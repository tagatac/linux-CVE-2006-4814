diff -urNp linux-5650/Documentation/Configure.help linux-5660/Documentation/Configure.help
--- linux-5650/Documentation/Configure.help
+++ linux-5660/Documentation/Configure.help
@@ -16457,6 +16457,15 @@ CONFIG_NFS_DIRECTIO
 
   If unsure, say N.
 
+Solaris ACL RPCs
+CONFIG_NFS_ACL
+  Allows manipulating POSIX Access Control Lists on NFS file systems
+  on NFS servers that implement the GETACL and SETACL extensions also
+  found in Solaris NFSv3. On Linux NFS servers the CONFIG_NFSD_ACL
+  option implements these extensions.
+
+  In doubt say N.
+
 Root file system on NFS
 CONFIG_ROOT_NFS
   If you want your Linux box to mount its whole root file system (the
@@ -16501,6 +16510,15 @@ CONFIG_NFSD_V3
   If you would like to include the NFSv3 server as well as the NFSv2
   server, say Y here.  If unsure, say Y.
 
+Solaris ACL RPCs
+CONFIG_NFSD_ACL
+  Allows manipulating POSIX Access Control Lists on exported file
+  systems. The client(s) must implement the GETACL and SETACL
+  extensions of Solaris NFSv3 in order to use these extensions. The
+  CONFIG_NFS_ACL option enables this.
+
+  In doubt say N.
+
 Provide NFS over TCP server support EXPERIMENTAL
 CONFIG_NFSD_TCP
   Enable NFS service over TCP connections.  This the officially
diff -urNp linux-5650/fs/Config.in linux-5660/fs/Config.in
--- linux-5650/fs/Config.in
+++ linux-5660/fs/Config.in
@@ -126,10 +126,12 @@ if [ "$CONFIG_NET" = "y" ]; then
    dep_tristate 'NFS file system support' CONFIG_NFS_FS $CONFIG_INET
    dep_mbool '  Provide NFSv3 client support' CONFIG_NFS_V3 $CONFIG_NFS_FS
    dep_mbool '  Allow direct I/O on NFS files (EXPERIMENTAL)' CONFIG_NFS_DIRECTIO $CONFIG_NFS_FS $CONFIG_EXPERIMENTAL
+   dep_mbool '  Solaris ACL RPCs (EXPERIMENTAL)' CONFIG_NFS_ACL $CONFIG_NFS_V3 $CONFIG_EXPERIMENTAL
    dep_bool '  Root file system on NFS' CONFIG_ROOT_NFS $CONFIG_NFS_FS $CONFIG_IP_PNP
 
    dep_tristate 'NFS server support' CONFIG_NFSD $CONFIG_INET
    dep_mbool '  Provide NFSv3 server support' CONFIG_NFSD_V3 $CONFIG_NFSD
+   dep_mbool '  Solaris ACL RPCs (EXPERIMENTAL)' CONFIG_NFSD_ACL $CONFIG_NFSD_V3 $CONFIG_EXPERIMENTAL
    dep_mbool '  Provide NFS server over TCP support (EXPERIMENTAL)' CONFIG_NFSD_TCP $CONFIG_NFSD $CONFIG_EXPERIMENTAL
 
    if [ "$CONFIG_NFS_FS" = "y" -o "$CONFIG_NFSD" = "y" ]; then
diff -urNp linux-5650/fs/Makefile linux-5660/fs/Makefile
--- linux-5650/fs/Makefile
+++ linux-5660/fs/Makefile
@@ -86,10 +86,13 @@ obj-y				+= binfmt_script.o
 
 obj-$(CONFIG_BINFMT_ELF)	+= binfmt_elf.o
 
-export-objs += mbcache.o posix_acl.o xattr_acl.o
+export-objs += mbcache.o posix_acl.o xattr_acl.o solaris_acl.o
 obj-$(CONFIG_FS_MBCACHE)	+= mbcache.o
 obj-$(CONFIG_FS_POSIX_ACL)	+= posix_acl.o xattr_acl.o
 
+obj-$(CONFIG_NFS_ACL)		+= solaris_acl.o
+obj-$(CONFIG_NFSD_ACL)		+= solaris_acl.o
+
 # persistent filesystems
 obj-y += $(join $(subdir-y),$(subdir-y:%=/%.o))
 
diff -urNp linux-5650/fs/lockd/svc.c linux-5660/fs/lockd/svc.c
--- linux-5650/fs/lockd/svc.c
+++ linux-5660/fs/lockd/svc.c
@@ -389,6 +389,7 @@ static struct svc_stat		nlmsvc_stats;
 
 #define NLM_NRVERS	(sizeof(nlmsvc_version)/sizeof(nlmsvc_version[0]))
 struct svc_program		nlmsvc_program = {
+	NULL,			/* last registered program */
 	NLM_PROGRAM,		/* program number */
 	1, NLM_NRVERS-1,	/* version range */
 	NLM_NRVERS,		/* number of entries in nlmsvc_version */
diff -urNp linux-5650/fs/nfs/Makefile linux-5660/fs/nfs/Makefile
--- linux-5650/fs/nfs/Makefile
+++ linux-5660/fs/nfs/Makefile
@@ -15,6 +15,7 @@ obj-y    := dir.o file.o flushd.o inode.
 obj-$(CONFIG_ROOT_NFS) += nfsroot.o mount_clnt.o      
 obj-$(CONFIG_NFS_V3) += nfs3proc.o nfs3xdr.o
 obj-$(CONFIG_NFS_DIRECTIO) += direct.o
+obj-$(CONFIG_NFS_ACL) += xattr.o
 
 obj-m   := $(O_TARGET)
 
diff -urNp linux-5650/fs/nfs/dir.c linux-5660/fs/nfs/dir.c
--- linux-5650/fs/nfs/dir.c
+++ linux-5660/fs/nfs/dir.c
@@ -72,6 +72,10 @@ struct inode_operations nfs_dir_inode_op
 	permission:	nfs_permission,
 	revalidate:	nfs_revalidate,
 	setattr:	nfs_notify_change,
+	listxattr:	nfs_listxattr,
+	getxattr:	nfs_getxattr,
+	setxattr:	nfs_setxattr,
+	removexattr:	nfs_removexattr,
 };
 
 static loff_t nfs_dir_llseek(struct file *file, loff_t offset, int origin)
diff -urNp linux-5650/fs/nfs/file.c linux-5660/fs/nfs/file.c
--- linux-5650/fs/nfs/file.c
+++ linux-5660/fs/nfs/file.c
@@ -63,6 +63,10 @@ struct inode_operations nfs_file_inode_o
 	permission:	nfs_permission,
 	revalidate:	nfs_revalidate,
 	setattr:	nfs_notify_change,
+	listxattr:	nfs_listxattr,
+	getxattr:	nfs_getxattr,
+	setxattr:	nfs_setxattr,
+	removexattr:	nfs_removexattr,
 };
 
 /* Hack for future NFS swap support */
diff -urNp linux-5650/fs/nfs/inode.c linux-5660/fs/nfs/inode.c
--- linux-5650/fs/nfs/inode.c
+++ linux-5660/fs/nfs/inode.c
@@ -33,6 +33,8 @@
 #include <linux/lockd/bind.h>
 #include <linux/smp_lock.h>
 #include <linux/seq_file.h>
+#include <linux/solaris_acl.h>
+#include <linux/sysctl.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -41,6 +43,48 @@
 #define NFSDBG_FACILITY		NFSDBG_VFS
 #define NFS_PARANOIA 1
 
+#ifdef CONFIG_NFS_ACL
+unsigned int nfs3_acl_max_entries = NFS3_ACL_MAX_ENTRIES;
+MODULE_PARM(nfs3_acl_max_entries, "i");
+MODULE_PARM_DESC(nfs3_acl_max_entries, "Max number of ACE objects to support in an NFS_ACL response");
+#endif
+
+static struct ctl_table_header *nfs_sysctl_table;
+#define CTL_UNNUMBERED		-2
+static ctl_table nfs_sysctl_files[] = {
+#ifdef CONFIG_NFS_ACL
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "nfs3_acl_max_entries",
+		.data		= &nfs3_acl_max_entries,
+		.maxlen		= sizeof(int),
+		.mode		= 0444,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+	{ .ctl_name = 0 }
+};
+
+static ctl_table nfs_sysctl_dir[] = {
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "nfs",
+		.mode		= 0555,
+		.child		= nfs_sysctl_files,
+	},
+	{ .ctl_name = 0 }
+};
+
+static ctl_table nfs_sysctl_root[] = {
+	{
+		.ctl_name	= CTL_FS,
+		.procname	= "fs",
+		.mode		= 0555,
+		.child		= nfs_sysctl_dir,
+	},
+	{ .ctl_name = 0 }
+};
+
 static struct inode * __nfs_fhget(struct super_block *, struct nfs_fh *, struct nfs_fattr *);
 void nfs_zap_caches(struct inode *);
 static void nfs_invalidate_inode(struct inode *);
@@ -53,6 +97,7 @@ static void nfs_clear_inode(struct inode
 static void nfs_umount_begin(struct super_block *);
 static int  nfs_statfs(struct super_block *, struct statfs *);
 static int  nfs_show_options(struct seq_file *, struct vfsmount *);
+extern void nfs3_fixup_xdr_tables(unsigned int max_acl);
 
 static struct super_operations nfs_sops = { 
 	read_inode:	nfs_read_inode,
@@ -65,6 +110,24 @@ static struct super_operations nfs_sops 
 	show_options:	nfs_show_options,
 };
 
+#ifdef CONFIG_NFS_ACL
+static struct rpc_stat		nfs_acl_rpcstat = { &nfs_acl_program };
+static struct rpc_version *	nfs_acl_version[] = {
+	NULL,
+	NULL,
+	NULL,
+	&nfs_acl_version3,
+};
+
+struct rpc_program		nfs_acl_program = {
+	"nfs_acl",
+	NFS3_ACL_PROGRAM,
+	sizeof(nfs_acl_version) / sizeof(nfs_acl_version[0]),
+	nfs_acl_version,
+	&nfs_acl_rpcstat,
+};
+#endif  /* CONFIG_NFS_ACL */
+
 /*
  * RPC cruft for NFS
  */
@@ -172,6 +235,11 @@ nfs_put_super(struct super_block *sb)
 	if ((rpc = server->client) != NULL)
 		rpc_shutdown_client(rpc);
 
+#ifdef CONFIG_NFS_ACL
+	if ((rpc = server->acl_client) != NULL)
+		rpc_shutdown_client(rpc);
+#endif  /* CONFIG_NFS_ACL */
+
 	nfs_reqlist_free(server);
 
 	if (!(server->flags & NFS_MOUNT_NONLM))
@@ -190,6 +258,11 @@ nfs_umount_begin(struct super_block *sb)
 	/* -EIO all pending I/O */
 	if ((rpc = server->client) != NULL)
 		rpc_killall_tasks(rpc);
+	
+#ifdef CONFIG_NFS_ACL
+	if ((rpc = server->acl_client) != NULL)
+		rpc_killall_tasks(rpc);
+#endif  /* CONFIG_NFS_ACL */
 }
 
 
@@ -451,6 +524,26 @@ nfs_read_super(struct super_block *sb, v
 	clnt->cl_chatty   = 1;
 	server->client    = clnt;
 
+#ifdef CONFIG_NFS_ACL
+	if (version == 3) {
+		clnt = rpc_create_client(xprt, server->hostname,
+					 &nfs_acl_program, version, authflavor);
+		if (clnt == NULL) {
+			rpc_shutdown_client(server->client);
+			goto out_no_client;
+		}
+
+		clnt->cl_intr      = (data->flags & NFS_MOUNT_INTR)? 1 : 0;
+		clnt->cl_softrtry  = (data->flags & NFS_MOUNT_SOFT)? 1 : 0;
+		clnt->cl_droppriv  = (data->flags & NFS_MOUNT_BROKEN_SUID) ?1:0;
+		clnt->cl_chatty    = 1;
+		server->acl_client = clnt;
+
+		/* Initially assume the nfs_acl program is supported */
+		server->flags |= (NFS_SOLARIS_GETACL | NFS_SOLARIS_SETACL);
+	}
+#endif  /* CONFIG_NFS_ACL */
+
 	/* Fire up rpciod if not yet running */
 	if (rpciod_up() != 0)
 		goto out_no_iod;
@@ -465,6 +558,9 @@ nfs_read_super(struct super_block *sb, v
 		data->flags &= ~NFS_MOUNT_VER3;
 		rpciod_down();
 		rpc_shutdown_client(server->client);
+#ifdef CONFIG_NFS_ACL
+		rpc_shutdown_client(server->acl_client);
+#endif  /* CONFIG_NFS_ACL */
 		goto nfsv3_try_again;
 	}
 
@@ -510,6 +606,9 @@ out_no_iod:
 	printk(KERN_WARNING "NFS: couldn't start rpciod!\n");
 out_shutdown:
 	rpc_shutdown_client(server->client);
+#ifdef CONFIG_NFS_ACL
+	rpc_shutdown_client(server->acl_client);
+#endif  /* CONFIG_NFS_ACL */
 	goto out_free_host;
 
 out_no_client:
@@ -642,6 +741,13 @@ nfs_invalidate_inode(struct inode *inode
 /* Don't use READDIRPLUS on directories that we believe are too large */
 #define NFS_LIMIT_READDIRPLUS (8*PAGE_SIZE)
 
+static struct inode_operations nfs_special_inode_operations = {
+	listxattr:	nfs_listxattr,
+	getxattr:	nfs_getxattr,
+	setxattr:	nfs_setxattr,
+	removexattr:	nfs_removexattr,
+};
+
 /*
  * Fill in inode information from the fattr.
  */
@@ -665,8 +771,10 @@ nfs_fill_inode(struct inode *inode, stru
 			NFS_FLAGS(inode) |= NFS_INO_ADVISE_RDPLUS;
 	} else if (S_ISLNK(inode->i_mode))
 		inode->i_op = &nfs_symlink_inode_operations;
-	else
+	else {
+		inode->i_op = &nfs_special_inode_operations;
 		init_special_inode(inode, inode->i_mode, fattr->rdev);
+	}
 	memcpy(&inode->u.nfs_i.fh, fh, sizeof(inode->u.nfs_i.fh));
 }
 
@@ -1232,6 +1340,10 @@ static int __init init_nfs_fs(void)
 {
 	int err;
 
+#ifdef CONFIG_NFS_ACL
+	nfs3_fixup_xdr_tables(nfs3_acl_max_entries);
+#endif
+
 	err = nfs_init_nfspagecache();
 	if (err)
 		return err;
@@ -1246,6 +1358,7 @@ static int __init init_nfs_fs(void)
 
 #ifdef CONFIG_PROC_FS
 	rpc_proc_register(&nfs_rpcstat);
+	nfs_sysctl_table = register_sysctl_table(nfs_sysctl_root,0);
 #endif
         return register_filesystem(&nfs_fs_type);
 }
@@ -1257,6 +1370,8 @@ static void __exit exit_nfs_fs(void)
 	nfs_destroy_nfspagecache();
 #ifdef CONFIG_PROC_FS
 	rpc_proc_unregister("nfs");
+	if (nfs_sysctl_table)
+		unregister_sysctl_table(nfs_sysctl_table);
 #endif
 	unregister_filesystem(&nfs_fs_type);
 }
diff -urNp linux-5650/fs/nfs/nfs3proc.c linux-5660/fs/nfs/nfs3proc.c
--- linux-5650/fs/nfs/nfs3proc.c
+++ linux-5660/fs/nfs/nfs3proc.c
@@ -14,6 +14,7 @@
 #include <linux/nfs.h>
 #include <linux/nfs3.h>
 #include <linux/nfs_fs.h>
+#include <linux/nfs_mount.h>
 
 #define NFSDBG_FACILITY		NFSDBG_PROC
 
@@ -522,6 +523,238 @@ nfs3_proc_pathconf(struct nfs_server *se
 	return status;
 }
 
+#ifdef CONFIG_NFS_ACL
+static int
+nfs3_proc_checkacls(struct inode *inode)
+{
+	struct nfs_server *server = NFS_SERVER(inode);
+	struct nfs_fattr fattr;
+	struct nfs3_getaclargs args;
+	struct nfs3_getaclres res = { &fattr };
+	int status;
+
+	if (!(server->flags & NFS_SOLARIS_GETACL) ||
+	    (server->flags & NFS_MOUNT_NOACL))
+		return -EOPNOTSUPP;
+
+	args.fh = NFS_FH(inode);
+	args.mask = NFS3_ACLCNT | NFS3_DFACLCNT;
+
+	dprintk("NFS call getacl\n");
+	status = rpc_call(NFS_ACL_CLIENT(inode), NFS3_ACL_PROC_GETACL,
+			  &args, &res, 0);
+	dprintk("NFS reply getacl: %d\n", status);
+
+	if (status) {
+		if (status == -ENOSYS) {
+			dprintk("NFS_ACL GETACL RPC not supported "
+				"(will not retry)\n");
+			server->flags &= ~NFS_SOLARIS_GETACL;
+			status = -EOPNOTSUPP;
+		} else if (status == -ENOTSUPP)
+			status = -EOPNOTSUPP;
+		goto getout;
+	}
+	if ((args.mask & res.mask) != args.mask) {
+		status = -EIO;
+		goto getout;
+	}
+
+	status = nfs_refresh_inode(inode, &fattr);
+
+getout:
+	posix_acl_release(res.acl_access);
+	posix_acl_release(res.acl_default);
+
+	if (!status) {
+		/* The (count > 4) test will exclude ACL entries from the list
+		   of names even if their ACL_GROUP_ENTRY and ACL_MASK have
+		   different permissions. Getacl still returns these as
+		   four-entry ACLs, instead of minimal (three-entry) ACLs. */
+		   
+		if ((args.mask & NFS3_ACLCNT) && res.acl_access_count > 4)
+			status |= ACL_TYPE_ACCESS;
+		if ((args.mask & NFS3_DFACLCNT) && res.acl_default_count > 0)
+			status |= ACL_TYPE_DEFAULT;
+	}
+	return status;
+}
+#endif  /* CONFIG_NFS_ACL */
+
+#ifdef CONFIG_NFS_ACL
+static struct posix_acl *
+nfs3_proc_getacl(struct inode *inode, int type)
+{
+	struct nfs_server *server = NFS_SERVER(inode);
+	struct nfs_fattr fattr;
+	struct nfs3_getaclargs args;
+	struct nfs3_getaclres res = { &fattr };
+	struct posix_acl *acl = NULL;
+	int status;
+
+	if (!(server->flags & NFS_SOLARIS_GETACL) ||
+	    (server->flags & NFS_MOUNT_NOACL))
+		return ERR_PTR(-EOPNOTSUPP);
+
+	args.fh = NFS_FH(inode);
+	switch(type) {
+		case ACL_TYPE_ACCESS:
+			args.mask = NFS3_ACLCNT|NFS3_ACL;
+			break;
+
+		case ACL_TYPE_DEFAULT:
+			args.mask = NFS3_DFACLCNT|NFS3_DFACL;
+			break;
+
+		default:
+			return ERR_PTR(-EINVAL);
+	}
+
+	dprintk("NFS call getacl\n");
+	status = rpc_call(NFS_ACL_CLIENT(inode), NFS3_ACL_PROC_GETACL,
+			  &args, &res, 0);
+	dprintk("NFS reply getacl: %d\n", status);
+
+	if (status) {
+		if (status == -ENOSYS) {
+			dprintk("NFS_ACL GETACL RPC not supported "
+				"(will not retry)\n");
+			server->flags &= ~NFS_SOLARIS_GETACL;
+			status = -EOPNOTSUPP;
+		} else if (status == -ENOTSUPP)
+			status = -EOPNOTSUPP;
+		goto getout;
+	}
+	if ((args.mask & res.mask) != args.mask) {
+		status = -EIO;
+		goto getout;
+	}
+
+	if (type == ACL_TYPE_ACCESS) {
+		if (res.acl_access) {
+			mode_t mode = inode->i_mode;
+			if (!posix_acl_equiv_mode(res.acl_access, &mode) &&
+			    inode->i_mode == mode) {
+				posix_acl_release(res.acl_access);
+				res.acl_access = NULL;
+			}
+		}
+		acl = res.acl_access;
+		res.acl_access = NULL;
+	} else {
+		acl = res.acl_default;
+		res.acl_default = NULL;
+	}
+
+	status = nfs_refresh_inode(inode, &fattr);
+
+getout:
+	posix_acl_release(res.acl_access);
+	posix_acl_release(res.acl_default);
+
+	if (status) {
+		posix_acl_release(acl);
+		acl = ERR_PTR(status);
+	}
+	return acl;
+}
+#endif  /* CONFIG_NFS_ACL */
+
+#ifdef CONFIG_NFS_ACL
+static int
+nfs3_proc_setacl(struct inode *inode, int type, struct posix_acl *acl)
+{
+	struct nfs_server *server = NFS_SERVER(inode);
+	struct nfs_fattr fattr;
+	struct nfs3_setaclargs args = { };
+	int status;
+
+	if (!(server->flags & NFS_SOLARIS_SETACL) ||
+	    (server->flags & NFS_MOUNT_NOACL))
+		return -EOPNOTSUPP;
+
+	/* We are doing this here, because XDR marshalling can only
+	   return -ENOMEM. */
+	if (acl && acl->a_count > nfs3_acl_max_entries)
+		return -EINVAL;
+	args.inode = inode;
+	args.mask = NFS3_ACL|NFS3_DFACL;
+	if (S_ISDIR(inode->i_mode)) {
+		switch(type) {
+			case ACL_TYPE_ACCESS:
+				args.acl_access = acl;
+				args.acl_default = NFS_PROTO(inode)->getacl(
+					inode, ACL_TYPE_DEFAULT);
+				status = PTR_ERR(args.acl_default);
+				if (IS_ERR(args.acl_default)) {
+					args.acl_default = NULL;
+					goto cleanup;
+				}
+				break;
+
+			case ACL_TYPE_DEFAULT:
+				args.acl_access = NFS_PROTO(inode)->getacl(
+					inode, ACL_TYPE_ACCESS);
+				status = PTR_ERR(args.acl_access);
+				if (IS_ERR(args.acl_access)) {
+					args.acl_access = NULL;
+					goto cleanup;
+				}
+				args.acl_default = acl;
+				break;
+
+			default:
+				status = -EINVAL;
+				goto cleanup;
+		}
+	} else {
+		status = -EINVAL;
+		if (type != ACL_TYPE_ACCESS)
+			goto cleanup;
+		args.mask = NFS3_ACL;
+		args.acl_access = acl;
+	}
+	if (args.acl_access == NULL) {
+		args.acl_access = posix_acl_from_mode(inode->i_mode,
+						      GFP_KERNEL);
+		status = PTR_ERR(args.acl_access);
+		if (IS_ERR(args.acl_access)) {
+			args.acl_access = NULL;
+			goto cleanup;
+		}
+	}
+	args.mask = NFS3_ACL | (args.acl_default ? NFS3_DFACL : 0);
+
+	dprintk("NFS call setacl\n");
+	status = rpc_call(NFS_ACL_CLIENT(inode), NFS3_ACL_PROC_SETACL,
+			  &args, &fattr, 0);
+	dprintk("NFS reply setacl: %d\n", status);
+
+	if (status) {
+		if (status == -ENOSYS) {
+			dprintk("NFS_ACL SETACL RPC not supported"
+				"(will not retry)\n");
+			server->flags &= ~NFS_SOLARIS_SETACL;
+			status = -EOPNOTSUPP;
+		} else if (status == -ENOTSUPP)
+			status = -EOPNOTSUPP;
+	} else {
+		/* Force an attribute cache update if the file mode
+		 * has changed. */
+		if (inode->i_mode != fattr.mode)
+			NFS_CACHEINV(inode);
+		status = nfs_refresh_inode(inode, &fattr);
+	}
+
+cleanup:
+	if (args.acl_access != acl)
+		posix_acl_release(args.acl_access);
+	if (args.acl_default != acl)
+		posix_acl_release(args.acl_default);
+	return status;
+}
+#endif  /* CONFIG_NFS_ACL */
+
 extern u32 *nfs3_decode_dirent(u32 *, struct nfs_entry *, int);
 
 struct nfs_rpc_ops	nfs_v3_clientops = {
@@ -550,4 +783,9 @@ struct nfs_rpc_ops	nfs_v3_clientops = {
 	nfs3_proc_fsinfo,
 	nfs3_proc_pathconf,
 	nfs3_decode_dirent,
+#ifdef CONFIG_NFS_ACL
+	nfs3_proc_getacl,
+	nfs3_proc_setacl,
+	nfs3_proc_checkacls,
+#endif  /* CONFIG_NFS_ACL */
 };
diff -urNp linux-5650/fs/nfs/nfs3xdr.c linux-5660/fs/nfs/nfs3xdr.c
--- linux-5650/fs/nfs/nfs3xdr.c
+++ linux-5660/fs/nfs/nfs3xdr.c
@@ -21,6 +21,7 @@
 #include <linux/nfs.h>
 #include <linux/nfs3.h>
 #include <linux/nfs_fs.h>
+#include <linux/solaris_acl.h>
 
 #define NFSDBG_FACILITY		NFSDBG_XDR
 
@@ -47,6 +48,7 @@ extern int			nfs_stat_to_errno(int);
 #define NFS3_fsinfo_sz		
 #define NFS3_pathconf_sz		
 #define NFS3_entry_sz		NFS3_filename_sz+3
+#define NFS3_acl_sz		1+NFS3_ACL_MAX_ENTRIES*3
 
 #define NFS3_enc_void_sz	0
 #define NFS3_sattrargs_sz	NFS3_fh_sz+NFS3_sattr_sz+3
@@ -63,6 +65,8 @@ extern int			nfs_stat_to_errno(int);
 #define NFS3_linkargs_sz		NFS3_fh_sz+NFS3_diropargs_sz
 #define NFS3_readdirargs_sz	NFS3_fh_sz+2
 #define NFS3_commitargs_sz	NFS3_fh_sz+3
+#define NFS3_getaclargs_sz	NFS3_fh_sz+1
+#define NFS3_setaclargs_sz	NFS3_fh_sz+1+2*(1+NFS3_acl_sz)
 
 #define NFS3_dec_void_sz	0
 #define NFS3_attrstat_sz	1+NFS3_fattr_sz
@@ -80,6 +84,8 @@ extern int			nfs_stat_to_errno(int);
 #define NFS3_fsinfores_sz	1+NFS3_post_op_attr_sz+12
 #define NFS3_pathconfres_sz	1+NFS3_post_op_attr_sz+6
 #define NFS3_commitres_sz	1+NFS3_wcc_data_sz+2
+#define NFS3_getaclres_sz	1+NFS3_post_op_attr_sz+1+2*(1+NFS3_acl_sz)
+#define NFS3_setaclres_sz	1+NFS3_post_op_attr_sz
 
 /*
  * Map file type to S_IFMT bits
@@ -658,6 +664,50 @@ nfs3_xdr_commitargs(struct rpc_rqst *req
 	return 0;
 }
 
+#ifdef CONFIG_NFS_ACL
+/*
+ * Encode GETACL arguments
+ */
+static int
+nfs3_xdr_getaclargs(struct rpc_rqst *req, u32 *p,
+		    struct nfs3_getaclargs *args)
+{
+	p = xdr_encode_fhandle(p, args->fh);
+	*p++ = htonl(args->mask);
+	req->rq_slen = xdr_adjust_iovec(req->rq_svec, p);
+
+	return 0;
+}
+#endif  /* CONFIG_NFS_ACL */
+
+#ifdef CONFIG_NFS_ACL
+/*
+ * Encode SETACL arguments
+ */
+static int
+nfs3_xdr_setaclargs(struct rpc_rqst *req, u32 *p,
+		    struct nfs3_setaclargs *args)
+{
+	struct iovec *iov = req->rq_svec;
+	u32 *end = (u32 *)((u8 *)iov->iov_base + iov->iov_len);
+	struct posix_acl *acl;
+
+	p = xdr_encode_fhandle(p, NFS_FH(args->inode));
+	*p++ = htonl(args->mask);
+	acl = (args->mask & NFS3_ACL) ? args->acl_access : NULL;
+	if (!(p = nfs_acl_encode_limit(p, end, args->inode, acl,
+			1, 0, nfs3_acl_max_entries)))
+		return -ENOMEM;
+	acl = (args->mask & NFS3_DFACL) ? args->acl_default : NULL;
+	if (!(p = nfs_acl_encode_limit(p, end, args->inode, acl,
+			1, NFS3_ACL_DEFAULT, nfs3_acl_max_entries)))
+		return -ENOMEM;
+	req->rq_slen = xdr_adjust_iovec(req->rq_svec, p);
+	
+	return 0;
+}
+#endif  /* CONFIG_NFS_ACL */
+
 /*
  * NFS XDR decode functions
  */
@@ -1008,6 +1058,59 @@ nfs3_xdr_commitres(struct rpc_rqst *req,
 	return 0;
 }
 
+#ifdef CONFIG_NFS_ACL
+/*
+ * Decode GETACL reply
+ */
+static int
+nfs3_xdr_getaclres(struct rpc_rqst *req, u32 *p,
+		   struct nfs3_getaclres *res)
+{
+	struct iovec *iov = req->rq_rvec;
+	u32 *end = (u32 *)((u8 *)iov->iov_base + iov->iov_len);
+	int status = ntohl(*p++);
+	struct posix_acl **acl;
+	unsigned int *aclcnt;
+
+	if (status != 0)
+		return -nfs_stat_to_errno(status);
+
+	p = xdr_decode_post_op_attr(p, res->fattr);
+
+	res->mask = ntohl(*p++);
+	if (res->mask & ~(NFS3_ACL|NFS3_ACLCNT|NFS3_DFACL|NFS3_DFACLCNT))
+		return -EINVAL;
+		
+	/* res->acl_{access,default} are released in nfs3_proc_getacl. */
+	acl = (res->mask & NFS3_ACL) ? &res->acl_access : NULL;
+	aclcnt = (res->mask & NFS3_ACLCNT) ? &res->acl_access_count : NULL;
+	if (!(p = nfs_acl_decode_limit(p, end, aclcnt, acl, nfs3_acl_max_entries)))
+		return -EINVAL;
+
+	acl = (res->mask & NFS3_DFACL) ? &res->acl_default : NULL;
+	aclcnt = (res->mask & NFS3_DFACLCNT) ? &res->acl_default_count : NULL;
+	if (!(p = nfs_acl_decode_limit(p, end, aclcnt, acl, nfs3_acl_max_entries)))
+		return -EINVAL;
+	return 0;
+}
+#endif  /* CONFIG_NFS_ACL */
+
+#ifdef CONFIG_NFS_ACL
+/*
+ * Decode setacl reply.
+ */
+static int
+nfs3_xdr_setaclres(struct rpc_rqst *req, u32 *p, struct nfs_fattr *fattr)
+{
+	int status = ntohl(*p++);
+
+	if (status)
+		return -nfs_stat_to_errno(status);
+	xdr_decode_post_op_attr(p, fattr);
+	return 0;
+}
+#endif  /* CONFIG_NFS_ACL */
+
 #ifndef MAX
 # define MAX(a, b)	(((a) > (b))? (a) : (b))
 #endif
@@ -1051,3 +1154,24 @@ struct rpc_version		nfs_version3 = {
 	nfs3_procedures
 };
 
+#ifdef CONFIG_NFS_ACL
+static struct rpc_procinfo	nfs3_acl_procedures[] = {
+  PROC(null,		enc_void,	dec_void, 0),
+  PROC(getacl,		getaclargs,	getaclres, 1),
+  PROC(setacl,		setaclargs,	setaclres, 0),
+};
+
+struct rpc_version		nfs_acl_version3 = {
+	3,
+	sizeof(nfs3_acl_procedures)/sizeof(nfs3_acl_procedures[0]),
+	nfs3_acl_procedures
+};
+
+void nfs3_fixup_xdr_tables(unsigned int acl_max)
+{
+	nfs3_acl_procedures[1].p_bufsiz =
+		(((acl_max*3)+2)*2)+1+NFS3_post_op_attr_sz+1;
+	nfs3_acl_procedures[2].p_bufsiz =
+		(((acl_max*3)+2)*2)+1+NFS3_fh_sz;
+}
+#endif  /* CONFIG_NFS_ACL */
diff -urNp linux-5650/fs/nfs/xattr.c linux-5660/fs/nfs/xattr.c
--- linux-5650/fs/nfs/xattr.c
+++ linux-5660/fs/nfs/xattr.c
@@ -0,0 +1,114 @@
+#include <linux/fs.h>
+#include <linux/nfs.h>
+#include <linux/nfs3.h>
+#include <linux/nfs_fs.h>
+#include <linux/xattr_acl.h>
+
+ssize_t
+nfs_listxattr(struct dentry *dentry, char *buffer, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	int error=0, pos=0, len=0;
+
+	error = -EOPNOTSUPP;
+	if (NFS_PROTO(inode)->version == 3 && NFS_PROTO(inode)->checkacls)
+		error = NFS_PROTO(inode)->checkacls(inode);
+	if (error < 0)
+		return error;
+	
+#	define output(s) do {						\
+			if (pos + sizeof(s) <= size) {			\
+				memcpy(buffer + pos, s, sizeof(s));	\
+				pos += sizeof(s);			\
+			}						\
+			len += sizeof(s);				\
+		} while(0)
+
+	if (error & ACL_TYPE_ACCESS)
+		output("system.posix_acl_access");
+	if (error & ACL_TYPE_DEFAULT)
+		output("system.posix_acl_default");
+
+#	undef output
+
+	if (!buffer || len <= size)
+		return len;
+	return -ERANGE;
+}
+
+ssize_t
+nfs_getxattr(struct dentry *dentry, const char *name, void *buffer, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	struct posix_acl *acl;
+	int type, error = 0;
+
+	if (strcmp(name, XATTR_NAME_ACL_ACCESS) == 0)
+		type = ACL_TYPE_ACCESS;
+	else if (strcmp(name, XATTR_NAME_ACL_DEFAULT) == 0)
+		type = ACL_TYPE_DEFAULT;
+	else
+		return -EOPNOTSUPP;
+
+	acl = ERR_PTR(-EOPNOTSUPP);
+	if (NFS_PROTO(inode)->version == 3 && NFS_PROTO(inode)->getacl)
+		acl = NFS_PROTO(inode)->getacl(inode, type);
+	if (IS_ERR(acl))
+		return PTR_ERR(acl);
+	else if (acl) {
+		if (type == ACL_TYPE_ACCESS && acl->a_count == 0)
+			error = -ENODATA;
+		else
+			error = posix_acl_to_xattr(acl, buffer, size);
+		posix_acl_release(acl);
+	} else
+		error = -ENODATA;
+
+	return error;
+}
+
+int
+nfs_setxattr(struct dentry *dentry, const char *name,
+	     const void *value, size_t size, int flags)
+{
+	struct inode *inode = dentry->d_inode;
+	struct posix_acl *acl;
+	int type, error;
+
+	if (strcmp(name, XATTR_NAME_ACL_ACCESS) == 0)
+		type = ACL_TYPE_ACCESS;
+	else if (strcmp(name, XATTR_NAME_ACL_DEFAULT) == 0)
+		type = ACL_TYPE_DEFAULT;
+	else
+		return -EOPNOTSUPP;
+	if (NFS_PROTO(inode)->version != 3 || !NFS_PROTO(inode)->setacl)
+		return -EOPNOTSUPP;
+
+	acl = posix_acl_from_xattr(value, size);
+	if (IS_ERR(acl))
+		return PTR_ERR(acl);
+	error = NFS_PROTO(inode)->setacl(inode, type, acl);
+	posix_acl_release(acl);
+
+	return error;
+}
+
+int
+nfs_removexattr(struct dentry *dentry, const char *name)
+{
+	struct inode *inode = dentry->d_inode;
+	int error, type;
+
+	if (strcmp(name, XATTR_NAME_ACL_ACCESS) == 0)
+		type = ACL_TYPE_ACCESS;
+	else if (strcmp(name, XATTR_NAME_ACL_DEFAULT) == 0)
+		type = ACL_TYPE_DEFAULT;
+	else
+		return -EOPNOTSUPP;
+
+	error = -EOPNOTSUPP;
+	if (NFS_PROTO(inode)->version == 3 && NFS_PROTO(inode)->setacl)
+		error = NFS_PROTO(inode)->setacl(inode, type, NULL);
+
+	return error;
+}
diff -urNp linux-5650/fs/nfsd/nfs3proc.c linux-5660/fs/nfsd/nfs3proc.c
--- linux-5650/fs/nfsd/nfs3proc.c
+++ linux-5660/fs/nfsd/nfs3proc.c
@@ -628,6 +628,105 @@ nfsd3_proc_commit(struct svc_rqst * rqst
 	RETURN_STATUS(nfserr);
 }
 
+#ifdef CONFIG_NFSD_ACL
+/*
+ * Get the Access and/or Default ACL of a file.
+ */
+static int
+nfsd3_proc_getacl(struct svc_rqst * rqstp, struct nfsd3_getaclargs *argp,
+					     struct nfsd3_getaclres *resp)
+{
+	svc_fh *fh;
+	struct posix_acl *acl;
+	int nfserr = 0;
+
+	fh = fh_copy(&resp->fh, &argp->fh);
+	if ((nfserr = fh_verify(rqstp, &resp->fh, 0, MAY_NOP)))
+		RETURN_STATUS(nfserr_inval);
+	
+	if (argp->mask & ~(NFS3_ACL|NFS3_ACLCNT|NFS3_DFACL|NFS3_DFACLCNT))
+		RETURN_STATUS(nfserr_inval);
+	resp->mask = argp->mask;
+
+	if (resp->mask & (NFS3_ACL|NFS3_ACLCNT)) {
+		acl = nfsd_get_posix_acl(fh, ACL_TYPE_ACCESS);
+		if (IS_ERR(acl)) {
+			int err = PTR_ERR(acl);
+
+			if (err == -ENODATA || err == -EOPNOTSUPP)
+				acl = NULL;
+			else {
+				nfserr = nfserrno(err);
+				goto fail;
+			}
+		}
+		if (acl == NULL) {
+			/* Solaris returns the inode's minimum ACL. */
+
+			struct inode *inode = fh->fh_dentry->d_inode;
+			acl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);
+		}
+		resp->acl_access = acl;
+	}
+	if (resp->mask & (NFS3_DFACL|NFS3_DFACLCNT)) {
+		/* Check how Solaris handles requests for the Default ACL
+		   of a non-directory! */
+
+		acl = nfsd_get_posix_acl(fh, ACL_TYPE_DEFAULT);
+		if (IS_ERR(acl)) {
+			int err = PTR_ERR(acl);
+
+			if (err == -ENODATA || err == -EOPNOTSUPP)
+				acl = NULL;
+			else {
+				nfserr = nfserrno(err);
+				goto fail;
+			}
+		}
+		resp->acl_default = acl;
+	}
+
+	/* resp->acl_{access,default} are released in nfs3svc_release_getacl. */
+	RETURN_STATUS(0);
+
+fail:
+	posix_acl_release(resp->acl_access);
+	posix_acl_release(resp->acl_default);
+	RETURN_STATUS(nfserr);
+}
+#endif  /* CONFIG_NFSD_ACL */
+
+#ifdef CONFIG_NFSD_ACL
+/*
+ * Set the Access and/or Default ACL of a file.
+ */
+static int
+nfsd3_proc_setacl(struct svc_rqst * rqstp, struct nfsd3_setaclargs *argp,
+					     struct nfsd3_attrstat *resp)
+{
+	svc_fh *fh;
+	int nfserr = 0;
+
+	fh = fh_copy(&resp->fh, &argp->fh);
+	nfserr = fh_verify(rqstp, &resp->fh, 0, MAY_NOP);
+	
+	if (!nfserr) {
+		nfserr = nfserrno( nfsd_set_posix_acl(
+			fh, ACL_TYPE_ACCESS, argp->acl_access) );
+	}
+	if (!nfserr) {
+		nfserr = nfserrno( nfsd_set_posix_acl(
+			fh, ACL_TYPE_DEFAULT, argp->acl_default) );
+	}
+
+	/* argp->acl_{access,default} may have been allocated in
+	   nfs3svc_decode_setaclargs. */
+	posix_acl_release(argp->acl_access);
+	posix_acl_release(argp->acl_default);
+	RETURN_STATUS(nfserr);
+}
+#endif  /* CONFIG_NFSD_ACL */
+
 
 /*
  * NFSv3 Server procedures.
@@ -644,6 +743,7 @@ nfsd3_proc_commit(struct svc_rqst * rqst
 #define nfsd3_fhandleres		nfsd3_attrstat
 #define nfsd3_attrstatres		nfsd3_attrstat
 #define nfsd3_wccstatres		nfsd3_attrstat
+#define nfsd3_setaclres			nfsd3_attrstat
 #define nfsd3_createres			nfsd3_diropres
 #define nfsd3_voidres			nfsd3_voidargs
 struct nfsd3_voidargs { int dummy; };
@@ -665,6 +765,7 @@ struct nfsd3_voidargs { int dummy; };
 #define AT 21		/* attributes */
 #define pAT (1+AT)	/* post attributes - conditional */
 #define WC (7+pAT)	/* WCC attributes */
+#define ACL (1+NFS3_ACL_MAX_ENTRIES*3)  /* Access Control List */
 
 struct svc_procedure		nfsd_procedures3[22] = {
   PROC(null,	 void,		void,		void,	 RC_NOCACHE, ST),
@@ -690,3 +791,17 @@ struct svc_procedure		nfsd_procedures3[2
   PROC(pathconf, fhandle,	pathconf,	void,     RC_NOCACHE, ST+pAT+6),
   PROC(commit,	 commit,	commit,		fhandle,  RC_NOCACHE, ST+WC+2),
 };
+
+#ifdef CONFIG_NFSD_ACL
+struct svc_procedure		nfsd_acl_procedures3[] = {
+  PROC(null,	 void,		void,		void,	 RC_NOCACHE, ST),
+  PROC(getacl,	 getacl,	getacl,		getacl,  RC_NOCACHE, ST+1+2*(1+ACL)),
+  PROC(setacl,	 setacl,	setacl,		fhandle, RC_NOCACHE, ST+pAT)
+};
+
+void nfs3_fixup_proc_tables(unsigned int acl_max)
+{
+	nfsd_acl_procedures3[1].pc_xdrressize = (((acl_max*3)+2)*2)+1+ST;
+}
+
+#endif  /* CONFIG_NFSD_ACL */
diff -urNp linux-5650/fs/nfsd/nfs3xdr.c linux-5660/fs/nfsd/nfs3xdr.c
--- linux-5650/fs/nfsd/nfs3xdr.c
+++ linux-5660/fs/nfsd/nfs3xdr.c
@@ -15,6 +15,8 @@
 #include <linux/nfsd/nfsd.h>
 #include <linux/nfsd/xdr3.h>
 
+#include <linux/solaris_acl.h>
+
 #define NFSDDBG_FACILITY		NFSDDBG_XDR
 
 #ifdef NFSD_OPTIMIZE_SPACE
@@ -520,6 +522,51 @@ nfs3svc_decode_commitargs(struct svc_rqs
 	return xdr_argsize_check(rqstp, p);
 }
 
+#ifdef CONFIG_NFSD_ACL
+int
+nfs3svc_decode_getaclargs(struct svc_rqst *rqstp, u32 *p,
+					struct nfsd3_getaclargs *args)
+{
+	if (!(p = decode_fh(p, &args->fh)))
+		return 0;
+	args->mask = ntohl(*p); p++;
+
+	return xdr_argsize_check(rqstp, p);
+}
+#endif  /* CONFIG_NFS_ACL */
+
+#ifdef CONFIG_NFSD_ACL
+int
+nfs3svc_decode_setaclargs(struct svc_rqst *rqstp, u32 *p,
+					struct nfsd3_setaclargs *args)
+{
+        struct svc_buf  *buf = &rqstp->rq_argbuf;
+	u32 *end = buf->base + buf->buflen;
+	struct posix_acl **acl;
+
+	if (!(p = decode_fh(p, &args->fh)))
+		return 0;
+	args->mask = ntohl(*p++);
+	if (args->mask & ~(NFS3_ACL|NFS3_ACLCNT|NFS3_DFACL|NFS3_DFACLCNT) ||
+	    !xdr_argsize_check(rqstp, p))
+		return 0;
+	
+	/* argp->acl_{access,default} are released in nfsd3_proc_setacl. */
+	acl = (args->mask & NFS3_ACL) ? &args->acl_access : NULL;
+	if (!(p = nfs_acl_decode_limit(p, end, NULL, acl, nfsd3_acl_max_entries)))
+		return 0;
+	
+	acl = (args->mask & NFS3_DFACL) ? &args->acl_default : NULL;
+	if (!(p = nfs_acl_decode_limit(p, end, NULL, acl, nfsd3_acl_max_entries))) {
+		posix_acl_release(args->acl_access);
+		args->acl_access = NULL;
+		return 0;
+	}
+	
+	return 1;
+}
+#endif  /* CONFIG_NFS_ACL */
+
 /*
  * XDR encode functions
  */
@@ -849,6 +896,46 @@ nfs3svc_encode_commitres(struct svc_rqst
 	return xdr_ressize_check(rqstp, p);
 }
 
+
+#ifdef CONFIG_NFSD_ACL
+/* GETACL */
+int
+nfs3svc_encode_getaclres(struct svc_rqst *rqstp, u32 *p,
+					struct nfsd3_getaclres *resp)
+{
+	struct dentry *dentry = resp->fh.fh_dentry;
+	struct svc_buf *buf = &rqstp->rq_resbuf;
+	u32 *end = buf->base + buf->buflen;
+
+	if (resp->status == 0 && dentry && dentry->d_inode) {
+		struct inode *inode = dentry->d_inode;
+
+		p = encode_post_op_attr(rqstp, p, &resp->fh);
+		*p++ = htonl(resp->mask);
+		if (!(p = nfs_acl_encode_limit(p, end, inode, resp->acl_access,
+				   resp->mask & NFS3_ACL, 0, nfsd3_acl_max_entries)))
+			return 0;
+		if (!(p = nfs_acl_encode_limit(p, end, inode, resp->acl_default,
+		    			 resp->mask & NFS3_DFACL,
+					 NFS3_ACL_DEFAULT, nfsd3_acl_max_entries)))
+			return 0;
+	}
+
+	return xdr_ressize_check(rqstp, p);
+}
+#endif  /* CONFIG_NFS_ACL */
+
+/* SETACL */
+int
+nfs3svc_encode_setaclres(struct svc_rqst *rqstp, u32 *p,
+					struct nfsd3_attrstat *resp)
+{
+	if (resp->status == 0)
+		p = encode_post_op_attr(rqstp, p, &resp->fh);
+
+	return xdr_ressize_check(rqstp, p);
+}
+
 /*
  * XDR release functions
  */
@@ -868,3 +955,15 @@ nfs3svc_release_fhandle2(struct svc_rqst
 	fh_put(&resp->fh2);
 	return 1;
 }
+
+#ifdef CONFIG_NFSD_ACL
+int
+nfs3svc_release_getacl(struct svc_rqst *rqstp, u32 *p,
+					struct nfsd3_getaclres *resp)
+{
+	fh_put(&resp->fh);
+	posix_acl_release(resp->acl_access);
+	posix_acl_release(resp->acl_default);
+	return 1;
+}
+#endif  /* CONFIG_NFS_ACL */
diff -urNp linux-5650/fs/nfsd/nfsctl.c linux-5660/fs/nfsd/nfsctl.c
--- linux-5650/fs/nfsd/nfsctl.c
+++ linux-5660/fs/nfsd/nfsctl.c
@@ -22,9 +22,11 @@
 #include <linux/slab.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
+#include <linux/sysctl.h>
 
 #include <linux/nfs.h>
 #include <linux/sunrpc/svc.h>
+#include <linux/solaris_acl.h>
 #include <linux/nfsd/nfsd.h>
 #include <linux/nfsd/cache.h>
 #include <linux/nfsd/xdr.h>
@@ -35,6 +37,12 @@
 #include <linux/smp_lock.h>
 #include <linux/init.h>
 
+#ifdef CONFIG_NFSD_ACL
+unsigned int nfsd3_acl_max_entries = NFS3_ACL_MAX_ENTRIES;
+MODULE_PARM(nfsd3_acl_max_entries, "i");
+MODULE_PARM_DESC(nfsd3_acl_max_entries, "Max number of ACE objects to support in an NFS_ACL response");
+#endif
+
 static int	nfsctl_svc(struct nfsctl_svc *data);
 static int	nfsctl_addclient(struct nfsctl_client *data);
 static int	nfsctl_delclient(struct nfsctl_client *data);
@@ -47,6 +55,42 @@ static int	nfsctl_getfs(struct nfsctl_fs
 static int	nfsctl_ugidupdate(struct nfsctl_ugidmap *data);
 #endif
 
+static struct ctl_table_header *nfsd_sysctl_table;
+#define CTL_UNNUMBERED		-2
+static ctl_table nfsd_sysctl_files[] = {
+#ifdef CONFIG_NFSD_ACL
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "nfsd3_acl_max_entries",
+		.data		= &nfsd3_acl_max_entries,
+		.maxlen		= sizeof(int),
+		.mode		= 0444,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
+	{ .ctl_name = 0 }
+};
+
+static ctl_table nfsd_sysctl_dir[] = {
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "nfsd",
+		.mode		= 0555,
+		.child		= nfsd_sysctl_files,
+	},
+	{ .ctl_name = 0 }
+};
+
+static ctl_table nfsd_sysctl_root[] = {
+	{
+		.ctl_name	= CTL_FS,
+		.procname	= "fs",
+		.mode		= 0555,
+		.child		= nfsd_sysctl_dir,
+	},
+	{ .ctl_name = 0 }
+};
+
 extern struct seq_operations nfs_exports_op;
 static int exports_open(struct inode *inode, struct file *file)
 {
@@ -321,11 +365,15 @@ nfsd_init(void)
 #ifdef MODULE
 	nfsd_linkage = &nfsd_linkage_s;
 #endif
+#ifdef CONFIG_NFSD_ACL
+	nfs3_fixup_proc_tables(nfsd3_acl_max_entries);
+#endif
 	nfsd_stat_init();	/* Statistics */
 	nfsd_cache_init();	/* RPC reply cache */
 	nfsd_export_init();	/* Exports table */
 	nfsd_lockd_init();	/* lockd->nfsd callbacks */
 	proc_export_init();
+	nfsd_sysctl_table = register_sysctl_table(nfsd_sysctl_root, 0);
 	return 0;
 }
 
@@ -338,6 +386,8 @@ nfsd_exit(void)
 #ifdef MODULE
 	nfsd_linkage = NULL;
 #endif
+	if (nfsd_sysctl_table)
+		unregister_sysctl_table(nfsd_sysctl_table);
 	nfsd_export_shutdown();
 	nfsd_cache_shutdown();
 	remove_proc_entry("fs/nfs/exports", NULL);
diff -urNp linux-5650/fs/nfsd/nfsproc.c linux-5660/fs/nfsd/nfsproc.c
--- linux-5650/fs/nfsd/nfsproc.c
+++ linux-5660/fs/nfsd/nfsproc.c
@@ -595,6 +595,8 @@ nfserrno (int errno)
 #endif
 		{ nfserr_stale, -ESTALE },
 		{ nfserr_dropit, -ENOMEM },
+		{ nfserr_notsupp, -EOPNOTSUPP },
+		{ nfserr_notsupp, -ENOTSUPP },
 		{ -1, -EIO }
 	};
 	int	i;
diff -urNp linux-5650/fs/nfsd/nfssvc.c linux-5660/fs/nfsd/nfssvc.c
--- linux-5650/fs/nfsd/nfssvc.c
+++ linux-5660/fs/nfsd/nfssvc.c
@@ -34,7 +34,10 @@
 #include <linux/lockd/bind.h>
 
 #define NFSDDBG_FACILITY	NFSDDBG_SVC
-#define NFSD_BUFSIZE		(1024 + NFSSVC_MAXBLKSIZE)
+/* The nfs_acl RPCs may transmit two ACLs with 1024 entries each! */
+#define NFSSVC_MAXACLSIZE	((28+2*3*1024)<<2)
+#define NFSD_BUFSIZE	(1024 + (NFSSVC_MAXACLSIZE > NFSSVC_MAXBLKSIZE ? \
+				 NFSSVC_MAXACLSIZE : NFSSVC_MAXBLKSIZE ))
 
 /* these signals will be delivered to an nfsd thread 
  * when handling a request
@@ -329,6 +332,35 @@ nfsd_dispatch(struct svc_rqst *rqstp, u3
 	return 1;
 }
 
+#ifdef CONFIG_NFSD_ACL
+static struct svc_version       nfsd_acl_version3 = {
+	3, 3, nfsd_acl_procedures3, nfsd_dispatch
+};
+
+static struct svc_version *     nfsd_acl_version[] = {
+	NULL,
+	NULL,
+	NULL,
+	&nfsd_acl_version3,
+};
+
+struct svc_stat nfsd_acl_svcstats = { &nfsd_acl_program, };
+
+# define NFSD_ACL_NRVERS (sizeof(nfsd_acl_version)/sizeof(nfsd_acl_version[0]))
+struct svc_program		nfsd_acl_program = {
+	NULL,			/* last registered program */
+	NFS3_ACL_PROGRAM,	/* program number */
+	3, NFSD_ACL_NRVERS-1,	/* version range */
+	NFSD_ACL_NRVERS,	/* nr of entries in nfsd_acl_version */
+	nfsd_acl_version,	/* version table */
+	"nfsd",			/* program name */
+	&nfsd_acl_svcstats,	/* version table */
+};
+# define nfsd_acl_program_p &nfsd_acl_program
+#else  /* CONFIG_NFS_ACL */
+# define nfsd_acl_program_p NULL
+#endif  /* CONFIG_NFS_ACL */
+
 static struct svc_version	nfsd_version2 = {
 	2, 18, nfsd_procedures2, nfsd_dispatch
 };
@@ -348,10 +380,11 @@ static struct svc_version *	nfsd_version
 
 #define NFSD_NRVERS		(sizeof(nfsd_version)/sizeof(nfsd_version[0]))
 struct svc_program		nfsd_program = {
+	nfsd_acl_program_p,	/* next registered program */
 	NFS_PROGRAM,		/* program number */
 	2, NFSD_NRVERS-1,	/* version range */
 	NFSD_NRVERS,		/* nr of entries in nfsd_version */
 	nfsd_version,		/* version table */
 	"nfsd",			/* program name */
-	&nfsd_svcstats,		/* version table */
+	&nfsd_svcstats,		/* rpc statistics */
 };
diff -urNp linux-5650/fs/nfsd/vfs.c linux-5660/fs/nfsd/vfs.c
--- linux-5650/fs/nfsd/vfs.c
+++ linux-5660/fs/nfsd/vfs.c
@@ -1650,7 +1650,8 @@ nfsd_set_posix_acl(struct svc_fh *fhp, i
 	size_t size;
 	int error;
 
-	if (!IS_POSIXACL(inode) || !inode->i_op || !inode->i_op->setxattr)
+	if (!IS_POSIXACL(inode) || !inode->i_op ||
+	    !inode->i_op->setxattr || !inode->i_op->removexattr)
 		return -EOPNOTSUPP;
 	switch(type) {
 		case ACL_TYPE_ACCESS:
@@ -1679,7 +1680,18 @@ nfsd_set_posix_acl(struct svc_fh *fhp, i
 	if (!fhp->fh_locked)
 		fh_lock(fhp);  /* unlocking is done automatically */
 	lock_kernel();  /* goes away in 2.5 */
-	error = inode->i_op->setxattr(fhp->fh_dentry, name, value, size, 0);
+	if (size)
+		error = inode->i_op->setxattr(fhp->fh_dentry, name,
+					      value, size, 0);
+	else {
+		if (!S_ISDIR(inode->i_mode) && type == ACL_TYPE_DEFAULT)
+			error = 0;
+		else {
+			error = inode->i_op->removexattr(fhp->fh_dentry, name);
+			if (error == -ENODATA)
+				error = 0;
+		}
+	}
 	unlock_kernel();  /* goes away in 2.5 */
 
 getout:
diff -urNp linux-5650/fs/solaris_acl.c linux-5660/fs/solaris_acl.c
--- linux-5650/fs/solaris_acl.c
+++ linux-5660/fs/solaris_acl.c
@@ -0,0 +1,198 @@
+/*
+ * linux/fs/solaris_acl.c
+ *
+ *  Copyright (C) 2002 by Andreas Gruenbacher <a.gruenbacher@computer.org>
+ */
+
+/*
+ * The Solaris nfs_acl protocol represents some ACLs slightly differently
+ * than POSIX 1003.1e draft 17 does (and we do):
+ *
+ *  - Minimal ACLs always have an ACL_MASK entry, so they have
+ *    four instead of three entries.
+ *  - The ACL_MASK entry in such minimal ACLs always has the same
+ *    permissions as the ACL_GROUP_OBJ entry. (In extended ACLs
+ *    the ACL_MASK and ACL_GROUP_OBJ entries may differ.)
+ *  - The identifier fields of the ACL_USER_OBJ and ACL_GROUP_OBJ
+ *    entries contain the identifiers of the owner and owning group.
+ *    (In POSIX ACLs we always set them to ACL_UNDEFINED_ID).
+ *  - ACL entries in the kernel are kept sorted in ascending order
+ *    of (e_tag, e_id). Solaris ACLs are unsorted.
+ */
+
+#include <linux/module.h>
+#include <linux/solaris_acl.h>
+#include <linux/nfs3.h>
+
+EXPORT_SYMBOL_GPL(nfs_acl_encode);
+EXPORT_SYMBOL_GPL(nfs_acl_decode);
+
+u32 *
+nfs_acl_encode(u32 *p, u32 *end, struct inode *inode, struct posix_acl *acl,
+	       int encode_entries, int typeflag)
+{
+	int entries = acl ? acl->a_count : 0;
+	
+	if (entries == 3)
+		entries++;  /* need to fake up ACL_MASK entry */
+	if (entries > NFS3_ACL_MAX_ENTRIES ||
+	    p + 2 + (encode_entries ? (3 * entries) : 0) > end)
+		return NULL;
+	*p++ = htonl(entries);
+	if (acl && encode_entries) {
+		struct posix_acl_entry *pa, *pe;
+		int group_obj_perm = ACL_READ|ACL_WRITE|ACL_EXECUTE;
+
+		*p++ = htonl(entries);
+		FOREACH_ACL_ENTRY(pa, acl, pe) {
+			*p++ = htonl(pa->e_tag | typeflag);
+			switch(pa->e_tag) {
+				case ACL_USER_OBJ:
+					*p++ = htonl(inode->i_uid);
+					break;
+				case ACL_GROUP_OBJ:
+					*p++ = htonl(inode->i_gid);
+					group_obj_perm = pa->e_perm;
+					break;
+				default:
+					*p++ = htonl(pa->e_id);
+					break;
+			}
+			*p++ = htonl(pa->e_perm & S_IRWXO);
+		}
+		if (acl->a_count < entries) {
+			/* fake up ACL_MASK entry */
+			*p++ = htonl(ACL_MASK | typeflag);
+			*p++ = htonl(ACL_UNDEFINED_ID);
+			*p++ = htonl(group_obj_perm & S_IRWXO);
+		}
+	} else
+		*p++ = 0;
+
+	return p;
+}
+
+static int
+cmp_acl_entry(const struct posix_acl_entry *a, const struct posix_acl_entry *b)
+{
+	if (a->e_tag != b->e_tag)
+		return a->e_tag - b->e_tag;
+	else if (a->e_id > b->e_id)
+		return 1;
+	else if (a->e_id < b->e_id)
+		return -1;
+	else
+		return 0;
+}
+
+/*
+ * Convert from a Solaris ACL to a POSIX 1003.1e draft 17 ACL.
+ */
+static int
+posix_acl_from_solaris(struct posix_acl *acl)
+{
+	struct posix_acl_entry *pa, *pe,
+	       *group_obj = NULL, *mask = NULL;
+
+	if (!acl)
+		return 0;
+
+	qsort(acl->a_entries, acl->a_count, sizeof(struct posix_acl_entry),
+	      (int(*)(const void *,const void *))cmp_acl_entry);
+
+	/* Clear undefined identifier fields and find the ACL_GROUP_OBJ
+	   and ACL_MASK entries. */
+	FOREACH_ACL_ENTRY(pa, acl, pe) {
+		switch(pa->e_tag) {
+			case ACL_USER_OBJ:
+				pa->e_id = ACL_UNDEFINED_ID;
+				break;
+			case ACL_GROUP_OBJ:
+				pa->e_id = ACL_UNDEFINED_ID;
+				group_obj = pa;
+				break;
+			case ACL_MASK:
+				mask = pa;
+				/* fall through */
+			case ACL_OTHER:
+				pa->e_id = ACL_UNDEFINED_ID;
+				break;
+		}
+	}
+	if (acl->a_count == 4 && group_obj && mask &&
+	    mask->e_perm == group_obj->e_perm) {
+		/* remove bogus ACL_MASK entry */
+		memmove(mask, mask+1, (acl->a_entries + 4 - mask) *
+				      sizeof(struct posix_acl_entry));
+		acl->a_count = 3;
+	}
+	return 0;
+}
+
+static u32 *
+nfs_acl_decode_entry(u32 *p, struct posix_acl_entry *entry)
+{
+	entry->e_tag = ntohl(*p++) & ~NFS3_ACL_DEFAULT;
+	entry->e_id = ntohl(*p++);
+	entry->e_perm = ntohl(*p++);
+
+	switch(entry->e_tag) {
+		case ACL_USER_OBJ:
+		case ACL_USER:
+		case ACL_GROUP_OBJ:
+		case ACL_GROUP:
+		case ACL_OTHER:
+			if (entry->e_perm & ~S_IRWXO)
+				return NULL;
+			break;
+		case ACL_MASK:
+			/* Solaris sometimes sets additonal bits in the mask */
+			entry->e_perm &= S_IRWXO;
+			break;
+		default:
+			return NULL;
+	}
+	return p;
+}
+
+u32 *
+nfs_acl_decode(u32 *p, u32 *end, unsigned int *aclcnt, struct posix_acl **pacl)
+{
+	struct posix_acl_entry *pa, *pe;
+	unsigned int entries, array_len;
+
+	if (p + 2 > end)
+		return NULL;
+	entries = ntohl(*p++);
+	array_len = ntohl(*p++);
+	if (entries > NFS3_ACL_MAX_ENTRIES || (pacl && entries != array_len))
+		return NULL;
+	if (p + 3 * array_len > end)
+		return NULL;
+	if (pacl) {
+		*pacl = NULL;
+		if (entries) {
+			struct posix_acl *acl;
+			
+			if (!(acl = posix_acl_alloc(array_len, GFP_KERNEL)))
+				return NULL;
+			FOREACH_ACL_ENTRY(pa, acl, pe) {
+				if (!(p = nfs_acl_decode_entry(p, pa))) {
+					posix_acl_release(acl);
+					return NULL;
+				}
+			}
+			if (posix_acl_from_solaris(acl) != 0) {
+				posix_acl_release(acl);
+				return NULL;
+			}
+			*pacl = acl;
+		}
+	} else 
+		p += 3 * array_len;
+
+	if (aclcnt)
+		*aclcnt = entries;
+	return p;
+}
+
diff -urNp linux-5650/fs/xattr_acl.c linux-5660/fs/xattr_acl.c
--- linux-5650/fs/xattr_acl.c
+++ linux-5660/fs/xattr_acl.c
@@ -29,7 +29,7 @@ posix_acl_from_xattr(const void *value, 
 	if (size < sizeof(xattr_acl_header))
 		 return ERR_PTR(-EINVAL);
 	if (header->a_version != cpu_to_le32(XATTR_ACL_VERSION))
-		return ERR_PTR(-EINVAL);
+		return ERR_PTR(-EOPNOTSUPP);
 
 	count = xattr_acl_count(size);
 	if (count < 0)
diff -urNp linux-5650/include/linux/kernel.h linux-5660/include/linux/kernel.h
--- linux-5650/include/linux/kernel.h
+++ linux-5660/include/linux/kernel.h
@@ -81,6 +81,8 @@ extern int sscanf(const char *, const ch
 	__attribute__ ((format (scanf,2,3)));
 extern int vsscanf(const char *, const char *, va_list);
 
+extern void qsort(void *, size_t, size_t, int (*)(const void *,const void *));
+
 extern int get_option(char **str, int *pint);
 extern char *get_options(char *str, int nints, int *ints);
 extern unsigned long long memparse(char *ptr, char **retptr);
diff -urNp linux-5650/include/linux/nfs3.h linux-5660/include/linux/nfs3.h
--- linux-5650/include/linux/nfs3.h
+++ linux-5660/include/linux/nfs3.h
@@ -36,6 +36,18 @@ enum nfs3_createmode {
 	NFS3_CREATE_EXCLUSIVE = 2
 };
 
+/* Flags for the getacl/setacl mode */
+#define NFS3_ACL		0x0001
+#define NFS3_ACLCNT		0x0002
+#define NFS3_DFACL		0x0004
+#define NFS3_DFACLCNT		0x0008
+
+/* Flag for Default ACL entries */
+#define NFS3_ACL_DEFAULT	0x1000
+
+/* Maximum number of ACL entries over NFS */
+#define NFS3_ACL_MAX_ENTRIES	1024
+
 /* NFSv3 file system properties */
 #define NFS3_FSF_LINK		0x0001
 #define NFS3_FSF_SYMLINK	0x0002
@@ -82,6 +94,10 @@ enum nfs3_ftype {
 #define NFS3PROC_PATHCONF	20
 #define NFS3PROC_COMMIT		21
 
+#define NFS3_ACL_PROGRAM	100227
+#define NFS3_ACL_PROC_GETACL	1
+#define NFS3_ACL_PROC_SETACL	2
+
 #define NFS_MNT3_PROGRAM	100005
 #define NFS_MNT3_VERSION	3
 #define MOUNTPROC3_NULL		0
@@ -95,5 +111,6 @@ enum nfs3_ftype {
 /* Number of 32bit words in post_op_attr */
 #define NFS3_POST_OP_ATTR_WORDS		22
 
+extern unsigned int nfs3_acl_max_entries;
 #endif /* __KERNEL__ */
 #endif /* _LINUX_NFS3_H */
diff -urNp linux-5650/include/linux/nfs_fs.h linux-5660/include/linux/nfs_fs.h
--- linux-5650/include/linux/nfs_fs.h
+++ linux-5660/include/linux/nfs_fs.h
@@ -103,6 +103,8 @@ do { \
 
 #define NFS_FILEID(inode)		((inode)->u.nfs_i.fileid)
 
+#define NFS_ACL_CLIENT(inode)		(NFS_SERVER(inode)->acl_client)
+
 static inline int nfs_server_capable(struct inode *inode, int cap)
 {
 	return NFS_SERVER(inode)->caps & cap;
@@ -171,6 +173,22 @@ extern struct inode_operations nfs_file_
 extern struct file_operations nfs_file_operations;
 extern struct address_space_operations nfs_file_aops;
 
+/*
+ * linux/fs/nfs/xattr.c
+ */
+#ifdef CONFIG_NFS_ACL
+extern ssize_t nfs_listxattr(struct dentry *, char *, size_t);
+extern ssize_t nfs_getxattr(struct dentry *, const char *, void *, size_t);
+extern int nfs_setxattr(struct dentry *, const char *,
+			const void *, size_t, int);
+extern int nfs_removexattr (struct dentry *, const char *name);
+#else
+# define nfs_listxattr NULL
+# define nfs_getxattr NULL
+# define nfs_setxattr NULL
+# define nfs_removexattr NULL
+#endif
+
 static __inline__ struct rpc_cred *
 nfs_file_cred(struct file *file)
 {
diff -urNp linux-5650/include/linux/nfs_fs_sb.h linux-5660/include/linux/nfs_fs_sb.h
--- linux-5650/include/linux/nfs_fs_sb.h
+++ linux-5660/include/linux/nfs_fs_sb.h
@@ -8,6 +8,9 @@
  */
 struct nfs_server {
 	struct rpc_clnt *	client;		/* RPC client handle */
+#ifdef CONFIG_NFS_ACL
+	struct rpc_clnt *	acl_client;	/* ACL RPC client handle */
+#endif
 	struct nfs_rpc_ops *	rpc_ops;	/* NFS protocol vector */
 	int			flags;		/* various flags */
 	unsigned int		caps;		/* server capabilities */
diff -urNp linux-5650/include/linux/nfs_mount.h linux-5660/include/linux/nfs_mount.h
--- linux-5650/include/linux/nfs_mount.h
+++ linux-5660/include/linux/nfs_mount.h
@@ -56,4 +56,8 @@ struct nfs_mount_data {
 #define NFS_MOUNT_NOACL		0x0800  /* 4 */
 #define NFS_MOUNT_FLAGMASK	0xFFFF
 
+/* Feature flags for the NFS_ACL GETACL and SETACL RPC's */
+#define NFS_SOLARIS_GETACL	0x10000
+#define NFS_SOLARIS_SETACL	0x20000
+
 #endif
diff -urNp linux-5650/include/linux/nfs_xdr.h linux-5660/include/linux/nfs_xdr.h
--- linux-5650/include/linux/nfs_xdr.h
+++ linux-5660/include/linux/nfs_xdr.h
@@ -1,6 +1,8 @@
 #ifndef _LINUX_NFS_XDR_H
 #define _LINUX_NFS_XDR_H
 
+#include <linux/posix_acl.h>
+
 struct nfs_fattr {
 	unsigned short		valid;		/* which fields are valid */
 	__u64			pre_size;	/* pre_op_attr.size	  */
@@ -278,6 +280,18 @@ struct nfs3_readdirargs {
 	struct page **		pages;
 };
 
+struct nfs3_getaclargs {
+	struct nfs_fh *		fh;
+	int			mask;
+};
+
+struct nfs3_setaclargs {
+	struct inode *		inode;
+	int			mask;
+	struct posix_acl *	acl_access;
+	struct posix_acl *	acl_default;
+};
+
 struct nfs3_diropres {
 	struct nfs_fattr *	dir_attr;
 	struct nfs_fh *		fh;
@@ -311,6 +325,15 @@ struct nfs3_readdirres {
 	int			plus;
 };
 
+struct nfs3_getaclres {
+	struct nfs_fattr *	fattr;
+	int			mask;
+	unsigned int		acl_access_count;
+	unsigned int		acl_default_count;
+	struct posix_acl *	acl_access;
+	struct posix_acl *	acl_default;
+};
+
 /*
  * RPC procedure vector for NFSv2/NFSv3 demuxing
  */
@@ -362,6 +385,11 @@ struct nfs_rpc_ops {
 	int	(*pathconf) (struct nfs_server *, struct nfs_fh *,
 			    struct nfs_pathconf *);
 	u32 *	(*decode_dirent)(u32 *, struct nfs_entry *, int plus);
+#ifdef CONFIG_NFS_ACL
+	struct posix_acl * (*getacl)(struct inode *, int);
+	int (*setacl)(struct inode *, int, struct posix_acl *);
+	int (*checkacls)(struct inode *inode);
+#endif  /* CONFIG_NFS_ACL */
 };
 
 /*
@@ -381,4 +409,9 @@ extern struct rpc_version	nfs_version3;
 extern struct rpc_program	nfs_program;
 extern struct rpc_stat		nfs_rpcstat;
 
+#ifdef CONFIG_NFS_ACL
+extern struct rpc_version	nfs_acl_version3;
+extern struct rpc_program	nfs_acl_program;
+#endif  /* CONFIG_NFS_ACL */
+
 #endif
diff -urNp linux-5650/include/linux/nfsd/nfsd.h linux-5660/include/linux/nfsd/nfsd.h
--- linux-5650/include/linux/nfsd/nfsd.h
+++ linux-5660/include/linux/nfsd/nfsd.h
@@ -71,6 +71,12 @@ extern struct svc_procedure	nfsd_procedu
 #endif /* CONFIG_NFSD_V3 */
 extern struct svc_program	nfsd_program;
 
+#ifdef CONFIG_NFSD_ACL
+extern struct svc_procedure	nfsd_acl_procedures3[];
+extern struct svc_program	nfsd_acl_program;
+extern unsigned int		nfsd3_acl_max_entries;
+#endif /* CONFIG_NFSD_ACL */
+
 /*
  * Function prototypes.
  */
diff -urNp linux-5650/include/linux/nfsd/xdr3.h linux-5660/include/linux/nfsd/xdr3.h
--- linux-5650/include/linux/nfsd/xdr3.h
+++ linux-5660/include/linux/nfsd/xdr3.h
@@ -10,6 +10,7 @@
 #define _LINUX_NFSD_XDR3_H
 
 #include <linux/nfsd/xdr.h>
+#include <linux/posix_acl.h>
 
 struct nfsd3_sattrargs {
 	struct svc_fh		fh;
@@ -101,6 +102,18 @@ struct nfsd3_commitargs {
 	__u32			count;
 };
 
+struct nfsd3_getaclargs {
+	struct svc_fh		fh;
+	int			mask;
+};
+
+struct nfsd3_setaclargs {
+	struct svc_fh		fh;
+	int			mask;
+	struct posix_acl	*acl_access;
+	struct posix_acl	*acl_default;
+};
+
 struct nfsd3_attrstat {
 	__u32			status;
 	struct svc_fh		fh;
@@ -192,6 +205,14 @@ struct nfsd3_commitres {
 	struct svc_fh		fh;
 };
 
+struct nfsd3_getaclres {
+	__u32			status;
+	struct svc_fh		fh;
+	int			mask;
+	struct posix_acl	*acl_access;
+	struct posix_acl	*acl_default;
+};
+
 /* dummy type for release */
 struct nfsd3_fhandle_pair {
 	__u32			dummy;
@@ -224,6 +245,7 @@ union nfsd3_xdrstore {
 	struct nfsd3_fsinfores		fsinfores;
 	struct nfsd3_pathconfres	pathconfres;
 	struct nfsd3_commitres		commitres;
+	struct nfsd3_getaclres		getaclres;
 };
 
 #define NFS3_SVC_XDRSIZE		sizeof(union nfsd3_xdrstore)
@@ -257,6 +279,10 @@ int nfs3svc_decode_readdirplusargs(struc
 				struct nfsd3_readdirargs *);
 int nfs3svc_decode_commitargs(struct svc_rqst *, u32 *,
 				struct nfsd3_commitargs *);
+int nfs3svc_decode_getaclargs(struct svc_rqst *, u32 *,
+				struct nfsd3_getaclargs *);
+int nfs3svc_decode_setaclargs(struct svc_rqst *, u32 *,
+				struct nfsd3_setaclargs *);
 int nfs3svc_encode_voidres(struct svc_rqst *, u32 *, void *);
 int nfs3svc_encode_attrstat(struct svc_rqst *, u32 *,
 				struct nfsd3_attrstat *);
@@ -286,11 +312,19 @@ int nfs3svc_encode_pathconfres(struct sv
 				struct nfsd3_pathconfres *);
 int nfs3svc_encode_commitres(struct svc_rqst *, u32 *,
 				struct nfsd3_commitres *);
+int nfs3svc_encode_getaclres(struct svc_rqst *, u32 *,
+				struct nfsd3_getaclres *);
+int nfs3svc_encode_setaclres(struct svc_rqst *, u32 *,
+				struct nfsd3_attrstat *);
+
 
 int nfs3svc_release_fhandle(struct svc_rqst *, u32 *,
 				struct nfsd3_attrstat *);
 int nfs3svc_release_fhandle2(struct svc_rqst *, u32 *,
 				struct nfsd3_fhandle_pair *);
+int nfs3svc_release_getacl(struct svc_rqst *rqstp, u32 *p,
+				struct nfsd3_getaclres *resp);
+
 int nfs3svc_encode_entry(struct readdir_cd *, const char *name,
 				int namlen, loff_t offset, ino_t ino,
 				unsigned int);
diff -urNp linux-5650/include/linux/solaris_acl.h linux-5660/include/linux/solaris_acl.h
--- linux-5650/include/linux/solaris_acl.h
+++ linux-5660/include/linux/solaris_acl.h
@@ -0,0 +1,33 @@
+/*
+  File: linux/solaris_acl.h
+
+  (C) 2002 Andreas Gruenbacher, <a.gruenbacher@computer.org>
+*/
+
+
+#ifndef __LINUX_SOLARIS_ACL_H
+#define __LINUX_SOLARIS_ACL_H
+
+#include <linux/posix_acl.h>
+
+u32 *nfs_acl_encode(u32 *, u32 *, struct inode *, struct posix_acl *, int, int);
+u32 *nfs_acl_decode(u32 *, u32 *, unsigned int *, struct posix_acl **);
+
+static __inline__ u32 *nfs_acl_encode_limit(u32 *p, u32 *end, struct inode *inode, struct posix_acl *acl,
+	int encode_entries, int typeflag, unsigned int acl_limit)
+{
+	int entries = acl ? acl->a_count : 0;
+	if (entries >= acl_limit)
+		return NULL;
+	return nfs_acl_encode(p, end, inode, acl, encode_entries, typeflag);
+}
+
+static __inline__ u32 *nfs_acl_decode_limit(u32 *p, u32 *end, unsigned int *aclcnt, struct posix_acl **pacl, unsigned int acl_limit)
+{
+	int entries = ntohl(*p);
+	
+	if (entries >= acl_limit)
+		return NULL;
+	return nfs_acl_decode(p, end, aclcnt, pacl);
+}
+#endif  /* __LINUX_SOLARIS_ACL_H */
diff -urNp linux-5650/include/linux/sunrpc/svc.h linux-5660/include/linux/sunrpc/svc.h
--- linux-5650/include/linux/sunrpc/svc.h
+++ linux-5660/include/linux/sunrpc/svc.h
@@ -131,9 +131,10 @@ struct svc_rqst {
 };
 
 /*
- * RPC program
+ * List of RPC programs on the same transport endpoint
  */
 struct svc_program {
+	struct svc_program *	pg_next;	/* other programs */
 	u32			pg_prog;	/* program number */
 	unsigned int		pg_lovers;	/* lowest version */
 	unsigned int		pg_hivers;	/* lowest version */
diff -urNp linux-5650/include/linux/sunrpc/xprt.h linux-5660/include/linux/sunrpc/xprt.h
--- linux-5650/include/linux/sunrpc/xprt.h
+++ linux-5660/include/linux/sunrpc/xprt.h
@@ -149,6 +149,8 @@ struct rpc_xprt {
 				nocong	   : 1,	/* no congestion control */
 				resvport   : 1, /* use a reserved port */
 				stream     : 1;	/* TCP */
+	unsigned int		clients;	/* Number of clients using
+						   this transport */
 
 	/*
 	 * State of TCP reply receive stuff
diff -urNp linux-5650/kernel/ksyms.c linux-5660/kernel/ksyms.c
--- linux-5650/kernel/ksyms.c
+++ linux-5660/kernel/ksyms.c
@@ -622,6 +622,9 @@ EXPORT_SYMBOL(get_write_access);
 EXPORT_SYMBOL(strnicmp);
 EXPORT_SYMBOL(strspn);
 EXPORT_SYMBOL(strsep);
+#if defined(CONFIG_QSORT) && ! defined(CONFIG_QSORT_MODULE)
+EXPORT_SYMBOL_GPL(qsort);
+#endif
 
 #ifdef CONFIG_CRC32
 EXPORT_SYMBOL(crc32_le);
diff -urNp linux-5650/lib/Config.in linux-5660/lib/Config.in
--- linux-5650/lib/Config.in
+++ linux-5660/lib/Config.in
@@ -41,4 +41,11 @@ else
   fi
 fi
 
+if [ "$CONFIG_NFSD_ACL" = "y" -o \
+     "$CONFIG_NFS_ACL" = "y" ]; then
+   define_tristate CONFIG_QSORT y
+else
+   tristate 'Quick Sort' CONFIG_QSORT
+fi
+
 endmenu
diff -urNp linux-5650/lib/Makefile linux-5660/lib/Makefile
--- linux-5650/lib/Makefile
+++ linux-5660/lib/Makefile
@@ -9,7 +9,7 @@
 L_TARGET := lib.a
 
 export-objs := cmdline.o dec_and_lock.o rwsem-spinlock.o rwsem.o \
-	       rbtree.o crc32.o
+	       rbtree.o crc32.o qsort.o
 
 obj-y := errno.o ctype.o string.o vsprintf.o brlock.o cmdline.o \
 	 bust_spinlocks.o rbtree.o dump_stack.o
@@ -31,6 +31,8 @@ include $(TOPDIR)/drivers/usb/Makefile.l
 include $(TOPDIR)/fs/Makefile.lib
 include $(TOPDIR)/net/bluetooth/bnep/Makefile.lib
 
+obj-$(CONFIG_QSORT) += qsort.o
+
 # Include the subdirs, if necessary.
 obj-y += $(join $(subdir-y),$(subdir-y:%=/%.o))
 
diff -urNp linux-5650/lib/qsort.c linux-5660/lib/qsort.c
--- linux-5650/lib/qsort.c
+++ linux-5660/lib/qsort.c
@@ -0,0 +1,254 @@
+/* Copyright (C) 1991, 1992, 1996, 1997, 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Written by Douglas C. Schmidt (schmidt@ics.uci.edu).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* If you consider tuning this algorithm, you should consult first:
+   Engineering a sort function; Jon Bentley and M. Douglas McIlroy;
+   Software - Practice and Experience; Vol. 23 (11), 1249-1265, 1993.  */
+
+# include <linux/module.h>
+# include <linux/slab.h>
+# include <linux/string.h>
+
+MODULE_LICENSE("GPL");
+
+/* Byte-wise swap two items of size SIZE. */
+#define SWAP(a, b, size)						      \
+  do									      \
+    {									      \
+      register size_t __size = (size);					      \
+      register char *__a = (a), *__b = (b);				      \
+      do								      \
+	{								      \
+	  char __tmp = *__a;						      \
+	  *__a++ = *__b;						      \
+	  *__b++ = __tmp;						      \
+	} while (--__size > 0);						      \
+    } while (0)
+
+/* Discontinue quicksort algorithm when partition gets below this size.
+   This particular magic number was chosen to work best on a Sun 4/260. */
+#define MAX_THRESH 4
+
+/* Stack node declarations used to store unfulfilled partition obligations. */
+typedef struct
+  {
+    char *lo;
+    char *hi;
+  } stack_node;
+
+/* The next 5 #defines implement a very fast in-line stack abstraction. */
+/* The stack needs log (total_elements) entries (we could even subtract
+   log(MAX_THRESH)).  Since total_elements has type size_t, we get as
+   upper bound for log (total_elements):
+   bits per byte (CHAR_BIT) * sizeof(size_t).  */
+#define CHAR_BIT 8
+#define STACK_SIZE	(CHAR_BIT * sizeof(size_t))
+#define PUSH(low, high)	((void) ((top->lo = (low)), (top->hi = (high)), ++top))
+#define	POP(low, high)	((void) (--top, (low = top->lo), (high = top->hi)))
+#define	STACK_NOT_EMPTY	(stack < top)
+
+
+/* Order size using quicksort.  This implementation incorporates
+   four optimizations discussed in Sedgewick:
+
+   1. Non-recursive, using an explicit stack of pointer that store the
+      next array partition to sort.  To save time, this maximum amount
+      of space required to store an array of SIZE_MAX is allocated on the
+      stack.  Assuming a 32-bit (64 bit) integer for size_t, this needs
+      only 32 * sizeof(stack_node) == 256 bytes (for 64 bit: 1024 bytes).
+      Pretty cheap, actually.
+
+   2. Chose the pivot element using a median-of-three decision tree.
+      This reduces the probability of selecting a bad pivot value and
+      eliminates certain extraneous comparisons.
+
+   3. Only quicksorts TOTAL_ELEMS / MAX_THRESH partitions, leaving
+      insertion sort to order the MAX_THRESH items within each partition.
+      This is a big win, since insertion sort is faster for small, mostly
+      sorted array segments.
+
+   4. The larger of the two sub-partitions is always pushed onto the
+      stack first, with the algorithm then concentrating on the
+      smaller partition.  This *guarantees* no more than log (total_elems)
+      stack size is needed (actually O(1) in this case)!  */
+
+void
+qsort(void *const pbase, size_t total_elems, size_t size,
+      int(*cmp)(const void *,const void *))
+{
+  register char *base_ptr = (char *) pbase;
+
+  const size_t max_thresh = MAX_THRESH * size;
+
+  if (total_elems == 0)
+    /* Avoid lossage with unsigned arithmetic below.  */
+    return;
+
+  if (total_elems > MAX_THRESH)
+    {
+      char *lo = base_ptr;
+      char *hi = &lo[size * (total_elems - 1)];
+      stack_node stack[STACK_SIZE];
+      stack_node *top = stack + 1;
+
+      while (STACK_NOT_EMPTY)
+        {
+          char *left_ptr;
+          char *right_ptr;
+
+	  /* Select median value from among LO, MID, and HI. Rearrange
+	     LO and HI so the three values are sorted. This lowers the
+	     probability of picking a pathological pivot value and
+	     skips a comparison for both the LEFT_PTR and RIGHT_PTR in
+	     the while loops. */
+
+	  char *mid = lo + size * ((hi - lo) / size >> 1);
+
+	  if ((*cmp) ((void *) mid, (void *) lo) < 0)
+	    SWAP (mid, lo, size);
+	  if ((*cmp) ((void *) hi, (void *) mid) < 0)
+	    SWAP (mid, hi, size);
+	  else
+	    goto jump_over;
+	  if ((*cmp) ((void *) mid, (void *) lo) < 0)
+	    SWAP (mid, lo, size);
+	jump_over:;
+
+	  left_ptr  = lo + size;
+	  right_ptr = hi - size;
+
+	  /* Here's the famous ``collapse the walls'' section of quicksort.
+	     Gotta like those tight inner loops!  They are the main reason
+	     that this algorithm runs much faster than others. */
+	  do
+	    {
+	      while ((*cmp) ((void *) left_ptr, (void *) mid) < 0)
+		left_ptr += size;
+
+	      while ((*cmp) ((void *) mid, (void *) right_ptr) < 0)
+		right_ptr -= size;
+
+	      if (left_ptr < right_ptr)
+		{
+		  SWAP (left_ptr, right_ptr, size);
+		  if (mid == left_ptr)
+		    mid = right_ptr;
+		  else if (mid == right_ptr)
+		    mid = left_ptr;
+		  left_ptr += size;
+		  right_ptr -= size;
+		}
+	      else if (left_ptr == right_ptr)
+		{
+		  left_ptr += size;
+		  right_ptr -= size;
+		  break;
+		}
+	    }
+	  while (left_ptr <= right_ptr);
+
+          /* Set up pointers for next iteration.  First determine whether
+             left and right partitions are below the threshold size.  If so,
+             ignore one or both.  Otherwise, push the larger partition's
+             bounds on the stack and continue sorting the smaller one. */
+
+          if ((size_t) (right_ptr - lo) <= max_thresh)
+            {
+              if ((size_t) (hi - left_ptr) <= max_thresh)
+		/* Ignore both small partitions. */
+                POP (lo, hi);
+              else
+		/* Ignore small left partition. */
+                lo = left_ptr;
+            }
+          else if ((size_t) (hi - left_ptr) <= max_thresh)
+	    /* Ignore small right partition. */
+            hi = right_ptr;
+          else if ((right_ptr - lo) > (hi - left_ptr))
+            {
+	      /* Push larger left partition indices. */
+              PUSH (lo, right_ptr);
+              lo = left_ptr;
+            }
+          else
+            {
+	      /* Push larger right partition indices. */
+              PUSH (left_ptr, hi);
+              hi = right_ptr;
+            }
+        }
+    }
+
+  /* Once the BASE_PTR array is partially sorted by quicksort the rest
+     is completely sorted using insertion sort, since this is efficient
+     for partitions below MAX_THRESH size. BASE_PTR points to the beginning
+     of the array to sort, and END_PTR points at the very last element in
+     the array (*not* one beyond it!). */
+
+  {
+    char *end_ptr = &base_ptr[size * (total_elems - 1)];
+    char *tmp_ptr = base_ptr;
+    char *thresh = min(end_ptr, base_ptr + max_thresh);
+    register char *run_ptr;
+
+    /* Find smallest element in first threshold and place it at the
+       array's beginning.  This is the smallest array element,
+       and the operation speeds up insertion sort's inner loop. */
+
+    for (run_ptr = tmp_ptr + size; run_ptr <= thresh; run_ptr += size)
+      if ((*cmp) ((void *) run_ptr, (void *) tmp_ptr) < 0)
+        tmp_ptr = run_ptr;
+
+    if (tmp_ptr != base_ptr)
+      SWAP (tmp_ptr, base_ptr, size);
+
+    /* Insertion sort, running from left-hand-side up to right-hand-side.  */
+
+    run_ptr = base_ptr + size;
+    while ((run_ptr += size) <= end_ptr)
+      {
+	tmp_ptr = run_ptr - size;
+	while ((*cmp) ((void *) run_ptr, (void *) tmp_ptr) < 0)
+	  tmp_ptr -= size;
+
+	tmp_ptr += size;
+        if (tmp_ptr != run_ptr)
+          {
+            char *trav;
+
+	    trav = run_ptr + size;
+	    while (--trav >= run_ptr)
+              {
+                char c = *trav;
+                char *hi, *lo;
+
+                for (hi = lo = trav; (lo -= size) >= tmp_ptr; hi = lo)
+                  *hi = *lo;
+                *hi = c;
+              }
+          }
+      }
+  }
+}
+/* If qsort is built into the kernel, we export the qsort symbol in
+   kernel/ksyms.c: The files in lib/ end up in lib.a, so qsort.o only
+   gets linked into the kernel image if it is used somewhere.  */
+#if defined(CONFIG_QSORT_MODULE)
+EXPORT_SYMBOL_GPL(qsort);
+#endif
diff -urNp linux-5650/net/sunrpc/clnt.c linux-5660/net/sunrpc/clnt.c
--- linux-5650/net/sunrpc/clnt.c
+++ linux-5660/net/sunrpc/clnt.c
@@ -89,6 +89,8 @@ rpc_create_client(struct rpc_xprt *xprt,
 	memset(clnt, 0, sizeof(*clnt));
 	atomic_set(&clnt->cl_users, 0);
 
+	xprt->clients++;
+
 	clnt->cl_xprt     = xprt;
 	clnt->cl_procinfo = version->procs;
 	clnt->cl_maxproc  = version->nrprocs;
@@ -166,7 +168,7 @@ rpc_destroy_client(struct rpc_clnt *clnt
 		rpcauth_destroy(clnt->cl_auth);
 		clnt->cl_auth = NULL;
 	}
-	if (clnt->cl_xprt) {
+	if (clnt->cl_xprt && !(--clnt->cl_xprt->clients)) {
 		xprt_destroy(clnt->cl_xprt);
 		clnt->cl_xprt = NULL;
 	}
@@ -917,6 +919,16 @@ call_verify(struct rpc_task *task)
 		return p;
 	case RPC_GARBAGE_ARGS:
 		break;			/* retry */
+	case RPC_PROG_UNAVAIL:
+		/* report requested program number*/
+		dprintk(KERN_WARNING "RPC: unknown program\n");
+		rpc_exit(task, -ENOSYS);
+		return NULL;
+	case RPC_PROC_UNAVAIL:
+		/* report requested program and procedure number, version */
+		dprintk(KERN_WARNING "RPC: unknown procedure\n");
+		rpc_exit(task, -ENOSYS);
+		return NULL;
 	default:
 		printk(KERN_WARNING "call_verify: server accept status: %x\n", n);
 		/* Also retry */
diff -urNp linux-5650/net/sunrpc/svc.c linux-5660/net/sunrpc/svc.c
--- linux-5650/net/sunrpc/svc.c
+++ linux-5660/net/sunrpc/svc.c
@@ -281,8 +281,10 @@ svc_process(struct svc_serv *serv, struc
 	if (auth_stat != rpc_auth_ok)
 		goto err_bad_auth;
 
-	progp = serv->sv_program;
-	if (prog != progp->pg_prog)
+	for (progp = serv->sv_program; progp; progp = progp->pg_next)
+		if (prog == progp->pg_prog)
+			break;
+	if (progp == NULL)
 		goto err_bad_prog;
 
 	if (vers >= progp->pg_nvers ||
@@ -390,9 +392,7 @@ err_bad_auth:
 
 err_bad_prog:
 #ifdef RPC_PARANOIA
-	if (prog != 100227 || progp->pg_prog != 100003)
-		printk("svc: unknown program %d (me %d)\n", prog, progp->pg_prog);
-	/* else it is just a Solaris client seeing if ACLs are supported */
+	printk("svc: unknown program %d\n", prog);
 #endif
 	serv->sv_stats->rpcbadfmt++;
 	svc_putlong(resp, rpc_prog_unavail);
