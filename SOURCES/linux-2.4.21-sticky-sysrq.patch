diff -urNp linux-870/drivers/char/keyboard.c linux-871/drivers/char/keyboard.c
--- linux-870/drivers/char/keyboard.c
+++ linux-871/drivers/char/keyboard.c
@@ -21,6 +21,12 @@
  *
  * 27-05-97: Added support for the Magic SysRq Key (Martin Mares)
  * 30-07-98: Dead keys redone, aeb@cwi.nl.
+ *
+ * 28-09-2001: Crutcher Dunnavant <crutcher+kernel@datastacks.com>
+ * Add stateful sysrq features, based upon work from:
+ *   Mathew Mills <mmills@amazon.com>
+ *   Norman Murray <nmurray@redhat.com>
+ *  
  */
 
 #include <linux/config.h>
@@ -88,6 +94,7 @@ static int dead_key_next;
  * return the value. I chose the former way.
  */
 int shift_state;
+int sysrq_time_start = 0;
 static int npadch = -1;			/* -1 or number assembled on pad */
 static unsigned char diacr;
 static char rep;			/* flag telling character repeat */
@@ -152,7 +159,13 @@ static unsigned char handle_diacr(unsign
 struct pt_regs * kbd_pt_regs;
 
 #ifdef CONFIG_MAGIC_SYSRQ
-static int sysrq_pressed;
+static enum {
+	UP_AND_CLEAR,
+	DOWN_AND_WAITING,
+	DOWN_AND_DONE,
+	UP_AND_WAITING,
+} sysrq_state;
+extern struct sysrq_ctls_struct sysrq_ctls;
 #endif
 
 static struct pm_dev *pm_kbd;
@@ -252,14 +265,81 @@ void handle_scancode(unsigned char scanc
 		rep = test_and_set_bit(keycode, key_down);
 
 #ifdef CONFIG_MAGIC_SYSRQ		/* Handle the SysRq Hack */
-	if (keycode == SYSRQ_KEY) {
-		sysrq_pressed = !up_flag;
-		goto out;
-	} else if (sysrq_pressed) {
-		if (!up_flag) {
-			handle_sysrq(kbd_sysrq_xlate[keycode], kbd_pt_regs, kbd, tty);
-			goto out;
+	/*
+	  Pressing magic + command key acts as a chorded command.
+	  Pressing and releasing magic without a command key acts sticky,
+	  using the next non-magic key as a command key
+	  Pressing magic twice without a command key passes the magic key
+	  through.
+	 */
+
+        if (sysrq_ctls.enabled) {
+		if (keycode == sysrq_ctls.keycode) switch(sysrq_state) {
+			case UP_AND_CLEAR:
+				sysrq_state = up_flag ? UP_AND_CLEAR :
+							DOWN_AND_WAITING;
+				/* consume the key event */
+				goto out;
+
+			case DOWN_AND_WAITING:
+				if (up_flag) {
+					if (sysrq_ctls.sticky) {
+						sysrq_time_start = xtime.tv_sec;
+						sysrq_state = UP_AND_WAITING;
+					} else {
+						sysrq_state = UP_AND_CLEAR;
+					}
+				} else {
+					sysrq_state = DOWN_AND_WAITING;
+				}
+				/* consume the key event */
+				goto out;
+
+			case DOWN_AND_DONE:
+				sysrq_state = up_flag ? UP_AND_CLEAR :
+							DOWN_AND_DONE;
+				/* consume the key event */
+				goto out;
+
+			case UP_AND_WAITING: /* note: up_flag will be 0 */
+				sysrq_state = DOWN_AND_WAITING;
+				goto out;
+
+		} else switch(sysrq_state) {
+			case UP_AND_WAITING:
+				if (up_flag)
+					break;
+
+				sysrq_state = UP_AND_CLEAR;
+				if ((xtime.tv_sec - sysrq_time_start) <=
+				    (sysrq_ctls.timer)) {
+					handle_sysrq(kbd_sysrq_xlate[keycode],
+						     kbd_pt_regs, kbd, tty);
+				} else {
+					/* if not handling this, pass it off */
+					break;
+				}
+
+				/* consume the key event */
+				goto out;
+
+			case DOWN_AND_WAITING:
+			case DOWN_AND_DONE:
+				sysrq_state = DOWN_AND_DONE;
+				if (!up_flag) {
+					handle_sysrq(kbd_sysrq_xlate[keycode],
+						     kbd_pt_regs, kbd, tty);
+					goto out;
+				} /* else */
+				break;
+
+			case UP_AND_CLEAR:
+				/* pass the key event through */
+				break;
+
 		}
+        } else {
+		sysrq_state = UP_AND_CLEAR;
 	}
 #endif
 
diff -urNp linux-870/drivers/char/sysrq.c linux-871/drivers/char/sysrq.c
--- linux-870/drivers/char/sysrq.c
+++ linux-871/drivers/char/sysrq.c
@@ -32,11 +32,26 @@
 
 #include <asm/ptrace.h>
 
+/* for the SYSRQ_KEY definition */
+#include <asm/keyboard.h>
+
 extern void reset_vc(unsigned int);
 extern struct list_head super_blocks;
 
 /* Whether we react on sysrq keys or just ignore them */
-int sysrq_enabled = 1;
+struct sysrq_ctls_struct sysrq_ctls = {
+	/* Whether we react on sysrq keys or just ignore them */
+	enabled: 1,
+
+	/* The keycode for the magic key, referred to as sysrq */
+	keycode: SYSRQ_KEY,
+
+	/* is the sysrq key 'sticky'? */
+	sticky: 0,
+
+	/* the initial timer value */
+	timer: 10,
+};
 
 /* Machine specific power off function */
 void (*sysrq_power_off)(void);
@@ -275,7 +290,6 @@ static struct sysrq_key_op sysrq_showcpu
 	action_msg:	"Show CPUs",
 };
 
-
 static void sysrq_handle_showstate(int key, struct pt_regs *pt_regs,
 		struct kbd_struct *kbd, struct tty_struct *tty) {
 	show_state();
@@ -409,7 +423,7 @@ static __inline__ int sysrq_key_table_ke
  */
 
 void __sysrq_lock_table (void) { spin_lock(&sysrq_key_table_lock); }
-
+int __sysrq_trylock_table (void) { return spin_trylock(&sysrq_key_table_lock); }
 void __sysrq_unlock_table (void) { spin_unlock(&sysrq_key_table_lock); }
 
 /*
@@ -440,10 +454,12 @@ void __sysrq_put_key_op (int key, struct
 
 void handle_sysrq(int key, struct pt_regs *pt_regs,
 		  struct kbd_struct *kbd, struct tty_struct *tty) {
-	if (!sysrq_enabled)
+	if (!sysrq_ctls.enabled)
+		return;
+
+	if (!__sysrq_trylock_table())
 		return;
 
-	__sysrq_lock_table();
 	__handle_sysrq_nolock(key, pt_regs, kbd, tty);
 	__sysrq_unlock_table();
 }
@@ -460,7 +476,7 @@ void __handle_sysrq_nolock(int key, stru
 	int orig_log_level;
 	int i, j;
 	
-	if (!sysrq_enabled)
+	if (!sysrq_ctls.enabled)
 		return;
 
 	orig_log_level = console_loglevel;
diff -urNp linux-870/drivers/input/keybdev.c linux-871/drivers/input/keybdev.c
--- linux-870/drivers/input/keybdev.c
+++ linux-871/drivers/input/keybdev.c
@@ -42,7 +42,7 @@
     defined(CONFIG_PPC) || defined(__mc68000__) || defined(__hppa__) || \
     defined(__arm__)
 
-static int x86_sysrq_alt = 0;
+static int x86_sysrq_alt, x86_sysrq_alt_pending;
 #ifdef CONFIG_SPARC64
 static int sparc_l1_a_state = 0;
 extern void batten_down_hatches(void);
@@ -117,9 +117,9 @@ static int emulate_raw(unsigned int keyc
 		return 0;
 	} 
 
-	if (keycode == KEY_SYSRQ && x86_sysrq_alt) {
+	if (keycode == KEY_SYSRQ && (x86_sysrq_alt || x86_sysrq_alt_pending)) {
 		handle_scancode(0x54, down);
-
+		x86_sysrq_alt_pending = down;
 		return 0;
 	}
 
diff -urNp linux-870/include/asm-s390/keyboard.h linux-871/include/asm-s390/keyboard.h
--- linux-870/include/asm-s390/keyboard.h
+++ linux-871/include/asm-s390/keyboard.h
@@ -0,0 +1 @@
+#define SYSRQ_KEY 0
diff -urNp linux-870/include/asm-s390x/keyboard.h linux-871/include/asm-s390x/keyboard.h
--- linux-870/include/asm-s390x/keyboard.h
+++ linux-871/include/asm-s390x/keyboard.h
@@ -0,0 +1 @@
+#define SYSRQ_KEY 0
diff -urNp linux-870/include/linux/sysctl.h linux-871/include/linux/sysctl.h
--- linux-870/include/linux/sysctl.h
+++ linux-871/include/linux/sysctl.h
@@ -107,7 +107,7 @@ enum
 	KERN_MSGMAX=35,         /* int: Maximum size of a messege */
 	KERN_MSGMNB=36,         /* int: Maximum message queue size */
 	KERN_MSGPOOL=37,        /* int: Maximum system message pool size */
-	KERN_SYSRQ=38,		/* int: Sysreq enable */
+	KERN_SYSRQ=38,		/* struct: Sysreq enable, keycode, sticky */
 	KERN_MAX_THREADS=39,	/* int: Maximum nr of threads in the system */
  	KERN_RANDOM=40,		/* Random driver */
  	KERN_SHMALL=41,		/* int: Maximum size of shared memory */
diff -urNp linux-870/include/linux/sysrq.h linux-871/include/linux/sysrq.h
--- linux-870/include/linux/sysrq.h
+++ linux-871/include/linux/sysrq.h
@@ -28,6 +28,14 @@ struct sysrq_key_op {
 
 #ifdef CONFIG_MAGIC_SYSRQ
 
+/*  sysrq_ctls - controls aspects of the SYSRQ magic key hack*/
+struct sysrq_ctls_struct {
+	int enabled;
+	int keycode;
+	int sticky;
+	int timer;
+};
+
 /* Generic SysRq interface -- you may call it from any device driver, supplying
  * ASCII code of the key, pointer to registers and kbd/tty structs (if they
  * are available -- else NULL's).
@@ -52,6 +60,7 @@ void __handle_sysrq_nolock(int, struct p
  */
 
 void __sysrq_lock_table (void);
+int __sysrq_trylock_table (void);
 void __sysrq_unlock_table (void);
 struct sysrq_key_op *__sysrq_get_key_op (int key);
 void __sysrq_put_key_op (int key, struct sysrq_key_op *op_p);
diff -urNp linux-870/kernel/sysctl.c linux-871/kernel/sysctl.c
--- linux-870/kernel/sysctl.c
+++ linux-871/kernel/sysctl.c
@@ -51,7 +51,7 @@ extern int sysctl_overcommit_memory;
 extern int max_threads;
 extern atomic_t nr_queued_signals;
 extern int max_queued_signals;
-extern int sysrq_enabled;
+extern struct sysrq_ctls_struct sysrq_ctls;
 extern int core_uses_pid;
 extern int core_setuid_ok;
 extern char core_pattern[];
@@ -266,7 +266,13 @@ static ctl_table kern_table[] = {
 	 0644, NULL, &proc_dointvec},
 #endif
 #ifdef CONFIG_MAGIC_SYSRQ
-	{KERN_SYSRQ, "sysrq", &sysrq_enabled, sizeof (int),
+	{KERN_SYSRQ, "sysrq", &sysrq_ctls.enabled, sizeof (int),
+	 0644, NULL, &proc_dointvec},
+	{KERN_SYSRQ, "sysrq-key", &sysrq_ctls.keycode, sizeof (sysrq_ctls.keycode),
+	 0644, NULL, &proc_dointvec},
+	{KERN_SYSRQ, "sysrq-sticky", &sysrq_ctls.sticky, sizeof (sysrq_ctls.sticky),
+	 0644, NULL, &proc_dointvec},
+	{KERN_SYSRQ, "sysrq-timer", &sysrq_ctls.timer, sizeof (sysrq_ctls.timer),
 	 0644, NULL, &proc_dointvec},
 #endif	 
 	{KERN_CADPID, "cad_pid", &cad_pid, sizeof (int),
