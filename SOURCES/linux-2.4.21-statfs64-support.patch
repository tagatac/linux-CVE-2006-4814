diff -urNp linux-6200/arch/i386/kernel/entry.S linux-6210/arch/i386/kernel/entry.S
--- linux-6200/arch/i386/kernel/entry.S
+++ linux-6210/arch/i386/kernel/entry.S
@@ -795,8 +795,8 @@ ENTRY(sys_call_table)
  	.long SYMBOL_NAME(sys_ni_syscall)	/* 265 sys_clock_gettime */
  	.long SYMBOL_NAME(sys_ni_syscall)	/* sys_clock_getres */
  	.long SYMBOL_NAME(sys_ni_syscall)	/* sys_clock_nanosleep */
-	.long SYMBOL_NAME(sys_ni_syscall)	/* sys_statfs64 */
-	.long SYMBOL_NAME(sys_ni_syscall)	/* sys_fstatfs64 */
+	.long sys_statfs64
+	.long sys_fstatfs64
  	.long SYMBOL_NAME(sys_tgkill)		/* 270 */
 
 	.rept NR_syscalls-(.-sys_call_table)/4
diff -urNp linux-6200/fs/nfs/inode.c linux-6210/fs/nfs/inode.c
--- linux-6200/fs/nfs/inode.c
+++ linux-6210/fs/nfs/inode.c
@@ -96,6 +96,9 @@ static void nfs_put_super(struct super_b
 static void nfs_clear_inode(struct inode *);
 static void nfs_umount_begin(struct super_block *);
 static int  nfs_statfs(struct super_block *, struct statfs *);
+#ifdef __ARCH_HAS_STATFS64
+static int  nfs_statfs64(struct super_block *, struct statfs64 *);
+#endif
 static int  nfs_show_options(struct seq_file *, struct vfsmount *);
 extern void nfs3_fixup_xdr_tables(unsigned int max_acl);
 
@@ -108,6 +111,9 @@ static struct super_operations nfs_sops 
 	clear_inode:	nfs_clear_inode,
 	umount_begin:	nfs_umount_begin,
 	show_options:	nfs_show_options,
+#ifdef __ARCH_HAS_STATFS64
+	statfs64:	nfs_statfs64,
+#endif
 };
 
 #ifdef CONFIG_NFS_ACL
@@ -437,6 +443,9 @@ nfs_read_super(struct super_block *sb, v
 
 	sb->s_magic      = NFS_SUPER_MAGIC;
 	sb->s_op         = &nfs_sops;
+#ifdef __ARCH_HAS_STATFS64
+	sb->s_flags	|= MS_HAS_STATFS64;
+#endif
 	server           = &sb->u.nfs_sb.s_server;
 	if (data->rsize)
 		server->rsize = nfs_block_size(data->rsize, NULL);
@@ -690,6 +699,41 @@ nfs_statfs(struct super_block *sb, struc
 }
 #undef TOOBIG
 
+#ifdef __ARCH_HAS_STATFS64
+static int
+nfs_statfs64(struct super_block *sb, struct statfs64 *buf)
+{
+	struct nfs_server *server = &sb->u.nfs_sb.s_server;
+	unsigned char blockbits;
+	unsigned long blockres;
+	struct nfs_fattr attr;
+	struct nfs_fsstat res = { &attr, };
+	int error;
+
+	error = server->rpc_ops->statfs(server, NFS_FH(sb->s_root->d_inode), &res);
+	buf->f_type = NFS_SUPER_MAGIC;
+	if (error < 0) {
+		printk("nfs_statfs64: statfs error = %d\n", -error);
+		goto out_err;
+	}
+
+	buf->f_bsize = sb->s_blocksize;
+	blockbits = sb->s_blocksize_bits;
+	blockres = (1 << blockbits) - 1;
+	buf->f_namelen = server->namelen;
+	buf->f_blocks = (res.tbytes + blockres) >> blockbits;
+	buf->f_bfree = (res.fbytes + blockres) >> blockbits;
+	buf->f_bavail = (res.abytes + blockres) >> blockbits;
+	buf->f_files = res.tfiles;
+	buf->f_ffree = res.afiles;
+	return 0;
+
+ out_err:
+	buf->f_bsize = buf->f_blocks = buf->f_bfree = buf->f_bavail = -1;
+	return 0;
+}
+#endif
+
 static int nfs_show_options(struct seq_file *m, struct vfsmount *mnt)
 {
 	static struct proc_nfs_info {
diff -urNp linux-6200/fs/open.c linux-6210/fs/open.c
--- linux-6200/fs/open.c
+++ linux-6210/fs/open.c
@@ -71,6 +71,80 @@ out:
 	return error;
 }
 
+#ifdef __ARCH_HAS_STATFS64
+static int vfs_statfs64(struct super_block *sb, struct statfs64 *buf)
+{
+	int retval;
+
+	if (sb->s_flags & MS_HAS_STATFS64) {
+		memset(buf, 0, sizeof(struct statfs64));
+		lock_kernel();
+		retval = sb->s_op->statfs64(sb, buf);
+		unlock_kernel();
+		if (retval)
+			return retval;
+	} else {
+		struct statfs st;
+		/* Fall back to the 32 bit filesystem call. */
+		retval = vfs_statfs(sb, &st);
+		if (retval)
+			return retval;
+		/* Stuff the 32 bit values into the 64 bit struct */
+		buf->f_type = st.f_type;
+		buf->f_bsize = st.f_bsize;
+		buf->f_blocks = st.f_blocks;
+		buf->f_bfree = st.f_bfree;
+		buf->f_bavail = st.f_bavail;
+		buf->f_files = st.f_files;
+		buf->f_ffree = st.f_ffree;
+		buf->f_fsid = st.f_fsid;
+		buf->f_namelen = st.f_namelen;
+		memset(buf->f_spare, 0, sizeof(buf->f_spare));
+	}
+	return 0;
+}
+
+asmlinkage long sys_statfs64(const char *path, size_t sz, struct statfs64 *buf)
+{
+	struct nameidata nd;
+	long error;
+
+	if (sz != sizeof(*buf))
+		return -EINVAL;
+	error = user_path_walk(path, &nd);
+	if (!error) {
+		struct statfs64 tmp;
+		error = vfs_statfs64(nd.dentry->d_inode->i_sb, &tmp);
+		if (!error && copy_to_user(buf, &tmp, sizeof(tmp)))
+			error = -EFAULT;
+		path_release(&nd);
+	}
+	return error;
+}
+
+
+asmlinkage long sys_fstatfs64(unsigned int fd, size_t sz, struct statfs64 *buf)
+{
+	struct file * file;
+	struct statfs64 tmp;
+	int error;
+
+	if (sz != sizeof(*buf))
+		return -EINVAL;
+
+	error = -EBADF;
+	file = fget(fd);
+	if (!file)
+		goto out;
+	error = vfs_statfs64(file->f_dentry->d_inode->i_sb, &tmp);
+	if (!error && copy_to_user(buf, &tmp, sizeof(tmp)))
+		error = -EFAULT;
+	fput(file);
+out:
+	return error;
+}
+#endif /* __ARCH_HAS_STATFS64 */
+
 /*
  * Install a file pointer in the fd array.  
  *
diff -urNp linux-6200/include/asm-i386/statfs.h linux-6210/include/asm-i386/statfs.h
--- linux-6200/include/asm-i386/statfs.h
+++ linux-6210/include/asm-i386/statfs.h
@@ -22,4 +22,32 @@ struct statfs {
 	long f_spare[6];
 };
 
+struct statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_spare[6];
+};
+
+struct compat_statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_spare[6];
+};
+
+#define __ARCH_HAS_STATFS64
+
 #endif
diff -urNp linux-6200/include/linux/fs.h linux-6210/include/linux/fs.h
--- linux-6200/include/linux/fs.h
+++ linux-6210/include/linux/fs.h
@@ -112,6 +112,7 @@ extern int leases_enable, dir_notify_ena
 #define MS_REC		16384
 #define MS_VERBOSE	32768
 #define MS_POSIXACL	65536	/* VFS does not apply the umask */
+#define MS_HAS_STATFS64 (1<<28)
 #define MS_SENDFILE_FOP (1<<29)
 #define MS_ACTIVE	(1<<30)
 #define MS_NOUSER	(1<<31)
@@ -1008,6 +1009,11 @@ struct super_operations {
 	struct dentry * (*fh_to_dentry)(struct super_block *sb, __u32 *fh, int len, int fhtype, int parent);
 	int (*dentry_to_fh)(struct dentry *, __u32 *fh, int *lenp, int need_parent);
 	int (*show_options)(struct seq_file *, struct vfsmount *);
+#ifdef __ARCH_HAS_STATFS64
+#ifndef __GENKSYMS__ /* preserve KMI/ABI ksyms compatibility for mod linkage */
+	int (*statfs64)(struct super_block *, struct statfs64 *);
+#endif
+#endif
 };
 
 /* Inode state bits.. */
