diff -urNp linux-7030/drivers/scsi/scsi.c linux-7040/drivers/scsi/scsi.c
--- linux-7030/drivers/scsi/scsi.c
+++ linux-7040/drivers/scsi/scsi.c
@@ -117,8 +117,10 @@ const unsigned char scsi_command_size[8]
 	16, 12, 10, 10
 };
 static unsigned long serial_number;
-static Scsi_Cmnd *scsi_bh_queue_head;
-static Scsi_Cmnd *scsi_bh_queue_tail;
+static union scsi_done_queue {
+	struct list_head list;
+	char __pad[SMP_CACHE_BYTES];
+} scsi_done_cmnds[NR_CPUS] __cacheline_aligned;
 
 /*
  * Note - the initial logging level can be set here to log events at boot time.
@@ -259,12 +261,6 @@ static void scsi_wait_done(Scsi_Cmnd * S
 static spinlock_t device_request_lock = SPIN_LOCK_UNLOCKED;
 
 /*
- * Used to protect insertion into and removal from the queue of
- * commands to be processed by the bottom half handler.
- */
-static spinlock_t scsi_bhqueue_lock = SPIN_LOCK_UNLOCKED;
-
-/*
  * Function:    scsi_allocate_request
  *
  * Purpose:     Allocate a request descriptor.
@@ -1155,12 +1151,10 @@ void scsi_done(Scsi_Cmnd * SCpnt)
 		SCSI_LOG_MLCOMPLETE(1, printk("Ignoring completion of %p due to timeout status", SCpnt));
 		return;
 	}
-	spin_lock_irqsave(&scsi_bhqueue_lock, flags);
 
 	SCpnt->serial_number_at_timeout = 0;
 	SCpnt->state = SCSI_STATE_BHQUEUE;
 	SCpnt->owner = SCSI_OWNER_BH_HANDLER;
-	SCpnt->bh_next = NULL;
 
 	/*
 	 * Next, put this command in the BH queue.
@@ -1181,23 +1175,17 @@ void scsi_done(Scsi_Cmnd * SCpnt)
 	 * Don't make any assumptions, and we also don't need any other lock
 	 * besides the bh queue lock.  (DL)
 	 */
-	if (!scsi_bh_queue_head) {
-		scsi_bh_queue_head = SCpnt;
-		scsi_bh_queue_tail = SCpnt;
-	} else {
-		scsi_bh_queue_tail->bh_next = SCpnt;
-		scsi_bh_queue_tail = SCpnt;
-	}
-
-	spin_unlock_irqrestore(&scsi_bhqueue_lock, flags);
+	local_irq_save(flags);
+	list_add_tail(&SCpnt->sc_list, &scsi_done_cmnds[smp_processor_id()].list);
+	local_irq_restore(flags);
 	/*
 	 * Mark the bottom half handler to be run.
 	 */
-	mark_bh(SCSI_BH);
+	raise_softirq(SCSI_SOFTIRQ);
 }
 
 /*
- * Procedure:   scsi_bottom_half_handler
+ * Procedure:   scsi_softirq_handler
  *
  * Purpose:     Called after we have finished processing interrupts, it
  *              performs post-interrupt handling for commands that may
@@ -1219,105 +1207,100 @@ void scsi_done(Scsi_Cmnd * SCpnt)
  * half queue.  Thus the only time we hold the lock here is when
  * we wish to atomically remove the contents of the queue.
  */
-void scsi_bottom_half_handler(void)
+void scsi_softirq_handler(struct softirq_action *not_used)
 {
 	struct Scsi_Host *host;
 	Scsi_Cmnd *SCpnt;
-	Scsi_Cmnd *SCnext;
-	unsigned long flags;
+	int cpu = smp_processor_id();
+	struct list_head *item;
 
 
 	while (1 == 1) {
-		spin_lock_irqsave(&scsi_bhqueue_lock, flags);
-		SCpnt = scsi_bh_queue_head;
-		scsi_bh_queue_head = NULL;
-		spin_unlock_irqrestore(&scsi_bhqueue_lock, flags);
-
-		if (SCpnt == NULL) {
+		local_irq_disable();
+		item = list_first(&scsi_done_cmnds[cpu].list);
+		if(!item) {
+			local_irq_enable();
 			return;
 		}
-		SCnext = SCpnt->bh_next;
-
-		for (; SCpnt; SCpnt = SCnext) {
-			SCnext = SCpnt->bh_next;
+		SCpnt = list_entry(item, struct scsi_cmnd, sc_list);
+		list_del(item);
+		local_irq_enable();
+
+		host = SCpnt->host;
+		switch (scsi_decide_disposition(SCpnt)) {
+		case SUCCESS:
+			/*
+			 * Add to BH queue.
+			 */
+			SCSI_LOG_MLCOMPLETE(3, printk("Command finished %d %d 0x%x\n", atomic_read(&SCpnt->host->host_busy),
+					SCpnt->host->host_failed,
+						 SCpnt->result));
 
-			host = SCpnt->host;
-			switch (scsi_decide_disposition(SCpnt)) {
-			case SUCCESS:
-				/*
-				 * Add to BH queue.
-				 */
-				SCSI_LOG_MLCOMPLETE(3, printk("Command finished %d %d 0x%x\n", atomic_read(&SCpnt->host->host_busy),
-						SCpnt->host->host_failed,
-							 SCpnt->result));
+			scsi_finish_command(SCpnt);
+			break;
+		case NEEDS_RETRY:
+			/*
+			 * We only come in here if we want to retry a command.  The
+			 * test to see whether the command should be retried should be
+			 * keeping track of the number of tries, so we don't end up looping,
+			 * of course.
+			 */
+			SCSI_LOG_MLCOMPLETE(3, printk("Command needs retry %d %d 0x%x\n", atomic_read(&SCpnt->host->host_busy),
+			SCpnt->host->host_failed, SCpnt->result));
 
-				scsi_finish_command(SCpnt);
-				break;
-			case NEEDS_RETRY:
-				/*
-				 * We only come in here if we want to retry a command.  The
-				 * test to see whether the command should be retried should be
-				 * keeping track of the number of tries, so we don't end up looping,
-				 * of course.
-				 */
-				SCSI_LOG_MLCOMPLETE(3, printk("Command needs retry %d %d 0x%x\n", atomic_read(&SCpnt->host->host_busy),
-				SCpnt->host->host_failed, SCpnt->result));
+			scsi_retry_command(SCpnt);
+			break;
+		case ADD_TO_MLQUEUE:
+			/* 
+			 * This typically happens for a QUEUE_FULL message -
+			 * typically only when the queue depth is only
+			 * approximate for a given device.  Adding a command
+			 * to the queue for the device will prevent further commands
+			 * from being sent to the device, so we shouldn't end up
+			 * with tons of things being sent down that shouldn't be.
+			 */
+			SCSI_LOG_MLCOMPLETE(3, printk("Command rejected as device queue full, put on ml queue %p\n",
+                                                             SCpnt));
+			scsi_mlqueue_insert(SCpnt, SCSI_MLQUEUE_DEVICE_BUSY);
+			break;
+		default:
+			/*
+			 * Here we have a fatal error of some sort.  Turn it over to
+			 * the error handler.
+			 */
+			SCSI_LOG_MLCOMPLETE(3, printk("Command failed %p %x active=%d busy=%d failed=%d\n",
+					    SCpnt, SCpnt->result,
+			  atomic_read(&SCpnt->host->host_active),
+			  atomic_read(&SCpnt->host->host_busy),
+				      SCpnt->host->host_failed));
 
-				scsi_retry_command(SCpnt);
-				break;
-			case ADD_TO_MLQUEUE:
-				/* 
-				 * This typically happens for a QUEUE_FULL message -
-				 * typically only when the queue depth is only
-				 * approximate for a given device.  Adding a command
-				 * to the queue for the device will prevent further commands
-				 * from being sent to the device, so we shouldn't end up
-				 * with tons of things being sent down that shouldn't be.
-				 */
-				SCSI_LOG_MLCOMPLETE(3, printk("Command rejected as device queue full, put on ml queue %p\n",
-                                                              SCpnt));
-				scsi_mlqueue_insert(SCpnt, SCSI_MLQUEUE_DEVICE_BUSY);
-				break;
-			default:
+			/*
+			 * Dump the sense information too.
+			 */
+			if ((status_byte(SCpnt->result) & CHECK_CONDITION) != 0) {
+				SCSI_LOG_MLCOMPLETE(3, print_sense("bh", SCpnt));
+			}
+			if (SCpnt->host->eh_wait != NULL) {
+				SCpnt->host->host_failed++;
+				SCpnt->owner = SCSI_OWNER_ERROR_HANDLER;
+				SCpnt->state = SCSI_STATE_FAILED;
+				SCpnt->host->in_recovery = 1;
 				/*
-				 * Here we have a fatal error of some sort.  Turn it over to
-				 * the error handler.
+				 * If the host is having troubles, then look to see if this was the last
+				 * command that might have failed.  If so, wake up the error handler.
 				 */
-				SCSI_LOG_MLCOMPLETE(3, printk("Command failed %p %x active=%d busy=%d failed=%d\n",
-						    SCpnt, SCpnt->result,
-				  atomic_read(&SCpnt->host->host_active),
-				  atomic_read(&SCpnt->host->host_busy),
-					      SCpnt->host->host_failed));
-
+				if (atomic_read(&SCpnt->host->host_busy) == SCpnt->host->host_failed) {
+					SCSI_LOG_ERROR_RECOVERY(5, printk("Waking error handler thread (%d)\n",
+									  atomic_read(&SCpnt->host->eh_wait->count)));
+					up(SCpnt->host->eh_wait);
+				}
+			} else {
 				/*
-				 * Dump the sense information too.
+				 * We only get here if the error recovery thread has died.
 				 */
-				if ((status_byte(SCpnt->result) & CHECK_CONDITION) != 0) {
-					SCSI_LOG_MLCOMPLETE(3, print_sense("bh", SCpnt));
-				}
-				if (SCpnt->host->eh_wait != NULL) {
-					SCpnt->host->host_failed++;
-					SCpnt->owner = SCSI_OWNER_ERROR_HANDLER;
-					SCpnt->state = SCSI_STATE_FAILED;
-					SCpnt->host->in_recovery = 1;
-					/*
-					 * If the host is having troubles, then look to see if this was the last
-					 * command that might have failed.  If so, wake up the error handler.
-					 */
-					if (atomic_read(&SCpnt->host->host_busy) == SCpnt->host->host_failed) {
-						SCSI_LOG_ERROR_RECOVERY(5, printk("Waking error handler thread (%d)\n",
-										  atomic_read(&SCpnt->host->eh_wait->count)));
-						up(SCpnt->host->eh_wait);
-					}
-				} else {
-					/*
-					 * We only get here if the error recovery thread has died.
-					 */
-					scsi_finish_command(SCpnt);
-				}
+				scsi_finish_command(SCpnt);
 			}
-		}		/* for(; SCpnt...) */
-
+		}
 	}			/* while(1==1) */
 
 }
@@ -2603,6 +2586,7 @@ __setup("scsihosts=", scsi_setup);
 static int __init init_scsi(void)
 {
 	struct proc_dir_entry *generic;
+	int i;
 
 	printk(KERN_INFO "SCSI subsystem driver " REVISION "\n");
 
@@ -2633,11 +2617,13 @@ static int __init init_scsi(void)
         if (scsihosts)
 		printk(KERN_INFO "scsi: host order: %s\n", scsihosts);	
 	scsi_host_no_init (scsihosts);
+	for(i=0; i < NR_CPUS; i++)
+		INIT_LIST_HEAD(&scsi_done_cmnds[i].list);
 	/*
 	 * This is where the processing takes place for most everything
 	 * when commands are completed.
 	 */
-	init_bh(SCSI_BH, scsi_bottom_half_handler);
+	open_softirq(SCSI_SOFTIRQ, scsi_softirq_handler, NULL);
 
 	return 0;
 }
@@ -2646,8 +2632,6 @@ static void __exit exit_scsi(void)
 {
 	Scsi_Host_Name *shn, *shn2 = NULL;
 
-	remove_bh(SCSI_BH);
-
         devfs_unregister (scsi_devfs_handle);
         for (shn = scsi_host_no_list;shn;shn = shn->next) {
 		if (shn->name)
diff -urNp linux-7030/drivers/scsi/scsi_error.c linux-7040/drivers/scsi/scsi_error.c
--- linux-7030/drivers/scsi/scsi_error.c
+++ linux-7040/drivers/scsi/scsi_error.c
@@ -84,7 +84,7 @@ STATIC void scsi_eh_action_done(Scsi_Cmn
 STATIC int scsi_eh_retry_command(Scsi_Cmnd *);
 STATIC int scsi_eh_completed_normally(Scsi_Cmnd * SCpnt);
 STATIC void scsi_restart_operations(struct Scsi_Host *);
-STATIC void scsi_eh_finish_command(Scsi_Cmnd ** SClist, Scsi_Cmnd * SCpnt);
+STATIC void scsi_eh_finish_command(struct list_head *, Scsi_Cmnd *);
 
 
 /*
@@ -722,10 +722,9 @@ STATIC int scsi_unit_is_ready(Scsi_Cmnd 
  *              a list of pending commands for final completion, and once we
  *              are ready to leave error handling we handle completion for real.
  */
-STATIC void scsi_eh_finish_command(Scsi_Cmnd ** SClist, Scsi_Cmnd * SCpnt)
+STATIC void scsi_eh_finish_command(struct list_head * SClist, Scsi_Cmnd * SCpnt)
 {
 	SCpnt->state = SCSI_STATE_BHQUEUE;
-	SCpnt->bh_next = *SClist;
 	/*
 	 * Set this back so that the upper level can correctly free up
 	 * things.
@@ -733,7 +732,7 @@ STATIC void scsi_eh_finish_command(Scsi_
 	SCpnt->use_sg = SCpnt->old_use_sg;
 	SCpnt->sc_data_direction = SCpnt->sc_old_data_direction;
 	SCpnt->underflow = SCpnt->old_underflow;
-	*SClist = SCpnt;
+	list_add_tail(&SCpnt->sc_list, SClist);
 }
 
 /*
@@ -1326,13 +1325,12 @@ STATIC int scsi_unjam_host(struct Scsi_H
 	Scsi_Cmnd *SCpnt;
 	Scsi_Device *SDpnt;
 	Scsi_Device *SDloop;
-	Scsi_Cmnd *SCdone;
+	LIST_HEAD(SCdone);
+	struct list_head *item, *tmp_item;
 	int timed_out;
 
 	ASSERT_LOCK(host->host_lock, 0);
 
-	SCdone = NULL;
-
 	/*
 	 * First, protect against any sort of race condition.  If any of the outstanding
 	 * commands are in states that indicate that we are not yet blocked (i.e. we are
@@ -1820,9 +1818,9 @@ STATIC int scsi_unjam_host(struct Scsi_H
 	 * be we can create a special version of this function to do the
 	 * same job for us.
 	 */
-	for (SCpnt = SCdone; SCpnt != NULL; SCpnt = SCdone) {
-		SCdone = SCpnt->bh_next;
-		SCpnt->bh_next = NULL;
+	list_for_each_safe(item, tmp_item, &SCdone) {
+		SCpnt = list_entry(item, struct scsi_cmnd, sc_list);
+		list_del(&SCpnt->sc_list);
                 /*
                  * Oh, this is a vile hack.  scsi_done() expects a timer
                  * to be running on the command.  If there isn't, it assumes
@@ -1834,6 +1832,10 @@ STATIC int scsi_unjam_host(struct Scsi_H
                  * the command, and then process it.
                  */
 		scsi_add_timer(SCpnt, 100, scsi_eh_times_out);
+		/*
+		 * scsi_done() will disable interrupts before frobbing
+		 * the softirq list, so we are safe here without any locks.
+		 */
 		scsi_done(SCpnt);
 	}
 
diff -urNp linux-7030/drivers/scsi/scsi_queue.c linux-7040/drivers/scsi/scsi_queue.c
--- linux-7030/drivers/scsi/scsi_queue.c
+++ linux-7040/drivers/scsi/scsi_queue.c
@@ -131,7 +131,6 @@ int scsi_mlqueue_insert(Scsi_Cmnd * cmd,
 	 */
 	cmd->state = SCSI_STATE_MLQUEUE;
 	cmd->owner = SCSI_OWNER_MIDLEVEL;
-	cmd->bh_next = NULL;
 
 	/*
 	 * Decrement the counters, since these commands are no longer
diff -urNp linux-7030/include/linux/interrupt.h linux-7040/include/linux/interrupt.h
--- linux-7030/include/linux/interrupt.h
+++ linux-7040/include/linux/interrupt.h
@@ -34,7 +34,6 @@ enum {
 	SPECIALIX_BH,
 	AURORA_BH,
 	ESP_BH,
-	SCSI_BH,
 	IMMEDIATE_BH,
 	CYCLADES_BH,
 	CM206_BH,
@@ -60,6 +59,7 @@ enum
 	HI_SOFTIRQ=0,
 	NET_TX_SOFTIRQ,
 	NET_RX_SOFTIRQ,
+	SCSI_SOFTIRQ,
 	TASKLET_SOFTIRQ
 };
 
diff -urNp linux-7030/kernel/ksyms.c linux-7040/kernel/ksyms.c
--- linux-7030/kernel/ksyms.c
+++ linux-7040/kernel/ksyms.c
@@ -637,6 +637,7 @@ EXPORT_SYMBOL(tasklet_init);
 EXPORT_SYMBOL(tasklet_kill);
 EXPORT_SYMBOL(__run_task_queue);
 EXPORT_SYMBOL(do_softirq);
+EXPORT_SYMBOL_GPL(open_softirq);
 EXPORT_SYMBOL(raise_softirq);
 EXPORT_SYMBOL(cpu_raise_softirq);
 EXPORT_SYMBOL(__tasklet_schedule);
