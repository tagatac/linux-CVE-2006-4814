diff -urNp linux-262/arch/ia64/ia32/ia32_signal.c linux-264/arch/ia64/ia32/ia32_signal.c
--- linux-262/arch/ia64/ia32/ia32_signal.c
+++ linux-264/arch/ia64/ia32/ia32_signal.c
@@ -478,13 +478,14 @@ ia32_rt_sigsuspend (sigset32_t *uset, un
 
 	sigdelsetmask(&set, ~_BLOCKABLE);
 
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	{
 		oldset = current->blocked;
 		current->blocked = set;
-		recalc_sigpending(current);
+		recalc_sigpending();
 	}
-	spin_unlock_irq(&current->sigmask_lock);
+	__set_current_state(TASK_INTERRUPTIBLE);
+	spin_unlock_irq(&current->sighand->siglock);
 
 	/*
 	 * The return below usually returns to the signal handler.  We need to pre-set the
@@ -493,10 +494,10 @@ ia32_rt_sigsuspend (sigset32_t *uset, un
 	 */
 	scr->pt.r8 = -EINTR;
 	while (1) {
-		current->state = TASK_INTERRUPTIBLE;
 		schedule();
 		if (ia64_do_signal(&oldset, scr, 1))
 			return -EINTR;
+		set_current_state(TASK_INTERRUPTIBLE);
 	}
 }
 
@@ -1016,10 +1017,10 @@ sys32_sigreturn (int arg0, int arg1, int
 		goto badframe;
 
 	sigdelsetmask(&set, ~_BLOCKABLE);
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	current->blocked = (sigset_t) set;
-	recalc_sigpending(current);
-	spin_unlock_irq(&current->sigmask_lock);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
 
 	if (restore_sigcontext_ia32(regs, &frame->sc, &eax))
 		goto badframe;
@@ -1047,10 +1048,10 @@ sys32_rt_sigreturn (int arg0, int arg1, 
 		goto badframe;
 
 	sigdelsetmask(&set, ~_BLOCKABLE);
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	current->blocked =  set;
-	recalc_sigpending(current);
-	spin_unlock_irq(&current->sigmask_lock);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
 
 	if (restore_sigcontext_ia32(regs, &frame->uc.uc_mcontext, &eax))
 		goto badframe;
diff -urNp linux-262/arch/ia64/kernel/ptrace.c linux-264/arch/ia64/kernel/ptrace.c
--- linux-262/arch/ia64/kernel/ptrace.c
+++ linux-264/arch/ia64/kernel/ptrace.c
@@ -61,7 +61,12 @@ ia64_get_scratch_nat_bits (struct pt_reg
 	({										\
 		unsigned long bit = ia64_unat_pos(&pt->r##first);			\
 		unsigned long mask = ((1UL << (last - first + 1)) - 1) << first;	\
-		(ia64_rotl(unat, first) >> bit) & mask;					\
+		unsigned long dist;							\
+		if (bit < first)							\
+			dist = 64 + bit - first;					\
+		else									\
+			dist = bit - first;						\
+		ia64_rotr(unat, dist) & mask;						\
 	})
 	unsigned long val;
 
@@ -82,14 +87,19 @@ ia64_get_scratch_nat_bits (struct pt_reg
 unsigned long
 ia64_put_scratch_nat_bits (struct pt_regs *pt, unsigned long nat)
 {
+#	define PUT_BITS(first, last, nat)						\
+	({										\
+		unsigned long bit = ia64_unat_pos(&pt->r##first);			\
+		unsigned long mask = ((1UL << (last - first + 1)) - 1) << first;	\
+		long dist;								\
+		if (bit < first)							\
+			dist = 64 + bit - first;					\
+		else									\
+			dist = bit - first;						\
+		ia64_rotl(nat & mask, dist);						\
+	})
 	unsigned long scratch_unat;
 
-#	define PUT_BITS(first, last, nat)					\
-	({									\
-		unsigned long bit = ia64_unat_pos(&pt->r##first);		\
-		unsigned long mask = ((1UL << (last - first + 1)) - 1) << bit;	\
-		(ia64_rotr(nat, first) << bit) & mask;				\
-	})
 	scratch_unat  = PUT_BITS( 1,  3, nat);
 	scratch_unat |= PUT_BITS(12, 15, nat);
 	scratch_unat |= PUT_BITS( 8, 11, nat);
@@ -1224,21 +1234,6 @@ sys_ptrace (long request, pid_t pid, uns
 		ret = 0;
 		goto out_tsk;
 
-	      case PTRACE_GETSIGINFO:
-		ret = -EIO;
-		if (!access_ok(VERIFY_WRITE, data, sizeof (siginfo_t)) || !child->thread.siginfo)
-			goto out_tsk;
-		ret = copy_siginfo_to_user((siginfo_t *) data, child->thread.siginfo);
-		goto out_tsk;
-
-	      case PTRACE_SETSIGINFO:
-		ret = -EIO;
-		if (!access_ok(VERIFY_READ, data, sizeof (siginfo_t))
-		    || child->thread.siginfo == 0)
-			goto out_tsk;
-		ret = copy_siginfo_from_user(child->thread.siginfo, (siginfo_t *) data);
-		goto out_tsk;
-
 	      case PTRACE_SYSCALL:	/* continue and stop at next (return from) syscall */
 	      case PTRACE_CONT:		/* restart after signal. */
 		ret = -EIO;
@@ -1317,7 +1312,7 @@ sys_ptrace (long request, pid_t pid, uns
 		goto out_tsk;
 
 	      default:
-		ret = -EIO;
+		ret = ptrace_request(child, request, addr, data);
 		goto out_tsk;
 	}
   out_tsk:
diff -urNp linux-262/arch/ia64/kernel/sigframe.h linux-264/arch/ia64/kernel/sigframe.h
--- linux-262/arch/ia64/kernel/sigframe.h
+++ linux-264/arch/ia64/kernel/sigframe.h
@@ -1,8 +1,3 @@
-struct sigscratch {
-	unsigned long scratch_unat;	/* ar.unat for the general registers saved in pt */
-	unsigned long pad;
-	struct pt_regs pt;
-};
 
 struct sigframe {
 	/*
diff -urNp linux-262/arch/ia64/kernel/signal.c linux-264/arch/ia64/kernel/signal.c
--- linux-262/arch/ia64/kernel/signal.c
+++ linux-264/arch/ia64/kernel/signal.c
@@ -17,6 +17,8 @@
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/stddef.h>
+#include <linux/tty.h>
+#include <linux/binfmts.h>
 #include <linux/unistd.h>
 #include <linux/wait.h>
 
@@ -39,8 +41,6 @@
 # define GET_SIGSET(k,u)	__get_user((k)->sig[0], &(u)->sig[0])
 #endif
 
-extern long ia64_do_signal (sigset_t *, struct sigscratch *, long);	/* forward decl */
-
 register double f16 asm ("f16"); register double f17 asm ("f17");
 register double f18 asm ("f18"); register double f19 asm ("f19");
 register double f20 asm ("f20"); register double f21 asm ("f21");
@@ -51,6 +51,8 @@ register double f26 asm ("f26"); registe
 register double f28 asm ("f28"); register double f29 asm ("f29");
 register double f30 asm ("f30"); register double f31 asm ("f31");
 
+int print_fatal_signals;
+
 long
 ia64_rt_sigsuspend (sigset_t *uset, size_t sigsetsize, struct sigscratch *scr)
 {
@@ -68,13 +70,14 @@ ia64_rt_sigsuspend (sigset_t *uset, size
 
 	sigdelsetmask(&set, ~_BLOCKABLE);
 
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	{
 		oldset = current->blocked;
 		current->blocked = set;
-		recalc_sigpending(current);
+		recalc_sigpending();
 	}
-	spin_unlock_irq(&current->sigmask_lock);
+	__set_current_state(TASK_INTERRUPTIBLE);
+	spin_unlock_irq(&current->sighand->siglock);
 
 	/*
 	 * The return below usually returns to the signal handler.  We need to
@@ -85,10 +88,10 @@ ia64_rt_sigsuspend (sigset_t *uset, size
 	scr->pt.r10 = -1;
 
 	while (1) {
-		current->state = TASK_INTERRUPTIBLE;
 		schedule();
 		if (ia64_do_signal(&oldset, scr, 1))
 			return -EINTR;
+		set_current_state(TASK_INTERRUPTIBLE);
 	}
 }
 
@@ -279,12 +282,12 @@ ia64_rt_sigreturn (struct sigscratch *sc
 
 	sigdelsetmask(&set, ~_BLOCKABLE);
 
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	{
 		current->blocked = set;
-		recalc_sigpending(current);
+		recalc_sigpending();
 	}
-	spin_unlock_irq(&current->sigmask_lock);
+	spin_unlock_irq(&current->sighand->siglock);
 
 	if (restore_sigcontext(sc, scr))
 		goto give_sigsegv;
@@ -320,7 +323,7 @@ ia64_rt_sigreturn (struct sigscratch *sc
 static long
 setup_sigcontext (struct sigcontext *sc, sigset_t *mask, struct sigscratch *scr)
 {
-	unsigned long flags = 0, ifs, nat;
+	unsigned long flags = 0, ifs, cfm, nat;
 	long err;
 
 	ifs = scr->pt.cr_ifs;
@@ -330,7 +333,9 @@ setup_sigcontext (struct sigcontext *sc,
 	if ((ifs & (1UL << 63)) == 0) {
 		/* if cr_ifs isn't valid, we got here through a syscall */
 		flags |= IA64_SC_FLAG_IN_SYSCALL;
-	}
+		cfm = scr->pad & ((1UL << 38) - 1);
+	} else
+		cfm = ifs & ((1UL << 38) - 1);
 	ia64_flush_fph(current);
 	if ((current->thread.flags & IA64_THREAD_FPH_VALID)) {
 		flags |= IA64_SC_FLAG_FPH_VALID;
@@ -349,6 +354,7 @@ setup_sigcontext (struct sigcontext *sc,
 
 	err |= __put_user(nat, &sc->sc_nat);
 	err |= PUT_SIGSET(mask, &sc->sc_mask);
+	err |= __put_user(cfm, &sc->sc_cfm);
 	err |= __put_user(scr->pt.cr_ipsr & IA64_PSR_UM, &sc->sc_um);
 	err |= __put_user(scr->pt.ar_rsc, &sc->sc_ar_rsc);
 	err |= __put_user(scr->pt.ar_ccv, &sc->sc_ar_ccv);
@@ -393,11 +399,11 @@ setup_frame (int sig, struct k_sigaction
 	if ((ka->sa.sa_flags & SA_ONSTACK) && sas_ss_flags((unsigned long) frame) == 0) {
 		frame = (void *) ((current->sas_ss_sp + current->sas_ss_size)
 				  & ~(STACK_ALIGN - 1));
-  		/*
+		/*
 		 * We need to check for the register stack being on the signal stack
 		 * separately, because it's switched separately (memory stack is switched
 		 * in the kernel, register stack is switched in the signal trampoline).
-  		 */
+		 */
 		if (!rbs_on_sig_stack(scr->pt.ar_bspstore))
 			new_rbs  = (current->sas_ss_sp + sizeof(long) - 1) & ~(sizeof(long) - 1);
 	}
@@ -427,6 +433,15 @@ setup_frame (int sig, struct k_sigaction
 	scr->pt.ar_fpsr = FPSR_DEFAULT;			/* reset fpsr for signal handler */
 	scr->pt.cr_iip = tramp_addr;
 	ia64_psr(&scr->pt)->ri = 0;			/* start executing in first slot */
+	/*
+	 * Force the interruption function mask to zero.  This has no effect when a
+	 * system-call got interrupted by a signal (since, in that case, scr->pt_cr_ifs is
+	 * ignored), but it has the desirable effect of making it possible to deliver a
+	 * signal with an incomplete register frame (which happens when a mandatory RSE
+	 * load faults).  Furthermore, it has no negative effect on the getting the user's
+	 * dirty partition preserved, because that's governed by scr->pt.loadrs.
+	 */
+	scr->pt.cr_ifs = (1UL << 63);
 
 	/*
 	 * Note: this affects only the NaT bits of the scratch regs (the ones saved in
@@ -457,28 +472,26 @@ static long
 handle_signal (unsigned long sig, struct k_sigaction *ka, siginfo_t *info, sigset_t *oldset,
 	       struct sigscratch *scr)
 {
-#ifdef CONFIG_IA32_SUPPORT
 	if (IS_IA32_PROCESS(&scr->pt)) {
 		/* send signal to IA-32 process */
 		if (!ia32_setup_frame1(sig, ka, info, oldset, &scr->pt))
 			return 0;
 	} else
-#endif
-	/* send signal to IA-64 process */
-	if (!setup_frame(sig, ka, info, oldset, scr))
-		return 0;
+		/* send signal to IA-64 process */
+		if (!setup_frame(sig, ka, info, oldset, scr))
+			return 0;
 
 	if (ka->sa.sa_flags & SA_ONESHOT)
 		ka->sa.sa_handler = SIG_DFL;
 
 	if (!(ka->sa.sa_flags & SA_NODEFER)) {
-		spin_lock_irq(&current->sigmask_lock);
+		spin_lock_irq(&current->sighand->siglock);
 		{
 			sigorsets(&current->blocked, &current->blocked, &ka->sa.sa_mask);
 			sigaddset(&current->blocked, sig);
-			recalc_sigpending(current);
+			recalc_sigpending();
 		}
-		spin_unlock_irq(&current->sigmask_lock);
+		spin_unlock_irq(&current->sighand->siglock);
 	}
 	return 1;
 }
@@ -490,11 +503,11 @@ handle_signal (unsigned long sig, struct
 long
 ia64_do_signal (sigset_t *oldset, struct sigscratch *scr, long in_syscall)
 {
-	struct signal_struct *sig;
 	struct k_sigaction *ka;
 	siginfo_t info;
 	long restart = in_syscall;
 	long errno = scr->pt.r8;
+#	define ERR_CODE(c)	(IS_IA32_PROCESS(&scr->pt) ? -(c) : (c))
 
 	/*
 	 * In the ia64_leave_kernel code path, we want the common case to go fast, which
@@ -507,7 +520,6 @@ ia64_do_signal (sigset_t *oldset, struct
 	if (!oldset)
 		oldset = &current->blocked;
 
-#ifdef CONFIG_IA32_SUPPORT
 	if (IS_IA32_PROCESS(&scr->pt)) {
 		if (in_syscall) {
 			if (errno >= 0)
@@ -515,9 +527,7 @@ ia64_do_signal (sigset_t *oldset, struct
 			else
 				errno = -errno;
 		}
-	} else
-#endif
-	if (scr->pt.r10 != -1) {
+	} else if (scr->pt.r10 != -1)
 		/*
 		 * A system calls has to be restarted only if one of the error codes
 		 * ERESTARTNOHAND, ERESTARTSYS, or ERESTARTNOINTR is returned.  If r10
@@ -525,130 +535,41 @@ ia64_do_signal (sigset_t *oldset, struct
 		 * restart the syscall, so we can clear the "restart" flag here.
 		 */
 		restart = 0;
-	}
-
-	for (;;) {
-		unsigned long signr;
 
-		spin_lock_irq(&current->sigmask_lock);
-		signr = dequeue_signal(&current->blocked, &info);
-		spin_unlock_irq(&current->sigmask_lock);
+	while (1) {
+		int signr = get_signal_to_deliver(&info, &scr->pt);
 
-		if (!signr)
+		if (signr <= 0)
 			break;
 
-		if ((current->ptrace & PT_PTRACED) && signr != SIGKILL) {
-			/* Let the debugger run.  */
-			current->exit_code = signr;
-			current->thread.siginfo = &info;
-			current->state = TASK_STOPPED;
-			notify_parent(current, SIGCHLD);
-			schedule();
-
-			signr = current->exit_code;
-			current->thread.siginfo = 0;
-
-			/* We're back.  Did the debugger cancel the sig?  */
-			if (!signr)
-				continue;
-			current->exit_code = 0;
-
-			/* The debugger continued.  Ignore SIGSTOP.  */
-			if (signr == SIGSTOP)
-				continue;
-
-			/* Update the siginfo structure.  Is this good?  */
-			if (signr != info.si_signo) {
-				info.si_signo = signr;
-				info.si_errno = 0;
-				info.si_code = SI_USER;
-				info.si_pid = current->p_pptr->pid;
-				info.si_uid = current->p_pptr->uid;
-			}
-
-			/* If the (new) signal is now blocked, requeue it.  */
-			if (sigismember(&current->blocked, signr)) {
-				send_sig_info(signr, &info, current);
-				continue;
-			}
-		}
-
-		ka = &current->sig->action[signr - 1];
-		if (ka->sa.sa_handler == SIG_IGN) {
-			if (signr != SIGCHLD)
-				continue;
-			/* Check for SIGCHLD: it's special.  */
-			while (sys_wait4(-1, NULL, WNOHANG, NULL) > 0)
-				/* nothing */;
-			continue;
-		}
-
-		if (ka->sa.sa_handler == SIG_DFL) {
-			int exit_code = signr;
-
-			/* Init gets no signals it doesn't want.  */
-			if (current->pid == 1)
-				continue;
-
-			switch (signr) {
-			      case SIGCONT: case SIGCHLD: case SIGWINCH: case SIGURG:
-				continue;
-
-			      case SIGTSTP: case SIGTTIN: case SIGTTOU:
-				if (is_orphaned_pgrp(current->pgrp))
-					continue;
-				/* FALLTHRU */
-
-			      case SIGSTOP:
-				current->state = TASK_STOPPED;
-				current->exit_code = signr;
-				sig = current->p_pptr->sig;
-				if (sig && !(sig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))
-					notify_parent(current, SIGCHLD);
-				schedule();
-				continue;
-
-			      case SIGQUIT: case SIGILL: case SIGTRAP:
-			      case SIGABRT: case SIGFPE: case SIGSEGV:
-			      case SIGBUS: case SIGSYS: case SIGXCPU: case SIGXFSZ:
-				if (do_coredump(signr, &scr->pt))
-					exit_code |= 0x80;
-				/* FALLTHRU */
-
-			      default:
-				sig_exit(signr, exit_code, &info);
-				/* NOTREACHED */
-			}
-		}
+		ka = &current->sighand->action[signr - 1];
 
 		if (restart) {
 			switch (errno) {
+			      case ERESTARTNOHAND:
+				scr->pt.r8 = ERR_CODE(EINTR);
+				/* note: scr->pt.r10 is already -1 */
+				break;
+
 			      case ERESTARTSYS:
 				if ((ka->sa.sa_flags & SA_RESTART) == 0) {
-			      case ERESTARTNOHAND:
-#ifdef CONFIG_IA32_SUPPORT
-					if (IS_IA32_PROCESS(&scr->pt))
-						scr->pt.r8 = -EINTR;
-					else
-#endif
-					scr->pt.r8 = EINTR;
+					scr->pt.r8 = ERR_CODE(EINTR);
 					/* note: scr->pt.r10 is already -1 */
 					break;
 				}
 			      case ERESTARTNOINTR:
-#ifdef CONFIG_IA32_SUPPORT
 				if (IS_IA32_PROCESS(&scr->pt)) {
 					scr->pt.r8 = scr->pt.r1;
 					scr->pt.cr_iip -= 2;
 				} else
-#endif
-				ia64_decrement_ip(&scr->pt);
+					ia64_decrement_ip(&scr->pt);
 			}
 		}
 
-		/* Whee!  Actually deliver the signal.  If the
-		   delivery failed, we need to continue to iterate in
-		   this loop so we can deliver the SIGSEGV... */
+		/*
+		 * Whee!  Actually deliver the signal.  If the delivery failed, we need to
+		 * continue to iterate in this loop so we can deliver the SIGSEGV...
+		 */
 		if (handle_signal(signr, ka, &info, oldset, scr))
 			return 1;
 	}
@@ -656,20 +577,19 @@ ia64_do_signal (sigset_t *oldset, struct
 	/* Did we come from a system call? */
 	if (restart) {
 		/* Restart the system call - no handlers present */
-		if (errno == ERESTARTNOHAND || errno == ERESTARTSYS || errno == ERESTARTNOINTR) {
-#ifdef CONFIG_IA32_SUPPORT
+		if (errno == ERESTARTNOHAND || errno == ERESTARTSYS || errno == ERESTARTNOINTR)
+		{
 			if (IS_IA32_PROCESS(&scr->pt)) {
 				scr->pt.r8 = scr->pt.r1;
 				scr->pt.cr_iip -= 2;
-			} else
-#endif
-			/*
-			 * Note: the syscall number is in r15 which is
-			 * saved in pt_regs so all we need to do here
-			 * is adjust ip so that the "break"
-			 * instruction gets re-executed.
-			 */
-			ia64_decrement_ip(&scr->pt);
+			} else {
+				/*
+				 * Note: the syscall number is in r15 which is saved in
+				 * pt_regs so all we need to do here is adjust ip so that
+				 * the "break" instruction gets re-executed.
+				 */
+				ia64_decrement_ip(&scr->pt);
+			}
 		}
 	}
 	return 0;
diff -urNp linux-262/include/asm-ia64/processor.h linux-264/include/asm-ia64/processor.h
--- linux-262/include/asm-ia64/processor.h
+++ linux-264/include/asm-ia64/processor.h
@@ -913,24 +913,13 @@ ia64_get_dbr (__u64 regnum)
 	return retval;
 }
 
-/* XXX remove the handcoded version once we have a sufficiently clever compiler... */
-#ifdef SMART_COMPILER
-# define ia64_rotr(w,n)				\
-  ({						\
-	__u64 _w = (w), _n = (n);		\
-						\
-	(_w >> _n) | (_w << (64 - _n));		\
-  })
-#else
-# define ia64_rotr(w,n)							\
-  ({									\
-	__u64 result;							\
-	asm ("shrp %0=%1,%1,%2" : "=r"(result) : "r"(w), "i"(n));	\
-	result;								\
-  })
-#endif
+static inline __u64
+ia64_rotr (__u64 w, __u64 n)
+{
+	return (w >> n) | (w << (64 - n));
+}
 
-#define ia64_rotl(w,n)	ia64_rotr((w),(64)-(n))
+#define ia64_rotl(w,n)	ia64_rotr((w), (64) - (n))
 
 static inline __u64
 ia64_thash (__u64 addr)
diff -urNp linux-262/include/asm-ia64/signal.h linux-264/include/asm-ia64/signal.h
--- linux-262/include/asm-ia64/signal.h
+++ linux-264/include/asm-ia64/signal.h
@@ -165,6 +165,15 @@ struct k_sigaction {
 };
 
 #  include <asm/sigcontext.h>
+#  include <asm/ptrace.h>
+
+struct sigscratch {
+	unsigned long scratch_unat;
+	unsigned long pad;
+	struct pt_regs pt;
+};
+
+extern long ia64_do_signal (sigset_t *oldset, struct sigscratch *scr, long in_syscall);
 
 #endif /* __KERNEL__ */
 
