diff -urNp linux-5410/arch/ia64/hp/zx1/hpzx1_misc.c linux-5411/arch/ia64/hp/zx1/hpzx1_misc.c
--- linux-5410/arch/ia64/hp/zx1/hpzx1_misc.c
+++ linux-5411/arch/ia64/hp/zx1/hpzx1_misc.c
@@ -227,7 +227,7 @@ hpzx1_lba_probe(acpi_handle obj, u32 dep
 {
 	u64 csr_base = 0, csr_length = 0;
 	acpi_status status;
-	NATIVE_UINT busnum;
+	unsigned long busnum;
 	char *name = context;
 	char fullname[32];
 
diff -urNp linux-5410/arch/ia64/kernel/acpi.c linux-5411/arch/ia64/kernel/acpi.c
--- linux-5410/arch/ia64/kernel/acpi.c
+++ linux-5411/arch/ia64/kernel/acpi.c
@@ -31,6 +31,7 @@
 #include <linux/config.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
+#include <linux/pci.h>
 #include <linux/sched.h>
 #include <linux/smp.h>
 #include <linux/string.h>
@@ -59,6 +60,8 @@ void (*pm_power_off) (void);
 
 unsigned char acpi_kbd_controller_present = 1;
 
+int acpi_disabled = 0;
+
 const char *
 acpi_get_sysname (void)
 {
@@ -111,24 +114,24 @@ acpi_get_sysname (void)
 
 #ifdef CONFIG_ACPI
 
-static acpi_resource *
-acpi_get_crs_next (acpi_buffer *buf, int *offset)
+static struct acpi_resource *
+acpi_get_crs_next (struct acpi_buffer *buf, int *offset)
 {
-	acpi_resource *res;
+	struct acpi_resource *res;
 
 	if (*offset >= buf->length)
 		return NULL;
 
-	res = (acpi_resource *)((char *) buf->pointer + *offset);
+	res = (struct acpi_resource *)((char *) buf->pointer + *offset);
 	*offset += res->length;
 	return res;
 }
 
-static acpi_resource_data *
-acpi_get_crs_type (acpi_buffer *buf, int *offset, int type)
+static union acpi_resource_data *
+acpi_get_crs_type (struct acpi_buffer *buf, int *offset, int type)
 {
 	for (;;) {
-		acpi_resource *res = acpi_get_crs_next(buf, offset);
+		struct acpi_resource *res = acpi_get_crs_next(buf, offset);
 		if (!res)
 			return NULL;
 		if (res->id == type)
@@ -137,20 +140,20 @@ acpi_get_crs_type (acpi_buffer *buf, int
 }
 
 static void
-acpi_get_crs_addr (acpi_buffer *buf, int type, u64 *base, u64 *length, u64 *tra)
+acpi_get_crs_addr (struct acpi_buffer *buf, int type, u64 *base, u64 *length, u64 *tra)
 {
 	int offset = 0;
-	acpi_resource_address16 *addr16;
-	acpi_resource_address32 *addr32;
-	acpi_resource_address64 *addr64;
+	struct acpi_resource_address16 *addr16;
+	struct acpi_resource_address32 *addr32;
+	struct acpi_resource_address64 *addr64;
 
 	for (;;) {
-		acpi_resource *res = acpi_get_crs_next(buf, &offset);
+		struct acpi_resource *res = acpi_get_crs_next(buf, &offset);
 		if (!res)
 			return;
 		switch (res->id) {
 			case ACPI_RSTYPE_ADDRESS16:
-				addr16 = (acpi_resource_address16 *) &res->data;
+				addr16 = (struct acpi_resource_address16 *) &res->data;
 
 				if (type == addr16->resource_type) {
 					*base = addr16->min_address_range;
@@ -160,7 +163,7 @@ acpi_get_crs_addr (acpi_buffer *buf, int
 				}
 				break;
 			case ACPI_RSTYPE_ADDRESS32:
-				addr32 = (acpi_resource_address32 *) &res->data;
+				addr32 = (struct acpi_resource_address32 *) &res->data;
 				if (type == addr32->resource_type) {
 					*base = addr32->min_address_range;
 					*length = addr32->address_length;
@@ -169,7 +172,7 @@ acpi_get_crs_addr (acpi_buffer *buf, int
 				}
 				break;
 			case ACPI_RSTYPE_ADDRESS64:
-				addr64 = (acpi_resource_address64 *) &res->data;
+				addr64 = (struct acpi_resource_address64 *) &res->data;
 				if (type == addr64->resource_type) {
 					*base = addr64->min_address_range;
 					*length = addr64->address_length;
@@ -188,7 +191,7 @@ acpi_status
 acpi_get_addr_space(acpi_handle obj, u8 type, u64 *base, u64 *length, u64 *tra)
 {
 	acpi_status status;
-	acpi_buffer buf = { .length  = ACPI_ALLOCATE_BUFFER,
+	struct acpi_buffer buf = { .length  = ACPI_ALLOCATE_BUFFER,
 			    .pointer = NULL };
 
 	*base = 0;
@@ -225,9 +228,9 @@ acpi_hp_csr_space(acpi_handle obj, u64 *
 {
 	int i, offset = 0;
 	acpi_status status;
-	acpi_buffer buf = { .length  = ACPI_ALLOCATE_BUFFER,
+	struct acpi_buffer buf = { .length  = ACPI_ALLOCATE_BUFFER,
 			    .pointer = NULL };
-	acpi_resource_vendor *res;
+	struct acpi_resource_vendor *res;
 	acpi_hp_vendor_long *hp_res;
 	efi_guid_t vendor_guid;
 
@@ -241,7 +244,7 @@ acpi_hp_csr_space(acpi_handle obj, u64 *
 	}
 
 	status = AE_NOT_FOUND;
-	res = (acpi_resource_vendor *)acpi_get_crs_type(&buf, &offset, ACPI_RSTYPE_VENDOR);
+	res = (struct acpi_resource_vendor *)acpi_get_crs_type(&buf, &offset, ACPI_RSTYPE_VENDOR);
 	if (!res) {
 		printk(KERN_ERR PREFIX "Failed to find config space for device\n");
 		goto out;
@@ -577,7 +580,7 @@ static int __init
 acpi_parse_fadt (unsigned long phys_addr, unsigned long size)
 {
 	struct acpi_table_header *fadt_header;
-	fadt_descriptor_rev2 *fadt;
+	struct fadt_descriptor_rev2 *fadt;
 	u32 sci_irq, gsi_base;
 	char *iosapic_address;
 
@@ -589,7 +592,7 @@ acpi_parse_fadt (unsigned long phys_addr
 	if (fadt_header->revision != 3)
 		return -ENODEV;		/* Only deal with ACPI 2.0 FADT */
 
-	fadt = (fadt_descriptor_rev2 *) fadt_header;
+	fadt = (struct fadt_descriptor_rev2 *) fadt_header;
 
 	if (!(fadt->iapc_boot_arch & BAF_8042_KEYBOARD_CONTROLLER))
 		acpi_kbd_controller_present = 0;
@@ -629,7 +632,7 @@ acpi_boot_init (char *cmdline)
 	int result;
 
 	/* Initialize the ACPI boot-time table parser */
-	result = acpi_table_init(cmdline);
+	result = acpi_table_init();
 	if (result)
 		return result;
 
@@ -686,7 +689,7 @@ skip_madt:
 	 * gets interrupts such as power and sleep buttons.  If it's not
 	 * on a Legacy interrupt, it needs to be setup.
 	 */
-	if (acpi_table_parse(ACPI_FACP, acpi_parse_fadt) < 1)
+	if (acpi_table_parse(ACPI_FADT, acpi_parse_fadt) < 1)
 		printk(KERN_ERR PREFIX "Can't find FADT\n");
 
 #ifdef CONFIG_SMP
@@ -735,19 +738,52 @@ acpi_get_prt (struct pci_vector_struct *
 
 	vector = *vectors;
 
+	/* 
+	 * Make sure all devices described by PCI link device entries
+	 * have valid IRQs 
+	 */
+	if (acpi_pci_link_check()) {
+		printk(KERN_ERR PREFIX "Unable to set PCI link device IRQs\n");
+		return -ENODEV;
+	}
+
 	list_for_each(node, &acpi_prt.entries) {
 		entry = (struct acpi_prt_entry *)node;
 		vector[i].segment = entry->id.segment;
 		vector[i].bus    = entry->id.bus;
 		vector[i].pci_id = ((u32) entry->id.device << 16) | 0xffff;
 		vector[i].pin    = entry->pin;
-		vector[i].irq    = entry->link.index;
+		if (!entry->irq && entry->link.handle)
+			vector[i].irq = acpi_pci_link_get_irq(entry->link.handle, entry->link.index, NULL, NULL);
+		else
+			vector[i].irq = entry->link.index;
 		i++;
 	}
 	*count = acpi_prt.count;
 	return 0;
 }
 
+int
+acpi_get_pci_link_irq_params(struct pci_dev *dev, unsigned char pin, int *trig, int *pol)
+{
+	struct list_head *node;
+	struct acpi_prt_entry *entry;
+
+	list_for_each(node, &acpi_prt.entries) {
+		entry = (struct acpi_prt_entry *)node;
+		
+		if ((entry->id.segment == PCI_SEGMENT(dev)) &&
+		    (entry->id.bus == dev->bus->number) &&
+		    (entry->id.device == PCI_SLOT(dev->devfn)) &&
+		    (entry->pin == pin) &&
+		    (!entry->irq && entry->link.handle)) {
+			acpi_pci_link_get_irq(entry->link.handle, entry->link.index, trig, pol);
+			return 1;
+		}
+	}
+	return 0;
+}
+
 /* Assume IA64 always use I/O SAPIC */
 
 int __init
diff -urNp linux-5410/arch/ia64/kernel/iosapic.c linux-5411/arch/ia64/kernel/iosapic.c
--- linux-5410/arch/ia64/kernel/iosapic.c
+++ linux-5411/arch/ia64/kernel/iosapic.c
@@ -784,10 +784,27 @@ iosapic_fixup_pci_interrupt (struct pci_
 		}
 
 		if (vector >= 0) {
+			int trigger = ACPI_LEVEL_SENSITIVE;
+			int polarity = ACPI_ACTIVE_LOW;
+
 			dev->irq = vector;
 
 			irq_type = &irq_type_iosapic_level;
 			idesc = ia64_irq_desc(vector);
+
+			/* 
+			 * Convert PCI interrupt to level-low, iff
+			 * there is no PCI link device entry that
+			 * specifies otherwise.
+			 */
+			if (acpi_get_pci_link_irq_params(dev, pci_pin, &trigger, &polarity)) {
+				iosapic_intr_info[vector].polarity = polarity;
+				iosapic_intr_info[vector].trigger = trigger;
+				if (polarity == ACPI_ACTIVE_HIGH)
+					printk("%s: changing vector 0x%2x polarity from low to high\n", __FUNCTION__, vector);
+				if (trigger == ACPI_EDGE_SENSITIVE)
+					irq_type = &irq_type_iosapic_edge;
+			}
 			if (idesc->handler != irq_type) {
 				if (idesc->handler != &no_irq_type)
 					printk("%s: changing vector %d from %s to %s\n",
diff -urNp linux-5410/drivers/acpi/osl.c linux-5411/drivers/acpi/osl.c
--- linux-5410/drivers/acpi/osl.c
+++ linux-5411/drivers/acpi/osl.c
@@ -727,7 +727,7 @@ acpi_os_acquire_lock (
 	if (flags & ACPI_NOT_ISR)
 		ACPI_DISABLE_IRQS();
 
-	spin_lock(handle);
+	spin_lock((spinlock_t *)handle);
 
 	return_VOID;
 }
diff -urNp linux-5410/drivers/acpi/tables/tbinstal.c linux-5411/drivers/acpi/tables/tbinstal.c
--- linux-5410/drivers/acpi/tables/tbinstal.c
+++ linux-5411/drivers/acpi/tables/tbinstal.c
@@ -271,22 +271,40 @@ acpi_tb_init_table_descriptor (
 		if (list_head->next) {
 			return_ACPI_STATUS (AE_ALREADY_EXISTS);
 		}
-	}
 
-	/*
-	 * Link the new table in to the list of tables of this type.
-	 * Just insert at the start of the list, order unimportant.
-	 *
-	 * table_desc->Prev is already NULL from calloc()
-	 */
-	table_desc->next = list_head->next;
-	list_head->next = table_desc;
+		table_desc->next = list_head->next;
+		list_head->next = table_desc;
 
-	if (table_desc->next) {
-		table_desc->next->prev = table_desc;
+		if (table_desc->next) {
+			table_desc->next->prev = table_desc;
+		}
+
+		list_head->count++;
 	}
+	else {
+		/*
+		 * Link the new table in to the list of tables of this type.
+		 * Insert at the end of the list, order IS IMPORTANT.
+		 *
+		 * table_desc->Prev & Next are already NULL from calloc()
+		 */
+		list_head->count++;
+
+		if (!list_head->next) {
+			list_head->next = table_desc;
+		}
+		else {
+			table_desc->next = list_head->next;
 
-	list_head->count++;
+			while (table_desc->next->next) {
+				table_desc->next = table_desc->next->next;
+			}
+
+			table_desc->next->next = table_desc;
+			table_desc->prev = table_desc->next;
+			table_desc->next = NULL;
+		}
+	}
 
 	/* Finish initialization of the table descriptor */
 
diff -urNp linux-5410/include/asm-ia64/acpi.h linux-5411/include/asm-ia64/acpi.h
--- linux-5410/include/asm-ia64/acpi.h
+++ linux-5411/include/asm-ia64/acpi.h
@@ -100,6 +100,7 @@ const char *acpi_get_sysname (void);
 int acpi_boot_init (char *cdline);
 int acpi_request_vector (u32 int_type);
 int acpi_get_prt (struct pci_vector_struct **vectors, int *count);
+int acpi_get_pci_link_irq_params (struct pci_dev *dev, unsigned char pin, int *trig, int *pol);
 int acpi_get_interrupt_model (int *type);
 int acpi_irq_to_vector (u32 irq);
 
