diff -urNp linux-5580/fs/lockd/svc4proc.c linux-5590/fs/lockd/svc4proc.c
--- linux-5580/fs/lockd/svc4proc.c
+++ linux-5590/fs/lockd/svc4proc.c
@@ -449,19 +449,35 @@ nlm4svc_proc_sm_notify(struct svc_rqst *
 	if (nlmsvc_ops != NULL) {
 		struct svc_client	*clnt;
 		saddr.sin_addr.s_addr = argp->addr;
-		nlmsvc_ops->exp_readlock();
 		if ((clnt = nlmsvc_ops->exp_getclient(&saddr)) != NULL 
 		 && (host = nlm_lookup_host(clnt, &saddr, 0, 0)) != NULL) {
 			nlmsvc_free_host_resources(host);
 		}
 		nlm_release_host(host);
-		nlmsvc_ops->exp_unlock();
 	}
 
 	return rpc_success;
 }
 
 /*
+ * client sent a GRANTED_RES, let's remove the associated block
+ */
+static int
+nlm4svc_proc_granted_res(struct svc_rqst *rqstp, struct nlm_res  *argp,
+                                                void            *resp)
+{
+        if (!nlmsvc_ops)
+                return rpc_success;
+
+        dprintk("lockd: GRANTED_RES   called\n");
+
+        nlmsvc_grant_reply(&argp->cookie, argp->status);
+        return rpc_success;
+}
+
+
+
+/*
  * This is the generic lockd callback for async RPC calls
  */
 static u32
@@ -524,7 +540,6 @@ nlm4svc_callback_exit(struct rpc_task *t
 #define nlm4svc_proc_lock_res	nlm4svc_proc_null
 #define nlm4svc_proc_cancel_res	nlm4svc_proc_null
 #define nlm4svc_proc_unlock_res	nlm4svc_proc_null
-#define nlm4svc_proc_granted_res	nlm4svc_proc_null
 
 struct nlm_void			{ int dummy; };
 
@@ -559,7 +574,7 @@ struct svc_procedure		nlmsvc_procedures4
   PROC(lock_res,	lockres,	norep,		res,	void, 1),
   PROC(cancel_res,	cancelres,	norep,		res,	void, 1),
   PROC(unlock_res,	unlockres,	norep,		res,	void, 1),
-  PROC(granted_res,	grantedres,	norep,		res,	void, 1),
+  PROC(granted_res,	res,		norep,		res,	void, 1),
   /* statd callback */
   PROC(sm_notify,	reboot,		void,		reboot,	void, 1),
   PROC(none,		void,		void,		void,	void, 0),
diff -urNp linux-5580/fs/lockd/svclock.c linux-5590/fs/lockd/svclock.c
--- linux-5580/fs/lockd/svclock.c
+++ linux-5590/fs/lockd/svclock.c
@@ -64,7 +64,7 @@ nlmsvc_insert_block(struct nlm_block *bl
 	if (when != NLM_NEVER) {
 		if ((when += jiffies) > NLM_NEVER)
 			when = NLM_NEVER;
-		while ((b = *bp) && time_before_eq(b->b_when,when))
+		while ((b = *bp) && time_before_eq(b->b_when,when) && b->b_when != NLM_NEVER)
 			bp = &b->b_next;
 	} else
 		while ((b = *bp))
@@ -113,11 +113,11 @@ nlmsvc_lookup_block(struct nlm_file *fil
 				(long long)lock->fl.fl_end, lock->fl.fl_type);
 	for (head = &nlm_blocked; (block = *head); head = &block->b_next) {
 		fl = &block->b_call.a_args.lock.fl;
-		dprintk("lockd: check f=%p pd=%d %Ld-%Ld ty=%d cookie=%x\n",
+		dprintk("lockd: check f=%p pd=%d %Ld-%Ld ty=%d cookie=%s\n",
 				block->b_file, fl->fl_pid,
 				(long long)fl->fl_start,
 				(long long)fl->fl_end, fl->fl_type,
-				*(unsigned int*)(block->b_call.a_args.cookie.data));
+				nlmdbg_cookie2a(&block->b_call.a_args.cookie));
 		if (block->b_file == file && nlm_compare_locks(fl, &lock->fl)) {
 			if (remove) {
 				*head = block->b_next;
@@ -580,10 +580,10 @@ nlmsvc_grant_callback(struct rpc_task *t
 	unsigned long		timeout;
 
 	dprintk("lockd: GRANT_MSG RPC callback\n");
-	dprintk("callback: looking for cookie %x \n", 
-		*(unsigned int *)(call->a_args.cookie.data));
+	dprintk("callback: looking for cookie %s \n", 
+		nlmdbg_cookie2a(&call->a_args.cookie));
 	if (!(block = nlmsvc_find_block(&call->a_args.cookie))) {
-		dprintk("lockd: no block for cookie %x\n", *(u32 *)(call->a_args.cookie.data));
+		dprintk("lockd: no block for cookie %s\n", nlmdbg_cookie2a(&call->a_args.cookie));
 		return;
 	}
 
@@ -631,7 +631,6 @@ nlmsvc_grant_reply(struct nlm_cookie *co
 		} else {
 			/* Lock is now held by client, or has been rejected.
 			 * In both cases, the block should be removed. */
-			file->f_count++;
 			up(&file->f_sema);
 			if (status == NLM_LCK_GRANTED)
 				nlmsvc_delete_block(block, 0);
diff -urNp linux-5580/fs/lockd/svcproc.c linux-5590/fs/lockd/svcproc.c
--- linux-5580/fs/lockd/svcproc.c
+++ linux-5590/fs/lockd/svcproc.c
@@ -345,15 +345,6 @@ nlmsvc_proc_granted_msg(struct svc_rqst 
 	return stat;
 }
 
-static int
-nlmsvc_proc_granted_res(struct svc_rqst *rqstp, struct nlm_res *argp,
-						void           *resp)
-{
-	dprintk("lockd: GRANTED_RES   called\n");
-	nlmsvc_grant_reply(&argp->cookie, argp->status);
-	return 0;
-}
-
 /*
  * SHARE: create a DOS share or alter existing share.
  */
@@ -486,19 +477,33 @@ nlmsvc_proc_sm_notify(struct svc_rqst *r
 	if (nlmsvc_ops != NULL) {
 		struct svc_client	*clnt;
 		saddr.sin_addr.s_addr = argp->addr;
-		nlmsvc_ops->exp_readlock();
 		if ((clnt = nlmsvc_ops->exp_getclient(&saddr)) != NULL 
 		 && (host = nlm_lookup_host(clnt, &saddr, 0, 0)) != NULL) {
 			nlmsvc_free_host_resources(host);
 		}
 		nlm_release_host(host);
-		nlmsvc_ops->exp_unlock();
 	}
 
 	return rpc_success;
 }
 
 /*
+ * client sent a GRANTED_RES, let's remove the associated block
+ */
+static int
+nlmsvc_proc_granted_res(struct svc_rqst *rqstp, struct nlm_res  *argp,
+                                                void            *resp)
+{
+	if (!nlmsvc_ops)
+		return rpc_success;
+
+	dprintk("lockd: GRANTED_RES   called\n");
+
+	nlmsvc_grant_reply(&argp->cookie, argp->status);
+	return rpc_success;
+}
+
+/*
  * This is the generic lockd callback for async RPC calls
  */
 static u32
diff -urNp linux-5580/fs/lockd/xdr.c linux-5590/fs/lockd/xdr.c
--- linux-5580/fs/lockd/xdr.c
+++ linux-5590/fs/lockd/xdr.c
@@ -55,7 +55,7 @@ static inline u32 *nlm_decode_cookie(u32
 		c->len=4;
 		memset(c->data, 0, 4);	/* hockeypux brain damage */
 	}
-	else if(len<=8)
+	else if(len<=NLM_MAXCOOKIELEN)
 	{
 		c->len=len;
 		memcpy(c->data, p, len);
@@ -64,7 +64,7 @@ static inline u32 *nlm_decode_cookie(u32
 	else 
 	{
 		printk(KERN_NOTICE
-			"lockd: bad cookie size %d (only cookies under 8 bytes are supported.)\n", len);
+			"lockd: bad cookie size %d (cookies over %d bytes are unsupported)\n", len, NLM_MAXCOOKIELEN);
 		return NULL;
 	}
 	return p;
@@ -86,7 +86,7 @@ nlm_decode_fh(u32 *p, struct nfs_fh *f)
 
 	if ((len = ntohl(*p++)) != NFS2_FHSIZE) {
 		printk(KERN_NOTICE
-			"lockd: bad fhandle size %x (should be %d)\n",
+			"lockd: bad fhandle size %d (should be %d)\n",
 			len, NFS2_FHSIZE);
 		return NULL;
 	}
@@ -534,7 +534,7 @@ nlmclt_decode_res(struct rpc_rqst *req, 
  * Buffer requirements for NLM
  */
 #define NLM_void_sz		0
-#define NLM_cookie_sz		3	/* 1 len , 2 data */
+#define NLM_cookie_sz		1+QUADLEN(NLM_MAXCOOKIELEN)
 #define NLM_caller_sz		1+QUADLEN(sizeof(system_utsname.nodename))
 #define NLM_netobj_sz		1+QUADLEN(XDR_MAX_NETOBJ)
 /* #define NLM_owner_sz		1+QUADLEN(NLM_MAXOWNER) */
@@ -643,3 +643,32 @@ nlm_procname(u32 proc)
 }
 #endif
 
+#ifdef RPC_DEBUG
+const char *nlmdbg_cookie2a(const struct nlm_cookie *cookie)
+{
+	/*
+	 * We can get away with a static buffer because we're only
+	 * called with BKL held.
+	 */
+	static char buf[2*NLM_MAXCOOKIELEN+1];
+	int i;
+	int len = sizeof(buf);
+	char *p = buf;
+
+	len--;	/* allow for trailing \0 */
+	if (len < 3)
+		return "???";
+	for (i = 0 ; i < cookie->len ; i++) {
+		if (len < 2) {
+			strcpy(p-3, "...");
+			break;
+		}
+		sprintf(p, "%02x", cookie->data[i]);
+		p += 2;
+		len -= 2;
+	}
+	*p = '\0';
+
+	return buf;
+}
+#endif
diff -urNp linux-5580/fs/lockd/xdr4.c linux-5590/fs/lockd/xdr4.c
--- linux-5580/fs/lockd/xdr4.c
+++ linux-5590/fs/lockd/xdr4.c
@@ -56,7 +56,7 @@ nlm4_decode_cookie(u32 *p, struct nlm_co
 		c->len=4;
 		memset(c->data, 0, 4);	/* hockeypux brain damage */
 	}
-	else if(len<=8)
+	else if(len<=NLM_MAXCOOKIELEN)
 	{
 		c->len=len;
 		memcpy(c->data, p, len);
@@ -65,7 +65,7 @@ nlm4_decode_cookie(u32 *p, struct nlm_co
 	else 
 	{
 		printk(KERN_NOTICE
-			"lockd: bad cookie size %d (only cookies under 8 bytes are supported.)\n", len);
+			"lockd: bad cookie size %d (cookies over %d bytes are unsupported)\n", len, NLM_MAXCOOKIELEN);
 		return NULL;
 	}
 	return p;
@@ -540,7 +540,7 @@ nlm4clt_decode_res(struct rpc_rqst *req,
  * Buffer requirements for NLM
  */
 #define NLM4_void_sz		0
-#define NLM4_cookie_sz		3	/* 1 len , 2 data */
+#define NLM4_cookie_sz		1+XDR_QUADLEN(NLM_MAXCOOKIELEN)
 #define NLM4_caller_sz		1+XDR_QUADLEN(NLM_MAXSTRLEN)
 #define NLM4_netobj_sz		1+XDR_QUADLEN(XDR_MAX_NETOBJ)
 /* #define NLM4_owner_sz		1+XDR_QUADLEN(NLM4_MAXOWNER) */
diff -urNp linux-5580/include/linux/lockd/debug.h linux-5590/include/linux/lockd/debug.h
--- linux-5580/include/linux/lockd/debug.h
+++ linux-5590/include/linux/lockd/debug.h
@@ -49,4 +49,13 @@ char *		  nlm_procname(u32);
 #define NLMDBG_ALL		0x7fff
 
 
+/*
+ * Support for printing NLM cookies in dprintk()
+ */
+#ifdef RPC_DEBUG
+struct nlm_cookie;
+/* Call this function with the BKL held (it uses a static buffer) */
+extern const char *nlmdbg_cookie2a(const struct nlm_cookie *);
+#endif
+
 #endif /* LINUX_LOCKD_DEBUG_H */
diff -urNp linux-5580/include/linux/lockd/lockd.h linux-5590/include/linux/lockd/lockd.h
--- linux-5580/include/linux/lockd/lockd.h
+++ linux-5590/include/linux/lockd/lockd.h
@@ -164,10 +164,10 @@ u32		  nlmsvc_unlock(struct nlm_file *, 
 u32		  nlmsvc_testlock(struct nlm_file *, struct nlm_lock *,
 					struct nlm_lock *);
 u32		  nlmsvc_cancel_blocked(struct nlm_file *, struct nlm_lock *);
-void		  nlmsvc_grant_reply(struct nlm_cookie *, u32);
 unsigned long	  nlmsvc_retry_blocked(void);
 int		  nlmsvc_traverse_blocks(struct nlm_host *, struct nlm_file *,
 					int action);
+void	  nlmsvc_grant_reply(struct nlm_cookie *cookie, u32 status);
 
 /*
  * File handling for the server personality
diff -urNp linux-5580/include/linux/lockd/xdr.h linux-5590/include/linux/lockd/xdr.h
--- linux-5580/include/linux/lockd/xdr.h
+++ linux-5590/include/linux/lockd/xdr.h
@@ -33,14 +33,15 @@ struct nlm_lock {
 };
 
 /*
- *	NLM cookies. Technically they can be 1K, Nobody uses over 8 bytes
- *	however.
+ *	NLM cookies. Technically they can be 1K, Few people use over 8 bytes,
+ *	FreeBSD uses 16, Apple Mac OS-X 10.3 uses 20.
  */
  
 struct nlm_cookie
 {
-	unsigned char data[8];
 	unsigned int len;
+#define NLM_MAXCOOKIELEN    	32
+	unsigned char data[NLM_MAXCOOKIELEN];
 };
 
 /*
