diff -urNp linux-8152/drivers/addon/lpfc/ChangeLog linux-8155/drivers/addon/lpfc/ChangeLog
--- linux-8152/drivers/addon/lpfc/ChangeLog
+++ linux-8155/drivers/addon/lpfc/ChangeLog
@@ -0,0 +1,958 @@
+Changes from 20060328 to 20060404:
+
+	* Changed version to 7.3.6
+	* Fixed FC protocol violation in handling process logout. 
+	  (CR 19803)
+	* Fixed PRLO processing to set npr timer while processing 
+	  unsolicited PRLO. (CR 19795)
+
+Changes from 20060111 to 20060328:
+
+	* Changed version to 7.3.5
+	* Modify lpfc_offline to empty the delay_list and return all ELS
+	  buffers on the free list only after all internal driver queues
+	  have been successfully flushed. (CR 19681)
+	* Introduce lpfc_reset_barrier() function for resets on dual
+	  Helios HBAs (CR 19630)
+
+Changes from 20051028 to 20060111:
+
+	* Changed version to 7.3.4
+	* Fixed a double insertion of mail box object to the SLI mailbox list.
+
+Changes from 20050711 to 20051028:
+
+	* Changed version to 7.3.3
+	* Fix names reported in the system log and in the proc files 
+	* Adding LP11000S and LPE11000S PCI IDs
+	
+Changes from 20050503 to 20050711:
+
+	* Changed version to 7.3.2.
+	* Fixed incorrect FAN handling.
+
+Changes from 20050401 to 20050503:
+
+	* Changed version to 7.3.1.
+	* Updated copyright messages.
+	* Added printk of copyright string at driver load.
+	* Removed PCI DMA sync calls to coherent/consistent PCI memory.
+
+Changes from 20050224 to 20050401
+
+	* Changed version to 7.3.0
+	* Fixed lpfc_stop_timer race condition.
+	* Added PCI devices ID definitions for Emulex HBAs.
+	* Fixed multiple simultaneous RSCNs from causing an outstanding
+	  PRLI from being prematurely aborted.
+	* Removed use of host memory for HGP on PowerPC platforms.
+	* Removed free_irq from the error path of HBA.
+
+Changes from 20050131 to 20050224
+
+	* Changed version to 7.2.4.
+	* Fixed copying of sense data back to midlayer when rsplen valid
+	  bit is cleared but rsplen contains a nonzero value.
+
+Changes from 20050127 to 20050131
+
+	* Changed version to 7.2.3.
+	* Fixed build warnings.
+
+Changes from 20050106 to 20050127
+
+	* Changed version to 7.2.2.
+	* Fixed VPD support.
+	* Changed use of DUMP mailbox command to support HBAs with 256
+	  bytes of SLIM.
+	* Changed max link speed value from 2 to 4.
+
+Changes from 20050105 to 20050106
+
+	* Changed version to 7.2.1.
+	* Fixed lpfc_config_port_prep for VPD info on big-endian
+	  architectures.
+
+Changes from 20041112 to 20050105
+
+	* Changed version to 7.2.0.
+	* Added support for four gigabit HBAs.
+	* Added VPD support.
+	* Removed unused Install.sh and Remove.sh scripts.
+	* Removed references to IPFC in Makefile.
+	* Removed references to KERNEL_VERSION(2,6,0) macro.
+	* Fixed build warnings on SLES 8.1.
+	* Added additional SLI layer logging.
+	* Fixed iotag initialization.
+	* Removed freeing of pmb structure if pmb->mbox_cmpl is set to
+	  lpfc_sli_wake_mbox_wait.
+
+Changes from 20041102 to 20041112
+
+	* Changed version to 7.1.14.
+	* Use data from pci_read_config_dword() to program config_port
+	  mailbox command instead of data from pci_resource_start() on
+	  systems with IOMMU.
+
+Changes from 20041026 to 20041102
+
+	* Changed version to 7.1.13.
+	* Removed RPI hash table and functions.
+	* Converted lpfc_findnode_rpi to an rpi->node lookup.
+	* Moved cleanup of txcmplq to lpfc_sli_brdreset after
+	  resetting board.
+	* Changed lpfc_cmpl_ct_cmd_gid_ft to not retry the nameserver
+	  command if the iocb is aborted by the driver.
+	* Moved clean up of ELS unsolicited event buffers to
+	  lpfc_sli_brdreset after reset of the board.
+	* If the NPortID of a previous device exists after FLOGI
+	  completion, removed the associated ndlp.
+	* Fixed discovery bug that occurs when the HBA NPortID changes
+	  during a link transition and ndlps are queued up for ADISC.
+	* No longer wait for interrupted I/Os to time out.
+	* Improved discovery transition for systems low on resources.
+	* Target reset now has sixty seconds to complete like the
+	  abort and reset handlers.
+	* Bus reset no longer fails if a target reset fails.
+	* Added write memory barrier before writing chip attention
+	  register and after writing to command iocb ring.
+	* Added read memory barrier in the ring event handler.
+
+Changes from 20041013 to 20041026
+
+	* Changed version to 7.1.12.
+	* Allow for ELS commands with IOERR_ABORT_REQUESTED to be
+          retried.
+	* Fixed CTPassthru to work for undiscovered nodes.
+	* No longer check for device existence before validating a
+          standard inquiry page response in the buffer.
+	* Fixed handling of error attention from firmware.
+	* Increase wait time in lpfc_config_port_prep() so it is
+          longer than the new FLOGI timeout period.
+	* Fixed rediscovery problem when PLOGI is received in NPort to
+          NPort point-to-point topology.
+	* Bug fixes in discovery state machine.
+	* Modified lpfc_sli_hba_down() to not free mbox->context1 if
+	  it does not poing to an mbuf structure.
+
+Changes from 20041007 to 20041013
+
+	* Changed version to 7.1.11.
+	* Added lpfc_dequenode() routine to deque ndlp even if did
+          equals zero.
+	* Fixed lpfc_linkdown() recursively calling itself.
+	* Errors from lpfc_sched_submit_command() are now propagated
+	  to the return value of lpfc_queuecommand().
+	* lpfc_queuecommand() now retries and returns DID_BUS_BUSY
+	  instead of returning 1.
+	* Fixed handling of in_retry in lpfc_queuecommand().
+	* Added list_del() discovery fixes.
+	* Fixed scheduler action when pcontext is zero and
+	  FC_NPR_ACTIVE is set.
+	* Fixed PCI IDs for Helios, JFly, Zephyr, and ZFly, and added
+	  the PCI ID for the LP111.
+	* Fixed system panics when MBX_READ_LA64 and MBX_READ_SPARM64
+	  mailbox commands timeout.
+
+Changes from 20041001 to 20041007
+
+	* Changed version to 7.1.10.
+	* Removed lpfc_nodev_timeout.
+	* Bug fixes in the discovery state machine.
+	* Fixed release of memory for a mailbox command before
+	  completion of the mailbox command.
+	* Scheduler host queue depth now reflects host->can_queue.
+	* Removed IRQ lock before calling lpfc_unmemmap().
+	* Converted spin_lock and spin_unlock to their irq
+	  equivalents.
+
+Changes from 20040928 to 20041001
+
+	* Changed version to 7.1.9.
+	* Fixed FLOGI completion handling when HBA is not in FLOGI
+          state.
+	* Fixed report LUN handling error paths.
+	* Fixed qcmdcnt to reflect qfull retries.
+	* Fixed scheduler bug in processing commandlist for a LUN
+        * Improved qfull handling logic.
+	* Fixed bug in pci_unmap_sg() by storing the seg_cnt returned
+          by pci_map_sg() and not calling lpfc_os_return_scsi_cmd() in
+          an error path when prep_io has not been called.
+	* Removed unused qfull-related code.
+	* Removed unused lpfc_qfull_retry() routine.
+	* Excessive qfull errors on a specific device are now passed
+          to the SCSI layer.
+	* Allow abort and close iocbs to not search txcmplq.
+
+Changes from 20040922 to 20040928
+
+	* Changed version to 7.1.8.
+	* Fixed equalities in comparison statements.
+	* Fixed premature FLOGI timeout.
+	* Fixed errors when calling lpfc_printf_log().
+
+Changes from 20040914 to 20040922
+
+	* Changed version to 7.1.7.
+	* Added lpfc_inq_pqb_filter parameter to lpfc.conf.
+	* All unsolicited ELS events in the tasklet queue are now
+	  flushed before the HBA is brought down.
+	* Retry logic in lpfc_cmpl_ct_cmd_gid_ft() is not executed if
+	  an iocb is aborted from lpfc_hba_down().
+	* lpfc_ns_rsp() no longer calls lpfc_disc_state_machine() if
+	  NLP_LOGO_ACC is set.
+	* Removed attempts to assign IOSTAT_DRIVER_REJECT to
+	  icmd->ulpStatus.
+	* Removed retries of any ELS commands that are rejected by
+	  lpfc_hba_down().
+	* Added call to lpfc_els_flush_rscn() before bringing down the
+	  HBA.
+	* lpfc_cmpl_els_plogi(), lpfc_cmpl_els_prli(),
+	  lpfc_cmpl_els_adisc(), and lpfc_cmpl_els_logo() routines
+	  call lpfc_disc_state_machine() only if IOSTAT_LOCAL_REJECT
+	  is not set and IOERR_SLI_ABORTED is set.
+	* Modfied lpfc_detect() to use the MODULE_DEVICE_TABLE as
+          opposed to a local array.
+	* Bug fixes in the discovery state machine.
+	* Fixed handling of FLOGI in point to point topology.
+	* Added support for Zephyr and ZFly HBAs.
+	* lpfc_rcv_logo_plogi_issue() cancels nlp_tmofunc before
+          calling elx_clk_set() to delay issuing a PLOGI.
+	* Fixed RJT Reason/Explanation codes in LPFC_FLOGI state.
+	* Added check to make sure request_buffer is allocated in
+          lpfc_os_return_scsi_cmd().
+	* Improved handling of reservation conflicts.
+	* Fix return path from lpfc_abort_handler() where the
+          io_request_lock is freed but the driver lock is not.
+
+Changes from 20040903 to 20040914
+
+	* Change version to 7.1.6.
+	* Fixed race condition in which a discovery event in
+	  lpfc_tasklet could access a freed node list pointer, iocb,
+	  or mb.
+	* Modified lpfc_sched_queue_command to queue to the tail of
+	  the commandList instead of the head.
+	* Removed pci_unmap_sg in the middle of sg_list in
+	  lpfc_os_prep_io.
+	* If lun is not present and target sets the peripheral
+	  quantifier bits, driver no longer returns DID_NOCONNECT.
+	* Removed driver unlocking/locking from lpfc_sli_hba_down.
+	* Increase timeout in lpfc_sli_issue_iocb_wait_high_priority
+          to allow sufficient time for iocbs to complete before
+          returning error.
+
+Changes from 20040824 to 20040903
+
+	* Change version to 7.1.5.
+	* Added a readl() call after each writel() call.
+
+Changes from 20040804 to 20040824
+
+	* Change version to 7.1.4.
+	* Fixed timer issues during detach.
+	* Removed flushing of QUE_RING_BUF commands from
+          lpfc_els_flush_cmd().
+	* Free buffers associated with a mailbox command that cannot
+          be sent to an adapter.
+	* Fixed memory leak in lpfc_els_unsol_event().
+	* Added changes to log message indicating the bus, device, or
+          IRQ of an adapter when attach fails.
+	* Modified lpfc_parse_binding_entry() to check if a persistent
+          binding entry matches the lpfc number being initialized.
+	* Restored the round-robin scheduling across LUNs in
+          lpfc_sched.c.
+	* Added rescheduling of any command that fails due to
+          SCSI_Q_FULL if it is the only outstanding command on the
+          LUN.
+	* Removed checking of zero value for ndlp in
+          elx_scsi_cmd_start().
+	* Added immediate return of a command if a fatal error occurs
+          and nodev_holdio is zero.
+	* Inquiry to a LUN now fails with host error status
+          DID_NOT_CONNECT if the LUN is not present or is offline.
+	* Delay on iodone when a check condition error with asc/ascq
+          indicates the LUN is becoming ready.
+
+Changes from 20040723 to 20040804
+
+	* Change version to 7.1.3.
+	* Added support for LP11000 and LP1150 HBAs.
+	* Added tracking for IOs whose completion is delayed with the
+          delay_iodone_timer so they can be cleaned up during an
+          offline transition.
+	* Added changes to handle kmalloc failure in
+          lpfc_start_timer() function.
+	* Added unregister from SCSI midlayer on HBA init failure.
+	* Added setting of HBA queue depth based on max_xri returned
+          by the firmware, as opposed to the PCI ID.
+	* Added removal of timerList cleanup after HBA shutdown.
+	* Added handling of outstanding IO completions during rmmod.
+	* Added setting max_lun to 0 and removed simulation of
+          processor device when report lun with zero lun is received.
+	* PRLO state machine now tries to relogin to FCP device.
+	* Fixed potential memory leaks.
+	* Modified device_reset_handle function to issue LUN reset.
+	* Moved initialization and cleanup of scsi_tmofunc in
+          lpfc_linux_attach(), lpfc_online(), and lpfc_offline()
+          functions to avoid double insertion of timer when
+          lpfc_handler_eratt() is processed.
+	* Added logic to lpfc_scsi_timeout_handler() to not requeue
+          itself after it is canceled in lpfc_offline().
+
+Changes from 20040707 to 20040723
+
+	* Change version to 7.1.2.
+	* Removed IPFC data structures.
+	* Reduced lpfc_no_device_delay from ten seconds back to one
+	  second.
+	* Added logging messages for nodev timer events.
+	* Added support for commands retried by the midlayer while the
+	  device is in the recovery state.
+
+Changes from 20040702 to 20040707
+
+	* Change version to 7.1.1.
+	* Properly clean up the head list_head entry that is added to
+          the beginning of the piocbq list in lpfc_ct_unsol_event().
+	* Fixed potential dereference of null p_mbuf.
+	* Fixed use of list macros on DMABUF_t list without the list
+          having a valid head.
+
+Changes from 20040621 to 20040702
+
+	* Change version to 7.1.0.
+	* Fixed Makefile to rebuild driver when lpfc.conf is modified.
+	* Removed references to lpfc_num_iocbs and lpfc_num_bufs.
+	* Increased lpfc_no_device_delay from one to ten seconds.
+	* Node port recovery timer is started if lpfc_nodev_holdio is
+          zero when a target is forced into NPR_ACTIVE state.
+	* Fixed lpfc_reset_bus_handler() return value.
+	* Fixed NULL pointer dereference in lpfc_tasklet() in lpfc_fcp.c.
+	* Remove check for max_lun when lun_skip is not specified.
+	* Use cmnd->request_bufferlen field to set fcp_cmnd->fcpDI.
+	* Fix failure in lun_reset/bus_reset path.
+	* Properly clean up after allocation of a linked BDE fails in
+          the SCSI queuecommand path.
+
+Changes from 20040610 to 20040621
+
+	* Change version to 7.0.4.
+	* Fixed make install target and MODLIB definition.
+	* Fixed counter decrement typo in lpfc_els.c
+	* Hardened the driver against bad HBAs.
+	* Fixed I/O errors generated by LIPs under heavy traffic.
+	* Protected target and lun scheduler list entries from double
+	  removal.
+	* Fix panic in LUN reset path.
+	* Fix firmware download problem.
+
+Changes from 20040526 to 20040610
+
+	* Change version to 7.0.3.
+	* Fix for high targt count handling.  Fix corrected storage
+          for target pointers to number of targets supported and loop
+          clauses to strict inequalities.
+	* Fixed discovery state machine to handle lip events with
+          heavy traffic loads to 256 luns.
+	* Decreased FLOGI discovery timeout to 20 seconds to eliminate
+          race condition between initial discovery time allotment and
+          FLOGI timeout occuring on GX-type switch ports.
+
+
+Changes from 20040515 to 20040526
+
+	* Change version to 7.0.2.
+	* Change del_timer_sync() to del_timer() in lpfc_stop_timer() as
+	  it is called from interrupt context.
+	* Add readls after writels to PCI space to flush the writes.
+	* Fix for read/write after free memory corruption when there is a
+	  link event.  Fix is to flush all els iocbs in the tasklet queue
+	  when there is a link down event.
+	* Fixed tasklet queue corruption.
+	* Fix compiler warnings for unused variables
+	* Change lpfc_proc_info handler to get the Nodename from
+	  fc_nodename instead of fc_portname.
+	* LP9802 qdepth is twice the LP9802DC qdepth.  Delay
+	  elx_sched_init after READ_CONFIG to get max_xri from the
+	  firmware.  Reset ELX_CFG_DFT_HBA_Q_DEPTH to max_xri after
+	  READ_CONFIG
+	* Fix bug in the safety pool implementation which can return a
+	  bogus address when allocating objects. The list_entry macro used
+	  in the alloc routine will return an invalid memory address.
+	* Moving ndlp node from unmap list to map list if ADISC completed
+	  successfully.  lpfc_assign_scsid(), lpfc_cmpl_prli_prli_issue(),
+	  lpfc_cmpl_adisc_prli_issue(), lpfc_cmpl_adisc_prli_compl(),
+	  lpfc_cmpl_adisc_mapped_node() and lpfc_add_bind() had been
+	  changed.
+	* Fix for IBM PPC64 cross compile issue - doubly prefixing
+	  CROSS_COMPILE prefix. This fix just always reduces the number of
+	  prefixes to one.
+
+
+Changes from 20040507 to 20040515
+
+	* Changing version to 7.0.1.
+	* Fixed bug in lpfc_tasklet.  lpfc_tasklet was recursively called
+	  when the tasklet has a linkdown event from lpfc_mbx_cmpl_read_la
+	  in linkdown.
+	* Fixed crash on driver unload when link event or target errors
+	  were present during traffic.
+	* Move some #defines from lpfc_diag.h to lpfc_dfc.h
+
+Changes from 20040429 to 20040507
+
+	* Change version to 7.0.0
+	* Fix the number of cmd / rsp ring entries in lpfc_fcp.c to match
+	  the divisions setup in lpfc_hw.h.
+	* Make lpfc_info() use lpfc_get_hba_model_desc() instead of
+	  rewriting almost identical code.
+	* Fix 1 overly long line in each of lpfc_cfgparm.h, lpfc_ftp.c and
+	  lpfc_sli.c.
+	* Change elx_sli_issue_mbox_wait to return correct error code to
+	  the caller.
+	* In some of the els completion routines, after calling
+	  lpfc_elx_chk_latt, driver ignores the return code of the
+	  lpfc_elx_chk_latt. This will prevent the discovery state machine
+	  restarting correctly when there are link events in the middle of
+	  discovery state machine running. Fix this by exiting discovery
+	  state machine if lpfc_els_chk_latt returns a non zero value.
+	* Removed MAX_LPFC_BRDS from lpfc_diag.h
+	* Removed unused first_check.
+	* Remove some unused fields and defines.
+	* Change lpfc-param names to lpfc_param.
+	* Shorten length of some of the comment lines to make them more
+	  readable.
+	* Move FCP_* definitions to their own header file, lpfc_fcp.h.
+	* Remove unused prototypes from lpfc_crtn.h: fcptst, iptst,
+	  lpfc_DELAYMS.
+	* Remove duplicated prototypes from lpfc_crtn.h:
+	  lpfc_config_port_prep, lpfc_config_port_post,
+	  lpfc_hba_down_prep.
+	* Removed some unused export_symbols.
+	* Install driver files into */drivers/scsi/lpfc instead of
+	  */drivers/scsi.
+
+Changes from 20040426 to 20040429
+
+	* Declared export symbol lpfc_page_alloc and lpfc_page_free
+	* Changed lpfc version number to 6.98.3
+	* Move the definition of MAX_LPFC_BRDS to the only header file
+	  that uses it (lpfc_diag.h).
+	* Change lpfc_sli_wake_iocb_wait to do a regular wake_up since
+	  lpfc_sli_issue_iocb_wait now sleeps uninterruptible.
+	* Replace list_for_each() with list_for_each_safe() when a list
+	  element could be deleted.
+	* Fix IOCB memory leak
+
+Changes from 20040416 to 20040426
+
+	* Change lpfc_config_port_prep() to interpret word 4 of the DUMP
+	  mbox response as a byte-count
+	* Add info attribute to sysfs
+	* Minor formatting (spaces to tabs) cleanup in lpfc_sched.h
+	* Remove unused log message number 732
+	* Completing MODULE_PARM -> module_param changes
+	* Removed unused targetenable module parameter
+	* Removed locks from lpfc_sli_issue_mbox_wait routine
+	* Removed code that retry 29,00 check condition
+	* Removed code that manipulates rspSnsLen.
+	* Fix use of lun-q-depth config param
+	* Fix severity inconsistency with log message 249
+	* Removed lpfc_max_target from lpfc_linux_attach
+	* Replace references to lpfcDRVR.pHba[] with lpfc_get_phba_by_inst()
+	* Change lpfc_param to lpfc-param
+	* Partially removed 32 HBA restriction within driver.  Incorported
+	  lpfc_instcnt, lpfc_instance[], and pHba[] into lpfcDRVR
+	  structure Added routines lpfc_get_phba_by_inst()
+	  lpfc_get_inst_by_phba() lpfc_check_valid_phba()
+	* Turn on attributes "set" & "params" by default.
+	* Further formatting/whitespace/line length cleanup on: lpfc_ct.c
+	  lpfc_els.c lpfc_fcp.c lpfc_hbadisc.c lpfc_init.c lpfc_ipport.c
+	  lpfc_mbox.c lpfc_nportdisc.c lpfc_sched.c lpfc_sched.h
+	  lpfc_scsi.h lpfc_scsiport.c lpfc_sli.c and lpfc_sli.h
+	* Add log message 249 to log any unsupported device addressing
+	  modes encountered.
+	* Add support for 256 targets and 256 LUNs
+	* Fixed panic in lpfc_linkdown.
+	* Removed (struct list_head*) casting in several calls to list_del
+	* Free irq reservation and kill running timers when insmod or
+	  modprobe are killed via ctrl-c
+	* Remove drivers/scsi from include path
+	* Wrap use of log message 311 in macro
+	* Detect failure return from pci_map_sg call in lpfc_os_prep_io
+	* Fix use-after-free of IOCB in lpfc_sli_process_sol_iocb which
+	  was causing an Oops on 2.6.5 kernel.
+	* Cleanup use of several gotos not used for error exit.
+	* Replace memcpy_toio() and memcpy_toio() with endian-dependent
+	  lpfc_memcpy_to_slim() and lpfc_memcpy_from_slim() so that for
+	  big endian hosts like PPC64, the SLIM is accessed 4 bytes at a
+	  time instead of as a byte-stream.
+
+Changes from 20040409 to 20040416
+
+	* The scsi_register and scsi_alloc_host OS calls can fail and
+	  return a zero-valued host pointer.  A ctrl-C on 2.6 kernels
+	  during driver load will cause this and the driver to panic.
+	  Fixed this bug.  Also found a bug in the error_x handling with
+	  lpfc_sli_hba_down - it was in the wrong place and the driver
+	  lock was not held, but needed to be (in lpfc_linux_attach) Fixed
+	  both.  Did some minor comment clean up.
+	* Removed unwanted (void *) castings.
+	* Replace define of INVALID_PHYS, with kernel 2.6.5's
+	  dma_mapping_error() and add a inline function for earlier
+	  kernels.  Remove lpfc_bad_scatterlist().
+	* Clean up formatting in hbaapi.h, lpfc.h, lpfc_cfgparm.h,
+	  lpfc_crtn.h, lpfc_ct.c, lpfc_diag.h, lpfc_disc.h, lpfc_els.c,
+	  lpfc_fcp.c, lpfc_hbadisc.c, lpfc_hw.h, lpfc_init.c,
+	  lpfc_ipport.c, lpfc_logmsg.c, lpfc_logmsg.h and lpfc_scsiport.c
+	  - mostly replacing groups of 8 spaces with hard tabs and keeping
+	  lines to 80 column max..
+	* Removed LPFC_DRVR_LOCK call from lpfc_unblock_requests for 2.4
+	  kernels.  The lpfc_scsi_done routine already unlocks the driver
+	  lock since it expects this lock to be held.
+	* Removed global lock capabilities from driver lock routines
+	* Remove SA_INTERRUPT flag from request_irq
+	* Move dma_addr_t cast inside of getPaddr macro as everywhere
+	  getPaddr is used, the return is cast to dma_addr_t.
+	* Clean up formatting in lpfc_sli.c and lpfc_sysfs.c - mostly
+	   replacing groups of 8 spaces with hard tabs and keeping lines
+	   to 80 column max.
+	* Fix build for RHEL 2.1 BOOT kernels by always #including
+	  interrupt.h in lpfc.h.
+	* Fix RHEL 3 build by #defining EXPORT_SYMTAB.
+	* Replace sprintf with snprintf in lpfc_proc_info.
+	* Fix build warnings on 2.6 kernels - remove no longer used calls
+	  to  character device initialization.
+	* Initial support code for discovery in tasklet conversion.
+	* Removing char interface and ioctl code.
+	* Change all elx prefixes to lpfc
+	* Replace lpfc_write_slim() & lpfc_read_slim() with memcpy_toio(),
+	  memcpy_fromio(), writel() & readl().
+
+Changes from 20040402 to 20040409
+
+	* Replaced lpfc_read_hbaregs_plus_offset and
+	  lpfc_write_hbaregs_plus_offset functions with readl and writel.
+	* Get rid of long mdelay's in insmod path
+	* Changed the way our pci_device_id structures are initialized
+	* Replace lpfc_read/write_CA/HA/HC/HS with calls to readl() &
+	  writel() directly.
+	* Increase SLI2_SLIM to 16K Increase cmd / rsp IOCBs accordingly
+	* Removed lpfc_els_chk_latt from the lpfc_config_post function.
+	  lpfc_els_chk_latt will enable the link event interrupts when
+	  flogi is pending which causes two discovery state machines
+	  running parallely.
+	* Add pci_disable_device to unload path.
+	* Move lpfc_sleep_event from lpfc_fcp.c to lpfc_util_ioctl.c
+	* Call dma_map_single() & pci_map_single() directly instead of via
+	  macro lpfc_pci_map().  Allow address 0 for PPC64.
+	* Change sleep to uninterruptible in lpfc_sli_issue_icob_wait
+	  because this function doesn't handle signals.
+	* Move lpfc_wakeup_event from lpfc_fcp.c to lpfc_ioctl.c
+	* Remove unneeded #include <linux/netdevice.h>
+	* Remove unused clock variables lpfc_clkCnt and lpfc_sec_clk.
+	* Get rid of capitalization of function names.
+	* Removed lpfc_addr_sprintf.
+	* Implemented gotos in lpfc_linux_attach for error cases.
+	* Replace mlist->dma.list = dmp->dma.list; to mlist = dmp.
+	* Remove functions lpfc_get_OsNameVersion and elx_wakeup. Change
+	  elx_wakeup to wake_up_interruptible
+	* Add function lpfc_get_os_nameversion and change
+	  lpfc_get_OsNameVersion to lpfc_get_os_nameversion.
+	* Remove lpfc_get_OsNameVersion
+	* Change driver name to a consistent lpfc in every visible place.
+	* Fix build warning: removed unused variable ret in lpfc_fdmi_tmo.
+	* Remove lpfc_utsname_nodename_check function
+	* Remove functions lpfc_register_intr and lpfc_unregister_intr
+	* Fill in owner field in lpfc_ops file_operations struct and
+	  remove now unnecessary open and close entry points.
+	* Change function name prefixes from elx_ to lpfc_
+	* Remove special case check for TUR in elx_os_prep_io()
+	* Renamed elx_scsi.h to lpfc_scsi.h
+	* Renamed elx_sched.h to lpfc_sched.h
+	* Renamed elx_mem.h to lpfc_mem.h
+	* Renamed elx_sli.h to lpfc_sli.h
+	* Renamed elx_logmsg.h to lpfc_logmsg.h
+	* Renamed elx.h to lpfc.h
+	* Renamed elx_sli.c to lpfc_sli.c
+	* Renamed elx_sched.c to lpfc_sched.c
+	* Renamed elx_mem.c to lpfc_mem.c
+	* Renamed elx_logmsg.c to lpfc_logmsg.c
+	* Renamed lpfcLINUXfcp.c lpfc_fcp.c
+	* Renamed elx_clock.c to lpfc_clock.c
+	* Reduce stack usage in lpfc_info().
+	* Move lpip_stats structure from lpfc_hba.h to lpfc_ip.h.
+	* Move lpfc_stats and HBAEVT_t structures from lpfc_hba.h to
+	  lpfc.h
+	* Remove lpfc_hba.h
+	* Remove duplicate rc definitions from 
+	* Removed code which used next pointer to store mbox structure.
+	* Cleaned up list iterations.
+	* Removed non list manipulation of the next pointers.
+	* Change list_del()/INIT_LIST_HEAD sequences to list_del_init()
+	* In ELX_IOCBQ_t: Moved hipri_trigger field to iocb_flag. Combined
+	  hipri_wait_queue and rsp_iocb in union
+	* Replaced casting from list_head with list_entry macro.
+	* Added ct_ndlp_context field to the ELX_IOCBQ_t.
+	* Do not use DMABUf_t list to store ndlp context
+	* Return 0 from lpfc_process_iotcl_util() when ELX_INITBRDS
+	  succeeds.
+	* remove elx_os_scsiport.h
+	* Do not use DMABUf_t list to hold rpi context
+	* Replace elx_cfg_* names with lpfc_cfg-*
+	* Moved FCP activity to ring 0.  Moved ELS/CT activity to ring 2.
+	* Clean up formatting of elx_sli.h (tabs for indents, 80 column
+	  lines).
+	* Remove unused elxclock declaration in elx_sli.h.
+	* Since everywhere IOCB_ENTRY is used, the return value is cast,
+	  move the cast into the macro.
+	* Split ioctls out into seperate files
+
+Changes from 20040326 to 20040402
+
+	* Updated ChangeLog for 20040402 SourceForge drop.
+	* Use safe list iterator for ndlp list
+	* Added code to return NLP_STE_FREED_NODE from the discovery
+	  state machine functions if the node is freed from the
+	  function.
+	* Fixes to DMABUF_t handling
+	* Fix for load error in discovery
+	* Remove loop_cnt variable from lpfc_rcv_plogi_unused_node.
+	* Remove nle. reference.
+        * Remove support for building 2.4 drivers
+	* Remove elx_util.h and replace elx_disc.h with lpfc_disc.h
+	* Implemented the Linux list macros in the discovery code.
+	  Also moved elx_disc.h contents into lpfc_disc.h
+	* Unused variable cleanup
+	* Use Linux list macros for DMABUF_t
+	* Break up ioctls into 3 sections, dfc, util, hbaapi
+	  rearranged code so this could be easily seperated into a
+	  differnet module later All 3 are currently turned on by
+	  defines in lpfc_ioctl.c LPFC_DFC_IOCTL, LPFC_UTIL_IOCTL,
+	  LPFC_HBAAPI_IOCTL
+	* Misc cleanup: some goto's; add comments; clarify function
+	  args
+	* Added code to use list macro for ELXSCSITARGET_t.
+	* New list implementation for ELX_MBOXQ_t
+	* Cleaned up some list_head casting.
+	* Put IPFC ifdef around two members of struct lpfc_nodelist.
+	* Cleaned up iocb list using list macros and list_head data
+	  structure.
+	* lpfc_online() was missing some timer routines that were
+	  started by lpfc_linux_attach().  These routines are now also
+	  started by lpfc_online().  lpfc_offline() only stopped
+	  els_timeout routine.  It now stops all timeout routines
+	  associated with that hba.
+	* Replace seperate next and prev pointers in struct
+	  lpfc_bindlist with list_head type.  In elxHBA_t, replace
+	  fc_nlpbind_start and _end with fc_nlpbind_list and use
+	  list_head macros to access it.
+	* Fix ulpStatus for aborting I/Os overlaps with newer firmware
+	  ulpStatus values
+	* Rework params_show/store to be consistent as the other
+	  routines.  Remove generic'ness and rely on set attribute.
+	* Remove unused log message.
+	* Collapse elx_crtn.h and prod_crtn.h into lpfc_crtn.h
+	* Ifdef Scheduler specific routines
+	* Removed following ununsed ioclt's: ELX_READ_IOCB
+	  ELX_READ_MEMSEG ELX_READ_BINFO ELX_READ_EINVAL ELX_READ_LHBA
+	  ELX_READ_LXHBA ELX_SET ELX_DBG LPFC_TRACE 
+	* Removed variable fc_dbg_flg
+	* Fixed a bug where HBA_Q_DEPTH was set incorrectly for
+	  3-digit HBAs.  Also changed can_queue so midlayer will only
+	  send (HBA_Q_DEPTH - 10) cmds.
+	* Clean up code in the error path, check condition.  Remove
+	  ununsed sense-related fields in lun structure.
+	* Added code for safety pools for following objects: mbuf/bpl,
+	  mbox, iocb, ndlp, bind
+	* Wrapped '#include <elx_sched.h>' in '#ifdef USE_SCHEDULER'.
+	* Fixed 'make clean' target.
+        * Build now ignores elx_sched.o, and includes lpfc_sysfs.o.
+	* Wrapped lpfndd.o target in BUILD_IPFC ifdef.
+	* Removed elx_os.h inclusion in implementation files.
+	* Removed ELX_OS_IO_t data structure and put data direction
+	  and non scatter/gather physical address into the scsi buffer
+	  structure directly.  Moved DRVR_LOCK, putPaddr, getPaddr
+	  macros and some defines into elx.h since they are required
+	  by the whole driver.
+	* Migrated following ioctls (debug) ELX_DISPLAY_PCI_ALL
+	  ELX_DEVP ELX_READ_BPLIST ELX_RESET_QDEPTH ELX_STAT.
+	* Step 1 of attempt to move all Debug ioctls to sysfs.
+	  Implemented the following IOCTLs in sysfs: ELX_WRITE_HC
+	  ELX_WRITE_HS ELX_WRITE_HA ELX_WRITE_CA ELX_READ_HC
+	  ELX_READ_HS ELX_READ_HA ELX_READ_CA ELX_READ_MB ELX_RESET
+	  ELX_READ_HBA ELX_INSTANCE ELX_LIP.  Also introduced
+	  attribute "set" to be used in conjuction with the above
+	  attributes.
+	* Removed DLINK, enque and deque declarations now that clock
+	  doesn't use them anymore
+	* Separated install rule so that BUILD_IPFC has to be set when
+	  make is called in order for the install rule to attempt to
+	  copy the lpfndd.o driver.  This change fixes a bug that
+	  occurs because the install rule by default attempted to
+	  install lpfndd.o, whereas the default make rule did not by
+	  default build lpfndd.o.
+	* Keep track if hbaapi index numbers need to be refreshed.
+	* Removed prod_os.h from include list.
+	* Removed LPFC_LOCK and LPFC_UNLOCK macros.  Added OS calls
+	  into elx_os_scsiport.c.  This file is now empty.
+	* Added spin_lock_irqsave and spin_unlock_irqrestore calls
+	  into code directly and removed LPFC_LOCK_ and _UNLOCK_
+	  macros
+	* Remove references to "elx_clock.h"
+	* Added utsname.h to include list.  The previous checkin to
+	  elx_os.h removed its inclusion of utsname.h since there is
+	  precious little in the file.  However, lpfcLINUXfcp.c needs
+	  it and now has it.
+	* Removed some commented-out code
+	* Removed elx_lck_t data structure, stray elxDRVR_t type, and
+	  include from file.  No longer used.
+	* Removed two PCI Sync defines.  Removed includes - not
+	  needed.  Cleaned up macro lines.
+	* Added two functions from elxLINUXfcp.c.  These functions
+	  were IPFC specific.
+	* Removed hipri lock abstractions and added OS call into code.
+	  Removed elx_lck_t and added spinlock_t directly. Moved two
+	  IPFC functions into lpfc_ipport.c
+	* Moved IP specific structures to lpfc_ip.h file.
+	* lpfc_ipfarp_timeout() uses system timer.  Remove all usages
+	  of old internal clock support.
+	* Made changes to compile without IPFC support for the default
+	  build.  Added ifdef IPFC for all lpfc_ip.h includes.
+	* Patched elx_free_scsi_buf
+  	* Removed elx_sched.o from 2.6 dependencies
+	* Reworked lpfc_pcimap.
+	* Use Linux swap macros to replace ELX swapping macros
+	  (SWAP_SHORT, SWAP_LONG, SWAP_DATA, SWAP_DATA16,
+	  PCIMEM_SHORT, PCIMEM_LONG, PCIMEM_DATA).
+	* move in_interrupt() check inside of elx_sleep_ms()
+	* Moved location of pci.h include.
+	* Restored elx_lck_t types in elxHBA_t.
+	* Removed elx_pci_dma_sync call.  Also removed some PCI
+	  defines from elx_hw.h and removed the spinlock_t locks that
+	  are no longer used in elx.h
+	* elx_iodone() now uses system timer.
+  	* elx_qfull_retry() now uses system timer.
+	* lpfc_put_buf(), lpfc_ip_xri_timeout() and
+	  lpfc_ip_timeout_handler() now use system timer.
+	* lpfc_fdmi_tmo() and lpfc_qthrottle_up() now use system
+          timer.
+	* Removed num_bufs and num_iocbs configuration parameters.
+	* Fixed a memory corruption bug. This was caused by a memory
+	  write to ndlp structure from lpfc_cmpl_els_acc function.
+	  This ndlp structure was freed from lpfc_els_unsol_event.
+	* lpfc_disc_timeout() and lpfc_establish_link_tmo() now use
+	  system timer.  Also update lpfc_els_retry_delay() to do a
+	  single lock release at the end.
+	* Remove use of PAN (pseudo adapter number).
+	* Reintroduced usage of the cross compiler for building on
+	  ppc64 to remove build errors that were cropping up when
+	  using the standard gcc compiler.
+	* Fix no-unlock-before return in lpfc_els_retry_delay which was
+	  causing  a deadlock on insmod in some environments.
+	* Minor format changes fix up comments
+	* Create utility clock function elx_start_timer() and
+	  elx_stop_timer().  All timeout routines now use these common
+	  routines.
+	* Minor formating changes fix up comments
+	* Minor formatting changes get rid of failover defines for
+	  syntax checking
+	* Minor formatting changes remove ISCSI defines.
+	* Fix typo in install target for 2.4 kernels.
+	* Removed unused elx_scsi_add_timer extern function
+	  declaration.
+	* Cleanup casting around DMA masks.
+	* Comment out lpfndd.o modules_install section as lpfndd.o is
+	  not generated if CONFIG_NET_LPFC is not set. Also refer to
+	  BASEINCLUDE only in out of kernel source module builds as it
+	  will not exist otherwise.
+	* Removed unused malloc counters from lpfcLINUXfcp.c.
+	* Remove some unnecessary #includes in lpfcLINUXfcp.c
+	* Remove unncessary #includes in elxLINUXfcp.c
+	* Minor formatting cleanups in Makefile to avoid some
+          linewrapping.
+	* Removed unused elx_mem_pool data structure.
+	* Remove several unnecessary #includes.
+	* Moving fix for memory leak in ioctl lip area to sysfs's lip.
+	* Removed unused elx_dma_handle_t elx_acc_handle_t
+	  FC_MAX_SEGSZ and FC_MAX_POOL.
+	* Rewrite of Makefile. Fixes breakages with make -j4 during
+	  kernel compile. Does not recompile all files on every
+	  build. Uses the kernel build's definitions of CFLAGS,
+	  MODFLAGS etc. Removed "make rpm" option.
+	* Removed unused #defines CLOSED, DEAD, OPENED, NORMAL_OPEN
+	  and unneeded #include of elx_sched.h in elx.h.
+	* Several log message updates
+	* Add PCI_DEVICE_ID_FIREFLY for LP6000
+	* Fixed known issues in 20040326: driver crashes on rmmod in
+	  both 2.4 and 2.6 kernels
+	
+
+Changes from 20040319 to 20040326
+
+	* Updated ChangeLog for 20040326 SourceForge drop.
+	* remove lpfc_isr / lpfc_tmr logic fixed up 8 spaces from
+	  previous checkins with tabs
+	* replace elx_in_intr() with in_interrupt()
+	* Remove unused messages 1602 and 1603.
+	* Fix the following issues with log messages: Remove unused
+	  messages 406, 407, 409, 927, 928, 1201, 1202, 1204, 1205, 1206
+	  and 1207.  Create a new message 738 to fix duplicate instances
+	  of 736.
+	* Removed remaining pci interface abstractions from elxLINUXfcp.c.
+	  Implemented OS calls directly in all remaining files and cleaned
+	  up modules.  Removed prototypes as well.
+	* Removed following functions/structures elx_mem_dmapool
+	  elx_idx_dmapool elx_size_dmapool elx_kmem_lock dfc_data_alloc
+	  dfc_data_free dfc_mem struct mbuf_info elx_acc_handle_t
+	  data_handle elx_dma_handle_t dma_handle struct elx_memseg
+	  MEMSEG_t
+	* lpfc_els_timeout_handler() now uses system timer.
+	* Further cleanup of #ifdef powerpc
+	* lpfc_scsi_timeout_handler() now uses system timer.
+	* Replace common driver's own defines for endianess w/ Linux's
+	  __BIG_ENDIAN etc.
+	* Added #ifdef IPFC for all IPFC specific code.
+	* lpfc_disc_retry_rptlun() now uses system timer.
+	* lpfc_npr_timeout() now uses system timer.
+	* Modified detect code, on insmod, to only wait a max of 2 secs if
+	  link comes up and there are no devices.
+	* Move remaining message logging functions into
+	  elx_logmsg.c/elx_logmsg.h.
+	* Added code to clear link attention bit when there is a pending
+	  link event and the memory allocation for read_la mail box
+	  command fails.
+	* Removed function calls for mapping bar registers and allocating
+	  kernel virtual memory mappings to the mapped bars Removed
+	  prototypes, lpfc_driver_cache_line, and pci_bar1_map rename to
+	  pci_bar2_map.
+	* Allocate mbox only if the hba_state is in ready state.
+	* Complete lip support via sysfs. To lip, echo brdnum >
+	  /sys/bus/pci/drivers/lpfc/lip.
+	* moving sysfs show/store implementations to lpfc_sysfs.c. Also add
+	  support for lip.
+	* Add files: lpfc_sysfs.c, lpfc_sysfs.h
+	* move LPFC_DRIVER_NAME and LPFC_MODULE_DESC out of lpfcLINUXfcp.c
+	  to lpfc_version.h, since it is now needed in lpfc_sysfs.c
+	* elx_mbox_timeout now uses system timer
+	* Changed lpfc_nodev_timeout, lpfc_els_retry_delay and
+	  lpfc_linkdown_timeout to use the system timer instead of
+	  internal clock support.
+	* Move remaining message logging functions in elx_util.c to
+	  elx_logmsg.c.
+	* Remove some unnecessary typecasting.
+	* Remove log message that is no longer used (was used by
+	  elx_str_atox).
+	* Replaced DLINK_t and SLINK_t by standard Linux list_head
+	* Removed deque macro
+	* Replaced ELX_DLINK_t ans ELX_SLINK_t by Linux struct list_head
+	  (except for clock)
+	* Removed following functions from code: linux_kmalloc linux_kfree
+	  elx_alloc_bigbuf elx_free_bigbuf
+	* Removed following abstract functions from the code.  elx_malloc
+	  elx_free elx_ip_get_rcv_buf elx_ip_free_rcv_buf
+	  elx_mem_alloc_dmabuf elx_mem_alloc_dmabufext elx_mem_alloc_dma
+	  elx_mem_alloc_buf lpfc_bufmap
+	* Removed custom PCI configuration #defines and replaced with
+	  OS-provided #defines. Also added linux/pci.h to *.c files.
+	* Remove elx_str_ctox.	Replace elx_str_atox with sscanf.
+	* Many indentation/whitespace fixes.
+	* Replace elx_str_ctox with isxdigit where it was only used to
+	  check the value of a character.
+	* Removed following functions from the code.  elx_kmem_free
+	  elx_kmem_alloc elx_kmem_zalloc
+	* Change use of 2.4 SCSI typedef Scsi_Host_Template to	struct
+	  scsi_host_template for 2.6 kernels.
+	* Change use of 2.4 SCSI typedefs (Scsi_Device, Scsi_Cmnd,
+	  Scsi_Request) the their real struct names.
+	* Move 2.6 compatibility irqreturn definitions to lpfc_compat.h.
+	  Protect these definitions from conflicting with similar ones in
+	  later 2.4 kernels.
+	* Remove unused definitions: LINUX_TGT_t, LINUX_LUN_t,
+	  LINUX_BUF_t, elx_lun_t, SET_ADAPTER_STATUS.
+	* Convert pci_ calls to linux 2.6 dma_ equivalents.
+	* Removed unused types: struct buf, struct sc_buf, T_SCSIBUF
+	  typedef.
+	* Fix Makefile so that 2.4 drivers don't always rebuild all files.
+	* Remove unused _static_ and fc_lun_t definitions.
+	* Cleaned up some memory pool implementation code.
+	* Fix panic with char dev changes. Turns out that 2.6.4 code does
+	  the same in kernel space with the 2.4 interface style
+	  definitions. So remove the new char dev code altogether.
+	* Remove typecasting from fc_get_cfg_param and consolidate
+	  multiple instances of the parameter switch into a single
+	  instance.
+	* Use lpfc_is_LC_HBA() macro that tests pcidev->device directly
+	  instead of saving a private copy that undergoes varied shifting
+	  & casting.
+	* Removed usage of all memory pools.
+
+Changes from 20040312 to 20040319
+	
+	* Use dev_warn instead of printk for 2.6 kernels
+	* Correct Iocbq completion routine for 2.6 kernel case
+	* Change void *pOSCmd to Scsi_Smnd *pCmd
+	* Change void *pOScmd to struct sk_buff *pCmd
+	* Remove data directon code.
+	* Removed memory pool for buf/bpl buffers and use kmalloc/kfree
+	  pci_pool_alloc/free directly.
+	* Move PPC check for DMA address 0 in scatter-gather list, into
+	  lpfc_compat.h
+	* Always use pci_unmap_single() instead of pci_unmap_page()
+	* Clean up the 2.6 vs 2.4 #if blocks.
+	* Conditionalize Scheduler
+	* Add a comment to explain a little what the first Makefile
+	  section does.
+	* Removed lpfc_intr_post
+	* Sysfs new display format. Also added write functionality. You
+	  can [ echo "0 log_verbose 3" >
+	  /sys/bus/pci/drivers/lpfc/params]. Hex support yet to be added.
+	* Removed several #ifdef powerpc, including for a discovery issue
+	  in lpfc_ValidLun()
+	* Change elx_printf_log to use vsprintf.
+	* Added lpfc_compat.h provides macros to aid compilation in the
+	  Linux 2.4 kernel over various platform architectures.  Initially
+	  support mapping to a DMA address.
+	* Removed memory pool for nlp/bind buffers and use kmalloc/kfree
+	  directly.
+	* Removed memory pool for iocb buffers and use kmalloc/kfree
+	  directly.
+	* Removed memory pool for mailbox buffers and use kmalloc/kfree
+	  directly.
+	* Cleaned up back and forth casts
+	* Initial support for sysfs for 2.6 kernel.
+	* Changed elx_dma_addr_t to dma_addr_t
+	* Fix a 2.6 kernel check to be >= 2.6.0 instead of > (was missing
+	  2.6.0).
+	* Remove elx_printf and elx_str_sprintf. Replace elx_print with
+	  printk.
+	* Replace elx_printf with printk.
+	* Replace elx_str_sprintf with sprintf.
+	* Removed the mem_lock, its prototype, function, macro, and
+	  iflags.
+	* Use kmalloc/kfree for ELX_SCSI_BUF_t
+	* Use linux pci_pools for SCSI_DMA_EXT
+	* Use linux pci_pools for BPLs.
+	* Minor cleanup of DFC args for PPC64.
+	* Several small indentation cleanups.
+	* New Linux 2.6 style of char device registration.
+	* Migrated members of LPFCHBA_t and LINUX_HBA_t into elxHBA_t
+	* Use strcpy, strncmp, isdigit, strlen instead of abstractions
+	* Cleanup of driver_template.
+	* Facilitate compile time turn on/off of lpfc_network_on.
+	* Split large source files into smaller, better named ones.
+
+Changes from 2.10a to 20040312
+
+	* Fix build for 2.4 kernels
+	* Move driver version macros into lpfc_version.h file.
+	* Fixed data miscompare with LIP.
+	* Removed elx_sli, elx_ioc, elx_disc, elx_sch routines,
+	  prototypes, and reference points.
+	* Correct the space insertions with hardtabs
+	* Remove routine call pointers in ELX_SLI_INIT_t struct.
+	* Removed module locks except for drvr, mem, and clock.
+	* Removed unused module locks from sourcebase. Kept drvr_lock,
+	  mem_lock, and clock_lock.
+	* Change NULL to 0
diff -urNp linux-8152/drivers/addon/lpfc/Makefile linux-8155/drivers/addon/lpfc/Makefile
--- linux-8152/drivers/addon/lpfc/Makefile
+++ linux-8155/drivers/addon/lpfc/Makefile
@@ -0,0 +1,24 @@
+#
+# Makefile for the LPFC driver
+#
+#
+
+O_TARGET := lpfc.o
+EXTRA_CFLAGS += -I$(TOPDIR)/drivers/scsi -DVARYIO=3 -DUSE_HIGHMEM_IO=3
+obj-m:= $(O_TARGET)
+
+obj-y:= lpfc_clock.o 		\
+	lpfc_ct.o		\
+	lpfc_els.o		\
+	lpfc_fcp.o		\
+	lpfc_hbadisc.o		\
+	lpfc_init.o		\
+	lpfc_logmsg.o		\
+	lpfc_mbox.o		\
+	lpfc_mem.o		\
+	lpfc_nportdisc.o	\
+	lpfc_sched.o		\
+	lpfc_scsiport.o		\
+	lpfc_sli.o
+
+include $(TOPDIR)/Rules.make
diff -urNp linux-8152/drivers/addon/lpfc/hbaapi.h linux-8155/drivers/addon/lpfc/hbaapi.h
--- linux-8152/drivers/addon/lpfc/hbaapi.h
+++ linux-8155/drivers/addon/lpfc/hbaapi.h
@@ -0,0 +1,481 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: hbaapi.h 328 2005-05-03 15:20:43Z sf_support $
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef HBA_API_H
+#define HBA_API_H
+
+/* Library version string */
+#define HBA_LIBVERSION 2
+
+/* DLL imports for WIN32 operation */
+#define HBA_API
+
+	typedef unsigned char HBA_UINT8;	/* Unsigned  8 bits */
+	typedef char HBA_INT8;	/* Signed    8 bits */
+	typedef unsigned short HBA_UINT16;	/* Unsigned 16 bits */
+	typedef short HBA_INT16;	/* Signed   16 bits */
+	typedef unsigned int HBA_UINT32;	/* Unsigned 32 bits */
+	typedef int HBA_INT32;	/* Signed   32 bits */
+	typedef void *HBA_PVOID;	/* Pointer  to void */
+	typedef HBA_UINT32 HBA_VOID32;	/* Opaque   32 bits */
+	typedef long long HBA_INT64;
+	typedef long long HBA_UINT64;
+
+/* 6.1        Handle to Device */
+	typedef HBA_UINT32 HBA_HANDLE;
+
+#define HBA_HANDLE_INVALID                   0
+
+/* 6.1        Status Return Values */
+	typedef HBA_UINT32 HBA_STATUS;
+
+#define HBA_STATUS_OK                        0
+#define HBA_STATUS_ERROR                     1	/* Error */
+#define HBA_STATUS_ERROR_NOT_SUPPORTED       2	/* Function not supported. */
+#define HBA_STATUS_ERROR_INVALID_HANDLE      3	/* invalid handle */
+#define HBA_STATUS_ERROR_ARG                 4	/* Bad argument */
+#define HBA_STATUS_ERROR_ILLEGAL_WWN         5	/* WWN not recognized */
+#define HBA_STATUS_ERROR_ILLEGAL_INDEX       6	/* Index not recognized */
+#define HBA_STATUS_ERROR_MORE_DATA           7	/* Larger buffer required */
+#define HBA_STATUS_ERROR_STALE_DATA          8	/* Information has changed since
+						 * last call to
+						 * HBA_Refreshinformation */
+#define HBA_STATUS_SCSI_CHECK_CONDITION      9	/* Obvious */
+#define HBA_STATUS_ERROR_BUSY                10	/* HBA busy or reserved,
+						 * retry may be effective */
+#define HBA_STATUS_ERROR_TRY_AGAIN           11	/* Request timedout,
+						 * retry may be effective */
+#define HBA_STATUS_ERROR_UNAVAILABLE         12	/* Referenced HBA has been
+						 * removed or deactivated */
+#define HBA_STATUS_ERROR_ELS_REJECT          13	/* The requested ELS was
+						 * rejected by the local HBA */
+#define HBA_STATUS_ERROR_INVALID_LUN         14	/* The specified LUN is not
+						 *  provided the specified
+						 *  HBA */
+#define HBA_STATUS_ERROR_INCOMPATIBLE        15
+
+#define HBA_STATUS_ERROR_AMBIGUOUS_WWN       16	/* Multiple adapters have a
+						 * matching WWN. This could
+						 * occur if the NodeWWN of
+						 * multiple adapters is
+						 * identical */
+#define HBA_STATUS_ERROR_LOCAL_BUS           17	/* A persistent binding request
+						 * included a bad local SCSI bus
+						 * number */
+#define HBA_STATUS_ERROR_LOCAL_TARGET        18	/* A persistent binding request
+						 * included a bad local SCSI
+						 * target number */
+#define HBA_STATUS_ERROR_LOCAL_LUN           19	/* A persistent binding request
+						 * included a bad local SCSI
+						 * logical unit number */
+#define HBA_STATUS_ERROR_LOCAL_SCSIID_BOUND  20	/* A persistent binding set
+						 * request included a local SCSI
+						 * ID that was already bound */
+#define HBA_STATUS_ERROR_TARGET_FCID         21	/* A persistent binding request
+						 * included a bad or unlocatable
+						 * FCP Target FCID */
+#define HBA_STATUS_ERROR_TARGET_NODE_WWN     22	/* A persistent binding request
+						 * included a bad FCP Target
+						 * Node WWN */
+#define HBA_STATUS_ERROR_TARGET_PORT_WWN     23	/* A persistent binding request
+						 * included a bad FCP Target
+						 * Port WWN */
+#define HBA_STATUS_ERROR_TARGET_LUN          24	/* A persistent binding request
+						 * included an FCP Logical Unit
+						 * Number not defined by the
+						 * identified Target*/
+#define HBA_STATUS_ERROR_TARGET_LUID         25	/* A persistent binding request
+						 * included an undefined or
+						 * otherwise inaccessible
+						 * Logical Unit Unique
+						 * Identifier */
+#define HBA_STATUS_ERROR_NO_SUCH_BINDING     26	/* A persistent binding remove
+						 * request included a binding
+						 * which did not match a binding
+						 * established by the specified
+						 * port */
+#define HBA_STATUS_ERROR_NOT_A_TARGET        27	/* A SCSI command was requested
+						 * to an Nx_Port that was not a
+						 * SCSI Target Port */
+#define HBA_STATUS_ERROR_UNSUPPORTED_FC4     28	/* A request was made concerning
+						 * an unsupported FC-4
+						 * protocol */
+#define HBA_STATUS_ERROR_INCAPABLE           29	/* A request was made to enable
+						 * unimplemented capabilities
+						 * for a port */
+#define HBA_STATUS_ERROR_TARGET_BUSY         30	/* A SCSI function was requested
+						 * at a time when issuing the
+						 * requested command would cause
+						 * a a SCSI overlapped command
+						 * condition (see SAM-3) */
+
+/* 6.4.1        Port Operational Modes Values */
+	typedef HBA_UINT32 HBA_PORTTYPE;
+
+#define HBA_PORTTYPE_UNKNOWN                1	/* Unknown */
+#define HBA_PORTTYPE_OTHER                  2	/* Other */
+#define HBA_PORTTYPE_NOTPRESENT             3	/* Not present */
+#define HBA_PORTTYPE_NPORT                  5	/* Fabric  */
+#define HBA_PORTTYPE_NLPORT                 6	/* Public Loop */
+#define HBA_PORTTYPE_FLPORT                 7
+#define HBA_PORTTYPE_FPORT                  8	/* Fabric Port */
+#define HBA_PORTTYPE_LPORT                  20	/* Private Loop */
+#define HBA_PORTTYPE_PTP                    21	/* Point to Point */
+
+	typedef HBA_UINT32 HBA_PORTSTATE;
+#define HBA_PORTSTATE_UNKNOWN               1	/* Unknown */
+#define HBA_PORTSTATE_ONLINE                2	/* Operational */
+#define HBA_PORTSTATE_OFFLINE               3	/* User Offline */
+#define HBA_PORTSTATE_BYPASSED              4	/* Bypassed */
+#define HBA_PORTSTATE_DIAGNOSTICS           5	/* In diagnostics mode */
+#define HBA_PORTSTATE_LINKDOWN              6	/* Link Down */
+#define HBA_PORTSTATE_ERROR                 7	/* Port Error */
+#define HBA_PORTSTATE_LOOPBACK              8	/* Loopback */
+
+	typedef HBA_UINT32 HBA_PORTSPEED;
+#define HBA_PORTSPEED_UNKNOWN               0	/* Unknown - transceiver incable
+						 * of reporting */
+#define HBA_PORTSPEED_1GBIT                 1	/* 1 GBit/sec */
+#define HBA_PORTSPEED_2GBIT                 2	/* 2 GBit/sec */
+#define HBA_PORTSPEED_4GBIT                 8	/* 4 GBit/sec */
+#define HBA_PORTSPEED_8GBIT                16 	/* 8 GBit/sec */
+#define HBA_PORTSPEED_10GBIT                4	/* 10 GBit/sec */
+#define HBA_PORTSPEED_NOT_NEGOTIATED        5	/* Speed not established */
+
+/* 6.4.1.4        See "Class of Service  - Format" in GC-GS-4 */
+
+	typedef HBA_UINT32 HBA_COS;
+
+/* 6.4.1.5        Fc4Types Values */
+
+	typedef struct HBA_fc4types {
+		HBA_UINT8 bits[32];	/* 32 bytes of FC-4 per GS-2 */
+	} HBA_FC4TYPES, *PHBA_FC4TYPES;
+
+/* 6.1        Basic Types */
+
+	typedef struct HBA_wwn {
+		HBA_UINT8 wwn[8];
+	} HBA_WWN, *PHBA_WWN;
+
+	typedef struct HBA_ipaddress {
+		int ipversion;	/* see enumerations in RNID */
+		union {
+			unsigned char ipv4address[4];
+			unsigned char ipv6address[16];
+		} ipaddress;
+	} HBA_IPADDRESS, *PHBA_IPADDRESS;
+
+	typedef HBA_INT8 HBA_BOOLEAN;
+
+/* 6.3.1        Adapter Attributes */
+	typedef struct hba_AdapterAttributes {
+		char Manufacturer[64];
+		char SerialNumber[64];
+		char Model[256];
+		char ModelDescription[256];
+		HBA_WWN NodeWWN;
+		char NodeSymbolicName[256];
+		char HardwareVersion[256];
+		char DriverVersion[256];
+		char OptionROMVersion[256];
+		char FirmwareVersion[256];
+		HBA_UINT32 VendorSpecificID;
+		HBA_UINT32 NumberOfPorts;
+		char DriverName[256];
+	} HBA_ADAPTERATTRIBUTES, *PHBA_ADAPTERATTRIBUTES;
+
+/* 6.4.1.6        Port Attributes */
+	typedef struct HBA_PortAttributes {
+		HBA_WWN NodeWWN;
+		HBA_WWN PortWWN;
+		HBA_UINT32 PortFcId;
+		HBA_PORTTYPE PortType;
+		HBA_PORTSTATE PortState;
+		HBA_COS PortSupportedClassofService;
+		HBA_FC4TYPES PortSupportedFc4Types;
+		HBA_FC4TYPES PortActiveFc4Types;
+		char PortSymbolicName[256];
+		char OSDeviceName[256];
+		HBA_PORTSPEED PortSupportedSpeed;
+		HBA_PORTSPEED PortSpeed;
+		HBA_UINT32 PortMaxFrameSize;
+		HBA_WWN FabricName;
+		HBA_UINT32 NumberofDiscoveredPorts;
+	} HBA_PORTATTRIBUTES, *PHBA_PORTATTRIBUTES;
+
+	typedef struct HBA_PortStatistics {
+		HBA_INT64 SecondsSinceLastReset;
+		HBA_INT64 TxFrames;
+		HBA_INT64 TxWords;
+		HBA_INT64 RxFrames;
+		HBA_INT64 RxWords;
+		HBA_INT64 LIPCount;
+		HBA_INT64 NOSCount;
+		HBA_INT64 ErrorFrames;
+		HBA_INT64 DumpedFrames;
+		HBA_INT64 LinkFailureCount;
+		HBA_INT64 LossOfSyncCount;
+		HBA_INT64 LossOfSignalCount;
+		HBA_INT64 PrimitiveSeqProtocolErrCount;
+		HBA_INT64 InvalidTxWordCount;
+		HBA_INT64 InvalidCRCCount;
+	} HBA_PORTSTATISTICS, *PHBA_PORTSTATISTICS;
+
+/* 6.6.1                FCP Attributes */
+
+	typedef enum HBA_fcpbindingtype { TO_D_ID, TO_WWN,
+		TO_OTHER
+	} HBA_FCPBINDINGTYPE;
+
+	typedef struct HBA_ScsiId {
+		char OSDeviceName[256];
+		HBA_UINT32 ScsiBusNumber;
+		HBA_UINT32 ScsiTargetNumber;
+		HBA_UINT32 ScsiOSLun;
+	} HBA_SCSIID, *PHBA_SCSIID;
+
+	typedef struct HBA_FcpId {
+		HBA_UINT32 FcId;
+		HBA_WWN NodeWWN;
+		HBA_WWN PortWWN;
+		HBA_UINT64 FcpLun;
+	} HBA_FCPID, *PHBA_FCPID;
+
+	typedef struct HBA_LUID {
+		char buffer[256];
+	} HBA_LUID, *PHBA_LUID;
+
+	typedef struct HBA_FcpScsiEntry {
+		HBA_SCSIID ScsiId;
+		HBA_FCPID FcpId;
+	} HBA_FCPSCSIENTRY, *PHBA_FCPSCSIENTRY;
+
+	typedef struct HBA_FcpScsiEntryV2 {
+		HBA_SCSIID ScsiId;
+		HBA_FCPID FcpId;
+		HBA_LUID LUID;
+	} HBA_FCPSCSIENTRYV2, *PHBA_FCPSCSIENTRYV2;
+
+	typedef struct HBA_FCPTargetMapping {
+		HBA_UINT32 NumberOfEntries;
+		HBA_FCPSCSIENTRY entry[1];	/* Variable length array
+						 * containing mappings */
+	} HBA_FCPTARGETMAPPING, *PHBA_FCPTARGETMAPPING;
+
+	typedef struct HBA_FCPTargetMappingV2 {
+		HBA_UINT32 NumberOfEntries;
+		HBA_FCPSCSIENTRYV2 entry[1];	/* Variable length array
+						 * containing mappings */
+	} HBA_FCPTARGETMAPPINGV2, *PHBA_FCPTARGETMAPPINGV2;
+
+	typedef struct HBA_FCPBindingEntry {
+		HBA_FCPBINDINGTYPE type;
+		HBA_SCSIID ScsiId;
+		HBA_FCPID FcpId;	/* WWN valid only if type is
+					 * to WWN, FcpLun always valid */
+		HBA_UINT32 FcId;
+	} HBA_FCPBINDINGENTRY, *PHBA_FCPBINDINGENTRY;
+
+	typedef struct HBA_FCPBinding {
+		HBA_UINT32 NumberOfEntries;
+		HBA_FCPBINDINGENTRY entry[1];	/* Variable length array */
+	} HBA_FCPBINDING, *PHBA_FCPBINDING;
+
+/* 6.7.1        FC-3 Management Atrributes */
+
+	typedef enum HBA_wwntype { NODE_WWN, PORT_WWN } HBA_WWNTYPE;
+
+	typedef struct HBA_MgmtInfo {
+		HBA_WWN wwn;
+		HBA_UINT32 unittype;
+		HBA_UINT32 PortId;
+		HBA_UINT32 NumberOfAttachedNodes;
+		HBA_UINT16 IPVersion;
+		HBA_UINT16 UDPPort;
+		HBA_UINT8 IPAddress[16];
+		HBA_UINT16 reserved;
+		HBA_UINT16 TopologyDiscoveryFlags;
+	} HBA_MGMTINFO, *PHBA_MGMTINFO;
+
+/* Event Codes */
+#define HBA_EVENT_LIP_OCCURRED           1
+#define HBA_EVENT_LINK_UP                2
+#define HBA_EVENT_LINK_DOWN              3
+#define HBA_EVENT_LIP_RESET_OCCURRED     4
+#define HBA_EVENT_RSCN                   5
+#define HBA_EVENT_PROPRIETARY            0xFFFF
+
+	typedef struct HBA_Link_EventInfo {
+		HBA_UINT32 PortFcId;	/* Port where event occurred */
+		HBA_UINT32 Reserved[3];
+	} HBA_LINK_EVENTINFO, *PHBA_LINK_EVENTINFO;
+
+	typedef struct HBA_RSCN_EventInfo {
+		HBA_UINT32 PortFcId;	/* Port where event occurred */
+		HBA_UINT32 NPortPage;	/* Reference FC-FS for RSCN ELS
+					 * "Affected N-Port Pages"*/
+		HBA_UINT32 Reserved[2];
+	} HBA_RSCN_EVENTINFO, *PHBA_RSCN_EVENTINFO;
+
+	typedef struct HBA_Pty_EventInfo {
+		HBA_UINT32 PtyData[4];	/* Proprietary data */
+	} HBA_PTY_EVENTINFO, *PHBA_PTY_EVENTINFO;
+
+	typedef struct HBA_EventInfo {
+		HBA_UINT32 EventCode;
+		union {
+			HBA_LINK_EVENTINFO Link_EventInfo;
+			HBA_RSCN_EVENTINFO RSCN_EventInfo;
+			HBA_PTY_EVENTINFO Pty_EventInfo;
+		} Event;
+	} HBA_EVENTINFO, *PHBA_EVENTINFO;
+
+/* Persistant Binding... */
+	typedef HBA_UINT32 HBA_BIND_TYPE;
+#define HBA_BIND_TO_D_ID                0x0001
+#define HBA_BIND_TO_WWPN                0x0002
+#define HBA_BIND_TO_WWNN                0x0004
+#define HBA_BIND_TO_LUID                0x0008
+#define HBA_BIND_TARGETS                0x0800
+
+/* A bit mask of Rev 2.0 persistent binding capabilities */
+	typedef HBA_UINT32 HBA_BIND_CAPABILITY;
+/* The following are bit flags indicating persistent binding capabilities */
+#define HBA_CAN_BIND_TO_D_ID                0x0001
+#define HBA_CAN_BIND_TO_WWPN                0x0002
+#define HBA_CAN_BIND_TO_WWNN                0x0004
+#define HBA_CAN_BIND_TO_LUID                0x0008
+#define HBA_CAN_BIND_ANY_LUNS               0x0400
+#define HBA_CAN_BIND_TARGETS                0x0800
+#define HBA_CAN_BIND_AUTOMAP                0x1000
+#define HBA_CAN_BIND_CONFIGURED             0x2000
+
+#define HBA_BIND_STATUS_DISABLED            0x00
+#define HBA_BIND_STATUS_ENABLED             0x01
+
+	typedef HBA_UINT32 HBA_BIND_STATUS;
+
+#define HBA_BIND_EFFECTIVE_AT_REBOOT        0x00
+#define HBA_BIND_EFFECTIVE_IMMEDIATE        0x01
+
+	typedef HBA_UINT32 HBA_BIND_EFFECTIVE;
+
+	typedef struct HBA_FCPBindingEntry2 {
+		HBA_BIND_TYPE type;
+		HBA_SCSIID ScsiId;
+		HBA_FCPID FcpId;
+		HBA_LUID LUID;
+		HBA_STATUS status;
+	} HBA_FCPBINDINGENTRY2, *PHBA_FCPBINDINGENTRY2;
+
+	typedef struct HBA_FcpBinding2 {
+		HBA_UINT32 NumberOfEntries;
+		HBA_FCPBINDINGENTRY2 entry[1];	/* Variable length array */
+	} HBA_FCPBINDING2, *PHBA_FCPBINDING2;
+
+/* FC-4 Instrumentation */
+	typedef struct HBA_FC4Statistics {
+		HBA_INT64 InputRequests;
+		HBA_INT64 OutputRequests;
+		HBA_INT64 ControlRequests;
+		HBA_INT64 InputMegabytes;
+		HBA_INT64 OutputMegabytes;
+	} HBA_FC4STATISTICS, *PHBA_FC4STATISTICS;
+
+	typedef void *HBA_CALLBACKHANDLE;
+/* Adapter Level Events */
+#define HBA_EVENT_ADAPTER_UNKNOWN       0x100
+#define HBA_EVENT_ADAPTER_ADD           0x101
+#define HBA_EVENT_ADAPTER_REMOVE        0x102
+#define HBA_EVENT_ADAPTER_CHANGE        0x103
+
+/* Port Level Events */
+#define HBA_EVENT_PORT_UNKNOWN          0x200
+#define HBA_EVENT_PORT_OFFLINE          0x201
+#define HBA_EVENT_PORT_ONLINE           0x202
+#define HBA_EVENT_PORT_NEW_TARGETS      0x203
+#define HBA_EVENT_PORT_FABRIC           0x204
+
+/* Port Statistics Events */
+#define HBA_EVENT_PORT_STAT_THRESHOLD   0x301
+#define HBA_EVENT_PORT_STAT_GROWTH      0x302
+
+/* Target Level Events */
+#define HBA_EVENT_TARGET_UNKNOWN        0x400
+#define HBA_EVENT_TARGET_OFFLINE        0x401
+#define HBA_EVENT_TARGET_ONLINE         0x402
+#define HBA_EVENT_TARGET_REMOVED        0x403
+
+/* Fabric Link  Events */
+#define HBA_EVENT_LINK_UNKNOWN          0x500
+#define HBA_EVENT_LINK_INCIDENT         0x501
+
+/* Used for OSDeviceName */
+	typedef struct HBA_osdn {
+		char drvname[32];
+		uint32_t instance;
+		uint32_t target;
+		uint32_t lun;
+		uint32_t bus;
+		char flags;
+		char sizeSN;
+		char InquirySN[64];
+	} HBA_OSDN;
+
+/* type definitions for GetBindList function */
+	typedef enum HBA_bindtype { BIND_NONE, BIND_WWNN, BIND_WWPN, BIND_DID,
+		BIND_ALPA
+	} HBA_BINDTYPE;
+/* Bind Entry flags */
+#define         HBA_BIND_AUTOMAP  0x1	/* Node is automapped            */
+#define         HBA_BIND_BINDLIST 0x2	/* entry in bind list not mapped */
+#define         HBA_BIND_MAPPED   0x4	/* Node is mapped to  a scsiid   */
+#define         HBA_BIND_UNMAPPED 0x8	/* Node is unmapped              */
+#define         HBA_BIND_NODEVTMO 0x10	/* NODEVTMO flag of the node     */
+#define         HBA_BIND_NOSCSIID 0x20	/* No scsi id is assigned yet    */
+#define         HBA_BIND_RPTLUNST 0x40	/* Node is in report lun cmpl st */
+	typedef struct {
+		HBA_BINDTYPE bind_type;
+		HBA_UINT32 scsi_id;
+		HBA_UINT32 did;
+		HBA_WWN wwnn;
+		HBA_WWN wwpn;
+		HBA_UINT32 flags;
+	} HBA_BIND_ENTRY;
+
+	typedef struct {
+		HBA_UINT32 NumberOfEntries;
+		HBA_BIND_ENTRY entry[1];	/* Variable length array */
+	} HBA_BIND_LIST, *HBA_BIND_LIST_PTR;
+
+#endif				/* HBA_API_H */
+
+#ifdef __cplusplus
+}
+#endif
diff -urNp linux-8152/drivers/addon/lpfc/lpfc.conf linux-8155/drivers/addon/lpfc/lpfc.conf
--- linux-8152/drivers/addon/lpfc/lpfc.conf
+++ linux-8155/drivers/addon/lpfc/lpfc.conf
@@ -0,0 +1,1271 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc.conf 328 2005-05-03 15:20:43Z sf_support $
+ */
+
+
+#ifndef _ETC_LPFC_CONF_
+#define _ETC_LPFC_CONF_
+
+#include "lpfc_cfgparm.h"
+
+/**************************  GLOBAL PARMS **********************/
+
+/* 
+# Setup FCP persistent bindings,
+# fcp-bind-WWPN binds a specific WorldWide PortName to a target id,
+# fcp-bind-WWNN binds a specific WorldWide NodeName to a target id,
+# fcp-bind-DID binds a specific DID to a target id.
+# Each array must end with a NULL pointer.
+# Binding method must match with the bind method of that HBA, else the
+# binding will be ignored.
+# scan-down should NOT be set to 2 when one of these binding methods 
+# is used. 
+# WWNN, WWPN and DID are hexadecimal values.
+# WWNN must be 16 digit BCD with leading 0s.
+# WWPN must be 16 digit BCD with leading 0s.
+# DID must be 6 digit BCD with leading 0s.
+# The SCSI ID to bind to consists of two parts, the lpfc interface
+# to bind to, and the target number for that interface.
+# Thus lpfc0t2 specifies target 2 on interface lpfc0.
+#
+# Here are some examples:
+#                                   WWNN             SCSI ID
+# char *lpfc_fcp_bind_WWNN[MAX_FC_BINDINGS]={"22000020370b8275:lpfc0t1",
+#                                            "22000020370b8998:lpfc0t2",
+#                                            0};
+# 
+#                                   WWPN             SCSI ID
+# char *lpfc_fcp_bind_WWPN[MAX_FC_BINDINGS]={"22000020370b8275:lpfc0t1",
+#                                            "22000020370b8998:lpfc0t2",
+#                                            0};
+# 
+#                                   DID   SCSI ID
+# char *lpfc_fcp_bind_DID[MAX_FC_BINDINGS]={"0000dc:lpfc0t1",
+#                                           "0000e0:lpfc0t2",
+#                                           0};
+# 
+*/
+      
+char *lpfc_fcp_bind_WWNN[MAX_FC_BINDINGS]   =  {0};
+
+char *lpfc_fcp_bind_WWPN[MAX_FC_BINDINGS]   =  {0};
+
+char *lpfc_fcp_bind_DID[MAX_FC_BINDINGS]    =  {0};
+
+/************************  PER ADAPTER PARMS ********************/
+
+/*
+ * The per adapter parmaters are in the form of lpfcX_param where
+ * X is the adapter number. If lpfcX_param = -1 then it will assume
+ * the default value which is indicated by lpfc_param that precedes
+ * that particular set of lpfcX_param's.
+ */
+
+/*
+# lpfc_max_lun: Specifies the maximum number of luns per target. A value of
+# 20 means luns from 0 to 19 are valid. Value range is [1,256]. Default
+# value = 256.
+*/
+int lpfc_max_lun   = 256;
+int lpfc0_max_lun  = -1;
+int lpfc1_max_lun  = -1;
+int lpfc2_max_lun  = -1;
+int lpfc3_max_lun  = -1;
+int lpfc4_max_lun  = -1;
+int lpfc5_max_lun  = -1;
+int lpfc6_max_lun  = -1;
+int lpfc7_max_lun  = -1;
+int lpfc8_max_lun  = -1;
+int lpfc9_max_lun  = -1;
+int lpfc10_max_lun = -1;
+int lpfc11_max_lun = -1;
+int lpfc12_max_lun = -1;
+int lpfc13_max_lun = -1;
+int lpfc14_max_lun = -1;
+int lpfc15_max_lun = -1;
+int lpfc16_max_lun = -1;
+int lpfc17_max_lun = -1;
+int lpfc18_max_lun = -1;
+int lpfc19_max_lun = -1;
+int lpfc20_max_lun = -1;
+int lpfc21_max_lun = -1;
+int lpfc22_max_lun = -1;
+int lpfc23_max_lun = -1;
+int lpfc24_max_lun = -1;
+int lpfc25_max_lun = -1;
+int lpfc26_max_lun = -1;
+int lpfc27_max_lun = -1;
+int lpfc28_max_lun = -1;
+int lpfc29_max_lun = -1;
+int lpfc30_max_lun = -1;
+int lpfc31_max_lun = -1;
+
+/*
+# Specifies the maximum number of ELS cmds we can have outstanding (for 
+# discovery). Value range is [1,64]. Default value = 1.
+*/
+int lpfc_discovery_threads   =  1;
+int lpfc0_discovery_threads  = -1;
+int lpfc1_discovery_threads  = -1;
+int lpfc2_discovery_threads  = -1;
+int lpfc3_discovery_threads  = -1;
+int lpfc4_discovery_threads  = -1;
+int lpfc5_discovery_threads  = -1;
+int lpfc6_discovery_threads  = -1;
+int lpfc7_discovery_threads  = -1;
+int lpfc8_discovery_threads  = -1;
+int lpfc9_discovery_threads  = -1;
+int lpfc10_discovery_threads = -1;
+int lpfc11_discovery_threads = -1;
+int lpfc12_discovery_threads = -1;
+int lpfc13_discovery_threads = -1;
+int lpfc14_discovery_threads = -1;
+int lpfc15_discovery_threads = -1;
+int lpfc16_discovery_threads = -1;
+int lpfc17_discovery_threads = -1;
+int lpfc18_discovery_threads = -1;
+int lpfc19_discovery_threads = -1;
+int lpfc20_discovery_threads = -1;
+int lpfc21_discovery_threads = -1;
+int lpfc22_discovery_threads = -1;
+int lpfc23_discovery_threads = -1;
+int lpfc24_discovery_threads = -1;
+int lpfc25_discovery_threads = -1;
+int lpfc26_discovery_threads = -1;
+int lpfc27_discovery_threads = -1;
+int lpfc28_discovery_threads = -1;
+int lpfc29_discovery_threads = -1;
+int lpfc30_discovery_threads = -1;
+int lpfc31_discovery_threads = -1;
+
+/*
+# lpfc_max_target: This configuration parameter limits how many targets/luns
+# the driver will support. Value range is [1,256]. Default value = 256.
+*/
+int  lpfc_max_target  = 256;
+int  lpfc0_max_target  = -1;
+int  lpfc1_max_target  = -1;
+int  lpfc2_max_target  = -1;
+int  lpfc3_max_target  = -1;
+int  lpfc4_max_target  = -1;
+int  lpfc5_max_target  = -1;
+int  lpfc6_max_target  = -1;
+int  lpfc7_max_target  = -1;
+int  lpfc8_max_target  = -1;
+int  lpfc9_max_target  = -1;
+int  lpfc10_max_target = -1;
+int  lpfc11_max_target = -1;
+int  lpfc12_max_target = -1;
+int  lpfc13_max_target = -1;
+int  lpfc14_max_target = -1;
+int  lpfc15_max_target = -1;
+int  lpfc16_max_target = -1;
+int  lpfc17_max_target = -1;
+int  lpfc18_max_target = -1;
+int  lpfc19_max_target = -1;
+int  lpfc20_max_target = -1;
+int  lpfc21_max_target = -1;
+int  lpfc22_max_target = -1;
+int  lpfc23_max_target = -1;
+int  lpfc24_max_target = -1;
+int  lpfc25_max_target = -1;
+int  lpfc26_max_target = -1;
+int  lpfc27_max_target = -1;
+int  lpfc28_max_target = -1;
+int  lpfc29_max_target = -1;
+int  lpfc30_max_target = -1;
+int  lpfc31_max_target = -1;
+
+/*
+# lpfc_fcp_bind_method: It specifies the method of binding to be used for each
+# port. This  binding method is used for persistent binding and automaped 
+# binding. A value of 1 will force WWNN binding, value of 2 will force WWPN
+# binding, value of 3 will force DID binding and value of 4 will force the
+# driver to derive binding from ALPA. Any persistent binding whose type does
+# not match with the bind method of the port will be ignored. Value range 
+# is [1,4]. Default value is 2.
+*/
+int  lpfc_fcp_bind_method   =  2;
+int  lpfc0_fcp_bind_method  = -1;
+int  lpfc1_fcp_bind_method  = -1;
+int  lpfc2_fcp_bind_method  = -1;
+int  lpfc3_fcp_bind_method  = -1;
+int  lpfc4_fcp_bind_method  = -1;
+int  lpfc5_fcp_bind_method  = -1;
+int  lpfc6_fcp_bind_method  = -1;
+int  lpfc7_fcp_bind_method  = -1;
+int  lpfc8_fcp_bind_method  = -1;
+int  lpfc9_fcp_bind_method  = -1;
+int  lpfc10_fcp_bind_method = -1;
+int  lpfc11_fcp_bind_method = -1;
+int  lpfc12_fcp_bind_method = -1;
+int  lpfc13_fcp_bind_method = -1;
+int  lpfc14_fcp_bind_method = -1;
+int  lpfc15_fcp_bind_method = -1;
+int  lpfc16_fcp_bind_method = -1;
+int  lpfc17_fcp_bind_method = -1;
+int  lpfc18_fcp_bind_method = -1;
+int  lpfc19_fcp_bind_method = -1;
+int  lpfc20_fcp_bind_method = -1;
+int  lpfc21_fcp_bind_method = -1;
+int  lpfc22_fcp_bind_method = -1;
+int  lpfc23_fcp_bind_method = -1;
+int  lpfc24_fcp_bind_method = -1;
+int  lpfc25_fcp_bind_method = -1;
+int  lpfc26_fcp_bind_method = -1;
+int  lpfc27_fcp_bind_method = -1;
+int  lpfc28_fcp_bind_method = -1;
+int  lpfc29_fcp_bind_method = -1;
+int  lpfc30_fcp_bind_method = -1;
+int  lpfc31_fcp_bind_method = -1;
+
+/*
+# If automap is set, SCSI IDs for all FCP nodes without
+# persistent bindings will be automatically generated.
+# If new FCP devices are added to the network when the system is down,
+# there is no guarantee that these SCSI IDs will remain the same
+# when the system is booted again. 
+# The bind method of the port is used as the binding method of
+# automap devices to preserve SCSI IDs between link down and link up.
+# If automap is 0, only devices with persistent bindings will be
+# recognized by the system. User can change the automap property
+# of port instance X by changing the value of lpfcX_automap parameter.
+# Value range is [0,1]. Default value is 1.
+*/
+int  lpfc_automap   =  1;
+int  lpfc0_automap  = -1;
+int  lpfc1_automap  = -1;
+int  lpfc2_automap  = -1;
+int  lpfc3_automap  = -1;
+int  lpfc4_automap  = -1;
+int  lpfc5_automap  = -1;
+int  lpfc6_automap  = -1;
+int  lpfc7_automap  = -1;
+int  lpfc8_automap  = -1;
+int  lpfc9_automap  = -1;
+int  lpfc10_automap = -1;
+int  lpfc11_automap = -1;
+int  lpfc12_automap = -1;
+int  lpfc13_automap = -1;
+int  lpfc14_automap = -1;
+int  lpfc15_automap = -1;
+int  lpfc16_automap = -1;
+int  lpfc17_automap = -1;
+int  lpfc18_automap = -1;
+int  lpfc19_automap = -1;
+int  lpfc20_automap = -1;
+int  lpfc21_automap = -1;
+int  lpfc22_automap = -1;
+int  lpfc23_automap = -1;
+int  lpfc24_automap = -1;
+int  lpfc25_automap = -1;
+int  lpfc26_automap = -1;
+int  lpfc27_automap = -1;
+int  lpfc28_automap = -1;
+int  lpfc29_automap = -1;
+int  lpfc30_automap = -1;
+int  lpfc31_automap = -1;
+
+/*
+# Some disk devices have a "select ID" or "select Target" capability.
+# From a protocol standpoint "select ID" usually means select the
+# Fibre channel "ALPA".  In the FC-AL Profile there is an "informative
+# annex" which contains a table that maps a "select ID" (a number
+# between 0 and 7F) to an ALPA.  By default, for compatibility with
+# older drivers, the lpfc driver scans this table from low ALPA to high
+# ALPA.
+#
+# Turning on the scan-down variable (on  = 1, off = 0) will
+# cause the lpfc driver to use an inverted table, effectively
+# scanning ALPAs from high to low. Value range is [0,1]. Default value is 1.
+#
+# (Note: This "select ID" functionality is a LOOP ONLY characteristic
+# and will not work across a fabric. Also this parameter will take
+# effect only in the case when ALPA map is not available.)
+*/
+int  lpfc_scan_down    =  1;
+int  lpfc0_scan_down   = -1;
+int  lpfc1_scan_down   = -1;
+int  lpfc2_scan_down   = -1;
+int  lpfc3_scan_down   = -1;
+int  lpfc4_scan_down   = -1;
+int  lpfc5_scan_down   = -1;
+int  lpfc6_scan_down   = -1;
+int  lpfc7_scan_down   = -1;
+int  lpfc8_scan_down   = -1;
+int  lpfc9_scan_down   = -1;
+int  lpfc10_scan_down  = -1;
+int  lpfc11_scan_down  = -1;
+int  lpfc12_scan_down  = -1;
+int  lpfc13_scan_down  = -1;
+int  lpfc14_scan_down  = -1;
+int  lpfc15_scan_down  = -1;
+int  lpfc16_scan_down  = -1;
+int  lpfc17_scan_down  = -1;
+int  lpfc18_scan_down  = -1;
+int  lpfc19_scan_down  = -1;
+int  lpfc20_scan_down  = -1;
+int  lpfc21_scan_down  = -1;
+int  lpfc22_scan_down  = -1;
+int  lpfc23_scan_down  = -1;
+int  lpfc24_scan_down  = -1;
+int  lpfc25_scan_down  = -1;
+int  lpfc26_scan_down  = -1;
+int  lpfc27_scan_down  = -1;
+int  lpfc28_scan_down  = -1;
+int  lpfc29_scan_down  = -1;
+int  lpfc30_scan_down  = -1;
+int  lpfc31_scan_down  = -1;
+
+/*
+# lpfc_log_verbose: Only turn this flag on if you are willing to risk being
+# deluged with LOTS of information.
+# You can set a bit mask to record specific types of verbose messages:
+#
+# LOG_ELS                       0x1        ELS events
+# LOG_DISCOVERY                 0x2        Link discovery events
+# LOG_MBOX                      0x4        Mailbox events
+# LOG_INIT                      0x8        Initialization events
+# LOG_LINK_EVENT                0x10       Link events
+# LOG_FCP                       0x40       FCP traffic history
+# LOG_NODE                      0x80       Node table events
+# LOG_MISC                      0x400      Miscellaneous events
+# LOG_SLI                       0x800      SLI events
+# LOG_CHK_COND                  0x1000     FCP Check condition flag
+# LOG_LIBDFC                    0x2000     LIBDFC events
+# LOG_ALL_MSG                   0xffff     LOG all messages
+*/
+int  lpfc_log_verbose   =  0x0;
+int  lpfc0_log_verbose  = -1;
+int  lpfc1_log_verbose  = -1;
+int  lpfc2_log_verbose  = -1;
+int  lpfc3_log_verbose  = -1;
+int  lpfc4_log_verbose  = -1;
+int  lpfc5_log_verbose  = -1;
+int  lpfc6_log_verbose  = -1;
+int  lpfc7_log_verbose  = -1;
+int  lpfc8_log_verbose  = -1;
+int  lpfc9_log_verbose  = -1;
+int  lpfc10_log_verbose = -1;
+int  lpfc11_log_verbose = -1;
+int  lpfc12_log_verbose = -1;
+int  lpfc13_log_verbose = -1;
+int  lpfc14_log_verbose = -1;
+int  lpfc15_log_verbose = -1;
+int  lpfc16_log_verbose = -1;
+int  lpfc17_log_verbose = -1;
+int  lpfc18_log_verbose = -1;
+int  lpfc19_log_verbose = -1;
+int  lpfc20_log_verbose = -1;
+int  lpfc21_log_verbose = -1;
+int  lpfc22_log_verbose = -1;
+int  lpfc23_log_verbose = -1;
+int  lpfc24_log_verbose = -1;
+int  lpfc25_log_verbose = -1;
+int  lpfc26_log_verbose = -1;
+int  lpfc27_log_verbose = -1;
+int  lpfc28_log_verbose = -1;
+int  lpfc29_log_verbose = -1;
+int  lpfc30_log_verbose = -1;
+int  lpfc31_log_verbose = -1;
+
+/*
+# lun_queue_depth:  This parameter is used to limit the number of outstanding
+# commands per FCP LUN. Value range is [1,128]. Default value is 30.
+*/
+int lpfc_lun_queue_depth   = 30;
+int lpfc0_lun_queue_depth  = -1;
+int lpfc1_lun_queue_depth  = -1;
+int lpfc2_lun_queue_depth  = -1;
+int lpfc3_lun_queue_depth  = -1;
+int lpfc4_lun_queue_depth  = -1;
+int lpfc5_lun_queue_depth  = -1;
+int lpfc6_lun_queue_depth  = -1;
+int lpfc7_lun_queue_depth  = -1;
+int lpfc8_lun_queue_depth  = -1;
+int lpfc9_lun_queue_depth  = -1;
+int lpfc10_lun_queue_depth = -1;
+int lpfc11_lun_queue_depth = -1;
+int lpfc12_lun_queue_depth = -1;
+int lpfc13_lun_queue_depth = -1;
+int lpfc14_lun_queue_depth = -1;
+int lpfc15_lun_queue_depth = -1;
+int lpfc16_lun_queue_depth = -1;
+int lpfc17_lun_queue_depth = -1;
+int lpfc18_lun_queue_depth = -1;
+int lpfc19_lun_queue_depth = -1;
+int lpfc20_lun_queue_depth = -1;
+int lpfc21_lun_queue_depth = -1;
+int lpfc22_lun_queue_depth = -1;
+int lpfc23_lun_queue_depth = -1;
+int lpfc24_lun_queue_depth = -1;
+int lpfc25_lun_queue_depth = -1;
+int lpfc26_lun_queue_depth = -1;
+int lpfc27_lun_queue_depth = -1;
+int lpfc28_lun_queue_depth = -1;
+int lpfc29_lun_queue_depth = -1;
+int lpfc30_lun_queue_depth = -1;
+int lpfc31_lun_queue_depth = -1;
+
+/*
+# tgt_queue_depth: It is used to limit the number of outstanding commands
+# per FCP target. If tgt_queue_depth = 0, the driver will internally use a
+# value appropriate to the FC hardware adapter. Value range is [0,10240]. 
+# Default value is 0.
+*/
+int lpfc_tgt_queue_depth    = 0 ;
+int lpfc0_tgt_queue_depth   = -1;
+int lpfc1_tgt_queue_depth   = -1;
+int lpfc2_tgt_queue_depth   = -1;
+int lpfc3_tgt_queue_depth   = -1;
+int lpfc4_tgt_queue_depth   = -1;
+int lpfc5_tgt_queue_depth   = -1;
+int lpfc6_tgt_queue_depth   = -1;
+int lpfc7_tgt_queue_depth   = -1;
+int lpfc8_tgt_queue_depth   = -1;
+int lpfc9_tgt_queue_depth   = -1;
+int lpfc10_tgt_queue_depth  = -1;
+int lpfc11_tgt_queue_depth  = -1;
+int lpfc12_tgt_queue_depth  = -1;
+int lpfc13_tgt_queue_depth  = -1;
+int lpfc14_tgt_queue_depth  = -1;
+int lpfc15_tgt_queue_depth  = -1;
+int lpfc16_tgt_queue_depth  = -1;
+int lpfc17_tgt_queue_depth  = -1;
+int lpfc18_tgt_queue_depth  = -1;
+int lpfc19_tgt_queue_depth  = -1;
+int lpfc20_tgt_queue_depth  = -1;
+int lpfc21_tgt_queue_depth  = -1;
+int lpfc22_tgt_queue_depth  = -1;
+int lpfc23_tgt_queue_depth  = -1;
+int lpfc24_tgt_queue_depth  = -1;
+int lpfc25_tgt_queue_depth  = -1;
+int lpfc26_tgt_queue_depth  = -1;
+int lpfc27_tgt_queue_depth  = -1;
+int lpfc28_tgt_queue_depth  = -1;
+int lpfc29_tgt_queue_depth  = -1;
+int lpfc30_tgt_queue_depth  = -1;
+int lpfc31_tgt_queue_depth  = -1;
+
+/*
+# no_device_delay: determines the length of the interval between deciding to
+# fail back an I/O because there is no way to communicate with its particular
+# device (e.g., due to device failure) and the actual fail back.  A value of
+# zero implies no delay whatsoever.
+# Cautions:  
+# (1)  This value is in seconds.  
+# (2)  Setting a long delay value may permit I/O to build up, each with a
+# pending timeout, which could result in the exhaustion of critical kernel
+# resources. 
+# Value range is [0,30]. Default value is 1.
+#
+# Note that this value can have an impact on the speed with which a
+# system can shut down with I/Os pending and with the HBA not able to
+# communicate with the loop or fabric, e.g., with a cable pulled.
+*/
+int  lpfc_no_device_delay    =  1;
+int  lpfc0_no_device_delay   = -1;
+int  lpfc1_no_device_delay   = -1;
+int  lpfc2_no_device_delay   = -1;
+int  lpfc3_no_device_delay   = -1;
+int  lpfc4_no_device_delay   = -1;
+int  lpfc5_no_device_delay   = -1;
+int  lpfc6_no_device_delay   = -1;
+int  lpfc7_no_device_delay   = -1;
+int  lpfc8_no_device_delay   = -1;
+int  lpfc9_no_device_delay   = -1;
+int  lpfc10_no_device_delay  = -1;
+int  lpfc11_no_device_delay  = -1;
+int  lpfc12_no_device_delay  = -1;
+int  lpfc13_no_device_delay  = -1;
+int  lpfc14_no_device_delay  = -1;
+int  lpfc15_no_device_delay  = -1;
+int  lpfc16_no_device_delay  = -1;
+int  lpfc17_no_device_delay  = -1;
+int  lpfc18_no_device_delay  = -1;
+int  lpfc19_no_device_delay  = -1;
+int  lpfc20_no_device_delay  = -1;
+int  lpfc21_no_device_delay  = -1;
+int  lpfc22_no_device_delay  = -1;
+int  lpfc23_no_device_delay  = -1;
+int  lpfc24_no_device_delay  = -1;
+int  lpfc25_no_device_delay  = -1;
+int  lpfc26_no_device_delay  = -1;
+int  lpfc27_no_device_delay  = -1;
+int  lpfc28_no_device_delay  = -1;
+int  lpfc29_no_device_delay  = -1;
+int  lpfc30_no_device_delay  = -1;
+int  lpfc31_no_device_delay  = -1;
+
+/*
+# xmt_que_size:  This is the size of the transmit queue for mbufs. Value
+# range is [128,10240]. Default value is 256.
+*/
+int lpfc_xmt_que_size  = 256;
+int lpfc0_xmt_que_size  = -1;
+int lpfc1_xmt_que_size  = -1;
+int lpfc2_xmt_que_size  = -1;
+int lpfc3_xmt_que_size  = -1;
+int lpfc4_xmt_que_size  = -1;
+int lpfc5_xmt_que_size  = -1;
+int lpfc6_xmt_que_size  = -1;
+int lpfc7_xmt_que_size  = -1;
+int lpfc8_xmt_que_size  = -1;
+int lpfc9_xmt_que_size  = -1;
+int lpfc10_xmt_que_size = -1;
+int lpfc11_xmt_que_size = -1;
+int lpfc12_xmt_que_size = -1;
+int lpfc13_xmt_que_size = -1;
+int lpfc14_xmt_que_size = -1;
+int lpfc15_xmt_que_size = -1;
+int lpfc16_xmt_que_size = -1;
+int lpfc17_xmt_que_size = -1;
+int lpfc18_xmt_que_size = -1;
+int lpfc19_xmt_que_size = -1;
+int lpfc20_xmt_que_size = -1;
+int lpfc21_xmt_que_size = -1;
+int lpfc22_xmt_que_size = -1;
+int lpfc23_xmt_que_size = -1;
+int lpfc24_xmt_que_size = -1;
+int lpfc25_xmt_que_size = -1;
+int lpfc26_xmt_que_size = -1;
+int lpfc27_xmt_que_size = -1;
+int lpfc28_xmt_que_size = -1;
+int lpfc29_xmt_que_size = -1;
+int lpfc30_xmt_que_size = -1;
+int lpfc31_xmt_que_size = -1;
+
+/*
+# lpfc_linkdown_tmo: Determine how long the driver will wait to begin
+# linkdown processing when a cable has been pulled or the link has
+# otherwise become inaccessible.  Linkdown processing includes failing back 
+# cmds to the target driver that have been waiting around for the link
+# to come back up.  There's a tradeoff here:  small values of the timer
+# cause the link to appear to "bounce", while large values of the
+# timer can delay redundent HBA recovery in a fault tolerant environment.
+# Units are in seconds. A value of 0 means never failback cmds until the
+# link comes up. Value range is [0,255]. Default value is 30.
+*/
+int  lpfc_linkdown_tmo   = 30;
+int  lpfc0_linkdown_tmo  = -1;
+int  lpfc1_linkdown_tmo  = -1;
+int  lpfc2_linkdown_tmo  = -1;
+int  lpfc3_linkdown_tmo  = -1;
+int  lpfc4_linkdown_tmo  = -1;
+int  lpfc5_linkdown_tmo  = -1;
+int  lpfc6_linkdown_tmo  = -1;
+int  lpfc7_linkdown_tmo  = -1;
+int  lpfc8_linkdown_tmo  = -1;
+int  lpfc9_linkdown_tmo  = -1;
+int  lpfc10_linkdown_tmo = -1;
+int  lpfc11_linkdown_tmo = -1;
+int  lpfc12_linkdown_tmo = -1;
+int  lpfc13_linkdown_tmo = -1;
+int  lpfc14_linkdown_tmo = -1;
+int  lpfc15_linkdown_tmo = -1;
+int  lpfc16_linkdown_tmo = -1;
+int  lpfc17_linkdown_tmo = -1;
+int  lpfc18_linkdown_tmo = -1;
+int  lpfc19_linkdown_tmo = -1;
+int  lpfc20_linkdown_tmo = -1;
+int  lpfc21_linkdown_tmo = -1;
+int  lpfc22_linkdown_tmo = -1;
+int  lpfc23_linkdown_tmo = -1;
+int  lpfc24_linkdown_tmo = -1;
+int  lpfc25_linkdown_tmo = -1;
+int  lpfc26_linkdown_tmo = -1;
+int  lpfc27_linkdown_tmo = -1;
+int  lpfc28_linkdown_tmo = -1;
+int  lpfc29_linkdown_tmo = -1;
+int  lpfc30_linkdown_tmo = -1;
+int  lpfc31_linkdown_tmo = -1;
+
+/*
+# lpfc_nodev_holdio: If set, it will hold all I/O errors on devices that
+# disappear until they come back. Value range is [0,1].  Default value is 0.
+*/
+int  lpfc_nodev_holdio   =  0;
+int  lpfc0_nodev_holdio  = -1;
+int  lpfc1_nodev_holdio  = -1;
+int  lpfc2_nodev_holdio  = -1;
+int  lpfc3_nodev_holdio  = -1;
+int  lpfc4_nodev_holdio  = -1;
+int  lpfc5_nodev_holdio  = -1;
+int  lpfc6_nodev_holdio  = -1;
+int  lpfc7_nodev_holdio  = -1;
+int  lpfc8_nodev_holdio  = -1;
+int  lpfc9_nodev_holdio  = -1;
+int  lpfc10_nodev_holdio = -1;
+int  lpfc11_nodev_holdio = -1;
+int  lpfc12_nodev_holdio = -1;
+int  lpfc13_nodev_holdio = -1;
+int  lpfc14_nodev_holdio = -1;
+int  lpfc15_nodev_holdio = -1;
+int  lpfc16_nodev_holdio = -1;
+int  lpfc17_nodev_holdio = -1;
+int  lpfc18_nodev_holdio = -1;
+int  lpfc19_nodev_holdio = -1;
+int  lpfc20_nodev_holdio = -1;
+int  lpfc21_nodev_holdio = -1;
+int  lpfc22_nodev_holdio = -1;
+int  lpfc23_nodev_holdio = -1;
+int  lpfc24_nodev_holdio = -1;
+int  lpfc25_nodev_holdio = -1;
+int  lpfc26_nodev_holdio = -1;
+int  lpfc27_nodev_holdio = -1;
+int  lpfc28_nodev_holdio = -1;
+int  lpfc29_nodev_holdio = -1;
+int  lpfc30_nodev_holdio = -1;
+int  lpfc31_nodev_holdio = -1;
+
+/*
+# lpfc_nodev_tmo: If set, it will hold all I/O errors on devices that disappear
+# until the timer expires. Value range is [0,255]. Default value is 30.
+*/
+int  lpfc_nodev_tmo   = 30;
+int  lpfc0_nodev_tmo  = -1;
+int  lpfc1_nodev_tmo  = -1;
+int  lpfc2_nodev_tmo  = -1;
+int  lpfc3_nodev_tmo  = -1;
+int  lpfc4_nodev_tmo  = -1;
+int  lpfc5_nodev_tmo  = -1;
+int  lpfc6_nodev_tmo  = -1;
+int  lpfc7_nodev_tmo  = -1;
+int  lpfc8_nodev_tmo  = -1;
+int  lpfc9_nodev_tmo  = -1;
+int  lpfc10_nodev_tmo = -1;
+int  lpfc11_nodev_tmo = -1;
+int  lpfc12_nodev_tmo = -1;
+int  lpfc13_nodev_tmo = -1;
+int  lpfc14_nodev_tmo = -1;
+int  lpfc15_nodev_tmo = -1;
+int  lpfc16_nodev_tmo = -1;
+int  lpfc17_nodev_tmo = -1;
+int  lpfc18_nodev_tmo = -1;
+int  lpfc19_nodev_tmo = -1;
+int  lpfc20_nodev_tmo = -1;
+int  lpfc21_nodev_tmo = -1;
+int  lpfc22_nodev_tmo = -1;
+int  lpfc23_nodev_tmo = -1;
+int  lpfc24_nodev_tmo = -1;
+int  lpfc25_nodev_tmo = -1;
+int  lpfc26_nodev_tmo = -1;
+int  lpfc27_nodev_tmo = -1;
+int  lpfc28_nodev_tmo = -1;
+int  lpfc29_nodev_tmo = -1;
+int  lpfc30_nodev_tmo = -1;
+int  lpfc31_nodev_tmo = -1;
+
+/*
+# lpfc_delay_rsp_err: Use this to delay FCP RSP errors and certain check
+# conditions. Value range is [0,1]. Default value is 0.
+*/
+int lpfc_delay_rsp_err   =  0;
+int lpfc0_delay_rsp_err  = -1;
+int lpfc1_delay_rsp_err  = -1;
+int lpfc2_delay_rsp_err  = -1;
+int lpfc3_delay_rsp_err  = -1;
+int lpfc4_delay_rsp_err  = -1;
+int lpfc5_delay_rsp_err  = -1;
+int lpfc6_delay_rsp_err  = -1;
+int lpfc7_delay_rsp_err  = -1;
+int lpfc8_delay_rsp_err  = -1;
+int lpfc9_delay_rsp_err  = -1;
+int lpfc10_delay_rsp_err = -1;
+int lpfc11_delay_rsp_err = -1;
+int lpfc12_delay_rsp_err = -1;
+int lpfc13_delay_rsp_err = -1;
+int lpfc14_delay_rsp_err = -1;
+int lpfc15_delay_rsp_err = -1;
+int lpfc16_delay_rsp_err = -1;
+int lpfc17_delay_rsp_err = -1;
+int lpfc18_delay_rsp_err = -1;
+int lpfc19_delay_rsp_err = -1;
+int lpfc20_delay_rsp_err = -1;
+int lpfc21_delay_rsp_err = -1;
+int lpfc22_delay_rsp_err = -1;
+int lpfc23_delay_rsp_err = -1;
+int lpfc24_delay_rsp_err = -1;
+int lpfc25_delay_rsp_err = -1;
+int lpfc26_delay_rsp_err = -1;
+int lpfc27_delay_rsp_err = -1;
+int lpfc28_delay_rsp_err = -1;
+int lpfc29_delay_rsp_err = -1;
+int lpfc30_delay_rsp_err = -1;
+int lpfc31_delay_rsp_err = -1;
+
+/*
+# lpfc_check_cond_err: Treat certain check conditions as a FCP error. Value
+# range is [0,1]. Default value is 0.
+*/
+int lpfc_check_cond_err   =  0;
+int lpfc0_check_cond_err  = -1;
+int lpfc1_check_cond_err  = -1;
+int lpfc2_check_cond_err  = -1;
+int lpfc3_check_cond_err  = -1;
+int lpfc4_check_cond_err  = -1;
+int lpfc5_check_cond_err  = -1;
+int lpfc6_check_cond_err  = -1;
+int lpfc7_check_cond_err  = -1;
+int lpfc8_check_cond_err  = -1;
+int lpfc9_check_cond_err  = -1;
+int lpfc10_check_cond_err = -1;
+int lpfc11_check_cond_err = -1;
+int lpfc12_check_cond_err = -1;
+int lpfc13_check_cond_err = -1;
+int lpfc14_check_cond_err = -1;
+int lpfc15_check_cond_err = -1;
+int lpfc16_check_cond_err = -1;
+int lpfc17_check_cond_err = -1;
+int lpfc18_check_cond_err = -1;
+int lpfc19_check_cond_err = -1;
+int lpfc20_check_cond_err = -1;
+int lpfc21_check_cond_err = -1;
+int lpfc22_check_cond_err = -1;
+int lpfc23_check_cond_err = -1;
+int lpfc24_check_cond_err = -1;
+int lpfc25_check_cond_err = -1;
+int lpfc26_check_cond_err = -1;
+int lpfc27_check_cond_err = -1;
+int lpfc28_check_cond_err = -1;
+int lpfc29_check_cond_err = -1;
+int lpfc30_check_cond_err = -1;
+int lpfc31_check_cond_err = -1;
+
+/*
+# lpfc_topology:  link topology for init link
+#            0x0  = attempt loop mode then point-to-point
+#            0x02 = attempt point-to-point mode only
+#            0x04 = attempt loop mode only 
+#            0x06 = attempt point-to-point mode then loop
+# Set point-to-point mode if you want to run as an N_Port.
+# Set loop mode if you want to run as an NL_Port. Value range is [0,0x6].
+# Default value is 0.
+*/
+int lpfc_topology   =   0x0;
+int lpfc0_topology  =  -1;
+int lpfc1_topology  =  -1;
+int lpfc2_topology  =  -1;
+int lpfc3_topology  =  -1;
+int lpfc4_topology  =  -1;
+int lpfc5_topology  =  -1;
+int lpfc6_topology  =  -1;
+int lpfc7_topology  =  -1;
+int lpfc8_topology  =  -1;
+int lpfc9_topology  =  -1;
+int lpfc10_topology =  -1;
+int lpfc11_topology =  -1;
+int lpfc12_topology =  -1;
+int lpfc13_topology =  -1;
+int lpfc14_topology =  -1;
+int lpfc15_topology =  -1;
+int lpfc16_topology =  -1;
+int lpfc17_topology =  -1;
+int lpfc18_topology =  -1;
+int lpfc19_topology =  -1;
+int lpfc20_topology =  -1;
+int lpfc21_topology =  -1;
+int lpfc22_topology =  -1;
+int lpfc23_topology =  -1;
+int lpfc24_topology =  -1;
+int lpfc25_topology =  -1;
+int lpfc26_topology =  -1;
+int lpfc27_topology =  -1;
+int lpfc28_topology =  -1;
+int lpfc29_topology =  -1;
+int lpfc30_topology =  -1;
+int lpfc31_topology =  -1;
+
+/*
+# lpfc_link_speed: Link speed selection for initializing the Fibre Channel
+# connection.
+#       0 = auto select (default)
+#       1 = 1 Gigabaud
+#       2 = 2 Gigabaud
+#       4 = 4 Gigabaud
+# Value range is [0,4]. Default value is 0.
+*/
+int  lpfc_link_speed   =  0;
+int  lpfc0_link_speed  = -1;
+int  lpfc1_link_speed  = -1;
+int  lpfc2_link_speed  = -1;
+int  lpfc3_link_speed  = -1;
+int  lpfc4_link_speed  = -1;
+int  lpfc5_link_speed  = -1;
+int  lpfc6_link_speed  = -1;
+int  lpfc7_link_speed  = -1;
+int  lpfc8_link_speed  = -1;
+int  lpfc9_link_speed  = -1;
+int  lpfc10_link_speed = -1;
+int  lpfc11_link_speed = -1;
+int  lpfc12_link_speed = -1;
+int  lpfc13_link_speed = -1;
+int  lpfc14_link_speed = -1;
+int  lpfc15_link_speed = -1;
+int  lpfc16_link_speed = -1;
+int  lpfc17_link_speed = -1;
+int  lpfc18_link_speed = -1;
+int  lpfc19_link_speed = -1;
+int  lpfc20_link_speed = -1;
+int  lpfc21_link_speed = -1;
+int  lpfc22_link_speed = -1;
+int  lpfc23_link_speed = -1;
+int  lpfc24_link_speed = -1;
+int  lpfc25_link_speed = -1;
+int  lpfc26_link_speed = -1;
+int  lpfc27_link_speed = -1;
+int  lpfc28_link_speed = -1;
+int  lpfc29_link_speed = -1;
+int  lpfc30_link_speed = -1;
+int  lpfc31_link_speed = -1;
+
+/*
+# lpfc_fcp_class:  Determines FC class to use for the FCP protocol.
+# Value range is [2,3]. Default value is 3.
+*/
+int lpfc_fcp_class   =  3;
+int lpfc0_fcp_class  = -1;
+int lpfc1_fcp_class  = -1;
+int lpfc2_fcp_class  = -1;
+int lpfc3_fcp_class  = -1;
+int lpfc4_fcp_class  = -1;
+int lpfc5_fcp_class  = -1;
+int lpfc6_fcp_class  = -1;
+int lpfc7_fcp_class  = -1;
+int lpfc8_fcp_class  = -1;
+int lpfc9_fcp_class  = -1;
+int lpfc10_fcp_class = -1;
+int lpfc11_fcp_class = -1;
+int lpfc12_fcp_class = -1;
+int lpfc13_fcp_class = -1;
+int lpfc14_fcp_class = -1;
+int lpfc15_fcp_class = -1;
+int lpfc16_fcp_class = -1;
+int lpfc17_fcp_class = -1;
+int lpfc18_fcp_class = -1;
+int lpfc19_fcp_class = -1;
+int lpfc20_fcp_class = -1;
+int lpfc21_fcp_class = -1;
+int lpfc22_fcp_class = -1;
+int lpfc23_fcp_class = -1;
+int lpfc24_fcp_class = -1;
+int lpfc25_fcp_class = -1;
+int lpfc26_fcp_class = -1;
+int lpfc27_fcp_class = -1;
+int lpfc28_fcp_class = -1;
+int lpfc29_fcp_class = -1;
+int lpfc30_fcp_class = -1;
+int lpfc31_fcp_class = -1;
+
+/*
+# lpfc_use_adisc: Use ADISC for FCP rediscovery instead of PLOGI. Value range
+# is [0,1]. Default value is 0.
+*/
+int  lpfc_use_adisc   =  0;
+int  lpfc0_use_adisc  = -1; 
+int  lpfc1_use_adisc  = -1; 
+int  lpfc2_use_adisc  = -1; 
+int  lpfc3_use_adisc  = -1; 
+int  lpfc4_use_adisc  = -1; 
+int  lpfc5_use_adisc  = -1; 
+int  lpfc6_use_adisc  = -1; 
+int  lpfc7_use_adisc  = -1; 
+int  lpfc8_use_adisc  = -1; 
+int  lpfc9_use_adisc  = -1; 
+int  lpfc10_use_adisc = -1; 
+int  lpfc11_use_adisc = -1; 
+int  lpfc12_use_adisc = -1; 
+int  lpfc13_use_adisc = -1; 
+int  lpfc14_use_adisc = -1; 
+int  lpfc15_use_adisc = -1; 
+int  lpfc16_use_adisc = -1; 
+int  lpfc17_use_adisc = -1; 
+int  lpfc18_use_adisc = -1; 
+int  lpfc19_use_adisc = -1; 
+int  lpfc20_use_adisc = -1; 
+int  lpfc21_use_adisc = -1; 
+int  lpfc22_use_adisc = -1; 
+int  lpfc23_use_adisc = -1; 
+int  lpfc24_use_adisc = -1; 
+int  lpfc25_use_adisc = -1; 
+int  lpfc26_use_adisc = -1; 
+int  lpfc27_use_adisc = -1; 
+int  lpfc28_use_adisc = -1; 
+int  lpfc29_use_adisc = -1; 
+int  lpfc30_use_adisc = -1; 
+int  lpfc31_use_adisc = -1; 
+
+/*
+# lpfc_extra_io_tmo: Extra FCP timeout for fabrics. Value range is [0,255].
+# Default value is 0.
+*/
+int  lpfc_extra_io_tmo   =  0;
+int  lpfc0_extra_io_tmo  = -1;
+int  lpfc1_extra_io_tmo  = -1;
+int  lpfc2_extra_io_tmo  = -1;
+int  lpfc3_extra_io_tmo  = -1;
+int  lpfc4_extra_io_tmo  = -1;
+int  lpfc5_extra_io_tmo  = -1;
+int  lpfc6_extra_io_tmo  = -1;
+int  lpfc7_extra_io_tmo  = -1;
+int  lpfc8_extra_io_tmo  = -1;
+int  lpfc9_extra_io_tmo  = -1;
+int  lpfc10_extra_io_tmo = -1;
+int  lpfc11_extra_io_tmo = -1;
+int  lpfc12_extra_io_tmo = -1;
+int  lpfc13_extra_io_tmo = -1;
+int  lpfc14_extra_io_tmo = -1;
+int  lpfc15_extra_io_tmo = -1;
+int  lpfc16_extra_io_tmo = -1;
+int  lpfc17_extra_io_tmo = -1;
+int  lpfc18_extra_io_tmo = -1;
+int  lpfc19_extra_io_tmo = -1;
+int  lpfc20_extra_io_tmo = -1;
+int  lpfc21_extra_io_tmo = -1;
+int  lpfc22_extra_io_tmo = -1;
+int  lpfc23_extra_io_tmo = -1;
+int  lpfc24_extra_io_tmo = -1;
+int  lpfc25_extra_io_tmo = -1;
+int  lpfc26_extra_io_tmo = -1;
+int  lpfc27_extra_io_tmo = -1;
+int  lpfc28_extra_io_tmo = -1;
+int  lpfc29_extra_io_tmo = -1;
+int  lpfc30_extra_io_tmo = -1;
+int  lpfc31_extra_io_tmo = -1;
+
+/*
+# lpfc_dqfull_throttle_up_time: Use dqfull-throttle-up-time to specify when to
+# increment the current Q depth. This variable is in seconds. Value range
+# is [0,30]. Default value is 1.
+*/
+int lpfc_dqfull_throttle_up_time   =  1;
+int lpfc0_dqfull_throttle_up_time  = -1;
+int lpfc1_dqfull_throttle_up_time  = -1;
+int lpfc2_dqfull_throttle_up_time  = -1;
+int lpfc3_dqfull_throttle_up_time  = -1;
+int lpfc4_dqfull_throttle_up_time  = -1;
+int lpfc5_dqfull_throttle_up_time  = -1;
+int lpfc6_dqfull_throttle_up_time  = -1;
+int lpfc7_dqfull_throttle_up_time  = -1;
+int lpfc8_dqfull_throttle_up_time  = -1;
+int lpfc9_dqfull_throttle_up_time  = -1;
+int lpfc10_dqfull_throttle_up_time = -1;
+int lpfc11_dqfull_throttle_up_time = -1;
+int lpfc12_dqfull_throttle_up_time = -1;
+int lpfc13_dqfull_throttle_up_time = -1;
+int lpfc14_dqfull_throttle_up_time = -1;
+int lpfc15_dqfull_throttle_up_time = -1;
+int lpfc16_dqfull_throttle_up_time = -1;
+int lpfc17_dqfull_throttle_up_time = -1;
+int lpfc18_dqfull_throttle_up_time = -1;
+int lpfc19_dqfull_throttle_up_time = -1;
+int lpfc20_dqfull_throttle_up_time = -1;
+int lpfc21_dqfull_throttle_up_time = -1;
+int lpfc22_dqfull_throttle_up_time = -1;
+int lpfc23_dqfull_throttle_up_time = -1;
+int lpfc24_dqfull_throttle_up_time = -1;
+int lpfc25_dqfull_throttle_up_time = -1;
+int lpfc26_dqfull_throttle_up_time = -1;
+int lpfc27_dqfull_throttle_up_time = -1;
+int lpfc28_dqfull_throttle_up_time = -1;
+int lpfc29_dqfull_throttle_up_time = -1;
+int lpfc30_dqfull_throttle_up_time = -1;
+int lpfc31_dqfull_throttle_up_time = -1;
+
+/*
+# lpfc_dqfull_throttle_up_inc: Increment the current Q depth by 
+# dqfull-throttle-up-inc. Value range is [0,128]. Default value is 1.
+*/
+int lpfc_dqfull_throttle_up_inc   =  1;
+int lpfc0_dqfull_throttle_up_inc  = -1;
+int lpfc1_dqfull_throttle_up_inc  = -1;
+int lpfc2_dqfull_throttle_up_inc  = -1;
+int lpfc3_dqfull_throttle_up_inc  = -1;
+int lpfc4_dqfull_throttle_up_inc  = -1;
+int lpfc5_dqfull_throttle_up_inc  = -1;
+int lpfc6_dqfull_throttle_up_inc  = -1;
+int lpfc7_dqfull_throttle_up_inc  = -1;
+int lpfc8_dqfull_throttle_up_inc  = -1;
+int lpfc9_dqfull_throttle_up_inc  = -1;
+int lpfc10_dqfull_throttle_up_inc = -1;
+int lpfc11_dqfull_throttle_up_inc = -1;
+int lpfc12_dqfull_throttle_up_inc = -1;
+int lpfc13_dqfull_throttle_up_inc = -1;
+int lpfc14_dqfull_throttle_up_inc = -1;
+int lpfc15_dqfull_throttle_up_inc = -1;
+int lpfc16_dqfull_throttle_up_inc = -1;
+int lpfc17_dqfull_throttle_up_inc = -1;
+int lpfc18_dqfull_throttle_up_inc = -1;
+int lpfc19_dqfull_throttle_up_inc = -1;
+int lpfc20_dqfull_throttle_up_inc = -1;
+int lpfc21_dqfull_throttle_up_inc = -1;
+int lpfc22_dqfull_throttle_up_inc = -1;
+int lpfc23_dqfull_throttle_up_inc = -1;
+int lpfc24_dqfull_throttle_up_inc = -1;
+int lpfc25_dqfull_throttle_up_inc = -1;
+int lpfc26_dqfull_throttle_up_inc = -1;
+int lpfc27_dqfull_throttle_up_inc = -1;
+int lpfc28_dqfull_throttle_up_inc = -1;
+int lpfc29_dqfull_throttle_up_inc = -1;
+int lpfc30_dqfull_throttle_up_inc = -1;
+int lpfc31_dqfull_throttle_up_inc = -1;
+
+/*
+# lpfc_ack0: Use ACK0, instead of ACK1 for class 2 acknowledgement. Value
+# range is [0,1]. Default value is 0.
+*/
+int  lpfc_ack0   =  0;
+int  lpfc0_ack0  = -1;
+int  lpfc1_ack0  = -1;
+int  lpfc2_ack0  = -1;
+int  lpfc3_ack0  = -1;
+int  lpfc4_ack0  = -1;
+int  lpfc5_ack0  = -1;
+int  lpfc6_ack0  = -1;
+int  lpfc7_ack0  = -1;
+int  lpfc8_ack0  = -1;
+int  lpfc9_ack0  = -1;
+int  lpfc10_ack0 = -1;
+int  lpfc11_ack0 = -1;
+int  lpfc12_ack0 = -1;
+int  lpfc13_ack0 = -1;
+int  lpfc14_ack0 = -1;
+int  lpfc15_ack0 = -1;
+int  lpfc16_ack0 = -1;
+int  lpfc17_ack0 = -1;
+int  lpfc18_ack0 = -1;
+int  lpfc19_ack0 = -1;
+int  lpfc20_ack0 = -1;
+int  lpfc21_ack0 = -1;
+int  lpfc22_ack0 = -1;
+int  lpfc23_ack0 = -1;
+int  lpfc24_ack0 = -1;
+int  lpfc25_ack0 = -1;
+int  lpfc26_ack0 = -1;
+int  lpfc27_ack0 = -1;
+int  lpfc28_ack0 = -1;
+int  lpfc29_ack0 = -1;
+int  lpfc30_ack0 = -1;
+int  lpfc31_ack0 = -1;
+
+/* 
+# lpfc_cr_delay & lpfc_cr_count: Default values for I/O coalescing 
+# cr_delay (msec) or cr_count outstanding commands. cr_delay can take
+# value [0,63]. cr_count can take value [1,255]. Default value of cr_delay
+# is 0. Default value of cr_count is 1. The cr_count feature is disabled if
+# cr_delay is set to 0.
+*/
+int  lpfc_cr_delay   =  0;
+int  lpfc0_cr_delay  = -1;
+int  lpfc1_cr_delay  = -1;
+int  lpfc2_cr_delay  = -1;
+int  lpfc3_cr_delay  = -1;
+int  lpfc4_cr_delay  = -1;
+int  lpfc5_cr_delay  = -1;
+int  lpfc6_cr_delay  = -1;
+int  lpfc7_cr_delay  = -1;
+int  lpfc8_cr_delay  = -1;
+int  lpfc9_cr_delay  = -1;
+int  lpfc10_cr_delay = -1;
+int  lpfc11_cr_delay = -1;
+int  lpfc12_cr_delay = -1;
+int  lpfc13_cr_delay = -1;
+int  lpfc14_cr_delay = -1;
+int  lpfc15_cr_delay = -1;
+int  lpfc16_cr_delay = -1;
+int  lpfc17_cr_delay = -1;
+int  lpfc18_cr_delay = -1;
+int  lpfc19_cr_delay = -1;
+int  lpfc20_cr_delay = -1;
+int  lpfc21_cr_delay = -1;
+int  lpfc22_cr_delay = -1;
+int  lpfc23_cr_delay = -1;
+int  lpfc24_cr_delay = -1;
+int  lpfc25_cr_delay = -1;
+int  lpfc26_cr_delay = -1;
+int  lpfc27_cr_delay = -1;
+int  lpfc28_cr_delay = -1;
+int  lpfc29_cr_delay = -1;
+int  lpfc30_cr_delay = -1;
+int  lpfc31_cr_delay = -1;
+
+int  lpfc_cr_count   =  1;
+int  lpfc0_cr_count  = -1;
+int  lpfc1_cr_count  = -1;
+int  lpfc2_cr_count  = -1;
+int  lpfc3_cr_count  = -1;
+int  lpfc4_cr_count  = -1;
+int  lpfc5_cr_count  = -1;
+int  lpfc6_cr_count  = -1;
+int  lpfc7_cr_count  = -1;
+int  lpfc8_cr_count  = -1;
+int  lpfc9_cr_count  = -1;
+int  lpfc10_cr_count = -1;
+int  lpfc11_cr_count = -1;
+int  lpfc12_cr_count = -1;
+int  lpfc13_cr_count = -1;
+int  lpfc14_cr_count = -1;
+int  lpfc15_cr_count = -1;
+int  lpfc16_cr_count = -1;
+int  lpfc17_cr_count = -1;
+int  lpfc18_cr_count = -1;
+int  lpfc19_cr_count = -1;
+int  lpfc20_cr_count = -1;
+int  lpfc21_cr_count = -1;
+int  lpfc22_cr_count = -1;
+int  lpfc23_cr_count = -1;
+int  lpfc24_cr_count = -1;
+int  lpfc25_cr_count = -1;
+int  lpfc26_cr_count = -1;
+int  lpfc27_cr_count = -1;
+int  lpfc28_cr_count = -1;
+int  lpfc29_cr_count = -1;
+int  lpfc30_cr_count = -1;
+int  lpfc31_cr_count = -1;
+
+/*
+# lpfc_fdmi_on: controls FDMI support.
+# 	0 = no FDMI support
+#	1 = support FDMI without attribute of hostname
+#	2 = support FDMI with attribute of hostname
+# Value range [0,2]. Default value is 0.
+*/
+int  lpfc_fdmi_on   =  0;
+int  lpfc0_fdmi_on  = -1;
+int  lpfc1_fdmi_on  = -1;
+int  lpfc2_fdmi_on  = -1;
+int  lpfc3_fdmi_on  = -1;
+int  lpfc4_fdmi_on  = -1;
+int  lpfc5_fdmi_on  = -1;
+int  lpfc6_fdmi_on  = -1;
+int  lpfc7_fdmi_on  = -1;
+int  lpfc8_fdmi_on  = -1;
+int  lpfc9_fdmi_on  = -1;
+int  lpfc10_fdmi_on = -1;
+int  lpfc11_fdmi_on = -1;
+int  lpfc12_fdmi_on = -1;
+int  lpfc13_fdmi_on = -1;
+int  lpfc14_fdmi_on = -1;
+int  lpfc15_fdmi_on = -1;
+int  lpfc16_fdmi_on = -1;
+int  lpfc17_fdmi_on = -1;
+int  lpfc18_fdmi_on = -1;
+int  lpfc19_fdmi_on = -1;
+int  lpfc20_fdmi_on = -1;
+int  lpfc21_fdmi_on = -1;
+int  lpfc22_fdmi_on = -1;
+int  lpfc23_fdmi_on = -1;
+int  lpfc24_fdmi_on = -1;
+int  lpfc25_fdmi_on = -1;
+int  lpfc26_fdmi_on = -1;
+int  lpfc27_fdmi_on = -1;
+int  lpfc28_fdmi_on = -1;
+int  lpfc29_fdmi_on = -1;
+int  lpfc30_fdmi_on = -1;
+int  lpfc31_fdmi_on = -1;
+
+/*
+# lpfc_scsi_req_tmo: Time out value (in seconds) for SCSI request sent. 
+# Value range is [0,255]. Default value is 30.
+*/
+int  lpfc_scsi_req_tmo   = 30;
+int  lpfc0_scsi_req_tmo  = -1;
+int  lpfc1_scsi_req_tmo  = -1;
+int  lpfc2_scsi_req_tmo  = -1;
+int  lpfc3_scsi_req_tmo  = -1;
+int  lpfc4_scsi_req_tmo  = -1;
+int  lpfc5_scsi_req_tmo  = -1;
+int  lpfc6_scsi_req_tmo  = -1;
+int  lpfc7_scsi_req_tmo  = -1;
+int  lpfc8_scsi_req_tmo  = -1;
+int  lpfc9_scsi_req_tmo  = -1;
+int  lpfc10_scsi_req_tmo = -1;
+int  lpfc11_scsi_req_tmo = -1;
+int  lpfc12_scsi_req_tmo = -1;
+int  lpfc13_scsi_req_tmo = -1;
+int  lpfc14_scsi_req_tmo = -1;
+int  lpfc15_scsi_req_tmo = -1;
+int  lpfc16_scsi_req_tmo = -1;
+int  lpfc17_scsi_req_tmo = -1;
+int  lpfc18_scsi_req_tmo = -1;
+int  lpfc19_scsi_req_tmo = -1;
+int  lpfc20_scsi_req_tmo = -1;
+int  lpfc21_scsi_req_tmo = -1;
+int  lpfc22_scsi_req_tmo = -1;
+int  lpfc23_scsi_req_tmo = -1;
+int  lpfc24_scsi_req_tmo = -1;
+int  lpfc25_scsi_req_tmo = -1;
+int  lpfc26_scsi_req_tmo = -1;
+int  lpfc27_scsi_req_tmo = -1;
+int  lpfc28_scsi_req_tmo = -1;
+int  lpfc29_scsi_req_tmo = -1;
+int  lpfc30_scsi_req_tmo = -1;
+int  lpfc31_scsi_req_tmo = -1;
+
+/*
+# lpfc_lun_skip : If this is set to 1, lpfc will fake out the LINUX scsi layer
+# to allow it to detect all LUNs if there are LUN holes on a device.
+*/
+int  lpfc_lun_skip     = 0;
+int  lpfc0_lun_skip    = -1;
+int  lpfc1_lun_skip    = -1;
+int  lpfc2_lun_skip    = -1;
+int  lpfc3_lun_skip    = -1;
+int  lpfc4_lun_skip    = -1;
+int  lpfc5_lun_skip    = -1;
+int  lpfc6_lun_skip    = -1;
+int  lpfc7_lun_skip    = -1;
+int  lpfc8_lun_skip    = -1;
+int  lpfc9_lun_skip    = -1;
+int  lpfc10_lun_skip   = -1;
+int  lpfc11_lun_skip   = -1;
+int  lpfc12_lun_skip   = -1;
+int  lpfc13_lun_skip   = -1;
+int  lpfc14_lun_skip   = -1;
+int  lpfc15_lun_skip   = -1;
+int  lpfc16_lun_skip   = -1;
+int  lpfc17_lun_skip   = -1;
+int  lpfc18_lun_skip   = -1;
+int  lpfc19_lun_skip   = -1;
+int  lpfc20_lun_skip   = -1;
+int  lpfc21_lun_skip   = -1;
+int  lpfc22_lun_skip   = -1;
+int  lpfc23_lun_skip   = -1;
+int  lpfc24_lun_skip   = -1;
+int  lpfc25_lun_skip   = -1;
+int  lpfc26_lun_skip   = -1;
+int  lpfc27_lun_skip   = -1;
+int  lpfc28_lun_skip   = -1;
+int  lpfc29_lun_skip   = -1;
+int  lpfc30_lun_skip   = -1;
+int  lpfc31_lun_skip   = -1;
+
+/*
+# lpfc_inq_pqb_filter : Some distributions does not handle peripheral qualifier
+# bit in the INQUIRY response set to 1. If this parameter is set, lpfc
+# driver will change the peripheral qualifier bit from 1 to 3 for INQUIRY 
+# responses.
+*/
+int lpfc_inq_pqb_filter = 0;
+
+#endif
diff -urNp linux-8152/drivers/addon/lpfc/lpfc.h linux-8155/drivers/addon/lpfc/lpfc.h
--- linux-8152/drivers/addon/lpfc/lpfc.h
+++ linux-8155/drivers/addon/lpfc/lpfc.h
@@ -0,0 +1,517 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc.h 483 2006-03-22 00:27:31Z sf_support $
+ */
+
+#ifndef _H_LPFC
+#define _H_LPFC
+
+#include <linux/interrupt.h>
+
+#include "lpfc_hw.h"
+#include "lpfc_sli.h"
+#include "lpfc_scsi.h"
+#include "lpfc_disc.h"
+#include "lpfc_mem.h"
+
+#ifndef TRUE
+#define TRUE    1
+#endif
+#ifndef FALSE
+#define FALSE   0
+#endif
+
+/* Define the SLIM2 page size. */
+#define LPFC_SLIM2_PAGE_AREA  8192
+
+/* Define macros for handling the driver lock. */
+#define LPFC_DRVR_LOCK(phba, flag)   lpfc_drvr_lock(phba, &flag)
+#define LPFC_DRVR_UNLOCK(phba, flag) lpfc_drvr_unlock(phba, &flag)
+
+/* Define macros for 64 bit support */
+#define putPaddrLow(addr)    ((uint32_t) (0xffffffff & (u64)(addr)))
+#define putPaddrHigh(addr)   ((uint32_t) (0xffffffff & (((u64)(addr))>>32)))
+#define getPaddr(high, low)  ((dma_addr_t)( \
+			     (( (u64)(high)<<16 ) << 16)|( (u64)(low))))
+
+/* Provide maximum configuration definitions. */
+#define LPFC_DRVR_TIMEOUT   16		/* driver iocb timeout value in sec. */
+#define MAX_FC_BINDINGS    64		/* max number of persistent bindings */
+#define MAX_FCP_TARGET     256		/* max number of FCP targets supported */
+#define MAX_FCP_LUN        255		/* max lun number supported */
+#define MAX_FCP_CMDS       16384	/* max number of FCP cmds supported */
+#define FC_MAX_ADPTMSG     64
+
+#define MAX_HBAEVT 32
+/***************************************************************************/
+/*
+ * This is the global device driver control structure
+ */
+/***************************************************************************/
+
+struct lpfc_drvr {
+	unsigned long loadtime;
+	struct list_head hba_list_head;
+	uint16_t num_devs;	/* count of devices configed */
+};
+typedef struct lpfc_drvr lpfcDRVR_t;
+
+#if __LITTLE_ENDIAN
+
+#define putLunLow(lunlow, lun)              \
+   {                                        \
+   lunlow = 0;                              \
+   }
+
+#define putLunHigh(lunhigh, lun)            \
+   {                                        \
+   lunhigh = (uint32_t)(lun << 8);          \
+   }
+
+#else				/* BIG_ENDIAN_HOST */
+
+#define putLunLow(lunlow, lun)              \
+   {                                        \
+   lunlow = 0;                              \
+   }
+
+#define putLunHigh(lunhigh, lun)            \
+   {                                        \
+   lunhigh = (uint32_t)(lun << 16);         \
+   }
+#endif
+
+#define SWAP_ALWAYS(x)  ((((x) & 0xFF)<<24) | (((x) & 0xFF00)<<8) | \
+			(((x) & 0xFF0000)>>8) | (((x) & 0xFF000000)>>24))
+
+#define SWAP_ALWAYS16(x) ((((x) & 0xFF) << 8) | ((x) >> 8))
+
+/****************************************************************************/
+/*      Device VPD save area                                                */
+/****************************************************************************/
+typedef struct lpfc_vpd {
+	uint32_t status;	/* vpd status value */
+	uint32_t length;	/* number of bytes actually returned */
+	struct {
+		uint32_t rsvd1;	/* Revision numbers */
+		uint32_t biuRev;
+		uint32_t smRev;
+		uint32_t smFwRev;
+		uint32_t endecRev;
+		uint16_t rBit;
+		uint8_t fcphHigh;
+		uint8_t fcphLow;
+		uint8_t feaLevelHigh;
+		uint8_t feaLevelLow;
+		uint32_t postKernRev;
+		uint32_t opFwRev;
+		uint8_t opFwName[16];
+		uint32_t sli1FwRev;
+		uint8_t sli1FwName[16];
+		uint32_t sli2FwRev;
+		uint8_t sli2FwName[16];
+	} rev;
+} lpfc_vpd_t;
+
+typedef struct lpfc_cfgparam {
+	char *a_string;
+	uint32_t a_low;
+	uint32_t a_hi;
+	uint32_t a_default;
+	uint32_t a_current;
+	uint16_t a_flag;
+	uint16_t a_changestate;
+	char *a_help;
+} lpfcCfgParam_t;
+
+struct lpfcScsiLun;
+struct lpfc_scsi_buf;
+
+/* This should correspond with the HBA API event structure */
+typedef struct hbaevt {
+	uint32_t fc_eventcode;
+	uint32_t fc_evdata1;
+	uint32_t fc_evdata2;
+	uint32_t fc_evdata3;
+	uint32_t fc_evdata4;
+} HBAEVT_t;
+
+/*
+ * lpfc stat counters
+ */
+struct lpfc_stats {
+	/* Statistics for ELS commands */
+	uint32_t elsLogiCol;
+	uint32_t elsRetryExceeded;
+	uint32_t elsXmitRetry;
+	uint32_t elsDelayRetry;
+	uint32_t elsRcvDrop;
+	uint32_t elsRcvFrame;
+	uint32_t elsRcvRSCN;
+	uint32_t elsRcvRNID;
+	uint32_t elsRcvFARP;
+	uint32_t elsRcvFARPR;
+	uint32_t elsRcvFLOGI;
+	uint32_t elsRcvPLOGI;
+	uint32_t elsRcvADISC;
+	uint32_t elsRcvPDISC;
+	uint32_t elsRcvFAN;
+	uint32_t elsRcvLOGO;
+	uint32_t elsRcvPRLO;
+	uint32_t elsRcvPRLI;
+	uint32_t elsRcvRRQ;
+	uint32_t elsXmitFLOGI;
+	uint32_t elsXmitPLOGI;
+	uint32_t elsXmitPRLI;
+	uint32_t elsXmitADISC;
+	uint32_t elsXmitLOGO;
+	uint32_t elsXmitSCR;
+	uint32_t elsXmitRNID;
+	uint32_t elsXmitFARP;
+	uint32_t elsXmitFARPR;
+	uint32_t elsXmitACC;
+	uint32_t elsXmitLSRJT;
+
+	uint32_t frameRcvBcast;
+	uint32_t frameRcvMulti;
+	uint32_t strayXmitCmpl;
+	uint32_t frameXmitDelay;
+	uint32_t xriCmdCmpl;
+	uint32_t xriStatErr;
+	uint32_t LinkUp;
+	uint32_t LinkDown;
+	uint32_t LinkMultiEvent;
+	uint32_t NoRcvBuf;
+	uint32_t fcpCmd;
+	uint32_t fcpCmpl;
+	uint32_t fcpRspErr;
+	uint32_t fcpRemoteStop;
+	uint32_t fcpPortRjt;
+	uint32_t fcpPortBusy;
+	uint32_t fcpError;
+	uint32_t fcpLocalErr;
+};
+typedef struct lpfc_stats LPFC_STAT_t;
+
+typedef struct lpfcHBA {
+	uint8_t intr_inited;		/* flag for interrupt registration */
+	uint8_t no_timer;
+	struct list_head hba_list;	/* List of hbas/ports */      
+	uint32_t hba_flag;		/* device flags */
+#define FC_SCHED_CFG_INIT   0x2		/* schedule a call to fc_cfg_init() */
+#define FC_STOP_IO          0x8		/* set for offline call */
+#define FC_POLL_CMD         0x10	/* indicate to poll for command
+					   completion */
+#define FC_LFR_ACTIVE       0x20	/* Link Failure recovery activated */
+#define FC_NDISC_ACTIVE     0x40	/* Node discovery mode activated */
+
+	struct lpfc_sli sli;
+	DMABUF_t slim2p;
+	uint32_t slim_size;
+
+	uint32_t hba_state;
+
+#define LPFC_INIT_START           1	/* Initial state after board reset */
+#define LPFC_INIT_MBX_CMDS        2	/* Initialize HBA with mbox commands */
+#define LPFC_LINK_DOWN            3	/* HBA initialized, link is down */
+#define LPFC_LINK_UP              4	/* Link is up  - issue READ_LA */
+#define LPFC_LOCAL_CFG_LINK       5	/* local NPORT Id configured */
+#define LPFC_FLOGI                6	/* FLOGI sent to Fabric */
+#define LPFC_FABRIC_CFG_LINK      7	/* Fabric assigned NPORT Id
+					   configured */
+#define LPFC_NS_REG               8	/* Register with NameServer */
+#define LPFC_NS_QRY               9	/* Query NameServer for NPort ID list */
+#define LPFC_BUILD_DISC_LIST      10	/* Build ADISC and PLOGI lists for
+					 * device authentication / discovery */
+#define LPFC_DISC_AUTH            11	/* Processing ADISC list */
+#define LPFC_CLEAR_LA             12	/* authentication cmplt - issue
+					   CLEAR_LA */
+#define LPFC_HBA_READY            32
+#define LPFC_HBA_ERROR            0xff
+
+	int32_t stopped;   /* HBA has not been restarted since last ERATT */
+	uint8_t fc_linkspeed;	/* Link speed after last READ_LA */
+
+	uint32_t fc_eventTag;	/* event tag for link attention */
+	uint32_t fc_prli_sent;	/* cntr for outstanding PRLIs */
+	uint8_t phys_addr[8];	/* actual network address in use */
+
+	uint32_t disc_state;	/*in addition to hba_state */
+	uint32_t num_disc_nodes;	/*in addition to hba_state */
+
+	uint8_t fcp_mapping;	/* Map FCP devices based on WWNN WWPN or DID */
+#define FCP_SEED_WWNN   0x1
+#define FCP_SEED_WWPN   0x2
+#define FCP_SEED_DID    0x4
+#define FCP_SEED_MASK   0x7
+#define FCP_SEED_AUTO   0x8	/* binding was created by auto mapping */
+
+	struct timer_list fc_estabtmo;	/* link establishment timer */
+	struct timer_list fc_disctmo;	/* Discovery rescue timer */
+	struct timer_list fc_linkdown;	/* link down timer */
+	struct timer_list fc_fdmitmo;	/* fdmi timer */
+
+
+	void *fc_evt_head;	/* waiting for event queue */
+	void *fc_evt_tail;	/* waiting for event queue */
+
+	uint16_t hba_event_put;	/* hbaevent event put word anchor */
+	uint16_t hba_event_get;	/* hbaevent event get word anchor */
+	uint32_t hba_event_missed;	/* hbaevent missed event word anchor */
+	uint32_t sid_cnt;	/* SCSI ID counter */
+
+	HBAEVT_t hbaevt[MAX_HBAEVT];
+
+#define FC_CPQ_LUNMAP   0x1	/* SCSI passthru interface LUN 0 mapping */
+
+	/* These fields used to be binfo */
+	NAME_TYPE fc_nodename;	/* fc nodename */
+	NAME_TYPE fc_portname;	/* fc portname */
+	uint32_t fc_pref_DID;	/* preferred D_ID */
+	uint8_t fc_pref_ALPA;	/* preferred AL_PA */
+	uint8_t fc_deferip;	/* defer IP processing */
+	uint8_t ipAddr[16];	/* For RNID support */
+	uint16_t ipVersion;	/* For RNID support */
+	uint16_t UDPport;	/* For RNID support */
+	uint32_t fc_edtov;	/* E_D_TOV timer value */
+	uint32_t fc_arbtov;	/* ARB_TOV timer value */
+	uint32_t fc_ratov;	/* R_A_TOV timer value */
+	uint32_t fc_rttov;	/* R_T_TOV timer value */
+	uint32_t fc_altov;	/* AL_TOV timer value */
+	uint32_t fc_crtov;	/* C_R_TOV timer value */
+	uint32_t fc_citov;	/* C_I_TOV timer value */
+	uint32_t fc_myDID;	/* fibre channel S_ID */
+	uint32_t fc_prevDID;	/* previous fibre channel S_ID */
+
+	SERV_PARM fc_sparam;	/* buffer for our service parameters */
+	SERV_PARM fc_fabparam;	/* fabric service parameters buffer */
+	uint8_t alpa_map[128];	/* AL_PA map from READ_LA */
+
+	uint8_t fc_ns_retry;	/* retries for fabric nameserver */
+	uint32_t fc_nlp_cnt;	/* outstanding NODELIST requests */
+	uint32_t fc_rscn_id_cnt;	/* count of RSCNs payloads in list */
+	DMABUF_t *fc_rscn_id_list[FC_MAX_HOLD_RSCN];
+
+	uint32_t lmt;
+	uint32_t fc_flag;	/* FC flags */
+#define FC_FCP_WWNN             0x0	/* Match FCP targets on WWNN */
+#define FC_FCP_WWPN             0x1	/* Match FCP targets on WWPN */
+#define FC_FCP_DID              0x2	/* Match FCP targets on DID */
+#define FC_FCP_MATCH            0x3	/* Mask for match FCP targets */
+#define FC_PENDING_RING0        0x4	/* Defer ring 0 IOCB processing */
+#define FC_LNK_DOWN             0x8	/* Link is down */
+#define FC_PT2PT                0x10	/* pt2pt with no fabric */
+#define FC_PT2PT_PLOGI          0x20	/* pt2pt initiate PLOGI */
+#define FC_DELAY_DISC           0x40	/* Delay discovery till after cfglnk */
+#define FC_PUBLIC_LOOP          0x80	/* Public loop */
+#define FC_INTR_THREAD          0x100	/* In interrupt code */
+#define FC_LBIT                 0x200	/* LOGIN bit in loopinit set */
+#define FC_RSCN_MODE            0x400	/* RSCN cmd rcv'ed */
+#define FC_RSCN_DISC_TMR        0x800	/* wait edtov before processing RSCN */
+#define FC_NLP_MORE             0x1000	/* More node to process in node tbl */
+#define FC_OFFLINE_MODE         0x2000	/* Interface is offline for diag */
+#define FC_LD_TIMER             0x4000	/* Linkdown timer has been started */
+#define FC_LD_TIMEOUT           0x8000	/* Linkdown timeout has occurred */
+#define FC_FABRIC               0x10000	/* We are fabric attached */
+#define FC_DELAY_PLOGI          0x20000	/* Delay login till unreglogin */
+#define FC_SLI2                 0x40000	/* SLI-2 CONFIG_PORT cmd completed */
+#define FC_INTR_WORK            0x80000	/* Was there work last intr */
+#define FC_NO_ROOM_IP           0x100000	/* No room on IP xmit queue */
+#define FC_NO_RCV_BUF           0x200000	/* No Rcv Buffers posted IP
+						   ring */
+#define FC_BUS_RESET            0x400000	/* SCSI BUS RESET */
+#define FC_ESTABLISH_LINK       0x800000	/* Reestablish Link */
+#define FC_SCSI_RLIP            0x1000000	/* SCSI rlip routine called */
+#define FC_DELAY_NSLOGI         0x2000000	/* Delay NameServer till
+						   ureglogin */
+#define FC_NSLOGI_TMR           0x4000000	/* NameServer in process of
+						   logout */
+#define FC_DELAY_RSCN           0x8000000	/* Delay RSCN till ureg/reg
+						   login */
+#define FC_RSCN_DISCOVERY       0x10000000	/* Authenticate all devices
+						   after RSCN */
+#define FC_POLL_MODE        0x40000000	/* [SYNC] I/O is in the polling mode */
+#define FC_BYPASSED_MODE        0x80000000	/* Interface is offline for
+						   diag */
+
+	uint32_t reset_pending;
+	uint32_t fc_topology;	/* link topology, from LINK INIT */
+	LPFC_NODELIST_t fc_nlp_bcast;	/* used for IP bcast's */
+
+	LPFC_STAT_t fc_stat;
+
+	uint32_t fc_ipfarp_timeout;	/* timeout in seconds for farp req
+					   completion. */
+	uint32_t fc_ipxri_timeout;	/* timeout in seconds for ip XRI create
+					   completions. */
+	struct list_head fc_node_farp_list;
+
+	/* These are the head/tail pointers for the bind, plogi, adisc, unmap,
+	 *  and map lists.  Their counters are immediately following.
+	 */
+	struct list_head fc_nlpbind_list;
+	struct list_head fc_plogi_list;
+	struct list_head fc_adisc_list;
+	struct list_head fc_nlpunmap_list;
+	struct list_head fc_nlpmap_list;
+
+	/* Keep counters for the number of entries in each list. */
+	uint16_t fc_bind_cnt;
+	uint16_t fc_plogi_cnt;
+	uint16_t fc_adisc_cnt;
+	uint16_t fc_unmap_cnt;
+	uint16_t fc_map_cnt;
+	LPFC_NODELIST_t fc_fcpnodev;	/* nodelist entry for no device */
+	uint32_t nport_event_cnt;	/* timestamp for nlplist entry */
+
+	LPFCSCSITARGET_t *device_queue_hash[MAX_FCP_TARGET];
+#define LPFC_RPI_HASH_SIZE     64
+#define LPFC_RPI_HASH_FUNC(x)  ((x) & (0x3f))
+	LPFC_NODELIST_t *fc_nlplookup[LPFC_RPI_HASH_SIZE]; /* ptr to active D_ID
+								   / RPIs */
+	uint32_t wwnn[2];
+	uint32_t RandomData[7];
+	uint32_t hbainitEx[5];
+
+	lpfcCfgParam_t *config;	/* Configuration parameters */
+
+	lpfc_vpd_t vpd;		/* vital product data */
+
+	unsigned long iflag;	/* used to hold context for drvr lock, if
+				   needed */
+
+	struct Scsi_Host *host;
+	struct pci_dev *pcidev;
+	spinlock_t drvrlock;
+	spinlock_t hiprilock;
+	struct tasklet_struct task_run;
+	struct list_head      task_disc;
+	uint16_t              task_discq_cnt;
+
+	atomic_t cmnds_in_flight;
+
+
+	unsigned long pci_bar0_map;     /* Physical address for PCI BAR0 */
+	unsigned long pci_bar2_map;     /* Physical address for PCI BAR0 */
+	void *slim_memmap_p;	        /* Kernel memory mapped address for PCI
+					   BAR0 */
+	void *ctrl_regs_memmap_p;	/* Kernel memory mapped address for PCI
+					   BAR2 */
+
+	void *MBslimaddr;	/* virtual address for mbox cmds */
+	void *HAregaddr;	/* virtual address for host attn reg */
+	void *CAregaddr;	/* virtual address for chip attn reg */
+	void *HSregaddr;	/* virtual address for host status reg */
+	void *HCregaddr;	/* virtual address for host ctl reg */
+	wait_queue_head_t linkevtwq;
+	wait_queue_head_t rscnevtwq;
+	wait_queue_head_t ctevtwq;
+
+	struct scsi_cmnd *cmnd_retry_list;
+	int in_retry;
+
+	uint8_t brd_no;		/* FC board number */
+	uint8_t fc_busflag;	/* bus access flags */
+	LPFC_SCHED_HBA_t hbaSched;
+
+	uint32_t fcp_timeout_offset;
+
+	char adaptermsg[FC_MAX_ADPTMSG];	/* adapter printf messages */
+
+	char SerialNumber[32];		/* adapter Serial Number */
+	char OptionROMVersion[32];	/* adapter BIOS / Fcode version */
+	char ModelDesc[256];		/* Model Description */
+	char ModelName[80];		/* Model Name */
+	char ProgramType[256];		/* Program type */
+	char Port[20];			/* Port No */
+	uint8_t vpd_flag;               /* VPD data flag */
+
+#define VPD_MODEL_DESC      0x1         /* valid vpd model description */
+#define VPD_MODEL_NAME      0x2         /* valid vpd model name */
+#define VPD_PROGRAM_TYPE    0x4         /* valid vpd program type */
+#define VPD_PORT            0x8         /* valid vpd port data */
+#define VPD_MASK            0xf         /* mask for any vpd data */
+
+	struct lpfcScsiLun *(*lpfc_tran_find_lun) (struct lpfc_scsi_buf *);
+	struct timer_list dqfull_clk;
+	struct timer_list els_tmofunc;
+	struct timer_list ip_tmofunc;
+	struct timer_list scsi_tmofunc;
+	struct timer_list buf_tmo;
+
+	struct list_head delay_list;
+	struct list_head free_buf_list;
+
+	/*
+	 * HBA API 2.0 specific counters
+	 */
+	uint64_t fc4InputRequests;
+	uint64_t fc4OutputRequests;
+	uint64_t fc4ControlRequests;
+
+	/* pci_mem_pools */
+	struct pci_pool *lpfc_scsi_dma_ext_pool;
+	struct pci_pool *lpfc_mbuf_pool;
+	struct pci_pool *lpfc_page_pool;
+	struct lpfc_dma_pool lpfc_mbuf_saftey_pool;
+	struct lpfc_dma_pool lpfc_page_saftey_pool;
+	struct lpfc_mem_pool lpfc_mem_saftey_pool;
+	struct list_head timerList;
+
+} lpfcHBA_t;
+
+struct clk_data {
+	struct list_head listLink;
+	struct timer_list *timeObj;
+	lpfcHBA_t     *phba; 
+	unsigned long clData1;
+	unsigned long clData2;
+	unsigned long flags;
+#define TM_CANCELED	0x1	/* timer has been canceled */
+};
+
+typedef struct fcEVT {		/* Kernel level Event structure */
+	uint32_t evt_handle;
+	uint32_t evt_mask;
+	uint32_t evt_data0;
+	uint16_t evt_sleep;
+	uint16_t evt_flags;
+	void    *evt_type;
+	void    *evt_next;
+	void    *evt_data1;
+	void    *evt_data2;
+} fcEVT_t;
+
+typedef struct fcEVTHDR {	/* Kernel level Event Header */
+	uint32_t e_handle;
+	uint32_t e_mask;
+	uint16_t e_mode;
+#define E_SLEEPING_MODE     0x0001
+	uint16_t e_refcnt;
+	uint16_t e_flag;
+#define E_GET_EVENT_ACTIVE  0x0001
+	fcEVT_t *e_head;
+	fcEVT_t *e_tail;
+	void    *e_next_header;
+	void    *e_type;
+} fcEVTHDR_t;
+#endif				/* _H_LPFC */
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_cfgparm.h linux-8155/drivers/addon/lpfc/lpfc_cfgparm.h
--- linux-8152/drivers/addon/lpfc/lpfc_cfgparm.h
+++ linux-8155/drivers/addon/lpfc/lpfc_cfgparm.h
@@ -0,0 +1,325 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_cfgparm.h 328 2005-05-03 15:20:43Z sf_support $
+ */
+
+#ifndef _H_LPFC_CFGPARAM
+#define _H_LPFC_CFGPARAM
+
+#define LPFC_DFT_XMT_QUE_SIZE           256
+#define LPFC_MIN_XMT_QUE_SIZE           128
+#define LPFC_MAX_XMT_QUE_SIZE           10240
+#define LPFC_DFT_NUM_IOCBS              256
+#define LPFC_MIN_NUM_IOCBS              128
+#define LPFC_MAX_NUM_IOCBS              10240
+#define LPFC_DFT_NUM_BUFS               128
+#define LPFC_MIN_NUM_BUFS               64
+#define LPFC_MAX_NUM_BUFS               4096
+#define LPFC_DFT_NUM_NODES              510
+#define LPFC_MIN_NUM_NODES              64
+#define LPFC_MAX_NUM_NODES              4096
+#define LPFC_DFT_TOPOLOGY               0
+#define LPFC_DFT_FC_CLASS               3
+
+#define LPFC_DFT_NO_DEVICE_DELAY        1	/* 1 sec */
+#define LPFC_MAX_NO_DEVICE_DELAY        30	/* 30 sec */
+#define LPFC_DFT_EXTRA_IO_TIMEOUT       0
+#define LPFC_MAX_EXTRA_IO_TIMEOUT       255	/* 255 sec */
+#define LPFC_DFT_LNKDWN_TIMEOUT         30
+#define LPFC_MAX_LNKDWN_TIMEOUT         255	/* 255 sec */
+#define LPFC_DFT_NODEV_TIMEOUT          30
+#define LPFC_MAX_NODEV_TIMEOUT          255	/* 255 sec */
+#define LPFC_DFT_RSCN_NS_DELAY          0
+#define LPFC_MAX_RSCN_NS_DELAY          255	/* 255 sec */
+
+#define LPFC_MAX_HBA_Q_DEPTH            10240	/* max cmds allowed per hba */
+#define LPFC_DFT_HBA_Q_DEPTH            2048	/* max cmds per hba */
+#define LPFC_LC_HBA_Q_DEPTH             1024	/* max cmds per low cost hba */
+#define LPFC_LP101_HBA_Q_DEPTH          128	/* max cmds per low cost hba */
+
+#define LPFC_MAX_TGT_Q_DEPTH            10240	/* max cmds allowed per tgt */
+#define LPFC_DFT_TGT_Q_DEPTH            0	/* default max cmds per tgt */
+
+#define LPFC_MAX_LUN_Q_DEPTH            128	/* max cmds to allow per lun */
+#define LPFC_DFT_LUN_Q_DEPTH            30	/* default max cmds per lun */
+
+#define LPFC_MAX_DQFULL_THROTTLE        1	/* Boolean (max value) */
+
+#define LPFC_MAX_DISC_THREADS           64	/* max outstanding discovery els
+						   requests */
+#define LPFC_DFT_DISC_THREADS           1	/* default outstanding discovery
+						   els requests */
+
+#define LPFC_MAX_NS_RETRY               3	/* Try to get to the NameServer
+						   3 times and then give up. */
+
+#define LPFC_MAX_SCSI_REQ_TMO           255	/* Max timeout value for SCSI
+						   passthru requests */
+#define LPFC_DFT_SCSI_REQ_TMO           30	/* Default timeout value for
+						   SCSI passthru requests */
+
+#define LPFC_MAX_TARGET                 256	/* max nunber of targets
+						   supported */
+#define LPFC_DFT_MAX_TARGET             256	/* default max number of targets
+						   supported */
+
+#define LPFC_MAX_LUN                    256	/* max nunber of LUNs
+						   supported */
+#define LPFC_DFT_MAX_LUN                256	/* default max number of LUNs
+						   supported */
+
+/* LPFC specific parameters start at LPFC_CORE_NUM_OF_CFG_PARAM */
+#define LPFC_CFG_LOG_VERBOSE             0	/* log-verbose */
+#define LPFC_CFG_DFT_TGT_Q_DEPTH         1	/* tgt_queue_depth */
+#define LPFC_CFG_DFT_LUN_Q_DEPTH         2	/* lun_queue_depth */
+#define LPFC_CFG_EXTRA_IO_TMO            3	/* extra-io-tmo */
+#define LPFC_CFG_NO_DEVICE_DELAY         4	/* no-device-delay */
+#define LPFC_CFG_LINKDOWN_TMO            5	/* linkdown-tmo */
+#define LPFC_CFG_HOLDIO                  6	/* nodev-holdio */
+#define LPFC_CFG_DELAY_RSP_ERR           7	/* delay-rsp-err */
+#define LPFC_CFG_CHK_COND_ERR            8	/* check-cond-err */
+#define LPFC_CFG_NODEV_TMO               9	/* nodev-tmo */
+#define LPFC_CFG_DQFULL_THROTTLE_UP_TIME 10	/* dqfull-throttle-up-time */
+#define LPFC_CFG_DQFULL_THROTTLE_UP_INC  11	/* dqfull-throttle-up-inc */
+#define LPFC_CFG_MAX_LUN                 12	/* max-lun */
+#define LPFC_CFG_DFT_HBA_Q_DEPTH         13	/* dft_hba_q_depth */
+#define LPFC_CFG_LUN_SKIP		 14	/* lun_skip */
+#define LPFC_CFG_AUTOMAP                 15	/* automap */
+#define LPFC_CFG_FCP_CLASS               16	/* fcp-class */
+#define LPFC_CFG_USE_ADISC               17	/* use-adisc */
+#define LPFC_CFG_XMT_Q_SIZE              18	/* xmt-que-size */
+#define LPFC_CFG_ACK0                    19	/* ack0 */
+#define LPFC_CFG_TOPOLOGY                20	/* topology */
+#define LPFC_CFG_SCAN_DOWN               21	/* scan-down */
+#define LPFC_CFG_LINK_SPEED              22	/* link-speed */
+#define LPFC_CFG_CR_DELAY                23	/* cr-delay */
+#define LPFC_CFG_CR_COUNT                24	/* cr-count */
+#define LPFC_CFG_FDMI_ON                 25	/* fdmi-on-count */
+#define LPFC_CFG_BINDMETHOD              26	/* fcp-bind-method */
+#define LPFC_CFG_DISC_THREADS            27	/* discovery-threads */
+#define LPFC_CFG_SCSI_REQ_TMO            28	/* timeout value for SCSI pass*/
+#define LPFC_CFG_MAX_TARGET              29	/* max-target */
+
+
+/* Note: The following define LPFC_TOTAL_NUM_OF_CFG_PARAM represents the total
+	 number of user configuration params. This define is used to specify the
+	 number of entries in the array lpfc_icfgparam[].
+ */
+#define LPFC_TOTAL_NUM_OF_CFG_PARAM      30
+
+/* The order of the icfgparam[] entries must match that of LPFC_CORE_CFG defs */
+#ifdef LPFC_DEF_ICFG
+iCfgParam lpfc_icfgparam[LPFC_TOTAL_NUM_OF_CFG_PARAM] = {
+	/* The driver now exports the cfg name. So it needs to be consistent
+	   with lpfc.conf param name */
+
+	/* general driver parameters */
+	{"log_verbose",
+	 0, 0xffff, FALSE, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_DYNAMIC,
+	 "Verbose logging bit-mask"},
+
+	{"tgt_queue_depth",
+	 0, LPFC_MAX_TGT_Q_DEPTH, LPFC_DFT_TGT_Q_DEPTH, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_RESTART,
+	 "Max number of FCP commands we can queue to a specific target"},
+
+	{"lun_queue_depth",
+	 1, LPFC_MAX_LUN_Q_DEPTH, LPFC_DFT_LUN_Q_DEPTH, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_RESTART,
+	 "Max number of FCP commands we can queue to a specific LUN"},
+
+	{"extra_io_tmo",
+	 0, LPFC_MAX_EXTRA_IO_TIMEOUT, 0, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_DYNAMIC,
+	 "Extra FCP command timeout"},
+
+	{"no_device_delay",
+	 0, LPFC_MAX_NO_DEVICE_DELAY, LPFC_DFT_NO_DEVICE_DELAY, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_DYNAMIC,
+	 "Length of interval in seconds for FCP device I/O failure"},
+
+	{"linkdown_tmo",
+	 0, LPFC_MAX_LNKDWN_TIMEOUT, LPFC_DFT_LNKDWN_TIMEOUT, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_DYNAMIC,
+	 "Seconds driver will wait before deciding link is really down"},
+
+	{"nodev_holdio",
+	 0, 1, FALSE, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_DYNAMIC,
+	 "Hold I/O errors if device disappears "},
+
+	{"delay_rsp_err",
+	 0, 1, FALSE, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_DYNAMIC,
+	 "Delay FCP error return for FCP RSP error and Check Condition"},
+
+	{"check_cond_err",
+	 0, 1, FALSE, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_DYNAMIC,
+	 "Treat special Check Conditions as a FCP error"},
+
+	{"nodev_tmo",
+	 0, LPFC_MAX_NODEV_TIMEOUT, LPFC_DFT_NODEV_TIMEOUT, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_DYNAMIC,
+	 "Seconds driver will hold I/O waiting for a device to come back"},
+
+	{"dqfull_throttle_up_time",
+	 0, 30, 1, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_DYNAMIC,
+	 "When to increment the current Q depth "},
+
+	{"dqfull_throttle_up_inc",
+	 0, LPFC_MAX_LUN_Q_DEPTH, 1, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_DYNAMIC,
+	 "Increment the current Q depth by dqfull-throttle-up-inc"},
+
+	{"max_lun",
+	 1, LPFC_MAX_LUN, LPFC_DFT_MAX_LUN, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_DYNAMIC,
+	 "The maximun number of LUNs a target can support"},
+
+	{"hba_queue_depth",
+	 0, LPFC_MAX_HBA_Q_DEPTH, 0, 0,
+	 (ushort) (CFG_IGNORE),
+	 (ushort) CFG_RESTART,
+	 "Max number of FCP commands we can queue to a specific HBA"},
+
+	{"lun_skip",
+	 0, 1, FALSE, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_RESTART,
+	 "Enable SCSI layer to scan past lun holes"},
+
+	/* Start of product specific (lpfc) config params */
+
+	{"automap",
+	 0, 1, 1, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_RESTART,
+	 "Automatically bind FCP devices as they are discovered"},
+
+	{"fcp_class",
+	 2, 3, LPFC_DFT_FC_CLASS, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_DYNAMIC,
+	 "Select Fibre Channel class of service for FCP sequences"},
+
+	{"use_adisc",
+	 0, 1, FALSE, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_DYNAMIC,
+	 "Use ADISC on rediscovery to authenticate FCP devices"},
+
+	/* IP specific parameters */
+	{"xmt_que_size",
+	 LPFC_MIN_XMT_QUE_SIZE, LPFC_MAX_XMT_QUE_SIZE, LPFC_DFT_XMT_QUE_SIZE, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_RESTART,
+	 "Number of outstanding IP cmds for an adapter"},
+
+	/* Fibre Channel specific parameters */
+	{"ack0",
+
+	 0, 1, FALSE, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_RESTART,
+	 "Enable ACK0 support"},
+
+	{"topology",
+	 0, 6, LPFC_DFT_TOPOLOGY, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_RESTART,
+	 "Select Fibre Channel topology"},
+
+	{"scan_down",
+	 0, 1, 1, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_DYNAMIC,
+	 "Start scanning for devices from highest ALPA to lowest"},
+
+	{"link_speed",
+	 0, 4, 0, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_RESTART,
+	 "Select link speed"},
+
+	{"cr_delay",
+	 0, 63, 0, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_RESTART,
+	 "A count of milliseconds after which an interrupt response is "
+	 "generated"},
+
+	{"cr_count",
+	 1, 255, 1, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_RESTART,
+	 "A count of I/O completions after which an interrupt response is "
+	 "generated"},
+
+	{"fdmi_on",
+	 0, 2, FALSE, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_RESTART,
+	 "Enable FDMI support"},
+
+	{"fcp_bind_method",
+	 1, 4, 2, 2,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_RESTART,
+	 "Select the bind method to be used."},
+
+	{"discovery_threads",
+	 1, LPFC_MAX_DISC_THREADS, LPFC_DFT_DISC_THREADS, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_RESTART,
+	 "Maximum number of ELS commands during discovery"},
+
+	{"scsi_req_tmo",
+	 0, LPFC_MAX_SCSI_REQ_TMO, LPFC_DFT_SCSI_REQ_TMO, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_DYNAMIC,
+	 "Timeout value for SCSI passthru requests"},
+
+	{"max_target",
+	 1, LPFC_MAX_TARGET, LPFC_DFT_MAX_TARGET, 0,
+	 (ushort) (CFG_EXPORT),
+	 (ushort) CFG_RESTART,
+	 "The maximun number of targets an adapter can support"},
+};
+#endif				/* LPFC_DEF_ICFG */
+
+#endif				/* _H_LPFC_CFGPARAM */
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_clock.c linux-8155/drivers/addon/lpfc/lpfc_clock.c
--- linux-8152/drivers/addon/lpfc/lpfc_clock.c
+++ linux-8155/drivers/addon/lpfc/lpfc_clock.c
@@ -0,0 +1,86 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_clock.c 328 2005-05-03 15:20:43Z sf_support $
+ */
+
+#include <linux/version.h>
+#include <linux/spinlock.h>
+
+
+#include <linux/blk.h>
+#include <scsi.h>
+
+#include "lpfc_hw.h"
+#include "lpfc_mem.h"
+#include "lpfc_sli.h"
+#include "lpfc_sched.h"
+#include "lpfc_disc.h"
+#include "lpfc.h"
+#include "lpfc_logmsg.h"
+#include "lpfc_scsi.h"
+#include "lpfc_crtn.h"
+
+void
+lpfc_start_timer(lpfcHBA_t * phba, 
+	unsigned long tmo, struct timer_list *ptimer,
+	void (*func) (unsigned long), unsigned long data1, unsigned long data2) 
+{
+	struct clk_data *clkData;
+
+	if (phba->no_timer)
+		return;
+
+	clkData = kmalloc(sizeof(struct clk_data), GFP_ATOMIC);
+	if (!clkData) {
+		printk (KERN_WARNING
+                        "lpfc_start_timer kmalloc failed. board_no: %d\n",
+			phba->brd_no);
+		return;
+	}
+	clkData->timeObj = ptimer; 
+	clkData->phba = phba;
+	clkData->clData1 = data1;
+	clkData->clData2 = data2;
+	clkData->flags = 0;
+
+	init_timer(ptimer);
+	ptimer->function = func;
+	ptimer->expires = jiffies + HZ * tmo;
+	ptimer->data = (unsigned long)clkData;
+	list_add((struct list_head *)clkData, &phba->timerList);
+	add_timer(ptimer);
+}
+
+void
+lpfc_stop_timer(struct clk_data *clkData)
+{
+	struct timer_list *ptimer;
+	
+	ptimer = clkData->timeObj;
+	clkData->flags |= TM_CANCELED;
+	ptimer->function = 0;
+	if (del_timer(ptimer)) {
+		list_del((struct list_head *)clkData);
+		kfree(clkData);
+		}
+
+}
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_compat.h linux-8155/drivers/addon/lpfc/lpfc_compat.h
--- linux-8152/drivers/addon/lpfc/lpfc_compat.h
+++ linux-8155/drivers/addon/lpfc/lpfc_compat.h
@@ -0,0 +1,141 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_compat.h 328 2005-05-03 15:20:43Z sf_support $
+ *
+ * This file provides macros to aid compilation in the Linux 2.4 kernel
+ * over various platform architectures.
+ */
+
+#ifndef _H_LPFC_COMPAT
+#define  _H_LPFC_COMPAT
+
+/*******************************************************************
+Note: dma_mapping_error() was added in 2.6.5 so 
+provide dma_mapping_error() for earlier kernels.
+This version is from asm-ppc64/dma-mapping.h but will also fit with
+asm-i386/dma-mapping.h since that version always returns 0.
+ *******************************************************************/
+
+#ifndef DMA_ERROR_CODE
+#define DMA_ERROR_CODE		(~(dma_addr_t)0x0)
+#endif
+
+static inline int dma_mapping_error(dma_addr_t dma_addr)
+{
+	return (dma_addr == DMA_ERROR_CODE);
+}
+
+
+/*******************************************************************
+Note: HBA's SLI memory contains little-endian LW.
+Thus to access it from a little-endian host,
+memcpy_toio() and memcpy_fromio() can be used.
+However on a big-endian host, copy 4 bytes at a time,
+using writel() and readl().
+ *******************************************************************/
+
+#if __BIG_ENDIAN
+
+static inline void
+lpfc_memcpy_to_slim( void *dest, void *src, unsigned int bytes)
+{
+	uint32_t *dest32;
+	uint32_t *src32;
+	unsigned int four_bytes;
+
+
+	dest32  = (uint32_t *) dest;
+	src32  = (uint32_t *) src;
+
+	/* write input bytes, 4 bytes at a time */
+	for (four_bytes = bytes /4; four_bytes > 0; four_bytes--) {
+		writel( *src32, dest32);
+		readl(dest32); /* flush */
+		dest32++;
+		src32++;
+	}
+
+	return;
+}
+
+static inline void
+lpfc_memcpy_from_slim( void *dest, void *src, unsigned int bytes)
+{
+	uint32_t *dest32;
+	uint32_t *src32;
+	unsigned int four_bytes;
+
+
+	dest32  = (uint32_t *) dest;
+	src32  = (uint32_t *) src;
+
+	/* read input bytes, 4 bytes at a time */
+	for (four_bytes = bytes /4; four_bytes > 0; four_bytes--) {
+		*dest32 = readl( src32);
+		dest32++;
+		src32++;
+	}
+
+	return;
+}
+
+#else
+
+static inline void
+lpfc_memcpy_to_slim( void *dest, void *src, unsigned int bytes)
+{
+	/* actually returns 1 byte past dest */
+	memcpy_toio( dest, src, bytes);
+}
+
+static inline void
+lpfc_memcpy_from_slim( void *dest, void *src, unsigned int bytes)
+{
+	/* actually returns 1 byte past dest */
+	memcpy_fromio( dest, src, bytes);
+}
+
+#endif /* __BIG_ENDIAN */
+
+
+/*******************************************************************
+Indicate whether "SLIM POINTER" feature can be used to set 
+"Host Group Ring Pointers" to point to HBA SLIM area.
+
+PowerPC cannot use this feature, so it must use the host memory
+instead. Likewise for SPARC SBUS.
+ *******************************************************************/
+
+#ifdef CONFIG_PPC64
+#define USE_HGP_HOST_SLIM	1
+#endif
+
+
+
+/* Linux kernels before 2.4.23 did not provide these definitions */
+#ifndef IRQ_NONE
+typedef void irqreturn_t;
+#define IRQ_NONE
+#define IRQ_HANDLED
+#endif				/* ifndef IRQ_NONE */
+
+#endif				/*  _H_LPFC_COMPAT */
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_crtn.h linux-8155/drivers/addon/lpfc/lpfc_crtn.h
--- linux-8152/drivers/addon/lpfc/lpfc_crtn.h
+++ linux-8155/drivers/addon/lpfc/lpfc_crtn.h
@@ -0,0 +1,492 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_crtn.h 328 2005-05-03 15:20:43Z sf_support $
+ */
+
+#ifndef _H_LPFC_CRTN
+#define _H_LPFC_CRTN
+
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <asm/uaccess.h>
+#include <scsi.h>
+
+#include "lpfc_sli.h"
+#include "lpfc_scsi.h"
+#include "lpfc_logmsg.h"
+
+#include "lpfc_compat.h"
+
+int lpfc_proc_info(char *, char **, off_t , int , int , int);
+
+void lpfc_dump_mem(lpfcHBA_t *, LPFC_MBOXQ_t *, uint16_t);
+void lpfc_read_nv(lpfcHBA_t *, LPFC_MBOXQ_t *);
+int lpfc_read_la(lpfcHBA_t *, LPFC_MBOXQ_t *);
+void lpfc_clear_la(lpfcHBA_t *, LPFC_MBOXQ_t *);
+void lpfc_config_link(lpfcHBA_t *, LPFC_MBOXQ_t *);
+int lpfc_read_sparam(lpfcHBA_t *, LPFC_MBOXQ_t *);
+void lpfc_read_config(lpfcHBA_t *, LPFC_MBOXQ_t *);
+void lpfc_set_slim(lpfcHBA_t *, LPFC_MBOXQ_t *, uint32_t, uint32_t);
+void lpfc_config_farp(lpfcHBA_t *, LPFC_MBOXQ_t *);
+int lpfc_reg_login(lpfcHBA_t *, uint32_t, uint8_t *, LPFC_MBOXQ_t *, uint32_t);
+void lpfc_unreg_login(lpfcHBA_t *, uint32_t, LPFC_MBOXQ_t *);
+void lpfc_unreg_did(lpfcHBA_t *, uint32_t, LPFC_MBOXQ_t *);
+void lpfc_init_link(lpfcHBA_t *, LPFC_MBOXQ_t *, uint32_t, uint32_t);
+uint32_t *lpfc_config_pcb_setup(lpfcHBA_t *);
+int lpfc_read_rpi(lpfcHBA_t *, uint32_t, LPFC_MBOXQ_t *, uint32_t);
+
+
+int lpfc_linkdown(lpfcHBA_t *);
+int lpfc_linkup(lpfcHBA_t *);
+void lpfc_mbx_cmpl_read_la(lpfcHBA_t *, LPFC_MBOXQ_t *);
+void lpfc_mbx_cmpl_config_link(lpfcHBA_t *, LPFC_MBOXQ_t *);
+void lpfc_mbx_cmpl_read_sparam(lpfcHBA_t *, LPFC_MBOXQ_t *);
+void lpfc_mbx_cmpl_clear_la(lpfcHBA_t *, LPFC_MBOXQ_t *);
+void lpfc_mbx_cmpl_reg_login(lpfcHBA_t *, LPFC_MBOXQ_t *);
+void lpfc_mbx_cmpl_fabric_reg_login(lpfcHBA_t *, LPFC_MBOXQ_t *);
+void lpfc_mbx_cmpl_ns_reg_login(lpfcHBA_t *, LPFC_MBOXQ_t *);
+void lpfc_mbx_cmpl_fdmi_reg_login(lpfcHBA_t *, LPFC_MBOXQ_t *);
+int lpfc_nlp_bind(lpfcHBA_t *, LPFC_BINDLIST_t *);
+int lpfc_nlp_plogi(lpfcHBA_t *, LPFC_NODELIST_t *);
+int lpfc_nlp_adisc(lpfcHBA_t *, LPFC_NODELIST_t *);
+int lpfc_nlp_unmapped(lpfcHBA_t *, LPFC_NODELIST_t *);
+int lpfc_nlp_mapped(struct lpfcHBA *, LPFC_NODELIST_t *, LPFC_BINDLIST_t *);
+void lpfc_set_npr_tmo(lpfcHBA_t *, LPFCSCSITARGET_t *, LPFC_NODELIST_t *);
+int lpfc_can_npr_tmo(lpfcHBA_t *, LPFCSCSITARGET_t *, LPFC_NODELIST_t *);
+void lpfc_set_disctmo(lpfcHBA_t *);
+int lpfc_can_disctmo(lpfcHBA_t *);
+int lpfc_driver_abort(lpfcHBA_t *, LPFC_NODELIST_t *);
+int lpfc_no_rpi(lpfcHBA_t *, LPFC_NODELIST_t *);
+int lpfc_new_rpi(lpfcHBA_t *, uint16_t);
+void lpfc_dequenode(lpfcHBA_t *, LPFC_NODELIST_t *);
+int lpfc_freenode(lpfcHBA_t *, LPFC_NODELIST_t *);
+int lpfc_nlp_remove(lpfcHBA_t *, LPFC_NODELIST_t *);
+LPFC_NODELIST_t *lpfc_findnode_did(lpfcHBA_t *, uint32_t, uint32_t);
+LPFC_NODELIST_t *lpfc_findnode_scsiid(lpfcHBA_t *, uint32_t);
+LPFC_NODELIST_t *lpfc_findnode_wwpn(lpfcHBA_t *, uint32_t, NAME_TYPE *);
+LPFC_NODELIST_t *lpfc_findnode_wwnn(lpfcHBA_t *, uint32_t, NAME_TYPE *);
+void lpfc_disc_list_loopmap(lpfcHBA_t *);
+void lpfc_disc_start(lpfcHBA_t *);
+void lpfc_disc_flush_list(lpfcHBA_t *);
+void lpfc_disc_timeout(unsigned long);
+void lpfc_linkdown_timeout(unsigned long);
+void lpfc_nodev_timeout(unsigned long);
+LPFCSCSILUN_t *lpfc_find_lun(lpfcHBA_t *, uint32_t, uint64_t, int);
+LPFC_SCSI_BUF_t *lpfc_build_scsi_cmd(lpfcHBA_t *, LPFC_NODELIST_t *, uint32_t,
+				    uint64_t);
+int lpfc_disc_issue_rptlun(lpfcHBA_t *, LPFC_NODELIST_t *);
+void lpfc_set_failmask(lpfcHBA_t *, LPFC_NODELIST_t *, uint32_t, uint32_t);
+
+LPFC_NODELIST_t *lpfc_findnode_rpi(lpfcHBA_t * phba, uint16_t rpi);
+
+int lpfc_discq_post_event(lpfcHBA_t *, void *, void *, uint32_t);
+void lpfc_tasklet(unsigned long);
+void lpfc_flush_disc_evtq(lpfcHBA_t * phba);
+int lpfc_disc_state_machine(lpfcHBA_t *, LPFC_NODELIST_t *, void *, uint32_t);
+uint32_t lpfc_disc_nodev(lpfcHBA_t *, LPFC_NODELIST_t *, void *, uint32_t);
+uint32_t lpfc_disc_neverdev(lpfcHBA_t *, LPFC_NODELIST_t *, void *, uint32_t);
+
+uint32_t lpfc_rcv_plogi_unused_node(lpfcHBA_t *, LPFC_NODELIST_t *,
+				    void *, uint32_t);
+uint32_t lpfc_rcv_els_unused_node(lpfcHBA_t *, LPFC_NODELIST_t *,
+				  void *, uint32_t);
+uint32_t lpfc_rcv_logo_unused_node(lpfcHBA_t *, LPFC_NODELIST_t *,
+				   void *, uint32_t);
+uint32_t lpfc_cmpl_els_unused_node(lpfcHBA_t *, LPFC_NODELIST_t *,
+				   void *, uint32_t);
+uint32_t lpfc_cmpl_reglogin_unused_node(lpfcHBA_t *, LPFC_NODELIST_t *,
+					void *, uint32_t);
+uint32_t lpfc_device_rm_unused_node(lpfcHBA_t *, LPFC_NODELIST_t *,
+				    void *, uint32_t);
+uint32_t lpfc_device_add_unused_node(lpfcHBA_t *, LPFC_NODELIST_t *,
+				     void *, uint32_t);
+uint32_t lpfc_device_unk_unused_node(lpfcHBA_t *, LPFC_NODELIST_t *,
+				     void *, uint32_t);
+uint32_t lpfc_rcv_plogi_plogi_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				    void *, uint32_t);
+uint32_t lpfc_rcv_prli_plogi_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				   void *, uint32_t);
+uint32_t lpfc_rcv_logo_plogi_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				   void *, uint32_t);
+uint32_t lpfc_rcv_els_plogi_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				  void *, uint32_t);
+uint32_t lpfc_cmpl_plogi_plogi_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				     void *, uint32_t);
+uint32_t lpfc_cmpl_prli_plogi_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				    void *, uint32_t);
+uint32_t lpfc_cmpl_logo_plogi_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				    void *, uint32_t);
+uint32_t lpfc_cmpl_adisc_plogi_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				     void *, uint32_t);
+uint32_t lpfc_cmpl_reglogin_plogi_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+					void *, uint32_t);
+uint32_t lpfc_device_rm_plogi_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				    void *, uint32_t);
+uint32_t lpfc_device_unk_plogi_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				     void *, uint32_t);
+uint32_t lpfc_rcv_plogi_reglogin_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				       void *, uint32_t);
+uint32_t lpfc_rcv_prli_reglogin_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				      void *, uint32_t);
+uint32_t lpfc_rcv_logo_reglogin_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				      void *, uint32_t);
+uint32_t lpfc_rcv_padisc_reglogin_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+					void *, uint32_t);
+uint32_t lpfc_rcv_prlo_reglogin_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				      void *, uint32_t);
+uint32_t lpfc_cmpl_plogi_reglogin_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+					void *, uint32_t);
+uint32_t lpfc_cmpl_prli_reglogin_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				       void *, uint32_t);
+uint32_t lpfc_cmpl_logo_reglogin_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				       void *, uint32_t);
+uint32_t lpfc_cmpl_adisc_reglogin_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+					void *, uint32_t);
+uint32_t lpfc_cmpl_reglogin_reglogin_issue(lpfcHBA_t *,
+					   LPFC_NODELIST_t *, void *, uint32_t);
+uint32_t lpfc_device_rm_reglogin_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				       void *, uint32_t);
+uint32_t lpfc_device_unk_reglogin_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+					void *, uint32_t);
+uint32_t lpfc_rcv_plogi_prli_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				   void *, uint32_t);
+uint32_t lpfc_rcv_prli_prli_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				  void *, uint32_t);
+uint32_t lpfc_rcv_logo_prli_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				  void *, uint32_t);
+uint32_t lpfc_rcv_padisc_prli_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				    void *, uint32_t);
+uint32_t lpfc_rcv_prlo_prli_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				  void *, uint32_t);
+uint32_t lpfc_cmpl_plogi_prli_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				    void *, uint32_t);
+uint32_t lpfc_cmpl_prli_prli_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				   void *, uint32_t);
+uint32_t lpfc_cmpl_logo_prli_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				   void *, uint32_t);
+uint32_t lpfc_cmpl_adisc_prli_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				    void *, uint32_t);
+uint32_t lpfc_cmpl_reglogin_prli_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				       void *, uint32_t);
+uint32_t lpfc_device_rm_prli_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				   void *, uint32_t);
+uint32_t lpfc_device_add_prli_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				    void *, uint32_t);
+uint32_t lpfc_device_unk_prli_issue(lpfcHBA_t *, LPFC_NODELIST_t *,
+				    void *, uint32_t);
+uint32_t lpfc_rcv_plogi_prli_compl(lpfcHBA_t *, LPFC_NODELIST_t *,
+				   void *, uint32_t);
+uint32_t lpfc_rcv_prli_prli_compl(lpfcHBA_t *, LPFC_NODELIST_t *,
+				  void *, uint32_t);
+uint32_t lpfc_rcv_logo_prli_compl(lpfcHBA_t *, LPFC_NODELIST_t *,
+				  void *, uint32_t);
+uint32_t lpfc_rcv_padisc_prli_compl(lpfcHBA_t *, LPFC_NODELIST_t *,
+				    void *, uint32_t);
+uint32_t lpfc_rcv_prlo_prli_compl(lpfcHBA_t *, LPFC_NODELIST_t *,
+				  void *, uint32_t);
+uint32_t lpfc_cmpl_logo_prli_compl(lpfcHBA_t *, LPFC_NODELIST_t *,
+				   void *, uint32_t);
+uint32_t lpfc_cmpl_adisc_prli_compl(lpfcHBA_t *, LPFC_NODELIST_t *,
+				    void *, uint32_t);
+uint32_t lpfc_cmpl_reglogin_prli_compl(lpfcHBA_t *, LPFC_NODELIST_t *,
+				       void *, uint32_t);
+uint32_t lpfc_device_rm_prli_compl(lpfcHBA_t *, LPFC_NODELIST_t *,
+				   void *, uint32_t);
+uint32_t lpfc_device_add_prli_compl(lpfcHBA_t *, LPFC_NODELIST_t *,
+				    void *, uint32_t);
+uint32_t lpfc_device_unk_prli_compl(lpfcHBA_t *, LPFC_NODELIST_t *,
+				    void *, uint32_t);
+uint32_t lpfc_rcv_plogi_mapped_node(lpfcHBA_t *, LPFC_NODELIST_t *,
+				    void *, uint32_t);
+uint32_t lpfc_rcv_prli_mapped_node(lpfcHBA_t *, LPFC_NODELIST_t *,
+				   void *, uint32_t);
+uint32_t lpfc_rcv_logo_mapped_node(lpfcHBA_t *, LPFC_NODELIST_t *,
+				   void *, uint32_t);
+uint32_t lpfc_rcv_padisc_mapped_node(lpfcHBA_t *, LPFC_NODELIST_t *,
+				     void *, uint32_t);
+uint32_t lpfc_rcv_prlo_mapped_node(lpfcHBA_t *, LPFC_NODELIST_t *,
+				   void *, uint32_t);
+uint32_t lpfc_cmpl_logo_mapped_node(lpfcHBA_t *, LPFC_NODELIST_t *,
+				    void *, uint32_t);
+uint32_t lpfc_cmpl_adisc_mapped_node(lpfcHBA_t *, LPFC_NODELIST_t *,
+				     void *, uint32_t);
+uint32_t lpfc_cmpl_reglogin_mapped_node(lpfcHBA_t *, LPFC_NODELIST_t *,
+					void *, uint32_t);
+uint32_t lpfc_device_rm_mapped_node(lpfcHBA_t *, LPFC_NODELIST_t *,
+				    void *, uint32_t);
+uint32_t lpfc_device_add_mapped_node(lpfcHBA_t *, LPFC_NODELIST_t *,
+				     void *, uint32_t);
+uint32_t lpfc_device_unk_mapped_node(lpfcHBA_t *, LPFC_NODELIST_t *,
+				     void *, uint32_t);
+
+int lpfc_check_sparm(lpfcHBA_t *, LPFC_NODELIST_t *, SERV_PARM *, uint32_t);
+int lpfc_geportname(NAME_TYPE *, NAME_TYPE *);
+uint32_t lpfc_add_bind(lpfcHBA_t * phba, uint8_t bind_type,
+		       void *bind_id, uint32_t scsi_id);
+uint32_t lpfc_del_bind(lpfcHBA_t * phba, uint8_t bind_type,
+		       void *bind_id, uint32_t scsi_id);
+
+int lpfc_initial_flogi(lpfcHBA_t *);
+int lpfc_issue_els_flogi(lpfcHBA_t *, LPFC_NODELIST_t *, uint8_t);
+int lpfc_els_abort_flogi(lpfcHBA_t *);
+int lpfc_issue_els_plogi(lpfcHBA_t *, LPFC_NODELIST_t *, uint8_t);
+int lpfc_issue_els_prli(lpfcHBA_t *, LPFC_NODELIST_t *, uint8_t);
+int lpfc_issue_els_adisc(lpfcHBA_t *, LPFC_NODELIST_t *, uint8_t);
+int lpfc_issue_els_logo(lpfcHBA_t *, LPFC_NODELIST_t *, uint8_t);
+int lpfc_issue_els_scr(lpfcHBA_t *, uint32_t, uint8_t);
+int lpfc_issue_els_farp(lpfcHBA_t *, uint8_t *, LPFC_FARP_ADDR_TYPE);
+int lpfc_issue_els_farpr(lpfcHBA_t *, uint32_t, uint8_t);
+LPFC_IOCBQ_t *lpfc_prep_els_iocb(lpfcHBA_t *, uint8_t expectRsp,
+				uint16_t, uint8_t, LPFC_NODELIST_t *, uint32_t);
+int lpfc_els_free_iocb(lpfcHBA_t *, LPFC_IOCBQ_t *);
+void lpfc_cmpl_els_flogi(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_IOCBQ_t *);
+void lpfc_cmpl_els_plogi(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_IOCBQ_t *);
+void lpfc_cmpl_els_prli(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_IOCBQ_t *);
+void lpfc_cmpl_els_adisc(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_IOCBQ_t *);
+void lpfc_cmpl_els_logo(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_IOCBQ_t *);
+void lpfc_cmpl_els_cmd(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_IOCBQ_t *);
+void lpfc_cmpl_els_acc(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_IOCBQ_t *);
+void lpfc_cmpl_els_logo_acc(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_IOCBQ_t *);
+int lpfc_els_rsp_acc(lpfcHBA_t *, uint32_t, LPFC_IOCBQ_t *,
+		     LPFC_NODELIST_t *, LPFC_MBOXQ_t *, uint8_t);
+int lpfc_els_rsp_reject(lpfcHBA_t *, uint32_t, LPFC_IOCBQ_t *,
+			LPFC_NODELIST_t *);
+int lpfc_els_rsp_adisc_acc(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_NODELIST_t *);
+int lpfc_els_rsp_prli_acc(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_NODELIST_t *);
+int lpfc_els_retry(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_IOCBQ_t *);
+void lpfc_els_retry_delay(unsigned long);
+void lpfc_els_unsol_event(lpfcHBA_t *, LPFC_SLI_RING_t *, LPFC_IOCBQ_t *);
+int lpfc_els_chk_latt(lpfcHBA_t *, LPFC_IOCBQ_t *);
+int lpfc_els_handle_rscn(lpfcHBA_t *);
+void lpfc_more_adisc(lpfcHBA_t *);
+void lpfc_more_plogi(lpfcHBA_t *);
+int lpfc_els_flush_rscn(lpfcHBA_t *);
+void lpfc_els_flush_cmd(lpfcHBA_t *);
+int lpfc_rscn_payload_check(lpfcHBA_t *, uint32_t);
+void lpfc_els_timeout_handler(unsigned long ptr);
+
+
+void lpfc_ct_unsol_event(lpfcHBA_t *, LPFC_SLI_RING_t *, LPFC_IOCBQ_t *);
+int lpfc_ns_cmd(lpfcHBA_t *, LPFC_NODELIST_t *, int);
+int lpfc_ct_cmd(lpfcHBA_t *, DMABUF_t *, DMABUF_t *,
+		LPFC_NODELIST_t *, void (*cmpl) (struct lpfcHBA *,
+						 LPFC_IOCBQ_t *,
+						 LPFC_IOCBQ_t *),
+		uint32_t);
+int lpfc_free_ct_rsp(lpfcHBA_t *, DMABUF_t *);
+int lpfc_ns_rsp(lpfcHBA_t *, DMABUF_t *, uint32_t);
+int lpfc_issue_ct_rsp(lpfcHBA_t *, uint32_t, DMABUF_t *, DMABUFEXT_t *);
+int lpfc_gen_req(lpfcHBA_t *, DMABUF_t *, DMABUF_t *, DMABUF_t *,
+		 void (*cmpl) (struct lpfcHBA *, LPFC_IOCBQ_t *,
+			       LPFC_IOCBQ_t *),
+		 LPFC_NODELIST_t *, uint32_t, uint32_t, uint32_t);
+void lpfc_cmpl_ct_cmd_gid_ft(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_IOCBQ_t *);
+void lpfc_cmpl_ct_cmd_rft_id(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_IOCBQ_t *);
+void lpfc_cmpl_ct_cmd_rnn_id(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_IOCBQ_t *);
+void lpfc_cmpl_ct_cmd_rsnn_nn(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_IOCBQ_t *);
+int lpfc_fdmi_cmd(lpfcHBA_t *, LPFC_NODELIST_t *, int);
+void lpfc_cmpl_ct_cmd_fdmi(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_IOCBQ_t *);
+void lpfc_fdmi_tmo(unsigned long);
+
+int lpfc_config_port_prep(lpfcHBA_t *);
+int lpfc_config_port_post(lpfcHBA_t *);
+int lpfc_hba_down_prep(lpfcHBA_t *);
+void lpfc_handle_eratt(lpfcHBA_t *, uint32_t);
+void lpfc_handle_latt(lpfcHBA_t *);
+void lpfc_hba_init(lpfcHBA_t *);
+int lpfc_post_buffer(lpfcHBA_t *, LPFC_SLI_RING_t *, int, int);
+void lpfc_cleanup(lpfcHBA_t *, uint32_t);
+int lpfc_online(lpfcHBA_t *);
+int lpfc_offline(lpfcHBA_t *);
+int lpfc_scsi_free(lpfcHBA_t *);
+int lpfc_parse_binding_entry(lpfcHBA_t *, uint8_t *, uint8_t *,
+			     int, int, int, unsigned int *, int, int *);
+void lpfc_decode_firmware_rev(lpfcHBA_t *, char *, int);
+uint8_t *lpfc_get_lpfchba_info(lpfcHBA_t *, uint8_t *);
+int lpfc_fcp_abort(lpfcHBA_t *, int, int, int);
+int lpfc_put_event(lpfcHBA_t *, uint32_t, uint32_t, void *, void *);
+int lpfc_hba_put_event(lpfcHBA_t *, uint32_t, uint32_t, uint32_t, uint32_t,
+		      uint32_t);
+void lpfc_get_hba_model_desc(lpfcHBA_t *, uint8_t *, uint8_t *);
+void lpfc_get_hba_sym_node_name(lpfcHBA_t *, uint8_t *);
+
+
+int lpfc_sli_queue_setup(lpfcHBA_t *);
+void lpfc_slim_access(lpfcHBA_t *);
+
+
+int lpfc_utsname_nodename_check(void);
+void lpfc_ip_timeout_handler(unsigned long);
+uint32_t fc_get_cfg_param(int, int);
+
+void lpfc_qthrottle_up(unsigned long);
+void lpfc_npr_timeout(unsigned long);
+void lpfc_scsi_assign_rpi(lpfcHBA_t *, LPFCSCSITARGET_t *, uint16_t);
+int lpfc_scsi_hba_reset(lpfcHBA_t *, LPFC_SCSI_BUF_t *);
+void lpfc_scsi_issue_inqsn(lpfcHBA_t *, void *, void *);
+void lpfc_scsi_issue_inqp0(lpfcHBA_t *, void *, void *);
+void lpfc_scsi_timeout_handler(unsigned long);
+
+uint32_t lpfc_intr_prep(struct lpfcHBA *);
+void lpfc_handle_eratt(struct lpfcHBA *, uint32_t);
+void lpfc_handle_latt(struct lpfcHBA *);
+irqreturn_t lpfc_intr_handler(int, void *, struct pt_regs *);
+
+uint32_t lpfc_read_pci(struct lpfcHBA *, int);
+void lpfc_setup_slim_access(struct lpfcHBA *);
+
+void lpfc_read_rev(lpfcHBA_t *, LPFC_MBOXQ_t *);
+void lpfc_config_ring(lpfcHBA_t *, int, LPFC_MBOXQ_t *);
+int lpfc_config_port(lpfcHBA_t *, LPFC_MBOXQ_t *);
+void lpfc_mbox_put(lpfcHBA_t *, LPFC_MBOXQ_t *);
+LPFC_MBOXQ_t *lpfc_mbox_get(lpfcHBA_t *);
+
+int lpfc_mem_alloc(lpfcHBA_t *);
+int lpfc_mem_free(lpfcHBA_t *);
+
+int lpfc_sli_hba_setup(lpfcHBA_t *);
+int lpfc_sli_hba_down(lpfcHBA_t *);
+int lpfc_sli_ring_map(lpfcHBA_t *);
+int lpfc_sli_intr(lpfcHBA_t *);
+int lpfc_sli_issue_mbox(lpfcHBA_t *, LPFC_MBOXQ_t *, uint32_t);
+void lpfc_mbox_abort(lpfcHBA_t *);
+int lpfc_sli_issue_iocb(lpfcHBA_t *, LPFC_SLI_RING_t *, LPFC_IOCBQ_t *,
+			uint32_t);
+int lpfc_sli_resume_iocb(lpfcHBA_t *, LPFC_SLI_RING_t *);
+int lpfc_sli_brdreset(lpfcHBA_t *);
+int lpfc_sli_setup(lpfcHBA_t *);
+void lpfc_sli_pcimem_bcopy(uint32_t *, uint32_t *, uint32_t);
+int lpfc_sli_ringpostbuf_put(lpfcHBA_t *, LPFC_SLI_RING_t *, DMABUF_t *);
+DMABUF_t *lpfc_sli_ringpostbuf_get(lpfcHBA_t *, LPFC_SLI_RING_t *, dma_addr_t);
+uint32_t lpfc_sli_next_iotag(lpfcHBA_t *, LPFC_SLI_RING_t *);
+int lpfc_sli_abort_iocb(lpfcHBA_t *, LPFC_SLI_RING_t *, LPFC_IOCBQ_t *);
+int lpfc_sli_issue_abort_iotag32(lpfcHBA_t *, LPFC_SLI_RING_t *,
+				 LPFC_IOCBQ_t *);
+int lpfc_sli_abort_iocb_ring(lpfcHBA_t *, LPFC_SLI_RING_t *, uint32_t);
+int lpfc_sli_abort_iocb_ctx(lpfcHBA_t *, LPFC_SLI_RING_t *, uint32_t);
+int lpfc_sli_abort_iocb_context1(lpfcHBA_t *, LPFC_SLI_RING_t *, void *);
+int lpfc_sli_abort_iocb_lun(lpfcHBA_t *, LPFC_SLI_RING_t *, uint16_t, uint64_t);
+int lpfc_sli_abort_iocb_tgt(lpfcHBA_t *, LPFC_SLI_RING_t *, uint16_t);
+int lpfc_sli_abort_iocb_hba(lpfcHBA_t *, LPFC_SLI_RING_t *);
+
+void lpfc_start_timer(lpfcHBA_t *, unsigned long, struct timer_list *,
+	void (*func) (unsigned long), unsigned long, unsigned long); 
+void lpfc_stop_timer(struct clk_data *);
+
+
+void lpfc_sli_wake_iocb_wait(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_IOCBQ_t *);
+int lpfc_sli_issue_iocb_wait(lpfcHBA_t *, LPFC_SLI_RING_t *,
+			    LPFC_IOCBQ_t *, uint32_t, LPFC_IOCBQ_t *, uint32_t);
+int lpfc_sli_issue_mbox_wait(lpfcHBA_t *, LPFC_MBOXQ_t *, uint32_t);
+void lpfc_sli_wake_mbox_wait(lpfcHBA_t *, LPFC_MBOXQ_t *);
+int lpfc_sleep(lpfcHBA_t *, void *, long tmo);
+void lpfc_wakeup(lpfcHBA_t *, void *);
+
+int lpfc_os_prep_io(lpfcHBA_t *, LPFC_SCSI_BUF_t *);
+LPFC_SCSI_BUF_t *lpfc_get_scsi_buf(lpfcHBA_t *);
+void lpfc_free_scsi_buf(LPFC_SCSI_BUF_t *);
+LPFCSCSILUN_t *lpfc_find_lun_device(LPFC_SCSI_BUF_t *);
+void lpfc_map_fcp_cmnd_to_bpl(lpfcHBA_t *, LPFC_SCSI_BUF_t *);
+void lpfc_free_scsi_cmd(LPFC_SCSI_BUF_t *);
+uint32_t lpfc_os_timeout_transform(lpfcHBA_t *, uint32_t);
+void lpfc_os_return_scsi_cmd(lpfcHBA_t *, LPFC_SCSI_BUF_t *);
+int lpfc_scsi_cmd_start(LPFC_SCSI_BUF_t *);
+int lpfc_scsi_prep_task_mgmt_cmd(lpfcHBA_t *, LPFC_SCSI_BUF_t *, uint8_t);
+int lpfc_scsi_cmd_abort(lpfcHBA_t *, LPFC_SCSI_BUF_t *);
+int lpfc_scsi_lun_reset(LPFC_SCSI_BUF_t *, lpfcHBA_t *, uint32_t,
+		       uint32_t, uint64_t, uint32_t);
+int lpfc_scsi_tgt_reset(LPFC_SCSI_BUF_t *, lpfcHBA_t *, uint32_t,
+		       uint32_t, uint32_t);
+
+int lpfc_get_inst_by_phba(lpfcHBA_t *);
+lpfcHBA_t *lpfc_get_phba_by_inst(int);
+int lpfc_check_valid_phba(lpfcHBA_t * phba);
+
+void lpfc_qfull_retry(unsigned long);
+void lpfc_scsi_lower_lun_qthrottle(lpfcHBA_t *, LPFC_SCSI_BUF_t *);
+
+void lpfc_sched_init_hba(lpfcHBA_t *, uint16_t);
+void lpfc_sched_target_init(LPFCSCSITARGET_t *, uint16_t);
+void lpfc_sched_lun_init(LPFCSCSILUN_t *, uint16_t);
+int lpfc_sched_submit_command(lpfcHBA_t *, LPFC_SCSI_BUF_t *);
+void lpfc_sched_queue_command(lpfcHBA_t *, LPFC_SCSI_BUF_t *);
+void lpfc_sched_add_target_to_ring(lpfcHBA_t *, LPFCSCSITARGET_t *);
+void lpfc_sched_remove_target_from_ring(lpfcHBA_t *, LPFCSCSITARGET_t *);
+void lpfc_sched_add_lun_to_ring(lpfcHBA_t *, LPFCSCSILUN_t *);
+void lpfc_sched_remove_lun_from_ring(lpfcHBA_t *, LPFCSCSILUN_t *);
+int lpfc_sli_issue_iocb_wait_high_priority(lpfcHBA_t * phba,
+					  LPFC_SLI_RING_t * pring,
+					  LPFC_IOCBQ_t * piocb, uint32_t flag,
+					  LPFC_IOCBQ_t * prspiocbq,
+					  uint32_t timeout);
+void lpfc_sched_service_high_priority_queue(struct lpfcHBA *hba);
+void lpfc_sli_wake_iocb_high_priority(lpfcHBA_t * phba, LPFC_IOCBQ_t * queue1,
+				     LPFC_IOCBQ_t * queue2);
+void *lpfc_page_alloc(lpfcHBA_t *, int, dma_addr_t *);
+void lpfc_page_free(lpfcHBA_t *, void *, dma_addr_t);
+void *lpfc_mbuf_alloc(lpfcHBA_t *, int, dma_addr_t *);
+void lpfc_mbuf_free(lpfcHBA_t *, void *, dma_addr_t);
+
+LPFC_MBOXQ_t *lpfc_mbox_alloc(lpfcHBA_t *, int);
+void lpfc_mbox_free(lpfcHBA_t *, LPFC_MBOXQ_t *);
+
+LPFC_IOCBQ_t *lpfc_iocb_alloc(lpfcHBA_t *, int);
+void lpfc_iocb_free(lpfcHBA_t *, LPFC_IOCBQ_t *);
+
+LPFC_NODELIST_t *lpfc_nlp_alloc(lpfcHBA_t *, int);
+void lpfc_nlp_free(lpfcHBA_t *, LPFC_NODELIST_t *);
+
+LPFC_BINDLIST_t *lpfc_bind_alloc(lpfcHBA_t *, int);
+void lpfc_bind_free(lpfcHBA_t *, LPFC_BINDLIST_t *);
+
+
+void lpfc_sleep_ms(lpfcHBA_t *, int);
+void lpfc_drvr_init_lock(lpfcHBA_t *);
+void lpfc_drvr_lock(lpfcHBA_t *, unsigned long *);
+void lpfc_drvr_unlock(lpfcHBA_t *, unsigned long *);
+void lpfc_hipri_init_lock(lpfcHBA_t *);
+void lpfc_hipri_lock(lpfcHBA_t *, unsigned long *);
+void lpfc_hipri_unlock(lpfcHBA_t *, unsigned long *);
+
+uint32_t lpfc_read_pci(lpfcHBA_t *, int);
+
+void lpfc_nodev(unsigned long);
+
+void lpfc_iodone(lpfcHBA_t *, LPFC_SCSI_BUF_t *);
+void lpfc_scsi_done(lpfcHBA_t *, struct scsi_cmnd *);
+int lpfc_scsi_delay_iodone(lpfcHBA_t *, LPFC_SCSI_BUF_t *);
+void lpfc_unblock_requests(lpfcHBA_t *);
+void lpfc_block_requests(lpfcHBA_t *);
+void myprint(char *, void *, void *, void *, void *);
+
+void lpfc_set_pkt_len(struct sk_buff *, uint32_t);
+void *lpfc_get_pkt_data(struct sk_buff *);
+
+void lpfc_scsi_cmd_iocb_cmpl(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_IOCBQ_t *);
+
+/* Function prototypes. */
+int lpfc_revoke(struct scsi_device *pScsiDevice);
+int lpfc_queuecommand(struct scsi_cmnd *, void (*done) (struct scsi_cmnd *));
+int lpfc_abort_handler(struct scsi_cmnd *);
+int lpfc_reset_lun_handler(struct scsi_cmnd *);
+
+#endif				/* _H_LPFC_CRTN */
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_ct.c linux-8155/drivers/addon/lpfc/lpfc_ct.c
--- linux-8152/drivers/addon/lpfc/lpfc_ct.c
+++ linux-8155/drivers/addon/lpfc/lpfc_ct.c
@@ -0,0 +1,1674 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_ct.c 437 2005-11-01 17:11:04Z sf_support $
+ *
+ * Fibre Channel SCSI LAN Device Driver CT support
+ */
+
+
+#include <linux/version.h>
+#include <linux/spinlock.h>
+#include <linux/utsname.h>
+#include <linux/pci.h>
+#include <linux/utsname.h>
+
+
+#include <linux/blk.h>
+
+#include "lpfc_version.h"
+#include "lpfc_hw.h"
+#include "lpfc_sli.h"
+#include "lpfc_mem.h"
+
+#include "lpfc_sched.h"
+#include "lpfc_disc.h"
+#include "lpfc_logmsg.h"
+#include "lpfc_scsi.h"
+#include "lpfc.h"
+#include "lpfc_crtn.h"
+#include "lpfc_cfgparm.h"
+#include "lpfc_dfc.h"
+#include "hbaapi.h"
+
+#define FOURBYTES	4
+
+
+extern char *lpfc_release_version;
+
+DMABUF_t *lpfc_alloc_ct_rsp(lpfcHBA_t *, int, ULP_BDE64 *, uint32_t, int *);
+
+
+
+/*
+ * lpfc_ct_unsol_event
+ */
+void
+lpfc_ct_unsol_event(lpfcHBA_t * phba,
+		    LPFC_SLI_RING_t * pring, LPFC_IOCBQ_t * piocbq)
+{
+
+	LPFC_SLI_t *psli;
+	DMABUF_t *p_mbuf = 0;
+	DMABUF_t *matp;
+	uint32_t ctx;
+	uint32_t count;
+	IOCB_t *icmd;
+	int i;
+	int status;
+	int go_exit = 0;
+	struct list_head head, *curr, *next;
+
+	psli = &phba->sli;
+	icmd = &piocbq->iocb;
+	if (icmd->ulpStatus) {
+		goto exit_unsol_event;
+	}
+
+	ctx = 0;
+	count = 0;
+	list_add_tail(&head, &piocbq->list);
+	list_for_each_safe(curr, next, &head) {
+		piocbq = list_entry(curr, LPFC_IOCBQ_t, list);
+		piocbq = (LPFC_IOCBQ_t *) curr;
+		icmd = &piocbq->iocb;
+		if (ctx == 0)
+			ctx = (uint32_t) (icmd->ulpContext);
+		if (icmd->ulpStatus) {
+			if ((icmd->ulpStatus == IOSTAT_LOCAL_REJECT) &&
+				((icmd->un.ulpWord[4] & 0xff)
+				 == IOERR_RCV_BUFFER_WAITING)) {
+				phba->fc_stat.NoRcvBuf++;
+
+				phba->fc_flag |= FC_NO_RCV_BUF;
+				lpfc_post_buffer(phba, pring, 0, 1);
+			}
+
+			go_exit = 1;
+			break;
+		}
+
+		if (icmd->ulpBdeCount == 0) {
+			continue;
+		}
+
+		for (i = 0; i < (int)icmd->ulpBdeCount; i++) {
+			matp = lpfc_sli_ringpostbuf_get(phba, pring,
+							getPaddr(icmd->un.
+								 cont64[i].
+								 addrHigh,
+								 icmd->un.
+								 cont64[i].
+								 addrLow));
+			if (matp == 0) {
+				/* Insert lpfc log message here */
+				go_exit = 1;
+				break;
+			}
+
+			/* Typically for Unsolicited CT requests */
+			if (!p_mbuf) {
+				p_mbuf = matp;
+				INIT_LIST_HEAD(&p_mbuf->list);
+			} else
+				list_add_tail(&matp->list, &p_mbuf->list);
+
+			count += icmd->un.cont64[i].tus.f.bdeSize;
+		}
+
+		/* check for early exit from above for loop */
+		if (go_exit != 0)
+			break;
+
+		lpfc_post_buffer(phba, pring, i, 1);
+		icmd->ulpBdeCount = 0;
+	}
+
+	list_del(&head);
+
+	/*
+	 * if not early-exiting and there is p_mbuf,
+	 * then do  FC_REG_CT_EVENT for HBAAPI libdfc event handling
+	 */
+	if (go_exit == 0  &&  p_mbuf != 0) {
+		status = lpfc_put_event(phba, FC_REG_CT_EVENT, ctx,
+				       p_mbuf,
+				       (void *) (unsigned long)count);
+
+		if ( status) {
+			/* Need to free IOCB buffer ? */
+			return;
+		}
+	}
+
+exit_unsol_event:
+	if (p_mbuf) {
+		list_for_each_safe(curr, next, &p_mbuf->list) {
+			matp = list_entry(curr, DMABUF_t, list);
+			lpfc_mbuf_free(phba, matp->virt, matp->phys);
+			list_del(&matp->list);
+			kfree(matp);
+		}
+		lpfc_mbuf_free(phba, p_mbuf->virt, p_mbuf->phys);
+		kfree(p_mbuf);
+	}
+	return;
+}
+
+/*
+ * lpfc_ns_cmd
+ * Description:
+ *    Issue Cmd to NameServer
+ *       SLI_CTNS_GID_FT
+ *       LI_CTNS_RFT_ID
+ */
+int
+lpfc_ns_cmd(lpfcHBA_t * phba, LPFC_NODELIST_t * ndlp, int cmdcode)
+{
+	lpfcCfgParam_t *clp;
+	DMABUF_t *mp, *bmp;
+	SLI_CT_REQUEST *CtReq;
+	ULP_BDE64 *bpl;
+	void (*cmpl) (struct lpfcHBA *, LPFC_IOCBQ_t *, LPFC_IOCBQ_t *);
+	uint32_t rsp_size;
+
+	clp = &phba->config[0];
+
+	/* fill in BDEs for command */
+	/* Allocate buffer for command payload */
+	if ((mp = kmalloc(sizeof (DMABUF_t), GFP_ATOMIC)) == 0) {
+		return (1);
+	}
+	
+	INIT_LIST_HEAD(&mp->list);
+	if ((mp->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &(mp->phys))) == 0) {
+		kfree(mp);
+		return (1);
+	}
+
+	/* Allocate buffer for Buffer ptr list */
+	if ((bmp = kmalloc(sizeof (DMABUF_t), GFP_ATOMIC)) == 0) {
+		lpfc_mbuf_free(phba, mp->virt, mp->phys);
+		kfree(mp);
+		return (1);
+	}
+
+	INIT_LIST_HEAD(&bmp->list);
+	if ((bmp->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &(bmp->phys))) == 0) {
+		lpfc_mbuf_free(phba, mp->virt, mp->phys);
+		kfree(mp);
+		kfree(bmp);
+		return (1);
+	}
+
+	bpl = (ULP_BDE64 *) bmp->virt;
+	bpl->addrHigh = le32_to_cpu( putPaddrHigh(mp->phys) );
+	bpl->addrLow = le32_to_cpu( putPaddrLow(mp->phys) );
+	bpl->tus.f.bdeFlags = 0;
+	if (cmdcode == SLI_CTNS_GID_FT)
+		bpl->tus.f.bdeSize = GID_REQUEST_SZ;
+	else if (cmdcode == SLI_CTNS_RFT_ID)
+		bpl->tus.f.bdeSize = RFT_REQUEST_SZ;
+	else if (cmdcode == SLI_CTNS_RNN_ID)
+		bpl->tus.f.bdeSize = RNN_REQUEST_SZ;
+	else if (cmdcode == SLI_CTNS_RSNN_NN)
+		bpl->tus.f.bdeSize = RSNN_REQUEST_SZ;
+	else
+		bpl->tus.f.bdeSize = 0;
+
+	bpl->tus.w = le32_to_cpu(bpl->tus.w);
+	CtReq = (SLI_CT_REQUEST *) mp->virt;
+
+	/* NameServer Req */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0236, lpfc_mes0236,
+			lpfc_msgBlk0236.msgPreambleStr, cmdcode, phba->fc_flag,
+			phba->fc_rscn_id_cnt);
+
+	memset(CtReq, 0, sizeof (SLI_CT_REQUEST));
+	CtReq->RevisionId.bits.Revision = SLI_CT_REVISION;
+	CtReq->RevisionId.bits.InId = 0;
+
+	CtReq->FsType = SLI_CT_DIRECTORY_SERVICE;
+	CtReq->FsSubType = SLI_CT_DIRECTORY_NAME_SERVER;
+	CtReq->CommandResponse.bits.Size = 0;
+
+	cmpl = 0;
+	rsp_size = 1024;
+	switch (cmdcode) {
+	case SLI_CTNS_GID_FT:
+		CtReq->CommandResponse.bits.CmdRsp =
+		    be16_to_cpu(SLI_CTNS_GID_FT);
+		CtReq->un.gid.Fc4Type = SLI_CTPT_FCP;
+		if (phba->hba_state < LPFC_HBA_READY) {
+			phba->hba_state = LPFC_NS_QRY;
+		}
+		lpfc_set_disctmo(phba);
+		cmpl = lpfc_cmpl_ct_cmd_gid_ft;
+		rsp_size = FC_MAX_NS_RSP;
+		break;
+
+	case SLI_CTNS_RFT_ID:
+		CtReq->CommandResponse.bits.CmdRsp =
+		    be16_to_cpu(SLI_CTNS_RFT_ID);
+		CtReq->un.rft.PortId = be32_to_cpu(phba->fc_myDID);
+		CtReq->un.rft.fcpReg = 1;
+
+		cmpl = lpfc_cmpl_ct_cmd_rft_id;
+		break;
+
+	case SLI_CTNS_RNN_ID:
+		CtReq->CommandResponse.bits.CmdRsp =
+		    be16_to_cpu(SLI_CTNS_RNN_ID);
+		CtReq->un.rnn.PortId = be32_to_cpu(phba->fc_myDID);
+		memcpy(CtReq->un.rnn.wwnn, (uint8_t *) & phba->fc_nodename,
+		       sizeof (NAME_TYPE));
+		cmpl = lpfc_cmpl_ct_cmd_rnn_id;
+		break;
+
+	case SLI_CTNS_RSNN_NN:
+
+		CtReq->CommandResponse.bits.CmdRsp =
+		    be16_to_cpu(SLI_CTNS_RSNN_NN);
+		memcpy(CtReq->un.rsnn.wwnn, (uint8_t *) & phba->fc_nodename,
+		       sizeof (NAME_TYPE));
+		lpfc_get_hba_sym_node_name(phba,
+					  (uint8_t *) CtReq->un.rsnn.symbname);
+		CtReq->un.rsnn.len = strlen((char *)CtReq->un.rsnn.symbname);
+		cmpl = lpfc_cmpl_ct_cmd_rsnn_nn;
+		break;
+	}
+
+	if (lpfc_ct_cmd(phba, mp, bmp, ndlp, cmpl, rsp_size)) {
+		lpfc_mbuf_free(phba, mp->virt, mp->phys);
+		lpfc_mbuf_free(phba, bmp->virt, bmp->phys);
+		kfree(mp);
+		kfree(bmp);
+		return (1);
+	}
+
+	return (0);
+}
+
+int
+lpfc_ct_cmd(lpfcHBA_t * phba,
+	    DMABUF_t * inmp,
+	    DMABUF_t * bmp,
+	    LPFC_NODELIST_t *ndlp,
+	    void (*cmpl) (struct lpfcHBA *, LPFC_IOCBQ_t *, LPFC_IOCBQ_t *),
+	    uint32_t rsp_size)
+{
+	ULP_BDE64 *bpl;
+	DMABUF_t *outmp;
+	int cnt;
+	int cmdcode;
+
+	bpl = (ULP_BDE64 *) bmp->virt;
+	bpl++;			/* Skip past ct request */
+
+	cnt = 0;
+
+	cmdcode = ((SLI_CT_REQUEST *) inmp->virt)->CommandResponse.bits.CmdRsp;
+
+	/* Put buffer(s) for ct rsp in bpl */
+	if ((outmp = lpfc_alloc_ct_rsp(phba, cmdcode, bpl, rsp_size, &cnt))
+	    == 0) {
+		return (ENOMEM);
+	}
+
+	if ((lpfc_gen_req
+	     (phba, bmp, inmp, outmp, cmpl, ndlp, 0, (cnt + 1),
+	      0))) {
+		lpfc_free_ct_rsp(phba, outmp);
+		return (ENOMEM);
+	}
+	return (0);
+}
+
+int
+lpfc_free_ct_rsp(lpfcHBA_t * phba, DMABUF_t * mlist)
+{
+	DMABUF_t *mlast;
+	struct list_head *curr, *next;
+
+	list_for_each_safe(curr, next, &mlist->list) {
+		mlast = list_entry(curr, DMABUF_t, list);
+		lpfc_mbuf_free(phba, mlast->virt, mlast->phys);
+		list_del(&mlast->list);
+		kfree(mlast);
+	}
+
+	lpfc_mbuf_free(phba, mlist->virt, mlist->phys);
+	kfree(mlist);
+
+	return (0);
+}
+
+DMABUF_t *
+lpfc_alloc_ct_rsp(lpfcHBA_t * phba, int cmdcode, ULP_BDE64 * bpl, uint32_t size,
+		  int *entries)
+{
+	DMABUF_t *mlist;
+	DMABUF_t *mp;
+	int cnt, i;
+
+	mlist = 0;
+	i = 0;
+
+	while (size) {
+
+		/* We get chucks of FCELSSIZE */
+		if (size > FCELSSIZE)
+			cnt = FCELSSIZE;
+		else
+			cnt = size;
+
+		/* Allocate buffer for rsp payload */
+		if ((mp = kmalloc(sizeof(DMABUF_t), GFP_ATOMIC)) == 0) {
+			lpfc_free_ct_rsp(phba, mlist);
+			return (0);
+		}
+		
+		INIT_LIST_HEAD(&mp->list);		
+
+		if (cmdcode == be16_to_cpu(SLI_CTNS_GID_FT))
+			mp->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &(mp->phys));
+
+		else
+			mp->virt = lpfc_mbuf_alloc(phba, 0, &(mp->phys));
+
+		if (mp->virt == 0) {
+				kfree(mp);
+			lpfc_free_ct_rsp(phba, mlist);
+			return (0);
+		}
+				
+		/* Queue it to a linked list */
+		if (mlist)
+			list_add_tail(&mp->list, &mlist->list); 
+		else 
+			mlist = mp;
+
+		bpl->tus.f.bdeFlags = BUFF_USE_RCV;
+
+		/* build buffer ptr list for IOCB */
+		bpl->addrLow = le32_to_cpu( putPaddrLow(mp->phys) );
+		bpl->addrHigh = le32_to_cpu( putPaddrHigh(mp->phys) );
+		bpl->tus.f.bdeSize = (uint16_t) cnt;
+		bpl->tus.w = le32_to_cpu(bpl->tus.w);
+		bpl++;
+
+		i++;
+		size -= cnt;
+	}
+
+	*entries = i;
+	return (mlist);
+}
+
+int
+lpfc_ns_rsp(lpfcHBA_t * phba, DMABUF_t * mp, uint32_t Size)
+{
+	SLI_CT_REQUEST *Response;
+	LPFC_NODELIST_t *ndlp, *new_ndlp;
+	struct list_head *listp, *pos, *pos_tmp;
+	struct list_head *node_list[4];
+	DMABUF_t *mlast, *mhead;
+	uint32_t *ctptr;
+	uint32_t Did;
+	uint32_t CTentry;
+	int Cnt, new_node, i;
+	struct list_head head, *curr, *next;
+
+	ndlp = 0;
+
+	lpfc_set_disctmo(phba);
+
+	Response = (SLI_CT_REQUEST *) mp->virt;
+	ctptr = (uint32_t *) & Response->un.gid.PortType;
+
+	mhead = mp;
+	list_add_tail(&head, &mp->list);
+
+	list_for_each_safe(curr, next, &head) {
+		mp = list_entry(curr, DMABUF_t, list);
+		mlast = mp;
+
+		if (Size > FCELSSIZE)
+			Cnt = FCELSSIZE;
+		else
+			Cnt = Size;
+
+		Size -= Cnt;
+
+		if (ctptr == 0)
+			ctptr = (uint32_t *) mlast->virt;
+		else
+			Cnt -= 16;	/* subtract length of CT header */
+
+		/* Loop through entire NameServer list of DIDs */
+		while (Cnt) {
+
+			/* Get next DID from NameServer List */
+			CTentry = *ctptr++;
+			Did = ((be32_to_cpu(CTentry)) & Mask_DID);
+
+			/* If we are processing an RSCN, check to ensure the Did
+			 * falls under the juristiction of the RSCN payload.
+			 */
+			if (phba->hba_state == LPFC_HBA_READY) {
+				Did = lpfc_rscn_payload_check(phba, Did);
+				/* Did = 0 indicates Not part of RSCN, ignore
+				   this entry */
+			}
+
+			ndlp = 0;
+			if ((Did) && (Did != phba->fc_myDID)) {
+				new_node = 0;
+				/* Skip if the node is already in the plogi /
+				   adisc list */
+				if ((ndlp =
+				     lpfc_findnode_did(phba, (NLP_SEARCH_PLOGI |
+							      NLP_SEARCH_ADISC),
+						       Did)))
+					{
+						goto nsout0;
+					}
+				ndlp =
+				    lpfc_findnode_did(phba, NLP_SEARCH_ALL,
+						      Did);
+				if (ndlp) {
+					/*
+					 * Event NLP_EVT_DEVICE_ADD will trigger ADISC to be
+					 * sent to the N_port after receiving a LOGO from it.
+					 * Don't call state machine if NLP_LOGO_ACC is set
+					 * Let lpfc_cmpl_els_logo_acc() to handle this node
+					 */
+					if (!(ndlp->nlp_flag & NLP_LOGO_ACC) &&
+					    !(ndlp->nlp_flag & NLP_PRLI_SND)) {
+						lpfc_disc_state_machine(phba, ndlp, (void *)0,
+									NLP_EVT_DEVICE_ADD);
+					}
+				} else {
+					new_node = 1;
+					if ((ndlp = (LPFC_NODELIST_t *)
+					     lpfc_nlp_alloc(phba, 0))) {
+						memset(ndlp, 0,
+						       sizeof
+						       (LPFC_NODELIST_t));
+						ndlp->nlp_state =
+						    NLP_STE_UNUSED_NODE;
+						ndlp->nlp_DID = Did;
+						lpfc_disc_state_machine(phba,
+							ndlp, 0,
+							NLP_EVT_DEVICE_ADD);
+					}
+				}
+			}
+		      nsout0:
+			/* Mark all node table entries that are in the
+			   Nameserver */
+			if (ndlp) {
+				ndlp->nlp_flag |= NLP_NS_NODE;
+				/* NameServer Rsp */
+				lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0238,
+						lpfc_mes0238,
+						lpfc_msgBlk0238.msgPreambleStr,
+						Did, ndlp->nlp_flag,
+						phba->fc_flag,
+						phba->fc_rscn_id_cnt);
+			} else {
+				/* NameServer Rsp */
+				lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0239,
+						lpfc_mes0239,
+						lpfc_msgBlk0239.msgPreambleStr,
+						Did, Size, phba->fc_flag,
+						phba->fc_rscn_id_cnt);
+			}
+
+			if (CTentry & (be32_to_cpu(SLI_CT_LAST_ENTRY)))
+				goto nsout1;
+			Cnt -= sizeof (uint32_t);
+		}
+		ctptr = 0;
+
+	}
+
+      nsout1:
+	list_del(&head);
+	/* Take out all node table entries that are not in the NameServer.  To
+	 * begin, start with a populated list.
+	 */
+	node_list[0] = &phba->fc_plogi_list;
+	node_list[1] = &phba->fc_adisc_list;
+	node_list[2] = &phba->fc_nlpunmap_list;
+	node_list[3] = &phba->fc_nlpmap_list;
+	for (i = 0; i < 4; i++) {
+		listp = node_list[i];
+		if (list_empty(listp)) 
+			continue;
+
+		list_for_each_safe(pos, pos_tmp, listp) {
+			new_ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			ndlp     = new_ndlp;
+			if ((ndlp->nlp_DID == phba->fc_myDID) ||
+			    (ndlp->nlp_DID == NameServer_DID) ||
+			    (ndlp->nlp_DID == FDMI_DID)       ||
+			    (ndlp->nlp_type & NLP_FABRIC) ||
+			    (ndlp->nlp_flag & NLP_NS_NODE)) {
+				if (ndlp->nlp_flag & NLP_NS_NODE) {
+					ndlp->nlp_flag &= ~NLP_NS_NODE;
+				}
+				continue;
+			}
+
+			/* If the driver is processing an RSCN, check to ensure
+			 * the Did falls under the juristiction of the RSCN
+			 * payload.
+			 */
+			if ((phba->hba_state == LPFC_HBA_READY) &&
+			    (!(lpfc_rscn_payload_check(phba, ndlp->nlp_DID)))) {
+				/* Not part of RSCN, ignore this entry */
+				continue;	
+			}
+
+			lpfc_disc_state_machine(phba, ndlp, 0,
+						NLP_EVT_DEVICE_RM);
+
+		}
+	}
+
+	if (phba->hba_state == LPFC_HBA_READY) {
+		lpfc_els_flush_rscn(phba);
+		phba->fc_flag |= FC_RSCN_MODE;
+	}
+	return (0);
+}
+
+int
+lpfc_issue_ct_rsp(lpfcHBA_t * phba,
+		  uint32_t tag, DMABUF_t * bmp, DMABUFEXT_t * inp)
+{
+	LPFC_SLI_t *psli;
+	IOCB_t *icmd;
+	LPFC_IOCBQ_t *ctiocb;
+	LPFC_SLI_RING_t *pring;
+	uint32_t num_entry;
+	int rc = 0;
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_ELS_RING];	/* ELS ring */
+	num_entry = (uint32_t) inp->flag;
+	inp->flag = 0;
+
+	/* Allocate buffer for  command iocb */
+	if ((ctiocb = lpfc_iocb_alloc(phba, 0)) == 0) {
+		return (ENOMEM);
+	}
+	memset(ctiocb, 0, sizeof (LPFC_IOCBQ_t));
+	icmd = &ctiocb->iocb;
+
+	icmd->un.xseq64.bdl.ulpIoTag32 = 0;
+	icmd->un.xseq64.bdl.addrHigh = putPaddrHigh(bmp->phys);
+	icmd->un.xseq64.bdl.addrLow = putPaddrLow(bmp->phys);
+	icmd->un.xseq64.bdl.bdeFlags = BUFF_TYPE_BDL;
+	icmd->un.xseq64.bdl.bdeSize = (num_entry * sizeof (ULP_BDE64));
+
+	icmd->un.xseq64.w5.hcsw.Fctl = (LS | LA);
+	icmd->un.xseq64.w5.hcsw.Dfctl = 0;
+	icmd->un.xseq64.w5.hcsw.Rctl = FC_SOL_CTL;
+	icmd->un.xseq64.w5.hcsw.Type = FC_COMMON_TRANSPORT_ULP;
+
+	icmd->ulpIoTag = lpfc_sli_next_iotag(phba, pring);
+
+	/* Fill in rest of iocb */
+	icmd->ulpCommand = CMD_XMIT_SEQUENCE64_CX;
+	icmd->ulpBdeCount = 1;
+	icmd->ulpLe = 1;
+	icmd->ulpClass = CLASS3;
+	icmd->ulpContext = (ushort) tag;
+	/* Xmit CT response on exchange <xid> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0118,
+			lpfc_mes0118, lpfc_msgBlk0118.msgPreambleStr,
+			icmd->ulpContext, icmd->ulpIoTag, phba->hba_state);
+
+	ctiocb->iocb_cmpl = 0;
+	ctiocb->iocb_flag |= LPFC_IO_LIBDFC;
+
+	rc = lpfc_sli_issue_iocb_wait(phba, pring, ctiocb, SLI_IOCB_USE_TXQ, 0,
+				     phba->fc_ratov * 2 + LPFC_DRVR_TIMEOUT);
+	lpfc_iocb_free(phba, ctiocb);
+	return (rc);
+}				/* lpfc_issue_ct_rsp */
+
+int
+lpfc_gen_req(lpfcHBA_t * phba,
+	     DMABUF_t * bmp,
+	     DMABUF_t * inp,
+	     DMABUF_t * outp,
+	     void (*cmpl) (struct lpfcHBA *, LPFC_IOCBQ_t *, LPFC_IOCBQ_t *),
+	     LPFC_NODELIST_t *ndlp, uint32_t usr_flg, uint32_t num_entry,
+	     uint32_t tmo)
+{
+
+	LPFC_SLI_t *psli;
+	LPFC_SLI_RING_t *pring;
+	IOCB_t *icmd;
+	LPFC_IOCBQ_t *geniocb;
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_ELS_RING];	/* ELS ring */
+	/* Allocate buffer for  command iocb */
+	if ((geniocb = lpfc_iocb_alloc(phba, 0)) == 0) {
+		return (1);
+	}
+	memset(geniocb, 0, sizeof (LPFC_IOCBQ_t));
+	icmd = &geniocb->iocb;
+
+	icmd->un.genreq64.bdl.ulpIoTag32 = 0;
+	icmd->un.genreq64.bdl.addrHigh = putPaddrHigh(bmp->phys);
+	icmd->un.genreq64.bdl.addrLow = putPaddrLow(bmp->phys);
+	icmd->un.genreq64.bdl.bdeFlags = BUFF_TYPE_BDL;
+	icmd->un.genreq64.bdl.bdeSize = (num_entry * sizeof (ULP_BDE64));
+
+	if (usr_flg)
+		geniocb->context3 = 0;
+	else
+		geniocb->context3 = (uint8_t *) bmp;
+
+	/* Save for completion so we can release these resources */
+	geniocb->context1 = (uint8_t *) inp;
+	geniocb->context2 = (uint8_t *) outp;
+
+	/* Fill in payload, bp points to frame payload */
+	icmd->ulpCommand = CMD_GEN_REQUEST64_CR;
+
+	icmd->ulpIoTag = lpfc_sli_next_iotag(phba, pring);
+
+	/* Fill in rest of iocb */
+	icmd->un.genreq64.w5.hcsw.Fctl = (SI | LA);
+	icmd->un.genreq64.w5.hcsw.Dfctl = 0;
+	icmd->un.genreq64.w5.hcsw.Rctl = FC_UNSOL_CTL;
+	icmd->un.genreq64.w5.hcsw.Type = FC_COMMON_TRANSPORT_ULP;
+
+	if (tmo == 0)
+		tmo = (2 * phba->fc_ratov) + 1;
+	icmd->ulpTimeout = tmo;
+	icmd->ulpBdeCount = 1;
+	icmd->ulpLe = 1;
+	icmd->ulpClass = CLASS3;
+	icmd->ulpContext = ndlp->nlp_rpi;
+
+	/* Issue GEN REQ IOCB for NPORT <did> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0119,
+			lpfc_mes0119, lpfc_msgBlk0119.msgPreambleStr,
+			icmd->un.ulpWord[5], icmd->ulpIoTag, phba->hba_state);
+	geniocb->iocb_cmpl = cmpl;
+	geniocb->drvrTimeout = icmd->ulpTimeout + LPFC_DRVR_TIMEOUT;
+	if (lpfc_sli_issue_iocb(phba, pring, geniocb, SLI_IOCB_USE_TXQ) ==
+	    IOCB_ERROR) {
+		lpfc_iocb_free(phba, geniocb);
+		return (1);
+	}
+
+	return (0);
+}
+
+void
+lpfc_cmpl_ct_cmd_gid_ft(lpfcHBA_t * phba,
+			LPFC_IOCBQ_t * cmdiocb, LPFC_IOCBQ_t * rspiocb)
+{
+	IOCB_t *irsp;
+	LPFC_SLI_t *psli;
+	DMABUF_t *bmp;
+	DMABUF_t *inp;
+	DMABUF_t *outp;
+	LPFC_NODELIST_t *ndlp;
+	SLI_CT_REQUEST *CTrsp;
+
+	psli = &phba->sli;
+	/* we pass cmdiocb to state machine which needs rspiocb as well */
+	cmdiocb->context_un.rsp_iocb = rspiocb; 
+
+	inp = (DMABUF_t *) cmdiocb->context1;
+	outp = (DMABUF_t *) cmdiocb->context2;
+	bmp = (DMABUF_t *) cmdiocb->context3;
+
+	irsp = &rspiocb->iocb;
+
+	/*
+	 * If the iocb is aborted by the driver do not retry it.
+	 */
+        if ((irsp->ulpStatus ) &&
+            ((irsp->un.ulpWord[4] == IOERR_SLI_DOWN)||
+	     (irsp->un.ulpWord[4] == IOERR_SLI_ABORTED)))
+                goto out;
+
+	if (irsp->ulpStatus) {
+		/* Check for retry */
+		if (phba->fc_ns_retry < LPFC_MAX_NS_RETRY) {
+			phba->fc_ns_retry++;
+			/* CT command is being retried */
+			ndlp =
+			    lpfc_findnode_did(phba, NLP_SEARCH_UNMAPPED,
+					      NameServer_DID);
+			if (ndlp) {
+				if (lpfc_ns_cmd(phba, ndlp, SLI_CTNS_GID_FT) ==
+				    0) {
+					goto out;
+				}
+			}
+		}
+	} else {
+		/* Good status, continue checking */
+		CTrsp = (SLI_CT_REQUEST *) outp->virt;
+		if (CTrsp->CommandResponse.bits.CmdRsp ==
+		    be16_to_cpu(SLI_CT_RESPONSE_FS_ACC)) {
+			lpfc_ns_rsp(phba, outp,
+				    (uint32_t) (irsp->un.genreq64.bdl.bdeSize));
+		} else if (CTrsp->CommandResponse.bits.CmdRsp ==
+			   be16_to_cpu(SLI_CT_RESPONSE_FS_RJT)) {
+			/* NameServer Rsp Error */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0240,
+					lpfc_mes0240,
+					lpfc_msgBlk0240.msgPreambleStr,
+					CTrsp->CommandResponse.bits.CmdRsp,
+					(uint32_t) CTrsp->ReasonCode,
+					(uint32_t) CTrsp->Explanation,
+					phba->fc_flag);
+		} else {
+			/* NameServer Rsp Error */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0241,
+					lpfc_mes0241,
+					lpfc_msgBlk0241.msgPreambleStr,
+					CTrsp->CommandResponse.bits.CmdRsp,
+					(uint32_t) CTrsp->ReasonCode,
+					(uint32_t) CTrsp->Explanation,
+					phba->fc_flag);
+		}
+	}
+	/* Link up / RSCN discovery */
+	lpfc_disc_start(phba);
+      out:
+	lpfc_free_ct_rsp(phba, outp);
+	lpfc_mbuf_free(phba, inp->virt, inp->phys);
+	lpfc_mbuf_free(phba, bmp->virt, bmp->phys);
+	kfree(inp);
+	kfree(bmp);
+	lpfc_iocb_free(phba, cmdiocb);
+	return;
+}
+
+void
+lpfc_cmpl_ct_cmd_rft_id(lpfcHBA_t * phba,
+			LPFC_IOCBQ_t * cmdiocb, LPFC_IOCBQ_t * rspiocb)
+{
+	LPFC_SLI_t *psli;
+	DMABUF_t *bmp;
+	DMABUF_t *inp;
+	DMABUF_t *outp;
+	IOCB_t *irsp;
+	SLI_CT_REQUEST *CTrsp;
+
+	psli = &phba->sli;
+	/* we pass cmdiocb to state machine which needs rspiocb as well */
+	cmdiocb->context_un.rsp_iocb = rspiocb; 
+
+	inp = (DMABUF_t *) cmdiocb->context1;
+	outp = (DMABUF_t *) cmdiocb->context2;
+	bmp = (DMABUF_t *) cmdiocb->context3;
+	irsp = &rspiocb->iocb;
+
+	CTrsp = (SLI_CT_REQUEST *) outp->virt;
+
+	/* RFT request completes status <ulpStatus> CmdRsp <CmdRsp> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0209,
+			lpfc_mes0209, lpfc_msgBlk0209.msgPreambleStr,
+			irsp->ulpStatus, CTrsp->CommandResponse.bits.CmdRsp);
+
+	lpfc_free_ct_rsp(phba, outp);
+	lpfc_mbuf_free(phba, inp->virt, inp->phys);
+	lpfc_mbuf_free(phba, bmp->virt, bmp->phys);
+	kfree(inp);
+	kfree(bmp);
+	lpfc_iocb_free(phba, cmdiocb);
+	return;
+}
+
+void
+lpfc_cmpl_ct_cmd_rnn_id(lpfcHBA_t * phba,
+			LPFC_IOCBQ_t * cmdiocb, LPFC_IOCBQ_t * rspiocb)
+{
+	lpfc_cmpl_ct_cmd_rft_id(phba, cmdiocb, rspiocb);
+	return;
+}
+
+void
+lpfc_cmpl_ct_cmd_rsnn_nn(lpfcHBA_t * phba,
+			 LPFC_IOCBQ_t * cmdiocb, LPFC_IOCBQ_t * rspiocb)
+{
+	lpfc_cmpl_ct_cmd_rft_id(phba, cmdiocb, rspiocb);
+	return;
+}
+
+void
+lpfc_get_os_nameversion(int cmd, char *osversion)
+{
+
+	memset(osversion, 0, 256);
+
+	switch (cmd) {
+	case GET_OS_VERSION:
+		sprintf(osversion, "%s %s %s",
+			system_utsname.sysname, system_utsname.release,
+			system_utsname.version);
+		break;
+	case GET_HOST_NAME:
+		sprintf(osversion, "%s", system_utsname.nodename);
+		break;
+	}
+	return ;
+}
+
+int
+lpfc_fdmi_cmd(lpfcHBA_t * phba, LPFC_NODELIST_t * ndlp, int cmdcode)
+{
+	lpfcCfgParam_t *clp;
+	DMABUF_t *mp, *bmp;
+	SLI_CT_REQUEST *CtReq;
+	ULP_BDE64 *bpl;
+	uint32_t size;
+	PREG_HBA rh;
+	PPORT_ENTRY pe;
+	PREG_PORT_ATTRIBUTE pab;
+	PATTRIBUTE_BLOCK ab;
+	PATTRIBUTE_ENTRY ae;
+	void (*cmpl) (struct lpfcHBA *, LPFC_IOCBQ_t *, LPFC_IOCBQ_t *);
+
+	clp = &phba->config[0];
+
+	/* fill in BDEs for command */
+	/* Allocate buffer for command payload */
+	if (((mp = kmalloc(sizeof (DMABUF_t), GFP_ATOMIC)) == 0) ||
+	    ((mp->virt = lpfc_mbuf_alloc(phba, 0, &(mp->phys))) == 0)) {
+		if (mp)
+			kfree(mp);
+		/* Issue FDMI request failed */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0219,
+				lpfc_mes0219, lpfc_msgBlk0219.msgPreambleStr,
+				cmdcode);
+		return (1);
+	}
+
+	/* Allocate buffer for Buffer ptr list */
+	if (((bmp = kmalloc(sizeof (DMABUF_t), GFP_ATOMIC)) == 0) ||
+	    ((bmp->virt = lpfc_mbuf_alloc(phba, 0, &(bmp->phys))) == 0)) {
+		if (bmp)
+			kfree(bmp);
+		lpfc_mbuf_free(phba, mp->virt, mp->phys);
+		kfree(mp);
+		/* Issue FDMI request failed */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0243,
+			       lpfc_mes0243, lpfc_msgBlk0243.msgPreambleStr,
+			       cmdcode);
+		return (1);
+	}
+
+	INIT_LIST_HEAD(&mp->list);
+	INIT_LIST_HEAD(&bmp->list);
+	/* FDMI request */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0218,
+		       lpfc_mes0218, lpfc_msgBlk0218.msgPreambleStr,
+		       phba->fc_flag, phba->hba_state, cmdcode);
+
+	CtReq = (SLI_CT_REQUEST *) mp->virt;
+
+/*
+   memset((void *)CtReq, 0, sizeof(SLI_CT_REQUEST));
+*/
+	memset(CtReq, 0, 1024);
+	CtReq->RevisionId.bits.Revision = SLI_CT_REVISION;
+	CtReq->RevisionId.bits.InId = 0;
+
+	CtReq->FsType = SLI_CT_MANAGEMENT_SERVICE;
+	CtReq->FsSubType = SLI_CT_FDMI_Subtypes;
+	size = 0;
+
+#define FOURBYTES	4
+
+	switch (cmdcode) {
+	case SLI_MGMT_RHBA:
+		{
+			lpfc_vpd_t *vp;
+			char str[256];
+			char lpfc_fwrevision[32];
+			uint32_t i, j, incr;
+			int len;
+			uint8_t HWrev[8];
+
+			vp = &phba->vpd;
+
+			CtReq->CommandResponse.bits.CmdRsp =
+			    be16_to_cpu(SLI_MGMT_RHBA);
+			CtReq->CommandResponse.bits.Size = 0;
+			rh = (REG_HBA *) & CtReq->un.PortID;
+			memcpy((uint8_t *) & rh->hi.PortName,
+			       (uint8_t *) & phba->fc_sparam.portName,
+			       sizeof (NAME_TYPE));
+			/* One entry (port) per adapter */
+			rh->rpl.EntryCnt = be32_to_cpu(1);
+			memcpy((uint8_t *) & rh->rpl.pe,
+			       (uint8_t *) & phba->fc_sparam.portName,
+			       sizeof (NAME_TYPE));
+
+			/* point to the HBA attribute block */
+			size =
+			    sizeof (NAME_TYPE) + FOURBYTES + sizeof (NAME_TYPE);
+			ab = (ATTRIBUTE_BLOCK *) ((uint8_t *) rh + size);
+			ab->EntryCnt = 0;
+
+			/* Point to the beginning of the first HBA attribute
+			   entry */
+			/* #1 HBA attribute entry */
+			size += FOURBYTES;
+			ae = (ATTRIBUTE_ENTRY *) ((uint8_t *) rh + size);
+			ae->ad.bits.AttrType = be16_to_cpu(NODE_NAME);
+			ae->ad.bits.AttrLen =
+			    be16_to_cpu(FOURBYTES + sizeof (NAME_TYPE));
+			memcpy((uint8_t *) & ae->un.NodeName,
+			       (uint8_t *) & phba->fc_sparam.nodeName,
+			       sizeof (NAME_TYPE));
+			ab->EntryCnt++;
+			size += FOURBYTES + sizeof (NAME_TYPE);
+
+			/* #2 HBA attribute entry */
+			ae = (ATTRIBUTE_ENTRY *) ((uint8_t *) rh + size);
+			ae->ad.bits.AttrType = be16_to_cpu(MANUFACTURER);
+			strcpy((char *)ae->un.Manufacturer,
+			       "Emulex Corporation");
+			len = strlen((char *)ae->un.Manufacturer);
+			len += (len & 3) ? (4 - (len & 3)) : 4;
+			ae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + len);
+			ab->EntryCnt++;
+			size += FOURBYTES + len;
+
+			/* #3 HBA attribute entry */
+			ae = (ATTRIBUTE_ENTRY *) ((uint8_t *) rh + size);
+			ae->ad.bits.AttrType = be16_to_cpu(SERIAL_NUMBER);
+			strcpy((char *)ae->un.SerialNumber, phba->SerialNumber);
+			len = strlen((char *)ae->un.SerialNumber);
+			len += (len & 3) ? (4 - (len & 3)) : 4;
+			ae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + len);
+			ab->EntryCnt++;
+			size += FOURBYTES + len;
+
+			/* #4 HBA attribute entry */
+			ae = (ATTRIBUTE_ENTRY *) ((uint8_t *) rh + size);
+			ae->ad.bits.AttrType = be16_to_cpu(MODEL);
+			strcpy((char *)ae->un.Model, phba->ModelName);
+			len = strlen((char *)ae->un.Model);
+			len += (len & 3) ? (4 - (len & 3)) : 4;
+			ae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + len);
+			ab->EntryCnt++;
+			size += FOURBYTES + len;
+
+			/* #5 HBA attribute entry */
+			ae = (ATTRIBUTE_ENTRY *) ((uint8_t *) rh + size);
+			ae->ad.bits.AttrType = be16_to_cpu(MODEL_DESCRIPTION);
+			strcpy((char *)ae->un.ModelDescription, phba->ModelDesc);
+			len = strlen((char *)ae->un.ModelDescription);
+			len += (len & 3) ? (4 - (len & 3)) : 4;
+			ae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + len);
+			ab->EntryCnt++;
+			size += FOURBYTES + len;
+
+			/* #6 HBA attribute entry */
+			ae = (ATTRIBUTE_ENTRY *) ((uint8_t *) rh + size);
+			ae->ad.bits.AttrType = be16_to_cpu(HARDWARE_VERSION);
+			ae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + 8);
+			/* Convert JEDEC ID to ascii for hardware version */
+			incr = vp->rev.biuRev;
+			for (i = 0; i < 8; i++) {
+				j = (incr & 0xf);
+				if (j <= 9)
+					HWrev[7 - i] =
+					    (char)((uint8_t) 0x30 +
+						   (uint8_t) j);
+				else
+					HWrev[7 - i] =
+					    (char)((uint8_t) 0x61 +
+						   (uint8_t) (j - 10));
+				incr = (incr >> 4);
+			}
+			memcpy(ae->un.HardwareVersion, (uint8_t *) HWrev, 8);
+			ab->EntryCnt++;
+			size += FOURBYTES + 8;
+
+			/* #7 HBA attribute entry */
+			ae = (ATTRIBUTE_ENTRY *) ((uint8_t *) rh + size);
+			ae->ad.bits.AttrType = be16_to_cpu(DRIVER_VERSION);
+			strcpy((char *)ae->un.DriverVersion,
+			       (char *)lpfc_release_version);
+			len = strlen((char *)ae->un.DriverVersion);
+			len += (len & 3) ? (4 - (len & 3)) : 4;
+			ae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + len);
+			ab->EntryCnt++;
+			size += FOURBYTES + len;
+
+			/* #8 HBA attribute entry */
+			ae = (ATTRIBUTE_ENTRY *) ((uint8_t *) rh + size);
+			ae->ad.bits.AttrType = be16_to_cpu(OPTION_ROM_VERSION);
+			strcpy((char *)ae->un.OptionROMVersion,
+			       (char *)phba->OptionROMVersion);
+			len = strlen((char *)ae->un.OptionROMVersion);
+			len += (len & 3) ? (4 - (len & 3)) : 4;
+			ae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + len);
+			ab->EntryCnt++;
+			size += FOURBYTES + len;
+
+			/* #9 HBA attribute entry */
+			ae = (ATTRIBUTE_ENTRY *) ((uint8_t *) rh + size);
+			ae->ad.bits.AttrType = be16_to_cpu(FIRMWARE_VERSION);
+			lpfc_decode_firmware_rev(phba, lpfc_fwrevision, 1);
+			strcpy((char *)ae->un.FirmwareVersion,
+			       (char *)lpfc_fwrevision);
+			len = strlen((char *)ae->un.FirmwareVersion);
+			len += (len & 3) ? (4 - (len & 3)) : 4;
+			ae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + len);
+			ab->EntryCnt++;
+			size += FOURBYTES + len;
+
+			/* #10 HBA attribute entry */
+			ae = (ATTRIBUTE_ENTRY *) ((uint8_t *) rh + size);
+			ae->ad.bits.AttrType = be16_to_cpu(OS_NAME_VERSION);
+			lpfc_get_os_nameversion(GET_OS_VERSION, str);
+			strcpy((char *)ae->un.OsNameVersion, (char *)str);
+			len = strlen((char *)ae->un.OsNameVersion);
+			len += (len & 3) ? (4 - (len & 3)) : 4;
+			ae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + len);
+			ab->EntryCnt++;
+			size += FOURBYTES + len;
+
+			/* #11 HBA attribute entry */
+			ae = (ATTRIBUTE_ENTRY *) ((uint8_t *) rh + size);
+			ae->ad.bits.AttrType = be16_to_cpu(MAX_CT_PAYLOAD_LEN);
+			ae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + 4);
+			ae->un.MaxCTPayloadLen = (65 * 4096);
+			ab->EntryCnt++;
+			size += FOURBYTES + 4;
+
+			ab->EntryCnt = be32_to_cpu(ab->EntryCnt);
+			/* Total size */
+			size = GID_REQUEST_SZ - 4 + size;
+		}
+		break;
+
+	case SLI_MGMT_RPA:
+		{
+			lpfc_vpd_t *vp;
+			SERV_PARM *hsp;
+			char str[256];
+			int len;
+
+			vp = &phba->vpd;
+
+			CtReq->CommandResponse.bits.CmdRsp =
+			    be16_to_cpu(SLI_MGMT_RPA);
+			CtReq->CommandResponse.bits.Size = 0;
+			pab = (REG_PORT_ATTRIBUTE *) & CtReq->un.PortID;
+			size = sizeof (NAME_TYPE) + FOURBYTES;
+			memcpy((uint8_t *) & pab->PortName,
+			       (uint8_t *) & phba->fc_sparam.portName,
+			       sizeof (NAME_TYPE));
+			pab->ab.EntryCnt = 0;
+
+			/* #1 Port attribute entry */
+			ae = (ATTRIBUTE_ENTRY *) ((uint8_t *) pab + size);
+			ae->ad.bits.AttrType = be16_to_cpu(SUPPORTED_FC4_TYPES);
+			ae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + 32);
+			ae->un.SupportFC4Types[2] = 1;
+			ae->un.SupportFC4Types[7] = 1;
+			pab->ab.EntryCnt++;
+			size += FOURBYTES + 32;
+
+			/* #2 Port attribute entry */
+			ae = (ATTRIBUTE_ENTRY *) ((uint8_t *) pab + size);
+			ae->ad.bits.AttrType = be16_to_cpu(SUPPORTED_SPEED);
+			ae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + 4);
+			if (FC_JEDEC_ID(vp->rev.biuRev) == VIPER_JEDEC_ID)
+				ae->un.SupportSpeed = HBA_PORTSPEED_10GBIT;
+			else if ((FC_JEDEC_ID(vp->rev.biuRev) ==
+				  HELIOS_JEDEC_ID)
+				 || (FC_JEDEC_ID(vp->rev.biuRev) ==
+				     ZEPHYR_JEDEC_ID))
+				ae->un.SupportSpeed = HBA_PORTSPEED_4GBIT;
+			else if ((FC_JEDEC_ID(vp->rev.biuRev) ==
+				  CENTAUR_2G_JEDEC_ID)
+				 || (FC_JEDEC_ID(vp->rev.biuRev) ==
+				     PEGASUS_JEDEC_ID)
+				 || (FC_JEDEC_ID(vp->rev.biuRev) ==
+				     THOR_JEDEC_ID))
+				ae->un.SupportSpeed = HBA_PORTSPEED_2GBIT;
+			else
+				ae->un.SupportSpeed = HBA_PORTSPEED_1GBIT;
+			pab->ab.EntryCnt++;
+			size += FOURBYTES + 4;
+
+			/* #3 Port attribute entry */
+			ae = (ATTRIBUTE_ENTRY *) ((uint8_t *) pab + size);
+			ae->ad.bits.AttrType = be16_to_cpu(PORT_SPEED);
+			ae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + 4);
+			switch(phba->fc_linkspeed) {
+				case LA_1GHZ_LINK:
+					ae->un.PortSpeed = HBA_PORTSPEED_1GBIT;
+				break;
+				case LA_2GHZ_LINK:
+					ae->un.PortSpeed = HBA_PORTSPEED_2GBIT;
+				break;
+				case LA_4GHZ_LINK:
+					ae->un.PortSpeed = HBA_PORTSPEED_4GBIT;
+				break;
+				default:
+					ae->un.PortSpeed = HBA_PORTSPEED_UNKNOWN;
+				break;
+			}
+			pab->ab.EntryCnt++;
+			size += FOURBYTES + 4;
+
+			/* #4 Port attribute entry */
+			ae = (ATTRIBUTE_ENTRY *) ((uint8_t *) pab + size);
+			ae->ad.bits.AttrType = be16_to_cpu(MAX_FRAME_SIZE);
+			ae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + 4);
+			hsp = (SERV_PARM *) & phba->fc_sparam;
+			ae->un.MaxFrameSize =
+			    (((uint32_t) hsp->cmn.
+			      bbRcvSizeMsb) << 8) | (uint32_t) hsp->cmn.
+			    bbRcvSizeLsb;
+			pab->ab.EntryCnt++;
+			size += FOURBYTES + 4;
+
+			/* #5 Port attribute entry */
+			ae = (ATTRIBUTE_ENTRY *) ((uint8_t *) pab + size);
+			ae->ad.bits.AttrType = be16_to_cpu(OS_DEVICE_NAME);
+			strcpy((char *)ae->un.OsDeviceName, LPFC_DRIVER_NAME);
+			len = strlen((char *)ae->un.OsDeviceName);
+			len += (len & 3) ? (4 - (len & 3)) : 4;
+			ae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + len);
+			pab->ab.EntryCnt++;
+			size += FOURBYTES + len;
+
+			if (clp[LPFC_CFG_FDMI_ON].a_current == 2) {
+				/* #6 Port attribute entry */
+				ae = (ATTRIBUTE_ENTRY *) ((uint8_t *) pab +
+							  size);
+				ae->ad.bits.AttrType = be16_to_cpu(HOST_NAME);
+				lpfc_get_os_nameversion(GET_HOST_NAME, str);
+				strcpy((char *)ae->un.HostName, (char *)str);
+				len = strlen((char *)ae->un.HostName);
+				len += (len & 3) ? (4 - (len & 3)) : 4;
+				ae->ad.bits.AttrLen =
+				    be16_to_cpu(FOURBYTES + len);
+				pab->ab.EntryCnt++;
+				size += FOURBYTES + len;
+			}
+
+			pab->ab.EntryCnt = be32_to_cpu(pab->ab.EntryCnt);
+			/* Total size */
+			size = GID_REQUEST_SZ - 4 + size;
+		}
+		break;
+
+	case SLI_MGMT_DHBA:
+		CtReq->CommandResponse.bits.CmdRsp = be16_to_cpu(SLI_MGMT_DHBA);
+		CtReq->CommandResponse.bits.Size = 0;
+		pe = (PORT_ENTRY *) & CtReq->un.PortID;
+		memcpy((uint8_t *) & pe->PortName,
+		       (uint8_t *) & phba->fc_sparam.portName,
+		       sizeof (NAME_TYPE));
+		size = GID_REQUEST_SZ - 4 + sizeof (NAME_TYPE);
+		break;
+
+	case SLI_MGMT_DPRT:
+		CtReq->CommandResponse.bits.CmdRsp = be16_to_cpu(SLI_MGMT_DPRT);
+		CtReq->CommandResponse.bits.Size = 0;
+		pe = (PORT_ENTRY *) & CtReq->un.PortID;
+		memcpy((uint8_t *) & pe->PortName,
+		       (uint8_t *) & phba->fc_sparam.portName,
+		       sizeof (NAME_TYPE));
+		size = GID_REQUEST_SZ - 4 + sizeof (NAME_TYPE);
+		break;
+	}
+
+	bpl = (ULP_BDE64 *) bmp->virt;
+	bpl->addrHigh = le32_to_cpu( putPaddrHigh(mp->phys) );
+	bpl->addrLow = le32_to_cpu( putPaddrLow(mp->phys) );
+	bpl->tus.f.bdeFlags = 0;
+	bpl->tus.f.bdeSize = size;
+	bpl->tus.w = le32_to_cpu(bpl->tus.w);
+
+	cmpl = lpfc_cmpl_ct_cmd_fdmi;
+
+	if (lpfc_ct_cmd(phba, mp, bmp, ndlp, cmpl, FC_MAX_NS_RSP)) {
+		lpfc_mbuf_free(phba, mp->virt, mp->phys);
+		lpfc_mbuf_free(phba, bmp->virt, bmp->phys);
+		kfree(mp);
+		kfree(bmp);
+		/* Issue FDMI request failed */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0244,
+			       lpfc_mes0244, lpfc_msgBlk0244.msgPreambleStr,
+			       cmdcode);
+		return (1);
+	}
+	return (0);
+}
+
+void
+lpfc_cmpl_ct_cmd_fdmi(lpfcHBA_t * phba,
+		      LPFC_IOCBQ_t * cmdiocb, LPFC_IOCBQ_t * rspiocb)
+{
+	DMABUF_t *bmp;
+	DMABUF_t *inp;
+	DMABUF_t *outp;
+	SLI_CT_REQUEST *CTrsp;
+	SLI_CT_REQUEST *CTcmd;
+	LPFC_NODELIST_t *ndlp;
+	uint16_t fdmi_cmd;
+	uint16_t fdmi_rsp;
+
+	inp = (DMABUF_t *) cmdiocb->context1;
+	outp = (DMABUF_t *) cmdiocb->context2;
+	bmp = (DMABUF_t *) cmdiocb->context3;
+
+	CTcmd = (SLI_CT_REQUEST *) inp->virt;
+	CTrsp = (SLI_CT_REQUEST *) outp->virt;
+
+	ndlp = lpfc_findnode_did(phba, NLP_SEARCH_ALL, FDMI_DID);
+
+	fdmi_rsp = CTrsp->CommandResponse.bits.CmdRsp;
+	fdmi_cmd = CTcmd->CommandResponse.bits.CmdRsp;
+
+	if (fdmi_rsp == be16_to_cpu(SLI_CT_RESPONSE_FS_RJT)) {
+		/* FDMI rsp failed */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0220,
+			       lpfc_mes0220, lpfc_msgBlk0220.msgPreambleStr,
+			       be16_to_cpu(fdmi_cmd));
+	}
+
+	switch (be16_to_cpu(fdmi_cmd)) {
+	case SLI_MGMT_RHBA:
+		lpfc_fdmi_cmd(phba, ndlp, SLI_MGMT_RPA);
+		break;
+
+	case SLI_MGMT_RPA:
+		break;
+
+	case SLI_MGMT_DHBA:
+		lpfc_fdmi_cmd(phba, ndlp, SLI_MGMT_DPRT);
+		break;
+
+	case SLI_MGMT_DPRT:
+		lpfc_fdmi_cmd(phba, ndlp, SLI_MGMT_RHBA);
+		break;
+	}
+
+	lpfc_free_ct_rsp(phba, outp);
+	lpfc_mbuf_free(phba, inp->virt, inp->phys);
+	lpfc_mbuf_free(phba, bmp->virt, bmp->phys);
+	kfree(inp);
+	kfree(bmp);
+	lpfc_iocb_free(phba, cmdiocb);
+	return;
+}
+
+void
+lpfc_fdmi_tmo(unsigned long ptr)
+{
+	lpfcHBA_t     *phba;
+	LPFC_NODELIST_t *ndlp;
+	struct clk_data *clkData;
+	unsigned long iflag;
+
+	clkData = (struct clk_data *)ptr;
+	phba = clkData->phba;
+	LPFC_DRVR_LOCK(phba, iflag);
+	if (clkData->flags & TM_CANCELED) {
+		list_del((struct list_head *)clkData);
+		kfree(clkData);	
+		goto out; 
+	}
+
+
+	ndlp = (LPFC_NODELIST_t *)clkData->clData1;
+	clkData->timeObj->function = 0;
+	list_del((struct list_head *)clkData);
+	kfree(clkData);
+
+	if (system_utsname.nodename[0] == '\0') {
+		lpfc_start_timer(phba, 60, &phba->fc_fdmitmo, lpfc_fdmi_tmo, 
+			(unsigned long)ndlp, (unsigned long)0);
+	} else {
+		phba->fc_fdmitmo.function = 0;
+		lpfc_fdmi_cmd(phba, ndlp, SLI_MGMT_DHBA);
+	}
+
+out:
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	return;
+}
+
+
+void
+lpfc_decode_firmware_rev(lpfcHBA_t * phba, char *fwrevision, int flag)
+{
+	LPFC_SLI_t *psli;
+	lpfc_vpd_t *vp;
+	uint32_t b1, b2, b3, b4, ldata;
+	char c;
+	uint32_t i, rev;
+	uint32_t *ptr, str[4];
+
+	psli = &phba->sli;
+	vp = &phba->vpd;
+	if (vp->rev.rBit) {
+		if (psli->sliinit.sli_flag & LPFC_SLI2_ACTIVE)
+			rev = vp->rev.sli2FwRev;
+		else
+			rev = vp->rev.sli1FwRev;
+
+		b1 = (rev & 0x0000f000) >> 12;
+		b2 = (rev & 0x00000f00) >> 8;
+		b3 = (rev & 0x000000c0) >> 6;
+		b4 = (rev & 0x00000030) >> 4;
+
+		switch (b4) {
+		case 0:
+			c = 'N';
+			break;
+		case 1:
+			c = 'A';
+			break;
+		case 2:
+			c = 'B';
+			break;
+		case 3:
+		default:
+			c = 0;
+			break;
+		}
+		b4 = (rev & 0x0000000f);
+
+		if (psli->sliinit.sli_flag & LPFC_SLI2_ACTIVE) {
+			for (i = 0; i < 16; i++) {
+				if (vp->rev.sli2FwName[i] == 0x20) {
+					vp->rev.sli2FwName[i] = 0;
+				}
+			}
+			ptr = (uint32_t *) vp->rev.sli2FwName;
+		} else {
+			for (i = 0; i < 16; i++) {
+				if (vp->rev.sli1FwName[i] == 0x20) {
+					vp->rev.sli1FwName[i] = 0;
+				}
+			}
+			ptr = (uint32_t *) vp->rev.sli1FwName;
+		}
+		for (i = 0; i < 3; i++) {
+			ldata = *ptr++;
+			ldata = be32_to_cpu(ldata);
+			str[i] = ldata;
+		}
+
+		if (c == 0) {
+			if (flag)
+				sprintf(fwrevision, "%d.%d%d (%s)",
+					(int)b1, (int)b2, (int)b3, (char *)str);
+			else
+				sprintf(fwrevision, "%d.%d%d", (int)b1,
+					(int)b2, (int)b3);
+		} else {
+			if (flag)
+				sprintf(fwrevision, "%d.%d%d%c%d (%s)",
+					(int)b1, (int)b2, (int)b3, c,
+					(int)b4, (char *)str);
+			else
+				sprintf(fwrevision, "%d.%d%d%c%d",
+					(int)b1, (int)b2, (int)b3, c, (int)b4);
+		}
+	} else {
+		rev = vp->rev.smFwRev;
+
+		b1 = (rev & 0xff000000) >> 24;
+		b2 = (rev & 0x00f00000) >> 20;
+		b3 = (rev & 0x000f0000) >> 16;
+		c = (char)((rev & 0x0000ff00) >> 8);
+		b4 = (rev & 0x000000ff);
+
+		if (flag)
+			sprintf(fwrevision, "%d.%d%d%c%d ", (int)b1,
+				(int)b2, (int)b3, c, (int)b4);
+		else
+			sprintf(fwrevision, "%d.%d%d%c%d ", (int)b1,
+				(int)b2, (int)b3, c, (int)b4);
+	}
+	return;
+}
+
+void
+lpfc_get_hba_model_desc(lpfcHBA_t * phba, uint8_t * mdp, uint8_t * descp)
+{
+	lpfc_vpd_t *vp;
+	uint16_t dev_id;
+	uint16_t dev_subid;
+	uint8_t hdrtype;
+	char *model_str = "";  
+	char *descr_str = "";
+
+	vp = &phba->vpd;
+	pci_read_config_word(phba->pcidev, PCI_DEVICE_ID, &dev_id);
+	pci_read_config_byte(phba->pcidev, PCI_HEADER_TYPE, &hdrtype);
+
+	switch (dev_id) {
+	case PCI_DEVICE_ID_FIREFLY:
+		model_str = "LP6000";
+		descr_str = "Emulex LP6000 1Gb PCI Fibre Channel Adapter";
+		break;
+	case PCI_DEVICE_ID_SUPERFLY:
+		if (vp->rev.biuRev >= 1 && vp->rev.biuRev <= 3) {
+			model_str = "LP7000";
+			descr_str = "Emulex LP7000 1Gb PCI Fibre Channel Adapter";
+		}
+		else {
+			model_str = "LP7000E";
+			descr_str = "Emulex LP7000E 1Gb PCI Fibre Channel Adapter";
+		}
+		break;
+	case PCI_DEVICE_ID_DRAGONFLY:
+		model_str = "LP8000";
+		descr_str = "Emulex LP8000 1Gb PCI Fibre Channel Adapter";
+		break;
+	case PCI_DEVICE_ID_CENTAUR:
+		if (FC_JEDEC_ID(vp->rev.biuRev) == CENTAUR_2G_JEDEC_ID) {
+			model_str = "LP9002";
+			descr_str = "Emulex LP9002 2Gb PCI Fibre Channel Adapter";
+		}
+		else {
+			model_str = "LP9000";
+			descr_str = "Emulex LP9000 1Gb PCI Fibre Channel Adapter";
+		}
+		break;
+	case PCI_DEVICE_ID_RFLY:
+		model_str = "LP952";
+		descr_str = "Emulex LP952 2Gb PCI Fibre Channel Adapter";
+		break;
+	case PCI_DEVICE_ID_PEGASUS:
+		model_str = "LP9802";
+		descr_str = "Emulex LP9802 2Gb PCI-X Fibre Channel Adapter";
+		break;
+	case PCI_DEVICE_ID_THOR:
+		if (hdrtype == 0x80) {
+			model_str = "LP10000DC";
+			descr_str = "Emulex LP10000DC 2Gb 2-port PCI-X Fibre Channel Adapter";
+		}
+		else {
+			model_str = "LP10000";
+			descr_str = "Emulex LP10000 2Gb PCI-X Fibre Channel Adapter";
+		}
+		break;
+	case PCI_DEVICE_ID_VIPER:
+		model_str = "LPX1000";
+		descr_str = "Emulex LPX1000 10Gb PCI-X Fibre Channel Adapter";
+		break;
+	case PCI_DEVICE_ID_PFLY:
+		model_str = "LP982";
+		descr_str = "Emulex LP982 2Gb PCI-X Fibre Channel Adapter";
+		break;
+	case PCI_DEVICE_ID_TFLY:
+		if (hdrtype == 0x80) {
+			model_str = "LP1050DC";
+			descr_str = "Emulex LP1050DC 2Gb 2-port PCI-X Fibre Channel Adapter";
+		}
+		else {
+			model_str = "LP1050";
+			descr_str = "Emulex LP1050 2Gb PCI-X Fibre Channel Adapter";
+		}
+		break;
+	case PCI_DEVICE_ID_HELIOS:
+		if (hdrtype == 0x80) {
+			model_str = "LP11002";
+			descr_str = "Emulex LP11002 4Gb 2-port PCI-X2 Fibre Channel Adapter";
+		}
+		else {
+			model_str = "LP11000";
+			descr_str = "Emulex LP11000 4Gb PCI-X2 Fibre Channel Adapter";
+		}
+		break;
+	case PCI_DEVICE_ID_HELIOS_SCSP:
+		model_str = "LP11000-SP";
+		descr_str = "Emulex LP11000-SP 4Gb PCI-X2 Fibre Channel Adapter";
+		break;
+	case PCI_DEVICE_ID_HELIOS_DCSP:
+		model_str = "LP11002-SP";
+		descr_str = "Emulex LP11002-SP 4Gb 2-port PCI-X2 Fibre Channel Adapter";
+		break;
+	case PCI_DEVICE_ID_NEPTUNE:
+		if (hdrtype == 0x80) {
+			model_str = "LPe1002";
+			descr_str = "Emulex LPe1002 4Gb 2-port PCIe Fibre Channel Adapter";
+		}
+		else {
+			model_str = "LPe1000";
+			descr_str = "Emulex LPe1000 4Gb PCIe Fibre Channel Adapter";
+		}
+		break;
+	case PCI_DEVICE_ID_NEPTUNE_SCSP:
+		model_str = "LPe1000-SP";
+		descr_str = "Emulex LPe1000-SP 4Gb PCIe Fibre Channel Adapter";
+		break;
+	case PCI_DEVICE_ID_NEPTUNE_DCSP:
+		model_str = "LPe1002-SP";
+		descr_str = "Emulex LPe1002-SP 4Gb 2-port PCIe Fibre Channel Adapter";
+		break;
+	case PCI_DEVICE_ID_BMID:
+		model_str = "LP1150";
+		descr_str = "Emulex LP1150 4Gb PCI-X2 Fibre Channel Adapter";
+		break;
+	case PCI_DEVICE_ID_BSMB:
+		model_str = "LP111";
+		descr_str = "Emulex LP111 4Gb PCI-X2 Fibre Channel Adapter";
+		break;
+	case PCI_DEVICE_ID_ZEPHYR:
+		if (hdrtype == 0x80) {
+			model_str = "LPe11002";
+			descr_str = "Emulex LPe11002 4Gb 2-port PCIe Fibre Channel Adapter";
+		}
+		else {
+			model_str = "LPe11000";
+			descr_str = "Emulex LPe11000 4Gb PCIe Fibre Channel Adapter";
+		}
+		break;
+	case PCI_DEVICE_ID_ZEPHYR_SCSP:
+		model_str = "LPe11000-SP";
+		descr_str = "Emulex LPe11000-SP 4Gb PCIe Fibre Channel Adapter";
+		break;
+	case PCI_DEVICE_ID_ZEPHYR_DCSP:
+		model_str = "LPe11002-SP";
+		descr_str = "Emulex LPe11002-SP 4Gb 2-port PCIe Fibre Channel Adapter";
+		break;
+	case PCI_DEVICE_ID_ZMID:
+		model_str = "LPe1150";
+		descr_str = "Emulex LPe1150 4Gb PCIe Fibre Channel Adapter";
+		break;
+	case PCI_DEVICE_ID_ZSMB:
+		model_str = "LPe111";
+		descr_str = "Emulex LPe111 4Gb PCIe Fibre Channel Adapter";
+		break;
+	case PCI_DEVICE_ID_LP101:
+		model_str = "LP101";
+		descr_str = "Emulex LP101 2Gb PCI-X Fibre Channel Adapter";
+		break;
+	case PCI_DEVICE_ID_LP10000S:
+		model_str = "LP10000-S";
+		descr_str = "Emulex LP10000-S 2Gb PCI Fibre Channel Adapter";
+		break;
+	case PCI_DEVICE_ID_LP11000S:
+	case PCI_DEVICE_ID_LPE11000S:
+		pci_read_config_word(phba->pcidev, PCI_SUBSYSTEM_ID, &dev_subid);
+		switch (dev_subid) {
+		case PCI_SUBSYSTEM_ID_LP11000S:
+			model_str = "LP11000-S";
+			descr_str = "Emulex LP11000-S 4Gb PCI-X2 Fibre Channel Adapter";
+			break;
+		case PCI_SUBSYSTEM_ID_LP11002S:
+			model_str = "LP11002-S";
+			descr_str = "Emulex LP11002-S 4Gb 2-port PCI-X2 Fibre Channel Adapter";
+			break;
+		case PCI_SUBSYSTEM_ID_LPE11000S:
+			model_str = "LPe11000-S";
+			descr_str = "Emulex LPe11000-S 4Gb PCIe Fibre Channel Adapter";
+			break;
+		case PCI_SUBSYSTEM_ID_LPE11002S:
+			model_str = "LPe11002-S";
+			descr_str = "Emulex LPe11002-S 4Gb 2-port PCIe Fibre Channel Adapter";
+			break;
+		case PCI_SUBSYSTEM_ID_LPE11010S:
+			model_str = "LPe11010-S";
+			descr_str = "Emulex LPe11010-S 4Gb 10-port PCIe Fibre Channel Adapter";
+			break;
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+	if (mdp)
+		sprintf(mdp, "%s", model_str);
+	if (descp)
+		sprintf(descp, "%s", descr_str);
+}
+
+void
+lpfc_get_hba_sym_node_name(lpfcHBA_t * phba, uint8_t * symbp)
+{
+	char fwrev[16];
+
+	lpfc_decode_firmware_rev(phba, fwrev, 0);
+	sprintf(symbp, "Emulex %s FV%s DV%s", phba->ModelName, fwrev, lpfc_release_version);
+}
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_dfc.h linux-8155/drivers/addon/lpfc/lpfc_dfc.h
--- linux-8152/drivers/addon/lpfc/lpfc_dfc.h
+++ linux-8155/drivers/addon/lpfc/lpfc_dfc.h
@@ -0,0 +1,99 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_dfc.h 328 2005-05-03 15:20:43Z sf_support $
+ */
+
+#ifndef _H_LPFC_DFC
+#define _H_LPFC_DFC
+
+#define LPFC_MAX_RING_MASK  4	/* max num of rctl/type masks allowed per
+				   ring */
+#define LPFC_MAX_RING       4	/* max num of SLI rings used by driver */
+
+#define LPFC_INQSN_SZ      64   /* Max size of Inquiry serial number */
+
+
+/* Defines for RegisterForEvent mask */
+#define FC_REG_LINK_EVENT       0x1	/* Register for link up / down events */
+#define FC_REG_RSCN_EVENT       0x2	/* Register for RSCN events */
+#define FC_REG_CT_EVENT         0x4	/* Register for CT request events */
+
+#define FC_REG_EVENT_MASK       0x2f	/* event mask */
+#define FC_REG_ALL_PORTS        0x80	/* Register for all ports */
+
+#define MAX_FC_EVENTS 8		/* max events user process can wait for per
+				   HBA */
+#define FC_FSTYPE_ALL 0xffff	/* match on all fsTypes */
+
+/* Defines for error codes */
+#define FC_ERROR_BUFFER_OVERFLOW          0xff
+#define FC_ERROR_RESPONSE_TIMEOUT         0xfe
+#define FC_ERROR_LINK_UNAVAILABLE         0xfd
+#define FC_ERROR_INSUFFICIENT_RESOURCES   0xfc
+#define FC_ERROR_EXISTING_REGISTRATION    0xfb
+#define FC_ERROR_INVALID_TAG              0xfa
+#define FC_ERROR_INVALID_WWN              0xf9
+#define FC_ERROR_CREATEVENT_FAILED        0xf8
+
+/* values for a_flag */
+#define CFG_EXPORT      0x1	/* Export this parameter to the end user */
+#define CFG_IGNORE      0x2	/* Ignore this parameter */
+#define CFG_DEFAULT     0x8000	/* Reestablishing Link */
+
+/* values for a_changestate */
+#define CFG_REBOOT      0x0	/* Changes effective after ystem reboot */
+#define CFG_DYNAMIC     0x1	/* Changes effective immediately */
+#define CFG_RESTART     0x2	/* Changes effective after driver restart */
+
+/* the icfgparam structure - internal use only */
+typedef struct ICFGPARAM {
+	char *a_string;
+	uint32_t a_low;
+	uint32_t a_hi;
+	uint32_t a_default;
+	uint32_t a_current;
+	uint16_t a_flag;
+	uint16_t a_changestate;
+	char *a_help;
+} iCfgParam;
+
+/* User Library level Event structure */
+typedef struct reg_evt {
+	uint32_t e_mask;
+	uint32_t e_gstype;
+	uint32_t e_pid;
+	uint32_t e_firstchild;
+	uint32_t e_outsz;
+	uint32_t e_pad;
+	void (*e_func) (uint32_t, ...);
+	void *e_ctx;
+	void *e_out;
+} RegEvent;
+
+/* Defines for portid for CT interface */
+#define CT_FabricCntlServer ((uint32_t)0xfffffd)
+#define CT_NameServer       ((uint32_t)0xfffffc)
+#define CT_TimeServer       ((uint32_t)0xfffffb)
+#define CT_MgmtServer       ((uint32_t)0xfffffa)
+
+#define IOCB_ENTRY(ring,slot) ((IOCB_t *)(((char *)(ring)) + ((slot) * 32)))
+#endif				/* _H_LPFC_DIAG */
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_disc.h linux-8155/drivers/addon/lpfc/lpfc_disc.h
--- linux-8152/drivers/addon/lpfc/lpfc_disc.h
+++ linux-8155/drivers/addon/lpfc/lpfc_disc.h
@@ -0,0 +1,300 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_disc.h 328 2005-05-03 15:20:43Z sf_support $
+ */
+
+#ifndef  _H_LPFC_DISC
+#define  _H_LPFC_DISC
+
+#include "lpfc_hw.h"
+
+struct lpfcScsiTarget;
+
+#define FC_MAX_HOLD_RSCN     32	      /* max number of deferred RSCNs */
+#define FC_MAX_NS_RSP        65536    /* max size NameServer rsp */
+#define FC_MAXLOOP           126      /* max devices supported on a fc loop */
+#define LPFC_DISC_FLOGI_TMO  10	      /* Discovery FLOGI ratov */
+
+/* Defines for failMask bitmask
+ * These are reasons that the device is not currently available 
+ * for I/O to be sent.
+ */
+#define LPFC_DEV_LINK_DOWN       0x1	/* Link is down */
+#define LPFC_DEV_DISAPPEARED     0x2	/* Device disappeared */
+#define LPFC_DEV_RPTLUN          0x4	/* Device needs report luns cmd */
+#define LPFC_DEV_INQSN_VALID     0x8	/* Validating Inquiry SN */
+
+/* If only these bits are set, the driver is trying to recover */
+#define LPFC_DEV_HOLD_IO         0xf
+
+#define LPFC_DEV_INVALID         0x10	/* DEV determined invalid by drvr */
+#define LPFC_DEV_MAINT_MODE      0x20	/* HBA is in maintance mode */
+#define LPFC_DEV_INACTIVE        0x40	/* DEV made inactive by drvr
+					   internally */
+#define LPFC_DEV_DISCONNECTED    0x80	/* noactive connection to remote dev */
+#define LPFC_DEV_USER_INITIATED  0x200	/* DEV taken offline by admin */
+
+/* If any of these bits are set, the device is gone */
+#define LPFC_DEV_FATAL_ERROR     0x3f0
+
+#define LPFC_DEV_DRVR_BITS       0x1ff	/* all valid driver failMask bits */
+#define LPFC_DEV_ALL_BITS        0x3ff	/* all valid failMask bits */
+
+/* These defines are used for set failMask routines */
+#define LPFC_SET_BITMASK		1
+#define LPFC_CLR_BITMASK		2
+
+/* Provide an enumeration for the Types of addresses a FARP can resolve. */
+typedef enum lpfc_farp_addr_type {
+	LPFC_FARP_BY_IEEE,
+	LPFC_FARP_BY_WWPN,
+	LPFC_FARP_BY_WWNN,
+} LPFC_FARP_ADDR_TYPE;
+
+/* This is the protocol dependent definition for a Node List Entry.
+ * This is used by Fibre Channel protocol to support FCP.
+ */
+
+struct lpfc_bindlist {
+	struct list_head      nlp_listp;
+	struct lpfcScsiTarget  *nlp_Target;	/* ptr to the tgt structure */
+	NAME_TYPE             nlp_portname;	/* port name */
+	NAME_TYPE             nlp_nodename;	/* node name */
+	uint16_t              nlp_bind_type;
+	uint16_t              nlp_sid;		/* scsi id */
+	uint32_t              nlp_DID;		/* FibreChannel D_ID of entry */
+};
+typedef struct lpfc_bindlist LPFC_BINDLIST_t;
+
+struct lpfc_nodelist {
+	struct list_head     nlp_listp;
+	uint32_t             nlp_failMask;	/* failure mask for device */
+
+	uint16_t             nlp_type;
+#define NLP_FC_NODE        0x1			/* entry is an FC node */
+#define NLP_FABRIC         0x4			/* entry represents a Fabric
+						   entity */
+#define NLP_FCP_TARGET     0x8			/* entry is an FCP target */
+
+	uint16_t             nlp_rpi;
+
+	uint8_t              nlp_fcp_info;	/* Remote class info */
+#define NLP_FCP_2_DEVICE   0x10			/* FCP-2 device */
+
+	volatile int         nlp_rflag;
+#define NLP_DELAY_REMOVE   0x8                  /* Defer removal till end of DSM */
+
+	uint16_t       nlp_state;		/* state transition indicator */
+	uint16_t       nlp_xri;			/* output exchange id for RPI */
+	uint32_t       nlp_flag;		/* entry  flags */
+	uint32_t       nlp_DID;			/* fibre channel D_ID of
+						   entry */
+	uint32_t       nlp_oldDID;		/* old fibre channel D_ID */
+	NAME_TYPE      nlp_portname;		/* port name */
+	NAME_TYPE      nlp_nodename;		/* node name */
+	uint16_t       nlp_sid;			/* scsi id */
+	uint8_t        nlp_retry;		/* used for ELS retries */
+	uint8_t        nlp_disc_refcnt;		/* used for DSM */
+	struct timer_list nlp_tmofunc;		/* Used for delayed ELS cmds,
+						   nodev tmo */
+	struct lpfcScsiTarget *nlp_Target;	/* Pointer to the target
+						   structure */
+
+
+	LPFC_BINDLIST_t *nlp_listp_bind;	/* Linked list bounded remote
+						   ports */
+};
+
+typedef struct lpfc_nodelist LPFC_NODELIST_t;
+
+/*++
+ * lpfc_node_farp_list: 
+ *   This data structure defines the attributes associated with
+ *   an outstanding FARP REQ to a remote node.
+ *
+ *   rnode_addr - The address of the remote node.  Either the IEEE, WWPN, or
+ *   WWNN.  Used in the FARP request.
+ *   fc_ipfarp_tmo - The timer associated with the FARP request.  This
+ *                   timer limits the amount of time spent waiting for
+ *                   the FARP to complete.
+ *   fc_ipbuf_list_farp_wait - A list of IP buffers waiting for the FARP
+ *                             request to complete.
+ *
+ --*/
+struct lpfc_node_farp_pend {
+	struct list_head listentry;
+	NAME_TYPE rnode_addr;
+};
+
+typedef struct lpfc_node_farp_pend LPFC_NODE_FARP_PEND_t;
+
+/* Defines for nlp_flag (uint32) */
+#define NLP_MAPPED_LIST    0x1		/* Node is now mapped */
+#define NLP_UNMAPPED_LIST  0x2		/* Node is now unmapped */
+#define NLP_PLOGI_LIST     0x4		/* Flg to indicate send PLOGI */
+#define NLP_ADISC_LIST     0x8		/* Flg to indicate send PLOGI */
+#define NLP_LIST_MASK      0xf		/* mask to see what list node is on */
+#define NLP_BIND_ASSOC     0x10		/* Node is now bound */
+#define NLP_PLOGI_SND      0x20		/* sent PLOGI request for this entry */
+#define NLP_PRLI_SND       0x40		/* sent PRLI request for this entry */
+#define NLP_ADISC_SND      0x80		/* sent ADISC request for this entry */
+#define NLP_LOGO_SND       0x100	/* sent LOGO request for this entry */
+#define NLP_FARP_SND       0x200	/* sent FARP request for this entry */
+#define NLP_RNID_SND       0x400	/* sent RNID request for this entry */
+#define NLP_ELS_SND_MASK   0x7e0	/* sent ELS request for this entry */
+#define NLP_AUTOMAP        0x800	/* Entry was automap'ed */
+#define NLP_SEED_WWPN      0x1000	/* Entry scsi id is seeded for WWPN */
+#define NLP_SEED_WWNN      0x2000	/* Entry scsi id is seeded for WWNN */
+#define NLP_SEED_DID       0x4000	/* Entry scsi id is seeded for DID */
+#define NLP_SEED_MASK      0x807000	/* mask for seeded flags */
+#define NLP_NS_NODE        0x8000	/* Authenticated entry by NameServer */
+#define NLP_DELAY_TMO      0x20000	/* delay timeout is running for node */
+#define NLP_DISC_NODE      0x40000	/* node is included in num_disc_nodes */
+#define NLP_RCV_PLOGI      0x80000	/* Rcv'ed PLOGI from remote system */
+#define NLP_LOGO_ACC       0x100000	/* Process LOGO after ACC completes */
+#define NLP_TGT_NO_SCSIID  0x200000	/* good PRLI but no binding for scsid */
+#define NLP_CREATE_XRI_INP 0x400000	/* in process of creating an XRI */
+#define NLP_SEED_ALPA      0x800000	/* SCSI id is derived from alpa array */
+#define NLP_ACC_REGLOGIN   0x1000000	/* Issue Reg Login after successful
+					   ACC */
+
+/* Defines for list searchs */
+#define NLP_SEARCH_MAPPED    0x1	/* search mapped */
+#define NLP_SEARCH_UNMAPPED  0x2	/* search unmapped */
+#define NLP_SEARCH_PLOGI     0x4	/* search plogi */
+#define NLP_SEARCH_ADISC     0x8	/* search adisc */
+#define NLP_SEARCH_ALL       0xf	/* search all lists */
+#define NLP_SEARCH_DEQUE     0x10	/* deque node if found */
+
+/* There are 4 different double linked lists nodelist entries can reside on.
+ * The Port Login (PLOGI) list and Address Discovery (ADISC) list are used 
+ * when Link Up discovery or Registered State Change Notification (RSCN) 
+ * processing is needed.  Each list holds the nodes that require a PLOGI or 
+ * ADISC Extended Link Service (ELS) request.  These lists keep track of the
+ * nodes affected by an RSCN, or a Link Up (Typically, all nodes are effected 
+ * by Link Up) event.  The unmapped_list contains all nodes that have 
+ * successfully logged into at the Fibre Channel level.  The
+ * mapped_list will contain all nodes that are mapped FCP targets.
+ *
+ * The bind list is a list of undiscovered (potentially non-existent) nodes
+ * that we have saved binding information on. This information is used when
+ * nodes transition from the unmapped to the mapped list.
+ */
+
+/* Defines for nlp_state */
+#define NLP_STE_UNUSED_NODE       0x0	/* node is just allocated */
+#define NLP_STE_PLOGI_ISSUE       0x1	/* PLOGI was sent to NL_PORT */
+#define NLP_STE_REG_LOGIN_ISSUE   0x2	/* REG_LOGIN was issued for NL_PORT */
+#define NLP_STE_PRLI_ISSUE        0x3	/* PRLI was sent to NL_PORT */
+#define NLP_STE_PRLI_COMPL        0x4	/* PRLI completed from NL_PORT */
+#define NLP_STE_MAPPED_NODE       0x5	/* Identified as a FCP Target */
+#define NLP_STE_MAX_STATE         0x6
+#define NLP_STE_FREED_NODE        0xff	/* node entry was freed to MEM_NLP */
+
+/* For UNUSED_NODE state, the node has just been allocated.
+ * For PLOGI_ISSUE and REG_LOGIN_ISSUE, the node is on
+ * the PLOGI list. For REG_LOGIN_COMPL, the node is taken off the PLOGI list
+ * and put on the unmapped list. For ADISC processing, the node is taken off 
+ * the ADISC list and placed on either the mapped or unmapped list (depending
+ * on its previous state). Once on the unmapped list, a PRLI is issued and the
+ * state changed to PRLI_ISSUE. When the PRLI completion occurs, the state is
+ * changed to PRLI_COMPL. If the completion indicates a mapped
+ * node, the node is taken off the unmapped list. The binding list is checked
+ * for a valid binding, or a binding is automatically assigned. If binding
+ * assignment is unsuccessful, the node is left on the unmapped list. If
+ * binding assignment is successful, the associated binding list entry (if
+ * any) is removed, and the node is placed on the mapped list. 
+ */
+/*
+ * For a Link Down, all nodes on the ADISC, PLOGI, unmapped or mapped
+ * lists will receive a DEVICE_UNK event. If the linkdown or nodev timers
+ * expire, all effected nodes will receive a DEVICE_RM event.
+ */
+/*
+ * For a Link Up or RSCN, all nodes will move from the mapped / unmapped lists
+ * to either the ADISC or PLOGI list.  After a Nameserver query or ALPA loopmap
+ * check, additional nodes may be added (DEVICE_ADD) or removed (DEVICE_RM) to /
+ * from the PLOGI or ADISC lists. Once the PLOGI and ADISC lists are populated,
+ * we will first process the ADISC list.  32 entries are processed initially and
+ * ADISC is initited for each one.  Completions / Events for each node are
+ * funnelled thru the state machine.  As each node finishes ADISC processing, it
+ * starts ADISC for any nodes waiting for ADISC processing. If no nodes are
+ * waiting, and the ADISC list count is identically 0, then we are done. For
+ * Link Up discovery, since all nodes on the PLOGI list are UNREG_LOGIN'ed, we
+ * can issue a CLEAR_LA and reenable Link Events. Next we will process the PLOGI
+ * list.  32 entries are processed initially and PLOGI is initited for each one.
+ * Completions / Events for each node are funnelled thru the state machine.  As
+ * each node finishes PLOGI processing, it starts PLOGI for any nodes waiting
+ * for PLOGI processing. If no nodes are waiting, and the PLOGI list count is
+ * identically 0, then we are done. We have now completed discovery / RSCN
+ * handling. Upon completion, ALL nodes should be on either the mapped or
+ * unmapped lists.
+ */
+
+/* Defines for Node List Entry Events that could happen */
+#define NLP_EVT_RCV_PLOGI         0x0	/* Rcv'd an ELS PLOGI command */
+#define NLP_EVT_RCV_PRLI          0x1	/* Rcv'd an ELS PRLI  command */
+#define NLP_EVT_RCV_LOGO          0x2	/* Rcv'd an ELS LOGO  command */
+#define NLP_EVT_RCV_ADISC         0x3	/* Rcv'd an ELS ADISC command */
+#define NLP_EVT_RCV_PDISC         0x4	/* Rcv'd an ELS PDISC command */
+#define NLP_EVT_RCV_PRLO          0x5	/* Rcv'd an ELS PRLO  command */
+#define NLP_EVT_CMPL_PLOGI        0x6	/* Sent an ELS PLOGI command */
+#define NLP_EVT_CMPL_PRLI         0x7	/* Sent an ELS PRLI  command */
+#define NLP_EVT_CMPL_LOGO         0x8	/* Sent an ELS LOGO  command */
+#define NLP_EVT_CMPL_ADISC        0x9	/* Sent an ELS ADISC command */
+#define NLP_EVT_CMPL_REG_LOGIN    0xa	/* REG_LOGIN mbox cmd completed */
+#define NLP_EVT_DEVICE_RM         0xb	/* Device not found in NS / ALPAmap */
+#define NLP_EVT_DEVICE_ADD        0xc	/* Device found in NS / ALPAmap */
+#define NLP_EVT_DEVICE_UNK        0xd	/* Device existence unknown */
+#define NLP_EVT_MAX_EVENT         0xe
+
+/* structure used to queue event to the discovery tasklet */
+struct lpfc_disc_evt {
+	struct list_head      evt_listp;
+	void                * evt_arg1;
+	void                * evt_arg2;
+	uint32_t              evt;
+};
+typedef struct lpfc_disc_evt LPFC_DISC_EVT_t;
+
+#define LPFC_EVT_MBOX		0x1
+#define LPFC_EVT_SOL_IOCB	0x2
+#define LPFC_EVT_UNSOL_IOCB	0x3
+
+/* Used for parsing binding configuration */
+#define LPFC_SYNTAX_OK                      0
+#define LPFC_SYNTAX_OK_BUT_NOT_THIS_BRD     1
+#define LPFC_SYNTAX_ERR_ASC_CONVERT         2
+#define LPFC_SYNTAX_ERR_EXP_COLON           3
+#define LPFC_SYNTAX_ERR_EXP_LPFC            4
+#define LPFC_SYNTAX_ERR_INV_LPFC_NUM        5
+#define LPFC_SYNTAX_ERR_EXP_T               6
+#define LPFC_SYNTAX_ERR_INV_TARGET_NUM      7
+#define LPFC_SYNTAX_ERR_EXP_D               8
+#define LPFC_SYNTAX_ERR_INV_DEVICE_NUM      9
+#define LPFC_SYNTAX_ERR_EXP_NULL_TERM      13
+
+/* Definitions for Binding Entry Type for lpfc_parse_binding_entry()  */
+#define LPFC_BIND_WW_NN_PN   0
+#define LPFC_BIND_DID        1
+
+#endif				/* _H_LPFC_DISC */
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_els.c linux-8155/drivers/addon/lpfc/lpfc_els.c
--- linux-8152/drivers/addon/lpfc/lpfc_els.c
+++ linux-8155/drivers/addon/lpfc/lpfc_els.c
@@ -0,0 +1,3121 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_els.c 502 2006-04-04 17:11:23Z sf_support $
+ */
+#include <linux/version.h>
+#include <linux/spinlock.h>
+#include <linux/pci.h>
+
+
+#include <linux/blk.h>
+
+#include "lpfc_hw.h"
+#include "lpfc_sli.h"
+#include "lpfc_mem.h"
+#include "lpfc_sched.h"
+#include "lpfc_disc.h"
+#include "lpfc.h"
+#include "lpfc_logmsg.h"
+#include "lpfc_scsi.h"
+#include "hbaapi.h"
+#include "lpfc_dfc.h"
+#include "lpfc_crtn.h"
+#include "lpfc_cfgparm.h"
+
+int lpfc_els_rcv_rscn(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_NODELIST_t *, uint8_t);
+int lpfc_els_rcv_flogi(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_NODELIST_t *, uint8_t);
+int lpfc_els_rcv_rrq(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_NODELIST_t *);
+int lpfc_els_rcv_rnid(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_NODELIST_t *);
+int lpfc_els_rcv_farp(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_NODELIST_t *);
+int lpfc_els_rcv_farpr(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_NODELIST_t *);
+int lpfc_els_rcv_fan(lpfcHBA_t *, LPFC_IOCBQ_t *, LPFC_NODELIST_t *);
+
+int lpfc_max_els_tries = 3;
+
+int
+lpfc_initial_flogi(lpfcHBA_t * phba)
+{
+	LPFC_NODELIST_t *ndlp;
+
+	/* First look for Fabric ndlp on the unmapped list */
+
+	if ((ndlp =
+	     lpfc_findnode_did(phba, (NLP_SEARCH_UNMAPPED | NLP_SEARCH_DEQUE),
+			       Fabric_DID)) == 0) {
+		/* Cannot find existing Fabric ndlp, so allocate a new one */
+		if ((ndlp = lpfc_nlp_alloc(phba, 0)) == 0) {
+			return (0);
+		}
+		memset(ndlp, 0, sizeof (LPFC_NODELIST_t));
+		ndlp->nlp_DID = Fabric_DID;
+	}
+	if (lpfc_issue_els_flogi(phba, ndlp, 0)) {
+		lpfc_nlp_free(phba, ndlp);
+	}
+	return (1);
+}
+
+int
+lpfc_issue_els_flogi(lpfcHBA_t * phba, LPFC_NODELIST_t * ndlp, uint8_t retry)
+{
+	SERV_PARM *sp;
+	IOCB_t *icmd;
+	LPFC_IOCBQ_t *elsiocb;
+	LPFC_SLI_RING_t *pring;
+	LPFC_SLI_t *psli;
+	uint8_t *pCmd;
+	uint16_t cmdsize;
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_ELS_RING];	/* ELS ring */
+
+	cmdsize = (sizeof (uint32_t) + sizeof (SERV_PARM));
+	if ((elsiocb = lpfc_prep_els_iocb(phba, TRUE, cmdsize, retry,
+					  ndlp, ELS_CMD_FLOGI)) == 0) {
+		return (1);
+	}
+
+	icmd = &elsiocb->iocb;
+	pCmd = (uint8_t *) (((DMABUF_t *) elsiocb->context2)->virt);
+
+	/* For FLOGI request, remainder of payload is service parameters */
+	*((uint32_t *) (pCmd)) = ELS_CMD_FLOGI;
+	pCmd += sizeof (uint32_t);
+	memcpy(pCmd, &phba->fc_sparam, sizeof (SERV_PARM));
+	sp = (SERV_PARM *) pCmd;
+
+	/* Setup CSPs accordingly for Fabric */
+	sp->cmn.e_d_tov = 0;
+	sp->cmn.w2.r_a_tov = 0;
+	sp->cls1.classValid = 0;
+	sp->cls2.seqDelivery = 1;
+	sp->cls3.seqDelivery = 1;
+	if (sp->cmn.fcphLow < FC_PH3)
+		sp->cmn.fcphLow = FC_PH3;
+	if (sp->cmn.fcphHigh < FC_PH3)
+		sp->cmn.fcphHigh = FC_PH3;
+
+	lpfc_set_disctmo(phba);
+
+	phba->fc_stat.elsXmitFLOGI++;
+	elsiocb->iocb_cmpl = lpfc_cmpl_els_flogi;
+	if (lpfc_sli_issue_iocb(phba, pring, elsiocb, SLI_IOCB_USE_TXQ) ==
+	    IOCB_ERROR) {
+		lpfc_els_free_iocb(phba, elsiocb);
+		return (1);
+	}
+	return (0);
+}
+
+void
+lpfc_cmpl_els_flogi(lpfcHBA_t * phba,
+		    LPFC_IOCBQ_t * cmdiocb, LPFC_IOCBQ_t * rspiocb)
+{
+	IOCB_t *irsp;
+	DMABUF_t *pCmd, *pRsp;
+	SERV_PARM *sp;
+	uint32_t *lp;
+	LPFC_MBOXQ_t *mbox;
+	LPFC_SLI_t *psli;
+	LPFC_NODELIST_t *ndlp;
+	lpfcCfgParam_t *clp;
+	uint32_t rc;
+
+	psli = &phba->sli;
+	irsp = &(rspiocb->iocb);
+	ndlp = (LPFC_NODELIST_t *) cmdiocb->context1;
+	pCmd = (DMABUF_t *) cmdiocb->context2;
+
+	clp = &phba->config[0];
+
+	/* Return to default values since first FLOGI has completed */
+	phba->fc_edtov = FF_DEF_EDTOV;
+	phba->fc_ratov = FF_DEF_RATOV;
+	phba->fcp_timeout_offset = 2 * phba->fc_ratov +
+		clp[LPFC_CFG_EXTRA_IO_TMO].a_current;
+
+	/* Check to see if link went down during discovery */
+	if (lpfc_els_chk_latt(phba, rspiocb))
+		goto out;
+
+	if (irsp->ulpStatus) {
+		/* Check for retry */
+		if (lpfc_els_retry(phba, cmdiocb, rspiocb)) {
+			/* ELS command is being retried */
+			goto out;
+		}
+		/* FLOGI failed, so there is no fabric */
+		phba->fc_flag &= ~(FC_FABRIC | FC_PUBLIC_LOOP);
+
+		/* If private loop, then allow max outstandting els to be
+		 * LPFC_MAX_DISC_THREADS (32). Scanning in the case of no 
+		 * alpa map would take too long otherwise. 
+		 */
+		if (phba->alpa_map[0] == 0) {
+			clp[LPFC_CFG_DISC_THREADS].a_current =
+			    LPFC_MAX_DISC_THREADS;
+		}
+
+		/* FLOGI failure */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0100,
+				lpfc_mes0100,
+				lpfc_msgBlk0100.msgPreambleStr,
+				irsp->ulpStatus, irsp->un.ulpWord[4]);
+	} else {
+		/* The FLogI succeeded.  Sync the data for the CPU before
+		 * accessing it. 
+		 */
+		pRsp = (DMABUF_t *) pCmd->list.next;
+		lp = (uint32_t *) pRsp->virt;
+
+		sp = (SERV_PARM *) ((uint8_t *) lp + sizeof (uint32_t));
+
+		/* FLOGI completes successfully */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0101,
+				lpfc_mes0101, lpfc_msgBlk0101.msgPreambleStr,
+				irsp->un.ulpWord[4], sp->cmn.e_d_tov,
+				sp->cmn.w2.r_a_tov, sp->cmn.edtovResolution);
+
+		if (phba->hba_state == LPFC_FLOGI) {
+			/* If Common Service Parameters indicate Nport
+			 * we are point to point, if Fport we are Fabric.
+			 */
+			if (sp->cmn.fPort) {
+				phba->fc_flag |= FC_FABRIC;
+				if (sp->cmn.edtovResolution) {
+					/* E_D_TOV ticks are in nanoseconds */
+					phba->fc_edtov =
+					    (be32_to_cpu(sp->cmn.e_d_tov) +
+					     999999) / 1000000;
+				} else {
+					/* E_D_TOV ticks are in milliseconds */
+					phba->fc_edtov =
+					    be32_to_cpu(sp->cmn.e_d_tov);
+				}
+				phba->fc_ratov =
+				    (be32_to_cpu(sp->cmn.w2.r_a_tov) +
+				     999) / 1000;
+				phba->fcp_timeout_offset =
+				    2 * phba->fc_ratov +
+				    clp[LPFC_CFG_EXTRA_IO_TMO].a_current;
+
+				if (phba->fc_topology == TOPOLOGY_LOOP) {
+					phba->fc_flag |= FC_PUBLIC_LOOP;
+				} else {
+					/* If we are a N-port connected to a
+					 * Fabric, fixup sparam's so logins to
+					 * devices on remote loops work.
+					 */
+					phba->fc_sparam.cmn.altBbCredit = 1;
+				}
+
+				phba->fc_myDID = irsp->un.ulpWord[4] & Mask_DID;
+
+				memcpy(&ndlp->nlp_portname,
+				       &sp->portName, sizeof (NAME_TYPE));
+				memcpy(&ndlp->nlp_nodename,
+				       &sp->nodeName, sizeof (NAME_TYPE));
+				memcpy(&phba->fc_fabparam, sp,
+				       sizeof (SERV_PARM));
+				if ((mbox = lpfc_mbox_alloc(phba, 0)) == 0) {
+					goto flogifail;
+				}
+				phba->hba_state = LPFC_FABRIC_CFG_LINK;
+				lpfc_config_link(phba, mbox);
+				if (lpfc_sli_issue_mbox
+				    (phba, mbox, (MBX_NOWAIT | MBX_STOP_IOCB))
+				    == MBX_NOT_FINISHED) {
+					lpfc_mbox_free(phba, mbox);
+					goto flogifail;
+				}
+
+				if ((mbox = lpfc_mbox_alloc(phba, 0)) == 0) {
+					goto flogifail;
+				}
+				if (lpfc_reg_login(phba, Fabric_DID,
+						   (uint8_t *) sp, mbox,
+						   0) == 0) {
+					/* set_slim mailbox command needs to
+					 * execute first, queue this command to
+					 * be processed later.
+					 */
+					mbox->mbox_cmpl =
+					    lpfc_mbx_cmpl_fabric_reg_login;
+					mbox->context2 = ndlp;
+					if (lpfc_sli_issue_mbox
+					    (phba, mbox,
+					     (MBX_NOWAIT | MBX_STOP_IOCB))
+					    == MBX_NOT_FINISHED) {
+						DMABUF_t *mp;
+						mp = (DMABUF_t *)(mbox->context1);
+						lpfc_mbuf_free(phba, mp->virt, mp->phys);
+						kfree(mp);
+						lpfc_mbox_free(phba, mbox);
+						goto flogifail;
+					}
+				} else {
+					lpfc_mbox_free(phba, mbox);
+					goto flogifail;
+				}
+			} else {
+				/* We FLOGIed into an NPort, initiate pt2pt
+				   protocol */
+				phba->fc_flag &= ~(FC_FABRIC | FC_PUBLIC_LOOP);
+				phba->fc_edtov = FF_DEF_EDTOV;
+				phba->fc_ratov = FF_DEF_RATOV;
+				phba->fcp_timeout_offset = 2 * phba->fc_ratov +
+				    clp[LPFC_CFG_EXTRA_IO_TMO].a_current;
+				if ((rc =
+				     lpfc_geportname((NAME_TYPE *) & phba->
+						     fc_portname,
+						     (NAME_TYPE *) & sp->
+						     portName))) {
+					/* This side will initiate the PLOGI */
+					phba->fc_flag |= FC_PT2PT_PLOGI;
+
+					/* N_Port ID cannot be 0, set our to
+					 * LocalID the other side will be
+					 * RemoteID.
+					 */
+
+					/* not equal */
+					if (rc == 1)
+						phba->fc_myDID = PT2PT_LocalID;
+					rc = 0;
+
+					if ((mbox = lpfc_mbox_alloc(phba, 0))
+					    == 0) {
+						goto flogifail;
+					}
+					lpfc_config_link(phba, mbox);
+					if (lpfc_sli_issue_mbox
+					    (phba, mbox,
+					     (MBX_NOWAIT | MBX_STOP_IOCB))
+					    == MBX_NOT_FINISHED) {
+						lpfc_mbox_free(phba, mbox);
+						goto flogifail;
+					}
+					lpfc_nlp_free(phba, ndlp);
+
+					if ((ndlp =
+					     lpfc_findnode_did(phba,
+							       NLP_SEARCH_ALL,
+							       PT2PT_RemoteID))
+					    == 0) {
+						/* Cannot find existing Fabric
+						   ndlp, so allocate a new
+						   one */
+						if ((ndlp = (LPFC_NODELIST_t *)
+						     lpfc_nlp_alloc(phba,
+								    0)) == 0) {
+							goto flogifail;
+						}
+						memset(ndlp, 0,
+						       sizeof
+						       (LPFC_NODELIST_t));
+						ndlp->nlp_DID = PT2PT_RemoteID;
+					}
+					memcpy(&ndlp->nlp_portname,
+					       &sp->portName,
+					       sizeof (NAME_TYPE));
+					memcpy(&ndlp->nlp_nodename,
+					       &sp->nodeName,
+					       sizeof (NAME_TYPE));
+					lpfc_nlp_plogi(phba, ndlp);
+				} else {
+					/* This side will wait for the PLOGI */
+					lpfc_nlp_free(phba, ndlp);
+				}
+
+				phba->fc_flag |= FC_PT2PT;
+				lpfc_set_disctmo(phba);
+
+				/* Start discovery - this should just do
+				   CLEAR_LA */
+				lpfc_disc_start(phba);
+			}
+			goto out;
+		}
+	}
+
+      flogifail:
+	lpfc_nlp_remove(phba, ndlp);
+
+	/* Do not start discovery on a driver initialed FLOGI abort */
+	if((irsp->ulpStatus != IOSTAT_LOCAL_REJECT) ||
+		(irsp->un.ulpWord[4] != IOERR_SLI_ABORTED)) {
+
+		/* FLOGI failed, so just use loop map to make discovery list */
+		lpfc_disc_list_loopmap(phba);
+
+		/* Start discovery */
+		lpfc_disc_start(phba);
+	}
+
+      out:
+	/* if myDID ndlp exists, remove it */
+	if ((ndlp = lpfc_findnode_did(phba,
+	     NLP_SEARCH_ALL, phba->fc_myDID))) {
+		lpfc_nlp_remove(phba, ndlp);
+	}
+
+	lpfc_els_free_iocb(phba, cmdiocb);
+	return;
+}
+
+int
+lpfc_els_abort_flogi(lpfcHBA_t * phba)
+{
+	LPFC_SLI_t *psli;
+	LPFC_SLI_RING_t *pring;
+	LPFC_IOCBQ_t *iocb, *next_iocb;
+	LPFC_NODELIST_t *ndlp;
+	IOCB_t *icmd;
+	struct list_head *curr, *next;
+
+	/* Abort outstanding I/O to the Fabric */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0242,
+			lpfc_mes0242,
+			lpfc_msgBlk0242.msgPreambleStr,
+			Fabric_DID);
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_ELS_RING];
+
+	/* check the txcmplq */
+	list_for_each_safe(curr, next, &pring->txcmplq) {
+		next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+		iocb = next_iocb;
+		/* Check to see if iocb matches the nport we are
+		   looking for */
+		icmd = &iocb->iocb;
+		if (icmd->ulpCommand == CMD_ELS_REQUEST64_CR) {
+			ndlp = (LPFC_NODELIST_t *)(iocb->context1);
+			if(ndlp && (ndlp->nlp_DID == Fabric_DID)) {
+				/* It matches, so deque and call compl
+				   with an error */
+				list_del(&iocb->list);
+				pring->txcmplq_cnt--;
+
+				if ((icmd->un.elsreq64.bdl.ulpIoTag32)) {
+					lpfc_sli_issue_abort_iotag32
+					    (phba, pring, iocb);
+				}
+				if (iocb->iocb_cmpl) {
+					icmd->ulpStatus =
+					    IOSTAT_LOCAL_REJECT;
+					icmd->un.ulpWord[4] =
+					    IOERR_SLI_ABORTED;
+					(iocb->iocb_cmpl) (phba, iocb, iocb);
+				} else {
+					lpfc_iocb_free(phba, iocb);
+				}
+			}
+		}
+	}
+	return (0);
+}
+
+int
+lpfc_issue_els_plogi(lpfcHBA_t * phba, LPFC_NODELIST_t * ndlp, uint8_t retry)
+{
+	SERV_PARM *sp;
+	IOCB_t *icmd;
+	LPFC_IOCBQ_t *elsiocb;
+	LPFC_SLI_RING_t *pring;
+	LPFC_SLI_t *psli;
+	uint8_t *pCmd;
+	uint16_t cmdsize;
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_ELS_RING];	/* ELS ring */
+
+	cmdsize = (sizeof (uint32_t) + sizeof (SERV_PARM));
+	if ((elsiocb = lpfc_prep_els_iocb(phba, TRUE, cmdsize, retry,
+					  ndlp, ELS_CMD_PLOGI)) == 0) {
+		return (1);
+	}
+
+	icmd = &elsiocb->iocb;
+	pCmd = (uint8_t *) (((DMABUF_t *) elsiocb->context2)->virt);
+
+	/* For PLOGI request, remainder of payload is service parameters */
+	*((uint32_t *) (pCmd)) = ELS_CMD_PLOGI;
+	pCmd += sizeof (uint32_t);
+	memcpy(pCmd, &phba->fc_sparam, sizeof (SERV_PARM));
+	sp = (SERV_PARM *) pCmd;
+
+	if (sp->cmn.fcphLow < FC_PH_4_3)
+		sp->cmn.fcphLow = FC_PH_4_3;
+
+	if (sp->cmn.fcphHigh < FC_PH3)
+		sp->cmn.fcphHigh = FC_PH3;
+
+	phba->fc_stat.elsXmitPLOGI++;
+	elsiocb->iocb_cmpl = lpfc_cmpl_els_plogi;
+	ndlp->nlp_flag |= NLP_PLOGI_SND;
+	if (lpfc_sli_issue_iocb(phba, pring, elsiocb, SLI_IOCB_USE_TXQ)
+	    == IOCB_ERROR) {
+		ndlp->nlp_flag &= ~NLP_PLOGI_SND;
+		lpfc_els_free_iocb(phba, elsiocb);
+		return (1);
+	}
+	return (0);
+}
+
+void
+lpfc_cmpl_els_plogi(lpfcHBA_t * phba,
+		    LPFC_IOCBQ_t * cmdiocb, LPFC_IOCBQ_t * rspiocb)
+{
+	IOCB_t *irsp;
+	LPFC_SLI_t *psli;
+	LPFC_NODELIST_t *ndlp;
+	int disc;
+
+	psli = &phba->sli;
+
+	/* we pass cmdiocb to state machine which needs rspiocb as well */
+	cmdiocb->context_un.rsp_iocb = rspiocb;
+
+	irsp = &rspiocb->iocb;
+	ndlp = (LPFC_NODELIST_t *) cmdiocb->context1;
+	ndlp->nlp_flag &= ~NLP_PLOGI_SND;
+
+	/* Since ndlp can be freed in the disc state machine, note if this node
+	 * is being used during discovery.
+	 */
+	disc = (ndlp->nlp_flag & NLP_DISC_NODE);
+	ndlp->nlp_flag &= ~NLP_DISC_NODE;
+
+	/* PLOGI completes to NPort <nlp_DID> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0102,
+			lpfc_mes0102, lpfc_msgBlk0102.msgPreambleStr,
+			ndlp->nlp_DID, irsp->ulpStatus, irsp->un.ulpWord[4],
+			disc, phba->num_disc_nodes);
+
+	/* Check to see if link went down during discovery */
+	if (lpfc_els_chk_latt(phba, rspiocb))
+		goto out;
+
+	if (irsp->ulpStatus) {
+		/* Check for retry */
+		if (lpfc_els_retry(phba, cmdiocb, rspiocb)) {
+			/* ELS command is being retried */
+			if (disc) {
+				ndlp->nlp_flag |= NLP_DISC_NODE;
+			}
+			goto out;
+		}
+
+		/* PLOGI failed */
+		if (!((irsp->ulpStatus == IOSTAT_LOCAL_REJECT) &&
+		      (irsp->un.ulpWord[4] == IOERR_SLI_ABORTED)))
+			lpfc_disc_state_machine(phba, ndlp, cmdiocb,
+						NLP_EVT_CMPL_PLOGI);
+	} else {
+		/* Good status, call state machine */
+		lpfc_disc_state_machine(phba, ndlp, cmdiocb,
+					NLP_EVT_CMPL_PLOGI);
+	}
+
+	if (disc && phba->num_disc_nodes) {
+		/* Check to see if there are more PLOGIs to be sent */
+		lpfc_more_plogi(phba);
+	}
+
+	if (phba->num_disc_nodes == 0) {
+		if (disc) {
+			phba->hba_flag &= ~FC_NDISC_ACTIVE;
+		}
+		lpfc_can_disctmo(phba);
+		if (phba->fc_flag & FC_RSCN_MODE) {
+			/* Check to see if more RSCNs came in while we were
+			 * processing this one.
+			 */
+			if ((phba->fc_rscn_id_cnt == 0) &&
+			    (!(phba->fc_flag & FC_RSCN_DISCOVERY))) {
+				lpfc_els_flush_rscn(phba);
+			} else {
+				lpfc_els_handle_rscn(phba);
+			}
+		}
+	}
+
+      out:
+	lpfc_els_free_iocb(phba, cmdiocb);
+	return;
+}
+
+int
+lpfc_issue_els_prli(lpfcHBA_t * phba, LPFC_NODELIST_t * ndlp, uint8_t retry)
+{
+	PRLI *npr;
+	IOCB_t *icmd;
+	LPFC_IOCBQ_t *elsiocb;
+	LPFC_SLI_RING_t *pring;
+	LPFC_SLI_t *psli;
+	uint8_t *pCmd;
+	uint16_t cmdsize;
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_ELS_RING];	/* ELS ring */
+
+	cmdsize = (sizeof (uint32_t) + sizeof (PRLI));
+	if ((elsiocb = lpfc_prep_els_iocb(phba, TRUE, cmdsize, retry,
+					  ndlp, ELS_CMD_PRLI)) == 0) {
+		return (1);
+	}
+
+	icmd = &elsiocb->iocb;
+	pCmd = (uint8_t *) (((DMABUF_t *) elsiocb->context2)->virt);
+
+	/* For PRLI request, remainder of payload is service parameters */
+	memset(pCmd, 0, (sizeof (PRLI) + sizeof (uint32_t)));
+	*((uint32_t *) (pCmd)) = ELS_CMD_PRLI;
+	pCmd += sizeof (uint32_t);
+
+	/* For PRLI, remainder of payload is PRLI parameter page */
+	npr = (PRLI *) pCmd;
+	/*
+	 * If our firmware version is 3.20 or later, 
+	 * set the following bits for FC-TAPE support.
+	 */
+	if (phba->vpd.rev.feaLevelHigh >= 0x02) {
+		npr->ConfmComplAllowed = 1;
+		npr->Retry = 1;
+		npr->TaskRetryIdReq = 1;
+	}
+	npr->estabImagePair = 1;
+	npr->readXferRdyDis = 1;
+
+	/* For FCP support */
+	npr->prliType = PRLI_FCP_TYPE;
+	npr->initiatorFunc = 1;
+
+	phba->fc_stat.elsXmitPRLI++;
+	elsiocb->iocb_cmpl = lpfc_cmpl_els_prli;
+	ndlp->nlp_flag |= NLP_PRLI_SND;
+	if (lpfc_sli_issue_iocb(phba, pring, elsiocb, SLI_IOCB_USE_TXQ) ==
+	    IOCB_ERROR) {
+		ndlp->nlp_flag &= ~NLP_PRLI_SND;
+		lpfc_els_free_iocb(phba, elsiocb);
+		return (1);
+	}
+	phba->fc_prli_sent++;
+	return (0);
+}
+
+void
+lpfc_cmpl_els_prli(lpfcHBA_t * phba,
+		   LPFC_IOCBQ_t * cmdiocb, LPFC_IOCBQ_t * rspiocb)
+{
+	IOCB_t *irsp;
+	LPFC_SLI_t *psli;
+	LPFC_NODELIST_t *ndlp;
+
+	psli = &phba->sli;
+	/* we pass cmdiocb to state machine which needs rspiocb as well */
+	cmdiocb->context_un.rsp_iocb = rspiocb;
+
+	irsp = &(rspiocb->iocb);
+	ndlp = (LPFC_NODELIST_t *) cmdiocb->context1;
+	ndlp->nlp_flag &= ~NLP_PRLI_SND;
+
+	/* PRLI completes to NPort <nlp_DID> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0103,
+			lpfc_mes0103, lpfc_msgBlk0103.msgPreambleStr,
+			ndlp->nlp_DID, irsp->ulpStatus, irsp->un.ulpWord[4],
+			phba->num_disc_nodes);
+
+	phba->fc_prli_sent--;
+	/* Check to see if link went down during discovery */
+	if (lpfc_els_chk_latt(phba, rspiocb))
+		goto out;
+
+	if (irsp->ulpStatus) {
+		/* Check for retry */
+		if (lpfc_els_retry(phba, cmdiocb, rspiocb)) {
+			/* ELS command is being retried */
+			goto out;
+		}
+		/* PRLI failed */
+		if ((!((irsp->ulpStatus == IOSTAT_LOCAL_REJECT) &&
+		       (irsp->un.ulpWord[4] == IOERR_SLI_ABORTED))) ||
+		    (ndlp->nlp_state == NLP_STE_PRLI_ISSUE))
+			lpfc_disc_state_machine(phba, ndlp, cmdiocb, NLP_EVT_CMPL_PRLI);
+	} else {
+		/* Good status, call state machine */
+		lpfc_disc_state_machine(phba, ndlp, cmdiocb, NLP_EVT_CMPL_PRLI);
+	}
+
+      out:
+	lpfc_els_free_iocb(phba, cmdiocb);
+	return;
+}
+
+int
+lpfc_issue_els_adisc(lpfcHBA_t * phba, LPFC_NODELIST_t * ndlp, uint8_t retry)
+{
+	ADISC *ap;
+	IOCB_t *icmd;
+	LPFC_IOCBQ_t *elsiocb;
+	LPFC_SLI_RING_t *pring;
+	LPFC_SLI_t *psli;
+	uint8_t *pCmd;
+	uint16_t cmdsize;
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_ELS_RING];	/* ELS ring */
+
+	cmdsize = (sizeof (uint32_t) + sizeof (ADISC));
+	if ((elsiocb = lpfc_prep_els_iocb(phba, TRUE, cmdsize, retry,
+					  ndlp, ELS_CMD_ADISC)) == 0) {
+		return (1);
+	}
+
+	icmd = &elsiocb->iocb;
+	pCmd = (uint8_t *) (((DMABUF_t *) elsiocb->context2)->virt);
+
+	/* For ADISC request, remainder of payload is service parameters */
+	*((uint32_t *) (pCmd)) = ELS_CMD_ADISC;
+	pCmd += sizeof (uint32_t);
+
+	/* Fill in ADISC payload */
+	ap = (ADISC *) pCmd;
+	ap->hardAL_PA = phba->fc_pref_ALPA;
+	memcpy(&ap->portName, &phba->fc_portname, sizeof (NAME_TYPE));
+	memcpy(&ap->nodeName, &phba->fc_nodename, sizeof (NAME_TYPE));
+	ap->DID = be32_to_cpu(phba->fc_myDID);
+
+	phba->fc_stat.elsXmitADISC++;
+	elsiocb->iocb_cmpl = lpfc_cmpl_els_adisc;
+	ndlp->nlp_flag |= NLP_ADISC_SND;
+	if (lpfc_sli_issue_iocb(phba, pring, elsiocb, SLI_IOCB_USE_TXQ) ==
+	    IOCB_ERROR) {
+		ndlp->nlp_flag &= ~NLP_ADISC_SND;
+		lpfc_els_free_iocb(phba, elsiocb);
+		return (1);
+	}
+	return (0);
+}
+
+/* lpfc_rscn_disc is only called by lpfc_cmpl_els_adisc below */
+static void
+lpfc_rscn_disc(lpfcHBA_t * phba)
+{
+	LPFC_NODELIST_t *ndlp;
+	lpfcCfgParam_t *clp;
+	struct list_head *pos;
+
+	clp = &phba->config[0];
+
+	/* RSCN discovery */
+	/* go thru PLOGI list and issue ELS PLOGIs */
+	if (phba->fc_plogi_cnt) {
+		list_for_each(pos, &phba->fc_plogi_list) {
+			ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			if (ndlp->nlp_state == NLP_STE_UNUSED_NODE) {
+				ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+				lpfc_issue_els_plogi(phba, ndlp, 0);
+				ndlp->nlp_flag |= NLP_DISC_NODE;
+				phba->num_disc_nodes++;
+				if (phba->num_disc_nodes >=
+				    clp[LPFC_CFG_DISC_THREADS].a_current) {
+					if (phba->fc_plogi_cnt >
+					    phba->num_disc_nodes)
+						phba->fc_flag |= FC_NLP_MORE;
+					break;
+				}
+			}
+		}
+	} else {
+		if (phba->fc_flag & FC_RSCN_MODE) {
+			/* Check to see if more RSCNs came in while we were
+			 * processing this one.
+			 */
+			if ((phba->fc_rscn_id_cnt == 0) &&
+			    (!(phba->fc_flag & FC_RSCN_DISCOVERY))) {
+				lpfc_els_flush_rscn(phba);
+			} else {
+				lpfc_els_handle_rscn(phba);
+			}
+		}
+	}
+}
+
+void
+lpfc_cmpl_els_adisc(lpfcHBA_t * phba, LPFC_IOCBQ_t * cmdiocb,
+		    LPFC_IOCBQ_t * rspiocb)
+{
+	IOCB_t *irsp;
+	LPFC_SLI_t *psli;
+	LPFC_NODELIST_t *ndlp;
+	LPFC_MBOXQ_t *mbox;
+	int disc;
+	lpfcCfgParam_t *clp;
+
+	clp = &phba->config[0];
+	psli = &phba->sli;
+
+	/* we pass cmdiocb to state machine which needs rspiocb as well */
+	cmdiocb->context_un.rsp_iocb = rspiocb;
+
+	irsp = &(rspiocb->iocb);
+	ndlp = (LPFC_NODELIST_t *) cmdiocb->context1;
+	ndlp->nlp_flag &= ~NLP_ADISC_SND;
+
+	if ((irsp->ulpStatus ) &&
+	    (irsp->un.ulpWord[4] == IOERR_SLI_DOWN))
+		goto out;
+
+	/* Since ndlp can be freed in the disc state machine, note if this node
+	 * is being used during discovery.
+	 */
+	disc = (ndlp->nlp_flag & NLP_DISC_NODE);
+	ndlp->nlp_flag &= ~NLP_DISC_NODE;
+
+	/* ADISC completes to NPort <nlp_DID> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0104,
+			lpfc_mes0104, lpfc_msgBlk0104.msgPreambleStr,
+			ndlp->nlp_DID, irsp->ulpStatus, irsp->un.ulpWord[4],
+			disc, phba->num_disc_nodes);
+
+	/* Check to see if link went down during discovery */
+	if (lpfc_els_chk_latt(phba, rspiocb))
+		goto out;
+
+	if (irsp->ulpStatus) {
+		/* Check for retry */
+		if (lpfc_els_retry(phba, cmdiocb, rspiocb)) {
+			/* ELS command is being retried */
+			if (disc) {
+				ndlp->nlp_flag |= NLP_DISC_NODE;
+				lpfc_set_disctmo(phba);
+			}
+			goto out;
+		}
+		/* ADISC failed */
+		if (!((irsp->ulpStatus == IOSTAT_LOCAL_REJECT) &&
+		      (irsp->un.ulpWord[4] == IOERR_SLI_ABORTED))) {
+			lpfc_disc_state_machine(phba, ndlp, cmdiocb,
+						NLP_EVT_CMPL_ADISC);
+		}
+	} else {
+		/* Good status, call state machine */
+		lpfc_disc_state_machine(phba, ndlp, cmdiocb,
+					NLP_EVT_CMPL_ADISC);
+	}
+
+	if (disc && phba->num_disc_nodes) {
+		/* Check to see if there are more ADISCs to be sent */
+		lpfc_more_adisc(phba);
+
+		/* Check to see if we are done with ADISC authentication */
+		if (phba->num_disc_nodes == 0) {
+			/* If we get here, there is nothing left to wait for */
+			if ((phba->hba_state < LPFC_HBA_READY) &&
+			    (phba->hba_state != LPFC_CLEAR_LA)) {
+				/* Link up discovery */
+				if ((mbox = lpfc_mbox_alloc(phba, MEM_PRI))) {
+					phba->hba_state = LPFC_CLEAR_LA;
+					lpfc_clear_la(phba, mbox);
+					mbox->mbox_cmpl =
+					    lpfc_mbx_cmpl_clear_la;
+					if (lpfc_sli_issue_mbox
+					    (phba, mbox,
+					     (MBX_NOWAIT | MBX_STOP_IOCB))
+					    == MBX_NOT_FINISHED) {
+						lpfc_mbox_free(phba, mbox);
+						lpfc_disc_flush_list(phba);
+						psli->ring[(psli->ip_ring)].
+						    flag &=
+						    ~LPFC_STOP_IOCB_EVENT;
+						psli->ring[(psli->fcp_ring)].
+						    flag &=
+						    ~LPFC_STOP_IOCB_EVENT;
+						psli->ring[(psli->next_ring)].
+						    flag &=
+						    ~LPFC_STOP_IOCB_EVENT;
+						phba->hba_state =
+						    LPFC_HBA_READY;
+					}
+				}
+			} else {
+				lpfc_rscn_disc(phba);
+			}
+		}
+	}
+      out:
+	lpfc_els_free_iocb(phba, cmdiocb);
+	return;
+}
+
+int
+lpfc_issue_els_logo(lpfcHBA_t * phba, LPFC_NODELIST_t * ndlp, uint8_t retry)
+{
+	IOCB_t *icmd;
+	LPFC_IOCBQ_t *elsiocb;
+	LPFC_SLI_RING_t *pring;
+	LPFC_SLI_t *psli;
+	uint8_t *pCmd;
+	uint16_t cmdsize;
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_ELS_RING];
+
+	cmdsize = 2 * (sizeof (uint32_t) + sizeof (NAME_TYPE));
+	if ((elsiocb = lpfc_prep_els_iocb(phba, TRUE, cmdsize, retry,
+					  ndlp, ELS_CMD_LOGO)) == 0) {
+		return (1);
+	}
+
+	icmd = &elsiocb->iocb;
+	pCmd = (uint8_t *) (((DMABUF_t *) elsiocb->context2)->virt);
+	*((uint32_t *) (pCmd)) = ELS_CMD_LOGO;
+	pCmd += sizeof (uint32_t);
+
+	/* Fill in LOGO payload */
+	*((uint32_t *) (pCmd)) = be32_to_cpu(phba->fc_myDID);
+	pCmd += sizeof (uint32_t);
+	memcpy(pCmd, &phba->fc_portname, sizeof (NAME_TYPE));
+
+	phba->fc_stat.elsXmitLOGO++;
+	elsiocb->iocb_cmpl = lpfc_cmpl_els_logo;
+	ndlp->nlp_flag |= NLP_LOGO_SND;
+	if (lpfc_sli_issue_iocb(phba, pring, elsiocb, SLI_IOCB_USE_TXQ) ==
+	    IOCB_ERROR) {
+		ndlp->nlp_flag &= ~NLP_LOGO_SND;
+		lpfc_els_free_iocb(phba, elsiocb);
+		return (1);
+	}
+	return (0);
+}
+
+void
+lpfc_cmpl_els_logo(lpfcHBA_t * phba,
+		   LPFC_IOCBQ_t * cmdiocb, LPFC_IOCBQ_t * rspiocb)
+{
+	IOCB_t *irsp;
+	LPFC_SLI_t *psli;
+	LPFC_NODELIST_t *ndlp;
+
+	psli = &phba->sli;
+	/* we pass cmdiocb to state machine which needs rspiocb as well */
+	cmdiocb->context_un.rsp_iocb = rspiocb;
+
+	irsp = &(rspiocb->iocb);
+	ndlp = (LPFC_NODELIST_t *) cmdiocb->context1;
+	ndlp->nlp_flag &= ~NLP_LOGO_SND;
+
+	/* LOGO completes to NPort <nlp_DID> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0105,
+			lpfc_mes0105, lpfc_msgBlk0105.msgPreambleStr,
+			ndlp->nlp_DID, irsp->ulpStatus, irsp->un.ulpWord[4],
+			phba->num_disc_nodes);
+
+	/* Check to see if link went down during discovery */
+	if (lpfc_els_chk_latt(phba, rspiocb))
+		goto out;
+
+	if (irsp->ulpStatus) {
+		/* Check for retry */
+		if (lpfc_els_retry(phba, cmdiocb, rspiocb)) {
+			/* ELS command is being retried */
+			goto out;
+		}
+		/* LOGO failed */
+		if (!((irsp->ulpStatus == IOSTAT_LOCAL_REJECT) &&
+		      (irsp->un.ulpWord[4] == IOERR_SLI_ABORTED)))
+			lpfc_disc_state_machine(phba, ndlp, cmdiocb, NLP_EVT_CMPL_LOGO);
+	} else {
+		/* Good status, call state machine */
+		lpfc_disc_state_machine(phba, ndlp, cmdiocb, NLP_EVT_CMPL_LOGO);
+	}
+
+      out:
+	lpfc_els_free_iocb(phba, cmdiocb);
+	return;
+}
+
+int
+lpfc_issue_els_scr(lpfcHBA_t * phba, uint32_t nportid, uint8_t retry)
+{
+	IOCB_t *icmd;
+	LPFC_IOCBQ_t *elsiocb;
+	LPFC_SLI_RING_t *pring;
+	LPFC_SLI_t *psli;
+	uint8_t *pCmd;
+	uint16_t cmdsize;
+	LPFC_NODELIST_t *ndlp;
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_ELS_RING];	/* ELS ring */
+	cmdsize = (sizeof (uint32_t) + sizeof (SCR));
+	if ((ndlp = lpfc_nlp_alloc(phba, 0)) == 0) {
+		return (1);
+	}
+
+	memset(ndlp, 0, sizeof (LPFC_NODELIST_t));
+	ndlp->nlp_DID = nportid;
+
+	if ((elsiocb = lpfc_prep_els_iocb(phba, TRUE, cmdsize, retry,
+					  ndlp, ELS_CMD_SCR)) == 0) {
+		lpfc_nlp_free(phba, ndlp);
+		return (1);
+	}
+
+	icmd = &elsiocb->iocb;
+	pCmd = (uint8_t *) (((DMABUF_t *) elsiocb->context2)->virt);
+
+	*((uint32_t *) (pCmd)) = ELS_CMD_SCR;
+	pCmd += sizeof (uint32_t);
+
+	/* For SCR, remainder of payload is SCR parameter page */
+	memset(pCmd, 0, sizeof (SCR));
+	((SCR *) pCmd)->Function = SCR_FUNC_FULL;
+
+	phba->fc_stat.elsXmitSCR++;
+	elsiocb->iocb_cmpl = lpfc_cmpl_els_cmd;
+	if (lpfc_sli_issue_iocb(phba, pring, elsiocb, SLI_IOCB_USE_TXQ) ==
+	    IOCB_ERROR) {
+		lpfc_nlp_free(phba, ndlp);
+		lpfc_els_free_iocb(phba, elsiocb);
+		return (1);
+	}
+	lpfc_nlp_free(phba, ndlp);
+	return (0);
+}
+
+int
+lpfc_issue_els_farp(lpfcHBA_t * phba, uint8_t * arg,
+		    LPFC_FARP_ADDR_TYPE argFlag)
+{
+	IOCB_t *icmd;
+	LPFC_IOCBQ_t *elsiocb;
+	LPFC_SLI_RING_t *pring;
+	LPFC_SLI_t *psli;
+	FARP *fp;
+	uint8_t *pCmd;
+	uint32_t *lp;
+	uint16_t cmdsize;
+	LPFC_NODELIST_t *ndlp;
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_ELS_RING];	/* ELS ring */
+
+	cmdsize = (sizeof (uint32_t) + sizeof (FARP));
+	if ((ndlp = lpfc_nlp_alloc(phba, 0)) == 0) {
+		return (1);
+	}
+	memset(ndlp, 0, sizeof (LPFC_NODELIST_t));
+	ndlp->nlp_DID = Bcast_DID;
+	if ((elsiocb = lpfc_prep_els_iocb(phba, TRUE, cmdsize, 0,
+					  ndlp, ELS_CMD_RNID)) == 0) {
+		lpfc_nlp_free(phba, ndlp);
+		return (1);
+	}
+
+	pCmd = (uint8_t *) (((DMABUF_t *) elsiocb->context2)->virt);
+	*((uint32_t *) (pCmd)) = ELS_CMD_FARP;
+	pCmd += sizeof (uint32_t);
+
+	/* Provide a timeout value, function, and context.  If the IP node on
+	 * far end never responds, this FARP and all IP bufs must be timed out.
+	 */
+	icmd = &elsiocb->iocb;
+	icmd->ulpTimeout = phba->fc_ipfarp_timeout;
+	icmd->ulpContext = (uint16_t) ELS_CMD_FARP;
+
+	/* Fill in FARP payload */
+
+	fp = (FARP *) (pCmd);
+	memset(fp, 0, sizeof (FARP));
+	lp = (uint32_t *) pCmd;
+	*lp++ = be32_to_cpu(phba->fc_myDID);
+	fp->Mflags = FARP_MATCH_PORT;
+	fp->Rflags = FARP_REQUEST_PLOGI;
+	memcpy(&fp->OportName, &phba->fc_portname, sizeof (NAME_TYPE));
+	memcpy(&fp->OnodeName, &phba->fc_nodename, sizeof (NAME_TYPE));
+	switch (argFlag) {
+	case LPFC_FARP_BY_IEEE:
+		fp->Mflags = FARP_MATCH_PORT;
+		fp->RportName.nameType = NAME_IEEE;	/* IEEE name */
+		fp->RportName.IEEEextMsn = 0;
+		fp->RportName.IEEEextLsb = 0;
+		memcpy(fp->RportName.IEEE, arg, 6);
+		fp->RnodeName.nameType = NAME_IEEE;	/* IEEE name */
+		fp->RnodeName.IEEEextMsn = 0;
+		fp->RnodeName.IEEEextLsb = 0;
+		memcpy(fp->RnodeName.IEEE, arg, 6);
+		break;
+	case LPFC_FARP_BY_WWPN:
+		fp->Mflags = FARP_MATCH_PORT;
+		memcpy(&fp->RportName, arg, sizeof (NAME_TYPE));
+		break;
+	case LPFC_FARP_BY_WWNN:
+		fp->Mflags = FARP_MATCH_NODE;
+		memcpy(&fp->RnodeName, arg, sizeof (NAME_TYPE));
+		break;
+	}
+
+	phba->fc_stat.elsXmitFARP++;
+
+	elsiocb->iocb_cmpl = lpfc_cmpl_els_cmd;
+	if (lpfc_sli_issue_iocb(phba, pring, elsiocb, SLI_IOCB_USE_TXQ) ==
+	    IOCB_ERROR) {
+		lpfc_nlp_free(phba, ndlp);
+		lpfc_els_free_iocb(phba, elsiocb);
+		return (1);
+	}
+
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0610,
+			lpfc_mes0610,
+			lpfc_msgBlk0610.msgPreambleStr,
+			phba->fc_nodename.IEEE[0], phba->fc_nodename.IEEE[1],
+			phba->fc_nodename.IEEE[2], phba->fc_nodename.IEEE[3],
+			phba->fc_nodename.IEEE[4], phba->fc_nodename.IEEE[5]);
+	return (0);
+}
+
+int
+lpfc_issue_els_farpr(lpfcHBA_t * phba, uint32_t nportid, uint8_t retry)
+{
+	IOCB_t *icmd;
+	LPFC_IOCBQ_t *elsiocb;
+	LPFC_SLI_RING_t *pring;
+	LPFC_SLI_t *psli;
+	FARP *fp;
+	uint8_t *pCmd;
+	uint32_t *lp;
+	uint16_t cmdsize;
+	LPFC_NODELIST_t *ondlp;
+	LPFC_NODELIST_t *ndlp;
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_ELS_RING];	/* ELS ring */
+	cmdsize = (sizeof (uint32_t) + sizeof (FARP));
+	if ((ndlp = lpfc_nlp_alloc(phba, 0)) == 0) {
+		return (1);
+	}
+	memset(ndlp, 0, sizeof (LPFC_NODELIST_t));
+	ndlp->nlp_DID = nportid;
+
+	if ((elsiocb = lpfc_prep_els_iocb(phba, TRUE, cmdsize, retry,
+					  ndlp, ELS_CMD_RNID)) == 0) {
+		lpfc_nlp_free(phba, ndlp);
+		return (1);
+	}
+
+	icmd = &elsiocb->iocb;
+	pCmd = (uint8_t *) (((DMABUF_t *) elsiocb->context2)->virt);
+
+	*((uint32_t *) (pCmd)) = ELS_CMD_FARPR;
+	pCmd += sizeof (uint32_t);
+
+	/* Fill in FARPR payload */
+	fp = (FARP *) (pCmd);
+	memset(fp, 0, sizeof (FARP));
+	lp = (uint32_t *) pCmd;
+	*lp++ = be32_to_cpu(nportid);
+	*lp++ = be32_to_cpu(phba->fc_myDID);
+	fp->Rflags = 0;
+	fp->Mflags = (FARP_MATCH_PORT | FARP_MATCH_NODE);
+
+	memcpy(&fp->RportName, &phba->fc_portname, sizeof (NAME_TYPE));
+	memcpy(&fp->RnodeName, &phba->fc_nodename, sizeof (NAME_TYPE));
+	if ((ondlp = lpfc_findnode_did(phba, NLP_SEARCH_ALL, nportid))) {
+		memcpy(&fp->OportName, &ondlp->nlp_portname,
+		       sizeof (NAME_TYPE));
+		memcpy(&fp->OnodeName, &ondlp->nlp_nodename,
+		       sizeof (NAME_TYPE));
+	}
+
+	phba->fc_stat.elsXmitFARPR++;
+	elsiocb->iocb_cmpl = lpfc_cmpl_els_cmd;
+	if (lpfc_sli_issue_iocb(phba, pring, elsiocb, SLI_IOCB_USE_TXQ) ==
+	    IOCB_ERROR) {
+		lpfc_nlp_free(phba, ndlp);
+		lpfc_els_free_iocb(phba, elsiocb);
+		return (1);
+	}
+	lpfc_nlp_free(phba, ndlp);
+	return (0);
+}
+
+void
+lpfc_cmpl_els_cmd(lpfcHBA_t * phba, LPFC_IOCBQ_t * cmdiocb,
+		  LPFC_IOCBQ_t * rspiocb)
+{
+	IOCB_t *irsp;
+
+	irsp = &rspiocb->iocb;
+
+	/* ELS cmd tag <ulpIoTag> completes */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0106,
+			lpfc_mes0106,
+			lpfc_msgBlk0106.msgPreambleStr,
+			irsp->ulpIoTag, irsp->ulpStatus, irsp->un.ulpWord[4]);
+
+	/* Check to see if link went down during discovery */
+	lpfc_els_chk_latt(phba, rspiocb);
+	lpfc_els_free_iocb(phba, cmdiocb);
+	return;
+}
+
+void
+lpfc_els_retry_delay(unsigned long ptr)
+{
+	lpfcHBA_t *phba;
+	LPFC_NODELIST_t *ndlp;
+	uint32_t cmd;
+	uint32_t did;
+	uint8_t retry;
+	struct clk_data *clkData;
+	unsigned long iflag;
+
+	clkData = (struct clk_data *)ptr;
+	phba = clkData->phba;
+	LPFC_DRVR_LOCK(phba, iflag);
+       	if (clkData->flags & TM_CANCELED) {
+		list_del((struct list_head *)clkData);
+		kfree(clkData);	
+		goto out;
+	}
+
+	did = (uint32_t) (unsigned long)(clkData->clData1);
+	cmd = (uint32_t) (unsigned long)(clkData->clData2);
+	clkData->timeObj->function = 0;
+	list_del((struct list_head *)clkData);
+	kfree(clkData);
+
+	if ((ndlp = lpfc_findnode_did(phba, NLP_SEARCH_ALL, did)) == 0) {
+		if ((ndlp = lpfc_nlp_alloc(phba, 0)) == 0) {
+			LPFC_DRVR_UNLOCK(phba, iflag);
+			return;
+		}
+		memset(ndlp, 0, sizeof (LPFC_NODELIST_t));
+		ndlp->nlp_DID = did;
+	}
+
+	ndlp->nlp_flag &= ~NLP_DELAY_TMO;
+	ndlp->nlp_tmofunc.function = 0;
+	retry = ndlp->nlp_retry;
+
+	switch (cmd) {
+	case ELS_CMD_FLOGI:
+		lpfc_issue_els_flogi(phba, ndlp, retry);
+		break;
+	case ELS_CMD_PLOGI:
+		ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+		lpfc_nlp_plogi(phba, ndlp);
+		lpfc_issue_els_plogi(phba, ndlp, retry);
+		break;
+	case ELS_CMD_ADISC:
+		lpfc_issue_els_adisc(phba, ndlp, retry);
+		break;
+	case ELS_CMD_PRLI:
+		lpfc_issue_els_prli(phba, ndlp, retry);
+		break;
+	case ELS_CMD_LOGO:
+		lpfc_issue_els_logo(phba, ndlp, retry);
+		break;
+	}
+out:
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	return;
+}
+
+int
+lpfc_els_retry(lpfcHBA_t * phba, LPFC_IOCBQ_t * cmdiocb, LPFC_IOCBQ_t * rspiocb)
+{
+	IOCB_t *irsp;
+	DMABUF_t *pCmd;
+	LPFC_NODELIST_t *ndlp;
+	uint32_t *elscmd;
+	lpfcCfgParam_t *clp;
+	LS_RJT stat;
+	int retry, maxretry;
+	int delay;
+	uint32_t cmd;
+
+	clp = &phba->config[0];
+	retry = 0;
+	delay = 0;
+	maxretry = lpfc_max_els_tries;
+	irsp = &rspiocb->iocb;
+	ndlp = (LPFC_NODELIST_t *) cmdiocb->context1;
+
+	pCmd = (DMABUF_t *) cmdiocb->context2;
+	cmd = 0;
+	/* Note: context2 may be 0 for internal driver abort 
+	 * of delays ELS command.
+	 */
+
+	if (pCmd && pCmd->virt) {
+		elscmd = (uint32_t *) (pCmd->virt);
+		cmd = *elscmd++;
+	}
+
+	switch (irsp->ulpStatus) {
+	case IOSTAT_FCP_RSP_ERROR:
+	case IOSTAT_REMOTE_STOP:
+		break;
+
+	case IOSTAT_LOCAL_REJECT:
+		if ((irsp->un.ulpWord[4] & 0xff) == IOERR_LINK_DOWN)
+			break;
+
+		if (irsp->un.ulpWord[4] == IOERR_SLI_DOWN)
+			break;
+
+		if ((irsp->un.ulpWord[4] & 0xff) == IOERR_LOOP_OPEN_FAILURE) {
+			if (cmd == ELS_CMD_PLOGI) {
+				if (cmdiocb->retry == 0) {
+					delay = 1;
+				}
+			}
+			retry = 1;
+			break;
+		}
+		if ((irsp->un.ulpWord[4] & 0xff) == IOERR_SEQUENCE_TIMEOUT) {
+			retry = 1;
+			if ((cmd == ELS_CMD_FLOGI)
+			    && (phba->fc_topology != TOPOLOGY_LOOP)) {
+				delay = 1;
+				maxretry = 48;
+			}
+			break;
+		}
+		if ((irsp->un.ulpWord[4] & 0xff) == IOERR_NO_RESOURCES) {
+			if (cmd == ELS_CMD_PLOGI) {
+				delay = 1;
+			}
+			retry = 1;
+			break;
+		}
+		if ((irsp->un.ulpWord[4] & 0xff) == IOERR_INVALID_RPI) {
+			retry = 1;
+			break;
+		}
+
+		if ((irsp->un.ulpWord[4] & 0xff) == IOERR_ABORT_REQUESTED) {
+			if (cmd == ELS_CMD_PRLI) {
+				if (cmdiocb->retry == 0) {
+					delay = 1;
+				}
+			}
+			retry = 1;
+			break;
+		}
+		break;
+
+	case IOSTAT_NPORT_RJT:
+	case IOSTAT_FABRIC_RJT:
+		if (irsp->un.ulpWord[4] & RJT_UNAVAIL_TEMP) {
+			retry = 1;
+			break;
+		}
+		break;
+
+	case IOSTAT_NPORT_BSY:
+	case IOSTAT_FABRIC_BSY:
+		retry = 1;
+		break;
+
+	case IOSTAT_LS_RJT:
+		stat.un.lsRjtError = be32_to_cpu(irsp->un.ulpWord[4]);
+		/* Added for Vendor specifc support
+		 * Just keep retrying for these Rsn / Exp codes
+		 */
+		switch (stat.un.b.lsRjtRsnCode) {
+		case LSRJT_UNABLE_TPC:
+			if (stat.un.b.lsRjtRsnCodeExp ==
+			    LSEXP_CMD_IN_PROGRESS) {
+				if (cmd == ELS_CMD_PLOGI) {
+					delay = 1;
+					maxretry = 48;
+				}
+				retry = 1;
+				break;
+			}
+			if (cmd == ELS_CMD_PLOGI) {
+				delay = 1;
+				maxretry = lpfc_max_els_tries + 1;
+				retry = 1;
+				break;
+			}
+			break;
+
+		case LSRJT_LOGICAL_BSY:
+			if (cmd == ELS_CMD_PLOGI) {
+				delay = 1;
+				maxretry = 48;
+			}
+			retry = 1;
+			break;
+		}
+		break;
+
+	case IOSTAT_INTERMED_RSP:
+	case IOSTAT_BA_RJT:
+		break;
+
+	default:
+		break;
+	}
+
+	if (ndlp->nlp_DID == FDMI_DID) {
+		retry = 1;
+	}
+
+	if ((++cmdiocb->retry) >= maxretry) {
+		phba->fc_stat.elsRetryExceeded++;
+		retry = 0;
+	}
+
+	if (retry) {
+
+		/* Retry ELS command <elsCmd> to remote NPORT <did> */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0107,
+				lpfc_mes0107,
+				lpfc_msgBlk0107.msgPreambleStr,
+				cmd, ndlp->nlp_DID, cmdiocb->retry, delay);
+
+		if ((cmd == ELS_CMD_PLOGI) || (cmd == ELS_CMD_ADISC)) {
+			/* If discovery / RSCN timer is running, reset it */
+			if ((phba->fc_disctmo.function)
+			    || (phba->fc_flag & FC_RSCN_MODE)) {
+				lpfc_set_disctmo(phba);
+			}
+		}
+
+		phba->fc_stat.elsXmitRetry++;
+		if (delay) {
+			phba->fc_stat.elsDelayRetry++;
+			if (ndlp->nlp_tmofunc.function) {
+				ndlp->nlp_flag &= ~NLP_DELAY_TMO;
+				lpfc_stop_timer((struct clk_data *)
+						ndlp->nlp_tmofunc.data);
+			}
+			if (cmd == ELS_CMD_PLOGI) {
+				lpfc_nlp_plogi(phba, ndlp);
+				ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+			}
+			ndlp->nlp_flag |= NLP_DELAY_TMO;
+			ndlp->nlp_retry = cmdiocb->retry;
+
+			lpfc_start_timer(phba, 1, &ndlp->nlp_tmofunc,
+					 lpfc_els_retry_delay,
+					 (unsigned long)ndlp->nlp_DID,
+					 (unsigned long)cmd);
+
+			return (1);
+		}
+		switch (cmd) {
+		case ELS_CMD_FLOGI:
+			lpfc_issue_els_flogi(phba, ndlp, cmdiocb->retry);
+			return (1);
+		case ELS_CMD_PLOGI:
+			lpfc_issue_els_plogi(phba, ndlp, cmdiocb->retry);
+			return (1);
+		case ELS_CMD_ADISC:
+			lpfc_issue_els_adisc(phba, ndlp, cmdiocb->retry);
+			return (1);
+		case ELS_CMD_PRLI:
+			lpfc_issue_els_prli(phba, ndlp, cmdiocb->retry);
+			return (1);
+		case ELS_CMD_LOGO:
+			lpfc_issue_els_logo(phba, ndlp, cmdiocb->retry);
+			return (1);
+		}
+	}
+
+	/* No retry ELS command <elsCmd> to remote NPORT <did> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0108,
+			lpfc_mes0108,
+			lpfc_msgBlk0108.msgPreambleStr,
+			cmd, ndlp->nlp_DID, cmdiocb->retry, ndlp->nlp_flag);
+
+	return (0);
+}
+
+LPFC_IOCBQ_t *
+lpfc_prep_els_iocb(lpfcHBA_t * phba,
+		   uint8_t expectRsp,
+		   uint16_t cmdSize,
+		   uint8_t retry, LPFC_NODELIST_t * ndlp, uint32_t elscmd)
+{
+	LPFC_SLI_t *psli;
+	LPFC_SLI_RING_t *pring;
+	LPFC_IOCBQ_t *elsiocb;
+	DMABUF_t *pCmd, *pRsp, *pBufList;
+	ULP_BDE64 *bpl;
+	IOCB_t *icmd;
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_ELS_RING];	/* ELS ring */
+
+	if (phba->hba_state < LPFC_LINK_UP) {
+		return (0);
+	}
+
+	/* Allocate buffer for  command iocb */
+	if ((elsiocb = lpfc_iocb_alloc(phba, MEM_PRI)) == 0) {
+		return (0);
+	}
+	memset(elsiocb, 0, sizeof (LPFC_IOCBQ_t));
+	icmd = &elsiocb->iocb;
+
+	/* fill in BDEs for command */
+	/* Allocate buffer for command payload */
+	if (((pCmd = kmalloc(sizeof (DMABUF_t), GFP_ATOMIC)) == 0) ||
+	    ((pCmd->virt = lpfc_mbuf_alloc(phba,
+					   MEM_PRI, &(pCmd->phys))) == 0)) {
+		if (pCmd)
+			kfree(pCmd);
+		lpfc_iocb_free(phba, elsiocb);
+		return (0);
+	}
+
+	INIT_LIST_HEAD(&pCmd->list);
+
+	/* Allocate buffer for response payload */
+	if (expectRsp) {
+		if (((pRsp = kmalloc(sizeof (DMABUF_t), GFP_ATOMIC)) == 0) ||
+		    ((pRsp->virt = lpfc_mbuf_alloc(phba,
+						   MEM_PRI,
+						   &(pRsp->phys))) == 0)) {
+			if (pRsp)
+				kfree(pRsp);
+			lpfc_mbuf_free(phba, pCmd->virt, pCmd->phys);
+			kfree(pCmd);
+			lpfc_iocb_free(phba, elsiocb);
+			return (0);
+		}
+		INIT_LIST_HEAD(&pRsp->list);
+	} else {
+		pRsp = 0;
+	}
+
+	/* Allocate buffer for Buffer ptr list */
+	if (((pBufList = kmalloc(sizeof (DMABUF_t), GFP_ATOMIC)) == 0) ||
+	    ((pBufList->virt = lpfc_mbuf_alloc(phba,
+					       MEM_PRI,
+					       &(pBufList->phys))) == 0)) {
+		lpfc_iocb_free(phba, elsiocb);
+		lpfc_mbuf_free(phba, pCmd->virt, pCmd->phys);
+		lpfc_mbuf_free(phba, pRsp->virt, pRsp->phys);
+		kfree(pCmd);
+		kfree(pRsp);
+		if (pBufList)
+			kfree(pBufList);
+		return (0);
+	}
+
+	INIT_LIST_HEAD(&pBufList->list);
+
+	icmd->un.elsreq64.bdl.addrHigh = putPaddrHigh(pBufList->phys);
+	icmd->un.elsreq64.bdl.addrLow = putPaddrLow(pBufList->phys);
+	icmd->un.elsreq64.bdl.bdeFlags = BUFF_TYPE_BDL;
+	if (expectRsp) {
+		icmd->un.elsreq64.bdl.bdeSize = (2 * sizeof (ULP_BDE64));
+		icmd->un.elsreq64.remoteID = ndlp->nlp_DID;	/* DID */
+		icmd->ulpCommand = CMD_ELS_REQUEST64_CR;
+	} else {
+		icmd->un.elsreq64.bdl.bdeSize = sizeof (ULP_BDE64);
+		icmd->ulpCommand = CMD_XMIT_ELS_RSP64_CX;
+	}
+
+	/* NOTE: we don't use ulpIoTag0 because it is a t2 structure */
+	icmd->ulpIoTag = lpfc_sli_next_iotag(phba, pring);
+	icmd->un.elsreq64.bdl.ulpIoTag32 = (uint32_t) icmd->ulpIoTag;
+	icmd->ulpBdeCount = 1;
+	icmd->ulpLe = 1;
+	icmd->ulpClass = CLASS3;
+
+	bpl = (ULP_BDE64 *) pBufList->virt;
+	bpl->addrLow = le32_to_cpu(putPaddrLow(pCmd->phys));
+	bpl->addrHigh = le32_to_cpu(putPaddrHigh(pCmd->phys));
+	bpl->tus.f.bdeSize = cmdSize;
+	bpl->tus.f.bdeFlags = 0;
+	bpl->tus.w = le32_to_cpu(bpl->tus.w);
+
+	if (expectRsp) {
+		bpl++;
+		bpl->addrLow = le32_to_cpu(putPaddrLow(pRsp->phys));
+		bpl->addrHigh = le32_to_cpu(putPaddrHigh(pRsp->phys));
+		bpl->tus.f.bdeSize = FCELSSIZE;
+		bpl->tus.f.bdeFlags = BUFF_USE_RCV;
+		bpl->tus.w = le32_to_cpu(bpl->tus.w);
+	}
+
+	/* Save for completion so we can release these resources */
+	elsiocb->context1 = (uint8_t *) ndlp;
+	elsiocb->context2 = (uint8_t *) pCmd;
+	elsiocb->context3 = (uint8_t *) pBufList;
+	elsiocb->retry = retry;
+	elsiocb->drvrTimeout = (phba->fc_ratov << 1) + LPFC_DRVR_TIMEOUT;
+
+	if (pRsp) {
+		list_add(&pRsp->list, &pCmd->list);
+	}
+
+	if (expectRsp) {
+		/* Xmit ELS command <elsCmd> to remote NPORT <did> */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0116, lpfc_mes0116,
+				lpfc_msgBlk0116.msgPreambleStr, elscmd,
+				ndlp->nlp_DID, icmd->ulpIoTag, phba->hba_state);
+	} else {
+		/* Xmit ELS response <elsCmd> to remote NPORT <did> */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0117, lpfc_mes0117,
+				lpfc_msgBlk0117.msgPreambleStr, elscmd,
+				ndlp->nlp_DID, icmd->ulpIoTag, cmdSize);
+	}
+
+	return (elsiocb);
+}
+
+int
+lpfc_els_free_iocb(lpfcHBA_t * phba, LPFC_IOCBQ_t * elsiocb)
+{
+	DMABUF_t *buf_ptr, *buf_ptr1;
+
+	/* context2  = cmd,  context2->next = rsp, context3 = bpl */
+	if (elsiocb->context2) {
+		buf_ptr1 = (DMABUF_t *) elsiocb->context2;
+		/* Free the response before processing the command.  */
+		if (!list_empty(&buf_ptr1->list)) {
+			buf_ptr = list_entry(buf_ptr1->list.next,
+					     DMABUF_t, list);
+			lpfc_mbuf_free(phba, buf_ptr->virt, buf_ptr->phys);
+			kfree(buf_ptr);
+		}
+		lpfc_mbuf_free(phba, buf_ptr1->virt, buf_ptr1->phys);
+		kfree(buf_ptr1);
+	}
+
+	if (elsiocb->context3) {
+		buf_ptr = (DMABUF_t *) elsiocb->context3;
+		lpfc_mbuf_free(phba, buf_ptr->virt, buf_ptr->phys);
+		kfree(buf_ptr);
+	}
+
+	lpfc_iocb_free(phba, elsiocb);
+	return 0;
+}
+
+void
+lpfc_cmpl_els_logo_acc(lpfcHBA_t * phba,
+		       LPFC_IOCBQ_t * cmdiocb, LPFC_IOCBQ_t * rspiocb)
+{
+	LPFC_NODELIST_t *ndlp;
+	lpfcCfgParam_t *clp;
+	int delay;
+
+	clp = &phba->config[0];
+	ndlp = (LPFC_NODELIST_t *) cmdiocb->context1;
+
+	/* ACC to LOGO completes to NPort <nlp_DID> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0109,
+			lpfc_mes0109,
+			lpfc_msgBlk0109.msgPreambleStr,
+			ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,
+			ndlp->nlp_rpi);
+
+	delay = 1;
+	switch (ndlp->nlp_state) {
+	case NLP_STE_UNUSED_NODE:	/* node is just allocated */
+	case NLP_STE_PLOGI_ISSUE:	/* PLOGI was sent to NL_PORT */
+	case NLP_STE_REG_LOGIN_ISSUE:	/* REG_LOGIN was issued for NL_PORT */
+		break;
+	case NLP_STE_PRLI_ISSUE:	/* PRLI was sent to NL_PORT */
+		/* dequeue, cancel timeout, unreg login */
+		lpfc_freenode(phba, ndlp);
+
+		/* put back on plogi list and send a new plogi */
+		lpfc_nlp_plogi(phba, ndlp);
+		ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+		lpfc_issue_els_plogi(phba, ndlp, 0);
+		break;
+
+	case NLP_STE_PRLI_COMPL:	/* PRLI completed from NL_PORT */
+		delay = 0;
+		if((ndlp->nlp_DID & Fabric_DID_MASK) == Fabric_DID_MASK) {
+			lpfc_nlp_remove(phba, ndlp);
+			ndlp = 0;
+			break;
+		}
+
+	case NLP_STE_MAPPED_NODE:	/* Identified as a FCP Target */
+
+		lpfc_set_failmask(phba, ndlp, LPFC_DEV_DISCONNECTED,
+				  LPFC_SET_BITMASK);
+		if (ndlp->nlp_flag & NLP_ADISC_SND) {
+			/* dequeue, cancel timeout, unreg login */
+			lpfc_freenode(phba, ndlp);
+
+			/* put back on plogi list and send a new plogi */
+			lpfc_nlp_plogi(phba, ndlp);
+			ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+			lpfc_issue_els_plogi(phba, ndlp, 0);
+		} else {
+			/* dequeue, cancel timeout, unreg login */
+			lpfc_freenode(phba, ndlp);
+
+			if (ndlp->nlp_tmofunc.function) {
+				ndlp->nlp_flag &= ~NLP_DELAY_TMO;
+				lpfc_stop_timer((struct clk_data *)
+						ndlp->nlp_tmofunc.data);
+			}
+			lpfc_nlp_plogi(phba, ndlp);
+			ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+			ndlp->nlp_flag |= NLP_DELAY_TMO;
+			ndlp->nlp_retry = 0;
+
+			lpfc_start_timer(phba, delay, &ndlp->nlp_tmofunc,
+					 lpfc_els_retry_delay,
+					 (unsigned long)ndlp->nlp_DID,
+					 (unsigned long)ELS_CMD_PLOGI);
+
+		}
+		break;
+	}
+	if(ndlp)
+		ndlp->nlp_flag &= ~NLP_LOGO_ACC;
+	lpfc_els_free_iocb(phba, cmdiocb);
+	return;
+}
+
+void
+lpfc_cmpl_els_acc(lpfcHBA_t * phba, LPFC_IOCBQ_t * cmdiocb,
+		  LPFC_IOCBQ_t * rspiocb)
+{
+	LPFC_NODELIST_t *ndlp;
+	LPFC_MBOXQ_t *mbox = 0;
+
+	ndlp = (LPFC_NODELIST_t *) cmdiocb->context1;
+	if (!ndlp) {
+
+		/* Check to see if link went down during discovery */
+		lpfc_els_chk_latt(phba, rspiocb);
+
+		lpfc_els_free_iocb(phba, cmdiocb);
+		return;
+	}
+
+	/* ELS response tag <ulpIoTag> completes */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0110,
+			lpfc_mes0110,
+			lpfc_msgBlk0110.msgPreambleStr,
+			cmdiocb->iocb.ulpIoTag, rspiocb->iocb.ulpStatus,
+			rspiocb->iocb.un.ulpWord[4], ndlp->nlp_DID,
+			ndlp->nlp_flag, ndlp->nlp_state, ndlp->nlp_rpi);
+
+	if (cmdiocb->context_un.mbox)
+		mbox = cmdiocb->context_un.mbox;
+
+	if (mbox) {
+		if ((rspiocb->iocb.ulpStatus == 0)
+		    && (ndlp->nlp_flag & NLP_ACC_REGLOGIN)) {
+			/* set_slim mailbox command needs to execute first,
+			 * queue this command to be processed later.
+			 */
+			mbox->mbox_cmpl = lpfc_mbx_cmpl_reg_login;
+			mbox->context2 = ndlp;
+			ndlp->nlp_state = NLP_STE_REG_LOGIN_ISSUE;
+			if (lpfc_sli_issue_mbox(phba, mbox,
+						(MBX_NOWAIT | MBX_STOP_IOCB))
+			    != MBX_NOT_FINISHED) {
+				goto out;
+			}
+			else {
+				/* NOTE: we should have messages for unsuccessful
+				   reglogin */
+				DMABUF_t *mp;
+				mp = (DMABUF_t *)(mbox->context1);
+				lpfc_mbuf_free(phba, mp->virt, mp->phys);
+				kfree(mp);
+				lpfc_mbox_free(phba, mbox);
+			}
+		} else {
+			lpfc_mbox_free(phba, mbox);
+		}
+	}
+
+      out:
+	ndlp->nlp_flag &= ~NLP_ACC_REGLOGIN;
+
+	/* Check to see if link went down during discovery */
+	lpfc_els_chk_latt(phba, rspiocb);
+
+	lpfc_els_free_iocb(phba, cmdiocb);
+	return;
+}
+
+int
+lpfc_els_rsp_acc(lpfcHBA_t * phba,
+		 uint32_t flag,
+		 LPFC_IOCBQ_t * oldiocb,
+		 LPFC_NODELIST_t * ndlp, LPFC_MBOXQ_t * mbox, uint8_t newnode)
+{
+	IOCB_t *icmd;
+	IOCB_t *oldcmd;
+	LPFC_IOCBQ_t *elsiocb;
+	LPFC_SLI_RING_t *pring;
+	LPFC_SLI_t *psli;
+	uint8_t *pCmd;
+	uint16_t cmdsize;
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_ELS_RING];	/* ELS ring */
+	oldcmd = &oldiocb->iocb;
+
+	switch (flag) {
+	case ELS_CMD_ACC:
+		cmdsize = sizeof (uint32_t);
+		if ((elsiocb =
+		     lpfc_prep_els_iocb(phba, FALSE, cmdsize, oldiocb->retry,
+					ndlp, ELS_CMD_ACC)) == 0) {
+			return (1);
+		}
+		icmd = &elsiocb->iocb;
+		icmd->ulpContext = oldcmd->ulpContext;	/* Xri */
+		pCmd = (uint8_t *) (((DMABUF_t *) elsiocb->context2)->virt);
+		*((uint32_t *) (pCmd)) = ELS_CMD_ACC;
+		pCmd += sizeof (uint32_t);
+		break;
+	case ELS_CMD_PLOGI:
+		cmdsize = (sizeof (SERV_PARM) + sizeof (uint32_t));
+		if ((elsiocb =
+		     lpfc_prep_els_iocb(phba, FALSE, cmdsize, oldiocb->retry,
+					ndlp, ELS_CMD_ACC)) == 0) {
+			return (1);
+		}
+		icmd = &elsiocb->iocb;
+		icmd->ulpContext = oldcmd->ulpContext;	/* Xri */
+		pCmd = (uint8_t *) (((DMABUF_t *) elsiocb->context2)->virt);
+
+		if (mbox)
+			elsiocb->context_un.mbox = mbox;
+
+		*((uint32_t *) (pCmd)) = ELS_CMD_ACC;
+		pCmd += sizeof (uint32_t);
+		memcpy(pCmd, &phba->fc_sparam, sizeof (SERV_PARM));
+		break;
+	case ELS_CMD_PRLO:
+		cmdsize = (sizeof (uint32_t) + sizeof (PRLO));
+		if ((elsiocb =
+			lpfc_prep_els_iocb(phba, FALSE, cmdsize, oldiocb->retry,
+				ndlp, ELS_CMD_PRLO)) == 0) {
+				return(1);
+		}
+		icmd = &elsiocb->iocb;
+		icmd->ulpContext = oldcmd->ulpContext;
+		pCmd = (uint8_t *) (((DMABUF_t *) elsiocb->context2)->virt);
+		memcpy(pCmd, ((DMABUF_t *) oldiocb->context2)->virt, 
+			sizeof (uint32_t) + sizeof (PRLO));
+		*((uint32_t *) (pCmd)) = ELS_CMD_PRLO_ACC;
+		break;
+	default:
+		return (1);
+	}
+
+	if (newnode)
+		elsiocb->context1 = 0;
+
+	if (ndlp->nlp_flag & NLP_LOGO_ACC) {
+		elsiocb->iocb_cmpl = lpfc_cmpl_els_logo_acc;
+	} else {
+		elsiocb->iocb_cmpl = lpfc_cmpl_els_acc;
+	}
+
+	phba->fc_stat.elsXmitACC++;
+	if (lpfc_sli_issue_iocb(phba, pring, elsiocb, SLI_IOCB_USE_TXQ) ==
+	    IOCB_ERROR) {
+		lpfc_els_free_iocb(phba, elsiocb);
+		return (1);
+	}
+	return (0);
+}
+
+int
+lpfc_els_rsp_reject(lpfcHBA_t * phba, uint32_t rejectError,
+		    LPFC_IOCBQ_t * oldiocb, LPFC_NODELIST_t * ndlp)
+{
+	IOCB_t *icmd;
+	IOCB_t *oldcmd;
+	LPFC_IOCBQ_t *elsiocb;
+	LPFC_SLI_RING_t *pring;
+	LPFC_SLI_t *psli;
+	uint8_t *pCmd;
+	uint16_t cmdsize;
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_ELS_RING];	/* ELS ring */
+
+	cmdsize = 2 * sizeof (uint32_t);
+	if ((elsiocb = lpfc_prep_els_iocb(phba, FALSE, cmdsize, oldiocb->retry,
+					  ndlp, ELS_CMD_LS_RJT)) == 0) {
+		return (1);
+	}
+
+	icmd = &elsiocb->iocb;
+	oldcmd = &oldiocb->iocb;
+	icmd->ulpContext = oldcmd->ulpContext;	/* Xri */
+	pCmd = (uint8_t *) (((DMABUF_t *) elsiocb->context2)->virt);
+
+	*((uint32_t *) (pCmd)) = ELS_CMD_LS_RJT;
+	pCmd += sizeof (uint32_t);
+	*((uint32_t *) (pCmd)) = rejectError;
+
+	phba->fc_stat.elsXmitLSRJT++;
+	elsiocb->iocb_cmpl = lpfc_cmpl_els_acc;
+
+	if (lpfc_sli_issue_iocb(phba, pring, elsiocb, SLI_IOCB_USE_TXQ) ==
+	    IOCB_ERROR) {
+		lpfc_els_free_iocb(phba, elsiocb);
+		return (1);
+	}
+	return (0);
+}
+
+int
+lpfc_els_rsp_adisc_acc(lpfcHBA_t * phba,
+		       LPFC_IOCBQ_t * oldiocb, LPFC_NODELIST_t * ndlp)
+{
+	ADISC *ap;
+	IOCB_t *icmd;
+	IOCB_t *oldcmd;
+	LPFC_IOCBQ_t *elsiocb;
+	LPFC_SLI_RING_t *pring;
+	LPFC_SLI_t *psli;
+	uint8_t *pCmd;
+	uint16_t cmdsize;
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_ELS_RING];	/* ELS ring */
+
+	cmdsize = sizeof (uint32_t) + sizeof (ADISC);
+	if ((elsiocb = lpfc_prep_els_iocb(phba, FALSE, cmdsize, oldiocb->retry,
+					  ndlp, ELS_CMD_ACC)) == 0) {
+		return (1);
+	}
+
+	icmd = &elsiocb->iocb;
+	oldcmd = &oldiocb->iocb;
+	icmd->ulpContext = oldcmd->ulpContext;	/* Xri */
+	pCmd = (uint8_t *) (((DMABUF_t *) elsiocb->context2)->virt);
+
+	*((uint32_t *) (pCmd)) = ELS_CMD_ACC;
+	pCmd += sizeof (uint32_t);
+
+	ap = (ADISC *) (pCmd);
+	ap->hardAL_PA = phba->fc_pref_ALPA;
+	memcpy(&ap->portName, &phba->fc_portname, sizeof (NAME_TYPE));
+	memcpy(&ap->nodeName, &phba->fc_nodename, sizeof (NAME_TYPE));
+	ap->DID = be32_to_cpu(phba->fc_myDID);
+
+	phba->fc_stat.elsXmitACC++;
+	elsiocb->iocb_cmpl = lpfc_cmpl_els_acc;
+
+	if (lpfc_sli_issue_iocb(phba, pring, elsiocb, SLI_IOCB_USE_TXQ) ==
+	    IOCB_ERROR) {
+		lpfc_els_free_iocb(phba, elsiocb);
+		return (1);
+	}
+	return (0);
+}
+
+int
+lpfc_els_rsp_prli_acc(lpfcHBA_t * phba,
+		      LPFC_IOCBQ_t * oldiocb, LPFC_NODELIST_t * ndlp)
+{
+	PRLI *npr;
+	lpfc_vpd_t *vpd;
+	IOCB_t *icmd;
+	IOCB_t *oldcmd;
+	LPFC_IOCBQ_t *elsiocb;
+	LPFC_SLI_RING_t *pring;
+	LPFC_SLI_t *psli;
+	uint8_t *pCmd;
+	uint16_t cmdsize;
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_ELS_RING];	/* ELS ring */
+
+	cmdsize = sizeof (uint32_t) + sizeof (PRLI);
+	if ((elsiocb = lpfc_prep_els_iocb(phba, FALSE, cmdsize, oldiocb->retry,
+					  ndlp,
+					  (ELS_CMD_ACC |
+					   (ELS_CMD_PRLI & ~ELS_RSP_MASK)))) ==
+	    0) {
+		return (1);
+	}
+
+	icmd = &elsiocb->iocb;
+	oldcmd = &oldiocb->iocb;
+	icmd->ulpContext = oldcmd->ulpContext;	/* Xri */
+	pCmd = (uint8_t *) (((DMABUF_t *) elsiocb->context2)->virt);
+
+	*((uint32_t *) (pCmd)) = (ELS_CMD_ACC | (ELS_CMD_PRLI & ~ELS_RSP_MASK));
+	pCmd += sizeof (uint32_t);
+
+	/* For PRLI, remainder of payload is PRLI parameter page */
+	memset(pCmd, 0, sizeof (PRLI));
+
+	npr = (PRLI *) pCmd;
+	vpd = &phba->vpd;
+	/*
+	 * If our firmware version is 3.20 or later, 
+	 * set the following bits for FC-TAPE support.
+	 */
+	if (vpd->rev.feaLevelHigh >= 0x02) {
+		npr->ConfmComplAllowed = 1;
+		npr->Retry = 1;
+		npr->TaskRetryIdReq = 1;
+	}
+
+	npr->acceptRspCode = PRLI_REQ_EXECUTED;
+	npr->estabImagePair = 1;
+	npr->readXferRdyDis = 1;
+	npr->ConfmComplAllowed = 1;
+
+	npr->prliType = PRLI_FCP_TYPE;
+	npr->initiatorFunc = 1;
+
+	phba->fc_stat.elsXmitACC++;
+	elsiocb->iocb_cmpl = lpfc_cmpl_els_acc;
+
+	if (lpfc_sli_issue_iocb(phba, pring, elsiocb, SLI_IOCB_USE_TXQ) ==
+	    IOCB_ERROR) {
+		lpfc_els_free_iocb(phba, elsiocb);
+		return (1);
+	}
+	return (0);
+}
+
+int
+lpfc_els_rsp_rnid_acc(lpfcHBA_t * phba,
+		      uint8_t format,
+		      LPFC_IOCBQ_t * oldiocb, LPFC_NODELIST_t * ndlp)
+{
+	RNID *rn;
+	IOCB_t *icmd;
+	IOCB_t *oldcmd;
+	LPFC_IOCBQ_t *elsiocb;
+	LPFC_SLI_RING_t *pring;
+	LPFC_SLI_t *psli;
+	uint8_t *pCmd;
+	uint16_t cmdsize;
+	lpfcCfgParam_t *clp;
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_ELS_RING];
+	clp = &phba->config[0];
+
+	cmdsize =
+	    sizeof (uint32_t) + sizeof (uint32_t) + (2 * sizeof (NAME_TYPE));
+	if (format)
+		cmdsize += sizeof (RNID_TOP_DISC);
+
+	if ((elsiocb = lpfc_prep_els_iocb(phba, FALSE, cmdsize, oldiocb->retry,
+					  ndlp, ELS_CMD_ACC)) == 0) {
+		return (1);
+	}
+
+	icmd = &elsiocb->iocb;
+	oldcmd = &oldiocb->iocb;
+	icmd->ulpContext = oldcmd->ulpContext;	/* Xri */
+	pCmd = (uint8_t *) (((DMABUF_t *) elsiocb->context2)->virt);
+
+	*((uint32_t *) (pCmd)) = ELS_CMD_ACC;
+	pCmd += sizeof (uint32_t);
+
+	memset(pCmd, 0, sizeof (RNID));
+	rn = (RNID *) (pCmd);
+	rn->Format = format;
+	rn->CommonLen = (2 * sizeof (NAME_TYPE));
+	memcpy(&rn->portName, &phba->fc_portname, sizeof (NAME_TYPE));
+	memcpy(&rn->nodeName, &phba->fc_nodename, sizeof (NAME_TYPE));
+	switch (format) {
+	case 0:
+		rn->SpecificLen = 0;
+		break;
+	case RNID_TOPOLOGY_DISC:
+		rn->SpecificLen = sizeof (RNID_TOP_DISC);
+		memcpy(&rn->un.topologyDisc.portName,
+		       &phba->fc_portname, sizeof (NAME_TYPE));
+		rn->un.topologyDisc.unitType = RNID_HBA;
+		rn->un.topologyDisc.physPort = 0;
+		rn->un.topologyDisc.attachedNodes = 0;
+		break;
+	default:
+		rn->CommonLen = 0;
+		rn->SpecificLen = 0;
+		break;
+	}
+
+	phba->fc_stat.elsXmitACC++;
+	elsiocb->iocb_cmpl = lpfc_cmpl_els_acc;
+
+	if (lpfc_sli_issue_iocb(phba, pring, elsiocb, SLI_IOCB_USE_TXQ) ==
+	    IOCB_ERROR) {
+		lpfc_els_free_iocb(phba, elsiocb);
+		return (1);
+	}
+	return (0);
+}
+
+void
+lpfc_els_unsol_event(lpfcHBA_t * phba,
+		     LPFC_SLI_RING_t * pring, LPFC_IOCBQ_t * elsiocb)
+{
+	LPFC_SLI_t *psli;
+	LPFC_NODELIST_t *ndlp;
+	DMABUF_t *mp;
+	uint32_t *lp;
+	IOCB_t *icmd;
+	LS_RJT stat;
+	uint32_t cmd;
+	uint32_t did;
+	uint32_t newnode;
+	uint32_t drop_cmd = 0;	/* by default do NOT drop received cmd */
+
+	psli = &phba->sli;
+	icmd = &elsiocb->iocb;
+
+	/* type of ELS cmd is first 32bit word in packet */
+	mp = lpfc_sli_ringpostbuf_get(phba, pring, getPaddr(icmd->un.
+							    cont64[0].
+							    addrHigh,
+							    icmd->un.
+							    cont64[0].addrLow));
+	if (mp == 0) {
+		drop_cmd = 1;
+		goto dropit;
+	}
+
+	newnode = 0;
+	lp = (uint32_t *) mp->virt;
+	cmd = *lp++;
+	lpfc_post_buffer(phba, &psli->ring[LPFC_ELS_RING], 1, 1);
+
+	if (icmd->ulpStatus) {
+		lpfc_mbuf_free(phba, mp->virt, mp->phys);
+		kfree(mp);
+		drop_cmd = 1;
+		goto dropit;
+	}
+
+	/* Check to see if link went down during discovery */
+	if (lpfc_els_chk_latt(phba, elsiocb)) {
+		lpfc_mbuf_free(phba, mp->virt, mp->phys);
+		kfree(mp);
+		drop_cmd = 1;
+		goto dropit;
+	}
+
+	did = icmd->un.rcvels.remoteID;
+	if ((ndlp = lpfc_findnode_did(phba, NLP_SEARCH_ALL, did)) == 0) {
+		/* Cannot find existing Fabric ndlp, so allocate a new one */
+		if ((ndlp = lpfc_nlp_alloc(phba, 0)) == 0) {
+			lpfc_mbuf_free(phba, mp->virt, mp->phys);
+			kfree(mp);
+			drop_cmd = 1;
+			goto dropit;
+		}
+
+		newnode = 1;
+		memset(ndlp, 0, sizeof (LPFC_NODELIST_t));
+		ndlp->nlp_DID = did;
+		if ((did & Fabric_DID_MASK) == Fabric_DID_MASK) {
+			ndlp->nlp_type |= NLP_FABRIC;
+		}
+	}
+
+	phba->fc_stat.elsRcvFrame++;
+	elsiocb->context1 = ndlp;
+	elsiocb->context2 = mp;
+
+	if ((cmd & ELS_CMD_MASK) == ELS_CMD_RSCN) {
+		cmd &= ELS_CMD_MASK;
+	}
+	/* ELS command <elsCmd> received from NPORT <did> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0112,
+			lpfc_mes0112,
+			lpfc_msgBlk0112.msgPreambleStr,
+			cmd, did, phba->hba_state);
+
+	switch (cmd) {
+	case ELS_CMD_PLOGI:
+		phba->fc_stat.elsRcvPLOGI++;
+		lpfc_disc_state_machine(phba, ndlp, elsiocb, NLP_EVT_RCV_PLOGI);
+		break;
+	case ELS_CMD_FLOGI:
+		phba->fc_stat.elsRcvFLOGI++;
+		lpfc_els_rcv_flogi(phba, elsiocb, ndlp, newnode);
+		if (newnode) {
+			lpfc_nlp_free(phba, ndlp);
+		}
+		break;
+	case ELS_CMD_LOGO:
+		phba->fc_stat.elsRcvLOGO++;
+		if(ndlp->nlp_Target)
+			lpfc_set_npr_tmo(phba, ndlp->nlp_Target, ndlp);
+		lpfc_disc_state_machine(phba, ndlp, elsiocb, NLP_EVT_RCV_LOGO);
+		break;
+	case ELS_CMD_PRLO:
+		phba->fc_stat.elsRcvPRLO++;
+		if (ndlp->nlp_Target)
+			lpfc_set_npr_tmo(phba, ndlp->nlp_Target, ndlp);
+		lpfc_disc_state_machine(phba, ndlp, elsiocb, NLP_EVT_RCV_PRLO);
+		break;
+	case ELS_CMD_RSCN:
+		phba->fc_stat.elsRcvRSCN++;
+		lpfc_els_rcv_rscn(phba, elsiocb, ndlp, newnode);
+		if (newnode) {
+			lpfc_nlp_free(phba, ndlp);
+		}
+		break;
+	case ELS_CMD_ADISC:
+		phba->fc_stat.elsRcvADISC++;
+		lpfc_disc_state_machine(phba, ndlp, elsiocb, NLP_EVT_RCV_ADISC);
+		break;
+	case ELS_CMD_PDISC:
+		phba->fc_stat.elsRcvPDISC++;
+		lpfc_disc_state_machine(phba, ndlp, elsiocb, NLP_EVT_RCV_PDISC);
+		break;
+	case ELS_CMD_FARPR:
+		phba->fc_stat.elsRcvFARPR++;
+		lpfc_els_rcv_farpr(phba, elsiocb, ndlp);
+		break;
+	case ELS_CMD_FARP:
+		phba->fc_stat.elsRcvFARP++;
+		lpfc_els_rcv_farp(phba, elsiocb, ndlp);
+		break;
+	case ELS_CMD_FAN:
+		phba->fc_stat.elsRcvFAN++;
+		lpfc_els_rcv_fan(phba, elsiocb, ndlp);
+		break;
+	case ELS_CMD_RRQ:
+		phba->fc_stat.elsRcvRRQ++;
+		lpfc_els_rcv_rrq(phba, elsiocb, ndlp);
+		break;
+	case ELS_CMD_PRLI:
+		phba->fc_stat.elsRcvPRLI++;
+		lpfc_disc_state_machine(phba, ndlp, elsiocb, NLP_EVT_RCV_PRLI);
+		break;
+	case ELS_CMD_RNID:
+		phba->fc_stat.elsRcvRNID++;
+		lpfc_els_rcv_rnid(phba, elsiocb, ndlp);
+		break;
+	default:
+		/* Unsupported ELS command, reject */
+		stat.un.b.lsRjtRsvd0 = 0;
+		stat.un.b.lsRjtRsnCode = LSRJT_CMD_UNSUPPORTED;
+		stat.un.b.lsRjtRsnCodeExp = LSEXP_NOTHING_MORE;
+		stat.un.b.vendorUnique = 0;
+
+		lpfc_els_rsp_reject(phba, stat.un.lsRjtError, elsiocb, ndlp);
+
+		/* Unknown ELS command <elsCmd> received from NPORT <did> */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0115,
+				lpfc_mes0115,
+				lpfc_msgBlk0115.msgPreambleStr, cmd, did);
+		if (newnode) {
+			lpfc_nlp_free(phba, ndlp);
+		}
+		break;
+	}
+	if (elsiocb->context2) {
+		lpfc_mbuf_free(phba, mp->virt, mp->phys);
+		kfree(mp);
+	}
+
+      dropit:
+	/* check if need to drop received ELS cmd */
+	if (drop_cmd == 1) {
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0111,
+				lpfc_mes0111,
+				lpfc_msgBlk0111.msgPreambleStr,
+				icmd->ulpStatus, icmd->un.ulpWord[4]);
+		phba->fc_stat.elsRcvDrop++;
+	}
+
+	return;
+}
+
+void
+lpfc_more_adisc(lpfcHBA_t * phba)
+{
+	int sentadisc;
+	LPFC_NODELIST_t *ndlp;
+	struct list_head *pos;
+
+	if (phba->num_disc_nodes)
+		phba->num_disc_nodes--;
+
+	/* Continue discovery with <num_disc_nodes> ADISCs to go */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0210,
+			lpfc_mes0210,
+			lpfc_msgBlk0210.msgPreambleStr,
+			phba->num_disc_nodes, phba->fc_adisc_cnt, phba->fc_flag,
+			phba->hba_state);
+
+	/* Check to see if there are more ADISCs to be sent */
+	if (phba->fc_flag & FC_NLP_MORE) {
+		sentadisc = 0;
+		lpfc_set_disctmo(phba);
+
+		/* go thru ADISC list and issue any remaining ELS ADISCs */
+		list_for_each(pos, &phba->fc_adisc_list) {
+			ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			if (!(ndlp->nlp_flag & NLP_ADISC_SND)) {
+				/* If we haven't already sent an ADISC for this
+				 * node, send it.
+				 */
+				lpfc_issue_els_adisc(phba, ndlp, 0);
+				phba->num_disc_nodes++;
+				ndlp->nlp_flag |= NLP_DISC_NODE;
+				sentadisc = 1;
+				break;
+			}
+		}
+
+		if (sentadisc == 0) {
+			phba->fc_flag &= ~FC_NLP_MORE;
+		}
+	}
+	return;
+}
+
+void
+lpfc_more_plogi(lpfcHBA_t * phba)
+{
+	int sentplogi;
+	LPFC_NODELIST_t *ndlp;
+	struct list_head *pos;
+
+	if (phba->num_disc_nodes)
+		phba->num_disc_nodes--;
+
+	/* Continue discovery with <num_disc_nodes> PLOGIs to go */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0232,
+			lpfc_mes0232,
+			lpfc_msgBlk0232.msgPreambleStr,
+			phba->num_disc_nodes, phba->fc_plogi_cnt, phba->fc_flag,
+			phba->hba_state);
+
+	/* Check to see if there are more PLOGIs to be sent */
+	if (phba->fc_flag & FC_NLP_MORE) {
+		sentplogi = 0;
+
+		/* go thru PLOGI list and issue any remaining ELS PLOGIs */
+		list_for_each(pos, &phba->fc_plogi_list) {
+			ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			if ((!(ndlp->nlp_flag & NLP_PLOGI_SND)) &&
+			    (ndlp->nlp_state == NLP_STE_UNUSED_NODE)) {
+				/* If we haven't already sent an PLOGI for this
+				 * node, send it.
+				 */
+				ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+				lpfc_issue_els_plogi(phba, ndlp, 0);
+				phba->num_disc_nodes++;
+				ndlp->nlp_flag |= NLP_DISC_NODE;
+				sentplogi = 1;
+				break;
+			}
+		}
+		if (sentplogi == 0) {
+			phba->fc_flag &= ~FC_NLP_MORE;
+		}
+	}
+	return;
+}
+
+int
+lpfc_els_flush_rscn(lpfcHBA_t * phba)
+{
+	DMABUF_t *mp;
+	int i;
+
+	for (i = 0; i < phba->fc_rscn_id_cnt; i++) {
+		mp = phba->fc_rscn_id_list[i];
+		lpfc_mbuf_free(phba, mp->virt, mp->phys);
+		kfree(mp);
+		phba->fc_rscn_id_list[i] = 0;
+	}
+	phba->fc_rscn_id_cnt = 0;
+	phba->fc_flag &= ~(FC_RSCN_MODE | FC_RSCN_DISCOVERY);
+	lpfc_can_disctmo(phba);
+	return (0);
+}
+
+int
+lpfc_rscn_payload_check(lpfcHBA_t * phba, uint32_t did)
+{
+	D_ID ns_did;
+	D_ID rscn_did;
+	DMABUF_t *mp;
+	uint32_t *lp;
+	uint32_t payload_len, cmd, i, match;
+
+	ns_did.un.word = did;
+	match = 0;
+
+	/* If we are doing a FULL RSCN rediscovery, match everything */
+	if (phba->fc_flag & FC_RSCN_DISCOVERY) {
+		return (did);
+	}
+
+	for (i = 0; i < phba->fc_rscn_id_cnt; i++) {
+		mp = phba->fc_rscn_id_list[i];
+		lp = (uint32_t *) mp->virt;
+		cmd = *lp++;
+		payload_len = be32_to_cpu(cmd) & 0xffff; /* payload length */
+		payload_len -= sizeof (uint32_t);	/* take off word 0 */
+		while (payload_len) {
+			rscn_did.un.word = *lp++;
+			rscn_did.un.word = be32_to_cpu(rscn_did.un.word);
+			payload_len -= sizeof (uint32_t);
+			switch (rscn_did.un.b.resv) {
+			case 0:	/* Single N_Port ID effected */
+				if (ns_did.un.word == rscn_did.un.word) {
+					match = did;
+				}
+				break;
+			case 1:	/* Whole N_Port Area effected */
+				if ((ns_did.un.b.domain == rscn_did.un.b.domain)
+				    && (ns_did.un.b.area == rscn_did.un.b.area))
+					{
+						match = did;
+					}
+				break;
+			case 2:	/* Whole N_Port Domain effected */
+				if (ns_did.un.b.domain == rscn_did.un.b.domain)
+					{
+						match = did;
+					}
+				break;
+			case 3:	/* Whole Fabric effected */
+				match = did;
+				break;
+			default:
+				/* Unknown Identifier in RSCN list */
+				lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0217,
+						lpfc_mes0217,
+						lpfc_msgBlk0217.msgPreambleStr,
+						rscn_did.un.word);
+				break;
+			}
+			if (match) {
+				break;
+			}
+		}
+	}
+	return (match);
+}
+
+
+static int
+lpfc_rscn_recovery_check(lpfcHBA_t * phba)
+{
+	LPFC_NODELIST_t *ndlp = NULL, *new_ndlp;
+	struct list_head *pos, *next, *listp;
+	struct list_head *node_list[4];
+	LPFCSCSITARGET_t *targetp;
+	int i;
+
+	/* Make all effected nodes LPFC_DEV_DISCONNECTED */
+	node_list[0] = &phba->fc_plogi_list;
+	node_list[1] = &phba->fc_adisc_list;
+	node_list[2] = &phba->fc_nlpunmap_list;
+	node_list[3] = &phba->fc_nlpmap_list;
+	for (i = 0; i < 4; i++) {
+		listp = node_list[i];
+		if (list_empty(listp))
+			continue;
+
+		list_for_each_safe(pos, next, listp) {
+			new_ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			ndlp = new_ndlp;
+
+			if((lpfc_rscn_payload_check(phba, ndlp->nlp_DID))) {
+				lpfc_set_failmask(phba, ndlp,
+						  LPFC_DEV_DISCONNECTED,
+						  LPFC_SET_BITMASK);
+
+				targetp = ndlp->nlp_Target;
+				if(targetp)
+					lpfc_set_npr_tmo(phba, targetp, ndlp);
+			}
+		}
+	}
+	return (0);
+}
+
+int
+lpfc_els_rcv_rscn(lpfcHBA_t * phba,
+		  LPFC_IOCBQ_t * cmdiocb,
+		  LPFC_NODELIST_t * ndlp, uint8_t newnode)
+{
+	DMABUF_t *pCmd;
+	uint32_t *lp;
+	IOCB_t *icmd;
+	uint32_t payload_len, cmd;
+
+	icmd = &cmdiocb->iocb;
+	pCmd = (DMABUF_t *) cmdiocb->context2;
+	lp = (uint32_t *) pCmd->virt;
+
+	cmd = *lp++;
+	payload_len = be32_to_cpu(cmd) & 0xffff;	/* payload length */
+	payload_len -= sizeof (uint32_t);	/* take off word 0 */
+	cmd &= ELS_CMD_MASK;
+
+	/* RSCN received */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0214,
+			lpfc_mes0214,
+			lpfc_msgBlk0214.msgPreambleStr,
+			phba->fc_flag, payload_len, *lp, phba->fc_rscn_id_cnt);
+
+	/* if we are already processing an RSCN, save the received
+	 * RSCN payload buffer, cmdiocb->context2 to process later.
+	 * If we zero, cmdiocb->context2, the calling routine will
+	 * not try to free it.
+	 */
+	if (phba->fc_flag & FC_RSCN_MODE) {
+		if ((phba->fc_rscn_id_cnt < FC_MAX_HOLD_RSCN) &&
+		    !(phba->fc_flag & FC_RSCN_DISCOVERY)) {
+			phba->fc_rscn_id_list[phba->fc_rscn_id_cnt++] = pCmd;
+			cmdiocb->context2 = 0;
+			/* Deferred RSCN */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0235,
+					lpfc_mes0235,
+					lpfc_msgBlk0235.msgPreambleStr,
+					phba->fc_rscn_id_cnt, phba->fc_flag,
+					phba->hba_state);
+		} else {
+			phba->fc_flag |= FC_RSCN_DISCOVERY;
+			/* ReDiscovery RSCN */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0234,
+					lpfc_mes0234,
+					lpfc_msgBlk0234.msgPreambleStr,
+					phba->fc_rscn_id_cnt, phba->fc_flag,
+					phba->hba_state);
+		}
+		/* Send back ACC */
+		lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, 0, newnode);
+		lpfc_rscn_recovery_check(phba);
+		return (0);
+	}
+
+	phba->fc_flag |= FC_RSCN_MODE;
+	phba->fc_rscn_id_list[phba->fc_rscn_id_cnt++] = pCmd;
+	/*
+	 * If we zero, cmdiocb->context2, the calling routine will
+	 * not try to free it.
+	 */
+	cmdiocb->context2 = 0;
+
+	lpfc_set_disctmo(phba);
+
+	/* Send back ACC */
+	lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, 0, newnode);
+	lpfc_rscn_recovery_check(phba);
+
+	return (lpfc_els_handle_rscn(phba));
+}
+
+int
+lpfc_els_handle_rscn(lpfcHBA_t * phba)
+{
+	LPFC_NODELIST_t *ndlp;
+
+	lpfc_hba_put_event(phba, HBA_EVENT_RSCN, phba->fc_myDID,
+			  phba->fc_myDID, 0, 0);
+	lpfc_put_event(phba, FC_REG_RSCN_EVENT, phba->fc_myDID, 0, 0);
+
+	/* RSCN processed */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0215,
+			lpfc_mes0215,
+			lpfc_msgBlk0215.msgPreambleStr,
+			phba->fc_flag, 0, phba->fc_rscn_id_cnt,
+			phba->hba_state);
+
+	/* To process RSCN, first compare RSCN data with NameServer */
+	phba->fc_ns_retry = 0;
+	if ((ndlp = lpfc_findnode_did(phba, NLP_SEARCH_UNMAPPED,
+				      NameServer_DID))) {
+		/* Good ndlp, issue CT Request to NameServer */
+		if (lpfc_ns_cmd(phba, ndlp, SLI_CTNS_GID_FT) == 0) {
+			/* Wait for NameServer query cmpl before we can
+			   continue */
+			return (1);
+		}
+	} else {
+		/* If login to NameServer does not exist, issue one */
+		/* Good status, issue PLOGI to NameServer */
+		if ((ndlp =
+		     lpfc_findnode_did(phba, NLP_SEARCH_ALL, NameServer_DID))) {
+			/* Wait for NameServer login cmpl before we can
+			   continue */
+			return (1);
+		}
+		if ((ndlp = lpfc_nlp_alloc(phba, 0)) == 0) {
+			lpfc_els_flush_rscn(phba);
+			return (0);
+		} else {
+			memset(ndlp, 0, sizeof (LPFC_NODELIST_t));
+			ndlp->nlp_type |= NLP_FABRIC;
+			ndlp->nlp_DID = NameServer_DID;
+			ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+			lpfc_issue_els_plogi(phba, ndlp, 0);
+			/* Wait for NameServer login cmpl before we can
+			   continue */
+			return (1);
+		}
+	}
+
+	lpfc_els_flush_rscn(phba);
+	return (0);
+}
+
+int
+lpfc_els_rcv_flogi(lpfcHBA_t * phba,
+		   LPFC_IOCBQ_t * cmdiocb,
+		   LPFC_NODELIST_t * ndlp, uint8_t newnode)
+{
+	DMABUF_t *pCmd;
+	uint32_t *lp;
+	IOCB_t *icmd;
+	SERV_PARM *sp;
+	LPFC_MBOXQ_t *mbox;
+	LPFC_SLI_t *psli;
+	lpfcCfgParam_t *clp;
+	LS_RJT stat;
+	uint32_t cmd, did;
+
+	psli = &phba->sli;
+	clp = &phba->config[0];
+	icmd = &cmdiocb->iocb;
+	pCmd = (DMABUF_t *) cmdiocb->context2;
+	lp = (uint32_t *) pCmd->virt;
+
+	cmd = *lp++;
+	sp = (SERV_PARM *) lp;
+
+	/* FLOGI received */
+
+	lpfc_set_disctmo(phba);
+
+	if (phba->fc_topology == TOPOLOGY_LOOP) {
+		/* We should never receive a FLOGI in loop mode, ignore it */
+		did = icmd->un.elsreq64.remoteID;
+
+		/* An FLOGI ELS command <elsCmd> was received from DID <did> in
+		   Loop Mode */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0113,
+				lpfc_mes0113,
+				lpfc_msgBlk0113.msgPreambleStr, cmd, did);
+		return (1);
+	}
+
+	did = Fabric_DID;
+
+	if ((lpfc_check_sparm(phba, ndlp, sp, CLASS3))) {
+		/* For a FLOGI we accept, then if our portname is greater
+		 * then the remote portname we initiate Nport login. 
+		 */
+		int rc;
+
+		rc = lpfc_geportname((NAME_TYPE *) & phba->fc_portname,
+				     (NAME_TYPE *) & sp->portName);
+
+		if (rc == 2) {
+			if ((mbox = lpfc_mbox_alloc(phba, 0)) == 0) {
+				return (1);
+			}
+			lpfc_linkdown(phba);
+			lpfc_init_link(phba, mbox,
+				       clp[LPFC_CFG_TOPOLOGY].a_current,
+				       clp[LPFC_CFG_LINK_SPEED].a_current);
+			mbox->mb.un.varInitLnk.lipsr_AL_PA = 0;
+			if (lpfc_sli_issue_mbox
+			    (phba, mbox, (MBX_NOWAIT | MBX_STOP_IOCB))
+			    == MBX_NOT_FINISHED) {
+				lpfc_mbox_free(phba, mbox);
+			}
+			return (1);
+		}
+
+		if (rc == 1) {	/* greater than */
+			phba->fc_flag |= FC_PT2PT_PLOGI;
+		}
+		phba->fc_flag |= FC_PT2PT;
+		phba->fc_flag &= ~(FC_FABRIC | FC_PUBLIC_LOOP);
+	} else {
+		/* Reject this request because invalid parameters */
+		stat.un.b.lsRjtRsvd0 = 0;
+		stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
+		stat.un.b.lsRjtRsnCodeExp = LSEXP_SPARM_OPTIONS;
+		stat.un.b.vendorUnique = 0;
+		lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb, ndlp);
+		return (1);
+	}
+
+	/* Send back ACC */
+	lpfc_els_rsp_acc(phba, ELS_CMD_PLOGI, cmdiocb, ndlp, 0, newnode);
+
+	return (0);
+}
+
+int
+lpfc_els_rcv_rnid(lpfcHBA_t * phba,
+		  LPFC_IOCBQ_t * cmdiocb, LPFC_NODELIST_t * ndlp)
+{
+	DMABUF_t *pCmd;
+	uint32_t *lp;
+	IOCB_t *icmd;
+	RNID *rn;
+	LS_RJT stat;
+	uint32_t cmd, did;
+
+	icmd = &cmdiocb->iocb;
+	did = icmd->un.elsreq64.remoteID;
+	pCmd = (DMABUF_t *) cmdiocb->context2;
+	lp = (uint32_t *) pCmd->virt;
+
+	cmd = *lp++;
+	rn = (RNID *) lp;
+
+	/* RNID received */
+
+	switch (rn->Format) {
+	case 0:
+	case RNID_TOPOLOGY_DISC:
+		/* Send back ACC */
+		lpfc_els_rsp_rnid_acc(phba, rn->Format, cmdiocb, ndlp);
+		break;
+	default:
+		/* Reject this request because format not supported */
+		stat.un.b.lsRjtRsvd0 = 0;
+		stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
+		stat.un.b.lsRjtRsnCodeExp = LSEXP_CANT_GIVE_DATA;
+		stat.un.b.vendorUnique = 0;
+		lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb, ndlp);
+	}
+	return (0);
+}
+
+int
+lpfc_els_rcv_rrq(lpfcHBA_t * phba, LPFC_IOCBQ_t * cmdiocb,
+		 LPFC_NODELIST_t * ndlp)
+{
+	DMABUF_t *pCmd;
+	uint32_t *lp;
+	IOCB_t *icmd;
+	LPFC_SLI_RING_t *pring;
+	LPFC_SLI_t *psli;
+	RRQ *rrq;
+	uint32_t cmd, did;
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_FCP_RING];
+	icmd = &cmdiocb->iocb;
+	did = icmd->un.elsreq64.remoteID;
+	pCmd = (DMABUF_t *) cmdiocb->context2;
+	lp = (uint32_t *) pCmd->virt;
+
+	cmd = *lp++;
+	rrq = (RRQ *) lp;
+
+	/* RRQ received */
+	/* Get oxid / rxid from payload and abort it */
+	if ((rrq->SID == be32_to_cpu(phba->fc_myDID))) {
+		lpfc_sli_abort_iocb_ctx(phba, pring, rrq->Oxid);
+	} else {
+		lpfc_sli_abort_iocb_ctx(phba, pring, rrq->Rxid);
+	}
+	/* ACCEPT the rrq request */
+	lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, 0, 0);
+
+	return (0);
+}
+
+int
+lpfc_els_rcv_farp(lpfcHBA_t * phba,
+		  LPFC_IOCBQ_t * cmdiocb, LPFC_NODELIST_t * ndlp)
+{
+	DMABUF_t *pCmd;
+	uint32_t *lp;
+	IOCB_t *icmd;
+	FARP *fp;
+	uint32_t cmd, cnt, did;
+
+	icmd = &cmdiocb->iocb;
+	did = icmd->un.elsreq64.remoteID;
+	pCmd = (DMABUF_t *) cmdiocb->context2;
+	lp = (uint32_t *) pCmd->virt;
+
+	cmd = *lp++;
+	fp = (FARP *) lp;
+
+	/* FARP-REQ received from DID <did> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0601,
+			lpfc_mes0601, lpfc_msgBlk0601.msgPreambleStr, did);
+
+	/* We will only support match on WWPN or WWNN */
+	if (fp->Mflags & ~(FARP_MATCH_NODE | FARP_MATCH_PORT)) {
+		return (0);
+	}
+
+	cnt = 0;
+	/* If this FARP command is searching for my portname */
+	if (fp->Mflags & FARP_MATCH_PORT) {
+		if (lpfc_geportname(&fp->RportName, &phba->fc_portname) == 2)
+			cnt = 1;
+	}
+
+	/* If this FARP command is searching for my nodename */
+	if (fp->Mflags & FARP_MATCH_NODE) {
+		if (lpfc_geportname(&fp->RnodeName, &phba->fc_nodename) == 2)
+			cnt = 1;
+	}
+
+	if (cnt) {
+		if ((ndlp->nlp_failMask == 0) &&
+		    (!(ndlp->nlp_flag & NLP_ELS_SND_MASK))) {
+			/* Log back into the node before sending the FARP. */
+			if (fp->Rflags & FARP_REQUEST_PLOGI) {
+				lpfc_nlp_plogi(phba, ndlp);
+				ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+				lpfc_issue_els_plogi(phba, ndlp, 0);
+			}
+
+			/* Send a FARP response to that node */
+			if (fp->Rflags & FARP_REQUEST_FARPR) {
+				lpfc_issue_els_farpr(phba, did, 0);
+			}
+		}
+	}
+	return (0);
+}
+
+int
+lpfc_els_rcv_farpr(lpfcHBA_t * phba,
+		   LPFC_IOCBQ_t * cmdiocb, LPFC_NODELIST_t * ndlp)
+{
+	DMABUF_t *pCmd;
+	uint32_t *lp;
+	IOCB_t *icmd;
+	uint32_t cmd, did;
+
+	icmd = &cmdiocb->iocb;
+	did = icmd->un.elsreq64.remoteID;
+	pCmd = (DMABUF_t *) cmdiocb->context2;
+	lp = (uint32_t *) pCmd->virt;
+
+	cmd = *lp++;
+	/* FARP-RSP received from DID <did> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0600,
+			lpfc_mes0600, lpfc_msgBlk0600.msgPreambleStr, did);
+
+	/* ACCEPT the Farp resp request */
+	lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, 0, 0);
+
+	return (0);
+}
+
+int
+lpfc_els_rcv_fan(lpfcHBA_t * phba, LPFC_IOCBQ_t * cmdiocb,
+		 LPFC_NODELIST_t * ndlp)
+{
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0261,
+			lpfc_mes0261,
+			lpfc_msgBlk0261.msgPreambleStr);
+	return (0);
+}
+
+int
+lpfc_els_chk_latt(lpfcHBA_t * phba, LPFC_IOCBQ_t * rspiocb)
+{
+	LPFC_SLI_t *psli;
+	IOCB_t *irsp;
+	LPFC_MBOXQ_t *mbox;
+	uint32_t ha_copy;
+
+	psli = &phba->sli;
+
+	if ((phba->hba_state < LPFC_HBA_READY) &&
+		(phba->hba_state != LPFC_LINK_DOWN)) {
+		uint32_t tag, stat, wd4;
+
+		/* Read the HBA Host Attention Register */
+		ha_copy = readl(phba->HAregaddr);
+
+		if (ha_copy & HA_LATT) {	/* Link Attention interrupt */
+			if (rspiocb) {
+				irsp = &(rspiocb->iocb);
+				tag = irsp->ulpIoTag;
+				stat = irsp->ulpStatus;
+				wd4 = irsp->un.ulpWord[4];
+				irsp->ulpStatus = IOSTAT_LOCAL_REJECT;
+				irsp->un.ulpWord[4] = IOERR_SLI_ABORTED;
+			} else {
+				tag = 0;
+				stat = 0;
+				wd4 = 0;
+			}
+			/* Pending Link Event during Discovery */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0237,
+					lpfc_mes0237,
+					lpfc_msgBlk0237.msgPreambleStr,
+					phba->hba_state, tag, stat, wd4);
+
+			lpfc_linkdown(phba);
+
+			if (phba->hba_state != LPFC_CLEAR_LA) {
+				if ((mbox = lpfc_mbox_alloc(phba, MEM_PRI))) {
+					phba->hba_state = LPFC_CLEAR_LA;
+					lpfc_clear_la(phba, mbox);
+					mbox->mbox_cmpl =
+					    lpfc_mbx_cmpl_clear_la;
+					if (lpfc_sli_issue_mbox
+					    (phba, mbox,
+					     (MBX_NOWAIT | MBX_STOP_IOCB))
+					    == MBX_NOT_FINISHED) {
+						lpfc_mbox_free(phba, mbox);
+						phba->hba_state =
+						    LPFC_HBA_ERROR;
+					}
+				}
+			}
+			return (1);
+		}
+	}
+
+	return (0);
+}
+
+void
+lpfc_els_timeout_handler(unsigned long ptr)
+{
+	lpfcHBA_t *phba;
+	LPFC_SLI_t *psli;
+	LPFC_SLI_RING_t *pring;
+	LPFC_IOCBQ_t *next_iocb;
+	LPFC_IOCBQ_t *piocb;
+	IOCB_t *cmd = 0;
+	DMABUF_t *pCmd;
+	struct list_head *dlp;
+	uint32_t *elscmd;
+	uint32_t els_command;
+	uint32_t timeout;
+	uint32_t next_timeout;
+	uint32_t remote_ID;
+	unsigned long iflag;
+	struct clk_data *elsClkData;
+	struct list_head *curr, *next;
+
+	elsClkData = (struct clk_data *)ptr;
+	phba = elsClkData->phba;
+	LPFC_DRVR_LOCK(phba, iflag);
+       	if (elsClkData->flags & TM_CANCELED) {
+		list_del((struct list_head *)elsClkData);
+		kfree(elsClkData);	
+		goto out;
+	}
+
+	timeout = (uint32_t) (unsigned long)(elsClkData->clData1);
+	phba->els_tmofunc.function = 0;
+	list_del((struct list_head *)elsClkData);
+	kfree(elsClkData);
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_ELS_RING];
+	dlp = &pring->txcmplq;
+	next_timeout = phba->fc_ratov << 1;
+
+	list_for_each_safe(curr, next, &pring->txcmplq) {
+		next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+		piocb = next_iocb;
+		cmd = &piocb->iocb;
+
+		if (piocb->iocb_flag & LPFC_IO_LIBDFC) {
+			continue;
+		}
+		pCmd = (DMABUF_t *) piocb->context2;
+		elscmd = (uint32_t *) (pCmd->virt);
+		els_command = *elscmd;
+
+		if ((els_command == ELS_CMD_FARP)
+		    || (els_command == ELS_CMD_FARPR)) {
+			continue;
+		}
+
+		if (piocb->drvrTimeout > 0) {
+			if (piocb->drvrTimeout >= timeout) {
+				piocb->drvrTimeout -= timeout;
+			} else {
+				piocb->drvrTimeout = 0;
+			}
+			continue;
+		}
+
+		list_del(&piocb->list);
+		pring->txcmplq_cnt--;
+
+		if (cmd->ulpCommand == CMD_GEN_REQUEST64_CR) {
+			LPFC_NODELIST_t *ndlp;
+
+			ndlp = lpfc_findnode_rpi(phba, cmd->ulpContext);
+			remote_ID = ndlp->nlp_DID;
+		} else {
+			remote_ID = cmd->un.elsreq64.remoteID;
+		}
+
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0127, lpfc_mes0127,
+				lpfc_msgBlk0127.msgPreambleStr, els_command,
+				remote_ID, cmd->ulpCommand, cmd->ulpIoTag);
+
+		/*
+		 * The iocb has timed out; driver abort it.
+		 */
+		cmd->ulpStatus = IOSTAT_LOCAL_REJECT;
+		cmd->un.ulpWord[4] = IOERR_SLI_ABORTED;
+
+		if (piocb->iocb_cmpl) {
+			(piocb->iocb_cmpl) (phba, piocb, piocb);
+		} else {
+			lpfc_iocb_free(phba, piocb);
+		}
+	}
+
+	lpfc_start_timer(phba, next_timeout, &phba->els_tmofunc,
+			 lpfc_els_timeout_handler,
+			 (unsigned long)next_timeout, (unsigned long)0);
+out:
+	LPFC_DRVR_UNLOCK(phba, iflag);
+}
+
+void
+lpfc_els_flush_cmd(lpfcHBA_t * phba)
+{
+	LPFC_SLI_t *psli;
+	LPFC_SLI_RING_t *pring;
+	LPFC_IOCBQ_t *next_iocb;
+	LPFC_IOCBQ_t *piocb;
+	IOCB_t *cmd = 0;
+	DMABUF_t *pCmd;
+	uint32_t *elscmd;
+	uint32_t els_command;
+	uint32_t remote_ID;
+	struct list_head *curr, *next;
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_ELS_RING];
+
+	list_for_each_safe(curr, next, &pring->txq) {
+		next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+		piocb = next_iocb;
+		cmd = &piocb->iocb;
+
+		if (piocb->iocb_flag & LPFC_IO_LIBDFC) {
+			continue;
+		}
+
+		/* Do not flush out the QUE_RING and ABORT/CLOSE iocbs */
+		if ((cmd->ulpCommand == CMD_QUE_RING_BUF_CN) ||
+		    (cmd->ulpCommand == CMD_QUE_RING_BUF64_CN) ||
+		    (cmd->ulpCommand == CMD_CLOSE_XRI_CN) ||
+		    (cmd->ulpCommand == CMD_ABORT_XRI_CN)) {
+			continue;
+		}
+
+		pCmd = (DMABUF_t *) piocb->context2;
+		elscmd = (uint32_t *) (pCmd->virt);
+		els_command = *elscmd;
+
+		if (cmd->ulpCommand == CMD_GEN_REQUEST64_CR) {
+			LPFC_NODELIST_t *ndlp;
+
+			ndlp = lpfc_findnode_rpi(phba, cmd->ulpContext);
+			remote_ID = ndlp->nlp_DID;
+			if (phba->hba_state == LPFC_HBA_READY) {
+				continue;
+			}
+		} else {
+			remote_ID = cmd->un.elsreq64.remoteID;
+		}
+
+		list_del(&piocb->list);
+		pring->txq_cnt--;
+
+		cmd->ulpStatus = IOSTAT_LOCAL_REJECT;
+		cmd->un.ulpWord[4] = IOERR_SLI_ABORTED;
+
+		if (piocb->iocb_cmpl) {
+			(piocb->iocb_cmpl) (phba, piocb, piocb);
+		} else {
+			lpfc_iocb_free(phba, piocb);
+		}
+	}
+
+	list_for_each_safe(curr, next, &pring->txcmplq) {
+		next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+		piocb = next_iocb;
+		cmd = &piocb->iocb;
+
+		if (piocb->iocb_flag & LPFC_IO_LIBDFC) {
+			continue;
+		}
+		pCmd = (DMABUF_t *) piocb->context2;
+		elscmd = (uint32_t *) (pCmd->virt);
+		els_command = *elscmd;
+
+		if (cmd->ulpCommand == CMD_GEN_REQUEST64_CR) {
+			LPFC_NODELIST_t *ndlp;
+
+			ndlp = lpfc_findnode_rpi(phba, cmd->ulpContext);
+			remote_ID = ndlp->nlp_DID;
+			if (phba->hba_state == LPFC_HBA_READY) {
+				continue;
+			}
+		} else {
+			remote_ID = cmd->un.elsreq64.remoteID;
+		}
+
+		list_del(&piocb->list);
+		pring->txcmplq_cnt--;
+
+		cmd->ulpStatus = IOSTAT_LOCAL_REJECT;
+		cmd->un.ulpWord[4] = IOERR_SLI_ABORTED;
+
+		if (piocb->iocb_cmpl) {
+			(piocb->iocb_cmpl) (phba, piocb, piocb);
+		} else {
+			lpfc_iocb_free(phba, piocb);
+		}
+	}
+	return;
+}
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_fcp.c linux-8155/drivers/addon/lpfc/lpfc_fcp.c
--- linux-8152/drivers/addon/lpfc/lpfc_fcp.c
+++ linux-8155/drivers/addon/lpfc/lpfc_fcp.c
@@ -0,0 +1,2500 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_fcp.c 432 2005-10-28 22:40:25Z sf_support $
+ */
+
+
+/* This is to export entry points needed for IP interface */
+#ifndef EXPORT_SYMTAB
+#define EXPORT_SYMTAB
+#endif
+#include <linux/version.h>
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/blk.h>
+#include <linux/utsname.h>
+#include <linux/pci.h>
+#include <linux/timer.h>
+#include <linux/if_arp.h>
+#include <linux/spinlock.h>
+
+
+/* From drivers/scsi */
+#include <sd.h>
+#include <hosts.h>
+#include <scsi.h>
+#include <linux/ctype.h>
+
+#include "lpfc_hw.h"
+#include "lpfc_sli.h"
+#include "lpfc_mem.h"
+#include "lpfc_sched.h"
+#include "lpfc_disc.h"
+#include "lpfc.h"
+#include "lpfc_logmsg.h"
+#include "lpfc_fcp.h"
+#include "lpfc_scsi.h"
+#include "lpfc_version.h"
+
+#include <linux/rtnetlink.h>
+#include <asm/byteorder.h>
+#include <linux/module.h>
+
+/* Configuration parameters defined */
+#define LPFC_DEF_ICFG
+#include "lpfc_dfc.h"
+#include "lpfc_cfgparm.h"
+#include "lpfc_module_param.h"
+#include "lpfc.conf"
+#include "lpfc_compat.h"
+#include "lpfc_crtn.h"
+
+
+char *lpfc_drvr_name = LPFC_DRIVER_NAME;
+char *lpfc_release_version = LPFC_DRIVER_VERSION;
+
+MODULE_DESCRIPTION("Emulex LightPulse Fibre Channel driver - Open Source");
+MODULE_AUTHOR("Emulex Corporation - tech.support@emulex.com");
+
+#define FC_EXTEND_TRANS_A 1
+#define ScsiResult(host_code, scsi_code) (((host_code) << 16) | scsi_code)
+
+int lpfc_detect(Scsi_Host_Template *);
+int lpfc_detect_instance(int, struct pci_dev *, uint32_t, Scsi_Host_Template *);
+int lpfc_linux_attach(int, Scsi_Host_Template *, struct pci_dev *);
+int lpfc_get_bind_type(lpfcHBA_t *);
+
+int lpfc_release(struct Scsi_Host *host);
+int lpfc_linux_detach(int);
+
+void lpfc_select_queue_depth(struct Scsi_Host *, struct scsi_device *);
+
+const char *lpfc_info(struct Scsi_Host *);
+
+int lpfc_device_queue_depth(lpfcHBA_t *, struct scsi_device *);
+int lpfc_reset_bus_handler(struct scsi_cmnd *cmnd);
+
+int lpfc_memmap(lpfcHBA_t *);
+int lpfc_unmemmap(lpfcHBA_t *);
+int lpfc_pcimap(lpfcHBA_t *);
+
+int lpfc_config_setup(lpfcHBA_t *);
+int lpfc_bind_setup(lpfcHBA_t *);
+int lpfc_sli_setup(lpfcHBA_t *);
+int lpfc_bind_wwpn(lpfcHBA_t *, char **, u_int);
+int lpfc_bind_wwnn(lpfcHBA_t *, char **, u_int);
+int lpfc_bind_did(lpfcHBA_t *, char **, u_int);
+LPFCSCSILUN_t *lpfc_tran_find_lun(LPFC_SCSI_BUF_t *);
+
+extern int lpfc_biosparam(Disk *, kdev_t, int[]);
+
+/* Binding Definitions: Max string size  */
+#define FC_MAX_DID_STRING       6
+#define FC_MAX_WW_NN_PN_STRING 16
+
+
+#if VARYIO == 20
+#define VARYIO_ENTRY .can_do_varyio = 1,
+#elif VARYIO == 3
+#define VARYIO_ENTRY .vary_io =1,
+#else
+#define VARYIO_ENTRY
+#endif
+
+#if defined CONFIG_HIGHMEM
+#if USE_HIGHMEM_IO ==2		// i386 & Redhat 2.1
+#define HIGHMEM_ENTRY .can_dma_32 = 1,
+#define SINGLE_SG_OK .single_sg_ok = 1,
+#else
+#if USE_HIGHMEM_IO ==3		// Redhat 3.0, Suse
+#define HIGHMEM_ENTRY .highmem_io = 1,
+#define SINGLE_SG_OK
+#else				// any other
+#define HIGHMEM_ENTRY
+#define SINGLE_SG_OK
+#endif
+#endif
+#else				// no highmem config
+#define HIGHMEM_ENTRY
+#define SINGLE_SG_OK
+#endif
+
+static Scsi_Host_Template driver_template = {
+	.module = THIS_MODULE,
+	.name = LPFC_DRIVER_NAME,
+	.info = lpfc_info,
+	.queuecommand = lpfc_queuecommand,
+
+	.eh_abort_handler = lpfc_abort_handler,
+	.eh_device_reset_handler = lpfc_reset_lun_handler,
+	.eh_bus_reset_handler = lpfc_reset_bus_handler,
+
+	.detect = lpfc_detect,
+	.release = lpfc_release,
+	.use_new_eh_code = 1,
+	VARYIO_ENTRY
+	HIGHMEM_ENTRY
+	SINGLE_SG_OK
+
+	.bios_param = lpfc_biosparam,
+	.proc_info = lpfc_proc_info,
+	.proc_name = LPFC_DRIVER_NAME,
+
+	.can_queue = LPFC_DFT_HBA_Q_DEPTH,
+	.this_id = -1,
+
+	.sg_tablesize = SG_ALL,
+	.cmd_per_lun = 30,
+	.use_clustering = DISABLE_CLUSTERING,
+};
+
+
+
+int lpfc_nethdr = 1;
+
+uint16_t lpfc_num_nodes = 128;	/* default number of NPort structs to alloc */
+
+lpfcDRVR_t lpfcDRVR;
+
+extern char *lpfc_fcp_bind_WWPN[];
+extern char *lpfc_fcp_bind_WWNN[];
+extern char *lpfc_fcp_bind_DID[];
+
+
+static struct pci_device_id lpfc_id_table[] = {
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_VIPER,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_THOR,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_PEGASUS,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_CENTAUR,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_DRAGONFLY,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_SUPERFLY,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_RFLY,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_PFLY,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_NEPTUNE,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_NEPTUNE_SCSP,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_NEPTUNE_DCSP,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_HELIOS,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_HELIOS_SCSP,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_HELIOS_DCSP,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_BMID,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_BSMB,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_ZEPHYR,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_ZEPHYR_SCSP,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_ZEPHYR_DCSP,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_ZMID,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_ZSMB,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_TFLY,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_LP101,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_LP10000S,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_LP11000S,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{PCI_VENDOR_ID_EMULEX, PCI_DEVICE_ID_LPE11000S,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{ 0 }
+};
+MODULE_DEVICE_TABLE(pci, lpfc_id_table);
+
+int
+lpfc_detect(Scsi_Host_Template * tmpt)
+{
+	struct pci_dev *pdev = 0;
+	int instance = 0;
+	int i;
+
+#if VARYIO == 21
+#ifdef SCSI_HOST_VARYIO
+	SCSI_HOST_VARYIO(tmpt) = 1;
+#endif
+#endif
+	printk(LPFC_MODULE_DESC "\n");
+	printk(LPFC_COPYRIGHT "\n");
+
+	/* Release the io_request_lock lock and reenable interrupts allowing
+	 * the driver to sleep if necessary.
+	 */
+	spin_unlock_irq(&io_request_lock);
+
+	memset((char *)&lpfcDRVR, 0, sizeof (lpfcDRVR_t));
+	lpfcDRVR.loadtime = jiffies;
+
+	/* Initialize list head for hba/port list */
+	INIT_LIST_HEAD(&lpfcDRVR.hba_list_head);
+
+	/* Search for all Device IDs supported */
+	i = 0;
+	while (lpfc_id_table[i].vendor) {
+		instance = lpfc_detect_instance(instance, pdev, lpfc_id_table[i].device, tmpt );
+		i++;
+	}
+
+
+	/* reacquire io_request_lock as the midlayer was holding it when it
+	   called us */
+	spin_lock_irq(&io_request_lock);
+	return (instance);
+}
+
+int
+lpfc_detect_instance(int instance,
+		     struct pci_dev *pdev, uint type, Scsi_Host_Template * tmpt)
+{
+
+	/* PCI_SUBSYSTEM_IDS supported */
+	while ((pdev = pci_find_subsys(PCI_VENDOR_ID_EMULEX, type,
+				       PCI_ANY_ID, PCI_ANY_ID, pdev))) {
+		if (pci_enable_device(pdev)) {
+			continue;
+		}
+		if (pci_request_regions(pdev, LPFC_DRIVER_NAME)) {
+			printk("lpfc pci I/O region is already in use. \n");
+			printk("a driver for lpfc is already loaded on this "
+			       "system\n");
+			continue;
+		}
+
+		if (lpfc_linux_attach(instance, tmpt, pdev)) {
+			pci_release_regions(pdev);
+
+			/* Failed to attach to lpfc adapter: bus <bus>
+			   device <device> irq <irq> */
+			lpfc_printf_log(instance, &lpfc_msgBlk0443,
+					lpfc_mes0443,
+					lpfc_msgBlk0443.msgPreambleStr,
+					pdev->bus->number,
+					PCI_SLOT(pdev->devfn),
+					pdev->irq);
+
+			continue;
+		}
+		instance++;
+	}
+
+	return (instance);
+}
+
+
+int
+lpfc_release(struct Scsi_Host *host)
+{
+	lpfcHBA_t *phba;
+	int instance;
+	phba = (lpfcHBA_t *) host->hostdata[0];
+	instance = phba->brd_no;
+
+	/*
+	 * detach the board 
+	 */
+	lpfc_linux_detach(instance);
+
+	return (0);
+}
+
+
+int
+lpfc_linux_attach(int instance, Scsi_Host_Template * tmpt, struct pci_dev *pdev)
+{
+	struct Scsi_Host *host;
+	lpfcHBA_t *phba;
+	lpfcCfgParam_t *clp;
+	struct clk_data *clkData;
+	int rc, i;
+	unsigned long iflag;
+	uint32_t timeout;
+
+	/*
+	 * must have a valid pci_dev
+	 */
+	if (!pdev)
+		return (1);
+
+	/* 
+	 * Allocate space for adapter info structure
+	 */
+	if (!(phba = kmalloc(sizeof (lpfcHBA_t), GFP_ATOMIC))) {
+		return (1);
+	}
+
+	/* By default, the driver expects this attach to succeed. */
+	rc = 0;
+
+	memset(phba, 0, sizeof (lpfcHBA_t));
+	INIT_LIST_HEAD(&phba->timerList);
+
+	/* Initialize default values for configuration parameters */
+	if (!(phba->config = kmalloc(sizeof (lpfc_icfgparam), GFP_ATOMIC))) {
+		goto error_1;
+	}
+	memset(phba->config, 0, sizeof (lpfc_icfgparam));
+
+	memcpy(&phba->config[0], (uint8_t *) & lpfc_icfgparam[0],
+	       sizeof (lpfc_icfgparam));
+
+	clp = &phba->config[0];
+
+	/* Set everything to the defaults */
+	for (i = 0; i < LPFC_TOTAL_NUM_OF_CFG_PARAM; i++)
+		clp[i].a_current = clp[i].a_default;
+	
+	phba->brd_no = instance;
+
+	/* Add adapter structure to list */
+	list_add_tail(&phba->hba_list, &lpfcDRVR.hba_list_head);
+
+	/* Initialize all internally managed lists. */
+	INIT_LIST_HEAD(&phba->fc_nlpmap_list);
+	INIT_LIST_HEAD(&phba->fc_nlpunmap_list);
+	INIT_LIST_HEAD(&phba->fc_plogi_list);
+	INIT_LIST_HEAD(&phba->fc_adisc_list);
+	INIT_LIST_HEAD(&phba->fc_nlpbind_list);
+	INIT_LIST_HEAD(&phba->delay_list);
+	INIT_LIST_HEAD(&phba->free_buf_list);
+
+	/* Initialize plxhba - LINUX specific */
+	phba->pcidev = pdev;
+	init_waitqueue_head(&phba->linkevtwq);
+	init_waitqueue_head(&phba->rscnevtwq);
+	init_waitqueue_head(&phba->ctevtwq);
+
+	if ((rc = lpfc_pcimap(phba))) {
+		goto error_2;
+	}
+
+	if ((rc = lpfc_memmap(phba))) {
+		goto error_2;
+	}
+
+	lpfcDRVR.num_devs++;
+	lpfc_config_setup(phba);	/* Setup configuration parameters */
+
+	/*
+	 * If the t.o value is not set, set it to 30
+	 */
+	if (clp[LPFC_CFG_SCSI_REQ_TMO].a_current == 0) {
+		clp[LPFC_CFG_SCSI_REQ_TMO].a_current = 30;
+	}
+
+	if (clp[LPFC_CFG_DISC_THREADS].a_current) {
+		/*
+		 * Set to FC_NLP_REQ if automap is set to 0 since order of
+		 * discovery does not matter if everything is persistently
+		 * bound. 
+		 */
+		if (clp[LPFC_CFG_AUTOMAP].a_current == 0) {
+			clp[LPFC_CFG_DISC_THREADS].a_current =
+			    LPFC_MAX_DISC_THREADS;
+		}
+	}
+
+
+  	/* 
+	 * Register this board
+	 */
+
+	host = scsi_register(tmpt, sizeof (unsigned long));
+	if (host) {
+		phba->host = host;
+		host->can_queue = clp[LPFC_CFG_DFT_HBA_Q_DEPTH].a_current - 10;
+	}
+	else {
+		printk (KERN_WARNING
+			"%s%d: scsi_host_alloc failed during attach\n", 
+			lpfc_drvr_name, phba->brd_no);
+		goto error_3;
+	}
+
+	/*
+	 * Adjust the number of id's
+	 * Although max_id is an int, target id's are unsined chars
+	 * Do not exceed 255, otherwise the device scan will wrap around
+	 */
+	if (clp[LPFC_CFG_MAX_TARGET].a_current > LPFC_MAX_TARGET) {
+		clp[LPFC_CFG_MAX_TARGET].a_current = LPFC_DFT_MAX_TARGET;
+	}
+	host->max_id = clp[LPFC_CFG_MAX_TARGET].a_current;
+	host->unique_id = instance;
+
+	if (clp[LPFC_CFG_MAX_LUN].a_current > LPFC_MAX_LUN) {
+		clp[LPFC_CFG_MAX_LUN].a_current = LPFC_DFT_MAX_LUN;
+	}
+	host->max_lun = clp[LPFC_CFG_MAX_LUN].a_current;
+
+	/* Adapter ID - tell midlayer not to reserve an ID for us */
+	host->this_id = -1;
+
+
+
+	/* Initialize all per HBA locks */
+	lpfc_drvr_init_lock(phba);
+	spin_lock_init(&phba->hiprilock);
+
+	/* Set up the HBA specific LUN device lookup routine */
+	phba->lpfc_tran_find_lun = lpfc_tran_find_lun;
+
+	lpfc_sli_setup(phba);	/* Setup SLI Layer to run over lpfc HBAs */
+	lpfc_sli_queue_setup(phba);	/* Initialize the SLI Layer */
+
+	if (lpfc_mem_alloc(phba) == 0) {
+          	scsi_unregister(host);
+		goto error_3;
+	}
+
+	lpfc_bind_setup(phba);	/* Setup binding configuration parameters */
+
+	/* Initialize HBA structure */
+	phba->fc_edtov = FF_DEF_EDTOV;
+	phba->fc_ratov = FF_DEF_RATOV;
+	phba->fc_altov = FF_DEF_ALTOV;
+	phba->fc_arbtov = FF_DEF_ARBTOV;
+
+	/* Set the FARP and XRI timeout values now since they depend on
+	   fc_ratov. */
+	phba->fc_ipfarp_timeout = (3 * phba->fc_ratov);
+	phba->fc_ipxri_timeout = (3 * phba->fc_ratov);
+
+	tasklet_init(&phba->task_run, (void *)lpfc_tasklet,
+		(unsigned long) phba);
+	INIT_LIST_HEAD(&phba->task_disc);
+
+
+	/*
+	 * Setup the scsi timeout handler with a 
+	 * timeout value = greater of (2*RATOV, 5).
+	 */                     	
+
+	timeout = (phba->fc_ratov << 1) > 5 ? (phba->fc_ratov << 1) : 5;
+	lpfc_start_timer(phba, timeout, &phba->scsi_tmofunc, 
+		lpfc_scsi_timeout_handler, (unsigned long)timeout, 0);
+
+
+	LPFC_DRVR_LOCK(phba, iflag);
+
+	if ((rc = lpfc_sli_hba_setup(phba)) != 0) {	/* Initialize the HBA */
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		scsi_unregister(host);
+		goto error_5;
+	}
+
+	/* 
+	   This is to support HBAs returning max_xri less than configured
+	   HBA_Q_DEPTH 
+	*/
+	host->can_queue = clp[LPFC_CFG_DFT_HBA_Q_DEPTH].a_current - 10;
+
+	lpfc_sched_init_hba(phba, clp[LPFC_CFG_DFT_HBA_Q_DEPTH].a_current - 10);
+
+	LPFC_DRVR_UNLOCK(phba, iflag);
+
+
+
+	/*
+	 * Starting with 2.4.0 kernel, Linux can support commands longer
+	 * than 12 bytes. However, scsi_register() always sets it to 12.
+	 * For it to be useful to the midlayer, we have to set it here.
+	 */
+	host->max_cmd_len = 16;
+
+	/*
+	 * Queue depths per lun
+	 */
+	host->cmd_per_lun = 1;
+
+	host->select_queue_depths = lpfc_select_queue_depth;
+
+	/*
+	 * Save a pointer to device control in host and increment board
+	 */
+	host->hostdata[0] = (unsigned long)phba;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,4)
+	scsi_set_pci_device(host, pdev);
+#endif
+
+	goto out;
+
+ error_5:
+	LPFC_DRVR_LOCK(phba, iflag);
+	lpfc_sli_hba_down(phba);
+	LPFC_DRVR_UNLOCK(phba, iflag);
+
+
+ error_3:
+	/* Stop any timers that were started during this attach. */
+	LPFC_DRVR_LOCK(phba, iflag);
+	while (!list_empty(&phba->timerList)) {
+		clkData = (struct clk_data *)(phba->timerList.next);
+		if (clkData) {
+			lpfc_stop_timer(clkData);
+		}
+	}
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	lpfc_tasklet((unsigned long)phba);
+	tasklet_kill(&phba->task_run);
+	lpfc_mem_free(phba);
+	lpfc_unmemmap(phba);
+	lpfcDRVR.num_devs--;
+
+ error_2:
+	kfree(phba->config);
+
+ error_1:
+	/* Remove from list of active HBAs */
+	list_del_init(&phba->hba_list);
+
+	kfree(phba);
+
+	/* Any error in the attach routine will end up here.  Set the return
+ 	 * code to 1 and exit. 
+	 */
+	rc = 1;
+
+ out:	
+	return rc;
+}
+
+/*
+ * Retrieve instance (board no) matching phba
+ * If valid hba return 1
+ * If invalid hba return 0 
+ */
+int
+lpfc_check_valid_phba(lpfcHBA_t * phba)
+{
+	struct list_head * pos;
+	lpfcHBA_t        * tphba = NULL;
+	int    found = 0;
+
+	list_for_each(pos, &lpfcDRVR.hba_list_head) {
+		tphba = list_entry(pos, lpfcHBA_t, hba_list);
+		if (tphba == phba) {
+			found = 1;
+			break;
+		}
+	}
+	
+	return(found);
+}
+
+/*
+ * Retrieve instance (board no) matching phba
+ * If found return board number
+ * If not found return -1 
+ */
+int
+lpfc_get_inst_by_phba(lpfcHBA_t * phba)
+{
+	struct list_head * pos;
+	lpfcHBA_t        * tphba = NULL;
+	int    found = 0;
+
+	list_for_each(pos, &lpfcDRVR.hba_list_head) {
+		tphba = list_entry(pos, lpfcHBA_t, hba_list);
+		if (tphba == phba) {
+			found = 1;
+			break;
+		}
+	}
+	
+	if (!found) 
+		return(-1);
+	else
+		return(tphba->brd_no);
+	
+}
+
+/*
+ * Retrieve lpfcHBA * matching instance (board no)
+ * If found return lpfcHBA *
+ * If not found return NULL 
+ */
+lpfcHBA_t *
+lpfc_get_phba_by_inst(int inst)
+{
+	struct list_head * pos;
+	lpfcHBA_t * phba;
+	int    found = 0;
+
+	phba = NULL;
+	list_for_each(pos, &lpfcDRVR.hba_list_head) {
+		phba = list_entry(pos, lpfcHBA_t, hba_list);
+		if (phba->brd_no == inst) {
+			found = 1;
+			break;
+		}
+	}
+	
+	if (!found) 
+		return(NULL);
+	else
+		return(phba);
+	
+}
+
+int
+lpfc_linux_detach(int instance)
+{
+	lpfcHBA_t        * phba;
+	LPFC_SLI_t       * psli;
+	struct clk_data  * clkData;
+	unsigned long      iflag;
+	LPFC_SCSI_BUF_t  * lpfc_cmd;
+	struct lpfc_dmabuf *cur_buf;
+	struct list_head *curr, *next;
+	struct timer_list *ptimer;
+
+	if ((phba = lpfc_get_phba_by_inst(instance)) == NULL) {
+		return(0);
+	}
+
+	psli = &phba->sli;
+
+	scsi_unregister(phba->host);
+
+	LPFC_DRVR_LOCK(phba, iflag);
+	phba->no_timer = 1;
+	list_for_each_safe(curr, next, &phba->timerList) {
+		clkData = list_entry(curr, struct clk_data, listLink);
+		if (clkData) {
+			ptimer = clkData->timeObj;
+			if (timer_pending(ptimer)) {
+				lpfc_stop_timer(clkData);	
+			}
+		}
+	}
+
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	while (!list_empty(&phba->timerList)) {
+	}
+	LPFC_DRVR_LOCK(phba, iflag);
+
+	lpfc_sli_hba_down(phba);	/* Bring down the SLI Layer */
+	if (phba->intr_inited) {
+		/* Clear all interrupt enable conditions */
+		writel(0, phba->HCregaddr);
+		readl(phba->HCregaddr); /* flush */
+		/* Clear all pending interrupts */
+		writel(0xffffffff, phba->HAregaddr);
+		readl(phba->HAregaddr); /* flush */
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		free_irq(phba->pcidev->irq, phba);
+		LPFC_DRVR_LOCK(phba, iflag);
+		phba->intr_inited = 0;
+	}
+
+	if (phba->pcidev) {
+		pci_release_regions(phba->pcidev);
+		pci_disable_device(phba->pcidev);
+	}
+
+	/* Complete any scheduled delayed i/o completions */
+	while(!list_empty(&phba->delay_list)) {
+		lpfc_cmd = list_entry(phba->delay_list.next, LPFC_SCSI_BUF_t, listentry);
+		list_del(&lpfc_cmd->listentry);
+		lpfc_iodone(phba, lpfc_cmd);
+	}
+
+	while(!list_empty(&phba->free_buf_list)) {
+		cur_buf = list_entry(phba->free_buf_list.next, DMABUF_t, list);
+		list_del(&cur_buf->list);
+		lpfc_mbuf_free(phba, cur_buf->virt, cur_buf->phys);
+		kfree((void *)cur_buf);
+	}
+
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	lpfc_tasklet((unsigned long)phba);
+	tasklet_kill(&phba->task_run);
+	LPFC_DRVR_LOCK(phba, iflag);
+
+	lpfc_cleanup(phba, 0);
+	lpfc_scsi_free(phba);
+
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	lpfc_mem_free(phba);
+	lpfc_unmemmap(phba);
+	LPFC_DRVR_LOCK(phba, iflag);
+
+
+
+	if (phba->config)
+		kfree(phba->config);
+
+	LPFC_DRVR_UNLOCK(phba, iflag);
+
+	/* Remove from list of active HBAs */
+	list_del(&phba->hba_list);
+
+	kfree(phba);
+
+	lpfcDRVR.num_devs--;
+
+	return (0);
+}
+
+const char *
+lpfc_info(struct Scsi_Host *host)
+{
+	lpfcHBA_t    *phba = (lpfcHBA_t *) host->hostdata[0];
+	int len;
+	static char  lpfcinfobuf[320];
+	
+        memset(lpfcinfobuf,0,320);
+	if(phba && phba->pcidev){
+		strncpy(lpfcinfobuf, phba->ModelDesc, 320);
+		len = strlen(lpfcinfobuf);	
+		snprintf(lpfcinfobuf + len,
+			320-len,
+	       		" on PCI bus %02x device %02x irq %d",
+			phba->pcidev->bus->number,
+		 	phba->pcidev->devfn,
+			phba->pcidev->irq);
+	}
+	return lpfcinfobuf;
+}
+
+int
+lpfc_proc_info(char *buf,
+	       char **start, off_t offset, int length, int hostnum, int rw)
+{
+
+	lpfcHBA_t *phba = NULL;
+	struct pci_dev *pdev;
+	char fwrev[32];
+	lpfc_vpd_t *vp;
+	struct list_head *pos;
+	LPFC_NODELIST_t *ndlp;
+	int  i, j, incr;
+	char hdw[9];
+	int len = 0, found = 0;
+	
+	/* Sufficient bytes to hold a port or node name. */
+	uint8_t name[sizeof (NAME_TYPE)];
+
+	/* If rw = 0, then read info
+	 * If rw = 1, then write info (NYI)
+	 */
+	if (rw)
+		return -EINVAL;
+
+	
+	list_for_each(pos, &lpfcDRVR.hba_list_head) {
+		phba = list_entry(pos, lpfcHBA_t, hba_list);
+		if (phba->host->host_no == hostnum) {
+			found = 1;
+			break;
+		}
+	}
+	
+
+	if (!found) {
+		return sprintf(buf, "Cannot find adapter for requested host "
+			       "number.\n");
+	}
+
+	vp = &phba->vpd;
+	pdev = phba->pcidev;
+
+	len += snprintf(buf, PAGE_SIZE, LPFC_MODULE_DESC "\n");
+
+	len += snprintf(buf + len, PAGE_SIZE-len, "%s\n",
+			lpfc_info(phba->host));
+
+	len += snprintf(buf + len, PAGE_SIZE-len, "SerialNum: %s\n",
+			phba->SerialNumber);
+
+	lpfc_decode_firmware_rev(phba, fwrev, 1);
+	len += snprintf(buf + len, PAGE_SIZE-len, "Firmware Version: %s\n",
+			fwrev);
+
+	len += snprintf(buf + len, PAGE_SIZE-len, "Hdw: ");
+	/* Convert JEDEC ID to ascii for hardware version */
+	incr = vp->rev.biuRev;
+	for (i = 0; i < 8; i++) {
+		j = (incr & 0xf);
+		if (j <= 9)
+			hdw[7 - i] = (char)((uint8_t) 0x30 + (uint8_t) j);
+		else
+			hdw[7 - i] =
+			    (char)((uint8_t) 0x61 + (uint8_t) (j - 10));
+		incr = (incr >> 4);
+	}
+	hdw[8] = 0;
+	len += snprintf(buf + len, PAGE_SIZE-len, hdw);
+
+	len += snprintf(buf + len, PAGE_SIZE-len, "\nVendorId: 0x%x\n",
+		       ((((uint32_t) pdev->device) << 16) |
+			(uint32_t) (pdev->vendor)));
+
+	/* A Fibre Channel node or port name is 8 octets long and delimited by 
+	 * colons.
+	 */
+	len += snprintf(buf + len, PAGE_SIZE-len, "Portname: ");
+	memcpy (&name[0], &phba->fc_portname, sizeof (NAME_TYPE));
+	len += snprintf(buf + len, PAGE_SIZE-len,
+			"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",
+			name[0], name[1], name[2], name[3], name[4], name[5],
+			name[6], name[7]);
+
+	len += snprintf(buf + len, PAGE_SIZE-len, "   Nodename: ");
+	memcpy (&name[0], &phba->fc_nodename, sizeof (NAME_TYPE));
+	len += snprintf(buf + len, PAGE_SIZE-len,
+			"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",
+			name[0], name[1], name[2], name[3], name[4], name[5],
+			name[6], name[7]);
+
+	switch (phba->hba_state) {
+	case LPFC_INIT_START:
+	case LPFC_INIT_MBX_CMDS:
+	case LPFC_LINK_DOWN:
+		len += snprintf(buf + len, PAGE_SIZE-len, "\n\nLink Down\n");
+		break;
+	case LPFC_LINK_UP:
+	case LPFC_LOCAL_CFG_LINK:
+		len += snprintf(buf + len, PAGE_SIZE-len, "\n\nLink Up\n");
+		break;
+	case LPFC_FLOGI:
+	case LPFC_FABRIC_CFG_LINK:
+	case LPFC_NS_REG:
+	case LPFC_NS_QRY:
+	case LPFC_BUILD_DISC_LIST:
+	case LPFC_DISC_AUTH:
+	case LPFC_CLEAR_LA:
+		len += snprintf(buf + len, PAGE_SIZE-len,
+				"\n\nLink Up - Discovery\n");
+		break;
+	case LPFC_HBA_READY:
+		len += snprintf(buf + len, PAGE_SIZE-len,
+				"\n\nLink Up - Ready:\n");
+		len += snprintf(buf + len, PAGE_SIZE-len, "   PortID 0x%x\n",
+				phba->fc_myDID);
+		if (phba->fc_topology == TOPOLOGY_LOOP) {
+			if (phba->fc_flag & FC_PUBLIC_LOOP)
+				len += snprintf(buf + len, PAGE_SIZE-len,
+						"   Public Loop\n");
+			else
+				len += snprintf(buf + len, PAGE_SIZE-len,
+						"   Private Loop\n");
+		} else {
+			if (phba->fc_flag & FC_FABRIC)
+				len += snprintf(buf + len, PAGE_SIZE-len,
+						"   Fabric\n");
+			else
+				len += snprintf(buf + len, PAGE_SIZE-len,
+						"   Point-2-Point\n");
+		}
+
+		if (phba->fc_linkspeed == LA_4GHZ_LINK)
+			len += snprintf(buf + len, PAGE_SIZE-len,
+					"   Current speed 4G\n");
+		else
+		if (phba->fc_linkspeed == LA_2GHZ_LINK)
+			len += snprintf(buf + len, PAGE_SIZE-len,
+					"   Current speed 2G\n");
+		else
+		if (phba->fc_linkspeed == LA_1GHZ_LINK)
+			len += snprintf(buf + len, PAGE_SIZE-len,
+					"   Current speed 1G\n\n");
+		else
+			len += snprintf(buf + len, PAGE_SIZE-len,
+					"   Current speed unknown\n\n");
+
+		/* Loop through the list of mapped nodes and dump the known node
+		   information. */
+		list_for_each(pos, &phba->fc_nlpmap_list) {
+			ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			if (ndlp->nlp_state == NLP_STE_MAPPED_NODE){
+				len += snprintf(buf + len, PAGE_SIZE -len, 
+						"lpfc%dt%02x DID %06x WWPN ",
+						ndlp->nlp_Target->pHba->brd_no,
+						ndlp->nlp_sid, ndlp->nlp_DID);
+
+				/* A Fibre Channel node or port name is 8 octets
+				 * long and delimited by colons.
+				 */
+				memcpy (&name[0], &ndlp->nlp_portname,
+					sizeof (NAME_TYPE));
+				len += snprintf(buf + len, PAGE_SIZE-len,
+						"%02x:%02x:%02x:%02x:%02x:%02x:"
+						"%02x:%02x",
+						name[0], name[1], name[2],
+						name[3], name[4], name[5],
+						name[6], name[7]);
+
+				len += snprintf(buf + len, PAGE_SIZE-len,
+						" WWNN ");
+				memcpy (&name[0], &ndlp->nlp_nodename,
+					sizeof (NAME_TYPE));
+				len += snprintf(buf + len, PAGE_SIZE-len,
+						"%02x:%02x:%02x:%02x:%02x:%02x:"
+						"%02x:%02x\n",
+						name[0], name[1], name[2],
+						name[3], name[4], name[5],
+						name[6], name[7]);
+
+			}
+			if(PAGE_SIZE - len < 90)
+				break;
+		}
+
+		if(pos != &phba->fc_nlpmap_list) 
+			len += snprintf(buf+len, PAGE_SIZE-len, "...\n");
+
+	}
+	return (len);
+}
+
+int
+lpfc_reset_bus_handler(struct scsi_cmnd *cmnd)
+{
+	lpfcHBA_t *phba;
+	LPFC_SCSI_BUF_t *lpfc_cmd;
+	unsigned long iflag;
+	int rc, tgt, lun;
+
+	/* release io_request_lock */
+	spin_unlock_irq(&io_request_lock);
+
+	phba = (lpfcHBA_t *) cmnd->host->hostdata[0];
+	tgt = cmnd->target;
+	lun = cmnd->lun;
+	LPFC_DRVR_LOCK(phba, iflag);
+
+	rc = 0;
+	if ((lpfc_cmd = lpfc_get_scsi_buf(phba))) {
+		rc = lpfc_scsi_hba_reset(phba, lpfc_cmd);
+		lpfc_free_scsi_buf(lpfc_cmd);
+	}
+
+	/* SCSI layer issued Bus Reset */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0714,
+		        lpfc_mes0714,
+		        lpfc_msgBlk0714.msgPreambleStr,
+		        tgt, lun, rc);
+
+	LPFC_DRVR_UNLOCK(phba, iflag);
+
+	/* reacquire io_request_lock for midlayer */
+	spin_lock_irq(&io_request_lock);
+	
+	return rc == 1? SUCCESS: FAILED;
+
+}				/* lpfc_reset_bus_handler */
+
+
+void
+lpfc_select_queue_depth(struct Scsi_Host *host, struct scsi_device *scsi_devs)
+{
+	struct scsi_device *device;
+	lpfcHBA_t *phba;
+
+	phba = (lpfcHBA_t *) host->hostdata[0];
+	for (device = scsi_devs; device != 0; device = device->next) {
+		if (device->host == host)
+			lpfc_device_queue_depth(phba, device);
+	}
+}
+
+int
+lpfc_device_queue_depth(lpfcHBA_t * phba, struct scsi_device *device)
+{
+	lpfcCfgParam_t *clp;
+
+	clp = &phba->config[0];
+
+	if (device->tagged_supported) {
+		device->tagged_queue = 1;
+		device->current_tag = 0;
+		device->queue_depth = clp[LPFC_CFG_DFT_LUN_Q_DEPTH].a_current;
+	} else {
+		device->queue_depth = 16;
+	}
+	return (device->queue_depth);
+}
+
+
+
+int
+lpfc_memmap(lpfcHBA_t * phba)
+{
+	unsigned long bar0map_len, bar2map_len;
+
+	if (phba->pcidev == 0)
+		return (1);
+
+	/* Configure DMA attributes. */
+	if (pci_set_dma_mask(phba->pcidev, 0xffffffffffffffffULL)) {
+		if (pci_set_dma_mask(phba->pcidev, 0xffffffffULL)) {
+			return (1);
+		}
+	}
+
+	/* 
+	 * Get the physical address of Bar0 and Bar2 and the number of bytes
+	 * required by each mapping.
+	 */
+	phba->pci_bar0_map = pci_resource_start(phba->pcidev, 0);
+	bar0map_len        = pci_resource_len(phba->pcidev, 0);
+	
+	phba->pci_bar2_map = pci_resource_start(phba->pcidev, 2);
+	bar2map_len        = pci_resource_len(phba->pcidev, 2);
+
+	/* Map HBA SLIM and Control Registers to a kernel virtual address. */
+	phba->slim_memmap_p      = ioremap(phba->pci_bar0_map, bar0map_len);
+	phba->ctrl_regs_memmap_p = ioremap(phba->pci_bar2_map, bar2map_len);
+
+	/* Setup SLI2 interface */
+	if (phba->slim2p.virt == 0) {
+		/*
+		 * Allocate memory for SLI-2 structures
+		 */
+		phba->slim2p.virt = pci_alloc_consistent(phba->pcidev,
+							 sizeof (SLI2_SLIM_t),
+							 &(phba->slim2p.phys));
+		
+		if (phba->slim2p.virt == 0) {
+			/* Cleanup adapter SLIM and Control Register
+			   mappings. */
+			iounmap(phba->ctrl_regs_memmap_p);
+			iounmap(phba->slim_memmap_p);
+			return (1);
+		}
+
+		/* The SLIM2 size is stored in the next field */ 
+		phba->slim_size = sizeof (SLI2_SLIM_t);
+		memset((char *)phba->slim2p.virt, 0, sizeof (SLI2_SLIM_t));
+	}
+	return (0);
+}
+
+int
+lpfc_unmemmap(lpfcHBA_t * phba)
+{
+	struct pci_dev *pdev;
+
+	pdev = phba->pcidev;
+
+	/* unmap adapter SLIM and Control Registers */
+	iounmap(phba->ctrl_regs_memmap_p);
+	iounmap(phba->slim_memmap_p);
+	
+	/* Free resources associated with SLI2 interface */
+	if (phba->slim2p.virt) {
+
+		
+		pci_free_consistent(pdev, 
+				    phba->slim_size, 
+				    phba->slim2p.virt, 
+				    phba->slim2p.phys);
+
+	}
+	return (0);
+}
+
+int
+lpfc_pcimap(lpfcHBA_t * phba)
+{
+	struct pci_dev *pdev;
+	int ret_val;
+
+	/*
+	 * PCI for board
+	 */
+	pdev = phba->pcidev;
+	if (!pdev)
+		return (1);
+
+	/* The LPFC HBAs are bus-master capable.  Call the kernel and have this
+	 * functionality enabled.  Note that setting pci bus master also sets
+	 * the latency value as well.  Also turn on MWI so that the cache line
+	 * size is set to match the host pci bridge.
+	 */
+
+	pci_set_master (pdev);
+	ret_val = pci_set_mwi (pdev);
+	if (ret_val != 0) {
+		/* The mwi set operation failed.  This is not a fatal error
+		 * so don't return an error.
+		 */
+	}
+
+	return (0);
+}
+
+void
+lpfc_setup_slim_access(lpfcHBA_t * arg)
+{
+	lpfcHBA_t *phba;
+
+	phba = (lpfcHBA_t *) arg;
+	phba->MBslimaddr = phba->slim_memmap_p;
+	phba->HAregaddr = (uint32_t *) (phba->ctrl_regs_memmap_p) +
+		HA_REG_OFFSET;
+	phba->HCregaddr = (uint32_t *) (phba->ctrl_regs_memmap_p) +
+		HC_REG_OFFSET;
+	phba->CAregaddr = (uint32_t *) (phba->ctrl_regs_memmap_p) +
+		CA_REG_OFFSET;
+	phba->HSregaddr = (uint32_t *) (phba->ctrl_regs_memmap_p) +
+		HS_REG_OFFSET;
+	return;
+}
+
+
+uint32_t
+lpfc_intr_prep(lpfcHBA_t * phba)
+{
+	LPFC_SLI_t *psli;
+	uint32_t ha_copy;
+
+	/* Ignore all interrupts during initialization. */
+	if (phba->hba_state < LPFC_LINK_DOWN) {
+		return (0);
+	}
+
+	psli = &phba->sli;
+	/* Read host attention register to determine interrupt source */
+	ha_copy = readl(phba->HAregaddr);
+
+	/* Clear Attention Sources, except ERATT (to preserve status) & LATT
+	 *    (ha_copy & ~(HA_ERATT | HA_LATT));
+	 */
+	writel((ha_copy & ~(HA_LATT | HA_ERATT)), phba->HAregaddr);
+	readl(phba->HAregaddr);
+	return (ha_copy);
+}				/* lpfc_intr_prep */
+
+int
+lpfc_valid_lun(LPFCSCSITARGET_t * targetp, uint64_t lun)
+{
+	uint32_t rptLunLen;
+	uint32_t *datap32;
+	uint32_t lunvalue, i;
+
+	if (targetp->rptLunState != REPORT_LUN_COMPLETE) {
+		return 1;
+	}
+
+	if (targetp->RptLunData) {
+		datap32 = (uint32_t *) targetp->RptLunData->virt;
+		rptLunLen = be32_to_cpu(*datap32);
+
+		for (i = 0; i < rptLunLen; i += 8) {
+			datap32 += 2;
+			lunvalue = (((*datap32) >> FC_LUN_SHIFT) & 0xff);
+			if (lunvalue == (uint32_t) lun)
+				return 1;
+		}
+		return 0;
+	} else {
+		return 1;
+	}
+}
+
+void
+lpfc_nodev_unsol_event(lpfcHBA_t * phba,
+		      LPFC_SLI_RING_t * pring, LPFC_IOCBQ_t * piocbq)
+{
+	return;
+}
+
+int
+lpfc_sli_setup(lpfcHBA_t * phba)
+{
+	int i, totiocb;
+	LPFC_SLI_t *psli;
+	LPFC_RING_INIT_t *pring;
+	lpfcCfgParam_t *clp;
+
+	psli = &phba->sli;
+	psli->sliinit.num_rings = MAX_CONFIGURED_RINGS;
+	psli->fcp_ring = LPFC_FCP_RING;
+	psli->next_ring = LPFC_FCP_NEXT_RING;
+	psli->ip_ring = LPFC_IP_RING;
+
+	clp = &phba->config[0];
+
+	totiocb = 0;
+	for (i = 0; i < psli->sliinit.num_rings; i++) {
+		pring = &psli->sliinit.ringinit[i];
+		switch (i) {
+		case LPFC_FCP_RING:	/* ring 0 - FCP */
+			/* numCiocb and numRiocb are used in config_port */
+			pring->numCiocb = SLI2_IOCB_CMD_R0_ENTRIES;
+			pring->numRiocb = SLI2_IOCB_RSP_R0_ENTRIES;
+			pring->numCiocb += SLI2_IOCB_CMD_R1XTRA_ENTRIES;
+			pring->numRiocb += SLI2_IOCB_RSP_R1XTRA_ENTRIES;
+			pring->numCiocb += SLI2_IOCB_CMD_R3XTRA_ENTRIES;
+			pring->numRiocb += SLI2_IOCB_RSP_R3XTRA_ENTRIES;
+			pring->iotag_ctr = 0;
+			pring->iotag_max =
+			    (clp[LPFC_CFG_DFT_HBA_Q_DEPTH].a_current * 2);
+			pring->fast_iotag = pring->iotag_max;
+			pring->num_mask = 0;
+			break;
+		case LPFC_IP_RING:	/* ring 1 - IP */
+			/* numCiocb and numRiocb are used in config_port */
+			pring->numCiocb = SLI2_IOCB_CMD_R1_ENTRIES;
+			pring->numRiocb = SLI2_IOCB_RSP_R1_ENTRIES;
+			pring->num_mask = 0;
+			pring->iotag_ctr = 0;
+			pring->iotag_max = clp[LPFC_CFG_XMT_Q_SIZE].a_current;
+			pring->fast_iotag = 0;
+			break;
+		case LPFC_ELS_RING:	/* ring 2 - ELS / CT */
+			/* numCiocb and numRiocb are used in config_port */
+			pring->numCiocb = SLI2_IOCB_CMD_R2_ENTRIES;
+			pring->numRiocb = SLI2_IOCB_RSP_R2_ENTRIES;
+			pring->fast_iotag = 0;
+			pring->iotag_ctr = 0;
+			pring->iotag_max = 4096;
+			pring->num_mask = 4;
+			pring->prt[0].profile = 0;	/* Mask 0 */
+			pring->prt[0].rctl = FC_ELS_REQ;
+			pring->prt[0].type = FC_ELS_DATA;
+			pring->prt[0].lpfc_sli_rcv_unsol_event =
+			    lpfc_els_unsol_event;
+			pring->prt[1].profile = 0;	/* Mask 1 */
+			pring->prt[1].rctl = FC_ELS_RSP;
+			pring->prt[1].type = FC_ELS_DATA;
+			pring->prt[1].lpfc_sli_rcv_unsol_event =
+			    lpfc_els_unsol_event;
+			pring->prt[2].profile = 0;	/* Mask 2 */
+			/* NameServer Inquiry */
+			pring->prt[2].rctl = FC_UNSOL_CTL;
+			/* NameServer */
+			pring->prt[2].type = FC_COMMON_TRANSPORT_ULP;
+			pring->prt[2].lpfc_sli_rcv_unsol_event =
+			    lpfc_ct_unsol_event;
+			pring->prt[3].profile = 0;	/* Mask 3 */
+			/* NameServer response */
+			pring->prt[3].rctl = FC_SOL_CTL;
+			/* NameServer */
+			pring->prt[3].type = FC_COMMON_TRANSPORT_ULP;
+			pring->prt[3].lpfc_sli_rcv_unsol_event =
+			    lpfc_ct_unsol_event;
+			break;
+		}
+		totiocb += (pring->numCiocb + pring->numRiocb);
+	}
+	if (totiocb > MAX_SLI2_IOCB) {
+		/* Too many cmd / rsp ring entries in SLI2 SLIM */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0462,
+			        lpfc_mes0462,
+			        lpfc_msgBlk0462.msgPreambleStr,
+			        totiocb, MAX_SLI2_IOCB);
+	}
+
+	psli->sliinit.sli_flag = 0;
+
+	return (0);
+}
+
+irqreturn_t
+lpfc_intr_handler(int irq, void *dev_id, struct pt_regs * regs)
+{
+	lpfcHBA_t *phba;
+	unsigned long iflag;
+
+	/* Sanity check dev_id parameter */
+	phba = (lpfcHBA_t *) dev_id;
+	if (!phba) {
+		return IRQ_NONE;
+	}
+
+	/* More sanity checks on dev_id parameter.
+	 * We have seen our interrupt service routine being called
+	 * with the dev_id of another PCI card in the system.
+	 * Here we verify the dev_id is really ours!
+	 */
+	if(!lpfc_check_valid_phba(phba))
+		return IRQ_NONE;
+
+	LPFC_DRVR_LOCK(phba, iflag);
+
+	/* Call SLI Layer to process interrupt */
+	lpfc_sli_intr(phba);
+
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	return IRQ_HANDLED;
+} /* lpfc_intr_handler */
+
+int
+lpfc_bind_setup(lpfcHBA_t * phba)
+{
+	lpfcCfgParam_t *clp;
+	char **arrayp = 0;
+	u_int cnt = 0;
+
+	/* 
+	 * Check if there are any WWNN / scsid bindings
+	 */
+	clp = &phba->config[0];
+
+	lpfc_get_bind_type(phba);
+
+	switch (phba->fcp_mapping) {
+	case FCP_SEED_WWNN:
+		arrayp = lpfc_fcp_bind_WWNN;
+		cnt = 0;
+		while (arrayp[cnt] != 0)
+			cnt++;
+		if (cnt && (*arrayp != 0)) {
+			lpfc_bind_wwnn(phba, arrayp, cnt);
+		}
+		break;
+
+	case FCP_SEED_WWPN:
+		arrayp = lpfc_fcp_bind_WWPN;
+		cnt = 0;
+		while (arrayp[cnt] != 0)
+			cnt++;
+		if (cnt && (*arrayp != 0)) {
+			lpfc_bind_wwpn(phba, arrayp, cnt);
+		}
+		break;
+
+	case FCP_SEED_DID:
+		if (clp[LPFC_CFG_BINDMETHOD].a_current != 4) {
+			arrayp = lpfc_fcp_bind_DID;
+			cnt = 0;
+			while (arrayp[cnt] != 0)
+				cnt++;
+			if (cnt && (*arrayp != 0)) {
+				lpfc_bind_did(phba, arrayp, cnt);
+			}
+		}
+		break;
+	}
+
+	if (cnt && (*arrayp != 0) &&
+	    (clp[LPFC_CFG_BINDMETHOD].a_current == 4)) {
+		/* Using ALPA map with Persistent binding - ignoring ALPA map */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0411,
+			        lpfc_mes0411, lpfc_msgBlk0411.msgPreambleStr,
+			        clp[LPFC_CFG_BINDMETHOD].a_current,
+				phba->fcp_mapping);
+	}
+
+	if (clp[LPFC_CFG_SCAN_DOWN].a_current > 1) {
+		/* Scan-down is out of range - ignoring scan-down */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0412,
+			        lpfc_mes0412, lpfc_msgBlk0412.msgPreambleStr,
+			        clp[LPFC_CFG_BINDMETHOD].a_current,
+				phba->fcp_mapping);
+		clp[LPFC_CFG_SCAN_DOWN].a_current = 0;
+	}
+	return (0);
+}
+
+/******************************************************************************
+* Function name : lpfc_config_setup
+*
+* Description   : Called from attach to setup configuration parameters for 
+*                 adapter 
+*                 The goal of this routine is to fill in all the a_current 
+*                 members of the CfgParam structure for all configuration 
+*                 parameters.
+* Example:
+* clp[LPFC_CFG_XXX].a_current = (uint32_t)value;
+* value might be a define, a global variable, clp[LPFC_CFG_XXX].a_default,
+* or some other enviroment specific way of initializing config parameters.
+******************************************************************************/
+
+int
+lpfc_config_setup(lpfcHBA_t * phba)
+{
+	lpfcCfgParam_t *clp;
+	LPFC_SLI_t *psli;
+	int i;
+	int brd;
+
+	clp = &phba->config[0];
+	psli = &phba->sli;
+	brd = phba->brd_no;
+
+	/*
+	 * Read the configuration parameters. Also set to default if
+	 * parameter value is out of allowed range.
+	 */
+	for (i = 0; i < LPFC_TOTAL_NUM_OF_CFG_PARAM; i++) {
+		clp[i].a_current = fc_get_cfg_param(brd, i);
+
+		if (i == LPFC_CFG_DFT_HBA_Q_DEPTH)
+			continue;
+
+		if ((clp[i].a_current >= clp[i].a_low) &&
+		    (clp[i].a_current <= clp[i].a_hi)) {
+			/* we continue if the range check is satisfied
+			 * however LPFC_CFG_TOPOLOGY has holes and
+			 * LPFC_CFG_FCP_CLASS needs to readjusted iff
+			 * it satisfies the range check
+			 */
+			if (i == LPFC_CFG_TOPOLOGY) {
+				/* odd values 1,3,5 are out */
+				if (!(clp[i].a_current & 1))
+					continue;
+			} else if (i == LPFC_CFG_FCP_CLASS) {
+				switch (clp[i].a_current) {
+				case 2:
+					/* CLASS2 = 1 */
+					clp[i].a_current = CLASS2;
+					break;
+				case 3:
+					/* CLASS3 = 2 */
+					clp[i].a_current = CLASS3;
+					break;
+				}
+				continue;
+			} else
+				continue;
+		}
+
+		/* The cr_count feature is disabled if cr_delay is set to 0.  So
+		   do not bother user with messages about cr_count if cr_delay
+		   is 0 */
+		if (i == LPFC_CFG_CR_COUNT)
+			if (clp[LPFC_CFG_CR_DELAY].a_current == 0)
+				continue;
+
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0413,
+				lpfc_mes0413,
+				lpfc_msgBlk0413.msgPreambleStr,
+				clp[i].a_string, clp[i].a_low, clp[i].a_hi,
+				clp[i].a_default);
+
+		clp[i].a_current = clp[i].a_default;
+
+	}
+
+	switch (phba->pcidev->device) {
+	case PCI_DEVICE_ID_LP101:
+	case PCI_DEVICE_ID_BSMB:
+	case PCI_DEVICE_ID_ZSMB:
+		clp[LPFC_CFG_DFT_HBA_Q_DEPTH].a_current =
+			LPFC_LP101_HBA_Q_DEPTH;
+		break;
+	case PCI_DEVICE_ID_RFLY:
+	case PCI_DEVICE_ID_PFLY:
+	case PCI_DEVICE_ID_BMID:
+	case PCI_DEVICE_ID_ZMID:
+	case PCI_DEVICE_ID_TFLY:
+		clp[LPFC_CFG_DFT_HBA_Q_DEPTH].a_current = LPFC_LC_HBA_Q_DEPTH;
+		break;
+	default:
+		clp[LPFC_CFG_DFT_HBA_Q_DEPTH].a_current = LPFC_DFT_HBA_Q_DEPTH;
+	}
+
+	if (clp[LPFC_CFG_DFT_HBA_Q_DEPTH].a_current > LPFC_MAX_HBA_Q_DEPTH) {
+		clp[LPFC_CFG_DFT_HBA_Q_DEPTH].a_current = LPFC_MAX_HBA_Q_DEPTH;
+	}
+
+	phba->sli.ring[LPFC_IP_RING].txq_max =
+	    clp[LPFC_CFG_XMT_Q_SIZE].a_current;
+
+
+	return (0);
+}
+
+int
+lpfc_bind_wwpn(lpfcHBA_t * phba, char **arrayp, u_int cnt)
+{
+	uint8_t *datap, *np;
+	LPFC_BINDLIST_t *blp;
+	NAME_TYPE pn;
+	int i, entry, lpfc_num, rstatus;
+	unsigned int sum;
+
+	phba->fcp_mapping = FCP_SEED_WWPN;
+	np = (uint8_t *) & pn;
+
+	for (entry = 0; entry < cnt; entry++) {
+		datap = (uint8_t *) arrayp[entry];
+		if (datap == 0)
+			break;
+		/* Determined the number of ASC hex chars in WWNN & WWPN */
+		for (i = 0; i < FC_MAX_WW_NN_PN_STRING; i++) {
+			if (!isxdigit(datap[i]))
+				break;
+		}
+		if ((rstatus = lpfc_parse_binding_entry(phba, datap, np,
+							i, sizeof (NAME_TYPE),
+							LPFC_BIND_WW_NN_PN,
+							&sum, entry,
+							&lpfc_num)) > 0) {
+			if (rstatus == LPFC_SYNTAX_OK_BUT_NOT_THIS_BRD)
+				continue;
+
+			/* For syntax error code definitions see
+			   LPFC_SYNTAX_ERR_ defines. */
+			/* WWPN binding entry <num>: Syntax error code <code> */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0430,
+					lpfc_mes0430,
+					lpfc_msgBlk0430.msgPreambleStr,
+					entry, rstatus);
+			goto out;
+		}
+
+		/* Loop through all BINDLIST entries and find
+		 * the next available entry.
+		 */
+		if ((blp = lpfc_bind_alloc(phba, 0)) == 0) {
+			/* WWPN binding entry: node table full */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0432,
+					lpfc_mes0432,
+					lpfc_msgBlk0432.msgPreambleStr);
+			goto out;
+		}
+		memset(blp, 0, sizeof (LPFC_BINDLIST_t));
+		blp->nlp_bind_type = FCP_SEED_WWPN;
+		blp->nlp_sid = (sum & 0xff);
+		memcpy(&blp->nlp_portname, (uint8_t *) & pn,
+		       sizeof (NAME_TYPE));
+
+		lpfc_nlp_bind(phba, blp);
+
+	      out:
+		np = (uint8_t *) & pn;
+	}
+	return (0);
+}				/* lpfc_bind_wwpn */
+
+int
+lpfc_get_bind_type(lpfcHBA_t * phba)
+{
+	int bind_type;
+	lpfcCfgParam_t *clp;
+
+	clp = &phba->config[0];
+
+	bind_type = clp[LPFC_CFG_BINDMETHOD].a_current;
+
+	switch (bind_type) {
+	case 1:
+		phba->fcp_mapping = FCP_SEED_WWNN;
+		break;
+
+	case 2:
+		phba->fcp_mapping = FCP_SEED_WWPN;
+		break;
+
+	case 3:
+		phba->fcp_mapping = FCP_SEED_DID;
+		break;
+
+	case 4:
+		phba->fcp_mapping = FCP_SEED_DID;
+		break;
+	}
+
+	return 0;
+}
+
+int
+lpfc_bind_wwnn(lpfcHBA_t * phba, char **arrayp, u_int cnt)
+{
+	uint8_t *datap, *np;
+	LPFC_BINDLIST_t *blp;
+	NAME_TYPE pn;
+	int i, entry, lpfc_num, rstatus;
+	unsigned int sum;
+
+	phba->fcp_mapping = FCP_SEED_WWNN;
+	np = (uint8_t *) & pn;
+
+	for (entry = 0; entry < cnt; entry++) {
+		datap = (uint8_t *) arrayp[entry];
+		if (datap == 0)
+			break;
+		/* Determined the number of ASC hex chars in WWNN & WWPN */
+		for (i = 0; i < FC_MAX_WW_NN_PN_STRING; i++) {
+			if (!isxdigit(datap[i]))
+				break;
+		}
+		if ((rstatus = lpfc_parse_binding_entry(phba, datap, np,
+							i, sizeof (NAME_TYPE),
+							LPFC_BIND_WW_NN_PN,
+							&sum, entry,
+							&lpfc_num)) > 0) {
+			if (rstatus == LPFC_SYNTAX_OK_BUT_NOT_THIS_BRD) {
+				continue;
+			}
+
+			/* For syntax error code definitions see
+			   LPFC_SYNTAX_ERR_ defines. */
+			/* WWNN binding entry <num>: Syntax error code <code> */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0431,
+					lpfc_mes0431,
+					lpfc_msgBlk0431.msgPreambleStr,
+					entry, rstatus);
+			goto out;
+		}
+
+		/* Loop through all BINDLIST entries and find
+		 * the next available entry.
+		 */
+		if ((blp = lpfc_bind_alloc(phba, 0)) == 0) {
+			/* WWNN binding entry: node table full */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0433,
+					lpfc_mes0433,
+					lpfc_msgBlk0433.msgPreambleStr);
+			goto out;
+		}
+		memset(blp, 0, sizeof (LPFC_BINDLIST_t));
+		blp->nlp_bind_type = FCP_SEED_WWNN;
+		blp->nlp_sid = (sum & 0xff);
+		memcpy(&blp->nlp_nodename, (uint8_t *) & pn,
+		       sizeof (NAME_TYPE));
+		lpfc_nlp_bind(phba, blp);
+
+	      out:
+		np = (uint8_t *) & pn;
+	}			/* for loop */
+	return (0);
+}				/* lpfc_bind_wwnn */
+
+int
+lpfc_bind_did(lpfcHBA_t * phba, char **arrayp, u_int cnt)
+{
+	uint8_t *datap, *np;
+	LPFC_BINDLIST_t *blp;
+	D_ID ndid;
+	int i, entry, lpfc_num, rstatus;
+	unsigned int sum;
+
+	phba->fcp_mapping = FCP_SEED_DID;
+	ndid.un.word = 0;
+	np = (uint8_t *) & ndid.un.word;
+
+	for (entry = 0; entry < cnt; entry++) {
+		datap = (uint8_t *) arrayp[entry];
+		if (datap == 0)
+			break;
+		/* Determined the number of ASC hex chars in DID */
+		for (i = 0; i < FC_MAX_DID_STRING; i++) {
+			if (!isxdigit(datap[i]))
+				break;
+		}
+		if ((rstatus = lpfc_parse_binding_entry(phba, datap, np,
+							i, sizeof (D_ID),
+							LPFC_BIND_DID, &sum,
+							entry,
+							&lpfc_num)) > 0) {
+			if (rstatus == LPFC_SYNTAX_OK_BUT_NOT_THIS_BRD)
+				continue;
+
+			/* For syntax error code definitions see
+			   LPFC_SYNTAX_ERR_ defines. */
+			/* DID binding entry <num>: Syntax error code <code> */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0434,
+				        lpfc_mes0434,
+				        lpfc_msgBlk0434.msgPreambleStr,
+				        entry, rstatus);
+			goto out;
+		}
+
+		/* Loop through all BINDLIST entries and find
+		 * the next available entry.
+		 */
+		if ((blp = lpfc_bind_alloc(phba, 0)) == 0) {
+			/* DID binding entry: node table full */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0435,
+				        lpfc_mes0435,
+				        lpfc_msgBlk0435.msgPreambleStr);
+			goto out;
+		}
+		memset(blp, 0, sizeof (LPFC_BINDLIST_t));
+		blp->nlp_bind_type = FCP_SEED_DID;
+		blp->nlp_sid = (sum & 0xff);
+		blp->nlp_DID = be32_to_cpu(ndid.un.word);
+
+		lpfc_nlp_bind(phba, blp);
+
+	      out:
+
+		np = (uint8_t *) & ndid.un.word;
+	}
+	return (0);
+}
+
+void
+lpfc_wakeup_event(lpfcHBA_t * phba, fcEVTHDR_t * ep)
+{
+	ep->e_mode &= ~E_SLEEPING_MODE;
+	switch (ep->e_mask) {
+	case FC_REG_LINK_EVENT:
+		wake_up_interruptible(&phba->linkevtwq);
+		break;
+	case FC_REG_RSCN_EVENT:
+		wake_up_interruptible(&phba->rscnevtwq);
+		break;
+	case FC_REG_CT_EVENT:
+		wake_up_interruptible(&phba->ctevtwq);
+		break;
+	}
+	return;
+}
+
+int
+lpfc_put_event(lpfcHBA_t * phba,
+	      uint32_t evcode, uint32_t evdata0, void *evdata1, void *evdata2)
+{
+	fcEVT_t *ep;
+	fcEVT_t *oep;
+	fcEVTHDR_t *ehp = 0;
+	int found;
+	DMABUF_t *mp;
+	void *fstype;
+	SLI_CT_REQUEST *ctp;
+
+	ehp = (fcEVTHDR_t *) phba->fc_evt_head;
+	fstype = 0;
+	switch (evcode) {
+	case FC_REG_CT_EVENT:
+		mp = (DMABUF_t *) evdata1;
+		ctp = (SLI_CT_REQUEST *) mp->virt;
+		fstype = (void *)(ulong) (ctp->FsType);
+		break;
+	}
+
+	while (ehp) {
+		if ((ehp->e_mask == evcode) && (ehp->e_type == fstype))
+			break;
+		
+		ehp = (fcEVTHDR_t *) ehp->e_next_header;
+	}
+
+	if (!ehp) {
+		return (0);
+	}
+
+	ep = ehp->e_head;
+	oep = 0;
+	found = 0;
+
+	while (ep && !(found)) {
+		if (ep->evt_sleep) {
+			switch (evcode) {
+			case FC_REG_CT_EVENT:
+				if ((ep->evt_type ==
+				     (void *)(ulong) FC_FSTYPE_ALL)
+				    || (ep->evt_type == fstype)) {
+					found++;
+					ep->evt_data0 = evdata0; /* tag */
+					ep->evt_data1 = evdata1; /* buffer
+								    ptr */
+					ep->evt_data2 = evdata2; /* count */
+					ep->evt_sleep = 0;
+					if (ehp->e_mode & E_SLEEPING_MODE) {
+						ehp->e_flag |=
+						    E_GET_EVENT_ACTIVE;
+						lpfc_wakeup_event(phba, ehp);
+					}
+					/* For FC_REG_CT_EVENT just give it to
+					   first one found */
+				}
+				break;
+			default:
+				found++;
+				ep->evt_data0 = evdata0;
+				ep->evt_data1 = evdata1;
+				ep->evt_data2 = evdata2;
+				ep->evt_sleep = 0;
+				if ((ehp->e_mode & E_SLEEPING_MODE)
+				    && !(ehp->e_flag & E_GET_EVENT_ACTIVE)) {
+					ehp->e_flag |= E_GET_EVENT_ACTIVE;
+					lpfc_wakeup_event(phba, ehp);
+				}
+				/* For all other events, give it to every one
+				   waiting */
+				break;
+			}
+		}
+		oep = ep;
+		
+		ep = ep->evt_next;
+	}
+	return (found);
+}
+
+int
+lpfc_hba_put_event(lpfcHBA_t * phba, uint32_t evcode, uint32_t evdata1,
+		  uint32_t evdata2, uint32_t evdata3, uint32_t evdata4)
+{
+	HBAEVT_t *rec;
+
+	rec = &phba->hbaevt[phba->hba_event_put];
+	rec->fc_eventcode = evcode;
+
+	rec->fc_evdata1 = evdata1;
+	rec->fc_evdata2 = evdata2;
+	rec->fc_evdata3 = evdata3;
+	rec->fc_evdata4 = evdata4;
+	phba->hba_event_put++;
+	if (phba->hba_event_put >= MAX_HBAEVT) {
+		phba->hba_event_put = 0;
+	}
+	if (phba->hba_event_put == phba->hba_event_get) {
+		phba->hba_event_missed++;
+		phba->hba_event_get++;
+		if (phba->hba_event_get >= MAX_HBAEVT) {
+			phba->hba_event_get = 0;
+		}
+	}
+
+	return (0);
+}
+
+
+LPFCSCSILUN_t *
+lpfc_tran_find_lun(LPFC_SCSI_BUF_t * lpfc_cmd)
+{
+	lpfcHBA_t *phba;
+	LPFCSCSILUN_t *lunp;
+
+	phba = lpfc_cmd->scsi_hba;
+	lunp = lpfc_find_lun(phba, lpfc_cmd->scsi_target, lpfc_cmd->scsi_lun,
+			     1);
+	return (lunp);
+}
+
+int
+lpfc_utsname_nodename_check(void)
+{
+	if (system_utsname.nodename[0] == '\0')
+		return (1);
+
+	return (0);
+}
+
+
+
+#define HBA_SPECIFIC_CFG_PARAM(hba)                                           \
+	switch (param) {                                                      \
+	case LPFC_CFG_LOG_VERBOSE:	/* log-verbose */                     \
+		value = lpfc_log_verbose;                                     \
+		if (lpfc##hba##_log_verbose != -1)                            \
+			value = lpfc##hba##_log_verbose;                      \
+		break;                                                        \
+	case LPFC_CFG_AUTOMAP:	/* automap */                                 \
+		value = lpfc_automap;                                         \
+		if (lpfc##hba##_automap != -1)                                \
+			value = lpfc##hba##_automap;                          \
+		break;                                                        \
+	case LPFC_CFG_BINDMETHOD:	/* bind-method */                     \
+		value = lpfc_fcp_bind_method;                                 \
+		if (lpfc##hba##_fcp_bind_method != -1)                        \
+			value = lpfc##hba##_fcp_bind_method;                  \
+		break;                                                        \
+	case LPFC_CFG_CR_DELAY:	/* cr_delay */                                \
+		value = lpfc_cr_delay;                                        \
+		if (lpfc##hba##_cr_delay != -1)                               \
+			value = lpfc##hba##_cr_delay;                         \
+		break;                                                        \
+	case LPFC_CFG_CR_COUNT:	/* cr_count */                                \
+		value = lpfc_cr_count;                                        \
+		if (lpfc##hba##_cr_count != -1)                               \
+			value = lpfc##hba##_cr_count;                         \
+		break;                                                        \
+	case LPFC_CFG_DFT_TGT_Q_DEPTH:	/* tgt_queue_depth */                 \
+		value = lpfc_tgt_queue_depth;                                 \
+		if (lpfc##hba##_tgt_queue_depth != -1)                        \
+			value = lpfc##hba##_tgt_queue_depth;                  \
+		break;                                                        \
+	case LPFC_CFG_DFT_LUN_Q_DEPTH:	/* lun_queue_depth */                 \
+		value = lpfc_lun_queue_depth;                                 \
+		if (lpfc##hba##_lun_queue_depth != -1)                        \
+			value = lpfc##hba##_lun_queue_depth;                  \
+		break;                                                        \
+	case LPFC_CFG_EXTRA_IO_TMO:	/* fcpfabric-tmo */                   \
+		value = lpfc_extra_io_tmo;                                    \
+		if (lpfc##hba##_extra_io_tmo != -1)                           \
+			value = lpfc##hba##_extra_io_tmo;                     \
+		break;                                                        \
+	case LPFC_CFG_FCP_CLASS:	/* fcp-class */                       \
+		value = lpfc_fcp_class;                                       \
+		if (lpfc##hba##_fcp_class != -1)                              \
+			value = lpfc##hba##_fcp_class;                        \
+		break;                                                        \
+	case LPFC_CFG_USE_ADISC:	/* use-adisc */                       \
+		value = lpfc_use_adisc;                                       \
+		if (lpfc##hba##_use_adisc != -1)                              \
+			value = lpfc##hba##_use_adisc;                        \
+		break;                                                        \
+	case LPFC_CFG_NO_DEVICE_DELAY:	/* no-device-delay */                 \
+		value = lpfc_no_device_delay;                                 \
+		if (lpfc##hba##_no_device_delay != -1)                        \
+			value = lpfc##hba##_no_device_delay;                  \
+		break;                                                        \
+	case LPFC_CFG_XMT_Q_SIZE:	/* xmt-que-size */                    \
+		value = lpfc_xmt_que_size;                                    \
+		if (lpfc##hba##_xmt_que_size != -1)                           \
+			value = lpfc##hba##_xmt_que_size;                     \
+		break;                                                        \
+	case LPFC_CFG_ACK0:	/* ack0 */                                    \
+		value = lpfc_ack0;                                            \
+		if (lpfc##hba##_ack0 != -1)                                   \
+			value = lpfc##hba##_ack0;                             \
+		break;                                                        \
+	case LPFC_CFG_TOPOLOGY:	/* topology */                                \
+		value = lpfc_topology;                                        \
+		if (lpfc##hba##_topology != -1)                               \
+			value = lpfc##hba##_topology;                         \
+		break;                                                        \
+	case LPFC_CFG_SCAN_DOWN:	/* scan-down */                       \
+		value = lpfc_scan_down;                                       \
+		if (lpfc##hba##_scan_down != -1)                              \
+			value = lpfc##hba##_scan_down;                        \
+		break;                                                        \
+	case LPFC_CFG_LINKDOWN_TMO:	/* linkdown-tmo */                    \
+		value = lpfc_linkdown_tmo;                                    \
+		if (lpfc##hba##_linkdown_tmo != -1)                           \
+			value = lpfc##hba##_linkdown_tmo;                     \
+		break;                                                        \
+	case LPFC_CFG_HOLDIO:	/* nodev-holdio */                            \
+		value = lpfc_nodev_holdio;                                    \
+		if (lpfc##hba##_nodev_holdio != -1)                           \
+			value = lpfc##hba##_nodev_holdio;                     \
+		break;                                                        \
+	case LPFC_CFG_DELAY_RSP_ERR:	/* delay-rsp-err */                   \
+		value = lpfc_delay_rsp_err;                                   \
+		if (lpfc##hba##_delay_rsp_err != -1)                          \
+			value = lpfc##hba##_delay_rsp_err;                    \
+		break;                                                        \
+	case LPFC_CFG_CHK_COND_ERR:	/* check-cond-err */                  \
+		value = lpfc_check_cond_err;                                  \
+		if (lpfc##hba##_check_cond_err != -1)                         \
+			value = lpfc##hba##_check_cond_err;                   \
+		break;                                                        \
+	case LPFC_CFG_NODEV_TMO:	/* nodev-tmo */                       \
+		value = lpfc_nodev_tmo;                                       \
+		if (lpfc##hba##_nodev_tmo != -1)                              \
+			value = lpfc##hba##_nodev_tmo;                        \
+		break;                                                        \
+	case LPFC_CFG_LINK_SPEED:	/* link-speed */                      \
+		value = lpfc_link_speed;                                      \
+		if (lpfc##hba##_link_speed != -1)                             \
+			value = lpfc##hba##_link_speed;                       \
+		break;                                                        \
+	case LPFC_CFG_DQFULL_THROTTLE_UP_TIME:	/* dqfull-throttle-up-time */ \
+		value = lpfc_dqfull_throttle_up_time;                         \
+		if (lpfc##hba##_dqfull_throttle_up_time != -1)                \
+			value = lpfc##hba##_dqfull_throttle_up_time;          \
+		break;                                                        \
+	case LPFC_CFG_DQFULL_THROTTLE_UP_INC:	/* dqfull-throttle-up-inc */  \
+		value = lpfc_dqfull_throttle_up_inc;                          \
+		if (lpfc##hba##_dqfull_throttle_up_inc != -1)                 \
+			value = lpfc##hba##_dqfull_throttle_up_inc;           \
+		break;                                                        \
+	case LPFC_CFG_FDMI_ON:	/* fdmi-on */                                 \
+		value = lpfc_fdmi_on;                                         \
+		if (lpfc##hba##_fdmi_on != -1)                                \
+			value = lpfc##hba##_fdmi_on;                          \
+		break;                                                        \
+	case LPFC_CFG_MAX_LUN:	/* max-lun */                                 \
+		value = lpfc_max_lun;                                         \
+		if (lpfc##hba##_max_lun != -1)                                \
+			value = lpfc##hba##_max_lun;                          \
+		break;                                                        \
+	case LPFC_CFG_DISC_THREADS:	/* discovery-threads */               \
+		value = lpfc_discovery_threads;                               \
+		if (lpfc##hba##_discovery_threads != -1)                      \
+			value = lpfc##hba##_discovery_threads;                \
+		break;                                                        \
+	case LPFC_CFG_MAX_TARGET:	/* max-target */                      \
+		value = lpfc_max_target;                                      \
+		if (lpfc##hba##_max_target != -1)                             \
+			value = lpfc##hba##_max_target;                       \
+		break;                                                        \
+	case LPFC_CFG_SCSI_REQ_TMO:	/* scsi-req-tmo */                    \
+		value = lpfc_scsi_req_tmo;                                    \
+		if (lpfc##hba##_scsi_req_tmo != -1)                           \
+			value = lpfc##hba##_scsi_req_tmo;                     \
+		break;                                                        \
+	case LPFC_CFG_LUN_SKIP:	/* lun-skip */                                \
+		value = lpfc_lun_skip;                                        \
+		if (lpfc##hba##_lun_skip != -1)                               \
+			value = lpfc##hba##_lun_skip;                         \
+		break;                                                        \
+	default:                                                              \
+		break;                                                        \
+	}
+
+uint32_t
+fc_get_cfg_param(int brd, int param)
+{
+	uint32_t value = (uint32_t)-1;
+
+	switch (brd) {
+	case 0:		/* HBA 0 */
+		HBA_SPECIFIC_CFG_PARAM(0);
+		break;
+	case 1:		/* HBA 1 */
+		HBA_SPECIFIC_CFG_PARAM(1);
+		break;
+	case 2:		/* HBA 2 */
+		HBA_SPECIFIC_CFG_PARAM(2);
+		break;
+	case 3:		/* HBA 3 */
+		HBA_SPECIFIC_CFG_PARAM(3);
+		break;
+	case 4:		/* HBA 4 */
+		HBA_SPECIFIC_CFG_PARAM(4);
+		break;
+	case 5:		/* HBA 5 */
+		HBA_SPECIFIC_CFG_PARAM(5);
+		break;
+	case 6:		/* HBA 6 */
+		HBA_SPECIFIC_CFG_PARAM(6);
+		break;
+	case 7:		/* HBA 7 */
+		HBA_SPECIFIC_CFG_PARAM(7);
+		break;
+	case 8:		/* HBA 8 */
+		HBA_SPECIFIC_CFG_PARAM(8);
+		break;
+	case 9:		/* HBA 9 */
+		HBA_SPECIFIC_CFG_PARAM(9);
+		break;
+	case 10:	/* HBA 10 */
+		HBA_SPECIFIC_CFG_PARAM(10);
+		break;
+	case 11:	/* HBA 11 */
+		HBA_SPECIFIC_CFG_PARAM(11);
+		break;
+	case 12:	/* HBA 12 */
+		HBA_SPECIFIC_CFG_PARAM(12);
+		break;
+	case 13:	/* HBA 13 */
+		HBA_SPECIFIC_CFG_PARAM(13);
+		break;
+	case 14:	/* HBA 14 */
+		HBA_SPECIFIC_CFG_PARAM(14);
+		break;
+	case 15:	/* HBA 15 */
+		HBA_SPECIFIC_CFG_PARAM(15);
+		break;
+	case 16:	/* HBA 16 */
+		HBA_SPECIFIC_CFG_PARAM(16);
+		break;
+	case 17:	/* HBA 17 */
+		HBA_SPECIFIC_CFG_PARAM(17);
+		break;
+	case 18:	/* HBA 18 */
+		HBA_SPECIFIC_CFG_PARAM(18);
+		break;
+	case 19:	/* HBA 19 */
+		HBA_SPECIFIC_CFG_PARAM(19);
+		break;
+	case 20:	/* HBA 20 */
+		HBA_SPECIFIC_CFG_PARAM(20);
+		break;
+	case 21:	/* HBA 21 */
+		HBA_SPECIFIC_CFG_PARAM(21);
+		break;
+	case 22:	/* HBA 22 */
+		HBA_SPECIFIC_CFG_PARAM(22);
+		break;
+	case 23:	/* HBA 23 */
+		HBA_SPECIFIC_CFG_PARAM(23);
+		break;
+	case 24:	/* HBA 24 */
+		HBA_SPECIFIC_CFG_PARAM(24);
+		break;
+	case 25:	/* HBA 25 */
+		HBA_SPECIFIC_CFG_PARAM(25);
+		break;
+	case 26:	/* HBA 26 */
+		HBA_SPECIFIC_CFG_PARAM(26);
+		break;
+	case 27:	/* HBA 27 */
+		HBA_SPECIFIC_CFG_PARAM(27);
+		break;
+	case 28:	/* HBA 28 */
+		HBA_SPECIFIC_CFG_PARAM(28);
+		break;
+	case 29:	/* HBA 29 */
+		HBA_SPECIFIC_CFG_PARAM(29);
+		break;
+	case 30:	/* HBA 30 */
+		HBA_SPECIFIC_CFG_PARAM(30);
+		break;
+	case 31:	/* HBA 31 */
+		HBA_SPECIFIC_CFG_PARAM(31);
+		break;
+	default:
+		break;
+	}
+	return (value);
+}
+
+
+
+void
+lpfc_sleep_ms(lpfcHBA_t * phba, int cnt)
+{
+	if (in_interrupt())
+		mdelay(cnt);
+	else {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout((cnt * HZ / 1000) + 1);
+	}
+	return;
+}
+
+void
+lpfc_drvr_init_lock(lpfcHBA_t * phba)
+{
+
+	spin_lock_init(&phba->drvrlock);
+	return;
+}
+
+void
+lpfc_drvr_lock(lpfcHBA_t * phba, unsigned long *iflag)
+{
+	unsigned long flag;
+
+	flag = 0;
+	spin_lock_irqsave(&phba->drvrlock, flag);
+	*iflag = flag;
+	phba->iflag = flag;
+	return;
+}
+
+void
+lpfc_drvr_unlock(lpfcHBA_t * phba, unsigned long *iflag)
+{
+
+	unsigned long flag;
+
+	flag = phba->iflag;
+	spin_unlock_irqrestore(&phba->drvrlock, flag);
+	return;
+}
+
+int
+lpfc_biosparam(Disk * disk, kdev_t n, int ip[])
+{
+	int size = disk->capacity;
+
+	ip[0] = 64;
+	ip[1] = 32;
+	ip[2] = size >> 11;
+	if (ip[2] > 1024) {
+		ip[0] = 255;
+		ip[1] = 63;
+		ip[2] = size / (ip[0] * ip[1]);
+#ifndef FC_EXTEND_TRANS_A
+		if (ip[2] > 1023)
+			ip[2] = 1023;
+#endif
+	}
+	return (0);
+}
+
+
+void
+lpfc_nodev(unsigned long l)
+{
+	return;
+}
+
+
+int
+lpfc_sleep(lpfcHBA_t * phba, void *wait_q_head, long tmo)
+{
+	wait_queue_t wq_entry;
+	unsigned long iflag = phba->iflag;
+	int rc = 1;
+	long left;
+
+	init_waitqueue_entry(&wq_entry, current);
+	/* start to sleep before we wait, to avoid races */
+	set_current_state(TASK_INTERRUPTIBLE);
+	add_wait_queue((wait_queue_head_t *) wait_q_head, &wq_entry);
+	if (tmo > 0) {
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		left = schedule_timeout(tmo * HZ);
+		LPFC_DRVR_LOCK(phba, iflag);
+	} else {
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		schedule();
+		LPFC_DRVR_LOCK(phba, iflag);
+		left = 0;
+	}
+	remove_wait_queue((wait_queue_head_t *) wait_q_head, &wq_entry);
+
+	if (signal_pending(current))
+		return (EINTR);
+	if (rc > 0)
+		return (0);
+	else
+		return (ETIMEDOUT);
+}
+
+void
+lpfc_discq_tasklet(lpfcHBA_t * phba, LPFC_DISC_EVT_t * evtp)
+{
+
+	/* Queue the cmnd to the iodone tasklet to be scheduled later */
+	list_add_tail(&evtp->evt_listp, &phba->task_disc);
+	phba->task_discq_cnt++;
+	tasklet_schedule(&phba->task_run);
+	return;
+}
+
+int
+lpfc_discq_post_event(lpfcHBA_t * phba, void *arg1, void *arg2, uint32_t evt)
+{
+	LPFC_DISC_EVT_t  *evtp;
+
+	/* All Mailbox completions and LPFC_ELS_RING rcv ring events will be
+	 * queued to tasklet for processing
+	 */
+	evtp = (LPFC_DISC_EVT_t *) kmalloc(sizeof(LPFC_DISC_EVT_t), GFP_ATOMIC);
+	if(evtp == 0) {
+		return (0);
+	}
+	evtp->evt_arg1  = arg1;
+	evtp->evt_arg2  = arg2;
+	evtp->evt       = evt;
+	evtp->evt_listp.next = 0;
+	evtp->evt_listp.prev = 0;
+	lpfc_discq_tasklet(phba, evtp);
+	return (1);
+}
+
+void
+lpfc_flush_disc_evtq(lpfcHBA_t * phba) {
+
+	LPFC_SLI_t       * psli;
+	struct list_head * pos, * pos_tmp;
+	struct list_head * cur, * next;
+	LPFC_DISC_EVT_t  * evtp;
+	IOCB_t           * cmd = 0;
+	LPFC_IOCBQ_t     * cmdiocbp;
+	LPFC_IOCBQ_t     * rspiocbp;
+	LPFC_IOCBQ_t     * saveq;
+	LPFC_RING_MASK_t * func;
+
+	psli = &phba->sli;
+
+	list_for_each_safe(pos, pos_tmp, &phba->task_disc) {
+		evtp = list_entry(pos, LPFC_DISC_EVT_t, evt_listp);
+
+		if ((evtp->evt == LPFC_EVT_SOL_IOCB)) {
+			list_del(&evtp->evt_listp);
+			phba->task_discq_cnt--;
+
+			cmdiocbp = (LPFC_IOCBQ_t *)(evtp->evt_arg1);
+			saveq = (LPFC_IOCBQ_t *)(evtp->evt_arg2);
+			cmd = &cmdiocbp->iocb;
+			cmd->ulpStatus = IOSTAT_LOCAL_REJECT;
+			cmd->un.ulpWord[4] = IOERR_SLI_ABORTED;
+			(cmdiocbp->iocb_cmpl) (phba, cmdiocbp, saveq);
+			/* Free up iocb buffer chain for command just
+			   processed */
+			list_for_each_safe(cur, next, &saveq->list) {
+				rspiocbp = list_entry(cur, LPFC_IOCBQ_t, list);
+				list_del(&rspiocbp->list);
+				lpfc_iocb_free(phba, rspiocbp);
+			}
+			lpfc_iocb_free(phba, saveq);
+			kfree(evtp);
+			continue;
+		}
+		if ((evtp->evt == LPFC_EVT_UNSOL_IOCB)) {
+                        list_del(&evtp->evt_listp);
+                        phba->task_discq_cnt--;
+
+                        func = (LPFC_RING_MASK_t *)(evtp->evt_arg1);
+                        saveq = (LPFC_IOCBQ_t *)(evtp->evt_arg2);
+                        (func->lpfc_sli_rcv_unsol_event) (phba,
+							  &psli->ring[LPFC_ELS_RING], saveq);
+                        /* Free up iocb buffer chain for command just
+                           processed */
+                        list_for_each_safe(cur, next, &saveq->list) {
+                                rspiocbp = list_entry(cur, LPFC_IOCBQ_t, list);
+                                list_del(&rspiocbp->list);
+                                lpfc_iocb_free(phba, rspiocbp);
+                        }
+                        lpfc_iocb_free(phba, saveq);
+                        kfree(evtp);
+                        continue;
+			
+                }
+
+		else
+			continue;
+	}
+}
+
+void
+lpfc_tasklet(unsigned long p)
+{
+	lpfcHBA_t        * phba = (lpfcHBA_t *)p;
+	LPFC_SLI_t       * psli;
+	LPFC_DISC_EVT_t  * evtp;
+	struct list_head * cur, * next;
+	LPFC_MBOXQ_t     * pmb;
+	LPFC_IOCBQ_t     * cmdiocbp;
+	LPFC_IOCBQ_t     * rspiocbp;
+	LPFC_IOCBQ_t     * saveq;
+	LPFC_RING_MASK_t * func;
+	unsigned long      flags;
+
+	psli = &phba->sli;
+	LPFC_DRVR_LOCK(phba, flags);
+
+	/* check discovery event list */
+	while (!list_empty(&phba->task_disc)) {
+		evtp = list_entry(phba->task_disc.next, LPFC_DISC_EVT_t, evt_listp);
+		list_del(&evtp->evt_listp);
+		phba->task_discq_cnt--;
+
+		switch(evtp->evt) {
+		case LPFC_EVT_MBOX:
+			pmb = (LPFC_MBOXQ_t *)(evtp->evt_arg1);
+			if (pmb->mbox_cmpl) {
+				(pmb->mbox_cmpl) (phba, pmb);
+			}
+			else {
+				lpfc_mbox_free(phba, pmb);
+			}
+			break;
+
+		case LPFC_EVT_SOL_IOCB:
+			cmdiocbp = (LPFC_IOCBQ_t *)(evtp->evt_arg1);
+			saveq = (LPFC_IOCBQ_t *)(evtp->evt_arg2);
+			(cmdiocbp->iocb_cmpl) (phba, cmdiocbp, saveq);
+			/* Free up iocb buffer chain for command just
+			   processed */
+			list_for_each_safe(cur, next, &saveq->list) {
+				rspiocbp = list_entry(cur, LPFC_IOCBQ_t, list);
+				list_del(&rspiocbp->list);
+				lpfc_iocb_free(phba, rspiocbp);
+			}
+			lpfc_iocb_free(phba, saveq);
+			break;
+		case LPFC_EVT_UNSOL_IOCB:
+			func = (LPFC_RING_MASK_t *)(evtp->evt_arg1);
+			saveq = (LPFC_IOCBQ_t *)(evtp->evt_arg2);
+			(func->lpfc_sli_rcv_unsol_event) (phba, 
+	 		&psli->ring[LPFC_ELS_RING], saveq);
+			/* Free up iocb buffer chain for command just
+			   processed */
+			list_for_each_safe(cur, next, &saveq->list) {
+				rspiocbp = list_entry(cur, LPFC_IOCBQ_t, list);
+				list_del(&rspiocbp->list);
+				lpfc_iocb_free(phba, rspiocbp);
+			}
+			lpfc_iocb_free(phba, saveq);
+			break;
+		}
+		kfree(evtp);
+	}
+	LPFC_DRVR_UNLOCK(phba, flags);
+	return;
+}
+
+#include <scsi_module.c>
+MODULE_LICENSE("GPL");
+
+/*
+ * Note: PPC64 architecture has function descriptors,
+ * so insmod on 2.4 does not automatically export all symbols.
+ */
+EXPORT_SYMBOL(lpfc_add_bind);
+EXPORT_SYMBOL(lpfc_block_requests);
+EXPORT_SYMBOL(lpfc_build_scsi_cmd);
+EXPORT_SYMBOL(lpfc_decode_firmware_rev);
+EXPORT_SYMBOL(lpfc_del_bind);
+EXPORT_SYMBOL(lpfcDRVR);
+EXPORT_SYMBOL(lpfc_drvr_name);
+EXPORT_SYMBOL(lpfc_drvr_lock);
+EXPORT_SYMBOL(lpfc_drvr_unlock);
+EXPORT_SYMBOL(lpfc_els_free_iocb);
+EXPORT_SYMBOL(lpfc_find_lun);
+EXPORT_SYMBOL(lpfc_findnode_did);
+EXPORT_SYMBOL(lpfc_findnode_scsiid);
+EXPORT_SYMBOL(lpfc_findnode_wwnn);
+EXPORT_SYMBOL(lpfc_findnode_wwpn);
+EXPORT_SYMBOL(lpfc_free_scsi_buf);
+EXPORT_SYMBOL(lpfc_geportname);
+EXPORT_SYMBOL(lpfc_get_hba_sym_node_name);
+EXPORT_SYMBOL(lpfc_get_scsi_buf);
+EXPORT_SYMBOL(lpfc_init_link);
+EXPORT_SYMBOL(lpfc_iocb_alloc);
+EXPORT_SYMBOL(lpfc_iocb_free);
+EXPORT_SYMBOL(lpfc_issue_ct_rsp);
+EXPORT_SYMBOL(lpfc_issue_els_adisc);
+EXPORT_SYMBOL(lpfc_issue_els_logo);
+EXPORT_SYMBOL(lpfc_issue_els_plogi);
+EXPORT_SYMBOL(lpfc_mbox_alloc);
+EXPORT_SYMBOL(lpfc_mbox_free);
+EXPORT_SYMBOL(lpfc_mbuf_alloc);
+EXPORT_SYMBOL(lpfc_mbuf_free);
+EXPORT_SYMBOL(lpfc_page_alloc);
+EXPORT_SYMBOL(lpfc_page_free);
+EXPORT_SYMBOL(lpfc_nlp_alloc);
+EXPORT_SYMBOL(lpfc_nlp_free);
+EXPORT_SYMBOL(lpfc_nlp_bind);
+EXPORT_SYMBOL(lpfc_nlp_plogi);
+EXPORT_SYMBOL(lpfc_offline);
+EXPORT_SYMBOL(lpfc_online);
+EXPORT_SYMBOL(lpfc_prep_els_iocb);
+EXPORT_SYMBOL(lpfc_release_version);
+EXPORT_SYMBOL(lpfc_scsi_lun_reset);
+EXPORT_SYMBOL(lpfc_scsi_tgt_reset);
+EXPORT_SYMBOL(lpfc_sleep);
+EXPORT_SYMBOL(lpfc_sleep_ms);
+EXPORT_SYMBOL(lpfc_sli_brdreset);
+EXPORT_SYMBOL(lpfc_sli_issue_iocb_wait);
+EXPORT_SYMBOL(lpfc_sli_issue_mbox);
+EXPORT_SYMBOL(lpfc_sli_issue_mbox_wait);
+EXPORT_SYMBOL(lpfc_sli_next_iotag);
+EXPORT_SYMBOL(lpfc_sli_pcimem_bcopy);
+EXPORT_SYMBOL(lpfc_unblock_requests);
+EXPORT_SYMBOL(lpfc_get_phba_by_inst);
+
+EXPORT_SYMBOL(lpfc_sched_continue_hba);
+EXPORT_SYMBOL(lpfc_sched_pause_hba);
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_fcp.h linux-8155/drivers/addon/lpfc/lpfc_fcp.h
--- linux-8152/drivers/addon/lpfc/lpfc_fcp.h
+++ linux-8155/drivers/addon/lpfc/lpfc_fcp.h
@@ -0,0 +1,161 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_fcp.h 328 2005-05-03 15:20:43Z sf_support $
+ */
+
+#ifndef H_LPFC_DFC
+#define H_LPFC_DFC
+
+#define MAX_LPFC_SNS      128
+
+#define FCP_CONTINUE    0x01	/* flag for issue_fcp_cmd */
+#define FCP_REQUEUE     0x02	/* flag for issue_fcp_cmd */
+#define FCP_EXIT        0x04	/* flag for issue_fcp_cmd */
+
+typedef struct _FCP_RSP {
+	uint32_t rspRsvd1;	/* FC Word 0, byte 0:3 */
+	uint32_t rspRsvd2;	/* FC Word 1, byte 0:3 */
+
+	uint8_t rspStatus0;	/* FCP_STATUS byte 0 (reserved) */
+	uint8_t rspStatus1;	/* FCP_STATUS byte 1 (reserved) */
+	uint8_t rspStatus2;	/* FCP_STATUS byte 2 field validity */
+#define RSP_LEN_VALID  0x01	/* bit 0 */
+#define SNS_LEN_VALID  0x02	/* bit 1 */
+#define RESID_OVER     0x04	/* bit 2 */
+#define RESID_UNDER    0x08	/* bit 3 */
+	uint8_t rspStatus3;	/* FCP_STATUS byte 3 SCSI status byte */
+#define SCSI_STAT_GOOD        0x00
+#define SCSI_STAT_CHECK_COND  0x02
+#define SCSI_STAT_COND_MET    0x04
+#define SCSI_STAT_BUSY        0x08
+#define SCSI_STAT_INTERMED    0x10
+#define SCSI_STAT_INTERMED_CM 0x14
+#define SCSI_STAT_RES_CNFLCT  0x18
+#define SCSI_STAT_CMD_TERM    0x22
+#define SCSI_STAT_QUE_FULL    0x28
+
+	uint32_t rspResId;	/* Residual xfer if residual count field set in
+				   fcpStatus2 */
+	/* Received in Big Endian format */
+	uint32_t rspSnsLen;	/* Length of sense data in fcpSnsInfo */
+	/* Received in Big Endian format */
+	uint32_t rspRspLen;	/* Length of FCP response data in fcpRspInfo */
+	/* Received in Big Endian format */
+
+	uint8_t rspInfo0;	/* FCP_RSP_INFO byte 0 (reserved) */
+	uint8_t rspInfo1;	/* FCP_RSP_INFO byte 1 (reserved) */
+	uint8_t rspInfo2;	/* FCP_RSP_INFO byte 2 (reserved) */
+	uint8_t rspInfo3;	/* FCP_RSP_INFO RSP_CODE byte 3 */
+
+#define RSP_NO_FAILURE       0x00
+#define RSP_DATA_BURST_ERR   0x01
+#define RSP_CMD_FIELD_ERR    0x02
+#define RSP_RO_MISMATCH_ERR  0x03
+#define RSP_TM_NOT_SUPPORTED 0x04	/* Task mgmt function not supported */
+#define RSP_TM_NOT_COMPLETED 0x05	/* Task mgmt function not performed */
+
+	uint32_t rspInfoRsvd;	/* FCP_RSP_INFO bytes 4-7 (reserved) */
+
+	uint8_t rspSnsInfo[MAX_LPFC_SNS];
+#define SNS_ILLEGAL_REQ 0x05	/* sense key is byte 3 ([2]) */
+#define SNSCOD_BADCMD 0x20	/* sense code is byte 13 ([12]) */
+} FCP_RSP, *PFCP_RSP;
+
+typedef struct _FCP_CMND {
+	uint32_t fcpLunMsl;	/* most  significant lun word (32 bits) */
+	uint32_t fcpLunLsl;	/* least significant lun word (32 bits) */
+	/* # of bits to shift lun id to end up in right
+	 * payload word, little endian = 8, big = 16.
+	 */
+#if __BIG_ENDIAN
+#define FC_LUN_SHIFT         16
+#define FC_ADDR_MODE_SHIFT   24
+#else	/*  __LITTLE_ENDIAN */
+#define FC_LUN_SHIFT         8
+#define FC_ADDR_MODE_SHIFT   0
+#endif
+
+	uint8_t fcpCntl0;	/* FCP_CNTL byte 0 (reserved) */
+	uint8_t fcpCntl1;	/* FCP_CNTL byte 1 task codes */
+#define  SIMPLE_Q        0x00
+#define  HEAD_OF_Q       0x01
+#define  ORDERED_Q       0x02
+#define  ACA_Q           0x04
+#define  UNTAGGED        0x05
+	uint8_t fcpCntl2;	/* FCP_CTL byte 2 task management codes */
+#define  ABORT_TASK_SET  0x02	/* Bit 1 */
+#define  CLEAR_TASK_SET  0x04	/* bit 2 */
+#define  BUS_RESET       0x08	/* bit 3 */
+#define  LUN_RESET       0x10	/* bit 4 */
+#define  TARGET_RESET    0x20	/* bit 5 */
+#define  CLEAR_ACA       0x40	/* bit 6 */
+#define  TERMINATE_TASK  0x80	/* bit 7 */
+	uint8_t fcpCntl3;
+#define  WRITE_DATA      0x01	/* Bit 0 */
+#define  READ_DATA       0x02	/* Bit 1 */
+
+	uint8_t fcpCdb[16];	/* SRB cdb field is copied here */
+	uint32_t fcpDl;		/* Total transfer length */
+
+} FCP_CMND, *PFCP_CMND;
+
+/* SCSI CDB command codes */
+#define FCP_SCSI_FORMAT_UNIT                  0x04
+#define FCP_SCSI_INQUIRY                      0x12
+#define FCP_SCSI_MODE_SELECT                  0x15
+#define FCP_SCSI_MODE_SENSE                   0x1A
+#define FCP_SCSI_PAUSE_RESUME                 0x4B
+#define FCP_SCSI_PLAY_AUDIO                   0x45
+#define FCP_SCSI_PLAY_AUDIO_EXT               0xA5
+#define FCP_SCSI_PLAY_AUDIO_MSF               0x47
+#define FCP_SCSI_PLAY_AUDIO_TRK_INDX          0x48
+#define FCP_SCSI_PREVENT_ALLOW_REMOVAL        0x1E
+#define FCP_SCSI_READ                         0x08
+#define FCP_SCSI_READ_BUFFER                  0x3C
+#define FCP_SCSI_READ_CAPACITY                0x25
+#define FCP_SCSI_READ_DEFECT_LIST             0x37
+#define FCP_SCSI_READ_EXTENDED                0x28
+#define FCP_SCSI_READ_HEADER                  0x44
+#define FCP_SCSI_READ_LONG                    0xE8
+#define FCP_SCSI_READ_SUB_CHANNEL             0x42
+#define FCP_SCSI_READ_TOC                     0x43
+#define FCP_SCSI_REASSIGN_BLOCK               0x07
+#define FCP_SCSI_RECEIVE_DIAGNOSTIC_RESULTS   0x1C
+#define FCP_SCSI_RELEASE_UNIT                 0x17
+#define FCP_SCSI_REPORT_LUNS                  0xa0
+#define FCP_SCSI_REQUEST_SENSE                0x03
+#define FCP_SCSI_RESERVE_UNIT                 0x16
+#define FCP_SCSI_REZERO_UNIT                  0x01
+#define FCP_SCSI_SEEK                         0x0B
+#define FCP_SCSI_SEEK_EXTENDED                0x2B
+#define FCP_SCSI_SEND_DIAGNOSTIC              0x1D
+#define FCP_SCSI_START_STOP_UNIT              0x1B
+#define FCP_SCSI_TEST_UNIT_READY              0x00
+#define FCP_SCSI_VERIFY                       0x2F
+#define FCP_SCSI_WRITE                        0x0A
+#define FCP_SCSI_WRITE_AND_VERIFY             0x2E
+#define FCP_SCSI_WRITE_BUFFER                 0x3B
+#define FCP_SCSI_WRITE_EXTENDED               0x2A
+#define FCP_SCSI_WRITE_LONG                   0xEA
+#define FCP_SCSI_RELEASE_LUNR                 0xBB
+#define FCP_SCSI_RELEASE_LUNV                 0xBF
+#endif
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_hbadisc.c linux-8155/drivers/addon/lpfc/lpfc_hbadisc.c
--- linux-8152/drivers/addon/lpfc/lpfc_hbadisc.c
+++ linux-8155/drivers/addon/lpfc/lpfc_hbadisc.c
@@ -0,0 +1,3245 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_hbadisc.c 369 2005-07-08 23:29:48Z sf_support $
+ */
+
+#include <linux/version.h>
+#include <linux/spinlock.h>
+#include <linux/pci.h>
+
+
+#include <linux/blk.h>
+#include <scsi.h>
+
+#include "lpfc_hw.h"
+#include "lpfc_sli.h"
+#include "lpfc_mem.h"
+#include "lpfc_sched.h"
+#include "lpfc_disc.h"
+#include "lpfc.h"
+#include "lpfc_logmsg.h"
+#include "lpfc_fcp.h"
+#include "lpfc_scsi.h"
+#include "lpfc_cfgparm.h"
+#include "hbaapi.h"
+#include "lpfc_dfc.h"
+#include "lpfc_crtn.h"
+
+int lpfc_matchdid(lpfcHBA_t *, LPFC_NODELIST_t *, uint32_t);
+void lpfc_free_tx(lpfcHBA_t *, LPFC_NODELIST_t *);
+void lpfc_put_buf(unsigned long);
+void lpfc_disc_retry_rptlun(unsigned long);
+
+/* Could be put in lpfc.conf; For now defined here */
+int lpfc_qfull_retry_count = 5;
+
+/* AlpaArray for assignment of scsid for scan-down and bind_method */
+uint8_t lpfcAlpaArray[] = {
+	0xEF, 0xE8, 0xE4, 0xE2, 0xE1, 0xE0, 0xDC, 0xDA, 0xD9, 0xD6,
+	0xD5, 0xD4, 0xD3, 0xD2, 0xD1, 0xCE, 0xCD, 0xCC, 0xCB, 0xCA,
+	0xC9, 0xC7, 0xC6, 0xC5, 0xC3, 0xBC, 0xBA, 0xB9, 0xB6, 0xB5,
+	0xB4, 0xB3, 0xB2, 0xB1, 0xAE, 0xAD, 0xAC, 0xAB, 0xAA, 0xA9,
+	0xA7, 0xA6, 0xA5, 0xA3, 0x9F, 0x9E, 0x9D, 0x9B, 0x98, 0x97,
+	0x90, 0x8F, 0x88, 0x84, 0x82, 0x81, 0x80, 0x7C, 0x7A, 0x79,
+	0x76, 0x75, 0x74, 0x73, 0x72, 0x71, 0x6E, 0x6D, 0x6C, 0x6B,
+	0x6A, 0x69, 0x67, 0x66, 0x65, 0x63, 0x5C, 0x5A, 0x59, 0x56,
+	0x55, 0x54, 0x53, 0x52, 0x51, 0x4E, 0x4D, 0x4C, 0x4B, 0x4A,
+	0x49, 0x47, 0x46, 0x45, 0x43, 0x3C, 0x3A, 0x39, 0x36, 0x35,
+	0x34, 0x33, 0x32, 0x31, 0x2E, 0x2D, 0x2C, 0x2B, 0x2A, 0x29,
+	0x27, 0x26, 0x25, 0x23, 0x1F, 0x1E, 0x1D, 0x1B, 0x18, 0x17,
+	0x10, 0x0F, 0x08, 0x04, 0x02, 0x01
+};
+
+int
+lpfc_linkdown(lpfcHBA_t * phba)
+{
+	LPFC_SLI_t *psli;
+	LPFC_NODELIST_t *ndlp;
+	LPFC_NODELIST_t *new_ndlp;
+	struct list_head *pos, *next, *listp;
+	struct list_head *node_list[4];
+	LPFCSCSITARGET_t *targetp;
+	LPFC_MBOXQ_t *mb;
+	lpfcCfgParam_t *clp;
+	int rc, i;
+
+	clp = &phba->config[0];
+	psli = &phba->sli;
+	phba->hba_state = LPFC_LINK_DOWN;
+	phba->fc_flag |= FC_LNK_DOWN;
+
+	lpfc_put_event(phba, FC_REG_LINK_EVENT, 0, 0, 0);
+	phba->nport_event_cnt++;
+
+	lpfc_hba_put_event(phba, HBA_EVENT_LINK_DOWN, phba->fc_myDID, 0, 0, 0);
+
+	/* Clean up any firmware default rpi's */
+	if ((mb = lpfc_mbox_alloc(phba, 0))) {
+		lpfc_unreg_did(phba, 0xffffffff, mb);
+		if (lpfc_sli_issue_mbox(phba, mb, (MBX_NOWAIT | MBX_STOP_IOCB))
+		    == MBX_NOT_FINISHED) {
+			lpfc_mbox_free(phba, mb);
+		}
+	}
+
+
+	/* Cleanup any outstanding RSCN activity */
+	lpfc_els_flush_rscn(phba);
+
+	/* Cleanup any outstanding ELS commands */
+	lpfc_els_flush_cmd(phba);
+
+	/* Flush all the ELS completion in the tasklet queue */
+	lpfc_flush_disc_evtq(phba);
+
+	/* Handle linkdown timer logic.   */
+	if (!(phba->fc_flag & FC_LD_TIMER)) {
+		/* Should we start the link down watchdog timer */
+		if ((clp[LPFC_CFG_LINKDOWN_TMO].a_current == 0) ||
+		    clp[LPFC_CFG_HOLDIO].a_current) {
+			phba->fc_flag |= (FC_LD_TIMER | FC_LD_TIMEOUT);
+			phba->hba_flag |= FC_LFR_ACTIVE;
+		} else {
+			phba->fc_flag |= FC_LD_TIMER;
+			phba->hba_flag |= FC_LFR_ACTIVE;
+			if (phba->fc_linkdown.function) {
+				unsigned long new_tmo;
+				new_tmo = jiffies + HZ *
+				    (clp[LPFC_CFG_LINKDOWN_TMO].a_current);
+				mod_timer(&phba->fc_linkdown, new_tmo);
+			} else {
+				if (clp[LPFC_CFG_HOLDIO].a_current == 0) {
+					lpfc_start_timer(phba,
+						clp[LPFC_CFG_LINKDOWN_TMO]
+							 .a_current,
+						&phba->fc_linkdown,
+						lpfc_linkdown_timeout, 0, 0);
+				}
+			}
+		}
+	}
+
+	/* Issue a LINK DOWN event to all nodes */
+	node_list[0] = &phba->fc_plogi_list;
+	node_list[1] = &phba->fc_adisc_list;
+	node_list[2] = &phba->fc_nlpunmap_list;
+	node_list[3] = &phba->fc_nlpmap_list;
+	for (i = 0; i < 4; i++) {
+		listp = node_list[i];
+		if (list_empty(listp))
+			continue;
+
+		list_for_each_safe(pos, next, listp) {
+			new_ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			ndlp = new_ndlp;
+
+			/* Fabric nodes are not handled thru state machine for
+			   link down */
+			if (!(ndlp->nlp_type & NLP_FABRIC)) {
+				lpfc_set_failmask(phba, ndlp,
+						  LPFC_DEV_LINK_DOWN,
+						  LPFC_SET_BITMASK);
+			}
+
+			targetp = ndlp->nlp_Target;
+			if(targetp)
+				lpfc_set_npr_tmo(phba, targetp, ndlp);
+
+			rc = lpfc_disc_state_machine(phba, ndlp, 0,
+						     NLP_EVT_DEVICE_UNK);
+		}
+	}
+
+	/* Setup myDID for link up if we are in pt2pt mode */
+	if (phba->fc_flag & FC_PT2PT) {
+		phba->fc_myDID = 0;
+		if ((mb = lpfc_mbox_alloc(phba, 0))) {
+			lpfc_config_link(phba, mb);
+			if (lpfc_sli_issue_mbox
+			    (phba, mb, (MBX_NOWAIT | MBX_STOP_IOCB))
+			    == MBX_NOT_FINISHED) {
+				lpfc_mbox_free(phba, mb);
+			}
+		}
+		phba->fc_flag &= ~(FC_PT2PT | FC_PT2PT_PLOGI);
+	}
+	phba->fc_flag &= ~FC_LBIT;
+
+	/* Turn off discovery timer if its running */
+	lpfc_can_disctmo(phba);
+
+
+	/* Must process IOCBs on all rings to handle ABORTed I/Os */
+	return (0);
+}
+
+int
+lpfc_linkup(lpfcHBA_t * phba)
+{
+	LPFC_NODELIST_t *ndlp, *new_ndlp;
+	struct list_head *pos, *next, *listp;
+	struct list_head *node_list[4];
+	lpfcCfgParam_t *clp;
+	int i;
+
+	clp = &phba->config[0];
+	phba->hba_state = LPFC_LINK_UP;
+	phba->hba_flag |= FC_NDISC_ACTIVE;
+	phba->fc_flag &= ~(FC_LNK_DOWN | FC_PT2PT | FC_PT2PT_PLOGI |
+			   FC_RSCN_MODE | FC_NLP_MORE | FC_DELAY_DISC |
+			   FC_RSCN_DISC_TMR | FC_RSCN_DISCOVERY | FC_LD_TIMER |
+			   FC_LD_TIMEOUT);
+	phba->fc_ns_retry = 0;
+
+	lpfc_put_event(phba, FC_REG_LINK_EVENT, 0, 0, 0);
+	phba->nport_event_cnt++;
+
+	lpfc_hba_put_event(phba, HBA_EVENT_LINK_UP, phba->fc_myDID,
+			  phba->fc_topology, 0, phba->fc_linkspeed);
+
+	if (phba->fc_linkdown.function) {
+		lpfc_stop_timer((struct clk_data *)phba->fc_linkdown.data);
+	}
+
+	/*
+	 * Clean up old Fabric, NameServer and other NLP_FABRIC logins.
+	 */
+	list_for_each_safe(pos, next, &phba->fc_nlpunmap_list) {
+		new_ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+		ndlp = new_ndlp;
+		if (ndlp->nlp_type & NLP_FABRIC) {
+			ndlp->nlp_flag &= ~(NLP_UNMAPPED_LIST |
+					    NLP_TGT_NO_SCSIID);
+			lpfc_nlp_remove(phba, ndlp);
+		}
+	}
+
+	/* Mark all nodes for LINK UP */
+	node_list[0] = &phba->fc_plogi_list;
+	node_list[1] = &phba->fc_adisc_list;
+	node_list[2] = &phba->fc_nlpunmap_list;
+	node_list[3] = &phba->fc_nlpmap_list;
+	for (i = 0; i < 4; i++) {
+		listp = node_list[i];
+		if (list_empty(listp))
+			continue;
+
+		list_for_each(pos, listp) {
+			ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			lpfc_set_failmask(phba, ndlp, LPFC_DEV_RPTLUN,
+					  LPFC_SET_BITMASK);
+			lpfc_set_failmask(phba, ndlp, LPFC_DEV_LINK_DOWN,
+					  LPFC_CLR_BITMASK);
+		}
+	}
+	/* Setup for first FLOGI */
+	phba->fc_ratov = LPFC_DISC_FLOGI_TMO;
+
+	return (0);
+}
+
+/*
+ * This routine handles processing a READ_LA mailbox
+ * command upon completion. It is setup in the LPFC_MBOXQ
+ * as the completion routine when the command is
+ * handed off to the SLI layer.
+ */
+void
+lpfc_mbx_cmpl_read_la(lpfcHBA_t * phba, LPFC_MBOXQ_t * pmb)
+{
+	DMABUF_t *mp;
+	LPFC_SLI_t *psli;
+	READ_LA_VAR *la;
+	LPFC_MBOXQ_t *mbox;
+	MAILBOX_t *mb;
+	lpfcCfgParam_t *clp;
+	uint32_t control;
+	int i;
+
+	clp = &phba->config[0];
+	psli = &phba->sli;
+	mb = &pmb->mb;
+	/* Check for error */
+	if (mb->mbxStatus) {
+		/* READ_LA mbox error <mbxStatus> state <hba_state> */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk1307,
+				lpfc_mes1307,
+				lpfc_msgBlk1307.msgPreambleStr,
+				mb->mbxStatus, phba->hba_state);
+
+		lpfc_linkdown(phba);
+		phba->hba_state = LPFC_HBA_ERROR;
+
+		/* turn on Link Attention interrupts */
+		psli->sliinit.sli_flag |= LPFC_PROCESS_LA;
+		control = readl(phba->HCregaddr);
+		control |= HC_LAINT_ENA;
+		writel(control, phba->HCregaddr);
+		readl(phba->HCregaddr); /* flush */
+		mp = (DMABUF_t *) (pmb->context1);
+		lpfc_mbuf_free(phba, mp->virt, mp->phys);
+		kfree(mp);
+		return;
+	}
+	la = (READ_LA_VAR *) & pmb->mb.un.varReadLA;
+
+	mp = (DMABUF_t *) (pmb->context1);
+
+	/* Get Loop Map information */
+	if (mp) {
+		memcpy(&phba->alpa_map[0], mp->virt, 128);
+	} else {
+		memset(&phba->alpa_map[0], 0, 128);
+	}
+
+	if (la->pb)
+		phba->fc_flag |= FC_BYPASSED_MODE;
+	else
+		phba->fc_flag &= ~FC_BYPASSED_MODE;
+
+	if (((phba->fc_eventTag + 1) < la->eventTag) ||
+	    (phba->fc_eventTag == la->eventTag)) {
+		phba->fc_stat.LinkMultiEvent++;
+		if (la->attType == AT_LINK_UP) {
+			if (phba->fc_eventTag != 0) {
+
+				lpfc_linkdown(phba);
+			}
+		}
+	}
+
+	phba->fc_eventTag = la->eventTag;
+
+	if (la->attType == AT_LINK_UP) {
+		phba->fc_stat.LinkUp++;
+		/* Link Up Event <eventTag> received */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk1303,
+				lpfc_mes1303,
+				lpfc_msgBlk1303.msgPreambleStr,
+				la->eventTag, phba->fc_eventTag,
+				la->granted_AL_PA, la->UlnkSpeed,
+				phba->alpa_map[0]);
+
+		switch(la->UlnkSpeed) {
+			case LA_1GHZ_LINK:
+				phba->fc_linkspeed = LA_1GHZ_LINK;
+			break;
+			case LA_2GHZ_LINK:
+				phba->fc_linkspeed = LA_2GHZ_LINK;
+			break;
+			case LA_4GHZ_LINK:
+				phba->fc_linkspeed = LA_4GHZ_LINK;
+			break;
+			default:
+				phba->fc_linkspeed = LA_UNKNW_LINK;
+			break;
+		}
+
+		if ((phba->fc_topology = la->topology) == TOPOLOGY_LOOP) {
+
+			if (la->il) {
+				phba->fc_flag |= FC_LBIT;
+			}
+
+			phba->fc_myDID = la->granted_AL_PA;
+
+			i = la->un.lilpBde64.tus.f.bdeSize;
+			if (i == 0) {
+				phba->alpa_map[0] = 0;
+			} else {
+				if (clp[LPFC_CFG_LOG_VERBOSE].
+				    a_current & LOG_LINK_EVENT) {
+					int numalpa, j, k;
+					union {
+						uint8_t pamap[16];
+						struct {
+							uint32_t wd1;
+							uint32_t wd2;
+							uint32_t wd3;
+							uint32_t wd4;
+						} pa;
+					} un;
+
+					numalpa = phba->alpa_map[0];
+					j = 0;
+					while (j < numalpa) {
+						memset(un.pamap, 0, 16);
+						for (k = 1; j < numalpa; k++) {
+							un.pamap[k - 1] =
+							    phba->alpa_map[j +
+									   1];
+							j++;
+							if (k == 16)
+								break;
+						}
+						/* Link Up Event ALPA map */
+						lpfc_printf_log(phba->brd_no,
+							&lpfc_msgBlk1304,
+							lpfc_mes1304,
+							lpfc_msgBlk1304
+								.msgPreambleStr,
+							un.pa.wd1, un.pa.wd2,
+							un.pa.wd3, un.pa.wd4);
+					}
+				}
+			}
+		} else {
+			phba->fc_myDID = phba->fc_pref_DID;
+			phba->fc_flag |= FC_LBIT;
+		}
+
+		lpfc_linkup(phba);
+		if ((mbox = lpfc_mbox_alloc(phba, MEM_PRI))) {
+			lpfc_read_sparam(phba, mbox);
+			mbox->mbox_cmpl = lpfc_mbx_cmpl_read_sparam;
+			lpfc_sli_issue_mbox
+			    (phba, mbox, (MBX_NOWAIT | MBX_STOP_IOCB));
+		}
+
+		if ((mbox = lpfc_mbox_alloc(phba, MEM_PRI))) {
+			phba->hba_state = LPFC_LOCAL_CFG_LINK;
+			lpfc_config_link(phba, mbox);
+			mbox->mbox_cmpl = lpfc_mbx_cmpl_config_link;
+			lpfc_sli_issue_mbox
+			    (phba, mbox, (MBX_NOWAIT | MBX_STOP_IOCB));
+		}
+	} else {
+		phba->fc_stat.LinkDown++;
+		/* Link Down Event <eventTag> received */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk1305,
+				lpfc_mes1305,
+				lpfc_msgBlk1305.msgPreambleStr,
+				la->eventTag, phba->fc_eventTag,
+				phba->hba_state, phba->fc_flag);
+
+		lpfc_linkdown(phba);
+
+		/* turn on Link Attention interrupts - no CLEAR_LA needed */
+		psli->sliinit.sli_flag |= LPFC_PROCESS_LA;
+		control = readl(phba->HCregaddr);
+		control |= HC_LAINT_ENA;
+		writel(control, phba->HCregaddr);
+		readl(phba->HCregaddr); /* flush */
+	}
+
+	pmb->context1 = 0;
+	lpfc_mbuf_free(phba, mp->virt, mp->phys);
+	kfree(mp);
+	lpfc_mbox_free(phba, pmb);
+	return;
+}
+
+void
+lpfc_mbx_cmpl_config_link(lpfcHBA_t * phba, LPFC_MBOXQ_t * pmb)
+{
+	LPFC_SLI_t *psli;
+	MAILBOX_t *mb;
+
+	psli = &phba->sli;
+	mb = &pmb->mb;
+	/* Check for error */
+	if (mb->mbxStatus) {
+		/* CONFIG_LINK mbox error <mbxStatus> state <hba_state> */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0306,
+				lpfc_mes0306,
+				lpfc_msgBlk0306.msgPreambleStr,
+				mb->mbxStatus, phba->hba_state);
+
+		lpfc_linkdown(phba);
+		phba->hba_state = LPFC_HBA_ERROR;
+		goto out;
+	}
+
+	if (phba->hba_state == LPFC_LOCAL_CFG_LINK) {
+
+		/* Start discovery by sending a FLOGI hba_state is identically
+		 * LPFC_FLOGI while waiting for FLOGI cmpl (same on FAN)
+		 */
+		phba->hba_state = LPFC_FLOGI;
+		lpfc_set_disctmo(phba);
+		lpfc_initial_flogi(phba);
+		lpfc_mbox_free(phba, pmb);
+		return;
+	}
+
+      out:
+	/* CONFIG_LINK bad hba state <hba_state> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0200,
+			lpfc_mes0200,
+			lpfc_msgBlk0200.msgPreambleStr, phba->hba_state);
+
+	if (phba->hba_state != LPFC_CLEAR_LA) {
+		lpfc_clear_la(phba, pmb);
+		pmb->mbox_cmpl = lpfc_mbx_cmpl_clear_la;
+		if (lpfc_sli_issue_mbox(phba, pmb, (MBX_NOWAIT | MBX_STOP_IOCB))
+		    == MBX_NOT_FINISHED) {
+			lpfc_mbox_free(phba, pmb);
+			lpfc_disc_flush_list(phba);
+			psli->ring[(psli->ip_ring)].flag &=
+				~LPFC_STOP_IOCB_EVENT;
+			psli->ring[(psli->fcp_ring)].flag &=
+				~LPFC_STOP_IOCB_EVENT;
+			psli->ring[(psli->next_ring)].flag &=
+				~LPFC_STOP_IOCB_EVENT;
+			phba->hba_state = LPFC_HBA_READY;
+		}
+	} else {
+		lpfc_mbox_free(phba, pmb);
+	}
+	return;
+}
+
+void
+lpfc_mbx_cmpl_read_sparam(lpfcHBA_t * phba, LPFC_MBOXQ_t * pmb)
+{
+	LPFC_SLI_t *psli;
+	MAILBOX_t *mb;
+	DMABUF_t *mp;
+
+	psli = &phba->sli;
+	mb = &pmb->mb;
+
+	/* Check for error */
+	if (mb->mbxStatus) {
+		/* READ_SPARAM mbox error <mbxStatus> state <hba_state> */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0319,
+				lpfc_mes0319,
+				lpfc_msgBlk0319.msgPreambleStr,
+				mb->mbxStatus, phba->hba_state);
+
+		lpfc_linkdown(phba);
+		phba->hba_state = LPFC_HBA_ERROR;
+		mp = (DMABUF_t *) pmb->context1;
+		lpfc_mbuf_free(phba, mp->virt, mp->phys);
+		kfree(mp);
+		if (phba->hba_state != LPFC_CLEAR_LA) {
+			lpfc_clear_la(phba, pmb);
+			pmb->mbox_cmpl = lpfc_mbx_cmpl_clear_la;
+			if (lpfc_sli_issue_mbox(phba, pmb, (MBX_NOWAIT | MBX_STOP_IOCB))
+				== MBX_NOT_FINISHED) {
+				lpfc_mbox_free(phba, pmb);
+				lpfc_disc_flush_list(phba);
+				psli->ring[(psli->ip_ring)].flag &=
+					~LPFC_STOP_IOCB_EVENT;
+				psli->ring[(psli->fcp_ring)].flag &=
+					~LPFC_STOP_IOCB_EVENT;
+				psli->ring[(psli->next_ring)].flag &=
+					~LPFC_STOP_IOCB_EVENT;
+				phba->hba_state = LPFC_HBA_READY;
+			}
+		} else {
+			lpfc_mbox_free(phba, pmb);
+		}
+		return;
+	}
+
+	mp = (DMABUF_t *) pmb->context1;
+
+	memcpy((uint8_t *) & phba->fc_sparam, (uint8_t *) mp->virt,
+	       sizeof (SERV_PARM));
+	memcpy((uint8_t *) & phba->fc_nodename,
+	       (uint8_t *) & phba->fc_sparam.nodeName, sizeof (NAME_TYPE));
+	memcpy((uint8_t *) & phba->fc_portname,
+	       (uint8_t *) & phba->fc_sparam.portName, sizeof (NAME_TYPE));
+	memcpy(phba->phys_addr, phba->fc_portname.IEEE, 6);
+	lpfc_mbuf_free(phba, mp->virt, mp->phys);
+	kfree(mp);
+	lpfc_mbox_free(phba, pmb);
+	return;
+}
+
+/*
+ * This routine handles processing a CLEAR_LA mailbox
+ * command upon completion. It is setup in the LPFC_MBOXQ
+ * as the completion routine when the command is
+ * handed off to the SLI layer.
+ */
+void
+lpfc_mbx_cmpl_clear_la(lpfcHBA_t * phba, LPFC_MBOXQ_t * pmb)
+{
+	lpfcCfgParam_t *clp;
+	LPFC_SLI_t *psli;
+	LPFC_NODELIST_t *ndlp;
+	struct list_head *pos;
+	MAILBOX_t *mb;
+	uint32_t control;
+
+	psli = &phba->sli;
+	clp = &phba->config[0];
+	mb = &pmb->mb;
+	/* Since we don't do discovery right now, turn these off here */
+	psli->ring[psli->ip_ring].flag &= ~LPFC_STOP_IOCB_EVENT;
+	psli->ring[psli->fcp_ring].flag &= ~LPFC_STOP_IOCB_EVENT;
+	psli->ring[psli->next_ring].flag &= ~LPFC_STOP_IOCB_EVENT;
+	/* Check for error */
+	if ((mb->mbxStatus) && (mb->mbxStatus != 0x1601)) {
+		/* CLEAR_LA mbox error <mbxStatus> state <hba_state> */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0320,
+				lpfc_mes0320,
+				lpfc_msgBlk0320.msgPreambleStr,
+				mb->mbxStatus, phba->hba_state);
+
+		phba->hba_state = LPFC_HBA_ERROR;
+		goto out;
+	}
+
+	phba->num_disc_nodes = 0;
+	/* go thru PLOGI list and issue ELS PLOGIs */
+	if (phba->fc_plogi_cnt) {
+		list_for_each(pos, &phba->fc_plogi_list) {
+			ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			if (ndlp->nlp_state == NLP_STE_UNUSED_NODE) {
+				ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+				lpfc_issue_els_plogi(phba, ndlp, 0);
+				ndlp->nlp_flag |= NLP_DISC_NODE;
+				phba->num_disc_nodes++;
+				if (phba->num_disc_nodes >=
+				    clp[LPFC_CFG_DISC_THREADS].a_current) {
+					if (phba->fc_plogi_cnt >
+					    phba->num_disc_nodes)
+						phba->fc_flag |= FC_NLP_MORE;
+					break;
+				}
+			}
+		}
+	}
+	if (phba->num_disc_nodes == 0) {
+		phba->hba_flag &= ~FC_NDISC_ACTIVE;
+	}
+	phba->hba_state = LPFC_HBA_READY;
+
+      out:
+	/* Device Discovery completes */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0225,
+			lpfc_mes0225, lpfc_msgBlk0225.msgPreambleStr);
+
+	phba->hba_flag &= ~FC_LFR_ACTIVE;
+
+	lpfc_mbox_free(phba, pmb);
+	if (phba->fc_flag & FC_ESTABLISH_LINK) {
+		phba->fc_flag &= ~FC_ESTABLISH_LINK;
+	}
+	if (phba->fc_estabtmo.function) {
+		lpfc_stop_timer((struct clk_data *)phba->fc_estabtmo.data);
+	}
+	lpfc_can_disctmo(phba);
+
+	/* turn on Link Attention interrupts */
+	psli->sliinit.sli_flag |= LPFC_PROCESS_LA;
+	control = readl(phba->HCregaddr);
+	control |= HC_LAINT_ENA;
+	writel(control, phba->HCregaddr);
+	readl(phba->HCregaddr); /* flush */
+
+	/* If there are mapped FCP nodes still running, restart the scheduler 
+	 * to get any pending IOCBs out.
+	 */
+	if (phba->fc_map_cnt) {
+		lpfc_sched_check(phba);
+	}
+	return;
+}
+
+/*
+ * This routine handles processing a REG_LOGIN mailbox
+ * command upon completion. It is setup in the LPFC_MBOXQ
+ * as the completion routine when the command is
+ * handed off to the SLI layer.
+ */
+void
+lpfc_mbx_cmpl_reg_login(lpfcHBA_t * phba, LPFC_MBOXQ_t * pmb)
+{
+	LPFC_SLI_t *psli;
+	MAILBOX_t *mb;
+	DMABUF_t *mp;
+	LPFC_NODELIST_t *ndlp;
+
+	psli = &phba->sli;
+	mb = &pmb->mb;
+
+	ndlp = (LPFC_NODELIST_t *) pmb->context2;
+	mp = (DMABUF_t *) (pmb->context1);
+
+	pmb->context1 = 0;
+
+	/* Good status, call state machine */
+	lpfc_disc_state_machine(phba, ndlp, pmb, NLP_EVT_CMPL_REG_LOGIN);
+	lpfc_mbuf_free(phba, mp->virt, mp->phys);
+	kfree(mp);
+	lpfc_mbox_free(phba, pmb);
+
+	return;
+}
+
+/*
+ * This routine handles processing a Fabric REG_LOGIN mailbox
+ * command upon completion. It is setup in the LPFC_MBOXQ
+ * as the completion routine when the command is
+ * handed off to the SLI layer.
+ */
+void
+lpfc_mbx_cmpl_fabric_reg_login(lpfcHBA_t * phba, LPFC_MBOXQ_t * pmb)
+{
+	LPFC_SLI_t *psli;
+	MAILBOX_t *mb;
+	DMABUF_t *mp;
+	LPFC_NODELIST_t *ndlp;
+	LPFC_NODELIST_t *ndlp_fdmi;
+	lpfcCfgParam_t *clp;
+
+	clp = &phba->config[0];
+
+	psli = &phba->sli;
+	mb = &pmb->mb;
+
+	ndlp = (LPFC_NODELIST_t *) pmb->context2;
+	mp = (DMABUF_t *) (pmb->context1);
+
+	pmb->context1 = 0;
+
+	ndlp->nlp_rpi = mb->un.varWords[0];
+	ndlp->nlp_type |= NLP_FABRIC;
+	lpfc_nlp_unmapped(phba, ndlp);
+	ndlp->nlp_state = NLP_STE_PRLI_COMPL;
+
+	if (phba->hba_state == LPFC_FABRIC_CFG_LINK) {
+		/* This NPort has been assigned an NPort_ID by the fabric as a
+		 * result of the completed fabric login.  Issue a State Change
+		 * Registration (SCR) ELS request to the fabric controller
+		 * (SCR_DID) so that this NPort gets RSCN events from the
+		 * fabric.
+		 */
+		lpfc_issue_els_scr(phba, SCR_DID, 0);
+
+		/* Allocate a new node instance.  If the pool is empty, just
+		 * start the discovery process and skip the Nameserver login
+		 * process.  This is attempted again later on.  Otherwise, issue
+		 * a Port Login (PLOGI) to the NameServer
+		 */
+		if ((ndlp = lpfc_nlp_alloc(phba, 0)) == 0) {
+			lpfc_disc_start(phba);
+		} else {
+			memset(ndlp, 0, sizeof (LPFC_NODELIST_t));
+			ndlp->nlp_type |= NLP_FABRIC;
+			ndlp->nlp_DID = NameServer_DID;
+			ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+			lpfc_issue_els_plogi(phba, ndlp, 0);
+			if (clp[LPFC_CFG_FDMI_ON].a_current) {
+				if ((ndlp_fdmi = lpfc_nlp_alloc(phba, 0))) {
+					memset(ndlp_fdmi, 0,
+					       sizeof (LPFC_NODELIST_t));
+					ndlp_fdmi->nlp_type |= NLP_FABRIC;
+					ndlp_fdmi->nlp_DID = FDMI_DID;
+					ndlp_fdmi->nlp_state =
+					    NLP_STE_PLOGI_ISSUE;
+					lpfc_issue_els_plogi(phba, ndlp_fdmi,
+							     0);
+				}
+			}
+		}
+	}
+
+	lpfc_mbuf_free(phba, mp->virt, mp->phys);
+	kfree(mp);
+	lpfc_mbox_free(phba, pmb);
+
+	return;
+}
+
+/*
+ * This routine handles processing a NameServer REG_LOGIN mailbox
+ * command upon completion. It is setup in the LPFC_MBOXQ
+ * as the completion routine when the command is
+ * handed off to the SLI layer.
+ */
+void
+lpfc_mbx_cmpl_ns_reg_login(lpfcHBA_t * phba, LPFC_MBOXQ_t * pmb)
+{
+	LPFC_SLI_t *psli;
+	MAILBOX_t *mb;
+	DMABUF_t *mp;
+	LPFC_NODELIST_t *ndlp;
+
+	psli = &phba->sli;
+	mb = &pmb->mb;
+
+	ndlp = (LPFC_NODELIST_t *) pmb->context2;
+	mp = (DMABUF_t *) (pmb->context1);
+
+	pmb->context1 = 0;
+	ndlp->nlp_rpi = mb->un.varWords[0];
+	ndlp->nlp_type |= NLP_FABRIC;
+	lpfc_nlp_unmapped(phba, ndlp);
+	ndlp->nlp_state = NLP_STE_PRLI_COMPL;
+
+	if (phba->hba_state < LPFC_HBA_READY) {
+		/* Link up discovery requires Fabrib registration. */
+		lpfc_ns_cmd(phba, ndlp, SLI_CTNS_RNN_ID);
+		lpfc_ns_cmd(phba, ndlp, SLI_CTNS_RSNN_NN);
+		lpfc_ns_cmd(phba, ndlp, SLI_CTNS_RFT_ID);
+	}
+
+	phba->fc_ns_retry = 0;
+	/* Good status, issue CT Request to NameServer */
+	if (lpfc_ns_cmd(phba, ndlp, SLI_CTNS_GID_FT)) {
+		/* Cannot issue NameServer Query, so finish up discovery */
+		lpfc_disc_start(phba);
+	}
+
+	lpfc_mbuf_free(phba, mp->virt, mp->phys);
+	kfree(mp);
+	lpfc_mbox_free(phba, pmb);
+
+	return;
+}
+
+/*
+ * Start / ReStart npr timer for Discovery / RSCN handling
+ */
+void
+lpfc_set_npr_tmo(lpfcHBA_t * phba, LPFCSCSITARGET_t *targetp,
+		LPFC_NODELIST_t * nlp)
+{
+	uint32_t tmo;
+	lpfcCfgParam_t *clp;
+
+	if(targetp->targetFlags & FC_NPR_ACTIVE)
+		return;
+
+	clp = &phba->config[0];
+	targetp->targetFlags |= FC_NPR_ACTIVE;
+	if(clp[LPFC_CFG_HOLDIO].a_current == 0){
+		tmo = clp[LPFC_CFG_NODEV_TMO].a_current;
+
+		if (( phba->fc_flag & FC_LNK_DOWN) &&
+		   (clp[LPFC_CFG_NODEV_TMO].a_current <
+		    clp[LPFC_CFG_LINKDOWN_TMO].a_current)) {
+			tmo = clp[LPFC_CFG_LINKDOWN_TMO].a_current;
+		}
+		lpfc_start_timer(phba, tmo, &targetp->tmofunc,
+			 lpfc_npr_timeout, (unsigned long)targetp, 0);
+
+ 		/* Start nodev timer */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0256,
+				lpfc_mes0256,
+				lpfc_msgBlk0256.msgPreambleStr,
+				nlp->nlp_DID, nlp->nlp_flag, nlp->nlp_state,
+				nlp->nlp_sid);
+	}
+	return;
+}
+
+/*
+ * Cancel npr timer for Discovery / RSCN handling
+ */
+int
+lpfc_can_npr_tmo(lpfcHBA_t * phba, LPFCSCSITARGET_t *targetp,
+		LPFC_NODELIST_t * nlp)
+{
+	int rc;
+
+	rc = 0;
+
+	targetp->targetFlags &= ~FC_NPR_ACTIVE;
+	if(targetp->tmofunc.function) {
+		lpfc_stop_timer((struct clk_data *) targetp->tmofunc.data);
+		rc = 1;
+	}
+
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0260,
+			lpfc_mes0260,
+			lpfc_msgBlk0260.msgPreambleStr,
+			nlp->nlp_DID, nlp->nlp_flag, nlp->nlp_state,
+			nlp->nlp_sid);
+	return (rc);
+}
+
+/* Put blp on the bind list */
+int
+lpfc_nlp_bind(lpfcHBA_t * phba, LPFC_BINDLIST_t * blp)
+{
+	LPFCSCSITARGET_t *targetp;
+
+	/* Put it at the end of the bind list */
+	list_add_tail(&blp->nlp_listp, &phba->fc_nlpbind_list);
+	phba->fc_bind_cnt++;
+	targetp = phba->device_queue_hash[blp->nlp_sid];
+
+	/* Add scsiid <sid> to BIND list */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0903,
+			lpfc_mes0903,
+			lpfc_msgBlk0903.msgPreambleStr,
+			blp->nlp_sid, phba->fc_bind_cnt, blp->nlp_DID,
+			blp->nlp_bind_type, (unsigned long)blp);
+
+	return (0);
+}
+
+/* Put blp on the plogi list */
+int
+lpfc_nlp_plogi(lpfcHBA_t * phba, LPFC_NODELIST_t * nlp)
+{
+	LPFC_BINDLIST_t *blp;
+	LPFC_SLI_t *psli;
+
+	psli = &phba->sli;
+	blp = 0;
+
+	/* Check to see if this node exists on any other list */
+	if (nlp->nlp_flag & NLP_LIST_MASK) {
+		if (nlp->nlp_flag & NLP_MAPPED_LIST) {
+			nlp->nlp_flag &= ~NLP_MAPPED_LIST;
+			phba->fc_map_cnt--;
+			list_del(&nlp->nlp_listp);
+			phba->nport_event_cnt++;
+
+			/* Must call before binding is removed */
+			lpfc_set_failmask(phba, nlp, LPFC_DEV_DISCONNECTED,
+					  LPFC_SET_BITMASK);
+
+			blp = nlp->nlp_listp_bind;
+			if (blp) {
+				blp->nlp_Target = nlp->nlp_Target;
+				nlp->nlp_listp_bind = 0;
+				nlp->nlp_sid = 0;
+				nlp->nlp_flag &= ~NLP_SEED_MASK;
+			}
+			if(nlp->nlp_Target)
+				lpfc_set_npr_tmo(phba, nlp->nlp_Target, nlp);
+
+		} else if (nlp->nlp_flag & NLP_UNMAPPED_LIST) {
+			nlp->nlp_flag &=
+			    ~(NLP_UNMAPPED_LIST | NLP_TGT_NO_SCSIID);
+			phba->fc_unmap_cnt--;
+			list_del(&nlp->nlp_listp);
+			phba->nport_event_cnt++;
+
+		} else if (nlp->nlp_flag & NLP_PLOGI_LIST) {
+			return (0);	/* Already on plogi list */
+		} else if (nlp->nlp_flag & NLP_ADISC_LIST) {
+			nlp->nlp_flag &= ~NLP_ADISC_LIST;
+			phba->fc_adisc_cnt--;
+			list_del(&nlp->nlp_listp);
+		}
+	}
+
+	/* Put it at the end of the plogi list */
+	list_add_tail(&nlp->nlp_listp, &phba->fc_plogi_list);
+	phba->fc_plogi_cnt++;
+	nlp->nlp_flag |= NLP_PLOGI_LIST;
+
+	/* Add NPort <did> to PLOGI list */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0904,
+			lpfc_mes0904,
+			lpfc_msgBlk0904.msgPreambleStr,
+			nlp->nlp_DID, phba->fc_plogi_cnt, (unsigned long)blp);
+
+	if (blp) {
+		lpfc_nlp_bind(phba, blp);
+	}
+	return (0);
+}
+
+/* Put nlp on the adisc list */
+int
+lpfc_nlp_adisc(lpfcHBA_t * phba, LPFC_NODELIST_t * nlp)
+{
+	LPFC_BINDLIST_t *blp;
+	LPFC_SLI_t *psli;
+	LPFCSCSITARGET_t *targetp;
+	lpfcCfgParam_t *clp;
+
+	blp = 0;
+	psli = &phba->sli;
+	clp = &phba->config[0];
+	targetp = nlp->nlp_Target;
+
+	/* Check to see if this node exist on any other list */
+	if (nlp->nlp_flag & NLP_LIST_MASK) {
+		if (nlp->nlp_flag & NLP_MAPPED_LIST) {
+			nlp->nlp_flag &= ~NLP_MAPPED_LIST;
+			phba->fc_map_cnt--;
+			list_del(&nlp->nlp_listp);
+			phba->nport_event_cnt++;
+
+			/* Must call before binding is removed */
+			lpfc_set_failmask(phba, nlp, LPFC_DEV_DISAPPEARED,
+					  LPFC_SET_BITMASK);
+
+			blp = nlp->nlp_listp_bind;
+			if (blp) {
+				blp->nlp_Target = nlp->nlp_Target;
+				nlp->nlp_listp_bind = 0;
+				nlp->nlp_flag &= ~NLP_SEED_MASK;
+			}
+			if(nlp->nlp_Target)
+				lpfc_set_npr_tmo(phba, nlp->nlp_Target, nlp);
+
+		} else if (nlp->nlp_flag & NLP_UNMAPPED_LIST) {
+			nlp->nlp_flag &=
+			    ~(NLP_UNMAPPED_LIST | NLP_TGT_NO_SCSIID);
+			phba->fc_unmap_cnt--;
+			list_del(&nlp->nlp_listp);
+			phba->nport_event_cnt++;
+
+
+		} else if (nlp->nlp_flag & NLP_PLOGI_LIST) {
+			nlp->nlp_flag &= ~NLP_PLOGI_LIST;
+			phba->fc_plogi_cnt--;
+			list_del(&nlp->nlp_listp);
+		} else if (nlp->nlp_flag & NLP_ADISC_LIST) {
+			return (0);	/* Already on adisc list */
+		}
+	}
+
+	/* Put it at the end of the adisc list */
+	list_add_tail(&nlp->nlp_listp, &phba->fc_adisc_list);
+	phba->fc_adisc_cnt++;
+	nlp->nlp_flag |= NLP_ADISC_LIST;
+
+	/* Add NPort <did> to ADISC list */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0905,
+			lpfc_mes0905,
+			lpfc_msgBlk0905.msgPreambleStr,
+			nlp->nlp_DID, phba->fc_adisc_cnt, (unsigned long)blp);
+
+	if (blp) {
+		lpfc_nlp_bind(phba, blp);
+	}
+
+	return (0);
+}
+
+/*
+ * Put nlp on the unmapped list 
+ * NOTE: - update nlp_type to NLP_FC_NODE
+ */
+int
+lpfc_nlp_unmapped(lpfcHBA_t * phba, LPFC_NODELIST_t * nlp)
+{
+	LPFC_BINDLIST_t *blp;
+
+	blp = 0;
+
+	/* Check to see if this node exists on any other list */
+	if (nlp->nlp_flag & NLP_LIST_MASK) {
+		if (nlp->nlp_flag & NLP_MAPPED_LIST) {
+			nlp->nlp_flag &= ~NLP_MAPPED_LIST;
+			phba->fc_map_cnt--;
+			list_del(&nlp->nlp_listp);
+
+			/* Must call before binding is removed */
+			lpfc_set_failmask(phba, nlp, LPFC_DEV_DISAPPEARED,
+					  LPFC_SET_BITMASK);
+
+			blp = nlp->nlp_listp_bind;
+			if (blp) {
+				blp->nlp_Target = nlp->nlp_Target;
+				nlp->nlp_listp_bind = 0;
+				nlp->nlp_sid = 0;
+				nlp->nlp_flag &= ~NLP_SEED_MASK;
+			}
+			if(nlp->nlp_Target)
+				lpfc_set_npr_tmo(phba, nlp->nlp_Target, nlp);
+
+		} else if (nlp->nlp_flag & NLP_UNMAPPED_LIST) {
+			return (0);	/* Already on unmapped list */
+		} else if (nlp->nlp_flag & NLP_PLOGI_LIST) {
+			nlp->nlp_flag &= ~NLP_PLOGI_LIST;
+			phba->fc_plogi_cnt--;
+			list_del(&nlp->nlp_listp);
+		} else if (nlp->nlp_flag & NLP_ADISC_LIST) {
+			nlp->nlp_flag &= ~NLP_ADISC_LIST;
+			phba->fc_adisc_cnt--;
+			list_del(&nlp->nlp_listp);
+		}
+	}
+
+	/* Put it at the end of the unmapped list */
+	list_add_tail(&nlp->nlp_listp, &phba->fc_nlpunmap_list);
+	phba->nport_event_cnt++;
+	phba->fc_unmap_cnt++;
+	nlp->nlp_type |= NLP_FC_NODE;
+	nlp->nlp_flag |= NLP_UNMAPPED_LIST;
+
+	/* Add NPort <did> to UNMAP list */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0906,
+			lpfc_mes0906,
+			lpfc_msgBlk0906.msgPreambleStr,
+			nlp->nlp_DID, phba->fc_unmap_cnt, (unsigned long)blp);
+
+	if (blp) {
+		lpfc_nlp_bind(phba, blp);
+	}
+	return (0);
+}
+
+/*
+ * Put nlp on the mapped list 
+ * NOTE: - update nlp_type to NLP_FCP_TARGET
+ *       - attach binding entry to context2 
+ */
+int
+lpfc_nlp_mapped(lpfcHBA_t * phba, LPFC_NODELIST_t * nlp, LPFC_BINDLIST_t * blp)
+{
+	LPFCSCSITARGET_t *targetp;
+	LPFCSCSILUN_t *lunp;
+	struct list_head *curr, *next;
+
+	/* Check to see if this node exists on any other list */
+	if (nlp->nlp_flag & NLP_LIST_MASK) {
+		if (nlp->nlp_flag & NLP_MAPPED_LIST) {
+			return (0);	/* Already on mapped list */
+		} else if (nlp->nlp_flag & NLP_UNMAPPED_LIST) {
+			nlp->nlp_flag &=
+			    ~(NLP_UNMAPPED_LIST | NLP_TGT_NO_SCSIID);
+			phba->fc_unmap_cnt--;
+			list_del(&nlp->nlp_listp);
+		} else if (nlp->nlp_flag & NLP_PLOGI_LIST) {
+			nlp->nlp_flag &= ~NLP_PLOGI_LIST;
+			phba->fc_plogi_cnt--;
+			list_del(&nlp->nlp_listp);
+		} else if (nlp->nlp_flag & NLP_ADISC_LIST) {
+			nlp->nlp_flag &= ~NLP_ADISC_LIST;
+			phba->fc_adisc_cnt--;
+			list_del(&nlp->nlp_listp);
+		}
+	}
+
+	/* Put it at the end of the mapped list */
+	list_add_tail(&nlp->nlp_listp, &phba->fc_nlpmap_list);
+	phba->nport_event_cnt++;
+	phba->fc_map_cnt++;
+	nlp->nlp_flag |= NLP_MAPPED_LIST;
+	nlp->nlp_type |= NLP_FCP_TARGET;
+	nlp->nlp_sid = blp->nlp_sid;
+	nlp->nlp_listp_bind = blp;
+	targetp = phba->device_queue_hash[nlp->nlp_sid];
+
+	/* Add NPort <did> to MAPPED list scsiid <sid> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0907,
+			lpfc_mes0907,
+			lpfc_msgBlk0907.msgPreambleStr,
+			nlp->nlp_DID, nlp->nlp_sid, phba->fc_map_cnt,
+			(unsigned long)blp);
+
+	if(nlp->nlp_tmofunc.function) {
+		nlp->nlp_flag &= ~NLP_DELAY_TMO;
+		lpfc_stop_timer((struct clk_data *)nlp->nlp_tmofunc.data);
+	}
+	if (targetp) {
+		lpfc_can_npr_tmo(phba, targetp, nlp);
+		blp->nlp_Target = targetp;
+		nlp->nlp_Target = targetp;
+		targetp->pcontext = nlp;
+		lpfc_scsi_assign_rpi(phba, targetp, nlp->nlp_rpi);
+		targetp->un.dev_did = nlp->nlp_DID;
+		list_for_each_safe(curr, next, &targetp->lunlist) {
+			lunp = list_entry(curr, LPFCSCSILUN_t, list);
+			lunp->pnode = (LPFC_NODELIST_t *) nlp;
+		}
+	}
+
+	return (0);
+}
+
+/*
+ * Start / ReStart rescue timer for Discovery / RSCN handling
+ */
+void
+lpfc_set_disctmo(lpfcHBA_t * phba)
+{
+	uint32_t tmo;
+
+	/* lpfc_prep_els_iocb adds LPFC_DRVR_TIMEOUT, so we must here as well */
+	tmo = (phba->fc_ratov << 1) + LPFC_DRVR_TIMEOUT + 1;
+
+	/* Turn off discovery timer if its running */
+	if (phba->fc_disctmo.function) {
+		lpfc_stop_timer((struct clk_data *)phba->fc_disctmo.data);
+	}
+	lpfc_start_timer(phba, tmo, &phba->fc_disctmo, lpfc_disc_timeout,
+			 (unsigned long)0, (unsigned long)0);
+
+	/* Start Discovery Timer state <hba_state> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0247,
+			lpfc_mes0247,
+			lpfc_msgBlk0247.msgPreambleStr,
+			phba->hba_state, tmo, (unsigned long)&phba->fc_disctmo,
+			phba->fc_plogi_cnt, phba->fc_adisc_cnt);
+
+	return;
+}
+
+/*
+ * Cancel rescue timer for Discovery / RSCN handling
+ */
+int
+lpfc_can_disctmo(lpfcHBA_t * phba)
+{
+	int rc;
+
+	rc = 0;
+
+	/* Turn off discovery timer if its running */
+	if (phba->fc_disctmo.function) {
+		lpfc_stop_timer((struct clk_data *)phba->fc_disctmo.data);
+		rc = 1;
+	}
+
+	/* Cancel Discovery Timer state <hba_state> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0248,
+			lpfc_mes0248,
+			lpfc_msgBlk0248.msgPreambleStr,
+			phba->hba_state, phba->fc_flag, rc, phba->fc_plogi_cnt,
+			phba->fc_adisc_cnt);
+
+	return (rc);
+}
+
+/*
+ * Check specified ring for outstanding IOCB on the SLI queue
+ * Return true if iocb matches the specified nport
+ */
+int
+lpfc_check_sli_ndlp(lpfcHBA_t * phba,
+		    LPFC_SLI_RING_t * pring,
+		    LPFC_IOCBQ_t * iocb, LPFC_NODELIST_t * ndlp)
+{
+	LPFC_SLI_t *psli;
+	IOCB_t *icmd;
+
+	psli = &phba->sli;
+	icmd = &iocb->iocb;
+	if (pring->ringno == LPFC_ELS_RING) {
+		switch (icmd->ulpCommand) {
+		case CMD_GEN_REQUEST64_CR:
+			if (icmd->ulpContext == (volatile ushort)ndlp->nlp_rpi)
+				return (1);
+		case CMD_ELS_REQUEST64_CR:
+		case CMD_XMIT_ELS_RSP64_CX:
+			if (iocb->context1 == (uint8_t *) ndlp)
+				return (1);
+		}
+	} else if (pring->ringno == psli->ip_ring) {
+
+	} else if (pring->ringno == psli->fcp_ring) {
+		/* Skip match check if waiting to relogin to FCP target */
+	  	if((ndlp->nlp_type & NLP_FCP_TARGET) &&
+	  	  (ndlp->nlp_tmofunc.function) &&
+		  (ndlp->nlp_flag & NLP_DELAY_TMO)) {
+			return (0);
+		}
+		if (icmd->ulpContext == (volatile ushort)ndlp->nlp_rpi) {
+			return (1);
+		}
+	} else if (pring->ringno == psli->next_ring) {
+
+	}
+	return (0);
+}
+
+/*
+ * Free resources / clean up outstanding I/Os
+ * associated with nlp_rpi in the LPFC_NODELIST entry.
+ */
+int
+lpfc_no_rpi(lpfcHBA_t * phba, LPFC_NODELIST_t * ndlp)
+{
+	LPFC_SLI_t *psli;
+	LPFC_SLI_RING_t *pring;
+	LPFC_IOCBQ_t *iocb, *next_iocb;
+	IOCB_t *icmd;
+	uint32_t rpi, i;
+	struct list_head *curr, *next;
+
+	psli = &phba->sli;
+	rpi = ndlp->nlp_rpi;
+	if (rpi) {
+		/* Now process each ring */
+		for (i = 0; i < psli->sliinit.num_rings; i++) {
+			pring = &psli->ring[i];
+
+			list_for_each_safe(curr, next, &pring->txq) {
+				next_iocb = list_entry(curr, LPFC_IOCBQ_t,
+						       list);
+				iocb = next_iocb;
+				/* Check to see if iocb matches the nport we are
+				   looking for */
+				if ((lpfc_check_sli_ndlp
+				     (phba, pring, iocb, ndlp))) {
+					/* It matches, so deque and call compl
+					   with an error */
+					list_del(&iocb->list);
+					pring->txq_cnt--;
+					if (iocb->iocb_cmpl) {
+						icmd = &iocb->iocb;
+						icmd->ulpStatus =
+						    IOSTAT_LOCAL_REJECT;
+						icmd->un.ulpWord[4] =
+						    IOERR_SLI_ABORTED;
+						(iocb->iocb_cmpl) (phba,
+								   iocb, iocb);
+					} else {
+						lpfc_iocb_free(phba, iocb);
+					}
+				}
+			}
+			/* Everything that matches on txcmplq will be returned
+			 * by firmware with a no rpi error.
+			 */
+		}
+	}
+	return (0);
+}
+
+/*
+ * Free resources / clean up outstanding I/Os
+ * associated with a brand new rpi.
+ */
+int
+lpfc_new_rpi(lpfcHBA_t * phba, uint16_t rpi)
+{
+	LPFC_SLI_t *psli;
+	LPFC_SLI_RING_t *pring;
+	LPFC_IOCBQ_t *iocb, *next_iocb;
+	IOCB_t *icmd;
+	struct list_head *curr, *next;
+
+	if (rpi) {
+		psli = &phba->sli;
+		pring = &psli->ring[psli->fcp_ring];
+
+		list_for_each_safe(curr, next, &pring->txq) {
+			next_iocb = list_entry(curr, LPFC_IOCBQ_t,
+						       list);
+			iocb = next_iocb;
+			icmd = &iocb->iocb;
+			if (icmd->ulpContext == (volatile ushort)rpi) {
+				/* It matches, so deque and call compl
+				   with an error */
+				list_del(&iocb->list);
+				pring->txq_cnt--;
+				if (iocb->iocb_cmpl) {
+					icmd->ulpStatus =
+					    IOSTAT_LOCAL_REJECT;
+					icmd->un.ulpWord[4] =
+					    IOERR_SLI_ABORTED;
+					(iocb->iocb_cmpl) (phba,
+							   iocb, iocb);
+				} else {
+					lpfc_iocb_free(phba, iocb);
+				}
+			}
+		}
+	}
+	return (0);
+}
+
+/*
+ * Free resources / clean up outstanding I/Os
+ * associated with a LPFC_NODELIST entry. This
+ * routine effectively results in a "software abort".
+ */
+int
+lpfc_driver_abort(lpfcHBA_t * phba, LPFC_NODELIST_t * ndlp)
+{
+	LPFC_SLI_t *psli;
+	LPFC_SLI_RING_t *pring;
+	LPFC_IOCBQ_t *iocb, *next_iocb;
+	IOCB_t *icmd;
+	struct clk_data *clkData;
+	uint32_t i, cmd;
+	struct list_head *curr, *next;
+
+	/* Abort outstanding I/O on NPort <nlp_DID> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0201,
+			lpfc_mes0201,
+			lpfc_msgBlk0201.msgPreambleStr,
+			ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,
+			ndlp->nlp_rpi);
+
+	psli = &phba->sli;
+	/* Now process each ring */
+	for (i = 0; i < psli->sliinit.num_rings; i++) {
+		pring = &psli->ring[i];
+
+		/* First check the txq */
+		list_for_each_safe(curr, next, &pring->txq) {
+			next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+			iocb = next_iocb;
+			/* Check to see if iocb matches the nport we are looking
+			   for */
+			if ((lpfc_check_sli_ndlp(phba, pring, iocb, ndlp))) {
+				/* It matches, so deque and call compl with an
+				   error */
+				list_del(&iocb->list);
+				pring->txq_cnt--;
+				if (iocb->iocb_cmpl) {
+					icmd = &iocb->iocb;
+					icmd->ulpStatus = IOSTAT_LOCAL_REJECT;
+					icmd->un.ulpWord[4] = IOERR_SLI_ABORTED;
+					(iocb->iocb_cmpl) (phba, iocb, iocb);
+				} else {
+					lpfc_iocb_free(phba, iocb);
+				}
+			}
+		}
+		/* Everything on txcmplq will be returned by firmware with a no
+		 * rpi / linkdown / abort error.  For ring 0, ELS discovery, we
+		 * want to get rid of it right here.
+		 */
+		if (pring->ringno == LPFC_ELS_RING) {
+			/* Next check the txcmplq */
+			list_for_each_safe(curr, next, &pring->txcmplq) {
+				next_iocb =
+				    list_entry(curr, LPFC_IOCBQ_t, list);
+				iocb = next_iocb;
+				/* Check to see if iocb matches the nport we are
+				   looking for */
+				if ((lpfc_check_sli_ndlp
+				     (phba, pring, iocb, ndlp))) {
+					/* It matches, so deque and call compl
+					   with an error */
+					list_del(&iocb->list);
+					pring->txcmplq_cnt--;
+
+					icmd = &iocb->iocb;
+					/* If the driver is completing an ELS
+					 * command early, flush it out of the
+					 * firmware.
+					 */
+					if ((icmd->ulpCommand ==
+					     CMD_ELS_REQUEST64_CR)
+					    && (icmd->un.elsreq64.bdl.
+						ulpIoTag32)) {
+						lpfc_sli_issue_abort_iotag32
+						    (phba, pring, iocb);
+					}
+					if (iocb->iocb_cmpl) {
+						icmd->ulpStatus =
+						    IOSTAT_LOCAL_REJECT;
+						icmd->un.ulpWord[4] =
+						    IOERR_SLI_ABORTED;
+						(iocb->iocb_cmpl) (phba,
+								   iocb, iocb);
+					} else {
+						lpfc_iocb_free(phba, iocb);
+					}
+				}
+			}
+		}
+	}
+
+	/* If we are delaying issuing an ELS command, cancel it */
+	if ((ndlp->nlp_tmofunc.function) && (ndlp->nlp_flag & NLP_DELAY_TMO)) {
+		ndlp->nlp_flag &= ~NLP_DELAY_TMO;
+		clkData = (struct clk_data *)(ndlp->nlp_tmofunc.data);
+		cmd = (uint32_t) (unsigned long)clkData->clData2;
+		lpfc_stop_timer((struct clk_data *)ndlp->nlp_tmofunc.data);
+
+		/* Allocate an IOCB and indicate an error completion */
+		/* Allocate a buffer for the command iocb */
+		if ((iocb = lpfc_iocb_alloc(phba, MEM_PRI)) == 0) {
+			return (0);
+		}
+		memset(iocb, 0, sizeof (LPFC_IOCBQ_t));
+		icmd = &iocb->iocb;
+		icmd->ulpStatus = IOSTAT_LOCAL_REJECT;
+		icmd->un.ulpWord[4] = IOERR_SLI_ABORTED;
+		iocb->context1 = ndlp;
+
+		switch (cmd) {
+		case ELS_CMD_FLOGI:
+			iocb->iocb_cmpl = lpfc_cmpl_els_flogi;
+			break;
+		case ELS_CMD_PLOGI:
+			iocb->iocb_cmpl = lpfc_cmpl_els_plogi;
+			break;
+		case ELS_CMD_ADISC:
+			iocb->iocb_cmpl = lpfc_cmpl_els_adisc;
+			break;
+		case ELS_CMD_PRLI:
+			iocb->iocb_cmpl = lpfc_cmpl_els_prli;
+			break;
+		case ELS_CMD_LOGO:
+			iocb->iocb_cmpl = lpfc_cmpl_els_logo;
+			break;
+		default:
+			iocb->iocb_cmpl = lpfc_cmpl_els_cmd;
+			break;
+		}
+		(iocb->iocb_cmpl) (phba, iocb, iocb);
+	}
+	return (0);
+}
+
+void
+lpfc_dequenode(lpfcHBA_t * phba, LPFC_NODELIST_t * ndlp)
+{
+	LPFC_BINDLIST_t *blp;
+
+	if (ndlp->nlp_flag & NLP_LIST_MASK) {
+		if (ndlp->nlp_flag & NLP_MAPPED_LIST) {
+			ndlp->nlp_flag &= ~NLP_MAPPED_LIST;
+			phba->fc_map_cnt--;
+			list_del(&ndlp->nlp_listp);
+			phba->nport_event_cnt++;
+			blp = ndlp->nlp_listp_bind;
+			ndlp->nlp_listp_bind = 0;
+			if (blp) {
+				blp->nlp_Target = ndlp->nlp_Target;
+				lpfc_nlp_bind(phba, blp);
+			}
+			ndlp->nlp_flag &= ~NLP_SEED_MASK;
+		} else if (ndlp->nlp_flag & NLP_UNMAPPED_LIST) {
+			ndlp->nlp_flag &= ~NLP_UNMAPPED_LIST;
+			phba->fc_unmap_cnt--;
+			list_del(&ndlp->nlp_listp);
+			phba->nport_event_cnt++;
+		} else if (ndlp->nlp_flag & NLP_PLOGI_LIST) {
+			ndlp->nlp_flag &= ~NLP_PLOGI_LIST;
+			phba->fc_plogi_cnt--;
+			list_del(&ndlp->nlp_listp);
+		} else if (ndlp->nlp_flag & NLP_ADISC_LIST) {
+			ndlp->nlp_flag &= ~NLP_ADISC_LIST;
+			phba->fc_adisc_cnt--;
+			list_del(&ndlp->nlp_listp);
+		}
+	}
+	return;
+}
+
+/*
+ * Free resources associated with LPFC_NODELIST entry
+ * so it can be freed.
+ */
+int
+lpfc_freenode(lpfcHBA_t * phba, LPFC_NODELIST_t * ndlp)
+{
+	LPFC_MBOXQ_t *mbox;
+	LPFC_SLI_t *psli;
+
+	/* The psli variable gets rid of the long pointer deference. */
+	psli = &phba->sli;
+
+	/* Cleanup node for NPort <nlp_DID> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0900,
+			lpfc_mes0900,
+			lpfc_msgBlk0900.msgPreambleStr,
+			ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,
+			ndlp->nlp_rpi);
+
+	lpfc_dequenode(phba, ndlp);
+
+	if (ndlp->nlp_tmofunc.function) {
+		lpfc_stop_timer((struct clk_data *)ndlp->nlp_tmofunc.data);
+		ndlp->nlp_flag &= ~NLP_DELAY_TMO;
+	}
+
+	if (ndlp->nlp_rpi) {
+		if ((mbox = lpfc_mbox_alloc(phba, MEM_PRI))) {
+			lpfc_unreg_login(phba, ndlp->nlp_rpi, mbox);
+			if (lpfc_sli_issue_mbox
+			    (phba, mbox, (MBX_NOWAIT | MBX_STOP_IOCB))
+			    == MBX_NOT_FINISHED) {
+				lpfc_mbox_free(phba, mbox);
+			}
+		}
+		lpfc_no_rpi(phba, ndlp);
+		ndlp->nlp_rpi = 0;
+		lpfc_set_failmask(phba, ndlp, LPFC_DEV_DISCONNECTED,
+				  LPFC_SET_BITMASK);
+	}
+	return (0);
+}
+
+/*
+ * Check to see if we can free the nlp back to the freelist.
+ * If we are in the middle of using the nlp in the discovery state
+ * machine, defer the free till we reach the end of the state machine.
+ */
+int
+lpfc_nlp_remove(lpfcHBA_t * phba, LPFC_NODELIST_t * ndlp)
+{
+	LPFCSCSITARGET_t *targetp;
+	LPFCSCSILUN_t    *lunp;
+	struct list_head *curr, *next;
+
+	if(ndlp->nlp_disc_refcnt) {
+		ndlp->nlp_rflag |= NLP_DELAY_REMOVE;
+	}
+	else {
+		/* Since the ndlp is being freed, disassociate it
+		 * from the target / lun structures.
+		 */
+		targetp = ndlp->nlp_Target;
+		if(targetp) {
+			lpfc_sched_flush_target(phba, targetp, IOSTAT_LOCAL_REJECT,
+				IOERR_SLI_ABORTED);
+
+			targetp->pcontext = 0;
+			list_for_each_safe(curr, next, &targetp->lunlist) {
+				lunp = list_entry(curr, LPFCSCSILUN_t, list);
+				lunp->pnode = 0;
+			}
+		}
+		lpfc_freenode(phba, ndlp);
+		lpfc_nlp_free(phba, ndlp);
+	}
+	return(0);
+}
+
+int
+lpfc_matchdid(lpfcHBA_t * phba, LPFC_NODELIST_t * ndlp, uint32_t did)
+{
+	D_ID mydid;
+	D_ID ndlpdid;
+	D_ID matchdid;
+	int zero_did;
+
+	if (did == Bcast_DID)
+		return (0);
+
+	zero_did = 0;
+	if (ndlp->nlp_DID == 0) {
+		return (0);
+	}
+
+	/* First check for Direct match */
+	if (ndlp->nlp_DID == did)
+		return (1);
+
+	/* Next check for area/domain identically equals 0 match */
+	mydid.un.word = phba->fc_myDID;
+	if ((mydid.un.b.domain == 0) && (mydid.un.b.area == 0)) {
+		goto out;
+	}
+
+	matchdid.un.word = did;
+	ndlpdid.un.word = ndlp->nlp_DID;
+	if (matchdid.un.b.id == ndlpdid.un.b.id) {
+		if ((mydid.un.b.domain == matchdid.un.b.domain) &&
+		    (mydid.un.b.area == matchdid.un.b.area)) {
+			if ((ndlpdid.un.b.domain == 0) &&
+			    (ndlpdid.un.b.area == 0)) {
+				if (ndlpdid.un.b.id)
+					return (1);
+			}
+			goto out;
+		}
+
+		matchdid.un.word = ndlp->nlp_DID;
+		if ((mydid.un.b.domain == ndlpdid.un.b.domain) &&
+		    (mydid.un.b.area == ndlpdid.un.b.area)) {
+			if ((matchdid.un.b.domain == 0) &&
+			    (matchdid.un.b.area == 0)) {
+				if (matchdid.un.b.id)
+					return (1);
+			}
+		}
+	}
+      out:
+	if (zero_did)
+		ndlp->nlp_DID = 0;
+	return (0);
+}
+
+/* Search for a nodelist entry on a specific list */
+LPFC_NODELIST_t *
+lpfc_findnode_scsiid(lpfcHBA_t * phba, uint32_t scsid)
+{
+	LPFC_NODELIST_t *ndlp;
+	struct list_head *pos;
+	LPFCSCSITARGET_t *targetp;
+
+	targetp = phba->device_queue_hash[scsid];
+	/* First see if the SCSI ID has an allocated LPFCSCSITARGET_t */
+	if (targetp) {
+		if (targetp->pcontext) {
+			return ((LPFC_NODELIST_t *) targetp->pcontext);
+		}
+	}
+
+	/* Now try the hard way */
+	list_for_each(pos, &phba->fc_nlpmap_list) {
+		ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+		if (scsid == ndlp->nlp_sid) {
+			return (ndlp);
+		}
+	}
+
+	/* no match found */
+	return ((LPFC_NODELIST_t *) 0);
+}
+
+/* Search for a nodelist entry on a specific list */
+LPFC_NODELIST_t *
+lpfc_findnode_wwnn(lpfcHBA_t * phba, uint32_t order, NAME_TYPE * wwnn)
+{
+	LPFC_NODELIST_t *ndlp;
+	uint32_t data1;
+	LPFC_BINDLIST_t *blp;
+	struct list_head *pos, *tpos;
+
+	blp = 0;
+	if (order & NLP_SEARCH_UNMAPPED) {
+		list_for_each_safe(pos, tpos, &phba->fc_nlpunmap_list) {
+			ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			if (lpfc_geportname(&ndlp->nlp_nodename, wwnn) == 2) {
+
+				data1 = (((uint32_t) ndlp->nlp_state << 24) |
+					 ((uint32_t) ndlp->nlp_xri << 16) |
+					 ((uint32_t) ndlp->nlp_type << 8) |
+					 ((uint32_t) ndlp->nlp_rpi & 0xff));
+				/* FIND node DID unmapped */
+				lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0910,
+						lpfc_mes0910,
+						lpfc_msgBlk0910.msgPreambleStr,
+						(ulong) ndlp, ndlp->nlp_DID,
+						ndlp->nlp_flag, data1);
+				if (order & NLP_SEARCH_DEQUE) {
+					ndlp->nlp_flag &=
+					    ~(NLP_UNMAPPED_LIST |
+					      NLP_TGT_NO_SCSIID);
+					phba->fc_unmap_cnt--;
+					list_del(&ndlp->nlp_listp);
+					phba->nport_event_cnt++;
+				}
+				return (ndlp);
+			}
+		}
+	}
+
+	if (order & NLP_SEARCH_MAPPED) {
+		list_for_each_safe(pos, tpos, &phba->fc_nlpmap_list) {
+			ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			if (lpfc_geportname(&ndlp->nlp_nodename, wwnn) == 2) {
+
+				data1 = (((uint32_t) ndlp->nlp_state << 24) |
+					 ((uint32_t) ndlp->nlp_xri << 16) |
+					 ((uint32_t) ndlp->nlp_type << 8) |
+					 ((uint32_t) ndlp->nlp_rpi & 0xff));
+				/* FIND node did mapped */
+				lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0902,
+						lpfc_mes0902,
+						lpfc_msgBlk0902.msgPreambleStr,
+						(ulong) ndlp, ndlp->nlp_DID,
+						ndlp->nlp_flag, data1);
+				if (order & NLP_SEARCH_DEQUE) {
+					ndlp->nlp_flag &= ~NLP_MAPPED_LIST;
+					phba->fc_map_cnt--;
+					list_del(&ndlp->nlp_listp);
+					phba->nport_event_cnt++;
+
+					/* Must call before binding is
+					   removed */
+					lpfc_set_failmask(phba, ndlp,
+							  LPFC_DEV_DISAPPEARED,
+							  LPFC_SET_BITMASK);
+
+					blp = ndlp->nlp_listp_bind;
+					ndlp->nlp_listp_bind = 0;
+					if (blp) {
+						blp->nlp_Target =
+						    ndlp->nlp_Target;
+					}
+					/* Keep Target and sid since
+					 * LPFC_DEV_DISAPPEARED is a
+					 * non-fatal error
+					 */
+					ndlp->nlp_flag &= ~NLP_SEED_MASK;
+				}
+				if (blp) {
+					lpfc_nlp_bind(phba, blp);
+				}
+				return (ndlp);
+			}
+		}
+	}
+
+	/* no match found */
+	return ((LPFC_NODELIST_t *) 0);
+}
+
+/* Search for a nodelist entry on a specific list */
+LPFC_NODELIST_t *
+lpfc_findnode_wwpn(lpfcHBA_t * phba, uint32_t order, NAME_TYPE * wwpn)
+{
+	LPFC_NODELIST_t *ndlp, *new_ndlp;
+	uint32_t data1;
+	LPFC_BINDLIST_t *blp;
+	struct list_head *pos, *next;
+
+	blp = 0;
+	if (order & NLP_SEARCH_UNMAPPED) {
+		list_for_each_safe(pos, next, &phba->fc_nlpunmap_list) {
+			new_ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			ndlp = new_ndlp;
+			if (lpfc_geportname(&ndlp->nlp_portname, wwpn) == 2) {
+
+				data1 = (((uint32_t) ndlp->nlp_state << 24) |
+					 ((uint32_t) ndlp->nlp_xri << 16) |
+					 ((uint32_t) ndlp->nlp_type << 8) |
+					 ((uint32_t) ndlp->nlp_rpi & 0xff));
+				/* FIND node DID unmapped */
+				lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0911,
+						lpfc_mes0911,
+						lpfc_msgBlk0911.msgPreambleStr,
+						(ulong) ndlp, ndlp->nlp_DID,
+						ndlp->nlp_flag, data1);
+				if (order & NLP_SEARCH_DEQUE) {
+					ndlp->nlp_flag &=
+					    ~(NLP_UNMAPPED_LIST |
+					      NLP_TGT_NO_SCSIID);
+					phba->fc_unmap_cnt--;
+					list_del(&ndlp->nlp_listp);
+					phba->nport_event_cnt++;
+				}
+				return (ndlp);
+			}
+		}
+	}
+
+	if (order & NLP_SEARCH_MAPPED) {
+		list_for_each_safe(pos, next, &phba->fc_nlpmap_list) {
+			new_ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			ndlp = new_ndlp;
+			if (lpfc_geportname(&ndlp->nlp_portname, wwpn) == 2) {
+
+				data1 = (((uint32_t) ndlp->nlp_state << 24) |
+					 ((uint32_t) ndlp->nlp_xri << 16) |
+					 ((uint32_t) ndlp->nlp_type << 8) |
+					 ((uint32_t) ndlp->nlp_rpi & 0xff));
+				/* FIND node DID mapped */
+				lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0901,
+						lpfc_mes0901,
+						lpfc_msgBlk0901.msgPreambleStr,
+						(ulong) ndlp, ndlp->nlp_DID,
+						ndlp->nlp_flag, data1);
+				if (order & NLP_SEARCH_DEQUE) {
+					ndlp->nlp_flag &= ~NLP_MAPPED_LIST;
+					phba->fc_map_cnt--;
+					list_del(&ndlp->nlp_listp);
+					phba->nport_event_cnt++;
+
+					/* Must call before binding is
+					   removed */
+					lpfc_set_failmask(phba, ndlp,
+							  LPFC_DEV_DISAPPEARED,
+							  LPFC_SET_BITMASK);
+
+					blp = ndlp->nlp_listp_bind;
+					ndlp->nlp_listp_bind = 0;
+					if (blp) {
+						blp->nlp_Target =
+						    ndlp->nlp_Target;
+					}
+					/* Keep Target and sid since
+					 * LPFC_DEV_DISAPPEARED is a
+					 * non-fatal error
+					 */
+					ndlp->nlp_flag &= ~NLP_SEED_MASK;
+				}
+				if (blp) {
+					lpfc_nlp_bind(phba, blp);
+				}
+				return (ndlp);
+			}
+		}
+	}
+
+	/* no match found */
+	return ((LPFC_NODELIST_t *) 0);
+}
+
+/* Search for a nodelist entry on a specific list */
+LPFC_NODELIST_t *
+lpfc_findnode_did(lpfcHBA_t * phba, uint32_t order, uint32_t did)
+{
+	LPFC_NODELIST_t *ndlp, *new_ndlp;
+	uint32_t data1;
+	LPFC_BINDLIST_t *blp;
+	struct list_head *pos, *next;
+
+	blp = 0;
+	if (order & NLP_SEARCH_UNMAPPED) {
+		list_for_each_safe(pos, next, &phba->fc_nlpunmap_list) {
+			new_ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			ndlp = new_ndlp;
+			if (lpfc_matchdid(phba, ndlp, did)) {
+				data1 = (((uint32_t) ndlp->nlp_state << 24) |
+					 ((uint32_t) ndlp->nlp_xri << 16) |
+					 ((uint32_t) ndlp->nlp_type << 8) |
+					 ((uint32_t) ndlp->nlp_rpi & 0xff));
+				/* FIND node DID unmapped */
+				lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0929,
+						lpfc_mes0929,
+						lpfc_msgBlk0929.msgPreambleStr,
+						(ulong) ndlp, ndlp->nlp_DID,
+						ndlp->nlp_flag, data1);
+				if (order & NLP_SEARCH_DEQUE) {
+					ndlp->nlp_flag &=
+					    ~(NLP_UNMAPPED_LIST |
+					      NLP_TGT_NO_SCSIID);
+					phba->fc_unmap_cnt--;
+					list_del(&ndlp->nlp_listp);
+					phba->nport_event_cnt++;
+				}
+
+				return (ndlp);
+			}
+		}
+	}
+
+	if (order & NLP_SEARCH_MAPPED) {
+		list_for_each_safe(pos, next, &phba->fc_nlpmap_list) {
+			new_ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			ndlp = new_ndlp;
+
+			if (lpfc_matchdid(phba, ndlp, did)) {
+
+				data1 = (((uint32_t) ndlp->nlp_state << 24) |
+					 ((uint32_t) ndlp->nlp_xri << 16) |
+					 ((uint32_t) ndlp->nlp_type << 8) |
+					 ((uint32_t) ndlp->nlp_rpi & 0xff));
+				/* FIND node DID mapped */
+				lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0930,
+						lpfc_mes0930,
+						lpfc_msgBlk0930.msgPreambleStr,
+						(ulong) ndlp, ndlp->nlp_DID,
+						ndlp->nlp_flag, data1);
+				if (order & NLP_SEARCH_DEQUE) {
+					ndlp->nlp_flag &= ~NLP_MAPPED_LIST;
+					phba->fc_map_cnt--;
+					list_del(&ndlp->nlp_listp);
+					phba->nport_event_cnt++;
+
+					/* Must call before binding is
+					   removed */
+					lpfc_set_failmask(phba, ndlp,
+							  LPFC_DEV_DISAPPEARED,
+							  LPFC_SET_BITMASK);
+
+					blp = ndlp->nlp_listp_bind;
+					ndlp->nlp_listp_bind = 0;
+					if (blp) {
+						blp->nlp_Target =
+						    ndlp->nlp_Target;
+					}
+					/* Keep Target and sid since
+					 * LPFC_DEV_DISAPPEARED is a
+					 * non-fatal error
+					 */
+					ndlp->nlp_flag &= ~NLP_SEED_MASK;
+				}
+
+				if (blp) {
+					lpfc_nlp_bind(phba, blp);
+				}
+				return (ndlp);
+			}
+		}
+	}
+
+	if (order & NLP_SEARCH_PLOGI) {
+		list_for_each_safe(pos, next, &phba->fc_plogi_list) {
+			new_ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			ndlp = new_ndlp;
+			if (lpfc_matchdid(phba, ndlp, did)) {
+
+				data1 = (((uint32_t) ndlp->nlp_state << 24) |
+					 ((uint32_t) ndlp->nlp_xri << 16) |
+					 ((uint32_t) ndlp->nlp_type << 8) |
+					 ((uint32_t) ndlp->nlp_rpi & 0xff));
+				/* LOG change to PLOGI */
+				/* FIND node DID bind */
+				lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0908,
+						lpfc_mes0908,
+						lpfc_msgBlk0908.msgPreambleStr,
+						(ulong) ndlp, ndlp->nlp_DID,
+						ndlp->nlp_flag, data1);
+				if (order & NLP_SEARCH_DEQUE) {
+					ndlp->nlp_flag &= ~NLP_PLOGI_LIST;
+					phba->fc_plogi_cnt--;
+					list_del(&ndlp->nlp_listp);
+				}
+
+				return (ndlp);
+			}
+		}
+	}
+
+	if (order & NLP_SEARCH_ADISC) {
+		list_for_each_safe(pos, next, &phba->fc_adisc_list) {
+			new_ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			ndlp = new_ndlp;
+			if (lpfc_matchdid(phba, ndlp, did)) {
+
+				data1 = (((uint32_t) ndlp->nlp_state << 24) |
+					 ((uint32_t) ndlp->nlp_xri << 16) |
+					 ((uint32_t) ndlp->nlp_type << 8) |
+					 ((uint32_t) ndlp->nlp_rpi & 0xff));
+				/* LOG change to ADISC */
+				/* FIND node DID bind */
+				lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0931,
+						lpfc_mes0931,
+						lpfc_msgBlk0931.msgPreambleStr,
+						(ulong) ndlp, ndlp->nlp_DID,
+						ndlp->nlp_flag, data1);
+				if (order & NLP_SEARCH_DEQUE) {
+					ndlp->nlp_flag &= ~NLP_ADISC_LIST;
+					phba->fc_adisc_cnt--;
+					list_del(&ndlp->nlp_listp);
+				}
+
+				return (ndlp);
+			}
+		}
+	}
+
+	/* FIND node did <did> NOT FOUND */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0932,
+			lpfc_mes0932,
+			lpfc_msgBlk0932.msgPreambleStr, did, order);
+
+	/* no match found */
+	return ((LPFC_NODELIST_t *) 0);
+}
+
+/* Build a list of nodes to discover based on the loopmap */
+void
+lpfc_disc_list_loopmap(lpfcHBA_t * phba)
+{
+	LPFC_NODELIST_t *ndlp;
+	lpfcCfgParam_t *clp;
+	int j;
+	uint32_t alpa, index;
+
+	clp = &phba->config[0];
+
+	if (phba->hba_state <= LPFC_LINK_DOWN) {
+		return;
+	}
+	if (phba->fc_topology != TOPOLOGY_LOOP) {
+		return;
+	}
+
+	/* Check for loop map present or not */
+	if (phba->alpa_map[0]) {
+		for (j = 1; j <= phba->alpa_map[0]; j++) {
+			alpa = phba->alpa_map[j];
+
+			if (((phba->fc_myDID & 0xff) == alpa) || (alpa == 0)) {
+				continue;
+			}
+			if ((ndlp = lpfc_findnode_did(phba,
+						      (NLP_SEARCH_MAPPED |
+						       NLP_SEARCH_UNMAPPED |
+						       NLP_SEARCH_DEQUE),
+						      alpa))) {
+				/* Mark node for address authentication */
+				lpfc_disc_state_machine(phba, ndlp, 0,
+							NLP_EVT_DEVICE_ADD);
+				continue;
+			}
+			/* Skip if the node is already in the plogi / adisc
+			   list */
+			if ((ndlp = lpfc_findnode_did(phba,
+						      (NLP_SEARCH_PLOGI |
+						       NLP_SEARCH_ADISC),
+						      alpa))) {
+				continue;
+			}
+			/* Cannot find existing Fabric ndlp, so allocate a new
+			   one */
+			if ((ndlp = lpfc_nlp_alloc(phba, 0)) == 0) {
+				continue;
+			}
+			memset(ndlp, 0, sizeof (LPFC_NODELIST_t));
+			ndlp->nlp_state = NLP_STE_UNUSED_NODE;
+			ndlp->nlp_DID = alpa;
+			/* Mark node for address discovery */
+			lpfc_disc_state_machine(phba, ndlp, 0,
+						NLP_EVT_DEVICE_ADD);
+		}
+	} else {
+		/* No alpamap, so try all alpa's */
+		for (j = 0; j < FC_MAXLOOP; j++) {
+			if (clp[LPFC_CFG_SCAN_DOWN].a_current)
+				index = FC_MAXLOOP - j - 1;
+			else
+				index = j;
+			alpa = lpfcAlpaArray[index];
+			if ((phba->fc_myDID & 0xff) == alpa) {
+				continue;
+			}
+
+			if ((ndlp = lpfc_findnode_did(phba,
+						      (NLP_SEARCH_MAPPED |
+						       NLP_SEARCH_UNMAPPED |
+						       NLP_SEARCH_DEQUE),
+						      alpa))) {
+				/* Mark node for address authentication */
+				lpfc_disc_state_machine(phba, ndlp, 0,
+							NLP_EVT_DEVICE_ADD);
+				continue;
+			}
+			/* Skip if the node is already in the plogi / adisc
+			   list */
+			if ((ndlp = lpfc_findnode_did(phba,
+						      (NLP_SEARCH_PLOGI |
+						       NLP_SEARCH_ADISC),
+						      alpa))) {
+				continue;
+			}
+			/* Cannot find existing ndlp, so allocate a new one */
+			if ((ndlp = lpfc_nlp_alloc(phba, 0)) == 0) {
+				continue;
+			}
+			memset(ndlp, 0, sizeof (LPFC_NODELIST_t));
+			ndlp->nlp_state = NLP_STE_UNUSED_NODE;
+			ndlp->nlp_DID = alpa;
+			/* Mark node for address discovery */
+			lpfc_disc_state_machine(phba, ndlp, 0,
+						NLP_EVT_DEVICE_ADD);
+		}
+	}
+	return;
+}
+
+/* Start Link up / RSCN discovery on ADISC or PLOGI lists */
+void
+lpfc_disc_start(lpfcHBA_t * phba)
+{
+	LPFC_SLI_t *psli;
+	LPFC_MBOXQ_t *mbox;
+	LPFC_NODELIST_t *ndlp;
+	LPFC_NODELIST_t *new_ndlp;
+	struct list_head *pos, *next;
+	uint32_t did_changed;
+	lpfcCfgParam_t *clp;
+	uint32_t clear_la_pending;
+
+	clp = &phba->config[0];
+	psli = &phba->sli;
+
+	if (phba->hba_state <= LPFC_LINK_DOWN) {
+		return;
+	}
+	if (phba->hba_state == LPFC_CLEAR_LA)
+		clear_la_pending = 1;
+	else
+		clear_la_pending = 0;
+
+	if (phba->hba_state < LPFC_HBA_READY) {
+		phba->hba_state = LPFC_DISC_AUTH;
+	}
+	lpfc_set_disctmo(phba);
+
+	if (phba->fc_prevDID == phba->fc_myDID) {
+		did_changed = 0;
+	} else {
+		did_changed = 1;
+	}
+	phba->fc_prevDID = phba->fc_myDID;
+
+	/* Start Discovery state <hba_state> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0202,
+			lpfc_mes0202,
+			lpfc_msgBlk0202.msgPreambleStr,
+			phba->hba_state, phba->fc_flag, phba->fc_plogi_cnt,
+			phba->fc_adisc_cnt);
+
+	/* First do ADISC for authentication */
+	if (phba->fc_adisc_cnt) {
+		if (did_changed == 0) {
+			phba->num_disc_nodes = 0;
+			/* go thru ADISC list and issue ELS ADISCs */
+			list_for_each(pos, &phba->fc_adisc_list) {
+				ndlp = list_entry(pos, LPFC_NODELIST_t,
+						  nlp_listp);
+				lpfc_issue_els_adisc(phba, ndlp, 0);
+				ndlp->nlp_flag |= NLP_DISC_NODE;
+				phba->num_disc_nodes++;
+				if (phba->num_disc_nodes >=
+				    clp[LPFC_CFG_DISC_THREADS].a_current) {
+					if (phba->fc_adisc_cnt >
+					    phba->num_disc_nodes)
+						phba->fc_flag |= FC_NLP_MORE;
+					break;
+				}
+			}
+			return;
+		}
+		/* If the did changed, force PLOGI discovery on all NPorts scheduled for ADISC */
+		if (!list_empty(&phba->fc_adisc_list)) {
+			list_for_each_safe(pos, next, &phba->fc_adisc_list) {
+				new_ndlp = list_entry(pos, LPFC_NODELIST_t,
+						      nlp_listp);
+				ndlp = new_ndlp;
+				lpfc_freenode(phba, ndlp);
+				ndlp->nlp_state = NLP_STE_UNUSED_NODE;
+				lpfc_nlp_plogi(phba, ndlp);
+			}
+		}
+	}
+
+	if ((phba->hba_state < LPFC_HBA_READY) && (!clear_la_pending)) {
+		/* If we get here, there is nothing to ADISC */
+		if ((mbox = lpfc_mbox_alloc(phba, MEM_PRI))) {
+			phba->hba_state = LPFC_CLEAR_LA;
+			lpfc_clear_la(phba, mbox);
+			mbox->mbox_cmpl = lpfc_mbx_cmpl_clear_la;
+			if (lpfc_sli_issue_mbox
+			    (phba, mbox, (MBX_NOWAIT | MBX_STOP_IOCB))
+			    == MBX_NOT_FINISHED) {
+				lpfc_mbox_free(phba, mbox);
+				lpfc_disc_flush_list(phba);
+				psli->ring[(psli->ip_ring)].flag &=
+				    ~LPFC_STOP_IOCB_EVENT;
+				psli->ring[(psli->fcp_ring)].flag &=
+				    ~LPFC_STOP_IOCB_EVENT;
+				psli->ring[(psli->next_ring)].flag &=
+				    ~LPFC_STOP_IOCB_EVENT;
+				phba->hba_state = LPFC_HBA_READY;
+			}
+		}
+	} else {
+		/* go thru PLOGI list and issue ELS PLOGIs */
+		phba->num_disc_nodes = 0;
+		if (phba->fc_plogi_cnt) {
+			list_for_each(pos, &phba->fc_plogi_list) {
+				ndlp = list_entry(pos, LPFC_NODELIST_t,
+						  nlp_listp);
+				if (ndlp->nlp_state == NLP_STE_UNUSED_NODE) {
+					ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+					lpfc_issue_els_plogi(phba, ndlp, 0);
+					ndlp->nlp_flag |= NLP_DISC_NODE;
+					phba->num_disc_nodes++;
+					if (phba->num_disc_nodes >=
+					    clp[LPFC_CFG_DISC_THREADS].
+					    a_current) {
+						if (phba->fc_plogi_cnt >
+						    phba->num_disc_nodes)
+							phba->fc_flag |=
+							    FC_NLP_MORE;
+						break;
+					}
+				}
+			}
+		} else {
+			if (phba->fc_flag & FC_RSCN_MODE) {
+				/* Check to see if more RSCNs came in while we
+				 * were processing this one.
+				 */
+				if ((phba->fc_rscn_id_cnt == 0) &&
+				    (!(phba->fc_flag & FC_RSCN_DISCOVERY))) {
+					lpfc_els_flush_rscn(phba);
+				} else {
+					lpfc_els_handle_rscn(phba);
+				}
+			}
+		}
+	}
+	return;
+}
+
+void
+lpfc_disc_flush_list(lpfcHBA_t * phba)
+{
+	LPFC_NODELIST_t *ndlp, *new_ndlp;
+	struct list_head *pos, *next;
+
+	if (phba->fc_plogi_cnt) {
+		list_for_each_safe(pos, next, &phba->fc_plogi_list) {
+			new_ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			ndlp = new_ndlp;
+			lpfc_set_failmask(phba, ndlp, LPFC_DEV_DISCONNECTED,
+					  LPFC_SET_BITMASK);
+			lpfc_free_tx(phba, ndlp);
+			lpfc_nlp_remove(phba, ndlp);
+		}
+	}
+	if (phba->fc_adisc_cnt) {
+		list_for_each_safe(pos, next, &phba->fc_adisc_list) {
+			new_ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			ndlp = new_ndlp;
+			lpfc_set_failmask(phba, ndlp, LPFC_DEV_DISCONNECTED,
+					  LPFC_SET_BITMASK);
+			lpfc_free_tx(phba, ndlp);
+			lpfc_nlp_remove(phba, ndlp);
+		}
+	}
+	return;
+}
+
+/*****************************************************************************/
+/*
+ * NAME:     lpfc_disc_timeout
+ *
+ * FUNCTION: Fibre Channel driver discovery timeout routine.
+ *
+ * EXECUTION ENVIRONMENT: interrupt only
+ *
+ * CALLED FROM:
+ *      Timer function
+ *
+ * RETURNS:  
+ *      none
+ */
+/*****************************************************************************/
+void
+lpfc_disc_timeout(unsigned long ptr)
+{
+	lpfcHBA_t *phba;
+	LPFC_SLI_t *psli;
+	LPFC_NODELIST_t *ndlp;
+	LPFC_MBOXQ_t *mbox;
+	lpfcCfgParam_t *clp;
+	struct clk_data *clkData;
+	unsigned long iflag;
+
+	clkData = (struct clk_data *)ptr;
+	phba = clkData->phba;
+	if (!phba) {
+		kfree(clkData);
+		return;
+	}
+
+	LPFC_DRVR_LOCK(phba, iflag);
+       	if (clkData->flags & TM_CANCELED) {
+		list_del((struct list_head *)clkData);
+		kfree(clkData);	
+		goto out;
+ 	}
+
+	clkData->timeObj->function = 0;
+	list_del((struct list_head *)clkData);
+	kfree(clkData);
+
+	clp = &phba->config[0];
+	psli = &phba->sli;
+	phba->fc_disctmo.function = 0;	/* timer expired */
+
+	/* hba_state is identically LPFC_LOCAL_CFG_LINK while waiting for FAN */
+	if (phba->hba_state == LPFC_LOCAL_CFG_LINK) {
+		/* FAN timeout */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0221,
+				lpfc_mes0221, lpfc_msgBlk0221.msgPreambleStr);
+
+		/* Forget about FAN, Start discovery by sending a FLOGI
+		 * hba_state is identically LPFC_FLOGI while waiting for FLOGI
+		 * cmpl
+		 */
+		phba->hba_state = LPFC_FLOGI;
+		lpfc_set_disctmo(phba);
+		lpfc_initial_flogi(phba);
+		goto out;
+	}
+
+	/* hba_state is identically LPFC_FLOGI while waiting for FLOGI cmpl */
+	if (phba->hba_state == LPFC_FLOGI) {
+		/* Initial FLOGI timeout */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0222,
+				lpfc_mes0222, lpfc_msgBlk0222.msgPreambleStr);
+
+		/* Assume no Fabric and go on with discovery.
+		 * Check for outstanding ELS FLOGI to abort.
+		 */
+
+		/* FLOGI failed, so just use loop map to make discovery list */
+		lpfc_disc_list_loopmap(phba);
+
+		/* Start discovery */
+		lpfc_disc_start(phba);
+		goto out;
+	}
+
+	/* hba_state is identically LPFC_FABRIC_CFG_LINK while waiting for
+	   NameServer login */
+	if (phba->hba_state == LPFC_FABRIC_CFG_LINK) {
+		/* Timeout while waiting for NameServer login */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0223,
+				lpfc_mes0223, lpfc_msgBlk0223.msgPreambleStr);
+
+		/* Next look for NameServer ndlp */
+		if ((ndlp =
+		     lpfc_findnode_did(phba,
+				       (NLP_SEARCH_ALL | NLP_SEARCH_DEQUE),
+				       NameServer_DID))) {
+			lpfc_nlp_remove(phba, ndlp);
+		}
+		/* Start discovery */
+		lpfc_disc_start(phba);
+		goto out;
+	}
+
+	/* Check for wait for NameServer Rsp timeout */
+	if (phba->hba_state == LPFC_NS_QRY) {
+		/* NameServer Query timeout */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0224,
+				lpfc_mes0224,
+				lpfc_msgBlk0224.msgPreambleStr,
+				phba->fc_ns_retry, LPFC_MAX_NS_RETRY);
+
+		if ((ndlp =
+		     lpfc_findnode_did(phba, NLP_SEARCH_UNMAPPED,
+				       NameServer_DID))) {
+			if (phba->fc_ns_retry < LPFC_MAX_NS_RETRY) {
+				/* Try it one more time */
+				if (lpfc_ns_cmd(phba, ndlp, SLI_CTNS_GID_FT) ==
+				    0) {
+					goto out;
+				}
+			}
+			phba->fc_ns_retry = 0;
+		}
+
+		/* Nothing to authenticate, so CLEAR_LA right now */
+		if (phba->hba_state != LPFC_CLEAR_LA) {
+			if ((mbox = lpfc_mbox_alloc(phba, MEM_PRI))) {
+				phba->hba_state = LPFC_CLEAR_LA;
+				lpfc_clear_la(phba, mbox);
+				mbox->mbox_cmpl = lpfc_mbx_cmpl_clear_la;
+				if (lpfc_sli_issue_mbox
+				    (phba, mbox, (MBX_NOWAIT | MBX_STOP_IOCB))
+				    == MBX_NOT_FINISHED) {
+					lpfc_mbox_free(phba, mbox);
+					goto clrlaerr;
+				}
+			} else {
+				/* Device Discovery completion error */
+				lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0226,
+						lpfc_mes0226,
+						lpfc_msgBlk0226.msgPreambleStr);
+				phba->hba_state = LPFC_HBA_ERROR;
+			}
+		}
+		if ((mbox = lpfc_mbox_alloc(phba, MEM_PRI))) {
+			/* Setup and issue mailbox INITIALIZE LINK command */
+			lpfc_linkdown(phba);
+			lpfc_init_link(phba, mbox,
+				       clp[LPFC_CFG_TOPOLOGY].a_current,
+				       clp[LPFC_CFG_LINK_SPEED].a_current);
+			mbox->mb.un.varInitLnk.lipsr_AL_PA = 0;
+			if (lpfc_sli_issue_mbox
+			    (phba, mbox, (MBX_NOWAIT | MBX_STOP_IOCB))
+			    == MBX_NOT_FINISHED) {
+				lpfc_mbox_free(phba, mbox);
+			}
+		}
+		goto out;
+	}
+
+	if (phba->hba_state == LPFC_DISC_AUTH) {
+		/* Node Authentication timeout */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0227,
+				lpfc_mes0227, lpfc_msgBlk0227.msgPreambleStr);
+		lpfc_disc_flush_list(phba);
+		if (phba->hba_state != LPFC_CLEAR_LA) {
+			if ((mbox = lpfc_mbox_alloc(phba, MEM_PRI))) {
+				phba->hba_state = LPFC_CLEAR_LA;
+				lpfc_clear_la(phba, mbox);
+				mbox->mbox_cmpl = lpfc_mbx_cmpl_clear_la;
+				if (lpfc_sli_issue_mbox
+				    (phba, mbox, (MBX_NOWAIT | MBX_STOP_IOCB))
+				    == MBX_NOT_FINISHED) {
+					lpfc_mbox_free(phba, mbox);
+					goto clrlaerr;
+				}
+			}
+		}
+		goto out;
+	}
+
+	if (phba->hba_state == LPFC_CLEAR_LA) {
+		/* CLEAR LA timeout */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0228,
+				lpfc_mes0228, lpfc_msgBlk0228.msgPreambleStr);
+	      clrlaerr:
+		lpfc_disc_flush_list(phba);
+		psli->ring[(psli->ip_ring)].flag &= ~LPFC_STOP_IOCB_EVENT;
+		psli->ring[(psli->fcp_ring)].flag &= ~LPFC_STOP_IOCB_EVENT;
+		psli->ring[(psli->next_ring)].flag &= ~LPFC_STOP_IOCB_EVENT;
+		phba->hba_state = LPFC_HBA_READY;
+		goto out;
+	}
+
+	if ((phba->hba_state == LPFC_HBA_READY) &&
+	    (phba->fc_flag & FC_RSCN_MODE)) {
+		/* RSCN timeout */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0231,
+				lpfc_mes0231,
+				lpfc_msgBlk0231.msgPreambleStr,
+				phba->fc_ns_retry, LPFC_MAX_NS_RETRY);
+
+		/* Cleanup any outstanding ELS commands */
+		lpfc_els_flush_cmd(phba);
+
+		lpfc_els_flush_rscn(phba);
+		lpfc_disc_flush_list(phba);
+		goto out;
+	}
+
+      out:
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	return;
+}
+
+/*****************************************************************************/
+/*
+ * NAME:     lpfc_linkdown_timeout
+ *
+ * FUNCTION: Fibre Channel driver linkdown timeout routine.
+ *
+ * EXECUTION ENVIRONMENT: interrupt only
+ *
+ * CALLED FROM:
+ *      Timer function
+ *
+ * RETURNS:  
+ *      none
+ */
+/*****************************************************************************/
+void
+lpfc_linkdown_timeout(unsigned long ptr)
+{
+	lpfcHBA_t *phba;
+	struct clk_data *clkData;
+	unsigned long iflag;
+
+	clkData = (struct clk_data *)ptr;
+	phba = clkData->phba;
+	if (!phba) {
+		kfree(clkData);
+		return;
+	}
+
+	LPFC_DRVR_LOCK(phba, iflag);
+       	if (clkData->flags & TM_CANCELED) {
+		list_del((struct list_head *)clkData);
+		kfree(clkData);	
+		goto out;
+ 	}
+	
+	clkData->timeObj->function = 0;
+	list_del((struct list_head *)clkData);
+	kfree(clkData);
+
+	/* Link Down timeout */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk1306,
+			lpfc_mes1306,
+			lpfc_msgBlk1306.msgPreambleStr,
+			phba->hba_state, phba->fc_flag, phba->fc_ns_retry);
+
+	phba->fc_linkdown.function = 0;	/* timer expired */
+	phba->fc_flag |= (FC_LD_TIMER | FC_LD_TIMEOUT);	/* indicate timeout */
+	phba->hba_flag &= ~FC_LFR_ACTIVE;
+out:
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	return;
+}
+
+LPFCSCSITARGET_t *
+lpfc_find_target(lpfcHBA_t * phba, uint32_t tgt)
+{
+	LPFCSCSITARGET_t *targetp;
+
+	targetp = phba->device_queue_hash[tgt];
+	return (targetp);
+}
+
+/*****************************************************************************/
+/*
+ * NAME:     lpfc_find_lun
+ *
+ * FUNCTION: Fibre Channel bus/target/LUN to LPFCSCSILUN_t lookup
+ *
+ * EXECUTION ENVIRONMENT: 
+ *
+ * RETURNS:  
+ *      ptr to desired LPFCSCSILUN_t
+ */
+/*****************************************************************************/
+LPFCSCSILUN_t *
+lpfc_find_lun(lpfcHBA_t * phba, uint32_t tgt, uint64_t lun, int create_flag)
+{
+	LPFC_NODELIST_t *nlp;
+	LPFC_BINDLIST_t *blp;
+	LPFCSCSITARGET_t *targetp;
+	LPFCSCSILUN_t *lunp;
+	lpfcCfgParam_t *clp;
+	struct list_head *curr, *next;
+
+	clp = &phba->config[0];
+	targetp = phba->device_queue_hash[tgt];
+
+	/* First see if the SCSI ID has an allocated LPFCSCSITARGET_t */
+	if (targetp) {
+		list_for_each_safe(curr, next, &targetp->lunlist) {
+			lunp = list_entry(curr, LPFCSCSILUN_t, list);
+			/* Finally see if the LUN ID has an allocated
+			   LPFCSCSILUN_t */
+			if (lunp->lun_id == lun) {
+				return (lunp);
+			}
+		}
+		if (create_flag) {
+			goto lun_create;
+		}
+	} else {
+		if (create_flag) {
+			nlp = lpfc_findnode_scsiid(phba, tgt);
+			if (nlp == 0) {
+				return 0;
+			}
+
+			targetp = kmalloc(sizeof (LPFCSCSITARGET_t),
+					  GFP_ATOMIC);
+			if (targetp == 0) {
+				return (0);
+			}
+
+			memset(targetp, 0, sizeof (LPFCSCSITARGET_t));
+			INIT_LIST_HEAD(&targetp->lunlist);
+			targetp->scsi_id = tgt;
+			targetp->max_lun = clp[LPFC_CFG_MAX_LUN].a_current;
+			targetp->pHba = phba;
+			phba->device_queue_hash[tgt] = targetp;
+			targetp->pcontext = nlp;
+			if (nlp) {
+
+				/* Create SCSI Target <tgt> */
+				lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0204,
+						lpfc_mes0204,
+						lpfc_msgBlk0204.msgPreambleStr,
+						tgt);
+
+				nlp->nlp_Target = targetp;
+				if ((blp = nlp->nlp_listp_bind)) {
+					blp->nlp_Target = targetp;
+				}
+			}
+			if (clp[LPFC_CFG_DFT_TGT_Q_DEPTH].a_current) {
+				lpfc_sched_target_init(targetp, (uint16_t)
+						clp[LPFC_CFG_DFT_TGT_Q_DEPTH]
+						       .a_current);
+			} else {
+				lpfc_sched_target_init(targetp, (uint16_t)
+						clp[LPFC_CFG_DFT_HBA_Q_DEPTH]
+						       .a_current - 10);
+			}
+
+lun_create:
+			lunp = kmalloc(sizeof (LPFCSCSILUN_t), GFP_ATOMIC);
+			if (lunp == 0) {
+				return (0);
+			}
+
+			/* Create SCSI LUN <lun> on Target <tgt> */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0205,
+					lpfc_mes0205,
+					lpfc_msgBlk0205.msgPreambleStr,
+					(uint32_t) lun, tgt);
+
+			memset(lunp, 0, sizeof (LPFCSCSILUN_t));
+			lunp->lun_id = lun;
+			/* For Schedular to retry */
+			lunp->qfull_retries = lpfc_qfull_retry_count;
+			lunp->pTarget = targetp;
+			lunp->pHBA = phba;
+
+			list_add_tail(&lunp->list, &targetp->lunlist);
+			lpfc_sched_lun_init(lunp, (uint16_t)
+					    clp[LPFC_CFG_DFT_LUN_Q_DEPTH].
+					    a_current);
+			return (lunp);
+		}
+	}
+	return (0);
+}
+
+void
+lpfc_disc_cmpl_rptlun(lpfcHBA_t * phba,
+		      LPFC_IOCBQ_t * cmdiocb, LPFC_IOCBQ_t * rspiocb)
+{
+	DMABUF_t *mp;
+	LPFC_SCSI_BUF_t *lpfc_cmd;
+	LPFCSCSITARGET_t *targetp;
+	LPFCSCSILUN_t *lunp;
+	LPFC_NODELIST_t *ndlp;
+	lpfcCfgParam_t *clp;
+	FCP_RSP *fcprsp;
+	IOCB_t *iocb;
+	uint8_t *datap;
+	uint32_t *datap32;
+	uint32_t rptLunLen;
+	uint32_t max, lun, i;
+	struct list_head *curr, *next;
+
+	lpfc_cmd = cmdiocb->context1;
+	mp = cmdiocb->context2;
+	targetp = lpfc_cmd->pLun->pTarget;
+	ndlp = (LPFC_NODELIST_t *) targetp->pcontext;
+	iocb = &lpfc_cmd->cur_iocbq.iocb;
+	fcprsp = lpfc_cmd->fcp_rsp;
+	clp = &phba->config[0];
+
+	if (ndlp == 0) {
+		targetp->rptLunState = REPORT_LUN_ERRORED;
+		targetp->targetFlags &= ~FC_RETRY_RPTLUN;
+		if (targetp->tmofunc.function) {
+			lpfc_stop_timer((struct clk_data *)
+					targetp->tmofunc.data);
+		}
+		lpfc_page_free(phba, mp->virt, mp->phys);
+		kfree(mp);
+		lpfc_free_scsi_buf(lpfc_cmd);
+		return;
+	}
+
+	/* Report Lun completes on NPort <nlp_DID> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0206,
+			lpfc_mes0206,
+			lpfc_msgBlk0206.msgPreambleStr,
+			ndlp->nlp_DID, iocb->ulpStatus, fcprsp->rspStatus2,
+			fcprsp->rspStatus3, ndlp->nlp_failMask);
+
+	if (targetp) {
+
+		targetp->max_lun = clp[LPFC_CFG_MAX_LUN].a_current;
+
+		if (((iocb->ulpStatus == IOSTAT_SUCCESS) &&
+		     (fcprsp->rspStatus3 == SCSI_STAT_GOOD)) ||
+		    ((iocb->ulpStatus == IOSTAT_FCP_RSP_ERROR) &&
+		     (fcprsp->rspStatus2 & RESID_UNDER) &&
+		     (fcprsp->rspStatus3 == SCSI_STAT_GOOD))) {
+
+			datap = (uint8_t *) mp->virt;
+			/*
+			 * Assume all LUNs use same addressing mode as LUN0
+			 */
+			i = (uint32_t) ((datap[8] & 0xc0) >> 6);
+			switch (i) {
+			case PERIPHERAL_DEVICE_ADDRESSING:
+				targetp->addrMode =
+				    PERIPHERAL_DEVICE_ADDRESSING;
+				break;
+			case VOLUME_SET_ADDRESSING:
+				targetp->addrMode = VOLUME_SET_ADDRESSING;
+				break;
+			case LOGICAL_UNIT_ADDRESSING:	/* Not supported */
+			default:
+				/* Unsupported Addressing Mode <i> on NPort
+				   <nlp_DID> Tgt <sid> */
+				lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0249,
+						lpfc_mes0249,
+						lpfc_msgBlk0249.msgPreambleStr,
+						i, ndlp->nlp_DID,
+						ndlp->nlp_sid);
+				targetp->addrMode =
+				    PERIPHERAL_DEVICE_ADDRESSING;
+				break;
+			}
+
+			i = 0;
+			datap32 = (uint32_t *) mp->virt;
+			rptLunLen = *datap32;
+			rptLunLen = be32_to_cpu(rptLunLen);
+			/* search for the max lun */
+			max = 0;
+			for (i = 0;
+			     ((i < rptLunLen) && (i < (8 * LPFC_MAX_LUN)));
+			     i += 8) {
+				datap32 += 2;
+				lun = (((*datap32) >> FC_LUN_SHIFT) & 0xff);
+				if (lun > max)
+					max = lun;
+			}
+			if (i) {
+				targetp->max_lun = max + 1;
+			} else {
+				targetp->max_lun = 0;
+			}
+
+			targetp->rptLunState = REPORT_LUN_COMPLETE;
+			targetp->targetFlags &= ~FC_RETRY_RPTLUN;
+			if (targetp->tmofunc.function) {
+				lpfc_stop_timer((struct clk_data *)
+						targetp->tmofunc.data);
+			}
+
+			/* The lpfc_issue_rptlun function does not re-use the
+			 * buffer pointed to by targetp->RptLunData.  It always
+			 * allocates a new one and frees the old buffer.
+			 */
+			if (targetp->RptLunData) {
+				lpfc_page_free(phba,
+					       targetp->RptLunData->virt,
+					       targetp->RptLunData->phys);
+				kfree(targetp->RptLunData);
+			}
+			targetp->RptLunData = mp;
+
+			lpfc_set_failmask(phba, ndlp, LPFC_DEV_RPTLUN,
+					  LPFC_CLR_BITMASK);
+			list_for_each_safe(curr, next, &targetp->lunlist) {
+				lunp = list_entry(curr, LPFCSCSILUN_t, list);
+				lunp->pnode = (LPFC_NODELIST_t *) ndlp;
+			}
+		} else {
+			/* Retry RPTLUN */
+			if (ndlp
+			    && (!(ndlp->nlp_failMask & LPFC_DEV_FATAL_ERROR))
+			    && (!(targetp->targetFlags & FC_RETRY_RPTLUN))) {
+				targetp->targetFlags |= FC_RETRY_RPTLUN;
+				lpfc_start_timer(phba, 1, &targetp->rptlunfunc,
+						 lpfc_disc_retry_rptlun,
+						 (unsigned long)targetp, 0);
+			} else {
+				targetp->rptLunState = REPORT_LUN_ERRORED;
+
+				/* If ReportLun failed, then we allow only lun 0
+				 * on this target.  This way, the driver won't
+				 * create Processor devices when JBOD failed
+				 * ReportLun and lun-skip is turned ON.
+				 */
+				targetp->max_lun = 1;
+
+				targetp->targetFlags &= ~FC_RETRY_RPTLUN;
+				if (targetp->tmofunc.function) {
+					lpfc_stop_timer((struct clk_data *)
+							targetp->tmofunc.data);
+				}
+				lpfc_set_failmask(phba, ndlp, LPFC_DEV_RPTLUN,
+						  LPFC_CLR_BITMASK);
+
+				list_for_each_safe(curr, next,
+						   &targetp->lunlist) {
+					lunp = list_entry(curr, LPFCSCSILUN_t,
+							  list);
+					lunp->pnode = (LPFC_NODELIST_t *) ndlp;
+				}
+			}
+		}
+	}
+
+	/* We cannot free RptLunData buffer if we already save it in 
+	 * the target structure */
+	if (mp != targetp->RptLunData) {
+		lpfc_page_free(phba, mp->virt, mp->phys);
+		kfree(mp);
+	}
+	lpfc_free_scsi_buf(lpfc_cmd);
+	return;
+}
+
+/*****************************************************************************/
+/*
+ * NAME:     lpfc_disc_retry_rptlun
+ *
+ * FUNCTION: Try to send report lun again.  Note that NODELIST could have
+ *           changed from the last failed repotlun cmd.  That's why we have
+ *           to get the latest ndlp before calling lpfc_disc_issue_rptlun. 
+ *
+ * EXECUTION ENVIRONMENT: 
+ *           During device discovery
+ *
+ */
+/*****************************************************************************/
+void
+lpfc_disc_retry_rptlun(unsigned long ptr)
+{
+	lpfcHBA_t *phba;
+	LPFCSCSITARGET_t *targetp;
+	LPFC_NODELIST_t *ndlp;
+	struct clk_data *clkData;
+	unsigned long iflag;
+
+	clkData = (struct clk_data *)ptr;
+	phba = clkData->phba;
+	LPFC_DRVR_LOCK(phba, iflag);
+       	if (clkData->flags & TM_CANCELED) {
+		list_del((struct list_head *)clkData);
+		kfree(clkData);	
+		goto out;
+	}
+
+	targetp = (LPFCSCSITARGET_t *) clkData->clData1;
+	clkData->timeObj->function = 0;
+	list_del((struct list_head *)clkData);
+	kfree(clkData);
+
+	ndlp = (LPFC_NODELIST_t *) targetp->pcontext;
+	if (ndlp) {
+		lpfc_disc_issue_rptlun(phba, ndlp);
+	}
+out:
+	LPFC_DRVR_UNLOCK(phba, iflag);
+}
+
+/*****************************************************************************/
+/*
+ * NAME:     lpfc_disc_issue_rptlun
+ *
+ * FUNCTION: Issue a RPTLUN SCSI command to a newly mapped FCP device
+ *           to determine LUN addressing mode
+ *
+ * EXECUTION ENVIRONMENT: 
+ *           During device discovery
+ *
+ */
+/*****************************************************************************/
+int
+lpfc_disc_issue_rptlun(lpfcHBA_t * phba, LPFC_NODELIST_t * nlp)
+{
+	LPFC_SLI_t *psli;
+	LPFC_SCSI_BUF_t *lpfc_cmd;
+	LPFC_IOCBQ_t *piocbq;
+
+	/* Issue Report LUN on NPort <nlp_DID> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0207,
+			lpfc_mes0207,
+			lpfc_msgBlk0207.msgPreambleStr,
+			nlp->nlp_DID, nlp->nlp_failMask, nlp->nlp_state,
+			nlp->nlp_rpi);
+
+	psli = &phba->sli;
+	lpfc_cmd = lpfc_build_scsi_cmd(phba, nlp, FCP_SCSI_REPORT_LUNS, 0);
+	if (lpfc_cmd) {
+		piocbq = &lpfc_cmd->cur_iocbq;
+		piocbq->iocb_cmpl = lpfc_disc_cmpl_rptlun;
+
+		if (lpfc_sli_issue_iocb(phba, &psli->ring[psli->fcp_ring],
+					piocbq,
+					SLI_IOCB_USE_TXQ) == IOCB_ERROR) {
+			lpfc_page_free(phba,
+				       ((DMABUF_t *) piocbq->context2)->virt,
+				       ((DMABUF_t *) piocbq->context2)->phys);
+			kfree(piocbq->context2);
+			lpfc_free_scsi_buf(lpfc_cmd);
+			return (1);
+		}
+		if (lpfc_cmd->pLun->pTarget) {
+			lpfc_cmd->pLun->pTarget->rptLunState =
+			    REPORT_LUN_ONGOING;
+		}
+	}
+	return (0);
+}
+
+/*
+ *   lpfc_set_failmask
+ *   Set, or clear, failMask bits in LPFC_NODELIST_t
+ */
+void
+lpfc_set_failmask(lpfcHBA_t * phba,
+		  LPFC_NODELIST_t * ndlp, uint32_t bitmask, uint32_t flag)
+{
+	LPFCSCSITARGET_t *targetp;
+	LPFCSCSILUN_t *lunp;
+	uint32_t oldmask;
+	uint32_t changed;
+	struct list_head *curr, *next;
+
+	/* Failmask change on NPort <nlp_DID> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0208,
+			lpfc_mes0208,
+			lpfc_msgBlk0208.msgPreambleStr,
+			ndlp->nlp_DID, ndlp->nlp_failMask, bitmask, flag);
+
+	targetp = ndlp->nlp_Target;
+	if (flag == LPFC_SET_BITMASK) {
+		oldmask = ndlp->nlp_failMask;
+		/* Set failMask event */
+		ndlp->nlp_failMask |= bitmask;
+		if (oldmask != ndlp->nlp_failMask) {
+			changed = 1;
+		} else {
+			changed = 0;
+		}
+
+		if (oldmask == 0) {
+
+			/* Pause the scheduler if this is a FCP node */
+			if (targetp) {
+				lpfc_sched_pause_target(targetp);
+			}
+		}
+	} else {
+		/* Clear failMask event */
+		ndlp->nlp_failMask &= ~bitmask;
+		changed = 1;
+	}
+
+	/* If mask has changed, there may be more to do */
+	if (changed) {
+		/* If the map was / is a mapped target, probagate change to 
+		 * all LPFCSCSILUN_t's
+		 */
+		if (targetp) {
+			list_for_each_safe(curr, next, &targetp->lunlist) {
+				lunp = list_entry(curr, LPFCSCSILUN_t, list);
+				if (flag == LPFC_SET_BITMASK) {
+					/* Set failMask event */
+					lunp->failMask |= bitmask;
+				} else {
+					/* Clear failMask event */
+					lunp->failMask &= ~bitmask;
+				}
+			}
+
+			/* If the failMask changes to 0, resume the scheduler */
+			if (ndlp->nlp_failMask == 0) {
+				lpfc_sched_continue_target(targetp);
+			}
+		}
+	}
+	return;
+}
+
+/*
+ *  Ignore completion for all IOCBs on tx and txcmpl queue for ELS 
+ *  ring the match the sppecified nodelist.
+ */
+void
+lpfc_free_tx(lpfcHBA_t * phba, LPFC_NODELIST_t * ndlp)
+{
+	LPFC_SLI_t *psli;
+	LPFC_IOCBQ_t *iocb, *next_iocb;
+	IOCB_t *icmd;
+	LPFC_SLI_RING_t *pring;
+	struct list_head *curr, *next;
+	struct lpfc_dmabuf *pCmd, *pRsp;
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_ELS_RING];
+
+	/* Error matching iocb on txq or txcmplq 
+	 * First check the txq.
+	 */
+	list_for_each_safe(curr, next, &pring->txq) {
+		next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+		iocb = next_iocb;
+		if (iocb->context1 != ndlp) {
+			continue;
+		}
+		icmd = &iocb->iocb;
+		if ((icmd->ulpCommand == CMD_ELS_REQUEST64_CR) ||
+		    (icmd->ulpCommand == CMD_XMIT_ELS_RSP64_CX)) {
+
+			list_del(&iocb->list);
+			pring->txq_cnt--;
+			lpfc_els_free_iocb(phba, iocb);
+		}
+	}
+
+	/* Next check the txcmplq */
+	list_for_each_safe(curr, next, &pring->txcmplq) {
+		next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+		iocb = next_iocb;
+		if (iocb->context1 != ndlp) {
+			continue;
+		}
+		icmd = &iocb->iocb;
+		if ((icmd->ulpCommand == CMD_ELS_REQUEST64_CR) ||
+		    (icmd->ulpCommand == CMD_XMIT_ELS_RSP64_CX)) {
+
+			iocb->iocb_cmpl = 0;
+			/* context2 = cmd, context2->next = rsp, context3 =
+			   bpl */
+			pCmd = (struct lpfc_dmabuf *)iocb->context2;
+			if (pCmd) {
+				/* Free the response IOCB before handling the
+				   command. */
+				pRsp = list_entry(pCmd->list.next, DMABUF_t, list); 
+				if (pRsp) {
+					/* Delay before releasing rsp buffer to
+					 * give UNREG mbox a chance to take
+					 * effect.
+					 */
+					list_add(&pRsp->list, &phba->free_buf_list);
+					lpfc_start_timer(phba, 1,
+							 &phba->buf_tmo,
+							 lpfc_put_buf,
+							 (unsigned
+							  long)pRsp, 0);
+				}
+				lpfc_mbuf_free(phba,
+					       pCmd->virt, 
+					       pCmd->phys);
+				kfree(pCmd);
+			}
+
+			if (iocb->context3) {
+				lpfc_mbuf_free(phba,
+					       ((DMABUF_t *) iocb->context3)->
+					       virt,
+					       ((DMABUF_t *) iocb->context3)->
+					       phys);
+				kfree(iocb->context3);
+			}
+		}
+	}
+
+	return;
+}
+
+/*****************************************************************************/
+/*
+ * NAME:     lpfc_put_buf
+ *
+ * FUNCTION: Fibre Channel driver delayed buffer release routine.
+ *
+ * EXECUTION ENVIRONMENT: interrupt only
+ *
+ * CALLED FROM:
+ *      Timer function
+ *
+ * RETURNS:  
+ *      none
+ */
+/*****************************************************************************/
+void
+lpfc_put_buf(unsigned long ptr)
+{
+	lpfcHBA_t *phba;
+	struct clk_data *clkData;
+	unsigned long iflag;
+	struct lpfc_dmabuf *some_buf;
+
+	clkData = (struct clk_data *)ptr;
+	phba = clkData->phba;
+	LPFC_DRVR_LOCK(phba, iflag);
+       	if (clkData->flags & TM_CANCELED) {
+		list_del((struct list_head *)clkData);
+		kfree(clkData);	
+		goto out;
+        }
+
+	clkData->timeObj->function = 0;
+	list_del((struct list_head *)clkData);
+
+	some_buf = (struct lpfc_dmabuf *)clkData->clData1;
+	list_del(&some_buf->list);
+	lpfc_mbuf_free(phba, some_buf->virt,
+		       some_buf->phys);
+	kfree((void *)some_buf);
+	kfree(clkData);
+out:
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	return;
+}
+
+/*
+ * This routine handles processing a NameServer REG_LOGIN mailbox
+ * command upon completion. It is setup in the LPFC_MBOXQ
+ * as the completion routine when the command is
+ * handed off to the SLI layer.
+ */
+void
+lpfc_mbx_cmpl_fdmi_reg_login(lpfcHBA_t * phba, LPFC_MBOXQ_t * pmb)
+{
+	LPFC_SLI_t *psli;
+	MAILBOX_t *mb;
+	DMABUF_t *mp;
+	LPFC_NODELIST_t *ndlp;
+	lpfcCfgParam_t *clp;
+
+	clp = &phba->config[0];
+	psli = &phba->sli;
+	mb = &pmb->mb;
+
+	ndlp = (LPFC_NODELIST_t *) pmb->context2;
+	mp = (DMABUF_t *) (pmb->context1);
+
+	pmb->context1 = 0;
+	ndlp->nlp_rpi = mb->un.varWords[0];
+	ndlp->nlp_type |= NLP_FABRIC;
+	lpfc_nlp_unmapped(phba, ndlp);
+	ndlp->nlp_state = NLP_STE_PRLI_COMPL;
+
+	/* Start issuing Fabric-Device Management Interface (FDMI)
+	 * command to 0xfffffa (FDMI well known port)
+	 */
+	if (clp[LPFC_CFG_FDMI_ON].a_current == 1) {
+		lpfc_fdmi_cmd(phba, ndlp, SLI_MGMT_DHBA);
+	} else {
+		/*
+		 * Delay issuing FDMI command if fdmi-on=2
+		 * (supporting RPA/hostnmae)
+		 */
+		lpfc_start_timer(phba, 60, &phba->fc_fdmitmo, lpfc_fdmi_tmo,
+				 (unsigned long)ndlp, (unsigned long)0);
+	}
+
+	lpfc_mbuf_free(phba, mp->virt, mp->phys);
+	kfree(mp);
+	lpfc_mbox_free(phba, pmb);
+
+	return;
+}
+
+/*
+ * This routine finds a node by sequentially searching each of the node lists
+ * maintained in the hba structure for that node that contains the caller's
+ * rpi.  If found, the node list pointer is returned.  Otherwise NULL is
+ * returned.
+ */
+LPFC_NODELIST_t *
+lpfc_findnode_rpi(lpfcHBA_t * phba, uint16_t rpi)
+{
+	LPFC_NODELIST_t *ndlp;
+	struct list_head *pos, *next;
+
+	/*
+	 * The lpfc_els module calls this routine for GEN_REQUEST iocbs. 
+	 * Start the sequential search with the plogi list. 
+	 */
+	list_for_each_safe(pos, next, &phba->fc_plogi_list) {
+		ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+		if (ndlp->nlp_rpi == rpi)
+			return ndlp;
+	}
+
+	list_for_each_safe(pos, next, &phba->fc_adisc_list) {
+		ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+		if (ndlp->nlp_rpi == rpi)
+			return ndlp;
+	}
+
+	list_for_each_safe(pos, next, &phba->fc_nlpunmap_list) {
+		ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+		if (ndlp->nlp_rpi == rpi)
+			return ndlp;
+	}
+
+	list_for_each_safe(pos, next, &phba->fc_nlpmap_list) {
+		ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+		if (ndlp->nlp_rpi == rpi)
+			return ndlp;
+	}
+
+	/* No match found */
+	return ((LPFC_NODELIST_t *) 0);
+}
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_hw.h linux-8155/drivers/addon/lpfc/lpfc_hw.h
--- linux-8152/drivers/addon/lpfc/lpfc_hw.h
+++ linux-8155/drivers/addon/lpfc/lpfc_hw.h
@@ -0,0 +1,2776 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_hw.h 502 2006-04-04 17:11:23Z sf_support $
+ */
+
+#ifndef  _H_LPFC_HW
+#define _H_LPFC_HW
+
+#define FDMI_DID        ((uint32_t)0xfffffa)
+#define NameServer_DID  ((uint32_t)0xfffffc)
+#define SCR_DID         ((uint32_t)0xfffffd)
+#define Fabric_DID      ((uint32_t)0xfffffe)
+#define Bcast_DID       ((uint32_t)0xffffff)
+#define Mask_DID        ((uint32_t)0xffffff)
+#define CT_DID_MASK     ((uint32_t)0xffff00)
+#define Fabric_DID_MASK ((uint32_t)0xfff000)
+#define WELL_KNOWN_DID_MASK ((uint32_t)0xfffff0)
+
+#define PT2PT_LocalID   ((uint32_t)1)
+#define PT2PT_RemoteID  ((uint32_t)2)
+
+#define FF_DEF_EDTOV          2000	/* Default E_D_TOV (2000ms) */
+#define FF_DEF_ALTOV            15	/* Default AL_TIME (15ms) */
+#define FF_DEF_RATOV             2	/* Default RA_TOV (2s) */
+#define FF_DEF_ARBTOV         1900	/* Default ARB_TOV (1900ms) */
+
+#define LPFC_BUF_RING0        64	/* Number of buffers to post to RING
+					   0 */
+
+#define FCELSSIZE             1024	/* maximum ELS transfer size */
+
+#define LPFC_FCP_RING            0	/* ring 2 for FCP initiator commands */
+#define LPFC_IP_RING             1	/* ring 1 for IP commands */
+#define LPFC_ELS_RING            2	/* ring 0 for ELS commands */
+#define LPFC_FCP_NEXT_RING       3
+
+#define SLI2_IOCB_CMD_R0_ENTRIES    172	/* SLI-2 FCP command ring entries */
+#define SLI2_IOCB_RSP_R0_ENTRIES    134	/* SLI-2 FCP response ring entries */
+#define SLI2_IOCB_CMD_R1_ENTRIES      4	/* SLI-2 IP command ring entries */
+#define SLI2_IOCB_RSP_R1_ENTRIES      4	/* SLI-2 IP response ring entries */
+#define SLI2_IOCB_CMD_R1XTRA_ENTRIES 36	/* SLI-2 extra FCP cmd ring entries */
+#define SLI2_IOCB_RSP_R1XTRA_ENTRIES 52	/* SLI-2 extra FCP rsp ring entries */
+#define SLI2_IOCB_CMD_R2_ENTRIES     20	/* SLI-2 ELS command ring entries */
+#define SLI2_IOCB_RSP_R2_ENTRIES     20	/* SLI-2 ELS response ring entries */
+#define SLI2_IOCB_CMD_R3_ENTRIES      0
+#define SLI2_IOCB_RSP_R3_ENTRIES      0
+#define SLI2_IOCB_CMD_R3XTRA_ENTRIES 24
+#define SLI2_IOCB_RSP_R3XTRA_ENTRIES 32
+
+/* Common Transport structures and definitions */
+
+union CtRevisionId {
+	/* Structure is in Big Endian format */
+	struct {
+		uint32_t Revision:8;
+		uint32_t InId:24;
+	} bits;
+	uint32_t word;
+};
+
+union CtCommandResponse {
+	/* Structure is in Big Endian format */
+	struct {
+		uint32_t CmdRsp:16;
+		uint32_t Size:16;
+	} bits;
+	uint32_t word;
+};
+
+typedef struct SliCtRequest {
+	/* Structure is in Big Endian format */
+	union CtRevisionId RevisionId;
+	uint8_t FsType;
+	uint8_t FsSubType;
+	uint8_t Options;
+	uint8_t Rsrvd1;
+	union CtCommandResponse CommandResponse;
+	uint8_t Rsrvd2;
+	uint8_t ReasonCode;
+	uint8_t Explanation;
+	uint8_t VendorUnique;
+
+	union {
+		uint32_t PortID;
+		struct gid {
+			uint8_t PortType;	/* for GID_PT requests */
+			uint8_t DomainScope;
+			uint8_t AreaScope;
+			uint8_t Fc4Type;	/* for GID_FT requests */
+		} gid;
+		struct rft {
+			uint32_t PortId;	/* For RFT_ID requests */
+
+#if __BIG_ENDIAN
+			uint32_t rsvd0:16;
+			uint32_t rsvd1:7;
+			uint32_t fcpReg:1;	/* Type 8 */
+			uint32_t rsvd2:2;
+			uint32_t ipReg:1;	/* Type 5 */
+			uint32_t rsvd3:5;
+#else	/*  __LITTLE_ENDIAN */
+			uint32_t rsvd0:16;
+			uint32_t fcpReg:1;	/* Type 8 */
+			uint32_t rsvd1:7;
+			uint32_t rsvd3:5;
+			uint32_t ipReg:1;	/* Type 5 */
+			uint32_t rsvd2:2;
+#endif
+
+			uint32_t rsvd[7];
+		} rft;
+		struct rnn {
+			uint32_t PortId;	/* For RNN_ID requests */
+			uint8_t wwnn[8];
+		} rnn;
+		struct rsnn {	/* For RSNN_ID requests */
+			uint8_t wwnn[8];
+			uint8_t len;
+			uint8_t symbname[255];
+		} rsnn;
+	} un;
+} SLI_CT_REQUEST, *PSLI_CT_REQUEST;
+
+#define  SLI_CT_REVISION        1
+#define  GID_REQUEST_SZ         (sizeof(SLI_CT_REQUEST) - 260)
+#define  RFT_REQUEST_SZ         (sizeof(SLI_CT_REQUEST) - 228)
+#define  RNN_REQUEST_SZ         (sizeof(SLI_CT_REQUEST) - 252)
+#define  RSNN_REQUEST_SZ        (sizeof(SLI_CT_REQUEST))
+
+/*
+ * FsType Definitions
+ */
+
+#define  SLI_CT_MANAGEMENT_SERVICE        0xFA
+#define  SLI_CT_TIME_SERVICE              0xFB
+#define  SLI_CT_DIRECTORY_SERVICE         0xFC
+#define  SLI_CT_FABRIC_CONTROLLER_SERVICE 0xFD
+
+/*
+ * Directory Service Subtypes
+ */
+
+#define  SLI_CT_DIRECTORY_NAME_SERVER     0x02
+
+/*
+ * Response Codes
+ */
+
+#define  SLI_CT_RESPONSE_FS_RJT           0x8001
+#define  SLI_CT_RESPONSE_FS_ACC           0x8002
+
+/*
+ * Reason Codes
+ */
+
+#define  SLI_CT_NO_ADDITIONAL_EXPL	  0x0
+#define  SLI_CT_INVALID_COMMAND           0x01
+#define  SLI_CT_INVALID_VERSION           0x02
+#define  SLI_CT_LOGICAL_ERROR             0x03
+#define  SLI_CT_INVALID_IU_SIZE           0x04
+#define  SLI_CT_LOGICAL_BUSY              0x05
+#define  SLI_CT_PROTOCOL_ERROR            0x07
+#define  SLI_CT_UNABLE_TO_PERFORM_REQ     0x09
+#define  SLI_CT_REQ_NOT_SUPPORTED         0x0b
+#define  SLI_CT_HBA_INFO_NOT_REGISTERED	  0x10
+#define  SLI_CT_MULTIPLE_HBA_ATTR_OF_SAME_TYPE  0x11
+#define  SLI_CT_INVALID_HBA_ATTR_BLOCK_LEN      0x12
+#define  SLI_CT_HBA_ATTR_NOT_PRESENT	  0x13
+#define  SLI_CT_PORT_INFO_NOT_REGISTERED  0x20
+#define  SLI_CT_MULTIPLE_PORT_ATTR_OF_SAME_TYPE 0x21
+#define  SLI_CT_INVALID_PORT_ATTR_BLOCK_LEN     0x22
+#define  SLI_CT_VENDOR_UNIQUE             0xff
+
+/*
+ * Name Server SLI_CT_UNABLE_TO_PERFORM_REQ Explanations
+ */
+
+#define  SLI_CT_NO_PORT_ID                0x01
+#define  SLI_CT_NO_PORT_NAME              0x02
+#define  SLI_CT_NO_NODE_NAME              0x03
+#define  SLI_CT_NO_CLASS_OF_SERVICE       0x04
+#define  SLI_CT_NO_IP_ADDRESS             0x05
+#define  SLI_CT_NO_IPA                    0x06
+#define  SLI_CT_NO_FC4_TYPES              0x07
+#define  SLI_CT_NO_SYMBOLIC_PORT_NAME     0x08
+#define  SLI_CT_NO_SYMBOLIC_NODE_NAME     0x09
+#define  SLI_CT_NO_PORT_TYPE              0x0A
+#define  SLI_CT_ACCESS_DENIED             0x10
+#define  SLI_CT_INVALID_PORT_ID           0x11
+#define  SLI_CT_DATABASE_EMPTY            0x12
+
+/*
+ * Name Server Command Codes
+ */
+
+#define  SLI_CTNS_GA_NXT      0x0100
+#define  SLI_CTNS_GPN_ID      0x0112
+#define  SLI_CTNS_GNN_ID      0x0113
+#define  SLI_CTNS_GCS_ID      0x0114
+#define  SLI_CTNS_GFT_ID      0x0117
+#define  SLI_CTNS_GSPN_ID     0x0118
+#define  SLI_CTNS_GPT_ID      0x011A
+#define  SLI_CTNS_GID_PN      0x0121
+#define  SLI_CTNS_GID_NN      0x0131
+#define  SLI_CTNS_GIP_NN      0x0135
+#define  SLI_CTNS_GIPA_NN     0x0136
+#define  SLI_CTNS_GSNN_NN     0x0139
+#define  SLI_CTNS_GNN_IP      0x0153
+#define  SLI_CTNS_GIPA_IP     0x0156
+#define  SLI_CTNS_GID_FT      0x0171
+#define  SLI_CTNS_GID_PT      0x01A1
+#define  SLI_CTNS_RPN_ID      0x0212
+#define  SLI_CTNS_RNN_ID      0x0213
+#define  SLI_CTNS_RCS_ID      0x0214
+#define  SLI_CTNS_RFT_ID      0x0217
+#define  SLI_CTNS_RSPN_ID     0x0218
+#define  SLI_CTNS_RPT_ID      0x021A
+#define  SLI_CTNS_RIP_NN      0x0235
+#define  SLI_CTNS_RIPA_NN     0x0236
+#define  SLI_CTNS_RSNN_NN     0x0239
+#define  SLI_CTNS_DA_ID       0x0300
+
+/*
+ * Port Types
+ */
+
+#define  SLI_CTPT_N_PORT      0x01
+#define  SLI_CTPT_NL_PORT     0x02
+#define  SLI_CTPT_FNL_PORT    0x03
+#define  SLI_CTPT_IP          0x04
+#define  SLI_CTPT_FCP         0x08
+#define  SLI_CTPT_NX_PORT     0x7F
+#define  SLI_CTPT_F_PORT      0x81
+#define  SLI_CTPT_FL_PORT     0x82
+#define  SLI_CTPT_E_PORT      0x84
+
+#define SLI_CT_LAST_ENTRY     0x80000000
+
+#define FL_ALPA    0x00		/* AL_PA of FL_Port */
+
+/* Fibre Channel Service Parameter definitions */
+
+#define FC_PH_4_0   6		/* FC-PH version 4.0 */
+#define FC_PH_4_1   7		/* FC-PH version 4.1 */
+#define FC_PH_4_2   8		/* FC-PH version 4.2 */
+#define FC_PH_4_3   9		/* FC-PH version 4.3 */
+
+#define FC_PH_LOW   8		/* Lowest supported FC-PH version */
+#define FC_PH_HIGH  9		/* Highest supported FC-PH version */
+#define FC_PH3   0x20		/* FC-PH-3 version */
+
+#define FF_FRAME_SIZE     2048
+
+typedef struct _NAME_TYPE {
+#if __BIG_ENDIAN
+	uint8_t nameType:4;	/* FC Word 0, bit 28:31 */
+	uint8_t IEEEextMsn:4;	/* FC Word 0, bit 24:27, bit 8:11 of IEEE ext */
+#else	/*  __LITTLE_ENDIAN */
+	uint8_t IEEEextMsn:4;	/* FC Word 0, bit 24:27, bit 8:11 of IEEE ext */
+	uint8_t nameType:4;	/* FC Word 0, bit 28:31 */
+#endif
+
+#define NAME_IEEE           0x1	/* IEEE name - nameType */
+#define NAME_IEEE_EXT       0x2	/* IEEE extended name */
+#define NAME_FC_TYPE        0x3	/* FC native name type */
+#define NAME_IP_TYPE        0x4	/* IP address */
+#define NAME_CCITT_TYPE     0xC
+#define NAME_CCITT_GR_TYPE  0xE
+	uint8_t IEEEextLsb;	/* FC Word 0, bit 16:23, IEEE extended Lsb */
+	uint8_t IEEE[6];	/* FC IEEE address */
+} NAME_TYPE;
+
+typedef struct _CSP {
+	uint8_t fcphHigh;	/* FC Word 0, byte 0 */
+	uint8_t fcphLow;
+	uint8_t bbCreditMsb;
+	uint8_t bbCreditlsb;	/* FC Word 0, byte 3 */
+
+#if __BIG_ENDIAN
+	uint16_t increasingOffset:1;	/* FC Word 1, bit 31 */
+	uint16_t randomOffset:1;	/* FC Word 1, bit 30 */
+	uint16_t word1Reserved2:1;	/* FC Word 1, bit 29 */
+	uint16_t fPort:1;	/* FC Word 1, bit 28 */
+	uint16_t altBbCredit:1;	/* FC Word 1, bit 27 */
+	uint16_t edtovResolution:1;	/* FC Word 1, bit 26 */
+	uint16_t multicast:1;	/* FC Word 1, bit 25 */
+	uint16_t broadcast:1;	/* FC Word 1, bit 24 */
+
+	uint16_t huntgroup:1;	/* FC Word 1, bit 23 */
+	uint16_t simplex:1;	/* FC Word 1, bit 22 */
+	uint16_t word1Reserved1:3;	/* FC Word 1, bit 21:19 */
+	uint16_t dhd:1;		/* FC Word 1, bit 18 */
+	uint16_t contIncSeqCnt:1;	/* FC Word 1, bit 17 */
+	uint16_t payloadlength:1;	/* FC Word 1, bit 16 */
+#else	/*  __LITTLE_ENDIAN */
+	uint16_t broadcast:1;	/* FC Word 1, bit 24 */
+	uint16_t multicast:1;	/* FC Word 1, bit 25 */
+	uint16_t edtovResolution:1;	/* FC Word 1, bit 26 */
+	uint16_t altBbCredit:1;	/* FC Word 1, bit 27 */
+	uint16_t fPort:1;	/* FC Word 1, bit 28 */
+	uint16_t word1Reserved2:1;	/* FC Word 1, bit 29 */
+	uint16_t randomOffset:1;	/* FC Word 1, bit 30 */
+	uint16_t increasingOffset:1;	/* FC Word 1, bit 31 */
+
+	uint16_t payloadlength:1;	/* FC Word 1, bit 16 */
+	uint16_t contIncSeqCnt:1;	/* FC Word 1, bit 17 */
+	uint16_t dhd:1;		/* FC Word 1, bit 18 */
+	uint16_t word1Reserved1:3;	/* FC Word 1, bit 21:19 */
+	uint16_t simplex:1;	/* FC Word 1, bit 22 */
+	uint16_t huntgroup:1;	/* FC Word 1, bit 23 */
+#endif
+
+	uint8_t bbRcvSizeMsb;	/* Upper nibble is reserved */
+	uint8_t bbRcvSizeLsb;	/* FC Word 1, byte 3 */
+	union {
+		struct {
+			uint8_t word2Reserved1;	/* FC Word 2 byte 0 */
+
+			uint8_t totalConcurrSeq;	/* FC Word 2 byte 1 */
+			uint8_t roByCategoryMsb;	/* FC Word 2 byte 2 */
+
+			uint8_t roByCategoryLsb;	/* FC Word 2 byte 3 */
+		} nPort;
+		uint32_t r_a_tov;	/* R_A_TOV must be in B.E. format */
+	} w2;
+
+	uint32_t e_d_tov;	/* E_D_TOV must be in B.E. format */
+} CSP;
+
+typedef struct _CLASS_PARMS {
+#if __BIG_ENDIAN
+	uint8_t classValid:1;	/* FC Word 0, bit 31 */
+	uint8_t intermix:1;	/* FC Word 0, bit 30 */
+	uint8_t stackedXparent:1;	/* FC Word 0, bit 29 */
+	uint8_t stackedLockDown:1;	/* FC Word 0, bit 28 */
+	uint8_t seqDelivery:1;	/* FC Word 0, bit 27 */
+	uint8_t word0Reserved1:3;	/* FC Word 0, bit 24:26 */
+#else	/*  __LITTLE_ENDIAN */
+	uint8_t word0Reserved1:3;	/* FC Word 0, bit 24:26 */
+	uint8_t seqDelivery:1;	/* FC Word 0, bit 27 */
+	uint8_t stackedLockDown:1;	/* FC Word 0, bit 28 */
+	uint8_t stackedXparent:1;	/* FC Word 0, bit 29 */
+	uint8_t intermix:1;	/* FC Word 0, bit 30 */
+	uint8_t classValid:1;	/* FC Word 0, bit 31 */
+
+#endif
+
+	uint8_t word0Reserved2;	/* FC Word 0, bit 16:23 */
+
+#if __BIG_ENDIAN
+	uint8_t iCtlXidReAssgn:2;	/* FC Word 0, Bit 14:15 */
+	uint8_t iCtlInitialPa:2;	/* FC Word 0, bit 12:13 */
+	uint8_t iCtlAck0capable:1;	/* FC Word 0, bit 11 */
+	uint8_t iCtlAckNcapable:1;	/* FC Word 0, bit 10 */
+	uint8_t word0Reserved3:2;	/* FC Word 0, bit  8: 9 */
+#else	/*  __LITTLE_ENDIAN */
+	uint8_t word0Reserved3:2;	/* FC Word 0, bit  8: 9 */
+	uint8_t iCtlAckNcapable:1;	/* FC Word 0, bit 10 */
+	uint8_t iCtlAck0capable:1;	/* FC Word 0, bit 11 */
+	uint8_t iCtlInitialPa:2;	/* FC Word 0, bit 12:13 */
+	uint8_t iCtlXidReAssgn:2;	/* FC Word 0, Bit 14:15 */
+#endif
+
+	uint8_t word0Reserved4;	/* FC Word 0, bit  0: 7 */
+
+#if __BIG_ENDIAN
+	uint8_t rCtlAck0capable:1;	/* FC Word 1, bit 31 */
+	uint8_t rCtlAckNcapable:1;	/* FC Word 1, bit 30 */
+	uint8_t rCtlXidInterlck:1;	/* FC Word 1, bit 29 */
+	uint8_t rCtlErrorPolicy:2;	/* FC Word 1, bit 27:28 */
+	uint8_t word1Reserved1:1;	/* FC Word 1, bit 26 */
+	uint8_t rCtlCatPerSeq:2;	/* FC Word 1, bit 24:25 */
+#else	/*  __LITTLE_ENDIAN */
+	uint8_t rCtlCatPerSeq:2;	/* FC Word 1, bit 24:25 */
+	uint8_t word1Reserved1:1;	/* FC Word 1, bit 26 */
+	uint8_t rCtlErrorPolicy:2;	/* FC Word 1, bit 27:28 */
+	uint8_t rCtlXidInterlck:1;	/* FC Word 1, bit 29 */
+	uint8_t rCtlAckNcapable:1;	/* FC Word 1, bit 30 */
+	uint8_t rCtlAck0capable:1;	/* FC Word 1, bit 31 */
+#endif
+
+	uint8_t word1Reserved2;	/* FC Word 1, bit 16:23 */
+	uint8_t rcvDataSizeMsb;	/* FC Word 1, bit  8:15 */
+	uint8_t rcvDataSizeLsb;	/* FC Word 1, bit  0: 7 */
+
+	uint8_t concurrentSeqMsb;	/* FC Word 2, bit 24:31 */
+	uint8_t concurrentSeqLsb;	/* FC Word 2, bit 16:23 */
+	uint8_t EeCreditSeqMsb;	/* FC Word 2, bit  8:15 */
+	uint8_t EeCreditSeqLsb;	/* FC Word 2, bit  0: 7 */
+
+	uint8_t openSeqPerXchgMsb;	/* FC Word 3, bit 24:31 */
+	uint8_t openSeqPerXchgLsb;	/* FC Word 3, bit 16:23 */
+	uint8_t word3Reserved1;	/* Fc Word 3, bit  8:15 */
+	uint8_t word3Reserved2;	/* Fc Word 3, bit  0: 7 */
+} CLASS_PARMS;
+
+typedef struct _SERV_PARM {	/* Structure is in Big Endian format */
+	CSP cmn;
+	NAME_TYPE portName;
+	NAME_TYPE nodeName;
+	CLASS_PARMS cls1;
+	CLASS_PARMS cls2;
+	CLASS_PARMS cls3;
+	CLASS_PARMS cls4;
+	uint8_t vendorVersion[16];
+} SERV_PARM, *PSERV_PARM;
+
+/*
+ *  Extended Link Service LS_COMMAND codes (Payload Word 0)
+ */
+#if __BIG_ENDIAN
+#define ELS_CMD_MASK      0xffff0000
+#define ELS_RSP_MASK      0xff000000
+#define ELS_CMD_LS_RJT    0x01000000
+#define ELS_CMD_ACC       0x02000000
+#define ELS_CMD_PLOGI     0x03000000
+#define ELS_CMD_FLOGI     0x04000000
+#define ELS_CMD_LOGO      0x05000000
+#define ELS_CMD_ABTX      0x06000000
+#define ELS_CMD_RCS       0x07000000
+#define ELS_CMD_RES       0x08000000
+#define ELS_CMD_RSS       0x09000000
+#define ELS_CMD_RSI       0x0A000000
+#define ELS_CMD_ESTS      0x0B000000
+#define ELS_CMD_ESTC      0x0C000000
+#define ELS_CMD_ADVC      0x0D000000
+#define ELS_CMD_RTV       0x0E000000
+#define ELS_CMD_RLS       0x0F000000
+#define ELS_CMD_ECHO      0x10000000
+#define ELS_CMD_TEST      0x11000000
+#define ELS_CMD_RRQ       0x12000000
+#define ELS_CMD_PRLI      0x20100014
+#define ELS_CMD_PRLO      0x21100014
+#define ELS_CMD_PRLO_ACC  0x02100014
+#define ELS_CMD_PDISC     0x50000000
+#define ELS_CMD_FDISC     0x51000000
+#define ELS_CMD_ADISC     0x52000000
+#define ELS_CMD_FARP      0x54000000
+#define ELS_CMD_FARPR     0x55000000
+#define ELS_CMD_FAN       0x60000000
+#define ELS_CMD_RSCN      0x61040000
+#define ELS_CMD_SCR       0x62000000
+#define ELS_CMD_RNID      0x78000000
+#else	/*  __LITTLE_ENDIAN */
+#define ELS_CMD_MASK      0xffff
+#define ELS_RSP_MASK      0xff
+#define ELS_CMD_LS_RJT    0x01
+#define ELS_CMD_ACC       0x02
+#define ELS_CMD_PLOGI     0x03
+#define ELS_CMD_FLOGI     0x04
+#define ELS_CMD_LOGO      0x05
+#define ELS_CMD_ABTX      0x06
+#define ELS_CMD_RCS       0x07
+#define ELS_CMD_RES       0x08
+#define ELS_CMD_RSS       0x09
+#define ELS_CMD_RSI       0x0A
+#define ELS_CMD_ESTS      0x0B
+#define ELS_CMD_ESTC      0x0C
+#define ELS_CMD_ADVC      0x0D
+#define ELS_CMD_RTV       0x0E
+#define ELS_CMD_RLS       0x0F
+#define ELS_CMD_ECHO      0x10
+#define ELS_CMD_TEST      0x11
+#define ELS_CMD_RRQ       0x12
+#define ELS_CMD_PRLI      0x14001020
+#define ELS_CMD_PRLO      0x14001021
+#define ELS_CMD_PRLO_ACC  0x14001002
+#define ELS_CMD_PDISC     0x50
+#define ELS_CMD_FDISC     0x51
+#define ELS_CMD_ADISC     0x52
+#define ELS_CMD_FARP      0x54
+#define ELS_CMD_FARPR     0x55
+#define ELS_CMD_FAN       0x60
+#define ELS_CMD_RSCN      0x0461
+#define ELS_CMD_SCR       0x62
+#define ELS_CMD_RNID      0x78
+#endif
+
+/*
+ *  LS_RJT Payload Definition
+ */
+
+typedef struct _LS_RJT {	/* Structure is in Big Endian format */
+	union {
+		uint32_t lsRjtError;
+		struct {
+			uint8_t lsRjtRsvd0;	/* FC Word 0, bit 24:31 */
+
+			uint8_t lsRjtRsnCode;	/* FC Word 0, bit 16:23 */
+			/* LS_RJT reason codes */
+#define LSRJT_INVALID_CMD     0x01
+#define LSRJT_LOGICAL_ERR     0x03
+#define LSRJT_LOGICAL_BSY     0x05
+#define LSRJT_PROTOCOL_ERR    0x07
+#define LSRJT_UNABLE_TPC      0x09	/* Unable to perform command */
+#define LSRJT_CMD_UNSUPPORTED 0x0B
+#define LSRJT_VENDOR_UNIQUE   0xFF	/* See Byte 3 */
+
+			uint8_t lsRjtRsnCodeExp; /* FC Word 0, bit 8:15 */
+			/* LS_RJT reason explanation */
+#define LSEXP_NOTHING_MORE      0x00
+#define LSEXP_SPARM_OPTIONS     0x01
+#define LSEXP_SPARM_ICTL        0x03
+#define LSEXP_SPARM_RCTL        0x05
+#define LSEXP_SPARM_RCV_SIZE    0x07
+#define LSEXP_SPARM_CONCUR_SEQ  0x09
+#define LSEXP_SPARM_CREDIT      0x0B
+#define LSEXP_INVALID_PNAME     0x0D
+#define LSEXP_INVALID_NNAME     0x0E
+#define LSEXP_INVALID_CSP       0x0F
+#define LSEXP_INVALID_ASSOC_HDR 0x11
+#define LSEXP_ASSOC_HDR_REQ     0x13
+#define LSEXP_INVALID_O_SID     0x15
+#define LSEXP_INVALID_OX_RX     0x17
+#define LSEXP_CMD_IN_PROGRESS   0x19
+#define LSEXP_INVALID_NPORT_ID  0x1F
+#define LSEXP_INVALID_SEQ_ID    0x21
+#define LSEXP_INVALID_XCHG      0x23
+#define LSEXP_INACTIVE_XCHG     0x25
+#define LSEXP_RQ_REQUIRED       0x27
+#define LSEXP_OUT_OF_RESOURCE   0x29
+#define LSEXP_CANT_GIVE_DATA    0x2A
+#define LSEXP_REQ_UNSUPPORTED   0x2C
+			uint8_t vendorUnique;	/* FC Word 0, bit  0: 7 */
+		} b;
+	} un;
+} LS_RJT;
+
+/*
+ *  N_Port Login (FLOGO/PLOGO Request) Payload Definition
+ */
+
+typedef struct _LOGO {		/* Structure is in Big Endian format */
+	union {
+		uint32_t nPortId32;	/* Access nPortId as a word */
+		struct {
+			uint8_t word1Reserved1;	/* FC Word 1, bit 31:24 */
+			uint8_t nPortIdByte0;	/* N_port  ID bit 16:23 */
+			uint8_t nPortIdByte1;	/* N_port  ID bit  8:15 */
+			uint8_t nPortIdByte2;	/* N_port  ID bit  0: 7 */
+		} b;
+	} un;
+	NAME_TYPE portName;	/* N_port name field */
+} LOGO;
+
+/*
+ *  FCP Login (PRLI Request / ACC) Payload Definition
+ */
+
+#define PRLX_PAGE_LEN   0x10
+#define TPRLO_PAGE_LEN  0x14
+
+typedef struct _PRLI {		/* Structure is in Big Endian format */
+	uint8_t prliType;	/* FC Parm Word 0, bit 24:31 */
+
+#define PRLI_FCP_TYPE 0x08
+	uint8_t word0Reserved1;	/* FC Parm Word 0, bit 16:23 */
+
+#if __BIG_ENDIAN
+	uint8_t origProcAssocV:1;	/* FC Parm Word 0, bit 15 */
+	uint8_t respProcAssocV:1;	/* FC Parm Word 0, bit 14 */
+	uint8_t estabImagePair:1;	/* FC Parm Word 0, bit 13 */
+
+	/*    ACC = imagePairEstablished */
+	uint8_t word0Reserved2:1;	/* FC Parm Word 0, bit 12 */
+	uint8_t acceptRspCode:4;	/* FC Parm Word 0, bit 8:11, ACC ONLY */
+#else	/*  __LITTLE_ENDIAN */
+	uint8_t acceptRspCode:4;	/* FC Parm Word 0, bit 8:11, ACC ONLY */
+	uint8_t word0Reserved2:1;	/* FC Parm Word 0, bit 12 */
+	uint8_t estabImagePair:1;	/* FC Parm Word 0, bit 13 */
+	uint8_t respProcAssocV:1;	/* FC Parm Word 0, bit 14 */
+	uint8_t origProcAssocV:1;	/* FC Parm Word 0, bit 15 */
+	/*    ACC = imagePairEstablished */
+#endif
+
+#define PRLI_REQ_EXECUTED     0x1	/* acceptRspCode */
+#define PRLI_NO_RESOURCES     0x2
+#define PRLI_INIT_INCOMPLETE  0x3
+#define PRLI_NO_SUCH_PA       0x4
+#define PRLI_PREDEF_CONFIG    0x5
+#define PRLI_PARTIAL_SUCCESS  0x6
+#define PRLI_INVALID_PAGE_CNT 0x7
+	uint8_t word0Reserved3;	/* FC Parm Word 0, bit 0:7 */
+
+	uint32_t origProcAssoc;	/* FC Parm Word 1, bit 0:31 */
+
+	uint32_t respProcAssoc;	/* FC Parm Word 2, bit 0:31 */
+
+	uint8_t word3Reserved1;	/* FC Parm Word 3, bit 24:31 */
+	uint8_t word3Reserved2;	/* FC Parm Word 3, bit 16:23 */
+
+#if __BIG_ENDIAN
+	uint16_t Word3bit15Resved:1;	/* FC Parm Word 3, bit 15 */
+	uint16_t Word3bit14Resved:1;	/* FC Parm Word 3, bit 14 */
+	uint16_t Word3bit13Resved:1;	/* FC Parm Word 3, bit 13 */
+	uint16_t Word3bit12Resved:1;	/* FC Parm Word 3, bit 12 */
+	uint16_t Word3bit11Resved:1;	/* FC Parm Word 3, bit 11 */
+	uint16_t Word3bit10Resved:1;	/* FC Parm Word 3, bit 10 */
+	uint16_t TaskRetryIdReq:1;	/* FC Parm Word 3, bit  9 */
+	uint16_t Retry:1;	/* FC Parm Word 3, bit  8 */
+	uint16_t ConfmComplAllowed:1;	/* FC Parm Word 3, bit  7 */
+	uint16_t dataOverLay:1;	/* FC Parm Word 3, bit  6 */
+	uint16_t initiatorFunc:1;	/* FC Parm Word 3, bit  5 */
+	uint16_t targetFunc:1;	/* FC Parm Word 3, bit  4 */
+	uint16_t cmdDataMixEna:1;	/* FC Parm Word 3, bit  3 */
+	uint16_t dataRspMixEna:1;	/* FC Parm Word 3, bit  2 */
+	uint16_t readXferRdyDis:1;	/* FC Parm Word 3, bit  1 */
+	uint16_t writeXferRdyDis:1;	/* FC Parm Word 3, bit  0 */
+#else	/*  __LITTLE_ENDIAN */
+	uint16_t Retry:1;	/* FC Parm Word 3, bit  8 */
+	uint16_t TaskRetryIdReq:1;	/* FC Parm Word 3, bit  9 */
+	uint16_t Word3bit10Resved:1;	/* FC Parm Word 3, bit 10 */
+	uint16_t Word3bit11Resved:1;	/* FC Parm Word 3, bit 11 */
+	uint16_t Word3bit12Resved:1;	/* FC Parm Word 3, bit 12 */
+	uint16_t Word3bit13Resved:1;	/* FC Parm Word 3, bit 13 */
+	uint16_t Word3bit14Resved:1;	/* FC Parm Word 3, bit 14 */
+	uint16_t Word3bit15Resved:1;	/* FC Parm Word 3, bit 15 */
+	uint16_t writeXferRdyDis:1;	/* FC Parm Word 3, bit  0 */
+	uint16_t readXferRdyDis:1;	/* FC Parm Word 3, bit  1 */
+	uint16_t dataRspMixEna:1;	/* FC Parm Word 3, bit  2 */
+	uint16_t cmdDataMixEna:1;	/* FC Parm Word 3, bit  3 */
+	uint16_t targetFunc:1;	/* FC Parm Word 3, bit  4 */
+	uint16_t initiatorFunc:1;	/* FC Parm Word 3, bit  5 */
+	uint16_t dataOverLay:1;	/* FC Parm Word 3, bit  6 */
+	uint16_t ConfmComplAllowed:1;	/* FC Parm Word 3, bit  7 */
+#endif
+} PRLI;
+
+/*
+ *  FCP Logout (PRLO Request / ACC) Payload Definition
+ */
+
+typedef struct _PRLO {		/* Structure is in Big Endian format */
+	uint8_t prloType;	/* FC Parm Word 0, bit 24:31 */
+
+#define PRLO_FCP_TYPE  0x08
+	uint8_t word0Reserved1;	/* FC Parm Word 0, bit 16:23 */
+
+#if __BIG_ENDIAN
+	uint8_t origProcAssocV:1;	/* FC Parm Word 0, bit 15 */
+	uint8_t respProcAssocV:1;	/* FC Parm Word 0, bit 14 */
+	uint8_t word0Reserved2:2;	/* FC Parm Word 0, bit 12:13 */
+	uint8_t acceptRspCode:4;	/* FC Parm Word 0, bit 8:11, ACC ONLY */
+#else	/*  __LITTLE_ENDIAN */
+	uint8_t acceptRspCode:4;	/* FC Parm Word 0, bit 8:11, ACC ONLY */
+	uint8_t word0Reserved2:2;	/* FC Parm Word 0, bit 12:13 */
+	uint8_t respProcAssocV:1;	/* FC Parm Word 0, bit 14 */
+	uint8_t origProcAssocV:1;	/* FC Parm Word 0, bit 15 */
+#endif
+
+#define PRLO_REQ_EXECUTED     0x1	/* acceptRspCode */
+#define PRLO_NO_SUCH_IMAGE    0x4
+#define PRLO_INVALID_PAGE_CNT 0x7
+
+	uint8_t word0Reserved3;	/* FC Parm Word 0, bit 0:7 */
+
+	uint32_t origProcAssoc;	/* FC Parm Word 1, bit 0:31 */
+
+	uint32_t respProcAssoc;	/* FC Parm Word 2, bit 0:31 */
+
+	uint32_t word3Reserved1;	/* FC Parm Word 3, bit 0:31 */
+} PRLO;
+
+typedef struct _ADISC {		/* Structure is in Big Endian format */
+	uint32_t hardAL_PA;
+	NAME_TYPE portName;
+	NAME_TYPE nodeName;
+	uint32_t DID;
+} ADISC;
+
+typedef struct _FARP {		/* Structure is in Big Endian format */
+	uint32_t Mflags:8;
+	uint32_t Odid:24;
+#define FARP_NO_ACTION          0	/* FARP information enclosed, no
+					   action */
+#define FARP_MATCH_PORT         0x1	/* Match on Responder Port Name */
+#define FARP_MATCH_NODE         0x2	/* Match on Responder Node Name */
+#define FARP_MATCH_IP           0x4	/* Match on IP address, not supported */
+#define FARP_MATCH_IPV4         0x5	/* Match on IPV4 address, not
+					   supported */
+#define FARP_MATCH_IPV6         0x6	/* Match on IPV6 address, not
+					   supported */
+	uint32_t Rflags:8;
+	uint32_t Rdid:24;
+#define FARP_REQUEST_PLOGI      0x1	/* Request for PLOGI */
+#define FARP_REQUEST_FARPR      0x2	/* Request for FARP Response */
+	NAME_TYPE OportName;
+	NAME_TYPE OnodeName;
+	NAME_TYPE RportName;
+	NAME_TYPE RnodeName;
+	uint8_t Oipaddr[16];
+	uint8_t Ripaddr[16];
+} FARP;
+
+typedef struct _FAN {		/* Structure is in Big Endian format */
+	uint32_t Fdid;
+	NAME_TYPE FportName;
+	NAME_TYPE FnodeName;
+} FAN;
+
+typedef struct _SCR {		/* Structure is in Big Endian format */
+	uint8_t resvd1;
+	uint8_t resvd2;
+	uint8_t resvd3;
+	uint8_t Function;
+#define  SCR_FUNC_FABRIC     0x01
+#define  SCR_FUNC_NPORT      0x02
+#define  SCR_FUNC_FULL       0x03
+#define  SCR_CLEAR           0xff
+} SCR;
+
+typedef struct _RNID_TOP_DISC {
+	NAME_TYPE portName;
+	uint8_t resvd[8];
+	uint32_t unitType;
+#define RNID_HBA            0x7
+#define RNID_HOST           0xa
+#define RNID_DRIVER         0xd
+	uint32_t physPort;
+	uint32_t attachedNodes;
+	uint16_t ipVersion;
+#define RNID_IPV4           0x1
+#define RNID_IPV6           0x2
+	uint16_t UDPport;
+	uint8_t ipAddr[16];
+	uint16_t resvd1;
+	uint16_t flags;
+#define RNID_TD_SUPPORT     0x1
+#define RNID_LP_VALID       0x2
+} RNID_TOP_DISC;
+
+typedef struct _RNID {		/* Structure is in Big Endian format */
+	uint8_t Format;
+#define RNID_TOPOLOGY_DISC  0xdf
+	uint8_t CommonLen;
+	uint8_t resvd1;
+	uint8_t SpecificLen;
+	NAME_TYPE portName;
+	NAME_TYPE nodeName;
+	union {
+		RNID_TOP_DISC topologyDisc;	/* topology disc (0xdf) */
+	} un;
+} RNID;
+
+typedef struct _RRQ {		/* Structure is in Big Endian format */
+	uint32_t SID;
+	uint16_t Oxid;
+	uint16_t Rxid;
+	uint8_t resv[32];	/* optional association hdr */
+} RRQ;
+
+/* This is used for RSCN command */
+typedef struct _D_ID {		/* Structure is in Big Endian format */
+	union {
+		uint32_t word;
+		struct {
+#if __BIG_ENDIAN
+			uint8_t resv;
+			uint8_t domain;
+			uint8_t area;
+			uint8_t id;
+#else	/*  __LITTLE_ENDIAN */
+			uint8_t id;
+			uint8_t area;
+			uint8_t domain;
+			uint8_t resv;
+#endif
+		} b;
+	} un;
+} D_ID;
+
+/*
+ *  Structure to define all ELS Payload types
+ */
+
+typedef struct _ELS_PKT {	/* Structure is in Big Endian format */
+	uint8_t elsCode;	/* FC Word 0, bit 24:31 */
+	uint8_t elsByte1;
+	uint8_t elsByte2;
+	uint8_t elsByte3;
+	union {
+		LS_RJT lsRjt;	/* Payload for LS_RJT ELS response */
+		SERV_PARM logi;	/* Payload for PLOGI/FLOGI/PDISC/ACC */
+		LOGO logo;	/* Payload for PLOGO/FLOGO/ACC */
+		PRLI prli;	/* Payload for PRLI/ACC */
+		PRLO prlo;	/* Payload for PRLO/ACC */
+		ADISC adisc;	/* Payload for ADISC/ACC */
+		FARP farp;	/* Payload for FARP/ACC */
+		FAN fan;	/* Payload for FAN */
+		SCR scr;	/* Payload for SCR/ACC */
+		RRQ rrq;	/* Payload for RRQ */
+		RNID rnid;	/* Payload for RNID */
+		uint8_t pad[128 - 4];	/* Pad out to payload of 128 bytes */
+	} un;
+} ELS_PKT;
+
+/*
+ * FDMI
+ * HBA MAnagement Operations Command Codes
+ */
+#define  SLI_MGMT_GRHL     0x100	/* Get registered HBA list */
+#define  SLI_MGMT_GHAT     0x101	/* Get HBA attributes */
+#define  SLI_MGMT_GRPL     0x102	/* Get registered Port list */
+#define  SLI_MGMT_GPAT     0x110	/* Get Port attributes */
+#define  SLI_MGMT_RHBA     0x200	/* Register HBA */
+#define  SLI_MGMT_RHAT     0x201	/* Register HBA atttributes */
+#define  SLI_MGMT_RPRT     0x210	/* Register Port */
+#define  SLI_MGMT_RPA      0x211	/* Register Port attributes */
+#define  SLI_MGMT_DHBA     0x300	/* De-register HBA */
+#define  SLI_MGMT_DPRT     0x310	/* De-register Port */
+
+/*
+ * Management Service Subtypes
+ */
+#define  SLI_CT_FDMI_Subtypes     0x10
+
+/*
+ * HBA Management Service Reject Code
+ */
+#define  REJECT_CODE             0x9	/* Unable to perform command request */
+
+/*
+ * HBA Management Service Reject Reason Code
+ * Please refer to the Reason Codes above
+ */
+
+/*
+ * HBA Attribute Types
+ */
+#define  NODE_NAME               0x1
+#define  MANUFACTURER            0x2
+#define  SERIAL_NUMBER           0x3
+#define  MODEL                   0x4
+#define  MODEL_DESCRIPTION       0x5
+#define  HARDWARE_VERSION        0x6
+#define  DRIVER_VERSION          0x7
+#define  OPTION_ROM_VERSION      0x8
+#define  FIRMWARE_VERSION        0x9
+#define  OS_NAME_VERSION	 0xa
+#define  MAX_CT_PAYLOAD_LEN	 0xb
+
+/*
+ * Port Attrubute Types
+ */
+#define  SUPPORTED_FC4_TYPES     0x1
+#define  SUPPORTED_SPEED         0x2
+#define  PORT_SPEED              0x3
+#define  MAX_FRAME_SIZE          0x4
+#define  OS_DEVICE_NAME          0x5
+#define  HOST_NAME               0x6
+
+union AttributesDef {
+	/* Structure is in Big Endian format */
+	struct {
+		uint32_t AttrType:16;
+		uint32_t AttrLen:16;
+	} bits;
+	uint32_t word;
+};
+
+#define GET_OS_VERSION          1
+#define GET_HOST_NAME           2
+
+/*
+ * HBA Attribute Entry (8 - 260 bytes)
+ */
+typedef struct {
+	union AttributesDef ad;
+	union {
+		uint32_t VendorSpecific;
+		uint8_t Manufacturer[64];
+		uint8_t SerialNumber[64];
+		uint8_t Model[256];
+		uint8_t ModelDescription[256];
+		uint8_t HardwareVersion[256];
+		uint8_t DriverVersion[256];
+		uint8_t OptionROMVersion[256];
+		uint8_t FirmwareVersion[256];
+		NAME_TYPE NodeName;
+		uint8_t SupportFC4Types[32];
+		uint32_t SupportSpeed;
+		uint32_t PortSpeed;
+		uint32_t MaxFrameSize;
+		uint8_t OsDeviceName[256];
+		uint8_t OsNameVersion[256];
+		uint32_t MaxCTPayloadLen;
+		uint8_t HostName[256];
+	} un;
+} ATTRIBUTE_ENTRY, *PATTRIBUTE_ENTRY;
+
+/*
+ * HBA Attribute Block
+ */
+typedef struct {
+	uint32_t EntryCnt;	/* Number of HBA attribute entries */
+	ATTRIBUTE_ENTRY Entry;	/* Variable-length array */
+} ATTRIBUTE_BLOCK, *PATTRIBUTE_BLOCK;
+
+/*
+ * Port Entry
+ */
+typedef struct {
+	NAME_TYPE PortName;
+} PORT_ENTRY, *PPORT_ENTRY;
+
+/*
+ * HBA Identifier
+ */
+typedef struct {
+	NAME_TYPE PortName;
+} HBA_IDENTIFIER, *PHBA_IDENTIFIER;
+
+/*
+ * Registered Port List Format
+ */
+typedef struct {
+	uint32_t EntryCnt;
+	PORT_ENTRY pe;		/* Variable-length array */
+} REG_PORT_LIST, *PREG_PORT_LIST;
+
+/*
+ * Register HBA(RHBA)
+ */
+typedef struct {
+	HBA_IDENTIFIER hi;
+	REG_PORT_LIST rpl;	/* variable-length array */
+/* ATTRIBUTE_BLOCK   ab; */
+} REG_HBA, *PREG_HBA;
+
+/*
+ * Register HBA Attributes (RHAT)
+ */
+typedef struct {
+	NAME_TYPE HBA_PortName;
+	ATTRIBUTE_BLOCK ab;
+} REG_HBA_ATTRIBUTE, *PREG_HBA_ATTRIBUTE;
+
+/*
+ * Register Port Attributes (RPA)
+ */
+typedef struct {
+	NAME_TYPE PortName;
+	ATTRIBUTE_BLOCK ab;
+} REG_PORT_ATTRIBUTE, *PREG_PORT_ATTRIBUTE;
+
+/*
+ * Get Registered HBA List (GRHL) Accept Payload Format
+ */
+typedef struct {
+	uint32_t HBA__Entry_Cnt; /* Number of Registered HBA Identifiers */
+	NAME_TYPE HBA_PortName;	/* Variable-length array */
+} GRHL_ACC_PAYLOAD, *PGRHL_ACC_PAYLOAD;
+
+/*
+ * Get Registered Port List (GRPL) Accept Payload Format
+ */
+typedef struct {
+	uint32_t RPL_Entry_Cnt;	/* Number of Registered Port Entries */
+	PORT_ENTRY Reg_Port_Entry[1];	/* Variable-length array */
+} GRPL_ACC_PAYLOAD, *PGRPL_ACC_PAYLOAD;
+
+/*
+ * Get Port Attributes (GPAT) Accept Payload Format
+ */
+
+typedef struct {
+	ATTRIBUTE_BLOCK pab;
+} GPAT_ACC_PAYLOAD, *PGPAT_ACC_PAYLOAD;
+
+
+/*
+ *  Begin HBA configuration parameters.
+ *  The PCI configuration register BAR assignments are:
+ *  BAR0, offset 0x10 - SLIM base memory address
+ *  BAR1, offset 0x14 - SLIM base memory high address
+ *  BAR2, offset 0x18 - REGISTER base memory address
+ *  BAR3, offset 0x1c - REGISTER base memory high address
+ *  BAR4, offset 0x20 - BIU I/O registers
+ *  BAR5, offset 0x24 - REGISTER base io high address 
+ */
+
+/* Maximum transfer size per operation */
+#define FC_MAX_TRANSFER    0x40000
+
+/* Number of rings currently used and available. */
+#define MAX_CONFIGURED_RINGS     3
+#define MAX_RINGS                4
+
+/* IO Register size in bytes */
+#define FF_REG_AREA_SIZE       256
+
+/* SLIM size in bytes */	
+#define FF_SLIM_SIZE          4096	
+
+/* IOCB / Mailbox is owned by FireFly */
+#define OWN_CHIP        1
+
+/* IOCB / Mailbox is owned by Host */	
+#define OWN_HOST        0
+
+/* Number of 4-byte words in an IOCB. */	
+#define IOCB_WORD_SZ    8
+
+/* defines for type field in fc header */
+#define FC_ELS_DATA     0x1
+#define FC_LLC_SNAP     0x5
+#define FC_FCP_DATA     0x8
+#define FC_COMMON_TRANSPORT_ULP 0x20
+
+/* defines for rctl field in fc header */
+#define FC_DEV_DATA     0x0
+#define FC_UNSOL_CTL    0x2
+#define FC_SOL_CTL      0x3
+#define FC_UNSOL_DATA   0x4
+#define FC_FCP_CMND     0x6
+#define FC_ELS_REQ      0x22
+#define FC_ELS_RSP      0x23
+
+/* network headers for Dfctl field */
+#define FC_NET_HDR      0x20	
+
+/* Start FireFly Register definitions */
+#define PCI_VENDOR_ID_EMULEX        0x10df
+#define PCI_DEVICE_ID_FIREFLY 	    0x1ae5
+#define PCI_DEVICE_ID_RFLY          0xf095
+#define PCI_DEVICE_ID_PFLY          0xf098
+#define PCI_DEVICE_ID_LP101	    0xf0a1
+#define PCI_DEVICE_ID_TFLY          0xf0a5
+#define PCI_DEVICE_ID_BSMB          0xf0d1
+#define PCI_DEVICE_ID_BMID          0xf0d5
+#define PCI_DEVICE_ID_ZSMB          0xf0e1
+#define PCI_DEVICE_ID_ZMID          0xf0e5
+#define PCI_DEVICE_ID_NEPTUNE       0xf0f5
+#define PCI_DEVICE_ID_NEPTUNE_SCSP  0xf0f6
+#define PCI_DEVICE_ID_NEPTUNE_DCSP  0xf0f7
+#define PCI_DEVICE_ID_SUPERFLY      0xf700
+#define PCI_DEVICE_ID_DRAGONFLY     0xf800
+#define PCI_DEVICE_ID_CENTAUR       0xf900
+#define PCI_DEVICE_ID_PEGASUS       0xf980
+#define PCI_DEVICE_ID_THOR          0xfa00
+#define PCI_DEVICE_ID_VIPER         0xfb00
+#define PCI_DEVICE_ID_LP10000S	    0xfc00
+#define PCI_DEVICE_ID_LP11000S      0xfc10
+#define PCI_DEVICE_ID_LPE11000S     0xfc20
+#define PCI_DEVICE_ID_HELIOS        0xfd00
+#define PCI_DEVICE_ID_HELIOS_SCSP   0xfd11
+#define PCI_DEVICE_ID_HELIOS_DCSP   0xfd12
+#define PCI_DEVICE_ID_ZEPHYR        0xfe00
+#define PCI_DEVICE_ID_ZEPHYR_SCSP   0xfe11
+#define PCI_DEVICE_ID_ZEPHYR_DCSP   0xfe12
+
+#define PCI_SUBSYSTEM_ID_LP11000S      0xfc11
+#define PCI_SUBSYSTEM_ID_LP11002S      0xfc12
+#define PCI_SUBSYSTEM_ID_LPE11000S     0xfc21
+#define PCI_SUBSYSTEM_ID_LPE11002S     0xfc22
+#define PCI_SUBSYSTEM_ID_LPE11010S     0xfc2A
+
+#define JEDEC_ID_ADDRESS            0x0080001c
+#define FIREFLY_JEDEC_ID            0x1ACC
+#define SUPERFLY_JEDEC_ID           0x0020
+#define DRAGONFLY_JEDEC_ID          0x0021
+#define DRAGONFLY_V2_JEDEC_ID       0x0025
+#define CENTAUR_2G_JEDEC_ID         0x0026
+#define CENTAUR_1G_JEDEC_ID         0x0028
+#define PEGASUS_ORION_JEDEC_ID      0x0036
+#define PEGASUS_JEDEC_ID            0x0038
+#define THOR_JEDEC_ID               0x0012
+#define HELIOS_JEDEC_ID             0x0364
+#define ZEPHYR_JEDEC_ID             0x0577
+#define VIPER_JEDEC_ID              0x4838
+
+#define JEDEC_ID_MASK               0x0FFFF000
+#define JEDEC_ID_SHIFT              12
+#define FC_JEDEC_ID(id)             ((id & JEDEC_ID_MASK) >> JEDEC_ID_SHIFT)
+
+#define DEFAULT_PCI_LATENCY_CLOCKS  0xf8 /* 0xF8 is a special value for FF11.1N6
+					  * firmware.  Use 0x80 for pre-FF11.1N6
+					  * &N7, etc */
+#define PCI_LATENCY_VALUE           0xf8
+
+typedef struct {		/* FireFly BIU registers */
+	uint32_t hostAtt;	/* See definitions for Host Attention
+				   register */
+	uint32_t chipAtt;	/* See definitions for Chip Attention
+				   register */
+	uint32_t hostStatus;	/* See definitions for Host Status register */
+	uint32_t hostControl;	/* See definitions for Host Control register */
+	uint32_t buiConfig;	/* See definitions for BIU configuration
+				   register */
+} FF_REGS, *PFF_REGS;
+
+/* Host Attention Register */
+
+#define HA_REG_OFFSET  0	/* Word offset from register base address */
+
+#define HA_R0RE_REQ    0x00000001	/* Bit  0 */
+#define HA_R0CE_RSP    0x00000002	/* Bit  1 */
+#define HA_R0ATT       0x00000008	/* Bit  3 */
+#define HA_R1RE_REQ    0x00000010	/* Bit  4 */
+#define HA_R1CE_RSP    0x00000020	/* Bit  5 */
+#define HA_R1ATT       0x00000080	/* Bit  7 */
+#define HA_R2RE_REQ    0x00000100	/* Bit  8 */
+#define HA_R2CE_RSP    0x00000200	/* Bit  9 */
+#define HA_R2ATT       0x00000800	/* Bit 11 */
+#define HA_R3RE_REQ    0x00001000	/* Bit 12 */
+#define HA_R3CE_RSP    0x00002000	/* Bit 13 */
+#define HA_R3ATT       0x00008000	/* Bit 15 */
+#define HA_LATT        0x20000000	/* Bit 29 */
+#define HA_MBATT       0x40000000	/* Bit 30 */
+#define HA_ERATT       0x80000000	/* Bit 31 */
+
+#define HA_RXRE_REQ    0x00000001	/* Bit  0 */
+#define HA_RXCE_RSP    0x00000002	/* Bit  1 */
+#define HA_RXATT       0x00000008	/* Bit  3 */
+#define HA_RXMASK      0x0000000f
+
+/* Chip Attention Register */
+
+#define CA_REG_OFFSET  1	/* Word offset from register base address */
+
+#define CA_R0CE_REQ    0x00000001	/* Bit  0 */
+#define CA_R0RE_RSP    0x00000002	/* Bit  1 */
+#define CA_R0ATT       0x00000008	/* Bit  3 */
+#define CA_R1CE_REQ    0x00000010	/* Bit  4 */
+#define CA_R1RE_RSP    0x00000020	/* Bit  5 */
+#define CA_R1ATT       0x00000080	/* Bit  7 */
+#define CA_R2CE_REQ    0x00000100	/* Bit  8 */
+#define CA_R2RE_RSP    0x00000200	/* Bit  9 */
+#define CA_R2ATT       0x00000800	/* Bit 11 */
+#define CA_R3CE_REQ    0x00001000	/* Bit 12 */
+#define CA_R3RE_RSP    0x00002000	/* Bit 13 */
+#define CA_R3ATT       0x00008000	/* Bit 15 */
+#define CA_MBATT       0x40000000	/* Bit 30 */
+
+/* Host Status Register */
+
+#define HS_REG_OFFSET  2	/* Word offset from register base address */
+
+#define HS_MBRDY       0x00400000	/* Bit 22 */
+#define HS_FFRDY       0x00800000	/* Bit 23 */
+#define HS_FFER8       0x01000000	/* Bit 24 */
+#define HS_FFER7       0x02000000	/* Bit 25 */
+#define HS_FFER6       0x04000000	/* Bit 26 */
+#define HS_FFER5       0x08000000	/* Bit 27 */
+#define HS_FFER4       0x10000000	/* Bit 28 */
+#define HS_FFER3       0x20000000	/* Bit 29 */
+#define HS_FFER2       0x40000000	/* Bit 30 */
+#define HS_FFER1       0x80000000	/* Bit 31 */
+#define HS_FFERM       0xFF000000	/* Mask for error bits 31:24 */
+
+/* Host Control Register */
+
+#define HC_REG_OFFSET  3	/* Word offset from register base address */
+
+#define HC_MBINT_ENA   0x00000001	/* Bit  0 */
+#define HC_R0INT_ENA   0x00000002	/* Bit  1 */
+#define HC_R1INT_ENA   0x00000004	/* Bit  2 */
+#define HC_R2INT_ENA   0x00000008	/* Bit  3 */
+#define HC_R3INT_ENA   0x00000010	/* Bit  4 */
+#define HC_INITHBI     0x02000000	/* Bit 25 */
+#define HC_INITMB      0x04000000	/* Bit 26 */
+#define HC_INITFF      0x08000000	/* Bit 27 */
+#define HC_LAINT_ENA   0x20000000	/* Bit 29 */
+#define HC_ERINT_ENA   0x80000000	/* Bit 31 */
+
+/* Mailbox Commands */
+#define MBX_SHUTDOWN        0x00	/* terminate testing */
+#define MBX_LOAD_SM         0x01
+#define MBX_READ_NV         0x02
+#define MBX_WRITE_NV        0x03
+#define MBX_RUN_BIU_DIAG    0x04
+#define MBX_INIT_LINK       0x05
+#define MBX_DOWN_LINK       0x06
+#define MBX_CONFIG_LINK     0x07
+#define MBX_CONFIG_RING     0x09
+#define MBX_RESET_RING      0x0A
+#define MBX_READ_CONFIG     0x0B
+#define MBX_READ_RCONFIG    0x0C
+#define MBX_READ_SPARM      0x0D
+#define MBX_READ_STATUS     0x0E
+#define MBX_READ_RPI        0x0F
+#define MBX_READ_XRI        0x10
+#define MBX_READ_REV        0x11
+#define MBX_READ_LNK_STAT   0x12
+#define MBX_REG_LOGIN       0x13
+#define MBX_UNREG_LOGIN     0x14
+#define MBX_READ_LA         0x15
+#define MBX_CLEAR_LA        0x16
+#define MBX_DUMP_MEMORY     0x17
+#define MBX_DUMP_CONTEXT    0x18
+#define MBX_RUN_DIAGS       0x19
+#define MBX_RESTART         0x1A
+#define MBX_UPDATE_CFG      0x1B
+#define MBX_DOWN_LOAD       0x1C
+#define MBX_DEL_LD_ENTRY    0x1D
+#define MBX_RUN_PROGRAM     0x1E
+#define MBX_SET_MASK        0x20
+#define MBX_SET_SLIM        0x21
+#define MBX_UNREG_D_ID      0x23
+#define MBX_KILL_BOARD      0x24
+#define MBX_CONFIG_FARP     0x25
+
+#define MBX_LOAD_AREA       0x81
+#define MBX_RUN_BIU_DIAG64  0x84
+#define MBX_CONFIG_PORT     0x88
+#define MBX_READ_SPARM64    0x8D
+#define MBX_READ_RPI64      0x8F
+#define MBX_REG_LOGIN64     0x93
+#define MBX_READ_LA64       0x95
+
+#define MBX_FLASH_WR_ULA    0x98
+#define MBX_SET_DEBUG       0x99
+#define MBX_LOAD_EXP_ROM    0x9C
+
+#define MBX_MAX_CMDS        0x9D
+#define MBX_SLI2_CMD_MASK   0x80
+
+/* IOCB Commands */
+
+#define CMD_RCV_SEQUENCE_CX     0x01
+#define CMD_XMIT_SEQUENCE_CR    0x02
+#define CMD_XMIT_SEQUENCE_CX    0x03
+#define CMD_XMIT_BCAST_CN       0x04
+#define CMD_XMIT_BCAST_CX       0x05
+#define CMD_QUE_RING_BUF_CN     0x06
+#define CMD_QUE_XRI_BUF_CX      0x07
+#define CMD_IOCB_CONTINUE_CN    0x08
+#define CMD_RET_XRI_BUF_CX      0x09
+#define CMD_ELS_REQUEST_CR      0x0A
+#define CMD_ELS_REQUEST_CX      0x0B
+#define CMD_RCV_ELS_REQ_CX      0x0D
+#define CMD_ABORT_XRI_CN        0x0E
+#define CMD_ABORT_XRI_CX        0x0F
+#define CMD_CLOSE_XRI_CN        0x10
+#define CMD_CLOSE_XRI_CX        0x11
+#define CMD_CREATE_XRI_CR       0x12
+#define CMD_CREATE_XRI_CX       0x13
+#define CMD_GET_RPI_CN          0x14
+#define CMD_XMIT_ELS_RSP_CX     0x15
+#define CMD_GET_RPI_CR          0x16
+#define CMD_XRI_ABORTED_CX      0x17
+#define CMD_FCP_IWRITE_CR       0x18
+#define CMD_FCP_IWRITE_CX       0x19
+#define CMD_FCP_IREAD_CR        0x1A
+#define CMD_FCP_IREAD_CX        0x1B
+#define CMD_FCP_ICMND_CR        0x1C
+#define CMD_FCP_ICMND_CX        0x1D
+
+#define CMD_ADAPTER_MSG         0x20
+#define CMD_ADAPTER_DUMP        0x22
+
+/*  SLI_2 IOCB Command Set */
+
+#define CMD_RCV_SEQUENCE64_CX   0x81
+#define CMD_XMIT_SEQUENCE64_CR  0x82
+#define CMD_XMIT_SEQUENCE64_CX  0x83
+#define CMD_XMIT_BCAST64_CN     0x84
+#define CMD_XMIT_BCAST64_CX     0x85
+#define CMD_QUE_RING_BUF64_CN   0x86
+#define CMD_QUE_XRI_BUF64_CX    0x87
+#define CMD_IOCB_CONTINUE64_CN  0x88
+#define CMD_RET_XRI_BUF64_CX    0x89
+#define CMD_ELS_REQUEST64_CR    0x8A
+#define CMD_ELS_REQUEST64_CX    0x8B
+#define CMD_ABORT_MXRI64_CN     0x8C
+#define CMD_RCV_ELS_REQ64_CX    0x8D
+#define CMD_XMIT_ELS_RSP64_CX   0x95
+#define CMD_FCP_IWRITE64_CR     0x98
+#define CMD_FCP_IWRITE64_CX     0x99
+#define CMD_FCP_IREAD64_CR      0x9A
+#define CMD_FCP_IREAD64_CX      0x9B
+#define CMD_FCP_ICMND64_CR      0x9C
+#define CMD_FCP_ICMND64_CX      0x9D
+
+#define CMD_GEN_REQUEST64_CR    0xC2
+#define CMD_GEN_REQUEST64_CX    0xC3
+
+#define CMD_MAX_IOCB_CMD        0xE6
+#define CMD_IOCB_MASK           0xff
+
+#define MAX_MSG_DATA            28	/* max msg data in CMD_ADAPTER_MSG
+					   iocb */
+#define LPFC_MAX_ADPTMSG         32	/* max msg data */
+/*
+ *  Define Status
+ */
+#define MBX_SUCCESS                 0
+#define MBXERR_NUM_RINGS            1
+#define MBXERR_NUM_IOCBS            2
+#define MBXERR_IOCBS_EXCEEDED       3
+#define MBXERR_BAD_RING_NUMBER      4
+#define MBXERR_MASK_ENTRIES_RANGE   5
+#define MBXERR_MASKS_EXCEEDED       6
+#define MBXERR_BAD_PROFILE          7
+#define MBXERR_BAD_DEF_CLASS        8
+#define MBXERR_BAD_MAX_RESPONDER    9
+#define MBXERR_BAD_MAX_ORIGINATOR   10
+#define MBXERR_RPI_REGISTERED       11
+#define MBXERR_RPI_FULL             12
+#define MBXERR_NO_RESOURCES         13
+#define MBXERR_BAD_RCV_LENGTH       14
+#define MBXERR_DMA_ERROR            15
+#define MBXERR_ERROR                16
+#define MBX_NOT_FINISHED           255
+
+#define MBX_BUSY                   0xffffff /* Attempted cmd to busy Mailbox */
+#define MBX_TIMEOUT                0xfffffe /* time-out expired waiting for */
+
+/*
+ *    Begin Structure Definitions for Mailbox Commands
+ */
+
+typedef struct {
+#if __BIG_ENDIAN
+	uint8_t tval;
+	uint8_t tmask;
+	uint8_t rval;
+	uint8_t rmask;
+#else	/*  __LITTLE_ENDIAN */
+	uint8_t rmask;
+	uint8_t rval;
+	uint8_t tmask;
+	uint8_t tval;
+#endif
+} RR_REG;
+
+typedef struct {
+	uint32_t bdeAddress;
+#if __BIG_ENDIAN
+	uint32_t bdeReserved:4;
+	uint32_t bdeAddrHigh:4;
+	uint32_t bdeSize:24;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t bdeSize:24;
+	uint32_t bdeAddrHigh:4;
+	uint32_t bdeReserved:4;
+#endif
+} ULP_BDE;
+
+typedef struct ULP_BDE_64 {	/* SLI-2 */
+	union ULP_BDE_TUS {
+		uint32_t w;
+		struct {
+#if __BIG_ENDIAN
+			uint32_t bdeFlags:8;	/* BDE Flags 0 IS A SUPPORTED
+						   VALUE !! */
+			uint32_t bdeSize:24;	/* Size of buffer (in bytes) */
+#else	/*  __LITTLE_ENDIAN */
+			uint32_t bdeSize:24;	/* Size of buffer (in bytes) */
+			uint32_t bdeFlags:8;	/* BDE Flags 0 IS A SUPPORTED
+						   VALUE !! */
+#endif
+
+#define BUFF_USE_RSVD       0x01	/* bdeFlags */
+#define BUFF_USE_INTRPT     0x02	/* Not Implemented with LP6000 */
+#define BUFF_USE_CMND       0x04	/* Optional, 1=cmd/rsp 0=data buffer */
+#define BUFF_USE_RCV        0x08	/*  "" "", 1=rcv buffer, 0=xmit
+					    buffer */
+#define BUFF_TYPE_32BIT     0x10	/*  "" "", 1=32 bit addr 0=64 bit
+					    addr */
+#define BUFF_TYPE_SPECIAL   0x20	/* Not Implemented with LP6000  */
+#define BUFF_TYPE_BDL       0x40	/* Optional,  may be set in BDL */
+#define BUFF_TYPE_INVALID   0x80	/*  ""  "" */
+		} f;
+	} tus;
+	uint32_t addrLow;
+	uint32_t addrHigh;
+} ULP_BDE64;
+#define BDE64_SIZE_WORD 0
+#define BPL64_SIZE_WORD 0x40
+
+typedef struct ULP_BDL {	/* SLI-2 */
+#if __BIG_ENDIAN
+	uint32_t bdeFlags:8;	/* BDL Flags */
+	uint32_t bdeSize:24;	/* Size of BDL array in host memory (bytes) */
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t bdeSize:24;	/* Size of BDL array in host memory (bytes) */
+	uint32_t bdeFlags:8;	/* BDL Flags */
+#endif
+
+	uint32_t addrLow;	/* Address 0:31 */
+	uint32_t addrHigh;	/* Address 32:63 */
+	uint32_t ulpIoTag32;	/* Can be used for 32 bit I/O Tag */
+} ULP_BDL;
+
+/* Structure for MB Command LOAD_SM and DOWN_LOAD */
+
+typedef struct {
+#if __BIG_ENDIAN
+	uint32_t rsvd2:25;
+	uint32_t acknowledgment:1;
+	uint32_t version:1;
+	uint32_t erase_or_prog:1;
+	uint32_t update_flash:1;
+	uint32_t update_ram:1;
+	uint32_t method:1;
+	uint32_t load_cmplt:1;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t load_cmplt:1;
+	uint32_t method:1;
+	uint32_t update_ram:1;
+	uint32_t update_flash:1;
+	uint32_t erase_or_prog:1;
+	uint32_t version:1;
+	uint32_t acknowledgment:1;
+	uint32_t rsvd2:25;
+#endif
+
+#define DL_FROM_BDE     0	/* method */
+#define DL_FROM_SLIM    1
+
+#define PROGRAM_FLASH   0	/* erase_or_prog */
+#define ERASE_FLASH     1
+
+	uint32_t dl_to_adr_low;
+	uint32_t dl_to_adr_high;
+	uint32_t dl_len;
+	union {
+		uint32_t dl_from_mbx_offset;
+		ULP_BDE dl_from_bde;
+		ULP_BDE64 dl_from_bde64;
+	} un;
+
+} LOAD_SM_VAR;
+
+/* Structure for MB Command READ_NVPARM (02) */
+
+typedef struct {
+	uint32_t rsvd1[3];	/* Read as all one's */
+	uint32_t rsvd2;		/* Read as all zero's */
+	uint32_t portname[2];	/* N_PORT name */
+	uint32_t nodename[2];	/* NODE name */
+
+#if __BIG_ENDIAN
+	uint32_t pref_DID:24;
+	uint32_t hardAL_PA:8;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t hardAL_PA:8;
+	uint32_t pref_DID:24;
+#endif
+
+	uint32_t rsvd3[21];	/* Read as all one's */
+} READ_NV_VAR;
+
+/* Structure for MB Command WRITE_NVPARMS (03) */
+
+typedef struct {
+	uint32_t rsvd1[3];	/* Must be all one's */
+	uint32_t rsvd2;		/* Must be all zero's */
+	uint32_t portname[2];	/* N_PORT name */
+	uint32_t nodename[2];	/* NODE name */
+
+#if __BIG_ENDIAN
+	uint32_t pref_DID:24;
+	uint32_t hardAL_PA:8;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t hardAL_PA:8;
+	uint32_t pref_DID:24;
+#endif
+
+	uint32_t rsvd3[21];	/* Must be all one's */
+} WRITE_NV_VAR;
+
+/* Structure for MB Command RUN_BIU_DIAG (04) */
+/* Structure for MB Command RUN_BIU_DIAG64 (0x84) */
+
+typedef struct {
+	uint32_t rsvd1;
+	union {
+		struct {
+			ULP_BDE xmit_bde;
+			ULP_BDE rcv_bde;
+		} s1;
+		struct {
+			ULP_BDE64 xmit_bde64;
+			ULP_BDE64 rcv_bde64;
+		} s2;
+	} un;
+} BIU_DIAG_VAR;
+
+/* Structure for MB Command INIT_LINK (05) */
+
+typedef struct {
+#if __BIG_ENDIAN
+	uint32_t rsvd1:24;
+	uint32_t lipsr_AL_PA:8;	/* AL_PA to issue Lip Selective Reset to */
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t lipsr_AL_PA:8;	/* AL_PA to issue Lip Selective Reset to */
+	uint32_t rsvd1:24;
+#endif
+
+#if __BIG_ENDIAN
+	uint8_t fabric_AL_PA;	/* If using a Fabric Assigned AL_PA */
+	uint8_t rsvd2;
+	uint16_t link_flags;
+#else	/*  __LITTLE_ENDIAN */
+	uint16_t link_flags;
+	uint8_t rsvd2;
+	uint8_t fabric_AL_PA;	/* If using a Fabric Assigned AL_PA */
+#endif
+
+#define FLAGS_LOCAL_LB               0x01 /* link_flags (=1) ENDEC loopback */
+#define FLAGS_TOPOLOGY_MODE_LOOP_PT  0x00 /* Attempt loop then pt-pt */
+#define FLAGS_TOPOLOGY_MODE_PT_PT    0x02 /* Attempt pt-pt only */
+#define FLAGS_TOPOLOGY_MODE_LOOP     0x04 /* Attempt loop only */
+#define FLAGS_TOPOLOGY_MODE_PT_LOOP  0x06 /* Attempt pt-pt then loop */
+#define FLAGS_LIRP_LILP              0x80 /* LIRP / LILP is disabled */
+
+#define FLAGS_TOPOLOGY_FAILOVER      0x0400	/* Bit 10 */
+#define FLAGS_LINK_SPEED             0x0800	/* Bit 11 */
+
+	uint32_t link_speed;	/* NEW_FEATURE */
+#define LINK_SPEED_AUTO 0	/* Auto selection */
+#define LINK_SPEED_1G   1	/* 1 Gigabaud */
+#define LINK_SPEED_2G   2	/* 2 Gigabaud */
+#define LINK_SPEED_4G   4	/* 4 Gigabaud */
+#define LINK_SPEED_8G   8	/* 8 Gigabaud */
+#define LINK_SPEED_10G  16 	/* 10 Gigabaud */
+
+} INIT_LINK_VAR;
+
+/* Structure for MB Command DOWN_LINK (06) */
+
+typedef struct {
+	uint32_t rsvd1;
+} DOWN_LINK_VAR;
+
+/* Structure for MB Command CONFIG_LINK (07) */
+
+typedef struct {
+#if __BIG_ENDIAN
+	uint32_t cr:1;
+	uint32_t ci:1;
+	uint32_t cr_delay:6;
+	uint32_t cr_count:8;
+	uint32_t rsvd1:8;
+	uint32_t MaxBBC:8;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t MaxBBC:8;
+	uint32_t rsvd1:8;
+	uint32_t cr_count:8;
+	uint32_t cr_delay:6;
+	uint32_t ci:1;
+	uint32_t cr:1;
+#endif
+
+	uint32_t myId;
+	uint32_t rsvd2;
+	uint32_t edtov;
+	uint32_t arbtov;
+	uint32_t ratov;
+	uint32_t rttov;
+	uint32_t altov;
+	uint32_t crtov;
+	uint32_t citov;
+#if __BIG_ENDIAN
+	uint32_t rrq_enable:1;
+	uint32_t rrq_immed:1;
+	uint32_t rsvd4:29;
+	uint32_t ack0_enable:1;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t ack0_enable:1;
+	uint32_t rsvd4:29;
+	uint32_t rrq_immed:1;
+	uint32_t rrq_enable:1;
+#endif
+} CONFIG_LINK;
+
+/* Structure for MB Command PART_SLIM (08)
+ * will be removed since SLI1 is no longer supported!
+ */
+typedef struct {
+#if __BIG_ENDIAN
+	uint16_t offCiocb;
+	uint16_t numCiocb;
+	uint16_t offRiocb;
+	uint16_t numRiocb;
+#else	/*  __LITTLE_ENDIAN */
+	uint16_t numCiocb;
+	uint16_t offCiocb;
+	uint16_t numRiocb;
+	uint16_t offRiocb;
+#endif
+} RING_DEF;
+
+typedef struct {
+#if __BIG_ENDIAN
+	uint32_t unused1:24;
+	uint32_t numRing:8;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t numRing:8;
+	uint32_t unused1:24;
+#endif
+
+	RING_DEF ringdef[4];
+	uint32_t hbainit;
+} PART_SLIM_VAR;
+
+/* Structure for MB Command CONFIG_RING (09) */
+
+typedef struct {
+#if __BIG_ENDIAN
+	uint32_t unused2:6;
+	uint32_t recvSeq:1;
+	uint32_t recvNotify:1;
+	uint32_t numMask:8;
+	uint32_t profile:8;
+	uint32_t unused1:4;
+	uint32_t ring:4;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t ring:4;
+	uint32_t unused1:4;
+	uint32_t profile:8;
+	uint32_t numMask:8;
+	uint32_t recvNotify:1;
+	uint32_t recvSeq:1;
+	uint32_t unused2:6;
+#endif
+
+#if __BIG_ENDIAN
+	uint16_t maxRespXchg;
+	uint16_t maxOrigXchg;
+#else	/*  __LITTLE_ENDIAN */
+	uint16_t maxOrigXchg;
+	uint16_t maxRespXchg;
+#endif
+
+	RR_REG rrRegs[6];
+} CONFIG_RING_VAR;
+
+/* Structure for MB Command RESET_RING (10) */
+
+typedef struct {
+	uint32_t ring_no;
+} RESET_RING_VAR;
+
+/* Structure for MB Command READ_CONFIG (11) */
+
+typedef struct {
+#if __BIG_ENDIAN
+	uint32_t cr:1;
+	uint32_t ci:1;
+	uint32_t cr_delay:6;
+	uint32_t cr_count:8;
+	uint32_t InitBBC:8;
+	uint32_t MaxBBC:8;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t MaxBBC:8;
+	uint32_t InitBBC:8;
+	uint32_t cr_count:8;
+	uint32_t cr_delay:6;
+	uint32_t ci:1;
+	uint32_t cr:1;
+#endif
+
+#if __BIG_ENDIAN
+	uint32_t topology:8;
+	uint32_t myDid:24;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t myDid:24;
+	uint32_t topology:8;
+#endif
+
+	/* Defines for topology (defined previously) */
+#if __BIG_ENDIAN
+	uint32_t AR:1;
+	uint32_t IR:1;
+	uint32_t rsvd1:29;
+	uint32_t ack0:1;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t ack0:1;
+	uint32_t rsvd1:29;
+	uint32_t IR:1;
+	uint32_t AR:1;
+#endif
+
+	uint32_t edtov;
+	uint32_t arbtov;
+	uint32_t ratov;
+	uint32_t rttov;
+	uint32_t altov;
+	uint32_t lmt;
+
+#define LMT_RESERVED    0x0	 /* Not used */
+#define LMT_266_10bit   0x1	 /*  265.625 Mbaud 10 bit iface */
+#define LMT_532_10bit   0x2	 /*  531.25  Mbaud 10 bit iface */
+#define LMT_1063_20bit  0x3	 /* 1062.5   Mbaud 20 bit iface */
+#define LMT_1063_10bit  0x4	 /* 1062.5   Mbaud 10 bit iface */
+#define LMT_2125_10bit  0x8	 /* 2125     Mbaud 10 bit iface */
+#define LMT_4250_10bit  0x40	 /* 4250     Mbaud 10 bit iface */
+
+	uint32_t rsvd2;
+	uint32_t rsvd3;
+	uint32_t max_xri;
+	uint32_t max_iocb;
+	uint32_t max_rpi;
+	uint32_t avail_xri;
+	uint32_t avail_iocb;
+	uint32_t avail_rpi;
+	uint32_t default_rpi;
+} READ_CONFIG_VAR;
+
+/* Structure for MB Command READ_RCONFIG (12) */
+
+typedef struct {
+#if __BIG_ENDIAN
+	uint32_t rsvd2:7;
+	uint32_t recvNotify:1;
+	uint32_t numMask:8;
+	uint32_t profile:8;
+	uint32_t rsvd1:4;
+	uint32_t ring:4;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t ring:4;
+	uint32_t rsvd1:4;
+	uint32_t profile:8;
+	uint32_t numMask:8;
+	uint32_t recvNotify:1;
+	uint32_t rsvd2:7;
+#endif
+
+#if __BIG_ENDIAN
+	uint16_t maxResp;
+	uint16_t maxOrig;
+#else	/*  __LITTLE_ENDIAN */
+	uint16_t maxOrig;
+	uint16_t maxResp;
+#endif
+
+	RR_REG rrRegs[6];
+
+#if __BIG_ENDIAN
+	uint16_t cmdRingOffset;
+	uint16_t cmdEntryCnt;
+	uint16_t rspRingOffset;
+	uint16_t rspEntryCnt;
+	uint16_t nextCmdOffset;
+	uint16_t rsvd3;
+	uint16_t nextRspOffset;
+	uint16_t rsvd4;
+#else	/*  __LITTLE_ENDIAN */
+	uint16_t cmdEntryCnt;
+	uint16_t cmdRingOffset;
+	uint16_t rspEntryCnt;
+	uint16_t rspRingOffset;
+	uint16_t rsvd3;
+	uint16_t nextCmdOffset;
+	uint16_t rsvd4;
+	uint16_t nextRspOffset;
+#endif
+} READ_RCONF_VAR;
+
+/* Structure for MB Command READ_SPARM (13) */
+/* Structure for MB Command READ_SPARM64 (0x8D) */
+
+typedef struct {
+	uint32_t rsvd1;
+	uint32_t rsvd2;
+	union {
+		ULP_BDE sp;	/* This BDE points to SERV_PARM structure */
+		ULP_BDE64 sp64;
+	} un;
+} READ_SPARM_VAR;
+
+/* Structure for MB Command READ_STATUS (14) */
+
+typedef struct {
+#if __BIG_ENDIAN
+	uint32_t rsvd1:31;
+	uint32_t clrCounters:1;
+	uint16_t activeXriCnt;
+	uint16_t activeRpiCnt;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t clrCounters:1;
+	uint32_t rsvd1:31;
+	uint16_t activeRpiCnt;
+	uint16_t activeXriCnt;
+#endif
+
+	uint32_t xmitByteCnt;
+	uint32_t rcvByteCnt;
+	uint32_t xmitFrameCnt;
+	uint32_t rcvFrameCnt;
+	uint32_t xmitSeqCnt;
+	uint32_t rcvSeqCnt;
+	uint32_t totalOrigExchanges;
+	uint32_t totalRespExchanges;
+	uint32_t rcvPbsyCnt;
+	uint32_t rcvFbsyCnt;
+} READ_STATUS_VAR;
+
+/* Structure for MB Command READ_RPI (15) */
+/* Structure for MB Command READ_RPI64 (0x8F) */
+
+typedef struct {
+#if __BIG_ENDIAN
+	uint16_t nextRpi;
+	uint16_t reqRpi;
+	uint32_t rsvd2:8;
+	uint32_t DID:24;
+#else	/*  __LITTLE_ENDIAN */
+	uint16_t reqRpi;
+	uint16_t nextRpi;
+	uint32_t DID:24;
+	uint32_t rsvd2:8;
+#endif
+
+	union {
+		ULP_BDE sp;
+		ULP_BDE64 sp64;
+	} un;
+
+} READ_RPI_VAR;
+
+/* Structure for MB Command READ_XRI (16) */
+
+typedef struct {
+#if __BIG_ENDIAN
+	uint16_t nextXri;
+	uint16_t reqXri;
+	uint16_t rsvd1;
+	uint16_t rpi;
+	uint32_t rsvd2:8;
+	uint32_t DID:24;
+	uint32_t rsvd3:8;
+	uint32_t SID:24;
+	uint32_t rsvd4;
+	uint8_t seqId;
+	uint8_t rsvd5;
+	uint16_t seqCount;
+	uint16_t oxId;
+	uint16_t rxId;
+	uint32_t rsvd6:30;
+	uint32_t si:1;
+	uint32_t exchOrig:1;
+#else	/*  __LITTLE_ENDIAN */
+	uint16_t reqXri;
+	uint16_t nextXri;
+	uint16_t rpi;
+	uint16_t rsvd1;
+	uint32_t DID:24;
+	uint32_t rsvd2:8;
+	uint32_t SID:24;
+	uint32_t rsvd3:8;
+	uint32_t rsvd4;
+	uint16_t seqCount;
+	uint8_t rsvd5;
+	uint8_t seqId;
+	uint16_t rxId;
+	uint16_t oxId;
+	uint32_t exchOrig:1;
+	uint32_t si:1;
+	uint32_t rsvd6:30;
+#endif
+} READ_XRI_VAR;
+
+/* Structure for MB Command READ_REV (17) */
+
+typedef struct {
+#if __BIG_ENDIAN
+	uint32_t cv:1;
+	uint32_t rr:1;
+	uint32_t rsvd1:29;
+	uint32_t rv:1;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t rv:1;
+	uint32_t rsvd1:29;
+	uint32_t rr:1;
+	uint32_t cv:1;
+#endif
+
+	uint32_t biuRev;
+	uint32_t smRev;
+	union {
+		uint32_t smFwRev;
+		struct {
+#if __BIG_ENDIAN
+			uint8_t ProgType;
+			uint8_t ProgId;
+			uint16_t ProgVer:4;
+			uint16_t ProgRev:4;
+			uint16_t ProgFixLvl:2;
+			uint16_t ProgDistType:2;
+			uint16_t DistCnt:4;
+#else	/*  __LITTLE_ENDIAN */
+			uint16_t DistCnt:4;
+			uint16_t ProgDistType:2;
+			uint16_t ProgFixLvl:2;
+			uint16_t ProgRev:4;
+			uint16_t ProgVer:4;
+			uint8_t ProgId;
+			uint8_t ProgType;
+#endif
+
+		} b;
+	} un;
+	uint32_t endecRev;
+#if __BIG_ENDIAN
+	uint8_t feaLevelHigh;
+	uint8_t feaLevelLow;
+	uint8_t fcphHigh;
+	uint8_t fcphLow;
+#else	/*  __LITTLE_ENDIAN */
+	uint8_t fcphLow;
+	uint8_t fcphHigh;
+	uint8_t feaLevelLow;
+	uint8_t feaLevelHigh;
+#endif
+
+	uint32_t postKernRev;
+	uint32_t opFwRev;
+	uint8_t opFwName[16];
+	uint32_t sli1FwRev;
+	uint8_t sli1FwName[16];
+	uint32_t sli2FwRev;
+	uint8_t sli2FwName[16];
+	uint32_t rsvd2;
+	uint32_t RandomData[7];
+} READ_REV_VAR;
+
+#define rxSeqRev postKernRev
+#define txSeqRev opFwRev
+
+/* Structure for MB Command READ_LINK_STAT (18) */
+
+typedef struct {
+	uint32_t rsvd1;
+	uint32_t linkFailureCnt;
+	uint32_t lossSyncCnt;
+
+	uint32_t lossSignalCnt;
+	uint32_t primSeqErrCnt;
+	uint32_t invalidXmitWord;
+	uint32_t crcCnt;
+	uint32_t primSeqTimeout;
+	uint32_t elasticOverrun;
+	uint32_t arbTimeout;
+} READ_LNK_VAR;
+
+/* Structure for MB Command REG_LOGIN (19) */
+/* Structure for MB Command REG_LOGIN64 (0x93) */
+
+typedef struct {
+#if __BIG_ENDIAN
+	uint16_t rsvd1;
+	uint16_t rpi;
+	uint32_t rsvd2:8;
+	uint32_t did:24;
+#else	/*  __LITTLE_ENDIAN */
+	uint16_t rpi;
+	uint16_t rsvd1;
+	uint32_t did:24;
+	uint32_t rsvd2:8;
+#endif
+
+	union {
+		ULP_BDE sp;
+		ULP_BDE64 sp64;
+	} un;
+
+} REG_LOGIN_VAR;
+
+/* Word 30 contents for REG_LOGIN */
+typedef union {
+	struct {
+#if __BIG_ENDIAN
+		uint16_t rsvd1:12;
+		uint16_t wd30_class:4;
+		uint16_t xri;
+#else	/*  __LITTLE_ENDIAN */
+		uint16_t xri;
+		uint16_t wd30_class:4;
+		uint16_t rsvd1:12;
+#endif
+	} f;
+	uint32_t word;
+} REG_WD30;
+
+/* Structure for MB Command UNREG_LOGIN (20) */
+
+typedef struct {
+#if __BIG_ENDIAN
+	uint16_t rsvd1;
+	uint16_t rpi;
+#else	/*  __LITTLE_ENDIAN */
+	uint16_t rpi;
+	uint16_t rsvd1;
+#endif
+} UNREG_LOGIN_VAR;
+
+/* Structure for MB Command UNREG_D_ID (0x23) */
+
+typedef struct {
+	uint32_t did;
+} UNREG_D_ID_VAR;
+
+/* Structure for MB Command READ_LA (21) */
+/* Structure for MB Command READ_LA64 (0x95) */
+
+typedef struct {
+	uint32_t eventTag;	/* Event tag */
+#if __BIG_ENDIAN
+	uint32_t rsvd1:22;
+	uint32_t pb:1;
+	uint32_t il:1;
+	uint32_t attType:8;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t attType:8;
+	uint32_t il:1;
+	uint32_t pb:1;
+	uint32_t rsvd1:22;
+#endif
+
+#define AT_RESERVED    0x00	/* Reserved - attType */
+#define AT_LINK_UP     0x01	/* Link is up */
+#define AT_LINK_DOWN   0x02	/* Link is down */
+
+#if __BIG_ENDIAN
+	uint8_t granted_AL_PA;
+	uint8_t lipAlPs;
+	uint8_t lipType;
+	uint8_t topology;
+#else	/*  __LITTLE_ENDIAN */
+	uint8_t topology;
+	uint8_t lipType;
+	uint8_t lipAlPs;
+	uint8_t granted_AL_PA;
+#endif
+
+#define LT_PORT_INIT    0x00	/* An L_PORT initing (F7, AL_PS) - lipType */
+#define LT_PORT_ERR     0x01	/* Err @L_PORT rcv'er (F8, AL_PS) */
+#define LT_RESET_APORT  0x02	/* Lip Reset of some other port */
+#define LT_RESET_MYPORT 0x03	/* Lip Reset of my port */
+#define TOPOLOGY_PT_PT 0x01	/* Topology is pt-pt / pt-fabric */
+#define TOPOLOGY_LOOP  0x02	/* Topology is FC-AL */
+
+	union {
+		ULP_BDE lilpBde; /* This BDE points to a 128 byte buffer to */
+		/* store the LILP AL_PA position map into */
+		ULP_BDE64 lilpBde64;
+	} un;
+
+#if __BIG_ENDIAN
+	uint32_t Dlu:1;
+	uint32_t Dtf:1;
+	uint32_t Drsvd2:14;
+	uint32_t DlnkSpeed:8;
+	uint32_t DnlPort:4;
+	uint32_t Dtx:2;
+	uint32_t Drx:2;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t Drx:2;
+	uint32_t Dtx:2;
+	uint32_t DnlPort:4;
+	uint32_t DlnkSpeed:8;
+	uint32_t Drsvd2:14;
+	uint32_t Dtf:1;
+	uint32_t Dlu:1;
+#endif
+
+#if __BIG_ENDIAN
+	uint32_t Ulu:1;
+	uint32_t Utf:1;
+	uint32_t Ursvd2:14;
+	uint32_t UlnkSpeed:8;
+	uint32_t UnlPort:4;
+	uint32_t Utx:2;
+	uint32_t Urx:2;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t Urx:2;
+	uint32_t Utx:2;
+	uint32_t UnlPort:4;
+	uint32_t UlnkSpeed:8;
+	uint32_t Ursvd2:14;
+	uint32_t Utf:1;
+	uint32_t Ulu:1;
+#endif
+
+#define LA_UNKNW_LINK  0x0	/* lnkSpeed */
+#define LA_1GHZ_LINK   0x04	/* lnkSpeed */
+#define LA_2GHZ_LINK   0x08	/* lnkSpeed */
+#define LA_4GHZ_LINK   0x10	/* lnkSpeed */
+#define LA_8GHZ_LINK   0x20	/* lnkSpeed */
+#define LA_10GHZ_LINK  0x40	/* lnkSpeed */
+
+} READ_LA_VAR;
+
+/* Structure for MB Command CLEAR_LA (22) */
+
+typedef struct {
+	uint32_t eventTag;	/* Event tag */
+	uint32_t rsvd1;
+} CLEAR_LA_VAR;
+
+/* Structure for MB Command DUMP */
+
+typedef struct {
+#if __BIG_ENDIAN
+	uint32_t rsvd:25;
+	uint32_t ra:1;
+	uint32_t co:1;
+	uint32_t cv:1;
+	uint32_t type:4;
+	uint32_t entry_index:16;
+	uint32_t region_id:16;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t type:4;
+	uint32_t cv:1;
+	uint32_t co:1;
+	uint32_t ra:1;
+	uint32_t rsvd:25;
+	uint32_t region_id:16;
+	uint32_t entry_index:16;
+#endif
+
+	uint32_t rsvd1;
+	uint32_t word_cnt;
+	uint32_t resp_offset;
+} DUMP_VAR;
+
+#define  DMP_MEM_REG             0x1
+#define  DMP_NV_PARAMS           0x2
+
+#define  DMP_REGION_VPD          0xe
+#define  DMP_VPD_SIZE            0x400  /* maximum amount of VPD */
+#define  DMP_RSP_OFFSET          0x14   /* word 5 contains first word of rsp */
+#define  DMP_RSP_SIZE            0x6C   /* maximum of 27 words of rsp data */
+
+/* Structure for MB Command CONFIG_PORT (0x88) */
+
+typedef struct {
+	uint32_t pcbLen;
+	uint32_t pcbLow;       /* bit 31:0  of memory based port config block */
+	uint32_t pcbHigh;      /* bit 63:32 of memory based port config block */
+	uint32_t hbainit[5];
+} CONFIG_PORT_VAR;
+
+/* SLI-2 Port Control Block */
+
+/* SLIM POINTER */
+#define SLIMOFF 0x30		/* WORD */
+
+typedef struct _SLI2_RDSC {
+	uint32_t cmdEntries;
+	uint32_t cmdAddrLow;
+	uint32_t cmdAddrHigh;
+
+	uint32_t rspEntries;
+	uint32_t rspAddrLow;
+	uint32_t rspAddrHigh;
+} SLI2_RDSC;
+
+typedef struct _PCB {
+#if __BIG_ENDIAN
+	uint32_t type:8;
+#define TYPE_NATIVE_SLI2       0x01;
+	uint32_t feature:8;
+#define FEATURE_INITIAL_SLI2   0x01;
+	uint32_t rsvd:12;
+	uint32_t maxRing:4;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t maxRing:4;
+	uint32_t rsvd:12;
+	uint32_t feature:8;
+#define FEATURE_INITIAL_SLI2   0x01;
+	uint32_t type:8;
+#define TYPE_NATIVE_SLI2       0x01;
+#endif
+
+	uint32_t mailBoxSize;
+	uint32_t mbAddrLow;
+	uint32_t mbAddrHigh;
+
+	uint32_t hgpAddrLow;
+	uint32_t hgpAddrHigh;
+
+	uint32_t pgpAddrLow;
+	uint32_t pgpAddrHigh;
+	SLI2_RDSC rdsc[MAX_RINGS];
+} PCB_t;
+
+/* NEW_FEATURE */
+typedef struct {
+#if __BIG_ENDIAN
+	uint32_t rsvd0:27;
+	uint32_t discardFarp:1;
+	uint32_t IPEnable:1;
+	uint32_t nodeName:1;
+	uint32_t portName:1;
+	uint32_t filterEnable:1;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t filterEnable:1;
+	uint32_t portName:1;
+	uint32_t nodeName:1;
+	uint32_t IPEnable:1;
+	uint32_t discardFarp:1;
+	uint32_t rsvd:27;
+#endif
+
+	uint8_t portname[8];	/* Used to be NAME_TYPE */
+	uint8_t nodename[8];
+	uint32_t rsvd1;
+	uint32_t rsvd2;
+	uint32_t rsvd3;
+	uint32_t IPAddress;
+} CONFIG_FARP_VAR;
+
+/* Union of all Mailbox Command types */
+#define MAILBOX_CMD_WSIZE 32
+
+typedef union {
+	uint32_t varWords[MAILBOX_CMD_WSIZE - 1];
+	LOAD_SM_VAR varLdSM;	/* cmd =  1 (LOAD_SM)        */
+	READ_NV_VAR varRDnvp;	/* cmd =  2 (READ_NVPARMS)   */
+	WRITE_NV_VAR varWTnvp;	/* cmd =  3 (WRITE_NVPARMS)  */
+	BIU_DIAG_VAR varBIUdiag;	/* cmd =  4 (RUN_BIU_DIAG)   */
+	INIT_LINK_VAR varInitLnk;	/* cmd =  5 (INIT_LINK)      */
+	DOWN_LINK_VAR varDwnLnk;	/* cmd =  6 (DOWN_LINK)      */
+	CONFIG_LINK varCfgLnk;	/* cmd =  7 (CONFIG_LINK)    */
+	PART_SLIM_VAR varSlim;	/* cmd =  8 (PART_SLIM)      */
+	CONFIG_RING_VAR varCfgRing;	/* cmd =  9 (CONFIG_RING)    */
+	RESET_RING_VAR varRstRing;	/* cmd = 10 (RESET_RING)     */
+	READ_CONFIG_VAR varRdConfig;	/* cmd = 11 (READ_CONFIG)    */
+	READ_RCONF_VAR varRdRConfig;	/* cmd = 12 (READ_RCONFIG)   */
+	READ_SPARM_VAR varRdSparm;	/* cmd = 13 (READ_SPARM(64)) */
+	READ_STATUS_VAR varRdStatus;	/* cmd = 14 (READ_STATUS)    */
+	READ_RPI_VAR varRdRPI;	/* cmd = 15 (READ_RPI(64))   */
+	READ_XRI_VAR varRdXRI;	/* cmd = 16 (READ_XRI)       */
+	READ_REV_VAR varRdRev;	/* cmd = 17 (READ_REV)       */
+	READ_LNK_VAR varRdLnk;	/* cmd = 18 (READ_LNK_STAT)  */
+	REG_LOGIN_VAR varRegLogin;	/* cmd = 19 (REG_LOGIN(64))  */
+	UNREG_LOGIN_VAR varUnregLogin;	/* cmd = 20 (UNREG_LOGIN)    */
+	READ_LA_VAR varReadLA;	/* cmd = 21 (READ_LA(64))    */
+	CLEAR_LA_VAR varClearLA;	/* cmd = 22 (CLEAR_LA)       */
+	DUMP_VAR varDmp;	/* Warm Start DUMP mbx cmd   */
+	UNREG_D_ID_VAR varUnregDID; /* cmd = 0x23 (UNREG_D_ID)   */
+	CONFIG_FARP_VAR varCfgFarp; /* cmd = 0x25 (CONFIG_FARP)  NEW_FEATURE */
+	CONFIG_PORT_VAR varCfgPort; /* cmd = 0x88 (CONFIG_PORT)  */
+} MAILVARIANTS;
+
+/*
+ * SLI-2 specific structures
+ */
+
+typedef struct {
+	uint32_t cmdPutInx;
+	uint32_t rspGetInx;
+} HGP;
+
+typedef struct {
+	uint32_t cmdGetInx;
+	uint32_t rspPutInx;
+} PGP;
+
+typedef struct _SLI2_DESC {
+	HGP host[MAX_RINGS];
+	uint32_t unused1[16];
+	PGP port[MAX_RINGS];
+} SLI2_DESC;
+
+typedef union {
+	SLI2_DESC s2;
+} SLI_VAR;
+
+typedef volatile struct {
+#if __BIG_ENDIAN
+	uint16_t mbxStatus;
+	uint8_t mbxCommand;
+	uint8_t mbxReserved:6;
+	uint8_t mbxHc:1;
+	uint8_t mbxOwner:1;	/* Low order bit first word */
+#else	/*  __LITTLE_ENDIAN */
+	uint8_t mbxOwner:1;	/* Low order bit first word */
+	uint8_t mbxHc:1;
+	uint8_t mbxReserved:6;
+	uint8_t mbxCommand;
+	uint16_t mbxStatus;
+#endif
+
+	MAILVARIANTS un;
+	SLI_VAR us;
+} MAILBOX_t, *PMAILBOX_t;
+
+/*
+ *    Begin Structure Definitions for IOCB Commands
+ */
+
+typedef struct {
+#if __BIG_ENDIAN
+	uint8_t statAction;
+	uint8_t statRsn;
+	uint8_t statBaExp;
+	uint8_t statLocalError;
+#else	/*  __LITTLE_ENDIAN */
+	uint8_t statLocalError;
+	uint8_t statBaExp;
+	uint8_t statRsn;
+	uint8_t statAction;
+#endif
+	/* statAction  FBSY reason codes */
+#define FBSY_RSN_MASK   0xF0	/* Rsn stored in upper nibble */
+#define FBSY_FABRIC_BSY 0x10	/* F_bsy due to Fabric BSY */
+#define FBSY_NPORT_BSY  0x30	/* F_bsy due to N_port BSY */
+
+	/* statAction  PBSY action codes */
+#define PBSY_ACTION1    0x01	/* Sequence terminated - retry */
+#define PBSY_ACTION2    0x02	/* Sequence active - retry */
+
+	/* statAction  P/FRJT action codes */
+#define RJT_RETRYABLE   0x01	/* Retryable class of error */
+#define RJT_NO_RETRY    0x02	/* Non-Retryable class of error */
+
+	/* statRsn  LS_RJT reason codes defined in LS_RJT structure */
+
+	/* statRsn  P_BSY reason codes */
+#define PBSY_NPORT_BSY  0x01	/* Physical N_port BSY */
+#define PBSY_RESRCE_BSY 0x03	/* N_port resource BSY */
+#define PBSY_VU_BSY     0xFF	/* See VU field for rsn */
+
+	/* statRsn  P/F_RJT reason codes */
+#define RJT_BAD_D_ID       0x01	/* Invalid D_ID field */
+#define RJT_BAD_S_ID       0x02	/* Invalid S_ID field */
+#define RJT_UNAVAIL_TEMP   0x03	/* N_Port unavailable temp. */
+#define RJT_UNAVAIL_PERM   0x04	/* N_Port unavailable perm. */
+#define RJT_UNSUP_CLASS    0x05	/* Class not supported */
+#define RJT_DELIM_ERR      0x06	/* Delimiter usage error */
+#define RJT_UNSUP_TYPE     0x07	/* Type not supported */
+#define RJT_BAD_CONTROL    0x08	/* Invalid link conrtol */
+#define RJT_BAD_RCTL       0x09	/* R_CTL invalid */
+#define RJT_BAD_FCTL       0x0A	/* F_CTL invalid */
+#define RJT_BAD_OXID       0x0B	/* OX_ID invalid */
+#define RJT_BAD_RXID       0x0C	/* RX_ID invalid */
+#define RJT_BAD_SEQID      0x0D	/* SEQ_ID invalid */
+#define RJT_BAD_DFCTL      0x0E	/* DF_CTL invalid */
+#define RJT_BAD_SEQCNT     0x0F	/* SEQ_CNT invalid */
+#define RJT_BAD_PARM       0x10	/* Param. field invalid */
+#define RJT_XCHG_ERR       0x11	/* Exchange error */
+#define RJT_PROT_ERR       0x12	/* Protocol error */
+#define RJT_BAD_LENGTH     0x13	/* Invalid Length */
+#define RJT_UNEXPECTED_ACK 0x14	/* Unexpected ACK */
+#define RJT_LOGIN_REQUIRED 0x16	/* Login required */
+#define RJT_TOO_MANY_SEQ   0x17	/* Excessive sequences */
+#define RJT_XCHG_NOT_STRT  0x18	/* Exchange not started */
+#define RJT_UNSUP_SEC_HDR  0x19	/* Security hdr not supported */
+#define RJT_UNAVAIL_PATH   0x1A	/* Fabric Path not available */
+#define RJT_VENDOR_UNIQUE  0xFF	/* Vendor unique error */
+
+	/* statRsn  BA_RJT reason codes */
+#define BARJT_BAD_CMD_CODE 0x01	/* Invalid command code */
+#define BARJT_LOGICAL_ERR  0x03	/* Logical error */
+#define BARJT_LOGICAL_BSY  0x05	/* Logical busy */
+#define BARJT_PROTOCOL_ERR 0x07	/* Protocol error */
+#define BARJT_VU_ERR       0xFF	/* Vendor unique error */
+
+	/* LS_RJT reason explanation defined in LS_RJT structure */
+
+	/* BA_RJT reason explanation */
+#define BARJT_EXP_INVALID_ID  0x01	/* Invalid OX_ID/RX_ID */
+#define BARJT_EXP_ABORT_SEQ   0x05	/* Abort SEQ, no more info */
+
+	/* FireFly localy detected errors */
+#define IOERR_SUCCESS                 0x00	/* statLocalError */
+#define IOERR_MISSING_CONTINUE        0x01
+#define IOERR_SEQUENCE_TIMEOUT        0x02
+#define IOERR_INTERNAL_ERROR          0x03
+#define IOERR_INVALID_RPI             0x04
+#define IOERR_NO_XRI                  0x05
+#define IOERR_ILLEGAL_COMMAND         0x06
+#define IOERR_XCHG_DROPPED            0x07
+#define IOERR_ILLEGAL_FIELD           0x08
+#define IOERR_BAD_CONTINUE            0x09
+#define IOERR_TOO_MANY_BUFFERS        0x0A
+#define IOERR_RCV_BUFFER_WAITING      0x0B
+#define IOERR_NO_CONNECTION           0x0C
+#define IOERR_TX_DMA_FAILED           0x0D
+#define IOERR_RX_DMA_FAILED           0x0E
+#define IOERR_ILLEGAL_FRAME           0x0F
+#define IOERR_EXTRA_DATA              0x10
+#define IOERR_NO_RESOURCES            0x11
+#define IOERR_RESERVED                0x12
+#define IOERR_ILLEGAL_LENGTH          0x13
+#define IOERR_UNSUPPORTED_FEATURE     0x14
+#define IOERR_ABORT_IN_PROGRESS       0x15
+#define IOERR_ABORT_REQUESTED         0x16
+#define IOERR_RECEIVE_BUFFER_TIMEOUT  0x17
+#define IOERR_LOOP_OPEN_FAILURE       0x18
+#define IOERR_RING_RESET              0x19
+#define IOERR_LINK_DOWN               0x1A
+#define IOERR_CORRUPTED_DATA          0x1B
+#define IOERR_CORRUPTED_RPI           0x1C
+#define IOERR_OUT_OF_ORDER_DATA       0x1D
+#define IOERR_OUT_OF_ORDER_ACK        0x1E
+#define IOERR_DUP_FRAME               0x1F
+#define IOERR_LINK_CONTROL_FRAME      0x20	/* ACK_N received */
+#define IOERR_BAD_HOST_ADDRESS        0x21
+#define IOERR_RCV_HDRBUF_WAITING      0x22
+#define IOERR_MISSING_HDR_BUFFER      0x23
+#define IOERR_MSEQ_CHAIN_CORRUPTED    0x24
+#define IOERR_ABORTMULT_REQUESTED     0x25
+#define IOERR_BUFFER_SHORTAGE         0x28
+#define IOERR_DEFAULT                 0x29
+#define IOERR_CNT                     0x2A
+
+#define IOERR_DRVR_MASK               0x100
+#define IOERR_SLI_DOWN                0x101  /* ulpStatus  - Driver defined */
+#define IOERR_SLI_BRESET              0x102
+#define IOERR_SLI_ABORTED             0x103
+} PARM_ERR;
+
+typedef union {
+	struct {
+#if __BIG_ENDIAN
+		uint8_t Rctl;	/* R_CTL field */
+		uint8_t Type;	/* TYPE field */
+		uint8_t Dfctl;	/* DF_CTL field */
+		uint8_t Fctl;	/* Bits 0-7 of IOCB word 5 */
+#else	/*  __LITTLE_ENDIAN */
+		uint8_t Fctl;	/* Bits 0-7 of IOCB word 5 */
+		uint8_t Dfctl;	/* DF_CTL field */
+		uint8_t Type;	/* TYPE field */
+		uint8_t Rctl;	/* R_CTL field */
+#endif
+
+#define BC      0x02		/* Broadcast Received  - Fctl */
+#define SI      0x04		/* Sequence Initiative */
+#define LA      0x08		/* Ignore Link Attention state */
+#define LS      0x80		/* Last Sequence */
+	} hcsw;
+	uint32_t reserved;
+} WORD5;
+
+/* IOCB Command template for a generic response */
+typedef struct {
+	uint32_t reserved[4];
+	PARM_ERR perr;
+} GENERIC_RSP;
+
+/* IOCB Command template for XMIT / XMIT_BCAST / RCV_SEQUENCE / XMIT_ELS */
+typedef struct {
+	ULP_BDE xrsqbde[2];
+	uint32_t xrsqRo;	/* Starting Relative Offset */
+	WORD5 w5;		/* Header control/status word */
+} XR_SEQ_FIELDS;
+
+/* IOCB Command template for ELS_REQUEST */
+typedef struct {
+	ULP_BDE elsReq;
+	ULP_BDE elsRsp;
+
+#if __BIG_ENDIAN
+	uint32_t word4Rsvd:7;
+	uint32_t fl:1;
+	uint32_t myID:24;
+	uint32_t word5Rsvd:8;
+	uint32_t remoteID:24;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t myID:24;
+	uint32_t fl:1;
+	uint32_t word4Rsvd:7;
+	uint32_t remoteID:24;
+	uint32_t word5Rsvd:8;
+#endif
+} ELS_REQUEST;
+
+/* IOCB Command template for RCV_ELS_REQ */
+typedef struct {
+	ULP_BDE elsReq[2];
+	uint32_t parmRo;
+
+#if __BIG_ENDIAN
+	uint32_t word5Rsvd:8;
+	uint32_t remoteID:24;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t remoteID:24;
+	uint32_t word5Rsvd:8;
+#endif
+} RCV_ELS_REQ;
+
+/* IOCB Command template for ABORT / CLOSE_XRI */
+typedef struct {
+	uint32_t rsvd[3];
+	uint32_t abortType;
+#define ABORT_TYPE_ABTX  0x00000000
+#define ABORT_TYPE_ABTS  0x00000001
+	uint32_t parm;
+#if __BIG_ENDIAN
+	uint16_t abortContextTag; /* ulpContext from command to abort/close */
+	uint16_t abortIoTag;	/* ulpIoTag from command to abort/close */
+#else	/*  __LITTLE_ENDIAN */
+	uint16_t abortIoTag;	/* ulpIoTag from command to abort/close */
+	uint16_t abortContextTag; /* ulpContext from command to abort/close */
+#endif
+} AC_XRI;
+
+/* IOCB Command template for ABORT_MXRI64 */
+typedef struct {
+	uint32_t rsvd[3];
+	uint32_t abortType;
+	uint32_t parm;
+	uint32_t iotag32;
+} A_MXRI64;
+
+/* IOCB Command template for GET_RPI */
+typedef struct {
+	uint32_t rsvd[4];
+	uint32_t parmRo;
+#if __BIG_ENDIAN
+	uint32_t word5Rsvd:8;
+	uint32_t remoteID:24;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t remoteID:24;
+	uint32_t word5Rsvd:8;
+#endif
+} GET_RPI;
+
+/* IOCB Command template for all FCP Initiator commands */
+typedef struct {
+	ULP_BDE fcpi_cmnd;	/* FCP_CMND payload descriptor */
+	ULP_BDE fcpi_rsp;	/* Rcv buffer */
+	uint32_t fcpi_parm;
+	uint32_t fcpi_XRdy;	/* transfer ready for IWRITE */
+} FCPI_FIELDS;
+
+/* IOCB Command template for all FCP Target commands */
+typedef struct {
+	ULP_BDE fcpt_Buffer[2];	/* FCP_CMND payload descriptor */
+	uint32_t fcpt_Offset;
+	uint32_t fcpt_Length;	/* transfer ready for IWRITE */
+} FCPT_FIELDS;
+
+/* SLI-2 IOCB structure definitions */
+
+/* IOCB Command template for 64 bit XMIT / XMIT_BCAST / XMIT_ELS */
+typedef struct {
+	ULP_BDL bdl;
+	uint32_t xrsqRo;	/* Starting Relative Offset */
+	WORD5 w5;		/* Header control/status word */
+} XMT_SEQ_FIELDS64;
+
+/* IOCB Command template for 64 bit RCV_SEQUENCE64 */
+typedef struct {
+	ULP_BDE64 rcvBde;
+	uint32_t rsvd1;
+	uint32_t xrsqRo;	/* Starting Relative Offset */
+	WORD5 w5;		/* Header control/status word */
+} RCV_SEQ_FIELDS64;
+
+/* IOCB Command template for ELS_REQUEST64 */
+typedef struct {
+	ULP_BDL bdl;
+#if __BIG_ENDIAN
+	uint32_t word4Rsvd:7;
+	uint32_t fl:1;
+	uint32_t myID:24;
+	uint32_t word5Rsvd:8;
+	uint32_t remoteID:24;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t myID:24;
+	uint32_t fl:1;
+	uint32_t word4Rsvd:7;
+	uint32_t remoteID:24;
+	uint32_t word5Rsvd:8;
+#endif
+} ELS_REQUEST64;
+
+/* IOCB Command template for GEN_REQUEST64 */
+typedef struct {
+	ULP_BDL bdl;
+	uint32_t xrsqRo;	/* Starting Relative Offset */
+	WORD5 w5;		/* Header control/status word */
+} GEN_REQUEST64;
+
+/* IOCB Command template for RCV_ELS_REQ64 */
+typedef struct {
+	ULP_BDE64 elsReq;
+	uint32_t rcvd1;
+	uint32_t parmRo;
+
+#if __BIG_ENDIAN
+	uint32_t word5Rsvd:8;
+	uint32_t remoteID:24;
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t remoteID:24;
+	uint32_t word5Rsvd:8;
+#endif
+} RCV_ELS_REQ64;
+
+/* IOCB Command template for all 64 bit FCP Initiator commands */
+typedef struct {
+	ULP_BDL bdl;
+	uint32_t fcpi_parm;
+	uint32_t fcpi_XRdy;	/* transfer ready for IWRITE */
+} FCPI_FIELDS64;
+
+/* IOCB Command template for all 64 bit FCP Target commands */
+typedef struct {
+	ULP_BDL bdl;
+	uint32_t fcpt_Offset;
+	uint32_t fcpt_Length;	/* transfer ready for IWRITE */
+} FCPT_FIELDS64;
+
+typedef volatile struct _IOCB {	/* IOCB structure */
+	union {
+		GENERIC_RSP grsp;	/* Generic response */
+		XR_SEQ_FIELDS xrseq;	/* XMIT / BCAST / RCV_SEQUENCE cmd */
+		ULP_BDE cont[3];	/* up to 3 continuation bdes */
+		RCV_ELS_REQ rcvels;	/* RCV_ELS_REQ template */
+		AC_XRI acxri;	/* ABORT / CLOSE_XRI template */
+		A_MXRI64 amxri;	/* abort multiple xri command overlay */
+		GET_RPI getrpi;	/* GET_RPI template */
+		FCPI_FIELDS fcpi;	/* FCP Initiator template */
+		FCPT_FIELDS fcpt;	/* FCP target template */
+
+		/* SLI-2 structures */
+
+		ULP_BDE64 cont64[2];	/* up to 2 64 bit continuation
+					   bde_64s */
+		ELS_REQUEST64 elsreq64;	/* ELS_REQUEST template */
+		GEN_REQUEST64 genreq64;	/* GEN_REQUEST template */
+		RCV_ELS_REQ64 rcvels64;	/* RCV_ELS_REQ template */
+		XMT_SEQ_FIELDS64 xseq64;	/* XMIT / BCAST cmd */
+		FCPI_FIELDS64 fcpi64;	/* FCP 64 bit Initiator template */
+		FCPT_FIELDS64 fcpt64;	/* FCP 64 bit target template */
+
+		uint32_t ulpWord[IOCB_WORD_SZ - 2];	/* generic 6 'words' */
+	} un;
+	union {
+		struct {
+#if __BIG_ENDIAN
+			uint16_t ulpContext;	/* High order bits word 6 */
+			uint16_t ulpIoTag;	/* Low  order bits word 6 */
+#else	/*  __LITTLE_ENDIAN */
+			uint16_t ulpIoTag;	/* Low  order bits word 6 */
+			uint16_t ulpContext;	/* High order bits word 6 */
+#endif
+		} t1;
+		struct {
+#if __BIG_ENDIAN
+			uint16_t ulpContext;	/* High order bits word 6 */
+			uint16_t ulpIoTag1:2;	/* Low  order bits word 6 */
+			uint16_t ulpIoTag0:14;	/* Low  order bits word 6 */
+#else	/*  __LITTLE_ENDIAN */
+			uint16_t ulpIoTag0:14;	/* Low  order bits word 6 */
+			uint16_t ulpIoTag1:2;	/* Low  order bits word 6 */
+			uint16_t ulpContext;	/* High order bits word 6 */
+#endif
+		} t2;
+	} un1;
+#define ulpContext un1.t1.ulpContext
+#define ulpIoTag   un1.t1.ulpIoTag
+#define ulpIoTag0  un1.t2.ulpIoTag0
+#define ulpDelayXmit  un1.t2.ulpIoTag1
+#define IOCB_DELAYXMIT_MSK 0x3000
+
+#if __BIG_ENDIAN
+	uint32_t ulpTimeout:8;
+	uint32_t ulpXS:1;
+	uint32_t ulpFCP2Rcvy:1;
+	uint32_t ulpPU:2;
+	uint32_t ulpIr:1;
+	uint32_t ulpClass:3;
+	uint32_t ulpCommand:8;
+	uint32_t ulpStatus:4;
+	uint32_t ulpBdeCount:2;
+	uint32_t ulpLe:1;
+	uint32_t ulpOwner:1;	/* Low order bit word 7 */
+#else	/*  __LITTLE_ENDIAN */
+	uint32_t ulpOwner:1;	/* Low order bit word 7 */
+	uint32_t ulpLe:1;
+	uint32_t ulpBdeCount:2;
+	uint32_t ulpStatus:4;
+	uint32_t ulpCommand:8;
+	uint32_t ulpClass:3;
+	uint32_t ulpIr:1;
+	uint32_t ulpPU:2;
+	uint32_t ulpFCP2Rcvy:1;
+	uint32_t ulpXS:1;
+	uint32_t ulpTimeout:8;
+#endif
+
+#define IOCB_FCP           1	/* IOCB is used for FCP ELS cmds - ulpRsvByte */
+#define IOCB_IP            2	/* IOCB is used for IP ELS cmds */
+#define PARM_UNUSED        0	/* PU field (Word 4) not used */
+#define PARM_REL_OFF       1	/* PU field (Word 4) = R. O. */
+#define PARM_READ_CHECK    2	/* PU field (Word 4) = Data Transfer Length */
+#define CLASS1             0	/* Class 1 */
+#define CLASS2             1	/* Class 2 */
+#define CLASS3             2	/* Class 3 */
+#define CLASS_FCP_INTERMIX 7	/* FCP Data->Cls 1, all else->Cls 2 */
+
+#define IOSTAT_SUCCESS         0x0	/* ulpStatus  - HBA defined */
+#define IOSTAT_FCP_RSP_ERROR   0x1
+#define IOSTAT_REMOTE_STOP     0x2
+#define IOSTAT_LOCAL_REJECT    0x3
+#define IOSTAT_NPORT_RJT       0x4
+#define IOSTAT_FABRIC_RJT      0x5
+#define IOSTAT_NPORT_BSY       0x6
+#define IOSTAT_FABRIC_BSY      0x7
+#define IOSTAT_INTERMED_RSP    0x8
+#define IOSTAT_LS_RJT          0x9
+#define IOSTAT_BA_RJT          0xA
+#define IOSTAT_RSVD1           0xB
+#define IOSTAT_RSVD2           0xC
+#define IOSTAT_RSVD3           0xD
+#define IOSTAT_RSVD4           0xE
+#define IOSTAT_RSVD5           0xF
+#define IOSTAT_DRIVER_REJECT   0x10   /* ulpStatus  - Driver defined */
+#define IOSTAT_DEFAULT         0xF    /* Same as rsvd5 for now */
+#define IOSTAT_CNT             0x11
+
+} IOCB_t, *PIOCB_t;
+
+/* Up to 498 IOCBs will fit into 16k 
+ * 256 (MAILBOX_t) + 140 (PCB_t) + ( 32 (IOCB_t) * 498 ) = < 16384
+ */
+#define SLI2_SLIM_SIZE   (16 * 1024)
+
+/* Maximum IOCBs that will fit in SLI2 slim */
+#define MAX_SLI2_IOCB    498
+
+typedef struct {
+	union {
+		uint8_t sli2slim[SLI2_SLIM_SIZE];
+		struct {
+			MAILBOX_t mbx;
+			PCB_t pcb;
+			IOCB_t IOCBs[MAX_SLI2_IOCB];
+		} slim;
+	} un;
+} SLI2_SLIM_t;
+
+/*******************************************************************
+This macro check PCI device to allow special handling for LC HBAs.
+
+Parameters:
+device : struct pci_dev 's device field
+
+return 1 => TRUE
+       0 => FALSE
+ *******************************************************************/
+static inline int
+lpfc_is_LC_HBA(unsigned short device)
+{
+	if ((device == PCI_DEVICE_ID_TFLY) ||
+	    (device == PCI_DEVICE_ID_PFLY) ||
+	    (device == PCI_DEVICE_ID_LP101) || 
+	    (device == PCI_DEVICE_ID_BMID) || 
+	    (device == PCI_DEVICE_ID_ZMID) || 
+	    (device == PCI_DEVICE_ID_BSMB) || 
+	    (device == PCI_DEVICE_ID_ZSMB) || 
+	    (device == PCI_DEVICE_ID_RFLY))
+		return 1;
+	else
+		return 0;
+}
+
+#endif				/* _H_LPFC_HW */
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_init.c linux-8155/drivers/addon/lpfc/lpfc_init.c
--- linux-8152/drivers/addon/lpfc/lpfc_init.c
+++ linux-8155/drivers/addon/lpfc/lpfc_init.c
@@ -0,0 +1,1505 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_init.c 485 2006-03-28 16:18:51Z sf_support $
+ */
+
+#include <linux/version.h>
+#include <linux/spinlock.h>
+#include <linux/pci.h>
+
+
+#include <linux/blk.h>
+#include <linux/ctype.h>
+
+#include "lpfc_version.h"
+#include "lpfc_hw.h"
+#include "lpfc_sli.h"
+#include "lpfc_mem.h"
+#include "lpfc_sched.h"
+#include "lpfc_disc.h"
+#include "lpfc.h"
+#include "lpfc_logmsg.h"
+#include "lpfc_scsi.h"
+#include "lpfc_cfgparm.h"
+#include "lpfc_crtn.h"
+
+extern lpfcDRVR_t lpfcDRVR;
+
+int lpfc_parse_vpd(lpfcHBA_t *, uint8_t *);
+int lpfc_post_rcv_buf(lpfcHBA_t *);
+void lpfc_establish_link_tmo(unsigned long ptr);
+int lpfc_check_for_vpd = 1;
+int lpfc_rdrev_wd30 = 0;
+
+
+/************************************************************************/
+/*                                                                      */
+/*   lpfc_swap_bcopy                                                    */
+/*                                                                      */
+/************************************************************************/
+void
+lpfc_swap_bcopy(uint32_t * src, uint32_t * dest, uint32_t cnt)
+{
+	uint32_t ldata;
+	int i;
+
+	for (i = 0; i < (int)cnt; i += sizeof (uint32_t)) {
+		ldata = *src++;
+		ldata = cpu_to_be32(ldata);
+		*dest++ = ldata;
+	}
+}
+
+/************************************************************************/
+/*                                                                      */
+/*    lpfc_config_port_prep                                             */
+/*    This routine will do LPFC initialization prior to the             */
+/*    CONFIG_PORT mailbox command. This will be initialized             */
+/*    as a SLI layer callback routine.                                  */
+/*    This routine returns 0 on success or ERESTART if it wants         */
+/*    the SLI layer to reset the HBA and try again. Any                 */
+/*    other return value indicates an error.                            */
+/*                                                                      */
+/************************************************************************/
+int
+lpfc_config_port_prep(lpfcHBA_t * phba)
+{
+	LPFC_MBOXQ_t *pmb;
+	MAILBOX_t *mb;
+	lpfc_vpd_t *vp;
+	char licensed[56] =
+	    "key unlock for use with gnu public licensed code only\0";
+	uint32_t *pText = (uint32_t *) licensed;
+
+	vp = &phba->vpd;
+
+	/* Get a Mailbox buffer to setup mailbox commands for HBA
+	   initialization */
+	if ((pmb = lpfc_mbox_alloc(phba, MEM_PRI)) == 0) {
+		phba->hba_state = LPFC_HBA_ERROR;
+		return (ENOMEM);
+	}
+	mb = &pmb->mb;
+
+	/* special handling for LC HBAs */
+	if (lpfc_is_LC_HBA(phba->pcidev->device)) {
+		/* Setup and issue mailbox READ NVPARAMS command */
+		phba->hba_state = LPFC_INIT_MBX_CMDS;
+		lpfc_read_nv(phba, pmb);
+		memset((void *)mb->un.varRDnvp.rsvd3, 0,
+		       sizeof (mb->un.varRDnvp.rsvd3));
+		lpfc_swap_bcopy(pText, pText, 56);
+		memcpy((void *)mb->un.varRDnvp.rsvd3, licensed,
+		       sizeof (licensed));
+		if (lpfc_sli_issue_mbox(phba, pmb, MBX_POLL) != MBX_SUCCESS) {
+			/* Adapter initialization error, mbxCmd <cmd>
+			   READ_NVPARM, mbxStatus <status> */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0324,
+				       lpfc_mes0324,
+				       lpfc_msgBlk0324.msgPreambleStr,
+				       mb->mbxCommand, mb->mbxStatus);
+			return (ERESTART);
+		}
+		memcpy((uint8_t *) phba->wwnn,
+		       (uint8_t *) mb->un.varRDnvp.nodename,
+		       sizeof (mb->un.varRDnvp.nodename));
+	}
+
+	/* Setup and issue mailbox READ REV command */
+	phba->hba_state = LPFC_INIT_MBX_CMDS;
+	lpfc_read_rev(phba, pmb);
+	if (lpfc_sli_issue_mbox(phba, pmb, MBX_POLL) != MBX_SUCCESS) {
+		/* Adapter failed to init, mbxCmd <mbxCmd> READ_REV, mbxStatus
+		   <status> */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0439,
+				lpfc_mes0439,
+				lpfc_msgBlk0439.msgPreambleStr,
+				mb->mbxCommand, mb->mbxStatus);
+		lpfc_mbox_free(phba, pmb);
+		return (ERESTART);
+	}
+
+	/* The HBA's current state is provided by the ProgType and rr fields.
+	 * Read and check the value of these fields before continuing to config
+	 * this port.
+	 */
+	if (mb->un.varRdRev.rr == 0) {
+		/* Old firmware */
+		vp->rev.rBit = 0;
+		/* Adapter failed to init, mbxCmd <cmd> READ_REV detected
+		   outdated firmware */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0440,
+				lpfc_mes0440,
+				lpfc_msgBlk0440.msgPreambleStr,
+				mb->mbxCommand, 0);
+
+		lpfc_mbox_free(phba, pmb);
+		return (ERESTART);
+	} else {
+		if (mb->un.varRdRev.un.b.ProgType != 2) {
+			lpfc_mbox_free(phba, pmb);
+			return (ERESTART);
+		}
+		vp->rev.rBit = 1;
+		vp->rev.sli1FwRev = mb->un.varRdRev.sli1FwRev;
+		memcpy((uint8_t *) vp->rev.sli1FwName,
+		       (uint8_t *) mb->un.varRdRev.sli1FwName, 16);
+		vp->rev.sli2FwRev = mb->un.varRdRev.sli2FwRev;
+		memcpy((uint8_t *) vp->rev.sli2FwName,
+		       (uint8_t *) mb->un.varRdRev.sli2FwName, 16);
+	}
+
+	/* Save information as VPD data */
+	vp->rev.biuRev = mb->un.varRdRev.biuRev;
+	vp->rev.smRev = mb->un.varRdRev.smRev;
+	vp->rev.smFwRev = mb->un.varRdRev.un.smFwRev;
+	vp->rev.endecRev = mb->un.varRdRev.endecRev;
+	vp->rev.fcphHigh = mb->un.varRdRev.fcphHigh;
+	vp->rev.fcphLow = mb->un.varRdRev.fcphLow;
+	vp->rev.feaLevelHigh = mb->un.varRdRev.feaLevelHigh;
+	vp->rev.feaLevelLow = mb->un.varRdRev.feaLevelLow;
+	vp->rev.postKernRev = mb->un.varRdRev.postKernRev;
+	vp->rev.opFwRev = mb->un.varRdRev.opFwRev;
+	lpfc_rdrev_wd30 = mb->un.varWords[30];
+
+	if (lpfc_is_LC_HBA(phba->pcidev->device)) {
+		memcpy((uint8_t *) phba->RandomData,
+		       (uint8_t *) & mb->un.varWords[24],
+		       sizeof (phba->RandomData));
+	}
+
+	/* Get the default values for Model Name and Description */
+	lpfc_get_hba_model_desc(phba, phba->ModelName, phba->ModelDesc);
+
+	if (lpfc_check_for_vpd) {
+		uint32_t *lpfc_vpd_data = 0;
+		uint16_t offset = 0;
+
+		/* Get adapter VPD information */
+		lpfc_vpd_data = kmalloc(DMP_VPD_SIZE, GFP_ATOMIC);
+		pmb->context2 = kmalloc(DMP_RSP_SIZE, GFP_ATOMIC);
+
+		do {
+			lpfc_dump_mem(phba, pmb, offset);
+
+			if (lpfc_sli_issue_mbox(phba, pmb, MBX_POLL) != MBX_SUCCESS) {
+				/*
+				 * Let it go through even if failed.
+				 */
+				/* Adapter failed to init, mbxCmd <cmd> DUMP VPD,
+				   mbxStatus <status> */
+				lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0441,
+						lpfc_mes0441,
+						lpfc_msgBlk0441.msgPreambleStr,
+						mb->mbxCommand, mb->mbxStatus);
+				kfree(lpfc_vpd_data);
+				lpfc_vpd_data = 0;
+				break;
+			}
+
+			lpfc_sli_pcimem_bcopy((uint32_t *)pmb->context2,
+					      (uint32_t*)((uint8_t*)lpfc_vpd_data + offset),
+					      mb->un.varDmp.word_cnt);
+
+			offset += mb->un.varDmp.word_cnt;
+		} while (mb->un.varDmp.word_cnt);
+
+		lpfc_parse_vpd(phba, (uint8_t *)lpfc_vpd_data);
+
+		if (pmb->context2)
+			kfree(pmb->context2);
+		if (lpfc_vpd_data)
+			kfree(lpfc_vpd_data);
+		pmb->context2 = 0;
+	}
+	lpfc_mbox_free(phba, pmb);
+	return (0);
+}
+
+/************************************************************************/
+/*                                                                      */
+/*    lpfc_config_port_post                                             */
+/*    This routine will do LPFC initialization after the                */
+/*    CONFIG_PORT mailbox command. This will be initialized             */
+/*    as a SLI layer callback routine.                                  */
+/*    This routine returns 0 on success. Any other return value         */
+/*    indicates an error.                                               */
+/*                                                                      */
+/************************************************************************/
+int
+lpfc_config_port_post(lpfcHBA_t * phba)
+{
+	LPFC_MBOXQ_t *pmb;
+	MAILBOX_t *mb;
+	DMABUF_t *mp;
+	LPFC_SLI_t *psli;
+	lpfcCfgParam_t *clp;
+	uint32_t status;
+	int i, j, flogi_sent;
+	unsigned long iflag, isr_cnt, clk_cnt;
+	uint32_t timeout;
+
+	psli = &phba->sli;
+	clp = &phba->config[0];
+
+	/* Get a Mailbox buffer to setup mailbox commands for HBA
+	   initialization */
+	if ((pmb = lpfc_mbox_alloc(phba, MEM_PRI)) == 0) {
+		phba->hba_state = LPFC_HBA_ERROR;
+		return (ENOMEM);
+	}
+	mb = &pmb->mb;
+
+	/* Setup link timers */
+	lpfc_config_link(phba, pmb);
+	if (lpfc_sli_issue_mbox(phba, pmb, MBX_POLL) != MBX_SUCCESS) {
+		/* Adapter failed to init, mbxCmd <cmd> CONFIG_LINK mbxStatus
+		   <status> */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0447,
+				lpfc_mes0447,
+				lpfc_msgBlk0447.msgPreambleStr,
+				mb->mbxCommand, mb->mbxStatus);
+		phba->hba_state = LPFC_HBA_ERROR;
+		lpfc_mbox_free(phba, pmb);
+		return (EIO);
+	}
+
+	/* Get login parameters for NID.  */
+	lpfc_read_sparam(phba, pmb);
+	if (lpfc_sli_issue_mbox(phba, pmb, MBX_POLL) != MBX_SUCCESS) {
+		/* Adapter failed to init, mbxCmd <cmd> READ_SPARM mbxStatus
+		   <status> */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0448,
+				lpfc_mes0448,
+				lpfc_msgBlk0448.msgPreambleStr,
+				mb->mbxCommand, mb->mbxStatus);
+		phba->hba_state = LPFC_HBA_ERROR;
+		lpfc_mbox_free(phba, pmb);
+		return (EIO);
+	}
+
+	mp = (DMABUF_t *) pmb->context1;
+
+	memcpy((uint8_t *) & phba->fc_sparam, (uint8_t *) mp->virt,
+	       sizeof (SERV_PARM));
+	lpfc_mbuf_free(phba, mp->virt, mp->phys);
+	kfree(mp);
+	pmb->context1 = 0;
+
+	memcpy((uint8_t *) & phba->fc_nodename,
+	       (uint8_t *) & phba->fc_sparam.nodeName, sizeof (NAME_TYPE));
+	memcpy((uint8_t *) & phba->fc_portname,
+	       (uint8_t *) & phba->fc_sparam.portName, sizeof (NAME_TYPE));
+	memcpy(phba->phys_addr, phba->fc_portname.IEEE, 6);
+	/* If no serial number in VPD data, use low 6 bytes of WWNN */
+	if (phba->SerialNumber[0] == 0) {
+		uint8_t *outptr;
+
+		outptr = (uint8_t *) & phba->fc_nodename.IEEE[0];
+		for (i = 0; i < 12; i++) {
+			status = *outptr++;
+			j = ((status & 0xf0) >> 4);
+			if (j <= 9)
+				phba->SerialNumber[i] =
+				    (char)((uint8_t) 0x30 + (uint8_t) j);
+			else
+				phba->SerialNumber[i] =
+				    (char)((uint8_t) 0x61 + (uint8_t) (j - 10));
+			i++;
+			j = (status & 0xf);
+			if (j <= 9)
+				phba->SerialNumber[i] =
+				    (char)((uint8_t) 0x30 + (uint8_t) j);
+			else
+				phba->SerialNumber[i] =
+				    (char)((uint8_t) 0x61 + (uint8_t) (j - 10));
+		}
+	}
+
+	/* This should turn on DELAYED ABTS for ELS timeouts */
+	lpfc_set_slim(phba, pmb, 0x052198, 0x1);
+	if (lpfc_sli_issue_mbox(phba, pmb, MBX_POLL) != MBX_SUCCESS) {
+		phba->hba_state = LPFC_HBA_ERROR;
+		lpfc_mbox_free(phba, pmb);
+		return (EIO);
+	}
+
+
+	lpfc_read_config(phba, pmb);
+	if (lpfc_sli_issue_mbox(phba, pmb, MBX_POLL) != MBX_SUCCESS) {
+		/* Adapter failed to init, mbxCmd <cmd> READ_CONFIG, mbxStatus
+		   <status> */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0453,
+			       lpfc_mes0453,
+			       lpfc_msgBlk0453.msgPreambleStr,
+			       mb->mbxCommand, mb->mbxStatus);
+		phba->hba_state = LPFC_HBA_ERROR;
+		lpfc_mbox_free(phba, pmb);
+		return (EIO);
+	}
+
+	if (clp[LPFC_CFG_DFT_HBA_Q_DEPTH].a_current > (mb->un.varRdConfig.max_xri+1)) {
+		/* Reset the DFT_HBA_Q_DEPTH to the max xri  */
+		clp[LPFC_CFG_DFT_HBA_Q_DEPTH].a_current = mb->un.varRdConfig.max_xri + 1;
+	}
+	phba->lmt = mb->un.varRdConfig.lmt;
+
+	/* HBA is not 4GB capable, or HBA is not 2GB capable, 
+	don't let link speed ask for it */
+	if ((((phba->lmt & LMT_4250_10bit) != LMT_4250_10bit) &&
+		(clp[LPFC_CFG_LINK_SPEED].a_current > LINK_SPEED_2G)) || 
+		(((phba->lmt & LMT_2125_10bit) != LMT_2125_10bit) &&
+		 (clp[LPFC_CFG_LINK_SPEED].a_current > LINK_SPEED_1G))) {
+			/* Reset link speed to auto. 1G/2GB HBA cfg'd for 4G */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk1302,
+					lpfc_mes1302,
+					lpfc_msgBlk1302.msgPreambleStr,
+					clp[LPFC_CFG_LINK_SPEED].a_current);
+			clp[LPFC_CFG_LINK_SPEED].a_current = LINK_SPEED_AUTO;
+	}
+	
+	if (phba->intr_inited != 1) {
+		/* Add our interrupt routine to kernel's interrupt chain &
+		   enable it */
+
+		if (request_irq(phba->pcidev->irq,
+				lpfc_intr_handler,
+				SA_SHIRQ,
+				LPFC_DRIVER_NAME,
+				phba) != 0) {
+			/* Enable interrupt handler failed */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0451,
+					lpfc_mes0451,
+					lpfc_msgBlk0451.msgPreambleStr);
+			phba->hba_state = LPFC_HBA_ERROR;
+			lpfc_mbox_free(phba, pmb);
+			return (EIO);
+		}
+		phba->intr_inited = 1;
+	}
+
+	phba->hba_state = LPFC_LINK_DOWN;
+	phba->fc_flag |= FC_LNK_DOWN;
+
+	/* Only process IOCBs on ring 0 till hba_state is READY */
+	if (psli->ring[psli->ip_ring].cmdringaddr)
+		psli->ring[psli->ip_ring].flag |= LPFC_STOP_IOCB_EVENT;
+	if (psli->ring[psli->fcp_ring].cmdringaddr)
+		psli->ring[psli->fcp_ring].flag |= LPFC_STOP_IOCB_EVENT;
+	if (psli->ring[psli->next_ring].cmdringaddr)
+		psli->ring[psli->next_ring].flag |= LPFC_STOP_IOCB_EVENT;
+
+	/* Post receive buffers for desired rings */
+	lpfc_post_rcv_buf(phba);
+
+	/* Enable appropriate host interrupts */
+	status = readl(phba->HCregaddr);
+	status |= (uint32_t) (HC_MBINT_ENA | HC_ERINT_ENA | HC_LAINT_ENA);
+	if (psli->sliinit.num_rings > 0)
+		status |= HC_R0INT_ENA;
+	if (psli->sliinit.num_rings > 1)
+		status |= HC_R1INT_ENA;
+	if (psli->sliinit.num_rings > 2)
+		status |= HC_R2INT_ENA;
+	if (psli->sliinit.num_rings > 3)
+		status |= HC_R3INT_ENA;
+
+	writel(status, phba->HCregaddr);
+	readl(phba->HCregaddr); /* flush */
+
+	/* Setup and issue mailbox INITIALIZE LINK command */
+	lpfc_init_link(phba, pmb, clp[LPFC_CFG_TOPOLOGY].a_current,
+		       clp[LPFC_CFG_LINK_SPEED].a_current);
+
+	isr_cnt = psli->slistat.sliIntr;
+	clk_cnt = jiffies;
+
+	if (lpfc_sli_issue_mbox(phba, pmb, MBX_NOWAIT) != MBX_SUCCESS) {
+		/* Adapter failed to init, mbxCmd <cmd> INIT_LINK, mbxStatus
+		   <status> */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0454,
+				lpfc_mes0454,
+				lpfc_msgBlk0454.msgPreambleStr,
+				mb->mbxCommand, mb->mbxStatus);
+
+		/* Clear all interrupt enable conditions */
+		writel(0, phba->HCregaddr);
+		readl(phba->HCregaddr); /* flush */
+		/* Clear all pending interrupts */
+		writel(0xffffffff, phba->HAregaddr);
+		readl(phba->HAregaddr); /* flush */
+
+		free_irq(phba->pcidev->irq, phba);
+		phba->intr_inited = 0;
+		phba->hba_state = LPFC_HBA_ERROR;
+		lpfc_mbox_free(phba, pmb);
+		return (EIO);
+	}
+	/* MBOX buffer will be freed in mbox compl */
+
+	/*
+	 * Setup the ring 0 (els)  timeout handler
+	 */
+	timeout = phba->fc_ratov << 1;
+	lpfc_start_timer(phba, timeout, &phba->els_tmofunc, 
+		lpfc_els_timeout_handler, 
+		(unsigned long)timeout, (unsigned long)0);
+
+	phba->fc_prevDID = Mask_DID;
+	flogi_sent = 0;
+	i = 0;
+	while ((phba->hba_state != LPFC_HBA_READY) ||
+	       (phba->num_disc_nodes) || (phba->fc_prli_sent) ||
+	       ((phba->fc_map_cnt == 0) && (i<2)) ||
+	       (psli->sliinit.sli_flag & LPFC_SLI_MBOX_ACTIVE)) {
+		/* Check every second for 45 retries. */
+		i++;
+		if (i > 45) {
+			break;
+		}
+		if ((i >= 15) && (phba->hba_state <= LPFC_LINK_DOWN)) {
+			/* The link is down.  Set linkdown timeout */
+
+			if ((clp[LPFC_CFG_LINKDOWN_TMO].a_current == 0) ||
+			    clp[LPFC_CFG_HOLDIO].a_current) {
+				phba->fc_flag |= (FC_LD_TIMER | FC_LD_TIMEOUT);
+				phba->hba_flag |= FC_LFR_ACTIVE;
+			} else {
+				phba->fc_flag |= FC_LD_TIMER;
+				phba->hba_flag |= FC_LFR_ACTIVE;
+				if (phba->fc_linkdown.function) {
+					unsigned long new_tmo;
+					new_tmo = jiffies + HZ *
+						(clp[LPFC_CFG_LINKDOWN_TMO]
+						 .a_current);
+					mod_timer(&phba->fc_linkdown, new_tmo);
+				} else {
+					if (clp[LPFC_CFG_HOLDIO].a_current
+					    == 0) {
+						lpfc_start_timer(phba,
+						 clp[LPFC_CFG_LINKDOWN_TMO]
+								 .a_current,
+						 &phba->fc_linkdown,
+						 lpfc_linkdown_timeout, 0, 0);
+					}
+				}
+			}
+			break;
+		}
+
+		/* 20 * 50ms is identically 1sec */
+		for (j = 0; j < 20; j++) {
+			lpfc_sleep_ms(phba, 50);
+			/* On some systems hardware interrupts cannot interrupt
+			 * the attach / detect routine. If this is the case,
+			 * manually call the ISR every 50 ms to service any
+			 * potential interrupt.
+			 */
+			LPFC_DRVR_LOCK(phba, iflag);
+			if (isr_cnt == psli->slistat.sliIntr) {
+				lpfc_sli_intr(phba);
+				isr_cnt = psli->slistat.sliIntr;
+			}
+			LPFC_DRVR_UNLOCK(phba, iflag);
+		}
+		isr_cnt = psli->slistat.sliIntr;
+
+		/* On some systems clock interrupts cannot interrupt the attach
+		 * / detect routine. If this is the case, manually call the
+		 * clock routine every sec to service any potential timeouts.
+		 */
+		if (clk_cnt == jiffies) {
+			/* REMOVE: IF THIS HAPPENS, SYSTEM CLOCK IS NOT RUNNING.
+			 * WE HAVE TO MANUALLY CALL OUR TIMEOUT ROUTINES.
+			 */
+			clk_cnt = jiffies;
+		}
+	}
+
+	/* Since num_disc_nodes keys off of PLOGI, delay a bit to let
+	 * any potential PRLIs to flush thru the SLI sub-system.
+	 */
+	lpfc_sleep_ms(phba, 50);
+	LPFC_DRVR_LOCK(phba, iflag);
+	if (isr_cnt == psli->slistat.sliIntr) {
+		lpfc_sli_intr(phba);
+	}
+
+	LPFC_DRVR_UNLOCK(phba, iflag);
+
+	return (0);
+}
+
+/************************************************************************/
+/*                                                                      */
+/*    lpfc_hba_down_prep                                                */
+/*    This routine will do LPFC uninitialization before the             */
+/*    HBA is reset when bringing down the SLI Layer. This will be       */
+/*    initialized as a SLI layer callback routine.                      */
+/*    This routine returns 0 on success. Any other return value         */
+/*    indicates an error.                                               */
+/*                                                                      */
+/************************************************************************/
+int
+lpfc_hba_down_prep(lpfcHBA_t * phba)
+{
+	LPFC_SLI_t *psli;
+
+	psli = &phba->sli;
+	/* Disable interrupts */
+	writel(0, phba->HCregaddr);
+	readl(phba->HCregaddr); /* flush */
+
+	lpfc_flush_disc_evtq(phba);
+	lpfc_els_flush_rscn(phba);
+
+	return (0);
+}
+
+/************************************************************************/
+/*                                                                      */
+/*    lpfc_handle_eratt                                                 */
+/*    This routine will handle processing a Host Attention              */
+/*    Error Status event. This will be initialized                      */
+/*    as a SLI layer callback routine.                                  */
+/*                                                                      */
+/************************************************************************/
+void
+lpfc_handle_eratt(lpfcHBA_t * phba, uint32_t status)
+{
+	LPFC_SLI_t *psli;
+	LPFC_SLI_RING_t  * pring;
+	LPFC_IOCBQ_t     * iocb, * next_iocb;
+	IOCB_t          * icmd = NULL, * cmd = NULL;
+	LPFC_SCSI_BUF_t  * lpfc_cmd;
+	volatile uint32_t status1, status2;
+	struct list_head *curr, *next;
+	void *from_slim;
+
+	psli = &phba->sli;
+	from_slim = ((uint8_t *)phba->MBslimaddr + 0xa8);
+	status1 = readl( from_slim);
+	from_slim =  ((uint8_t *)phba->MBslimaddr + 0xac);
+	status2 = readl( from_slim);
+
+	if (status & HS_FFER6) {
+		/* Re-establishing Link */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk1301,
+			       lpfc_mes1301,
+			       lpfc_msgBlk1301.msgPreambleStr,
+			       status, status1, status2);
+		phba->fc_flag |= FC_ESTABLISH_LINK;
+
+		/* 
+		* Firmware stops when it triggled erratt with HS_FFER6.
+		* That could cause the I/Os dropped by the firmware.
+		* Error iocb (I/O) on txcmplq and let the SCSI layer 
+		* retry it after re-establishing link. 
+		*/
+		pring = &psli->ring[psli->fcp_ring];
+
+		list_for_each_safe(curr, next, &pring->txcmplq) {
+			next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+			iocb = next_iocb;
+			cmd = &iocb->iocb;
+
+			/* Must be a FCP command */
+			if((cmd->ulpCommand != CMD_FCP_ICMND64_CR) &&
+				(cmd->ulpCommand != CMD_FCP_IWRITE64_CR) &&
+				(cmd->ulpCommand != CMD_FCP_IREAD64_CR)) {
+				continue;
+				}
+
+			/* context1 MUST be a LPFC_SCSI_BUF_t */
+			lpfc_cmd = (LPFC_SCSI_BUF_t *)(iocb->context1);
+			if(lpfc_cmd == 0) {
+				continue;
+			}
+
+			list_del(&iocb->list);
+			pring->txcmplq_cnt--;
+
+			if(iocb->iocb_cmpl) {
+				icmd = &iocb->iocb;
+				icmd->ulpStatus = IOSTAT_LOCAL_REJECT;
+				icmd->un.ulpWord[4] = IOERR_SLI_ABORTED;
+				(iocb->iocb_cmpl)(phba, iocb, iocb);
+			} else {
+				lpfc_iocb_free(phba, iocb);
+			}
+		}
+
+		lpfc_offline(phba);
+		if (lpfc_online(phba) == 0) {	/* Initialize the HBA */
+			if (phba->fc_estabtmo.function) {
+				lpfc_stop_timer((struct clk_data *)
+						phba->fc_estabtmo.data);
+			}
+			lpfc_start_timer(phba, 60, &phba->fc_estabtmo,
+					 lpfc_establish_link_tmo, 0, 0);
+			return;
+		}
+	}
+	/* Adapter Hardware Error */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0457,
+			lpfc_mes0457,
+			lpfc_msgBlk0457.msgPreambleStr,
+			status, status1, status2);
+
+	lpfc_offline(phba);
+	lpfc_unblock_requests(phba);
+	return;
+}
+
+/************************************************************************/
+/*                                                                      */
+/*    lpfc_handle_latt                                                  */
+/*    This routine will handle processing a Host Attention              */
+/*    Link Status event. This will be initialized                       */
+/*    as a SLI layer callback routine.                                  */
+/*                                                                      */
+/************************************************************************/
+void
+lpfc_handle_latt(lpfcHBA_t * phba)
+{
+	LPFC_SLI_t *psli;
+	LPFC_MBOXQ_t *pmb;
+	volatile uint32_t control;
+
+	/* called from host_interrupt, to process LATT */
+	psli = &phba->sli;
+
+	psli->slistat.linkEvent++;
+
+	/* Get a buffer which will be used for mailbox commands */
+	if ((pmb = (LPFC_MBOXQ_t *) lpfc_mbox_alloc(phba, MEM_PRI))) {
+		if (lpfc_read_la(phba, pmb) == 0) {
+			pmb->mbox_cmpl = lpfc_mbx_cmpl_read_la;
+			if (lpfc_sli_issue_mbox
+			    (phba, pmb, (MBX_NOWAIT | MBX_STOP_IOCB))
+			    != MBX_NOT_FINISHED) {
+				/* Turn off Link Attention interrupts until
+				   CLEAR_LA done */
+				psli->sliinit.sli_flag &= ~LPFC_PROCESS_LA;
+				control = readl(phba->HCregaddr);
+				control &= ~HC_LAINT_ENA;
+				writel(control, phba->HCregaddr);
+				readl(phba->HCregaddr); /* flush */
+
+				/* Clear Link Attention in HA REG */
+				writel(HA_LATT, phba->HAregaddr);
+				readl(phba->HAregaddr); /* flush */
+				return;
+			} else {
+				lpfc_mbox_free(phba, pmb);
+			}
+		} else {
+			lpfc_mbox_free(phba, pmb);
+		}
+	}
+
+	/* Clear Link Attention in HA REG */
+	writel(HA_LATT, phba->HAregaddr);
+	readl(phba->HAregaddr); /* flush */
+	lpfc_linkdown(phba);
+	phba->hba_state = LPFC_HBA_ERROR;
+	return;
+}
+
+/************************************************************************/
+/*                                                                      */
+/*   lpfc_parse_vpd                                                     */
+/*   This routine will parse the VPD data                               */
+/*                                                                      */
+/************************************************************************/
+int
+lpfc_parse_vpd(lpfcHBA_t * phba, uint8_t * vpd)
+{
+	uint8_t lenlo, lenhi;
+	uint32_t Length;
+	int i, j;
+	int finished = 0;
+	int index = 0;
+
+	if (!vpd)
+		return (0);
+
+	/* Vital Product */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0455,
+			lpfc_mes0455,
+			lpfc_msgBlk0455.msgPreambleStr,
+			(uint32_t) vpd[0], (uint32_t) vpd[1], (uint32_t) vpd[2],
+			(uint32_t) vpd[3]);
+	do {
+		switch (vpd[index]) {
+		case 0x82:
+			index += 1;
+			lenlo = vpd[index];
+			index += 1;
+			lenhi = vpd[index];
+			index += 1;
+			i = ((((unsigned short)lenhi) << 8) + lenlo);
+			index += i;
+			break;
+		case 0x90:
+			index += 1;
+			lenlo = vpd[index];
+			index += 1;
+			lenhi = vpd[index];
+			index += 1;
+			Length = ((((unsigned short)lenhi) << 8) + lenlo);
+
+			while (Length > 0) {
+			/* Look for Serial Number */
+			if ((vpd[index] == 'S') && (vpd[index+1] == 'N')) {
+				index += 2;
+				i = vpd[index];
+				index += 1;
+				j = 0;
+				Length -= (3+i);
+				while(i--) {
+					phba->SerialNumber[j++] = vpd[index++];
+					if(j == 31)
+						break;
+				}
+				phba->SerialNumber[j] = 0;
+				continue;
+			}
+			else if ((vpd[index] == 'V') && (vpd[index+1] == '1')) {
+				phba->vpd_flag |= VPD_MODEL_DESC;
+				index += 2;
+				i = vpd[index];
+				index += 1;
+				j = 0;
+				Length -= (3+i);
+				while(i--) {
+					phba->ModelDesc[j++] = vpd[index++];
+					if(j == 255)
+						break;
+				}
+				phba->ModelDesc[j] = 0;
+				continue;
+			}
+			else if ((vpd[index] == 'V') && (vpd[index+1] == '2')) {
+				phba->vpd_flag |= VPD_MODEL_NAME;
+				index += 2;
+				i = vpd[index];
+				index += 1;
+				j = 0;
+				Length -= (3+i);
+				while(i--) {
+					phba->ModelName[j++] = vpd[index++];
+					if(j == 79)
+						break;
+				}
+				phba->ModelName[j] = 0;
+				continue;
+			}
+			else if ((vpd[index] == 'V') && (vpd[index+1] == '3')) {
+				phba->vpd_flag |= VPD_PROGRAM_TYPE;
+				index += 2;
+				i = vpd[index];
+				index += 1;
+				j = 0;
+				Length -= (3+i);
+				while(i--) {
+					phba->ProgramType[j++] = vpd[index++];
+					if(j == 255)
+						break;
+				}
+				phba->ProgramType[j] = 0;
+				continue;
+			}
+			else if ((vpd[index] == 'V') && (vpd[index+1] == '4')) {
+				phba->vpd_flag |= VPD_PORT;
+				index += 2;
+				i = vpd[index];
+				index += 1;
+				j = 0;
+				Length -= (3+i);
+				while(i--) {
+				phba->Port[j++] = vpd[index++];
+				if(j == 19)
+					break;
+				}
+				phba->Port[j] = 0;
+				continue;
+			}
+			else {
+				index += 2;
+				i = vpd[index];
+				index += 1;
+				index += i;
+				Length -= (3 + i);
+			}
+			}
+			finished = 0;
+			break;
+		case 0x78:
+			finished = 1;
+			break;
+		default:
+			index++;
+			break;
+		}
+	} while (!finished && (index < 108));
+
+	return (1);
+}
+
+/**************************************************/
+/*   lpfc_post_buffer                             */
+/*                                                */
+/*   This routine will post count buffers to the  */
+/*   ring with the QUE_RING_BUF_CN command. This  */
+/*   allows 3 buffers / command to be posted.     */
+/*   Returns the number of buffers NOT posted.    */
+/**************************************************/
+int
+lpfc_post_buffer(lpfcHBA_t * phba, LPFC_SLI_RING_t * pring, int cnt, int type)
+{
+	IOCB_t *icmd;
+	LPFC_IOCBQ_t *iocb;
+	DMABUF_t *mp1, *mp2;
+
+	cnt += pring->missbufcnt;
+
+	/* While there are buffers to post */
+	while (cnt > 0) {
+		/* Allocate buffer for  command iocb */
+		if ((iocb = lpfc_iocb_alloc(phba, MEM_PRI)) == 0) {
+			pring->missbufcnt = cnt;
+			return (cnt);
+		}
+		memset(iocb, 0, sizeof (LPFC_IOCBQ_t));
+		icmd = &iocb->iocb;
+
+		/* 2 buffers can be posted per command */
+		/* Allocate buffer to post */
+		if (((mp1 = kmalloc(sizeof (DMABUF_t), GFP_ATOMIC)) == 0) ||
+		    ((mp1->virt = lpfc_mbuf_alloc(phba,
+						  MEM_PRI,
+						  &(mp1->phys))) == 0)) {
+			if (mp1)
+				kfree(mp1);
+
+			lpfc_iocb_free(phba, iocb);
+			pring->missbufcnt = cnt;
+			return (cnt);
+		}
+	
+		INIT_LIST_HEAD(&mp1->list);
+		/* Allocate buffer to post */
+		if (cnt > 1) {
+			if (((mp2 =
+			      kmalloc(sizeof (DMABUF_t), GFP_ATOMIC)) == 0)
+			    ||
+			    ((mp2->virt =
+			      lpfc_mbuf_alloc(phba, MEM_PRI,
+					      &(mp2->phys))) == 0)) {
+				if (mp2)
+					kfree(mp2);
+				lpfc_mbuf_free(phba, mp1->virt, mp1->phys);
+				kfree(mp1);
+				lpfc_iocb_free(phba, iocb);
+				pring->missbufcnt = cnt;
+				return (cnt);
+			}
+
+			INIT_LIST_HEAD(&mp2->list);
+		} else {
+			mp2 = 0;
+		}
+
+		icmd->un.cont64[0].addrHigh = putPaddrHigh(mp1->phys);
+		icmd->un.cont64[0].addrLow = putPaddrLow(mp1->phys);
+		icmd->un.cont64[0].tus.f.bdeSize = FCELSSIZE;
+		icmd->ulpBdeCount = 1;
+		cnt--;
+		if (mp2) {
+			icmd->un.cont64[1].addrHigh = putPaddrHigh(mp2->phys);
+			icmd->un.cont64[1].addrLow = putPaddrLow(mp2->phys);
+			icmd->un.cont64[1].tus.f.bdeSize = FCELSSIZE;
+			cnt--;
+			icmd->ulpBdeCount = 2;
+		}
+
+		icmd->ulpCommand = CMD_QUE_RING_BUF64_CN;
+		icmd->ulpIoTag = lpfc_sli_next_iotag(phba, pring);
+		icmd->ulpLe = 1;
+
+		if (lpfc_sli_issue_iocb(phba, pring, iocb, SLI_IOCB_USE_TXQ) ==
+		    IOCB_ERROR) {
+			lpfc_mbuf_free(phba, mp1->virt, mp1->phys);
+			kfree(mp1);
+			if (mp2) {
+				lpfc_mbuf_free(phba, mp2->virt, mp2->phys);
+				kfree(mp2);
+			}
+			lpfc_iocb_free(phba, iocb);
+			pring->missbufcnt = cnt;
+			return (cnt);
+		}
+		lpfc_sli_ringpostbuf_put(phba, pring, mp1);
+		if (mp2) {
+			lpfc_sli_ringpostbuf_put(phba, pring, mp2);
+		}
+	}
+	pring->missbufcnt = 0;
+	return (0);
+}
+
+/************************************************************************/
+/*                                                                      */
+/*   lpfc_post_rcv_buf                                                  */
+/*   This routine post initial rcv buffers to the configured rings      */
+/*                                                                      */
+/************************************************************************/
+int
+lpfc_post_rcv_buf(lpfcHBA_t * phba)
+{
+	LPFC_SLI_t *psli;
+	lpfcCfgParam_t *clp;
+
+	psli = &phba->sli;
+	clp = &phba->config[0];
+
+	/* Ring 0, ELS / CT buffers */
+	lpfc_post_buffer(phba, &psli->ring[LPFC_ELS_RING], LPFC_BUF_RING0, 1);
+
+
+	/* Ring 2 - FCP no buffers needed */
+
+	return (0);
+}
+
+#define S(N,V) (((V)<<(N))|((V)>>(32-(N))))
+
+/************************************************************************/
+/*                                                                      */
+/*   lpfc_sha_init                                                      */
+/*                                                                      */
+/************************************************************************/
+void
+lpfc_sha_init(uint32_t * HashResultPointer)
+{
+	HashResultPointer[0] = 0x67452301;
+	HashResultPointer[1] = 0xEFCDAB89;
+	HashResultPointer[2] = 0x98BADCFE;
+	HashResultPointer[3] = 0x10325476;
+	HashResultPointer[4] = 0xC3D2E1F0;
+}
+
+/************************************************************************/
+/*                                                                      */
+/*   lpfc_sha_iterate                                                   */
+/*                                                                      */
+/************************************************************************/
+void
+lpfc_sha_iterate(uint32_t * HashResultPointer, uint32_t * HashWorkingPointer)
+{
+	int t;
+	uint32_t TEMP;
+	uint32_t A, B, C, D, E;
+	t = 16;
+	do {
+		HashWorkingPointer[t] =
+		    S(1,
+		      HashWorkingPointer[t - 3] ^ HashWorkingPointer[t -
+								     8] ^
+		      HashWorkingPointer[t - 14] ^ HashWorkingPointer[t - 16]);
+	} while (++t <= 79);
+	t = 0;
+	A = HashResultPointer[0];
+	B = HashResultPointer[1];
+	C = HashResultPointer[2];
+	D = HashResultPointer[3];
+	E = HashResultPointer[4];
+
+	do {
+		if (t < 20) {
+			TEMP = ((B & C) | ((~B) & D)) + 0x5A827999;
+		} else if (t < 40) {
+			TEMP = (B ^ C ^ D) + 0x6ED9EBA1;
+		} else if (t < 60) {
+			TEMP = ((B & C) | (B & D) | (C & D)) + 0x8F1BBCDC;
+		} else {
+			TEMP = (B ^ C ^ D) + 0xCA62C1D6;
+		}
+		TEMP += S(5, A) + E + HashWorkingPointer[t];
+		E = D;
+		D = C;
+		C = S(30, B);
+		B = A;
+		A = TEMP;
+	} while (++t <= 79);
+
+	HashResultPointer[0] += A;
+	HashResultPointer[1] += B;
+	HashResultPointer[2] += C;
+	HashResultPointer[3] += D;
+	HashResultPointer[4] += E;
+
+}
+
+/************************************************************************/
+/*                                                                      */
+/*   lpfc_challenge_key                                                 */
+/*                                                                      */
+/************************************************************************/
+void
+lpfc_challenge_key(uint32_t * RandomChallenge, uint32_t * HashWorking)
+{
+	*HashWorking = (*RandomChallenge ^ *HashWorking);
+}
+
+/************************************************************************/
+/*                                                                      */
+/*   lpfc_hba_init                                                      */
+/*                                                                      */
+/************************************************************************/
+void
+lpfc_hba_init(lpfcHBA_t * phba)
+{
+	int t;
+	uint32_t HashWorking[80];
+	uint32_t *pwwnn;
+
+	pwwnn = phba->wwnn;
+	memset(HashWorking, 0, sizeof (HashWorking));
+	HashWorking[0] = HashWorking[78] = *pwwnn++;
+	HashWorking[1] = HashWorking[79] = *pwwnn;
+	for (t = 0; t < 7; t++) {
+		lpfc_challenge_key(phba->RandomData + t, HashWorking + t);
+	}
+	lpfc_sha_init(phba->hbainitEx);
+	lpfc_sha_iterate(phba->hbainitEx, HashWorking);
+}
+
+void
+lpfc_cleanup(lpfcHBA_t * phba, uint32_t save_bind)
+{
+	LPFC_NODELIST_t *ndlp;
+	LPFC_BINDLIST_t *bdlp;
+	struct list_head *pos, *next;
+
+	/* clean up phba - lpfc specific */
+	lpfc_can_disctmo(phba);
+	list_for_each_safe(pos, next, &phba->fc_nlpunmap_list) {
+		ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+		lpfc_nlp_remove(phba, ndlp);
+	}
+
+	list_for_each_safe(pos, next, &phba->fc_nlpmap_list) {
+		ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+		lpfc_nlp_remove(phba, ndlp);
+	}
+
+	list_for_each_safe(pos, next, &phba->fc_plogi_list) {
+		ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+		lpfc_nlp_remove(phba, ndlp);
+	}
+
+	list_for_each_safe(pos, next, &phba->fc_adisc_list) {
+		ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+		lpfc_nlp_remove(phba, ndlp);
+	}
+
+	if (save_bind == 0) {
+		list_for_each_safe(pos, next, &phba->fc_nlpbind_list) {
+			bdlp = list_entry(pos, LPFC_BINDLIST_t, nlp_listp);
+			list_del(pos);
+			lpfc_bind_free(phba, bdlp);
+		}
+
+		phba->fc_bind_cnt = 0;
+	}
+
+	INIT_LIST_HEAD(&phba->fc_nlpmap_list);
+	INIT_LIST_HEAD(&phba->fc_nlpunmap_list);
+	INIT_LIST_HEAD(&phba->fc_plogi_list);
+	INIT_LIST_HEAD(&phba->fc_adisc_list);
+	
+	phba->fc_map_cnt   = 0;
+	phba->fc_unmap_cnt = 0;
+	phba->fc_plogi_cnt = 0;
+	phba->fc_adisc_cnt = 0;
+	return;
+}
+
+void
+lpfc_establish_link_tmo(unsigned long ptr)
+{
+	lpfcHBA_t     *phba;
+	struct clk_data *clkData;
+	unsigned long iflag;
+
+	clkData = (struct clk_data *)ptr;
+	phba = clkData->phba;
+	LPFC_DRVR_LOCK(phba, iflag);
+        	if (clkData->flags & TM_CANCELED) {
+		list_del((struct list_head *)clkData);
+		kfree(clkData);	
+		goto out;
+	}
+
+	clkData->timeObj->function = 0;
+	list_del((struct list_head *)clkData);
+	kfree(clkData);
+
+	/* Re-establishing Link, timer expired */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk1300,
+		       lpfc_mes1300,
+		       lpfc_msgBlk1300.msgPreambleStr,
+		       phba->fc_flag, phba->hba_state);
+	phba->fc_flag &= ~FC_ESTABLISH_LINK;
+out:
+	LPFC_DRVR_UNLOCK(phba, iflag);
+}
+
+int
+lpfc_online(lpfcHBA_t * phba)
+{
+	uint32_t timeout;
+
+	if (phba) {
+		if (!(phba->fc_flag & FC_OFFLINE_MODE)) {
+			return (0);
+		}
+		phba->reset_pending = 1;
+		phba->no_timer = 0;
+
+		/* Bring Adapter online */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0458,
+			       lpfc_mes0458,
+			       lpfc_msgBlk0458.msgPreambleStr);
+
+		if (!lpfc_sli_queue_setup(phba)) {
+			phba->reset_pending = 0;
+			return (1);
+		}
+		if (lpfc_sli_hba_setup(phba)) {	/* Initialize the HBA */
+			phba->reset_pending = 0;
+			return (1);
+		}
+
+   		phba->fc_flag &= ~FC_OFFLINE_MODE;
+		
+		timeout = (phba->fc_ratov << 1) > 5 ? (phba->fc_ratov << 1) : 5;
+		lpfc_start_timer(phba, timeout, &phba->scsi_tmofunc, 
+			lpfc_scsi_timeout_handler, (unsigned long)timeout, 
+			(unsigned long)0);
+
+		
+		phba->reset_pending = 0;
+		lpfc_unblock_requests(phba);
+	}
+	return (0);
+}
+
+int
+lpfc_offline(lpfcHBA_t * phba)
+{
+	LPFC_SLI_RING_t *pring;
+	LPFC_SLI_t *psli;
+	LPFC_SCSI_BUF_t *lpfc_cmd;
+	unsigned long iflag;
+	int i;
+	struct clk_data *clkData;
+	struct list_head *curr, *next;
+	struct lpfc_dmabuf *cur_buf;
+	struct timer_list *ptimer;
+	LPFCSCSITARGET_t *targetp;
+
+	if (phba) {
+		if (phba->fc_flag & FC_OFFLINE_MODE) {
+			return (0);
+		}
+
+		phba->reset_pending = 1;
+		psli = &phba->sli;
+		pring = &psli->ring[psli->fcp_ring];
+
+		lpfc_block_requests(phba);
+
+		lpfc_linkdown(phba);
+
+		phba->no_timer = 1;
+		list_for_each_safe(curr, next, &phba->timerList) {
+			clkData = list_entry(curr, struct clk_data, listLink);
+			if (clkData) {
+				ptimer = clkData->timeObj;
+				if (timer_pending(ptimer)) {
+					lpfc_stop_timer(clkData);	
+				}
+			}
+		}
+
+        	for (i = 0; i < MAX_FCP_TARGET; i++) {
+                	targetp = phba->device_queue_hash[i];
+                	if (targetp) {
+                        	targetp->targetFlags &= ~FC_NPR_ACTIVE;
+                        	targetp->tmofunc.function = 0;
+                                                                                
+                        	if(targetp->pcontext)
+                                	lpfc_disc_state_machine(phba, 
+					targetp->pcontext, 
+					0, NLP_EVT_DEVICE_RM);
+                                                                                
+                        	lpfc_sched_flush_target(phba, 
+					targetp, IOSTAT_LOCAL_REJECT,
+                                	IOERR_SLI_ABORTED);
+                	}
+        	}
+
+		/* If lpfc_offline is called from the interrupt, there is a
+           	   FW trap . Do not expect iocb completions here */
+		if (!in_interrupt()) {
+			i = 0;
+			while (pring->txcmplq_cnt) {
+				LPFC_DRVR_UNLOCK(phba, iflag);
+				mdelay(10);
+				LPFC_DRVR_LOCK(phba, iflag);
+				if (i++ > 3000)	/* 30 secs */
+					break;
+			}
+		}
+
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		while (!list_empty(&phba->timerList)) {
+		}
+		LPFC_DRVR_LOCK(phba, iflag);
+
+		/* Bring Adapter offline */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0460,
+			       lpfc_mes0460,
+			       lpfc_msgBlk0460.msgPreambleStr);
+
+		lpfc_sli_hba_down(phba);	/* Bring down the SLI Layer */
+
+		phba->fc_flag |= FC_OFFLINE_MODE;
+ 
+		lpfc_cleanup(phba, 1);	/* Save bindings */
+
+		while(!list_empty(&phba->delay_list)) {
+			lpfc_cmd = list_entry(phba->delay_list.next, LPFC_SCSI_BUF_t, listentry);
+			list_del(&lpfc_cmd->listentry);
+			lpfc_iodone(phba, lpfc_cmd);
+		}
+
+		while(!list_empty(&phba->free_buf_list)) {
+			cur_buf = list_entry(phba->free_buf_list.next, DMABUF_t, list);
+			list_del(&cur_buf->list);
+			lpfc_mbuf_free(phba, cur_buf->virt, cur_buf->phys);
+			kfree((void *)cur_buf);
+		}
+
+		phba->reset_pending = 0;
+	}
+	return (0);
+}
+
+/******************************************************************************
+* Function name : lpfc_scsi_free
+*
+* Description   : Called from fc_detach to free scsi tgt / lun resources
+* 
+******************************************************************************/
+int
+lpfc_scsi_free(lpfcHBA_t * phba)
+{
+	LPFCSCSITARGET_t *targetp;
+	LPFCSCSILUN_t *lunp;
+	int i;
+	struct list_head *curr, *next;
+
+	for (i = 0; i < MAX_FCP_TARGET; i++) {
+		targetp = phba->device_queue_hash[i];
+		if (targetp) {
+
+			list_for_each_safe(curr, next, &targetp->lunlist) {
+				lunp = list_entry(curr, LPFCSCSILUN_t , list);
+				list_del(&lunp->list);
+				kfree(lunp);
+			}
+
+			if (targetp->RptLunData) {
+				lpfc_page_free(phba,
+					       targetp->RptLunData->virt,
+					       targetp->RptLunData->phys);
+				kfree(targetp->RptLunData);
+			}
+
+			kfree(targetp);
+			phba->device_queue_hash[i] = 0;
+		}
+	}
+	return (0);
+}
+
+
+/******************************************************************************
+* Function name : lpfc_parse_binding_entry
+*
+* Description   : Parse binding entry for WWNN & WWPN
+*
+* ASCII Input string example: 2000123456789abc:lpfc1t0
+* 
+* Return        :  0              = Success
+*                  Greater than 0 = Binding entry syntax error. SEE defs
+*                                   LPFC_SYNTAX_ERR_XXXXXX.
+******************************************************************************/
+int
+lpfc_parse_binding_entry(lpfcHBA_t * phba,
+			 uint8_t * inbuf,
+			 uint8_t * outbuf,
+			 int in_size,
+			 int out_size,
+			 int bind_type,
+			 unsigned int *sum, int entry, int *lpfc_num)
+{
+	int c1, sumtmp;
+	uint8_t hexval;
+	char val[3] = {0};
+
+	char ds_lpfc[] = LPFC_DRIVER_NAME;
+
+	*lpfc_num = -1;
+	if (bind_type == LPFC_BIND_DID) {
+		outbuf++;
+	}
+
+	/* Sanity check the input parameters */
+	if (in_size < 1) {
+		/* Convert ASC to hex. Input byte cnt < 1. */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk1210,
+			       lpfc_mes1210,
+			       lpfc_msgBlk1210.msgPreambleStr);
+		return (LPFC_SYNTAX_ERR_ASC_CONVERT);
+	}
+	if ((out_size * 2) < in_size) {
+		/* Convert ASC to hex. Output buffer to small. */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk1212,
+			       lpfc_mes1212,
+			       lpfc_msgBlk1212.msgPreambleStr);
+		return (LPFC_SYNTAX_ERR_ASC_CONVERT);
+	}
+
+	/* Parse 16 digit ASC hex address */
+	while (in_size > 1) {
+		if (sscanf((char *)inbuf, "%1c", val) != 1) {
+			/* Convert ASC to hex. Input char seq not ASC hex. */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk1213,
+				       lpfc_mes1213,
+				       lpfc_msgBlk1213.msgPreambleStr);
+			return (LPFC_SYNTAX_ERR_ASC_CONVERT);
+		}
+		hexval = (uint8_t)simple_strtoul(val, NULL, 16);
+		*(char *)outbuf++ = hexval;
+		inbuf += 2;
+		in_size -=2;
+	}
+
+	/* Parse colon */
+	if (*inbuf++ != ':')
+		return (LPFC_SYNTAX_ERR_EXP_COLON);
+
+	/* Parse lpfc */
+	if (strncmp(inbuf, ds_lpfc, strlen(ds_lpfc)))
+		return (LPFC_SYNTAX_ERR_EXP_LPFC);
+	inbuf += strlen(ds_lpfc);
+
+	/* Parse lpfc number */
+	/* Get 1st lpfc digit */
+	c1 = *inbuf++;
+	if (!isdigit(c1))
+		goto err_lpfc_num;
+	sumtmp = c1 - 0x30;
+
+	/* Get 2nd lpfc digit */
+	c1 = *inbuf;
+	if (!isdigit(c1))
+		goto convert_instance;
+	inbuf++;
+	sumtmp = (sumtmp * 10) + c1 - 0x30;
+
+	/* Get 3rd lpfc digit */
+	c1 = *inbuf;
+	if (!isdigit(c1))
+		goto convert_instance;
+	inbuf++;
+	sumtmp = (sumtmp * 10) + c1 - 0x30;
+	if (sumtmp < 0)
+		goto err_lpfc_num;
+
+	goto convert_instance;
+
+      err_lpfc_num:
+
+	return (LPFC_SYNTAX_ERR_INV_LPFC_NUM);
+
+	/* Convert from ddi instance number to adapter number */
+      convert_instance:
+
+	/* Check to see if this is the right board */
+	if(phba->brd_no != sumtmp) {
+		/* Skip this entry */
+		return(LPFC_SYNTAX_OK_BUT_NOT_THIS_BRD);
+	}
+
+	/* Parse 't' */
+	if (*inbuf++ != 't')
+		return (LPFC_SYNTAX_ERR_EXP_T);
+
+	/* Parse target number */
+	/* Get 1st target digit */
+	c1 = *inbuf++;
+	if (!isdigit(c1))
+		goto err_target_num;
+	sumtmp = c1 - 0x30;
+
+	/* Get 2nd target digit */
+	c1 = *inbuf;
+	if (!isdigit(c1))
+		goto check_for_term;
+	inbuf++;
+	sumtmp = (sumtmp * 10) + c1 - 0x30;
+
+	/* Get 3nd target digit */
+	c1 = *inbuf;
+	if (!isdigit(c1))
+		goto check_for_term;
+	inbuf++;
+	sumtmp = (sumtmp * 10) + c1 - 0x30;
+	goto check_for_term;
+
+      err_target_num:
+	return (LPFC_SYNTAX_ERR_INV_TARGET_NUM);
+
+      check_for_term:
+
+	if (*inbuf != 0)
+		return (LPFC_SYNTAX_ERR_EXP_NULL_TERM);
+
+	*sum = sumtmp;
+	return (LPFC_SYNTAX_OK);	/* Success */
+}
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_logmsg.c linux-8155/drivers/addon/lpfc/lpfc_logmsg.c
--- linux-8152/drivers/addon/lpfc/lpfc_logmsg.c
+++ linux-8155/drivers/addon/lpfc/lpfc_logmsg.c
@@ -0,0 +1,4371 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_logmsg.c 369 2005-07-08 23:29:48Z sf_support $
+ */
+#include <linux/version.h>
+#include <linux/spinlock.h>
+#include <linux/pci.h>
+
+
+#include <linux/blk.h>
+#include <scsi.h>
+
+#include "lpfc_hw.h"
+#include "lpfc_mem.h"
+#include "lpfc_sli.h"
+#include "lpfc_sched.h"
+#include "lpfc_disc.h"
+#include "lpfc.h"
+#include "lpfc_scsi.h"
+#include "lpfc_logmsg.h"
+#include "lpfc_cfgparm.h"
+#include "lpfc_crtn.h"
+
+/*
+ * Define the message logging functions
+ */
+
+#define  MAX_IO_SIZE 32 * 2	/* iobuf cache size */
+#define  MAX_TBUFF   18 * 2	/* temp buffer size */
+
+extern char *lpfc_drvr_name;
+extern lpfcDRVR_t lpfcDRVR;
+
+int
+lpfc_printf_log(int brdno, msgLogDef * msg,	/* Pointer to LOG msg
+						   structure */
+	       void *control, ...)
+{
+	uint8_t str2[MAX_IO_SIZE + MAX_TBUFF];	/* extra room to convert
+						   numbers */
+	int iocnt;
+	va_list args;
+	va_start(args, control);
+
+	if (lpfc_log_chk_msg_disabled(brdno, msg))
+		return (0);	/* This LOG message disabled */
+
+	/* If LOG message is disabled via any SW method, we SHOULD NOT get this
+	   far!  We should have taken the above return.
+	 */
+
+	str2[0] = '\0';
+	iocnt = vsprintf(str2, control, args);
+	va_end(args);
+	return (lpfc_printf_log_msgblk(brdno, msg, (char *)str2));
+}
+
+int
+lpfc_log_chk_msg_disabled(int brdno, msgLogDef * msg)
+{				/* Pointer to LOG msg structure */
+	lpfcHBA_t *phba;
+	lpfcCfgParam_t *clp;
+	int verbose;
+
+	verbose = 0;
+
+	if (msg->msgOutput == LPFC_MSG_OPUT_DISA)
+		return (1);	/* This LOG message disabled */
+
+        if ((phba = lpfc_get_phba_by_inst(brdno)) != NULL) {
+		clp = &phba->config[0];
+		verbose = clp[LPFC_CFG_LOG_VERBOSE].a_current;
+	}
+
+	if (msg->msgOutput == LPFC_MSG_OPUT_FORCE) {
+		return (0);	/* This LOG message enabled */
+	}
+
+	if ((msg->msgType == LPFC_LOG_MSG_TYPE_INFO) ||
+	    (msg->msgType == LPFC_LOG_MSG_TYPE_WARN)) {
+		/* LOG msg is INFO or WARN */
+		if ((msg->msgMask & verbose) == 0)
+			return (1);	/* This LOG message disabled */
+	}
+
+	return (0);		/* This LOG message enabled */
+}
+
+int
+lpfc_printf_log_msgblk(int brdno, msgLogDef * msg, char *str)
+{				/* String formatted by caller */
+	int ddiinst;
+	lpfcHBA_t *phba;
+
+        if ((phba = lpfc_get_phba_by_inst(brdno)) == NULL) {	
+		/* Remove: This case should not occur. Sanitize anyway. More
+		   testing needed */
+		printk(KERN_WARNING "%s%d:%04d:%s\n", lpfc_drvr_name, brdno,
+		       msg->msgNum, str);
+		return 1;
+	}
+
+	ddiinst = brdno;	/* Board number = instance in LINUX */
+	switch (msg->msgType) {
+	case LPFC_LOG_MSG_TYPE_INFO:
+	case LPFC_LOG_MSG_TYPE_WARN:
+		/* These LOG messages appear in LOG file only */
+		printk(KERN_INFO "%s%d:%04d:%s\n", lpfc_drvr_name, ddiinst,
+		       msg->msgNum, str);
+		break;
+	case LPFC_LOG_MSG_TYPE_ERR_CFG:
+	case LPFC_LOG_MSG_TYPE_ERR:
+		/* These LOG messages appear on the monitor and in the LOG
+		   file */
+		printk(KERN_WARNING "%s%d:%04d:%s\n", lpfc_drvr_name, ddiinst,
+		       msg->msgNum, str);
+		break;
+	case LPFC_LOG_MSG_TYPE_PANIC:
+		panic("%s%d:%04d:%s\n", lpfc_drvr_name, ddiinst, msg->msgNum,
+		      str);
+		break;
+	default:
+		return (0);
+	}
+	return (1);
+}
+
+/* ELS Log Message Preamble Strings - 100 */
+char lpfc_msgPreambleELi[] = "ELi:";	/* ELS Information */
+char lpfc_msgPreambleELw[] = "ELw:";	/* ELS Warning */
+char lpfc_msgPreambleELe[] = "ELe:";	/* ELS Error */
+char lpfc_msgPreambleELp[] = "ELp:";	/* ELS Panic */
+
+/* DISCOVERY Log Message Preamble Strings - 200 */
+char lpfc_msgPreambleDIi[] = "DIi:";	/* Discovery Information */
+char lpfc_msgPreambleDIw[] = "DIw:";	/* Discovery Warning */
+char lpfc_msgPreambleDIe[] = "DIe:";	/* Discovery Error */
+char lpfc_msgPreambleDIp[] = "DIp:";	/* Discovery Panic */
+
+/* MAIBOX Log Message Preamble Strings - 300 */
+/* SLI Log Message Preamble Strings    - 300 */
+char lpfc_msgPreambleMBi[] = "MBi:";	/* Mailbox Information */
+char lpfc_msgPreambleMBw[] = "MBw:";	/* Mailbox Warning */
+char lpfc_msgPreambleMBe[] = "MBe:";	/* Mailbox Error */
+char lpfc_msgPreambleMBp[] = "MBp:";	/* Mailbox Panic */
+char lpfc_msgPreambleSLw[] = "SLw:";	/* SLI Warning */
+char lpfc_msgPreambleSLe[] = "SLe:";	/* SLI Error */
+char lpfc_msgPreambleSLi[] = "SLi:";	/* SLI Information */
+
+/* INIT Log Message Preamble Strings - 400, 500 */
+char lpfc_msgPreambleINi[] = "INi:";	/* INIT Information */
+char lpfc_msgPreambleINw[] = "INw:";	/* INIT Warning */
+char lpfc_msgPreambleINc[] = "INc:";	/* INIT Error Config */
+char lpfc_msgPreambleINe[] = "INe:";	/* INIT Error */
+char lpfc_msgPreambleINp[] = "INp:";	/* INIT Panic */
+
+/* IP Log Message Preamble Strings - 600 */
+char lpfc_msgPreambleIPi[] = "IPi:";	/* IP Information */
+char lpfc_msgPreambleIPw[] = "IPw:";	/* IP Warning */
+char lpfc_msgPreambleIPe[] = "IPe:";	/* IP Error */
+char lpfc_msgPreambleIPp[] = "IPp:";	/* IP Panic */
+
+/* FCP Log Message Preamble Strings - 700, 800 */
+char lpfc_msgPreambleFPi[] = "FPi:";	/* FP Information */
+char lpfc_msgPreambleFPw[] = "FPw:";	/* FP Warning */
+char lpfc_msgPreambleFPe[] = "FPe:";	/* FP Error */
+char lpfc_msgPreambleFPp[] = "FPp:";	/* FP Panic */
+
+/* NODE Log Message Preamble Strings - 900 */
+char lpfc_msgPreambleNDi[] = "NDi:";	/* Node Information */
+char lpfc_msgPreambleNDe[] = "NDe:";	/* Node Error */
+char lpfc_msgPreambleNDp[] = "NDp:";	/* Node Panic */
+
+/* MISC Log Message Preamble Strings - 1200 */
+char lpfc_msgPreambleMIi[] = "MIi:";	/* MISC Information */
+char lpfc_msgPreambleMIw[] = "MIw:";	/* MISC Warning */
+char lpfc_msgPreambleMIc[] = "MIc:";	/* MISC Error Config */
+char lpfc_msgPreambleMIe[] = "MIe:";	/* MISC Error */
+char lpfc_msgPreambleMIp[] = "MIp:";	/* MISC Panic */
+
+/* Link Log Message Preamble Strings - 1300 */
+char lpfc_msgPreambleLKi[] = "LKi:";	/* Link Information */
+char lpfc_msgPreambleLKw[] = "LKw:";	/* Link Warning */
+char lpfc_msgPreambleLKe[] = "LKe:";	/* Link Error */
+char lpfc_msgPreambleLKp[] = "Lkp:";	/* Link Panic */
+
+/* Libdfc Log Message Preamble Strings - 1600 */
+char lpfc_msgPreambleLDi[] = "LDi:";	/* Libdfc Information */
+char lpfc_msgPreambleLDw[] = "LDw:";	/* Libdfc Warning */
+char lpfc_msgPreambleLDe[] = "LDe:";	/* Libdfc Error */
+char lpfc_msgPreambleLDp[] = "LDp:";	/* Libdfc Panic */
+
+/* 
+ * The format of all code below this point must meet rules specified by 
+ * the ultility MKLOGRPT.
+ */
+
+/*
+ *  Begin ELS LOG message structures
+ */
+
+/*
+msgName: lpfc_mes0100
+message:  FLOGI failure
+descript: An ELS FLOGI command that was sent to the fabric failed.
+data:     (1) ulpStatus (2) ulpWord[4]
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0100[] = "%sFLOGI failure Data: x%x x%x";
+msgLogDef lpfc_msgBlk0100 = {
+	LPFC_LOG_MSG_EL_0100,
+	lpfc_mes0100,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0101
+message:  FLOGI completes successfully
+descript: An ELS FLOGI command that was sent to the fabric succeeded.
+data:     (1) ulpWord[4] (2) e_d_tov (3) r_a_tov (4) edtovResolution
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0101[] = "%sFLOGI completes sucessfully Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0101 = {
+	LPFC_LOG_MSG_EL_0101,
+	lpfc_mes0101,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0102
+message:  PLOGI completes to NPort <nlp_DID>
+descript: The HBA performed a PLOGI into a remote NPort
+data:     (1) ulpStatus (2) ulpWord[4] (3) disc (4) num_disc_nodes
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0102[] = "%sPLOGI completes to NPort x%x Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0102 = {
+	LPFC_LOG_MSG_EL_0102,
+	lpfc_mes0102,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0103
+message:  PRLI completes to NPort <nlp_DID>
+descript: The HBA performed a PRLI into a remote NPort
+data:     (1) ulpStatus (2) ulpWord[4] (3) num_disc_nodes
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0103[] = "%sPRLI completes to NPort x%x Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0103 = {
+	LPFC_LOG_MSG_EL_0103,
+	lpfc_mes0103,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0104
+message:  ADISC completes to NPort <nlp_DID>
+descript: The HBA performed a ADISC into a remote NPort
+data:     (1) ulpStatus (2) ulpWord[4] (3) disc (4) num_disc_nodes
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0104[] = "%sADISC completes to NPort x%x Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0104 = {
+	LPFC_LOG_MSG_EL_0104,
+	lpfc_mes0104,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0105
+message:  LOGO completes to NPort <nlp_DID>
+descript: The HBA performed a LOGO to a remote NPort
+data:     (1) ulpStatus (2) ulpWord[4] (3) num_disc_nodes
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0105[] = "%sLOGO completes to NPort x%x Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0105 = {
+	LPFC_LOG_MSG_EL_0105,
+	lpfc_mes0105,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0106
+message:  ELS cmd tag <ulpIoTag> completes
+descript: The specific ELS command was completed by the firmware.
+data:     (1) ulpStatus (2) ulpWord[4]
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0106[] = "%sELS cmd tag x%x completes Data: x%x x%x";
+msgLogDef lpfc_msgBlk0106 = {
+	LPFC_LOG_MSG_EL_0106,
+	lpfc_mes0106,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0107
+message:  Retry ELS command <elsCmd> to remote NPORT <did>
+descript: The driver is retrying the specific ELS command.
+data:     (1) retry (2) delay
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0107[] =
+    "%sRetry ELS command x%x to remote NPORT x%x Data: x%x x%x";
+msgLogDef lpfc_msgBlk0107 = {
+	LPFC_LOG_MSG_EL_0107,
+	lpfc_mes0107,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0108
+message:  No retry ELS command <elsCmd> to remote NPORT <did>
+descript: The driver decided not to retry the specific ELS command that failed.
+data:     (1) retry (2) nlp_flag
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0108[] =
+    "%sNo retry ELS command x%x to remote NPORT x%x Data: x%x x%x";
+msgLogDef lpfc_msgBlk0108 = {
+	LPFC_LOG_MSG_EL_0108,
+	lpfc_mes0108,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0109
+message:  ACC to LOGO completes to NPort <nlp_DID>
+descript: The driver received a LOGO from a remote NPort and successfully
+          issued an ACC response.
+data:     (1) nlp_flag (2) nlp_state (3) nlp_rpi
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0109[] = "%sACC to LOGO completes to NPort x%x Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0109 = {
+	LPFC_LOG_MSG_EL_0109,
+	lpfc_mes0109,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0110
+message:  ELS response tag <ulpIoTag> completes
+descript: The specific ELS response was completed by the firmware.
+data:     (1) ulpStatus (2) ulpWord[4] (3) nlp_DID (4) nlp_flag (5) nlp_state
+          (6) nlp_rpi
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0110[] =
+    "%sELS response tag x%x completes Data: x%x x%x x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0110 = {
+	LPFC_LOG_MSG_EL_0110,
+	lpfc_mes0110,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0111
+message:  Dropping received ELS cmd
+descript: The driver decided to drop an ELS Response ring entry
+data:     (1) ulpStatus (2) ulpWord[4]
+severity: Error
+log:      Always
+action:   This error could indicate a software driver or firmware 
+          problem. If problems persist report these errors to 
+          Technical Support.
+*/
+char lpfc_mes0111[] = "%sDropping received ELS cmd Data: x%x x%x";
+msgLogDef lpfc_msgBlk0111 = {
+	LPFC_LOG_MSG_EL_0111,
+	lpfc_mes0111,
+	lpfc_msgPreambleELe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0112
+message:  ELS command <elsCmd> received from NPORT <did> 
+descript: Received the specific ELS command from a remote NPort.
+data:     (1) fc_ffstate
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0112[] = "%sELS command x%x received from NPORT x%x Data: x%x";
+msgLogDef lpfc_msgBlk0112 = {
+	LPFC_LOG_MSG_EL_0112,
+	lpfc_mes0112,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0113
+message:  An FLOGI ELS command <elsCmd> was received from DID <did> in Loop
+          Mode
+descript: While in Loop Mode an unknown or unsupported ELS commnad 
+          was received.
+data:     None
+severity: Error
+log:      Always
+action:   Check device DID
+*/
+char lpfc_mes0113[] =
+    "%sAn FLOGI ELS command x%x was received from DID x%x in Loop Mode";
+msgLogDef lpfc_msgBlk0113 = {
+	LPFC_LOG_MSG_EL_0113,
+	lpfc_mes0113,
+	lpfc_msgPreambleELe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0114
+message:  PLOGI chkparm OK
+descript: Received a PLOGI from a remote NPORT and its Fibre Channel service 
+          parameters match this HBA. Request can be accepted.
+data:     (1) nlp_DID (2) nlp_state (3) nlp_flag (4) nlp_Rpi
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0114[] = "%sPLOGI chkparm OK Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0114 = {
+	LPFC_LOG_MSG_EL_0114,
+	lpfc_mes0114,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0115
+message:  Unknown ELS command <elsCmd> received from NPORT <did> 
+descript: Received an unsupported ELS command from a remote NPORT.
+data:     None
+severity: Error
+log:      Always
+action:   Check remote NPORT for potential problem.
+*/
+char lpfc_mes0115[] = "%sUnknown ELS command x%x received from NPORT x%x";
+msgLogDef lpfc_msgBlk0115 = {
+	LPFC_LOG_MSG_EL_0115,
+	lpfc_mes0115,
+	lpfc_msgPreambleELe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0116
+message:  Xmit ELS command <elsCmd> to remote NPORT <did>
+descript: Xmit ELS command to remote NPORT 
+data:     (1) icmd->ulpIoTag (2) binfo->fc_ffstate
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0116[] = "%sXmit ELS command x%x to remote NPORT x%x Data: x%x x%x";
+msgLogDef lpfc_msgBlk0116 = {
+	LPFC_LOG_MSG_EL_0116,
+	lpfc_mes0116,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0117
+message:  Xmit ELS response <elsCmd> to remote NPORT <did>
+descript: Xmit ELS response to remote NPORT 
+data:     (1) icmd->ulpIoTag (2) size
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0117[] =
+    "%sXmit ELS response x%x to remote NPORT x%x Data: x%x x%x";
+msgLogDef lpfc_msgBlk0117 = {
+	LPFC_LOG_MSG_EL_0117,
+	lpfc_mes0117,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0118
+message:  Xmit CT response on exchange <xid>
+descript: Xmit a CT response on the appropriate exchange.
+data:     (1) ulpIoTag (2) fc_ffstate
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0118[] = "%sXmit CT response on exchange x%x Data: x%x x%x";
+msgLogDef lpfc_msgBlk0118 = {
+	LPFC_LOG_MSG_EL_0118,
+	lpfc_mes0118,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0119
+message:  Issue GEN REQ IOCB for NPORT <did>
+descript: Issue a GEN REQ IOCB for remote NPORT.  These are typically
+          used for CT request. 
+data:     (1) ulpIoTag (2) fc_ffstate
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0119[] = "%sIssue GEN REQ IOCB for NPORT x%x Data: x%x x%x";
+msgLogDef lpfc_msgBlk0119 = {
+	LPFC_LOG_MSG_EL_0119,
+	lpfc_mes0119,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0120
+message:  PLOGI chkparm OK
+descript: Received a PLOGI from a remote NPORT and its Fibre Channel service 
+          parameters match this HBA. Request can be accepted.
+data:     (1) nlp_DID (2) nlp_state (3) nlp_flag (4) nlp_Rpi
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0120[] = "%sPLOGI chkparm OK Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0120 = {
+	LPFC_LOG_MSG_EL_0120,
+	lpfc_mes0120,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0121
+message:  PLOGI chkparm OK
+descript: Received a PLOGI from a remote NPORT and its Fibre Channel service 
+          parameters match this HBA. Request can be accepted.
+data:     (1) nlp_DID (2) nlp_state (3) nlp_flag (4) nlp_Rpi
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0121[] = "%sPLOGI chkparm OK Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0121 = {
+	LPFC_LOG_MSG_EL_0121,
+	lpfc_mes0121,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0122
+message:  PLOGI chkparm OK
+descript: Received a PLOGI from a remote NPORT and its Fibre Channel service 
+          parameters match this HBA. Request can be accepted.
+data:     (1) nlp_DID (2) nlp_state (3) nlp_flag (4) nlp_Rpi
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0122[] = "%sPLOGI chkparm OK Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0122 = {
+	LPFC_LOG_MSG_EL_0122,
+	lpfc_mes0122,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0123
+message:  PLOGI chkparm OK
+descript: Received a PLOGI from a remote NPORT and its Fibre Channel service 
+          parameters match this HBA. Request can be accepted.
+data:     (1) nlp_DID (2) nlp_state (3) nlp_flag (4) nlp_Rpi
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0123[] = "%sPLOGI chkparm OK Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0123 = {
+	LPFC_LOG_MSG_EL_0123,
+	lpfc_mes0123,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0124
+message:  PLOGI chkparm OK
+descript: Received a PLOGI from a remote NPORT and its Fibre Channel service 
+          parameters match this HBA. Request can be accepted.
+data:     (1) nlp_DID (2) nlp_state (3) nlp_flag (4) nlp_Rpi
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0124[] = "%sPLOGI chkparm OK Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0124 = {
+	LPFC_LOG_MSG_EL_0124,
+	lpfc_mes0124,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0125
+message:  PLOGI chkparm OK
+descript: Received a PLOGI from a remote NPORT and its Fibre Channel service 
+          parameters match this HBA. Request can be accepted.
+data:     (1) nlp_DID (2) nlp_state (3) nlp_flag (4) nlp_Rpi
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0125[] = "%sPLOGI chkparm OK Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0125 = {
+	LPFC_LOG_MSG_EL_0125,
+	lpfc_mes0125,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0126
+message:  PLOGI chkparm OK
+descript: Received a PLOGI from a remote NPORT and its Fibre Channel service 
+          parameters match this HBA. Request can be accepted.
+data:     (1) nlp_DID (2) nlp_state (3) nlp_flag (4) nlp_Rpi
+severity: Information
+log:      LOG_ELS verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0126[] = "%sPLOGI chkparm OK Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0126 = {
+	LPFC_LOG_MSG_EL_0126,
+	lpfc_mes0126,
+	lpfc_msgPreambleELi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_ELS,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0127
+message:  ELS timeout
+descript: An ELS IOCB command was posted to a ring and did not complete
+          within ULP timeout seconds.
+data:     (1) elscmd (2) did (3) ulpcommand (4) iotag
+severity: Error
+log:      Always
+action:   If no ELS command is going through the adapter, reboot the system;
+          If problem persists, contact Technical Support.
+*/
+char lpfc_mes0127[] = "%sELS timeout Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0127 = {
+	LPFC_LOG_MSG_EL_0127,
+	lpfc_mes0127,
+	lpfc_msgPreambleELe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_ELS,
+	ERRID_LOG_TIMEOUT
+};
+
+/*
+ *  Begin DSCOVERY LOG Message Structures
+ */
+
+/*
+msgName: lpfc_mes0200
+message:  CONFIG_LINK bad hba state <hba_state>
+descript: A CONFIG_LINK mbox command completed and the driver was not in the
+          right state.
+data:     none
+severity: Error
+log:      Always
+action:   Software driver error.
+          If this problem persists, report these errors to Technical Support.
+*/
+char lpfc_mes0200[] = "%sCONFIG_LINK bad hba state x%x";
+msgLogDef lpfc_msgBlk0200 = {
+	LPFC_LOG_MSG_DI_0200,
+	lpfc_mes0200,
+	lpfc_msgPreambleDIe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0201
+message:  Abort outstanding I/O on NPort <nlp_DID>
+descript: All outstanding I/Os are cleaned up on the specified remote NPort.
+data:     (1) nlp_flag (2) nlp_state (3) nlp_rpi
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0201[] = "%sAbort outstanding I/O on NPort x%x Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0201 = {
+	LPFC_LOG_MSG_DI_0201,
+	lpfc_mes0201,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0202
+message:  Start Discovery hba state <hba_state>
+descript: Device discovery / rediscovery after FLOGI, FAN or RSCN has started.
+data:     (1) tmo (2) fc_plogi_cnt (3) fc_adisc_cnt
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0202[] = "%sStart Discovery hba state x%x Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0202 = {
+	LPFC_LOG_MSG_DI_0202,
+	lpfc_mes0202,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0204
+message:  Create SCSI Target <tgt>
+descript: A mapped FCP target was discovered and the driver has allocated
+          resources for it.
+data:     none
+severity: Information
+log:      LOG_DISCOVERY | LOG_FCP verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0204[] = "%sCreate SCSI Target %d";
+msgLogDef lpfc_msgBlk0204 = {
+	LPFC_LOG_MSG_DI_0204,
+	lpfc_mes0204,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY | LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0205
+message:  Create SCSI LUN <lun> on Target <tgt>
+descript: A LUN on a mapped FCP target was discovered and the driver has
+          allocated resources for it.
+data:     none
+severity: Information
+log:      LOG_DISCOVERY | LOG_FCP verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0205[] = "%sCreate SCSI LUN %d on Target %d";
+msgLogDef lpfc_msgBlk0205 = {
+	LPFC_LOG_MSG_DI_0205,
+	lpfc_mes0205,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY | LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0206
+message:  Report Lun completes on NPort <nlp_DID>
+descript: The driver issued a REPORT_LUN SCSI command to a FCP target and it
+          completed.
+data:     (1) ulpStatus (2) rspStatus2 (3) rspStatus3 (4) nlp_failMask
+severity: Information
+log:      LOG_DISCOVERY | LOG_FCP verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0206[] =
+    "%sReport Lun completes on NPort x%x status: x%x status2: x%x status3: x%x failMask: x%x";
+msgLogDef lpfc_msgBlk0206 = {
+	LPFC_LOG_MSG_DI_0206,
+	lpfc_mes0206,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY | LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0207
+message:  Issue Report LUN on NPort <nlp_DID>
+descript: The driver issued a REPORT_LUN SCSI command to a FCP target.
+data:     (1) nlp_failMask (2) nlp_state (3) nlp_rpi
+severity: Information
+log:      LOG_DISCOVERY | LOG_FCP verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0207[] = "%sIssue Report LUN on NPort x%x Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0207 = {
+	LPFC_LOG_MSG_DI_0207,
+	lpfc_mes0207,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY | LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0208
+message:  Failmask change on NPort <nlp_DID>
+descript: An event was processed that indicates the driver may not be able to
+          communicate with the remote NPort.
+data:     (1) nlp_failMask (2) bitmask (3) flag
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0208[] = "%sFailmask change on NPort x%x Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0208 = {
+	LPFC_LOG_MSG_DI_0208,
+	lpfc_mes0208,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0209
+message:  RFT request completes ulpStatus <ulpStatus> CmdRsp <CmdRsp>
+descript: A RFT request that was sent to the fabric completed.
+data:     (1) nlp_failMask (2) bitmask (3) flag
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0209[] = "%sRFT request completes ulpStatus x%x CmdRsp x%x";
+msgLogDef lpfc_msgBlk0209 = {
+	LPFC_LOG_MSG_DI_0209,
+	lpfc_mes0209,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0210
+message:  Continue discovery with <num_disc_nodes> ADISCs to go
+descript: Device discovery is in progress
+data:     (1) fc_adisc_cnt (2) fc_flag (3) phba->hba_state
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0210[] =
+    "%sContinue discovery with %d ADISCs to go Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0210 = {
+	LPFC_LOG_MSG_DI_0210,
+	lpfc_mes0210,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0211
+message:  DSM in event <evt> on NPort <nlp_DID> in state <cur_state>
+descript: The driver Discovery State Machine is processing an event.
+data:     (1) nlp_flag
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0211[] = "%sDSM in event x%x on NPort x%x in state %d Data: x%x";
+msgLogDef lpfc_msgBlk0211 = {
+	LPFC_LOG_MSG_DI_0211,
+	lpfc_mes0211,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0212
+message:  DSM out state <rc> on NPort <nlp_DID>
+descript: The driver Discovery State Machine completed processing an event.
+data:     (1) nlp_flag
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0212[] = "%sDSM out state %d on NPort x%x Data: x%x";
+msgLogDef lpfc_msgBlk0212 = {
+	LPFC_LOG_MSG_DI_0212,
+	lpfc_mes0212,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0213
+message:  Reassign scsi id <sid> to NPort <nlp_DID>
+descript: A previously bound FCP Target has been rediscovered and reassigned a
+          scsi id.
+data:     (1) nlp_bind_type (2) nlp_flag (3) nlp_state (4) nlp_rpi
+severity: Information
+log:      LOG_DISCOVERY | LOG_FCP verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0213[] =
+    "%sReassign scsi id x%x to NPort x%x Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0213 = {
+	LPFC_LOG_MSG_DI_0213,
+	lpfc_mes0213,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY | LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0214
+message:  RSCN received
+descript: A RSCN ELS command was received from a fabric.
+data:     (1) fc_flag (2) i (3) *lp (4) fc_rscn_id_cnt
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0214[] = "%sRSCN received Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0214 = {
+	LPFC_LOG_MSG_DI_0214,
+	lpfc_mes0214,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0215
+message:  RSCN processed
+descript: A RSCN ELS command was received from a fabric and processed.
+data:     (1) fc_flag (2) cnt (3) fc_rscn_id_cnt (4) fc_ffstate
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0215[] = "%sRSCN processed Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0215 = {
+	LPFC_LOG_MSG_DI_0215,
+	lpfc_mes0215,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0216
+message:  Assign scandown scsi id <sid> to NPort <nlp_DID>
+descript: A scsi id is assigned due to BIND_ALPA.
+data:     (1) nlp_bind_type (2) nlp_flag (3) nlp_state (4) nlp_rpi
+severity: Information
+log:      LOG_DISCOVERY | LOG_FCP verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0216[] =
+    "%sAssign scandown scsi id x%x to NPort x%x Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0216 = {
+	LPFC_LOG_MSG_DI_0216,
+	lpfc_mes0216,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY | LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0217
+message:  Unknown Identifier in RSCN payload
+descript: Typically the identifier in the RSCN payload specifies 
+          a domain, area or a specific NportID. If neither of 
+          these are specified, a warning will be recorded. 
+data:     (1) didp->un.word
+detail:   (1) Illegal identifier
+severity: Error
+log:      Always
+action:   Potential problem with Fabric. Check with Fabric vendor.
+*/
+char lpfc_mes0217[] = "%sUnknown Identifier in RSCN payload Data: x%x";
+msgLogDef lpfc_msgBlk0217 = {
+	LPFC_LOG_MSG_DI_0217,
+	lpfc_mes0217,
+	lpfc_msgPreambleDIe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0218
+message:  FDMI Request
+descript: The driver is sending an FDMI request to the fabric.
+data:     (1) fc_flag (2) hba_state (3) cmdcode
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0218[] = "%sFDMI Request Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0218 = {
+	LPFC_LOG_MSG_DI_0218,
+	lpfc_mes0218,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0219
+message:  Issue FDMI request failed
+descript: Cannot issue FDMI request to HBA.
+data:     (1) cmdcode
+severity: Information
+log:      LOG_Discovery verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0219[] = "%sIssue FDMI request failed Data: x%x";
+msgLogDef lpfc_msgBlk0219 = {
+	LPFC_LOG_MSG_DI_0219,
+	lpfc_mes0219,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0220
+message:  FDMI rsp failed
+descript: An error response was received to FDMI request
+data:     (1) be16_to_cpu(fdmi_cmd)
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   The fabric does not support FDMI, check fabric configuration.
+*/
+char lpfc_mes0220[] = "%sFDMI rsp failed Data: x%x";
+msgLogDef lpfc_msgBlk0220 = {
+	LPFC_LOG_MSG_DI_0220,
+	lpfc_mes0220,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0221
+message:  FAN timeout
+descript: A link up event was received without the login bit set, 
+          so the driver waits E_D_TOV for the Fabric to send a FAN. 
+          If no FAN if received, a FLOGI will be sent after the timeout. 
+data:     None
+severity: Warning
+log:      LOG_DISCOVERY verbose
+action:   None required. The driver recovers from this condition by 
+          issuing a FLOGI to the Fabric.
+*/
+char lpfc_mes0221[] = "%sFAN timeout";
+msgLogDef lpfc_msgBlk0221 = {
+	LPFC_LOG_MSG_DI_0221,
+	lpfc_mes0221,
+	lpfc_msgPreambleDIw,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_WARN,
+	LOG_DISCOVERY,
+	ERRID_LOG_TIMEOUT
+};
+
+/*
+msgName: lpfc_mes0222
+message:  Initial FLOGI timeout
+descript: The driver sent the initial FLOGI to fabric and never got a response
+          back.
+data:     None
+severity: Error
+log:      Always
+action:   Check Fabric configuration. The driver recovers from this and 
+          continues with device discovery.
+*/
+char lpfc_mes0222[] = "%sInitial FLOGI timeout";
+msgLogDef lpfc_msgBlk0222 = {
+	LPFC_LOG_MSG_DI_0222,
+	lpfc_mes0222,
+	lpfc_msgPreambleDIe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_DISCOVERY,
+	ERRID_LOG_TIMEOUT
+};
+
+/*
+msgName: lpfc_mes0223
+message:  Timeout while waiting for NameServer login 
+descript: Our login request to the NameServer was not acknowledged 
+          within RATOV.
+data:     None
+severity: Error
+log:      Always
+action:   Check Fabric configuration. The driver recovers from this and 
+          continues with device discovery.
+*/
+char lpfc_mes0223[] = "%sTimeout while waiting for NameServer login";
+msgLogDef lpfc_msgBlk0223 = {
+	LPFC_LOG_MSG_DI_0223,
+	lpfc_mes0223,
+	lpfc_msgPreambleDIe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_DISCOVERY,
+	ERRID_LOG_TIMEOUT
+};
+
+/*
+msgName: lpfc_mes0224
+message:  NameServer Query timeout
+descript: Node authentication timeout, node Discovery timeout. A NameServer 
+          Query to the Fabric or discovery of reported remote NPorts is not 
+          acknowledged within R_A_TOV. 
+data:     (1) fc_ns_retry (2) fc_max_ns_retry
+severity: Error
+log:      Always
+action:   Check Fabric configuration. The driver recovers from this and 
+          continues with device discovery.
+*/
+char lpfc_mes0224[] = "%sNameServer Query timeout Data: x%x x%x";
+msgLogDef lpfc_msgBlk0224 = {
+	LPFC_LOG_MSG_DI_0224,
+	lpfc_mes0224,
+	lpfc_msgPreambleDIe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_DISCOVERY,
+	ERRID_LOG_TIMEOUT
+};
+
+/*
+msgName: lpfc_mes0225
+message:  Device Discovery completes
+descript: This indicates successful completion of device 
+          (re)discovery after a link up. 
+data:     None
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0225[] = "%sDevice Discovery completes";
+msgLogDef lpfc_msgBlk0225 = {
+	LPFC_LOG_MSG_DI_0225,
+	lpfc_mes0225,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0226
+message:  Device Discovery completion error
+descript: This indicates an uncorrectable error was encountered 
+          during device (re)discovery after a link up. Fibre 
+          Channel devices will not be accessible if this message 
+          is displayed.
+data:     None
+severity: Error
+log:      Always
+action:   Reboot system. If problem persists, contact Technical 
+          Support. Run with verbose mode on for more details.
+*/
+char lpfc_mes0226[] = "%sDevice Discovery completion error";
+msgLogDef lpfc_msgBlk0226 = {
+	LPFC_LOG_MSG_DI_0226,
+	lpfc_mes0226,
+	lpfc_msgPreambleDIe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0227
+message:  Node Authentication timeout
+descript: The driver has lost track of what NPORTs are being authenticated.
+data:     None
+severity: Error
+log:      Always
+action:   None required. Driver should recover from this event.
+*/
+char lpfc_mes0227[] = "%sNode Authentication timeout";
+msgLogDef lpfc_msgBlk0227 = {
+	LPFC_LOG_MSG_DI_0227,
+	lpfc_mes0227,
+	lpfc_msgPreambleDIe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_DISCOVERY,
+	ERRID_LOG_TIMEOUT
+};
+
+/*
+msgName: lpfc_mes0228
+message:  CLEAR LA timeout
+descript: The driver issued a CLEAR_LA that never completed
+data:     None
+severity: Error
+log:      Always
+action:   None required. Driver should recover from this event.
+*/
+char lpfc_mes0228[] = "%sCLEAR LA timeout";
+msgLogDef lpfc_msgBlk0228 = {
+	LPFC_LOG_MSG_DI_0228,
+	lpfc_mes0228,
+	lpfc_msgPreambleDIe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_DISCOVERY,
+	ERRID_LOG_TIMEOUT
+};
+
+/*
+msgName: lpfc_mes0229
+message:  Assign scsi ID <sid> to NPort <nlp_DID>
+descript: The driver assigned a scsi id to a discovered mapped FCP target.
+data:     (1) nlp_bind_type (2) nlp_flag (3) nlp_state (4) nlp_rpi
+severity: Information
+log:      LOG_DISCOVERY | LOG_FCP verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0229[] = "%sAssign scsi ID x%x to NPort x%x Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0229 = {
+	LPFC_LOG_MSG_DI_0229,
+	lpfc_mes0229,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY | LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0230
+message:  Cannot assign scsi ID on NPort <nlp_DID>
+descript: The driver cannot assign a scsi id to a discovered mapped FCP target.
+data:     (1) nlp_flag (2) nlp_state (3) nlp_rpi
+severity: Information
+log:      LOG_DISCOVERY | LOG_FCP verbose
+action:   Check persistent binding information
+*/
+char lpfc_mes0230[] = "%sCannot assign scsi ID on NPort x%x Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0230 = {
+	LPFC_LOG_MSG_DI_0230,
+	lpfc_mes0230,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY | LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0231
+message:  RSCN timeout
+descript: The driver has lost track of what NPORTs have RSCNs pending.
+data:     (1) fc_ns_retry (2) fc_max_ns_retry
+severity: Error
+log:      Always
+action:   None required. Driver should recover from this event.
+*/
+char lpfc_mes0231[] = "%sRSCN timeout Data: x%x x%x";
+msgLogDef lpfc_msgBlk0231 = {
+	LPFC_LOG_MSG_DI_0231,
+	lpfc_mes0231,
+	lpfc_msgPreambleDIe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_DISCOVERY,
+	ERRID_LOG_TIMEOUT
+};
+
+/*
+msgName: lpfc_mes0232
+message:  Continue discovery with <num_disc_nodes> PLOGIs to go
+descript: Device discovery is in progress
+data:     (1) fc_plogi_cnt (2) fc_flag (3) phba->hba_state
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0232[] =
+    "%sContinue discovery with %d PLOGIs to go Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0232 = {
+	LPFC_LOG_MSG_DI_0232,
+	lpfc_mes0232,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0234
+message:  ReDiscovery RSCN
+descript: The number / type of RSCNs has forced the driver to go to 
+          the nameserver and re-discover all NPORTs.
+data:     (1) fc_defer_rscn.q_cnt (2) fc_flag (3) hba_state
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0234[] = "%sReDiscovery RSCN Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0234 = {
+	LPFC_LOG_MSG_DI_0234,
+	lpfc_mes0234,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0235
+message:  Deferred RSCN
+descript: The driver has received multiple RSCNs and has deferred the 
+          processing of the most recent RSCN.
+data:     (1) fc_defer_rscn.q_cnt (2) fc_flag (3) hba_state
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0235[] = "%sDeferred RSCN Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0235 = {
+	LPFC_LOG_MSG_DI_0235,
+	lpfc_mes0235,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0236
+message:  NameServer Req
+descript: The driver is issuing a nameserver request to the fabric.
+data:     (1) cmdcode (2) fc_flag (3) fc_rscn_id_cnt
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0236[] = "%sNameServer Req Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0236 = {
+	LPFC_LOG_MSG_DI_0236,
+	lpfc_mes0236,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0237
+message:  Pending Link Event during Discovery
+descript: Received link event during discovery. Causes discovery restart.
+data:     (1) hba_state (2) ulpIoTag (3) ulpStatus (4) ulpWord[4]
+severity: Warning
+log:      LOG_DISCOVERY verbose
+action:   None required unless problem persist. If persistent check cabling.
+*/
+char lpfc_mes0237[] =
+    "%sPending Link Event during Discovery Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0237 = {
+	LPFC_LOG_MSG_DI_0237,
+	lpfc_mes0237,
+	lpfc_msgPreambleDIw,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_WARN,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0238
+message:  NameServer Rsp
+descript: The driver received a nameserver response.
+data:     (1) Did (2) nlp_flag (3) fc_flag (4) fc_rscn_id_cnt
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0238[] = "%sNameServer Rsp Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0238 = {
+	LPFC_LOG_MSG_DI_0238,
+	lpfc_mes0238,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0239
+message:  NameServer Rsp
+descript: The driver received a nameserver response.
+data:     (1) Did (2) ndlp (3) fc_flag (4) fc_rscn_id_cnt
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0239[] = "%sNameServer Rsp Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0239 = {
+	LPFC_LOG_MSG_DI_0239,
+	lpfc_mes0239,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0240
+message:  NameServer Rsp Error
+descript: The driver received a nameserver response containig a status error.
+data:     (1) CommandResponse.bits.CmdRsp (2) ReasonCode (3) Explanation 
+          (4) fc_flag
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   Check Fabric configuration. The driver recovers from this and 
+          continues with device discovery.
+*/
+char lpfc_mes0240[] = "%sNameServer Rsp Error Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0240 = {
+	LPFC_LOG_MSG_DI_0240,
+	lpfc_mes0240,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0241
+message:  NameServer Rsp Error
+descript: The driver received a nameserver response containig a status error.
+data:     (1) CommandResponse.bits.CmdRsp (2) ReasonCode (3) Explanation 
+          (4) fc_flag
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   Check Fabric configuration. The driver recovers from this and 
+          continues with device discovery.
+*/
+char lpfc_mes0241[] = "%sNameServer Rsp Error Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0241 = {
+	LPFC_LOG_MSG_DI_0241,
+	lpfc_mes0241,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0242
+message:  Abort outstanding I/O to the Fabric
+descript: All outstanding I/Os to the fabric are cleaned up.
+data:     (1) Fabric_DID
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0242[] = "%sAbort outstanding I/O to the Fabric x%x";
+msgLogDef lpfc_msgBlk0242 = {
+	LPFC_LOG_MSG_DI_0242,
+	lpfc_mes0242,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0243
+message:  Issue FDMI request failed
+descript: Cannot issue FDMI request to HBA.
+data:     (1) cmdcode
+severity: Information
+log:      LOG_Discovery verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0243[] = "%sIssue FDMI request failed Data: x%x";
+msgLogDef lpfc_msgBlk0243 = {
+	LPFC_LOG_MSG_DI_0243,
+	lpfc_mes0243,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0244
+message:  Issue FDMI request failed
+descript: Cannot issue FDMI request to HBA.
+data:     (1) cmdcode
+severity: Information
+log:      LOG_Discovery verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0244[] = "%sIssue FDMI request failed Data: x%x";
+msgLogDef lpfc_msgBlk0244 = {
+	LPFC_LOG_MSG_DI_0244,
+	lpfc_mes0244,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0245
+message:  ALPA based bind method used on an HBA which is in a nonloop topology
+descript: ALPA based bind method used on an HBA which is not
+          in a loop topology.
+data:     (1) topology
+severity: Warning
+log:      LOG_DISCOVERY verbose
+action:   Change the bind method configuration parameter of the HBA to
+          1(WWNN) or 2(WWPN) or 3(DID)
+*/
+char lpfc_mes0245[] =
+    "%sALPA based bind method used on an HBA which is in a nonloop topology Data: x%x";
+msgLogDef lpfc_msgBlk0245 = {
+	LPFC_LOG_MSG_DI_0245,
+	lpfc_mes0245,
+	lpfc_msgPreambleDIw,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_WARN,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0246
+message:  RegLogin failed 
+descript: Firmware returned failure for the specified RegLogin 
+data:     Did, mbxStatus, hbaState 
+severity: Error
+log:      Always 
+action:   This message indicates that the firmware could not do
+          RegLogin for the specified Did. It could be because
+          there is a limitation on how many nodes an HBA can see. 
+*/
+char lpfc_mes0246[] = "%sRegLogin failed Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0246 = {
+	LPFC_LOG_MSG_DI_0246,
+	lpfc_mes0246,
+	lpfc_msgPreambleDIe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0247
+message:  Start Discovery Timer state <hba_state>
+descript: Start device discovery / RSCN rescue timer
+data:     (1) tmo (2) disctmo (3) fc_plogi_cnt (4) fc_adisc_cnt
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0247[] = "%sStart Discovery Timer state x%x Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0247 = {
+	LPFC_LOG_MSG_DI_0247,
+	lpfc_mes0247,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0248
+message:  Cancel Discovery Timer state <hba_state>
+descript: Cancel device discovery / RSCN rescue timer
+data:     (1) fc_flag (2) rc (3) fc_plogi_cnt (4) fc_adisc_cnt
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0248[] = "%sCancel Discovery Timer state x%x Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0248 = {
+	LPFC_LOG_MSG_DI_0248,
+	lpfc_mes0248,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0249
+message: Unsupported Addressing Mode <i> on NPort <nlp_DID> Tgt <sid>
+descript: The driver issued a REPORT_LUN SCSI command to a FCP target.
+data:     None
+severity: Warning
+log:      LOG_DISCOVERY | LOG_FCP verbose
+action:   Check configuration of target. Driver will default to peripheral
+          addressing mode.
+*/
+char lpfc_mes0249[] = "%sUnsupported Addressing Mode %d on NPort x%x Tgt %d";
+msgLogDef lpfc_msgBlk0249 = {
+	LPFC_LOG_MSG_DI_0249,
+	lpfc_mes0249,
+	lpfc_msgPreambleDIw,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_WARN,
+	LOG_DISCOVERY | LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0250
+message:  EXPIRED nodev timer
+descript: A device disappeared for greater than the configuration parameter 
+          (lpfc_nodev_tmo) seconds. All I/O associated with this device 
+          will be failed.  
+data:     (1) dev_did (2) scsi_id (3) rpi 
+severity: Error
+log:      Always
+action:   Check physical connections to Fibre Channel network and the 
+          state of the remote PortID.
+*/
+char      lpfc_mes0250[] = "%sEXPIRED nodev timer Data: x%x x%x x%x"; 
+msgLogDef lpfc_msgBlk0250 = {
+          LPFC_LOG_MSG_DI_0250,
+          lpfc_mes0250,
+          lpfc_msgPreambleDIe,
+          LPFC_MSG_OPUT_GLOB_CTRL,
+          LPFC_LOG_MSG_TYPE_ERR,
+          LOG_DISCOVERY,
+          ERRID_LOG_UNEXPECT_EVENT 
+};
+
+/*
+msgName: lpfc_mes0256
+message:  Start nodev timer
+descript: A target disappeared from the Fibre Channel network. If the 
+          target does not return within nodev-tmo timeout all I/O to 
+          the target will fail.
+data:     (1) nlp_DID (2) nlp_flag (3) nlp_state (4) nlp
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0256[] = "%sStart nodev timer Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0256 = {
+	LPFC_LOG_MSG_DI_0256,
+	lpfc_mes0256,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0260
+message:  Stop Nodev timeout on NPort <nlp_DID>
+descript: The FCP target was rediscovered and I/O can be resumed.
+data:     (1) nlp_DID (2) nlp_flag (3) nlp_state (4) nlp
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0260[] = "%sStop nodev timeout on NPort x%x Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0260 = {
+	LPFC_LOG_MSG_DI_0260,
+	lpfc_mes0260,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0261
+message:  FAN received
+descript: A FAN was received from the fabric
+data:     NONE
+severity: Information
+log:      LOG_DISCOVERY verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0261[] = "%sFAN received";
+msgLogDef lpfc_msgBlk0261 = {
+	LPFC_LOG_MSG_DI_0261,
+	lpfc_mes0261,
+	lpfc_msgPreambleDIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+
+/*
+ *  Begin MAILBOX LOG Message Structures
+ */
+
+/*
+msgName: lpfc_mes0300
+message:  READ_LA: no buffers
+descript: The driver attempted to issue READ_LA mailbox command to the HBA
+          but there were no buffer available.
+data:     None
+severity: Warning
+log:      LOG_MBOX verbose
+action:   This message indicates (1) a possible lack of memory resources. Try 
+          increasing the lpfc 'num_bufs' configuration parameter to allocate 
+          more buffers. (2) A possible driver buffer management problem. If 
+          this problem persists, report these errors to Technical Support.
+*/
+char lpfc_mes0300[] = "%sREAD_LA: no buffers";
+msgLogDef lpfc_msgBlk0300 = {
+	LPFC_LOG_MSG_MB_0300,
+	lpfc_mes0300,
+	lpfc_msgPreambleMBw,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_WARN,
+	LOG_MBOX,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+
+
+
+/*
+msgName: lpfc_mes0301
+message:  READ_SPARAM: no buffers
+descript: The driver attempted to issue READ_SPARAM mailbox command to the 
+          HBA but there were no buffer available.
+data:     None
+severity: Warning
+log:      LOG_MBOX verbose
+action:   This message indicates (1) a possible lack of memory resources. Try 
+          increasing the lpfc 'num_bufs' configuration parameter to allocate 
+          more buffers. (2) A possible driver buffer management problem. If 
+          this problem persists, report these errors to Technical Support.
+*/
+char lpfc_mes0301[] = "%sREAD_SPARAM: no buffers";
+msgLogDef lpfc_msgBlk0301 = {
+	LPFC_LOG_MSG_MB_0301,
+	lpfc_mes0301,
+	lpfc_msgPreambleMBw,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_WARN,
+	LOG_MBOX,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0302
+message:  REG_LOGIN: no buffers
+descript: The driver attempted to issue REG_LOGIN mailbox command to the HBA
+          but there were no buffer available.
+data:     None
+severity: Warning
+log:      LOG_MBOX verbose
+action:   This message indicates (1) a possible lack of memory resources. Try 
+          increasing the lpfc 'num_bufs' configuration parameter to allocate 
+          more buffers. (2) A possible driver buffer management problem. If 
+          this problem persists, report these errors to Technical Support.
+*/
+char lpfc_mes0302[] = "%sREG_LOGIN: no buffers Data x%x x%x";
+msgLogDef lpfc_msgBlk0302 = {
+	LPFC_LOG_MSG_MB_0302,
+	lpfc_mes0302,
+	lpfc_msgPreambleMBw,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_WARN,
+	LOG_MBOX,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0304
+message:  Stray Mailbox Interrupt, mbxCommand <cmd> mbxStatus <status>.
+descript: Received a mailbox completion interrupt and there are no 
+          outstanding mailbox commands.
+data:     None
+severity: Error
+log:      Always
+action:   This error could indicate a hardware or firmware problem. If 
+          problems persist report these errors to Technical Support.
+*/
+char lpfc_mes0304[] = "%sStray Mailbox Interrupt mbxCommand x%x mbxStatus x%x";
+msgLogDef lpfc_msgBlk0304 = {
+	LPFC_LOG_MSG_MB_0304,
+	lpfc_mes0304,
+	lpfc_msgPreambleMBe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_MBOX | LOG_SLI,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0305
+message:  Mbox cmd cmpl error - RETRYing
+descript: A mailbox command completed with an error status that causes the 
+          driver to reissue the mailbox command.
+data:     (1) mbxCommand (2) mbxStatus (3) word1 (4) hba_state
+severity: Information
+log:      LOG_MBOX verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0305[] = "%sMbox cmd cmpl error - RETRYing Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0305 = {
+	LPFC_LOG_MSG_MB_0305,
+	lpfc_mes0305,
+	lpfc_msgPreambleMBi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_MBOX | LOG_SLI,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0306
+message:  CONFIG_LINK mbxStatus error <mbxStatus> HBA state <hba_state>
+descript: The driver issued a CONFIG_LINK mbox command to the HBA that failed.
+data:     none
+severity: Error
+log:      Always
+action:   This error could indicate a firmware or hardware
+          problem. Report these errors to Technical Support.
+*/
+char lpfc_mes0306[] = "%sCONFIG_LINK mbxStatus error x%x HBA state x%x";
+msgLogDef lpfc_msgBlk0306 = {
+	LPFC_LOG_MSG_MB_0306,
+	lpfc_mes0306,
+	lpfc_msgPreambleMBe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_MBOX,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0307
+message:  Mailbox cmd <cmd> cmpl <mbox_cmpl> <pmbox> <varWord> <varWord>
+          <varWord> <varWord> <varWord> <varWord> <varWord> <varWord>
+descript: A mailbox command completed.
+data:     none
+severity: Information
+log:      LOG_MBOX verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0307[] = "%sMailbox cmd x%x cmpl x%p, x%x x%x x%x x%x x%x x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0307 = {
+	LPFC_LOG_MSG_MB_0307,
+	lpfc_mes0307,
+	lpfc_msgPreambleMBi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_MBOX | LOG_SLI,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0308
+message:  Mbox cmd issue - BUSY
+descript: The driver attempted to issue a mailbox command while the mailbox 
+          was busy processing the previous command. The processing of the 
+          new command will be deferred until the mailbox becomes available.
+data:     (1) mbxCommand (2) hba_state (3) sli_flag (4) flag
+severity: Information
+log:      LOG_MBOX verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0308[] = "%sMbox cmd issue - BUSY Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0308 = {
+	LPFC_LOG_MSG_MB_0308,
+	lpfc_mes0308,
+	lpfc_msgPreambleMBi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_MBOX | LOG_SLI,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0309
+message:  Mailbox cmd <cmd> issue
+descript: The driver is in the process of issuing a mailbox command.
+data:     (1) hba_state (2) sli_flag (3) flag
+severity: Information
+log:      LOG_MBOX verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0309[] = "%sMailbox cmd x%x issue Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0309 = {
+	LPFC_LOG_MSG_MB_0309,
+	lpfc_mes0309,
+	lpfc_msgPreambleMBi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_MBOX | LOG_SLI,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0310
+message:  Mailbox command <cmd> timeout
+descript: A Mailbox command was posted to the adapter and did 
+          not complete within 30 seconds.
+data:     (1) hba_state (2) sli_flag (3) mbox_active
+severity: Error
+log:      Always
+action:   This error could indicate a software driver or firmware 
+          problem. If no I/O is going through the adapter, reboot 
+          the system. If these problems persist, report these 
+          errors to Technical Support.
+*/
+char lpfc_mes0310[] = "%sMailbox command x%x timeout Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0310 = {
+	LPFC_LOG_MSG_MB_0310,
+	lpfc_mes0310,
+	lpfc_msgPreambleMBe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_MBOX | LOG_SLI,
+	ERRID_LOG_TIMEOUT
+};
+
+/*
+msgName: lpfc_mes0311
+message:  Mailbox command <cmd> cannot issue
+descript: Driver is in the wrong state to issue the specified command
+data:     (1) hba_state (2) sli_flag (3) flag
+severity: Information
+log:      LOG_MBOX verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0311[] = "%sMailbox command x%x cannot issue Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0311 = {
+	LPFC_LOG_MSG_MB_0311,
+	lpfc_mes0311,
+	lpfc_msgPreambleMBi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_MBOX | LOG_SLI,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0312
+message:  Ring <ringno> handler: portRspPut <portRspPut> is bigger then rsp
+          ring <portRspMax> 
+descript: Port rsp ring put index is > size of rsp ring
+data:     None
+severity: Error
+log:      Always
+action:   This error could indicate a software driver, firmware or hardware
+          problem. Report these errors to Technical Support.
+*/
+char lpfc_mes0312[] = "%sRing %d handler: portRspPut %d is bigger then rsp ring %d";
+msgLogDef lpfc_msgBlk0312 = {
+	LPFC_LOG_MSG_MB_0312,
+	lpfc_mes0312,
+	lpfc_msgPreambleSLe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_SLI,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0313
+message:  Ring <ringno> handler: unexpected Rctl <Rctl> Type <Type> received 
+descript: The Rctl/Type of a received frame did not match any for the
+          configured masks for the specified ring.           
+data:     (1) Ring number (2) rctl (3) type
+severity: Warning
+log:      LOG_MBOX verbose
+action:   This error could indicate a software driver or firmware 
+          problem. If problems persist report these errors to 
+          Technical Support.
+*/
+char lpfc_mes0313[] ="%sRing %d handler: unexpected Rctl x%x Type x%x received ";
+msgLogDef lpfc_msgBlk0313 = {
+	LPFC_LOG_MSG_MB_0313,
+	lpfc_mes0313,
+	lpfc_msgPreambleSLw,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_WARN,
+	LOG_SLI,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0314
+message:  Ring <ringno> issue: portCmdGet <portCmdGet> is bigger then cmd ring
+          <portCmdMax> 
+descript: Port cmd ring get index is > size of cmd ring
+data:     None
+severity: Error
+log:      Always
+action:   This error could indicate a software driver, firmware or hardware
+          problem. Report these errors to Technical Support.
+*/
+char lpfc_mes0314[] =
+    "%sRing %d issue: portCmdGet %d is bigger then cmd ring %d";
+msgLogDef lpfc_msgBlk0314 = {
+	LPFC_LOG_MSG_MB_0314,
+	lpfc_mes0314,
+	lpfc_msgPreambleSLe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_SLI,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0315
+message:  Ring <ringno> issue: portCmdGet <portCmdGet> is bigger then cmd ring
+          <portCmdMax> 
+descript: Port cmd ring get index is > size of cmd ring
+data:     None
+severity: Error
+log:      Always
+action:   This error could indicate a software driver or firmware 
+          problem. If problems persist report these errors to 
+          Technical Support.
+*/
+char lpfc_mes0315[] =
+    "%sRing %d issue: portCmdGet %d is bigger then cmd ring %d";
+msgLogDef lpfc_msgBlk0315 = {
+	LPFC_LOG_MSG_MB_0315,
+	lpfc_mes0315,
+	lpfc_msgPreambleSLe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_SLI,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0316
+message:  Cmd ring <ringno> put: iotag <iotag> greater then configured max
+          <fast_iotag> wd0 <icmd>
+descript: The assigned I/O iotag is > the max allowed
+data:     None
+severity: Error
+log:      Always
+action:   This error could indicate a software driver
+          problem. If problems persist report these errors to 
+          Technical Support.
+*/
+char lpfc_mes0316[] =
+    "%sCmd ring %d put: iotag x%x greater then configured max x%x wd0 x%x";
+msgLogDef lpfc_msgBlk0316 = {
+	LPFC_LOG_MSG_MB_0316,
+	lpfc_mes0316,
+	lpfc_msgPreambleSLe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_SLI,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0317
+message:  Rsp ring <ringno> get: iotag <iotag> greater then configured
+          max <fast_iotag> wd0 <irsp>
+descript: The assigned I/O iotag is > the max allowed
+data:     None
+severity: Error
+log:      Always
+action:   This error could indicate a software driver
+          problem. If problems persist report these errors to 
+          Technical Support.
+*/
+char lpfc_mes0317[] =
+    "%sRsp ring %d get: iotag x%x greater then configured max x%x wd0 x%x";
+msgLogDef lpfc_msgBlk0317 = {
+	LPFC_LOG_MSG_MB_0317,
+	lpfc_mes0317,
+	lpfc_msgPreambleSLe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_SLI,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0318
+message:  Outstanding I/O count for ring <ringno> is at max <fast_iotag>
+descript: We cannot assign an I/O tag because none are available. Max allowed
+          I/Os are currently outstanding.
+data:     None
+severity: Information
+log:      LOG_SLI verbose
+action:   This message indicates the adapter hba I/O queue is full. 
+          Typically this happens if you are running heavy I/O on a
+          low-end (3 digit) adapter. Suggest you upgrade to our high-end
+          adapter.
+*/
+char lpfc_mes0318[] = "%sOutstanding I/O count for ring %d is at max x%x";
+msgLogDef lpfc_msgBlk0318 = {
+	LPFC_LOG_MSG_MB_0318,
+	lpfc_mes0318,
+	lpfc_msgPreambleSLi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_SLI,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0319
+descript: The driver issued a READ_SPARAM mbox command to the HBA that failed.
+data:     none
+severity: Error
+log:      Always
+action:   This error could indicate a firmware or hardware
+          problem. Report these errors to Technical Support.
+*/
+char lpfc_mes0319[] = "%sREAD_SPARAM mbxStatus error x%x hba state x%x>";
+msgLogDef lpfc_msgBlk0319 = {
+	LPFC_LOG_MSG_MB_0319,
+	lpfc_mes0319,
+	lpfc_msgPreambleMBe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_MBOX,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0320
+message:  CLEAR_LA mbxStatus error <mbxStatus> hba state <hba_state>
+descript: The driver issued a CLEAR_LA mbox command to the HBA that failed.
+data:     none
+severity: Error
+log:      Always
+action:   This error could indicate a firmware or hardware
+          problem. Report these errors to Technical Support.
+*/
+char lpfc_mes0320[] = "%sCLEAR_LA mbxStatus error x%x hba state x%x";
+msgLogDef lpfc_msgBlk0320 = {
+	LPFC_LOG_MSG_MB_0320,
+	lpfc_mes0320,
+	lpfc_msgPreambleMBe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_MBOX,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0321
+message:  Unknown IOCB command
+descript: Received an unknown IOCB command completion.
+data:     (1) ulpCommand (2) ulpStatus (3) ulpIoTag (4) ulpContext)
+severity: Error
+log:      Always
+action:   This error could indicate a software driver or firmware 
+          problem. If these problems persist, report these errors 
+          to Technical Support.
+*/
+char lpfc_mes0321[] = "%sUnknown IOCB command Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0321 = {
+	LPFC_LOG_MSG_MB_0321,
+	lpfc_mes0321,
+	lpfc_msgPreambleSLe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_SLI,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0322
+message:  Ring <ringno> handler: unexpected completion IoTag <IoTag>
+descript: The driver could not find a matching command for the completion
+          received on the specified ring.           
+data:     (1) ulpStatus (2) ulpWord[4] (3) ulpCommand (4) ulpContext
+severity: Warning
+log:      LOG_SLI verbose
+action:   This error could indicate a software driver or firmware 
+          problem. If problems persist report these errors to 
+          Technical Support.
+*/
+char lpfc_mes0322[] =
+    "%sRing %d handler: unexpected completion IoTag x%x Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0322 = {
+	LPFC_LOG_MSG_MB_0322,
+	lpfc_mes0322,
+	lpfc_msgPreambleSLw,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_WARN,
+	LOG_SLI,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0323
+message:  Unknown Mailbox command <cmd> Cmpl 
+descript: A unknown mailbox command completed.. 
+data:     (1) Mailbox Command
+severity: Error
+log:      Always
+action:   This error could indicate a software driver, firmware or hardware
+          problem. Report these errors to Technical Support.
+*/
+char lpfc_mes0323[] = "%sUnknown Mailbox command %x Cmpl";
+msgLogDef lpfc_msgBlk0323 = {
+	LPFC_LOG_MSG_MB_0323,
+	lpfc_mes0323,
+	lpfc_msgPreambleMBe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_MBOX | LOG_SLI,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0324
+message:  Adapter initialization error, mbxCmd <cmd> READ_NVPARM, mbxStatus
+          <status>
+descript: A read nvparams mailbox command failed during config port.
+data:     (1) Mailbox Command (2) Mailbox Command Status
+severity: Error
+log:      Always
+action:   This error could indicate a hardware or firmware problem. If 
+          problems persist report these errors to Technical Support.
+*/
+char lpfc_mes0324[] =
+    "%sConfig Port initialization error, mbxCmd x%x READ_NVPARM, mbxStatus x%x";
+msgLogDef lpfc_msgBlk0324 = {
+	LPFC_LOG_MSG_MB_0324,
+	lpfc_mes0324,
+	lpfc_msgPreambleMBe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_MBOX,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0325
+message:  Rsp ring <ringno> error: IOCB
+descript: Received an IOCB response error
+data:     (1) wd0 (2) wd1 (3) wd2 (4) wd3 (5) wd4 (6) wd5 (7) wd6 (8) wd7
+severity: Warning
+log:      LOG_SLI verbose
+action:   This error could indicate a software driver
+          problem. If problems persist report these errors to 
+          Technical Support.
+*/
+char lpfc_mes0325[] =
+    "%sRsp ring %d error: IOCB Data: x%x x%x x%x x%x x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0325 = {
+	LPFC_LOG_MSG_MB_0325,
+	lpfc_mes0325,
+	lpfc_msgPreambleSLw,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_WARN,
+	LOG_SLI,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0326
+message:  Reset HBA
+descript: The HBA has been reset
+data:     (1) hba_state (2) sli_flag
+severity: Information
+log:      LOG_SLI verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0326[] =
+    "%sReset HBA Data:x%x x%x";
+msgLogDef lpfc_msgBlk0326 = {
+	LPFC_LOG_MSG_MB_0326,
+	lpfc_mes0326,
+	lpfc_msgPreambleSLi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_SLI,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+ *  Begin INIT LOG Message Structures
+ */
+
+/*
+msgName: lpfc_mes0405
+message:  Service Level Interface (SLI) 2 selected
+descript: A CONFIG_PORT (SLI2) mailbox command was issued. 
+data:     None
+severity: Information
+log:      LOG_INIT verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0405[] = "%sService Level Interface (SLI) 2 selected";
+msgLogDef lpfc_msgBlk0405 = {
+	LPFC_LOG_MSG_IN_0405,
+	lpfc_mes0405,
+	lpfc_msgPreambleINi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_INIT,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0410
+message:  Cannot find virtual addr for mapped buf on ring <num>
+descript: The driver cannot find the specified buffer in its 
+          mapping table. Thus it cannot find the virtual address 
+          needed to access the data.
+data:     (1) first (2) q_first (3) q_last (4) q_cnt
+severity: Error
+log:      Always
+action:   This error could indicate a software driver or firmware 
+          problem. If problems persist report these errors to 
+          Technical Support.
+*/
+char lpfc_mes0410[] =
+    "%sCannot find virtual addr for mapped buf on ring %d Data x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0410 = {
+	LPFC_LOG_MSG_IN_0410,
+	lpfc_mes0410,
+	lpfc_msgPreambleINe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_INIT,
+	ERRID_LOG_NO_RESOURCE
+};
+
+/*
+msgName: lpfc_mes0411
+message:  fcp_bind_method is 4 with Persistent binding - ignoring
+          fcp_bind_method
+descript: The configuration parameter for fcp_bind_method conflicts with 
+          Persistent binding parameter.
+data:     (1) a_current (2) fcp_mapping
+severity: Error config
+log:      Always
+action:   Make necessary changes to lpfc configuration file.
+*/
+char lpfc_mes0411[] =
+    "%sfcp_bind_method is 4 with Persistent binding - ignoring fcp_bind_method Data: x%x x%x";
+msgLogDef lpfc_msgBlk0411 = {
+	LPFC_LOG_MSG_IN_0411,
+	lpfc_mes0411,
+	lpfc_msgPreambleINc,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR_CFG,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0412
+message:  Scan-down is out of range - ignoring scan-down
+descript: The configuration parameter for Scan-down is out of range.
+data:     (1) clp[CFG_SCAN_DOWN].a_current (2) fcp_mapping
+severity: Error
+log:      Always
+action:   Make necessary changes to lpfc configuration file.
+*/
+char lpfc_mes0412[] =
+    "%sScan-down is out of range - ignoring scan-down Data: x%x x%x";
+msgLogDef lpfc_msgBlk0412 = {
+	LPFC_LOG_MSG_IN_0412,
+	lpfc_mes0412,
+	lpfc_msgPreambleINe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0413
+message:  Configuration parameter out of range, resetting to default value
+descript: User is attempting to set a configuration parameter to a value not 
+          supported by the driver. Resetting the configuration parameter to the
+          default value.
+data:     (1) a_string (2) a_low (3) a_hi (4) a_default
+severity: Error config
+log:      Always
+action:   Make necessary changes to lpfc configuration file.
+*/
+char lpfc_mes0413[] =
+    "%sConfiguration parameter lpfc_%s out of range [%d,%d]. Using default value %d";
+msgLogDef lpfc_msgBlk0413 = {
+	LPFC_LOG_MSG_IN_0413,
+	lpfc_mes0413,
+	lpfc_msgPreambleINc,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR_CFG,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0430
+message:  WWPN binding entry <num>: Syntax error code <code>
+descript: A syntax error occured while parsing WWPN binding 
+          configuration information.
+data:     None
+detail:   Binding syntax error codes
+          0  FC_SYNTAX_OK
+          1  FC_SYNTAX_OK_BUT_NOT_THIS_BRD
+          2  FC_SYNTAX_ERR_ASC_CONVERT
+          3  FC_SYNTAX_ERR_EXP_COLON
+          4  FC_SYNTAX_ERR_EXP_LPFC
+          5  FC_SYNTAX_ERR_INV_LPFC_NUM
+          6  FC_SYNTAX_ERR_EXP_T
+          7  FC_SYNTAX_ERR_INV_TARGET_NUM
+          8  FC_SYNTAX_ERR_EXP_D
+          9  FC_SYNTAX_ERR_INV_DEVICE_NUM
+          10 FC_SYNTAX_ERR_INV_RRATIO_NUM
+          11 FC_SYNTAX_ERR_EXP_NULL_TERM
+severity: Error config
+log:      Always
+action:   Make necessary changes to lpfc configuration file.
+*/
+char lpfc_mes0430[] = "%sWWPN binding entry %d: Syntax error code %d";
+msgLogDef lpfc_msgBlk0430 = {
+	LPFC_LOG_MSG_IN_0430,
+	lpfc_mes0430,
+	lpfc_msgPreambleINc,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR_CFG,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0431
+message:  WWNN binding entry <num>: Syntax error code <code>
+descript: A syntax error occured while parsing WWNN binding 
+          configuration information.
+data:     None
+detail:   Binding syntax error codes
+          0  FC_SYNTAX_OK
+          1  FC_SYNTAX_OK_BUT_NOT_THIS_BRD
+          2  FC_SYNTAX_ERR_ASC_CONVERT
+          3  FC_SYNTAX_ERR_EXP_COLON
+          4  FC_SYNTAX_ERR_EXP_LPFC
+          5  FC_SYNTAX_ERR_INV_LPFC_NUM
+          6  FC_SYNTAX_ERR_EXP_T
+          7  FC_SYNTAX_ERR_INV_TARGET_NUM
+          8  FC_SYNTAX_ERR_EXP_D
+          9  FC_SYNTAX_ERR_INV_DEVICE_NUM
+          10 FC_SYNTAX_ERR_INV_RRATIO_NUM
+          11 FC_SYNTAX_ERR_EXP_NULL_TERM
+severity: Error config
+log:      Always
+action:   Make necessary changes to lpfc configuration file.
+*/
+char lpfc_mes0431[] = "%sWWNN binding entry %d: Syntax error code %d";
+msgLogDef lpfc_msgBlk0431 = {
+	LPFC_LOG_MSG_IN_0431,
+	lpfc_mes0431,
+	lpfc_msgPreambleINc,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR_CFG,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0432
+message:  WWPN binding entry: node table full
+descript: More bindings entries were configured than the driver can handle. 
+data:     None
+severity: Error config
+log:      Always
+action:   Make necessary changes to lpfc configuration file such that 
+          fewer bindings are configured.
+*/
+char lpfc_mes0432[] = "%sWWPN binding entry: node table full";
+msgLogDef lpfc_msgBlk0432 = {
+	LPFC_LOG_MSG_IN_0432,
+	lpfc_mes0432,
+	lpfc_msgPreambleINc,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR_CFG,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0433
+message:  WWNN binding entry: node table full
+descript: More bindings entries were configured than the driver can handle. 
+data:     None
+severity: Error config
+log:      Always
+action:   Make necessary changes to lpfc configuration file such that 
+          fewer bindings are configured.
+*/
+char lpfc_mes0433[] = "%sWWNN binding entry: node table full";
+msgLogDef lpfc_msgBlk0433 = {
+	LPFC_LOG_MSG_IN_0433,
+	lpfc_mes0433,
+	lpfc_msgPreambleINc,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR_CFG,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0434
+message:  DID binding entry <num>: Syntax error code <code>
+descript: A syntax error occured while parsing DID binding 
+          configuration information.
+data:     None
+detail:   Binding syntax error codes
+          0  FC_SYNTAX_OK
+          1  FC_SYNTAX_OK_BUT_NOT_THIS_BRD
+          2  FC_SYNTAX_ERR_ASC_CONVERT
+          3  FC_SYNTAX_ERR_EXP_COLON
+          4  FC_SYNTAX_ERR_EXP_LPFC
+          5  FC_SYNTAX_ERR_INV_LPFC_NUM
+          6  FC_SYNTAX_ERR_EXP_T
+          7  FC_SYNTAX_ERR_INV_TARGET_NUM
+          8  FC_SYNTAX_ERR_EXP_D
+          9  FC_SYNTAX_ERR_INV_DEVICE_NUM
+          10 FC_SYNTAX_ERR_INV_RRATIO_NUM
+          11 FC_SYNTAX_ERR_EXP_NULL_TERM
+severity: Error config
+log:      Always
+action:   Make necessary changes to lpfc configuration file.
+*/
+char lpfc_mes0434[] = "%sDID binding entry %d: Syntax error code %d";
+msgLogDef lpfc_msgBlk0434 = {
+	LPFC_LOG_MSG_IN_0434,
+	lpfc_mes0434,
+	lpfc_msgPreambleINc,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR_CFG,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0435
+message:  DID binding entry: node table full
+descript: More bindings entries were configured than the driver can handle. 
+data:     None
+severity: Error config
+log:      Always
+action:   Make necessary changes to lpfc configuration file such that 
+          fewer bindings are configured.
+*/
+char lpfc_mes0435[] = "%sDID binding entry: node table full";
+msgLogDef lpfc_msgBlk0435 = {
+	LPFC_LOG_MSG_IN_0435,
+	lpfc_mes0435,
+	lpfc_msgPreambleINc,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR_CFG,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0436
+message:  Adapter failed to init, timeout, status reg <status>
+descript: The adapter failed during powerup diagnostics after it was reset.
+data:     None
+severity: Error
+log:      Always
+action:   This error could indicate a hardware or firmware problem. If 
+          problems persist report these errors to Technical Support.
+*/
+char lpfc_mes0436[] = "%sAdapter failed to init, timeout, status reg x%x";
+msgLogDef lpfc_msgBlk0436 = {
+	LPFC_LOG_MSG_IN_0436,
+	lpfc_mes0436,
+	lpfc_msgPreambleINe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0437
+message:  Adapter failed to init, chipset, status reg <status>
+descript: The adapter failed during powerup diagnostics after it was reset.
+data:     None
+severity: Error
+log:      Always
+action:   This error could indicate a hardware or firmware problem. If 
+          problems persist report these errors to Technical Support.
+*/
+char lpfc_mes0437[] = "%sAdapter failed to init, chipset, status reg x%x";
+msgLogDef lpfc_msgBlk0437 = {
+	LPFC_LOG_MSG_IN_0437,
+	lpfc_mes0437,
+	lpfc_msgPreambleINe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0438
+message:  Adapter failed to init, chipset, status reg <status>
+descript: The adapter failed during powerup diagnostics after it was reset.
+data:     None
+severity: Error
+log:      Always
+action:   This error could indicate a hardware or firmware problem. If 
+          problems persist report these errors to Technical Support.
+*/
+char lpfc_mes0438[] = "%sAdapter failed to init, chipset, status reg x%x";
+msgLogDef lpfc_msgBlk0438 = {
+	LPFC_LOG_MSG_IN_0438,
+	lpfc_mes0438,
+	lpfc_msgPreambleINe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0439
+message:  Adapter failed to init, mbxCmd <cmd> READ_REV, mbxStatus <status>
+descript: Adapter initialization failed when issuing READ_REV mailbox command.
+data:     None
+severity: Error
+log:      Always
+action:   This error could indicate a hardware or firmware problem. If 
+          problems persist report these errors to Technical Support.
+*/
+char lpfc_mes0439[] =
+    "%sAdapter failed to init, mbxCmd x%x READ_REV, mbxStatus x%x";
+msgLogDef lpfc_msgBlk0439 = {
+	LPFC_LOG_MSG_IN_0439,
+	lpfc_mes0439,
+	lpfc_msgPreambleINe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0440
+message:  Adapter failed to init, mbxCmd <cmd> READ_REV detected outdated
+          firmware
+descript: Outdated firmware was detected during initialization. 
+data:     (1) read_rev_reset
+severity: Error
+log:      Always
+action:   This error could indicate a hardware or firmware problem. Update 
+          firmware. If problems persist report these errors to Technical 
+          Support.
+*/
+char lpfc_mes0440[] =
+    "%sAdapter failed to init, mbxCmd x%x READ_REV detected outdated firmware Data: x%x";
+msgLogDef lpfc_msgBlk0440 = {
+	LPFC_LOG_MSG_IN_0440,
+	lpfc_mes0440,
+	lpfc_msgPreambleINe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0441
+message:  VPD not present on adapter, mbxCmd <cmd> DUMP VPD, mbxStatus <status>
+descript: DUMP_VPD mailbox command failed.
+data:     None
+severity: Information
+log:      LOG_INIT verbose
+action:   This error could indicate a hardware or firmware problem. If 
+          problems persist report these to Technical Support.
+*/
+char lpfc_mes0441[] =
+    "%sVPD not present on adapter, mbxCmd x%x DUMP VPD, mbxStatus x%x";
+msgLogDef lpfc_msgBlk0441 = {
+	LPFC_LOG_MSG_IN_0441,
+	lpfc_mes0441,
+	lpfc_msgPreambleINi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0442
+message:  Adapter failed to init, mbxCmd <cmd> CONFIG_PORT, mbxStatus <status>
+descript: Adapter initialization failed when issuing CONFIG_PORT mailbox 
+          command.
+data:     (1) hbainit
+severity: Error
+log:      Always
+action:   This error could indicate a hardware or firmware problem. If 
+          problems persist report these errors to Technical Support.
+*/
+char lpfc_mes0442[] =
+    "%sAdapter failed to init, mbxCmd x%x CONFIG_PORT, mbxStatus x%x Data: x%x";
+msgLogDef lpfc_msgBlk0442 = {
+	LPFC_LOG_MSG_IN_0442,
+	lpfc_mes0442,
+	lpfc_msgPreambleINe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0443
+message:  Failed to attach to lpfc adapter: bus <bus> device <device> irq <irq>
+descript: An lpfc adapter was found in the pci config but the lpfc driver failed
+          to attach.
+data:     (1) bus (2) device (3) irq
+severity: Error
+log:      Always
+action:   This error could indicate a hardware or firmware problem. If 
+          problems persist report these errors to Technical Support.
+*/
+char lpfc_mes0443[] =
+    "%sFailed to attach to lpfc adapter: bus %02x device %02x irq %d";
+msgLogDef lpfc_msgBlk0443 = {
+	LPFC_LOG_MSG_IN_0443,
+	lpfc_mes0443,
+	lpfc_msgPreambleINe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0446
+message:  Adapter failed to init, mbxCmd <cmd> CFG_RING, mbxStatus <status>,
+          ring <num>
+descript: Adapter initialization failed when issuing CFG_RING mailbox command.
+data:     None
+severity: Error
+log:      Always
+action:   This error could indicate a hardware or firmware problem. If 
+          problems persist report these errors to Technical Support.
+*/
+char lpfc_mes0446[] =
+    "%sAdapter failed to init, mbxCmd x%x CFG_RING, mbxStatus x%x, ring %d";
+msgLogDef lpfc_msgBlk0446 = {
+	LPFC_LOG_MSG_IN_0446,
+	lpfc_mes0446,
+	lpfc_msgPreambleINe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0447
+message:  Adapter failed init, mbxCmd <cmd> CONFIG_LINK mbxStatus <status>
+descript: Adapter initialization failed when issuing CONFIG_LINK mailbox 
+          command.
+data:     None
+severity: Error
+log:      Always
+action:   This error could indicate a hardware or firmware problem. If 
+          problems persist report these errors to Technical Support.
+*/
+char lpfc_mes0447[] =
+    "%sAdapter failed init, mbxCmd x%x CONFIG_LINK mbxStatus x%x";
+msgLogDef lpfc_msgBlk0447 = {
+	LPFC_LOG_MSG_IN_0447,
+	lpfc_mes0447,
+	lpfc_msgPreambleINe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0448
+message:  Adapter failed to init, mbxCmd <cmd> READ_SPARM mbxStatus <status>
+descript: Adapter initialization failed when issuing READ_SPARM mailbox 
+          command.
+data:     None
+severity: Error
+log:      Always
+action:   This error could indicate a hardware or firmware problem. If 
+          problems persist report these errors to Technical Support.
+*/
+char lpfc_mes0448[] =
+    "%sAdapter failed init, mbxCmd x%x READ_SPARM mbxStatus x%x";
+msgLogDef lpfc_msgBlk0448 = {
+	LPFC_LOG_MSG_IN_0448,
+	lpfc_mes0448,
+	lpfc_msgPreambleINe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+
+/*
+msgName: lpfc_mes0451
+message:  Enable interrupt handler failed
+descript: The driver attempted to register the HBA interrupt service 
+          routine with the host operating system but failed.
+data:     None
+severity: Error
+log:      Always
+action:   This error could indicate a hardware or driver problem. If 
+          problems persist report these errors to Technical Support.
+*/
+char lpfc_mes0451[] = "%sEnable interrupt handler failed";
+msgLogDef lpfc_msgBlk0451 = {
+	LPFC_LOG_MSG_IN_0451,
+	lpfc_mes0451,
+	lpfc_msgPreambleINe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0453
+message:  Adapter failed to init, mbxCmd <cmd> READ_CONFIG, mbxStatus <status>
+descript: Adapter initialization failed when issuing READ_CONFIG mailbox 
+          command.
+data:     None
+severity: Error
+log:      Always
+action:   This error could indicate a hardware or firmware problem. If 
+          problems persist report these errors to Technical Support.
+*/
+char lpfc_mes0453[] =
+    "%sAdapter failed to init, mbxCmd x%x READ_CONFIG, mbxStatus x%x";
+msgLogDef lpfc_msgBlk0453 = {
+	LPFC_LOG_MSG_IN_0453,
+	lpfc_mes0453,
+	lpfc_msgPreambleINe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0454
+message:  Adapter failed to init, mbxCmd <cmd> INIT_LINK, mbxStatus <status>
+descript: Adapter initialization failed when issuing INIT_LINK mailbox command.
+data:     None
+severity: Error
+log:      Always
+action:   This error could indicate a hardware or firmware problem. If 
+          problems persist report these errors to Technical Support.
+*/
+char lpfc_mes0454[] =
+    "%sAdapter failed to init, mbxCmd x%x INIT_LINK, mbxStatus x%x";
+msgLogDef lpfc_msgBlk0454 = {
+	LPFC_LOG_MSG_IN_0454,
+	lpfc_mes0454,
+	lpfc_msgPreambleINe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0455
+message:  Vital Product
+descript: Vital Product Data (VPD) contained in HBA flash.
+data:     (1) vpd[0] (2) vpd[1] (3) vpd[2] (4) vpd[3]
+severity: Information
+log:      LOG_INIT verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0455[] = "%sVital Product Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0455 = {
+	LPFC_LOG_MSG_IN_0455,
+	lpfc_mes0455,
+	lpfc_msgPreambleINi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0457
+message:  Adapter Hardware Error
+descript: The driver received an interrupt indicting a possible hardware 
+          problem.
+data:     (1) status (2) status1 (3) status2
+severity: Error
+log:      Always
+action:   This error could indicate a hardware or firmware problem. If 
+          problems persist report these errors to Technical Support.
+*/
+char lpfc_mes0457[] = "%sAdapter Hardware Error Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0457 = {
+	LPFC_LOG_MSG_IN_0457,
+	lpfc_mes0457,
+	lpfc_msgPreambleINe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+msgName: lpfc_mes0458
+message:  Bring Adapter online
+descript: The FC driver has received a request to bring the adapter 
+          online. This may occur when running lputil.
+data:     None
+severity: Warning
+log:      LOG_INIT verbose
+action:   None required
+*/
+char lpfc_mes0458[] = "%sBring Adapter online";
+msgLogDef lpfc_msgBlk0458 = {
+	LPFC_LOG_MSG_IN_0458,
+	lpfc_mes0458,
+	lpfc_msgPreambleINw,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_WARN,
+	LOG_INIT,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0460
+message:  Bring Adapter offline
+descript: The FC driver has received a request to bring the adapter 
+          offline. This may occur when running lputil.
+data:     None
+severity: Warning
+log:      LOG_INIT verbose
+action:   None required
+*/
+char lpfc_mes0460[] = "%sBring Adapter offline";
+msgLogDef lpfc_msgBlk0460 = {
+	LPFC_LOG_MSG_IN_0460,
+	lpfc_mes0460,
+	lpfc_msgPreambleINw,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_WARN,
+	LOG_INIT,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0462
+message:  Too many cmd / rsp ring entries in SLI2 SLIM
+descript: The configuration parameter for Scan-down is out of range.
+data:     (1) totiocb (2) MAX_SLI2_IOCB
+severity: Error
+log:      Always
+action:   Software driver error.
+          If this problem persists, report these errors to Technical Support.
+*/
+char lpfc_mes0462[] =
+    "%sToo many cmd / rsp ring entries in SLI2 SLIM Data: x%x x%x";
+msgLogDef lpfc_msgBlk0462 = {
+	LPFC_LOG_MSG_IN_0462,
+	lpfc_mes0462,
+	lpfc_msgPreambleINe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_INIT,
+	ERRID_LOG_INIT
+};
+
+/*
+ *  Begin IP LOG Message Structures
+ */
+
+/*
+msgName: lpfc_mes0600
+message:  FARP-RSP received from DID <did>.
+descript: A FARP ELS command response was received.
+data:     None
+severity: Information
+log:      LOG_IP verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0600[] = "%sFARP-RSP received from DID x%x";
+msgLogDef lpfc_msgBlk0600 = {
+	LPFC_LOG_MSG_IP_0600,
+	lpfc_mes0600,
+	lpfc_msgPreambleIPi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_IP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0601
+message:  FARP-REQ received from DID <did>
+descript: A FARP ELS command request was received.
+data:     None
+severity: Information
+log:      LOG_IP verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0601[] = "%sFARP-REQ received from DID x%x";
+msgLogDef lpfc_msgBlk0601 = {
+	LPFC_LOG_MSG_IP_0601,
+	lpfc_mes0601,
+	lpfc_msgPreambleIPi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_IP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+
+/*
+msgName: lpfc_mes0610
+message:  FARP Request sent to remote DID
+descript: A send to a remote IP address has no node in the driver's nodelists.
+          Send a FARP request to obtain the node's HW address.
+data:     (1) IEEE[0] (2) IEEE[1] (3) IEEE[2] (4) IEEE[3] (5) IEEE[4]
+          (6) IEEE[5] 
+severity: Information
+log:      LOG_IP verbose
+action:   Issue FARP and wait for PLOGI from remote node.
+*/
+char lpfc_mes0610[] =
+    "%sFARP Request sent to remote HW Address %02x-%02x-%02x-%02x-%02x-%02x";
+msgLogDef lpfc_msgBlk0610 = {
+	LPFC_LOG_MSG_IP_0610,
+	lpfc_mes0610,
+	lpfc_msgPreambleIPi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_IP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+ *  Begin FCP LOG Message Structures
+ */
+
+/*
+msgName: lpfc_mes0701
+message:  Issue Abort Task Set to TGT <num> LUN <num>
+descript: The SCSI layer detected that it needs to abort all I/O 
+          to a specific device. This results in an FCP Task 
+          Management command to abort the I/O in progress. 
+data:     (1) scsi_id (2) lun_id (1) (3) rpi (4) flags
+severity: Information
+log:      LOG_FCP verbose
+action:   Check state of device in question. 
+*/
+char lpfc_mes0701[] = "%sIssue Abort Task Set to TGT x%x LUN x%llx Data: x%x x%x";
+msgLogDef lpfc_msgBlk0701 = {
+	LPFC_LOG_MSG_FP_0701,
+	lpfc_mes0701,
+	lpfc_msgPreambleFPi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0702
+message:  Issue Target Reset to TGT <num>
+descript: The SCSI layer detected that it needs to abort all I/O 
+          to a specific target. This results in an FCP Task 
+          Management command to abort the I/O in progress. 
+data:     (1) rpi (2) flags
+severity: Information
+log:      LOG_FCP verbose
+action:   Check state of target in question. 
+*/
+char lpfc_mes0702[] = "%sIssue Target Reset to TGT %d Data: x%x x%x";
+msgLogDef lpfc_msgBlk0702 = {
+	LPFC_LOG_MSG_FP_0702,
+	lpfc_mes0702,
+	lpfc_msgPreambleFPi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0703
+message:  Issue LUN Reset to TGT <num> LUN <num>
+descript: The SCSI layer detected that it needs to abort all I/O 
+          to a specific device. This results in an FCP Task 
+          Management command to abort the I/O in progress. 
+data:     (1) scsi_id (2) lun_id (3) rpi (4) flags
+severity: Information
+log:      LOG_FCP verbose
+action:   Check state of device in question. 
+*/
+char lpfc_mes0703[] = "%sIssue LUN Reset to TGT x%x LUN x%llx Data: x%x x%x";
+msgLogDef lpfc_msgBlk0703 = {
+	LPFC_LOG_MSG_FP_0703,
+	lpfc_mes0703,
+	lpfc_msgPreambleFPi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0712
+message:  SCSI layer issued abort device
+descript: The SCSI layer is requesting the driver to abort 
+          I/O to a specific device.
+data:     (1) target (2) lun (3)
+severity: Error
+log:      Always
+action:   Check state of device in question.
+*/
+char lpfc_mes0712[] = "%sSCSI layer issued abort device Data: x%x x%llx";
+msgLogDef lpfc_msgBlk0712 = {
+	LPFC_LOG_MSG_FP_0712,
+	lpfc_mes0712,
+	lpfc_msgPreambleFPe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0713
+message:  SCSI layer issued Target Reset
+descript: The SCSI layer is requesting the driver to abort 
+          I/O to a specific target.
+data:     (1) target (2) lun 
+severity: Error
+log:      Always
+action:   Check state of target in question.
+*/
+char lpfc_mes0713[] = "%sSCSI layer issued Target Reset Data: x%x x%llx";
+msgLogDef lpfc_msgBlk0713 = {
+	LPFC_LOG_MSG_FP_0713,
+	lpfc_mes0713,
+	lpfc_msgPreambleFPe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0714
+message:  SCSI layer issued Bus Reset
+descript: The SCSI layer is requesting the driver to abort 
+          all I/Os to all targets on this HBA.
+data:     (1) tgt (2) lun (3) rc - success / failure
+severity: Error
+log:      Always
+action:   Check state of targets in question.
+*/
+char lpfc_mes0714[] = "%sSCSI layer issued Bus Reset Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0714 = {
+	LPFC_LOG_MSG_FP_0714,
+	lpfc_mes0714,
+	lpfc_msgPreambleFPe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0716
+message:  FCP Read Underrun, expected <len>, residual <resid>
+descript: FCP device provided less data than was requested.
+data:     (1) fcpi_parm (2) cmnd[0] (3) underflow 
+severity: Information
+log:      LOG_FCP verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0716[] =
+    "%sFCP Read Underrun, expected %d, residual %d Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0716 = {
+	LPFC_LOG_MSG_FP_0716,
+	lpfc_mes0716,
+	lpfc_msgPreambleFPi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0717
+message:  FCP command <cmd> residual underrun converted to error
+descript: The driver convert this underrun condition to an error based 
+          on the underflow field in the SCSI cmnd.
+data:     (1) len (2) resid (3) underflow
+severity: Information
+log:      LOG_FCP verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0717[] =
+    "%sFCP command x%x residual underrun converted to error Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0717 = {
+	LPFC_LOG_MSG_FP_0717,
+	lpfc_mes0717,
+	lpfc_msgPreambleFPi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0729
+message:  FCP cmd <cmnd> failed <target>/<lun>
+descript: The specifed device failed an FCP command. 
+data:     (1) cmnd (2) scsi_id (3) lun_id (4) status (5) result (6) xri (7) iotag
+severity: Warning
+log:      LOG_FCP verbose
+action:   Check the state of the target in question.
+*/
+char lpfc_mes0729[] =
+    "%sFCP cmd x%x failed, x%x x%llx, status: x%x result: x%x Data: x%x x%x";
+msgLogDef lpfc_msgBlk0729 = {
+	LPFC_LOG_MSG_FP_0729,
+	lpfc_mes0729,
+	lpfc_msgPreambleFPw,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_WARN,
+	LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0730
+message:  FCP command failed: RSP
+descript: The FCP command failed with a response error.
+data:     (1) Status2 (2) Status3 (3) ResId (4) SnsLen (5) RspLen (6) Info3
+severity: Warning
+log:      LOG_FCP verbose
+action:   Check the state of the target in question.
+*/
+char lpfc_mes0730[] = "%sFCP command failed: RSP Data: x%x x%x x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0730 = {
+	LPFC_LOG_MSG_FP_0730,
+	lpfc_mes0730,
+	lpfc_msgPreambleFPw,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_WARN,
+	LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0734
+message:  FCP Read Check Error
+descript: The issued FCP command returned a Read Check Error
+data:     (1) fcpDl (2) rspResId (3) fcpi_parm (4) cdb[0]
+severity: Warning
+log:      LOG_FCP verbose
+action:   Check the state of the target in question.
+*/
+char lpfc_mes0734[] = "%sFCP Read Check Error Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0734 = {
+	LPFC_LOG_MSG_FP_0734,
+	lpfc_mes0734,
+	lpfc_msgPreambleFPw,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_WARN,
+	LOG_FCP,
+	ERRID_LOG_HDW_ERR
+};
+
+/*
+msgName: lpfc_mes0735
+message:  FCP Read Check Error with Check Condition
+descript: The issued FCP command returned a Read Check Error and a 
+          Check condition.
+data:     (1) fcpDl (2) rspResId (3) fcpi_parm (4) cdb[0]
+severity: Warning
+log:      LOG_FCP verbose
+action:   Check the state of the target in question.
+*/
+char lpfc_mes0735[] =
+    "%sFCP Read Check Error with Check Condition Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0735 = {
+	LPFC_LOG_MSG_FP_0735,
+	lpfc_mes0735,
+	lpfc_msgPreambleFPw,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_WARN,
+	LOG_FCP | LOG_CHK_COND,
+	ERRID_LOG_HDW_ERR
+};
+
+/*
+msgName: lpfc_mes0737
+message:  <ASC ASCQ> Check condition received
+descript: The issued FCP command resulted in a Check Condition.
+data:     (1) CFG_CHK_COND_ERR (2) CFG_DELAY_RSP_ERR (3) *lp
+severity: Information
+log:      LOG_FCP | LOG_CHK_COND verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0737[] = "%sx%x Check condition received Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0737 = {
+	LPFC_LOG_MSG_FP_0737,
+	lpfc_mes0737,
+	lpfc_msgPreambleFPi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_FCP | LOG_CHK_COND,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0738
+message:  Scheduler received Queue Full status from FCP device <tgt> <lun>.
+descript: Scheduler received a Queue Full error status from specified FCP
+          device.
+data:     (1) qfull_retry_count (2) qfull_retries (3) currentOutstanding
+          (4) maxOutstanding
+severity: Information
+log:      LOG_FCP verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0738[] =
+    "%sScheduler received Queue Full status from FCP device %d %d Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0738 = {
+	LPFC_LOG_MSG_FP_0738,
+	lpfc_mes0738,
+	lpfc_msgPreambleFPi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0747
+message:  Cmpl Target Reset
+descript: Target Reset completed.
+data:     (1) scsi_id (2) lun_id (3) Error (4) statLocalError (5) *cmd + WD7
+severity: Information
+log:      LOG_FCP verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0747[] = "%sCmpl Target Reset Data: x%x x%llx x%x x%x x%x"; 
+msgLogDef lpfc_msgBlk0747 = {
+	LPFC_LOG_MSG_FP_0747,
+	lpfc_mes0747,
+	lpfc_msgPreambleFPi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0748
+message:  Cmpl LUN Reset
+descript: LUN Reset completed.
+data:     (1) scsi_id (2) lun_id (3) Error (4) statLocalError (5) *cmd + WD7
+severity: Information
+log:      LOG_FCP verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0748[] = "%sCmpl LUN Reset Data: x%x x%llx x%x x%x x%x"; 
+msgLogDef lpfc_msgBlk0748 = {
+	LPFC_LOG_MSG_FP_0748,
+	lpfc_mes0748,
+	lpfc_msgPreambleFPi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0749
+message:  Cmpl Abort Task Set
+descript: Abort Task Set completed.
+data:     (1) scsi_id (2) lun_id (3) Error (4) statLocalError (5) *cmd + WD7
+severity: Information
+log:      LOG_FCP verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0749[] = "%sCmpl Abort Task Set Data: x%x x%llx x%x x%x x%x"; 
+msgLogDef lpfc_msgBlk0749 = {
+	LPFC_LOG_MSG_FP_0749,
+	lpfc_mes0749,
+	lpfc_msgPreambleFPi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_FCP,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0754
+message:  SCSI timeout
+descript: An FCP IOCB command was posted to a ring and did not complete 
+          within ULP timeout seconds.
+data:     (1) did (2) sid (3) command (4) iotag
+severity: Error
+log:      Always
+action:   If no I/O is going through the adapter, reboot the system; 
+          If problem persists, contact Technical Support.
+*/
+char lpfc_mes0754[] = "%sSCSI timeout Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0754 = {
+	LPFC_LOG_MSG_FP_0754,
+	lpfc_mes0754,
+	lpfc_msgPreambleFPe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_FCP,
+	ERRID_LOG_TIMEOUT
+};
+
+/*
+ *  Begin NODE LOG Message Structures
+ */
+
+/*
+msgName: lpfc_mes0900
+message:  Cleanup node for NPort <nlp_DID>
+descript: The driver node table entry for a remote NPort was removed.
+data:     (1) nlp_flag (2) nlp_state (3) nlp_rpi
+severity: Information
+log:      LOG_NODE verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0900[] = "%sCleanup node for NPort x%x Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk0900 = {
+	LPFC_LOG_MSG_ND_0900,
+	lpfc_mes0900,
+	lpfc_msgPreambleNDi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_NODE,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0901
+message:  FIND node DID mapped
+descript: The driver is searching for a node table entry, on the 
+          mapped node list, based on DID.
+data:     (1) nlp (2) nlp_DID (3) nlp_flag (4) data1
+severity: Information
+log:      LOG_NODE verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0901[] = "%sFIND node DID mapped Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0901 = {
+	LPFC_LOG_MSG_ND_0901,
+	lpfc_mes0901,
+	lpfc_msgPreambleNDi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_NODE,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0902
+message:  FIND node DID mapped
+descript: The driver is searching for a node table entry, on the 
+          mapped node list, based on DID.
+data:     (1) nlp (2) nlp_DID (3) nlp_flag (4) data1
+severity: Information
+log:      LOG_NODE verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0902[] = "%sFIND node DID mapped Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0902 = {
+	LPFC_LOG_MSG_ND_0902,
+	lpfc_mes0902,
+	lpfc_msgPreambleNDi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_NODE,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0903
+message:  Add scsiid <sid> to BIND list 
+descript: The driver is putting the node table entry on the binding list.
+data:     (1) bind_cnt (2) nlp_DID (3) bind_type (4) blp
+severity: Information
+log:      LOG_NODE verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0903[] = "%sAdd scsiid %d to BIND list Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0903 = {
+	LPFC_LOG_MSG_ND_0903,
+	lpfc_mes0903,
+	lpfc_msgPreambleNDi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_NODE,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0904
+message:  Add NPort <did> to PLOGI list
+descript: The driver is putting the node table entry on the plogi list.
+data:     (1) plogi_cnt (2) blp
+severity: Information
+log:      LOG_NODE verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0904[] = "%sAdd NPort x%x to PLOGI list Data: x%x x%x";
+msgLogDef lpfc_msgBlk0904 = {
+	LPFC_LOG_MSG_ND_0904,
+	lpfc_mes0904,
+	lpfc_msgPreambleNDi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_NODE,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0905
+message:  Add NPort <did> to ADISC list
+descript: The driver is putting the node table entry on the adisc list.
+data:     (1) adisc_cnt (2) blp
+severity: Information
+log:      LOG_NODE verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0905[] = "%sAdd NPort x%x to ADISC list Data: x%x x%x";
+msgLogDef lpfc_msgBlk0905 = {
+	LPFC_LOG_MSG_ND_0905,
+	lpfc_mes0905,
+	lpfc_msgPreambleNDi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_NODE,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0906
+message:  Add NPort <did> to UNMAP list
+descript: The driver is putting the node table entry on the unmap list.
+data:     (1) unmap_cnt (2) blp
+severity: Information
+log:      LOG_NODE verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0906[] = "%sAdd NPort x%x to UNMAP list Data: x%x x%x";
+msgLogDef lpfc_msgBlk0906 = {
+	LPFC_LOG_MSG_ND_0906,
+	lpfc_mes0906,
+	lpfc_msgPreambleNDi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_NODE,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0907
+message:  Add NPort <did> to MAP list scsiid <sid>
+descript: The driver is putting the node table entry on the mapped list.
+data:     (1) map_cnt (2) blp
+severity: Information
+log:      LOG_NODE verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0907[] = "%sAdd NPort x%x to MAP list scsiid %d Data: x%x x%x";
+msgLogDef lpfc_msgBlk0907 = {
+	LPFC_LOG_MSG_ND_0907,
+	lpfc_mes0907,
+	lpfc_msgPreambleNDi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_NODE,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0908
+message:  FIND node DID bind
+descript: The driver is searching for a node table entry, on the 
+          binding list, based on DID.
+data:     (1) nlp (2) nlp_DID (3) nlp_flag (4) data1
+severity: Information
+log:      LOG_NODE verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0908[] = "%sFIND node DID bind Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0908 = {
+	LPFC_LOG_MSG_ND_0908,
+	lpfc_mes0908,
+	lpfc_msgPreambleNDi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_NODE,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0910
+message:  FIND node DID unmapped
+descript: The driver is searching for a node table entry, on the 
+          unmapped node list, based on DID.
+data:     (1) nlp (2) nlp_DID (3) nlp_flag (4) data1
+severity: Information
+log:      LOG_NODE verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0910[] = "%sFIND node DID unmapped Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0910 = {
+	LPFC_LOG_MSG_ND_0910,
+	lpfc_mes0910,
+	lpfc_msgPreambleNDi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_NODE,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0911
+message:  FIND node DID unmapped
+descript: The driver is searching for a node table entry, on the 
+          unmapped node list, based on DID.
+data:     (1) nlp (2) nlp_DID (3) nlp_flag (4) data1
+severity: Information
+log:      LOG_NODE verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0911[] = "%sFIND node DID unmapped Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0911 = {
+	LPFC_LOG_MSG_ND_0911,
+	lpfc_mes0911,
+	lpfc_msgPreambleNDi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_NODE,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0929
+message:  FIND node DID unmapped
+descript: The driver is searching for a node table entry, on the 
+          unmapped node list, based on DID.
+data:     (1) nlp (2) nlp_DID (3) nlp_flag (4) data1
+severity: Information
+log:      LOG_NODE verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0929[] = "%sFIND node DID unmapped Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0929 = {
+	LPFC_LOG_MSG_ND_0929,
+	lpfc_mes0929,
+	lpfc_msgPreambleNDi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_NODE,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0930
+message:  FIND node DID mapped
+descript: The driver is searching for a node table entry, on the 
+          mapped node list, based on DID.
+data:     (1) nlp (2) nlp_DID (3) nlp_flag (4) data1
+severity: Information
+log:      LOG_NODE verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0930[] = "%sFIND node DID mapped Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0930 = {
+	LPFC_LOG_MSG_ND_0930,
+	lpfc_mes0930,
+	lpfc_msgPreambleNDi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_NODE,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0931
+message:  FIND node DID bind
+descript: The driver is searching for a node table entry, on the 
+          binding list, based on DID.
+data:     (1) nlp (2) nlp_DID (3) nlp_flag (4) data1
+severity: Information
+log:      LOG_NODE verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0931[] = "%sFIND node DID bind Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk0931 = {
+	LPFC_LOG_MSG_ND_0931,
+	lpfc_mes0931,
+	lpfc_msgPreambleNDi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_NODE,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes0932
+message:  FIND node did <did> NOT FOUND
+descript: The driver was searching for a node table entry based on DID 
+          and the entry was not found.
+data:     (1) order
+severity: Information
+log:      LOG_NODE verbose
+action:   No action needed, informational
+*/
+char lpfc_mes0932[] = "%sFIND node did x%x NOT FOUND Data: x%x";
+msgLogDef lpfc_msgBlk0932 = {
+	LPFC_LOG_MSG_ND_0932,
+	lpfc_mes0932,
+	lpfc_msgPreambleNDi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_NODE,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+ *  Begin MISC LOG message structures
+ */
+
+/*
+msgName: lpfc_mes1208
+descript: The CT response returned more data than the user buffer could hold. 
+message:  C_CT Request error
+data:     (1) dfc_flag (2) 4096
+severity: Information
+log:      LOG_MISC verbose
+action:   Modify user application issuing CT request to allow for a larger 
+          response buffer.
+*/
+char lpfc_mes1208[] = "%sC_CT Request error Data: x%x x%x";
+msgLogDef lpfc_msgBlk1208 = {
+	LPFC_LOG_MSG_MI_1208,
+	lpfc_mes1208,
+	lpfc_msgPreambleMIi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_MISC,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes1210
+message:  Convert ASC to hex. Input byte cnt < 1
+descript: ASCII string to hex conversion failed. Input byte count < 1.
+data:     none
+severity: Error
+log:      Always
+action:   This error could indicate a software driver problem. 
+          If problems persist report these errors to Technical Support.
+*/
+char lpfc_mes1210[] = "%sConvert ASC to hex. Input byte cnt < 1";
+msgLogDef lpfc_msgBlk1210 = {
+	LPFC_LOG_MSG_MI_1210,
+	lpfc_mes1210,
+	lpfc_msgPreambleMIe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_MISC,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes1212
+message:  Convert ASC to hex. Output buffer to small 
+descript: ASCII string to hex conversion failed. The output buffer byte 
+          size is less than 1/2 of input byte count. Every 2 input chars 
+          (bytes) require 1 output byte.
+data:     none
+severity: Error
+log:      Always
+action:   This error could indicate a software driver problem. 
+          If problems persist report these errors to Technical Support.
+*/
+char lpfc_mes1212[] = "%sConvert ASC to hex. Output buffer too small";
+msgLogDef lpfc_msgBlk1212 = {
+	LPFC_LOG_MSG_MI_1212,
+	lpfc_mes1212,
+	lpfc_msgPreambleMIe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_MISC,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes1213
+message:  Convert ASC to hex. Input char seq not ASC hex.
+descript: The ASCII hex input string contains a non-ASCII hex characters
+data:     none
+severity: Error configuration
+log:      Always
+action:   Make necessary changes to lpfc configuration file.
+*/
+char lpfc_mes1213[] = "%sConvert ASC to hex. Input char seq not ASC hex.";
+msgLogDef lpfc_msgBlk1213 = {
+	LPFC_LOG_MSG_MI_1213,
+	lpfc_mes1213,
+	lpfc_msgPreambleMIc,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR_CFG,
+	LOG_MISC,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+ *  Begin LINK LOG Message Structures
+ */
+
+/*
+msgName: lpfc_mes1300
+message:  Re-establishing Link, timer expired
+descript: The driver detected a condition where it had to re-initialize 
+          the link.
+data:     (1) fc_flag (2) fc_ffstate
+severity: Error
+log:      Always
+action:   If numerous link events are occurring, check physical 
+          connections to Fibre Channel network.
+*/
+char lpfc_mes1300[] = "%sRe-establishing Link, timer expired Data: x%x x%x";
+msgLogDef lpfc_msgBlk1300 = {
+	LPFC_LOG_MSG_LK_1300,
+	lpfc_mes1300,
+	lpfc_msgPreambleLKe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_LINK_EVENT,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes1301
+message:  Re-establishing Link
+descript: The driver detected a condition where it had to re-initialize 
+          the link.
+data:     (1) status (2) status1 (3) status2
+severity: Information
+log:      LOG_LINK_EVENT verbose
+action:   If numerous link events are occurring, check physical 
+          connections to Fibre Channel network.
+*/
+char lpfc_mes1301[] = "%sRe-establishing Link Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk1301 = {
+	LPFC_LOG_MSG_LK_1301,
+	lpfc_mes1301,
+	lpfc_msgPreambleLKi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_LINK_EVENT,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes1302
+message:  Reset link speed to auto. 1G HBA cfg'd for 2G
+descript: The driver is reinitializing the link speed to auto-detect.
+data:     (1) current link speed
+severity: Warning
+log:      LOG_LINK_EVENT verbose
+action:   None required
+*/
+char lpfc_mes1302[] =
+    "%s Invalid speed for this board: Reset link speed to auto: x%x";
+msgLogDef lpfc_msgBlk1302 = {
+	LPFC_LOG_MSG_LK_1302,
+	lpfc_mes1302,
+	lpfc_msgPreambleLKw,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_WARN,
+	LOG_LINK_EVENT,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes1303
+message:  Link Up Event <eventTag> received
+descript: A link up event was received. It is also possible for 
+          multiple link events to be received together. 
+data:     (1) fc_eventTag (2) granted_AL_PA (3) UlnkSpeed (4) alpa_map[0]
+detail:   If link events received, log (1) last event number 
+          received, (2) ALPA granted, (3) Link speed 
+          (4) number of entries in the loop init LILP ALPA map. 
+          An ALPA map message is also recorded if LINK_EVENT 
+          verbose mode is set. Each ALPA map message contains 
+          16 ALPAs. 
+severity: Error
+log:      Always
+action:   If numerous link events are occurring, check physical 
+          connections to Fibre Channel network.
+*/
+char lpfc_mes1303[] = "%sLink Up Event x%x received Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk1303 = {
+	LPFC_LOG_MSG_LK_1303,
+	lpfc_mes1303,
+	lpfc_msgPreambleLKe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_LINK_EVENT,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes1304
+message:  Link Up Event ALPA map
+descript: A link up event was received.
+data:     (1) wd1 (2) wd2 (3) wd3 (4) wd4
+severity: Warning
+log:      LOG_LINK_EVENT verbose
+action:   If numerous link events are occurring, check physical 
+          connections to Fibre Channel network.
+*/
+char lpfc_mes1304[] = "%sLink Up Event ALPA map Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk1304 = {
+	LPFC_LOG_MSG_LK_1304,
+	lpfc_mes1304,
+	lpfc_msgPreambleLKw,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_WARN,
+	LOG_LINK_EVENT,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes1305
+message:  Link Down Event <eventTag> received
+descript: A link down event was received.
+data:     (1) fc_eventTag (2) hba_state (3) fc_flag
+severity: Error
+log:      Always
+action:   If numerous link events are occurring, check physical 
+          connections to Fibre Channel network.
+*/
+char lpfc_mes1305[] = "%sLink Down Event x%x received Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk1305 = {
+	LPFC_LOG_MSG_LK_1305,
+	lpfc_mes1305,
+	lpfc_msgPreambleLKe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_LINK_EVENT,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes1306
+message:  Link Down timeout
+descript: The link was down for greater than the configuration parameter 
+          (lpfc_linkdown_tmo) seconds. All I/O associated with the devices
+          on this link will be failed.  
+data:     (1) hba_state (2) fc_flag (3) fc_ns_retry
+severity: Warning
+log:      LOG_LINK_EVENT | LOG_DISCOVERY verbose
+action:   Check HBA cable/connection to Fibre Channel network.
+*/
+char lpfc_mes1306[] = "%sLink Down timeout Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk1306 = {
+	LPFC_LOG_MSG_LK_1306,
+	lpfc_mes1306,
+	lpfc_msgPreambleLKw,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_WARN,
+	LOG_LINK_EVENT | LOG_DISCOVERY,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes1307
+message:  READ_LA mbox error <mbxStatus> state <hba_state>
+descript: The driver cannot determine what type of link event occurred.
+data:     None
+severity: Information
+log:      LOG_LINK_EVENT verbose
+action:   If numerous link events are occurring, check physical 
+          connections to Fibre Channel network. Could indicate
+          possible hardware or firmware problem.
+*/
+char lpfc_mes1307[] = "%sREAD_LA mbox error x%x state x%x";
+msgLogDef lpfc_msgBlk1307 = {
+	LPFC_LOG_MSG_LK_1307,
+	lpfc_mes1307,
+	lpfc_msgPreambleLKi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_LINK_EVENT,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+ *  Begin XXX LOG Message Structures
+ */
+
+/*
+ *  Begin Libdfc Message Structures
+ */
+
+/*
+msgName: lpfc_mes1600
+message:  libdfc debug entry
+descript: Entry point for processing debug diagnostic routines 
+data:     (1) c_cmd (2) c_arg1 (3) c_arg2 (4) c_outsz
+severity: Information
+log:      LOG_LIBDFC verbose
+action:   No action needed, informational
+*/
+char lpfc_mes1600[] = "%slibdfc debug entry Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk1600 = {
+	LPFC_LOG_MSG_IO_1600,
+	lpfc_mes1600,
+	lpfc_msgPreambleLDi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_LIBDFC,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes1601
+message:  libdfc debug exit
+descript: Exit point for processing debug diagnostic routines
+data:     (1) rc (2) c_outsz (3) c_dataout
+severity: Information
+log:      LOG_LIBDFC verbose
+action:   No action needed, informational
+*/
+char lpfc_mes1601[] = "%slibdfc debug exit Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk1601 = {
+	LPFC_LOG_MSG_IO_1601,
+	lpfc_mes1601,
+	lpfc_msgPreambleLDi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_LIBDFC,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes1602
+message:  libdfc hbaapi entry
+descript: Entry point for processing hbaapi diagnostic routines 
+data:     (1) c_cmd (2) c_arg1 (3) c_arg2 (4) c_outsz
+severity: Information
+log:      LOG_LIBDFC verbose
+action:   No action needed, informational
+*/
+char lpfc_mes1602[] = "%slibdfc hbaapi entry Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk1602 = {
+	LPFC_LOG_MSG_IO_1602,
+	lpfc_mes1602,
+	lpfc_msgPreambleLDi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_LIBDFC,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes1603
+message:  libdfc hbaapi exit
+descript: Exit point for processing hbaapi diagnostic routines
+data:     (1) rc (2) c_outsz (3) c_dataout
+severity: Information
+log:      LOG_LIBDFC verbose
+action:   No action needed, informational
+*/
+char lpfc_mes1603[] = "%slibdfc hbaapi exit Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk1603 = {
+	LPFC_LOG_MSG_IO_1603,
+	lpfc_mes1603,
+	lpfc_msgPreambleLDi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_LIBDFC,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes1604
+message:  libdfc:error
+descript: SCSI send request buffer size limited exceeded
+data:     (1) error number index
+severity: Error
+log:      Always
+action:   Reduce application program's SCSI send request buffer size to < 320K
+          bytes.  
+*/
+char lpfc_mes1604[] = "%slibdfc error Data: %d";
+msgLogDef lpfc_msgBlk1604 = {
+	LPFC_LOG_MSG_IO_1604,
+	lpfc_mes1604,
+	lpfc_msgPreambleLDe,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_ERR,
+	LOG_LIBDFC,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes1606
+message:  libdfc util entry
+descript: Entry point for processing util diagnostic routines 
+data:     (1) c_cmd (2) c_arg1 (3) c_arg2 (4) c_outsz
+severity: Information
+log:      LOG_LIBDFC verbose
+action:   No action needed, informational
+*/
+char lpfc_mes1606[] = "%slibdfc util entry Data: x%x x%x x%x x%x";
+msgLogDef lpfc_msgBlk1606 = {
+	LPFC_LOG_MSG_IO_1606,
+	lpfc_mes1606,
+	lpfc_msgPreambleLDi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_LIBDFC,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
+/*
+msgName: lpfc_mes1607
+message:  libdfc util exit
+descript: Exit point for processing util diagnostic routines
+data:     (1) rc (2) c_outsz (3) c_dataout
+severity: Information
+log:      LOG_LIBDFC verbose
+action:   No action needed, informational
+*/
+char lpfc_mes1607[] = "%slibdfc util exit Data: x%x x%x x%x";
+msgLogDef lpfc_msgBlk1607 = {
+	LPFC_LOG_MSG_IO_1607,
+	lpfc_mes1607,
+	lpfc_msgPreambleLDi,
+	LPFC_MSG_OPUT_GLOB_CTRL,
+	LPFC_LOG_MSG_TYPE_INFO,
+	LOG_LIBDFC,
+	ERRID_LOG_UNEXPECT_EVENT
+};
+
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_logmsg.h linux-8155/drivers/addon/lpfc/lpfc_logmsg.h
--- linux-8152/drivers/addon/lpfc/lpfc_logmsg.h
+++ linux-8155/drivers/addon/lpfc/lpfc_logmsg.h
@@ -0,0 +1,770 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_logmsg.h 369 2005-07-08 23:29:48Z sf_support $
+ */
+
+#ifndef _H_LPFC_LOGMSG
+#define _H_LPFC_LOGMSG
+
+/*
+ * Log Message Structure
+ *
+ * The following structure supports LOG messages only.
+ * Every LOG message is associated to a msgBlkLogDef structure of the 
+ * following type.
+ */
+
+typedef struct msgLogType {
+	int msgNum;		/* Message number */
+	char *msgStr;		/* Ptr to log message */
+	char *msgPreambleStr;	/* Ptr to log message preamble */
+	int msgOutput;		/* Message output target - bitmap */
+	/*
+	 * This member controls message OUTPUT.
+	 *
+	 * The phase 'global controls' refers to user configurable parameters
+	 * such as LOG_VERBOSE that control message output on a global basis.
+	 */
+
+#define LPFC_MSG_OPUT_GLOB_CTRL         0x0	/* Use global control */
+#define LPFC_MSG_OPUT_DISA              0x1	/* Override global control */
+#define LPFC_MSG_OPUT_FORCE             0x2	/* Override global control */
+	int msgType;		/* Message LOG type - bitmap */
+#define LPFC_LOG_MSG_TYPE_INFO          0x1	/* Maskable */
+#define LPFC_LOG_MSG_TYPE_WARN          0x2	/* Non-Maskable */
+#define LPFC_LOG_MSG_TYPE_ERR_CFG       0x4	/* Non-Maskable */
+#define LPFC_LOG_MSG_TYPE_ERR           0x8	/* Non-Maskable */
+#define LPFC_LOG_MSG_TYPE_PANIC        0x10	/* Non-Maskable */
+	int msgMask;		/* Message LOG mask - bitmap */
+	/*
+	 * NOTE: Only LOG messages of types MSG_TYPE_WARN & MSG_TYPE_INFO are 
+	 * maskable at the GLOBAL level.
+	 * 
+	 * Any LOG message regardless of message type can be disabled (override
+	 * verbose) at the msgBlkLogDef struct level my setting member msgOutput
+	 * = LPFC_MSG_OPUT_DISA.  The message will never be displayed regardless
+	 * of verbose mask.
+	 * 
+	 * Any LOG message regardless of message type can be enable (override
+	 * verbose) at the msgBlkLogDef struct level my setting member msgOutput
+	 * = LPFC_MSG_OPUT_FORCE.  The message will always be displayed
+	 * regardless of verbose mask.
+	 */
+#define LOG_ELS                       0x1	/* ELS events */
+#define LOG_DISCOVERY                 0x2	/* Link discovery events */
+#define LOG_MBOX                      0x4	/* Mailbox events */
+#define LOG_INIT                      0x8	/* Initialization events */
+#define LOG_LINK_EVENT                0x10	/* Link events */
+#define LOG_IP                        0x20	/* IP traffic history */
+#define LOG_FCP                       0x40	/* FCP traffic history */
+#define LOG_NODE                      0x80	/* Node table events */
+#define LOG_MISC                      0x400	/* Miscellaneous events */
+#define LOG_SLI                       0x800	/* SLI events */
+#define LOG_CHK_COND                  0x1000	/* FCP Check condition flag */
+#define LOG_LIBDFC                    0x2000	/* Libdfc events */
+#define LOG_ALL_MSG                   0xffff	/* LOG all messages */
+
+	unsigned int msgAuxLogID;	/* Message LOG ID - This auxilliary
+					   member describes the failure. */
+#define ERRID_LOG_TIMEOUT             0xfdefefa7 /* Fibre Channel timeout */
+#define ERRID_LOG_HDW_ERR             0x1ae4fffc /* Fibre Channel hardware
+						    failure */
+#define ERRID_LOG_UNEXPECT_EVENT      0xbdb7e728 /* Fibre Channel unexpected
+						    event */
+#define ERRID_LOG_INIT                0xbe1043b8 /* Fibre Channel init
+						    failure */
+#define ERRID_LOG_NO_RESOURCE         0x474c1775 /* Fibre Channel no
+						    resources */
+} msgLogDef;
+
+/*
+ * Message logging function prototypes
+ */
+
+int lpfc_log_chk_msg_disabled(int, msgLogDef *);
+int lpfc_printf_log(int, msgLogDef *, void *, ...);
+int lpfc_printf_log_msgblk(int, msgLogDef *, char *);
+
+/*
+ * External Declarations for LOG Messages
+ */
+
+/* ELS LOG Messages */
+extern char lpfc_mes0100[];
+extern char lpfc_mes0101[];
+extern char lpfc_mes0102[];
+extern char lpfc_mes0103[];
+extern char lpfc_mes0104[];
+extern char lpfc_mes0105[];
+extern char lpfc_mes0106[];
+extern char lpfc_mes0107[];
+extern char lpfc_mes0108[];
+extern char lpfc_mes0109[];
+extern char lpfc_mes0110[];
+extern char lpfc_mes0111[];
+extern char lpfc_mes0112[];
+extern char lpfc_mes0113[];
+extern char lpfc_mes0114[];
+extern char lpfc_mes0115[];
+extern char lpfc_mes0116[];
+extern char lpfc_mes0117[];
+extern char lpfc_mes0118[];
+extern char lpfc_mes0119[];
+extern char lpfc_mes0120[];
+extern char lpfc_mes0121[];
+extern char lpfc_mes0122[];
+extern char lpfc_mes0123[];
+extern char lpfc_mes0124[];
+extern char lpfc_mes0125[];
+extern char lpfc_mes0126[];
+extern char lpfc_mes0127[];
+
+/* DISCOVERY LOG Messages */
+extern char lpfc_mes0200[];
+extern char lpfc_mes0201[];
+extern char lpfc_mes0202[];
+extern char lpfc_mes0204[];
+extern char lpfc_mes0205[];
+extern char lpfc_mes0206[];
+extern char lpfc_mes0207[];
+extern char lpfc_mes0208[];
+extern char lpfc_mes0209[];
+extern char lpfc_mes0210[];
+extern char lpfc_mes0211[];
+extern char lpfc_mes0212[];
+extern char lpfc_mes0213[];
+extern char lpfc_mes0214[];
+extern char lpfc_mes0215[];
+extern char lpfc_mes0216[];
+extern char lpfc_mes0217[];
+extern char lpfc_mes0218[];
+extern char lpfc_mes0219[];
+extern char lpfc_mes0220[];
+extern char lpfc_mes0221[];
+extern char lpfc_mes0222[];
+extern char lpfc_mes0223[];
+extern char lpfc_mes0224[];
+extern char lpfc_mes0225[];
+extern char lpfc_mes0226[];
+extern char lpfc_mes0227[];
+extern char lpfc_mes0228[];
+extern char lpfc_mes0229[];
+extern char lpfc_mes0230[];
+extern char lpfc_mes0231[];
+extern char lpfc_mes0232[];
+extern char lpfc_mes0234[];
+extern char lpfc_mes0235[];
+extern char lpfc_mes0236[];
+extern char lpfc_mes0237[];
+extern char lpfc_mes0238[];
+extern char lpfc_mes0239[];
+extern char lpfc_mes0240[];
+extern char lpfc_mes0241[];
+extern char lpfc_mes0242[];
+extern char lpfc_mes0243[];
+extern char lpfc_mes0244[];
+extern char lpfc_mes0245[];
+extern char lpfc_mes0246[];
+extern char lpfc_mes0247[];
+extern char lpfc_mes0248[];
+extern char lpfc_mes0249[];
+extern char lpfc_mes0250[];
+extern char lpfc_mes0256[];
+extern char lpfc_mes0260[];
+extern char lpfc_mes0261[];
+
+/* MAILBOX LOG Messages */
+extern char lpfc_mes0300[];
+extern char lpfc_mes0301[];
+extern char lpfc_mes0302[];
+extern char lpfc_mes0304[];
+extern char lpfc_mes0305[];
+extern char lpfc_mes0306[];
+extern char lpfc_mes0307[];
+extern char lpfc_mes0308[];
+extern char lpfc_mes0309[];
+extern char lpfc_mes0310[];
+extern char lpfc_mes0311[];
+extern char lpfc_mes0312[];
+extern char lpfc_mes0313[];
+extern char lpfc_mes0314[];
+extern char lpfc_mes0315[];
+extern char lpfc_mes0316[];
+extern char lpfc_mes0317[];
+extern char lpfc_mes0318[];
+extern char lpfc_mes0319[];
+extern char lpfc_mes0320[];
+extern char lpfc_mes0321[];
+extern char lpfc_mes0322[];
+extern char lpfc_mes0323[];
+extern char lpfc_mes0324[];
+extern char lpfc_mes0325[];
+extern char lpfc_mes0326[];
+
+/* INIT LOG Messages */
+extern char lpfc_mes0405[];
+extern char lpfc_mes0410[];
+extern char lpfc_mes0411[];
+extern char lpfc_mes0412[];
+extern char lpfc_mes0413[];
+extern char lpfc_mes0430[];
+extern char lpfc_mes0431[];
+extern char lpfc_mes0432[];
+extern char lpfc_mes0433[];
+extern char lpfc_mes0434[];
+extern char lpfc_mes0435[];
+extern char lpfc_mes0436[];
+extern char lpfc_mes0437[];
+extern char lpfc_mes0438[];
+extern char lpfc_mes0439[];
+extern char lpfc_mes0440[];
+extern char lpfc_mes0441[];
+extern char lpfc_mes0442[];
+extern char lpfc_mes0443[];
+extern char lpfc_mes0446[];
+extern char lpfc_mes0447[];
+extern char lpfc_mes0448[];
+extern char lpfc_mes0451[];
+extern char lpfc_mes0453[];
+extern char lpfc_mes0454[];
+extern char lpfc_mes0455[];
+extern char lpfc_mes0457[];
+extern char lpfc_mes0458[];
+extern char lpfc_mes0460[];
+extern char lpfc_mes0462[];
+
+/* IP LOG Messages */
+extern char lpfc_mes0600[];
+extern char lpfc_mes0601[];
+extern char lpfc_mes0610[];
+
+/* FCP LOG Messages */
+extern char lpfc_mes0701[];
+extern char lpfc_mes0702[];
+extern char lpfc_mes0703[];
+extern char lpfc_mes0712[];
+extern char lpfc_mes0713[];
+extern char lpfc_mes0714[];
+extern char lpfc_mes0716[];
+extern char lpfc_mes0717[];
+extern char lpfc_mes0729[];
+extern char lpfc_mes0730[];
+extern char lpfc_mes0734[];
+extern char lpfc_mes0735[];
+extern char lpfc_mes0737[];
+extern char lpfc_mes0738[];
+extern char lpfc_mes0747[];
+extern char lpfc_mes0748[];
+extern char lpfc_mes0749[];
+extern char lpfc_mes0754[];
+
+/* NODE LOG Messages */
+extern char lpfc_mes0900[];
+extern char lpfc_mes0901[];
+extern char lpfc_mes0902[];
+extern char lpfc_mes0903[];
+extern char lpfc_mes0904[];
+extern char lpfc_mes0905[];
+extern char lpfc_mes0906[];
+extern char lpfc_mes0907[];
+extern char lpfc_mes0908[];
+extern char lpfc_mes0910[];
+extern char lpfc_mes0911[];
+extern char lpfc_mes0929[];
+extern char lpfc_mes0930[];
+extern char lpfc_mes0931[];
+extern char lpfc_mes0932[];
+
+/* MISC LOG messages */
+extern char lpfc_mes1208[];
+extern char lpfc_mes1210[];
+extern char lpfc_mes1212[];
+extern char lpfc_mes1213[];
+
+/* LINK LOG Messages */
+extern char lpfc_mes1300[];
+extern char lpfc_mes1301[];
+extern char lpfc_mes1302[];
+extern char lpfc_mes1303[];
+extern char lpfc_mes1304[];
+extern char lpfc_mes1305[];
+extern char lpfc_mes1306[];
+extern char lpfc_mes1307[];
+
+/* CHK CONDITION LOG Messages */
+
+/* Libdfc Log Messages */
+extern char lpfc_mes1600[];
+extern char lpfc_mes1601[];
+extern char lpfc_mes1602[];
+extern char lpfc_mes1603[];
+extern char lpfc_mes1604[];
+extern char lpfc_mes1606[];
+extern char lpfc_mes1607[];
+
+/*
+ * External Declarations for LOG Message Structure msgBlkLogDef
+ */
+
+/* ELS LOG Message Structures */
+extern msgLogDef lpfc_msgBlk0100;
+extern msgLogDef lpfc_msgBlk0101;
+extern msgLogDef lpfc_msgBlk0102;
+extern msgLogDef lpfc_msgBlk0103;
+extern msgLogDef lpfc_msgBlk0104;
+extern msgLogDef lpfc_msgBlk0105;
+extern msgLogDef lpfc_msgBlk0106;
+extern msgLogDef lpfc_msgBlk0107;
+extern msgLogDef lpfc_msgBlk0108;
+extern msgLogDef lpfc_msgBlk0109;
+extern msgLogDef lpfc_msgBlk0110;
+extern msgLogDef lpfc_msgBlk0111;
+extern msgLogDef lpfc_msgBlk0112;
+extern msgLogDef lpfc_msgBlk0113;
+extern msgLogDef lpfc_msgBlk0114;
+extern msgLogDef lpfc_msgBlk0115;
+extern msgLogDef lpfc_msgBlk0116;
+extern msgLogDef lpfc_msgBlk0117;
+extern msgLogDef lpfc_msgBlk0118;
+extern msgLogDef lpfc_msgBlk0119;
+extern msgLogDef lpfc_msgBlk0120;
+extern msgLogDef lpfc_msgBlk0121;
+extern msgLogDef lpfc_msgBlk0122;
+extern msgLogDef lpfc_msgBlk0123;
+extern msgLogDef lpfc_msgBlk0124;
+extern msgLogDef lpfc_msgBlk0125;
+extern msgLogDef lpfc_msgBlk0126;
+extern msgLogDef lpfc_msgBlk0127;
+
+/* DISCOVERY LOG Message Structures */
+extern msgLogDef lpfc_msgBlk0200;
+extern msgLogDef lpfc_msgBlk0201;
+extern msgLogDef lpfc_msgBlk0202;
+extern msgLogDef lpfc_msgBlk0204;
+extern msgLogDef lpfc_msgBlk0205;
+extern msgLogDef lpfc_msgBlk0206;
+extern msgLogDef lpfc_msgBlk0207;
+extern msgLogDef lpfc_msgBlk0208;
+extern msgLogDef lpfc_msgBlk0209;
+extern msgLogDef lpfc_msgBlk0210;
+extern msgLogDef lpfc_msgBlk0211;
+extern msgLogDef lpfc_msgBlk0212;
+extern msgLogDef lpfc_msgBlk0213;
+extern msgLogDef lpfc_msgBlk0214;
+extern msgLogDef lpfc_msgBlk0215;
+extern msgLogDef lpfc_msgBlk0216;
+extern msgLogDef lpfc_msgBlk0217;
+extern msgLogDef lpfc_msgBlk0218;
+extern msgLogDef lpfc_msgBlk0219;
+extern msgLogDef lpfc_msgBlk0220;
+extern msgLogDef lpfc_msgBlk0221;
+extern msgLogDef lpfc_msgBlk0222;
+extern msgLogDef lpfc_msgBlk0223;
+extern msgLogDef lpfc_msgBlk0224;
+extern msgLogDef lpfc_msgBlk0225;
+extern msgLogDef lpfc_msgBlk0226;
+extern msgLogDef lpfc_msgBlk0227;
+extern msgLogDef lpfc_msgBlk0228;
+extern msgLogDef lpfc_msgBlk0229;
+extern msgLogDef lpfc_msgBlk0230;
+extern msgLogDef lpfc_msgBlk0231;
+extern msgLogDef lpfc_msgBlk0232;
+extern msgLogDef lpfc_msgBlk0234;
+extern msgLogDef lpfc_msgBlk0235;
+extern msgLogDef lpfc_msgBlk0236;
+extern msgLogDef lpfc_msgBlk0237;
+extern msgLogDef lpfc_msgBlk0238;
+extern msgLogDef lpfc_msgBlk0239;
+extern msgLogDef lpfc_msgBlk0240;
+extern msgLogDef lpfc_msgBlk0241;
+extern msgLogDef lpfc_msgBlk0242;
+extern msgLogDef lpfc_msgBlk0243;
+extern msgLogDef lpfc_msgBlk0244;
+extern msgLogDef lpfc_msgBlk0245;
+extern msgLogDef lpfc_msgBlk0246;
+extern msgLogDef lpfc_msgBlk0247;
+extern msgLogDef lpfc_msgBlk0248;
+extern msgLogDef lpfc_msgBlk0249;
+extern msgLogDef lpfc_msgBlk0250;
+extern msgLogDef lpfc_msgBlk0256;
+extern msgLogDef lpfc_msgBlk0260;
+extern msgLogDef lpfc_msgBlk0261;
+
+
+/* MAILBOX LOG Message Structures */
+extern msgLogDef lpfc_msgBlk0300;
+extern msgLogDef lpfc_msgBlk0301;
+extern msgLogDef lpfc_msgBlk0302;
+extern msgLogDef lpfc_msgBlk0304;
+extern msgLogDef lpfc_msgBlk0305;
+extern msgLogDef lpfc_msgBlk0306;
+extern msgLogDef lpfc_msgBlk0307;
+extern msgLogDef lpfc_msgBlk0308;
+extern msgLogDef lpfc_msgBlk0309;
+extern msgLogDef lpfc_msgBlk0310;
+extern msgLogDef lpfc_msgBlk0311;
+extern msgLogDef lpfc_msgBlk0312;
+extern msgLogDef lpfc_msgBlk0313;
+extern msgLogDef lpfc_msgBlk0314;
+extern msgLogDef lpfc_msgBlk0315;
+extern msgLogDef lpfc_msgBlk0316;
+extern msgLogDef lpfc_msgBlk0317;
+extern msgLogDef lpfc_msgBlk0318;
+extern msgLogDef lpfc_msgBlk0319;
+extern msgLogDef lpfc_msgBlk0320;
+extern msgLogDef lpfc_msgBlk0321;
+extern msgLogDef lpfc_msgBlk0322;
+extern msgLogDef lpfc_msgBlk0323;
+extern msgLogDef lpfc_msgBlk0324;
+extern msgLogDef lpfc_msgBlk0325;
+extern msgLogDef lpfc_msgBlk0326;
+
+/* INIT LOG Message Structures */
+extern msgLogDef lpfc_msgBlk0405;
+extern msgLogDef lpfc_msgBlk0410;
+extern msgLogDef lpfc_msgBlk0411;
+extern msgLogDef lpfc_msgBlk0412;
+extern msgLogDef lpfc_msgBlk0413;
+extern msgLogDef lpfc_msgBlk0430;
+extern msgLogDef lpfc_msgBlk0431;
+extern msgLogDef lpfc_msgBlk0432;
+extern msgLogDef lpfc_msgBlk0433;
+extern msgLogDef lpfc_msgBlk0434;
+extern msgLogDef lpfc_msgBlk0435;
+extern msgLogDef lpfc_msgBlk0436;
+extern msgLogDef lpfc_msgBlk0437;
+extern msgLogDef lpfc_msgBlk0438;
+extern msgLogDef lpfc_msgBlk0439;
+extern msgLogDef lpfc_msgBlk0440;
+extern msgLogDef lpfc_msgBlk0441;
+extern msgLogDef lpfc_msgBlk0442;
+extern msgLogDef lpfc_msgBlk0443;
+extern msgLogDef lpfc_msgBlk0446;
+extern msgLogDef lpfc_msgBlk0447;
+extern msgLogDef lpfc_msgBlk0448;
+extern msgLogDef lpfc_msgBlk0451;
+extern msgLogDef lpfc_msgBlk0453;
+extern msgLogDef lpfc_msgBlk0454;
+extern msgLogDef lpfc_msgBlk0455;
+extern msgLogDef lpfc_msgBlk0457;
+extern msgLogDef lpfc_msgBlk0458;
+extern msgLogDef lpfc_msgBlk0460;
+extern msgLogDef lpfc_msgBlk0462;
+
+/* IP LOG Message Structures */
+extern msgLogDef lpfc_msgBlk0600;
+extern msgLogDef lpfc_msgBlk0601;
+extern msgLogDef lpfc_msgBlk0610;
+
+/* FCP LOG Message Structures */
+extern msgLogDef lpfc_msgBlk0701;
+extern msgLogDef lpfc_msgBlk0702;
+extern msgLogDef lpfc_msgBlk0703;
+extern msgLogDef lpfc_msgBlk0712;
+extern msgLogDef lpfc_msgBlk0713;
+extern msgLogDef lpfc_msgBlk0714;
+extern msgLogDef lpfc_msgBlk0716;
+extern msgLogDef lpfc_msgBlk0717;
+extern msgLogDef lpfc_msgBlk0729;
+extern msgLogDef lpfc_msgBlk0730;
+extern msgLogDef lpfc_msgBlk0734;
+extern msgLogDef lpfc_msgBlk0735;
+extern msgLogDef lpfc_msgBlk0737;
+extern msgLogDef lpfc_msgBlk0738;
+extern msgLogDef lpfc_msgBlk0747;
+extern msgLogDef lpfc_msgBlk0748;
+extern msgLogDef lpfc_msgBlk0749;
+extern msgLogDef lpfc_msgBlk0754;
+
+/* NODE LOG Message Structures */
+extern msgLogDef lpfc_msgBlk0900;
+extern msgLogDef lpfc_msgBlk0901;
+extern msgLogDef lpfc_msgBlk0902;
+extern msgLogDef lpfc_msgBlk0903;
+extern msgLogDef lpfc_msgBlk0904;
+extern msgLogDef lpfc_msgBlk0905;
+extern msgLogDef lpfc_msgBlk0906;
+extern msgLogDef lpfc_msgBlk0907;
+extern msgLogDef lpfc_msgBlk0908;
+extern msgLogDef lpfc_msgBlk0910;
+extern msgLogDef lpfc_msgBlk0911;
+extern msgLogDef lpfc_msgBlk0929;
+extern msgLogDef lpfc_msgBlk0930;
+extern msgLogDef lpfc_msgBlk0931;
+extern msgLogDef lpfc_msgBlk0932;
+
+/* MISC LOG Message Structures */
+extern msgLogDef lpfc_msgBlk1208;
+extern msgLogDef lpfc_msgBlk1210;
+extern msgLogDef lpfc_msgBlk1212;
+extern msgLogDef lpfc_msgBlk1213;
+
+/* LINK LOG Message Structures */
+extern msgLogDef lpfc_msgBlk1300;
+extern msgLogDef lpfc_msgBlk1301;
+extern msgLogDef lpfc_msgBlk1302;
+extern msgLogDef lpfc_msgBlk1303;
+extern msgLogDef lpfc_msgBlk1304;
+extern msgLogDef lpfc_msgBlk1305;
+extern msgLogDef lpfc_msgBlk1306;
+extern msgLogDef lpfc_msgBlk1307;
+
+/* CHK CONDITION LOG Message Structures */
+
+/* Libdfc LOG Message Structures */
+extern msgLogDef lpfc_msgBlk1600;
+extern msgLogDef lpfc_msgBlk1601;
+extern msgLogDef lpfc_msgBlk1602;
+extern msgLogDef lpfc_msgBlk1603;
+extern msgLogDef lpfc_msgBlk1604;
+extern msgLogDef lpfc_msgBlk1606;
+extern msgLogDef lpfc_msgBlk1607;
+
+/* 
+ * LOG Messages Numbers
+ */
+
+/* ELS LOG Message Numbers */
+#define LPFC_LOG_MSG_EL_0100    100
+#define LPFC_LOG_MSG_EL_0101    101
+#define LPFC_LOG_MSG_EL_0102    102
+#define LPFC_LOG_MSG_EL_0103    103
+#define LPFC_LOG_MSG_EL_0104    104
+#define LPFC_LOG_MSG_EL_0105    105
+#define LPFC_LOG_MSG_EL_0106    106
+#define LPFC_LOG_MSG_EL_0107    107
+#define LPFC_LOG_MSG_EL_0108    108
+#define LPFC_LOG_MSG_EL_0109    109
+#define LPFC_LOG_MSG_EL_0110    110
+#define LPFC_LOG_MSG_EL_0111    111
+#define LPFC_LOG_MSG_EL_0112    112
+#define LPFC_LOG_MSG_EL_0113    113
+#define LPFC_LOG_MSG_EL_0114    114
+#define LPFC_LOG_MSG_EL_0115    115
+#define LPFC_LOG_MSG_EL_0116    116
+#define LPFC_LOG_MSG_EL_0117    117
+#define LPFC_LOG_MSG_EL_0118    118
+#define LPFC_LOG_MSG_EL_0119    119
+#define LPFC_LOG_MSG_EL_0120    120
+#define LPFC_LOG_MSG_EL_0121    121
+#define LPFC_LOG_MSG_EL_0122    122
+#define LPFC_LOG_MSG_EL_0123    123
+#define LPFC_LOG_MSG_EL_0124    124
+#define LPFC_LOG_MSG_EL_0125    125
+#define LPFC_LOG_MSG_EL_0126    126
+#define LPFC_LOG_MSG_EL_0127    127
+
+/* DISCOVERY LOG Message Numbers */
+#define LPFC_LOG_MSG_DI_0200    200
+#define LPFC_LOG_MSG_DI_0201    201
+#define LPFC_LOG_MSG_DI_0202    202
+#define LPFC_LOG_MSG_DI_0204    204
+#define LPFC_LOG_MSG_DI_0205    205
+#define LPFC_LOG_MSG_DI_0206    206
+#define LPFC_LOG_MSG_DI_0207    207
+#define LPFC_LOG_MSG_DI_0208    208
+#define LPFC_LOG_MSG_DI_0209    209
+#define LPFC_LOG_MSG_DI_0210    210
+#define LPFC_LOG_MSG_DI_0211    211
+#define LPFC_LOG_MSG_DI_0212    212
+#define LPFC_LOG_MSG_DI_0213    213
+#define LPFC_LOG_MSG_DI_0214    214
+#define LPFC_LOG_MSG_DI_0215    215
+#define LPFC_LOG_MSG_DI_0216    216
+#define LPFC_LOG_MSG_DI_0217    217
+#define LPFC_LOG_MSG_DI_0218    218
+#define LPFC_LOG_MSG_DI_0219    219
+#define LPFC_LOG_MSG_DI_0220    220
+#define LPFC_LOG_MSG_DI_0221    221
+#define LPFC_LOG_MSG_DI_0222    222
+#define LPFC_LOG_MSG_DI_0223    223
+#define LPFC_LOG_MSG_DI_0224    224
+#define LPFC_LOG_MSG_DI_0225    225
+#define LPFC_LOG_MSG_DI_0226    226
+#define LPFC_LOG_MSG_DI_0227    227
+#define LPFC_LOG_MSG_DI_0228    228
+#define LPFC_LOG_MSG_DI_0229    229
+#define LPFC_LOG_MSG_DI_0230    230
+#define LPFC_LOG_MSG_DI_0231    231
+#define LPFC_LOG_MSG_DI_0232    232
+#define LPFC_LOG_MSG_DI_0234    234
+#define LPFC_LOG_MSG_DI_0235    235
+#define LPFC_LOG_MSG_DI_0236    236
+#define LPFC_LOG_MSG_DI_0237    237
+#define LPFC_LOG_MSG_DI_0238    238
+#define LPFC_LOG_MSG_DI_0239    239
+#define LPFC_LOG_MSG_DI_0240    240
+#define LPFC_LOG_MSG_DI_0241    241
+#define LPFC_LOG_MSG_DI_0242    242
+#define LPFC_LOG_MSG_DI_0243    243
+#define LPFC_LOG_MSG_DI_0244    244
+#define LPFC_LOG_MSG_DI_0245    245
+#define LPFC_LOG_MSG_DI_0246    246
+#define LPFC_LOG_MSG_DI_0247    247
+#define LPFC_LOG_MSG_DI_0248    248
+#define LPFC_LOG_MSG_DI_0249    249
+#define LPFC_LOG_MSG_DI_0250    250
+#define LPFC_LOG_MSG_DI_0256    256
+#define LPFC_LOG_MSG_DI_0260    260
+#define LPFC_LOG_MSG_DI_0261    261
+
+/* MAILBOX LOG Message Numbers */
+#define LPFC_LOG_MSG_MB_0300    300
+#define LPFC_LOG_MSG_MB_0301    301
+#define LPFC_LOG_MSG_MB_0302    302
+#define LPFC_LOG_MSG_MB_0304    304
+#define LPFC_LOG_MSG_MB_0305    305
+#define LPFC_LOG_MSG_MB_0306    306
+#define LPFC_LOG_MSG_MB_0307    307
+#define LPFC_LOG_MSG_MB_0308    308
+#define LPFC_LOG_MSG_MB_0309    309
+#define LPFC_LOG_MSG_MB_0310    310
+#define LPFC_LOG_MSG_MB_0311    311
+#define LPFC_LOG_MSG_MB_0312    312
+#define LPFC_LOG_MSG_MB_0313    313
+#define LPFC_LOG_MSG_MB_0314    314
+#define LPFC_LOG_MSG_MB_0315    315
+#define LPFC_LOG_MSG_MB_0316    316
+#define LPFC_LOG_MSG_MB_0317    317
+#define LPFC_LOG_MSG_MB_0318    318
+#define LPFC_LOG_MSG_MB_0319    319
+#define LPFC_LOG_MSG_MB_0320    320
+#define LPFC_LOG_MSG_MB_0321    321
+#define LPFC_LOG_MSG_MB_0322    322
+#define LPFC_LOG_MSG_MB_0323    323
+#define LPFC_LOG_MSG_MB_0324    324
+#define LPFC_LOG_MSG_MB_0325    325
+#define LPFC_LOG_MSG_MB_0326    326
+
+/* INIT LOG Message Numbers */
+#define LPFC_LOG_MSG_IN_0405    405
+#define LPFC_LOG_MSG_IN_0410    410
+#define LPFC_LOG_MSG_IN_0411    411
+#define LPFC_LOG_MSG_IN_0412    412
+#define LPFC_LOG_MSG_IN_0413    413
+#define LPFC_LOG_MSG_IN_0430    430
+#define LPFC_LOG_MSG_IN_0431    431
+#define LPFC_LOG_MSG_IN_0432    432
+#define LPFC_LOG_MSG_IN_0433    433
+#define LPFC_LOG_MSG_IN_0434    434
+#define LPFC_LOG_MSG_IN_0435    435
+#define LPFC_LOG_MSG_IN_0436    436
+#define LPFC_LOG_MSG_IN_0437    437
+#define LPFC_LOG_MSG_IN_0438    438
+#define LPFC_LOG_MSG_IN_0439    439
+#define LPFC_LOG_MSG_IN_0440    440
+#define LPFC_LOG_MSG_IN_0441    441
+#define LPFC_LOG_MSG_IN_0442    442
+#define LPFC_LOG_MSG_IN_0443    443
+#define LPFC_LOG_MSG_IN_0446    446
+#define LPFC_LOG_MSG_IN_0447    447
+#define LPFC_LOG_MSG_IN_0448    448
+#define LPFC_LOG_MSG_IN_0451    451
+#define LPFC_LOG_MSG_IN_0453    453
+#define LPFC_LOG_MSG_IN_0454    454
+#define LPFC_LOG_MSG_IN_0455    455
+#define LPFC_LOG_MSG_IN_0457    457
+#define LPFC_LOG_MSG_IN_0458    458
+#define LPFC_LOG_MSG_IN_0460    460
+#define LPFC_LOG_MSG_IN_0462    462
+
+/*
+ * Available.LPFC_LOG_MSG_IN_0500    500
+ */
+
+/* IP LOG Message Numbers */
+#define LPFC_LOG_MSG_IP_0600    600
+#define LPFC_LOG_MSG_IP_0601    601
+#define LPFC_LOG_MSG_IP_0610    610
+
+/* FCP LOG Message Numbers */
+#define LPFC_LOG_MSG_FP_0701    701
+#define LPFC_LOG_MSG_FP_0702    702
+#define LPFC_LOG_MSG_FP_0703    703
+#define LPFC_LOG_MSG_FP_0712    712
+#define LPFC_LOG_MSG_FP_0713    713
+#define LPFC_LOG_MSG_FP_0714    714
+#define LPFC_LOG_MSG_FP_0716    716
+#define LPFC_LOG_MSG_FP_0717    717
+#define LPFC_LOG_MSG_FP_0729    729
+#define LPFC_LOG_MSG_FP_0730    730
+#define LPFC_LOG_MSG_FP_0734    734
+#define LPFC_LOG_MSG_FP_0735    735
+#define LPFC_LOG_MSG_FP_0737    737
+#define LPFC_LOG_MSG_FP_0738    738
+#define LPFC_LOG_MSG_FP_0747    747
+#define LPFC_LOG_MSG_FP_0748    748
+#define LPFC_LOG_MSG_FP_0749    749
+#define LPFC_LOG_MSG_FP_0754    754
+
+/*
+ * Available:  LPFC_LOG_MSG_FP_0800    800
+ */
+
+/* NODE LOG Message Numbers */
+#define LPFC_LOG_MSG_ND_0900    900
+#define LPFC_LOG_MSG_ND_0901    901
+#define LPFC_LOG_MSG_ND_0902    902
+#define LPFC_LOG_MSG_ND_0903    903
+#define LPFC_LOG_MSG_ND_0904    904
+#define LPFC_LOG_MSG_ND_0905    905
+#define LPFC_LOG_MSG_ND_0906    906
+#define LPFC_LOG_MSG_ND_0907    907
+#define LPFC_LOG_MSG_ND_0908    908
+#define LPFC_LOG_MSG_ND_0910    910
+#define LPFC_LOG_MSG_ND_0911    911
+#define LPFC_LOG_MSG_ND_0929    929
+#define LPFC_LOG_MSG_ND_0930    930
+#define LPFC_LOG_MSG_ND_0931    931
+#define LPFC_LOG_MSG_ND_0932    932
+
+/* MISC LOG Message Numbers */
+#define LPFC_LOG_MSG_MI_1208   1208
+#define LPFC_LOG_MSG_MI_1210   1210
+#define LPFC_LOG_MSG_MI_1212   1212
+#define LPFC_LOG_MSG_MI_1213   1213
+
+/* LINK LOG Message Numbers */
+#define LPFC_LOG_MSG_LK_1300   1300
+#define LPFC_LOG_MSG_LK_1301   1301
+#define LPFC_LOG_MSG_LK_1302   1302
+#define LPFC_LOG_MSG_LK_1303   1303
+#define LPFC_LOG_MSG_LK_1304   1304
+#define LPFC_LOG_MSG_LK_1305   1305
+#define LPFC_LOG_MSG_LK_1306   1306
+#define LPFC_LOG_MSG_LK_1307   1307
+
+/* CHK COMDITION LOG Message Numbers */
+/*
+ * Available LPFC_LOG_MSG_LK_1500   1500
+ */
+
+/* Libdfc LOG Message Numbers */
+#define LPFC_LOG_MSG_IO_1600   1600
+#define LPFC_LOG_MSG_IO_1601   1601
+#define LPFC_LOG_MSG_IO_1602   1602
+#define LPFC_LOG_MSG_IO_1603   1603
+#define LPFC_LOG_MSG_IO_1604   1604
+#define LPFC_LOG_MSG_IO_1606   1606
+#define LPFC_LOG_MSG_IO_1607   1607
+
+#endif				/* _H_LPFC_LOGMSG */
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_mbox.c linux-8155/drivers/addon/lpfc/lpfc_mbox.c
--- linux-8152/drivers/addon/lpfc/lpfc_mbox.c
+++ linux-8155/drivers/addon/lpfc/lpfc_mbox.c
@@ -0,0 +1,732 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_mbox.c 328 2005-05-03 15:20:43Z sf_support $
+ */
+#include <linux/version.h>
+#include <linux/spinlock.h>
+#include <linux/pci.h>
+
+
+#include <linux/blk.h>
+#include <scsi.h>
+
+#include "lpfc_hw.h"
+#include "lpfc_sli.h"
+#include "lpfc_mem.h"
+#include "lpfc_sched.h"
+#include "lpfc_disc.h"
+#include "lpfc.h"
+#include "lpfc_logmsg.h"
+#include "lpfc_scsi.h"
+#include "lpfc_crtn.h"
+#include "lpfc_cfgparm.h"
+
+/**********************************************/
+
+/*                mailbox command             */
+/**********************************************/
+void
+lpfc_dump_mem(lpfcHBA_t * phba, LPFC_MBOXQ_t * pmb, uint16_t offset)
+{
+	MAILBOX_t *mb;
+	void *ctx;
+
+	mb = &pmb->mb;
+	ctx = pmb->context2;
+
+	/* Setup to dump VPD region */
+	memset(pmb, 0, sizeof (LPFC_MBOXQ_t));
+	mb->mbxCommand = MBX_DUMP_MEMORY;
+	mb->un.varDmp.cv = 1;
+	mb->un.varDmp.type = DMP_NV_PARAMS;
+	mb->un.varDmp.entry_index = offset;
+	mb->un.varDmp.region_id = DMP_REGION_VPD;
+	mb->un.varDmp.word_cnt = (DMP_RSP_SIZE / sizeof (uint32_t));
+
+	mb->un.varDmp.co = 0;
+	mb->un.varDmp.resp_offset = 0;
+	pmb->context2 = ctx;
+
+	mb->mbxOwner = OWN_HOST;
+	return;
+}
+
+/**********************************************/
+/*  lpfc_read_nv  Issue a READ NVPARAM        */
+/*                mailbox command             */
+/**********************************************/
+void
+lpfc_read_nv(lpfcHBA_t * phba, LPFC_MBOXQ_t * pmb)
+{
+	MAILBOX_t *mb;
+
+	mb = &pmb->mb;
+	memset(pmb, 0, sizeof (LPFC_MBOXQ_t));
+	mb->mbxCommand = MBX_READ_NV;
+	mb->mbxOwner = OWN_HOST;
+	return;
+}
+
+/**********************************************/
+/*  lpfc_read_la  Issue a READ LA             */
+/*                mailbox command             */
+/**********************************************/
+int
+lpfc_read_la(lpfcHBA_t * phba, LPFC_MBOXQ_t * pmb)
+{
+	MAILBOX_t *mb;
+	DMABUF_t *mp;
+	LPFC_SLI_t *psli;
+
+	psli = &phba->sli;
+	mb = &pmb->mb;
+	memset(pmb, 0, sizeof (LPFC_MBOXQ_t));
+
+	/* Get a buffer to hold the loop map */
+	if (((mp = kmalloc(sizeof (DMABUF_t), GFP_ATOMIC)) == 0) ||
+	    ((mp->virt = lpfc_mbuf_alloc(phba, 0, &(mp->phys))) == 0)) {
+		if (mp)
+			kfree(mp);
+		mb->mbxCommand = MBX_READ_LA64;
+		/* READ_LA: no buffers */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0300, lpfc_mes0300,
+			       lpfc_msgBlk0300.msgPreambleStr);
+		return (1);
+	}
+	INIT_LIST_HEAD(&mp->list);
+	mb->mbxCommand = MBX_READ_LA64;
+	mb->un.varReadLA.un.lilpBde64.tus.f.bdeSize = 128;
+	mb->un.varReadLA.un.lilpBde64.addrHigh = putPaddrHigh(mp->phys);
+	mb->un.varReadLA.un.lilpBde64.addrLow = putPaddrLow(mp->phys);
+
+	/* Save address for later completion and set the owner to host so that
+	 * the FW knows this mailbox is available for processing. 
+	 */
+	pmb->context1 = (uint8_t *) mp;
+	mb->mbxOwner = OWN_HOST;
+	return (0);
+}
+
+/**********************************************/
+/*  lpfc_clear_la  Issue a CLEAR LA           */
+/*                 mailbox command            */
+/**********************************************/
+void
+lpfc_clear_la(lpfcHBA_t * phba, LPFC_MBOXQ_t * pmb)
+{
+	MAILBOX_t *mb;
+
+	mb = &pmb->mb;
+	memset(pmb, 0, sizeof (LPFC_MBOXQ_t));
+
+	mb->un.varClearLA.eventTag = phba->fc_eventTag;
+	mb->mbxCommand = MBX_CLEAR_LA;
+	mb->mbxOwner = OWN_HOST;
+	return;
+}
+
+/**************************************************/
+/*  lpfc_config_link  Issue a CONFIG LINK         */
+/*                    mailbox command             */
+/**************************************************/
+void
+lpfc_config_link(lpfcHBA_t * phba, LPFC_MBOXQ_t * pmb)
+{
+	MAILBOX_t *mb;
+	lpfcCfgParam_t *clp;
+
+	clp = &phba->config[0];
+	mb = &pmb->mb;
+	memset(pmb, 0, sizeof (LPFC_MBOXQ_t));
+
+	/* NEW_FEATURE
+	 * SLI-2, Coalescing Response Feature. 
+	 */
+	if (clp[LPFC_CFG_CR_DELAY].a_current) {
+		mb->un.varCfgLnk.cr = 1;
+		mb->un.varCfgLnk.ci = 1;
+		mb->un.varCfgLnk.cr_delay = clp[LPFC_CFG_CR_DELAY].a_current;
+		mb->un.varCfgLnk.cr_count = clp[LPFC_CFG_CR_COUNT].a_current;
+	}
+
+	mb->un.varCfgLnk.myId = phba->fc_myDID;
+	mb->un.varCfgLnk.edtov = phba->fc_edtov;
+	mb->un.varCfgLnk.arbtov = phba->fc_arbtov;
+	mb->un.varCfgLnk.ratov = phba->fc_ratov;
+	mb->un.varCfgLnk.rttov = phba->fc_rttov;
+	mb->un.varCfgLnk.altov = phba->fc_altov;
+	mb->un.varCfgLnk.crtov = phba->fc_crtov;
+	mb->un.varCfgLnk.citov = phba->fc_citov;
+
+	if (clp[LPFC_CFG_ACK0].a_current)
+		mb->un.varCfgLnk.ack0_enable = 1;
+
+	mb->mbxCommand = MBX_CONFIG_LINK;
+	mb->mbxOwner = OWN_HOST;
+	return;
+}
+
+/**********************************************/
+/*  lpfc_init_link  Issue an INIT LINK        */
+/*                  mailbox command           */
+/**********************************************/
+void
+lpfc_init_link(lpfcHBA_t * phba,
+	       LPFC_MBOXQ_t * pmb, uint32_t topology, uint32_t linkspeed)
+{
+	lpfc_vpd_t *vpd;
+	LPFC_SLI_t *psli;
+	MAILBOX_t *mb;
+
+	mb = &pmb->mb;
+	memset(pmb, 0, sizeof (LPFC_MBOXQ_t));
+
+	psli = &phba->sli;
+	switch (topology) {
+	case FLAGS_TOPOLOGY_MODE_LOOP_PT:
+		mb->un.varInitLnk.link_flags = FLAGS_TOPOLOGY_MODE_LOOP;
+		mb->un.varInitLnk.link_flags |= FLAGS_TOPOLOGY_FAILOVER;
+		break;
+	case FLAGS_TOPOLOGY_MODE_PT_PT:
+		mb->un.varInitLnk.link_flags = FLAGS_TOPOLOGY_MODE_PT_PT;
+		break;
+	case FLAGS_TOPOLOGY_MODE_LOOP:
+		mb->un.varInitLnk.link_flags = FLAGS_TOPOLOGY_MODE_LOOP;
+		break;
+	case FLAGS_TOPOLOGY_MODE_PT_LOOP:
+		mb->un.varInitLnk.link_flags = FLAGS_TOPOLOGY_MODE_PT_PT;
+		mb->un.varInitLnk.link_flags |= FLAGS_TOPOLOGY_FAILOVER;
+		break;
+	}
+
+	vpd = &phba->vpd;
+	if (vpd->rev.feaLevelHigh >= 0x02) {
+		switch(linkspeed) {
+		case LINK_SPEED_1G:
+		case LINK_SPEED_2G:
+		case LINK_SPEED_4G:
+			mb->un.varInitLnk.link_flags |= FLAGS_LINK_SPEED;
+			mb->un.varInitLnk.link_speed = linkspeed;
+			break;
+		case LINK_SPEED_AUTO:
+		default:
+			mb->un.varInitLnk.link_speed = LINK_SPEED_AUTO;
+		}
+	} else
+		mb->un.varInitLnk.link_speed = LINK_SPEED_AUTO;
+
+	mb->mbxCommand = (volatile uint8_t)MBX_INIT_LINK;
+	mb->mbxOwner = OWN_HOST;
+	mb->un.varInitLnk.fabric_AL_PA = phba->fc_pref_ALPA;
+	return;
+}
+
+/**********************************************/
+/*  lpfc_read_sparam  Issue a READ SPARAM     */
+/*                    mailbox command         */
+/**********************************************/
+int
+lpfc_read_sparam(lpfcHBA_t * phba, LPFC_MBOXQ_t * pmb)
+{
+	DMABUF_t *mp;
+	MAILBOX_t *mb;
+	LPFC_SLI_t *psli;
+
+	psli = &phba->sli;
+	mb = &pmb->mb;
+	memset(pmb, 0, sizeof (LPFC_MBOXQ_t));
+
+	mb->mbxOwner = OWN_HOST;
+
+	/* Get a buffer to hold the HBAs Service Parameters */
+
+	if (((mp = kmalloc(sizeof (DMABUF_t), GFP_ATOMIC)) == 0) ||
+	    ((mp->virt = lpfc_mbuf_alloc(phba, 0, &(mp->phys))) == 0)) {
+		if (mp)
+			kfree(mp);
+		mb->mbxCommand = MBX_READ_SPARM64;
+		/* READ_SPARAM: no buffers */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0301,
+			       lpfc_mes0301, lpfc_msgBlk0301.msgPreambleStr);
+		return (1);
+	}
+	INIT_LIST_HEAD(&mp->list);
+	mb->mbxCommand = MBX_READ_SPARM64;
+	mb->un.varRdSparm.un.sp64.tus.f.bdeSize = sizeof (SERV_PARM);
+	mb->un.varRdSparm.un.sp64.addrHigh = putPaddrHigh(mp->phys);
+	mb->un.varRdSparm.un.sp64.addrLow = putPaddrLow(mp->phys);
+
+	/* save address for completion */
+	pmb->context1 = mp;
+
+	return (0);
+}
+
+/**********************************************/
+/*  lpfc_read_rpi    Issue a READ RPI         */
+/*                   mailbox command          */
+/**********************************************/
+int
+lpfc_read_rpi(lpfcHBA_t * phba, uint32_t rpi, LPFC_MBOXQ_t * pmb, uint32_t flag)
+{
+	MAILBOX_t *mb;
+
+	mb = &pmb->mb;
+	memset(pmb, 0, sizeof (LPFC_MBOXQ_t));
+
+	mb->un.varRdRPI.reqRpi = (volatile uint16_t)rpi;
+
+	mb->mbxCommand = MBX_READ_RPI64;
+	mb->mbxOwner = OWN_HOST;
+
+	mb->un.varWords[30] = flag;	/* Set flag to issue action on cmpl */
+
+	return (0);
+}
+
+/********************************************/
+/*  lpfc_unreg_did  Issue a UNREG_DID       */
+/*                  mailbox command         */
+/********************************************/
+void
+lpfc_unreg_did(lpfcHBA_t * phba, uint32_t did, LPFC_MBOXQ_t * pmb)
+{
+	MAILBOX_t *mb;
+
+	mb = &pmb->mb;
+	memset(pmb, 0, sizeof (LPFC_MBOXQ_t));
+
+	mb->un.varUnregDID.did = did;
+
+	mb->mbxCommand = MBX_UNREG_D_ID;
+	mb->mbxOwner = OWN_HOST;
+	return;
+}
+
+/***********************************************/
+
+/*                  command to write slim      */
+/***********************************************/
+void
+lpfc_set_slim(lpfcHBA_t * phba, LPFC_MBOXQ_t * pmb, uint32_t addr,
+	      uint32_t value)
+{
+	MAILBOX_t *mb;
+
+	mb = &pmb->mb;
+	memset(pmb, 0, sizeof (LPFC_MBOXQ_t));
+
+	/* addr = 0x090597 is AUTO ABTS disable for ELS commands */
+	/* addr = 0x052198 is DELAYED ABTS enable for ELS commands */
+
+	/*
+	 * Always turn on DELAYED ABTS for ELS timeouts 
+	 */
+	if ((addr == 0x052198) && (value == 0))
+		value = 1;
+
+	mb->un.varWords[0] = addr;
+	mb->un.varWords[1] = value;
+
+	mb->mbxCommand = MBX_SET_SLIM;
+	mb->mbxOwner = OWN_HOST;
+	return;
+}
+
+/**********************************************/
+/*  lpfc_config_farp  Issue a CONFIG FARP     */
+/*                    mailbox command         */
+/**********************************************/
+void
+lpfc_config_farp(lpfcHBA_t * phba, LPFC_MBOXQ_t * pmb)
+{
+	MAILBOX_t *mb;
+
+	mb = &pmb->mb;
+	memset(pmb, 0, sizeof (LPFC_MBOXQ_t));
+
+	mb->un.varCfgFarp.filterEnable = 1;
+	mb->un.varCfgFarp.portName = 1;
+	mb->un.varCfgFarp.nodeName = 1;
+
+	memcpy((uint8_t *) & mb->un.varCfgFarp.portname,
+	       (uint8_t *) & phba->fc_portname, sizeof (NAME_TYPE));
+	memcpy((uint8_t *) & mb->un.varCfgFarp.nodename,
+	       (uint8_t *) & phba->fc_portname, sizeof (NAME_TYPE));
+	mb->mbxCommand = MBX_CONFIG_FARP;
+	mb->mbxOwner = OWN_HOST;
+	return;
+}
+
+/**********************************************/
+/*  lpfc_read_nv  Issue a READ CONFIG         */
+/*                mailbox command             */
+/**********************************************/
+void
+lpfc_read_config(lpfcHBA_t * phba, LPFC_MBOXQ_t * pmb)
+{
+	MAILBOX_t *mb;
+
+	mb = &pmb->mb;
+	memset(pmb, 0, sizeof (LPFC_MBOXQ_t));
+
+	mb->mbxCommand = MBX_READ_CONFIG;
+	mb->mbxOwner = OWN_HOST;
+	return;
+}
+
+/********************************************/
+/*  lpfc_reg_login  Issue a REG_LOGIN       */
+/*                  mailbox command         */
+/********************************************/
+int
+lpfc_reg_login(lpfcHBA_t * phba,
+	       uint32_t did, uint8_t * param, LPFC_MBOXQ_t * pmb, uint32_t flag)
+{
+	uint8_t *sparam;
+	DMABUF_t *mp;
+	MAILBOX_t *mb;
+	LPFC_SLI_t *psli;
+
+	psli = &phba->sli;
+	mb = &pmb->mb;
+	memset(pmb, 0, sizeof (LPFC_MBOXQ_t));
+
+	mb->un.varRegLogin.rpi = 0;
+	mb->un.varRegLogin.did = did;
+	mb->un.varWords[30] = flag;	/* Set flag to issue action on cmpl */
+
+	mb->mbxOwner = OWN_HOST;
+
+	/* Get a buffer to hold NPorts Service Parameters */
+	if (((mp = kmalloc(sizeof (DMABUF_t), GFP_ATOMIC)) == 0) ||
+	    ((mp->virt = lpfc_mbuf_alloc(phba, 0, &(mp->phys))) == 0)) {
+		if (mp)
+			kfree(mp);
+
+		mb->mbxCommand = MBX_REG_LOGIN64;
+		/* REG_LOGIN: no buffers */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0302,
+			       lpfc_mes0302,
+			       lpfc_msgBlk0302.msgPreambleStr,
+			       (uint32_t) did, (uint32_t) flag);
+		return (1);
+	}
+	INIT_LIST_HEAD(&mp->list);
+	sparam = mp->virt;
+
+	/* Copy param's into a new buffer */
+	memcpy(sparam, param, sizeof (SERV_PARM));
+
+	/* save address for completion */
+	pmb->context1 = (uint8_t *) mp;
+
+	mb->mbxCommand = MBX_REG_LOGIN64;
+	mb->un.varRegLogin.un.sp64.tus.f.bdeSize = sizeof (SERV_PARM);
+	mb->un.varRegLogin.un.sp64.addrHigh = putPaddrHigh(mp->phys);
+	mb->un.varRegLogin.un.sp64.addrLow = putPaddrLow(mp->phys);
+
+	return (0);
+}
+
+/**********************************************/
+/*  lpfc_unreg_login  Issue a UNREG_LOGIN     */
+/*                    mailbox command         */
+/**********************************************/
+void
+lpfc_unreg_login(lpfcHBA_t * phba, uint32_t rpi, LPFC_MBOXQ_t * pmb)
+{
+	MAILBOX_t *mb;
+
+	mb = &pmb->mb;
+	memset(pmb, 0, sizeof (LPFC_MBOXQ_t));
+
+	mb->un.varUnregLogin.rpi = (uint16_t) rpi;
+	mb->un.varUnregLogin.rsvd1 = 0;
+
+	mb->mbxCommand = MBX_UNREG_LOGIN;
+	mb->mbxOwner = OWN_HOST;
+	return;
+}
+
+/***********************************************/
+/*  lpfc_config_pcb_setup  Issue a CONFIG_PORT */
+/*                   mailbox command           */
+/***********************************************/
+uint32_t *
+lpfc_config_pcb_setup(lpfcHBA_t * phba)
+{
+	LPFC_SLI_t *psli;
+	LPFC_SLI_RING_t *pring;
+	LPFC_RING_INIT_t *pringinit;
+	PCB_t *pcbp;
+	SLI2_SLIM_t *slim2p_virt;
+	dma_addr_t pdma_addr;
+	uint32_t offset;
+	uint32_t iocbCnt;
+	int i;
+
+	psli = &phba->sli;
+
+	slim2p_virt = ((SLI2_SLIM_t *) phba->slim2p.virt);
+	pcbp = &slim2p_virt->un.slim.pcb;
+	psli->MBhostaddr = (uint32_t *) (&slim2p_virt->un.slim.mbx);
+
+	pcbp->maxRing = (psli->sliinit.num_rings - 1);
+
+	iocbCnt = 0;
+	for (i = 0; i < psli->sliinit.num_rings; i++) {
+		pringinit = &psli->sliinit.ringinit[i];
+		pring = &psli->ring[i];
+		/* A ring MUST have both cmd and rsp entries defined to be
+		   valid */
+		if ((pringinit->numCiocb == 0) || (pringinit->numRiocb == 0)) {
+			pcbp->rdsc[i].cmdEntries = 0;
+			pcbp->rdsc[i].rspEntries = 0;
+			pcbp->rdsc[i].cmdAddrHigh = 0;
+			pcbp->rdsc[i].rspAddrHigh = 0;
+			pcbp->rdsc[i].cmdAddrLow = 0;
+			pcbp->rdsc[i].rspAddrLow = 0;
+			pring->cmdringaddr = 0;
+			pring->rspringaddr = 0;
+			continue;
+		}
+		/* Command ring setup for ring */
+		pring->cmdringaddr =
+		    (void *)&slim2p_virt->un.slim.IOCBs[iocbCnt];
+		pcbp->rdsc[i].cmdEntries = pringinit->numCiocb;
+
+		offset =
+		    (uint8_t *) & slim2p_virt->un.slim.IOCBs[iocbCnt] -
+		    (uint8_t *) slim2p_virt;
+		pdma_addr = phba->slim2p.phys + offset;
+		pcbp->rdsc[i].cmdAddrHigh = putPaddrHigh(pdma_addr);
+		pcbp->rdsc[i].cmdAddrLow = putPaddrLow(pdma_addr);
+		iocbCnt += pringinit->numCiocb;
+
+		/* Response ring setup for ring */
+		pring->rspringaddr =
+		    (void *) &slim2p_virt->un.slim.IOCBs[iocbCnt];
+
+		pcbp->rdsc[i].rspEntries = pringinit->numRiocb;
+		offset =
+		    (uint8_t *) & slim2p_virt->un.slim.IOCBs[iocbCnt] -
+		    (uint8_t *) slim2p_virt;
+		pdma_addr = phba->slim2p.phys + offset;
+		pcbp->rdsc[i].rspAddrHigh = putPaddrHigh(pdma_addr);
+		pcbp->rdsc[i].rspAddrLow = putPaddrLow(pdma_addr);
+		iocbCnt += pringinit->numRiocb;
+	}
+
+	/* special handling for LC HBAs */
+	if (lpfc_is_LC_HBA(phba->pcidev->device)) {
+		lpfc_hba_init(phba);
+		return (phba->hbainitEx);
+	} else
+		return (0);
+}
+
+
+void
+lpfc_read_rev(lpfcHBA_t * phba, LPFC_MBOXQ_t * pmb)
+{
+	MAILBOX_t *mb;
+
+	mb = &pmb->mb;
+	memset(pmb, 0, sizeof (LPFC_MBOXQ_t));
+	mb->un.varRdRev.cv = 1;
+	mb->mbxCommand = MBX_READ_REV;
+	mb->mbxOwner = OWN_HOST;
+	return;
+}
+
+void
+lpfc_config_ring(lpfcHBA_t * phba, int ring, LPFC_MBOXQ_t * pmb)
+{
+	int i;
+	MAILBOX_t *mb;
+	LPFC_SLI_t *psli;
+	LPFC_RING_INIT_t *pring;
+
+	mb = &pmb->mb;
+	memset(pmb, 0, sizeof (LPFC_MBOXQ_t));
+
+	mb->un.varCfgRing.ring = ring;
+	mb->un.varCfgRing.maxOrigXchg = 0;
+	mb->un.varCfgRing.maxRespXchg = 0;
+	mb->un.varCfgRing.recvNotify = 1;
+
+	psli = &phba->sli;
+	pring = &psli->sliinit.ringinit[ring];
+	mb->un.varCfgRing.numMask = pring->num_mask;
+	mb->mbxCommand = MBX_CONFIG_RING;
+	mb->mbxOwner = OWN_HOST;
+
+	/* Is this ring configured for a specific profile */
+	if (pring->prt[0].profile) {
+		mb->un.varCfgRing.profile = pring->prt[0].profile;
+		return;
+	}
+
+	/* Otherwise we setup specific rctl / type masks for this ring */
+	for (i = 0; i < pring->num_mask; i++) {
+		mb->un.varCfgRing.rrRegs[i].rval = pring->prt[i].rctl;
+		if (mb->un.varCfgRing.rrRegs[i].rval != FC_ELS_REQ)
+			mb->un.varCfgRing.rrRegs[i].rmask = 0xff;
+		else
+			mb->un.varCfgRing.rrRegs[i].rmask = 0xfe;
+		mb->un.varCfgRing.rrRegs[i].tval = pring->prt[i].type;
+		mb->un.varCfgRing.rrRegs[i].tmask = 0xff;
+	}
+
+	return;
+}
+
+int
+lpfc_config_port(lpfcHBA_t * phba, LPFC_MBOXQ_t * pmb)
+{
+	LPFC_SLI_t *psli;
+	MAILBOX_t *mb;
+	uint32_t *hbainit;
+	dma_addr_t pdma_addr;
+	uint32_t offset;
+	HGP hgp;
+	void *to_slim;
+	uint32_t bar0_config_word, bar1_config_word;
+
+	mb = &pmb->mb;
+	memset(pmb, 0, sizeof (LPFC_MBOXQ_t));
+
+	psli = &phba->sli;
+	mb->mbxCommand = MBX_CONFIG_PORT;
+	mb->mbxOwner = OWN_HOST;
+
+	mb->un.varCfgPort.pcbLen = sizeof (PCB_t);
+	offset =
+	    (uint8_t *) (&((SLI2_SLIM_t *) phba->slim2p.virt)->un.slim.pcb) -
+	    (uint8_t *) phba->slim2p.virt;
+	pdma_addr = phba->slim2p.phys + offset;
+	mb->un.varCfgPort.pcbLow = putPaddrLow(pdma_addr);
+	mb->un.varCfgPort.pcbHigh = putPaddrHigh(pdma_addr);
+
+	/* Now setup pcb */
+	((SLI2_SLIM_t *) phba->slim2p.virt)->un.slim.pcb.type =
+	    TYPE_NATIVE_SLI2;
+	((SLI2_SLIM_t *) phba->slim2p.virt)->un.slim.pcb.feature =
+	    FEATURE_INITIAL_SLI2;
+
+	/* Setup Mailbox pointers */
+	((SLI2_SLIM_t *) phba->slim2p.virt)->un.slim.pcb.mailBoxSize =
+	    sizeof (MAILBOX_t);
+	offset =
+	    (uint8_t *) (&((SLI2_SLIM_t *) phba->slim2p.virt)->un.slim.mbx) -
+	    (uint8_t *) phba->slim2p.virt;
+	pdma_addr = phba->slim2p.phys + offset;
+	((SLI2_SLIM_t *) phba->slim2p.virt)->un.slim.pcb.mbAddrHigh =
+	    putPaddrHigh(pdma_addr);
+	((SLI2_SLIM_t *) phba->slim2p.virt)->un.slim.pcb.mbAddrLow =
+	    putPaddrLow(pdma_addr);
+
+	
+	pci_read_config_dword(phba->pcidev, PCI_BASE_ADDRESS_0, &bar0_config_word);
+	pci_read_config_dword(phba->pcidev, PCI_BASE_ADDRESS_1, &bar1_config_word);
+	if (bar0_config_word & PCI_BASE_ADDRESS_MEM_TYPE_64) {
+		((SLI2_SLIM_t *) phba->slim2p.virt)->
+			un.slim.pcb.hgpAddrHigh = bar1_config_word;
+	} else {
+		((SLI2_SLIM_t *) phba->slim2p.virt)->
+			un.slim.pcb.hgpAddrHigh = 0;
+	}
+	bar0_config_word &= PCI_BASE_ADDRESS_MEM_MASK;
+
+	((SLI2_SLIM_t *) phba->slim2p.virt)->un.slim.pcb.hgpAddrLow = 
+		(uint32_t) (bar0_config_word
+			    + (SLIMOFF * sizeof (uint32_t)));
+	memset(&hgp, 0, sizeof (HGP));
+
+	/* write HGP data to SLIM */
+	to_slim = (uint8_t *) phba->MBslimaddr
+		+ (SLIMOFF * sizeof (uint32_t));
+	lpfc_memcpy_to_slim( to_slim,  &hgp, sizeof (HGP));
+	
+
+	/* Setup Port Group ring counters */
+	offset =
+	    (uint8_t *) (&((SLI2_SLIM_t *) phba->slim2p.virt)->un.slim.mbx.us.
+			 s2.port) - (uint8_t *) phba->slim2p.virt;
+	pdma_addr = phba->slim2p.phys + offset;
+	((SLI2_SLIM_t *) phba->slim2p.virt)->un.slim.pcb.pgpAddrHigh =
+	    putPaddrHigh(pdma_addr);
+	((SLI2_SLIM_t *) phba->slim2p.virt)->un.slim.pcb.pgpAddrLow =
+	    putPaddrLow(pdma_addr);
+
+	/* Use callback routine to setp rings in the pcb */
+	hbainit = lpfc_config_pcb_setup(phba);
+	if (hbainit != 0)
+		memcpy(&mb->un.varCfgPort.hbainit, hbainit, 20);
+
+	/* Swap PCB if needed */
+	lpfc_sli_pcimem_bcopy((uint32_t
+			      *) (&((SLI2_SLIM_t *) phba->slim2p.virt)->un.slim.
+				  pcb),
+			     (uint32_t
+			      *) (&((SLI2_SLIM_t *) phba->slim2p.virt)->un.slim.
+				  pcb), sizeof (PCB_t));
+
+	/* Service Level Interface (SLI) 2 selected */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0405,
+		       lpfc_mes0405, lpfc_msgBlk0405.msgPreambleStr);
+	return (0);
+}
+
+void
+lpfc_mbox_put(lpfcHBA_t * phba, LPFC_MBOXQ_t * mbq)
+{				
+	LPFC_SLI_t *psli;
+
+	psli = &phba->sli;
+
+	list_add_tail(&mbq->list, &psli->mboxq);
+
+	psli->mboxq_cnt++;
+
+	return;
+}
+
+LPFC_MBOXQ_t *
+lpfc_mbox_get(lpfcHBA_t * phba)
+{
+	LPFC_MBOXQ_t *mbq;
+	LPFC_SLI_t *psli;
+	
+	mbq = 0;
+
+	psli = &phba->sli;
+
+	if (!list_empty(&psli->mboxq)) {
+		mbq = list_entry(psli->mboxq.next, LPFC_MBOXQ_t, list);
+		list_del_init(&mbq->list);
+		psli->mboxq_cnt--;
+	}
+
+	return (mbq);
+}
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_mem.c linux-8155/drivers/addon/lpfc/lpfc_mem.c
--- linux-8152/drivers/addon/lpfc/lpfc_mem.c
+++ linux-8155/drivers/addon/lpfc/lpfc_mem.c
@@ -0,0 +1,529 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_mem.c 328 2005-05-03 15:20:43Z sf_support $
+ */
+
+#include <linux/version.h>
+#include <linux/pci.h>
+#include <linux/blk.h>
+#include <scsi.h>
+
+
+#include "lpfc_hw.h"
+#include "lpfc_mem.h"
+#include "lpfc_sli.h"
+#include "lpfc_sched.h"
+#include "lpfc_disc.h"
+#include "lpfc.h"
+#include "lpfc_logmsg.h"
+#include "lpfc_scsi.h"
+#include "lpfc_crtn.h"
+
+void lpfc_mem_saftey_pool_create(lpfcHBA_t *, uint32_t );
+void lpfc_mem_saftey_pool_destroy(lpfcHBA_t *);
+void lpfc_mbuf_saftey_pool_create(lpfcHBA_t *, uint32_t );
+void lpfc_mbuf_saftey_pool_destroy(lpfcHBA_t *);
+void lpfc_page_saftey_pool_create(lpfcHBA_t *, uint32_t );
+void lpfc_page_saftey_pool_destroy(lpfcHBA_t *);
+void *lpfc_mbuf_alloc(lpfcHBA_t *, int, dma_addr_t *);
+void lpfc_mbuf_free(lpfcHBA_t *, void *, dma_addr_t);
+void *lpfc_page_alloc(lpfcHBA_t *, int, dma_addr_t *);
+void lpfc_page_free(lpfcHBA_t *, void *, dma_addr_t);
+
+static void lpfc_mem_saftey_pool_free(lpfcHBA_t *, void *);
+static void *lpfc_mem_saftey_pool_alloc(lpfcHBA_t *);
+static uint32_t lpfc_mem_saftey_pool_check(lpfcHBA_t *, void *);
+
+int
+lpfc_mem_alloc(lpfcHBA_t * phba)
+{
+
+	phba->lpfc_scsi_dma_ext_pool = 0;
+	phba->lpfc_mbuf_pool = 0;
+	phba->lpfc_page_pool = 0;
+
+	phba->lpfc_scsi_dma_ext_pool = 
+		pci_pool_create("lpfc_scsi_dma_ext_pool", 
+				phba->pcidev, 
+				LPFC_SCSI_DMA_EXT_SIZE, 
+				8,
+				0, 
+				GFP_KERNEL);
+
+	phba->lpfc_mbuf_pool = 
+		pci_pool_create("lpfc_mbuf_pool", 
+				phba->pcidev, 
+				LPFC_BPL_SIZE, 
+				8,
+				0, 
+				GFP_KERNEL);
+
+	phba->lpfc_page_pool = 
+		pci_pool_create("lpfc_page_pool", 
+				phba->pcidev, 
+				LPFC_SCSI_PAGE_BUF_SZ, 
+				8,
+				0, 
+				GFP_KERNEL);
+
+
+	if ((!phba->lpfc_scsi_dma_ext_pool) || (!phba->lpfc_mbuf_pool) ||
+	   (!phba->lpfc_page_pool)) {
+		lpfc_mem_free(phba);
+		return (0);
+	}
+
+	lpfc_mbuf_saftey_pool_create(phba, LPFC_MBUF_POOL_SIZE);
+	lpfc_page_saftey_pool_create(phba, LPFC_PAGE_POOL_SIZE);
+	lpfc_mem_saftey_pool_create(phba, LPFC_MEM_POOL_SIZE);
+
+	return (1);
+}
+
+int
+lpfc_mem_free(lpfcHBA_t * phba)
+{
+	LPFC_MBOXQ_t *mbox;
+	LPFC_SLI_t *psli;
+	struct list_head *curr, *next;
+
+	/* free the mapped address match area for each ring */
+	psli = &phba->sli;
+
+
+	/* Free everything on mbox queue */
+	list_for_each_safe(curr, next, &psli->mboxq) {
+		mbox = list_entry(curr, LPFC_MBOXQ_t, list);
+		list_del_init(&mbox->list);
+		lpfc_mbox_free(phba, mbox);
+	}
+
+	psli->sliinit.sli_flag &= ~LPFC_SLI_MBOX_ACTIVE;
+	if (psli->mbox_active) {
+		lpfc_mbox_free(phba, psli->mbox_active);
+		psli->mbox_active = 0;
+	}
+
+	lpfc_mbuf_saftey_pool_destroy(phba);
+	lpfc_page_saftey_pool_destroy(phba);
+	lpfc_mem_saftey_pool_destroy(phba);
+
+	if (phba->lpfc_scsi_dma_ext_pool)
+		pci_pool_destroy(phba->lpfc_scsi_dma_ext_pool);
+
+	if (phba->lpfc_mbuf_pool)
+		pci_pool_destroy(phba->lpfc_mbuf_pool);
+
+	if (phba->lpfc_page_pool)
+		pci_pool_destroy(phba->lpfc_page_pool);
+
+	return (1);
+}
+
+void
+lpfc_mem_saftey_pool_create(lpfcHBA_t *phba, uint32_t count)
+{
+
+	int number_of_pages;
+	int i, j;
+	struct lpfc_mem_pool *pool = &(phba->lpfc_mem_saftey_pool);
+	void *obj_ptr;
+
+	pool->page_count = 0;
+	pool->max_count  = 0;
+	pool->curr_count = 0;
+
+	number_of_pages =  LPFC_MEM_POOL_PAGE_SIZE / LPFC_MEM_POOL_OBJ_SIZE ;
+	number_of_pages = count / number_of_pages + 1;
+
+	pool->saftey_mempool_pages = kmalloc( number_of_pages * sizeof(void *),
+					      GFP_KERNEL);
+	INIT_LIST_HEAD(&(pool->obj_list));
+
+	if (!pool->saftey_mempool_pages)
+		return;
+
+	for (i=0; i<number_of_pages; i++) {
+		pool->saftey_mempool_pages[i] = kmalloc(LPFC_MEM_POOL_PAGE_SIZE,
+							GFP_KERNEL);
+
+		if (!pool->saftey_mempool_pages[i])
+			return;
+
+		pool->page_count++;
+		obj_ptr = pool->saftey_mempool_pages[i];
+
+		for ( j=0; j < LPFC_MEM_POOL_PAGE_SIZE/LPFC_MEM_POOL_OBJ_SIZE;
+		      j++) {
+			list_add((struct list_head *) obj_ptr,
+				 &(pool->obj_list));
+			pool->max_count++;
+			pool->curr_count++;
+			obj_ptr += LPFC_MEM_POOL_OBJ_SIZE;
+		}
+	}
+	return;
+}
+
+
+void
+lpfc_mem_saftey_pool_destroy(lpfcHBA_t *phba) {
+
+
+	struct lpfc_mem_pool *pool = &(phba->lpfc_mem_saftey_pool);
+	int i;
+
+	if ( pool->max_count != pool->curr_count )
+		printk("Memory leaked in lpfc memory saftey pool \n");
+
+	/* Make the object list empty */
+	INIT_LIST_HEAD(&(pool->obj_list));
+
+	/* Free the pages */
+	for (i=0; i<pool->page_count; i++)
+		kfree(pool->saftey_mempool_pages[i]);
+
+	kfree(pool->saftey_mempool_pages);
+	return;
+}
+
+void
+lpfc_mem_saftey_pool_free(lpfcHBA_t *phba, void *obj) {
+	struct lpfc_mem_pool *pool = &(phba->lpfc_mem_saftey_pool);
+	if(!obj)
+		return;
+
+	list_add((struct list_head *) obj,
+		 &(pool->obj_list));
+	pool->curr_count++;
+	return;
+}
+
+void *
+lpfc_mem_saftey_pool_alloc(lpfcHBA_t *phba) {
+	struct lpfc_mem_pool *pool = &(phba->lpfc_mem_saftey_pool);
+	void *ret = 0;
+
+	if ( (pool->curr_count) && 
+	     (!list_empty(&(pool->obj_list)))) {
+		ret = (void *) pool->obj_list.next ;
+		list_del(pool->obj_list.next);
+		pool->curr_count--;
+	}
+	return ret;
+}
+
+uint32_t
+lpfc_mem_saftey_pool_check(lpfcHBA_t *phba, void *obj) {
+	unsigned long address = (unsigned long) obj;
+	unsigned long page_addr;
+	int i;
+	struct lpfc_mem_pool *pool = &(phba->lpfc_mem_saftey_pool);
+
+	if ( pool->curr_count == pool->max_count )
+		return 0;
+
+	for (i=0; i< pool->page_count; i++) {
+		page_addr = (unsigned long) pool->saftey_mempool_pages[i];
+		if ((page_addr < address) &&
+		    (page_addr + LPFC_MEM_POOL_PAGE_SIZE > address))
+			return 1;
+	}
+
+	return 0;
+}
+
+void
+lpfc_mbuf_saftey_pool_create(lpfcHBA_t * phba, uint32_t count)
+{
+	int i;
+
+	struct lpfc_dma_pool *pool = 
+		&(phba->lpfc_mbuf_saftey_pool);
+
+	pool->elements = kmalloc(sizeof(DMABUF_t) * count,
+				 GFP_KERNEL);
+	pool->max_count = 0;
+	pool->current_count = 0;
+	for ( i=0; i<count; i++) {
+		pool->elements[i].virt =
+			pci_pool_alloc(phba->lpfc_mbuf_pool, 
+				       GFP_KERNEL, 
+				       &(pool->elements[i].phys));
+
+		if (!pool->elements[i].virt)
+			break;
+		pool->max_count++;
+		pool->current_count++;
+	}
+}
+ 
+void
+lpfc_mbuf_saftey_pool_destroy(lpfcHBA_t * phba)
+{
+	struct lpfc_dma_pool *pool = 
+		&(phba->lpfc_mbuf_saftey_pool);
+	int i;
+
+	if ( pool->max_count != pool->current_count)
+		printk("Memory leaked in mbuf saftey pool \n");
+
+	for (i=0; i< pool->current_count; i++) {
+		pci_pool_free(phba->lpfc_mbuf_pool, 
+			      pool->elements[i].virt,
+			      pool->elements[i].phys);
+	}
+
+	kfree(pool->elements);
+}
+
+
+void
+lpfc_page_saftey_pool_create(lpfcHBA_t * phba, uint32_t count)
+{
+	int i;
+
+	struct lpfc_dma_pool *pool = 
+		&(phba->lpfc_page_saftey_pool);
+
+	pool->elements = kmalloc(sizeof(DMABUF_t) * count,
+				 GFP_KERNEL);
+	pool->max_count = 0;
+	pool->current_count = 0;
+	for ( i=0; i<count; i++) {
+		pool->elements[i].virt =
+			pci_pool_alloc(phba->lpfc_page_pool, 
+				       GFP_KERNEL, 
+				       &(pool->elements[i].phys));
+
+		if (!pool->elements[i].virt)
+			break;
+		pool->max_count++;
+		pool->current_count++;
+	}
+}
+ 
+void
+lpfc_page_saftey_pool_destroy(lpfcHBA_t * phba)
+{
+	struct lpfc_dma_pool *pool = 
+		&(phba->lpfc_page_saftey_pool);
+	int i;
+
+	if ( pool->max_count != pool->current_count)
+		printk("Memory leaked in page saftey pool \n");
+
+	for (i=0; i< pool->current_count; i++) {
+		pci_pool_free(phba->lpfc_page_pool, 
+			      pool->elements[i].virt,
+			      pool->elements[i].phys);
+	}
+
+	kfree(pool->elements);
+}
+
+void *
+lpfc_mbuf_alloc(lpfcHBA_t * phba, int mem_flags, dma_addr_t * handle)
+{
+	void *ret;
+	struct lpfc_dma_pool *pool = 
+		&(phba->lpfc_mbuf_saftey_pool);
+
+	ret = pci_pool_alloc(phba->lpfc_mbuf_pool, GFP_ATOMIC, handle);
+	/* 
+	   If we are low in memory and is priority memory allocation
+	   use saftey pool 
+	*/
+	if ((!ret) && ( mem_flags & MEM_PRI) 
+	    && (pool->current_count)) {
+		pool->current_count--;
+		ret = pool->elements[pool->current_count].virt;
+		*handle = pool->elements[pool->current_count].phys;
+	}
+	return ret;
+}
+
+void
+lpfc_mbuf_free(lpfcHBA_t * phba, void *virt, dma_addr_t dma)
+{
+	struct lpfc_dma_pool *pool = 
+		&(phba->lpfc_mbuf_saftey_pool);
+
+	if ( pool->current_count < pool->max_count) {
+		pool->elements[pool->current_count].virt = virt;
+		pool->elements[pool->current_count].phys = dma;
+		pool->current_count++;
+		return;
+	}
+
+	pci_pool_free(phba->lpfc_mbuf_pool, virt, dma);
+	return;
+}
+
+void *
+lpfc_page_alloc(lpfcHBA_t * phba, int mem_flags, dma_addr_t * handle)
+{
+	void *ret;
+	struct lpfc_dma_pool *pool = 
+		&(phba->lpfc_page_saftey_pool);
+
+	ret = pci_pool_alloc(phba->lpfc_page_pool, GFP_ATOMIC, handle);
+	/* 
+	   If we are low in memory and is priority memory allocation
+	   use saftey pool 
+	*/
+	if ((!ret) && ( mem_flags & MEM_PRI) 
+	    && (pool->current_count)) {
+		pool->current_count--;
+		ret = pool->elements[pool->current_count].virt;
+		*handle = pool->elements[pool->current_count].phys;
+	}
+	return ret;
+}
+
+void
+lpfc_page_free(lpfcHBA_t * phba, void *virt, dma_addr_t dma)
+{
+	struct lpfc_dma_pool *pool = 
+		&(phba->lpfc_page_saftey_pool);
+
+	if ( pool->current_count < pool->max_count) {
+		pool->elements[pool->current_count].virt = virt;
+		pool->elements[pool->current_count].phys = dma;
+		pool->current_count++;
+		return;
+	}
+
+	pci_pool_free(phba->lpfc_page_pool, virt, dma);
+	return;
+}
+
+LPFC_MBOXQ_t *
+lpfc_mbox_alloc(lpfcHBA_t * phba, int mem_flags)
+{
+	LPFC_MBOXQ_t *ret;
+
+	ret = (LPFC_MBOXQ_t *) kmalloc(sizeof (LPFC_MBOXQ_t), GFP_ATOMIC);
+
+	/* if kmalloc fails and is a priority allocation use saftey pool */
+	if ((!ret) && (mem_flags & MEM_PRI))
+		ret = lpfc_mem_saftey_pool_alloc(phba);
+
+	return ret;
+}
+
+void
+lpfc_mbox_free(lpfcHBA_t * phba, LPFC_MBOXQ_t * virt)
+{
+	/* Check if the object belongs to saftey pool */
+	if (lpfc_mem_saftey_pool_check(phba,virt)) {
+		lpfc_mem_saftey_pool_free(phba,virt);
+		return;
+	}
+
+	kfree(virt);
+	return;
+}
+
+
+LPFC_IOCBQ_t *
+lpfc_iocb_alloc(lpfcHBA_t * phba, int mem_flags)
+{
+	LPFC_IOCBQ_t *ret;
+	ret = (LPFC_IOCBQ_t *) kmalloc(sizeof (LPFC_IOCBQ_t), GFP_ATOMIC);
+	
+	/* if kmalloc fails and is a priority allocation use saftey pool */
+	if ((!ret) && (mem_flags & MEM_PRI))
+		ret = lpfc_mem_saftey_pool_alloc(phba);
+	return ret;
+}
+
+void
+lpfc_iocb_free(lpfcHBA_t * phba, LPFC_IOCBQ_t * virt)
+{
+
+	/* Check if the object belongs to saftey pool */
+	if (lpfc_mem_saftey_pool_check(phba,virt)) {
+		lpfc_mem_saftey_pool_free(phba,virt);
+		return;
+	}
+
+	kfree(virt);
+	return;
+}
+
+
+LPFC_NODELIST_t *
+lpfc_nlp_alloc(lpfcHBA_t * phba, int mem_flags)
+{
+	LPFC_NODELIST_t *ret;
+
+	ret = (LPFC_NODELIST_t *)
+		kmalloc(sizeof (LPFC_NODELIST_t), GFP_ATOMIC);
+
+	/* if kmalloc fails and is a priority allocation use saftey pool */
+	if ((!ret) && (mem_flags & MEM_PRI))
+		ret = lpfc_mem_saftey_pool_alloc(phba);
+	return ret;
+}
+
+void
+lpfc_nlp_free(lpfcHBA_t * phba, LPFC_NODELIST_t * virt)
+{
+
+	/* Check if the object belongs to saftey pool */
+	if (lpfc_mem_saftey_pool_check(phba,virt)) {
+		lpfc_mem_saftey_pool_free(phba,virt);
+		return;
+	}
+
+	kfree(virt);
+	return;
+}
+
+LPFC_BINDLIST_t *
+lpfc_bind_alloc(lpfcHBA_t * phba, int mem_flags)
+{
+	LPFC_BINDLIST_t *ret;
+
+	ret = (LPFC_BINDLIST_t *)
+		kmalloc(sizeof (LPFC_BINDLIST_t), GFP_ATOMIC);
+
+	/* if kmalloc fails and is a priority allocation use saftey pool */
+	if ((!ret) && (mem_flags & MEM_PRI))
+		ret = lpfc_mem_saftey_pool_alloc(phba);
+	return ret;
+}
+
+void
+lpfc_bind_free(lpfcHBA_t * phba, LPFC_BINDLIST_t * virt)
+{
+	/* Check if the object belongs to saftey pool */
+	if (lpfc_mem_saftey_pool_check(phba,virt)) {
+		lpfc_mem_saftey_pool_free(phba,virt);
+		return;
+	}
+
+	kfree(virt);
+	return;
+}
+
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_mem.h linux-8155/drivers/addon/lpfc/lpfc_mem.h
--- linux-8152/drivers/addon/lpfc/lpfc_mem.h
+++ linux-8155/drivers/addon/lpfc/lpfc_mem.h
@@ -0,0 +1,84 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_mem.h 328 2005-05-03 15:20:43Z sf_support $
+ */
+
+#ifndef _H_LPFC_MEM
+#define _H_LPFC_MEM
+
+
+struct lpfc_dmabuf {
+	struct list_head list;
+	void *virt;		/* virtual address ptr */
+	dma_addr_t phys;	/* mapped address */
+};
+typedef struct lpfc_dmabuf DMABUF_t;
+
+struct lpfc_dmabufext {
+	DMABUF_t dma;
+	uint32_t size;
+	uint32_t flag;
+};
+typedef struct lpfc_dmabufext DMABUFEXT_t;
+
+struct lpfc_dmabufip {
+	DMABUF_t dma;
+	struct sk_buff *ipbuf;
+};
+typedef struct lpfc_dmabufip DMABUFIP_t;
+
+struct lpfc_dma_pool {
+	DMABUF_t   *elements;
+	uint32_t    max_count;
+	uint32_t    current_count;
+}; 
+
+struct lpfc_mem_pool {
+	void     **saftey_mempool_pages;
+	uint32_t   page_count;
+	uint32_t   max_count;
+	uint32_t   curr_count;
+	struct list_head obj_list;
+};
+
+#define MEM_PRI             0x100	/* Priority bit: set to exceed low
+					   water */
+
+
+#define LPFC_MEM_ERR          0x1	/* return error memflag */
+#define LPFC_MEM_GETMORE      0x2	/* get more memory memflag */
+#define LPFC_MEM_DMA          0x4	/* blocks are for DMA */
+#define LPFC_MEM_LOWHIT       0x8	/* low water mark was hit */
+#define LPFC_MEMPAD           0x10	/* offset used for a FC_MEM_DMA
+					   buffer */
+#define LPFC_MEM_ATTACH_IPBUF 0x20	/* attach a system IP buffer */
+#define LPFC_MEM_BOUND        0x40	/* has a upper bound */
+
+
+#define LPFC_PAGE_POOL_SIZE      4      /* max elements in page saftey pool */
+#define LPFC_MBUF_POOL_SIZE     64      /* max elements in MBUF saftey pool */
+#define LPFC_MEM_POOL_SIZE      64      /* max elements in non DMA saftey
+					   pool */
+#define LPFC_MEM_POOL_PAGE_SIZE 8192    
+#define LPFC_MEM_POOL_OBJ_SIZE  ((sizeof(LPFC_MBOXQ_t) + 0x7) & (~0x7))
+
+#endif				/* _H_LPFC_MEM */
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_module_param.h linux-8155/drivers/addon/lpfc/lpfc_module_param.h
--- linux-8152/drivers/addon/lpfc/lpfc_module_param.h
+++ linux-8155/drivers/addon/lpfc/lpfc_module_param.h
@@ -0,0 +1,1022 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_module_param.h 328 2005-05-03 15:20:43Z sf_support $
+ */
+
+#ifndef H_MODULE_PARAM
+#define H_MODULE_PARAM
+
+MODULE_PARM(lpfc0_log_verbose, "i");
+MODULE_PARM(lpfc0_lun_queue_depth, "i");
+MODULE_PARM(lpfc0_tgt_queue_depth, "i");
+MODULE_PARM(lpfc0_no_device_delay, "i");
+MODULE_PARM(lpfc0_xmt_que_size, "i");
+MODULE_PARM(lpfc0_scan_down, "i");
+MODULE_PARM(lpfc0_linkdown_tmo, "i");
+MODULE_PARM(lpfc0_nodev_tmo, "i");
+MODULE_PARM(lpfc0_delay_rsp_err, "i");
+MODULE_PARM(lpfc0_nodev_holdio, "i");
+MODULE_PARM(lpfc0_check_cond_err, "i");
+MODULE_PARM(lpfc0_topology, "i");
+MODULE_PARM(lpfc0_link_speed, "i");
+MODULE_PARM(lpfc0_fcp_class, "i");
+MODULE_PARM(lpfc0_use_adisc, "i");
+MODULE_PARM(lpfc0_extra_io_tmo, "i");
+MODULE_PARM(lpfc0_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc0_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc0_ack0, "i");
+MODULE_PARM(lpfc0_automap, "i");
+MODULE_PARM(lpfc0_fcp_bind_method, "i");
+MODULE_PARM(lpfc0_cr_delay, "i");
+MODULE_PARM(lpfc0_cr_count, "i");
+MODULE_PARM(lpfc0_fdmi_on, "i");
+MODULE_PARM(lpfc0_max_lun, "i");
+MODULE_PARM(lpfc0_discovery_threads, "i");
+MODULE_PARM(lpfc0_max_target, "i");
+MODULE_PARM(lpfc0_scsi_req_tmo, "i");
+MODULE_PARM(lpfc0_lun_skip, "i");
+
+MODULE_PARM(lpfc1_log_verbose, "i");
+MODULE_PARM(lpfc1_lun_queue_depth, "i");
+MODULE_PARM(lpfc1_tgt_queue_depth, "i");
+MODULE_PARM(lpfc1_no_device_delay, "i");
+MODULE_PARM(lpfc1_xmt_que_size, "i");
+MODULE_PARM(lpfc1_scan_down, "i");
+MODULE_PARM(lpfc1_linkdown_tmo, "i");
+MODULE_PARM(lpfc1_nodev_tmo, "i");
+MODULE_PARM(lpfc1_delay_rsp_err, "i");
+MODULE_PARM(lpfc1_nodev_holdio, "i");
+MODULE_PARM(lpfc1_check_cond_err, "i");
+MODULE_PARM(lpfc1_topology, "i");
+MODULE_PARM(lpfc1_link_speed, "i");
+MODULE_PARM(lpfc1_fcp_class, "i");
+MODULE_PARM(lpfc1_use_adisc, "i");
+MODULE_PARM(lpfc1_extra_io_tmo, "i");
+MODULE_PARM(lpfc1_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc1_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc1_ack0, "i");
+MODULE_PARM(lpfc1_automap, "i");
+MODULE_PARM(lpfc1_fcp_bind_method, "i");
+MODULE_PARM(lpfc1_cr_delay, "i");
+MODULE_PARM(lpfc1_cr_count, "i");
+MODULE_PARM(lpfc1_fdmi_on, "i");
+MODULE_PARM(lpfc1_max_lun, "i");
+MODULE_PARM(lpfc1_discovery_threads, "i");
+MODULE_PARM(lpfc1_max_target, "i");
+MODULE_PARM(lpfc1_scsi_req_tmo, "i");
+MODULE_PARM(lpfc1_lun_skip, "i");
+
+MODULE_PARM(lpfc2_log_verbose, "i");
+MODULE_PARM(lpfc2_lun_queue_depth, "i");
+MODULE_PARM(lpfc2_tgt_queue_depth, "i");
+MODULE_PARM(lpfc2_no_device_delay, "i");
+MODULE_PARM(lpfc2_xmt_que_size, "i");
+MODULE_PARM(lpfc2_scan_down, "i");
+MODULE_PARM(lpfc2_linkdown_tmo, "i");
+MODULE_PARM(lpfc2_nodev_tmo, "i");
+MODULE_PARM(lpfc2_delay_rsp_err, "i");
+MODULE_PARM(lpfc2_nodev_holdio, "i");
+MODULE_PARM(lpfc2_check_cond_err, "i");
+MODULE_PARM(lpfc2_topology, "i");
+MODULE_PARM(lpfc2_link_speed, "i");
+MODULE_PARM(lpfc2_fcp_class, "i");
+MODULE_PARM(lpfc2_use_adisc, "i");
+MODULE_PARM(lpfc2_extra_io_tmo, "i");
+MODULE_PARM(lpfc2_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc2_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc2_ack0, "i");
+MODULE_PARM(lpfc2_automap, "i");
+MODULE_PARM(lpfc2_fcp_bind_method, "i");
+MODULE_PARM(lpfc2_cr_delay, "i");
+MODULE_PARM(lpfc2_cr_count, "i");
+MODULE_PARM(lpfc2_fdmi_on, "i");
+MODULE_PARM(lpfc2_max_lun, "i");
+MODULE_PARM(lpfc2_discovery_threads, "i");
+MODULE_PARM(lpfc2_max_target, "i");
+MODULE_PARM(lpfc2_scsi_req_tmo, "i");
+MODULE_PARM(lpfc2_lun_skip, "i");
+
+MODULE_PARM(lpfc3_log_verbose, "i");
+MODULE_PARM(lpfc3_lun_queue_depth, "i");
+MODULE_PARM(lpfc3_tgt_queue_depth, "i");
+MODULE_PARM(lpfc3_no_device_delay, "i");
+MODULE_PARM(lpfc3_xmt_que_size, "i");
+MODULE_PARM(lpfc3_scan_down, "i");
+MODULE_PARM(lpfc3_linkdown_tmo, "i");
+MODULE_PARM(lpfc3_nodev_tmo, "i");
+MODULE_PARM(lpfc3_delay_rsp_err, "i");
+MODULE_PARM(lpfc3_nodev_holdio, "i");
+MODULE_PARM(lpfc3_check_cond_err, "i");
+MODULE_PARM(lpfc3_topology, "i");
+MODULE_PARM(lpfc3_link_speed, "i");
+MODULE_PARM(lpfc3_fcp_class, "i");
+MODULE_PARM(lpfc3_use_adisc, "i");
+MODULE_PARM(lpfc3_extra_io_tmo, "i");
+MODULE_PARM(lpfc3_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc3_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc3_ack0, "i");
+MODULE_PARM(lpfc3_automap, "i");
+MODULE_PARM(lpfc3_fcp_bind_method, "i");
+MODULE_PARM(lpfc3_cr_delay, "i");
+MODULE_PARM(lpfc3_cr_count, "i");
+MODULE_PARM(lpfc3_fdmi_on, "i");
+MODULE_PARM(lpfc3_max_lun, "i");
+MODULE_PARM(lpfc3_discovery_threads, "i");
+MODULE_PARM(lpfc3_max_target, "i");
+MODULE_PARM(lpfc3_scsi_req_tmo, "i");
+MODULE_PARM(lpfc3_lun_skip, "i");
+
+MODULE_PARM(lpfc4_log_verbose, "i");
+MODULE_PARM(lpfc4_lun_queue_depth, "i");
+MODULE_PARM(lpfc4_tgt_queue_depth, "i");
+MODULE_PARM(lpfc4_no_device_delay, "i");
+MODULE_PARM(lpfc4_xmt_que_size, "i");
+MODULE_PARM(lpfc4_scan_down, "i");
+MODULE_PARM(lpfc4_linkdown_tmo, "i");
+MODULE_PARM(lpfc4_nodev_tmo, "i");
+MODULE_PARM(lpfc4_delay_rsp_err, "i");
+MODULE_PARM(lpfc4_nodev_holdio, "i");
+MODULE_PARM(lpfc4_check_cond_err, "i");
+MODULE_PARM(lpfc4_topology, "i");
+MODULE_PARM(lpfc4_link_speed, "i");
+MODULE_PARM(lpfc4_fcp_class, "i");
+MODULE_PARM(lpfc4_use_adisc, "i");
+MODULE_PARM(lpfc4_extra_io_tmo, "i");
+MODULE_PARM(lpfc4_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc4_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc4_ack0, "i");
+MODULE_PARM(lpfc4_automap, "i");
+MODULE_PARM(lpfc4_fcp_bind_method, "i");
+MODULE_PARM(lpfc4_cr_delay, "i");
+MODULE_PARM(lpfc4_cr_count, "i");
+MODULE_PARM(lpfc4_fdmi_on, "i");
+MODULE_PARM(lpfc4_max_lun, "i");
+MODULE_PARM(lpfc4_discovery_threads, "i");
+MODULE_PARM(lpfc4_max_target, "i");
+MODULE_PARM(lpfc4_scsi_req_tmo, "i");
+MODULE_PARM(lpfc4_lun_skip, "i");
+
+MODULE_PARM(lpfc5_log_verbose, "i");
+MODULE_PARM(lpfc5_lun_queue_depth, "i");
+MODULE_PARM(lpfc5_tgt_queue_depth, "i");
+MODULE_PARM(lpfc5_no_device_delay, "i");
+MODULE_PARM(lpfc5_xmt_que_size, "i");
+MODULE_PARM(lpfc5_scan_down, "i");
+MODULE_PARM(lpfc5_linkdown_tmo, "i");
+MODULE_PARM(lpfc5_nodev_tmo, "i");
+MODULE_PARM(lpfc5_delay_rsp_err, "i");
+MODULE_PARM(lpfc5_nodev_holdio, "i");
+MODULE_PARM(lpfc5_check_cond_err, "i");
+MODULE_PARM(lpfc5_topology, "i");
+MODULE_PARM(lpfc5_link_speed, "i");
+MODULE_PARM(lpfc5_fcp_class, "i");
+MODULE_PARM(lpfc5_use_adisc, "i");
+MODULE_PARM(lpfc5_extra_io_tmo, "i");
+MODULE_PARM(lpfc5_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc5_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc5_ack0, "i");
+MODULE_PARM(lpfc5_automap, "i");
+MODULE_PARM(lpfc5_fcp_bind_method, "i");
+MODULE_PARM(lpfc5_cr_delay, "i");
+MODULE_PARM(lpfc5_cr_count, "i");
+MODULE_PARM(lpfc5_fdmi_on, "i");
+MODULE_PARM(lpfc5_max_lun, "i");
+MODULE_PARM(lpfc5_discovery_threads, "i");
+MODULE_PARM(lpfc5_max_target, "i");
+MODULE_PARM(lpfc5_scsi_req_tmo, "i");
+MODULE_PARM(lpfc5_lun_skip, "i");
+
+MODULE_PARM(lpfc6_log_verbose, "i");
+MODULE_PARM(lpfc6_lun_queue_depth, "i");
+MODULE_PARM(lpfc6_tgt_queue_depth, "i");
+MODULE_PARM(lpfc6_no_device_delay, "i");
+MODULE_PARM(lpfc6_xmt_que_size, "i");
+MODULE_PARM(lpfc6_scan_down, "i");
+MODULE_PARM(lpfc6_linkdown_tmo, "i");
+MODULE_PARM(lpfc6_nodev_tmo, "i");
+MODULE_PARM(lpfc6_delay_rsp_err, "i");
+MODULE_PARM(lpfc6_nodev_holdio, "i");
+MODULE_PARM(lpfc6_check_cond_err, "i");
+MODULE_PARM(lpfc6_topology, "i");
+MODULE_PARM(lpfc6_link_speed, "i");
+MODULE_PARM(lpfc6_fcp_class, "i");
+MODULE_PARM(lpfc6_use_adisc, "i");
+MODULE_PARM(lpfc6_extra_io_tmo, "i");
+MODULE_PARM(lpfc6_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc6_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc6_ack0, "i");
+MODULE_PARM(lpfc6_automap, "i");
+MODULE_PARM(lpfc6_fcp_bind_method, "i");
+MODULE_PARM(lpfc6_cr_delay, "i");
+MODULE_PARM(lpfc6_cr_count, "i");
+MODULE_PARM(lpfc6_fdmi_on, "i");
+MODULE_PARM(lpfc6_max_lun, "i");
+MODULE_PARM(lpfc6_discovery_threads, "i");
+MODULE_PARM(lpfc6_max_target, "i");
+MODULE_PARM(lpfc6_scsi_req_tmo, "i");
+MODULE_PARM(lpfc6_lun_skip, "i");
+
+MODULE_PARM(lpfc7_log_verbose, "i");
+MODULE_PARM(lpfc7_lun_queue_depth, "i");
+MODULE_PARM(lpfc7_tgt_queue_depth, "i");
+MODULE_PARM(lpfc7_no_device_delay, "i");
+MODULE_PARM(lpfc7_xmt_que_size, "i");
+MODULE_PARM(lpfc7_scan_down, "i");
+MODULE_PARM(lpfc7_linkdown_tmo, "i");
+MODULE_PARM(lpfc7_nodev_tmo, "i");
+MODULE_PARM(lpfc7_delay_rsp_err, "i");
+MODULE_PARM(lpfc7_nodev_holdio, "i");
+MODULE_PARM(lpfc7_check_cond_err, "i");
+MODULE_PARM(lpfc7_topology, "i");
+MODULE_PARM(lpfc7_link_speed, "i");
+MODULE_PARM(lpfc7_fcp_class, "i");
+MODULE_PARM(lpfc7_use_adisc, "i");
+MODULE_PARM(lpfc7_extra_io_tmo, "i");
+MODULE_PARM(lpfc7_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc7_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc7_ack0, "i");
+MODULE_PARM(lpfc7_automap, "i");
+MODULE_PARM(lpfc7_fcp_bind_method, "i");
+MODULE_PARM(lpfc7_cr_delay, "i");
+MODULE_PARM(lpfc7_cr_count, "i");
+MODULE_PARM(lpfc7_fdmi_on, "i");
+MODULE_PARM(lpfc7_max_lun, "i");
+MODULE_PARM(lpfc7_discovery_threads, "i");
+MODULE_PARM(lpfc7_max_target, "i");
+MODULE_PARM(lpfc7_scsi_req_tmo, "i");
+MODULE_PARM(lpfc7_lun_skip, "i");
+
+MODULE_PARM(lpfc8_log_verbose, "i");
+MODULE_PARM(lpfc8_lun_queue_depth, "i");
+MODULE_PARM(lpfc8_tgt_queue_depth, "i");
+MODULE_PARM(lpfc8_no_device_delay, "i");
+MODULE_PARM(lpfc8_xmt_que_size, "i");
+MODULE_PARM(lpfc8_scan_down, "i");
+MODULE_PARM(lpfc8_linkdown_tmo, "i");
+MODULE_PARM(lpfc8_nodev_tmo, "i");
+MODULE_PARM(lpfc8_delay_rsp_err, "i");
+MODULE_PARM(lpfc8_nodev_holdio, "i");
+MODULE_PARM(lpfc8_check_cond_err, "i");
+MODULE_PARM(lpfc8_topology, "i");
+MODULE_PARM(lpfc8_link_speed, "i");
+MODULE_PARM(lpfc8_fcp_class, "i");
+MODULE_PARM(lpfc8_use_adisc, "i");
+MODULE_PARM(lpfc8_extra_io_tmo, "i");
+MODULE_PARM(lpfc8_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc8_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc8_ack0, "i");
+MODULE_PARM(lpfc8_automap, "i");
+MODULE_PARM(lpfc8_fcp_bind_method, "i");
+MODULE_PARM(lpfc8_cr_delay, "i");
+MODULE_PARM(lpfc8_cr_count, "i");
+MODULE_PARM(lpfc8_fdmi_on, "i");
+MODULE_PARM(lpfc8_max_lun, "i");
+MODULE_PARM(lpfc8_discovery_threads, "i");
+MODULE_PARM(lpfc8_max_target, "i");
+MODULE_PARM(lpfc8_scsi_req_tmo, "i");
+MODULE_PARM(lpfc8_lun_skip, "i");
+
+MODULE_PARM(lpfc9_log_verbose, "i");
+MODULE_PARM(lpfc9_lun_queue_depth, "i");
+MODULE_PARM(lpfc9_tgt_queue_depth, "i");
+MODULE_PARM(lpfc9_no_device_delay, "i");
+MODULE_PARM(lpfc9_xmt_que_size, "i");
+MODULE_PARM(lpfc9_scan_down, "i");
+MODULE_PARM(lpfc9_linkdown_tmo, "i");
+MODULE_PARM(lpfc9_nodev_tmo, "i");
+MODULE_PARM(lpfc9_delay_rsp_err, "i");
+MODULE_PARM(lpfc9_nodev_holdio, "i");
+MODULE_PARM(lpfc9_check_cond_err, "i");
+MODULE_PARM(lpfc9_topology, "i");
+MODULE_PARM(lpfc9_link_speed, "i");
+MODULE_PARM(lpfc9_fcp_class, "i");
+MODULE_PARM(lpfc9_use_adisc, "i");
+MODULE_PARM(lpfc9_extra_io_tmo, "i");
+MODULE_PARM(lpfc9_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc9_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc9_ack0, "i");
+MODULE_PARM(lpfc9_automap, "i");
+MODULE_PARM(lpfc9_fcp_bind_method, "i");
+MODULE_PARM(lpfc9_cr_delay, "i");
+MODULE_PARM(lpfc9_cr_count, "i");
+MODULE_PARM(lpfc9_fdmi_on, "i");
+MODULE_PARM(lpfc9_max_lun, "i");
+MODULE_PARM(lpfc9_discovery_threads, "i");
+MODULE_PARM(lpfc9_max_target, "i");
+MODULE_PARM(lpfc9_scsi_req_tmo, "i");
+MODULE_PARM(lpfc9_lun_skip, "i");
+
+MODULE_PARM(lpfc10_log_verbose, "i");
+MODULE_PARM(lpfc10_lun_queue_depth, "i");
+MODULE_PARM(lpfc10_tgt_queue_depth, "i");
+MODULE_PARM(lpfc10_no_device_delay, "i");
+MODULE_PARM(lpfc10_xmt_que_size, "i");
+MODULE_PARM(lpfc10_scan_down, "i");
+MODULE_PARM(lpfc10_linkdown_tmo, "i");
+MODULE_PARM(lpfc10_nodev_tmo, "i");
+MODULE_PARM(lpfc10_delay_rsp_err, "i");
+MODULE_PARM(lpfc10_nodev_holdio, "i");
+MODULE_PARM(lpfc10_check_cond_err, "i");
+MODULE_PARM(lpfc10_topology, "i");
+MODULE_PARM(lpfc10_link_speed, "i");
+MODULE_PARM(lpfc10_fcp_class, "i");
+MODULE_PARM(lpfc10_use_adisc, "i");
+MODULE_PARM(lpfc10_extra_io_tmo, "i");
+MODULE_PARM(lpfc10_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc10_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc10_ack0, "i");
+MODULE_PARM(lpfc10_automap, "i");
+MODULE_PARM(lpfc10_fcp_bind_method, "i");
+MODULE_PARM(lpfc10_cr_delay, "i");
+MODULE_PARM(lpfc10_cr_count, "i");
+MODULE_PARM(lpfc10_fdmi_on, "i");
+MODULE_PARM(lpfc10_max_lun, "i");
+MODULE_PARM(lpfc10_discovery_threads, "i");
+MODULE_PARM(lpfc10_max_target, "i");
+MODULE_PARM(lpfc10_scsi_req_tmo, "i");
+MODULE_PARM(lpfc10_lun_skip, "i");
+
+MODULE_PARM(lpfc11_log_verbose, "i");
+MODULE_PARM(lpfc11_lun_queue_depth, "i");
+MODULE_PARM(lpfc11_tgt_queue_depth, "i");
+MODULE_PARM(lpfc11_no_device_delay, "i");
+MODULE_PARM(lpfc11_xmt_que_size, "i");
+MODULE_PARM(lpfc11_scan_down, "i");
+MODULE_PARM(lpfc11_linkdown_tmo, "i");
+MODULE_PARM(lpfc11_nodev_tmo, "i");
+MODULE_PARM(lpfc11_delay_rsp_err, "i");
+MODULE_PARM(lpfc11_nodev_holdio, "i");
+MODULE_PARM(lpfc11_check_cond_err, "i");
+MODULE_PARM(lpfc11_topology, "i");
+MODULE_PARM(lpfc11_link_speed, "i");
+MODULE_PARM(lpfc11_fcp_class, "i");
+MODULE_PARM(lpfc11_use_adisc, "i");
+MODULE_PARM(lpfc11_extra_io_tmo, "i");
+MODULE_PARM(lpfc11_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc11_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc11_ack0, "i");
+MODULE_PARM(lpfc11_automap, "i");
+MODULE_PARM(lpfc11_fcp_bind_method, "i");
+MODULE_PARM(lpfc11_cr_delay, "i");
+MODULE_PARM(lpfc11_cr_count, "i");
+MODULE_PARM(lpfc11_fdmi_on, "i");
+MODULE_PARM(lpfc11_max_lun, "i");
+MODULE_PARM(lpfc11_discovery_threads, "i");
+MODULE_PARM(lpfc11_max_target, "i");
+MODULE_PARM(lpfc11_scsi_req_tmo, "i");
+MODULE_PARM(lpfc11_lun_skip, "i");
+
+MODULE_PARM(lpfc12_log_verbose, "i");
+MODULE_PARM(lpfc12_lun_queue_depth, "i");
+MODULE_PARM(lpfc12_tgt_queue_depth, "i");
+MODULE_PARM(lpfc12_no_device_delay, "i");
+MODULE_PARM(lpfc12_xmt_que_size, "i");
+MODULE_PARM(lpfc12_scan_down, "i");
+MODULE_PARM(lpfc12_linkdown_tmo, "i");
+MODULE_PARM(lpfc12_nodev_tmo, "i");
+MODULE_PARM(lpfc12_delay_rsp_err, "i");
+MODULE_PARM(lpfc12_nodev_holdio, "i");
+MODULE_PARM(lpfc12_check_cond_err, "i");
+MODULE_PARM(lpfc12_topology, "i");
+MODULE_PARM(lpfc12_link_speed, "i");
+MODULE_PARM(lpfc12_fcp_class, "i");
+MODULE_PARM(lpfc12_use_adisc, "i");
+MODULE_PARM(lpfc12_extra_io_tmo, "i");
+MODULE_PARM(lpfc12_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc12_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc12_ack0, "i");
+MODULE_PARM(lpfc12_automap, "i");
+MODULE_PARM(lpfc12_fcp_bind_method, "i");
+MODULE_PARM(lpfc12_cr_delay, "i");
+MODULE_PARM(lpfc12_cr_count, "i");
+MODULE_PARM(lpfc12_fdmi_on, "i");
+MODULE_PARM(lpfc12_max_lun, "i");
+MODULE_PARM(lpfc12_discovery_threads, "i");
+MODULE_PARM(lpfc12_max_target, "i");
+MODULE_PARM(lpfc12_scsi_req_tmo, "i");
+MODULE_PARM(lpfc12_lun_skip, "i");
+
+MODULE_PARM(lpfc13_log_verbose, "i");
+MODULE_PARM(lpfc13_lun_queue_depth, "i");
+MODULE_PARM(lpfc13_tgt_queue_depth, "i");
+MODULE_PARM(lpfc13_no_device_delay, "i");
+MODULE_PARM(lpfc13_xmt_que_size, "i");
+MODULE_PARM(lpfc13_scan_down, "i");
+MODULE_PARM(lpfc13_linkdown_tmo, "i");
+MODULE_PARM(lpfc13_nodev_tmo, "i");
+MODULE_PARM(lpfc13_delay_rsp_err, "i");
+MODULE_PARM(lpfc13_nodev_holdio, "i");
+MODULE_PARM(lpfc13_check_cond_err, "i");
+MODULE_PARM(lpfc13_topology, "i");
+MODULE_PARM(lpfc13_link_speed, "i");
+MODULE_PARM(lpfc13_fcp_class, "i");
+MODULE_PARM(lpfc13_use_adisc, "i");
+MODULE_PARM(lpfc13_extra_io_tmo, "i");
+MODULE_PARM(lpfc13_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc13_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc13_ack0, "i");
+MODULE_PARM(lpfc13_automap, "i");
+MODULE_PARM(lpfc13_fcp_bind_method, "i");
+MODULE_PARM(lpfc13_cr_delay, "i");
+MODULE_PARM(lpfc13_cr_count, "i");
+MODULE_PARM(lpfc13_fdmi_on, "i");
+MODULE_PARM(lpfc13_max_lun, "i");
+MODULE_PARM(lpfc13_discovery_threads, "i");
+MODULE_PARM(lpfc13_max_target, "i");
+MODULE_PARM(lpfc13_scsi_req_tmo, "i");
+MODULE_PARM(lpfc13_lun_skip, "i");
+
+MODULE_PARM(lpfc14_log_verbose, "i");
+MODULE_PARM(lpfc14_lun_queue_depth, "i");
+MODULE_PARM(lpfc14_tgt_queue_depth, "i");
+MODULE_PARM(lpfc14_no_device_delay, "i");
+MODULE_PARM(lpfc14_xmt_que_size, "i");
+MODULE_PARM(lpfc14_scan_down, "i");
+MODULE_PARM(lpfc14_linkdown_tmo, "i");
+MODULE_PARM(lpfc14_nodev_tmo, "i");
+MODULE_PARM(lpfc14_delay_rsp_err, "i");
+MODULE_PARM(lpfc14_nodev_holdio, "i");
+MODULE_PARM(lpfc14_check_cond_err, "i");
+MODULE_PARM(lpfc14_topology, "i");
+MODULE_PARM(lpfc14_link_speed, "i");
+MODULE_PARM(lpfc14_fcp_class, "i");
+MODULE_PARM(lpfc14_use_adisc, "i");
+MODULE_PARM(lpfc14_extra_io_tmo, "i");
+MODULE_PARM(lpfc14_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc14_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc14_ack0, "i");
+MODULE_PARM(lpfc14_automap, "i");
+MODULE_PARM(lpfc14_fcp_bind_method, "i");
+MODULE_PARM(lpfc14_cr_delay, "i");
+MODULE_PARM(lpfc14_cr_count, "i");
+MODULE_PARM(lpfc14_fdmi_on, "i");
+MODULE_PARM(lpfc14_max_lun, "i");
+MODULE_PARM(lpfc14_discovery_threads, "i");
+MODULE_PARM(lpfc14_max_target, "i");
+MODULE_PARM(lpfc14_scsi_req_tmo, "i");
+MODULE_PARM(lpfc14_lun_skip, "i");
+
+MODULE_PARM(lpfc15_log_verbose, "i");
+MODULE_PARM(lpfc15_lun_queue_depth, "i");
+MODULE_PARM(lpfc15_tgt_queue_depth, "i");
+MODULE_PARM(lpfc15_no_device_delay, "i");
+MODULE_PARM(lpfc15_xmt_que_size, "i");
+MODULE_PARM(lpfc15_scan_down, "i");
+MODULE_PARM(lpfc15_linkdown_tmo, "i");
+MODULE_PARM(lpfc15_nodev_tmo, "i");
+MODULE_PARM(lpfc15_delay_rsp_err, "i");
+MODULE_PARM(lpfc15_nodev_holdio, "i");
+MODULE_PARM(lpfc15_check_cond_err, "i");
+MODULE_PARM(lpfc15_topology, "i");
+MODULE_PARM(lpfc15_link_speed, "i");
+MODULE_PARM(lpfc15_fcp_class, "i");
+MODULE_PARM(lpfc15_use_adisc, "i");
+MODULE_PARM(lpfc15_extra_io_tmo, "i");
+MODULE_PARM(lpfc15_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc15_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc15_ack0, "i");
+MODULE_PARM(lpfc15_automap, "i");
+MODULE_PARM(lpfc15_fcp_bind_method, "i");
+MODULE_PARM(lpfc15_cr_delay, "i");
+MODULE_PARM(lpfc15_cr_count, "i");
+MODULE_PARM(lpfc15_fdmi_on, "i");
+MODULE_PARM(lpfc15_max_lun, "i");
+MODULE_PARM(lpfc15_discovery_threads, "i");
+MODULE_PARM(lpfc15_max_target, "i");
+MODULE_PARM(lpfc15_scsi_req_tmo, "i");
+MODULE_PARM(lpfc15_lun_skip, "i");
+
+MODULE_PARM(lpfc16_log_verbose, "i");
+MODULE_PARM(lpfc16_lun_queue_depth, "i");
+MODULE_PARM(lpfc16_tgt_queue_depth, "i");
+MODULE_PARM(lpfc16_no_device_delay, "i");
+MODULE_PARM(lpfc16_xmt_que_size, "i");
+MODULE_PARM(lpfc16_scan_down, "i");
+MODULE_PARM(lpfc16_linkdown_tmo, "i");
+MODULE_PARM(lpfc16_nodev_tmo, "i");
+MODULE_PARM(lpfc16_delay_rsp_err, "i");
+MODULE_PARM(lpfc16_nodev_holdio, "i");
+MODULE_PARM(lpfc16_check_cond_err, "i");
+MODULE_PARM(lpfc16_topology, "i");
+MODULE_PARM(lpfc16_link_speed, "i");
+MODULE_PARM(lpfc16_fcp_class, "i");
+MODULE_PARM(lpfc16_use_adisc, "i");
+MODULE_PARM(lpfc16_extra_io_tmo, "i");
+MODULE_PARM(lpfc16_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc16_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc16_ack0, "i");
+MODULE_PARM(lpfc16_automap, "i");
+MODULE_PARM(lpfc16_fcp_bind_method, "i");
+MODULE_PARM(lpfc16_cr_delay, "i");
+MODULE_PARM(lpfc16_cr_count, "i");
+MODULE_PARM(lpfc16_fdmi_on, "i");
+MODULE_PARM(lpfc16_max_lun, "i");
+MODULE_PARM(lpfc16_discovery_threads, "i");
+MODULE_PARM(lpfc16_max_target, "i");
+MODULE_PARM(lpfc16_scsi_req_tmo, "i");
+MODULE_PARM(lpfc16_lun_skip, "i");
+
+MODULE_PARM(lpfc17_log_verbose, "i");
+MODULE_PARM(lpfc17_lun_queue_depth, "i");
+MODULE_PARM(lpfc17_tgt_queue_depth, "i");
+MODULE_PARM(lpfc17_no_device_delay, "i");
+MODULE_PARM(lpfc17_xmt_que_size, "i");
+MODULE_PARM(lpfc17_scan_down, "i");
+MODULE_PARM(lpfc17_linkdown_tmo, "i");
+MODULE_PARM(lpfc17_nodev_tmo, "i");
+MODULE_PARM(lpfc17_delay_rsp_err, "i");
+MODULE_PARM(lpfc17_nodev_holdio, "i");
+MODULE_PARM(lpfc17_check_cond_err, "i");
+MODULE_PARM(lpfc17_topology, "i");
+MODULE_PARM(lpfc17_link_speed, "i");
+MODULE_PARM(lpfc17_fcp_class, "i");
+MODULE_PARM(lpfc17_use_adisc, "i");
+MODULE_PARM(lpfc17_extra_io_tmo, "i");
+MODULE_PARM(lpfc17_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc17_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc17_ack0, "i");
+MODULE_PARM(lpfc17_automap, "i");
+MODULE_PARM(lpfc17_fcp_bind_method, "i");
+MODULE_PARM(lpfc17_cr_delay, "i");
+MODULE_PARM(lpfc17_cr_count, "i");
+MODULE_PARM(lpfc17_fdmi_on, "i");
+MODULE_PARM(lpfc17_max_lun, "i");
+MODULE_PARM(lpfc17_discovery_threads, "i");
+MODULE_PARM(lpfc17_max_target, "i");
+MODULE_PARM(lpfc17_scsi_req_tmo, "i");
+MODULE_PARM(lpfc17_lun_skip, "i");
+
+MODULE_PARM(lpfc18_log_verbose, "i");
+MODULE_PARM(lpfc18_lun_queue_depth, "i");
+MODULE_PARM(lpfc18_tgt_queue_depth, "i");
+MODULE_PARM(lpfc18_no_device_delay, "i");
+MODULE_PARM(lpfc18_xmt_que_size, "i");
+MODULE_PARM(lpfc18_scan_down, "i");
+MODULE_PARM(lpfc18_linkdown_tmo, "i");
+MODULE_PARM(lpfc18_nodev_tmo, "i");
+MODULE_PARM(lpfc18_delay_rsp_err, "i");
+MODULE_PARM(lpfc18_nodev_holdio, "i");
+MODULE_PARM(lpfc18_check_cond_err, "i");
+MODULE_PARM(lpfc18_topology, "i");
+MODULE_PARM(lpfc18_link_speed, "i");
+MODULE_PARM(lpfc18_fcp_class, "i");
+MODULE_PARM(lpfc18_use_adisc, "i");
+MODULE_PARM(lpfc18_extra_io_tmo, "i");
+MODULE_PARM(lpfc18_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc18_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc18_ack0, "i");
+MODULE_PARM(lpfc18_automap, "i");
+MODULE_PARM(lpfc18_fcp_bind_method, "i");
+MODULE_PARM(lpfc18_cr_delay, "i");
+MODULE_PARM(lpfc18_cr_count, "i");
+MODULE_PARM(lpfc18_fdmi_on, "i");
+MODULE_PARM(lpfc18_max_lun, "i");
+MODULE_PARM(lpfc18_discovery_threads, "i");
+MODULE_PARM(lpfc18_max_target, "i");
+MODULE_PARM(lpfc18_scsi_req_tmo, "i");
+MODULE_PARM(lpfc18_lun_skip, "i");
+
+MODULE_PARM(lpfc19_log_verbose, "i");
+MODULE_PARM(lpfc19_lun_queue_depth, "i");
+MODULE_PARM(lpfc19_tgt_queue_depth, "i");
+MODULE_PARM(lpfc19_no_device_delay, "i");
+MODULE_PARM(lpfc19_xmt_que_size, "i");
+MODULE_PARM(lpfc19_scan_down, "i");
+MODULE_PARM(lpfc19_linkdown_tmo, "i");
+MODULE_PARM(lpfc19_nodev_tmo, "i");
+MODULE_PARM(lpfc19_delay_rsp_err, "i");
+MODULE_PARM(lpfc19_nodev_holdio, "i");
+MODULE_PARM(lpfc19_check_cond_err, "i");
+MODULE_PARM(lpfc19_topology, "i");
+MODULE_PARM(lpfc19_link_speed, "i");
+MODULE_PARM(lpfc19_fcp_class, "i");
+MODULE_PARM(lpfc19_use_adisc, "i");
+MODULE_PARM(lpfc19_extra_io_tmo, "i");
+MODULE_PARM(lpfc19_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc19_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc19_ack0, "i");
+MODULE_PARM(lpfc19_automap, "i");
+MODULE_PARM(lpfc19_fcp_bind_method, "i");
+MODULE_PARM(lpfc19_cr_delay, "i");
+MODULE_PARM(lpfc19_cr_count, "i");
+MODULE_PARM(lpfc19_fdmi_on, "i");
+MODULE_PARM(lpfc19_max_lun, "i");
+MODULE_PARM(lpfc19_discovery_threads, "i");
+MODULE_PARM(lpfc19_max_target, "i");
+MODULE_PARM(lpfc19_scsi_req_tmo, "i");
+MODULE_PARM(lpfc19_lun_skip, "i");
+
+MODULE_PARM(lpfc20_log_verbose, "i");
+MODULE_PARM(lpfc20_lun_queue_depth, "i");
+MODULE_PARM(lpfc20_tgt_queue_depth, "i");
+MODULE_PARM(lpfc20_no_device_delay, "i");
+MODULE_PARM(lpfc20_xmt_que_size, "i");
+MODULE_PARM(lpfc20_scan_down, "i");
+MODULE_PARM(lpfc20_linkdown_tmo, "i");
+MODULE_PARM(lpfc20_nodev_tmo, "i");
+MODULE_PARM(lpfc20_delay_rsp_err, "i");
+MODULE_PARM(lpfc20_nodev_holdio, "i");
+MODULE_PARM(lpfc20_check_cond_err, "i");
+MODULE_PARM(lpfc20_topology, "i");
+MODULE_PARM(lpfc20_link_speed, "i");
+MODULE_PARM(lpfc20_fcp_class, "i");
+MODULE_PARM(lpfc20_use_adisc, "i");
+MODULE_PARM(lpfc20_extra_io_tmo, "i");
+MODULE_PARM(lpfc20_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc20_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc20_ack0, "i");
+MODULE_PARM(lpfc20_automap, "i");
+MODULE_PARM(lpfc20_fcp_bind_method, "i");
+MODULE_PARM(lpfc20_cr_delay, "i");
+MODULE_PARM(lpfc20_cr_count, "i");
+MODULE_PARM(lpfc20_fdmi_on, "i");
+MODULE_PARM(lpfc20_max_lun, "i");
+MODULE_PARM(lpfc20_discovery_threads, "i");
+MODULE_PARM(lpfc20_max_target, "i");
+MODULE_PARM(lpfc20_scsi_req_tmo, "i");
+MODULE_PARM(lpfc20_lun_skip, "i");
+
+MODULE_PARM(lpfc21_log_verbose, "i");
+MODULE_PARM(lpfc21_lun_queue_depth, "i");
+MODULE_PARM(lpfc21_tgt_queue_depth, "i");
+MODULE_PARM(lpfc21_no_device_delay, "i");
+MODULE_PARM(lpfc21_xmt_que_size, "i");
+MODULE_PARM(lpfc21_scan_down, "i");
+MODULE_PARM(lpfc21_linkdown_tmo, "i");
+MODULE_PARM(lpfc21_nodev_tmo, "i");
+MODULE_PARM(lpfc21_delay_rsp_err, "i");
+MODULE_PARM(lpfc21_nodev_holdio, "i");
+MODULE_PARM(lpfc21_check_cond_err, "i");
+MODULE_PARM(lpfc21_topology, "i");
+MODULE_PARM(lpfc21_link_speed, "i");
+MODULE_PARM(lpfc21_fcp_class, "i");
+MODULE_PARM(lpfc21_use_adisc, "i");
+MODULE_PARM(lpfc21_extra_io_tmo, "i");
+MODULE_PARM(lpfc21_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc21_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc21_ack0, "i");
+MODULE_PARM(lpfc21_automap, "i");
+MODULE_PARM(lpfc21_fcp_bind_method, "i");
+MODULE_PARM(lpfc21_cr_delay, "i");
+MODULE_PARM(lpfc21_cr_count, "i");
+MODULE_PARM(lpfc21_fdmi_on, "i");
+MODULE_PARM(lpfc21_max_lun, "i");
+MODULE_PARM(lpfc21_discovery_threads, "i");
+MODULE_PARM(lpfc21_max_target, "i");
+MODULE_PARM(lpfc21_scsi_req_tmo, "i");
+MODULE_PARM(lpfc21_lun_skip, "i");
+
+MODULE_PARM(lpfc22_log_verbose, "i");
+MODULE_PARM(lpfc22_lun_queue_depth, "i");
+MODULE_PARM(lpfc22_tgt_queue_depth, "i");
+MODULE_PARM(lpfc22_no_device_delay, "i");
+MODULE_PARM(lpfc22_xmt_que_size, "i");
+MODULE_PARM(lpfc22_scan_down, "i");
+MODULE_PARM(lpfc22_linkdown_tmo, "i");
+MODULE_PARM(lpfc22_nodev_tmo, "i");
+MODULE_PARM(lpfc22_delay_rsp_err, "i");
+MODULE_PARM(lpfc22_nodev_holdio, "i");
+MODULE_PARM(lpfc22_check_cond_err, "i");
+MODULE_PARM(lpfc22_topology, "i");
+MODULE_PARM(lpfc22_link_speed, "i");
+MODULE_PARM(lpfc22_fcp_class, "i");
+MODULE_PARM(lpfc22_use_adisc, "i");
+MODULE_PARM(lpfc22_extra_io_tmo, "i");
+MODULE_PARM(lpfc22_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc22_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc22_ack0, "i");
+MODULE_PARM(lpfc22_automap, "i");
+MODULE_PARM(lpfc22_fcp_bind_method, "i");
+MODULE_PARM(lpfc22_cr_delay, "i");
+MODULE_PARM(lpfc22_cr_count, "i");
+MODULE_PARM(lpfc22_fdmi_on, "i");
+MODULE_PARM(lpfc22_max_lun, "i");
+MODULE_PARM(lpfc22_discovery_threads, "i");
+MODULE_PARM(lpfc22_max_target, "i");
+MODULE_PARM(lpfc22_scsi_req_tmo, "i");
+MODULE_PARM(lpfc22_lun_skip, "i");
+
+MODULE_PARM(lpfc23_log_verbose, "i");
+MODULE_PARM(lpfc23_lun_queue_depth, "i");
+MODULE_PARM(lpfc23_tgt_queue_depth, "i");
+MODULE_PARM(lpfc23_no_device_delay, "i");
+MODULE_PARM(lpfc23_xmt_que_size, "i");
+MODULE_PARM(lpfc23_scan_down, "i");
+MODULE_PARM(lpfc23_linkdown_tmo, "i");
+MODULE_PARM(lpfc23_nodev_tmo, "i");
+MODULE_PARM(lpfc23_delay_rsp_err, "i");
+MODULE_PARM(lpfc23_nodev_holdio, "i");
+MODULE_PARM(lpfc23_check_cond_err, "i");
+MODULE_PARM(lpfc23_topology, "i");
+MODULE_PARM(lpfc23_link_speed, "i");
+MODULE_PARM(lpfc23_fcp_class, "i");
+MODULE_PARM(lpfc23_use_adisc, "i");
+MODULE_PARM(lpfc23_extra_io_tmo, "i");
+MODULE_PARM(lpfc23_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc23_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc23_ack0, "i");
+MODULE_PARM(lpfc23_automap, "i");
+MODULE_PARM(lpfc23_fcp_bind_method, "i");
+MODULE_PARM(lpfc23_cr_delay, "i");
+MODULE_PARM(lpfc23_cr_count, "i");
+MODULE_PARM(lpfc23_fdmi_on, "i");
+MODULE_PARM(lpfc23_max_lun, "i");
+MODULE_PARM(lpfc23_discovery_threads, "i");
+MODULE_PARM(lpfc23_max_target, "i");
+MODULE_PARM(lpfc23_scsi_req_tmo, "i");
+MODULE_PARM(lpfc23_lun_skip, "i");
+
+MODULE_PARM(lpfc24_log_verbose, "i");
+MODULE_PARM(lpfc24_lun_queue_depth, "i");
+MODULE_PARM(lpfc24_tgt_queue_depth, "i");
+MODULE_PARM(lpfc24_no_device_delay, "i");
+MODULE_PARM(lpfc24_xmt_que_size, "i");
+MODULE_PARM(lpfc24_scan_down, "i");
+MODULE_PARM(lpfc24_linkdown_tmo, "i");
+MODULE_PARM(lpfc24_nodev_tmo, "i");
+MODULE_PARM(lpfc24_delay_rsp_err, "i");
+MODULE_PARM(lpfc24_nodev_holdio, "i");
+MODULE_PARM(lpfc24_check_cond_err, "i");
+MODULE_PARM(lpfc24_topology, "i");
+MODULE_PARM(lpfc24_link_speed, "i");
+MODULE_PARM(lpfc24_fcp_class, "i");
+MODULE_PARM(lpfc24_use_adisc, "i");
+MODULE_PARM(lpfc24_extra_io_tmo, "i");
+MODULE_PARM(lpfc24_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc24_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc24_ack0, "i");
+MODULE_PARM(lpfc24_automap, "i");
+MODULE_PARM(lpfc24_fcp_bind_method, "i");
+MODULE_PARM(lpfc24_cr_delay, "i");
+MODULE_PARM(lpfc24_cr_count, "i");
+MODULE_PARM(lpfc24_fdmi_on, "i");
+MODULE_PARM(lpfc24_max_lun, "i");
+MODULE_PARM(lpfc24_discovery_threads, "i");
+MODULE_PARM(lpfc24_max_target, "i");
+MODULE_PARM(lpfc24_scsi_req_tmo, "i");
+MODULE_PARM(lpfc24_lun_skip, "i");
+
+MODULE_PARM(lpfc25_log_verbose, "i");
+MODULE_PARM(lpfc25_lun_queue_depth, "i");
+MODULE_PARM(lpfc25_tgt_queue_depth, "i");
+MODULE_PARM(lpfc25_no_device_delay, "i");
+MODULE_PARM(lpfc25_xmt_que_size, "i");
+MODULE_PARM(lpfc25_scan_down, "i");
+MODULE_PARM(lpfc25_linkdown_tmo, "i");
+MODULE_PARM(lpfc25_nodev_tmo, "i");
+MODULE_PARM(lpfc25_delay_rsp_err, "i");
+MODULE_PARM(lpfc25_nodev_holdio, "i");
+MODULE_PARM(lpfc25_check_cond_err, "i");
+MODULE_PARM(lpfc25_topology, "i");
+MODULE_PARM(lpfc25_link_speed, "i");
+MODULE_PARM(lpfc25_fcp_class, "i");
+MODULE_PARM(lpfc25_use_adisc, "i");
+MODULE_PARM(lpfc25_extra_io_tmo, "i");
+MODULE_PARM(lpfc25_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc25_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc25_ack0, "i");
+MODULE_PARM(lpfc25_automap, "i");
+MODULE_PARM(lpfc25_fcp_bind_method, "i");
+MODULE_PARM(lpfc25_cr_delay, "i");
+MODULE_PARM(lpfc25_cr_count, "i");
+MODULE_PARM(lpfc25_fdmi_on, "i");
+MODULE_PARM(lpfc25_max_lun, "i");
+MODULE_PARM(lpfc25_discovery_threads, "i");
+MODULE_PARM(lpfc25_max_target, "i");
+MODULE_PARM(lpfc25_scsi_req_tmo, "i");
+MODULE_PARM(lpfc25_lun_skip, "i");
+
+MODULE_PARM(lpfc26_log_verbose, "i");
+MODULE_PARM(lpfc26_lun_queue_depth, "i");
+MODULE_PARM(lpfc26_tgt_queue_depth, "i");
+MODULE_PARM(lpfc26_no_device_delay, "i");
+MODULE_PARM(lpfc26_xmt_que_size, "i");
+MODULE_PARM(lpfc26_scan_down, "i");
+MODULE_PARM(lpfc26_linkdown_tmo, "i");
+MODULE_PARM(lpfc26_nodev_tmo, "i");
+MODULE_PARM(lpfc26_delay_rsp_err, "i");
+MODULE_PARM(lpfc26_nodev_holdio, "i");
+MODULE_PARM(lpfc26_check_cond_err, "i");
+MODULE_PARM(lpfc26_topology, "i");
+MODULE_PARM(lpfc26_link_speed, "i");
+MODULE_PARM(lpfc26_fcp_class, "i");
+MODULE_PARM(lpfc26_use_adisc, "i");
+MODULE_PARM(lpfc26_extra_io_tmo, "i");
+MODULE_PARM(lpfc26_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc26_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc26_ack0, "i");
+MODULE_PARM(lpfc26_automap, "i");
+MODULE_PARM(lpfc26_fcp_bind_method, "i");
+MODULE_PARM(lpfc26_cr_delay, "i");
+MODULE_PARM(lpfc26_cr_count, "i");
+MODULE_PARM(lpfc26_fdmi_on, "i");
+MODULE_PARM(lpfc26_max_lun, "i");
+MODULE_PARM(lpfc26_discovery_threads, "i");
+MODULE_PARM(lpfc26_max_target, "i");
+MODULE_PARM(lpfc26_scsi_req_tmo, "i");
+MODULE_PARM(lpfc26_lun_skip, "i");
+
+MODULE_PARM(lpfc27_log_verbose, "i");
+MODULE_PARM(lpfc27_lun_queue_depth, "i");
+MODULE_PARM(lpfc27_tgt_queue_depth, "i");
+MODULE_PARM(lpfc27_no_device_delay, "i");
+MODULE_PARM(lpfc27_xmt_que_size, "i");
+MODULE_PARM(lpfc27_scan_down, "i");
+MODULE_PARM(lpfc27_linkdown_tmo, "i");
+MODULE_PARM(lpfc27_nodev_tmo, "i");
+MODULE_PARM(lpfc27_delay_rsp_err, "i");
+MODULE_PARM(lpfc27_nodev_holdio, "i");
+MODULE_PARM(lpfc27_check_cond_err, "i");
+MODULE_PARM(lpfc27_topology, "i");
+MODULE_PARM(lpfc27_link_speed, "i");
+MODULE_PARM(lpfc27_fcp_class, "i");
+MODULE_PARM(lpfc27_use_adisc, "i");
+MODULE_PARM(lpfc27_extra_io_tmo, "i");
+MODULE_PARM(lpfc27_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc27_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc27_ack0, "i");
+MODULE_PARM(lpfc27_automap, "i");
+MODULE_PARM(lpfc27_fcp_bind_method, "i");
+MODULE_PARM(lpfc27_cr_delay, "i");
+MODULE_PARM(lpfc27_cr_count, "i");
+MODULE_PARM(lpfc27_fdmi_on, "i");
+MODULE_PARM(lpfc27_max_lun, "i");
+MODULE_PARM(lpfc27_discovery_threads, "i");
+MODULE_PARM(lpfc27_max_target, "i");
+MODULE_PARM(lpfc27_scsi_req_tmo, "i");
+MODULE_PARM(lpfc27_lun_skip, "i");
+
+MODULE_PARM(lpfc28_log_verbose, "i");
+MODULE_PARM(lpfc28_lun_queue_depth, "i");
+MODULE_PARM(lpfc28_tgt_queue_depth, "i");
+MODULE_PARM(lpfc28_no_device_delay, "i");
+MODULE_PARM(lpfc28_xmt_que_size, "i");
+MODULE_PARM(lpfc28_scan_down, "i");
+MODULE_PARM(lpfc28_linkdown_tmo, "i");
+MODULE_PARM(lpfc28_nodev_tmo, "i");
+MODULE_PARM(lpfc28_delay_rsp_err, "i");
+MODULE_PARM(lpfc28_nodev_holdio, "i");
+MODULE_PARM(lpfc28_check_cond_err, "i");
+MODULE_PARM(lpfc28_topology, "i");
+MODULE_PARM(lpfc28_link_speed, "i");
+MODULE_PARM(lpfc28_fcp_class, "i");
+MODULE_PARM(lpfc28_use_adisc, "i");
+MODULE_PARM(lpfc28_extra_io_tmo, "i");
+MODULE_PARM(lpfc28_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc28_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc28_ack0, "i");
+MODULE_PARM(lpfc28_automap, "i");
+MODULE_PARM(lpfc28_fcp_bind_method, "i");
+MODULE_PARM(lpfc28_cr_delay, "i");
+MODULE_PARM(lpfc28_cr_count, "i");
+MODULE_PARM(lpfc28_fdmi_on, "i");
+MODULE_PARM(lpfc28_max_lun, "i");
+MODULE_PARM(lpfc28_discovery_threads, "i");
+MODULE_PARM(lpfc28_max_target, "i");
+MODULE_PARM(lpfc28_scsi_req_tmo, "i");
+MODULE_PARM(lpfc28_lun_skip, "i");
+
+MODULE_PARM(lpfc29_log_verbose, "i");
+MODULE_PARM(lpfc29_lun_queue_depth, "i");
+MODULE_PARM(lpfc29_tgt_queue_depth, "i");
+MODULE_PARM(lpfc29_no_device_delay, "i");
+MODULE_PARM(lpfc29_xmt_que_size, "i");
+MODULE_PARM(lpfc29_scan_down, "i");
+MODULE_PARM(lpfc29_linkdown_tmo, "i");
+MODULE_PARM(lpfc29_nodev_tmo, "i");
+MODULE_PARM(lpfc29_delay_rsp_err, "i");
+MODULE_PARM(lpfc29_nodev_holdio, "i");
+MODULE_PARM(lpfc29_check_cond_err, "i");
+MODULE_PARM(lpfc29_topology, "i");
+MODULE_PARM(lpfc29_link_speed, "i");
+MODULE_PARM(lpfc29_fcp_class, "i");
+MODULE_PARM(lpfc29_use_adisc, "i");
+MODULE_PARM(lpfc29_extra_io_tmo, "i");
+MODULE_PARM(lpfc29_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc29_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc29_ack0, "i");
+MODULE_PARM(lpfc29_automap, "i");
+MODULE_PARM(lpfc29_fcp_bind_method, "i");
+MODULE_PARM(lpfc29_cr_delay, "i");
+MODULE_PARM(lpfc29_cr_count, "i");
+MODULE_PARM(lpfc29_fdmi_on, "i");
+MODULE_PARM(lpfc29_max_lun, "i");
+MODULE_PARM(lpfc29_discovery_threads, "i");
+MODULE_PARM(lpfc29_max_target, "i");
+MODULE_PARM(lpfc29_scsi_req_tmo, "i");
+MODULE_PARM(lpfc29_lun_skip, "i");
+
+MODULE_PARM(lpfc30_log_verbose, "i");
+MODULE_PARM(lpfc30_lun_queue_depth, "i");
+MODULE_PARM(lpfc30_tgt_queue_depth, "i");
+MODULE_PARM(lpfc30_no_device_delay, "i");
+MODULE_PARM(lpfc30_xmt_que_size, "i");
+MODULE_PARM(lpfc30_scan_down, "i");
+MODULE_PARM(lpfc30_linkdown_tmo, "i");
+MODULE_PARM(lpfc30_nodev_tmo, "i");
+MODULE_PARM(lpfc30_delay_rsp_err, "i");
+MODULE_PARM(lpfc30_nodev_holdio, "i");
+MODULE_PARM(lpfc30_check_cond_err, "i");
+MODULE_PARM(lpfc30_topology, "i");
+MODULE_PARM(lpfc30_link_speed, "i");
+MODULE_PARM(lpfc30_fcp_class, "i");
+MODULE_PARM(lpfc30_use_adisc, "i");
+MODULE_PARM(lpfc30_extra_io_tmo, "i");
+MODULE_PARM(lpfc30_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc30_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc30_ack0, "i");
+MODULE_PARM(lpfc30_automap, "i");
+MODULE_PARM(lpfc30_fcp_bind_method, "i");
+MODULE_PARM(lpfc30_cr_delay, "i");
+MODULE_PARM(lpfc30_cr_count, "i");
+MODULE_PARM(lpfc30_fdmi_on, "i");
+MODULE_PARM(lpfc30_max_lun, "i");
+MODULE_PARM(lpfc30_discovery_threads, "i");
+MODULE_PARM(lpfc30_max_target, "i");
+MODULE_PARM(lpfc30_scsi_req_tmo, "i");
+MODULE_PARM(lpfc30_lun_skip, "i");
+
+MODULE_PARM(lpfc31_log_verbose, "i");
+MODULE_PARM(lpfc31_lun_queue_depth, "i");
+MODULE_PARM(lpfc31_tgt_queue_depth, "i");
+MODULE_PARM(lpfc31_no_device_delay, "i");
+MODULE_PARM(lpfc31_xmt_que_size, "i");
+MODULE_PARM(lpfc31_scan_down, "i");
+MODULE_PARM(lpfc31_linkdown_tmo, "i");
+MODULE_PARM(lpfc31_nodev_tmo, "i");
+MODULE_PARM(lpfc31_delay_rsp_err, "i");
+MODULE_PARM(lpfc31_nodev_holdio, "i");
+MODULE_PARM(lpfc31_check_cond_err, "i");
+MODULE_PARM(lpfc31_topology, "i");
+MODULE_PARM(lpfc31_link_speed, "i");
+MODULE_PARM(lpfc31_fcp_class, "i");
+MODULE_PARM(lpfc31_use_adisc, "i");
+MODULE_PARM(lpfc31_extra_io_tmo, "i");
+MODULE_PARM(lpfc31_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc31_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc31_ack0, "i");
+MODULE_PARM(lpfc31_automap, "i");
+MODULE_PARM(lpfc31_fcp_bind_method, "i");
+MODULE_PARM(lpfc31_cr_delay, "i");
+MODULE_PARM(lpfc31_cr_count, "i");
+MODULE_PARM(lpfc31_fdmi_on, "i");
+MODULE_PARM(lpfc31_max_lun, "i");
+MODULE_PARM(lpfc31_discovery_threads, "i");
+MODULE_PARM(lpfc31_max_target, "i");
+MODULE_PARM(lpfc31_scsi_req_tmo, "i");
+MODULE_PARM(lpfc31_lun_skip, "i");
+
+MODULE_PARM(lpfc_log_verbose, "i");
+MODULE_PARM(lpfc_lun_queue_depth, "i");
+MODULE_PARM(lpfc_tgt_queue_depth, "i");
+MODULE_PARM(lpfc_no_device_delay, "i");
+MODULE_PARM(lpfc_xmt_que_size, "i");
+MODULE_PARM(lpfc_scan_down, "i");
+MODULE_PARM(lpfc_linkdown_tmo, "i");
+MODULE_PARM(lpfc_nodev_tmo, "i");
+MODULE_PARM(lpfc_delay_rsp_err, "i");
+MODULE_PARM(lpfc_nodev_holdio, "i");
+MODULE_PARM(lpfc_check_cond_err, "i");
+MODULE_PARM(lpfc_topology, "i");
+MODULE_PARM(lpfc_link_speed, "i");
+MODULE_PARM(lpfc_fcp_class, "i");
+MODULE_PARM(lpfc_use_adisc, "i");
+MODULE_PARM(lpfc_extra_io_tmo, "i");
+MODULE_PARM(lpfc_dqfull_throttle_up_time, "i");
+MODULE_PARM(lpfc_dqfull_throttle_up_inc, "i");
+MODULE_PARM(lpfc_ack0, "i");
+MODULE_PARM(lpfc_automap, "i");
+MODULE_PARM(lpfc_fcp_bind_method, "i");
+MODULE_PARM(lpfc_cr_delay, "i");
+MODULE_PARM(lpfc_cr_count, "i");
+MODULE_PARM(lpfc_fdmi_on, "i");
+MODULE_PARM(lpfc_max_lun, "i");
+MODULE_PARM(lpfc_discovery_threads, "i");
+MODULE_PARM(lpfc_scsi_req_tmo, "i");
+MODULE_PARM(lpfc_max_target, "i");
+MODULE_PARM(lpfc_fcp_bind_WWPN, "1-" __MODULE_STRING(MAX_FC_BINDINGS) "s");
+MODULE_PARM(lpfc_fcp_bind_WWNN, "1-" __MODULE_STRING(MAX_FC_BINDINGS) "s");
+MODULE_PARM(lpfc_fcp_bind_DID, "1-" __MODULE_STRING(MAX_FC_BINDINGS) "s");
+MODULE_PARM(lpfc_lun_skip, "i");
+MODULE_PARM(lpfc_inq_pqb_filter, "i");
+
+#endif
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_nportdisc.c linux-8155/drivers/addon/lpfc/lpfc_nportdisc.c
--- linux-8152/drivers/addon/lpfc/lpfc_nportdisc.c
+++ linux-8155/drivers/addon/lpfc/lpfc_nportdisc.c
@@ -0,0 +1,2945 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_nportdisc.c 502 2006-04-04 17:11:23Z sf_support $
+ */
+
+#include <linux/version.h>
+#include <linux/spinlock.h>
+#include <linux/pci.h>
+
+
+#include <linux/blk.h>
+#include <scsi.h>
+
+#include "lpfc_hw.h"
+#include "lpfc_sli.h"
+#include "lpfc_mem.h"
+#include "lpfc_sched.h"
+#include "lpfc_disc.h"
+#include "lpfc.h"
+#include "lpfc_logmsg.h"
+#include "lpfc_scsi.h"
+#include "lpfc_cfgparm.h"
+#include "lpfc_hw.h"
+#include "lpfc_crtn.h"
+
+/* This next section defines the NPort Discovery State Machine */
+
+/* There are 4 different double linked lists nodelist entries can reside on.
+ * The plogi list and adisc list are used when Link Up discovery or RSCN 
+ * processing is needed. Each list holds the nodes that we will send PLOGI
+ * or ADISC on. These lists will keep track of what nodes will be effected
+ * by an RSCN, or a Link Up (Typically, all nodes are effected on Link Up).
+ * The unmapped_list will contain all nodes that we have successfully logged
+ * into at the Fibre Channel level. The mapped_list will contain all nodes
+ * that are mapped FCP targets.
+ */
+/*
+ * The bind list is a list of undiscovered (potentially non-existent) nodes
+ * that we have saved binding information on. This information is used when
+ * nodes transition from the unmapped to the mapped list.
+ */
+/* For UNUSED_NODE state, the node has just been allocated .
+ * For PLOGI_ISSUE and REG_LOGIN_ISSUE, the node is on
+ * the PLOGI list. For REG_LOGIN_COMPL, the node is taken off the PLOGI list
+ * and put on the unmapped list. For ADISC processing, the node is taken off 
+ * the ADISC list and placed on either the mapped or unmapped list (depending
+ * on its previous state). Once on the unmapped list, a PRLI is issued and the
+ * state changed to PRLI_ISSUE. When the PRLI completion occurs, the state is
+ * changed to PRLI_COMPL. If the completion indicates a mapped
+ * node, the node is taken off the unmapped list. The binding list is checked
+ * for a valid binding, or a binding is automatically assigned. If binding
+ * assignment is unsuccessful, the node is left on the unmapped list. If
+ * binding assignment is successful, the associated binding list entry (if
+ * any) is removed, and the node is placed on the mapped list. 
+ */
+/*
+ * For a Link Down, all nodes on the ADISC, PLOGI, unmapped or mapped
+ * lists will receive a DEVICE_UNK event. If the linkdown or nodev timers
+ * expire, all effected nodes will receive a DEVICE_RM event.
+ */
+/*
+ * For a Link Up or RSCN, all nodes will move from the mapped / unmapped lists
+ * to either the ADISC or PLOGI list.  After a Nameserver query or ALPA loopmap
+ * check, additional nodes may be added (DEVICE_ADD) or removed (DEVICE_RM) to /
+ * from the PLOGI or ADISC lists. Once the PLOGI and ADISC lists are populated,
+ * we will first process the ADISC list.  32 entries are processed initially and
+ * ADISC is initited for each one.  Completions / Events for each node are
+ * funnelled thru the state machine.  As each node finishes ADISC processing, it
+ * starts ADISC for any nodes waiting for ADISC processing. If no nodes are
+ * waiting, and the ADISC list count is identically 0, then we are done. For
+ * Link Up discovery, since all nodes on the PLOGI list are UNREG_LOGIN'ed, we
+ * can issue a CLEAR_LA and reenable Link Events. Next we will process the PLOGI
+ * list.  32 entries are processed initially and PLOGI is initited for each one.
+ * Completions / Events for each node are funnelled thru the state machine.  As
+ * each node finishes PLOGI processing, it starts PLOGI for any nodes waiting
+ * for PLOGI processing. If no nodes are waiting, and the PLOGI list count is
+ * indentically 0, then we are done. We have now completed discovery / RSCN
+ * handling. Upon completion, ALL nodes should be on either the mapped or
+ * unmapped lists.
+ */
+
+void *lpfc_disc_action[NLP_STE_MAX_STATE * NLP_EVT_MAX_EVENT] = {
+	/* Action routine                          Event       Current State  */
+	(void *)lpfc_rcv_plogi_unused_node,	/* RCV_PLOGI   UNUSED_NODE    */
+	(void *)lpfc_rcv_els_unused_node,	/* RCV_PRLI        */
+	(void *)lpfc_rcv_logo_unused_node,	/* RCV_LOGO        */
+	(void *)lpfc_rcv_els_unused_node,	/* RCV_ADISC       */
+	(void *)lpfc_rcv_els_unused_node,	/* RCV_PDISC       */
+	(void *)lpfc_rcv_els_unused_node,	/* RCV_PRLO        */
+	(void *)lpfc_cmpl_els_unused_node,	/* CMPL_PLOGI      */
+	(void *)lpfc_cmpl_els_unused_node,	/* CMPL_PRLI       */
+	(void *)lpfc_cmpl_els_unused_node,	/* CMPL_LOGO       */
+	(void *)lpfc_cmpl_els_unused_node,	/* CMPL_ADISC      */
+	(void *)lpfc_cmpl_reglogin_unused_node,	/* CMPL_REG_LOGIN  */
+	(void *)lpfc_device_rm_unused_node,	/* DEVICE_RM       */
+	(void *)lpfc_device_add_unused_node,	/* DEVICE_ADD      */
+	(void *)lpfc_device_unk_unused_node,	/* DEVICE_UNK      */
+	(void *)lpfc_rcv_plogi_plogi_issue,	/* RCV_PLOGI   PLOGI_ISSUE    */
+	(void *)lpfc_rcv_prli_plogi_issue,	/* RCV_PRLI        */
+	(void *)lpfc_rcv_logo_plogi_issue,	/* RCV_LOGO        */
+	(void *)lpfc_rcv_els_plogi_issue,	/* RCV_ADISC       */
+	(void *)lpfc_rcv_els_plogi_issue,	/* RCV_PDISC       */
+	(void *)lpfc_rcv_els_plogi_issue,	/* RCV_PRLO        */
+	(void *)lpfc_cmpl_plogi_plogi_issue,	/* CMPL_PLOGI      */
+	(void *)lpfc_cmpl_prli_plogi_issue,	/* CMPL_PRLI       */
+	(void *)lpfc_cmpl_logo_plogi_issue,	/* CMPL_LOGO       */
+	(void *)lpfc_cmpl_adisc_plogi_issue,	/* CMPL_ADISC      */
+	(void *)lpfc_cmpl_reglogin_plogi_issue,	/* CMPL_REG_LOGIN  */
+	(void *)lpfc_device_rm_plogi_issue,	/* DEVICE_RM       */
+	(void *)lpfc_disc_nodev,	/* DEVICE_ADD      */
+	(void *)lpfc_device_unk_plogi_issue,	/* DEVICE_UNK      */
+	(void *)lpfc_rcv_plogi_reglogin_issue,	/* RCV_PLOGI  REG_LOGIN_ISSUE */
+	(void *)lpfc_rcv_prli_reglogin_issue,	/* RCV_PLOGI       */
+	(void *)lpfc_rcv_logo_reglogin_issue,	/* RCV_LOGO        */
+	(void *)lpfc_rcv_padisc_reglogin_issue,	/* RCV_ADISC       */
+	(void *)lpfc_rcv_padisc_reglogin_issue,	/* RCV_PDISC       */
+	(void *)lpfc_rcv_prlo_reglogin_issue,	/* RCV_PRLO        */
+	(void *)lpfc_disc_neverdev,	/* CMPL_PLOGI      */
+	(void *)lpfc_disc_neverdev,	/* CMPL_PRLI       */
+	(void *)lpfc_cmpl_logo_reglogin_issue,	/* CMPL_LOGO       */
+	(void *)lpfc_cmpl_adisc_reglogin_issue,	/* CMPL_ADISC      */
+	(void *)lpfc_cmpl_reglogin_reglogin_issue,	/* CMPL_REG_LOGIN  */
+	(void *)lpfc_device_rm_reglogin_issue,	/* DEVICE_RM       */
+	(void *)lpfc_disc_nodev,	/* DEVICE_ADD      */
+	(void *)lpfc_device_unk_reglogin_issue,	/* DEVICE_UNK      */
+	(void *)lpfc_rcv_plogi_prli_issue,	/* RCV_PLOGI   PRLI_ISSUE     */
+	(void *)lpfc_rcv_prli_prli_issue,	/* RCV_PRLI        */
+	(void *)lpfc_rcv_logo_prli_issue,	/* RCV_LOGO        */
+	(void *)lpfc_rcv_padisc_prli_issue,	/* RCV_ADISC       */
+	(void *)lpfc_rcv_padisc_prli_issue,	/* RCV_PDISC       */
+	(void *)lpfc_rcv_prlo_prli_issue,	/* RCV_PRLO        */
+	(void *)lpfc_disc_neverdev,	/* CMPL_PLOGI      */
+	(void *)lpfc_cmpl_prli_prli_issue,	/* CMPL_PRLI       */
+	(void *)lpfc_cmpl_logo_prli_issue,	/* CMPL_LOGO       */
+	(void *)lpfc_cmpl_adisc_prli_issue,	/* CMPL_ADISC      */
+	(void *)lpfc_cmpl_reglogin_prli_issue,	/* CMPL_REG_LOGIN  */
+	(void *)lpfc_device_rm_prli_issue,	/* DEVICE_RM       */
+	(void *)lpfc_device_add_prli_issue,	/* DEVICE_ADD      */
+	(void *)lpfc_device_unk_prli_issue,	/* DEVICE_UNK      */
+	(void *)lpfc_rcv_plogi_prli_compl,	/* RCV_PLOGI   PRLI_COMPL     */
+	(void *)lpfc_rcv_prli_prli_compl,	/* RCV_PRLI        */
+	(void *)lpfc_rcv_logo_prli_compl,	/* RCV_LOGO        */
+	(void *)lpfc_rcv_padisc_prli_compl,	/* RCV_ADISC       */
+	(void *)lpfc_rcv_padisc_prli_compl,	/* RCV_PDISC       */
+	(void *)lpfc_rcv_prlo_prli_compl,	/* RCV_PRLO        */
+	(void *)lpfc_disc_neverdev,	/* CMPL_PLOGI      */
+	(void *)lpfc_disc_neverdev,	/* CMPL_PRLI       */
+	(void *)lpfc_cmpl_logo_prli_compl,	/* CMPL_LOGO       */
+	(void *)lpfc_cmpl_adisc_prli_compl,	/* CMPL_ADISC      */
+	(void *)lpfc_cmpl_reglogin_prli_compl,	/* CMPL_REG_LOGIN  */
+	(void *)lpfc_device_rm_prli_compl,	/* DEVICE_RM       */
+	(void *)lpfc_device_add_prli_compl,	/* DEVICE_ADD      */
+	(void *)lpfc_device_unk_prli_compl,	/* DEVICE_UNK      */
+	(void *)lpfc_rcv_plogi_mapped_node,	/* RCV_PLOGI   MAPPED_NODE    */
+	(void *)lpfc_rcv_prli_mapped_node,	/* RCV_PRLI        */
+	(void *)lpfc_rcv_logo_mapped_node,	/* RCV_LOGO        */
+	(void *)lpfc_rcv_padisc_mapped_node,	/* RCV_ADISC       */
+	(void *)lpfc_rcv_padisc_mapped_node,	/* RCV_PDISC       */
+	(void *)lpfc_rcv_prlo_mapped_node,	/* RCV_PRLO        */
+	(void *)lpfc_disc_neverdev,	/* CMPL_PLOGI      */
+	(void *)lpfc_disc_neverdev,	/* CMPL_PRLI       */
+	(void *)lpfc_cmpl_logo_mapped_node,	/* CMPL_LOGO       */
+	(void *)lpfc_cmpl_adisc_mapped_node,	/* CMPL_ADISC      */
+	(void *)lpfc_cmpl_reglogin_mapped_node,	/* CMPL_REG_LOGIN  */
+	(void *)lpfc_device_rm_mapped_node,	/* DEVICE_RM       */
+	(void *)lpfc_device_add_mapped_node,	/* DEVICE_ADD      */
+	(void *)lpfc_device_unk_mapped_node,	/* DEVICE_UNK      */
+};
+
+extern uint8_t lpfcAlpaArray[];
+
+int lpfc_check_adisc(lpfcHBA_t *, LPFC_NODELIST_t *, NAME_TYPE *, NAME_TYPE *);
+int lpfc_geportname(NAME_TYPE *, NAME_TYPE *);
+LPFC_BINDLIST_t *lpfc_assign_scsid(lpfcHBA_t *, LPFC_NODELIST_t *, int);
+
+int
+lpfc_disc_state_machine(lpfcHBA_t * phba,
+			LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	uint32_t cur_state, rc;
+	uint32_t(*func) (lpfcHBA_t *, LPFC_NODELIST_t *, void *, uint32_t);
+
+	ndlp->nlp_disc_refcnt++;
+	cur_state = ndlp->nlp_state;
+
+	/* DSM in event <evt> on NPort <nlp_DID> in state <cur_state> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0211,
+		       lpfc_mes0211,
+		       lpfc_msgBlk0211.msgPreambleStr,
+		       evt, ndlp->nlp_DID, cur_state, ndlp->nlp_flag);
+
+	func = (uint32_t(*)(lpfcHBA_t *, LPFC_NODELIST_t *, void *, uint32_t))
+	    lpfc_disc_action[(cur_state * NLP_EVT_MAX_EVENT) + evt];
+	rc = (func) (phba, ndlp, arg, evt);
+
+	/* DSM out state <rc> on NPort <nlp_DID> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0212,
+		       lpfc_mes0212,
+		       lpfc_msgBlk0212.msgPreambleStr,
+		       rc, ndlp->nlp_DID, ndlp->nlp_flag);
+
+	ndlp->nlp_disc_refcnt--;
+
+	/* Check to see if ndlp removal is deferred */
+	if((ndlp->nlp_disc_refcnt == 0) && (ndlp->nlp_rflag & NLP_DELAY_REMOVE)) {
+		ndlp->nlp_rflag &= ~NLP_DELAY_REMOVE;
+		lpfc_nlp_remove(phba, ndlp);
+		return (NLP_STE_FREED_NODE);
+	}
+	if (rc == NLP_STE_FREED_NODE)
+		return (NLP_STE_FREED_NODE);
+	ndlp->nlp_state = rc;
+	return (rc);
+}
+
+uint32_t
+lpfc_rcv_plogi(lpfcHBA_t * phba,
+			   LPFC_NODELIST_t * ndlp, LPFC_IOCBQ_t *cmdiocb)
+{
+	DMABUF_t *pCmd;
+	uint32_t *lp;
+	IOCB_t *icmd;
+	SERV_PARM *sp;
+	LPFC_MBOXQ_t *mbox;
+	lpfcCfgParam_t *clp;
+
+	clp = &phba->config[0];
+	icmd = &cmdiocb->iocb;
+	pCmd = (DMABUF_t *) cmdiocb->context2;
+	lp = (uint32_t *) pCmd->virt;
+	sp = (SERV_PARM *) ((uint8_t *) lp + sizeof (uint32_t));
+
+	if ((clp[LPFC_CFG_FCP_CLASS].a_current == CLASS2) &&
+	    (sp->cls2.classValid)) {
+		ndlp->nlp_fcp_info |= CLASS2;
+	} else {
+		ndlp->nlp_fcp_info |= CLASS3;
+	}
+
+	if ((mbox = lpfc_mbox_alloc(phba, MEM_PRI)) == 0) {
+		return (ndlp->nlp_state);
+	}
+	if ((phba->fc_flag & FC_PT2PT)
+	    && !(phba->fc_flag & FC_PT2PT_PLOGI)) {
+		/* The rcv'ed PLOGI determines what our NPortId will
+		   be */
+		phba->fc_myDID = icmd->un.rcvels.parmRo;
+		lpfc_config_link(phba, mbox);
+		if (lpfc_sli_issue_mbox
+		    (phba, mbox, (MBX_NOWAIT | MBX_STOP_IOCB))
+		    == MBX_NOT_FINISHED) {
+			lpfc_mbox_free(phba, mbox);
+			return (ndlp->nlp_state);
+		}
+		if ((mbox = lpfc_mbox_alloc(phba, MEM_PRI)) == 0) {
+			return (ndlp->nlp_state);
+		}
+	}
+	if (lpfc_reg_login(phba, icmd->un.rcvels.remoteID,
+			   (uint8_t *) sp, mbox, 0) == 0) {
+		mbox->mbox_cmpl = lpfc_mbx_cmpl_reg_login;
+		mbox->context2 = ndlp;
+		ndlp->nlp_state = NLP_STE_REG_LOGIN_ISSUE;
+		if (lpfc_sli_issue_mbox
+		    (phba, mbox, (MBX_NOWAIT | MBX_STOP_IOCB))
+		    != MBX_NOT_FINISHED) {
+			lpfc_nlp_plogi(phba, ndlp);
+			lpfc_els_rsp_acc(phba, ELS_CMD_PLOGI, cmdiocb,
+					 ndlp, 0, 0);
+			return (ndlp->nlp_state);	/* HAPPY PATH */
+		}
+		/* NOTE: we should have messages for unsuccessful
+		   reglogin */
+		lpfc_mbox_free(phba, mbox);
+	} else {
+		lpfc_mbox_free(phba, mbox);
+	}
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_rcv_plogi_unused_node(lpfcHBA_t * phba,
+			   LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+	DMABUF_t *pCmd;
+	uint32_t *lp;
+	SERV_PARM *sp;
+	lpfcCfgParam_t *clp;
+	LS_RJT stat;
+
+	clp = &phba->config[0];
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+	pCmd = (DMABUF_t *) cmdiocb->context2;
+	lp = (uint32_t *) pCmd->virt;
+
+	sp = (SERV_PARM *) ((uint8_t *) lp + sizeof (uint32_t));
+
+	if ((phba->hba_state <= LPFC_FLOGI) ||
+	    ((lpfc_check_sparm(phba, ndlp, sp, CLASS3) == 0))) {
+		/* Before responding to PLOGI, check for pt2pt mode.
+		 * If we are pt2pt, with an outstanding FLOGI, abort
+		 * the FLOGI and resend it first.
+		 */
+		if (phba->fc_flag & FC_PT2PT) {
+			lpfc_els_abort_flogi(phba);
+		        if(!(phba->fc_flag & FC_PT2PT_PLOGI)) {
+				/* If the other side is supposed to initiate
+				 * the PLOGI anyway, just ACC it now and
+				 * move on with discovery.
+				 */
+	    			lpfc_check_sparm(phba, ndlp, sp, CLASS3);
+				phba->fc_edtov = FF_DEF_EDTOV;
+				phba->fc_ratov = FF_DEF_RATOV;
+				phba->fcp_timeout_offset = 2 * phba->fc_ratov +
+				    clp[LPFC_CFG_EXTRA_IO_TMO].a_current;
+				/* Start discovery - this should just do
+				   CLEAR_LA */
+				lpfc_disc_start(phba);
+			}
+			else {
+				lpfc_initial_flogi(phba);
+			}
+			goto good_path;
+		}
+		/* Reject this request because invalid parameters */
+		stat.un.b.lsRjtRsvd0 = 0;
+		if (phba->hba_state <= LPFC_FLOGI) {
+			stat.un.b.lsRjtRsnCode = LSRJT_LOGICAL_BSY;
+			stat.un.b.lsRjtRsnCodeExp = LSEXP_NOTHING_MORE;
+		} else {
+			stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
+			stat.un.b.lsRjtRsnCodeExp = LSEXP_SPARM_OPTIONS;
+		}
+		stat.un.b.vendorUnique = 0;
+		lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb, ndlp);
+	} else {
+good_path:
+		/* PLOGI chkparm OK */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0114,
+				lpfc_mes0114,
+				lpfc_msgBlk0114.msgPreambleStr,
+				ndlp->nlp_DID, ndlp->nlp_state, ndlp->nlp_flag,
+				ndlp->nlp_rpi);
+
+		ndlp->nlp_state = lpfc_rcv_plogi(phba, ndlp, cmdiocb);
+		if(ndlp->nlp_state == NLP_STE_REG_LOGIN_ISSUE)
+			return (ndlp->nlp_state);
+	}
+	lpfc_nlp_remove(phba, ndlp);
+	return (NLP_STE_FREED_NODE);
+}
+
+uint32_t
+lpfc_rcv_els_unused_node(lpfcHBA_t * phba,
+			 LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	lpfc_issue_els_logo(phba, ndlp, 0);
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_rcv_logo_unused_node(lpfcHBA_t * phba,
+			  LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+	lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, 0, 0);
+	lpfc_nlp_remove(phba, ndlp);
+	return (NLP_STE_FREED_NODE);
+}
+
+uint32_t
+lpfc_cmpl_els_unused_node(lpfcHBA_t * phba,
+			  LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	lpfc_nlp_remove(phba, ndlp);
+	return (NLP_STE_FREED_NODE);
+}
+
+uint32_t
+lpfc_cmpl_reglogin_unused_node(lpfcHBA_t * phba,
+			       LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	/* dequeue, cancel timeout, unreg login */
+	lpfc_nlp_remove(phba, ndlp);
+	return (NLP_STE_FREED_NODE);
+}
+
+uint32_t
+lpfc_device_rm_unused_node(lpfcHBA_t * phba,
+			   LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	/* dequeue, cancel timeout, unreg login */
+	lpfc_nlp_remove(phba, ndlp);
+	return (NLP_STE_FREED_NODE);
+}
+
+uint32_t
+lpfc_device_add_unused_node(lpfcHBA_t * phba,
+			    LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	if (ndlp->nlp_tmofunc.function) {
+		ndlp->nlp_flag &= ~NLP_DELAY_TMO;
+		lpfc_stop_timer((struct clk_data *)ndlp->nlp_tmofunc.data);
+	}
+	ndlp->nlp_state = NLP_STE_UNUSED_NODE;
+	lpfc_nlp_plogi(phba, ndlp);
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_device_unk_unused_node(lpfcHBA_t * phba,
+			    LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	/* dequeue, cancel timeout, unreg login */
+	lpfc_nlp_remove(phba, ndlp);
+	return (NLP_STE_FREED_NODE);
+}
+
+uint32_t
+lpfc_rcv_plogi_plogi_issue(lpfcHBA_t * phba,
+			   LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+	DMABUF_t *pCmd;
+	uint32_t *lp;
+	IOCB_t *icmd;
+	SERV_PARM *sp;
+	LPFC_MBOXQ_t *mbox;
+	lpfcCfgParam_t *clp;
+	LS_RJT stat;
+	int port_cmp;
+
+	clp = &phba->config[0];
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+	icmd = &cmdiocb->iocb;
+	pCmd = (DMABUF_t *) cmdiocb->context2;
+	lp = (uint32_t *) pCmd->virt;
+
+	if (ndlp->nlp_flag & NLP_LOGO_SND) {
+		return (ndlp->nlp_state);
+	}
+
+	sp = (SERV_PARM *) ((uint8_t *) lp + sizeof (uint32_t));
+
+	/* For a PLOGI, we only accept if our portname is less
+	 * than the remote portname. 
+	 */
+	phba->fc_stat.elsLogiCol++;
+	port_cmp = lpfc_geportname((NAME_TYPE *) & phba->fc_portname,
+				   (NAME_TYPE *) & sp->portName);
+
+	if (!port_cmp) {
+		if (lpfc_check_sparm(phba, ndlp, sp, CLASS3) == 0) {
+			/* Reject this request because invalid parameters */
+			stat.un.b.lsRjtRsvd0 = 0;
+			stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
+			stat.un.b.lsRjtRsnCodeExp = LSEXP_SPARM_OPTIONS;
+			stat.un.b.vendorUnique = 0;
+			lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb,
+					    ndlp);
+		} else {
+			/* PLOGI chkparm OK */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0120,
+					lpfc_mes0120,
+					lpfc_msgBlk0120.msgPreambleStr,
+					ndlp->nlp_DID, ndlp->nlp_state,
+					ndlp->nlp_flag,
+					((LPFC_NODELIST_t*) ndlp)->nlp_rpi);
+
+			if ((clp[LPFC_CFG_FCP_CLASS].a_current == CLASS2) &&
+			    (sp->cls2.classValid)) {
+				ndlp->nlp_fcp_info |= CLASS2;
+			} else {
+				ndlp->nlp_fcp_info |= CLASS3;
+			}
+
+			if ((mbox = lpfc_mbox_alloc(phba, MEM_PRI))) {
+				if (lpfc_reg_login
+				    (phba, icmd->un.rcvels.remoteID,
+				     (uint8_t *) sp, mbox, 0) == 0) {
+					mbox->mbox_cmpl =
+					    lpfc_mbx_cmpl_reg_login;
+					mbox->context2 = ndlp;
+					/* Issue Reg Login after successful
+					   ACC */
+					ndlp->nlp_flag |= NLP_ACC_REGLOGIN;
+
+					if (port_cmp != 2) {
+						/* Abort outstanding PLOGI */
+						lpfc_driver_abort(phba, ndlp);
+					}
+					lpfc_els_rsp_acc(phba, ELS_CMD_PLOGI,
+							 cmdiocb, ndlp, mbox,
+							 0);
+					return (ndlp->nlp_state);
+
+				} else {
+					lpfc_mbox_free(phba, mbox);
+				}
+			}
+		}		/* if valid sparm */
+	} /* if our portname was less */
+	else {
+		/* Reject this request because the remote node will accept
+		   ours */
+		stat.un.b.lsRjtRsvd0 = 0;
+		stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
+		stat.un.b.lsRjtRsnCodeExp = LSEXP_CMD_IN_PROGRESS;
+		stat.un.b.vendorUnique = 0;
+		lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb, ndlp);
+	}
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_rcv_prli_plogi_issue(lpfcHBA_t * phba,
+			  LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+
+	/* software abort outstanding plogi, then send logout */
+	if (ndlp->nlp_tmofunc.function) {
+		ndlp->nlp_flag &= ~NLP_DELAY_TMO;
+		lpfc_stop_timer((struct clk_data *)ndlp->nlp_tmofunc.data);
+		lpfc_issue_els_logo(phba, ndlp, 0);
+	} else {
+		if (ndlp->nlp_flag & NLP_ACC_REGLOGIN) {
+			lpfc_els_rsp_prli_acc(phba, cmdiocb, ndlp);
+			return(ndlp->nlp_state);
+		}
+
+		lpfc_driver_abort(phba, ndlp);
+		lpfc_issue_els_logo(phba, ndlp, 0);
+	}
+
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_rcv_logo_plogi_issue(lpfcHBA_t * phba,
+			  LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+	lpfcCfgParam_t *clp;
+	int           issue_abort;
+
+	clp = &phba->config[0];
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+
+	/* software abort outstanding plogi before sending acc */
+	issue_abort = 0;
+	if (!ndlp->nlp_tmofunc.function) {
+		issue_abort = 1;
+	}
+	lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, 0, 0);
+
+	/* resend plogi after 1 sec delay */
+	if (ndlp->nlp_tmofunc.function) {
+		ndlp->nlp_flag &= ~NLP_DELAY_TMO;
+		lpfc_stop_timer((struct clk_data *)ndlp->nlp_tmofunc.data);
+	} 
+	ndlp->nlp_flag |= NLP_DELAY_TMO;
+	ndlp->nlp_retry = 0;
+
+	lpfc_start_timer(phba, 1, &ndlp->nlp_tmofunc, lpfc_els_retry_delay, 
+		(unsigned long)ndlp->nlp_DID, (unsigned long)ELS_CMD_PLOGI);
+	lpfc_nlp_plogi(phba, ndlp);
+
+	if(issue_abort) {
+		lpfc_driver_abort(phba, ndlp);
+	}
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_rcv_els_plogi_issue(lpfcHBA_t * phba,
+			 LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	/* software abort outstanding plogi, then send logout */
+	if (ndlp->nlp_tmofunc.function) {
+		ndlp->nlp_flag &= ~NLP_DELAY_TMO;
+		lpfc_stop_timer((struct clk_data *)ndlp->nlp_tmofunc.data);
+	} else {
+		lpfc_driver_abort(phba, ndlp);
+	}
+	lpfc_issue_els_logo(phba, ndlp, 0);
+	return (ndlp->nlp_state);
+}
+
+/*! lpfc_cmpl_plogi_plogi_issue
+  * 
+  * \pre
+  * \post
+  * \param   phba
+  * \param   ndlp
+  * \param   arg
+  * \param   evt
+  * \return  uint32_t
+  *
+  * \b Description:
+  *     This routine is envoked when we rcv a PLOGI completion from a node we
+  *     tried to log into. We check the CSPs, and the ulpStatus. If successful
+  *     change the state to REG_LOGIN_ISSUE and issue a REG_LOGIN. For failure,
+  *     we free the nodelist entry.
+  */
+
+uint32_t
+lpfc_cmpl_plogi_plogi_issue(lpfcHBA_t * phba,
+			    LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb, *rspiocb;
+	DMABUF_t *pCmd, *pRsp;
+	uint32_t *lp;
+	IOCB_t *irsp;
+	SERV_PARM *sp;
+	LPFC_MBOXQ_t *mbox;
+	lpfcCfgParam_t *clp;
+
+	clp = &phba->config[0];
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+	rspiocb = cmdiocb->context_un.rsp_iocb;
+
+	if (ndlp->nlp_flag & NLP_ACC_REGLOGIN) {
+		return (ndlp->nlp_state);
+	}
+
+	irsp = &rspiocb->iocb;
+
+	if (irsp->ulpStatus == 0) {
+		pCmd = (DMABUF_t *) cmdiocb->context2;
+		
+		pRsp = (DMABUF_t *) pCmd->list.next;
+		lp = (uint32_t *) pRsp->virt;
+
+		sp = (SERV_PARM *) ((uint8_t *) lp + sizeof (uint32_t));
+		if ((lpfc_check_sparm(phba, ndlp, sp, CLASS3))) {
+			/* PLOGI chkparm OK */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0121,
+					lpfc_mes0121,
+					lpfc_msgBlk0121.msgPreambleStr,
+					ndlp->nlp_DID, ndlp->nlp_state,
+					ndlp->nlp_flag,
+					((LPFC_NODELIST_t*) ndlp)->nlp_rpi);
+
+			if ((clp[LPFC_CFG_FCP_CLASS].a_current == CLASS2) &&
+			    (sp->cls2.classValid)) {
+				ndlp->nlp_fcp_info |= CLASS2;
+			} else {
+				ndlp->nlp_fcp_info |= CLASS3;
+			}
+
+			if ((mbox = lpfc_mbox_alloc(phba, MEM_PRI))) {
+				if (lpfc_reg_login
+				    (phba, irsp->un.elsreq64.remoteID,
+				     (uint8_t *) sp, mbox, 0) == 0) {
+					/* set_slim mailbox command needs to
+					 * execute first, queue this command to
+					 * be processed later.
+					 */
+					if (ndlp->nlp_DID == NameServer_DID) {
+						mbox->mbox_cmpl =
+						    lpfc_mbx_cmpl_ns_reg_login;
+					} else if (ndlp->nlp_DID == FDMI_DID) {
+						mbox->mbox_cmpl =
+						   lpfc_mbx_cmpl_fdmi_reg_login;
+					} else {
+						mbox->mbox_cmpl =
+						    lpfc_mbx_cmpl_reg_login;
+					}
+					mbox->context2 = ndlp;
+					ndlp->nlp_state =
+					    NLP_STE_REG_LOGIN_ISSUE;
+					if (lpfc_sli_issue_mbox
+					    (phba, mbox,
+					     (MBX_NOWAIT | MBX_STOP_IOCB))
+					    != MBX_NOT_FINISHED) {
+						return (ndlp->nlp_state);
+					}
+					lpfc_mbox_free(phba, mbox);
+				} else {
+					lpfc_mbox_free(phba, mbox);
+				}
+			}
+		}
+	}
+
+	/* If we are in the middle of discovery,
+	 * take necessary actions to finish up.
+	 */
+	if (ndlp->nlp_DID == NameServer_DID) {
+		/* Link up / RSCN discovery */
+		lpfc_disc_start(phba);
+	}
+
+	/* If this is a driver initiated abort, to a FCP target,
+	 * still honor the timer to relogin after a second.
+	 */
+	if((irsp->ulpStatus == IOSTAT_LOCAL_REJECT) &&
+	  (irsp->un.ulpWord[4] == IOERR_SLI_ABORTED) &&
+	  (ndlp->nlp_tmofunc.function) && (ndlp->nlp_flag & NLP_DELAY_TMO)) {
+		return (ndlp->nlp_state);
+	}
+	ndlp->nlp_state = NLP_STE_UNUSED_NODE;
+
+	/* Free this node since the driver cannot login or has the wrong
+	   sparm */
+	lpfc_nlp_remove(phba, ndlp);
+	return (NLP_STE_FREED_NODE);
+}
+
+uint32_t
+lpfc_cmpl_prli_plogi_issue(lpfcHBA_t * phba,
+			   LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+
+	/* First ensure ndlp is on the plogi list */
+	lpfc_nlp_plogi(phba, ndlp);
+
+	/* If a PLOGI is not already pending, issue one */
+	if (!(ndlp->nlp_flag & NLP_PLOGI_SND)) {
+		ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+		lpfc_issue_els_plogi(phba, ndlp, 0);
+		ndlp->nlp_flag |= NLP_DISC_NODE;
+	}
+
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_cmpl_logo_plogi_issue(lpfcHBA_t * phba,
+			   LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	if (!(ndlp->nlp_flag & NLP_PLOGI_SND)) {
+		lpfc_nlp_plogi(phba, ndlp);
+		ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+		lpfc_issue_els_plogi(phba, ndlp, 0);
+	}
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_cmpl_adisc_plogi_issue(lpfcHBA_t * phba,
+			    LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+
+	/* First ensure ndlp is on the plogi list */
+	lpfc_nlp_plogi(phba, ndlp);
+
+	/* If a PLOGI is not already pending, issue one */
+	if (!(ndlp->nlp_flag & NLP_PLOGI_SND)) {
+		ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+		lpfc_issue_els_plogi(phba, ndlp, 0);
+		ndlp->nlp_flag |= NLP_DISC_NODE;
+	}
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_cmpl_reglogin_plogi_issue(lpfcHBA_t * phba,
+			       LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_MBOXQ_t *pmb, *mbox;
+	MAILBOX_t *mb;
+	uint32_t ldata;
+	uint16_t rpi;
+
+	if (ndlp->nlp_flag & NLP_LOGO_SND) {
+		return (ndlp->nlp_state);
+	}
+
+	pmb = (LPFC_MBOXQ_t *) arg;
+	mb = &pmb->mb;
+	ldata = mb->un.varWords[0];	/* rpi */
+	rpi = (uint16_t) (le32_to_cpu(ldata) & 0xFFFF);
+
+	/* first unreg node's rpi */
+	if ((mbox = lpfc_mbox_alloc(phba, MEM_PRI))) {
+		/* now unreg rpi just got back from reg_login */
+		lpfc_unreg_login(phba, rpi, mbox);
+		if (lpfc_sli_issue_mbox(phba, mbox,
+					(MBX_NOWAIT | MBX_STOP_IOCB))
+		    == MBX_NOT_FINISHED) {
+			lpfc_mbox_free(phba, mbox);
+		}
+	}
+
+	/* software abort outstanding plogi */
+	lpfc_driver_abort(phba, ndlp);
+	/* send a new plogi */
+	lpfc_nlp_plogi(phba, ndlp);
+	ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+	lpfc_issue_els_plogi(phba, ndlp, 0);
+
+	return (ndlp->nlp_state);
+}
+
+/*! lpfc_device_rm_plogi_issue
+  * 
+  * \pre
+  * \post
+  * \param   phba
+  * \param   ndlp
+  * \param   arg
+  * \param   evt
+  * \return  uint32_t
+  *
+  * \b Description:
+  *     This routine is envoked when we a request to remove a nport we are in
+  *     the process of PLOGIing. We should issue a software abort on the
+  *     outstanding PLOGI request, then issue a LOGO request. Change node state
+  *     to UNUSED_NODE so it can be freed when LOGO completes.
+  *
+  */
+
+uint32_t
+lpfc_device_rm_plogi_issue(lpfcHBA_t * phba,
+			   LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+
+	/* software abort outstanding plogi, before sending LOGO */
+	lpfc_driver_abort(phba, ndlp);
+
+	/* If discovery processing causes us to remove a device, it is important
+	 * that nothing gets sent to the device (soft zoning issues).
+	 */
+	ndlp->nlp_state = NLP_STE_UNUSED_NODE;
+	lpfc_nlp_remove(phba, ndlp);
+	return (NLP_STE_FREED_NODE);
+}
+
+uint32_t
+lpfc_device_unk_plogi_issue(lpfcHBA_t * phba,
+			    LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	/* software abort outstanding plogi */
+	lpfc_driver_abort(phba, ndlp);
+
+	/* dequeue, cancel timeout, unreg login */
+	lpfc_nlp_remove(phba, ndlp);
+	return (NLP_STE_FREED_NODE);
+}
+
+uint32_t
+lpfc_rcv_plogi_reglogin_issue(lpfcHBA_t * phba,
+			      LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+	DMABUF_t *pCmd;
+	uint32_t *lp;
+	SERV_PARM *sp;
+	LS_RJT stat;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+	pCmd = (DMABUF_t *) cmdiocb->context2;
+	lp = (uint32_t *) pCmd->virt;
+
+	if (ndlp->nlp_flag & NLP_LOGO_SND) {
+		return (ndlp->nlp_state);
+	}
+
+	sp = (SERV_PARM *) ((uint8_t *) lp + sizeof (uint32_t));
+
+	if ((lpfc_check_sparm(phba, ndlp, sp, CLASS3) == 0)) {
+		/* Reject this request because invalid parameters */
+		stat.un.b.lsRjtRsvd0 = 0;
+		stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
+		stat.un.b.lsRjtRsnCodeExp = LSEXP_SPARM_OPTIONS;
+		stat.un.b.vendorUnique = 0;
+		lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb, ndlp);
+	} else {
+		/* PLOGI chkparm OK */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0122,
+				lpfc_mes0122,
+				lpfc_msgBlk0122.msgPreambleStr,
+				ndlp->nlp_DID, ndlp->nlp_state, ndlp->nlp_flag,
+				((LPFC_NODELIST_t*) ndlp)->nlp_rpi);
+
+		lpfc_els_rsp_acc(phba, ELS_CMD_PLOGI, cmdiocb, ndlp, 0, 0);
+	}
+
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_rcv_prli_reglogin_issue(lpfcHBA_t * phba,
+			     LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+
+	lpfc_els_rsp_prli_acc(phba, cmdiocb, ndlp);
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_rcv_logo_reglogin_issue(lpfcHBA_t * phba,
+			     LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+
+	lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, 0, 0);
+
+	/* resend plogi */
+	lpfc_nlp_plogi(phba, ndlp);
+	ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+	lpfc_issue_els_plogi(phba, ndlp, 0);
+
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_rcv_padisc_reglogin_issue(lpfcHBA_t * phba,
+			       LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+	DMABUF_t *pCmd;
+	uint32_t *lp;
+	SERV_PARM *sp;
+	LS_RJT stat;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+	pCmd = (DMABUF_t *) cmdiocb->context2;
+	lp = (uint32_t *) pCmd->virt;
+
+	sp = (SERV_PARM *) ((uint8_t *) lp + sizeof (uint32_t));
+
+	if ((lpfc_check_sparm(phba, ndlp, sp, CLASS3) == 0)) {
+		/* Reject this request because invalid parameters */
+		stat.un.b.lsRjtRsvd0 = 0;
+		stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
+		stat.un.b.lsRjtRsnCodeExp = LSEXP_SPARM_OPTIONS;
+		stat.un.b.vendorUnique = 0;
+		lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb, ndlp);
+	} else {
+		/* PLOGI chkparm OK */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0123,
+				lpfc_mes0123,
+				lpfc_msgBlk0123.msgPreambleStr,
+				ndlp->nlp_DID, ndlp->nlp_state, ndlp->nlp_flag,
+				((LPFC_NODELIST_t*) ndlp)->nlp_rpi);
+
+		lpfc_els_rsp_acc(phba, ELS_CMD_PLOGI, cmdiocb, ndlp, 0, 0);
+	}
+
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_rcv_prlo_reglogin_issue(lpfcHBA_t * phba,
+			     LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+	lpfc_els_rsp_acc(phba, ELS_CMD_PRLO, cmdiocb, ndlp, 0, 0);
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_cmpl_logo_reglogin_issue(lpfcHBA_t * phba,
+			      LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	/* 
+	 * don't really want to do anything since reglogin has not finished,
+	 * and we won't let any els happen until the mb is finished. 
+	 */
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_cmpl_adisc_reglogin_issue(lpfcHBA_t * phba,
+			       LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+
+	/* First ensure ndlp is on the plogi list */
+	lpfc_nlp_plogi(phba, ndlp);
+
+	return (ndlp->nlp_state);
+}
+
+/*! lpfc_cmpl_reglogin_reglogin_issue
+  * 
+  * \pre
+  * \post
+  * \param   phba
+  * \param   ndlp
+  * \param   arg
+  * \param   evt
+  * \return  uint32_t
+  *
+  * \b Description:
+  *     This routine is envoked when the REG_LOGIN completes. If unsuccessful,
+  *     we should send a LOGO ELS request and free the node entry. If
+  *     successful, save the RPI assigned, then issue a PRLI request. The
+  *     nodelist entry should be moved to the unmapped list.  If the NPortID
+  *     indicates a Fabric entity, don't issue PRLI, just go straight into
+  *     PRLI_COMPL.  PRLI_COMPL - for fabric entity
+  */
+uint32_t
+lpfc_cmpl_reglogin_reglogin_issue(lpfcHBA_t * phba,
+				  LPFC_NODELIST_t * ndlp,
+				  void *arg, uint32_t evt)
+{
+	LPFC_MBOXQ_t *pmb;
+	MAILBOX_t *mb;
+	LPFC_NODELIST_t *plogi_ndlp;
+	uint32_t did;
+
+	if (ndlp->nlp_flag & NLP_LOGO_SND) {
+		return (ndlp->nlp_state);
+	}
+
+	pmb = (LPFC_MBOXQ_t *) arg;
+	mb = &pmb->mb;
+	did = mb->un.varWords[1];
+	if (mb->mbxStatus ||
+	    ((plogi_ndlp = lpfc_findnode_did(phba,
+					     (NLP_SEARCH_PLOGI |
+					      NLP_SEARCH_DEQUE), did)) == 0)
+	    || (ndlp != plogi_ndlp)) {
+		/* RegLogin failed */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0246,
+				lpfc_mes0246,
+				lpfc_msgBlk0246.msgPreambleStr,
+				did, mb->mbxStatus, phba->hba_state);
+
+		lpfc_dequenode(phba, ndlp);
+		ndlp->nlp_state = NLP_STE_UNUSED_NODE;
+		lpfc_nlp_remove(phba, ndlp);
+		return (NLP_STE_FREED_NODE);
+	}
+
+	ndlp->nlp_rpi = mb->un.varWords[0];
+
+	/* This is a brand new rpi, so there should be NO pending IOCBs queued to
+	 * the SLI layer using this rpi.
+	 */
+	lpfc_new_rpi(phba, ndlp->nlp_rpi);
+	lpfc_nlp_unmapped(phba, ndlp);
+
+	/* Only if we are not a fabric nport do we issue PRLI */
+	if (!(ndlp->nlp_type & NLP_FABRIC)) {
+		lpfc_issue_els_prli(phba, ndlp, 0);
+		ndlp->nlp_state = NLP_STE_PRLI_ISSUE;
+	} else {
+		ndlp->nlp_state = NLP_STE_PRLI_COMPL;
+	}
+
+	return (ndlp->nlp_state);
+}
+
+/*! lpfc_device_rm_reglogin_issue
+  * 
+  * \pre
+  * \post
+  * \param   phba
+  * \param   ndlp
+  * \param   arg
+  * \param   evt
+  * \return  uint32_t
+  *
+  * \b Description:
+  *     This routine is envoked when we a request to remove a nport we are in
+  *     the process of REG_LOGINing. We should issue a UNREG_LOGIN by did, then
+  *     issue a LOGO request. Change node state to NODE_UNUSED, so it will be
+  *     freed when LOGO completes.
+  *
+  */
+
+uint32_t
+lpfc_device_rm_reglogin_issue(lpfcHBA_t * phba,
+			      LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_MBOXQ_t *mbox;
+
+	if (ndlp->nlp_rpi) {
+		if ((mbox = lpfc_mbox_alloc(phba, MEM_PRI))) {
+			lpfc_unreg_login(phba, ndlp->nlp_rpi, mbox);
+			if (lpfc_sli_issue_mbox
+			    (phba, mbox, (MBX_NOWAIT | MBX_STOP_IOCB))
+			    == MBX_NOT_FINISHED) {
+				lpfc_mbox_free(phba, mbox);
+			}
+		}
+
+		lpfc_no_rpi(phba, ndlp);
+		ndlp->nlp_rpi = 0;
+	}
+
+	/* If discovery processing causes us to remove a device, it is important
+	 * that nothing gets sent to the device (soft zoning issues).
+	 */
+	ndlp->nlp_state = NLP_STE_UNUSED_NODE;
+	lpfc_nlp_remove(phba, ndlp);
+	return (NLP_STE_FREED_NODE);
+}
+
+/* DEVICE_ADD for REG_LOGIN_ISSUE is nodev */
+
+uint32_t
+lpfc_device_unk_reglogin_issue(lpfcHBA_t * phba,
+			       LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	/* dequeue, cancel timeout, unreg login */
+	lpfc_nlp_remove(phba, ndlp);
+	return (NLP_STE_FREED_NODE);
+}
+
+uint32_t
+lpfc_rcv_plogi_prli_issue(lpfcHBA_t * phba,
+			  LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+	DMABUF_t *pCmd;
+	uint32_t *lp;
+	SERV_PARM *sp;
+	LS_RJT stat;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+	pCmd = (DMABUF_t *) cmdiocb->context2;
+	lp = (uint32_t *) pCmd->virt;
+
+	if (ndlp->nlp_flag & NLP_LOGO_SND) {
+		return (ndlp->nlp_state);
+	}
+
+	sp = (SERV_PARM *) ((uint8_t *) lp + sizeof (uint32_t));
+
+	if ((lpfc_check_sparm(phba, ndlp, sp, CLASS3) == 0)) {
+		/* Reject this request because invalid parameters */
+		stat.un.b.lsRjtRsvd0 = 0;
+		stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
+		stat.un.b.lsRjtRsnCodeExp = LSEXP_SPARM_OPTIONS;
+		stat.un.b.vendorUnique = 0;
+		lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb, ndlp);
+	} else {
+		/* PLOGI chkparm OK */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0124,
+				lpfc_mes0124,
+				lpfc_msgBlk0124.msgPreambleStr,
+				ndlp->nlp_DID, ndlp->nlp_state, ndlp->nlp_flag,
+				((LPFC_NODELIST_t*) ndlp)->nlp_rpi);
+
+		lpfc_els_rsp_acc(phba, ELS_CMD_PLOGI, cmdiocb, ndlp, 0, 0);
+	}
+
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_rcv_prli_prli_issue(lpfcHBA_t * phba,
+			 LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+
+	lpfc_els_rsp_prli_acc(phba, cmdiocb, ndlp);
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_rcv_logo_prli_issue(lpfcHBA_t * phba,
+			 LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+
+	/* Software abort outstanding prli before sending acc */
+	lpfc_driver_abort(phba, ndlp);
+
+	/* Only call LOGO ACC for first LOGO, this avoids sending unnecessary
+	 * PLOGIs during LOGO storms from a device.
+	 */
+	if (ndlp->nlp_flag & NLP_LOGO_ACC) {
+		ndlp->nlp_flag &= ~NLP_LOGO_ACC;
+		lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, 0, 0);
+		ndlp->nlp_flag |= NLP_LOGO_ACC;
+	} else {
+		ndlp->nlp_flag |= NLP_LOGO_ACC;
+		lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, 0, 0);
+	}
+
+	/* The driver has to wait until the ACC completes before it continues
+	 * processing the LOGO.  The action will resume in
+	 * lpfc_cmpl_els_logo_acc routine. Since part of processing includes an
+	 * unreg_login, the driver waits so the ACC does not get aborted.
+	 */
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_rcv_padisc_prli_issue(lpfcHBA_t * phba,
+			   LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+	DMABUF_t *pCmd;
+	SERV_PARM *sp;		/* used for PDISC */
+	ADISC *ap;		/* used for ADISC */
+	uint32_t *lp;
+	uint32_t cmd;
+	NAME_TYPE *pnn, *ppn;
+	LS_RJT stat;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+	pCmd = (DMABUF_t *) cmdiocb->context2;
+	lp = (uint32_t *) pCmd->virt;
+	cmd = *lp++;
+
+	if (cmd == ELS_CMD_ADISC) {
+		ap = (ADISC *) lp;
+		pnn = (NAME_TYPE *) & ap->nodeName;
+		ppn = (NAME_TYPE *) & ap->portName;
+	} else {
+		sp = (SERV_PARM *) lp;
+		pnn = (NAME_TYPE *) & sp->nodeName;
+		ppn = (NAME_TYPE *) & sp->portName;
+	}
+
+	if (lpfc_check_adisc(phba, ndlp, pnn, ppn)) {
+		if (cmd == ELS_CMD_ADISC) {
+			lpfc_els_rsp_adisc_acc(phba, cmdiocb, ndlp);
+		} else {
+			lpfc_els_rsp_acc(phba, ELS_CMD_PLOGI, cmdiocb, ndlp,
+					 0, 0);
+		}
+	} else {
+		/* Reject this request because invalid parameters */
+		stat.un.b.lsRjtRsvd0 = 0;
+		stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
+		stat.un.b.lsRjtRsnCodeExp = LSEXP_SPARM_OPTIONS;
+		stat.un.b.vendorUnique = 0;
+		lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb, ndlp);
+	}
+
+	return (ndlp->nlp_state);
+}
+
+/* This routine is envoked when we rcv a PRLO request from a nport
+ * we are logged into.  We should send back a PRLO rsp setting the
+ * appropriate bits.
+ * NEXT STATE = PRLI_ISSUE
+ */
+uint32_t
+lpfc_rcv_prlo_prli_issue(lpfcHBA_t * phba,
+			 LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+	lpfc_els_rsp_acc(phba, ELS_CMD_PRLO, cmdiocb, ndlp, 0, 0);
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_cmpl_prli_prli_issue(lpfcHBA_t * phba,
+			  LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb, *rspiocb;
+	DMABUF_t *pCmd, *pRsp;
+	uint32_t *lp;
+	IOCB_t *irsp;
+	PRLI *npr;
+	LPFC_BINDLIST_t *blp;
+	LPFCSCSILUN_t *lunp;
+	LPFCSCSITARGET_t *targetp;
+	struct list_head *curr, *next;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+	rspiocb = cmdiocb->context_un.rsp_iocb;
+	irsp = &rspiocb->iocb;
+	if (irsp->ulpStatus) {
+		/* If a local error occured go back to plogi state and retry */
+		if(((irsp->ulpStatus == IOSTAT_LOCAL_REJECT) &&
+		   (irsp->un.ulpWord[4] == IOERR_SEQUENCE_TIMEOUT)) ||
+		   ((irsp->ulpStatus == IOSTAT_LOCAL_REJECT) &&
+		    (irsp->un.ulpWord[4] == IOERR_SLI_ABORTED))) {
+			lpfc_nlp_plogi(phba, ndlp);
+			ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+			lpfc_issue_els_plogi(phba, ndlp, 0);
+		} else {
+			ndlp->nlp_state = NLP_STE_PRLI_COMPL;
+			lpfc_set_failmask(phba, ndlp, LPFC_DEV_RPTLUN,
+					  LPFC_CLR_BITMASK);
+		}
+		return (ndlp->nlp_state);
+	}
+	pCmd = (DMABUF_t *) cmdiocb->context2;
+	
+	pRsp = (DMABUF_t *) pCmd->list.next;
+	lp = (uint32_t *) pRsp->virt;
+
+	npr = (PRLI *) ((uint8_t *) lp + sizeof (uint32_t));
+
+	/* Check out PRLI rsp */
+	if ((npr->acceptRspCode != PRLI_REQ_EXECUTED) ||
+	    (npr->prliType != PRLI_FCP_TYPE) || (npr->targetFunc != 1)) {
+		ndlp->nlp_state = NLP_STE_PRLI_COMPL;
+		lpfc_set_failmask(phba, ndlp, LPFC_DEV_RPTLUN,
+				  LPFC_CLR_BITMASK);
+		return (ndlp->nlp_state);
+	}
+	if (npr->Retry == 1) {
+		ndlp->nlp_fcp_info |= NLP_FCP_2_DEVICE;
+	}
+
+	/* Can we assign a SCSI Id to this NPort */
+	if ((blp = lpfc_assign_scsid(phba, ndlp, 0))) {
+		lpfc_nlp_mapped(phba, ndlp, blp);
+		targetp = ndlp->nlp_Target;
+		ndlp->nlp_failMask = 0;
+		if (targetp) {
+			list_for_each_safe(curr, next, &targetp->lunlist) {
+				lunp = list_entry(curr, LPFCSCSILUN_t, list);
+				lunp->failMask = 0;
+			}
+		}
+		else {
+			/* new target to driver, allocate space to target <sid>
+			   lun 0 */
+			if (blp->nlp_Target == 0) {
+				lpfc_find_lun(phba, blp->nlp_sid, 0, 1);
+				blp->nlp_Target =
+				    phba->device_queue_hash[blp->nlp_sid];
+			}
+			targetp = blp->nlp_Target;
+			ndlp->nlp_Target = targetp;
+			targetp->pcontext = ndlp;
+			lpfc_scsi_assign_rpi(phba, targetp, ndlp->nlp_rpi);
+			targetp->un.dev_did = ndlp->nlp_DID;
+			list_for_each_safe(curr, next, &targetp->lunlist) {
+				lunp = list_entry(curr, LPFCSCSILUN_t, list);
+				lunp->pnode = (LPFC_NODELIST_t *) ndlp;
+			}
+		}
+		lpfc_set_failmask(phba, ndlp, LPFC_DEV_RPTLUN,
+				  LPFC_SET_BITMASK);
+
+		ndlp->nlp_state = NLP_STE_MAPPED_NODE;
+		lpfc_disc_issue_rptlun(phba, ndlp);
+	} else {
+		ndlp->nlp_state = NLP_STE_PRLI_COMPL;
+		ndlp->nlp_flag |= NLP_TGT_NO_SCSIID;
+		lpfc_set_failmask(phba, ndlp, LPFC_DEV_RPTLUN,
+				  LPFC_CLR_BITMASK);
+	}
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_cmpl_logo_prli_issue(lpfcHBA_t * phba,
+			  LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	/* dequeue, cancel timeout, unreg login */
+	lpfc_freenode(phba, ndlp);
+
+	/* software abort outstanding prli, then send logout */
+	lpfc_driver_abort(phba, ndlp);
+	lpfc_issue_els_logo(phba, ndlp, 0);
+	lpfc_nlp_remove(phba, ndlp);
+	return (NLP_STE_FREED_NODE);
+}
+
+uint32_t
+lpfc_cmpl_adisc_prli_issue(lpfcHBA_t * phba,
+			   LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_BINDLIST_t  *blp;
+	LPFCSCSILUN_t    *lunp;
+	LPFCSCSITARGET_t *targetp;
+	struct list_head *curr, *next;
+
+	/* Can we reassign a SCSI Id to this NPort */
+	if ((blp = lpfc_assign_scsid(phba, ndlp, 1))) {
+		lpfc_nlp_mapped(phba, ndlp, blp);
+		/* NOTE: can't we have this in lpfc_nlp_mapped */
+		ndlp->nlp_state = NLP_STE_MAPPED_NODE;
+		targetp = ndlp->nlp_Target;
+		if(!targetp) {
+			/* new target to driver, allocate target <sid> lun 0 */
+			if(blp->nlp_Target == 0) {
+				lpfc_find_lun(phba, blp->nlp_sid, 0, 1);
+				blp->nlp_Target = phba->device_queue_hash[blp->nlp_sid];
+			}
+			targetp = blp->nlp_Target;
+			ndlp->nlp_Target = targetp;
+			targetp->pcontext = ndlp;
+			lpfc_scsi_assign_rpi(phba, targetp, ndlp->nlp_rpi);
+			targetp->un.dev_did = ndlp->nlp_DID;
+			list_for_each_safe(curr, next, &targetp->lunlist) {
+				lunp = list_entry(curr, LPFCSCSILUN_t, list);
+				lunp->pnode = (LPFC_NODELIST_t *) ndlp;
+			}
+		}
+		lpfc_set_failmask(phba, ndlp, LPFC_DEV_ALL_BITS, LPFC_CLR_BITMASK);
+	}
+	else {
+		lpfc_nlp_unmapped(phba, ndlp);
+		lpfc_set_failmask(phba, ndlp, LPFC_DEV_RPTLUN, LPFC_CLR_BITMASK);
+	}
+
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_cmpl_reglogin_prli_issue(lpfcHBA_t * phba,
+			      LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_MBOXQ_t *pmb, *mbox;
+	MAILBOX_t *mb;
+	uint32_t ldata;
+	uint16_t rpi;
+
+	if (ndlp->nlp_flag & NLP_LOGO_SND) {
+		return (ndlp->nlp_state);
+	}
+
+	pmb = (LPFC_MBOXQ_t *) arg;
+	mb = &pmb->mb;
+	ldata = mb->un.varWords[0];	/* rpi */
+	rpi = (uint16_t) (le32_to_cpu(ldata) & 0xFFFF);
+
+	if (ndlp->nlp_rpi != rpi) {
+		/* first unreg node's rpi */
+		if ((mbox = lpfc_mbox_alloc(phba, MEM_PRI))) {
+			lpfc_unreg_login(phba, ndlp->nlp_rpi, mbox);
+			if (lpfc_sli_issue_mbox
+			    (phba, mbox, (MBX_NOWAIT | MBX_STOP_IOCB))
+			    == MBX_NOT_FINISHED) {
+				lpfc_mbox_free(phba, mbox);
+			}
+		}
+
+		lpfc_no_rpi(phba, ndlp);
+		ndlp->nlp_rpi = 0;
+
+		/* now unreg rpi just got back from reg_login */
+		lpfc_unreg_login(phba, rpi, mbox);
+		if (lpfc_sli_issue_mbox(phba, mbox,
+					(MBX_NOWAIT | MBX_STOP_IOCB))
+		    == MBX_NOT_FINISHED) {
+			lpfc_mbox_free(phba, mbox);
+		}
+
+		/* software abort outstanding prli */
+		lpfc_driver_abort(phba, ndlp);
+
+		/* send logout and put this node on plogi list */
+		lpfc_issue_els_logo(phba, ndlp, 0);
+		ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+		lpfc_nlp_plogi(phba, ndlp);
+	}
+
+	return (ndlp->nlp_state);
+}
+
+/*! lpfc_device_rm_prli_issue
+  * 
+  * \pre
+  * \post
+  * \param   phba
+  * \param   ndlp
+  * \param   arg
+  * \param   evt
+  * \return  uint32_t
+  *
+  * \b Description:
+  *    This routine is envoked when we a request to remove a nport we are in the
+  *    process of PRLIing. We should software abort outstanding prli, unreg
+  *    login, send a logout. We will change node state to UNUSED_NODE, put it
+  *    on plogi list so it can be freed when LOGO completes. 
+  *
+  */
+uint32_t
+lpfc_device_rm_prli_issue(lpfcHBA_t * phba,
+			  LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+
+	/* software abort outstanding prli */
+	lpfc_driver_abort(phba, ndlp);
+
+	ndlp->nlp_state = NLP_STE_UNUSED_NODE;
+
+	/* dequeue, cancel timeout, unreg login */
+	lpfc_nlp_remove(phba, ndlp);
+	return (NLP_STE_FREED_NODE);
+}
+
+uint32_t
+lpfc_device_add_prli_issue(lpfcHBA_t * phba,
+			   LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	if (ndlp->nlp_tmofunc.function) {
+		ndlp->nlp_flag &= ~NLP_DELAY_TMO;
+		lpfc_stop_timer((struct clk_data *)ndlp->nlp_tmofunc.data);
+	}
+	/* software abort outstanding prli */
+	lpfc_driver_abort(phba, ndlp);
+
+	lpfc_nlp_adisc(phba, ndlp);
+	return (ndlp->nlp_state);
+}
+
+/*! lpfc_device_unk_prli_issue
+  * 
+  * \pre
+  * \post
+  * \param   phba
+  * \param   ndlp
+  * \param   arg
+  * \param   evt
+  * \return  uint32_t
+  *
+  * \b Description:
+  *    The routine is envoked when the state of a device is unknown, like
+  *    during a link down. We should remove the nodelist entry from the
+  *    unmapped list, issue a UNREG_LOGIN, do a software abort of the
+  *    outstanding PRLI command, then free the node entry.
+  */
+uint32_t
+lpfc_device_unk_prli_issue(lpfcHBA_t * phba,
+			   LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	/* software abort outstanding prli */
+	lpfc_driver_abort(phba, ndlp);
+
+	/* dequeue, cancel timeout, unreg login */
+	lpfc_nlp_remove(phba, ndlp);
+	return (NLP_STE_FREED_NODE);
+}
+
+uint32_t
+lpfc_rcv_plogi_prli_compl(lpfcHBA_t * phba,
+			  LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+	DMABUF_t *pCmd;
+	uint32_t *lp;
+	SERV_PARM *sp;
+	LS_RJT stat;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+	pCmd = (DMABUF_t *) cmdiocb->context2;
+	lp = (uint32_t *) pCmd->virt;
+
+	if (ndlp->nlp_flag & NLP_LOGO_SND) {
+		return (ndlp->nlp_state);
+	}
+
+	sp = (SERV_PARM *) ((uint8_t *) lp + sizeof (uint32_t));
+
+	if ((phba->hba_state <= LPFC_FLOGI) ||
+	    ((lpfc_check_sparm(phba, ndlp, sp, CLASS3) == 0))) {
+		/* Reject this request because invalid parameters */
+		stat.un.b.lsRjtRsvd0 = 0;
+		stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
+		if (phba->hba_state <= LPFC_FLOGI) {
+			stat.un.b.lsRjtRsnCode = LSRJT_LOGICAL_BSY;
+			stat.un.b.lsRjtRsnCodeExp = LSEXP_NOTHING_MORE;
+		} else {
+			stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
+			stat.un.b.lsRjtRsnCodeExp = LSEXP_SPARM_OPTIONS;
+		}
+		stat.un.b.vendorUnique = 0;
+		lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb, ndlp);
+	} else {
+		/* PLOGI chkparm OK */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0125,
+				lpfc_mes0125,
+				lpfc_msgBlk0125.msgPreambleStr,
+				ndlp->nlp_DID, ndlp->nlp_state, ndlp->nlp_flag,
+				((LPFC_NODELIST_t*) ndlp)->nlp_rpi);
+
+		lpfc_els_rsp_acc(phba, ELS_CMD_PLOGI, cmdiocb, ndlp, 0, 0);
+
+		if ((phba->fc_flag & FC_PT2PT)
+		    && !(phba->fc_flag & FC_PT2PT_PLOGI)) {
+			ndlp->nlp_state = lpfc_rcv_plogi(phba, ndlp, cmdiocb);
+		}
+	}
+
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_rcv_prli_prli_compl(lpfcHBA_t * phba,
+			 LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+
+	lpfc_els_rsp_prli_acc(phba, cmdiocb, ndlp);
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_rcv_logo_prli_compl(lpfcHBA_t * phba,
+			 LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+
+	/* software abort outstanding adisc before sending acc */
+	if (ndlp->nlp_flag & NLP_ADISC_SND) {
+		lpfc_nlp_plogi(phba, ndlp);
+		lpfc_driver_abort(phba, ndlp);
+	}
+	/* Only call LOGO ACC for first LOGO, this avoids sending unnecessary
+	 * PLOGIs during LOGO storms from a device.
+	 */
+	if (ndlp->nlp_flag & NLP_LOGO_ACC) {
+		ndlp->nlp_flag &= ~NLP_LOGO_ACC;
+		lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, 0, 0);
+		ndlp->nlp_flag |= NLP_LOGO_ACC;
+	} else {
+		ndlp->nlp_flag |= NLP_LOGO_ACC;
+		lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, 0, 0);
+	}
+
+	/* The driver has to wait until the ACC completes before we can continue
+	 * processing the LOGO, the action will resume in
+	 * lpfc_cmpl_els_logo_acc.  Since part of processing includes an
+	 * unreg_login, the driver waits so the ACC does not get aborted.
+	 */
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_rcv_padisc_prli_compl(lpfcHBA_t * phba,
+			   LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+	DMABUF_t *pCmd;
+	SERV_PARM *sp;		/* used for PDISC */
+	ADISC *ap;		/* used for ADISC */
+	uint32_t *lp;
+	uint32_t cmd;
+	NAME_TYPE *pnn, *ppn;
+	LS_RJT stat;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+	pCmd = (DMABUF_t *) cmdiocb->context2;
+	lp = (uint32_t *) pCmd->virt;
+	cmd = *lp++;
+
+	if (cmd == ELS_CMD_ADISC) {
+		ap = (ADISC *) lp;
+		pnn = (NAME_TYPE *) & ap->nodeName;
+		ppn = (NAME_TYPE *) & ap->portName;
+	} else {
+		sp = (SERV_PARM *) lp;
+		pnn = (NAME_TYPE *) & sp->nodeName;
+		ppn = (NAME_TYPE *) & sp->portName;
+	}
+
+	if (lpfc_check_adisc(phba, ndlp, pnn, ppn)) {
+		if (cmd == ELS_CMD_ADISC) {
+			lpfc_els_rsp_adisc_acc(phba, cmdiocb, ndlp);
+		} else {
+			lpfc_els_rsp_acc(phba, ELS_CMD_PLOGI, cmdiocb, ndlp,
+					 0, 0);
+		}
+	} else {
+		/* Reject this request because invalid parameters */
+		stat.un.b.lsRjtRsvd0 = 0;
+		stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
+		stat.un.b.lsRjtRsnCodeExp = LSEXP_SPARM_OPTIONS;
+		stat.un.b.vendorUnique = 0;
+		lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb, ndlp);
+	}
+
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_rcv_prlo_prli_compl(lpfcHBA_t * phba,
+			 LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+	lpfc_els_rsp_acc(phba, ELS_CMD_PRLO, cmdiocb, ndlp, 0, 0);
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_cmpl_logo_prli_compl(lpfcHBA_t * phba,
+			  LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	/* dequeue, cancel timeout, unreg login */
+	lpfc_freenode(phba, ndlp);
+
+	if (ndlp->nlp_flag & NLP_ADISC_SND) {
+		lpfc_nlp_plogi(phba, ndlp);
+		/* software abort outstanding adisc */
+		lpfc_driver_abort(phba, ndlp);
+	}
+
+	ndlp->nlp_state = NLP_STE_UNUSED_NODE;
+	lpfc_nlp_remove(phba, ndlp);
+	return (NLP_STE_FREED_NODE);
+}
+
+uint32_t
+lpfc_cmpl_adisc_prli_compl(lpfcHBA_t * phba,
+			   LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb, *rspiocb;
+	DMABUF_t *pCmd, *pRsp;
+	uint32_t *lp;
+	IOCB_t *irsp;
+	LPFC_BINDLIST_t * blp;
+	LPFCSCSILUN_t    * lunp;
+	LPFCSCSITARGET_t * targetp;
+	ADISC *ap;
+	struct list_head * curr, * next;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+	rspiocb = cmdiocb->context_un.rsp_iocb;
+	irsp = &rspiocb->iocb;
+
+	/* First remove the ndlp from any list */
+	lpfc_dequenode(phba, ndlp);
+
+	if (irsp->ulpStatus) {
+		lpfc_freenode(phba, ndlp);
+		ndlp->nlp_state = NLP_STE_UNUSED_NODE;
+		lpfc_nlp_plogi(phba, ndlp);
+		return (ndlp->nlp_state);
+	}
+
+	pCmd = (DMABUF_t *) cmdiocb->context2;
+	
+	pRsp = (DMABUF_t *) pCmd->list.next;
+	lp = (uint32_t *) pRsp->virt;
+
+	ap = (ADISC *) ((uint8_t *) lp + sizeof (uint32_t));
+
+	/* Check out ADISC rsp */
+	if ((lpfc_check_adisc(phba, ndlp, &ap->nodeName, &ap->portName) == 0)) {
+		lpfc_freenode(phba, ndlp);
+		ndlp->nlp_state = NLP_STE_UNUSED_NODE;
+		lpfc_nlp_plogi(phba, ndlp);
+		return (ndlp->nlp_state);
+	}
+	if ((blp = lpfc_assign_scsid(phba, ndlp, 1))) {
+		lpfc_nlp_mapped(phba, ndlp, blp);
+		/* NOTE: can't we have this in lpfc_nlp_mapped */
+		ndlp->nlp_state = NLP_STE_MAPPED_NODE;
+		targetp = ndlp->nlp_Target;
+		if(!targetp) {
+			/* new target to driver, allocate space to target <sid> lun 0 */
+			if(blp->nlp_Target == 0) {
+				lpfc_find_lun(phba, blp->nlp_sid, 0, 1);
+				blp->nlp_Target = phba->device_queue_hash[blp->nlp_sid];
+			}
+			targetp = blp->nlp_Target;
+			ndlp->nlp_Target = targetp;
+			targetp->pcontext = ndlp;
+			lpfc_scsi_assign_rpi(phba, targetp, ndlp->nlp_rpi);
+			targetp->un.dev_did = ndlp->nlp_DID;
+			list_for_each_safe(curr, next, &targetp->lunlist) {
+				lunp = list_entry(curr, LPFCSCSILUN_t, list);
+				lunp->pnode = (LPFC_NODELIST_t *) ndlp;
+			}
+		}
+		lpfc_set_failmask(phba, ndlp, LPFC_DEV_ALL_BITS, LPFC_CLR_BITMASK);
+	}
+	else {
+		lpfc_nlp_unmapped(phba, ndlp);
+		lpfc_set_failmask(phba, ndlp, LPFC_DEV_RPTLUN, LPFC_CLR_BITMASK);
+	}
+
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_cmpl_reglogin_prli_compl(lpfcHBA_t * phba,
+			      LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_MBOXQ_t *pmb, *mbox;
+	MAILBOX_t *mb;
+	uint32_t ldata;
+	uint16_t rpi;
+
+	if (ndlp->nlp_flag & NLP_LOGO_SND) {
+		return (ndlp->nlp_state);
+	}
+
+	pmb = (LPFC_MBOXQ_t *) arg;
+	mb = &pmb->mb;
+	ldata = mb->un.varWords[0];	/* rpi */
+	rpi = (uint16_t) (le32_to_cpu(ldata) & 0xFFFF);
+
+	if (ndlp->nlp_rpi != rpi) {
+		/* first unreg node's rpi */
+		if ((mbox = lpfc_mbox_alloc(phba, MEM_PRI))) {
+			lpfc_unreg_login(phba, ndlp->nlp_rpi, mbox);
+			if (lpfc_sli_issue_mbox
+			    (phba, mbox, (MBX_NOWAIT | MBX_STOP_IOCB))
+			    == MBX_NOT_FINISHED) {
+				lpfc_mbox_free(phba, mbox);
+			}
+		}
+
+		lpfc_no_rpi(phba, ndlp);
+		ndlp->nlp_rpi = 0;
+
+		/* now unreg rpi just got back from reg_login */
+		lpfc_unreg_login(phba, rpi, mbox);
+		if (lpfc_sli_issue_mbox(phba, mbox,
+					(MBX_NOWAIT | MBX_STOP_IOCB))
+		    == MBX_NOT_FINISHED) {
+			lpfc_mbox_free(phba, mbox);
+		}
+
+		if (ndlp->nlp_flag & NLP_ADISC_SND) {
+			lpfc_nlp_plogi(phba, ndlp);
+			/* software abort outstanding adisc */
+			lpfc_driver_abort(phba, ndlp);
+		}
+
+		/* send logout and put this node on plogi list */
+		lpfc_issue_els_logo(phba, ndlp, 0);
+		ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+		lpfc_nlp_plogi(phba, ndlp);
+	}
+
+	return (ndlp->nlp_state);
+}
+
+/*! lpfc_device_rm_prli_compl
+  * 
+  * \pre
+  * \post
+  * \param   phba
+  * \param   ndlp
+  * \param   arg
+  * \param   evt
+  * \return  uint32_t
+  *
+  * \b Description:
+  *    This routine is envoked when we a request to remove a nport.
+  *    It could be called when linkdown or nodev timer expires.
+  *    If nodev timer is still running, we just want to exit.
+  *    If this node timed out, we want to abort outstanding ADISC,
+  *    unreg login, send logout, change state to UNUSED_NODE and
+  *    place node on plogi list so it can be freed when LOGO completes.
+  *
+  */
+uint32_t
+lpfc_device_rm_prli_compl(lpfcHBA_t * phba,
+			  LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	lpfc_set_failmask(phba, ndlp, LPFC_DEV_DISCONNECTED,
+			  LPFC_SET_BITMASK);
+	if (ndlp->nlp_flag & NLP_ADISC_SND) {
+		lpfc_nlp_plogi(phba, ndlp);
+		/* software abort outstanding adisc */
+		lpfc_driver_abort(phba, ndlp);
+	}
+
+	/* If discovery processing causes us to remove a device, it is
+	 * important that nothing gets sent to the device (soft zoning
+	 * issues).
+	 */
+	ndlp->nlp_state = NLP_STE_UNUSED_NODE;
+	/* dequeue, cancel timeout, unreg login */
+	lpfc_nlp_remove(phba, ndlp);
+	return (NLP_STE_FREED_NODE);
+}
+
+uint32_t
+lpfc_device_add_prli_compl(lpfcHBA_t * phba,
+			   LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	if (ndlp->nlp_tmofunc.function) {
+		ndlp->nlp_flag &= ~NLP_DELAY_TMO;
+		lpfc_stop_timer((struct clk_data *)ndlp->nlp_tmofunc.data);
+	}
+	lpfc_nlp_adisc(phba, ndlp);
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_device_unk_prli_compl(lpfcHBA_t * phba,
+			   LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	/* dequeue, cancel timeout, unreg login */
+	lpfc_nlp_remove(phba, ndlp);
+	return (NLP_STE_FREED_NODE);
+}
+
+uint32_t
+lpfc_rcv_plogi_mapped_node(lpfcHBA_t * phba,
+			   LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+	DMABUF_t *pCmd;
+	uint32_t *lp;
+	SERV_PARM *sp;
+	LS_RJT stat;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+	pCmd = (DMABUF_t *) cmdiocb->context2;
+	lp = (uint32_t *) pCmd->virt;
+
+	if (ndlp->nlp_flag & NLP_LOGO_SND) {
+		return (ndlp->nlp_state);
+	}
+
+	sp = (SERV_PARM *) ((uint8_t *) lp + sizeof (uint32_t));
+
+	if ((phba->hba_state <= LPFC_FLOGI) ||
+	    ((lpfc_check_sparm(phba, ndlp, sp, CLASS3) == 0))) {
+		/* Reject this request because invalid parameters */
+		stat.un.b.lsRjtRsvd0 = 0;
+		stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
+		if (phba->hba_state <= LPFC_FLOGI) {
+			stat.un.b.lsRjtRsnCode = LSRJT_LOGICAL_BSY;
+			stat.un.b.lsRjtRsnCodeExp = LSEXP_NOTHING_MORE;
+		} else {
+			stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
+			stat.un.b.lsRjtRsnCodeExp = LSEXP_SPARM_OPTIONS;
+		}
+		stat.un.b.vendorUnique = 0;
+		lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb, ndlp);
+	} else {
+		/* PLOGI chkparm OK */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0126,
+				lpfc_mes0126,
+				lpfc_msgBlk0126.msgPreambleStr,
+				ndlp->nlp_DID, ndlp->nlp_state, ndlp->nlp_flag,
+				((LPFC_NODELIST_t*) ndlp)->nlp_rpi);
+
+		lpfc_els_rsp_acc(phba, ELS_CMD_PLOGI, cmdiocb, ndlp, 0, 0);
+
+		if ((phba->fc_flag & FC_PT2PT)
+		    && !(phba->fc_flag & FC_PT2PT_PLOGI)) {
+			ndlp->nlp_state = lpfc_rcv_plogi(phba, ndlp, cmdiocb);
+		}
+	}
+
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_rcv_prli_mapped_node(lpfcHBA_t * phba,
+			  LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+
+	lpfc_els_rsp_prli_acc(phba, cmdiocb, ndlp);
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_rcv_logo_mapped_node(lpfcHBA_t * phba,
+			  LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+
+	/* software abort outstanding adisc before sending acc */
+	if (ndlp->nlp_flag & NLP_ADISC_SND) {
+		lpfc_nlp_plogi(phba, ndlp);
+		lpfc_driver_abort(phba, ndlp);
+	}
+	/* Only call LOGO ACC for first LOGO, this avoids sending unnecessary
+	 * PLOGIs during LOGO storms from a device.
+	 */
+	if (ndlp->nlp_flag & NLP_LOGO_ACC) {
+		ndlp->nlp_flag &= ~NLP_LOGO_ACC;
+		lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, 0, 0);
+		ndlp->nlp_flag |= NLP_LOGO_ACC;
+	} else {
+		ndlp->nlp_flag |= NLP_LOGO_ACC;
+		lpfc_els_rsp_acc(phba, ELS_CMD_ACC, cmdiocb, ndlp, 0, 0);
+	}
+
+	/* The driver has to wait until the ACC completes before we can continue
+	 * processing the LOGO, the action will resume in
+	 * lpfc_cmpl_els_logo_acc.  Since part of processing includes an
+	 * unreg_login, the driver waits so the ACC does not get aborted.
+	 */
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_rcv_padisc_mapped_node(lpfcHBA_t * phba,
+			    LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+	DMABUF_t *pCmd;
+	SERV_PARM *sp;		/* used for PDISC */
+	ADISC *ap;		/* used for ADISC */
+	uint32_t *lp;
+	uint32_t cmd;
+	NAME_TYPE *pnn, *ppn;
+	LS_RJT stat;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+	pCmd = (DMABUF_t *) cmdiocb->context2;
+	lp = (uint32_t *) pCmd->virt;
+	cmd = *lp++;
+
+	if (cmd == ELS_CMD_ADISC) {
+		ap = (ADISC *) lp;
+		pnn = (NAME_TYPE *) & ap->nodeName;
+		ppn = (NAME_TYPE *) & ap->portName;
+	} else {
+		sp = (SERV_PARM *) lp;
+		pnn = (NAME_TYPE *) & sp->nodeName;
+		ppn = (NAME_TYPE *) & sp->portName;
+	}
+
+	if (lpfc_check_adisc(phba, ndlp, pnn, ppn)) {
+		if (cmd == ELS_CMD_ADISC) {
+			lpfc_els_rsp_adisc_acc(phba, cmdiocb, ndlp);
+		} else {
+			lpfc_els_rsp_acc(phba, ELS_CMD_PLOGI, cmdiocb, ndlp,
+					 0, 0);
+		}
+	} else {
+		/* Reject this request because invalid parameters */
+		stat.un.b.lsRjtRsvd0 = 0;
+		stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
+		stat.un.b.lsRjtRsnCodeExp = LSEXP_SPARM_OPTIONS;
+		stat.un.b.vendorUnique = 0;
+		lpfc_els_rsp_reject(phba, stat.un.lsRjtError, cmdiocb, ndlp);
+	}
+
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_rcv_prlo_mapped_node(lpfcHBA_t * phba,
+			  LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+
+	/* Force discovery to rePLOGI as well as PRLI */
+	ndlp->nlp_flag |= NLP_LOGO_ACC;
+	lpfc_els_rsp_acc(phba, ELS_CMD_PRLO, cmdiocb, ndlp, 0, 0);
+
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_cmpl_logo_mapped_node(lpfcHBA_t * phba,
+			   LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	/* save binding on binding list */
+	if (ndlp->nlp_listp_bind) {
+		lpfc_nlp_bind(phba, ndlp->nlp_listp_bind);
+		ndlp->nlp_listp_bind = 0;
+		ndlp->nlp_sid = 0;
+		ndlp->nlp_flag &= ~NLP_SEED_MASK;
+	}
+
+	/* dequeue, cancel timeout, unreg login */
+	lpfc_freenode(phba, ndlp);
+
+	/* software abort outstanding adisc */
+	if (ndlp->nlp_flag & NLP_ADISC_SND) {
+		lpfc_nlp_plogi(phba, ndlp);
+		lpfc_driver_abort(phba, ndlp);
+	}
+	lpfc_nlp_remove(phba, ndlp);
+	return (NLP_STE_FREED_NODE);
+}
+
+uint32_t
+lpfc_cmpl_adisc_mapped_node(lpfcHBA_t * phba,
+			    LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_IOCBQ_t *cmdiocb, *rspiocb;
+	DMABUF_t *pCmd, *pRsp;
+	uint32_t *lp;
+	IOCB_t *irsp;
+	LPFC_BINDLIST_t *blp;
+	LPFCSCSILUN_t *lunp;
+	LPFCSCSITARGET_t *targetp;
+	struct list_head *curr, *next;
+	ADISC *ap;
+
+	cmdiocb = (LPFC_IOCBQ_t *) arg;
+	rspiocb = cmdiocb->context_un.rsp_iocb;
+	irsp = &rspiocb->iocb;
+
+	/* First remove the ndlp from any list */
+	lpfc_dequenode(phba, ndlp);
+
+	if (irsp->ulpStatus) {
+		/* If this is not a driver aborted ADISC, handle the recovery
+		   here */
+		if ((irsp->ulpStatus != IOSTAT_LOCAL_REJECT) ||
+			!(irsp->un.ulpWord[4] & IOERR_DRVR_MASK)) {
+			lpfc_freenode(phba, ndlp);
+			ndlp->nlp_state = NLP_STE_UNUSED_NODE;
+			lpfc_nlp_plogi(phba, ndlp);
+		}
+		return (ndlp->nlp_state);
+	}
+
+	pCmd = (DMABUF_t *) cmdiocb->context2;
+	
+	pRsp = (DMABUF_t *) pCmd->list.next;
+	lp = (uint32_t *) pRsp->virt;
+
+	ap = (ADISC *) ((uint8_t *) lp + sizeof (uint32_t));
+
+	/* Check out ADISC rsp */
+	if ((lpfc_check_adisc(phba, ndlp, &ap->nodeName, &ap->portName) == 0)) {
+		/* This is not a driver aborted ADISC, so handle the recovery
+		   here */
+		ndlp->nlp_state = NLP_STE_UNUSED_NODE;
+		lpfc_freenode(phba, ndlp);
+		lpfc_nlp_plogi(phba, ndlp);
+		return (ndlp->nlp_state);
+	}
+
+	/* Can we reassign a SCSI Id to this NPort */
+	if ((blp = lpfc_assign_scsid(phba, ndlp, 0))) {
+		lpfc_nlp_mapped(phba, ndlp, blp);
+
+		ndlp->nlp_state = NLP_STE_MAPPED_NODE;
+		targetp = ndlp->nlp_Target;
+		if (!targetp) {
+			/* new target to driver, allocate space to target <sid>
+			   lun 0 */
+			if (blp->nlp_Target == 0) {
+				lpfc_find_lun(phba, blp->nlp_sid, 0, 1);
+				blp->nlp_Target =
+				    phba->device_queue_hash[blp->nlp_sid];
+			}
+			targetp = blp->nlp_Target;
+			ndlp->nlp_Target = targetp;
+			targetp->pcontext = ndlp;
+			lpfc_scsi_assign_rpi(phba, targetp, ndlp->nlp_rpi);
+			targetp->un.dev_did = ndlp->nlp_DID;
+			list_for_each_safe(curr, next, &targetp->lunlist) {
+				lunp = list_entry(curr, LPFCSCSILUN_t, list);
+				lunp->pnode = (LPFC_NODELIST_t *) ndlp;
+			}
+		}
+		lpfc_set_failmask(phba, ndlp, LPFC_DEV_ALL_BITS,
+				  LPFC_CLR_BITMASK);
+	} else {
+		lpfc_nlp_unmapped(phba, ndlp);
+		ndlp->nlp_state = NLP_STE_PRLI_COMPL;
+		ndlp->nlp_flag |= NLP_TGT_NO_SCSIID;
+		lpfc_set_failmask(phba, ndlp, LPFC_DEV_RPTLUN,
+				  LPFC_CLR_BITMASK);
+	}
+
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_cmpl_reglogin_mapped_node(lpfcHBA_t * phba,
+			       LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	LPFC_MBOXQ_t *pmb, *mbox;
+	MAILBOX_t *mb;
+	uint32_t ldata;
+	uint16_t rpi;
+
+	if (ndlp->nlp_flag & NLP_LOGO_SND) {
+		return (ndlp->nlp_state);
+	}
+
+	pmb = (LPFC_MBOXQ_t *) arg;
+	mb = &pmb->mb;
+	ldata = mb->un.varWords[0];	/* rpi */
+	rpi = (uint16_t) (le32_to_cpu(ldata) & 0xFFFF);
+
+	if (ndlp->nlp_rpi != rpi) {
+		/* first unreg node's rpi */
+		if ((mbox = lpfc_mbox_alloc(phba, MEM_PRI))) {
+			lpfc_unreg_login(phba, ndlp->nlp_rpi, mbox);
+			if (lpfc_sli_issue_mbox
+			    (phba, mbox, (MBX_NOWAIT | MBX_STOP_IOCB))
+			    == MBX_NOT_FINISHED) {
+				lpfc_mbox_free(phba, mbox);
+			}
+		}
+
+		lpfc_no_rpi(phba, ndlp);
+		ndlp->nlp_rpi = 0;
+
+		/* now unreg rpi just got back from reg_login */
+		lpfc_unreg_login(phba, rpi, mbox);
+		if (lpfc_sli_issue_mbox(phba, mbox,
+					(MBX_NOWAIT | MBX_STOP_IOCB))
+		    == MBX_NOT_FINISHED) {
+			lpfc_mbox_free(phba, mbox);
+		}
+
+		/* save binding on binding list */
+		if (ndlp->nlp_listp_bind) {
+			lpfc_nlp_bind(phba, ndlp->nlp_listp_bind);
+			ndlp->nlp_listp_bind = 0;
+			ndlp->nlp_sid = 0;
+			ndlp->nlp_flag &= ~NLP_SEED_MASK;
+		}
+
+
+		/* software abort outstanding adisc */
+		if (ndlp->nlp_flag & NLP_ADISC_SND) {
+			lpfc_nlp_plogi(phba, ndlp);
+			lpfc_driver_abort(phba, ndlp);
+		}
+
+		/* send logout and put this node on plogi list */
+		lpfc_issue_els_logo(phba, ndlp, 0);
+		ndlp->nlp_state = NLP_STE_PLOGI_ISSUE;
+		lpfc_nlp_plogi(phba, ndlp);
+	}
+
+	return (ndlp->nlp_state);
+}
+
+/*! lpfc_device_rm_mapped_node
+  * 
+  * \pre
+  * \post
+  * \param   phba
+  * \param   ndlp
+  * \param   arg
+  * \param   evt
+  * \return  uint32_t
+  *
+  * \b Description:
+  *    This routine is envoked when we a request to remove a nport.
+  *    It could be called when linkdown or nodev timer expires.
+  *    If nodev timer is still running, we just want to exit.
+  *    If this node timed out, we want to abort outstanding ADISC,
+  *    save its binding, unreg login, send logout, change state to 
+  *    UNUSED_NODE and place node on plogi list so it can be freed 
+  *    when LOGO completes.
+  *
+  */
+uint32_t
+lpfc_device_rm_mapped_node(lpfcHBA_t * phba,
+			   LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	lpfc_set_failmask(phba, ndlp, LPFC_DEV_DISCONNECTED,
+			  LPFC_SET_BITMASK);
+
+	if (ndlp->nlp_flag & NLP_ADISC_SND) {
+		lpfc_nlp_plogi(phba, ndlp);
+		/* software abort outstanding adisc */
+		lpfc_driver_abort(phba, ndlp);
+	}
+
+	/* save binding info */
+	if (ndlp->nlp_listp_bind) {
+		lpfc_nlp_bind(phba, ndlp->nlp_listp_bind);
+		ndlp->nlp_listp_bind = 0;
+		ndlp->nlp_sid = 0;
+		ndlp->nlp_flag &= ~NLP_SEED_MASK;
+	}
+
+
+	/* If discovery processing causes us to remove a device, it is
+	 * important that nothing gets sent to the device (soft zoning
+	 * issues).
+	 */
+	ndlp->nlp_state = NLP_STE_UNUSED_NODE;
+	/* dequeue, cancel timeout, unreg login */
+	lpfc_nlp_remove(phba, ndlp);
+	return (NLP_STE_FREED_NODE);
+}
+
+uint32_t
+lpfc_device_add_mapped_node(lpfcHBA_t * phba,
+			    LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	if (ndlp->nlp_tmofunc.function) {
+		ndlp->nlp_flag &= ~NLP_DELAY_TMO;
+		lpfc_stop_timer((struct clk_data *)ndlp->nlp_tmofunc.data);
+	}
+	lpfc_nlp_adisc(phba, ndlp);
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_device_unk_mapped_node(lpfcHBA_t * phba,
+			    LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	/* No need to do anything till the link comes back up or
+	 * npr timer expires.
+	 */
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_disc_nodev(lpfcHBA_t * phba,
+		LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	/* This routine does nothing, just return the current state */
+	return (ndlp->nlp_state);
+}
+
+uint32_t
+lpfc_disc_neverdev(lpfcHBA_t * phba,
+		   LPFC_NODELIST_t * ndlp, void *arg, uint32_t evt)
+{
+	/* This routine does nothing, just return the current state */
+	return (ndlp->nlp_state);
+}
+
+int
+lpfc_geportname(NAME_TYPE * pn1, NAME_TYPE * pn2)
+{
+	int i;
+	uint8_t *cp1, *cp2;
+
+	i = sizeof (NAME_TYPE);
+	cp1 = (uint8_t *) pn1;
+	cp2 = (uint8_t *) pn2;
+	while (i--) {
+		if (*cp1 < *cp2) {
+			return (0);
+		}
+		if (*cp1 > *cp2) {
+			return (1);
+		}
+		cp1++;
+		cp2++;
+	}
+
+	return (2);		/* equal */
+}
+
+int
+lpfc_check_sparm(lpfcHBA_t * phba,
+		 LPFC_NODELIST_t * ndlp, SERV_PARM * sp, uint32_t class)
+{
+	volatile SERV_PARM *hsp;
+
+	hsp = &phba->fc_sparam;
+	/* First check for supported version */
+
+	/* Next check for class validity */
+	if (sp->cls1.classValid) {
+
+		if (sp->cls1.rcvDataSizeMsb > hsp->cls1.rcvDataSizeMsb)
+			sp->cls1.rcvDataSizeMsb = hsp->cls1.rcvDataSizeMsb;
+		if (sp->cls1.rcvDataSizeLsb > hsp->cls1.rcvDataSizeLsb)
+			sp->cls1.rcvDataSizeLsb = hsp->cls1.rcvDataSizeLsb;
+	} else if (class == CLASS1) {
+		return (0);
+	}
+
+	if (sp->cls2.classValid) {
+
+		if (sp->cls2.rcvDataSizeMsb > hsp->cls2.rcvDataSizeMsb)
+			sp->cls2.rcvDataSizeMsb = hsp->cls2.rcvDataSizeMsb;
+		if (sp->cls2.rcvDataSizeLsb > hsp->cls2.rcvDataSizeLsb)
+			sp->cls2.rcvDataSizeLsb = hsp->cls2.rcvDataSizeLsb;
+	} else if (class == CLASS2) {
+		return (0);
+	}
+
+	if (sp->cls3.classValid) {
+
+		if (sp->cls3.rcvDataSizeMsb > hsp->cls3.rcvDataSizeMsb)
+			sp->cls3.rcvDataSizeMsb = hsp->cls3.rcvDataSizeMsb;
+		if (sp->cls3.rcvDataSizeLsb > hsp->cls3.rcvDataSizeLsb)
+			sp->cls3.rcvDataSizeLsb = hsp->cls3.rcvDataSizeLsb;
+	} else if (class == CLASS3) {
+		return (0);
+	}
+
+	if (sp->cmn.bbRcvSizeMsb > hsp->cmn.bbRcvSizeMsb)
+		sp->cmn.bbRcvSizeMsb = hsp->cmn.bbRcvSizeMsb;
+	if (sp->cmn.bbRcvSizeLsb > hsp->cmn.bbRcvSizeLsb)
+		sp->cmn.bbRcvSizeLsb = hsp->cmn.bbRcvSizeLsb;
+
+	/* If check is good, copy wwpn wwnn into ndlp */
+	memcpy(&ndlp->nlp_nodename, &sp->nodeName, sizeof (NAME_TYPE));
+	memcpy(&ndlp->nlp_portname, &sp->portName, sizeof (NAME_TYPE));
+	return (1);
+}
+
+int
+lpfc_check_adisc(lpfcHBA_t * phba,
+		 LPFC_NODELIST_t * ndlp, NAME_TYPE * nn, NAME_TYPE * pn)
+{
+	if (lpfc_geportname((NAME_TYPE *) nn, &ndlp->nlp_nodename) != 2) {
+		return (0);
+	}
+
+	if (lpfc_geportname((NAME_TYPE *) pn, &ndlp->nlp_portname) != 2) {
+		return (0);
+	}
+
+	return (1);
+}
+
+int
+lpfc_binding_found(LPFC_BINDLIST_t * blp, LPFC_NODELIST_t * ndlp)
+{
+	uint16_t bindtype;
+
+	bindtype = blp->nlp_bind_type;
+	if ((bindtype & FCP_SEED_DID) && (ndlp->nlp_DID == blp->nlp_DID)) {
+		return (1);
+	} else if ((bindtype & FCP_SEED_WWPN) &&
+		   (lpfc_geportname(&ndlp->nlp_portname, &blp->nlp_portname) ==
+		    2)) {
+		return (1);
+	} else if ((bindtype & FCP_SEED_WWNN) &&
+		   (lpfc_geportname(&ndlp->nlp_nodename, &blp->nlp_nodename) ==
+		    2)) {
+		return (1);
+	}
+	return (0);
+}
+
+int
+lpfc_binding_useid(lpfcHBA_t * phba, uint32_t sid)
+{
+	LPFC_BINDLIST_t *blp;
+	struct list_head *pos;
+
+	list_for_each(pos, &phba->fc_nlpbind_list) {
+		blp = list_entry(pos, LPFC_BINDLIST_t, nlp_listp);
+
+		if (blp->nlp_sid == sid) {
+			return (1);
+		}
+	}
+	return (0);
+}
+
+int
+lpfc_mapping_useid(lpfcHBA_t * phba, uint32_t sid)
+{
+	LPFC_NODELIST_t *mapnode;
+	LPFC_BINDLIST_t *blp;
+	struct list_head *pos;
+
+	list_for_each(pos, &phba->fc_nlpmap_list) {
+		mapnode = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+		blp = mapnode->nlp_listp_bind;
+		if (blp->nlp_sid == sid) {
+			return (1);
+		}
+	}
+	return (0);
+}
+
+LPFC_BINDLIST_t *
+lpfc_create_binding(lpfcHBA_t * phba,
+		    LPFC_NODELIST_t * ndlp, uint16_t index, uint16_t bindtype)
+{
+	LPFC_BINDLIST_t *blp;
+
+	if ((blp = lpfc_bind_alloc(phba, 0))) {
+		memset(blp, 0, sizeof (LPFC_BINDLIST_t));
+		switch (bindtype) {
+		case FCP_SEED_WWPN:
+			blp->nlp_bind_type = FCP_SEED_WWPN;
+			break;
+		case FCP_SEED_WWNN:
+			blp->nlp_bind_type = FCP_SEED_WWNN;
+			break;
+		case FCP_SEED_DID:
+			blp->nlp_bind_type = FCP_SEED_DID;
+			break;
+		}
+		blp->nlp_sid = index;
+		blp->nlp_DID = ndlp->nlp_DID;
+		blp->nlp_Target = phba->device_queue_hash[index];
+		memcpy(&blp->nlp_nodename, &ndlp->nlp_nodename,
+		       sizeof (NAME_TYPE));
+		memcpy(&blp->nlp_portname, &ndlp->nlp_portname,
+		       sizeof (NAME_TYPE));
+
+		return (blp);
+	}
+
+	return (0);
+}
+
+uint32_t
+lpfc_add_bind(lpfcHBA_t * phba, uint8_t bind_type,	/* NN/PN/DID */
+	      void *bind_id,	/* pointer to the bind id value */
+	      uint32_t scsi_id)
+{
+	LPFC_NODELIST_t *ndlp;
+	LPFC_BINDLIST_t *blp;
+	LPFCSCSITARGET_t *targetp;
+	LPFCSCSILUN_t *lunp;
+	struct list_head *pos;
+	struct list_head *curr, *next;
+
+	/* Check if the SCSI ID is currently mapped */
+	ndlp = lpfc_findnode_scsiid(phba, scsi_id);
+	if (ndlp && (ndlp != &phba->fc_fcpnodev)) {
+		return ENOENT;
+	}
+	/* Check if the SCSI ID is currently in the bind list. */
+	list_for_each(pos, &phba->fc_nlpbind_list) {
+		blp = list_entry(pos, LPFC_BINDLIST_t, nlp_listp);
+	
+		if (blp->nlp_sid == scsi_id) {
+			return ENOENT;
+		}
+		switch (bind_type) {
+		case FCP_SEED_WWPN:
+			if ((blp->nlp_bind_type & FCP_SEED_WWPN) &&
+			    (lpfc_geportname(bind_id, &blp->nlp_portname) ==
+			     2)) {
+				return EBUSY;
+			}
+			break;
+		case FCP_SEED_WWNN:
+			if ((blp->nlp_bind_type & FCP_SEED_WWNN) &&
+			    (lpfc_geportname(bind_id, &blp->nlp_nodename) ==
+			     2)) {
+				return EBUSY;
+			}
+			break;
+		case FCP_SEED_DID:
+			if ((blp->nlp_bind_type & FCP_SEED_DID) &&
+			    (*((uint32_t *) bind_id) == blp->nlp_DID)) {
+				return EBUSY;
+			}
+			break;
+		}
+	}
+	if (phba->fcp_mapping != bind_type) {
+		return EINVAL;
+	}
+	switch (bind_type) {
+	case FCP_SEED_WWNN:
+		{
+			/* Check if the node name present in the mapped list */
+			ndlp =
+			    lpfc_findnode_wwnn(phba, NLP_SEARCH_MAPPED,
+					       bind_id);
+			if (ndlp) {
+				return EBUSY;
+			}
+			ndlp =
+			    lpfc_findnode_wwnn(phba, NLP_SEARCH_UNMAPPED,
+					       bind_id);
+			break;
+		}
+	case FCP_SEED_WWPN:
+		{
+			/* Check if the port name present in the mapped list */
+			ndlp =
+			    lpfc_findnode_wwpn(phba, NLP_SEARCH_MAPPED,
+					       bind_id);
+			if (ndlp)
+				return EBUSY;
+			ndlp =
+			    lpfc_findnode_wwpn(phba, NLP_SEARCH_UNMAPPED,
+					       bind_id);
+			break;
+		}
+	case FCP_SEED_DID:
+		{
+			/* Check if the DID present in the mapped list */
+			ndlp =
+			    lpfc_findnode_did(phba, NLP_SEARCH_MAPPED,
+					      *((uint32_t *) bind_id));
+			if (ndlp)
+				return EBUSY;
+			ndlp =
+			    lpfc_findnode_did(phba, NLP_SEARCH_UNMAPPED,
+					      *((uint32_t *) bind_id));
+			break;
+		}
+	}
+
+	/* Add to the bind list */
+	if ((blp = (LPFC_BINDLIST_t *) lpfc_bind_alloc(phba, 0)) == 0) {
+		return EIO;
+	}
+	memset(blp, 0, sizeof (LPFC_BINDLIST_t));
+	blp->nlp_bind_type = bind_type;
+	blp->nlp_sid = (scsi_id & 0xff);
+
+	switch (bind_type) {
+	case FCP_SEED_WWNN:
+		memcpy(&blp->nlp_nodename, (uint8_t *) bind_id,
+		       sizeof (NAME_TYPE));
+		break;
+
+	case FCP_SEED_WWPN:
+		memcpy(&blp->nlp_portname, (uint8_t *) bind_id,
+		       sizeof (NAME_TYPE));
+		break;
+
+	case FCP_SEED_DID:
+		blp->nlp_DID = *((uint32_t *) bind_id);
+		break;
+
+	}
+
+	lpfc_nlp_bind(phba, blp);
+	/* 
+	   If the newly added node is in the unmapped list, assign a
+	   SCSI ID to the node.
+	 */
+
+	if (ndlp) {
+		if ((blp = lpfc_assign_scsid(phba, ndlp, 0))) {
+			lpfc_nlp_mapped(phba, ndlp, blp);
+			targetp = ndlp->nlp_Target;
+			ndlp->nlp_failMask = 0;
+			if (targetp) {
+				list_for_each_safe(curr, next,
+						   &targetp->lunlist) {
+					lunp = list_entry(curr, LPFCSCSILUN_t,
+							  list);
+					lunp->failMask = 0;
+				}
+			} else {
+				/* new target to driver, allocate space to
+				   target <sid> lun 0 */
+				if (blp->nlp_Target == 0) {
+					lpfc_find_lun(phba, blp->nlp_sid, 0, 1);
+					blp->nlp_Target =
+					    phba->device_queue_hash[blp->
+								    nlp_sid];
+				}
+				targetp = blp->nlp_Target;
+				ndlp->nlp_Target = targetp;
+				targetp->pcontext = ndlp;
+				lpfc_scsi_assign_rpi(phba, targetp, ndlp->nlp_rpi);
+				targetp->un.dev_did = ndlp->nlp_DID;
+				list_for_each_safe(curr, next, &targetp->lunlist) {
+					lunp = list_entry(curr, LPFCSCSILUN_t, list);
+					lunp->pnode = (LPFC_NODELIST_t *) ndlp;
+				}
+			}
+			lpfc_set_failmask(phba, ndlp, LPFC_DEV_RPTLUN,
+					  LPFC_SET_BITMASK);
+			ndlp->nlp_state = NLP_STE_MAPPED_NODE;
+			lpfc_disc_issue_rptlun(phba, ndlp);
+		}
+	}
+	return (0);
+}
+
+uint32_t
+lpfc_del_bind(lpfcHBA_t * phba, uint8_t bind_type,	/* NN/PN/DID */
+	      void *bind_id,	/* pointer to the bind id value */
+	      uint32_t scsi_id)
+{
+	LPFC_BINDLIST_t *blp = 0;
+	uint32_t found = 0;
+	LPFC_NODELIST_t *ndlp = 0;
+	struct list_head *pos;
+
+	/* Search the mapped list for the bind_id */
+	if (!bind_id) {
+		ndlp = lpfc_findnode_scsiid(phba, scsi_id);
+		if ((ndlp == &phba->fc_fcpnodev) ||
+		    (ndlp && (!(ndlp->nlp_flag & NLP_MAPPED_LIST))))
+			ndlp = 0;
+	} else {
+
+		if (bind_type != phba->fcp_mapping)
+			return EINVAL;
+
+		switch (bind_type) {
+		case FCP_SEED_WWNN:
+			ndlp =
+			    lpfc_findnode_wwnn(phba, NLP_SEARCH_MAPPED,
+					       bind_id);
+			break;
+
+		case FCP_SEED_WWPN:
+			ndlp =
+			    lpfc_findnode_wwpn(phba, NLP_SEARCH_MAPPED,
+					       bind_id);
+			break;
+
+		case FCP_SEED_DID:
+			ndlp =
+			    lpfc_findnode_did(phba, NLP_SEARCH_MAPPED,
+					      *((uint32_t *) bind_id));
+			break;
+		}
+	}
+
+	/* If there is a mapped target for this bing unmap it */
+	if (ndlp) {
+		return EBUSY;
+	}
+
+	/* check binding list */
+	list_for_each(pos, &phba->fc_nlpbind_list) {
+		blp = list_entry(pos, LPFC_BINDLIST_t, nlp_listp);
+
+		if (!bind_id) {
+			/* Search binding based on SCSI ID */
+			if (blp->nlp_sid == scsi_id) {
+				found = 1;
+				break;
+			} else {
+				continue;
+			}
+		}
+
+		switch (bind_type) {
+		case FCP_SEED_WWPN:
+			if ((blp->nlp_bind_type & FCP_SEED_WWPN) &&
+			    (lpfc_geportname(bind_id, &blp->nlp_portname) ==
+			     2)) {
+				found = 1;
+			}
+			break;
+		case FCP_SEED_WWNN:
+			if ((blp->nlp_bind_type & FCP_SEED_WWNN) &&
+			    (lpfc_geportname(bind_id, &blp->nlp_nodename) ==
+			     2)) {
+				found = 1;
+			}
+			break;
+		case FCP_SEED_DID:
+			if ((blp->nlp_bind_type & FCP_SEED_DID) &&
+			    (*((uint32_t *) bind_id) == blp->nlp_DID)) {
+				found = 1;
+			}
+			break;
+		}
+		if (found)
+			break;
+	}
+
+	if (found) {
+		/* take it off the bind list */
+		phba->fc_bind_cnt--;
+		list_del(&blp->nlp_listp);
+		return 0;
+	}
+
+	return ENOENT;
+}
+
+LPFC_BINDLIST_t *
+lpfc_assign_scsid(lpfcHBA_t * phba, LPFC_NODELIST_t * ndlp,
+		  int prev_flag)
+{
+	LPFC_BINDLIST_t *blp;
+	lpfcCfgParam_t *clp;
+	uint16_t index;
+	struct list_head *pos, *pos_tmp;
+
+	clp = &phba->config[0];
+
+	/* check binding list */
+	list_for_each_safe(pos, pos_tmp, &phba->fc_nlpbind_list) {
+		blp = list_entry(pos, LPFC_BINDLIST_t, nlp_listp);
+
+		if (lpfc_binding_found(blp, ndlp)) {
+			ndlp->nlp_sid = blp->nlp_sid;
+			ndlp->nlp_Target = blp->nlp_Target;
+			ndlp->nlp_flag &= ~NLP_SEED_MASK;
+			switch ((blp->nlp_bind_type & FCP_SEED_MASK)) {
+			case FCP_SEED_WWPN:
+				ndlp->nlp_flag |= NLP_SEED_WWPN;
+				break;
+			case FCP_SEED_WWNN:
+				ndlp->nlp_flag |= NLP_SEED_WWNN;
+				break;
+			case FCP_SEED_DID:
+				ndlp->nlp_flag |= NLP_SEED_DID;
+				break;
+			}
+			if (blp->nlp_bind_type & FCP_SEED_AUTO) {
+				ndlp->nlp_flag |= NLP_AUTOMAP;
+			}
+
+			/* take it off the binding list */
+			phba->fc_bind_cnt--;
+			list_del_init(pos);
+
+			/* Reassign scsi id <sid> to NPort <nlp_DID> */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0213,
+					lpfc_mes0213,
+					lpfc_msgBlk0213.msgPreambleStr,
+					blp->nlp_sid, ndlp->nlp_DID,
+					blp->nlp_bind_type, ndlp->nlp_flag,
+					ndlp->nlp_state, ndlp->nlp_rpi);
+
+			return (blp);
+		}
+	}
+
+	if(prev_flag)
+		return(0);
+
+	/* NOTE: if scan-down = 2 and we have private loop, then we use
+	 * AlpaArray to determine sid.
+	 */
+	if ((clp[LPFC_CFG_BINDMETHOD].a_current == 4) &&
+	    ((phba->fc_flag & (FC_PUBLIC_LOOP | FC_FABRIC)) ||
+	     (phba->fc_topology != TOPOLOGY_LOOP))) {
+		/* Log message: ALPA based binding used on a non loop
+		   topology */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0245,
+				lpfc_mes0245,
+				lpfc_msgBlk0245.msgPreambleStr,
+				phba->fc_topology);
+	}
+
+	if ((clp[LPFC_CFG_BINDMETHOD].a_current == 4) &&
+	    !(phba->fc_flag & (FC_PUBLIC_LOOP | FC_FABRIC)) &&
+	    (phba->fc_topology == TOPOLOGY_LOOP)) {
+		for (index = 0; index < FC_MAXLOOP; index++) {
+			if (ndlp->nlp_DID == (uint32_t) lpfcAlpaArray[index]) {
+				if ((blp =
+				     lpfc_create_binding(phba, ndlp, index,
+							 FCP_SEED_DID))) {
+
+					ndlp->nlp_sid = index;
+					ndlp->nlp_Target =
+					    phba->device_queue_hash[index];
+					ndlp->nlp_flag &= ~NLP_SEED_MASK;
+					ndlp->nlp_flag |= NLP_SEED_DID;
+					ndlp->nlp_flag |= NLP_SEED_ALPA;
+
+					/* Assign scandown scsi id <sid> to
+					   NPort <nlp_DID> */
+					lpfc_printf_log(phba->brd_no,
+						&lpfc_msgBlk0216,
+						lpfc_mes0216,
+						lpfc_msgBlk0216.msgPreambleStr,
+						blp->nlp_sid, ndlp->nlp_DID,
+						blp->nlp_bind_type,
+						ndlp->nlp_flag, ndlp->nlp_state,
+						ndlp->nlp_rpi);
+
+					return (blp);
+				}
+				goto errid;
+			}
+		}
+	}
+
+	if (clp[LPFC_CFG_AUTOMAP].a_current) {
+		while (1) {
+			if ((lpfc_binding_useid(phba, phba->sid_cnt))
+			     || (lpfc_mapping_useid (phba, phba->sid_cnt))) {
+
+				phba->sid_cnt++;
+			} else {
+				if ((blp =
+				     lpfc_create_binding(phba, ndlp,
+							 phba->sid_cnt,
+							 phba->fcp_mapping))) {
+					ndlp->nlp_sid = blp->nlp_sid;
+					ndlp->nlp_Target = blp->nlp_Target;
+					ndlp->nlp_flag &= ~NLP_SEED_MASK;
+					switch ((blp->
+						 nlp_bind_type & FCP_SEED_MASK))
+					{
+					case FCP_SEED_WWPN:
+						ndlp->nlp_flag |= NLP_SEED_WWPN;
+						break;
+					case FCP_SEED_WWNN:
+						ndlp->nlp_flag |= NLP_SEED_WWNN;
+						break;
+					case FCP_SEED_DID:
+						ndlp->nlp_flag |= NLP_SEED_DID;
+						break;
+					}
+					blp->nlp_bind_type |= FCP_SEED_AUTO;
+					ndlp->nlp_flag |= NLP_AUTOMAP;
+
+					phba->sid_cnt++;
+
+					/* Assign scsi id <sid> to NPort
+					   <nlp_DID> */
+					lpfc_printf_log(phba->brd_no,
+						&lpfc_msgBlk0229,
+						lpfc_mes0229,
+						lpfc_msgBlk0229.msgPreambleStr,
+						blp->nlp_sid, ndlp->nlp_DID,
+						blp->nlp_bind_type,
+						ndlp->nlp_flag, ndlp->nlp_state,
+						ndlp->nlp_rpi);
+
+					return (blp);
+				}
+				goto errid;
+			}
+		}
+	}
+	/* if automap on */
+      errid:
+	/* Cannot assign scsi id on NPort <nlp_DID> */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0230,
+			lpfc_mes0230,
+			lpfc_msgBlk0230.msgPreambleStr,
+			ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,
+			ndlp->nlp_rpi);
+
+	return (0);
+}
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_sched.c linux-8155/drivers/addon/lpfc/lpfc_sched.c
--- linux-8152/drivers/addon/lpfc/lpfc_sched.c
+++ linux-8155/drivers/addon/lpfc/lpfc_sched.c
@@ -0,0 +1,930 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_sched.c 328 2005-05-03 15:20:43Z sf_support $
+ */
+
+#include <linux/version.h>
+#include <linux/spinlock.h>
+
+
+#include <linux/blk.h>
+#include <scsi.h>
+
+#include "lpfc_hw.h"
+#include "lpfc_mem.h"
+#include "lpfc_sli.h"
+#include "lpfc_sched.h"
+#include "lpfc_disc.h"
+#include "lpfc.h"
+#include "lpfc_logmsg.h"
+#include "lpfc_fcp.h"
+#include "lpfc_scsi.h"
+#include "lpfc_cfgparm.h"
+#include "lpfc_crtn.h"
+
+struct lpfcHBA;
+
+/* *********************************************************************
+**
+**    Forward declaration of internal routines to SCHED
+**
+** ******************************************************************** */
+
+static void lpfc_sched_internal_check(lpfcHBA_t * hba);
+
+/* ***************************************************************
+**
+**  Initialize HBA, TARGET and LUN SCHED structures
+**  Basically clear them, set MaxQueue Depth
+** and mark them ready to go
+**
+** **************************************************************/
+
+void
+lpfc_sched_init_hba(lpfcHBA_t * hba, uint16_t maxOutstanding)
+{
+	memset(&hba->hbaSched, 0, sizeof (hba->hbaSched));
+	hba->hbaSched.maxOutstanding = maxOutstanding;
+	hba->hbaSched.status = LPFC_SCHED_STATUS_OKAYTOSEND;
+	INIT_LIST_HEAD(&hba->hbaSched.highPriorityCmdList);
+	INIT_LIST_HEAD(&hba->hbaSched.targetRing);
+}
+
+void
+lpfc_sched_target_init(LPFCSCSITARGET_t * target, uint16_t maxOutstanding)
+{
+	memset(&target->targetSched, 0, sizeof (target->targetSched));
+	target->targetSched.maxOutstanding = maxOutstanding;
+	target->targetSched.status = LPFC_SCHED_STATUS_OKAYTOSEND;
+	/* initlize the queue */
+	INIT_LIST_HEAD(&target->listentry);
+	INIT_LIST_HEAD(&target->targetSched.lunRing);
+	return;
+}
+
+void
+lpfc_sched_lun_init(LPFCSCSILUN_t * lun, uint16_t maxOutstanding)
+{
+	memset(&lun->lunSched, 0, sizeof (lun->lunSched));
+	lun->lunSched.maxOutstanding = maxOutstanding;
+	lun->fcp_lun_queue_depth = lun->lunSched.maxOutstanding;
+	lun->lunSched.status = LPFC_SCHED_STATUS_OKAYTOSEND;
+	/* initialize list */
+	INIT_LIST_HEAD(&lun->lunSched.commandList);
+	INIT_LIST_HEAD(&lun->listentry);
+
+	return;
+}
+
+void
+lpfc_sched_pause_target(LPFCSCSITARGET_t * target)
+{
+	target->targetSched.status = LPFC_SCHED_STATUS_PAUSED;
+
+	return;
+}
+
+void
+lpfc_sched_pause_hba(lpfcHBA_t * hba)
+{
+	hba->hbaSched.status = LPFC_SCHED_STATUS_PAUSED;
+
+	return;
+}
+
+void
+lpfc_sched_continue_target(LPFCSCSITARGET_t * target)
+{
+	target->targetSched.status = LPFC_SCHED_STATUS_OKAYTOSEND;
+	/* Make target the next LPFCSCSITARGET_t to process */
+	lpfc_sched_internal_check(target->pHba);
+	return;
+}
+
+void
+lpfc_sched_continue_hba(lpfcHBA_t * hba)
+{
+	hba->hbaSched.status = LPFC_SCHED_STATUS_OKAYTOSEND;
+	lpfc_sched_internal_check(hba);
+	return;
+}
+
+void
+lpfc_sched_sli_done(lpfcHBA_t * pHba,
+		    LPFC_IOCBQ_t * pIocbIn, LPFC_IOCBQ_t * pIocbOut)
+{
+	LPFC_SCSI_BUF_t *pCommand = (LPFC_SCSI_BUF_t *) pIocbIn->context1;
+	LPFCSCSILUN_t *plun = pCommand->pLun;
+	static int doNotCheck = 0;
+	lpfcCfgParam_t *clp;
+	FCP_RSP *fcprsp;
+
+	plun->lunSched.currentOutstanding--;
+	plun->pTarget->targetSched.currentOutstanding--;
+
+	pCommand->result = pIocbOut->iocb.un.ulpWord[4];
+	if ((pCommand->status = pIocbOut->iocb.ulpStatus) ==
+	    IOSTAT_LOCAL_REJECT) {
+		if(pCommand->result & IOERR_DRVR_MASK) {
+			pCommand->status = IOSTAT_DRIVER_REJECT;
+		}
+	}
+	pCommand->IOxri = pIocbOut->iocb.ulpContext;
+	if (pCommand->status) {
+		plun->errorcnt++;
+	}
+	plun->iodonecnt++;
+
+	pHba->hbaSched.currentOutstanding--;
+
+	fcprsp = pCommand->fcp_rsp;
+	if ((pCommand->status == IOSTAT_FCP_RSP_ERROR) &&
+	    (fcprsp->rspStatus3 == SCSI_STAT_QUE_FULL)) {
+
+		/* Scheduler received Queue Full status from FCP device (tgt>
+		   <lun> */
+		lpfc_printf_log(pHba->brd_no, &lpfc_msgBlk0738,
+				lpfc_mes0738,
+				lpfc_msgBlk0738.msgPreambleStr,
+				pCommand->scsi_target, pCommand->scsi_lun,
+				pCommand->qfull_retry_count,
+				plun->qfull_retries,
+				plun->lunSched.currentOutstanding,
+				plun->lunSched.maxOutstanding);
+
+		if (((plun->qfull_retries > 0) &&
+		     (pCommand->qfull_retry_count < plun->qfull_retries)) || 
+		    (plun->lunSched.currentOutstanding + plun->lunSched.q_cnt == 0)){
+			clp = &pHba->config[0];
+			if (clp[LPFC_CFG_DQFULL_THROTTLE_UP_TIME].a_current) {
+				lpfc_scsi_lower_lun_qthrottle(pHba, pCommand);
+			}
+			lpfc_sched_queue_command(pHba, pCommand);
+			plun->qcmdcnt++;
+			pCommand->qfull_retry_count++;
+			goto skipcmpl;
+		}
+	}
+
+	(pCommand->cmd_cmpl) (pHba, pCommand);
+
+ skipcmpl:
+
+	if (!doNotCheck) {
+		doNotCheck = 1;
+		lpfc_sched_internal_check(pHba);
+		doNotCheck = 0;
+	}
+	return;
+}
+
+void
+lpfc_sched_check(lpfcHBA_t * hba)
+{
+	lpfc_sched_internal_check(hba);
+
+	return;
+}
+
+
+static void    
+lpfc_sched_internal_check(lpfcHBA_t  *hba) 
+{
+	LPFC_SCHED_HBA_t  * hbaSched           = &hba->hbaSched;
+	LPFC_SLI_t        * psli;
+	LPFC_NODELIST_t   * ndlp;
+	int                numberOfFailedTargetChecks = 0;
+	int                didSuccessSubmit   = 0;    /* SLI optimization for Port signals */
+	int                stopSched          = 0;    /* used if SLI rejects on interloop */
+
+	/* get the elx_sli struct from phba */
+	psli = &hba->sli;
+   
+	/* Service the High Priority Queue first */
+	if (hba->hbaSched.q_cnt)
+		lpfc_sched_service_high_priority_queue(hba);
+   
+	/* If targetCount is identically 0 then there are no Targets on the ring therefore
+	   no pending commands on any LUN           
+	*/
+	if ( (hbaSched->targetCount == 0) ||
+	     (hbaSched->status == LPFC_SCHED_STATUS_PAUSED) )   
+		return;
+   
+	/* We are going to cycle through the Targets
+	   on a round robin basis until we make a pass through
+	   with nothing to schedule. 
+	*/
+
+	while ( (stopSched == 0)                                            &&
+		(hbaSched->currentOutstanding < hbaSched->maxOutstanding) &&
+		(numberOfFailedTargetChecks < hbaSched->targetCount) ) {
+		LPFCSCSITARGET_t      *target      = hbaSched->nextTargetToCheck;
+		LPFC_SCHED_TARGET_t   *targetSched = &target->targetSched;
+		LPFCSCSITARGET_t      *newNext     = list_entry(target->listentry.next,
+								LPFCSCSITARGET_t,
+								listentry);
+		int                   numberOfFailedLunChecks = 0;
+      
+		if (target->listentry.next == &hbaSched->targetRing) {
+			newNext = list_entry( hbaSched->targetRing.next,
+					      LPFCSCSITARGET_t,
+					      listentry);
+		}
+
+		if (( targetSched->currentOutstanding  < targetSched->maxOutstanding) &&
+		    ( targetSched->status != LPFC_SCHED_STATUS_PAUSED)) {
+			while ( numberOfFailedLunChecks < targetSched->lunCount ) {
+				LPFCSCSILUN_t      *lun        = target->targetSched.nextLunToCheck;
+				LPFC_SCHED_LUN_t   *lunSched   = &lun->lunSched;
+				LPFCSCSILUN_t      *newNextLun = list_entry(lun->listentry.next,
+									    LPFCSCSILUN_t,
+									    listentry);
+			   
+				if ( lun->listentry.next == &target->targetSched.lunRing ) {
+					newNextLun = list_entry(target->targetSched.lunRing.next,
+								LPFCSCSILUN_t,
+								listentry);
+				}
+
+				if (( lunSched->currentOutstanding < lunSched->maxOutstanding ) &&
+				    ( !(list_empty(&lunSched->commandList))) &&
+				    ( lunSched->status != LPFC_SCHED_STATUS_PAUSED)) {
+					LPFC_SCSI_BUF_t   *command;
+					int               sliStatus;
+					LPFC_IOCBQ_t      *pIocbq;
+					struct list_head *head;
+
+					head = lunSched->commandList.next;
+					command = list_entry(head,
+							     LPFC_SCSI_BUF_t,
+							     listentry);
+					list_del(head);
+					--lunSched->q_cnt;
+				   
+					if (!command) {
+						numberOfFailedLunChecks++;
+						targetSched->nextLunToCheck  = newNextLun;
+						continue;
+					}
+				   
+					ndlp = command->pLun->pnode;
+					if(ndlp == 0) {
+						numberOfFailedLunChecks++;
+						lpfc_sched_queue_command(hba,command);
+						targetSched->nextLunToCheck  = newNextLun;
+						continue;
+					}
+	       
+					pIocbq = &command->cur_iocbq;
+				   
+					pIocbq->context1  = command;
+					pIocbq->iocb_cmpl = lpfc_sched_sli_done;
+				   
+					/* put the RPI number and NODELIST info in the IOCB command */
+					pIocbq->iocb.ulpContext = ndlp->nlp_rpi;
+					if (ndlp->nlp_fcp_info & NLP_FCP_2_DEVICE) {
+						pIocbq->iocb.ulpFCP2Rcvy = 1;
+					}
+					pIocbq->iocb.ulpClass = (ndlp->nlp_fcp_info & 0x0f);
+				   
+					/* Get an iotag and finish setup of IOCB  */
+					pIocbq->iocb.ulpIoTag = lpfc_sli_next_iotag( hba,
+										     &psli->ring[ psli->fcp_ring] );
+					if(pIocbq->iocb.ulpIoTag == 0) {
+						stopSched = 1;
+						list_add(&command->listentry,
+							 &lunSched->commandList);
+						++lunSched->q_cnt;
+						break;
+					}
+				   
+					sliStatus = lpfc_sli_issue_iocb(hba,
+									&psli->ring[ psli->fcp_ring],
+									pIocbq, SLI_IOCB_RET_IOCB);
+	       
+				   
+					switch (sliStatus) {
+					case  IOCB_ERROR:   
+					case  IOCB_BUSY: 
+						stopSched = 1;
+						list_add(&command->listentry,
+							 &lunSched->commandList);
+						++lunSched->q_cnt;
+						break;
+		     
+					case  IOCB_SUCCESS:
+						didSuccessSubmit = 1;
+						lunSched->currentOutstanding++;
+						targetSched->currentOutstanding++;
+						hbaSched->currentOutstanding++;
+						targetSched->nextLunToCheck = newNextLun;
+						break;
+		     
+					default:
+						break;
+					}      /* End of Switch */				   
+
+					/* 
+					 * Check if there is any pending command on the lun. If not 
+					 * remove the lun. If this is the last lun in the target, the
+					 * target also will get removed from the scheduler ring.
+					 */
+					if (list_empty(&lunSched->commandList))		   
+						lpfc_sched_remove_lun_from_ring(hba,lun);
+
+					/* Either we shipped or SLI refused the operation. In any chase
+					 * the driver is done with this LUN/Target!. 
+					 */
+					break;
+
+					/* This brace ends LUN window open */
+				}   
+				else {
+					numberOfFailedLunChecks++;
+					targetSched->nextLunToCheck = newNextLun;
+				}
+				/* This brace ends While looping through LUNs on a Target */
+			}
+	 
+			if ( numberOfFailedLunChecks >= targetSched->lunCount )  
+				numberOfFailedTargetChecks++;
+			else 
+				numberOfFailedTargetChecks = 0;
+		}   /* if Target isn't pended */
+		else 
+			numberOfFailedTargetChecks++;
+      
+		hbaSched->nextTargetToCheck = newNext;
+	}   /* While looping through Targets on HBA */
+  
+	return;
+}
+
+
+void
+lpfc_sched_service_high_priority_queue(struct lpfcHBA *hba)
+{
+	LPFC_SLI_t *psli;
+	LPFC_NODELIST_t *ndlp;
+
+	LPFC_IOCBQ_t *pIocbq;
+	LPFC_SCSI_BUF_t *command;
+	int sliStatus;
+	struct list_head *pos, *pos_tmp;
+
+	psli = &hba->sli;
+
+	/* 
+	 * Iterate through highprioritycmdlist if any cmds waiting on it
+	 * dequeue first cmd from highPriorityCmdList
+	 * 
+	 */
+	list_for_each_safe(pos, pos_tmp, &hba->hbaSched.highPriorityCmdList) {
+		command =
+			list_entry(pos,
+				   LPFC_SCSI_BUF_t,
+				   listentry);
+		list_del(pos);
+		--hba->hbaSched.q_cnt;
+
+		if (!command) {
+			continue;
+		}
+
+		if ((command->pLun) && (command->pLun->pnode)) {
+
+			ndlp = command->pLun->pnode;
+			if (ndlp == 0) {
+
+			} else {
+				/* put the RPI number and NODELIST info in the
+				   IOCB command */
+				pIocbq = &command->cur_iocbq;
+				pIocbq->iocb.ulpContext = ndlp->nlp_rpi;
+				if (ndlp->nlp_fcp_info & NLP_FCP_2_DEVICE) {
+					pIocbq->iocb.ulpFCP2Rcvy = 1;
+				}
+				pIocbq->iocb.ulpClass =
+					(ndlp->nlp_fcp_info & 0x0f);
+			}
+		}
+
+		pIocbq = &command->cur_iocbq;
+		/*  Current assumption is let SLI queue it until it busy us */
+
+		pIocbq->context1 = command;
+
+		/* Fill in iocb completion callback  */
+		pIocbq->iocb_cmpl = lpfc_sli_wake_iocb_high_priority;
+
+		/* Fill in iotag if we don't have one yet */
+		if (pIocbq->iocb.ulpIoTag == 0) {
+			pIocbq->iocb.ulpIoTag =
+				lpfc_sli_next_iotag(hba,
+						    &psli->ring[psli->fcp_ring]);
+		}
+
+		sliStatus = lpfc_sli_issue_iocb(hba,
+						&psli->ring[psli->fcp_ring],
+						pIocbq,
+						SLI_IOCB_HIGH_PRIORITY |
+						SLI_IOCB_RET_IOCB);
+
+		switch (sliStatus) {
+		case IOCB_ERROR:
+		case IOCB_BUSY:
+			/* We'll put it back to the head of the q and try
+			   again */
+			list_add(&command->listentry,
+				 &hba->hbaSched.highPriorityCmdList);
+			++hba->hbaSched.q_cnt;
+			break;
+
+		case IOCB_SUCCESS:
+			hba->hbaSched.currentOutstanding++;
+			break;
+
+		default:
+
+			break;
+		}
+
+		break;
+	}
+
+	return;
+}
+
+LPFC_SCSI_BUF_t *
+lpfc_sched_dequeue(lpfcHBA_t * hba, LPFC_SCSI_BUF_t * ourCommand)
+{
+	LPFC_SCSI_BUF_t *currentCommand=0;
+	LPFC_SCHED_LUN_t *pLunSched;
+	struct list_head *cur, *next;
+
+	pLunSched = &ourCommand->pLun->lunSched;
+	list_for_each_safe (cur, next, &pLunSched->commandList) {
+		currentCommand = list_entry(cur, LPFC_SCSI_BUF_t, listentry);
+
+		if (currentCommand == ourCommand) {	/* found it */
+			/* remove this entry from queue */
+			list_del(cur);
+
+			--pLunSched->q_cnt;
+
+			if (!pLunSched->q_cnt){
+				/* queue is empty */
+				lpfc_sched_remove_lun_from_ring(hba,
+								ourCommand->pLun);
+			}
+			break;
+		}
+	}
+
+	return (currentCommand);;
+}
+
+uint32_t
+lpfc_sched_flush_command(lpfcHBA_t * pHba,
+			 LPFC_SCSI_BUF_t * command,
+			 uint8_t iocbStatus, uint32_t word4)
+{
+	LPFC_SCSI_BUF_t *foundCommand = lpfc_sched_dequeue(pHba, command);
+	uint32_t found = 0;
+
+	if (foundCommand) {
+		IOCB_t *pIOCB = (IOCB_t *) & (command->cur_iocbq.iocb);
+		found++;
+		pIOCB->ulpStatus = iocbStatus;
+		foundCommand->status = iocbStatus;
+		if (word4) {
+			pIOCB->un.ulpWord[4] = word4;
+			foundCommand->result = word4;
+		}
+
+		if (foundCommand->status) {
+			foundCommand->pLun->errorcnt++;
+		}
+		foundCommand->pLun->iodonecnt++;
+
+		(command->cmd_cmpl) (pHba, command);
+	} else {
+		/* if we couldn't find this command is not in the scheduler,
+		   look for it in the SLI layer */
+		if (lpfc_sli_abort_iocb_context1
+		    (pHba, &pHba->sli.ring[pHba->sli.fcp_ring], command) == 0) {
+			found++;
+		}
+	}
+
+	return found;
+}
+
+uint32_t
+lpfc_sched_flush_lun(lpfcHBA_t * pHba,
+		     LPFCSCSILUN_t * lun, uint8_t iocbStatus, uint32_t word4)
+{
+	struct list_head *cur, *next;
+
+	int numberFlushed = 0;
+
+	list_for_each_safe(cur, next, &lun->lunSched.commandList) {
+		IOCB_t *pIOCB;
+		LPFC_SCSI_BUF_t *command =
+			list_entry(cur,
+				   LPFC_SCSI_BUF_t,
+				   listentry);
+		list_del(cur);
+		--lun->lunSched.q_cnt;
+
+		pIOCB = (IOCB_t *) & (command->cur_iocbq.iocb);
+		pIOCB->ulpStatus = iocbStatus;
+		command->status = iocbStatus;
+		if (word4) {
+			pIOCB->un.ulpWord[4] = word4;
+			command->result = word4;
+		}
+
+		if (command->status) {
+			lun->errorcnt++;
+		}
+		lun->iodonecnt++;
+
+		(command->cmd_cmpl) (pHba, command);
+
+		numberFlushed++;
+	}
+	lpfc_sched_remove_lun_from_ring(pHba, lun);
+
+	/* flush the SLI layer also */
+	lpfc_sli_abort_iocb_lun(pHba, &pHba->sli.ring[pHba->sli.fcp_ring],
+				lun->pTarget->scsi_id, lun->lun_id);
+	return (numberFlushed);
+}
+
+uint32_t
+lpfc_sched_flush_target(lpfcHBA_t * pHba,
+			LPFCSCSITARGET_t * target,
+			uint8_t iocbStatus, uint32_t word4)
+{
+	LPFCSCSILUN_t *lun;
+	int numberFlushed = 0;
+	struct list_head *cur_h, *next_h;
+	struct list_head *cur_l, *next_l;
+
+	if (target->rptlunfunc.function) {
+		lpfc_stop_timer((struct clk_data *) target->rptlunfunc.data);
+		target->targetFlags &= ~FC_RETRY_RPTLUN;
+	}
+
+	/* walk the list of LUNs on this target and flush each LUN.  We
+	   accomplish this by pulling the first LUN off the head of the
+	   queue until there aren't any LUNs left */
+	list_for_each_safe(cur_h, next_h, &target->targetSched.lunRing) {
+		lun = list_entry(cur_h,
+				 LPFCSCSILUN_t,
+				 listentry);
+		
+		list_for_each_safe(cur_l, next_l, &lun->lunSched.commandList) {
+			IOCB_t *pIOCB;
+			LPFC_SCSI_BUF_t *command =
+				list_entry(cur_l,
+					   LPFC_SCSI_BUF_t,
+					   listentry);
+			list_del(cur_l);
+			--lun->lunSched.q_cnt;
+
+			pIOCB = (IOCB_t *) & (command->cur_iocbq.iocb);
+			pIOCB->ulpStatus = iocbStatus;
+			command->status = iocbStatus;
+			if (word4) {
+				pIOCB->un.ulpWord[4] = word4;
+				command->result = word4;
+			}
+
+			if (command->status) {
+				lun->errorcnt++;
+			}
+			lun->iodonecnt++;
+
+			(command->cmd_cmpl) (pHba, command);
+
+			numberFlushed++;
+		}
+
+		lpfc_sched_remove_lun_from_ring(pHba, lun);
+	}
+	lpfc_sched_remove_target_from_ring(pHba, target);
+
+	/* flush the SLI layer also */
+	lpfc_sli_abort_iocb_tgt(pHba, &pHba->sli.ring[pHba->sli.fcp_ring],
+				target->scsi_id);
+	return (numberFlushed);
+}
+
+uint32_t
+lpfc_sched_flush_hba(lpfcHBA_t * pHba, uint8_t iocbStatus, uint32_t word4)
+{
+	int numberFlushed = 0;
+	LPFCSCSITARGET_t *target;
+	LPFCSCSILUN_t *lun;
+	struct list_head *cur_h, *next_h;
+	struct list_head *cur_l, *next_l;
+	struct list_head *cur_c, *next_c;
+
+	list_for_each_safe(cur_h, next_h, &pHba->hbaSched.targetRing) {
+		target = list_entry(cur_h,
+				    LPFCSCSITARGET_t,
+				    listentry);
+		list_for_each_safe(cur_l, next_l, &target->targetSched.lunRing)
+			{
+				lun = list_entry(cur_l, LPFCSCSILUN_t, listentry);
+				list_for_each_safe(cur_c, next_c,
+						   &lun->lunSched.commandList) {
+					IOCB_t *pIOCB;
+					LPFC_SCSI_BUF_t *command =
+						list_entry(cur_c,
+							   LPFC_SCSI_BUF_t,
+							   listentry);
+					list_del(cur_c);
+					--lun->lunSched.q_cnt;
+
+					pIOCB = (IOCB_t *) & (command->cur_iocbq.iocb);
+					pIOCB->ulpStatus = iocbStatus;
+					command->status = iocbStatus;
+					if (word4) {
+						pIOCB->un.ulpWord[4] = word4;
+						command->result = word4;
+					}
+
+					if (command->status) {
+						lun->errorcnt++;
+					}
+					lun->iodonecnt++;
+
+					(command->cmd_cmpl) (pHba, command);
+
+					numberFlushed++;
+				}
+
+				lpfc_sched_remove_lun_from_ring(pHba, lun);
+			}
+		lpfc_sched_remove_target_from_ring(pHba, target);
+	}
+
+	/* flush the SLI layer also */
+	lpfc_sli_abort_iocb_hba(pHba, &pHba->sli.ring[pHba->sli.fcp_ring]);
+	return (numberFlushed);
+}
+
+int
+lpfc_sched_submit_command(lpfcHBA_t * hba, LPFC_SCSI_BUF_t * command)
+{
+	LPFC_NODELIST_t *ndlp;
+	uint16_t okayToSchedule = 1;
+
+	/* If we have a command see if we can cut through */
+	if (command != 0) {
+
+		/* Just some short cuts */
+		LPFC_SCHED_HBA_t *hbaSched = &hba->hbaSched;
+		LPFC_SCHED_LUN_t *lunSched = &command->pLun->lunSched;
+		LPFC_SCHED_TARGET_t *targetSched =
+			&command->pLun->pTarget->targetSched;
+		LPFC_IOCBQ_t *pIocbq = &command->cur_iocbq;
+		LPFC_SLI_t *psli = &hba->sli;
+
+		/*    Set it up so SLI calls us when it is done       */
+
+		ndlp = command->pLun->pnode;
+		if (ndlp == 0) {
+			if(!(command->pLun->pTarget->targetFlags &
+				FC_NPR_ACTIVE)) {
+				return (1);
+			}
+			/* To be filled in later */
+			pIocbq->iocb.ulpContext = 0;
+			pIocbq->iocb.ulpFCP2Rcvy = 0;
+			pIocbq->iocb.ulpClass = CLASS3;
+		}
+		else {
+			/* put RPI number and NODELIST info in IOCB command */
+			pIocbq->iocb.ulpContext = ndlp->nlp_rpi;
+			if (ndlp->nlp_fcp_info & NLP_FCP_2_DEVICE) {
+				pIocbq->iocb.ulpFCP2Rcvy = 1;
+			}
+			pIocbq->iocb.ulpClass = (ndlp->nlp_fcp_info & 0x0f);
+		}
+
+		pIocbq->context1 = command;
+		pIocbq->iocb_cmpl = lpfc_sched_sli_done;
+
+		/* Get an iotag and finish setup of IOCB  */
+		pIocbq->iocb.ulpIoTag = lpfc_sli_next_iotag(hba,
+							    &psli->ring[psli->fcp_ring]);
+
+		if ((pIocbq->iocb.ulpIoTag != 0) && ndlp &&
+		    (hbaSched->currentOutstanding < hbaSched->maxOutstanding) &&
+		    (hbaSched->status & LPFC_SCHED_STATUS_OKAYTOSEND) &&
+		    (targetSched->lunCount == 0) &&
+		    (targetSched->currentOutstanding <
+		     targetSched->maxOutstanding)
+		    && (targetSched->status & LPFC_SCHED_STATUS_OKAYTOSEND)
+		    && (lunSched->currentOutstanding < lunSched->maxOutstanding)
+		    && (lunSched->status & LPFC_SCHED_STATUS_OKAYTOSEND)
+		    ) {
+
+			/* The scheduler, target and lun are all in a position
+			 * to accept a send operation.  Call the SLI layer and
+			 * issue the IOCB.
+			 */
+
+			int sliStatus;
+
+			
+			sliStatus =
+				lpfc_sli_issue_iocb(hba,
+						    &psli->ring[psli->fcp_ring],
+						    pIocbq, SLI_IOCB_RET_IOCB);
+
+			switch (sliStatus) {
+			case IOCB_ERROR:
+			case IOCB_BUSY:
+				okayToSchedule = 0;
+				lpfc_sched_queue_command(hba, command);
+				break;
+			case IOCB_SUCCESS:
+				lunSched->currentOutstanding++;
+				targetSched->currentOutstanding++;
+				hbaSched->currentOutstanding++;
+				break;
+			default:
+
+				break;
+			}
+
+			/* Remove this state to cause a scan of queues if submit
+			   worked. */
+			okayToSchedule = 0;
+		} else {
+			/* This clause is execute only if there are outstanding
+			 * commands in the scheduler.
+			 */
+			lpfc_sched_queue_command(hba, command);
+		}
+	}
+
+	/* if(command) */
+	/* We either queued something or someone called us to schedule
+	   so now go schedule. */
+	if (okayToSchedule)
+		lpfc_sched_internal_check(hba);
+	return (0);
+}
+
+void
+lpfc_sched_queue_command(lpfcHBA_t * hba, LPFC_SCSI_BUF_t * command)
+{
+	LPFCSCSILUN_t *lun = command->pLun;
+	LPFC_SCHED_LUN_t *lunSched = &lun->lunSched;
+	struct list_head *head;
+	
+	head = (struct list_head *)&lunSched->commandList;
+	
+	list_add_tail(&command->listentry,
+		      head);
+	lunSched->q_cnt++;
+
+	lpfc_sched_add_lun_to_ring(hba, lun);
+
+	return;
+}
+
+void
+lpfc_sched_add_target_to_ring(lpfcHBA_t * hba, LPFCSCSITARGET_t * target)
+{
+	LPFC_SCHED_TARGET_t *targetSched = &target->targetSched;
+	LPFC_SCHED_HBA_t *hbaSched = &hba->hbaSched;
+
+	if (!list_empty(&target->listentry) ||	/* Already on list */
+	    (targetSched->lunCount == 0))	/* nothing to schedule */
+		return;
+
+	list_add_tail(&target->listentry, &hbaSched->targetRing);
+	if ( hbaSched->targetCount == 0 ) {
+		hbaSched->nextTargetToCheck = target;
+	}
+	hbaSched->targetCount++;
+	return;
+}
+
+void
+lpfc_sched_add_lun_to_ring(lpfcHBA_t * hba, LPFCSCSILUN_t * lun)
+{
+	LPFC_SCHED_LUN_t *lunSched = &lun->lunSched;
+	LPFCSCSITARGET_t *target = lun->pTarget;
+	LPFC_SCHED_TARGET_t *targetSched = &target->targetSched;
+
+	if (!list_empty(&lun->listentry) ||	/* Already on list */
+	    (lunSched->q_cnt == 0))	/* nothing to schedule */
+		return;
+
+	list_add_tail(&lun->listentry, &targetSched->lunRing);
+	if ( targetSched->lunCount == 0 ) {
+		targetSched->nextLunToCheck = lun;
+	}
+
+	targetSched->lunCount++;
+	lpfc_sched_add_target_to_ring(hba, target);
+	return;
+}
+
+void
+lpfc_sched_remove_target_from_ring(lpfcHBA_t * hba, LPFCSCSITARGET_t * target)
+{
+
+	LPFC_SCHED_HBA_t *hbaSched = &hba->hbaSched;
+
+	if (list_empty(&target->listentry))
+		return;		/* Not on Ring */
+	hbaSched->targetCount--;
+
+	if ( hbaSched->targetCount ) {
+		if ( hbaSched->nextTargetToCheck == target ) {
+			if (target->listentry.next == &hbaSched->targetRing) {
+				hbaSched->nextTargetToCheck  = list_entry( hbaSched->targetRing.next,
+									   LPFCSCSITARGET_t,
+									   listentry);
+			} else {
+				hbaSched->nextTargetToCheck = list_entry ( target->listentry.next,
+									   LPFCSCSITARGET_t,
+									   listentry);
+			}
+		}
+	} else {
+		hbaSched->nextTargetToCheck = 0;
+	}
+
+	list_del_init(&target->listentry);
+	return;
+}
+
+void
+lpfc_sched_remove_lun_from_ring(lpfcHBA_t * hba, LPFCSCSILUN_t * lun)
+{
+	LPFCSCSITARGET_t *target = lun->pTarget;
+	LPFC_SCHED_TARGET_t *targetSched = &target->targetSched;
+
+	if (list_empty(&lun->listentry))
+		return;		/* Not on Ring  */
+
+	targetSched->lunCount--;
+
+	if ( targetSched->lunCount ) {     /*  Delink the LUN from the Ring */
+		
+		if ( targetSched->nextLunToCheck == lun ) {
+
+			if ( lun->listentry.next == &target->targetSched.lunRing ) {
+				targetSched->nextLunToCheck = 
+					list_entry(target->targetSched.lunRing.next,
+						   LPFCSCSILUN_t,
+						   listentry);
+			} else {
+				targetSched->nextLunToCheck = 
+					list_entry(lun->listentry.next,
+						   LPFCSCSILUN_t,
+						   listentry);
+
+			}
+
+		}
+	} else
+		targetSched->nextLunToCheck = 0; /*   Ring is empty */
+	
+	list_del_init(&lun->listentry);
+
+	if (!targetSched->lunCount)
+		lpfc_sched_remove_target_from_ring(hba, target);
+
+	return;
+}
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_sched.h linux-8155/drivers/addon/lpfc/lpfc_sched.h
--- linux-8152/drivers/addon/lpfc/lpfc_sched.h
+++ linux-8155/drivers/addon/lpfc/lpfc_sched.h
@@ -0,0 +1,267 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_sched.h 328 2005-05-03 15:20:43Z sf_support $
+ */
+
+#ifndef         LPFC_SCHED_H
+#define         LPFC_SCHED_H
+
+/*
+
+There are two key data structures
+
+A LUN Ring which is just a circular list of all LUNs with pending commands.
+
+A command list.. a linked list of all pending commands for a particular LUN.
+The Comand List is a FIFO used by the scheduler although there are routines
+to search and remove a command from the lists.
+
+The HBA structure a pointer to the LUN Ring along with a pointer to the
+the next LUN to be checked for scheduling. The pointer moves around the ring
+as the scheduler checks for commands to release. The HBA has an pointer to the
+ring and a count of the number of LUNs on the ring. If the count is zero then
+the pointers are undefined.
+
+Pointers to each of the command lists pointers are stored in the LUN table
+along with a count of the number of commands on the list.  The list is
+singularly linked the LUN structure as a pointer to the first and last
+command on the list. If a count is zero, the pointers are undefined.
+
+Each Target Structure has a count of the number of LUNs in the target that
+currently have pended commands. As LUNs enter and exit the LUN Ring, the count
+is incremented and decremented respectively.
+
+The HBA, Targets and LUNs have queue depth limits. There are two counters, the
+number of outstanding commands sent to the SLI layer and the max. number of
+commands that should be sent. Associated with each HBA, Target and LUN is a
+status word that has two states OKAYTOSEND or Paused. If a paused, then no
+pending commands form that object will be scheduled. If OKAYTOSEND then pending
+commands will be released to the SLI layer as the queue depth window opens.
+
+
+*/
+
+/* **************************************************************************
+**
+**   The Pending Scheduler (called SCH here) requires a data structures in
+**   each HBA, Target, LUN and SCSI_BUF. This interface defines the following
+**      conventions for calling these structures :
+**               LPFC_type_SCHED_t 
+**                   where type is HBA, LUN, TARGET or SCSI_BUF.
+**
+**   This header should be included BEFORE the actual declarations of the
+**   base structure are defined so the SCH structures can be inline.
+**
+**
+** NOTE:  HBA and LUN SCH structures have a "count" field.
+**        It represents the number of LUNs on the LUN RING and the
+**        number of SCSI_BUFs on the command QUEUEs.  If the "count" is
+**        identically 0, then the value of all pointers in the SCH structure
+**        is NOT DEFINED.  Check the "count" field before attempting to
+**        deference any pointers.
+**
+**   Locking consists of a lock in the HBA Scheduler Data
+**   Considerations for working with LUNs or Targets:
+**   1   Pause the LUN, Target, or HBA   LPFC_SCHED_PAUSE_<LUN,TARGET,HBA>
+**   2   LPFC_SCHED_DEQUEUE_LUN each LUN for commands until 0 is returned
+**   3   Make sure no more commands are sent down with that LUN
+**
+**   Once a LUN pending queue is empty, the Scheduler will have any references
+**   to that LUN structure.
+**
+** ************************************************************************ */
+
+/* ***************************************************************************
+**
+**   Forward declarations needed by the SCHED type structures.  Because
+**   the actual structures will contain these structures and the SCH
+**   structures contains pointers to the containers, the code forward declares
+**   the structure names.
+**
+** ************************************************************************* */
+
+struct lpfcHBA;
+struct lpfcScsiTarget;
+struct lpfcScsiLun;
+struct lpfc_scsi_buf;
+struct lpfcIocbq;
+
+typedef enum {
+	LPFC_SCHED_STATUS_OKAYTOSEND = 1,	/* Okay to search this list  */
+	LPFC_SCHED_STATUS_PAUSED = 2,	/* Do not schedule this list */
+} LPFC_SCHED_STATUS_t;
+
+typedef struct lpfcSchedHBA {
+	struct list_head highPriorityCmdList; /* High priority command queue */
+	uint16_t q_cnt;
+	uint16_t targetCount;	/* Number of elements on Ring */
+	struct list_head targetRing;
+
+	uint16_t maxOutstanding;	/* These 2 words implement queue */
+	uint16_t currentOutstanding;	/* Depth on the HBA. */
+	LPFC_SCHED_STATUS_t status;	/* Status word for stopping any
+					   scheduling of the HBA */
+        struct lpfcScsiTarget *nextTargetToCheck; 
+} LPFC_SCHED_HBA_t;		/*   layer without queueing */
+
+/* ****************************************************************************
+**
+**    Scheduler Data for Target
+**
+**   lunCount lunList and nextLunToCheck are used to
+**   manage a list of LUNs that have pending commands
+**   We keep here the queue depth for the Target, Target Queue Status
+**
+** ************************************************************************** */
+
+typedef struct lpfcSchedTarget {
+	struct list_head lunRing;
+
+	int16_t lunCount;	/* Number of elements on Ring */
+	int16_t maxOutstanding;	/* Max # of commands that can be outstanding */
+	int16_t currentOutstanding; /* # of commands that currently
+				       outstanding. */
+	LPFC_SCHED_STATUS_t status;	/* Pended entries can be scheduled or */
+	/*   or not at this time. */
+	struct lpfcScsiLun *nextLunToCheck;
+} LPFC_SCHED_TARGET_t;
+
+/* ****************************************************************************
+**
+**    Scheduler Data for a LUN
+**
+**   SCSI_BUFs that are pending are keeped on a singly link list.
+**   Each LUN_SCH has a pointer to the first and last entry.
+**   In most cases 99.9999% all commands are released FIFO
+**   exceptions are ABORT, LUN and Target Resets (and internal
+**   conditions that have the same effect).
+**
+**  The "count" field is the number of commands on list.  If count is
+**  identically 0 the values of firstCommand and lastCommand are undefined.
+**
+**  LUNS with pending commands are doubly linked into a ring.
+**  nextLun and previousLun point to other LUNs on the ring.
+**  (HBA_SCH contains a pointer to the LUN RING.)
+**  If count is identically 0 then there are no commands and therefore
+**  the LUN is NOT on the ring and therefore the
+**  nextLUN and previousLun are undefined when
+**  count is identically 0.
+**
+**  Status is used to signal whether commands on this LUN
+**  can be scheduled.
+**
+**  maxOutstanding and currentOutstanding are used for queue depth
+**  management for this LUN
+**
+**  Only Statistic variable is maxCount which is the max number of commands
+**  ever queued by this LUN.
+** ************************************************************************** */
+
+typedef struct {
+	struct list_head commandList;	/* Next command to be scheduled */
+	uint16_t q_cnt; /* commandList queue count */
+	LPFC_SCHED_STATUS_t status;	/*Status of this LUN's queue   */
+	uint16_t maxOutstanding;	/*Queue Depth for the LUN      */
+	uint16_t currentOutstanding;
+} LPFC_SCHED_LUN_t;
+
+/*    Scheduler Data for each Command   */
+
+typedef struct {
+	struct lpfc_scsi_buf *nextCommand;
+} LPFC_SCHED_SCSI_BUF_t;
+
+/* ********************** FUNCTION DECLARATIONS   **************************
+**
+**   The next 3 routines initialize the SCH structures. Basically
+**   clear the block and set the queue depth.  No Lock is taken
+**
+** ********************************************************************** */
+
+void lpfc_sched_hba_init(struct lpfcHBA *hba, uint16_t maxOutstanding);
+void lpfc_sched_target_init(struct lpfcScsiTarget *target,
+			   uint16_t maxOutstanding);
+void lpfc_sched_lun_init(struct lpfcScsiLun *lun, uint16_t maxOutstanding);
+
+/* **********************************************************************
+**
+**   Pause and Continue the scheduler
+**
+** ********************************************************************* */
+
+void lpfc_sched_pause_target(struct lpfcScsiTarget *target);
+void lpfc_sched_pause_hba(struct lpfcHBA *hba);
+void lpfc_sched_continue_target(struct lpfcScsiTarget *target);
+void lpfc_sched_continue_hba(struct lpfcHBA *hba);
+
+/* ********************************************************************
+**   Used to schedule a SCSI IO (including Task Management) IOCBs
+**   to be passed to the SLI layer.  HBA -> to the HBA structure
+**   command pts to the SCSI_BUF to be submitted.
+** ********************************************************************** */
+
+void lpfc_sched_service_high_priority_queue(struct lpfcHBA *pHba);
+
+/*      
+ * When a command is returned from the SLI layer, pass it back through
+ * the scheduler so the queue depths can be updated.  Scheduling is NOT.
+ * performed as part of this command.  This approach allows multiple 
+ * completions before insertions and reduces recursion issues.
+ */
+
+void lpfc_sched_sli_done(struct lpfcHBA *hba, struct lpfcIocbq *iocbqin,
+			struct lpfcIocbq *iocbqout);
+
+/* **************************************************************************
+**
+**   Use this command to kick of a search of pended SCSI_BUFs to be sent to the
+**   SLI layer.
+**
+** ****************************************************************************/
+
+void lpfc_sched_check(struct lpfcHBA *hba);
+
+/* **************************************************************************
+**
+**   Check to see if a command is currently in the scheduler and removes
+**   it if it is.  Returns 0 if not found or the pointer if it was found
+**
+**   DEQUEUE_LUN just gets the first command on the LUN pending queue or 0
+**   if there are none.  (You might want to pause the LUN before this call).
+**
+** ****************************************************************************/
+
+struct lpfc_scsi_buf *lpfc_sched_dequeue(struct lpfcHBA *hba,
+				       struct lpfc_scsi_buf *command);
+
+uint32_t lpfc_sched_flush_hba(struct lpfcHBA *hba, uint8_t status,
+			     uint32_t word4);
+uint32_t lpfc_sched_flush_target(struct lpfcHBA *hba,
+				struct lpfcScsiTarget *target, uint8_t status,
+				uint32_t word4);
+uint32_t lpfc_sched_flush_lun(struct lpfcHBA *hba, struct lpfcScsiLun *lun,
+			     uint8_t status, uint32_t word4);
+uint32_t lpfc_sched_flush_command(struct lpfcHBA *hba,
+				 struct lpfc_scsi_buf *command, uint8_t status,
+				 uint32_t word4);
+
+#endif
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_scsi.h linux-8155/drivers/addon/lpfc/lpfc_scsi.h
--- linux-8152/drivers/addon/lpfc/lpfc_scsi.h
+++ linux-8155/drivers/addon/lpfc/lpfc_scsi.h
@@ -0,0 +1,228 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_scsi.h 328 2005-05-03 15:20:43Z sf_support $
+ */
+
+#ifndef _H_LPFC_SCSI
+#define _H_LPFC_SCSI
+
+/*
+ * SCSI node structure for each open Fibre Channel node
+ * used by scsi transport.
+ */
+
+struct lpfcHBA;
+
+typedef struct lpfcScsiTarget {
+	struct lpfcHBA *pHba;	/* adapter structure ptr */
+	struct list_head   lunlist;
+	void *pcontext;		/* LPFC_NODELIST_t * for device */
+	struct timer_list tmofunc;
+	struct timer_list rptlunfunc;
+	struct list_head listentry; /* scsi target queue entry */
+	LPFC_SCHED_TARGET_t targetSched; /* Scheduling Info for this target */
+	uint16_t max_lun;	/* max lun supported */
+	uint16_t scsi_id;	/* SCSI ID of this device */
+
+	uint16_t rpi;
+
+	uint16_t targetFlags;
+#define FC_NODEV_TMO        0x1	/* nodev-tmo tmr started and expired */
+#define FC_FCP2_RECOVERY    0x2	/* set FCP2 Recovery for commands */
+#define FC_RETRY_RPTLUN     0x4	/* Report Lun has been retried */
+#define FC_NPR_ACTIVE       0x10	/* NPort Recovery active */
+
+	uint16_t addrMode;	/* SCSI address method */
+#define PERIPHERAL_DEVICE_ADDRESSING    0
+#define VOLUME_SET_ADDRESSING           1
+#define LOGICAL_UNIT_ADDRESSING         2
+
+	uint16_t rptLunState;	/* For report lun SCSI command */
+#define REPORT_LUN_REQUIRED     0
+#define REPORT_LUN_ONGOING      1
+#define REPORT_LUN_COMPLETE     2
+#define REPORT_LUN_ERRORED      3
+
+	DMABUF_t *RptLunData;
+
+	void *pTargetProto;	/* target struc for driver type */
+	void *pTargetOSEnv;
+
+	union {
+		uint32_t dev_did;	/* SCSI did */
+	} un;
+
+} LPFCSCSITARGET_t;
+
+#define LPFC_SCSI_BUF_SZ        1024  /* used for driver generated scsi cmds */
+#define LPFC_SCSI_PAGE_BUF_SZ   4096  /* used for driver RPTLUN cmds */
+#define LPFC_INQSN_SZ           64    /* Max size of Inquiry serial number */
+
+struct fcPathId;
+struct fcRouteId;
+
+struct lpfcScsiLun {
+	struct list_head list;	/* Used for list of LUNs on this node */
+	LPFC_NODELIST_t *pnode;	/* Pointer to the node structure. */
+	struct lpfcHBA *pHBA;	/* Pointer to the HBA with
+				   which this LUN is
+				   associated. */
+	LPFCSCSITARGET_t *pTarget;	/* Pointer to the target structure */
+	struct lpfcScsiLun *pnextLun;	/* Used for list of LUNs on this node */
+
+	uint64_t lun_id;		/* LUN ID of this device */
+	uint32_t qcmdcnt;
+	uint32_t iodonecnt;
+	uint32_t errorcnt;
+
+	void *pLunOSEnv;
+
+	/*
+	 *  A command lives in a pending queue until it is sent to the HBA.
+	 *  Throttling constraints apply:
+	 *          No more than N commands total to a single target
+	 *          No more than M commands total to a single LUN on that target
+	 *
+	 *  A command that has left the pending queue and been sent to the HBA
+	 *  is an "underway" command.  We count underway commands, per-LUN,
+	 *  to obey the LUN throttling constraint.
+	 *
+	 *  Because we only allocate enough fc_buf_t structures to handle N
+	 *  commands, per target, we implicitly obey the target throttling
+	 *  constraint by being unable to send a command when we run out of
+	 *  free fc_buf_t structures.
+	 *
+	 *  We count the number of pending commands to determine whether the
+	 *  target has I/O to be issued at all.
+	 *
+	 *  We use next_pending to rotor through the LUNs, issuing one I/O at
+	 *  a time for each LUN.  This mechanism guarantees a fair distribution
+	 *  of I/Os across LUNs in the face of a target queue_depth lower than
+	 *  #LUNs*fcp_lun_queue_depth.
+	 */
+	LPFC_SCHED_LUN_t lunSched;	/* Used to schedule I/O to HBA */
+	uint16_t fcp_lun_queue_depth;	/* maximum # cmds to each lun */
+	uint8_t stop_send_io;	/* stop sending any io to this dev */
+	uint32_t lunFlag;	/* flags for the drive */
+#define SCSI_TQ_HALTED        0x0001	/* The transaction Q is halted */
+#define SCSI_TQ_CLEARING      0x0002	/* The transaction Q is clearing */
+#define SCSI_TQ_CLEAR_ACA     0x0004	/* a CLEAR_ACA is PENDING      */
+#define SCSI_LUN_RESET        0x0008	/* sent LUN_RESET not of TARGET_RESET */
+#define SCSI_ABORT_TSET       0x0010	/* BDR requested but not yet sent */
+#define SCSI_TARGET_RESET     0x0020	/* a SCSI BDR is active for device */
+#define CHK_SCSI_ABDR         0x0038	/* value used to check tm flags */
+#define QUEUED_FOR_ABDR       0x0040	/* dev_ptr is on ABORT_BDR queue */
+#define NORPI_RESET_DONE      0x0100	/* BOGUS_RPI Bus Reset attempted */
+#define LUN_BLOCKED           0x0200	/* if flag is set, this lun has been
+					   blocked */
+#define SCSI_BUMP_QDEPTH      0x0800	/* bump qdepth to max after cmpl */
+#define SCSI_SEND_INQUIRY_SN  0x1000	/* Serial number inq should be sent */
+#define SCSI_INQUIRY_SN       0x2000	/* Serial number inq has been sent */
+#define SCSI_INQUIRY_P0       0x4000	/* Page 0 inq has been sent */
+#define SCSI_INQUIRY_CMD      0x6000	/* Serial number or Page 0 inq sent */
+#define SCSI_P0_INFO          0x20000	/* device has good P0 info */
+
+	uint16_t qfull_retries;	/* # of retries on qfull condition */
+	struct timer_list qfull_tmo_id;
+
+	uint32_t failMask;	/* failure mask for device */
+
+	uint8_t InquirySN[LPFC_INQSN_SZ];	/* serial number from Inquiry */
+	uint8_t Vendor[8];	/* From Page 0 Inquiry */
+	uint8_t Product[16];	/* From Page 0 Inquiry */
+	uint8_t Rev[4];		/* From Page 0 Inquiry */
+	uint8_t sizeSN;		/* size of InquirySN */
+	struct list_head listentry; /* scsi lun queue entry */
+};
+
+typedef struct lpfcScsiLun LPFCSCSILUN_t;
+
+#define LPFC_MIN_QFULL    1	/* lowest we can decrement throttle */
+
+struct lpfc_scsi_buf {
+	struct list_head listentry;
+	uint32_t scsitmo;	/* IN */
+	uint32_t timeout;	/* IN */
+	struct lpfcHBA *scsi_hba;	/* IN */
+	uint8_t scsi_bus;	/* IN */
+	uint16_t scsi_target;	/* IN */
+	uint64_t scsi_lun;	/* IN */
+
+	struct scsi_cmnd *pCmd;	/* IN */
+
+	uint32_t qfull_retry_count;	/* internal to scsi xport */
+	uint16_t flags;		/* flags for this cmd */
+#define DATA_MAPPED     0x0001	/* data buffer has been D_MAPed */
+#define FCBUF_ABTS      0x0002	/* ABTS has been sent for this cmd */
+#define FCBUF_ABTS2     0x0004	/* ABTS has been sent twice */
+#define FCBUF_INTERNAL  0x0008	/* Internal generated driver command */
+#define LPFC_SCSI_ERR    0x0010
+	uint16_t IOxri;		/* From IOCB Word 6- ulpContext */
+	uint16_t status;	/* From IOCB Word 7- ulpStatus */
+	uint32_t result;	/* From IOCB Word 4. */
+
+	int        datadir;	/* Data direction as requested in the scsi
+				   command. */
+	uint32_t   seg_cnt;	/* Number of scatter-gather segments returned by
+				 * pci_map_sg.  The driver needs this for calls
+				 * to pci_unmap_sg. */
+	dma_addr_t nonsg_phys;	/* Non scatter-gather physical address. */
+
+	LPFCSCSILUN_t *pLun;
+	struct timer_list delayIodoneFunc;
+
+	/* dma_ext has both virt, phys to dma-able buffer
+	 * which contains fcp_cmd, fcp_rsp and scatter gather list fro upto 
+	 * 68 (LPFC_SCSI_BPL_SIZE) BDE entries,
+	 * xfer length, cdb, data direction....
+	 */
+	DMABUF_t *dma_ext;
+	struct _FCP_CMND *fcp_cmnd;
+	struct _FCP_RSP *fcp_rsp;
+	ULP_BDE64 *fcp_bpl;
+
+	/* cur_iocbq has phys of the dma-able buffer.
+	 * Iotag is in here 
+	 */
+	LPFC_IOCBQ_t cur_iocbq;
+
+	void (*cmd_cmpl) (struct lpfcHBA *, struct lpfc_scsi_buf *);	/* IN */
+};
+
+typedef struct lpfc_scsi_buf LPFC_SCSI_BUF_t;
+
+#define LPFC_SCSI_INITIAL_BPL_SIZE  3	/* Number of scsi buf BDEs in fcp_bpl */
+
+#define FAILURE -1
+#define LPFC_CMD_STATUS_ABORTED -1
+
+#define LPFC_INTERNAL_RESET   0	/* internal reset */
+#define LPFC_EXTERNAL_RESET   1	/* external reset, scsi layer */
+#define LPFC_ISSUE_LUN_RESET  2	/* flag for reset routine to issue LUN_RESET */
+#define LPFC_ISSUE_ABORT_TSET 4	/* flag for reset routine to issue ABORT_TSET */
+
+#define LPFC_SCSI_DMA_EXT_SIZE 256
+#define LPFC_BPL_SIZE          1024
+
+#define MDAC_DIRECT_CMD                  0x22
+
+#endif				/* _H_LPFC_SCSI */
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_scsiport.c linux-8155/drivers/addon/lpfc/lpfc_scsiport.c
--- linux-8152/drivers/addon/lpfc/lpfc_scsiport.c
+++ linux-8155/drivers/addon/lpfc/lpfc_scsiport.c
@@ -0,0 +1,2456 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_scsiport.c 328 2005-05-03 15:20:43Z sf_support $
+ */
+#include <linux/version.h>
+#include <linux/spinlock.h>
+#include <linux/pci.h>
+#include <linux/blk.h>
+
+#include <scsi.h>
+#include <hosts.h>
+
+#include "lpfc_hw.h"
+#include "lpfc_sli.h"
+#include "lpfc_mem.h"
+#include "lpfc_sched.h"
+#include "lpfc_disc.h"
+#include "lpfc.h"
+#include "lpfc_logmsg.h"
+#include "lpfc_fcp.h"
+#include "lpfc_scsi.h"
+#include "lpfc_cfgparm.h"
+#include "lpfc_crtn.h"
+#include "lpfc_compat.h"
+
+extern int lpfc_inq_pqb_filter;
+
+typedef struct lpfc_xlat_err {
+	uint16_t iocb_status;
+	uint16_t host_status;
+	uint16_t action_flag;
+} lpfc_xlat_err_t;
+
+/* Defines for action flags */
+#define LPFC_DELAY_IODONE    0x1
+#define LPFC_FCPRSP_ERROR    0x2
+#define LPFC_IOERR_TABLE     0x4
+#define LPFC_STAT_ACTION     0x8
+
+#define LPFC_CMD_BEING_RETRIED  0xFFFF
+
+/* This table is indexed by the IOCB ulpStatus */
+
+lpfc_xlat_err_t lpfc_iostat_tbl[IOSTAT_CNT] = {
+/* f/w code            host_status   flag */
+
+	{IOSTAT_SUCCESS, DID_OK, 0},	/* 0x0 */
+	{IOSTAT_FCP_RSP_ERROR, DID_OK, LPFC_FCPRSP_ERROR},	/* 0x1 */
+	{IOSTAT_REMOTE_STOP, DID_ERROR, 0},	/* 0x2 */
+	{IOSTAT_LOCAL_REJECT, DID_ERROR, LPFC_IOERR_TABLE},	/* 0x3 */
+	{IOSTAT_NPORT_RJT, DID_ERROR, LPFC_STAT_ACTION},	/* 0x4 */
+	{IOSTAT_FABRIC_RJT, DID_ERROR, LPFC_STAT_ACTION},	/* 0x5 */
+	{IOSTAT_NPORT_BSY, DID_BUS_BUSY, LPFC_DELAY_IODONE},	/* 0x6 */
+	{IOSTAT_FABRIC_BSY, DID_BUS_BUSY, LPFC_DELAY_IODONE},	/* 0x7 */
+	{IOSTAT_INTERMED_RSP, DID_ERROR, 0},	/* 0x8 */
+	{IOSTAT_LS_RJT, DID_ERROR, 0},	/* 0x9 */
+	{IOSTAT_BA_RJT, DID_ERROR, 0},	/* 0xa */
+	{IOSTAT_RSVD1, DID_ERROR, 0},	/* 0xb */
+	{IOSTAT_RSVD2, DID_ERROR, 0},	/* 0xc */
+	{IOSTAT_RSVD3, DID_ERROR, 0},	/* 0xd */
+	{IOSTAT_RSVD4, DID_ERROR, 0},	/* 0xe */
+	{IOSTAT_DEFAULT, DID_ERROR, 0},	/* 0xf */
+	{IOSTAT_DRIVER_REJECT, DID_ERROR, LPFC_DELAY_IODONE}	/* 0x10 */
+};
+
+/* This table is indexed by the IOCB perr.statLocalError */
+
+lpfc_xlat_err_t lpfc_ioerr_tbl[IOERR_CNT] = {
+
+/* f/w code                     host_status     flag */
+	{0, DID_ERROR, LPFC_DELAY_IODONE},
+	{IOERR_MISSING_CONTINUE, DID_BUS_BUSY, LPFC_DELAY_IODONE}, /* 0x1  */
+	{IOERR_SEQUENCE_TIMEOUT, DID_ERROR, LPFC_DELAY_IODONE},	/* 0x2  */
+	{IOERR_INTERNAL_ERROR, DID_ERROR, LPFC_DELAY_IODONE},	/* 0x3  */
+	{IOERR_INVALID_RPI, DID_ERROR, LPFC_DELAY_IODONE},	/* 0x4  */
+	{IOERR_NO_XRI, DID_ERROR, LPFC_DELAY_IODONE},	/* 0x5  */
+	{IOERR_ILLEGAL_COMMAND, DID_BUS_BUSY, LPFC_DELAY_IODONE}, /* 0x6  */
+	{IOERR_XCHG_DROPPED, DID_ERROR, LPFC_DELAY_IODONE},	/* 0x7  */
+	{IOERR_ILLEGAL_FIELD, DID_BUS_BUSY, LPFC_DELAY_IODONE},	/* 0x8  */
+	{IOERR_BAD_CONTINUE, DID_BUS_BUSY, LPFC_DELAY_IODONE},	/* 0x9  */
+	{IOERR_TOO_MANY_BUFFERS, DID_BUS_BUSY, LPFC_DELAY_IODONE}, /* 0xA  */
+	{IOERR_RCV_BUFFER_WAITING, DID_ERROR, LPFC_DELAY_IODONE}, /* 0xB  */
+	{IOERR_NO_CONNECTION, DID_ERROR, LPFC_DELAY_IODONE},	/* 0xC  */
+	{IOERR_TX_DMA_FAILED, DID_ERROR, LPFC_DELAY_IODONE},	/* 0xD  */
+	{IOERR_RX_DMA_FAILED, DID_ERROR, LPFC_DELAY_IODONE},	/* 0xE  */
+	{IOERR_ILLEGAL_FRAME, DID_BUS_BUSY, LPFC_DELAY_IODONE},	/* 0xF  */
+	{IOERR_EXTRA_DATA, DID_BUS_BUSY, LPFC_DELAY_IODONE},	/* 0x10 */
+	{IOERR_NO_RESOURCES, DID_BUS_BUSY, LPFC_DELAY_IODONE},	/* 0x11 */
+	{0, DID_ERROR, LPFC_DELAY_IODONE},	/* 0x12 */
+	{IOERR_ILLEGAL_LENGTH, DID_BUS_BUSY, LPFC_DELAY_IODONE}, /* 0x13 */
+	{IOERR_UNSUPPORTED_FEATURE, DID_BUS_BUSY, LPFC_DELAY_IODONE}, /* 0x14 */
+	{IOERR_ABORT_IN_PROGRESS, DID_ERROR, LPFC_DELAY_IODONE}, /* 0x15 */
+	{IOERR_ABORT_REQUESTED, DID_ERROR, LPFC_DELAY_IODONE},	/* 0x16 */
+	{IOERR_RECEIVE_BUFFER_TIMEOUT, DID_ERROR, LPFC_DELAY_IODONE}, /* 0x17 */
+	{IOERR_LOOP_OPEN_FAILURE, DID_ERROR, LPFC_DELAY_IODONE}, /* 0x18 */
+	{IOERR_RING_RESET, DID_ERROR, LPFC_DELAY_IODONE},	/* 0x19 */
+	{IOERR_LINK_DOWN, DID_ERROR, LPFC_DELAY_IODONE},	/* 0x1A */
+	{IOERR_CORRUPTED_DATA, DID_ERROR, LPFC_DELAY_IODONE},	/* 0x1B */
+	{IOERR_CORRUPTED_RPI, DID_ERROR, LPFC_DELAY_IODONE},	/* 0x1C */
+	{IOERR_OUT_OF_ORDER_DATA, DID_ERROR, LPFC_DELAY_IODONE}, /* 0x1D */
+	{IOERR_OUT_OF_ORDER_ACK, DID_ERROR, LPFC_DELAY_IODONE},	/* 0x1E */
+	{IOERR_DUP_FRAME, DID_BUS_BUSY, LPFC_DELAY_IODONE},	/* 0x1F */
+	{IOERR_LINK_CONTROL_FRAME, DID_BUS_BUSY, LPFC_DELAY_IODONE}, /* 0x20 */
+	{IOERR_BAD_HOST_ADDRESS, DID_ERROR, LPFC_DELAY_IODONE},	/* 0x21 */
+	{IOERR_RCV_HDRBUF_WAITING, DID_ERROR, LPFC_DELAY_IODONE}, /* 0x22 */
+	{IOERR_MISSING_HDR_BUFFER, DID_ERROR, LPFC_DELAY_IODONE}, /* 0x23 */
+	{IOERR_MSEQ_CHAIN_CORRUPTED, DID_ERROR, LPFC_DELAY_IODONE}, /* 0x24 */
+	{IOERR_ABORTMULT_REQUESTED, DID_ERROR, LPFC_DELAY_IODONE}, /* 0x25 */
+	{0, DID_ERROR, LPFC_DELAY_IODONE},	/* 0x26 */
+	{0, DID_ERROR, LPFC_DELAY_IODONE},	/* 0x27 */
+	{IOERR_BUFFER_SHORTAGE, DID_BUS_BUSY, LPFC_DELAY_IODONE}, /* 0x28 */
+	{IOERR_DEFAULT, DID_ERROR, LPFC_DELAY_IODONE}	/* 0x29 */
+
+};
+
+#define ScsiResult(host_code, scsi_code) (((host_code) << 16) | scsi_code)
+
+LPFCSCSITARGET_t *lpfc_find_target(lpfcHBA_t *, uint32_t);
+int lpfc_valid_lun(LPFCSCSITARGET_t *, uint64_t);
+
+void lpfc_scsi_add_timer(struct scsi_cmnd *, int);
+int lpfc_scsi_delete_timer(struct scsi_cmnd *);
+uint32_t lpfc_os_fcp_err_handle(LPFC_SCSI_BUF_t *, lpfc_xlat_err_t *);
+
+/* Functions required by the scsiport module. */
+
+/* This routine allocates a scsi buffer, which contains all the necessary
+ * information needed to initiate a SCSI I/O. The non-DMAable region of
+ * the buffer contains the area to build the IOCB. The DMAable region contains
+ * the memory for the FCP CMND, FCP RSP, and the inital BPL. 
+ * In addition to allocating memeory, the FCP CMND and FCP RSP BDEs are setup
+ * in the BPL and the BPL BDE is setup in the IOCB.
+ */
+LPFC_SCSI_BUF_t *
+lpfc_get_scsi_buf(lpfcHBA_t * phba)
+{
+	LPFC_SCSI_BUF_t *psb;
+	DMABUF_t *pdma;
+	ULP_BDE64 *bpl;
+	IOCB_t *cmd;
+	uint8_t *ptr;
+	dma_addr_t pdma_phys;
+
+	/* Get a SCSI buffer for an I/O */
+	if ((psb =
+	     (LPFC_SCSI_BUF_t *) kmalloc(sizeof (LPFC_SCSI_BUF_t),
+					 GFP_ATOMIC)) == 0) {
+		return (0);
+	}
+	memset(psb, 0, sizeof (LPFC_SCSI_BUF_t));
+
+	/* Get a SCSI DMA extention for an I/O */
+	/*
+	 * The DMA buffer for FCP_CMND, FCP_RSP and BPL use
+	 * lpfc_scsi_dma_ext_pool with size LPFC_SCSI_DMA_EXT_SIZE
+	 *
+	 *
+	 *    The size of FCP_CMND  = 32 bytes.         
+	 *    The size of FCP_RSP   = 160 bytes.         
+	 *    The size of ULP_BDE64 = 12 bytes and driver can only support
+	 *       LPFC_SCSI_INITIAL_BPL_SIZE (3) S/G segments for scsi data.
+	 *       One ULP_BDE64 is used for each of the FCP_CMND and FCP_RSP
+	 *
+	 *    Total usage for each I/O use 32 + 160 + (2 * 12) +
+	 *    (3 * 12) = 254 bytes ~256.
+	 */
+	if ((pdma = (DMABUF_t *) kmalloc(sizeof (DMABUF_t), GFP_ATOMIC)) == 0) {
+		kfree(psb);
+		return (0);
+	}
+	memset(pdma, 0, sizeof (DMABUF_t));
+
+	INIT_LIST_HEAD(&pdma->list);
+
+	pdma->virt = pci_pool_alloc(phba->lpfc_scsi_dma_ext_pool,
+				    GFP_ATOMIC, &pdma->phys);
+	if (!pdma->virt) {
+		kfree(pdma);
+		kfree(psb);
+		return (0);
+	}
+	/* Save DMABUF ptr for put routine */
+	psb->dma_ext = pdma;
+
+	/* This is used to save extra BPLs that are chained to pdma.
+	 * Only used if I/O has more then 65 data segments.
+	 */
+
+	/* Save virtual ptrs to FCP Command, Response, and BPL */
+	ptr = (uint8_t *) pdma->virt;
+
+	memset(ptr, 0, LPFC_SCSI_DMA_EXT_SIZE);
+	psb->fcp_cmnd = (FCP_CMND *) ptr;
+	ptr += sizeof (FCP_CMND);
+	psb->fcp_rsp = (FCP_RSP *) ptr;
+	ptr += (sizeof (FCP_RSP));
+	psb->fcp_bpl = (ULP_BDE64 *) ptr;
+	psb->scsi_hba = phba;
+
+	/* Since this is for a FCP cmd, the first 2 BDEs in the BPL are always
+	 * the FCP CMND and FCP RSP, so lets just set it up right here.
+	 */
+	bpl = psb->fcp_bpl;
+	/* ptr points to physical address of FCP CMD */
+	pdma_phys = pdma->phys;
+	bpl->addrHigh = le32_to_cpu(putPaddrHigh(pdma_phys));
+	bpl->addrLow = le32_to_cpu(putPaddrLow(pdma_phys));
+	bpl->tus.f.bdeSize = sizeof (FCP_CMND);
+	bpl->tus.f.bdeFlags = BUFF_USE_CMND;
+	bpl->tus.w = le32_to_cpu(bpl->tus.w);
+	bpl++;
+
+	/* Setup FCP RSP */
+	pdma_phys += sizeof (FCP_CMND);
+	bpl->addrHigh = le32_to_cpu(putPaddrHigh(pdma_phys));
+	bpl->addrLow = le32_to_cpu(putPaddrLow(pdma_phys));
+	bpl->tus.f.bdeSize = sizeof (FCP_RSP);
+	bpl->tus.f.bdeFlags = (BUFF_USE_CMND | BUFF_USE_RCV);
+	bpl->tus.w = le32_to_cpu(bpl->tus.w);
+	bpl++;
+
+	/* Since the IOCB for the FCP I/O is built into the LPFC_SCSI_BUF_t,
+	 * lets setup what we can right here.
+	 */
+	pdma_phys += (sizeof (FCP_RSP));
+	cmd = &psb->cur_iocbq.iocb;
+	cmd->un.fcpi64.bdl.ulpIoTag32 = 0;
+	cmd->un.fcpi64.bdl.addrHigh = putPaddrHigh(pdma_phys);
+	cmd->un.fcpi64.bdl.addrLow = putPaddrLow(pdma_phys);
+	cmd->un.fcpi64.bdl.bdeSize = (2 * sizeof (ULP_BDE64));
+	cmd->un.fcpi64.bdl.bdeFlags = BUFF_TYPE_BDL;
+	cmd->ulpBdeCount = 1;
+	cmd->ulpClass = CLASS3;
+
+	return (psb);
+}
+
+/* This routine frees a scsi buffer, both DMAable and non-DMAable regions */
+void
+lpfc_free_scsi_buf(LPFC_SCSI_BUF_t * psb)
+{
+	lpfcHBA_t *phba;
+	DMABUF_t *pdma;
+	DMABUF_t *pbpl;
+	struct list_head *curr, *next;
+
+	if (psb) {
+		phba = psb->scsi_hba;
+		pdma = psb->dma_ext;
+		if (pdma) {
+			/* Check to see if there were any extra buffers used to
+			   chain BPLs */
+			list_for_each_safe(curr, next, &pdma->list) {
+
+				pbpl = list_entry(curr, DMABUF_t, list);
+				lpfc_mbuf_free(phba, pbpl->virt, pbpl->phys);
+				list_del(&pbpl->list);
+				kfree(pbpl);
+			}
+			pci_pool_free(phba->lpfc_scsi_dma_ext_pool, pdma->virt,
+				      pdma->phys);
+			kfree(pdma);
+		}
+		kfree(psb);
+	}
+	return;
+}
+
+LPFCSCSILUN_t *
+lpfc_find_lun_device(LPFC_SCSI_BUF_t * lpfc_cmd)
+{
+	/*
+	 * Search through the LUN list to find the LUN that has properties
+	 * matching those outlined in this function's parameters. 
+	 */
+	return lpfc_cmd->scsi_hba->lpfc_tran_find_lun(lpfc_cmd);
+}
+
+/*
+ * Generic routine used the setup and initiate a SCSI I/O.
+ */
+int
+lpfc_scsi_cmd_start(LPFC_SCSI_BUF_t * lpfc_cmd)
+{
+
+	lpfcHBA_t *phba;
+	LPFC_SLI_t *psli;
+	lpfcCfgParam_t *clp;
+	LPFC_IOCBQ_t *piocbq;
+	LPFCSCSITARGET_t *targetp;
+	IOCB_t *piocb;
+	FCP_CMND *fcp_cmnd;
+	LPFCSCSILUN_t *lun_device;
+	LPFC_NODELIST_t *ndlp;
+	int rc = 0;
+
+	lun_device = lpfc_find_lun_device(lpfc_cmd);
+
+	/* 
+	 * Make sure the HBA is online (cable plugged) and that this target
+	 *is not in an error recovery mode.
+	 */
+	if (lun_device == 0)
+		return -1;
+
+	ndlp = (LPFC_NODELIST_t *) lun_device->pTarget->pcontext;
+	phba = lun_device->pHBA;
+	clp = &phba->config[0];
+
+	targetp =  lun_device->pTarget;
+	if ((targetp->targetFlags & FC_NPR_ACTIVE) ||
+	    (targetp->rptLunState == REPORT_LUN_ONGOING)) {
+		/* Make sure the target is paused. */
+		lpfc_sched_pause_target(lun_device->pTarget);
+	} else {
+		if ((lun_device->failMask & LPFC_DEV_FATAL_ERROR) &&
+		    (clp[LPFC_CFG_HOLDIO].a_current == 0)){
+			/* The device is lost.  Just abort the IO and let
+			 * queuecommand figure out how to fail this IO.  The
+			 * io resources are not mapped yet so don't call
+			 * lpfc_os_return_scsi_cmd.
+			 */
+			return 1;
+		}
+	}
+
+	/* allocate an iocb command */
+	piocbq = &(lpfc_cmd->cur_iocbq);
+	piocb = &piocbq->iocb;
+
+	
+	psli = &phba->sli;
+
+	lpfc_cmd->pLun = lun_device;
+
+	/* Note: ndlp may be 0 in recovery mode */
+	lpfc_cmd->pLun->pnode = ndlp;
+	lpfc_cmd->cmd_cmpl = lpfc_os_return_scsi_cmd;
+
+	if (lpfc_os_prep_io(phba, lpfc_cmd)) {
+		return 1;
+	}
+
+	/* ulpTimeout is only one byte */
+	if (lpfc_cmd->timeout > 0xff) {
+		/*
+		 * The driver provides the timeout mechanism for this command.
+		 */
+		piocb->ulpTimeout = 0;
+	} else {
+		piocb->ulpTimeout = lpfc_cmd->timeout;
+	}
+
+	/*
+	 * Setup driver timeout, in case the command does not complete
+	 * Driver timeout should be greater than ulpTimeout
+	 */
+
+	piocbq->drvrTimeout = lpfc_cmd->timeout + LPFC_DRVR_TIMEOUT;
+
+	fcp_cmnd = lpfc_cmd->fcp_cmnd;
+	putLunHigh(fcp_cmnd->fcpLunMsl, lun_device->lun_id);
+	putLunLow(fcp_cmnd->fcpLunLsl, lun_device->lun_id);
+
+	/*
+	 * Setup addressing method
+	 * The Logical Unit Addressing method is not supported at
+	 * this current release.
+	 */
+	if (lun_device->pTarget->addrMode == VOLUME_SET_ADDRESSING) {
+		fcp_cmnd->fcpLunMsl |= be32_to_cpu(0x40000000);
+	}
+
+	if (!(piocbq->iocb_flag & LPFC_IO_POLL)) {
+		/* Pass the command on down to the SLI layer. */
+		rc = lpfc_sched_submit_command(phba, lpfc_cmd);
+		if(rc == 0)
+			lun_device->qcmdcnt++;
+	} else {
+
+		/*
+		 * Following statements has been done by the
+		 * lpfc_sched_submit_command if LPFC_IO_NOINTR is not set.
+		 */
+		piocbq->context1 = lpfc_cmd;
+		piocbq->iocb_cmpl = lpfc_sched_sli_done;
+
+		/* put the RPI number and NODELIST info in the IOCB command */
+		piocbq->iocb.ulpContext = targetp->rpi;
+		if (ndlp->nlp_fcp_info & NLP_FCP_2_DEVICE) {
+			piocbq->iocb.ulpFCP2Rcvy = 1;
+		}
+		piocbq->iocb.ulpClass = (ndlp->nlp_fcp_info & 0x0f);
+		/* Get an iotag and finish setup of IOCB  */
+		piocbq->iocb.ulpIoTag = lpfc_sli_next_iotag(phba,
+						   &psli->ring[psli->fcp_ring]);
+
+		/* Poll for command completion */
+		rc = lpfc_sli_issue_iocb(phba, &phba->sli.ring[psli->fcp_ring],
+					 piocbq,
+					 (SLI_IOCB_RET_IOCB | SLI_IOCB_POLL));
+	}
+	return (rc);
+}
+
+int
+lpfc_scsi_prep_task_mgmt_cmd(lpfcHBA_t * phba,
+			     LPFC_SCSI_BUF_t * lpfc_cmd, uint8_t task_mgmt_cmd)
+{
+
+	LPFC_SLI_t *psli;
+	lpfcCfgParam_t *clp;
+	LPFC_IOCBQ_t *piocbq;
+	IOCB_t *piocb;
+	FCP_CMND *fcp_cmnd;
+	LPFCSCSILUN_t *lun_device;
+	LPFC_NODELIST_t *ndlp;
+
+	lun_device = lpfc_find_lun_device(lpfc_cmd);
+	if (lun_device == 0) {
+		return 0;
+	}
+
+	ndlp = (LPFC_NODELIST_t *) lun_device->pTarget->pcontext;
+
+	if ((lun_device->failMask & LPFC_DEV_FATAL_ERROR) || (ndlp == 0)) {
+		return 0;
+	}
+
+	/* allocate an iocb command */
+	psli = &phba->sli;
+	piocbq = &(lpfc_cmd->cur_iocbq);
+	piocb = &piocbq->iocb;
+
+	clp = &phba->config[0];
+
+	fcp_cmnd = lpfc_cmd->fcp_cmnd;
+	putLunHigh(fcp_cmnd->fcpLunMsl, lun_device->lun_id);
+	putLunLow(fcp_cmnd->fcpLunLsl, lun_device->lun_id);
+	if (lun_device->pTarget->addrMode == VOLUME_SET_ADDRESSING) {
+		fcp_cmnd->fcpLunMsl |= be32_to_cpu(0x40000000);
+	}
+	fcp_cmnd->fcpCntl2 = task_mgmt_cmd;
+
+	piocb->ulpIoTag =
+	    lpfc_sli_next_iotag(phba, &phba->sli.ring[psli->fcp_ring]);
+	piocb->ulpCommand = CMD_FCP_ICMND64_CR;
+
+	piocb->ulpContext = ndlp->nlp_rpi;
+	if (ndlp->nlp_fcp_info & NLP_FCP_2_DEVICE) {
+		piocb->ulpFCP2Rcvy = 1;
+	}
+	piocb->ulpClass = (ndlp->nlp_fcp_info & 0x0f);
+
+	/* ulpTimeout is only one byte */
+	if (lpfc_cmd->timeout > 0xff) {
+		/*
+		 * Do not timeout the command at the firmware level.
+		 * The driver will provide the timeout mechanism.
+		 */
+		piocb->ulpTimeout = 0;
+	} else {
+		piocb->ulpTimeout = lpfc_cmd->timeout;
+	}
+
+	lun_device->pnode = ndlp;
+	lpfc_cmd->pLun = lun_device;
+
+	switch (task_mgmt_cmd) {
+	case LUN_RESET:
+		/* Issue LUN Reset to TGT <num> LUN <num> */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0703,
+				lpfc_mes0703, lpfc_msgBlk0703.msgPreambleStr,
+				lpfc_cmd->scsi_target, lpfc_cmd->scsi_lun,
+				ndlp->nlp_rpi, ndlp->nlp_rflag);
+
+		break;
+	case ABORT_TASK_SET:
+		/* Issue Abort Task Set to TGT <num> LUN <num> */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0701,
+				lpfc_mes0701, lpfc_msgBlk0701.msgPreambleStr,
+				lpfc_cmd->scsi_target, lpfc_cmd->scsi_lun,
+				ndlp->nlp_rpi, ndlp->nlp_rflag);
+
+		break;
+	case TARGET_RESET:
+		/* Issue Target Reset to TGT <num> */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0702,
+				lpfc_mes0702, lpfc_msgBlk0702.msgPreambleStr,
+				lpfc_cmd->scsi_target, ndlp->nlp_rpi,
+				ndlp->nlp_rflag);
+		break;
+	}
+
+	return (1);
+}
+
+/* returns:  0 if we successfully find and abort the command,
+	     1 if we couldn't find the command
+*/
+int
+lpfc_scsi_cmd_abort(lpfcHBA_t * phba, LPFC_SCSI_BUF_t * lpfc_cmd)
+{
+
+	/* when this function returns, the command has been aborted and
+	   returned to the OS, or it was returned before we could abort
+	   it */
+
+	/* tell the scheduler to find this command on LUN queue and remove
+	   it.  It's up to the scheduler to remove the command from the SLI
+	   layer. */
+	if (lpfc_sched_flush_command(phba, lpfc_cmd, LPFC_CMD_STATUS_ABORTED,
+				     0)) {
+		return 1;
+	} else {
+		/* couldn't find command - fail */
+		return 0;
+	}
+
+}
+
+/*
+ * Returns: 1 for IOCB_SUCCESS
+ */
+int
+lpfc_scsi_lun_reset(LPFC_SCSI_BUF_t * external_cmd,
+		    lpfcHBA_t * phba,
+		    uint32_t bus, uint32_t target, uint64_t lun, uint32_t flag)
+{
+	LPFC_SCSI_BUF_t *lpfc_cmd;
+	LPFC_IOCBQ_t *piocbq;
+	LPFC_SLI_t *psli;
+	LPFCSCSILUN_t *plun;
+	LPFC_IOCBQ_t *piocbqrsp = 0;
+	LPFC_SCSI_BUF_t *internal_cmd = 0;
+	int ret = 0;
+
+	/* Allocate command buf if internal command */
+	if (!(flag & LPFC_EXTERNAL_RESET)) {
+		if ((internal_cmd = lpfc_get_scsi_buf(phba)) == 0) {
+			return (FAILURE);
+		}
+
+		lpfc_cmd = internal_cmd;
+		lpfc_cmd->scsi_hba = phba;
+		lpfc_cmd->scsi_bus = bus;
+		lpfc_cmd->scsi_target = target;
+		lpfc_cmd->scsi_lun = lun;
+	} else {
+		lpfc_cmd = external_cmd;
+	}
+
+
+	/*
+	 * Reset a device with either a LUN reset or an ABORT TASK
+	 * reset depending on the caller's flag value.
+	 */
+	if (flag & LPFC_ISSUE_LUN_RESET) {
+		ret = lpfc_scsi_prep_task_mgmt_cmd(phba, lpfc_cmd, LUN_RESET);
+	} else {
+		if (flag & LPFC_ISSUE_ABORT_TSET) {
+			ret =
+			    lpfc_scsi_prep_task_mgmt_cmd(phba, lpfc_cmd,
+							 ABORT_TASK_SET);
+		} else {
+			ret = 0;
+		}
+	}
+
+	if (ret) {
+		psli = &phba->sli;
+		piocbq = &(lpfc_cmd->cur_iocbq);
+		if (flag & LPFC_EXTERNAL_RESET) {
+
+			/* get a buffer for this response IOCB command */
+			if ((piocbqrsp = lpfc_iocb_alloc(phba, 0)) == 0) {
+				if (internal_cmd) {
+					lpfc_free_scsi_buf(internal_cmd);
+					internal_cmd = 0;
+					lpfc_cmd = 0;
+				}
+				return (ENOMEM);
+			}
+			memset(piocbqrsp, 0, sizeof (LPFC_IOCBQ_t));
+
+			piocbq->iocb_flag |= LPFC_IO_POLL;
+			piocbq->iocb_cmpl = lpfc_sli_wake_iocb_high_priority;
+			ret = lpfc_sli_issue_iocb_wait_high_priority(phba,
+					     &phba->sli.ring[psli->fcp_ring],
+					     piocbq, SLI_IOCB_USE_TXQ,
+					     piocbqrsp, 60);	/* 60 secs */
+			ret = (ret == IOCB_SUCCESS) ? 1 : 0;
+
+			lpfc_cmd->result = piocbqrsp->iocb.un.ulpWord[4];
+			if ((lpfc_cmd->status = piocbqrsp->iocb.ulpStatus) ==
+			    IOSTAT_LOCAL_REJECT) {
+				if (lpfc_cmd->result & IOERR_DRVR_MASK) {
+					lpfc_cmd->status = IOSTAT_DRIVER_REJECT;
+				}
+			}
+
+			plun = lpfc_find_lun_device(lpfc_cmd);
+			if (plun) {
+				/* tell the scheduler to find all commands on
+				 * this LUN queue and remove them.  It's up to
+				 * the scheduler to remove the command from the
+				 * SLI layer.
+				 */
+				if (!lpfc_sched_flush_lun(phba, plun,
+						 LPFC_CMD_STATUS_ABORTED,0)) {
+
+				}
+
+			}
+			/* Done with piocbqrsp, return to free list */
+			if (piocbqrsp) {
+				lpfc_iocb_free(phba, piocbqrsp);
+			}
+
+			/* If this was an external lun reset, issue a message
+			 * indicating its completion.
+			 */
+			if (flag & LPFC_ISSUE_LUN_RESET) {
+				lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0748,
+						lpfc_mes0748,
+						lpfc_msgBlk0748.msgPreambleStr,
+						lpfc_cmd->scsi_target,
+						lpfc_cmd->scsi_lun, ret,
+						lpfc_cmd->status,
+						lpfc_cmd->result);
+			}
+		} else {
+
+			ret =
+			    lpfc_sli_issue_iocb(phba,
+						&phba->sli.ring[psli->fcp_ring],
+						piocbq,
+						SLI_IOCB_HIGH_PRIORITY |
+						SLI_IOCB_RET_IOCB);
+			ret = (ret == IOCB_SUCCESS) ? 1 : 0;
+		}
+	}
+
+	if (internal_cmd) {
+		lpfc_free_scsi_buf(internal_cmd);
+		internal_cmd = 0;
+		lpfc_cmd = 0;
+	}
+
+	return (ret);
+
+}
+
+
+/*
+ * Returns: 1 for IOCB_SUCCESS
+ */
+int
+lpfc_scsi_tgt_reset(LPFC_SCSI_BUF_t * external_cmd,
+		    lpfcHBA_t * phba,
+		    uint32_t bus, uint32_t target, uint32_t flag)
+{
+	LPFC_SCSI_BUF_t *lpfc_cmd;
+	LPFC_IOCBQ_t *piocbq;
+	LPFC_SLI_t *psli;
+	LPFC_SCHED_HBA_t *phbaSched;
+	LPFCSCSITARGET_t *ptarget = 0;
+	LPFCSCSILUN_t *plun;
+	LPFC_IOCBQ_t *piocbqrsp = 0;
+	LPFC_SCSI_BUF_t *internal_cmd = 0;
+	int ret = 0;
+
+	/* Allocate command buf if internal command */
+	if (!(flag & LPFC_EXTERNAL_RESET)) {
+		if ((internal_cmd = lpfc_get_scsi_buf(phba)) == 0) {
+			return (FAILURE);
+		}
+		lpfc_cmd = internal_cmd;
+		lpfc_cmd->scsi_hba = phba;
+		lpfc_cmd->scsi_bus = bus;
+		lpfc_cmd->scsi_target = target;
+	} else {
+		lpfc_cmd = external_cmd;
+	}
+
+	/*
+	 * target reset a device
+	 */
+	ret = lpfc_scsi_prep_task_mgmt_cmd(phba, lpfc_cmd, TARGET_RESET);
+	if (ret) {
+		psli = &phba->sli;
+		piocbq = &(lpfc_cmd->cur_iocbq);
+		if (flag & LPFC_EXTERNAL_RESET) {
+
+			/* get a buffer for this IOCB command response */
+			if ((piocbqrsp = lpfc_iocb_alloc(phba, 0)) == 0) {
+				if (internal_cmd) {
+					lpfc_free_scsi_buf(internal_cmd);
+					internal_cmd = 0;
+					lpfc_cmd = 0;
+				}
+				return (ENOMEM);
+			}
+			memset(piocbqrsp, 0, sizeof (LPFC_IOCBQ_t));
+
+			piocbq->iocb_flag |= LPFC_IO_POLL;
+			piocbq->iocb_cmpl = lpfc_sli_wake_iocb_high_priority;
+
+			if (lpfc_cmd->timeout == 0) {
+				/*
+				* Allot enough time to abort all outstanding IO
+				* in the HBA.  The FW must finish its IO before
+				* the scheduler is allowed to abort its IO.
+				*/
+				lpfc_cmd->timeout = 60;
+			}
+
+			ret = lpfc_sli_issue_iocb_wait_high_priority(phba,
+				     &phba->sli.ring[psli->fcp_ring],
+				     piocbq, SLI_IOCB_HIGH_PRIORITY,
+				     piocbqrsp,
+				     lpfc_cmd->timeout);
+			ret = (ret == IOCB_SUCCESS) ? 1 : 0;
+
+			lpfc_cmd->result = piocbqrsp->iocb.un.ulpWord[4];
+			if ((lpfc_cmd->status = piocbqrsp->iocb.ulpStatus) ==
+			    IOSTAT_LOCAL_REJECT) {
+				if (lpfc_cmd->result & IOERR_DRVR_MASK) {
+					lpfc_cmd->status = IOSTAT_DRIVER_REJECT;
+				}
+			}
+
+			plun = lpfc_find_lun_device(lpfc_cmd);
+
+			/* tell the scheduler to find all commands on this Tgt
+			 * queue and remove them.  It's up to the scheduler to
+			 * remove the command from the SLI layer.
+			 */
+			if ((plun == 0) || (plun->pTarget == 0)) {
+				struct list_head *pos;
+
+				phbaSched = &phba->hbaSched;
+
+				list_for_each(pos, &phbaSched->targetRing) {
+					ptarget = list_entry(pos,
+							     LPFCSCSITARGET_t,
+							     listentry);
+					if ((ptarget == 0)
+					    || (ptarget->scsi_id == target)) {
+						break;
+					}
+				}
+			} else {
+				ptarget = plun->pTarget;
+			}
+
+			if (ptarget) {
+				(void) lpfc_sched_flush_target(phba, ptarget,
+						LPFC_CMD_STATUS_ABORTED,0);
+			}
+
+			/* Done with piocbqrsp, return to free list */
+			if (piocbqrsp) {
+				lpfc_iocb_free(phba, piocbqrsp);
+			}
+		} else {
+
+			ret =
+			    lpfc_sli_issue_iocb(phba,
+						&phba->sli.ring[psli->fcp_ring],
+						piocbq,
+						SLI_IOCB_HIGH_PRIORITY |
+						SLI_IOCB_RET_IOCB);
+			ret = (ret == IOCB_SUCCESS) ? 1 : 0;
+		}
+	}
+
+	if (internal_cmd) {
+		lpfc_free_scsi_buf(internal_cmd);
+		internal_cmd = 0;
+		lpfc_cmd = 0;
+	}
+
+	return (ret);
+}
+
+void
+lpfc_scsi_lower_lun_qthrottle(lpfcHBA_t * phba, LPFC_SCSI_BUF_t * lpfc_cmd)
+{
+	LPFCSCSILUN_t *plun;
+	lpfcCfgParam_t *clp;
+
+	clp = &phba->config[0];
+	plun = lpfc_cmd->pLun;
+
+	if (plun->lunSched.maxOutstanding > LPFC_MIN_QFULL) {
+		if (plun->lunSched.currentOutstanding > LPFC_MIN_QFULL) {
+			/*
+			 * knock the current queue throttle down to
+			 * (active_io_count - 1)
+			 */
+			plun->lunSched.maxOutstanding =
+			    plun->lunSched.currentOutstanding - 1;
+
+			/*
+			 * Delay LPFC_NO_DEVICE_DELAY seconds before sending I/O
+			 * this device again.  stop_send_io will be decreament
+			 * by 1 in lpfc_qthrottle_up();
+			 */
+			plun->stop_send_io =
+			    clp[LPFC_CFG_NO_DEVICE_DELAY].a_current;
+
+			/*
+			 * Kick off the lpfc_qthrottle_up()
+			 */
+			if (phba->dqfull_clk.function == 0) {
+				lpfc_start_timer(phba, 
+					clp[LPFC_CFG_DQFULL_THROTTLE_UP_TIME]
+						 .a_current,
+					&phba->dqfull_clk, lpfc_qthrottle_up, 
+					0, 0);
+			}
+		} else {
+			plun->lunSched.maxOutstanding = LPFC_MIN_QFULL;
+		}
+	}
+}
+
+void
+lpfc_qthrottle_up(unsigned long ptr)
+{
+	lpfcHBA_t *phba;
+	LPFC_NODELIST_t *ndlp;
+	struct list_head *pos;
+	LPFCSCSITARGET_t *ptarget;
+	LPFCSCSILUN_t *plun = 0;
+	lpfcCfgParam_t *clp;
+	int reset_clock = 0;
+	struct clk_data *clkData;
+	unsigned long iflag;
+	struct list_head *curr, *next;
+
+	clkData = (struct clk_data *)ptr;
+	phba = clkData->phba;
+	LPFC_DRVR_LOCK(phba, iflag);
+       	if (clkData->flags & TM_CANCELED) {
+		list_del((struct list_head *)clkData);
+		kfree(clkData);	
+		goto out;
+	}
+	clkData->timeObj->function = 0;
+	list_del((struct list_head *)clkData);
+	kfree(clkData);
+
+	clp = &phba->config[0];
+	if (clp[LPFC_CFG_DFT_LUN_Q_DEPTH].a_current <= LPFC_MIN_QFULL) {
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		return;
+	}
+
+	if (phba->hba_state != LPFC_HBA_READY) {
+		list_for_each(pos, &phba->fc_nlpmap_list) {
+			ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			ptarget = ndlp->nlp_Target;
+			if (ptarget) {
+				list_for_each_safe(curr, next,
+						   &ptarget->lunlist) {
+					plun = list_entry(curr, LPFCSCSILUN_t,
+							  list);
+					plun->lunSched.maxOutstanding =
+					    plun->fcp_lun_queue_depth;
+					plun->stop_send_io = 0;
+				}
+			}
+		}
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		return;
+	}
+
+	list_for_each(pos, &phba->fc_nlpmap_list) {
+		ndlp = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+		ptarget = ndlp->nlp_Target;
+		if (ptarget) {
+			list_for_each_safe(curr, next, &ptarget->lunlist) {
+				plun = list_entry(curr, LPFCSCSILUN_t, list);
+
+				if ((plun->stop_send_io == 0)
+				    &&
+				    (plun->lunSched.maxOutstanding <
+				     plun->fcp_lun_queue_depth)
+				    ) {
+					/* 
+					 * update lun q throttle 
+					 */
+					plun->lunSched.maxOutstanding +=
+					    clp[LPFC_CFG_DQFULL_THROTTLE_UP_INC]
+					    .a_current;
+
+					if (plun->lunSched.maxOutstanding >
+					    plun->fcp_lun_queue_depth) {
+						plun->lunSched.maxOutstanding =
+						    plun->fcp_lun_queue_depth;
+					}
+
+					reset_clock = 1;
+				} else {
+					/* 
+					 * Try to reset stop_send_io 
+					 */
+					if (plun->stop_send_io) {
+						plun->stop_send_io--;
+						reset_clock = 1;
+					}
+				}
+			}
+		}
+	}
+
+	if (reset_clock) {
+		lpfc_start_timer(phba,
+				 clp[LPFC_CFG_DQFULL_THROTTLE_UP_TIME].
+				 a_current, &phba->dqfull_clk,
+				 lpfc_qthrottle_up, (unsigned long)0,
+				 (unsigned long)0);
+	}
+
+out:
+	LPFC_DRVR_UNLOCK(phba, iflag);
+
+	return;
+}
+
+void
+lpfc_scsi_assign_rpi(lpfcHBA_t * phba, LPFCSCSITARGET_t *targetp, uint16_t rpi)
+{
+	LPFC_SLI_t *psli;
+	LPFC_SLI_RING_t * pring;
+	LPFC_SCSI_BUF_t *lpfc_cmd;
+	LPFCSCSILUN_t *lun;
+	struct list_head *cur_h, *next_h;
+	struct list_head *cur_l, *next_l;
+	struct list_head *curr, *next;
+	IOCB_t *cmd = 0;
+	LPFC_IOCBQ_t *iocb;
+
+	/* If the rpi has changed for this target, there may be some I/Os
+	 * already queued with the WRONG rpi. Bad things will happen if we
+	 * don't clean it up here.
+	 */
+	if(targetp->rpi != rpi) {
+		/* Check for initial assignment */
+		if(targetp->rpi == 0) {
+			targetp->rpi = rpi;
+			return;
+		}
+
+		/* We can either error the I/O back to the upper layer, and
+		 * let it retry, or we can be more sophisticated about it and
+		 * change the rpi in the I/Os "on deck".
+		 */
+		/* First the scheduler queue */
+
+		/* walk the list of LUNs on this target and flush each LUN.  We
+		   accomplish this by pulling the first LUN off the head of the
+		   queue until there aren't any LUNs left */
+		list_for_each_safe(cur_h, next_h, &targetp->targetSched.lunRing) {
+			lun = list_entry(cur_h, LPFCSCSILUN_t, listentry);
+		
+			list_for_each_safe(cur_l, next_l, &lun->lunSched.commandList) {
+				LPFC_SCSI_BUF_t *command =
+					list_entry(cur_l,
+					   LPFC_SCSI_BUF_t,
+					   listentry);
+				cmd = (IOCB_t *) & (command->cur_iocbq.iocb);
+				cmd->ulpContext = rpi;
+			}
+		}
+
+
+		/* Next the txq */
+		psli = &phba->sli;
+		pring = &psli->ring[psli->fcp_ring];
+
+		list_for_each_safe(curr, next, &pring->txq) {
+			iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+			cmd = &iocb->iocb;
+
+			/* Must be a FCP command */
+			if ((cmd->ulpCommand != CMD_FCP_ICMND64_CR) &&
+		    	(cmd->ulpCommand != CMD_FCP_IWRITE64_CR) &&
+		    	(cmd->ulpCommand != CMD_FCP_IREAD64_CR)) {
+				continue;
+			}
+
+			/* context1 MUST be a LPFC_SCSI_BUF_t */
+			lpfc_cmd = (LPFC_SCSI_BUF_t *) (iocb->context1);
+			if ((lpfc_cmd == 0) ||
+				(lpfc_cmd->scsi_target != targetp->scsi_id)) {
+				continue;
+			}
+			cmd->ulpContext = rpi;
+		}
+		targetp->rpi = rpi;
+	}
+	return;
+}
+
+void
+lpfc_npr_timeout(unsigned long ptr)
+{
+	lpfcHBA_t *phba;
+	LPFCSCSITARGET_t *targetp;
+	struct clk_data *nprClkData;
+	unsigned long iflag;
+
+	nprClkData = (struct clk_data *)ptr;
+	phba = nprClkData->phba;
+	LPFC_DRVR_LOCK(phba, iflag);
+	if (nprClkData->flags & TM_CANCELED) {
+		list_del((struct list_head *)nprClkData);
+		kfree(nprClkData);  
+		goto out;    
+	}
+
+
+	targetp = (LPFCSCSITARGET_t *) nprClkData->clData1;
+	targetp->tmofunc.function = 0;
+
+	/* Expired nodev timer */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0250,
+		lpfc_mes0250,
+		lpfc_msgBlk0250.msgPreambleStr,
+		targetp->un.dev_did, targetp->scsi_id, targetp->rpi);
+
+	list_del((struct list_head *)nprClkData);
+	kfree(nprClkData);	
+        
+	targetp->targetFlags &= ~FC_NPR_ACTIVE;
+
+	if(targetp->pcontext)
+		lpfc_disc_state_machine(phba, targetp->pcontext,
+			0, NLP_EVT_DEVICE_RM);
+
+	lpfc_sched_flush_target(phba, targetp, IOSTAT_LOCAL_REJECT,
+				IOERR_SLI_ABORTED);
+out:
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	return;
+}
+
+/*
+ * Returns: 1 for SUCCESS
+ */
+int
+lpfc_scsi_hba_reset(lpfcHBA_t * phba, LPFC_SCSI_BUF_t * lpfc_cmd)
+{
+	LPFCSCSITARGET_t *ptarget;
+	int ret;
+	int i, errcnt = 0;
+
+	lpfc_cmd->scsi_hba = phba;
+	lpfc_cmd->scsi_bus = 0;
+	lpfc_cmd->scsi_lun = 0;
+	for (i = 0; i < MAX_FCP_TARGET; i++) {
+		ptarget = phba->device_queue_hash[i];
+		if (ptarget) {
+			lpfc_cmd->scsi_target = i;
+			ret = lpfc_scsi_tgt_reset(lpfc_cmd, phba, 0, i, 
+						LPFC_EXTERNAL_RESET);
+			if (!ret)
+				errcnt++;
+		}
+	}
+
+	ret = 1;
+	if (errcnt)
+		ret = 0;
+	return ret;
+}
+
+LPFC_SCSI_BUF_t *
+lpfc_build_scsi_cmd(lpfcHBA_t * phba,
+		    LPFC_NODELIST_t * nlp, uint32_t scsi_cmd, uint64_t lun)
+{
+	LPFC_SLI_t *psli;
+	LPFCSCSITARGET_t *targetp;
+	LPFCSCSILUN_t *lunp;
+	DMABUF_t *mp;
+	LPFC_SCSI_BUF_t *lpfc_cmd;
+	LPFC_IOCBQ_t *piocbq;
+	IOCB_t *piocb;
+	FCP_CMND *fcpCmnd;
+	ULP_BDE64 *bpl;
+	uint32_t tgt, size;
+
+	tgt = nlp->nlp_sid;
+	lunp = lpfc_find_lun(phba, tgt, lun, 1);
+	lpfc_cmd = 0;
+	/* First see if the SCSI ID has an allocated LPFCSCSITARGET_t */
+	if (lunp && lunp->pTarget) {
+		targetp = lunp->pTarget;
+		psli = &phba->sli;
+
+		/* Get a buffer to hold SCSI data */
+		if ((mp = kmalloc(sizeof (DMABUF_t), GFP_ATOMIC)) == 0) {
+			return (0);
+		}
+
+		INIT_LIST_HEAD(&mp->list);
+		/* Get resources to send a SCSI command */
+		lpfc_cmd = lpfc_get_scsi_buf(phba);
+		if (lpfc_cmd == 0) {
+			kfree(mp);
+			return (0);
+		}
+		lpfc_cmd->pLun = lunp;
+		lpfc_cmd->scsi_target = tgt;
+		lpfc_cmd->scsi_lun = lun;
+		lpfc_cmd->timeout = 30 + phba->fcp_timeout_offset;
+
+		/* Finish building BPL with the I/O dma ptrs.
+		 * setup FCP CMND, and setup IOCB.
+		 */
+
+		fcpCmnd = lpfc_cmd->fcp_cmnd;
+
+		putLunHigh(fcpCmnd->fcpLunMsl, lun);	/* LUN */
+		putLunLow(fcpCmnd->fcpLunLsl, lun);	/* LUN */
+
+		switch (scsi_cmd) {
+		case FCP_SCSI_REPORT_LUNS:
+			size = LPFC_SCSI_PAGE_BUF_SZ;
+			fcpCmnd->fcpCdb[0] = scsi_cmd;
+			/* 0x1000 = LPFC_SCSI_PAGE_BUF_SZ */
+			fcpCmnd->fcpCdb[8] = 0x10;
+			fcpCmnd->fcpCdb[9] = 0x00;
+			fcpCmnd->fcpCntl3 = READ_DATA;
+			fcpCmnd->fcpDl = be32_to_cpu(LPFC_SCSI_PAGE_BUF_SZ);
+			/* Get a buffer to hold SCSI data */
+			if ((mp->virt = lpfc_page_alloc(phba, MEM_PRI,
+			   &(mp->phys))) == 0) {
+				if (mp)
+					kfree(mp);
+				lpfc_free_scsi_buf(lpfc_cmd);
+				return (0);
+			}
+			break;
+		case FCP_SCSI_INQUIRY:
+			fcpCmnd->fcpCdb[0] = scsi_cmd;	/* SCSI Inquiry
+							   Command */
+			fcpCmnd->fcpCdb[4] = 0xff;	/* allocation length */
+			fcpCmnd->fcpCntl3 = READ_DATA;
+			fcpCmnd->fcpDl = be32_to_cpu(LPFC_SCSI_BUF_SZ);
+			/* drop thru to get a buffer */
+		default:
+			size = LPFC_SCSI_BUF_SZ;
+			/* Get a buffer to hold SCSI data */
+			if ((mp->virt =
+			     lpfc_mbuf_alloc(phba, 0, &(mp->phys))) == 0) {
+				if (mp)
+					kfree(mp);
+				lpfc_free_scsi_buf(lpfc_cmd);
+				return (0);
+			}
+			break;
+		}
+
+		bpl = lpfc_cmd->fcp_bpl;
+		bpl += 2;	/* Bump past FCP CMND and FCP RSP */
+
+		/* no scatter-gather list case */
+		bpl->addrLow = le32_to_cpu(putPaddrLow(mp->phys));
+		bpl->addrHigh = le32_to_cpu(putPaddrHigh(mp->phys));
+		bpl->tus.f.bdeSize = size;
+		bpl->tus.f.bdeFlags = BUFF_USE_RCV;
+		bpl->tus.w = le32_to_cpu(bpl->tus.w);
+		bpl++;
+		bpl->addrHigh = 0;
+		bpl->addrLow = 0;
+		bpl->tus.w = 0;
+
+		piocbq = &lpfc_cmd->cur_iocbq;
+		piocb = &piocbq->iocb;
+		piocb->ulpCommand = CMD_FCP_IREAD64_CR;
+		piocb->ulpPU = PARM_READ_CHECK;
+		piocb->un.fcpi.fcpi_parm = size;
+		piocb->un.fcpi64.bdl.bdeSize += sizeof (ULP_BDE64);
+		piocb->ulpBdeCount = 1;
+		piocb->ulpLe = 1;	/* Set the LE bit in the iocb */
+
+		/* Get an iotag and finish setup of IOCB  */
+		piocb->ulpIoTag = lpfc_sli_next_iotag(phba,
+					      &phba->sli.ring[psli->fcp_ring]);
+		piocb->ulpContext = nlp->nlp_rpi;
+		if (nlp->nlp_fcp_info & NLP_FCP_2_DEVICE) {
+			piocb->ulpFCP2Rcvy = 1;
+		}
+		piocb->ulpClass = (nlp->nlp_fcp_info & 0x0f);
+
+		/* ulpTimeout is only one byte */
+		if (lpfc_cmd->timeout > 0xff) {
+			/*
+			 * Do not timeout the command at the firmware level.
+			 * The driver will provide the timeout mechanism.
+			 */
+			piocb->ulpTimeout = 0;
+		} else {
+			piocb->ulpTimeout = lpfc_cmd->timeout;
+		}
+
+		/*
+		 * Setup driver timeout, in case the command does not complete
+		 * Driver timeout should be greater than ulpTimeout
+		 */
+
+		piocbq->drvrTimeout = lpfc_cmd->timeout + LPFC_DRVR_TIMEOUT;
+
+		/* set up iocb return path by setting the context fields
+		 * and the completion function.
+		 */
+		piocbq->context1 = lpfc_cmd;
+		piocbq->context2 = mp;
+
+	}
+	return (lpfc_cmd);
+}
+
+void
+lpfc_scsi_timeout_handler(unsigned long ptr)
+{
+	lpfcHBA_t *phba;
+	LPFC_SLI_t *psli;
+	LPFC_SLI_RING_t *pring;
+	LPFC_IOCBQ_t *next_iocb;
+	LPFC_IOCBQ_t *piocb;
+	IOCB_t *cmd = 0;
+	LPFC_SCSI_BUF_t *lpfc_cmd;
+	uint32_t timeout;
+	uint32_t next_timeout;
+	unsigned long iflag;
+	struct clk_data *scsiClkData;
+	struct list_head *curr, *next;
+
+	scsiClkData = (struct clk_data *)ptr;
+	phba = scsiClkData->phba;
+	LPFC_DRVR_LOCK(phba, iflag);
+       	if (scsiClkData->flags & TM_CANCELED) {
+		list_del((struct list_head *)scsiClkData);
+		kfree(scsiClkData);   
+		goto out;  
+	}
+
+	timeout = (uint32_t) (unsigned long)(scsiClkData->clData1);
+	phba->scsi_tmofunc.function = 0;
+	list_del((struct list_head *)scsiClkData);
+	kfree(scsiClkData);
+
+	psli = &phba->sli;
+	pring = &psli->ring[psli->fcp_ring];
+	next_timeout = (phba->fc_ratov << 1) > 5 ? (phba->fc_ratov << 1) : 5;
+
+	list_for_each_safe(curr, next, &pring->txcmplq) {
+		next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+		piocb = next_iocb;
+		cmd = &piocb->iocb;
+		lpfc_cmd = (LPFC_SCSI_BUF_t *) piocb->context1;
+
+		if (piocb->iocb_flag & (LPFC_IO_LIBDFC | LPFC_IO_POLL)) {
+			continue;
+		}
+
+		if (piocb->drvrTimeout) {
+			if (piocb->drvrTimeout > timeout)
+				piocb->drvrTimeout -= timeout;
+			else
+				piocb->drvrTimeout = 0;
+
+			continue;
+		}
+
+		/*
+		 * The iocb has timed out; abort it.
+		 */
+
+		if (cmd->un.acxri.abortType == ABORT_TYPE_ABTS) {
+			/*
+			 * If abort times out, simply throw away the iocb
+			 */
+
+			list_del(&piocb->list);
+			pring->txcmplq_cnt--;
+			(piocb->iocb_cmpl) (phba, piocb, piocb);
+		} else {
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0754,
+					lpfc_mes0754,
+					lpfc_msgBlk0754.msgPreambleStr,
+					lpfc_cmd->pLun->pTarget->un.dev_did,
+					lpfc_cmd->pLun->pTarget->scsi_id,
+					lpfc_cmd->fcp_cmnd->fcpCdb[0],
+					cmd->ulpIoTag);
+
+			lpfc_sli_abort_iocb(phba, pring, piocb);
+		}
+	}
+
+	if (!(phba->fc_flag & FC_OFFLINE_MODE))
+	{
+ 
+		lpfc_start_timer(phba, next_timeout, &phba->scsi_tmofunc,
+			 lpfc_scsi_timeout_handler,
+			 (unsigned long)next_timeout, (unsigned long)0);
+	}
+
+out:
+	LPFC_DRVR_UNLOCK(phba, iflag);
+}
+
+int
+lpfc_os_prep_io(lpfcHBA_t * phba, LPFC_SCSI_BUF_t * lpfc_cmd)
+{
+	FCP_CMND *fcp_cmnd;
+	ULP_BDE64 *topbpl;
+	ULP_BDE64 *bpl;
+	DMABUF_t *bmp;
+	DMABUF_t *head_bmp;
+	IOCB_t *cmd;
+	struct scsi_cmnd *cmnd;
+	struct scatterlist *sgel_p, *sgel_beginp;
+	dma_addr_t physaddr;
+	uint32_t i;
+	uint32_t num_bmps, num_bde, max_bde;
+	uint16_t use_sg;
+	int datadir;
+
+	bpl = lpfc_cmd->fcp_bpl;
+	fcp_cmnd = lpfc_cmd->fcp_cmnd;
+
+	bpl += 2;		/* Bump past FCP CMND and FCP RSP */
+	max_bde = LPFC_SCSI_INITIAL_BPL_SIZE - 1;
+
+	cmnd = lpfc_cmd->pCmd;
+	cmd = &lpfc_cmd->cur_iocbq.iocb;
+
+	/* These are needed if we chain BPLs */
+	head_bmp = lpfc_cmd->dma_ext;
+	num_bmps = 1;
+	topbpl = 0;
+
+	use_sg = cmnd->use_sg;
+	num_bde = 0;
+	sgel_p = 0;
+
+	/*
+	 * Fill in the FCP CMND
+	 */
+	memcpy(&fcp_cmnd->fcpCdb[0], cmnd->cmnd, 16);
+
+	if (cmnd->device->tagged_supported) {
+		switch (cmnd->tag) {
+		case HEAD_OF_QUEUE_TAG:
+			fcp_cmnd->fcpCntl1 = HEAD_OF_Q;
+			break;
+		case ORDERED_QUEUE_TAG:
+			fcp_cmnd->fcpCntl1 = ORDERED_Q;
+			break;
+		default:
+			fcp_cmnd->fcpCntl1 = SIMPLE_Q;
+			break;
+		}
+	} else {
+		fcp_cmnd->fcpCntl1 = 0;
+	}
+
+	datadir = cmnd->sc_data_direction;
+	lpfc_cmd->datadir = cmnd->sc_data_direction;
+
+	if (use_sg) {
+		/*
+		 * Get a local pointer to the scatter-gather list.  The 
+		 * scatter-gather list head must be preserved since
+		 * sgel_p is incremented in the loop.  The driver must store
+		 * the segment count returned from pci_map_sg for calls to 
+		 * pci_unmap_sg later on because the use_sg field in the 
+		 * scsi_cmd is a count of physical memory pages, whereas the
+		 * seg_cnt is a count of dma-mappings used by the MMIO to
+		 * map the use_sg pages.  They are not the same in most
+		 * cases for those architectures that implement an MMIO.
+		 */
+		sgel_p = (struct scatterlist *)cmnd->request_buffer;
+		sgel_beginp = sgel_p;
+		lpfc_cmd->seg_cnt = pci_map_sg(phba->pcidev, sgel_p, use_sg,
+					     scsi_to_pci_dma_dir(datadir));
+
+		/* return error if we cannot map sg list */
+		if (lpfc_cmd->seg_cnt == 0)
+			return 1;
+
+		/* scatter-gather list case */
+		for (i = 0; i < lpfc_cmd->seg_cnt; i++) {
+			/* Check to see if current BPL is full of BDEs */
+			/* If this is last BDE and there is one left in */
+			/* current BPL, use it.                         */
+			if (num_bde == max_bde) {
+				bmp = kmalloc(sizeof (DMABUF_t), GFP_ATOMIC);
+				if (bmp == 0) {
+					goto error_out;
+				}
+				memset(bmp, 0, sizeof (DMABUF_t));
+				bmp->virt =
+				    lpfc_mbuf_alloc(phba, 0, &bmp->phys);
+				if (!bmp->virt) {
+					kfree(bmp);
+					goto error_out;
+				}
+				max_bde = ((1024 / sizeof (ULP_BDE64)) - 3);
+				/* Fill in continuation entry to next bpl */
+				bpl->addrHigh =
+				    le32_to_cpu(putPaddrHigh(bmp->phys));
+				bpl->addrLow =
+				    le32_to_cpu(putPaddrLow(bmp->phys));
+				bpl->tus.f.bdeFlags = BPL64_SIZE_WORD;
+				num_bde++;
+				if (num_bmps == 1) {
+					cmd->un.fcpi64.bdl.bdeSize +=
+					    (num_bde * sizeof (ULP_BDE64));
+				} else {
+					topbpl->tus.f.bdeSize =
+					    (num_bde * sizeof (ULP_BDE64));
+					topbpl->tus.w =
+					    le32_to_cpu(topbpl->tus.w);
+				}
+				topbpl = bpl;
+				bpl = (ULP_BDE64 *) bmp->virt;
+				list_add(&bmp->list, &head_bmp->list);
+				num_bde = 0;
+				num_bmps++;
+			}
+
+			physaddr = sg_dma_address(sgel_p);
+
+			bpl->addrLow = le32_to_cpu(putPaddrLow(physaddr));
+			bpl->addrHigh = le32_to_cpu(putPaddrHigh(physaddr));
+			bpl->tus.f.bdeSize = sg_dma_len(sgel_p);
+			if (datadir == SCSI_DATA_WRITE)
+			{
+				bpl->tus.f.bdeFlags = 0;
+			} else {
+				bpl->tus.f.bdeFlags = BUFF_USE_RCV;
+			}
+			bpl->tus.w = le32_to_cpu(bpl->tus.w);
+			bpl++;
+			sgel_p++;
+			num_bde++;
+		}		/* end for loop */
+
+		if (datadir == SCSI_DATA_WRITE)
+		{
+			cmd->ulpCommand = CMD_FCP_IWRITE64_CR;
+			fcp_cmnd->fcpCntl3 = WRITE_DATA;
+
+			phba->fc4OutputRequests++;
+		} else {
+			cmd->ulpCommand = CMD_FCP_IREAD64_CR;
+			cmd->ulpPU = PARM_READ_CHECK;
+			cmd->un.fcpi.fcpi_parm = cmnd->request_bufflen;
+			fcp_cmnd->fcpCntl3 = READ_DATA;
+
+			phba->fc4InputRequests++;
+		}
+	} else {
+		if (cmnd->request_buffer && cmnd->request_bufflen) {
+
+			physaddr = pci_map_single(phba->pcidev,
+						  cmnd->request_buffer,
+						  cmnd->request_bufflen,
+						  scsi_to_pci_dma_dir(datadir));
+
+			/* no scatter-gather list case */
+			lpfc_cmd->nonsg_phys = physaddr;
+			bpl->addrLow = le32_to_cpu(putPaddrLow(physaddr));
+			bpl->addrHigh = le32_to_cpu(putPaddrHigh(physaddr));
+			bpl->tus.f.bdeSize = cmnd->request_bufflen;
+			if (datadir == SCSI_DATA_WRITE)
+			{
+				cmd->ulpCommand = CMD_FCP_IWRITE64_CR;
+				fcp_cmnd->fcpCntl3 = WRITE_DATA;
+				bpl->tus.f.bdeFlags = 0;
+
+				phba->fc4OutputRequests++;
+			} else {
+				cmd->ulpCommand = CMD_FCP_IREAD64_CR;
+				cmd->ulpPU = PARM_READ_CHECK;
+				cmd->un.fcpi.fcpi_parm = cmnd->request_bufflen;
+				fcp_cmnd->fcpCntl3 = READ_DATA;
+				bpl->tus.f.bdeFlags = BUFF_USE_RCV;
+
+				phba->fc4InputRequests++;
+			}
+			bpl->tus.w = le32_to_cpu(bpl->tus.w);
+			num_bde = 1;
+			bpl++;
+		} else {
+			cmd->ulpCommand = CMD_FCP_ICMND64_CR;
+			cmd->un.fcpi.fcpi_parm = 0;
+			fcp_cmnd->fcpCntl3 = 0;
+
+			phba->fc4ControlRequests++;
+		}
+	}
+	bpl->addrHigh = 0;
+	bpl->addrLow = 0;
+	bpl->tus.w = 0;
+	if (num_bmps == 1) {
+		cmd->un.fcpi64.bdl.bdeSize += (num_bde * sizeof (ULP_BDE64));
+	} else {
+		topbpl->tus.f.bdeSize = (num_bde * sizeof (ULP_BDE64));
+		topbpl->tus.w = le32_to_cpu(topbpl->tus.w);
+	}
+	cmd->ulpBdeCount = 1;
+	cmd->ulpLe = 1;		/* Set the LE bit in the iocb */
+
+	/* set the Data Length field in the FCP CMND accordingly */
+	fcp_cmnd->fcpDl = be32_to_cpu(cmnd->request_bufflen);
+
+	return (0);
+
+error_out:
+	/* Allocation of a chained BPL failed.  Unmap the sg list and return
+	 * an error. */
+	pci_unmap_sg(phba->pcidev, sgel_beginp, lpfc_cmd->seg_cnt,
+		     scsi_to_pci_dma_dir(datadir));
+	return 1;
+}
+
+int
+lpfc_queuecommand(struct scsi_cmnd *cmnd, void (*done) (struct scsi_cmnd *))
+{
+	lpfcHBA_t *phba;
+	LPFC_SCSI_BUF_t *lpfc_cmd;
+	int ret;
+	void (*old_done) (struct scsi_cmnd *);
+	unsigned long iflag;
+	LPFCSCSITARGET_t *targetp;
+	lpfcCfgParam_t *clp;
+	struct Scsi_Host *host;
+
+	host = cmnd->host;
+
+	phba = (lpfcHBA_t *) host->hostdata[0];
+	clp = &phba->config[0];
+
+	LPFC_DRVR_LOCK(phba, iflag);
+
+	/* 
+	 * If the hba is in blocked state and the command is a retry queue the
+	 * command and retry success 
+	 */
+	if (phba->in_retry) {
+		cmnd->scsi_done = done;
+		cmnd->reset_chain = phba->cmnd_retry_list;
+		phba->cmnd_retry_list = cmnd;
+		cmnd->host_scribble = 0;
+		atomic_inc(&phba->cmnds_in_flight);
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		return (0);
+	}
+
+	lpfc_cmd = lpfc_get_scsi_buf(phba);
+	if (lpfc_cmd == 0) {
+		if (atomic_read(&phba->cmnds_in_flight) == 0
+		    && (host->host_self_blocked == FALSE)) {
+			LPFC_DRVR_UNLOCK(phba, iflag);
+		} else {
+			/* Do not count retry (with cmnds_in_flight) */
+			if(cmnd->retries)
+				cmnd->retries--;
+			LPFC_DRVR_UNLOCK(phba, iflag);
+		}
+		cmnd->result = ScsiResult(DID_BUS_BUSY, 0);
+		done(cmnd);
+		return (0);
+	}
+	
+
+	lpfc_cmd->scsi_bus = cmnd->channel;
+	lpfc_cmd->scsi_target = cmnd->target;
+	lpfc_cmd->scsi_lun = cmnd->lun;
+
+	if ((targetp = lpfc_find_target(phba, lpfc_cmd->scsi_target))) {
+ 
+		if ((targetp->pcontext == 0)
+		    && !(targetp->targetFlags & FC_NPR_ACTIVE)) {
+			lpfc_free_scsi_buf(lpfc_cmd);
+			LPFC_DRVR_UNLOCK(phba, iflag);
+			/* error-out this command */
+			cmnd->result = ScsiResult(DID_NO_CONNECT, 0);
+			done(cmnd);
+			return (0);
+		}
+
+	}
+	
+	/* store our command structure for later */
+	lpfc_cmd->pCmd = cmnd;
+	cmnd->host_scribble = (unsigned char *)lpfc_cmd;
+
+	/* Let the driver time I/Os out, NOT the upper layer */
+	lpfc_cmd->scsitmo = lpfc_scsi_delete_timer(cmnd);
+	lpfc_cmd->timeout = (uint32_t) (cmnd->timeout_per_command / HZ) +
+	    phba->fcp_timeout_offset;
+	/* save original done function in case we can not issue this
+	   command */
+	old_done = cmnd->scsi_done;
+
+	cmnd->scsi_done = done;
+
+	ret = lpfc_scsi_cmd_start(lpfc_cmd);
+	if (ret) {
+
+		lpfc_scsi_add_timer(cmnd, cmnd->timeout_per_command);
+
+		lpfc_free_scsi_buf(lpfc_cmd);
+
+		/* restore original done function in command */
+		cmnd->scsi_done = old_done;
+		if (ret < 0) {
+			/* permanent failure -- error out command */
+			cmnd->result = ScsiResult(DID_BAD_TARGET, 0);
+			LPFC_DRVR_UNLOCK(phba, iflag);
+			done(cmnd);
+			return (0);
+		} else {
+			if (atomic_read(&phba->cmnds_in_flight) == 0) {
+				/* there are no other commands which will
+				   complete to flush the queue, so retry */
+				LPFC_DRVR_UNLOCK(phba, iflag);
+			} else {
+				/* Do not count retry (with cmnds_in_flight) */
+				if(cmnd->retries)
+					cmnd->retries--;
+				LPFC_DRVR_UNLOCK(phba, iflag);
+			}
+			cmnd->result = ScsiResult(DID_BUS_BUSY, 0);
+			done(cmnd);
+			return (0);
+		}
+	}
+
+	atomic_inc(&phba->cmnds_in_flight);
+	LPFC_DRVR_UNLOCK(phba, iflag);
+
+	/* Return the error code. */
+	return (0);
+}
+
+int
+lpfc_abort_handler(struct scsi_cmnd *cmnd)
+{
+	lpfcHBA_t *phba;
+	LPFC_SCSI_BUF_t *lpfc_cmd;
+	unsigned long iflag;
+	int rc = 0;
+
+	struct scsi_cmnd *prev_cmnd;
+
+	/* release io_request_lock */
+	spin_unlock_irq(&io_request_lock);
+	phba = (lpfcHBA_t *) cmnd->host->hostdata[0];
+
+	LPFC_DRVR_LOCK(phba, iflag);
+
+	lpfc_cmd = (LPFC_SCSI_BUF_t *) cmnd->host_scribble;
+
+	/* 
+	   If the command is in retry cahin. delete the command from the
+	   list.
+	 */
+	if (!lpfc_cmd) {
+
+		if (phba->cmnd_retry_list) {
+			if (phba->cmnd_retry_list == cmnd) {
+				phba->cmnd_retry_list = cmnd->reset_chain;
+
+			} else {
+				prev_cmnd = phba->cmnd_retry_list;
+
+				while ((prev_cmnd->reset_chain != 0) &&
+				       (prev_cmnd->reset_chain != cmnd))
+					prev_cmnd = prev_cmnd->reset_chain;
+
+				if (prev_cmnd->reset_chain)
+					prev_cmnd->reset_chain =
+					    cmnd->reset_chain;
+				else
+					rc = 1;		/* return FAILURE */
+			}
+
+		} else
+			rc = 1;		/* return FAILURE */
+		goto exit_abort_handler;
+	}
+
+	/* set command timeout to 60 seconds */
+	lpfc_cmd->timeout = 60;
+
+	/* SCSI layer issued abort device */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0712,
+			lpfc_mes0712,
+			lpfc_msgBlk0712.msgPreambleStr,
+			lpfc_cmd->scsi_target,
+			lpfc_cmd->scsi_lun);
+
+	/* tell low layer to abort it */
+	rc = lpfc_scsi_cmd_abort(phba, lpfc_cmd);
+
+	/* SCSI layer issued abort device */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0749,
+			lpfc_mes0749,
+			lpfc_msgBlk0749.msgPreambleStr,
+			lpfc_cmd->scsi_target,
+			lpfc_cmd->scsi_lun, rc,
+			lpfc_cmd->status, lpfc_cmd->result);
+
+exit_abort_handler:
+	LPFC_DRVR_UNLOCK(phba, iflag);
+
+	/* reacquire io_request_lock for midlayer */
+	spin_lock_irq(&io_request_lock);
+
+	return ((rc == 0) ? SUCCESS : FAILURE);
+
+}
+
+/* This function is now OS-specific and driver-specific */
+
+int
+lpfc_reset_lun_handler(struct scsi_cmnd *cmnd)
+{
+	lpfcHBA_t *phba;
+	LPFC_SCSI_BUF_t *lpfc_cmd;
+	unsigned long iflag;
+	int rc;
+
+	/* release io_request_lock */
+	spin_unlock_irq(&io_request_lock);
+	phba = (lpfcHBA_t *) cmnd->host->hostdata[0];
+	LPFC_DRVR_LOCK(phba, iflag);
+
+	/* Get resources to send a SCSI command */
+	lpfc_cmd = lpfc_get_scsi_buf(phba);
+	if (lpfc_cmd == 0) {
+		rc = 0;		/* return FAILURE */
+		goto exit_reset_lun_handler;
+	}
+
+	lpfc_cmd->timeout = 60;	   /* 60 sec command timeout */
+	lpfc_cmd->scsi_hba = phba;
+	lpfc_cmd->scsi_bus = cmnd->channel;
+	lpfc_cmd->scsi_target = cmnd->target;
+	lpfc_cmd->scsi_lun = cmnd->lun;
+	lpfc_cmd->pCmd = cmnd;
+
+	/* SCSI layer issued abort device */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0713,
+			lpfc_mes0713,
+			lpfc_msgBlk0713.msgPreambleStr,
+			lpfc_cmd->scsi_target,
+			lpfc_cmd->scsi_lun);
+
+
+	/*
+	 * For SCSI device_reset_handler, by default issue LUN Reset.
+	 * If the target does not support this, issue Target Reset.
+	 * (Alternatively a Abort Task Set can be issued.)
+	 */
+#ifndef USE_ABORT_TSET
+	rc = lpfc_scsi_lun_reset(lpfc_cmd, phba, lpfc_cmd->scsi_bus,
+				 lpfc_cmd->scsi_target, lpfc_cmd->scsi_lun,
+				 LPFC_EXTERNAL_RESET | LPFC_ISSUE_LUN_RESET);
+	/* check if IOCB command was issued and also check reply status */
+	if (rc != 1 || lpfc_cmd->status != IOSTAT_SUCCESS) {
+		rc = lpfc_scsi_tgt_reset(lpfc_cmd, phba, lpfc_cmd->scsi_bus,
+					lpfc_cmd->scsi_target,
+					LPFC_EXTERNAL_RESET);
+	}
+
+#else /* USE_ABORT_TSET */
+	rc = lpfc_scsi_lun_reset(lpfc_cmd, phba, lpfc_cmd->scsi_bus,
+				 lpfc_cmd->scsi_target, lpfc_cmd->scsi_lun,
+				 LPFC_EXTERNAL_RESET | LPFC_ISSUE_ABORT_TSET);
+#endif /* USE_ABORT_TSET */
+
+	/* SCSI layer issued abort device */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0747,
+			lpfc_mes0747,
+			lpfc_msgBlk0747.msgPreambleStr,
+			lpfc_cmd->scsi_target,
+			lpfc_cmd->scsi_lun,
+			rc, lpfc_cmd->status, lpfc_cmd->result);
+
+	lpfc_free_scsi_buf(lpfc_cmd);
+
+exit_reset_lun_handler:
+	LPFC_DRVR_UNLOCK(phba, iflag);
+
+	/* reacquire io_request_lock for midlayer */
+	spin_lock_irq(&io_request_lock);
+
+	return ((rc == 1) ? SUCCESS : FAILURE);
+}
+
+void
+free_lun(lpfcHBA_t * phba, LPFC_SCSI_BUF_t * lpfc_cmd)
+{
+	LPFCSCSITARGET_t *targetp;
+	LPFCSCSILUN_t *lunp, *curLun;
+	struct list_head *curr, *next;
+
+	lunp = lpfc_cmd->pLun;
+	if (lunp == 0) {
+		return;
+	}
+
+	targetp = lunp->pTarget;
+	if (targetp == 0) {
+		return;
+	}
+	lpfc_sched_remove_lun_from_ring(phba, lunp);
+	list_for_each_safe(curr, next, &targetp->lunlist) {
+
+		curLun = list_entry(curr, LPFCSCSILUN_t, list);
+
+		if (curLun == lunp) {
+			list_del(&lunp->list);
+			kfree(lunp);
+			return;
+		}
+	}
+
+}
+
+
+void
+lpfc_os_return_scsi_cmd(lpfcHBA_t * phba, LPFC_SCSI_BUF_t * lpfc_cmd)
+{
+	struct scsi_cmnd *lnx_cmnd = lpfc_cmd->pCmd;
+	LPFCSCSILUN_t *lun_device;
+	lpfc_xlat_err_t resultdata;
+	lpfc_xlat_err_t *presult;
+	PARM_ERR *perr;
+	uint32_t host_status;
+	uint32_t scsi_status;
+
+	FCP_CMND *fcp_cmnd;
+
+	if (lpfc_cmd->status >= IOSTAT_CNT)
+		lpfc_cmd->status = IOSTAT_DEFAULT;
+	presult = &lpfc_iostat_tbl[lpfc_cmd->status];
+
+	host_status = presult->host_status;
+	scsi_status = 0;
+
+	/* Now check if there are any special actions to perform */
+	if (presult->action_flag) {
+		/* FCP cmd <cmnd> failed <target>/<lun> */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0729,
+				lpfc_mes0729,
+				lpfc_msgBlk0729.msgPreambleStr,
+				lnx_cmnd->cmnd[0], lpfc_cmd->scsi_target,
+				lpfc_cmd->scsi_lun,
+				lpfc_cmd->status,
+				lpfc_cmd->result, lpfc_cmd->IOxri,
+				lpfc_cmd->cur_iocbq.iocb.ulpIoTag);
+
+		if (presult->action_flag & LPFC_FCPRSP_ERROR) {
+			presult = &resultdata;
+			presult->host_status = DID_OK;
+			presult->action_flag = 0;
+			/* Call FCP RSP handler to determine result */
+			scsi_status = lpfc_os_fcp_err_handle(lpfc_cmd, presult);
+			if (scsi_status == LPFC_CMD_BEING_RETRIED) {
+				return;
+			}
+		} else {
+			if (presult->action_flag & LPFC_IOERR_TABLE) {
+
+				perr = (PARM_ERR *) & lpfc_cmd->result;
+				if (perr->statLocalError >= IOERR_CNT)
+					perr->statLocalError = IOERR_DEFAULT;
+				presult = &lpfc_ioerr_tbl[perr->statLocalError];
+			}
+		}
+		host_status = presult->host_status;
+
+		if (presult->action_flag & LPFC_STAT_ACTION) {
+			perr = (PARM_ERR *) & lpfc_cmd->result;
+			if (perr->statAction == RJT_RETRYABLE) {
+				host_status = DID_BUS_BUSY;
+			}
+		}
+
+		lun_device = lpfc_find_lun_device(lpfc_cmd);
+
+		/* Special treatment for targets in the NPort recovery state */
+		if (lun_device &&
+		    (lun_device->pTarget->targetFlags & FC_NPR_ACTIVE)) {
+
+			/* Make sure command will be retried */
+			if (host_status != DID_OK          &&
+			    host_status != DID_PASSTHROUGH &&
+			    host_status != DID_ERROR       &&
+			    host_status != DID_PARITY      &&
+			    host_status != DID_BUS_BUSY )
+				host_status = DID_SOFT_ERROR;
+
+			if (lnx_cmnd->retries) {
+				/* Do not count this retry (in FC_NPR_ACTIVE state) */
+				lnx_cmnd->retries--;
+			}
+		}
+
+		if (presult->action_flag & LPFC_DELAY_IODONE) {
+			lnx_cmnd->result = ScsiResult(host_status, scsi_status);
+ 			lpfc_scsi_delay_iodone(phba, lpfc_cmd);
+			return;
+		}
+
+	}
+
+	fcp_cmnd = lpfc_cmd->fcp_cmnd;
+
+	/*
+	 * If this is a scsi inquiry response, make sure the response is standard
+	 * inquiry page data before deciding whether the device exists or not.
+	 */
+	if ((fcp_cmnd->fcpCdb[0] == FCP_SCSI_INQUIRY) && (fcp_cmnd->fcpCdb[1] == 0) &&
+	     (fcp_cmnd->fcpCdb[2] == 0)) {
+		unsigned char *buf;
+		lpfcCfgParam_t *clp;
+		LPFCSCSITARGET_t *targetp;
+
+		buf = (unsigned char *)lnx_cmnd->request_buffer;
+		targetp = lpfc_find_target(phba, lpfc_cmd->scsi_target);
+
+		if (buf && ((*buf == 0x7f) || ((*buf & 0xE0) == 0x20))) {
+			/*
+			 * SLES8 does not handle Peripheral Qualifier bit set 
+			 * to 1. If the lpfc_INQ_PQB_filter parameter is enabled
+			 * set, change PQB = 1 to PQB = 3.
+			 */
+			if (lpfc_inq_pqb_filter)
+				*buf |= 0x60;
+
+			free_lun(phba, lpfc_cmd);
+
+			/* If a LINUX OS patch to support, LUN skipping / no LUN
+			 * 0, is not present, this code will fake out the LINUX
+			 * scsi layer to allow it to detect all LUNs if there
+			 * are LUN holes on a device.
+			 */
+			clp = &phba->config[0];
+			if ((clp[LPFC_CFG_LUN_SKIP].a_current) &&
+			    (targetp) &&
+			    (lpfc_cmd->scsi_lun < targetp->max_lun)){
+				/* Make lun unassigned and wrong type */
+				*buf++ = 0x3;
+				*buf++ = 0x0;
+				*buf++ = 0x3;
+				*buf++ = 0x12;
+				*buf++ = 0x4;
+				*buf++ = 0x0;
+				*buf++ = 0x0;
+				*buf++ = 0x2;
+			} 
+		} else { 
+			if ((targetp) && (lpfc_cmd->scsi_lun >  targetp->max_lun))
+				targetp->max_lun = lpfc_cmd->scsi_lun;
+		}
+	}
+
+	lnx_cmnd->result = ScsiResult(host_status, scsi_status);
+
+	lpfc_iodone(phba, lpfc_cmd);
+
+	return;
+}
+
+void
+lpfc_scsi_add_timer(struct scsi_cmnd *SCset, int timeout)
+{
+
+	if (SCset->eh_timeout.function != 0) {
+		del_timer(&SCset->eh_timeout);
+	}
+
+	if (SCset->eh_timeout.data != (unsigned long)SCset) {
+		SCset->eh_timeout.data = (unsigned long)SCset;
+		SCset->eh_timeout.function =
+		    (void (*)(unsigned long))lpfc_nodev;
+	}
+	SCset->eh_timeout.expires = jiffies + timeout;
+
+	add_timer(&SCset->eh_timeout);
+	return;
+}
+
+int
+lpfc_scsi_delete_timer(struct scsi_cmnd *SCset)
+{
+	int rtn;
+
+	rtn = SCset->eh_timeout.expires - jiffies;
+	del_timer(&SCset->eh_timeout);
+	SCset->eh_timeout.data = 0;
+	SCset->eh_timeout.function = 0;
+	return (rtn);
+}
+
+uint32_t
+lpfc_os_fcp_err_handle(LPFC_SCSI_BUF_t * lpfc_cmd, lpfc_xlat_err_t * presult)
+{
+	struct scsi_cmnd *cmnd = lpfc_cmd->pCmd;
+	FCP_CMND *fcpcmd;
+	FCP_RSP *fcprsp;
+	lpfcHBA_t *phba;
+	LPFCSCSILUN_t *plun;
+	IOCB_t *iocb;
+	lpfcCfgParam_t *clp;
+	int datadir;
+	uint8_t iostat;
+	uint32_t scsi_status;
+	uint32_t rsplen = 0;
+
+	phba = lpfc_cmd->scsi_hba;
+	plun = lpfc_cmd->pLun;
+	clp = &phba->config[0];
+	iocb = &lpfc_cmd->cur_iocbq.iocb;
+	fcpcmd = lpfc_cmd->fcp_cmnd;
+	fcprsp = lpfc_cmd->fcp_rsp;
+	iostat = (uint8_t) (lpfc_cmd->status);
+
+	/* Make sure presult->host_status is identically DID_OK and scsi_status
+	 * is identically 0.  The driver alters this value later on an as-needed
+	 * basis.
+	 */
+	presult->host_status = DID_OK;
+	scsi_status = 0;
+
+	/*
+	 *  If this is a task management command, there is no
+	 *  scsi packet associated with it.  Return here.
+	 */
+	if ((cmnd == 0) || (fcpcmd->fcpCntl2)) {
+		return (scsi_status);
+	}
+
+	/* FCP cmd failed: RSP */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0730,
+			lpfc_mes0730,
+			lpfc_msgBlk0730.msgPreambleStr,
+			fcprsp->rspStatus2, fcprsp->rspStatus3,
+			be32_to_cpu(fcprsp->rspResId),
+			be32_to_cpu(fcprsp->rspSnsLen),
+			be32_to_cpu(fcprsp->rspRspLen), fcprsp->rspInfo3);
+
+	if (fcprsp->rspStatus2 & RSP_LEN_VALID) {
+		rsplen = be32_to_cpu(fcprsp->rspRspLen);
+		if ((rsplen > 8) || (fcprsp->rspInfo3 != RSP_NO_FAILURE)) {
+			presult->host_status = DID_ERROR;
+			scsi_status = (uint32_t) (fcprsp->rspStatus3);
+			return (scsi_status);
+		}
+	}
+
+	/* if there's sense data, let's copy it back */
+	if ((fcprsp->rspStatus2 & SNS_LEN_VALID) && (fcprsp->rspSnsLen != 0)) {
+		uint32_t snsLen;
+
+		snsLen = be32_to_cpu(fcprsp->rspSnsLen);
+
+		/* then we return this sense info in the sense buffer for this
+		   cmd */
+		if (snsLen > SCSI_SENSE_BUFFERSIZE) {
+			snsLen = SCSI_SENSE_BUFFERSIZE;
+		}
+		memcpy(cmnd->sense_buffer,
+		       (((uint8_t *) & fcprsp->rspInfo0) + rsplen), snsLen);
+	}
+
+	/*
+	 * In the Tape Env., there is an early WARNNING right before EOM without
+	 * data xfer error. We should set b_resid to be 0 before we check all
+	 * other cases.
+	 */
+
+	cmnd->resid = 0;
+
+	if (fcprsp->rspStatus2 & (RESID_UNDER | RESID_OVER)) {
+		if (fcprsp->rspStatus2 & RESID_UNDER) {
+			cmnd->resid = be32_to_cpu(fcprsp->rspResId);
+
+			/* FCP Read Underrun, expected <len>, residual
+			   <resid> */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0716,
+					lpfc_mes0716,
+					lpfc_msgBlk0716.msgPreambleStr,
+					be32_to_cpu(fcpcmd->fcpDl),
+					cmnd->resid, iocb->un.fcpi.fcpi_parm,
+					cmnd->cmnd[0], cmnd->underflow);
+
+			switch (cmnd->cmnd[0]) {
+			case TEST_UNIT_READY:
+			case REQUEST_SENSE:
+			case INQUIRY:
+			case RECEIVE_DIAGNOSTIC:
+			case READ_CAPACITY:
+			case FCP_SCSI_READ_DEFECT_LIST:
+			case MDAC_DIRECT_CMD:
+				/* return the scsi status */ 
+				scsi_status = (uint32_t) (fcprsp->rspStatus3); 
+				return (scsi_status); 
+
+			default:
+				if (!(fcprsp->rspStatus2 & SNS_LEN_VALID) &&
+				    ((cmnd->request_bufflen - cmnd->resid) <
+				     cmnd->underflow)) {
+
+					/* FCP command <cmd> residual underrun
+					   converted to error */
+					lpfc_printf_log(phba->brd_no,
+							&lpfc_msgBlk0717,
+							lpfc_mes0717,
+							lpfc_msgBlk0717.
+							msgPreambleStr,
+							cmnd->cmnd[0],
+							cmnd->request_bufflen,
+							cmnd->resid,
+							cmnd->underflow);
+
+					presult->host_status = DID_ERROR;
+					scsi_status =
+					    (uint32_t) (fcprsp->rspStatus3);
+
+					/* Queue Full handled below */
+					if (scsi_status != SCSI_STAT_QUE_FULL)
+						return (scsi_status);
+
+				}
+			}
+		}
+	} else {
+		datadir = lpfc_cmd->datadir;
+
+		if ((datadir == SCSI_DATA_READ) && iocb->un.fcpi.fcpi_parm)
+		{
+			/* 
+			 * This is ALWAYS a readcheck error!! 
+			 * Give Check Condition priority over Read Check 
+			 */
+
+			if (fcprsp->rspStatus3 != SCSI_STAT_BUSY) {
+				if (fcprsp->rspStatus3 != 
+				    SCSI_STAT_CHECK_COND) {
+					/* FCP Read Check Error */
+					lpfc_printf_log(phba->brd_no,
+							&lpfc_msgBlk0734,
+							lpfc_mes0734,
+							lpfc_msgBlk0734.
+							msgPreambleStr,
+							be32_to_cpu(fcpcmd->
+								    fcpDl),
+							be32_to_cpu(fcprsp->
+								    rspResId),
+							iocb->un.fcpi.fcpi_parm,
+							cmnd->cmnd[0]);
+
+					presult->host_status = DID_ERROR;
+					cmnd->resid = cmnd->request_bufflen;
+					scsi_status =
+					    (uint32_t) (fcprsp->rspStatus3);
+					return (scsi_status);
+				}
+
+				/* FCP Read Check Error with Check Condition */
+				lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0735,
+						lpfc_mes0735,
+						lpfc_msgBlk0735.msgPreambleStr,
+						be32_to_cpu(fcpcmd->fcpDl),
+						be32_to_cpu(fcprsp->rspResId),
+						iocb->un.fcpi.fcpi_parm,
+						cmnd->cmnd[0]);
+			}
+		}
+	}
+
+	scsi_status = (uint32_t) (fcprsp->rspStatus3);
+
+	switch (scsi_status) {
+	case SCSI_STAT_QUE_FULL:
+		if (clp[LPFC_CFG_DQFULL_THROTTLE_UP_TIME].a_current) {
+			lpfc_scsi_lower_lun_qthrottle(phba, lpfc_cmd);
+		}
+		presult->host_status = DID_BUS_BUSY;
+		presult->action_flag |= LPFC_DELAY_IODONE;
+		break;
+
+	case SCSI_STAT_BUSY:
+		presult->host_status = DID_BUS_BUSY;
+		scsi_status = (uint32_t) (fcprsp->rspStatus3);
+		presult->action_flag |= LPFC_DELAY_IODONE;
+		break;
+
+	case SCSI_STAT_CHECK_COND:
+		{
+			uint32_t i;
+			uint32_t cc, asc_ascq;
+			uint32_t *lp;
+
+			i = be32_to_cpu(fcprsp->rspRspLen);
+			lp = (uint32_t *) (((uint8_t *) & fcprsp->rspInfo0) +
+					   i);
+			cc = be32_to_cpu((lp[3]) & be32_to_cpu(0xFF000000));
+			asc_ascq = be32_to_cpu((lp[3]) & be32_to_cpu(0xFFFF0000));
+
+			/* <ASC ASCQ> Check condition received */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0737,
+					lpfc_mes0737,
+					lpfc_msgBlk0737.msgPreambleStr,
+					asc_ascq,
+					clp[LPFC_CFG_CHK_COND_ERR].a_current,
+					clp[LPFC_CFG_DELAY_RSP_ERR].a_current,
+					*lp);
+
+			switch (cc) {
+			case 0x0:	/* ASC and ASCQ = 0 */
+				break;
+			case 0x44000000:	/* Internal Target Failure */
+			case 0x25000000:	/* Login Unit not supported */
+			case 0x20000000:	/* Invalid cmd operation code */
+				/* These will be considered an error if the
+				 * command is not a TUR and CHK_COND_ERR is not
+				 * set */
+				if ((fcpcmd->fcpCdb[0] !=
+				     FCP_SCSI_TEST_UNIT_READY)
+				    && (clp[LPFC_CFG_CHK_COND_ERR].a_current)) {
+					presult->host_status = DID_ERROR;
+					scsi_status = 0;
+				}
+			}
+			if (asc_ascq == 0x04010000) {
+				presult->action_flag |= LPFC_DELAY_IODONE;
+				presult->host_status = DID_ERROR;
+				scsi_status = 0;
+			}
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	return (scsi_status);
+}
+
+void
+lpfc_iodone(lpfcHBA_t * phba, LPFC_SCSI_BUF_t * lpfc_cmd)
+{
+	LPFCSCSITARGET_t *targetp;
+	struct scsi_cmnd *lnx_cmnd = lpfc_cmd->pCmd;
+	struct scatterlist *sgel_p = 
+			(struct scatterlist *) lnx_cmnd->request_buffer;
+	int datadir;
+
+	datadir = lpfc_cmd->datadir;
+	if (lnx_cmnd->use_sg) {
+		if (lpfc_cmd->seg_cnt == 0) {
+			/* This is an error.  Don't allow the caller to unmap a
+			 * zero-count sg list.  Note that the sgel_p may or may not
+			 * be NULL so treat the printk value as an unsigned long and
+			 * don't dereference. it. */
+			printk(KERN_ERR "%s: ignoring pci_unmap_sg request on"
+				" lpfc_cmd %p sgel_p 0x%lx, seg_cnt %d\n", 
+				__FUNCTION__, lpfc_cmd, 
+				(unsigned long) sgel_p, lpfc_cmd->seg_cnt);
+		} else {
+			pci_unmap_sg(phba->pcidev, sgel_p, lpfc_cmd->seg_cnt,
+					 scsi_to_pci_dma_dir(datadir));
+			lpfc_cmd->seg_cnt = 0;
+		}
+	} else if ((lnx_cmnd->request_bufflen) && (lpfc_cmd->nonsg_phys)) {
+		pci_unmap_single(phba->pcidev, lpfc_cmd->nonsg_phys,
+				 lnx_cmnd->request_bufflen,
+				 scsi_to_pci_dma_dir(datadir));
+	}
+
+	/* Lets check to see if the device timed out during this I/O,
+	 * if so, return DID_NO_CONNECT.
+	 */
+	targetp = lpfc_find_target(phba, lpfc_cmd->scsi_target);
+	if (targetp && (targetp->pcontext == 0) &&
+	    !(targetp->targetFlags & FC_NPR_ACTIVE)) {
+		if(lnx_cmnd->result)
+			lnx_cmnd->result = ScsiResult(DID_NO_CONNECT, 0);
+	}
+
+	lpfc_free_scsi_buf(lpfc_cmd);
+	lpfc_scsi_done(phba, lnx_cmnd);
+	return;
+}
+
+void
+lpfc_delay_done(unsigned long ptr)
+{
+	lpfcHBA_t *phba;
+	LPFC_SCSI_BUF_t *lpfc_cmd;
+	struct clk_data *clkData;
+	unsigned long iflag;
+
+	clkData = (struct clk_data *)ptr;
+	phba = clkData->phba;
+	LPFC_DRVR_LOCK(phba, iflag);
+        	if (clkData->flags & TM_CANCELED) {
+		list_del((struct list_head *)clkData);
+		kfree(clkData);	
+		goto out;
+	}
+
+	lpfc_cmd = (LPFC_SCSI_BUF_t *) (clkData->clData1);
+	list_del(&lpfc_cmd->listentry);
+	clkData->timeObj->function = 0;
+	list_del((struct list_head *)clkData);
+	kfree(clkData);
+
+	lpfc_iodone(phba, lpfc_cmd);
+out:
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	return;
+}
+
+int
+lpfc_scsi_delay_iodone(lpfcHBA_t * phba, LPFC_SCSI_BUF_t * lpfc_cmd)
+{
+	lpfcCfgParam_t *clp;
+	uint32_t tmout;
+	FCP_RSP *fcprsp;
+	uint32_t scsi_status;
+
+	clp = &phba->config[0];
+
+	fcprsp = lpfc_cmd->fcp_rsp;
+	scsi_status = (uint32_t) (fcprsp->rspStatus3);
+	if (scsi_status == SCSI_STAT_QUE_FULL) {
+		/* For QUE_FULL, delay should be at least 5 seconds */
+		tmout = clp[LPFC_CFG_NO_DEVICE_DELAY].a_current;
+		if(tmout < 5)
+			tmout = 5;
+
+		list_add(&lpfc_cmd->listentry, &phba->delay_list);
+
+		lpfc_start_timer(phba, tmout, &lpfc_cmd->delayIodoneFunc,
+				 lpfc_delay_done, (unsigned long)lpfc_cmd,
+				 (unsigned long)0);
+		return (0);
+	}
+
+	if (clp[LPFC_CFG_NO_DEVICE_DELAY].a_current) {
+		/* Set a timer so iodone can be called
+		 * for buffer upon expiration.
+		 */
+		tmout = clp[LPFC_CFG_NO_DEVICE_DELAY].a_current;
+
+		list_add(&lpfc_cmd->listentry, &phba->delay_list);
+
+		lpfc_start_timer(phba, tmout, &lpfc_cmd->delayIodoneFunc,
+				 lpfc_delay_done, (unsigned long)lpfc_cmd,
+				 (unsigned long)0);
+		return (0);
+	}
+
+	lpfc_iodone(phba, lpfc_cmd);
+	return (0);
+}
+
+void
+lpfc_block_requests(lpfcHBA_t * phba)
+{
+	phba->in_retry = 1;
+	scsi_block_requests(phba->host);
+
+}
+
+void
+lpfc_unblock_requests(lpfcHBA_t * phba)
+{
+
+	struct scsi_cmnd *cmnd, *next_cmnd;
+	unsigned long iflag;
+
+	cmnd = phba->cmnd_retry_list;
+	phba->in_retry = 0;
+	while (cmnd) {
+		next_cmnd = cmnd->reset_chain;
+		cmnd->reset_chain = 0;
+		cmnd->result = ScsiResult(DID_RESET, 0);
+		lpfc_scsi_done(phba, cmnd);
+		cmnd = next_cmnd;
+	}
+	phba->cmnd_retry_list = 0;
+	iflag = phba->iflag;
+
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	scsi_unblock_requests(phba->host);
+	LPFC_DRVR_LOCK(phba, iflag);
+	phba->iflag = iflag;
+}
+
+void
+lpfc_scsi_done(lpfcHBA_t * phba, struct scsi_cmnd *cmnd)
+{
+	unsigned long sflag;
+	unsigned long iflag;
+
+	LPFC_DRVR_UNLOCK(phba, iflag);
+
+	spin_lock_irqsave(&io_request_lock, sflag);
+
+	cmnd->host_scribble = 0;
+	lpfc_scsi_add_timer(cmnd, cmnd->timeout_per_command);
+	atomic_dec(&phba->cmnds_in_flight);
+
+	/* Give this command back to the OS */
+	cmnd->scsi_done(cmnd);
+
+	spin_unlock_irqrestore(&io_request_lock, sflag);
+	LPFC_DRVR_LOCK(phba, iflag);
+	return;
+}
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_sli.c linux-8155/drivers/addon/lpfc/lpfc_sli.c
--- linux-8152/drivers/addon/lpfc/lpfc_sli.c
+++ linux-8155/drivers/addon/lpfc/lpfc_sli.c
@@ -0,0 +1,3737 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_sli.c 483 2006-03-22 00:27:31Z sf_support $
+ */
+
+#include <linux/version.h>
+#include <linux/spinlock.h>
+
+
+#include <linux/blk.h>
+#include <scsi.h>
+
+#include "lpfc_hw.h"
+#include "lpfc_mem.h"
+#include "lpfc_sli.h"
+#include "lpfc_sched.h"
+#include "lpfc_disc.h"
+#include "lpfc.h"
+#include "lpfc_logmsg.h"
+#include "lpfc_scsi.h"
+#include "lpfc_crtn.h"
+
+int lpfc_sli_reset_on_init = 1;
+
+int lpfc_sli_handle_mb_event(lpfcHBA_t *);
+int lpfc_sli_handle_ring_event(lpfcHBA_t *, LPFC_SLI_RING_t *, uint32_t);
+int lpfc_sli_process_unsol_iocb(lpfcHBA_t * phba,
+	LPFC_SLI_RING_t * pring, LPFC_IOCBQ_t *saveq);
+int lpfc_sli_process_sol_iocb(lpfcHBA_t * phba,
+	LPFC_SLI_RING_t * pring, LPFC_IOCBQ_t *saveq);
+int lpfc_sli_ringtx_put(lpfcHBA_t *, LPFC_SLI_RING_t *, LPFC_IOCBQ_t *);
+int lpfc_sli_ringtxcmpl_put(lpfcHBA_t *, LPFC_SLI_RING_t *, LPFC_IOCBQ_t *);
+LPFC_IOCBQ_t *lpfc_sli_ringtx_get(lpfcHBA_t *, LPFC_SLI_RING_t *);
+LPFC_IOCBQ_t *lpfc_sli_ringtxcmpl_get(lpfcHBA_t *, LPFC_SLI_RING_t *,
+	 LPFC_IOCBQ_t *, uint32_t);
+LPFC_IOCBQ_t *lpfc_search_txcmpl(LPFC_SLI_RING_t * pring,
+		   LPFC_IOCBQ_t * prspiocb);
+DMABUF_t *lpfc_sli_ringpostbuf_search(lpfcHBA_t *, LPFC_SLI_RING_t *,
+	dma_addr_t, int);
+
+
+/*
+ * Define macro to log: Mailbox command x%x cannot issue Data
+ * This allows multiple uses of lpfc_msgBlk0311
+ * w/o perturbing log msg utility.
+*/
+#define LOG_MBOX_CANNOT_ISSUE_DATA( phba, mb, psli, flag) \
+			lpfc_printf_log(phba->brd_no,	\
+				&lpfc_msgBlk0311,	\
+				lpfc_mes0311,		\
+				lpfc_msgBlk0311.msgPreambleStr, \
+				mb->mbxCommand,		\
+				phba->hba_state,	\
+				psli->sliinit.sli_flag,	\
+				flag);
+
+
+/* This will save a huge switch to determine if the IOCB cmd
+ * is unsolicited or solicited.
+ */
+#define LPFC_UNKNOWN_IOCB 0
+#define LPFC_UNSOL_IOCB   1
+#define LPFC_SOL_IOCB     2
+#define LPFC_ABORT_IOCB   3
+uint8_t lpfc_sli_iocb_cmd_type[CMD_MAX_IOCB_CMD] = {
+	LPFC_UNKNOWN_IOCB,	/* 0x00 */
+	LPFC_UNSOL_IOCB,	/* CMD_RCV_SEQUENCE_CX     0x01 */
+	LPFC_SOL_IOCB,		/* CMD_XMIT_SEQUENCE_CR    0x02 */
+	LPFC_SOL_IOCB,		/* CMD_XMIT_SEQUENCE_CX    0x03 */
+	LPFC_SOL_IOCB,		/* CMD_XMIT_BCAST_CN       0x04 */
+	LPFC_SOL_IOCB,		/* CMD_XMIT_BCAST_CX       0x05 */
+	LPFC_UNKNOWN_IOCB,	/* CMD_QUE_RING_BUF_CN     0x06 */
+	LPFC_UNKNOWN_IOCB,	/* CMD_QUE_XRI_BUF_CX      0x07 */
+	LPFC_UNKNOWN_IOCB,	/* CMD_IOCB_CONTINUE_CN    0x08 */
+	LPFC_UNKNOWN_IOCB,	/* CMD_RET_XRI_BUF_CX      0x09 */
+	LPFC_SOL_IOCB,		/* CMD_ELS_REQUEST_CR      0x0A */
+	LPFC_SOL_IOCB,		/* CMD_ELS_REQUEST_CX      0x0B */
+	LPFC_UNKNOWN_IOCB,	/* 0x0C */
+	LPFC_UNSOL_IOCB,	/* CMD_RCV_ELS_REQ_CX      0x0D */
+	LPFC_ABORT_IOCB,	/* CMD_ABORT_XRI_CN        0x0E */
+	LPFC_ABORT_IOCB,	/* CMD_ABORT_XRI_CX        0x0F */
+	LPFC_ABORT_IOCB,	/* CMD_CLOSE_XRI_CN        0x10 */
+	LPFC_ABORT_IOCB,	/* CMD_CLOSE_XRI_CX        0x11 */
+	LPFC_SOL_IOCB,		/* CMD_CREATE_XRI_CR       0x12 */
+	LPFC_SOL_IOCB,		/* CMD_CREATE_XRI_CX       0x13 */
+	LPFC_SOL_IOCB,		/* CMD_GET_RPI_CN          0x14 */
+	LPFC_SOL_IOCB,		/* CMD_XMIT_ELS_RSP_CX     0x15 */
+	LPFC_SOL_IOCB,		/* CMD_GET_RPI_CR          0x16 */
+	LPFC_ABORT_IOCB,	/* CMD_XRI_ABORTED_CX      0x17 */
+	LPFC_SOL_IOCB,		/* CMD_FCP_IWRITE_CR       0x18 */
+	LPFC_SOL_IOCB,		/* CMD_FCP_IWRITE_CX       0x19 */
+	LPFC_SOL_IOCB,		/* CMD_FCP_IREAD_CR        0x1A */
+	LPFC_SOL_IOCB,		/* CMD_FCP_IREAD_CX        0x1B */
+	LPFC_SOL_IOCB,		/* CMD_FCP_ICMND_CR        0x1C */
+	LPFC_SOL_IOCB,		/* CMD_FCP_ICMND_CX        0x1D */
+	LPFC_UNKNOWN_IOCB,	/* 0x1E */
+	LPFC_SOL_IOCB,		/* CMD_FCP_TSEND_CX        0x1F */
+	LPFC_SOL_IOCB,		/* CMD_ADAPTER_MSG         0x20 */
+	LPFC_SOL_IOCB,		/* CMD_FCP_TRECEIVE_CX     0x21 */
+	LPFC_SOL_IOCB,		/* CMD_ADAPTER_DUMP        0x22 */
+	LPFC_SOL_IOCB,		/* CMD_FCP_TRSP_CX         0x23 */
+	/* 0x24 - 0x80 */
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	/* 0x30 */
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB,
+	/* 0x40 */
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB,
+	/* 0x50 */
+	LPFC_SOL_IOCB,
+	LPFC_SOL_IOCB,
+	LPFC_UNKNOWN_IOCB,
+	LPFC_SOL_IOCB,
+	LPFC_SOL_IOCB,
+	LPFC_UNSOL_IOCB,
+	LPFC_UNSOL_IOCB,
+	LPFC_SOL_IOCB,
+	LPFC_SOL_IOCB,
+
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB,
+	/* 0x60 */
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB,
+	/* 0x70 */
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB,
+	/* 0x80 */
+	LPFC_UNKNOWN_IOCB,
+	LPFC_UNSOL_IOCB,	/* CMD_RCV_SEQUENCE64_CX   0x81 */
+	LPFC_SOL_IOCB,		/* CMD_XMIT_SEQUENCE64_CR  0x82 */
+	LPFC_SOL_IOCB,		/* CMD_XMIT_SEQUENCE64_CX  0x83 */
+	LPFC_SOL_IOCB,		/* CMD_XMIT_BCAST64_CN     0x84 */
+	LPFC_SOL_IOCB,		/* CMD_XMIT_BCAST64_CX     0x85 */
+	LPFC_UNKNOWN_IOCB,	/* CMD_QUE_RING_BUF64_CN   0x86 */
+	LPFC_UNKNOWN_IOCB,	/* CMD_QUE_XRI_BUF64_CX    0x87 */
+	LPFC_UNKNOWN_IOCB,	/* CMD_IOCB_CONTINUE64_CN  0x88 */
+	LPFC_UNKNOWN_IOCB,	/* CMD_RET_XRI_BUF64_CX    0x89 */
+	LPFC_SOL_IOCB,		/* CMD_ELS_REQUEST64_CR    0x8A */
+	LPFC_SOL_IOCB,		/* CMD_ELS_REQUEST64_CX    0x8B */
+	LPFC_ABORT_IOCB,	/* CMD_ABORT_MXRI64_CN     0x8C */
+	LPFC_UNSOL_IOCB,	/* CMD_RCV_ELS_REQ64_CX    0x8D */
+	/* 0x8E - 0x94 */
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB,
+	LPFC_SOL_IOCB,		/* CMD_XMIT_ELS_RSP64_CX   0x95 */
+	LPFC_UNKNOWN_IOCB,	/* 0x96 */
+	LPFC_UNKNOWN_IOCB,	/* 0x97 */
+	LPFC_SOL_IOCB,		/* CMD_FCP_IWRITE64_CR     0x98 */
+	LPFC_SOL_IOCB,		/* CMD_FCP_IWRITE64_CX     0x99 */
+	LPFC_SOL_IOCB,		/* CMD_FCP_IREAD64_CR      0x9A */
+	LPFC_SOL_IOCB,		/* CMD_FCP_IREAD64_CX      0x9B */
+	LPFC_SOL_IOCB,		/* CMD_FCP_ICMND64_CR      0x9C */
+	LPFC_SOL_IOCB,		/* CMD_FCP_ICMND64_CX      0x9D */
+	LPFC_UNKNOWN_IOCB,	/* 0x9E */
+	LPFC_SOL_IOCB,		/* CMD_FCP_TSEND64_CX      0x9F */
+	LPFC_UNKNOWN_IOCB,	/* 0xA0 */
+	LPFC_SOL_IOCB,		/* CMD_FCP_TRECEIVE64_CX   0xA1 */
+	LPFC_UNKNOWN_IOCB,	/* 0xA2 */
+	LPFC_SOL_IOCB,		/* CMD_FCP_TRSP64_CX       0xA3 */
+	/* 0xA4 - 0xC1 */
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_SOL_IOCB,		/* CMD_GEN_REQUEST64_CR    0xC2 */
+	LPFC_SOL_IOCB,		/* CMD_GEN_REQUEST64_CX    0xC3 */
+	/* 0xC4 - 0xCF */
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+
+	LPFC_SOL_IOCB,
+	LPFC_SOL_IOCB,		/* CMD_SENDTEXT_CR              0xD1 */
+	LPFC_SOL_IOCB,		/* CMD_SENDTEXT_CX              0xD2 */
+	LPFC_SOL_IOCB,		/* CMD_RCV_LOGIN                0xD3 */
+	LPFC_SOL_IOCB,		/* CMD_ACCEPT_LOGIN             0xD4 */
+	LPFC_SOL_IOCB,		/* CMD_REJECT_LOGIN             0xD5 */
+	LPFC_UNSOL_IOCB,
+	/* 0xD7 - 0xDF */
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB, LPFC_UNKNOWN_IOCB,
+	/* 0xE0 */
+	LPFC_UNSOL_IOCB,
+	LPFC_SOL_IOCB,
+	LPFC_SOL_IOCB,
+	LPFC_SOL_IOCB,
+	LPFC_SOL_IOCB,
+	LPFC_UNSOL_IOCB
+};
+
+int
+lpfc_sli_hba_setup(lpfcHBA_t * phba)
+{
+	LPFC_SLI_t *psli;
+	LPFC_MBOXQ_t *pmb;
+	int read_rev_reset, i, rc;
+	uint32_t status;
+	unsigned long iflag;
+
+	psli = &phba->sli;
+
+	/* Setep SLI interface for HBA register and HBA SLIM access */
+	lpfc_setup_slim_access(phba);
+
+	/* Set board state to initialization started */
+	phba->hba_state = LPFC_INIT_START;
+	read_rev_reset = 0;
+
+	iflag = phba->iflag;
+	LPFC_DRVR_UNLOCK(phba, iflag);
+
+	/* On some platforms/OS's, the driver can't rely on the state the
+	 * adapter may be in.  For this reason, the driver is allowed to reset
+	 * the HBA before initialization.
+	 */
+	if (lpfc_sli_reset_on_init) {
+		phba->hba_state = 0;	/* Don't skip post */
+		lpfc_sli_brdreset(phba);
+		phba->hba_state = LPFC_INIT_START;
+		lpfc_sleep_ms(phba, 2500);
+	}
+
+      top:
+	/* Read the HBA Host Status Register */
+	status = readl(phba->HSregaddr);
+
+	i = 0;			/* counts number of times thru while loop */
+
+	/* Check status register to see what current state is */
+	while ((status & (HS_FFRDY | HS_MBRDY)) != (HS_FFRDY | HS_MBRDY)) {
+
+		/* Check every 100ms for 5 retries, then every 500ms for 5, then
+		 * every 2.5 sec for 5, then reset board and every 2.5 sec for
+		 * 4.
+		 */
+		if (i++ >= 20) {
+			/* Adapter failed to init, timeout, status reg
+			   <status> */
+			lpfc_printf_log(phba->brd_no,
+				&lpfc_msgBlk0436,
+				lpfc_mes0436,
+				lpfc_msgBlk0436.msgPreambleStr,
+				status);
+			phba->hba_state = LPFC_HBA_ERROR;
+			LPFC_DRVR_LOCK(phba, iflag);
+			return (ETIMEDOUT);
+		}
+
+		/* Check to see if any errors occurred during init */
+		if (status & HS_FFERM) {
+			/* ERROR: During chipset initialization */
+			/* Adapter failed to init, chipset, status reg
+			   <status> */
+			lpfc_printf_log(phba->brd_no,
+				&lpfc_msgBlk0437,
+				lpfc_mes0437,
+				lpfc_msgBlk0437.msgPreambleStr,
+				status);
+			phba->hba_state = LPFC_HBA_ERROR;
+			LPFC_DRVR_LOCK(phba, iflag);
+			return (EIO);
+		}
+
+		if (i <= 5) {
+			lpfc_sleep_ms(phba, 100);
+		} else if (i <= 10) {
+			lpfc_sleep_ms(phba, 500);
+		} else {
+			lpfc_sleep_ms(phba, 2500);
+		}
+
+		if (i == 15) {
+			phba->hba_state = 0;	/* Don't skip post */
+			lpfc_sli_brdreset(phba);
+			phba->hba_state = LPFC_INIT_START;
+		}
+		/* Read the HBA Host Status Register */
+		status = readl(phba->HSregaddr);
+	}
+
+	/* Check to see if any errors occurred during init */
+	if (status & HS_FFERM) {
+		/* ERROR: During chipset initialization */
+		/* Adapter failed to init, chipset, status reg <status> */
+		lpfc_printf_log(phba->brd_no,
+			&lpfc_msgBlk0438,
+			lpfc_mes0438,
+			lpfc_msgBlk0438.msgPreambleStr,
+			status);
+		phba->hba_state = LPFC_HBA_ERROR;
+		LPFC_DRVR_LOCK(phba, iflag);
+		return (EIO);
+	}
+
+	/* Clear all interrupt enable conditions */
+	writel(0, phba->HCregaddr);
+	readl(phba->HCregaddr); /* flush */
+
+	/* setup host attn register */
+	writel(0xffffffff, phba->HAregaddr);
+	readl(phba->HAregaddr); /* flush */
+
+	/* Get a Mailbox buffer to setup mailbox commands for HBA
+	   initialization */
+	if ((pmb = (LPFC_MBOXQ_t *) lpfc_mbox_alloc(phba, MEM_PRI)) == 0) {
+		phba->hba_state = LPFC_HBA_ERROR;
+		LPFC_DRVR_LOCK(phba, iflag);
+		return (ENOMEM);
+	}
+
+	/* Call pre CONFIG_PORT mailbox command initialization.  A value of 0
+	 * means the call was successful.  Any other nonzero value is a failure,
+	 * but if ERESTART is returned, the driver may reset the HBA and try
+	 * again.
+	 */
+	if ((rc = lpfc_config_port_prep(phba))) {
+		if ((rc == ERESTART) && (read_rev_reset == 0)) {
+			lpfc_mbox_free(phba, pmb);
+			phba->hba_state = 0;	/* Don't skip post */
+			lpfc_sli_brdreset(phba);
+			phba->hba_state = LPFC_INIT_START;
+			lpfc_sleep_ms(phba, 500);
+			read_rev_reset = 1;
+			goto top;
+		}
+		phba->hba_state = LPFC_HBA_ERROR;
+		lpfc_mbox_free(phba, pmb);
+		LPFC_DRVR_LOCK(phba, iflag);
+		return (ENXIO);
+	}
+
+	/* Setup and issue mailbox CONFIG_PORT command */
+	phba->hba_state = LPFC_INIT_MBX_CMDS;
+	lpfc_config_port(phba, pmb);
+	if (lpfc_sli_issue_mbox(phba, pmb, MBX_POLL) != MBX_SUCCESS) {
+		/* Adapter failed to init, mbxCmd <cmd> CONFIG_PORT,
+		   mbxStatus <status> */
+		lpfc_printf_log(phba->brd_no,
+			&lpfc_msgBlk0442,
+			lpfc_mes0442,
+			lpfc_msgBlk0442.msgPreambleStr,
+			pmb->mb.mbxCommand,
+			pmb->mb.mbxStatus,
+			0);
+
+		/* This clause gives the config_port call is given multiple
+		   chances to succeed. */
+		if (read_rev_reset == 0) {
+			lpfc_mbox_free(phba, pmb);
+			phba->hba_state = 0;	/* Don't skip post */
+			lpfc_sli_brdreset(phba);
+			phba->hba_state = LPFC_INIT_START;
+			lpfc_sleep_ms(phba, 2500);
+			read_rev_reset = 1;
+			goto top;
+		}
+
+		psli->sliinit.sli_flag &= ~LPFC_SLI2_ACTIVE;
+		phba->hba_state = LPFC_HBA_ERROR;
+		lpfc_mbox_free(phba, pmb);
+		LPFC_DRVR_LOCK(phba, iflag);
+		return (ENXIO);
+	}
+
+	if ((rc = lpfc_sli_ring_map(phba))) {
+		phba->hba_state = LPFC_HBA_ERROR;
+		lpfc_mbox_free(phba, pmb);
+		LPFC_DRVR_LOCK(phba, iflag);
+		return (ENXIO);
+	}
+	psli->sliinit.sli_flag |= LPFC_PROCESS_LA;
+
+	/* Call post CONFIG_PORT mailbox command initialization. */
+	if ((rc = lpfc_config_port_post(phba))) {
+		phba->hba_state = LPFC_HBA_ERROR;
+		lpfc_mbox_free(phba, pmb);
+		LPFC_DRVR_LOCK(phba, iflag);
+		return (ENXIO);
+	}
+	lpfc_mbox_free(phba, pmb);
+	LPFC_DRVR_LOCK(phba, iflag);
+	return (0);
+}
+
+int
+lpfc_sli_ring_map(lpfcHBA_t * phba)
+{
+	LPFC_SLI_t *psli;
+	LPFC_MBOXQ_t *pmb;
+	MAILBOX_t *pmbox;
+	int i;
+
+	psli = &phba->sli;
+
+	/* Get a Mailbox buffer to setup mailbox commands for HBA
+	   initialization */
+	if ((pmb = (LPFC_MBOXQ_t *) lpfc_mbox_alloc(phba, MEM_PRI)) == 0) {
+		phba->hba_state = LPFC_HBA_ERROR;
+		return (ENOMEM);
+	}
+	pmbox = &pmb->mb;
+
+	/* Initialize the LPFC_SLI_RING_t structure for each ring */
+	for (i = 0; i < psli->sliinit.num_rings; i++) {
+		/* Issue a CONFIG_RING mailbox command for each ring */
+		phba->hba_state = LPFC_INIT_MBX_CMDS;
+		lpfc_config_ring(phba, i, pmb);
+		if (lpfc_sli_issue_mbox(phba, pmb, MBX_POLL) != MBX_SUCCESS) {
+			/* Adapter failed to init, mbxCmd <cmd> CFG_RING,
+			   mbxStatus <status>, ring <num> */
+			lpfc_printf_log(phba->brd_no,
+				&lpfc_msgBlk0446,
+				lpfc_mes0446,
+				lpfc_msgBlk0446.msgPreambleStr,
+				pmbox->mbxCommand,
+				pmbox->mbxStatus,
+				i);
+			phba->hba_state = LPFC_HBA_ERROR;
+			lpfc_mbox_free(phba, pmb);
+			return (ENXIO);
+		}
+	}
+	lpfc_mbox_free(phba, pmb);
+	return (0);
+}
+
+int
+lpfc_sli_intr(lpfcHBA_t * phba)
+{
+	LPFC_SLI_t *psli;
+	LPFC_SLI_RING_t *pring;
+	uint32_t ha_copy, status;
+	int i;
+
+	psli = &phba->sli;
+	psli->slistat.sliIntr++;
+	ha_copy = lpfc_intr_prep(phba);
+
+	if (!ha_copy) {
+
+		/*
+		 * Don't claim that interrupt
+		 */
+		return (1);
+	}
+
+	if (ha_copy & HA_ERATT) {	/* Link / board error */
+		psli->slistat.errAttnEvent++;
+		/* do what needs to be done, get error from STATUS REGISTER */
+		status = readl(phba->HSregaddr);
+
+		/* Clear Chip error bit */
+		writel(HA_ERATT, phba->HAregaddr);
+		readl(phba->HAregaddr); /* flush */
+		phba->stopped = 1;
+		/* Process the Error Attention */
+		lpfc_handle_eratt(phba, status);
+		return (0);
+	}
+
+	if (ha_copy & HA_MBATT) {	/* Mailbox interrupt */
+		lpfc_sli_handle_mb_event(phba);
+	}
+
+	if (ha_copy & HA_LATT) {	/* Link Attention interrupt */
+		/* Process the Link Attention */
+		if (psli->sliinit.sli_flag & LPFC_PROCESS_LA) {
+			lpfc_handle_latt(phba);
+		}
+	}
+
+	/* Now process each ring */
+	for (i = 0; i < psli->sliinit.num_rings; i++) {
+		pring = &psli->ring[i];
+		if ((ha_copy & HA_RXATT)
+		    || (pring->flag & LPFC_DEFERRED_RING_EVENT)) {
+			if (pring->flag & LPFC_STOP_IOCB_MASK) {
+				pring->flag |= LPFC_DEFERRED_RING_EVENT;
+			} else {
+				lpfc_sli_handle_ring_event(phba, pring,
+							   (ha_copy &
+							    HA_RXMASK));
+				pring->flag &= ~LPFC_DEFERRED_RING_EVENT;
+			}
+		}
+		ha_copy = (ha_copy >> 4);
+	}
+
+	return (0);
+}
+
+int
+lpfc_sli_chk_mbx_command(uint8_t mbxCommand)
+{
+	uint8_t ret;
+
+	switch (mbxCommand) {
+	case MBX_LOAD_SM:
+	case MBX_READ_NV:
+	case MBX_WRITE_NV:
+	case MBX_RUN_BIU_DIAG:
+	case MBX_INIT_LINK:
+	case MBX_DOWN_LINK:
+	case MBX_CONFIG_LINK:
+	case MBX_CONFIG_RING:
+	case MBX_RESET_RING:
+	case MBX_READ_CONFIG:
+	case MBX_READ_RCONFIG:
+	case MBX_READ_SPARM:
+	case MBX_READ_STATUS:
+	case MBX_READ_RPI:
+	case MBX_READ_XRI:
+	case MBX_READ_REV:
+	case MBX_READ_LNK_STAT:
+	case MBX_REG_LOGIN:
+	case MBX_UNREG_LOGIN:
+	case MBX_READ_LA:
+	case MBX_CLEAR_LA:
+	case MBX_DUMP_MEMORY:
+	case MBX_DUMP_CONTEXT:
+	case MBX_RUN_DIAGS:
+	case MBX_RESTART:
+	case MBX_UPDATE_CFG:
+	case MBX_DOWN_LOAD:
+	case MBX_DEL_LD_ENTRY:
+	case MBX_RUN_PROGRAM:
+	case MBX_SET_MASK:
+	case MBX_SET_SLIM:
+	case MBX_UNREG_D_ID:
+	case MBX_CONFIG_FARP:
+	case MBX_LOAD_AREA:
+	case MBX_RUN_BIU_DIAG64:
+	case MBX_CONFIG_PORT:
+	case MBX_READ_SPARM64:
+	case MBX_READ_RPI64:
+	case MBX_REG_LOGIN64:
+	case MBX_READ_LA64:
+	case MBX_FLASH_WR_ULA:
+	case MBX_SET_DEBUG:
+	case MBX_LOAD_EXP_ROM:
+		ret = mbxCommand;
+		break;
+	default:
+		ret = MBX_SHUTDOWN;
+		break;
+	}
+	return (ret);
+}
+
+
+/* lpfc_sli_turn_on_ring is only called by lpfc_sli_handle_mb_event below */
+static void
+lpfc_sli_turn_on_ring(lpfcHBA_t * phba, int ringno)
+{
+	LPFC_SLI_t *psli;
+	LPFC_SLI_RING_t *pring;
+	PGP *pgp;
+	uint32_t status;
+	uint32_t portCmdGet, portGetIndex;
+
+
+	psli = &phba->sli;
+	pring = &psli->ring[ringno];
+	pgp = (PGP *) & (((MAILBOX_t *)psli->MBhostaddr)->us.s2.port[ringno]);
+
+	/* If the ring is active, flag it */
+	if (psli->ring[ringno].cmdringaddr) {
+		if (psli->ring[ringno].flag & LPFC_STOP_IOCB_MBX) {
+			psli->ring[ringno].flag &= ~LPFC_STOP_IOCB_MBX;
+			portGetIndex = lpfc_sli_resume_iocb(phba, pring);
+			/* Make sure the host slim pointers are up-to-date
+			 * before continuing.  An update is NOT guaranteed on
+			 * the first read.
+			 */
+			status = pgp->cmdGetInx;
+			portCmdGet = le32_to_cpu(status);
+			if (portGetIndex != portCmdGet) {
+				lpfc_sli_resume_iocb(phba, pring);
+			}
+			/* If this is the FCP ring, the scheduler needs to be
+			   restarted. */
+			if (pring->ringno == psli->fcp_ring) {
+				lpfc_sched_check(phba);
+			}
+		}
+	}
+}
+
+int
+lpfc_sli_handle_mb_event(lpfcHBA_t * phba)
+{
+	MAILBOX_t *mbox;
+	MAILBOX_t *pmbox;
+	LPFC_MBOXQ_t *pmb;
+	DMABUF_t   *mp;
+	LPFC_SLI_t *psli;
+	int i;
+	uint32_t process_next;
+
+
+	psli = &phba->sli;
+	/* We should only get here if we are in SLI2 mode */
+	if (!(psli->sliinit.sli_flag & LPFC_SLI2_ACTIVE)) {
+		return (1);
+	}
+
+	psli->slistat.mboxEvent++;
+
+	/* Get a Mailbox buffer to setup mailbox commands for callback */
+	if ((pmb = psli->mbox_active)) {
+		pmbox = &pmb->mb;
+		mbox = (MAILBOX_t *) psli->MBhostaddr;
+
+		/* First check out the status word */
+		lpfc_sli_pcimem_bcopy((uint32_t *) mbox, (uint32_t *) pmbox,
+				     sizeof (uint32_t));
+
+		/* Sanity check to ensure the host owns the mailbox */
+		if (pmbox->mbxOwner != OWN_HOST) {
+			/* Lets try for a while */
+			for (i = 0; i < 10240; i++) {
+				/* First copy command data */
+				lpfc_sli_pcimem_bcopy((uint32_t *) mbox,
+						     (uint32_t *) pmbox,
+						     sizeof (uint32_t));
+				if (pmbox->mbxOwner == OWN_HOST)
+					goto mbout;
+			}
+			/* Stray Mailbox Interrupt, mbxCommand <cmd> mbxStatus
+			   <status> */
+			lpfc_printf_log(phba->brd_no,
+				&lpfc_msgBlk0304,
+				lpfc_mes0304,
+				lpfc_msgBlk0304.msgPreambleStr,
+				pmbox->mbxCommand,
+				pmbox->mbxStatus);
+
+			psli->sliinit.sli_flag |= LPFC_SLI_MBOX_ACTIVE;
+			return (1);
+		}
+
+	      mbout:
+		if (psli->mbox_tmo.function) {
+			lpfc_stop_timer((struct clk_data *)psli->mbox_tmo.data);
+		}
+
+		/*
+		 * It is a fatal error if unknown mbox command completion.
+		 */
+		if (lpfc_sli_chk_mbx_command(pmbox->mbxCommand) == 
+		    MBX_SHUTDOWN) {
+
+			/* Unknow mailbox command compl */
+			lpfc_printf_log(phba->brd_no,
+				&lpfc_msgBlk0323,
+				lpfc_mes0323,
+				lpfc_msgBlk0323.msgPreambleStr,
+				pmbox->mbxCommand);
+			phba->hba_state = LPFC_HBA_ERROR;
+			phba->hba_flag |= FC_STOP_IO;
+			lpfc_handle_eratt(phba, HS_FFER3);
+			return (0);
+		}
+
+		psli->mbox_active = 0;
+		if (pmbox->mbxStatus) {
+			psli->slistat.mboxStatErr++;
+			if (pmbox->mbxStatus == MBXERR_NO_RESOURCES) {
+				/* Mbox cmd cmpl error - RETRYing */
+				lpfc_printf_log(phba->brd_no,
+					&lpfc_msgBlk0305,
+					lpfc_mes0305,
+					lpfc_msgBlk0305.msgPreambleStr,
+					pmbox->mbxCommand,
+					pmbox->mbxStatus,
+					pmbox->un.varWords[0],
+					phba->hba_state);
+				pmbox->mbxStatus = 0;
+				pmbox->mbxOwner = OWN_HOST;
+				psli->sliinit.sli_flag &= ~LPFC_SLI_MBOX_ACTIVE;
+				if (lpfc_sli_issue_mbox(phba, pmb, MBX_NOWAIT)
+				    == MBX_SUCCESS) {
+					return (0);
+				}
+			}
+		}
+
+		/* Mailbox cmd <cmd> Cmpl <cmpl> */
+		lpfc_printf_log(phba->brd_no,
+			&lpfc_msgBlk0307,	
+			lpfc_mes0307,
+			lpfc_msgBlk0307.msgPreambleStr,
+			pmbox->mbxCommand,
+			pmb->mbox_cmpl,
+			*((uint32_t *) pmbox),
+			pmbox->un.varWords[0],
+			pmbox->un.varWords[1],
+			pmbox->un.varWords[2],
+			pmbox->un.varWords[3],
+			pmbox->un.varWords[4],
+			pmbox->un.varWords[5],
+			pmbox->un.varWords[6],
+			pmbox->un.varWords[7]);
+
+
+		if (pmb->mbox_cmpl) {
+			/* Copy entire mbox completion over buffer */
+			lpfc_sli_pcimem_bcopy((uint32_t *) mbox,
+					     (uint32_t *) pmbox,
+					     (sizeof (uint32_t) *
+					      (MAILBOX_CMD_WSIZE)));
+			/* All mbox cmpls are posted to discovery tasklet */
+			lpfc_discq_post_event(phba, (void *)pmb, 0,
+				LPFC_EVT_MBOX);
+		} else {
+			mp = (DMABUF_t *) (pmb->context1);
+			if(mp) {
+				lpfc_mbuf_free(phba, mp->virt, mp->phys);
+				kfree(mp);
+			}
+			lpfc_mbox_free(phba, pmb);
+		}
+	}
+
+
+	do {
+		process_next = 0;	/* by default don't loop */
+		psli->sliinit.sli_flag &= ~LPFC_SLI_MBOX_ACTIVE;
+
+		/* Process next mailbox command if there is one */
+		if ((pmb = lpfc_mbox_get(phba))) {
+			if (lpfc_sli_issue_mbox(phba, pmb, MBX_NOWAIT) ==
+			    MBX_NOT_FINISHED) {
+				mp = (DMABUF_t *) (pmb->context1);
+				if(mp) {
+					lpfc_mbuf_free(phba, mp->virt,
+						mp->phys);
+					kfree(mp);
+				}
+				lpfc_mbox_free(phba, pmb);
+				process_next = 1;
+				continue;	/* loop back */
+			}
+		} else {
+			/* Turn on IOCB processing */
+			for (i = 0; i < psli->sliinit.num_rings; i++) {
+				lpfc_sli_turn_on_ring(phba, i);
+			}
+		}
+	} while (process_next);
+
+
+	return (0);
+}
+
+int
+lpfc_sli_handle_ring_event(lpfcHBA_t * phba,
+			   LPFC_SLI_RING_t * pring, uint32_t mask)
+{
+	LPFC_SLI_t       * psli;
+	IOCB_t           * entry;
+	IOCB_t           * irsp;
+	LPFC_IOCBQ_t     * rspiocbp;
+	LPFC_IOCBQ_t     * cmdiocbp;
+	LPFC_IOCBQ_t     * saveq;
+	HGP              * hgp;
+	PGP              * pgp;
+	MAILBOX_t        * mbox;
+	struct list_head * curr, * next;
+	uint32_t           status, free_saveq;
+	uint32_t           portRspPut, portRspMax;
+	uint32_t           portCmdGet, portGetIndex;
+	int                ringno, loopcnt, rc;
+	uint8_t            type;
+	void *to_slim;
+
+	psli = &phba->sli;
+	ringno = pring->ringno;
+	psli->slistat.iocbEvent[ringno]++;
+	irsp = 0;
+	rc = 1;
+
+	/* At this point we assume SLI-2 */
+	mbox = (MAILBOX_t *) psli->MBhostaddr;
+	pgp = (PGP *) & mbox->us.s2.port[ringno];
+	hgp = (HGP *) & mbox->us.s2.host[ringno];
+
+	/* portRspMax is the number of rsp ring entries for this specific
+	   ring. */
+	portRspMax = psli->sliinit.ringinit[ringno].numRiocb;
+
+	rspiocbp = 0;
+	loopcnt = 0;
+
+	/* Gather iocb entries off response ring.
+	 * rspidx is the IOCB index of the next IOCB that the driver
+	 * is going to process.
+	 */
+	entry = IOCB_ENTRY(pring->rspringaddr, pring->rspidx);
+	status = pgp->rspPutInx;
+	portRspPut = le32_to_cpu(status);
+
+	if (portRspPut >= portRspMax) {
+
+		/* Ring <ringno> handler: portRspPut <portRspPut> is bigger then
+		   rsp ring <portRspMax> */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0312,
+				lpfc_mes0312,
+				lpfc_msgBlk0312.msgPreambleStr,
+				ringno, portRspPut, portRspMax);
+		/*
+		 * Treat it as adapter hardware error.
+		 */
+		phba->hba_state = LPFC_HBA_ERROR;
+		phba->hba_flag |= FC_STOP_IO;
+		lpfc_handle_eratt(phba, HS_FFER3);
+		return (1);
+	}
+	
+	rmb();
+
+	/* Get the next available response iocb.
+	 * rspidx is the IOCB index of the next IOCB that the driver
+	 * is going to process.
+	 */
+	while (pring->rspidx != portRspPut) {
+		/* get an iocb buffer to copy entry into */
+		if ((rspiocbp = lpfc_iocb_alloc(phba, MEM_PRI)) == 0) {
+			break;
+		}
+
+		lpfc_sli_pcimem_bcopy((uint32_t *) entry,
+				      (uint32_t *) & rspiocbp->iocb,
+				      sizeof (IOCB_t));
+		wmb();
+		irsp = &rspiocbp->iocb;
+
+		/* bump iocb available response index */
+		if (++pring->rspidx >= portRspMax) {
+			pring->rspidx = 0;
+		}
+
+		/* Let the HBA know what IOCB slot will be the next one the
+		 * driver will read a response from.
+		 */
+               
+
+		status = (uint32_t) pring->rspidx;
+		to_slim = (uint8_t *) phba->MBslimaddr +
+		    (SLIMOFF + (ringno * 2) + 1) * 4;
+		writel(status, to_slim);
+		readl(to_slim); /* flush */
+	
+
+		/* chain all iocb entries until LE is set */
+		if (list_empty(&(pring->iocb_continueq))) {
+			list_add(&rspiocbp->list, &(pring->iocb_continueq));
+		} else {
+			list_add_tail(&rspiocbp->list,
+				      &(pring->iocb_continueq));
+		}
+		pring->iocb_continueq_cnt++;
+
+		/* when LE is set, entire Command has been received */
+		if (irsp->ulpLe) {
+			/* get a ptr to first iocb entry in chain and process
+			   it */
+			free_saveq = 1;
+			saveq = list_entry(pring->iocb_continueq.next,
+					   LPFC_IOCBQ_t, list);
+			irsp = &(saveq->iocb);
+			list_del_init(&pring->iocb_continueq);
+			pring->iocb_continueq_cnt = 0;
+
+			psli->slistat.iocbRsp[ringno]++;
+
+			if (irsp->ulpStatus) {
+				/* Rsp ring <ringno> error: IOCB Data: */
+				lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0325,
+						lpfc_mes0325,
+						lpfc_msgBlk0325.msgPreambleStr,
+						ringno,
+						irsp->un.ulpWord[0],
+						irsp->un.ulpWord[1],
+						irsp->un.ulpWord[2],
+						irsp->un.ulpWord[3],
+						irsp->un.ulpWord[4],
+						irsp->un.ulpWord[5],
+						*(((uint32_t *) irsp) + 6),
+						*(((uint32_t *) irsp) + 7));
+			}
+
+			/* Determine if IOCB command is a solicited or
+			   unsolicited event */
+			type =
+			    lpfc_sli_iocb_cmd_type[(irsp->
+						    ulpCommand &
+						    CMD_IOCB_MASK)];
+			if (type == LPFC_SOL_IOCB) {
+				rc = lpfc_sli_process_sol_iocb(phba, pring,
+					saveq);
+				if (pring->ringno == LPFC_ELS_RING)
+					free_saveq = 0;
+				else
+					free_saveq = 1;
+			} else if (type == LPFC_UNSOL_IOCB) {
+				rc = lpfc_sli_process_unsol_iocb(phba, pring,
+					saveq);
+				if (pring->ringno == LPFC_ELS_RING)
+					free_saveq = 0;
+				else
+					free_saveq = 1;
+
+			} else if (type == LPFC_ABORT_IOCB) {
+				/* Solicited ABORT Responses */
+				/* Based on the iotag field, get the cmd IOCB
+				   from the txcmplq */
+				if ((irsp->ulpCommand == CMD_ABORT_MXRI64_CN) &&
+				    ((cmdiocbp =
+				      lpfc_sli_ringtxcmpl_get(phba, pring,
+							      saveq, 0)))) {
+					/* Call the specified completion
+					   routine */
+					if (cmdiocbp->iocb_cmpl) {
+						(cmdiocbp->iocb_cmpl) (phba,
+							     cmdiocbp, saveq);
+					} else {
+						lpfc_iocb_free(phba, cmdiocbp);
+					}
+				}
+			} else if (type == LPFC_UNKNOWN_IOCB) {
+				if (irsp->ulpCommand == CMD_ADAPTER_MSG) {
+
+					char adaptermsg[LPFC_MAX_ADPTMSG];
+
+					memset(adaptermsg, 0,
+					       LPFC_MAX_ADPTMSG);
+					memcpy(&adaptermsg[0], (uint8_t *) irsp,
+					       MAX_MSG_DATA);
+					printk("lpfc%d: %s", phba->brd_no,
+					       adaptermsg);
+				} else {
+					/* Unknown IOCB command */
+					lpfc_printf_log(phba->brd_no,
+						&lpfc_msgBlk0321,
+						lpfc_mes0321,
+						lpfc_msgBlk0321.msgPreambleStr,
+						irsp->ulpCommand,
+						irsp->ulpStatus,
+						irsp->ulpIoTag,
+						irsp->ulpContext);
+				}
+			}
+
+			if(free_saveq) {
+				/* Free up iocb buffer chain for command just
+			   	processed */
+
+				if (!list_empty(&pring->iocb_continueq)) {
+					list_for_each_safe(curr, next,
+						   &pring->iocb_continueq) {
+					rspiocbp =
+					   list_entry(curr, LPFC_IOCBQ_t, list);
+						list_del_init(&rspiocbp->list);
+					lpfc_iocb_free(phba, rspiocbp);
+				}
+				}
+				lpfc_iocb_free(phba, saveq);
+			}
+		}
+
+		/* Entire Command has been received */
+		entry = IOCB_ENTRY(pring->rspringaddr, pring->rspidx);
+
+		/* If the port response put pointer has not been updated, sync
+		 * the pgp->rspPutInx in the MAILBOX_tand fetch the new port
+		 * response put pointer.
+		 */
+		if (pring->rspidx == portRspPut) {
+			status = pgp->rspPutInx;
+			portRspPut = le32_to_cpu(status);
+		}
+	}			/* while (pring->rspidx != portRspPut) */
+
+	if ((rspiocbp != 0) && (mask & HA_R0RE_REQ)) {
+		/* At least one response entry has been freed */
+		psli->slistat.iocbRspFull[ringno]++;
+		/* SET RxRE_RSP in Chip Att register */
+		status = ((CA_R0ATT | CA_R0RE_RSP) << (ringno * 4));
+		wmb();
+		writel(status, phba->CAregaddr);
+		readl(phba->CAregaddr); /* flush */
+	}
+	if ((mask & HA_R0CE_RSP) && (pring->flag & LPFC_CALL_RING_AVAILABLE)) {
+		pring->flag &= ~LPFC_CALL_RING_AVAILABLE;
+		psli->slistat.iocbCmdEmpty[ringno]++;
+		portGetIndex = lpfc_sli_resume_iocb(phba, pring);
+
+		/* Read the new portGetIndex value twice to ensure it was
+		   updated correctly. */
+		status = pgp->cmdGetInx;
+		portCmdGet = le32_to_cpu(status);
+		if (portGetIndex != portCmdGet) {
+			lpfc_sli_resume_iocb(phba, pring);
+		}
+		if ((psli->sliinit.ringinit[ringno].lpfc_sli_cmd_available))
+			(psli->sliinit.ringinit[ringno].
+			 lpfc_sli_cmd_available) (phba, pring);
+
+		/* Restart the scheduler on the FCP ring. */
+		if (pring->ringno == psli->fcp_ring) {
+			lpfc_sched_check(phba);
+		}
+	}
+	return (rc);
+}
+
+int
+lpfc_sli_process_sol_iocb(lpfcHBA_t * phba,
+			   LPFC_SLI_RING_t * pring, LPFC_IOCBQ_t *saveq)
+{
+	LPFC_IOCBQ_t * cmdiocbp;
+	int            ringno, rc;
+
+	rc = 1;
+	ringno = pring->ringno;
+	/* Solicited Responses */
+	/* Based on the iotag field, get the cmd IOCB
+	   from the txcmplq */
+	if ((cmdiocbp =
+	     lpfc_sli_ringtxcmpl_get(phba, pring, saveq,
+				     0))) {
+		/* Call the specified completion
+		   routine */
+		if (cmdiocbp->iocb_cmpl) {
+			/* All iocb cmpls for LPFC_ELS_RING 
+			 * are posted to discovery tasklet.
+			 */
+			if(ringno == LPFC_ELS_RING) {
+				lpfc_discq_post_event(phba, (void *)cmdiocbp,
+					(void *)saveq,  LPFC_EVT_SOL_IOCB);
+			}
+			else {
+				if (cmdiocbp->iocb_flag & LPFC_IO_POLL) {
+					rc = 0;
+				}
+				(cmdiocbp->iocb_cmpl) (phba, cmdiocbp, saveq);
+			}
+		} else {
+			lpfc_iocb_free(phba, cmdiocbp);
+		}
+	} else {
+		/* Could not find the initiating command
+		 * based of the response iotag.
+		 */
+		/* Ring <ringno> handler: unexpected
+		   completion IoTag <IoTag> */
+		lpfc_printf_log(phba->brd_no,
+			&lpfc_msgBlk0322,
+			lpfc_mes0322,
+			lpfc_msgBlk0322.msgPreambleStr,
+			ringno,
+			saveq->iocb.ulpIoTag,
+			saveq->iocb.ulpStatus,
+			saveq->iocb.un.ulpWord[4],
+			saveq->iocb.ulpCommand,
+			saveq->iocb.ulpContext);
+	}
+	return(rc);
+}
+
+int
+lpfc_sli_process_unsol_iocb(lpfcHBA_t * phba,
+			   LPFC_SLI_RING_t * pring, LPFC_IOCBQ_t *saveq)
+{
+	LPFC_SLI_t       * psli;
+	IOCB_t           * irsp;
+	LPFC_RING_INIT_t * pringinit;
+	WORD5            * w5p;
+	uint32_t           Rctl, Type;
+	uint32_t           match, ringno, i;
+
+	psli = &phba->sli;
+	match = 0;
+	ringno = pring->ringno;
+	irsp = &(saveq->iocb);
+	if ((irsp->ulpCommand == CMD_RCV_ELS_REQ64_CX)
+	    || (irsp->ulpCommand == CMD_RCV_ELS_REQ_CX)) {
+		Rctl = FC_ELS_REQ;
+		Type = FC_ELS_DATA;
+	} else {
+		w5p =
+		    (WORD5 *) & (saveq->iocb.un.
+				 ulpWord[5]);
+		Rctl = w5p->hcsw.Rctl;
+		Type = w5p->hcsw.Type;
+	}
+	/* unSolicited Responses */
+	pringinit = &psli->sliinit.ringinit[ringno];
+	if (pringinit->prt[0].profile) {
+		/* If this ring has a profile set, just
+		   send it to prt[0] */
+		/* All unsol iocbs for LPFC_ELS_RING 
+		 * are posted to discovery tasklet.
+		 */
+		if(ringno == LPFC_ELS_RING) {
+			lpfc_discq_post_event(phba, (void *)&pringinit->prt[0],
+			(void *)saveq,  LPFC_EVT_UNSOL_IOCB);
+		}
+		else {
+			(pringinit->prt[0].
+		 	lpfc_sli_rcv_unsol_event) (phba, pring, saveq);
+		}
+		match = 1;
+	} else {
+		/* We must search, based on rctl / type
+		   for the right routine */
+		for (i = 0; i < pringinit->num_mask;
+		     i++) {
+			if ((pringinit->prt[i].rctl ==
+			     Rctl)
+			    && (pringinit->prt[i].
+				type == Type)) {
+				/* All unsol iocbs for LPFC_ELS_RING 
+				 * are posted to discovery tasklet.
+				 */
+				if(ringno == LPFC_ELS_RING) {
+					lpfc_discq_post_event(phba,
+					(void *)&pringinit->prt[i],
+					(void *)saveq,  LPFC_EVT_UNSOL_IOCB);
+				}
+				else {
+					(pringinit->prt[i].
+				 	lpfc_sli_rcv_unsol_event)
+				    	(phba, pring, saveq);
+				}
+				match = 1;
+				break;
+			}
+		}
+	}
+	if (match == 0) {
+		/* Unexpected Rctl / Type received */
+		/* Ring <ringno> handler: unexpected
+		   Rctl <Rctl> Type <Type> received */
+		lpfc_printf_log(phba->brd_no,
+			&lpfc_msgBlk0313,
+			lpfc_mes0313,
+			lpfc_msgBlk0313.msgPreambleStr,
+			ringno,
+			Rctl,
+			Type);
+	}
+	return(1);
+}
+
+/*! lpfc_mbox_timeout
+ * 
+ * \pre
+ * \post
+ * \param hba Pointer to per lpfcHBA_t structure
+ * \param l1  Pointer to the driver's mailbox queue.
+ * \return 
+ *   void
+ *
+ * \b Description:
+ *
+ * This routine handles mailbox timeout events at timer interrupt context.
+ */
+void
+lpfc_mbox_timeout(unsigned long ptr)
+{
+	lpfcHBA_t *phba;
+	LPFC_SLI_t *psli;
+	LPFC_MBOXQ_t *pmbox;
+	MAILBOX_t *mb;
+	DMABUF_t * mp;
+	struct clk_data *clkData;
+	unsigned long iflag;
+
+	clkData = (struct clk_data *)ptr;
+	phba = clkData->phba;
+	LPFC_DRVR_LOCK(phba, iflag);
+       	if (clkData->flags & TM_CANCELED) {
+		list_del((struct list_head *)clkData);
+		kfree(clkData);	
+		goto out;
+	}
+
+	pmbox = (LPFC_MBOXQ_t *) clkData->clData1;
+	clkData->timeObj->function = 0;
+	list_del((struct list_head *)clkData);
+	kfree(clkData);
+
+	psli = &phba->sli;
+	mb = &pmbox->mb;
+
+	/* Mbox cmd <mbxCommand> timeout */
+	lpfc_printf_log(phba->brd_no,
+		&lpfc_msgBlk0310,
+		lpfc_mes0310,
+		lpfc_msgBlk0310.msgPreambleStr,
+		mb->mbxCommand,
+		phba->hba_state,
+		psli->sliinit.sli_flag,
+		psli->mbox_active);
+
+	if (psli->mbox_active == pmbox) {
+		psli->mbox_active = 0;
+		if (pmbox->mbox_cmpl) {
+			mb->mbxStatus = MBX_NOT_FINISHED;
+			(pmbox->mbox_cmpl) (phba, pmbox);
+		} else {
+			mp = (DMABUF_t *) (pmbox->context1);
+			if(mp) {
+				lpfc_mbuf_free(phba, mp->virt, mp->phys);
+				kfree(mp);
+			}
+			lpfc_mbox_free(phba, pmbox);
+		}
+		psli->sliinit.sli_flag &= ~LPFC_SLI_MBOX_ACTIVE;
+	}
+
+	lpfc_mbox_abort(phba);
+out:
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	return;
+}
+
+void
+lpfc_mbox_abort(lpfcHBA_t * phba)
+{
+	LPFC_SLI_t *psli;
+	LPFC_MBOXQ_t *pmbox;
+	DMABUF_t * mp;
+	MAILBOX_t *mb;
+
+	psli = &phba->sli;
+
+	if (psli->mbox_active) {
+		if (psli->mbox_tmo.function) {
+			lpfc_stop_timer((struct clk_data *)psli->mbox_tmo.data);
+		}
+		pmbox = psli->mbox_active;
+		mb = &pmbox->mb;
+		psli->mbox_active = 0;
+		if (pmbox->mbox_cmpl) {
+			mb->mbxStatus = MBX_NOT_FINISHED;
+			(pmbox->mbox_cmpl) (phba, pmbox);
+		} else {
+			mp = (DMABUF_t *) (pmbox->context1);
+			if(mp) {
+				lpfc_mbuf_free(phba, mp->virt, mp->phys);
+				kfree(mp);
+			}
+			lpfc_mbox_free(phba, pmbox);
+		}
+		psli->sliinit.sli_flag &= ~LPFC_SLI_MBOX_ACTIVE;
+	}
+
+	/* Abort all the non active mailbox commands. */
+	pmbox = lpfc_mbox_get(phba);
+	while (pmbox) {
+		mb = &pmbox->mb;
+		if (pmbox->mbox_cmpl) {
+			mb->mbxStatus = MBX_NOT_FINISHED;
+			(pmbox->mbox_cmpl) (phba, pmbox);
+		} else {
+			mp = (DMABUF_t *) (pmbox->context1);
+			if(mp) {
+				lpfc_mbuf_free(phba, mp->virt, mp->phys);
+				kfree(mp);
+			}
+			lpfc_mbox_free(phba, pmbox);
+		}
+		pmbox = lpfc_mbox_get(phba);
+	}
+	return;
+}
+
+int
+lpfc_sli_issue_mbox(lpfcHBA_t * phba, LPFC_MBOXQ_t * pmbox, uint32_t flag)
+{
+	MAILBOX_t *mbox;
+	MAILBOX_t *mb;
+	LPFC_SLI_t *psli;
+	uint32_t status, evtctr;
+	uint32_t ha_copy;
+	int i;
+	unsigned long drvr_flag;
+	volatile uint32_t word0, ldata;
+	void *to_slim;
+
+	psli = &phba->sli;
+	if (flag & MBX_POLL) {
+		LPFC_DRVR_LOCK(phba, drvr_flag);
+	}
+
+	mb = &pmbox->mb;
+	status = MBX_SUCCESS;
+
+	if (psli->sliinit.sli_flag & LPFC_SLI_MBOX_ACTIVE) {
+		/* Polling for a mbox command when another one is already active
+		 * is not allowed in SLI. Also, the driver must have established
+		 * SLI2 mode to queue and process multiple mbox commands.
+		 */
+
+		if (flag & MBX_POLL) {
+			LPFC_DRVR_UNLOCK(phba, drvr_flag);
+
+			/* Mbox command <mbxCommand> cannot issue */
+			LOG_MBOX_CANNOT_ISSUE_DATA( phba, mb, psli, flag)
+			return (MBX_NOT_FINISHED);
+		}
+
+		if (!(psli->sliinit.sli_flag & LPFC_SLI2_ACTIVE)) {
+
+			/* Mbox command <mbxCommand> cannot issue */
+			LOG_MBOX_CANNOT_ISSUE_DATA( phba, mb, psli, flag)
+			return (MBX_NOT_FINISHED);
+		}
+
+		/* Handle STOP IOCB processing flag. This is only meaningful
+		 * if we are not polling for mbox completion.
+		 */
+		if (flag & MBX_STOP_IOCB) {
+			flag &= ~MBX_STOP_IOCB;
+			/* Now flag each ring */
+			for (i = 0; i < psli->sliinit.num_rings; i++) {
+				/* If the ring is active, flag it */
+				if (psli->ring[i].cmdringaddr) {
+					psli->ring[i].flag |=
+					    LPFC_STOP_IOCB_MBX;
+				}
+			}
+		}
+
+		/* Another mailbox command is still being processed, queue this
+		 * command to be processed later.
+		 */
+		lpfc_mbox_put(phba, pmbox);
+
+		/* Mbox cmd issue - BUSY */
+		lpfc_printf_log(phba->brd_no,
+			&lpfc_msgBlk0308,
+			lpfc_mes0308,
+			lpfc_msgBlk0308.msgPreambleStr,
+			mb->mbxCommand,
+			phba->hba_state,
+			psli->sliinit.sli_flag,
+			flag);
+
+		psli->slistat.mboxBusy++;
+		if (flag == MBX_POLL) {
+			LPFC_DRVR_UNLOCK(phba, drvr_flag);
+		}
+		return (MBX_BUSY);
+	}
+
+	/* Handle STOP IOCB processing flag. This is only meaningful
+	 * if we are not polling for mbox completion.
+	 */
+	if (flag & MBX_STOP_IOCB) {
+		flag &= ~MBX_STOP_IOCB;
+		if (flag == MBX_NOWAIT) {
+			/* Now flag each ring */
+			for (i = 0; i < psli->sliinit.num_rings; i++) {
+				/* If the ring is active, flag it */
+				if (psli->ring[i].cmdringaddr) {
+					psli->ring[i].flag |=
+					    LPFC_STOP_IOCB_MBX;
+				}
+			}
+		}
+	}
+
+	psli->sliinit.sli_flag |= LPFC_SLI_MBOX_ACTIVE;
+
+	/* If we are not polling, we MUST be in SLI2 mode */
+	if (flag != MBX_POLL) {
+		if (!(psli->sliinit.sli_flag & LPFC_SLI2_ACTIVE)) {
+			psli->sliinit.sli_flag &= ~LPFC_SLI_MBOX_ACTIVE;
+
+			/* Mbox command <mbxCommand> cannot issue */
+			LOG_MBOX_CANNOT_ISSUE_DATA( phba, mb, psli, flag);
+			return (MBX_NOT_FINISHED);
+		}
+		/* timeout active mbox command */
+		if (psli->mbox_tmo.function) {
+			mod_timer(&psli->mbox_tmo, LPFC_MBOX_TMO);
+		} else {
+			lpfc_start_timer(phba, LPFC_MBOX_TMO, &psli->mbox_tmo,
+					 lpfc_mbox_timeout,
+					 (unsigned long)pmbox,
+					 (unsigned long)0);
+		}
+	}
+
+	/* Mailbox cmd <cmd> issue */
+	lpfc_printf_log(phba->brd_no,
+		&lpfc_msgBlk0309,
+		lpfc_mes0309,
+		lpfc_msgBlk0309.msgPreambleStr,
+		mb->mbxCommand,
+		phba->hba_state,
+		psli->sliinit.sli_flag,
+		flag);
+
+	psli->slistat.mboxCmd++;
+	evtctr = psli->slistat.mboxEvent;
+
+	/* next set own bit for the adapter and copy over command word */
+	mb->mbxOwner = OWN_CHIP;
+
+	if (psli->sliinit.sli_flag & LPFC_SLI2_ACTIVE) {
+
+		/* First copy command data to host SLIM area */
+		mbox = (MAILBOX_t *) psli->MBhostaddr;
+		lpfc_sli_pcimem_bcopy((uint32_t *) mb, (uint32_t *) mbox,
+				      (sizeof (uint32_t) *
+				       (MAILBOX_CMD_WSIZE)));
+
+	} else {
+		if (mb->mbxCommand == MBX_CONFIG_PORT) {
+			/* copy command data into host mbox for cmpl */
+			mbox = (MAILBOX_t *) psli->MBhostaddr;
+			lpfc_sli_pcimem_bcopy((uint32_t *) mb,
+					      (uint32_t *) mbox,
+					      (sizeof (uint32_t) *
+					       (MAILBOX_CMD_WSIZE)));
+		}
+
+		/* First copy mbox command data to HBA SLIM, skip past first
+		   word */
+		to_slim = (uint8_t *) phba->MBslimaddr + sizeof (uint32_t);
+		lpfc_memcpy_to_slim(to_slim, (void *)&mb->un.varWords[0],
+			    (MAILBOX_CMD_WSIZE - 1) * sizeof (uint32_t));
+
+		/* Next copy over first word, with mbxOwner set */
+		ldata = *((volatile uint32_t *)mb);
+		to_slim = phba->MBslimaddr;
+		writel(ldata, to_slim);
+		readl(to_slim); /* flush */
+
+		if (mb->mbxCommand == MBX_CONFIG_PORT) {
+			/* switch over to host mailbox */
+			psli->sliinit.sli_flag |= LPFC_SLI2_ACTIVE;
+		}
+	}
+
+	wmb();
+	/* interrupt board to doit right away */
+	writel(CA_MBATT, phba->CAregaddr);
+	readl(phba->CAregaddr); /* flush */
+
+	switch (flag) {
+	case MBX_NOWAIT:
+		/* Don't wait for it to finish, just return */
+		psli->mbox_active = pmbox;
+		break;
+
+	case MBX_POLL:
+		i = 0;
+		psli->mbox_active = 0;
+		if (psli->sliinit.sli_flag & LPFC_SLI2_ACTIVE) {
+			/* First read mbox status word */
+			mbox = (MAILBOX_t *) psli->MBhostaddr;
+			word0 = *((volatile uint32_t *)mbox);
+			word0 = le32_to_cpu(word0);
+		} else {
+			/* First read mbox status word */
+			word0 = readl(phba->MBslimaddr);
+		}
+
+		/* Read the HBA Host Attention Register */
+		ha_copy = readl(phba->HAregaddr);
+
+		/* Wait for command to complete */
+		while (((word0 & OWN_CHIP) == OWN_CHIP)
+		       || !(ha_copy & HA_MBATT)) {
+			if (i++ >= 100) {
+				psli->sliinit.sli_flag &= ~LPFC_SLI_MBOX_ACTIVE;
+				LPFC_DRVR_UNLOCK(phba, drvr_flag);
+				return (MBX_NOT_FINISHED);
+			}
+
+			/* Check if we took a mbox interrupt while we were
+			   polling */
+			if (((word0 & OWN_CHIP) != OWN_CHIP)
+			    && (evtctr != psli->slistat.mboxEvent))
+				break;
+
+			LPFC_DRVR_UNLOCK(phba, drvr_flag);
+
+			/* If in interrupt context do not sleep */
+			lpfc_sleep_ms(phba, i);
+
+			LPFC_DRVR_LOCK(phba, drvr_flag);
+
+			if (psli->sliinit.sli_flag & LPFC_SLI2_ACTIVE) {
+				/* First copy command data */
+				mbox = (MAILBOX_t *) psli->MBhostaddr;
+				word0 = *((volatile uint32_t *)mbox);
+				word0 = le32_to_cpu(word0);
+				if (mb->mbxCommand == MBX_CONFIG_PORT) {
+					MAILBOX_t *slimmb;
+					volatile uint32_t slimword0;
+					/* Check real SLIM for any errors */
+					slimword0 = readl(phba->MBslimaddr);
+					slimmb = (MAILBOX_t *) & slimword0;
+					if (((slimword0 & OWN_CHIP) != OWN_CHIP)
+					    && slimmb->mbxStatus) {
+						psli->sliinit.sli_flag &=
+						    ~LPFC_SLI2_ACTIVE;
+						word0 = slimword0;
+					}
+				}
+			} else {
+				/* First copy command data */
+				word0 = readl(phba->MBslimaddr);
+			}
+			/* Read the HBA Host Attention Register */
+			ha_copy = readl(phba->HAregaddr);
+		}
+
+		if (psli->sliinit.sli_flag & LPFC_SLI2_ACTIVE) {
+			/* First copy command data */
+			mbox = (MAILBOX_t *) psli->MBhostaddr;
+			/* copy results back to user */
+			lpfc_sli_pcimem_bcopy((uint32_t *) mbox,
+					      (uint32_t *) mb,
+					      (sizeof (uint32_t) *
+					       MAILBOX_CMD_WSIZE));
+		} else {
+			/* First copy command data */
+			lpfc_memcpy_from_slim((void *)mb,
+				      phba->MBslimaddr,
+				      sizeof (uint32_t) * (MAILBOX_CMD_WSIZE));
+			if ((mb->mbxCommand == MBX_DUMP_MEMORY) &&
+			       pmbox->context2) {
+				lpfc_memcpy_from_slim((void *)pmbox->context2,
+				      phba->MBslimaddr + DMP_RSP_OFFSET,
+				      mb->un.varDmp.word_cnt);
+			}
+		}
+
+		wmb();
+		writel(HA_MBATT, phba->HAregaddr);
+		readl(phba->HAregaddr); /* flush */
+
+		psli->sliinit.sli_flag &= ~LPFC_SLI_MBOX_ACTIVE;
+		status = mb->mbxStatus;
+	}
+
+	if (flag == MBX_POLL) {
+		LPFC_DRVR_UNLOCK(phba, drvr_flag);
+	}
+	return (status);
+}
+
+int
+lpfc_sli_issue_iocb(lpfcHBA_t * phba,
+		    LPFC_SLI_RING_t * pring, LPFC_IOCBQ_t * piocb,
+		    uint32_t flag)
+{
+	LPFC_SLI_t *psli;
+	IOCB_t *iocb;
+	IOCB_t *icmd = 0;
+	HGP *hgp;
+	PGP *pgp;
+	MAILBOX_t *mbox;
+	LPFC_IOCBQ_t *nextiocb;
+	LPFC_IOCBQ_t *lastiocb;
+	uint32_t status;
+	int ringno, loopcnt;
+	uint32_t portCmdGet, portCmdMax;
+	void *to_slim;
+	void *from_slim;
+
+	psli = &phba->sli;
+	ringno = pring->ringno;
+
+	/* At this point we assume SLI-2 */
+	mbox = (MAILBOX_t *) psli->MBhostaddr;
+	pgp = (PGP *) & mbox->us.s2.port[ringno];
+	hgp = (HGP *) & mbox->us.s2.host[ringno];
+
+	/* portCmdMax is the number of cmd ring entries for this specific
+	   ring. */
+	portCmdMax = psli->sliinit.ringinit[ringno].numCiocb;
+
+	/* portCmdGet is the IOCB index of the next IOCB that the HBA
+	 * is going to process.
+	 */
+	status = pgp->cmdGetInx;
+	portCmdGet = le32_to_cpu(status);
+
+	/* We should never get an IOCB if we are in a < LINK_DOWN state */
+	if (phba->hba_state < LPFC_LINK_DOWN) {
+		/* If link is not initialized, just return */
+		return (IOCB_ERROR);
+	}
+
+	/* Check to see if we are blocking IOCB processing because of a
+	 * outstanding mbox command.
+	 */
+	if (pring->flag & LPFC_STOP_IOCB_MBX) {
+		/* Queue command to ring xmit queue */
+		if (!(flag & SLI_IOCB_RET_IOCB)) {
+			lpfc_sli_ringtx_put(phba, pring, piocb);
+		}
+		psli->slistat.iocbCmdDelay[ringno]++;
+		return (IOCB_BUSY);
+	}
+
+	if (phba->hba_state == LPFC_LINK_DOWN) {
+		icmd = &piocb->iocb;
+		if ((icmd->ulpCommand == CMD_QUE_RING_BUF_CN) ||
+		    (icmd->ulpCommand == CMD_QUE_RING_BUF64_CN) ||
+		    (icmd->ulpCommand == CMD_CLOSE_XRI_CN) ||
+		    (icmd->ulpCommand == CMD_ABORT_XRI_CN)) {
+			/* For IOCBs, like QUE_RING_BUF, that have no rsp ring 
+			 * completion, iocb_cmpl MUST be 0.
+			 */
+			if (piocb->iocb_cmpl) {
+				piocb->iocb_cmpl = 0;
+			}
+		} else {
+			if ((icmd->ulpCommand != CMD_CREATE_XRI_CR)) {
+				/* Queue command to ring xmit queue */
+				if (!(flag & SLI_IOCB_RET_IOCB)) {
+					lpfc_sli_ringtx_put(phba, pring, piocb);
+				}
+
+				/* If link is down, just return */
+				psli->slistat.iocbCmdDelay[ringno]++;
+				return (IOCB_BUSY);
+			}
+		}
+		/* Only CREATE_XRI and QUE_RING_BUF can be issued if the link
+		 * is not up.
+		 */
+	} else {
+		/* For FCP commands, we must be in a state where we can process
+		 * link attention events.
+		 */
+		if (!(psli->sliinit.sli_flag & LPFC_PROCESS_LA) &&
+		    (pring->ringno == psli->fcp_ring)) {
+			/* Queue command to ring xmit queue */
+			if (!(flag & SLI_IOCB_RET_IOCB)) {
+				lpfc_sli_ringtx_put(phba, pring, piocb);
+			}
+			psli->slistat.iocbCmdDelay[ringno]++;
+			return (IOCB_BUSY);
+		}
+	}
+
+	/* onetime should only be set for QUE_RING_BUF or CREATE_XRI
+	 * iocbs sent with link down.
+	 */
+
+	/* Get the next available command iocb.
+	 * cmdidx is the IOCB index of the next IOCB that the driver
+	 * is going to issue a command with.
+	 */
+	iocb = IOCB_ENTRY(pring->cmdringaddr, pring->cmdidx);
+
+	if (portCmdGet >= portCmdMax) {
+
+		/* Ring <ringno> issue: portCmdGet <portCmdGet> is bigger then
+		   cmd ring <portCmdMax> */
+		lpfc_printf_log(phba->brd_no,
+			&lpfc_msgBlk0314,
+			lpfc_mes0314,
+			lpfc_msgBlk0314.msgPreambleStr,
+			ringno,
+			portCmdGet,
+			portCmdMax);
+		/* Queue command to ring xmit queue */
+		if (!(flag & SLI_IOCB_RET_IOCB)) {
+			lpfc_sli_ringtx_put(phba, pring, piocb);
+		}
+		psli->slistat.iocbCmdDelay[ringno]++;
+
+		/*
+		 * Treat it as adapter hardware error.
+		 */
+		phba->hba_state = LPFC_HBA_ERROR;
+		phba->hba_flag |= FC_STOP_IO;
+		lpfc_handle_eratt(phba, HS_FFER3);
+		return (IOCB_BUSY);
+	}
+
+	/* Bump driver iocb command index to next IOCB */
+	if (++pring->cmdidx >= portCmdMax) {
+		pring->cmdidx = 0;
+	}
+	lastiocb = 0;
+	loopcnt = 0;
+
+	/* Check to see if this is a high priority
+	   command. If so bypass tx queue processing.
+	 */
+
+	if (flag & SLI_IOCB_HIGH_PRIORITY) {
+		nextiocb = 0;
+		goto afterloop;
+	}
+
+	/* While IOCB entries are available */
+	while (pring->cmdidx != portCmdGet) {
+		/* If there is anything on the tx queue, process it before
+		   piocb */
+		if (((nextiocb = lpfc_sli_ringtx_get(phba, pring)) == 0)
+		    && (piocb == 0)) {
+		      issueout:
+			/* Make sure cmdidx is in sync with the HBA's current
+			   value. */
+			
+			from_slim = (uint8_t *) phba->MBslimaddr +
+			    (SLIMOFF + (ringno * 2)) * 4;
+			status = readl(from_slim);
+			pring->cmdidx = (uint8_t) status;
+		
+
+			/* Interrupt the HBA to let it know there is work to do
+			 * in ring ringno.
+			 */
+			status = ((CA_R0ATT) << (ringno * 4));
+			wmb();
+			writel(status, phba->CAregaddr);
+			readl(phba->CAregaddr); /* flush */
+
+			/* If we are waiting for the IOCB to complete before
+			   returning */
+			if ((flag & SLI_IOCB_POLL) && lastiocb) {
+				uint32_t loopcnt, ha_copy;
+				int retval;
+
+				/* Wait 10240 loop iterations + 30 seconds
+				   before timing out the IOCB. */
+				for (loopcnt = 0; loopcnt < (10240 + 30);
+				     loopcnt++) {
+					ha_copy = lpfc_intr_prep(phba);
+					ha_copy = (ha_copy >> (ringno * 4));
+					if (ha_copy & HA_RXATT) {
+						retval =
+						    lpfc_sli_handle_ring_event
+						    (phba, pring,
+						     (ha_copy & HA_RXMASK));
+
+						/*
+						 * The IOCB requires to poll for
+						 * completion.  If retval is
+						 * identically 0, the iocb has
+						 * been handled.  Otherwise,
+						 * wait and retry.
+						 */
+						if (retval == 0) {
+							break;
+						}
+					}
+					if (loopcnt > 10240) {
+						/* 1 second delay */
+						lpfc_sleep_ms(phba, 1000);
+					}
+				}
+				if (loopcnt >= (10240 + 30)) {
+					/* Command timed out */
+					/* Based on the iotag field, get the cmd
+					   IOCB from the txcmplq */
+					if ((lastiocb =
+					     lpfc_sli_ringtxcmpl_get(phba,
+								     pring,
+								     lastiocb,
+								     0))) {
+						/* Call the specified completion
+						   routine */
+						icmd = &lastiocb->iocb;
+						icmd->ulpStatus =
+						    IOSTAT_LOCAL_REJECT;
+						icmd->un.ulpWord[4] =
+						    IOERR_SEQUENCE_TIMEOUT;
+						if (lastiocb->iocb_cmpl) {
+							(lastiocb->
+							 iocb_cmpl) (phba,
+								     lastiocb,
+								     lastiocb);
+						} else {
+							lpfc_iocb_free(phba,
+							       lastiocb);
+						}
+					}
+				}
+			}
+			return (IOCB_SUCCESS);
+		}
+
+afterloop:
+
+		/* If there is nothing left in the tx queue, now we can send
+		   piocb */
+		if (nextiocb == 0) {
+			nextiocb = piocb;
+			piocb = 0;
+		}
+		icmd = &nextiocb->iocb;
+
+		/* issue iocb command to adapter */
+		lpfc_sli_pcimem_bcopy((uint32_t *) icmd, (uint32_t *) iocb,
+				      sizeof (IOCB_t));
+		wmb();
+		psli->slistat.iocbCmd[ringno]++;
+
+		/* If there is no completion routine to call, we can release the
+		 * IOCB buffer back right now. For IOCBs, like QUE_RING_BUF,
+		 * that have no rsp ring completion, iocb_cmpl MUST be 0.
+		 */
+		if (nextiocb->iocb_cmpl) {
+			lpfc_sli_ringtxcmpl_put(phba, pring, nextiocb);
+		} else {
+			lpfc_iocb_free(phba, nextiocb);
+		}
+
+		/* Let the HBA know what IOCB slot will be the next one the
+		 * driver will put a command into.
+		 */
+		
+		
+		status = (uint32_t) pring->cmdidx;
+		to_slim = (uint8_t *) phba->MBslimaddr
+		    + (SLIMOFF + (ringno * 2)) * 4;
+		writel(status, to_slim);
+		readl(to_slim);
+	
+
+		/* Get the next available command iocb.
+		 * cmdidx is the IOCB index of the next IOCB that the driver
+		 * is going to issue a command with.
+		 */
+		iocb = IOCB_ENTRY(pring->cmdringaddr, pring->cmdidx);
+
+		/* Bump driver iocb command index to next IOCB */
+		if (++pring->cmdidx >= portCmdMax) {
+			pring->cmdidx = 0;
+		}
+
+		lastiocb = nextiocb;
+
+		/* Make sure the ring's command index has been updated.  If 
+		 * not, sync the slim memory area and refetch the command index.
+		 */
+		if (pring->cmdidx == portCmdGet) {
+			status = pgp->cmdGetInx;
+			portCmdGet = le32_to_cpu(status);
+		}
+
+	}			/* pring->cmdidx != portCmdGet */
+
+	if (piocb == 0 && !(flag & SLI_IOCB_HIGH_PRIORITY)) {
+		goto issueout;
+	} else if (piocb == 0) {
+		/* Make sure cmdidx is in sync with the HBA's current value. */
+		
+		from_slim =
+		    (uint8_t *) phba->MBslimaddr + (SLIMOFF +
+						    (ringno * 2)) * 4;
+		status = readl(from_slim);
+		pring->cmdidx = (uint8_t) status;
+	
+
+		/* Interrupt the HBA to let it know there is work to do
+		 * in ring ringno.
+		 */
+		status = ((CA_R0ATT) << (ringno * 4));
+		wmb();
+		writel(status, phba->CAregaddr);
+		readl(phba->CAregaddr); /* flush */
+
+		return (IOCB_SUCCESS);
+	}
+
+	/* This code is executed only if the command ring is full.  Wait for the
+	 * HBA to process some entries before handing it more work.
+	 */
+
+	/* Make sure cmdidx is in sync with the HBA's current value. */
+      	from_slim =
+		    (uint8_t *) phba->MBslimaddr + (SLIMOFF + (ringno * 2)) * 4;
+	status = readl(from_slim);
+	pring->cmdidx = (uint8_t) status;
+
+
+	pring->flag |= LPFC_CALL_RING_AVAILABLE; /* indicates cmd ring was
+						    full */
+	/* 
+	 * Set ring 'ringno' to SET R0CE_REQ in Chip Att register.
+	 * The HBA will tell us when an IOCB entry is available.
+	 */
+	status = ((CA_R0ATT | CA_R0CE_REQ) << (ringno * 4));
+	wmb();
+	writel(status, phba->CAregaddr);
+	readl(phba->CAregaddr); /* flush */
+
+	psli->slistat.iocbCmdFull[ringno]++;
+
+	/* Queue command to ring xmit queue */
+	if ((!(flag & SLI_IOCB_RET_IOCB)) && piocb) {
+		lpfc_sli_ringtx_put(phba, pring, piocb);
+	}
+
+	return (IOCB_BUSY);
+}
+
+int
+lpfc_sli_resume_iocb(lpfcHBA_t * phba, LPFC_SLI_RING_t * pring)
+{
+	LPFC_SLI_t *psli;
+	IOCB_t *iocb;
+	IOCB_t *icmd = 0;
+	HGP *hgp;
+	PGP *pgp;
+	MAILBOX_t *mbox;
+	LPFC_IOCBQ_t *nextiocb;
+	uint32_t status;
+	int ringno, loopcnt;
+	uint32_t portCmdGet, portCmdMax;
+	void *to_slim;
+	void *from_slim;
+
+	psli = &phba->sli;
+	ringno = pring->ringno;
+
+	/* At this point we assume SLI-2 */
+	mbox = (MAILBOX_t *) psli->MBhostaddr;
+	pgp = (PGP *) & mbox->us.s2.port[ringno];
+	hgp = (HGP *) & mbox->us.s2.host[ringno];
+
+	/* portCmdMax is the number of cmd ring entries for this specific
+	   ring. */
+	portCmdMax = psli->sliinit.ringinit[ringno].numCiocb;
+
+	/* portCmdGet is the IOCB index of the next IOCB that the HBA
+	 * is going to process.
+	 */
+	status = pgp->cmdGetInx;
+	portCmdGet = le32_to_cpu(status);
+
+	/* First check to see if there is anything on the txq to send */
+	if (pring->txq_cnt == 0) {
+		return (portCmdGet);
+	}
+
+	if (phba->hba_state <= LPFC_LINK_DOWN) {
+		return (portCmdGet);
+	}
+	/* For FCP commands, we must be in a state where we can process
+	 * link attention events.
+	 */
+	if (!(psli->sliinit.sli_flag & LPFC_PROCESS_LA) &&
+	    (pring->ringno == psli->fcp_ring)) {
+		return (portCmdGet);
+	}
+
+	/* Check to see if we are blocking IOCB processing because of a
+	 * outstanding mbox command.
+	 */
+	if (pring->flag & LPFC_STOP_IOCB_MBX) {
+		return (portCmdGet);
+	}
+
+	/* Get the next available command iocb.
+	 * cmdidx is the IOCB index of the next IOCB that the driver
+	 * is going to issue a command with.
+	 */
+	iocb = IOCB_ENTRY(pring->cmdringaddr, pring->cmdidx);
+
+	if (portCmdGet >= portCmdMax) {
+
+		/* Ring <ringno> issue: portCmdGet <portCmdGet> is bigger
+		   then cmd ring <portCmdMax> */
+		lpfc_printf_log(phba->brd_no,
+			&lpfc_msgBlk0315,
+			lpfc_mes0315,
+			lpfc_msgBlk0315.msgPreambleStr,
+			ringno,
+			portCmdGet,
+			portCmdMax);
+
+		return (portCmdGet);
+	}
+
+	/* Bump driver iocb command index to next IOCB */
+	if (++pring->cmdidx >= portCmdMax) {
+		pring->cmdidx = 0;
+	}
+	loopcnt = 0;
+
+	/* While IOCB entries are available */
+	while (pring->cmdidx != portCmdGet) {
+		/* If there is anything on the tx queue, process it */
+		if ((nextiocb = lpfc_sli_ringtx_get(phba, pring)) == 0) {
+			/* Make sure cmdidx is in sync with the HBA's current
+			   value. */
+			
+			from_slim =
+			    (uint8_t *) phba->MBslimaddr + (SLIMOFF +
+							    (ringno *
+							     2)) * 4;
+			status = readl(from_slim);
+			pring->cmdidx = (uint8_t) status;
+		
+
+			/* Interrupt the HBA to let it know there is work to do
+			 * in ring ringno.
+			 */
+			status = ((CA_R0ATT) << (ringno * 4));
+			wmb();
+			writel(status, phba->CAregaddr);
+			readl(phba->CAregaddr); /* flush */
+			return (portCmdGet);
+		}
+		icmd = &nextiocb->iocb;
+
+		/* issue iocb command to adapter */
+		lpfc_sli_pcimem_bcopy((uint32_t *) icmd, (uint32_t *) iocb,
+				      sizeof (IOCB_t));
+		wmb();
+		psli->slistat.iocbCmd[ringno]++;
+
+		/* If there is no completion routine to call, we can release the
+		 * IOCB buffer back right now. For IOCBs, like QUE_RING_BUF,
+		 * that have no rsp ring completion, iocb_cmpl MUST be 0.
+		 */
+		if (nextiocb->iocb_cmpl) {
+			lpfc_sli_ringtxcmpl_put(phba, pring, nextiocb);
+		} else {
+			lpfc_iocb_free(phba, nextiocb);
+		}
+
+		/* Let the HBA know what IOCB slot will be the next one the
+		 * driver will put a command into.
+		 */
+		
+
+		status = (uint32_t) pring->cmdidx;
+		to_slim =
+		    (uint8_t *) phba->MBslimaddr + (SLIMOFF +
+						    (ringno * 2)) * 4;
+		writel(status, to_slim);
+		readl(to_slim);
+	
+
+		/* Get the next available command iocb.
+		 * cmdidx is the IOCB index of the next IOCB that the driver
+		 * is going to issue a command with.
+		 */
+		iocb = IOCB_ENTRY(pring->cmdringaddr, pring->cmdidx);
+
+		/* Bump driver iocb command index to next IOCB */
+		if (++pring->cmdidx >= portCmdMax) {
+			pring->cmdidx = 0;
+		}
+
+		/* Make sure the ring's command index has been updated.  If 
+		 * not, sync the slim memory area and refetch the command index.
+		 */
+		if (pring->cmdidx == portCmdGet) {
+			/* sync pgp->cmdGetInx in the MAILBOX_t */
+			status = pgp->cmdGetInx;
+			portCmdGet = le32_to_cpu(status);
+		}
+	}
+
+	/* This code is executed only if the command ring is full.  Wait for the
+	 * HBA to process some entries before handing it more work.
+	 */
+	/* Make sure cmdidx is in sync with the HBA's current value. */
+   
+	from_slim = (uint8_t *) phba->MBslimaddr +
+	    (SLIMOFF + (ringno * 2)) * 4;
+	status = readl(from_slim);
+	pring->cmdidx = (uint8_t) status;
+
+
+	pring->flag |= LPFC_CALL_RING_AVAILABLE; /* indicates cmd ring was
+						    full */
+	/* 
+	 * Set ring 'ringno' to SET R0CE_REQ in Chip Att register.
+	 * The HBA will tell us when an IOCB entry is available.
+	 */
+	status = ((CA_R0ATT | CA_R0CE_REQ) << (ringno * 4));
+	wmb();
+	writel(status, phba->CAregaddr);
+	readl(phba->CAregaddr); /* flush */
+
+	psli->slistat.iocbCmdFull[ringno]++;;
+	return (portCmdGet);
+}
+
+#define BARRIER_TEST_PATTERN (0xdeadbeef)
+
+void lpfc_reset_barrier(lpfcHBA_t * phba)
+{
+	uint32_t * resp_buf;
+	uint32_t * mbox_buf;
+	volatile uint32_t mbox;
+	uint32_t hc_copy;
+	int  i;
+	uint8_t hdrtype;
+
+	pci_read_config_byte(phba->pcidev, PCI_HEADER_TYPE, &hdrtype);
+	if (hdrtype != 0x80 ||
+	    (FC_JEDEC_ID(phba->vpd.rev.biuRev) != HELIOS_JEDEC_ID &&
+	     FC_JEDEC_ID(phba->vpd.rev.biuRev) != THOR_JEDEC_ID))
+		return;
+
+	/*
+	 * Tell the other part of the chip to suspend temporarily all
+	 * its DMA activity.
+	 */
+	resp_buf =  (uint32_t *)phba->MBslimaddr;
+
+	/* Disable the error attention */
+	hc_copy = readl(phba->HCregaddr);
+	writel((hc_copy & ~HC_ERINT_ENA), phba->HCregaddr);
+	readl(phba->HCregaddr); /* flush */
+
+	if (readl(phba->HAregaddr) & HA_ERATT) {
+		/* Clear Chip error bit */
+		writel(HA_ERATT, phba->HAregaddr);
+		phba->stopped = 1;
+	}
+
+	mbox = 0;
+	((MAILBOX_t *)&mbox)->mbxCommand = MBX_KILL_BOARD;
+	((MAILBOX_t *)&mbox)->mbxOwner = OWN_CHIP;
+
+	writel(BARRIER_TEST_PATTERN, (resp_buf + 1));
+	mbox_buf = (uint32_t *)phba->MBslimaddr;
+	writel(mbox, mbox_buf);
+
+	for (i = 0;
+	     readl(resp_buf + 1) != ~(BARRIER_TEST_PATTERN) && i < 50; i++)
+		mdelay(1);
+
+	if (readl(resp_buf + 1) != ~(BARRIER_TEST_PATTERN)) {
+		if (phba->sli.sliinit.sli_flag & LPFC_SLI2_ACTIVE ||
+		    phba->stopped)
+			goto restore_hc;
+		else
+			goto clear_errat;
+	}
+
+	((MAILBOX_t *)&mbox)->mbxOwner = OWN_HOST;
+	for (i = 0; readl(resp_buf) != mbox &&  i < 500; i++)
+		mdelay(1);
+
+clear_errat:
+
+	while (!(readl(phba->HAregaddr) & HA_ERATT) && ++i < 500)
+		mdelay(1);
+
+	/* Clear Chip error bit */
+	if (readl(phba->HAregaddr) & HA_ERATT) {
+		writel(HA_ERATT, phba->HAregaddr);
+		readl(phba->HAregaddr); /* flush */
+		phba->stopped = 1;
+	}
+
+restore_hc:
+	writel(hc_copy, phba->HCregaddr);
+	readl(phba->HCregaddr); /* flush */
+}
+
+int
+lpfc_sli_brdreset(lpfcHBA_t * phba)
+{
+	MAILBOX_t *swpmb;
+	LPFC_SLI_t *psli;
+	LPFC_SLI_RING_t *pring;
+	uint16_t cfg_value, skip_post;
+	volatile uint32_t word0;
+	int i;
+	void *to_slim;
+	struct list_head *curr, *next;
+	DMABUF_t * mp;
+
+	psli = &phba->sli;
+
+	lpfc_reset_barrier(phba);
+
+	/* A board reset must use REAL SLIM. */
+	psli->sliinit.sli_flag &= ~LPFC_SLI2_ACTIVE;
+
+	word0 = 0;
+	swpmb = (MAILBOX_t *) & word0;
+	swpmb->mbxCommand = MBX_RESTART;
+	swpmb->mbxHc = 1;
+
+	to_slim = phba->MBslimaddr;
+	writel(*(uint32_t *) swpmb, to_slim);
+	readl(to_slim); /* flush */
+
+	/* Only skip post after fc_ffinit is completed */
+	if (phba->hba_state) {
+		skip_post = 1;
+		word0 = 1;	/* This is really setting up word1 */
+	} else {
+		skip_post = 0;
+		word0 = 0;	/* This is really setting up word1 */
+	}
+	to_slim = (uint8_t *) phba->MBslimaddr + sizeof (uint32_t);
+	writel(*(uint32_t *) swpmb, to_slim);
+	readl(to_slim); /* flush */
+
+	/* Reset HBA */
+	lpfc_printf_log(phba->brd_no,
+			&lpfc_msgBlk0326,
+			lpfc_mes0326,
+			lpfc_msgBlk0326.msgPreambleStr,
+			phba->hba_state,
+			psli->sliinit.sli_flag);
+
+	/* Turn off SERR, PERR in PCI cmd register */
+	phba->hba_state = LPFC_INIT_START;
+
+	/* perform board reset */
+	phba->fc_eventTag = 0;
+	phba->fc_myDID = 0;
+	phba->fc_prevDID = 0;
+
+	/* Turn off parity checking and serr during the physical reset */
+	pci_read_config_word(phba->pcidev, PCI_COMMAND, &cfg_value);
+	pci_write_config_word(phba->pcidev, PCI_COMMAND,
+			      (cfg_value &
+			       ~(PCI_COMMAND_PARITY | PCI_COMMAND_SERR)));
+
+	/* Now toggle INITFF bit in the Host Control Register */
+	writel(HC_INITFF, phba->HCregaddr);
+	mdelay(1);
+	readl(phba->HCregaddr); /* flush */
+	writel(0, phba->HCregaddr);
+	readl(phba->HCregaddr); /* flush */
+
+	/* Restore PCI cmd register */
+
+	pci_write_config_word(phba->pcidev, PCI_COMMAND, cfg_value);
+	phba->hba_state = LPFC_INIT_START;
+	phba->stopped = 0;
+	/* Initialize relevant SLI info */
+	for (i = 0; i < psli->sliinit.num_rings; i++) {
+		pring = &psli->ring[i];
+		pring->flag = 0;
+		pring->rspidx = 0;
+		pring->cmdidx = 0;
+		pring->missbufcnt = 0;
+	}
+
+	if (skip_post) {
+		mdelay(100);
+	} else {
+		mdelay(2000);
+	}
+
+	/* Now cleanup posted buffers on each ring */
+	pring = &psli->ring[LPFC_ELS_RING];
+	list_for_each_safe(curr, next, &pring->postbufq) {
+		mp = list_entry(curr, DMABUF_t, list);
+		list_del(&mp->list);
+		pring->postbufq_cnt--;
+		lpfc_mbuf_free(phba, mp->virt, mp->phys);
+		kfree(mp);
+	}
+
+	for (i = 0; i < psli->sliinit.num_rings; i++) {
+		pring = &psli->ring[i];
+		lpfc_sli_abort_iocb_ring(phba, pring, LPFC_SLI_ABORT_IMED);
+	}
+
+	return (0);
+}
+
+int
+lpfc_sli_queue_setup(lpfcHBA_t * phba)
+{
+	LPFC_SLI_t *psli;
+	LPFC_SLI_RING_t *pring;
+	int i, cnt;
+
+	psli = &phba->sli;
+	INIT_LIST_HEAD(&psli->mboxq);
+	/* Initialize list headers for txq and txcmplq as double linked lists */
+	for (i = 0; i < psli->sliinit.num_rings; i++) {
+		pring = &psli->ring[i];
+		pring->ringno = i;
+		INIT_LIST_HEAD(&pring->txq);
+		INIT_LIST_HEAD(&pring->txcmplq);
+		INIT_LIST_HEAD(&pring->iocb_continueq);
+		INIT_LIST_HEAD(&pring->postbufq);
+		cnt = psli->sliinit.ringinit[i].fast_iotag;
+		if (cnt) {
+			pring->fast_lookup =
+			    kmalloc(cnt * sizeof (LPFC_IOCBQ_t *), GFP_ATOMIC);
+			if (pring->fast_lookup == 0) {
+				return (0);
+			}
+			memset((char *)pring->fast_lookup, 0, 
+			       cnt*sizeof (LPFC_IOCBQ_t *));
+		}
+	}
+	return (1);
+}
+
+int
+lpfc_sli_hba_down(lpfcHBA_t * phba)
+{
+	LPFC_SLI_t *psli;
+	LPFC_SLI_RING_t *pring;
+	LPFC_MBOXQ_t *pmb;
+	DMABUF_t * mp;
+	LPFC_IOCBQ_t *iocb;
+	IOCB_t *icmd = 0;
+	int i, cnt;
+	unsigned long iflag;
+	struct list_head *curr, *next;
+
+	psli = &phba->sli;
+
+	iflag = phba->iflag;
+
+	lpfc_hba_down_prep(phba);
+
+	for (i = 0; i < psli->sliinit.num_rings; i++) {
+		pring = &psli->ring[i];
+		pring->flag |= LPFC_DEFERRED_RING_EVENT;
+		/* Error everything on txq  */
+		pring->txq_cnt = 0;
+
+		list_for_each_safe(curr, next, &pring->txq) {
+			iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+			list_del_init(curr);
+			if (iocb->iocb_cmpl) {
+				icmd = &iocb->iocb;
+				icmd->ulpStatus = IOSTAT_LOCAL_REJECT;
+				icmd->un.ulpWord[4] = IOERR_SLI_DOWN;
+				(iocb->iocb_cmpl) (phba, iocb, iocb);
+			} else {
+				lpfc_iocb_free(phba, iocb);
+			}
+		}
+
+		INIT_LIST_HEAD(&(pring->txq));
+
+		/* Free any memory allocated for fast lookup */
+		cnt = psli->sliinit.ringinit[i].fast_iotag;
+		if (pring->fast_lookup) {
+			kfree(pring->fast_lookup);
+			pring->fast_lookup = 0;
+		}
+	}
+
+	/* Return any active mbox cmds */
+	if (psli->mbox_tmo.function) {
+		lpfc_stop_timer((struct clk_data *)psli->mbox_tmo.data);
+	}
+	if ((psli->mbox_active)) {
+		pmb = psli->mbox_active;
+		mp = (DMABUF_t *) (pmb->context1);
+		if((mp) && 
+			(pmb->mbox_cmpl != lpfc_sli_wake_mbox_wait)) {
+			lpfc_mbuf_free(phba, mp->virt, mp->phys);
+			kfree(mp);
+		}
+		lpfc_mbox_free(phba, pmb);
+	}
+	psli->sliinit.sli_flag &= ~LPFC_SLI_MBOX_ACTIVE;
+	psli->mbox_active = 0;
+
+	/* Return any pending mbox cmds */
+	while ((pmb = lpfc_mbox_get(phba))) {
+		mp = (DMABUF_t *) (pmb->context1);
+		if ((mp) &&
+		    (pmb->mbox_cmpl != lpfc_sli_wake_mbox_wait)) {
+			lpfc_mbuf_free(phba, mp->virt, mp->phys);
+			kfree(mp);
+		}
+		lpfc_mbox_free(phba, pmb);
+	}
+
+	INIT_LIST_HEAD(&psli->mboxq);
+
+	/*
+	 * Adapter can not handle any mbox command.
+	 * Skip borad reset.
+	 */
+	if (phba->hba_state != LPFC_HBA_ERROR) {
+		phba->hba_state = LPFC_INIT_START;
+		lpfc_sli_brdreset(phba);
+	}
+
+	return (1);
+}
+
+void
+lpfc_sli_pcimem_bcopy(uint32_t * src, uint32_t * dest, uint32_t cnt)
+{
+	uint32_t ldata;
+	int i;
+
+	for (i = 0; i < (int)cnt; i += sizeof (uint32_t)) {
+		ldata = *src++;
+		ldata = le32_to_cpu(ldata);
+		*dest++ = ldata;
+	}
+}
+
+int
+lpfc_sli_ringpostbuf_put(lpfcHBA_t * phba, LPFC_SLI_RING_t * pring,
+			 DMABUF_t * mp)
+{
+	/* Stick DMABUF_t at end of postbufq so driver can look it up later */
+	list_add_tail(&mp->list, &pring->postbufq);
+
+	pring->postbufq_cnt++;
+	return (0);
+}
+
+DMABUF_t *
+lpfc_sli_ringpostbuf_get(lpfcHBA_t * phba,
+			 LPFC_SLI_RING_t * pring, dma_addr_t phys)
+{
+	return (lpfc_sli_ringpostbuf_search(phba, pring, phys, 1));
+}
+
+DMABUF_t *
+lpfc_sli_ringpostbuf_search(lpfcHBA_t * phba,
+			    LPFC_SLI_RING_t * pring, dma_addr_t phys,
+			    int unlink)
+{
+	DMABUF_t *mp;
+	struct list_head *slp;
+	int count;
+	struct list_head *pos, *tpos;
+
+	slp = &pring->postbufq;
+
+	/* Search postbufq, from the begining, looking for a match on phys */
+	count = 0;
+
+	list_for_each_safe(pos, tpos, &pring->postbufq) {
+		count++;
+		mp = list_entry(pos, DMABUF_t, list);
+		if (mp->phys == phys) {
+			/* If we find a match, deque it and return it to the
+			   caller */
+			if (unlink) {
+				list_del(&mp->list);
+
+				pring->postbufq_cnt--;
+			}
+			return (mp);
+		}
+	}
+	/* Cannot find virtual addr for mapped buf on ring <num> */
+	lpfc_printf_log(phba->brd_no,
+		&lpfc_msgBlk0410,
+		lpfc_mes0410,
+		lpfc_msgBlk0410.msgPreambleStr,
+		pring->ringno,
+		phys,
+		slp->next,
+		slp->prev,
+		pring->postbufq_cnt);
+	return (0);
+}
+
+int
+lpfc_sli_ringtx_put(lpfcHBA_t * phba, LPFC_SLI_RING_t * pring,
+		    LPFC_IOCBQ_t * piocb)
+{
+	struct list_head *dlp;
+	struct list_head *dlp_end;
+
+	/* Stick IOCBQ_t at end of txq so driver can issue it later */
+	dlp = &pring->txq;
+	dlp_end = (struct list_head *)dlp->prev;
+	list_add(&piocb->list, dlp_end);
+	pring->txq_cnt++;
+	return (0);
+}
+
+int
+lpfc_sli_ringtxcmpl_put(lpfcHBA_t * phba,
+			LPFC_SLI_RING_t * pring, LPFC_IOCBQ_t * piocb)
+{
+	struct list_head *dlp;
+	struct list_head *dlp_end;
+	IOCB_t *icmd = 0;
+	LPFC_SLI_t *psli;
+	uint8_t *ptr;
+	uint16_t iotag;
+
+	dlp = &pring->txcmplq;
+	dlp_end = dlp->prev;
+	list_add(&piocb->list, dlp_end);
+
+	pring->txcmplq_cnt++;
+	ptr = (uint8_t *) (pring->fast_lookup);
+
+	if (ptr) {
+		/* Setup fast lookup based on iotag for completion */
+		psli = &phba->sli;
+		icmd = &piocb->iocb;
+		iotag = icmd->ulpIoTag;
+		if (iotag < psli->sliinit.ringinit[pring->ringno].fast_iotag) {
+			ptr += (iotag * sizeof (LPFC_IOCBQ_t *));
+			*((LPFC_IOCBQ_t **) ptr) = piocb;
+		} else {
+
+			/* Cmd ring <ringno> put: iotag <iotag> greater then
+			   configured max <fast_iotag> wd0 <icmd> */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0316,
+					lpfc_mes0316,
+					lpfc_msgBlk0316.msgPreambleStr,
+					pring->ringno, iotag, psli->sliinit
+					.ringinit[pring->ringno].fast_iotag,
+					*(((uint32_t *) icmd) + 7));
+		}
+	}
+	return (0);
+}
+
+LPFC_IOCBQ_t *
+lpfc_sli_ringtx_get(lpfcHBA_t * phba, LPFC_SLI_RING_t * pring)
+{
+	struct list_head *dlp;
+	LPFC_IOCBQ_t *cmd_iocb;
+	LPFC_IOCBQ_t *next_iocb;
+
+	dlp = &pring->txq;
+	cmd_iocb = 0;
+	next_iocb = (LPFC_IOCBQ_t *) pring->txq.next;
+	if (next_iocb != (LPFC_IOCBQ_t *) & pring->txq) {
+		/* If the first ptr is not equal to the list header, 
+		 * deque the IOCBQ_t and return it.
+		 */
+		cmd_iocb = next_iocb;
+		list_del(&cmd_iocb->list);
+		pring->txq_cnt--;
+	}
+	return (cmd_iocb);
+}
+
+LPFC_IOCBQ_t *
+lpfc_sli_ringtxcmpl_get(lpfcHBA_t * phba,
+			LPFC_SLI_RING_t * pring,
+			LPFC_IOCBQ_t * prspiocb, uint32_t srch)
+{
+	struct list_head *dlp;
+	IOCB_t *irsp = 0;
+	LPFC_IOCBQ_t *cmd_iocb;
+	LPFC_SLI_t *psli;
+	uint8_t *ptr;
+	uint16_t iotag;
+
+
+	dlp = &pring->txcmplq;
+	ptr = (uint8_t *) (pring->fast_lookup);
+
+	if (ptr && (srch == 0)) {
+		/* Use fast lookup based on iotag for completion */
+		psli = &phba->sli;
+		irsp = &prspiocb->iocb;
+		iotag = irsp->ulpIoTag;
+		if (iotag < psli->sliinit.ringinit[pring->ringno].fast_iotag) {
+			ptr += (iotag * sizeof (LPFC_IOCBQ_t *));
+			cmd_iocb = *((LPFC_IOCBQ_t **) ptr);
+			*((LPFC_IOCBQ_t **) ptr) = 0;
+			if (cmd_iocb == 0) {
+				cmd_iocb = lpfc_search_txcmpl(pring, prspiocb);
+				return(cmd_iocb);
+			}
+
+			list_del(&cmd_iocb->list);
+			pring->txcmplq_cnt--;
+		} else {
+
+			/* Rsp ring <ringno> get: iotag <iotag> greater then
+			   configured max <fast_iotag> wd0 <irsp> */
+			lpfc_printf_log(phba->brd_no, &lpfc_msgBlk0317,
+					lpfc_mes0317,
+					lpfc_msgBlk0317.msgPreambleStr,
+					pring->ringno, iotag,
+					psli->sliinit.ringinit[pring->ringno]
+					.fast_iotag,
+					*(((uint32_t *) irsp) + 7));
+
+			cmd_iocb = lpfc_search_txcmpl(pring, prspiocb);
+			return(cmd_iocb);
+		}
+	} else {
+		cmd_iocb = lpfc_search_txcmpl(pring, prspiocb);
+	}
+
+	return (cmd_iocb);
+}
+
+LPFC_IOCBQ_t *
+lpfc_search_txcmpl(LPFC_SLI_RING_t * pring, LPFC_IOCBQ_t * prspiocb)
+{
+	struct list_head *list, *list_tmp;
+	IOCB_t *icmd = 0;
+	IOCB_t *irsp = 0;
+	LPFC_IOCBQ_t *cmd_iocb;
+	LPFC_IOCBQ_t *next_iocb;
+	uint16_t iotag;
+
+	irsp = &prspiocb->iocb;
+	iotag = irsp->ulpIoTag;
+	cmd_iocb = 0;
+
+	/* Search through txcmpl from the begining */
+	list_for_each_safe(list, list_tmp, &(pring->txcmplq)) {
+		next_iocb = (LPFC_IOCBQ_t *) list;
+		icmd = &next_iocb->iocb;
+		if (iotag == icmd->ulpIoTag) {
+			/* found a match! */
+			cmd_iocb = next_iocb;
+			list_del(&cmd_iocb->list);
+			pring->txcmplq_cnt--;
+			break;
+		}
+	}
+
+	return (cmd_iocb);
+}
+
+
+uint32_t
+lpfc_sli_next_iotag(lpfcHBA_t * phba, LPFC_SLI_RING_t * pring)
+{
+	LPFC_RING_INIT_t *pringinit;
+	LPFC_SLI_t *psli;
+	uint8_t *ptr;
+	int i;
+
+	psli = &phba->sli;
+	pringinit = &psli->sliinit.ringinit[pring->ringno];
+	for (i = 0; i < pringinit->iotag_max; i++) {
+		/* Never give an iotag of 0 back */
+		pringinit->iotag_ctr++;
+		if (pringinit->iotag_ctr == pringinit->iotag_max) {
+			pringinit->iotag_ctr = 1; /* Never use 0 as an iotag */
+		}
+		/* If fast_iotaging is used, we can ensure that the iotag 
+		 * we give back is not already in use.
+		 */
+		if (pring->fast_lookup) {
+			ptr = (uint8_t *) (pring->fast_lookup);
+			ptr += (pringinit->iotag_ctr * sizeof (LPFC_IOCBQ_t *));
+			if (*((LPFC_IOCBQ_t **) ptr) != 0)
+				continue;
+		}
+		return (pringinit->iotag_ctr);
+	}
+
+	/* Outstanding I/O count for ring <ringno> is at max <fast_iotag> */
+	lpfc_printf_log(phba->brd_no,
+		&lpfc_msgBlk0318,
+		lpfc_mes0318,
+		lpfc_msgBlk0318.msgPreambleStr,
+		pring->ringno,
+		psli->sliinit.ringinit[pring->ringno].fast_iotag);
+	return (0);
+}
+
+void
+lpfc_sli_abort_cmpl(lpfcHBA_t * phba, LPFC_IOCBQ_t * cmdiocb,
+		    LPFC_IOCBQ_t * rspiocb)
+{
+	lpfc_iocb_free(phba, cmdiocb);
+	return;
+}
+
+void
+lpfc_sli_abort_elsreq_cmpl(lpfcHBA_t * phba, LPFC_IOCBQ_t * cmdiocb,
+			   LPFC_IOCBQ_t * rspiocb)
+{
+	DMABUF_t *buf_ptr, *buf_ptr1;
+	/* Free the resources associated with the ELS_REQUEST64 IOCB the driver
+	 * just aborted.
+	 * In this case, context2  = cmd,  context2->next = rsp, context3 = bpl 
+	 */
+	if (cmdiocb->context2) {
+		buf_ptr1 = (DMABUF_t *) cmdiocb->context2;
+
+		/* Free the response IOCB before completing the abort
+		   command.  */
+		if (!list_empty(&buf_ptr1->list)) {
+
+			buf_ptr = list_entry(buf_ptr1->list.next,
+					     DMABUF_t, list);
+
+			list_del(&buf_ptr->list);
+			lpfc_mbuf_free(phba, buf_ptr->virt, buf_ptr->phys);
+			kfree(buf_ptr);
+		}
+		lpfc_mbuf_free(phba, buf_ptr1->virt, buf_ptr1->phys);
+		kfree(buf_ptr1);
+	}
+
+	if (cmdiocb->context3) {
+		buf_ptr = (DMABUF_t *) cmdiocb->context3;
+		lpfc_mbuf_free(phba, buf_ptr->virt, buf_ptr->phys);
+		kfree(buf_ptr);
+	}
+	lpfc_iocb_free(phba, cmdiocb);
+	return;
+}
+
+int
+lpfc_sli_abort_iocb(lpfcHBA_t * phba, LPFC_SLI_RING_t * pring,
+		    LPFC_IOCBQ_t * piocb)
+{
+	LPFC_SLI_t *psli;
+	LPFC_IOCBQ_t *abtsiocbp;
+	uint8_t *ptr;
+	IOCB_t *abort_cmd = 0, *cmd = 0;
+	uint16_t iotag;
+
+	psli = &phba->sli;
+	cmd = &piocb->iocb;
+
+	if (piocb->abort_count == 2) {
+		/* Clear fast_lookup entry, if any */
+		iotag = cmd->ulpIoTag;
+		ptr = (uint8_t *) (pring->fast_lookup);
+		if (ptr
+		    && (iotag <
+			psli->sliinit.ringinit[pring->ringno].fast_iotag)) {
+			LPFC_IOCBQ_t *cmd_iocb;
+			ptr += (iotag * sizeof (LPFC_IOCBQ_t *));
+			cmd_iocb = *((LPFC_IOCBQ_t **) ptr);
+			*((LPFC_IOCBQ_t **) ptr) = 0;
+		}
+
+		/* Dequeue and complete with error */
+		list_del(&piocb->list);
+		pring->txcmplq_cnt--;
+
+		if (piocb->iocb_cmpl) {
+			cmd->ulpStatus = IOSTAT_LOCAL_REJECT;
+			cmd->un.ulpWord[4] = IOERR_SLI_ABORTED;
+			(piocb->iocb_cmpl) (phba, piocb, piocb);
+		} else {
+			lpfc_iocb_free(phba, piocb);
+		}
+
+		return (1);
+	}
+
+	/* issue ABTS for this IOCB based on iotag */
+
+	if ((abtsiocbp = lpfc_iocb_alloc(phba, MEM_PRI))
+	    == 0) {
+		return (0);
+	}
+
+	memset(abtsiocbp, 0, sizeof (LPFC_IOCBQ_t));
+	abort_cmd = &abtsiocbp->iocb;
+
+	abort_cmd->un.acxri.abortType = ABORT_TYPE_ABTS;
+	abort_cmd->un.acxri.abortContextTag = cmd->ulpContext;
+	abort_cmd->un.acxri.abortIoTag = cmd->ulpIoTag;
+
+	abort_cmd->ulpLe = 1;
+	abort_cmd->ulpClass = cmd->ulpClass;
+	if (phba->hba_state >= LPFC_LINK_UP) {
+		abort_cmd->ulpCommand = CMD_ABORT_XRI_CN;
+	} else {
+		abort_cmd->ulpCommand = CMD_CLOSE_XRI_CN;
+	}
+
+	/* set up an iotag  */
+	abort_cmd->ulpIoTag = lpfc_sli_next_iotag(phba, pring);
+
+	if (lpfc_sli_issue_iocb(phba, pring, abtsiocbp, SLI_IOCB_USE_TXQ)
+	    == IOCB_ERROR) {
+		lpfc_iocb_free(phba, abtsiocbp);
+		return (0);
+	}
+
+	piocb->abort_count++;
+	return (1);
+}
+
+int
+lpfc_sli_abort_iocb_ring(lpfcHBA_t * phba, LPFC_SLI_RING_t * pring,
+			 uint32_t flag)
+{
+	LPFC_SLI_t *psli;
+	LPFC_IOCBQ_t *iocb, *next_iocb;
+	LPFC_IOCBQ_t *abtsiocbp;
+	uint8_t *ptr;
+	IOCB_t *icmd = 0, *cmd = 0;
+	int errcnt;
+	uint16_t iotag;
+	struct list_head *curr, *next;
+
+	psli = &phba->sli;
+	errcnt = 0;
+
+	/* Error everything on txq and txcmplq 
+	 * First do the txq.
+	 */
+	list_for_each_safe(curr, next, &pring->txq) {
+		next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+		list_del_init(&next_iocb->list);
+		iocb = next_iocb;
+
+		if (iocb->iocb_cmpl) {
+			icmd = &iocb->iocb;
+			icmd->ulpStatus = IOSTAT_LOCAL_REJECT;
+			icmd->un.ulpWord[4] = IOERR_SLI_ABORTED;
+			(iocb->iocb_cmpl) (phba, iocb, iocb);
+		} else {
+			lpfc_iocb_free(phba, iocb);
+		}
+	}
+
+	pring->txq_cnt = 0;
+	INIT_LIST_HEAD(&(pring->txq));
+
+	/* Next issue ABTS for everything on the txcmplq */
+	list_for_each_safe(curr, next, &pring->txcmplq) {
+		next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+		iocb = next_iocb;
+		cmd = &iocb->iocb;
+
+		if (flag == LPFC_SLI_ABORT_IMED) {
+			/* Imediate abort of IOCB, deque and call compl */
+			list_del_init(curr);
+		}
+
+		/* issue ABTS for this IOCB based on iotag */
+
+		if ((abtsiocbp = lpfc_iocb_alloc(phba, MEM_PRI)) == 0) {
+			errcnt++;
+			continue;
+		}
+		memset(abtsiocbp, 0, sizeof (LPFC_IOCBQ_t));
+		icmd = &abtsiocbp->iocb;
+
+		icmd->un.acxri.abortType = ABORT_TYPE_ABTS;
+		icmd->un.acxri.abortContextTag = cmd->ulpContext;
+		icmd->un.acxri.abortIoTag = cmd->ulpIoTag;
+
+		icmd->ulpLe = 1;
+		icmd->ulpClass = cmd->ulpClass;
+		if (phba->hba_state >= LPFC_LINK_UP) {
+			icmd->ulpCommand = CMD_ABORT_XRI_CN;
+		} else {
+			icmd->ulpCommand = CMD_CLOSE_XRI_CN;
+		}
+
+		if (flag == LPFC_SLI_ABORT_IMED) {
+			/* Clear fast_lookup entry, if any */
+			iotag = cmd->ulpIoTag;
+			ptr = (uint8_t *) (pring->fast_lookup);
+			if (ptr
+			    && (iotag <
+				psli->sliinit.ringinit[pring->ringno].
+				fast_iotag)) {
+				ptr += (iotag * sizeof (LPFC_IOCBQ_t *));
+				*((LPFC_IOCBQ_t **) ptr) = 0;
+			}
+			/* Imediate abort of IOCB, deque and call compl */
+			if (iocb->iocb_cmpl) {
+				cmd->ulpStatus = IOSTAT_LOCAL_REJECT;
+				cmd->un.ulpWord[4] = IOERR_SLI_ABORTED;
+				(iocb->iocb_cmpl) (phba, iocb, iocb);
+			} else {
+				lpfc_iocb_free(phba, iocb);
+			}
+			lpfc_iocb_free(phba, abtsiocbp);
+		} else {
+			/* set up an iotag  */
+			icmd->ulpIoTag = lpfc_sli_next_iotag(phba, pring);
+
+			if (lpfc_sli_issue_iocb
+			    (phba, pring, abtsiocbp, SLI_IOCB_USE_TXQ)
+			    == IOCB_ERROR) {
+				lpfc_iocb_free(phba, abtsiocbp);
+				errcnt++;
+				continue;
+			}
+		}
+		/* The rsp ring completion will remove IOCB from txcmplq when 
+		 * abort is read by HBA.
+		 */
+	}
+
+	if (flag == LPFC_SLI_ABORT_IMED) {
+		INIT_LIST_HEAD(&(pring->txcmplq));
+		pring->txcmplq_cnt = 0;
+	}
+
+	return (errcnt);
+}
+
+int
+lpfc_sli_issue_abort_iotag32(lpfcHBA_t * phba,
+			     LPFC_SLI_RING_t * pring, LPFC_IOCBQ_t * cmdiocb)
+{
+	LPFC_SLI_t *psli;
+	LPFC_IOCBQ_t *abtsiocbp;
+	IOCB_t *icmd = 0;
+	IOCB_t *iabt = 0;
+	uint32_t iotag32;
+
+	psli = &phba->sli;
+
+	/* issue ABTS for this IOCB based on iotag */
+	if ((abtsiocbp = lpfc_iocb_alloc(phba, MEM_PRI)) == 0) {
+		return (0);
+	}
+	memset(abtsiocbp, 0, sizeof (LPFC_IOCBQ_t));
+	iabt = &abtsiocbp->iocb;
+
+	icmd = &cmdiocb->iocb;
+	switch (icmd->ulpCommand) {
+	case CMD_ELS_REQUEST64_CR:
+		iotag32 = icmd->un.elsreq64.bdl.ulpIoTag32;
+		/* Even though we abort the ELS command, the firmware may access
+		 * the BPL or other resources before it processes our
+		 * ABORT_MXRI64. Thus we must delay reusing the cmdiocb
+		 * resources till the actual abort request completes.
+		 */
+		abtsiocbp->context1 = (void *)((unsigned long)icmd->ulpCommand);
+		abtsiocbp->context2 = cmdiocb->context2;
+		abtsiocbp->context3 = cmdiocb->context3;
+		cmdiocb->context2 = 0;
+		cmdiocb->context3 = 0;
+		abtsiocbp->iocb_cmpl = lpfc_sli_abort_elsreq_cmpl;
+		break;
+	default:
+		lpfc_iocb_free(phba, abtsiocbp);
+		return (0);
+	}
+
+	iabt->un.amxri.abortType = ABORT_TYPE_ABTS;
+	iabt->un.amxri.iotag32 = iotag32;
+
+	iabt->ulpLe = 1;
+	iabt->ulpClass = CLASS3;
+	iabt->ulpCommand = CMD_ABORT_MXRI64_CN;
+
+	/* set up an iotag  */
+	iabt->ulpIoTag = lpfc_sli_next_iotag(phba, pring);
+
+	if (lpfc_sli_issue_iocb(phba, pring, abtsiocbp, SLI_IOCB_USE_TXQ)
+	    == IOCB_ERROR) {
+		lpfc_iocb_free(phba, abtsiocbp);
+		return (0);
+	}
+
+	return (1);
+}
+
+int
+lpfc_sli_abort_iocb_ctx(lpfcHBA_t * phba, LPFC_SLI_RING_t * pring, uint32_t ctx)
+{
+	LPFC_SLI_t *psli;
+	LPFC_IOCBQ_t *iocb, *next_iocb;
+	LPFC_IOCBQ_t *abtsiocbp;
+	IOCB_t *icmd = 0, *cmd = 0;
+	int errcnt;
+	struct list_head *curr, *next;
+
+	psli = &phba->sli;
+	errcnt = 0;
+
+	/* Error matching iocb on txq or txcmplq 
+	 * First check the txq.
+	 */
+	list_for_each_safe(curr, next, &pring->txq) {
+		next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+		iocb = next_iocb;
+		cmd = &iocb->iocb;
+		if (cmd->ulpContext != ctx) {
+			continue;
+		}
+
+		list_del(&iocb->list);
+		pring->txq_cnt--;
+		if (iocb->iocb_cmpl) {
+			icmd = &iocb->iocb;
+			icmd->ulpStatus = IOSTAT_LOCAL_REJECT;
+			icmd->un.ulpWord[4] = IOERR_SLI_ABORTED;
+			(iocb->iocb_cmpl) (phba, iocb, iocb);
+		} else {
+			lpfc_iocb_free(phba, iocb);
+		}
+	}
+
+	/* Next check the txcmplq */
+	list_for_each_safe(curr, next, &pring->txcmplq) {
+		next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+		iocb = next_iocb;
+		cmd = &iocb->iocb;
+		if (cmd->ulpContext != ctx) {
+			continue;
+		}
+
+		/* issue ABTS for this IOCB based on iotag */
+		if ((abtsiocbp = lpfc_iocb_alloc(phba, MEM_PRI)) == 0) {
+			errcnt++;
+			continue;
+		}
+		memset(abtsiocbp, 0, sizeof (LPFC_IOCBQ_t));
+		icmd = &abtsiocbp->iocb;
+
+		icmd->un.acxri.abortType = ABORT_TYPE_ABTS;
+		icmd->un.acxri.abortContextTag = cmd->ulpContext;
+		icmd->un.acxri.abortIoTag = cmd->ulpIoTag;
+
+		icmd->ulpLe = 1;
+		icmd->ulpClass = cmd->ulpClass;
+		if (phba->hba_state >= LPFC_LINK_UP) {
+			icmd->ulpCommand = CMD_ABORT_XRI_CN;
+		} else {
+			icmd->ulpCommand = CMD_CLOSE_XRI_CN;
+		}
+
+		/* set up an iotag  */
+		icmd->ulpIoTag = lpfc_sli_next_iotag(phba, pring);
+
+		if (lpfc_sli_issue_iocb
+		    (phba, pring, abtsiocbp, SLI_IOCB_USE_TXQ)
+		    == IOCB_ERROR) {
+			lpfc_iocb_free(phba, abtsiocbp);
+			errcnt++;
+			continue;
+		}
+		/* The rsp ring completion will remove IOCB from txcmplq when 
+		 * abort is read by HBA.
+		 */
+	}
+	return (errcnt);
+}
+
+int
+lpfc_sli_abort_iocb_context1(lpfcHBA_t * phba, LPFC_SLI_RING_t * pring,
+			     void *ctx)
+{
+	LPFC_SLI_t *psli;
+	LPFC_IOCBQ_t *iocb, *next_iocb;
+	LPFC_IOCBQ_t *abtsiocbp;
+	IOCB_t *icmd = 0, *cmd = 0;
+	int errcnt;
+	struct list_head *curr, *next;
+
+	psli = &phba->sli;
+	errcnt = 0;
+
+	/* Error matching iocb on txq or txcmplq 
+	 * First check the txq.
+	 */
+	list_for_each_safe(curr, next, &pring->txq) {
+		next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+		iocb = next_iocb;
+		cmd = &iocb->iocb;
+		if (iocb->context1 != ctx) {
+			continue;
+		}
+
+		list_del(&iocb->list);
+		pring->txq_cnt--;
+		if (iocb->iocb_cmpl) {
+			icmd = &iocb->iocb;
+			icmd->ulpStatus = IOSTAT_LOCAL_REJECT;
+			icmd->un.ulpWord[4] = IOERR_SLI_ABORTED;
+			(iocb->iocb_cmpl) (phba, iocb, iocb);
+		} else {
+			lpfc_iocb_free(phba, iocb);
+		}
+	}
+
+	/* Next check the txcmplq */
+	list_for_each_safe(curr, next, &pring->txcmplq) {
+		next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+		iocb = next_iocb;
+		cmd = &iocb->iocb;
+		if (iocb->context1 != ctx) {
+			continue;
+		}
+
+		/* issue ABTS for this IOCB based on iotag */
+		if ((abtsiocbp = lpfc_iocb_alloc(phba, MEM_PRI)) == 0) {
+			errcnt++;
+			continue;
+		}
+		memset(abtsiocbp, 0, sizeof (LPFC_IOCBQ_t));
+		icmd = &abtsiocbp->iocb;
+
+		icmd->un.acxri.abortType = ABORT_TYPE_ABTS;
+		icmd->un.acxri.abortContextTag = cmd->ulpContext;
+		icmd->un.acxri.abortIoTag = cmd->ulpIoTag;
+
+		icmd->ulpLe = 1;
+		icmd->ulpClass = cmd->ulpClass;
+		if (phba->hba_state >= LPFC_LINK_UP) {
+			icmd->ulpCommand = CMD_ABORT_XRI_CN;
+		} else {
+			icmd->ulpCommand = CMD_CLOSE_XRI_CN;
+		}
+
+		/* set up an iotag  */
+		icmd->ulpIoTag = lpfc_sli_next_iotag(phba, pring);
+
+		if (lpfc_sli_issue_iocb
+		    (phba, pring, abtsiocbp, SLI_IOCB_USE_TXQ)
+		    == IOCB_ERROR) {
+			lpfc_iocb_free(phba, abtsiocbp);
+			errcnt++;
+			continue;
+		}
+		/* The rsp ring completion will remove IOCB from txcmplq when 
+		 * abort is read by HBA.
+		 */
+	}
+	return (errcnt);
+}
+
+int
+lpfc_sli_abort_iocb_lun(lpfcHBA_t * phba,
+			LPFC_SLI_RING_t * pring,
+			uint16_t scsi_target, uint64_t scsi_lun)
+{
+	LPFC_SLI_t *psli;
+	LPFC_IOCBQ_t *iocb, *next_iocb;
+	LPFC_IOCBQ_t *abtsiocbp;
+	IOCB_t *icmd = 0, *cmd = 0;
+	LPFC_SCSI_BUF_t *lpfc_cmd;
+	int errcnt;
+	struct list_head *curr, *next;
+
+	psli = &phba->sli;
+	errcnt = 0;
+
+	/* Error matching iocb on txq or txcmplq 
+	 * First check the txq.
+	 */
+	list_for_each_safe(curr, next, &pring->txq) {
+		next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+		iocb = next_iocb;
+		cmd = &iocb->iocb;
+
+		/* Must be a FCP command */
+		if ((cmd->ulpCommand != CMD_FCP_ICMND64_CR) &&
+		    (cmd->ulpCommand != CMD_FCP_IWRITE64_CR) &&
+		    (cmd->ulpCommand != CMD_FCP_IREAD64_CR)) {
+			continue;
+		}
+
+		/* context1 MUST be a LPFC_SCSI_BUF_t */
+		lpfc_cmd = (LPFC_SCSI_BUF_t *) (iocb->context1);
+		if ((lpfc_cmd == 0) ||
+		    (lpfc_cmd->scsi_target != scsi_target) ||
+		    (lpfc_cmd->scsi_lun != scsi_lun)) {
+			continue;
+		}
+
+		list_del(&iocb->list);
+		pring->txq_cnt--;
+		if (iocb->iocb_cmpl) {
+			icmd = &iocb->iocb;
+			icmd->ulpStatus = IOSTAT_LOCAL_REJECT;
+			icmd->un.ulpWord[4] = IOERR_SLI_ABORTED;
+			(iocb->iocb_cmpl) (phba, iocb, iocb);
+		} else {
+			lpfc_iocb_free(phba, iocb);
+		}
+	}
+
+	/* Next check the txcmplq */
+	list_for_each_safe(curr, next, &pring->txcmplq) {
+		next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+		iocb = next_iocb;
+		cmd = &iocb->iocb;
+
+		/* Must be a FCP command */
+		if ((cmd->ulpCommand != CMD_FCP_ICMND64_CR) &&
+		    (cmd->ulpCommand != CMD_FCP_IWRITE64_CR) &&
+		    (cmd->ulpCommand != CMD_FCP_IREAD64_CR)) {
+			continue;
+		}
+
+		/* context1 MUST be a LPFC_SCSI_BUF_t */
+		lpfc_cmd = (LPFC_SCSI_BUF_t *) (iocb->context1);
+		if ((lpfc_cmd == 0) ||
+		    (lpfc_cmd->scsi_target != scsi_target) ||
+		    (lpfc_cmd->scsi_lun != scsi_lun)) {
+			continue;
+		}
+
+		/* issue ABTS for this IOCB based on iotag */
+		if ((abtsiocbp = lpfc_iocb_alloc(phba, MEM_PRI)) == 0) {
+			errcnt++;
+			continue;
+		}
+		memset(abtsiocbp, 0, sizeof (LPFC_IOCBQ_t));
+		icmd = &abtsiocbp->iocb;
+
+		icmd->un.acxri.abortType = ABORT_TYPE_ABTS;
+		icmd->un.acxri.abortContextTag = cmd->ulpContext;
+		icmd->un.acxri.abortIoTag = cmd->ulpIoTag;
+
+		icmd->ulpLe = 1;
+		icmd->ulpClass = cmd->ulpClass;
+		if (phba->hba_state >= LPFC_LINK_UP) {
+			icmd->ulpCommand = CMD_ABORT_XRI_CN;
+		} else {
+			icmd->ulpCommand = CMD_CLOSE_XRI_CN;
+		}
+
+		/* set up an iotag  */
+		icmd->ulpIoTag = lpfc_sli_next_iotag(phba, pring);
+
+		if (lpfc_sli_issue_iocb
+		    (phba, pring, abtsiocbp, SLI_IOCB_USE_TXQ)
+		    == IOCB_ERROR) {
+			lpfc_iocb_free(phba, abtsiocbp);
+			errcnt++;
+			continue;
+		}
+		/* The rsp ring completion will remove IOCB from txcmplq when 
+		 * abort is read by HBA.
+		 */
+	}
+	return (errcnt);
+}
+
+int
+lpfc_sli_abort_iocb_tgt(lpfcHBA_t * phba,
+			LPFC_SLI_RING_t * pring, uint16_t scsi_target)
+{
+	LPFC_SLI_t *psli;
+	LPFC_IOCBQ_t *iocb, *next_iocb;
+	LPFC_IOCBQ_t *abtsiocbp;
+	IOCB_t *icmd = 0, *cmd = 0;
+	LPFC_SCSI_BUF_t *lpfc_cmd;
+	int errcnt;
+	struct list_head *curr, *next;
+
+	psli = &phba->sli;
+	errcnt = 0;
+
+	/* Error matching iocb on txq or txcmplq 
+	 * First check the txq.
+	 */
+	list_for_each_safe(curr, next, &pring->txq) {
+		next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+		iocb = next_iocb;
+		cmd = &iocb->iocb;
+
+		/* Must be a FCP command */
+		if ((cmd->ulpCommand != CMD_FCP_ICMND64_CR) &&
+		    (cmd->ulpCommand != CMD_FCP_IWRITE64_CR) &&
+		    (cmd->ulpCommand != CMD_FCP_IREAD64_CR)) {
+			continue;
+		}
+
+		/* context1 MUST be a LPFC_SCSI_BUF_t */
+		lpfc_cmd = (LPFC_SCSI_BUF_t *) (iocb->context1);
+		if ((lpfc_cmd == 0) || (lpfc_cmd->scsi_target != scsi_target)) {
+			continue;
+		}
+
+		list_del(&iocb->list);
+		pring->txq_cnt--;
+		if (iocb->iocb_cmpl) {
+			icmd = &iocb->iocb;
+			icmd->ulpStatus = IOSTAT_LOCAL_REJECT;
+			icmd->un.ulpWord[4] = IOERR_SLI_ABORTED;
+			(iocb->iocb_cmpl) (phba, iocb, iocb);
+		} else {
+			lpfc_iocb_free(phba, iocb);
+		}
+	}
+
+	/* Next check the txcmplq */
+	list_for_each_safe(curr, next, &pring->txcmplq) {
+
+		next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+		iocb = next_iocb;
+		cmd = &iocb->iocb;
+
+		/* Must be a FCP command */
+		if ((cmd->ulpCommand != CMD_FCP_ICMND64_CR) &&
+		    (cmd->ulpCommand != CMD_FCP_IWRITE64_CR) &&
+		    (cmd->ulpCommand != CMD_FCP_IREAD64_CR)) {
+			continue;
+		}
+
+		/* context1 MUST be a LPFC_SCSI_BUF_t */
+		lpfc_cmd = (LPFC_SCSI_BUF_t *) (iocb->context1);
+		if ((lpfc_cmd == 0) || (lpfc_cmd->scsi_target != scsi_target)) {
+			continue;
+		}
+
+		/* issue ABTS for this IOCB based on iotag */
+		if ((abtsiocbp = lpfc_iocb_alloc(phba, MEM_PRI)) == 0) {
+			errcnt++;
+			continue;
+		}
+		memset(abtsiocbp, 0, sizeof (LPFC_IOCBQ_t));
+		icmd = &abtsiocbp->iocb;
+
+		icmd->un.acxri.abortType = ABORT_TYPE_ABTS;
+		icmd->un.acxri.abortContextTag = cmd->ulpContext;
+		icmd->un.acxri.abortIoTag = cmd->ulpIoTag;
+
+		icmd->ulpLe = 1;
+		icmd->ulpClass = cmd->ulpClass;
+		if (phba->hba_state >= LPFC_LINK_UP) {
+			icmd->ulpCommand = CMD_ABORT_XRI_CN;
+		} else {
+			icmd->ulpCommand = CMD_CLOSE_XRI_CN;
+		}
+
+		/* set up an iotag  */
+		icmd->ulpIoTag = lpfc_sli_next_iotag(phba, pring);
+
+		if (lpfc_sli_issue_iocb
+		    (phba, pring, abtsiocbp, SLI_IOCB_USE_TXQ)
+		    == IOCB_ERROR) {
+			lpfc_iocb_free(phba, abtsiocbp);
+			errcnt++;
+			continue;
+		}
+		/* The rsp ring completion will remove IOCB from txcmplq when 
+		 * abort is read by HBA.
+		 */
+	}
+	return (errcnt);
+}
+
+int
+lpfc_sli_abort_iocb_hba(lpfcHBA_t * phba, LPFC_SLI_RING_t * pring)
+{
+	LPFC_SLI_t *psli;
+	LPFC_IOCBQ_t *iocb, *next_iocb;
+	LPFC_IOCBQ_t *abtsiocbp;
+	IOCB_t *icmd = 0, *cmd = 0;
+	LPFC_SCSI_BUF_t *lpfc_cmd;
+	int errcnt;
+	struct list_head *curr, *next;
+
+	psli = &phba->sli;
+	errcnt = 0;
+
+	/* Error matching iocb on txq or txcmplq 
+	 * First check the txq.
+	 */
+	list_for_each_safe(curr, next, &pring->txq) {
+		next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+		iocb = next_iocb;
+		cmd = &iocb->iocb;
+
+		/* Must be a FCP command */
+		if ((cmd->ulpCommand != CMD_FCP_ICMND64_CR) &&
+		    (cmd->ulpCommand != CMD_FCP_IWRITE64_CR) &&
+		    (cmd->ulpCommand != CMD_FCP_IREAD64_CR)) {
+			continue;
+		}
+
+		/* context1 MUST be a LPFC_SCSI_BUF_t */
+		lpfc_cmd = (LPFC_SCSI_BUF_t *) (iocb->context1);
+		if (lpfc_cmd == 0) {
+			continue;
+		}
+
+		list_del(&iocb->list);
+		pring->txq_cnt--;
+		if (iocb->iocb_cmpl) {
+			icmd = &iocb->iocb;
+			icmd->ulpStatus = IOSTAT_LOCAL_REJECT;
+			icmd->un.ulpWord[4] = IOERR_SLI_ABORTED;
+			(iocb->iocb_cmpl) (phba, iocb, iocb);
+		} else {
+			lpfc_iocb_free(phba, iocb);
+		}
+	}
+
+	/* Next check the txcmplq */
+	list_for_each_safe(curr, next, &pring->txcmplq) {
+		next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+		iocb = next_iocb;
+		cmd = &iocb->iocb;
+
+		/* Must be a FCP command */
+		if ((cmd->ulpCommand != CMD_FCP_ICMND64_CR) &&
+		    (cmd->ulpCommand != CMD_FCP_IWRITE64_CR) &&
+		    (cmd->ulpCommand != CMD_FCP_IREAD64_CR)) {
+			continue;
+		}
+
+		/* context1 MUST be a LPFC_SCSI_BUF_t */
+		lpfc_cmd = (LPFC_SCSI_BUF_t *) (iocb->context1);
+		if (lpfc_cmd == 0) {
+			continue;
+		}
+
+		/* issue ABTS for this IOCB based on iotag */
+		if ((abtsiocbp = lpfc_iocb_alloc(phba, MEM_PRI)) == 0) {
+			errcnt++;
+			continue;
+		}
+		memset(abtsiocbp, 0, sizeof (LPFC_IOCBQ_t));
+		icmd = &abtsiocbp->iocb;
+
+		icmd->un.acxri.abortType = ABORT_TYPE_ABTS;
+		icmd->un.acxri.abortContextTag = cmd->ulpContext;
+		icmd->un.acxri.abortIoTag = cmd->ulpIoTag;
+
+		icmd->ulpLe = 1;
+		icmd->ulpClass = cmd->ulpClass;
+		if (phba->hba_state >= LPFC_LINK_UP) {
+			icmd->ulpCommand = CMD_ABORT_XRI_CN;
+		} else {
+			icmd->ulpCommand = CMD_CLOSE_XRI_CN;
+		}
+
+		/* set up an iotag  */
+		icmd->ulpIoTag = lpfc_sli_next_iotag(phba, pring);
+
+		if (lpfc_sli_issue_iocb
+		    (phba, pring, abtsiocbp, SLI_IOCB_USE_TXQ)
+		    == IOCB_ERROR) {
+			lpfc_iocb_free(phba, abtsiocbp);
+			errcnt++;
+			continue;
+		}
+		/* The rsp ring completion will remove IOCB from txcmplq when 
+		 * abort is read by HBA.
+		 */
+	}
+	return (errcnt);
+}
+
+void
+lpfc_sli_wake_iocb_wait(lpfcHBA_t * phba,
+			LPFC_IOCBQ_t * queue1, LPFC_IOCBQ_t * queue2)
+{
+	wait_queue_head_t *pdone_q;
+
+	queue1->iocb_flag |= LPFC_IO_WAIT;
+	if (queue1->context2 && queue2)
+		memcpy(queue1->context2, queue2, sizeof (LPFC_IOCBQ_t));
+	pdone_q = queue1->context_un.hipri_wait_queue;
+	if (pdone_q) {
+		wake_up(pdone_q);
+	}
+	/* if pdone_q/ was NULL, it means the waiter already gave
+	   up and returned, so we don't have to do anything */
+
+	return;
+}
+
+int
+lpfc_sli_issue_iocb_wait(lpfcHBA_t * phba,
+			 LPFC_SLI_RING_t * pring,
+			 LPFC_IOCBQ_t * piocb,
+			 uint32_t flag,
+			 LPFC_IOCBQ_t * prspiocbq, uint32_t timeout)
+{
+	DECLARE_WAIT_QUEUE_HEAD(done_q);
+	DECLARE_WAITQUEUE(wq_entry, current);
+	uint32_t timeleft = 0;
+	int retval;
+	unsigned long iflag = phba->iflag;
+
+	/* The caller must leave context1 empty for the driver. */
+	if (piocb->context_un.hipri_wait_queue != 0) {
+		return (IOCB_ERROR);
+	}
+	/* If the caller has provided a response iocbq buffer, then context2 
+	 * is NULL or its an error.
+	 */
+	if (prspiocbq) {
+		if (piocb->context2) {
+			return (IOCB_ERROR);
+		}
+		piocb->context2 = prspiocbq;
+	}
+
+	/* setup wake call as IOCB callback */
+	piocb->iocb_cmpl = lpfc_sli_wake_iocb_wait;
+	/* setup context field to pass wait_queue pointer to wake function  */
+	piocb->context_un.hipri_wait_queue = &done_q;
+
+	/* start to sleep before we wait, to avoid races */
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	add_wait_queue(&done_q, &wq_entry);
+
+	/* now issue the command */
+	retval = lpfc_sli_issue_iocb(phba, pring, piocb, flag);
+	if ((retval == IOCB_SUCCESS) ||
+	    ((!(flag & SLI_IOCB_RET_IOCB)) && retval == IOCB_BUSY)) {
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		timeleft = schedule_timeout(timeout * HZ);
+		LPFC_DRVR_LOCK(phba, iflag);
+		piocb->context_un.hipri_wait_queue = 0;	/* prevents completion
+							   function from
+							   signalling */
+		piocb->iocb_cmpl = 0;
+		if (piocb->context2 == prspiocbq)
+			piocb->context2 = 0;
+
+		/* if schedule_timeout returns 0, we timed out and were not
+		 * woken up if LPFC_IO_WAIT is not set, we go woken up by a
+		 * signal.
+		 */
+		if ((timeleft == 0) || !(piocb->iocb_flag & LPFC_IO_WAIT)) {
+			if (timeleft == 0)
+				retval = IOCB_TIMEDOUT;
+
+			if (piocb->list.next && piocb->list.prev)
+				list_del((struct list_head *)piocb);
+		}
+	}
+	remove_wait_queue(&done_q, &wq_entry);
+	set_current_state(TASK_RUNNING);
+	return retval;
+}
+
+void
+lpfc_sli_wake_iocb_high_priority(lpfcHBA_t * phba,
+				 LPFC_IOCBQ_t * queue1, LPFC_IOCBQ_t * queue2)
+{
+	if (queue1->context2 && queue2)
+		memcpy(queue1->context2, queue2, sizeof (LPFC_IOCBQ_t));
+
+	/* The waiter is looking for LPFC_IO_HIPRI bit to be set 
+	   as a signal to wake up */
+	queue1->iocb_flag |= LPFC_IO_HIPRI;
+
+	return;
+}
+
+int
+lpfc_sli_issue_iocb_wait_high_priority(lpfcHBA_t * phba,
+				       LPFC_SLI_RING_t * pring,
+				       LPFC_IOCBQ_t * piocb,
+				       uint32_t flag,
+				       LPFC_IOCBQ_t * prspiocbq,
+				       uint32_t timeout)
+{
+	int j, delay_time, retval = IOCB_ERROR;
+	unsigned long drvr_flag = phba->iflag;
+	unsigned long iflag;
+
+	/* The caller must left context1 empty.  */
+	if (piocb->context_un.hipri_wait_queue != 0) {
+		return (IOCB_ERROR);
+	}
+	/* If the caller has provided a response iocbq buffer, context2 is NULL
+	 * or its an error.
+	 */
+	if (prspiocbq) {
+		if (piocb->context2) {
+			return (IOCB_ERROR);
+		}
+		piocb->context2 = prspiocbq;
+	}
+
+	piocb->context3 = 0;
+	/* setup wake call as IOCB callback */
+	piocb->iocb_cmpl = lpfc_sli_wake_iocb_high_priority;
+
+	/* now issue the command */
+	retval =
+	    lpfc_sli_issue_iocb(phba, pring, piocb,
+				flag | SLI_IOCB_HIGH_PRIORITY);
+
+ 	if (retval != IOCB_SUCCESS) {
+		piocb->context2 = 0;
+		return IOCB_ERROR;
+	}
+
+
+	/*
+	 * This high-priority iocb was sent out-of-band.  Poll for its 
+	 * completion rather than wait for a signal.  Note that the host_lock
+	 * is held by the midlayer and must be released here to allow the 
+	 * interrupt handlers to complete the IO and signal this routine via 
+	 * the iocb_flag.
+	 * Also, the delay_time is computed to be one second longer than
+	 * the scsi command timeout to give the FW time to abort on 
+	 * timeout rather than the driver just giving up.  Typically,
+	 * the midlayer does not specify a time for this command so the
+	 * driver is free to enforce its own timeout.
+	 */
+
+	retval = IOCB_ERROR;
+	delay_time = ((timeout + 1) * 1000) >> 6; 
+	for (j = 0; j < 64; j++) {
+		LPFC_DRVR_UNLOCK(phba, drvr_flag);
+		mdelay(delay_time);
+		LPFC_DRVR_LOCK(phba, drvr_flag);
+
+		spin_lock_irqsave(&phba->hiprilock, iflag);
+		if (piocb->iocb_flag & LPFC_IO_HIPRI) {
+			piocb->iocb_flag &= ~LPFC_IO_HIPRI;
+			retval = IOCB_SUCCESS;
+			spin_unlock_irqrestore(&phba->hiprilock, iflag);
+			break;
+		}
+		spin_unlock_irqrestore(&phba->hiprilock, iflag);
+	}
+
+	piocb->context2 = 0;
+	piocb->context3 = 0;
+
+	return retval;
+}
+
+void
+lpfc_sli_wake_mbox_wait(lpfcHBA_t * phba, LPFC_MBOXQ_t * pmboxq)
+{
+	wait_queue_head_t *pdone_q;
+
+	pdone_q = (wait_queue_head_t *) pmboxq->context1;
+	if (pdone_q)
+		wake_up_interruptible(pdone_q);
+	/* if pdone_q was NULL, it means the waiter already gave
+	   up and returned, so we don't have to do anything */
+
+	return;
+}
+
+int
+lpfc_sli_issue_mbox_wait(lpfcHBA_t * phba, LPFC_MBOXQ_t * pmboxq,
+			 uint32_t timeout)
+{
+	DECLARE_WAIT_QUEUE_HEAD(done_q);
+	DECLARE_WAITQUEUE(wq_entry, current);
+	uint32_t timeleft = 0;
+	int retval;
+	unsigned long iflag = phba->iflag;
+
+	/* The caller must leave context1 empty. */
+	if (pmboxq->context1 != 0) {
+		return (MBX_NOT_FINISHED);
+	}
+
+	/* setup wake call as IOCB callback */
+	pmboxq->mbox_cmpl = lpfc_sli_wake_mbox_wait;
+	/* setup context field to pass wait_queue pointer to wake function  */
+	pmboxq->context1 = &done_q;
+
+	/* start to sleep before we wait, to avoid races */
+	set_current_state(TASK_INTERRUPTIBLE);
+	add_wait_queue(&done_q, &wq_entry);
+
+	/* now issue the command */
+	retval = lpfc_sli_issue_mbox(phba, pmboxq, MBX_NOWAIT);
+	if (retval == MBX_BUSY || retval == MBX_SUCCESS) {
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		timeleft = schedule_timeout(timeout * HZ);
+		LPFC_DRVR_LOCK(phba, iflag);
+		pmboxq->context1 = 0;
+		/* if schedule_timeout returns 0, we timed out and were not
+		   woken up */
+		if ((timeleft == 0) || signal_pending(current))
+			retval = MBX_TIMEOUT;
+		else
+			retval = MBX_SUCCESS;
+	}
+
+
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&done_q, &wq_entry);
+	return retval;
+}
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_sli.h linux-8155/drivers/addon/lpfc/lpfc_sli.h
--- linux-8152/drivers/addon/lpfc/lpfc_sli.h
+++ linux-8155/drivers/addon/lpfc/lpfc_sli.h
@@ -0,0 +1,214 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_sli.h 328 2005-05-03 15:20:43Z sf_support $
+ */
+
+#ifndef _H_LPFC_SLI
+#define _H_LPFC_SLI
+
+#define IOCB_CMD_WSIZE  8	/* Length, in words, of a IOCB command */
+#define MBOX_CMD_WSIZE  32	/* max length, in words, of a mailbox command */
+
+/* forward declaration for LPFC_IOCB_t's use */
+struct lpfcHBA;
+
+/* This structure is used to handle IOCB requests / responses */
+typedef struct lpfcIocbq {
+	/* IOCBQs are used in double linked lists */
+	struct list_head list;
+	IOCB_t iocb;		/* IOCB cmd */
+	uint8_t retry;		/* retry counter for IOCB cmd - if needed */
+	uint8_t iocb_flag;
+#define LPFC_IO_POLL	1	/* Polling mode iocb */
+#define LPFC_IO_LIBDFC	2	/* libdfc iocb */
+#define LPFC_IO_WAIT	4
+#define LPFC_IO_HIPRI	8	/* High Priority Queue signal flag */
+
+	uint8_t abort_count;
+	uint8_t rsvd2;
+	uint32_t drvrTimeout;	/* driver timeout in seconds */
+	void *context1;		/* caller context information */
+	void *context2;		/* caller context information */
+	void *context3;		/* caller context information */
+	union {
+		wait_queue_head_t *hipri_wait_queue; /* High Priority Queue wait
+							queue */
+		struct lpfcIocbq   *rsp_iocb;
+		struct lpfcMboxq   *mbox;
+	} context_un; 
+
+	void (*iocb_cmpl) (struct lpfcHBA *, struct lpfcIocbq *,
+			   struct lpfcIocbq *);
+
+} LPFC_IOCBQ_t;
+
+#define SLI_IOCB_USE_TXQ       1	/* Queue IOCB to txq if cmd ring full */
+#define SLI_IOCB_RET_IOCB      2	/* Return IOCB if cmd ring full */
+#define SLI_IOCB_POLL          4	/* poll for completion */
+#define SLI_IOCB_HIGH_PRIORITY 8	/* High priority command */
+
+#define IOCB_SUCCESS        0
+#define IOCB_BUSY           1
+#define IOCB_ERROR          2
+#define IOCB_TIMEDOUT       3
+
+typedef struct lpfcMboxq {
+	/* MBOXQs are used in single linked lists */
+	struct list_head list;	/* ptr to next mailbox command */
+	MAILBOX_t mb;		/* Mailbox cmd */
+	void *context1;		/* caller context information */
+	void *context2;		/* caller context information */
+
+	void (*mbox_cmpl) (struct lpfcHBA *, struct lpfcMboxq *);
+
+} LPFC_MBOXQ_t;
+
+#define MBX_POLL        1	/* poll mailbox till command done, then
+				   return */
+#define MBX_NOWAIT      2	/* issue command then return immediately */
+#define MBX_STOP_IOCB   4	/* Stop iocb processing till mbox cmds
+				   complete */
+
+#define LPFC_MAX_RING_MASK  4	/* max num of rctl/type masks allowed per
+				   ring */
+#define LPFC_MAX_RING       4	/* max num of SLI rings used by driver */
+
+/* Structure used to hold SLI ring information */
+typedef struct {
+	uint16_t flag;		/* ring flags */
+#define LPFC_DEFERRED_RING_EVENT 0x001	/* Deferred processing a ring event */
+#define LPFC_CALL_RING_AVAILABLE 0x002	/* indicates cmd was full */
+#define LPFC_STOP_IOCB_MBX       0x010	/* Stop processing IOCB cmds mbox */
+#define LPFC_STOP_IOCB_EVENT     0x020	/* Stop processing IOCB cmds event */
+#define LPFC_STOP_IOCB_MASK      0x030	/* Stop processing IOCB cmds mask */
+	uint16_t abtsiotag;	/* tracks next iotag to use for ABTS */
+
+	uint8_t rsvd;
+	uint8_t ringno;		/* ring number */
+	uint8_t rspidx;		/* current index in response ring */
+	uint8_t cmdidx;		/* current index in command ring */
+	LPFC_IOCBQ_t *fast_lookup;	/* array of IOCB ptrs indexed by
+					   iotag */
+	struct list_head txq;
+	uint16_t txq_cnt;	/* current length of queue */
+	uint16_t txq_max;	/* max length */
+	struct list_head txcmplq;
+	uint16_t txcmplq_cnt;	/* current length of queue */
+	uint16_t txcmplq_max;	/* max length */
+	volatile uint32_t *cmdringaddr;	/* virtual address for cmd rings */
+	volatile uint32_t *rspringaddr;	/* virtual address for rsp rings */
+	uint32_t missbufcnt;	/* keep track of buffers to post */
+	struct list_head postbufq;
+	uint16_t postbufq_cnt;	/* current length of queue */
+	uint16_t postbufq_max;	/* max length */
+	struct list_head iocb_continueq;
+	uint16_t iocb_continueq_cnt;	/* current length of queue */
+	uint16_t iocb_continueq_max;	/* max length */
+} LPFC_SLI_RING_t;
+
+typedef struct {
+	uint8_t profile;	/* profile associated with ring */
+	uint8_t rctl;	/* rctl / type pair configured for ring */
+	uint8_t type;	/* rctl / type pair configured for ring */
+	uint8_t rsvd;
+	/* rcv'd unsol event */
+	void (*lpfc_sli_rcv_unsol_event) (struct lpfcHBA *,
+					 LPFC_SLI_RING_t *,
+					 LPFC_IOCBQ_t *);
+} LPFC_RING_MASK_t;
+
+/* Structure used for configuring rings to a specific profile or rctl / type */
+typedef struct {
+	LPFC_RING_MASK_t prt[LPFC_MAX_RING_MASK];
+	uint32_t num_mask;	/* number of mask entries in prt array */
+	uint32_t iotag_ctr;	/* keeps track of the next iotag to use */
+	uint32_t iotag_max;	/* keeps track of the next iotag to use */
+	uint32_t fast_iotag;	/* fast lookup based on iotag */
+	uint16_t numCiocb;	/* number of command iocb's per ring */
+	uint16_t numRiocb;	/* number of rsp iocb's per ring */
+	/* cmd ring available */
+	void (*lpfc_sli_cmd_available) (struct lpfcHBA *, LPFC_SLI_RING_t *);
+} LPFC_RING_INIT_t;
+
+typedef struct {
+	LPFC_RING_INIT_t ringinit[LPFC_MAX_RING]; /* ring initialization info */
+	uint32_t num_rings;
+	uint32_t sli_flag;
+} LPFC_SLI_INIT_t;
+
+/* Structure used to hold SLI statistical counters and info */
+typedef struct {
+	uint64_t iocbEvent[LPFC_MAX_RING];	/* IOCB event counters */
+	uint64_t iocbCmd[LPFC_MAX_RING];	/* IOCB cmd issued */
+	uint64_t iocbRsp[LPFC_MAX_RING];	/* IOCB rsp received */
+	uint64_t iocbCmdDelay[LPFC_MAX_RING];	/* IOCB cmd ring delay */
+	uint64_t iocbCmdFull[LPFC_MAX_RING];	/* IOCB cmd ring full */
+	uint64_t iocbCmdEmpty[LPFC_MAX_RING];	/* IOCB cmd ring is now empty */
+	uint64_t iocbRspFull[LPFC_MAX_RING];	/* IOCB rsp ring full */
+	uint64_t mboxStatErr;	/* Mbox cmds completed status error */
+	uint64_t mboxCmd;	/* Mailbox commands issued */
+	uint64_t sliIntr;	/* Count of Host Attention interrupts */
+	uint32_t errAttnEvent;	/* Error Attn event counters */
+	uint32_t linkEvent;	/* Link event counters */
+	uint32_t mboxEvent;	/* Mailbox event counters */
+	uint32_t mboxBusy;	/* Mailbox cmd busy */
+} LPFC_SLI_STAT_t;
+
+/* Structure used to hold SLI information */
+typedef struct lpfc_sli {
+	LPFC_SLI_INIT_t sliinit;	/* initialization info */
+	/* Additional sli_flags */
+#define LPFC_SLI_MBOX_ACTIVE      0x100	/* HBA mailbox is currently active */
+#define LPFC_SLI2_ACTIVE          0x200	/* SLI2 overlay in firmware is active */
+#define LPFC_PROCESS_LA           0x400	/* Able to process link attention */
+
+	LPFC_SLI_RING_t ring[LPFC_MAX_RING];
+	int fcp_ring;		/* ring used for FCP initiator commands */
+	int next_ring;
+
+	int ip_ring;		/* ring used for IP network drv cmds */
+
+	LPFC_SLI_STAT_t slistat;	/* SLI statistical info */
+	struct list_head mboxq;
+	uint16_t mboxq_cnt;	/* current length of queue */
+	uint16_t mboxq_max;	/* max length */
+	LPFC_MBOXQ_t *mbox_active;	/* active mboxq information */
+	struct timer_list mbox_tmo;	/* Hold clk to timeout active mbox
+					   cmd */
+
+	volatile uint32_t *MBhostaddr;	/* virtual address for mbox cmds */
+} LPFC_SLI_t;
+
+/* Given a pointer to the start of the ring, and the slot number of
+ * the desired iocb entry, calc a pointer to that entry.
+ * (assume iocb entry size is 32 bytes, or 8 words)
+ */
+#define IOCB_ENTRY(ring,slot) ((IOCB_t *)(((char *)(ring)) + ((slot) * 32)))
+
+#define LPFC_SLI_ABORT_WAIT	0	/* Wait for rsp ring completion of
+					   IOCBs */
+#define LPFC_SLI_ABORT_IMED	0	/* Immediate abort of IOCB, deque and
+					   call compl routine immediately. */
+#define LPFC_MBOX_TMO           30	/* Sec tmo for outstanding mbox
+					   command */
+
+#endif				/* _H_LPFC_SLI */
diff -urNp linux-8152/drivers/addon/lpfc/lpfc_version.h linux-8155/drivers/addon/lpfc/lpfc_version.h
--- linux-8152/drivers/addon/lpfc/lpfc_version.h
+++ linux-8155/drivers/addon/lpfc/lpfc_version.h
@@ -0,0 +1,30 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_version.h 503 2006-04-04 17:48:43Z sf_support $
+ */
+
+#define LPFC_DRIVER_VERSION "7.3.6"
+
+#define LPFC_DRIVER_NAME "lpfc"
+
+#define LPFC_MODULE_DESC "Emulex LightPulse FC SCSI " LPFC_DRIVER_VERSION
+#define LPFC_COPYRIGHT "Copyright(c) 2003-2005 Emulex.  All rights reserved."
