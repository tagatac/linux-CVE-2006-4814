diff -urNp linux-6000/drivers/block/blkpg.c linux-6010/drivers/block/blkpg.c
--- linux-6000/drivers/block/blkpg.c
+++ linux-6010/drivers/block/blkpg.c
@@ -59,6 +59,11 @@ void diskdump_unregister_hook(void)
 	diskdump_func = NULL;
 }
 
+#if defined(CONFIG_IA64) 
+static int set_last_sector( kdev_t dev, const void *param );
+static int get_last_sector( kdev_t dev, const void *param );
+#endif
+
 /*
  * What is the data describing a partition?
  *
@@ -225,6 +230,19 @@ int blk_ioctl(kdev_t dev, unsigned int c
 		return -EINVAL;
 
 	switch (cmd) {
+#if defined(CONFIG_IA64)
+		case BLKGETLASTSECT:
+			if (!capable(CAP_SYS_ADMIN))
+				return -EACCES;
+			return get_last_sector(dev, (char *)(arg));
+
+		case BLKSETLASTSECT:
+			if( is_read_only(dev) )
+				return -EACCES;
+			if (!capable(CAP_SYS_ADMIN))
+				return -EACCES;
+			return set_last_sector(dev, (char *)(arg));
+#endif
 		case BLKROSET:
 			if (!capable(CAP_SYS_ADMIN))
 				return -EACCES;
@@ -316,3 +334,223 @@ int blk_ioctl(kdev_t dev, unsigned int c
 }
 
 EXPORT_SYMBOL(blk_ioctl);
+
+#if defined(CONFIG_IA64)
+
+ /*********************
+  * get_last_sector()
+  *  
+  * Description: This function will read any inaccessible blocks at the end
+  * 	of a device
+  * Why: Normal read/write calls through the block layer will not read the 
+  *      last sector of an odd-size disk. 
+  * parameters: 
+  *    dev: kdev_t -- which device to read
+  *    param: a pointer to a userspace struct. The struct has these members: 
+  *	block:  an int which denotes which block to return:
+  *		0 == Last block
+  * 		1 == Last block - 1
+  * 		n == Last block - n
+  *		This is validated so that only values of 
+  *		  <= ((total_sects + 1) % logical_block_size)  ||  0
+  *		  are allowed.
+  * 	block_contents: a pointer to userspace char*, this is where we write 
+  *	 returned blocks to.
+  * 	content_length: How big the userspace buffer is.
+  * return: 
+  *    0 on success
+  *   -ERRVAL on error.
+  *********************/
+int get_last_sector( kdev_t dev, const void *param )
+{   
+        struct buffer_head *bh;
+        struct gendisk *g;
+        int rc = 0;
+        unsigned int lastlba, readlba;
+        int orig_blksize = BLOCK_SIZE;
+        int hardblocksize;
+
+	struct {
+		unsigned int block;
+		size_t content_length;
+		char *block_contents;
+	} blk_ioctl_parameter;
+
+        if( !dev ) return -EINVAL;
+
+        if(copy_from_user(&blk_ioctl_parameter, param, sizeof(blk_ioctl_parameter)))
+		return -EFAULT;
+
+        g = get_gendisk( dev );
+
+        if( !g ) return -EINVAL;
+
+        lastlba = g->part[MINOR(dev)].nr_sects;
+
+        if( !lastlba ) return -EINVAL;
+
+        hardblocksize = get_hardsect_size(dev);
+        if( ! hardblocksize ) hardblocksize = 512;
+
+         /* Need to change the block size that the block layer uses */
+        if (blksize_size[MAJOR(dev)]){
+                orig_blksize = blksize_size[MAJOR(dev)][MINOR(dev)];
+        }
+
+         /* validate userspace input */
+        if( blk_ioctl_parameter.block == 0 )
+		goto good_params;
+
+	/* so we don't divide by zero below */  
+	if(orig_blksize == 0) 
+		return -EINVAL; 
+
+        if( blk_ioctl_parameter.block <= (lastlba % (orig_blksize / hardblocksize)))
+		goto good_params;
+
+	return -EINVAL; 
+
+good_params:
+        readlba = lastlba - blk_ioctl_parameter.block - 1;
+
+        if (orig_blksize != hardblocksize)
+                   set_blocksize(dev, hardblocksize);
+
+        bh =  bread(dev, readlba, hardblocksize);
+        if (!bh) {
+		/* We hit the end of the disk */
+		printk(KERN_WARNING
+			"get_last_sector ioctl: bread returned NULL.\n");
+		rc = -EIO;
+		goto out;
+        }
+
+	if (copy_to_user(blk_ioctl_parameter.block_contents, bh->b_data, 
+		(bh->b_size > blk_ioctl_parameter.content_length) ? 
+		blk_ioctl_parameter.content_length : bh->b_size))
+		rc = -EFAULT;
+
+out:
+        brelse(bh);
+
+        /* change block size back */
+        if (orig_blksize != hardblocksize)
+                   set_blocksize(dev, orig_blksize);
+   
+        return rc;
+}
+
+ /*********************
+  * set_last_sector()
+  *  
+  * Description: This function will write to any inaccessible blocks at the end
+  * 	of a device
+  * Why: Normal read/write calls through the block layer will not read the 
+  *      last sector of an odd-size disk. 
+  * parameters: 
+  *    dev: kdev_t -- which device to read
+  *    sect: a pointer to a userspace struct. The struct has these members: 
+  *	block:  an int which denotes which block to return:
+  *		0 == Last block
+  * 		1 == Last block - 1
+  * 		n == Last block - n
+  *		This is validated so that only values of 
+  *		  <= ((total_sects + 1) % logical_block_size)  ||  0
+  *		  are allowed.
+  * 	block_contents: a pointer to userspace char*, this is where we write 
+  *	 returned blocks to.
+  * 	content_length: How big the userspace buffer is.
+  * return: 
+  *    0 on success
+  *   -ERRVAL on error.
+  *********************/
+int set_last_sector( kdev_t dev, const void *param ) 
+{
+        struct buffer_head *bh;
+        struct gendisk *g;
+        int rc = 0;
+        unsigned int lastlba, writelba;
+        int orig_blksize = BLOCK_SIZE;
+        int hardblocksize;
+
+	struct {
+		unsigned int block;
+		size_t content_length;
+		char *block_contents;
+	} blk_ioctl_parameter;
+
+        if( !dev ) return -EINVAL;
+
+	if(copy_from_user(&blk_ioctl_parameter, param, sizeof(blk_ioctl_parameter)))
+		return -EFAULT;
+
+        g = get_gendisk( dev );
+
+        if( !g ) return -EINVAL;
+    
+        lastlba = g->part[MINOR(dev)].nr_sects ;
+    
+        if( !lastlba ) return -EINVAL;
+    
+        hardblocksize = get_hardsect_size(dev);
+        if( ! hardblocksize ) hardblocksize = 512;
+    
+         /* Need to change the block size that the block layer uses */
+        if (blksize_size[MAJOR(dev)]){
+                orig_blksize = blksize_size[MAJOR(dev)][MINOR(dev)];
+        }
+
+         /* validate userspace input */
+        if( blk_ioctl_parameter.block == 0 )
+		goto good_params;
+
+	/* so we don't divide by zero below */  
+	if(orig_blksize == 0) 
+		return -EINVAL; 
+
+        if( blk_ioctl_parameter.block <= (lastlba % (orig_blksize / hardblocksize)))
+		goto good_params;
+
+	return -EINVAL; 
+
+good_params:
+        writelba = lastlba - blk_ioctl_parameter.block - 1;
+
+        if (orig_blksize != hardblocksize)
+                 set_blocksize(dev, hardblocksize);
+    
+        bh =  bread(dev, writelba, hardblocksize);
+        if (!bh) {
+		/* We hit the end of the disk */
+		printk(KERN_WARNING
+			"get_last_sector ioctl: getblk returned NULL.\n");
+		rc = -EIO;
+		goto out;
+        }
+    
+        if (copy_from_user(bh->b_data, blk_ioctl_parameter.block_contents, 
+		(bh->b_size > blk_ioctl_parameter.content_length) ? 
+		blk_ioctl_parameter.content_length : bh->b_size)) {
+		rc = -EFAULT;
+		goto out_brelse;
+	}
+    
+        mark_buffer_dirty(bh);
+        ll_rw_block (WRITE, 1, &bh);
+        wait_on_buffer (bh);
+        if (!buffer_uptodate(bh))
+		rc = -EIO; 
+    
+out_brelse:
+        brelse(bh);
+    
+out:
+        /* change block size back */
+        if (orig_blksize != hardblocksize)
+                 set_blocksize(dev, orig_blksize);
+       
+       return rc;
+}
+
+#endif /* CONFIG_IA64 */
+
diff -urNp linux-6000/drivers/ide/ide.c linux-6010/drivers/ide/ide.c
--- linux-6000/drivers/ide/ide.c
+++ linux-6010/drivers/ide/ide.c
@@ -1717,6 +1717,10 @@ static int ide_ioctl (struct inode *inod
 			}
 			return 0;
 		}
+#if defined(CONFIG_IA64)
+ 		case BLKGETLASTSECT:
+ 		case BLKSETLASTSECT:
+#endif
 		case BLKROSET:
 		case BLKROGET:
 		case BLKFLSBUF:
diff -urNp linux-6000/drivers/scsi/sd.c linux-6010/drivers/scsi/sd.c
--- linux-6000/drivers/scsi/sd.c
+++ linux-6010/drivers/scsi/sd.c
@@ -275,6 +275,10 @@ static int sd_ioctl(struct inode * inode
 		}
 		case BLKGETSIZE:
 		case BLKGETSIZE64:
+#if defined(CONFIG_IA64)
+ 		case BLKGETLASTSECT:
+ 		case BLKSETLASTSECT:
+#endif
 		case BLKROSET:
 		case BLKROGET:
 		case BLKRASET:
diff -urNp linux-6000/include/linux/fs.h linux-6010/include/linux/fs.h
--- linux-6000/include/linux/fs.h
+++ linux-6010/include/linux/fs.h
@@ -189,6 +189,18 @@ extern int leases_enable, dir_notify_ena
    probably all these _IO(0x12,*) ioctls should be moved to blkpg.h. */
 #endif
 /* A jump here: 108-111 have been used for various private purposes. */
+
+/* ioctls 108 and 109 allow reading and writing the last 
+ * sector of a disk. Odd-sectored disks are not visisble via the filesytem 
+ * layer. gpt partitions, used on ia64, needs to read and write these sectors.  
+ * These ioctl numbers are not implemented upstream. Thus, we only enable 
+ * them for ia64 */
+
+#if defined(CONFIG_IA64)
+#define BLKGETLASTSECT  _IO(0x12,108) /* get last sector of block device */
+#define BLKSETLASTSECT  _IO(0x12,109) /* get last sector of block device */
+#endif
+
 #define BLKBSZGET  _IOR(0x12,112,sizeof(int))
 #define BLKBSZSET  _IOW(0x12,113,sizeof(int))
 #define BLKGETSIZE64 _IOR(0x12,114,sizeof(u64))	/* return device size in bytes (u64 *arg) */
