diff -urNp linux-8030/drivers/addon/bcm/Makefile linux-8040/drivers/addon/bcm/Makefile
--- linux-8030/drivers/addon/bcm/Makefile
+++ linux-8040/drivers/addon/bcm/Makefile
@@ -0,0 +1,54 @@
+#
+# Makefile for linux/drivers/addon/bcm/Linux
+#
+
+O_TARGET := bcm5820_foo.o
+
+EXTRA_CFLAGS += -DUBSEC_5820 -DGOTOSLEEP -DMULTIPLE_DEVICES -DLINUX -DLINUX_DEVICE
+
+
+obj-$(CONFIG_CRYPTO_BROADCOM)	+= bcm5820.o 
+
+
+BCMOBJS=	              \
+	chipinfo.o	\
+	crypto.o	\
+	device.o	\
+	dispatch.o	\
+	hash.o		\
+	math.o		\
+	param.o		\
+	pkey.o		\
+	rng.o		\
+	selftest.o	\
+	snmp.o		\
+	sslarc4.o	\
+	sslcipher.o	\
+	sslmac.o	\
+	tlsmac.o	\
+	ubsciphr.o	\
+	ubsdh.o		\
+	ubsdsa.o	\
+	ubsinit.o	\
+	ubsint.o	\
+	ubskey.o	\
+	ubskeytest.o	\
+	ubsmath.o	\
+	ubsmd5.o	\
+	ubsnorm.o	\
+	ubsrng.o	\
+	ubsrsa.o	\
+	ubssha1.o	\
+	ubsssl.o	\
+	ubsstats.o	\
+	ubsstruc.o	\
+	ubstest.o	\
+	ubsutils.o	\
+	memory.o	\
+	utils.o
+	
+
+include $(TOPDIR)/Rules.make
+
+bcm5820.o: $(BCMOBJS)
+	$(LD)  -o $@ -r $(BCMOBJS)
diff -urNp linux-8030/drivers/addon/bcm/cdevextrn.h linux-8040/drivers/addon/bcm/cdevextrn.h
--- linux-8030/drivers/addon/bcm/cdevextrn.h
+++ linux-8040/drivers/addon/bcm/cdevextrn.h
@@ -0,0 +1,112 @@
+
+/*
+ *  Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ *  of any kind, either express or implied as further specified in the GNU Public
+ *  License. This software may be used and distributed according to the terms of
+ *  the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+/******************************************************************************
+ *
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+/*
+ * Revision History:
+ *
+ * May 2000 SOR/JTT Created.
+ */
+/*
+ * Character device externs header file.
+ * 10/09/2001 SRM 64 bit port
+ */
+
+#ifndef __CDEVEXTRN_H__
+#define __CDEVEXTRN_H__
+
+extern int InitDevices(int NumberOfCryptoMCRs,int NumberOfKeyMCRs);
+extern int init_keyif(void);
+extern void shutdown_keyif(void);
+extern int init_mathif(void);
+extern void shutdown_mathif(void);
+extern int init_cryptoif(void);
+extern void shutdown_cryptoif(void);
+extern int init_rngif(void);
+extern void shutdown_rngif(void);
+extern int init_arc4if(void);
+extern void shutdown_arc4if(void);
+
+int ubsec_keysetup(ubsec_DeviceContext_t pContext,
+	       ubsec_key_io_t *pKeyIOInfo);
+extern int ubsec_math(ubsec_DeviceContext_t pContext,
+	   ubsec_math_io_t *pIOInfo);
+extern int ubsec_rng(ubsec_DeviceContext_pt pContext, ubsec_rng_io_t *rng_cmd);
+extern int ubsec_tlsmac(ubsec_DeviceContext_t pContext, ubsec_tlsmac_io_t *tls_cmd);
+extern int ubsec_sslmac(ubsec_DeviceContext_t pContext, ubsec_sslmac_io_t *ssl_cmd);
+extern int ubsec_hash(ubsec_DeviceContext_t pContext, ubsec_hash_io_t *hash_cmd);
+extern int ubsec_sslcipher(ubsec_DeviceContext_t pContext, 
+			   ubsec_sslcipher_io_t *ssl_cmd, unsigned int features);
+extern int ubsec_sslarc4(ubsec_DeviceContext_t pContext, ubsec_arc4_io_t *arc4_cmd);
+extern int ubsec_dvt_handler(void *context, void* parameters);
+extern int obsolete_chipinfo(ubsec_DeviceContext_t pContext, linux_chipinfo_io_t *ci_cmd);
+extern int ubsec_chipinfo(ubsec_DeviceContext_t pContext, ubsec_chipinfo_io_t *ci_cmd);
+extern int DumpDeviceInfo(PInt pm);
+extern int TestDevices(PInt pm);
+extern int FailDevices(PInt pm);
+extern int GetHardwareVersion(PInt pm);
+extern int TestDevice(int SelectedDevice);
+extern void ubsec_DumpDeviceInfo(ubsec_DeviceContext_t Context);
+extern int SetupFragmentList(ubsec_FragmentInfo_pt Frags, unsigned char *packet,int packet_len);
+
+int
+KeyCommandCopyin(unsigned long Command, 
+		 ubsec_KeyCommandParams_pt pSRLParams, 
+		 ubsec_KeyCommandParams_pt pDHIOparams,
+		 unsigned char *KeyLoc,
+		 ubsec_FragmentInfo_pt InputKeyInfo);
+
+int
+KeyCommandCopyout(unsigned long Command, 
+		 ubsec_KeyCommandParams_pt pSRLParams, 
+		 ubsec_KeyCommandParams_pt pIOparams,
+		 unsigned char *KeyLoc);
+
+int ubsec_keysetup_Diffie_Hellman(unsigned long command, 
+	ubsec_KeyCommandParams_pt pIOparams, ubsec_KeyCommandParams_pt pSRLparams, 	
+	unsigned char *KeyLoc);
+
+int ubsec_keysetup_RSA(unsigned long command, 
+	ubsec_KeyCommandParams_pt pIOparams, ubsec_KeyCommandParams_pt pSRLparams, 	
+	unsigned char *KeyLoc);
+int ubsec_keysetup_DSA(unsigned long command,
+	ubsec_KeyCommandParams_pt pIOparams, ubsec_KeyCommandParams_pt pSRLparams, 	
+	unsigned char *KeyLoc, ubsec_FragmentInfo_pt InputKeyInfo);
+
+extern void tv_sub(struct timeval *out, struct timeval *in);
+extern unsigned long stop_time(struct timeval *tv_stop);
+extern void start_time(struct timeval *tv_start)  ;
+
+#ifndef LINUX2dot2
+extern int Gotosleep(wait_queue_head_t *WaitQ);
+extern void Wakeup(wait_queue_head_t *WaitQ);
+#else
+extern int Gotosleep(struct wait_queue **WaitQ);
+extern void Wakeup(struct wait_queue **WaitQ);
+#endif
+
+extern int do_encrypt(ubsec_DeviceContext_t pContext,ubsec_io_t *at,
+		      unsigned int features);
+extern int Selftest(ubsec_DeviceContext_t pContext,struct pci_dev* pDev);
+
+extern void CmdCompleteCallback(unsigned long CallBackContext,ubsec_Status_t Result);
+
+#endif /* __CDEVEXTRN_H__ */
+
diff -urNp linux-8030/drivers/addon/bcm/cdevincl.h linux-8040/drivers/addon/bcm/cdevincl.h
--- linux-8030/drivers/addon/bcm/cdevincl.h
+++ linux-8040/drivers/addon/bcm/cdevincl.h
@@ -0,0 +1,178 @@
+
+/*
+ *  Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ *  of any kind, either express or implied as further specified in the GNU Public
+ *  License. This software may be used and distributed according to the terms of
+ *  the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+/******************************************************************************
+ *
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+/*
+ * cdevincl.h: Major include file for cdev
+ *
+ *
+ * Revision History:
+ *
+ * May 2000 SOR/JTT Created
+ * March 2001 PW Release for Linux 2.4 kernel 
+ * Oct  2001 SRM 64 bit port
+ */
+
+#ifndef _CDEVINCL_H_
+#define _CDEVINCL_H_
+
+#ifndef __KERNEL__
+#define __KERNEL__
+#endif
+
+#include <linux/version.h>
+#define __NO_VERSION__ /* don't define kernel_verion in module.h */
+#include <linux/config.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
+#define MODVERSIONS
+#define LINUX2dot2
+#endif
+
+#ifdef MODVERSIONS
+#include <linux/modversions.h>
+#endif
+
+#include <linux/types.h>
+#include <linux/kernel.h> /* printk() */
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/wrapper.h>
+#include <linux/slab.h> /* kmalloc() */
+#include <linux/fs.h>     /* everything... */
+#include <linux/errno.h>  /* error codes */
+#include <linux/string.h> /* memset(), memcpy() */
+#include <linux/mm.h>     /* get_free_pages() */
+#include <linux/time.h>
+#include <linux/delay.h>   /* udelay() */
+
+#include <linux/ptrace.h>
+#include <linux/in.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <asm/segment.h>   
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+#include <asm/irq.h>
+#include <asm/semaphore.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+
+
+#ifndef UBS_UINT32
+#define UBS_UINT32 unsigned int
+#endif
+
+#define vtophys(x) virt_to_bus(x)
+
+#include "ubsec.h"
+#include "ubsdefs.h"
+#include "ubsio.h"
+#include "keydefs.h"
+#include "cdevextrn.h"
+#include "snmp.h"
+
+typedef struct CommandContext_s {
+#ifndef LINUX2dot2
+  wait_queue_head_t 	WaitQ; 
+#else
+  struct wait_queue     *WaitQ;
+#endif
+  struct timeval   	tv_start;
+  unsigned long		CallBackStatus;
+  int 			Status;
+  int			pid;
+} CommandContext_t, *CommandContext_pt;
+
+#define MAX_SUPPORTED_DEVICES 10
+#define SLEEP_ON_SRL_SEM
+
+typedef struct DeviceInfo_s {
+  ubsec_DeviceContext_t Context;
+  struct pci_dev* pDev;
+  struct tq_struct completion_handler_task;
+  struct semaphore Semaphore_SRL;
+  volatile u_int32_t	DeviceStatus;
+  u_int32_t	DeviceFailuresCount;
+  unsigned int  Features;
+} DeviceInfo_t, *DeviceInfo_pt;
+
+extern int NumDevices;
+#ifndef INCL_BCM_OEM_1
+extern DeviceInfo_t DeviceInfoList[MAX_SUPPORTED_DEVICES];
+#endif
+
+/* device status functions for failover */
+
+int
+GetDeviceStatus(DeviceInfo_t Device);
+
+int
+SetDeviceStatus(DeviceInfo_pt Device, int Status);
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)) /* Enable only for > 7.x */
+#define UBSEC_SNMP_2_2
+#else
+#define UBSEC_SNMP_2_4
+#endif
+
+/* Device Type */
+#ifndef UBS_DEVICE_TYPE
+#if defined(UBSEC_5820)
+#define UBS_DEVICE_TYPE "BCM5820"
+#elif defined(UBSEC_582x)
+#define UBS_DEVICE_TYPE "BCM582x"
+#else
+#define UBS_DEVICE_TYPE "BCM5805"
+#endif
+#endif
+
+/* Debug Info  */
+/* Define this tag in any file for a specific debug tag for the file */
+#ifndef FILE_DEBUG_TAG
+#define FILE_DEBUG_TAG  UBS_DEVICE_TYPE 
+#endif
+
+#define PRINTK printk("%s: ",FILE_DEBUG_TAG); printk
+
+/* Validation of the Length */
+
+#ifdef UBSEC_582x_CLASS_DEVICE
+#define MAX_KEY_LENGTH_BITS 2048
+#define MAX_MATH_LENGTH_BITS 2048
+#else
+#define MAX_KEY_LENGTH_BITS 1024
+#define MAX_MATH_LENGTH_BITS 1024
+#endif
+
+#define MAX_RNG_LENGTH_BITS 4096
+#define MAX_RSA_PRIVATE_KEY_LENGTH_BITS 1024
+#define MAX_DSA_KEY_LENGTH_BITS 1024
+#define MAX_DSA_MODQ_LENGTH_BITS 160
+#define MAX_DSA_SIG_LENGTH_BITS 160
+#define MAX_CRYPT_LENGTH_BITS 65535
+
+#define CHECK_SIZE(param,maxsize) if ( param > maxsize){ 	\
+ 	PRINTK("Maximum length supported  %d. Given length %d.\n",maxsize,(int)param);						\
+	return -EINVAL;						\
+ }
+#endif /*  _CDEVINCL_H_ */
diff -urNp linux-8030/drivers/addon/bcm/chipinfo.c linux-8040/drivers/addon/bcm/chipinfo.c
--- linux-8030/drivers/addon/bcm/chipinfo.c
+++ linux-8040/drivers/addon/bcm/chipinfo.c
@@ -0,0 +1,79 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2001
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/*******************************************************************************
+ *
+ * File: Linux/chipinfo.c
+ * 
+ * What: obsolete_chipinfo returns the maximum key size for the installed h/w. 
+ *
+ * Description: 
+ *              
+ * Revision History:
+ *                   When       Who   What
+ *                   09/07/01   RJT   Renamed from ubsec_chipinfo. This routine
+ *                                    will be phased out in favor of the new
+ *                                    ubsec_chipinfo function in the SRL
+ *                   06/28/01   DNA   Removed SRL call, uses Linux #define now.
+ *                   03/13/01   DNA   Created.
+ *
+ ******************************************************************************/
+
+#include "cdevincl.h"
+
+/**************************************************************************
+ *
+ * Function:     obsolete_chipinfo
+ * 
+ * Called from:  ubsec_ioctl() in Linux/dispatch.c
+ *
+ * Description: 
+ *
+ * Return Values: 
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+
+int
+obsolete_chipinfo(
+	       ubsec_DeviceContext_t   pContext,
+	       linux_chipinfo_io_t    *pIOInfo
+	       ) {
+  
+  linux_chipinfo_io_t   IOInfo;
+  
+  if (copy_from_user(&IOInfo, pIOInfo, sizeof(linux_chipinfo_io_t)))
+    return -EFAULT;
+  
+#ifdef UBSEC_5820
+  IOInfo.max_key_len = 2048;
+#else
+  IOInfo.max_key_len = 1024;
+#endif
+  
+  if (copy_to_user(pIOInfo, &IOInfo, sizeof(linux_chipinfo_io_t)))
+    return -EFAULT;
+  
+  IOInfo.result_status = UBSEC_STATUS_SUCCESS;
+  
+  return(IOInfo.result_status);
+}
+
diff -urNp linux-8030/drivers/addon/bcm/crypto.c linux-8040/drivers/addon/bcm/crypto.c
--- linux-8030/drivers/addon/bcm/crypto.c
+++ linux-8040/drivers/addon/bcm/crypto.c
@@ -0,0 +1,768 @@
+/*
+ *  Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ *  of any kind, either express or implied as further specified in the GNU Public
+ *  License. This software may be used and distributed according to the terms of
+ *  the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+/******************************************************************************
+ *
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+/*
+ * Crypto operations for character driver interface to the ubsec driver
+ *
+ * Revision History:
+ *
+ * May 2000 SOR/JTT Created.
+ * March 2001 PW Release for Linux 2.4 UP and SMP kernel 
+ * 10/09/2001 SRM 64 bit port
+ */
+
+#include "cdevincl.h"
+
+#ifdef FILE_DEBUG_TAG
+#undef FILE_DEBUG_TAG
+#endif
+#define FILE_DEBUG_TAG  "BCMCRYPTO"
+
+#define AUTH_BUF_SIZE 4096
+
+#ifdef POLL
+#undef GOTOSLEEP
+#endif
+
+/* These are useful only for diagnostics. */
+#undef SETFRAGMENTS
+#undef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+
+#ifdef STATIC_ALLOC
+#define STATIC_ALLOC_OF_CRYPTO_BUFFERS 1
+#endif
+
+
+#ifdef SETFRAGMENTS
+ubsec_FragmentInfo_t SourceFragments[MAX_COMMANDS][MAX_FRAGMENTS];
+ubsec_FragmentInfo_t DestinationFragments[MAX_COMMANDS][MAX_FRAGMENTS];
+#endif
+
+int SetupFragmentList(ubsec_FragmentInfo_pt Frags, unsigned char *packet,int packet_len);
+unsigned long Page_Size = PAGE_SIZE;
+
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+unsigned char *kern_source_buf = NULL;
+unsigned char *kern_dest_buf   = NULL;
+unsigned char *kern_auth_buf   = NULL;
+static ubsec_MemAddress_t PhysSourceBuf;
+static ubsec_MemAddress_t PhysDestBuf;
+static ubsec_MemAddress_t PhysAuthBuf;
+#endif
+
+#define ALLOC_PAGE_SIZE ((unsigned long)Page_Size)
+#define ALLOC_PAGE_MASK (ALLOC_PAGE_SIZE-1)
+#define BYTES_TO_PAGE_BOUNDARY_PHYS(v) \
+ ((unsigned long)(ALLOC_PAGE_SIZE-(((unsigned long)v)&(ALLOC_PAGE_MASK))))
+#define BYTES_TO_PAGE_BOUNDARY(p) (BYTES_TO_PAGE_BOUNDARY_PHYS(virt_to_bus(p)))
+
+/**************************************************************************
+ *
+ *  Function:  init_cryptoif
+ *   
+ *************************************************************************/
+int init_cryptoif(void)
+{
+#ifdef DEBUG
+  PRINTK("ubsec library version %d.%x%c\n", UBSEC_VERSION_MAJOR,
+	 UBSEC_VERSION_MINOR, UBSEC_VERSION_REV);
+#endif
+
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  kern_source_buf = 
+    (char *) kmalloc((MAX_FILE_SIZE ),GFP_KERNEL|GFP_ATOMIC);
+
+  if( kern_source_buf == NULL ) {
+    PRINTK("no memory for source buffer\n");
+    return -ENOMEM;
+  }
+
+#ifdef DEBUG
+  PRINTK("Allocate %x %x\n",kern_source_buf,vtophys(kern_source_buf));
+#endif
+
+/* Destination Buffers are local so no problem in over writing */
+  kern_dest_buf=kern_source_buf;
+  kern_auth_buf = (char *) kmalloc((AUTH_BUF_SIZE),GFP_KERNEL|GFP_ATOMIC);
+  if( kern_auth_buf == NULL ) {
+    kfree(kern_source_buf);
+    PRINTK("no memory for auth buffer\n");
+    return -ENOMEM;
+  }
+
+  PhysSourceBuf=(ubsec_MemAddress_t)(virt_to_bus(kern_source_buf));
+  PhysDestBuf=(ubsec_MemAddress_t)(virt_to_bus(kern_dest_buf));
+  PhysAuthBuf=(ubsec_MemAddress_t)(virt_to_bus(kern_auth_buf));
+
+#ifdef DEBUG
+  PRINTK("Memory Alloc source %x %x Dest %x %x for source buffer\n",
+	 kern_source_buf,PhysSourceBuf,kern_dest_buf,PhysDestBuf);
+#endif
+
+#endif /* STATIC_ALLOC */
+
+  return 0; /* success */
+}
+
+
+
+/**************************************************************************
+ *
+ *  Function:  cleanup_module
+ *
+ *************************************************************************/
+void shutdown_cryptoif(void)
+{
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  if (kern_source_buf != NULL)
+    kfree(kern_source_buf);
+  if (kern_auth_buf != NULL)
+    kfree(kern_auth_buf);
+#endif /* STATIC_ALLOC */
+}
+
+
+
+/**************************************************************************
+ *
+ *  Function:  do_encrypt
+ *
+ *************************************************************************/
+int
+do_encrypt(ubsec_DeviceContext_t pContext,ubsec_io_t *pat, unsigned int features)
+{
+  ubsec_io_t		at_buf;
+  ubsec_io_pt		at = &at_buf;
+#ifndef SETFRAGMENTS
+  ubsec_FragmentInfo_t *SourceFragments=NULL;
+  ubsec_FragmentInfo_t *DestinationFragments=NULL;
+#endif
+  unsigned int num_packets;
+  unsigned int total_packets;
+  unsigned int packets_done;
+  ubsec_HMAC_State_t HMAC_State;
+  ubsec_CipherCommandInfo_pt acmd;
+  volatile CommandContext_t CommandContext;
+  unsigned int i;
+#ifdef SETFRAGMENTS
+  unsigned int  j;
+#endif
+  unsigned int src_pos;
+  unsigned int dest_pos;
+  unsigned char *user_source_buf;
+  unsigned char *user_dest_buf;
+
+  unsigned int source_buf_size;
+  unsigned int user_dest_buf_size;	 
+  unsigned int dest_buf_size;
+  unsigned int in_packet_size;
+  unsigned int out_packet_size;
+  int MacSize=0;
+  unsigned long delay_total_us;
+  ubsec_CipherCommandInfo_t *ubsec_commands = NULL;
+
+#ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  unsigned char *kern_source_buf = NULL;
+  unsigned char *kern_dest_buf   = NULL;
+  unsigned char *kern_auth_buf   = NULL;
+  ubsec_MemAddress_t PhysSourceBuf;
+  ubsec_MemAddress_t PhysDestBuf;
+  ubsec_MemAddress_t PhysAuthBuf=0;
+#endif
+  int Status=-1;
+  /*int CryptoHeaderLen=0; */
+  int alignbytes=0; /* Holds the no of bytes to align the encrypt buffer so that the auth buffer starts at 4 byte boundry */ /* This happens only when Auth only with clear message not in 4 byte aligned boundry */ 
+
+	/*
+	 * Copy control packet into kernel space.
+	 */
+  if (copy_from_user( at, pat , sizeof(*at)))
+    return -EFAULT;
+  /*
+  if (UBSEC_USING_CRYPT(at->flags) == UBSEC_3DES)
+  {
+     if (!(features & UBSEC_EXTCHIPINFO_3DES))
+        return -EINVAL;
+  }
+  */
+
+  /* Validation */
+
+  CHECK_SIZE(at->source_buf_size,MAX_CRYPT_LENGTH_BITS);
+  CHECK_SIZE(at->dest_buf_size,MAX_CRYPT_LENGTH_BITS);
+
+  user_source_buf = at->source_buf;
+  user_dest_buf   = at->dest_buf;
+  source_buf_size   = at->source_buf_size;
+  user_dest_buf_size     = at->dest_buf_size;
+	
+  at->time_us =0;
+
+/* Calculate Dest buf size */
+dest_buf_size = 0; /* minimum required buf size */
+if (UBSEC_USING_CRYPT(at->flags))
+	dest_buf_size =source_buf_size - at->crypt_header_skip; /* crypt data */
+if ( UBSEC_USING_MAC(at->flags) ){
+	if (at->flags & UBSEC_ENCODE)
+		dest_buf_size += ( ((at->flags & UBSEC_MAC_MD5) ? MD5_LENGTH : SHA1_LENGTH) * at->num_packets); /* auth data required */
+	else if (UBSEC_USING_CRYPT(at->flags)  )
+		dest_buf_size -= ( ((at->flags & UBSEC_MAC_MD5) ? MD5_LENGTH : SHA1_LENGTH) * at->num_packets); /* auth data  substract from the size; expect auth data in the in size*/
+	}
+
+/* Calculate the size of the packets */
+  in_packet_size    = source_buf_size / at->num_packets;
+  out_packet_size   = dest_buf_size / at->num_packets;
+
+  if ( at->flags & UBSEC_ENCODE ) {
+  	alignbytes = 4 -  (source_buf_size & 0x03) ;  
+  	if (alignbytes == 4)
+		alignbytes =0; /* 4 - 0 = 4  so fix it here*/
+	}
+  
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  if( source_buf_size > MAX_FILE_SIZE ) {
+    PRINTK("input buffer size too large <%d,%d>\n",source_buf_size,MAX_FILE_SIZE);
+    Status=-EINVAL;
+    goto Error_Ret;
+  }
+  if( dest_buf_size > MAX_FILE_SIZE ) {
+    PRINTK("required output buffer too large <%d,%d>\n",dest_buf_size,MAX_FILE_SIZE);
+    Status=-EINVAL;
+    goto Error_Ret;
+  }
+#endif
+
+#ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  kern_source_buf = 
+    (char *) kmalloc((((dest_buf_size>source_buf_size)?dest_buf_size:source_buf_size)+alignbytes),
+		GFP_KERNEL|GFP_ATOMIC);
+
+  if( kern_source_buf == NULL ) {
+    PRINTK("no memory for source buffer %d\n",dest_buf_size);
+    Status=-ENOMEM;
+    goto Error_Ret;
+  }
+
+#ifdef DEBUG
+  PRINTK("Allocate %x %x\n",kern_source_buf,vtophys(kern_source_buf));
+#endif
+
+  kern_dest_buf=kern_source_buf;
+
+  PhysSourceBuf=(ubsec_MemAddress_t)(virt_to_bus(kern_source_buf));
+  PhysDestBuf=(ubsec_MemAddress_t)(virt_to_bus(kern_dest_buf));
+
+#ifdef DEBUG
+  PRINTK("Memory Alloc source %x %x Dest %x %x for source buffer\n",
+	 kern_source_buf,PhysSourceBuf,kern_dest_buf,PhysDestBuf);
+#endif
+
+#endif /* STATIC_ALLOC */
+
+  packets_done = 0;   /* incremented every time callback is called */
+  num_packets = at->num_packets;
+  if( num_packets > MAX_COMMANDS ) {
+    PRINTK("too many packets/commands\n");
+    Status=-EINVAL;
+    goto Error_Ret;
+  }
+
+#ifdef SETFRAGMENTS
+  if (at->num_fragments > UBSEC_MAX_FRAGMENTS)
+  {
+    PRINTK("too many fragments\n");
+    Status=-EINVAL;
+    goto Error_Ret;
+  }
+#endif
+
+  /*
+   * File size is a little different when using MAC
+   */
+  if(UBSEC_USING_MAC( at->flags ) ) {
+    /*
+     * We need to initialize the inner and outer hash keys.
+     */
+    MacSize= (at->flags & UBSEC_MAC_MD5) ? MD5_LENGTH : SHA1_LENGTH;
+    if ( at->flags & UBSEC_DECODE ) {
+#ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+      /*kern_auth_buf = (char *) kmalloc((AUTH_BUF_SIZE),GFP_KERNEL|GFP_ATOMIC);*/
+      kern_auth_buf = (char *) kmalloc((at->num_packets*MacSize),GFP_KERNEL|GFP_ATOMIC);
+      if( kern_auth_buf == NULL ) {
+	PRINTK("no memory for auth buffer\n");
+	Status=-ENOMEM;
+	goto Error_Ret;
+      }
+#endif /* STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+      in_packet_size    = (source_buf_size - (at->num_packets*MacSize)) / at->num_packets;
+      PhysAuthBuf=(ubsec_MemAddress_t)(virt_to_bus(kern_auth_buf));
+      /*memset(kern_auth_buf,0,AUTH_BUF_SIZE);*/
+      memset(kern_auth_buf,0,at->num_packets*MacSize);
+    }
+    else{
+      	out_packet_size   = (dest_buf_size - (at->num_packets*MacSize)) / at->num_packets; 
+	
+    	if(UBSEC_USING_CRYPT( at->flags ) ) 
+     		PhysAuthBuf=(ubsec_MemAddress_t)(virt_to_bus(&kern_dest_buf[(at->num_packets*out_packet_size) + alignbytes])); /* Add to end */   
+	else
+     		PhysAuthBuf=(ubsec_MemAddress_t)(virt_to_bus(kern_dest_buf)); /* no crypto  */   
+	}
+   }
+
+#ifndef SETFRAGMENTS
+  /* Allocate memory for fragment information. */
+  SourceFragments=(ubsec_FragmentInfo_t *) kmalloc(((sizeof(ubsec_FragmentInfo_t)*num_packets*UBSEC_MAX_FRAGMENTS)),GFP_KERNEL|GFP_ATOMIC);
+  if( SourceFragments == NULL ) {
+    PRINTK("no memory for source fragment buffer\n");
+    Status=-ENOMEM;
+    goto Error_Ret;
+  }
+  DestinationFragments=(ubsec_FragmentInfo_t *) kmalloc(((sizeof(ubsec_FragmentInfo_t)*num_packets*UBSEC_MAX_FRAGMENTS)),GFP_KERNEL|GFP_ATOMIC);
+  if( DestinationFragments == NULL ) {
+    PRINTK("no memory for destination fragment buffer\n");
+    Status=-ENOMEM;
+    goto Error_Ret;
+  }
+#endif /* SETFRAGMENTS */
+
+/*
+  memset(ubsec_commands,0, sizeof(ubsec_commands));
+*/
+  memset((CommandContext_t *)&CommandContext,0, sizeof(CommandContext_t));
+  src_pos = 0;
+  dest_pos = 0;
+
+  ubsec_commands=(ubsec_CipherCommandInfo_t *) kmalloc((sizeof(ubsec_CipherCommandInfo_t)*num_packets),GFP_KERNEL|GFP_ATOMIC);
+
+  if( ubsec_commands == NULL ) {
+    PRINTK("no memory for source buffer\n");
+    return -ENOMEM;
+  }
+
+
+
+  for(i = 0; i < num_packets; i++) {
+    acmd = &ubsec_commands[i];
+    acmd->InitialVector = (ubsec_IV_pt) at->initial_vector;
+    acmd->CryptKey = (ubsec_CryptKey_pt) at->crypt_key;
+    acmd->Command=at->flags;
+
+/* Expect the states in mac_key */
+    if (USING_MAC_STATES(at->flags)){
+      memcpy(&HMAC_State,at->mac_key,sizeof(ubsec_HMAC_State_t));	
+    }
+    else if (UBSEC_USING_MAC(at->flags)) 
+      ubsec_InitHMACState(&HMAC_State,UBSEC_USING_MAC(acmd->Command),at->mac_key);
+
+    acmd->HMACState=&HMAC_State;
+    if ((int)(at->crypt_header_skip & 0x03)) {
+		PRINTK("Invalid crypto offset length %08x\n",at->crypt_header_skip);
+		Status=UBSEC_STATUS_INVALID_PARAMETER;
+    		goto Error_Ret;
+		}
+    acmd->CryptHeaderSkip = at->crypt_header_skip/4; /* Done here so the SRL does not do */
+    /*CryptoHeaderLen= at->crypt_header_skip ;*/
+
+#ifdef SETFRAGMENTS
+    acmd->NumSource = at->num_fragments;
+    acmd->NumDestination = at->num_fragments;
+    for( j = 0; j < at->num_fragments; j++ ) {
+      SourceFragments[i][j].FragmentAddress = PhysSourceBuf+src_pos;
+      SourceFragments[i][j].FragmentLength = in_packet_size / at->num_fragments;
+      if( j+1 == at->num_fragments )
+	SourceFragments[i][j].FragmentLength += in_packet_size % at->num_fragments;
+      src_pos += SourceFragments[i][j].FragmentLength;
+    }
+    acmd->SourceFragments=&SourceFragments[i][0];
+
+    /*
+     * Keep destination fragments separate since there
+     * are more restrictions on them
+     */
+    if ((at->num_fragments == 1) || (!(at->num_fragments % 4)))
+      acmd->NumDestination = at->num_fragments;
+    else
+      acmd->NumDestination=4;  /* Default. */
+
+    for( j = 0; j < acmd->NumDestination; j++ ) {
+      DestinationFragments[i][j].FragmentAddress =  PhysDestBuf+dest_pos;
+      DestinationFragments[i][j].FragmentLength = out_packet_size / acmd->NumDestination; /*at->num_fragments; */
+      if( j+1 == acmd->NumDestination)
+	DestinationFragments[i][j].FragmentLength += out_packet_size % acmd->NumDestination;
+      dest_pos += DestinationFragments[i][j].FragmentLength;
+    }
+    acmd->DestinationFragments=&DestinationFragments[i][0];
+
+
+#else
+    /* Since we do not have a large enough contiguous buffer, we override
+       the fragment num setting and set the fragment accordingly. */
+    acmd->SourceFragments=&SourceFragments[i*UBSEC_MAX_FRAGMENTS];
+    if ((acmd->NumSource=SetupFragmentList(acmd->SourceFragments,&kern_source_buf[src_pos],in_packet_size)) == 0) {
+      /* The input data requires more fragments than the current driver build can provide; return error */
+      Status=UBSEC_STATUS_NO_RESOURCE;
+      goto Error_Ret;
+    }
+
+    src_pos += in_packet_size;
+    acmd->DestinationFragments=&DestinationFragments[i*UBSEC_MAX_FRAGMENTS];
+    if(UBSEC_USING_CRYPT( at->flags ) ) {
+      if ((acmd->NumDestination=SetupFragmentList(acmd->DestinationFragments,&kern_dest_buf[dest_pos],out_packet_size)) == 0) {
+	/* The output data would require more fragments than the current driver build can provide; return error */
+	Status=UBSEC_STATUS_NO_RESOURCE;
+	goto Error_Ret;
+      }
+
+/* We donot expect Header offset for output data */
+#if 0 
+ 	if (CryptoHeaderLen > 0)  {
+		for ( k=0;k < UBSEC_MAX_FRAGMENTS;i++){
+		if (CryptoHeaderLen > out_packet_size)	{
+    			acmd->DestinationFragments[k].FragmentAddress = virt_to_bus(&kern_dest_buf[dest_pos+out_packet_size]);
+    			acmd->DestinationFragments[k].FragmentLength -= out_packet_size;
+			CryptoHeaderLen -=out_packet_size;
+			} else{
+    			acmd->DestinationFragments[k].FragmentAddress = virt_to_bus(&kern_dest_buf[dest_pos+CryptoHeaderLen]);
+    			acmd->DestinationFragments[k].FragmentLength -= CryptoHeaderLen;
+			CryptoHeaderLen -=CryptoHeaderLen;
+			}
+			if (CryptoHeaderLen <=0)
+				break;
+			}
+		}
+#endif /* 0 */
+   	 dest_pos+= out_packet_size;
+	}else{
+	/* To satisfy the SRL, Donot use it Chip */
+    	acmd->NumDestination=1; 
+    	DestinationFragments[i].FragmentLength = 1;
+    	DestinationFragments[i].FragmentAddress = PhysAuthBuf; /* Nothing official about it, satisfys alignment checks */
+   	dest_pos+= out_packet_size;
+	}
+#endif
+
+    /*
+     * If we are doing authentication then we need to allocate
+     * another fragment for the output
+     */
+    if(UBSEC_USING_MAC( acmd->Command ) ) {
+      acmd->AuthenticationInfo.FragmentAddress = PhysAuthBuf+(MacSize*i);
+    }
+    if (i==(num_packets-1)) {
+	/*
+	 * We only set the callback for the last one since that
+	 * they are completed in batch mode
+	 */
+      acmd->CompletionCallback = CmdCompleteCallback;
+      acmd->CommandContext = (unsigned long) &CommandContext;
+    }
+    else {
+      acmd->CompletionCallback = NULL;
+      acmd->CommandContext=0;
+    }
+  }
+
+  if(UBSEC_USING_MAC( at->flags )) {
+    if (at->flags & UBSEC_DECODE) {
+      src_pos+=(MacSize*num_packets);
+      }
+    else {
+      dest_pos+=(MacSize*num_packets);
+    }
+  }
+  if( src_pos != source_buf_size ) {
+    PRINTK("invalid source buffer size -- "
+	   "given size %u -- total used/needed %u\n", 
+	   source_buf_size, src_pos);
+    Status=-EINVAL;
+    goto Error_Ret;
+  }
+  if(dest_pos != dest_buf_size ) {
+    PRINTK("invalid dest buffer size -- "
+	   "given size %u -- total used/needed %u\n", 
+	   dest_buf_size, dest_pos);
+    Status=-EINVAL;
+    goto Error_Ret;
+  }
+
+  /*memset(kern_source_buf,0,dest_buf_size);*/
+  memset(kern_source_buf,0,(((dest_buf_size>source_buf_size)?dest_buf_size:source_buf_size)+alignbytes));
+  if (copy_from_user(kern_source_buf, user_source_buf, source_buf_size)) {
+    Status=-EFAULT;
+    goto Error_Ret;
+  }
+
+  /* Sync the DMA memory so that the CryptoNetX device can access it. */
+  OS_SyncToDevice(kern_source_buf, 0, source_buf_size); /* (MemHandle, offset, bytes) */
+
+  /*
+   *  Let the system do anything it may want/need to do before we begin
+   *  timing.
+   */
+  start_time((struct timeval *)&CommandContext.tv_start);
+  total_packets=num_packets;  
+
+#ifndef LINUX2dot2
+  init_waitqueue_head((wait_queue_head_t *)&CommandContext.WaitQ);
+#else
+   CommandContext.WaitQ         = 0; 
+#endif    
+
+  Status=  ubsec_CipherCommand(pContext,ubsec_commands,&num_packets) ; 
+  switch ( Status ) {
+  case UBSEC_STATUS_SUCCESS:
+    break;
+  case UBSEC_STATUS_TIMEOUT:
+    PRINTK("ubsec  ubsec_Command() Timeout\n");
+    ubsec_ResetDevice(pContext);
+    Status=ETIMEDOUT;
+    goto Error_Ret;
+    break;
+  case UBSEC_STATUS_INVALID_PARAMETER:
+    PRINTK(" ubsec_Command() Invalid parameter\n");
+    Status=EINVAL;
+    goto Error_Ret;
+    break;
+  case UBSEC_STATUS_NO_RESOURCE:
+    PRINTK("ubsec  ubsec_Command() No crypto resource. Num Done %d\n",num_packets);
+  default:
+    Status=-ENOMSG;
+    goto Error_Ret;
+    break;
+  }
+
+#ifdef GOTOSLEEP
+  if (!(CommandContext.CallBackStatus)) { /* Just in case completed on same thread. */
+#ifndef LINUX2dot2
+     Gotosleep((wait_queue_head_t *)&CommandContext.WaitQ);
+#else
+     Gotosleep(&CommandContext.WaitQ);
+#endif
+     if (!CommandContext.CallBackStatus) { /* interrupt never happened? */
+        CommandContext.Status=UBSEC_STATUS_TIMEOUT;
+#ifdef DEBUG_TIMEOUT
+    	udelay(2);
+	/* This loop is to push all the remaining MCR's,  missed by specific  rare interrupt preemting a PushMCR condition */
+	while(1)	
+		{
+		ubsec_PollDevice(pContext);
+		PushMCR(pContext);
+		if (CommandContext.CallBackStatus)
+			{
+        		CommandContext.Status=0;
+			Status=0;
+			goto skip_error_ret;
+			}
+    		udelay(2);
+		}
+#else
+     PRINTK(" Gotosleep timedout.\n");
+     ubsec_ResetDevice(pContext);
+     Status = -ETIMEDOUT;
+     goto Error_Ret;
+#endif
+     }
+  }
+#else
+  for (delay_total_us=1  ; !(CommandContext.CallBackStatus); delay_total_us++) {
+#ifdef POLL /* We need to poll the device if we are operating in POLL mode. */
+    ubsec_PollDevice(pContext);
+#endif
+    if (delay_total_us >= 3000000) {
+    Status=-ETIMEDOUT;
+#ifdef DEBUG_TIMEOUT
+	/* This loop is to push all the remaining MCR's,  missed by specific  rare interrupt preemting a PushMCR condition */
+	while(1)	
+		{
+		ubsec_PollDevice(pContext);
+		PushMCR(pContext);
+		if (CommandContext.CallBackStatus)
+			{
+			Status=0;
+			goto skip_error_ret;
+			}
+    		udelay(1);
+		}
+#else
+      	PRINTK(" Poll timedout.\n");
+     goto Error_Ret;
+#endif
+    }
+    udelay(1);
+  }
+#endif
+skip_error_ret:
+
+  if (UBSEC_USING_MAC( at->flags ) && (at->flags & UBSEC_DECODE)) {
+
+    /* Sync the Auth output memory so that the CPU sees newly DMA'd memory. */
+    OS_SyncToCPU(kern_auth_buf, 0, MacSize*at->num_packets); /* (MemHandle, offset, bytes) */
+
+    /* Check the Auth */
+    if (memcmp(kern_auth_buf,&kern_source_buf[at->num_packets*in_packet_size],MacSize*at->num_packets)) { /*at->num_packets*MacSize)) */
+      	PRINTK(" Authentication error.\n");
+#ifdef PRINT_AUTH_ERROR_INFO
+	PRINTK("Decode type :%s\n", ((at->flags & UBSEC_DECODE_3DES) ? "3DES" : "DES"));
+	PRINTK("Authentication type :%s\n", ((at->flags & UBSEC_MAC_MD5) ? "MD5" : "SHA1"));
+	PRINTK("Total Packets  -- %d\n",at->num_packets);
+	PRINTK("Total Auth size -- %d\n",MacSize*at->num_packets);
+	{
+	num_packets = 0;
+	while(num_packets < at->num_packets) {
+		if(memcmp(kern_auth_buf+(num_packets*MacSize), &kern_source_buf[(at->num_packets*in_packet_size)+(num_packets*MacSize)],MacSize) !=0) { 
+			PRINTK("Auth Error in Packet  %d\n",num_packets);
+      			for (i=0; i < MacSize ; i++)
+				PRINTK("<%x,%x>",(kern_auth_buf+(num_packets*MacSize))[i],kern_source_buf[((at->num_packets*in_packet_size)+(num_packets*MacSize))+i]);
+        		PRINTK("\n");
+			}
+		num_packets++;
+		} /* While */
+	}
+#endif
+	Status=-1;
+	goto Error_Ret;
+    }
+  }
+
+  /* Sync the crypto output memory so that the CPU sees newly DMA'd memory. */
+  OS_SyncToCPU(kern_dest_buf, 0, user_dest_buf_size); /* (MemHandle, offset, bytes) */
+
+/* FIX for align bubble */
+  if (alignbytes ==0 ) { /* expect alignbytes == 0 in DECODE */
+  	if (copy_to_user(user_dest_buf, kern_dest_buf, user_dest_buf_size)) {
+		Status=-EFAULT;
+	}
+  } else {
+	/* Copy what ever the user wants */
+	if (user_dest_buf_size <= (dest_buf_size-MacSize) ){
+  		if (copy_to_user(user_dest_buf, kern_dest_buf, user_dest_buf_size))
+			Status=-EFAULT;
+		goto Error_Ret;
+		}
+	
+  	if (copy_to_user(user_dest_buf, kern_dest_buf, (dest_buf_size-MacSize)) /* copy encrypt */ ||
+  	    copy_to_user(user_dest_buf+(dest_buf_size-MacSize), bus_to_virt((long)PhysAuthBuf),
+			((user_dest_buf_size < dest_buf_size)?(user_dest_buf_size-(dest_buf_size-MacSize)):MacSize ) ) )  /* copy whatever auth the user wants */
+			Status=-EFAULT;
+	}
+
+  at->time_us = CommandContext.tv_start.tv_sec * 1000000 + CommandContext.tv_start.tv_usec;
+
+ Error_Ret:
+
+#ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  if (kern_source_buf != NULL)
+    kfree(kern_source_buf);
+  if ( at->flags & UBSEC_DECODE ) {
+	if ( UBSEC_USING_MAC(at->flags) ){
+  		if (kern_auth_buf != NULL)
+    			kfree(kern_auth_buf);
+	}
+   }
+#endif /* STATIC_ALLOC */
+
+#ifndef SETFRAGMENTS
+    if (SourceFragments != NULL)
+     kfree(SourceFragments);
+    if (DestinationFragments != NULL)
+     kfree(DestinationFragments);
+#endif
+
+    if(ubsec_commands != NULL)
+     kfree( ubsec_commands);
+  /*
+   * Copy back time to user space.
+   */
+#if 0
+  if (copy_to_user((unsigned char *)&(pat->time_us), (unsigned char *)&time_us, sizeof(time_us)))
+    Status=-EFAULT;
+#else
+  if (copy_to_user(pat, at, sizeof(*at)))
+    Status=-EFAULT;
+#endif
+
+  return(Status);
+}
+
+
+
+/*
+ * Setup Fragment list: Initializes a fragment list for a logically
+ * contigous but maybe physically fragmented buffer
+ *
+ * Return the number of fragments allocated, or 0 if fragmentation failed.
+ */
+int
+SetupFragmentList(ubsec_FragmentInfo_pt Frags, unsigned char *packet,int packet_len)
+{
+  int NumFrags=1;
+  int i;
+  
+  /* Initial case. */
+  Frags[0].FragmentLength=packet_len;
+  Frags[0].FragmentAddress=(ubsec_MemAddress_t)(virt_to_bus(packet));
+  
+  if (packet_len > BYTES_TO_PAGE_BOUNDARY(packet)) {
+    /* First case is special since we are dealing with offsets. Readjust length */
+    Frags[0].FragmentLength=BYTES_TO_PAGE_BOUNDARY(packet);
+    packet_len -= Frags[0].FragmentLength;
+    packet += Frags[0].FragmentLength;
+    
+#ifdef DEBUG_FRAGS
+    PRINTK("Frag %d <%x,%x>",0,Frags[0].FragmentLength,Frags[0].FragmentAddress);
+#endif
+    /* From now on the Frags should be equal and of length ALLOC_PAGE_SIZE until the last. */
+    for  (i=1;packet_len > 0;i++) {
+      Frags[i].FragmentAddress=(ubsec_MemAddress_t)(virt_to_bus(packet));
+#ifdef DEBUG_FRAGS
+      if (packet_len > ALLOC_PAGE_SIZE) {
+	Frags[i].FragmentLength = ALLOC_PAGE_SIZE;
+      } else {
+	Frags[i].FragmentLength = packet_len;
+      }
+#else
+      if (packet_len > BYTES_TO_PAGE_BOUNDARY(packet)) {
+	Frags[i].FragmentLength = BYTES_TO_PAGE_BOUNDARY(packet);
+      } else {
+	Frags[i].FragmentLength = packet_len;
+      }
+#endif
+#ifdef DEBUG_FRAGS
+      PRINTK("Frag %d <%x,%x>",i,Frags[i].FragmentLength,Frags[i].FragmentAddress);
+#endif
+      NumFrags++;
+      packet+=Frags[i].FragmentLength;
+      packet_len-= Frags[i].FragmentLength;
+      if ((NumFrags >= UBSEC_MAX_FRAGMENTS) && packet_len) {
+ 	PRINTK("CryptoNet: Maximum number of fragments (%d) exceeded\n",NumFrags);
+ 	NumFrags = 0;
+	break;
+      }
+    } /* Each fragment for loop */
+  } /* Need-to-fragment block */
+#ifdef DEBUG_FRAGS
+  PRINTK("Returning %d fragments\n",NumFrags);
+#endif
+  return(NumFrags);
+}
+
+
+
+
diff -urNp linux-8030/drivers/addon/bcm/device.c linux-8040/drivers/addon/bcm/device.c
--- linux-8030/drivers/addon/bcm/device.c
+++ linux-8040/drivers/addon/bcm/device.c
@@ -0,0 +1,529 @@
+
+/*
+ *  Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ *  of any kind, either express or implied as further specified in the GNU Public
+ *  License. This software may be used and distributed according to the terms of
+ *  the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+/******************************************************************************
+ *
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+/*
+ * device.c:  Modules to interface with the ubsec device.
+ */
+/*
+ * Revision History:
+ *
+ * 10/xx/99 SOR Created.
+ * 11/16/1999 DWP added PCI memory access enable for fixing linuxppc operation
+ * March 2001 PW Release for Linux 2.4 UP and SMP kernel  
+ * May   2001 PW added selftest for bcmdiag
+ * June  2001 SRM added per device testing and forced device failure. 
+ * July  2001 RJT Added support for BCM5821
+ * 10/09/2001 SRM 64 bit port
+ */
+
+#include "cdevincl.h"
+
+//#define SET_PCI_MAX_LATENCY 0x80
+//#define SET_PCI_CLS
+#define SET_PCI_RETRY_COUNT 0x00
+#define SET_PCI_TRDY_COUNT 0xff
+
+/* Devices */
+struct DeviceTable_s {
+  short VendorID;
+  short DeviceID;
+};
+
+/* Define supported device list. */
+#ifdef UBSEC_582x_CLASS_DEVICE
+#define NUM_SUPPORTED_DEVICE_TYPES 3
+#else
+#define NUM_SUPPORTED_DEVICE_TYPES 3
+#endif
+
+static struct DeviceTable_s DeviceList[NUM_SUPPORTED_DEVICE_TYPES]={
+#ifndef UBSEC_582x_CLASS_DEVICE
+  {BROADCOM_VENDOR_ID,BROADCOM_DEVICE_ID_5805},
+  {BROADCOM_VENDOR_ID,BROADCOM_DEVICE_ID_5802},
+  {BROADCOM_VENDOR_ID,BROADCOM_DEVICE_ID_5801}
+#else
+  {BROADCOM_VENDOR_ID,BROADCOM_DEVICE_ID_5821},
+  {BROADCOM_VENDOR_ID,BROADCOM_DEVICE_ID_5822},
+  {BROADCOM_VENDOR_ID,BROADCOM_DEVICE_ID_5820}
+#endif
+};
+
+DeviceInfo_t DeviceInfoList[MAX_SUPPORTED_DEVICES];
+
+void (*ubsec_callback)(void);
+
+/*
+ *
+ * interrupt_proc
+ *
+ * This function receives the completion signal from the device.  At completion
+ * time, it marks the time and schedules the bottom half.
+ *
+ */
+void
+interrupt_proc( int irq, void* pvoid, struct pt_regs *regs )
+{
+}
+
+/*
+ * Initialize and return all devices.
+ * Return the number of initialized devices.
+ */
+
+#ifndef LINUX2dot2
+extern struct pci_dev *globalpDev;
+#endif
+
+int 
+InitDevices(int NumberOfCryptoMCRs,int NumberOfKeyMCRs)
+{
+  short value;
+  ubsec_Status_t Status;
+  int i;
+  int NumDevices=0;
+  DeviceInfo_pt pDevice=&DeviceInfoList[0];
+  struct pci_dev* pDev=NULL;
+  ubsec_chipinfo_io_t srl_chipinfo;
+
+  if( !pcibios_present() ) {
+    PRINTK("cryptonet:  No PCI bus detected!\n" );
+    return( 0 ); /* XXX make an error message */
+  }
+
+  memset(&srl_chipinfo,0, sizeof(ubsec_chipinfo_io_t)); /* no chipinfo from SRL yet   */
+  srl_chipinfo.Status =sizeof(ubsec_chipinfo_io_t);     /* Required for ubslib-SRL match check */
+
+  /* Find and initialize all the devices we can */
+  for (i=0; i < NUM_SUPPORTED_DEVICE_TYPES ; ) {
+    /* Find the next device. */
+
+#if 0
+    PRINTK("Checking for %x-%x\n",DeviceList[i].VendorID,DeviceList[i].DeviceID);
+#endif
+
+    if ((pDev = pci_find_device(DeviceList[i].VendorID,DeviceList[i].DeviceID, pDev))==NULL) {
+      if (NumDevices)
+	break; /* Must not mix device types */
+      i++;
+      continue;
+    }
+#ifndef LINUX2dot2
+ globalpDev = pDev;
+#endif
+
+#if 0 /* Taken care of below */
+    /* set this device as a bus-mastering device */
+    pci_set_master(pDev);
+#endif
+
+    /* below paragraph added 16-nov-1999 dwp to make work on linuxppc */
+    pci_read_config_word( pDev, PCI_COMMAND, &value ); /* SOR added */
+    if( !(value & PCI_COMMAND_MEMORY) )    {
+      value |= PCI_COMMAND_MEMORY;
+      pci_write_config_word( pDev, PCI_COMMAND, value );
+      pci_read_config_word( pDev, PCI_COMMAND, &value );
+      if( !(value & PCI_COMMAND_MEMORY ))   {
+	PRINTK( " memory access enable failed\n" );
+      }
+    }
+    if( !(value & PCI_COMMAND_MASTER) ) {
+      value |= PCI_COMMAND_MASTER;
+      pci_write_config_word( pDev, PCI_COMMAND, value );
+      pci_read_config_word( pDev, PCI_COMMAND, &value );
+      if( !(value & PCI_COMMAND_MASTER ))  {
+	PRINTK( " bus master enable failed\n" );
+      }
+    }	
+#ifdef SET_PCI_MAX_LATENCY
+    pci_write_config_byte(pDev,PCI_LATENCY_TIMER,SET_PCI_MAX_LATENCY);
+#endif
+#ifdef SET_PCI_CLS // Set the cache line size
+    pci_write_config_byte(pDev,PCI_CACHE_LINE_SIZE,1);
+#endif
+#ifdef SET_PCI_RETRY_COUNT
+    pci_write_config_byte(pDev,0x41,SET_PCI_RETRY_COUNT);
+#endif
+#ifdef SET_PCI_TRDY_COUNT
+    pci_write_config_byte(pDev,0x40,SET_PCI_TRDY_COUNT);
+#endif
+
+
+
+    /* let the outside world know what we found */
+    printk( " <BCM%04X, Bus %i, Slot %d, ", pDev->device, pDev->bus->number, PCI_SLOT(pDev->devfn) );
+    printk( "IRQ %d> ", pDev->irq );
+    sema_init (&pDevice->Semaphore_SRL, 1);
+
+    Status=ubsec_InitDevice(pDev->device,
+#ifndef LINUX2dot2
+			    pci_resource_start(pDev,0),
+#else
+			    pDev->base_address[0], 
+#endif
+			    pDev->irq,
+			    NumberOfCryptoMCRs,
+			    NumberOfKeyMCRs, &(pDevice->Context),(OS_DeviceInfo_t) pDevice);
+
+    printk("\n");
+    if (Status != UBSEC_STATUS_SUCCESS) {
+      PRINTK("InitDevice Failed (%ld)\n",Status);
+      continue;
+    }
+
+    pDevice->pDev=pDev;
+
+    Status=Selftest(pDevice->Context,pDev);
+
+    pDevice->DeviceStatus = Status;
+
+#if 0
+    if (Status != UBSEC_STATUS_SUCCESS) {
+      PRINTK("Device failed %lx\n",Status);
+    } else {
+#endif
+
+    if (!srl_chipinfo.Features && ((Status=ubsec_chipinfo(pDevice->Context, (void *)&srl_chipinfo)) != 0)) {
+      PRINTK("ubsec_chipinfo() failed (%ld)\n",Status);
+      continue;
+    }
+
+    /* Check to determine device and stepping */
+    pDevice->Features = ~(0); /* Start with all features enabled */
+
+    pci_read_config_word( pDev, PCI_CLASS_REVISION, &value );
+    if ((value & 0x00E0) == 0xE0) {
+      /* 3DES, ARC4 command not supported in export mode */
+      pDevice->Features &= ~(UBSEC_EXTCHIPINFO_ARC4);
+      pDevice->Features &= ~(UBSEC_EXTCHIPINFO_3DES);
+    }
+    if (pDev->device < BROADCOM_DEVICE_ID_5821) {
+      /* ARC4 command not supported by BCM580x devices */
+      pDevice->Features &= ~(UBSEC_EXTCHIPINFO_ARC4);
+      /* DblModExp command not supported by BCM580x devices */
+      pDevice->Features &= ~(UBSEC_EXTCHIPINFO_DBLMODEXP);
+    }
+    if (pDev->device == BROADCOM_DEVICE_ID_5821) {
+      /* BCM5821 */
+      if ((value & 0x001F) == 0x01) {
+	/* Rev A0; RNG, ARC4_CONT not supported */
+	pDevice->Features &= ~(UBSEC_EXTCHIPINFO_RNG);
+	pDevice->Features &= ~(UBSEC_EXTCHIPINFO_ARC4);
+      }
+    }
+    pDevice->Features &= srl_chipinfo.Features;
+
+    NumDevices++;
+    if (NumDevices == MAX_SUPPORTED_DEVICES)
+      break;
+    pDevice++;
+    
+#if 0
+    }
+#endif
+    
+  } /* For each detected CryptoNet device in the system */
+
+  return(NumDevices);
+}
+
+/*
+ * dump_pci_config: Dump the contents of the pci configuration associated
+ * with the device.
+ */
+void
+dump_pci_config(struct pci_dev *pDev)
+{
+  int i;
+  int j;
+  unsigned char uc;
+
+  printk("  --------------- PCI CONFIG REGISTERS ---------------");
+
+  for( i = 0; i < 65; i += 4 ) {
+    if( !(i%16) ) {
+      printk( "\n  " );
+    }
+    printk( "--%02d:", i/4);
+    for( j = i+3; j >= i; j-- ) {
+      pci_read_config_byte( pDev, j, &uc );
+      printk( "%02X", uc );
+    }
+  }
+  /* printk( "\n  " ); */
+
+  printk("\n  ----------------------------------------------------\n");
+}
+
+/*
+ * Use an Intermediate ISR callback because of
+ * differences in parameters. For ISR and callback
+ * instead of saving the SRL functions we just call
+ * them directly.
+ */
+void
+inter_callback(int irq,void *param,struct pt_regs *regs)
+{
+  DeviceInfo_pt pDevice=(DeviceInfo_pt)param;
+  if (pDevice->Context==0)
+    return;
+  ubsec_ISR(pDevice->Context);
+}
+
+void
+LinuxAllocateIRQ(int irq,void *context)
+{
+  request_irq(irq,inter_callback, SA_INTERRUPT | SA_SHIRQ, UBSEC_DEVICE_NAME,(void *)context); 
+}
+
+void
+LinuxFreeIRQ(int irq, void *context)
+{
+  free_irq(irq,context);
+}
+
+/*
+ * Redirection of callback to make it fit
+ * 
+ */
+void
+callback_dpc(void *param)
+{
+  DeviceInfo_pt pDevice = (DeviceInfo_pt) param;
+  if (pDevice->Context==0)
+    return;
+  ubsec_ISRCallback(pDevice->Context);
+}
+
+/*
+ * Schedule it for a local function
+ */
+int
+LinuxScheduleCallback(void *Context, DeviceInfo_pt pDevice)
+{
+  pDevice->completion_handler_task.routine = callback_dpc;
+  pDevice->completion_handler_task.data =pDevice;
+
+    /* queue up the handler in the bottom half */
+  queue_task( &pDevice->completion_handler_task, &tq_immediate );
+  mark_bh( IMMEDIATE_BH );
+  return 0;
+
+}
+
+/*
+ * LinuxInitCriticalSection:
+ */
+void
+LinuxInitCriticalSection(volatile DeviceInfo_pt pDevice)
+{
+  sema_init(&pDevice->Semaphore_SRL, 1);
+}
+
+/*
+ * LinuxEnterCriticalSection:
+ */
+unsigned long
+LinuxEnterCriticalSection(DeviceInfo_pt pDevice)
+{
+  down_interruptible(&pDevice->Semaphore_SRL);
+  return 0;
+}
+
+/*
+ * LinuxLeaveCriticalSection: Called by SRL
+ */
+void
+LinuxLeaveCriticalSection(DeviceInfo_pt pDevice)
+{
+  up (&pDevice->Semaphore_SRL);
+}
+
+/*
+ * LinuxTestCriticalSection:
+ */
+unsigned long
+LinuxTestCriticalSection(DeviceInfo_pt pDevice)
+{
+  if (down_trylock (&pDevice->Semaphore_SRL))
+    return -1;
+  return 0;
+}
+
+void
+LinuxWaitus( int wait_us )
+{
+  udelay(wait_us);
+}
+
+int
+TestDevice(int SelectedDevice)
+{
+  
+  int status = 1;
+  volatile static int flag = 0;
+
+#ifdef DEBUG_FAILOVER
+  PRINTK("Entering TestDevice, SelectedDevice = %d, DeviceStatus = %d\n", 
+	 SelectedDevice, DeviceInfoList[SelectedDevice].DeviceStatus);
+#endif
+
+  if(flag == 0xdeadbeef) {
+    
+#ifdef DEBUG_FAILOVER
+    PRINTK("Returning from TestDevice, because of flag.\n");
+#endif
+
+    return 1;
+
+  } else {
+
+    flag = 0xdeadbeef;
+    /* should we clear the semaphore here ????? */
+    if(DeviceInfoList[SelectedDevice].DeviceStatus != -1) {
+       DeviceInfoList[SelectedDevice].DeviceStatus = -1; /* remove from the active list */
+      status = Selftest(DeviceInfoList[SelectedDevice].Context, DeviceInfoList[SelectedDevice].pDev);
+      SetDeviceStatus(&DeviceInfoList[SelectedDevice], status);
+    } else {
+#ifdef DEBUG_FAILOVER
+      PRINTK("TestDevice is resetting device %d whose status was %d and will be %d.\n", 
+	      SelectedDevice, DeviceInfoList[SelectedDevice].DeviceStatus, status);
+#endif
+      /* keep device failing but next time it'll pass and status will be cleared */
+      ubsec_ResetDevice(DeviceInfoList[SelectedDevice].Context);
+      SetDeviceStatus(&DeviceInfoList[SelectedDevice], status);
+    }
+    
+    flag = 0;
+  }
+  
+  return DeviceInfoList[SelectedDevice].DeviceStatus;
+}
+
+int
+TestDevices(PInt pm)
+{
+  int Retval=0;
+  int i, timestogo;
+  int seldev = *pm;
+
+#ifdef DEBUG_FAILOVER
+  PRINTK("Entering TestDevices, seldev = %d\n", seldev);
+#endif
+
+  if (seldev > NumDevices) {
+    PRINTK("Selected Device is not installed.\n");
+    return (NumDevices);
+  }
+  if (seldev > 0) {
+      seldev--;
+      timestogo = 1;
+  } else
+      timestogo = NumDevices;
+  
+  /* test all the devices or a given device. */
+  for (i=seldev; i < seldev+timestogo ; i++) {
+    Retval=TestDevice(i);
+    if (Retval)
+      return (-1);
+  }
+  return(Retval);
+}
+
+int
+FailDevices(PInt pm)
+{
+  int i;
+  int seldev = *pm;
+
+#ifdef DEBUG_FAILOVER
+  if(seldev) { 
+    PRINTK("Entering FailDevice, will fail device %d whose status is %d.\n", 
+	   seldev - 1, DeviceInfoList[seldev-1].DeviceStatus);
+  } else {
+    PRINTK("Entering FailDevice, will fail all devices\n", 
+	   seldev - 1, DeviceInfoList[seldev-1].DeviceStatus);
+  }
+#endif
+
+  if (seldev > NumDevices) {
+    PRINTK("Selected device is not installed.\n");
+    return (-1);
+  }
+  if (seldev > 0) {
+     DeviceInfoList[seldev-1].DeviceStatus = -1;
+     ubsec_DisableInterrupt(DeviceInfoList[seldev-1].Context);
+  } else {
+    /* Fail all the devices. */
+    for (i=0; i < NumDevices ; i++) {
+      DeviceInfoList[i].DeviceStatus = -1;
+      ubsec_DisableInterrupt(DeviceInfoList[i].Context);
+    }
+  }
+  
+  return(0);
+}
+
+int
+DumpDeviceInfo(PInt pm)
+{
+  int i, timestogo;
+  int seldev = *pm;
+
+  if (seldev > NumDevices) {
+    PRINTK("Selected device is not installed.\n");
+    return (-1);
+  }
+  if (seldev > 0) {
+      seldev--;
+      timestogo = 1;
+  } else
+      timestogo = NumDevices;
+  /* Dump Info for all the devices or a given device. */
+  for (i=seldev; i < seldev+timestogo ; i++) {
+    dump_pci_config(DeviceInfoList[i].pDev);
+    ubsec_DumpDeviceInfo(DeviceInfoList[i].Context);
+  }
+  return(0);
+}
+
+/*
+ * Get hardware version:
+ * Return the ID (lower byte) and revision ID
+ */
+int
+GetHardwareVersion(PInt pm)
+{
+  unsigned char uc;
+  unsigned short retval;
+  DeviceInfo_pt pDevice;
+  int DNum = *pm;
+
+  if (DNum > NumDevices) {
+    PRINTK("Selected device is not installed.\n");
+    return (-1);
+  }
+  if (DNum > 0)
+    DNum--;
+
+  pDevice=&DeviceInfoList[DNum];
+
+  pci_read_config_byte( pDevice->pDev, PCI_REVISION_ID, &uc );
+  retval=(((pDevice->pDev->device)&0xff)<<8); /* Only need the lower byte */
+  retval+=uc;
+  return(retval);
+}
diff -urNp linux-8030/drivers/addon/bcm/dispatch.c linux-8040/drivers/addon/bcm/dispatch.c
--- linux-8030/drivers/addon/bcm/dispatch.c
+++ linux-8040/drivers/addon/bcm/dispatch.c
@@ -0,0 +1,577 @@
+
+/*
+ *  Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ *  of any kind, either express or implied as further specified in the GNU Public
+ *  License. This software may be used and distributed according to the terms of
+ *  the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+/******************************************************************************
+ *
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+/*
+ * dispatch.c: Character driver interface to the ubsec driver
+ */
+/* Revision History:
+ *
+ * May   2000 SOR Created
+ * March 2001 PW Release for Linux 2.4 UP and SMP kernel 
+ * May   2001 PW added selftest for bcmdiag
+ * May   2001 SRM added support for dumping statistics to the proc
+ *   		  file system
+ * May   2001 SRM change stats file name to bcm5820 
+ * May   2001 SRM Move snmp related stuff to snmp.c. Also support
+ *		  statistics thru' snmp for linux kernel less than
+ *		  2 2 17.
+ * June  2001 SRM Added per device testing and forced device failure. 
+ * July  2001 RJT Added support for BCM5821
+ * Dec   2001 SRM stats ioctl
+ */
+
+#define MODULE
+
+#define NUMBER_OF_KEY_MCRS 128
+#define NUMBER_OF_CRYPTO_MCRS 512 
+
+
+
+
+#include "cdevincl.h"
+
+#ifdef BCM_OEM_1
+#include "bcm_oem_1.h"
+#endif
+
+char kernel_version[] = UTS_RELEASE;
+
+#undef  KERN_DEBUG
+#define KERN_DEBUG "<1>"
+
+static int ubsec_ioctl(struct inode *inode, struct file *filp,unsigned int cmd, unsigned long arg);
+
+static int ubsec_open(struct inode *inode, struct file *filp);
+
+static int ubsec_release(struct inode *inode, struct file *filp);
+
+#ifdef DVT
+DVT_Params_t DVTparams;
+extern unsigned long Page_Size;
+extern int power_of_2(unsigned long);
+extern unsigned long next_smaller_power_of_2(unsigned long);
+#endif /* DVT */
+
+void get_ubsec_Function_Ptrs(ubsec_Function_Ptrs_t *fptrs); /* for function ptrs access */
+
+int PInt_Contents;
+int NumDevices=0;
+ubsec_chipinfo_io_t   ExtChipInfo;
+int UserCopySize;
+
+int 
+GetDeviceStatus(DeviceInfo_t Device)
+{ 
+  return Device.DeviceStatus;
+}
+
+int 
+SetDeviceStatus(DeviceInfo_pt pDevice, int Status)
+{ 
+  return pDevice->DeviceStatus = Status;
+}
+
+unsigned short Version=0x0181; /* Upper byte is major, lower byte is Minor */
+static char *version_string="%s driver v%x.%02x";
+
+int ubsec_major_number = -1;
+static int SelectedDevice=0;
+/*
+ *  UBSEC's set of file operations.  This is the data structure that
+ *  will be passed when we call register_chrdev().
+ */
+#ifndef LINUX2dot2
+static struct file_operations ubsec_file_ops = {
+ 
+        owner:          THIS_MODULE,
+        ioctl:          ubsec_ioctl,
+        open:           ubsec_open,
+        release:        ubsec_release,
+};
+ 
+#else       
+struct file_operations ubsec_file_ops = {
+  NULL,          /* lseek   */
+  NULL,          /* read    */
+  NULL,          /* write   */
+  NULL,          /* readdir */
+  NULL,          /* select  */
+  ubsec_ioctl,/* ioctl   */
+  NULL,          /* mmap    */
+  ubsec_open,          /* open    */
+  NULL,          /* flush    */
+  ubsec_release,          /* release */
+  NULL           /* fsync   */
+  /* fill any remaining entries with NULL */
+};
+
+#endif
+
+/**************************************************************************
+ *
+ *  Function:  ubsec_ioctl
+ *
+ *************************************************************************/
+static int 
+ubsec_ioctl(struct inode *inode,struct file *filp,unsigned int cmd, unsigned long arg)
+{
+
+  long			Retval=0;
+
+  int                   status = 0;
+  int                   deadlockctr = 0;
+  
+  unsigned short        value;
+
+  
+  
+  /* Simple round robin scheduling of device. We need to increment
+     first since the keysetup command may block. */
+  
+ TheBeginning:
+
+  deadlockctr = 0;
+  do {
+
+    /* For diagnostic related stuff do not try any available devices */
+    /* Try the intended device or all devices as directed by the command */
+
+    if (cmd >= UBSEC_DEVICEDUMP || cmd == UBSEC_SELFTEST || cmd == UBSEC_FAILDEVICE) {
+      break;
+    }
+
+    if(++deadlockctr == (NumDevices * 2)) {  /* to be conservative... */
+#ifdef DEBUG_FAILOVER
+      PRINTK("dispatch found no more devices.\n");
+#endif
+      return 1; /* error: no more devices */
+    }
+
+    if ((++SelectedDevice) == NumDevices)
+      SelectedDevice=0;
+
+  } while(GetDeviceStatus(DeviceInfoList[SelectedDevice]));
+
+#ifdef DEBUG_FAILOVER
+  printk("\n");
+  PRINTK("dsptch-pre: SltdDev=%d,DevStati=%d %d\n", 
+	 SelectedDevice, DeviceInfoList[0].DeviceStatus, DeviceInfoList[1].DeviceStatus);
+#endif
+
+
+  switch(cmd) {
+#ifdef BCM_OEM_1
+  case BCM_OEM_1_IOCTL1:
+	BCM_OEM1_IOCTL1_HANDLER();
+	break;
+  case BCM_OEM_1_IOCTL2:
+	BCM_OEM1_IOCTL2_HANDLER();
+	break;
+#endif /* BCM_OEM_1 */
+
+  case UBSEC_ENCRYPT_DECRYPT_FUNC:
+    status = do_encrypt(DeviceInfoList[SelectedDevice].Context, 
+			(void *)arg, DeviceInfoList[SelectedDevice].Features);
+    break;
+
+  case UBSEC_KEY_SETUP_FUNC:
+    status = ubsec_keysetup(DeviceInfoList[SelectedDevice].Context, (void *)arg);
+    break;
+
+  case UBSEC_MATH_FUNC:
+    status = ubsec_math(DeviceInfoList[SelectedDevice].Context, (void *)arg);
+    break;
+
+  case UBSEC_RNG_FUNC:
+    if (DeviceInfoList[SelectedDevice].Features & UBSEC_EXTCHIPINFO_RNG)
+      status = ubsec_rng(DeviceInfoList[SelectedDevice].Context, (void *)arg);
+    else
+      status = UBSEC_STATUS_NO_DEVICE;
+    break;
+    
+  case UBSEC_TLS_HMAC_FUNC:
+    status = ubsec_tlsmac(DeviceInfoList[SelectedDevice].Context, (void *)arg);
+    break;
+    
+  case UBSEC_SSL_MAC_FUNC:
+    status = ubsec_sslmac(DeviceInfoList[SelectedDevice].Context, (void *)arg);
+    break;
+    
+  case UBSEC_SSL_HASH_FUNC:
+    status = ubsec_hash(DeviceInfoList[SelectedDevice].Context, (void *)arg);
+    break;
+
+  case UBSEC_SSL_DES_FUNC:
+    status = ubsec_sslcipher(DeviceInfoList[SelectedDevice].Context, (void *)arg,
+			     DeviceInfoList[SelectedDevice].Features);
+    break;
+
+  case UBSEC_SSL_ARC4_FUNC:
+    if (DeviceInfoList[SelectedDevice].Features & UBSEC_EXTCHIPINFO_ARC4)
+      status = ubsec_sslarc4(DeviceInfoList[SelectedDevice].Context, (void *)arg);
+    else
+      status = UBSEC_STATUS_NO_DEVICE;
+    break;
+
+  case UBSEC_CHIPINFO_FUNC:
+    status = obsolete_chipinfo(DeviceInfoList[SelectedDevice].Context, (void *)arg);
+    break;
+
+  case UBSEC_STATS_FUNC:
+    {
+      ubsec_stats_io_t IOInfo;
+      int device_num;
+      if (copy_from_user((void *) &IOInfo,(void *) arg, sizeof(ubsec_stats_io_t)))
+        return -EFAULT; 
+      device_num  = IOInfo.device_num;
+
+
+	if ( (device_num >= NumDevices) || (device_num < 0) )
+		return -1;
+
+      ubsec_GetStatistics(DeviceInfoList[device_num].Context, &IOInfo.dev_stats);
+      if (copy_to_user((void *) arg, (void *) &IOInfo, sizeof(ubsec_stats_io_t)))
+        return -EFAULT;
+    }
+    break;
+    
+  case UBSEC_EXTCHIPINFO_FUNC:
+    if (copy_from_user((void *)&ExtChipInfo, (void *)arg, sizeof(ubsec_chipinfo_io_t)))
+      return -EFAULT; 
+    if (ExtChipInfo.Status !=sizeof(ubsec_chipinfo_io_t)) {
+      UserCopySize = sizeof(ubsec_chipinfo_io_t);
+      if (UserCopySize > ExtChipInfo.Status)
+	UserCopySize = ExtChipInfo.Status;
+      ExtChipInfo.Status = UBSEC_STATUS_NO_DEVICE;
+      if (copy_to_user((void *)arg, (void *)&ExtChipInfo, UserCopySize))
+        return -EFAULT;
+      return(-1);
+    }
+    else if ((ExtChipInfo.CardNum >= NumDevices) || (ExtChipInfo.CardNum < 0)) {
+      ExtChipInfo.CardNum = NumDevices; 
+      ExtChipInfo.Status = UBSEC_STATUS_INVALID_PARAMETER; 
+    }
+    else {
+      status = ubsec_chipinfo(DeviceInfoList[ExtChipInfo.CardNum].Context, &ExtChipInfo); 
+      ExtChipInfo.NumDevices = NumDevices; 
+      ExtChipInfo.Features &= DeviceInfoList[ExtChipInfo.CardNum].Features;
+      ExtChipInfo.Status = UBSEC_STATUS_SUCCESS; 
+    }
+    if (copy_to_user((void *)arg, (void *)&ExtChipInfo, sizeof(ubsec_chipinfo_io_t)))
+      return -EFAULT; 
+    if (ExtChipInfo.Status != UBSEC_STATUS_SUCCESS)
+      return(-1);
+    else
+      return(0);
+    break;
+    
+  case UBSEC_DEVICEDUMP:
+    if (copy_from_user((void *)&PInt_Contents, (void *)arg, sizeof(int)))
+      return -EFAULT;
+    Retval=DumpDeviceInfo((PInt)&PInt_Contents);
+    if (Retval)
+      return(-1); /* Error */
+    break;
+
+  case UBSEC_FAILDEVICE:
+    if (copy_from_user((void *)&PInt_Contents, (void *)arg, sizeof(int)))
+      return -EFAULT;
+    Retval=FailDevices((PInt)&PInt_Contents);
+    if (Retval)
+      return(-1); /* Error */
+    break;
+
+  case UBSEC_SELFTEST:
+#ifdef BCM_OEM_1
+	DISABLE_BCM_OEM1();
+#endif /*BCM_OEM_1 */
+    if (copy_from_user((void *)&PInt_Contents, (void *)arg, sizeof(int)))
+      return -EFAULT;
+    Retval=TestDevices((PInt)&PInt_Contents);
+#ifdef BCM_OEM_1
+	ENABLE_BCM_OEM1();
+#endif /*BCM_OEM_1 */
+    if (Retval)
+      return (Retval); /* Error */
+
+  case UBSEC_GETVERSION:
+    if (copy_from_user((void *)&PInt_Contents, (void *)arg, sizeof(int)))
+      return -EFAULT;
+    Retval=GetHardwareVersion((PInt)&PInt_Contents); /* For the moment one card */
+    Retval=Retval<<16;
+    Retval+=Version;
+    #ifdef LINUX_IA64
+    return Retval;
+    #else
+    return(-Retval);
+    #endif
+    break;
+
+  case UBSEC_GETNUMCARDS:
+	if (copy_to_user((void *)arg,&NumDevices,sizeof(int)))
+          return -EFAULT;
+    return NumDevices;
+
+
+  case  UBSEC_GET_FUNCTION_PTRS:
+	{
+	ubsec_Function_Ptrs_t fptrs;
+	get_ubsec_Function_Ptrs(&fptrs);
+      	if (copy_to_user((void *) arg, (void *) &fptrs, sizeof(ubsec_Function_Ptrs_t)))
+          return -EFAULT;
+	}
+    break;
+
+#ifdef DVT 
+  case UBSEC_RESERVED:
+    if (copy_from_user((void *)&DVTparams, (void *)arg, sizeof(DVT_Params_t)))
+      return -EFAULT;
+    if ((DVTparams.CardNum >= NumDevices) || (DVTparams.CardNum < 0)) {
+      {PRINTK("Invalid CardNum (%d), must be 0",DVTparams.CardNum);}
+      if (NumDevices == 1)
+	printk("\n");
+      else
+	printk("-%d\n",NumDevices-1);
+      return -1; 
+    }
+    switch (DVTparams.Command) {
+    case UBSEC_DVT_PAGESIZE: /* Wrapper command */
+      DVTparams.OutParameter = Page_Size;
+      if (!DVTparams.InParameter) {
+	DVTparams.OutParameter = Page_Size = PAGE_SIZE;
+	DVTparams.Status = UBSEC_STATUS_SUCCESS;
+	Retval = UBSEC_STATUS_SUCCESS;
+      }      
+      else if ((DVTparams.InParameter > PAGE_SIZE) ||
+	       (DVTparams.InParameter < 2)) {
+	DVTparams.Status = UBSEC_STATUS_INVALID_PARAMETER;
+      }
+      else {
+	if (!power_of_2(DVTparams.InParameter))
+	  DVTparams.InParameter = next_smaller_power_of_2(DVTparams.InParameter);
+	DVTparams.OutParameter = Page_Size; 
+	Page_Size = DVTparams.InParameter; 
+	DVTparams.Status = UBSEC_STATUS_SUCCESS;
+	Retval = UBSEC_STATUS_SUCCESS;
+      }
+      break;
+    default:
+      /* Pass all other commands down to the SRL */
+      Retval=ubsec_dvt_handler((void *)DeviceInfoList[DVTparams.CardNum].Context,(void *)&DVTparams); 
+    };
+    if (copy_to_user((void *)arg, (void *)&DVTparams, sizeof(DVT_Params_t)))
+      return -EFAULT;
+    return(Retval);
+    break;
+#endif /* DVT */
+
+  default:
+    return -EINVAL;
+  }
+  
+#ifdef DEBUG_FAILOVER
+  PRINTK("dsptch-pst: SltdDev=%d,DevStati=%d %d\n", 
+	 SelectedDevice, DeviceInfoList[0].DeviceStatus, DeviceInfoList[1].DeviceStatus);
+  if((status == ETIMEDOUT) || (status == -ETIMEDOUT)) {
+    PRINTK("dispatch.c: TIMED OUT SelectedDevice=%d, DeviceStatus=%d\n", 
+	   SelectedDevice, DeviceInfoList[SelectedDevice].DeviceStatus);
+  }
+#endif
+
+  switch(status) {
+  case 0:
+    break;
+
+  case (ETIMEDOUT):
+    status = -ETIMEDOUT;
+  case (-ETIMEDOUT):
+    DeviceInfoList[SelectedDevice].DeviceStatus = TestDevice(SelectedDevice);
+    /*  goto TheBeginning; */
+    return(status);
+    break;
+    
+  default:
+    /*  goto TheBeginning; */
+    return(status);
+    break;
+  }
+  
+  return 0;
+}
+
+
+/**************************************************************************
+ *
+ *  Function:  init_module
+ *   
+ *************************************************************************/
+int init_module(void)
+{
+  printk(version_string,UBS_DEVICE_TYPE,Version>>8,Version&0xff);
+
+#ifdef DEBUG
+  printk(" (SRL v%d.%x%c):\n",UBSEC_VERSION_MAJOR,UBSEC_VERSION_MINOR,UBSEC_VERSION_REV);
+#else
+  printk(":\n");
+#endif
+
+/*
+ * First try to find and initialize the ubsec devices.
+ */
+ if ((NumDevices=InitDevices(NUMBER_OF_CRYPTO_MCRS,NUMBER_OF_KEY_MCRS)) ==0) {
+   PRINTK(KERN_DEBUG "Device startup failed\n");
+   return -ENOMEM;
+ }
+
+#ifdef BCM_OEM_1
+	INIT_BCM_OEM_1();
+#endif
+
+ if (init_keyif() < 0) {
+   PRINTK(KERN_DEBUG "no memory for key buffer\n");
+   return(ENOMEM);
+ }
+
+ if (init_mathif() < 0) {
+   PRINTK(KERN_DEBUG "no memory for mathif buffer\n");
+   shutdown_keyif();
+   return(ENOMEM);
+ }
+
+ if (init_rngif() < 0) {
+   PRINTK(KERN_DEBUG "no memory for rng buffer\n");
+   shutdown_keyif();
+   shutdown_mathif();
+   return(ENOMEM);
+ }
+
+ if (init_cryptoif() < 0) {
+   PRINTK(KERN_DEBUG "crypto init failed\n");
+   shutdown_keyif();
+   shutdown_mathif();
+   return(ENOMEM);
+ }
+
+ if(init_arc4if() < 0) {
+   PRINTK(KERN_DEBUG "ssl init failed\n");
+   shutdown_cryptoif();
+   shutdown_rngif();
+   shutdown_keyif();
+   shutdown_mathif();
+   return(ENOMEM);
+ }
+
+
+ /* create a /proc/net/ubsec entry for possible SNMP support */
+#if (defined(UBSEC_STATS) && defined(CONFIG_PROC_FS))
+  init_snmp_stats_support();
+#endif
+
+  /*
+   *  Register the device -- ask for a dnynamicly assigned major number
+   */
+ ubsec_major_number = register_chrdev(0, UBSEC_KEYDEVICE_NAME, &ubsec_file_ops);
+ if(ubsec_major_number < 0 ) /* Bound? */
+   return(ubsec_major_number);
+
+#if 0 
+register_chrdev(ubsec_major_number, UBSEC_KEYDEVICE_NAME, &ubsec_file_ops);
+#endif
+
+ EXPORT_NO_SYMBOLS;
+ return 0; /* success */
+}
+
+/**************************************************************************
+ *
+ *  Function:  cleanup_module
+ *
+ *************************************************************************/
+void
+cleanup_module(void)
+{
+  int i;
+
+#ifdef BCM_OEM_1
+	SHUTDOWN_BCM_OEM_1();
+#endif /* BCM_OEM_1 */
+
+  shutdown_keyif();
+  shutdown_mathif();
+  shutdown_rngif();
+  shutdown_cryptoif();
+  shutdown_arc4if();
+#if (defined(UBSEC_STATS) && defined(CONFIG_PROC_FS))
+  shutdown_snmp_stats_support();
+#endif
+
+
+#if 0
+  unregister_chrdev(ubsec_major_number, UBSEC_DEVICE_NAME);
+#endif
+  unregister_chrdev(ubsec_major_number, UBSEC_KEYDEVICE_NAME);
+
+  /* Shutdown all the devices. */
+  for (i=0; i < NumDevices ; i++)
+    ubsec_ShutdownDevice(DeviceInfoList[i].Context); /* Shutdown the device */
+  PRINTK("Module unloaded\n");
+}
+
+/*
+ * ubsec_open:
+ */
+static int
+ubsec_open(struct inode *inode, struct file *filp)
+{
+  MOD_INC_USE_COUNT;
+  return 0;
+}
+
+/*
+ * ubsec_release:
+ */
+static int
+ubsec_release(struct inode *inode, struct file *filp)
+{
+  MOD_DEC_USE_COUNT;
+  return 0; 
+}
+
+/*
+* get_ubsec_Function_Ptrs 
+* copies the function ptrs for DeviceInfoList, crypto,RNG and DMA Memory access
+*/
+
+void get_ubsec_Function_Ptrs(ubsec_Function_Ptrs_t *fptrs)
+{
+
+extern void * Linux_AllocateDMAMemory(ubsec_DeviceContext_t *context, int size);
+extern void  Linux_FreeDMAMemory(void * virtual , int size);
+
+	fptrs->PhysDeviceInfoList_Ptr = DeviceInfoList;
+	fptrs->OS_AllocateDMAMemory_Fptr = Linux_AllocateDMAMemory;
+	fptrs->OS_FreeDMAMemory_Fptr = Linux_FreeDMAMemory;
+	fptrs->ubsec_InitHMACState_Fptr = ubsec_InitHMACState;
+	fptrs->ubsec_CipherCommand_Fptr = ubsec_CipherCommand;
+	fptrs->ubsec_RNGCommand_Fptr = ubsec_RNGCommand;
+
+	return;
+}
diff -urNp linux-8030/drivers/addon/bcm/hash.c linux-8040/drivers/addon/bcm/hash.c
--- linux-8030/drivers/addon/bcm/hash.c
+++ linux-8040/drivers/addon/bcm/hash.c
@@ -0,0 +1,411 @@
+
+/*
+ *  Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ *  of any kind, either express or implied as further specified in the GNU Public
+ *  License. This software may be used and distributed according to the terms of
+ *  the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+/******************************************************************************
+ *
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+/*
+ * Broadcom Corporation uBSec SDK
+ */
+/*
+ * pkey.c: Character driver interface to public key routines.
+ */
+/*
+ * Revision History:
+ *
+ * March 2001 PW Release for Linux 2.4 UP and SMP kernel
+ * 10/09/2001 SRM 64 bit port
+ */      
+
+#include "cdevincl.h"
+
+/* This is useful only for diagnostics. */
+#undef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+
+#ifdef POLL
+#undef GOTOSLEEP
+#endif
+
+/*
+ * Global Variables:
+ */
+
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+
+unsigned char * pKernSourceBuffer = NULL;
+unsigned char * pKernDestBuffer   = NULL;
+static ubsec_MemAddress_t      PhysSourceBuf;
+static ubsec_MemAddress_t      PhysDestBuf;
+
+#endif /* ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+
+
+/**************************************************************************
+ *
+ * Function:  init_arc4if
+ * 
+ * Called from: init_module() in Linux/dispatch.c
+ *
+ * Description: 
+ *              Buffer sent to SRL is not malloc'd here after all, to allow 
+ *              for re-entrant code.
+ *
+ * Return Values:
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+
+int 
+init_hashif(void) {
+  
+  int error = 0;
+  
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  pKernSourceBuffer = pKernDestBuffer = (char *)kmalloc((MAX_FILE_SIZE),GFP_KERNEL|GFP_ATOMIC);
+  if(pKernSourceBuffer == NULL) {
+    PRINTK("no memory for source buffer %d\n", MAX_FILE_SIZE);
+    error = -ENOMEM;
+    return(error);
+  }
+  memset(pKernSourceBuffer,0, MAX_FILE_SIZE);
+  
+  pKernStateBuffer = (char *)kmalloc((260),GFP_KERNEL|GFP_ATOMIC);
+  if(pKernStateBuffer == NULL) {
+    PRINTK("no memory for source buffer %d\n", 260);
+    error = -ENOMEM;
+    return(error);
+  }
+  memset(pKernStateBuffer,0, 260);
+  
+#ifdef DEBUG
+  
+  PRINTK("Allocate Source: %x %x\n", pKernSourceBuffer, vtophys(pKernSourceBuffer));
+  PRINTK("Allocate Dest: %x %x\n", pKernSourceBuffer, vtophys(pKernSourceBuffer));
+
+#endif /* ifdef DEBUG */
+  
+  PhysSourceBuf = PhysDestBuf = (ubsec_MemAddress_t)(virt_to_bus(pKernSourceBuffer));
+
+#ifdef DEBUG
+  
+  PRINTK("Memory Alloc Source %x %x Dest %x %x for source buffer\n",
+	 pKernSourceBuffer, PhysSourceBuf, KernDestBuffer, PhysDestBuf);
+    
+#endif /* ifdef DEBUG */
+  
+#endif /* ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+
+  return(error);
+}
+
+
+/**************************************************************************
+ *
+ * Function: shutdown_arc4if
+ *
+ * Called from: cleaup_module() in Linux/dispatch.c
+ *
+ * Description:
+ *
+ *************************************************************************/
+
+void 
+shutdown_hashif(void) {
+  
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  if(pKernSourceBuffer != NULL)
+    kfree(pKernSourceBuffer);
+  if(pKernStateBuffer != NULL)
+    kfree(pKernStateBuffer);
+  
+#endif /* ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+  
+  return;
+}
+
+/**************************************************************************
+ *
+ * Function:  ubsec_hash
+ * 
+ * Called from: ubsec_ioctl() in Linux/dispatch.c
+ *
+ * Purpose:
+ *          Wrapper function between user call and call to SRL.
+ *
+ * Description: 
+ *              Prepare all the data from the user's call for a call to 
+ *              the SRL, set up the timer, and finally place this thread
+ *              on the wait queue and go to sleep. When ubsec_arc4 is 
+ *              called, the relevant data for an SSL ARC4 op reside in
+ *              user space. The struct ubecom_arc4_io_pt argument, pIOInfo, 
+ *              points to data on the stack and in kernal space. However, 
+ *              pIOInfo is a struct that contains pointers which still 
+ *              point to memory in user space. ubecom_ssl copies the 
+ *              contents of pIOInfo as well as the input data it points
+ *              to into memory allocated in kernal space with LinuxAllocateMemory.
+ *
+ * Return Values: 
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+
+int
+ubsec_hash(
+	   ubsec_DeviceContext_t pContext,
+	   ubsec_hash_io_t      *pIOInfo
+	   ) {
+  
+  ubsec_hash_io_t                IOInfo;
+  ubsec_SSLCommandInfo_t         SslCommand;
+  ubsec_SSLCommandInfo_pt        pSslCommand       = &SslCommand;
+  ubsec_HashParams_pt            pHashParams       = &(pSslCommand->Parameters.HashParams);
+  volatile CommandContext_t  CommandContext;
+  CommandContext_t          *pCommandContext   = (CommandContext_t *)&CommandContext;
+  int                            NumCommands       = 1;
+  unsigned long		         delayTotalUs      = 0;
+  ubsec_FragmentInfo_pt          pSourceFragments  = NULL;
+  unsigned char *                pUserSourceBuffer = NULL;
+  unsigned int                   SourceBufferBytes = 0;
+  unsigned int                   DestBufferBytes   = 0;
+  int                            error             = 0;
+
+#ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  unsigned char *                pKernSourceBuffer = NULL;
+  unsigned char *                pKernDestBuffer   = NULL;
+  ubsec_MemAddress_t             PhysSourceBuf     = 0;
+  ubsec_MemAddress_t             PhysDestBuf       = 0;
+  
+#endif /* ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+
+  if (copy_from_user(&IOInfo, pIOInfo, sizeof(ubsec_hash_io_t)))
+    return -EFAULT;
+  pUserSourceBuffer = IOInfo.SourceBuffer;
+  SourceBufferBytes = IOInfo.SourceBufferBytes;
+
+  DestBufferBytes   = IOInfo.HashBufferBytes;
+  SourceBufferBytes = IOInfo.SourceBufferBytes;
+  pUserSourceBuffer = IOInfo.SourceBuffer;
+  
+#if DEBUG
+  PRINTK("bytes= %u\n", IOInfo.SourceBufferBytes);
+  PRINTK("bytes= %u\n", SourceBufferBytes);
+  PRINTK("auth_alg = %u\n", IOInfo.auth_alg);
+  PRINTK("bytes= %u\n", IOInfo.HashBufferBytes);
+  PRINTK("bytes= %u\n", DestBufferBytes);
+#endif
+
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  if(SourceBufferBytes > MAX_FILE_SIZE) {
+    PRINTK("input file too large <%d,%d>\n", SourceBufferBytes, MAX_FILE_SIZE);
+    error = -EINVAL;
+    return(error);
+  }
+
+#else
+  
+  pKernSourceBuffer = (char *)kmalloc((SourceBufferBytes),GFP_KERNEL|GFP_ATOMIC);
+  if(pKernSourceBuffer == NULL) {
+    PRINTK("no memory for source buffer %d\n", SourceBufferBytes);
+    error = -ENOMEM;
+    goto ReturnErrorLabel;
+  }
+  memset(pKernSourceBuffer,0, SourceBufferBytes);
+  
+  pKernDestBuffer = (char *)kmalloc((DestBufferBytes),GFP_KERNEL|GFP_ATOMIC);
+  if(pKernDestBuffer == NULL) {
+    PRINTK("no memory for dest buffer %d\n", DestBufferBytes);
+    error = -ENOMEM;
+    goto ReturnErrorLabel;
+  }
+  memset(pKernDestBuffer,0, DestBufferBytes);
+  
+#ifdef DEBUG
+  PRINTK("Allocate Source: %x %x\n", pKernSourceBuffer, vtophys(pKernSourceBuffer));
+  PRINTK("Allocate Source: %x %x\n", pKernDestBuffer, vtophys(pKernDestBuffer));
+#endif /* ifdef DEBUG */
+  
+  PhysSourceBuf = (ubsec_MemAddress_t)(virt_to_bus(pKernSourceBuffer));
+  PhysDestBuf   = (ubsec_MemAddress_t)(virt_to_bus(pKernDestBuffer));
+  
+#ifdef DEBUG
+  PRINTK("Memory Alloc Source %x %x Dest %x %x \n", pKernSourceBuffer, PhysSourceBuf, pKernDestBuffer, PhysDestBuf);
+#endif /* ifdef DEBUG */
+  
+#endif /* ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+
+  /* Assemble Source Fragments */
+  
+  pSourceFragments = kmalloc((((sizeof(ubsec_FragmentInfo_t) * UBSEC_MAX_FRAGMENTS))),GFP_KERNEL|GFP_ATOMIC);
+  if(pSourceFragments == NULL) {
+    PRINTK("no memory for fragment buffer\n");
+    error = -ENOMEM;
+    return(error);
+  }
+  
+  pSslCommand->SourceFragments = pSourceFragments;
+  if ((pSslCommand->NumSource = SetupFragmentList(pSslCommand->SourceFragments,
+						  pKernSourceBuffer,
+						  SourceBufferBytes)) == 0) {
+    /* The input data requires more fragments than the current driver build can provide; return error */
+    error = UBSEC_STATUS_NO_RESOURCE;
+    goto ReturnErrorLabel;
+  }
+  
+  if (copy_from_user(pKernSourceBuffer, pUserSourceBuffer, SourceBufferBytes)) {
+    error = -EFAULT;
+    goto ReturnErrorLabel;
+  }
+  pSslCommand->Command = UBSEC_HASH;
+  if(IOInfo.auth_alg == MAC_SHA1) {
+    pSslCommand->Command |= UBSEC_MAC_SHA1;
+  } else {
+    pSslCommand->Command |= UBSEC_MAC_MD5;
+  }
+  
+#if DEBUG
+  PRINTK("auth_alg = x%x\n", IOInfo.auth_alg);
+  PRINTK("command = x%x\n", pSslCommand->Command);
+#endif
+  
+  /* Assemble Destination Fragment */
+
+  pSslCommand->NumDestination             = 0;
+  pHashParams->OutputHMAC.FragmentAddress = PhysDestBuf;
+  pHashParams->OutputHMAC.FragmentLength  = 0; /* fixed output length */
+  
+  pCommandContext->CallBackStatus = 0;
+  pSslCommand->CommandContext     = (unsigned long) pCommandContext;
+  pSslCommand->CompletionCallback = CmdCompleteCallback;
+
+  start_time(&(pCommandContext->tv_start));
+  
+#if DEBUG
+  PRINTK("Linux:ubsec_sslarc4 just before SRL call...\n");
+#endif
+
+#ifndef LINUX2dot2
+  init_waitqueue_head(&pCommandContext->WaitQ);
+#else
+   pCommandContext->WaitQ         = 0; 
+#endif  
+
+  IOInfo.result_status = ubsec_SSLCommand(pContext, pSslCommand, &NumCommands);
+  
+  switch(IOInfo.result_status) {
+  case UBSEC_STATUS_SUCCESS:
+    break;
+    
+  case UBSEC_STATUS_TIMEOUT:
+    PRINTK(" ubsec_SslCommand() timeout\n");
+    ubsec_ResetDevice(pContext);
+    error = -ETIMEDOUT;
+    goto ReturnErrorLabel;
+    break;
+    
+  case UBSEC_STATUS_INVALID_PARAMETER:
+    PRINTK("  ubsec_SslCommand() invalid parameter\n");
+    error = -EINVAL;
+    goto ReturnErrorLabel;
+    break;
+    
+  case UBSEC_STATUS_NO_RESOURCE:
+    PRINTK(" ubsec_SslCommand() no resource. Number done: %d\n", NumCommands);
+    error = -ENOBUFS;
+    goto ReturnErrorLabel;
+    break;
+    
+  default:
+    error = -ENOMSG;
+    goto ReturnErrorLabel;
+    break;
+  }
+  
+#ifdef GOTOSLEEP
+  
+  if(!(pCommandContext->CallBackStatus))  {/* Just in case completed on same thread. */
+    Gotosleep(&pCommandContext->WaitQ);
+    if (!pCommandContext->CallBackStatus) {
+              pCommandContext->Status=UBSEC_STATUS_TIMEOUT;
+              error = -ETIMEDOUT;
+              ubsec_ResetDevice(pContext);
+              goto ReturnErrorLabel;
+         }
+    }                          
+  
+#else
+  
+  for(delayTotalUs = 1; !(CommandContext.CallBackStatus); delayTotalUs++) {
+    
+#ifdef POLL
+    
+    /* We need to poll the device if we are operating in POLL mode. */
+    ubsec_PollDevice(pContext);
+    
+#endif
+    
+    if(delayTotalUs >= 3000000) {
+      error = -ETIMEDOUT;
+      ubsec_ResetDevice(pContext);
+      goto ReturnErrorLabel;
+    }
+    udelay(1);
+  }
+  
+#endif
+
+#if DEBUG
+  PRINTK("Linux:ubsec_hash: Dest Buffer (post-SRL)\n");
+  for(i = 0; i < UBSEC_HMAC_LENGTH; i++) {
+    PRINTK("%02X", pKernDestBuffer[i]);
+  }
+  PRINTK("\n");
+#endif
+
+  IOInfo.time_us = CommandContext.tv_start.tv_sec * 1000000 + CommandContext.tv_start.tv_usec;
+  if(IOInfo.result_status == UBSEC_STATUS_SUCCESS) {
+    if (copy_to_user(pIOInfo, &IOInfo, sizeof(ubsec_hash_io_t)) ||
+        copy_to_user(pIOInfo->HashBuffer, pKernDestBuffer, DestBufferBytes))
+      error = -EFAULT;
+  }
+  
+ ReturnErrorLabel:
+  
+#ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  if(pKernSourceBuffer != NULL) {
+    kfree(pKernSourceBuffer);
+    pKernSourceBuffer = NULL;
+  }
+  if(pKernDestBuffer != NULL) {
+    kfree(pKernDestBuffer);
+    pKernDestBuffer = NULL;
+  }
+  
+#endif /* ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+  
+  if(pSourceFragments != NULL) {
+    kfree(pSourceFragments);
+    pSourceFragments = NULL;
+  }
+
+  return(error);
+}
+
diff -urNp linux-8030/drivers/addon/bcm/keydefs.h linux-8040/drivers/addon/bcm/keydefs.h
--- linux-8030/drivers/addon/bcm/keydefs.h
+++ linux-8040/drivers/addon/bcm/keydefs.h
@@ -0,0 +1,76 @@
+
+/*
+ *  Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ *  of any kind, either express or implied as further specified in the GNU Public
+ *  License. This software may be used and distributed according to the terms of
+ *  the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+/******************************************************************************
+ *
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+/*
+ * keydefs.h: Misc keytype definitions.
+ *
+ */
+/*
+ * Revision History:
+ *
+ * May 2000 SOR/JTT Created.
+ */
+
+#ifndef _KEY_DEFS_H
+#define _KEY_DEFS_H
+
+/* Maximum key size in bytes */
+#define MAX_KEY_BYTE_SIZE 256
+/* Convert bit length to byte length */
+#define BITSTOBYTES(bitsize) ((bitsize+7)/8)
+/* Intermediate key copy location offsets */
+
+/* Offset of Key information within kernel buffer. */
+#define DH_Y_OFFSET 	0
+#define DH_X_OFFSET 	1
+#define DH_K_OFFSET 	2
+#define DH_N_OFFSET 	3
+#define DH_G_OFFSET 	4
+#define DH_USERX_OFFSET	5
+
+#define RSA_OUT_OFFSET 	0
+#define RSA_IN_OFFSET 	1
+#define RSA_N_OFFSET	3
+#define RSA_E_OFFSET	4
+#define RSA_P_OFFSET	5
+#define RSA_Q_OFFSET	6
+#define RSA_EDP_OFFSET	7
+#define RSA_EDQ_OFFSET	8
+#define RSA_PINV_OFFSET	9
+
+#define DSA_R_OFFSET	1
+#define DSA_S_OFFSET	2
+#define DSA_Q_OFFSET	3
+#define DSA_P_OFFSET	4
+#define DSA_G_OFFSET	5
+#define DSA_KEY_OFFSET	6
+#define DSA_RAND_OFFSET	7
+#define DSA_V_OFFSET 	8
+#define DSA_IN_OFFSET 	9
+
+#define MAX_NUM_KEY_PARAMS 10
+
+#endif /* KEY_DEFS_H */
+
+
+
+
+
diff -urNp linux-8030/drivers/addon/bcm/math.c linux-8040/drivers/addon/bcm/math.c
--- linux-8030/drivers/addon/bcm/math.c
+++ linux-8040/drivers/addon/bcm/math.c
@@ -0,0 +1,355 @@
+
+/*
+ *  Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ *  of any kind, either express or implied as further specified in the GNU Public
+ *  License. This software may be used and distributed according to the terms of
+ *  the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+/******************************************************************************
+ *
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+/*
+ * math.c: Character driver interface to MATH routines in the ubsec driver
+ *
+ * SOR
+ * JJT
+ * March 2001 PW Release for Linux 2.4 UP and SMP kernel
+ * 10/09/2001 SRM 64 bit port
+ */
+
+#include "cdevincl.h"
+
+/* Maximum key size in bytes */
+#define MAX_KEY_BYTE_SIZE 256
+
+/* Intermediate key copy location offsets */
+
+/* Offset of Key information within kernel buffer. */
+#define MATH_MODN_OFFSET 	0
+#define MATH_MODN2_OFFSET 	1
+#define MATH_PARAMA_OFFSET 	2
+#define MATH_PARAMB_OFFSET 	3
+#define MATH_PARAMC_OFFSET 	4
+#define MATH_PARAMD_OFFSET 	5
+#define MATH_RESULT_OFFSET 	6
+#define MATH_RESULT2_OFFSET 	7
+
+#define MAX_NUM_MATH_PARAMS 8
+
+#ifdef POLL
+#undef GOTOSLEEP
+#endif
+
+static int ubsec_mathsetup(unsigned long command, 
+	ubsec_MathCommandParams_pt pIOparams, ubsec_MathCommandParams_pt pSRLparams, 	
+	unsigned char *MathLoc);
+
+void ubsec_pkey(ubsec_io_t *at);
+
+/**************************************************************************
+ *
+ *  Function:  init_pkeyif
+ *   
+ *************************************************************************/
+int init_mathif(void)
+{
+ return 0; /* success */
+}
+
+
+
+/**************************************************************************
+ *
+ *  Function:  cleanup_module
+ *
+ *************************************************************************/
+void shutdown_mathif(void)
+{
+  return;
+}
+
+/*
+ * Math function  setup function. Builds MathCommandInfo for call to SRL.
+ * Returns number of bits to normalize.
+ */
+static int ubsec_mathsetup(unsigned long command, 
+			   ubsec_MathCommandParams_pt pSRLparams, 	
+			   ubsec_MathCommandParams_pt pIOparams, 
+			   unsigned char *MathLoc)
+{
+  /*
+   * Do a brute force copy of the math command. This will set the
+   * lengths etc but we still need to set the pointers.
+   */
+  *pSRLparams=*pIOparams;
+
+
+  /* Validation of the Length */
+  if (command == UBSEC_MATH_DBLMODEXP) { 
+    CHECK_SIZE(pIOparams->ModN.KeyLength , 512);
+    CHECK_SIZE(pIOparams->ModN2.KeyLength , 512);
+  }
+  else {
+    CHECK_SIZE(pIOparams->ModN.KeyLength , MAX_MATH_LENGTH_BITS);
+  }
+
+  /* 
+   * Setup Math parameter locations and align them. Start with modulus N.
+   */
+  if (copy_from_user( &MathLoc[MAX_KEY_BYTE_SIZE*MATH_MODN_OFFSET],pIOparams->ModN.KeyValue,
+	 ROUNDUP_TO_32_BIT(pIOparams->ModN.KeyLength)/8))
+    return -EFAULT;
+  /*  Modulus is a virtual address. */
+  pSRLparams->ModN.KeyValue=(void *)&MathLoc[MAX_KEY_BYTE_SIZE*MATH_MODN_OFFSET];
+
+  /* Always copy in paramA */
+   /* Validation of the Length */
+   CHECK_SIZE(pIOparams->ParamA.KeyLength , MAX_MATH_LENGTH_BITS);
+  if (copy_from_user( &MathLoc[MAX_KEY_BYTE_SIZE*MATH_PARAMA_OFFSET],pIOparams->ParamA.KeyValue,
+	 ROUNDUP_TO_32_BIT(pIOparams->ParamA.KeyLength)/8))
+    return -EFAULT;
+  pSRLparams->ParamA.KeyValue=(void *) (&MathLoc[MAX_KEY_BYTE_SIZE*MATH_PARAMA_OFFSET]);
+
+  /* Optionally copy in paramB */
+  if (command!=UBSEC_MATH_MODREM) {
+   /* Validation of the Length */
+   CHECK_SIZE(pIOparams->ParamB.KeyLength , MAX_MATH_LENGTH_BITS);
+    if (copy_from_user( &MathLoc[MAX_KEY_BYTE_SIZE*MATH_PARAMB_OFFSET],pIOparams->ParamB.KeyValue,
+	 ROUNDUP_TO_32_BIT(pIOparams->ParamB.KeyLength)/8))
+      return -EFAULT;
+    pSRLparams->ParamB.KeyValue=(void *) (&MathLoc[MAX_KEY_BYTE_SIZE*MATH_PARAMB_OFFSET]);
+  }
+   
+  pSRLparams->Result.KeyValue=(void *) (&MathLoc[MAX_KEY_BYTE_SIZE*MATH_RESULT_OFFSET]);
+  pSRLparams->Result.KeyLength = pIOparams->ModN.KeyLength;
+ 
+  /* Optionally copy in the Double ModExp params */
+  if (command == UBSEC_MATH_DBLMODEXP) {
+
+    /* Second modulus N2 */
+    if (copy_from_user( &MathLoc[MAX_KEY_BYTE_SIZE*MATH_MODN2_OFFSET],pIOparams->ModN2.KeyValue,
+		    ROUNDUP_TO_32_BIT(pIOparams->ModN2.KeyLength)/8))
+      return -EFAULT;
+    /*  Modulus is a virtual address. */
+    pSRLparams->ModN2.KeyValue=(void *)&MathLoc[MAX_KEY_BYTE_SIZE*MATH_MODN2_OFFSET];
+
+    /* Parameter C */
+    /* Validation of the Length */
+    CHECK_SIZE(pIOparams->ParamC.KeyLength , MAX_MATH_LENGTH_BITS);
+    if (copy_from_user( &MathLoc[MAX_KEY_BYTE_SIZE*MATH_PARAMC_OFFSET],pIOparams->ParamC.KeyValue,
+		    ROUNDUP_TO_32_BIT(pIOparams->ParamC.KeyLength)/8))
+      return -EFAULT;
+    pSRLparams->ParamC.KeyValue=(void *) (&MathLoc[MAX_KEY_BYTE_SIZE*MATH_PARAMC_OFFSET]);
+
+    /* Parameter D */
+    /* Validation of the Length */
+    CHECK_SIZE(pIOparams->ParamD.KeyLength , MAX_MATH_LENGTH_BITS);
+    if (copy_from_user( &MathLoc[MAX_KEY_BYTE_SIZE*MATH_PARAMD_OFFSET],pIOparams->ParamD.KeyValue,
+		    ROUNDUP_TO_32_BIT(pIOparams->ParamD.KeyLength)/8))
+      return -EFAULT;
+    pSRLparams->ParamD.KeyValue=(void *) (&MathLoc[MAX_KEY_BYTE_SIZE*MATH_PARAMD_OFFSET]);
+
+    /* Second result Result2 */
+    pSRLparams->Result2.KeyValue=(void *) (&MathLoc[MAX_KEY_BYTE_SIZE*MATH_RESULT2_OFFSET]);
+    pSRLparams->Result2.KeyLength = pIOparams->ModN2.KeyLength;
+  }
+
+  return 0;
+}
+
+/*
+ *
+ */
+int
+ubsec_math(ubsec_DeviceContext_t pContext,
+	   ubsec_math_io_t *pIOInfo)
+{
+  ubsec_MathCommandInfo_pt	kcmd;
+  ubsec_MathCommandParams_pt	pMathparams=NULL, 
+				pIOparams = NULL;
+#ifndef GOTOSLEEP
+  unsigned long			delay_total_us;
+#endif
+  unsigned char			*MathLoc;
+  unsigned int			num_commands=1;
+  ubsec_math_io_t		MathCommand;
+  ubsec_math_io_pt		pMathIOInfo=&MathCommand;
+  int				error = 0;
+  CommandContext_pt		pCommandContext;
+  char				*pmath_buf=NULL;
+
+  pmath_buf = (char *) kmalloc((4096),GFP_KERNEL|GFP_ATOMIC);
+  if( pmath_buf == NULL ) {
+    PRINTK("no memory for math buffer\n");
+    return -ENOMEM;
+  }
+  memset(pmath_buf,0,4096);
+
+  if (copy_from_user( pMathIOInfo, pIOInfo, sizeof(*pMathIOInfo)))
+    return -EFAULT;
+  pIOparams=&pMathIOInfo->Math;
+
+#if 0
+#ifdef GOTOSLEEP
+  WaitQ= (struct wait_queue *)pmath_buf;
+  kcmd=&WaitQ[1];
+#else
+  kcmd = (ubsec_MathCommandInfo_pt)pmath_buf;
+#endif
+  tv_start =(struct timeval *)(&kcmd[1]);
+  pStatus = (long *)(&tv_start[1]);
+  pCallbackStatus = (int *)(&pStatus[1]);
+
+	/* Set up starting key location. */
+  MathLoc=(unsigned char *)&pCallbackStatus[1];
+#endif
+
+  pCommandContext = (CommandContext_pt)pmath_buf;
+  kcmd = (ubsec_MathCommandInfo_pt)&pCommandContext[1];
+  pMathparams=&kcmd->Parameters;
+  MathLoc=(unsigned char *)&kcmd[1];
+
+#ifndef LINUX2dot2
+  init_waitqueue_head(&pCommandContext->WaitQ);
+#else
+   pCommandContext->WaitQ         = 0; 
+#endif
+    
+	/*
+	 * Now we need to format the command for the SRL.
+	 * This depends on the type of the key command.
+	 */
+  switch (kcmd->Command=pMathIOInfo->command) {
+  case UBSEC_MATH_MODADD :
+  case UBSEC_MATH_MODSUB :
+  case UBSEC_MATH_MODMUL :
+  case UBSEC_MATH_MODEXP :
+  case UBSEC_MATH_MODREM :
+  case UBSEC_MATH_DBLMODEXP:
+    	if((error = ubsec_mathsetup(pMathIOInfo->command, &kcmd->Parameters,
+			       &pMathIOInfo->Math, MathLoc)) < 0) {
+	goto Free_Return;
+	}
+    break;
+
+  default:
+    PRINTK("Invalid Math Command %lx\n",kcmd->Command);
+    return EINVAL;
+  }
+
+
+
+  kcmd->CompletionCallback = CmdCompleteCallback;
+  kcmd->CommandContext=(unsigned long)pmath_buf;
+
+	/*
+	 *  Let the system do anything it may want/need to do before we begin
+	 *  timing.
+	 */
+  do_gettimeofday(&pCommandContext->tv_start);
+  
+  pCommandContext->CallBackStatus=0; /* inc'd on callback */
+  switch (pMathIOInfo->result_status=ubsec_MathCommand(pContext,kcmd,&num_commands) ) {
+  case UBSEC_STATUS_SUCCESS:
+    break;
+  case UBSEC_STATUS_TIMEOUT:
+    PRINTK("ubsec_Command() Timeout\n");
+    ubsec_ResetDevice(pContext);
+    error = -ETIMEDOUT;
+    goto Return;
+    break;
+
+  case UBSEC_STATUS_INVALID_PARAMETER:
+    PRINTK("ubsec_Command() Invalid parameter\n");
+    error = -EINVAL;
+    goto Return;
+    break;
+
+  case UBSEC_STATUS_NO_RESOURCE:
+    PRINTK(" ubsec_Command() No math resource. Num Done %d\n",num_commands);
+    error = -ENOBUFS;
+  default:
+    error = -EIO;
+    goto Return;
+    break;
+  }
+
+#ifndef GOTOSLEEP      /* We need to poll the device if we are operating in POLL mode. */
+  for (delay_total_us=1  ; !pCommandContext->CallBackStatus ; delay_total_us++) {
+#ifdef POLL
+    ubsec_PollDevice(pContext);
+#endif
+    if (delay_total_us >= 30000000) {
+      PRINTK("Command timeout\n");
+      pCommandContext->Status=UBSEC_STATUS_TIMEOUT;
+      error = -ETIMEDOUT;
+      ubsec_ResetDevice(pContext);
+      goto Return;
+    }
+    udelay(1);
+  }
+#else
+  if (!pCommandContext->CallBackStatus) { /* Just in case completed on same thread. */
+    Gotosleep(&pCommandContext->WaitQ);
+    if (!pCommandContext->CallBackStatus) {
+              pCommandContext->Status=UBSEC_STATUS_TIMEOUT;
+      	      ubsec_ResetDevice(pContext);
+	      error = -ETIMEDOUT;
+	      goto Return;
+    }                          
+  }
+
+#endif
+
+  pMathIOInfo->result_status = pCommandContext->Status;
+  pMathIOInfo->time_us = pCommandContext->tv_start.tv_sec * 1000000 + 
+	pCommandContext->tv_start.tv_usec;
+
+  /*
+   * Status gets set above to timeout or in callback to success indicator.
+   */
+  if (pMathIOInfo->result_status == UBSEC_STATUS_SUCCESS) {
+  	/* 
+  	 * Now we need to copyout those parameters that were changed
+  	 */
+    pIOparams->Result.KeyLength = pMathparams->Result.KeyLength;
+    if (copy_to_user(pIOparams->Result.KeyValue,
+		 &MathLoc[MAX_KEY_BYTE_SIZE*MATH_RESULT_OFFSET],
+		 ROUNDUP_TO_32_BIT(pIOparams->Result.KeyLength)/8)) {
+      error = -EFAULT;
+      goto Free_Return;
+    }
+    /* Optionally copy out the Double ModExp params */
+    if (pMathIOInfo->command == UBSEC_MATH_DBLMODEXP) {
+      pIOparams->Result2.KeyLength = pMathparams->Result2.KeyLength;
+      if (copy_to_user(pIOparams->Result2.KeyValue,
+		   &MathLoc[MAX_KEY_BYTE_SIZE*MATH_RESULT2_OFFSET],
+		   ROUNDUP_TO_32_BIT(pIOparams->Result2.KeyLength)/8)) {
+        error = -EFAULT;
+        goto Free_Return;
+      }
+    }
+
+  } else {
+		error = -ENOMSG;
+	}
+
+ Return:
+	/*
+	 * Copyback the result
+	 */
+	if (copy_to_user(pIOInfo, pMathIOInfo, sizeof(*pMathIOInfo)))
+          error = -EFAULT;
+ Free_Return:
+  	if (pmath_buf) kfree(pmath_buf);
+	return error;
+}
+
diff -urNp linux-8030/drivers/addon/bcm/memory.c linux-8040/drivers/addon/bcm/memory.c
--- linux-8030/drivers/addon/bcm/memory.c
+++ linux-8040/drivers/addon/bcm/memory.c
@@ -0,0 +1,126 @@
+
+/*
+ *  Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ *  of any kind, either express or implied as further specified in the GNU Public
+ *  License. This software may be used and distributed according to the terms of
+ *  the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+/*
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+/*
+ * Broadcom Corporation uBSec SDK
+ */
+/*
+ * Revision History:
+ *
+ * March 2001 PW Created, Release for Linux 2.4 UP and SMP kernel
+ */                                         
+
+#include "cdevincl.h"
+
+#ifndef LINUX2dot2
+struct pci_dev *globalpDev;
+#endif 
+
+void *LinuxAllocateMemory(unsigned long size) ;
+void LinuxFreeMemory(void *virtual);
+#if 0
+void *LinuxAllocateMemory(unsigned long size) {
+    dma_addr_t dma_handle;
+    struct list_node *temp;
+    void *virtual;
+    
+    temp = my_get_free_q();
+    if (temp == NULL) {
+
+        printk("<0> Unable to allocate memory\n");
+        while(1);
+    }
+    virtual = pci_alloc_consistent(globalpDev, size, &dma_handle);
+
+    my_put_busy_q(temp, virtual, size, dma_handle);
+
+    return virtual;
+}
+
+void
+LinuxFreeMemory(void *virtual)
+{
+    struct list_node *temp;
+    struct pci_dev *pDev;
+
+
+    if ((temp = my_get_busy_q(virtual)) == NULL) {
+
+        printk("<0> Unable to find virtual %x\n",virtual);
+        return;
+    }
+    pci_free_consistent(globalpDev, temp->size, virtual, temp->dma_handle);
+    my_put_free_q(temp);    
+
+}
+#else
+
+void *LinuxAllocateMemory(unsigned long size)
+{
+   return kmalloc(size, GFP_KERNEL|GFP_ATOMIC);
+}
+
+void
+LinuxFreeMemory(void *virtual)
+{
+    kfree(virtual);
+}
+
+void *LinuxAllocateDMAMemory(unsigned long size) 
+{
+    return kmalloc(size, GFP_KERNEL| GFP_ATOMIC);
+}
+
+void
+LinuxFreeDMAMemory(void *virtual)
+{
+    kfree(virtual);
+}
+#endif
+
+unsigned long
+LinuxGetPhysicalAddress(void *virtual)
+{
+   return virt_to_bus(virtual);
+}
+
+unsigned long
+LinuxGetVirtualAddress(void *virtual)
+{
+   return (unsigned long) virtual ;
+}
+
+void *LinuxMapPhysToIO(unsigned long Physical_Address, int size)
+{
+	return ioremap(Physical_Address,size );
+}
+
+void LinuxUnMapIO( unsigned long ioaddr)
+{
+	iounmap((void *)ioaddr);
+}
+
+/* Made the access functions generic as viewed by SRL(OS_AllocateDMA ... */
+void * Linux_AllocateDMAMemory(ubsec_DeviceContext_t * context, int size)
+{
+	return LinuxAllocateMemory(size);
+}
+void  Linux_FreeDMAMemory(void * virtual , int size)
+{
+	LinuxFreeMemory(virtual);
+	return;
+}
diff -urNp linux-8030/drivers/addon/bcm/param.c linux-8040/drivers/addon/bcm/param.c
--- linux-8030/drivers/addon/bcm/param.c
+++ linux-8040/drivers/addon/bcm/param.c
@@ -0,0 +1,534 @@
+
+/*
+ *  Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ *  of any kind, either express or implied as further specified in the GNU Public
+ *  License. This software may be used and distributed according to the terms of
+ *  the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+/******************************************************************************
+ *
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+/*
+ * param.c: IO parameter manipulation routines
+ */
+/*
+ * Revision History:
+ *
+ * May 2000 SOR/JTT Created.
+ * March 2001 PW Release for Linux 2.4 UP and SMP kernel
+ */
+
+#include "cdevincl.h"
+
+
+
+extern unsigned long Page_Size;
+
+int
+KeyCommandCopyin(unsigned long Command, 
+		 ubsec_KeyCommandParams_pt pSRLParams, 
+		 ubsec_KeyCommandParams_pt pIOparams,
+		 unsigned char *KeyLoc,
+		 ubsec_FragmentInfo_pt pDSAMessageFragList)
+{
+  int error = 0;
+
+  /*
+   * Now we need to format the command for the SRL.
+   * This depends on the type of the key command.
+   */
+  switch (Command) {
+  case UBSEC_DH_PUBLIC    :
+  case UBSEC_DH_SHARED  :
+    if((error = ubsec_keysetup_Diffie_Hellman(Command, pSRLParams,
+					     pIOparams, KeyLoc)) != 0)
+	return error;
+    break;
+
+  case UBSEC_RSA_PUBLIC  :
+  case UBSEC_RSA_PRIVATE  : 
+   if((error = ubsec_keysetup_RSA(Command, pSRLParams,
+				  pIOparams, KeyLoc)) != 0)
+	return error;
+    break;
+
+  case UBSEC_DSA_VERIFY: 
+  case UBSEC_DSA_SIGN: 
+    if ((error = ubsec_keysetup_DSA(Command, pSRLParams,
+			   pIOparams, KeyLoc, 
+			   pDSAMessageFragList)) != 0) {
+      return error;
+    }
+    break;
+
+  default:
+    PRINTK("Invalid Key Command %lx\n",Command);
+    return -EINVAL;
+  }
+
+return error;
+}
+
+/*
+ * 
+ */
+int
+KeyCommandCopyout(unsigned long Command, 
+		 ubsec_KeyCommandParams_pt pSRLParams, 
+		 ubsec_KeyCommandParams_pt pIOparams,
+		 unsigned char *KeyLoc)
+{
+  ubsec_DH_Params_pt pDHSRLparams=NULL,pDHIOparams = NULL;
+  ubsec_RSA_Params_pt pRSASRLparams=NULL, pRSAIOparams=NULL;
+  ubsec_DSA_Params_pt pDSASRLparams=NULL, pDSAIOparams=NULL;
+
+
+  /* 
+   * Now we need to copyout those parameters that were changed
+   */
+  switch (Command) {
+  case UBSEC_DH_SHARED:
+    pDHSRLparams=&pSRLParams->DHParams;
+    pDHIOparams=&pIOparams->DHParams;
+    pDHIOparams->K.KeyLength = pDHSRLparams->K.KeyLength; 
+    if (copy_to_user(pDHIOparams->K.KeyValue,
+		 &KeyLoc[MAX_KEY_BYTE_SIZE*DH_K_OFFSET],
+		 ROUNDUP_TO_32_BIT(pDHIOparams->K.KeyLength)/8))
+      return -EFAULT;
+    break;
+
+  case UBSEC_DH_PUBLIC:
+    pDHSRLparams=&pSRLParams->DHParams;
+    pDHIOparams=&pIOparams->DHParams;
+    pDHIOparams->Y.KeyLength = pDHSRLparams->Y.KeyLength;
+    if (copy_to_user(pDHIOparams->Y.KeyValue,
+		 &KeyLoc[MAX_KEY_BYTE_SIZE*DH_Y_OFFSET],
+		 ROUNDUP_TO_32_BIT(pDHIOparams->Y.KeyLength)/8))
+      return -EFAULT;
+
+    pDHIOparams->X.KeyLength = pDHSRLparams->X.KeyLength;
+    if (copy_to_user(pDHIOparams->X.KeyValue,
+		 &KeyLoc[MAX_KEY_BYTE_SIZE*DH_X_OFFSET],
+		 ROUNDUP_TO_32_BIT(pDHIOparams->X.KeyLength)/8))
+      return -EFAULT;
+    break;
+  case UBSEC_RSA_PUBLIC  :
+  case UBSEC_RSA_PRIVATE  : 
+    pRSASRLparams=&pSRLParams->RSAParams;
+    pRSAIOparams=&pIOparams->RSAParams;
+    pRSAIOparams->OutputKeyInfo.KeyLength =
+      pRSASRLparams->OutputKeyInfo.KeyLength;
+    if (copy_to_user(pRSAIOparams->OutputKeyInfo.KeyValue,
+		 &KeyLoc[MAX_KEY_BYTE_SIZE*RSA_OUT_OFFSET],
+		 ROUNDUP_TO_32_BIT(pRSAIOparams->OutputKeyInfo.KeyLength)/8))
+      return -EFAULT;
+    break;
+
+  case UBSEC_DSA_SIGN     : 
+    pDSASRLparams=&pSRLParams->DSAParams;
+    pDSAIOparams=&pIOparams->DSAParams;
+    pDSAIOparams->SigS.KeyLength = pDSASRLparams->SigS.KeyLength;
+    pDSAIOparams->SigR.KeyLength = pDSASRLparams->SigR.KeyLength;
+    if (copy_to_user(pDSAIOparams->SigS.KeyValue,
+		 &KeyLoc[MAX_KEY_BYTE_SIZE*DSA_S_OFFSET],
+		 ROUNDUP_TO_32_BIT(pDSAIOparams->SigS.KeyLength)/8)
+     || copy_to_user(pDSAIOparams->SigR.KeyValue,
+		 &KeyLoc[MAX_KEY_BYTE_SIZE*DSA_R_OFFSET],
+		 ROUNDUP_TO_32_BIT(pDSAIOparams->SigR.KeyLength)/8))
+      return -EFAULT;
+    break;
+
+  case UBSEC_DSA_VERIFY   : 
+    pDSAIOparams=&pIOparams->DSAParams;
+    pDSASRLparams=&pSRLParams->DSAParams;
+    pDSAIOparams->V.KeyLength = pDSASRLparams->V.KeyLength;
+    if (copy_to_user(pDSAIOparams->V.KeyValue,
+		 &KeyLoc[MAX_KEY_BYTE_SIZE*DSA_V_OFFSET],
+		 ROUNDUP_TO_32_BIT(pDSAIOparams->V.KeyLength)/8))
+      return -EFAULT;
+    break;
+  }
+return 0 ;
+}
+
+
+/*
+ * Diffie Hellman key setup function. Builds KeyCommandInfo for call to SRL.
+ */
+int
+ubsec_keysetup_Diffie_Hellman(unsigned long command, 
+			      ubsec_KeyCommandParams_pt pSRLparams, 
+			      ubsec_KeyCommandParams_pt pIOparams,
+			      unsigned char *KeyLoc)
+{
+  ubsec_DH_Params_pt 	pDHSRLparams = &pSRLparams->DHParams;
+  ubsec_DH_Params_pt 	pDHIOparams = &pIOparams->DHParams;
+
+  /* 
+   * Setup key parameter locations and align them. Start with modulus N.
+   */
+
+  /* Validation */
+ CHECK_SIZE(pDHIOparams->N.KeyLength,MAX_KEY_LENGTH_BITS);
+ CHECK_SIZE(pDHIOparams->Y.KeyLength,MAX_KEY_LENGTH_BITS);
+  if (copy_from_user( &KeyLoc[MAX_KEY_BYTE_SIZE*DH_N_OFFSET],pDHIOparams->N.KeyValue,
+	 ROUNDUP_TO_32_BIT(pDHIOparams->N.KeyLength)/8))
+    return -EFAULT;
+  pDHSRLparams->N.KeyValue=(void *)&KeyLoc[MAX_KEY_BYTE_SIZE*DH_N_OFFSET];
+  pDHSRLparams->N.KeyLength = pDHIOparams->N.KeyLength;
+
+  /* 
+   * Now copy in the specific parameters.
+   */
+  if ((command & UBSEC_DH_SHARED)==UBSEC_DH_SHARED) {
+    /*
+     * Computing K=Y**x|N
+     */
+    /* Validation of the Length */
+    CHECK_SIZE(pDHIOparams->K.KeyLength,MAX_KEY_LENGTH_BITS);
+    CHECK_SIZE(pDHIOparams->X.KeyLength,MAX_KEY_LENGTH_BITS);
+    if (copy_from_user(&KeyLoc[MAX_KEY_BYTE_SIZE*DH_Y_OFFSET],pDHIOparams->Y.KeyValue,
+	   ROUNDUP_TO_32_BIT(pDHIOparams->Y.KeyLength)/8))
+      return -EFAULT;
+
+    /*
+     * Copy in our secret value x. 
+     */
+    if (copy_from_user(&KeyLoc[MAX_KEY_BYTE_SIZE*DH_X_OFFSET],pDHIOparams->X.KeyValue,
+	   ROUNDUP_TO_32_BIT(pDHIOparams->X.KeyLength)/8))
+      return -EFAULT;
+    pDHSRLparams->X.KeyLength = pDHIOparams->X.KeyLength;
+	/*
+	 * Output parameter is the shared key. Must represent integral
+	 * number of 32 bit words.
+	 */
+    pDHSRLparams->K.KeyValue=(void *) 
+      (&KeyLoc[MAX_KEY_BYTE_SIZE*DH_K_OFFSET]);
+    pDHSRLparams->K.KeyLength = pDHIOparams->K.KeyLength;
+  } 
+  else {
+    /*
+     * Computing Y=g**x|N
+     */
+    /* Validation of the Length */
+    CHECK_SIZE(pDHIOparams->G.KeyLength,MAX_KEY_LENGTH_BITS);
+
+    if (copy_from_user( &KeyLoc[MAX_KEY_BYTE_SIZE*DH_G_OFFSET],pDHIOparams->G.KeyValue,
+	   ROUNDUP_TO_32_BIT(pDHIOparams->G.KeyLength)/8))
+      return -EFAULT;
+    pDHSRLparams->G.KeyValue=(void *)(&KeyLoc[MAX_KEY_BYTE_SIZE*DH_G_OFFSET]);
+    pDHSRLparams->G.KeyLength = pDHIOparams->G.KeyLength;
+    pDHSRLparams->RNGEnable=pDHIOparams->RNGEnable;
+
+    /*
+     * X and Y are input/output fragment data and must be physical addresses.
+     */
+    pDHSRLparams->X.KeyValue=(void *)(&KeyLoc[MAX_KEY_BYTE_SIZE*DH_X_OFFSET]);
+ 
+    if (!pDHSRLparams->RNGEnable) {
+
+      CHECK_SIZE(pDHIOparams->UserX.KeyLength,MAX_KEY_LENGTH_BITS);
+
+      if (copy_from_user(&KeyLoc[MAX_KEY_BYTE_SIZE*DH_USERX_OFFSET],pDHIOparams->UserX.KeyValue,
+	     ROUNDUP_TO_32_BIT(pDHIOparams->UserX.KeyLength)/8))
+        return -EFAULT;
+      pDHSRLparams->UserX.KeyValue=(void *)
+	(&KeyLoc[MAX_KEY_BYTE_SIZE*DH_USERX_OFFSET]);
+      pDHSRLparams->UserX.KeyLength = pDHIOparams->UserX.KeyLength;
+	/*
+	 * Set length for return. X will be copied from supplied UserX.
+	 */
+      pDHIOparams->X.KeyLength = pDHIOparams->UserX.KeyLength;
+
+	/*
+	 * User supplied secret value will be copied to the output X.
+	 * Output needs to be an integral number of 32-bit words.
+	 */
+      pDHSRLparams->X.KeyLength=pDHIOparams->UserX.KeyLength;
+    }
+    else {
+      /*
+       * Set length for return. X will be the random number
+       * generated by the chip. Output needs to be integral 
+       * number of 32-bit words.
+       */
+      CHECK_SIZE(pDHIOparams->X.KeyLength,MAX_KEY_LENGTH_BITS);
+      CHECK_SIZE(pDHIOparams->RandomKeyLen,MAX_KEY_LENGTH_BITS);
+
+      pDHIOparams->X.KeyLength = pDHIOparams->RandomKeyLen;
+      pDHSRLparams->X.KeyLength = pDHIOparams->X.KeyLength;
+      pDHSRLparams->RandomKeyLen=pDHIOparams->RandomKeyLen;
+    }
+  }
+
+  /*
+   * X and Y are input/output fragment data and must be physical addresses.
+   */
+
+  pDHSRLparams->X.KeyValue=(void *) (&KeyLoc[MAX_KEY_BYTE_SIZE*DH_X_OFFSET]);
+  pDHSRLparams->Y.KeyValue=(void *) (&KeyLoc[MAX_KEY_BYTE_SIZE*DH_Y_OFFSET]);
+  pDHSRLparams->Y.KeyLength = pDHIOparams->Y.KeyLength ;
+
+  return 0 ;
+}
+
+/*
+ * RSA key setup function. Builds KeyCommandInfo for call to SRL.
+ */
+int
+ubsec_keysetup_RSA(unsigned long command, ubsec_KeyCommandParams_pt pSRLparams, 
+	ubsec_KeyCommandParams_pt pIOparams,unsigned char *KeyLoc)
+{
+  ubsec_RSA_Params_pt 	pRSASRLparams=&pSRLparams->RSAParams;
+  ubsec_RSA_Params_pt 	pRSAIOparams=&pIOparams->RSAParams;
+
+  /*
+   * Message in, message out, same for public or private. Both are
+   * fragment data, must be physical address.
+   */
+  CHECK_SIZE(pRSAIOparams->InputKeyInfo.KeyLength,MAX_KEY_LENGTH_BITS);
+  CHECK_SIZE(pRSAIOparams->OutputKeyInfo.KeyLength,MAX_KEY_LENGTH_BITS);
+
+  if (copy_from_user(&KeyLoc[MAX_KEY_BYTE_SIZE*RSA_IN_OFFSET],pRSAIOparams->InputKeyInfo.KeyValue,
+	 ROUNDUP_TO_32_BIT(pRSAIOparams->InputKeyInfo.KeyLength)/8))
+    return -EFAULT;
+
+  /*
+   * Output buffer will have to be corrected to be an integral number of 
+   * 32-bit words. This will depend on the operation.
+   */
+  pRSASRLparams->OutputKeyInfo.KeyValue = (void *) 
+    (&KeyLoc[MAX_KEY_BYTE_SIZE*RSA_OUT_OFFSET]);
+
+  /*
+   * Keys depend on public or private operations.
+   */
+  if ((command & UBSEC_RSA_PUBLIC)==UBSEC_RSA_PUBLIC) {
+    CHECK_SIZE(pRSAIOparams->ModN.KeyLength,MAX_KEY_LENGTH_BITS);
+    CHECK_SIZE(pRSAIOparams->ExpE.KeyLength,MAX_KEY_LENGTH_BITS);
+
+    if (copy_from_user(&KeyLoc[MAX_KEY_BYTE_SIZE*RSA_N_OFFSET],pRSAIOparams->ModN.KeyValue,
+	   ROUNDUP_TO_32_BIT(pRSAIOparams->ModN.KeyLength)/8))
+      return -EFAULT;
+    pRSASRLparams->ModN.KeyValue=
+      (void *)(&KeyLoc[MAX_KEY_BYTE_SIZE*RSA_N_OFFSET]);
+    pRSASRLparams->ModN.KeyLength = pRSAIOparams->ModN.KeyLength;
+
+
+    pRSASRLparams->OutputKeyInfo.KeyLength=pRSAIOparams->OutputKeyInfo.KeyLength;
+    if (copy_from_user( &KeyLoc[MAX_KEY_BYTE_SIZE*RSA_E_OFFSET],pRSAIOparams->ExpE.KeyValue,
+	   ROUNDUP_TO_32_BIT(pRSAIOparams->ExpE.KeyLength)/8))
+      return -EFAULT;
+    pRSASRLparams->ExpE.KeyValue= (void *)(&KeyLoc[MAX_KEY_BYTE_SIZE*RSA_E_OFFSET]);
+    pRSASRLparams->ExpE.KeyLength = pRSAIOparams->ExpE.KeyLength;
+    pRSASRLparams->InputKeyInfo.KeyLength = pRSAIOparams->InputKeyInfo.KeyLength;
+  }
+  else { /* Private. */
+    CHECK_SIZE(pRSAIOparams->PrimeP.KeyLength,MAX_RSA_PRIVATE_KEY_LENGTH_BITS);
+    CHECK_SIZE(pRSAIOparams->PrimeQ.KeyLength,MAX_RSA_PRIVATE_KEY_LENGTH_BITS);
+    CHECK_SIZE(pRSAIOparams->PrimeEdp.KeyLength,MAX_RSA_PRIVATE_KEY_LENGTH_BITS);
+    CHECK_SIZE(pRSAIOparams->PrimeEdq.KeyLength,MAX_RSA_PRIVATE_KEY_LENGTH_BITS);
+    CHECK_SIZE(pRSAIOparams->Pinv.KeyLength,MAX_RSA_PRIVATE_KEY_LENGTH_BITS);
+    if (copy_from_user( &KeyLoc[MAX_KEY_BYTE_SIZE*RSA_P_OFFSET],pRSAIOparams->PrimeP.KeyValue,
+	   ROUNDUP_TO_32_BIT(pRSAIOparams->PrimeP.KeyLength)/8))
+      return -EFAULT;
+    pRSASRLparams->PrimeP.KeyValue= (void *)(&KeyLoc[MAX_KEY_BYTE_SIZE*RSA_P_OFFSET]);
+    pRSASRLparams->PrimeP.KeyLength = pRSAIOparams->PrimeP.KeyLength;
+    if (copy_from_user( &KeyLoc[MAX_KEY_BYTE_SIZE*RSA_Q_OFFSET],pRSAIOparams->PrimeQ.KeyValue,
+	   ROUNDUP_TO_32_BIT(pRSAIOparams->PrimeQ.KeyLength)/8))
+      return -EFAULT;
+    pRSASRLparams->PrimeQ.KeyValue = (void *)(&KeyLoc[MAX_KEY_BYTE_SIZE*RSA_Q_OFFSET]);
+    pRSASRLparams->PrimeQ.KeyLength = pRSAIOparams->PrimeQ.KeyLength;
+    if (copy_from_user( &KeyLoc[MAX_KEY_BYTE_SIZE*RSA_EDP_OFFSET],pRSAIOparams->PrimeEdp.KeyValue,
+	   ROUNDUP_TO_32_BIT(pRSAIOparams->PrimeEdp.KeyLength)/8))
+      return -EFAULT;
+    pRSASRLparams->PrimeEdp.KeyValue=
+      (void *)(&KeyLoc[MAX_KEY_BYTE_SIZE*RSA_EDP_OFFSET]);
+    pRSASRLparams->PrimeEdp.KeyLength = pRSAIOparams->PrimeEdp.KeyLength;
+    if (copy_from_user( &KeyLoc[MAX_KEY_BYTE_SIZE*RSA_EDQ_OFFSET],pRSAIOparams->PrimeEdq.KeyValue,
+	   ROUNDUP_TO_32_BIT(pRSAIOparams->PrimeEdq.KeyLength)/8))
+      return -EFAULT;
+    pRSASRLparams->PrimeEdq.KeyValue=
+      (void *)(&KeyLoc[MAX_KEY_BYTE_SIZE*RSA_EDQ_OFFSET]);
+    pRSASRLparams->PrimeEdq.KeyLength = pRSAIOparams->PrimeEdq.KeyLength;
+    if (copy_from_user( &KeyLoc[MAX_KEY_BYTE_SIZE*RSA_PINV_OFFSET],pRSAIOparams->Pinv.KeyValue,
+	   ROUNDUP_TO_32_BIT(pRSAIOparams->Pinv.KeyLength)/8))
+      return -EFAULT;
+    pRSASRLparams->Pinv.KeyValue= (void *)(&KeyLoc[MAX_KEY_BYTE_SIZE*RSA_PINV_OFFSET]);
+    pRSASRLparams->Pinv.KeyLength = pRSAIOparams->Pinv.KeyLength;
+
+    pRSASRLparams->OutputKeyInfo.KeyLength=pRSAIOparams->OutputKeyInfo.KeyLength;
+    pRSASRLparams->InputKeyInfo.KeyLength=pRSAIOparams->InputKeyInfo.KeyLength;
+  }      
+
+  pRSASRLparams->InputKeyInfo.KeyValue = (void *) 
+    (&KeyLoc[MAX_KEY_BYTE_SIZE*RSA_IN_OFFSET]);
+  return 0;
+}
+
+
+
+
+/*
+ * DSA key setup function. Builds KeyCommandInfo for call to SRL.
+ */
+ int
+ubsec_keysetup_DSA(unsigned long command, 
+		   ubsec_KeyCommandParams_pt pSRLparams, 
+		   ubsec_KeyCommandParams_pt pIOparams,
+		   unsigned char *KeyLoc,                    /* Pointer to already malloc'd DMA memory    */
+		   ubsec_FragmentInfo_pt pMessageFragList)   /* Pointer to already malloc'd fragment list */
+{
+  ubsec_DSA_Params_pt 	pDSASRLparams = &pSRLparams->DSAParams; /* points back to SRL parameter structure being built */
+  ubsec_DSA_Params_pt 	pDSAIOparams = &pIOparams->DSAParams;   /* points back to IOCTL parameter structure passed in */
+  int i; 
+  ubsec_FragmentInfo_t IOInputFragment; /* Local (single IOCTL input) fragment for DSA */
+
+  /* Copy single IOCTL fragment info into local copy */
+  if (copy_from_user( &IOInputFragment,pDSAIOparams->InputFragments,sizeof(IOInputFragment)))
+    return -EFAULT;
+  pDSAIOparams->InputFragments = &IOInputFragment;   /* points to local (single) fragment descriptor    */
+  pDSASRLparams->InputFragments = pMessageFragList;      /* points back to calling fragment list */
+
+  /*
+   * Message in, signature in/out, key parameters used for both sign and verify.
+   */
+  pDSASRLparams->HashEnable = pDSAIOparams->HashEnable;
+
+  if (copy_from_user( &KeyLoc[MAX_KEY_BYTE_SIZE*DSA_IN_OFFSET],(void *)pDSAIOparams->InputFragments->FragmentAddress,
+		  pDSAIOparams->InputFragments->FragmentLength))
+    return -EFAULT;
+  
+  /* Sync the input message DMA memory so that the CryptoNetX device can access it.  */
+  /***********************************************************************************/
+  /***************************  PLATFORM PORTABILITY ISSUE  **************************/
+  /***********************************************************************************/
+  /* Strictly speaking, KeyLoc is not the right parameter for the sync macro.        */
+  /* It is not an OS_MemHandle_t value returned from a malloc call; it was derived   */
+  /* from an OS_MemHandle_t value using pointer math in the virtual address domain.  */
+  /* However, OS_MemHandle_t types for Linux-on-a-PC are virtual pointers anyway,    */
+  /* so KeyLoc is an acceptable parameter in this case.                              */ 
+  /***********************************************************************************/
+  /***************************  PLATFORM PORTABILITY ISSUE  **************************/
+  /***********************************************************************************/
+  OS_SyncToDevice(KeyLoc, MAX_KEY_BYTE_SIZE*DSA_IN_OFFSET, 
+		  pDSAIOparams->InputFragments->FragmentLength); /* (MemHandle, offset, bytes) */
+
+  /* The DSA message or message hash is a bytestream. Treat it just like a fragmentable crypto buffer. */
+  if ((pDSASRLparams->NumInputFragments = SetupFragmentList(pDSASRLparams->InputFragments,
+							    &KeyLoc[MAX_KEY_BYTE_SIZE*DSA_IN_OFFSET],
+							    pDSAIOparams->InputFragments->FragmentLength)) == 0) {
+    /* Input message for DSA requires too many fragments; return error code */
+    return UBSEC_STATUS_NO_RESOURCE;
+  }
+  for (i=0;i<(pDSASRLparams->NumInputFragments-1);i++) {
+    if ((pDSASRLparams->InputFragments[i].FragmentLength)%64)
+      /* Input message fragmentation for DSA violates CryptoNet requirements for fragment sizes */
+      return UBSEC_STATUS_NO_RESOURCE;
+  }
+  
+  /* If the message has already been hashed, the input hash must be 20 bytes and in a single fragment */
+  if ( (!pDSAIOparams->HashEnable) && \
+       ((pDSAIOparams->InputFragments->FragmentLength != 20) || (pDSASRLparams->NumInputFragments != 1)) )
+    return UBSEC_STATUS_NO_RESOURCE; 
+  
+  CHECK_SIZE(pDSAIOparams->ModQ.KeyLength,MAX_DSA_MODQ_LENGTH_BITS);
+  CHECK_SIZE(pDSAIOparams->ModP.KeyLength,MAX_DSA_KEY_LENGTH_BITS);
+  CHECK_SIZE(pDSAIOparams->BaseG.KeyLength,MAX_DSA_KEY_LENGTH_BITS);
+  CHECK_SIZE(pDSAIOparams->Key.KeyLength,MAX_DSA_KEY_LENGTH_BITS);
+
+  if (copy_from_user( &KeyLoc[MAX_KEY_BYTE_SIZE*DSA_Q_OFFSET],pDSAIOparams->ModQ.KeyValue,
+	 ROUNDUP_TO_32_BIT(pDSAIOparams->ModQ.KeyLength)/8))
+    return -EFAULT;
+  pDSASRLparams->ModQ.KeyValue = (void *)(&KeyLoc[MAX_KEY_BYTE_SIZE*DSA_Q_OFFSET]);
+  pDSASRLparams->ModQ.KeyLength = pDSAIOparams->ModQ.KeyLength;
+
+  if (copy_from_user( &KeyLoc[MAX_KEY_BYTE_SIZE*DSA_P_OFFSET],pDSAIOparams->ModP.KeyValue,
+	 ROUNDUP_TO_32_BIT(pDSAIOparams->ModP.KeyLength)/8))
+    return -EFAULT;
+  pDSASRLparams->ModP.KeyValue = (void *)(&KeyLoc[MAX_KEY_BYTE_SIZE*DSA_P_OFFSET]);
+  pDSASRLparams->ModP.KeyLength = pDSAIOparams->ModP.KeyLength;
+  if (copy_from_user( &KeyLoc[MAX_KEY_BYTE_SIZE*DSA_G_OFFSET],pDSAIOparams->BaseG.KeyValue,
+	 ROUNDUP_TO_32_BIT(pDSAIOparams->BaseG.KeyLength)/8))
+    return -EFAULT;
+  pDSASRLparams->BaseG.KeyValue = (void *)(&KeyLoc[MAX_KEY_BYTE_SIZE*DSA_G_OFFSET]);
+  pDSASRLparams->BaseG.KeyLength = pDSAIOparams->BaseG.KeyLength;
+
+  if (copy_from_user( &KeyLoc[MAX_KEY_BYTE_SIZE*DSA_KEY_OFFSET],pDSAIOparams->Key.KeyValue,
+	 ROUNDUP_TO_32_BIT(pDSAIOparams->Key.KeyLength)/8))
+    return -EFAULT;
+  pDSASRLparams->Key.KeyValue = (void *)(&KeyLoc[MAX_KEY_BYTE_SIZE*DSA_KEY_OFFSET]);
+  pDSASRLparams->Key.KeyLength = pDSAIOparams->Key.KeyLength;
+
+  /*
+   * R and S are always input/output fragment data, physical addresses.
+   */
+  pDSASRLparams->SigS.KeyValue=(void *) (&KeyLoc[MAX_KEY_BYTE_SIZE*DSA_S_OFFSET]);
+  pDSASRLparams->SigR.KeyValue=(void *) (&KeyLoc[MAX_KEY_BYTE_SIZE*DSA_R_OFFSET]);
+
+  if ((command & UBSEC_DSA_SIGN) == UBSEC_DSA_SIGN) {
+    /*
+     * Output will be in R and S, fragment data.
+     */
+    pDSASRLparams->RNGEnable=pDSAIOparams->RNGEnable;
+    if (!pDSASRLparams->RNGEnable) {
+      CHECK_SIZE(pDSAIOparams->Random.KeyLength,MAX_DSA_KEY_LENGTH_BITS);
+      if (copy_from_user(&KeyLoc[MAX_KEY_BYTE_SIZE*DSA_RAND_OFFSET],pDSAIOparams->Random.KeyValue,
+	     ROUNDUP_TO_32_BIT(pDSAIOparams->Random.KeyLength)/8))
+        return -EFAULT;
+      pDSASRLparams->Random.KeyValue = (void *)
+	(&KeyLoc[MAX_KEY_BYTE_SIZE*DSA_RAND_OFFSET]);
+      pDSASRLparams->Random.KeyLength = pDSAIOparams->Random.KeyLength;
+    }
+    pDSASRLparams->SigS.KeyLength = 160; 
+    pDSASRLparams->SigR.KeyLength = 160;     
+    /*
+     * Set Return lengths
+     */
+    pDSAIOparams->SigS.KeyLength = pDSAIOparams->ModQ.KeyLength;
+    pDSAIOparams->SigR.KeyLength = pDSAIOparams->ModQ.KeyLength;
+  } else {
+    /*
+     * Verify.
+     *
+     * Input will be in R and S, fragment data.
+     */
+    CHECK_SIZE(pDSAIOparams->SigS.KeyLength,MAX_DSA_SIG_LENGTH_BITS);
+    CHECK_SIZE(pDSAIOparams->SigR.KeyLength,MAX_DSA_SIG_LENGTH_BITS);
+    if (copy_from_user( &KeyLoc[MAX_KEY_BYTE_SIZE*DSA_S_OFFSET],pDSAIOparams->SigS.KeyValue,
+	   ROUNDUP_TO_32_BIT(pDSAIOparams->SigS.KeyLength)/8))
+      return -EFAULT;
+    pDSASRLparams->SigS.KeyLength = pDSAIOparams->SigS.KeyLength;
+    if (copy_from_user( &KeyLoc[MAX_KEY_BYTE_SIZE*DSA_R_OFFSET],pDSAIOparams->SigR.KeyValue,
+	   ROUNDUP_TO_32_BIT(pDSAIOparams->SigR.KeyLength)/8))
+    return -EFAULT;
+    pDSASRLparams->SigR.KeyLength = pDSAIOparams->SigR.KeyLength;
+
+    /*
+     * Output verification value is also fragmented data, must be
+     * integral number of 32-bit words.
+     */
+    pDSASRLparams->V.KeyValue=(void *)(&KeyLoc[MAX_KEY_BYTE_SIZE*DSA_V_OFFSET]);
+    pDSASRLparams->V.KeyLength = 160; 
+    /*
+     * Set value for return.
+     */
+    pDSAIOparams->V.KeyLength = 160; /*pDSAIOparams->ModQ.KeyLength;*/
+  }
+	
+  return 0;
+}
+
+
+
diff -urNp linux-8030/drivers/addon/bcm/pkey.c linux-8040/drivers/addon/bcm/pkey.c
--- linux-8030/drivers/addon/bcm/pkey.c
+++ linux-8040/drivers/addon/bcm/pkey.c
@@ -0,0 +1,238 @@
+
+/*
+ *  Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ *  of any kind, either express or implied as further specified in the GNU Public
+ *  License. This software may be used and distributed according to the terms of
+ *  the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+/*
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+/*
+ * pkey.c: Character driver interface to public key routines.
+ */
+/*
+ * Revision History:
+ *
+ * May 2000 SOR/JTT Created.
+ * March 2001 PW Release for Linux 2.4 UP and SMP kernel
+ */
+
+#include "cdevincl.h"	
+
+#ifdef POLL
+#undef GOTOSLEEP
+#endif
+
+#define MAX_KMALLOC_SIZE	0x20000
+
+/**************************************************************************
+ *
+ *  Function:  init_pkeyif
+ *   
+ *************************************************************************/
+int init_keyif(void)
+{
+ return 0; /* success */
+}
+
+/**************************************************************************
+ *
+ *  Function:  cleanup_module
+ *
+ *************************************************************************/
+void shutdown_keyif(void)
+{
+  return;
+}
+
+/*
+ * ubsec_keysetup:
+ */
+int ubsec_keysetup(ubsec_DeviceContext_t pContext, ubsec_key_io_t *pKeyIOInfo)
+{
+  ubsec_KeyCommandInfo_pt	kcmd=NULL;
+  unsigned char			*KeyLoc=NULL;
+  unsigned int			num_commands=1;
+  int				error = 0;
+  ubsec_key_io_pt		KeyIOInfo=NULL;
+  CommandContext_pt		pCommandContext=NULL;
+  unsigned char			*pkey_buf = NULL;
+  ubsec_key_io_t                KeyIOInfoForDSA;
+  ubsec_FragmentInfo_t		InputFragments; 
+  int                           dsa_buf_bytes = 4096;
+  int i;
+  int timeout;
+  int message_alignment;  
+
+  /* This DSA message aligner ensures that the DSA message will begin on a 64-byte boundary,     */
+  /* which guarantees that (non-last) message fragments will have sizes that are integer         */
+  /* multiples of 64 (a chip requirement for DSA messages)                                       */
+
+#define DSA_MESSAGE_ALIGNMENT ((64-((sizeof(*pCommandContext)+sizeof(*kcmd)+\
+sizeof(*KeyIOInfo)+(MAX_KEY_BYTE_SIZE*DSA_IN_OFFSET))%64))&63)
+
+#ifndef GOTOSLEEP
+  unsigned long			delay_total_us;
+#endif
+  ubsec_FragmentInfo_t DSAMessageFragList[MAX_FRAGMENTS]; 
+
+  memset(DSAMessageFragList,0,sizeof(DSAMessageFragList)); 
+
+  if(copy_from_user(&KeyIOInfoForDSA, pKeyIOInfo, sizeof(KeyIOInfoForDSA)))
+    return -EFAULT;
+
+  if(copy_from_user(&InputFragments,
+                    KeyIOInfoForDSA.key.DSAParams.InputFragments,
+                    sizeof(InputFragments)))
+    return -EFAULT;
+
+  if((KeyIOInfoForDSA.command == UBSEC_DSA_SIGN) || (KeyIOInfoForDSA.command == UBSEC_DSA_VERIFY)) {
+    message_alignment = DSA_MESSAGE_ALIGNMENT;
+    dsa_buf_bytes += InputFragments.FragmentLength + DSA_MESSAGE_ALIGNMENT;
+  } else {
+    message_alignment = 0;
+  }
+
+  if ((dsa_buf_bytes < 0) || (dsa_buf_bytes > MAX_KMALLOC_SIZE))
+    return -EINVAL;
+
+  /* Allocate temporary buffer for key structure */
+  pkey_buf = (unsigned char *) kmalloc((dsa_buf_bytes),GFP_KERNEL|GFP_ATOMIC);
+  if(pkey_buf == NULL) {
+    PRINTK("no memory for key buffer\n");
+    return -ENOMEM;
+  }
+  memset(pkey_buf,0, dsa_buf_bytes);
+
+  pCommandContext = (CommandContext_pt)pkey_buf;
+  kcmd = (ubsec_KeyCommandInfo_pt) &pCommandContext[1];
+  KeyIOInfo = (ubsec_key_io_pt)&kcmd[1];
+  KeyLoc = ((unsigned char *)&KeyIOInfo[1]) + message_alignment;
+  
+  memcpy(KeyIOInfo, &KeyIOInfoForDSA, sizeof(*KeyIOInfo));
+
+  /* DSA needs extra indirection setup */
+
+  if ((error = KeyCommandCopyin((kcmd->Command = KeyIOInfo->command),
+				&kcmd->Parameters, &KeyIOInfo->key, KeyLoc,&DSAMessageFragList[0])) < 0) {
+    PRINTK("KeyCommandCopyin failed.\n");
+    KeyIOInfo->result_status = UBSEC_STATUS_INVALID_PARAMETER;
+    goto Return;
+  }
+
+  /* Set up callback function. */
+  kcmd->CompletionCallback = CmdCompleteCallback;
+  kcmd->CommandContext=(unsigned long)pkey_buf;
+
+  /* Remember calling process. */
+  pCommandContext->pid = current->pid;
+
+  /* Initialize start timer. */
+  do_gettimeofday(&pCommandContext->tv_start);
+  pCommandContext->CallBackStatus = 0;
+
+#ifndef LINUX2dot2
+  init_waitqueue_head(&pCommandContext->WaitQ);
+#else
+   pCommandContext->WaitQ         = 0; 
+#endif
+
+  switch ((KeyIOInfo->result_status = ubsec_KeyCommand(pContext, kcmd, &num_commands))) {
+  case UBSEC_STATUS_SUCCESS:
+    break;
+  case UBSEC_STATUS_TIMEOUT:
+    PRINTK("ubsec_Command() Timeout\n");
+    error = -ETIMEDOUT;
+    goto Return;
+    break;
+  case UBSEC_STATUS_INVALID_PARAMETER:
+    PRINTK("ubsec_Command:  Invalid parameter\n");
+    error = -EINVAL;
+    goto Return;
+    break;
+  case UBSEC_STATUS_NO_RESOURCE:
+    PRINTK("ubsec_Command() No key resource. Num Done %d Context %lx\n",
+	num_commands, (long unsigned int)pContext);
+    error = -ENOBUFS;
+    goto Return;
+    break;
+  case UBSEC_STATUS_DEVICE_FAILED:
+    PRINTK("ubsec_Command:  Device Failed.\n");
+    error = -EIO;
+    goto Return;
+    break;
+  default:
+    PRINTK("ubsec_Command:  Error=%x.\n", KeyIOInfo->result_status);
+    error = -EIO;
+    goto Return;
+    break;
+  }
+
+#ifndef GOTOSLEEP      /* We need to poll the device if we are operating in POLL mode. */
+  for (delay_total_us=1  ; !pCommandContext->CallBackStatus ; delay_total_us++) {
+#ifdef POLL
+    ubsec_PollDevice(pContext);
+#endif /* POLL */
+    if (delay_total_us >= 30000000) {
+      PRINTK("pkey timeout in poll wait.\n");
+      pCommandContext->Status=UBSEC_STATUS_TIMEOUT;
+      break;
+    }
+    udelay(1);
+  }
+#else  /* GOTOSLEEP */
+  if (!pCommandContext->CallBackStatus) { /* Just in case completed on same thread. */
+    timeout = Gotosleep(&pCommandContext->WaitQ);
+    if (!pCommandContext->CallBackStatus) {
+	      PRINTK("Device timeout\n");
+              pCommandContext->Status=UBSEC_STATUS_TIMEOUT;
+    }
+  }
+#endif /* GOTOSLEEP */
+
+  /* Timing information for caller */
+  KeyIOInfo->time_us = pCommandContext->tv_start.tv_sec * 1000000 + 
+	pCommandContext->tv_start.tv_usec;
+
+  switch ((KeyIOInfo->result_status = pCommandContext->Status)) {
+  case UBSEC_STATUS_SUCCESS:
+	KeyCommandCopyout(KeyIOInfo->command, &kcmd->Parameters,
+		&KeyIOInfo->key, KeyLoc);
+	break;
+  case UBSEC_STATUS_TIMEOUT:
+	error = -ETIMEDOUT;
+	ubsec_ResetDevice(pContext);
+	break;
+  case UBSEC_STATUS_INVALID_PARAMETER:
+	PRINTK("pkey FAILURE: UBSEC_STATUS_INVALID_PARAMETER\n");
+    	error = -EINVAL;
+	break;
+  default:
+	PRINTK("pkey FAILURE: %x\n", KeyIOInfo->result_status);
+	error = -ENOMSG;
+  }
+
+Return:
+
+  /*
+   * Copy back the result block.
+   */
+  if (copy_to_user(pKeyIOInfo, KeyIOInfo, sizeof(*KeyIOInfo)) && !error)
+    error = -EFAULT;
+
+  if (pkey_buf) kfree(pkey_buf);
+
+  return error;
+}
+
diff -urNp linux-8030/drivers/addon/bcm/prototypes.h linux-8040/drivers/addon/bcm/prototypes.h
--- linux-8030/drivers/addon/bcm/prototypes.h
+++ linux-8040/drivers/addon/bcm/prototypes.h
@@ -0,0 +1,21 @@
+#include "cdevincl.h"
+
+int
+ ubsec_tlsmac (ubsec_DeviceContext_t pContext, ubsec_tlsmac_io_pt * ppIOInfo);
+int
+ ubsec_sslmac (ubsec_DeviceContext_t pContext, ubsec_sslmac_io_pt * ppIOInfo);
+int
+ ubsec_hash (ubsec_DeviceContext_t pContext, ubsec_hash_io_pt * ppIOInfo);
+int
+ ubsec_sslcipher (ubsec_DeviceContext_t pContext, ubsec_sslcipher_io_pt * ppIOInfo);
+int
+ ubsec_sslarc4 (ubsec_DeviceContext_t pContext, ubsec_arc4_io_pt * ppIOInfo);
+int ubsec_chipinfo (ubsec_DeviceContext_t pContext, ubsec_chipinfo_io_pt * ppIOInfo);
+int DumpDeviceInfo (PInt pm);
+int FailDevices (PInt pm);
+int TestDevice (int SelectedDevice);
+int TestDevices (PInt pm);
+int GetHardwareVersion (PInt pm);
+int init_arc4if (void);
+void shutdown_arc4if (void);
+int SetupFragmentList (ubsec_FragmentInfo_pt Frags, unsigned char *packet, int packet_len);
diff -urNp linux-8030/drivers/addon/bcm/rng.c linux-8040/drivers/addon/bcm/rng.c
--- linux-8030/drivers/addon/bcm/rng.c
+++ linux-8040/drivers/addon/bcm/rng.c
@@ -0,0 +1,260 @@
+
+/*
+ *  Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ *  of any kind, either express or implied as further specified in the GNU Public
+ *  License. This software may be used and distributed according to the terms of
+ *  the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+/******************************************************************************
+ *
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+/*
+ * rng.c: Character driver interface to RNG routines in the ubsec driver
+ *
+ * SOR
+ * JJT
+ * March 2001 PW Release for Linux 2.4 UP and SMP kernel
+ */
+
+#include "cdevincl.h"
+#define NORMALIZE 0
+/*#define PRG_BUFFER_SIZE 4096*/
+
+#ifdef POLL
+#undef GOTOSLEEP
+#endif
+
+/* Maximum key size in bytes */
+#define MAX_RNG_BYTE_SIZE  (ROUNDUP_TO_32_BIT(MAX_RNG_LENGTH_BITS)/8)
+
+/* Intermediate key copy location offsets */
+
+/* Offset of Key information within kernel buffer. */
+#define RNG_RESULT_OFFSET 	0
+
+#define MAX_NUM_RNG_PARAMS 1
+
+static int ubsec_rngsetup(unsigned long command, 
+	ubsec_RNGCommandParams_pt pIOparams, ubsec_RNGCommandParams_pt pSRLparams, 	
+	unsigned char *RngLoc);
+
+/**************************************************************************
+ *
+ *  Function:  init_pkeyif
+ *   
+ *************************************************************************/
+int init_rngif(void)
+{
+ return 0; /* success */
+}
+
+
+
+/**************************************************************************
+ *
+ *  Function:  cleanup_module
+ *
+ *************************************************************************/
+void shutdown_rngif(void)
+{
+ return;
+}
+
+/*
+ * Rng function  setup function. Builds RngCommandInfo for call to SRL.
+ * Returns number of bits to normalize.
+ */
+static int ubsec_rngsetup(unsigned long command, 
+	ubsec_RNGCommandParams_pt pIOparams, ubsec_RNGCommandParams_pt pSRLparams, 	
+	unsigned char *RngLoc)
+{
+  int			NormBits = 0;
+
+
+  /*
+   * Do a brute force copy of the rng command. This will set the
+   * lengths etc but we still need to set the pointers.
+   */
+  *pSRLparams=*pIOparams;
+
+  pSRLparams->Result.KeyValue=(void *)&RngLoc[0];
+
+  /* Validation of the Length */
+  CHECK_SIZE(  pSRLparams->Result.KeyLength, MAX_RNG_LENGTH_BITS);
+
+  return NormBits;
+}
+
+/*
+ *
+ */
+int
+ubsec_rng(ubsec_DeviceContext_t *ubsecContext, ubsec_rng_io_t *pIOInfo)
+{
+  ubsec_RNGCommandInfo_pt	kcmd;
+  ubsec_RNGCommandParams_pt	pRngparams=NULL, 
+				pIOparams = NULL;
+  unsigned long			delay_total_us;
+  unsigned char			*RngLoc;
+  unsigned int			num_commands=1;
+  ubsec_rng_io_t		RngCommand;
+  ubsec_rng_io_pt		pRngIOInfo=&RngCommand;
+  int				error = 0;
+  CommandContext_pt		pCommandContext;
+  unsigned char 		*prng_buf = NULL;
+/*
+  int i;
+*/
+
+
+  prng_buf = (char *) kmalloc((MAX_RNG_BYTE_SIZE ),GFP_KERNEL|GFP_ATOMIC);
+  if( prng_buf == NULL ) {
+    PRINTK("no memory for rng buffer\n");
+    return -ENOMEM;
+  }
+
+  memset(prng_buf,0,MAX_RNG_BYTE_SIZE);
+
+  pCommandContext = (CommandContext_pt)prng_buf;
+  kcmd = (ubsec_RNGCommandInfo_pt)&pCommandContext[1];
+  RngLoc=(unsigned char *)&kcmd[1];
+  pRngparams=&(kcmd->Parameters);
+
+		
+		
+
+  if (copy_from_user( pRngIOInfo, pIOInfo, sizeof(*pRngIOInfo)))
+    return -EFAULT;
+  pIOparams=&pRngIOInfo->Rng;
+
+#ifndef LINUX2dot2
+  init_waitqueue_head(&pCommandContext->WaitQ);
+#else
+   pCommandContext->WaitQ         = 0; 
+#endif 
+	/*
+	 * Now we need to format the command for the SRL.
+	 * This depends on the type of the key command.
+	 */
+  switch ((kcmd->Command=pRngIOInfo->command)) {
+  case UBSEC_RNG_DIRECT:
+  case UBSEC_RNG_SHA1:
+    if (ubsec_rngsetup(pRngIOInfo->command,&pRngIOInfo->Rng, pRngparams, RngLoc) < 0){
+	error = -EINVAL;
+	goto Free_Return;
+	}
+    break;
+  default:
+    PRINTK("Invalid Rng Command %lx\n",kcmd->Command);
+    error = -EINVAL;
+	goto Free_Return;
+  }
+
+
+  kcmd->CompletionCallback = CmdCompleteCallback;
+  kcmd->CommandContext=(unsigned long)prng_buf;
+
+	/*
+	 *  Let the system do anything it may want/need to do before we begin
+	 *  timing.
+	 */
+  do_gettimeofday(&pCommandContext->tv_start);
+  
+  pCommandContext->CallBackStatus=0; /* inc'd on callback */
+  switch ((pRngIOInfo->result_status=ubsec_RNGCommand(ubsecContext, kcmd,
+	&num_commands))) {
+  case UBSEC_STATUS_SUCCESS:
+    break;
+  case UBSEC_STATUS_TIMEOUT:
+    PRINTK("ubsec_Command() Timeout\n");
+    error = -ETIMEDOUT;
+    goto Return;
+    break;
+  case UBSEC_STATUS_INVALID_PARAMETER:
+    PRINTK("ubsec_Command() Invalid parameter\n");
+    error = -EINVAL;
+    goto Return;
+    break;
+  case UBSEC_STATUS_NO_RESOURCE:
+    PRINTK("ubsec_Command() No rng resource. Num Done %d\n",num_commands);
+    error = -ENOBUFS;
+    goto Return;
+    break;
+  default:
+    error = -EIO;
+    goto Return;
+    break;
+  }
+
+#ifndef GOTOSLEEP
+  for (delay_total_us=1 ; !(pCommandContext->CallBackStatus); delay_total_us++) {
+    ubsec_PollDevice(ubsecContext);
+    if (delay_total_us >= 3000000) {
+      pCommandContext->Status=-ETIMEDOUT;
+      error = -ETIMEDOUT;
+      ubsec_ResetDevice(ubsecContext);
+      goto Return;
+    }
+    udelay(1);
+  }
+#else
+  if (!pCommandContext->CallBackStatus) { /* Just in case completed on same thread. */
+     Gotosleep(&pCommandContext->WaitQ);
+     if (!pCommandContext->CallBackStatus) { /* timed out, never got the interrupt */
+       ubsec_PollDevice(ubsecContext);       /* Manually poll just in case */
+       if (!pCommandContext->CallBackStatus) { 
+	 /* The command truly timed out, return error status */
+	 pCommandContext->Status=UBSEC_STATUS_TIMEOUT;
+	 error = -ETIMEDOUT;
+	 ubsec_ResetDevice(ubsecContext);
+	 goto Return;
+       }
+     }
+  }
+#endif
+
+  pRngIOInfo->result_status = pCommandContext->Status;
+  pRngIOInfo->time_us = pCommandContext->tv_start.tv_sec * 1000000 + 
+	pCommandContext->tv_start.tv_usec;
+
+  /*
+   * Status gets set above to timeout or in callback to success indicator.
+   */
+  if (pRngIOInfo->result_status == UBSEC_STATUS_SUCCESS) {
+  	/* 
+  	 * Now we need to copy out those parameters that were changed
+  	 */
+    pIOparams->Result.KeyLength = pRngparams->Result.KeyLength;
+    if (copy_to_user(pIOparams->Result.KeyValue, RngLoc, 
+	ROUNDUP_TO_32_BIT(pIOparams->Result.KeyLength)/8)) {
+      error = -EFAULT;
+      goto Free_Return;
+    }
+
+
+  } else {
+#if 1
+		PRINTK("rng FAILURE %lx\n", (unsigned long)pCommandContext->Status);
+#endif
+		error = -ENOMSG;
+	}
+
+ Return:
+	/*
+	 * Copyback the result
+	 */
+	if (copy_to_user(pIOInfo, pRngIOInfo, sizeof(*pRngIOInfo)) && !error)
+		error = -EFAULT;
+Free_Return:
+  	if (prng_buf != NULL)
+		kfree(prng_buf);
+	return error;
+}
diff -urNp linux-8030/drivers/addon/bcm/selftest.c linux-8040/drivers/addon/bcm/selftest.c
--- linux-8030/drivers/addon/bcm/selftest.c
+++ linux-8040/drivers/addon/bcm/selftest.c
@@ -0,0 +1,127 @@
+
+/*
+ *  Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ *  of any kind, either express or implied as further specified in the GNU Public
+ *  License. This software may be used and distributed according to the terms of
+ *  the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+/******************************************************************************
+ *
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+/*
+ * selftest.c: Character driver interface to selftest routines in the ubsec driver
+ *
+ * SOR
+ * JJT
+ * RJT
+ */
+
+#include "cdevincl.h"
+
+static void CryptoCallback(unsigned long CommandContext,long Result);
+static void KeyCallback(unsigned long CommandContext,long Result);
+
+static long Status;
+static int CallbackStatus=0;
+
+/*
+ *
+ */
+int
+Selftest(ubsec_DeviceContext_t pContext,struct pci_dev* pDev)
+{
+  unsigned long			delay_total_us;
+
+  CallbackStatus=0; /* inc'd on callback */
+
+  Status=ubsec_TestCryptoDevice(pContext,CryptoCallback,(unsigned long)pDev);
+  if (Status != UBSEC_STATUS_SUCCESS) {
+    printk("Selftest Device failed %lx\n",Status);
+    /* RJT call ubsec_PollDevice() here? Chip seems lost after failing */
+    goto Return;
+  }
+
+  for (delay_total_us=1  ; !CallbackStatus ; delay_total_us++) {
+#ifdef POLL /* We need to poll the device if we are operating in POLL mode. */
+    ubsec_PollDevice(pContext);
+#endif
+    if (delay_total_us >= 3000000) {
+      Status=UBSEC_STATUS_TIMEOUT;
+      break;
+    }
+    udelay(1);
+  }
+
+  if (Status != UBSEC_STATUS_SUCCESS)
+     goto Return;
+
+  if(UBSEC_IS_CRYPTO_DEVICEID(pDev->device)) {
+    goto Return;
+  }
+
+  CallbackStatus=0; /* inc'd on callback */
+
+  Status=ubsec_TestKeyDevice(pContext,KeyCallback,(unsigned long)pDev);
+  if (Status != UBSEC_STATUS_SUCCESS) {
+    printk("Key Selftest Device failed %lx\n",Status);
+    /* RJT call ubsec_PollDevice() here? Chip seems lost after failing */
+    goto Return;
+  }
+
+  for (delay_total_us=1  ; !CallbackStatus ; delay_total_us++) {
+#ifdef POLL /* We need to poll the device if we are operating in POLL mode. */
+    ubsec_PollDevice(pContext);
+#endif
+    if (delay_total_us >= 3000000) {
+      Status=UBSEC_STATUS_TIMEOUT;
+      break;
+    }
+    udelay(1);
+  }
+
+ Return:
+        ubsec_ResetDevice(pContext);
+	return(Status);
+}
+
+
+static void CryptoCallback(unsigned long CommandContext,long Result)
+{
+  struct pci_dev *pDev=(struct pci_dev *) CommandContext; /* This is our handle to the pci device */
+  if (Status != UBSEC_STATUS_SUCCESS)
+     return;
+  if (Result!=UBSEC_STATUS_SUCCESS) 
+    printk("Device crypto selftest <%i-%i,%x> failed (%d)\n",
+	   pDev->bus->number, PCI_SLOT(pDev->devfn),pDev->device,(unsigned int)Result);
+  
+
+  CallbackStatus++;
+  Status=Result;
+}
+
+static void KeyCallback(unsigned long CommandContext,long Result)
+{
+  struct pci_dev *pDev=(struct pci_dev *) CommandContext; /* This is our handle to the pci device */
+  if (Status != UBSEC_STATUS_SUCCESS)
+     return;
+  if (Result!=UBSEC_STATUS_SUCCESS) 
+    printk("Device key selftest <%i-%i,%x> failed (%d)\n",
+	   pDev->bus->number, PCI_SLOT(pDev->devfn),pDev->device,(unsigned int)Result);
+  
+
+  CallbackStatus++;
+  Status=Result;
+}
+
+
+
+
+
diff -urNp linux-8030/drivers/addon/bcm/snmp.c linux-8040/drivers/addon/bcm/snmp.c
--- linux-8030/drivers/addon/bcm/snmp.c
+++ linux-8040/drivers/addon/bcm/snmp.c
@@ -0,0 +1,128 @@
+
+/*
+ *  Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ *  of any kind, either express or implied as further specified in the GNU Public
+ *  License. This software may be used and distributed according to the terms of
+ *  the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+/*
+ *  snmp.c module for providing statistics thru snmp agent. 
+ */
+/* Revision History:
+ *
+ * May   2001 SRM Created
+ */
+#include "cdevincl.h"
+
+extern DeviceInfo_t DeviceInfoList[MAX_SUPPORTED_DEVICES];
+
+#ifdef UBSEC_SNMP_2_4
+int stats5820_get_info(char *, char **, off_t, int);
+#endif
+
+#ifdef UBSEC_SNMP_2_2 
+
+#define PROC_NET_BCM5820 PROC_NET_LAST + 32 
+typedef int (get_info_t) (char *, char **, mode_t, int, int);
+
+int stats5820_get_info(char *, char **, off_t, int, int);
+static struct proc_dir_entry proc_net_bcm5820 = {
+	PROC_NET_BCM5820, 7, "bcm5820",
+	S_IFREG | S_IRUGO, 1, 0, 0,
+	0, &proc_net_inode_operations,
+	stats5820_get_info
+};
+int proc_net_create(const char *name, mode_t mode, get_info_t *get_info);
+int proc_net_remove(const char*name);
+
+int proc_net_create(const char *name, mode_t mode, get_info_t *get_info)
+{
+	return proc_net_register(&proc_net_bcm5820);
+}
+
+int proc_net_remove(const char *name)
+{
+	return proc_net_unregister(PROC_NET_BCM5820);
+}
+#endif
+
+void init_snmp_stats_support()
+{
+	proc_net_create("bcm5820", 0, (get_info_t *) stats5820_get_info);
+}
+
+void shutdown_snmp_stats_support()
+{
+	proc_net_remove("bcm5820");
+}
+
+#ifdef UBSEC_SNMP_2_2
+int stats5820_get_info(char *buf, char **start, off_t offset, int length, int dummy)
+#else
+int stats5820_get_info(char *buf, char **start, off_t offset, int length)
+#endif
+{
+	int size, i;
+	int len = 0;
+	ubsec_Statistics_t stats;
+	
+	for (i = 0; i < NumDevices; i++)
+	{
+		size = sprintf(buf+len, "Cryptonet %d: ", i+1);
+		len += size;
+		if (DeviceInfoList[i].Context == NULL)
+			continue;
+		if (ubsec_GetStatistics(DeviceInfoList[i].Context, &stats) == UBSEC_STATUS_SUCCESS)
+		{
+			size = sprintf(buf+len,"%d %d %d %d %d %d %d %d %d %d %d\n",
+				NumDevices,
+				(i+1),
+				stats.IKECount,
+				stats.IKEFailedCount,
+				stats.BytesEncryptedCount,
+				stats.BytesDecryptedCount,
+				stats.BlocksEncryptedCount,
+				stats.BlocksDecryptedCount,
+				stats.CryptoFailedCount,
+				DeviceInfoList[i].DeviceFailuresCount,
+				DeviceInfoList[i].DeviceStatus);
+			len += size;
+			/*
+			size = sprintf(buf+len,"%ld %ld %ld %ld %ld %ld %ld\n",
+				stats.DHPublicCount,
+				stats.DHSharedCount,
+				stats.RSAPublicCount,
+				stats.RSAPrivateCount,
+				stats.DSASignCount,
+				stats.DSAVerifyCount,
+				stats.DMAErrorCount);
+			len += size;
+			*/
+			if (len > length)
+				break;
+		}
+	}
+	if (offset >= len)
+	{
+		*start = buf;
+		return 0;
+	}
+	*start = buf + offset;
+	len -= offset;
+	return (len > length ? length : len);
+}
diff -urNp linux-8030/drivers/addon/bcm/snmp.h linux-8040/drivers/addon/bcm/snmp.h
--- linux-8030/drivers/addon/bcm/snmp.h
+++ linux-8040/drivers/addon/bcm/snmp.h
@@ -0,0 +1,28 @@
+
+/*
+ *  Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ *  of any kind, either express or implied as further specified in the GNU Public
+ *  License. This software may be used and distributed according to the terms of
+ *  the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+/******************************************************************************
+ *
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+/*
+  snmp.h
+*/
+/*
+  *  Revision History
+  *
+  *  created	SRM	06/10/2001
+*/
+void init_snmp_stats_support(void);
+void shutdown_snmp_stats_support(void);
diff -urNp linux-8030/drivers/addon/bcm/sslarc4.c linux-8040/drivers/addon/bcm/sslarc4.c
--- linux-8030/drivers/addon/bcm/sslarc4.c
+++ linux-8040/drivers/addon/bcm/sslarc4.c
@@ -0,0 +1,458 @@
+
+/*
+ *  Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ *  of any kind, either express or implied as further specified in the GNU Public
+ *  License. This software may be used and distributed according to the terms of
+ *  the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+/******************************************************************************
+ *
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/*******************************************************************************
+ *
+ * File: Linux/sslarc4.c
+ * 
+ * Description: 
+ *              Character driver interface to SSL ARC4 routines in the 
+ *              ubsec driver.
+ *
+ * Revision History:
+ *                   When       Who   What
+ *                   10/11/00   DNA   Created
+ * March 2001 PW Release for Linux 2.4 UP and SMP kernel
+ * 10/09/2001 SRM 64 bit port
+ *
+ ******************************************************************************/
+
+#include "cdevincl.h"
+
+#ifdef FILE_DEBUG_TAG
+#undef FILE_DEBUG_TAG
+#endif
+#define FILE_DEBUG_TAG  "BCMSSL"
+
+
+/* This is useful only for diagnostics. */
+#undef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+
+#ifdef POLL
+#undef GOTOSLEEP
+#endif
+
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+
+unsigned char *  pKernSourceBuffer = NULL;
+unsigned char *  pKernDestBuffer   = NULL;
+unsigned char *  pKernStateBuffer  = NULL;
+static ubsec_MemAddress_t       PhysSourceBuf;
+static ubsec_MemAddress_t       PhysDestBuf;
+static ubsec_MemAddress_t       PhysStateBuf;
+
+#endif /* ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+
+
+/**************************************************************************
+ *
+ * Function:  init_arc4if
+ * 
+ * Called from: init_module() in Linux/dispatch.c
+ *
+ * Description: 
+ *              Buffer sent to SRL is not malloc'd here after all, to allow 
+ *              for re-entrant code.
+ *
+ * Return Values:
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+
+int 
+init_arc4if(void) {
+  
+  int error = 0;
+  
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  pKernSourceBuffer = pKernDestBuffer = (char *)kmalloc((MAX_FILE_SIZE),GFP_KERNEL|GFP_ATOMIC);
+  if(pKernSourceBuffer == NULL) {
+    PRINTK("no memory for source buffer %d\n", MAX_FILE_SIZE);
+    error = -ENOMEM;
+    return(error);
+  }
+  memset(pKernSourceBuffer,0, MAX_FILE_SIZE);
+  
+  pKernStateBuffer = (char *)kmalloc((260),GFP_KERNEL|GFP_ATOMIC);
+  if(pKernStateBuffer == NULL) {
+    PRINTK("no memory for source buffer %d\n", 260);
+    error = -ENOMEM;
+    return(error);
+  }
+  memset(pKernStateBuffer,0, 260);
+  
+#ifdef DEBUG
+  PRINTK("Allocate Source: %x %x\n", pKernSourceBuffer, vtophys(pKernSourceBuffer));
+  PRINTK("Allocate State: %x %x\n", pKernStateBuffer, vtophys(pKernStateBuffer));
+#endif
+  
+  PhysSourceBuf = PhysDestBuf = (ubsec_MemAddress_t)(virt_to_bus(pKernSourceBuffer));
+  PhysStateBuf  = (ubsec_MemAddress_t)(virt_to_bus(pKernStateBuffer));
+
+#ifdef DEBUG
+  PRINTK("Memory Alloc Source %x %x Dest %x %x for source buffer\n",
+	 pKernSourceBuffer, PhysSourceBuf, KernDestBuffer, PhysDestBuf);
+  PRINTK("Memory Alloc State %x %x state buffer\n", pKernStateBuffer, PhysStateBuf);
+#endif
+  
+#endif /* ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+  
+  return(error);
+}
+
+
+/**************************************************************************
+ *
+ * Function: shutdown_arc4if
+ *
+ * Called from: cleanup_module() in Linux/dispatch.c
+ *
+ * Description:
+ *
+ *************************************************************************/
+
+void 
+shutdown_arc4if(void) {
+  
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  if(pKernSourceBuffer != NULL)
+    kfree(pKernSourceBuffer);
+  if(pKernStateBuffer != NULL)
+    kfree(pKernStateBuffer);
+  
+#endif /* ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+  
+  return;
+}
+
+/**************************************************************************
+ *
+ * Function:  ubsec_arc4
+ * 
+ * Called from: ubsec_ioctl() in Linux/dispatch.c
+ *
+ * Purpose:
+ *          Wrapper function between user call and call to SRL.
+ *
+ * Description: 
+ *              Prepare all the data from the user's call for a call to 
+ *              the SRL, set up the timer, and finally place this thread
+ *              on the wait queue and go to sleep. When ubsec_arc4 is 
+ *              called, the relevant data for an SSL ARC4 op reside in
+ *              user space. The struct ubecom_arc4_io_pt argument, pIOInfo, 
+ *              points to data on the stack and in kernal space. However, 
+ *              pIOInfo is a struct that contains pointers which still 
+ *              point to memory in user space. ubecom_ssl copies the 
+ *              contents of pIOInfo as well as the input data it points
+ *              to into memory allocated in kernal space with LinuxAllocateMemory.
+ *
+ * Return Values: 
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+
+int
+ubsec_sslarc4(
+	      ubsec_DeviceContext_t pContext,
+	      ubsec_arc4_io_t      *pIOInfo
+	      ) {
+  
+  ubsec_arc4_io_t               IOInfo;
+  ubsec_SSLCommandInfo_t        SslCommand;
+  ubsec_SSLCommandInfo_pt       pSslCommand       = &SslCommand;
+  ubsec_ARC4Params_pt           pArc4Params       = &(pSslCommand->Parameters.ARC4Params);
+  volatile  CommandContext_t  CommandContext;
+  CommandContext_t          *pCommandContext   = (CommandContext_t *)&CommandContext;
+  int                           NumCommands       = 1;
+  unsigned long		        delayTotalUs      = 0;
+  ubsec_FragmentInfo_pt         pSourceFragments  = NULL;
+  unsigned char *               pUserSourceBuffer;
+  unsigned int                  SourceBufferBytes;
+  int                           error             = 0;
+
+#ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  unsigned char *               pKernSourceBuffer = NULL;
+  unsigned char *               pKernDestBuffer   = NULL;
+  unsigned char *               pKernStateBuffer  = NULL;
+  ubsec_MemAddress_t            PhysSourceBuf;
+  ubsec_MemAddress_t            PhysDestBuf;
+  ubsec_MemAddress_t            PhysStateBuf;
+  
+#endif /* ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+
+  if (copy_from_user(&IOInfo, pIOInfo, sizeof(ubsec_arc4_io_t)))
+    return -EFAULT;
+  pUserSourceBuffer = IOInfo.SourceBuffer;
+  SourceBufferBytes = IOInfo.SourceBufferBytes;
+
+  /* 
+   *  First, allocate memory for the source buffer (which doubles as 
+   *  the destination buffer) and the state output buffer. Translate
+   *  both addresses to physical addresses and clear this memory.
+   */
+  
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  if(SourceBufferBytes > MAX_FILE_SIZE) {
+    PRINTK("input file too large <%d,%d>\n", SourceBufferBytes, MAX_FILE_SIZE);
+    error = -EINVAL;
+    return(error);
+  }
+  
+#else
+  
+  pKernSourceBuffer = pKernDestBuffer = (char *)kmalloc((SourceBufferBytes),GFP_KERNEL|GFP_ATOMIC);
+  if(pKernSourceBuffer == NULL) {
+    PRINTK("no memory for source buffer %d\n", SourceBufferBytes);
+    error = -ENOMEM;
+    goto ReturnErrorLabel;
+  }
+  memset(pKernSourceBuffer,0, SourceBufferBytes);
+  
+  pKernStateBuffer = (char *)kmalloc((260),GFP_KERNEL|GFP_ATOMIC);
+  if(pKernStateBuffer == NULL) {
+    PRINTK("no memory for source buffer %d\n", 260);
+    error = -ENOMEM;
+    goto ReturnErrorLabel;
+  }
+  memset(pKernStateBuffer,0, 260);
+  
+#ifdef DEBUG
+  PRINTK("Allocate Source: %x %x\n", pKernSourceBuffer, vtophys(pKernSourceBuffer));
+  PRINTK("Allocate State: %x %x\n", pKernStateBuffer, vtophys(pKernStateBuffer));
+#endif /* ifdef DEBUG */
+  
+  PhysSourceBuf = PhysDestBuf = (ubsec_MemAddress_t)(virt_to_bus(pKernSourceBuffer));
+  PhysStateBuf  = (ubsec_MemAddress_t)(virt_to_bus(pKernStateBuffer));
+
+#ifdef DEBUG
+  PRINTK("Memory Alloc Source %x %x Dest %x %x for source buffer\n",
+	 pKernSourceBuffer, PhysSourceBuf, pKernDestBuffer, PhysDestBuf);
+  PRINTK("Memory Alloc State %x %x state buffer\n", pKernStateBuffer, PhysStateBuf);
+#endif
+  
+#endif /* ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+  
+  /*
+   * Next fill data buffers and data structures with appropriate data
+   * for this ARC4 op.
+   */
+
+  pArc4Params->KeyStateFlag = 0;
+  if( (IOInfo.KeyStateFlag & ARC4_STATE_SUPPRESS_WRITEBACK)  != ARC4_STATE_SUPPRESS_WRITEBACK)
+  	pArc4Params->KeyStateFlag |= UBSEC_ARC4_STATE_WRITEBACK; 
+  if( (IOInfo.KeyStateFlag & ARC4_KEY)  == ARC4_KEY)
+    	pArc4Params->KeyStateFlag |= UBSEC_ARC4_STATE_STATEKEY;  
+  if( (IOInfo.KeyStateFlag & ARC4_NULL_DATA_MODE)  == ARC4_NULL_DATA_MODE)
+    	pArc4Params->KeyStateFlag |= UBSEC_ARC4_STATE_NULL_DATA;
+
+#if DEBUG
+  PRINTK("keystateflag io = %d\n", IOInfo.KeyStateFlag);
+  PRINTK("keystateflag pa = %d\n", pArc4Params->KeyStateFlag);
+#endif
+  
+
+  /* 
+   *  The formats of IOInfo.KeyStateInBuffer, IOInfo.StateOutBuffer and pARC4Params->KeyStateIn are 
+   *  the exact same format as the ARC4 context command structure (with state, index_i and index_j). 
+   *  Note that the internal byte ordering within these structures changes depending on
+   *  the endianess setting of the CryptoNet device. Other than that, these structures
+   *  should be treated simply as 260-byte buffers.
+   */
+
+  pArc4Params->KeyStateIn = (ubsec_ARC4_State_pt)kmalloc(sizeof(ubsec_ARC4_State_t),GFP_KERNEL|GFP_ATOMIC);
+  if(pArc4Params->KeyStateIn == NULL) {
+    PRINTK("no memory for KeyStateIn buffer %d\n", sizeof(ubsec_ARC4_State_t));
+    error = -ENOMEM;
+    goto ReturnErrorLabel;
+  }
+  memset(pArc4Params->KeyStateIn,0, sizeof(ubsec_ARC4_State_t));
+  if (copy_from_user(pArc4Params->KeyStateIn, IOInfo.KeyStateInBuffer, sizeof(ubsec_ARC4_State_t))) {
+    error = -EFAULT;
+    goto ReturnErrorLabel;
+  }
+
+
+  /* Assemble Source Fragments */
+  
+  pSourceFragments = kmalloc((((sizeof(ubsec_FragmentInfo_t) * UBSEC_MAX_FRAGMENTS))),GFP_KERNEL|GFP_ATOMIC);
+  if(pSourceFragments == NULL) {
+    PRINTK("no memory for fragment buffer\n");
+    error = -ENOMEM;
+    return(error);
+  }
+  
+  pSslCommand->SourceFragments = pSourceFragments;
+  if ((pSslCommand->NumSource = SetupFragmentList(pSslCommand->SourceFragments,
+						   pKernSourceBuffer,
+						   SourceBufferBytes)) == 0) {
+    /* The input/output data requires more fragments than the current driver build can provide; return error */
+    error = UBSEC_STATUS_NO_RESOURCE;
+    goto ReturnErrorLabel;
+  }
+  
+  if( (IOInfo.KeyStateFlag & ARC4_NULL_DATA_MODE)  != ARC4_NULL_DATA_MODE)
+  	if (copy_from_user(pKernSourceBuffer, pUserSourceBuffer, SourceBufferBytes)) {
+          error = -EFAULT;
+          goto ReturnErrorLabel;
+        }
+  
+  /* Assemble Destination Fragments */
+
+  pSslCommand->NumDestination            = pSslCommand->NumSource;
+  pSslCommand->DestinationFragments      = pSslCommand->SourceFragments;
+  pArc4Params->state_out.FragmentAddress = PhysStateBuf;
+  pArc4Params->state_out.FragmentLength  = 260;
+  
+  pCommandContext->CallBackStatus = 0;
+  pSslCommand->CommandContext     = (unsigned long)pCommandContext;
+  pSslCommand->CompletionCallback = CmdCompleteCallback;
+  pSslCommand->Command            = UBSEC_ARC4;
+  
+  start_time(&(pCommandContext->tv_start));
+  
+#ifdef DEBUG
+  PRINTK("Linux:ubsec_sslarc4 just before SRL call...\n");
+#endif
+
+#ifndef LINUX2dot2
+  init_waitqueue_head(&pCommandContext->WaitQ);
+#else
+   pCommandContext->WaitQ         = 0;
+#endif 
+
+  IOInfo.result_status = ubsec_SSLCommand(pContext, pSslCommand, &NumCommands);
+  
+  switch(IOInfo.result_status) {
+  case UBSEC_STATUS_SUCCESS:
+    break;
+    
+  case UBSEC_STATUS_TIMEOUT:
+    PRINTK(" ubsec_SslCommand() timeout\n");
+    ubsec_ResetDevice(pContext);
+    error = -ETIMEDOUT;
+    goto ReturnErrorLabel;
+    break;
+    
+  case UBSEC_STATUS_INVALID_PARAMETER:
+    PRINTK("  ubsec_SslCommand() invalid parameter\n");
+    error = -EINVAL;
+    goto ReturnErrorLabel;
+    break;
+    
+  case UBSEC_STATUS_NO_RESOURCE:
+    PRINTK(" ubsec_SslCommand() no resource. Number done: %d\n", NumCommands);
+    error = -ENOBUFS;
+    goto ReturnErrorLabel;
+    break;
+    
+  default:
+    error = -ENOMSG;
+    goto ReturnErrorLabel;
+    break;
+  }
+  
+#ifdef GOTOSLEEP
+  
+  if(!(pCommandContext->CallBackStatus))  /* Just in case completed on same thread. */
+    Gotosleep(&pCommandContext->WaitQ);
+    if (!pCommandContext->CallBackStatus) {
+         pCommandContext->Status=UBSEC_STATUS_TIMEOUT;
+         ubsec_ResetDevice(pContext);
+         error = -ETIMEDOUT;
+         goto ReturnErrorLabel;
+    }
+#else
+  
+  for(delayTotalUs = 1; !(CommandContext.CallBackStatus); delayTotalUs++) {
+    
+#ifdef POLL
+    
+    /* We need to poll the device if we are operating in POLL mode. */
+    ubsec_PollDevice(pContext);
+    
+#endif
+    
+    if(delayTotalUs >= 3000000) {
+      error = -ETIMEDOUT;
+      ubsec_ResetDevice(pContext);
+      goto ReturnErrorLabel;
+    }
+    udelay(1);
+  }
+  
+#endif
+
+#if DEBUG
+  PRINTK("Linux: Dest Buffer (post-SRL)\n");
+  for(i = 0; i < 32; i++) {
+    PRINTK("%02X", pKernDestBuffer[i]);
+  }
+  PRINTK("\n");
+#endif
+#if DEBUG
+  PRINTK("Linux: State Buffer (post-SRL)\n");
+  for(i = 0; i < 260; i++) {
+    PRINTK("%02X", pKernStateBuffer[i]);
+  }
+  PRINTK("\n");
+#endif
+  
+  IOInfo.time_us = CommandContext.tv_start.tv_sec * 1000000 + CommandContext.tv_start.tv_usec;
+  if(IOInfo.result_status == UBSEC_STATUS_SUCCESS) {
+    if (copy_to_user(IOInfo.DestBuffer, pKernDestBuffer, SourceBufferBytes)) {
+      error = -EFAULT;
+      goto ReturnErrorLabel;
+    }
+    if( (IOInfo.KeyStateFlag & ARC4_STATE_SUPPRESS_WRITEBACK) != ARC4_STATE_SUPPRESS_WRITEBACK){
+      if (copy_to_user(IOInfo.StateOutBuffer, pKernStateBuffer, 260)) {
+        error = -EFAULT;
+        goto ReturnErrorLabel;
+      }
+    }
+    if (copy_to_user(pIOInfo, &IOInfo, sizeof(ubsec_arc4_io_t))) {
+      error = -EFAULT;
+      goto ReturnErrorLabel;
+    }
+  }
+  
+ ReturnErrorLabel:
+  
+#ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  if(pKernSourceBuffer != NULL)
+    kfree(pKernSourceBuffer);
+  if(pKernStateBuffer != NULL)
+    kfree(pKernStateBuffer);
+  if(pArc4Params->KeyStateIn != NULL)
+    kfree(pArc4Params->KeyStateIn);
+  
+#endif /* ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+  
+  if(pSourceFragments != NULL)
+    kfree(pSourceFragments);
+  
+  return(error);
+}
+
diff -urNp linux-8030/drivers/addon/bcm/sslcipher.c linux-8040/drivers/addon/bcm/sslcipher.c
--- linux-8030/drivers/addon/bcm/sslcipher.c
+++ linux-8040/drivers/addon/bcm/sslcipher.c
@@ -0,0 +1,379 @@
+
+/*
+ *  Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ *  of any kind, either express or implied as further specified in the GNU Public
+ *  License. This software may be used and distributed according to the terms of
+ *  the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+/******************************************************************************
+ *
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/*******************************************************************************
+ *
+ * File: Linux/sslcipher.c
+ * 
+ * What: Character driver interface to SSL DES routines in the ubsec driver
+ *
+ * Revision History:
+ *                   When       Who   What
+ *                   10/24/00   DNA   Created
+ * March 2001 PW Release for Linux 2.4 UP and SMP kernel
+ *
+ ******************************************************************************/
+
+#include "cdevincl.h"
+
+#ifdef FILE_DEBUG_TAG
+#undef FILE_DEBUG_TAG
+#endif
+#define FILE_DEBUG_TAG  "BCMSSL"
+
+/* This is useful only for diagnostics. */
+#undef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+
+#ifdef POLL
+#undef GOTOSLEEP
+#endif
+
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+
+unsigned char * pKernSourceBuffer = NULL;
+unsigned char * pKernDestBuffer   = NULL;
+static int      PhysSourceBuf     = 0;
+static int      PhysDestBuf       = 0;
+
+#endif /* ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+
+
+/**************************************************************************
+ *
+ * Function:  init_sslcipherif
+ * 
+ * Called from: init_module() in Linux/dispatch.c
+ *
+ * Description: 
+ *
+ * Return Values:
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+
+int 
+init_sslcipherif(void) {
+  int error = 0;
+  
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  pKernSourceBuffer = pKernDestBuffer = (char *)kmalloc((MAX_FILE_SIZE),GFP_KERNEL|GFP_ATOMIC);
+  if(pKernSourceBuffer == NULL) {
+    PRINTK("no memory for source buffer %d\n", MAX_FILE_SIZE);
+    error = -ENOMEM;
+    return(error);
+  }
+  memset(pKernSourceBuffer,0, MAX_FILE_SIZE);
+  
+#ifdef DEBUG
+  
+  PRINTK("Allocate Source: %x %x\n", pKernSourceBuffer, vtophys(pKernSourceBuffer));
+
+#endif /* ifdef DEBUG */
+  
+  PhysSourceBuf = PhysDestBuf = virt_to_bus(pKernSourceBuffer);
+
+#ifdef DEBUG
+  
+  PRINTK("Memory Alloc Source %x %x Dest %x %x for source buffer\n",
+	 pKernSourceBuffer, PhysSourceBuf, KernDestBuffer, PhysDestBuf);
+  PRINTK("Memory Alloc State %x %x state buffer\n", pKernStateBuffer, PhysStateBuf);
+    
+#endif /* ifdef DEBUG */
+  
+#endif /* ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+
+  return(error);
+}
+
+
+/**************************************************************************
+ *
+ * Function: shutdown_sslcipherif
+ *
+ * Called from: cleaup_module() in Linux/dispatch.c
+ *
+ * Description:
+ *
+ *************************************************************************/
+
+void 
+shutdown_sslcipherif(void) {
+  
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  if(pKernSourceBuffer != NULL)
+    kfree(pKernSourceBuffer);
+  
+  pKernSourceBuffer = pKernDestBuffer = NULL;
+  PhysSourceBuf = PhysDestBuf = 0;
+  
+#endif /* ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+  
+  return;
+}
+
+/**************************************************************************
+ *
+ * Function:  ubsec_sslcipher
+ * 
+ * Called from: ubsec_ioctl() in Linux/dispatch.c
+ *
+ * Purpose:
+ *          Wrapper function between user call and call to SRL.
+ *
+ * Description: 
+ *              Prepare all the data from the user's call for a call to 
+ *              the SRL, set up the timer, and finally place this thread
+ *              on the wait queue and go to sleep. When ubsec_sslcipher is 
+ *              called, the relevant data for an SSL DES op reside in
+ *              user space. The struct ubecom_sslcipher_io_pt argument, pIOInfo, 
+ *              points to data on the stack and in kernal space. However, 
+ *              pIOInfo is a struct that contains pointers which still 
+ *              point to memory in user space. ubecom_ssl copies the 
+ *              contents of pIOInfo as well as the input data it points
+ *              to into memory allocated in kernal space with LinuxAllocateMemory.
+ *
+ * Return Values: 
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+
+int
+ubsec_sslcipher(
+		ubsec_DeviceContext_t  pContext,
+		ubsec_sslcipher_io_t  *pIOInfo,
+		unsigned int features) {
+  
+  ubsec_sslcipher_io_t           IOInfo;
+  /* ubsec_sslcipher_io_pt          pIOInfo           = &IOInfo; */
+  ubsec_SSLCommandInfo_t         SslCommand;
+  ubsec_SSLCommandInfo_pt        pSslCommand       = &SslCommand;
+  ubsec_SSLCipherParams_pt       pCipherParams     = &(pSslCommand->Parameters.SSLCipherParams);
+  volatile  CommandContext_t  CommandContext;
+  CommandContext_t          *pCommandContext   = (CommandContext_t *)&CommandContext;
+  int                            NumCommands       = 1;
+  unsigned long		         delayTotalUs      = 0;
+  ubsec_FragmentInfo_pt          pSourceFragments  = NULL;
+  unsigned char *                pUserSourceBuffer = NULL;
+  unsigned int                   SourceBufferBytes = 0;
+  int                            error             = 0;
+  int                            i                 = 0;
+
+#ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  unsigned char *               pKernSourceBuffer = NULL;
+  unsigned char *               pKernDestBuffer   = NULL;
+  int                           PhysSourceBuf     = 0;
+  int                           PhysDestBuf       = 0;
+  
+#endif /* ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+
+  if (copy_from_user(&IOInfo, pIOInfo, sizeof(ubsec_sslcipher_io_t)))
+    return -EFAULT;
+  if (UBSEC_USING_CRYPT(IOInfo.command) == UBSEC_3DES)
+  {
+     if (!(features & UBSEC_EXTCHIPINFO_3DES))
+        return -EINVAL;
+  }
+  pUserSourceBuffer = IOInfo.SourceBuffer;
+  SourceBufferBytes = IOInfo.SourceBufferBytes;
+
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  if(SourceBufferBytes > MAX_FILE_SIZE) {
+    PRINTK("input file too large <%d,%d>\n", SourceBufferBytes, MAX_FILE_SIZE);
+    error = -EINVAL;
+    return(error);
+  }
+
+#else
+  
+  pKernSourceBuffer = pKernDestBuffer = (char *)kmalloc((SourceBufferBytes),GFP_KERNEL|GFP_ATOMIC);
+  if(pKernSourceBuffer == NULL) {
+    PRINTK("no memory for source buffer %d\n", SourceBufferBytes);
+    error = -ENOMEM;
+    goto ReturnErrorLabel;
+  }
+  memset(pKernSourceBuffer,0, SourceBufferBytes);
+  
+#ifdef DEBUG
+  PRINTK("Allocate Source: %x %x\n", pKernSourceBuffer, vtophys(pKernSourceBuffer));
+#endif
+  
+  PhysSourceBuf = PhysDestBuf = virt_to_bus(pKernSourceBuffer);
+
+#ifdef DEBUG
+  PRINTK("Memory Alloc Source %x %x Dest %x %x for source buffer\n",
+	 pKernSourceBuffer, PhysSourceBuf, pKernDestBuffer, PhysDestBuf);
+#endif
+  
+#endif /* ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+  
+  /* Endianness issue? */
+  memcpy(pCipherParams->InitialVector, IOInfo.InitialVector, sizeof(ubsec_IV_t));
+  memcpy(pCipherParams->CryptKey, IOInfo.CryptKey, 4*UBSEC_3DES_KEY_LENGTH);
+  
+  /* Assemble Source Fragments */
+  
+  pSourceFragments = (ubsec_FragmentInfo_pt)kmalloc((((sizeof(ubsec_FragmentInfo_t) * UBSEC_MAX_FRAGMENTS))),GFP_KERNEL|GFP_ATOMIC);
+  if(pSourceFragments == NULL) {
+    PRINTK("no memory for fragment buffer\n");
+    error = -ENOMEM;
+    return(error);
+  }
+  
+  pSslCommand->SourceFragments = pSourceFragments;
+  if ((pSslCommand->NumSource = SetupFragmentList(pSslCommand->SourceFragments,
+						  pKernSourceBuffer,
+						  SourceBufferBytes)) == 0) {
+    /* The input/output data requires more fragments than the current driver build can provide; return error */
+    error = UBSEC_STATUS_NO_RESOURCE;
+    goto ReturnErrorLabel;
+  }
+  
+  if (copy_from_user(pKernSourceBuffer, pUserSourceBuffer, SourceBufferBytes)) {
+    error = -EFAULT;
+    goto ReturnErrorLabel;
+  }
+  
+  /* Assemble Destination Fragments */
+
+  pSslCommand->NumDestination       = pSslCommand->NumSource;
+  pSslCommand->DestinationFragments = pSslCommand->SourceFragments;
+
+  pCommandContext->CallBackStatus   = 0;
+  pSslCommand->CommandContext       = (unsigned long) pCommandContext;
+  pSslCommand->CompletionCallback   = CmdCompleteCallback;
+  pSslCommand->Command              = IOInfo.command;
+  
+  start_time(&(pCommandContext->tv_start));
+
+#if DEBUG
+  PRINTK("Linux:ubsec_sslarc4 just before SRL call...\n");
+#endif
+
+#ifndef LINUX2dot2
+  init_waitqueue_head(&pCommandContext->WaitQ);
+#else
+   pCommandContext->WaitQ         = 0;
+#endif 
+
+  IOInfo.result_status = ubsec_SSLCommand(pContext, pSslCommand, &NumCommands);
+  
+  switch(IOInfo.result_status) {
+  case UBSEC_STATUS_SUCCESS:
+    break;
+    
+  case UBSEC_STATUS_TIMEOUT:
+    PRINTK(" ubsec_SslCommand() timeout\n");
+    ubsec_ResetDevice(pContext);
+    error = -ETIMEDOUT;
+    goto ReturnErrorLabel;
+    break;
+    
+  case UBSEC_STATUS_INVALID_PARAMETER:
+    PRINTK("  ubsec_SslCommand() invalid parameter\n");
+    error = -EINVAL;
+    goto ReturnErrorLabel;
+    break;
+    
+  case UBSEC_STATUS_NO_RESOURCE:
+    PRINTK(" ubsec_SslCommand() no resource. Number done: %d\n", NumCommands);
+    error = -ENOBUFS;
+    goto ReturnErrorLabel;
+    break;
+    
+  default:
+    error = -ENOMSG;
+    goto ReturnErrorLabel;
+    break;
+  }
+  
+#ifdef GOTOSLEEP
+  
+  if(!(pCommandContext->CallBackStatus))  /* Just in case completed on same thread. */
+    Gotosleep(&pCommandContext->WaitQ);
+    if (!pCommandContext->CallBackStatus) {
+              pCommandContext->Status=UBSEC_STATUS_TIMEOUT;
+              ubsec_ResetDevice(pContext);
+              error = -ETIMEDOUT;
+              goto ReturnErrorLabel;
+
+    }                          
+  
+#else
+  
+  for(delayTotalUs = 1; !(CommandContext.CallBackStatus); delayTotalUs++) {
+    
+#ifdef POLL
+    
+    /* We need to poll the device if we are operating in POLL mode. */
+    ubsec_PollDevice(pContext);
+    
+#endif
+    
+    if(delayTotalUs >= 3000000) {
+      error = -ETIMEDOUT;
+      ubsec_ResetDevice(pContext);
+      goto ReturnErrorLabel;
+    }
+    udelay(1);
+  }
+  
+#endif
+
+#if DEBUG
+  PRINTK("Linux: Dest Buffer (post-SRL)\n");
+  for(i = 0; i < SourceBufferBytes; i++) {
+    PRINTK("%02X", pKernDestBuffer[i]);
+  }
+  PRINTK("\n");
+#endif
+
+  IOInfo.time_us = CommandContext.tv_start.tv_sec * 1000000 + CommandContext.tv_start.tv_usec;
+  if(IOInfo.result_status == UBSEC_STATUS_SUCCESS) {
+    if (copy_to_user(IOInfo.DestBuffer, pKernDestBuffer, SourceBufferBytes)
+     || copy_to_user(pIOInfo, &IOInfo, sizeof(ubsec_arc4_io_t))) {
+      error = -EFAULT;
+      goto ReturnErrorLabel;
+    }
+  }
+  
+ ReturnErrorLabel:
+  
+#ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  if(pKernSourceBuffer != NULL) {
+    kfree(pKernSourceBuffer);
+    pKernSourceBuffer = pKernDestBuffer = NULL;
+  }
+  
+#endif /* ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+  
+  if(pSourceFragments != NULL) {
+    kfree(pSourceFragments);
+    pSourceFragments = NULL;
+  }
+  
+  return(error);
+}
+
diff -urNp linux-8030/drivers/addon/bcm/sslmac.c linux-8040/drivers/addon/bcm/sslmac.c
--- linux-8030/drivers/addon/bcm/sslmac.c
+++ linux-8040/drivers/addon/bcm/sslmac.c
@@ -0,0 +1,435 @@
+
+/*
+ *  Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ *  of any kind, either express or implied as further specified in the GNU Public
+ *  License. This software may be used and distributed according to the terms of
+ *  the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+/******************************************************************************
+ *
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+/*
+ * Broadcom Corporation uBSec SDK
+ */
+/*
+ * pkey.c: Character driver interface to public key routines.
+ */
+/*
+ * Revision History:
+ *
+ * March 2001 PW Release for Linux 2.4 UP and SMP kernel
+ * 10/09/2001 SRM 64 bit port
+ */         
+
+#include "cdevincl.h"
+
+#ifdef FILE_DEBUG_TAG
+#undef FILE_DEBUG_TAG
+#endif
+#define FILE_DEBUG_TAG  "BCMSSL"
+
+/* This is useful only for diagnostics. */
+#undef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+
+#ifdef POLL
+#undef GOTOSLEEP
+#endif
+
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+
+unsigned char * pKernSourceBuffer = NULL;
+unsigned char * pKernDestBuffer   = NULL;
+static ubsec_MemAddress_t      PhysSourceBuf;
+static ubsec_MemAddress_t      PhysDestBuf;
+
+#endif /* ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+
+
+/**************************************************************************
+ *
+ * Function:  init_sslmacif
+ * 
+ * Called from: init_module() in Linux/dispatch.c
+ *
+ * Description: 
+ *              Buffer sent to SRL is not malloc'd here after all, to allow 
+ *              for re-entrant code.
+ *
+ * Return Values:
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+
+int 
+init_sslmacif(void) {
+  
+  int error = 0;
+  
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  pKernSourceBuffer = pKernDestBuffer = (char *)kmalloc((MAX_FILE_SIZE),GFP_KERNEL|GFP_ATOMIC);
+  if(pKernSourceBuffer == NULL) {
+    PRINTK("no memory for source buffer %d\n", MAX_FILE_SIZE);
+    error = -ENOMEM;
+    return(error);
+  }
+  memset(pKernSourceBuffer,0, MAX_FILE_SIZE);
+  
+  pKernStateBuffer = (char *)kmalloc((260),GFP_KERNEL|GFP_ATOMIC);
+  if(pKernStateBuffer == NULL) {
+    PRINTK("no memory for source buffer %d\n", 260);
+    error = -ENOMEM;
+    return(error);
+  }
+  memset(pKernStateBuffer,0, 260);
+  
+#ifdef DEBUG
+  
+  PRINTK("Allocate Source: %x %x\n", pKernSourceBuffer, vtophys(pKernSourceBuffer));
+  PRINTK("Allocate State: %x %x\n", pKernStateBuffer, vtophys(pKernStateBuffer));
+
+#endif /* ifdef DEBUG */
+  
+  PhysSourceBuf = PhysDestBuf = (ubsec_MemAddress_t)(virt_to_bus(pKernSourceBuffer));
+
+#ifdef DEBUG
+  
+  PRINTK("Memory Alloc Source %x %x Dest %x %x for source buffer\n",
+	 pKernSourceBuffer, PhysSourceBuf, KernDestBuffer, PhysDestBuf);
+    
+#endif /* ifdef DEBUG */
+  
+#endif /* ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+
+  return(error);
+}
+
+
+/**************************************************************************
+ *
+ * Function: shutdown_sslmacif
+ *
+ * Called from: cleaup_module() in Linux/dispatch.c
+ *
+ * Description:
+ *
+ *************************************************************************/
+
+void 
+shutdown_sslmacif(void) {
+  
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  if(pKernSourceBuffer != NULL)
+    kfree(pKernSourceBuffer);
+  if(pKernStateBuffer != NULL)
+    kfree(pKernStateBuffer);
+  
+#endif /* ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+  
+  return;
+}
+
+/**************************************************************************
+ *
+ * Function:  ubsec_sslmac
+ * 
+ * Called from: ubsec_ioctl() in Linux/dispatch.c
+ *
+ * Purpose:
+ *          Wrapper function between user call and call to SRL.
+ *
+ * Description: 
+ *              Prepare all the data from the user's call for a call to 
+ *              the SRL, set up the timer, and finally place this thread
+ *              on the wait queue and go to sleep. When ubsec_sslmac is 
+ *              called, the relevant data for an SSL MAC op reside in
+ *              user space. The struct ubsec_sslmac_io_pt argument, pIOInfo, 
+ *              points to data on the stack and in kernal space. However, 
+ *              pIOInfo is a struct that contains pointers which still 
+ *              point to memory in user space. ubecom_ssl copies the 
+ *              contents of pIOInfo as well as the input data it points
+ *              to into memory allocated in kernal space with LinuxAllocateMemory.
+ *
+ * Return Values: 
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+
+int
+ubsec_sslmac(
+	     ubsec_DeviceContext_t pContext,
+	     ubsec_sslmac_io_t    *pIOInfo
+	     ) {
+  
+  ubsec_sslmac_io_t          IOInfo;
+  /* ubsec_sslmac_io_pt         pIOInfo           = &IOInfo; */
+  ubsec_SSLCommandInfo_t     SslCommand;
+  ubsec_SSLCommandInfo_pt    pSslCommand       = &SslCommand;
+  ubsec_SSLMACParams_pt      pSSLMACParams     = &(pSslCommand->Parameters.SSLMACParams);
+  volatile  CommandContext_t  CommandContext;
+  CommandContext_t          *pCommandContext   = (CommandContext_t *)&CommandContext;
+  int                        NumCommands       = 1;
+  unsigned long		     delayTotalUs      = 0;
+  ubsec_FragmentInfo_pt      pSourceFragments  = NULL;
+  unsigned char *            pUserSourceBuffer = NULL;
+  unsigned int               SourceBufferBytes = 0;
+  unsigned int               DestBufferBytes   = 0;
+  int                        error             = 0;
+
+#ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  unsigned char *           pKernSourceBuffer = NULL;
+  unsigned char *           pKernDestBuffer   = NULL;
+  ubsec_MemAddress_t        PhysSourceBuf;
+  ubsec_MemAddress_t        PhysDestBuf;
+  
+#endif /* ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+
+  /* Grab Data From User Space */
+  
+  if (copy_from_user(&IOInfo, pIOInfo, sizeof(ubsec_sslmac_io_t)))
+    return -EFAULT;
+  
+#if 0
+  PRINTK("content type = %d\n", IOInfo.ContentType);
+  PRINTK("data length = %d\n", IOInfo.DataLength);
+#endif
+
+  pUserSourceBuffer = IOInfo.SourceBuffer;
+  SourceBufferBytes = IOInfo.SourceBufferBytes;
+  
+#if 0
+  PRINTK("source bytes = %d\n", IOInfo.SourceBufferBytes);
+  PRINTK("hmac bytes = %d\n", IOInfo.HmacBufferBytes);
+  PRINTK("context type = %02X\n", IOInfo.ContentType);
+#endif
+  
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  if(SourceBufferBytes > MAX_FILE_SIZE) {
+    PRINTK("input file too large <%d,%d>\n", SourceBufferBytes, MAX_FILE_SIZE);
+    error = -EINVAL;
+    return(error);
+  }
+
+#else
+  
+  pKernSourceBuffer = (char *)kmalloc((SourceBufferBytes),GFP_KERNEL|GFP_ATOMIC);
+  if(pKernSourceBuffer == NULL) {
+    PRINTK("no memory for source buffer %d\n", SourceBufferBytes);
+    error = -ENOMEM;
+    goto ReturnErrorLabel;
+  }
+  memset(pKernSourceBuffer,0, SourceBufferBytes);
+  
+  pKernDestBuffer = (char *)kmalloc((UBSEC_HMAC_LENGTH),GFP_KERNEL|GFP_ATOMIC);
+  if(pKernDestBuffer == NULL) {
+    PRINTK("no memory for dest buffer %d\n", UBSEC_HMAC_LENGTH);
+    error = -ENOMEM;
+    goto ReturnErrorLabel;
+  }
+  memset(pKernDestBuffer,0, UBSEC_HMAC_LENGTH);
+  
+#ifdef DEBUG
+  
+  PRINTK("Allocate Source: %x %x\n", pKernSourceBuffer, vtophys(pKernSourceBuffer));
+  PRINTK("Allocate Source: %x %x\n", pKernDestBuffer, vtophys(pKernDestBuffer));
+  
+#endif /* ifdef DEBUG */
+  
+  PhysSourceBuf = (ubsec_MemAddress_t)(virt_to_bus(pKernSourceBuffer));
+  PhysDestBuf   = (ubsec_MemAddress_t)(virt_to_bus(pKernDestBuffer));
+  
+#ifdef DEBUG
+  
+  PRINTK("Memory Alloc Source %x %x Dest %x %x \n", pKernSourceBuffer, PhysSourceBuf, pKernDestBuffer, PhysDestBuf);
+    
+#endif /* ifdef DEBUG */
+  
+#endif /* ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+
+  /* Assemble Source Fragments */
+  
+  pSourceFragments = kmalloc((((sizeof(ubsec_FragmentInfo_t) * UBSEC_MAX_FRAGMENTS))),GFP_KERNEL|GFP_ATOMIC);
+  if(pSourceFragments == NULL) {
+    PRINTK("no memory for fragment buffer\n");
+    error = -ENOMEM;
+    return(error);
+  }
+  
+  pSslCommand->SourceFragments = pSourceFragments;
+  if ((pSslCommand->NumSource = SetupFragmentList(pSslCommand->SourceFragments,
+						  pKernSourceBuffer,
+						  SourceBufferBytes)) == 0) {
+    /* The input data requires more fragments than the current driver build can provide; return error */
+    error = UBSEC_STATUS_NO_RESOURCE;
+    goto ReturnErrorLabel;
+  }
+  if (copy_from_user(pKernSourceBuffer, pUserSourceBuffer, SourceBufferBytes)) {
+    error = -EFAULT;
+    goto ReturnErrorLabel;
+  }
+
+  /* Assemble Destination Fragment */
+
+  pSslCommand->NumDestination             = 0;
+  pSSLMACParams->OutputHMAC.FragmentAddress = PhysDestBuf;
+  pSSLMACParams->OutputHMAC.FragmentLength  = 0; /* fixed output length */
+
+  /* Set Data */
+
+  memcpy(&(pSSLMACParams->key), &(IOInfo.key), sizeof(ubsec_SSLMAC_key_t));  /* memcpy for portability */
+  pSSLMACParams->SequenceNumber = IOInfo.SequenceNumber;
+  pSSLMACParams->ContentType    = IOInfo.ContentType;
+  pSSLMACParams->DataLength     = IOInfo.DataLength;
+
+  /* Assemble SSL Command */
+
+  pSslCommand->Command = UBSEC_SSL_MAC;
+  if(IOInfo.HashAlgorithm == MAC_SHA1) {
+    pSslCommand->Command |= UBSEC_SSL_MAC_SHA1;
+    DestBufferBytes = UBSEC_SHA1_LENGTH;  
+  }         
+  else {
+    pSslCommand->Command |= UBSEC_SSL_MAC_MD5;
+    DestBufferBytes = UBSEC_MD5_LENGTH;  
+  }
+#if 0
+  PRINTK("command = x%x\n", pSslCommand->Command);
+#endif
+  pCommandContext->CallBackStatus         = 0;
+  pSslCommand->CommandContext             = (unsigned long) pCommandContext;
+  pSslCommand->CompletionCallback         = CmdCompleteCallback;
+  
+  start_time(&(pCommandContext->tv_start));
+  
+#if 0
+  PRINTK("Linux:ubsec_sslmac just before SRL call...\n");
+#endif
+
+#ifndef LINUX2dot2
+  init_waitqueue_head(&pCommandContext->WaitQ);
+#else
+   pCommandContext->WaitQ         = 0;
+#endif 
+
+  IOInfo.result_status = ubsec_SSLCommand(pContext, pSslCommand, &NumCommands);
+  
+  switch(IOInfo.result_status) {
+  case UBSEC_STATUS_SUCCESS:
+    break;
+    
+  case UBSEC_STATUS_TIMEOUT:
+    PRINTK(" ubsec_SslCommand() timeout\n");
+    ubsec_ResetDevice(pContext);
+    error = -ETIMEDOUT;
+    goto ReturnErrorLabel;
+    break;
+    
+  case UBSEC_STATUS_INVALID_PARAMETER:
+    PRINTK("  ubsec_SslCommand() invalid parameter\n");
+    error = -EINVAL;
+    goto ReturnErrorLabel;
+    break;
+    
+  case UBSEC_STATUS_NO_RESOURCE:
+    PRINTK(" ubsec_SslCommand() no resource. Number done: %d\n", NumCommands);
+    error = -ENOBUFS;
+    goto ReturnErrorLabel;
+    break;
+    
+  default:
+    error = -ENOMSG;
+    goto ReturnErrorLabel;
+    break;
+  }
+  
+#ifdef GOTOSLEEP
+  
+  if(!(pCommandContext->CallBackStatus))  /* Just in case completed on same thread. */
+    Gotosleep(&pCommandContext->WaitQ);
+    if (!pCommandContext->CallBackStatus) {
+              pCommandContext->Status=UBSEC_STATUS_TIMEOUT;
+      	      error = -ETIMEDOUT;
+      	      ubsec_ResetDevice(pContext);
+      	      goto ReturnErrorLabel;
+
+    }                          
+  
+#else
+  
+  for(delayTotalUs = 1; !(CommandContext.CallBackStatus); delayTotalUs++) {
+    
+#ifdef POLL
+    
+    /* We need to poll the device if we are operating in POLL mode. */
+    ubsec_PollDevice(pContext);
+    
+#endif
+    
+    if(delayTotalUs >= 3000000) {
+      error = -ETIMEDOUT;
+      ubsec_ResetDevice(pContext);
+      goto ReturnErrorLabel;
+    }
+    udelay(1);
+  }
+  
+#endif
+
+#if 0
+  PRINTK("Linux:ubsec_hash: Dest Buffer (post-SRL)\n");
+  for(i = 0; i < UBSEC_HMAC_LENGTH; i++) {
+    PRINTK("%02X", pKernDestBuffer[i]);
+  }
+  PRINTK("\n");
+#endif
+
+  IOInfo.time_us = CommandContext.tv_start.tv_sec * 1000000 + CommandContext.tv_start.tv_usec;
+  if(IOInfo.result_status == UBSEC_STATUS_SUCCESS) {
+    if (copy_to_user(IOInfo.HmacBuffer, pKernDestBuffer, DestBufferBytes)) {
+      error = -EFAULT;
+      goto ReturnErrorLabel;
+    }
+#if 1
+    if (copy_to_user(pIOInfo, &IOInfo, sizeof(ubsec_sslmac_io_t))) {
+      error = -EFAULT;
+      goto ReturnErrorLabel;
+    }
+#endif
+  }
+  
+ ReturnErrorLabel:
+  
+#ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  if(pKernSourceBuffer != NULL) {
+    kfree(pKernSourceBuffer);
+    pKernSourceBuffer = NULL;
+  }
+  if(pKernDestBuffer != NULL) {
+    kfree(pKernDestBuffer);
+    pKernDestBuffer = NULL;
+  }
+  
+#endif /* ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+  
+  if(pSourceFragments != NULL) {
+    kfree(pSourceFragments);
+    pSourceFragments = NULL;
+  }
+
+  return(error);
+}
+
diff -urNp linux-8030/drivers/addon/bcm/tlsmac.c linux-8040/drivers/addon/bcm/tlsmac.c
--- linux-8030/drivers/addon/bcm/tlsmac.c
+++ linux-8040/drivers/addon/bcm/tlsmac.c
@@ -0,0 +1,409 @@
+
+/*
+ *  Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ *  of any kind, either express or implied as further specified in the GNU Public
+ *  License. This software may be used and distributed according to the terms of
+ *  the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+/******************************************************************************
+ *
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/*******************************************************************************
+ *
+ * File: Linux/tlsmac.c
+ * 
+ * What: Character driver interface to TLS HMAC routines in the ubsec driver
+ *
+ * Revision History:
+ *                   When       Who   What
+ *                   10/24/00   DNA   Created
+ * March 2001 PW Release for Linux 2.4 UP and SMP kernel 
+ * 10/09/2001 SRM 64 bit port
+ *
+ ******************************************************************************/
+
+#include "cdevincl.h"
+
+/* This is useful only for diagnostics. */
+#undef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+
+#ifdef POLL
+#undef GOTOSLEEP
+#endif
+
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+
+unsigned char * pKernSourceBuffer = NULL;
+unsigned char * pKernDestBuffer   = NULL;
+static ubsec_MemAddress_t      PhysSourceBuf     = 0;
+static ubsec_MemAddress_t      PhysDestBuf       = 0;
+
+#endif /* ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+
+
+/**************************************************************************
+ *
+ * Function:  init_tlsmacif
+ * 
+ * Called from: init_module() in Linux/dispatch.c
+ *
+ * Description: 
+ *
+ * Return Values:
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+
+int 
+init_tlsmacif(void) {
+  int error = 0;
+  
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  pKernSourceBuffer = pKernDestBuffer = (char *)kmalloc((MAX_FILE_SIZE),GFP_KERNEL|GFP_ATOMIC);
+  if(pKernSourceBuffer == NULL) {
+    PRINTK("no memory for source buffer %d\n", MAX_FILE_SIZE);
+    error = -ENOMEM;
+    return(error);
+  }
+  memset(pKernSourceBuffer,0, MAX_FILE_SIZE);
+  
+#ifdef DEBUG
+  
+  PRINTK("Allocate Source: %x %x\n", pKernSourceBuffer, vtophys(pKernSourceBuffer));
+
+#endif /* ifdef DEBUG */
+  
+  PhysSourceBuf = PhysDestBuf = (ubsec_MemAddress_t)(virt_to_bus(pKernSourceBuffer));
+
+#ifdef DEBUG
+  
+  PRINTK("Memory Alloc Source %x %x Dest %x %x for source buffer\n",
+	 pKernSourceBuffer, PhysSourceBuf, KernDestBuffer, PhysDestBuf);
+  PRINTK("Memory Alloc State %x %x state buffer\n", pKernStateBuffer, PhysStateBuf);
+    
+#endif /* ifdef DEBUG */
+  
+#endif /* ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+
+  return(error);
+}
+
+
+/**************************************************************************
+ *
+ * Function: shutdown_tlsmacif
+ *
+ * Called from: cleaup_module() in Linux/dispatch.c
+ *
+ * Description:
+ *
+ *************************************************************************/
+
+void 
+shutdown_tlsmacif(void) {
+  
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  if(pKernSourceBuffer != NULL)
+    kfree(pKernSourceBuffer);
+  
+  pKernSourceBuffer = pKernDestBuffer = NULL;
+  PhysSourceBuf = PhysDestBuf = 0;
+  
+#endif /* ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+  
+  return;
+}
+
+/**************************************************************************
+ *
+ * Function:  ubsec_tlsmac
+ * 
+ * Called from: ubsec_ioctl() in Linux/dispatch.c
+ *
+ * Purpose:
+ *          Wrapper function between user call and call to SRL.
+ *
+ * Description: 
+ *              Prepare all the data from the user's call for a call to 
+ *              the SRL, set up the timer, and finally place this thread
+ *              on the wait queue and go to sleep. When ubsec_tlsmac is 
+ *              called, the relevant data for an SSL DES op reside in
+ *              user space. The struct ubecom_tlsmac_io_pt argument, pIOInfo, 
+ *              points to data on the stack and in kernal space. However, 
+ *              pIOInfo is a struct that contains pointers which still 
+ *              point to memory in user space. ubecom_ssl copies the 
+ *              contents of pIOInfo as well as the input data it points
+ *              to into memory allocated in kernal space with LinuxAllocateMemory.
+ *
+ * Return Values: 
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+
+int
+ubsec_tlsmac(
+		ubsec_DeviceContext_t  pContext,
+		ubsec_tlsmac_io_t *   pIOInfo
+		) {
+  
+  ubsec_tlsmac_io_t             IOInfo;
+  ubsec_SSLCommandInfo_t        SslCommand;
+  ubsec_SSLCommandInfo_pt       pSslCommand       = &SslCommand;
+  ubsec_TLSHMACParams_pt        pTLSHMACParams     = &(pSslCommand->Parameters.TLSHMACParams);
+  volatile  CommandContext_t  CommandContext;
+  CommandContext_t          *pCommandContext   = (CommandContext_t *)&CommandContext;
+  int                           NumCommands       = 1;
+  unsigned long		        delayTotalUs      = 0;
+  ubsec_FragmentInfo_pt         pSourceFragments  = NULL;
+  unsigned char *               pUserSourceBuffer = NULL;
+  unsigned int                  SourceBufferBytes = 0;
+  unsigned int                  DestBufferBytes   = 0;
+  int                           error             = 0;
+  ubsec_HMAC_State_t            HMACState;
+  ubsec_HMAC_State_pt           pHMACState        = &HMACState;
+  
+#ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  unsigned char *              pKernSourceBuffer = NULL;
+  unsigned char *              pKernDestBuffer   = NULL;
+  ubsec_MemAddress_t           PhysSourceBuf     = 0;
+  ubsec_MemAddress_t           PhysDestBuf       = 0;
+  
+#endif /* ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+
+  if (copy_from_user(&IOInfo, pIOInfo, sizeof(ubsec_tlsmac_io_t)))
+    return -EFAULT;
+  pUserSourceBuffer = IOInfo.SourceBuffer;
+  SourceBufferBytes = IOInfo.SourceBufferBytes;
+
+#ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  if(SourceBufferBytes > MAX_FILE_SIZE) {
+    PRINTK("input file too large <%d,%d>\n", SourceBufferBytes, MAX_FILE_SIZE);
+    error = -EINVAL;
+    return(error);
+  }
+
+#else
+  
+  pKernSourceBuffer = (char *)kmalloc((SourceBufferBytes),GFP_KERNEL|GFP_ATOMIC);
+  if(pKernSourceBuffer == NULL) {
+    PRINTK("no memory for source buffer %d\n", SourceBufferBytes);
+    error = -ENOMEM;
+    goto ReturnErrorLabel;
+  }
+  memset(pKernSourceBuffer,0, SourceBufferBytes);
+  
+  /* Allocate kernel memory to accommodate the largest MAC digest */
+  pKernDestBuffer = (char *)kmalloc(UBSEC_HMAC_LENGTH,GFP_KERNEL|GFP_ATOMIC);
+  if(pKernDestBuffer == NULL) {
+    PRINTK("no memory for dest buffer %d\n", UBSEC_HMAC_LENGTH);
+    error = -ENOMEM;
+    goto ReturnErrorLabel;
+  }
+  memset(pKernDestBuffer,0, UBSEC_HMAC_LENGTH);
+  
+#ifdef DEBUG
+  PRINTK("Allocate Source: %x %x\n", pKernSourceBuffer, vtophys(pKernSourceBuffer));
+  PRINTK("Allocate Dest: %x %x\n", pKernDestBuffer, vtophys(pKernDestBuffer));
+#endif
+  
+  PhysSourceBuf = (ubsec_MemAddress_t)(virt_to_bus(pKernSourceBuffer));
+  PhysDestBuf   = (ubsec_MemAddress_t)(virt_to_bus(pKernDestBuffer));
+
+#ifdef DEBUG
+  PRINTK("Memory Alloc Source %x %x Dest %x %x for source buffer\n",
+	 pKernSourceBuffer, PhysSourceBuf, pKernDestBuffer, PhysDestBuf);
+#endif
+  
+#endif /* ifdef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+  
+  /* 
+     IOInfo.MacKey points to either a key (MAC_KEY_LENGTH bytes max) or to
+     the Inner and Outer States (ubsec_HMAC_State_pt)
+  */
+
+  if (USING_MAC_STATES(IOInfo.HashAlgorithm)) {
+    memcpy(pHMACState, &IOInfo.MacKey, sizeof(ubsec_HMAC_State_t));
+  }
+  else {
+    ubsec_InitHMACState(pHMACState,UBSEC_USING_MAC(IOInfo.HashAlgorithm),IOInfo.MacKey);
+  }
+
+  pTLSHMACParams->HMACState      = pHMACState;
+  pTLSHMACParams->Version        = IOInfo.Version;
+  pTLSHMACParams->SequenceNumber = IOInfo.SequenceNumber;
+  pTLSHMACParams->ContentType    = IOInfo.ContentType;
+  pTLSHMACParams->DataLength     = IOInfo.DataLength;
+  
+#if DEBUG
+  PRINTK("hmacstate = %x\n", pTLSHMACParams->HMACState);
+#endif
+
+  /* Assemble Source Fragments */
+  
+  pSourceFragments = kmalloc((((sizeof(ubsec_FragmentInfo_t) * UBSEC_MAX_FRAGMENTS))),GFP_KERNEL|GFP_ATOMIC);
+  if(pSourceFragments == NULL) {
+    PRINTK("no memory for fragment buffer\n");
+    error = -ENOMEM;
+    return(error);
+  }
+  
+  pSslCommand->SourceFragments = pSourceFragments;
+  if ((pSslCommand->NumSource       = SetupFragmentList(pSslCommand->SourceFragments,
+						   pKernSourceBuffer,
+							SourceBufferBytes)) == 0) {
+    /* The input data requires more fragments than the current driver build can provide; return error */
+    error = UBSEC_STATUS_NO_RESOURCE;
+    goto ReturnErrorLabel;
+  }
+  
+  if (copy_from_user(pKernSourceBuffer, pUserSourceBuffer, SourceBufferBytes)) {
+    error = -EFAULT;
+    goto ReturnErrorLabel;
+  }
+  
+  /* Assemble Destination Fragments */
+
+  pSslCommand->NumDestination               = 0;
+  pTLSHMACParams->OutputHMAC.FragmentAddress = PhysDestBuf;
+  pTLSHMACParams->OutputHMAC.FragmentLength  = 0; /* fixed output length */
+  
+  pCommandContext->CallBackStatus   = 0;
+  pSslCommand->CommandContext       = (unsigned long) pCommandContext;
+  pSslCommand->CompletionCallback   = CmdCompleteCallback;
+  pSslCommand->Command              = IOInfo.command;
+  
+
+  if(IOInfo.command & UBSEC_MAC_SHA1)
+    DestBufferBytes = UBSEC_SHA1_LENGTH;
+  else
+    DestBufferBytes = UBSEC_MD5_LENGTH; 
+
+  start_time(&(pCommandContext->tv_start));
+
+#if DEBUG
+  PRINTK("Linux:ubsec_sslarc4 just before SRL call...\n");
+#endif
+
+#ifndef LINUX2dot2
+  init_waitqueue_head(&pCommandContext->WaitQ);
+#else
+   pCommandContext->WaitQ         = 0;
+#endif 
+
+  IOInfo.result_status = ubsec_SSLCommand(pContext, pSslCommand, &NumCommands);
+  
+  switch(IOInfo.result_status) {
+  case UBSEC_STATUS_SUCCESS:
+    break;
+    
+  case UBSEC_STATUS_TIMEOUT:
+    PRINTK(" ubsec_SslCommand() timeout\n");
+    ubsec_ResetDevice(pContext);
+    error = -ETIMEDOUT;
+    goto ReturnErrorLabel;
+    break;
+    
+  case UBSEC_STATUS_INVALID_PARAMETER:
+    PRINTK("  ubsec_SslCommand() invalid parameter\n");
+    error = -EINVAL;
+    goto ReturnErrorLabel;
+    break;
+    
+  case UBSEC_STATUS_NO_RESOURCE:
+    PRINTK(" ubsec_SslCommand() no resource. Number done: %d\n", NumCommands);
+    error = -ENOBUFS;
+    goto ReturnErrorLabel;
+    break;
+    
+  default:
+    error = -ENOMSG;
+    goto ReturnErrorLabel;
+    break;
+  }
+  
+#ifdef GOTOSLEEP
+  
+  if(!(pCommandContext->CallBackStatus))  /* Just in case completed on same thread. */
+    Gotosleep(&pCommandContext->WaitQ);
+    if (!pCommandContext->CallBackStatus) {
+              pCommandContext->Status=UBSEC_STATUS_TIMEOUT;
+              error = -ETIMEDOUT;
+              ubsec_ResetDevice(pContext);
+              goto ReturnErrorLabel;
+
+    }                          
+  
+#else
+  
+  for(delayTotalUs = 1; !(CommandContext.CallBackStatus); delayTotalUs++) {
+    
+#ifdef POLL
+    
+    /* We need to poll the device if we are operating in POLL mode. */
+    ubsec_PollDevice(pContext);
+    
+#endif
+    
+    if(delayTotalUs >= 3000000) {
+      error = -ETIMEDOUT;
+      ubsec_ResetDevice(pContext);
+      goto ReturnErrorLabel;
+    }
+    udelay(1);
+  }
+  
+#endif
+
+#if DEBUG
+  PRINTK("Linux: Dest Buffer (post-SRL)\n");
+  for(i = 0; i < UBSEC_HMAC_LENGTH; i++) {
+    PRINTK("%02X", pKernDestBuffer[i]);
+  }
+  PRINTK("\n");
+#endif
+  
+  IOInfo.time_us = CommandContext.tv_start.tv_sec * 1000000 + CommandContext.tv_start.tv_usec;
+  if(IOInfo.result_status == UBSEC_STATUS_SUCCESS) {
+    if (copy_to_user(IOInfo.HmacBuffer, pKernDestBuffer, DestBufferBytes)
+     || copy_to_user(pIOInfo, &IOInfo, sizeof(ubsec_arc4_io_t))) {
+      error = -EFAULT;
+      goto ReturnErrorLabel;
+    }
+  }
+  
+ ReturnErrorLabel:
+  
+#ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS
+  
+  if(pKernSourceBuffer != NULL)
+    kfree(pKernSourceBuffer);
+  if(pKernDestBuffer != NULL)
+    kfree(pKernDestBuffer);
+  pKernSourceBuffer = pKernDestBuffer = NULL;
+  PhysSourceBuf = PhysDestBuf = 0;
+  
+#endif /* ifndef STATIC_ALLOC_OF_CRYPTO_BUFFERS */
+  
+  if(pSourceFragments != NULL) {
+    kfree(pSourceFragments);
+    pSourceFragments = NULL;
+  }
+
+  return(error);
+}
+
diff -urNp linux-8030/drivers/addon/bcm/ubsciphr.c linux-8040/drivers/addon/bcm/ubsciphr.c
--- linux-8030/drivers/addon/bcm/ubsciphr.c
+++ linux-8040/drivers/addon/bcm/ubsciphr.c
@@ -0,0 +1,353 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubsciphr.c: Cipher commands are handled by this module
+ */
+
+/*
+ * Revision History:
+ *
+ * 09/xx/1999 SOR Created.
+ * 12/01/1999 DWP Modified to handle Big Endian setup.
+ * 12/03/1999 SOR Modifications to do all static address computations at init time
+ * 07/06/2000 DPA Fixes for SMP operation
+ * 09/21/2000 SOR Upgrade to make 5820 enable
+ * 04/03/2001 RJT Added support for CryptoNet device big-endian mode
+ * 04/20/2001 RJT Added support for CPU-DMA memory synchronization
+ * 07/16/2001 RJT Added support for BCM5821
+ * 10/09/2001 SRM 64 bit port.
+ */
+
+#include "ubsincl.h"
+
+/*
+ * ubsec_CipherCommand: Process a list of Cipher commands.
+ *
+ * Immediate Status is returned. Completion status is returned
+ * on a per command callback
+ */
+ubsec_Status_t 
+ubsec_CipherCommand(ubsec_DeviceContext_t Context,
+	      ubsec_CipherCommandInfo_pt pCommand,
+	      int *NumCommands)
+{
+  DeviceInfo_pt pDevice=(DeviceInfo_pt)Context;
+  VOLATILE MasterCommand_t  *pMCR;
+  VOLATILE Packet_t         *pPacket;
+  VOLATILE PacketContext_t  *pContext;
+  VOLATILE CipherContext_t  *pCipherContext;
+  VOLATILE int             PacketIndex;
+  VOLATILE int  NumFrags;   /* Number of fragments */
+  ubsec_FragmentInfo_t ExtraFragment, *pExtraFragment;
+  int CommandIndex=0;
+  int CommandCount=*NumCommands;
+  ubsec_Status_t Status;
+  UBS_UINT32 SaveConfig = 0;
+
+  Dbg_Print(DBG_CMD,( "ubsec:  ubsec command %d",*NumCommands ));
+
+  /*
+   * Check some parameters
+   */    
+  if(pDevice==NULL_DEVICE_INFO) {
+    Dbg_Print(DBG_FATAL,( "NO DEV\n " ));
+    return(UBSEC_STATUS_NO_DEVICE );
+  }
+  Dbg_Print(DBG_CMD,( "\n"));
+
+  if (OS_EnterCriticalSection(pDevice,SaveConfig)) {
+    return(UBSEC_STATUS_DEVICE_BUSY);
+  }
+
+  /* Get the next MCR to load */
+ Get_New_MCR:
+  *NumCommands=CommandIndex; /* Update number completed */
+  if ((pMCR=GetFreeMCR(pDevice,UBSEC_CIPHER_LIST,&Status))== NULL_MASTER_COMMAND) {
+    Dbg_Print(DBG_CMD_FAIL,("ubsec: device busy MCR %x\n", Status));
+    goto Error_Return;
+  }
+
+  /* Add packets to this MCR. */
+
+  Dbg_Print(DBG_CMD,( "ubsec: mcr_index %d MCR %0x\n",pMCR->Index,pMCR));
+  /* Initialize the packet information */
+
+  PacketIndex = pMCR->NumberOfPackets; 
+  pPacket = &(pMCR->PacketArray[PacketIndex]); /* Set up the current packet. */
+  pContext = &pMCR->ContextList[PacketIndex]; 
+  Status=UBSEC_STATUS_SUCCESS; /* Wishful thinking? */
+
+  /* Process all the commands in the command list. */
+  for (; CommandIndex < CommandCount ; CommandIndex++) { /* Add all the packets to the MCR */
+    if( PacketIndex >= MCR_MAXIMUM_PACKETS ) {
+      Dbg_Print(DBG_CMD,( "ubsec:  overran mcr buffer. %d %d\n",PacketIndex,CommandIndex ));
+      /* 
+       * We have filled this MCR with the max # of packets,
+       * but still have more packets (commands) to do.
+       * Advance next free. Wrap around if necessary
+       */
+      pDevice->NextFreeMCR[UBSEC_CIPHER_LIST]=
+	(MasterCommand_pt) pMCR->pNextMCR;
+
+      /* For crypto MCRs, the contexts are accessed using a single handle   */
+      /* for an array of contexts. This means that all contexts for an MCR  */
+      /* are contiguous in memory, and that we can sync all contexts at     */
+      /* once (now that we know that we're finished loading this MCR).      */
+      /* Make DMA memory actually hold CPU-initialized context data         */
+      Dbg_Print(DBG_CNTXT_SYNC,( "ubsec: ubsec_CipherCommand Sync %d Contexts to Device (0x%08X,%d,%d)\n", 
+			 pMCR->NumberOfPackets,
+			 pMCR->ContextListHandle[0],
+			 0,
+			 pMCR->NumberOfPackets * sizeof(PacketContext_t)));
+      OS_SyncToDevice(pMCR->ContextListHandle[0],0,
+		      pMCR->NumberOfPackets * sizeof(PacketContext_t));
+
+      PushMCR(pDevice); /* Get it going (pipeline) */
+      goto Get_New_MCR; /* Try to add to the next MCR */
+    }
+    
+    /* Save the callback information. */
+    pMCR->CompletionArray[PacketIndex].CompletionCallback = pCommand->CompletionCallback;
+    pMCR->CompletionArray[PacketIndex].CommandContext = pCommand->CommandContext;
+
+    /* Now set up the packet processing parameters */
+    Dbg_Print(DBG_PACKET,( "ubsec: packet_Index %d, Context Buf %0x\n",PacketIndex,pContext ));
+    pPacket->PacketContextBuffer=pContext->PhysicalAddress;
+    pCipherContext=&pContext->Context.Cipher;
+    RTL_MemZero(pCipherContext,sizeof(*pCipherContext));
+#ifdef UBSEC_582x_CLASS_DEVICE
+    /* Some extra fields to be filled in . */
+    pContext->cmd_structure_length= CPU_TO_CTRL_SHORT(sizeof(*pCipherContext)+4); /* For header. */
+    pContext->operation_type=OPERATION_IPSEC; /* send mode for DH */
+#endif    
+    /*
+     * Now add the packet input fragment information
+     * First fragment will need to skip the MAC Header
+     * We need at least one fragment.
+     */
+    /* Sanity checks.*/
+    if (!(NumFrags=pCommand->NumSource)) {
+      Dbg_Print(DBG_PACKET,( "ubsec:  No Input fragments\n" ));
+      Status=UBSEC_STATUS_INVALID_PARAMETER;
+      goto MCR_Done;
+    }
+    if (NumFrags>(UBSEC_MAX_FRAGMENTS+1)) {
+      Dbg_Print(DBG_PACKET,( "ubsec:  Too Many Input fragments\n" ));
+      Status=UBSEC_STATUS_INVALID_PARAMETER;
+      goto MCR_Done;
+    }
+
+    Dbg_Print(DBG_PACKET,( "ubsec: Num Input Frags %d \n",NumFrags));
+
+    /* SetupInputFragmentList will always be successful here because of */
+    /* the sanity checks performed above.                               */
+    SetupInputFragmentList((MasterCommand_t *)pMCR, (Packet_t *)pPacket,NumFrags,pCommand->SourceFragments);
+
+    /*
+     * Now add the packet output fragment information
+     * We need at least one fragment.
+     */
+    /* Sanity checks */
+    if (!(NumFrags=pCommand->NumDestination)) {
+      Dbg_Print(DBG_PACKET,( "ubsec:  No Output fragments\n" ));
+      Status=UBSEC_STATUS_INVALID_PARAMETER;
+      goto MCR_Done;
+    }
+    if (NumFrags > (UBSEC_MAX_FRAGMENTS+1)) {
+      Dbg_Print(DBG_PACKET,( "ubsec:  Too Many Output fragments\n" ));
+      Status=UBSEC_STATUS_INVALID_PARAMETER;
+      goto MCR_Done;
+    }
+
+    Dbg_Print(DBG_PACKET,( "ubsec: Num Output Frags %d \n",NumFrags));
+
+    if (UBSEC_USING_MAC(pCommand->Command)) { 
+      /* We need an 'extra' fragment info struct for the auth data */
+      ExtraFragment.FragmentAddress = 
+	pCommand->AuthenticationInfo.FragmentAddress;
+      /* Easy to do check here for invalid 'extra' fragment address */
+      if ( (long) ExtraFragment.FragmentAddress & 0x03 ) {
+	Dbg_Print(DBG_PACKET,("ubsec:  ################INVALID HMAC ADDRESS %08x\n",ExtraFragment.FragmentAddress));
+	Status=UBSEC_STATUS_INVALID_PARAMETER;
+	goto Error_Return;
+      }
+      /* The CryptoNet chip knows how big the auth fragment is, but */
+      /* SetupOutputFragmentList() needs to see a length of zero.   */
+      ExtraFragment.FragmentLength = 0;
+      pExtraFragment = &ExtraFragment;
+    }
+    else { /* not doing authentication; pass NULL extra fragment info */
+      pExtraFragment = (ubsec_FragmentInfo_pt) 0;
+    }
+    /* SetupOutputFragmentList() checks frag list for allowable fragment */
+    /* addresses (4-byte aligned) and lengths (4-byte multiples).        */
+    if (SetupOutputFragmentList((MasterCommand_t *)pMCR,(Packet_t *)pPacket,NumFrags,
+			    pCommand->DestinationFragments,pExtraFragment)) {
+      Status=UBSEC_STATUS_INVALID_PARAMETER;
+      goto Error_Return;
+    }
+
+    /* Set up the context flags */
+    if (pCommand->Command & UBSEC_ENCODE)
+      pCipherContext->CryptoFlag = CF_ENCODE;
+    else
+      pCipherContext->CryptoFlag = CF_DECODE;
+
+    if (UBSEC_USING_CRYPT( pCommand->Command )) {
+      pCipherContext->CryptoFlag |= CF_3DES;
+      pCipherContext->CryptoOffset = CPU_TO_CTRL_SHORT( pCommand->CryptHeaderSkip );
+      if (pCommand->Command &UBSEC_3DES) {
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_BIG_ENDIAN)
+	RTL_Memcpy( &pCipherContext->CryptoKey1[0], pCommand->CryptKey, 24);
+#else
+	copywords((UBS_UINT32 *)&pCipherContext->CryptoKey1[0], (UBS_UINT32 *)pCommand->CryptKey, 6);
+#endif
+      } 
+      else {  
+	/* Des is implemented by using 3 copies of the same DES key */
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_BIG_ENDIAN)
+	RTL_Memcpy( &pCipherContext->CryptoKey1[0], pCommand->CryptKey, 8); 
+#else
+	copywords((UBS_UINT32 *) &pCipherContext->CryptoKey1[0], (UBS_UINT32 *) pCommand->CryptKey, 2); 
+#endif
+	RTL_Memcpy( &pCipherContext->CryptoKey2[0],&pCipherContext->CryptoKey1[0],sizeof(pCipherContext->CryptoKey1));
+	RTL_Memcpy( &pCipherContext->CryptoKey3[0],&pCipherContext->CryptoKey1[0],sizeof(pCipherContext->CryptoKey1));
+      }
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_BIG_ENDIAN)
+      RTL_Memcpy(&pCipherContext->ComputedIV[0],&pCommand->InitialVector[0],8);
+#else
+      copywords((UBS_UINT32 *) &pCipherContext->ComputedIV[0], (UBS_UINT32 *) &pCommand->InitialVector[0],2);
+#endif
+    }
+    /* If using HMAC then copy the authentication state to the context. */
+    if( UBSEC_USING_MAC( pCommand->Command ) ) {
+      RTL_Memcpy( &pCipherContext->HMACInnerState[0],
+		  pCommand->HMACState,
+		  sizeof(ubsec_HMAC_State_t));
+      if( UBSEC_MAC_MD5 & pCommand->Command )
+	    pCipherContext->CryptoFlag |= CF_MD5;
+      else if( UBSEC_MAC_SHA1 & pCommand->Command )
+	    pCipherContext->CryptoFlag |= CF_SHA1;
+    }
+    
+    Dbg_Print( DBG_PACKET, ("ubsec:  CryptoOffset and Flag [%04x][%04x]\n",
+        CTRL_TO_CPU_SHORT( pCipherContext->CryptoOffset ), 
+        CTRL_TO_CPU_SHORT( pCipherContext->CryptoFlag )) );
+
+#ifdef UBSEC_STATS
+    if (pCipherContext->CryptoFlag & CF_DECODE) {
+      pDevice->Statistics.BlocksDecryptedCount++;
+      pDevice->Statistics.BytesDecryptedCount+=CTRL_TO_CPU_SHORT(pPacket->PacketLength);
+    }
+    else {
+      pDevice->Statistics.BlocksEncryptedCount++;
+      pDevice->Statistics.BytesEncryptedCount+=CTRL_TO_CPU_SHORT(pPacket->PacketLength);
+    }
+#endif
+
+   /* Now inc the number of packets and prepare for the next command. */
+    pMCR->NumberOfPackets++;
+    pCommand++;
+    PacketIndex++;
+    pPacket++;
+    pContext++;
+
+  } /* For NumCommands-- */
+
+  /*
+   * If we are here then the last packet(s) (commands) have been added to
+   * the current MCR.
+   * Push the MCR to the device. 
+   */
+ MCR_Done:
+  *NumCommands=CommandIndex; /* Update number completed */
+
+  /* For crypto MCRs, the contexts are accessed using a single handle   */
+  /* for an array of contexts. This means that all contexts for an MCR  */
+  /* are contiguous in memory, and that we can sync all contexts at     */
+  /* once (now that we know that we're finished loading this MCR).      */
+  /* Make DMA memory actually hold CPU-initialized context data         */
+  Dbg_Print(DBG_CNTXT_SYNC,( "ubsec: ubsec_CipherCommand Sync %d Contexts to Device (0x%08X,%d,%d)\n", 
+			 pMCR->NumberOfPackets,
+			 pMCR->ContextListHandle[0],
+			 0,
+			 pMCR->NumberOfPackets * sizeof(PacketContext_t)));
+  OS_SyncToDevice(pMCR->ContextListHandle[0],0,
+		  pMCR->NumberOfPackets * sizeof(PacketContext_t));
+
+  PushMCR(pDevice);
+
+#ifdef BLOCK 
+  /* Wait for all outstanding  to complete */
+    while ((Status=WaitForCompletion(pDevice,(UBS_UINT32)100000,UBSEC_CIPHER_LIST))
+	   == UBSEC_STATUS_SUCCESS);
+    if (Status!=UBSEC_STATUS_TIMEOUT) /* We are nested, return success */
+      Status=UBSEC_STATUS_SUCCESS;
+ Error_Return:
+#else
+
+ Error_Return:  /* Label to make sure that IRQs are enabled. */
+#ifdef COMPLETE_ON_COMMAND_THREAD
+    ubsec_PollDevice(pDevice);  /* Try to complete some & cut down on ints */
+#endif
+#endif
+    OS_LeaveCriticalSection(pDevice,SaveConfig);
+
+#ifdef UBSEC_STATS
+		if (Status != UBSEC_STATUS_SUCCESS)
+			pDevice->Statistics.CryptoFailedCount++;
+#endif
+   return(Status);
+}
+
+
+/*
+ * InitHMACState: Initialize the inner and outer state of the HMAC
+ *
+ * This is to allow it to be used for the authentication commands.
+ *
+ */
+ubsec_Status_t
+ubsec_InitHMACState(ubsec_HMAC_State_pt HMAC_State,
+		      ubsec_CipherCommand_t type,
+		      ubsec_HMAC_Key_pt Key)
+{
+  RTL_MemZero(HMAC_State,sizeof(*HMAC_State));
+  if (type==UBSEC_MAC_SHA1) {
+    InitSHA1State(HMAC_State,Key);
+    return(UBSEC_STATUS_SUCCESS);
+  }
+  else
+    if (type== UBSEC_MAC_MD5) {
+      InitMD5State(HMAC_State,Key);
+      return(UBSEC_STATUS_SUCCESS);
+    }
+return(UBSEC_STATUS_INVALID_PARAMETER);
+}
+
+
+
+
+
diff -urNp linux-8030/drivers/addon/bcm/ubscrypt.h linux-8040/drivers/addon/bcm/ubscrypt.h
--- linux-8030/drivers/addon/bcm/ubscrypt.h
+++ linux-8040/drivers/addon/bcm/ubscrypt.h
@@ -0,0 +1,550 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubscrypt.h:  This file contains all the structure definitions for the crypto 
+ * functions of the BCM58xx chip family.
+ * 
+ * This file was previously named ubs5501.h:
+ */ 
+
+/*
+ * Revision History:
+ *
+ * 09/xx/1999 SOR Created - ubs5501.h.
+ * 12/01/1999 DWP Modified to handle Big Endian devices.  Activating SRL for
+ *                Big Endian requires defining BIG_ENDIAN, rather than 
+ *                LITTLE_ENDIAN
+ * 12/03/1999 SOR Modifications to do all static address computations 
+ *                at init time
+ * 09/14/2000 SOR Added 5820 Support
+ * 09/14/2000 SOR Created register control file and this file.
+ * 04/03/2001 RJT Added support for CryptoNet device big-endian mode
+ * 07/16/2001 RJT Added support for BCM5821
+ * 10/04/2001 SRM 64bit port
+ */
+
+#ifndef _UBSCRYPT_H_
+#define _UBSCRYPT_H_
+
+/*
+ * Device specfic Data Structures.
+ *
+ * These structures are determined by the hardware.
+ * additional fields are added for simplicity.
+ *
+ * BCM - ubs5801 was previously the BSN-ubs5501.
+ * so both definitions may be used in this file.
+ */
+
+
+/*
+ * Packet Context Buffer structure
+ *
+ * 	Keeps the keys and instructions for a packet.
+ *
+ *	CryptoKeys		holds the keys for 3DES
+ *	HMACInnerState		pre-computed HMAC inner state
+ *	HMACOuterState		pre-computed HMAC outer state
+ *				(2x16bit for MD5, 2x20bit for SHA1)
+ *	ComputedIV		Crypto Initial Vector(from payload, if explicit)
+ *				Processing Control Flags:
+ *	reserved		reserved
+ *	uAuthentication		MD5/SHA1/None
+ *	Inbound		Inbound Packet
+ *	Crypto			3DES-CBC/None
+ *	CryptoOffset		Offset to skip authenticated but not encrypted
+ *				header words.  Goes to start of IV data, in
+ *				units of 32-bit words.
+ */
+typedef struct CipherContext_s {
+#ifdef UBSEC_582x_CLASS_DEVICE 
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE unsigned short       CryptoFlag;
+  VOLATILE unsigned short       CryptoOffset;
+#else
+  VOLATILE unsigned short       CryptoOffset;
+  VOLATILE unsigned short       CryptoFlag;
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+  VOLATILE UBS_UINT32	CryptoKey1[2];
+  VOLATILE UBS_UINT32	CryptoKey2[2];
+  VOLATILE UBS_UINT32	CryptoKey3[2];
+  VOLATILE UBS_UINT32	ComputedIV[2];
+  VOLATILE UBS_UINT32	HMACInnerState[5];
+  VOLATILE UBS_UINT32	HMACOuterState[5];
+#else /* UBSEC_580x */
+  VOLATILE UBS_UINT32	CryptoKey1[2];
+  VOLATILE UBS_UINT32	CryptoKey2[2];
+  VOLATILE UBS_UINT32	CryptoKey3[2];
+  VOLATILE UBS_UINT32	HMACInnerState[5];
+  VOLATILE UBS_UINT32	HMACOuterState[5];
+  VOLATILE UBS_UINT32	ComputedIV[2];
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE unsigned short       CryptoFlag;
+  VOLATILE unsigned short	CryptoOffset;
+#else
+  VOLATILE unsigned short	CryptoOffset;
+  VOLATILE unsigned short       CryptoFlag;
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+#endif /* 5820/21 conditional */
+}   CipherContext_t, *CipherContext_pt;
+
+/*
+ * CryptoFlag Settings
+ */
+/* #ifdef UBS_LITTLE_ENDIAN */
+#if (UBS_CPU_ATTRIBUTE == UBS_CRYPTONET_ATTRIBUTE)
+#define CF_ENCODE   0x0000
+#define CF_DECODE   0x4000
+#define CF_3DES     0x8000
+#define CF_MD5      0x1000
+#define CF_SHA1     0x2000
+#else
+#define CF_ENCODE   0x0000
+#define CF_DECODE   0x0040
+#define CF_3DES     0x0080
+#define CF_MD5      0x0010
+#define CF_SHA1     0x0020
+#endif
+
+#ifdef UBSEC_582x_CLASS_DEVICE  /* SSL/TLS/ARC4 are for BCM5820/21 only */
+
+/*
+ * SSL MD5/SHA1 context.
+ */
+#define SSL_HMAC_PAD_VALUE_LONG 0x3636363636363636
+#define SSL_HMAC_PAD_LENGTH_LONG 12
+
+#define SSL_MAC_PAD_VALUE_LONG 0x3636363636363636
+#define SSL_MAC_PAD_LENGTH_LONG 12
+
+typedef struct SSL_HMACContext_s {
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE unsigned short       CryptoFlag;
+  VOLATILE unsigned short	Reserved;
+#else
+  VOLATILE unsigned short	Reserved;
+  VOLATILE unsigned short       CryptoFlag;
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+  VOLATILE unsigned char	HMACKey[20];
+  VOLATILE unsigned char	HMACPad[48];
+  VOLATILE UBS_UINT32	SequenceHigh;
+  VOLATILE UBS_UINT32	SequenceLow;
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE UBS_UINT32	ReservedB : 8;
+  VOLATILE UBS_UINT32	DataLength : 16;
+  VOLATILE UBS_UINT32	ContentType : 8;
+#else
+  VOLATILE UBS_UINT32	ContentType : 8;
+  VOLATILE UBS_UINT32	DataLength : 16;
+  VOLATILE UBS_UINT32	ReservedB : 8;
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+}   SSL_HMACContext_t, *SSL_HMACContext_pt, SSL_MACContext_t, *SSL_MACContext_pt;
+
+/* TLS HMAC Context */
+typedef struct TLS_HMACContext_s {
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE unsigned short       CryptoFlag;
+  VOLATILE unsigned short	Reserved;
+#else
+  VOLATILE unsigned short	Reserved;
+  VOLATILE unsigned short       CryptoFlag;
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+  VOLATILE UBS_UINT32	HMACInnerState[5];
+  VOLATILE UBS_UINT32	HMACOuterState[5];
+  VOLATILE UBS_UINT32	SequenceHigh;
+  VOLATILE UBS_UINT32	SequenceLow;
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE UBS_UINT32	DataLengthHi:8;
+  VOLATILE UBS_UINT32	Version:16;
+  VOLATILE UBS_UINT32	ContentType:8;
+  VOLATILE UBS_UINT32	ReservedG2:24;
+  VOLATILE UBS_UINT32	DataLengthLo:8;
+#else
+  VOLATILE UBS_UINT32	ContentType:8;
+  VOLATILE UBS_UINT32	Version:16;
+  VOLATILE UBS_UINT32	DataLengthHi:8;
+  VOLATILE UBS_UINT32	DataLengthLo:8;
+  VOLATILE UBS_UINT32	ReservedG2:24;
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+}   TLS_HMACContext_t, *TLS_HMACContext_pt;
+
+/* SSL/TLS DES Context */
+typedef struct SSL_CryptoContext_s {
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE unsigned short       CryptoFlag;
+  VOLATILE unsigned short	Reserved;
+#else
+  VOLATILE unsigned short	Reserved;
+  VOLATILE unsigned short       CryptoFlag;
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+  VOLATILE UBS_UINT32	CryptoKey1[2];
+  VOLATILE UBS_UINT32	CryptoKey2[2];
+  VOLATILE UBS_UINT32	CryptoKey3[2];
+  VOLATILE UBS_UINT32	ComputedIV[2];
+}   SSL_CryptoContext_t, *SSL_CryptoContext_pt;
+
+/* ARC4  DES Context */
+
+
+typedef struct ARC4_CryptoContext_s {
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE unsigned short StateInfo;
+  VOLATILE unsigned short Reserved;
+#else
+  VOLATILE unsigned short Reserved;
+  VOLATILE unsigned short StateInfo;
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+  VOLATILE unsigned char KeyState[UBSEC_ARC4_KEYSTATE_BYTES];
+}   ARC4_CryptoContext_t, *ARC4_CryptoContext_pt;
+
+
+/* Bit field definitions for state Information  */
+#if (UBS_CPU_ATTRIBUTE == UBS_CRYPTONET_ATTRIBUTE)
+#define ARC4_STATE_NULL_DATA   0x1000
+#define ARC4_STATE_WRITEBACK   0x0800
+#define ARC4_STATE_STATEKEY    0x0400
+#else
+#define ARC4_STATE_NULL_DATA   0x0010
+#define ARC4_STATE_WRITEBACK   0x0008
+#define ARC4_STATE_STATEKEY    0x0004
+#endif
+
+
+/* Pure Hash Context */
+typedef struct Hash_Context_s {
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE unsigned short CryptoFlag;
+  VOLATILE unsigned short Reserved; 
+#else
+  VOLATILE unsigned short Reserved; 
+  VOLATILE unsigned short CryptoFlag;
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+}   Hash_Context_t, *Hash_Context_pt;
+
+#endif /* UBSEC_582x_CLASS_DEVICE */
+
+/*
+ * Generic union to encompass all cipher context types
+ */
+
+typedef union CryptoContext_u {
+  CipherContext_t Cipher;
+#ifdef UBSEC_582x_CLASS_DEVICE
+  SSL_HMACContext_t SSL_Mac;
+  TLS_HMACContext_t TLS_HMac;
+  SSL_CryptoContext_t SSL_Crypto;
+  ARC4_CryptoContext_t ARC4_Crypto;
+  Hash_Context_t Hash;
+#endif
+}   CryptoContext_t, *CryptoContext_pt;
+
+typedef struct PacketContextUnaligned_s {
+#ifdef UBSEC_582x_CLASS_DEVICE
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE unsigned short cmd_structure_length;
+  VOLATILE unsigned short operation_type; 
+#else
+  VOLATILE unsigned short operation_type; 
+  VOLATILE unsigned short cmd_structure_length;
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+#endif /* UBSEC_582x_CLASS_DEVICE */
+  VOLATILE CryptoContext_t Context;
+  VOLATILE UBS_UINT32  PhysicalAddress;
+} PacketContextUnaligned_t;
+
+
+#define PKTCONTEXT_ALIGNMENT 64 /* Boundary to which PacketContexts will be aligned. Must be power of 2 */
+
+#if (SYS_CACHELINE_SIZE >= PKTCONTEXT_ALIGNMENT) 
+  #define PKTCONTEXT_ALIGNMENT_PAD (PKTCONTEXT_ALIGNMENT - (sizeof(PacketContextUnaligned_t) & (PKTCONTEXT_ALIGNMENT-1)))
+#else
+  #undef PKTCONTEXT_ALIGNMENT_PAD
+#endif
+
+/***********************************************************************/
+/* Hardware (DMA) version of above structure that is cacheline sized   */
+/* (an integer multiple of SYS_CACHELINE_SIZE bytes in length).        */
+/* Any changes made to either structure must be mirrored in the other  */
+/***********************************************************************/
+
+typedef struct PacketContext_s {
+#ifdef UBSEC_582x_CLASS_DEVICE
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE unsigned short cmd_structure_length;
+  VOLATILE unsigned short operation_type; 
+#else
+  VOLATILE unsigned short operation_type; 
+  VOLATILE unsigned short cmd_structure_length;
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+#endif /* 582x conditional */
+  VOLATILE CryptoContext_t Context;
+  VOLATILE UBS_UINT32  PhysicalAddress;
+#if (SYS_CACHELINE_SIZE >= PKTCONTEXT_ALIGNMENT) 
+  /***********************************************************************/
+  /**** If PacketContextUnaligned_t is cacheline sized, the following ****/
+  /**** pad array will have a subscript of zero. Under this condition ****/
+  /**** the following line should be commented out.                   ****/ 
+  unsigned char pad[PKTCONTEXT_ALIGNMENT_PAD];                        /***/
+  /***********************************************************************/
+#endif
+} PacketContext_t,*PacketContext_pt;
+
+/* Size of command fields. */
+#define CIPHER_CONTEXT_SIZE (sizeof(CipherContext_t)+4) 
+#define SSLMAC_CONTEXT_SIZE (sizeof(SSL_MACContext_t)+4)
+#define SSLCRYPTO_CONTEXT_SIZE (sizeof(SSL_CryptoContext_t)+4) 
+#define TLSHMAC_CONTEXT_SIZE (sizeof(TLS_HMACContext_t)+4) 
+#define ARC4_CONTEXT_SIZE (sizeof(ARC4_CryptoContext_t)+4)
+#define HASH_CONTEXT_SIZE (sizeof(Hash_Context_t)+4)
+
+/*
+ * Crypto operation types.
+ */
+/* #ifdef UBS_LITTLE_ENDIAN */
+#if (UBS_CPU_ATTRIBUTE == UBS_CRYPTONET_ATTRIBUTE)
+#define OPERATION_IPSEC      0x0000
+#define OPERATION_SSL_HMAC   0x0001
+#define OPERATION_SSL_MAC    0x0001
+#define OPERATION_TLS_HMAC   0x0002
+#define OPERATION_SSL_CRYPTO 0x0003
+#define OPERATION_ARC4       0x0004
+#define OPERATION_HASH       0x0005
+#else
+#define OPERATION_IPSEC      0x0000
+#define OPERATION_SSL_HMAC   0x0100
+#define OPERATION_SSL_MAC    0x0100
+#define OPERATION_TLS_HMAC   0x0200
+#define OPERATION_SSL_CRYPTO 0x0300
+#define OPERATION_ARC4       0x0400
+#define OPERATION_HASH       0x0500
+#endif
+
+#define NULL_PACKET_CONTEXT (PacketContext_pt) 0
+
+
+
+/*--------------------------------------------------------------------------
+ * Data Buffer Chain element
+ *
+ *	An element in the linked list of data buffers that makes up a 
+ *	Packet
+ *
+ *	DataAddress				pointer to this buffer's data
+ *	pNext					pointer to the next element
+ *	DataLength				size in bytes of this element
+ *	Reserved				reserved
+ */
+
+typedef struct DataBufChain_s	{
+  VOLATILE UBS_UINT32 	DataAddress;           /* Physical address. */
+  VOLATILE UBS_UINT32	pNext;  /* Physical address. */
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE unsigned short  DataLength;
+  VOLATILE unsigned short  Reserved;
+#else
+  VOLATILE unsigned short  Reserved;
+  VOLATILE unsigned short  DataLength;
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+} DataBufChain_t, *DataBufChain_pt;
+
+/* This is the same structure as above but with
+   a physical address location for efficiency */
+typedef struct DataBufChainList_s	{
+  VOLATILE UBS_UINT32 	DataAddress;           /* Physical address. */
+  VOLATILE UBS_UINT32	pNext;  /* Physical address. */
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE unsigned short  DataLength;
+  VOLATILE unsigned short  Reserved;
+#else
+  VOLATILE unsigned short  Reserved;
+  VOLATILE unsigned short  DataLength;
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+  VOLATILE UBS_UINT32 PhysicalAddress;
+} DataBufChainList_t, *DataBufChainList_pt;
+
+#define NULL_DATA_CHAIN ((DataBufChainList_pt) 0)
+
+/*
+ * Packet
+ */
+typedef struct Packet_s {
+	 VOLATILE UBS_UINT32      PacketContextBuffer;
+	 VOLATILE DataBufChain_t     InputHead;
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+	 VOLATILE unsigned short     Reserved;
+	 VOLATILE unsigned short     PacketLength;
+#else
+	 VOLATILE unsigned short     PacketLength;
+	 VOLATILE unsigned short     Reserved;
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+	 VOLATILE DataBufChain_t     OutputHead;
+	} Packet_t, *Packet_pt;
+
+/*
+ * Master Command Record structure
+ *
+ * 	The master command record is the structure that gets passed
+ *	to the chip.  
+ *
+ *	NumberOfPackets	number of packets in this MCR
+ *	Flags			completion status from chip
+ *	PacketArray		array of packet structures
+ */
+
+typedef struct CallBackInfo_s {
+  void(*CompletionCallback)(unsigned long Context,ubsec_Status_t Result);
+  unsigned long	   		 CommandContext;
+  }   CallBackInfo_t, *CallBackInfo_pt;
+
+#if (UBS_CPU_ATTRIBUTE == UBS_CRYPTONET_ATTRIBUTE)
+#define MCR_FLAG_COMPLETION    0x0001		/* bit [0] indicates done */
+#define MCR_INTERRUPT_SUPPRESS 0x8000		/* bit [15] suppresses interrupt for 5821 MCR */
+#else
+#define MCR_FLAG_COMPLETION 0xff00		/* bit [8] indicates done */
+#define MCR_INTERRUPT_SUPPRESS 0x0080		/* bit [7] suppresses interrupt for 5821 MCR */
+#endif
+
+/* MCR_DMA_MEM_OFFSET forces the PacketArray list to start on a 32-byte boundary.  */
+/* This assumes that each MCR is aligned to at least a 32-byte boundary. That      */
+/* means that OS_AllocateDMAMemory() must return physical memory aligned to        */
+/* at least 32-byte boundaries (32, 64, 96 etc.) as defined by SYS_CACHELINE_SIZE. */
+#if (SYS_CACHELINE_SIZE && !(SYS_CACHELINE_SIZE & 0x1F)) 
+  #define MCR_DMA_MEM_OFFSET (sizeof(Packet_t) - 2*sizeof(unsigned short)) 
+#else
+  #define MCR_DMA_MEM_OFFSET 0
+#endif
+
+typedef struct MasterCommandUnaligned_s {
+#if (SYS_CACHELINE_SIZE && !(SYS_CACHELINE_SIZE & 0x1F)) 
+  unsigned char dma_pad[MCR_DMA_MEM_OFFSET];
+#endif
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE unsigned short	NumberOfPackets;
+  VOLATILE unsigned short	Flags;
+#else
+  VOLATILE unsigned short	Flags;
+  VOLATILE unsigned short	NumberOfPackets;
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+  VOLATILE Packet_t	PacketArray[MCR_MAXIMUM_PACKETS];
+	  /*
+	   * The following fields are not part of the MCR but are present here
+	   * for easy access. 
+	   */
+  OS_MemHandle_t MCRMemHandle; /* Memory handle to use for current MCR */
+  UBS_UINT32 MCRMemHandleOffset; /* Used with handle for OS_SyncTo calls */
+  VOLATILE CallBackInfo_t CompletionArray[MCR_MAXIMUM_PACKETS];
+  VOLATILE PacketContext_t  *ContextList;
+  VOLATILE KeyContext_t  *KeyContextList[MCR_MAXIMUM_PACKETS];
+  OS_MemHandle_t  ContextListHandle[MCR_MAXIMUM_PACKETS];
+#ifdef STATIC_F_LIST
+  VOLATILE DataBufChainList_t  InputFragmentList[MCR_MAXIMUM_PACKETS*UBSEC_MAX_FRAGMENTS];
+  VOLATILE DataBufChainList_t  OutputFragmentList[MCR_MAXIMUM_PACKETS*UBSEC_MAX_FRAGMENTS];
+#else
+  VOLATILE DataBufChainList_t  *InputFragmentList;
+  VOLATILE DataBufChainList_t  *OutputFragmentList;
+  OS_MemHandle_t InputFragmentListHandle;
+  OS_MemHandle_t OutputFragmentListHandle;
+#endif
+  VOLATILE UBS_UINT32 MCRPhysicalAddress;
+  VOLATILE UBS_UINT32 MCRState;
+  VOLATILE struct MasterCommand_s *pNextMCR; /* Pointer to next in list. */
+  UBS_UINT32 Index;
+} MasterCommandUnaligned_t;
+
+#define MCR_ALIGNMENT 32 /* Boundary to which MCRs will be aligned. Must be power of 2 */
+
+#if (SYS_CACHELINE_SIZE >= MCR_ALIGNMENT) 
+  #define MCR_ALIGNMENT_PAD (MCR_ALIGNMENT - (sizeof(MasterCommandUnaligned_t) & (MCR_ALIGNMENT-1)))
+#else
+  #undef MCR_ALIGNMENT_PAD 
+#endif
+
+/***********************************************************************/
+/* Hardware (DMA) version of above structure that is 'alignably' sized */
+/* (an integer multiple of 32 bytes in length).                        */
+/* Any changes made to either structure must be mirrored in the other  */
+/***********************************************************************/
+
+typedef struct MasterCommand_s {
+#if (SYS_CACHELINE_SIZE && !(SYS_CACHELINE_SIZE & 0x3)) 
+  unsigned char dma_pad[MCR_DMA_MEM_OFFSET];
+#endif
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE unsigned short	NumberOfPackets;
+  VOLATILE unsigned short	Flags;
+#else
+  VOLATILE unsigned short	Flags;
+  VOLATILE unsigned short	NumberOfPackets;
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+  VOLATILE Packet_t	PacketArray[MCR_MAXIMUM_PACKETS];
+	  /*
+	   * The following fields are not part of the MCR but are present here
+	   * for easy access. 
+	   */
+  OS_MemHandle_t MCRMemHandle; /* Memory handle to use for current MCR */
+  UBS_UINT32 MCRMemHandleOffset; /* Used with handle for OS_SyncTo calls */
+  VOLATILE CallBackInfo_t CompletionArray[MCR_MAXIMUM_PACKETS];
+  VOLATILE PacketContext_t  *ContextList;
+  VOLATILE KeyContext_t  *KeyContextList[MCR_MAXIMUM_PACKETS];
+  OS_MemHandle_t  ContextListHandle[MCR_MAXIMUM_PACKETS];
+#ifdef STATIC_F_LIST
+  VOLATILE DataBufChainList_t  InputFragmentList[MCR_MAXIMUM_PACKETS*UBSEC_MAX_FRAGMENTS];
+  VOLATILE DataBufChainList_t  OutputFragmentList[MCR_MAXIMUM_PACKETS*UBSEC_MAX_FRAGMENTS];
+#else
+  VOLATILE DataBufChainList_t  *InputFragmentList;
+  VOLATILE DataBufChainList_t  *OutputFragmentList;
+  OS_MemHandle_t InputFragmentListHandle;
+  OS_MemHandle_t OutputFragmentListHandle;
+#endif
+  VOLATILE UBS_UINT32 MCRPhysicalAddress;
+  VOLATILE UBS_UINT32 MCRState;
+  VOLATILE struct MasterCommand_s *pNextMCR; /* Pointer to next in list. */
+  UBS_UINT32 Index;
+#if (SYS_CACHELINE_SIZE >= MCR_ALIGNMENT) 
+  /***********************************************************************/
+  /**** If sizeof(MasterCommandUnaligned_t)%32 is zero, the following ****/
+  /**** pad array will have a subscript of zero. Under this condition ****/
+  /**** the following line should be commented out.                   ****/ 
+  unsigned char pad[MCR_ALIGNMENT_PAD];                                /**/
+  /***********************************************************************/
+#endif
+} MasterCommand_t, *MasterCommand_pt;
+
+#define NULL_MASTER_COMMAND (MasterCommand_pt) 0
+
+#define MCR_STATE_FREE   0x00 /* Not in use. */
+#define MCR_STATE_ACTIVE   0x01 /* Packets in the MCR. */
+#define MCR_STATE_PUSHED 0x02 /* Pushed onto device. */
+
+#define UBSEC_IS_SSL_DEVICE(pDevice) ( (pDevice->DeviceID==BROADCOM_DEVICE_ID_5820) || \
+(pDevice->DeviceID==BROADCOM_DEVICE_ID_5821) || \
+(pDevice->DeviceID==BROADCOM_DEVICE_ID_5822) )
+
+#endif /*  _UBSCRYPT_H_ */
+
+
+
+
+
diff -urNp linux-8030/drivers/addon/bcm/ubsctl.h linux-8040/drivers/addon/bcm/ubsctl.h
--- linux-8030/drivers/addon/bcm/ubsctl.h
+++ linux-8040/drivers/addon/bcm/ubsctl.h
@@ -0,0 +1,276 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubsctl.c: Ubsec device control macro definitions.
+ */
+
+/*
+ * Revision History:
+ *
+ * 09/15/2000 SOR Created.
+ * 07/16/2001 RJT Added support for BCM5821
+ */
+
+#ifndef _UBSCTL_H_
+#define _UBSCTL_H_
+
+enum ubsDmaRegistersNumber_e {
+       	dmaMCR1=0,
+	dmaControl,
+	dmaStatus,
+	dmaError,
+	dmaMCR2
+};
+
+
+/*
+ *
+ * UBSEC PCI configuration space values
+ *
+ */
+
+/*
+ * DMA Control and Status Registers (32 bits each index)
+ */
+#define  MCR_ADDRESS  		0x0
+/*  Writing the address of a valid Master Command Record to this
+	//	register causes processing of the packtes within that record
+	//	to begin.  This register must only be written when the
+	//	'MCR1_FULL' bit of the DMA Status register is '0'.
+*/
+#define DMA_CONTROL			0x1
+#if (UBS_CPU_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+#define UBSEC_RESET		0x80000000
+#define MCR2INT_ENABLE		0x40000000
+#define MCR1INT_ENABLE		0x20000000
+#define OUTPUT_FRAG_MODE	0x10000000
+#define UBS_LITTLE_ENDIAN_MODE	0x0C000000  /* (do both bits at once) */
+#define UBS_BIG_ENDIAN_MODE	0x04000000  /* (do both bits at once) */
+#define DMAERR_ENABLE		0x02000000
+#define RNG_MODE_16		0x01800000
+#define RNG_MODE_08		0x01000000
+#define RNG_MODE_04		0x00800000
+#define RNG_MODE_01		0x00000000
+#define SW_NORM_EN              0x00400000
+#else
+#define UBSEC_RESET		0x00000080
+#define MCR2INT_ENABLE		0x00000040
+#define MCR1INT_ENABLE		0x00000020
+#define OUTPUT_FRAG_MODE	0x00000010
+#define UBS_LITTLE_ENDIAN_MODE	0x0000000C  /* (do both bits at once) */
+#define UBS_BIG_ENDIAN_MODE	0x00000004  /* (do both bits at once) */
+#define DMAERR_ENABLE		0x00000002
+#define RNG_MODE_16		0x00008001
+#define RNG_MODE_08		0x00000001
+#define RNG_MODE_04		0x00008000
+#define RNG_MODE_01		0x00000000
+#define SW_NORM_EN              0x00004000 
+
+#endif
+/*  bits	    purpose
+//  MCRnINT_ENABLE --           Enable MCR completion interrupt (def=0)
+//  Output Fragment Mode --    '0' means get output fragment
+//				size from data buffer length entry
+//				'1' means get output fragment size from
+//				low order bits of this register (def=0)
+//  UBS_X_ENDIAN_MODE fields are comprised of the following two bits:
+//  LE_CRYPTONET --             Little endian mode, 32-bit words.  '0' means
+//				big endian data in DMA memory.  '1' means little
+//				endian data in DMA memory. Must be set to '1' for
+//                              BCM580x and BCM5820 devices (def=1).
+//  NORMAL_PCI --               '0' means all PCI bus master data will be
+//                              internally swapped by the CryptoNet chip.
+//				'1' means industry standard PCI bus endianess.
+//				Must be set to '1' for BCM580x and BCM5820 
+//                              devices. Normally set to '1' (def=1).
+//  DMAERR_ENABLE --            Enable DMA Error interrupt (def=0)
+//  Output Fragment Size --     The size, in bytes of output
+//				fragments.  Only used if Output Frag
+//				Mode is enabled.
+*/
+#define DMA_STATUS			0x2
+#if (UBS_CPU_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+#define MCR_BUSY			0x80000000
+#define MCR1_FULL			0x40000000
+#define MCR1_DONE			0x20000000
+#define DMA_ERROR			0x10000000
+#define MCR2_FULL			0x08000000
+#define MCR2_DONE			0x04000000
+#define MCR1_ALL_EMPTY			0x02000000
+#define MCR2_ALL_EMPTY			0x01000000
+#else
+#define MCR_BUSY			0x00000080
+#define MCR1_FULL			0x00000040
+#define MCR1_DONE			0x00000020
+#define DMA_ERROR			0x00000010
+#define MCR2_FULL			0x00000008
+#define MCR2_DONE			0x00000004
+#define MCR1_ALL_EMPTY			0x00000002
+#define MCR2_ALL_EMPTY			0x00000001
+#endif
+/*  bits	purpose
+//  MCR_BUSY --	        If set, master access is in progress.
+//  MCRn_FULL --        MCRn Address register is full.  When
+//			'1', do not write to MCRn Address reg.
+//  MCRn_DONE -- 	Completion status of MCRn.  This bit is
+//			set regardless of the MCRnINT_EN completion
+//			interrupt enable bit.  This bit is 
+//			sticky, and is reset to zero by writing
+//			a '1'.
+//  DMA_ERROR --	DMA Error status.  This bit is set
+//			regardless of the DMAERR_EN interrupt
+//			enable bit.  This bit is sticky, and is
+//			reset to zero by writing a '1'.
+//  MCRn_ALL_EMPTY -- 	If set, indicates that chip completed all
+//                      MCRs that were written to MCRn, i.e. there
+//                      are no pending operations. This bit is
+//			set regardless of the MCRnINT_EN completion
+//			interrupt enable bit.  This bit is 
+//			sticky, and is reset to zero by writing
+//			a '1' to either the MCRn_ALL_EMPTY bit
+//                      or to the associated MCRn_DONE bit.
+*/
+#define  DMA_ERROR_ADDRESS      0x3
+/*  bits	purpose
+//  2-31	Address of master access that resulted in a PCI fault.
+//		The address points to a 32bit word.
+//  1		1 = fault on a read.  0 = fault on a write.
+*/
+
+
+/*
+ * Number of device registers
+ */
+#define UBSEC_CRYPTO_DEVICE_REGISTERS 4
+#define UBSEC_KEY_DEVICE_REGISTERS 5
+
+#ifdef  UBSEC_PKEY_SUPPORT
+#define UBSEC_MAXREGISTERS 5
+#else
+#define UBSEC_MAXREGISTERS 4
+#endif
+
+/*
+ * Interrupt ack/enable masks. Different for each class of device.
+ */
+#define UBSEC_CRYPTO_DEVICE_IENABLE_MASK (MCR1INT_ENABLE | DMAERR_ENABLE)
+#define UBSEC_CRYPTO_DEVICE_IACK_MASK    (MCR1_DONE | DMA_ERROR)
+#define UBSEC_KEY_DEVICE_IENABLE_MASK (MCR1INT_ENABLE | MCR2INT_ENABLE | DMAERR_ENABLE)
+#define UBSEC_KEY_DEVICE_IACK_MASK    (MCR1_DONE | MCR2_DONE | DMA_ERROR) 
+
+/*
+ * Read configuration control register
+ */
+#define UBSEC_READ_CONFIG(pDevice)  \
+  OS_IOMemRead32(pDevice->ControlReg[dmaControl])
+
+/*
+ * Write configuration control register. Because we share interrupts with another device and
+ * there is no way to stop the int mask we need to set the interrupt enable status
+ * accordingly
+ */
+#define UBSEC_WRITE_CONFIG(pDevice,value)  			   \
+  { pDevice->IRQEnabled=((value) & (pDevice->IntEnableMask)); \
+    OS_IOMemWrite32(pDevice->ControlReg[dmaControl],value); }
+
+
+#define UBSEC_IRQ_ENABLED(pDevice) \
+           ((UBSEC_READ_CONFIG(pDevice) & pDevice->IntEnableMask) != 0)
+
+/*
+ * Reset the security accelerator hardware (chip). 
+ */
+#define UBSEC_RESET_DEVICE(pDevice) \
+  { UBSEC_WRITE_CONFIG(pDevice,(UBSEC_READ_CONFIG(pDevice) | UBSEC_RESET));     \
+    OS_Waitus(100000);                                                          \
+    UBSEC_WRITE_CONFIG(pDevice,pDevice->ResetConfig); }
+
+/*
+ * Enable device interrupts. 
+ */
+#define UBSEC_ENABLE_INT(pDevice) \
+  UBSEC_WRITE_CONFIG(pDevice,(UBSEC_READ_CONFIG(pDevice) | (pDevice->IntEnableMask)))
+
+/*
+ * Disable device interrupts. Because we share interrupts with another device and
+ * there is no way to stop the int mask we need to set the interrupt enable status
+ * accordingly
+ */
+#define UBSEC_DISABLE_INT(pDevice)\
+  UBSEC_WRITE_CONFIG(pDevice,(UBSEC_READ_CONFIG(pDevice)&~(pDevice->IntEnableMask))) 
+
+
+/*
+ * Acknowledge device status
+ */
+#define UBSEC_ACK_INT(pDevice)\
+OS_IOMemWrite32(pDevice->ControlReg[dmaStatus],OS_IOMemRead32(pDevice->ControlReg[dmaStatus]) & (pDevice->IntAckMask)) 
+
+
+/*
+ * Hardware marker (for logic analyzer), used for code profiling
+ */
+#ifdef UBSEC_HW_PROFILE_MARKER_ENABLE
+#define UBSEC_HW_PROFILE_MARKER(pDevice,marker) OS_IOMemWrite32(pDevice->ControlReg[dmaError],marker) 
+#else
+#define UBSEC_HW_PROFILE_MARKER(pDevice,marker) 
+#endif
+
+
+/*
+ * Macro that determines whether or not external byteswap hardware is in use.
+ * This condition is inferred when the CryptoNet chip is configured for an  
+ * endianess mode that is different from that defined by UBS_CRYPTONET_ATTRIBUTE.
+ * CryptoNet endianess is determined by the state of the UBS_LITTLE_ENDIAN_MODE 
+ * bits in the CryptoNet DMA_CONTROL register. This macro is used in ubstest.c
+ */
+#define UBSEC_EXTERNAL_BYTESWAP_HW(pDevice) \
+(((UBS_CRYPTONET_ATTRIBUTE == UBS_BIG_ENDIAN) && ((pDevice->ResetConfig & UBS_LITTLE_ENDIAN_MODE) == UBS_LITTLE_ENDIAN_MODE)) || \
+ ((UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN) && ((pDevice->ResetConfig & UBS_LITTLE_ENDIAN_MODE) == UBS_BIG_ENDIAN_MODE)) )
+
+
+
+/*
+ * Acknowledge device status
+ */
+#define UBSEC_ACK_CONDITION(pDevice,Condition)\
+OS_IOMemWrite32(pDevice->ControlReg[dmaStatus],OS_IOMemRead32(pDevice->ControlReg[dmaStatus]) & (Condition))
+
+/*
+ * Read device status
+ */
+#define UBSEC_READ_STATUS(pDevice) \
+  OS_IOMemRead32(pDevice->ControlReg[dmaStatus])
+
+/*
+ * Write MCR address to device.
+ */
+#define UBSEC_WRITE_MCR(pDevice,pMCR,ListIndex) \
+  OS_IOMemWrite32(pDevice->ControlReg[(ListIndex) ? dmaMCR2 : dmaMCR1 ],pMCR->MCRPhysicalAddress);
+
+
+#endif /*  _UBSCTL_H_ */
+
+
diff -urNp linux-8030/drivers/addon/bcm/ubsdebug.h linux-8040/drivers/addon/bcm/ubsdebug.h
--- linux-8030/drivers/addon/bcm/ubsdebug.h
+++ linux-8040/drivers/addon/bcm/ubsdebug.h
@@ -0,0 +1,134 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubsdebug.h: Ubsec debug helper routines
+ */
+
+/*
+ * Revision History:
+ *
+ * 09/xx/99 SOR Created.
+ */
+
+/*
+ * Debug.h: Macros associated with debug.
+ */
+
+#ifndef _UBSDEBUG_H_
+#define _UBSDEBUG_H_
+
+#ifdef  UBSDBG
+
+#ifndef Dbg_Test
+
+#define Dbg_Test(class)           \
+	((Dbg_PrintEnabled & (class))==class)
+#endif /* Dbg_Test */
+
+#ifndef Dbg_Print
+
+#define  Dbg_Print(class, x)                    \
+  do  {                                         \
+    if ((Dbg_PrintEnabled & (class))==class) 			\
+      DbgPrint (x);                               \
+  } while (0)
+#endif /* Dbg_Print */
+
+#ifndef Dbg_Call
+#define  Dbg_Call(class, function)        		 \
+  {                                             \
+    if ((Dbg_PrintEnabled & (class))==class) 			\
+      function;                                 \
+  }
+#endif /* Dbg_call */
+
+#ifndef ASSERT
+#define  ASSERT(x)  \
+      DbgPrint(DBG_FATAL,("Assert \"%s\" failed, file %s, line %d.\n",  \
+               #x, __FILE__, __LINE__));  
+
+#endif /* ASSERT */
+#else /* UBSDBG */
+
+#ifndef Dbg_Test
+#define Dbg_Test(class) 0
+#endif /* Dbg_Test */
+
+#ifndef Dbg_Print
+#define  Dbg_Print(class, x)
+#endif /* Dbg_Print  */
+
+#ifndef Dbg_Call
+#define	 Dbg_Call(class, function)
+#endif /*  Dbg_Call */
+
+#ifndef ASSERT
+#define  ASSERT(x)
+#endif /* ASSERT */
+
+#endif
+
+/*
+ * Classes for the Dbg_Print macro.
+ */
+#define DBG_ALL	   	0xffffffff
+#define	DBG_INIT   	0x00000001 /* debug initialization stuff */
+#define	DBG_CMD_FAIL   	0x00000002 /* Debug command failures */
+#define	DBG_MD5   	0x00000004 /* Debug MD5 Code */
+#define	DBG_SHA1   	0x00000008 /* Debug SHA1 Code */
+#define	DBG_FATAL   	0x00000010 /* Debug FATAL conditions */
+#define	DBG_VERSION   	0x00000020 /* Debug Version control */
+#define DBG_CMD        (0x00000040+DBG_CMD_FAIL) /* Command failure */
+#define	DBG_IRQ   	0x00000080 /* Debug IRQ */
+#define	DBG_DHKEY   	0x00000200 /* Debug DH  KEY */
+#define DBG_PACKET      0x00000400 /* Debug packet processing. */
+#define DBG_NORM        0x00000800 /* Debug Normalization routines. */
+#define	DBG_RSAKEY   	0x00001000 /* Debug RSA  KEY */
+#define	DBG_DSAKEY   	0x00002000 /* Debug DSA  KEY */
+#define	DBG_TEST   	0x00004000 /* Debug SelfTest  KEY */
+#define DBG_MATH        0x00008000 /* MATH function debug. */
+#define DBG_RNG         0x00010000 /* Random Number function debug. */
+#define DBG_RESET       0x00020000 /* Indicate Device Reset event */
+#define DBG_LOG         0x00040000 /* Log messages */
+#define DBG_INITD       0x00080000 /* Init device */
+#define	DBG_INITS_LIST 	0x00100000 /* debug initialization list structure  stuff */
+#define DBG_MCR_SYNC    0x00200000 /* CPU <-> DMA MCR synchronization events */
+#define DBG_CNTXT_SYNC  0x00400000 /* Context synchronization events */
+#define DBG_FRAG_SYNC   0x00800000 /* Frag descr synchronization events */
+#define DBG_SYNC        (DBG_MCR_SYNC | DBG_CNTXT_SYNC | DBG_FRAG_SYNC)
+#define	DBG_INITS 	(DBG_INITD | DBG_INITS_LIST)
+#define	DBG_KEY   	(DBG_DHKEY | DBG_RSAKEY | DBG_DSAKEY)
+#define DBG_LEVEL  	(DBG_FATAL | DBG_CMD_FAIL)  
+
+#ifndef Dbg_PrintEnabled 
+#define Dbg_PrintEnabled DBG_LEVEL
+#endif /* Dbg_PrintEnabled */
+
+
+/* When defined, enables the UBSEC_HW_PROFILE_MARKER macro (in ubsctl.h) */
+#undef UBSEC_HW_PROFILE_MARKER_ENABLE
+
+#endif /* _UBSDEBUG_H_ */
+
diff -urNp linux-8030/drivers/addon/bcm/ubsdefs.h linux-8040/drivers/addon/bcm/ubsdefs.h
--- linux-8030/drivers/addon/bcm/ubsdefs.h
+++ linux-8040/drivers/addon/bcm/ubsdefs.h
@@ -0,0 +1,153 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubsdefs.h:  Compilation definitions
+ */
+
+/*
+ * Revision History:
+ *
+ * 09/xx/99 SOR Created.
+ * 07/06/2000 DPA Fixes for SMP operation
+ * 04/03/2001 RJT Added support for CryptoNet device big-endian mode
+ * 07/16/2001 RJT Added support for BCM5821
+ */
+
+#ifndef _UBSDEFS_H_
+#define _UBSDEFS_H_
+
+/**** Constants Definitions ****/
+#define UBS_LITTLE_ENDIAN 1
+#define UBS_BIG_ENDIAN    2
+/*******************************/
+
+/* To allow Makefile to override endianess settings with compiler switches */
+#if defined(UBS_CPU_LITTLE_ENDIAN)       
+  #define UBS_CPU_ATTRIBUTE         UBS_LITTLE_ENDIAN
+#elif defined(UBS_CPU_BIG_ENDIAN) 
+  #define UBS_CPU_ATTRIBUTE         UBS_BIG_ENDIAN
+#else
+  #define UBS_CPU_ATTRIBUTE         UBS_LITTLE_ENDIAN  /* Default CPU endianess */
+#endif
+
+#if defined(UBS_CRYPTONET_LITTLE_ENDIAN) 
+  #define UBS_CRYPTONET_ATTRIBUTE   UBS_LITTLE_ENDIAN
+#elif defined(UBS_CRYPTONET_BIG_ENDIAN)
+  #define UBS_CRYPTONET_ATTRIBUTE   UBS_BIG_ENDIAN
+#else
+  #define UBS_CRYPTONET_ATTRIBUTE   UBS_LITTLE_ENDIAN  /* Default CryptoNet endianess */
+#endif
+
+/* Use polling for completion instead of irq */
+#undef POLL 
+
+/* Block on completion of a single MCR request. */
+#undef BLOCK
+
+#ifdef BLOCK
+  #ifndef POLL
+    #define POLL
+  #endif
+#endif
+
+/*
+ * Operational definitions.
+ * UBSEC_5xxx (Chip Type) is defined on the compiler command line (see Makefile)
+ */
+#if defined(UBSEC_5820)
+  #define UBSEC_582x_CLASS_DEVICE
+  #define MCR_MAXIMUM_PACKETS 4 /* For key performance */
+#elif defined(UBSEC_582x)
+  #define UBSEC_582x_CLASS_DEVICE
+  #define MCR_MAXIMUM_PACKETS 4 /* For key performance */
+#else
+  #undef UBSEC_582x_CLASS_DEVICE
+  #define MCR_MAXIMUM_PACKETS 8 /* For key performance */
+#endif
+
+#define UBSEC_MAX_FRAGMENTS 20 
+
+#ifndef COMPLETE_ON_COMMAND_THREAD /* To allow Makefile to override. */
+  #undef COMPLETE_ON_COMMAND_THREAD		/* allows SRL to attempt to complete requests in same thread as command */
+#endif
+
+#define UBSEC_STATS  /* Enable/Disable statistical information. */
+
+
+/* 5820/5821 Feature set */
+#ifdef UBSEC_582x_CLASS_DEVICE
+  #define UBSEC_HW_NORMALIZE /* Hardware does the normalization. */
+  #define UBSEC_SSL_SUPPORT 
+#endif
+
+/* 
+ *  Hard enable/disable of key support. 
+ *  This must be enabled for all key functions.
+ */
+#define UBSEC_PKEY_SUPPORT	
+
+#ifdef UBSEC_PKEY_SUPPORT
+  #define UBSEC_MATH_SUPPORT /* Can be conditional. */
+  #define UBSEC_RNG_SUPPORT  /* Can be conditional. */
+  #define UBSEC_DH_SUPPORT   /* Can be conditional. */
+  #define UBSEC_DSA_SUPPORT  /* Can be conditional. */
+  #define UBSEC_RSA_SUPPORT  /* Can be conditional. */
+#endif
+
+
+
+/*
+ * STATIC_F_LIST when defined allocate memory
+ * for the fragment lists as part of the MCR.
+ * This is useful to minimize fragmentation of memory. However
+ * since it increases the size of the MCR large MCR/packet/fragment
+ * combinations (see below) can cause the allocation to fail if the
+ * system does not support large DMA memory allocations. When undefined
+ * separate memory blocks are used in the memory allocation and these
+ * allow the memory allocation to succeed.
+ */
+#undef STATIC_F_LIST
+
+/* Allocate MCRs contiguously */
+#undef CONTIG_MCR
+
+/* Cacheline size of target platform.                        */
+/* A value of zero disables struct alignment optimizations.  */
+/* If enabled (!=0), OS_AllocateDMAMemory() must allocate    */
+/* memory blocks aligned to a cacheline boundary.            */
+#define SYS_CACHELINE_SIZE 64     
+
+#endif  /* _UBSDEFS_H_ */
+
+
+
+
+
+
+
+
+
+
+
diff -urNp linux-8030/drivers/addon/bcm/ubsdh.c linux-8040/drivers/addon/bcm/ubsdh.c
--- linux-8030/drivers/addon/bcm/ubsdh.c
+++ linux-8040/drivers/addon/bcm/ubsdh.c
@@ -0,0 +1,547 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubsdh.c: Diffie Hellman parameter setup functions.
+ *
+ * Revision History:
+ *
+ * May 2000 SOR Created
+ * Sep 2000 SOR 5820 upgrade
+ * 04/20/2001 RJT Added support for CPU-DMA memory synchronization
+ * 04/24/2001 DPA Allow for unnormalize of D-H random number (x) output for BCM5805
+ * 07/16/2001 RJT Added support for BCM5821
+ * 10/09/2001 SRM 64 bit port.
+ */
+
+#include "ubsincl.h"
+
+#ifdef UBSEC_PKEY_SUPPORT
+
+/*
+ * DH_SetupPublicParams:
+ */
+ubsec_Status_t 
+DH_SetupPublicParams(VOLATILE MasterCommand_pt 	pMCR,
+		     ubsec_DH_Params_pt pDHParams)
+
+     /* pDHParams points to a structure which contains all of the info
+	needed for Diffie-Hellman operations. In addition to regular
+	numerical parameters, "key" memory buffer locations are passed 
+	using memory "handles". Handles are defined as memory descriptors
+	from which BOTH the virtual and physical addresses of the designated
+	memory can be derived.
+
+	The virtual and physical pointers associated with the handle 
+	must be extracted by using the following macros:
+
+	  OS_GetVirtualAddress()
+	  OS_GetPhysicalAddress()
+	
+	Results from OS_GetPhysicalAddress() may be written to CryptoNet
+	control structures in (DMA) memory. 
+	Results from OS_GetVirtualAddress() may be used (if necessary) as
+	regular old pointers.
+     */
+
+{
+#ifdef UBSEC_DH_SUPPORT
+  VOLATILE DataBufChainList_t  *FragPtr,*NextFragPtr;
+  int 		     DataLength;
+  VOLATILE Packet_t *pPacket;
+  DH_Send_CtxCmdBuf_pt pDHSendCtx;
+  VOLATILE int             	PacketIndex;
+  ubsec_Status_t Status=UBSEC_STATUS_SUCCESS;
+  int NgLen;
+  int NormalizeLen,NrmBits;
+  int element;
+  unsigned char *pNg;
+  UBS_UINT32 *longkey;
+  ubsec_MemAddress_t PhysAddr;
+
+  PacketIndex = pMCR->NumberOfPackets; 
+  pDHSendCtx = (DH_Send_CtxCmdBuf_t *) &pMCR->KeyContextList[PacketIndex]->CtxCmdBuf.DH_Send_CtxCmdBuf; 
+  RTL_MemZero(pDHSendCtx,sizeof(*pDHSendCtx));
+  pPacket = &(pMCR->PacketArray[PacketIndex]); /* Set up the current packet. */
+
+  pDHSendCtx->rng_enable= CPU_TO_CTRL_SHORT(pDHParams->RNGEnable); 
+
+  /* The modulus needs to be aligned on a 512/768 or 1024 bit boundary.
+   (2048 for 5820) */
+
+  /*
+   * Save amount to normalize/renormalize.
+   */
+  if (pDHParams->N.KeyLength <=512)
+    NormalizeLen=512;
+  else
+    if (pDHParams->N.KeyLength <=768)
+      NormalizeLen=768;
+    else
+      if (pDHParams->N.KeyLength <=1024)
+	NormalizeLen=1024;
+      else
+#ifdef UBSEC_582x_CLASS_DEVICE
+	if (pDHParams->N.KeyLength <=1536)
+	  NormalizeLen=1536;
+	else
+	  if (pDHParams->N.KeyLength <= 2048)
+	    NormalizeLen=2048;
+	  else
+#endif
+        return(UBSEC_STATUS_INVALID_PARAMETER);
+
+#ifndef UBSEC_HW_NORMALIZE
+  if ((NrmBits = ubsec_NormalizeDataTo(&pDHParams->N,NormalizeLen))) {
+      ubsec_ShiftData(&pDHParams->G, NrmBits);
+  }
+
+  pMCR->KeyContextList[PacketIndex]->NormBits=NrmBits;
+#else
+  NrmBits=0;
+#endif
+  pMCR->KeyContextList[PacketIndex]->ResultKey[0]=&(pDHParams->Y); /* Save here for post-command finishing */
+  pMCR->KeyContextList[PacketIndex]->ResultKey[1]=NULL; /* Not used */ 
+
+  /*
+   * Output Y value may need to be rounded up to represent an integral
+   * number of 32 bit words, same total length as modulus N.
+   */
+
+#ifndef UBSEC_HW_NORMALIZE
+  pDHParams->Y.KeyLength = NormalizeLen;    
+#else
+#if 0
+  pDHParams->Y.KeyLength = ROUNDUP_TO_32_BIT(pDHParams->Y.KeyLength);
+#else
+  pDHParams->Y.KeyLength = NormalizeLen;    
+#endif
+#endif
+
+  /* Now setup some of the parameters that need to be aligned. */
+  /* RJT_TEST why is this rounded up? */
+  pDHParams->X.KeyLength = ROUNDUP_TO_32_BIT(pDHParams->X.KeyLength);
+  pMCR->KeyContextList[PacketIndex]->ResultRNG=&(pDHParams->X); /* Save here for post-command finishing */
+
+	/* N Copy the modulo value */
+  pDHSendCtx->modulus_length = (unsigned short)CPU_TO_CTRL_SHORT(pDHParams->N.KeyLength);
+  pNg=(unsigned char *)&pDHSendCtx->Ng[0]; /* For convenience */
+  NgLen=NormalizeLen/8;
+#ifndef UBSEC_HW_NORMALIZE
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords((UBS_UINT32 *)&pNg[0],(UBS_UINT32 *)OS_GetVirtualAddress(pDHParams->N.KeyValue),NgLen/4);
+ #else
+  RTL_Memcpy(&pNg[0],OS_GetVirtualAddress(pDHParams->N.KeyValue),NgLen);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#else /* HW does the normalization */
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords((UBS_UINT32 *)&pNg[0],
+	    (UBS_UINT32 *)OS_GetVirtualAddress(pDHParams->N.KeyValue),
+	    ROUNDUP_TO_32_BIT(pDHParams->N.KeyLength)/32);
+ #else
+  RTL_Memcpy(&pNg[0],OS_GetVirtualAddress(pDHParams->N.KeyValue),ROUNDUP_TO_32_BIT(pDHParams->N.KeyLength)/8);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#endif
+
+  /*
+   * G  Copy the input value. This is the public key for private
+   * operation or the Baseg value for public key generation.
+   * It also needs to be aligned on the same  length
+   * as N
+   */
+  pNg+=NgLen; /* Starting G location. */
+  pDHSendCtx->generator_length=(unsigned short)CPU_TO_CTRL_SHORT(pDHParams->G.KeyLength);
+#ifndef UBSEC_HW_NORMALIZE
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords((UBS_UINT32 *)&pNg[0],(UBS_UINT32 *)OS_GetVirtualAddress(pDHParams->G.KeyValue),NgLen/4);
+ #else
+  RTL_Memcpy(&pNg[0],OS_GetVirtualAddress(pDHParams->G.KeyValue),NgLen);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#else /* HW does the normalization */
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords((UBS_UINT32 *)&pNg[0],
+	    (UBS_UINT32 *)OS_GetVirtualAddress(pDHParams->G.KeyValue),
+	    ROUNDUP_TO_32_BIT(pDHParams->G.KeyLength)/32);
+ #else
+  RTL_Memcpy(&pNg[0],OS_GetVirtualAddress(pDHParams->G.KeyValue),ROUNDUP_TO_32_BIT(pDHParams->G.KeyLength)/8);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#endif
+  
+  /* "extra" length is always 2 x Ng length */
+  pMCR->KeyContextList[PacketIndex]->cmd_structure_length+=(NgLen*2);
+
+  /*
+   * Input Buffer setup for DH Send (Public): 
+   * If the private key x is provided by software, save
+   * it in the first input data buffer, otherwise, the 
+   * input data buffer will not be used by the chip
+   */
+  FragPtr=(DataBufChainList_pt)&pPacket->InputHead;
+  if (! pDHParams->RNGEnable ) { /* Random number manually provided */
+    /* RJT_TEST why is this rounded up? */
+    pDHParams->UserX.KeyLength = ROUNDUP_TO_32_BIT(pDHParams->UserX.KeyLength);
+    PhysAddr=(ubsec_MemAddress_t)(OS_GetPhysicalAddress(pDHParams->UserX.KeyValue));
+#if defined(UBS_ENABLE_KEY_SWAP)
+    longkey = (UBS_UINT32 *)OS_GetVirtualAddress(pDHParams->UserX.KeyValue);
+    for (element = 0 ; element < ROUNDUP_TO_32_BIT(pDHParams->UserX.KeyLength)/32 ; element++) 
+      longkey[element] = BYTESWAPLONG(longkey[element]);
+#endif /* UBS_ENABLE_KEY_SWAP */
+    FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+    DataLength=(pDHParams->UserX.KeyLength+7)/8; /* map the length from bits to bytes */
+    FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+    pDHSendCtx->private_key_length = (unsigned short)CPU_TO_CTRL_SHORT(pDHParams->UserX.KeyLength);
+    Dbg_Print(DBG_FRAG_SYNC,( "ubsec: DH_SetupPublicParams Sync UserX Fragment to Device (0x%08X,%d,%d)\n", 
+			      pDHParams->UserX.KeyValue,
+			      0,
+			      DataLength));
+    OS_SyncToDevice(pDHParams->UserX.KeyValue,
+		    0,
+		    DataLength);
+    Dbg_Print(DBG_DHKEY,( "Public (Send) NormBits %d Input Key, UserX: <%d,%08x (%08x)>\n",NrmBits,DataLength, CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr));
+  }
+  else { /* CryptoNet chip to internally generate random number X */
+    pDHSendCtx->private_key_length=CPU_TO_CTRL_SHORT(pDHParams->RandomKeyLen);
+    FragPtr->DataLength = 0;
+    FragPtr->DataAddress = 0;
+    DataLength=0;
+  } /* Manual/CryptoNet random number generation if-else */
+  /* The CryptoNet chip ignores the pPacket->PacketLength field for this */
+  /* operation. We'll zero that field out for consistency's sake.        */
+  pPacket->PacketLength = 0;
+  FragPtr->pNext = 0; /* Terminate the (empty or single) input fragment list */
+#ifdef UBSDBG
+  /* Print out the context information if required */
+  {
+    int WordLen,i;
+    WordLen=(pMCR->KeyContextList[PacketIndex]->cmd_structure_length-DH_STATIC_SEND_CONTEXT_SIZE)/4;
+    Dbg_Print(DBG_DHKEY,(   "ubsec:  ---- DH_Public - RNG-Enable [%d] Private Klen [%d] Generator Len [%d]\n",
+			    CTRL_TO_CPU_SHORT(pDHSendCtx->rng_enable),
+			    CTRL_TO_CPU_SHORT(pDHSendCtx->private_key_length),
+			    CTRL_TO_CPU_SHORT(pDHSendCtx->generator_length))); 
+
+    Dbg_Print(DBG_DHKEY,(   "ubsec:  ---- Modulus Length [%d] ",
+			    CTRL_TO_CPU_SHORT(pDHSendCtx->modulus_length))); 
+    Dbg_Print(DBG_DHKEY,(   "Context Len %d Context Value=[",
+			    (pMCR->KeyContextList[PacketIndex]->cmd_structure_length))); 
+    for ( i=0 ; i < WordLen ; i++) {
+      Dbg_Print(DBG_DHKEY,( "%08x ",SYS_TO_BE_LONG(pDHSendCtx->Ng[i])));
+    }
+    Dbg_Print(DBG_DHKEY,( "]\n"));
+
+  }
+#endif
+
+  /* Output Buffer setup for DH Send (Public):
+   * The output buffer has Public Key Y, followed by
+   * Private Key X
+   */
+  FragPtr=(DataBufChainList_pt)&pPacket->OutputHead;
+        /* The first output data buffer has Public Key Y */
+  PhysAddr=(ubsec_MemAddress_t)(OS_GetPhysicalAddress(pDHParams->Y.KeyValue)); 
+  FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+  DataLength=(pDHParams->Y.KeyLength+7)/8; /* map the length from bits to bytes */
+  FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+
+#ifdef UBSDBG
+      /* Sanity check debug info for conditions that will hang the chip. */
+  if ( (CTRL_TO_CPU_LONG( FragPtr->DataAddress )) & 0x03) {
+    Dbg_Print(DBG_FATAL,("ubsec:#########INVALID OUTPUT ADDRESS %08x\n", CTRL_TO_CPU_LONG(FragPtr->DataAddress)));
+    Status=UBSEC_STATUS_INVALID_PARAMETER;
+    goto Error_Return;
+  }
+  if ((DataLength) & 0x03) {
+    Dbg_Print(DBG_FATAL,("ubsec:#########INVALID OUTPUT LENGTH %08x\n", DataLength)); 
+    Status=UBSEC_STATUS_INVALID_PARAMETER;
+    goto Error_Return;
+  }
+#endif 
+        /* get the next fragment pointer */
+  NextFragPtr=&pMCR->OutputFragmentList[PacketIndex*(UBSEC_MAX_FRAGMENTS)];
+  FragPtr->pNext =NextFragPtr->PhysicalAddress; 
+  Dbg_Print(DBG_DHKEY,( "Public (Send) NormBits %d Output Key  Y: <%d,%08x, (%08x,Next-%08x)>\n",
+      NrmBits,DataLength,CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr,FragPtr->pNext));
+  FragPtr=NextFragPtr;
+        /* The second output data buffer has Private Key X */
+  PhysAddr=(ubsec_MemAddress_t)(OS_GetPhysicalAddress(pDHParams->X.KeyValue)); 
+  FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+  DataLength=(pDHParams->X.KeyLength+7)/8; /* map the length from bits to bytes */
+  FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+
+  Dbg_Print(DBG_DHKEY,( "Public (Send) Output Key X: <%d, %08x, (%08x,Next-%08x)>\n",
+      DataLength, CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr,FragPtr->pNext));
+
+#ifdef UBSDBG
+      /* Sanity check debug info for conditions that will hang the chip. */
+  if ( (CTRL_TO_CPU_LONG( FragPtr->DataAddress )) & 0x03) {
+    Dbg_Print(DBG_FATAL,("ubsec:#########INVALID OUTPUT_B ADDRESS %08x\n", CTRL_TO_CPU_LONG(FragPtr->DataAddress)));
+    Status=UBSEC_STATUS_INVALID_PARAMETER;
+    goto Error_Return;
+  }
+  if ((DataLength) & 0x03) {
+    Dbg_Print(DBG_FATAL,("ubsec:#########INVALID OUTPUT_B LENGTH %08x\n", DataLength)); 
+    Status=UBSEC_STATUS_INVALID_PARAMETER;
+    goto Error_Return;
+  }
+#endif 
+  
+  FragPtr->pNext = 0;
+
+#ifndef STATIC_F_LIST
+  /* Fragment lists are external to MCR structures, must sync separately */
+  /* Always 2 output frags, need to sync one entry in OutputFragmentList */
+  Dbg_Print(DBG_FRAG_SYNC,( "ubsec: DH_SetupPublicParams Sync OFrag Descriptor to Device (0x%08X,%d,%d)\n", pMCR->OutputFragmentListHandle,
+	      PacketIndex*(UBSEC_MAX_FRAGMENTS)*sizeof(DataBufChainList_t),
+	      sizeof(DataBufChainList_t)));
+  OS_SyncToDevice(pMCR->OutputFragmentListHandle,
+	    PacketIndex*(UBSEC_MAX_FRAGMENTS)*sizeof(DataBufChainList_t),
+	    sizeof(DataBufChainList_t));
+#endif /* STATIC_F_LIST not defined */
+
+#ifdef UBSDBG
+ Error_Return:
+#endif 
+
+  return(Status);
+#else
+    return(UBSEC_STATUS_NO_DEVICE);
+#endif
+
+
+}
+
+
+
+/*
+ * DH_SetupSharedParams:
+ */
+ubsec_Status_t 
+DH_SetupSharedParams(VOLATILE MasterCommand_pt 	pMCR,
+		     ubsec_DH_Params_pt pDHParams)
+{
+#ifdef UBSEC_DH_SUPPORT
+  VOLATILE DataBufChainList_t  *FragPtr, *NextFragPtr;
+  int 		DataLength;
+  ubsec_Status_t Status=UBSEC_STATUS_SUCCESS;
+  VOLATILE Packet_t *pPacket;
+  DH_REC_CtxCmdBuf_pt pDHRecCtx;
+  VOLATILE int             	PacketIndex;
+  int NgLen;
+  int element;
+  int NormalizeLen,NrmBits=0;
+  UBS_UINT32 *longkey;
+  ubsec_MemAddress_t PhysAddr;
+
+  PacketIndex = pMCR->NumberOfPackets; 
+  pDHRecCtx = (DH_REC_CtxCmdBuf_t *) &pMCR->KeyContextList[PacketIndex]->CtxCmdBuf.DH_REC_CtxCmdBuf; 
+  RTL_MemZero(pDHRecCtx,sizeof(*pDHRecCtx));
+  pPacket = &(pMCR->PacketArray[PacketIndex]); /* Set up the current packet. */
+
+  if (pDHParams->N.KeyLength <=512)
+    NormalizeLen=512;
+  else
+    if (pDHParams->N.KeyLength <=768)
+      NormalizeLen=768;
+    else
+      if (pDHParams->N.KeyLength <=1024)
+	NormalizeLen=1024;
+      else
+#ifdef UBSEC_582x_CLASS_DEVICE
+	if (pDHParams->N.KeyLength <=1536)
+	  NormalizeLen=1536;
+	else
+	  NormalizeLen=2048;
+#else
+        return(UBSEC_STATUS_INVALID_PARAMETER);
+#endif
+
+    /*
+     * Output K value may need to be rounded up to represent an integral
+     * number of 32 bit words, same total length as modulus N.
+     */
+#ifndef UBSEC_HW_NORMALIZE
+  pDHParams->K.KeyLength = NormalizeLen;    
+  if ((NrmBits = ubsec_NormalizeDataTo(&pDHParams->N,NormalizeLen))) {
+    ubsec_ShiftData(&pDHParams->Y, NrmBits);
+  }
+  pMCR->KeyContextList[PacketIndex]->NormBits=NrmBits;
+#else
+#if 1
+  pDHParams->K.KeyLength = NormalizeLen;    
+#else
+  pDHParams->K.KeyLength = ROUNDUP_TO_32_BIT(pDHParams->K.KeyLength);
+#endif
+  NrmBits=0;
+#endif
+  pMCR->KeyContextList[PacketIndex]->ResultKey[0]=&pDHParams->K; /* Save here for post-command finishing */
+  pMCR->KeyContextList[PacketIndex]->ResultKey[1]=NULL; /* Not used */ 
+  pMCR->KeyContextList[PacketIndex]->ResultRNG=NULL; /* Not used */
+
+
+  pDHParams->Y.KeyLength = NormalizeLen;    
+
+  /* Now setup some of the parameters that need to be aligned. */
+  /* RJT_TEST why is this rounded up? */
+  pDHParams->X.KeyLength = ROUNDUP_TO_32_BIT(pDHParams->X.KeyLength);
+
+  NgLen=NormalizeLen/8;
+
+  /* N Copy the modulo value modulo */
+  pDHRecCtx->modulus_length = (unsigned short)CPU_TO_CTRL_SHORT(pDHParams->N.KeyLength);
+
+#ifndef UBSEC_HW_NORMALIZE
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pDHRecCtx->N[0],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pDHParams->N.KeyValue),
+	     NgLen/4);
+ #else
+  RTL_Memcpy( &pDHRecCtx->N[0],OS_GetVirtualAddress(pDHParams->N.KeyValue),NgLen);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#else /* HW does the normalization */
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pDHRecCtx->N[0],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pDHParams->N.KeyValue),
+	     ROUNDUP_TO_32_BIT(pDHParams->N.KeyLength)/32);
+ #else
+  RTL_Memcpy( &pDHRecCtx->N[0],OS_GetVirtualAddress(pDHParams->N.KeyValue),ROUNDUP_TO_32_BIT(pDHParams->N.KeyLength)/8);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#endif
+  pMCR->KeyContextList[PacketIndex]->cmd_structure_length+=NgLen;
+
+  /* Set the private key value */
+  pDHRecCtx->modulus_length = (unsigned short)CPU_TO_CTRL_SHORT(pDHParams->N.KeyLength);
+  pDHRecCtx->private_key_length=(unsigned short)CPU_TO_CTRL_SHORT(pDHParams->X.KeyLength);
+
+#ifdef UBSDBG
+  /* Print out the context information if required */
+  {
+  int WordLen,i;
+  WordLen=(NgLen/4);
+  Dbg_Print(DBG_DHKEY,(   "ubsec:  ---- DH Shared Mod Length [%d] Pkey Len [%d] Context Len %d, Value -\n[",
+			  CTRL_TO_CPU_SHORT(pDHRecCtx->modulus_length),
+			  CTRL_TO_CPU_SHORT(pDHRecCtx->private_key_length),		
+			  pMCR->KeyContextList[PacketIndex]->cmd_structure_length)); 
+  for ( i=0 ; i < WordLen ; i++) {
+    Dbg_Print(DBG_DHKEY,( "%08x ",SYS_TO_BE_LONG(pDHRecCtx->N[i])));
+  }
+  Dbg_Print(DBG_DHKEY,( "]\n"));
+  }
+#endif
+
+  /* Input Buffer setup for DH Receive (Shared): */
+  FragPtr=(DataBufChainList_pt)&pPacket->InputHead;
+     /* The first fragment has Y */
+  PhysAddr=(ubsec_MemAddress_t)(OS_GetPhysicalAddress(pDHParams->Y.KeyValue));
+#if defined(UBS_ENABLE_KEY_SWAP)
+  longkey = (UBS_UINT32 *)OS_GetVirtualAddress(pDHParams->Y.KeyValue);
+  for (element = 0 ; element < ROUNDUP_TO_32_BIT(pDHParams->Y.KeyLength)/32 ; element++) 
+    longkey[element] = BYTESWAPLONG(longkey[element]);
+#endif /* UBS_ENABLE_KEY_SWAP */
+  FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+  DataLength=(pDHParams->Y.KeyLength+7)/8; /* map the length from bits to bytes */
+  FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+  /* The CryptoNet chip ignores the pPacket->PacketLength field for this */
+  /* operation. We'll zero that field out for consistency's sake.        */
+  pPacket->PacketLength = 0;
+        /* get the next fragment pointer */
+  NextFragPtr=&pMCR->InputFragmentList[PacketIndex*(UBSEC_MAX_FRAGMENTS)];
+  FragPtr->pNext =NextFragPtr->PhysicalAddress; 
+  Dbg_Print(DBG_FRAG_SYNC,( "ubsec: DH_SetupSharedParams Sync Y Fragment to Device (0x%08X,%d,%d)\n", 
+			    pDHParams->Y.KeyValue,
+			    0,
+			    DataLength));
+  OS_SyncToDevice(pDHParams->Y.KeyValue,
+		  0,
+		  DataLength);
+  Dbg_Print(DBG_DHKEY,( "DH Shared  Y:  FragI <%d,%08x %08x,Next-%08x>\n",
+		      DataLength, CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr,FragPtr->pNext));
+
+  FragPtr=NextFragPtr;
+        /* The second Input data buffer has Private Key x */
+  PhysAddr=(ubsec_MemAddress_t)(OS_GetPhysicalAddress(pDHParams->X.KeyValue));
+#if defined(UBS_ENABLE_KEY_SWAP)
+  longkey = (UBS_UINT32 *)OS_GetVirtualAddress(pDHParams->X.KeyValue);
+  for (element = 0 ; element < ROUNDUP_TO_32_BIT(pDHParams->X.KeyLength)/32 ; element++) 
+    longkey[element] = BYTESWAPLONG(longkey[element]);
+#endif /* UBS_ENABLE_KEY_SWAP */
+  FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+  DataLength=(pDHParams->X.KeyLength+7)/8; /* map the length from bits to bytes */
+  FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+  Dbg_Print(DBG_FRAG_SYNC,( "ubsec: DH_SetupSharedParams Sync X Fragment to Device (0x%08X,%d,%d)\n", 
+			    pDHParams->X.KeyValue,
+			    0,
+			    DataLength));
+  OS_SyncToDevice(pDHParams->X.KeyValue,
+		  0,
+		  DataLength);
+  Dbg_Print(DBG_DHKEY,( "Shared Private Key X: <%d, %08x, (%08x,Next-%08x)>\n",
+      DataLength, CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr,FragPtr->pNext));
+  FragPtr->pNext = 0;
+
+        /* Output Buffer setup for DH Received (Shared):
+	 * The output buffer contains shared secret K 
+	 */
+  FragPtr=(DataBufChainList_pt)&pPacket->OutputHead;
+  PhysAddr=(ubsec_MemAddress_t)(OS_GetPhysicalAddress(pDHParams->K.KeyValue)); 
+  FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+  DataLength=(pDHParams->K.KeyLength+7)/8; /* map the length from bits to bytes */
+  FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+
+#ifdef UBSDBG
+      /* Sanity check debug info for conditions that will hang the chip. */
+  if ( (CTRL_TO_CPU_LONG( FragPtr->DataAddress )) & 0x03) {
+    Dbg_Print(DBG_FATAL,("ubsec:#########INVALID OUTPUT ADDRESS %08x\n", CTRL_TO_CPU_LONG(FragPtr->DataAddress)));
+    Status=UBSEC_STATUS_INVALID_PARAMETER;
+    goto Error_Return;
+  }
+  if ((DataLength) & 0x03) {
+    Dbg_Print(DBG_FATAL,("ubsec:#########INVALID OUTPUT LENGTH %08x\n", DataLength)); 
+    Status=UBSEC_STATUS_INVALID_PARAMETER;
+    goto Error_Return;
+  }
+#endif 
+  Dbg_Print(DBG_DHKEY,( "Receive Buffer K:FragO <%d, %08x>\n",
+		      DataLength, CTRL_TO_CPU_LONG( FragPtr->DataAddress )));
+  FragPtr->pNext = 0;
+
+
+#ifdef UBSDBG
+ Error_Return:
+#endif 
+
+
+  return(Status);
+#else
+    return(UBSEC_STATUS_NO_DEVICE);
+#endif
+
+}
+
+
+#endif /* UBSEC_PKEY_SUPPORT */
+
+
+
+
+
+
diff -urNp linux-8030/drivers/addon/bcm/ubsdsa.c linux-8040/drivers/addon/bcm/ubsdsa.c
--- linux-8030/drivers/addon/bcm/ubsdsa.c
+++ linux-8040/drivers/addon/bcm/ubsdsa.c
@@ -0,0 +1,685 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubsdsa.c: DSA parameter setup functions.
+ *
+ * Revision History:
+ *
+ * May  2000 SOR Created
+ * 04/18/2001 RJT Added support for CPU-DMA memory synchronization
+ * 07/16/2001 RJT Added support for BCM5821
+ * 10/09/2001 SRM 64 bit port
+ */
+
+#include "ubsincl.h"
+
+#ifdef UBSEC_PKEY_SUPPORT
+
+/* 
+ * Function: DSA_SetupSignParams()
+ * Set up KeyContext Buffer, MCR Input Buffer and MCR Output Buffer 
+ * for DSA Sign  operation with parameters provided by pDSAParams 
+ */
+
+ubsec_Status_t 
+DSA_SetupSignParams(MasterCommand_pt pMCR, ubsec_DSA_Params_pt pDSAParams)
+
+     /* pDSAParams points to a structure which contains all of the info
+	needed for the DSA operations. In addition to regular
+	numerical parameters, "key" memory buffer locations are passed 
+	using memory "handles". Handles are defined as memory descriptors
+	from which BOTH the virtual and physical addresses of the designated
+	memory can be derived.
+
+	The virtual and physical pointers associated with the handle 
+	must be extracted by using the following macros:
+
+	  OS_GetVirtualAddress()
+	  OS_GetPhysicalAddress()
+	
+	Results from OS_GetPhysicalAddress() may be written to CryptoNet
+	control structures in (DMA) memory. 
+	Results from OS_GetVirtualAddress() may be used (if necessary) as
+	regular old pointers.
+     */
+
+{
+#ifdef UBSEC_DSA_SUPPORT
+  volatile DataBufChainList_t   *FragPtr = NULL, *NextFragPtr;
+  int                            DataLength;
+  volatile Packet_t 		*pPacket;
+  VOLATILE DSA_Sign_CtxCmdBuf_t	*pDSACtx;
+  int                  PacketIndex;
+  int fragnum; 
+  int Offset;
+  int element;
+  int NormBits,NormalizeLen;
+  UBS_UINT32 *longkey;
+  ubsec_MemAddress_t PhysAddr;
+
+  PacketIndex = pMCR->NumberOfPackets;
+  pDSACtx = &pMCR->KeyContextList[PacketIndex]->CtxCmdBuf.DSA_Sign_CtxCmdBuf;
+
+  /* Zero out the parameters */
+  RTL_MemZero(pDSACtx,sizeof(*pDSACtx));
+
+  pPacket = &(pMCR->PacketArray[PacketIndex]); /* Set up the current packet */
+  pDSACtx->sha1_enable= pDSAParams->HashEnable ? CPU_TO_CTRL_SHORT(1) : 0;
+
+  pDSACtx->p_length = (unsigned short)CPU_TO_CTRL_SHORT(pDSAParams->ModP.KeyLength);
+  if (pDSAParams->ModP.KeyLength <=512)
+    NormalizeLen=512;
+  else
+    if (pDSAParams->ModP.KeyLength  <= 768)
+      NormalizeLen=768;
+    else
+    if (pDSAParams->ModP.KeyLength  <= 1024)
+      NormalizeLen=1024;
+    else
+#ifdef UBSEC_582x_CLASS_DEVICE
+      if (pDSAParams->ModP.KeyLength <=1536)
+	NormalizeLen=1536;
+      else
+	if (pDSAParams->ModP.KeyLength<=2048)
+	  NormalizeLen=2048;
+	else
+#endif
+      return(UBSEC_STATUS_INVALID_PARAMETER);
+
+
+
+  /*
+   * Q Needs to be normalized on 160 bits.
+   * P & G need to be shifted the same amount
+   */
+#ifndef UBSEC_HW_NORMALIZE
+  NormBits = ubsec_NormalizeDataTo(&pDSAParams->ModQ,160);
+  NormBits=ubsec_NormalizeDataTo(&pDSAParams->ModP, NormalizeLen); 
+  ubsec_ShiftData(&pDSAParams->BaseG, NormBits); 
+#else
+  NormBits=0;
+#endif
+  NormalizeLen/=8;
+
+  Offset=0;
+  /* q setup, Always 160 Bits. */
+#ifndef UBSEC_HW_NORMALIZE
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pDSACtx->CtxParams[0],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pDSAParams->ModQ.KeyValue),
+	     20/4);
+ #else
+  RTL_Memcpy( &pDSACtx->CtxParams[0],OS_GetVirtualAddress(pDSAParams->ModQ.KeyValue),20);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#else
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pDSACtx->CtxParams[0],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pDSAParams->ModQ.KeyValue),
+	     ROUNDUP_TO_32_BIT(pDSAParams->ModQ.KeyLength)/32);
+ #else
+  RTL_Memcpy( &pDSACtx->CtxParams[0],OS_GetVirtualAddress(pDSAParams->ModQ.KeyValue),
+	      ROUNDUP_TO_32_BIT(pDSAParams->ModQ.KeyLength)/8);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#endif
+  Offset+=20;
+
+  /* p setup */
+#ifndef UBSEC_HW_NORMALIZE
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pDSACtx->CtxParams[Offset/4],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pDSAParams->ModP.KeyValue),
+	     NormalizeLen/4);
+ #else
+  RTL_Memcpy( &pDSACtx->CtxParams[Offset/4],OS_GetVirtualAddress(pDSAParams->ModP.KeyValue)
+	      ,NormalizeLen);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#else
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pDSACtx->CtxParams[Offset/4],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pDSAParams->ModP.KeyValue),
+	     ROUNDUP_TO_32_BIT(pDSAParams->ModP.KeyLength)/32);
+ #else
+  RTL_Memcpy( &pDSACtx->CtxParams[Offset/4],OS_GetVirtualAddress(pDSAParams->ModP.KeyValue),
+	      ROUNDUP_TO_32_BIT(pDSAParams->ModP.KeyLength)/8);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#endif
+  Offset+=NormalizeLen;
+
+  /* g setup */
+#ifndef UBSEC_HW_NORMALIZE
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pDSACtx->CtxParams[Offset/4],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pDSAParams->BaseG.KeyValue),
+	     NormalizeLen/4);
+ #else
+  RTL_Memcpy( &pDSACtx->CtxParams[Offset/4],OS_GetVirtualAddress(pDSAParams->BaseG.KeyValue),NormalizeLen);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#else
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pDSACtx->CtxParams[Offset/4],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pDSAParams->BaseG.KeyValue),
+	     ROUNDUP_TO_32_BIT(pDSAParams->BaseG.KeyLength)/32);
+ #else
+  RTL_Memcpy( &pDSACtx->CtxParams[Offset/4],OS_GetVirtualAddress(pDSAParams->BaseG.KeyValue),
+	      ROUNDUP_TO_32_BIT(pDSAParams->BaseG.KeyLength)/8);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#endif
+  Offset+=NormalizeLen;
+
+  /* x setup */
+#ifndef UBSEC_HW_NORMALIZE
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pDSACtx->CtxParams[Offset/4],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pDSAParams->Key.KeyValue),
+	     20/4);
+ #else
+  RTL_Memcpy( &pDSACtx->CtxParams[Offset/4],OS_GetVirtualAddress(pDSAParams->Key.KeyValue),20);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#else
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pDSACtx->CtxParams[Offset/4],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pDSAParams->Key.KeyValue),
+	     ROUNDUP_TO_32_BIT(pDSAParams->Key.KeyLength)/32);
+ #else
+  RTL_Memcpy( &pDSACtx->CtxParams[Offset/4],OS_GetVirtualAddress(pDSAParams->Key.KeyValue),
+	      ROUNDUP_TO_32_BIT(pDSAParams->Key.KeyLength)/8);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#endif
+  Offset+=20;
+
+  /* Set total length */
+  pMCR->KeyContextList[PacketIndex]->cmd_structure_length+=Offset;
+
+#ifdef UBSDBG
+  /* Print out the context information if required */
+  {
+  int WordLen,i;
+  WordLen=(pMCR->KeyContextList[PacketIndex]->cmd_structure_length-DSA_STATIC_SIGN_CONTEXT_SIZE)/4;
+  Dbg_Print(DBG_DSAKEY,(   "ubsec:  ---- DSA Mod P Length [%d] \n",
+			   CTRL_TO_CPU_SHORT(pDSACtx->p_length))); 
+  Dbg_Print(DBG_DSAKEY,(   "ubsec:  ---- DSA SHA Enabled  [%d]\n",
+			   CTRL_TO_CPU_SHORT(pDSACtx->sha1_enable)));
+  Dbg_Print(DBG_DSAKEY,(   "ubsec:  ---- Context Len %d Value -\n[",
+			   pMCR->KeyContextList[PacketIndex]->cmd_structure_length )); 
+
+  for ( i=0 ; i < WordLen ; i++) {
+    Dbg_Print(DBG_DSAKEY,( "%08x ",SYS_TO_BE_LONG(pDSACtx->CtxParams[i])));
+  }
+  Dbg_Print(DBG_DSAKEY,( "]\n"));
+  }
+#endif
+
+  /* Input Buffer setup for DSA Sign. */
+  pPacket->PacketLength = 0;
+  /* The DSA message is a bytestream. Treat it just like a crypto buffer. */
+  NextFragPtr=(DataBufChainList_pt)&pPacket->InputHead;
+  for (fragnum=0;fragnum<(int)pDSAParams->NumInputFragments;fragnum++) {
+    FragPtr = NextFragPtr;
+    PhysAddr=pDSAParams->InputFragments[fragnum].FragmentAddress;
+    DataLength=pDSAParams->InputFragments[fragnum].FragmentLength;
+    FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+    FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+    /* Add (endian-adjusted) fragment length into current packet structure */
+    pPacket->PacketLength += (unsigned short)DataLength; 
+    if (fragnum==0) { /* Next frag descriptor is packet's InputFragmentList */
+      NextFragPtr=&pMCR->InputFragmentList[PacketIndex*(UBSEC_MAX_FRAGMENTS)];
+    }
+    else { /* Next frag descriptor is next InputFragmentList entry */
+      NextFragPtr=&FragPtr[1]; 
+    }
+    FragPtr->pNext = NextFragPtr->PhysicalAddress;
+    Dbg_Print(DBG_DSAKEY,( "DSA Sign InputKeyInfo: IFrag[%d] <%d,%08x %08x>\n",
+			   fragnum, DataLength, 
+			   CTRL_TO_CPU_LONG( FragPtr->DataAddress ), 
+			   FragPtr));
+  } /* for each input fragment of the unhashed message bytestream */
+
+  /* ->PacketLength is only for the message 'm'; it does not count the */
+  /* size of the fragment used for the random number (if present)      */
+  /* Therefore, we're finished updating ->PacketLength.                */
+    
+#if (UBS_CPU_ATTRIBUTE != UBS_CRYPTONET_ATTRIBUTE) 
+  /* fix up the packet length endianess in DMA control memory */
+  pPacket->PacketLength = CPU_TO_CTRL_SHORT( pPacket->PacketLength );
+#endif 
+
+    if (!pDSAParams->RNGEnable) { /* CryptoNet RNG generation not requested */
+    /* The random number is provided by the user (not CryptoNet). It    */
+    /* will use the next available frag descriptor in InputFragmentList */
+    pDSACtx->rng_enable=0;
+
+    /* If here we need to use an additional input frag descriptor    */
+    /* FragPtr is pointing at the last filled fragment descriptor    */
+    /* NextFragPtr is pointing at next available fragment descriptor */
+    /* FragPtr->pNext is pointing at NextFragPtr's physical address  */
+    /* However, first check for an excessively long fragment list    */
+    if (pDSAParams->NumInputFragments > UBSEC_MAX_FRAGMENTS)
+      return(UBSEC_STATUS_INVALID_PARAMETER); 
+
+    FragPtr=NextFragPtr;
+    PhysAddr=(ubsec_MemAddress_t)(OS_GetPhysicalAddress(pDSAParams->Random.KeyValue)); 
+ #if defined(UBS_ENABLE_KEY_SWAP)
+    longkey = (UBS_UINT32 *)OS_GetVirtualAddress(pDSAParams->Random.KeyValue);
+    for (element = 0 ; element < ROUNDUP_TO_32_BIT(pDSAParams->Random.KeyLength)/32 ; element++) 
+      longkey[element] = BYTESWAPLONG(longkey[element]);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+    FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+    DataLength=(pDSAParams->Random.KeyLength+7)/8; /* map the length from bits to bytes */
+    FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+    fragnum++; /* Increment for upcoming OS_SyncToDevice() call */
+    Dbg_Print(DBG_FRAG_SYNC,( "ubsec: DSA_SetupSignParams Sync Random Fragment to Device (0x%08X,%d,%d)\n", 
+			      pDSAParams->Random.KeyValue,
+			      0,
+			      DataLength));
+    OS_SyncToDevice(pDSAParams->Random.KeyValue,
+		    0,
+		    DataLength);
+    Dbg_Print(DBG_DSAKEY,( " DSA Random Num Fragment: <%d,%08x (%08x)>\n",
+		DataLength, CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr));
+
+  }
+  else {
+    /* The random number will be generated by the CryptoNet chip.   */
+    /* No additional input fragment descriptor required.            */
+    pDSACtx->rng_enable=CPU_TO_CTRL_SHORT(1);
+    pDSAParams->Random.KeyLength = 
+      ROUNDUP_TO_32_BIT(pDSAParams->Random.KeyLength);
+  }
+
+  FragPtr->pNext = 0; /* Terminate the input fragment descriptor list */
+  Dbg_Print(DBG_DSAKEY,(   "ubsec:  ---- RNG_Enabled [%d]\n",pDSACtx->rng_enable));
+
+#ifndef STATIC_F_LIST
+  /* Fragment lists are external to MCR structures, must sync separately */
+  if (fragnum > 1) { /* We're using at least one InputFragmentList entry */
+    Dbg_Print(DBG_FRAG_SYNC,( "ubsec: DSA_SetupSignParams Sync %d IFrag Descriptor(s) to Device (0x%08X,%d,%d)\n", fragnum-1, pMCR->InputFragmentListHandle,
+	      PacketIndex*(UBSEC_MAX_FRAGMENTS)*sizeof(DataBufChainList_t),
+	      (fragnum-1)*sizeof(DataBufChainList_t)));
+    OS_SyncToDevice(pMCR->InputFragmentListHandle,
+	    PacketIndex*(UBSEC_MAX_FRAGMENTS)*sizeof(DataBufChainList_t),
+	    (fragnum-1)*sizeof(DataBufChainList_t));
+  }
+#endif /* STATIC_F_LIST not defined */
+
+  /* Now setup the output fragment descriptor list. Always 2 fragments */
+
+  FragPtr=(DataBufChainList_pt)&pPacket->OutputHead;
+  PhysAddr=(ubsec_MemAddress_t)(OS_GetPhysicalAddress(pDSAParams->SigR.KeyValue));
+  FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+  DataLength=(pDSAParams->SigR.KeyLength+7)/8;
+  FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+
+        /* get the next fragment pointer */
+  NextFragPtr=&pMCR->OutputFragmentList[PacketIndex*(UBSEC_MAX_FRAGMENTS)];
+  FragPtr->pNext =NextFragPtr->PhysicalAddress;
+  Dbg_Print(DBG_DSAKEY,( "DSA Sign Sig_R: <%d,%08x, (%08x,Next-%08x)>\n",
+      DataLength,CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr,FragPtr->pNext));
+  FragPtr=NextFragPtr;
+  PhysAddr=(ubsec_MemAddress_t)(OS_GetPhysicalAddress(pDSAParams->SigS.KeyValue));
+  FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+  DataLength=(pDSAParams->SigS.KeyLength+7)/8;
+  FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+  FragPtr->pNext = 0;
+
+  Dbg_Print(DBG_DSAKEY,( "DSA Sign Sig_S: <%d,%08x, (%08x,Next-%08x)>\n",
+      DataLength,CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr,FragPtr->pNext));
+
+#ifndef STATIC_F_LIST
+  /* Fragment lists are external to MCR structures, must sync separately */
+  /* Always 2 output frags, need to sync one entry in OutputFragmentList */
+  Dbg_Print(DBG_FRAG_SYNC,( "ubsec: DSA_SetupSignParams Sync OFrag Descriptor to Device (0x%08X,%d,%d)\n", pMCR->OutputFragmentListHandle,
+	      PacketIndex*(UBSEC_MAX_FRAGMENTS)*sizeof(DataBufChainList_t),
+	      sizeof(DataBufChainList_t)));
+  OS_SyncToDevice(pMCR->OutputFragmentListHandle,
+	    PacketIndex*(UBSEC_MAX_FRAGMENTS)*sizeof(DataBufChainList_t),
+	    sizeof(DataBufChainList_t));
+#endif /* STATIC_F_LIST not defined */
+
+#ifndef UBSEC_HW_NORMALIZE
+  pMCR->KeyContextList[PacketIndex]->NormBits=0;
+#endif
+  pMCR->KeyContextList[PacketIndex]->ResultKey[0] = &pDSAParams->SigR; /* Save for post-processing callback */
+  pMCR->KeyContextList[PacketIndex]->ResultKey[1] = &pDSAParams->SigS; /* Save for post-processing callback */
+  pMCR->KeyContextList[PacketIndex]->ResultRNG = NULL; /* Not used */
+  return(UBSEC_STATUS_SUCCESS);
+#else /* UBSEC_DSA_SUPPORT not defined */
+    return(UBSEC_STATUS_NO_DEVICE);
+#endif
+} /* end DSA_SetupSignParams() */
+
+
+
+/* 
+ * Function: DSA_SetupVerifyParams()
+ * Set up KeyContext Buffer, MCR Input Buffer and MCR Output Buffer 
+ * for DSA Verify operation with parameters provided by pDSAParams 
+ */
+
+ubsec_Status_t 
+DSA_SetupVerifyParams(MasterCommand_pt pMCR, ubsec_DSA_Params_pt pDSAParams)
+{
+#ifdef UBSEC_DSA_SUPPORT
+  volatile DataBufChainList_t   *FragPtr, *NextFragPtr;
+  int                            DataLength;
+  volatile Packet_t 		*pPacket;
+  VOLATILE DSA_Verify_CtxCmdBuf_t	*pDSACtx;
+  int                  PacketIndex;
+  int fragnum; 
+  int Offset;
+  int element;
+  int NormBits,NormalizeLen;
+  UBS_UINT32 *longkey;
+  ubsec_MemAddress_t PhysAddr;
+
+  /* First do a sanity check for an excessively long input fragment list */
+  if (pDSAParams->NumInputFragments > (UBSEC_MAX_FRAGMENTS - 1))
+    return(UBSEC_STATUS_INVALID_PARAMETER); 
+
+  PacketIndex = pMCR->NumberOfPackets;
+  pDSACtx = &pMCR->KeyContextList[PacketIndex]->CtxCmdBuf.DSA_Verify_CtxCmdBuf;
+  RTL_MemZero(pDSACtx,sizeof(*pDSACtx));
+
+  pDSACtx->sha1_enable= pDSAParams->HashEnable ? CPU_TO_CTRL_SHORT(1) : 0;
+  pPacket = &(pMCR->PacketArray[PacketIndex]); /* Set up the current packet */
+
+  pDSACtx->p_length = (unsigned short)CPU_TO_CTRL_SHORT(pDSAParams->ModP.KeyLength) ;
+
+  if (pDSAParams->ModP.KeyLength <=512)
+    NormalizeLen=512;
+  else
+    if (pDSAParams->ModP.KeyLength <= 768)
+      NormalizeLen=768;
+    else
+    if (pDSAParams->ModP.KeyLength  <= 1024)
+      NormalizeLen=1024;
+    else
+#ifdef UBSEC_582x_CLASS_DEVICE
+	if (pDSAParams->ModP.KeyLength <=1536)
+	  NormalizeLen=1536;
+	else
+	  NormalizeLen=2048;
+#else
+        return(UBSEC_STATUS_INVALID_PARAMETER);
+#endif
+
+#ifndef UBSEC_HW_NORMALIZE
+  /*
+   * Q Needs to be normalized on 160 bits.
+   * P & G need to be shifted the same amount
+   */
+  NormBits = ubsec_NormalizeDataTo(&pDSAParams->ModQ,160);
+  NormBits=ubsec_NormalizeDataTo(&pDSAParams->ModP, NormalizeLen); 
+  ubsec_ShiftData(&pDSAParams->BaseG, NormBits); 
+  if (NormBits)
+    ubsec_ShiftData(&pDSAParams->Key, NormBits); 
+#else
+  NormBits=0;
+#endif
+  NormalizeLen/=8;
+  Offset=0;
+
+  /* Pad out those parameters that need it. */
+  pDSAParams->SigS.KeyLength = ROUNDUP_TO_32_BIT(pDSAParams->SigS.KeyLength);
+  pDSAParams->SigR.KeyLength = ROUNDUP_TO_32_BIT(pDSAParams->SigR.KeyLength);
+
+  /* q setup, Always 160 Bits. */
+#ifndef UBSEC_HW_NORMALIZE
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pDSACtx->CtxParams[0],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pDSAParams->ModQ.KeyValue),
+	     20/4);
+ #else
+  RTL_Memcpy( &pDSACtx->CtxParams[0],OS_GetVirtualAddress(pDSAParams->ModQ.KeyValue),20);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#else
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pDSACtx->CtxParams[0],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pDSAParams->ModQ.KeyValue),
+	     ROUNDUP_TO_32_BIT(pDSAParams->ModQ.KeyLength)/32);
+ #else
+  RTL_Memcpy( &pDSACtx->CtxParams[0],OS_GetVirtualAddress(pDSAParams->ModQ.KeyValue),
+	      ROUNDUP_TO_32_BIT(pDSAParams->ModQ.KeyLength)/8);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#endif
+  Offset+=20;
+
+  /* p setup */
+#ifndef UBSEC_HW_NORMALIZE
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pDSACtx->CtxParams[Offset/4],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pDSAParams->ModP.KeyValue),
+	     NormalizeLen/4);
+ #else
+  RTL_Memcpy( &pDSACtx->CtxParams[Offset/4],OS_GetVirtualAddress(pDSAParams->ModP.KeyValue),
+	      NormalizeLen);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#else
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pDSACtx->CtxParams[Offset/4],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pDSAParams->ModP.KeyValue),
+	     ROUNDUP_TO_32_BIT(pDSAParams->ModP.KeyLength)/32);
+ #else
+  RTL_Memcpy( &pDSACtx->CtxParams[Offset/4],OS_GetVirtualAddress(pDSAParams->ModP.KeyValue),
+	      ROUNDUP_TO_32_BIT(pDSAParams->ModP.KeyLength)/8);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#endif
+  Offset+=NormalizeLen;
+
+  /* g setup */
+#ifndef UBSEC_HW_NORMALIZE
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pDSACtx->CtxParams[Offset/4],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pDSAParams->BaseG.KeyValue),
+	     NormalizeLen/4);
+ #else
+  RTL_Memcpy( &pDSACtx->CtxParams[Offset/4],OS_GetVirtualAddress(pDSAParams->BaseG.KeyValue),
+	      NormalizeLen);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#else
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pDSACtx->CtxParams[Offset/4],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pDSAParams->BaseG.KeyValue),
+	     ROUNDUP_TO_32_BIT(pDSAParams->BaseG.KeyLength)/32);
+ #else
+  RTL_Memcpy( &pDSACtx->CtxParams[Offset/4],OS_GetVirtualAddress(pDSAParams->BaseG.KeyValue),
+	      ROUNDUP_TO_32_BIT(pDSAParams->BaseG.KeyLength)/8);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#endif
+  Offset+=NormalizeLen;
+
+  /* Y setup */
+#ifndef UBSEC_HW_NORMALIZE
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pDSACtx->CtxParams[Offset/4],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pDSAParams->Key.KeyValue),
+	     NormalizeLen/4);
+ #else
+  RTL_Memcpy( &pDSACtx->CtxParams[Offset/4],OS_GetVirtualAddress(pDSAParams->Key.KeyValue),
+	      NormalizeLen);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#else
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pDSACtx->CtxParams[Offset/4],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pDSAParams->Key.KeyValue),
+	     ROUNDUP_TO_32_BIT(pDSAParams->Key.KeyLength)/32);
+ #else
+  RTL_Memcpy( &pDSACtx->CtxParams[Offset/4],OS_GetVirtualAddress(pDSAParams->Key.KeyValue),
+	      ROUNDUP_TO_32_BIT(pDSAParams->Key.KeyLength)/8);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#endif
+  Offset+=NormalizeLen;
+
+  /* Set total length */
+  pMCR->KeyContextList[PacketIndex]->cmd_structure_length+=Offset;
+
+#ifdef UBSDBG
+  /* Print out the context information if required */
+  {
+  int WordLen,i;
+  WordLen=(pMCR->KeyContextList[PacketIndex]->cmd_structure_length-DSA_STATIC_SIGN_CONTEXT_SIZE)/4;
+  Dbg_Print(DBG_DSAKEY,(   "ubsec:  ---- DSA Verify Mod P Length [%d] \n",pDSACtx->p_length)); 
+  Dbg_Print(DBG_DSAKEY,(   "ubsec:  ---- DSA SHA Enabled  [%d]\n",pDSACtx->sha1_enable));
+  Dbg_Print(DBG_DSAKEY,(   "ubsec:  ---- Context Len %d Value -\n[",
+			   pMCR->KeyContextList[PacketIndex]->cmd_structure_length )); 
+
+  for ( i=0 ; i < WordLen ; i++) {
+    Dbg_Print(DBG_DSAKEY,( "%08x ",SYS_TO_BE_LONG(pDSACtx->CtxParams[i])));
+  }
+  Dbg_Print(DBG_DSAKEY,( "]\n"));
+  }
+#endif
+
+  /* Input Buffer(s) setup for DSA Verify */
+  pPacket->PacketLength = 0;
+  /* The DSA message is a bytestream. Treat it just like a crypto buffer. */
+  NextFragPtr=(DataBufChainList_pt)&pPacket->InputHead;
+  for (fragnum=0;fragnum<(int)pDSAParams->NumInputFragments;fragnum++) {
+    FragPtr = NextFragPtr;
+    PhysAddr=pDSAParams->InputFragments[fragnum].FragmentAddress;
+    DataLength=pDSAParams->InputFragments[fragnum].FragmentLength;
+    FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+    FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+    /* Add (endian-adjusted) fragment length into MCR structure */
+    pPacket->PacketLength += (unsigned short)DataLength;
+    if (fragnum==0) { /* Next frag descriptor is packet's InputFragmentList */
+      NextFragPtr=&pMCR->InputFragmentList[PacketIndex*(UBSEC_MAX_FRAGMENTS)];
+    }
+    else { /* Next frag descriptor is next InputFragmentList entry */
+      NextFragPtr=&FragPtr[1]; 
+    }
+    FragPtr->pNext = NextFragPtr->PhysicalAddress;
+    
+    Dbg_Print(DBG_DSAKEY,( "DSA Verify InputKeyInfo : IFrag[%d] <%d,%08x %08x>\n",
+			   fragnum, DataLength, 
+			   CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr)); 
+  } /* for each input fragment */
+  
+  /* ->PacketLength is only for the message 'm'; it does not  */
+  /* count the sizes of the fragments used for 'R' and 'S'.   */    
+  /* Therefore, we're finished updating ->PacketLength.       */
+
+#if (UBS_CPU_ATTRIBUTE != UBS_CRYPTONET_ATTRIBUTE) 
+  /* fix up the packet length endianess in DMA control memory */
+  pPacket->PacketLength = CPU_TO_CTRL_SHORT( pPacket->PacketLength );
+#endif
+
+  /* Here with FragPtr pointing at last filled fragment descriptor */
+  /* NextFragPtr is pointing at next available fragment descriptor */
+  /* FragPtr->pNext is pointing at NextFragPtr's physical address  */
+
+  /* Now setup R */
+  FragPtr=NextFragPtr;
+  PhysAddr=(ubsec_MemAddress_t)(OS_GetPhysicalAddress(pDSAParams->SigR.KeyValue));
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  longkey = (UBS_UINT32 *)OS_GetVirtualAddress(pDSAParams->SigR.KeyValue);
+  for (element = 0 ; element < ROUNDUP_TO_32_BIT(pDSAParams->SigR.KeyLength)/32 ; element++) 
+    longkey[element] = BYTESWAPLONG(longkey[element]);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+  FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+  DataLength=(pDSAParams->SigR.KeyLength+7)/8;
+  FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+
+  /* Get and goto the next fragment */
+  NextFragPtr=&FragPtr[1];
+  FragPtr->pNext =NextFragPtr->PhysicalAddress;
+  Dbg_Print(DBG_FRAG_SYNC,( "ubsec: DSA_SetupVerifyParams Sync SigR Fragment to Device (0x%08X,%d,%d)\n", 
+			    pDSAParams->SigR.KeyValue,
+			    0,
+			    DataLength));
+  OS_SyncToDevice(pDSAParams->SigR.KeyValue,
+		  0,
+		  DataLength);
+  Dbg_Print(DBG_DSAKEY,( "DSA Verify Sig_R: <%d,%08x, (%08x,Next-%08x)>\n",
+      DataLength,CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr,FragPtr->pNext));
+
+  FragPtr=NextFragPtr;
+  /* Set up S */
+  PhysAddr=(ubsec_MemAddress_t)(OS_GetPhysicalAddress(pDSAParams->SigS.KeyValue));
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  longkey = (UBS_UINT32 *)OS_GetVirtualAddress(pDSAParams->SigS.KeyValue);
+  for (element = 0 ; element < ROUNDUP_TO_32_BIT(pDSAParams->SigS.KeyLength)/32 ; element++) 
+    longkey[element] = BYTESWAPLONG(longkey[element]);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+  FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+  DataLength=(pDSAParams->SigS.KeyLength+7)/8;
+  FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+
+  Dbg_Print(DBG_FRAG_SYNC,( "ubsec: DSA_SetupVerifyParams Sync SigS Fragment to Device (0x%08X,%d,%d)\n", 
+			    pDSAParams->SigS.KeyValue,
+			    0,
+			    DataLength));
+  OS_SyncToDevice(pDSAParams->SigS.KeyValue,
+		  0,
+		  DataLength);
+  Dbg_Print(DBG_DSAKEY,( "DSA Verify Sig_S: <%d,%08x, (%08x,Next-%08x)>\n",
+      DataLength,CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr,FragPtr->pNext));
+
+  FragPtr->pNext = 0; /* Terminate the InputFragmentList. */
+
+#ifndef STATIC_F_LIST
+  /* Fragment lists are external to MCR structures, must sync separately */
+  Dbg_Print(DBG_FRAG_SYNC,( "ubsec: DSA_SetupSignParams Sync %d IFrag Descriptor(s) to Device (0x%08X,%d,%d)\n", fragnum+1, pMCR->InputFragmentListHandle,
+	      PacketIndex*(UBSEC_MAX_FRAGMENTS)*sizeof(DataBufChainList_t),
+	      (fragnum+1)*sizeof(DataBufChainList_t)));
+  OS_SyncToDevice(pMCR->InputFragmentListHandle,
+	    PacketIndex*(UBSEC_MAX_FRAGMENTS)*sizeof(DataBufChainList_t),
+	    (fragnum+1)*sizeof(DataBufChainList_t));
+#endif /* STATIC_F_LIST not defined */
+
+  /* Output Buffers setup for DSA Verify. Always only one fragment */
+  FragPtr=(DataBufChainList_pt)&pPacket->OutputHead;
+  PhysAddr=(ubsec_MemAddress_t)(OS_GetPhysicalAddress(pDSAParams->V.KeyValue));
+  FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+  DataLength=(pDSAParams->V.KeyLength+7)/8;
+  FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+  FragPtr->pNext = 0;
+
+  Dbg_Print(DBG_DSAKEY,( "DSA Verify V: <%d,%08x, (%08x,Next-%08x)>\n",
+      DataLength,CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr,FragPtr->pNext));
+
+  /* The (only) Output Fragment descriptor (inside the MCR packet struct) */
+  /* will get sync'd to the CryptoNet device when the MCR gets sync'd.    */
+
+#ifndef UBSEC_HW_NORMALIZE
+  pMCR->KeyContextList[PacketIndex]->NormBits=0;
+#endif
+
+  pMCR->KeyContextList[PacketIndex]->ResultKey[0] = &pDSAParams->V; /* Save for post-processing callback */
+  pMCR->KeyContextList[PacketIndex]->ResultKey[1] = NULL; /* Not used */
+  pMCR->KeyContextList[PacketIndex]->ResultRNG = NULL; /* Not used */
+
+  return(UBSEC_STATUS_SUCCESS);
+#else
+    return(UBSEC_STATUS_NO_DEVICE);
+#endif
+} /* end DSA_SetupVerifyParams() */
+
+
+
+
+#endif /* UBSEC_PKEY_SUPPORT */
+
+
+
diff -urNp linux-8030/drivers/addon/bcm/ubsec.h linux-8040/drivers/addon/bcm/ubsec.h
--- linux-8030/drivers/addon/bcm/ubsec.h
+++ linux-8040/drivers/addon/bcm/ubsec.h
@@ -0,0 +1,710 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubsec.h: Interface functions and defintions for the ubsec Software Reference
+ * library.
+ *
+ * This file should be included by any files using the UBSEC 5501 SRL
+ */
+
+/*
+ * Revision History:
+ *
+ *  Oct 99 SOR Created.
+ *  Sep 00 SOR 5820 Support Added.
+ *  Jul 01 RJT 5821 Support Added (1.2a)
+ *  Oct 01 SRM 64 bit port.
+ */
+
+#ifndef _UBSEC_H_
+#define _UBSEC_H_
+
+#include "ubslinux.h"
+/*
+ * Device_Context is handle for all ubsec device operations. It
+ * is assigned at initialization time.
+ */
+typedef void *ubsec_DeviceContext_t, **ubsec_DeviceContext_pt;
+
+#ifdef PAD_ALIGN64_APP32
+#define PADIT(name,size)  char name[size];
+#else
+#define PADIT(name,size)
+#endif
+
+#include "ubssys.h"
+
+/*
+ * List of Vendor/Device IDs supported by the library.
+ */
+#define BROADCOM_VENDOR_ID  0x14e4  /* Broadcom vendor ID */
+#define BROADCOM_DEVICE_ID_5801  0x5801 /* Release board. */
+#define BROADCOM_DEVICE_ID_5802  0x5802 /* Release board. */
+#define BROADCOM_DEVICE_ID_5805  0x5805 /* Release board  */
+#define BROADCOM_DEVICE_ID_5820  0x5820 /* Release board  */
+#define BROADCOM_DEVICE_ID_5821  0x5821 /* Release board  */
+#define BROADCOM_DEVICE_ID_5822  0x5822 /* Release board  */
+
+/* Macro to determine device type based on deviceID */
+#define UBSEC_IS_CRYPTO_DEVICEID(DeviceID) ((DeviceID) == BROADCOM_DEVICE_ID_5801)
+
+/* 
+ * Version of the SRL.
+ */
+#define UBSEC_VERSION_MAJOR 0x1
+#define UBSEC_VERSION_MINOR 0x4
+#define UBSEC_VERSION_REV   ' '  /* Single alphanumeric character, start with blank, then a,b,c... */
+
+
+/*
+ * Cryptographic parameter definitions
+ */
+#define UBSEC_DES_KEY_LENGTH 2    /* long */
+#define UBSEC_3DES_KEY_LENGTH 6   /* long */
+#define UBSEC_MAX_CRYPT_KEY_LENGTH UBSEC_3DES_KEY_LENGTH
+#define UBSEC_IV_LENGTH		2 /* long */
+#define UBSEC_IV_LENGTH_BYTES	8
+
+#define UBSEC_MAC_KEY_LENGTH	64 /* Bytes */
+#define UBSEC_MD5_LENGTH	16 /* Bytes */
+#define UBSEC_SHA1_LENGTH	20 /* Bytes */
+#define UBSEC_HMAC_LENGTH   20 /* Max of MD5/SHA1 */
+
+
+/*
+ * HMAC State type defines the current (inner/outer)
+ * Hash state values. 
+ */
+typedef struct ubsec_HMAC_State_s {
+  unsigned char	InnerState[UBSEC_HMAC_LENGTH];
+  unsigned char	OuterState[UBSEC_HMAC_LENGTH];
+} ubsec_HMAC_State_t, *ubsec_HMAC_State_pt;
+
+
+typedef unsigned char* ubsec_MemAddress_t;
+
+
+/* 
+ * Generic Fragment information type. Length
+ * and physical address of fragment defined
+ * here.
+ */
+typedef struct ubsec_FragmentInfo_s {
+  int                 FragmentLength;  /* Length of the fragment.     */
+  PADIT(FragmentAddress_pad,8)
+  ubsec_MemAddress_t  FragmentAddress; /* Virtual or Physical address */
+} ubsec_FragmentInfo_t, *ubsec_FragmentInfo_pt;
+
+
+/*
+ * HMAC Block type. Used to generate a HMAC state which is
+ * passed to the API.
+ */
+typedef unsigned char ubsec_HMAC_Block_t[UBSEC_MAC_KEY_LENGTH],*ubsec_HMAC_Block_pt;
+
+/*
+ * HMAC Block type. Used to generate a HMAC state which is
+ * passed to the API.
+ */
+typedef unsigned char ubsec_HMAC_Key_t[UBSEC_MAC_KEY_LENGTH],*ubsec_HMAC_Key_pt;
+
+/*
+ * Initial Vector type for CBC operations.
+ */
+typedef long  ubsec_IV_t[UBSEC_IV_LENGTH], *ubsec_IV_pt;
+
+/*
+ * DES Key type definitions.
+ */
+
+/* Single DES Crypt key type. 3DES operation used 3 of these. */
+typedef long ubsec_CryptKey_t[UBSEC_DES_KEY_LENGTH], *ubsec_CryptKey_pt;
+
+/* Cipher command type defines Cipher/Authentication operation. */
+typedef long ubsec_CipherCommand_t;
+
+/* Status code is used by the SRL to indicate status */
+typedef long ubsec_Status_t;
+
+
+/*
+ * Cipher command struture defines the parameters of a cipher
+ * command, its input and output data areas along with the 
+ * context.
+ */
+typedef struct ubsec_CipherCommandInfo_s {
+  ubsec_CipherCommand_t   	Command;  /* Operation(s) to perform */
+  ubsec_IV_pt	   	        InitialVector;   /* IV for CBC operation. */
+  ubsec_CryptKey_pt 	        CryptKey;         /* For CBC operation. */
+  ubsec_HMAC_State_pt            HMACState;    /*  Initialized HMAC state for authentication. */
+  unsigned NumSource;                    /* Number of source fragments. */
+  ubsec_FragmentInfo_pt 	SourceFragments; /* Source fragment list */
+  UBS_UINT32 		NumDestination;  /* Number of Destination fragments. */
+  ubsec_FragmentInfo_pt         DestinationFragments;    /* Destination fragment list */
+  ubsec_FragmentInfo_t          AuthenticationInfo;       /* Authentication output location . */
+  unsigned short   		 CryptHeaderSkip; /* Size of crypt header to skip. */
+  void(*CompletionCallback)(unsigned long Context,ubsec_Status_t Result);  /* Callback routine on completion. */
+  unsigned long	   		 CommandContext;    /* Context (ID) of this command). */
+  } ubsec_CipherCommandInfo_t,*ubsec_CipherCommandInfo_pt;
+
+
+/*
+ * Cipher Command subtype flags.
+ */
+#define UBSEC_ENCODE		1
+#define UBSEC_DECODE		2
+#define UBSEC_3DES		4
+#define UBSEC_DES		8
+#define UBSEC_MAC_MD5		16
+#define UBSEC_MAC_SHA1		32
+
+/*
+ *	Command field definitions.
+ */
+#define UBSEC_ENCODE_3DES (UBSEC_ENCODE+UBSEC_3DES)
+#define UBSEC_DECODE_3DES (UBSEC_DECODE+UBSEC_3DES)
+#define UBSEC_ENCODE_DES  (UBSEC_ENCODE+UBSEC_DES)
+#define UBSEC_DECODE_DES  (UBSEC_DECODE+UBSEC_DES)
+
+#define UBSEC_ENCODE_3DES_MD5   (UBSEC_ENCODE_3DES+UBSEC_MAC_MD5)
+#define UBSEC_DECODE_3DES_MD5   (UBSEC_DECODE_3DES+UBSEC_MAC_MD5)
+#define UBSEC_ENCODE_3DES_SHA1  (UBSEC_ENCODE_3DES+UBSEC_MAC_SHA1)
+#define UBSEC_DECODE_3DES_SHA1  (UBSEC_DECODE_3DES+UBSEC_MAC_SHA1)
+#define UBSEC_ENCODE_DES_MD5	(UBSEC_ENCODE_DES+UBSEC_MAC_MD5)
+#define UBSEC_DECODE_DES_MD5	(UBSEC_DECODE_DES+UBSEC_MAC_MD5)
+#define UBSEC_ENCODE_DES_SHA1	(UBSEC_ENCODE_DES+UBSEC_MAC_SHA1)
+#define UBSEC_DECODE_DES_SHA1	(UBSEC_DECODE_DES+UBSEC_MAC_SHA1)
+
+#define UBSEC_USING_CRYPT(f) ( (f) & (UBSEC_3DES | UBSEC_DES) )
+#define UBSEC_USING_MAC(f)   ( (f) & (UBSEC_MAC_MD5 | UBSEC_MAC_SHA1) )
+
+/*
+ * Status codes
+ */
+#define UBSEC_STATUS_SUCCESS              0
+#define UBSEC_STATUS_NO_DEVICE           -1
+#define UBSEC_STATUS_TIMEOUT             -2
+#define UBSEC_STATUS_INVALID_PARAMETER   -3
+#define UBSEC_STATUS_DEVICE_FAILED       -4
+#define UBSEC_STATUS_DEVICE_BUSY         -5
+#define UBSEC_STATUS_NO_RESOURCE         -6
+#define UBSEC_STATUS_CANCELLED           -7
+
+  /* 
+   * SRL  API function prototypes.
+   */
+#ifndef OS_DeviceInfo_t
+#define OS_DeviceInfo_t void *
+#endif
+
+#ifndef OS_MemHandle_t
+#define OS_MemHandle_t void *
+#endif
+
+#ifndef UBSECAPI
+#define UBSECAPI
+#endif
+
+  /* Initialize the device */
+UBSECAPI ubsec_Status_t
+ubsec_InitDevice(unsigned short DeviceID,
+		 unsigned long BaseAddress,
+		 unsigned int irq,
+		 unsigned int CipherPipeLineDepth,
+		 unsigned int KeyPipeLineDepth,
+		 ubsec_DeviceContext_pt Context,
+		 OS_DeviceInfo_t OSContext);
+
+/*
+ * Perform self test of device.
+ */
+UBSECAPI ubsec_Status_t
+ubsec_TestCryptoDevice(ubsec_DeviceContext_t Context,void(*CompletionCallback)(unsigned long PacketContext,ubsec_Status_t Result),unsigned long CompletionContext);
+
+UBSECAPI ubsec_Status_t
+ubsec_TestKeyDevice(ubsec_DeviceContext_t Context,void(*CompletionCallback)(unsigned long PacketContext,ubsec_Status_t Result),unsigned long CompletionContext);
+
+
+  /* Reset the device */
+UBSECAPI ubsec_Status_t
+ubsec_ResetDevice( ubsec_DeviceContext_t Context);
+
+  /* Shutdown the device. */
+UBSECAPI ubsec_Status_t
+ubsec_ShutdownDevice( ubsec_DeviceContext_t Context);
+
+  /* Enable device interrupts */
+ubsec_Status_t
+ubsec_EnableInterrupt( ubsec_DeviceContext_t Context);
+
+  /* Disable device interrupts */
+unsigned long
+ubsec_DisableInterrupt( ubsec_DeviceContext_t Context);
+
+  /* Poll device for completion of commands */
+ubsec_Status_t
+ubsec_PollDevice( ubsec_DeviceContext_t Context);
+
+  /* Cipher command execute function. */
+UBSECAPI ubsec_Status_t
+ubsec_CipherCommand(ubsec_DeviceContext_t Context,
+		    ubsec_CipherCommandInfo_pt command,
+		    int *NumCommands);
+
+  /* Initialize HMAC state */
+UBSECAPI ubsec_Status_t
+ubsec_InitHMACState(ubsec_HMAC_State_pt HMAC_State,
+	      ubsec_CipherCommand_t type,
+	      ubsec_HMAC_Key_pt Key) ;
+
+/* ISR functions are here to allow direct call
+   by the wrapper. */
+UBSECAPI long ubsec_ISR(ubsec_DeviceContext_t Context);
+UBSECAPI void ubsec_ISRCallback(ubsec_DeviceContext_t Context);
+
+/*
+ *
+ * Public key operational definitions.
+ *
+ */
+
+
+/*
+ * The long key type is used as a generic type to hold public
+ * key information.
+ * KeyValue points to an array of 32-bit integers. The convention of these keys
+ * is such that element[0] of this array holds the least significant part of
+ * the total "key" (multi-precision integer).
+ * Keylength holds the number of significant bits in the key, i.e. the bit
+ * position of the most significant "1" bit, plus 1.
+ * For example, the multi-precision integer ("key")
+ *    0x0102030405060708090A0B0C0D0E0F00
+ * has 121 significant bits (KeyLength), and would be arranged in the N-element 
+ * array (pointed to by KeyLength) of 32-bit integers as
+ *    array[0] = 0x0D0E0F00
+ *    array[1] = 0x090A0B0C
+ *    array[2] = 0x05060708
+ *    array[3] = 0x01020304
+ *    array[4] = 0x00000000
+ *        ...
+ *    array[N-1] = 0x00000000
+ */
+
+typedef struct ubsec_LongKey_s {
+  UBS_UINT32	KeyLength;	/* length in bits */
+  PADIT(KeyValue_pad,8)
+  OS_MemHandle_t  KeyValue;	/* pointer to 32-bit integer "key" array */
+} ubsec_LongKey_t,*ubsec_LongKey_pt;
+
+
+/*
+ * Diffie-Hellman parameter type definition.
+ */
+typedef struct ubsec_DH_Params_t {
+  ubsec_LongKey_t Y;		/* Public value, in (UBSEC_DH_SHARED), out (UBSEC_DH_PUBLIC) */
+  ubsec_LongKey_t X;		/* Secret value, in (UBSEC_DH_SHARED), out (UBSEC_DH_PUBLIC) */
+  ubsec_LongKey_t K;		/* Shared secret value, out (UBSEC_DH_SHARED) */
+  ubsec_LongKey_t N;   		/* Modulus, in (UBSEC_DH_SHARED), out (UBSEC_DH_PUBLIC) */
+  ubsec_LongKey_t G;	  	/* Generator, in (UBSEC_DH_PUBLIC) */
+  ubsec_LongKey_t UserX;  	/* Optional user supplied secret value, in (UBSEC_DH_PUBLIC) */
+
+  unsigned short RandomKeyLen;	/* Random key length*/
+  unsigned short RNGEnable;	/* Generate random secret value if set, ignore user supplied. */
+} ubsec_DH_Params_t,*ubsec_DH_Params_pt;
+
+
+/*
+ * RSA parameter type definition.
+ */
+typedef struct ubsec_RSA_Params_t {
+  ubsec_LongKey_t OutputKeyInfo; /* Output data. */
+  ubsec_LongKey_t InputKeyInfo;  /* Input data. */
+  ubsec_LongKey_t ModN;      /* Modulo N value to be applied */
+  ubsec_LongKey_t ExpE;      /* BaseG value to be applied. */
+  ubsec_LongKey_t PrimeP;    /* Prime P value */
+  ubsec_LongKey_t PrimeQ;    /* Prime Q value */
+  ubsec_LongKey_t PrimeEdp;  /* Private exponent edp. */
+  ubsec_LongKey_t PrimeEdq;  /* Private exponent edq.  */
+  ubsec_LongKey_t Pinv;      /* Pinv value. */
+} ubsec_RSA_Params_t,*ubsec_RSA_Params_pt;
+
+
+
+/*
+ * DSA parameter type definition.
+ */
+typedef struct ubsec_DSA_Params_t {
+  unsigned int NumInputFragments;  /* Number of source fragments. */
+  PADIT(InputFragments_pad,8)
+  ubsec_FragmentInfo_pt InputFragments; /* Source fragment list for unhashed message */
+  ubsec_LongKey_t SigR;		/* Signature R value (input on verify, output on sign) */
+  ubsec_LongKey_t SigS;		/* Signature S value (input on verify, output on sign) */
+  ubsec_LongKey_t ModQ;   	/* Modulo Q value to be applied */
+  ubsec_LongKey_t ModP;   	/* Modulo P value to be applied */
+  ubsec_LongKey_t BaseG;  	/* BaseG value to be applied. */
+  ubsec_LongKey_t Key;    	/* User supplied public (verify) or private (sign) key. */
+  ubsec_LongKey_t Random; 	/* Random value optionally provided by user (sign) */
+  ubsec_LongKey_t V;		/* Verification value (verify) */
+  unsigned short RandomLen; 	/* Random value length (sign) */
+  unsigned short RNGEnable;    	/* Random value generated on-chip. (sign) */
+  unsigned short HashEnable;    /* Enable Chip hash */
+} ubsec_DSA_Params_t,*ubsec_DSA_Params_pt;
+
+/* 
+ * Generic key command parameters
+ */
+typedef union ubsec_KeyCommandParams_u {
+  ubsec_DH_Params_t DHParams;    /* DH parameters  */
+  ubsec_RSA_Params_t RSAParams;  /* RSA Parameters */
+  ubsec_DSA_Params_t DSAParams;  /* RSA Parameters */
+} ubsec_KeyCommandParams_t,*ubsec_KeyCommandParams_pt;
+
+
+
+/* Key command type defines Public key operation. */
+typedef long ubsec_KeyCommand_t;
+
+
+/* Key command types. */
+#define UBSEC_DH          0x0001
+#define UBSEC_RSA         0x0002
+#define UBSEC_DSA         0x0004
+#define UBSEC_KEY_PRIVATE 0x0010
+#define UBSEC_KEY_PUBLIC  0x0020
+#define UBSEC_SIGN        0x0040
+#define UBSEC_VERIFY      0x0080
+
+#define UBSEC_DH_PUBLIC    	(UBSEC_DH+UBSEC_KEY_PUBLIC)
+#define UBSEC_DH_SHARED    	(UBSEC_DH+UBSEC_KEY_PRIVATE)
+#define UBSEC_RSA_PUBLIC   	(UBSEC_RSA+UBSEC_KEY_PUBLIC)
+#define UBSEC_RSA_PRIVATE  	(UBSEC_RSA+UBSEC_KEY_PRIVATE)
+#define UBSEC_DSA_SIGN     	(UBSEC_DSA+UBSEC_SIGN)
+#define UBSEC_DSA_VERIFY   	(UBSEC_DSA+UBSEC_VERIFY)
+
+/*
+ * Key command struture defines the parameters of a cipher
+ * command, its input and output data areas along with the 
+ * context.
+ */
+typedef struct ubsec_KeyCommandInfo_s {
+  ubsec_KeyCommand_t   	Command;  /* Operation(s) to perform */
+  ubsec_KeyCommandParams_t Parameters;  /* Associated parameters. */
+  void(*CompletionCallback)(unsigned long Context,ubsec_Status_t Result);  /* Callback routine on completion. */
+  unsigned long	 CommandContext;    /* Context (ID) of this command). */
+  } ubsec_KeyCommandInfo_t,*ubsec_KeyCommandInfo_pt;
+
+  /* Key command execute function. */
+UBSECAPI ubsec_Status_t
+ubsec_KeyCommand(ubsec_DeviceContext_t Context,
+		    ubsec_KeyCommandInfo_pt command,
+		    int *NumCommands);
+
+/* 
+ * Key normalization maniputaltion functions.
+ */
+long ubsec_NormalizeDataTo(ubsec_LongKey_pt pData,int NormalizeLen);
+void ubsec_ShiftData(ubsec_LongKey_pt pData,long ShiftBits );
+
+/* 
+ * Generic Math command parameters. Parameters vary with the
+ * command type.
+ */
+typedef struct  ubsec_MathCommandParams_s {
+  ubsec_LongKey_t ModN;   	/* Modulo N value to be applied (Used by all commands) */
+  ubsec_LongKey_t ModN2;   	/* Second Modulo N value to be applied (Used by DblModExp only) */
+  ubsec_LongKey_t ParamA;   	/* Input Parameter 1 (Used by all commands) */
+  ubsec_LongKey_t ParamB;   	/* Input Parameter 2 (Used by all commands except ModRem) */
+  ubsec_LongKey_t ParamC;   	/* Input Parameter 3 (Used by DblModExp only) */
+  ubsec_LongKey_t ParamD;   	/* Input Parameter 4 (Used by DblModExp only) */
+  ubsec_LongKey_t Result;   	/* Result of math operation (Used by all commands) */
+  ubsec_LongKey_t Result2;   	/* Second result of math operation (Used by DblModExp only) */
+} ubsec_MathCommandParams_t,*ubsec_MathCommandParams_pt;
+
+/* Math command type defines Math acceleration operation. */
+typedef long ubsec_MathCommand_t;
+
+/* Math command types. */
+#define UBSEC_MATH_MODADD    0x0001
+#define UBSEC_MATH_MODSUB    0x0002
+#define UBSEC_MATH_MODMUL    0x0004
+#define UBSEC_MATH_MODEXP    0x0008
+#define UBSEC_MATH_MODREM    0x0010
+#define UBSEC_MATH_DBLMODEXP 0x0040
+
+/*
+ * Math command struture defines the parameters of a Math
+ * command, its input and output data areas along with the 
+ * context.
+ */
+typedef struct ubsec_MathCommandInfo_s {
+  ubsec_MathCommand_t   	Command;  /* Operation(s) to perform */
+  ubsec_MathCommandParams_t Parameters;  /* Associated parameters. */
+  void(*CompletionCallback)(unsigned long Context,ubsec_Status_t Result);  /* Callback routine on completion. */
+  unsigned long	 CommandContext;    /* Context (ID) of this command). */
+  } ubsec_MathCommandInfo_t,*ubsec_MathCommandInfo_pt;
+
+/*
+ * Math acceleration command function.
+ */
+UBSECAPI ubsec_Status_t 
+ubsec_MathCommand(ubsec_DeviceContext_t Context,
+	      ubsec_MathCommandInfo_pt pCommand,
+	      int *NumCommands);
+
+
+/* 
+ * Random number generation parameters
+ */
+typedef struct  ubsec_RNGCommandParams_s {
+  ubsec_LongKey_t Result;   	/* Of RNG operation. */
+} ubsec_RNGCommandParams_t,*ubsec_RNGCommandParams_pt;
+
+/* RNG command type defines RNG acceleration operation. */
+typedef long ubsec_RNGCommand_t;
+
+/* RNG command types. */
+#define UBSEC_RNG_DIRECT 0x0001
+#define UBSEC_RNG_SHA1   0x0002
+
+/*
+ * RNG command struture defines the parameters of a RNG
+ * command, its input and output data areas along with the 
+ * context.
+ */
+typedef struct ubsec_RNGCommandInfo_s {
+  ubsec_RNGCommand_t   	Command;  /* Operation(s) to perform */
+  ubsec_RNGCommandParams_t Parameters;  /* Associated parameters. */
+  void(*CompletionCallback)(unsigned long Context,ubsec_Status_t Result);  /* Callback routine on completion. */
+  unsigned long	 CommandContext;    /* Context (ID) of this command). */
+  } ubsec_RNGCommandInfo_t,*ubsec_RNGCommandInfo_pt;
+
+/*
+ * RNG acceleration command function.
+ */
+UBSECAPI ubsec_Status_t 
+ubsec_RNGCommand(ubsec_DeviceContext_t Context,
+	      ubsec_RNGCommandInfo_pt pCommand,
+	      int *NumCommands);
+
+
+/*
+ * Ubsec Statistics information contains all statistics 
+ * maintained by the driver.
+ */
+typedef struct ubsec_Statistics_s {
+  UBS_UINT32 BlocksEncryptedCount;
+  UBS_UINT32 BlocksDecryptedCount;
+  UBS_UINT32 BytesEncryptedCount;
+  UBS_UINT32 BytesDecryptedCount;
+  UBS_UINT32 CryptoFailedCount;
+  UBS_UINT32 IKECount;
+  UBS_UINT32 IKEFailedCount;
+  UBS_UINT32 DHPublicCount;
+  UBS_UINT32 DHSharedCount;
+  UBS_UINT32 RSAPublicCount;
+  UBS_UINT32 RSAPrivateCount;
+  UBS_UINT32 DSASignCount;
+  UBS_UINT32 DSAVerifyCount;
+  UBS_UINT32 DMAErrorCount;
+  } ubsec_Statistics_t, *ubsec_Statistics_pt;
+
+
+/*
+ * Ubsec get statistical information function.
+ */
+UBSECAPI ubsec_Status_t 
+ubsec_GetStatistics(ubsec_DeviceContext_t Context,
+	      ubsec_Statistics_pt Dest);
+
+
+/* 
+ * SSL/TLS/ARC4 Command prototype definitions
+ */
+
+/*
+ *  SSL Command definitions. These commands will be ored in with
+ * crypto commands.
+ */
+
+#define UBSEC_SSL_HMAC         (0x01000)
+#define UBSEC_SSL_MAC         (0x01000)
+#define UBSEC_SSL_CRYPTO      (0x02000)
+#define UBSEC_TLS             (0x04000)
+#define UBSEC_ARC4            (0x08000)
+#define UBSEC_HASH            (0x10000)
+
+#define UBSEC_SSL_DES_ENCODE (UBSEC_SSL_CRYPTO+UBSEC_ENCODE+UBSEC_3DES)
+#define UBSEC_SSL_DES_DECODE (UBSEC_SSL_CRYPTO+UBSEC_ENCODE+UBSEC_DES)
+#define UBSEC_SSL_HMAC_MD5   (UBSEC_SSL_HMAC+UBSEC_MAC_MD5)
+#define UBSEC_SSL_HMAC_SHA1  (UBSEC_SSL_HMAC+UBSEC_MAC_SHA1)
+#define UBSEC_SSL_MAC_MD5    (UBSEC_SSL_MAC+UBSEC_MAC_MD5)
+#define UBSEC_SSL_MAC_SHA1   (UBSEC_SSL_MAC+UBSEC_MAC_SHA1)
+#define UBSEC_TLS_HMAC_MD5   (UBSEC_TLS+UBSEC_MAC_MD5)
+#define UBSEC_TLS_HMAC_SHA1  (UBSEC_TLS+UBSEC_MAC_SHA1)
+#define UBSEC_HASH_SHA1      (UBSEC_HASH | UBSEC_MAC_SHA1)
+#define UBSEC_HASH_MD5       (UBSEC_HASH | UBSEC_MAC_MD5)
+
+#define UBSEC_ARC4_STATE_WRITEBACK  0x0001
+#define UBSEC_ARC4_STATE_STATEKEY   0x0002
+#define UBSEC_ARC4_STATE_NULL_DATA  0x0004
+
+#define UBSEC_SSL_COMMAND_MASK (UBSEC_SSL_MAC+UBSEC_SSL_CRYPTO+UBSEC_TLS+UBSEC_ARC4+UBSEC_HASH)
+#define UBSEC_SSL_COMMAND(command) (command & (UBSEC_SSL_COMMAND_MASK))
+
+/*
+ * Type Definitions:
+ */
+typedef unsigned char ubsec_SSLMAC_key_t[UBSEC_HMAC_LENGTH], *ubsec_SSLMAC_key_pt;
+
+/* Sequence number type. Double DWORD. */
+typedef struct ubsec_DoubleSequenceNumber_s {
+  UBS_UINT32 HighWord;
+  UBS_UINT32 LowWord;
+} ubsec_DoubleSequenceNumber_t, *ubsec_DoubleSequenceNumber_pt;
+
+typedef struct ubsec_SSLMACParams_s {
+  ubsec_FragmentInfo_t         OutputHMAC;      /* output MAC */
+  ubsec_SSLMAC_key_t           key;             /* MAC key */
+  ubsec_DoubleSequenceNumber_t SequenceNumber;  /* sequence number */
+  unsigned char                ContentType;     /* content type */
+  unsigned short               DataLength;
+} ubsec_SSLMACParams_t, *ubsec_SSLMACParams_pt;
+
+typedef struct ubsec_TLSHMACParams_s {
+  ubsec_FragmentInfo_t          OutputHMAC; /* output MAC */
+  ubsec_HMAC_State_pt           HMACState; /* HMAC State */
+  ubsec_DoubleSequenceNumber_t   SequenceNumber;     /* sequence number */
+  unsigned char ContentType;        /* content type */
+  unsigned short Version;        /* Version */
+  unsigned short DataLength;
+} ubsec_TLSHMACParams_t, *ubsec_TLSHMACParams_pt;
+
+typedef struct ubsec_SSLCipherParams_t {
+  ubsec_IV_t         InitialVector;              /* initial vector */
+  UBS_UINT32 CryptKey[UBSEC_3DES_KEY_LENGTH];
+} ubsec_SSLCipherParams_t, *ubsec_SSLCipherParams_pt;
+
+#define UBSEC_ARC4_KEYSTATE_BYTES (260)
+typedef unsigned char ubsec_ARC4_State_t[UBSEC_ARC4_KEYSTATE_BYTES], *ubsec_ARC4_State_pt;
+
+typedef struct ubsec_SSLARC4Params_t {
+  ubsec_ARC4_State_pt  KeyStateIn;       /* key or state data */
+  UBS_UINT32          KeyStateFlag;  /* start with key or start from flag */
+  ubsec_FragmentInfo_t  state_out;       /* state upon completing this arc4 operation */
+} ubsec_ARC4Params_t, *ubsec_ARC4Params_pt;
+
+typedef struct ubsec_HashParams_t {
+  ubsec_FragmentInfo_t          OutputHMAC; /* output MAC */
+} ubsec_HashParams_t, *ubsec_HashParams_pt;
+
+typedef union ubsec_SSLParams_u {
+  ubsec_SSLMACParams_t    SSLMACParams;
+  ubsec_SSLCipherParams_t SSLCipherParams;
+  ubsec_TLSHMACParams_t    TLSHMACParams;
+  ubsec_ARC4Params_t      ARC4Params;
+  ubsec_HashParams_t      HashParams;
+} ubsec_SSLCommandParams_t, *ubsec_SSLCommandParams_pt;
+
+typedef UBS_UINT32 ubsec_SSLCommand_t;
+
+typedef struct ubsec_SSLCommandInfo_s {
+  ubsec_SSLCommand_t        Command;
+  ubsec_SSLCommandParams_t  Parameters;
+  unsigned long             CommandContext;
+  unsigned int NumSource;                    /* Number of source fragments. */
+  ubsec_FragmentInfo_pt 	SourceFragments; /* Source fragment list */
+  UBS_UINT32 		NumDestination;  /* Number of Destination fragments. */
+  ubsec_FragmentInfo_pt           DestinationFragments;    /* Destination fragment list */
+  void(*CompletionCallback)(unsigned long Context, ubsec_Status_t Result);
+} ubsec_SSLCommandInfo_t, *ubsec_SSLCommandInfo_pt;
+
+
+  /* SSL command execute function. */
+UBSECAPI ubsec_Status_t
+ubsec_SSLCommand(ubsec_DeviceContext_t Context,
+		    ubsec_SSLCommandInfo_pt command,
+		    int *NumCommands);
+
+
+
+/* 
+ * Extended ChipInfo prototype definitions
+ */
+
+/* Parameter structure, used at IOCTL and in SRL */
+typedef struct ubsec_chipinfo_io_s {
+  unsigned int     Status;
+  unsigned int     CardNum;
+  unsigned int     MaxKeyLen;
+  unsigned short   DeviceID;
+  UBS_UINT32       BaseAddress;
+  int              IRQ; 
+  int              NumDevices;
+  unsigned int     Features;
+} ubsec_chipinfo_io_t, *ubsec_chipinfo_io_pt;
+
+
+/* ubsec_chipinfo_io_pt->features bit definitions */
+#define UBSEC_EXTCHIPINFO_SRL_BE         0x00000001
+#define UBSEC_EXTCHIPINFO_CPU_BE         0x00000002
+#define UBSEC_EXTCHIPINFO_ARC4_NULL      0x00000004
+#define UBSEC_EXTCHIPINFO_ARC4           0x00000008
+#define UBSEC_EXTCHIPINFO_3DES           0x00000010
+#define UBSEC_EXTCHIPINFO_RNG            0x00000020
+#define UBSEC_EXTCHIPINFO_DBLMODEXP      0x00000040
+#define UBSEC_EXTCHIPINFO_KEY_OVERRIDE   0x00000080
+#define UBSEC_EXTCHIPINFO_SSL            0x00000100
+
+/* 
+ * DVT prototype definitions
+ */
+
+/* Parameter structure, used at IOCTL and in SRL */
+typedef struct DVT_Params_s {
+  int           Command;
+  int           CardNum;
+  UBS_UINT32 	InParameter;    /* should this be left as unsigned long */
+  UBS_UINT32 	OutParameter;   /* should this be left as unsigned long */
+  unsigned long Status;
+  /* Add new structure members to end of existing member list */
+} DVT_Params_t, *DVT_Params_pt;
+
+/* DVT Command codes */
+#define UBSEC_DVT_MCR1_SUSPEND    1
+#define UBSEC_DVT_MCR1_RESUME     2
+#define UBSEC_DVT_MCR2_SUSPEND    3
+#define UBSEC_DVT_MCR2_RESUME     4
+#define UBSEC_DVT_NEXT_MCR1       5
+#define UBSEC_DVT_NEXT_MCR2       6
+#define UBSEC_DVT_PAGESIZE        7
+#define UBSEC_DVT_ALL_MCR_RESUME  8
+
+/* pDevice->DVTOptions bit definitions */
+#define UBSEC_SUSPEND_MCR1        0x00000001
+#define UBSEC_SUSPEND_MCR2        0x00000002
+
+
+
+#endif /* _UBSEC_H_ */
diff -urNp linux-8030/drivers/addon/bcm/ubsextrn.h linux-8040/drivers/addon/bcm/ubsextrn.h
--- linux-8030/drivers/addon/bcm/ubsextrn.h
+++ linux-8040/drivers/addon/bcm/ubsextrn.h
@@ -0,0 +1,79 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubsextrn.h:  ubsec internal function prototype and variable declarations
+ */
+
+/*
+ * Revision History:
+ *
+ * 09/xx/99 SOR Created
+ * 10/09/01 SRM 64 bit port.
+ */
+
+#ifndef _UBSEXTRN_H_
+#define _UBSEXTRN_H_
+
+/*
+ * Function prototype defintions.
+ */
+extern void completion_handler( void* p_void );
+extern DeviceInfo_pt AllocDeviceInfo(unsigned long DeviceID,int NumberOfCipherMCRs,int NumberOfKeyMCRs,OS_DeviceInfo_t OSContext);
+extern void  FreeDeviceInfo(DeviceInfo_pt pDevice );
+extern ubsec_Status_t SetupInputFragmentList(MasterCommand_pt  pMCR,
+		       Packet_pt pPacket,
+		       int NumSource,
+		       ubsec_FragmentInfo_pt SourceFragments);
+extern ubsec_Status_t SetupOutputFragmentList(MasterCommand_pt  pMCR,
+			Packet_pt pPacket,
+			int NumFrags,
+			ubsec_FragmentInfo_pt DestinationFragments,
+			ubsec_FragmentInfo_pt pExtraFragment);
+extern void revBytes(void *st, int len);
+extern UBS_UINT32  rol(UBS_UINT32 x, int n);
+extern void copywords(UBS_UINT32 *out, UBS_UINT32 *in,int num);
+extern void InitSHA1State(ubsec_HMAC_State_pt HMAC_State,unsigned char *HashBlock);
+extern void InitMD5State(ubsec_HMAC_State_pt HMAC_State,unsigned char *HashKey);
+extern int WaitForCompletion(DeviceInfo_pt pDevice,unsigned long blockus,unsigned long MCRListIndex);
+extern void Dump_Registers(DeviceInfo_pt pDevice,int dbg_flag);
+extern void ubsec_DumpDeviceInfo(ubsec_DeviceContext_t Context);
+extern void PushMCR(DeviceInfo_pt pDevice);
+extern void FlushDevice(DeviceInfo_pt pDevice,ubsec_Status_t Status,unsigned int type);
+extern int dump_MCR(DeviceInfo_pt pDevice,MasterCommand_pt pMCR,unsigned long MCRListIndex);
+extern ubsec_Status_t DH_SetupPublicParams(MasterCommand_pt pMCR, ubsec_DH_Params_pt pDHParams);
+extern ubsec_Status_t DH_SetupSharedParams(MasterCommand_pt pMCR, ubsec_DH_Params_pt pDHParams);
+extern ubsec_Status_t RSA_SetupPublicParams(MasterCommand_pt pMCR, ubsec_RSA_Params_pt pRSAParams);
+extern ubsec_Status_t RSA_SetupPrivateParams(MasterCommand_pt pMCR, ubsec_RSA_Params_pt pRSAParams);
+extern ubsec_Status_t DSA_SetupSignParams(MasterCommand_pt pMCR, ubsec_DSA_Params_pt pDSAParams);
+extern ubsec_Status_t DSA_SetupVerifyParams(MasterCommand_pt pMCR, ubsec_DSA_Params_pt pDSAParams);
+extern MasterCommand_pt GetFreeMCR(  DeviceInfo_pt pDevice,int MCRList,ubsec_Status_t *Status);
+extern void KeyFinishResult(unsigned long Context,ubsec_Status_t Result);
+
+/*
+ * External variable definitions.
+ */
+
+#endif  /* _UBSEXTRN_H_ */
+
diff -urNp linux-8030/drivers/addon/bcm/ubsincl.h linux-8040/drivers/addon/bcm/ubsincl.h
--- linux-8030/drivers/addon/bcm/ubsincl.h
+++ linux-8040/drivers/addon/bcm/ubsincl.h
@@ -0,0 +1,51 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubsincl.h:  ubsec main include file
+ */
+
+/*
+ * Revision History:
+ *
+ * 09/xx/99 SOR Created.
+ */
+
+#ifndef _UBSINCL_H_
+#define _UBSINCL_H_
+
+#include "ubsdefs.h"
+#include "ubsdebug.h"
+#include "ubsec.h"
+#include "ubskey.h"
+#include "ubscrypt.h"
+#include "ubsctl.h"
+#include "ubsstruc.h"
+#include "ubssha1.h"
+#include "ubsmd5.h"
+#include "ubsextrn.h"
+#include "ubslinux.h"
+
+#endif /* _UBSINCL_H_ */
+
diff -urNp linux-8030/drivers/addon/bcm/ubsinit.c linux-8040/drivers/addon/bcm/ubsinit.c
--- linux-8030/drivers/addon/bcm/ubsinit.c
+++ linux-8040/drivers/addon/bcm/ubsinit.c
@@ -0,0 +1,283 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubsinit.c:  ubsec initialization and cleanup modules.
+ */
+
+/*
+ * Revision History:
+ *
+ * 09/xx/1999 SOR Created.
+ * 07/16/2001 RJT Added support for BCM5821
+ * 10/09/2001 SRM 64 bit port
+ */
+
+#include "ubsincl.h"
+
+/*
+ * ubsec_InitDevice:
+ *
+ * Initialize a device for operation. 
+ * Return a status indicating result of the initialization 
+ * along with a context to be used in further device operations.
+ */
+ubsec_Status_t
+ubsec_InitDevice(unsigned short DeviceID,   /* PCI device ID */
+		 unsigned long BaseAddress,  /* Physical address of device */
+		 unsigned int irq,           /* IRQ of device. */
+		 unsigned int CipherPipeLineDepth, /* Number of Cipher MCRs */
+		 unsigned int KeyPipeLineDepth,   /* Number of key MCRS */
+		 ubsec_DeviceContext_pt Context,  /* Pointer to context */
+		 OS_DeviceInfo_t OSContext)	/* pointer to OS-specific device context */
+{
+  DeviceInfo_pt pDevice;
+  UBS_UINT32 *tmpAddress;
+  int i;
+  int NumRegs;
+
+    /* announce ourselves */
+  Dbg_Print(DBG_VERSION,( "ubSec: SRL v%d.%x%c\n",UBSEC_VERSION_MAJOR,UBSEC_VERSION_MINOR,UBSEC_VERSION_REV));
+  
+#ifdef UBSEC_582x_CLASS_DEVICE
+  if (DeviceID < BROADCOM_DEVICE_ID_5820) {
+    Dbg_Print(DBG_INITD,( "ubSec:  SRL configuration not compatible with the BCM580x!\n" ));
+    return(UBSEC_STATUS_NO_DEVICE );
+  }
+#else
+  if (DeviceID > BROADCOM_DEVICE_ID_5805) {
+    Dbg_Print(DBG_INITD,( "ubSec:  SRL configuration not compatible with the BCM5820/5821!\n" ));
+    return(UBSEC_STATUS_NO_DEVICE );
+  }
+#endif
+
+  /*
+   * Allocate and initialize the device information structure.
+   */
+  if ((pDevice = AllocDeviceInfo((unsigned long) DeviceID,CipherPipeLineDepth,KeyPipeLineDepth,OSContext)) == NULL) {
+    Dbg_Print(DBG_INITD,( "ubSec:  Alloc context failed!\n" ));
+    return(UBSEC_STATUS_NO_RESOURCE );
+  }
+  Dbg_Print(DBG_INITD,( "ubSec: Alloc Info OK\n"));
+
+  /* 
+   * Save pointer to OS device context
+   */
+  pDevice->OsDeviceInfo = OSContext;
+  pDevice->Status=UBSEC_STATUS_SUCCESS;
+	
+  /* 
+   * Save Device ID information.
+   */
+  pDevice->BaseAddress=BaseAddress; /* Save for ID purpose */
+  pDevice->IRQ=irq;
+    /* Save the OS context */
+
+  if (UBSEC_IS_CRYPTO_DEVICEID(DeviceID)) {
+    NumRegs= UBSEC_CRYPTO_DEVICE_REGISTERS;
+    pDevice->IntAckMask=UBSEC_CRYPTO_DEVICE_IACK_MASK;
+    pDevice->IntEnableMask=UBSEC_CRYPTO_DEVICE_IENABLE_MASK;
+  }
+  else {
+    NumRegs=UBSEC_KEY_DEVICE_REGISTERS;
+    pDevice->IntAckMask=UBSEC_KEY_DEVICE_IACK_MASK;
+    pDevice->IntEnableMask=UBSEC_KEY_DEVICE_IENABLE_MASK;
+  }
+
+  if (DeviceID >= BROADCOM_DEVICE_ID_5821) {
+    /* The MCRn_ALL_EMPTY bits do not have their own enable bits. */
+    /* They will cause H/W interrupts if the associated MCRn_DONE */
+    /* interrupt is enabled. Even though the EMPTY bits are reset */
+    /* when the associated MCRn_DONE bit is ack'd, they should be */
+    /* ack'd along with the DONE bits just in case the associated */
+    /* MCRn_DONE interrupts were suppressed.                      */
+    pDevice->IntAckMask |= (MCR1_ALL_EMPTY | MCR2_ALL_EMPTY);
+    /* Set the CryptoNet endianess bits here */
+   #if (defined(UBSEC_582x) && (UBS_CRYPTONET_ATTRIBUTE == UBS_BIG_ENDIAN))
+    /* SRL was built with BCM582x in mind; enable H/W big endian mode */
+    pDevice->ResetConfig = UBS_BIG_ENDIAN_MODE;
+   #else
+    /* Device must use H/W little endian mode */
+    pDevice->ResetConfig = UBS_LITTLE_ENDIAN_MODE;
+   #endif
+    /* Set the Interrupt Suppress bit here */
+   #if (defined(UBSEC_582x) && defined(COMPLETE_ON_COMMAND_THREAD)) 
+    /* SRL was built with BCM582x in mind, and we complete during command issuance */
+    pDevice->InterruptSuppress = MCR_INTERRUPT_SUPPRESS;
+   #else /* 5820 mode (fall back to BCM5820 functionality) */
+    pDevice->InterruptSuppress = 0;
+   #endif /* InterruptSuppress en/disable */
+   #ifndef UBSEC_HW_NORMALIZE
+    /* To enable SW normalization in 5821 chip */
+    pDevice->ResetConfig |= SW_NORM_EN;
+   #endif
+  }
+  else if (DeviceID == BROADCOM_DEVICE_ID_5820) {
+    /* Set the CryptoNet endianess bits here */
+    pDevice->ResetConfig = UBS_LITTLE_ENDIAN_MODE;
+    /* Set the Interrupt Suppress bit here */
+    pDevice->InterruptSuppress = 0;
+   #ifndef UBSEC_HW_NORMALIZE
+    /* To enable HW normalization in 5820 chip */
+    pDevice->ResetConfig |= SW_NORM_EN;
+   #endif
+  }
+  else {
+    /* Set the CryptoNet endianess bits here */
+    pDevice->ResetConfig = UBS_LITTLE_ENDIAN_MODE;
+    /* Set the Interrupt Suppress bit here */
+    pDevice->InterruptSuppress = 0;
+  }
+      
+
+
+  /* Map the physical base address to our address space. */
+  tmpAddress=(UBS_UINT32 *) OS_MapPhysToIO(pDevice,pDevice->BaseAddress,NumRegs*sizeof(UBS_UINT32));
+
+  Dbg_Print(DBG_INITD,( "ubSec: Map Address %08x\n",tmpAddress));
+
+    /* Save the device registers for easy access */
+  for (i=0; i < UBSEC_MAXREGISTERS; i++)
+    pDevice->ControlReg[i] = tmpAddress++; 
+
+    /* Just in case acknowledge pending interrupts */
+  UBSEC_ACK_INT(pDevice);
+
+    /* Make sure that nothing is happening. */
+  UBSEC_RESET_DEVICE(pDevice);
+
+  *Context= (ubsec_DeviceContext_t) pDevice; 
+
+  Dbg_Print(DBG_INITD,( "ubSec: Device Reset\n"));
+
+#ifndef POLL
+    /* Allocate our ISR and enable interrupts */
+  OS_AllocateISR(irq, pDevice, ubsec_ISR);
+  UBSEC_ENABLE_INT(pDevice);
+#else
+  UBSEC_DISABLE_INT(pDevice);
+#endif
+
+
+  OS_InitCriticalSection(pDevice);
+
+  Dbg_Print(DBG_INITD,( "ubSec: Init OK\n"));
+
+  return (UBSEC_STATUS_SUCCESS);
+}
+
+/*
+ * ubsec_ShutdownDevice:
+ *
+ * Disable the device from operating and free up any related resources.
+ */
+ubsec_Status_t
+ubsec_ShutdownDevice( ubsec_DeviceContext_t Context)
+{
+  unsigned long i;
+
+  /* To keep the compiler happy.... */
+  DeviceInfo_pt pDevice=(DeviceInfo_pt)Context;
+    
+  Dbg_Print(DBG_INIT,( "ubSec:  Shutdown device \n" ));
+  UBSEC_DISABLE_INT(pDevice);
+
+#ifndef POLL  
+  /* free up irq and disable device interrupts */
+  OS_FreeISR(pDevice->IRQ,pDevice);
+#endif
+
+  /* Wait for outstanding requests to complete */
+  for (i=0; i < pDevice->NumberOfMCRLists ; i++) {
+    while (WaitForCompletion(pDevice,1000000,i)
+	   == UBSEC_STATUS_SUCCESS);
+  }
+
+  UBSEC_RESET_DEVICE(pDevice);
+
+  UBSEC_DISABLE_INT(pDevice);
+  UBSEC_ACK_INT(pDevice);
+
+  /* Complete pending events that have not completed*/
+  FlushDevice(pDevice,UBSEC_STATUS_CANCELLED,FLUSH_ALL);
+
+  /* Free up the device information resource. */
+  FreeDeviceInfo( pDevice );
+  return(UBSEC_STATUS_SUCCESS);
+}
+
+/*
+ * ubsec_ResetDevice:
+ *
+ * Reset the device.
+ */
+ubsec_Status_t
+ubsec_ResetDevice( ubsec_DeviceContext_t Context)
+{
+  unsigned long i;
+  DeviceInfo_pt pDevice=(DeviceInfo_pt)Context;
+  unsigned long SaveConfig;
+
+  if (OS_EnterCriticalSection(pDevice,SaveConfig)) {
+    return(UBSEC_STATUS_DEVICE_BUSY);
+  }
+
+ 
+#ifndef POLL
+ /* Disable interrupts while resetting. */
+  UBSEC_DISABLE_INT(pDevice);
+#endif
+
+  /* Wait for outstanding requests to complete */
+  for (i=0; i < pDevice->NumberOfMCRLists ; i++) {
+    while (WaitForCompletion( pDevice,1000000,i)
+	 == UBSEC_STATUS_SUCCESS);
+  }
+
+  UBSEC_RESET_DEVICE(pDevice);
+
+  /* Complete pending events that have not completed*/
+  FlushDevice(pDevice,UBSEC_STATUS_CANCELLED,FLUSH_ALL);
+  pDevice->Status=UBSEC_STATUS_SUCCESS;
+
+#ifndef POLL
+  /* Reenable interrupts */
+    UBSEC_ENABLE_INT(pDevice);
+#endif
+
+#ifdef UBSEC_STATS
+  RTL_MemZero(&pDevice->Statistics,sizeof(pDevice->Statistics));
+#endif	
+
+  OS_LeaveCriticalSection(pDevice,SaveConfig);
+  return(UBSEC_STATUS_SUCCESS);
+}
+
+
+
+
+
+
+
+
diff -urNp linux-8030/drivers/addon/bcm/ubsint.c linux-8040/drivers/addon/bcm/ubsint.c
--- linux-8030/drivers/addon/bcm/ubsint.c
+++ linux-8040/drivers/addon/bcm/ubsint.c
@@ -0,0 +1,255 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubsint.c: Ubsec interrupt processing functions.
+ *
+ * ubsec Interrupt service routine. Most OS's (at least the multitasking ones
+ * treat interrupt processing as a two stage process. One is to servce the IRQ
+ * delete the interrupt condition and schedule a callback to do the bulk processing
+ * at a lower priority time.
+ *
+ * The second process is to do the bulk processing itself. This module handles that
+ * case. In the case that all int processing can be done at IRQ time then scheduling
+ * the callback can call the bulk processing call directly
+ */
+
+/*
+ * Revision History:
+ *
+ * 09/xx/1999 SOR Created.
+ * 12/02/1999 DWP Modified to handle Big Endian architecture
+ * 07/06/2000 DPA Fixes for SMP operation
+ * 04/23/2001 RJT Added support for CPU-DMA memory synchronization
+ * 07/16/2001 RJT Added support for BCM5821
+ * 10/09/2001 SRM 64 bit port.
+ */
+
+#include "ubsincl.h"
+
+/*
+ * ubsec_ISR
+ * 
+ * Called when interrupt occurs. If interrupt is from us, disable
+ * further interrupts and return an indication that the interupt
+ * came from us. Otherwise just return 0.
+ */
+long 
+ubsec_ISR(ubsec_DeviceContext_t Context)
+{
+  DeviceInfo_pt pDevice=(DeviceInfo_pt)Context;
+  VOLATILE UBS_UINT32 InterruptCondition=0;    
+
+  Dump_Registers(pDevice,DBG_IRQ);
+  
+  if (UBSEC_IRQ_ENABLED(pDevice)) {
+    InterruptCondition=(UBSEC_READ_STATUS(pDevice) & pDevice->IntAckMask);
+    if (InterruptCondition) {  
+      /* Disable the interrupt mask on device and ... */
+      UBSEC_DISABLE_INT(pDevice);
+
+	 UBSEC_ACK_CONDITION(pDevice,InterruptCondition);
+      if (InterruptCondition & DMA_ERROR ) {
+	Dump_Registers(pDevice,DBG_FATAL);
+	pDevice->Status=UBSEC_STATUS_DEVICE_FAILED;
+      }
+
+      if (InterruptCondition & MCR1_DONE ) {
+	Dbg_Print(DBG_IRQ,( "ubsec:  irq handler mcr1 done\n" ));
+      }
+      else if (InterruptCondition & MCR1_ALL_EMPTY ) {
+	Dbg_Print(DBG_IRQ,( "ubsec:  irq handler mcr1 empty\n" ));
+      }
+      if (InterruptCondition & MCR2_DONE ) {
+	Dbg_Print(DBG_IRQ,( "ubsec:  irq handler mcr2 done\n" ));
+      }
+      else if (InterruptCondition & MCR2_ALL_EMPTY ) {
+	Dbg_Print(DBG_IRQ,( "ubsec:  irq handler mcr2 empty\n" ));
+      }
+
+      Dump_Registers(pDevice,DBG_IRQ);
+      OS_ScheduleCallBack(ubsec_ISRCallback,pDevice);
+    }
+  }
+ return(InterruptCondition);	
+
+}
+
+/*
+ * ubsec_ISRCallback:
+ *
+ * This routine is scheduled at ISR time to do batch
+ * processing for the device.
+ * 
+ * Interrupts are also reenabled for the device.
+ */
+void
+ubsec_ISRCallback(ubsec_DeviceContext_t Context)
+{
+  DeviceInfo_pt pDevice=(DeviceInfo_pt)Context;
+  unsigned long InterruptCondition;
+  unsigned long SaveConfig;
+
+  /* Reread the latest status. */
+  Dbg_Print(DBG_TEST,("ubsec_ISRCallback Entered\n"));
+  InterruptCondition=(UBSEC_READ_STATUS(pDevice) & pDevice->IntAckMask);
+  /* Now ack the interrupt condition. */
+  UBSEC_ACK_CONDITION(pDevice,InterruptCondition);
+
+#ifndef COMPLETE_ON_COMMAND_THREAD
+  ubsec_PollDevice(pDevice); /* Always poll for good completions */
+#endif
+  if (InterruptCondition & DMA_ERROR) 
+     pDevice->Status=UBSEC_STATUS_DEVICE_FAILED;
+  if (pDevice->Status!=UBSEC_STATUS_SUCCESS)  {
+    Dbg_Print(DBG_FATAL,( "CryptoNet:  DMA Reset\n"));	  
+#ifdef UBSEC_STATS
+      pDevice->Statistics.DMAErrorCount++;
+#endif
+    FlushDevice(pDevice,pDevice->Status,FLUSH_ONLY_PUSHED);
+    UBSEC_RESET_DEVICE(pDevice);
+    pDevice->Status=UBSEC_STATUS_SUCCESS;
+  }
+  /*
+   * Check to see if more need to be pushed to the device.
+   */
+  if (OS_TestCriticalSection(pDevice,SaveConfig)==0) {
+    PushMCR(pDevice);
+#ifdef COMPLETE_ON_COMMAND_THREAD
+    ubsec_PollDevice(pDevice); /* Always poll for good completions */
+#endif
+    OS_LeaveCriticalSection(pDevice,SaveConfig);
+  }
+
+#ifndef POLL
+  /* reenable interrupts */
+  UBSEC_ENABLE_INT(pDevice);
+#endif
+
+}
+
+
+/*
+ * ubsec_PollDevice:
+ *
+ * This routine is used to poll a device for command completion.
+ * Commands will be completed (callbacks called) from within
+ * this call.
+ *
+ * Returns UBSEC_STATUS_SUCCESS
+ */
+ubsec_Status_t
+ubsec_PollDevice(ubsec_DeviceContext_t Context)
+{
+DeviceInfo_pt pDevice=(DeviceInfo_pt)Context;
+VOLATILE MasterCommand_t *pMCR;
+VOLATILE int j;
+VOLATILE CallBackInfo_t *pCallBack;
+int NumberOfPackets;
+unsigned long MCRListIndex;
+ubsec_Status_t  Status=UBSEC_STATUS_SUCCESS;
+
+Dbg_Print(DBG_IRQ,( "ubsec completion handler \n" ));
+
+pDevice->InCriticalSection++;
+     
+  /* While there are MCRs to complete, do it. */
+for (MCRListIndex=0; MCRListIndex < pDevice->NumberOfMCRLists ;MCRListIndex++) {
+  for (;;) {
+     pMCR = pDevice->NextDoneMCR[MCRListIndex];
+     Dbg_Print(DBG_MCR_SYNC,( "ubsec: ubsec_PollDevice() Sync Flags to CPU (0x%08X,%d,%d)\n",pMCR->MCRMemHandle,pMCR->MCRMemHandleOffset,4));
+     OS_SyncToCPU(pMCR->MCRMemHandle,
+		  pMCR->MCRMemHandleOffset,4); /* Just need to sync flags */
+      /* Now check to see if there are any to complete */
+     if (pMCR->Flags & MCR_FLAG_COMPLETION)  {
+#ifdef UBSDBG
+/* Debug code for 5805 key operation. */
+     if (UBSEC_IS_KEY_DEVICE(pDevice) && (MCRListIndex)) {
+         if (pMCR->Flags & 0x02)
+	    Dbg_Print(DBG_CMD_FAIL,( "ubsec:  Command Fail %x\n", pMCR->Flags));	  
+	}
+#endif
+	pMCR->Flags = 0; /* Do it here for reentrancy issues */
+	/* unload the packets */
+	NumberOfPackets = CTRL_TO_CPU_SHORT( pMCR->NumberOfPackets );
+	Dbg_Print(DBG_CMD,( "ubsec:  Complete MCR %x with %d packets \n",
+			    pMCR, NumberOfPackets ));
+	pCallBack = &pMCR->CompletionArray[0];
+	for( j = 0; j < NumberOfPackets; j++ ) {
+	  if( pCallBack->CompletionCallback) {
+	    (*pCallBack->CompletionCallback)( pCallBack->CommandContext,UBSEC_STATUS_SUCCESS);
+	    pCallBack->CompletionCallback=0;
+	  }
+	  pCallBack++;
+	}
+	pMCR->NumberOfPackets = 0; /* This frees it up */
+	pMCR->MCRState = MCR_STATE_FREE; /* Set it to free */
+	pDevice->NextDoneMCR[MCRListIndex] = (MasterCommand_pt)pMCR->pNextMCR;
+      }
+      else {
+	break;
+      }
+  }
+}
+    /* MCRListIndex for loop */
+
+ Dump_Registers(pDevice,DBG_IRQ);
+
+ pDevice->InCriticalSection--;
+ return(Status);
+}
+
+/*
+ * Disable interrupts and return interrupt mask status
+ */
+unsigned long
+ubsec_DisableInterrupt(ubsec_DeviceContext_t Context)
+{
+DeviceInfo_pt pDevice=(DeviceInfo_pt)Context;
+UBS_UINT32 saveval;
+
+saveval=(UBSEC_READ_STATUS(pDevice) & pDevice->IntAckMask);
+UBSEC_DISABLE_INT(pDevice);
+return(saveval);
+}
+
+/* 
+ * Enable device interrupts
+ *
+ * Return success
+ */
+ubsec_Status_t
+ubsec_EnableInterrupt( ubsec_DeviceContext_t Context)
+{
+#ifndef POLL
+DeviceInfo_pt pDevice=(DeviceInfo_pt)Context;
+UBSEC_ENABLE_INT(pDevice);
+#endif
+return(UBSEC_STATUS_SUCCESS);
+}
+
+
+
+
+
diff -urNp linux-8030/drivers/addon/bcm/ubsio.h linux-8040/drivers/addon/bcm/ubsio.h
--- linux-8030/drivers/addon/bcm/ubsio.h
+++ linux-8040/drivers/addon/bcm/ubsio.h
@@ -0,0 +1,438 @@
+
+/*
+ *  Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ *  of any kind, either express or implied as further specified in the GNU Public
+ *  License. This software may be used and distributed according to the terms of
+ *  the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+/******************************************************************************
+ *
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+/*
+ * Character device header file.
+ */
+/*
+ * Revision History:
+ *
+ * When       Who      What
+ * June 2001  SRM      Added forced failure of a device/devices. 
+ * Sept 2001  PW       Added selftest for bcmdiag
+ * Sept 2000  DNA      Added SSL structures
+ * May  2000  SOR/JTT  Created
+ *
+ */
+
+#ifndef _UBSEC_IO_H_
+#define _UBSEC_IO_H_
+
+#include "ubsec.h"
+
+#define UBSEC_MAJOR 99
+#define MAX_COMMANDS 500
+#define MAX_FRAGMENTS 64
+#define MAX_FILE_SIZE  128*1024 /*(PAGE_SIZE << PAGE_ORDER_FOR_BUFS) 64*1024 */
+#define PAGE_ORDER_FOR_BUFS 5
+
+#define IV_LENGTH 8
+#define MAX_CRYPT_KEY_LENGTH 24
+#define MAC_KEY_LENGTH 64
+#define MD5_LENGTH	16 /* Bytes */
+#define SHA1_LENGTH	20 /* Bytes */
+
+#define ENCODE			1
+#define DECODE			2
+#define CRYPT_3DES		4
+#define CRYPT_DES		8
+#define MAC_MD5			16
+#define MAC_SHA1		32
+#define CRYPT_NEW_KEY		128
+#define DMA_FULL_NOBLOCK	512
+#define USE_CALLBACK		1024
+#define USE_MAC_STATES		2048
+
+#define USING_CALLBACK(f) 	((f) & USE_CALLBACK)
+#define DOING_DECODE(f)		((f) & DECODE)
+#define USING_MAC_STATES(f)   	( (f) & (USE_MAC_STATES) )
+
+#define UBSEC_DEVICE_NAME "cryptonet"
+#define UBSEC_KEYDEVICE_NAME "cryptonet"
+
+#define UBSEC_DEVICE_PRINT_NAME "BCM58xx"
+
+/*
+ * Command codes for read/write operations.
+ */
+
+#define ENCRYPT_CMD	0
+#define KEYSETUP_CMD 	1
+#define MATH_CMD 	2
+#define RNG_CMD 	3
+
+
+typedef int * PInt;
+
+
+
+/*
+ * Bulk encryption/decryption ioctl
+ */
+
+typedef struct ubsec_io_s {
+  unsigned char	initial_vector[IV_LENGTH];
+  unsigned char 	crypt_key[MAX_CRYPT_KEY_LENGTH]; 
+  unsigned char 	mac_key[MAC_KEY_LENGTH]; 
+  
+  unsigned int	flags;
+  unsigned int	result_status;
+  unsigned int 	use_callback;
+  unsigned long 	time_us;
+  
+  unsigned short 	crypt_header_skip;
+  unsigned short 	filler;
+  
+  unsigned int 	num_packets;
+  unsigned int 	num_fragments;
+  
+  void 		*source_buf;
+  unsigned int 	source_buf_size;
+  
+  void		*dest_buf;
+  unsigned int 	dest_buf_size;
+  unsigned short mac_header_skip;
+  unsigned int session_num;
+  
+} ubsec_io_t, *ubsec_io_pt;
+
+/*
+ * Key setup ioctl
+ */
+
+typedef struct ubsec_key_io_s {
+	unsigned int 			result_status;
+	unsigned int 			use_callback;
+	unsigned long			time_us;
+	ubsec_KeyCommandParams_t	key;
+	ubsec_KeyCommand_t		command;
+	unsigned long			user_context[2]; /* usable for anything by caller */
+} ubsec_key_io_t, *ubsec_key_io_pt;
+
+/*
+ * Math Function ioctl
+ */
+
+typedef struct ubsec_math_io_s {
+  unsigned int                  result_status;
+  unsigned int                  use_callback;
+  unsigned long                 time_us;
+  ubsec_MathCommandParams_t	Math;
+  ubsec_MathCommand_t           command;
+  unsigned long                 user_context[2]; /* usable for anything by caller */
+} ubsec_math_io_t, *ubsec_math_io_pt;
+
+/*
+ * RNG ioctl
+ */
+
+typedef struct ubsec_rng_io_s {
+  unsigned int 			result_status;
+  unsigned int 			use_callback;
+  unsigned long			time_us;
+  ubsec_RNGCommandParams_t	Rng;
+  ubsec_RNGCommand_t		command;
+  unsigned long			user_context[2]; /* usable for anything by caller */
+} ubsec_rng_io_t, *ubsec_rng_io_pt;
+
+/*
+ * Ssl Mac Ioctl
+ */
+
+typedef struct ubsec_sslmac_io_s {
+  unsigned int                   result_status;
+  unsigned long                  time_us;
+  ubsec_SSLCommand_t             command;
+  unsigned int 	                 num_fragments;
+  unsigned short                 HashAlgorithm;
+  ubsec_DoubleSequenceNumber_t   SequenceNumber;
+  unsigned char                  ContentType;
+  unsigned short                 DataLength;
+  ubsec_SSLMAC_key_t             key;
+  unsigned char *                SourceBuffer;
+  unsigned int                   SourceBufferBytes;
+  unsigned char                  *HmacBuffer;
+  unsigned int                   HmacBufferBytes;
+} ubsec_sslmac_io_t, *ubsec_sslmac_io_pt;
+
+/*
+ *  Ssl Cipher Ioctl (SSL/TLS DES/3DES)
+ */
+
+typedef struct ubsec_sslcipher_io_s {
+  unsigned int        result_status;
+  unsigned long       time_us;
+  unsigned int 	      num_fragments;
+  ubsec_SSLCommand_t  command;
+  unsigned char       InitialVector[IV_LENGTH];
+  unsigned char       CryptKey[MAX_CRYPT_KEY_LENGTH]; 
+  unsigned char *     SourceBuffer;
+  unsigned int        SourceBufferBytes;
+  unsigned char *     DestBuffer;
+  unsigned int        DestBufferBytes;
+} ubsec_sslcipher_io_t, *ubsec_sslcipher_io_pt;
+
+/*
+ *  Ssl Arc4 Ioctl
+ */
+
+#define ARC4_KEY                      	(1)
+#define ARC4_STATE                    	(2)
+#define ARC4_STATE_SUPPRESS_WRITEBACK 	(4)
+#define ARC4_NULL_DATA_MODE           	(8)
+#define ARC4_INDICESKEYSTATE_BUF_LEN  	(260)
+
+typedef struct ubsec_arc4_io_s {
+  unsigned int        result_status;
+  unsigned long       time_us;
+  unsigned int 	      num_fragments;
+  ubsec_SSLCommand_t  command;
+  unsigned char       KeyStateFlag;
+  unsigned char *     KeyStateInBuffer;
+  unsigned int        KeyStateInBufferBytes;
+  unsigned char *     SourceBuffer;
+  unsigned int        SourceBufferBytes;
+  unsigned char *     DestBuffer;
+  unsigned int        DestBufferBytes;
+  unsigned char *     StateOutBuffer;
+  unsigned int        StateOutBufferBytes;
+} ubsec_arc4_io_t, *ubsec_arc4_io_pt;
+
+
+/*
+ * Tls Ioctl
+ */
+
+typedef struct ubsec_tlsmac_io_s {
+  unsigned int                  result_status;
+  unsigned long                 time_us;
+  unsigned int 	                num_fragments;
+  ubsec_SSLCommand_t            command;
+  unsigned short                HashAlgorithm;
+  ubsec_DoubleSequenceNumber_t  SequenceNumber;
+  unsigned char                 ContentType;
+  unsigned short                Version;
+  unsigned short                DataLength;
+  unsigned char                 MacKey[MAC_KEY_LENGTH]; 
+  unsigned char                 InnerState[UBSEC_HMAC_LENGTH];
+  unsigned char                 OuterState[UBSEC_HMAC_LENGTH];
+  unsigned char *               SourceBuffer;
+  unsigned int                  SourceBufferBytes;
+  unsigned char *               HmacBuffer;
+  unsigned int                  HmacBufferBytes;
+} ubsec_tlsmac_io_t, *ubsec_tlsmac_io_pt;
+
+/*
+ * Raw Hash Ioctl
+ */
+
+typedef struct ubsec_hash_io_s {
+  unsigned int                   result_status;
+  unsigned long                  time_us;
+  unsigned int                   num_fragments;
+  ubsec_SSLCommand_t             command;
+  int                            auth_alg;
+  unsigned char *                SourceBuffer;
+  unsigned int                   SourceBufferBytes;
+  unsigned char                  HashBuffer[UBSEC_HMAC_LENGTH];
+  unsigned int                   HashBufferBytes;
+} ubsec_hash_io_t, *ubsec_hash_io_pt;
+
+/*
+ *  Chip Info Ioctl (to be phased out)
+ */
+
+typedef struct linux_chipinfo_io_s {
+  unsigned int     result_status;
+  unsigned long    time_us;
+  unsigned int     max_key_len;
+} linux_chipinfo_io_t, *linux_chipinfo_io_pt;
+
+
+/*
+ * Bulk encryption/decryption read/write. Passed to driver by application prepended onto
+ * the data to be encrypted or decrypted. Since the driver supports scatter/gather, this
+ * is not a real problem. For encryption, data must be padded on an eight byte boundary.
+ * This structure is updated and returned to the caller.
+ */
+
+typedef struct ubsec_encrypt_rw_s {
+	unsigned int		cmd_type;		/* ENCRYPT_CMD */
+	unsigned long		user_context[2];
+	ubsec_CipherCommand_t	command;	
+
+	unsigned char		initial_vector[IV_LENGTH];
+	unsigned char 		crypt_key[MAX_CRYPT_KEY_LENGTH]; 
+	unsigned char 		mac_key[MAC_KEY_LENGTH]; 
+
+	unsigned int		flags;
+	unsigned int		result_status;
+	unsigned long 		time_us;
+
+	unsigned short 		source_buf_size;
+	unsigned short	 	crypt_header_skip;
+
+	unsigned short		num_packets;		/* must be one for now */
+	unsigned short 		num_fragments;
+
+	unsigned char		authenticator[SHA1_LENGTH];
+
+} ubsec_encrypt_rw_t, *ubsec_encrypt_rw_pt;
+
+
+/*
+ * Key setup read/write
+ */
+typedef struct ubsec_key_rw_s {
+	unsigned int			cmd_type;		/* KEY_SETUP */
+	unsigned long			user_context[2];	/* returned to user untouched */
+	ubsec_KeyCommand_t		command;
+
+	unsigned int			flags;
+	unsigned int 			result_status;
+        unsigned long	   	        time_us;
+
+	ubsec_KeyCommandParams_t	key;
+
+} ubsec_key_rw_t, *ubsec_key_rw_pt;
+
+
+/*
+ * Math func read/write
+ */
+typedef struct ubsec_math_rw_s {
+	unsigned int			cmd_type;		/* MATH */
+	unsigned long			user_context[2];	/* returned to user untouched */
+	ubsec_MathCommand_t		command;
+
+	unsigned int			flags;
+	unsigned int 			result_status;
+	unsigned long			time_us;
+
+	ubsec_MathCommandParams_t	Math;
+
+} ubsec_math_rw_t, *ubsec_math_rw_pt;
+
+
+/*
+ * RNG func read/write
+ */
+typedef struct ubsec_rng_rw_s {
+	unsigned int			cmd_type;		/* RNG */
+	unsigned long			user_context[2];	/* returned to user untouched */
+	ubsec_RNGCommand_t		command;
+
+	unsigned int			flags;
+	unsigned int 			result_status;
+	unsigned long			time_us;
+
+	ubsec_RNGCommandParams_t	rng;
+
+} ubsec_rng_rw_t, *ubsec_rng_rw_pt;
+
+/*
+ * Command packet used by read/write routines.
+ * Filled in by caller, copied to kernel space.
+ */
+typedef union ubsec_rw_s {
+	ubsec_encrypt_rw_t	encrypt;
+	ubsec_key_rw_t		key;
+	ubsec_math_rw_t		math;
+	ubsec_rng_rw_t		rng;
+} ubsec_rw_t, *ubsec_rw_pt;
+
+/*********************************************************** Statistics */
+typedef struct ubsec_stats_io_s {
+  unsigned int        result_status;
+  unsigned long       time_us;
+  int                 device_num;
+  ubsec_Statistics_t  dev_stats;
+} ubsec_stats_io_t, *ubsec_stats_io_pt;
+
+/* Function Ptrs ioctl */
+
+typedef struct ubsec_Function_Ptrs_s {
+/* DeviceInfoList pointer */
+void *PhysDeviceInfoList_Ptr; /* to contains &DeviceInfoList */
+
+/* Allocate DMA Memory function */
+void * (*OS_AllocateDMAMemory_Fptr)(ubsec_DeviceContext_t * ,
+		int size);
+
+/* Free DMA Memory function */
+void  (*OS_FreeDMAMemory_Fptr)(void * ,
+		int size);
+
+/* Initialize HMAC state function */
+ubsec_Status_t (*ubsec_InitHMACState_Fptr)(ubsec_HMAC_State_pt ,
+	      ubsec_CipherCommand_t ,
+	      ubsec_HMAC_Key_pt) ;
+
+/* Cipher command execute function */
+ubsec_Status_t (*ubsec_CipherCommand_Fptr)(ubsec_DeviceContext_t ,
+		    ubsec_CipherCommandInfo_pt ,
+		    int *);
+/* RNG command execute function */
+ubsec_Status_t (*ubsec_RNGCommand_Fptr)(ubsec_DeviceContext_t,
+	      ubsec_RNGCommandInfo_pt ,
+	      int *);
+
+}ubsec_Function_Ptrs_t;
+
+/*
+ * Ioctl command codes.
+ */
+
+#define BRCM_IOC_MAGIC  'Y'
+#define UBSEC_ENCRYPT_DECRYPT_FUNC  _IOWR(BRCM_IOC_MAGIC,  1, ubsec_io_pt)
+#define UBSEC_KEY_SETUP_FUNC	    _IOWR(BRCM_IOC_MAGIC,  2, ubsec_key_io_pt)
+#define UBSEC_MATH_FUNC		    _IOWR(BRCM_IOC_MAGIC,  3, ubsec_math_io_pt)
+#define UBSEC_RNG_FUNC		    _IOWR(BRCM_IOC_MAGIC,  4, ubsec_rng_io_pt)
+#define UBSEC_SSL_MAC_FUNC	    _IOWR(BRCM_IOC_MAGIC,  5, ubsec_sslmac_io_pt)
+#define UBSEC_SSL_DES_FUNC	    _IOWR(BRCM_IOC_MAGIC,  6, ubsec_sslcipher_io_pt)
+#define UBSEC_TLS_HMAC_FUNC	    _IOWR(BRCM_IOC_MAGIC,  7, ubsec_tlsmac_io_pt)
+#define UBSEC_SSL_ARC4_FUNC	    _IOWR(BRCM_IOC_MAGIC,  8, ubsec_arc4_io_pt)
+#define UBSEC_SSL_HASH_FUNC         _IOWR(BRCM_IOC_MAGIC,  9, ubsec_hash_io_pt)
+#define UBSEC_CHIPINFO_FUNC         _IOWR(BRCM_IOC_MAGIC, 10, linux_chipinfo_io_pt)
+#define UBSEC_SELFTEST              _IOWR(BRCM_IOC_MAGIC, 11, PInt)
+#define UBSEC_GETVERSION            _IOWR(BRCM_IOC_MAGIC, 12, PInt)
+#define UBSEC_RESERVED              _IOWR(BRCM_IOC_MAGIC, 13, PInt)
+#define UBSEC_DEVICEDUMP            _IOWR(BRCM_IOC_MAGIC, 14, PInt)
+#define UBSEC_EXTCHIPINFO_FUNC      _IOWR(BRCM_IOC_MAGIC, 15, ubsec_chipinfo_io_pt)
+#define UBSEC_GETNUMCARDS           _IOWR(BRCM_IOC_MAGIC, 16, PInt)
+#define UBSEC_GET_FUNCTION_PTRS     _IOWR(BRCM_IOC_MAGIC, 17, ubsec_Function_Ptrs_t *)
+#define UBSEC_FAILDEVICE            _IOWR(BRCM_IOC_MAGIC, 32, PInt)
+#define UBSEC_STATS_FUNC            _IOWR(BRCM_IOC_MAGIC, 64, ubsec_stats_io_pt)
+
+#ifdef BCM_OEM_1
+#define BCM_OEM_1_IOCTL1	 	_IO('L',0x11)
+#define BCM_OEM_1_IOCTL2 		_IO('L',0x12)
+#endif /* BCM_OEM_1 */
+
+ 
+#define USING_MAC(f)   ( (f) & (MAC_MD5 | MAC_SHA1) )
+
+#ifdef BCM_OEM_1
+#include "bcm_oem1_device.h"
+#endif
+
+#endif  /* _UBSEC_IO_H_ */
diff -urNp linux-8030/drivers/addon/bcm/ubskey.c linux-8040/drivers/addon/bcm/ubskey.c
--- linux-8030/drivers/addon/bcm/ubskey.c
+++ linux-8040/drivers/addon/bcm/ubskey.c
@@ -0,0 +1,405 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubskey.c: Public Key commands are handled by this module
+ *
+ *
+ * Revision History:
+ *
+ * 01/03/2000 PW Created
+ * 07/06/2000 DPA Fixes for SMP operation
+ * 04/03/2001 RJT Added support for CryptoNet device big-endian mode
+ * 04/20/2001 RJT Added support for CPU-DMA memory synchronization
+ * 04/24/2001 DPA Allow for unnormalize of D-H random number (x) output for BCM5805
+ * 10/09/2001 SRM 64 bit port
+ */
+
+#include "ubsincl.h"
+
+void significant_bits(ubsec_LongKey_pt key, int native_endianess);
+
+/*
+ * ubsec_KeyCommand: Process a list of Cipher commands.
+ *
+ * Immediate Status is returned. Completion status is returned
+ * on a per command callback
+ */
+ubsec_Status_t 
+ubsec_KeyCommand(ubsec_DeviceContext_t Context,
+	      ubsec_KeyCommandInfo_pt pCommand,
+	      int *NumCommands)
+{
+
+#ifdef UBSEC_PKEY_SUPPORT
+  DeviceInfo_pt 		pDevice=(DeviceInfo_pt)Context;
+  VOLATILE MasterCommand_t  	*pMCR;
+  VOLATILE Packet_t         	*pPacket;
+  VOLATILE KeyContext_t  	*pContext;
+  VOLATILE int             	PacketIndex;
+  int 				CommandIndex=0;
+  int 				CommandCount=*NumCommands;
+  ubsec_Status_t 		Status;
+  UBS_UINT32 			SaveConfig;
+  CallBackInfo_pt pCompletionContext;
+
+  if (!(UBSEC_IS_KEY_DEVICE(pDevice))) {
+    Dbg_Print(DBG_FATAL,( "ubsec: KEY Command for a crypto device %x\n ",pDevice->DeviceID ));
+    return(UBSEC_STATUS_NO_DEVICE );
+  }
+
+
+  Dbg_Print(DBG_KEY,( "ubsec:  Key command %d ",*NumCommands ));
+  /*
+   * Check some parameters
+   */    
+  if(pDevice==NULL_DEVICE_INFO) {
+    Dbg_Print(DBG_FATAL,( "NO DEV\n " ));
+    return(UBSEC_STATUS_NO_DEVICE );
+  }
+  Dbg_Print(DBG_KEY,( "\n"));
+
+  if (OS_EnterCriticalSection(pDevice,SaveConfig)) {
+    return(UBSEC_STATUS_DEVICE_BUSY);
+  }
+
+  /* Get the next MCR to load */
+ Get_New_MCR:
+  *NumCommands=CommandIndex; /* Update number completed */
+
+
+  if ((pMCR=GetFreeMCR(pDevice,UBSEC_KEY_LIST,&Status))== NULL_MASTER_COMMAND)
+    goto Error_Return;
+
+  /* Add packets to this MCR. */
+
+  Dbg_Print(DBG_KEY,( "ubsec: mcr_index %d MCR <%0x,%0x>\n",pMCR->Index,pMCR,pMCR->MCRPhysicalAddress));
+  /* Initialize the packet information */
+  PacketIndex = pMCR->NumberOfPackets; 
+  pPacket = &(pMCR->PacketArray[PacketIndex]); /* Set up the current packet. */
+  pContext = pMCR->KeyContextList[PacketIndex]; 
+  Status=UBSEC_STATUS_SUCCESS; /* Wishful thinking? */
+
+  Dbg_Print(DBG_KEY,( "ubsec: PacketIndex %d \n",pMCR->NumberOfPackets));
+
+  /* Process all the commands in the command list. */
+  for (; CommandIndex < CommandCount ; CommandIndex++) { /* Add all the packets to the MCR*/
+    if( PacketIndex >= MCR_MAXIMUM_PACKETS ) {
+      Dbg_Print(DBG_KEY,( "ubsec:  overran mcr buffer. %d\n",PacketIndex,CommandIndex ));
+      /* 
+       * We have filled this MCR. 
+       * Advance next free. Wrap around if necessary
+       */
+      pDevice->NextFreeMCR[UBSEC_KEY_LIST]=(MasterCommand_pt)pMCR->pNextMCR;
+      Dbg_Print(DBG_KEY,( "ubsec:  PushMCR ..." ));
+      PushMCR(pDevice); /* Get it going (pipeline) */
+      goto Get_New_MCR; /* Try to add to the next MCR */
+    }
+	pContext = pMCR->KeyContextList[PacketIndex]; 
+
+    pCompletionContext=(CallBackInfo_pt)&pMCR->CompletionArray[PacketIndex];
+
+    /* Now set up the packet processing parameters */
+    Dbg_Print(DBG_KEY,( "ubsec: packet_Index %d, Context Buf <%0x,%0x>\n",PacketIndex,pContext,pContext->PhysicalAddress ));
+    pPacket->PacketContextBuffer=pContext->PhysicalAddress;
+    
+    switch (pCommand->Command) {
+      case UBSEC_DH_PUBLIC:
+	Dbg_Print(DBG_KEY,( "ubsec: UBSEC_DH_PUBLIC\n" ));
+	pContext->cmd_structure_length= DH_STATIC_SEND_CONTEXT_SIZE;
+	pContext->operation_type	= OPERATION_DH_PUBLIC; /* send mode for DH */
+	Status=DH_SetupPublicParams((MasterCommand_pt)pMCR,&pCommand->Parameters.DHParams);
+
+	if (Status != UBSEC_STATUS_SUCCESS)
+	  goto Error_Return;
+#ifdef UBSEC_STATS
+	pDevice->Statistics.DHPublicCount++;
+#endif
+        break;
+
+      case UBSEC_DH_SHARED:
+	Dbg_Print(DBG_KEY,( "ubsec: UBSEC_DH_SHARED\n" ));
+	pContext->cmd_structure_length= DH_STATIC_REC_CONTEXT_SIZE;
+	pContext->operation_type	= OPERATION_DH_SHARED; /* send mode for DH */
+	Status=DH_SetupSharedParams((MasterCommand_pt)pMCR,&pCommand->Parameters.DHParams);
+	if (Status != UBSEC_STATUS_SUCCESS)
+	  goto Error_Return;
+#ifdef UBSEC_STATS
+	pDevice->Statistics.DHSharedCount++;
+#endif
+	break;
+
+      case UBSEC_RSA_PUBLIC:
+	pContext->cmd_structure_length=RSA_STATIC_PUBLIC_CONTEXT_SIZE;
+	pContext->operation_type	= OPERATION_RSA_PUBLIC; /* send mode for DH */
+	Status=RSA_SetupPublicParams((MasterCommand_pt)pMCR,&pCommand->Parameters.RSAParams);
+	if (Status != UBSEC_STATUS_SUCCESS)
+	  goto Error_Return;
+#ifdef UBSEC_STATS
+	pDevice->Statistics.RSAPublicCount++;
+#endif
+	break;
+
+      case UBSEC_RSA_PRIVATE:
+	pContext->cmd_structure_length=RSA_STATIC_PRIVATE_CONTEXT_SIZE;
+	pContext->operation_type	= OPERATION_RSA_PRIVATE; /* send mode for DH */
+	Status=RSA_SetupPrivateParams((MasterCommand_pt)pMCR,&pCommand->Parameters.RSAParams);
+	if (Status != UBSEC_STATUS_SUCCESS)
+	  goto Error_Return;
+#ifdef UBSEC_STATS
+	pDevice->Statistics.RSAPrivateCount++;
+#endif
+	break;
+
+      case UBSEC_DSA_SIGN:
+	pContext->cmd_structure_length= DSA_STATIC_SIGN_CONTEXT_SIZE;
+	pContext->operation_type	= OPERATION_DSA_SIGN; /* send mode for DH */
+	Status=DSA_SetupSignParams((MasterCommand_pt)pMCR,&pCommand->Parameters.DSAParams);
+	if (Status != UBSEC_STATUS_SUCCESS)
+	  goto Error_Return;
+#ifdef UBSEC_STATS
+	pDevice->Statistics.DSASignCount++;
+#endif
+	break;
+
+      case UBSEC_DSA_VERIFY:
+	pContext->cmd_structure_length= DSA_STATIC_VERIFY_CONTEXT_SIZE;
+	pContext->operation_type	= OPERATION_DSA_VERIFY; /* send mode for DH */
+
+	Status=DSA_SetupVerifyParams((MasterCommand_pt)pMCR,&pCommand->Parameters.DSAParams);
+	if (Status != UBSEC_STATUS_SUCCESS)
+	  goto Error_Return;
+#ifdef UBSEC_STATS
+	pDevice->Statistics.DSAVerifyCount++;
+#endif
+	break;
+
+    default:
+      return(UBSEC_STATUS_INVALID_PARAMETER);
+    }
+
+    /* Save the user callback information. We use an intermediate callback for LongKey numbers */
+
+    /* Always save the user callback parameters (to be called by the intermediate callback) */
+    pContext->UserCallback = pCommand->CompletionCallback;
+    pContext->UserContext = pCommand->CommandContext;
+    /* The intermediate callback needs to get this command context passed to it */
+    pCompletionContext->CompletionCallback = KeyFinishResult;
+    pCompletionContext->CommandContext = (unsigned long)pContext;
+
+
+#if (UBS_CPU_ATTRIBUTE != UBS_CRYPTONET_ATTRIBUTE) 
+    pContext->cmd_structure_length= CPU_TO_CTRL_SHORT(pContext->cmd_structure_length);
+#endif
+
+    /* For key MCRs, contexts are accessed by an array of handles.        */
+    /* This means that memory for each context was separately allocated.  */
+    /* Therefore we must sync each context separately as it is built.     */
+    Dbg_Print(DBG_CNTXT_SYNC,( "ubsec: ubsec_KeyCommand() Sync Context to Device (0x%08X,%d,%d)\n", pMCR->ContextListHandle[PacketIndex],
+		       0,
+		       CTRL_TO_CPU_SHORT(pContext->cmd_structure_length)));
+    OS_SyncToDevice(pMCR->ContextListHandle[PacketIndex],
+		    0,
+		    CTRL_TO_CPU_SHORT(pContext->cmd_structure_length));
+
+    /* Now inc the number of packets and prepare for the next command. */
+    pMCR->NumberOfPackets++;
+    pCommand++;
+    PacketIndex++;
+    pPacket++;
+#ifdef UBSEC_STATS
+    pDevice->Statistics.IKECount++;
+#endif
+  } /* For NumCommands-- */
+
+  /*
+   * If we are here then the MCR is built.
+   * Push it to the device. 
+   */
+  *NumCommands=CommandIndex; /* Update number completed */
+  PushMCR(pDevice);
+
+#ifdef BLOCK 
+  /* Wait for all outstanding  to complete */
+    while ((Status=WaitForCompletion(pDevice,(UBS_UINT32)1000000,UBSEC_KEY_LIST))
+	   == UBSEC_STATUS_SUCCESS);
+    if (Status!=UBSEC_STATUS_TIMEOUT) /* We are nested, return success */
+      Status=UBSEC_STATUS_SUCCESS;
+ Error_Return:
+#else
+
+ Error_Return:  /* Label to make sure that IRQs are enabled. */
+
+#ifdef COMPLETE_ON_COMMAND_THREAD
+    ubsec_PollDevice(pDevice);  /* Try to complete some & cut down on ints */
+#endif
+
+#endif
+    OS_LeaveCriticalSection(pDevice,SaveConfig);
+
+#ifdef UBSEC_STATS
+		if (Status != UBSEC_STATUS_SUCCESS)
+			pDevice->Statistics.IKEFailedCount++;
+#endif
+
+    return(Status);
+#else /* Support */
+    return(UBSEC_STATUS_NO_DEVICE);
+#endif
+}
+
+
+/*
+ * Intermediate callback routine to finish/unshift "key" (multi-precision integers) results data.
+ * This routine counts significant bits in the LongKey result(s). It also adjusts keys to CPU native 
+ * endianess (if needed) and/or un-normalizes keys (if needed)
+ */
+void KeyFinishResult(unsigned long Context,ubsec_Status_t Result)
+{
+  KeyContext_pt pContext=(KeyContext_pt)Context;
+  long NormBits_RNG;
+  int key_num, element_num, native_endianess;
+  UBS_UINT32 *key_array;
+
+  /* We are assuming that the KeyLength field value passed in refers to a key array element that
+     is not less significant (lower array index) than the actual most significant array element,
+     and not so large as to exceed the allocated space for the KeyValue array */
+
+  if (Result==UBSEC_STATUS_SUCCESS) {
+
+#if defined(UBS_OVERRIDE_LONG_KEY_MODE)
+    native_endianess = 0; /* Key arrays NOT returned in the CPU's native endianess */
+#else
+    native_endianess = 1; /* Key arrays returned in the CPU's native endianess */
+#endif /* Returned endianess of the key arrays */
+
+    /* Process one or both of the ResultKey arrays */
+    for (key_num=0 ; key_num<2 ; key_num++) {
+      if ((pContext->ResultKey[key_num] == NULL) || \
+	  (pContext->ResultKey[key_num]->KeyValue == NULL) || \
+	  (pContext->ResultKey[key_num]->KeyLength == 0))
+	continue;
+
+      Dbg_Print(DBG_FRAG_SYNC,( "ubsec: KeyFinishResult Sync Output Frag #%d to CPU (0x%08X,%d,%d)\n",
+				key_num+1, 
+				pContext->ResultKey[key_num]->KeyValue,
+				0,
+				ROUNDUP_TO_32_BIT(pContext->ResultKey[key_num]->KeyLength)/8));
+      OS_SyncToCPU(pContext->ResultKey[key_num]->KeyValue,
+		   0,
+		   ROUNDUP_TO_32_BIT(pContext->ResultKey[key_num]->KeyLength)/8);
+
+#if defined(UBS_ENABLE_KEY_SWAP) 
+      key_array = (UBS_UINT32 *)OS_GetVirtualAddress(pContext->ResultKey[key_num]->KeyValue);
+      for (element_num=0; element_num<((pContext->ResultKey[key_num]->KeyLength+31)/32) ; element_num++)
+	key_array[element_num] = BYTESWAPLONG(key_array[element_num]);
+#endif /* UBS_ENABLE_KEY_SWAP */
+ 
+#ifndef UBSEC_HW_NORMALIZE
+      if (pContext->NormBits) 
+	ubsec_ShiftData(pContext->ResultKey[key_num], -pContext->NormBits);
+#endif /* UBSEC_HW_NORMALIZE */
+
+      significant_bits(pContext->ResultKey[key_num], native_endianess);
+
+    } /* for each ResultKey[key_num] to be finished */
+
+    /* Now process the RNG key array result (if present) */
+    if ((pContext->ResultRNG != NULL) && \
+	(pContext->ResultRNG->KeyValue != NULL) && \
+	pContext->ResultRNG->KeyLength ) {
+
+      Dbg_Print(DBG_FRAG_SYNC,( "ubsec: KeyFinishResult Sync RNG Frag to CPU (0x%08X,%d,%d)\n",
+				pContext->ResultRNG->KeyValue,
+				0,
+				ROUNDUP_TO_32_BIT(pContext->ResultRNG->KeyLength)/8));
+      OS_SyncToCPU(pContext->ResultRNG->KeyValue,
+		   0,
+		   ROUNDUP_TO_32_BIT(pContext->ResultRNG->KeyLength)/8);
+
+#if defined(UBS_ENABLE_KEY_SWAP) 
+      key_array = (UBS_UINT32 *)OS_GetVirtualAddress(pContext->ResultRNG->KeyValue);
+      for (element_num=0; element_num<((pContext->ResultRNG->KeyLength+31)/32) ; element_num++)
+	key_array[element_num] = BYTESWAPLONG(key_array[element_num]);
+#endif /* UBS_ENABLE_KEY_SWAP */
+
+#ifndef UBSEC_HW_NORMALIZE
+      if ((pContext->operation_type == OPERATION_DH_PUBLIC) && pContext->CtxCmdBuf.DH_Send_CtxCmdBuf.rng_enable) {
+	NormBits_RNG = pContext->CtxCmdBuf.DH_Send_CtxCmdBuf.private_key_length & 0x1f;
+	if (NormBits_RNG) {
+	  ubsec_ShiftData(pContext->ResultRNG, NormBits_RNG - 32);
+	}
+      }
+#endif /* UBSEC_HW_NORMALIZE */
+      significant_bits(pContext->ResultRNG, native_endianess);
+    }
+
+  } /* Result == UBSEC_STATUS_SUCCESS */
+
+  if (pContext->UserCallback) 
+    (*pContext->UserCallback)( pContext->UserContext,Result);
+}
+
+
+void significant_bits(ubsec_LongKey_pt key, int native_endianess)
+{
+  int element_num;
+  UBS_UINT32 element, *key_array;
+
+  if ((key == NULL) || !key->KeyLength) {
+    Dbg_Print(DBG_FATAL,("significant_bits: invalid/unworkable input\n"));
+    return;
+  }
+
+  /* Round up to next 32-bit multiple */
+  key->KeyLength = (key->KeyLength + 31) & ~31;
+
+  /* Start search at appropriate 32-bit array element */
+  key_array = (UBS_UINT32 *)OS_GetVirtualAddress(key->KeyValue);
+  element_num = (key->KeyLength / 32) - 1; 
+
+  do {
+    if (key_array[element_num] == 0) {
+      key->KeyLength -= 32;
+      continue;
+    }
+    else {
+      if (native_endianess) 
+	element = key_array[element_num]; /* Key array in CPU's native endianess */
+      else
+	element = BYTESWAPLONG(key_array[element_num]); /* Key array NOT in CPU's native endianess */
+      while (!(element & 0x80000000)) {
+	element = element << 1;
+	key->KeyLength--;
+      }
+      break;
+    }
+  } while (--element_num >= 0);
+  return;
+}
+
+
+
+
+
diff -urNp linux-8030/drivers/addon/bcm/ubskey.h linux-8040/drivers/addon/bcm/ubskey.h
--- linux-8030/drivers/addon/bcm/ubskey.h
+++ linux-8040/drivers/addon/bcm/ubskey.h
@@ -0,0 +1,296 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubskey.h: ubsec key specific context definitions.
+ *
+ * The BCM5805 was previously called the uB5601
+ * This file was previously ubs5805.h
+ * This file contains all the structure definitions for the key functions
+ * of the 58xx chip family
+ */
+
+/*
+ * Revision History:
+ *
+ * 09/21/2000 SOR Created from PW-5805.h
+ * 04/03/2001 RJT Added support for CryptoNet device big-endian mode
+ * 04/24/2001 DPA Allow for unnormalize of D-H random number (x) output for BCM5805
+ * 07/16/2001 RJT Added support for BCM5821
+ * 10/09/2001 SRM 64 bit port.
+ */
+
+
+#ifndef _UBSKEY_H_
+#define _UBSKEY_H_
+
+
+/* Context Buffer Operation type */
+#if (UBS_CPU_ATTRIBUTE == UBS_CRYPTONET_ATTRIBUTE)
+#define OPERATION_DH_PUBLIC    	0x0001
+#define OPERATION_DH_SHARED    	0x0002
+#define OPERATION_RSA_PUBLIC   	0x0003
+#define OPERATION_RSA_PRIVATE  	0x0004
+#define OPERATION_DSA_SIGN   	0x0005
+#define OPERATION_DSA_VERIFY  	0x0006
+#define OPERATION_RNG_DIRECT   	0x0041
+#define OPERATION_RNG_SHA1     	0x0042
+#define OPERATION_MOD_ADD   	0x0043
+#define OPERATION_MOD_SUB     	0x0044
+#define OPERATION_MOD_MULT   	0x0045
+#define OPERATION_MOD_REDUCT   	0x0046
+#define OPERATION_MOD_EXPON   	0x0047
+#define OPERATION_MOD_DBLEXP  	0x0049
+#else
+#define OPERATION_DH_PUBLIC    	0x0100
+#define OPERATION_DH_SHARED    	0x0200
+#define OPERATION_RSA_PUBLIC   	0x0300
+#define OPERATION_RSA_PRIVATE  	0x0400
+#define OPERATION_DSA_SIGN   	0x0500
+#define OPERATION_DSA_VERIFY  	0x0600
+#define OPERATION_RNG_DIRECT   	0x4100
+#define OPERATION_RNG_SHA1     	0x4200
+#define OPERATION_MOD_ADD   	0x4300
+#define OPERATION_MOD_SUB     	0x4400
+#define OPERATION_MOD_MULT   	0x4500
+#define OPERATION_MOD_REDUCT   	0x4600
+#define OPERATION_MOD_EXPON   	0x4700
+#define OPERATION_MOD_DBLEXP  	0x4900
+#endif
+
+#define NULL_KEY_CONTEXT (KeyContext_pt) 0
+
+/* Context buffer */
+/* Different algorithms have different context command buffers */
+
+#ifdef UBSEC_582x_CLASS_DEVICE
+#define MAX_KEY_LENGTH_BITS 2048
+#else
+#define MAX_KEY_LENGTH_BITS 1024
+#endif
+
+#define MAX_KEY_LENGTH_BYTES (MAX_KEY_LENGTH_BITS/8)
+#define MAX_KEY_LENGTH_WORDS (MAX_KEY_LENGTH_BITS/32)
+
+/* These lengths are defined as longs. */
+#define MAX_MODULUS_LENGTH      MAX_KEY_LENGTH_WORDS 	
+#define MAX_GENERATOR_LENGTH   	MAX_KEY_LENGTH_WORDS
+#define MAX_EXPON_LENGTH        MAX_KEY_LENGTH_WORDS
+#define MAX_DP_LENGTH           MAX_KEY_LENGTH_WORDS
+#define MAX_DQ_LENGTH           MAX_KEY_LENGTH_WORDS
+#define MAX_PRIME_LENGTH        MAX_KEY_LENGTH_WORDS
+#define MAX_PRINV_LENGTH        MAX_KEY_LENGTH_WORDS
+#define MAX_PRIME_LENGTH        MAX_KEY_LENGTH_WORDS
+#define MAX_PRI_KEY_LENGTH      MAX_KEY_LENGTH_WORDS
+#define MAX_PUB_KEY_LENGTH      MAX_KEY_LENGTH_WORDS
+
+#define DH_STATIC_SEND_CONTEXT_SIZE (6*sizeof(unsigned short))
+/*Diffie-Hellman Send*/
+typedef struct DH_Send_CtxCmdBuf_struct {
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE unsigned short rng_enable;	       /* Private key x RNG or SW  */ 
+  VOLATILE unsigned short private_key_length;  /* Priv key x len in bits   */
+  VOLATILE unsigned short generator_length;    /* Generator g len in bits  */
+  VOLATILE unsigned short modulus_length;      /* Modulus N Len in bits    */
+#else
+  VOLATILE unsigned short private_key_length;  /* Priv key x len in bits   */
+  VOLATILE unsigned short rng_enable;	       /* Private key x RNG or SW  */ 
+  VOLATILE unsigned short modulus_length;      /* Modulus N Len in bits    */
+  VOLATILE unsigned short generator_length;    /* Generator g len in bits  */
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+  VOLATILE UBS_UINT32 Ng[MAX_MODULUS_LENGTH+MAX_GENERATOR_LENGTH];
+			 /* Private key is stored in the data buffer */	
+} DH_Send_CtxCmdBuf_t, *DH_Send_CtxCmdBuf_pt;
+
+#define DH_STATIC_REC_CONTEXT_SIZE (4*sizeof(unsigned short))
+/*Diffie-Hellman Receive*/
+typedef struct DH_REC_CtxCmdBuf_struct {
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE unsigned short private_key_length;  /* Private key length in bits */
+  VOLATILE unsigned short modulus_length;      /* Modulus N Length in bits   */
+#else
+  VOLATILE unsigned short modulus_length;      /* Modulus N Length in bits   */
+  VOLATILE unsigned short private_key_length;  /* Private key length in bits */
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+  VOLATILE UBS_UINT32 N[MAX_MODULUS_LENGTH];  /* Modulus N  */
+} DH_REC_CtxCmdBuf_t, *DH_REC_CtxCmdBuf_pt;
+
+/*Public Key RSA*/
+#define RSA_STATIC_PUBLIC_CONTEXT_SIZE (4*sizeof(unsigned short))
+typedef struct Pub_RSA_CtxCmdBuf_struct {
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE unsigned short exponent_length;   /* Exponent E length in bits */
+  VOLATILE unsigned short modulus_length;    /* Modulus N Length in bits  */
+#else
+  VOLATILE unsigned short modulus_length;    /* Modulus N Length in bits  */
+  VOLATILE unsigned short exponent_length;   /* Exponent E length in bits */
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+  VOLATILE UBS_UINT32 Ng[2*MAX_MODULUS_LENGTH]; /* Modulus N and g fields */
+} Pub_RSA_CtxCmdBuf_t, *Pub_RSA_CtxCmdBuf_pt;
+
+/*Public Key RSA*/
+#define RSA_STATIC_PRIVATE_CONTEXT_SIZE  (4*sizeof(unsigned short))
+  typedef struct Pri_RSA_CtxCmdBuf_struct {
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE unsigned short q_length; 	         /* Prime q length in bits */
+  VOLATILE unsigned short p_length; 		 /* Prime p Length in bits */
+#else
+  VOLATILE unsigned short p_length; 		 /* Prime p Length in bits */
+  VOLATILE unsigned short q_length; 	         /* Prime q length in bits */
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+  VOLATILE UBS_UINT32 CtxParams[MAX_PRIME_LENGTH+MAX_PRIME_LENGTH+MAX_DP_LENGTH+MAX_DQ_LENGTH+MAX_PRINV_LENGTH];
+} Pri_RSA_CtxCmdBuf_t, *Pri_RSA_CtxCmdBuf_pt;
+
+/*DSA signing */
+#define DSA_STATIC_SIGN_CONTEXT_SIZE  (6*sizeof(unsigned short))
+typedef struct DSA_Sign_CtxCmdBuf_struct {
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE unsigned short sha1_enable;	 /* hash performed by SHA1 or by SW */
+  VOLATILE unsigned short Reserved;	 /*                                 */
+  VOLATILE unsigned short rng_enable;	 /* Private key x by RNG or SW      */ 
+  VOLATILE unsigned short p_length; 	 /* Modulus p length in bits        */
+#else
+  VOLATILE unsigned short Reserved;	 /*                                 */
+  VOLATILE unsigned short sha1_enable;	 /* hash performed by SHA1 or by SW */
+  VOLATILE unsigned short p_length; 	 /* Modulus p length in bits        */
+  VOLATILE unsigned short rng_enable;	 /* Private key x by RNG or SW      */ 
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+  VOLATILE UBS_UINT32 CtxParams[4*MAX_MODULUS_LENGTH]; /* q,p,g,x */
+} DSA_Sign_CtxCmdBuf_t, *DSA_Sign_CtxCmdBuf_pt;
+
+/*DSA Verification */
+#define DSA_STATIC_VERIFY_CONTEXT_SIZE  (6*sizeof(unsigned short))
+typedef struct DSA_Verify_CtxCmdBuf_struct {
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE unsigned short sha1_enable;	 /* hash performed by SHA1 or by SW */
+  VOLATILE unsigned short Reserved;	 /*                                 */
+  VOLATILE unsigned short Reserved2;     /* not used                        */
+  VOLATILE unsigned short p_length; 	 /* Modulus p length in bits        */
+#else
+  VOLATILE unsigned short Reserved;	 /*                                 */
+  VOLATILE unsigned short sha1_enable;	 /* hash performed by SHA1 or by SW */
+  VOLATILE unsigned short p_length; 	 /* Modulus p length in bits        */
+  VOLATILE unsigned short Reserved2;     /* not used                        */
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+  VOLATILE UBS_UINT32 CtxParams[4*MAX_MODULUS_LENGTH]; /* q,p,g,y */
+} DSA_Verify_CtxCmdBuf_t, *DSA_Verify_CtxCmdBuf_pt;
+
+/* RNG Bypass */
+#define RNG_STATIC_CONTEXT_SIZE 64
+typedef struct RNG_CtxCmdBuf_struct {
+  UBS_UINT32 none;
+} RNG_CtxCmdBuf_t, *RNG_CtxCmdBuf_pt;
+
+
+/* Generic math context buffer */
+#define MATH_STATIC_CONTEXT_SIZE  (4*sizeof(unsigned short))
+typedef struct Math_CtxCmdBuf_struct {
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE unsigned short exponent_length; /* Exponent (N-2) length in bits */
+                                           /* 0 when not present            */
+  VOLATILE unsigned short modulus_length;  /* Modulus N Length in bits 	    */
+#else
+  VOLATILE unsigned short modulus_length;  /* Modulus N Length in bits 	    */
+  VOLATILE unsigned short exponent_length; /* Exponent (N-2) length in bits */
+                                           /* 0 when not present            */
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+  VOLATILE UBS_UINT32 NE[2*MAX_MODULUS_LENGTH];  /* Modulus N, N2 (dblmodexp only) */
+} Math_CtxCmdBuf_t, *Math_CtxCmdBuf_pt;
+
+typedef union CtxCmdBuf_u {
+	DH_Send_CtxCmdBuf_t		DH_Send_CtxCmdBuf;
+	DH_REC_CtxCmdBuf_t		DH_REC_CtxCmdBuf;
+	Pub_RSA_CtxCmdBuf_t		Pub_RSA_CtxCmdBuf;
+	Pri_RSA_CtxCmdBuf_t		Pri_RSA_CtxCmdBuf;
+	DSA_Sign_CtxCmdBuf_t		DSA_Sign_CtxCmdBuf;
+	DSA_Verify_CtxCmdBuf_t		DSA_Verify_CtxCmdBuf;
+        RNG_CtxCmdBuf_t		        RNG_CtxCmdBuf;
+	Math_CtxCmdBuf_t		Math_CtxCmdBuf;
+    } CtxCmdBuf_t, *CtxCmdBuf_pt ; 
+
+typedef struct KeyContextUnaligned_s {
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE unsigned short 	  cmd_structure_length;
+  VOLATILE unsigned short 	  operation_type; 
+#else
+  VOLATILE unsigned short 	  operation_type; 
+  VOLATILE unsigned short 	  cmd_structure_length;
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+  VOLATILE CtxCmdBuf_t  CtxCmdBuf;
+  VOLATILE UBS_UINT32  	  PhysicalAddress;
+  /* The following fields are used as redirection when
+     renormailization is required after a key operation. */
+  void(*UserCallback)(unsigned long Context,ubsec_Status_t Result);
+  unsigned long	UserContext;
+  long NormBits;
+  ubsec_LongKey_pt ResultKey[2];
+  ubsec_LongKey_pt ResultRNG;
+} KeyContextUnaligned_t;
+
+#define KEYCONTEXT_ALIGNMENT 64 /* Boundary to which KeyContexts will be aligned. Must be power of 2 */
+
+#if (SYS_CACHELINE_SIZE >= KEYCONTEXT_ALIGNMENT) 
+  #define KEYCONTEXT_ALIGNMENT_PAD (KEYCONTEXT_ALIGNMENT - (sizeof(KeyContextUnaligned_t) & (KEYCONTEXT_ALIGNMENT-1)))
+#else
+  #undef KEYCONTEXT_ALIGNMENT_PAD
+#endif
+
+/***********************************************************************/
+/* Hardware (DMA) version of above structure that is 'alignably' sized */
+/* (an integer multiple of KEYCONTEXT_ALIGNMENT bytes in length).      */
+/* Any changes made to either structure must be mirrored in the other  */
+/***********************************************************************/
+
+typedef struct KeyContext_s {
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+  VOLATILE unsigned short 	  cmd_structure_length;
+  VOLATILE unsigned short 	  operation_type; 
+#else
+  VOLATILE unsigned short 	  operation_type; 
+  VOLATILE unsigned short 	  cmd_structure_length;
+#endif /* UBS_CRYPTONET_ATTRIBUTE conditional */
+  VOLATILE CtxCmdBuf_t  CtxCmdBuf;
+  VOLATILE UBS_UINT32  	  PhysicalAddress;
+  /* The following fields are used as redirection when
+     renormailization is required after a key operation. */
+  void(*UserCallback)(unsigned long Context,ubsec_Status_t Result);
+  unsigned long	UserContext;
+  long NormBits;
+  ubsec_LongKey_pt ResultKey[2];
+  ubsec_LongKey_pt ResultRNG;
+#if (SYS_CACHELINE_SIZE >= KEYCONTEXT_ALIGNMENT) 
+  /***********************************************************************/
+  /**** If KeyContextUnaligned_t is cacheline sized, the following    ****/
+  /**** pad array will have a subscript of zero. Under this condition ****/
+  /**** the following line should be commented out.                   ****/ 
+  unsigned char pad[KEYCONTEXT_ALIGNMENT_PAD];                        /***/
+  /***********************************************************************/
+#endif
+} KeyContext_t, *KeyContext_pt;
+
+#define NULL_KEY_CONTEXT (KeyContext_pt) 0
+
+#define UBSEC_IS_KEY_DEVICE(pDevice) ((UBSEC_IS_CRYPTO_DEVICEID(pDevice->DeviceID))==0) 
+
+#endif /* _UBSKEY_H_ */
diff -urNp linux-8030/drivers/addon/bcm/ubskeytest.c linux-8040/drivers/addon/bcm/ubskeytest.c
--- linux-8030/drivers/addon/bcm/ubskeytest.c
+++ linux-8040/drivers/addon/bcm/ubskeytest.c
@@ -0,0 +1,350 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubskeytest.c: Ubsec Key Bring up Diagnostics routines
+ */
+
+/*
+ * Revision History:
+ *
+ * 02/05/2001 PW Created.
+ * 04/23/2001 RJT Added support for CPU-DMA memory synchronization
+ * 10/09/2001 SRM 64 bit port
+ */
+
+
+#include "ubsincl.h"
+
+#ifndef ASYNC
+static void callback(unsigned long PacketContext,ubsec_Status_t Result);
+#endif
+
+/* computing Y=G**X/N */
+
+/*  1. base DHP g - G */
+static UBS_UINT32 G[TEST_KEY_BLOCK_SIZE/4]= {
+  0x62A13103, 0xC095F9CE, 0xF2434441, 0x898B31C8,
+  0xEAF84EFB, 0x0D3C831F, 0x6E1C8601, 0xE54D28EE,
+  0xBE7244F0, 0xAE38B60B, 0x8711944A, 0x43F30F4C,
+  0xA29FF11D, 0x6D2E9F77, 0x46DEBA6B, 0xB3D3C7A2
+};
+
+/* 2. Mod DHP n - N */
+static UBS_UINT32 N[TEST_KEY_BLOCK_SIZE/4]= {
+  0x99286689, 0x748EB488, 0xD146DD17, 0xCF124E36,
+  0xA9C4BCDD, 0xC9571116, 0x4BEEE715, 0x5B1DCC42,
+  0x6AAB6260, 0xCC4CCF11, 0xCB631589, 0x12CD8785,
+  0xBF512BBC, 0x70197EA2, 0x0AE59A21, 0xB70636E2
+};
+
+/* 3. DHP x - UserX  */
+static UBS_UINT32 UserX[TEST_KEY_BLOCK_SIZE/4]= {
+  0xE910C7CA, 0x225387FF, 0xA8EB0590, 0xAD40FA33,
+  0x85A46F95, 0x63E5D86F, 0xFF2F4AF8, 0x2D9999A8,
+  0xA3CDB938, 0x1D4574DA, 0x69BF06C8, 0xBACF2C6D,
+  0x4E997E30, 0xC5EB1F75, 0x8C546D95, 0xF6020408
+};
+
+/* 4.  result DHP y - Y */
+static UBS_UINT32 Y[TEST_KEY_BLOCK_SIZE/4]= {
+  0x0377E5D2, 0x142CEF26, 0xF9F9023C, 0xE7ED8561, 
+  0x153459E1, 0x26BE6B17, 0x47F62506, 0xD272E194, 
+  0xAD15BFA0, 0x2344F145, 0x3E671269, 0x8CFB6945, 
+  0x7C6070F8, 0x039BF0A2, 0xEE99CE09, 0x31FC14FC 
+};
+
+
+/* These will be used as type OS_MemHandle_t. However, some systems 
+	define OS_MemHandle_t as void*; some compilers don't like to use
+	void* in declarations */
+static unsigned char *G_Handle, *N_Handle, *UserX_Handle, *Y_Handle, *X_Handle;
+static ubsec_KeyCommandInfo_pt Kcmd;
+
+static ubsec_Status_t CompareKeyResults(void);
+static void KeyCallback(unsigned long PacketContext,ubsec_Status_t Result);
+
+
+/*
+ * ubsec_TestKeyDevice
+ */
+ubsec_Status_t
+ubsec_TestKeyDevice(ubsec_DeviceContext_t Ubsec_Context,void(*CompletionCallback)(unsigned long PacketContext,ubsec_Status_t Result),unsigned long CompletionContext)
+{
+  unsigned char* pG;
+  unsigned char* pN;
+  unsigned char* pX;
+  unsigned char* pUserX;
+  unsigned char* pY;
+  int num_packets=1;
+  int i, Status;
+  UBS_UINT32 SaveConfig;
+  DeviceInfo_pt pDevice=(DeviceInfo_pt)Ubsec_Context;
+
+  Dbg_Print(DBG_TEST,("ubskeytest: key self-test..\n"));
+  /* 
+   * First reset the device and complete any pending requests.
+   */
+  ubsec_ResetDevice(Ubsec_Context);
+
+  /* First allocate and clear the Key Command area. */
+  if((Kcmd = (ubsec_KeyCommandInfo_t *)OS_AllocateMemory(sizeof(ubsec_KeyCommandInfo_t))) == NULL) {
+    return(UBSEC_STATUS_NO_RESOURCE);
+  }
+  RTL_MemZero(Kcmd, sizeof(ubsec_KeyCommandInfo_t));
+
+  if((G_Handle = (unsigned char*)OS_AllocateDMAMemory(pDevice,TEST_KEY_BLOCK_SIZE)) == NULL) {
+    return(UBSEC_STATUS_NO_RESOURCE);
+  }
+  pG = (unsigned char*)OS_GetVirtualAddress(G_Handle);
+  RTL_MemZero(pG, TEST_KEY_BLOCK_SIZE);
+
+  if((N_Handle = OS_AllocateDMAMemory(pDevice,TEST_KEY_BLOCK_SIZE)) == NULL) {
+    OS_FreeDMAMemory(G_Handle,TEST_KEY_BLOCK_SIZE);
+    return(UBSEC_STATUS_NO_RESOURCE);
+  }
+  pN = (unsigned char*)OS_GetVirtualAddress(N_Handle);
+  RTL_MemZero(pN, TEST_KEY_BLOCK_SIZE);
+
+  if((UserX_Handle = OS_AllocateDMAMemory(pDevice,TEST_KEY_BLOCK_SIZE)) == NULL) {
+    OS_FreeDMAMemory(N_Handle,TEST_KEY_BLOCK_SIZE);
+    OS_FreeDMAMemory(G_Handle,TEST_KEY_BLOCK_SIZE);
+    return(UBSEC_STATUS_NO_RESOURCE);
+  }
+  pUserX = (unsigned char*)OS_GetVirtualAddress(UserX_Handle);
+  RTL_MemZero(pUserX, TEST_KEY_BLOCK_SIZE);
+
+  if((Y_Handle = OS_AllocateDMAMemory(pDevice,TEST_KEY_BLOCK_SIZE)) == NULL) {
+    OS_FreeDMAMemory(UserX_Handle,TEST_KEY_BLOCK_SIZE);
+    OS_FreeDMAMemory(N_Handle,TEST_KEY_BLOCK_SIZE);
+    OS_FreeDMAMemory(G_Handle,TEST_KEY_BLOCK_SIZE);
+    return(UBSEC_STATUS_NO_RESOURCE);
+  }
+  pY = (unsigned char*)OS_GetVirtualAddress(Y_Handle);
+  RTL_MemZero(pY, TEST_KEY_BLOCK_SIZE);
+
+  if((X_Handle = OS_AllocateDMAMemory(pDevice,TEST_KEY_BLOCK_SIZE)) == NULL) {
+    OS_FreeDMAMemory(Y_Handle,TEST_KEY_BLOCK_SIZE);
+    OS_FreeDMAMemory(UserX_Handle,TEST_KEY_BLOCK_SIZE);
+    OS_FreeDMAMemory(N_Handle,TEST_KEY_BLOCK_SIZE);
+    OS_FreeDMAMemory(G_Handle,TEST_KEY_BLOCK_SIZE);
+    return(UBSEC_STATUS_NO_RESOURCE);
+  }
+  pX = (unsigned char*)OS_GetVirtualAddress(X_Handle);
+  RTL_MemZero(pX, TEST_KEY_BLOCK_SIZE);
+
+
+Dbg_Print(DBG_TEST,("\npG, 	  pN, 	    pUserX,   pY, 	pX\n0x%x 0x%x 0x%x 0x%x 0x%x\n\n", pG, pN, pUserX, pY, pX));
+
+
+  /* Copy the selftest data (TEST_KEY_BLOCK_SIZE chars * 8 bits/char) bits */
+
+ #if defined(UBS_OVERRIDE_LONG_KEY_MODE)
+  copywords((UBS_UINT32 *)pG,(UBS_UINT32 *)G,(TEST_KEY_BLOCK_SIZE+3)/4);
+  copywords((UBS_UINT32 *)pN,(UBS_UINT32 *)N,(TEST_KEY_BLOCK_SIZE+3)/4);
+  copywords((UBS_UINT32 *)pUserX,(UBS_UINT32 *)UserX,(TEST_KEY_BLOCK_SIZE+3)/4);
+ #else 
+  RTL_Memcpy(pG,G,TEST_KEY_BLOCK_SIZE);
+  RTL_Memcpy(pN,N,TEST_KEY_BLOCK_SIZE);
+  RTL_Memcpy(pUserX,UserX,TEST_KEY_BLOCK_SIZE);
+ #endif /* UBS_OVERRIDE_LONG_KEY_MODE */
+
+  /* Make sure DMA memory actually holds recent CPU-initialized buffer data */
+  OS_SyncToDevice(UserX_Handle,0,TEST_KEY_BLOCK_SIZE);
+
+  /* set up command parameters */
+  Kcmd->Command= UBSEC_DH_PUBLIC;
+  Kcmd->Parameters.DHParams.Y.KeyLength = 8*TEST_KEY_BLOCK_SIZE; /* in bits */
+  Kcmd->Parameters.DHParams.N.KeyLength = 8*TEST_KEY_BLOCK_SIZE; /* in bits */
+  Kcmd->Parameters.DHParams.G.KeyLength = 8*TEST_KEY_BLOCK_SIZE; /* in bits */
+
+  /* need to setup X as well, as the chip write back the userX to this */
+  Kcmd->Parameters.DHParams.X.KeyLength = 8*TEST_KEY_BLOCK_SIZE; /* in bits */
+  Kcmd->Parameters.DHParams.UserX.KeyLength = 8*TEST_KEY_BLOCK_SIZE; /* in bits */
+
+  Kcmd->Parameters.DHParams.Y.KeyValue = Y_Handle;         /* Memory handle */
+  Kcmd->Parameters.DHParams.N.KeyValue = N_Handle;         /* Memory handle */
+  Kcmd->Parameters.DHParams.G.KeyValue = G_Handle;         /* Memory handle */
+  Kcmd->Parameters.DHParams.X.KeyValue = X_Handle;         /* Memory handle */ 
+  Kcmd->Parameters.DHParams.UserX.KeyValue = UserX_Handle; /* Memory handle */ 
+
+  /* (usually random) UserX provided manually (by S/W) */
+  Kcmd->Parameters.DHParams.RNGEnable  = 0; 
+
+  SaveConfig=UBSEC_READ_CONFIG(pDevice); 
+
+  /* Are we completing sync or async */
+  if (CompletionCallback) {
+    pDevice->KeySelfTestCallBack=CompletionCallback;
+    pDevice->KeySelfTestContext=CompletionContext;
+    Kcmd->CompletionCallback=KeyCallback;
+    Kcmd->CommandContext=(unsigned long) pDevice;
+  }
+  else {
+    /* Turn off interrupts while waiting. */
+    UBSEC_DISABLE_INT(pDevice);
+  }
+
+  switch (Status=ubsec_KeyCommand(Ubsec_Context,Kcmd,&num_packets) ) {
+  case UBSEC_STATUS_SUCCESS:
+    break;
+  case UBSEC_STATUS_TIMEOUT:
+    Dbg_Print(DBG_FATAL,( "ubsec:  Key SelfTest Command timeout\n"));
+    ubsec_ResetDevice(Ubsec_Context);
+    goto Free_DMAMemory_and_Return_Status;
+    break;
+  case UBSEC_STATUS_INVALID_PARAMETER:
+    Dbg_Print(DBG_FATAL,( "ubsec:  Key SelfTest Failed Invalid parameter\n"));
+    goto Free_DMAMemory_and_Return_Status;
+    break;
+  case UBSEC_STATUS_NO_RESOURCE:
+    Dbg_Print(DBG_FATAL,( "ubsec:  Key SelfTest Failed No Resource\n"));
+    goto Free_DMAMemory_and_Return_Status;
+  default:
+    Dbg_Print(DBG_FATAL,( "ubsec:  Key SelfTest Failure unknown %x\n",Status));
+    goto Free_DMAMemory_and_Return_Status;
+    break;
+  }
+
+  /* Are we completing sync or async */
+  if (CompletionCallback) {
+    return(Status);
+  }
+
+    
+#ifndef BLOCK
+ while ((Status=WaitForCompletion(pDevice,(UBS_UINT32)100000,UBSEC_KEY_LIST))
+	== UBSEC_STATUS_SUCCESS); /* wait for them all to complete */
+#endif
+
+  /* Restore configuration status  */
+  UBSEC_WRITE_CONFIG(pDevice,SaveConfig);
+
+#ifdef BLOCK
+  /* Invalid parameter means that no more left on pending queue */
+  if (Status != UBSEC_STATUS_INVALID_PARAMETER) {
+#else
+  if (Status != UBSEC_STATUS_SUCCESS) {
+#endif
+    /* Keep error Status for return */;
+  }
+  else {
+    /* Make sure CPU sees current state of recently DMA'd data buffers */
+    OS_SyncToCPU(X_Handle,0,TEST_KEY_BLOCK_SIZE);
+    OS_SyncToCPU(Y_Handle,0,TEST_KEY_BLOCK_SIZE);
+    /* then get new Status from compare test */
+    Status = CompareKeyResults();
+  }
+
+ Free_DMAMemory_and_Return_Status:
+
+	OS_FreeDMAMemory(X_Handle,TEST_KEY_BLOCK_SIZE);
+	OS_FreeDMAMemory(Y_Handle,TEST_KEY_BLOCK_SIZE);
+	OS_FreeDMAMemory(UserX_Handle,TEST_KEY_BLOCK_SIZE);
+	OS_FreeDMAMemory(N_Handle,TEST_KEY_BLOCK_SIZE);
+	OS_FreeDMAMemory(G_Handle,TEST_KEY_BLOCK_SIZE);
+	OS_FreeMemory(Kcmd,sizeof(ubsec_KeyCommandInfo_t));
+	return (Status);
+
+}
+
+/*
+ * Compare the results of the key operation.
+ */
+static ubsec_Status_t
+CompareKeyResults(void)
+{
+  unsigned char *pX, *pY;
+  int i;
+
+  pY = (unsigned char*)OS_GetVirtualAddress(Y_Handle);
+  pX = (unsigned char*)OS_GetVirtualAddress(X_Handle);
+
+  /* cmp with golden data */
+  /* print out a few bytes to see it for real */
+  /* Y points to golden data, pY points to data written by the chip */
+    Dbg_Print(DBG_TEST,("\nCompare ..."));
+    Dbg_Print(DBG_TEST,("\npY %x %x %x %x %x %x %x %x ...",*(pY),*(pY+1),*(pY+2),*(pY+3),*(pY+4),*(pY+5),*(pY+6),*(pY+7))); 
+    Dbg_Print(DBG_TEST,("\n Y %x %x %x %x %x %x %x %x ...\n\n",*(Y),*(Y+1),*(Y+2),*(Y+3),*(Y+4),*(Y+5),*(Y+6),*(Y+7))); 
+
+
+#if defined(UBS_OVERRIDE_LONG_KEY_MODE)
+  for (i=0 ; i<((TEST_KEY_BLOCK_SIZE+3)/4) ; i++) {
+    if (BYTESWAPLONG(((UBS_UINT32*)pY)[i]) != ((UBS_UINT32*)Y)[i]) {
+	Dbg_Print(DBG_TEST,("ubstest: key self-test results do not match\n"));
+	return(UBSEC_STATUS_DEVICE_FAILED);
+    }
+  }
+  for (i=0 ; i<((TEST_KEY_BLOCK_SIZE+3)/4) ; i++) {
+    if (BYTESWAPLONG(((UBS_UINT32*)pX)[i]) != ((UBS_UINT32*)UserX)[i]) {
+	Dbg_Print(DBG_TEST,("ubstest: key self-test results do not match\n"));
+	return(UBSEC_STATUS_DEVICE_FAILED);
+    }
+  }
+#else
+  if (RTL_Memcmp(pY,Y,TEST_KEY_BLOCK_SIZE)) {
+    Dbg_Print(DBG_TEST,("ubstest: key self-test results do not match\n"));
+    return(UBSEC_STATUS_DEVICE_FAILED);
+  }
+  if (RTL_Memcmp(pX,UserX,TEST_KEY_BLOCK_SIZE)) {
+    Dbg_Print(DBG_TEST,("ubstest: key self-test results do not match\n"));
+    return(UBSEC_STATUS_DEVICE_FAILED);
+  }
+#endif /* UBS_OVERRIDE_LONG_KEY_MODE */
+
+
+  Dbg_Print(DBG_TEST,("key self-test passed successfully.\n"));
+
+  return(UBSEC_STATUS_SUCCESS);
+}
+
+/*
+ * KeyCallback: Intermediate callback routine for key selftest.
+ * This is called when the key operation completes. We need to check
+ * the result of the key operation and indicate the status to the 
+ * initiator of the test.
+ */
+static void KeyCallback(unsigned long Context,ubsec_Status_t Result)
+{
+  DeviceInfo_pt pDevice=(DeviceInfo_pt)Context;
+
+  if (Result == UBSEC_STATUS_SUCCESS) { 
+    /* Make sure CPU sees current state of recently DMA'd data buffers */
+    OS_SyncToCPU(X_Handle,0,TEST_KEY_BLOCK_SIZE);
+    OS_SyncToCPU(Y_Handle,0,TEST_KEY_BLOCK_SIZE);
+    Result=CompareKeyResults();
+  }
+
+  OS_FreeDMAMemory(X_Handle,TEST_KEY_BLOCK_SIZE);
+  OS_FreeDMAMemory(Y_Handle,TEST_KEY_BLOCK_SIZE);
+  OS_FreeDMAMemory(UserX_Handle,TEST_KEY_BLOCK_SIZE);
+  OS_FreeDMAMemory(N_Handle,TEST_KEY_BLOCK_SIZE);
+  OS_FreeDMAMemory(G_Handle,TEST_KEY_BLOCK_SIZE);
+  OS_FreeMemory(Kcmd,sizeof(ubsec_KeyCommandInfo_t));
+
+  (*pDevice->KeySelfTestCallBack)(pDevice->KeySelfTestContext,Result);
+
+}
+
+
diff -urNp linux-8030/drivers/addon/bcm/ubslinux.h linux-8040/drivers/addon/bcm/ubslinux.h
--- linux-8030/drivers/addon/bcm/ubslinux.h
+++ linux-8040/drivers/addon/bcm/ubslinux.h
@@ -0,0 +1,154 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubssys.h:  ubsec operating system dependencies
+ */
+
+/*
+ * Revision History:
+ *
+ * 09/xx/99 SOR Created.
+ * 07/26/00 SOR Virtual/Physical Memory manipulation modifications
+ * March 2001 PW Release for Linux 2.4 UP and SMP kernel 
+ * 10/09/2001 SRM 64 bit port.
+ */
+
+#ifndef _UBSLINUX_H
+#define _UBSLINUX_H
+
+#ifdef LINUX_DEVICE
+
+#include <linux/version.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/ptrace.h>
+#include <linux/in.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/timer.h>
+#include <asm/irq.h>           /* For NR_IRQS only. */
+#include <asm/bitops.h>
+#include <asm/io.h>                   
+
+
+#include <linux/tqueue.h>
+#include <linux/delay.h>
+
+#define VOLATILE volatile
+#define UBSECAPI
+#define OS_MemHandle_t void *
+#define OS_DeviceInfo_t void *
+
+
+#ifdef UBSDBG
+#define DbgPrint(x) printk x
+#endif
+
+
+extern void *LinuxMapPhysToIO(unsigned long Physical_Address, int size);
+extern void LinuxUnMapIO(unsigned long ioaddr);
+extern void LinuxAllocateIRQ(int irq,void *context);
+extern void LinuxFreeIRQ(int irq, void *context);
+extern void LinuxWaitus( int wait_us );
+extern void *LinuxAllocateMemory(unsigned long size);
+extern void *LinuxAllocateDMAMemory(unsigned long size);
+extern void LinuxFreeMemory(void *virtual);
+extern void LinuxFreeDMAMemory(void *virtual);
+extern unsigned long LinuxGetPhysicalAddress(void *virtual);
+extern unsigned long LinuxGetVirtualAddress(void *virtual);
+
+
+/*************************** 
+ * Memory allocations 
+ ***************************/ 
+
+#define OS_AllocateMemory(size)    	       LinuxAllocateMemory(size)
+#define OS_AllocateDMAMemory(pDevice,size)     LinuxAllocateDMAMemory(size)
+#define OS_FreeMemory(mem,size)     	       LinuxFreeMemory(mem);
+#define OS_FreeDMAMemory(mem,size)  	       LinuxFreeDMAMemory(mem);
+
+/*************************** 
+ * Interrupt related functions
+ ***************************/ 
+#define OS_AllocateISR(irq,context,callback)   LinuxAllocateIRQ(irq,(void *)context->OsDeviceInfo)
+#define OS_FreeISR(irq,context)                LinuxFreeIRQ(irq,(void *)context->OsDeviceInfo)
+#define OS_ScheduleCallBack(callback,Context)  LinuxScheduleCallback((void *)Context,Context->OsDeviceInfo)
+#define OS_Waitus(wait_us) 	               LinuxWaitus(wait_us) 
+
+/*************************** 
+ * Critical section functions
+ ***************************/ 
+#if 0
+extern void 		LinuxInitCriticalSection(OS_DeviceInfo_t);
+extern unsigned long 	LinuxEnterCriticalSection(OS_DeviceInfo_t);
+extern unsigned long 	LinuxTestCriticalSection(OS_DeviceInfo_t);
+extern void  		LinuxLeaveCriticalSection(OS_DeviceInfo_t);
+#endif
+
+#define OS_InitCriticalSection(pDevice)     	       LinuxInitCriticalSection(pDevice->OsDeviceInfo)
+#define OS_EnterCriticalSection(pDevice,SaveConfig)    LinuxEnterCriticalSection(pDevice->OsDeviceInfo)
+#define OS_LeaveCriticalSection(pDevice,SaveConfig)    LinuxLeaveCriticalSection(pDevice->OsDeviceInfo) 
+#define OS_TestCriticalSection(pDevice,SaveConfig)     LinuxTestCriticalSection(pDevice->OsDeviceInfo)
+
+/*************
+ * IO Mapping 
+ *************/ 
+#define OS_MapPhysToIO(pDevice,Physical_Address,size)  LinuxMapPhysToIO(Physical_Address,size )
+#define OS_UnMapIO(pDevice,ioaddr)     		       LinuxUnMapIO(ioaddr)
+
+/********************************* 
+ * virtal and physical addreesses 
+ *********************************/ 
+#define OS_GetPhysicalAddress(MemHandle) 	       LinuxGetPhysicalAddress(MemHandle)
+#define OS_GetVirtualAddress(MemHandle)                LinuxGetVirtualAddress(MemHandle) 
+
+/*************************** 
+ * system memory functions 
+ ***************************/ 
+#define  RTL_MemZero(mem,bytes)        memset(( void *)mem,0,bytes)
+#define  RTL_Memset(mem,val,bytes)     memset(( void *)mem,val,bytes)
+#define  RTL_Memcpy(dest,source,bytes) memcpy(( void *)dest,( void *)source,bytes)
+#define  RTL_Memcmp(dest,source,bytes) memcmp(( void *)dest,( void *)source,bytes)
+
+/*************************** 
+ * Access to our chip 
+ ***************************/ 
+#if 0
+#define OS_IOMemWrite32(Address,val)   (*Address)=val
+#define OS_IOMemRead32(Address)        (*Address)
+#else
+#define OS_IOMemWrite32(Address,val)   writel(val, Address)
+#define OS_IOMemRead32(Address)        readl(Address)
+#endif
+
+#endif /* LINUX_DEVICE */
+
+#endif /* _UBSLINUX_H_ */
diff -urNp linux-8030/drivers/addon/bcm/ubsmath.c linux-8040/drivers/addon/bcm/ubsmath.c
--- linux-8030/drivers/addon/bcm/ubsmath.c
+++ linux-8040/drivers/addon/bcm/ubsmath.c
@@ -0,0 +1,615 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubsmath.c: Math function acceleration functions
+ *
+ * Revision History:
+ *
+ * 03/17/2000 SOR Created
+ * 07/06/2000 DPA Fixes for SMP operation
+ * 07/26/00 SOR Virtual/Physical Memory manipulation modifications
+ * 04/20/2001 RJT Added support for CPU-DMA memory synchronization
+ * 07/16/2001 RJT Added support for BCM5821
+ * 10/09/2001 SRM 64 bit port
+ */
+
+#include "ubsincl.h"
+
+/*
+ * ubsec_MathCommand: Process a list of Math commands.
+ *
+ * Immediate Status is returned. Completion status is returned
+ * on a per command callback
+ */
+ubsec_Status_t 
+ubsec_MathCommand(ubsec_DeviceContext_t Context,
+	      ubsec_MathCommandInfo_pt pCommand,
+	      int *NumCommands)
+{
+  DeviceInfo_pt 		pDevice=(DeviceInfo_pt)Context;
+  VOLATILE MasterCommand_t  	*pMCR;
+  VOLATILE Packet_t         	*pPacket;
+  VOLATILE KeyContext_t  	*pContext;
+  VOLATILE int             	PacketIndex;
+  int 				CommandIndex=0;
+  int 				CommandCount=*NumCommands;
+  ubsec_Status_t 		Status;
+  unsigned long 		SaveConfig;
+  ubsec_MathCommandParams_pt    pParams;
+  VOLATILE Math_CtxCmdBuf_t     *pMathContext;
+  int offset;
+  VOLATILE DataBufChainList_t   *FragPtr, *NextFragPtr;
+  int DataLength;
+  int NormalizeLen,NrmBits=0;
+  int element;
+  UBS_UINT32 *longkey;
+  ubsec_MemAddress_t PhysAddr;
+  CallBackInfo_pt pCompletionContext;
+
+  if (!UBSEC_IS_KEY_DEVICE(pDevice)) {
+    Dbg_Print(DBG_FATAL,( "ubsec: Math Command for a crypto device\n " ));
+    return(UBSEC_STATUS_NO_DEVICE );
+  }
+
+  Dbg_Print(DBG_MATH,( "ubsec:  Math command %d ",*NumCommands ));
+  /*
+   * Check some parameters
+   */    
+  if(pDevice==NULL_DEVICE_INFO) {
+    Dbg_Print(DBG_FATAL,( "NO DEV\n " ));
+    return(UBSEC_STATUS_NO_DEVICE );
+  }
+  Dbg_Print(DBG_MATH,( "\n"));
+
+  if (OS_EnterCriticalSection(pDevice,SaveConfig)) {
+    return(UBSEC_STATUS_DEVICE_BUSY);
+  }
+
+  /* Get the next MCR to load */
+ Get_New_MCR:
+  *NumCommands=CommandIndex; /* Update number completed */
+
+  if ((pMCR=GetFreeMCR(pDevice,UBSEC_KEY_LIST,&Status))== NULL_MASTER_COMMAND) 
+    goto Error_Return;
+
+  /* Add packets to this MCR. */
+
+  Dbg_Print(DBG_MATH,( "ubsec: mcr_index %d MCR <%0x,%0x>\n",pMCR->Index,pMCR,pMCR->MCRPhysicalAddress));
+  /* Initialize the packet information */
+  PacketIndex = pMCR->NumberOfPackets; 
+  pPacket = &(pMCR->PacketArray[PacketIndex]); /* Set up the current packet. */
+  pContext = pMCR->KeyContextList[PacketIndex]; 
+  pMathContext=&pContext->CtxCmdBuf.Math_CtxCmdBuf;
+  Status=UBSEC_STATUS_SUCCESS; /* Wishful thinking? */
+
+
+  Dbg_Print(DBG_MATH,( "ubsec: PacketIndex %d \n",pMCR->NumberOfPackets));
+
+  /* Process all the commands in the command list. */
+  for (; CommandIndex < CommandCount ; CommandIndex++) { /* Add all the packets to the MCR*/
+    if( PacketIndex >= MCR_MAXIMUM_PACKETS ) {
+      Dbg_Print(DBG_MATH,( "ubsec:  overran mcr buffer. %d\n",PacketIndex,CommandIndex ));
+      /* 
+       * We have filled this MCR. 
+       * Advance next free. Wrap around if necessary
+       */
+      pDevice->NextFreeMCR[UBSEC_KEY_LIST]=(MasterCommand_pt)pMCR->pNextMCR;
+      Dbg_Print(DBG_MATH,( "ubsec:  PushMCR ..." ));
+      PushMCR(pDevice); /* Get it going (pipeline) */
+      goto Get_New_MCR; /* Try to add to the next MCR */
+    }
+
+    pCompletionContext=(CallBackInfo_pt)&pMCR->CompletionArray[PacketIndex];
+
+    /* First set up the command type and parameters. */
+    Dbg_Print(DBG_MATH,( "ubsec: Math Command packet_Index %d, Context Buf <%0x,%0x>\n",PacketIndex,pContext,pContext->PhysicalAddress ));
+    pPacket->PacketContextBuffer=pContext->PhysicalAddress;
+    
+    switch (pCommand->Command) {
+    case UBSEC_MATH_MODADD :
+      pContext->operation_type	= OPERATION_MOD_ADD;
+      break;
+    case UBSEC_MATH_MODSUB :
+      pContext->operation_type	= OPERATION_MOD_SUB;
+      break;
+    case UBSEC_MATH_MODMUL :
+      pContext->operation_type	= OPERATION_MOD_MULT;
+      break;
+    case UBSEC_MATH_MODEXP :
+      pContext->operation_type	= OPERATION_MOD_EXPON;
+      break;
+    case UBSEC_MATH_MODREM :
+      pContext->operation_type	= OPERATION_MOD_REDUCT;
+      break;
+#if defined(UBSEC_582x)
+    case UBSEC_MATH_DBLMODEXP :
+      /* DBLMODEXP supported in "582x mode" driver for BCM5821 and later chips only */
+      if (pDevice->DeviceID < BROADCOM_DEVICE_ID_5821) {
+	Status=(UBSEC_STATUS_INVALID_PARAMETER);
+	goto Error_Return;
+      }
+      pContext->operation_type	= OPERATION_MOD_DBLEXP;
+      break;
+#endif /* UBSEC_582x */
+
+    default:
+      Status=(UBSEC_STATUS_INVALID_PARAMETER);
+      goto Error_Return;
+    }
+
+    pParams=&pCommand->Parameters;
+
+    /* Clear the context. */
+    RTL_MemZero(pMathContext,sizeof(Math_CtxCmdBuf_t));
+
+    pContext->cmd_structure_length= MATH_STATIC_CONTEXT_SIZE;
+
+    if ( pCommand->Command != UBSEC_MATH_DBLMODEXP) {
+      /* The modulus needs to be aligned on a 512/768 or 1024 bit boundary. */
+      /*
+       * Save amount to normalize/renormalize.
+       */
+      if (pParams->ModN.KeyLength <=512)
+	NormalizeLen=512;
+      else if (pParams->ModN.KeyLength <=768)
+	NormalizeLen=768;
+      else if (pParams->ModN.KeyLength <=1024)
+	NormalizeLen=1024;
+#ifdef UBSEC_582x_CLASS_DEVICE
+      else if (pParams->ModN.KeyLength <=1536)
+	NormalizeLen=1536;
+      else
+	NormalizeLen=2048;
+#else
+      else
+	return(UBSEC_STATUS_INVALID_PARAMETER);
+#endif
+    } /* end non-DBLMODEXP modulus size alignment block */
+    else { 
+      /* DBLMODEXP operation */
+      NormalizeLen=512; /* The DBLMODEXP moduli must both be 512 bits (or fewer) long */
+    }
+
+#ifndef UBSEC_HW_NORMALIZE
+    if ((NrmBits = ubsec_NormalizeDataTo(&pParams->ModN,NormalizeLen))) {
+      Dbg_Print(DBG_FATAL,("ubsec: MATH NrmBits %d\n",NrmBits));
+      ubsec_ShiftData(&pParams->ParamA, NrmBits);
+    }
+
+    pMCR->KeyContextList[PacketIndex]->NormBits=NrmBits;
+#else
+    NrmBits=0;
+#endif
+    pMCR->KeyContextList[PacketIndex]->ResultKey[0]=&pParams->Result; /* Save here for post-command finishing */
+    if (pCommand->Command == UBSEC_MATH_DBLMODEXP) {
+      pMCR->KeyContextList[PacketIndex]->ResultKey[1]=&pParams->Result2; /* Save here for post-command finishing */
+    }
+    else {
+      pMCR->KeyContextList[PacketIndex]->ResultKey[1]=NULL; /* Not used */
+    }
+    pMCR->KeyContextList[PacketIndex]->ResultRNG=NULL; /* Not used */
+
+    /*
+     * Output value may need to be rounded up to represent an integral
+     * number of 32 bit words, same total length as modulus N.
+     */
+
+    /* N Copy the modulo value modulo */
+    pMathContext->modulus_length = (unsigned short)CPU_TO_CTRL_SHORT(pParams->ModN.KeyLength);
+    offset=NormalizeLen/8;
+
+#ifndef UBSEC_HW_NORMALIZE
+ #if defined(UBS_ENABLE_KEY_SWAP)
+    copywords((UBS_UINT32 *)&pMathContext->NE[0],
+	      (UBS_UINT32 *)OS_GetVirtualAddress(pParams->ModN.KeyValue),
+	      offset/4);
+ #else
+    RTL_Memcpy(&pMathContext->NE[0],OS_GetVirtualAddress(pParams->ModN.KeyValue),offset);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#else
+ #if defined(UBS_ENABLE_KEY_SWAP)
+    copywords((UBS_UINT32 *)&pMathContext->NE[0],
+	      (UBS_UINT32 *)OS_GetVirtualAddress(pParams->ModN.KeyValue),
+	      ROUNDUP_TO_32_BIT(pParams->ModN.KeyLength)/32);
+ #else
+    RTL_Memcpy(&pMathContext->NE[0],OS_GetVirtualAddress(pParams->ModN.KeyValue),
+	       ROUNDUP_TO_32_BIT(pParams->ModN.KeyLength)/8);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#endif
+
+    /* Update the total context length to reflect the modulus. */
+    pContext->cmd_structure_length+=(offset);
+
+    if (pCommand->Command==UBSEC_MATH_DBLMODEXP) {
+
+      /* Second modulus needs to be copied to the context for dblmodexp */
+#ifndef UBSEC_HW_NORMALIZE
+ #if defined(UBS_ENABLE_KEY_SWAP)
+      copywords((UBS_UINT32 *)&pMathContext->NE[NormalizeLen/32],
+		(UBS_UINT32 *)OS_GetVirtualAddress(pParams->ModN2.KeyValue),
+		offset/4);
+ #else
+      RTL_Memcpy(&pMathContext->NE[NormalizeLen/32],OS_GetVirtualAddress(pParams->ModN2.KeyValue),offset);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#else
+ #if defined(UBS_ENABLE_KEY_SWAP)
+      copywords((UBS_UINT32 *)&pMathContext->NE[NormalizeLen/32],
+		(UBS_UINT32 *)OS_GetVirtualAddress(pParams->ModN2.KeyValue),
+		ROUNDUP_TO_32_BIT(pParams->ModN2.KeyLength)/32);
+ #else
+      RTL_Memcpy(&pMathContext->NE[NormalizeLen/32],OS_GetVirtualAddress(pParams->ModN2.KeyValue),
+		 ROUNDUP_TO_32_BIT(pParams->ModN2.KeyLength)/8);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#endif
+
+      /* Update the total context length to reflect the second modulus. */
+      pContext->cmd_structure_length+=(offset);
+
+      /* Second modulus' length needs to be present in context for dblmodexp  */
+      /* Place the two lengths in their proper context fields (see datasheet) */
+
+      pMathContext->exponent_length = pMathContext->modulus_length;
+      pMathContext->modulus_length = 
+	(unsigned short)CPU_TO_CTRL_SHORT(pParams->ModN2.KeyLength); 
+
+    } /* end second modulus copy for dblmodexp */
+
+
+    if (pCommand->Command==UBSEC_MATH_MODREM) {
+      /* Message length needs to be present in context for modrem */
+      pMathContext->exponent_length=
+	(unsigned short)CPU_TO_CTRL_SHORT(pParams->ParamA.KeyLength);
+    }
+    else if (pCommand->Command==UBSEC_MATH_MODEXP) {
+      /* Exponent length needs to be present in context for modexp */
+      pMathContext->exponent_length= 
+	(unsigned short)CPU_TO_CTRL_SHORT(pParams->ParamB.KeyLength); 
+    }
+    /* Otherwise leave pMathContext->exponent_length field 0 (reserved) */
+    
+
+#ifdef UBSDBG
+  /* Print out the context information if required */
+  {
+    int WordLen,i;
+    WordLen=(pContext->cmd_structure_length-MATH_STATIC_CONTEXT_SIZE)/4;
+    Dbg_Print(DBG_MATH,(   "ubsec:  ---- DH Math Modulus Length = %d, Exponent Length = %d\n",
+			   CTRL_TO_CPU_SHORT(pMathContext->modulus_length),
+			   CTRL_TO_CPU_SHORT(pMathContext->exponent_length))); 
+    Dbg_Print(DBG_MATH,(   "Context Len %d Context Value=[",
+			    (pContext->cmd_structure_length))); 
+    for ( i=0 ; i < WordLen ; i++) {
+      Dbg_Print(DBG_MATH,( "%08x ",SYS_TO_BE_LONG(pMathContext->NE[i])));
+    }
+    Dbg_Print(DBG_MATH,( "]\n"));
+    }
+#endif
+
+
+    /**************************************************/
+    /* ParamA setup (all ops). Input buffer fragment. */
+    /**************************************************/
+
+
+    /* Now do the Input parameter A (1st input buffer). All math ops have one. */
+    FragPtr=(DataBufChainList_pt)&pPacket->InputHead;
+    PhysAddr=(ubsec_MemAddress_t)(OS_GetPhysicalAddress(pParams->ParamA.KeyValue)); 
+    FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+#if defined(UBS_ENABLE_KEY_SWAP)
+    longkey = (UBS_UINT32 *)OS_GetVirtualAddress(pParams->ParamA.KeyValue);
+    for (element = 0 ; element < ROUNDUP_TO_32_BIT(pParams->ParamA.KeyLength)/32 ; element++) 
+      longkey[element] = BYTESWAPLONG(longkey[element]);
+#endif /* UBS_ENABLE_KEY_SWAP */
+    DataLength=NormalizeLen/8;
+    FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+    Dbg_Print(DBG_FRAG_SYNC,( "ubsec: ubsec_MathCommand Sync ParamA Fragment to Device (0x%08X,%d,%d)\n", 
+			      pParams->ParamA.KeyValue,
+			      0,
+			      DataLength));
+    OS_SyncToDevice(pParams->ParamA.KeyValue,
+		    0,
+		    DataLength);
+    Dbg_Print(DBG_MATH,( "Input Param 1: <%d,%08x (%08x)>\n",
+			 DataLength, 
+			 CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr));
+    /* End ParamA input fragment setup */    
+
+
+    /****************************************************************/
+    /* ParamB setup (all ops except MODREM). Input buffer fragment. */
+    /****************************************************************/
+
+
+    if (pCommand->Command != UBSEC_MATH_MODREM) {
+#ifndef UBSEC_HW_NORMALIZE
+      ubsec_ShiftData(&pParams->ParamB, NrmBits);
+#endif
+      /* get the next fragment pointer */
+      NextFragPtr=&pMCR->InputFragmentList[PacketIndex*(UBSEC_MAX_FRAGMENTS)];
+      FragPtr->pNext =NextFragPtr->PhysicalAddress;
+      FragPtr=NextFragPtr;
+      /* The second input data buffer has 2nd math parameter (B or E) */
+      PhysAddr=(ubsec_MemAddress_t)(OS_GetPhysicalAddress(pParams->ParamB.KeyValue)); 
+      FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+#if defined(UBS_ENABLE_KEY_SWAP)
+      longkey = (UBS_UINT32 *)OS_GetVirtualAddress(pParams->ParamB.KeyValue);
+      for (element = 0 ; element < ROUNDUP_TO_32_BIT(pParams->ParamB.KeyLength)/32 ; element++) 
+	longkey[element] = BYTESWAPLONG(longkey[element]);
+#endif /* UBS_ENABLE_KEY_SWAP */
+#if 0
+      DataLength=ROUNDUP_TO_32_BIT(pParams->ParamB.KeyLength+NrmBits);
+#else
+      if (pCommand->Command==UBSEC_MATH_MODEXP) {
+	/* Exponent parameter fragment sizes need to be byte multiples only */
+	DataLength = (pParams->ParamB.KeyLength + 7)/8;
+      }
+      else {
+	/* Non-exponent parameter fragment sizes need to be equal to the "key size" (in bytes) */
+	DataLength = NormalizeLen/8;
+      }
+#endif
+      FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+      Dbg_Print(DBG_FRAG_SYNC,( "ubsec: ubsec_MathCommand Sync ParamB Fragment to Device (0x%08X,%d,%d)\n", 
+				pParams->ParamB.KeyValue,
+				0,
+				DataLength));
+      OS_SyncToDevice(pParams->ParamB.KeyValue,
+		      0,
+		      DataLength);
+      Dbg_Print(DBG_MATH,( "Input Param 2: <%d,%08x (%08x)>\n",
+			 DataLength, 
+			 CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr));
+
+      if (pCommand->Command != UBSEC_MATH_DBLMODEXP) {
+	/* No more input fragments */
+	FragPtr->pNext=0; /* Terminate the input fragment descriptor list */
+#ifndef STATIC_F_LIST
+	/* Sync single fragment descriptor (external to MCR) */
+	FragPtr->pNext=0; /* Terminate the input fragment descriptor list before syncing. */
+	Dbg_Print(DBG_FRAG_SYNC,( "ubsec: ubsec_MathCommand Sync IFrag Descriptor to Device (0x%08X,%d,%d)\n", 
+				  pMCR->InputFragmentListHandle,
+				  PacketIndex*(UBSEC_MAX_FRAGMENTS)*sizeof(DataBufChainList_t),
+				  sizeof(DataBufChainList_t)));
+	OS_SyncToDevice(pMCR->InputFragmentListHandle,
+			PacketIndex*(UBSEC_MAX_FRAGMENTS)*sizeof(DataBufChainList_t),
+			sizeof(DataBufChainList_t));
+#endif
+      }
+
+    } 
+    /* End ParamB input fragment setup */
+
+    if (pCommand->Command == UBSEC_MATH_DBLMODEXP) {
+
+
+      /*********************************************************/
+      /* ParamC setup (DBLMODEXP only). Input buffer fragment. */
+      /*********************************************************/
+
+
+      /* get the next fragment pointer */
+      NextFragPtr=&FragPtr[1];
+      FragPtr->pNext =NextFragPtr->PhysicalAddress;
+      FragPtr=NextFragPtr;
+      /* The third input data buffer has 2nd DBLMODEXP base (A1) */
+      PhysAddr=(ubsec_MemAddress_t)(OS_GetPhysicalAddress(pParams->ParamC.KeyValue)); 
+      FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+#if defined(UBS_ENABLE_KEY_SWAP)
+      longkey = (UBS_UINT32 *)OS_GetVirtualAddress(pParams->ParamC.KeyValue);
+      for (element = 0 ; element < ROUNDUP_TO_32_BIT(pParams->ParamC.KeyLength)/32 ; element++) 
+	longkey[element] = BYTESWAPLONG(longkey[element]);
+#endif /* UBS_ENABLE_KEY_SWAP */
+      DataLength = NormalizeLen/8;
+      FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+      Dbg_Print(DBG_FRAG_SYNC,( "ubsec: ubsec_MathCommand Sync ParamC Fragment to Device (0x%08X,%d,%d)\n", 
+				pParams->ParamC.KeyValue,
+				0,
+				DataLength));
+      OS_SyncToDevice(pParams->ParamC.KeyValue,
+		      0,
+		      DataLength);
+      Dbg_Print(DBG_MATH,( "Input Param 3: <%d,%08x (%08x)>\n",
+			 DataLength, 
+			 CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr));
+
+      /* End ParamC input fragment setup */
+
+
+      /*********************************************************/
+      /* ParamD setup (DBLMODEXP only). Input buffer fragment. */
+      /*********************************************************/
+
+
+#ifndef UBSEC_HW_NORMALIZE
+      ubsec_ShiftData(&pParams->ParamD, NrmBits);
+#endif
+      /* get the next fragment pointer */
+      NextFragPtr=&FragPtr[1];
+      FragPtr->pNext =NextFragPtr->PhysicalAddress;
+      FragPtr=NextFragPtr;
+      /* The fourth input data buffer has 2nd DBLMODEXP exponent (E1) */
+      PhysAddr=(ubsec_MemAddress_t)(OS_GetPhysicalAddress(pParams->ParamD.KeyValue)); 
+      FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+#if defined(UBS_ENABLE_KEY_SWAP)
+      longkey = (UBS_UINT32 *)OS_GetVirtualAddress(pParams->ParamD.KeyValue);
+      for (element = 0 ; element < ROUNDUP_TO_32_BIT(pParams->ParamD.KeyLength)/32 ; element++) 
+	longkey[element] = BYTESWAPLONG(longkey[element]);
+#endif /* UBS_ENABLE_KEY_SWAP */
+      DataLength = NormalizeLen/8;
+      FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+      Dbg_Print(DBG_FRAG_SYNC,( "ubsec: ubsec_MathCommand Sync ParamD Fragment to Device (0x%08X,%d,%d)\n", 
+				pParams->ParamD.KeyValue,
+				0,
+				DataLength));
+      OS_SyncToDevice(pParams->ParamD.KeyValue,
+		      0,
+		      DataLength);
+      Dbg_Print(DBG_MATH,( "Input Param 4: <%d,%08x (%08x)>\n",
+			 DataLength, 
+			 CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr));
+
+      /* End ParamD input fragment setup */
+
+      FragPtr->pNext=0; /* Terminate the input fragment descriptor list. */
+
+#ifndef STATIC_F_LIST
+      /* sync the three fragment descriptors for ParamB, ParamC and ParamD */
+      Dbg_Print(DBG_FRAG_SYNC,( "ubsec: ubsec_MathCommand Sync IFrag Descriptors to Device (0x%08X,%d,%d)\n", 
+				pMCR->InputFragmentListHandle,
+				PacketIndex*(UBSEC_MAX_FRAGMENTS)*sizeof(DataBufChainList_t),
+				3*sizeof(DataBufChainList_t)));
+      OS_SyncToDevice(pMCR->InputFragmentListHandle,
+		      PacketIndex*(UBSEC_MAX_FRAGMENTS)*sizeof(DataBufChainList_t),
+		      3*sizeof(DataBufChainList_t));
+#endif
+    } /* end ParamC and ParamD setup (DBLMODEXP only) */
+
+    /* (At this point, the input fragment descriptor list has been terminated already) */
+
+
+
+    /* Now do the Output data buffer. All operations have at least one */
+
+    FragPtr=(DataBufChainList_pt)&pPacket->OutputHead;
+    PhysAddr=(ubsec_MemAddress_t)(OS_GetPhysicalAddress(pParams->Result.KeyValue)); 
+    FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+
+    DataLength=NormalizeLen/8;
+
+    FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+
+#ifdef UBSDBG
+      /* Sanity check debug info for conditions that will hang the chip. */
+    if ( (CTRL_TO_CPU_LONG( FragPtr->DataAddress )) & 0x03) {
+      Dbg_Print(DBG_FATAL,("ubsec:MATH #########INVALID OUTPUT ADDRESS %08x\n", CTRL_TO_CPU_LONG(FragPtr->DataAddress)));
+      Status=UBSEC_STATUS_INVALID_PARAMETER;
+      goto Error_Return;
+    }
+    if ((DataLength) & 0x03) {
+      Dbg_Print(DBG_FATAL,("ubsec:MATH #########INVALID OUTPUT LENGTH %08x\n", DataLength)); 
+      Status=UBSEC_STATUS_INVALID_PARAMETER;
+      goto Error_Return;
+    }
+#endif 
+
+    if (pCommand->Command == UBSEC_MATH_DBLMODEXP) {
+      NextFragPtr=&pMCR->OutputFragmentList[PacketIndex*(UBSEC_MAX_FRAGMENTS)];
+      FragPtr->pNext =NextFragPtr->PhysicalAddress;
+      FragPtr =NextFragPtr;
+      PhysAddr=(ubsec_MemAddress_t)(OS_GetPhysicalAddress(pParams->Result2.KeyValue)); 
+      FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+      DataLength=NormalizeLen/8;
+      FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+
+#ifndef STATIC_F_LIST
+      FragPtr->pNext=0; /* Terminate the output fragment descriptor list before syncing */
+      Dbg_Print(DBG_FRAG_SYNC,( "ubsec: ubsec_MathCommand Sync 2nd OFrag Descriptor to Device (0x%08X,%d,%d)\n", 
+				pMCR->OutputFragmentListHandle,
+				PacketIndex*(UBSEC_MAX_FRAGMENTS)*sizeof(DataBufChainList_t),
+				sizeof(DataBufChainList_t)));
+      OS_SyncToDevice(pMCR->OutputFragmentListHandle,
+		      PacketIndex*(UBSEC_MAX_FRAGMENTS)*sizeof(DataBufChainList_t),
+		      sizeof(DataBufChainList_t));
+#endif
+
+#ifdef UBSDBG
+      /* Sanity check debug info for conditions that will hang the chip. */
+      if ( (CTRL_TO_CPU_LONG( FragPtr->DataAddress )) & 0x03) {
+	Dbg_Print(DBG_FATAL,("ubsec:MATH DBLMODEXP#########INVALID OUTPUT ADDRESS %08x\n", CTRL_TO_CPU_LONG(FragPtr->DataAddress)));
+	Status=UBSEC_STATUS_INVALID_PARAMETER;
+	goto Error_Return;
+      }
+      if ((DataLength) & 0x03) {
+	Dbg_Print(DBG_FATAL,("ubsec:MATH DBLMODEXP#########INVALID OUTPUT LENGTH %08x\n", DataLength)); 
+	Status=UBSEC_STATUS_INVALID_PARAMETER;
+	goto Error_Return;
+      }
+#endif 
+    } /* end second output buffer setup (DBLMODEXP only) */
+
+    FragPtr->pNext=0; /* Terminate the output fragment descriptor list (if not already done). */
+
+    Dbg_Print(DBG_MATH,( "Result : <%d,%08x (%08x)>\n",
+			 DataLength, 
+			 CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr));
+
+
+    /* Save the user callback information. We use an intermediate callback for LongKey numbers */
+
+    /* Always save the user callback parameters (to be called by the intermediate callback) */
+    pContext->UserCallback = pCommand->CompletionCallback;
+    pContext->UserContext = pCommand->CommandContext;
+    /* The intermediate callback needs to get this command context passed to it */
+    pCompletionContext->CompletionCallback = KeyFinishResult;
+    pCompletionContext->CommandContext = (unsigned long)pContext;
+
+#if (UBS_CPU_ATTRIBUTE != UBS_CRYPTONET_ATTRIBUTE)
+    pContext->cmd_structure_length= CPU_TO_CTRL_SHORT(pContext->cmd_structure_length);
+#endif
+
+    /* For key (math) MCRs, contexts are accessed by an array of handles. */
+    /* This means that memory for each context was separately allocated.  */
+    /* Therefore we must sync each context separately as it is built.     */
+    Dbg_Print(DBG_CNTXT_SYNC,( "ubsec: ubsec_MathCommand Sync Context to Device (0x%08X,%d,%d)\n", pMCR->ContextListHandle[PacketIndex],
+		       0,
+		       CTRL_TO_CPU_SHORT(pContext->cmd_structure_length)));
+    OS_SyncToDevice(pMCR->ContextListHandle[PacketIndex],
+		    0,
+		    CTRL_TO_CPU_SHORT(pContext->cmd_structure_length));
+
+    /* Now inc the number of packets and prepare for the next command. */
+    pMCR->NumberOfPackets++;
+    pCommand++;
+    PacketIndex++;
+    pPacket++;
+    pContext++;
+
+  } /* For NumCommands-- */
+
+  /*
+   * If we are here then the MCR is built.
+   * Push it to the device. 
+   */
+  *NumCommands=CommandIndex; /* Update number completed */
+  PushMCR(pDevice);
+
+#ifdef BLOCK 
+  /* Wait for all outstanding  to complete */
+    while ((Status=WaitForCompletion(pDevice,(unsigned long)1000000,UBSEC_KEY_LIST))
+	   == UBSEC_STATUS_SUCCESS);
+    if (Status!=UBSEC_STATUS_TIMEOUT) /* We are nested, return success */
+      Status=UBSEC_STATUS_SUCCESS;
+ Error_Return:
+#else
+
+ Error_Return:  /* Label to make sure that IRQs are enabled. */
+#ifdef COMPLETE_ON_COMMAND_THREAD
+    ubsec_PollDevice(pDevice);  /* Try to complete some & cut down on ints */
+#endif
+
+#endif
+    OS_LeaveCriticalSection(pDevice,SaveConfig);
+    return(Status);
+}
diff -urNp linux-8030/drivers/addon/bcm/ubsmd5.c linux-8040/drivers/addon/bcm/ubsmd5.c
--- linux-8030/drivers/addon/bcm/ubsmd5.c
+++ linux-8040/drivers/addon/bcm/ubsmd5.c
@@ -0,0 +1,241 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/* 
+ * ubsmd5.c: MD5 key manipulation functions.
+ */
+
+/*
+ * Revision History:
+ *
+ * 09/xx/1999 SOR Created from little endian c-model
+ * 04/03/2001 RJT Added support for CryptoNet device big-endian mode
+ */
+
+#include "ubsincl.h"
+
+static void MD5Update(struct MD5Context *ctx, unsigned char *HashBlock, int len);
+
+/*
+ * We use a SHA-style formulation of MD5 algorithm -- this is simpler and much
+ * faster in HW, although it is slower in SW. The SHA-style algorithm avoids
+ * a set of muxes in front of each arithmetic unit, and also
+ * simplifies the HW control logic a lot.
+ *
+ * This code is exactly equivalent to the more verbose 64-round formulation
+ * with FF's, GG's, HH's and II's shown in Schneier's "Applied Cryptography."
+ * This code will only work on a little endian machine. Constants and boolean functions
+ * are out of Schneier's "Applied Cryptography". Also, MD5Update() must only be called
+ * once, followed by a call to MD5Final() -- the length field is not being properly
+ * carried over within MD5Update().
+ * This implementation does not handle large block sizes per the MD5 RFC1321.
+ * It is meant for packets of less than 2**28 bytes each.
+ *
+*/
+
+
+/* Boolean functions for internal rounds */
+#define F(x,y,z) ( ((x) & (y)) | ((~(x)) & (z)) )
+#define G(x,y,z) ( ((x) & (z)) | ((y) & (~(z))) )
+#define H(x,y,z) ( (x) ^ (y) ^ (z) )
+#define I(x,y,z) ( (y) ^ ((x) | (~(z))) )
+
+static UBS_UINT32 MD5_T[] = { /* The 64 magic constants */
+	0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 
+	0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
+	0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 
+	0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
+	0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 
+	0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
+	0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 
+	0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
+	0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 
+	0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
+	0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 
+	0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
+	0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 
+	0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
+	0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 
+	0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391
+};
+
+static int MD5_S[] = { /* Shift amounts for each round */
+	/* Rounds  0-15 */ 7,12,17,22,7,12,17,22,7,12,17,22,7,12,17,22,
+	/* Rounds 16-31 */ 5,9,14,20,5,9,14,20,5,9,14,20,5,9,14,20,
+	/* Rounds 32-47 */ 4,11,16,23,4,11,16,23,4,11,16,23,4,11,16,23,
+	/* Rounds 48-63 */ 6,10,15,21,6,10,15,21,6,10,15,21,6,10,15,21
+};
+
+static int MD5_P[] = { /* Permutation index to access message blocks */
+	/* Rounds  0-15 */ 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
+	/* Rounds 16-31 */ 1,6,11,0,5,10,15,4,9,14,3,8,13,2,7,12,
+	/* Rounds 32-47 */ 5,8,11,14,1,4,7,10,13,0,3,6,9,12,15,2,
+	/* Rounds 48-63 */ 0,7,14,5,12,3,10,1,8,15,6,13,4,11,2,9
+};
+
+static unsigned char ipad[64] = {0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+        0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+        0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+        0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+        0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+        0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+        0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+        0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36};
+                                         
+static unsigned char opad[64] = {0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
+        0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
+        0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
+        0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
+        0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
+        0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
+        0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
+        0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c};
+
+
+static  void bytnxor( unsigned char *dest, unsigned char *src1, unsigned char *src2, unsigned char len)
+{
+  while (len-- > 0) *dest++ = *src1++ ^ *src2++; 
+}
+
+void
+InitMD5State(ubsec_HMAC_State_pt HMAC_State,unsigned char *HashKey)
+{
+  struct MD5Context ctx;
+  unsigned char pad[64];
+
+  /* First prepare the inner block. */
+  bytnxor((unsigned char *)pad,(unsigned char *)HashKey,ipad, 64);
+  RTL_MemZero(&ctx,sizeof(struct MD5Context));
+
+  /* The initial values in memory are 01 23 45 ... per RFC1321 */
+  ctx.buf[0] = 0x67452301;
+  ctx.buf[1] = 0xefcdab89;
+  ctx.buf[2] = 0x98badcfe;
+  ctx.buf[3] = 0x10325476;
+
+  MD5Update(&ctx,pad,64);
+
+	/* ctx comes out as an array of long ints. The byte order of ctx
+is dependent on the CPU endianess. The byte order of the memory destination 
+is dependent on the CryptoNet memory endianess. Based on our MD5 algorithm's
+CPU endianess assumptions, the net result is that we do a straight copy if
+the CPU and CryptoNet memory are of the same endianess. If the CPU and 
+CryptoNet memory are of opposite endianess, we'll do 32-bit byteswapping
+during the copy, taken care of by the copywords() routine. */
+
+#if (UBS_CPU_ATTRIBUTE != UBS_CRYPTONET_ATTRIBUTE)
+  copywords((UBS_UINT32 *)&HMAC_State->InnerState[0],&ctx.buf[0], MD5_HASH_LENGTH/4); 
+#else
+  RTL_Memcpy(&HMAC_State->InnerState[0],&ctx.buf[0], MD5_HASH_LENGTH); 
+#endif /* UBS_CPU_ATTRIBUTE */
+
+  /* Now prepare the Outer block. */
+  bytnxor((unsigned char *)pad,(unsigned char *)HashKey,opad, 64);
+  RTL_MemZero(&ctx,sizeof(struct MD5Context));
+
+
+  /* The initial values in memory are 01 23 45 ... per RFC1321 */
+  ctx.buf[0] = 0x67452301;
+  ctx.buf[1] = 0xefcdab89;
+  ctx.buf[2] = 0x98badcfe;
+  ctx.buf[3] = 0x10325476;
+
+  MD5Update(&ctx,pad,64);
+
+	/* ctx comes out as an array of long ints. The byte order of ctx
+is dependent on the CPU endianess. The byte order of the memory destination 
+is dependent on the CryptoNet memory endianess. Based on our MD5 algorithm's
+CPU endianess assumptions, the net result is that we do a straight copy if
+the CPU and CryptoNet memory are of the same endianess. If the CPU and 
+CryptoNet memory are of opposite endianess, we'll do 32-bit byteswapping
+during the copy, taken care of by the copywords() routine. */
+
+#if (UBS_CPU_ATTRIBUTE != UBS_CRYPTONET_ATTRIBUTE)
+  copywords((UBS_UINT32 *)&HMAC_State->OuterState[0],&ctx.buf[0], MD5_HASH_LENGTH/4); 
+#else
+  RTL_Memcpy(&HMAC_State->OuterState[0],&ctx.buf[0], MD5_HASH_LENGTH); 
+#endif /* UBS_CPU_ATTRIBUTE */
+
+}
+
+
+static void MD5Update(struct MD5Context *ctx, unsigned char *HashBlock, int len)
+{
+  /* ctx was built (CPU endian-independent) as unsigned longs       */
+  /* HashBlock was built (CPU endian-independent) as unsigned chars */
+	UBS_UINT32 a, b, c, d;
+	int block, i;
+	/* Process as many blocks as possible */
+	for (block = 0; len >= 64; len -= 64, ++block) {
+	  UBS_UINT32 m[16], A, B, C, D;
+
+	  RTL_Memcpy(m, HashBlock + 64*block, 64); /* Get one block of data */
+
+	  /* At this point m[] is built as a char array. However, m[] will
+	     be operated on from here on out as an array of unsigned longs.
+	     This algorithm's definition assumes a little endian CPU, so 
+	     we'll endian-adjust the byte array if we have a big endian CPU */
+#if (UBS_CPU_ATTRIBUTE == UBS_BIG_ENDIAN)
+	  for( i = 0; i < 16; ++i )
+		  m[i] = BYTESWAPLONG( m[i] ); /* View data as big endian */
+#endif
+
+		a = ctx->buf[0];
+		b = ctx->buf[1];
+		c = ctx->buf[2];
+		d = ctx->buf[3];
+		/* Now for the hyper-compact SHA-style formulation of MD5 */
+		A = b; B = c; C = d; D = a;
+		Dbg_Print(DBG_MD5,("pre round 0: 0x%x 0x%x 0x%x 0x%x\n", A, B, C, D));
+		for (i = 0; i < 64; ++i) {
+			UBS_UINT32 temp, fn = 0, rolt, prerolt;
+
+			switch (i / 16) {
+			case 0: fn = F(A,B,C); break;
+			case 1: fn = G(A,B,C); break;
+			case 2: fn = H(A,B,C); break;
+			case 3: fn = I(A,B,C); break;
+			default: ;
+			}
+			prerolt = D + fn + m[MD5_P[i]] + MD5_T[i];
+			rolt = rol(D + fn + m[MD5_P[i]] + MD5_T[i], MD5_S[i]);
+			temp = A + rol(D + fn + m[MD5_P[i]] + MD5_T[i], MD5_S[i]);
+			D = C;
+			C = B;
+			B = A;
+			A = temp;
+			Dbg_Print(DBG_MD5,("post round %d: 0x%x 0x%x 0x%x 0x%x\n", i, A, B, C, D));
+			Dbg_Print(DBG_MD5,("fn=0x%x, before rol=0x%x, rol()=0x%x\n", fn, prerolt, rolt));
+			Dbg_Print(DBG_MD5,("\tcte=0x%x, data=0x%x, shift amt=%d\n\n", MD5_T[i], m[MD5_P[i]], MD5_S[i]));
+		}
+		b = A; c = B; d = C; a = D;
+
+		ctx->buf[0] += a;
+		ctx->buf[1] += b;
+		ctx->buf[2] += c;
+		ctx->buf[3] += d;
+	}
+}
+
+
diff -urNp linux-8030/drivers/addon/bcm/ubsmd5.h linux-8040/drivers/addon/bcm/ubsmd5.h
--- linux-8030/drivers/addon/bcm/ubsmd5.h
+++ linux-8040/drivers/addon/bcm/ubsmd5.h
@@ -0,0 +1,57 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubsmd5.h:
+ */
+
+/*
+ * Revision History:
+ *
+ */
+
+#ifndef _MD5_H_
+#define _MD5_H_
+
+#define MD5_BLOCK_LENGTH  64		/* in bytes */
+#define MD5_HASH_LENGTH   16 		/* in bytes */
+
+
+#if 0
+typedef unsigned int u32;
+typedef unsigned char u8;
+typedef unsigned short u16;
+#endif
+
+
+typedef int uint32;
+struct MD5Context {
+	uint32 buf[4];
+	uint32 bits[2];
+	unsigned char in[64];
+};
+
+
+#endif /* _MD5_H_ */
+
diff -urNp linux-8030/drivers/addon/bcm/ubsnorm.c linux-8040/drivers/addon/bcm/ubsnorm.c
--- linux-8030/drivers/addon/bcm/ubsnorm.c
+++ linux-8040/drivers/addon/bcm/ubsnorm.c
@@ -0,0 +1,229 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubsec_norm.c: Normalize (left shift) and UnNormalize (right shift) data 
+ *
+ *
+ * Revision History:
+ *
+ * May 2000 SOR Created
+ * 04/24/01 DPA Allow for unnormalize of D-H random number (x) output for BCM5805
+ * 10/09/01 SRM 64 bit port
+ */
+
+#include "ubsincl.h"
+
+#ifdef UBSEC_PKEY_SUPPORT
+#ifndef UBSEC_HW_NORMALIZE
+#define WORD_LENGTH 32
+
+
+/* 
+ * This code assumes that each 32-bit element in the "key" data array is stored
+ * in memory in little endian format. This assumption allows one to treat the
+ * "key" array as a byte array, with each byte being more significant than the
+ * bytes preceeding it and less significant than the bytes that follow it.
+ * This "byte array" treatment cannot be applied to arrays of big endian integers.
+ */ 
+
+/* The MSB Bit is the most significant bit of a multibyte
+   word, in little endian formant. */
+#define MSB_BIT_MASK 0x80000000 /* most significant bit */
+#define MOVEBITSMASK 0xffffffff /* 32 bits */
+
+/*****************************************************************************
+ * ubsec_NormalizeDataTo:
+ *
+ * Normalize data to the DWORD boundary passed as a parameter.
+ * Input: pData,Normalize to len
+ *
+ * Output: Number of bits to shift
+ *
+ *****************************************************************************/ 
+
+long ubsec_NormalizeDataTo(ubsec_LongKey_pt pData,int NormalizeLen)
+{
+  unsigned long ArrayLength;
+  unsigned long shift_in_bits;
+  UBS_UINT32 *tmpPtr;
+  int	  i;
+  
+  Dbg_Print(DBG_NORM,("\nubsec: pData->KeyLength:%d", pData->KeyLength));
+  /* 
+   * Set data so there is a bit in the LSb. 
+   */
+  /* Total length in bits rounded up. */
+  ArrayLength = (pData->KeyLength+WORD_LENGTH-1)/WORD_LENGTH;
+
+ /* 
+  * Now determine how many bits to shift to align on a DWORD value.
+  */
+  shift_in_bits = 0;
+  tmpPtr = (UBS_UINT32 *)OS_GetVirtualAddress(pData->KeyValue);  
+  for (i=(ArrayLength-1) ; (i>0) ; i--, shift_in_bits+=WORD_LENGTH) {
+    if (tmpPtr[i]) { /* Bits in this long */ 
+      unsigned long y=CPU_TO_CTRL_LONG(tmpPtr[i]); 
+      while (!(y & MSB_BIT_MASK)) { /* Find the bit depth */
+	shift_in_bits++;
+	y=y<<1;
+      }
+      break;	
+    } 
+  }
+
+  Dbg_Print(DBG_NORM,("\nubsec: Normalize %08x shift_in_bits-A %d\n",
+		      tmpPtr[ArrayLength-1],shift_in_bits));
+
+  NormalizeLen/=32; /* Assume aligned on DWORD Boundary. */
+  shift_in_bits+=((NormalizeLen-ArrayLength)*WORD_LENGTH);
+
+  Dbg_Print(DBG_NORM,("\nubsec: Normalize shift_in_bits-B %d\n", shift_in_bits));
+  ubsec_ShiftData(pData,shift_in_bits);
+  return(shift_in_bits);
+}
+
+/*****************************************************************************
+ * ubsec_ShiftData():
+ * Shift data by the bits indicated as a parameter.
+ *
+ * Input: pData, ShiftBits
+ * Output: pData
+ *
+ * On input, pData contains a pointer (*KeyValue) to the data to be
+ *   unnormalized. It's length(KeyLength) is one of the values 512,768,or 1024
+ *   ShiftInBits is the number of bits to be shifted for the pData 
+ *
+ * On output, pData contains a pointer (*KeyValue) to the data that has been 
+ *   unnormalized. It's length (KeyLength) is  the number of bits, excluding
+ *   the leading 0's, of the data pointed by KeyValue
+ *****************************************************************************/ 
+
+void ubsec_ShiftData(ubsec_LongKey_pt pData, 
+                   long    ShiftBits )
+{
+  unsigned long ArrayLength;
+  unsigned long MoveBitsMask;
+  unsigned long *tmpPtr,tmpval,tmpval2,tmpval3;
+  int i;
+  int RightShift;
+  int Dest;
+
+  if (!ShiftBits) /* Nothing to do. */
+    return;
+
+  if (ShiftBits > 0) 
+    RightShift=1;
+  else {
+    RightShift=0;
+    ShiftBits=-ShiftBits;  /* Make it positive */
+  }
+
+  Dbg_Print(DBG_NORM,("\nubsec: Normalize shiftbits %d\n", ShiftBits));
+
+  /* Get shift dword length. */
+  ArrayLength = (pData->KeyLength+WORD_LENGTH-1)/WORD_LENGTH;
+  tmpPtr = (unsigned long *)OS_GetVirtualAddress(pData->KeyValue);
+  if (RightShift) {  /* Logical right shift of bits */
+    /* Calculate destination location based, on extra
+       words to shift */
+    i=(ArrayLength-1) ;   /* Point at last location */
+    Dest=(i+(ShiftBits/WORD_LENGTH)); /* Point to new dest location. */
+    ShiftBits%=WORD_LENGTH; /* Number of bits within a Word to shift.*/
+    MoveBitsMask = MOVEBITSMASK << ShiftBits; 
+    Dbg_Print(DBG_NORM,("\nubsec: Mod-shiftbits %d Mask %08x\n", ShiftBits,MoveBitsMask));
+    tmpval=CTRL_TO_CPU_LONG(tmpPtr[i]);
+    if (tmpval & ~(MOVEBITSMASK >> ShiftBits)) {
+      i++;
+      Dest++;
+    }
+    for ( ; i>0; i--,Dest-- ) {
+      tmpval=CTRL_TO_CPU_LONG(tmpPtr[i]);
+      tmpval2=CTRL_TO_CPU_LONG(tmpPtr[i-1]);
+      tmpval3=( ((tmpval<< ShiftBits)&MoveBitsMask)|
+		((tmpval2 >>(WORD_LENGTH-ShiftBits)) &(~MoveBitsMask)));
+      tmpPtr[Dest] = CPU_TO_CTRL_LONG(tmpval3);
+    }
+      /* last word to shift */
+    tmpval=CTRL_TO_CPU_LONG(tmpPtr[0]);
+    tmpval2=((tmpval<<ShiftBits) & MoveBitsMask); 
+    tmpPtr[Dest]=CPU_TO_CTRL_LONG(tmpval2);
+
+    /* Now clear leading 0s */
+    for (i=0; i < Dest; i++)
+      tmpPtr[i]=0;
+  }
+  else {
+    /* Calculate destination location based, on extra
+       words to shift */
+    Dest=0; /* Last location. */
+    i=((ShiftBits)/WORD_LENGTH);   /* Point at first location */
+    ShiftBits%=WORD_LENGTH; /* Number of bits within a Word to shift.*/
+    MoveBitsMask = MOVEBITSMASK >> ShiftBits; 
+    Dbg_Print(DBG_NORM,("\nubsec: Mod-shiftbits %d Mask %08x\n", ShiftBits,MoveBitsMask));
+    for ( ; Dest<(int)(ArrayLength-1); i++,Dest++ ) {
+      tmpval=CTRL_TO_CPU_LONG(tmpPtr[i]);
+      tmpval2=CTRL_TO_CPU_LONG(tmpPtr[i+1]);
+      tmpval3=( ((tmpval >> ShiftBits)&MoveBitsMask)
+	| (tmpval2  << (WORD_LENGTH-ShiftBits) &(~MoveBitsMask)));
+      tmpPtr[Dest] = CPU_TO_CTRL_LONG(tmpval3) ;
+
+    }
+      /* last word to shift */
+    tmpval=CTRL_TO_CPU_LONG(tmpPtr[i]);
+    tmpval2=((tmpval>>ShiftBits) & MoveBitsMask);
+    tmpPtr[Dest]= CPU_TO_CTRL_LONG(tmpval2); 
+
+    /* Now set trailing 0s */
+    for (Dest++; Dest  <= i; Dest++)
+      tmpPtr[Dest]=0;
+  }
+
+}
+
+
+
+#endif /* NORM */
+
+#endif /* Support */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff -urNp linux-8030/drivers/addon/bcm/ubsrng.c linux-8040/drivers/addon/bcm/ubsrng.c
--- linux-8030/drivers/addon/bcm/ubsrng.c
+++ linux-8040/drivers/addon/bcm/ubsrng.c
@@ -0,0 +1,264 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubsrng.c: Random Number Generator Code
+ */
+
+/*
+ * Revision History:
+ *
+ * 03/17/2000 SOR Created
+ * 07/06/2000 DPA Fixes for SMP operation
+ * 04/20/2001 RJT Added support for CPU-DMA memory synchronization
+ */
+
+#include "ubsincl.h"
+
+void RNGFinishResult(unsigned long Context,ubsec_Status_t Result);
+
+/*
+ * ubsec_rngCommand: Process a list of rng commands.
+ *
+ * Immediate Status is returned. Completion status is returned
+ * on a per command callback
+ */
+ubsec_Status_t 
+ubsec_RNGCommand(ubsec_DeviceContext_t Context,
+	      ubsec_RNGCommandInfo_pt pCommand,
+	      int *NumCommands)
+{
+#ifdef UBSEC_RNG_SUPPORT
+  DeviceInfo_pt 		pDevice=(DeviceInfo_pt)Context;
+  VOLATILE MasterCommand_t  	*pMCR;
+  VOLATILE Packet_t         	*pPacket;
+  VOLATILE KeyContext_t  	*pContext;
+  VOLATILE int             	PacketIndex;
+  int 				CommandIndex=0;
+  int 				CommandCount=*NumCommands;
+  ubsec_Status_t 		Status;
+  unsigned long 		SaveConfig;
+  ubsec_RNGCommandParams_pt    pParams;
+  VOLATILE DataBufChainList_t  *FragPtr;
+  int                           DataLength;
+
+  if (!UBSEC_IS_KEY_DEVICE(pDevice)) {
+    Dbg_Print(DBG_FATAL,( "ubsec: RNG Command for a crypto device\n " ));
+    return(UBSEC_STATUS_NO_DEVICE );
+  }
+
+  Dbg_Print(DBG_RNG,( "ubsec:  Rng command %d ",*NumCommands ));
+  /*
+   * Check some parameters
+   */    
+  if(pDevice==NULL_DEVICE_INFO) {
+    Dbg_Print(DBG_FATAL,( "NO DEV\n " ));
+    return(UBSEC_STATUS_NO_DEVICE );
+  }
+
+  Dbg_Print(DBG_RNG,( "\n"));
+
+  if (OS_EnterCriticalSection(pDevice,SaveConfig)) {
+    return(UBSEC_STATUS_DEVICE_BUSY);
+  }
+
+  /* Get the next MCR to load */
+ Get_New_MCR:
+  *NumCommands=CommandIndex; /* Update number completed */
+
+  if ((pMCR=GetFreeMCR(pDevice,UBSEC_KEY_LIST,&Status))== NULL_MASTER_COMMAND) 
+    goto Error_Return;
+
+  /* Add packets to this MCR. */
+
+  Dbg_Print(DBG_RNG,( "ubsec: mcr_index %d MCR <%0x,%0x>\n",pMCR->Index,pMCR,pMCR->MCRPhysicalAddress));
+  /* Initialize the packet information */
+  PacketIndex = pMCR->NumberOfPackets; 
+  pPacket = &(pMCR->PacketArray[PacketIndex]); /* Set up the current packet. */
+  pContext = pMCR->KeyContextList[PacketIndex]; 
+
+#if 0
+  RTL_MemZero(pContext,sizeof(*pContext));
+#endif
+
+  Status=UBSEC_STATUS_SUCCESS; /* Wishful thinking? */
+
+  Dbg_Print(DBG_RNG,( "ubsec: PacketIndex %d \n",pMCR->NumberOfPackets));
+
+  /* Process all the commands in the command list. */
+  for (; CommandIndex < CommandCount ; CommandIndex++) { /* Add all the packets to the MCR*/
+    if( PacketIndex >= MCR_MAXIMUM_PACKETS ) {
+      Dbg_Print(DBG_RNG,( "ubsec:  overran mcr buffer. %d\n",PacketIndex,CommandIndex ));
+      /* 
+       * We have filled this MCR. 
+       * Advance next free. Wrap around if necessary
+       */
+      pDevice->NextFreeMCR[UBSEC_KEY_LIST]=(MasterCommand_pt)pMCR->pNextMCR;
+      Dbg_Print(DBG_RNG,( "ubsec:  PushMCR ..." ));
+      PushMCR(pDevice); /* Get it going (pipeline) */
+      goto Get_New_MCR; /* Try to add to the next MCR */
+    }
+
+    /* First set up the command type and parameters. */
+    Dbg_Print(DBG_RNG,( "ubsec: packet_Index %d, Context Buf <%0x,%0x>\n",PacketIndex,pContext,pContext->PhysicalAddress ));
+    pPacket->PacketContextBuffer=pContext->PhysicalAddress;
+    
+    switch (pCommand->Command) {
+    case UBSEC_RNG_DIRECT:
+      pContext->operation_type	= OPERATION_RNG_DIRECT;
+      break;
+    case UBSEC_RNG_SHA1:
+      pContext->operation_type	= OPERATION_RNG_SHA1;
+      break;
+
+    default:
+      Status=(UBSEC_STATUS_INVALID_PARAMETER);
+      goto Error_Return;
+    }
+
+    pParams=&pCommand->Parameters;
+    pContext->cmd_structure_length= RNG_STATIC_CONTEXT_SIZE;
+
+    /* Now do the Output data buffer. All operations have exactly one */
+    FragPtr=(DataBufChainList_pt)&pPacket->OutputHead;
+    FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)(OS_GetPhysicalAddress(pParams->Result.KeyValue)) ); 
+    DataLength=(pParams->Result.KeyLength+7)/8; /* map the length from bits to bytes */
+    FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+    FragPtr->pNext=0; /* Terminate the input fragment descriptor list. */
+
+#ifdef UBSDBG
+  /* Print out the context and fragment information if required */
+  {
+    Dbg_Print(DBG_RNG,(   "ubsec:  ---- RNG Context: Len %d Operation %x\n",
+	  pContext->cmd_structure_length,pContext->operation_type));
+    Dbg_Print(DBG_RNG,( "OutputFragment: <%d, %08x, (%08x,Next-%08x)>\n",
+      DataLength, CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr,FragPtr->pNext));
+  }
+#endif
+
+
+#ifdef UBSDBG
+      /* Sanity check debug info for conditions that will hang the chip. */
+    if ( (CTRL_TO_CPU_LONG( FragPtr->DataAddress )) & 0x03) {
+      Dbg_Print(DBG_FATAL,("ubsec:MATH #########INVALID OUTPUT ADDRESS %08x\n", CTRL_TO_CPU_LONG(FragPtr->DataAddress)));
+      Status=UBSEC_STATUS_INVALID_PARAMETER;
+      goto Error_Return;
+    }
+    if ((DataLength) & 0x03) {
+      Dbg_Print(DBG_FATAL,("ubsec:MATH #########INVALID OUTPUT LENGTH %08x\n", DataLength)); 
+      Status=UBSEC_STATUS_INVALID_PARAMETER;
+      goto Error_Return;
+    }
+#endif 
+
+    /* Save the callback information. */
+
+    pContext->ResultRNG = &pParams->Result; /* Save here for post-command processing */
+    pContext->ResultKey[0]=NULL; /* Not used */
+    pContext->ResultKey[1]=NULL; /* Not used */
+    pContext->UserCallback = pCommand->CompletionCallback;
+    pContext->UserContext = pCommand->CommandContext;
+
+    /* The intermediate callback needs to get this command context passed to it */
+    pMCR->CompletionArray[PacketIndex].CompletionCallback = RNGFinishResult;
+    pMCR->CompletionArray[PacketIndex].CommandContext = (unsigned long)pContext;
+
+
+#if (UBS_CPU_ATTRIBUTE != UBS_CRYPTONET_ATTRIBUTE) 
+    pContext->cmd_structure_length= CPU_TO_CTRL_SHORT(pContext->cmd_structure_length);
+#endif
+
+    /* For key (RNG) MCRs, contexts are accessed by an array of handles.  */
+    /* This means that memory for each context was separately allocated.  */
+    /* Therefore we must sync each context separately as it is built.     */
+    /* Since the CryptoNet RNG function only reads the first 32-bit word  */
+    /* of the context, we only need to sync the first four bytes.         */
+    Dbg_Print(DBG_CNTXT_SYNC,( "ubsec: ubsec_RNGCommand Sync Context to Device (0x%08X,%d,%d)\n", pMCR->ContextListHandle[PacketIndex],0,4));
+    OS_SyncToDevice(pMCR->ContextListHandle[PacketIndex],0,4);
+
+    /* Now inc the number of packets and prepare for the next command. */
+    pMCR->NumberOfPackets++;
+    pCommand++;
+    PacketIndex++;
+    pPacket++;
+  } /* For NumCommands-- */
+
+  /*
+   * If we are here then the MCR is built.
+   * Push it to the device. 
+   */
+  *NumCommands=CommandIndex; /* Update number completed */
+  PushMCR(pDevice);
+
+#ifdef BLOCK 
+  /* Wait for all outstanding  to complete */
+    while ((Status=WaitForCompletion(pDevice,(unsigned long)1000000,UBSEC_KEY_LIST))
+	   == UBSEC_STATUS_SUCCESS);
+    if (Status!=UBSEC_STATUS_TIMEOUT) /* We are nested, return success */
+      Status=UBSEC_STATUS_SUCCESS;
+ Error_Return:
+#else /* Not BLOCKing */
+
+ Error_Return:  /* Label to make sure that IRQs are enabled. */
+#ifdef COMPLETE_ON_COMMAND_THREAD
+    ubsec_PollDevice(pDevice);  /* Try to complete some & cut down on ints */
+#endif 
+
+#endif /* BLOCK */
+    OS_LeaveCriticalSection(pDevice,SaveConfig);
+    return(Status);
+#else /* UBSEC_RNG_SUPPORT not defined */
+    return(UBSEC_STATUS_NO_DEVICE);
+#endif /* UBSEC_RNG_SUPPORT */
+}
+
+
+/*
+ * Intermediate callback routine to finish a Random number "key" (multi-precision integer).
+ * This routine zeros out the un-asked-for random bits (the chip generates them in groups of 8).
+ */
+void RNGFinishResult(unsigned long Context,ubsec_Status_t Result)
+{
+  KeyContext_pt pContext=(KeyContext_pt)Context;
+  UBS_UINT32 rng_mask, *key_array;
+
+  if ((Result==UBSEC_STATUS_SUCCESS) && (pContext->ResultRNG != NULL)) {
+    
+  /* The KeyLength field value passed in refers to the desired number of bits */
+
+    /* Chop off the un-asked-for bits so that the RNG array makes sense to the CPU */
+#if (UBS_CPU_ATTRIBUTE != UBS_CRYPTONET_ATTRIBUTE)
+    rng_mask = 0xFFFFFFFF << (32 - (pContext->ResultRNG->KeyLength & 31));  
+#else
+    rng_mask = 0xFFFFFFFF >> (32 - (pContext->ResultRNG->KeyLength & 31)); 
+#endif 
+    
+    ((UBS_UINT32 *)OS_GetVirtualAddress(pContext->ResultRNG->KeyValue))[(pContext->ResultRNG->KeyLength-1)/32] &= rng_mask;
+
+  } /* Result == UBSEC_STATUS_SUCCESS */
+
+  if (pContext->UserCallback) 
+    (*pContext->UserCallback)( pContext->UserContext,Result);
+}
+
diff -urNp linux-8030/drivers/addon/bcm/ubsrsa.c linux-8040/drivers/addon/bcm/ubsrsa.c
--- linux-8030/drivers/addon/bcm/ubsrsa.c
+++ linux-8040/drivers/addon/bcm/ubsrsa.c
@@ -0,0 +1,499 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubsrsa.c: RSA parameter setup functions.
+ *
+ *
+ * Revision History:
+ *
+ * May 2000 SOR Created
+ * 07/26/2000 SOR Virtual/Physical Memory manipulation modifications
+ * 09/xx/2000 DRE BCM5820 Support
+ * 07/16/2001 RJT Added support for BCM5821
+ * 10/09/2001 SRM 64 bit port
+ */
+
+#include "ubsincl.h"
+
+#ifdef UBSEC_PKEY_SUPPORT
+
+
+/* 
+ * Function: RSA_SetupPublicParams()
+ * Set up KeyContext Buffer, MCR Input Buffer and MCR Output Buffer 
+ * for RSA Public operation with parameters provided by pRSAParams 
+ * The KeyContext Buffer includes exponent_length, modulus_length,
+ * N, and g
+ */
+
+ubsec_Status_t 
+RSA_SetupPublicParams(MasterCommand_pt pMCR, ubsec_RSA_Params_pt pRSAParams)
+
+     /* pRSAParams points to a structure which contains all of the info
+	needed for RSA operations. In addition to regular numerical 
+	parameters, "key" memory buffer locations are passed using memory 
+	"handles". Handles are defined as memory descriptors from which 
+	BOTH the virtual and physical addresses of the designated
+	memory can be derived.
+
+	The virtual and physical pointers associated with the handle 
+	must be extracted by using the following macros:
+
+	  OS_GetVirtualAddress()
+	  OS_GetPhysicalAddress()
+	
+	Results from OS_GetPhysicalAddress() may be written to CryptoNet
+	control structures in (DMA) memory. 
+	Results from OS_GetVirtualAddress() may be used (if necessary) as
+	regular old pointers.
+     */
+
+{
+#ifdef UBSEC_RSA_SUPPORT
+  VOLATILE DataBufChainList_t   *FragPtr;
+  int                            DataLength;
+  VOLATILE Packet_t 		*pPacket;
+  Pub_RSA_CtxCmdBuf_pt		pRSACtx;
+  VOLATILE int                  PacketIndex;
+  ubsec_Status_t Status=UBSEC_STATUS_SUCCESS;
+  int ModNLen,NormBits;
+  int element;
+  UBS_UINT32 *longkey;
+  ubsec_MemAddress_t PhysAddr;
+
+  PacketIndex = pMCR->NumberOfPackets;
+  pRSACtx = (Pub_RSA_CtxCmdBuf_pt)&pMCR->KeyContextList[PacketIndex]->CtxCmdBuf.Pub_RSA_CtxCmdBuf;
+  pPacket = &(pMCR->PacketArray[PacketIndex]); /* Set up the current packet */
+  RTL_MemZero(pRSACtx,sizeof(*pRSACtx));
+
+  pRSACtx->modulus_length  = (unsigned short)CPU_TO_CTRL_SHORT(pRSAParams->ModN.KeyLength) ;
+  pRSAParams->ExpE.KeyLength=ROUNDUP_TO_32_BIT(pRSAParams->ExpE.KeyLength);
+  pRSACtx->exponent_length = (unsigned short) CPU_TO_CTRL_SHORT(pRSAParams->ExpE.KeyLength);
+
+  if (pRSAParams->ModN.KeyLength <=512)
+    ModNLen=512;
+  else
+    if (pRSAParams->ModN.KeyLength <=768)
+      ModNLen=768;
+    else
+    if (pRSAParams->ModN.KeyLength  <= 1024)
+      ModNLen=1024;
+    else
+#ifdef UBSEC_582x_CLASS_DEVICE
+      if (pRSAParams->ModN.KeyLength <=1536)
+	ModNLen=1536;
+      else
+	if (pRSAParams->ModN.KeyLength <= 2048)
+	  ModNLen=2048;
+	else
+#endif
+      return(UBSEC_STATUS_INVALID_PARAMETER);
+
+#ifndef UBSEC_HW_NORMALIZE
+  NormBits = ubsec_NormalizeDataTo(&pRSAParams->ModN,ModNLen);
+  pRSAParams->OutputKeyInfo.KeyLength=ModNLen;
+  if (NormBits) {
+    /*
+     * Normalize message to align with modulus.
+     */
+    ubsec_ShiftData(&pRSAParams->InputKeyInfo, NormBits);
+    /* RJT_TEST why is this rounded up? */
+    pRSAParams->InputKeyInfo.KeyLength=
+      ROUNDUP_TO_32_BIT(pRSAParams->InputKeyInfo.KeyLength+NormBits);
+  }
+  pMCR->KeyContextList[PacketIndex]->NormBits=NormBits;
+#else
+  NormBits=ModNLen-pRSAParams->ModN.KeyLength;
+  pRSAParams->OutputKeyInfo.KeyLength=ModNLen;
+  pRSAParams->InputKeyInfo.KeyLength=ModNLen;
+  pMCR->KeyContextList[PacketIndex]->NormBits=NormBits;
+#endif
+
+  pMCR->KeyContextList[PacketIndex]->ResultKey[0] = &pRSAParams->OutputKeyInfo; /* Save here for post-command finishing */ 
+  pMCR->KeyContextList[PacketIndex]->ResultKey[1] = NULL; /* Not used */
+  pMCR->KeyContextList[PacketIndex]->ResultRNG = NULL; /* Not used */
+  ModNLen/=8;
+
+  /* N, g setup. These parameters are copied to the CryptoNet context structure */
+
+#ifndef UBSEC_HW_NORMALIZE
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pRSACtx->Ng[0],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pRSAParams->ModN.KeyValue),
+	     ModNLen/4);
+  copywords( (UBS_UINT32 *)&pRSACtx->Ng[ModNLen/4],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pRSAParams->ExpE.KeyValue),
+	     pRSAParams->ExpE.KeyLength/32);
+#else /* No key swap */
+  RTL_Memcpy( &pRSACtx->Ng[0],OS_GetVirtualAddress(pRSAParams->ModN.KeyValue),ModNLen);
+  RTL_Memcpy( &pRSACtx->Ng[ModNLen/4],OS_GetVirtualAddress(pRSAParams->ExpE.KeyValue),
+	      pRSAParams->ExpE.KeyLength/8);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#else /* H/W normalization */
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pRSACtx->Ng[0],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pRSAParams->ModN.KeyValue),
+	     ROUNDUP_TO_32_BIT(pRSAParams->ModN.KeyLength)/32);
+  copywords( (UBS_UINT32 *)&pRSACtx->Ng[ModNLen/4],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pRSAParams->ExpE.KeyValue),
+	     pRSAParams->ExpE.KeyLength/32);
+#else /* No key swap */
+  RTL_Memcpy( &pRSACtx->Ng[0],OS_GetVirtualAddress(pRSAParams->ModN.KeyValue),ROUNDUP_TO_32_BIT(pRSAParams->ModN.KeyLength)/8);
+  RTL_Memcpy( &pRSACtx->Ng[ModNLen/4],OS_GetVirtualAddress(pRSAParams->ExpE.KeyValue),
+	      pRSAParams->ExpE.KeyLength/8);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#endif
+
+  ModNLen+=pRSAParams->ExpE.KeyLength/8;
+  /* Now set the extra length. */
+  pMCR->KeyContextList[PacketIndex]->cmd_structure_length+=(ModNLen);
+
+#ifdef UBSDBG
+  /* Print out the context information if required */
+  {
+  int WordLen,i;
+  WordLen=(pMCR->KeyContextList[PacketIndex]->cmd_structure_length-RSA_STATIC_PUBLIC_CONTEXT_SIZE)/4;
+  Dbg_Print(DBG_RSAKEY,(   "ubsec:  ---- RSA Public Modulus Length [%d] Normbits [%d]\n[",
+			   pRSACtx->modulus_length,NormBits)); 
+  Dbg_Print(DBG_RSAKEY,(   "ubsec:  ---- RSA Public G Length [%d] Context Len %d Value-\n[",
+			   CTRL_TO_CPU_SHORT(pRSACtx->exponent_length),
+			   pMCR->KeyContextList[PacketIndex]->cmd_structure_length)); 
+  for ( i=0 ; i < WordLen ; i++) {
+    Dbg_Print(DBG_RSAKEY,( "%08x ",SYS_TO_BE_LONG(pRSACtx->Ng[i])));
+  }
+  Dbg_Print(DBG_RSAKEY,( "]\n"));
+  }
+#endif
+
+  /* Input Buffer setup for RSA Public */
+  FragPtr=(DataBufChainList_pt)&pPacket->InputHead;
+  PhysAddr=(ubsec_MemAddress_t)(OS_GetPhysicalAddress( pRSAParams->InputKeyInfo.KeyValue));
+#if defined(UBS_ENABLE_KEY_SWAP)
+  longkey = (UBS_UINT32 *)OS_GetVirtualAddress(pRSAParams->InputKeyInfo.KeyValue);
+  for (element = 0 ; element < ROUNDUP_TO_32_BIT(pRSAParams->InputKeyInfo.KeyLength)/32 ; element++) 
+    longkey[element] = BYTESWAPLONG(longkey[element]);
+#endif /* UBS_ENABLE_KEY_SWAP */
+  FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+  DataLength=(pRSAParams->InputKeyInfo.KeyLength+7)/8;
+  FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+ /* Copy (endian-adjusted) fragment length into MCR structure */
+  pPacket->PacketLength = FragPtr->DataLength;
+  Dbg_Print(DBG_FRAG_SYNC,( "ubsec: RSA_SetupPublicParams Sync InputKeyInfo Fragment to Device (0x%08X,%d,%d)\n", 
+			    pRSAParams->InputKeyInfo.KeyValue,
+			    0,
+			    DataLength));
+  OS_SyncToDevice(pRSAParams->InputKeyInfo.KeyValue,
+		  0,
+		  DataLength);
+  Dbg_Print(DBG_RSAKEY,( "RSA Public Key, InputKeyInfo:  FragI <%d,%08x %08x>\n",
+            DataLength, CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr));
+  FragPtr->pNext = 0;
+
+  /* Output Buffer setup for RSA Public */
+  FragPtr=(DataBufChainList_pt)&pPacket->OutputHead;
+  PhysAddr=(ubsec_MemAddress_t)(OS_GetPhysicalAddress(pRSAParams->OutputKeyInfo.KeyValue));
+  FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+  DataLength=(pRSAParams->OutputKeyInfo.KeyLength+7)/8;
+  FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+  Dbg_Print(DBG_RSAKEY,( "RSA Public Key, OutputKeyInfo:  FragO <%d,%08x %08x>\n",
+            DataLength, CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr));
+  FragPtr->pNext = 0;
+
+  pRSAParams->OutputKeyInfo.KeyLength-=NormBits;
+  return(UBSEC_STATUS_SUCCESS);
+#else
+    return(UBSEC_STATUS_NO_DEVICE);
+#endif
+}
+
+/* 
+ * Function: RSA_SetupPrivateParams()
+ * Set up KeyContext Buffer, MCR Input Buffer and MCR Output Buffer 
+ * for RSA Private operation with parameters provided by pRSAParams 
+ * The KeyContext Buffer includes q_length,p_length, dq_length,                
+ * dp_length, pinv_length, p, q, dp, dq, and  pinv 
+ */
+ubsec_Status_t 
+RSA_SetupPrivateParams(MasterCommand_pt pMCR, ubsec_RSA_Params_pt pRSAParams)
+{
+#ifdef UBSEC_RSA_SUPPORT
+  VOLATILE DataBufChainList_t   *FragPtr;
+  int                            DataLength;
+  VOLATILE Packet_t 		*pPacket;
+  VOLATILE Pri_RSA_CtxCmdBuf_t	*pRSACtx;
+  int                  PacketIndex;
+  int Offset;
+  int element;
+  int ParamLen,NormBits;
+  UBS_UINT32 *longkey;
+  ubsec_MemAddress_t PhysAddr;
+
+  PacketIndex = pMCR->NumberOfPackets;
+  pRSACtx = &pMCR->KeyContextList[PacketIndex]->CtxCmdBuf.Pri_RSA_CtxCmdBuf;
+  pPacket = &(pMCR->PacketArray[PacketIndex]); /* Set up the current packet */
+  RTL_MemZero(pRSACtx,sizeof(*pRSACtx));
+  pRSACtx->q_length    = (unsigned short)CPU_TO_CTRL_SHORT(pRSAParams->PrimeQ.KeyLength) ;
+  pRSACtx->p_length    = (unsigned short)CPU_TO_CTRL_SHORT(pRSAParams->PrimeP.KeyLength) ;
+
+  /*
+   * All parameters need to be aligned on the 
+   * same length so we use the length of the 
+   * largest.
+   */
+
+  /* Both P & Q Must be normalized and aligned on the largest 
+     length. */
+  if ((pRSAParams->PrimeQ.KeyLength > pRSAParams->PrimeP.KeyLength)) 
+    ParamLen=pRSAParams->PrimeQ.KeyLength;
+  else
+    ParamLen=pRSAParams->PrimeP.KeyLength;
+    
+  if (ParamLen <=256)
+    ParamLen=256;
+  else
+    if (ParamLen <= 384)
+      ParamLen=384;
+    else
+      if (ParamLen <= 512)
+	ParamLen=512;
+      else
+#ifdef UBSEC_582x_CLASS_DEVICE
+	if (ParamLen <= 768)
+	  ParamLen=768;
+	else
+	  if (ParamLen <= 1024)
+	    ParamLen=1024;
+	else
+#endif
+	  return(UBSEC_STATUS_INVALID_PARAMETER);
+
+#ifndef UBSEC_HW_NORMALIZE
+  NormBits = ubsec_NormalizeDataTo(&pRSAParams->PrimeP,ParamLen);
+  if (NormBits)
+    ubsec_ShiftData(&pRSAParams->PrimeEdp, NormBits);
+  NormBits = ubsec_NormalizeDataTo(&pRSAParams->PrimeQ,ParamLen);
+  if (NormBits) {
+    ubsec_ShiftData(&pRSAParams->PrimeEdq, NormBits); 
+    ubsec_ShiftData(&pRSAParams->Pinv, NormBits); 
+  }
+
+  /* Return the number of bits the result will have to be shifted by. */
+  NormBits=((ParamLen*2)
+	    -(pRSAParams->PrimeQ.KeyLength+pRSAParams->PrimeP.KeyLength)); 
+
+  if (NormBits) {
+    pRSAParams->OutputKeyInfo.KeyLength = pRSAParams->PrimeQ.KeyLength+pRSAParams->PrimeP.KeyLength; 
+  }
+  pMCR->KeyContextList[PacketIndex]->NormBits=NormBits;
+#else
+  NormBits=((ParamLen*2)
+	    -(pRSAParams->PrimeQ.KeyLength+pRSAParams->PrimeP.KeyLength)); 
+
+  pMCR->KeyContextList[PacketIndex]->NormBits=NormBits;
+  pRSAParams->OutputKeyInfo.KeyLength=ParamLen*2;
+#endif
+
+  pRSAParams->InputKeyInfo.KeyLength = 2*ParamLen; /* Pad it out.*/
+  pRSAParams->OutputKeyInfo.KeyLength=2*ParamLen;
+
+  pMCR->KeyContextList[PacketIndex]->ResultKey[0] = &pRSAParams->OutputKeyInfo; /* Save here for post-command finishing */
+  pMCR->KeyContextList[PacketIndex]->ResultKey[1] = NULL; /* Not used */
+  pMCR->KeyContextList[PacketIndex]->ResultRNG = NULL; /* Not used */
+  ParamLen/=8;
+
+  /* p setup */
+
+#ifndef UBSEC_HW_NORMALIZE
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pRSACtx->CtxParams[0],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pRSAParams->PrimeP.KeyValue),
+	     ParamLen/4);
+ #else
+  RTL_Memcpy( &pRSACtx->CtxParams[0],OS_GetVirtualAddress(pRSAParams->PrimeP.KeyValue),
+	      ParamLen);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#else
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pRSACtx->CtxParams[0],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pRSAParams->PrimeP.KeyValue),
+	     ROUNDUP_TO_32_BIT(pRSAParams->PrimeP.KeyLength)/32);
+ #else
+  RTL_Memcpy( &pRSACtx->CtxParams[0],OS_GetVirtualAddress(pRSAParams->PrimeP.KeyValue),
+	      ROUNDUP_TO_32_BIT(pRSAParams->PrimeP.KeyLength)/8);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#endif
+  Offset=ParamLen;
+
+  /* q setup */
+#ifndef UBSEC_HW_NORMALIZE
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pRSACtx->CtxParams[Offset/4],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pRSAParams->PrimeQ.KeyValue),
+	     ParamLen/4);
+ #else
+  RTL_Memcpy( &pRSACtx->CtxParams[Offset/4],OS_GetVirtualAddress(pRSAParams->PrimeQ.KeyValue),
+	      ParamLen);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#else
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pRSACtx->CtxParams[Offset/4],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pRSAParams->PrimeQ.KeyValue),
+	     ROUNDUP_TO_32_BIT(pRSAParams->PrimeQ.KeyLength)/32);
+ #else
+  RTL_Memcpy( &pRSACtx->CtxParams[Offset/4],OS_GetVirtualAddress(pRSAParams->PrimeQ.KeyValue),
+	      ROUNDUP_TO_32_BIT(pRSAParams->PrimeQ.KeyLength)/8);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#endif
+  Offset+=ParamLen;
+
+  /* dp setup */
+#ifndef UBSEC_HW_NORMALIZE
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pRSACtx->CtxParams[Offset/4],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pRSAParams->PrimeEdp.KeyValue),
+	     ParamLen/4);
+ #else
+  RTL_Memcpy( &pRSACtx->CtxParams[Offset/4],OS_GetVirtualAddress(pRSAParams->PrimeEdp.KeyValue),
+	      ParamLen);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#else
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pRSACtx->CtxParams[Offset/4],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pRSAParams->PrimeEdp.KeyValue),
+	     ROUNDUP_TO_32_BIT(pRSAParams->PrimeEdp.KeyLength)/32);
+ #else
+  RTL_Memcpy( &pRSACtx->CtxParams[Offset/4],OS_GetVirtualAddress(pRSAParams->PrimeEdp.KeyValue),
+	      ROUNDUP_TO_32_BIT(pRSAParams->PrimeEdp.KeyLength)/8);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#endif
+  Offset+=ParamLen;
+
+  /* dq setup */
+#ifndef UBSEC_HW_NORMALIZE
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pRSACtx->CtxParams[Offset/4],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pRSAParams->PrimeEdq.KeyValue),
+	     ParamLen/4);
+ #else
+  RTL_Memcpy( &pRSACtx->CtxParams[Offset/4],OS_GetVirtualAddress(pRSAParams->PrimeEdq.KeyValue),
+	      ParamLen);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#else
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pRSACtx->CtxParams[Offset/4],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pRSAParams->PrimeEdq.KeyValue),
+	     ROUNDUP_TO_32_BIT(pRSAParams->PrimeEdq.KeyLength)/32);
+ #else
+  RTL_Memcpy( &pRSACtx->CtxParams[Offset/4],OS_GetVirtualAddress(pRSAParams->PrimeEdq.KeyValue),
+	      ROUNDUP_TO_32_BIT(pRSAParams->PrimeEdq.KeyLength)/8);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#endif
+
+  Offset+=ParamLen;
+
+  /* pinv setup */
+#ifndef UBSEC_HW_NORMALIZE
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pRSACtx->CtxParams[Offset/4],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pRSAParams->Pinv.KeyValue),
+	     ParamLen/4);
+ #else
+  RTL_Memcpy( &pRSACtx->CtxParams[Offset/4],OS_GetVirtualAddress(pRSAParams->Pinv.KeyValue),
+	      ParamLen);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#else
+ #if defined(UBS_ENABLE_KEY_SWAP)
+  copywords( (UBS_UINT32 *)&pRSACtx->CtxParams[Offset/4],
+	     (UBS_UINT32 *)OS_GetVirtualAddress(pRSAParams->Pinv.KeyValue),
+	     ROUNDUP_TO_32_BIT(pRSAParams->Pinv.KeyLength)/32);
+ #else
+  RTL_Memcpy( &pRSACtx->CtxParams[Offset/4],OS_GetVirtualAddress(pRSAParams->Pinv.KeyValue),
+	      ROUNDUP_TO_32_BIT(pRSAParams->Pinv.KeyLength)/8);
+ #endif /* UBS_ENABLE_KEY_SWAP */
+#endif
+  Offset+=ParamLen;
+
+  pMCR->KeyContextList[PacketIndex]->cmd_structure_length+=(Offset);
+
+#ifdef UBSDBG
+  /* Print out the context information if required */
+  {
+  int WordLen,i;
+  WordLen=(pMCR->KeyContextList[PacketIndex]->cmd_structure_length-RSA_STATIC_PRIVATE_CONTEXT_SIZE)/4;
+  Dbg_Print(DBG_RSAKEY,(   "ubsec:  ---- RSA Private P-Q Length [%d] P-D Length [%d] \n[",pRSACtx->q_length,pRSACtx->p_length)); 
+  Dbg_Print(DBG_RSAKEY,(   "ubsec:  ---- ParamLen %d Context Len %d Value -\n[",
+			   CTRL_TO_CPU_SHORT(ParamLen),pMCR->KeyContextList[PacketIndex]->cmd_structure_length )); 
+
+  for ( i=0 ; i < WordLen ; i++) {
+    Dbg_Print(DBG_RSAKEY,( "%08x ",SYS_TO_BE_LONG(pRSACtx->CtxParams[i])));
+  }
+  Dbg_Print(DBG_RSAKEY,( "]\n"));
+  }
+#endif
+
+  /* Input Buffer setup for RSA Private */
+  FragPtr=(DataBufChainList_pt)&pPacket->InputHead;
+  PhysAddr=(ubsec_MemAddress_t)(OS_GetPhysicalAddress(pRSAParams->InputKeyInfo.KeyValue));
+#if defined(UBS_ENABLE_KEY_SWAP)
+  longkey = (UBS_UINT32 *)OS_GetVirtualAddress(pRSAParams->InputKeyInfo.KeyValue);
+  for (element = 0 ; element < ROUNDUP_TO_32_BIT(pRSAParams->InputKeyInfo.KeyLength)/32 ; element++) 
+    longkey[element] = BYTESWAPLONG(longkey[element]);
+#endif /* UBS_ENABLE_KEY_SWAP */
+  FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+  DataLength=(pRSAParams->InputKeyInfo.KeyLength+7)/8;
+  FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+ /* Copy (endian-adjusted) fragment length into MCR structure */
+  pPacket->PacketLength = FragPtr->DataLength;
+  Dbg_Print(DBG_FRAG_SYNC,( "ubsec: RSA_SetupPrivateParams Sync InputKeyInfo Fragment to Device (0x%08X,%d,%d)\n", 
+			    pRSAParams->InputKeyInfo.KeyValue,
+			    0,
+			    DataLength));
+  OS_SyncToDevice(pRSAParams->InputKeyInfo.KeyValue,
+		  0,
+		  DataLength);
+  Dbg_Print(DBG_RSAKEY,( "RSA Private Key, InputKeyInfo:  FragI <%d,%08x %08x>\n",
+            DataLength, CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr));
+  FragPtr->pNext = 0;
+
+  /* Output Buffer setup for RSA Public */
+  FragPtr=(DataBufChainList_pt)&pPacket->OutputHead;
+  PhysAddr=(ubsec_MemAddress_t)(OS_GetPhysicalAddress(pRSAParams->OutputKeyInfo.KeyValue));
+  FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)PhysAddr );
+  DataLength=(pRSAParams->OutputKeyInfo.KeyLength+7)/8;
+  FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+  Dbg_Print(DBG_RSAKEY,( "RSA Private Key, OutputKeyInfo:  FragO <%d,%08x %08x>\n",
+            DataLength, CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr));
+  FragPtr->pNext = 0;
+
+  pRSAParams->OutputKeyInfo.KeyLength-=NormBits;
+
+  return(UBSEC_STATUS_SUCCESS);
+#else
+    return(UBSEC_STATUS_NO_DEVICE);
+#endif
+}
+
+
+#endif /* UBSEC_PKEY_SUPPORT */ 
diff -urNp linux-8030/drivers/addon/bcm/ubssha1.c linux-8040/drivers/addon/bcm/ubssha1.c
--- linux-8030/drivers/addon/bcm/ubssha1.c
+++ linux-8040/drivers/addon/bcm/ubssha1.c
@@ -0,0 +1,220 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/* 
+ * ubssha1.c: SHA1 key manipulation functions.
+ */
+
+/*
+ * Revision History:
+ *
+ * 09/xx/1999 SOR Created from little endian c-model
+ * 12/02/1999 DWP modified to handle Big Endian architectures
+ * 04/03/2001 RJT Added support for CryptoNet device big-endian mode
+ * 10/09/2001 SRM 64 bit port
+ */
+
+#include "ubsincl.h"
+                                         
+static void SHAUpdate(SHA_CTX *ctx, unsigned char *HashBlock, int len);
+
+static  void bytnxor( unsigned char *dest, unsigned char *src1, unsigned char *src2, unsigned char len)
+{
+  while (len-- > 0) *dest++ = *src1++ ^ *src2++; 
+}
+
+/*
+ * This code will only work on a little endian machine. Constants and boolean functions
+ * are out of Schneier's "Applied Cryptography". Also, SHAUpdate() must only be called
+ * once, followed by a call to SHAFinal() -- the length field is not being properly
+ * carried over within SHAUpdate().
+ *
+ * This implementation does not handle large block sizes per the spec.
+ * It is meant for packets of less than 2**28 bytes each.
+*/
+
+/* Boolean functions for internal rounds */
+#define F(x,y,z) ( ((x) & (y)) | ((~(x)) & (z)) )
+#define G(x,y,z) ( (x) ^ (y) ^ (z) )
+#define H(x,y,z) ( ((x)&(y)) | ((x)&(z)) | ((y)&(z)) )
+
+/* The 4 magic constants */
+static UBS_UINT32 SHA1_K[] = {
+  0x5a827999, 0x6ed9eba1, 
+  0x8f1bbcdc, 0xca62c1d6
+  };
+
+static unsigned char ipad[64] = {0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+        0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+        0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+        0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+        0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+        0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+        0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
+        0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36};
+                                         
+static unsigned char opad[64] = {0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
+        0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
+        0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
+        0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
+        0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
+        0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
+        0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
+        0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c};
+
+void 
+InitSHA1State(ubsec_HMAC_State_pt HMAC_State,unsigned char *HashKey)
+{
+  SHA_CTX ctx;
+  unsigned char pad[64];
+
+  /* First prepare the inner block. */
+  bytnxor((unsigned char *)pad,(unsigned char *)HashKey,ipad, 64);
+
+	/* Init the context, the initial values in memory are 01 23 45 ... */
+  RTL_MemZero(&ctx,sizeof(SHA_CTX));
+  ctx.buffer[0] = 0x67452301;
+  ctx.buffer[1] = 0xefcdab89;
+  ctx.buffer[2] = 0x98badcfe;
+  ctx.buffer[3] = 0x10325476;
+  ctx.buffer[4] = 0xc3d2e1f0;
+  SHAUpdate(&ctx,pad,64);
+
+	/* ctx comes out as an array of long ints. The byte order of ctx
+is dependent on the CPU endianess. The byte order of the memory destination 
+is dependent on the CryptoNet memory endianess. Based on our SHA1 algorithm's
+CPU endianess assumptions, the net result is that we do a straight copy if
+the CPU and CryptoNet memory are of the same endianess. If the CPU and 
+CryptoNet memory are of opposite endianess, we'll do 32-bit byteswapping
+during the copy, taken care of by the copywords() routine. */
+
+#if (UBS_CPU_ATTRIBUTE != UBS_CRYPTONET_ATTRIBUTE)
+  copywords((UBS_UINT32 *)&HMAC_State->InnerState[0],&ctx.buffer[0], SHA_HASH_LENGTH/4); 
+#else
+  RTL_Memcpy(&HMAC_State->InnerState[0],&ctx.buffer[0], SHA_HASH_LENGTH); 
+#endif /* UBS_CPU_ATTRIBUTE */
+
+  /* Do do the same for the outer block */
+  bytnxor((unsigned char *)pad,(unsigned char *)HashKey, opad, 64);
+  RTL_MemZero(&ctx,sizeof(SHA_CTX));
+  ctx.buffer[0] = 0x67452301;
+  ctx.buffer[1] = 0xefcdab89;
+  ctx.buffer[2] = 0x98badcfe;
+  ctx.buffer[3] = 0x10325476;
+  ctx.buffer[4] = 0xc3d2e1f0;
+
+  SHAUpdate(&ctx, pad,64);
+
+	/* ctx comes out as an array of long ints. The byte order of ctx
+is dependent on the CPU endianess. The byte order of the memory destination 
+is dependent on the CryptoNet memory endianess. Based on our SHA1 algorithm's
+CPU endianess assumptions, the net result is that we do a straight copy if
+the CPU and CryptoNet memory are of the same endianess. If the CPU and 
+CryptoNet memory are of opposite endianess, we'll do 32-bit byteswapping
+during the copy, taken care of by the copywords() routine. */
+
+#if (UBS_CPU_ATTRIBUTE != UBS_CRYPTONET_ATTRIBUTE)
+  copywords((UBS_UINT32 *)&HMAC_State->OuterState[0],&ctx.buffer[0], SHA_HASH_LENGTH/4); 
+#else
+  RTL_Memcpy(&HMAC_State->OuterState[0],&ctx.buffer[0], SHA_HASH_LENGTH); 
+#endif /* UBS_CPU_ATTRIBUTE */
+
+}
+
+
+static void
+SHAUpdate(SHA_CTX *ctx, unsigned char *HashBlock, int len)
+{
+  UBS_UINT32 a, b, c, d, e;
+  int block, i;
+
+	/* Process as many blocks as possible */
+  for (block = 0; len >= 64; len -= 64, ++block) {
+    UBS_UINT32 m[16];
+
+    /* A 16-byte buffer is sufficient -- we build needed words beyond the first 16 on the fly */
+    RTL_Memcpy(m, HashBlock + 64*block, 64); /* Get one block of data */
+
+    /* At this point m[] is built as a char array. However, m[] will
+       be operated on from here on out as an array of unsigned longs.
+       This algorithm assumes m[] is arranged in big-endian byte order, so 
+       we'll endian-adjust the byte array if we have a little endian CPU */
+
+#if (UBS_CPU_ATTRIBUTE == UBS_LITTLE_ENDIAN)
+    for (i = 0; i < 16; ++i) 
+        m[i] = BYTESWAPLONG(m[i]); /* View data as big endian */
+#endif
+
+    a = ctx->buffer[0];
+    b = ctx->buffer[1];
+    c = ctx->buffer[2];
+    d = ctx->buffer[3];
+    e = ctx->buffer[4];
+
+    Dbg_Print(DBG_SHA1,("pre round 0: 0x%x 0x%x 0x%x 0x%x 0x%x\n", a, b, c, d, e));
+
+		/* Four sets of 20 rounds each */
+    for (i = 0; i < 80; ++i) {
+      unsigned long fn = 0, temp, K = 0;
+      switch (i / 20) {
+      case 0: K = SHA1_K[0]; fn = F(b,c,d); break;
+      case 1: K = SHA1_K[1]; fn = G(b,c,d); break;
+      case 2: K = SHA1_K[2]; fn = H(b,c,d); break;
+      case 3: K = SHA1_K[3]; fn = G(b,c,d); break;
+      default:;
+      }
+
+			/* Build needed words beyond original 16 on the fly */
+      if (i >= 16) m[i % 16] = rol(m[(i-3) % 16] ^ m[(i-8) % 16] ^ m[(i-14) % 16] ^ m[(i-16) % 16], 1);
+      temp = rol(a, 5) + fn + e + m[i%16] + K;
+      e = d;
+      d = c;
+      c = rol(b, 30);
+      b = a;
+      a = temp;
+
+     Dbg_Print(DBG_SHA1,("post round %d: 0x%x 0x%x 0x%x 0x%x 0x%x\n", i, a, b, c, d, e));
+    }
+
+    ctx->buffer[0] += a;
+    ctx->buffer[1] += b;
+    ctx->buffer[2] += c;
+    ctx->buffer[3] += d;
+    ctx->buffer[4] += e;
+  }
+
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
diff -urNp linux-8030/drivers/addon/bcm/ubssha1.h linux-8040/drivers/addon/bcm/ubssha1.h
--- linux-8030/drivers/addon/bcm/ubssha1.h
+++ linux-8040/drivers/addon/bcm/ubssha1.h
@@ -0,0 +1,56 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubssha1.h: 
+ * 10/09/2001 SRM 64 bit port.
+ */
+
+/*
+ * Revision History:
+ *
+ */
+
+#ifndef _SHA_H_
+#define _SHA_H_
+
+/* define the following line to get FIPS 180-1 enhancements */
+#define SHA_UPDATE
+
+#define SHA_BLOCK_LENGTH  64		/* in bytes */
+#define SHA_HASH_LENGTH   20		/* in bytes */
+
+typedef unsigned char BYTE;
+
+
+typedef struct {
+    UBS_UINT32 Numbytes;
+    UBS_UINT32 Numblocks[2];  /* each block contains 64 bytes */
+    UBS_UINT32 Mblock[16];
+    UBS_UINT32 buffer[5];
+} SHA_CTX;
+
+
+#endif /*_SHA_H_*/
+
diff -urNp linux-8030/drivers/addon/bcm/ubssolaris.h linux-8040/drivers/addon/bcm/ubssolaris.h
--- linux-8030/drivers/addon/bcm/ubssolaris.h
+++ linux-8040/drivers/addon/bcm/ubssolaris.h
@@ -0,0 +1,108 @@
+/******************************************************************************
+ *
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+/*
+ * ubssolaris.h:  ubsec solaris dependent routines 
+ */
+/*
+ * Revision History:
+ *
+ * 6/27/99 PW Created.
+ */
+
+
+#ifndef _UBSSOLARIS_H
+#define _UBSSOLARIS_H
+
+#ifdef SOLARIS_DEVICE
+
+#define UBS_UINT32  unsigned int
+
+#define OS_DeviceInfo_t PhysDeviceInfo_t *
+#define OS_MemHandle_t  UbsDMAHandle *
+#define OS_DeviceInfo_pt PhysDeviceInfo_t *
+
+#define OS_DeviceStruct_pt Ubsio *
+
+#include "cdevdrv.h"
+
+#ifdef UBSDBG
+#define DbgPrint(x) printf x
+#else
+#define DbgPrint(x) 
+#endif
+
+#define VOLATILE volatile
+#define UBSECAPI
+
+#define OS_GetVirtualAddress(MemHandle)   ((OS_MemHandle_t *)(MemHandle)->virt_addr)
+/*#define OS_GetPhysicalAddress(MemHandle)  ((UBS_UINT32 *)(OS_MemHandle_t *)(MemHandle)->phys_addr)*/
+#define OS_GetPhysicalAddress(MemHandle)  ((UBS_UINT32 )(MemHandle)->phys_addr)
+
+
+extern unsigned long Solaris_TestCriticalSection( OS_DeviceStruct_pt ubs_p);
+extern unsigned long Solaris_EnterCriticalSection( OS_DeviceStruct_pt ubs_p);
+extern void Solaris_LeaveCriticalSection( OS_DeviceStruct_pt ubs_p);
+
+#define OS_TestCriticalSection(pDevice,SaveConfig) Solaris_TestCriticalSection(pDevice->OsDeviceInfo->ubsio_pt)
+#define OS_EnterCriticalSection(pDevice,SaveConfig) Solaris_EnterCriticalSection(pDevice->OsDeviceInfo->ubsio_pt)
+#define OS_LeaveCriticalSection(pDevice,SaveConfig) Solaris_LeaveCriticalSection(pDevice->OsDeviceInfo->ubsio_pt)
+
+#define OS_InitCriticalSection(pDevice)
+
+extern void *  Solaris_AllocateDMAMemory(OS_DeviceStruct_pt handle,int size);
+extern void Solaris_FreeDMAMemory(void *mem,int size);
+extern void *Solaris_AllocateMemory(int size);
+extern void Solaris_FreeMemory(void *mem,int size);
+
+
+
+/*************************** 
+ * Memory allocations 
+ ***************************/ 
+
+#define OS_AllocateMemory(size)    	       Solaris_AllocateMemory(size)
+#define OS_AllocateDMAMemory( pDevice, size)   Solaris_AllocateDMAMemory( pDevice->OsDeviceInfo->ubsio_pt,size)
+#define OS_FreeMemory(mem,size)     	       Solaris_FreeMemory(mem,size);
+#define OS_FreeDMAMemory(mem,size)  	       Solaris_FreeDMAMemory(mem,size)
+
+
+#define OS_SyncToDevice(MemHandle,offset,size) (ddi_dma_sync((OS_MemHandle_t *)(MemHandle)->iopbhdl,(off_t)offset,(size_t)size,(u_int)DDI_DMA_SYNC_FORDEV))
+
+#define OS_SyncToCPU(MemHandle,offset,size) (ddi_dma_sync((OS_MemHandle_t *)(MemHandle)->iopbhdl,(off_t)offset,(size_t)size,(u_int)DDI_DMA_SYNC_FORKERNEL))
+
+#define OS_FreeISR(irq,context)
+
+#define OS_AllocateISR(irq,context,callback)   Solaris_AllocateISR(irq,context,callback)
+#if 0 /* FIX Me  -Gigi */
+#define OS_ScheduleCallBack(CallBack,Context) ddi_trigger_softintr( (DeviceInfo_pt)Context->OsDeviceInfo->ubsio_pt->softint_id)  
+#else
+#define OS_ScheduleCallBack(CallBack,Context)
+#endif
+
+#define OS_MapPhysToIO(pDevice,Physical_Address,size)  (Physical_Address) 
+
+#define OS_UnMapIO(pDevice,ioaddr)     
+#define OS_IOMemWrite32(Address,val)  \
+(*Address)=val
+
+#define OS_IOMemRead32(Address) (*Address)
+#define OS_Waitus(wait_us) delay(drv_usectohz(wait_us))
+
+#define  RTL_MemZero(mem,bytes)   bzero((char *)mem,bytes)
+#define  RTL_Memcpy(dest,source,bytes) bcopy((char *)source,(char *)dest,bytes)
+#define  RTL_Memcmp(dest,source,bytes) bcmp((char *)dest,(char *)source,bytes)
+#define  RTL_Memset(mem,val,bytes)   bzero((char *)mem,bytes)
+
+
+#endif /* SOLARIS_DEVICE */
+#endif  _UBSSOLARIS_H
diff -urNp linux-8030/drivers/addon/bcm/ubsssl.c linux-8040/drivers/addon/bcm/ubsssl.c
--- linux-8030/drivers/addon/bcm/ubsssl.c
+++ linux-8040/drivers/addon/bcm/ubsssl.c
@@ -0,0 +1,405 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubsssl.c: SSL/TLS/ARC4 commands are handled by this module
+ */
+
+/*
+ * Revision History:
+ *
+ * 10/xx/2000 SOR Created
+ * 04/19/2001 RJT Added support for CPU-DMA memory synchronization
+ * 10/09/2001 SRM 64 bit port.
+ */
+
+#include "ubsincl.h"
+
+
+/*
+ * ubsec_SSLCommand: Process a list of Cipher commands.
+ *
+ * Immediate Status is returned. Completion status is returned
+ * on a per command callback
+ */
+ubsec_Status_t 
+ubsec_SSLCommand(ubsec_DeviceContext_t Context,
+	      ubsec_SSLCommandInfo_pt pCommand,
+	      int *NumCommands)
+{
+#ifdef UBSEC_SSL_SUPPORT
+  DeviceInfo_pt pDevice=(DeviceInfo_pt)Context;
+  VOLATILE MasterCommand_t   *pMCR;
+  VOLATILE Packet_t          *pPacket;
+  VOLATILE PacketContext_t   *pContext;
+  VOLATILE SSL_MACContext_t  *pSSLMACContext;
+  VOLATILE TLS_HMACContext_t *pTLSHMACContext;
+  VOLATILE SSL_CryptoContext_t *pSSLCryptoContext;
+  VOLATILE ARC4_CryptoContext_t *pARC4Context;
+  VOLATILE Hash_Context_t *pHashContext;
+  int i;
+  long *plong;
+  VOLATILE int             PacketIndex;
+
+  int CommandIndex=0;
+  int CommandCount=*NumCommands;
+  ubsec_Status_t Status;
+  unsigned long SaveConfig;
+  ubsec_FragmentInfo_pt pExtraFragment=(ubsec_FragmentInfo_pt) 0;
+
+  Dbg_Print(DBG_CMD,( "ubsec:  SSL command %d",*NumCommands ));
+  /*
+   * Check some parameters
+   */    
+  if(pDevice==NULL_DEVICE_INFO) {
+    Dbg_Print(DBG_FATAL,( "NO DEV\n " ));
+    return(UBSEC_STATUS_NO_DEVICE );
+  }
+  Dbg_Print(DBG_CMD,( "\n"));
+
+  if (!(UBSEC_IS_SSL_DEVICE(pDevice))) {
+    Dbg_Print(DBG_FATAL,( "ubsec: SSL Command for a non SSL device %x \n ",pDevice->DeviceID ));
+    return(UBSEC_STATUS_NO_DEVICE );
+  }
+
+  /*  SaveConfig=OS_EnterCriticalSection(pDevice); */
+  OS_EnterCriticalSection(pDevice, SaveConfig);
+
+  /* Get the next MCR to load */
+ Get_New_MCR:
+  *NumCommands=CommandIndex; /* Update number completed */
+  if ((pMCR=GetFreeMCR(pDevice,UBSEC_CIPHER_LIST,&Status))== NULL_MASTER_COMMAND) {
+    Dbg_Print(DBG_CMD_FAIL,("ubsec: device busy MCR %x\n",Status));
+    goto Error_Return;
+  }
+
+  /* Add packets to this MCR. */
+
+  Dbg_Print(DBG_CMD,( "ubsec: mcr_index %d MCR %0x\n",pMCR->Index,pMCR));
+  /* Initialize the packet information */
+
+  PacketIndex = pMCR->NumberOfPackets; 
+  pPacket = &(pMCR->PacketArray[PacketIndex]); /* Set up the current packet. */
+  pContext = &pMCR->ContextList[PacketIndex]; 
+  Status=UBSEC_STATUS_SUCCESS; /* Wishful thinking? */
+
+  /* Process all the commands in the command list. */
+  for (; CommandIndex < CommandCount ; CommandIndex++) { /* Add all the packets to the MCR */
+    if( PacketIndex >= MCR_MAXIMUM_PACKETS ) {
+      Dbg_Print(DBG_CMD,( "ubsec:  overran mcr buffer. %d\n",PacketIndex,CommandIndex ));
+      /* 
+       * We have filled this MCR. 
+       * Advance next free. Wrap around if necessary
+       */
+      pDevice->NextFreeMCR[0]=(MasterCommand_pt) pMCR->pNextMCR;
+      PushMCR(pDevice); /* Get it going (pipeline) */
+      goto Get_New_MCR; /* Try to add to the next MCR */
+    }
+    
+    pPacket->PacketContextBuffer=pContext->PhysicalAddress; 
+    
+    /* Save the callback information. */
+    pMCR->CompletionArray[PacketIndex].CompletionCallback = pCommand->CompletionCallback;
+    pMCR->CompletionArray[PacketIndex].CommandContext = pCommand->CommandContext;
+
+    /* Now set up the packet processing parameters */
+    Dbg_Print(DBG_PACKET,( "ubsec: packet_Index %d, Context Buf %0x\n",PacketIndex,pContext ));
+
+        /* Now setup the particular context */
+
+    pExtraFragment=(ubsec_FragmentInfo_pt) 0;
+    switch (UBSEC_SSL_COMMAND(pCommand->Command)) {
+
+
+    case UBSEC_SSL_MAC:
+      pContext->cmd_structure_length= CPU_TO_CTRL_SHORT(SSLMAC_CONTEXT_SIZE);
+      pContext->operation_type=OPERATION_SSL_MAC;
+      pCommand->NumDestination=0; /* Make sure */
+
+      pSSLMACContext=&pContext->Context.SSL_Mac;
+      RTL_MemZero(pSSLMACContext,sizeof(*pSSLMACContext));
+
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_BIG_ENDIAN)
+      pSSLMACContext->SequenceHigh=pCommand->Parameters.SSLMACParams.SequenceNumber.HighWord;
+      pSSLMACContext->SequenceLow=pCommand->Parameters.SSLMACParams.SequenceNumber.LowWord;
+      RTL_Memcpy(&pSSLMACContext->HMACKey[0],&pCommand->Parameters.SSLMACParams.key[0],20);
+#else
+      pSSLMACContext->SequenceHigh=BYTESWAPLONG(pCommand->Parameters.SSLMACParams.SequenceNumber.HighWord);
+      pSSLMACContext->SequenceLow=BYTESWAPLONG(pCommand->Parameters.SSLMACParams.SequenceNumber.LowWord);
+      copywords((UBS_UINT32 *)&pSSLMACContext->HMACKey[0],
+		(UBS_UINT32 *)&pCommand->Parameters.SSLMACParams.key[0],5);
+#endif
+
+      pSSLMACContext->DataLength=CPU_TO_CTRL_SHORT(pCommand->Parameters.SSLMACParams.DataLength);
+      pSSLMACContext->ContentType=pCommand->Parameters.SSLMACParams.ContentType;
+
+      /*
+      for (i=0,plong=(long *)&pSSLMACContext->HMACPad; i <SSL_MAC_PAD_LENGTH_LONG; i++)
+	*plong++=SSL_MAC_PAD_VALUE_LONG;
+      */
+      RTL_Memset((unsigned char*)pSSLMACContext->HMACPad, 0x36, 48);
+
+      pExtraFragment=&pCommand->Parameters.HashParams.OutputHMAC;
+      if( UBSEC_MAC_MD5 & pCommand->Command )
+	pSSLMACContext->CryptoFlag = CF_MD5;
+      else if( UBSEC_MAC_SHA1 & pCommand->Command )
+	pSSLMACContext->CryptoFlag = CF_SHA1;
+      
+      break;
+
+    case UBSEC_TLS: 
+      pContext->cmd_structure_length= CPU_TO_CTRL_SHORT(TLSHMAC_CONTEXT_SIZE);
+      pContext->operation_type=OPERATION_TLS_HMAC;
+      pCommand->NumDestination=0; /* Make sure */
+           
+      pTLSHMACContext=&pContext->Context.TLS_HMac;
+      RTL_MemZero(pTLSHMACContext,sizeof(*pTLSHMACContext));
+
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_BIG_ENDIAN)
+      /* Assume sequence numbers are in proper format. */
+      pTLSHMACContext->SequenceHigh=pCommand->Parameters.TLSHMACParams.SequenceNumber.HighWord;
+      pTLSHMACContext->SequenceLow=pCommand->Parameters.TLSHMACParams.SequenceNumber.LowWord;
+#else
+      /* Assume sequence numbers are in proper format. */
+      pTLSHMACContext->SequenceHigh=BYTESWAPLONG(pCommand->Parameters.TLSHMACParams.SequenceNumber.HighWord);
+      pTLSHMACContext->SequenceLow=BYTESWAPLONG(pCommand->Parameters.TLSHMACParams.SequenceNumber.LowWord);
+#endif      
+      RTL_Memcpy( &pTLSHMACContext->HMACInnerState[0],
+		  pCommand->Parameters.TLSHMACParams.HMACState,sizeof(ubsec_HMAC_State_t)); 
+      /* printk("md5 = x%x sha = x%x command = x%x\n", UBSEC_MAC_MD5, UBSEC_MAC_SHA1, pCommand->Command); */
+      pTLSHMACContext->CryptoFlag = 0;
+      if( UBSEC_MAC_MD5 & pCommand->Command )
+	pTLSHMACContext->CryptoFlag |= CF_MD5;
+      else if( UBSEC_MAC_SHA1 & pCommand->Command )
+	pTLSHMACContext->CryptoFlag |= CF_SHA1;
+
+      pTLSHMACContext->ContentType=pCommand->Parameters.TLSHMACParams.ContentType;
+      pTLSHMACContext->Version = CPU_TO_CTRL_SHORT(pCommand->Parameters.TLSHMACParams.Version);
+      pTLSHMACContext->DataLengthHi=HIGH_BYTE(pCommand->Parameters.TLSHMACParams.DataLength);
+	pTLSHMACContext->DataLengthLo=LOW_BYTE(pCommand->Parameters.TLSHMACParams.DataLength);
+      pExtraFragment=&pCommand->Parameters.TLSHMACParams.OutputHMAC;
+      break;
+    case UBSEC_SSL_CRYPTO:
+      pContext->cmd_structure_length= CPU_TO_CTRL_SHORT(SSLCRYPTO_CONTEXT_SIZE);
+      pContext->operation_type=OPERATION_SSL_CRYPTO;
+      pSSLCryptoContext=&pContext->Context.SSL_Crypto;
+      RTL_MemZero(pSSLCryptoContext,sizeof(*pSSLCryptoContext));
+
+      if (UBSEC_USING_CRYPT( pCommand->Command )) {
+	pSSLCryptoContext->CryptoFlag |= CF_3DES;
+	  
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_BIG_ENDIAN)
+	RTL_Memcpy(&pSSLCryptoContext->CryptoKey1[0], pCommand->Parameters.SSLCipherParams.CryptKey, 24);
+	RTL_Memcpy(&pSSLCryptoContext->ComputedIV[0], &pCommand->Parameters.SSLCipherParams.InitialVector[0],8);
+#else
+	copywords((UBS_UINT32 *)&pSSLCryptoContext->CryptoKey1[0], pCommand->Parameters.SSLCipherParams.CryptKey, 6);
+	copywords((UBS_UINT32 *)&pSSLCryptoContext->ComputedIV[0], (UBS_UINT32 *)&pCommand->Parameters.SSLCipherParams.InitialVector[0],2);
+#endif
+	}
+        /* Set up the context flags for direction */
+      if (pCommand->Command & UBSEC_ENCODE)
+	pSSLCryptoContext->CryptoFlag = CF_ENCODE;
+      else
+	pSSLCryptoContext->CryptoFlag = CF_DECODE;
+
+      break;
+
+    case UBSEC_HASH:
+      pContext->cmd_structure_length= CPU_TO_CTRL_SHORT(HASH_CONTEXT_SIZE);
+      pContext->operation_type=OPERATION_HASH; 
+      pHashContext=&pContext->Context.Hash;
+      RTL_MemZero(pHashContext,sizeof(*pHashContext));
+
+      if( UBSEC_MAC_MD5 & pCommand->Command )
+	pHashContext->CryptoFlag |= CF_MD5;
+      else if( UBSEC_MAC_SHA1 & pCommand->Command )
+	pHashContext->CryptoFlag |= CF_SHA1;
+      pExtraFragment=&pCommand->Parameters.HashParams.OutputHMAC;
+      pExtraFragment->FragmentLength=0; /* Only pointer is used .*/
+      pCommand->NumDestination=0; /* Should already be but... */
+      break;
+
+    case UBSEC_ARC4:
+
+    #if defined(UBSEC_582x) 
+      /* ARC4_NULL_DATA mode supported in "582x mode" driver for BCM5821 and later chips only */
+      if ((pCommand->Parameters.ARC4Params.KeyStateFlag & UBSEC_ARC4_STATE_NULL_DATA) && \
+	   (pDevice->DeviceID < BROADCOM_DEVICE_ID_5821)) {
+	Status=UBSEC_STATUS_INVALID_PARAMETER;
+	goto MCR_Done;
+      }
+    #else
+      /* ARC4_NULL_DATA mode not supported in "5820 mode" driver */
+      if (pCommand->Parameters.ARC4Params.KeyStateFlag & UBSEC_ARC4_STATE_NULL_DATA) {
+	Status=UBSEC_STATUS_INVALID_PARAMETER;
+	goto MCR_Done;
+      }       
+#endif /* UBSEC_582x */
+
+      pContext->cmd_structure_length= CPU_TO_CTRL_SHORT(ARC4_CONTEXT_SIZE);
+      pContext->operation_type=OPERATION_ARC4; 
+      pARC4Context=&pContext->Context.ARC4_Crypto;
+      RTL_MemZero(pARC4Context,sizeof(*pARC4Context));
+
+      if (pCommand->Parameters.ARC4Params.KeyStateFlag & UBSEC_ARC4_STATE_WRITEBACK) {
+	/*  printk("\nSRL: keystateflag = %d\n", pCommand->Parameters.ARC4Params.KeyStateFlag); */
+	pARC4Context->StateInfo|=ARC4_STATE_WRITEBACK;
+      }
+      if (pCommand->Parameters.ARC4Params.KeyStateFlag & UBSEC_ARC4_STATE_STATEKEY) {
+	/*  printk("\nSRL: keystateflag = %d\n", pCommand->Parameters.ARC4Params.KeyStateFlag); */
+	pARC4Context->StateInfo|=ARC4_STATE_STATEKEY;
+      }
+    #if defined(UBSEC_582x) 
+      if (pCommand->Parameters.ARC4Params.KeyStateFlag & UBSEC_ARC4_STATE_NULL_DATA) {
+	/* printk("\nSRL: keystateflag = %d\n", pCommand->Parameters.ARC4Params.KeyStateFlag); */
+	pARC4Context->StateInfo|=ARC4_STATE_NULL_DATA;
+      } 
+    #endif /* UBSEC_582x */
+
+
+#if (UBS_CRYPTONET_ATTRIBUTE == UBS_BIG_ENDIAN)
+      /* The initial "packed key" must be byteswapped for big endian CryptoNet builds */
+      if (pCommand->Parameters.ARC4Params.KeyStateFlag & UBSEC_ARC4_STATE_STATEKEY) 
+	copywords( (UBS_UINT32 *)pARC4Context->KeyState,
+		   (UBS_UINT32 *)pCommand->Parameters.ARC4Params.KeyStateIn,
+		   sizeof(ubsec_ARC4_State_t)/4);
+      else
+#endif
+      RTL_Memcpy( pARC4Context->KeyState,pCommand->Parameters.ARC4Params.KeyStateIn,sizeof(ubsec_ARC4_State_t));
+
+
+      pExtraFragment=&pCommand->Parameters.ARC4Params.state_out;
+      break;
+    default:
+      Dbg_Print(DBG_CMD,( "ubsec:  SSL Invalid Command %x\n",pCommand->Command ));
+      Status=UBSEC_STATUS_INVALID_PARAMETER;
+      goto MCR_Done;
+    };
+
+
+    /*
+     * Now add the packet input fragment information
+     * First fragment will need to skip the MAC Header
+     * Must have at least one fragment (pCommand->NumSource > 0).
+     *
+     * For ARC4_NULL_DATA mode, we still need to know how big the message is.
+     * You can actually build a DMA-able input fragment list just like if you were
+     * not using ARC4_NULL_DATA mode, but that method incurs unnecessary CPU cycles.
+     * The fastest way is to create a single "dummy" input fragment, with
+     * a FragmentLength equal to the length of the "virtual" message. 
+     * The "dummy" fragment's DataAddress will be ignored. Either way,
+     * at least one input fragment must be present.
+     */
+    if ((Status=SetupInputFragmentList((MasterCommand_pt)pMCR, (Packet_t *)pPacket,pCommand->NumSource,pCommand->SourceFragments))) {
+      goto MCR_Done;
+    }
+
+    /*
+     * Now add the packet output fragment information
+     */
+    if ((Status=SetupOutputFragmentList((MasterCommand_pt)pMCR, (Packet_t *)pPacket,pCommand->NumDestination,pCommand->DestinationFragments,pExtraFragment))) {
+      goto MCR_Done;
+    }
+
+    /* Sync the current context memory region for CryptoNet DMA use */
+    Dbg_Print(DBG_CNTXT_SYNC,( "ubsec: ubsec_SSLCommand() Sync Context to Device (0x%08X,%d,%d)\n", pMCR->ContextListHandle[PacketIndex],
+		       0,
+		       CTRL_TO_CPU_SHORT(pContext->cmd_structure_length)));
+    OS_SyncToDevice(pMCR->ContextListHandle[PacketIndex],
+		    0,
+		    CTRL_TO_CPU_SHORT(pContext->cmd_structure_length));
+
+
+#ifdef UBSEC_STATS
+    if (UBSEC_SSL_COMMAND(pCommand->Command)== UBSEC_SSL_CRYPTO){
+      	if (pCommand->Command & UBSEC_ENCODE){
+      		pDevice->Statistics.BlocksEncryptedCount++;
+      		pDevice->Statistics.BytesEncryptedCount+=CTRL_TO_CPU_SHORT(pPacket->PacketLength);
+    		}
+    		else {
+      		pDevice->Statistics.BlocksDecryptedCount++;
+      		pDevice->Statistics.BytesDecryptedCount+=CTRL_TO_CPU_SHORT(pPacket->PacketLength);
+    		}
+	}
+#endif
+
+   /* Now inc the number of packets and prepare for the next command. */
+    pMCR->NumberOfPackets++;
+    pCommand++;
+    PacketIndex++;
+    pPacket++;
+    pContext++;
+  } /* For (;CommandIndex < CommandCount ; CommandIndex++) */
+
+#ifdef UBSDBG
+  /* Print out the context information if required */
+  DumpCipherMCR(pMCR);
+#endif
+
+
+  /*
+   * If we are here then the MCR is built.
+   * Either everything went great or we came straight here at the first
+   * error condition we encountered. The MCR is filled only with those
+   * packets that were built successfully (before any encountered error). 
+   * Push the MCR to the device. 
+   */
+ MCR_Done:
+  *NumCommands=CommandIndex; /* Update number completed */
+
+  PushMCR(pDevice);
+
+#ifdef BLOCK 
+  /* Wait for all outstanding  to complete */
+    while ((Status=WaitForCompletion(pDevice,(unsigned long)100000,UBSEC_CIPHER_LIST))
+	   == UBSEC_STATUS_SUCCESS);
+    if (Status!=UBSEC_STATUS_TIMEOUT) /* We are nested, return success */
+      Status=UBSEC_STATUS_SUCCESS;
+ Error_Return:
+#else /* not BLOCKing */
+
+ Error_Return:  /* Label to make sure that IRQs are enabled. */
+#ifdef COMPLETE_ON_COMMAND_THREAD
+    ubsec_PollDevice(pDevice);  /* Try to complete some & cut down on ints */
+#endif
+
+#endif /* BLOCK */
+    OS_LeaveCriticalSection(pDevice,SaveConfig);
+
+#ifdef UBSEC_STATS
+		if (Status != UBSEC_STATUS_SUCCESS)
+			pDevice->Statistics.CryptoFailedCount++;
+#endif
+   return(Status);
+
+#else /* UBSEC_SSL_SUPPORT not defined */
+    return(UBSEC_STATUS_NO_DEVICE);
+#endif /* UBSEC_SSL_SUPPORT */
+
+}
+
+
+
+
+
diff -urNp linux-8030/drivers/addon/bcm/ubsstats.c linux-8040/drivers/addon/bcm/ubsstats.c
--- linux-8030/drivers/addon/bcm/ubsstats.c
+++ linux-8040/drivers/addon/bcm/ubsstats.c
@@ -0,0 +1,81 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubsinit.c:  ubsec initialization and cleanup modules.
+ */
+
+/*
+ * Revision History:
+ *
+ * 09/xx/99 SOR Created.
+ * 07/26/00 SOR Added Number of Key MCRs
+ */
+
+#include "ubsincl.h"
+
+/******************************************************************************
+ *
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+/*
+ * ubsstats.c:  ubsec Statistics information.
+ */
+/*
+ * Revision History:
+ *
+ * 08/09/00 SOR Created
+ */
+
+#include "ubsincl.h"
+
+
+/*
+ * Ubsec get statistical information function.
+ */
+UBSECAPI ubsec_Status_t 
+ubsec_GetStatistics(ubsec_DeviceContext_t Context,
+	      ubsec_Statistics_pt Dest)
+{
+
+#ifdef UBSEC_STATS
+DeviceInfo_pt pDevice;
+
+pDevice = (DeviceInfo_pt)Context;
+RTL_Memcpy(Dest,&pDevice->Statistics,sizeof(ubsec_Statistics_t));
+return(UBSEC_STATUS_SUCCESS);
+#else
+return(UBSEC_STATUS_INVALID_PARAMETER);
+#endif
+}
+
+
diff -urNp linux-8030/drivers/addon/bcm/ubsstruc.c linux-8040/drivers/addon/bcm/ubsstruc.c
--- linux-8030/drivers/addon/bcm/ubsstruc.c
+++ linux-8040/drivers/addon/bcm/ubsstruc.c
@@ -0,0 +1,671 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubsstruc.c: Internal structure manipulation routines.
+ */
+
+/*
+ * Revision History:
+ *
+ * 09/xx/1999 SOR Created.
+ * 12/02/1999 DWP Modified source to handle Big Endianness
+ * 12/03/1999 DWP Changed size AllocInfoSize to fix customer noticed bug
+ * 12/20/1999 SOR Modifications to do all static address computations at init time
+ * 07/07/2000 SOR Debug format change.
+ * 07/26/2000 SOR Virtual/Physical Memory manipulation modifications
+ *                NumberOfKeyMCRs addition.
+ * 04/03/2001 RJT Added support for CryptoNet device big-endian mode
+ * 04/18/2001 RJT Added support for CPU-DMA memory synchronization
+ * 10/09/2001 SRM 64 bit port
+ *
+ */
+
+#include "ubsincl.h"
+
+
+/*
+ * AllocDeviceInfo:
+ *
+ * Allocate and initialize the resources associated with a device.
+ * Return a pointer to the initialized device structure or zero
+ * if device initialization failed.
+ * Also physical addresses are calculated here.  We set up the physical addresses
+ * now because it is an expensive function to do at command time.
+ */
+DeviceInfo_pt
+AllocDeviceInfo(unsigned long DeviceID,int NumberOfCipherMCRs,int NumberOfKeyMCRs,OS_DeviceInfo_t OSContext)
+{
+
+  DeviceInfo_pt    pDevice = NULL_DEVICE_INFO;
+  UBS_UINT32       IListPhysicalAddress;
+  UBS_UINT32       OListPhysicalAddress;
+  UBS_UINT32       ContextPhysicalAddress;
+  UBS_UINT32       MCRPhysicalAddress;
+  MasterCommand_pt pMCR;
+  MasterCommand_pt pMCR_Temp = NULL;
+  unsigned long		   MCRListIndex;
+#ifdef CONTIG_MCR
+  unsigned int MCRAllocSize;
+  OS_MemHandle_t pContigMCRBaseHandle;
+#endif
+  OS_MemHandle_t pGeneric;
+
+  /* 
+   * Calculate the allocation size
+   * Note that crypto contexts are allocated as a block for all packets, 
+   * but key contexts  have one block for each packet
+   */
+  long ContextAllocSize = sizeof( PacketContext_t ) * MCR_MAXIMUM_PACKETS;
+  long KeyContextAllocSize = sizeof( KeyContext_t );
+
+#ifndef STATIC_F_LIST
+  int FragListAllocSize=sizeof(DataBufChainList_t)*MCR_MAXIMUM_PACKETS*UBSEC_MAX_FRAGMENTS;
+#endif
+  unsigned DInfoAllocSize = sizeof(DeviceInfo_t);
+  unsigned int i,j;
+
+  Dbg_Print(DBG_INITS,( "ubSec: %d-%d MCRs .\n",NumberOfCipherMCRs,NumberOfKeyMCRs));
+
+  /*
+   *  Allocate memory for main block
+   *  (Note later it is more efficient to allocate one big block
+   *  for all memory.
+   */
+  if ((pDevice = OS_AllocateMemory(DInfoAllocSize))
+      == NULL_DEVICE_INFO) {
+    Dbg_Print(DBG_FATAL,("ubSec:  unable to allocate memory for driver object <%d>\n",DInfoAllocSize));
+    return(NULL_DEVICE_INFO);
+  }
+
+  RTL_MemZero( pDevice, DInfoAllocSize ); 
+
+  /* This is a hokey way to fix the problem of 0 MCRs  but we need at least one
+     for a potential self test anyway. */
+  if (NumberOfCipherMCRs)
+    pDevice->NumberOfMCRs[UBSEC_CIPHER_LIST]=NumberOfCipherMCRs;
+  else
+    pDevice->NumberOfMCRs[UBSEC_CIPHER_LIST]=1;
+
+  if (NumberOfKeyMCRs)
+    pDevice->NumberOfMCRs[UBSEC_KEY_LIST]=NumberOfKeyMCRs;
+  else
+    pDevice->NumberOfMCRs[UBSEC_KEY_LIST]=1;
+
+  /* set up the master command record array */
+
+    /* Set up the number of MCR lists this device has */
+  pDevice->DeviceID=DeviceID;
+#ifdef UBSEC_PKEY_SUPPORT
+  pDevice->NumberOfMCRLists = UBSEC_IS_KEY_DEVICE(pDevice) ? 2 : 1;
+#else
+  pDevice->NumberOfMCRLists = 1;
+#endif
+  pDevice->Status=UBSEC_STATUS_SUCCESS;
+  pDevice->OsDeviceInfo = OSContext;
+
+  for(MCRListIndex=0; MCRListIndex< pDevice->NumberOfMCRLists ;MCRListIndex++) {
+  Dbg_Print(DBG_INITS,( "ubSec: Initializing MCR List %d.\n",MCRListIndex));
+
+#ifdef CONTIG_MCR
+  /* Allocate one big block of memory for the array of MCRs */
+  /* This means there is only one MemHandle for the whole list */
+  /* We'll do the sub allocations for each MCR later. */
+    MCRAllocSize = sizeof( MasterCommand_t ) * pDevice->NumberOfMCRs[MCRListIndex];
+    Dbg_Print(DBG_INITS_LIST,( "ubsec:  MCRAllocSize %d\n", MCRAllocSize ));
+    if ((pGeneric = OS_AllocateDMAMemory(pDevice,MCRAllocSize))
+	== NULL_MASTER_COMMAND) {
+      Dbg_Print(DBG_FATAL,( "ubsec:  unable to allocate a lot of memory for mcrs %d.\n",MCRAllocSize));
+      goto InitDeviceInfoFail;
+    }
+    pMCR = (MasterCommand_pt)  OS_GetVirtualAddress(pGeneric);
+    RTL_MemZero( pMCR, MCRAllocSize );
+    pMCR->MCRMemHandle = pContigMCRBaseHandle = pGeneric;
+    MCRPhysicalAddress=(UBS_UINT32)((unsigned char*)OS_GetPhysicalAddress(pGeneric) + MCR_DMA_MEM_OFFSET);
+#endif
+
+    for( i = 0; i < pDevice->NumberOfMCRs[MCRListIndex]; i++ ) {
+      Dbg_Print(DBG_INITS,( "ubSec: Initializing MCR %d.",i));
+
+#ifndef CONTIG_MCR
+      /* Do a separate memory allocation for each MCR */
+      /* Each MCR then gets its own MCRMemHandle, with
+	 an MCRMemHandleOffset of MCR_DMA_MEM_OFFSET. */
+      /* Now do the sub allocations for this device.  */
+      if ((pGeneric= OS_AllocateDMAMemory(pDevice,sizeof(*pMCR)))
+	  == NULL_MASTER_COMMAND) {
+	Dbg_Print(DBG_FATAL,( "ubsec:  unable to allocate all  mcrs %d.\n",i));
+	pDevice->NumberOfMCRs[MCRListIndex]=i; /* To free them up */
+	goto InitDeviceInfoFail;
+      }
+      pMCR = (MasterCommand_pt)  OS_GetVirtualAddress(pGeneric);
+      RTL_MemZero( pMCR, sizeof(*pMCR));
+      pMCR->MCRMemHandle=pGeneric;
+      pMCR->MCRMemHandleOffset = MCR_DMA_MEM_OFFSET;
+	  MCRPhysicalAddress=(UBS_UINT32)((unsigned char*)OS_GetPhysicalAddress(pGeneric) + MCR_DMA_MEM_OFFSET);
+#else /* CONTIG_MCR is defined; MCRs built as a contiguous array  */
+      /* There is only the one MemHandle for the entire MCR array */
+      /* We'll need to calculate an offset from it for each MCR   */
+      pMCR->MCRMemHandle = pContigMCRBaseHandle;
+      pMCR->MCRMemHandleOffset = (i * sizeof(*pMCR)) + MCR_DMA_MEM_OFFSET;
+#endif
+
+      if (i) {
+	/* Wrap around the pointer */
+	pMCR_Temp->pNextMCR=pMCR;
+      }
+      else {
+	pDevice->MCRList[MCRListIndex]=pMCR; /* First one */
+      }
+    /* Assume the last. It will be eventually */
+      pMCR->pNextMCR=pDevice->MCRList[MCRListIndex];
+      pMCR_Temp=pMCR; /* For next loop through */
+
+      /* We'll save the MCRPhysicalAddress here. We'll pre-byteswap     */
+      /* the address value (if the CPU is big-endian). This will        */
+      /* eliminate the need to swap bytes (during run time) when we     */
+      /* push this MCR.                                                 */
+      /* Even though the value lives in CTRLMEM, its swappability is    */
+      /* determined by the CPU-PCI endianess match (not CPU-CTRLMEM).   */
+      /* When the MCR gets pushed, this pointer is simply read from     */
+      /* here and written to the MCRn (PCI) register without using      */
+      /* any CPU-CTRLMEM macros (for maximum runtime performance).      */
+      /* So we'll pre-adjust its required endianess here.               */
+      /*                                                                */
+      /* This treatment applies only to pMCR->MCRPhysicalAddress, as    */
+      /* it is the only physical address written to a device register   */
+      /* by the CPU. All other physical addresses are read from memory  */
+      /* by the CryptoNet device (during PCI bus master DMA accesses).  */
+
+      pMCR->MCRPhysicalAddress = CPU_TO_PCI_LONG(MCRPhysicalAddress);
+
+      pMCR->MCRState=0;
+      pMCR->NumberOfPackets=0;
+      pMCR->Index=i;
+
+      if(!MCRListIndex) {
+      Dbg_Print(DBG_INITS,( " Cipher-C"));
+	/* only allocate Cipher ContextList for MCR1 */
+	if ((pGeneric = OS_AllocateDMAMemory(pDevice,ContextAllocSize)) ==
+	    NULL_PACKET_CONTEXT)
+	  goto InitDeviceInfoFail;
+	pMCR->ContextList =  (PacketContext_t *)OS_GetVirtualAddress(pGeneric);
+	RTL_MemZero(pMCR->ContextList, ContextAllocSize ); 
+	pMCR->ContextListHandle[0]=pGeneric;
+	/* Save physical address */
+	ContextPhysicalAddress=OS_GetPhysicalAddress(pMCR->ContextListHandle[0]); 
+	Dbg_Print(DBG_INITS_LIST,("MCRListIndex: %d CryptC-Physical Addrs:  MCR[%08x] Context[%08x]\n",
+			  MCRListIndex,
+			  PCI_TO_CPU_LONG( pMCR->MCRPhysicalAddress ),
+			  ContextPhysicalAddress));
+    /* 
+     * We want to fix up the physical addresses of static memory locations
+     * so as not to do the calculation at runtime.
+     */
+	for (j=0; j <  MCR_MAXIMUM_PACKETS; j++){
+	  pMCR->ContextList[j].PhysicalAddress=
+	    CPU_TO_CTRL_LONG(ContextPhysicalAddress);
+	  ContextPhysicalAddress+=(sizeof( PacketContext_t));
+	}
+      } /* crypto MCR */
+      else {
+	/* only allocate Key ContextList for MCR2 */
+	Dbg_Print(DBG_INITS,( " Key-C "));
+	for (j=0; j <  MCR_MAXIMUM_PACKETS; j++){
+	  if ((pGeneric = OS_AllocateDMAMemory(pDevice,KeyContextAllocSize)) ==
+	      NULL_KEY_CONTEXT)
+	    goto InitDeviceInfoFail;
+	  pMCR->ContextListHandle[j]=pGeneric;
+	  pMCR->KeyContextList[j]=(KeyContext_t *)OS_GetVirtualAddress(pMCR->ContextListHandle[j]); /* Get Virtual address */
+	/* Save physical address */
+	  ContextPhysicalAddress=OS_GetPhysicalAddress(pMCR->ContextListHandle[j]); 
+	  RTL_MemZero(pMCR->KeyContextList[j], KeyContextAllocSize ); 
+	  Dbg_Print(DBG_INITS_LIST,("MCRListIndex: %d MCR %d  KeyC-Physical Addrs:  MCR[%08x] KeyContext[%08x]\n",
+			    MCRListIndex,pMCR->Index,
+			    PCI_TO_CPU_LONG(pMCR->MCRPhysicalAddress),
+			    ContextPhysicalAddress)); 
+
+    /* 
+     * We want to fix up the physical addresses of static memory locations
+     * so as not to do the calculation at runtime.
+     */
+	  pMCR->KeyContextList[j]->PhysicalAddress=
+	    CPU_TO_CTRL_LONG(ContextPhysicalAddress);
+	}
+      } /* key MCR */
+
+      Dbg_Print(DBG_INITS,( " Frag "));
+#ifndef STATIC_F_LIST
+      /* The Fragment Descriptor Lists will be built outside of each MCR */
+      pGeneric = (DataBufChainList_pt) OS_AllocateDMAMemory(pDevice,FragListAllocSize);
+      if (pGeneric == (void *) 0)
+	goto InitDeviceInfoFail;
+      pMCR->InputFragmentList = (DataBufChainList_pt) OS_GetVirtualAddress(pGeneric);
+      RTL_MemZero(pMCR->InputFragmentList, FragListAllocSize ); 
+      pMCR->InputFragmentListHandle=pGeneric;
+      if ((pGeneric= (DataBufChainList_pt) OS_AllocateDMAMemory(pDevice,FragListAllocSize))
+	  == (void *)0)
+	goto InitDeviceInfoFail;
+
+      pMCR->OutputFragmentList=(DataBufChainList_pt) OS_GetVirtualAddress(pGeneric);
+      RTL_MemZero(pMCR->OutputFragmentList,FragListAllocSize ); 
+      pMCR->OutputFragmentListHandle=pGeneric;
+    /* Now set up the physical addresses of the fragment descriptor list */
+    /* First get the base physical addresses. */
+      IListPhysicalAddress=OS_GetPhysicalAddress(pMCR->InputFragmentListHandle); /* Save physical address */
+      OListPhysicalAddress=OS_GetPhysicalAddress(pMCR->OutputFragmentListHandle); /* Save physical address */
+#else /* STATIC_F_LIST is defined */
+      /* The fragment lists are inside each MCR (statically allocated). */
+      /* pMCR->MCRPhysicalAddress was stored in CTRLMEM using the     */
+      /* CPU_TO_PCI_LONG macro. Since we need the address for numerical  */
+      /* calculations, we need to use the PCI_TO_CPU_LONG macro here. */
+      IListPhysicalAddress = PCI_TO_CPU_LONG(pMCR->MCRPhysicalAddress) +
+	(UBS_UINT32)(&pMCR->InputFragmentList[0])-(UBS_UINT32)pMCR-
+	MCR_DMA_MEM_OFFSET;
+      OListPhysicalAddress = PCI_TO_CPU_LONG(pMCR->MCRPhysicalAddress) +
+	(UBS_UINT32)(&pMCR->OutputFragmentList[0])-(UBS_UINT32)pMCR-
+	MCR_DMA_MEM_OFFSET;
+#endif /* STATIC_F_LIST */
+      /* Here with IListPhysicalAddress and OListPhysicalAddress set
+	 to the beginning of the Fragment Descriptor lists */
+      /* Now fixup (pre-swap) the input and outputlist PhysicalAddress */
+      for (j=0; j < (MCR_MAXIMUM_PACKETS*UBSEC_MAX_FRAGMENTS); j++) {
+	pMCR->InputFragmentList[j].PhysicalAddress=
+	  CPU_TO_CTRL_LONG(IListPhysicalAddress);
+	pMCR->OutputFragmentList[j].PhysicalAddress=
+	  CPU_TO_CTRL_LONG(OListPhysicalAddress);
+	Dbg_Print(DBG_INITS_LIST,("MCRListIndex: %d MCR-%d, I-Frag-%d Physical Addrs:%08x, O-Frag-%d Physical Addrs:%08x\n",
+			    MCRListIndex,pMCR->Index,j,
+			    IListPhysicalAddress,j,
+			    OListPhysicalAddress));
+	IListPhysicalAddress+=sizeof(DataBufChainList_t);
+	OListPhysicalAddress+=sizeof(DataBufChainList_t);
+      }
+#ifdef CONTIG_MCR    
+      pMCR++;
+      MCRPhysicalAddress+=sizeof(*pMCR); /* non-swapped pointer */
+#endif
+      Dbg_Print(DBG_INITS,( " OK\n"));
+    } /* for each MCR in current MCRList */
+
+  /* Initialize the working pointers */
+    pDevice->NextFreeMCR[MCRListIndex]=pDevice->MCRList[MCRListIndex];
+    pDevice->NextDeviceMCR[MCRListIndex]=pDevice->MCRList[MCRListIndex];
+    pDevice->NextDoneMCR[MCRListIndex]=pDevice->MCRList[MCRListIndex];
+  Dbg_Print(DBG_INITS,( "ubSec: NextFreeMCR[%d]=0x%08X\n",MCRListIndex,pDevice->MCRList[MCRListIndex]));
+  Dbg_Print(DBG_INITS,( "ubSec: NextDeviceMCR[%d]=0x%08X\n",MCRListIndex,pDevice->MCRList[MCRListIndex]));
+  Dbg_Print(DBG_INITS,( "ubSec: NextDoneMCR[%d]=0x%08X\n",MCRListIndex,pDevice->MCRList[MCRListIndex]));
+  } /* for(MCRListIndex=0 .. */
+
+  Dbg_Print(DBG_INITS,( "ubSec: Alloc Device info - init struc done\n"));
+  pDevice->SelfTestMemArea=(unsigned char *)0;
+
+  if ((pGeneric= OS_AllocateDMAMemory(pDevice,TEST_DATA_SIZE)) == 0) {
+    Dbg_Print(DBG_FATAL,( "ubsec:  unable to allocate memory for BUDs\n"));
+    /* Not a fatal condition if we get this far */
+  }
+
+  pDevice->SelfTestMemArea= (unsigned char *)  OS_GetVirtualAddress(pGeneric);
+  pDevice->SelfTestMemAreaHandle= (unsigned char *)  pGeneric;
+
+  Dbg_Print(DBG_INITS,( "ubSec: Device struc initialized\n"));
+  return( pDevice );
+
+ InitDeviceInfoFail:
+  Dbg_Print(DBG_INITS,( "ubSec: Device Struc Alloc failed\n"));
+  FreeDeviceInfo(pDevice);
+  return(NULL_DEVICE_INFO);
+} /* end of AllocDeviceInfo() */
+
+
+
+
+/*
+ * Free all resources held by a device info type structure.
+ *
+ * This can be called during initialization so checks must
+ * be done before memory is freed.
+ */
+void FreeDeviceInfo(DeviceInfo_pt pDevice )
+{
+  unsigned long 		   i,j;
+  unsigned long              MCRListIndex;
+  MasterCommand_pt pMCR;
+#ifndef CONTIG_MCR
+  MasterCommand_pt pMCR_temp;
+#endif
+
+  Dbg_Print(DBG_INITS,( "ubSec: Free Device Info "));
+ 
+  /* Make sure that the interrupts are disabled */
+  UBSEC_DISABLE_INT(pDevice);
+  if( pDevice != NULL_DEVICE_INFO)     
+    for(MCRListIndex=0; MCRListIndex< pDevice->NumberOfMCRLists ;MCRListIndex++) {
+      if( pDevice->MCRList[MCRListIndex] != NULL_MASTER_COMMAND) {
+	for( i = 0,pMCR=pDevice->MCRList[MCRListIndex]; i < pDevice->NumberOfMCRs[MCRListIndex]; i++ ) {
+	  /* for key MCRs, context list is an array of handles, but for crypto 
+	     MCRs it's just one handle */
+	  if (MCRListIndex) {
+	    for ( j=0; j<MCR_MAXIMUM_PACKETS; j++) {
+	      if  (pMCR->ContextListHandle[j])
+		OS_FreeDMAMemory( pMCR->ContextListHandle[j],
+				  sizeof(KeyContext_t));
+	    } 
+	  }
+	  else  {
+	      if  (pMCR->ContextListHandle[0])
+		OS_FreeDMAMemory( pMCR->ContextListHandle[0],(sizeof(PacketContext_t)*MCR_MAXIMUM_PACKETS));
+	  }
+#ifndef STATIC_F_LIST
+	  if (pMCR->InputFragmentList != NULL_DATA_CHAIN)
+	    OS_FreeDMAMemory(pMCR->InputFragmentListHandle,
+			     (sizeof(DataBufChainList_t)*
+			      MCR_MAXIMUM_PACKETS*UBSEC_MAX_FRAGMENTS));
+	  if (pMCR->OutputFragmentList != NULL_DATA_CHAIN)
+	    OS_FreeDMAMemory(pMCR->OutputFragmentListHandle,
+			     (sizeof(DataBufChainList_t)*
+			      MCR_MAXIMUM_PACKETS*UBSEC_MAX_FRAGMENTS));
+			     
+#endif
+#ifdef CONTIG_MCR
+	  pMCR=pMCR->pNextMCR;
+#else
+	  pMCR_temp=pMCR;
+	  pMCR=(MasterCommand_pt)pMCR->pNextMCR;
+	  OS_FreeDMAMemory(pMCR_temp->MCRMemHandle,sizeof(*pMCR));
+#endif
+	  }
+
+#ifdef CONTIG_MCR
+      OS_FreeDMAMemory( pDevice->MCRList[MCRListIndex]->MCRMemHandle,
+			(pDevice->NumberOfMCRs[MCRListIndex]*sizeof(*pMCR)));
+#endif
+	}
+} /* MCRListIndex for loop */
+
+  if (pDevice->SelfTestMemArea!=(unsigned char *)0) {
+    OS_FreeDMAMemory( pDevice->SelfTestMemAreaHandle,TEST_DATA_SIZE);
+  }
+
+  if (pDevice->ControlReg[0])
+    OS_UnMapIO(pDevice,(void*) pDevice->ControlReg[0] );
+  OS_FreeMemory(pDevice ,sizeof(*pDevice));
+
+  Dbg_Print(DBG_INITS,( "ubSec: Done!\n"));
+
+} /* end of FreeDeviceInfo() */
+
+
+
+/*
+ * SetupInputFragmentList: Setup the fragment list 
+ * This routine processes an input fragment list that was built outside
+ * the SRL. That list's info is put into the context and fragment list 
+ * (if multi-fragment) structures in the MCR structure, converted to 
+ * CryptoNet device format.
+ * Return error if failure.
+ */
+ubsec_Status_t
+SetupInputFragmentList(MasterCommand_pt  pMCR,
+		       Packet_pt pPacket,
+		       int NumSource,
+		       ubsec_FragmentInfo_pt SourceFragments)
+{
+  VOLATILE DataBufChainList_t *FragPtr, *NextFragPtr;
+  int NumFrags,FragNum;
+  int DataLength=0;
+  int PacketIndex;
+
+  Dbg_Print(DBG_CMD,( "ubsec: Num Input Frags %d \n",NumSource));
+
+  if (!(NumFrags=NumSource)) {
+    Dbg_Print(DBG_CMD,( "ubsec:  No Input fragments\n" ));
+    return(UBSEC_STATUS_INVALID_PARAMETER);
+  }
+
+  /* Sanity check.*/
+  if (NumFrags>(UBSEC_MAX_FRAGMENTS+1)) { 
+    Dbg_Print(DBG_CMD,( "ubsec:  Too Many Input fragments\n" ));
+    return(UBSEC_STATUS_INVALID_PARAMETER);
+  }
+
+
+  PacketIndex = pMCR->NumberOfPackets; 
+  /* Initialize the Fragment pointer. First is part of the context*/
+  FragPtr=(DataBufChainList_pt)&pPacket->InputHead;
+  pPacket->PacketLength=0;
+
+    /* Now create a device fragment list from those of the parameter fragments. */
+  for (FragNum=0 ;NumFrags-- ;FragNum++ ) {
+    FragPtr->DataAddress= CPU_TO_CTRL_LONG( (UBS_UINT32)(SourceFragments[FragNum].FragmentAddress) ); 
+    DataLength= SourceFragments[FragNum].FragmentLength;
+    FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+    pPacket->PacketLength += (unsigned short)DataLength;   /* Increment the total packet length. */
+
+    Dbg_Print(DBG_PACKET,( "ubsec:  FragI <%d,%d,%08x %08x>\n",
+			   FragNum, 
+			   DataLength, 
+			   CTRL_TO_CPU_LONG( FragPtr->DataAddress ), 
+			   FragPtr));
+      /* 
+       * The first fragment info case is a special case since
+       * it lives in the context structure.
+       * Subsequent fragment info (if multi-fragment) is placed in
+       * the InputFragmentList structure of the MCR.
+       *  1) If there are extra fragments we need to jump into
+       *  a new fragment list.
+       */
+    if (FragNum==0) {   
+      /* Processing the frag info that is part of the context structure */
+      if (NumFrags) { /* This is not the last fragment */
+	NextFragPtr=(DataBufChainList_pt)&pMCR->InputFragmentList[PacketIndex*(UBSEC_MAX_FRAGMENTS)];
+	FragPtr->pNext =NextFragPtr->PhysicalAddress;
+	FragPtr=NextFragPtr;
+      }
+      else /* Current fragment is the last fragment */
+	FragPtr->pNext = 0;
+    }
+    else { /* We are processing non-context frag info (multifragment) */
+      if (NumFrags) { /* The current fragment is not the last fragment */
+	FragPtr->pNext =FragPtr[1].PhysicalAddress;
+	FragPtr++;
+      }
+      else /* Current fragment is the last fragment */
+	FragPtr->pNext = 0;
+    }
+  } /* end of 'for each fragment' for-loop */
+
+#ifndef STATIC_F_LIST 
+  /* The input fragment descriptor list is not inside the MCR.   */
+  /* If just initialized, it needs to be synced separately.      */ 
+  if (NumSource > 1) {
+    Dbg_Print(DBG_FRAG_SYNC,( "ubsec: SetupInputFragmentList Sync %d Descriptors to Device (0x%08X,%d,%d)\n", NumSource-1,
+	      pMCR->InputFragmentListHandle,
+	      PacketIndex*(UBSEC_MAX_FRAGMENTS)*sizeof(DataBufChainList_t),
+	      (NumSource-1)*sizeof(DataBufChainList_t)));
+    OS_SyncToDevice(pMCR->InputFragmentListHandle,
+	    PacketIndex*(UBSEC_MAX_FRAGMENTS)*sizeof(DataBufChainList_t),
+	    (NumSource-1)*sizeof(DataBufChainList_t));
+  }
+#endif
+
+#if (UBS_CPU_ATTRIBUTE != UBS_CRYPTONET_ATTRIBUTE) 
+    /* fix up the packet length endianess in DMA control memory */
+  pPacket->PacketLength = CPU_TO_CTRL_SHORT( pPacket->PacketLength );
+#endif 
+
+  return(UBSEC_STATUS_SUCCESS);
+} /* end of SetupInputFragmentList() */
+
+
+
+/*
+ * SetupOutputFragmentList: Setup the output fragment list 
+ * This routine processes an output fragment list that was built outside
+ * the SRL. That list's info is put into the context and fragment list 
+ * (if multi-fragment) structures in the MCR structure, converted to 
+ * CryptoNet device format.
+ * Return error if failure.
+ */
+ubsec_Status_t
+SetupOutputFragmentList(MasterCommand_pt  pMCR,
+			Packet_pt pPacket,
+			int NumFrags,
+			ubsec_FragmentInfo_pt DestinationFragments,
+			ubsec_FragmentInfo_pt pExtraFragment)
+{
+  VOLATILE DataBufChainList_t *FragPtr, *NextFragPtr;
+  int FragNum;
+  int DataLength;
+  int PacketIndex;
+
+  /* Sanity check for excessively long output fragment list */
+  if ( pExtraFragment && pExtraFragment->FragmentLength && \
+      (NumFrags>UBSEC_MAX_FRAGMENTS) ) { 
+    Dbg_Print(DBG_PACKET,( "ubsec:  Too Many Output fragments\n" ));
+    return(UBSEC_STATUS_INVALID_PARAMETER);
+  }
+  else if (NumFrags>(UBSEC_MAX_FRAGMENTS+1)) { 
+    Dbg_Print(DBG_PACKET,( "ubsec:  Too Many Output fragments\n" ));
+    return(UBSEC_STATUS_INVALID_PARAMETER);
+  }
+
+  PacketIndex = pMCR->NumberOfPackets; 
+  Dbg_Print(DBG_PACKET,( "ubsec: Num Output Frags %d \n",NumFrags));
+
+    /* First fragment is part of the context. */
+  FragPtr=(DataBufChainList_pt)&pPacket->OutputHead; 
+
+    /* Now add them all */
+  for (FragNum=0 ;NumFrags-- ;FragNum++ ) {
+    FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)(DestinationFragments[FragNum].FragmentAddress) ); 
+    DataLength = DestinationFragments[FragNum].FragmentLength; 
+    FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+
+#ifdef UBSDBG
+      /* Sanity check debug info for conditions that will hang the chip. */
+    if ( (CTRL_TO_CPU_LONG( FragPtr->DataAddress )) & 0x03) {
+      Dbg_Print(DBG_FATAL,("ubsec:  ################INVALID OUTPUT ADDRESS %08x\n", CTRL_TO_CPU_LONG(FragPtr->DataAddress)));
+      return(UBSEC_STATUS_INVALID_PARAMETER);
+    }
+#if 0
+/* Causes problems with less than 4 byte packets */
+    if ((DataLength) & 0x03) {
+      Dbg_Print(DBG_FATAL,("ubsec:  ################INVALID OUTPUT LENGTH %08x\n", DataLength)); 
+      return(UBSEC_STATUS_INVALID_PARAMETER);
+    A
+}
+#endif
+#endif 
+
+    Dbg_Print(DBG_PACKET,( "ubsec: FragO <%d, %d, %08x, %08x>\n",
+			   FragNum, DataLength, CTRL_TO_CPU_LONG( FragPtr->DataAddress ), FragPtr));
+
+      /* 
+       * First case is a special case since fragment is inside pPacket struct
+       * If there are additional fragments we need to link into the 
+       * OutputFragmentList belonging to the current pPacket.
+       */
+    if (FragNum==0) {   
+      /* We are working on the fragment descriptor inside pPacket struct */
+      /* See if there are more fragments to build */
+      if ((NumFrags)) { /* need to link into current OutputFragmentList */
+	NextFragPtr=(DataBufChainList_pt)&pMCR->OutputFragmentList[PacketIndex*(UBSEC_MAX_FRAGMENTS)];
+	FragPtr->pNext =NextFragPtr->PhysicalAddress;
+	FragPtr=NextFragPtr;
+      }
+      else /* Only the one frag descriptor in the current pPacket struct */
+	FragPtr->pNext = 0;
+    }
+    else { /* We are already in the OutputFragmentList */
+      /* See if there are more fragments to build */
+      if ((NumFrags)) { /* point to next descriptor in list */
+	FragPtr->pNext =FragPtr[1].PhysicalAddress;
+	FragPtr++;
+      }
+      else /* last fragment descriptor, terminate the list (for now) */
+	FragPtr->pNext = 0;
+    }
+  }
+
+  /*
+   * If we are doing HMAC/authentication then we need to incorporate
+   * the ExtraFragment info into the output frag descriptor list.
+   * HMAC/authentication is indicated by a non-NULL pExtraFragment pointer.
+   * If pExtraFragment->FragmentLength == 0, then the output 
+   * length of the HMAC/auth frag is implied (fixed by CryptoNet chip design).
+   * In this case, the last regular frag descriptor's pNext pointer
+   * points directly to the extra fragment's data, NOT to the extra fragment 
+   * descriptor structure itself.
+   * Otherwise (if pExtraFragment->FragmentLength != 0), treat
+   * ExtraFragment as simply another fragment descriptor.
+   * Here with FragPtr pointing to last filled fragment descriptor,
+   * and Fragnum indicating the next (uninitialized) frag descriptor.
+   */
+  if (pExtraFragment) { /* There is an extra fragment descriptor */
+    if (pExtraFragment->FragmentLength==0) {
+      /* Make FragPtr->pNext point to the extra fragment data buffer,
+	 NOT the extra fragment descriptor itself */
+      FragPtr->pNext = CPU_TO_CTRL_LONG(pExtraFragment->FragmentAddress );
+      if ( (int) (CTRL_TO_CPU_LONG( FragPtr->pNext )) & 0x03) {
+	Dbg_Print(DBG_PACKET,("ubsec:  ################INVALID HMAC ADDRESS %08x\n",FragPtr->pNext));
+	return(UBSEC_STATUS_INVALID_PARAMETER);
+      }
+    }
+    else { /* add the extra frag descriptor to the descriptor list */
+      if (FragNum==1) {   
+	NextFragPtr=(DataBufChainList_pt)&pMCR->OutputFragmentList[PacketIndex*(UBSEC_MAX_FRAGMENTS)];
+	FragPtr->pNext =NextFragPtr->PhysicalAddress;
+	FragPtr=NextFragPtr;
+      }
+      else {
+	FragPtr->pNext =FragPtr[1].PhysicalAddress;
+	FragPtr++;
+      }
+      /* Here with FragPtr pointing to the added (last) extra frag     */
+      /* descriptor. Increment NumFrags for OS_SyncToDevice() below    */
+      NumFrags++; 
+      FragPtr->DataAddress = CPU_TO_CTRL_LONG( (UBS_UINT32)(pExtraFragment->FragmentAddress) );
+      DataLength = pExtraFragment->FragmentLength;
+      FragPtr->DataLength = CPU_TO_CTRL_SHORT( (unsigned short)DataLength );
+      FragPtr->pNext = 0;
+    }
+  } /* if(pExtraFragment) */
+
+#ifndef STATIC_F_LIST 
+  /* The output fragment descriptor list is not inside the MCR.  */
+  /* If just initialized, it needs to be synced separately.      */ 
+  if (NumFrags > 1) {
+    Dbg_Print(DBG_FRAG_SYNC,( "ubsec: SetupOutputFragmentList Sync %d Descriptors to Device (0x%08X,%d,%d)\n", NumFrags-1,
+	      pMCR->OutputFragmentListHandle,
+	      PacketIndex*(UBSEC_MAX_FRAGMENTS)*sizeof(DataBufChainList_t),
+	      (NumFrags-1)*sizeof(DataBufChainList_t)));
+    OS_SyncToDevice(pMCR->OutputFragmentListHandle,
+	    PacketIndex*(UBSEC_MAX_FRAGMENTS)*sizeof(DataBufChainList_t),
+	    (NumFrags-1)*sizeof(DataBufChainList_t));
+  }
+#endif
+
+  return(UBSEC_STATUS_SUCCESS);
+} /* end of SetupOutputFragmentList() */
diff -urNp linux-8030/drivers/addon/bcm/ubsstruc.h linux-8040/drivers/addon/bcm/ubsstruc.h
--- linux-8030/drivers/addon/bcm/ubsstruc.h
+++ linux-8040/drivers/addon/bcm/ubsstruc.h
@@ -0,0 +1,123 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubsstruc.h:  ubsec internal structure definition header file
+ */
+
+/*
+ * Revision History:
+ *
+ * 09/xx/1999 SOR Created.
+ * 02/05/2001 PW Added code for key self test 
+ * 07/16/2001 RJT Added support for BCM5821
+ * 10/09/2001 SRM 64 bit port
+ */
+
+#ifndef _UBSSTRUC_H_
+#define _UBSSTRUC_H_
+
+
+#define UBSEC_CIPHER_LIST 0
+#define UBSEC_KEY_LIST 1
+#define UBSEC_NUM_MCR_LISTS 2
+#define UBSEC_MAX_MCR_LISTS 2
+
+/* MCR statistics */
+#define NUM_MCR_REGS 2
+typedef struct MCRStat_s
+{
+UBS_UINT32 no_free_mcr_ret;
+UBS_UINT32 num_packets_stat[MCR_MAXIMUM_PACKETS];
+UBS_UINT32 push_mcr_stat[NUM_MCR_REGS];
+UBS_UINT32 mcr_full_stat[NUM_MCR_REGS];
+}MCRStat_t;
+
+/*
+ * Device Information structure. This contains all the state information
+ * for the device. The device context points to this structure.
+ */
+typedef struct DeviceInfo_s {
+  /* housekeeping information */
+  UBS_UINT32 DeviceID;      /* Type of device */
+  unsigned long BaseAddress;   /* Physical base address 	   	    */
+  unsigned int IRQ;            /* IRQ associated with device. 	   	    */
+  ubsec_Status_t Status;
+  VOLATILE UBS_UINT32 *ControlReg[UBSEC_MAXREGISTERS];/* device register */
+  unsigned int NumberOfMCRs[UBSEC_MAX_MCR_LISTS];   /* Number of MCRs allocated to this device.  */
+  MasterCommand_pt  MCRList[UBSEC_MAX_MCR_LISTS];        /* MCR List, 0 for MCR1, 1 for MCR2  */
+  MasterCommand_pt  NextFreeMCR[UBSEC_MAX_MCR_LISTS];    /* Next MCR to fill 	  	    */
+  MasterCommand_pt  NextDeviceMCR[UBSEC_MAX_MCR_LISTS];  /* Next MCR to push to device. 	    */
+  MasterCommand_pt  NextDoneMCR[UBSEC_MAX_MCR_LISTS];    /* Next MCR to be checked for        */
+  VOLATILE int IRQEnabled;              /* Interrupt enabled indicator 	    */
+  UBS_UINT32 InCriticalSection;      /* Primitive (single thread) mutex   */
+  UBS_UINT32 NumberOfMCRLists;       /* Number of MCR Lists in this device */
+  UBS_UINT32 IntEnableMask;          /* Interrupt mask values */
+  UBS_UINT32 IntAckMask;             /* Interrupt mask values */
+  UBS_UINT32 ResetConfig;            /* DMA Control reg state after reset */
+  unsigned short InterruptSuppress;     /* Interrupt Suppress setting for MCR Flags field */
+  unsigned short Reserved;              /* To maintain alignment */
+  unsigned char *SelfTestMemArea;       /* Test memory area */
+  OS_MemHandle_t SelfTestMemAreaHandle; /* Memory area handle */
+
+  void (*SelfTestCallBack)(unsigned long Context,ubsec_Status_t Result);  /* Test user callback */
+  unsigned long SelfTestContext; /* Self test user context */
+
+  void (*KeySelfTestCallBack)(unsigned long Context,ubsec_Status_t Result);  /* Test user callback */
+  unsigned long KeySelfTestContext; /* Self test user context */
+
+  OS_DeviceInfo_t OsDeviceInfo;	/* pointer to structure containing info specific to an OS */
+#ifdef UBSEC_STATS
+  ubsec_Statistics_t Statistics;
+#endif	
+#ifdef DVT
+  UBS_UINT32 DVTOptions;
+#endif
+#ifdef MCR_STATS
+  MCRStat_t MCRstat;
+#endif 
+} DeviceInfo_t,*DeviceInfo_pt;
+
+#define NULL_DEVICE_INFO (DeviceInfo_pt) 0
+
+/*
+ * Sizes for ubs Bud
+ */
+#define TEST_CIPHER_BLOCK_SIZE 64
+#define TEST_AUTH_DATA_SIZE 32
+#define TEST_DATA_SIZE (3*(TEST_CIPHER_BLOCK_SIZE+TEST_AUTH_DATA_SIZE))
+
+/* need a array of 64 char (512 bits) for each parameter N G UserX Y and X, so the totoal length
+   is 64 * 5 = 320 
+*/
+#define TEST_KEY_BLOCK_SIZE 64
+#define TEST_KEY_OFFSET_SIZE 128
+#define KEY_TEST_DATA_SIZE 2048 
+
+#define FLUSH_ONLY_PUSHED 0
+#define FLUSH_ALL         1
+
+
+#endif  /* _UBSSTRUC_H_ */
+
diff -urNp linux-8030/drivers/addon/bcm/ubssys.h linux-8040/drivers/addon/bcm/ubssys.h
--- linux-8030/drivers/addon/bcm/ubssys.h
+++ linux-8040/drivers/addon/bcm/ubssys.h
@@ -0,0 +1,167 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubssys.h:  ubsec operating system dependencies
+ */
+
+/*
+ * Revision History:
+ *
+ * 09/xx/1999 SOR Created.
+ * 12/02/1999 DWP Added macros to swap bytes for Little and Big endian hosts
+ * 12/15/1999 SOR Added bsd include file
+ * 04/03/2001 RJT Added support for CryptoNet device big-endian mode
+ * 04/13/2001 RJT Added support for CPU-DMA memory synchronization
+ * 07/16/2001 RJT Added support for BCM5821
+ * 10/09/2001 SRM 64 bit port.
+ */
+
+
+#ifndef _UBSSYS_H_
+#define _UBSSYS_H_
+
+
+#if defined(UBSEC_5805)
+  #if (defined(UBSEC_5820) || defined(UBSEC_582x))
+    ERROR - Multiple driver types simultaneously defined 
+  #endif
+#elif defined(UBSEC_5820)
+  #if (defined(UBSEC_5805) || defined(UBSEC_582x))
+    ERROR - Multiple driver types simultaneously defined 
+  #endif
+#elif defined(UBSEC_582x)
+  #if (defined(UBSEC_5805) || defined(UBSEC_5820))
+    ERROR - Multiple driver types simultaneously defined 
+  #endif
+#endif
+
+
+#ifdef UBS_PLATFORM_H_FILE
+  #include UBS_PLATFORM_H_FILE
+#else
+  #ifdef LINUX_DEVICE
+  #define UBS_UINT32 unsigned int
+  #include "ubslinux.h"
+  #endif
+  #ifdef WIN32_DEVICE
+  #include "ubsnt.h"
+  #endif
+  #ifdef BSD_DEVICE
+  #include "ubsbsd.h"
+  #endif
+  #ifdef VXWORKS_DEVICE 
+  #include "ubsvxworks.h"
+  #endif
+  #ifdef SOLARIS_DEVICE
+  #include "ubssolaris.h"
+  #endif
+#endif
+
+#ifndef UBS_IOWR 
+#define UBS_IOWR(magic,no,arg) (no)
+#endif
+
+#ifndef OS_EnterCriticalSection
+  #define OS_EnterCriticalSection(x,y) 0
+#endif
+
+#ifndef OS_TestCriticalSection
+  #define OS_TestCriticalSection(x,y) 0
+#endif
+
+#ifndef OS_SyncToDevice
+  #define OS_SyncToDevice(x,y,z)
+#endif
+
+#ifndef OS_SyncToCPU
+  #define OS_SyncToCPU(x,y,z)
+#endif
+
+#ifndef UBS_UINT32
+#define UBS_UINT32 unsigned int
+#endif
+
+#define BYTESWAPSHORT(sval) ((((sval)&0xff00)>>8)+(((sval)&0xff)<<8))
+#define BYTESWAPLONG(lval) (((BYTESWAPSHORT((lval)>>16)))+((BYTESWAPSHORT((lval)&0xffff)<<16)))
+
+
+#if defined(UBS_ENABLE_SWAP_KEY)
+  #undef UBS_ENABLE_SWAP_KEY
+#endif
+
+#ifndef VOLATILE
+#define VOLATILE volatile
+#endif
+
+
+#if (UBS_CPU_ATTRIBUTE != UBS_CRYPTONET_ATTRIBUTE) 
+
+  #define CPU_TO_CTRL_LONG( lval )  (BYTESWAPLONG( (UBS_UINT32)(lval) ))
+  #define CTRL_TO_CPU_LONG( lval )  (BYTESWAPLONG( (UBS_UINT32)(lval) ))
+  #define CPU_TO_CTRL_SHORT( sval ) (BYTESWAPSHORT( (unsigned short)(sval) ))
+  #define CTRL_TO_CPU_SHORT( sval ) (BYTESWAPSHORT( (unsigned short)(sval) ))
+
+  #define SYS_TO_BE_LONG( lval )  ((UBS_UINT32)(lval))
+
+  #if !defined(UBS_OVERRIDE_LONG_KEY_MODE)
+    #define UBS_ENABLE_KEY_SWAP
+  #endif
+
+#else /* CPU and CryptoNet device have the same endianess */
+
+  #define CPU_TO_CTRL_LONG( lval )  ((UBS_UINT32)(lval))
+  #define CTRL_TO_CPU_LONG( lval )  ((UBS_UINT32)(lval))
+  #define CPU_TO_CTRL_SHORT( sval ) ((unsigned short)(sval))
+  #define CTRL_TO_CPU_SHORT( sval ) ((unsigned short)(sval))
+
+  #if defined(UBS_OVERRIDE_LONG_KEY_MODE)
+    #define UBS_ENABLE_KEY_SWAP
+  #endif
+
+  #define SYS_TO_BE_LONG( lval )  (BYTESWAPLONG((UBS_UINT32)(lval)))
+
+#endif /* CPU and CTRLMEM endianess considerations */
+
+#if (UBS_CPU_ATTRIBUTE == UBS_BIG_ENDIAN) 
+
+  /* byteswap for runtime (little endian) CryptoNet register accesses */
+  #define CPU_TO_PCI_LONG( lval )  (BYTESWAPLONG( (UBS_UINT32)(lval) ))
+  #define PCI_TO_CPU_LONG( lval )  (BYTESWAPLONG( (UBS_UINT32)(lval) ))
+
+#else 
+
+  /* CPU (and CryptoNet registers) are both little endian, no byteswap needed */
+  #define CPU_TO_PCI_LONG( lval )  ((UBS_UINT32)(lval))
+  #define PCI_TO_CPU_LONG( lval )  ((UBS_UINT32)(lval))
+
+#endif /* CPU and CryptoNet endianess considerations */
+
+#define LOW_BYTE(x) (x&0xff)
+#define HIGH_BYTE(x) (((x)&0xff00)>>8)
+
+#define ROUNDUP_TO_32_BIT(n) ((n+31)&(~31)) 
+
+#endif  /* _UBSSYS_H_ */
+
diff -urNp linux-8030/drivers/addon/bcm/ubstest.c linux-8040/drivers/addon/bcm/ubstest.c
--- linux-8030/drivers/addon/bcm/ubstest.c
+++ linux-8040/drivers/addon/bcm/ubstest.c
@@ -0,0 +1,420 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubstest.c: Ubsec Bring  up Diagnostics routines
+ */
+
+/*
+ * Revision History:
+ *
+ * 01/31/2000 SOR Created.
+ * 04/03/2001 RJT Added support for CryptoNet device big-endian mode
+ * 04/23/2001 RJT Added support for CPU-DMA memory synchronization
+ * 07/30/2001 DPA Changed test from 3DES to DES
+ */
+
+#include "ubsincl.h"
+
+#ifndef ASYNC
+static void callback(unsigned long PacketContext,ubsec_Status_t Result);
+#endif
+#define UBS_SELFTEST_MD5   /* Undefine for SHA1 authentication */
+
+static unsigned char InitialVector[]={1, 2, 3, 4, 5, 6, 7, 8 };
+
+static unsigned char CryptKey[]={
+    1,  2,  3,  4,  5,  6,  7,  8, 
+    9, 10, 11, 12, 13, 14, 15, 16, 
+    17, 18, 19, 20, 21, 22, 23, 24
+  };
+
+static unsigned char MacKey[]=   { 
+     1,  2,  3,  4,  5,  6,  7,  8, 
+     9, 10, 11, 12, 13, 14, 15, 16, 
+    17, 18, 19, 20, 21, 22, 23, 24,
+    25, 26, 27, 28, 29, 30, 31, 32,
+    33, 34, 35, 36, 37, 38, 39, 40,
+    41, 42, 43, 44, 45, 46, 47, 48,
+    49, 50, 51, 52, 53, 54, 55, 56, 
+    57, 58, 59, 60, 61, 62, 63, 64
+  };
+
+ 
+/* Input data to the encryption function. */
+static unsigned char InputData[TEST_CIPHER_BLOCK_SIZE]= {
+ 0x30 ,0x31 ,0x32 ,0x33 ,0x34 ,0x35 ,0x36 ,0x37,
+ 0x38 ,0x39 ,0x0a ,0x61 ,0x62 ,0x63 ,0x64 ,0x65,  
+ 0x66 ,0x67 ,0x68 ,0x69 ,0x6a ,0x0a ,0x6b ,0x6c,
+ 0x6d ,0x6e ,0x6f ,0x70 ,0x71 ,0x72 ,0x73 ,0x74,
+ 0x0a ,0x75 ,0x76 ,0x77 ,0x78 ,0x79 ,0x7a ,0x2e,
+ 0x2e ,0x2e ,0x2e ,0x0a ,0x41 ,0x42 ,0x43 ,0x44,
+ 0x45 ,0x46 ,0x47 ,0x48 ,0x49 ,0x4a ,0x0a ,0x4b,
+ 0x4c ,0x4d ,0x4e ,0x4f ,0x50 ,0x51 ,0x52 ,0x53
+};
+
+
+/* Encoded data value - the golden data */
+static unsigned char EncodedData[TEST_CIPHER_BLOCK_SIZE]= {
+0x6C ,0x12 ,0x11 ,0x49 ,0x33 ,0xC7 ,0xD3 ,0x64,  
+0xD3 ,0x03 ,0x56 ,0xB6 ,0x64 ,0x0A ,0xEC ,0xF0,
+0x68 ,0xCD ,0xCC ,0x77 ,0xD1 ,0x4E ,0x9A ,0xCC,
+0x9C ,0xAC ,0x5D ,0x78 ,0x1A ,0x10 ,0x63 ,0x42,
+0xCC ,0xE0 ,0x46 ,0xEB ,0x7C ,0x8F ,0x06 ,0xCC,
+0xE7 ,0x3A ,0x2A ,0x4F ,0x04 ,0xD2 ,0xF7 ,0x85,
+0xF9 ,0xF5 ,0xB7 ,0xE8 ,0xFC ,0xEB ,0x3D ,0x01,
+0xF6 ,0x35 ,0xD4 ,0xD0 ,0x2F ,0x48 ,0x44 ,0xB6
+};     
+
+#ifdef UBS_SELFTEST_MD5
+/* Authentication Info for MD5 authentication */
+static unsigned char AuthData[TEST_AUTH_DATA_SIZE] = {
+0xF4 ,0x2E ,0x0C ,0x27 ,0x98 ,0xD5 ,0x57 ,0x6D,
+0x8C ,0x5D ,0x2D ,0xF0 ,0x78 ,0xE3 ,0x3F ,0x92,
+0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00,
+0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00
+};
+#else
+/* Authentication Info for SHA1 authentication*/
+static unsigned char AuthData[TEST_AUTH_DATA_SIZE] = {
+0xB0 ,0x15 ,0xEC ,0x4E ,0x5C ,0x5E ,0x93 ,0x01 ,
+0x30 ,0x37 ,0xFD ,0x24 ,0x1C ,0xC4 ,0x41 ,0xA6 ,
+0x11 ,0xF5 ,0x0F ,0x06 ,0x00 ,0x00 ,0x00 ,0x00 , 
+0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00
+};
+#endif
+
+/*
+ * Static Prototype definitions.
+ */
+static ubsec_Status_t CompareCryptoResults(DeviceInfo_pt pDevice, unsigned char *pData);
+static void CryptoCallback(unsigned long PacketContext,ubsec_Status_t Result);
+
+
+/*
+ * ubsec_TestCryptoDevice
+ * 
+ * Perform testing on a ubsec device.
+ */
+ubsec_Status_t
+ubsec_TestCryptoDevice(ubsec_DeviceContext_t Ubsec_Context,void(*CompletionCallback)(unsigned long PacketContext,ubsec_Status_t Result),unsigned long CompletionContext)
+{
+  ubsec_CipherCommandInfo_t ubsec_commands[2]; /* One encode/one decode. */
+  ubsec_HMAC_State_t HMAC_State;
+  ubsec_FragmentInfo_t SourceFragments[2]; /* One for each command */
+  ubsec_FragmentInfo_t DestinationFragments[2]; /* One for each command */
+  unsigned char *pData;
+  ubsec_MemAddress_t PhysicalAddress;
+  int num_packets=1;
+  int i, Status;
+  UBS_UINT32 SaveConfig;
+  DeviceInfo_pt pDevice=(DeviceInfo_pt)Ubsec_Context;
+
+  Dbg_Print(DBG_TEST,("ubstest: crypto self-test..\n"));
+  /* 
+   * First reset the device and complete any pending requests.
+   */
+  ubsec_ResetDevice(Ubsec_Context);
+
+  /* First clear the Data areas. */
+  RTL_MemZero(ubsec_commands, sizeof(ubsec_commands));
+  if ((pData=pDevice->SelfTestMemArea)==(unsigned char *) 0)
+    return(UBSEC_STATUS_NO_RESOURCE);
+  RTL_MemZero(pData,TEST_DATA_SIZE);
+  
+  /* We assume here that the TEST_DATA_SIZE (defined in ubsec.h) bytes at     */
+  /* SelfTestMemAreaHandle are in contiguous physical memory. This assumption */
+  /* allows us to forego fragmentation, and to perform physical pointer math. */
+  /* SelfTestMemArea is an individually malloc'd buffer of TEST_DATA_SIZE     */
+  /* bytes, significantly smaller than the typical 4096-byte physical memory  */
+  /* page.                                                                    */
+
+  PhysicalAddress=(ubsec_MemAddress_t)(OS_GetPhysicalAddress(pDevice->SelfTestMemAreaHandle));
+  /* Set the fragments to point to the locations. */
+  SourceFragments[0].FragmentLength=TEST_CIPHER_BLOCK_SIZE;   
+  SourceFragments[0].FragmentAddress=PhysicalAddress; 
+  DestinationFragments[0].FragmentLength=TEST_CIPHER_BLOCK_SIZE;
+  DestinationFragments[0].FragmentAddress=PhysicalAddress+TEST_CIPHER_BLOCK_SIZE; 
+  SourceFragments[1]=DestinationFragments[0];  /* This is the input to the decode */
+  /* Final output should match the input. */
+  DestinationFragments[1].FragmentLength=TEST_CIPHER_BLOCK_SIZE; 
+  DestinationFragments[1].FragmentAddress=PhysicalAddress+(2*TEST_CIPHER_BLOCK_SIZE); 
+
+  /* Crypto data is usually a byte stream in network byte order,         */
+  /* (endianess does not apply). However, there may be external H/W      */
+  /* (like the Galileo GT64120) which performs byteswapping on an        */
+  /* address-window basis. Under this circumstance, the crypto data      */
+  /* we're using here (in SRL CTRLMEM) would certainly live in a         */
+  /* swappable memory window. We would therefore need to "cheat" when    */
+  /* we are building our selftest crypto structures in endian-aware      */
+  /* memory (CTRLMEM, the only kind that the SRL code uses).             */
+  /* To compensate for those platforms where (CTRLMEM) memory is         */
+  /* byteswapped when accessed by our device (as a PCI bus master),      */
+  /* we'll use BYTESWAPLONG when copying selftest crypto data into       */
+  /* (CTRLMEM) memory. This ensures that the data (as read by our        */
+  /* device) always appears in the desired byte order on the PCI bus,    */
+  /* based on what the hardware platform does with CTRLMEM-PCI bytes.    */
+  /* Because BYTESWAPLONG operates on 32-bit integers, the data used     */
+  /* in this self test must be treated as 32-bit integers (instead of    */
+  /* a byte stream).                                                     */
+
+  /* Now copy in the original source */
+
+  if (UBSEC_EXTERNAL_BYTESWAP_HW(pDevice)) {
+    /* 32-bit longs in CTRLMEM will be byteswapped by the external H/W.      */
+    /* Remember that we're building selftest crypto data in CTRLMEM memory.  */
+    /* Copy data by long ints, even though crypto data is intrinsically a    */
+    /* byte stream. Swap here to compensate for the external byteswap H/W.   */
+    for (i=0 ; i<(TEST_CIPHER_BLOCK_SIZE/4) ; i++) {
+      ((UBS_UINT32 *)pData)[i] = \
+	BYTESWAPLONG(((UBS_UINT32 *)InputData)[i]);
+    }
+  }
+  else /* (Normal) H/W doesn't change endianess between CTRLMEM and PCI */
+    RTL_Memcpy( pData,&InputData[0],TEST_CIPHER_BLOCK_SIZE);
+
+  /* Make sure DMA memory actually holds recent CPU-initialized buffer data */
+  OS_SyncToDevice(pDevice->SelfTestMemAreaHandle,0,TEST_CIPHER_BLOCK_SIZE);
+
+  /* Now set up the command(s) */
+#ifdef UBS_SELFTEST_MD5
+  /* Initialize the MAC/Inner Outer Key */
+  ubsec_InitHMACState(&HMAC_State,UBSEC_MAC_MD5,MacKey);
+  /* First is encode. */
+  ubsec_commands[0].Command=UBSEC_ENCODE_DES_MD5;
+  /* Second is decode. */
+  ubsec_commands[1].Command=UBSEC_DECODE_DES_MD5;
+#else
+  /* Initialize the MAC/Inner Outer Key */
+  ubsec_InitHMACState(&HMAC_State,UBSEC_MAC_SHA1,MacKey);
+  /* First is encode. */
+  ubsec_commands[0].Command=UBSEC_ENCODE_DES_SHA1;
+  /* Second is decode. */
+  ubsec_commands[1].Command=UBSEC_DECODE_DES_SHA1;
+#endif
+
+  /* The rest can be done in a loop */
+  for (i=0; i < 2 ; i++) {
+    ubsec_commands[i].InitialVector=(ubsec_IV_pt)&InitialVector[0]; 
+    ubsec_commands[i].CryptKey=(ubsec_CryptKey_pt)&CryptKey[0];
+    ubsec_commands[i].HMACState=&HMAC_State; 
+    ubsec_commands[i].NumSource=1; 
+    ubsec_commands[i].SourceFragments=&SourceFragments[i];
+    ubsec_commands[i].NumDestination=1; 
+    ubsec_commands[i].DestinationFragments=&DestinationFragments[i]; 
+    ubsec_commands[i].AuthenticationInfo.FragmentAddress=
+                            PhysicalAddress+(3*TEST_CIPHER_BLOCK_SIZE);
+    ubsec_commands[i].CryptHeaderSkip=0;
+  }
+
+  SaveConfig=UBSEC_READ_CONFIG(pDevice); 
+
+
+  /* Are we completing sync or async */
+  if (CompletionCallback) {
+    pDevice->SelfTestCallBack=CompletionCallback;
+    pDevice->SelfTestContext=CompletionContext;
+    ubsec_commands[1].CompletionCallback=CryptoCallback;
+    ubsec_commands[1].CommandContext=(unsigned long) pDevice;
+  }
+  else {
+    /* Turn off interrupts while waiting. */
+    UBSEC_DISABLE_INT(pDevice);
+  }
+
+    for (i=0; i < 2 ; i+=num_packets) {
+      switch (Status=ubsec_CipherCommand(Ubsec_Context,&ubsec_commands[i],&num_packets) ) {
+      case UBSEC_STATUS_SUCCESS:
+	break;
+      case UBSEC_STATUS_TIMEOUT:
+	Dbg_Print(DBG_FATAL,( "ubsec:  BUD Command timeout\n"));
+	ubsec_ResetDevice(Ubsec_Context);
+	return(Status);
+	break;
+      case UBSEC_STATUS_INVALID_PARAMETER:
+	Dbg_Print(DBG_FATAL,( "ubsec:  BUD Failed Invalid parameter\n"));
+	return(Status);
+	break;
+      case UBSEC_STATUS_NO_RESOURCE:
+	Dbg_Print(DBG_FATAL,( "ubsec:  BUD Failed No Resource\n"));
+	return(Status);
+      default:
+	Dbg_Print(DBG_FATAL,( "ubsec:  BUD Failure unknown %x\n",Status));
+	return(Status);
+	break;
+      }
+    }
+
+  /* Are we completing sync or async */
+  if (CompletionCallback) {
+    return(Status);
+  }
+
+    
+#ifndef BLOCK
+ while ((Status=WaitForCompletion(pDevice,(unsigned long)100000,UBSEC_CIPHER_LIST))
+	== UBSEC_STATUS_SUCCESS); /* wait for them all to complete */
+#endif
+
+  /* Restore configuration status */
+  UBSEC_WRITE_CONFIG(pDevice,SaveConfig);
+
+#ifdef BLOCK
+  /* Invalid parameter means that no more left on pending queue */
+  if (Status != UBSEC_STATUS_INVALID_PARAMETER)
+#else
+  if (Status != UBSEC_STATUS_SUCCESS)
+#endif
+    return(Status);
+
+  /* Make sure CPU sees current state of recently DMA'd data buffers */
+  OS_SyncToCPU(pDevice->SelfTestMemAreaHandle,
+	       TEST_CIPHER_BLOCK_SIZE,
+	       2*TEST_CIPHER_BLOCK_SIZE+UBSEC_SHA1_LENGTH);
+
+  return(CompareCryptoResults(pDevice,pData));
+}
+
+
+
+/*
+ * Compare the results of the crypto operation.
+ */
+static ubsec_Status_t
+CompareCryptoResults(DeviceInfo_pt pDevice, unsigned char *pData)
+{
+  int i;
+  /* Compare golden data with encrypted output data.                     */
+  if (UBSEC_EXTERNAL_BYTESWAP_HW(pDevice)) {
+    /* 32-bit longs in CTRLMEM will be byteswapped by external hardware.     */
+    /* Remember that we're building selftest crypto data in CTRLMEM memory.  */
+    /* Compare data by long ints, even though crypto data is intrinsically   */
+    /* byte stream. Swap here to compensate for the external byteswap H/W.   */
+    for (i=0 ; i<(TEST_CIPHER_BLOCK_SIZE/4) ; i++) {
+      if (((UBS_UINT32*)(&pData[TEST_CIPHER_BLOCK_SIZE]))[i] != \
+	  BYTESWAPLONG(((UBS_UINT32*)EncodedData)[i]) ) {
+	Dbg_Print(DBG_TEST,("ubstest: golden data and encrypted data do not match\n"));
+	return(UBSEC_STATUS_DEVICE_FAILED);
+      }
+    }
+  }
+  else {
+    if (RTL_Memcmp(EncodedData, &pData[TEST_CIPHER_BLOCK_SIZE],TEST_CIPHER_BLOCK_SIZE))
+      {
+	Dbg_Print(DBG_TEST,("ubstest: golden data and encrypted data do not match\n"));
+	return(UBSEC_STATUS_DEVICE_FAILED);
+      }
+  }
+
+  Dbg_Print(DBG_TEST,("ubstest: golden data and encrypted data match\n"));
+
+  /* Compare the decrypted-encrypted data with the original data         */
+
+  if (UBSEC_EXTERNAL_BYTESWAP_HW(pDevice)) {
+    /* 32-bit longs in CTRLMEM will be byteswapped by external hardware.     */
+    /* Remember that we're building selftest crypto data in CTRLMEM memory.  */
+    /* Compare data by long ints, even though crypto data is intrinsically   */
+    /* byte stream. Swap here to compensate for the external byteswap H/W.   */
+    for (i=0 ; i<(TEST_CIPHER_BLOCK_SIZE/4) ; i++) {
+      if (((UBS_UINT32*)(&pData[2*TEST_CIPHER_BLOCK_SIZE]))[i] != \
+	  BYTESWAPLONG(((UBS_UINT32*)InputData)[i]) ) {
+	Dbg_Print(DBG_TEST,("ubstest:decrypted-encrypted data and original data do not match\n"));
+	return(UBSEC_STATUS_DEVICE_FAILED);
+      }  
+    }
+  }
+  else {
+    if (RTL_Memcmp(pData, &pData[2*TEST_CIPHER_BLOCK_SIZE],TEST_CIPHER_BLOCK_SIZE))
+      {
+	Dbg_Print(DBG_TEST,("ubstest:decrypted-encrypted data and original data do not match\n"));
+	return(UBSEC_STATUS_DEVICE_FAILED);
+      }
+  }
+
+  Dbg_Print(DBG_TEST,("ubstest: decrypted-encrypted data and original data match\n"));
+
+  /* Compare final authentication */
+
+  if (UBSEC_EXTERNAL_BYTESWAP_HW(pDevice)) {
+    /* 32-bit longs in CTRLMEM will be byteswapped by external hardware.       */
+    /* Compare data by long ints, even though crypto data is intrinsically     */
+    /* a byte stream. Swap here to compensate for the external byteswap H/W.   */
+
+#ifdef UBS_SELFTEST_MD5
+    for (i=0 ; i<(UBSEC_MD5_LENGTH/4) ; i++) {
+#else
+    for (i=0 ; i<(UBSEC_SHA1_LENGTH/4) ; i++) {
+#endif
+      if (((UBS_UINT32*)(&pData[3*TEST_CIPHER_BLOCK_SIZE]))[i] != \
+	  BYTESWAPLONG(((UBS_UINT32*)(&AuthData[0]))[i]) ) {
+	Dbg_Print(DBG_TEST,("ubstest: Authentication data do not match\n"));
+	return(UBSEC_STATUS_DEVICE_FAILED);
+      }
+    }
+  }
+else {
+  
+#ifdef UBS_SELFTEST_MD5
+  if (RTL_Memcmp(&AuthData[0], &pData[(TEST_CIPHER_BLOCK_SIZE*3)],UBSEC_MD5_LENGTH)) {
+#else
+  if (RTL_Memcmp(&AuthData[0], &pData[(TEST_CIPHER_BLOCK_SIZE*3)],UBSEC_SHA1_LENGTH)) {
+#endif
+      Dbg_Print(DBG_TEST,("ubstest: Authentication data do not match\n"));
+      return(UBSEC_STATUS_DEVICE_FAILED);
+  }
+}
+
+  Dbg_Print(DBG_TEST,("ubstest: Authentication data matches\n"));
+  Dbg_Print(DBG_TEST,("ubstest: crypto self-test passed successfully.\n"));
+  return(UBSEC_STATUS_SUCCESS);
+}
+
+
+/*
+ * CryptoCallback: Intermediate callback routine for crypto selftest.
+ * This is called when the crypto operation completes. We need to check
+ * the result of the crypto operation and indicate the status to the 
+ * initiator of the test.
+ */
+static void CryptoCallback(unsigned long Context,ubsec_Status_t Result)
+{
+  DeviceInfo_pt pDevice=(DeviceInfo_pt)Context;
+
+  if (Result == UBSEC_STATUS_SUCCESS) { 
+    /* Make sure CPU sees current state of recently DMA'd data buffers */
+    OS_SyncToCPU(pDevice->SelfTestMemAreaHandle,
+	       TEST_CIPHER_BLOCK_SIZE,
+	       2*TEST_CIPHER_BLOCK_SIZE+UBSEC_SHA1_LENGTH);
+    Result=CompareCryptoResults(pDevice,pDevice->SelfTestMemArea);
+  }
+
+  (*pDevice->SelfTestCallBack)(pDevice->SelfTestContext,Result);
+}
+
+
+
+
+
+
+
diff -urNp linux-8030/drivers/addon/bcm/ubsutils.c linux-8040/drivers/addon/bcm/ubsutils.c
--- linux-8030/drivers/addon/bcm/ubsutils.c
+++ linux-8040/drivers/addon/bcm/ubsutils.c
@@ -0,0 +1,884 @@
+
+/*
+ * Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ * of any kind, either express or implied as further specified in the GNU Public
+ * License. This software may be used and distributed according to the terms of
+ * the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+
+/******************************************************************************
+ *
+ * Copyright 2000
+ * Broadcom Corporation
+ * 16215 Alton Parkway
+ * PO Box 57013
+ * Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+
+/*
+ * ubsutils.c: ubsec library utility and support functions.
+ */
+
+/*
+ * Revision History:
+ * 12/02/1999 DWP Modified source to handle big endian host.
+ * 07/06/2000 DPA Fixes for SMP operation
+ * 04/18/2001 RJT Added support for CPU-DMA memory synchronization
+ * 07/16/2001 RJT Added support for BCM5821
+ * 10/09/2001 SRM 64 bit port
+ */
+
+#include "ubsincl.h"
+
+void DumpCipherMCR(MasterCommand_pt pMCR);
+void DumpKeyMCR(MasterCommand_pt pMCR);
+/* Reverse 'len' bytes from 'st'. Used to convert between big and little endian */
+void
+revBytes(void *st, int len)
+{
+	int i;
+	unsigned char *bst = (unsigned char *) st;
+
+	for (i = 0; i < len/2; ++i) {
+		unsigned char temp = bst[i];
+		bst[i] = bst[len-1-i];
+		bst[len-1-i] = temp;
+	}
+}
+
+/* Reasonably fast rotate left of x by 'n' bits */
+UBS_UINT32
+rol(UBS_UINT32 x, int n)
+{
+	unsigned long result = (x << n) | (x >> (32-n));
+	return (result);
+}
+
+void
+/*
+ * Copy DWORD values to destination of opposite endianess (of source endianess)
+ */
+copywords(UBS_UINT32 *out, UBS_UINT32 *in, int num)
+{
+  /*
+   * This routine is used as the anti-endian version of RTL_Memcpy().
+   */
+  for (;num--;) {
+    out[num]=BYTESWAPLONG(in[num]); /* Change the 32-bit endianess in S/W */
+  }
+}
+
+
+void ubs_copylongs_cpu_ctrlmem(unsigned long *dest,unsigned long *src, int num)
+{
+  for ( ; --num >= 0 ; ) 
+    dest[num] = CPU_TO_CTRL_LONG(src[num]);
+}
+
+void ubs_copylongs_byteswap(unsigned long *dest,unsigned long *src, int num)
+{
+  for ( ; --num >= 0 ; ) 
+    dest[num] = BYTESWAPLONG(src[num]);
+}
+
+
+#ifdef MCR_STATS
+#define STAT_NOOFMCRNOFREERETHITS() pDevice->MCRstat.no_free_mcr_ret++;
+#define STAT_NOOFPACKETS(num)  \
+	if (num <= MCR_MAXIMUM_PACKETS) \
+		pDevice->MCRstat.num_packets_stat[num-1]++; \
+
+#define STAT_NOOFMCRHITS(mcrnum) pDevice->MCRstat.push_mcr_stat[mcrnum-1]++;
+#define STAT_NOOFMCRFULLHITS(mcrnum) pDevice->MCRstat.mcr_full_stat[mcrnum-1]++;
+#else
+#define STAT_NOOFMCRNOFREERETHITS() 
+#define STAT_NOOFPACKETS(mcrnum)  
+#define STAT_NOOFMCRHITS(mcrnum) 
+#define STAT_NOOFMCRFULLHITS(mcrnum) 
+#endif /* MCR_STATS */
+
+/*
+ * GetFreeMCR: Get the next free MCR from the MCR List.
+ * Return MCR and/or error status if unable to do so.
+ */
+MasterCommand_pt GetFreeMCR(  DeviceInfo_pt pDevice,int MCRList,ubsec_Status_t *Status)
+{
+
+ MasterCommand_pt  	pMCR;
+
+  pMCR = pDevice->NextFreeMCR[MCRList];
+  /* Check to see if it is busy. If not then the list is full */
+  if (pMCR->MCRState&MCR_STATE_PUSHED) { /* If it has been pushed. */
+    /* Check to see if the command has completed, if so we can free it up. */
+
+    /* First make sure the CPU sees any CryptoNet DMA updates.             */
+    Dbg_Print(DBG_MCR_SYNC,( "ubsec: GetFreeMCR() Sync Flags to CPU (0x%08X,%d,%d)\n", 
+			pMCR->MCRMemHandle,pMCR->MCRMemHandleOffset,4));
+    OS_SyncToCPU(pMCR->MCRMemHandle,
+		 pMCR->MCRMemHandleOffset,4); /* Need to sync DMA'd flags */
+
+    if( pMCR->Flags & MCR_FLAG_COMPLETION ) {
+#ifdef COMPLETE_ON_COMMAND_THREAD
+      ubsec_PollDevice(pDevice); /* Free some up */
+#endif
+      /* Try again */
+      pMCR = pDevice->NextFreeMCR[MCRList];
+      if (pMCR->MCRState)  /* Still busy */ {
+	*Status=UBSEC_STATUS_NO_RESOURCE;
+	goto Error_Return;
+      }
+    }
+    else {
+      /* Are we blocked, just check to see if device is running.*/
+      if ( UBSEC_READ_STATUS(pDevice) & DMA_ERROR) {
+	Dump_Registers(pDevice,DBG_FATAL); 
+	*Status=UBSEC_STATUS_DEVICE_FAILED;
+	goto Error_Return;
+      }
+      else {
+	*Status=UBSEC_STATUS_NO_RESOURCE;
+	goto Error_Return;
+      }
+    }
+  }
+
+  *Status=UBSEC_STATUS_SUCCESS;
+
+  return(pMCR);
+
+ Error_Return:
+	 STAT_NOOFMCRNOFREERETHITS();
+  return(NULL_MASTER_COMMAND);
+}
+
+
+/*
+ *
+ * PushMCR: Push an MCR onto the device if there is an MCR waiting
+ * and the device is ready to accept the waiting MCR. 
+ *
+ * MCRs in each list waiting to be pushed are pointed to by NextDeviceMCR
+ *
+ */
+
+
+
+void
+PushMCR(DeviceInfo_pt pDevice)
+{
+  VOLATILE MasterCommand_t  *pMCR;
+  unsigned int MCRListNum; /* MCR list we are dealing with */
+
+
+  for (MCRListNum=0;MCRListNum < pDevice->NumberOfMCRLists ;MCRListNum++ ) {
+    pMCR = pDevice->NextDeviceMCR[MCRListNum];
+
+    /* Is this MCR ready for pushing. (packets+notpushed)*/
+    if (!pMCR->NumberOfPackets ||
+	(pMCR->MCRState==MCR_STATE_PUSHED))
+	continue;  /* Nope, go to next MCRList */
+
+	STAT_NOOFPACKETS(pMCR->NumberOfPackets);
+
+    /* Is the device ready to accept an MCR */
+    if ( !MCRListNum) { /* check MCR1_FULL (crypto) */
+#ifdef DVT
+      if (pDevice->DVTOptions & UBSEC_SUSPEND_MCR1)
+	continue;
+#endif /* DVT */
+      if (UBSEC_READ_STATUS(pDevice) & MCR1_FULL) {
+#ifdef CHECK_BUSY_BIT_TWICE
+	/* Wait one us and try again. */
+	OS_Waitus(1);
+	if (UBSEC_READ_STATUS(pDevice) & MCR1_FULL) 
+#endif
+	  STAT_NOOFMCRFULLHITS(1); /* MCR_STATS */
+	  continue; /* can't push crypto MCR, try next MCRList */
+      }
+	STAT_NOOFMCRHITS(1); /* MCR_STATS */
+    }
+    else { /* check MCR2_FULL (key) */
+#ifdef DVT
+      if (pDevice->DVTOptions & UBSEC_SUSPEND_MCR2)
+	continue;
+#endif /* DVT */
+      if (UBSEC_READ_STATUS(pDevice) & MCR2_FULL) {
+#ifdef CHECK_BUSY_BIT_TWICE
+	/* Wait one us and try again. */
+	OS_Waitus(1);
+	if (UBSEC_READ_STATUS(pDevice) & MCR2_FULL)
+#endif
+	  STAT_NOOFMCRFULLHITS(2); /* MCR_STATS */
+	  continue; /* can't push key MCR, try next MCRList (or quit if this is last MCRList) */
+       }
+	STAT_NOOFMCRHITS(2); /* MCR_STATS */
+     } /* end of MCR2_FULL check */ 
+
+    Dbg_Print(DBG_CMD,( "ubsec:  push a new mcr %d: %d Packets\n", pDevice->NextDeviceMCR[MCRListNum]->Index,pMCR->NumberOfPackets ));
+
+    /* If we are pushing the current free MCR then we will need to
+       advance it to ensure that we maintain list integrity */
+    if (pMCR==pDevice->NextFreeMCR[MCRListNum])
+      pDevice->NextFreeMCR[MCRListNum]=(MasterCommand_pt)pMCR->pNextMCR;
+
+    /* Go to the next MCR. Wrap around if necessary. */
+    pDevice->NextDeviceMCR[MCRListNum]=(MasterCommand_pt)pMCR->pNextMCR;
+    /* Now push the current MCR to the device */
+    pMCR->NumberOfPackets = CPU_TO_CTRL_SHORT( pMCR->NumberOfPackets );
+
+    /* For the BCM582x, let MCRn_ALL_DONE (not MCRn_INTR) cause the H/W interrupt.   */
+    /* This line of code has no effect on these CryptoNet devices: BCM580x, BCM5820 */
+    pMCR->Flags = pDevice->InterruptSuppress; /* UBSEC_582x */
+
+    Dbg_Print(DBG_MCR_SYNC,( "ubsec: PushMCR() Sync MCR to device (0x%08X,%d,%d)\n", 
+			pMCR->MCRMemHandle,pMCR->MCRMemHandleOffset,
+			sizeof(*pMCR)));
+    OS_SyncToDevice(pMCR->MCRMemHandle,pMCR->MCRMemHandleOffset,sizeof(*pMCR));
+
+    pMCR->MCRState|=MCR_STATE_PUSHED;
+    UBSEC_WRITE_MCR(pDevice,pMCR,MCRListNum);
+  } /* for each MCRList */
+
+} /* end of PushMCR */
+
+
+/*
+ * dumpMCR: Dump the contents of the MCR with associated structures etc.
+ *
+ */
+int
+dump_MCR(DeviceInfo_pt pDevice,MasterCommand_pt pMCR,unsigned long MCRListIndex)
+{
+int NumCommands;
+
+
+Dbg_Print(DBG_CMD,("ubsec:  --------------- MCR DUMP (%d) ----------------\n",MCRListIndex));
+ Dbg_Print(DBG_CMD,("ubsec: MCR Index:  Free(%02d) Device(%02d) Done(%02d)\n",
+		      pDevice->NextFreeMCR[MCRListIndex]->Index, pDevice->NextDeviceMCR[MCRListIndex]->Index, pDevice->NextDoneMCR[MCRListIndex]->Index));
+
+ if (pMCR->MCRState & MCR_STATE_PUSHED)
+   NumCommands=CPU_TO_CTRL_SHORT(pMCR->NumberOfPackets);
+ else
+   NumCommands=pMCR->NumberOfPackets;
+ Dbg_Print(DBG_CMD,("ubsec:  Info for MCR %d\n", pMCR->Index ));
+ Dbg_Print(DBG_CMD,("ubsec:  -- Virtual Address  [%08x]\n", pMCR ));
+ Dbg_Print(DBG_CMD,("ubsec:  -- Physical Address [%08x]\n", pMCR->MCRPhysicalAddress ));
+ Dbg_Print(DBG_CMD,("ubsec:  -- Number of Packets [%04d] Flags [%04x]", NumCommands, pMCR->Flags));
+ 
+#ifdef UBSDBG
+ if ((unsigned int) pMCR->Index >= pDevice->NumberOfMCRs[MCRListIndex]) {
+   Dbg_Print(DBG_FATAL,( "\nubsec:  -- Invalid Index %d\n ", pMCR->Index ));
+   return(UBSEC_STATUS_INVALID_PARAMETER);
+ }
+#endif
+
+ if (NumCommands > MCR_MAXIMUM_PACKETS) {
+   Dbg_Print(DBG_FATAL,( "\nubsec:  -- Too many packets %d Just do 1\n ",NumCommands ));
+   NumCommands=1;
+  }
+
+
+ /* Type of MCR depends on the list */
+ if(MCRListIndex==0){
+   DumpCipherMCR(pMCR);
+ }
+ else {
+   DumpKeyMCR(pMCR);
+ }
+
+ return 0;
+
+
+}
+
+/*
+ * Dump the contents of a "cipher" MCR.
+ */
+void DumpCipherMCR(MasterCommand_pt pMCR)
+{
+Packet_pt         pPacket;
+PacketContext_pt  pContext;
+int             PacketIndex;
+int  FragNum;     /* Index into packet fragment array. */
+VOLATILE DataBufChain_t  *FragPtr;
+VOLATILE DataBufChain_t  *tFragPtr;
+int NumCommands;
+#ifdef UBSEC_582x_CLASS_DEVICE
+ int WordLen,i;
+ long *p;
+#endif
+
+ VOLATILE CipherContext_t  *pCipherContext;
+
+ PacketIndex = 0;
+ pPacket = (Packet_pt)&(pMCR->PacketArray[0]);
+ pContext = (PacketContext_pt)&(pMCR->ContextList[0]);
+ if (pMCR->MCRState & MCR_STATE_PUSHED)
+   NumCommands=CPU_TO_CTRL_SHORT(pMCR->NumberOfPackets);
+ else
+   NumCommands=pMCR->NumberOfPackets;
+
+ for (; NumCommands-- ; PacketIndex++,pPacket++,pContext++) { /* Add all the packets to the MCR */
+   Dbg_Print(DBG_CMD,( "\nubsec:  ---- Packet %d\n", PacketIndex ));
+   Dbg_Print(DBG_CMD,(   "ubsec:  ---- Context: Virtual Address  [%08x]\n", pContext ));
+   Dbg_Print(DBG_CMD,(   "ubsec:  ----          Physical Address [%08x]\n", CPU_TO_CTRL_LONG(pContext->PhysicalAddress))); 
+#ifdef UBSEC_582x_CLASS_DEVICE
+   if (pContext->operation_type!=OPERATION_IPSEC) {
+     WordLen=(pContext->cmd_structure_length)/4;
+     Dbg_Print(DBG_CMD,( "Context - "));
+     p=(long *)pContext;
+     for ( i=0 ; i < WordLen ; i++,p++) {
+       Dbg_Print(DBG_CMD,( "%08x ",CPU_TO_CTRL_LONG(*p)));
+     }
+     Dbg_Print(DBG_CMD,( "]\n"));
+   }
+   else
+#endif /* UBSEC_582x_CLASS_DEVICE */
+     {
+    pCipherContext=&pContext->Context.Cipher;
+
+     Dbg_Print(DBG_CMD,(   "ubsec:  ----          Crypto Key [%08x][%08x]\n", pCipherContext->CryptoKey1[0],pCipherContext->CryptoKey1[1] ));
+     Dbg_Print(DBG_CMD,(   "ubsec:  ----                     [%08x][%08x]\n", pCipherContext->CryptoKey2[0],pCipherContext->CryptoKey2[1] ));
+     Dbg_Print(DBG_CMD,(   "ubsec:  ----                     [%08x][%08x]\n", pCipherContext->CryptoKey3[0],pCipherContext->CryptoKey3[1] ));
+     Dbg_Print(DBG_CMD,(   "ubsec:  ----          HMAC Inner [%08x][%08x][%08x][%08x][%08x]\n",
+			pCipherContext->HMACInnerState[0],
+			pCipherContext->HMACInnerState[1],
+			pCipherContext->HMACInnerState[2],
+			pCipherContext->HMACInnerState[3],
+			pCipherContext->HMACInnerState[4] ));
+     Dbg_Print(DBG_CMD,(   "ubsec:  ----          HMAC Outer [%08x][%08x][%08x][%08x][%08x]\n",
+			pCipherContext->HMACOuterState[0],
+			pCipherContext->HMACOuterState[1],
+			  pCipherContext->HMACOuterState[2],
+			pCipherContext->HMACOuterState[3],
+			pCipherContext->HMACOuterState[4] ));
+     Dbg_Print(DBG_CMD,(   "ubsec:  ----          Computed IV [%08x][%08x]\n", pCipherContext->ComputedIV[0], pCipherContext->ComputedIV[1] ));
+     Dbg_Print(DBG_CMD,(   "ubsec:  ----          Crypto O/F  [%04x][%04x]\n", 
+                        CTRL_TO_CPU_SHORT( pCipherContext->CryptoOffset ), 
+			CTRL_TO_CPU_SHORT( pCipherContext->CryptoFlag )));
+     }
+    /*
+     * Now add the packet input fragment information
+     * First fragment will need to skip the MAC Header
+     * We are assuming at least one fragment.
+     */
+
+   Dbg_Print(DBG_CMD,( "ubsec:  Packet len %d\n",CTRL_TO_CPU_SHORT(pPacket->PacketLength))); 
+
+     FragPtr=&pPacket->InputHead;
+     for (FragNum=0 ;  ;FragNum++ ) {
+       Dbg_Print(DBG_CMD,( "ubsec:  ---- Input Fragment(%02d): Length (%04d)\n", 
+			   FragNum, CTRL_TO_CPU_SHORT(FragPtr->DataLength)));
+       Dbg_Print(DBG_CMD,( "ubsec:  ----          Physical Address [%08x]\n",
+               CTRL_TO_CPU_LONG(FragPtr->DataAddress)));
+       if (FragNum>UBSEC_MAX_FRAGMENTS) {
+	 Dbg_Print(DBG_CMD,( "ubsec:  Lost input fragment list\n" ));
+	 return;
+       }
+       if (!FragPtr->pNext) {
+	  break;
+       }
+       tFragPtr=FragPtr;
+       FragPtr=(DataBufChain_pt)&pMCR->InputFragmentList[(PacketIndex*(UBSEC_MAX_FRAGMENTS))];
+       FragPtr+=FragNum;
+     }
+      /* print the packet size */
+	 Dbg_Print(DBG_CMD,( "ubsec:  ---- Packet Length (%04d)\n",CTRL_TO_CPU_SHORT(pPacket->PacketLength)));
+
+      /* print the output fragment information */
+     FragPtr=&pPacket->OutputHead;
+     for (FragNum=0 ;  ;FragNum++ ) {
+       Dbg_Print(DBG_CMD,( "ubsec:  ---- Output Fragment(%02d): Length (%04d)\n",
+			   FragNum, CTRL_TO_CPU_SHORT(FragPtr->DataLength)));
+       Dbg_Print(DBG_CMD,( "ubsec:  ----          Physical Address [%08x]\n",
+			   CTRL_TO_CPU_LONG(FragPtr->DataAddress)));
+       Dbg_Print(DBG_CMD,( "ubsec:  ----          Next Physical Addr [%08x]\n",
+			   CTRL_TO_CPU_LONG(FragPtr->pNext)));
+
+       if (FragNum>UBSEC_MAX_FRAGMENTS) {
+	 Dbg_Print(DBG_CMD,( "ubsec:  Lost output fragment list\n" ));
+	 return;
+       }
+
+       if (!FragPtr->pNext) {
+	 break;
+       }
+       tFragPtr=FragPtr;
+       FragPtr=(DataBufChain_pt)&pMCR->OutputFragmentList[(PacketIndex*(UBSEC_MAX_FRAGMENTS))];
+       FragPtr+=FragNum;
+       if ( CTRL_TO_CPU_LONG(FragPtr->DataAddress) & 0x03)
+	 Dbg_Print(DBG_CMD,("ubsec: ################INVALID OUTPUT ADDRESS %0x\n",CTRL_TO_CPU_LONG(FragPtr->DataAddress)));
+       if ( CTRL_TO_CPU_SHORT(FragPtr->DataLength) & 0x03)
+	 Dbg_Print(DBG_CMD,("ubsec: ################INVALID OUTPUT LENGTH %0x\n",CTRL_TO_CPU_SHORT(FragPtr->DataLength)));
+     }
+   }
+}
+
+
+
+/*
+ * Dump the contents of a "key" MCR.
+ */
+void DumpKeyMCR(MasterCommand_pt pMCR)
+{
+#if 0
+  Packet_pt         pPacket;
+  KeyContext_pt  pContext;
+  int             PacketIndex;
+  int NumCommands;
+  DH_Send_CtxCmdBuf_pt 	pDHSendCtx;
+  DH_REC_CtxCmdBuf_pt	pDHRecCtx;
+  Pub_RSA_CtxCmdBuf_pt		pRSACtx;
+  Pri_RSA_CtxCmdBuf_pt		pPrivRSACtx;
+
+  int i;
+  int  FragNum;     /* Index into packet fragment array. */
+  VOLATILE DataBufChain_t *FragPtr;
+  VOLATILE DataBufChain_t *tFragPtr;
+  int WordLen;
+
+  PacketIndex = 0;
+  pPacket = &(pMCR->PacketArray[0]);
+  pContext = pMCR->KeyContextList[0];
+  if (pMCR->MCRState & MCR_STATE_PUSHED)
+    NumCommands=CPU_TO_CTRL_SHORT(pMCR->NumberOfPackets);
+  else
+    NumCommands=pMCR->NumberOfPackets;
+
+  for (; NumCommands-- ; PacketIndex++,pPacket++) { // Add all the packets to the MCR
+    pContext = pMCR->KeyContextList[PacketIndex];
+     Dbg_Print(DBG_KEY,( "\nubsec:  ---- Packet %d\n", PacketIndex ));
+     Dbg_Print(DBG_KEY,(   "ubsec:  ---- Context: Virtual Address  [%08x]\n", pContext ));
+     Dbg_Print(DBG_KEY,(   "ubsec:  ----          Physical Address [%08x]\n", CPU_TO_CTRL_LONG(pContext->PhysicalAddress))); 
+     switch (pContext->operation_type) {
+     case OPERATION_DH_PUBLIC:
+	pDHSendCtx = &pContext->CtxCmdBuf.DH_Send_CtxCmdBuf; 
+	WordLen=(pMCR->KeyContextList[PacketIndex]->cmd_structure_length-DH_STATIC_SEND_CONTEXT_SIZE)/4;
+
+	Dbg_Print(DBG_KEY,(   "ubsec:  ---- DH_Public - RNG-Enable [%d] Private Klen [%d] Generator Len [%d]\n",
+			      pDHSendCtx->rng_enable,pDHSendCtx->private_key_length,pDHSendCtx->generator_length)); 
+
+	Dbg_Print(DBG_KEY,(   "ubsec:  ---- Modulus Length [%d] ",pDHSendCtx->modulus_length)); 
+	Dbg_Print(DBG_KEY,(   "Generator Length [%d] Context Value=[",pDHSendCtx->generator_length)); 
+
+	for ( i=0 ; i < WordLen ; i++) {
+	   Dbg_Print(DBG_KEY,( "%08x",SYS_TO_BE_LONG(pDHSendCtx->Ng[i])));
+	}
+	Dbg_Print(DBG_KEY,( "]\n"));
+
+	break;
+     case OPERATION_DH_SHARED:
+
+	pDHRecCtx = &pContext->CtxCmdBuf.DH_REC_CtxCmdBuf; 
+	WordLen=(pDHRecCtx->modulus_length+31)/32;
+
+	Dbg_Print(DBG_KEY,(   "ubsec:  ---- DH Shared Modulus Length [%d] Value -\n[",pDHRecCtx->modulus_length)); 
+	for ( i=0 ; i < WordLen ; i++) {
+	   Dbg_Print(DBG_KEY,( "%08x",SYS_TO_BE_LONG(pDHRecCtx->N[i])));
+	}
+	Dbg_Print(DBG_KEY,( "]\n"));
+
+       break;
+     case OPERATION_RSA_PUBLIC:
+       pRSACtx = &pContext->CtxCmdBuf.Pub_RSA_CtxCmdBuf;
+       WordLen=(pMCR->KeyContextList[PacketIndex]->cmd_structure_length-RSA_STATIC_PUBLIC_CONTEXT_SIZE)/4;
+       Dbg_Print(DBG_KEY,(   "ubsec:  ---- RSA Public Modulus Length [%d] \n[",pRSACtx->modulus_length)); 
+       Dbg_Print(DBG_KEY,(   "ubsec:  ---- RSA Public G Length [%d] Context-\n[",pRSACtx->exponent_length)); 
+       for ( i=0 ; i < WordLen ; i++) {
+	 Dbg_Print(DBG_KEY,( "%08x",SYS_TO_BE_LONG(pRSACtx->Ng[i])));
+       }
+       Dbg_Print(DBG_KEY,( "]\n"));
+
+       break;
+     case OPERATION_RSA_PRIVATE:
+       pPrivRSACtx = &pContext->CtxCmdBuf.Pri_RSA_CtxCmdBuf;
+       WordLen=(pMCR->KeyContextList[PacketIndex]->cmd_structure_length-RSA_STATIC_PRIVATE_CONTEXT_SIZE)/4;
+       Dbg_Print(DBG_KEY,(   "ubsec:  ---- RSA Private Prime Q Length [%d] \n[",pPrivRSACtx->q_length)); 
+       Dbg_Print(DBG_KEY,(   "ubsec:  ---- RSA Private Prime P Length [%d] \n[",pPrivRSACtx->p_length)); 
+       Dbg_Print(DBG_KEY,(   "ubsec:  ---- RSA Private Prime EDQ Length [%d] \n[",pPrivRSACtx->dq_length)); 
+       Dbg_Print(DBG_KEY,(   "ubsec:  ---- RSA Private Prime EDP Length [%d] \n[",pPrivRSACtx->dp_length)); 
+       Dbg_Print(DBG_KEY,(   "ubsec:  ---- RSA Private Prime Pinv Length [%d] Context Value -\n[",pPrivRSACtx->pinv_length)); 
+
+       for ( i=0 ; i < WordLen ; i++) {
+	 Dbg_Print(DBG_KEY,( "%08x",SYS_TO_BE_LONG(pPrivRSACtx->CtxParams[i])));
+       }
+       Dbg_Print(DBG_KEY,( "]\n"));
+
+       break;
+     default:
+       Dbg_Print(DBG_KEY,(   "ubsec:  ----          Unknown Key Command %x\n",pContext->operation_type)); 
+     }
+  
+    /*
+     * Now add the packet input fragment information
+     * First fragment will need to skip the MAC Header
+     * We are assuming at least one fragment.
+     */
+	FragPtr=&pPacket->InputHead;
+	for (FragNum=0 ;  ;FragNum++ ) {
+	  Dbg_Print(DBG_CMD,( "ubsec:  ---- Input Fragment(%02d): Length (%04d)\n", 
+			      FragNum, CTRL_TO_CPU_SHORT(FragPtr->DataLength)));
+	  Dbg_Print(DBG_CMD,( "ubsec:  ----          Physical Address [%08x]\n",
+			      CTRL_TO_CPU_LONG(FragPtr->DataAddress)));
+	  if (FragNum>UBSEC_MAX_FRAGMENTS) {
+	    Dbg_Print(DBG_CMD,( "ubsec:  Lost input fragment list\n" ));
+	    return(-3);
+	  }
+
+	  if (FragNum>UBSEC_MAX_FRAGMENTS) {
+	    Dbg_Print(DBG_CMD,( "ubsec:  Lost output fragment list\n" ));
+	    return(-3);
+	  }
+
+	  if (!FragPtr->pNext) {
+	    break;
+	  }
+	  tFragPtr=FragPtr;
+	  FragPtr=&pMCR->InputFragmentList[(PacketIndex*(UBSEC_MAX_FRAGMENTS))];
+	  FragPtr+=FragNum;
+	}
+	/* print the packet size */
+	   Dbg_Print(DBG_CMD,( "ubsec:  ---- Packet Length (%04d)\n",CTRL_TO_CPU_SHORT(pPacket->PacketLength)));
+
+      /* print the output fragment information */
+	FragPtr=&pPacket->OutputHead;
+	for (FragNum=0 ;  ;FragNum++ ) {
+	  Dbg_Print(DBG_CMD,( "ubsec:  ---- Output Fragment(%02d): Length (%04d)\n",
+			      FragNum, CTRL_TO_CPU_SHORT(FragPtr->DataLength)));
+	  Dbg_Print(DBG_CMD,( "ubsec:  ----          Physical Address [%08x]\n",
+			      CTRL_TO_CPU_LONG(FragPtr->DataAddress)));
+	  Dbg_Print(DBG_CMD,( "ubsec:  ----          Next Physical Addr [%08x]\n",
+			      CTRL_TO_CPU_LONG(FragPtr->pNext)));
+	  if (FragNum>UBSEC_MAX_FRAGMENTS) {
+	    Dbg_Print(DBG_CMD,( "ubsec:  Lost output fragment list\n" ));
+	    return(-3);
+	  }
+
+	  if (FragNum>UBSEC_MAX_FRAGMENTS) {
+	    Dbg_Print(DBG_CMD,( "ubsec:  Lost output fragment list\n" ));
+	    return(-3);
+	  }
+
+	  if (!FragPtr->pNext) {
+	    break;
+	  }
+	  tFragPtr=FragPtr;
+	  FragPtr=&pMCR->OutputFragmentList[(PacketIndex*(UBSEC_MAX_FRAGMENTS))];
+	  FragPtr+=FragNum;
+	  if ( CTRL_TO_CPU_LONG(FragPtr->DataAddress) & 0x03)
+	    Dbg_Print(DBG_CMD,("ubsec: ################INVALID OUTPUT ADDRESS %0x\n",CTRL_TO_CPU_LONG(FragPtr->DataAddress)));
+	  if ( CTRL_TO_CPU_SHORT(FragPtr->DataLength) & 0x03)
+	    Dbg_Print(DBG_CMD,("ubsec: ################INVALID OUTPUT LENGTH %0x\n",CTRL_TO_CPU_SHORT(FragPtr->DataLength)));
+	}
+  }
+#endif
+}
+
+
+/*
+ * Poll with timeout the next MCR to be done. Complete the MCR
+ * and return if it completes.
+ */
+int
+WaitForCompletion(DeviceInfo_pt pDevice,unsigned long blockus,unsigned long MCRListIndex)
+{
+  VOLATILE  int wait_us;
+  VOLATILE  unsigned long delay_total_us=0;
+  MasterCommand_pt pMCR;
+
+  pMCR =  pDevice->NextDoneMCR[MCRListIndex];
+
+  /* First make sure this MCR has been pushed. */
+  if (!(pMCR->MCRState&MCR_STATE_PUSHED))
+    return(UBSEC_STATUS_INVALID_PARAMETER);
+
+  if (pDevice->InCriticalSection) {
+    Dbg_Print((DBG_CMD|DBG_KEY),( "ubsec:  ubsec Completion Nested call %d ",pDevice->InCriticalSection));
+    return(UBSEC_STATUS_DEVICE_BUSY); 
+  }
+
+  wait_us=1;
+
+  Dbg_Print(DBG_MCR_SYNC,( "ubsec: WaitForCompletion() Sync Flags to CPU (0x%08X,%d,%d)\n", 
+		      pMCR->MCRMemHandle,pMCR->MCRMemHandleOffset,4));
+  OS_SyncToCPU(pMCR->MCRMemHandle,
+	       pMCR->MCRMemHandleOffset,4); /* Need to sync DMA'd flags */
+
+  while (!( pMCR->Flags & MCR_FLAG_COMPLETION)) {
+    delay_total_us+=wait_us;
+    if (delay_total_us >= blockus) {
+      Dbg_Print(DBG_CMD_FAIL,("ubsec: Command Timeout %x\n",pMCR->Flags));
+      Dump_Registers(pDevice,DBG_CMD_FAIL);
+      return(UBSEC_STATUS_TIMEOUT);
+    }
+
+    Dbg_Print(DBG_MCR_SYNC,( "ubsec: WaitForCompletion() Sync Flags to CPU (0x%08X,%d,%d)\n", 
+			pMCR->MCRMemHandle,pMCR->MCRMemHandleOffset,4));
+    OS_SyncToCPU(pMCR->MCRMemHandle,
+		 pMCR->MCRMemHandleOffset,4); /* Sync flags before checking */
+
+    OS_Waitus(wait_us);
+    wait_us=1;
+  }
+
+  /* Now complete the request */
+  ubsec_PollDevice((ubsec_DeviceContext_t)pDevice);
+#if defined BLOCK || defined COMPLETE_PENDING_REQUESTS
+  PushMCR(pDevice);
+#endif
+  return(UBSEC_STATUS_SUCCESS);
+}
+
+/*
+ * FlushDevice:
+ *
+ * This routine is used to flush the device request queue.
+ * Commands will be completed (callbacks called) from within
+ * this call with the status as passed to this routine
+ *
+ * Flushall when set will cause entire queues to be complete
+ * Otherwise they will only complete if they have been pushed.
+ *
+ */
+void
+FlushDevice(DeviceInfo_pt pDevice,ubsec_Status_t Status,unsigned int FlushType)
+{
+  VOLATILE MasterCommand_t *pMCR;
+  VOLATILE int j;
+  VOLATILE CallBackInfo_t  *pCallBack;
+  int NumberOfPackets;
+  unsigned long MCRListIndex;
+
+  Dbg_Print(DBG_CMD,( "ubsec:  flush device handler \n" ));
+
+  /* While there are MCRs to complete, do it. */
+  for(MCRListIndex=0; MCRListIndex< pDevice->NumberOfMCRLists ;MCRListIndex++) {
+    for(;;) {
+    /* Get next device. */
+      pMCR = pDevice->NextDoneMCR[MCRListIndex];
+      /* Now check to see if there are any to complete */
+      if  ((pMCR->MCRState) ||
+	  ((FlushType==FLUSH_ALL) && (pMCR->NumberOfPackets))) { /* Flush all packets */
+	if (pMCR->MCRState & MCR_STATE_PUSHED)
+	  NumberOfPackets = CPU_TO_CTRL_SHORT(pMCR->NumberOfPackets);
+	else
+	  NumberOfPackets = pMCR->NumberOfPackets;
+	/* unload the packets */
+	pCallBack = &pMCR->CompletionArray[0];
+	for( j = 0; j < NumberOfPackets; j++ ) {
+	  if( pCallBack->CompletionCallback) {
+	    (*pCallBack->CompletionCallback)( pCallBack->CommandContext,Status);
+	    pCallBack->CompletionCallback=0;
+	  }
+	  pCallBack++;
+	}
+	pMCR->NumberOfPackets = 0; /* This frees it up */
+	pMCR->Flags = 0; 
+	pMCR->MCRState = MCR_STATE_FREE; /* Set it to free */
+	pDevice->NextDoneMCR[MCRListIndex] = (MasterCommand_pt)pMCR->pNextMCR;
+      }
+      else {
+		  if (FlushType==FLUSH_ALL) {
+			/* reinit buffer pointers */
+			pDevice->NextFreeMCR[MCRListIndex]=pDevice->MCRList[MCRListIndex];
+			pDevice->NextDeviceMCR[MCRListIndex]=pDevice->MCRList[MCRListIndex];
+			pDevice->NextDoneMCR[MCRListIndex]=pDevice->MCRList[MCRListIndex];
+		  }
+	break;
+      }
+    }
+  }
+return;
+}
+
+
+
+
+/*
+ *
+ */
+int
+ubsec_chipinfo(
+	       DeviceInfo_pt   pDevice,
+	       ubsec_chipinfo_io_pt   pExtChipInfo
+	       ) {
+  
+  if (pExtChipInfo->Status != sizeof(*pExtChipInfo))
+    /* Current driver build is incompatible with calling app */
+    return UBSEC_STATUS_NO_DEVICE; 
+
+  pExtChipInfo->DeviceID = pDevice->DeviceID;
+  pExtChipInfo->BaseAddress = pDevice->BaseAddress;
+  pExtChipInfo->IRQ = pDevice->IRQ;
+
+#ifdef UBSEC_582x_CLASS_DEVICE
+  pExtChipInfo->MaxKeyLen = 2048;
+#else
+  pExtChipInfo->MaxKeyLen = 1024;
+#endif
+  
+
+  pExtChipInfo->Features = ~(0); /* Start with all flags enabled */
+
+#if (UBS_CRYPTONET_ATTRIBUTE != UBS_BIG_ENDIAN)
+  pExtChipInfo->Features &= ~(UBSEC_EXTCHIPINFO_SRL_BE);
+#endif /* Little Endian CryptoNet build */
+
+#if (UBS_CPU_ATTRIBUTE != UBS_BIG_ENDIAN)
+  pExtChipInfo->Features &= ~(UBSEC_EXTCHIPINFO_CPU_BE);
+#endif /* Little Endian CPU build */
+
+#if !defined(UBS_OVERRIDE_LONG_KEY_MODE)
+  pExtChipInfo->Features &= ~(UBSEC_EXTCHIPINFO_KEY_OVERRIDE);
+#endif /* Normal LongKey mode build */
+
+#if (defined(UBSEC_5820) || defined(UBSEC_5805)) 
+  /* SRL was built in "5820 mode" or for 580x chips */
+  pExtChipInfo->Features &= ~(UBSEC_EXTCHIPINFO_ARC4);
+  pExtChipInfo->Features &= ~(UBSEC_EXTCHIPINFO_ARC4_NULL);
+  pExtChipInfo->Features &= ~(UBSEC_EXTCHIPINFO_DBLMODEXP);
+#endif /* UBSEC_5820 or UBSEC_5805 */
+
+#if defined(UBSEC_5805) 
+  pExtChipInfo->Features &= ~(UBSEC_EXTCHIPINFO_SSL);
+#endif /* UBSEC_5805 */
+
+  pExtChipInfo->Status = UBSEC_STATUS_SUCCESS;
+  return UBSEC_STATUS_SUCCESS;
+}
+
+
+
+
+/*
+ *
+ */
+void
+Dump_Registers(DeviceInfo_pt pDevice,int dbg_flag)
+{
+    unsigned long a,b,c,d,e; /* conseq reads help in debugging on PCI trace. */
+    
+    /* check that we will print before polling the device */
+    if( !Dbg_Test( dbg_flag ) )
+	return;
+
+    a=PCI_TO_CPU_LONG( OS_IOMemRead32(pDevice->ControlReg[0]));
+    b=PCI_TO_CPU_LONG( OS_IOMemRead32(pDevice->ControlReg[1]));
+    c=PCI_TO_CPU_LONG( OS_IOMemRead32(pDevice->ControlReg[2]));
+    d=PCI_TO_CPU_LONG( OS_IOMemRead32(pDevice->ControlReg[3]));
+
+    if (UBSEC_IS_KEY_DEVICE(pDevice)) {
+      e=PCI_TO_CPU_LONG( OS_IOMemRead32(pDevice->ControlReg[4])); 
+
+      Dbg_Print((unsigned int)dbg_flag,( "ubsec: -------------------------- Register Dump --------------------------\n" ));
+      Dbg_Print((unsigned int)dbg_flag,( " MCR1[%08x] ctrl[%08x] stat[%08x] dma[%08x] MCR2[%08x]\n",a,b,c,d,e));
+      Dbg_Print((unsigned int)dbg_flag,( "ubsec: -------------------------------------------------------------------\n" ));
+    }
+    else {
+      Dbg_Print((unsigned int)dbg_flag,( "ubsec:  --------------- Register Dump ----------------\n" ));
+      Dbg_Print((unsigned int)dbg_flag,( "ubsec:  MCR [%08x] ctrl[%08x] stat[%08x] dma[%08x]\n",a,b,c,d));
+    }
+
+}
+
+
+#ifdef DVT
+
+int ubsec_dvt_handler(void *context, void *arg)
+{
+  MasterCommand_pt pMCR;
+  unsigned long save_config = 0;
+  DVT_Params_pt DVTparams = (DVT_Params_pt) arg;
+  DeviceInfo_pt pDevice = (DeviceInfo_pt) context;
+  if (DVTparams->Status < sizeof(*DVTparams))
+    /* Current driver build is incompatible with calling app */
+    return UBSEC_STATUS_NO_DEVICE;
+  DVTparams->Status = UBSEC_STATUS_SUCCESS;
+  switch (DVTparams->Command) {
+  case UBSEC_DVT_MCR1_SUSPEND:
+    pDevice->DVTOptions |= UBSEC_SUSPEND_MCR1;
+    DVTparams->OutParameter = pDevice->NextFreeMCR[UBSEC_CIPHER_LIST]->Index; 
+    break;
+  case UBSEC_DVT_MCR2_SUSPEND:
+    pDevice->DVTOptions |= UBSEC_SUSPEND_MCR2;
+    DVTparams->OutParameter = pDevice->NextFreeMCR[UBSEC_KEY_LIST]->Index; 
+    break;
+  case UBSEC_DVT_MCR1_RESUME:
+    pDevice->DVTOptions &= ~UBSEC_SUSPEND_MCR1;
+    PushMCR(pDevice);
+    break;
+  case UBSEC_DVT_MCR2_RESUME:
+    pDevice->DVTOptions &= ~UBSEC_SUSPEND_MCR2;
+    PushMCR(pDevice);
+    break;
+  case UBSEC_DVT_ALL_MCR_RESUME:
+    pDevice->DVTOptions &= ~(UBSEC_SUSPEND_MCR1 | UBSEC_SUSPEND_MCR2);
+    PushMCR(pDevice);
+    break;
+  case UBSEC_DVT_NEXT_MCR1:
+    if (OS_EnterCriticalSection(pDevice,save_config)) {
+      DVTparams->Status = UBSEC_STATUS_DEVICE_BUSY;
+      break;
+    }
+    pMCR = pDevice->NextFreeMCR[UBSEC_CIPHER_LIST];
+    if (pMCR->MCRState)  /* Still busy */ 
+      DVTparams->Status=UBSEC_STATUS_NO_RESOURCE;
+    else if (!pMCR->NumberOfPackets) {
+      /* Do not jump if current MCR has no packets */
+    }
+    else {
+      pDevice->NextFreeMCR[UBSEC_CIPHER_LIST] = (MasterCommand_pt)pMCR->pNextMCR;
+    } 
+    DVTparams->OutParameter = pDevice->NextFreeMCR[UBSEC_CIPHER_LIST]->Index; 
+    OS_LeaveCriticalSection(pDevice,save_config);
+    break;
+  case UBSEC_DVT_NEXT_MCR2:
+    if (OS_EnterCriticalSection(pDevice,save_config)) {
+      DVTparams->Status = UBSEC_STATUS_DEVICE_BUSY;
+      break;
+    }
+    pMCR = pDevice->NextFreeMCR[UBSEC_KEY_LIST];
+    if (pMCR->MCRState)  /* Still busy */ 
+      DVTparams->Status=UBSEC_STATUS_NO_RESOURCE;
+    else if (!pMCR->NumberOfPackets) {
+      /* Do not jump if current MCR has no packets */
+    }
+    else {
+      pDevice->NextFreeMCR[UBSEC_KEY_LIST] = (MasterCommand_pt)pMCR->pNextMCR;
+    }
+    DVTparams->OutParameter = pDevice->NextFreeMCR[UBSEC_KEY_LIST]->Index; 
+    OS_LeaveCriticalSection(pDevice,save_config);
+    break;
+  default:
+    DVTparams->Status = UBSEC_STATUS_INVALID_PARAMETER;
+    break;
+  };
+  return (DVTparams->Status);
+}
+
+#endif /* DVT */
+
+
+void
+ubsec_DumpDeviceInfo(ubsec_DeviceContext_t Context)
+{
+  DeviceInfo_pt pDevice=(DeviceInfo_pt)Context;
+  Dump_Registers(pDevice,DBG_LOG);
+  Dbg_Print(DBG_LOG,("CryptoNet: MCR-0 Index:  Free(%02d) Device(%02d) Done(%02d)\n",
+		     pDevice->NextFreeMCR[0]->Index, pDevice->NextDeviceMCR[0]->Index, pDevice->NextDoneMCR[0]->Index));
+  Dbg_Print(DBG_LOG,("CryptoNet: MCR-1 Index:  Free(%02d) Device(%02d) Done(%02d)\n",
+		     pDevice->NextFreeMCR[1]->Index, pDevice->NextDeviceMCR[1]->Index, pDevice->NextDoneMCR[1]->Index));
+#ifdef UBSEC_STATS
+    Dbg_Print(DBG_LOG,("CryptoNet: DMA Errors %02d\n",
+		       pDevice->Statistics.DMAErrorCount));
+#endif
+}
+
+
diff -urNp linux-8030/drivers/addon/bcm/utils.c linux-8040/drivers/addon/bcm/utils.c
--- linux-8030/drivers/addon/bcm/utils.c
+++ linux-8040/drivers/addon/bcm/utils.c
@@ -0,0 +1,145 @@
+
+/*
+ *  Broadcom Cryptonet Driver software is distributed as is, without any warranty
+ *  of any kind, either express or implied as further specified in the GNU Public
+ *  License. This software may be used and distributed according to the terms of
+ *  the GNU Public License.
+ *
+ * Cryptonet is a registered trademark of Broadcom Corporation.
+ */
+/******************************************************************************
+ *
+ *  Copyright 2000
+ *  Broadcom Corporation
+ *  16215 Alton Parkway
+ *  PO Box 57013
+ *  Irvine CA 92619-7013
+ *
+ *****************************************************************************/
+/* 
+ * Broadcom Corporation uBSec SDK 
+ */
+/*
+ * utils.c: Driver utility functions.
+ */
+/*
+ * Revision History:
+ *
+ * May 2000 SOR/JTT Created.
+ * March 2001 PW Release for Linux 2.4 UP and SMP kenel
+ */
+
+#include "cdevincl.h"	
+#include <linux/sched.h>
+
+
+#ifdef DVT
+  #define MAX_SLEEP_TIME 100*HZ
+#else
+  #define MAX_SLEEP_TIME 3*HZ
+#endif /* DVT */
+
+
+void tv_sub(struct timeval *out, struct timeval *in)
+{
+  if (in->tv_usec > out->tv_usec)  {
+	out->tv_sec--;
+	out->tv_usec += 1000000;
+  }
+  out->tv_sec -= in->tv_sec;
+  out->tv_usec -= in->tv_usec;
+}
+
+void start_time(struct timeval *tv_start)  
+{ 
+  do_gettimeofday(tv_start);
+}
+
+
+unsigned long stop_time(struct timeval *tv_start)
+{
+  struct timeval tv_stop;
+
+  do_gettimeofday(&tv_stop);
+  tv_sub(&tv_stop, tv_start);
+  return ( tv_stop.tv_sec * 1000000 + tv_stop.tv_usec );
+}
+
+#ifndef LINUX2dot2
+
+int Gotosleep(wait_queue_head_t *WaitQ)
+{
+   init_waitqueue_head(WaitQ);
+   sleep_on_timeout(WaitQ, MAX_SLEEP_TIME);
+   return 0;
+}
+
+void wakeup(wait_queue_head_t *WaitQ)
+{
+   wake_up(WaitQ);
+}
+
+#else
+int Gotosleep(struct wait_queue **WaitQ)
+{
+ return sleep_on_timeout(WaitQ,MAX_SLEEP_TIME);
+ 
+#ifdef LATEST_VERSION
+  module_interruptible_sleep_on_timeout(WaitQ,MAX_SLEEP_TIME);
+#else
+  interruptible_sleep_on_timeout(WaitQ,MAX_SLEEP_TIME);
+#endif
+}
+
+void wakeup(struct wait_queue **WaitQ)
+{
+  module_wake_up(WaitQ);
+}                 
+#endif
+
+
+void CmdCompleteCallback(unsigned long CallBackContext,ubsec_Status_t Result)
+{
+	
+  CommandContext_pt  pCommandContext=(CommandContext_pt)CallBackContext;
+  struct timeval	tv_stop;
+
+  memset(&tv_stop, 0, sizeof(tv_stop));
+  do_gettimeofday(&tv_stop);
+  tv_sub(&tv_stop, &pCommandContext->tv_start);
+  pCommandContext->tv_start = tv_stop;
+
+  (pCommandContext->CallBackStatus)++;
+  pCommandContext->Status=Result;
+
+#ifdef GOTOSLEEP
+       wakeup(&pCommandContext->WaitQ);
+#endif
+  return;
+}
+
+
+
+int power_of_2(unsigned long number)
+{
+  if (number < 2) 
+    return 0; 
+  while (!(number & 0x01)) 
+    number = number >> 1;
+  return (number == 1);
+}
+
+
+
+unsigned long next_smaller_power_of_2(unsigned long number)
+{
+  int shift = 0;
+  if (!number) 
+    return 0; 
+  while (!(number & 0x80000000)) {
+    number = number << 1;
+    shift++;
+  }
+  return (0x80000000 >> shift);
+}
+
