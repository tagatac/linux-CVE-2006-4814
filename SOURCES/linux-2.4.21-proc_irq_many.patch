diff -urNp linux-7081/arch/i386/kernel/irq.c linux-7090/arch/i386/kernel/irq.c
--- linux-7081/arch/i386/kernel/irq.c
+++ linux-7090/arch/i386/kernel/irq.c
@@ -32,6 +32,7 @@
 #include <linux/kernel_stat.h>
 #include <linux/irq.h>
 #include <linux/proc_fs.h>
+#include <linux/seq_file.h>
 
 #include <asm/atomic.h>
 #include <asm/io.h>
@@ -131,57 +132,56 @@ atomic_t irq_mis_count;
  * Generic, controller-independent functions:
  */
 
-int get_irq_list(char *buf)
+int show_interrupts(struct seq_file *p, void *v)
 {
 	int i, j;
 	struct irqaction * action;
-	char *p = buf;
 
-	p += sprintf(p, "           ");
+	seq_printf(p, "           ");
 	for (j=0; j<smp_num_cpus; j++)
-		p += sprintf(p, "CPU%d       ",j);
-	*p++ = '\n';
+		seq_printf(p, "CPU%d       ",j);
+	seq_putc(p,'\n');
 
 	for (i = 0 ; i < NR_IRQS ; i++) {
 		action = irq_desc[i].action;
 		if (!action) 
 			continue;
-		p += sprintf(p, "%3d: ",i);
+		seq_printf(p, "%3d: ",i);
 #ifndef CONFIG_SMP
-		p += sprintf(p, "%10u ", kstat_irqs(i));
+		seq_printf(p, "%10u ", kstat_irqs(i));
 #else
 		for (j = 0; j < smp_num_cpus; j++)
-			p += sprintf(p, "%10u ",
+			seq_printf(p, "%10u ",
 				kstat_percpu[cpu_logical_map(j)].irqs[i]);
 #endif
-		p += sprintf(p, " %14s", irq_desc[i].handler->typename);
-		p += sprintf(p, "  %s", action->name);
+		seq_printf(p, " %14s", irq_desc[i].handler->typename);
+		seq_printf(p, "  %s", action->name);
 
 		for (action=action->next; action; action = action->next)
-			p += sprintf(p, ", %s", action->name);
-		*p++ = '\n';
+			seq_printf(p, ", %s", action->name);
+		seq_putc(p,'\n');
 	}
-	p += sprintf(p, "NMI: ");
+	seq_printf(p, "NMI: ");
 	for (j = 0; j < smp_num_cpus; j++)
-		p += sprintf(p, "%10u ",
+		seq_printf(p, "%10u ",
 			nmi_count(cpu_logical_map(j)));
-	p += sprintf(p, "\n");
+	seq_printf(p, "\n");
 #if CONFIG_X86_LOCAL_APIC
-	p += sprintf(p, "LOC: ");
+	seq_printf(p, "LOC: ");
 	for (j = 0; j < smp_num_cpus; j++)
-		p += sprintf(p, "%10u ",
+		seq_printf(p, "%10u ",
 			apic_timer_irqs[cpu_logical_map(j)]);
-	p += sprintf(p, "\n");
+	seq_printf(p, "\n");
 #endif
-	p += sprintf(p, "ERR: %10u\n", atomic_read(&irq_err_count));
+	seq_printf(p, "ERR: %10u\n", atomic_read(&irq_err_count));
 #ifdef CONFIG_X86_IO_APIC
 #ifdef APIC_MISMATCH_DEBUG
-	p += sprintf(p, "MIS: %10u\n", atomic_read(&irq_mis_count));
+	seq_printf(p, "MIS: %10u\n", atomic_read(&irq_mis_count));
 #endif
 #endif
-	return p - buf;
-}
 
+	return 0;
+}
 
 /*
  * Global interrupt locks for SMP. Allow interrupts to come in on any
diff -urNp linux-7081/arch/ppc64/kernel/irq.c linux-7090/arch/ppc64/kernel/irq.c
--- linux-7081/arch/ppc64/kernel/irq.c
+++ linux-7090/arch/ppc64/kernel/irq.c
@@ -360,55 +360,11 @@ void enable_irq(unsigned int irq)
 	spin_unlock_irqrestore(&desc->lock, flags);
 }
 
-/* one would think this function has one foot in the grave */
-int get_irq_list(char *buf)
-{
-   int i, len = 0, j;
-   struct irqaction * action;
-
-   len += sprintf(buf+len, "           ");
-   for (j=0; j<smp_num_cpus; j++)
-       len += sprintf(buf+len, "CPU%d       ",j);
-   *(char *)(buf+len++) = '\n';
-
-   for (i = 0 ; i < NR_IRQS ; i++) {
-       action = irq_desc[i].action;
-       if ( !action || !action->handler )
-           continue;
-       len += sprintf(buf+len, "%3d: ", i);
-#ifdef CONFIG_SMP
-       for (j = 0; j < smp_num_cpus; j++)
-           len += sprintf(buf+len, "%10u ",
-               kstat_percpu[cpu_logical_map(j)].irqs[i]);
-#else
-       len += sprintf(buf+len, "%10u ", kstat_irqs(i));
-#endif /* CONFIG_SMP */
-if ( irq_desc[i].handler )
-len += sprintf(buf+len, " %s ", irq_desc[i].handler->typename );
-else
-len += sprintf(buf+len, "  None      ");
-len += sprintf(buf+len, "%s", (irq_desc[i].status & IRQ_LEVEL) ? "Level " : "Edge  ");
-len += sprintf(buf+len, "    %s",action->name);
-for (action=action->next; action; action = action->next) {
-len += sprintf(buf+len, ", %s", action->name);
-}
-len += sprintf(buf+len, "\n");
-}
-#ifdef CONFIG_SMP
-/* should this be per processor send/receive? */
-len += sprintf(buf+len, "IPI (recv/sent): %10u/%u\n",
-atomic_read(&ipi_recv), atomic_read(&ipi_sent));
-#endif
-len += sprintf(buf+len, "BAD: %10u\n", ppc_spurious_interrupts);
-return len;
-}
-
-
-
 int show_interrupts(struct seq_file *p, void *v)
 {
 	int i, j;
 	struct irqaction * action;
+	unsigned long flags;
 
 	seq_printf(p, "           ");
 	for (j=0; j<smp_num_cpus; j++)
@@ -416,9 +372,10 @@ int show_interrupts(struct seq_file *p, 
 	seq_putc(p, '\n');
 
 	for (i = 0 ; i < NR_IRQS ; i++) {
+		spin_lock_irqsave(&irq_desc[i].lock, flags);
 		action = irq_desc[i].action;
 		if (!action || !action->handler)
-			continue;
+			goto skip;
 		seq_printf(p, "%3d: ", i);		
 #ifdef CONFIG_SMP
 		for (j = 0; j < smp_num_cpus; j++)
@@ -436,12 +393,14 @@ int show_interrupts(struct seq_file *p, 
 		for (action=action->next; action; action = action->next)
 			seq_printf(p, ", %s", action->name);
 		seq_putc(p, '\n');
+skip:
+		spin_unlock_irqrestore(&irq_desc[i].lock, flags);
 	}
 #ifdef CONFIG_SMP
 	/* should this be per processor send/receive? */
 	seq_printf(p, "IPI (recv/sent): %10u/%u\n",
 		       atomic_read(&ipi_recv), atomic_read(&ipi_sent));
-#endif		
+#endif
 	seq_printf(p, "BAD: %10u\n", ppc_spurious_interrupts);
 	return 0;
 }
diff -urNp linux-7081/fs/proc/proc_misc.c linux-7090/fs/proc/proc_misc.c
--- linux-7081/fs/proc/proc_misc.c
+++ linux-7090/fs/proc/proc_misc.c
@@ -366,7 +366,7 @@ static int kstat_read_proc(char *page, c
 			kstat_sum(pswpout),
 			sum
 	);
-#if !defined(CONFIG_ARCH_S390) && !defined(CONFIG_ALPHA)
+#if !defined(CONFIG_ARCH_S390) && !defined(CONFIG_ALPHA) && !defined(CONFIG_PPC64)
 	for (i = 0 ; i < NR_IRQS ; i++)
 		proc_sprintf(page, &off, &len,
 			     " %u", kstat_irqs(i));
@@ -414,7 +414,7 @@ static int devices_read_proc(char *page,
 	return proc_calc_metrics(page, start, off, count, eof, len);
 }
 
-#if !defined(CONFIG_ARCH_S390)
+#if (!defined(CONFIG_ARCH_S390) && !defined(CONFIG_PPC64) && !defined(CONFIG_X86)) || defined(CONFIG_X86_64)
 static int interrupts_read_proc(char *page, char **start, off_t off,
 				 int count, int *eof, void *data)
 {
@@ -423,6 +423,34 @@ static int interrupts_read_proc(char *pa
 }
 #endif
 
+#if defined(CONFIG_PPC64) || (defined(CONFIG_X86) && !defined(CONFIG_X86_64))
+extern int show_interrupts(struct seq_file *p, void *v);
+static int interrupts_open(struct inode *inode, struct file *file)
+{
+	unsigned size = PAGE_SIZE;
+	char *buf = kmalloc(size, GFP_KERNEL);
+	struct seq_file *m;
+	int res;
+
+	if (!buf)
+		return -ENOMEM;
+	res = single_open(file, show_interrupts, NULL);
+	if (!res) {
+		m = file->private_data;
+		m->buf = buf;
+		m->size = size;
+	} else
+		kfree(buf);
+	return res;
+}
+static struct file_operations proc_interrupts_operations = {
+	.open		= interrupts_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+#endif
+
 static int filesystems_read_proc(char *page, char **start, off_t off,
 				 int count, int *eof, void *data)
 {
@@ -613,7 +641,7 @@ void __init proc_misc_init(void)
 #endif
 		{"stat",	kstat_read_proc},
 		{"devices",	devices_read_proc},
-#if !defined(CONFIG_ARCH_S390)
+#if (!defined(CONFIG_ARCH_S390) && !defined(CONFIG_PPC64) && !defined(CONFIG_X86)) || defined(CONFIG_X86_64)
 		{"interrupts",	interrupts_read_proc},
 #endif
 		{"filesystems",	filesystems_read_proc},
@@ -640,6 +668,9 @@ void __init proc_misc_init(void)
 		entry->proc_fops = &proc_kmsg_operations;
 	create_seq_entry("cpuinfo", 0, &proc_cpuinfo_operations);
 	create_seq_entry("partitions", 0, &proc_partitions_operations);
+#if defined(CONFIG_PPC64) || (defined(CONFIG_X86) && !defined(CONFIG_X86_64))
+	create_seq_entry("interrupts", 0, &proc_interrupts_operations);
+#endif
 	create_seq_entry("slabinfo",S_IWUSR|S_IRUGO,&proc_slabinfo_operations);
 #ifdef CONFIG_MODULES
 	create_seq_entry("ksyms", 0, &proc_ksyms_operations);
