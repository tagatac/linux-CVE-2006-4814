diff -urNp linux-459/arch/s390/config.in linux-460/arch/s390/config.in
--- linux-459/arch/s390/config.in
+++ linux-460/arch/s390/config.in
@@ -63,6 +63,16 @@ if [ "$CONFIG_NET" = "y" ]; then
   source net/Config.in
 fi
 
+mainmenu_option next_comment
+comment 'SCSI support'
+
+tristate 'SCSI support' CONFIG_SCSI
+
+if [ "$CONFIG_SCSI" != "n" ]; then
+   source drivers/scsi/Config.in
+fi
+endmenu
+
 source fs/Config.in
 
 source arch/s390/oprofile/Config.in
diff -urNp linux-459/arch/s390/mm/fault.c linux-460/arch/s390/mm/fault.c
--- linux-459/arch/s390/mm/fault.c
+++ linux-460/arch/s390/mm/fault.c
@@ -503,8 +503,6 @@ asmlinkage void
 pfault_interrupt(struct pt_regs *regs, __u16 error_code)
 {
 	struct task_struct *tsk;
-	wait_queue_head_t queue;
-	wait_queue_head_t *qp;
 	__u16 subcode;
 
 	/*
@@ -523,42 +521,32 @@ pfault_interrupt(struct pt_regs *regs, _
 	tsk = (struct task_struct *)
 		(*((unsigned long *) __LC_PFAULT_INTPARM) - THREAD_SIZE);
 	
-	/*
-	 * We got all needed information from the lowcore and can
-	 * now safely switch on interrupts.
-	 */
-	if (regs->psw.mask & PSW_PROBLEM_STATE)
-		__sti();
-
 	if (subcode & 0x0080) {
 		/* signal bit is set -> a page has been swapped in by VM */
-		qp = (wait_queue_head_t *)
-			xchg(&tsk->thread.pfault_wait, -1);
-		if (qp != NULL) {
+		if (xchg(&tsk->thread.pfault_wait, -1) != 0) {
 			/* Initial interrupt was faster than the completion
 			 * interrupt. pfault_wait is valid. Set pfault_wait
 			 * back to zero and wake up the process. This can
 			 * safely be done because the task is still sleeping
-			 * and can't procude new pfaults. */
+			 * and can't produce new pfaults. */
+			task_lock(tsk);
 			tsk->thread.pfault_wait = 0ULL;
-			wake_up(qp);
+			wake_up_process(tsk);
+			task_unlock(tsk);
 		}
 	} else {
 		/* signal bit not set -> a real page is missing. */
-                init_waitqueue_head (&queue);
-		qp = (wait_queue_head_t *)
-			xchg(&tsk->thread.pfault_wait, (addr_t) &queue);
-		if (qp != NULL) {
+		set_task_state(tsk, TASK_UNINTERRUPTIBLE);
+		if (xchg(&tsk->thread.pfault_wait, 1) != 0) {
 			/* Completion interrupt was faster than the initial
 			 * interrupt (swapped in a -1 for pfault_wait). Set
 			 * pfault_wait back to zero and exit. This can be
 			 * done safely because tsk is running in kernel 
 			 * mode and can't produce new pfaults. */
 			tsk->thread.pfault_wait = 0ULL;
-		}
-
-                /* go to sleep */
-                wait_event(queue, tsk->thread.pfault_wait == 0ULL);
+			set_task_state(tsk, TASK_RUNNING);
+		} else
+			tsk->need_resched = 1;
 	}
 }
 #endif
diff -urNp linux-459/arch/s390x/config.in linux-460/arch/s390x/config.in
--- linux-459/arch/s390x/config.in
+++ linux-460/arch/s390x/config.in
@@ -68,6 +68,16 @@ if [ "$CONFIG_NET" = "y" ]; then
   source net/Config.in
 fi
 
+mainmenu_option next_comment
+comment 'SCSI support'
+
+tristate 'SCSI support' CONFIG_SCSI
+
+if [ "$CONFIG_SCSI" != "n" ]; then
+   source drivers/scsi/Config.in
+fi
+endmenu
+
 source fs/Config.in
 
 source arch/s390x/oprofile/Config.in
diff -urNp linux-459/arch/s390x/mm/fault.c linux-460/arch/s390x/mm/fault.c
--- linux-459/arch/s390x/mm/fault.c
+++ linux-460/arch/s390x/mm/fault.c
@@ -415,8 +415,6 @@ asmlinkage void
 pfault_interrupt(struct pt_regs *regs, __u16 error_code)
 {
 	struct task_struct *tsk;
-	wait_queue_head_t queue;
-	wait_queue_head_t *qp;
 	__u16 subcode;
 
 	/*
@@ -435,42 +433,32 @@ pfault_interrupt(struct pt_regs *regs, _
 	tsk = (struct task_struct *)
 		(*((unsigned long *) __LC_PFAULT_INTPARM) - THREAD_SIZE);
 
-	/*
-	 * We got all needed information from the lowcore and can
-	 * now safely switch on interrupts.
-	 */
-	if (regs->psw.mask & PSW_PROBLEM_STATE)
-		__sti();
-
 	if (subcode & 0x0080) {
 		/* signal bit is set -> a page has been swapped in by VM */
-		qp = (wait_queue_head_t *)
-			xchg(&tsk->thread.pfault_wait, -1);
-		if (qp != NULL) {
+		if (xchg(&tsk->thread.pfault_wait, -1) != 0) {
 			/* Initial interrupt was faster than the completion
 			 * interrupt. pfault_wait is valid. Set pfault_wait
 			 * back to zero and wake up the process. This can
 			 * safely be done because the task is still sleeping
-			 * and can't procude new pfaults. */
+			 * and can't produce new pfaults. */
+			task_lock(tsk);
 			tsk->thread.pfault_wait = 0ULL;
-			wake_up(qp);
+			wake_up_process(tsk);
+			task_unlock(tsk);
 		}
 	} else {
 		/* signal bit not set -> a real page is missing. */
-                init_waitqueue_head (&queue);
-		qp = (wait_queue_head_t *)
-			xchg(&tsk->thread.pfault_wait, (addr_t) &queue);
-		if (qp != NULL) {
+		set_task_state(tsk, TASK_UNINTERRUPTIBLE);
+		if (xchg(&tsk->thread.pfault_wait, 1) != 0) {
 			/* Completion interrupt was faster than the initial
 			 * interrupt (swapped in a -1 for pfault_wait). Set
 			 * pfault_wait back to zero and exit. This can be
 			 * done safely because tsk is running in kernel 
 			 * mode and can't produce new pfaults. */
 			tsk->thread.pfault_wait = 0ULL;
-		}
-
-                /* go to sleep */
-                wait_event(queue, tsk->thread.pfault_wait == 0ULL);
+			set_task_state(tsk, TASK_RUNNING);
+		} else
+			tsk->need_resched = 1;
 	}
 }
 #endif
diff -urNp linux-459/drivers/s390/Config.in linux-460/drivers/s390/Config.in
--- linux-459/drivers/s390/Config.in
+++ linux-460/drivers/s390/Config.in
@@ -33,6 +33,11 @@ fi
 
 endmenu
 
+# To include everything would be correct, but disruptive:
+#source drivers/block/Config.in
+# So, we just add missing parts by value here, as a bugfix.
+bool 'Per partition statistics in /proc/partitions' CONFIG_BLK_STATS
+
 source drivers/md/Config.in
 
 mainmenu_option next_comment
@@ -67,6 +72,13 @@ if [ "$CONFIG_S390_TAPE" != "n" ]; then
   comment 'S/390 tape hardware support'
   dep_tristate '   Support for 3480/3490 tape hardware' CONFIG_S390_TAPE_34XX $CONFIG_S390_TAPE
 fi
+
+comment 'Watchdog Cards'
+bool 'Watchdog Timer Support'   CONFIG_WATCHDOG 
+if [ "$CONFIG_WATCHDOG" != "n" ]; then
+   bool '  Disable watchdog shutdown on close' CONFIG_WATCHDOG_NOWAYOUT
+   tristate '  Software Watchdog' CONFIG_SOFT_WATCHDOG
+fi
 endmenu
 
 if [ "$CONFIG_NET" = "y" ]; then
diff -urNp linux-459/drivers/s390/char/ctrlchar.c linux-460/drivers/s390/char/ctrlchar.c
--- linux-459/drivers/s390/char/ctrlchar.c
+++ linux-460/drivers/s390/char/ctrlchar.c
@@ -11,7 +11,10 @@
 #include <linux/stddef.h>
 #include <linux/sysrq.h>
 #include <linux/ctype.h>
+#include <asm/spinlock.h> /* P3: interrupt.h has extern spinlock_t foo */
 #include <linux/interrupt.h>
+#include <linux/tqueue.h>
+#include <linux/tty.h>
 
 #include <asm/ctrlchar.h>
 
diff -urNp linux-459/drivers/s390/misc/chandev.c linux-460/drivers/s390/misc/chandev.c
--- linux-459/drivers/s390/misc/chandev.c
+++ linux-460/drivers/s390/misc/chandev.c
@@ -2470,6 +2470,7 @@ static int chandev_setup(int in_read_con
 					goto BadArgs;
 					
 				}
+				break;
 			case del_auto_msck_stridx*stridx_mult:
 			case (del_auto_msck_stridx*stridx_mult)|iscomma:
 				switch(ints[0])
@@ -2482,6 +2483,7 @@ static int chandev_setup(int in_read_con
 				default:
 					goto BadArgs;
 				}
+				break;
 			case del_noauto_stridx*stridx_mult:
 				chandev_free_all_list((list **)&chandev_noauto_head);
 				break;
diff -urNp linux-459/drivers/s390/net/ctcmain.c linux-460/drivers/s390/net/ctcmain.c
--- linux-459/drivers/s390/net/ctcmain.c
+++ linux-460/drivers/s390/net/ctcmain.c
@@ -2313,6 +2313,7 @@ static void ctc_irq_handler (int irq, vo
 		fsm_event(ch->fsm, CH_EVENT_IRQ, ch);
 
  done:
+	;
 }
 
 /**
diff -urNp linux-459/drivers/s390/s390dyn.c linux-460/drivers/s390/s390dyn.c
--- linux-459/drivers/s390/s390dyn.c
+++ linux-460/drivers/s390/s390dyn.c
@@ -10,10 +10,12 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/smp_lock.h>
+#include <linux/string.h>
 
 #include <asm/irq.h>
 #include <asm/s390io.h>
 #include <asm/s390dyn.h>
+#include <asm/errno.h>
 
 static struct list_head devreg_anchor = LIST_HEAD_INIT(devreg_anchor);
 static spinlock_t  dyn_lock           = SPIN_LOCK_UNLOCKED;
diff -urNp linux-459/drivers/s390/s390io.c linux-460/drivers/s390/s390io.c
--- linux-459/drivers/s390/s390io.c
+++ linux-460/drivers/s390/s390io.c
@@ -48,7 +48,8 @@
 #include <linux/module.h>
 #include <linux/config.h>
 #include <linux/errno.h>
-#include <linux/kernel_stat.h>
+// #include <linux/time.h>	/* P3: for Doug's kernel_stat.h with accounting */
+// #include <linux/kernel_stat.h>
 #include <linux/signal.h>
 #include <linux/sched.h>
 #include <linux/interrupt.h>
diff -urNp linux-459/fs/partitions/ibm.c linux-460/fs/partitions/ibm.c
--- linux-459/fs/partitions/ibm.c
+++ linux-460/fs/partitions/ibm.c
@@ -9,6 +9,7 @@
  * 07/10/00 Fixed detection of CMS formatted disks     
  * 02/13/00 VTOC partition support added
  * 12/27/01 fixed PL030593 (CMS reserved minidisk not detected on 64 bit)
+ * 07/24/03 no longer using contents of freed page for CMS label recognition (BZ3611)
  */
 
 #include <linux/config.h>
@@ -141,7 +142,7 @@ ibm_partition(struct gendisk *hd, struct
 		/*
 		 * VM style CMS1 labeled disk
 		 */
-		int *label = (int *) data;
+		int *label = (int *) vlabel;
 
 		if (label[13] != 0) {
 			printk("CMS1/%8s(MDSK):", name);
diff -urNp linux-459/include/asm-s390/dma.h linux-460/include/asm-s390/dma.h
--- linux-459/include/asm-s390/dma.h
+++ linux-460/include/asm-s390/dma.h
@@ -13,4 +13,7 @@
 
 #define MAX_DMA_ADDRESS         0x80000000
 
+/* This obviously does nothing good on our platform, it lets scsi to link */
+extern void free_dma(unsigned int dmanr);
+
 #endif /* _ASM_DMA_H */
diff -urNp linux-459/include/asm-s390/hardirq.h linux-460/include/asm-s390/hardirq.h
--- linux-459/include/asm-s390/hardirq.h
+++ linux-460/include/asm-s390/hardirq.h
@@ -15,7 +15,7 @@
 #include <linux/config.h>
 #include <linux/threads.h>
 #include <asm/lowcore.h>
-#include <linux/sched.h>
+// #include <linux/sched.h>  P3
 
 /* entry.S is sensitive to the offsets of these fields */
 typedef struct {
diff -urNp linux-459/include/asm-s390/io.h linux-460/include/asm-s390/io.h
--- linux-459/include/asm-s390/io.h
+++ linux-460/include/asm-s390/io.h
@@ -43,7 +43,8 @@ extern inline void * phys_to_virt(unsign
 /*
  * Change "struct page" to physical address.
  */
-#define page_to_phys(page)	((page - mem_map) << PAGE_SHIFT)
+/* This allows up to 4GB of RAM. They run s390x on bigger boxes anyway. */
+#define page_to_phys(page)	(((page) - mem_map) << PAGE_SHIFT)
 
 extern void * __ioremap(unsigned long offset, unsigned long size, unsigned long flags);
 
diff -urNp linux-459/include/asm-s390/irq.h linux-460/include/asm-s390/irq.h
--- linux-459/include/asm-s390/irq.h
+++ linux-460/include/asm-s390/irq.h
@@ -4,6 +4,7 @@
 #include <linux/config.h>
 #ifdef __KERNEL__
 #include <asm/hardirq.h>
+#include <asm/system.h>
 
 /*
  * How many IRQ's for S390 ?!?
@@ -978,30 +979,6 @@ static inline void irq_exit(int cpu, uns
 
 #endif /* CONFIG_SMP */
 
-/*
- * x86 profiling function, SMP safe. We might want to do this in
- * assembly totally?
- */
-extern char _stext;
-static inline void s390_do_profile (unsigned long addr)
-{
-        if (prof_buffer && current->pid) {
-#ifndef CONFIG_ARCH_S390X
-                addr &= 0x7fffffff;
-#endif
-                addr -= (unsigned long) &_stext;
-                addr >>= prof_shift;
-                /*
-                 * Don't ignore out-of-bounds EIP values silently,
-                 * put them into the last histogram slot, so if
-                 * present, they will show up as a sharp peak.
-                 */
-                if (addr > prof_len-1)
-                        addr = prof_len-1;
-                atomic_inc((atomic_t *)&prof_buffer[addr]);
-        }
-}
-
 #include <asm/s390io.h>
 
 #define get_irq_lock(irq) &ioinfo[irq]->irq_lock
diff -urNp linux-459/include/asm-s390/param.h linux-460/include/asm-s390/param.h
--- linux-459/include/asm-s390/param.h
+++ linux-460/include/asm-s390/param.h
@@ -11,6 +11,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	4096
diff -urNp linux-459/include/asm-s390/smplock.h linux-460/include/asm-s390/smplock.h
--- linux-459/include/asm-s390/smplock.h
+++ linux-460/include/asm-s390/smplock.h
@@ -8,6 +8,8 @@
 
 #include <linux/interrupt.h>
 #include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <asm/current.h>
 
 extern spinlock_t kernel_flag;
 
diff -urNp linux-459/include/asm-s390/spinlock.h linux-460/include/asm-s390/spinlock.h
--- linux-459/include/asm-s390/spinlock.h
+++ linux-460/include/asm-s390/spinlock.h
@@ -76,6 +76,8 @@ typedef struct {
 
 #define rwlock_init(x)	do { *(x) = RW_LOCK_UNLOCKED; } while(0)
 
+#define rwlock_is_locked(x) ((x)->lock != 0)
+
 #define read_lock(rw)   \
         asm volatile("   l     2,0(%0)\n"   \
                      "   j     1f\n"     \
diff -urNp linux-459/include/asm-s390/system.h linux-460/include/asm-s390/system.h
--- linux-459/include/asm-s390/system.h
+++ linux-460/include/asm-s390/system.h
@@ -147,6 +147,13 @@ static inline unsigned long __xchg(unsig
 #define __restore_flags(x) \
         __asm__ __volatile__("ssm   0(%0)" : : "a" (&x) : "memory")
 
+#define irqs_disabled()			\
+({					\
+	unsigned long flags;		\
+	__save_flags(flags);		\
+	!((flags >> 24) & 3);		\
+})
+
 #define __load_psw(psw) \
 	__asm__ __volatile__("lpsw 0(%0)" : : "a" (&psw) : "cc" );
 
diff -urNp linux-459/include/asm-s390x/dma.h linux-460/include/asm-s390x/dma.h
--- linux-459/include/asm-s390x/dma.h
+++ linux-460/include/asm-s390x/dma.h
@@ -13,4 +13,7 @@
    We use the existing DMA zone mechanism to handle this. */
 #define MAX_DMA_ADDRESS         0x80000000
 
+/* This obviously does nothing good on our platform, it lets scsi to link */
+extern void free_dma(unsigned int dmanr);
+
 #endif /* _ASM_DMA_H */
diff -urNp linux-459/include/asm-s390x/hardirq.h linux-460/include/asm-s390x/hardirq.h
--- linux-459/include/asm-s390x/hardirq.h
+++ linux-460/include/asm-s390x/hardirq.h
@@ -15,7 +15,7 @@
 #include <linux/config.h>
 #include <linux/threads.h>
 #include <asm/lowcore.h>
-#include <linux/sched.h>
+// #include <linux/sched.h> P3
 
 /* entry.S is sensitive to the offsets of these fields */
 typedef struct {
diff -urNp linux-459/include/asm-s390x/io.h linux-460/include/asm-s390x/io.h
--- linux-459/include/asm-s390x/io.h
+++ linux-460/include/asm-s390x/io.h
@@ -43,7 +43,7 @@ extern inline void * phys_to_virt(unsign
 /*
  * Change "struct page" to physical address.
  */
-#define page_to_phys(page)	((page - mem_map) << PAGE_SHIFT)
+#define page_to_phys(page)	(((page) - mem_map) << PAGE_SHIFT)
 
 extern void * __ioremap(unsigned long offset, unsigned long size, unsigned long flags);
 
diff -urNp linux-459/include/asm-s390x/irq.h linux-460/include/asm-s390x/irq.h
--- linux-459/include/asm-s390x/irq.h
+++ linux-460/include/asm-s390x/irq.h
@@ -4,6 +4,7 @@
 #include <linux/config.h>
 #ifdef __KERNEL__
 #include <asm/hardirq.h>
+#include <asm/system.h>
 
 /*
  * How many IRQ's for S390 ?!?
@@ -979,30 +980,6 @@ static inline void irq_exit(int cpu, uns
 
 #endif /* CONFIG_SMP */
 
-/*
- * x86 profiling function, SMP safe. We might want to do this in
- * assembly totally?
- */
-extern char _stext;
-static inline void s390_do_profile (unsigned long addr)
-{
-        if (prof_buffer && current->pid) {
-#ifndef CONFIG_ARCH_S390X
-                addr &= 0x7fffffff;
-#endif
-                addr -= (unsigned long) &_stext;
-                addr >>= prof_shift;
-                /*
-                 * Don't ignore out-of-bounds EIP values silently,
-                 * put them into the last histogram slot, so if
-                 * present, they will show up as a sharp peak.
-                 */
-                if (addr > prof_len-1)
-                        addr = prof_len-1;
-                atomic_inc((atomic_t *)&prof_buffer[addr]);
-        }
-}
-
 #include <asm/s390io.h>
 
 #define get_irq_lock(irq) &ioinfo[irq]->irq_lock
diff -urNp linux-459/include/asm-s390x/smplock.h linux-460/include/asm-s390x/smplock.h
--- linux-459/include/asm-s390x/smplock.h
+++ linux-460/include/asm-s390x/smplock.h
@@ -8,6 +8,8 @@
 
 #include <linux/interrupt.h>
 #include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <asm/current.h>
 
 extern spinlock_t kernel_flag;
 
diff -urNp linux-459/include/asm-s390x/spinlock.h linux-460/include/asm-s390x/spinlock.h
--- linux-459/include/asm-s390x/spinlock.h
+++ linux-460/include/asm-s390x/spinlock.h
@@ -91,6 +91,8 @@ typedef struct {
 
 #define rwlock_init(x)	do { *(x) = RW_LOCK_UNLOCKED; } while(0)
 
+#define rwlock_is_locked(x) ((x)->lock != 0)
+
 #define read_lock(rw)   \
         asm volatile("   lg    2,0(%0)\n"   \
                      "   j     1f\n"     \
diff -urNp linux-459/include/asm-s390x/system.h linux-460/include/asm-s390x/system.h
--- linux-459/include/asm-s390x/system.h
+++ linux-460/include/asm-s390x/system.h
@@ -159,6 +159,13 @@ static inline unsigned long __xchg(unsig
 #define __restore_flags(x) \
         __asm__ __volatile__("ssm   0(%0)" : : "a" (&x) : "memory")
 
+#define irqs_disabled()			\
+({					\
+	unsigned long flags;		\
+	__save_flags(flags);		\
+	!((flags >> 56) & 3);		\
+})
+
 #define __load_psw(psw) \
         __asm__ __volatile__("lpswe 0(%0)" : : "a" (&psw) : "cc" );
 
