diff -urNp linux-7000/drivers/block/blkpg.c linux-7001/drivers/block/blkpg.c
--- linux-7000/drivers/block/blkpg.c
+++ linux-7001/drivers/block/blkpg.c
@@ -91,7 +91,7 @@ static int get_last_sector( kdev_t dev, 
 int add_partition(kdev_t dev, struct blkpg_partition *p) {
 	struct gendisk *g;
 	long long ppstart, pplength;
-	long pstart, plength;
+	unsigned long pstart, plength;
 	int i, drive, first_minor, end_minor, minor;
 
 	/* convert bytes to sectors, check for fit in a hd_struct */
diff -urNp linux-7000/drivers/block/ll_rw_blk.c linux-7001/drivers/block/ll_rw_blk.c
--- linux-7000/drivers/block/ll_rw_blk.c
+++ linux-7001/drivers/block/ll_rw_blk.c
@@ -1244,7 +1244,7 @@ void generic_make_request (int rw, struc
 			   when mounting a device. */
 			printk(KERN_INFO
 			       "attempt to access beyond end of device\n");
-			printk(KERN_INFO "%s: rw=%d, want=%ld, limit=%d\n",
+			printk(KERN_INFO "%s: rw=%d, want=%lu, limit=%u\n",
 			       kdevname(bh->b_rdev), rw,
 			       (sector + count)>>1, minorsize);
 
@@ -1266,7 +1266,7 @@ void generic_make_request (int rw, struc
 		if (!q) {
 			printk(KERN_ERR
 			       "generic_make_request: Trying to access "
-			       "nonexistent block-device %s (%ld)\n",
+			       "nonexistent block-device %s (%lu)\n",
 			       kdevname(bh->b_rdev), bh->b_rsector);
 			buffer_IO_error(bh);
 			break;
diff -urNp linux-7000/drivers/md/linear.c linux-7001/drivers/md/linear.c
--- linux-7000/drivers/md/linear.c
+++ linux-7001/drivers/md/linear.c
@@ -125,14 +125,14 @@ static int linear_make_request (mddev_t 
         linear_conf_t *conf = mddev_to_conf(mddev);
         struct linear_hash *hash;
         dev_info_t *tmp_dev;
-        long block;
+        unsigned long block;
 
 	block = bh->b_rsector >> 1;
 	hash = conf->hash_table + (block / conf->smallest->size);
   
 	if (block >= (hash->dev0->size + hash->dev0->offset)) {
 		if (!hash->dev1) {
-			printk ("linear_make_request : hash->dev1==NULL for block %ld\n",
+			printk ("linear_make_request : hash->dev1==NULL for block %lu\n",
 						block);
 			buffer_IO_error(bh);
 			return 0;
@@ -143,7 +143,7 @@ static int linear_make_request (mddev_t 
     
 	if (block >= (tmp_dev->size + tmp_dev->offset)
 				|| block < tmp_dev->offset) {
-		printk ("linear_make_request: Block %ld out of bounds on dev %s size %ld offset %ld\n", block, kdevname(tmp_dev->dev), tmp_dev->size, tmp_dev->offset);
+		printk ("linear_make_request: Block %lu out of bounds on dev %s size %lu offset %lu\n", block, kdevname(tmp_dev->dev), tmp_dev->size, tmp_dev->offset);
 		buffer_IO_error(bh);
 		return 0;
 	}
diff -urNp linux-7000/drivers/md/md.c linux-7001/drivers/md/md.c
--- linux-7000/drivers/md/md.c
+++ linux-7001/drivers/md/md.c
@@ -1038,7 +1038,7 @@ static int write_disk_sb(mdk_rdev_t * rd
 	dev = rdev->dev;
 	sb_offset = calc_dev_sboffset(dev, rdev->mddev, 1);
 	if (rdev->sb_offset != sb_offset) {
-		printk(KERN_INFO "%s's sb offset has changed from %ld to %ld, skipping\n",
+		printk(KERN_INFO "%s's sb offset has changed from %lu to %lu, skipping\n",
 		       partition_name(dev), rdev->sb_offset, sb_offset);
 		goto skip;
 	}
@@ -1049,12 +1049,12 @@ static int write_disk_sb(mdk_rdev_t * rd
 	 */
 	size = calc_dev_size(dev, rdev->mddev, 1);
 	if (size != rdev->size) {
-		printk(KERN_INFO "%s's size has changed from %ld to %ld since import, skipping\n",
+		printk(KERN_INFO "%s's size has changed from %lu to %lu since import, skipping\n",
 		       partition_name(dev), rdev->size, size);
 		goto skip;
 	}
 
-	printk(KERN_INFO "(write) %s's sb offset: %ld\n", partition_name(dev), sb_offset);
+	printk(KERN_INFO "(write) %s's sb offset: %lu\n", partition_name(dev), sb_offset);
 
 	if (!sync_page_io(dev, sb_offset<<1, MD_SB_BYTES, rdev->sb_page, WRITE)) {
 		printk("md: write_disk_sb failed for device %s\n", partition_name(dev));
@@ -1675,7 +1675,7 @@ static int device_size_calculation(mddev
 		rdev->size = calc_dev_size(rdev->dev, mddev, persistent);
 		if (rdev->size < sb->chunk_size / 1024) {
 			printk(KERN_WARNING
-				"md: Dev %s smaller than chunk_size: %ldk < %dk\n",
+				"md: Dev %s smaller than chunk_size: %luk < %uk\n",
 				partition_name(rdev->dev),
 				rdev->size, sb->chunk_size / 1024);
 			return -EINVAL;
@@ -1730,7 +1730,7 @@ static int device_size_calculation(mddev
 		mdidx(mddev), readahead*(PAGE_SIZE/1024));
 
 	printk(KERN_INFO
-		"md%d: %d data-disks, max readahead per data-disk: %ldk\n",
+		"md%d: %d data-disks, max readahead per data-disk: %luk\n",
 			mdidx(mddev), data_disks, readahead/data_disks*(PAGE_SIZE/1024));
 	return 0;
 abort:
@@ -1877,7 +1877,7 @@ static int do_md_run(mddev_t * mddev)
 	 */
 	md_hd_struct[mdidx(mddev)].start_sect = 0;
 	register_disk(&md_gendisk, MKDEV(MAJOR_NR,mdidx(mddev)),
-			1, &md_fops, md_size[mdidx(mddev)]<<1);
+			1, &md_fops, (unsigned long)md_size[mdidx(mddev)] << 1);
 
 	read_ahead[MD_MAJOR] = 1024;
 	return (0);
diff -urNp linux-7000/drivers/md/raid5.c linux-7001/drivers/md/raid5.c
--- linux-7000/drivers/md/raid5.c
+++ linux-7001/drivers/md/raid5.c
@@ -266,7 +266,7 @@ static struct stripe_head *get_active_st
 			 * assert that we want to change it again
 			 */
 			int oldsize = conf->buffer_size;
-			PRINTK("get_stripe %ld/%d buffer_size is %d, %d active\n", sector, size, conf->buffer_size, atomic_read(&conf->active_stripes));
+			PRINTK("get_stripe %lu/%d buffer_size is %d, %d active\n", sector, size, conf->buffer_size, atomic_read(&conf->active_stripes));
 			if (size==0)
 				wait_event_lock_irq(conf->wait_for_stripe,
 						    conf->buffer_size,
@@ -277,7 +277,7 @@ static struct stripe_head *get_active_st
 					wait_event_lock_irq(conf->wait_for_stripe,
 							    atomic_read(&conf->active_stripes)==0 || conf->buffer_size,
 							    conf->device_lock);
-					PRINTK("waited and now  %ld/%d buffer_size is %d - %d active\n", sector, size,
+					PRINTK("waited and now  %lu/%d buffer_size is %d - %d active\n", sector, size,
 					       conf->buffer_size, atomic_read(&conf->active_stripes));
 				}
 
@@ -787,7 +787,7 @@ static void add_stripe_bh (struct stripe
 	else
 		bhp = &sh->bh_write[dd_idx];
 	while (*bhp) {
-		printk(KERN_NOTICE "raid5: multiple %d requests for sector %ld\n", rw, sh->sector);
+		printk(KERN_NOTICE "raid5: multiple %d requests for sector %lu\n", rw, sh->sector);
 		bhp = & (*bhp)->b_reqnext;
 	}
 	*bhp = bh;
@@ -831,7 +831,7 @@ static void handle_stripe(struct stripe_
 	int failed_num=0;
 	struct buffer_head *bh;
 
-	PRINTK("handling stripe %ld, cnt=%d, pd_idx=%d\n", sh->sector, atomic_read(&sh->count), sh->pd_idx);
+	PRINTK("handling stripe %lu, cnt=%d, pd_idx=%d\n", sh->sector, atomic_read(&sh->count), sh->pd_idx);
 	memset(action, 0, sizeof(action));
 
 	spin_lock(&sh->lock);
@@ -1007,7 +1007,7 @@ static void handle_stripe(struct stripe_
 				else rcw += 2*disks;
 			}
 		}
-		PRINTK("for sector %ld, rmw=%d rcw=%d\n", sh->sector, rmw, rcw);
+		PRINTK("for sector %lu, rmw=%d rcw=%d\n", sh->sector, rmw, rcw);
 		set_bit(STRIPE_HANDLE, &sh->state);
 		if (rmw < rcw && rmw > 0)
 			/* prefer read-modify-write, but need to get some data */
@@ -1146,13 +1146,13 @@ static void handle_stripe(struct stripe_
 				bh->b_dev = spare->dev;
 			else skip=1;
 			if (!skip) {
-				PRINTK("for %ld schedule op %d on disc %d\n", sh->sector, action[i]-1, i);
+				PRINTK("for %lu schedule op %d on disc %d\n", sh->sector, action[i]-1, i);
 				atomic_inc(&sh->count);
 				bh->b_rdev = bh->b_dev;
 				bh->b_rsector = bh->b_blocknr * (bh->b_size>>9);
 				generic_make_request(action[i]-1, bh);
 			} else {
-				PRINTK("skip op %d on disc %d for sector %ld\n", action[i]-1, i, sh->sector);
+				PRINTK("skip op %d on disc %d for sector %lu\n", action[i]-1, i, sh->sector);
 				clear_bit(BH_Lock, &bh->b_state);
 				set_bit(STRIPE_HANDLE, &sh->state);
 			}
@@ -1664,12 +1664,12 @@ static void print_sh (struct stripe_head
 {
 	int i;
 
-	printk("sh %lu, size %d, pd_idx %d, state %ld.\n", sh->sector, sh->size, sh->pd_idx, sh->state);
+	printk("sh %lu, size %d, pd_idx %d, state %lu.\n", sh->sector, sh->size, sh->pd_idx, sh->state);
 	printk("sh %lu,  count %d.\n", sh->sector, atomic_read(&sh->count));
 	printk("sh %lu, ", sh->sector);
 	for (i = 0; i < MD_SB_DISKS; i++) {
 		if (sh->bh_cache[i])
-			printk("(cache%d: %p %ld) ", i, sh->bh_cache[i], sh->bh_cache[i]->b_state);
+			printk("(cache%d: %p %lu) ", i, sh->bh_cache[i], sh->bh_cache[i]->b_state);
 	}
 	printk("\n");
 }
diff -urNp linux-7000/drivers/scsi/sd.c linux-7001/drivers/scsi/sd.c
--- linux-7000/drivers/scsi/sd.c
+++ linux-7001/drivers/scsi/sd.c
@@ -333,7 +333,8 @@ static request_queue_t *sd_find_queue(kd
 
 static int sd_init_command(Scsi_Cmnd * SCpnt)
 {
-	int dev, block, this_count;
+	int dev, this_count;
+	unsigned int block;
 	struct hd_struct *ppnt;
 	Scsi_Disk *dpnt;
 #if CONFIG_SCSI_LOGGING
@@ -845,7 +846,10 @@ static int sd_init_onedisk(int i)
 	/*
 	 * We need to retry the READ_CAPACITY because a UNIT_ATTENTION is
 	 * considered a fatal error, and many devices report such an error
-	 * just after a scsi bus reset.
+	 * just after a scsi bus reset. Also, if a previous READ_CAPACITY
+	 * failed due to media going offline, defaults will have
+         * been established; which may not be correct for current/online
+	 * media.
 	 */
 
 	SRpnt = scsi_allocate_request(rscsi_disks[i].device);
@@ -1023,78 +1027,107 @@ static int sd_init_onedisk(int i)
 		 */
 		rscsi_disks[i].ready = 1;
 
-		rscsi_disks[i].capacity = 1 + ((buffer[0] << 24) |
-					       (buffer[1] << 16) |
-					       (buffer[2] << 8) |
-					       buffer[3]);
+		/*
+		 * We only support READ CAPACITY (8).  If 2TB limit is detected
+		 * set limit to 2TB minus two sectors.  This will prevent an
+		 * overflow, and leave us with an even sector count.
+		 */
+
+		if (buffer[0] == 0xFF &&
+		    buffer[1] == 0xFF &&
+		    buffer[2] == 0xFF &&
+		    (buffer[3] == 0xFF || buffer[3] == 0xFE )) {
+			rscsi_disks[i].capacity = 0xFFFFFFFE;
+		} else {
+			rscsi_disks[i].capacity = 1 + ((buffer[0] << 24) |
+						       (buffer[1] << 16) |
+						       (buffer[2] << 8) |
+						        buffer[3]);
+		}
 
 		sector_size = (buffer[4] << 24) |
 		    (buffer[5] << 16) | (buffer[6] << 8) | buffer[7];
 
-		if (sector_size == 0) {
-			sector_size = 512;
-			printk("%s : sector size 0 reported, assuming 512.\n",
-			       nbuff);
+	}
+
+	if (sector_size == 0) {
+		sector_size = 512;
+		printk("%s : sector size 0 reported, assuming 512.\n",
+		       nbuff);
+	}
+	if (sector_size != 512 &&
+	    sector_size != 1024 &&
+	    sector_size != 2048 &&
+	    sector_size != 4096 &&
+	    sector_size != 256) {
+		printk("%s : unsupported sector size %d.\n",
+		       nbuff, sector_size);
+		/*
+		 * The user might want to re-format the drive with
+		 * a supported sectorsize.  Once this happens, it
+		 * would be relatively trivial to set the thing up.
+		 * For this reason, we leave the thing in the table.
+		 */
+		rscsi_disks[i].capacity = 0;
+	}
+
+	/* NOTE: if a device had media, then media was removed, and the above code
+	 * failed due to this (lack of media), sd_blocksizes may be left as it was on
+	 * entry to this function; this is okay.
+         */
+	if (sector_size > 1024) {
+		int m;
+
+		/*
+		 * We must fix the sd_blocksizes and sd_hardsizes
+		 * to allow us to read the partition tables.
+		 * The disk reading code does not allow for reading
+		 * of partial sectors.
+		 */
+		for (m = i << 4; m < ((i + 1) << 4); m++) {
+			sd_blocksizes[m] = sector_size;
 		}
-		if (sector_size != 512 &&
-		    sector_size != 1024 &&
-		    sector_size != 2048 &&
-		    sector_size != 4096 &&
-		    sector_size != 256) {
-			printk("%s : unsupported sector size %d.\n",
-			       nbuff, sector_size);
-			/*
-			 * The user might want to re-format the drive with
-			 * a supported sectorsize.  Once this happens, it
-			 * would be relatively trivial to set the thing up.
-			 * For this reason, we leave the thing in the table.
-			 */
-			rscsi_disks[i].capacity = 0;
+	} {
+		/*
+		 * The msdos fs needs to know the hardware sector size
+		 * So I have created this table. See ll_rw_blk.c
+		 * Jacques Gelinas (Jacques@solucorp.qc.ca)
+		 */
+		int m;
+		unsigned int hard_sector = sector_size;
+		unsigned int sz = rscsi_disks[i].capacity *
+			(hard_sector / 256);
+
+		if (sz < rscsi_disks[i].capacity) {
+			/* redo computations avoiding "sz" overflow */
+			sz = (rscsi_disks[i].capacity / 1950) *
+				(hard_sector / 256);
+			sz = sz/2 - sz/1250 + 974;
+		} else {
+			sz = (sz/2 - sz/1250 + 974) / 1950;
 		}
-		if (sector_size > 1024) {
-			int m;
 
-			/*
-			 * We must fix the sd_blocksizes and sd_hardsizes
-			 * to allow us to read the partition tables.
-			 * The disk reading code does not allow for reading
-			 * of partial sectors.
-			 */
-			for (m = i << 4; m < ((i + 1) << 4); m++) {
-				sd_blocksizes[m] = sector_size;
-			}
-		} {
-			/*
-			 * The msdos fs needs to know the hardware sector size
-			 * So I have created this table. See ll_rw_blk.c
-			 * Jacques Gelinas (Jacques@solucorp.qc.ca)
-			 */
-			int m;
-			int hard_sector = sector_size;
-			unsigned int sz = (rscsi_disks[i].capacity/2) * (hard_sector/256);
-
-			/* There are 16 minors allocated for each major device */
-			for (m = i << 4; m < ((i + 1) << 4); m++) {
-				sd_hardsizes[m] = hard_sector;
-			}
-
-			printk("SCSI device %s: "
-			       "%u %d-byte hdwr sectors (%d MB)\n",
-			       nbuff, rscsi_disks[i].capacity,
-			       hard_sector, (sz - sz/625 + 974)/1950);
+		/* There are 16 minors allocated for each major device */
+		for (m = i << 4; m < ((i + 1) << 4); m++) {
+			sd_hardsizes[m] = hard_sector;
 		}
 
-		/* Rescale capacity to 512-byte units */
-		if (sector_size == 4096)
-			rscsi_disks[i].capacity <<= 3;
-		if (sector_size == 2048)
-			rscsi_disks[i].capacity <<= 2;
-		if (sector_size == 1024)
-			rscsi_disks[i].capacity <<= 1;
-		if (sector_size == 256)
-			rscsi_disks[i].capacity >>= 1;
+		printk("SCSI device %s: "
+		       "%u %u-byte hdwr sectors (%u MB)\n",
+		       nbuff, rscsi_disks[i].capacity,
+		       hard_sector, sz);
 	}
 
+	/* Rescale capacity to 512-byte units */
+	if (sector_size == 4096)
+		rscsi_disks[i].capacity <<= 3;
+	if (sector_size == 2048)
+		rscsi_disks[i].capacity <<= 2;
+	if (sector_size == 1024)
+		rscsi_disks[i].capacity <<= 1;
+	if (sector_size == 256)
+		rscsi_disks[i].capacity >>= 1;
+
 
 	/*
 	 * Unless otherwise specified, this is not write protected.
diff -urNp linux-7000/fs/block_dev.c linux-7001/fs/block_dev.c
--- linux-7000/fs/block_dev.c
+++ linux-7001/fs/block_dev.c
@@ -122,11 +122,11 @@ int sb_min_blocksize(struct super_block 
 
 static int blkdev_get_block(struct inode * inode, long iblock, struct buffer_head * bh, int create)
 {
-	if (iblock >= max_block(inode->i_rdev))
+	if ((unsigned long)iblock >= max_block(inode->i_rdev))
 		return -EIO;
 
 	bh->b_dev = inode->i_rdev;
-	bh->b_blocknr = iblock;
+	bh->b_blocknr = (unsigned long)iblock;
 	bh->b_state |= 1UL << BH_Mapped;
 	return 0;
 }
diff -urNp linux-7000/fs/partitions/check.c linux-7001/fs/partitions/check.c
--- linux-7000/fs/partitions/check.c
+++ linux-7001/fs/partitions/check.c
@@ -239,7 +239,7 @@ char *disk_name (struct gendisk *hd, int
 /*
  * Add a partitions details to the devices partition description.
  */
-void add_gd_partition(struct gendisk *hd, int minor, int start, int size)
+void add_gd_partition(struct gendisk *hd, int minor, unsigned long start, unsigned long size)
 {
 #ifndef CONFIG_DEVFS_FS
 	char buf[40];
@@ -408,15 +408,24 @@ void devfs_register_partitions (struct g
  * done
  */
 
+#ifdef __GENKSYMS__ /* preserve KMI/ABI ksyms compatibility for mod linkage */
 void register_disk(struct gendisk *gdev, kdev_t dev, unsigned minors,
 	struct block_device_operations *ops, long size)
+#else
+void register_disk(struct gendisk *gdev, kdev_t dev, unsigned minors,
+	struct block_device_operations *ops, unsigned long size)
+#endif /* __GENKSYMS__ */
 {
 	if (!gdev)
 		return;
 	grok_partitions(gdev, MINOR(dev)>>gdev->minor_shift, minors, size);
 }
 
+#ifdef __GENKSYMS__ /* preserve KMI/ABI ksyms compatibility for mod linkage */
 void grok_partitions(struct gendisk *dev, int drive, unsigned minors, long size)
+#else
+void grok_partitions(struct gendisk *dev, int drive, unsigned minors, unsigned long size)
+#endif /* __GENKSYMS__ */
 {
 	int i;
 	int first_minor	= drive << dev->minor_shift;
diff -urNp linux-7000/fs/partitions/check.h linux-7001/fs/partitions/check.h
--- linux-7000/fs/partitions/check.h
+++ linux-7001/fs/partitions/check.h
@@ -2,7 +2,7 @@
  * add_partition adds a partitions details to the devices partition
  * description.
  */
-void add_gd_partition(struct gendisk *hd, int minor, int start, int size);
+void add_gd_partition(struct gendisk *hd, int minor, unsigned long start, unsigned long size);
 
 typedef struct {struct page *v;} Sector;
 
diff -urNp linux-7000/include/linux/blkdev.h linux-7001/include/linux/blkdev.h
--- linux-7000/include/linux/blkdev.h
+++ linux-7001/include/linux/blkdev.h
@@ -211,8 +211,14 @@ struct sec_size {
 
 extern struct sec_size * blk_sec[MAX_BLKDEV];
 extern struct blk_dev_struct blk_dev[MAX_BLKDEV];
+#ifdef __GENKSYMS__ /* preserve KMI/ABI ksyms compatibility for mod linkage */
 extern void grok_partitions(struct gendisk *dev, int drive, unsigned minors, long size);
 extern void register_disk(struct gendisk *dev, kdev_t first, unsigned minors, struct block_device_operations *ops, long size);
+#else
+extern void grok_partitions(struct gendisk *dev, int drive, unsigned minors, unsigned long size);
+extern void register_disk(struct gendisk *dev, kdev_t first, unsigned minors, struct block_device_operations *ops, unsigned long size);
+#endif /* __GENKSYMS__ */
+
 extern void generic_make_request(int rw, struct buffer_head * bh);
 extern inline request_queue_t *blk_get_queue(kdev_t dev);
 extern void blkdev_release_request(struct request *);
