diff -urNp linux-354/arch/ppc64/Makefile linux-355/arch/ppc64/Makefile
--- linux-354/arch/ppc64/Makefile
+++ linux-355/arch/ppc64/Makefile
@@ -49,6 +49,14 @@ SUBDIRS += arch/ppc64/kdb
 CORE_FILES += arch/ppc64/kdb/kdba.o
 endif
 
+# FIXME: is drivers- right ?
+ifdef CONFIG_OPROFILE
+SUBDIRS += arch/ppc64/oprofile
+ifeq ($(CONFIG_OPROFILE),y)
+DRIVERS += arch/ppc64/oprofile/oprofile.o
+endif
+endif
+
 MAKEBOOT = $(MAKE) -C arch/$(ARCH)/boot
 
 checks:
diff -urNp linux-354/arch/ppc64/config.in linux-355/arch/ppc64/config.in
--- linux-354/arch/ppc64/config.in
+++ linux-355/arch/ppc64/config.in
@@ -248,6 +248,8 @@ fi
 
 source lib/Config.in
 
+source arch/ppc64/oprofile/Config.in
+ 
 mainmenu_option next_comment
 comment 'Kernel hacking'
 
diff -urNp linux-354/arch/ppc64/kernel/sys_ppc32.c linux-355/arch/ppc64/kernel/sys_ppc32.c
--- linux-354/arch/ppc64/kernel/sys_ppc32.c
+++ linux-355/arch/ppc64/kernel/sys_ppc32.c
@@ -4638,6 +4638,14 @@ asmlinkage int sys32_ftruncate64(unsigne
 		return sys_ftruncate(fd, (high << 32) | low);
 }
 
+extern long sys_lookup_dcookie(u64 cookie64, char *buf, size_t len);
+
+long ppc32_lookup_dcookie(u32 cookie_high, u32 cookie_low, char *buf,
+			  size_t len)
+{
+	return sys_lookup_dcookie((u64)cookie_high << 32 | cookie_low,
+				  buf, len);
+}
 
 
 asmlinkage long sys32_fcntl64(unsigned int fd, unsigned int cmd, unsigned long arg)
diff -urNp linux-354/arch/ppc64/kernel/time.c linux-355/arch/ppc64/kernel/time.c
--- linux-354/arch/ppc64/kernel/time.c
+++ linux-355/arch/ppc64/kernel/time.c
@@ -46,6 +46,7 @@
 #include <linux/mc146818rtc.h>
 #include <linux/time.h>
 #include <linux/init.h>
+#include <linux/profile.h>
 
 #include <asm/naca.h>
 #include <asm/segment.h>
@@ -93,20 +94,34 @@ extern unsigned long wall_jiffies;
 extern unsigned long lpEvent_count;
 extern int smp_tb_synchronized;
 
-extern unsigned long prof_cpu_mask;
-extern unsigned int * prof_buffer;
-extern unsigned long prof_len;
-extern unsigned long prof_shift;
-extern char _stext;
-
 extern struct timezone sys_tz;
 
 void ppc_adjtimex(void);
 
 static unsigned adjusting_time = 0;
 
-static void ppc_do_profile (unsigned long nip)
+/*
+ * The profiling function is SMP safe. (nothing can mess
+ * around with "current", and the profiling counters are
+ * updated with atomic operations). This is especially
+ * useful with a profiling multiplier != 1
+ */
+static inline void ppc64_do_profile(struct pt_regs *regs)
 {
+	unsigned long nip;
+	extern unsigned long prof_cpu_mask;
+	extern char _stext;
+
+	profile_hook(regs);
+
+	if (user_mode(regs))
+		return;
+
+	if (!prof_buffer)
+		return;
+
+	nip = instruction_pointer(regs);
+
 	/*
 	 * Only measure the CPUs specified by /proc/irq/prof_cpu_mask.
 	 * (default is all CPUs.)
@@ -126,7 +141,6 @@ static void ppc_do_profile (unsigned lon
 	atomic_inc((atomic_t *)&prof_buffer[nip]);
 }
 
-
 static __inline__ void timer_check_rtc(void)
 {
         /*
@@ -251,14 +265,10 @@ int timer_interrupt(struct pt_regs * reg
 	unsigned long cur_tb;
 	struct paca_struct *lpaca = get_paca();
 	unsigned long cpu = lpaca->xPacaIndex;
-	struct ItLpQueue * lpq;
 
 	irq_enter(cpu);
 
-	if ((!user_mode(regs)) && (prof_buffer))
-		ppc_do_profile(instruction_pointer(regs));
-
-	pmc_timeslice_tick(); /* Hack this in for now */
+	ppc64_do_profile(regs);
 
 	lpaca->xLpPaca.xIntDword.xFields.xDecrInt = 0;
 
@@ -285,9 +295,13 @@ int timer_interrupt(struct pt_regs * reg
         	next_dec = lpaca->default_decr;
 	set_dec(next_dec);
 
-	lpq = lpaca->lpQueuePtr;
-	if (lpq && ItLpQueue_isLpIntPending(lpq))
-		lpEvent_count += ItLpQueue_process(lpq, regs); 
+#ifdef CONFIG_PPC_ISERIES
+	{
+		struct ItLpQueue *lpq = lpaca->lpQueuePtr;
+		if (lpq && ItLpQueue_isLpIntPending(lpq))
+			lpEvent_count += ItLpQueue_process(lpq, regs);
+	}
+#endif
 
 	irq_exit(cpu);
 
diff -urNp linux-354/arch/ppc64/oprofile/Config.help linux-355/arch/ppc64/oprofile/Config.help
--- linux-354/arch/ppc64/oprofile/Config.help
+++ linux-355/arch/ppc64/oprofile/Config.help
@@ -0,0 +1,6 @@
+CONFIG_OPROFILE
+  OProfile is a profiling system capable of profiling the
+  whole system, include the kernel, kernel modules, libraries,
+  and applications.
+
+  If unsure, say N.
diff -urNp linux-354/arch/ppc64/oprofile/Config.in linux-355/arch/ppc64/oprofile/Config.in
--- linux-354/arch/ppc64/oprofile/Config.in
+++ linux-355/arch/ppc64/oprofile/Config.in
@@ -0,0 +1,9 @@
+if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Profiling support'
+   bool 'Profiling support (EXPERIMENTAL)' CONFIG_PROFILING
+   if [ "$CONFIG_PROFILING" = "y" ]; then
+      tristate '  OProfile system profiling (EXPERIMENTAL)' CONFIG_OPROFILE
+   fi
+   endmenu
+fi
diff -urNp linux-354/arch/ppc64/oprofile/Makefile linux-355/arch/ppc64/oprofile/Makefile
--- linux-354/arch/ppc64/oprofile/Makefile
+++ linux-355/arch/ppc64/oprofile/Makefile
@@ -0,0 +1,11 @@
+# arch/ppc64/oprofile/Makefile
+
+O_TARGET:=oprofile.o
+obj-m := $(O_TARGET)
+obj-y := init.o timer_int.o \
+         $(addprefix ../../../drivers/oprofile/, \
+           oprof.o cpu_buffer.o buffer_sync.o \
+           event_buffer.o oprofile_files.o \
+           oprofilefs.o oprofile_stats.o )
+
+include $(TOPDIR)/Rules.make
diff -urNp linux-354/arch/ppc64/oprofile/init.c linux-355/arch/ppc64/oprofile/init.c
--- linux-354/arch/ppc64/oprofile/init.c
+++ linux-355/arch/ppc64/oprofile/init.c
@@ -0,0 +1,25 @@
+/**
+ * @file init.c
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon <levon@movementarian.org>
+ */
+
+#include <linux/kernel.h>
+#include <linux/oprofile.h>
+#include <linux/init.h>
+ 
+extern void timer_init(struct oprofile_operations ** ops);
+
+int __init oprofile_arch_init(struct oprofile_operations ** ops)
+{
+	timer_init(ops);
+	return 0;
+}
+
+
+void __exit oprofile_arch_exit(void)
+{
+}
diff -urNp linux-354/arch/ppc64/oprofile/timer_int.c linux-355/arch/ppc64/oprofile/timer_int.c
--- linux-354/arch/ppc64/oprofile/timer_int.c
+++ linux-355/arch/ppc64/oprofile/timer_int.c
@@ -0,0 +1,59 @@
+/**
+ * @file timer_int.c
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon <levon@movementarian.org>
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/notifier.h>
+#include <linux/smp.h>
+#include <linux/irq.h>
+#include <linux/oprofile.h>
+#include <linux/profile.h>
+#include <asm/ptrace.h>
+ 
+static int timer_notify(struct notifier_block * self, unsigned long val, void * data)
+{
+	struct pt_regs * regs = (struct pt_regs *)data;
+	int cpu = smp_processor_id();
+	unsigned long pc = instruction_pointer(regs);
+	int is_kernel = !user_mode(regs);
+ 
+	oprofile_add_sample(pc, is_kernel, 0, cpu);
+	return 0;
+}
+ 
+ 
+static struct notifier_block timer_notifier = {
+	.notifier_call	= timer_notify,
+};
+ 
+
+static int timer_start(void)
+{
+	return register_profile_notifier(&timer_notifier);
+}
+
+
+static void timer_stop(void)
+{
+	unregister_profile_notifier(&timer_notifier);
+}
+
+
+static struct oprofile_operations timer_ops = {
+	.start	= timer_start,
+	.stop	= timer_stop,
+	.cpu_type = "timer"
+};
+
+ 
+void __init timer_init(struct oprofile_operations ** ops)
+{
+	*ops = &timer_ops;
+	printk(KERN_INFO "oprofile: using timer interrupt.\n");
+}
diff -urNp linux-354/include/asm-ppc64/smp.h linux-355/include/asm-ppc64/smp.h
--- linux-354/include/asm-ppc64/smp.h
+++ linux-355/include/asm-ppc64/smp.h
@@ -41,6 +41,14 @@ extern void smp_send_xmon_break(int cpu)
 struct pt_regs;
 extern void smp_message_recv(int, struct pt_regs *);
 
+/* Newer 2.5 Linux kernels have cpu_possible. This provides equivalent function
+   for the older 2.4 kernels */
+extern unsigned long cpu_online_map;
+static inline int cpu_possible(int cpu)
+{
+	return (cpu_online_map & (1<<(cpu)));
+} 
+
 #define NO_PROC_ID		0xFF            /* No processor magic marker */
 #define PROC_CHANGE_PENALTY	20
 
