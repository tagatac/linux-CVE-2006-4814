diff -urNp linux-110/arch/i386/kernel/acpitable.c linux-115/arch/i386/kernel/acpitable.c
--- linux-110/arch/i386/kernel/acpitable.c
+++ linux-115/arch/i386/kernel/acpitable.c
@@ -34,6 +34,7 @@
 #include <linux/stddef.h>
 #include <linux/slab.h>
 #include <linux/pci.h>
+#include <linux/bootmem.h>
 #include <asm/mpspec.h>
 #include <asm/io.h>
 #include <asm/apic.h>
@@ -219,7 +220,7 @@ static int __init acpi_tables_init(void)
 	acpi_table_header *header = NULL;
 	struct acpi_table_rsdp *rsdp = NULL;
 	struct acpi_table_rsdt *rsdt = NULL;
-	struct acpi_table_rsdt saved_rsdt;
+	struct acpi_table_rsdt *saved_rsdt;
 	int tables = 0;
 	int type = 0;
 	int i = 0;
@@ -238,15 +239,16 @@ static int __init acpi_tables_init(void)
 		return -EINVAL;
 	}
 
+	header = (acpi_table_header *)
+		__va_range(rsdp->rsdt_address, sizeof(acpi_table_header));
 	rsdt = (struct acpi_table_rsdt *)
-	    __va_range(rsdp->rsdt_address, sizeof(struct acpi_table_rsdt));
+	    __va_range(rsdp->rsdt_address, header->length);
 
 	if (!rsdt) {
 		printk(KERN_WARNING "ACPI: Invalid root system description tables (RSDT)\n");
 		return -ENODEV;
 	}
 	
-	header = & rsdt->header;
 	acpi_print_table_header(header);
 	
 	if (strncmp(header->signature, RSDT_SIG, strlen(RSDT_SIG))) {
@@ -262,22 +264,23 @@ static int __init acpi_tables_init(void)
 	 */
 	tables = (header->length - sizeof(acpi_table_header)) / 4;
 		    
-	memcpy(&saved_rsdt, rsdt, sizeof(saved_rsdt));
+	saved_rsdt = alloc_bootmem(header->length);
 
-	if (saved_rsdt.header.length > sizeof(saved_rsdt)) {
-		printk(KERN_WARNING "ACPI: Too big length in RSDT: %d\n", saved_rsdt.header.length);
+	if (!saved_rsdt) {
+		printk(KERN_WARNING "ACPI: Unable to allocate memory for RSDT\n");
 		return -ENODEV;
 	}
+	memcpy(saved_rsdt, rsdt, header->length);
 
 	for (i = 0; i < tables; i++) {
 		/* Map in header, then map in full table length. */
 		header = (acpi_table_header *)
-			    __va_range(saved_rsdt.entry[i],
+			    __va_range(saved_rsdt->entry[i],
 				       sizeof(acpi_table_header));
 		if (!header)
 			break;
 		header = (acpi_table_header *)
-			    __va_range(saved_rsdt.entry[i], header->length);
+			    __va_range(saved_rsdt->entry[i], header->length);
 		if (!header)
 			break;
 
@@ -305,7 +308,7 @@ static int __init acpi_tables_init(void)
 			continue;
 			
 		result = acpi_boot_ops[type] (header,
-						 (unsigned long) saved_rsdt.
+						 (unsigned long) saved_rsdt->
 						 entry[i]);
 	}
 
diff -urNp linux-110/arch/i386/kernel/acpitable.h linux-115/arch/i386/kernel/acpitable.h
--- linux-110/arch/i386/kernel/acpitable.h
+++ linux-115/arch/i386/kernel/acpitable.h
@@ -146,7 +146,7 @@ struct acpi_table_rsdp {
 
 struct acpi_table_rsdt {
 	acpi_table_header header;
-	u32 entry[ACPI_TABLE_COUNT];
+	u32 entry[1];
 } __attribute__ ((packed));
 
 typedef struct {
diff -urNp linux-110/arch/i386/kernel/process.c linux-115/arch/i386/kernel/process.c
--- linux-110/arch/i386/kernel/process.c
+++ linux-115/arch/i386/kernel/process.c
@@ -379,12 +379,13 @@ void machine_restart(char * __unused)
 
 		/* check to see if reboot_cpu is valid 
 		   if its not, default to the BSP */
-		if ((reboot_cpu == -1) ||  
-		      (reboot_cpu > (NR_CPUS -1))  || 
-		      !(phys_cpu_present_map & (1<<cpuid))) 
+		if ((reboot_cpu < 0) ||
+		    (reboot_cpu > (NR_CPUS - 1)) ||
+		    !(phys_cpu_present_map & (1 << reboot_cpu)))
 			reboot_cpu = boot_cpu_physical_apicid;
 
 		reboot_smp = 0;  /* use this as a flag to only go through this once*/
+		wmb();
 		/* re-run this function on the other CPUs
 		   it will fall though this section since we have 
 		   cleared reboot_smp, and do the reboot if it is the
@@ -393,9 +394,11 @@ void machine_restart(char * __unused)
 			smp_call_function((void *)machine_restart , NULL, 1, 0);
 	}
 
-	/* if reboot_cpu is still -1, then we want a tradional reboot, 
-	   and if we are not running on the reboot_cpu,, halt */
-	if ((reboot_cpu != -1) && (cpuid != reboot_cpu)) {
+	/* if we don't pass reboot=s<number> to the kernel command line, then
+	   reboot_cpu will be -1, in which case we run on whatever CPU we
+	   happen to be on.  If we do pass reboot=s<number> though, then we
+	   need to make sure we are the right CPU before continuing. */
+	if ((reboot_cpu != -1) && (reboot_cpu != cpuid)) {
 		for (;;)
 		__asm__ __volatile__ ("hlt");
 	}
