diff -urNp linux-5830/fs/nfsd/export.c linux-5840/fs/nfsd/export.c
--- linux-5830/fs/nfsd/export.c
+++ linux-5840/fs/nfsd/export.c
@@ -640,6 +640,7 @@ struct flags {
 	{ NFSEXP_CROSSMNT, {"nohide", ""}},
 	{ NFSEXP_NOSUBTREECHECK, {"no_subtree_check", ""}},
 	{ NFSEXP_NOAUTHNLM, {"insecure_locks", ""}},
+	{ NFSEXP_NOACL, {"no_acl", "acl"}},
 #ifdef MSNFS
 	{ NFSEXP_MSNFS, {"msnfs", ""}},
 #endif
diff -urNp linux-5830/fs/nfsd/nfs3xdr.c linux-5840/fs/nfsd/nfs3xdr.c
--- linux-5830/fs/nfsd/nfs3xdr.c
+++ linux-5840/fs/nfsd/nfs3xdr.c
@@ -161,21 +161,11 @@ encode_fattr3(struct svc_rqst *rqstp, u3
 	struct inode	*inode = fhp->fh_dentry->d_inode;
 	mode_t		mode = inode->i_mode;
 
-	if (IS_POSIXACL(inode) && EX_POSTXACL(fhp->fh_export)) {
+	if (IS_POSIXACL(inode) && EX_NOACL(fhp->fh_export)) {
 		struct posix_acl *acl = nfsd_get_posix_acl(fhp,ACL_TYPE_ACCESS);
-		/*
-		 * If IS_ERR(acl) is true, there is really not much that can
-		 * be done at this point since returning zero just causes
-		 * the client to retry (forever) and returning something
-		 * like EOPNOTSUPP for a getattr really doesn't make much
-		 * sense either. So if there is an error, its ignored
-		 * and things go on as if it never happen...
-		 */
 		if (!IS_ERR(acl) && acl) {
-			int error = posix_acl_masq_nfs_mode(acl, &mode);
+			posix_acl_masq_nfs_mode(acl, &mode);
 			posix_acl_release(acl);
-			if (error)
-				mode = inode->i_mode;
 		}
 	}
 
diff -urNp linux-5830/fs/nfsd/nfsxdr.c linux-5840/fs/nfsd/nfsxdr.c
--- linux-5830/fs/nfsd/nfsxdr.c
+++ linux-5840/fs/nfsd/nfsxdr.c
@@ -138,21 +138,11 @@ encode_fattr(struct svc_rqst *rqstp, u32
  	mode_t mode = inode->i_mode;
 	int type = (inode->i_mode & S_IFMT);
   
-	if (IS_POSIXACL(inode) && EX_POSTXACL(fhp->fh_export)) {
+	if (IS_POSIXACL(inode) && EX_NOACL(fhp->fh_export)) {
 		struct posix_acl *acl = nfsd_get_posix_acl(fhp,ACL_TYPE_ACCESS);
-		/*
-		 * If IS_ERR(acl) is true, there is really not much that can
-		 * be done at this point since returning zero just causes 
-		 * the client to retry (forever) and returning something
-		 * like EOPNOTSUPP for a getattr really doesn't make much
-		 * sense either. So if there is an error, its ignored 
-		 * and things go on as if it never happen...
-		 */
 		if (!IS_ERR(acl) && acl) {
-			int error = posix_acl_masq_nfs_mode(acl, &mode);
+			posix_acl_masq_nfs_mode(acl, &mode);
 			posix_acl_release(acl);
-			if (error)
-				mode = inode->i_mode;
 		}
 	}
 
diff -urNp linux-5830/include/linux/nfsd/export.h linux-5840/include/linux/nfsd/export.h
--- linux-5830/include/linux/nfsd/export.h
+++ linux-5840/include/linux/nfsd/export.h
@@ -26,22 +26,22 @@
 /*
  * Export flags.
  */
-#define NFSEXP_READONLY		0x0001
+#define NFSEXP_READONLY			0x0001
 #define NFSEXP_INSECURE_PORT	0x0002
-#define NFSEXP_ROOTSQUASH	0x0004
-#define NFSEXP_ALLSQUASH	0x0008
-#define NFSEXP_ASYNC		0x0010
+#define NFSEXP_ROOTSQUASH		0x0004
+#define NFSEXP_ALLSQUASH		0x0008
+#define NFSEXP_ASYNC			0x0010
 #define NFSEXP_GATHERED_WRITES	0x0020
-#define NFSEXP_UIDMAP		0x0040
-#define NFSEXP_KERBEROS		0x0080		/* not available */
-#define NFSEXP_SUNSECURE	0x0100
+#define NFSEXP_UIDMAP			0x0040
+#define NFSEXP_KERBEROS			0x0080		/* not available */
+#define NFSEXP_SUNSECURE		0x0100
 #define NFSEXP_CROSSMNT		0x0200
 #define NFSEXP_NOSUBTREECHECK	0x0400
-#define	NFSEXP_NOAUTHNLM	0x0800		/* Don't authenticate NLM requests - just trust */
-#define NFSEXP_MSNFS		0x1000	/* do silly things that MS clients expect */
-#define NFSEXP_FSID		0x2000
-#define NFSEXP_POSTXACL		0x4000	/* turn on acl support */
-#define NFSEXP_ALLFLAGS		0x3FFF
+#define	NFSEXP_NOAUTHNLM		0x0800		/* Don't authenticate NLM requests - just trust */
+#define NFSEXP_MSNFS			0x1000	/* do silly things that MS clients expect */
+#define NFSEXP_FSID				0x2000
+#define NFSEXP_NOACL			0x8000	/* turn off acl support */
+#define NFSEXP_ALLFLAGS			0xFFFF
 
 
 #ifdef __KERNEL__
@@ -85,19 +85,18 @@ struct svc_export {
 #define EX_SUNSECURE(exp)	((exp)->ex_flags & NFSEXP_SUNSECURE)
 #define EX_WGATHER(exp)		((exp)->ex_flags & NFSEXP_GATHERED_WRITES)
 /*
-   With Posix Access Control Lists, pre-NFS3 clients and older Linux
-   NFSv3 clients in some cases mis-interpret the file mode permission
-   bits, and either allow the remote user to read data she is not
-   permitted to, or deny the user read access that should be granted.
-   (With proper NFSv3, the access RPC is used to check access, and
-   access decisions are not implemented on the client.)
-
-   The acl option should only be set in an environment where it is known 
-   that all not clients are using the NFSv3 ACCESS RPC.  (i.e. This option 
-   should always be set for NFSv2 clients.)
-*/
-#define EX_POSTXACL(exp)	((exp)->ex_flags & NFSEXP_POSTXACL)
-
+ * With Posix Access Control Lists, pre-NFS3 clients and older Linux
+ * NFSv3 clients in some cases mis-interpret the file mode permission
+ * bits, and either allow the remote user to read data she is not
+ * permitted to, or deny the user read access that should be granted.
+ * (With proper NFSv3, the access RPC is used to check access, and
+ * access decisions are not implemented on the client.)
+ *
+ * The no_acl option should be set in environments with clients that do
+ * not use the NFSv3 ACCESS RPC. This option should always be set for NFSv2
+ * clients.
+ */
+#define EX_NOACL(exp)		((exp)->ex_flags & NFSEXP_NOACL)
 
 /*
  * Function declarations
