diff -urNp linux-7010/arch/i386/kernel/time.c linux-7020/arch/i386/kernel/time.c
--- linux-7010/arch/i386/kernel/time.c
+++ linux-7020/arch/i386/kernel/time.c
@@ -76,7 +76,6 @@ static unsigned long last_tsc_low; /* ls
  */
 unsigned long fast_gettimeoffset_quotient;
 
-extern rwlock_t xtime_lock;
 extern unsigned long wall_jiffies;
 
 spinlock_t rtc_lock = SPIN_LOCK_UNLOCKED;
@@ -276,6 +275,7 @@ static u32 last_cyclone_timer;
 static inline void mark_timeoffset_cyclone(void)
 {
 	int count;
+	unsigned long lost;
 	unsigned long delta = last_cyclone_timer;
 	spin_lock(&i8253_lock);
 	/* quickly read the cyclone timer */
@@ -291,10 +291,11 @@ static inline void mark_timeoffset_cyclo
 
 	/*lost tick compensation*/
 	delta = last_cyclone_timer - delta;
-	if(delta > loops_per_jiffy+2000){
-		delta = (delta/loops_per_jiffy)-1;
-		jiffies += delta;
-	}
+	delta /= (CYCLONE_TIMER_FREQ/1000000);
+	delta += delay_at_last_interrupt;
+	lost = delta/(1000000/HZ);
+	if (lost >= 2)
+		jiffies += lost-1;
                
 	count = ((LATCH-1) - count) * TICK_SIZE;
 	delay_at_last_interrupt = (count + LATCH/2) / LATCH;
@@ -441,7 +442,7 @@ void do_gettimeofday(struct timeval *tv)
 	unsigned long flags;
 	unsigned long usec, sec;
 
-	read_lock_irqsave(&xtime_lock, flags);
+	br_read_lock_irqsave(BR_XTIME_LOCK, flags);
 	usec = do_gettimeoffset();
 	{
 		unsigned long lost = jiffies - wall_jiffies;
@@ -450,7 +451,7 @@ void do_gettimeofday(struct timeval *tv)
 	}
 	sec = xtime.tv_sec;
 	usec += xtime.tv_usec;
-	read_unlock_irqrestore(&xtime_lock, flags);
+	br_read_unlock_irqrestore(BR_XTIME_LOCK, flags);
 
 	while (usec >= 1000000) {
 		usec -= 1000000;
@@ -463,7 +464,7 @@ void do_gettimeofday(struct timeval *tv)
 
 void do_settimeofday(struct timeval *tv)
 {
-	write_lock_irq(&xtime_lock);
+	br_write_lock_irq(BR_XTIME_LOCK);
 	/*
 	 * This is revolting. We need to set "xtime" correctly. However, the
 	 * value in this location is the value at the most recent update of
@@ -483,7 +484,7 @@ void do_settimeofday(struct timeval *tv)
 	time_status |= STA_UNSYNC;
 	time_maxerror = NTP_PHASE_LIMIT;
 	time_esterror = NTP_PHASE_LIMIT;
-	write_unlock_irq(&xtime_lock);
+	br_write_unlock_irq(BR_XTIME_LOCK);
 }
 
 /*
@@ -650,7 +651,7 @@ static void timer_interrupt(int irq, voi
 	 * the irq version of write_lock because as just said we have irq
 	 * locally disabled. -arca
 	 */
-	write_lock(&xtime_lock);
+	br_write_lock(BR_XTIME_LOCK);
 
 	if(use_cyclone)
 		mark_timeoffset_cyclone();
@@ -684,8 +685,6 @@ static void timer_interrupt(int irq, voi
 		   code at least */
 		   
 		if (count > LATCH) {
-			printk(KERN_WARNING 
-			       "i8253 count too high! resetting..\n");
 			outb_p(0x34, 0x43);
 			outb_p(LATCH & 0xff, 0x40);
 			outb(LATCH >> 8, 0x40);
@@ -706,7 +705,7 @@ static void timer_interrupt(int irq, voi
 
 	do_timer_interrupt(irq, NULL, regs);
 
-	write_unlock(&xtime_lock);
+	br_write_unlock(BR_XTIME_LOCK);
 
 }
 
diff -urNp linux-7010/arch/ia64/kernel/time.c linux-7020/arch/ia64/kernel/time.c
--- linux-7010/arch/ia64/kernel/time.c
+++ linux-7020/arch/ia64/kernel/time.c
@@ -25,7 +25,6 @@
 #include <asm/system.h>
 #include <asm/cyclone.h>
 
-extern rwlock_t xtime_lock;
 extern unsigned long wall_jiffies;
 
 unsigned long last_time_offset;
@@ -37,7 +36,7 @@ unsigned long last_cli_ip;
 
 /*
  * Return the number of micro-seconds that elapsed since the last update to jiffy.  The
- * xtime_lock must be at least read-locked when calling this routine.
+ * BR_XTIME_LOCK must be at least read-locked when calling this routine.
  */
 static inline unsigned long
 gettimeoffset (void)
@@ -67,7 +66,7 @@ gettimeoffset (void)
 void
 do_settimeofday (struct timeval *tv)
 {
-	write_lock_irq(&xtime_lock);
+	br_write_lock_irq(BR_XTIME_LOCK);
 	{
 		/*
 		 * This is revolting. We need to set "xtime" correctly. However, the value
@@ -89,7 +88,7 @@ do_settimeofday (struct timeval *tv)
 		time_maxerror = NTP_PHASE_LIMIT;
 		time_esterror = NTP_PHASE_LIMIT;
 	}
-	write_unlock_irq(&xtime_lock);
+	br_write_unlock_irq(BR_XTIME_LOCK);
 }
 
 void
@@ -97,7 +96,7 @@ do_gettimeofday (struct timeval *tv)
 {
 	unsigned long flags, usec, sec, old;
 
-	read_lock_irqsave(&xtime_lock, flags);
+	br_read_lock_irqsave(BR_XTIME_LOCK, flags);
 	{
 		usec = gettimeoffset();
 
@@ -116,7 +115,7 @@ do_gettimeofday (struct timeval *tv)
 		sec = xtime.tv_sec;
 		usec += xtime.tv_usec;
 	}
-	read_unlock_irqrestore(&xtime_lock, flags);
+	br_read_unlock_irqrestore(BR_XTIME_LOCK, flags);
 
 	while (usec >= 1000000) {
 		usec -= 1000000;
@@ -152,14 +151,14 @@ timer_interrupt(int irq, void *dev_id, s
 			 * Here we are in the timer irq handler. We have irqs locally
 			 * disabled, but we don't know if the timer_bh is running on
 			 * another CPU. We need to avoid to SMP race by acquiring the
-			 * xtime_lock.
+			 * BR_XTIME_LOCK.
 			 */
-			write_lock(&xtime_lock);
+			br_write_lock(BR_XTIME_LOCK);
 			do_timer(regs);
 			local_cpu_data->itm_next = new_itm;
 			if (use_cyclone)
 				mark_timeoffset_cyclone();
-			write_unlock(&xtime_lock);
+			br_write_unlock(BR_XTIME_LOCK);
 		} else
 			local_cpu_data->itm_next = new_itm;
 
diff -urNp linux-7010/arch/ppc64/kernel/time.c linux-7020/arch/ppc64/kernel/time.c
--- linux-7010/arch/ppc64/kernel/time.c
+++ linux-7020/arch/ppc64/kernel/time.c
@@ -70,7 +70,6 @@ extern void setup_before_console_init();
 
 /* keep track of when we need to update the rtc */
 time_t last_rtc_update;
-extern rwlock_t xtime_lock;
 extern int piranha_simulator;
 #ifdef CONFIG_PPC_ISERIES
 unsigned long iSeries_recal_titan = 0;
@@ -278,12 +277,12 @@ int timer_interrupt(struct pt_regs * reg
 		smp_local_timer_interrupt(regs);
 #endif
 		if (cpu == 0) {
-			write_lock(&xtime_lock);
+			br_write_lock(BR_XTIME_LOCK);
 			tb_last_stamp = lpaca->next_jiffy_update_tb;
 			do_timer(regs);
 			timer_sync_xtime( cur_tb );
 			timer_check_rtc();
-			write_unlock(&xtime_lock);
+			br_write_unlock(BR_XTIME_LOCK);
 			if ( adjusting_time && (time_adjust == 0) )
 				ppc_adjtimex();
 		}
@@ -392,7 +391,7 @@ void do_settimeofday(struct timeval *tv)
 	long int tb_delta, new_usec, new_sec;
 	unsigned long new_xsec;
 
-	write_lock_irqsave(&xtime_lock, flags);
+	br_write_lock_irqsave(BR_XTIME_LOCK, flags);
 	/* Updating the RTC is not the job of this code. If the time is
 	 * stepped under NTP, the RTC will be update after STA_UNSYNC
 	 * is cleared. Tool like clock/hwclock either copy the RTC
@@ -446,7 +445,7 @@ void do_settimeofday(struct timeval *tv)
 	systemcfg->tz_minuteswest = sys_tz.tz_minuteswest;
 	systemcfg->tz_dsttime = sys_tz.tz_dsttime;
 
-	write_unlock_irqrestore(&xtime_lock, flags);
+	br_write_unlock_irqrestore(BR_XTIME_LOCK, flags);
 }
 
 /*
@@ -510,7 +509,7 @@ void __init time_init(void)
 	if ( ! piranha_simulator ) {
 		ppc_md.get_boot_time(&tm);
 	}
-	write_lock_irqsave(&xtime_lock, flags);
+	br_write_lock_irqsave(BR_XTIME_LOCK, flags);
 	xtime.tv_sec = mktime(tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
 			      tm.tm_hour, tm.tm_min, tm.tm_sec);
 	tb_last_stamp = get_tb();
@@ -527,7 +526,7 @@ void __init time_init(void)
 
 	xtime.tv_usec = 0;
 	last_rtc_update = xtime.tv_sec;
-	write_unlock_irqrestore(&xtime_lock, flags);
+	br_write_unlock_irqrestore(BR_XTIME_LOCK, flags);
 
 	/* Not exact, but the timer interrupt takes care of this */
 	set_dec(tb_ticks_per_jiffy);
@@ -635,7 +634,7 @@ void ppc_adjtimex(void)
 	new_tb_to_xs = divres.result_low;
 	new_xsec = mulhdu( tb_ticks, new_tb_to_xs );
 
-	write_lock_irqsave( &xtime_lock, flags );
+	br_write_lock_irqsave(BR_XTIME_LOCK, flags);
 	old_xsec = mulhdu( tb_ticks, systemcfg->tb_to_xs );
 	new_stamp_xsec = systemcfg->stamp_xsec + old_xsec - new_xsec;
 
@@ -655,7 +654,7 @@ void ppc_adjtimex(void)
 	wmb();
 	++(systemcfg->tb_update_count);
 
-	write_unlock_irqrestore( &xtime_lock, flags );
+	br_write_unlock_irqrestore(BR_XTIME_LOCK, flags);
 
 }
 
diff -urNp linux-7010/arch/s390/kernel/time.c linux-7020/arch/s390/kernel/time.c
--- linux-7010/arch/s390/kernel/time.c
+++ linux-7020/arch/s390/kernel/time.c
@@ -43,7 +43,6 @@
 static ext_int_info_t ext_int_info_timer;
 static uint64_t init_timer_cc;
 
-extern rwlock_t xtime_lock;
 extern unsigned long wall_jiffies;
 
 void tod_to_timeval(__u64 todval, struct timeval *xtime)
@@ -99,10 +98,10 @@ void do_gettimeofday(struct timeval *tv)
 	unsigned long flags;
 	unsigned long usec, sec;
 
-	read_lock_irqsave(&xtime_lock, flags);
+	br_read_lock_irqsave(BR_XTIME_LOCK, flags);
 	sec = xtime.tv_sec;
 	usec = xtime.tv_usec + do_gettimeoffset();
-	read_unlock_irqrestore(&xtime_lock, flags);
+	br_read_unlock_irqrestore(BR_XTIME_LOCK, flags);
 
 	while (usec >= 1000000) {
 		usec -= 1000000;
@@ -116,7 +115,7 @@ void do_gettimeofday(struct timeval *tv)
 void do_settimeofday(struct timeval *tv)
 {
 
-	write_lock_irq(&xtime_lock);
+	br_write_lock_irq(BR_XTIME_LOCK);
 	/* This is revolting. We need to set the xtime.tv_usec
 	 * correctly. However, the value in this location is
 	 * is value at the last tick.
@@ -135,7 +134,7 @@ void do_settimeofday(struct timeval *tv)
 	time_status |= STA_UNSYNC;
 	time_maxerror = NTP_PHASE_LIMIT;
 	time_esterror = NTP_PHASE_LIMIT;
-	write_unlock_irq(&xtime_lock);
+	br_write_unlock_irq(BR_XTIME_LOCK);
 }
 
 #ifdef CONFIG_PROFILING
@@ -209,13 +208,13 @@ static void do_comparator_interrupt(stru
 
 #ifdef CONFIG_SMP
 	if (S390_lowcore.cpu_data.cpu_addr == boot_cpu_addr)
-		write_lock(&xtime_lock);
+		br_write_lock(BR_XTIME_LOCK);
 
 	update_process_times(user_mode(regs));
 
 	if (S390_lowcore.cpu_data.cpu_addr == boot_cpu_addr) {
 		do_timer(regs);
-		write_unlock(&xtime_lock);
+		br_write_unlock(BR_XTIME_LOCK);
 	}
 #else
 	do_timer(regs);
diff -urNp linux-7010/arch/s390x/kernel/time.c linux-7020/arch/s390x/kernel/time.c
--- linux-7010/arch/s390x/kernel/time.c
+++ linux-7020/arch/s390x/kernel/time.c
@@ -43,7 +43,6 @@
 static ext_int_info_t ext_int_info_timer;
 static uint64_t init_timer_cc;
 
-extern rwlock_t xtime_lock;
 extern unsigned long wall_jiffies;
 
 void tod_to_timeval(__u64 todval, struct timeval *xtime)
@@ -72,10 +71,10 @@ void do_gettimeofday(struct timeval *tv)
 	unsigned long flags;
 	unsigned long usec, sec;
 
-	read_lock_irqsave(&xtime_lock, flags);
+	br_read_lock_irqsave(BR_XTIME_LOCK, flags);
 	sec = xtime.tv_sec;
 	usec = xtime.tv_usec + do_gettimeoffset();
-	read_unlock_irqrestore(&xtime_lock, flags);
+	br_read_unlock_irqrestore(BR_XTIME_LOCK, flags);
 
 	while (usec >= 1000000) {
 		usec -= 1000000;
@@ -89,7 +88,7 @@ void do_gettimeofday(struct timeval *tv)
 void do_settimeofday(struct timeval *tv)
 {
 
-	write_lock_irq(&xtime_lock);
+	br_write_lock_irq(BR_XTIME_LOCK);
 	/* This is revolting. We need to set the xtime.tv_usec
 	 * correctly. However, the value in this location is
 	 * is value at the last tick.
@@ -108,7 +107,7 @@ void do_settimeofday(struct timeval *tv)
 	time_status |= STA_UNSYNC;
 	time_maxerror = NTP_PHASE_LIMIT;
 	time_esterror = NTP_PHASE_LIMIT;
-	write_unlock_irq(&xtime_lock);
+	br_write_unlock_irq(BR_XTIME_LOCK);
 }
 
 #ifdef CONFIG_PROFILING
@@ -182,13 +181,13 @@ static void do_comparator_interrupt(stru
 
 #ifdef CONFIG_SMP
 	if (S390_lowcore.cpu_data.cpu_addr == boot_cpu_addr)
-		write_lock(&xtime_lock);
+		br_write_lock(BR_XTIME_LOCK);
 
 	update_process_times(user_mode(regs));
 
 	if (S390_lowcore.cpu_data.cpu_addr == boot_cpu_addr) {
 		do_timer(regs);
-		write_unlock(&xtime_lock);
+		br_write_unlock(BR_XTIME_LOCK);
 	}
 #else
 	do_timer(regs);
diff -urNp linux-7010/arch/x86_64/kernel/time.c linux-7020/arch/x86_64/kernel/time.c
--- linux-7010/arch/x86_64/kernel/time.c
+++ linux-7020/arch/x86_64/kernel/time.c
@@ -22,7 +22,6 @@
 #include <asm/vsyscall.h>
 #include <asm/timex.h>
 
-extern rwlock_t xtime_lock;
 spinlock_t rtc_lock = SPIN_LOCK_UNLOCKED;
 spinlock_t i8253_lock = SPIN_LOCK_UNLOCKED;
 
@@ -160,7 +159,7 @@ void do_gettimeofday(struct timeval *tv)
 
 void do_settimeofday(struct timeval *tv)
 {
-	write_lock_irq(&xtime_lock);
+	br_write_lock_irq(BR_XTIME_LOCK);
 	vxtime_lock();
 
 	tv->tv_usec -= (jiffies - wall_jiffies) * tick
@@ -179,7 +178,7 @@ void do_settimeofday(struct timeval *tv)
 	time_maxerror = NTP_PHASE_LIMIT;
 	time_esterror = NTP_PHASE_LIMIT;
 
-	write_unlock_irq(&xtime_lock);
+	br_write_unlock_irq(BR_XTIME_LOCK);
 }
 
 /*
@@ -262,7 +261,7 @@ static void timer_interrupt(int irq, voi
  * variables, because both do_timer() and us change them -arca+vojtech
  */
 
-	write_lock(&xtime_lock);
+	br_write_lock(BR_XTIME_LOCK);
 	vxtime_lock();
 
 	{
@@ -360,7 +359,7 @@ static void timer_interrupt(int irq, voi
 	}
 
 	vxtime_unlock();
-	write_unlock(&xtime_lock);
+	br_write_unlock(BR_XTIME_LOCK);
 }
 
 static unsigned long get_cmos_time(void)
@@ -656,10 +655,10 @@ void __init time_init(void)
         hpet_address = 0;
 #endif
 
-	write_lock(&xtime_lock);
+	br_write_lock(BR_XTIME_LOCK);
 	xtime.tv_sec = get_cmos_time();
 	xtime.tv_usec = 0;
-	write_unlock(&xtime_lock);
+	br_write_unlock(BR_XTIME_LOCK);
 
 	if (!hpet_init()) {
                 timer_hz = vxtime_hz = (1000000000000000L + hpet_period / 2) / hpet_period;
diff -urNp linux-7010/drivers/char/ipmi/ipmi_kcs_intf.c linux-7020/drivers/char/ipmi/ipmi_kcs_intf.c
--- linux-7010/drivers/char/ipmi/ipmi_kcs_intf.c
+++ linux-7020/drivers/char/ipmi/ipmi_kcs_intf.c
@@ -684,13 +684,13 @@ static void kcs_restart_short_timer(stru
 
 		/* We already have irqsave on, so no need for it
                    here. */
-		read_lock(&xtime_lock);
+		br_read_lock(BR_XTIME_LOCK);
 		jiffies_now = jiffies;
 		kcs_info->kcs_timer.expires = jiffies_now;
 
 		kcs_info->kcs_timer.sub_expires
 			= quick_update_jiffies_sub(jiffies_now);
-		read_unlock(&xtime_lock);
+		br_read_unlock(BR_XTIME_LOCK);
 
 		kcs_info->kcs_timer.sub_expires
 			+= usec_to_arch_cycles(KCS_SHORT_TIMEOUT_USEC);
diff -urNp linux-7010/drivers/char/ipmi/ipmi_si.c linux-7020/drivers/char/ipmi/ipmi_si.c
--- linux-7010/drivers/char/ipmi/ipmi_si.c
+++ linux-7020/drivers/char/ipmi/ipmi_si.c
@@ -847,11 +847,11 @@ static void si_restart_short_timer(struc
 
 		/* We already have irqsave on, so no need for it
                    here. */
-		read_lock(&xtime_lock);
+		br_read_lock(BR_XTIME_LOCK);
 		jiffies_now = jiffies;
 		smi_info->si_timer.expires = jiffies_now;
 		smi_info->si_timer.sub_expires = get_arch_cycles(jiffies_now);
-		read_unlock(&xtime_lock);
+		br_read_unlock(BR_XTIME_LOCK);
 
 		add_usec_to_timer(&smi_info->si_timer, SI_SHORT_TIMEOUT_USEC);
 
@@ -907,11 +907,11 @@ static void smi_timeout(unsigned long da
 		smi_info->short_timeouts++;
 		spin_unlock_irqrestore(&smi_info->count_lock, flags);
 #if defined(CONFIG_HIGH_RES_TIMERS)
-		read_lock(&xtime_lock);
+		br_read_lock(BR_XTIME_LOCK);
                 smi_info->si_timer.expires = jiffies;
                 smi_info->si_timer.sub_expires
                         = get_arch_cycles(smi_info->si_timer.expires);
-                read_unlock(&xtime_lock);
+		br_read_unlock(BR_XTIME_LOCK);
 		add_usec_to_timer(&smi_info->si_timer, SI_SHORT_TIMEOUT_USEC);
 #else
 		smi_info->si_timer.expires = jiffies + 1;
diff -urNp linux-7010/include/asm-ia64/timex.h linux-7020/include/asm-ia64/timex.h
--- linux-7010/include/asm-ia64/timex.h
+++ linux-7020/include/asm-ia64/timex.h
@@ -24,4 +24,10 @@ get_cycles (void)
 #define vxtime_lock()		do {} while (0)
 #define vxtime_unlock()		do {} while (0)
 
+#define ARCH_UPDATE_WALL_TIME() \
+do { \
+	extern unsigned long last_time_offset; \
+	last_time_offset = 0; \
+} while (0)
+
 #endif /* _ASM_IA64_TIMEX_H */
diff -urNp linux-7010/include/linux/brlock.h linux-7020/include/linux/brlock.h
--- linux-7010/include/linux/brlock.h
+++ linux-7020/include/linux/brlock.h
@@ -39,6 +39,7 @@ enum brlock_indices {
 	BR_LRU_LOCK,
 	BR_PAGECACHE_LOCK,
 	BR_GENHD_LOCK,
+	BR_XTIME_LOCK,
 
 	__BR_END
 };
@@ -205,7 +206,7 @@ static inline void br_write_unlock (enum
 	do { local_bh_disable(); br_write_lock(idx); } while (0)
 
 #define br_read_unlock_irqrestore(idx, flags) \
-	do { br_read_unlock(irx); local_irq_restore(flags); } while (0)
+	do { br_read_unlock(idx); local_irq_restore(flags); } while (0)
 
 #define br_read_unlock_irq(idx) \
 	do { br_read_unlock(idx); local_irq_enable(); } while (0)
@@ -214,7 +215,7 @@ static inline void br_write_unlock (enum
 	do { br_read_unlock(idx); local_bh_enable(); } while (0)
 
 #define br_write_unlock_irqrestore(idx, flags) \
-	do { br_write_unlock(irx); local_irq_restore(flags); } while (0)
+	do { br_write_unlock(idx); local_irq_restore(flags); } while (0)
 
 #define br_write_unlock_irq(idx) \
 	do { br_write_unlock(idx); local_irq_enable(); } while (0)
diff -urNp linux-7010/kernel/time.c linux-7020/kernel/time.c
--- linux-7010/kernel/time.c
+++ linux-7020/kernel/time.c
@@ -36,9 +36,8 @@
  */
 struct timezone sys_tz;
 
-/* The xtime_lock is not only serializing the xtime read/writes but it's also
+/* The BR_XTIME_LOCK is not only serializing the xtime read/writes but it's also
    serializing all accesses to the global NTP variables now. */
-extern rwlock_t xtime_lock;
 
 #if !defined(__alpha__) && !defined(__ia64__)
 
@@ -79,7 +78,7 @@ asmlinkage long sys_stime(int * tptr)
 		return -EPERM;
 	if (get_user(value, tptr))
 		return -EFAULT;
-	write_lock_irq(&xtime_lock);
+	br_write_lock_irq(BR_XTIME_LOCK);
 	vxtime_lock();
 	xtime.tv_sec = value;
 	xtime.tv_usec = 0;
@@ -88,7 +87,7 @@ asmlinkage long sys_stime(int * tptr)
 	time_status |= STA_UNSYNC;
 	time_maxerror = NTP_PHASE_LIMIT;
 	time_esterror = NTP_PHASE_LIMIT;
-	write_unlock_irq(&xtime_lock);
+	br_write_unlock_irq(BR_XTIME_LOCK);
 	return 0;
 }
 
@@ -127,11 +126,11 @@ asmlinkage long sys_gettimeofday(struct 
  */
 inline static void warp_clock(void)
 {
-	write_lock_irq(&xtime_lock);
+	br_write_lock_irq(BR_XTIME_LOCK);
 	vxtime_lock();
 	xtime.tv_sec += sys_tz.tz_minuteswest * 60;
 	vxtime_unlock();
-	write_unlock_irq(&xtime_lock);
+	br_write_unlock_irq(BR_XTIME_LOCK);
 }
 
 /*
@@ -235,7 +234,7 @@ int do_adjtimex(struct timex *txc)
 		if (txc->tick < 900000/HZ || txc->tick > 1100000/HZ)
 			return -EINVAL;
 
-	write_lock_irq(&xtime_lock);
+	br_write_lock_irq(BR_XTIME_LOCK);
 	result = time_state;	/* mostly `TIME_OK' */
 
 	/* Save for later - semantics of adjtime is to return old value */
@@ -390,7 +389,7 @@ leave:	if ((time_status & (STA_UNSYNC|ST
 	txc->calcnt	   = pps_calcnt;
 	txc->errcnt	   = pps_errcnt;
 	txc->stbcnt	   = pps_stbcnt;
-	write_unlock_irq(&xtime_lock);
+	br_write_unlock_irq(BR_XTIME_LOCK);
 	do_gettimeofday(&txc->time);
 	return(result);
 }
diff -urNp linux-7010/kernel/timer.c linux-7020/kernel/timer.c
--- linux-7010/kernel/timer.c
+++ linux-7020/kernel/timer.c
@@ -34,7 +34,7 @@ struct kernel_stat_percpu kstat_percpu[N
 long tick = (1000000 + HZ/2) / HZ;	/* timer interrupt period */
 
 /* The current time */
-struct timeval xtime __attribute__ ((aligned (16)));
+struct timeval xtime __cacheline_aligned;
 
 /* Don't completely fail for HZ > 500.  */
 int tickadj = 500/HZ ? : 1;		/* microsecs */
@@ -67,7 +67,7 @@ unsigned long event;
 
 extern int do_setitimer(int, struct itimerval *, struct itimerval *);
 
-unsigned long volatile jiffies;
+unsigned long volatile jiffies __cacheline_aligned;
 
 /*
  * Event timer code
@@ -530,6 +530,9 @@ static void update_wall_time(unsigned lo
 	    xtime.tv_sec++;
 	    second_overflow();
 	}
+#ifdef ARCH_UPDATE_WALL_TIME
+	ARCH_UPDATE_WALL_TIME();
+#endif
 }
 
 static inline void do_process_times(struct task_struct *p,
@@ -635,11 +638,6 @@ static inline void calc_load(unsigned lo
 /* jiffies at the most recent update of wall time */
 unsigned long wall_jiffies;
 
-/*
- * This spinlock protect us from races in SMP while playing with xtime. -arca
- */
-rwlock_t xtime_lock = RW_LOCK_UNLOCKED;
-
 static inline void update_times(void)
 {
 	unsigned long ticks;
@@ -649,7 +647,7 @@ static inline void update_times(void)
 	 * just know that the irqs are locally enabled and so we don't
 	 * need to save/restore the flags of the local CPU here. -arca
 	 */
-	write_lock_irq(&xtime_lock);
+	br_write_lock_irq(BR_XTIME_LOCK);
 	vxtime_lock();
 
 	ticks = jiffies - wall_jiffies;
@@ -658,7 +656,7 @@ static inline void update_times(void)
 		update_wall_time(ticks);
 	}
 	vxtime_unlock();
-	write_unlock_irq(&xtime_lock);
+	br_write_unlock_irq(BR_XTIME_LOCK);
 	calc_load(ticks);
 }
 
