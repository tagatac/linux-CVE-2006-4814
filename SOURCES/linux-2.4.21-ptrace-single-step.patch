diff -urNp linux-8260/arch/i386/kernel/entry.S linux-8270/arch/i386/kernel/entry.S
--- linux-8260/arch/i386/kernel/entry.S
+++ linux-8270/arch/i386/kernel/entry.S
@@ -309,7 +309,7 @@ ENTRY(system_call)
 	pushl %eax			# save orig_eax
 	SAVE_ALL
 	GET_CURRENT(%ebx)
-	testw $0x802,tsk_ptrace(%ebx)	# PT_TRACESYS|PT_AUDITED
+	testw $0x1802,tsk_ptrace(%ebx)	# PT_TRACESYS|PT_AUDITED|PT_SINGLESTEP
 	jne tracesys
 	cmpl $(NR_syscalls),%eax
 	jae badsys
diff -urNp linux-8260/arch/i386/kernel/ptrace.c linux-8270/arch/i386/kernel/ptrace.c
--- linux-8260/arch/i386/kernel/ptrace.c
+++ linux-8270/arch/i386/kernel/ptrace.c
@@ -146,6 +146,7 @@ void ptrace_disable(struct task_struct *
 { 
 	long tmp;
 
+	child->ptrace &= ~PT_SINGLESTEP;
 	tmp = get_stack_long(child, EFL_OFFSET) & ~TRAP_FLAG;
 	put_stack_long(child, EFL_OFFSET, tmp);
 }
@@ -363,6 +364,7 @@ asmlinkage int sys_ptrace(long request, 
 			child->ptrace |= PT_TRACESYS;
 		else
 			child->ptrace &= ~PT_TRACESYS;
+		child->ptrace &= ~PT_SINGLESTEP;
 		child->exit_code = data;
 	/* make sure the single step bit is not set. */
 		tmp = get_stack_long(child, EFL_OFFSET) & ~TRAP_FLAG;
@@ -385,6 +387,7 @@ asmlinkage int sys_ptrace(long request, 
 			break;
 		child->exit_code = SIGKILL;
 		/* make sure the single step bit is not set. */
+		child->ptrace &= ~PT_SINGLESTEP;
 		tmp = get_stack_long(child, EFL_OFFSET) & ~TRAP_FLAG;
 		put_stack_long(child, EFL_OFFSET, tmp);
 		wake_up_process(child);
@@ -398,6 +401,7 @@ asmlinkage int sys_ptrace(long request, 
 		if ((unsigned long) data > _NSIG)
 			break;
 		child->ptrace &= ~PT_TRACESYS;
+		child->ptrace |= PT_SINGLESTEP;
 		if ((child->ptrace & PT_DTRACE) == 0) {
 			/* Spurious delayed TF traps may occur */
 			child->ptrace |= PT_DTRACE;
@@ -545,9 +549,11 @@ asmlinkage void syscall_trace_enter(stru
 
 asmlinkage void syscall_trace_leave(struct pt_regs *regs)
 {
+	int ptrace = current->ptrace;
+
 	if (isaudit(current) && (current->ptrace & PT_AUDITED))
 		audit_result(regs);
 
-	if ((current->ptrace & (PT_PTRACED|PT_TRACESYS)) == (PT_PTRACED|PT_TRACESYS))
+	if ((ptrace & PT_PTRACED) && (ptrace & (PT_TRACESYS|PT_SINGLESTEP)))
 		syscall_ptrace();
 }
diff -urNp linux-8260/arch/i386/kernel/signal.c linux-8270/arch/i386/kernel/signal.c
--- linux-8260/arch/i386/kernel/signal.c
+++ linux-8270/arch/i386/kernel/signal.c
@@ -337,6 +337,9 @@ setup_sigcontext(struct sigcontext *__sc
 	sc.eip = regs->eip;
 	*(unsigned int *)&sc.cs = regs->xcs;
 	sc.eflags = regs->eflags;
+	if (current->ptrace & PT_PTRACED) {
+		sc.eflags &= ~TF_MASK;
+	}
 	sc.esp_at_signal = regs->esp;
 	*(unsigned int *)&sc.ss = regs->xss;
 
@@ -436,7 +439,13 @@ static void setup_frame(int sig, struct 
 	regs->xes = __USER_DS;
 	regs->xss = __USER_DS;
 	regs->xcs = __USER_CS;
-	regs->eflags &= ~TF_MASK;
+	if (regs->eflags & TF_MASK) {
+		if (current->ptrace & PT_PTRACED) {
+			ptrace_notify(SIGTRAP);
+		} else {
+			regs->eflags &= ~TF_MASK;
+		}
+	}
 
 #if DEBUG_SIG
 	printk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",
@@ -511,7 +520,13 @@ static void setup_rt_frame(int sig, stru
 	regs->xes = __USER_DS;
 	regs->xss = __USER_DS;
 	regs->xcs = __USER_CS;
-	regs->eflags &= ~TF_MASK;
+	if (regs->eflags & TF_MASK) {
+		if (current->ptrace & PT_PTRACED) {
+			ptrace_notify(SIGTRAP);
+		} else {
+			regs->eflags &= ~TF_MASK;
+		}
+	}
 
 #if DEBUG_SIG
 	printk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",
diff -urNp linux-8260/arch/ia64/kernel/ptrace.c linux-8270/arch/ia64/kernel/ptrace.c
--- linux-8260/arch/ia64/kernel/ptrace.c
+++ linux-8270/arch/ia64/kernel/ptrace.c
@@ -1192,6 +1192,8 @@ ptrace_disable (struct task_struct *chil
 	child_psr->ss = 0;
 	child_psr->tb = 0;
 
+	child->ptrace &= ~PT_SINGLESTEP;
+
 	/* Turn off flag indicating that the KRBS is sync'd with child's VM: */
 	child->thread.flags &= ~IA64_THREAD_KRBS_SYNCED;
 }
@@ -1293,6 +1295,7 @@ sys_ptrace (long request, pid_t pid, uns
 			child->ptrace |= PT_TRACESYS;
 		else
 			child->ptrace &= ~PT_TRACESYS;
+		child->ptrace &= ~PT_SINGLESTEP;
 		child->exit_code = data;
 
 		/* make sure the single step/taken-branch trap bits are not set: */
@@ -1319,6 +1322,7 @@ sys_ptrace (long request, pid_t pid, uns
 		/* make sure the single step/take-branch tra bits are not set: */
 		ia64_psr(pt)->ss = 0;
 		ia64_psr(pt)->tb = 0;
+		child->ptrace &= ~PT_SINGLESTEP;
 
 		/* Turn off flag indicating that the KRBS is sync'd with child's VM: */
 		child->thread.flags &= ~IA64_THREAD_KRBS_SYNCED;
@@ -1334,6 +1338,7 @@ sys_ptrace (long request, pid_t pid, uns
 			goto out_tsk;
 
 		child->ptrace &= ~PT_TRACESYS;
+		child->ptrace |= PT_SINGLESTEP;
 		if (request == PTRACE_SINGLESTEP) {
 			ia64_psr(pt)->ss = 1;
 		} else {
@@ -1404,7 +1409,8 @@ asmlinkage void syscall_trace_enter(stru
 
 asmlinkage void syscall_trace_leave(struct pt_regs *regs)
 {
-	if ((current->ptrace & (PT_PTRACED|PT_TRACESYS)) == (PT_PTRACED|PT_TRACESYS))
+	int ptrace = current->ptrace;
+	if ((ptrace & PT_PTRACED) && (ptrace & (PT_TRACESYS|PT_SINGLESTEP)))
 		syscall_trace();
 
 #if defined(CONFIG_AUDIT) || defined(CONFIG_AUDIT_MODULE)
diff -urNp linux-8260/arch/ia64/tools/print_offsets.c linux-8270/arch/ia64/tools/print_offsets.c
--- linux-8260/arch/ia64/tools/print_offsets.c
+++ linux-8270/arch/ia64/tools/print_offsets.c
@@ -206,7 +206,7 @@ main (int argc, char **argv)
   printf ("#define PT_PTRACED_BIT\t\t\t%u\n", ffs (PT_PTRACED) - 1);
   printf ("#define PT_TRACESYS_BIT\t\t\t%u\n", ffs (PT_TRACESYS) - 1);
   printf ("#define PT_AUDITED_BIT\t\t\t%u\n", ffs (PT_AUDITED) - 1);
-  printf ("#define PT_TRACEAUDITMASK\t\t0x%x\n\n", PT_TRACESYS|PT_AUDITED);
+  printf ("#define PT_TRACEAUDITMASK\t\t0x%x\n\n", PT_TRACESYS|PT_AUDITED|PT_SINGLESTEP);
 
   for (i = 0; i < sizeof (tab) / sizeof (tab[0]); ++i)
     {
diff -urNp linux-8260/arch/ppc64/kernel/entry.S linux-8270/arch/ppc64/kernel/entry.S
--- linux-8260/arch/ppc64/kernel/entry.S
+++ linux-8270/arch/ppc64/kernel/entry.S
@@ -82,7 +82,7 @@ _GLOBAL(DoSyscall)
 1:
 #endif /* SHOW_SYSCALLS */
 	ld	r10,TASK_PTRACE(r13)
-	andi.	r10,r10,PT_TRACESYS|PT_AUDITED
+	andi.	r10,r10,PT_TRACESYS|PT_AUDITED|PT_SINGLESTEP
 	bne-	50f
 	cmpli	0,r0,NR_syscalls
 	bge-	66f
@@ -220,7 +220,7 @@ _GLOBAL(ppc64_rt_sigreturn)
 	bl	.sys_rt_sigreturn
 
 80:	ld	r10,TASK_PTRACE(r13)
-	andi.	r10,r10,PT_TRACESYS|PT_AUDITED
+	andi.	r10,r10,PT_TRACESYS|PT_AUDITED|PT_SINGLESTEP
 	bne-	81f
 	cmpi	0,r3,0
 	bge	.ret_from_except
diff -urNp linux-8260/arch/ppc64/kernel/mk_defs.c linux-8270/arch/ppc64/kernel/mk_defs.c
--- linux-8260/arch/ppc64/kernel/mk_defs.c
+++ linux-8270/arch/ppc64/kernel/mk_defs.c
@@ -129,6 +129,7 @@ main(void)
 	DEFINE(PT_REGS, offsetof(struct thread_struct, regs));
 	DEFINE(PT_TRACESYS, PT_TRACESYS);
 	DEFINE(PT_AUDITED, PT_AUDITED);
+	DEFINE(PT_SINGLESTEP, PT_SINGLESTEP);
 	DEFINE(TASK_PTRACE, offsetof(struct task_struct, ptrace));
 	DEFINE(NEED_RESCHED, offsetof(struct task_struct, need_resched));
 	DEFINE(THREAD_FPR0, offsetof(struct thread_struct, fpr[0]));
diff -urNp linux-8260/arch/ppc64/kernel/ptrace.c linux-8270/arch/ppc64/kernel/ptrace.c
--- linux-8260/arch/ppc64/kernel/ptrace.c
+++ linux-8270/arch/ppc64/kernel/ptrace.c
@@ -100,6 +100,7 @@ set_single_step(struct task_struct *task
 	struct pt_regs *regs = task->thread.regs;
 	if (regs != NULL)
 		regs->msr |= MSR_SE;
+	task->ptrace |= PT_SINGLESTEP;
 }
 
 static inline void
@@ -108,6 +109,7 @@ clear_single_step(struct task_struct *ta
 	struct pt_regs *regs = task->thread.regs;
 	if (regs != NULL)
 		regs->msr &= ~MSR_SE;
+	task->ptrace &= ~PT_SINGLESTEP;
 }
 
 /*
@@ -401,9 +403,11 @@ void syscall_trace_enter(struct pt_regs 
 
 void syscall_trace_leave(struct pt_regs *regs)
 {
+	int ptrace = current->ptrace;
+
 	if (isaudit(current) && (current->ptrace & PT_AUDITED))
 		audit_result(regs);
 
-	if ((current->ptrace & (PT_PTRACED|PT_TRACESYS)) == (PT_PTRACED|PT_TRACESYS))
+	if ((ptrace & PT_PTRACED) && (ptrace & (PT_TRACESYS|PT_SINGLESTEP)))
 		syscall_ptrace();
 }
diff -urNp linux-8260/arch/ppc64/kernel/ptrace32.c linux-8270/arch/ppc64/kernel/ptrace32.c
--- linux-8260/arch/ppc64/kernel/ptrace32.c
+++ linux-8270/arch/ppc64/kernel/ptrace32.c
@@ -113,6 +113,7 @@ set_single_step(struct task_struct *task
 	struct pt_regs *regs = task->thread.regs;
 	if (regs != NULL)
 		regs->msr |= MSR_SE;
+	task->ptrace |= PT_SINGLESTEP;
 }
 
 static inline void
@@ -121,6 +122,7 @@ clear_single_step(struct task_struct *ta
 	struct pt_regs *regs = task->thread.regs;
 	if (regs != NULL)
 		regs->msr &= ~MSR_SE;
+	task->ptrace &= ~PT_SINGLESTEP;
 }
 
 int sys32_ptrace(long request, long pid, unsigned long addr, unsigned long data)
diff -urNp linux-8260/arch/ppc64/kernel/signal.c linux-8270/arch/ppc64/kernel/signal.c
--- linux-8260/arch/ppc64/kernel/signal.c
+++ linux-8270/arch/ppc64/kernel/signal.c
@@ -428,6 +428,9 @@ setup_rt_frame(int signr, struct k_sigac
 	if (err)
 		goto give_sigsegv;
 
+	if (current->ptrace & PT_SINGLESTEP)
+		ptrace_notify(SIGTRAP);
+
 	return;
 
 give_sigsegv:
@@ -511,6 +514,9 @@ setup_frame(int signr, struct k_sigactio
 	if (err)
 		goto badframe;
 
+	if (current->ptrace & PT_SINGLESTEP)
+		ptrace_notify(SIGTRAP);
+
 	return;
 
 badframe:
diff -urNp linux-8260/arch/ppc64/kernel/signal32.c linux-8270/arch/ppc64/kernel/signal32.c
--- linux-8260/arch/ppc64/kernel/signal32.c
+++ linux-8270/arch/ppc64/kernel/signal32.c
@@ -405,6 +405,9 @@ setup_frame32(struct pt_regs *regs, int 
 		goto badframe;
 	regs->gpr[1] = newsp;
 
+	if (current->ptrace & PT_SINGLESTEP)
+		ptrace_notify(SIGTRAP);
+
 	return;
 
  badframe:
@@ -952,6 +955,9 @@ setup_rt_frame32(struct pt_regs *regs, i
 	regs->nip    = (unsigned long) ka->sa.sa_handler;
 	regs->link   = (unsigned long) frame->tramp;
 
+	if (current->ptrace & PT_SINGLESTEP)
+		ptrace_notify(SIGTRAP);
+
 	return;
 
  badframe:
diff -urNp linux-8260/arch/s390/kernel/entry.S linux-8270/arch/s390/kernel/entry.S
--- linux-8260/arch/s390/kernel/entry.S
+++ linux-8270/arch/s390/kernel/entry.S
@@ -181,7 +181,7 @@ system_call:
         stosm   24(%r15),0x03     # reenable interrupts
         l       %r8,sys_call_table-entry_base(%r7,%r13) # get system call addr.
         l       %r1,__TASK_ptrace(%r9) # process ptrace flags
-        tml     %r1,0x802         # PT_TRACESYS|PT_AUDITED
+        tml     %r1,0x1802        # PT_TRACESYS|PT_AUDITED|PT_SINGLESTEP
         bnz     BASED(sysc_tracesys)
         basr    %r14,%r8          # call sys_xxxx
         st      %r2,SP_R2(%r15)   # store return value (change R2 on stack)
@@ -689,7 +689,7 @@ pgm_svcper:
         stosm   24(%r15),0x03     # reenable interrupts
         l       %r8,sys_call_table-entry_base(%r7,%r13) # get system call addr.
         l       %r1,__TASK_ptrace(%r9) # process ptrace flags
-        tml     %r1,0x802         # PT_TRACESYS|PT_AUDITED
+        tml     %r1,0x1802        # PT_TRACESYS|PT_AUDITED|PT_SINGLESTEP
         bnz     BASED(pgm_tracesys)
         basr    %r14,%r8          # call sys_xxxx
         st      %r2,SP_R2(%r15)   # store return value (change R2 on stack)
diff -urNp linux-8260/arch/s390/kernel/ptrace.c linux-8270/arch/s390/kernel/ptrace.c
--- linux-8260/arch/s390/kernel/ptrace.c
+++ linux-8270/arch/s390/kernel/ptrace.c
@@ -84,6 +84,7 @@ void set_single_step(struct task_struct 
 	per_struct *per_info=
 			(per_struct *)&task->thread.per_info;	
 	
+	task->ptrace |= PT_SINGLESTEP;
 	per_info->single_step=1;  /* Single step */
 	FixPerRegisters(task);
 }
@@ -93,6 +94,7 @@ void clear_single_step(struct task_struc
 	per_struct *per_info=
 			(per_struct *)&task->thread.per_info;
 
+	task->ptrace &= ~PT_SINGLESTEP;
 	per_info->single_step=0;
 	FixPerRegisters(task);
 }
@@ -391,10 +393,11 @@ asmlinkage void syscall_trace_enter(stru
 
 asmlinkage void syscall_trace_exit(struct pt_regs *regs)
 {
+	int ptrace = current->ptrace;
+
 	if (isaudit(current) && (current->ptrace & PT_AUDITED))
 		audit_result(regs);
-	if ((current->ptrace & (PT_PTRACED|PT_TRACESYS)) ==
-		(PT_PTRACED|PT_TRACESYS))
+	if ((ptrace & PT_PTRACED) && (ptrace & (PT_TRACESYS|PT_SINGLESTEP)))
 		syscall_ptrace();
 }
 
diff -urNp linux-8260/arch/s390x/kernel/entry.S linux-8270/arch/s390x/kernel/entry.S
--- linux-8260/arch/s390x/kernel/entry.S
+++ linux-8270/arch/s390x/kernel/entry.S
@@ -167,7 +167,7 @@ system_call:
 sysc_noemu:
         lgf     %r8,0(%r7,%r10)   # load address of system call routine
         lg      %r1,__TASK_ptrace(%r9) # process ptrace flags
-        tml     %r1,0x802         # PT_TRACESYS|PT_AUDITED
+        tml     %r1,0x1802        # PT_TRACESYS|PT_AUDITED|PT_SINGLESTEP
         jnz     sysc_tracesys
         basr    %r14,%r8          # call sys_xxxx
         stg     %r2,SP_R2(%r15)   # store return value (change R2 on stack)
@@ -726,7 +726,7 @@ pgm_svcper:
 pgm_svcper_noemu:
         lgf     %r8,0(%r7,%r10)   # load address of system call routine
         lg      %r1,__TASK_ptrace(%r9) # process ptrace flags
-        tml     %r1,0x802         # PT_TRACESYS|PT_AUDITED
+        tml     %r1,0x1802        # PT_TRACESYS|PT_AUDITED|PT_SINGLESTEP
         jnz     pgm_tracesys
         basr    %r14,%r8          # call sys_xxxx
         stg     %r2,SP_R2(%r15)   # store return value (change R2 on stack)
diff -urNp linux-8260/arch/s390x/kernel/ptrace.c linux-8270/arch/s390x/kernel/ptrace.c
--- linux-8260/arch/s390x/kernel/ptrace.c
+++ linux-8270/arch/s390x/kernel/ptrace.c
@@ -88,6 +88,7 @@ void set_single_step(struct task_struct 
 {
 	per_struct *per_info= (per_struct *) &task->thread.per_info;	
 	
+	task->ptrace |= PT_SINGLESTEP;
 	per_info->single_step = 1;  /* Single step */
 	FixPerRegisters (task);
 }
@@ -96,6 +97,7 @@ void clear_single_step(struct task_struc
 {
 	per_struct *per_info= (per_struct *) &task->thread.per_info;
 
+	task->ptrace &= ~PT_SINGLESTEP;
 	per_info->single_step = 0;
 	FixPerRegisters (task);
 }
@@ -624,10 +626,11 @@ asmlinkage void syscall_trace_enter(stru
 
 asmlinkage void syscall_trace_exit(struct pt_regs *regs)
 {
+	int ptrace = current->ptrace;
+
 	if (isaudit(current) && (current->ptrace & PT_AUDITED))
 		audit_result(regs);
-	if ((current->ptrace & (PT_PTRACED|PT_TRACESYS)) ==
-		(PT_PTRACED|PT_TRACESYS))
+	if ((ptrace & PT_PTRACED) && (ptrace & (PT_TRACESYS|PT_SINGLESTEP)))
 		syscall_ptrace();
 }
 
diff -urNp linux-8260/arch/x86_64/ia32/ia32_signal.c linux-8270/arch/x86_64/ia32/ia32_signal.c
--- linux-8260/arch/x86_64/ia32/ia32_signal.c
+++ linux-8270/arch/x86_64/ia32/ia32_signal.c
@@ -299,6 +299,7 @@ ia32_setup_sigcontext(struct sigcontext_
 		 struct pt_regs *regs, unsigned int mask)
 {
 	int tmp, err = 0;
+	unsigned long eflags;
 
 	tmp = 0;
 	__asm__("movl %%gs,%0" : "=r"(tmp): "0"(tmp));
@@ -323,7 +324,11 @@ ia32_setup_sigcontext(struct sigcontext_
 	err |= __put_user(current->thread.trap_no, &sc->trapno);
 	err |= __put_user(current->thread.error_code, &sc->err);
 	err |= __put_user((u32)regs->rip, &sc->eip);
-	err |= __put_user((u32)regs->eflags, &sc->eflags);
+	eflags = regs->eflags;
+	if (current->ptrace & PT_PTRACED) {
+		eflags &= ~TF_MASK;
+	}
+	err |= __put_user(regs->eflags, &sc->eflags);
 	err |= __put_user((u32)regs->rsp, &sc->esp_at_signal);
 
 	tmp = save_i387_ia32(current, fpstate, regs, 0);
@@ -427,7 +432,13 @@ void ia32_setup_frame(int sig, struct k_
 	regs->ss = __USER32_DS; 
 
 	set_fs(USER_DS);
-	regs->eflags &= ~TF_MASK;
+	if (regs->eflags & TF_MASK) {
+		if (current->ptrace & PT_PTRACED) {
+			ptrace_notify(SIGTRAP);
+		} else {
+			regs->eflags &= ~TF_MASK;
+		}
+	}
 
 #if DEBUG_SIG
 	printk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",
@@ -504,7 +515,13 @@ void ia32_setup_rt_frame(int sig, struct
 	regs->ss = __USER32_DS; 
 
 	set_fs(USER_DS);
-	regs->eflags &= ~TF_MASK;
+	if (regs->eflags & TF_MASK) {
+		if (current->ptrace & PT_PTRACED) {
+			ptrace_notify(SIGTRAP);
+		} else {
+			regs->eflags &= ~TF_MASK;
+		}
+	}
 
 #if DEBUG_SIG
 	printk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",
diff -urNp linux-8260/arch/x86_64/ia32/ia32entry.S linux-8270/arch/x86_64/ia32/ia32entry.S
--- linux-8260/arch/x86_64/ia32/ia32entry.S
+++ linux-8270/arch/x86_64/ia32/ia32entry.S
@@ -57,7 +57,7 @@ ENTRY(ia32_syscall)
 	cld
 	SAVE_ARGS
 	GET_CURRENT(%r10)
-	testl $PT_TRACESYS|PT_AUDITED,tsk_ptrace(%r10) 
+	testl $PT_TRACESYS|PT_AUDITED|PT_SINGLESTEP,tsk_ptrace(%r10) 
 	jne  ia32_tracesys
 	cmpl $(IA32_NR_syscalls),%eax
 	jae  ia32_badsys
diff -urNp linux-8260/arch/x86_64/kernel/entry.S linux-8270/arch/x86_64/kernel/entry.S
--- linux-8260/arch/x86_64/kernel/entry.S
+++ linux-8270/arch/x86_64/kernel/entry.S
@@ -123,7 +123,7 @@ ENTRY(system_call)
 	movq  %rax,ORIG_RAX-ARGOFFSET(%rsp) 
 	movq  %rcx,RIP-ARGOFFSET(%rsp)	
 	GET_CURRENT(%rcx)
-	testl $PT_TRACESYS|PT_AUDITED,tsk_ptrace(%rcx)
+	testl $PT_TRACESYS|PT_AUDITED|PT_SINGLESTEP,tsk_ptrace(%rcx)
 	jne tracesys
 	cmpq $__NR_syscall_max,%rax
 	ja badsys
diff -urNp linux-8260/arch/x86_64/kernel/ptrace.c linux-8270/arch/x86_64/kernel/ptrace.c
--- linux-8260/arch/x86_64/kernel/ptrace.c
+++ linux-8270/arch/x86_64/kernel/ptrace.c
@@ -85,6 +85,7 @@ void ptrace_disable(struct task_struct *
 { 
 	long tmp;
 
+	child->ptrace &= ~PT_SINGLESTEP;
 	tmp = get_stack_long(child, EFL_OFFSET) & ~TRAP_FLAG;
 	put_stack_long(child, EFL_OFFSET, tmp);
 }
@@ -324,6 +325,7 @@ asmlinkage long sys_ptrace(long request,
 			child->ptrace |= PT_TRACESYS;
 		else
 			child->ptrace &= ~PT_TRACESYS;
+		child->ptrace &= ~PT_SINGLESTEP;
 		child->exit_code = data;
 	/* make sure the single step bit is not set. */
 		tmp = get_stack_long(child, EFL_OFFSET);
@@ -375,6 +377,7 @@ asmlinkage long sys_ptrace(long request,
 			break;
 		child->exit_code = SIGKILL;
 		/* make sure the single step bit is not set. */
+		child->ptrace &= ~PT_SINGLESTEP;
 		tmp = get_stack_long(child, EFL_OFFSET) & ~TRAP_FLAG;
 		put_stack_long(child, EFL_OFFSET, tmp);
 		wake_up_process(child);
@@ -388,6 +391,7 @@ asmlinkage long sys_ptrace(long request,
 		if ((unsigned long) data > _NSIG)
 			break;
 		child->ptrace &= ~PT_TRACESYS;
+		child->ptrace |= PT_SINGLESTEP;
 		if ((child->ptrace & PT_DTRACE) == 0) {
 			/* Spurious delayed TF traps may occur */
 			child->ptrace |= PT_DTRACE;
@@ -499,8 +503,9 @@ asmlinkage void syscall_trace_enter(stru
 
 asmlinkage void syscall_trace_leave(struct pt_regs *regs)
 {
-       if ((current->ptrace & (PT_PTRACED|PT_TRACESYS)) == (PT_PTRACED|PT_TRACESYS))
-               syscall_ptrace(regs);
+	int ptrace = current->ptrace;
+	if ((ptrace & PT_PTRACED) && (ptrace & (PT_TRACESYS|PT_SINGLESTEP)))
+		syscall_ptrace(regs);
 
        if (isaudit(current) && (current->ptrace & PT_AUDITED))
                audit_result(regs);
diff -urNp linux-8260/arch/x86_64/kernel/signal.c linux-8270/arch/x86_64/kernel/signal.c
--- linux-8260/arch/x86_64/kernel/signal.c
+++ linux-8270/arch/x86_64/kernel/signal.c
@@ -135,6 +135,7 @@ static int
 restore_sigcontext(struct pt_regs *regs, struct sigcontext *sc, unsigned long *prax)
 {
 	unsigned int err = 0;
+	unsigned int caller_eflags;
 
 
 #define COPY(x)		err |= __get_user(regs->x, &sc->x)
@@ -162,6 +163,7 @@ restore_sigcontext(struct pt_regs *regs,
 	{
 		unsigned int tmpflags;
 		err |= __get_user(tmpflags, &sc->eflags);
+		caller_eflags = regs->eflags;
 		regs->eflags = (regs->eflags & ~0x40DD5) | (tmpflags & 0x40DD5);
 		regs->orig_rax = -1;		/* disable syscall checks */
 	}
@@ -177,6 +179,22 @@ restore_sigcontext(struct pt_regs *regs,
 	}
 
 	err |= __get_user(*prax, &sc->rax);
+
+	if (!err && unlikely(caller_eflags & X86_EFLAGS_TF) &&
+	    (current->ptrace & (PT_PTRACED|PT_DTRACE)) == (PT_PTRACED|PT_DTRACE)) {
+		/*
+		 * If ptrace single-stepped into the sigreturn system call,
+		 * then fake a single-step trap before we resume the restored
+		 * context.
+		 */
+		siginfo_t info;
+		info.si_signo = SIGTRAP;
+		info.si_errno = 0;
+		info.si_code = TRAP_BRKPT;
+		info.si_addr = (void *)regs->rip;
+		force_sig_info(SIGTRAP, &info, current);
+	}
+
 	return err;
 }
 #undef COPY
@@ -228,6 +246,7 @@ setup_sigcontext(struct sigcontext *sc, 
 {
 	int tmp, err = 0;
 	struct task_struct *me = current;
+	unsigned long eflags;
 
 	tmp = 0;
 	err |= __put_user(0, &sc->gs);
@@ -253,7 +272,11 @@ setup_sigcontext(struct sigcontext *sc, 
 	err |= __put_user(me->thread.error_code, &sc->err);
 	err |= __put_user(regs->rip, &sc->rip);
 	err |= __put_user(regs->cs, &sc->cs);
-	err |= __put_user(regs->eflags, &sc->eflags);
+	eflags = regs->eflags;
+	if (current->ptrace & PT_PTRACED) {
+		eflags &= ~TF_MASK;
+	}
+	err |= __put_user(eflags, &sc->eflags);
 	err |= __put_user(mask, &sc->oldmask);
 	err |= __put_user(me->thread.cr2, &sc->cr2);
 
@@ -365,7 +388,13 @@ static void setup_rt_frame(int sig, stru
 	regs->ss = __USER_DS; 
 
 	set_fs(USER_DS);
-	regs->eflags &= ~TF_MASK;
+	if (regs->eflags & TF_MASK) {
+		if (current->ptrace & PT_PTRACED) {
+			ptrace_notify(SIGTRAP);
+		} else {
+			regs->eflags &= ~TF_MASK;
+		}
+	}
 
 #if DEBUG_SIG
 	printk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",
diff -urNp linux-8260/arch/x86_64/tools/offset.c linux-8270/arch/x86_64/tools/offset.c
--- linux-8260/arch/x86_64/tools/offset.c
+++ linux-8270/arch/x86_64/tools/offset.c
@@ -54,6 +54,7 @@ int main(void) 
 	output("#ifdef __ASSEMBLY__"); 
 	outconst("#define PT_TRACESYS %0", PT_TRACESYS);
 	outconst("#define PT_AUDITED %0", PT_AUDITED);
+	outconst("#define PT_SINGLESTEP %0", PT_SINGLESTEP);
 	outconst("#define TASK_SIZE %0", TASK_SIZE); 
 	outconst("#define SIGCHLD %0", SIGCHLD);
 	outconst("#define CLONE_VFORK %0", CLONE_VFORK); 
diff -urNp linux-8260/include/linux/mm.h linux-8270/include/linux/mm.h
--- linux-8260/include/linux/mm.h
+++ linux-8270/include/linux/mm.h
@@ -917,6 +917,10 @@ static inline unsigned int page_pin_hash
 #define page_mapping_pinned(p) \
 	(atomic_read(page_pin_counter(p)) != 0)
 
+#ifdef CONFIG_IA64
+int in_gate_area(struct task_struct *task, unsigned long addr);
+struct vm_area_struct *get_gate_vma(struct task_struct *tsk);
+#endif /*CONFIG_IA64*/
 #endif /* __KERNEL__ */
 
 #endif
diff -urNp linux-8260/include/linux/sched.h linux-8270/include/linux/sched.h
--- linux-8260/include/linux/sched.h
+++ linux-8270/include/linux/sched.h
@@ -624,6 +624,7 @@ struct task_struct {
 #define PT_TRACE_EXIT   0x00000200
 #define PT_DTRACE	0x00000400      /* delayed trace (used on m68k, i386) */
 #define PT_AUDITED	0x00000800      /* being audited */
+#define PT_SINGLESTEP	0x00001000	/* PTRACE_SINGLESTEP in progress */
 
 #define is_dumpable(tsk)    ((tsk)->task_dumpable && (tsk)->mm && (tsk)->mm->dumpable)
 
diff -urNp linux-8260/mm/memory.c linux-8270/mm/memory.c
--- linux-8260/mm/memory.c
+++ linux-8270/mm/memory.c
@@ -886,6 +886,35 @@ int __get_user_pages(struct task_struct 
 
 		vma = find_extend_vma(mm, start);
 
+#ifdef CONFIG_IA64
+		if (!vma && in_gate_area(tsk, start)) {
+			unsigned long pg = start & PAGE_MASK;
+			struct vm_area_struct *gate_vma = get_gate_vma(tsk);
+			pgd_t *pgd;
+			pmd_t *pmd;
+			pte_t *pte;
+			if (write) /* user gate pages are read-only */
+				return i ? : -EFAULT;
+			pgd = pgd_offset_k(pg);
+			BUG_ON(pgd_none(*pgd));
+			pmd = pmd_offset(pgd, pg);
+			BUG_ON(pmd_none(*pmd));
+			pte = pte_offset_map(pmd, pg);
+			BUG_ON(pte_none(*pte));
+			if (pages) {
+				pages[i] = pte_page(*pte);
+				get_page(pages[i]);
+			}
+			pte_unmap(pte);
+			if (vmas)
+				vmas[i] = gate_vma;
+			i++;
+			start += PAGE_SIZE;
+			len--;
+			continue;
+		}
+#endif
+
 		if ( !vma || (pages && vma->vm_flags & VM_IO) || !(flags & vma->vm_flags) )
 			return i ? : -EFAULT;
 		if (is_vm_hugetlb_page(vma)) {
@@ -2392,3 +2421,31 @@ int map_user_kiobuf_iovecs(int rw, struc
 	dprintk ("map_user_kiobuf_iovecs: end OK\n");
 	return 0;
 }
+
+#ifdef CONFIG_IA64
+
+struct vm_area_struct gate_vma;
+
+static int __init gate_vma_init(void) {
+	printk("Call gate_vma_init\n");
+	gate_vma.vm_mm = NULL;
+	gate_vma.vm_start = GATE_ADDR;
+	gate_vma.vm_end = PERCPU_ADDR;
+	gate_vma.vm_page_prot = PAGE_READONLY;
+	gate_vma.vm_flags = 0;
+	return 0;
+}
+
+struct vm_area_struct *get_gate_vma(struct task_struct *tsk) {
+	return &gate_vma;
+}
+
+int in_gate_area(struct task_struct *task, unsigned long addr) {
+	if ((addr >= GATE_ADDR) && (addr < PERCPU_ADDR))
+		return 1;
+	return 0;
+}
+
+__initcall(gate_vma_init);
+#endif
+
