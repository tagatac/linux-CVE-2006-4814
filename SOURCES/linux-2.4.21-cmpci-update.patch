diff -urNp linux-5431/drivers/sound/Config.in linux-5440/drivers/sound/Config.in
--- linux-5431/drivers/sound/Config.in
+++ linux-5440/drivers/sound/Config.in
@@ -19,7 +19,7 @@ if [ "$CONFIG_SOUND_CMPCI" = "y" -o "$CO
     if [ "$CONFIG_SOUND_CMPCI_MIDI" = "y" ]; then
         hex '    MPU-401 I/O 330, 320, 310, 300' CONFIG_SOUND_CMPCI_MPUIO 330
     fi
-    bool '    Enable joystick' CONFIG_SOUND_CMPCI_JOYSTICK
+    dep_mbool '    Enable joystick' CONFIG_SOUND_CMPCI_JOYSTICK $CONFIG_INPUT_GAMEPORT
     bool '    Support CMI8738 based audio cards' CONFIG_SOUND_CMPCI_CM8738
     if [ "$CONFIG_SOUND_CMPCI_CM8738" = "y" ]; then
 	bool '      Inverse S/PDIF in for CMI8738' CONFIG_SOUND_CMPCI_SPDIFINVERSE
diff -urNp linux-5431/drivers/sound/cmpci.c linux-5440/drivers/sound/cmpci.c
--- linux-5431/drivers/sound/cmpci.c
+++ linux-5440/drivers/sound/cmpci.c
@@ -1,4 +1,3 @@
-/*****************************************************************************/
 /*
  *      cmpci.c  --  C-Media PCI audio driver.
  *
@@ -8,7 +7,6 @@
  *      Based on the PCI drivers by Thomas Sailer (sailer@ife.ee.ethz.ch)
  *
  * 	For update, visit:
- * 		http://members.home.net/puresoft/cmedia.html
  * 		http://www.cmedia.com.tw
  * 	
  *      This program is free software; you can redistribute it and/or modify
@@ -82,8 +80,8 @@
  *	- speaker mixer support 
  *	Mon Aug 13 2001
  *	- optimizations and cleanups
- *    03/01/2003 - open_mode fixes from Georg Acher <acher@in.tum.de>
  *
+ *    03/01/2003 - open_mode fixes from Georg Acher <acher@in.tum.de>
  */
 /*****************************************************************************/
       
@@ -98,15 +96,16 @@
 #include <linux/slab.h>
 #include <linux/soundcard.h>
 #include <linux/pci.h>
-#include <linux/wrapper.h>
 #include <asm/io.h>
 #include <asm/dma.h>
 #include <linux/init.h>
 #include <linux/poll.h>
 #include <linux/spinlock.h>
 #include <linux/smp_lock.h>
+#include <linux/wrapper.h>
 #include <asm/uaccess.h>
 #include <asm/hardirq.h>
+#include <linux/gameport.h>
 #include <linux/bitops.h>
 
 #include "dm.h"
@@ -178,26 +177,143 @@
 #define DSP_MIX_TREBLEIDX_R		((unsigned char)(0x45))
 #define DSP_MIX_BASSIDX_L		((unsigned char)(0x46))
 #define DSP_MIX_BASSIDX_R		((unsigned char)(0x47))
+#define DSP_MIX_EXTENSION		((unsigned char)(0xf0))
+// pseudo register for AUX
+#define	DSP_MIX_AUXVOL_L		((unsigned char)(0x50))
+#define	DSP_MIX_AUXVOL_R		((unsigned char)(0x51))
+
+// I/O length
+#define CM_EXTENT_CODEC	  0x100
+#define CM_EXTENT_MIDI	  0x2
+#define CM_EXTENT_SYNTH	  0x4
+#define CM_EXTENT_GAME	  0x8
+
+// Function Control Register 0 (00h)
+#define CHADC0    	0x01
+#define CHADC1    	0x02
+#define PAUSE0	  	0x04
+#define PAUSE1	  	0x08
+ 
+// Function Control Register 0+2 (02h)
+#define CHEN0     	0x01
+#define CHEN1     	0x02
+#define RST_CH0	  	0x04
+#define RST_CH1	  	0x08
+ 
+// Function Control Register 1 (04h)
+#define JYSTK_EN	0x02
+#define UART_EN		0x04
+#define	SPDO2DAC	0x40
+#define	SPDFLOOP	0x80
+ 
+// Function Control Register 1+1 (05h)
+#define	SPDF_0		0x01
+#define	SPDF_1		0x02
+#define	ASFC		0xe0
+#define	DSFC		0x1c
+#define	SPDIF2DAC	(SPDF_0 << 8 | SPDO2DAC)
+
+// Channel Format Register (08h)
+#define CM_CFMT_STEREO	0x01
+#define CM_CFMT_16BIT	0x02
+#define CM_CFMT_MASK	0x03
+#define	POLVALID	0x20
+#define	INVSPDIFI	0x80
+
+// Channel Format Register+2 (0ah)
+#define SPD24SEL	0x20
+
+// Channel Format Register+3 (0bh)
+#define CHB3D		0x20
+#define CHB3D5C		0x80
+
+// Interrupt Hold/Clear Register+2 (0eh)
+#define	CH0_INT_EN	0x01
+#define	CH1_INT_EN	0x02
+
+// Interrupt Register (10h)
+#define CHINT0		0x01
+#define CHINT1		0x02
+#define	CH0BUSY		0x04
+#define	CH1BUSY		0x08
+
+// Legacy Control/Status Register+1 (15h)
+#define	EXBASEN		0x10
+#define	BASE2LIN	0x20
+#define	CENTR2LIN	0x40
+#define	CB2LIN		(BASE2LIN|CENTR2LIN)
+#define	CHB3D6C		0x80
+
+// Legacy Control/Status Register+2 (16h)
+#define	DAC2SPDO	0x20
+#define	SPDCOPYRHT	0x40
+#define	ENSPDOUT	0x80
+
+// Legacy Control/Status Register+3 (17h)
+#define	FMSEL		0x03
+#define	VSBSEL		0x0c
+#define	VMPU		0x60
+#define	NXCHG		0x80
+ 
+// Miscellaneous Control Register (18h)
+#define	REAR2LIN	0x20
+#define	MUTECH1		0x40
+#define	ENCENTER	0x80
+ 
+// Miscellaneous Control Register+1 (19h)
+#define	SELSPDIFI2	0x01
+#define	SPDF_AC97	0x80
+ 
+// Miscellaneous Control Register+2 (1ah)
+#define	AC3_EN		0x04
+#define	FM_EN		0x08
+#define	SPD32SEL	0x20
+#define	XCHGDAC		0x40
+#define	ENDBDAC		0x80
+ 
+// Miscellaneous Control Register+3 (1bh)
+#define	SPDIFI48K	0x01
+#define	SPDO5V		0x02
+#define	N4SPK3D		0x04
+#define	RESET		0x40
+#define	PWD		0x80
+#define	SPDIF48K	(SPDIFI48K << 24 | SPDF_AC97 << 8)
+ 
+// Mixer1 (24h)
+#define	CDPLAY		0x01
+#define	X3DEN		0x02
+#define	REAR2FRONT	0x10
+#define	SPK4		0x20
+#define	WSMUTE		0x40
+ 
+// Miscellaneous Register (27h)
+#define	SPDVALID	0x02
+#define	CENTR2MIC	0x04
+
+#define CM_CFMT_DACSHIFT   0
+#define CM_CFMT_ADCSHIFT   2
+#define CM_FREQ_DACSHIFT   2
+#define CM_FREQ_ADCSHIFT   5
+#define	RSTDAC		RST_CH0
+#define	RSTADC		RST_CH1
+#define	ENDAC		CHEN0
+#define	ENADC		CHEN1
+#define	PAUSEDAC	PAUSE0
+#define	PAUSEADC	PAUSE1
+#define CODEC_CMI_DAC_FRAME1	CODEC_CMI_CH0_FRAME1
+#define CODEC_CMI_DAC_FRAME2	CODEC_CMI_CH0_FRAME2
+#define CODEC_CMI_ADC_FRAME1	CODEC_CMI_CH1_FRAME1
+#define CODEC_CMI_ADC_FRAME2	CODEC_CMI_CH1_FRAME2
+#define	DACINT		CHINT0
+#define	ADCINT		CHINT1
+#define	DACBUSY		CH0BUSY
+#define	ADCBUSY		CH1BUSY
+#define	ENDACINT	CH0_INT_EN
+#define	ENADCINT	CH1_INT_EN
 
-#define CM_CH0_RESET			0x04
-#define CM_CH1_RESET			0x08
-#define CM_EXTENT_CODEC			0x100
-#define CM_EXTENT_MIDI			0x2
-#define CM_EXTENT_SYNTH			0x4
-#define CM_INT_CH0			1
-#define CM_INT_CH1			2
-
-#define CM_CFMT_STEREO			0x01
-#define CM_CFMT_16BIT			0x02
-#define CM_CFMT_MASK			0x03
-#define CM_CFMT_DACSHIFT		2
-#define CM_CFMT_ADCSHIFT		0
-
+static const unsigned sample_size[] = { 1, 2, 2, 4 };
 static const unsigned sample_shift[]	= { 0, 1, 1, 2 };
 
-#define CM_ENABLE_CH1      0x2
-#define CM_ENABLE_CH0      0x1
-
 /* MIDI buffer sizes **************************/
 
 #define MIDIINBUF  256
@@ -213,11 +329,19 @@ static const unsigned sample_shift[]	= {
 
 #define NR_DEVICE 3		/* maximum number of devices */
 
-/*********************************************/
+static unsigned int devindex = 0;
+
+//*********************************************/
 
 struct cm_state {
-	unsigned int magic;		/* magic */
-	struct cm_state *next;		/* we keep cm cards in a linked list */
+	/* magic */
+	unsigned int magic;
+
+	/* list of cmedia devices */
+	struct list_head devs;
+
+	/* the corresponding pci_dev structure */
+	struct pci_dev *dev;
 
 	int dev_audio;			/* soundcore stuff */
 	int dev_mixer;
@@ -243,7 +367,7 @@ struct cm_state {
 
 	struct dmabuf {
 		void *rawbuf;
-		unsigned rawphys;
+		dma_addr_t dmaaddr;
 		unsigned buforder;
 		unsigned numfrag;
 		unsigned fragshift;
@@ -261,6 +385,7 @@ struct cm_state {
 		unsigned mapped:1;	/* OSS stuff */
 		unsigned ready:1;
 		unsigned endcleared:1;
+		unsigned enabled:1;
 		unsigned ossfragshift;
 		int ossmaxfrags;
 		unsigned subdivision;
@@ -275,7 +400,9 @@ struct cm_state {
 		unsigned char ibuf[MIDIINBUF];
 		unsigned char obuf[MIDIOUTBUF];
 	} midi;
-	
+
+	struct gameport gameport;
+
 	int	chip_version;		
 	int	max_channels;
 	int	curr_channels;		
@@ -312,8 +439,7 @@ struct cm_state {
 #define	DO_SPDIF_IN		0x00000200
 #define	DO_SPDIF_LOOP		0x00000400
 
-static struct cm_state *devs;
-static unsigned long wavetable_mem;
+static LIST_HEAD(devs);
 
 /* --------------------------------------------------------------------- */
 
@@ -356,55 +482,55 @@ static void maskl(unsigned int addr, uns
 static void set_dmadac1(struct cm_state *s, unsigned int addr, unsigned int count)
 {
 	if (addr)
-	    outl(addr, s->iobase + CODEC_CMI_CH0_FRAME1);
-	outw(count - 1, s->iobase + CODEC_CMI_CH0_FRAME2);
-	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~1, 0);
+	    outl(addr, s->iobase + CODEC_CMI_ADC_FRAME1);
+	outw(count - 1, s->iobase + CODEC_CMI_ADC_FRAME2);
+	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~CHADC1, 0);
 }
 
 static void set_dmaadc(struct cm_state *s, unsigned int addr, unsigned int count)
 {
-	outl(addr, s->iobase + CODEC_CMI_CH0_FRAME1);
-	outw(count - 1, s->iobase + CODEC_CMI_CH0_FRAME2);
-	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~0, 1);
+	outl(addr, s->iobase + CODEC_CMI_ADC_FRAME1);
+	outw(count - 1, s->iobase + CODEC_CMI_ADC_FRAME2);
+	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~0, CHADC1);
 }
 
 static void set_dmadac(struct cm_state *s, unsigned int addr, unsigned int count)
 {
-	outl(addr, s->iobase + CODEC_CMI_CH1_FRAME1);
-	outw(count - 1, s->iobase + CODEC_CMI_CH1_FRAME2);
-	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~2, 0);
+	outl(addr, s->iobase + CODEC_CMI_DAC_FRAME1);
+	outw(count - 1, s->iobase + CODEC_CMI_DAC_FRAME2);
+	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~CHADC0, 0);
 	if (s->status & DO_DUAL_DAC)
 		set_dmadac1(s, 0, count);
 }
 
 static void set_countadc(struct cm_state *s, unsigned count)
 {
-	outw(count - 1, s->iobase + CODEC_CMI_CH0_FRAME2 + 2);
+	outw(count - 1, s->iobase + CODEC_CMI_ADC_FRAME2 + 2);
 }
 
 static void set_countdac(struct cm_state *s, unsigned count)
 {
-	outw(count - 1, s->iobase + CODEC_CMI_CH1_FRAME2 + 2);
+	outw(count - 1, s->iobase + CODEC_CMI_DAC_FRAME2 + 2);
 	if (s->status & DO_DUAL_DAC)
 	    set_countadc(s, count);
 }
 
-static inline unsigned get_dmadac(struct cm_state *s)
+static unsigned get_dmadac(struct cm_state *s)
 {
 	unsigned int curr_addr;
 
-	curr_addr = inw(s->iobase + CODEC_CMI_CH1_FRAME2) + 1;
+	curr_addr = inw(s->iobase + CODEC_CMI_DAC_FRAME2) + 1;
 	curr_addr <<= sample_shift[(s->fmt >> CM_CFMT_DACSHIFT) & CM_CFMT_MASK];
 	curr_addr = s->dma_dac.dmasize - curr_addr;
 
 	return curr_addr;
 }
 
-static inline unsigned get_dmaadc(struct cm_state *s)
+static unsigned get_dmaadc(struct cm_state *s)
 {
 	unsigned int curr_addr;
 
-	curr_addr = inw(s->iobase + CODEC_CMI_CH0_FRAME2) + 1;
+	curr_addr = inw(s->iobase + CODEC_CMI_ADC_FRAME2) + 1;
 	curr_addr <<= sample_shift[(s->fmt >> CM_CFMT_ADCSHIFT) & CM_CFMT_MASK];
 	curr_addr = s->dma_adc.dmasize - curr_addr;
 
@@ -413,23 +539,79 @@ static inline unsigned get_dmaadc(struct
 
 static void wrmixer(struct cm_state *s, unsigned char idx, unsigned char data)
 {
+	unsigned char regval, pseudo;
+
+	// pseudo register
+	if (idx == DSP_MIX_AUXVOL_L) {
+		data >>= 4;
+		data &= 0x0f;
+		regval = inb(s->iobase + CODEC_CMI_AUX_VOL) & ~0x0f;
+		outb(regval | data, s->iobase + CODEC_CMI_AUX_VOL);
+		return;
+	}
+	if (idx == DSP_MIX_AUXVOL_R) {
+		data &= 0xf0;
+		regval = inb(s->iobase + CODEC_CMI_AUX_VOL) & ~0xf0;
+		outb(regval | data, s->iobase + CODEC_CMI_AUX_VOL);
+		return;
+	}
 	outb(idx, s->iobase + CODEC_SB16_ADDR);
 	udelay(10);
+	// pseudo bits
+	if (idx == DSP_MIX_OUTMIXIDX) {
+		pseudo = data & ~0x1f;
+		pseudo >>= 1;	
+		regval = inb(s->iobase + CODEC_CMI_MIXER2) & ~0x30;
+		outb(regval | pseudo, s->iobase + CODEC_CMI_MIXER2);
+	}
+	if (idx == DSP_MIX_ADCMIXIDX_L) {
+		pseudo = data & 0x80;
+		pseudo >>= 1;
+		regval = inb(s->iobase + CODEC_CMI_MIXER2) & ~0x40;
+		outb(regval | pseudo, s->iobase + CODEC_CMI_MIXER2);
+	}
+	if (idx == DSP_MIX_ADCMIXIDX_R) {
+		pseudo = data & 0x80;
+		regval = inb(s->iobase + CODEC_CMI_MIXER2) & ~0x80;
+		outb(regval | pseudo, s->iobase + CODEC_CMI_MIXER2);
+	}
 	outb(data, s->iobase + CODEC_SB16_DATA);
 	udelay(10);
 }
 
 static unsigned char rdmixer(struct cm_state *s, unsigned char idx)
 {
-	unsigned char v;
-	unsigned long flags;
+	unsigned char v, pseudo;
 	
-	spin_lock_irqsave(&s->lock, flags);
+	// pseudo register
+	if (idx == DSP_MIX_AUXVOL_L) {
+		v = inb(s->iobase + CODEC_CMI_AUX_VOL) & 0x0f;
+		v <<= 4;
+		return v;
+	}
+	if (idx == DSP_MIX_AUXVOL_L) {
+		v = inb(s->iobase + CODEC_CMI_AUX_VOL) & 0xf0;
+		return v;
+	}
 	outb(idx, s->iobase + CODEC_SB16_ADDR);
 	udelay(10);
 	v = inb(s->iobase + CODEC_SB16_DATA);
 	udelay(10);
-	spin_unlock_irqrestore(&s->lock, flags);
+	// pseudo bits
+	if (idx == DSP_MIX_OUTMIXIDX) {
+		pseudo = inb(s->iobase + CODEC_CMI_MIXER2) & 0x30;
+		pseudo <<= 1;
+		v |= pseudo;
+	}
+	if (idx == DSP_MIX_ADCMIXIDX_L) {
+		pseudo = inb(s->iobase + CODEC_CMI_MIXER2) & 0x40;
+		pseudo <<= 1;
+		v |= pseudo;
+	}
+	if (idx == DSP_MIX_ADCMIXIDX_R) {
+		pseudo = inb(s->iobase + CODEC_CMI_MIXER2) & 0x80;
+		v |= pseudo;
+	}
 	return v;
 }
 
@@ -479,24 +661,88 @@ static struct {
 	{ 48000,	(44100 + 48000) / 2,	48000,			7 }
 };
 
+static void set_spdif_copyright(struct cm_state *s, int spdif_copyright)
+{
+	/* enable SPDIF-in Copyright */
+	maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 2, ~SPDCOPYRHT, spdif_copyright ? SPDCOPYRHT : 0);
+}
+
+static void set_spdif_loop(struct cm_state *s, int spdif_loop)
+{
+	/* enable SPDIF loop */
+	if (spdif_loop) {
+		s->status |= DO_SPDIF_LOOP;
+		/* turn on spdif-in to spdif-out */
+		maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~0, SPDFLOOP);
+	} else {
+		s->status &= ~DO_SPDIF_LOOP;
+		/* turn off spdif-in to spdif-out */
+		maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~SPDFLOOP, 0);
+	}
+}
+
+static void set_spdif_monitor(struct cm_state *s, int channel)
+{
+	// SPDO2DAC
+	maskw(s->iobase + CODEC_CMI_FUNCTRL1, ~SPDO2DAC, channel == 2 ? SPDO2DAC : 0);
+	// CDPLAY
+	if (s->chip_version >= 39)
+		maskb(s->iobase + CODEC_CMI_MIXER1, ~CDPLAY, channel ? CDPLAY : 0);
+}
+
+static void set_spdifout_level(struct cm_state *s, int level5v)
+{
+	/* SPDO5V */
+	maskb(s->iobase + CODEC_CMI_MISC_CTRL + 3, ~SPDO5V, level5v ? SPDO5V : 0);
+}
+
+static void set_spdifin_inverse(struct cm_state *s, int spdif_inverse)
+{
+	if (spdif_inverse) {
+		/* turn on spdif-in inverse */
+		if (s->chip_version >= 39)
+			maskb(s->iobase + CODEC_CMI_CHFORMAT, ~0, INVSPDIFI);
+		else
+			maskb(s->iobase + CODEC_CMI_CHFORMAT + 2, ~0, 1);
+	} else {
+		/* turn off spdif-ininverse */
+		if (s->chip_version >= 39) 
+			maskb(s->iobase + CODEC_CMI_CHFORMAT, ~INVSPDIFI, 0);
+		else
+			maskb(s->iobase + CODEC_CMI_CHFORMAT + 2, ~1, 0);
+	}
+}
+
+static void set_spdifin_channel2(struct cm_state *s, int channel2)
+{
+	/* SELSPDIFI2 */
+	if (s->chip_version >= 39)
+		maskb(s->iobase + CODEC_CMI_MISC_CTRL + 1, ~SELSPDIFI2, channel2 ? SELSPDIFI2 : 0);
+}
+
+static void set_spdifin_valid(struct cm_state *s, int valid)
+{
+	/* SPDVALID */
+	maskb(s->iobase + CODEC_CMI_MISC, ~SPDVALID, valid ? SPDVALID : 0);
+}
+
 static void set_spdifout_unlocked(struct cm_state *s, unsigned rate)
 {
 	if (rate == 48000 || rate == 44100) {
+		// SPDF_0
+		maskw(s->iobase + CODEC_CMI_FUNCTRL1, ~0, SPDF_0);
 		// SPDIFI48K SPDF_ACc97
-		maskl(s->iobase + CODEC_CMI_MISC_CTRL, ~0x01008000, rate == 48000 ? 0x01008000 : 0);
+		maskl(s->iobase + CODEC_CMI_MISC_CTRL, ~SPDIF48K, rate == 48000 ? SPDIF48K : 0);
 		// ENSPDOUT
-		maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 2, ~0, 0x80);
-		// SPDF_1 SPD2DAC
-		maskw(s->iobase + CODEC_CMI_FUNCTRL1, ~0, 0x240);
-		// CDPLAY
-		if (s->chip_version >= 39)
-			maskb(s->iobase + CODEC_CMI_MIXER1, ~0, 1);
+		maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 2, ~0, ENSPDOUT);
+		// monitor SPDIF out
+		set_spdif_monitor(s, 2);
 		s->status |= DO_SPDIF_OUT;
 	} else {
-		maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 2, ~0x80, 0);
-		maskw(s->iobase + CODEC_CMI_FUNCTRL1, ~0x240, 0);
-		if (s->chip_version >= 39)
-			maskb(s->iobase + CODEC_CMI_MIXER1, ~1, 0);
+		maskw(s->iobase + CODEC_CMI_FUNCTRL1, ~SPDF_0, 0);
+		maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 2, ~ENSPDOUT, 0);
+		// monitor none
+		set_spdif_monitor(s, 0);
 		s->status &= ~DO_SPDIF_OUT;
 	}
 }
@@ -510,7 +756,30 @@ static void set_spdifout(struct cm_state
 	spin_unlock_irqrestore(&s->lock, flags);
 }
 
-/* find parity for bit 4~30 */
+static void set_spdifin_unlocked(struct cm_state *s, unsigned rate)
+{
+	if (rate == 48000 || rate == 44100) {
+		// SPDF_1
+		maskw(s->iobase + CODEC_CMI_FUNCTRL1, ~0, SPDF_1);
+		// SPDIFI48K SPDF_AC97
+		maskl(s->iobase + CODEC_CMI_MISC_CTRL, ~SPDIF48K, rate == 48000 ? SPDIF48K : 0);
+		s->status |= DO_SPDIF_IN;
+	} else {
+		maskw(s->iobase + CODEC_CMI_FUNCTRL1, ~SPDF_1, 0);
+		s->status &= ~DO_SPDIF_IN;
+	}
+}
+
+static void set_spdifin(struct cm_state *s, unsigned rate)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&s->lock, flags);
+	set_spdifin_unlocked(s,rate);
+	spin_unlock_irqrestore(&s->lock, flags);
+}
+
+//* find parity for bit 4~30 */
 static unsigned parity(unsigned data)
 {
 	unsigned parity = 0;
@@ -531,21 +800,26 @@ static void set_ac3_unlocked(struct cm_s
 	/* enable AC3 */
 	if (rate == 48000 || rate == 44100) {
 		// mute DAC
-		maskb(s->iobase + CODEC_CMI_MIXER1, ~0, 0x40);
-		// AC3EN for 037, 0x10
-		maskb(s->iobase + CODEC_CMI_CHFORMAT + 2, ~0, 0x10);
+		maskb(s->iobase + CODEC_CMI_MIXER1, ~0, WSMUTE);
 		// AC3EN for 039, 0x04
-		maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~0, 0x04);
+		if (s->chip_version >= 39)
+			maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~0, AC3_EN);
+		// AC3EN for 037, 0x10
+		else if (s->chip_version == 37)
+			maskb(s->iobase + CODEC_CMI_CHFORMAT + 2, ~0, 0x10);
 		if (s->capability & CAN_AC3_HW) {
-			// SPD24SEL for 037, 0x02
 			// SPD24SEL for 039, 0x20, but cannot be set
-			maskb(s->iobase + CODEC_CMI_CHFORMAT + 2, ~0, 0x02);
+			if (s->chip_version >= 39)
+				maskb(s->iobase + CODEC_CMI_CHFORMAT + 2, ~0, SPD24SEL);
+			// SPD24SEL for 037, 0x02
+			else if (s->chip_version == 37)
+				maskb(s->iobase + CODEC_CMI_CHFORMAT + 2, ~0, 0x02);
 			s->status |= DO_AC3_HW;
 			if (s->chip_version >= 39)
-				maskb(s->iobase + CODEC_CMI_MIXER1, ~1, 0);
+				maskb(s->iobase + CODEC_CMI_MIXER1, ~CDPLAY, 0);
 		 } else {
 			// SPD32SEL for 037 & 039, 0x20
-			maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~0, 0x20);
+			maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~0, SPD32SEL);
 			// set 176K sample rate to fix 033 HW bug
 			if (s->chip_version == 33) {
 				if (rate == 48000)
@@ -556,18 +830,16 @@ static void set_ac3_unlocked(struct cm_s
 			s->status |= DO_AC3_SW;
 		}
 	} else {
-		maskb(s->iobase + CODEC_CMI_MIXER1, ~0x40, 0);
+		maskb(s->iobase + CODEC_CMI_MIXER1, ~WSMUTE, 0);
 		maskb(s->iobase + CODEC_CMI_CHFORMAT + 2, ~0x32, 0);
-		maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~0x24, 0);
-		maskb(s->iobase + CODEC_CMI_CHFORMAT + 1, ~0x08, 0);
+		maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~(SPD32SEL|AC3_EN), 0);
 		if (s->chip_version == 33)
 			maskb(s->iobase + CODEC_CMI_CHFORMAT + 1, ~0x08, 0);
 		if (s->chip_version >= 39)
-			maskb(s->iobase + CODEC_CMI_MIXER1, ~0, 1);
+			maskb(s->iobase + CODEC_CMI_MIXER1, ~0, CDPLAY);
 		s->status &= ~DO_AC3;
 	}
 	s->spdif_counter = 0;
-
 }
 
 static void set_ac3(struct cm_state *s, unsigned rate)
@@ -629,9 +901,9 @@ static void set_adc_rate_unlocked(struct
 	    	}
 	}
 	s->rateadc = rate;
-	freq <<= 2;
+	freq <<= CM_FREQ_ADCSHIFT;
 
-	maskb(s->iobase + CODEC_CMI_FUNCTRL1 + 1, ~0x1c, freq);
+	maskb(s->iobase + CODEC_CMI_FUNCTRL1 + 1, ~ASFC, freq);
 }
 
 static void set_adc_rate(struct cm_state *s, unsigned rate)
@@ -652,10 +924,10 @@ static void set_adc_rate(struct cm_state
 	    	}
 	}
 	s->rateadc = rate;
-	freq <<= 2;
+	freq <<= CM_FREQ_ADCSHIFT;
 
 	spin_lock_irqsave(&s->lock, flags);
-	maskb(s->iobase + CODEC_CMI_FUNCTRL1 + 1, ~0x1c, freq);
+	maskb(s->iobase + CODEC_CMI_FUNCTRL1 + 1, ~ASFC, freq);
 	spin_unlock_irqrestore(&s->lock, flags);
 }
 
@@ -677,46 +949,45 @@ static void set_dac_rate(struct cm_state
 	    	}
 	}
 	s->ratedac = rate;
-	freq <<= 5;
+	freq <<= CM_FREQ_DACSHIFT;
 
 	spin_lock_irqsave(&s->lock, flags);
-	maskb(s->iobase + CODEC_CMI_FUNCTRL1 + 1, ~0xe0, freq);
-
+	maskb(s->iobase + CODEC_CMI_FUNCTRL1 + 1, ~DSFC, freq);
+	spin_unlock_irqrestore(&s->lock, flags);
 
 	if (s->curr_channels <=  2)
-		set_spdifout_unlocked(s, rate);
+		set_spdifout(s, rate);
 	if (s->status & DO_DUAL_DAC)
-		set_adc_rate_unlocked(s, rate);
-
-	spin_unlock_irqrestore(&s->lock, flags);
+		set_adc_rate(s, rate);
 }
 
 /* --------------------------------------------------------------------- */
 static inline void reset_adc(struct cm_state *s)
 {
 	/* reset bus master */
-	outb(s->enable | CM_CH0_RESET, s->iobase + CODEC_CMI_FUNCTRL0 + 2);
+	outb(s->enable | RSTADC, s->iobase + CODEC_CMI_FUNCTRL0 + 2);
 	udelay(10);
-	outb(s->enable & ~CM_CH0_RESET, s->iobase + CODEC_CMI_FUNCTRL0 + 2);
+	outb(s->enable & ~RSTADC, s->iobase + CODEC_CMI_FUNCTRL0 + 2);
 }
 
 static inline void reset_dac(struct cm_state *s)
 {
 	/* reset bus master */
-	outb(s->enable | CM_CH1_RESET, s->iobase + CODEC_CMI_FUNCTRL0 + 2);
-	outb(s->enable & ~CM_CH1_RESET, s->iobase + CODEC_CMI_FUNCTRL0 + 2);
+	outb(s->enable | RSTDAC, s->iobase + CODEC_CMI_FUNCTRL0 + 2);
+	udelay(10);
+	outb(s->enable & ~RSTDAC, s->iobase + CODEC_CMI_FUNCTRL0 + 2);
 	if (s->status & DO_DUAL_DAC)
 		reset_adc(s);
 }
 
 static inline void pause_adc(struct cm_state *s)
 {
-	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~0, 4);
+	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~0, PAUSEADC);
 }
 
 static inline void pause_dac(struct cm_state *s)
 {
-	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~0, 8);
+	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~0, PAUSEDAC);
 	if (s->status & DO_DUAL_DAC)
 		pause_adc(s);
 }
@@ -724,7 +995,7 @@ static inline void pause_dac(struct cm_s
 static inline void disable_adc(struct cm_state *s)
 {
 	/* disable channel */
-	s->enable &= ~CM_ENABLE_CH0;
+	s->enable &= ~ENADC;
 	outb(s->enable, s->iobase + CODEC_CMI_FUNCTRL0 + 2);
 	reset_adc(s);
 }
@@ -732,7 +1003,7 @@ static inline void disable_adc(struct cm
 static inline void disable_dac(struct cm_state *s)
 {
 	/* disable channel */
-	s->enable &= ~CM_ENABLE_CH1;
+	s->enable &= ~ENDAC;
 	outb(s->enable, s->iobase + CODEC_CMI_FUNCTRL0 + 2);
 	reset_dac(s);
 	if (s->status & DO_DUAL_DAC)
@@ -741,22 +1012,22 @@ static inline void disable_dac(struct cm
 
 static inline void enable_adc(struct cm_state *s)
 {
-	if (!(s->enable & CM_ENABLE_CH0)) {
+	if (!(s->enable & ENADC)) {
 		/* enable channel */
-		s->enable |= CM_ENABLE_CH0;
+		s->enable |= ENADC;
 		outb(s->enable, s->iobase + CODEC_CMI_FUNCTRL0 + 2);
 	}
-	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~4, 0);
+	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~PAUSEADC, 0);
 }
 
 static inline void enable_dac_unlocked(struct cm_state *s)
 {
-	if (!(s->enable & CM_ENABLE_CH1)) {
+	if (!(s->enable & ENDAC)) {
 		/* enable channel */
-		s->enable |= CM_ENABLE_CH1;
+		s->enable |= ENDAC;
 		outb(s->enable, s->iobase + CODEC_CMI_FUNCTRL0 + 2);
 	}
-	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~8, 0);
+	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~PAUSEDAC, 0);
 
 	if (s->status & DO_DUAL_DAC)
 		enable_adc(s);
@@ -773,9 +1044,9 @@ static inline void enable_dac(struct cm_
 
 static inline void stop_adc_unlocked(struct cm_state *s)
 {
-	if (s->enable & CM_ENABLE_CH0) {
+	if (s->enable & ENADC) {
 		/* disable interrupt */
-		maskb(s->iobase + CODEC_CMI_INT_HLDCLR + 2, ~1, 0);
+		maskb(s->iobase + CODEC_CMI_INT_HLDCLR + 2, ~ENADCINT, 0);
 		disable_adc(s);
 	}
 }
@@ -792,9 +1063,9 @@ static inline void stop_adc(struct cm_st
 
 static inline void stop_dac_unlocked(struct cm_state *s)
 {
-	if (s->enable & CM_ENABLE_CH1) {
+	if (s->enable & ENDAC) {
 		/* disable interrupt */
-		maskb(s->iobase + CODEC_CMI_INT_HLDCLR + 2, ~2, 0);
+		maskb(s->iobase + CODEC_CMI_INT_HLDCLR + 2, ~ENDACINT, 0);
 		disable_dac(s);
 	}
 	if (s->status & DO_DUAL_DAC)
@@ -810,12 +1081,12 @@ static inline void stop_dac(struct cm_st
 	spin_unlock_irqrestore(&s->lock, flags);
 }
 
-static void start_adc_unlocked(struct cm_state *s)
+static inline void start_adc_unlocked(struct cm_state *s)
 {
 	if ((s->dma_adc.mapped || s->dma_adc.count < (signed)(s->dma_adc.dmasize - 2*s->dma_adc.fragsize))
 	    && s->dma_adc.ready) {
 		/* enable interrupt */
-		maskb(s->iobase + CODEC_CMI_INT_HLDCLR + 2, ~0, 1);
+		maskb(s->iobase + CODEC_CMI_INT_HLDCLR + 2, ~0, ENADCINT);
 		enable_adc(s);
 	}
 }
@@ -833,7 +1104,7 @@ static void start_dac1_unlocked(struct c
 {
 	if ((s->dma_adc.mapped || s->dma_adc.count > 0) && s->dma_adc.ready) {
 		/* enable interrupt */
-//		maskb(s->iobase + CODEC_CMI_INT_HLDCLR + 2, ~0, 1);
+		maskb(s->iobase + CODEC_CMI_INT_HLDCLR + 2, ~0, ENADCINT);
  		enable_dac_unlocked(s);
 	}
 }
@@ -842,11 +1113,11 @@ static void start_dac_unlocked(struct cm
 {
 	if ((s->dma_dac.mapped || s->dma_dac.count > 0) && s->dma_dac.ready) {
 		/* enable interrupt */
-		maskb(s->iobase + CODEC_CMI_INT_HLDCLR + 2, ~0, 2);
+		maskb(s->iobase + CODEC_CMI_INT_HLDCLR + 2, ~0, ENDACINT);
 		enable_dac_unlocked(s);
 	}
-		if (s->status & DO_DUAL_DAC)
-			start_dac1_unlocked(s);
+	if (s->status & DO_DUAL_DAC)
+		start_dac1_unlocked(s);
 }
 
 static void start_dac(struct cm_state *s)
@@ -870,13 +1141,13 @@ static int set_dac_channels(struct cm_st
 	    set_spdifout_unlocked(s, 0);
 	    if (s->capability & CAN_MULTI_CH_HW) {
 		// NXCHG
-		maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 3, ~0, 0x80);
+		maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 3, ~0, NXCHG);
 		// CHB3D or CHB3D5C
-	       	maskb(s->iobase + CODEC_CMI_CHFORMAT + 3, ~0xa0, channels > 4 ? 0x80 : 0x20);
+	       	maskb(s->iobase + CODEC_CMI_CHFORMAT + 3, ~(CHB3D5C|CHB3D), channels > 4 ? CHB3D5C : CHB3D);
 		// CHB3D6C
-		maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 1, ~0x80, channels == 6 ? 0x80 : 0);
+		maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 1, ~CHB3D6C, channels == 6 ? CHB3D6C : 0);
 		// ENCENTER 
-		maskb(s->iobase + CODEC_CMI_MISC_CTRL, ~0x80, channels == 6 ? 0x80 : 0);
+		maskb(s->iobase + CODEC_CMI_MISC_CTRL, ~ENCENTER, channels == 6 ? ENCENTER : 0);
 		s->status |= DO_MULTI_CH_HW;
 	    } else if (s->capability & CAN_DUAL_DAC) {
 		unsigned char fmtm = ~0, fmts = 0;
@@ -884,7 +1155,7 @@ static int set_dac_channels(struct cm_st
 
 		// ENDBDAC, turn on double DAC mode
 		// XCHGDAC, CH0 -> back, CH1->front
-		maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~0, 0xC0);
+		maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~0, ENDBDAC|XCHGDAC);
 		s->status |= DO_DUAL_DAC;
 		// prepare secondary buffer
 
@@ -907,20 +1178,21 @@ static int set_dac_channels(struct cm_st
 
 	    }
 
+	    // N4SPK3D, disable 4 speaker mode (analog duplicate)
 	    if (s->speakers > 2)
-		maskb(s->iobase + CODEC_CMI_MISC_CTRL + 3, ~0x04, 0);
+		maskb(s->iobase + CODEC_CMI_MISC_CTRL + 3, ~N4SPK3D, 0);
 	    s->curr_channels = channels;
 	} else {
 	    if (s->status & DO_MULTI_CH_HW) {
-		maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 3, ~0x80, 0);
-		maskb(s->iobase + CODEC_CMI_CHFORMAT + 3, ~0xa0, 0);
-		maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 1, ~0x80, 0);
+		maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 3, ~NXCHG, 0);
+		maskb(s->iobase + CODEC_CMI_CHFORMAT + 3, ~(CHB3D5C|CHB3D), 0);
+		maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 1, ~CHB3D6C, 0);
 	    } else if (s->status & DO_DUAL_DAC) {
-		maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~0x80, 0);
+		maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~ENDBDAC, 0);
 	    }
 	    // N4SPK3D, enable 4 speaker mode (analog duplicate)
 	    if (s->speakers > 2)
-		maskb(s->iobase + CODEC_CMI_MISC_CTRL + 3, ~0, 0x04);
+		maskb(s->iobase + CODEC_CMI_MISC_CTRL + 3, ~0, N4SPK3D);
 	    s->status &= ~DO_MULTI_CH;
 	    s->curr_channels = s->fmt & (CM_CFMT_STEREO << CM_CFMT_DACSHIFT) ? 2 : 1;
 	}
@@ -934,7 +1206,7 @@ static int set_dac_channels(struct cm_st
 #define DMABUF_DEFAULTORDER (16-PAGE_SHIFT)
 #define DMABUF_MINORDER 1
 
-static void dealloc_dmabuf(struct dmabuf *db)
+static void dealloc_dmabuf(struct cm_state *s, struct dmabuf *db)
 {
 	struct page *pstart, *pend;
 	
@@ -943,7 +1215,7 @@ static void dealloc_dmabuf(struct dmabuf
 		pend = virt_to_page(db->rawbuf + (PAGE_SIZE << db->buforder) - 1);
 		for (pstart = virt_to_page(db->rawbuf); pstart <= pend; pstart++)
 			mem_map_unreserve(pstart);
-		free_pages((unsigned long)db->rawbuf, db->buforder);
+		pci_free_consistent(s->dev, PAGE_SIZE << db->buforder, db->rawbuf, db->dmaaddr);
 	}
 	db->rawbuf = NULL;
 	db->mapped = db->ready = 0;
@@ -976,18 +1248,11 @@ static int prog_dmabuf(struct cm_state *
 	if (!db->rawbuf) {
 		db->ready = db->mapped = 0;
 		for (order = DMABUF_DEFAULTORDER; order >= DMABUF_MINORDER; order--)
-			if ((db->rawbuf = (void *)__get_free_pages(GFP_KERNEL | GFP_DMA, order)))
+			if ((db->rawbuf = pci_alloc_consistent(s->dev, PAGE_SIZE << order, &db->dmaaddr)))
 				break;
-		if (!db->rawbuf)
+		if (!db->rawbuf || !db->dmaaddr)
 			return -ENOMEM;
 		db->buforder = order;
-		db->rawphys = virt_to_bus(db->rawbuf);
-		if ((db->rawphys ^ (db->rawphys + (PAGE_SIZE << db->buforder) - 1)) & ~0xffff)
-			printk(KERN_DEBUG "cmpci: DMA buffer crosses 64k boundary: busaddr 0x%lx  size %ld\n", 
-			       (long) db->rawphys, PAGE_SIZE << db->buforder);
-		if ((db->rawphys + (PAGE_SIZE << db->buforder) - 1) & ~0xffffff)
-			printk(KERN_DEBUG "cmpci: DMA buffer beyond 16MB: busaddr 0x%lx  size %ld\n", 
-			       (long) db->rawphys, PAGE_SIZE << db->buforder);
 		/* now mark the pages as reserved; otherwise remap_page_range doesn't do what we want */
 		pend = virt_to_page(db->rawbuf + (PAGE_SIZE << db->buforder) - 1);
 		for (pstart = virt_to_page(db->rawbuf); pstart <= pend; pstart++)
@@ -1021,17 +1286,18 @@ static int prog_dmabuf(struct cm_state *
 	spin_lock_irqsave(&s->lock, flags);
 	if (rec) {
 		if (s->status & DO_DUAL_DAC)
-		    set_dmadac1(s, db->rawphys, db->dmasize >> sample_shift[fmt]);
+		    set_dmadac1(s, db->dmaaddr, db->dmasize >> sample_shift[fmt]);
 		else
-		    set_dmaadc(s, db->rawphys, db->dmasize >> sample_shift[fmt]);
+		    set_dmaadc(s, db->dmaaddr, db->dmasize >> sample_shift[fmt]);
 		/* program sample counts */
 		set_countdac(s, db->fragsamples);
 	} else {
-		set_dmadac(s, db->rawphys, db->dmasize >> sample_shift[fmt]);
+		set_dmadac(s, db->dmaaddr, db->dmasize >> sample_shift[fmt]);
 		/* program sample counts */
 		set_countdac(s, db->fragsamples);
 	}
 	spin_unlock_irqrestore(&s->lock, flags);
+	db->enabled = 1;
 	db->ready = 1;
 	return 0;
 }
@@ -1084,7 +1350,7 @@ static void cm_update_ptr(struct cm_stat
 				clear_advance(s);
 				s->dma_adc.endcleared = 1;
 			}
-			if (s->dma_dac.count + (signed)s->dma_dac.fragsize <= (signed)s->dma_dac.dmasize)
+			if (s->dma_adc.count + (signed)s->dma_adc.fragsize <= (signed)s->dma_adc.dmasize)
 				wake_up(&s->dma_adc.wait);
 		}
 	    } else {
@@ -1173,10 +1439,10 @@ static void cm_interrupt(int irq, void *
 	spin_lock(&s->lock);
 	intstat = inb(s->iobase + CODEC_CMI_INT_HLDCLR + 2);
 	/* acknowledge interrupt */
-	if (intsrc & CM_INT_CH0)
-		mask |= 1;
-	if (intsrc & CM_INT_CH1)
-		mask |= 2;
+	if (intsrc & ADCINT)
+		mask |= ENADCINT;
+	if (intsrc & DACINT)
+		mask |= ENDACINT;
 	outb(intstat & ~mask, s->iobase + CODEC_CMI_INT_HLDCLR + 2);
 	outb(intstat | mask, s->iobase + CODEC_CMI_INT_HLDCLR + 2);
 	cm_update_ptr(s);
@@ -1237,7 +1503,8 @@ static const struct {
 	[SOUND_MIXER_SYNTH]  = { DSP_MIX_FMVOLIDX_L,  	 DSP_MIX_FMVOLIDX_R,     MT_5MUTE,     0x40, 0x00 },
 	[SOUND_MIXER_VOLUME] = { DSP_MIX_MASTERVOLIDX_L, DSP_MIX_MASTERVOLIDX_R, MT_5MUTE,     0x00, 0x00 },
 	[SOUND_MIXER_PCM]    = { DSP_MIX_VOICEVOLIDX_L,  DSP_MIX_VOICEVOLIDX_R,  MT_5MUTE,     0x00, 0x00 },
-	[SOUND_MIXER_SPEAKER]= { DSP_MIX_SPKRVOLIDX,	 DSP_MIX_SPKRVOLIDX,	 MT_5MUTEMONO, 0x01, 0x01 }
+	[SOUND_MIXER_LINE1]  = { DSP_MIX_AUXVOL_L,       DSP_MIX_AUXVOL_R,       MT_5MUTE,     0x80, 0x20 },
+	[SOUND_MIXER_SPEAKER]= { DSP_MIX_SPKRVOLIDX,	 DSP_MIX_SPKRVOLIDX,	 MT_5MUTEMONO, 0x00, 0x01 }
 };
 
 static const unsigned char volidx[SOUND_MIXER_NRDEVICES] = 
@@ -1248,15 +1515,32 @@ static const unsigned char volidx[SOUND_
 	[SOUND_MIXER_SYNTH]  = 4,
 	[SOUND_MIXER_VOLUME] = 5,
 	[SOUND_MIXER_PCM]    = 6,
-	[SOUND_MIXER_SPEAKER]= 7
+	[SOUND_MIXER_LINE1]  = 7,
+	[SOUND_MIXER_SPEAKER]= 8
 };
 
+static unsigned mixer_outmask(struct cm_state *s)
+{
+	unsigned long flags;
+	int i, j, k;
+
+	spin_lock_irqsave(&s->lock, flags);
+	j = rdmixer(s, DSP_MIX_OUTMIXIDX);
+	spin_unlock_irqrestore(&s->lock, flags);
+	for (k = i = 0; i < SOUND_MIXER_NRDEVICES; i++)
+		if (j & mixtable[i].play)
+			k |= 1 << i;
+	return k;
+}
+
 static unsigned mixer_recmask(struct cm_state *s)
 {
+	unsigned long flags;
 	int i, j, k;
 
+	spin_lock_irqsave(&s->lock, flags);
 	j = rdmixer(s, DSP_MIX_ADCMIXIDX_L);
-	j &= 0x7f;
+	spin_unlock_irqrestore(&s->lock, flags);
 	for (k = i = 0; i < SOUND_MIXER_NRDEVICES; i++)
 		if (j & mixtable[i].rec)
 			k |= 1 << i;
@@ -1289,15 +1573,17 @@ static int mixer_ioctl(struct cm_state *
 	}
 	if (cmd == OSS_GETVERSION)
 		return put_user(SOUND_VERSION, (int *)arg);
-	if (_IOC_TYPE(cmd) != 'M' || _IOC_SIZE(cmd) != sizeof(int))
+	if (_IOC_TYPE(cmd) != 'M' || _SIOC_SIZE(cmd) != sizeof(int))
                 return -EINVAL;
-        if (_IOC_DIR(cmd) == _IOC_READ) {
+        if (_SIOC_DIR(cmd) == _SIOC_READ) {
                 switch (_IOC_NR(cmd)) {
                 case SOUND_MIXER_RECSRC: /* Arg contains a bit for each recording source */
-			return put_user(mixer_recmask(s), (int *)arg);
+			val = mixer_recmask(s);
+			return put_user(val, (int *)arg);
 			
                 case SOUND_MIXER_OUTSRC: /* Arg contains a bit for each recording source */
-			return put_user(mixer_recmask(s), (int *)arg);//need fix
+			val = mixer_outmask(s);
+			return put_user(val, (int *)arg);
 			
                 case SOUND_MIXER_DEVMASK: /* Arg contains a bit for each supported device */
 			for (val = i = 0; i < SOUND_MIXER_NRDEVICES; i++)
@@ -1335,7 +1621,7 @@ static int mixer_ioctl(struct cm_state *
 			return put_user(s->mix.vol[volidx[i]-1], (int *)arg);
 		}
 	}
-        if (_IOC_DIR(cmd) != (_IOC_READ|_IOC_WRITE)) 
+        if (_SIOC_DIR(cmd) != (_SIOC_READ|_SIOC_WRITE)) 
 		return -EINVAL;
 	s->mix.modcnt++;
 	switch (_IOC_NR(cmd)) {
@@ -1354,7 +1640,7 @@ static int mixer_ioctl(struct cm_state *
 		}
 		spin_lock_irqsave(&s->lock, flags);
 		wrmixer(s, DSP_MIX_ADCMIXIDX_L, j);
-		wrmixer(s, DSP_MIX_ADCMIXIDX_R, (j & 1) | (j>>1));
+		wrmixer(s, DSP_MIX_ADCMIXIDX_R, (j & 1) | (j>>1) | (j & 0x80));
 		spin_unlock_irqrestore(&s->lock, flags);
 		return 0;
 
@@ -1371,11 +1657,11 @@ static int mixer_ioctl(struct cm_state *
 			j |= mixtable[i].play;
 		}
 		spin_lock_irqsave(&s->lock, flags);
-		frobindir(s, DSP_MIX_OUTMIXIDX, 0x1f, j);
+		wrmixer(s, DSP_MIX_OUTMIXIDX, j);
 		spin_unlock_irqrestore(&s->lock, flags);
 		return 0;
 
-		default:
+	default:
 		i = _IOC_NR(cmd);
 		if (i >= SOUND_MIXER_NRDEVICES || !mixtable[i].type)
 			return -EINVAL;
@@ -1402,15 +1688,27 @@ static int mixer_ioctl(struct cm_state *
 			rl = (l < 4 ? 0 : (l - 5) / 3) & 31;
 			rr = (rl >> 2) & 7;
 			wrmixer(s, mixtable[i].left, rl<<3);
-			maskb(s->iobase + CODEC_CMI_MIXER2, ~0x0e, rr<<1);
+			if (i == SOUND_MIXER_MIC)
+				maskb(s->iobase + CODEC_CMI_MIXER2, ~0x0e, rr<<1);
 			break;
 			
 		case MT_5MUTEMONO:
-			r = l;
 			rl = l < 4 ? 0 : (l - 5) / 3;
-			rr = rl >> 2;
  			wrmixer(s, mixtable[i].left, rl<<3);
-			maskb(s->iobase + CODEC_CMI_MIXER2, ~0x0e, rr<<1);
+			l = rdmixer(s, DSP_MIX_OUTMIXIDX) & ~mixtable[i].play;
+			r = rl ? mixtable[i].play : 0;
+			wrmixer(s, DSP_MIX_OUTMIXIDX, l | r);
+			/* for recording */
+			if (i == SOUND_MIXER_MIC) {
+				if (s->chip_version >= 37) {
+					rr = rl >> 1;
+					maskb(s->iobase + CODEC_CMI_MIXER2, ~0x0e, (rr&0x07)<<1);
+					frobindir(s, DSP_MIX_EXTENSION, ~0x01, rr>>3);
+				} else {
+					rr = rl >> 2;
+					maskb(s->iobase + CODEC_CMI_MIXER2, ~0x0e, rr<<1);
+				}
+			}
 			break;
 				
 		case MT_5MUTE:
@@ -1418,6 +1716,10 @@ static int mixer_ioctl(struct cm_state *
 			rr = r < 4 ? 0 : (r - 5) / 3;
  			wrmixer(s, mixtable[i].left, rl<<3);
 			wrmixer(s, mixtable[i].right, rr<<3);
+			l = rdmixer(s, DSP_MIX_OUTMIXIDX);
+			l &= ~mixtable[i].play;
+			r = (rl|rr) ? mixtable[i].play : 0;
+			wrmixer(s, DSP_MIX_OUTMIXIDX, l | r);
 			break;
 
 		case MT_6MUTE:
@@ -1447,12 +1749,16 @@ static int mixer_ioctl(struct cm_state *
 static int cm_open_mixdev(struct inode *inode, struct file *file)
 {
 	int minor = MINOR(inode->i_rdev);
-	struct cm_state *s = devs;
+	struct list_head *list;
+	struct cm_state *s;
 
-	while (s && s->dev_mixer != minor)
-		s = s->next;
-	if (!s)
-		return -ENODEV;
+	for (list = devs.next; ; list = list->next) {
+		if (list == &devs)
+			return -ENODEV;
+		s = list_entry(list, struct cm_state, devs);
+		if (s->dev_mixer == minor)
+			break;
+	}
        	VALIDATE_STATE(s);
 	file->private_data = s;
 	return 0;
@@ -1490,9 +1796,9 @@ static int drain_dac(struct cm_state *s,
 
 	if (s->dma_dac.mapped || !s->dma_dac.ready)
 		return 0;
-        set_current_state(TASK_INTERRUPTIBLE);
         add_wait_queue(&s->dma_dac.wait, &wait);
         for (;;) {
+        	__set_current_state(TASK_INTERRUPTIBLE);
                 spin_lock_irqsave(&s->lock, flags);
 		count = s->dma_dac.count;
                 spin_unlock_irqrestore(&s->lock, flags);
@@ -1522,6 +1828,7 @@ static int drain_dac(struct cm_state *s,
 static ssize_t cm_read(struct file *file, char *buffer, size_t count, loff_t *ppos)
 {
 	struct cm_state *s = (struct cm_state *)file->private_data;
+	DECLARE_WAITQUEUE(wait, current);
 	ssize_t ret;
 	unsigned long flags;
 	unsigned swptr;
@@ -1538,37 +1845,50 @@ static ssize_t cm_read(struct file *file
 		return -EFAULT;
 	ret = 0;
 
+        add_wait_queue(&s->dma_adc.wait, &wait);
 	while (count > 0) {
 		spin_lock_irqsave(&s->lock, flags);
 		swptr = s->dma_adc.swptr;
 		cnt = s->dma_adc.dmasize-swptr;
 		if (s->dma_adc.count < cnt)
 			cnt = s->dma_adc.count;
+		if (cnt <= 0)
+			__set_current_state(TASK_INTERRUPTIBLE);
 		spin_unlock_irqrestore(&s->lock, flags);
 		if (cnt > count)
 			cnt = count;
 		if (cnt <= 0) {
-			start_adc(s);
-			if (file->f_flags & O_NONBLOCK)
-				return ret ? ret : -EAGAIN;
-			if (!interruptible_sleep_on_timeout(&s->dma_adc.wait, HZ)) {
+			if (s->dma_adc.enabled)
+				start_adc(s);
+			if (file->f_flags & O_NONBLOCK) {
+				if (!ret)
+					ret = -EAGAIN;
+				goto out;
+			}
+			if (!schedule_timeout(HZ)) {
 				printk(KERN_DEBUG "cmpci: read: chip lockup? dmasz %u fragsz %u count %i hwptr %u swptr %u\n",
 				       s->dma_adc.dmasize, s->dma_adc.fragsize, s->dma_adc.count,
 				       s->dma_adc.hwptr, s->dma_adc.swptr);
 				spin_lock_irqsave(&s->lock, flags);
 				stop_adc_unlocked(s);
-				set_dmaadc(s, s->dma_adc.rawphys, s->dma_adc.dmasamples);
+				set_dmaadc(s, s->dma_adc.dmaaddr, s->dma_adc.dmasamples);
 				/* program sample counts */
 				set_countadc(s, s->dma_adc.fragsamples);
 				s->dma_adc.count = s->dma_adc.hwptr = s->dma_adc.swptr = 0;
 				spin_unlock_irqrestore(&s->lock, flags);
 			}
-			if (signal_pending(current))
-				return ret ? ret : -ERESTARTSYS;
+			if (signal_pending(current)) {
+				if (!ret)
+					ret = -ERESTARTSYS;
+				goto out;
+			}
 			continue;
 		}
-		if (copy_to_user(buffer, s->dma_adc.rawbuf + swptr, cnt))
-			return ret ? ret : -EFAULT;
+		if (copy_to_user(buffer, s->dma_adc.rawbuf + swptr, cnt)) {
+			if (!ret)
+				ret = -EFAULT;
+			goto out;
+		}
 		swptr = (swptr + cnt) % s->dma_adc.dmasize;
 		spin_lock_irqsave(&s->lock, flags);
 		s->dma_adc.swptr = swptr;
@@ -1576,15 +1896,20 @@ static ssize_t cm_read(struct file *file
 		count -= cnt;
 		buffer += cnt;
 		ret += cnt;
-		start_adc_unlocked(s);
+		if (s->dma_adc.enabled)
+			start_adc_unlocked(s);
 		spin_unlock_irqrestore(&s->lock, flags);
 	}
+out:
+        remove_wait_queue(&s->dma_adc.wait, &wait);
+	set_current_state(TASK_RUNNING);
 	return ret;
 }
 
 static ssize_t cm_write(struct file *file, const char *buffer, size_t count, loff_t *ppos)
 {
 	struct cm_state *s = (struct cm_state *)file->private_data;
+	DECLARE_WAITQUEUE(wait, current);
 	ssize_t ret;
 	unsigned long flags;
 	unsigned swptr;
@@ -1609,6 +1934,7 @@ static ssize_t cm_write(struct file *fil
 		return -EFAULT;
 	ret = 0;
 
+        add_wait_queue(&s->dma_dac.wait, &wait);
 	while (count > 0) {
 		spin_lock_irqsave(&s->lock, flags);
 		if (s->dma_dac.count < 0) {
@@ -1629,33 +1955,42 @@ static ssize_t cm_write(struct file *fil
 			if (s->dma_dac.count + cnt > s->dma_dac.dmasize)
 				cnt = s->dma_dac.dmasize - s->dma_dac.count;
 		}
+		if (cnt <= 0)
+			__set_current_state(TASK_INTERRUPTIBLE);
 		spin_unlock_irqrestore(&s->lock, flags);
 		if (cnt > count)
 			cnt = count;
 		if ((s->status & DO_DUAL_DAC) && (cnt > count / 2))
 		    cnt = count / 2;
 		if (cnt <= 0) {
-			start_dac(s);
-			if (file->f_flags & O_NONBLOCK)
-				return ret ? ret : -EAGAIN;
-			if (!interruptible_sleep_on_timeout(&s->dma_dac.wait, HZ)) {
+			if (s->dma_dac.enabled)
+				start_dac(s);
+			if (file->f_flags & O_NONBLOCK) {
+				if (!ret)
+					ret = -EAGAIN;
+				goto out;
+			}
+			if (!schedule_timeout(HZ)) {
 				printk(KERN_DEBUG "cmpci: write: chip lockup? dmasz %u fragsz %u count %i hwptr %u swptr %u\n",
 				       s->dma_dac.dmasize, s->dma_dac.fragsize, s->dma_dac.count,
 				       s->dma_dac.hwptr, s->dma_dac.swptr);
 				spin_lock_irqsave(&s->lock, flags);
 				stop_dac_unlocked(s);
-				set_dmadac(s, s->dma_dac.rawphys, s->dma_dac.dmasamples);
+				set_dmadac(s, s->dma_dac.dmaaddr, s->dma_dac.dmasamples);
 				/* program sample counts */
 				set_countdac(s, s->dma_dac.fragsamples);
 				s->dma_dac.count = s->dma_dac.hwptr = s->dma_dac.swptr = 0;
 				if (s->status & DO_DUAL_DAC)  {
-					set_dmadac1(s, s->dma_adc.rawphys, s->dma_adc.dmasamples);
+					set_dmadac1(s, s->dma_adc.dmaaddr, s->dma_adc.dmasamples);
 					s->dma_adc.count = s->dma_adc.hwptr = s->dma_adc.swptr = 0;
 				}
 				spin_unlock_irqrestore(&s->lock, flags);
 			}
-			if (signal_pending(current))
-				return ret ? ret : -ERESTARTSYS;
+			if (signal_pending(current)) {
+				if (!ret)
+					ret = -ERESTARTSYS;
+				goto out;
+			}
 			continue;
 		}
 		if (s->status & DO_AC3_SW) {
@@ -1664,8 +1999,10 @@ static ssize_t cm_write(struct file *fil
 			// clip exceeded data, caught by 033 and 037
 			if (swptr + 2 * cnt > s->dma_dac.dmasize)
 				cnt = (s->dma_dac.dmasize - swptr) / 2;
-			if ((err = trans_ac3(s, s->dma_dac.rawbuf + swptr, buffer, cnt)))
-				return err;
+			if ((err = trans_ac3(s, s->dma_dac.rawbuf + swptr, buffer, cnt))) {
+				ret = err;
+				goto out;
+			}
 			swptr = (swptr + 2 * cnt) % s->dma_dac.dmasize;
 		} else if (s->status & DO_DUAL_DAC) {
 			int	i, err;
@@ -1676,15 +2013,22 @@ static ssize_t cm_write(struct file *fil
 			dst1 = (unsigned long *) (s->dma_adc.rawbuf + swptr);
 			// copy left/right sample at one time
 			for (i = 0; i <= cnt / 4; i++) {
-				if ((err = __get_user(*dst0++, src++)))
-					return err;
-				if ((err = __get_user(*dst1++, src++)))
-					return err;
+				if ((err = __get_user(*dst0++, src++))) {
+					ret = err;
+					goto out;
+				}
+				if ((err = __get_user(*dst1++, src++))) {
+					ret = err;
+					goto out;
+				}
 			}
 			swptr = (swptr + cnt) % s->dma_dac.dmasize;
 		} else {
-			if (copy_from_user(s->dma_dac.rawbuf + swptr, buffer, cnt))
-				return ret ? ret : -EFAULT;
+			if (copy_from_user(s->dma_dac.rawbuf + swptr, buffer, cnt)) {
+				if (!ret)
+					ret = -EFAULT;
+				goto out;
+			}
 			swptr = (swptr + cnt) % s->dma_dac.dmasize;
 		}
 		spin_lock_irqsave(&s->lock, flags);
@@ -1702,8 +2046,12 @@ static ssize_t cm_write(struct file *fil
 			buffer += cnt;
 			ret += cnt;
 		}
-		start_dac(s);
+		if (s->dma_dac.enabled)
+			start_dac(s);
 	}
+out:
+        remove_wait_queue(&s->dma_dac.wait, &wait);
+	set_current_state(TASK_RUNNING);
 	return ret;
 }
 
@@ -1714,10 +2062,16 @@ static unsigned int cm_poll(struct file 
 	unsigned int mask = 0;
 
 	VALIDATE_STATE(s);
-	if (file->f_mode & FMODE_WRITE)
+	if (file->f_mode & FMODE_WRITE) {
+		if (!s->dma_dac.ready && prog_dmabuf(s, 0))
+			return 0;
 		poll_wait(file, &s->dma_dac.wait, wait);
-	if (file->f_mode & FMODE_READ)
+	}
+	if (file->f_mode & FMODE_READ) {
+		if (!s->dma_adc.ready && prog_dmabuf(s, 1))
+			return 0;
 		poll_wait(file, &s->dma_adc.wait, wait);
+	}
 	spin_lock_irqsave(&s->lock, flags);
 	cm_update_ptr(s);
 	if (file->f_mode & FMODE_READ) {
@@ -1772,6 +2126,16 @@ out:
 	return ret;
 }
 
+#define SNDCTL_SPDIF_COPYRIGHT	_SIOW('S',  0, int)       // set/reset S/PDIF copy protection
+#define SNDCTL_SPDIF_LOOP	_SIOW('S',  1, int)       // set/reset S/PDIF loop
+#define SNDCTL_SPDIF_MONITOR	_SIOW('S',  2, int)       // set S/PDIF monitor
+#define SNDCTL_SPDIF_LEVEL	_SIOW('S',  3, int)       // set/reset S/PDIF out level
+#define SNDCTL_SPDIF_INV	_SIOW('S',  4, int)       // set/reset S/PDIF in inverse
+#define SNDCTL_SPDIF_SEL2	_SIOW('S',  5, int)       // set S/PDIF in #2
+#define SNDCTL_SPDIF_VALID	_SIOW('S',  6, int)       // set S/PDIF valid
+#define SNDCTL_SPDIFOUT		_SIOW('S',  7, int)       // set S/PDIF out
+#define SNDCTL_SPDIFIN		_SIOW('S',  8, int)       // set S/PDIF out
+
 static int cm_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
 {
 	struct cm_state *s = (struct cm_state *)file->private_data;
@@ -1955,14 +2319,14 @@ static int cm_ioctl(struct inode *inode,
 		val = 0;
 		if (s->status & DO_DUAL_DAC) {
 			if (file->f_mode & FMODE_WRITE &&
-			 (s->enable & CM_ENABLE_CH1) &&
-			 (s->enable & CM_ENABLE_CH0))
+			 (s->enable & ENDAC) &&
+			 (s->enable & ENADC))
 				val |= PCM_ENABLE_OUTPUT;
 			return put_user(val, (int *)arg);
 		}
-		if (file->f_mode & FMODE_READ && s->enable & CM_ENABLE_CH0) 
+		if (file->f_mode & FMODE_READ && s->enable & ENADC) 
 			val |= PCM_ENABLE_INPUT;
-		if (file->f_mode & FMODE_WRITE && s->enable & CM_ENABLE_CH1) 
+		if (file->f_mode & FMODE_WRITE && s->enable & ENDAC) 
 			val |= PCM_ENABLE_OUTPUT;
 		return put_user(val, (int *)arg);
 
@@ -1973,9 +2337,12 @@ static int cm_ioctl(struct inode *inode,
 			if (val & PCM_ENABLE_INPUT) {
 				if (!s->dma_adc.ready && (ret =  prog_dmabuf(s, 1)))
 					return ret;
+				s->dma_adc.enabled = 1;
 				start_adc(s);
-			} else
+			} else {
+				s->dma_adc.enabled = 0;
 				stop_adc(s);
+			}
 		}
 		if (file->f_mode & FMODE_WRITE) {
 			if (val & PCM_ENABLE_OUTPUT) {
@@ -1985,16 +2352,19 @@ static int cm_ioctl(struct inode *inode,
 					if (!s->dma_adc.ready && (ret = prog_dmabuf(s, 1)))
 						return ret;
 				}
+				s->dma_dac.enabled = 1;
 				start_dac(s);
-			} else
+			} else {
+				s->dma_dac.enabled = 0;
 				stop_dac(s);
+			}
 		}
 		return 0;
 
 	case SNDCTL_DSP_GETOSPACE:
 		if (!(file->f_mode & FMODE_WRITE))
 			return -EINVAL;
-		if (!(s->enable & CM_ENABLE_CH1) && (val = prog_dmabuf(s, 0)) != 0)
+		if (!(s->enable & ENDAC) && (val = prog_dmabuf(s, 0)) != 0)
 			return val;
 		spin_lock_irqsave(&s->lock, flags);
 		cm_update_ptr(s);
@@ -2008,7 +2378,7 @@ static int cm_ioctl(struct inode *inode,
 	case SNDCTL_DSP_GETISPACE:
 		if (!(file->f_mode & FMODE_READ))
 			return -EINVAL;
-		if (!(s->enable & CM_ENABLE_CH0) && (val = prog_dmabuf(s, 1)) != 0)
+		if (!(s->enable & ENADC) && (val = prog_dmabuf(s, 1)) != 0)
 			return val;
 		spin_lock_irqsave(&s->lock, flags);
 		cm_update_ptr(s);
@@ -2155,6 +2525,11 @@ static int cm_ioctl(struct inode *inode,
 			if (file->f_mode & FMODE_READ) {
 				stop_adc(s);
 				s->dma_adc.ready = 0;
+				if (val & DSP_BIND_SPDIF) {
+					set_spdifin(s, s->rateadc);
+					if (!(s->status & DO_SPDIF_OUT))
+						val &= ~DSP_BIND_SPDIF;
+				}
 			}
 			if (file->f_mode & FMODE_WRITE) {
 				stop_dac(s);
@@ -2194,7 +2569,51 @@ static int cm_ioctl(struct inode *inode,
 	case SNDCTL_DSP_MAPOUTBUF:
         case SNDCTL_DSP_SETSYNCRO:
                 return -EINVAL;
-		
+	case SNDCTL_SPDIF_COPYRIGHT:
+		if (get_user(val, (int *)arg))
+			return -EFAULT;
+		set_spdif_copyright(s, val);
+                return 0;
+	case SNDCTL_SPDIF_LOOP:
+		if (get_user(val, (int *)arg))
+			return -EFAULT;
+		set_spdif_loop(s, val);
+                return 0;
+	case SNDCTL_SPDIF_MONITOR:
+		if (get_user(val, (int *)arg))
+			return -EFAULT;
+		set_spdif_monitor(s, val);
+                return 0;
+	case SNDCTL_SPDIF_LEVEL:
+		if (get_user(val, (int *)arg))
+			return -EFAULT;
+		set_spdifout_level(s, val);
+                return 0;
+	case SNDCTL_SPDIF_INV:
+		if (get_user(val, (int *)arg))
+			return -EFAULT;
+		set_spdifin_inverse(s, val);
+                return 0;
+	case SNDCTL_SPDIF_SEL2:
+		if (get_user(val, (int *)arg))
+			return -EFAULT;
+		set_spdifin_channel2(s, val);
+                return 0;
+	case SNDCTL_SPDIF_VALID:
+		if (get_user(val, (int *)arg))
+			return -EFAULT;
+		set_spdifin_valid(s, val);
+                return 0;
+	case SNDCTL_SPDIFOUT:
+		if (get_user(val, (int *)arg))
+			return -EFAULT;
+		set_spdifout(s, val ? s->ratedac : 0);
+                return 0;
+	case SNDCTL_SPDIFIN:
+		if (get_user(val, (int *)arg))
+			return -EFAULT;
+		set_spdifin(s, val ? s->rateadc : 0);
+                return 0;
 	}
 	return mixer_ioctl(s, cmd, arg);
 }
@@ -2202,13 +2621,18 @@ static int cm_ioctl(struct inode *inode,
 static int cm_open(struct inode *inode, struct file *file)
 {
 	int minor = MINOR(inode->i_rdev);
-	struct cm_state *s = devs;
+	DECLARE_WAITQUEUE(wait, current);
 	unsigned char fmtm = ~0, fmts = 0;
+	struct list_head *list;
+	struct cm_state *s;
 
-	while (s && ((s->dev_audio ^ minor) & ~0xf))
-		s = s->next;
-	if (!s)
-		return -ENODEV;
+	for (list = devs.next; ; list = list->next) {
+		if (list == &devs)
+			return -ENODEV;
+		s = list_entry(list, struct cm_state, devs);
+		if (!((s->dev_audio ^ minor) & ~0xf))
+			break;
+	}
        	VALIDATE_STATE(s);
 	file->private_data = s;
 	/* wait for device to become free */
@@ -2218,8 +2642,12 @@ static int cm_open(struct inode *inode, 
 			up(&s->open_sem);
 			return -EBUSY;
 		}
+		add_wait_queue(&s->open_wait, &wait);
+		__set_current_state(TASK_INTERRUPTIBLE);
 		up(&s->open_sem);
-		interruptible_sleep_on(&s->open_wait);
+		schedule();
+		remove_wait_queue(&s->open_wait, &wait);
+		set_current_state(TASK_RUNNING);
 		if (signal_pending(current))
 			return -ERESTARTSYS;
 		down(&s->open_sem);
@@ -2229,17 +2657,22 @@ static int cm_open(struct inode *inode, 
 		if ((minor & 0xf) == SND_DEV_DSP16)
 			fmts |= CM_CFMT_16BIT << CM_CFMT_ADCSHIFT;
 		s->dma_adc.ossfragshift = s->dma_adc.ossmaxfrags = s->dma_adc.subdivision = 0;
+		s->dma_adc.enabled = 1;
 		set_adc_rate(s, 8000);
+		// spdif-in is turnned off by default
+		set_spdifin(s, 0);
 	}
 	if (file->f_mode & FMODE_WRITE) {
 		fmtm &= ~((CM_CFMT_STEREO | CM_CFMT_16BIT) << CM_CFMT_DACSHIFT);
 		if ((minor & 0xf) == SND_DEV_DSP16)
 			fmts |= CM_CFMT_16BIT << CM_CFMT_DACSHIFT;
 		s->dma_dac.ossfragshift = s->dma_dac.ossmaxfrags = s->dma_dac.subdivision = 0;
+		s->dma_dac.enabled = 1;
 		set_dac_rate(s, 8000);
 		// clear previous multichannel, spdif, ac3 state
 		set_spdifout(s, 0);
-		if (s->deviceid == PCI_DEVICE_ID_CMEDIA_CM8738) {
+		if (s->deviceid == PCI_DEVICE_ID_CMEDIA_CM8738
+		 || s->deviceid == PCI_DEVICE_ID_CMEDIA_CM8738B) {
 			set_ac3(s, 0);
 			set_dac_channels(s, 1);
 		}
@@ -2262,9 +2695,9 @@ static int cm_release(struct inode *inod
 	if (file->f_mode & FMODE_WRITE) {
 		stop_dac(s);
 
-		dealloc_dmabuf(&s->dma_dac);
+		dealloc_dmabuf(s, &s->dma_dac);
 		if (s->status & DO_DUAL_DAC)
-			dealloc_dmabuf(&s->dma_adc);
+			dealloc_dmabuf(s, &s->dma_adc);
 
 		if (s->status & DO_MULTI_CH)
 			set_dac_channels(s, 0);
@@ -2275,7 +2708,7 @@ static int cm_release(struct inode *inod
 	}
 	if (file->f_mode & FMODE_READ) {
 		stop_adc(s);
-		dealloc_dmabuf(&s->dma_adc);
+		dealloc_dmabuf(s, &s->dma_adc);
 	}
 	s->open_mode &= ~(file->f_mode & (FMODE_READ|FMODE_WRITE));
 	up(&s->open_sem);
@@ -2321,6 +2754,8 @@ static ssize_t cm_midi_read(struct file 
 		cnt = MIDIINBUF - ptr;
 		if (s->midi.icnt < cnt)
 			cnt = s->midi.icnt;
+		if (cnt <= 0)
+			__set_current_state(TASK_INTERRUPTIBLE);
 		spin_unlock_irqrestore(&s->lock, flags);
 		if (cnt > count)
 			cnt = count;
@@ -2331,7 +2766,6 @@ static ssize_t cm_midi_read(struct file 
 					ret = -EAGAIN;
 				break;
 			}
-			__set_current_state(TASK_INTERRUPTIBLE);
 			schedule();
 			if (signal_pending(current))
 			{
@@ -2386,8 +2820,10 @@ static ssize_t cm_midi_write(struct file
 		cnt = MIDIOUTBUF - ptr;
 		if (s->midi.ocnt + cnt > MIDIOUTBUF)
 			cnt = MIDIOUTBUF - s->midi.ocnt;
-		if (cnt <= 0)
+		if (cnt <= 0) {
+			__set_current_state(TASK_INTERRUPTIBLE);
 			cm_handle_midi(s);
+		}
 		spin_unlock_irqrestore(&s->lock, flags);
 		if (cnt > count)
 			cnt = count;
@@ -2398,7 +2834,6 @@ static ssize_t cm_midi_write(struct file
 					ret = -EAGAIN;
 				break;
 			}
-			__set_current_state(TASK_INTERRUPTIBLE);
 			schedule();
 			if (signal_pending(current)) {
 				if (!ret)
@@ -2457,13 +2892,18 @@ static unsigned int cm_midi_poll(struct 
 static int cm_midi_open(struct inode *inode, struct file *file)
 {
 	int minor = MINOR(inode->i_rdev);
-	struct cm_state *s = devs;
+	DECLARE_WAITQUEUE(wait, current);
 	unsigned long flags;
+	struct list_head *list;
+	struct cm_state *s;
 
-	while (s && s->dev_midi != minor)
-		s = s->next;
-	if (!s)
-		return -ENODEV;
+	for (list = devs.next; ; list = list->next) {
+		if (list == &devs)
+			return -ENODEV;
+		s = list_entry(list, struct cm_state, devs);
+		if (s->dev_midi == minor)
+			break;
+	}
        	VALIDATE_STATE(s);
 	file->private_data = s;
 	/* wait for device to become free */
@@ -2473,8 +2913,12 @@ static int cm_midi_open(struct inode *in
 			up(&s->open_sem);
 			return -EBUSY;
 		}
+		add_wait_queue(&s->open_wait, &wait);
+		__set_current_state(TASK_INTERRUPTIBLE);
 		up(&s->open_sem);
-		interruptible_sleep_on(&s->open_wait);
+		schedule();
+		remove_wait_queue(&s->open_wait, &wait);
+		set_current_state(TASK_RUNNING);
 		if (signal_pending(current))
 			return -ERESTARTSYS;
 		down(&s->open_sem);
@@ -2484,7 +2928,7 @@ static int cm_midi_open(struct inode *in
 		s->midi.ird = s->midi.iwr = s->midi.icnt = 0;
 		s->midi.ord = s->midi.owr = s->midi.ocnt = 0;
 		/* enable MPU-401 */
-		maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~0, 4);
+		maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~0, UART_EN);
 		outb(0xff, s->iomidi+1); /* reset command */
 		if (!(inb(s->iomidi+1) & 0x80))
 			inb(s->iomidi);
@@ -2507,7 +2951,6 @@ static int cm_midi_open(struct inode *in
 	spin_unlock_irqrestore(&s->lock, flags);
 	s->open_mode |= (file->f_mode << FMODE_MIDI_SHIFT) & (FMODE_MIDI_READ | FMODE_MIDI_WRITE);
 	up(&s->open_sem);
-	MOD_INC_USE_COUNT;
 	return 0;
 }
 
@@ -2522,9 +2965,9 @@ static int cm_midi_release(struct inode 
 	lock_kernel();
 
 	if (file->f_mode & FMODE_WRITE) {
-		__set_current_state(TASK_INTERRUPTIBLE);
 		add_wait_queue(&s->midi.owait, &wait);
 		for (;;) {
+			__set_current_state(TASK_INTERRUPTIBLE);
 			spin_lock_irqsave(&s->lock, flags);
 			count = s->midi.ocnt;
 			spin_unlock_irqrestore(&s->lock, flags);
@@ -2532,12 +2975,8 @@ static int cm_midi_release(struct inode 
 				break;
 			if (signal_pending(current))
 				break;
-			if (file->f_flags & O_NONBLOCK) {
-				remove_wait_queue(&s->midi.owait, &wait);
-				set_current_state(TASK_RUNNING);
-				unlock_kernel();
-				return -EBUSY;
-			}
+			if (file->f_flags & O_NONBLOCK)
+				break;
 			tmo = (count * HZ) / 3100;
 			if (!schedule_timeout(tmo ? : 1) && tmo)
 				printk(KERN_DEBUG "cmpci: midi timed out??\n");
@@ -2554,7 +2993,7 @@ static int cm_midi_release(struct inode 
 		if (!(inb(s->iomidi+1) & 0x80))
 			inb(s->iomidi);
 		/* disable MPU-401 */
-		maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~4, 0);
+		maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~UART_EN, 0);
 	}
 	spin_unlock_irqrestore(&s->lock, flags);
 	up(&s->open_sem);
@@ -2675,12 +3114,17 @@ static int cm_dmfm_ioctl(struct inode *i
 static int cm_dmfm_open(struct inode *inode, struct file *file)
 {
 	int minor = MINOR(inode->i_rdev);
-	struct cm_state *s = devs;
+	DECLARE_WAITQUEUE(wait, current);
+	struct list_head *list;
+	struct cm_state *s;
 
-	while (s && s->dev_dmfm != minor)
-		s = s->next;
-	if (!s)
-		return -ENODEV;
+	for (list = devs.next; ; list = list->next) {
+		if (list == &devs)
+			return -ENODEV;
+		s = list_entry(list, struct cm_state, devs);
+		if (s->dev_dmfm == minor)
+			break;
+	}
        	VALIDATE_STATE(s);
 	file->private_data = s;
 	/* wait for device to become free */
@@ -2690,8 +3134,12 @@ static int cm_dmfm_open(struct inode *in
 			up(&s->open_sem);
 			return -EBUSY;
 		}
+		add_wait_queue(&s->open_wait, &wait);
+		__set_current_state(TASK_INTERRUPTIBLE);
 		up(&s->open_sem);
-		interruptible_sleep_on(&s->open_wait);
+		schedule();
+		remove_wait_queue(&s->open_wait, &wait);
+		set_current_state(TASK_RUNNING);
 		if (signal_pending(current))
 			return -ERESTARTSYS;
 		down(&s->open_sem);
@@ -2705,7 +3153,6 @@ static int cm_dmfm_open(struct inode *in
 	outb(1, s->iosynth+3);  /* enable OPL3 */
 	s->open_mode |= FMODE_DMFM;
 	up(&s->open_sem);
-	MOD_INC_USE_COUNT;
 	return 0;
 }
 
@@ -2836,11 +3283,17 @@ static	int	use_line_as_bass = 1;
 #else
 static	int	use_line_as_bass;
 #endif
+#ifdef CONFIG_SOUND_CMPCI_MIC_BASS
+static	int	use_mic_as_bass = 1;
+#else
+static	int	use_mic_as_bass = 0;
+#endif
 #ifdef CONFIG_SOUND_CMPCI_JOYSTICK
 static	int	joystick = 1;
 #else
 static	int	joystick;
 #endif
+static	int	mic_boost = 0;
 MODULE_PARM(mpuio, "i");
 MODULE_PARM(fmio, "i");
 MODULE_PARM(spdif_inverse, "i");
@@ -2848,7 +3301,9 @@ MODULE_PARM(spdif_loop, "i");
 MODULE_PARM(speakers, "i");
 MODULE_PARM(use_line_as_rear, "i");
 MODULE_PARM(use_line_as_bass, "i");
+MODULE_PARM(use_mic_as_bass, "i");
 MODULE_PARM(joystick, "i");
+MODULE_PARM(mic_boost, "i");
 MODULE_PARM_DESC(mpuio, "(0x330, 0x320, 0x310, 0x300) Base of MPU-401, 0 to disable");
 MODULE_PARM_DESC(fmio, "(0x388, 0x3C8, 0x3E0) Base of OPL3, 0 to disable");
 MODULE_PARM_DESC(spdif_inverse, "(1/0) Invert S/PDIF-in signal");
@@ -2856,24 +3311,15 @@ MODULE_PARM_DESC(spdif_loop, "(1/0) Rout
 MODULE_PARM_DESC(speakers, "(2-6) Number of speakers you connect");
 MODULE_PARM_DESC(use_line_as_rear, "(1/0) Use line-in jack as rear-out");
 MODULE_PARM_DESC(use_line_as_bass, "(1/0) Use line-in jack as bass/center");
+MODULE_PARM_DESC(use_mic_as_bass, "(1/0) Use mic-in jack as bass/center");
 MODULE_PARM_DESC(joystick, "(1/0) Enable joystick interface, still need joystick driver");
+MODULE_PARM_DESC(mic_boost, "(1/0) Enable microphone boost");
 
-static struct pci_device_id cmpci_pci_tbl[] = {
-	{ PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8738, 
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
- 	{ PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338A, 
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338B, 
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ 0 }
-};
-MODULE_DEVICE_TABLE(pci, cmpci_pci_tbl);
-
-void initialize_chip(struct pci_dev *pcidev)
+static int __devinit cm_probe(struct pci_dev *pcidev, const struct pci_device_id *pciid)
 {
 	struct cm_state *s;
 	mm_segment_t fs;
-	int i, val;
+	int i, val, ret;
 	unsigned char reg_mask = 0;
 	struct {
 		unsigned short	deviceid;
@@ -2886,277 +3332,282 @@ void initialize_chip(struct pci_dev *pci
 		{ PCI_DEVICE_ID_CMEDIA_CM8738B, "CM8738B" },
 	};
 	char	*devicename = "unknown";
-	{
-		if (pci_enable_device(pcidev))
-			return;
-		if (pcidev->irq == 0)
-			return;
-		s = kmalloc(sizeof(*s), GFP_KERNEL);
-		if (!s) {
-			printk(KERN_WARNING "cmpci: out of memory\n");
-			return;
-		}
-		/* search device name */
-		for (i = 0; i < sizeof(devicetable) / sizeof(devicetable[0]); i++) {
-			if (devicetable[i].deviceid == pcidev->device)
-			{
-				devicename = devicetable[i].devicename;
-				break;
-			}
-		}
-		memset(s, 0, sizeof(struct cm_state));
-		init_waitqueue_head(&s->dma_adc.wait);
-		init_waitqueue_head(&s->dma_dac.wait);
-		init_waitqueue_head(&s->open_wait);
-		init_waitqueue_head(&s->midi.iwait);
-		init_waitqueue_head(&s->midi.owait);
-		init_MUTEX(&s->open_sem);
-		spin_lock_init(&s->lock);
-		s->magic = CM_MAGIC;
-		s->iobase = pci_resource_start(pcidev, 0);
-		s->iosynth = fmio;
-		s->iomidi = mpuio;
-		s->status = 0;
-		/* range check */
-		if (speakers < 2)
-			speakers = 2;
-		else if (speakers > 6)
-			speakers = 6;
-		s->speakers = speakers;
-		if (s->iobase == 0)
-			return;
-		s->irq = pcidev->irq;
-
-		if (!request_region(s->iobase, CM_EXTENT_CODEC, "cmpci")) {
-			printk(KERN_ERR "cmpci: io ports %#x-%#x in use\n", s->iobase, s->iobase+CM_EXTENT_CODEC-1);
-			goto err_region5;
+	if ((ret = pci_enable_device(pcidev)))
+		return ret;
+	if (!(pci_resource_flags(pcidev, 0) & IORESOURCE_IO))
+		return -ENODEV;
+	if (pcidev->irq == 0)
+		return -ENODEV;
+	i = pci_set_dma_mask(pcidev, 0xffffffff);
+	if (i) {
+		printk(KERN_WARNING "cmpci: architecture does not support 32bit PCI busmaster DMA\n");
+		return i;
+	}
+	s = kmalloc(sizeof(*s), GFP_KERNEL);
+	if (!s) {
+		printk(KERN_WARNING "cmpci: out of memory\n");
+		return -ENOMEM;
+	}
+	/* search device name */
+	for (i = 0; i < sizeof(devicetable) / sizeof(devicetable[0]); i++) {
+		if (devicetable[i].deviceid == pcidev->device)
+		{
+			devicename = devicetable[i].devicename;
+			break;
 		}
+	}
+	memset(s, 0, sizeof(struct cm_state));
+	init_waitqueue_head(&s->dma_adc.wait);
+	init_waitqueue_head(&s->dma_dac.wait);
+	init_waitqueue_head(&s->open_wait);
+	init_waitqueue_head(&s->midi.iwait);
+	init_waitqueue_head(&s->midi.owait);
+	init_MUTEX(&s->open_sem);
+	spin_lock_init(&s->lock);
+	s->magic = CM_MAGIC;
+	s->dev = pcidev;
+	s->iobase = pci_resource_start(pcidev, 0);
+	s->iosynth = fmio;
+	s->iomidi = mpuio;
+	s->gameport.io = 0x200;
+	s->status = 0;
+	/* range check */
+	if (speakers < 2)
+		speakers = 2;
+	else if (speakers > 6)
+		speakers = 6;
+	s->speakers = speakers;
+	if (s->iobase == 0)
+		return -ENODEV;
+	s->irq = pcidev->irq;
+
+	if (!request_region(s->iobase, CM_EXTENT_CODEC, "cmpci")) {
+		printk(KERN_ERR "cmpci: io ports %#x-%#x in use\n", s->iobase, s->iobase+CM_EXTENT_CODEC-1);
+		ret = -EBUSY;
+		goto err_region5;
+	}
 #ifdef CONFIG_SOUND_CMPCI_MIDI
-		/* disable MPU-401 */
-		maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~0x04, 0);
-		if (s->iomidi) {
-		    if (!request_region(s->iomidi, CM_EXTENT_MIDI, "cmpci Midi")) {
-			printk(KERN_ERR "cmpci: io ports %#x-%#x in use\n", s->iomidi, s->iomidi+CM_EXTENT_MIDI-1);
+	/* disable MPU-401 */
+	maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~0x04, 0);
+	if (s->iomidi) {
+	    if (!request_region(s->iomidi, CM_EXTENT_MIDI, "cmpci Midi")) {
+		printk(KERN_ERR "cmpci: io ports %#x-%#x in use\n", s->iomidi, s->iomidi+CM_EXTENT_MIDI-1);
+		s->iomidi = 0;
+	    } else {
+		/* set IO based at 0x330 */
+		switch (s->iomidi) {
+		    case 0x330:
+			reg_mask = 0;
+			break;
+		    case 0x320:
+			reg_mask = 0x20;
+			break;
+		    case 0x310:
+			reg_mask = 0x40;
+			break;
+		    case 0x300:
+			reg_mask = 0x60;
+			break;
+		    default:
 			s->iomidi = 0;
-		    } else {
-		        /* set IO based at 0x330 */
-		        switch (s->iomidi) {
-		 	    case 0x330:
-				reg_mask = 0;
-				break;
-			    case 0x320:
-				reg_mask = 0x20;
-				break;
-			    case 0x310:
-				reg_mask = 0x40;
-				break;
-			    case 0x300:
-				reg_mask = 0x60;
-				break;
-			    default:
-				s->iomidi = 0;
-				break;
-		        }
-		        outb((inb(s->iobase + CODEC_CMI_LEGACY_CTRL + 3) & ~0x60) | reg_mask, s->iobase + CODEC_CMI_LEGACY_CTRL + 3);
-			/* enable MPU-401 */
-			if (s->iomidi) {
-			    maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~0, 0x04);
-			}
-		    }
+			break;
 		}
+		outb((inb(s->iobase + CODEC_CMI_LEGACY_CTRL + 3) & ~0x60) | reg_mask, s->iobase + CODEC_CMI_LEGACY_CTRL + 3);
+		/* enable MPU-401 */
+		if (s->iomidi) {
+		    maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~0, 0x04);
+		}
+	    }
+	}
 #endif
 #ifdef CONFIG_SOUND_CMPCI_FM
-		/* disable FM */
-		maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~8, 0);
-		if (s->iosynth) {
-		    if (!request_region(s->iosynth, CM_EXTENT_SYNTH, "cmpci FM")) {
-			printk(KERN_ERR "cmpci: io ports %#x-%#x in use\n", s->iosynth, s->iosynth+CM_EXTENT_SYNTH-1);
+	/* disable FM */
+	maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~8, 0);
+	if (s->iosynth) {
+	    if (!request_region(s->iosynth, CM_EXTENT_SYNTH, "cmpci FM")) {
+		printk(KERN_ERR "cmpci: io ports %#x-%#x in use\n", s->iosynth, s->iosynth+CM_EXTENT_SYNTH-1);
+		s->iosynth = 0;
+	    } else {
+		/* set IO based at 0x388 */
+		switch (s->iosynth) {
+		    case 0x388:
+			reg_mask = 0;
+			break;
+		    case 0x3C8:
+			reg_mask = 0x01;
+			break;
+		    case 0x3E0:
+			reg_mask = 0x02;
+			break;
+		    case 0x3E8:
+			reg_mask = 0x03;
+			break;
+		    default:
 			s->iosynth = 0;
-		    } else {
-		        /* set IO based at 0x388 */
-		        switch (s->iosynth) {
-		 	    case 0x388:
-				reg_mask = 0;
-				break;
-			    case 0x3C8:
-				reg_mask = 0x01;
-				break;
-			    case 0x3E0:
-				reg_mask = 0x02;
-				break;
-			    case 0x3E8:
-				reg_mask = 0x03;
-				break;
-			    default:
-				s->iosynth = 0;
-				break;
-		        }
-		        maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 3, ~0x03, reg_mask);
-		        /* enable FM */
-			if (s->iosynth) {
-		            maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~0, 8);
-			}
-		    }
+			break;
 		}
+		maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 3, ~0x03, reg_mask);
+		/* enable FM */
+		if (s->iosynth) {
+		    maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~0, 8);
+		}
+	    }
+	}
 #endif
-		/* enable joystick */
-		if (joystick)
+	/* enable joystick */
+	if (joystick) {
+		if (s->gameport.io && !request_region(s->gameport.io, CM_EXTENT_GAME, "cmpci GAME")) {
+			printk(KERN_ERR "cmpci: gameport io ports in use\n");
+			s->gameport.io = 0;
+	       	} else
 			maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~0, 0x02);
-		else
-			maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~0x02, 0);
-		/* initialize codec registers */
-		outb(0, s->iobase + CODEC_CMI_INT_HLDCLR + 2);  /* disable ints */
-		outb(0, s->iobase + CODEC_CMI_FUNCTRL0 + 2); /* disable channels */
-		/* reset mixer */
-		wrmixer(s, DSP_MIX_DATARESETIDX, 0);
-
-		/* request irq */
-		if (request_irq(s->irq, cm_interrupt, SA_SHIRQ, "cmpci", s)) {
-			printk(KERN_ERR "cmpci: irq %u in use\n", s->irq);
-			goto err_irq;
-		}
-		printk(KERN_INFO "cmpci: found %s adapter at io %#06x irq %u\n",
-		       devicename, s->iobase, s->irq);
-		/* register devices */
-		if ((s->dev_audio = register_sound_dsp(&cm_audio_fops, -1)) < 0)
-			goto err_dev1;
-		if ((s->dev_mixer = register_sound_mixer(&cm_mixer_fops, -1)) < 0)
-			goto err_dev2;
+	} else {
+		maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~0x02, 0);
+		s->gameport.io = 0;
+	}
+	/* initialize codec registers */
+	outb(0, s->iobase + CODEC_CMI_INT_HLDCLR + 2);  /* disable ints */
+	outb(0, s->iobase + CODEC_CMI_FUNCTRL0 + 2); /* disable channels */
+	/* reset mixer */
+	wrmixer(s, DSP_MIX_DATARESETIDX, 0);
+
+	/* request irq */
+	if ((ret = request_irq(s->irq, cm_interrupt, SA_SHIRQ, "cmpci", s))) {
+		printk(KERN_ERR "cmpci: irq %u in use\n", s->irq);
+		goto err_irq;
+	}
+	printk(KERN_INFO "cmpci: found %s adapter at io %#x irq %u\n",
+	       devicename, s->iobase, s->irq);
+	/* register devices */
+	if ((s->dev_audio = register_sound_dsp(&cm_audio_fops, -1)) < 0) {
+		ret = s->dev_audio;
+		goto err_dev1;
+	}
+	if ((s->dev_mixer = register_sound_mixer(&cm_mixer_fops, -1)) < 0) {
+		ret = s->dev_mixer;
+		goto err_dev2;
+	}
 #ifdef CONFIG_SOUND_CMPCI_MIDI
-		if ((s->dev_midi = register_sound_midi(&cm_midi_fops, -1)) < 0)
-			goto err_dev3;
+	if ((s->dev_midi = register_sound_midi(&cm_midi_fops, -1)) < 0) {
+		ret = s->dev_midi;
+		goto err_dev3;
+	}
 #endif
 #ifdef CONFIG_SOUND_CMPCI_FM
-		if ((s->dev_dmfm = register_sound_special(&cm_dmfm_fops, 15 /* ?? */)) < 0)
-			goto err_dev4;
-#endif
-		pci_set_master(pcidev);	/* enable bus mastering */
-		/* initialize the chips */
-		fs = get_fs();
-		set_fs(KERNEL_DS);
-		/* set mixer output */
-		frobindir(s, DSP_MIX_OUTMIXIDX, 0x1f, 0x1f);
-		/* set mixer input */
-		val = SOUND_MASK_LINE|SOUND_MASK_SYNTH|SOUND_MASK_CD|SOUND_MASK_MIC;
-		mixer_ioctl(s, SOUND_MIXER_WRITE_RECSRC, (unsigned long)&val);
-		for (i = 0; i < sizeof(initvol)/sizeof(initvol[0]); i++) {
-			val = initvol[i].vol;
-			mixer_ioctl(s, initvol[i].mixch, (unsigned long)&val);
-		}
-		/* use channel 0 for record, channel 1 for play */
-		maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~2, 1);
-		s->deviceid = pcidev->device;
-
-		if (pcidev->device == PCI_DEVICE_ID_CMEDIA_CM8738) {
-
-			/* chip version and hw capability check */
-			s->chip_version = query_chip(s);
-			printk(KERN_INFO "cmpci: chip version = 0%d\n", s->chip_version);
-
-			/* seet SPDIF-in inverse before enable SPDIF loop */
-			if (spdif_inverse) {
-				/* turn on spdif-in inverse */
-				maskb(s->iobase + CODEC_CMI_CHFORMAT + 2, ~0, 1);
-				printk(KERN_INFO "cmpci: Inverse SPDIF-in\n");
-			} else {
-				/* turn off spdif-ininverse */
-				maskb(s->iobase + CODEC_CMI_CHFORMAT + 2, ~1, 0);
-			}
-
-			/* enable SPDIF loop */
-			if (spdif_loop) {
-				s->status |= DO_SPDIF_LOOP;
-				/* turn on spdif-in to spdif-out */
-				maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~0, 0x80);
-				printk(KERN_INFO "cmpci: Enable SPDIF loop\n");
-			} else {
-				s->status &= ~DO_SPDIF_LOOP;
-				/* turn off spdif-in to spdif-out */
-				maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~0x80, 0);
-			}
-			if (use_line_as_rear) {
-				s->capability |= CAN_LINE_AS_REAR;
-				s->status |= DO_LINE_AS_REAR;
-				maskb(s->iobase + CODEC_CMI_MIXER1, ~0, 0x20);
+	if ((s->dev_dmfm = register_sound_special(&cm_dmfm_fops, 15 /* ?? */)) < 0) {
+		ret = s->dev_dmfm;
+		goto err_dev4;
+	}
+#endif
+	pci_set_master(pcidev);	/* enable bus mastering */
+	/* initialize the chips */
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+	/* set mixer output */
+	frobindir(s, DSP_MIX_OUTMIXIDX, 0x1f, 0x1f);
+	/* set mixer input */
+	val = SOUND_MASK_LINE|SOUND_MASK_SYNTH|SOUND_MASK_CD|SOUND_MASK_MIC;
+	mixer_ioctl(s, SOUND_MIXER_WRITE_RECSRC, (unsigned long)&val);
+	for (i = 0; i < sizeof(initvol)/sizeof(initvol[0]); i++) {
+		val = initvol[i].vol;
+		mixer_ioctl(s, initvol[i].mixch, (unsigned long)&val);
+	}
+	set_fs(fs);
+	/* use channel 1 for record, channel 0 for play */
+	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~0, CHADC1);
+	/* turn off VMIC3 - mic boost */
+	if (mic_boost)
+		maskb(s->iobase + CODEC_CMI_MIXER2, ~1, 0);
+	else
+		maskb(s->iobase + CODEC_CMI_MIXER2, ~0, 1);
+	s->deviceid = pcidev->device;
+
+	if (pcidev->device == PCI_DEVICE_ID_CMEDIA_CM8738
+	 || pcidev->device == PCI_DEVICE_ID_CMEDIA_CM8738B) {
+
+		/* chip version and hw capability check */
+		s->chip_version = query_chip(s);
+		printk(KERN_INFO "cmpci: chip version = 0%d\n", s->chip_version);
+
+		/* seet SPDIF-in inverse before enable SPDIF loop */
+		set_spdifin_inverse(s, spdif_inverse);
+
+		/* enable SPDIF loop */
+		set_spdif_loop(s, spdif_loop);
+
+		/* use SPDIF in #1 */
+		set_spdifin_channel2(s, 0);
+
+		if (use_line_as_rear) {
+			s->capability |= CAN_LINE_AS_REAR;
+			s->status |= DO_LINE_AS_REAR;
+			maskb(s->iobase + CODEC_CMI_MIXER1, ~0, SPK4);
+		} else
+			maskb(s->iobase + CODEC_CMI_MIXER1, ~SPK4, 0);
+		if (s->chip_version >= 39) {
+			if (use_line_as_bass) {
+				s->capability |= CAN_LINE_AS_BASS;
+				s->status |= DO_LINE_AS_BASS;
+				maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 1, ~0, CB2LIN);
 			} else
-				maskb(s->iobase + CODEC_CMI_MIXER1, ~0x20, 0);
-			if (s->chip_version >= 39) {
-				if (use_line_as_bass) {
-					s->capability |= CAN_LINE_AS_BASS;
-					s->status |= DO_LINE_AS_BASS;
-					maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 1, ~0, 0x60);
-				} else
-					maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 1, ~0x60, 0);
-			}
-		} else {
-			/* 8338 will fall here */
-			s->max_channels = 2;
+				maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 1, ~CB2LIN, 0);
+			if (use_mic_as_bass) {
+				s->capability |= CAN_MIC_AS_BASS;
+				s->status |= DO_MIC_AS_BASS;
+				maskb(s->iobase + CODEC_CMI_MISC, ~0, 0x04);
+			} else
+				maskb(s->iobase + CODEC_CMI_MISC, ~0x04, 0);
 		}
-		/* queue it for later freeing */
-		s->next = devs;
-		devs = s;
-		return;
+	} else {
+		s->chip_version = 0;
+		/* 8338 will fall here */
+		s->max_channels = 2;
+	}
+#ifdef CONFIG_SOUND_CMPCI_JOYSTICK
+	/* register gameport */
+	if (joystick)
+		gameport_register_port(&s->gameport);
+#endif
+	/* store it in the driver field */
+	pci_set_drvdata(pcidev, s);
+	/* put it into driver list */
+	list_add_tail(&s->devs, &devs);
+	/* increment devindex */
+	if (devindex < NR_DEVICE-1)
+		devindex++;
+	return 0;
 
 #ifdef CONFIG_SOUND_CMPCI_FM
-		unregister_sound_special(s->dev_dmfm);
-	err_dev4:
+	unregister_sound_special(s->dev_dmfm);
+err_dev4:
 #endif
 #ifdef CONFIG_SOUND_CMPCI_MIDI
-		unregister_sound_midi(s->dev_midi);
-	err_dev3:
+	unregister_sound_midi(s->dev_midi);
+err_dev3:
+#endif
+	unregister_sound_mixer(s->dev_mixer);
+err_dev2:
+	unregister_sound_dsp(s->dev_audio);
+err_dev1:
+	printk(KERN_ERR "cmpci: cannot register misc device\n");
+	free_irq(s->irq, s);
+err_irq:
+	if (s->gameport.io) {
+#ifdef CONFIG_SOUND_CMPCI_JOYSTICK
+		gameport_unregister_port(&s->gameport);
 #endif
-		unregister_sound_mixer(s->dev_mixer);
-	err_dev2:
-		unregister_sound_dsp(s->dev_audio);
-	err_dev1:
-		printk(KERN_ERR "cmpci: cannot register misc device\n");
-		free_irq(s->irq, s);
-	err_irq:
+		release_region(s->gameport.io, CM_EXTENT_GAME);
+	}
 #ifdef CONFIG_SOUND_CMPCI_FM
-		if (s->iosynth) release_region(s->iosynth, CM_EXTENT_SYNTH);
+	if (s->iosynth) release_region(s->iosynth, CM_EXTENT_SYNTH);
 #endif
 #ifdef CONFIG_SOUND_CMPCI_MIDI
-		if (s->iomidi) release_region(s->iomidi, CM_EXTENT_MIDI);
-#endif
-		release_region(s->iobase, CM_EXTENT_CODEC);
-	err_region5:
-		kfree(s);
-	}
-	if (!devs) {
-		if (wavetable_mem)
-			free_pages(wavetable_mem, 20-PAGE_SHIFT);
-		return;
-	}
-	return;
-}
-
-static int __init init_cmpci(void)
-{
-	struct pci_dev *pcidev = NULL;
-	int index = 0;
-
-#ifdef CONFIG_PCI
-	if (!pci_present())   /* No PCI bus in this machine! */
+	if (s->iomidi) release_region(s->iomidi, CM_EXTENT_MIDI);
 #endif
-		return -ENODEV;
-	printk(KERN_INFO "cmpci: version $Revision: 5.64 $ time " __TIME__ " " __DATE__ "\n");
-
-	while (index < NR_DEVICE && (
-	       (pcidev = pci_find_device(PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8738, pcidev)))) { 
-		initialize_chip(pcidev);
-		index++;
-	}
-	while (index < NR_DEVICE && (
- 	       (pcidev = pci_find_device(PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338A, pcidev)))) {
-		initialize_chip(pcidev);
-		index++;
-	}
-	while (index < NR_DEVICE && (
-	       (pcidev = pci_find_device(PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338B, pcidev)))) {
-		initialize_chip(pcidev);
-		index++;
-	}
-	return 0;
+	release_region(s->iobase, CM_EXTENT_CODEC);
+err_region5:
+	kfree(s);
+	return ret;
 }
 
 /* --------------------------------------------------------------------- */
@@ -3165,42 +3616,77 @@ MODULE_AUTHOR("ChenLi Tien, cltien@cmedi
 MODULE_DESCRIPTION("CM8x38 Audio Driver");
 MODULE_LICENSE("GPL");
 
-
-static void __exit cleanup_cmpci(void)
+static void __devinit cm_remove(struct pci_dev *dev)
 {
-	struct cm_state *s;
+	struct cm_state *s = pci_get_drvdata(dev);
 
-	while ((s = devs)) {
-		devs = devs->next;
-		outb(0, s->iobase + CODEC_CMI_INT_HLDCLR + 2);  /* disable ints */
-		synchronize_irq();
-		outb(0, s->iobase + CODEC_CMI_FUNCTRL0 + 2); /* disable channels */
-		free_irq(s->irq, s);
+	if (!s)
+		return;
+	list_del(&s->devs);
+	outb(0, s->iobase + CODEC_CMI_INT_HLDCLR + 2);  /* disable ints */
+	synchronize_irq();
+	outb(0, s->iobase + CODEC_CMI_FUNCTRL0 + 2); /* disable channels */
+	free_irq(s->irq, s);
 
-		/* reset mixer */
-		wrmixer(s, DSP_MIX_DATARESETIDX, 0);
+	/* reset mixer */
+	wrmixer(s, DSP_MIX_DATARESETIDX, 0);
 
-		release_region(s->iobase, CM_EXTENT_CODEC);
+	if (s->gameport.io) {
+#ifdef CONFIG_SOUND_CMPCI_JOYSTICK
+		gameport_unregister_port(&s->gameport);
+#endif
+		release_region(s->gameport.io, CM_EXTENT_GAME);
+	}
+	release_region(s->iobase, CM_EXTENT_CODEC);
 #ifdef CONFIG_SOUND_CMPCI_MIDI
-		if (s->iomidi) release_region(s->iomidi, CM_EXTENT_MIDI);
+	if (s->iomidi) release_region(s->iomidi, CM_EXTENT_MIDI);
 #endif
 #ifdef CONFIG_SOUND_CMPCI_FM
-		if (s->iosynth) release_region(s->iosynth, CM_EXTENT_SYNTH);
+	if (s->iosynth) release_region(s->iosynth, CM_EXTENT_SYNTH);
 #endif
-		unregister_sound_dsp(s->dev_audio);
-		unregister_sound_mixer(s->dev_mixer);
+	unregister_sound_dsp(s->dev_audio);
+	unregister_sound_mixer(s->dev_mixer);
 #ifdef CONFIG_SOUND_CMPCI_MIDI
-		unregister_sound_midi(s->dev_midi);
+	unregister_sound_midi(s->dev_midi);
 #endif
 #ifdef CONFIG_SOUND_CMPCI_FM
-		unregister_sound_special(s->dev_dmfm);
+	unregister_sound_special(s->dev_dmfm);
 #endif
-		kfree(s);
-	}
-	if (wavetable_mem)
-		free_pages(wavetable_mem, 20-PAGE_SHIFT);
+	kfree(s);
+	pci_set_drvdata(dev, NULL);
+}
+
+static struct pci_device_id id_table[] __devinitdata = {
+	{ PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8738B, PCI_ANY_ID, PCI_ANY_ID, 0, 0 },
+	{ PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8738, PCI_ANY_ID, PCI_ANY_ID, 0, 0 },
+ 	{ PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338A, PCI_ANY_ID, PCI_ANY_ID, 0, 0 },
+	{ PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338B, PCI_ANY_ID, PCI_ANY_ID, 0, 0 },
+	{ 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, id_table);
+
+static struct pci_driver cm_driver = {
+       name: "cmpci",
+       id_table: id_table,
+       probe: cm_probe,
+       remove: cm_remove
+};
+ 
+static int __init init_cmpci(void)
+{
+	if (!pci_present())   /* No PCI bus in this machine! */
+		return -ENODEV;
+	printk(KERN_INFO "cmpci: version $Revision: 6.36 $ time " __TIME__ " " __DATE__ "\n");
+	return pci_module_init(&cm_driver);
+}
+
+static void __exit cleanup_cmpci(void)
+{
 	printk(KERN_INFO "cmpci: unloading\n");
+	pci_unregister_driver(&cm_driver);
 }
 
 module_init(init_cmpci);
 module_exit(cleanup_cmpci);
+
