--- linux-2.4.20/init/main.c.orig	2003-04-02 13:09:17.000000000 -0500
+++ linux-2.4.20/init/main.c	2003-04-02 14:22:01.000000000 -0500
@@ -136,6 +136,8 @@
 extern void time_init(void);
 extern void softirq_init(void);
 
+extern void do_log_buf_swap(void);
+
 int rows, cols;
 
 char *execute_command;
@@ -368,6 +370,7 @@
 	setup_arch(&command_line);
 	printk("Kernel command line: %s\n", saved_command_line);
 	parse_options(command_line);
+	do_log_buf_swap();
 	trap_init();
 	init_IRQ();
 	sched_init();
--- linux-2.4.20/kernel/printk.c.orig	2003-04-02 13:09:16.000000000 -0500
+++ linux-2.4.20/kernel/printk.c	2003-04-02 16:36:13.000000000 -0500
@@ -27,20 +27,24 @@
 #include <linux/interrupt.h>			/* For in_interrupt() */
 #include <linux/config.h>
 #include <linux/delay.h>
+#include <linux/bootmem.h>
 
 #include <asm/uaccess.h>
 
 #if defined(CONFIG_MULTIQUAD) || defined(CONFIG_IA64)
-#define LOG_BUF_LEN	(65536)
-#elif defined(CONFIG_ARCH_S390)
 #define LOG_BUF_LEN	(131072)
+#elif defined(CONFIG_ARCH_S390)
+#define LOG_BUF_LEN	(262144)
 #elif defined(CONFIG_SMP)
-#define LOG_BUF_LEN	(32768)
+#define LOG_BUF_LEN	(65536)
 #else	
-#define LOG_BUF_LEN	(16384)			/* This must be a power of two */
+#define LOG_BUF_LEN	(32768)			/* This must be a power of two */
 #endif
 
-#define LOG_BUF_MASK	(LOG_BUF_LEN-1)
+#define LOG_BUF_MAX_SHIFT       20
+#define LOG_BUF_MAX		(1 << LOG_BUF_MAX_SHIFT)
+
+#define LOG_BUF_MASK		(log_buf_len-1)
 
 #ifndef arch_consoles_callable
 #define arch_consoles_callable() (1)
@@ -79,7 +83,9 @@
  */
 static spinlock_t logbuf_lock = SPIN_LOCK_UNLOCKED;
 
-static char log_buf[LOG_BUF_LEN];
+static char init_log_buf[LOG_BUF_LEN] __initdata = { 0 };
+static char *log_buf = init_log_buf;
+static volatile int log_buf_len = LOG_BUF_LEN;
 #define LOG_BUF(idx) (log_buf[(idx) & LOG_BUF_MASK])
 
 /*
@@ -219,8 +225,8 @@
 		if (error)
 			goto out;
 		count = len;
-		if (count > LOG_BUF_LEN)
-			count = LOG_BUF_LEN;
+		if (count > log_buf_len)
+			count = log_buf_len;
 		spin_lock_irq(&logbuf_lock);
 		if (count > logged_chars)
 			count = logged_chars;
@@ -235,7 +241,7 @@
 		 */
 		for(i=0;i < count;i++) {
 			j = limit-1-i;
-			if (j+LOG_BUF_LEN < log_end)
+			if (j+log_buf_len < log_end)
 				break;
 			c = LOG_BUF(j);
 			spin_unlock_irq(&logbuf_lock);
@@ -321,7 +327,7 @@
 	if (msg_log_level < console_loglevel && console_drivers && start != end) {
 		if ((start & LOG_BUF_MASK) > (end & LOG_BUF_MASK)) {
 			/* wrapped write */
-			__call_console_drivers(start & LOG_BUF_MASK, LOG_BUF_LEN);
+			__call_console_drivers(start & LOG_BUF_MASK, log_buf_len);
 			__call_console_drivers(0, end & LOG_BUF_MASK);
 		} else {
 			__call_console_drivers(start, end);
@@ -384,14 +390,59 @@
 {
 	LOG_BUF(log_end) = c;
 	log_end++;
-	if (log_end - log_start > LOG_BUF_LEN)
-		log_start = log_end - LOG_BUF_LEN;
-	if (log_end - con_start > LOG_BUF_LEN)
-		con_start = log_end - LOG_BUF_LEN;
-	if (logged_chars < LOG_BUF_LEN)
+	if (log_end - log_start > log_buf_len)
+		log_start = log_end - log_buf_len;
+	if (log_end - con_start > log_buf_len)
+		con_start = log_end - log_buf_len;
+	if (logged_chars < log_buf_len)
 		logged_chars++;
 }
 
+
+static int __init log_buf_setup(char *str)
+{
+	int len = simple_strtoul(str, NULL, 0);
+	int i;
+
+	/*
+	 * If specified value is not a power of two, round up
+	 * to the next power of two not exceeding a designated
+	 * maximum value.  Also, don't permit values below the
+	 * default size (i.e., cannot shrink the kernel message
+	 * buffer).
+	 */
+	if (len > LOG_BUF_MAX) {
+	        log_buf_len = LOG_BUF_MAX;
+	        return 1;
+	}
+	if (len < LOG_BUF_LEN) {
+	        return 1;
+	}
+	if ((len & -len) != len) {
+	        for (i = (LOG_BUF_MAX_SHIFT-1); i >= 0; i--) {
+	                if (((1 << i) & len)) {
+				len = 1 << (i+1);
+	                        break;
+	                }
+	        } 
+	}       
+	log_buf_len = len;
+	return 1;
+}       
+
+__setup("log_buf_len=", log_buf_setup);
+
+void do_log_buf_swap(void)
+{
+	char *cp = (char *)alloc_bootmem(log_buf_len);
+	unsigned long flags;
+
+	spin_lock_irqsave(&logbuf_lock, flags);
+	memcpy(cp, log_buf, log_buf_len);
+	log_buf = cp;
+	spin_unlock_irqrestore(&logbuf_lock, flags);
+}
+
 /*
  * This is printk.  It can be called from any context.  We want it to work.
  * 
