diff -urNp linux-5500/fs/dcache.c linux-5510/fs/dcache.c
--- linux-5500/fs/dcache.c
+++ linux-5510/fs/dcache.c
@@ -300,15 +300,19 @@ restart:
 static inline void prune_one_dentry(struct dentry * dentry)
 {
 	struct dentry * parent;
+	struct super_block *sb = dentry->d_sb;
 
 	list_del_init(&dentry->d_hash);
 	list_del(&dentry->d_child);
+	sb->s_prunes++;
 	dentry_iput(dentry);
 	parent = dentry->d_parent;
 	d_free(dentry);
 	if (parent != dentry)
 		dput(parent);
 	spin_lock(&dcache_lock);
+	if (!--sb->s_prunes)
+		wake_up(&sb->s_wait_prunes);
 }
 
 /**
@@ -324,7 +328,7 @@ static inline void prune_one_dentry(stru
  * all the dentries are in use.
  */
  
-void prune_dcache(int count)
+void __prune_dcache(int count, struct super_block *sb)
 {
 	spin_lock(&dcache_lock);
 	for (;;) {
@@ -332,7 +336,19 @@ void prune_dcache(int count)
 		struct list_head *tmp;
 
 		tmp = dentry_unused.prev;
-
+		if (unlikely(sb != NULL)) {
+			/* Try to find a dentry for this sb, but don't try
+			 * too hard, if they aren't near the tail they will
+			 * be moved down again soon.
+			 */
+			int skip = count;
+			while (skip > 0 &&
+			    tmp != &dentry_unused &&
+			    list_entry(tmp, struct dentry, d_lru)->d_sb != sb) {
+				skip--;
+				tmp = tmp->prev;
+			}
+		}
 		if (tmp == &dentry_unused)
 			break;
 		list_del_init(tmp);
@@ -357,6 +373,11 @@ void prune_dcache(int count)
 	spin_unlock(&dcache_lock);
 }
 
+void prune_dcache(int count)
+{
+	__prune_dcache(count, NULL);
+}
+
 /*
  * Shrink the dcache for the specified super block.
  * This allows us to unmount a device without disturbing
@@ -474,9 +495,34 @@ positive:
 }
 
 /*
+ * Wait until there are no pending prunes from prune_one_dentry
+ * Called with, and exits with, dcache_lock locked
+ */
+static void wait_on_prunes(struct super_block *sb)
+{
+	DECLARE_WAITQUEUE(wait, current);
+
+	if (!sb->s_prunes)
+		return;
+
+	add_wait_queue(&sb->s_wait_prunes, &wait);
+
+	while (sb->s_prunes) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		spin_unlock(&dcache_lock);
+		schedule();
+		spin_lock(&dcache_lock);
+	}
+ 
+	remove_wait_queue(&sb->s_wait_prunes, &wait);
+
+	return;
+} 
+
+/*
  * Search the dentry child list for the specified parent,
  * and move any unused dentries to the end of the unused
- * list for prune_dcache(). We descend to the next level
+ * list for prune_dcache().  We descend to the next level
  * whenever the d_subdirs list is non-empty and continue
  * searching.
  */
@@ -487,6 +533,8 @@ static int select_parent(struct dentry *
 	int found = 0;
 
 	spin_lock(&dcache_lock);
+	wait_on_prunes(parent->d_sb);
+
 repeat:
 	next = this_parent->d_subdirs.next;
 resume:
@@ -539,7 +587,7 @@ void shrink_dcache_parent(struct dentry 
 	int found;
 
 	while ((found = select_parent(parent)) != 0)
-		prune_dcache(found);
+		__prune_dcache(found, parent->d_sb);
 }
 
 /*
diff -urNp linux-5500/fs/super.c linux-5510/fs/super.c
--- linux-5500/fs/super.c
+++ linux-5510/fs/super.c
@@ -306,6 +306,8 @@ static struct super_block *alloc_super(v
 		s->dq_op = sb_dquot_ops;
 		s->s_qcop = sb_quotactl_ops;
 		s->s_op = &empty_sops;
+		s->s_prunes = 0;
+		init_waitqueue_head(&s->s_wait_prunes);
 	}
 	return s;
 }
diff -urNp linux-5500/include/linux/fs.h linux-5510/include/linux/fs.h
--- linux-5500/include/linux/fs.h
+++ linux-5510/include/linux/fs.h
@@ -820,6 +820,10 @@ struct super_block {
 	 * non-directories) are allowed, but not unconnected diretories.
 	 */
 	struct semaphore s_nfsd_free_path_sem;
+#ifndef __GENKSYMS__ /* preserve KMI/ABI ksyms compatibility for mod linkage */
+	wait_queue_head_t s_wait_prunes; 
+	int s_prunes;
+#endif
 };
 
 /*
