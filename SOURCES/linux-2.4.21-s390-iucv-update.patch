diff -urNp linux-462/drivers/s390/net/iucv.c linux-463/drivers/s390/net/iucv.c
--- linux-462/drivers/s390/net/iucv.c
+++ linux-463/drivers/s390/net/iucv.c
@@ -1,5 +1,5 @@
 /* 
- * $Id: iucv.c,v 1.39 2003/02/14 15:45:15 felfert Exp $
+ * $Id: iucv.c,v 1.40.2.5 2004/06/29 07:37:33 braunu Exp $
  *
  * IUCV network driver
  *
@@ -29,7 +29,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * RELEASE-TAG: IUCV lowlevel driver $Revision: 1.39 $
+ * RELEASE-TAG: IUCV lowlevel driver $Revision: 1.40.2.5 $
  *
  */
 
@@ -89,6 +89,8 @@ static iucv_GeneralInterrupt *iucv_exter
 
 static spinlock_t iucv_lock = SPIN_LOCK_UNLOCKED;
 
+static int messagesDisabled = 0;
+
 /***************INTERRUPT HANDLING ***************/
 
 typedef struct {
@@ -338,7 +340,7 @@ do { \
 static void
 iucv_banner(void)
 {
-	char vbuf[] = "$Revision: 1.39 $";
+	char vbuf[] = "$Revision: 1.40.2.5 $";
 	char *version = vbuf;
 
 	if ((version = strchr(version, ':'))) {
@@ -413,9 +415,12 @@ iucv_init(void)
  *
  * Frees everything allocated from iucv_init.
  */
+static int iucv_retrieve_buffer (void);
+
 static void
 iucv_exit(void)
 {
+	iucv_retrieve_buffer();
 	if (iucv_external_int_buffer)
 		kfree(iucv_external_int_buffer);
 	if (iucv_param_pool)
@@ -436,17 +441,19 @@ iucv_exit(void)
 static __inline__ iucv_param *
 grab_param(void)
 {
-	iucv_param *ret;
-	int i = 0;
+	iucv_param *ptr;
+        static int hint = 0;
 
-	while (atomic_compare_and_swap(0, 1, &iucv_param_pool[i].in_use)) {
-		i++;
-		if (i >= PARAM_POOL_SIZE)
-			i = 0;
-	}
-	ret = &iucv_param_pool[i];
-	memset(&ret->param, 0, sizeof(ret->param));
-	return ret;
+	ptr = iucv_param_pool + hint;
+	do {
+		ptr++;
+		if (ptr >= iucv_param_pool + PARAM_POOL_SIZE)
+			ptr = iucv_param_pool;
+	} while (atomic_compare_and_swap(0, 1, &ptr->in_use));
+	hint = ptr - iucv_param_pool;
+
+	memset(&ptr->param, 0, sizeof(ptr->param));
+	return ptr;
 }
 
 /**
@@ -610,7 +617,7 @@ iucv_declare_buffer_cpu0 (void *result)
  * Unregister IUCV usage at VM. This is always executed on CPU 0.
  * Called from iucv_retrieve_buffer().
  */
-void
+static void
 iucv_retrieve_buffer_cpu0 (void *result)
 {
 	iparml_control *parm;
@@ -652,7 +659,7 @@ iucv_declare_buffer (void)
  * Terminates all use of IUCV.
  * Returns: return code from CP
  */
-int
+static int
 iucv_retrieve_buffer (void)
 {
 	iucv_debug(1, "entering");
@@ -686,7 +693,6 @@ iucv_remove_handler(handler *handler)
 	spin_lock_irqsave (&iucv_lock, flags);
 	list_del(&handler->list);
 	if (list_empty(&iucv_handler_table)) {
-		iucv_retrieve_buffer();
 		if (register_flag) {
 			unregister_external_interrupt(0x4000, iucv_irq_handler);
 			register_flag = 0;
@@ -762,6 +768,7 @@ iucv_register_program (__u8 pgmname[16],
 		if (iucv_pathid_table == NULL) {
 			printk(KERN_WARNING "%s: iucv_pathid_table storage "
 			       "allocation failed\n", __FUNCTION__);
+			kfree(new_handler);
 			return NULL;
 		}
 		memset (iucv_pathid_table, 0, max_connections * sizeof(handler *));
@@ -1128,7 +1135,8 @@ iucv_connect (__u16 *pathid, __u16 msgli
 	 */
 
 	/* Enable everything but IUCV Control messages */
-	iucv_setmask(~(IUCVControlInterruptsFlag));
+	iucv_setmask(~(AllInterrupts));
+	messagesDisabled = 1;
 
 	parm->ipflags1 = (__u8)flags1;
 	b2f0_result = b2f0(CONNECT, parm);
@@ -1138,6 +1146,7 @@ iucv_connect (__u16 *pathid, __u16 msgli
 
 	if (b2f0_result) {
 		iucv_setmask(~0);
+		messagesDisabled = 0;
 		return b2f0_result;
 	}
 
@@ -1145,7 +1154,7 @@ iucv_connect (__u16 *pathid, __u16 msgli
 	*pathid = parm->ippathid;
 
 	/* Enable everything again */
-	iucv_setmask(~0);
+	iucv_setmask(IUCVControlInterruptsFlag);
 
 	if (msglim)
 		*msglim = parm->ipmsglim;
@@ -2305,6 +2314,10 @@ iucv_do_int(iucv_GeneralInterrupt * int_
 	/* end of if statement */
 	switch (int_buf->iptype) {
 		case 0x01:		/* connection pending */
+			if (messagesDisabled) {
+			    iucv_setmask(~0);
+			    messagesDisabled = 0;
+			}
 			spin_lock_irqsave(&iucv_lock, flags);
 			list_for_each(lh, &iucv_handler_table) {
 				h = list_entry(lh, handler, list);
@@ -2325,7 +2338,8 @@ iucv_do_int(iucv_GeneralInterrupt * int_
 					iucv_debug(2,
 						   "found a matching handler");
 					break;
-				}
+				} else
+					h = NULL;
 			}
 			spin_unlock_irqrestore (&iucv_lock, flags);
 			if (h) {
@@ -2353,6 +2367,10 @@ iucv_do_int(iucv_GeneralInterrupt * int_
 			break;
 			
 		case 0x02:		/*connection complete */
+			if (messagesDisabled) {
+			    iucv_setmask(~0);
+			    messagesDisabled = 0;
+			}
 			if (h) {
 				if (interrupt->ConnectionComplete)
 				{
@@ -2368,6 +2386,10 @@ iucv_do_int(iucv_GeneralInterrupt * int_
 			break;
 			
 		case 0x03:		/* connection severed */
+			if (messagesDisabled) {
+			    iucv_setmask(~0);
+			    messagesDisabled = 0;
+			}
 			if (h) {
 				if (interrupt->ConnectionSevered)
 					interrupt->ConnectionSevered(
@@ -2381,6 +2403,10 @@ iucv_do_int(iucv_GeneralInterrupt * int_
 			break;
 			
 		case 0x04:		/* connection quiesced */
+			if (messagesDisabled) {
+			    iucv_setmask(~0);
+			    messagesDisabled = 0;
+			}
 			if (h) {
 				if (interrupt->ConnectionQuiesced)
 					interrupt->ConnectionQuiesced(
@@ -2393,6 +2419,10 @@ iucv_do_int(iucv_GeneralInterrupt * int_
 			break;
 			
 		case 0x05:		/* connection resumed */
+			if (messagesDisabled) {
+			    iucv_setmask(~0);
+			    messagesDisabled = 0;
+			}
 			if (h) {
 				if (interrupt->ConnectionResumed)
 					interrupt->ConnectionResumed(
diff -urNp linux-462/drivers/s390/net/iucv.h linux-463/drivers/s390/net/iucv.h
--- linux-462/drivers/s390/net/iucv.h
+++ linux-463/drivers/s390/net/iucv.h
@@ -63,6 +63,7 @@
 #define Nonpriority_MessageCompletionInterruptsFlag      0x20
 #define Priority_MessageCompletionInterruptsFlag         0x10
 #define IUCVControlInterruptsFlag                        0x08
+#define AllInterrupts                                    0xf8
 
 /*
  * Mapping of external interrupt buffers should be used with the corresponding
diff -urNp linux-462/drivers/s390/net/netiucv.c linux-463/drivers/s390/net/netiucv.c
--- linux-462/drivers/s390/net/netiucv.c
+++ linux-463/drivers/s390/net/netiucv.c
@@ -1,5 +1,5 @@
 /*
- * $Id: netiucv.c,v 1.21 2002/12/09 18:40:44 mschwide Exp $
+ * $Id: netiucv.c,v 1.21.8.6 2004/06/29 07:37:33 braunu Exp $
  *
  * IUCV network driver
  *
@@ -28,7 +28,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * RELEASE-TAG: IUCV network driver $Revision: 1.21 $
+ * RELEASE-TAG: IUCV network driver $Revision: 1.21.8.5 $
  *
  */
 
@@ -114,7 +114,6 @@ typedef struct iucv_connection_t {
 	spinlock_t               collect_lock;
 	int                      collect_len;
 	int                      max_buffsize;
-	int                      flags;
 	fsm_timer                timer;
 	int                      retry;
 	fsm_instance             *fsm;
@@ -123,8 +122,6 @@ typedef struct iucv_connection_t {
 	char                     userid[9];
 } iucv_connection;
 
-#define CONN_FLAGS_BUFSIZE_CHANGED 1
-
 /**
  * Linked list of all connection structs.
  */
@@ -590,7 +587,7 @@ conn_action_rx(fsm_instance *fi, int eve
 	iucv_MessagePending *eib = (iucv_MessagePending *)ev->data;
 	netiucv_priv *privptr = (netiucv_priv *)conn->netdev->priv;
 
-	__u16 msglen = eib->ln1msg2.ipbfln1f;
+	__u32 msglen = eib->ln1msg2.ipbfln1f;
 	int rc;
 
 #ifdef DEBUG
@@ -613,6 +610,7 @@ conn_action_rx(fsm_instance *fi, int eve
 			  conn->rx_buff->data, msglen, NULL, NULL, NULL);
 	if (rc != 0 || msglen < 5) {
 		privptr->stats.rx_errors++;
+		printk(KERN_INFO "iucv_receive returned %08x\n", rc);
 		return;
 	}
 	netiucv_unpack_skb(conn, conn->rx_buff);
@@ -693,7 +691,7 @@ conn_action_txdone(fsm_instance *fi, int
 			fsm_newstate(fi, CONN_STATE_IDLE);
 			if (privptr)
 				privptr->stats.tx_errors += txpackets;
-			printk(KERN_DEBUG "iucv_send returned %08x\n",
+			printk(KERN_INFO "iucv_send returned %08x\n",
 			       rc);
 		} else {
 			if (privptr) {
@@ -1019,6 +1017,7 @@ static void
 dev_action_connup(fsm_instance *fi, int event, void *arg)
 {
 	net_device   *dev = (net_device *)arg;
+	netiucv_priv *privptr = (netiucv_priv *)dev->priv;
 
 #ifdef DEBUG
 	printk(KERN_DEBUG "%s() called\n", __FUNCTION__);
@@ -1027,8 +1026,8 @@ dev_action_connup(fsm_instance *fi, int 
 		case DEV_STATE_STARTWAIT:
 			fsm_newstate(fi, DEV_STATE_RUNNING);
 			printk(KERN_INFO
-			       "%s: connected with remote side\n",
-			       dev->name);
+			       "%s: connected with remote side %s\n",
+			       dev->name, privptr->conn->userid);
 			break;
 		case DEV_STATE_STOPWAIT:
 			printk(KERN_INFO
@@ -1417,7 +1416,6 @@ netiucv_buffer_write(struct file *file, 
 	privptr->conn->max_buffsize = bs1;
 	if (!(dev->flags & IFF_RUNNING))
 		dev->mtu = bs1 - NETIUCV_HDRLEN - NETIUCV_HDRLEN;
-	privptr->conn->flags |= CONN_FLAGS_BUFSIZE_CHANGED;
 
 	return count;
 }
@@ -2039,7 +2037,7 @@ netiucv_free_netdevice(net_device *dev)
 static void
 netiucv_banner(void)
 {
-	char vbuf[] = "$Revision: 1.21 $";
+	char vbuf[] = "$Revision: 1.21.8.5 $";
 	char *version = vbuf;
 
 	if ((version = strchr(version, ':'))) {
