diff -urNp linux-8155/drivers/addon/lpfc/Makefile linux-8156/drivers/addon/lpfc/Makefile
--- linux-8155/drivers/addon/lpfc/Makefile
+++ linux-8156/drivers/addon/lpfc/Makefile
@@ -21,4 +21,6 @@ obj-y:= lpfc_clock.o 		\
 	lpfc_scsiport.o		\
 	lpfc_sli.o
 
+subdir-$(CONFIG_SCSI_LPFC) += lpfcdfc
+
 include $(TOPDIR)/Rules.make
diff -urNp linux-8155/drivers/addon/lpfc/lpfcdfc/ChangeLog linux-8156/drivers/addon/lpfc/lpfcdfc/ChangeLog
--- linux-8155/drivers/addon/lpfc/lpfcdfc/ChangeLog
+++ linux-8156/drivers/addon/lpfc/lpfcdfc/ChangeLog
@@ -0,0 +1,34 @@
+Changes from 20060106 to 20060328:
+
+	* Changed version to 1.2.3
+	* Fixed system hang/panic while executing
+	  lpfc_ioctl_hba_fcptargetmapping function (CR 19692)
+
+Changes from 20050503 to 20060106:
+
+	* Changed version to 1.2.2.
+	* Fixed a panic found during 7.3.2 driver testing.
+	* Fixed lpfc_ioctl_hba_getevent() to return correct number of events.
+
+Changes from 20050401 to 20050503:
+
+	* Changed version to 1.2.1.
+	* Updated copyright messages.
+	* Added printk of copyright string at driver load.
+
+Changes from 1.1.1 to 20050401:
+
+	* Changed version to 1.2.0.
+
+Changes from 1.0.13 to 1.1.1:
+
+	* Changed version to 1.1.1.
+	* Added INC_TOP definition for dkms module support.
+	* Removed code wrapped by USE_SCHEDULER and IPFC definitions.
+	* Removed references to IPFC in Makefile.
+	* Removed references to KERNEL_VERSION(2,6,0) macro.
+	* Changed lpfc_ioctl_port_attributes to examine nlp_type rather
+	  than nlp_flags.
+	* Corrected link speeds.
+	* Added VPD support.
+	* Reworked IssueMbox error codes.
diff -urNp linux-8155/drivers/addon/lpfc/lpfcdfc/Makefile linux-8156/drivers/addon/lpfc/lpfcdfc/Makefile
--- linux-8155/drivers/addon/lpfc/lpfcdfc/Makefile
+++ linux-8156/drivers/addon/lpfc/lpfcdfc/Makefile
@@ -0,0 +1,19 @@
+#
+# Makefile for the LPFCDFC driver
+#
+#
+
+O_TARGET := lpfcdfc.o
+EXTRA_CFLAGS += -I$(TOPDIR)/drivers/scsi -I../
+obj-m:= $(O_TARGET)
+
+obj-y:= lpfc_cdev.o		\
+	lpfc_util_ioctl.o	\
+	lpfc_hbaapi_ioctl.o	\
+	lpfc_debug_ioctl.o	\
+	lpfc_logmsg.o
+
+lpfc_logmsg.c:
+	ln -sf ../lpfc_logmsg.c lpfc_logmsg.c
+
+include $(TOPDIR)/Rules.make
diff -urNp linux-8155/drivers/addon/lpfc/lpfcdfc/lpfc_cdev.c linux-8156/drivers/addon/lpfc/lpfcdfc/lpfc_cdev.c
--- linux-8155/drivers/addon/lpfc/lpfcdfc/lpfc_cdev.c
+++ linux-8156/drivers/addon/lpfc/lpfcdfc/lpfc_cdev.c
@@ -0,0 +1,335 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_cdev.c 328 2005-05-03 15:20:43Z sf_support $
+ */
+
+#ifndef EXPORT_SYMTAB
+#define EXPORT_SYMTAB
+#endif
+#include <linux/version.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/blk.h>
+#include <linux/utsname.h>
+#include <linux/pci.h>
+#include <linux/timer.h>
+#include <linux/if_arp.h>
+#include <linux/spinlock.h>
+
+/* From drivers/scsi */
+#include <sd.h>
+#include <hosts.h>
+#include <scsi.h>
+#include <linux/ctype.h>
+
+#include "lpfcdfc_version.h"
+#include "lpfc_version.h"
+#include "lpfc_hw.h"
+#include "lpfc_sli.h"
+#include "lpfc_mem.h"
+#include "lpfc_sched.h"
+#include "lpfc_disc.h"
+#include "lpfc.h"
+#include "lpfc_logmsg.h"
+#include "lpfc_scsi.h"
+#include "lpfc_dfc.h"
+#include "lpfc_diag.h"
+#if defined(CONFIG_PPC64) || defined(CONFIG_X86_64)
+extern int sys_ioctl(unsigned int, unsigned int, unsigned long);
+extern int register_ioctl32_conversion(unsigned int cmd,
+				       int (*handler)(unsigned int,
+						      unsigned int,
+						      unsigned long,
+						      struct file *));
+extern int unregister_ioctl32_conversion(unsigned int cmd);
+#endif
+#include "lpfc_ioctl.h"
+
+#include <linux/rtnetlink.h>
+#include <asm/byteorder.h>
+#include <linux/module.h>
+
+/* Configuration parameters defined */
+#define LPFC_DEF_ICFG
+#include "lpfc_cfgparm.h"
+#include "lpfc_module_param.h"
+#include "lpfc.conf"
+#include "lpfc_compat.h"
+#include "lpfc_crtn.h"
+#include "lpfc_util_ioctl.h"
+#include "lpfc_hbaapi_ioctl.h"
+#include "lpfc_debug_ioctl.h"
+
+typedef int (*LPFC_IOCTL_FN)(lpfcHBA_t *, LPFCCMDINPUT_t *);
+
+extern lpfcDRVR_t lpfcDRVR;
+extern char* lpfc_release_version;
+
+int lpfc_diag_init(void);
+int lpfc_diag_uninit(void);
+static int lpfc_major = 0;
+
+/* A chrdev is used for diagnostic interface */
+int lpfcdiag_ioctl(struct inode *inode, struct file *file,
+		   unsigned int cmd, unsigned long arg);
+
+static struct file_operations lpfc_fops = {
+	.owner = THIS_MODULE,
+	.ioctl = lpfcdiag_ioctl,
+};
+
+#define LPFCDFC_DRIVER_NAME "lpfcdfc"
+
+int
+lpfc_diag_init(void)
+{
+	int result;
+	result = register_chrdev(lpfc_major, LPFCDFC_DRIVER_NAME, &lpfc_fops);
+	if (result < 0)
+		return (result);
+	if (lpfc_major == 0)
+		lpfc_major = result;	/* dynamic */
+	return (0);
+}
+
+int
+lpfc_diag_uninit(void)
+{
+	if (lpfc_major) {
+		unregister_chrdev(lpfc_major, LPFCDFC_DRIVER_NAME);
+		lpfc_major = 0;
+	}
+	return (0);
+}
+
+struct ioctls_registry_entry {
+	struct list_head list;
+	LPFC_IOCTL_FN lpfc_ioctl_fn;
+};
+
+struct ioctls_registry_entry lpfc_ioctls_registry = {
+	.list = LIST_HEAD_INIT(lpfc_ioctls_registry.list)
+};
+
+int
+reg_ioctl_entry(LPFC_IOCTL_FN fn)
+{
+	struct ioctls_registry_entry *new_lpfc_ioctls_registry_entry =
+	    kmalloc(sizeof (struct ioctls_registry_entry), GFP_KERNEL);
+	if (new_lpfc_ioctls_registry_entry == 0)
+		return -ENOMEM;
+	new_lpfc_ioctls_registry_entry->lpfc_ioctl_fn = fn;
+	if (fn != 0) {
+		list_add(&(new_lpfc_ioctls_registry_entry->list),
+			 &(lpfc_ioctls_registry.list));
+	}
+	return 0;
+}
+
+int
+unreg_ioctl_entry(LPFC_IOCTL_FN fn)
+{
+	struct list_head *p, *n;
+	struct ioctls_registry_entry *entry;
+
+	list_for_each_safe(p, n, &(lpfc_ioctls_registry.list)) {
+		entry = list_entry(p, struct ioctls_registry_entry, list);
+		if (entry->lpfc_ioctl_fn == fn) {
+			list_del(p);
+			kfree(entry);
+			break;
+		}
+	}
+	return 0;
+}
+
+void
+unreg_all_ioctl_entries(void)
+{
+	struct list_head *p,*n;
+	struct ioctls_registry_entry *entry;
+
+	list_for_each_safe(p, n, &(lpfc_ioctls_registry.list)) {
+		entry = list_entry(p, struct ioctls_registry_entry, list);
+		list_del(p);
+		kfree(entry);
+	}
+	return ;
+}
+
+int
+lpfcdiag_ioctl(struct inode *inode,
+	       struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int rc = EINVAL, fd;
+	lpfcHBA_t *phba;
+	LPFCCMDINPUT_t *ci;
+	unsigned long iflag;
+	struct list_head *p;
+	struct ioctls_registry_entry *entry;
+
+	if (!arg)
+		return (-EINVAL);
+
+	ci = (LPFCCMDINPUT_t *) kmalloc(sizeof (LPFCCMDINPUT_t), GFP_ATOMIC);
+
+	if (!ci)
+		return (-ENOMEM);
+
+	if (copy_from_user
+	    ((uint8_t *) ci, (uint8_t *) arg, sizeof (LPFCCMDINPUT_t))) {
+		kfree(ci);
+		return (-EIO);
+	}
+
+	fd = ci->lpfc_brd;
+	if (fd >= lpfcDRVR.num_devs) {
+		kfree(ci);
+		return (-EINVAL);
+	}
+
+	if ((phba = lpfc_get_phba_by_inst(fd)) == NULL) {
+		kfree(ci);
+		return (-EINVAL);
+	}
+
+        
+	if ( phba->reset_pending) {
+		kfree(ci);
+		return(-ENODEV);
+	}
+
+
+	LPFC_DRVR_LOCK(phba, iflag);
+	list_for_each(p, &(lpfc_ioctls_registry.list)) {
+		entry = list_entry(p, struct ioctls_registry_entry, list);
+		if (entry->lpfc_ioctl_fn) {
+			rc = entry->lpfc_ioctl_fn(phba, ci);
+			if (rc != -1)
+				break;	/* This IOCTL has been serviced. Do not
+					 bother to pass it to the ohter entries in
+					 the registry */
+		}
+	}
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	kfree(ci);
+	return (-rc);
+}
+#if defined(CONFIG_PPC64) || defined(CONFIG_X86_64)
+int
+lpfc_ioctl32_handler(unsigned int fd, unsigned int cmd, unsigned long arg, struct file *file)
+{
+	LPFCCMDINPUT32_t arg32;
+	LPFCCMDINPUT_t arg64;
+	mm_segment_t old_fs;
+	int ret;
+
+	if(copy_from_user(&arg32, (void*)arg, sizeof(LPFCCMDINPUT32_t)))
+		return -EFAULT;
+
+
+	arg64.lpfc_brd = arg32.lpfc_brd;
+	arg64.lpfc_ring = arg32.lpfc_ring;
+	arg64.lpfc_iocb = arg32.lpfc_iocb;
+	arg64.lpfc_flag = arg32.lpfc_flag;
+	arg64.lpfc_arg1 = (void*)(unsigned long) arg32.lpfc_arg1;
+	arg64.lpfc_arg2 = (void *)(unsigned long)arg32.lpfc_arg2;
+	arg64.lpfc_arg3 = (void *)(unsigned long) arg32.lpfc_arg3;
+	arg64.lpfc_dataout = (void *)(unsigned long) arg32.lpfc_dataout;
+	arg64.lpfc_cmd = arg32.lpfc_cmd;
+	arg64.lpfc_outsz = arg32.lpfc_outsz;
+	arg64.lpfc_arg4 = arg32.lpfc_arg4;
+	arg64.lpfc_arg5 = arg32.lpfc_arg5;
+	arg64.lpfc_cntl = arg32.lpfc_cntl;
+	
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	ret = sys_ioctl(fd, LPFC_DFC_CMD_IOCTL , (unsigned long)&arg64);
+	set_fs(old_fs);
+	
+	
+	arg32.lpfc_brd = arg64.lpfc_brd;
+	arg32.lpfc_ring = arg64.lpfc_ring;
+	arg32.lpfc_iocb = arg64.lpfc_iocb;
+	arg32.lpfc_flag = arg64.lpfc_flag;
+	arg32.lpfc_arg1 = (u32)(unsigned long)(arg64.lpfc_arg1);
+	arg32.lpfc_arg2 = (u32)(unsigned long)(arg64.lpfc_arg2);
+	arg32.lpfc_arg3 = (u32)(unsigned long) (arg64.lpfc_arg3);
+	arg32.lpfc_dataout = (u32)(unsigned long) (arg64.lpfc_dataout);
+	arg32.lpfc_cmd = arg64.lpfc_cmd;
+	arg32.lpfc_outsz = arg64.lpfc_outsz;
+	arg32.lpfc_arg4 = arg64.lpfc_arg4;
+	arg32.lpfc_arg5 = arg64.lpfc_arg5;
+	arg32.lpfc_cntl = arg64.lpfc_cntl;
+
+	if(copy_to_user((void*)arg, &arg32, sizeof(LPFCCMDINPUT32_t)))
+		return -EFAULT;
+
+	return ret;
+}
+#endif
+static int __init
+lpfc_cdev_init(void)
+{
+	printk(LPFCDFC_MODULE_DESC "\n");
+	printk(LPFCDFC_COPYRIGHT "\n");
+
+	if (strcmp(lpfc_release_version, LPFC_DRIVER_VERSION) != 0) {
+		printk("lpfcdfc requires lpfc version %s.  Current version is %s.\n",
+		       LPFC_DRIVER_VERSION, lpfc_release_version);
+		return -ENODEV;
+	}
+
+	if(unlikely(reg_ioctl_entry(lpfc_process_ioctl_util) != 0)) goto errexit;
+	if(unlikely(reg_ioctl_entry(lpfc_process_ioctl_hbaapi) != 0)) goto errexit;
+	if(unlikely(reg_ioctl_entry(lpfc_process_ioctl_dfc) != 0)) goto errexit;
+	if(unlikely(lpfc_diag_init()!=0 )) goto errexit;
+#if defined(CONFIG_PPC64) || defined(CONFIG_X86_64)
+	if(register_ioctl32_conversion(LPFC_DFC_CMD_IOCTL32, lpfc_ioctl32_handler) !=0) goto errexit;
+#endif
+	return 0;
+
+	errexit:
+	unreg_all_ioctl_entries();
+	return -ENODEV;		
+}
+
+static void __exit
+lpfc_cdev_exit(void)
+{
+	unreg_ioctl_entry(lpfc_process_ioctl_util);
+	unreg_ioctl_entry(lpfc_process_ioctl_hbaapi);
+	unreg_ioctl_entry(lpfc_process_ioctl_dfc);
+	lpfc_diag_uninit();
+#if defined(CONFIG_PPC64) || defined(CONFIG_X86_64)
+	unregister_ioctl32_conversion(LPFC_DFC_CMD_IOCTL32);
+#endif
+}
+
+module_init(lpfc_cdev_init);
+module_exit(lpfc_cdev_exit);
+
+MODULE_DESCRIPTION("Emulex LightPulse Fibre Channel driver IOCTL support");
+MODULE_AUTHOR("Emulex Corporation - tech.support@emulex.com");
+MODULE_LICENSE("GPL");
diff -urNp linux-8155/drivers/addon/lpfc/lpfcdfc/lpfc_debug_ioctl.c linux-8156/drivers/addon/lpfc/lpfcdfc/lpfc_debug_ioctl.c
--- linux-8155/drivers/addon/lpfc/lpfcdfc/lpfc_debug_ioctl.c
+++ linux-8156/drivers/addon/lpfc/lpfcdfc/lpfc_debug_ioctl.c
@@ -0,0 +1,1192 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_debug_ioctl.c 328 2005-05-03 15:20:43Z sf_support $
+ */
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/blkdev.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/unistd.h>
+#include <linux/timex.h>
+#include <linux/timer.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/irq.h>
+#include <sd.h>			/* From drivers/scsi */
+#include <hosts.h>
+
+#include "lpfc_hw.h"
+#include "lpfc_sli.h"
+#include "lpfc_mem.h"
+#include "lpfc_sched.h"
+#include "lpfc_disc.h"
+#include "lpfc.h"
+#include "lpfc_logmsg.h"
+#include "lpfc_fcp.h"
+#include "lpfc_scsi.h"
+#include "lpfc_diag.h"
+#include "lpfc_ioctl.h"
+#include "lpfc_diag.h"
+#include "lpfc_crtn.h"
+#include "lpfc_cfgparm.h"
+#include "lpfc_debug_ioctl.h"
+
+extern lpfcDRVR_t lpfcDRVR;
+
+int
+lpfc_process_ioctl_dfc(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip)
+{
+
+	int rc = -1;
+	uint32_t outshift;
+	uint32_t total_mem;
+	struct dfc_info *di;
+	void   *dataout;
+	unsigned long iflag;
+        
+	extern struct dfc dfc;
+
+	di = &dfc.dfc_info[cip->lpfc_brd];
+	/* dfc_ioctl entry */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk1600,	/* ptr to msg structure */
+		lpfc_mes1600,			/* ptr to msg */
+		lpfc_msgBlk1600.msgPreambleStr,	/* begin varargs */
+		cip->lpfc_cmd,
+		(ulong) cip->lpfc_arg1,
+		(ulong) cip->lpfc_arg2,
+		cip->lpfc_outsz);		/* end varargs */
+
+	outshift = 0;
+	if (cip->lpfc_outsz >= 4096) {
+
+		/* Allocate memory for ioctl data. If buffer is bigger than 64k, then we
+		 * allocate 64k and re-use that buffer over and over to xfer the whole 
+		 * block. This is because Linux kernel has a problem allocating more than
+		 * 120k of kernel space memory. Saw problem with GET_FCPTARGETMAPPING...
+		 */
+		if (cip->lpfc_outsz <= (64 * 1024))
+			total_mem = cip->lpfc_outsz;
+		else
+			total_mem = 64 * 1024;		
+	} else {
+		/* Allocate memory for ioctl data */
+		total_mem = 4096;
+	}
+
+
+	dataout = kmalloc(total_mem, GFP_ATOMIC);
+	if (!dataout)
+		return (ENOMEM);
+
+	di->fc_refcnt++;
+	switch (cip->lpfc_cmd) {
+
+	/* Debug Interface Support - dfc */
+	case LPFC_LIP:
+		rc = lpfc_ioctl_lip(phba, cip, dataout);
+		break;
+
+	case LPFC_RESET_QDEPTH:
+		rc = lpfc_reset_dev_q_depth(phba);
+		break;
+
+	case LPFC_OUTFCPIO:
+		rc = lpfc_ioctl_outfcpio(phba, cip, dataout);
+		break;
+
+	case LPFC_SEND_ELS:
+		rc = lpfc_ioctl_send_els(phba, cip);
+		break;
+
+	case LPFC_INST:
+		rc = lpfc_ioctl_inst(phba, cip, dataout);
+		break;
+
+	case LPFC_READ_BPLIST:
+		rc = lpfc_ioctl_read_bplist(phba, cip, dataout, total_mem);
+		break;
+
+	case LPFC_LISTN:
+		rc = lpfc_ioctl_listn(phba, cip, dataout, total_mem);
+		break;
+
+	case LPFC_RESET:
+		rc = lpfc_ioctl_reset(phba, cip);
+		break;
+
+	case LPFC_READ_HBA:
+		rc = lpfc_ioctl_read_hba(phba, cip, dataout, total_mem);
+		break;
+
+	case LPFC_STAT:
+		rc = lpfc_ioctl_stat(phba, cip, dataout);
+		break;
+
+	case LPFC_DEVP:
+		rc = lpfc_ioctl_devp(phba, cip, dataout);
+		break;
+	}
+
+	di->fc_refcnt--;
+
+	/* dfc_ioctl exit */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk1601,	/* ptr to msg structure */
+		lpfc_mes1601,			/* ptr to msg */
+		lpfc_msgBlk1601.msgPreambleStr,	/* begin varargs */
+		rc,
+		cip->lpfc_outsz,
+		(uint32_t) ((ulong) cip->lpfc_dataout));	/* end varargs */
+
+
+	/* Copy data to user space config method */
+	if (rc == 0) {
+		if (cip->lpfc_outsz) {
+			LPFC_DRVR_UNLOCK(phba, iflag);
+			if (copy_to_user
+			    ((uint8_t *) cip->lpfc_dataout,
+			     (uint8_t *) dataout, (int)cip->lpfc_outsz)) {
+				rc = EIO;
+			}
+			LPFC_DRVR_LOCK(phba, iflag);
+		}
+	}
+
+	kfree(dataout);
+	return(rc);
+}
+
+int
+lpfc_ioctl_lip(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip, void *dataout)
+{
+	LPFC_SLI_t *psli;
+	LPFC_SLI_RING_t *pring;
+	lpfcCfgParam_t *clp;
+	LPFC_MBOXQ_t *pmboxq;
+	int mbxstatus;
+	int i, rc;
+	unsigned long iflag;
+
+	clp = &phba->config[0];
+	psli = &phba->sli;
+
+	rc = 0;
+
+	mbxstatus = MBXERR_ERROR;
+	if (phba->hba_state == LPFC_HBA_READY) {
+
+		if ((pmboxq = lpfc_mbox_alloc(phba, MEM_PRI)) == 0) {
+			return ENOMEM;
+		}
+
+		/* The HBA is reporting ready.  Pause the scheduler so that
+		 * all outstanding I/Os complete before LIPing.
+		 */
+		lpfc_sched_pause_hba(phba);
+
+		i = 0;
+		pring = &psli->ring[psli->fcp_ring];
+		while (pring->txcmplq_cnt) {
+			if (i++ > 500) {	/* wait up to 5 seconds */
+				break;
+			}
+
+			LPFC_DRVR_UNLOCK(phba, iflag);
+			mdelay(10);
+			LPFC_DRVR_LOCK(phba, iflag);
+		}
+		memset((void *)pmboxq, 0, sizeof (LPFC_MBOXQ_t));
+		lpfc_init_link(phba, pmboxq, clp[LPFC_CFG_TOPOLOGY].a_current,
+			       clp[LPFC_CFG_LINK_SPEED].a_current);
+
+		mbxstatus =
+		    lpfc_sli_issue_mbox_wait(phba, pmboxq, phba->fc_ratov * 2);
+		if (mbxstatus == MBX_TIMEOUT) {
+			/*
+			 * Let SLI layer to release mboxq if mbox command completed after timeout.
+			 */
+			pmboxq->mbox_cmpl = 0;
+		} else {
+			lpfc_mbox_free(phba, pmboxq);
+		}
+
+		lpfc_sched_continue_hba(phba);
+	}
+
+	memcpy(dataout, (char *)&mbxstatus, sizeof (uint16_t));
+
+	return (rc);
+}
+
+int
+copy_sli_info(dfcsli_t * pdfcsli, LPFC_SLI_t * psli)
+{
+	int i, j;
+
+	for (i = 0; i < LPFC_MAX_RING; ++i) {
+		for (j = 0; j < LPFC_MAX_RING_MASK; ++j) {
+			pdfcsli->sliinit.ringinit[i].prt[j].rctl =
+				psli->sliinit.ringinit[i].prt[j].rctl;
+			pdfcsli->sliinit.ringinit[i].prt[j].type =
+				psli->sliinit.ringinit[i].prt[j].type;
+		}
+		pdfcsli->sliinit.ringinit[i].num_mask =
+			psli->sliinit.ringinit[i].num_mask;
+		pdfcsli->sliinit.ringinit[i].iotag_ctr =
+			psli->sliinit.ringinit[i].iotag_ctr;
+		pdfcsli->sliinit.ringinit[i].numCiocb =
+			psli->sliinit.ringinit[i].numCiocb;
+		pdfcsli->sliinit.ringinit[i].numRiocb =
+			psli->sliinit.ringinit[i].numRiocb;
+	}
+	pdfcsli->sliinit.num_rings = psli->sliinit.num_rings;
+	pdfcsli->sliinit.sli_flag = psli->sliinit.sli_flag;
+	pdfcsli->MBhostaddr.addrlo =
+		(uint64_t)((unsigned long)psli->MBhostaddr) & 0xffffffff;
+	pdfcsli->MBhostaddr.addrhi =
+		(uint64_t)((unsigned long)psli->MBhostaddr) >> 32;
+	for (i = 0; i < LPFC_MAX_RING; ++i) {
+		pdfcsli->ring[i].rspidx = psli->ring[i].rspidx;
+		pdfcsli->ring[i].cmdidx = psli->ring[i].cmdidx;
+		pdfcsli->ring[i].txq_cnt = psli->ring[i].txq_cnt;
+		pdfcsli->ring[i].txq_max = psli->ring[i].txq_max;
+		pdfcsli->ring[i].txcmplq_cnt = psli->ring[i].txcmplq_cnt;
+		pdfcsli->ring[i].txcmplq_max = psli->ring[i].txcmplq_max;
+		pdfcsli->ring[i].cmdringaddr.addrlo =
+			(uint64_t)((unsigned long)psli->ring[i].cmdringaddr)
+			& 0xffffffff;
+		pdfcsli->ring[i].cmdringaddr.addrhi =
+			(uint64_t)((unsigned long)psli->ring[i].cmdringaddr)
+			>> 32;
+		pdfcsli->ring[i].rspringaddr.addrlo =
+			(uint64_t)((unsigned long)psli->ring[i].rspringaddr)
+			& 0xffffffff;
+		pdfcsli->ring[i].rspringaddr.addrhi =
+			(uint64_t)((unsigned long)psli->ring[i].rspringaddr)
+			>> 32;
+		pdfcsli->ring[i].missbufcnt = psli->ring[i].missbufcnt;
+		pdfcsli->ring[i].postbufq_cnt = psli->ring[i].postbufq_cnt;
+		pdfcsli->ring[i].postbufq_max = psli->ring[i].postbufq_max;
+	}
+	pdfcsli->mboxq_cnt = psli->mboxq_cnt;
+	pdfcsli->mboxq_max = psli->mboxq_max;
+	for (i = 0; i < LPFC_MAX_RING; ++i) {
+		pdfcsli->slistat.iocbEvent[i].lo =
+			(uint64_t)((unsigned long)psli->slistat.iocbEvent[i])
+			& 0xffffffff;
+		pdfcsli->slistat.iocbEvent[i].hi =
+			(uint64_t)((unsigned long)psli->slistat.iocbEvent[i])
+			>> 32;
+		pdfcsli->slistat.iocbCmd[i].lo =
+			(uint64_t)((unsigned long)psli->slistat.iocbCmd[i])
+			& 0xffffffff;
+		pdfcsli->slistat.iocbCmd[i].hi =
+			(uint64_t)((unsigned long)psli->slistat.iocbCmd[i])
+			>> 32;
+		pdfcsli->slistat.iocbRsp[i].lo =
+			(uint64_t)((unsigned long)psli->slistat.iocbRsp[i])
+			& 0xffffffff;
+		pdfcsli->slistat.iocbRsp[i].hi =
+			(uint64_t)((unsigned long)psli->slistat.iocbRsp[i])
+			>> 32;
+		pdfcsli->slistat.iocbCmdFull[i].lo =
+			(uint64_t)((unsigned long)psli->slistat.iocbCmdFull[i])
+			& 0xffffffff;
+		pdfcsli->slistat.iocbCmdFull[i].hi =
+			(uint64_t)((unsigned long)psli->slistat.iocbCmdFull[i])
+			>> 32;
+		pdfcsli->slistat.iocbCmdEmpty[i].lo =
+			(uint64_t)((unsigned long)psli->slistat.iocbCmdEmpty[i])
+			& 0xffffffff;
+		pdfcsli->slistat.iocbCmdEmpty[i].hi =
+			(uint64_t)((unsigned long)psli->slistat.iocbCmdEmpty[i])
+			>> 32;
+		pdfcsli->slistat.iocbRspFull[i].lo =
+			(uint64_t)((unsigned long)psli->slistat.iocbRspFull[i])
+			& 0xffffffff;
+		pdfcsli->slistat.iocbRspFull[i].hi =
+			(uint64_t)((unsigned long)psli->slistat.iocbRspFull[i])
+			>> 32;
+	}
+	pdfcsli->slistat.mboxStatErr.lo =
+		(uint64_t)((unsigned long)psli->slistat.mboxStatErr)
+		& 0xffffffff;
+	pdfcsli->slistat.mboxStatErr.hi =
+		(uint64_t)((unsigned long)psli->slistat.mboxStatErr)
+		>> 32;
+	pdfcsli->slistat.mboxCmd.lo =
+		(uint64_t)((unsigned long)psli->slistat.mboxCmd)
+		& 0xffffffff;
+	pdfcsli->slistat.mboxCmd.hi =
+		(uint64_t)((unsigned long)psli->slistat.mboxCmd)
+		>> 32;
+	pdfcsli->slistat.sliIntr.lo =
+		(uint64_t)((unsigned long)psli->slistat.sliIntr)
+		& 0xffffffff;
+	pdfcsli->slistat.sliIntr.hi =
+		(uint64_t)((unsigned long)psli->slistat.sliIntr)
+		>> 32;
+	pdfcsli->slistat.errAttnEvent = psli->slistat.errAttnEvent;
+	pdfcsli->slistat.linkEvent = psli->slistat.linkEvent;
+	pdfcsli->fcp_ring = (uint32_t)psli->fcp_ring;
+	return (0);
+}
+
+int
+lpfc_ioctl_outfcpio(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip, void *dataout)
+{
+	LPFCSCSILUN_t *lunp;
+	LPFCSCSITARGET_t *targetp;
+	LPFC_SCSI_BUF_t *lpfc_cmd;
+	LPFC_SLI_RING_t *pring;
+	LPFC_IOCBQ_t *iocb;
+	LPFC_IOCBQ_t *next_iocb;
+	IOCB_t *cmd;
+	uint32_t tgt, lun;
+	struct out_fcp_devp *dp;
+	int max;
+	LPFC_SLI_t *psli;
+	dfcsli_t *pdfcsli;
+	int rc = 0;
+	uint64_t count = 0;
+	struct list_head *curr, *next;
+	struct list_head *curr_lun, *next_lun;
+	psli = &phba->sli;
+	pring = &psli->ring[psli->fcp_ring];
+
+	pdfcsli = (dfcsli_t*) dataout;
+	copy_sli_info(pdfcsli, psli);
+
+	dp = (struct out_fcp_devp *)(pdfcsli + 1);
+	max = cip->lpfc_outsz - sizeof (LPFC_SLI_t);
+	max = (max / sizeof (struct out_fcp_devp));
+
+	for (tgt = 0; tgt < MAX_FCP_TARGET; tgt++) {
+		if ((targetp = phba->device_queue_hash[tgt])) {
+			list_for_each_safe(curr_lun, next_lun, &targetp->lunlist) {
+				lunp = list_entry(curr_lun, LPFCSCSILUN_t , list);
+				lun = lunp->lun_id;
+				if (count++ >= max)
+					goto outio;
+
+				dp->target = tgt;
+				dp->lun = (ushort) lun;
+
+				dp->qcmdcnt = lunp->qcmdcnt;
+				dp->iodonecnt = lunp->iodonecnt;
+				dp->errorcnt = lunp->errorcnt;
+
+				dp->tx_count = 0;
+				dp->txcmpl_count = 0;
+				dp->delay_count = 0;
+
+				dp->sched_count =
+				    lunp->lunSched.q_cnt;
+				dp->lun_qdepth = lunp->lunSched.maxOutstanding;
+				dp->current_qdepth =
+				    lunp->lunSched.currentOutstanding;
+
+				/* Error matching iocb on txq or txcmplq 
+				 * First check the txq.
+				 */
+				list_for_each_safe(curr, next, &pring->txq) {
+					next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+					iocb = next_iocb;
+					cmd = &iocb->iocb;
+
+					/* Must be a FCP command */
+					if ((cmd->ulpCommand !=
+					     CMD_FCP_ICMND64_CR)
+					    && (cmd->ulpCommand !=
+						CMD_FCP_IWRITE64_CR)
+					    && (cmd->ulpCommand !=
+						CMD_FCP_IREAD64_CR)) {
+						continue;
+					}
+
+					/* context1 MUST be a LPFC_SCSI_BUF_t */
+					lpfc_cmd =
+					    (LPFC_SCSI_BUF_t *) (iocb->context1);
+					if ((lpfc_cmd == 0)
+					    || (lpfc_cmd->scsi_target != tgt)
+					    || (lpfc_cmd->scsi_lun != lun)) {
+						continue;
+					}
+					dp->tx_count++;
+				}
+
+				/* Next check the txcmplq */
+				list_for_each_safe(curr, next, &pring->txcmplq) {
+					next_iocb = list_entry(curr, LPFC_IOCBQ_t, list);
+					iocb = next_iocb;
+					cmd = &iocb->iocb;
+
+					/* Must be a FCP command */
+					if ((cmd->ulpCommand !=
+					     CMD_FCP_ICMND64_CR)
+					    && (cmd->ulpCommand !=
+						CMD_FCP_IWRITE64_CR)
+					    && (cmd->ulpCommand !=
+						CMD_FCP_IREAD64_CR)) {
+						continue;
+					}
+
+					/* context1 MUST be a LPFC_SCSI_BUF_t */
+					lpfc_cmd =
+					    (LPFC_SCSI_BUF_t *) (iocb->context1);
+					if ((lpfc_cmd == 0)
+					    || (lpfc_cmd->scsi_target != tgt)
+					    || (lpfc_cmd->scsi_lun != lun)) {
+						continue;
+					}
+
+					dp->txcmpl_count++;
+				}
+				dp++;
+
+			}
+		}
+	}
+      outio:
+	/* Use sliIntr to count number of out_fcp_devp entries */
+	pdfcsli->slistat.sliIntr.lo = count & 0xffffffff;
+	pdfcsli->slistat.sliIntr.hi = count >> 32;
+
+	cip->lpfc_outsz = (sizeof (LPFC_SLI_t) +
+			  (count * sizeof (struct out_fcp_devp)));
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_send_els(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip)
+{
+
+	uint32_t did;
+	uint32_t opcode;
+	LPFC_BINDLIST_t *blp;
+	LPFC_NODELIST_t *pndl;
+	int rc = 0;
+
+	did = (ulong) cip->lpfc_arg1;
+	opcode = (ulong) cip->lpfc_arg2;
+	did = (did & Mask_DID);
+
+	if (((pndl = lpfc_findnode_did(phba, NLP_SEARCH_ALL, did))) == 0) {
+		if ((pndl = lpfc_nlp_alloc(phba, 0))) {
+			memset((void *)pndl, 0, sizeof (LPFC_NODELIST_t));
+			pndl->nlp_DID = did;
+			pndl->nlp_state = NLP_STE_UNUSED_NODE;
+			blp = pndl->nlp_listp_bind;
+			if (blp) {
+				lpfc_nlp_bind(phba, blp);
+			}
+		} else {
+			rc = ENOMEM;
+			return (rc);
+		}
+	}
+
+	switch (opcode) {
+	case ELS_CMD_PLOGI:
+		lpfc_issue_els_plogi(phba, pndl, 0);
+		break;
+	case ELS_CMD_LOGO:
+		lpfc_issue_els_logo(phba, pndl, 0);
+		break;
+	case ELS_CMD_ADISC:
+		lpfc_issue_els_adisc(phba, pndl, 0);
+		break;
+	default:
+		break;
+	}
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_inst(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip, void *dataout)
+{
+	struct list_head *pos;
+	int *p_int;
+	int rc = 0;
+
+	p_int = dataout;
+
+	/* Store the number of devices */
+	*p_int++ = (int)lpfcDRVR.num_devs;
+	/* Store instance number of each device */
+	list_for_each(pos, &lpfcDRVR.hba_list_head) {
+		phba = list_entry(pos, lpfcHBA_t, hba_list);
+		*p_int++ = phba->brd_no;
+	}
+
+
+	return (rc);
+}
+
+int
+copy_node_list(dfcnodelist_t *pdfcndl, LPFC_NODELIST_t *pndl)
+{
+	pdfcndl->nlp_failMask = pndl->nlp_failMask;
+	pdfcndl->nlp_type = pndl->nlp_type;
+	pdfcndl->nlp_rpi = pndl->nlp_rpi;
+	pdfcndl->nlp_state = pndl->nlp_state;
+	pdfcndl->nlp_xri = pndl->nlp_xri;
+	pdfcndl->nlp_flag = pndl->nlp_flag;
+	pdfcndl->nlp_DID = pndl->nlp_DID;
+	pdfcndl->nlp_oldDID = pndl->nlp_oldDID;
+	memcpy(pdfcndl->nlp_portname,
+	       (uint8_t *)&(pndl->nlp_portname),
+	       sizeof(pdfcndl->nlp_portname));
+	memcpy(pdfcndl->nlp_nodename,
+	       (uint8_t *)&(pndl->nlp_nodename),
+	       sizeof(pdfcndl->nlp_nodename));
+	pdfcndl->nlp_sid = pndl->nlp_sid;
+
+	return (sizeof (dfcnodelist_t));
+}
+
+int
+lpfc_ioctl_listn(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip,  void *dataout, int size)
+{
+
+	dfcbindlist_t   *bpp;
+	LPFC_BINDLIST_t *blp;
+	dfcnodelist_t   *npp;
+	LPFC_NODELIST_t *pndl;
+	struct list_head *pos;
+	uint32_t offset;
+	uint32_t lcnt;
+	uint32_t *lcntp;
+	int rc = 0;
+	uint32_t total_mem = size;
+
+	offset = (ulong) cip->lpfc_arg1;
+	/* If the value of offset is 1, the driver is handling
+	 * the bindlist.  Correct the total memory to account for the 
+	 * bindlist's different size 
+	 */
+	if (offset == 1) {
+		total_mem -= sizeof (LPFC_BINDLIST_t);
+	} else {
+		total_mem -= sizeof (LPFC_NODELIST_t);
+	}
+
+	lcnt = 0;
+	switch (offset) {
+	case 1:		/* bind */
+		lcntp = dataout;
+		memcpy(dataout, (uint8_t *) & lcnt, sizeof (uint32_t));
+		bpp =
+		    (dfcbindlist_t *) ((uint8_t *) (dataout) +
+					 sizeof (uint32_t));
+
+		list_for_each(pos, &phba->fc_nlpbind_list) {
+			if (total_mem <= 0)
+				break;
+			blp = list_entry(pos, LPFC_BINDLIST_t, nlp_listp);
+
+			memcpy(bpp->nlp_portname,
+			       (uint8_t *)&(blp->nlp_portname),
+			       sizeof(bpp->nlp_portname));
+			memcpy(bpp->nlp_nodename,
+			       (uint8_t *)&(blp->nlp_nodename),
+			       sizeof(bpp->nlp_nodename));
+			bpp->nlp_bind_type = blp->nlp_bind_type;
+			bpp->nlp_sid = blp->nlp_sid;
+			bpp->nlp_DID = blp->nlp_DID;
+			total_mem -= sizeof (dfcbindlist_t);
+			bpp++;
+			lcnt++;
+		}
+		*lcntp = lcnt;
+		break;
+	case 2:		/* unmap */
+		lcntp = dataout;
+		memcpy(dataout, (uint8_t *) & lcnt, sizeof (uint32_t));
+		npp = (dfcnodelist_t *) ((uint8_t *) (dataout) + sizeof (uint32_t));
+		list_for_each(pos, &phba->fc_nlpunmap_list) {
+			if (total_mem <= 0)
+				break;
+			pndl = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			total_mem -= copy_node_list(npp, pndl);
+			npp++;
+			lcnt++;
+		}
+		*lcntp = lcnt;
+		break;
+	case 3:		/* map */
+		lcntp = dataout;
+		memcpy(dataout, (uint8_t *) & lcnt, sizeof (uint32_t));
+		npp = (dfcnodelist_t *) ((uint8_t *) (dataout) + sizeof (uint32_t));
+		list_for_each(pos, &phba->fc_nlpmap_list) {
+			if (total_mem <= 0)
+				break;
+			pndl = list_entry(pos, LPFC_NODELIST_t, nlp_listp);		
+			total_mem -= copy_node_list(npp, pndl);
+			npp++;
+			lcnt++;   
+		}
+		*lcntp = lcnt;
+		break;
+	case 4:		/* plogi */
+		lcntp = dataout;
+		memcpy(dataout, (uint8_t *) & lcnt, sizeof (uint32_t));
+		npp = (dfcnodelist_t *) ((uint8_t *) (dataout) + sizeof (uint32_t));
+		
+		list_for_each(pos, &phba->fc_plogi_list) {
+			if (total_mem <= 0)
+				break;
+			pndl = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			total_mem -= copy_node_list(npp, pndl);
+			npp++;
+			lcnt++;
+		}
+		*lcntp = lcnt;
+		break;
+	case 5:		/* adisc */
+		lcntp = dataout;
+		memcpy(dataout, (uint8_t *) & lcnt, sizeof (uint32_t));
+		npp = (dfcnodelist_t *) ((uint8_t *) (dataout) + sizeof (uint32_t));
+		
+		list_for_each(pos, &phba->fc_adisc_list) {
+			if (total_mem <= 0)
+				break;
+			pndl = list_entry(pos, LPFC_NODELIST_t, nlp_listp);		
+			total_mem -= copy_node_list(npp, pndl);
+			npp++;
+			lcnt++;
+		}
+		*lcntp = lcnt;
+		break;
+	case 6:		/* all except bind list */
+		lcntp = dataout;
+		memcpy(dataout, (uint8_t *) & lcnt, sizeof (uint32_t));
+		npp =
+		    (dfcnodelist_t *) ((uint8_t *) (dataout) +
+					 sizeof (uint32_t));
+
+		list_for_each(pos, &phba->fc_plogi_list) {
+			if (total_mem <= 0)
+				break;
+			pndl = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			total_mem -= copy_node_list(npp, pndl);
+			npp++;
+			lcnt++;
+		}
+
+		list_for_each(pos, &phba->fc_adisc_list) {
+			if (total_mem <= 0)
+				break;
+			pndl = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			total_mem -= copy_node_list(npp, pndl);
+			npp++;
+			lcnt++;
+		}
+
+		list_for_each(pos, &phba->fc_nlpunmap_list) {
+			if (total_mem <= 0)
+				break;
+			pndl = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			total_mem -= copy_node_list(npp, pndl);
+			npp++;
+			lcnt++;
+		}
+
+		list_for_each(pos, &phba->fc_nlpmap_list) {
+			if (total_mem <= 0)
+				break;
+			pndl = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			total_mem -= copy_node_list(npp, pndl);
+			npp++;
+			lcnt++;
+		}
+		*lcntp = lcnt;
+		break;
+	default:
+		rc = ERANGE;
+		break;
+	}
+	cip->lpfc_outsz = (sizeof (uint32_t) + (lcnt * sizeof (LPFC_NODELIST_t)));
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_read_bplist(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip, 
+		       void *dataout, int size)
+{
+	LPFC_SLI_RING_t *rp;
+	struct list_head *dlp;
+	DMABUF_t *mm;
+	uint32_t *lptr;
+	LPFC_SLI_t *psli;
+	int rc = 0;
+	struct list_head *pos;
+	uint32_t total_mem = size;
+
+	psli = &phba->sli;
+	rp = &psli->ring[LPFC_ELS_RING];	/* RING 0 */
+	dlp = &rp->postbufq;
+	lptr = (uint32_t *) dataout;
+	total_mem -= (3 * sizeof (uint32_t));
+
+	list_for_each(pos, &rp->postbufq) {
+		if (total_mem <= 0)
+			break;
+		mm = list_entry(pos, DMABUF_t, list);
+		if ((cip->lpfc_ring == LPFC_ELS_RING)
+		    || (cip->lpfc_ring == LPFC_FCP_NEXT_RING)) {
+			*lptr++ = (uint32_t) ((ulong) mm);
+			*lptr++ = (uint32_t) ((ulong) mm->virt);
+			*lptr++ = (uint32_t) ((ulong) mm->phys);
+		}
+		total_mem -= (3 * sizeof (uint32_t));
+	}
+	*lptr++ = 0;
+
+	cip->lpfc_outsz = ((uint8_t *) lptr - (uint8_t *) (dataout));
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_reset(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip)
+{
+	uint32_t status;
+	uint32_t offset;
+	LPFC_SLI_t *psli;
+	int rc = 0;
+
+	psli = &phba->sli;
+	offset = (ulong) cip->lpfc_arg1;
+	switch (offset) {
+	case 1:		/* hba */
+		phba->hba_state = 0;	/* Don't skip post */
+		lpfc_sli_brdreset(phba);
+		phba->hba_state = LPFC_INIT_START;
+		mdelay(2500);
+		/* Read the HBA Host Status Register */
+		status = readl(phba->HSregaddr);
+		break;
+
+	case 3:		/* target */
+		lpfc_fcp_abort(phba, TARGET_RESET, (long)cip->lpfc_arg2, -1);
+		break;
+	case 4:		/* lun */
+		lpfc_fcp_abort(phba, LUN_RESET, (long)cip->lpfc_arg2,
+			       (long)cip->lpfc_arg3);
+		break;
+	case 5:		/* task set */
+		lpfc_fcp_abort(phba, ABORT_TASK_SET,
+			       (long)cip->lpfc_arg2, (long)cip->lpfc_arg3);
+		break;
+	case 6:		/* bus */
+		lpfc_fcp_abort(phba, BUS_RESET, -1, -1);
+		break;
+
+	default:
+		rc = ERANGE;
+		break;
+	}
+	return (rc);
+}
+
+int
+copy_hba_info(void *dataout, lpfcHBA_t * phba)
+{
+	dfchba_t * pdfchba;
+
+	pdfchba = (dfchba_t*)dataout;
+
+	pdfchba->hba_state = phba->hba_state;
+	pdfchba->cmnds_in_flight = atomic_read(&(phba->cmnds_in_flight));
+	pdfchba->fc_busflag = phba->fc_busflag;
+	pdfchba->hbaSched.targetCount = phba->hbaSched.targetCount;
+	pdfchba->hbaSched.maxOutstanding = phba->hbaSched.maxOutstanding;
+	pdfchba->hbaSched.currentOutstanding = phba->hbaSched.currentOutstanding;
+	pdfchba->hbaSched.status = phba->hbaSched.status;
+	copy_sli_info(&pdfchba->sli, &phba->sli);
+	return (0);
+}
+
+int
+copy_stat_info(void *dataout, lpfcHBA_t * phba)
+{
+	dfcstats_t * pdfcstat;
+	pdfcstat = (dfcstats_t*)dataout;
+
+	pdfcstat->elsRetryExceeded = phba->fc_stat.elsRetryExceeded;
+	pdfcstat->elsXmitRetry = phba->fc_stat.elsXmitRetry;
+	pdfcstat->elsRcvDrop = phba->fc_stat.elsRcvDrop;
+	pdfcstat->elsRcvFrame = phba->fc_stat.elsRcvFrame;
+	pdfcstat->elsRcvRSCN = phba->fc_stat.elsRcvRSCN;
+	pdfcstat->elsRcvRNID = phba->fc_stat.elsRcvRNID;
+	pdfcstat->elsRcvFARP = phba->fc_stat.elsRcvFARP;
+	pdfcstat->elsRcvFARPR = phba->fc_stat.elsRcvFARPR;
+	pdfcstat->elsRcvFLOGI = phba->fc_stat.elsRcvFLOGI;
+	pdfcstat->elsRcvPLOGI = phba->fc_stat.elsRcvPLOGI;
+	pdfcstat->elsRcvADISC = phba->fc_stat.elsRcvADISC;
+	pdfcstat->elsRcvPDISC = phba->fc_stat.elsRcvPDISC;
+	pdfcstat->elsRcvFAN = phba->fc_stat.elsRcvFAN;
+	pdfcstat->elsRcvLOGO = phba->fc_stat.elsRcvLOGO;
+	pdfcstat->elsRcvPRLO = phba->fc_stat.elsRcvPRLO;
+	pdfcstat->elsRcvPRLI = phba->fc_stat.elsRcvPRLI;
+	pdfcstat->elsRcvRRQ = phba->fc_stat.elsRcvRRQ;
+	pdfcstat->frameRcvBcast = phba->fc_stat.frameRcvBcast;
+	pdfcstat->frameRcvMulti = phba->fc_stat.frameRcvMulti;
+	pdfcstat->strayXmitCmpl = phba->fc_stat.strayXmitCmpl;
+	pdfcstat->frameXmitDelay = phba->fc_stat.frameXmitDelay;
+	pdfcstat->xriCmdCmpl = phba->fc_stat.xriCmdCmpl;
+	pdfcstat->xriStatErr = phba->fc_stat.xriStatErr;
+	pdfcstat->LinkUp = phba->fc_stat.LinkUp;
+	pdfcstat->LinkDown = phba->fc_stat.LinkDown;
+	pdfcstat->LinkMultiEvent = phba->fc_stat.LinkMultiEvent;
+	pdfcstat->NoRcvBuf = phba->fc_stat.NoRcvBuf;
+	pdfcstat->fcpCmd = phba->fc_stat.fcpCmd;
+	pdfcstat->fcpCmpl = phba->fc_stat.fcpCmpl;
+	pdfcstat->fcpRspErr = phba->fc_stat.fcpRspErr;
+	pdfcstat->fcpRemoteStop = phba->fc_stat.fcpRemoteStop;
+	pdfcstat->fcpPortRjt = phba->fc_stat.fcpPortRjt;
+	pdfcstat->fcpPortBusy = phba->fc_stat.fcpPortBusy;
+	pdfcstat->fcpError = phba->fc_stat.fcpError;
+	return(0);
+}
+
+int
+lpfc_ioctl_read_hba(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip, void *dataout, int size)
+{
+
+	LPFC_SLI_t *psli;
+	int rc = 0;
+	int cnt = 0;
+	unsigned long iflag;
+	void* psavbuf = 0;
+
+	psli = &phba->sli;
+	if (cip->lpfc_arg1) {
+
+		if (psli->sliinit.sli_flag & LPFC_SLI2_ACTIVE) {
+
+			/* The SLIM2 size is stored in the next field.  We cannot exceed
+			 * the size of the dataout buffer so if it's not big enough we need
+			 * to allocate a temp buffer.
+			 */
+			cnt = phba->slim_size;
+			if (cnt > size) {
+				psavbuf = dataout;
+				dataout = kmalloc(cnt, GFP_ATOMIC);
+				if (!dataout)
+					return (ENOMEM);
+			}
+		} else {
+			cnt = 4096;
+		}
+
+		if (psli->sliinit.sli_flag & LPFC_SLI2_ACTIVE) {
+			/* copy results back to user */
+			lpfc_sli_pcimem_bcopy((uint32_t *) psli->MBhostaddr,
+					     (uint32_t *) dataout, cnt);
+		} else {
+			/* First copy command data */
+			lpfc_memcpy_from_slim( dataout, phba->MBslimaddr, cnt);
+		}
+
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		if (copy_to_user
+		    ((uint8_t *) cip->lpfc_arg1, (uint8_t *) dataout,
+		     cnt)) {
+			rc = EIO;
+		}
+		LPFC_DRVR_LOCK(phba, iflag);
+		if (psavbuf) {
+			kfree(dataout);
+			dataout = psavbuf;
+			psavbuf = 0;
+		}
+		if (rc)
+			return (rc);
+	}
+	copy_hba_info(dataout, phba);
+	return (rc);
+}
+
+int
+lpfc_ioctl_stat(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip, void *dataout)
+{
+	int rc = 0;
+
+	if ((ulong) cip->lpfc_arg1 == 1) {
+		copy_hba_info(dataout, phba);
+	}
+
+	/* Copy LPFC_STAT_t */
+	if ((ulong) cip->lpfc_arg1 == 2) {
+		copy_stat_info(dataout, phba);
+	}
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_devp(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip, void *dataout)
+{
+	uint32_t offset, cnt;
+	LPFCSCSILUN_t *dev_ptr;
+	LPFC_NODELIST_t *pndl;
+	LPFCSCSITARGET_t *node_ptr;
+	int rc = 0;
+	int i;
+	struct list_head *curr, *next;
+
+	cnt = 0;
+	offset = (ulong) cip->lpfc_arg1;
+	cnt = (ulong) cip->lpfc_arg2;
+	if ((offset >= (MAX_FCP_TARGET)) || (cnt >= 128)) {
+		rc = ERANGE;
+		return (rc);
+	}
+	node_ptr = 0;
+	dev_ptr = 0;
+	pndl = 0;
+	memset(dataout, 0,
+	       (sizeof (LPFCSCSITARGET_t) + sizeof (LPFCSCSILUN_t) +
+		sizeof (LPFC_NODELIST_t)));
+	rc = ENODEV;
+	node_ptr = phba->device_queue_hash[offset];
+	if (node_ptr) {
+		dfcscsitarget_t dfc_node;
+
+		rc = 0;
+		dfc_node.context.addrlo = (uint64_t)((unsigned long)node_ptr->pcontext) & 0xffffffff;
+		dfc_node.context.addrhi = (uint64_t)((unsigned long)node_ptr->pcontext) >> 32;
+		dfc_node.targetSched.lunCount = node_ptr->targetSched.lunCount;
+		dfc_node.targetSched.maxOutstanding = node_ptr->targetSched.maxOutstanding;
+		dfc_node.targetSched.currentOutstanding = node_ptr->targetSched.currentOutstanding;
+		dfc_node.targetSched.status = node_ptr->targetSched.status;
+		dfc_node.max_lun = node_ptr->max_lun;
+		dfc_node.scsi_id = node_ptr->scsi_id;
+		dfc_node.targetFlags = node_ptr->targetFlags;
+		dfc_node.addrMode = node_ptr->addrMode;
+		dfc_node.rptLunState = node_ptr->rptLunState;
+
+		cip->lpfc_outsz = sizeof (dfcscsitarget_t);
+		memcpy((uint8_t *) dataout, (uint8_t *) &dfc_node,
+		       (sizeof(dfcscsitarget_t)));
+
+		list_for_each_safe(curr, next, &node_ptr->lunlist) {
+			dev_ptr = list_entry(curr, LPFCSCSILUN_t, list);
+			if (dev_ptr->lun_id == (uint64_t) cnt)
+				break;
+		}
+		if (dev_ptr) {
+			dfcscsilun_t dfc_dev;
+
+			dfc_dev.lun_id.lo =
+				(uint64_t)((unsigned long)dev_ptr->lun_id)
+				& 0xffffffff;
+			dfc_dev.lun_id.hi =
+				(uint64_t)((unsigned long)dev_ptr->lun_id)
+				>> 32;
+			dfc_dev.lunSched.maxOutstanding = dev_ptr->lunSched.maxOutstanding;
+			dfc_dev.lunSched.currentOutstanding = dev_ptr->lunSched.currentOutstanding;
+			dfc_dev.lunSched.status = dev_ptr->lunSched.status;
+			dfc_dev.lunFlag = dev_ptr->lunFlag;
+			dfc_dev.failMask = dev_ptr->failMask;
+			for (i=0; i<LPFC_INQSN_SZ; i++)
+				dfc_dev.InquirySN[i] = dev_ptr->InquirySN[i];
+			for (i=0; i<sizeof(dfc_dev.Vendor); i++)
+				dfc_dev.Vendor[i] = dev_ptr->Vendor[i];
+			for (i=0; i<sizeof(dfc_dev.Product); i++)
+				dfc_dev.Product[i] = dev_ptr->Product[i];
+			for (i=0; i<sizeof(dfc_dev.Rev); i++)
+				dfc_dev.Rev[i] = dev_ptr->Rev[i];
+			dfc_dev.sizeSN = dev_ptr->sizeSN;
+
+			cip->lpfc_outsz += sizeof (dfcscsilun_t);
+			memcpy(((uint8_t *) dataout +
+				sizeof (dfcscsitarget_t)), (uint8_t *) &dfc_dev,
+			       (sizeof (dfcscsilun_t)));
+			pndl = (LPFC_NODELIST_t *) node_ptr->pcontext;
+			if (pndl) {
+				cip->lpfc_outsz += copy_node_list(
+					(dfcnodelist_t*)((uint8_t *) dataout +
+					 sizeof (dfcscsilun_t) +
+					 sizeof (dfcscsitarget_t)), pndl);
+			}
+		}
+	}
+	return (rc);
+}
+
+int
+lpfc_reset_dev_q_depth(lpfcHBA_t * phba)
+{
+	LPFCSCSITARGET_t *targetp;
+	LPFCSCSILUN_t *dev_ptr;
+	int i;
+	lpfcCfgParam_t *clp = &phba->config[0];
+	struct list_head *curr, *next;
+
+	/*
+	 * Find the target and set it to default. 
+	 */
+
+	clp = &phba->config[0];
+	for (i = 0; i < MAX_FCP_TARGET; ++i) {
+		targetp = phba->device_queue_hash[i];
+		if (targetp) {
+			list_for_each_safe(curr, next, &targetp->lunlist) {
+				dev_ptr = list_entry(curr, LPFCSCSILUN_t , list);
+				
+				dev_ptr->lunSched.maxOutstanding =
+				    (ushort) clp[LPFC_DFT_LUN_Q_DEPTH].
+				    a_current;
+			}
+		}
+	}
+	return (0);
+}
+
+int
+lpfc_fcp_abort(lpfcHBA_t * phba, int cmd, int target, int lun)
+{
+	LPFC_SCSI_BUF_t *lpfc_cmd;
+	LPFC_NODELIST_t *pndl;
+	uint32_t flag;
+	int ret = 0;
+	int i = 0;
+
+	flag = LPFC_EXTERNAL_RESET;
+	switch (cmd) {
+	case BUS_RESET:
+
+		{
+			for (i = 0; i < MAX_FCP_TARGET; i++) {
+				pndl = lpfc_findnode_scsiid(phba, i);
+				if (pndl) {
+					lpfc_cmd = lpfc_get_scsi_buf(phba);
+					if (lpfc_cmd) {
+
+						lpfc_cmd->scsi_hba = phba;
+						lpfc_cmd->scsi_bus = 0;
+						lpfc_cmd->scsi_target = i;
+						lpfc_cmd->scsi_lun = 0;
+						ret =
+						    lpfc_scsi_tgt_reset(lpfc_cmd,
+								        phba, 0,
+								        i, flag);
+						lpfc_free_scsi_buf(lpfc_cmd);
+						lpfc_cmd = 0;
+					}
+				}
+			}
+		}
+		break;
+	case TARGET_RESET:
+		{
+			/* Obtain node ptr */
+			pndl = lpfc_findnode_scsiid(phba, target);
+			if (pndl) {
+				lpfc_cmd = lpfc_get_scsi_buf(phba);
+				if (lpfc_cmd) {
+
+					lpfc_cmd->scsi_hba = phba;
+					lpfc_cmd->scsi_bus = 0;
+					lpfc_cmd->scsi_target = target;
+					lpfc_cmd->scsi_lun = 0;
+
+					ret =
+					    lpfc_scsi_tgt_reset(lpfc_cmd, phba, 0,
+							        target, flag);
+					lpfc_free_scsi_buf(lpfc_cmd);
+					lpfc_cmd = 0;
+				}
+			}
+		}
+		break;
+	case LUN_RESET:
+		{
+			/* Obtain node ptr */
+			pndl = lpfc_findnode_scsiid(phba, target);
+			if (pndl) {
+				lpfc_cmd = lpfc_get_scsi_buf(phba);
+				if (lpfc_cmd) {
+					lpfc_cmd->scsi_hba = phba;
+					lpfc_cmd->scsi_bus = 0;
+					lpfc_cmd->scsi_target = target;
+					lpfc_cmd->scsi_lun = lun;
+					ret =
+					    lpfc_scsi_lun_reset(lpfc_cmd, phba, 0,
+							        target, lun,
+							        (flag |
+								 LPFC_ISSUE_LUN_RESET));
+					lpfc_free_scsi_buf(lpfc_cmd);
+					lpfc_cmd = 0;
+				}
+			}
+		}
+		break;
+	case ABORT_TASK_SET:
+		{
+			/* Obtain node ptr */
+			pndl = lpfc_findnode_scsiid(phba, target);
+			if (pndl) {
+				lpfc_cmd = lpfc_get_scsi_buf(phba);
+				if (lpfc_cmd) {
+					lpfc_cmd->scsi_hba = phba;
+					lpfc_cmd->scsi_bus = 0;
+					lpfc_cmd->scsi_target = target;
+					lpfc_cmd->scsi_lun = lun;
+					ret =
+					    lpfc_scsi_lun_reset(lpfc_cmd, phba, 0,
+							        target, lun,
+							        (flag |
+								 LPFC_ISSUE_ABORT_TSET));
+					lpfc_free_scsi_buf(lpfc_cmd);
+					lpfc_cmd = 0;
+				}
+			}
+		}
+		break;
+	}
+
+	return (ret);
+}
diff -urNp linux-8155/drivers/addon/lpfc/lpfcdfc/lpfc_debug_ioctl.h linux-8156/drivers/addon/lpfc/lpfcdfc/lpfc_debug_ioctl.h
--- linux-8155/drivers/addon/lpfc/lpfcdfc/lpfc_debug_ioctl.h
+++ linux-8156/drivers/addon/lpfc/lpfcdfc/lpfc_debug_ioctl.h
@@ -0,0 +1,40 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_debug_ioctl.h 328 2005-05-03 15:20:43Z sf_support $
+ */
+
+#ifndef H_LPFC_DFC_IOCTL
+#define H_LPFC_DFC_IOCTL
+int lpfc_process_ioctl_dfc(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip);
+int lpfc_ioctl_lip(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_outfcpio(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_send_els(lpfcHBA_t *, LPFCCMDINPUT_t *);
+int lpfc_ioctl_inst(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_listn(lpfcHBA_t *, LPFCCMDINPUT_t *,  void *, int);
+int lpfc_ioctl_read_bplist(lpfcHBA_t *, LPFCCMDINPUT_t *, void *, int);
+int lpfc_ioctl_reset(lpfcHBA_t *, LPFCCMDINPUT_t *);
+int lpfc_ioctl_read_hba(lpfcHBA_t *, LPFCCMDINPUT_t *, void *, int);
+int lpfc_ioctl_stat(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_devp(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_reset_dev_q_depth(lpfcHBA_t *);
+int lpfc_fcp_abort(lpfcHBA_t *, int, int, int);
+#endif
diff -urNp linux-8155/drivers/addon/lpfc/lpfcdfc/lpfc_diag.h linux-8156/drivers/addon/lpfc/lpfcdfc/lpfc_diag.h
--- linux-8155/drivers/addon/lpfc/lpfcdfc/lpfc_diag.h
+++ linux-8156/drivers/addon/lpfc/lpfcdfc/lpfc_diag.h
@@ -0,0 +1,228 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_diag.h 328 2005-05-03 15:20:43Z sf_support $
+ */
+
+#ifndef _H_LPFC_DIAG
+#define _H_LPFC_DIAG
+
+
+   /*
+      Define interface for dynamic persistent binding
+    */
+#define       LPFC_WWNN_BIND 0x0
+#define       LPFC_WWPN_BIND 0x1
+#define       LPFC_DID_BIND  0x2
+#define       LPFC_SCSI_ID   0x3
+
+
+/* bits in a_onmask */
+#define ONDI_MBOX       0x1	/* allows non-destructive mailbox commands */
+#define ONDI_IOINFO     0x2	/* supports retrieval of I/O info */
+#define ONDI_LNKINFO    0x4	/* supports retrieval of link info */
+#define ONDI_NODEINFO   0x8	/* supports retrieval of node info */
+#define ONDI_TRACEINFO  0x10	/* supports retrieval of trace info */
+#define ONDI_SETTRACE   0x20	/* supports configuration of trace info */
+#define ONDI_SLI1       0x40	/* hardware supports SLI-1 interface */
+#define ONDI_SLI2       0x80	/* hardware supports SLI-2 interface */
+#define ONDI_BIG_ENDIAN 0x100	/* DDI interface is BIG Endian */
+#define ONDI_LTL_ENDIAN 0x200	/* DDI interface is LITTLE Endian */
+#define ONDI_RMEM       0x400	/* allows reading of adapter shared memory */
+#define ONDI_RFLASH     0x800	/* allows reading of adapter flash */
+#define ONDI_RPCI       0x1000	/* allows reading of adapter pci registers */
+#define ONDI_RCTLREG    0x2000	/* allows reading of adapter cntrol registers */
+#define ONDI_CFGPARAM   0x4000	/* supports get/set configuration parameters */
+#define ONDI_CT         0x8000	/* supports passthru CT interface */
+#define ONDI_HBAAPI     0x10000	/* supports HBA API interface */
+
+/* bits in a_offmask */
+#define OFFDI_MBOX      0x1	/* allows all mailbox commands */
+#define OFFDI_RMEM      0x2	/* allows reading of adapter shared memory */
+#define OFFDI_WMEM      0x4	/* allows writing of adapter shared memory */
+#define OFFDI_RFLASH    0x8	/* allows reading of adapter flash */
+#define OFFDI_WFLASH    0x10	/* allows writing of adapter flash */
+#define OFFDI_RPCI      0x20	/* allows reading of adapter pci registers */
+#define OFFDI_WPCI      0x40	/* allows writing of adapter pci registers */
+#define OFFDI_RCTLREG   0x80	/* allows reading of adapter cntrol registers */
+#define OFFDI_WCTLREG   0x100	/* allows writing of adapter cntrol registers */
+#define OFFDI_OFFLINE   0x80000000	/* if set, adapter is in offline
+					   state */
+
+/* values for flag in SetDiagEnv */
+#define DDI_SHOW        0x0
+#define DDI_ONDI        0x1
+#define DDI_OFFDI       0x2
+
+#define DDI_BRD_SHOW    0x10
+#define DDI_BRD_ONDI    0x11
+#define DDI_BRD_OFFDI   0x12
+
+#define DDI_UNUSED      0xFFFFFFFFL
+
+/* the ioinfo structure */
+typedef struct IOINFO {
+	uint32_t a_mbxCmd;	/* mailbox commands issued */
+	uint32_t a_mboxCmpl;	/* mailbox commands completed */
+	uint32_t a_mboxErr;	/* mailbox commands completed, error status */
+	uint32_t a_iocbCmd;	/* iocb command ring issued */
+	uint32_t a_iocbRsp;	/* iocb rsp ring received */
+	uint32_t a_adapterIntr;	/* adapter interrupt events */
+	uint32_t a_fcpCmd;	/* FCP commands issued */
+	uint32_t a_fcpCmpl;	/* FCP command completions received */
+	uint32_t a_fcpErr;	/* FCP command completions errors */
+	uint32_t a_seqXmit;	/* IP xmit sequences sent */
+	uint32_t a_seqRcv;	/* IP sequences received */
+	uint32_t a_bcastXmit;	/* cnt of successful xmit bcast cmds issued */
+	uint32_t a_bcastRcv;	/* cnt of receive bcast cmds received */
+	uint32_t a_elsXmit;	/* cnt of successful ELS req cmds issued */
+	uint32_t a_elsRcv;	/* cnt of ELS request commands received */
+	uint32_t a_RSCNRcv;	/* cnt of RSCN commands received */
+	uint32_t a_seqXmitErr;	/* cnt of unsuccessful xmit bcast cmds issued */
+	uint32_t a_elsXmitErr;	/* cnt of unsuccessful ELS req cmds issued  */
+	uint32_t a_elsBufPost;	/* cnt of ELS buffers posted to adapter */
+	uint32_t a_ipBufPost;	/* cnt of IP buffers posted to adapter */
+	uint32_t a_cnt1;	/* generic counter */
+	uint32_t a_cnt2;	/* generic counter */
+	uint32_t a_cnt3;	/* generic counter */
+	uint32_t a_cnt4;	/* generic counter */
+} IOinfo;
+
+/* the linkinfo structure */
+typedef struct LINKINFO {
+	uint32_t a_linkEventTag;
+	uint32_t a_linkUp;
+	uint32_t a_linkDown;
+	uint32_t a_linkMulti;
+	uint32_t a_DID;
+	uint8_t a_topology;
+	uint8_t a_linkState;
+	uint8_t a_alpa;
+	uint8_t a_alpaCnt;
+	uint8_t a_alpaMap[128];
+	uint8_t a_wwpName[8];
+	uint8_t a_wwnName[8];
+} LinkInfo;
+
+/* values for a_topology */
+#define LNK_LOOP                0x1
+#define LNK_PUBLIC_LOOP         0x2
+#define LNK_FABRIC              0x3
+#define LNK_PT2PT               0x4
+
+/* values for a_linkState */
+#define LNK_DOWN                0x1
+#define LNK_UP                  0x2
+#define LNK_FLOGI               0x3
+#define LNK_DISCOVERY           0x4
+#define LNK_REDISCOVERY         0x5
+#define LNK_READY               0x6
+
+/* the traceinfo structure */
+typedef struct TRACEINFO {
+	uint8_t a_event;
+	uint8_t a_cmd;
+	uint16_t a_status;
+	uint32_t a_information;
+} TraceInfo;
+
+/* values for flag */
+#define TRC_SHOW        0x0
+#define TRC_MBOX        0x1
+#define TRC_IOCB        0x2
+#define TRC_INTR        0x4
+#define TRC_EVENT       0x8
+
+/* values for a_event */
+#define TRC_MBOX_CMD    0x1
+#define TRC_MBOX_CMPL   0x2
+#define TRC_IOCB_CMD    0x3
+#define TRC_IOCB_RSP    0x4
+#define TRC_INTR_RCV    0x5
+#define TRC_EVENT1      0x6
+#define TRC_EVENT2      0x7
+#define TRC_EVENT_MASK  0x7
+#define TRC_RING0       0x0
+#define TRC_RING1       0x40
+#define TRC_RING2       0x80
+#define TRC_RING3       0xC0
+#define TRC_RING_MASK   0xC0
+
+/* the cfgparam structure */
+typedef struct CFGPARAM {
+	char a_string[32];
+	uint32_t a_low;
+	uint32_t a_hi;
+	uint32_t a_default;
+	uint32_t a_current;
+	uint16_t a_flag;
+	uint16_t a_changestate;
+	char a_help[80];
+} CfgParam;
+
+#define MAX_CFG_PARAM 64
+
+/* the nodeinfo structure */
+typedef struct NODEINFO {
+	uint16_t a_flag;
+	uint16_t a_state;
+	uint32_t a_did;
+	uint8_t a_wwpn[8];
+	uint8_t a_wwnn[8];
+	uint32_t a_targetid;
+} NodeInfo;
+
+#define MAX_NODES 512
+
+/* Defines for a_state */
+#define NODE_UNUSED     0
+#define NODE_LIMBO      0x1	/* entry needs to hang around for wwpn / sid */
+#define NODE_LOGOUT     0x2	/* NL_PORT is not logged in - entry is cached */
+#define NODE_PLOGI      0x3	/* PLOGI was sent to NL_PORT */
+#define NODE_LOGIN      0x4	/* NL_PORT is logged in / login REG_LOGINed */
+#define NODE_PRLI       0x5	/* PRLI was sent to NL_PORT */
+#define NODE_ALLOC      0x6	/* NL_PORT is  ready to initiate adapter I/O */
+#define NODE_SEED       0x7	/* seed scsi id bind in table */
+
+/* Defines for a_flag */
+#define NODE_RPI_XRI        0x1	/* creating xri for entry */
+#define NODE_REQ_SND        0x2	/* sent ELS request for this entry */
+#define NODE_ADDR_AUTH      0x4	/* Authenticating addr for this entry */
+#define NODE_RM_ENTRY       0x8	/* Remove this entry */
+#define NODE_FARP_SND       0x10	/* sent FARP request for this entry */
+#define NODE_FABRIC         0x20	/* this entry represents the Fabric */
+#define NODE_FCP_TARGET     0x40	/* this entry is an FCP target */
+#define NODE_IP_NODE        0x80	/* this entry is an IP node */
+#define NODE_DISC_START     0x100	/* start discovery on this entry */
+#define NODE_SEED_WWPN      0x200	/* Entry scsi id is seeded for WWPN */
+#define NODE_SEED_WWNN      0x400	/* Entry scsi id is seeded for WWNN */
+#define NODE_SEED_DID       0x800	/* Entry scsi id is seeded for DID */
+#define NODE_SEED_MASK      0xe00	/* mask for seeded flags */
+#define NODE_AUTOMAP        0x1000	/* This entry was automap'ed */
+#define NODE_NS_REMOVED     0x2000	/* This entry removed from NameServer */
+
+/* Define for fc_flag */
+#define DFC_MBOX_ACTIVE  2	/* mailbox is active thru dfc */
+
+/* Define for dfc 'riocb' function */
+#define FC_RING(ringoff,sa)     ((volatile uint8_t *)((volatile uint8_t *)sa + \
+						      (unsigned long)(ringoff)))
+#endif				/* _H_LPFC_DIAG */
diff -urNp linux-8155/drivers/addon/lpfc/lpfcdfc/lpfc_hbaapi_ioctl.c linux-8156/drivers/addon/lpfc/lpfcdfc/lpfc_hbaapi_ioctl.c
--- linux-8155/drivers/addon/lpfc/lpfcdfc/lpfc_hbaapi_ioctl.c
+++ linux-8156/drivers/addon/lpfc/lpfcdfc/lpfc_hbaapi_ioctl.c
@@ -0,0 +1,2133 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_hbaapi_ioctl.c 484 2006-03-27 16:26:51Z sf_support $
+ */
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/blkdev.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/unistd.h>
+#include <linux/timex.h>
+#include <linux/timer.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/irq.h>
+#include <sd.h>			/* From drivers/scsi */
+#include <hosts.h>
+
+#include "lpfc_version.h"
+#include "lpfc_hw.h"
+#include "lpfc_sli.h"
+#include "lpfc_mem.h"
+#include "lpfc_sched.h"
+#include "lpfc_disc.h"
+#include "lpfc.h"
+#include "lpfc_logmsg.h"
+#include "lpfc_fcp.h"
+#include "lpfc_scsi.h"
+#include "lpfc_hw.h"
+#include "lpfc_diag.h"
+#include "lpfc_ioctl.h"
+#include "lpfc_diag.h"
+#include "lpfc_crtn.h"
+#include "lpfc_cfgparm.h"
+#include "hbaapi.h"
+#include "lpfc_hbaapi_ioctl.h"
+
+extern lpfcDRVR_t lpfcDRVR;
+extern char *lpfc_release_version;
+
+/*
+ * For 64 bit platforms that run x86 code we need to thunk the 64 bit versions
+ * of the data structures in the driver to the 32 bit versions used by the apps.
+ * This only applies to data that has different sizes or packing on the two
+ * platforms which is why we don't have 32 and 64 bit versions of all data
+ * structures
+ */
+#ifdef CONFIG_X86_64
+#pragma pack(4)
+typedef struct HBA_FcpId32 {
+	HBA_UINT32 FcId;
+	HBA_WWN NodeWWN;
+	HBA_WWN PortWWN;
+	HBA_UINT64 FcpLun;
+} HBA_FCPID32, *PHBA_FCPID32;
+
+typedef struct HBA_FcpScsiEntry32 {
+	HBA_SCSIID ScsiId;
+	HBA_FCPID32 FcpId;
+} HBA_FCPSCSIENTRY32, *PHBA_FCPSCSIENTRY32;
+
+typedef struct HBA_FcpScsiEntryV232 {
+	HBA_SCSIID ScsiId;
+	HBA_FCPID32 FcpId;
+	HBA_LUID LUID;
+} HBA_FCPSCSIENTRYV232, *PHBA_FCPSCSIENTRYV232;
+
+typedef struct HBA_FCPTargetMapping32 {
+	HBA_UINT32 NumberOfEntries;
+	HBA_FCPSCSIENTRY32 entry[1];	/* Variable length array
+					 * containing mappings */
+} HBA_FCPTARGETMAPPING32, *PHBA_FCPTARGETMAPPING32;
+
+typedef struct HBA_FCPTargetMappingV232 {
+	HBA_UINT32 NumberOfEntries;
+	HBA_FCPSCSIENTRYV232 entry[1];	/* Variable length array
+					 * containing mappings */
+} HBA_FCPTARGETMAPPINGV232, *PHBA_FCPTARGETMAPPINGV232;
+
+typedef struct HBA_FCPBindingEntry32 {
+	HBA_FCPBINDINGTYPE type;
+	HBA_SCSIID ScsiId;
+	HBA_FCPID32 FcpId;	/* WWN valid only if type is
+				 * to WWN, FcpLun always valid */
+	HBA_UINT32 FcId;
+} HBA_FCPBINDINGENTRY32, *PHBA_FCPBINDINGENTRY32;
+
+typedef struct HBA_FCPBindingEntry232 {
+	HBA_BIND_TYPE type;
+	HBA_SCSIID ScsiId;
+	HBA_FCPID32 FcpId;
+	HBA_LUID LUID;
+	HBA_STATUS status;
+} HBA_FCPBINDINGENTRY232, *PHBA_FCPBINDINGENTRY232;
+
+typedef struct HBA_FCPBinding32 {
+	HBA_UINT32 NumberOfEntries;
+	HBA_FCPBINDINGENTRY32 entry[1];	/* Variable length array */
+} HBA_FCPBINDING32, *PHBA_FCPBINDING32;
+
+typedef struct HBA_FcpBinding232 {
+	HBA_UINT32 NumberOfEntries;
+	HBA_FCPBINDINGENTRY232 entry[1];	/* Variable length array */
+} HBA_FCPBINDING232, *PHBA_FCPBINDING232;
+#pragma pack()
+#endif /* CONFIG_X86_64 */
+
+/* Routine Declaration - Local */
+
+int
+lpfc_process_ioctl_hbaapi(lpfcHBA_t *phba, LPFCCMDINPUT_t *cip)
+{
+	int rc = -1;
+	int do_cp = 0; 
+	uint32_t outshift;
+	uint32_t total_mem;
+	struct dfc_info *di;
+	void   *dataout;
+	unsigned long iflag;
+        
+	extern struct dfc dfc;
+
+	di = &dfc.dfc_info[cip->lpfc_brd];
+	/* dfc_ioctl entry */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk1602,	/* ptr to msg structure */
+		lpfc_mes1602,			/* ptr to msg */
+		lpfc_msgBlk1602.msgPreambleStr,	/* begin varargs */
+		cip->lpfc_cmd,
+		(ulong) cip->lpfc_arg1,
+		(ulong) cip->lpfc_arg2,
+		cip->lpfc_outsz);		/* end varargs */
+
+	outshift = 0;
+	if (cip->lpfc_outsz >= 4096) {
+
+		/* Allocate memory for ioctl data. If buffer is bigger than 64k, then we
+		 * allocate 64k and re-use that buffer over and over to xfer the whole 
+		 * block. This is because Linux kernel has a problem allocating more than
+		 * 120k of kernel space memory. Saw problem with GET_FCPTARGETMAPPING...
+		 */
+		if (cip->lpfc_outsz <= (64 * 1024))
+			total_mem = cip->lpfc_outsz;
+		else
+			total_mem = 64 * 1024;		
+	} else {
+		/* Allocate memory for ioctl data */
+		total_mem = 4096;
+	}
+
+	dataout = kmalloc(total_mem, GFP_ATOMIC);
+	if (!dataout)
+		return (ENOMEM);
+
+	di->fc_refcnt++;
+
+	switch (cip->lpfc_cmd) {
+
+	/* Diagnostic Interface Library Support - hbaapi */
+	case LPFC_HBA_ADAPTERATTRIBUTES:
+		rc = lpfc_ioctl_hba_adapterattributes(phba, cip, dataout);
+		break;
+
+	case LPFC_HBA_PORTATTRIBUTES:
+		rc = lpfc_ioctl_hba_portattributes(phba, cip, dataout);
+		break;
+
+	case LPFC_HBA_PORTSTATISTICS:
+		rc = lpfc_ioctl_hba_portstatistics(phba, cip, dataout);
+		break;
+
+	case LPFC_HBA_WWPNPORTATTRIBUTES:
+		rc = lpfc_ioctl_hba_wwpnportattributes(phba, cip, dataout);
+		break;
+
+	case LPFC_HBA_DISCPORTATTRIBUTES:
+		rc = lpfc_ioctl_hba_discportattributes(phba, cip, dataout);
+		break;
+
+	case LPFC_HBA_INDEXPORTATTRIBUTES:
+		rc = lpfc_ioctl_hba_indexportattributes(phba, cip, dataout);
+		break;
+
+	case LPFC_HBA_SETMGMTINFO:
+		rc = lpfc_ioctl_hba_setmgmtinfo(phba, cip);
+		break;
+
+	case LPFC_HBA_GETMGMTINFO:
+		rc = lpfc_ioctl_hba_getmgmtinfo(phba, cip, dataout);
+		break;
+
+	case LPFC_HBA_REFRESHINFO:
+		rc = lpfc_ioctl_hba_refreshinfo(phba, cip, dataout);
+		break;
+
+	case LPFC_HBA_RNID:
+		rc = lpfc_ioctl_hba_rnid(phba, cip, dataout);
+		break;
+
+	case LPFC_HBA_GETEVENT:
+		rc = lpfc_ioctl_hba_getevent(phba, cip, dataout);
+		break;
+
+	case LPFC_HBA_FCPTARGETMAPPING:
+		rc = lpfc_ioctl_hba_fcptargetmapping(phba, cip, 
+						     dataout, total_mem, &do_cp);
+		break;
+
+	case LPFC_HBA_FCPBINDING:
+		rc = lpfc_ioctl_hba_fcpbinding(phba, cip, dataout, 
+					       total_mem, &do_cp);
+		break;
+	}
+	di->fc_refcnt--;
+
+	/* dfc_ioctl exit */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk1603,	/* ptr to msg structure */
+		lpfc_mes1603,			/* ptr to msg */
+		lpfc_msgBlk1603.msgPreambleStr,	/* begin varargs */
+		rc,
+		cip->lpfc_outsz,
+		(uint32_t) ((ulong) cip->lpfc_dataout));	/* end varargs */
+
+
+	/* Copy data to user space config method */
+	if (rc == 0 || do_cp == 1) {
+		if (cip->lpfc_outsz) {
+			LPFC_DRVR_UNLOCK(phba, iflag);
+			if (copy_to_user
+			    ((uint8_t *) cip->lpfc_dataout,
+			     (uint8_t *) dataout, (int)cip->lpfc_outsz)) {
+				rc = EIO;
+			}
+			LPFC_DRVR_LOCK(phba, iflag);
+		}
+	}
+
+	kfree(dataout);
+	return(rc);
+}
+
+int
+lpfc_ioctl_hba_adapterattributes(lpfcHBA_t * phba,
+				 LPFCCMDINPUT_t * cip, void *dataout)
+{
+	HBA_ADAPTERATTRIBUTES *ha;
+	struct pci_dev *pdev;
+	char *pNodeSymbolicName;
+	char fwrev[32];
+	uint32_t incr;
+	lpfc_vpd_t *vp;
+	int rc = 0;
+	int i, j = 0;		/* loop index */
+
+	/* Allocate mboxq structure */
+	pNodeSymbolicName = kmalloc(256, GFP_ATOMIC);
+	if (!pNodeSymbolicName)
+		return(ENOMEM);
+
+	pdev = phba->pcidev;
+	vp = &phba->vpd;
+	ha = (HBA_ADAPTERATTRIBUTES *) dataout;
+	memset(dataout, 0, (sizeof (HBA_ADAPTERATTRIBUTES)));
+	ha->NumberOfPorts = 1;
+	ha->VendorSpecificID = 
+	    ((((uint32_t) pdev->device) << 16) | (uint32_t) (pdev->vendor));
+	ha->VendorSpecificID = le32_to_cpu(ha->VendorSpecificID);
+	memcpy(ha->DriverVersion, lpfc_release_version, 8);
+	lpfc_decode_firmware_rev(phba, fwrev, 1);
+	memcpy(ha->FirmwareVersion, fwrev, 32);
+	memcpy((uint8_t *) & ha->NodeWWN,
+	       (uint8_t *) & phba->fc_sparam.nodeName, sizeof (HBA_WWN));
+	memcpy(ha->Manufacturer, "Emulex Corporation", 20);
+	memcpy(ha->Model, phba->ModelName, 80);
+	memcpy(ha->ModelDescription, phba->ModelDesc, 256);
+	memcpy(ha->DriverName, LPFC_DRIVER_NAME, 7);
+	memcpy(ha->SerialNumber, phba->SerialNumber, 32);
+	memcpy(ha->OptionROMVersion, phba->OptionROMVersion, 32);
+	/* Convert JEDEC ID to ascii for hardware version */
+	incr = vp->rev.biuRev;
+	for (i = 0; i < 8; i++) {
+		j = (incr & 0xf);
+		if (j <= 9)
+			ha->HardwareVersion[7 - i] =
+			    (char)((uint8_t) 0x30 + (uint8_t) j);
+		else
+			ha->HardwareVersion[7 - i] =
+			    (char)((uint8_t) 0x61 + (uint8_t) (j - 10));
+		incr = (incr >> 4);
+	}
+	ha->HardwareVersion[8] = 0;
+
+	lpfc_get_hba_sym_node_name(phba, (uint8_t *) pNodeSymbolicName);
+	memcpy(ha->NodeSymbolicName, pNodeSymbolicName, 256);
+
+	/* Free allocated block of memory */
+	if (pNodeSymbolicName)
+		kfree(pNodeSymbolicName);
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_hba_portattributes(lpfcHBA_t * phba,
+			      LPFCCMDINPUT_t * cip, void *dataout)
+{
+
+	HBA_PORTATTRIBUTES *hp;
+	SERV_PARM *hsp;
+	HBA_OSDN *osdn;
+	lpfc_vpd_t *vp;
+	uint32_t cnt;
+	lpfcCfgParam_t *clp;
+	int rc = 0;
+
+	cnt = 0;
+	clp = &phba->config[0];
+	vp = &phba->vpd;
+	hsp = (SERV_PARM *) (&phba->fc_sparam);
+	hp = (HBA_PORTATTRIBUTES *) dataout;
+
+	memset(dataout, 0, (sizeof (HBA_PORTATTRIBUTES)));
+	memcpy((uint8_t *) & hp->NodeWWN,
+	       (uint8_t *) & phba->fc_sparam.nodeName, sizeof (HBA_WWN));
+	memcpy((uint8_t *) & hp->PortWWN,
+	       (uint8_t *) & phba->fc_sparam.portName, sizeof (HBA_WWN));
+
+	switch(phba->fc_linkspeed) {
+	case LA_1GHZ_LINK:
+		hp->PortSpeed = HBA_PORTSPEED_1GBIT;
+		break;
+	case LA_2GHZ_LINK:
+		hp->PortSpeed = HBA_PORTSPEED_2GBIT;
+		break;
+	case LA_4GHZ_LINK:
+		hp->PortSpeed = HBA_PORTSPEED_4GBIT;
+		break;
+	default:
+		hp->PortSpeed = HBA_PORTSPEED_UNKNOWN;
+		break;
+	}
+
+	if (FC_JEDEC_ID(vp->rev.biuRev) == VIPER_JEDEC_ID)
+		hp->PortSupportedSpeed = HBA_PORTSPEED_10GBIT;
+	else if ((FC_JEDEC_ID(vp->rev.biuRev) == HELIOS_JEDEC_ID) ||
+		 (FC_JEDEC_ID(vp->rev.biuRev) == ZEPHYR_JEDEC_ID))
+		hp->PortSupportedSpeed = HBA_PORTSPEED_4GBIT;
+	else if ((FC_JEDEC_ID(vp->rev.biuRev) == CENTAUR_2G_JEDEC_ID) ||
+		 (FC_JEDEC_ID(vp->rev.biuRev) == PEGASUS_JEDEC_ID) ||
+		 (FC_JEDEC_ID(vp->rev.biuRev) == THOR_JEDEC_ID))
+		hp->PortSupportedSpeed = HBA_PORTSPEED_2GBIT;
+	else
+		hp->PortSupportedSpeed = HBA_PORTSPEED_1GBIT;
+
+	hp->PortFcId = phba->fc_myDID;
+	hp->PortType = HBA_PORTTYPE_UNKNOWN;
+	if (phba->fc_topology == TOPOLOGY_LOOP) {
+		if (phba->fc_flag & FC_PUBLIC_LOOP) {
+			hp->PortType = HBA_PORTTYPE_NLPORT;
+			memcpy((uint8_t *) & hp->FabricName,
+			       (uint8_t *) & phba->fc_fabparam.nodeName,
+			       sizeof (HBA_WWN));
+		} else {
+			hp->PortType = HBA_PORTTYPE_LPORT;
+		}
+	} else {
+		if (phba->fc_flag & FC_FABRIC) {
+			hp->PortType = HBA_PORTTYPE_NPORT;
+			memcpy((uint8_t *) & hp->FabricName,
+			       (uint8_t *) & phba->fc_fabparam.nodeName,
+			       sizeof (HBA_WWN));
+		} else {
+			hp->PortType = HBA_PORTTYPE_PTP;
+		}
+	}
+
+	if (phba->fc_flag & FC_BYPASSED_MODE) {
+		hp->PortState = HBA_PORTSTATE_BYPASSED;
+	} else if (phba->fc_flag & FC_OFFLINE_MODE) {
+		hp->PortState = HBA_PORTSTATE_DIAGNOSTICS;
+	} else {
+		switch (phba->hba_state) {
+		case LPFC_INIT_START:
+		case LPFC_INIT_MBX_CMDS:
+			hp->PortState = HBA_PORTSTATE_UNKNOWN;
+			break;
+		case LPFC_LINK_DOWN:
+		case LPFC_LINK_UP:
+		case LPFC_LOCAL_CFG_LINK:
+		case LPFC_FLOGI:
+		case LPFC_FABRIC_CFG_LINK:
+		case LPFC_NS_REG:
+		case LPFC_NS_QRY:
+		case LPFC_BUILD_DISC_LIST:
+		case LPFC_DISC_AUTH:
+		case LPFC_CLEAR_LA:
+			hp->PortState = HBA_PORTSTATE_LINKDOWN;
+			break;
+		case LPFC_HBA_READY:
+			hp->PortState = HBA_PORTSTATE_ONLINE;
+			break;
+		case LPFC_HBA_ERROR:
+		default:
+			hp->PortState = HBA_PORTSTATE_ERROR;
+			break;
+		}
+	}
+	cnt = phba->fc_map_cnt + phba->fc_unmap_cnt;
+	hp->NumberofDiscoveredPorts = cnt;
+	if (hsp->cls1.classValid) {
+		hp->PortSupportedClassofService |= 2;	/* bit 1 */
+	}
+	if (hsp->cls2.classValid) {
+		hp->PortSupportedClassofService |= 4;	/* bit 2 */
+	}
+	if (hsp->cls3.classValid) {
+		hp->PortSupportedClassofService |= 8;	/* bit 3 */
+	}
+	hp->PortMaxFrameSize = (((uint32_t) hsp->cmn.bbRcvSizeMsb) << 8) |
+	    (uint32_t) hsp->cmn.bbRcvSizeLsb;
+
+	hp->PortSupportedFc4Types.bits[2] = 0x1;
+	hp->PortSupportedFc4Types.bits[3] = 0x20;
+	hp->PortSupportedFc4Types.bits[7] = 0x1;
+	hp->PortActiveFc4Types.bits[2] = 0x1;
+
+	hp->PortActiveFc4Types.bits[7] = 0x1;
+
+	/* OSDeviceName is the device info filled into the HBA_OSDN structure */
+	osdn = (HBA_OSDN *) & hp->OSDeviceName[0];
+	memcpy(osdn->drvname, LPFC_DRIVER_NAME, 4);
+	osdn->instance = phba->brd_no;
+	osdn->target = (uint32_t) (-1);
+	osdn->lun = (uint32_t) (-1);
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_hba_portstatistics(lpfcHBA_t * phba,
+			      LPFCCMDINPUT_t * cip, void *dataout)
+{
+
+	HBA_PORTSTATISTICS *hs;
+	LPFC_MBOXQ_t *pmboxq;
+	MAILBOX_t *pmb;
+	unsigned long iflag;
+	int rc = 0;
+	LPFC_SLI_t *psli = &phba->sli;
+
+	if ((pmboxq = lpfc_mbox_alloc(phba, MEM_PRI)) == 0) {
+		return ENOMEM;
+	}
+
+	pmb = &pmboxq->mb;
+
+	hs = (HBA_PORTSTATISTICS *) dataout;
+	memset(dataout, 0, (sizeof (HBA_PORTSTATISTICS)));
+	memset((void *)pmboxq, 0, sizeof (LPFC_MBOXQ_t));
+	pmb->mbxCommand = MBX_READ_STATUS;
+	pmb->mbxOwner = OWN_HOST;
+	pmboxq->context1 = (uint8_t *) 0;
+
+	if ((phba->fc_flag & FC_OFFLINE_MODE) ||
+	    (!(psli->sliinit.sli_flag & LPFC_SLI2_ACTIVE))){
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		rc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_POLL);
+		LPFC_DRVR_LOCK(phba, iflag);
+	} else
+		rc = lpfc_sli_issue_mbox_wait(phba, pmboxq, phba->fc_ratov * 2);
+	if (rc != MBX_SUCCESS) {
+		if (pmboxq) {
+			if (rc == MBX_TIMEOUT) {
+				/*
+				 * Let SLI layer to release mboxq if mbox command completed after timeout.
+				 */
+				pmboxq->mbox_cmpl = 0;
+			} else {
+				lpfc_mbox_free(phba, pmboxq);
+			}
+		}
+		rc = ENODEV;
+		return (rc);
+	}
+	hs->TxFrames = pmb->un.varRdStatus.xmitFrameCnt;
+	hs->RxFrames = pmb->un.varRdStatus.rcvFrameCnt;
+	/* Convert KBytes to words */
+	hs->TxWords = (pmb->un.varRdStatus.xmitByteCnt * 256);
+	hs->RxWords = (pmb->un.varRdStatus.rcvByteCnt * 256);
+	memset((void *)pmboxq, 0, sizeof (LPFC_MBOXQ_t));
+	pmb->mbxCommand = MBX_READ_LNK_STAT;
+	pmb->mbxOwner = OWN_HOST;
+	pmboxq->context1 = (uint8_t *) 0;
+
+	if ((phba->fc_flag & FC_OFFLINE_MODE) ||
+	    (!(psli->sliinit.sli_flag & LPFC_SLI2_ACTIVE))){
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		rc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_POLL);
+		LPFC_DRVR_LOCK(phba, iflag);
+	} else
+		rc = lpfc_sli_issue_mbox_wait(phba, pmboxq, phba->fc_ratov * 2);
+	if (rc != MBX_SUCCESS) {
+		if (pmboxq) {
+			if (rc == MBX_TIMEOUT) {
+				/*
+				 * Let SLI layer to release mboxq if mbox command completed after timeout.
+				 */
+				pmboxq->mbox_cmpl = 0;
+			} else {
+				lpfc_mbox_free(phba, pmboxq);
+			}
+		}
+		rc = ENODEV;
+		return (rc);
+	}
+	hs->LinkFailureCount = pmb->un.varRdLnk.linkFailureCnt;
+	hs->LossOfSyncCount = pmb->un.varRdLnk.lossSyncCnt;
+	hs->LossOfSignalCount = pmb->un.varRdLnk.lossSignalCnt;
+	hs->PrimitiveSeqProtocolErrCount = pmb->un.varRdLnk.primSeqErrCnt;
+	hs->InvalidTxWordCount = pmb->un.varRdLnk.invalidXmitWord;
+	hs->InvalidCRCCount = pmb->un.varRdLnk.crcCnt;
+	hs->ErrorFrames = pmb->un.varRdLnk.crcCnt;
+
+	if (phba->fc_topology == TOPOLOGY_LOOP) {
+		hs->LIPCount = (phba->fc_eventTag >> 1);
+		hs->NOSCount = -1;
+	} else {
+		hs->LIPCount = -1;
+		hs->NOSCount = (phba->fc_eventTag >> 1);
+	}
+
+	hs->DumpedFrames = -1;
+
+	hs->SecondsSinceLastReset = (jiffies - lpfcDRVR.loadtime) / HZ;
+
+	/* Free allocated mboxq memory */
+	if (pmboxq) {
+		lpfc_mbox_free(phba, pmboxq);
+	}
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_hba_wwpnportattributes(lpfcHBA_t * phba,
+				  LPFCCMDINPUT_t * cip, void *dataout)
+{
+	HBA_WWN findwwn;
+	LPFC_NODELIST_t *pndl;
+	struct list_head *pos, *listp;
+	struct list_head *node_list[2];
+	HBA_PORTATTRIBUTES *hp;
+	lpfc_vpd_t *vp;
+	MAILBOX_t *pmbox;
+	int rc = 0;
+	unsigned long iflag;
+	int i;
+
+	/* Allocate mboxq structure */
+	pmbox = kmalloc(sizeof (MAILBOX_t), GFP_ATOMIC);
+	if (!pmbox)
+		return(ENOMEM);
+
+	hp = (HBA_PORTATTRIBUTES *) dataout;
+	vp = &phba->vpd;
+	memset(dataout, 0, (sizeof (HBA_PORTATTRIBUTES)));
+
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	if (copy_from_user((uint8_t *) & findwwn, (uint8_t *) cip->lpfc_arg1,
+			   (ulong) (sizeof (HBA_WWN)))) {
+		LPFC_DRVR_LOCK(phba, iflag);
+		rc = EIO;
+		/* Free allocated mbox memory */
+		if (pmbox)
+			kfree((void *)pmbox);
+		return (rc);
+	}
+	LPFC_DRVR_LOCK(phba, iflag);
+
+	/* First Mapped ports, then unMapped ports */
+	node_list[0] = &phba->fc_nlpmap_list;
+	node_list[1] = &phba->fc_nlpunmap_list;
+	for (i = 0; i < 2; i++) {
+		listp = node_list[i];
+		if (list_empty(listp)) 
+			continue;
+
+		list_for_each(pos, listp) {
+			pndl = list_entry(pos, LPFC_NODELIST_t, nlp_listp);	
+			if (lpfc_geportname(&pndl->nlp_portname, 
+						(NAME_TYPE *) &findwwn) == 2) {
+				/* handle found port */
+				rc = lpfc_ioctl_found_port(phba, pndl, dataout, pmbox, hp);
+				/* Free allocated mbox memory */
+				if (pmbox)
+					kfree((void *)pmbox);
+				return (rc);
+			}
+		}
+	}
+
+	/* Free allocated mbox memory */
+	if (pmbox)
+		kfree((void *)pmbox);
+
+	rc = ERANGE;
+	return (rc);
+}
+
+int
+lpfc_ioctl_hba_discportattributes(lpfcHBA_t * phba,
+				  LPFCCMDINPUT_t * cip, void *dataout)
+{
+	HBA_PORTATTRIBUTES *hp;
+	LPFC_NODELIST_t *pndl;
+	struct list_head *pos, *listp;
+	struct list_head *node_list[2];
+	lpfc_vpd_t *vp;
+	LPFC_SLI_t *psli;
+	uint32_t refresh, offset, cnt;
+	MAILBOX_t *pmbox;
+	int rc = 0;
+	int i;
+
+	/* Allocate mboxq structure */
+	pmbox = kmalloc(sizeof (MAILBOX_t), GFP_ATOMIC);
+	if (!pmbox)
+		return (ENOMEM);
+
+	psli = &phba->sli;
+	hp = (HBA_PORTATTRIBUTES *) dataout;
+	vp = &phba->vpd;
+	memset(dataout, 0, (sizeof (HBA_PORTATTRIBUTES)));
+	offset = (ulong) cip->lpfc_arg2;
+	refresh = (ulong) cip->lpfc_arg3;
+	if (refresh != phba->nport_event_cnt) {
+		/* This is an error, need refresh, just return zero'ed out
+		 * portattr and FcID as -1.
+		 */
+		hp->PortFcId = 0xffffffff;
+		return (rc);
+	}
+	cnt = 0;
+
+	/* First Mapped ports, then unMapped ports */
+	node_list[0] = &phba->fc_nlpmap_list;
+	node_list[1] = &phba->fc_nlpunmap_list;
+	for (i = 0; i < 2; i++) {
+		listp = node_list[i];
+		if (list_empty(listp)) 
+			continue;
+		list_for_each(pos, listp) {
+			pndl = list_entry(pos, LPFC_NODELIST_t, nlp_listp);	
+			if (cnt == offset) {
+				/* handle found port */
+				rc = lpfc_ioctl_found_port(phba, pndl, dataout, pmbox, hp);
+
+				/* Free allocated mbox memory */
+				if (pmbox)
+					kfree((void *)pmbox);
+				return (rc);
+			}
+		cnt++;
+		}
+	}
+
+	rc = ERANGE;
+
+	/* Free allocated mbox memory */
+	if (pmbox)
+		kfree((void *)pmbox);
+	return (rc);
+}
+
+int
+lpfc_ioctl_hba_indexportattributes(lpfcHBA_t * phba,
+				   LPFCCMDINPUT_t * cip, void *dataout)
+{
+	HBA_PORTATTRIBUTES *hp;
+	lpfc_vpd_t *vp;
+	LPFC_NODELIST_t *pndl;
+	struct list_head *pos;
+	uint32_t refresh, offset, cnt;
+	MAILBOX_t *pmbox;
+	int rc = 0;
+
+	/* Allocate mboxq structure */
+	pmbox = kmalloc(sizeof (MAILBOX_t), GFP_ATOMIC);
+	if (!pmbox)
+		return (ENOMEM);
+
+	vp = &phba->vpd;
+	hp = (HBA_PORTATTRIBUTES *) dataout;
+	memset(dataout, 0, (sizeof (HBA_PORTATTRIBUTES)));
+	offset = (ulong) cip->lpfc_arg2;
+	refresh = (ulong) cip->lpfc_arg3;
+	if (refresh != phba->nport_event_cnt) {
+		/* This is an error, need refresh, just return zero'ed out
+		 * portattr and FcID as -1.
+		 */
+		hp->PortFcId = 0xffffffff;
+
+		/* Free allocated mbox memory */
+		if (pmbox)
+			kfree((void *)pmbox);
+
+		return (rc);
+	}
+	cnt = 0;
+	/* Mapped NPorts only */
+	list_for_each(pos, &phba->fc_nlpmap_list) {
+		pndl = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+		if (cnt == offset) {
+			/* handle found port */
+			rc = lpfc_ioctl_found_port(phba, pndl, dataout, pmbox, hp);
+			/* Free allocated mbox memory */
+			if (pmbox)
+				kfree((void *)pmbox);
+			return (rc);
+		}
+		cnt++;
+	}
+
+	/* Free allocated mbox memory */
+	if (pmbox)
+		kfree((void *)pmbox);
+
+	rc = ERANGE;
+	return (rc);
+}
+
+int
+lpfc_ioctl_hba_setmgmtinfo(lpfcHBA_t * phba,
+			   LPFCCMDINPUT_t * cip)
+{
+
+	HBA_MGMTINFO *mgmtinfo;
+	int rc = 0;
+	unsigned long iflag;
+
+	mgmtinfo = kmalloc(4096, GFP_ATOMIC);
+	if (!mgmtinfo)
+		return(ENOMEM);
+
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	if (copy_from_user
+	    ((uint8_t *) mgmtinfo, (uint8_t *) cip->lpfc_arg1,
+	     sizeof (HBA_MGMTINFO))) {
+		LPFC_DRVR_LOCK(phba, iflag);
+		rc = EIO;
+		kfree(mgmtinfo);
+		return (rc);
+	}
+	LPFC_DRVR_LOCK(phba, iflag);
+
+	/* Can ONLY set UDP port and IP Address */
+	phba->ipVersion = mgmtinfo->IPVersion;
+	phba->UDPport = mgmtinfo->UDPPort;
+	if (phba->ipVersion == RNID_IPV4) {
+		memcpy((uint8_t *) & phba->ipAddr[0],
+		       (uint8_t *) & mgmtinfo->IPAddress[0], 4);
+	} else {
+		memcpy((uint8_t *) & phba->ipAddr[0],
+		       (uint8_t *) & mgmtinfo->IPAddress[0], 16);
+	}
+
+	kfree(mgmtinfo);
+	return (rc);
+}
+
+int
+lpfc_ioctl_hba_getmgmtinfo(lpfcHBA_t * phba,
+			   LPFCCMDINPUT_t * cip, void *dataout)
+{
+
+	HBA_MGMTINFO *mgmtinfo;
+	int rc = 0;
+
+	mgmtinfo = (HBA_MGMTINFO *) dataout;
+	memcpy((uint8_t *) & mgmtinfo->wwn, (uint8_t *) & phba->fc_nodename, 8);
+	mgmtinfo->unittype = RNID_HBA;
+	mgmtinfo->PortId = phba->fc_myDID;
+	mgmtinfo->NumberOfAttachedNodes = 0;
+	mgmtinfo->TopologyDiscoveryFlags = 0;
+	mgmtinfo->IPVersion = phba->ipVersion;
+	mgmtinfo->UDPPort = phba->UDPport;
+	if (phba->ipVersion == RNID_IPV4) {
+		memcpy((void *)&mgmtinfo->IPAddress[0],
+		       (void *)&phba->ipAddr[0], 4);
+	} else {
+		memcpy((void *)&mgmtinfo->IPAddress[0],
+		       (void *)&phba->ipAddr[0], 16);
+	}
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_hba_refreshinfo(lpfcHBA_t * phba,
+			   LPFCCMDINPUT_t * cip, void *dataout)
+{
+	uint32_t *lptr;
+	int rc = 0;
+
+	lptr = (uint32_t *) dataout;
+	*lptr = phba->nport_event_cnt;
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_hba_rnid(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip, void *dataout)
+{
+
+	HBA_WWN idn;
+	LPFC_SLI_t *psli;
+	LPFC_IOCBQ_t *cmdiocbq = 0;
+	LPFC_IOCBQ_t *rspiocbq = 0;
+	RNID *prsp;
+	uint32_t *pcmd;
+	uint32_t *psta;
+	IOCB_t *rsp;
+	LPFC_SLI_RING_t *pring;
+	void *context2;		/* both prep_iocb and iocb_wait use this */
+	int i0;
+	uint16_t siz;
+	unsigned long iflag;
+	int rtnbfrsiz;
+	LPFC_NODELIST_t *pndl;
+	int rc = 0;
+
+	psli = &phba->sli;
+	pring = &psli->ring[LPFC_ELS_RING];
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	if (copy_from_user((uint8_t *) & idn, (uint8_t *) cip->lpfc_arg1,
+			   (ulong) (sizeof (HBA_WWN)))) {
+		rc = EIO;
+		LPFC_DRVR_LOCK(phba, iflag);
+		return (rc);
+	}
+	LPFC_DRVR_LOCK(phba, iflag);
+
+	if (cip->lpfc_flag == NODE_WWN) {
+		pndl =
+		    lpfc_findnode_wwnn(phba,
+				       NLP_SEARCH_MAPPED | NLP_SEARCH_UNMAPPED,
+				       (NAME_TYPE *) & idn);
+	} else {
+		pndl =
+		    lpfc_findnode_wwpn(phba,
+				       NLP_SEARCH_MAPPED | NLP_SEARCH_UNMAPPED,
+				       (NAME_TYPE *) & idn);
+	}
+	if (!pndl) {
+		rc = ENODEV;
+		goto sndrndqwt;
+	}
+	for (i0 = 0;
+	     i0 < 10 && (pndl->nlp_flag & NLP_ELS_SND_MASK) == NLP_RNID_SND;
+	     i0++) {
+		iflag = phba->iflag;
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		mdelay(1000);
+		LPFC_DRVR_LOCK(phba, iflag);
+	}
+	if (i0 == 10) {
+		rc = EACCES;
+		pndl->nlp_flag &= ~NLP_RNID_SND;
+		goto sndrndqwt;
+	}
+
+	siz = 2 * sizeof (uint32_t);
+	/*  lpfc_prep_els_iocb sets the following: */
+
+	if (!
+	    (cmdiocbq =
+	     lpfc_prep_els_iocb(phba, 1, siz, 0, pndl, ELS_CMD_RNID))) {
+		rc = ENOMEM;
+		goto sndrndqwt;
+	}
+    /************************************************************************/
+	/*  context2 is used by prep/free to locate cmd and rsp buffers,   */
+	/*  but context2 is also used by iocb_wait to hold a rspiocb ptr, so    */
+	/*  the rsp iocbq can be returned from the completion routine for       */
+	/*  iocb_wait, so, save the prep/free value locally ... it will be      */
+	/*  restored after returning from iocb_wait.                            */
+    /************************************************************************/
+	context2 = cmdiocbq->context2;	/* needed to use lpfc_els_free_iocb */
+	if ((rspiocbq = lpfc_iocb_alloc(phba, MEM_PRI)) == 0) {
+		rc = ENOMEM;
+		goto sndrndqwt;
+	}
+	memset((void *)rspiocbq, 0, sizeof (LPFC_IOCBQ_t));
+	rsp = &(rspiocbq->iocb);
+
+	pcmd = (uint32_t *) (((DMABUF_t *) cmdiocbq->context2)->virt);
+	*pcmd++ = ELS_CMD_RNID;
+	memset((void *)pcmd, 0, sizeof (RNID));	/* fill in RNID payload */
+	((RNID *) pcmd)->Format = 0;	/* following makes it more interesting */
+	((RNID *) pcmd)->Format = RNID_TOPOLOGY_DISC;
+	cmdiocbq->context1 = (uint8_t *) 0;
+	cmdiocbq->context2 = (uint8_t *) 0;
+	cmdiocbq->iocb_flag |= LPFC_IO_LIBDFC;
+	for (rc = -1, i0 = 0; i0 < 4 && rc != IOCB_SUCCESS; i0++) {
+		pndl->nlp_flag |= NLP_RNID_SND;
+		rc = lpfc_sli_issue_iocb_wait(phba, pring, cmdiocbq,
+					      SLI_IOCB_USE_TXQ, rspiocbq,
+					      (phba->fc_ratov * 2) +
+					      LPFC_DRVR_TIMEOUT);
+		pndl->nlp_flag &= ~NLP_RNID_SND;
+		cmdiocbq->context2 = context2;
+		if (rc == IOCB_ERROR) {
+			rc = EACCES;
+			goto sndrndqwt;
+		}
+	}
+	if (rc != IOCB_SUCCESS) {
+		goto sndrndqwt;
+	}
+
+	if (rsp->ulpStatus) {
+		rc = EACCES;
+	} else {
+		struct lpfc_dmabuf *buf_ptr1, *buf_ptr;
+		buf_ptr1 = (struct lpfc_dmabuf *)(cmdiocbq->context2);
+                buf_ptr = list_entry(buf_ptr1->list.next, struct lpfc_dmabuf,
+                                                                        list);
+                psta = (uint32_t*)buf_ptr->virt;
+
+		prsp = (RNID *) (psta + 1);	/*  then rnid response data */
+		if (*psta != ELS_CMD_ACC) {
+			rc = EFAULT;
+			goto sndrndqwt;
+		}
+		rtnbfrsiz = prsp->CommonLen + prsp->SpecificLen;
+		memcpy((uint8_t *) dataout, (uint8_t *) prsp, rtnbfrsiz);
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		if (copy_to_user
+		    ((uint8_t *) cip->lpfc_arg2, (uint8_t *) & rtnbfrsiz,
+		     sizeof (int)))
+			rc = EIO;
+		LPFC_DRVR_LOCK(phba, iflag);
+	}
+      sndrndqwt:
+	if (cmdiocbq)
+		lpfc_els_free_iocb(phba, cmdiocbq);
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_hba_getevent(lpfcHBA_t * phba,
+			LPFCCMDINPUT_t * cip, void *dataout)
+{
+
+	uint32_t outsize, size;
+	HBAEVT_t *rec;
+	HBAEVT_t *recout;
+	int j, rc = 0;
+	unsigned long iflag;
+
+	size = (ulong) cip->lpfc_arg1;	/* size is number of event entries */
+
+	recout = (HBAEVT_t *) dataout;
+	for (j = 0; j < MAX_HBAEVT; j++) {
+		if ((j == (int)size) ||
+		    (phba->hba_event_get == phba->hba_event_put))
+			break;
+		rec = &phba->hbaevt[phba->hba_event_get];
+		memcpy((uint8_t *) recout, (uint8_t *) rec, sizeof (HBAEVT_t));
+		recout++;
+		phba->hba_event_get++;
+		if (phba->hba_event_get >= MAX_HBAEVT) {
+			phba->hba_event_get = 0;
+		}
+	}
+	outsize = j;
+
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	/* copy back size of response */
+	if (copy_to_user((uint8_t *) cip->lpfc_arg2, (uint8_t *) & outsize,
+			 sizeof (uint32_t))) {
+		rc = EIO;
+		LPFC_DRVR_LOCK(phba, iflag);
+		return (rc);
+	}
+
+	/* copy back number of missed records */
+	if (copy_to_user
+	    ((uint8_t *) cip->lpfc_arg3, (uint8_t *) & phba->hba_event_missed,
+	     sizeof (uint32_t))) {
+		rc = EIO;
+		LPFC_DRVR_LOCK(phba, iflag);
+		return (rc);
+	}
+	LPFC_DRVR_LOCK(phba, iflag);
+
+	phba->hba_event_missed = 0;
+	cip->lpfc_outsz = (uint32_t) (outsize * sizeof (HBA_EVENTINFO));
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_hba_fcptargetmapping(lpfcHBA_t * phba,
+				LPFCCMDINPUT_t * cip,
+				void *dataout, int buff_size, int *do_cp)
+{
+
+	uint32_t room = (ulong) cip->lpfc_arg1;
+	uint32_t total = 0;
+	int count = 0;
+	int size = 0;
+	int minsize;
+	int pansid;
+	union {
+		char* p;
+		HBA_FCPSCSIENTRY *se;
+#ifdef CONFIG_X86_64
+		HBA_FCPSCSIENTRY32 *se32;
+#endif /* CONFIG_X86_64 */
+	} ep;
+	char *appPtr;
+	char *drvPtr;
+	LPFCSCSILUN_t *plun;
+	LPFCSCSITARGET_t *ptarget;
+	LPFC_NODELIST_t *pndl;
+	struct list_head *pos;
+	int rc = 0;
+	struct pci_dev *pcidev;
+	struct list_head *curr, *next;
+	unsigned long iflag;
+
+#ifdef CONFIG_X86_64
+	if (cip->lpfc_cntl == LPFC_CNTL_X86_APP) {
+		appPtr = ((char *) cip->lpfc_dataout) + offsetof(HBA_FCPTARGETMAPPING32, entry);
+		drvPtr = (char *)&((HBA_FCPTARGETMAPPING32 *) dataout)->entry[0];
+		minsize = sizeof(HBA_FCPSCSIENTRY32);
+	} else {
+#endif /* CONFIG_X86_64 */
+		appPtr = ((char *) cip->lpfc_dataout) + offsetof(HBA_FCPTARGETMAPPING, entry);
+		drvPtr = (char *)&((HBA_FCPTARGETMAPPING *) dataout)->entry[0];
+		minsize = sizeof(HBA_FCPSCSIENTRY);
+#ifdef CONFIG_X86_64
+	}
+#endif /* CONFIG_X86_64 */
+
+	ep.p = drvPtr;
+
+	pcidev = phba->pcidev;
+
+	/* Mapped ports only */
+	list_for_each(pos, &phba->fc_nlpmap_list) {
+		pndl = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+		pansid = pndl->nlp_sid;
+		if (pansid > MAX_FCP_TARGET) {
+			continue;
+		}
+		ptarget = phba->device_queue_hash[pansid];
+		if (!ptarget) {
+			continue;
+		}
+
+		list_for_each_safe(curr, next, &ptarget->lunlist) {
+			plun = list_entry(curr, LPFCSCSILUN_t, list);
+
+			if (!(plun->failMask) && !(plun->lunFlag && LUN_BLOCKED)) {
+				if (count < room) {
+					HBA_OSDN *osdn;
+					uint32_t fcpLun[2];
+
+					if ((buff_size - size) < minsize) {
+						/*  Not enuough space left; we have to 
+						 *  copy what we have now back to 
+						 *  application space, before reusing
+						 *  this buffer again.
+						 */
+						LPFC_DRVR_UNLOCK(phba, iflag);
+						if ( copy_to_user(appPtr,
+								  drvPtr,
+								  size)) {
+							LPFC_DRVR_LOCK(phba, iflag);
+							return(EIO);
+						}
+						LPFC_DRVR_LOCK(phba, iflag);
+						appPtr += size;
+						ep.p = drvPtr;
+						size = 0;
+					}
+
+#ifdef CONFIG_X86_64
+					if (cip->lpfc_cntl == LPFC_CNTL_X86_APP) {
+						memset((void *)ep.se32->ScsiId.OSDeviceName,
+						       0, 256);
+						/* OSDeviceName is device info filled into HBA_OSDN */
+						osdn =
+							(HBA_OSDN *) & ep.se32->ScsiId.
+							OSDeviceName[0];
+						memcpy(osdn->drvname, LPFC_DRIVER_NAME,
+						       4);
+						osdn->instance = phba->brd_no;
+						osdn->target = pansid;
+						osdn->lun = (uint32_t) (plun->lun_id);
+						osdn->flags = 0;
+						ep.se32->ScsiId.ScsiTargetNumber = pansid;
+						ep.se32->ScsiId.ScsiOSLun =
+							(uint32_t) (plun->lun_id);
+						ep.se32->ScsiId.ScsiBusNumber = 0;
+						ep.se32->FcpId.FcId = pndl->nlp_DID;
+						memset((char *)fcpLun, 0,
+						       sizeof (HBA_UINT64));
+						fcpLun[0] = (plun->lun_id << FC_LUN_SHIFT);
+						if (ptarget->addrMode ==
+						    VOLUME_SET_ADDRESSING) {
+							fcpLun[0] |=
+								be32_to_cpu(0x40000000);
+						}
+						memcpy((char *)&ep.se32->FcpId.FcpLun,
+						       (char *)&fcpLun[0],
+						       sizeof (HBA_UINT64));
+						memcpy((uint8_t *) & ep.se32->FcpId.PortWWN,
+						       &pndl->nlp_portname,
+						       sizeof (HBA_WWN));
+						memcpy((uint8_t *) & ep.se32->FcpId.NodeWWN,
+						       &pndl->nlp_nodename,
+						       sizeof (HBA_WWN));
+						count++;
+						ep.se32++;
+						size += sizeof(HBA_FCPSCSIENTRY32);
+					} else {
+#endif /* CONFIG_X86_64 */
+						memset((void *)ep.se->ScsiId.OSDeviceName,
+						       0, 256);
+						/* OSDeviceName is device info filled into HBA_OSDN */
+						osdn =
+							(HBA_OSDN *) & ep.se->ScsiId.
+							OSDeviceName[0];
+						memcpy(osdn->drvname, LPFC_DRIVER_NAME,
+						       4);
+						osdn->instance = phba->brd_no;
+						osdn->target = pansid;
+						osdn->lun = (uint32_t) (plun->lun_id);
+						osdn->flags = 0;
+						ep.se->ScsiId.ScsiTargetNumber = pansid;
+						ep.se->ScsiId.ScsiOSLun =
+							(uint32_t) (plun->lun_id);
+						ep.se->ScsiId.ScsiBusNumber = 0;
+						ep.se->FcpId.FcId = pndl->nlp_DID;
+						memset((char *)fcpLun, 0,
+						       sizeof (HBA_UINT64));
+						fcpLun[0] = (plun->lun_id << FC_LUN_SHIFT);
+						if (ptarget->addrMode ==
+						    VOLUME_SET_ADDRESSING) {
+							fcpLun[0] |=
+								be32_to_cpu(0x40000000);
+						}
+						memcpy((char *)&ep.se->FcpId.FcpLun,
+						       (char *)&fcpLun[0],
+						       sizeof (HBA_UINT64));
+						memcpy((uint8_t *) & ep.se->FcpId.PortWWN,
+						       &pndl->nlp_portname,
+						       sizeof (HBA_WWN));
+						memcpy((uint8_t *) & ep.se->FcpId.NodeWWN,
+						       &pndl->nlp_nodename,
+						       sizeof (HBA_WWN));
+						count++;
+						ep.se++;
+						size += sizeof(HBA_FCPSCSIENTRY);
+#ifdef CONFIG_X86_64
+					}
+#endif /* CONFIG_X86_64 */
+				}
+				total++;
+			}
+		}
+	}
+
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	if (copy_to_user(appPtr, drvPtr, size)) {
+		LPFC_DRVR_LOCK(phba, iflag);
+		return(EIO);
+	}
+	LPFC_DRVR_LOCK(phba, iflag);
+
+#ifdef CONFIG_X86_64
+	if (cip->lpfc_cntl == LPFC_CNTL_X86_APP)
+		((HBA_FCPTARGETMAPPING32 *) dataout)->NumberOfEntries = total;
+	else
+#endif /* CONFIG_X86_64 */
+		((HBA_FCPTARGETMAPPING *) dataout)->NumberOfEntries = total;
+
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	if (copy_to_user(cip->lpfc_dataout, &total, sizeof(HBA_UINT32))) {
+		LPFC_DRVR_LOCK(phba, iflag);
+		return(EIO);
+	}
+	LPFC_DRVR_LOCK(phba, iflag);
+	cip->lpfc_outsz = 0;
+	if (total > room) {
+		rc = ERANGE;
+		*do_cp = 1;
+	}
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_hba_fcpbinding(lpfcHBA_t * phba,
+			  LPFCCMDINPUT_t * cip, void *dataout, int size, int *do_cp)
+{
+	struct list_head *pos;
+	uint32_t room;
+	uint32_t total = 0;
+	uint32_t pansid;
+	uint32_t fcpLun[2];
+	int memsz = 0;
+	int cnt = 0;
+	int rc = 0;
+	char *appPtr;
+	char *drvPtr;
+	union {
+		char* p;
+		HBA_FCPBINDINGENTRY *se;
+#ifdef CONFIG_X86_64
+		HBA_FCPBINDINGENTRY32 *se32;
+#endif /* CONFIG_X86_64 */
+	} ep;
+	LPFCSCSILUN_t *plun;
+	LPFCSCSITARGET_t *ptarget;
+	LPFC_BINDLIST_t *pbdl;
+	LPFC_NODELIST_t *pndl;
+	HBA_OSDN *osdn;
+	uint32_t total_mem = size;
+	int minsize;
+	unsigned long iflag;
+	struct pci_dev *pcidev;
+	struct list_head *curr, *next;
+
+#ifdef CONFIG_X86_64
+	if (cip->lpfc_cntl == LPFC_CNTL_X86_APP) {
+		appPtr = ((char *) cip->lpfc_dataout) + offsetof(HBA_FCPBINDING32, entry);
+		drvPtr = (char *)&((HBA_FCPBINDING32 *) dataout)->entry[0];
+		minsize = sizeof(HBA_FCPBINDINGENTRY32);
+	} else {
+#endif /* CONFIG_X86_64 */
+		appPtr = ((char *) cip->lpfc_dataout) + offsetof(HBA_FCPBINDING, entry);
+		drvPtr = (char *)&((HBA_FCPBINDING *) dataout)->entry[0];
+		minsize = sizeof(HBA_FCPBINDINGENTRY);
+#ifdef CONFIG_X86_64
+	}
+#endif /* CONFIG_X86_64 */
+
+	ep.p = drvPtr;
+
+	pcidev = phba->pcidev;
+
+	room = (uint32_t)((ulong)cip->lpfc_arg1);
+
+	/* First Mapped ports */
+	list_for_each(pos, &phba->fc_nlpmap_list) {
+		pndl = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+		if (pndl->nlp_flag & NLP_SEED_MASK) {
+			pansid = pndl->nlp_sid;
+			if (pansid > MAX_FCP_TARGET) {
+				continue;
+			}
+			ptarget = phba->device_queue_hash[pansid];
+			if (!ptarget) {
+				continue;
+			}
+
+			list_for_each_safe(curr, next, &ptarget->lunlist) {
+				plun = list_entry(curr, LPFCSCSILUN_t, list);
+
+				if (!(plun->failMask) && !(plun->lunFlag && LUN_BLOCKED)) {
+					if (cnt < room) {
+						/* if not enuf space left then we have to copy what we 
+						 *  have now back to application space, before reusing 
+						 *  this buffer again.
+						 */
+						if (total_mem - memsz < minsize) {
+							LPFC_DRVR_UNLOCK(phba, iflag);
+							if (copy_to_user
+							    ((uint8_t *) appPtr,
+							     (uint8_t *) drvPtr,
+							     memsz)) {
+								LPFC_DRVR_LOCK(phba,
+									       iflag);
+								return EIO;
+							}
+							LPFC_DRVR_LOCK(phba, iflag);
+							appPtr = appPtr + memsz;
+							ep.p = drvPtr;
+							memsz = 0;
+						}
+#ifdef CONFIG_X86_64
+						if (cip->lpfc_cntl == LPFC_CNTL_X86_APP) {
+							memset((void *)ep.se32->ScsiId.OSDeviceName,
+							       0, 256);
+							/* OSDeviceName is device info filled into HBA_OSDN */
+							osdn =
+								(HBA_OSDN *) & ep.se32->ScsiId.
+								OSDeviceName[0];
+							memcpy(osdn->drvname, LPFC_DRIVER_NAME,
+							       4);
+							osdn->instance = phba->brd_no;
+							osdn->target = pansid;
+							osdn->lun = (uint32_t) (plun->lun_id);
+							ep.se32->ScsiId.ScsiTargetNumber =
+								pansid;
+							ep.se32->ScsiId.ScsiOSLun =
+								(uint32_t) (plun->lun_id);
+							ep.se32->ScsiId.ScsiBusNumber = 0;
+							memset((char *)fcpLun, 0,
+							       sizeof (HBA_UINT64));
+							fcpLun[0] =
+								(plun->lun_id << FC_LUN_SHIFT);
+							if (ptarget->addrMode ==
+							    VOLUME_SET_ADDRESSING) {
+								fcpLun[0] |=
+									be32_to_cpu(0x40000000);
+							}
+							memcpy((char *)&ep.se32->FcpId.FcpLun,
+							       (char *)&fcpLun[0],
+							       sizeof (HBA_UINT64));
+
+							if (pndl->nlp_flag & NLP_SEED_DID) {
+								ep.se32->type = TO_D_ID;
+								ep.se32->FcpId.FcId = pndl->nlp_DID;
+								ep.se32->FcId = pndl->nlp_DID;
+								memset((uint8_t *) & ep.se32->FcpId.
+								       PortWWN, 0,
+								       sizeof (HBA_WWN));
+								memset((uint8_t *) & ep.se32->FcpId.
+								       NodeWWN, 0,
+								       sizeof (HBA_WWN));
+							} else {
+								ep.se32->type = TO_WWN;
+								ep.se32->FcId = 0;
+								ep.se32->FcpId.FcId = 0;
+								if (pndl->
+								    nlp_flag & NLP_SEED_WWPN) {
+									memcpy((uint8_t *) &
+									       ep.se32->FcpId.
+									       PortWWN,
+									       &pndl->
+									       nlp_portname,
+									       sizeof
+									       (HBA_WWN));
+								} else {
+									memcpy((uint8_t *) &
+									       ep.se32->FcpId.
+									       NodeWWN,
+									       &pndl->
+									       nlp_nodename,
+									       sizeof
+									       (HBA_WWN));
+								}
+							}
+							ep.se32->FcpId.FcId = pndl->nlp_DID;
+							memcpy((uint8_t *) & ep.se32->FcpId.PortWWN,
+							       &pndl->nlp_portname,
+							       sizeof (HBA_WWN));
+							memcpy((uint8_t *) & ep.se32->FcpId.NodeWWN,
+							       &pndl->nlp_nodename,
+							       sizeof (HBA_WWN));
+							ep.se32++;
+							cnt++;
+							memsz += minsize;
+						} else {
+#endif /* CONFIG_X86_64 */
+							memset((void *)ep.se->ScsiId.OSDeviceName,
+							       0, 256);
+							/* OSDeviceName is device info filled into HBA_OSDN */
+							osdn =
+								(HBA_OSDN *) & ep.se->ScsiId.
+								OSDeviceName[0];
+							memcpy(osdn->drvname, LPFC_DRIVER_NAME,
+							       4);
+							osdn->instance = phba->brd_no;
+							osdn->target = pansid;
+							osdn->lun = (uint32_t) (plun->lun_id);
+							ep.se->ScsiId.ScsiTargetNumber =
+								pansid;
+							ep.se->ScsiId.ScsiOSLun =
+								(uint32_t) (plun->lun_id);
+							ep.se->ScsiId.ScsiBusNumber = 0;
+							memset((char *)fcpLun, 0,
+							       sizeof (HBA_UINT64));
+							fcpLun[0] =
+								(plun->lun_id << FC_LUN_SHIFT);
+							if (ptarget->addrMode ==
+							    VOLUME_SET_ADDRESSING) {
+								fcpLun[0] |=
+									be32_to_cpu(0x40000000);
+							}
+							memcpy((char *)&ep.se->FcpId.FcpLun,
+							       (char *)&fcpLun[0],
+							       sizeof (HBA_UINT64));
+
+							if (pndl->nlp_flag & NLP_SEED_DID) {
+								ep.se->type = TO_D_ID;
+								ep.se->FcpId.FcId = pndl->nlp_DID;
+								ep.se->FcId = pndl->nlp_DID;
+								memset((uint8_t *) & ep.se->FcpId.
+								       PortWWN, 0,
+								       sizeof (HBA_WWN));
+								memset((uint8_t *) & ep.se->FcpId.
+								       NodeWWN, 0,
+								       sizeof (HBA_WWN));
+							} else {
+								ep.se->type = TO_WWN;
+								ep.se->FcId = 0;
+								ep.se->FcpId.FcId = 0;
+								if (pndl->
+								    nlp_flag & NLP_SEED_WWPN) {
+									memcpy((uint8_t *) &
+									       ep.se->FcpId.
+									       PortWWN,
+									       &pndl->
+									       nlp_portname,
+									       sizeof
+									       (HBA_WWN));
+								} else {
+									memcpy((uint8_t *) &
+									       ep.se->FcpId.
+									       NodeWWN,
+									       &pndl->
+									       nlp_nodename,
+									       sizeof
+									       (HBA_WWN));
+								}
+							}
+							ep.se->FcpId.FcId = pndl->nlp_DID;
+							memcpy((uint8_t *) & ep.se->FcpId.PortWWN,
+							       &pndl->nlp_portname,
+							       sizeof (HBA_WWN));
+							memcpy((uint8_t *) & ep.se->FcpId.NodeWWN,
+							       &pndl->nlp_nodename,
+							       sizeof (HBA_WWN));
+							ep.se++;
+							cnt++;
+							memsz += minsize;
+#ifdef CONFIG_X86_64
+						}
+#endif /* CONFIG_X86_64 */
+					}
+					total++;
+				}
+			}
+		}
+	}			/* end searching mapped list */
+
+	/* then unmapped ports */
+	list_for_each(pos, &phba->fc_nlpunmap_list) {
+		pndl = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+		if (pndl->nlp_flag & NLP_SEED_MASK) {
+			pansid = pndl->nlp_sid;
+			if (pansid > MAX_FCP_TARGET) {
+				continue;
+			}
+			ptarget = phba->device_queue_hash[pansid];
+			if (!ptarget) {
+				continue;
+			}
+
+			list_for_each_safe(curr, next, &ptarget->lunlist) {
+				plun = list_entry(curr, LPFCSCSILUN_t , list);
+
+				if (cnt < room) {
+					/* if not enuf space left then we have to copy what we 
+					 *  have now back to application space, before reusing 
+					 *  this buffer again.
+					 */
+					if (total_mem - memsz < minsize) {
+						LPFC_DRVR_UNLOCK(phba, iflag);
+						if (copy_to_user
+						    ((uint8_t *) appPtr,
+						     (uint8_t *) drvPtr,
+						     memsz)) {
+							LPFC_DRVR_LOCK(phba,
+								      iflag);
+							return EIO;
+						}
+						LPFC_DRVR_LOCK(phba, iflag);
+						appPtr = appPtr + memsz;
+						ep.p = drvPtr;
+						memsz = 0;
+					}
+#ifdef CONFIG_X86_64
+					if (cip->lpfc_cntl == LPFC_CNTL_X86_APP) {
+						memset((void *)ep.se32->ScsiId.OSDeviceName,
+						       0, 256);
+						/* OSDeviceName is device info filled into HBA_OSDN */
+						osdn =
+							(HBA_OSDN *) & ep.se32->ScsiId.
+							OSDeviceName[0];
+						memcpy(osdn->drvname, LPFC_DRIVER_NAME,
+						       4);
+						osdn->instance = phba->brd_no;
+						osdn->target = pansid;
+						osdn->lun = (uint32_t) (plun->lun_id);
+						ep.se32->ScsiId.ScsiTargetNumber =
+							pansid;
+						ep.se32->ScsiId.ScsiOSLun =
+							(uint32_t) (plun->lun_id);
+						ep.se32->ScsiId.ScsiBusNumber = 0;
+						memset((char *)fcpLun, 0,
+						       sizeof (HBA_UINT64));
+						fcpLun[0] =
+							(plun->lun_id << FC_LUN_SHIFT);
+						if (ptarget->addrMode ==
+						    VOLUME_SET_ADDRESSING) {
+							fcpLun[0] |=
+								be32_to_cpu(0x40000000);
+						}
+						memcpy((char *)&ep.se32->FcpId.FcpLun,
+						       (char *)&fcpLun[0],
+						       sizeof (HBA_UINT64));
+						
+						if (pndl->nlp_flag & NLP_SEED_DID) {
+							ep.se32->type = TO_D_ID;
+							ep.se32->FcpId.FcId = pndl->nlp_DID;
+							ep.se32->FcId = pndl->nlp_DID;
+							memset((uint8_t *) & ep.se32->FcpId.
+							       PortWWN, 0,
+							       sizeof (HBA_WWN));
+							memset((uint8_t *) & ep.se32->FcpId.
+							       NodeWWN, 0,
+							       sizeof (HBA_WWN));
+						} else {
+							ep.se32->type = TO_WWN;
+							ep.se32->FcId = 0;
+							ep.se32->FcpId.FcId = 0;
+							if (pndl->
+							    nlp_flag & NLP_SEED_WWPN) {
+								memcpy((uint8_t *) &
+								       ep.se32->FcpId.
+								       PortWWN,
+								       &pndl->
+								       nlp_portname,
+								       sizeof
+								       (HBA_WWN));
+							} else {
+								memcpy((uint8_t *) &
+								       ep.se32->FcpId.
+								       NodeWWN,
+								       &pndl->
+								       nlp_nodename,
+								       sizeof
+								       (HBA_WWN));
+							}
+						}
+						ep.se32->FcpId.FcId = pndl->nlp_DID;
+						memcpy((uint8_t *) & ep.se32->FcpId.PortWWN,
+						       &pndl->nlp_portname,
+						       sizeof (HBA_WWN));
+						memcpy((uint8_t *) & ep.se32->FcpId.NodeWWN,
+						       &pndl->nlp_nodename,
+						       sizeof (HBA_WWN));
+						ep.se32++;
+						cnt++;
+						memsz += minsize;
+					} else {
+#endif /* CONFIG_X86_64 */
+						memset((void *)ep.se->ScsiId.OSDeviceName,
+						       0, 256);
+						/* OSDeviceName is device info filled into HBA_OSDN */
+						osdn =
+							(HBA_OSDN *) & ep.se->ScsiId.
+							OSDeviceName[0];
+						memcpy(osdn->drvname, LPFC_DRIVER_NAME,
+						       4);
+						osdn->instance = phba->brd_no;
+						osdn->target = pansid;
+						osdn->lun = (uint32_t) (plun->lun_id);
+						ep.se->ScsiId.ScsiTargetNumber =
+							pansid;
+						ep.se->ScsiId.ScsiOSLun =
+							(uint32_t) (plun->lun_id);
+						ep.se->ScsiId.ScsiBusNumber = 0;
+						memset((char *)fcpLun, 0,
+						       sizeof (HBA_UINT64));
+						fcpLun[0] =
+							(plun->lun_id << FC_LUN_SHIFT);
+						if (ptarget->addrMode ==
+						    VOLUME_SET_ADDRESSING) {
+							fcpLun[0] |=
+								be32_to_cpu(0x40000000);
+						}
+						memcpy((char *)&ep.se->FcpId.FcpLun,
+						       (char *)&fcpLun[0],
+						       sizeof (HBA_UINT64));
+						
+						if (pndl->nlp_flag & NLP_SEED_DID) {
+							ep.se->type = TO_D_ID;
+							ep.se->FcpId.FcId = pndl->nlp_DID;
+							ep.se->FcId = pndl->nlp_DID;
+							memset((uint8_t *) & ep.se->FcpId.
+							       PortWWN, 0,
+							       sizeof (HBA_WWN));
+							memset((uint8_t *) & ep.se->FcpId.
+							       NodeWWN, 0,
+							       sizeof (HBA_WWN));
+						} else {
+							ep.se->type = TO_WWN;
+							ep.se->FcId = 0;
+							ep.se->FcpId.FcId = 0;
+							if (pndl->
+							    nlp_flag & NLP_SEED_WWPN) {
+								memcpy((uint8_t *) &
+								       ep.se->FcpId.
+								       PortWWN,
+								       &pndl->
+								       nlp_portname,
+								       sizeof
+								       (HBA_WWN));
+							} else {
+								memcpy((uint8_t *) &
+								       ep.se->FcpId.
+								       NodeWWN,
+								       &pndl->
+								       nlp_nodename,
+								       sizeof
+								       (HBA_WWN));
+							}
+						}
+						ep.se->FcpId.FcId = pndl->nlp_DID;
+						memcpy((uint8_t *) & ep.se->FcpId.PortWWN,
+						       &pndl->nlp_portname,
+						       sizeof (HBA_WWN));
+						memcpy((uint8_t *) & ep.se->FcpId.NodeWWN,
+						       &pndl->nlp_nodename,
+						       sizeof (HBA_WWN));
+						ep.se++;
+						cnt++;
+						memsz += minsize;
+#ifdef CONFIG_X86_64
+					}
+#endif /* CONFIG_X86_64 */
+				}
+				total++;
+			}
+		}
+	}			/* end searching unmapped list */
+
+	/* search binding list */
+	list_for_each(pos, &phba->fc_nlpbind_list) {
+		pbdl = list_entry(pos, LPFC_BINDLIST_t, nlp_listp);
+		if (pbdl->nlp_bind_type & FCP_SEED_MASK) {
+			pansid = pbdl->nlp_sid;
+			if (pansid > MAX_FCP_TARGET) {
+				continue;
+			}
+			if (cnt < room) {
+				/* if not enough space left then we
+				 *  have to copy what we have now back
+				 *  to application space, before
+				 *  reusing this buffer again.
+				 */
+				if (total_mem - memsz < minsize) {
+					LPFC_DRVR_UNLOCK(phba, iflag);
+					if (copy_to_user
+					    ((uint8_t *) appPtr,
+					     (uint8_t *) drvPtr,
+					     memsz)) {
+						LPFC_DRVR_LOCK(phba, iflag);
+						return EIO;
+					}
+					LPFC_DRVR_LOCK(phba, iflag);
+					appPtr = appPtr + memsz;
+					ep.p = drvPtr;
+					memsz = 0;
+				}
+#ifdef CONFIG_X86_64
+				if (cip->lpfc_cntl == LPFC_CNTL_X86_APP) {
+					memset((void *)ep.se32->ScsiId.OSDeviceName, 0, 256);
+					ep.se32->ScsiId.ScsiTargetNumber = pansid;
+					ep.se32->ScsiId.ScsiBusNumber = 0;
+					memset((char *)fcpLun, 0,
+					       sizeof (HBA_UINT64));
+					if (pbdl->nlp_bind_type & FCP_SEED_DID) {
+						ep.se32->type = TO_D_ID;
+						ep.se32->FcpId.FcId = pbdl->nlp_DID;
+						ep.se32->FcId = pbdl->nlp_DID;
+						memset((uint8_t *) & ep.se32->FcpId.PortWWN,
+						       0, sizeof (HBA_WWN));
+						memset((uint8_t *) & ep.se32->FcpId.NodeWWN,
+						       0, sizeof (HBA_WWN));
+					} else {
+						ep.se32->type = TO_WWN;
+						ep.se32->FcId = 0;
+						ep.se32->FcpId.FcId = 0;
+						if (pbdl->nlp_bind_type & FCP_SEED_WWPN) {
+							memcpy((uint8_t *) & ep.se32->FcpId.
+							       PortWWN,
+							       &pbdl->nlp_portname,
+							       sizeof (HBA_WWN));
+						} else {
+							memcpy((uint8_t *) & ep.se32->FcpId.
+							       NodeWWN,
+							       &pbdl->nlp_nodename,
+							       sizeof (HBA_WWN));
+						}
+					}
+					ep.se32->FcpId.FcId = pbdl->nlp_DID;
+					memcpy((uint8_t *) & ep.se32->FcpId.PortWWN,
+					       &pbdl->nlp_portname, sizeof (HBA_WWN));
+					memcpy((uint8_t *) & ep.se32->FcpId.NodeWWN,
+					       &pbdl->nlp_nodename, sizeof (HBA_WWN));
+					ep.se32++;
+					cnt++;
+					memsz += minsize;
+				} else {
+#endif /* CONFIG_X86_64 */
+					memset((void *)ep.se->ScsiId.OSDeviceName, 0, 256);
+					ep.se->ScsiId.ScsiTargetNumber = pansid;
+					ep.se->ScsiId.ScsiBusNumber = 0;
+					memset((char *)fcpLun, 0,
+					       sizeof (HBA_UINT64));
+					if (pbdl->nlp_bind_type & FCP_SEED_DID) {
+						ep.se->type = TO_D_ID;
+						ep.se->FcpId.FcId = pbdl->nlp_DID;
+						ep.se->FcId = pbdl->nlp_DID;
+						memset((uint8_t *) & ep.se->FcpId.PortWWN,
+						       0, sizeof (HBA_WWN));
+						memset((uint8_t *) & ep.se->FcpId.NodeWWN,
+						       0, sizeof (HBA_WWN));
+					} else {
+						ep.se->type = TO_WWN;
+						ep.se->FcId = 0;
+						ep.se->FcpId.FcId = 0;
+						if (pbdl->nlp_bind_type & FCP_SEED_WWPN) {
+							memcpy((uint8_t *) & ep.se->FcpId.
+							       PortWWN,
+							       &pbdl->nlp_portname,
+							       sizeof (HBA_WWN));
+						} else {
+							memcpy((uint8_t *) & ep.se->FcpId.
+							       NodeWWN,
+							       &pbdl->nlp_nodename,
+							       sizeof (HBA_WWN));
+						}
+					}
+					ep.se->FcpId.FcId = pbdl->nlp_DID;
+					memcpy((uint8_t *) & ep.se->FcpId.PortWWN,
+					       &pbdl->nlp_portname, sizeof (HBA_WWN));
+					memcpy((uint8_t *) & ep.se->FcpId.NodeWWN,
+					       &pbdl->nlp_nodename, sizeof (HBA_WWN));
+					ep.se++;
+					cnt++;
+					memsz += minsize;
+#ifdef CONFIG_X86_64
+				}
+#endif /* CONFIG_X86_64 */
+			}
+			total++;
+		}
+	}			/* end searching bindlist */
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	if (copy_to_user
+	    ((uint8_t *) appPtr, (uint8_t *) drvPtr, memsz)) {
+		LPFC_DRVR_LOCK(phba, iflag);
+		return EIO;
+	}
+
+#ifdef CONFIG_X86_64
+	if (cip->lpfc_cntl == LPFC_CNTL_X86_APP)
+		((HBA_FCPBINDING32 *) dataout)->NumberOfEntries = total;
+	else
+#endif /* CONFIG_X86_64 */
+		((HBA_FCPBINDING *) dataout)->NumberOfEntries = total;
+
+	if (copy_to_user(cip->lpfc_dataout, &total, sizeof (HBA_UINT32))) {
+		LPFC_DRVR_LOCK(phba, iflag);
+		return EIO;
+	}
+
+	LPFC_DRVR_LOCK(phba, iflag);
+	cip->lpfc_outsz = 0;	/* no more copy needed */
+	if (total > room) {
+		rc = ERANGE;
+		*do_cp = 1;
+	}
+	return (rc);
+}
+
+int
+lpfc_ioctl_port_attrib(lpfcHBA_t * phba, void *dataout)
+{
+	lpfc_vpd_t *vp;
+	SERV_PARM *hsp;
+	HBA_PORTATTRIBUTES *hp;
+	HBA_OSDN *osdn;
+	uint32_t cnt;
+	int rc = 0;
+
+	vp = &phba->vpd;
+	hsp = (SERV_PARM *) (&phba->fc_sparam);
+	hp = (HBA_PORTATTRIBUTES *) dataout;
+	memset(dataout, 0, (sizeof (HBA_PORTATTRIBUTES)));
+	memcpy((uint8_t *) & hp->NodeWWN,
+	       (uint8_t *) & phba->fc_sparam.nodeName, sizeof (HBA_WWN));
+	memcpy((uint8_t *) & hp->PortWWN,
+	       (uint8_t *) & phba->fc_sparam.portName, sizeof (HBA_WWN));
+
+	if (phba->fc_linkspeed == LA_2GHZ_LINK)
+		hp->PortSpeed = HBA_PORTSPEED_2GBIT;
+	else
+		hp->PortSpeed = HBA_PORTSPEED_1GBIT;
+
+	if (FC_JEDEC_ID(vp->rev.biuRev) == VIPER_JEDEC_ID)
+		hp->PortSupportedSpeed = HBA_PORTSPEED_10GBIT;
+	else if ((FC_JEDEC_ID(vp->rev.biuRev) == CENTAUR_2G_JEDEC_ID) ||
+		 (FC_JEDEC_ID(vp->rev.biuRev) == PEGASUS_JEDEC_ID) ||
+		 (FC_JEDEC_ID(vp->rev.biuRev) == THOR_JEDEC_ID))
+		hp->PortSupportedSpeed = HBA_PORTSPEED_2GBIT;
+	else
+		hp->PortSupportedSpeed = HBA_PORTSPEED_1GBIT;
+
+	hp->PortFcId = phba->fc_myDID;
+	hp->PortType = HBA_PORTTYPE_UNKNOWN;
+	if (phba->fc_topology == TOPOLOGY_LOOP) {
+		if (phba->fc_flag & FC_PUBLIC_LOOP) {
+			hp->PortType = HBA_PORTTYPE_NLPORT;
+			memcpy((uint8_t *) & hp->FabricName,
+			       (uint8_t *) & phba->fc_fabparam.nodeName,
+			       sizeof (HBA_WWN));
+		} else {
+			hp->PortType = HBA_PORTTYPE_LPORT;
+		}
+	} else {
+		if (phba->fc_flag & FC_FABRIC) {
+			hp->PortType = HBA_PORTTYPE_NPORT;
+			memcpy((uint8_t *) & hp->FabricName,
+			       (uint8_t *) & phba->fc_fabparam.nodeName,
+			       sizeof (HBA_WWN));
+		} else {
+			hp->PortType = HBA_PORTTYPE_PTP;
+		}
+	}
+
+	if (phba->fc_flag & FC_BYPASSED_MODE) {
+		hp->PortState = HBA_PORTSTATE_BYPASSED;
+	} else if (phba->fc_flag & FC_OFFLINE_MODE) {
+		hp->PortState = HBA_PORTSTATE_DIAGNOSTICS;
+	} else {
+		switch (phba->hba_state) {
+		case LPFC_INIT_START:
+		case LPFC_INIT_MBX_CMDS:
+			hp->PortState = HBA_PORTSTATE_UNKNOWN;
+			break;
+
+		case LPFC_LINK_DOWN:
+		case LPFC_LINK_UP:
+		case LPFC_LOCAL_CFG_LINK:
+		case LPFC_FLOGI:
+		case LPFC_FABRIC_CFG_LINK:
+		case LPFC_NS_REG:
+		case LPFC_NS_QRY:
+		case LPFC_BUILD_DISC_LIST:
+		case LPFC_DISC_AUTH:
+		case LPFC_CLEAR_LA:
+			hp->PortState = HBA_PORTSTATE_LINKDOWN;
+			break;
+
+		case LPFC_HBA_READY:
+			hp->PortState = HBA_PORTSTATE_ONLINE;
+			break;
+
+		case LPFC_HBA_ERROR:
+		default:
+			hp->PortState = HBA_PORTSTATE_ERROR;
+			break;
+		}
+	}
+
+	cnt = phba->fc_map_cnt + phba->fc_unmap_cnt;
+	hp->NumberofDiscoveredPorts = cnt;
+	if (hsp->cls1.classValid) {
+		hp->PortSupportedClassofService |= 2;	/* bit 1 */
+	}
+
+	if (hsp->cls2.classValid) {
+		hp->PortSupportedClassofService |= 4;	/* bit 2 */
+	}
+
+	if (hsp->cls3.classValid) {
+		hp->PortSupportedClassofService |= 8;	/* bit 3 */
+	}
+
+	hp->PortMaxFrameSize = (((uint32_t) hsp->cmn.bbRcvSizeMsb) << 8) |
+	    (uint32_t) hsp->cmn.bbRcvSizeLsb;
+
+	hp->PortSupportedFc4Types.bits[2] = 0x1;
+	hp->PortSupportedFc4Types.bits[3] = 0x20;
+	hp->PortSupportedFc4Types.bits[7] = 0x1;
+	hp->PortActiveFc4Types.bits[2] = 0x1;
+
+	hp->PortActiveFc4Types.bits[7] = 0x1;
+
+	/* OSDeviceName is the device info filled into the HBA_OSDN structure */
+	osdn = (HBA_OSDN *) & hp->OSDeviceName[0];
+	memcpy(osdn->drvname, LPFC_DRIVER_NAME, 4);
+	osdn->instance = phba->brd_no;
+	osdn->target = (uint32_t) (-1);
+	osdn->lun = (uint32_t) (-1);
+
+	return rc;
+}
+
+int
+lpfc_ioctl_found_port(lpfcHBA_t * phba,
+		      LPFC_NODELIST_t * pndl,
+		      void *dataout,
+		      MAILBOX_t * pmbox, HBA_PORTATTRIBUTES * hp)
+{
+	LPFC_SLI_t *psli = &phba->sli;
+	SERV_PARM *hsp;
+	DMABUF_t *mp;
+	HBA_OSDN *osdn;
+	LPFC_MBOXQ_t *mboxq;
+	unsigned long iflag;
+	int mbxstatus;
+	int rc = 0;
+
+	/* Check if its the local port */
+	if (phba->fc_myDID == pndl->nlp_DID) {
+		/* handle localport */
+		rc = lpfc_ioctl_port_attrib(phba, dataout);
+		return rc;
+	}
+
+	memset((void *)pmbox, 0, sizeof (MAILBOX_t));
+	pmbox->un.varRdRPI.reqRpi = (volatile uint16_t)pndl->nlp_rpi;
+	pmbox->mbxCommand = MBX_READ_RPI64;
+	pmbox->mbxOwner = OWN_HOST;
+
+	if (((mp = kmalloc(sizeof (DMABUF_t), GFP_ATOMIC)) == 0) ||
+	    ((mp->virt = lpfc_mbuf_alloc(phba, 0, &(mp->phys))) == 0)) {
+		if (mp)
+			kfree(mp);
+		return ENOMEM;
+	}
+	INIT_LIST_HEAD(&mp->list);
+	if ((mboxq = lpfc_mbox_alloc(phba, MEM_PRI)) == 0) {
+		lpfc_mbuf_free(phba, mp->virt, mp->phys);
+		kfree(mp);
+		return ENOMEM;
+	}
+
+	hsp = (SERV_PARM *) mp->virt;
+	if (psli->sliinit.sli_flag & LPFC_SLI2_ACTIVE) {
+		pmbox->un.varRdRPI.un.sp64.addrHigh = putPaddrHigh(mp->phys);
+		pmbox->un.varRdRPI.un.sp64.addrLow = putPaddrLow(mp->phys);
+		pmbox->un.varRdRPI.un.sp64.tus.f.bdeSize = sizeof (SERV_PARM);
+	} else {
+		pmbox->un.varRdRPI.un.sp.bdeAddress = putPaddrLow(mp->phys);
+		pmbox->un.varRdRPI.un.sp.bdeSize = sizeof (SERV_PARM);
+	}
+
+	memset((void *)mboxq, 0, sizeof (LPFC_MBOXQ_t));
+	mboxq->mb.mbxCommand = pmbox->mbxCommand;
+	mboxq->mb.mbxOwner = pmbox->mbxOwner;
+	mboxq->mb.un = pmbox->un;
+	mboxq->mb.us = pmbox->us;
+	mboxq->context1 = (uint8_t *) 0;
+
+	if ((phba->fc_flag & FC_OFFLINE_MODE) ||
+	    (!(psli->sliinit.sli_flag & LPFC_SLI2_ACTIVE))){
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		mbxstatus = lpfc_sli_issue_mbox(phba, mboxq, MBX_POLL);
+		LPFC_DRVR_LOCK(phba, iflag);
+	} else
+		mbxstatus =
+		    lpfc_sli_issue_mbox_wait(phba, mboxq, phba->fc_ratov * 2);
+
+	if (mbxstatus != MBX_SUCCESS) {
+		if (mbxstatus == MBX_TIMEOUT) {
+			/*
+			 * Let SLI layer to release mboxq if mbox command completed after timeout.
+			 */
+			mboxq->mbox_cmpl = 0;
+		} else {
+			lpfc_mbox_free(phba, mboxq);
+		}
+		return ENODEV;
+	}
+
+	pmbox->mbxCommand = mboxq->mb.mbxCommand;
+	pmbox->mbxOwner = mboxq->mb.mbxOwner;
+	pmbox->un = mboxq->mb.un;
+	pmbox->us = mboxq->mb.us;
+
+	if (hsp->cls1.classValid) {
+		hp->PortSupportedClassofService |= 2;	/* bit 1 */
+	}
+	if (hsp->cls2.classValid) {
+		hp->PortSupportedClassofService |= 4;	/* bit 2 */
+	}
+	if (hsp->cls3.classValid) {
+		hp->PortSupportedClassofService |= 8;	/* bit 3 */
+	}
+
+	hp->PortMaxFrameSize = (((uint32_t) hsp->cmn.bbRcvSizeMsb) << 8) |
+	    (uint32_t) hsp->cmn.bbRcvSizeLsb;
+
+	lpfc_mbuf_free(phba, mp->virt, mp->phys);
+	kfree(mp);
+	lpfc_mbox_free(phba, mboxq);
+
+	memcpy((uint8_t *) & hp->NodeWWN, (uint8_t *) & pndl->nlp_nodename,
+	       sizeof (HBA_WWN));
+	memcpy((uint8_t *) & hp->PortWWN, (uint8_t *) & pndl->nlp_portname,
+	       sizeof (HBA_WWN));
+	hp->PortSpeed = 0;
+	/* We only know the speed if the device is on the same loop as us */
+	if (((phba->fc_myDID & 0xffff00) == (pndl->nlp_DID & 0xffff00)) &&
+	    (phba->fc_topology == TOPOLOGY_LOOP)) {
+		if (phba->fc_linkspeed == LA_2GHZ_LINK)
+			hp->PortSpeed = HBA_PORTSPEED_2GBIT;
+		else
+			hp->PortSpeed = HBA_PORTSPEED_1GBIT;
+	}
+
+	hp->PortFcId = pndl->nlp_DID;
+	if ((phba->fc_flag & FC_FABRIC) &&
+	    ((phba->fc_myDID & 0xff0000) == (pndl->nlp_DID & 0xff0000))) {
+		/* If remote node is in the same domain we are in */
+		memcpy((uint8_t *) & hp->FabricName,
+		       (uint8_t *) & phba->fc_fabparam.nodeName,
+		       sizeof (HBA_WWN));
+	}
+	hp->PortState = HBA_PORTSTATE_ONLINE;
+	if (pndl->nlp_type & NLP_FCP_TARGET) {
+		hp->PortActiveFc4Types.bits[2] = 0x1;
+	}
+	hp->PortActiveFc4Types.bits[7] = 0x1;
+
+	hp->PortType = HBA_PORTTYPE_UNKNOWN;
+	if (phba->fc_topology == TOPOLOGY_LOOP) {
+		if (phba->fc_flag & FC_PUBLIC_LOOP) {
+			/* Check if Fabric port */
+			if (lpfc_geportname(&pndl->nlp_nodename,
+					    (NAME_TYPE *) & (phba->fc_fabparam.
+							     nodeName)) == 2) {
+				hp->PortType = HBA_PORTTYPE_FLPORT;
+			} else {
+				/* Based on DID */
+				if ((pndl->nlp_DID & 0xff) == 0) {
+					hp->PortType = HBA_PORTTYPE_NPORT;
+				} else {
+					if ((pndl->nlp_DID & 0xff0000) !=
+					    0xff0000) {
+						hp->PortType =
+						    HBA_PORTTYPE_NLPORT;
+					}
+				}
+			}
+		} else {
+			hp->PortType = HBA_PORTTYPE_LPORT;
+		}
+	} else {
+		if (phba->fc_flag & FC_FABRIC) {
+			/* Check if Fabric port */
+			if (lpfc_geportname(&pndl->nlp_nodename,
+					    (NAME_TYPE *) & (phba->fc_fabparam.
+							     nodeName)) == 2) {
+				hp->PortType = HBA_PORTTYPE_FPORT;
+			} else {
+				/* Based on DID */
+				if ((pndl->nlp_DID & 0xff) == 0) {
+					hp->PortType = HBA_PORTTYPE_NPORT;
+				} else {
+					if ((pndl->nlp_DID & 0xff0000) !=
+					    0xff0000) {
+						hp->PortType =
+						    HBA_PORTTYPE_NLPORT;
+					}
+				}
+			}
+		} else {
+			hp->PortType = HBA_PORTTYPE_PTP;
+		}
+	}
+
+	/* for mapped devices OSDeviceName is device info filled into HBA_OSDN 
+	 * structure */
+	if (pndl->nlp_flag & NLP_MAPPED_LIST) {
+		osdn = (HBA_OSDN *) & hp->OSDeviceName[0];
+		memcpy(osdn->drvname, LPFC_DRIVER_NAME, 4);
+		osdn->instance = phba->brd_no;
+		osdn->target = pndl->nlp_sid;
+		osdn->lun = (uint32_t) (-1);
+	}
+
+	return rc;
+}
diff -urNp linux-8155/drivers/addon/lpfc/lpfcdfc/lpfc_hbaapi_ioctl.h linux-8156/drivers/addon/lpfc/lpfcdfc/lpfc_hbaapi_ioctl.h
--- linux-8155/drivers/addon/lpfc/lpfcdfc/lpfc_hbaapi_ioctl.h
+++ linux-8156/drivers/addon/lpfc/lpfcdfc/lpfc_hbaapi_ioctl.h
@@ -0,0 +1,46 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_hbaapi_ioctl.h 484 2006-03-27 16:26:51Z sf_support $
+ */
+
+#include "hbaapi.h"
+#ifndef H_LPFC_HBAAPI_IOCTL
+#define H_LPFC_HBAAPI_IOCTL
+int lpfc_process_ioctl_hbaapi(lpfcHBA_t *phba, LPFCCMDINPUT_t *cip);
+int lpfc_ioctl_hba_adapterattributes(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_hba_portattributes(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_hba_portstatistics(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_hba_wwpnportattributes(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_hba_discportattributes(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_hba_indexportattributes(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_hba_setmgmtinfo(lpfcHBA_t *, LPFCCMDINPUT_t *);
+int lpfc_ioctl_hba_getmgmtinfo(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_hba_refreshinfo(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_hba_rnid(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_hba_getevent(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_hba_fcptargetmapping(lpfcHBA_t *, LPFCCMDINPUT_t *, void *, int, int *);
+int lpfc_ioctl_hba_fcpbinding(lpfcHBA_t *, LPFCCMDINPUT_t *, void *, int, int *);
+int lpfc_ioctl_port_attrib(lpfcHBA_t *, void *);
+int lpfc_ioctl_found_port(lpfcHBA_t *, LPFC_NODELIST_t *, void *, MAILBOX_t *, HBA_PORTATTRIBUTES *);
+void lpfc_decode_firmware_rev(lpfcHBA_t *, char *, int);
+void lpfc_get_hba_sym_node_name(lpfcHBA_t *, uint8_t *);
+#endif
diff -urNp linux-8155/drivers/addon/lpfc/lpfcdfc/lpfc_ioctl.h linux-8156/drivers/addon/lpfc/lpfcdfc/lpfc_ioctl.h
--- linux-8155/drivers/addon/lpfc/lpfcdfc/lpfc_ioctl.h
+++ linux-8156/drivers/addon/lpfc/lpfcdfc/lpfc_ioctl.h
@@ -0,0 +1,453 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_ioctl.h 328 2005-05-03 15:20:43Z sf_support $
+ */
+
+#ifndef _H_LPFC_IOCTL
+#define _H_LPFC_IOCTL
+
+#define MAX_LPFC_BRDS 32
+
+#define DFC_MAJOR_REV	1
+#define DFC_MINOR_REV	19
+
+/* LPFC Ioctls() 0x00 - 0x3F. */
+
+/* LPFC_FIRST_COMMAND_USED	0x01	    First defines Ioctl used  */
+#define LPFC_WRITE_PCI		0x01	/* Write to PCI */
+#define LPFC_READ_PCI		0x06	/* Read from PCI */
+
+/* LPFC COMMAND POSITION 0xc available.  Used to be Read ring information. */
+
+#define LPFC_READ_MEM		0x0d	/* Read memory */
+
+/* LPFC COMMAND POSITION 0xf available. */
+
+#define LPFC_MBOX		0x12	/* Issue a MB cmd */
+#define LPFC_RESET		0x13	/* Reset the adapter */
+#define LPFC_READ_HBA		0x14	/* Get adapter info */
+
+/* LPFC COMMAND POSITION 0x15 available.  Used to be Get NDD stats. */
+
+#define LPFC_WRITE_MEM		0x16	/* Write to SLIM memory */
+#define LPFC_WRITE_CTLREG	0x17	/* Write to Control register */
+#define LPFC_READ_CTLREG		0x18	/* Read from Control control register */
+#define LPFC_INITBRDS		0x19	/* Initialize the adapters */
+#define LPFC_SETDIAG		0x1a	/* Set/get board online/offline */
+#define LPFC_INST		0x1b	/* get instance info */
+#define LPFC_DEVP		0x1c	/* Get Device infotmation */
+#define LPFC_READ_BPLIST		0x2d	/* get list of buffers post */
+#define LPFC_LINKINFO		0x2f	/* get link information */
+#define LPFC_IOINFO  		0x30	/* get I/O stats */
+#define LPFC_NODEINFO  		0x31	/* get node (NPort) information */
+#define LPFC_ADD_BIND		0x36	/* Add a new binding */
+#define LPFC_DEL_BIND		0x37	/* Del a binding */
+#define LPFC_LIST_BIND		0x38	/* List binding */
+/*	LPFC_LAST_IOCTL_USED	0x38	Last LPFC Ioctl used  */
+
+
+/* LPFC Ioctls() 0x40 - 0x7F */
+
+/* LPFC_FIRST_IOCTL_USED		0x40     First defines Ioctl used  */
+#define LPFC_LIP			0x41	/* Issue a LIP */
+#define LPFC_CT				0x42	/* Send CT passthru command */
+#define LPFC_LISTN			0x43	/* List nodes for adapter
+						 * (by WWPN, WWNN and DID) */
+
+/*  HBA API specific Ioctls() */
+
+#define LPFC_HBA_ADAPTERATTRIBUTES	0x48	/* Get attributes of HBA */
+#define LPFC_HBA_PORTATTRIBUTES		0x49	/* Get attributes of HBA Port */
+#define LPFC_HBA_PORTSTATISTICS		0x4a	/* Get statistics of HBA Port */
+#define LPFC_HBA_DISCPORTATTRIBUTES	0x4b	/* Get attibutes of the
+						 * discovered adapter Ports */
+#define LPFC_HBA_WWPNPORTATTRIBUTES	0x4c	/* Get attributes of the Port
+						 * specified by WWPN */
+#define LPFC_HBA_INDEXPORTATTRIBUTES	0x4d	/* Get attributes of the Port
+						 * specified by index */
+#define LPFC_HBA_FCPTARGETMAPPING	0x4e	/* Get info for all FCP tgt's */
+#define LPFC_HBA_FCPBINDING		0x4f	/* Binding info for FCP tgts */
+#define LPFC_HBA_SETMGMTINFO		0x50	/* Sets driver values with
+						 * default HBA_MGMTINFO vals */
+#define LPFC_HBA_GETMGMTINFO		0x51	/* Get driver values for
+						 * HBA_MGMTINFO vals */
+#define LPFC_HBA_RNID			0x52	/* Send an RNID request */
+#define LPFC_HBA_GETEVENT		0x53	/* Get event data */
+#define LPFC_HBA_SEND_SCSI		0x55	/* Send SCSI requests to tgt */
+#define LPFC_HBA_REFRESHINFO		0x56	/* Do a refresh of the stats */
+#define LPFC_SEND_ELS			0x57	/* Send out an ELS command */
+#define LPFC_HBA_SEND_FCP		0x58	/* Send out a FCP command */
+#define LPFC_HBA_SET_EVENT		0x59	/* Set FCP event(s) */
+#define LPFC_HBA_GET_EVENT		0x5a	/* Get  FCP event(s) */
+#define LPFC_HBA_SEND_MGMT_CMD		0x5b	/* Send a management command */
+#define LPFC_HBA_SEND_MGMT_RSP		0x5c	/* Send a management response */
+
+#define LPFC_UNUSED			0x61	/* to be removed */
+#define LPFC_RESET_QDEPTH		0x62	/* Reset adapter Q depth */
+#define LPFC_OUTFCPIO			0x63	/* Number of outstanding I/Os */
+#define LPFC_GETCFG			0x64	/* Get config parameters */
+#define LPFC_SETCFG			0x65	/* Set config parameters */
+#define LPFC_STAT			0x67	/* Statistics for SLI/FC/IP */
+#define LPFC_GET_DFC_REV		0x68	/* Get the rev of the ioctl driver */
+#define LPFC_GET_VPD			0x69	/* Get Adapter VPD */
+/*  LPFC_LAST_IOCTL_USED 	        0x69 Last LPFC Ioctl used  */
+
+/*
+Data structure definitions:
+*/
+
+/*
+ * Diagnostic (DFC) Command & Input structures: (LPFC)
+ */
+typedef struct lpfcCmdInput {
+	short    lpfc_brd;
+	short    lpfc_ring;
+	short    lpfc_iocb;
+	short    lpfc_flag;
+	void    *lpfc_arg1;
+	void    *lpfc_arg2;
+	void    *lpfc_arg3;
+	char    *lpfc_dataout;
+	uint32_t lpfc_cmd;
+	uint32_t lpfc_outsz;
+	uint32_t lpfc_arg4;
+	uint32_t lpfc_arg5;
+	uint32_t lpfc_cntl;
+	uint8_t  pad[4]; /* pad structure to 8 byte boundary */
+} LPFCCMDINPUT_t;
+
+#if defined(CONFIG_PPC64) || defined(CONFIG_X86_64)
+/* 32 bit version */
+typedef struct lpfcCmdInput32 {
+	short    lpfc_brd;
+	short    lpfc_ring;
+	short    lpfc_iocb;
+	short    lpfc_flag;
+	u32	lpfc_arg1;
+	u32	lpfc_arg2;
+	u32     lpfc_arg3;
+	u32     lpfc_dataout;
+	uint32_t lpfc_cmd;
+	uint32_t lpfc_outsz;
+	uint32_t lpfc_arg4;
+	uint32_t lpfc_arg5;
+	uint32_t lpfc_cntl;
+	uint8_t  pad[4]; /* pad structure to 8 byte boundary */
+} LPFCCMDINPUT32_t;
+#endif
+
+/* Command input control definitions */
+
+#define LPFC_CNTL_X86_APP  0x01
+
+/* Structure for OUTFCPIO command */
+
+struct out_fcp_devp {
+	uint16_t target;
+	uint16_t lun;
+	uint16_t tx_count;
+	uint16_t txcmpl_count;
+	uint16_t delay_count;
+	uint16_t sched_count;
+	uint16_t lun_qdepth;
+	uint16_t current_qdepth;
+	uint32_t qcmdcnt;
+	uint32_t iodonecnt;
+	uint32_t errorcnt;
+	uint8_t  pad[4]; /* pad structure to 8 byte boundary */
+};
+
+/* Structure for VPD command */
+
+struct vpd {
+	uint32_t version;
+#define VPD_VERSION1     1
+	uint8_t  ModelDescription[256];    /* VPD field V1 */
+	uint8_t  Model[80];                /* VPD field V2 */
+	uint8_t  ProgramType[256];         /* VPD field V3 */
+	uint8_t  PortNum[20];              /* VPD field V4 */
+};
+
+#define MREC_MAX 16
+#define arecord(a, b, c, d)
+
+struct rec {
+	void *arg0;
+	void *arg1;
+	void *arg2;
+	void *arg3;
+};
+
+/*
+ * This structure needs to fit in di->fc_dataout alloc'ed memory
+ * array in dfc_un for dfc.c / C_TRACE
+ */
+struct mrec {
+	ulong reccnt;
+	struct rec rectbl[MREC_MAX];
+};
+
+/* the DfcRevInfo structure */
+typedef struct DFCREVINFO {
+	uint32_t a_Major;
+	uint32_t a_Minor;
+} DfcRevInfo;
+
+
+
+
+/* the brdinfo structure */
+typedef struct BRDINFO {
+	uint32_t a_mem_hi;	/* memory identifier for adapter access */
+	uint32_t a_mem_low;	/* memory identifier for adapter access */
+	uint32_t a_flash_hi;	/* memory identifier for adapter access */
+	uint32_t a_flash_low;	/* memory identifier for adapter access */
+	uint32_t a_ctlreg_hi;	/* memory identifier for adapter access */
+	uint32_t a_ctlreg_low;	/* memory identifier for adapter access */
+	uint32_t a_intrlvl;	/* interrupt level for adapter */
+	uint32_t a_pci;		/* PCI identifier (device / vendor id) */
+	uint32_t a_busid;	/* identifier of PCI bus adapter is on */
+	uint32_t a_devid;	/* identifier of PCI device number */
+	uint8_t a_rsvd1;	/* reserved for future use */
+	uint8_t a_rsvd2;	/* reserved for future use */
+	uint8_t a_siglvl;	/* signal handler used by library */
+	uint8_t a_ddi;		/* identifier device driver instance number */
+	uint32_t a_onmask;	/* mask of ONDI primatives supported */
+	uint32_t a_offmask;	/* mask of OFFDI primatives supported */
+	uint8_t a_drvrid[16];	/* driver version */
+	uint8_t a_fwname[32];	/* firmware version */
+} brdinfo;
+
+typedef struct {
+	uint8_t bind_type;
+	uint8_t wwpn[8];
+	uint8_t wwnn[8];
+	uint32_t did;
+	uint32_t scsi_id;
+} bind_ctl_t;
+
+struct dfc_info {
+	brdinfo fc_ba;
+	char *fc_iomap_io;	/* starting address for registers */
+	char *fc_iomap_mem;	/* starting address for SLIM */
+	uint8_t *fc_hmap;	/* handle for mapping memory */
+	uint32_t fc_refcnt;
+	uint32_t fc_flag;
+};
+
+struct dfc {
+	uint32_t dfc_init;
+	uint32_t dfc_pad;
+	struct dfc_info dfc_info[MAX_LPFC_BRDS];
+};
+
+#define LPFC_DFC_CMD_IOCTL_MAGIC 0xFC
+#define LPFC_DFC_CMD_IOCTL _IOWR(LPFC_DFC_CMD_IOCTL_MAGIC, 0x1, LPFCCMDINPUT_t) 	/* Used for ioctl command */
+#define LPFC_DFC_CMD_IOCTL32 _IOWR(LPFC_DFC_CMD_IOCTL_MAGIC, 0x1, LPFCCMDINPUT32_t) 	/* Used for ioctl command */
+
+/* DFC specific data structures */
+
+typedef struct dfcptr {
+	uint32_t addrhi;
+	uint32_t addrlo;
+} dfcptr_t;
+
+typedef struct dfcu64 {
+	uint32_t hi;
+	uint32_t lo;
+} dfcu64_t;
+
+typedef struct dfcringmask {
+	uint8_t rctl;
+	uint8_t type;
+	uint8_t  pad[6]; /* pad structure to 8 byte boundary */
+} dfcringmask_t;
+
+typedef struct dfcringinit {
+	dfcringmask_t prt[LPFC_MAX_RING_MASK];
+	uint32_t num_mask;
+	uint32_t iotag_ctr;
+	uint16_t numCiocb;
+	uint16_t numRiocb;
+	uint8_t  pad[4]; /* pad structure to 8 byte boundary */
+} dfcringinit_t;
+
+typedef struct dfcsliinit {
+	dfcringinit_t ringinit[LPFC_MAX_RING];
+	uint32_t num_rings;
+	uint32_t sli_flag;
+} dfcsliinit_t;
+
+typedef struct dfcsliring {
+	uint16_t txq_cnt;
+	uint16_t txq_max;
+	uint16_t txcmplq_cnt;
+	uint16_t txcmplq_max;
+	uint16_t postbufq_cnt;
+	uint16_t postbufq_max;
+	uint32_t missbufcnt;
+	dfcptr_t cmdringaddr;
+	dfcptr_t rspringaddr;
+	uint8_t  rspidx;
+	uint8_t  cmdidx;
+	uint8_t  pad[6]; /* pad structure to 8 byte boundary */
+} dfcsliring_t;
+
+typedef struct dfcslistat {
+	dfcu64_t iocbEvent[LPFC_MAX_RING];
+	dfcu64_t iocbCmd[LPFC_MAX_RING];
+	dfcu64_t iocbRsp[LPFC_MAX_RING];
+	dfcu64_t iocbCmdFull[LPFC_MAX_RING];
+	dfcu64_t iocbCmdEmpty[LPFC_MAX_RING];
+	dfcu64_t iocbRspFull[LPFC_MAX_RING];
+	dfcu64_t mboxStatErr;
+	dfcu64_t mboxCmd;
+	dfcu64_t sliIntr;
+	uint32_t errAttnEvent;
+	uint32_t linkEvent;
+} dfcslistat_t;
+
+typedef struct dfcsli {
+	dfcsliinit_t sliinit;
+	dfcsliring_t ring[LPFC_MAX_RING];
+	dfcslistat_t slistat;
+	dfcptr_t MBhostaddr;
+	uint16_t mboxq_cnt;
+	uint16_t mboxq_max;
+	uint32_t fcp_ring;
+} dfcsli_t;
+
+typedef struct dfcschedhba {
+	uint32_t status;
+	uint16_t targetCount;
+	uint16_t maxOutstanding;
+	uint16_t currentOutstanding;
+	uint8_t  pad[6]; /* pad structure to 8 byte boundary */
+} dfcschedhba_t;
+
+typedef struct dfcschedlun {
+	uint32_t status;
+	uint16_t maxOutstanding;
+	uint16_t currentOutstanding;
+} dfcschedlun_t;
+
+typedef struct dfcschedtarget {
+	uint32_t status;
+	uint16_t lunCount;
+	uint16_t maxOutstanding;
+	uint16_t currentOutstanding;
+	uint8_t  pad[6]; /* pad structure to 8 byte boundary */
+} dfcschedtarget_t;
+
+typedef struct dfchba {
+	dfcschedhba_t hbaSched;
+	dfcsli_t sli;
+	uint32_t hba_state;
+	uint32_t cmnds_in_flight;
+	uint8_t fc_busflag;
+	uint8_t  pad[3]; /* pad structure to 8 byte boundary */
+} dfchba_t;
+
+typedef struct dfcnodelist {
+	uint32_t nlp_failMask;
+	uint16_t nlp_type;
+	uint16_t nlp_rpi;
+	uint16_t nlp_state;
+	uint16_t nlp_xri;
+	uint32_t nlp_flag;
+	uint32_t nlp_DID;
+	uint32_t nlp_oldDID;
+	uint8_t  nlp_portname[8];
+	uint8_t  nlp_nodename[8];
+	uint16_t nlp_sid;
+	uint8_t  pad[6]; /* pad structure to 8 byte boundary */
+} dfcnodelist_t;
+
+typedef struct dfcscsilun {
+	dfcschedlun_t lunSched;
+	dfcu64_t lun_id;
+	uint32_t lunFlag;
+	uint32_t failMask;
+	uint8_t  InquirySN[LPFC_INQSN_SZ];
+	uint8_t  Vendor[8];
+	uint8_t  Product[16];
+	uint8_t  Rev[4];
+	uint8_t  sizeSN;
+	uint8_t  pad[3]; /* pad structure to 8 byte boundary */
+} dfcscsilun_t;
+
+typedef struct dfcscsitarget {
+	dfcschedtarget_t targetSched;
+	dfcptr_t context;
+	uint16_t max_lun;
+	uint16_t scsi_id;
+	uint16_t targetFlags;
+	uint16_t addrMode;
+	uint16_t rptLunState;
+	uint8_t  pad[6]; /* pad structure to 8 byte boundary */
+} dfcscsitarget_t;
+
+typedef struct dfcbindlist {
+	uint8_t  nlp_portname[8];
+	uint8_t  nlp_nodename[8];
+	uint16_t nlp_bind_type;
+	uint16_t nlp_sid;
+	uint32_t nlp_DID;
+} dfcbindlist_t;
+
+typedef struct dfcstat {
+	uint32_t elsRetryExceeded;
+	uint32_t elsXmitRetry;
+	uint32_t elsRcvDrop;
+	uint32_t elsRcvFrame;
+	uint32_t elsRcvRSCN;
+	uint32_t elsRcvRNID;
+	uint32_t elsRcvFARP;
+	uint32_t elsRcvFARPR;
+	uint32_t elsRcvFLOGI;
+	uint32_t elsRcvPLOGI;
+	uint32_t elsRcvADISC;
+	uint32_t elsRcvPDISC;
+	uint32_t elsRcvFAN;
+	uint32_t elsRcvLOGO;
+	uint32_t elsRcvPRLO;
+	uint32_t elsRcvPRLI;
+	uint32_t elsRcvRRQ;
+	uint32_t frameRcvBcast;
+	uint32_t frameRcvMulti;
+	uint32_t strayXmitCmpl;
+	uint32_t frameXmitDelay;
+	uint32_t xriCmdCmpl;
+	uint32_t xriStatErr;
+	uint32_t LinkUp;
+	uint32_t LinkDown;
+	uint32_t LinkMultiEvent;
+	uint32_t NoRcvBuf;
+	uint32_t fcpCmd;
+	uint32_t fcpCmpl;
+	uint32_t fcpRspErr;
+	uint32_t fcpRemoteStop;
+	uint32_t fcpPortRjt;
+	uint32_t fcpPortBusy;
+	uint32_t fcpError;
+} dfcstats_t;
+#endif				/* _H_LPFC_IOCTL */
diff -urNp linux-8155/drivers/addon/lpfc/lpfcdfc/lpfc_util_ioctl.c linux-8156/drivers/addon/lpfc/lpfcdfc/lpfc_util_ioctl.c
--- linux-8155/drivers/addon/lpfc/lpfcdfc/lpfc_util_ioctl.c
+++ linux-8156/drivers/addon/lpfc/lpfcdfc/lpfc_util_ioctl.c
@@ -0,0 +1,2653 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2006 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_util_ioctl.c 466 2006-01-05 19:16:29Z sf_support $
+ */
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/blkdev.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/unistd.h>
+#include <linux/timex.h>
+#include <linux/timer.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/irq.h>
+#include <sd.h>			/* From drivers/scsi */
+#include <hosts.h>
+
+#include "lpfc_hw.h"
+#include "lpfc_sli.h"
+#include "lpfc_mem.h"
+#include "lpfc_sched.h"
+#include "lpfc_disc.h"
+#include "lpfc.h"
+#include "lpfc_logmsg.h"
+#include "lpfc_fcp.h"
+#include "lpfc_scsi.h"
+#include "lpfc_diag.h"
+#include "lpfc_ioctl.h"
+#include "lpfc_diag.h"
+#include "lpfc_dfc.h"
+#include "lpfc_crtn.h"
+#include "lpfc_cfgparm.h"
+#include "hbaapi.h"
+#include "lpfc_util_ioctl.h"
+
+#define LPFC_MAX_EVENT 4 /* Default events we can queue before dropping them */
+
+extern lpfcDRVR_t lpfcDRVR;
+struct dfc dfc;
+
+uint32_t lpfc_diag_state = DDI_ONDI;
+
+int
+lpfc_initpci(struct dfc_info *di, lpfcHBA_t * phba)
+{
+	struct pci_dev *pdev;
+	char lpfc_fwrevision[32];
+	extern char* lpfc_release_version;
+
+	pdev = phba->pcidev;
+	/*
+	   must have the pci struct
+	 */
+	if (!pdev)
+		return (1);
+
+	di->fc_ba.a_onmask = (ONDI_MBOX | ONDI_RMEM | ONDI_RPCI | ONDI_RCTLREG |
+			      ONDI_IOINFO | ONDI_LNKINFO | ONDI_NODEINFO |
+			      ONDI_CFGPARAM | ONDI_CT | ONDI_HBAAPI);
+	di->fc_ba.a_offmask =
+	    (OFFDI_MBOX | OFFDI_RMEM | OFFDI_WMEM | OFFDI_RPCI | OFFDI_WPCI |
+	     OFFDI_RCTLREG | OFFDI_WCTLREG);
+
+	if (lpfc_diag_state == DDI_ONDI)
+		di->fc_ba.a_onmask |= ONDI_SLI2;
+	else
+		di->fc_ba.a_onmask |= ONDI_SLI1;
+
+	/* set endianness of driver diagnotic interface */
+#if __BIG_ENDIAN
+	di->fc_ba.a_onmask |= ONDI_BIG_ENDIAN;
+#else	/*  __LITTLE_ENDIAN */
+	di->fc_ba.a_onmask |= ONDI_LTL_ENDIAN;
+#endif
+
+	di->fc_ba.a_pci =
+	    ((((uint32_t) pdev->device) << 16) | (uint32_t) (pdev->vendor));
+	di->fc_ba.a_pci = le32_to_cpu(di->fc_ba.a_pci);
+	di->fc_ba.a_ddi = phba->brd_no;
+
+	if (pdev->bus)
+		di->fc_ba.a_busid = (uint32_t) (pdev->bus->number);
+	else
+		di->fc_ba.a_busid = 0;
+	di->fc_ba.a_devid = (uint32_t) (pdev->devfn);
+
+	memcpy(di->fc_ba.a_drvrid, lpfc_release_version, 8);
+	lpfc_decode_firmware_rev(phba, lpfc_fwrevision, 1);
+	memcpy(di->fc_ba.a_fwname, lpfc_fwrevision, 32);
+
+	return (0);
+}
+/* Routine Declaration - Local */
+
+int
+lpfc_process_ioctl_util(lpfcHBA_t *phba, LPFCCMDINPUT_t *cip)
+{
+	int rc = -1;
+	int do_cp = 0; 
+	uint32_t outshift;
+	uint32_t total_mem;
+	struct dfc_info *di;
+	void   *dataout;
+	unsigned long iflag;
+
+	extern struct dfc dfc;
+
+	di = &dfc.dfc_info[cip->lpfc_brd];
+	/* dfc_ioctl entry */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk1606,	/* ptr to msg structure */
+		lpfc_mes1606,			/* ptr to msg */
+		lpfc_msgBlk1606.msgPreambleStr,	/* begin varargs */
+		cip->lpfc_cmd,
+		(ulong) cip->lpfc_arg1,
+		(ulong) cip->lpfc_arg2,
+		cip->lpfc_outsz);		/* end varargs */
+
+	outshift = 0;
+	if (cip->lpfc_outsz >= 4096) {
+
+		/* Allocate memory for ioctl data. If buffer is bigger than 64k, then we
+		 * allocate 64k and re-use that buffer over and over to xfer the whole 
+		 * block. This is because Linux kernel has a problem allocating more than
+		 * 120k of kernel space memory. Saw problem with GET_FCPTARGETMAPPING...
+		 */
+		if (cip->lpfc_outsz <= (64 * 1024))
+			total_mem = cip->lpfc_outsz;
+		else
+			total_mem = 64 * 1024;		
+	} else {
+		/* Allocate memory for ioctl data */
+		total_mem = 4096;
+	}
+
+	dataout = kmalloc(total_mem, GFP_ATOMIC);
+	if (!dataout)
+		return (ENOMEM);
+
+	di->fc_refcnt++;
+
+	switch (cip->lpfc_cmd) {
+
+	/* Diagnostic Interface Library Support - util */
+	case LPFC_WRITE_PCI:
+		rc = lpfc_ioctl_write_pci(phba, cip);
+		break;
+
+	case LPFC_READ_PCI:
+		rc = lpfc_ioctl_read_pci(phba, cip, dataout);
+		break;
+
+	case LPFC_WRITE_MEM:
+		rc = lpfc_ioctl_write_mem(phba, cip);
+		break;
+
+	case LPFC_READ_MEM:
+		rc = lpfc_ioctl_read_mem(phba, cip, dataout);
+		break;
+
+	case LPFC_WRITE_CTLREG:
+		rc = lpfc_ioctl_write_ctlreg(phba, cip);
+		break;
+
+	case LPFC_READ_CTLREG:
+		rc = lpfc_ioctl_read_ctlreg(phba, cip, dataout);
+		break;
+
+	case LPFC_GET_DFC_REV:
+
+		((DfcRevInfo *) dataout)->a_Major = DFC_MAJOR_REV;
+		((DfcRevInfo *) dataout)->a_Minor = DFC_MINOR_REV;
+		cip->lpfc_outsz = sizeof (DfcRevInfo);
+		rc = 0;
+		break;
+
+	case LPFC_INITBRDS:
+		di = &dfc.dfc_info[cip->lpfc_brd];
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		if (copy_from_user
+		    ((uint8_t *) & di->fc_ba, (uint8_t *) cip->lpfc_dataout,
+		     sizeof (brdinfo))) {
+			rc = EIO;
+			LPFC_DRVR_LOCK(phba, iflag);
+			break;
+		}
+		LPFC_DRVR_LOCK(phba, iflag);
+		if (lpfc_initpci(di, phba)) {
+			rc = EIO;
+			break;
+		}
+		if (phba->fc_flag & FC_OFFLINE_MODE)
+			di->fc_ba.a_offmask |= OFFDI_OFFLINE;
+
+		memcpy(dataout, (uint8_t *) & di->fc_ba,
+		       sizeof (brdinfo));
+		cip->lpfc_outsz = sizeof (brdinfo);
+		rc = 0;
+		break;
+
+	case LPFC_SETDIAG:
+		rc = lpfc_ioctl_setdiag(phba, cip, dataout);
+		break;
+
+	case LPFC_HBA_SEND_SCSI:
+	case LPFC_HBA_SEND_FCP:
+		rc = lpfc_ioctl_send_scsi_fcp(phba, cip);
+		break;
+
+	case LPFC_HBA_SEND_MGMT_RSP:
+		rc = lpfc_ioctl_send_mgmt_rsp(phba, cip);
+		break;
+
+	case LPFC_HBA_SEND_MGMT_CMD:
+	case LPFC_CT:
+		rc = lpfc_ioctl_send_mgmt_cmd(phba, cip, dataout);
+		break;
+
+	case LPFC_MBOX:
+		rc = lpfc_ioctl_mbox(phba, cip, dataout);
+		break;
+
+	case LPFC_LINKINFO:
+		rc = lpfc_ioctl_linkinfo(phba, cip, dataout);
+		break;
+
+	case LPFC_IOINFO:
+		rc = lpfc_ioctl_ioinfo(phba, cip, dataout);
+		break;
+
+	case LPFC_NODEINFO:
+		rc = lpfc_ioctl_nodeinfo(phba, cip, dataout, total_mem);
+		break;
+
+	case LPFC_GETCFG:
+		rc = lpfc_ioctl_getcfg(phba, cip, dataout);
+		break;
+
+	case LPFC_SETCFG:
+		rc = lpfc_ioctl_setcfg(phba, cip);
+		break;
+
+	case LPFC_HBA_GET_EVENT:
+		rc = lpfc_ioctl_hba_get_event(phba, cip, dataout, total_mem);
+		break;
+
+	case LPFC_HBA_SET_EVENT:
+		rc = lpfc_ioctl_hba_set_event(phba, cip);
+		break;
+
+	case LPFC_ADD_BIND:
+		rc = lpfc_ioctl_add_bind(phba, cip);
+		break;
+
+	case LPFC_DEL_BIND:
+		rc = lpfc_ioctl_del_bind(phba, cip);
+		break;
+
+	case LPFC_LIST_BIND:
+		rc = lpfc_ioctl_list_bind(phba, cip, dataout, &do_cp);
+		break;
+
+	case LPFC_GET_VPD:
+		rc = lpfc_ioctl_get_vpd(phba, cip, dataout, &do_cp);
+		break;
+	}
+	di->fc_refcnt--;
+
+	/* dfc_ioctl exit */
+	lpfc_printf_log(phba->brd_no, &lpfc_msgBlk1607,	/* ptr to msg structure */
+		lpfc_mes1607,			/* ptr to msg */
+		lpfc_msgBlk1607.msgPreambleStr,	/* begin varargs */
+		rc,
+		cip->lpfc_outsz,
+		(uint32_t) ((ulong) cip->lpfc_dataout));	/* end varargs */
+
+
+	/* Copy data to user space config method */
+	if (rc == 0) {
+		if (cip->lpfc_outsz) {
+			LPFC_DRVR_UNLOCK(phba, iflag);
+			if (copy_to_user
+			    ((uint8_t *) cip->lpfc_dataout,
+			     (uint8_t *) dataout, (int)cip->lpfc_outsz)) {
+				rc = EIO;
+			}
+			LPFC_DRVR_LOCK(phba, iflag);
+		}
+	}
+
+	kfree(dataout);
+	return(rc);
+}
+
+int
+lpfc_ioctl_write_pci(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip)
+{
+	uint32_t offset, cnt;
+	int i, rc = 0;
+	unsigned long iflag;
+	uint32_t *buffer;
+
+	offset = (ulong) cip->lpfc_arg1;
+	cnt = (ulong) cip->lpfc_arg2;
+
+	if (!(phba->fc_flag & FC_OFFLINE_MODE)) {
+		rc = EPERM;
+		return (rc);
+	}
+
+	if ((cnt + offset) > 256) {
+		rc = ERANGE;
+		return (rc);
+	}
+
+	buffer = kmalloc(4096, GFP_ATOMIC);
+	if (!buffer) {
+		return (ENOMEM);
+	}
+
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	if (copy_from_user(buffer, cip->lpfc_dataout,
+			   cnt)) {
+		LPFC_DRVR_LOCK(phba, iflag);
+		rc = EIO;
+		kfree(buffer);
+		return (rc);
+	}
+	LPFC_DRVR_LOCK(phba, iflag);
+	
+	for (i = offset; i < (offset + cnt); i += 4) {
+		pci_write_config_dword(phba->pcidev, i, *buffer);
+		buffer++;
+	}
+
+	kfree(buffer);
+	return (rc);
+}
+
+int
+lpfc_ioctl_read_pci(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip, void *dataout)
+{
+	uint32_t offset, cnt;
+	uint32_t *destp;
+	int rc = 0;
+	int i;
+
+	offset = (ulong) cip->lpfc_arg1;
+	cnt = (ulong) cip->lpfc_arg2;
+	destp = (uint32_t *) dataout;
+
+	if ((cnt + offset) > 256) {
+		rc = ERANGE;
+		return (rc);
+	}
+
+	for (i = offset; i < (offset + cnt); i += 4) {
+		pci_read_config_dword(phba->pcidev, i, destp);
+		destp++;
+	}
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_write_mem(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip)
+{
+	uint32_t offset, cnt;
+	LPFC_SLI_t *psli;
+	int rc = 0;
+	unsigned long iflag;
+	uint8_t *buffer;
+
+	psli = &phba->sli;
+	offset = (ulong) cip->lpfc_arg1;
+	cnt = (ulong) cip->lpfc_arg2;
+
+	if (!(phba->fc_flag & FC_OFFLINE_MODE)) {
+		if (offset != 256) {
+			rc = EPERM;
+			return (rc);
+		}
+		/* Allow writing of first 128 bytes after mailbox in online mode */
+		if (cnt > 128) {
+			rc = EPERM;
+			return (rc);
+		}
+	}
+	if (offset >= 4096) {
+		rc = ERANGE;
+		return (rc);
+	}
+	cnt = (ulong) cip->lpfc_arg2;
+	if ((cnt + offset) > 4096) {
+		rc = ERANGE;
+		return (rc);
+	}
+
+	buffer =  kmalloc(4096, GFP_ATOMIC);
+	if (!buffer)
+		return(ENOMEM);
+
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	if (copy_from_user((uint8_t *) buffer, (uint8_t *) cip->lpfc_dataout,
+			   (ulong) cnt)) {
+		rc = EIO;
+		LPFC_DRVR_LOCK(phba, iflag);
+		kfree(buffer);
+		return (rc);
+	}
+	LPFC_DRVR_LOCK(phba, iflag);
+
+	if (psli->sliinit.sli_flag & LPFC_SLI2_ACTIVE) {
+		/* copy into SLIM2 */
+		lpfc_sli_pcimem_bcopy((uint32_t *) buffer,
+				     ((uint32_t *) phba->slim2p.virt + offset),
+				     cnt >> 2);
+	} else {
+		/* First copy command data */
+		lpfc_memcpy_to_slim( phba->MBslimaddr, (void *)buffer, cnt);
+	}
+	kfree(buffer);
+	return (rc);
+}
+
+int
+lpfc_ioctl_read_mem(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip, void *dataout)
+{
+	uint32_t offset, cnt;
+	LPFC_SLI_t *psli;
+	int i, rc = 0;
+
+	psli = &phba->sli;
+	offset = (ulong) cip->lpfc_arg1;
+	cnt = (ulong) cip->lpfc_arg2;
+
+	if (psli->sliinit.sli_flag & LPFC_SLI2_ACTIVE) {
+		/* The SLIM2 size is stored in the next field */
+		i = phba->slim_size;
+	} else {
+		i = 4096;
+	}
+
+	if (offset >= i) {
+		rc = ERANGE;
+		return (rc);
+	}
+
+	if ((cnt + offset) > i) {
+		/* Adjust cnt instead of error ret */
+		cnt = (i - offset);
+	}
+
+	if (psli->sliinit.sli_flag & LPFC_SLI2_ACTIVE) {
+		/* copy results back to user */
+		lpfc_sli_pcimem_bcopy((uint32_t *) psli->MBhostaddr,
+				     (uint32_t *) dataout, cnt);
+	} else {
+		/* First copy command data from SLIM */
+		lpfc_memcpy_from_slim( dataout,
+			       phba->MBslimaddr,
+			       sizeof (uint32_t) * (MAILBOX_CMD_WSIZE) );		
+	}
+	return (rc);
+}
+
+int
+lpfc_ioctl_write_ctlreg(lpfcHBA_t * phba,
+			LPFCCMDINPUT_t * cip)
+{
+	uint32_t offset, incr;
+	LPFC_SLI_t *psli;
+	int rc = 0;
+
+	psli = &phba->sli;
+	offset = (ulong) cip->lpfc_arg1;
+	incr = (ulong) cip->lpfc_arg2;
+
+	if (!(phba->fc_flag & FC_OFFLINE_MODE)) {
+		rc = EPERM;
+		return (rc);
+	}
+
+	if (offset > 255) {
+		rc = ERANGE;
+		return (rc);
+	}
+
+	if (offset % 4) {
+		rc = EINVAL;
+		return (rc);
+	}
+
+	writel(incr, (phba->ctrl_regs_memmap_p) + offset);
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_read_ctlreg(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip, void *dataout)
+{
+	uint32_t offset, incr;
+	int rc = 0;
+
+	offset = (ulong) cip->lpfc_arg1;
+
+	if (offset > 255) {
+		rc = ERANGE;
+		return (rc);
+	}
+
+	if (offset % 4) {
+		rc = EINVAL;
+		return (rc);
+	}
+
+	incr = readl((phba->ctrl_regs_memmap_p) + offset);
+	*((uint32_t *) dataout) = incr;
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_setdiag(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip, void *dataout)
+{
+	uint32_t offset;
+	int rc = 0;
+
+	offset = (ulong) cip->lpfc_arg1;
+
+	switch (offset) {
+	case DDI_ONDI:
+		rc = ENXIO;
+		break;
+
+	case DDI_OFFDI:
+		rc = ENXIO;
+		break;
+
+	case DDI_SHOW:
+		rc = ENXIO;
+		break;
+
+	case DDI_BRD_ONDI:
+		if (phba->fc_flag & FC_OFFLINE_MODE) {
+			lpfc_online(phba);
+		}
+		*((uint32_t *) (dataout)) = DDI_ONDI;
+		break;
+
+	case DDI_BRD_OFFDI:
+		if (!(phba->fc_flag & FC_OFFLINE_MODE)) {
+			lpfc_offline(phba);
+		}
+		*((uint32_t *) (dataout)) = DDI_OFFDI;
+		break;
+
+	case DDI_BRD_SHOW:
+		if (phba->fc_flag & FC_OFFLINE_MODE) {
+			*((uint32_t *) (dataout)) = DDI_OFFDI;
+		} else {
+			*((uint32_t *) (dataout)) = DDI_ONDI;
+		}
+		break;
+
+	default:
+		rc = ERANGE;
+		break;
+	}
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_send_scsi_fcp(lpfcHBA_t * phba,
+			 LPFCCMDINPUT_t * cip)
+{
+
+	LPFC_SLI_t *psli = &phba->sli;
+	lpfcCfgParam_t *clp;
+	int reqbfrcnt;
+	int snsbfrcnt;
+	int j = 0;
+	HBA_WWN wwpn;
+	FCP_CMND *fcpcmd;
+	FCP_RSP *fcprsp;
+	ULP_BDE64 *bpl;
+	LPFC_NODELIST_t *pndl;
+	LPFC_SLI_RING_t *pring = &psli->ring[LPFC_FCP_RING];
+	LPFC_IOCBQ_t *cmdiocbq = 0;
+	LPFC_IOCBQ_t *rspiocbq = 0;
+	DMABUFEXT_t *outdmp = 0;
+	IOCB_t *cmd = 0;
+	IOCB_t *rsp = 0;
+	DMABUF_t *mp = 0;
+	DMABUF_t *bmp = 0;
+	int i0;
+	char *outdta;
+	uint32_t clear_count;
+	int rc = 0;
+	unsigned long iflag;
+	uint32_t iocb_wait_timeout = cip->lpfc_arg5;
+	uint32_t iocb_retries;
+
+	struct {
+		/* this rspcnt is really data buffer size */
+		uint32_t rspcnt;
+		/* this is sense count in case of LPFC_HBA_SEND_SCSI.
+		 * It is fcp response size in case of LPFC_HBA_SEND_FCP
+		 */
+		uint32_t snscnt;
+	} count;
+
+	clp = &phba->config[0];
+
+    /************************************************************************/
+
+    /************************************************************************/
+	reqbfrcnt = cip->lpfc_arg4;
+	snsbfrcnt = cip->lpfc_flag;
+	if ((reqbfrcnt + cip->lpfc_outsz) > (80 * 4096)) {
+		/* lpfc_ioctl:error <idx> */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk1604,	/* ptr to msg structure */
+			       lpfc_mes1604,	/* ptr to msg */
+			       lpfc_msgBlk1604.msgPreambleStr,	/* begin varargs */
+			       0);	/* end varargs */
+		rc = ERANGE;
+		goto sndsczout;
+	}
+
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	if (copy_from_user((uint8_t *) & wwpn, (uint8_t *) cip->lpfc_arg3,
+			   (ulong) (sizeof (HBA_WWN)))) {
+		rc = EIO;
+		LPFC_DRVR_LOCK(phba, iflag);
+		goto sndsczout;
+	}
+	LPFC_DRVR_LOCK(phba, iflag);
+
+	pndl =
+	    lpfc_findnode_wwpn(phba, NLP_SEARCH_MAPPED, (NAME_TYPE *) & wwpn);
+	if (!pndl) {
+		if (!(pndl = lpfc_findnode_wwpn(phba, NLP_SEARCH_UNMAPPED,
+						(NAME_TYPE *) & wwpn))
+		    || !(pndl->nlp_flag & NLP_TGT_NO_SCSIID)) {
+			pndl = (LPFC_NODELIST_t *) 0;
+		}
+	}
+	if (!pndl || !(psli->sliinit.sli_flag & LPFC_SLI2_ACTIVE)) {
+		rc = EACCES;
+		goto sndsczout;
+	}
+	if (pndl->nlp_flag & NLP_ELS_SND_MASK) {
+		rc = ENODEV;
+		goto sndsczout;
+	}
+	/* Allocate buffer for command iocb */
+	if ((cmdiocbq = lpfc_iocb_alloc(phba, MEM_PRI)) == 0) {
+		rc = ENOMEM;
+		goto sndsczout;
+	}
+	memset((void *)cmdiocbq, 0, sizeof (LPFC_IOCBQ_t));
+	cmd = &(cmdiocbq->iocb);
+
+	/* Allocate buffer for response iocb */
+	if ((rspiocbq = lpfc_iocb_alloc(phba, MEM_PRI)) == 0) {
+		rc = ENOMEM;
+		goto sndsczout;
+	}
+	memset((void *)rspiocbq, 0, sizeof (LPFC_IOCBQ_t));
+	rsp = &(rspiocbq->iocb);
+
+	/* Allocate buffer for Buffer ptr list */
+	if (((bmp = kmalloc(sizeof (DMABUF_t), GFP_ATOMIC)) == 0) ||
+	    ((bmp->virt = lpfc_mbuf_alloc(phba, 0, &(bmp->phys))) == 0)) {
+		if (bmp)
+			kfree(bmp);
+		bmp = NULL;
+		rc = ENOMEM;
+		goto sndsczout;
+	}
+	INIT_LIST_HEAD(&bmp->list);
+	bpl = (ULP_BDE64 *) bmp->virt;
+
+	/* Allocate buffer for FCP CMND / FCP RSP */
+	if (((mp = kmalloc(sizeof (DMABUF_t), GFP_ATOMIC)) == 0) ||
+	    ((mp->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &(mp->phys))) == 0)) {
+		if (mp)
+			kfree(mp);
+		mp = NULL;
+		rc = ENOMEM;
+		goto sndsczout;
+	}
+	INIT_LIST_HEAD(&mp->list);
+	fcpcmd = (FCP_CMND *) mp->virt;
+	fcprsp = (FCP_RSP *) ((uint8_t *) mp->virt + sizeof (FCP_CMND));
+	memset((void *)fcpcmd, 0, sizeof (FCP_CMND) + sizeof (FCP_RSP));
+
+	/* Setup FCP CMND and FCP RSP */
+	bpl->addrHigh = le32_to_cpu( putPaddrHigh(mp->phys) );
+	bpl->addrLow = le32_to_cpu( putPaddrLow(mp->phys) );
+	bpl->tus.f.bdeSize = sizeof (FCP_CMND);
+	bpl->tus.f.bdeFlags = BUFF_USE_CMND;
+	bpl->tus.w = le32_to_cpu(bpl->tus.w);
+	bpl++;
+	bpl->addrHigh = le32_to_cpu( putPaddrHigh(mp->phys + sizeof (FCP_CMND)) );
+	bpl->addrLow = le32_to_cpu( putPaddrLow(mp->phys + sizeof (FCP_CMND)) );
+	bpl->tus.f.bdeSize = sizeof (FCP_RSP);
+	bpl->tus.f.bdeFlags = (BUFF_USE_CMND | BUFF_USE_RCV);
+	bpl->tus.w = le32_to_cpu(bpl->tus.w);
+	bpl++;
+
+	/* Copy user data into fcpcmd buffer at this point to see if its a read
+	   or a write.  */
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	if (copy_from_user((uint8_t *) fcpcmd, (uint8_t *) cip->lpfc_arg1,
+			   (ulong) (reqbfrcnt))) {
+		rc = EIO;
+		LPFC_DRVR_LOCK(phba, iflag);
+		goto sndsczout;
+	}
+	LPFC_DRVR_LOCK(phba, iflag);
+
+	outdta = (fcpcmd->fcpCntl3 == WRITE_DATA ? cip->lpfc_dataout : 0);
+
+	/* Allocate data buffer, and fill it if its a write */
+	if (cip->lpfc_outsz == 0) {
+		outdmp = dfc_cmd_data_alloc(phba, outdta, bpl, 512);
+	} else {
+		outdmp = dfc_cmd_data_alloc(phba, outdta, bpl, cip->lpfc_outsz);
+	}
+	if (outdmp == 0) {
+		rc = ENOMEM;
+		goto sndsczout;
+	}
+
+	cmd->un.fcpi64.bdl.ulpIoTag32 = 0;
+	cmd->un.fcpi64.bdl.addrHigh = putPaddrHigh(bmp->phys);
+	cmd->un.fcpi64.bdl.addrLow = putPaddrLow(bmp->phys);
+	cmd->un.fcpi64.bdl.bdeSize = (3 * sizeof (ULP_BDE64));
+	cmd->un.fcpi64.bdl.bdeFlags = BUFF_TYPE_BDL;
+	cmd->ulpBdeCount = 1;
+	cmd->ulpContext = pndl->nlp_rpi;
+	cmd->ulpIoTag = lpfc_sli_next_iotag(phba, pring);
+	cmd->ulpClass = pndl->nlp_fcp_info & 0x0f;
+	cmd->ulpOwner = OWN_CHIP;
+	cmd->ulpTimeout =
+	    clp[LPFC_CFG_SCSI_REQ_TMO].a_current + phba->fcp_timeout_offset;
+	cmd->ulpLe = 1;
+	if (pndl->nlp_fcp_info & NLP_FCP_2_DEVICE) {
+		cmd->ulpFCP2Rcvy = 1;
+	}
+	switch (fcpcmd->fcpCntl3) {
+	case READ_DATA:	/* Set up for SCSI read */
+		cmd->ulpCommand = CMD_FCP_IREAD64_CR;
+		cmd->ulpPU = PARM_READ_CHECK;
+		cmd->un.fcpi.fcpi_parm = cip->lpfc_outsz;
+		cmd->un.fcpi64.bdl.bdeSize =
+		    ((outdmp->flag + 2) * sizeof (ULP_BDE64));
+		break;
+	case WRITE_DATA:	/* Set up for SCSI write */
+		cmd->ulpCommand = CMD_FCP_IWRITE64_CR;
+		cmd->un.fcpi64.bdl.bdeSize =
+		    ((outdmp->flag + 2) * sizeof (ULP_BDE64));
+		break;
+	default:		/* Set up for SCSI command */
+		cmd->ulpCommand = CMD_FCP_ICMND64_CR;
+		cmd->un.fcpi64.bdl.bdeSize = (2 * sizeof (ULP_BDE64));
+		break;
+	}
+	cmdiocbq->context1 = (uint8_t *) 0;
+	cmdiocbq->iocb_flag |= LPFC_IO_LIBDFC;
+
+	/* Set up the timeout value for the iocb wait command. */
+	if( iocb_wait_timeout == 0 ) {
+	        iocb_wait_timeout = clp[LPFC_CFG_SCSI_REQ_TMO].a_current +
+		   phba->fcp_timeout_offset + LPFC_DRVR_TIMEOUT;
+		/* Retry three times on getting IOCB_BUSY or
+		   IOCB_TIMEOUT from issue_iocb. */
+		iocb_retries = 4;
+	} else {
+	        /* Don't retry the iocb on failure. */
+	        iocb_retries = 1;
+	}
+
+	/* send scsi command, retry 3 times on getting IOCB_BUSY, or
+	   IOCB_TIMEOUT frm issue_iocb  */
+	for (rc = -1, i0 = 0; i0 < iocb_retries && rc != IOCB_SUCCESS; i0++) {
+		rc = lpfc_sli_issue_iocb_wait(phba, pring, cmdiocbq,
+					     SLI_IOCB_USE_TXQ, rspiocbq,
+					     iocb_wait_timeout);
+		if (rc == IOCB_ERROR) {
+			rc = EACCES;
+			break;
+		}
+	}
+
+	if (rc != IOCB_SUCCESS) {
+		rc = EACCES;
+		goto sndsczout;
+	}
+
+	/* For LPFC_HBA_SEND_FCP, just return FCP_RSP unless we got
+	 * an IOSTAT_LOCAL_REJECT.
+	 *
+	 * For SEND_FCP case, snscnt is really FCP_RSP length. In the
+	 * switch statement below, the snscnt should not get destroyed.
+	 */
+	if (cmd->ulpCommand == CMD_FCP_IWRITE64_CX) {
+		clear_count = (rsp->ulpStatus == IOSTAT_SUCCESS ? 1 : 0);
+	} else {
+		clear_count = cmd->un.fcpi.fcpi_parm;
+	}
+	if ((cip->lpfc_cmd == LPFC_HBA_SEND_FCP) &&
+	    (rsp->ulpStatus != IOSTAT_LOCAL_REJECT)) {
+		if (snsbfrcnt < sizeof (FCP_RSP)) {
+			count.snscnt = snsbfrcnt;
+		} else {
+			count.snscnt = sizeof (FCP_RSP);
+		}
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		if (copy_to_user((uint8_t *) cip->lpfc_arg2, (uint8_t *) fcprsp,
+				 count.snscnt)) {
+			rc = EIO;
+			LPFC_DRVR_LOCK(phba, iflag);
+			goto sndsczout;
+		}
+		LPFC_DRVR_LOCK(phba, iflag);
+	}
+	switch (rsp->ulpStatus) {
+	case IOSTAT_SUCCESS:
+	      cpdata:
+		if (cip->lpfc_outsz < clear_count) {
+			cip->lpfc_outsz = 0;
+			rc = ERANGE;
+			break;
+		}
+		cip->lpfc_outsz = clear_count;
+		if (cip->lpfc_cmd == LPFC_HBA_SEND_SCSI) {
+			count.rspcnt = cip->lpfc_outsz;
+			count.snscnt = 0;
+		} else {	/* For LPFC_HBA_SEND_FCP, snscnt is already set */
+			count.rspcnt = cip->lpfc_outsz;
+		}
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		/* Return data length */
+		if (copy_to_user((uint8_t *) cip->lpfc_arg3, (uint8_t *) & count,
+				 (2 * sizeof (uint32_t)))) {
+			rc = EIO;
+			LPFC_DRVR_LOCK(phba, iflag);
+			break;
+		}
+		LPFC_DRVR_LOCK(phba, iflag);
+		cip->lpfc_outsz = 0;
+		if (count.rspcnt) {
+			if (dfc_rsp_data_copy
+			    (phba, (uint8_t *) cip->lpfc_dataout, outdmp,
+			     count.rspcnt)) {
+				rc = EIO;
+				break;
+			}
+		}
+		break;
+	case IOSTAT_LOCAL_REJECT:
+		cip->lpfc_outsz = 0;
+		if (rsp->un.grsp.perr.statLocalError == IOERR_SEQUENCE_TIMEOUT) {
+			rc = ETIMEDOUT;
+			break;
+		}
+		rc = EFAULT;
+		goto sndsczout;	/* count.rspcnt and count.snscnt is already 0 */
+	case IOSTAT_FCP_RSP_ERROR:
+		/* at this point, clear_count is the residual count. 
+		 * We are changing it to the amount actually xfered.
+		 */
+		if (fcpcmd->fcpCntl3 == READ_DATA) {
+			if ((fcprsp->rspStatus2 & RESID_UNDER)
+			    && (fcprsp->rspStatus3 == SCSI_STAT_GOOD)) {
+				goto cpdata;
+			}
+		} else {
+			clear_count = 0;
+		}
+		count.rspcnt = (uint32_t) clear_count;
+		cip->lpfc_outsz = 0;
+		if (fcprsp->rspStatus2 & RSP_LEN_VALID) {
+			j = be32_to_cpu(fcprsp->rspRspLen);
+		}
+		if (fcprsp->rspStatus2 & SNS_LEN_VALID) {
+			if (cip->lpfc_cmd == LPFC_HBA_SEND_SCSI) {
+				if (snsbfrcnt < be32_to_cpu(fcprsp->rspSnsLen))
+					count.snscnt = snsbfrcnt;
+				else
+					count.snscnt =
+					    be32_to_cpu(fcprsp->rspSnsLen);
+				/* Return sense info from rsp packet */
+				LPFC_DRVR_UNLOCK(phba, iflag);
+				if (copy_to_user
+				    ((uint8_t *) cip->lpfc_arg2,
+				     ((uint8_t *) & fcprsp->rspInfo0) + j,
+				     count.snscnt)) {
+					rc = EIO;
+					LPFC_DRVR_LOCK(phba, iflag);
+					break;
+				}
+				LPFC_DRVR_LOCK(phba, iflag);
+			}
+		} else {
+			rc = EFAULT;
+			break;
+		}
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		if (copy_to_user(	/* return data length */
+					(uint8_t *) cip->lpfc_arg3,
+					(uint8_t *) & count,
+					(2 * sizeof (uint32_t)))) {
+			rc = EIO;
+			LPFC_DRVR_LOCK(phba, iflag);
+			break;
+		}
+		LPFC_DRVR_LOCK(phba, iflag);
+		if (count.rspcnt) {	/* return data for read */
+			if (dfc_rsp_data_copy
+			    (phba, (uint8_t *) cip->lpfc_dataout, outdmp,
+			     count.rspcnt)) {
+				rc = EIO;
+				break;
+			}
+		}
+		break;
+	default:
+		cip->lpfc_outsz = 0;
+		rc = EFAULT;
+		break;
+	}
+      sndsczout:
+	dfc_cmd_data_free(phba, outdmp);
+	if (mp) {
+		lpfc_mbuf_free(phba, mp->virt, mp->phys);
+		kfree(mp);
+	}
+	if (bmp) {
+		lpfc_mbuf_free(phba, bmp->virt, bmp->phys);
+		kfree(bmp);
+	}
+	if (cmdiocbq)
+		lpfc_iocb_free(phba, cmdiocbq);
+	if (rspiocbq)
+		lpfc_iocb_free(phba, rspiocbq);
+	return (rc);
+}
+
+int
+lpfc_ioctl_send_mgmt_rsp(lpfcHBA_t * phba,
+			 LPFCCMDINPUT_t * cip)
+{
+	ULP_BDE64 *bpl;
+	DMABUF_t *bmp;
+	DMABUFEXT_t *indmp;
+	uint32_t tag;
+	int reqbfrcnt;
+	int rc = 0;
+
+	tag = (uint32_t) cip->lpfc_flag;	/* XRI for XMIT_SEQUENCE */
+	reqbfrcnt = (ulong) cip->lpfc_arg2;
+
+	if ((reqbfrcnt == 0) || (reqbfrcnt > (80 * 4096))) {
+		rc = ERANGE;
+		return (rc);
+	}
+
+	/* Allocate buffer for Buffer ptr list */
+	if (((bmp = kmalloc(sizeof (DMABUF_t), GFP_ATOMIC)) == 0) ||
+	    ((bmp->virt = lpfc_mbuf_alloc(phba, 0, &(bmp->phys))) == 0)) {
+		if (bmp)
+			kfree(bmp);
+		rc = ENOMEM;
+		return (rc);
+	}
+	INIT_LIST_HEAD(&bmp->list);
+	bpl = (ULP_BDE64 *) bmp->virt;
+
+	if ((indmp =
+	     dfc_cmd_data_alloc(phba, (char *)cip->lpfc_arg1, bpl,
+				reqbfrcnt)) == 0) {
+		lpfc_mbuf_free(phba, bmp->virt, bmp->phys);
+		kfree(bmp);
+		rc = ENOMEM;
+		return (rc);
+	}
+
+	/* flag contains total number of BPLs for xmit */
+	if ((rc = lpfc_issue_ct_rsp(phba, tag, bmp, indmp))) {
+		if (rc == IOCB_TIMEDOUT)
+			rc = ETIMEDOUT;
+		else if (rc == IOCB_ERROR)
+			rc = EACCES;
+	}
+
+	dfc_cmd_data_free(phba, indmp);
+	lpfc_mbuf_free(phba, bmp->virt, bmp->phys);
+	kfree(bmp);
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_send_mgmt_cmd(lpfcHBA_t * phba,
+			 LPFCCMDINPUT_t * cip, void *dataout)
+{
+	LPFC_NODELIST_t *pndl;
+	ULP_BDE64 *bpl;
+	HBA_WWN findwwn;
+	uint32_t finddid;
+	LPFC_IOCBQ_t *cmdiocbq = 0;	/* Initialize the command iocb queue to a 0 default. */
+	LPFC_IOCBQ_t *rspiocbq = 0;	/* Initialize the response iocb queue to a 0 default. */
+	DMABUFEXT_t *indmp = 0;
+	DMABUFEXT_t *outdmp = 0;
+	IOCB_t *cmd = 0;
+	IOCB_t *rsp = 0;
+	DMABUF_t *mp = 0;
+	DMABUF_t *bmp = 0;
+	LPFC_SLI_t *psli = &phba->sli;
+	LPFC_SLI_RING_t *pring = &psli->ring[LPFC_ELS_RING];	/* els ring */
+	int i0 = 0, rc = 0;
+	int reqbfrcnt;
+	int snsbfrcnt;
+	uint32_t timeout;
+	unsigned long iflag;
+
+	reqbfrcnt = cip->lpfc_arg4;
+	snsbfrcnt = cip->lpfc_arg5;
+
+	if (!(reqbfrcnt) || !(snsbfrcnt)
+	    || (reqbfrcnt + snsbfrcnt) > (80 * 4096)) {
+		rc = ERANGE;
+		goto sndmgtqwt;
+	}
+
+	if (cip->lpfc_cmd == LPFC_HBA_SEND_MGMT_CMD) {
+
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		if (copy_from_user
+		    ((uint8_t *) & findwwn, (uint8_t *) cip->lpfc_arg3,
+		     (ulong) (sizeof (HBA_WWN)))) {
+			rc = EIO;
+			LPFC_DRVR_LOCK(phba, iflag);
+			goto sndmgtqwt;
+		}
+		LPFC_DRVR_LOCK(phba, iflag);
+
+		pndl =
+		    lpfc_findnode_wwpn(phba,
+				       NLP_SEARCH_MAPPED | NLP_SEARCH_UNMAPPED,
+				       (NAME_TYPE *) & findwwn);
+		if (!pndl) {
+			rc = ENODEV;
+			goto sndmgtqwt;
+		}
+	} else {
+		finddid = (uint32_t)((unsigned long)cip->lpfc_arg3);
+		if (!(pndl = lpfc_findnode_did(phba, 
+					       NLP_SEARCH_MAPPED |
+					       NLP_SEARCH_UNMAPPED, finddid))) {
+			if (phba->fc_flag & FC_FABRIC) {
+				if ((pndl = lpfc_nlp_alloc(phba, 0)) == 0) {
+					rc = ENODEV;
+					goto sndmgtqwt;
+				}
+
+				memset(pndl, 0, sizeof (LPFC_NODELIST_t));
+				pndl->nlp_DID = finddid;
+
+				if (lpfc_issue_els_plogi(phba, pndl, 0)) {
+					lpfc_nlp_free(phba, pndl);
+					rc = ENODEV;
+					goto sndmgtqwt;
+				}
+
+				pndl->nlp_state = NLP_STE_PLOGI_ISSUE;
+				lpfc_nlp_plogi(phba, pndl);
+
+				/* Allow the node to complete discovery */
+				while ((i0++ < 4) &&
+				       ! (pndl = lpfc_findnode_did(phba,
+								   NLP_SEARCH_MAPPED |
+								   NLP_SEARCH_UNMAPPED, finddid))) {
+					LPFC_DRVR_UNLOCK(phba, iflag);
+					lpfc_sleep_ms(phba, 500);
+					LPFC_DRVR_LOCK(phba, iflag);
+				}
+
+				if (i0 == 4) {
+					rc = ENODEV;
+					goto sndmgtqwt;
+				}
+			}
+			else {
+				rc = ENODEV;
+				goto sndmgtqwt;
+			}
+		}
+	}
+
+	if (!pndl || !(psli->sliinit.sli_flag & LPFC_SLI2_ACTIVE)) {
+		rc = EACCES;
+		goto sndmgtqwt;
+	}
+	if (pndl->nlp_flag & NLP_ELS_SND_MASK) {
+		rc = ENODEV;
+		goto sndmgtqwt;
+	}
+	if ((cmdiocbq = lpfc_iocb_alloc(phba, MEM_PRI)) == 0) {
+		rc = ENOMEM;
+		goto sndmgtqwt;
+	}
+	memset((void *)cmdiocbq, 0, sizeof (LPFC_IOCBQ_t));
+	cmd = &(cmdiocbq->iocb);
+
+	if ((rspiocbq = lpfc_iocb_alloc(phba, MEM_PRI)) == 0) {
+		rc = ENOMEM;
+		goto sndmgtqwt;
+	}
+	memset((void *)rspiocbq, 0, sizeof (LPFC_IOCBQ_t));
+	rsp = &(rspiocbq->iocb);
+
+	if (((bmp = kmalloc(sizeof (DMABUF_t), GFP_ATOMIC)) == 0) ||
+	    ((bmp->virt = lpfc_mbuf_alloc(phba, 0, &(bmp->phys))) == 0)) {
+		if (bmp)
+			kfree(bmp);
+		bmp = NULL;
+		rc = ENOMEM;
+		goto sndmgtqwt;
+	}
+	INIT_LIST_HEAD(&bmp->list);
+
+	bpl = (ULP_BDE64 *) bmp->virt;
+	if ((indmp = dfc_cmd_data_alloc(phba, (char *)cip->lpfc_arg1, bpl,
+					reqbfrcnt)) == 0) {
+		lpfc_mbuf_free(phba, bmp->virt, bmp->phys);
+		kfree(bmp);
+		bmp = NULL;
+		rc = ENOMEM;
+		goto sndmgtqwt;
+	}
+	bpl += indmp->flag;	/* flag contains total number of BPLs for xmit */
+	if ((outdmp = dfc_cmd_data_alloc(phba, 0, bpl, snsbfrcnt)) == 0) {
+		dfc_cmd_data_free(phba, indmp);
+		lpfc_mbuf_free(phba, bmp->virt, bmp->phys);
+		kfree(bmp);
+		bmp = NULL;
+		rc = ENOMEM;
+		goto sndmgtqwt;
+	}
+
+	cmd->un.genreq64.bdl.ulpIoTag32 = 0;
+	cmd->un.genreq64.bdl.addrHigh = putPaddrHigh(bmp->phys);
+	cmd->un.genreq64.bdl.addrLow = putPaddrLow(bmp->phys);
+	cmd->un.genreq64.bdl.bdeFlags = BUFF_TYPE_BDL;
+	cmd->un.genreq64.bdl.bdeSize =
+	    (outdmp->flag + indmp->flag) * sizeof (ULP_BDE64);
+	cmd->ulpCommand = CMD_GEN_REQUEST64_CR;
+	cmd->un.genreq64.w5.hcsw.Fctl = (SI | LA);
+	cmd->un.genreq64.w5.hcsw.Dfctl = 0;
+	cmd->un.genreq64.w5.hcsw.Rctl = FC_UNSOL_CTL;
+	cmd->un.genreq64.w5.hcsw.Type = FC_COMMON_TRANSPORT_ULP;
+	cmd->ulpIoTag = lpfc_sli_next_iotag(phba, pring);
+	cmd->ulpTimeout = cip->lpfc_flag;
+	cmd->ulpBdeCount = 1;
+	cmd->ulpLe = 1;
+	cmd->ulpClass = CLASS3;
+	cmd->ulpContext = pndl->nlp_rpi;
+	cmd->ulpOwner = OWN_CHIP;
+	cmdiocbq->context1 = (uint8_t *) 0;
+	cmdiocbq->context2 = (uint8_t *) 0;
+	cmdiocbq->iocb_flag |= LPFC_IO_LIBDFC;
+
+	if (cip->lpfc_flag < (phba->fc_ratov * 2 + LPFC_DRVR_TIMEOUT)) {
+		timeout = phba->fc_ratov * 2 + LPFC_DRVR_TIMEOUT;
+	} else {
+		timeout = cip->lpfc_flag;
+	}
+
+	for (rc = -1, i0 = 0; i0 < 4 && rc != IOCB_SUCCESS; i0++) {
+		rc = lpfc_sli_issue_iocb_wait(phba, pring, cmdiocbq,
+					     SLI_IOCB_USE_TXQ, rspiocbq,
+					     timeout);
+		if (rc == IOCB_ERROR) {
+			rc = EACCES;
+			goto sndmgtqwt;
+		}
+	}
+
+	if (rc != IOCB_SUCCESS) {
+		goto sndmgtqwt;
+	}
+	if (rsp->ulpStatus) {
+		if (rsp->ulpStatus == IOSTAT_LOCAL_REJECT) {
+			switch (rsp->un.ulpWord[4] & 0xff) {
+			case IOERR_SEQUENCE_TIMEOUT:
+				rc = ETIMEDOUT;
+				break;
+			case IOERR_INVALID_RPI:
+				rc = EFAULT;
+				break;
+			default:
+				rc = EACCES;
+				break;
+			}
+
+			goto sndmgtqwt;
+		}
+	} else {
+		outdmp->flag = rsp->un.genreq64.bdl.bdeSize;
+	}
+	if (outdmp->flag > snsbfrcnt) {	/* copy back response data */
+		rc = ERANGE;	/* C_CT Request error */
+		lpfc_printf_log(phba->brd_no, &lpfc_msgBlk1208,	/* ptr to msg structure */
+			       lpfc_mes1208,	/* ptr to msg */
+			       lpfc_msgBlk1208.msgPreambleStr,	/* begin varargs */
+			       outdmp->flag, 4096);	/* end varargs */
+		goto sndmgtqwt;
+	}
+	/* copy back size of response, and response itself */
+	memcpy(dataout, (char *)&outdmp->flag, sizeof (int));
+	if (dfc_rsp_data_copy
+	    (phba, (uint8_t *) cip->lpfc_arg2, outdmp, outdmp->flag)) {
+		rc = EIO;
+		goto sndmgtqwt;
+	}
+      sndmgtqwt:
+	dfc_cmd_data_free(phba, indmp);
+	dfc_cmd_data_free(phba, outdmp);
+	if (mp) {
+		lpfc_mbuf_free(phba, mp->virt, mp->phys);
+		kfree(mp);
+	}
+	if (bmp) {
+		lpfc_mbuf_free(phba, bmp->virt, bmp->phys);
+		kfree(bmp);
+	}
+	if (cmdiocbq)
+		lpfc_iocb_free(phba, cmdiocbq);
+	if (rspiocbq)
+		lpfc_iocb_free(phba, rspiocbq);
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_mbox(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip, void *dataout)
+{
+	MAILBOX_t *pmbox;
+	uint32_t size;
+	dma_addr_t lptr;
+	struct dfc_info *di;
+	LPFC_MBOXQ_t *pmboxq;
+	DMABUF_t *pbfrnfo;
+	unsigned long iflag;
+	int count = 0;
+	int rc = 0;
+	int mbxstatus = 0;
+
+	/* Allocate mbox structure */
+	if ((pmbox = (MAILBOX_t *) lpfc_mbox_alloc(phba, MEM_PRI)) == 0) {
+		return ENOMEM;
+	}
+
+	/* Allocate mboxq structure */
+	if ((pmboxq = lpfc_mbox_alloc(phba, MEM_PRI)) == 0) {
+		lpfc_mbox_free(phba, (LPFC_MBOXQ_t *) pmbox);
+		return ENOMEM;
+	}
+
+	/* Allocate mbuf structure */
+	if (((pbfrnfo = kmalloc(sizeof (DMABUF_t), GFP_ATOMIC)) == 0) ||
+	    ((pbfrnfo->virt = lpfc_mbuf_alloc(phba,
+					      0, &(pbfrnfo->phys))) == 0)) {
+		if (pbfrnfo)
+			kfree(pbfrnfo);
+		lpfc_mbox_free(phba, (LPFC_MBOXQ_t *) pmbox);
+		lpfc_mbox_free(phba, pmboxq);
+		return ENOMEM;
+	}
+	INIT_LIST_HEAD(&pbfrnfo->list);
+	di = &dfc.dfc_info[cip->lpfc_brd];
+
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	if (copy_from_user((uint8_t *) pmbox, (uint8_t *) cip->lpfc_arg1,
+			   MAILBOX_CMD_WSIZE * sizeof (uint32_t))) {
+		LPFC_DRVR_LOCK(phba, iflag);
+		lpfc_mbox_free(phba, (LPFC_MBOXQ_t *) pmbox);
+		lpfc_mbox_free(phba, pmboxq);
+		lpfc_mbuf_free(phba, pbfrnfo->virt, pbfrnfo->phys);
+		kfree(pbfrnfo);
+		return EIO;
+	}
+	LPFC_DRVR_LOCK(phba, iflag);
+
+	while (di->fc_flag & DFC_MBOX_ACTIVE) {
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		lpfc_sleep_ms(phba, 5);
+		LPFC_DRVR_LOCK(phba, iflag);
+		if (count++ == 200)
+			break;
+	}
+
+	if (count >= 200) {
+		pmbox->mbxStatus = MBXERR_ERROR;
+		rc = EAGAIN;
+		goto mbout_err;
+	} else {
+#ifdef _LP64
+		if ((pmbox->mbxCommand == MBX_READ_SPARM) ||
+		    (pmbox->mbxCommand == MBX_READ_RPI) ||
+		    (pmbox->mbxCommand == MBX_REG_LOGIN) ||
+		    (pmbox->mbxCommand == MBX_READ_LA)) {
+			/* Must use 64 bit versions of these mbox cmds */
+			pmbox->mbxStatus = MBXERR_ERROR;
+			rc = ENODEV;
+			goto mbout_err;
+		}
+#endif
+		di->fc_flag |= DFC_MBOX_ACTIVE;
+		lptr = 0;
+		size = 0;
+		switch (pmbox->mbxCommand) {
+			/* Offline only */
+		case MBX_WRITE_NV:
+		case MBX_INIT_LINK:
+		case MBX_DOWN_LINK:
+		case MBX_CONFIG_LINK:
+		case MBX_CONFIG_RING:
+		case MBX_RESET_RING:
+		case MBX_UNREG_LOGIN:
+		case MBX_CLEAR_LA:
+		case MBX_DUMP_CONTEXT:
+		case MBX_RUN_DIAGS:
+		case MBX_RESTART:
+		case MBX_FLASH_WR_ULA:
+		case MBX_SET_MASK:
+		case MBX_SET_SLIM:
+		case MBX_SET_DEBUG:
+			if (!(phba->fc_flag & FC_OFFLINE_MODE)) {
+				pmbox->mbxStatus = MBXERR_ERROR;
+				di->fc_flag &= ~DFC_MBOX_ACTIVE;
+				goto mbout_err;
+			}
+			break;
+
+			/* Online / Offline */
+		case MBX_LOAD_SM:
+		case MBX_READ_NV:
+		case MBX_READ_CONFIG:
+		case MBX_READ_RCONFIG:
+		case MBX_READ_STATUS:
+		case MBX_READ_XRI:
+		case MBX_READ_REV:
+		case MBX_READ_LNK_STAT:
+		case MBX_DUMP_MEMORY:
+		case MBX_DOWN_LOAD:
+		case MBX_UPDATE_CFG:
+		case MBX_LOAD_AREA:
+		case MBX_LOAD_EXP_ROM:
+			break;
+
+			/* Online / Offline - with DMA */
+		case MBX_READ_SPARM64:
+			lptr = getPaddr(pmbox->un.varRdSparm.un.sp64.addrHigh,
+					pmbox->un.varRdSparm.un.sp64.addrLow);
+			size = (int)pmbox->un.varRdSparm.un.sp64.tus.f.bdeSize;
+			if (lptr) {
+				pmbox->un.varRdSparm.un.sp64.addrHigh =
+				    putPaddrHigh(pbfrnfo->phys);
+				pmbox->un.varRdSparm.un.sp64.addrLow =
+				    putPaddrLow(pbfrnfo->phys);
+			}
+			break;
+
+		case MBX_READ_RPI64:
+			/* This is only allowed when online is SLI2 mode */
+			lptr = getPaddr(pmbox->un.varRdRPI.un.sp64.addrHigh,
+					pmbox->un.varRdRPI.un.sp64.addrLow);
+			size = (int)pmbox->un.varRdRPI.un.sp64.tus.f.bdeSize;
+			if (lptr) {
+				pmbox->un.varRdRPI.un.sp64.addrHigh =
+				    putPaddrHigh(pbfrnfo->phys);
+				pmbox->un.varRdRPI.un.sp64.addrLow =
+				    putPaddrLow(pbfrnfo->phys);
+			}
+			break;
+
+		case MBX_READ_LA:
+		case MBX_READ_LA64:
+		case MBX_REG_LOGIN:
+		case MBX_REG_LOGIN64:
+		case MBX_CONFIG_PORT:
+		case MBX_RUN_BIU_DIAG:
+			/* Do not allow SLI-2 commands */
+			pmbox->mbxStatus = MBXERR_ERROR;
+			di->fc_flag &= ~DFC_MBOX_ACTIVE;
+			goto mbout_err;
+
+		default:
+			/* Offline only
+			 * Let firmware return error for unsupported commands
+			 */
+			if (!(phba->fc_flag & FC_OFFLINE_MODE)) {
+				pmbox->mbxStatus = MBXERR_ERROR;
+				di->fc_flag &= ~DFC_MBOX_ACTIVE;
+				goto mbout_err;
+			}
+			break;
+		}		/* switch pmbox->command */
+
+		{
+			MAILBOX_t *pmb = &pmboxq->mb;
+			LPFC_SLI_t *psli = &phba->sli;
+
+			memset((void *)pmboxq, 0, sizeof (LPFC_MBOXQ_t));
+			pmb->mbxCommand = pmbox->mbxCommand;
+			pmb->mbxOwner = pmbox->mbxOwner;
+			pmb->un = pmbox->un;
+			pmb->us = pmbox->us;
+			pmboxq->context1 = (uint8_t *) 0;
+			if ((phba->fc_flag & FC_OFFLINE_MODE) ||
+			    (!(psli->sliinit.sli_flag & LPFC_SLI2_ACTIVE))){
+				LPFC_DRVR_UNLOCK(phba, iflag);
+				mbxstatus =
+				    lpfc_sli_issue_mbox(phba, pmboxq, MBX_POLL);
+				LPFC_DRVR_LOCK(phba, iflag);
+			} else
+				mbxstatus =
+				    lpfc_sli_issue_mbox_wait(phba, pmboxq,
+							    LPFC_MBOX_TMO);
+			di->fc_flag &= ~DFC_MBOX_ACTIVE;
+
+			if (mbxstatus == MBX_TIMEOUT) {
+				rc = EBUSY;
+				goto mbout;
+			} else if (mbxstatus != MBX_SUCCESS) {
+				rc = ENODEV;
+				/* Not successful */
+				goto mbout;
+			}
+		}
+
+		if (lptr) {
+			LPFC_DRVR_UNLOCK(phba, iflag);
+			if ((copy_to_user
+			     ((uint8_t *) & lptr, (uint8_t *) pbfrnfo->virt,
+			      (ulong) size))) {
+				rc = EIO;
+			}
+			LPFC_DRVR_LOCK(phba, iflag);
+		}
+	}
+
+      mbout:
+	{
+		MAILBOX_t *pmb = &pmboxq->mb;
+
+		memcpy(dataout, (char *)pmb,
+		       MAILBOX_CMD_WSIZE * sizeof (uint32_t));
+	}
+
+	goto mbout_freemem;
+
+      mbout_err:
+	{
+		/* Jump here only if there is an error and copy the status */
+		memcpy(dataout, (char *)pmbox,
+		       MAILBOX_CMD_WSIZE * sizeof (uint32_t));
+	}
+
+      mbout_freemem:
+	/* Free allocated mbox memory */
+	if (pmbox)
+		lpfc_mbox_free(phba, (LPFC_MBOXQ_t *) pmbox);
+
+	/* Free allocated mboxq memory */
+	if (pmboxq) {
+		if (mbxstatus == MBX_TIMEOUT) {
+			/*
+			 * Let SLI layer to release mboxq if mbox command completed after timeout.
+			 */
+			pmboxq->mbox_cmpl = 0;
+		} else {
+			lpfc_mbox_free(phba, pmboxq);
+		}
+	}
+
+	/* Free allocated mbuf memory */
+	if (pbfrnfo) {
+		lpfc_mbuf_free(phba, pbfrnfo->virt, pbfrnfo->phys);
+		kfree(pbfrnfo);
+	}
+
+	return (rc);
+}
+int
+lpfc_ioctl_linkinfo(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip, void *dataout)
+{
+	LinkInfo *linkinfo;
+	int rc = 0;
+
+	linkinfo = (LinkInfo *) dataout;
+	linkinfo->a_linkEventTag = phba->fc_eventTag;
+	linkinfo->a_linkUp = phba->fc_stat.LinkUp;
+	linkinfo->a_linkDown = phba->fc_stat.LinkDown;
+	linkinfo->a_linkMulti = phba->fc_stat.LinkMultiEvent;
+	linkinfo->a_DID = phba->fc_myDID;
+	if (phba->fc_topology == TOPOLOGY_LOOP) {
+		if (phba->fc_flag & FC_PUBLIC_LOOP) {
+			linkinfo->a_topology = LNK_PUBLIC_LOOP;
+			memcpy((uint8_t *) linkinfo->a_alpaMap,
+			       (uint8_t *) phba->alpa_map, 128);
+			linkinfo->a_alpaCnt = phba->alpa_map[0];
+		} else {
+			linkinfo->a_topology = LNK_LOOP;
+			memcpy((uint8_t *) linkinfo->a_alpaMap,
+			       (uint8_t *) phba->alpa_map, 128);
+			linkinfo->a_alpaCnt = phba->alpa_map[0];
+		}
+	} else {
+		memset((uint8_t *) linkinfo->a_alpaMap, 0, 128);
+		linkinfo->a_alpaCnt = 0;
+		if (phba->fc_flag & FC_FABRIC) {
+			linkinfo->a_topology = LNK_FABRIC;
+		} else {
+			linkinfo->a_topology = LNK_PT2PT;
+		}
+	}
+	linkinfo->a_linkState = 0;
+	switch (phba->hba_state) {
+	case LPFC_INIT_START:
+
+	case LPFC_LINK_DOWN:
+		linkinfo->a_linkState = LNK_DOWN;
+		memset((uint8_t *) linkinfo->a_alpaMap, 0, 128);
+		linkinfo->a_alpaCnt = 0;
+		break;
+	case LPFC_LINK_UP:
+
+	case LPFC_LOCAL_CFG_LINK:
+		linkinfo->a_linkState = LNK_UP;
+		break;
+	case LPFC_FLOGI:
+		linkinfo->a_linkState = LNK_FLOGI;
+		break;
+	case LPFC_DISC_AUTH:
+	case LPFC_FABRIC_CFG_LINK:
+	case LPFC_NS_REG:
+	case LPFC_NS_QRY:
+
+	case LPFC_CLEAR_LA:
+		linkinfo->a_linkState = LNK_DISCOVERY;
+		break;
+	case LPFC_HBA_READY:
+		linkinfo->a_linkState = LNK_READY;
+		break;
+	}
+	linkinfo->a_alpa = (uint8_t) (phba->fc_myDID & 0xff);
+	memcpy((uint8_t *) linkinfo->a_wwpName,
+	       (uint8_t *) & phba->fc_portname, 8);
+	memcpy((uint8_t *) linkinfo->a_wwnName,
+	       (uint8_t *) & phba->fc_nodename, 8);
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_ioinfo(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip, void *dataout)
+{
+
+	IOinfo *ioinfo;
+	LPFC_SLI_t *psli;
+	int rc = 0;
+
+	psli = &phba->sli;
+
+	ioinfo = (IOinfo *) dataout;
+	ioinfo->a_mbxCmd = psli->slistat.mboxCmd;
+	ioinfo->a_mboxCmpl = psli->slistat.mboxEvent;
+	ioinfo->a_mboxErr = psli->slistat.mboxStatErr;
+	ioinfo->a_iocbCmd = psli->slistat.iocbCmd[cip->lpfc_ring];
+	ioinfo->a_iocbRsp = psli->slistat.iocbRsp[cip->lpfc_ring];
+	ioinfo->a_adapterIntr = (psli->slistat.linkEvent +
+				 psli->slistat.iocbRsp[cip->lpfc_ring] +
+				 psli->slistat.mboxEvent);
+	ioinfo->a_fcpCmd = phba->fc_stat.fcpCmd;
+	ioinfo->a_fcpCmpl = phba->fc_stat.fcpCmpl;
+	ioinfo->a_fcpErr = phba->fc_stat.fcpRspErr +
+	    phba->fc_stat.fcpRemoteStop + phba->fc_stat.fcpPortRjt +
+	    phba->fc_stat.fcpPortBusy + phba->fc_stat.fcpError +
+	    phba->fc_stat.fcpLocalErr;
+	ioinfo->a_bcastRcv = phba->fc_stat.frameRcvBcast;
+	ioinfo->a_RSCNRcv = phba->fc_stat.elsRcvRSCN;
+	ioinfo->a_cnt1 = 0;
+	ioinfo->a_cnt2 = 0;
+	ioinfo->a_cnt3 = 0;
+	ioinfo->a_cnt4 = 0;
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_nodeinfo(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip, void *dataout, int size)
+{
+	NodeInfo *np;
+	LPFC_NODELIST_t *pndl;
+	LPFC_BINDLIST_t *pbdl;
+	uint32_t cnt;
+	int rc = 0;
+	uint32_t total_mem = size;
+	struct list_head *pos, *listp;
+	struct list_head *node_list[4];
+	int i;
+
+	np = (NodeInfo *) dataout;
+	cnt = 0;
+
+	/* Since the size of bind & others are different,
+	   get the node list of bind first
+	 */
+	total_mem -= sizeof (LPFC_BINDLIST_t);
+
+	list_for_each(pos, &phba->fc_nlpbind_list) {
+		if (total_mem <= 0)
+			break;
+		pbdl = list_entry(pos, LPFC_BINDLIST_t, nlp_listp);
+		memset((uint8_t *) np, 0, sizeof (LPFC_BINDLIST_t));
+		if (pbdl->nlp_bind_type & FCP_SEED_WWPN)
+			np->a_flag |= NODE_SEED_WWPN;
+		if (pbdl->nlp_bind_type & FCP_SEED_WWNN)
+			np->a_flag |= NODE_SEED_WWNN;
+		if (pbdl->nlp_bind_type & FCP_SEED_DID)
+			np->a_flag |= NODE_SEED_DID;
+		if (pbdl->nlp_bind_type & FCP_SEED_AUTO)
+			np->a_flag |= NODE_AUTOMAP;
+		np->a_state = NODE_SEED;
+		np->a_did = pbdl->nlp_DID;
+		np->a_targetid = pbdl->nlp_sid;
+		memcpy(np->a_wwpn, &pbdl->nlp_portname, 8);
+		memcpy(np->a_wwnn, &pbdl->nlp_nodename, 8);
+		total_mem -= sizeof (LPFC_BINDLIST_t);
+		np++;
+		cnt++;
+	}
+
+	/* Get the node list of unmap, map, plogi and adisc
+	 */
+	total_mem -= sizeof (LPFC_NODELIST_t);
+
+	node_list[0] = &phba->fc_plogi_list;
+	node_list[1] = &phba->fc_adisc_list;
+	node_list[2] = &phba->fc_nlpunmap_list;
+	node_list[3] = &phba->fc_nlpmap_list;
+	for (i = 0; i < 4; i++) {
+		listp = node_list[i];
+		if (list_empty(listp)) 
+			continue;	
+
+		list_for_each(pos, listp) {
+			pndl = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+			if (total_mem <= 0)
+				break;
+			memset((uint8_t *) np, 0, sizeof (LPFC_NODELIST_t));
+			if (pndl->nlp_flag & NLP_ADISC_LIST) {
+				np->a_flag |= NODE_ADDR_AUTH;
+				np->a_state = NODE_LIMBO;
+			}
+			if (pndl->nlp_flag & NLP_PLOGI_LIST) {
+				np->a_state = NODE_PLOGI;
+			}
+			if (pndl->nlp_flag & NLP_MAPPED_LIST) {
+				np->a_state = NODE_ALLOC;
+			}
+			if (pndl->nlp_flag & NLP_UNMAPPED_LIST) {
+				np->a_state = NODE_PRLI;
+			}
+			if (pndl->nlp_type & NLP_FABRIC)
+				np->a_flag |= NODE_FABRIC;
+			if (pndl->nlp_type & NLP_FCP_TARGET)
+				np->a_flag |= NODE_FCP_TARGET;
+			if (pndl->nlp_flag & NLP_ELS_SND_MASK)	/* Sent ELS mask  -- Check this */
+				np->a_flag |= NODE_REQ_SND;
+			if (pndl->nlp_flag & NLP_FARP_SND)
+				np->a_flag |= NODE_FARP_SND;
+			if (pndl->nlp_flag & NLP_SEED_WWPN)
+				np->a_flag |= NODE_SEED_WWPN;
+			if (pndl->nlp_flag & NLP_SEED_WWNN)
+				np->a_flag |= NODE_SEED_WWNN;
+			if (pndl->nlp_flag & NLP_SEED_DID)
+				np->a_flag |= NODE_SEED_DID;
+			if (pndl->nlp_flag & NLP_AUTOMAP)
+				np->a_flag |= NODE_AUTOMAP;
+			np->a_did = pndl->nlp_DID;
+			np->a_targetid = pndl->nlp_sid;
+			memcpy(np->a_wwpn, &pndl->nlp_portname, 8);
+			memcpy(np->a_wwnn, &pndl->nlp_nodename, 8);
+			total_mem -= sizeof (LPFC_NODELIST_t);
+			np++;
+			cnt++;
+		}
+	}
+	cip->lpfc_outsz = (uint32_t) (cnt * sizeof (NodeInfo));
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_getcfg(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip, void *dataout)
+{
+
+	CfgParam *cp;
+	iCfgParam *icp;
+	uint32_t cnt;
+	lpfcCfgParam_t *clp;
+	int i, rc = 0, astringi;
+
+	clp = &phba->config[0];
+	/* First uint32_t word will be count */
+	cp = (CfgParam *) dataout;
+	cnt = 0;
+	for (i = 0; i < LPFC_TOTAL_NUM_OF_CFG_PARAM; i++) {
+		icp = (iCfgParam *) & clp[i];
+		if (!(icp->a_flag & CFG_EXPORT))
+			continue;
+		cp->a_low = icp->a_low;
+		cp->a_hi = icp->a_hi;
+		cp->a_flag = icp->a_flag;
+		cp->a_default = icp->a_default;
+		if (i == LPFC_CFG_FCP_CLASS) {
+			switch (icp->a_current) {
+			case CLASS1:
+				cp->a_current = 1;
+				break;
+			case CLASS2:
+				cp->a_current = 2;
+				break;
+			case CLASS3:
+				cp->a_current = 3;
+				break;
+			}
+		} else {
+			cp->a_current = icp->a_current;
+		}
+		cp->a_changestate = icp->a_changestate;
+		memcpy(cp->a_string, icp->a_string, 32);
+
+		/* Translate all "_" to "-" to preserve backwards compatibility
+		with older drivers that used "_" */
+		astringi=0;
+		while(cp->a_string[astringi++])
+			if(cp->a_string[astringi] == '_')
+				cp->a_string[astringi] = '-';
+
+		memcpy(cp->a_help, icp->a_help, 80);
+		cp++;
+		cnt++;
+	}
+	if (cnt) {
+		cip->lpfc_outsz = (uint32_t) (cnt * sizeof (CfgParam));
+	}
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_setcfg(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip)
+{
+
+	iCfgParam *icp;
+	uint32_t offset, cnt;
+	lpfcCfgParam_t *clp;
+	LPFC_SLI_t *psli;
+	int rc = 0;
+	int i, j;
+
+	psli = &phba->sli;
+	clp = &phba->config[0];
+	offset = (ulong) cip->lpfc_arg1;
+	cnt = (ulong) cip->lpfc_arg2;
+	if (offset >= LPFC_TOTAL_NUM_OF_CFG_PARAM) {
+		rc = ERANGE;
+		return (rc);
+	}
+	j = offset;
+	for (i = 0; i < LPFC_TOTAL_NUM_OF_CFG_PARAM; i++) {
+		icp = (iCfgParam *) & clp[i];
+		if (!(icp->a_flag & CFG_EXPORT))
+			continue;
+		if (j == 0)
+			break;
+		j--;
+	}
+	if (icp->a_changestate != CFG_DYNAMIC) {
+		rc = EPERM;
+		return (rc);
+	}
+	if (((icp->a_low != 0) && (cnt < icp->a_low)) || (cnt > icp->a_hi)) {
+		rc = ERANGE;
+		return (rc);
+	}
+	if (!(icp->a_flag & CFG_EXPORT)) {
+		rc = EPERM;
+		return (rc);
+	}
+	switch (offset) {
+	case LPFC_CFG_FCP_CLASS:
+		switch (cnt) {
+		case 1:
+			clp[LPFC_CFG_FCP_CLASS].a_current = CLASS1;
+			break;
+		case 2:
+			clp[LPFC_CFG_FCP_CLASS].a_current = CLASS2;
+			break;
+		case 3:
+			clp[LPFC_CFG_FCP_CLASS].a_current = CLASS3;
+			break;
+		}
+		icp->a_current = cnt;
+		break;
+
+	case LPFC_CFG_LINKDOWN_TMO:
+		icp->a_current = cnt;
+		break;
+
+	default:
+		icp->a_current = cnt;
+	}
+
+	return (rc);
+}
+
+int
+lpfc_ioctl_hba_get_event(lpfcHBA_t * phba,
+			 LPFCCMDINPUT_t * cip, 
+			 void *dataout, int data_size)
+{
+	fcEVT_t *ep;
+	fcEVT_t *oep;
+	fcEVTHDR_t *ehp;
+	uint8_t *cp;
+	void *type;
+	uint32_t offset, incr, size, cnt, i, gstype;
+	DMABUF_t *mm;
+	int no_more;
+	int rc = 0;
+	uint32_t total_mem = data_size;
+	unsigned long iflag;
+	struct list_head head, *pos, *tmp_pos;
+
+	no_more = 1;
+
+	offset = ((ulong) cip->lpfc_arg3 &	/* event mask */
+		  FC_REG_EVENT_MASK);	/* event mask */
+	incr = (uint32_t) cip->lpfc_flag;	/* event id   */
+	size = (uint32_t) cip->lpfc_iocb;	/* process requesting evt  */
+
+	type = 0;
+	switch (offset) {
+	case FC_REG_CT_EVENT:
+		LPFC_DRVR_UNLOCK(phba, iflag);
+		if (copy_from_user
+		    ((uint8_t *) & gstype, (uint8_t *) cip->lpfc_arg2,
+		     (ulong) (sizeof (uint32_t)))) {
+			rc = EIO;
+			LPFC_DRVR_LOCK(phba, iflag);
+			return (rc);
+		}
+		LPFC_DRVR_LOCK(phba, iflag);
+		type = (void *)(ulong) gstype;
+		break;
+	}
+
+	ehp = (fcEVTHDR_t *) phba->fc_evt_head;
+
+	while (ehp) {
+		if ((ehp->e_mask == offset) && (ehp->e_type == type))
+			break;
+		ehp = (fcEVTHDR_t *) ehp->e_next_header;
+	}
+
+	if (!ehp) {
+		rc = ENOENT;
+		return (rc);
+	}
+
+	ep = ehp->e_head;
+	oep = 0;
+	while (ep) {
+		/* Find an event that matches the event mask */
+		if (ep->evt_sleep == 0) {
+			/* dequeue event from event list */
+			if (oep == 0) {
+				ehp->e_head = ep->evt_next;
+			} else {
+				oep->evt_next = ep->evt_next;
+			}
+			if (ehp->e_tail == ep)
+				ehp->e_tail = oep;
+
+			switch (offset) {
+			case FC_REG_LINK_EVENT:
+				break;
+			case FC_REG_RSCN_EVENT:
+				/* Return data length */
+				cnt = sizeof (uint32_t);
+				LPFC_DRVR_UNLOCK(phba, iflag);
+				if (copy_to_user
+				    ((uint8_t *) cip->lpfc_arg1,
+				     (uint8_t *) & cnt, sizeof (uint32_t))) {
+					rc = EIO;
+				}
+				LPFC_DRVR_LOCK(phba, iflag);
+				memcpy(dataout, (char *)&ep->evt_data0,
+				       cnt);
+				cip->lpfc_outsz = (uint32_t) cnt;
+				break;
+			case FC_REG_CT_EVENT:
+				/* Return data length */
+				cnt = (ulong) (ep->evt_data2);
+				LPFC_DRVR_UNLOCK(phba, iflag);
+				if (copy_to_user
+				    ((uint8_t *) cip->lpfc_arg1,
+				     (uint8_t *) & cnt, sizeof (uint32_t))) {
+					rc = EIO;
+				} else {
+					if (copy_to_user
+					    ((uint8_t *) cip->lpfc_arg2,
+					     (uint8_t *) & ep->evt_data0,
+					     sizeof (uint32_t))) {
+						rc = EIO;
+					}
+				}
+				LPFC_DRVR_LOCK(phba, iflag);
+
+				cip->lpfc_outsz = (uint32_t) cnt;
+				i = cnt;
+				mm = (DMABUF_t *) ep->evt_data1;
+				cp = (uint8_t *) dataout;
+				list_add_tail(&head, &mm->list);
+				list_for_each_safe(pos, tmp_pos, &head) {
+					mm = list_entry(pos, DMABUF_t, list);
+
+					if (cnt > FCELSSIZE)
+						i = FCELSSIZE;
+					else
+						i = cnt;
+
+					if (total_mem > 0) {
+						memcpy(cp, (char *)mm->virt, i);
+						total_mem -= i;
+					}
+
+					cp += i;
+					lpfc_mbuf_free(phba, mm->virt,
+						       mm->phys);
+					list_del(pos);
+					kfree(mm);
+				}
+				list_del(&head);
+				break;
+			}
+
+			if ((offset == FC_REG_CT_EVENT) && (ep->evt_next) &&
+			    (((fcEVT_t *) (ep->evt_next))->evt_sleep == 0)) {
+				ep->evt_data0 |= 0x80000000;	/* More event r waiting */
+				LPFC_DRVR_UNLOCK(phba, iflag);
+				if (copy_to_user
+				    ((uint8_t *) cip->lpfc_arg2,
+				     (uint8_t *) & ep->evt_data0,
+				     sizeof (uint32_t))) {
+					rc = EIO;
+				}
+				LPFC_DRVR_LOCK(phba, iflag);
+				no_more = 0;
+			}
+
+			/* Requeue event entry */
+			ep->evt_next = 0;
+			ep->evt_data0 = 0;
+			ep->evt_data1 = 0;
+			ep->evt_data2 = 0;
+			ep->evt_sleep = 1;
+			ep->evt_flags = 0;
+
+			if (ehp->e_head == 0) {
+				ehp->e_head = ep;
+				ehp->e_tail = ep;
+			} else {
+				ehp->e_tail->evt_next = ep;
+				ehp->e_tail = ep;
+			}
+
+			if (offset == FC_REG_LINK_EVENT) {
+				ehp->e_flag &= ~E_GET_EVENT_ACTIVE;
+				rc = lpfc_ioctl_linkinfo(phba, cip, dataout);
+				return (rc);
+			}
+
+			if (no_more)
+				ehp->e_flag &= ~E_GET_EVENT_ACTIVE;
+			return (rc);
+			/*
+			   break;
+			 */
+		}
+		oep = ep;
+		ep = ep->evt_next;
+	}
+	if (ep == 0) {
+		/* No event found */
+		rc = ENOENT;
+	}
+
+	return (rc);
+}
+
+int
+lpfc_sleep_event(lpfcHBA_t * phba, fcEVTHDR_t * ep)
+{
+
+	ep->e_mode |= E_SLEEPING_MODE;
+	switch (ep->e_mask) {
+	case FC_REG_LINK_EVENT:
+		return (lpfc_sleep(phba, &phba->linkevtwq, 0));
+	case FC_REG_RSCN_EVENT:
+		return (lpfc_sleep(phba, &phba->rscnevtwq, 0));
+	case FC_REG_CT_EVENT:
+		return (lpfc_sleep(phba, &phba->ctevtwq, 0));
+	}
+	return (0);
+}
+
+int
+lpfc_ioctl_hba_set_event(lpfcHBA_t * phba,
+			 LPFCCMDINPUT_t * cip)
+{
+	fcEVT_t *evp;
+	fcEVT_t *ep;
+	fcEVT_t *oep;
+	fcEVTHDR_t *ehp;
+	fcEVTHDR_t *oehp;
+	int found;
+	void *type;
+	uint32_t offset, incr;
+	int rc = 0;
+
+	offset = (((ulong) cip->lpfc_arg3) &	/* event mask */
+		  FC_REG_EVENT_MASK);
+	incr = (uint32_t) cip->lpfc_flag;	/* event id   */
+	switch (offset) {
+	case FC_REG_CT_EVENT:
+		type = cip->lpfc_arg2;
+		found = LPFC_MAX_EVENT;	/* Number of events we can queue up + 1, before
+					 * dropping events for this event id.  */
+		break;
+	case FC_REG_RSCN_EVENT:
+		type = (void *)0;
+		found = LPFC_MAX_EVENT;	/* Number of events we can queue up + 1, before
+					 * dropping events for this event id.  */
+		break;
+	case FC_REG_LINK_EVENT:
+		type = (void *)0;
+		found = 2;	/* Number of events we can queue up + 1, before
+				 * dropping events for this event id.  */
+		break;
+	default:
+		found = 0;
+		rc = EINTR;
+		return (rc);
+	}
+
+	/*
+	 * find the fcEVT_t header for this Event, allocate a header
+	 * if not found.
+	 */
+	oehp = 0;
+	ehp = (fcEVTHDR_t *) phba->fc_evt_head;
+	while (ehp) {
+		if ((ehp->e_mask == offset) && (ehp->e_type == type)) {
+			found = 0;
+			break;
+		}
+		oehp = ehp;
+		ehp = (fcEVTHDR_t *) ehp->e_next_header;
+	}
+
+	if (!ehp) {
+		ehp = kmalloc (sizeof (fcEVTHDR_t),
+			       GFP_ATOMIC);
+		if (ehp == 0 ) {
+			rc = EINTR;
+			return (rc);
+		}
+		memset((char *)ehp, 0, sizeof (fcEVTHDR_t));
+		if (phba->fc_evt_head == 0) {
+			phba->fc_evt_head = ehp;
+			phba->fc_evt_tail = ehp;
+		} else {
+			((fcEVTHDR_t *) (phba->fc_evt_tail))->e_next_header =
+			    ehp;
+			phba->fc_evt_tail = (void *)ehp;
+		}
+		ehp->e_handle = incr;
+		ehp->e_mask = offset;
+		ehp->e_type = type;
+		ehp->e_refcnt++;
+	} else {
+		ehp->e_refcnt++;
+	}
+
+	while (found) {
+		/* Save event id for C_GET_EVENT */
+		oep = kmalloc (sizeof (fcEVT_t),
+			       GFP_ATOMIC);
+		if ( oep ==  0) {
+			rc = EINTR;
+			break;
+		}
+		memset((char *)oep, 0, sizeof (fcEVT_t));
+
+		oep->evt_sleep = 1;
+		oep->evt_handle = incr;
+		oep->evt_mask = offset;
+		oep->evt_type = type;
+
+		if (ehp->e_head == 0) {
+			ehp->e_head = oep;
+			ehp->e_tail = oep;
+		} else {
+			ehp->e_tail->evt_next = (void *)oep;
+			ehp->e_tail = oep;
+		}
+		oep->evt_next = 0;
+		found--;
+	}
+
+	switch (offset) {
+	case FC_REG_CT_EVENT:
+	case FC_REG_RSCN_EVENT:
+	case FC_REG_LINK_EVENT:
+
+		if (rc || lpfc_sleep_event(phba, ehp)) {
+			rc = EINTR;
+			ehp->e_mode &= ~E_SLEEPING_MODE;
+			ehp->e_refcnt--;
+			if (ehp->e_refcnt) {
+				goto setout;
+			}
+			/* Remove all eventIds from queue */
+			ep = ehp->e_head;
+			oep = 0;
+			found = 0;
+			while (ep) {
+				if (ep->evt_handle == incr) {
+					/* dequeue event from event list */
+					if (oep == 0) {
+						ehp->e_head = ep->evt_next;
+					} else {
+						oep->evt_next = ep->evt_next;
+					}
+					if (ehp->e_tail == ep)
+						ehp->e_tail = oep;
+					evp = ep;
+					ep = ep->evt_next;
+					kfree(evp);
+				} else {
+					oep = ep;
+					ep = ep->evt_next;
+				}
+			}
+
+			/*
+			 * No more fcEVT_t pointer under this fcEVTHDR_t
+			 * Free the fcEVTHDR_t
+			 */
+			if (ehp->e_head == 0) {
+				oehp = 0;
+				ehp = (fcEVTHDR_t *) phba->fc_evt_head;
+				while (ehp) {
+					if ((ehp->e_mask == offset) &&
+					    (ehp->e_type == type)) {
+						found = 0;
+						break;
+					}
+					oehp = ehp;
+					ehp = (fcEVTHDR_t *) ehp->e_next_header;
+				}
+				if (oehp == 0) {
+					phba->fc_evt_head = ehp->e_next_header;
+				} else {
+					oehp->e_next_header =
+					    ehp->e_next_header;
+				}
+				if (phba->fc_evt_tail == ehp)
+					phba->fc_evt_tail = oehp;
+
+				kfree(ehp);
+			}
+			goto setout;
+		}
+		ehp->e_refcnt--;
+		break;
+	}
+      setout:
+	return (rc);
+}
+
+int
+lpfc_ioctl_add_bind(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip)
+{
+
+	bind_ctl_t bind_ctl;
+	void *bind_id = 0;
+	uint8_t bind_type = FCP_SEED_WWNN;
+	int rc = 0;
+	unsigned long iflag;
+
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	if (copy_from_user((uint8_t *) & bind_ctl, (uint8_t *) cip->lpfc_arg1,
+			   (ulong) (sizeof (bind_ctl)))) {
+		rc = EIO;
+		LPFC_DRVR_LOCK(phba, iflag);
+		return rc;
+	}
+	LPFC_DRVR_LOCK(phba, iflag);
+
+	switch (bind_ctl.bind_type) {
+	case LPFC_WWNN_BIND:
+		bind_type = FCP_SEED_WWNN;
+		bind_id = &bind_ctl.wwnn[0];
+		break;
+	case LPFC_WWPN_BIND:
+		bind_type = FCP_SEED_WWPN;
+		bind_id = &bind_ctl.wwpn[0];
+		break;
+	case LPFC_DID_BIND:
+		bind_type = FCP_SEED_DID;
+		bind_id = &bind_ctl.did;
+		break;
+	default:
+		rc = EIO;
+		break;
+	}
+
+	if (rc)
+		return rc;
+
+	rc = lpfc_add_bind(phba, bind_type, bind_id, bind_ctl.scsi_id);
+	return rc;
+}
+
+int
+lpfc_ioctl_del_bind(lpfcHBA_t * phba, LPFCCMDINPUT_t * cip)
+{
+
+	bind_ctl_t bind_ctl;
+	void *bind_id = 0;
+	uint8_t bind_type = FCP_SEED_WWNN;
+	int rc = 0;
+	unsigned long iflag;
+
+	LPFC_DRVR_UNLOCK(phba, iflag);
+	if (copy_from_user((uint8_t *) & bind_ctl, (uint8_t *) cip->lpfc_arg1,
+			   (ulong) (sizeof (bind_ctl)))) {
+		LPFC_DRVR_LOCK(phba, iflag);
+		rc = EIO;
+		return rc;
+	}
+	LPFC_DRVR_LOCK(phba, iflag);
+
+	switch (bind_ctl.bind_type) {
+
+	case LPFC_WWNN_BIND:
+		bind_type = FCP_SEED_WWNN;
+		bind_id = &bind_ctl.wwnn[0];
+		break;
+
+	case LPFC_WWPN_BIND:
+		bind_type = FCP_SEED_WWPN;
+		bind_id = &bind_ctl.wwpn[0];
+		break;
+
+	case LPFC_DID_BIND:
+		bind_type = FCP_SEED_DID;
+		bind_id = &bind_ctl.did;
+		break;
+
+	case LPFC_SCSI_ID:
+		bind_id = 0;
+		break;
+
+	default:
+		rc = EIO;
+		break;
+	}
+
+	if (rc)
+		return rc;
+
+	rc = lpfc_del_bind(phba, bind_type, bind_id, bind_ctl.scsi_id);
+
+	return rc;
+}
+
+int
+lpfc_ioctl_list_bind(lpfcHBA_t * phba,
+		     LPFCCMDINPUT_t * cip, void *dataout, int *do_cp)
+{
+
+	unsigned long next_index = 0;
+	unsigned long max_index = (unsigned long)cip->lpfc_arg1;
+	HBA_BIND_LIST *bind_list;
+	HBA_BIND_ENTRY *bind_array;
+	LPFC_BINDLIST_t *pbdl;
+	LPFC_NODELIST_t *pndl;
+	struct list_head *pos;
+	int rc;
+
+	bind_list = (HBA_BIND_LIST *) dataout;
+	bind_array = &bind_list->entry[0];
+
+	/* Iterate through the mapped list */
+	list_for_each(pos, &phba->fc_nlpmap_list) {
+		pndl = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+		if (next_index >= max_index) {
+			rc = ERANGE;
+			*do_cp = 0;
+			return (rc);
+		}
+
+		memset(&bind_array[next_index], 0, sizeof (HBA_BIND_ENTRY));
+		bind_array[next_index].scsi_id = pndl->nlp_sid;
+		bind_array[next_index].did = pndl->nlp_DID;
+		memcpy(&bind_array[next_index].wwpn, &pndl->nlp_portname,
+		       sizeof (HBA_WWN));
+		memcpy(&bind_array[next_index].wwnn, &pndl->nlp_nodename,
+		       sizeof (HBA_WWN));
+		if (pndl->nlp_flag & NLP_AUTOMAP)
+			bind_array[next_index].flags |= HBA_BIND_AUTOMAP;
+		if (pndl->nlp_flag & NLP_SEED_WWNN)
+			bind_array[next_index].bind_type = BIND_WWNN;
+		if (pndl->nlp_flag & NLP_SEED_WWPN)
+			bind_array[next_index].bind_type = BIND_WWPN;
+		if (pndl->nlp_flag & NLP_SEED_ALPA)
+			bind_array[next_index].bind_type = BIND_ALPA;
+		else if (pndl->nlp_flag & NLP_SEED_DID)
+			bind_array[next_index].bind_type = BIND_DID;
+		bind_array[next_index].flags |= HBA_BIND_MAPPED;
+		if (pndl && pndl->nlp_Target) {
+		    if(pndl->nlp_Target->targetFlags & FC_NPR_ACTIVE)
+			bind_array[next_index].flags |= HBA_BIND_NODEVTMO;
+		    if(pndl->nlp_Target->rptLunState == REPORT_LUN_COMPLETE)
+			bind_array[next_index].flags |= HBA_BIND_RPTLUNST;
+		}
+		next_index++;
+	}
+
+	/* Iterate through the unmapped list */
+	list_for_each(pos, &phba->fc_nlpunmap_list) {
+		pndl = list_entry(pos, LPFC_NODELIST_t, nlp_listp);
+		if (next_index >= max_index) {
+			rc = ERANGE;
+			*do_cp = 0;
+			return (rc);
+		}
+
+		memset(&bind_array[next_index], 0, sizeof (HBA_BIND_ENTRY));
+		bind_array[next_index].did = pndl->nlp_DID;
+		memcpy(&bind_array[next_index].wwpn, &pndl->nlp_portname,
+		       sizeof (HBA_WWN));
+		memcpy(&bind_array[next_index].wwnn, &pndl->nlp_nodename,
+		       sizeof (HBA_WWN));
+		bind_array[next_index].flags |= HBA_BIND_UNMAPPED;
+		if (pndl->nlp_flag & NLP_TGT_NO_SCSIID)
+			bind_array[next_index].flags |= HBA_BIND_NOSCSIID;
+		if (pndl && pndl->nlp_Target) {
+		    if(pndl->nlp_Target->targetFlags & FC_NPR_ACTIVE)
+			bind_array[next_index].flags |= HBA_BIND_NODEVTMO;
+		    if(pndl->nlp_Target->rptLunState == REPORT_LUN_COMPLETE)
+			bind_array[next_index].flags |= HBA_BIND_RPTLUNST;
+		}
+		next_index++;
+	}
+
+	/* Iterate through the bind list */
+	list_for_each(pos, &phba->fc_nlpbind_list) {
+		pbdl = list_entry(pos, LPFC_BINDLIST_t, nlp_listp);
+	
+		if (next_index >= max_index) {
+			rc = ERANGE;
+			*do_cp = 0;
+			return (rc);
+		}
+		memset(&bind_array[next_index], 0, sizeof (HBA_BIND_ENTRY));
+		bind_array[next_index].scsi_id = pbdl->nlp_sid;
+
+		if (pbdl->nlp_bind_type & FCP_SEED_DID) {
+			bind_array[next_index].bind_type = BIND_DID;
+			bind_array[next_index].did = pbdl->nlp_DID;
+
+		}
+
+		if (pbdl->nlp_bind_type & FCP_SEED_WWPN) {
+			bind_array[next_index].bind_type = BIND_WWPN;
+			memcpy((uint8_t *) & bind_array[next_index].wwpn,
+			       &pbdl->nlp_portname, sizeof (HBA_WWN));
+		}
+
+		if (pbdl->nlp_bind_type & FCP_SEED_WWNN) {
+			bind_array[next_index].bind_type = BIND_WWNN;
+			memcpy((uint8_t *) & bind_array[next_index].wwnn,
+			       &pbdl->nlp_nodename, sizeof (HBA_WWN));
+		}
+		bind_array[next_index].flags |= HBA_BIND_BINDLIST;
+		
+		next_index++;
+	}
+	bind_list->NumberOfEntries = next_index;
+	return 0;
+}
+
+int
+lpfc_ioctl_get_vpd(lpfcHBA_t * phba,
+		   LPFCCMDINPUT_t * cip, void *dataout, int *do_cp)
+{
+	struct vpd *dp;
+	int rc = 0;
+
+	dp = (struct vpd *) dataout;
+
+	if (cip->lpfc_arg4 != VPD_VERSION1) {
+		rc = EINVAL;
+		*do_cp = 1;
+	}
+
+	dp->version = VPD_VERSION1;
+
+	memset(dp->ModelDescription, 0, 256);
+	memset(dp->Model, 0, 80);
+	memset(dp->ProgramType, 0, 256);
+	memset(dp->PortNum, 0, 20);
+
+	if (phba->vpd_flag & VPD_MASK) {
+		if (phba->vpd_flag & VPD_MODEL_DESC) {
+			memcpy(dp->ModelDescription, phba->ModelDesc, 256);
+		}
+		if (phba->vpd_flag & VPD_MODEL_NAME) {
+			memcpy(dp->Model, phba->ModelName, 80);
+		}
+		if (phba->vpd_flag & VPD_PROGRAM_TYPE) {
+			memcpy(dp->ProgramType, phba->ProgramType, 256);
+		}
+		if (phba->vpd_flag & VPD_PORT) {
+			memcpy(dp->PortNum, phba->Port, 20);
+		}
+	}
+
+	return rc;
+}
+
+int
+dfc_rsp_data_copy(lpfcHBA_t * phba,
+		  uint8_t * outdataptr, DMABUFEXT_t * mlist, uint32_t size)
+{
+	DMABUFEXT_t *mlast = 0;
+	int cnt, offset = 0;
+	unsigned long iflag;
+	struct list_head head, *curr, *next;
+
+	if (!mlist)
+		return(0);
+
+	list_add_tail(&head, &mlist->dma.list);
+
+	list_for_each_safe(curr, next, &head) {
+		mlast = list_entry(curr, DMABUFEXT_t , dma.list);
+		if (!size)
+			break;
+
+		/* We copy chucks of 4K */
+		if (size > 4096)
+			cnt = 4096;
+		else
+			cnt = size;
+
+		if (outdataptr) {
+			pci_dma_sync_single(phba->pcidev, mlast->dma.phys,
+						LPFC_BPL_SIZE, PCI_DMA_TODEVICE);
+			/* Copy data to user space */
+			LPFC_DRVR_UNLOCK(phba, iflag);
+			if (copy_to_user
+			    ((uint8_t *) (outdataptr + offset),
+			     (uint8_t *) mlast->dma.virt, (ulong) cnt)) {
+				LPFC_DRVR_LOCK(phba, iflag);
+				return (1);
+			}
+			LPFC_DRVR_LOCK(phba, iflag);
+		}
+		offset += cnt;
+		size -= cnt;
+	}
+	list_del(&head);
+	return (0);
+}
+
+DMABUFEXT_t *
+dfc_cmd_data_alloc(lpfcHBA_t * phba,
+		   char *indataptr, ULP_BDE64 * bpl, uint32_t size)
+{
+	DMABUFEXT_t *mlist = 0;
+	DMABUFEXT_t *dmp;
+	int cnt, offset = 0, i = 0;
+	unsigned long iflag;
+	struct pci_dev *pcidev;
+
+	pcidev = phba->pcidev;
+
+	while (size) {
+		/* We get chucks of 4K */
+		if (size > 4096)
+			cnt = 4096;
+		else
+			cnt = size;
+
+		/* allocate DMABUFEXT_t buffer header */
+		dmp = kmalloc(sizeof (DMABUFEXT_t), GFP_ATOMIC);
+		if ( dmp == 0 ) {
+			goto out;
+		}
+
+		INIT_LIST_HEAD(&dmp->dma.list);
+
+		/* Queue it to a linked list */
+		if (mlist)
+			list_add_tail(&dmp->dma.list, &mlist->dma.list);
+		else
+			mlist = dmp;
+
+		/* allocate buffer */
+		dmp->dma.virt = pci_alloc_consistent(pcidev, 
+						     cnt, 
+						     &(dmp->dma.phys));
+
+		if (dmp->dma.virt == 0) {
+			goto out;
+		}
+		dmp->size = cnt;
+
+		if (indataptr) {
+			/* Copy data from user space in */
+			LPFC_DRVR_UNLOCK(phba, iflag);
+			if (copy_from_user
+			    ((uint8_t *) dmp->dma.virt,
+			     (uint8_t *) (indataptr + offset), (ulong) cnt)) {
+				LPFC_DRVR_LOCK(phba, iflag);
+				goto out;
+			}
+			LPFC_DRVR_LOCK(phba, iflag);
+			bpl->tus.f.bdeFlags = 0;
+
+			pci_dma_sync_single(phba->pcidev, dmp->dma.phys, 
+						LPFC_BPL_SIZE, PCI_DMA_TODEVICE);
+		} else {
+			bpl->tus.f.bdeFlags = BUFF_USE_RCV;
+		}
+
+		/* build buffer ptr list for IOCB */
+		bpl->addrLow = le32_to_cpu( putPaddrLow(dmp->dma.phys) );
+		bpl->addrHigh = le32_to_cpu( putPaddrHigh(dmp->dma.phys) );
+		bpl->tus.f.bdeSize = (ushort) cnt;
+		bpl->tus.w = le32_to_cpu(bpl->tus.w);
+		bpl++;
+
+		i++;
+		offset += cnt;
+		size -= cnt;
+	}
+
+	mlist->flag = i;
+	return (mlist);
+      out:
+	dfc_cmd_data_free(phba, mlist);
+	return (0);
+}
+
+int
+dfc_cmd_data_free(lpfcHBA_t * phba, DMABUFEXT_t * mlist)
+{
+	DMABUFEXT_t *mlast;
+	struct pci_dev *pcidev;
+	struct list_head head, *curr, *next;
+
+	if (!mlist)
+		return(0);
+
+	pcidev = phba->pcidev;
+	list_add_tail(&head, &mlist->dma.list);
+
+	list_for_each_safe(curr, next, &head) {
+		mlast = list_entry(curr, DMABUFEXT_t , dma.list);
+		if (mlast->dma.virt) {
+
+			pci_free_consistent(pcidev, 
+					    mlast->size, 
+					    mlast->dma.virt, 
+					    mlast->dma.phys);
+
+		}
+		kfree(mlast);
+	}
+	return (0);
+}
diff -urNp linux-8155/drivers/addon/lpfc/lpfcdfc/lpfc_util_ioctl.h linux-8156/drivers/addon/lpfc/lpfcdfc/lpfc_util_ioctl.h
--- linux-8155/drivers/addon/lpfc/lpfcdfc/lpfc_util_ioctl.h
+++ linux-8156/drivers/addon/lpfc/lpfcdfc/lpfc_util_ioctl.h
@@ -0,0 +1,55 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2005 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfc_util_ioctl.h 328 2005-05-03 15:20:43Z sf_support $
+ */
+
+#ifndef  _H_LPFC_UTIL_IOCTL
+#define _H_LPFC_UTIL_IOCTL
+
+int lpfc_process_ioctl_util(lpfcHBA_t *phba, LPFCCMDINPUT_t *cip);
+int lpfc_ioctl_write_pci(lpfcHBA_t *, LPFCCMDINPUT_t *);
+int lpfc_ioctl_read_pci(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_write_mem(lpfcHBA_t *, LPFCCMDINPUT_t *);
+int lpfc_ioctl_read_mem(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_write_ctlreg(lpfcHBA_t *, LPFCCMDINPUT_t *);
+int lpfc_ioctl_read_ctlreg(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_setdiag(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_send_scsi_fcp(lpfcHBA_t *, LPFCCMDINPUT_t *);
+int lpfc_ioctl_send_mgmt_rsp(lpfcHBA_t *, LPFCCMDINPUT_t *);
+int lpfc_ioctl_send_mgmt_cmd(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_mbox(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_linkinfo(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_ioinfo(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_nodeinfo(lpfcHBA_t *, LPFCCMDINPUT_t *, void *, int);
+int lpfc_ioctl_getcfg(lpfcHBA_t *, LPFCCMDINPUT_t *, void *);
+int lpfc_ioctl_setcfg(lpfcHBA_t *, LPFCCMDINPUT_t *);
+int lpfc_ioctl_hba_get_event(lpfcHBA_t *, LPFCCMDINPUT_t *, void *, int);
+int lpfc_ioctl_hba_set_event(lpfcHBA_t *, LPFCCMDINPUT_t *);
+int lpfc_ioctl_add_bind(lpfcHBA_t *, LPFCCMDINPUT_t *);
+int lpfc_ioctl_del_bind(lpfcHBA_t *, LPFCCMDINPUT_t *);
+int lpfc_ioctl_list_bind(lpfcHBA_t *, LPFCCMDINPUT_t *, void *, int *);
+int lpfc_ioctl_get_vpd(lpfcHBA_t *, LPFCCMDINPUT_t *, void *, int *);
+int dfc_rsp_data_copy(lpfcHBA_t *, uint8_t *, DMABUFEXT_t *, uint32_t);
+DMABUFEXT_t *dfc_cmd_data_alloc(lpfcHBA_t *, char *, ULP_BDE64 *, uint32_t);
+int dfc_cmd_data_free(lpfcHBA_t *, DMABUFEXT_t *);
+
+#endif
diff -urNp linux-8155/drivers/addon/lpfc/lpfcdfc/lpfcdfc_version.h linux-8156/drivers/addon/lpfc/lpfcdfc/lpfcdfc_version.h
--- linux-8155/drivers/addon/lpfc/lpfcdfc/lpfcdfc_version.h
+++ linux-8156/drivers/addon/lpfc/lpfcdfc/lpfcdfc_version.h
@@ -0,0 +1,30 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Refer to the README file included with this package for         *
+ * driver version and adapter support.                             *
+ * Copyright (C) 2003-2006 Emulex.  All rights reserved.           *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of the GNU General Public License     *
+ * as published by the Free Software Foundation; either version 2  *
+ * of the License, or (at your option) any later version.          *
+ *                                                                 *
+ * This program is distributed in the hope that it will be useful, *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of  *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *
+ * GNU General Public License for more details, a copy of which    *
+ * can be found in the file COPYING included with this package.    *
+ *******************************************************************/
+
+/*
+ * $Id: lpfcdfc_version.h 486 2006-03-28 18:41:49Z sf_support $
+ */
+
+#define LPFCDFC_DRIVER_VERSION "1.2.3"
+
+#define LPFCDFC_DRIVER_NAME "lpfcdfc"
+
+#define LPFCDFC_MODULE_DESC "Emulex LightPulse FC SCSI IOCTL " LPFCDFC_DRIVER_VERSION
+#define LPFCDFC_COPYRIGHT "Copyright(c) 2003-2006 Emulex.  All rights reserved."
