diff -urNp linux-2/arch/i386/kernel/i387.c linux-3/arch/i386/kernel/i387.c
--- linux-2/arch/i386/kernel/i387.c	
+++ linux-3/arch/i386/kernel/i387.c	
@@ -373,14 +373,14 @@ static inline int restore_i387_fsave( st
 
 static inline int restore_i387_fxsave( struct _fpstate *buf )
 {
+	int err;
 	struct task_struct *tsk = current;
 	clear_fpu( tsk );
-	if ( __copy_from_user( &tsk->thread.i387.fxsave, &buf->_fxsr_env[0],
-			       sizeof(struct i387_fxsave_struct) ) )
-		return 1;
+	err = __copy_from_user( &tsk->thread.i387.fxsave, &buf->_fxsr_env[0],
+				sizeof(struct i387_fxsave_struct) );
 	/* mxcsr bit 6 and 31-16 must be zero for security reasons */
 	tsk->thread.i387.fxsave.mxcsr &= 0xffbf;
-	return convert_fxsr_from_user( &tsk->thread.i387.fxsave, buf );
+	return err ? 1 : convert_fxsr_from_user( &tsk->thread.i387.fxsave, buf );
 }
 
 int restore_i387( struct _fpstate *buf )
diff -urNp linux-2/drivers/ieee1394/amdtp.c linux-3/drivers/ieee1394/amdtp.c
--- linux-2/drivers/ieee1394/amdtp.c	
+++ linux-3/drivers/ieee1394/amdtp.c	
@@ -62,6 +62,12 @@
  * - Maybe make an ALSA interface, that is, create a file_ops
  *   implementation that recognizes ALSA ioctls and uses defaults for
  *   things that can't be controlled through ALSA (iso channel).
+ *
+ *   Changes:
+ *
+ * - Audit copy_from_user in amdtp_write.
+ *                           Daniele Bellucci <bellucda@tiscali.it>
+ *
  */
 
 #include <linux/module.h>
@@ -1112,7 +1118,8 @@ static ssize_t amdtp_write(struct file *
 
 	for (i = 0; i < count; i += length) {
 		p = buffer_put_bytes(s->input, count - i, &length);
-		copy_from_user(p, buffer + i, length);
+		if (copy_from_user(p, buffer + i, length))
+			return -EFAULT;
 		if (s->input->length < s->input->size)
 			continue;
 		
diff -urNp linux-2/drivers/net/3c59x.c linux-3/drivers/net/3c59x.c
--- linux-2/drivers/net/3c59x.c	
+++ linux-3/drivers/net/3c59x.c	
@@ -166,6 +166,11 @@
     - Rename wait_for_completion() to issue_and_wait() to avoid completion.h
       clash.
 
+    LK1.1.18ac 01Jul02 akpm
+     - Fix for undocumented transceiver power-up bit on some 3c566B's
+       (Donald Becker, Rahul Karnik)
+ 
+
     - See http://www.uow.edu.au/~andrewm/linux/#3c59x-2.3 for more details.
     - Also see Documentation/networking/vortex.txt
 */
@@ -181,8 +186,8 @@
 
 
 #define DRV_NAME	"3c59x"
-#define DRV_VERSION	"LK1.1.16"
-#define DRV_RELDATE	"19 July 2001"
+#define DRV_VERSION	"LK1.1.18-ac"
+#define DRV_RELDATE	"1 July 2002"
 
 
 
@@ -400,7 +405,7 @@ enum {	IS_VORTEX=1, IS_BOOMERANG=2, IS_C
 	EEPROM_8BIT=0x10,	/* AKPM: Uses 0x230 as the base bitmaps for EEPROM reads */
 	HAS_PWR_CTRL=0x20, HAS_MII=0x40, HAS_NWAY=0x80, HAS_CB_FNS=0x100,
 	INVERT_MII_PWR=0x200, INVERT_LED_PWR=0x400, MAX_COLLISION_RESET=0x800,
-	EEPROM_OFFSET=0x1000, HAS_HWCKSM=0x2000 };
+	EEPROM_OFFSET=0x1000, HAS_HWCKSM=0x2000, WNO_XCVR_PWR=0x4000 };
 
 enum vortex_chips {
 	CH_3C590 = 0,
@@ -424,6 +429,7 @@ enum vortex_chips {
 	CH_3C905B_2,
 	CH_3C905B_FX,
 	CH_3C905C,
+	CH_3C905C2,
 	CH_3C980,
 	CH_3C9805,
 
@@ -442,6 +448,8 @@ enum vortex_chips {
 	CH_3CCFEM656_1,
 	CH_3C450,
 	CH_3C920,
+	CH_3C982A,
+	CH_3C982B,
 };
 
 
@@ -495,10 +503,12 @@ static struct vortex_chip_info {
 	 PCI_USES_IO|PCI_USES_MASTER, IS_CYCLONE|HAS_HWCKSM, 128, },
 	{"3c905C Tornado",
 	 PCI_USES_IO|PCI_USES_MASTER, IS_TORNADO|HAS_NWAY|HAS_HWCKSM, 128, },
+	{"3c905C Tornado 2",
+	 PCI_USES_IO|PCI_USES_MASTER, IS_TORNADO|HAS_NWAY|HAS_HWCKSM, 128, },
 	{"3c980 Cyclone",
 	 PCI_USES_IO|PCI_USES_MASTER, IS_CYCLONE|HAS_HWCKSM, 128, },
-	{"3c982 Dual Port Server Cyclone",
-	 PCI_USES_IO|PCI_USES_MASTER, IS_CYCLONE|HAS_HWCKSM, 128, },
+	{"3c980C Python-T",
+	 PCI_USES_IO|PCI_USES_MASTER, IS_CYCLONE|HAS_NWAY|HAS_HWCKSM, 128, },
 
 	{"3cSOHO100-TX Hurricane",
 	 PCI_USES_IO|PCI_USES_MASTER, IS_CYCLONE|HAS_NWAY|HAS_HWCKSM, 128, },
@@ -509,7 +519,7 @@ static struct vortex_chip_info {
 									HAS_HWCKSM, 128, },
 	{"3c556B Laptop Hurricane",
 	 PCI_USES_IO|PCI_USES_MASTER, IS_TORNADO|HAS_NWAY|EEPROM_OFFSET|HAS_CB_FNS|INVERT_MII_PWR|
-									HAS_HWCKSM, 128, },
+	                                WNO_XCVR_PWR|HAS_HWCKSM, 128, },
 	{"3c575 [Megahertz] 10/100 LAN 	CardBus",
 	PCI_USES_IO|PCI_USES_MASTER, IS_BOOMERANG|HAS_MII|EEPROM_8BIT, 128, },
 
@@ -535,6 +545,11 @@ static struct vortex_chip_info {
 	 PCI_USES_IO|PCI_USES_MASTER, IS_TORNADO|HAS_NWAY|HAS_HWCKSM, 128, },
 	{"3c920 Tornado",
 	 PCI_USES_IO|PCI_USES_MASTER, IS_TORNADO|HAS_NWAY|HAS_HWCKSM, 128, },
+	{"3c982 Hydra Dual Port A",
+	 PCI_USES_IO|PCI_USES_MASTER, IS_TORNADO|HAS_HWCKSM|HAS_NWAY, 128, },
+	{"3c982 Hydra Dual Port B",
+	 PCI_USES_IO|PCI_USES_MASTER, IS_TORNADO|HAS_HWCKSM|HAS_NWAY, 128, },
+
 	{0,}, /* 0 terminated list. */
 };
 
@@ -561,6 +576,7 @@ static struct pci_device_id vortex_pci_t
 	{ 0x10B7, 0x9058, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C905B_2 },
 	{ 0x10B7, 0x905A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C905B_FX },
 	{ 0x10B7, 0x9200, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C905C },
+	{ 0x10B7, 0x9201, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C905C2 },
 	{ 0x10B7, 0x9800, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C980 },
 	{ 0x10B7, 0x9805, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C9805 },
 
@@ -579,6 +595,8 @@ static struct pci_device_id vortex_pci_t
 	{ 0x10B7, 0x6564, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3CCFEM656_1 },
 	{ 0x10B7, 0x4500, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C450 },
 	{ 0x10B7, 0x9201, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C920 },
+	{ 0x10B7, 0x1201, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C982A },
+	{ 0x10B7, 0x1202, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_3C982B },
 	{0,}						/* 0 terminated list. */
 };
 MODULE_DEVICE_TABLE(pci, vortex_pci_tbl);
@@ -1190,6 +1208,10 @@ static int __devinit vortex_probe1(struc
 		if (vp->drv_flags & INVERT_MII_PWR)
 			n |= 0x4000;
 		outw(n, ioaddr + Wn2_ResetOptions);
+		if (vp->drv_flags & WNO_XCVR_PWR) {
+			EL3WINDOW(0);
+			outw(0x0800, ioaddr);
+		}
 	}
 
 	/* Extract our information from the EEPROM data. */
diff -urNp linux-2/drivers/net/acenic.c linux-3/drivers/net/acenic.c
--- linux-2/drivers/net/acenic.c	
+++ linux-3/drivers/net/acenic.c	
@@ -1865,7 +1865,9 @@ static void ace_watchdog(struct net_devi
 	} else {
 		printk(KERN_DEBUG "%s: BUG... transmitter died. Kicking it.\n",
 		       dev->name);
+#if 0
 		netif_wake_queue(dev);
+#endif
 	}
 }
 
@@ -3017,9 +3019,6 @@ static int ace_ioctl(struct net_device *
 		return 0;
 
 	case ETHTOOL_SSET:
-		if(!capable(CAP_NET_ADMIN))
-			return -EPERM;
-
 		link = readl(&regs->GigLnkState);
 		if (link & LNK_1000MB)
 			speed = SPEED_1000;
diff -urNp linux-2/drivers/net/amd8111e.c linux-3/drivers/net/amd8111e.c
--- linux-2/drivers/net/amd8111e.c	
+++ linux-3/drivers/net/amd8111e.c	
@@ -1,6 +1,6 @@
 
 /* Advanced  Micro Devices Inc. AMD8111E Linux Network Driver 
- * Copyright (C) 2002 Advanced Micro Devices 
+ * Copyright (C) 2003 Advanced Micro Devices 
  *
  * 
  * Copyright 2001,2002 Jeff Garzik <jgarzik@mandrakesoft.com> [ 8139cp.c,tg3.c ]
@@ -41,6 +41,20 @@ Environment:
 	Kernel Mode
 
 Revision History:
+ 	3.0.0
+	   Initial Revision.
+	3.0.1
+	 1. Dynamic interrupt coalescing.
+	 2. Removed prev_stats.
+	 3. MII support.
+	 4. Dynamic IPG support
+	3.0.2  05/29/2003
+	 1. Bug fix: Fixed failure to send jumbo packets larger than 4k.
+	 2. Bug fix: Fixed VLAN support failure.
+	 3. Bug fix: Fixed receive interrupt coalescing bug.
+	 4. Dynamic IPG support is disabled by default.
+	3.0.3 06/05/2003
+	 1. Bug fix: Fixed failure to close the interface if SMP is enabled.
 
 */
 
@@ -77,13 +91,16 @@ Revision History:
 
 #include "amd8111e.h"
 #define MODULE_NAME	"amd8111e"
-#define MODULE_VERSION	"3.0.0"
+#define MODULE_VERSION	"3.0.3"
 MODULE_AUTHOR("Advanced Micro Devices, Inc.");
-MODULE_DESCRIPTION ("AMD8111 based 10/100 Ethernet Controller. Driver Version 3.0.0"); 
+MODULE_DESCRIPTION ("AMD8111 based 10/100 Ethernet Controller. Driver Version 3.0.3");
 MODULE_LICENSE("GPL");
-
 MODULE_PARM(speed_duplex, "1-" __MODULE_STRING (MAX_UNITS) "i");
 MODULE_PARM_DESC(speed_duplex, "Set device speed and duplex modes, 0: Auto Negotitate, 1: 10Mbps Half Duplex, 2: 10Mbps Full Duplex, 3: 100Mbps Half Duplex, 4: 100Mbps Full Duplex");
+MODULE_PARM(coalesce, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM_DESC(coalesce, "Enable or Disable interrupt coalescing, 1: Enable, 0: Disable");
+MODULE_PARM(dynamic_ipg, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM_DESC(dynamic_ipg, "Enable or Disable dynamic IPG, 1: Enable, 0: Disable");
 
 static struct pci_device_id amd8111e_pci_tbl[] __devinitdata = {
 		
@@ -92,6 +109,88 @@ static struct pci_device_id amd8111e_pci
 	{ 0, }
 
 };
+/* 
+This function will read the PHY registers.
+*/
+static int amd8111e_read_phy(struct amd8111e_priv* lp, int phy_id, int reg, u32* val)
+{
+	void * mmio = lp->mmio;
+	unsigned int reg_val;
+	unsigned int repeat= REPEAT_CNT;
+
+	reg_val = readl(mmio + PHY_ACCESS);
+	while (reg_val & PHY_CMD_ACTIVE)
+		reg_val = readl( mmio + PHY_ACCESS );
+
+	writel( PHY_RD_CMD | ((phy_id & 0x1f) << 21) |
+			   ((reg & 0x1f) << 16),  mmio +PHY_ACCESS);
+	do{
+		reg_val = readl(mmio + PHY_ACCESS);
+		udelay(30);  /* It takes 30 us to read/write data */
+	} while (--repeat && (reg_val & PHY_CMD_ACTIVE));
+	if(reg_val & PHY_RD_ERR)
+		goto err_phy_read;
+	
+	*val = reg_val & 0xffff;
+	return 0;
+err_phy_read:	
+	*val = 0;
+	return -EINVAL;
+	
+}
+
+/* 
+This function will write into PHY registers. 
+*/
+static int amd8111e_write_phy(struct amd8111e_priv* lp,int phy_id, int reg, u32 val)
+{
+	unsigned int repeat = REPEAT_CNT
+	void * mmio = lp->mmio;
+	unsigned int reg_val;
+
+	reg_val = readl(mmio + PHY_ACCESS);
+	while (reg_val & PHY_CMD_ACTIVE)
+		reg_val = readl( mmio + PHY_ACCESS );
+
+	writel( PHY_WR_CMD | ((phy_id & 0x1f) << 21) |
+			   ((reg & 0x1f) << 16)|val, mmio + PHY_ACCESS);
+
+	do{
+		reg_val = readl(mmio + PHY_ACCESS);
+		udelay(30);  /* It takes 30 us to read/write the data */
+	} while (--repeat && (reg_val & PHY_CMD_ACTIVE));
+	
+	if(reg_val & PHY_RD_ERR)
+		goto err_phy_write;
+	
+	return 0;
+
+err_phy_write:	
+	return -EINVAL;
+	
+}
+/* 
+This is the mii register read function provided to the mii interface.
+*/ 
+static int amd8111e_mdio_read(struct net_device * dev, int phy_id, int reg_num)
+{
+	struct amd8111e_priv* lp = dev->priv;
+	unsigned int reg_val;
+
+	amd8111e_read_phy(lp,phy_id,reg_num,&reg_val);
+	return reg_val;
+	
+}
+
+/* 
+This is the mii register write function provided to the mii interface.
+*/ 
+static void amd8111e_mdio_write(struct net_device * dev, int phy_id, int reg_num, int val)
+{
+	struct amd8111e_priv* lp = dev->priv;
+
+	amd8111e_write_phy(lp, phy_id, reg_num, val);
+}
 
 /*
 This function will set PHY speed. During initialization sets the original speed to 100 full.
@@ -99,26 +198,39 @@ This function will set PHY speed. During
 static void amd8111e_set_ext_phy(struct net_device *dev)
 {
 	struct amd8111e_priv *lp = (struct amd8111e_priv *)dev->priv;
-	unsigned long  reg_val = 0;
-	void * mmio = lp->mmio;
-	struct amd8111e_link_config *link_config = &lp->link_config;
+	u32 bmcr,advert,tmp;
 	
-	if(!lp->opened){
-		/* Initializing SPEED_100 and DUPLEX_FULL as original values */
-		link_config->orig_speed = SPEED_100;
-		link_config->orig_duplex = DUPLEX_FULL;
-		link_config->orig_phy_option = XPHYSP |XPHYFD;
-	}
-	reg_val = lp->ext_phy_option;
-
-	/* Disable port manager */
-	writel((u32) EN_PMGR, mmio + CMD3 );
+	/* Determine mii register values to set the speed */
+	advert = amd8111e_mdio_read(dev, PHY_ID, MII_ADVERTISE);
+	tmp = advert & ~(ADVERTISE_ALL | ADVERTISE_100BASE4);
+	switch (lp->ext_phy_option){
+
+		default:
+		case SPEED_AUTONEG: /* advertise all values */
+			tmp |= ( ADVERTISE_10HALF|ADVERTISE_10FULL|
+				ADVERTISE_100HALF|ADVERTISE_100FULL) ;
+			break;
+		case SPEED10_HALF:
+			tmp |= ADVERTISE_10HALF;
+			break;
+		case SPEED10_FULL:
+			tmp |= ADVERTISE_10FULL;
+			break;
+		case SPEED100_HALF: 
+			tmp |= ADVERTISE_100HALF;
+			break;
+		case SPEED100_FULL:
+			tmp |= ADVERTISE_100FULL;
+			break;
+	}
+
+	if(advert != tmp)
+		amd8111e_mdio_write(dev, PHY_ID, MII_ADVERTISE, tmp);
+	/* Restart auto negotiation */
+	bmcr = amd8111e_mdio_read(dev, PHY_ID, MII_BMCR);
+	bmcr |= (BMCR_ANENABLE | BMCR_ANRESTART);
+	amd8111e_mdio_write(dev, PHY_ID, MII_BMCR, bmcr);
 
-	/* Reset PHY */
-	writel((u32)XPHYRST | lp->ext_phy_option, mmio + CTRL2);
-
-	/* Enable port manager */
-	writel((u32)VAL1 | EN_PMGR, mmio + CMD3 );
 }
 
 /* 
@@ -156,7 +268,7 @@ static int amd8111e_free_skbs(struct net
 }
 
 /*
- This will set the receive buffer length corresponding to the mtu size of network interface.
+This will set the receive buffer length corresponding to the mtu size of networkinterface.
 */
 static inline void amd8111e_set_rx_buff_len(struct net_device* dev)
 {
@@ -226,13 +338,13 @@ static int amd8111e_init_ring(struct net
 
 		lp->rx_ring[i].buff_phy_addr = cpu_to_le32(lp->rx_dma_addr[i]);
 		lp->rx_ring[i].buff_count = cpu_to_le16(lp->rx_buff_len);
-		lp->rx_ring[i].rx_dr_offset10 = cpu_to_le16(OWN_BIT);
+		lp->rx_ring[i].rx_flags = cpu_to_le16(OWN_BIT);
 	}
 
 	/* Initializing transmit descriptors */
 	for (i = 0; i < NUM_TX_RING_DR; i++) {
 		lp->tx_ring[i].buff_phy_addr = 0;
-		lp->tx_ring[i].tx_dr_offset2 = 0;
+		lp->tx_ring[i].tx_flags = 0;
 		lp->tx_ring[i].buff_count = 0;
 	}
 
@@ -253,6 +365,65 @@ err_free_tx_ring:
 err_no_mem:
 	return -ENOMEM;
 }
+/* This function will set the interrupt coalescing according to the input arguments */
+static int amd8111e_set_coalesce(struct net_device * dev, enum coal_mode cmod)
+{
+	unsigned int timeout;
+	unsigned int event_count;
+
+	struct amd8111e_priv *lp = dev->priv;
+	void* mmio = lp->mmio;
+	struct amd8111e_coalesce_conf * coal_conf = &lp->coal_conf;
+
+
+	switch(cmod)
+	{
+		case RX_INTR_COAL :
+			timeout = coal_conf->rx_timeout;
+			event_count = coal_conf->rx_event_count;
+			if( timeout > MAX_TIMEOUT || 
+					event_count > MAX_EVENT_COUNT ) 
+			return -EINVAL;
+
+			timeout = timeout * DELAY_TIMER_CONV; 
+			writel(VAL0|STINTEN, mmio+INTEN0);
+			writel((u32)DLY_INT_A_R0|( event_count<< 16 )|timeout,
+							mmio+DLY_INT_A);
+			break;
+
+		case TX_INTR_COAL :
+			timeout = coal_conf->tx_timeout;
+			event_count = coal_conf->tx_event_count;
+			if( timeout > MAX_TIMEOUT || 
+					event_count > MAX_EVENT_COUNT ) 
+			return -EINVAL;
+
+		   
+			timeout = timeout * DELAY_TIMER_CONV; 
+			writel(VAL0|STINTEN,mmio+INTEN0);
+			writel((u32)DLY_INT_B_T0|( event_count<< 16 )|timeout,
+							 mmio+DLY_INT_B);
+			break;
+
+		case DISABLE_COAL:
+			writel(0,mmio+STVAL);
+			writel(STINTEN, mmio+INTEN0);
+			writel(0, mmio +DLY_INT_B);
+			writel(0, mmio+DLY_INT_A);
+			break;
+		 case ENABLE_COAL: 
+		       /* Start the timer */
+			writel((u32)SOFT_TIMER_FREQ, mmio+STVAL); /*  0.5 sec */
+			writel(VAL0|STINTEN, mmio+INTEN0);
+			break;
+		default:
+			break;
+
+   }
+	return 0;
+
+}
+
 /* 
 This function initializes the device registers  and starts the device.  
 */
@@ -267,13 +438,17 @@ static int amd8111e_restart(struct net_d
 
 	if(amd8111e_init_ring(dev))
 		return -ENOMEM;
+
+	/* enable the port manager and set auto negotiation always */
+	writel((u32) VAL1|EN_PMGR, mmio + CMD3 );
+	writel((u32)XPHYANE|XPHYRST , mmio + CTRL2); 
 	
 	amd8111e_set_ext_phy(dev);
 
 	/* set control registers */
 	reg_val = readl(mmio + CTRL1);
-	
-	writel( reg_val| XMTSP_128 | CACHE_ALIGN | B1_MASK, mmio + CTRL1 );
+	reg_val &= ~XMTSP_MASK;
+	writel( reg_val| XMTSP_128 | CACHE_ALIGN, mmio + CTRL1 );
 
 	/* enable interrupt */
 	writel( APINT5EN | APINT4EN | APINT3EN | APINT2EN | APINT1EN | 
@@ -288,15 +463,21 @@ static int amd8111e_restart(struct net_d
 
 	writew((u32)NUM_TX_RING_DR, mmio + XMT_RING_LEN0);
 	writew((u16)NUM_RX_RING_DR, mmio + RCV_RING_LEN0);
+	
+	/* set default IPG to 96 */
+	writew((u32)DEFAULT_IPG,mmio+IPG);
+	writew((u32)(DEFAULT_IPG-IFS1_DELTA), mmio + IFS1); 
 
 	if(lp->options & OPTION_JUMBO_ENABLE){
 		writel((u32)VAL2|JUMBO, mmio + CMD3);
 		/* Reset REX_UFLO */
 		writel( REX_UFLO, mmio + CMD2);
 		/* Should not set REX_UFLO for jumbo frames */
-		writel( VAL0 | APAD_XMT | REX_RTRY, mmio + CMD2);
-	}else
+		writel( VAL0 | APAD_XMT|REX_RTRY , mmio + CMD2);
+	}else{
 		writel( VAL0 | APAD_XMT | REX_RTRY|REX_UFLO, mmio + CMD2);
+		writel((u32)JUMBO, mmio + CMD3);
+	}
 
 #if AMD8111E_VLAN_TAG_USED
 	writel((u32) VAL2|VSIZE|VL_TAG_DEL, mmio + CMD3);
@@ -306,11 +487,20 @@ static int amd8111e_restart(struct net_d
 	/* Setting the MAC address to the device */
 	for(i = 0; i < ETH_ADDR_LEN; i++)
 		writeb( dev->dev_addr[i], mmio + PADR + i ); 
+
+	/* Enable interrupt coalesce */
+	if(lp->options & OPTION_INTR_COAL_ENABLE){
+		printk(KERN_INFO "%s: Interrupt Coalescing Enabled.\n",
+								dev->name);
+		amd8111e_set_coalesce(dev,ENABLE_COAL);
+	}
 	
 	/* set RUN bit to start the chip */
 	writel(VAL2 | RDMD0, mmio + CMD0);
 	writel(VAL0 | INTREN | RUN, mmio + CMD0);
 	
+	/* To avoid PCI posting bug */
+	readl(mmio+CMD0);
 	return 0;
 }
 /* 
@@ -383,7 +573,7 @@ static void amd8111e_init_hw_default( st
 	writew(MIB_CLEAR, mmio + MIB_ADDR);
 
 	/* Clear LARF */
-	AMD8111E_WRITE_REG64(mmio, LADRF,logic_filter);
+	amd8111e_writeq(*(u64*)logic_filter,mmio+LADRF);
 
 	/* SRAM_SIZE register */
 	reg_val = readl(mmio + SRAM_SIZE);
@@ -393,8 +583,11 @@ static void amd8111e_init_hw_default( st
 #if AMD8111E_VLAN_TAG_USED
 	writel(VAL2|VSIZE|VL_TAG_DEL, mmio + CMD3 );
 #endif
-	/* CMD2 register */
-	reg_val = readl(mmio + CMD2);
+	/* Set default value to CTRL1 Register */
+	writel(CTRL1_DEFAULT, mmio + CTRL1);
+
+	/* To avoid PCI posting bug */
+	readl(mmio + CMD2);
 
 }
 
@@ -412,6 +605,9 @@ static void amd8111e_disable_interrupt(s
 	/* Clear INT0 */
 	intr0 = readl(lp->mmio + INT0);
 	writel(intr0, lp->mmio + INT0);
+	
+	/* To avoid PCI posting bug */
+	readl(lp->mmio + INT0);
 
 }
 
@@ -421,6 +617,9 @@ This function stops the chip. 
 static void amd8111e_stop_chip(struct amd8111e_priv* lp)
 {
 	writel(RUN, lp->mmio + CMD0);
+	
+	/* To avoid PCI posting bug */
+	readl(lp->mmio + CMD0);
 }
 
 /* 
@@ -467,11 +666,10 @@ static int amd8111e_tx(struct net_device
 	struct amd8111e_priv* lp = dev->priv;
 	int tx_index = lp->tx_complete_idx & TX_RING_DR_MOD_MASK;
 	int status;
-	
 	/* Complete all the transmit packet */
 	while (lp->tx_complete_idx != lp->tx_idx){
 		tx_index =  lp->tx_complete_idx & TX_RING_DR_MOD_MASK;
-		status = le16_to_cpu(lp->tx_ring[tx_index].tx_dr_offset2);
+		status = le16_to_cpu(lp->tx_ring[tx_index].tx_flags);
 
 		if(status & OWN_BIT)
 			break;	/* It still hasn't been Txed */
@@ -487,11 +685,15 @@ static int amd8111e_tx(struct net_device
 			lp->tx_skbuff[tx_index] = 0;
 			lp->tx_dma_addr[tx_index] = 0;
 		}
-		lp->tx_complete_idx++;	
+		lp->tx_complete_idx++;
+		/*COAL update tx coalescing parameters */
+		lp->coal_conf.tx_packets++;
+		lp->coal_conf.tx_bytes += lp->tx_ring[tx_index].buff_count;	
 
 		if (netif_queue_stopped(dev) &&
 			lp->tx_complete_idx > lp->tx_idx - NUM_TX_BUFFERS +2){
 			/* The ring is no longer full, clear tbusy. */
+			/* lp->tx_full = 0; */
 			netif_wake_queue (dev);
 		}
 	}
@@ -516,33 +718,31 @@ static int amd8111e_rx(struct net_device
 	
 	/* If we own the next entry, it's a new packet. Send it up. */
 	while(++num_rx_pkt <= max_rx_pkt){
-		if(lp->rx_ring[rx_index].rx_dr_offset10 & OWN_BIT)
+		if(lp->rx_ring[rx_index].rx_flags & OWN_BIT)
 			return 0;
 	       
 		/* check if err summary bit is set */ 
-		if(le16_to_cpu(lp->rx_ring[rx_index].rx_dr_offset10) & ERR_BIT){
+		if(le16_to_cpu(lp->rx_ring[rx_index].rx_flags) & ERR_BIT){
 			/* 
 			 * There is a tricky error noted by John Murphy,
 			 * <murf@perftech.com> to Russ Nelson: Even with full-sized
 			 * buffers it's possible for a jabber packet to use two
 			 * buffers, with only the last correctly noting the error.			 */
 			/* reseting flags */
-			lp->rx_ring[rx_index].rx_dr_offset10 &= 
-						cpu_to_le16(RESET_RX_FLAGS);
+			lp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;
 			goto err_next_pkt;
 		}
 		/* check for STP and ENP */
-		status = le16_to_cpu(lp->rx_ring[rx_index].rx_dr_offset10);
+		status = le16_to_cpu(lp->rx_ring[rx_index].rx_flags);
 		if(!((status & STP_BIT) && (status & ENP_BIT))){
 			/* reseting flags */
-			lp->rx_ring[rx_index].rx_dr_offset10 &= 
-						cpu_to_le16(RESET_RX_FLAGS);
+			lp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;
 			goto err_next_pkt;
 		}
 		pkt_len = le16_to_cpu(lp->rx_ring[rx_index].msg_count) - 4;
 
 #if AMD8111E_VLAN_TAG_USED		
-		vtag = le16_to_cpu(lp->rx_ring[rx_index].rx_dr_offset10) & TT_MASK;
+		vtag = le16_to_cpu(lp->rx_ring[rx_index].rx_flags) & TT_MASK;
 		/*MAC will strip vlan tag*/ 
 		if(lp->vlgrp != NULL && vtag !=0)
 			min_pkt_len =MIN_PKT_LEN - 4;
@@ -551,16 +751,14 @@ static int amd8111e_rx(struct net_device
 			min_pkt_len =MIN_PKT_LEN;
 
 		if (pkt_len < min_pkt_len) {
-			lp->rx_ring[rx_index].rx_dr_offset10 &= 
-				cpu_to_le16(RESET_RX_FLAGS);
+			lp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;
 			lp->stats.rx_errors++;
 			goto err_next_pkt;
 		}
 		if(!(new_skb = dev_alloc_skb(lp->rx_buff_len))){
 			/* if allocation fail, 
 				ignore that pkt and go to next one */
-			lp->rx_ring[rx_index].rx_dr_offset10 &= 
-				cpu_to_le16(RESET_RX_FLAGS);
+			lp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;
 			lp->stats.rx_errors++;
 			goto err_next_pkt;
 		}
@@ -580,22 +778,26 @@ static int amd8111e_rx(struct net_device
 
 #if AMD8111E_VLAN_TAG_USED		
 		
-		vtag = lp->rx_ring[rx_index].rx_dr_offset10 & TT_MASK;
+		vtag = lp->rx_ring[rx_index].rx_flags & TT_MASK;
 		if(lp->vlgrp != NULL && (vtag == TT_VLAN_TAGGED)){
 			amd8111e_vlan_rx(lp, skb,
 				    lp->rx_ring[rx_index].tag_ctrl_info);
 		} else
 #endif
 			
-			dev->last_rx = jiffies;
 			netif_rx (skb);
+			/*COAL update rx coalescing parameters*/
+			lp->coal_conf.rx_packets++;
+			lp->coal_conf.rx_bytes += pkt_len;	
+
+			dev->last_rx = jiffies;
 	
 err_next_pkt:
 		lp->rx_ring[rx_index].buff_phy_addr
 			 = cpu_to_le32(lp->rx_dma_addr[rx_index]);
 		lp->rx_ring[rx_index].buff_count = 
 				cpu_to_le16(lp->rx_buff_len-2);
-		lp->rx_ring[rx_index].rx_dr_offset10 |= cpu_to_le16(OWN_BIT);
+		lp->rx_ring[rx_index].rx_flags |= cpu_to_le16(OWN_BIT);
 		rx_index = (++lp->rx_idx) & RX_RING_DR_MOD_MASK;
 	}
 
@@ -603,8 +805,8 @@ err_next_pkt:
 }
 
 /* 
-This function will store the original speed to restore later, if autoneg is turned on. This speed will be set later when the autoneg is turned off. If the link status indicates that link is down, that will be indicated to the kernel */
-
+This function will indicate the link status to the kernel.
+*/
 static int amd8111e_link_change(struct net_device* dev)
 {	
 	struct amd8111e_priv *lp = dev->priv;
@@ -614,21 +816,11 @@ static int amd8111e_link_change(struct n
      	status0 = readl(lp->mmio + STAT0);
 	
 	if(status0 & LINK_STATS){
-		if(status0 & AUTONEG_COMPLETE){
-			/* keeping the original speeds */
-			if((lp->link_config.speed != SPEED_INVALID)&&
-				(lp->link_config.duplex != DUPLEX_INVALID)){
-			lp->link_config.orig_speed = lp->link_config.speed;
-			lp->link_config.orig_duplex = lp->link_config.duplex;
-			lp->link_config.orig_phy_option = lp->ext_phy_option;
-			}
-	
-			lp->link_config.speed = SPEED_INVALID;
-			lp->link_config.duplex = DUPLEX_INVALID;
+		if(status0 & AUTONEG_COMPLETE)
 			lp->link_config.autoneg = AUTONEG_ENABLE;
-			netif_carrier_on(dev);
-			return 0;
-		}
+		else 
+			lp->link_config.autoneg = AUTONEG_DISABLE;
+
 		if(status0 & FULL_DPLX)
 			lp->link_config.duplex = DUPLEX_FULL;
 		else 
@@ -638,13 +830,17 @@ static int amd8111e_link_change(struct n
 			lp->link_config.speed = SPEED_10;
 		else if(speed == PHY_SPEED_100)
 			lp->link_config.speed = SPEED_100;
-		lp->link_config.autoneg = AUTONEG_DISABLE;
+
+		printk(KERN_INFO "%s: Link is Up. Speed is %s Mbps %s Duplex\n",			dev->name,
+		       (lp->link_config.speed == SPEED_100) ? "100": "10", 
+		       (lp->link_config.duplex == DUPLEX_FULL)? "Full": "Half"); 
 		netif_carrier_on(dev);
 	}
 	else{	
 		lp->link_config.speed = SPEED_INVALID;
 		lp->link_config.duplex = DUPLEX_INVALID;
 		lp->link_config.autoneg = AUTONEG_INVALID;
+		printk(KERN_INFO "%s: Link is Down.\n",dev->name);
 		netif_carrier_off(dev);
 	}
 		
@@ -671,114 +867,236 @@ static int amd8111e_read_mib(void* mmio,
 }
 
 /*
-This function retuurns the reads the mib registers and returns the hardware statistics. It adds the previous statistics with new values.*/ 
+This function reads the mib registers and returns the hardware statistics. It  updates previous internal driver statistics with new values.
+*/ 
 static struct net_device_stats *amd8111e_get_stats(struct net_device * dev)
 {
 	struct amd8111e_priv *lp = dev->priv;
 	void * mmio = lp->mmio;
 	unsigned long flags;
-	struct net_device_stats *prev_stats = &lp->prev_stats;
+	/* struct net_device_stats *prev_stats = &lp->prev_stats; */
 	struct net_device_stats* new_stats = &lp->stats;
 	
 	if(!lp->opened)
-		return prev_stats;	
+		return &lp->stats;	
 	spin_lock_irqsave (&lp->lock, flags);
 
 	/* stats.rx_packets */
-	new_stats->rx_packets = prev_stats->rx_packets+
-		amd8111e_read_mib(mmio, rcv_broadcast_pkts)+
-		amd8111e_read_mib(mmio, rcv_multicast_pkts)+
-		amd8111e_read_mib(mmio, rcv_unicast_pkts);
+	new_stats->rx_packets = amd8111e_read_mib(mmio, rcv_broadcast_pkts)+
+				amd8111e_read_mib(mmio, rcv_multicast_pkts)+
+				amd8111e_read_mib(mmio, rcv_unicast_pkts);
 
 	/* stats.tx_packets */
-	new_stats->tx_packets = prev_stats->tx_packets+
-		amd8111e_read_mib(mmio, xmt_packets);
+	new_stats->tx_packets = amd8111e_read_mib(mmio, xmt_packets);
 
 	/*stats.rx_bytes */
-	new_stats->rx_bytes = prev_stats->rx_bytes+
-		amd8111e_read_mib(mmio, rcv_octets);
+	new_stats->rx_bytes = amd8111e_read_mib(mmio, rcv_octets);
 
 	/* stats.tx_bytes */
-	new_stats->tx_bytes = prev_stats->tx_bytes+
-		amd8111e_read_mib(mmio, xmt_octets);
+	new_stats->tx_bytes = amd8111e_read_mib(mmio, xmt_octets);
 
 	/* stats.rx_errors */
-	new_stats->rx_errors = prev_stats->rx_errors+
-		amd8111e_read_mib(mmio, rcv_undersize_pkts)+
-		amd8111e_read_mib(mmio, rcv_fragments)+
-		amd8111e_read_mib(mmio, rcv_jabbers)+
-		amd8111e_read_mib(mmio, rcv_alignment_errors)+
-		amd8111e_read_mib(mmio, rcv_fcs_errors)+
-		amd8111e_read_mib(mmio, rcv_miss_pkts);
+	new_stats->rx_errors = amd8111e_read_mib(mmio, rcv_undersize_pkts)+
+				amd8111e_read_mib(mmio, rcv_fragments)+
+				amd8111e_read_mib(mmio, rcv_jabbers)+
+				amd8111e_read_mib(mmio, rcv_alignment_errors)+
+				amd8111e_read_mib(mmio, rcv_fcs_errors)+
+				amd8111e_read_mib(mmio, rcv_miss_pkts);
 
 	/* stats.tx_errors */
-	new_stats->tx_errors = prev_stats->tx_errors+
-		amd8111e_read_mib(mmio, xmt_underrun_pkts);
+	new_stats->tx_errors = amd8111e_read_mib(mmio, xmt_underrun_pkts);
 
 	/* stats.rx_dropped*/
-	new_stats->rx_dropped = prev_stats->rx_dropped+
-		amd8111e_read_mib(mmio, rcv_miss_pkts);
+	new_stats->rx_dropped = amd8111e_read_mib(mmio, rcv_miss_pkts);
 
 	/* stats.tx_dropped*/
-	new_stats->tx_dropped = prev_stats->tx_dropped+
-		amd8111e_read_mib(mmio,  xmt_underrun_pkts);
+	new_stats->tx_dropped = amd8111e_read_mib(mmio,  xmt_underrun_pkts);
 
 	/* stats.multicast*/
-	new_stats->multicast = prev_stats->multicast+
-		amd8111e_read_mib(mmio, rcv_multicast_pkts);
+	new_stats->multicast = amd8111e_read_mib(mmio, rcv_multicast_pkts);
 
 	/* stats.collisions*/
-	new_stats->collisions = prev_stats->collisions+
-		amd8111e_read_mib(mmio, xmt_collisions);
+	new_stats->collisions = amd8111e_read_mib(mmio, xmt_collisions);
 
 	/* stats.rx_length_errors*/
-	new_stats->rx_length_errors = prev_stats->rx_length_errors+
+	new_stats->rx_length_errors = 
 		amd8111e_read_mib(mmio, rcv_undersize_pkts)+
 		amd8111e_read_mib(mmio, rcv_oversize_pkts);
 
 	/* stats.rx_over_errors*/
-	new_stats->rx_over_errors = prev_stats->rx_over_errors+
-		amd8111e_read_mib(mmio, rcv_miss_pkts);
+	new_stats->rx_over_errors = amd8111e_read_mib(mmio, rcv_miss_pkts);
 
 	/* stats.rx_crc_errors*/
-	new_stats->rx_crc_errors = prev_stats->rx_crc_errors+
-		amd8111e_read_mib(mmio, rcv_fcs_errors);
+	new_stats->rx_crc_errors = amd8111e_read_mib(mmio, rcv_fcs_errors);
 
 	/* stats.rx_frame_errors*/
-	new_stats->rx_frame_errors = prev_stats->rx_frame_errors+
+	new_stats->rx_frame_errors =
 		amd8111e_read_mib(mmio, rcv_alignment_errors);
 
 	/* stats.rx_fifo_errors */
-	new_stats->rx_fifo_errors = prev_stats->rx_fifo_errors+
-		amd8111e_read_mib(mmio, rcv_miss_pkts);
+	new_stats->rx_fifo_errors = amd8111e_read_mib(mmio, rcv_miss_pkts);
 
 	/* stats.rx_missed_errors */
-	new_stats->rx_missed_errors = prev_stats->rx_missed_errors+
-		amd8111e_read_mib(mmio, rcv_miss_pkts);
+	new_stats->rx_missed_errors = amd8111e_read_mib(mmio, rcv_miss_pkts);
 
 	/* stats.tx_aborted_errors*/
-	new_stats->tx_aborted_errors = prev_stats->tx_aborted_errors+
+	new_stats->tx_aborted_errors = 
 		amd8111e_read_mib(mmio, xmt_excessive_collision);
 
 	/* stats.tx_carrier_errors*/
-	new_stats->tx_carrier_errors = prev_stats->tx_carrier_errors+
+	new_stats->tx_carrier_errors = 
 		amd8111e_read_mib(mmio, xmt_loss_carrier);
 
 	/* stats.tx_fifo_errors*/
-	new_stats->tx_fifo_errors = prev_stats->tx_fifo_errors+
-		amd8111e_read_mib(mmio, xmt_underrun_pkts);
+	new_stats->tx_fifo_errors = amd8111e_read_mib(mmio, xmt_underrun_pkts);
 
 	/* stats.tx_window_errors*/
-	new_stats->tx_window_errors = prev_stats->tx_window_errors+
+	new_stats->tx_window_errors =
 		amd8111e_read_mib(mmio, xmt_late_collision);
 
+	/* Reset the mibs for collecting new statistics */
+	/* writew(MIB_CLEAR, mmio + MIB_ADDR);*/
+		
 	spin_unlock_irqrestore (&lp->lock, flags);
 
 	return new_stats;
 }
+/* This function recalculate the interupt coalescing  mode on every interrupt 
+according to the datarate and the packet rate.
+*/
+static int amd8111e_calc_coalesce(struct net_device *dev)
+{
+	struct amd8111e_priv *lp = dev->priv;
+	struct amd8111e_coalesce_conf * coal_conf = &lp->coal_conf;
+	int tx_pkt_rate;
+	int rx_pkt_rate;
+	int tx_data_rate;
+	int rx_data_rate;
+	int rx_pkt_size;
+	int tx_pkt_size;
+
+	tx_pkt_rate = coal_conf->tx_packets - coal_conf->tx_prev_packets;
+	coal_conf->tx_prev_packets =  coal_conf->tx_packets;
+	
+	tx_data_rate = coal_conf->tx_bytes - coal_conf->tx_prev_bytes;
+	coal_conf->tx_prev_bytes =  coal_conf->tx_bytes;
+	
+	rx_pkt_rate = coal_conf->rx_packets - coal_conf->rx_prev_packets;
+	coal_conf->rx_prev_packets =  coal_conf->rx_packets;
+	
+	rx_data_rate = coal_conf->rx_bytes - coal_conf->rx_prev_bytes;
+	coal_conf->rx_prev_bytes =  coal_conf->rx_bytes;
+	
+	if(rx_pkt_rate < 800){
+		if(coal_conf->rx_coal_type != NO_COALESCE){
+			
+			coal_conf->rx_timeout = 0x0;
+			coal_conf->rx_event_count = 0;
+			amd8111e_set_coalesce(dev,RX_INTR_COAL);
+			coal_conf->rx_coal_type = NO_COALESCE;
+		}
+	}
+	else{
+	
+		rx_pkt_size = rx_data_rate/rx_pkt_rate;
+		if (rx_pkt_size < 128){
+			if(coal_conf->rx_coal_type != NO_COALESCE){
+			
+				coal_conf->rx_timeout = 0;
+				coal_conf->rx_event_count = 0;
+				amd8111e_set_coalesce(dev,RX_INTR_COAL);
+				coal_conf->rx_coal_type = NO_COALESCE;
+			}
 
+		}
+		else if ( (rx_pkt_size >= 128) && (rx_pkt_size < 512) ){
+	
+			if(coal_conf->rx_coal_type !=  LOW_COALESCE){
+				coal_conf->rx_timeout = 1;
+				coal_conf->rx_event_count = 4;
+				amd8111e_set_coalesce(dev,RX_INTR_COAL);
+				coal_conf->rx_coal_type = LOW_COALESCE;
+			}
+		}
+		else if ((rx_pkt_size >= 512) && (rx_pkt_size < 1024)){
+			
+			if(coal_conf->rx_coal_type !=  MEDIUM_COALESCE){
+				coal_conf->rx_timeout = 1;
+				coal_conf->rx_event_count = 4;
+				amd8111e_set_coalesce(dev,RX_INTR_COAL);
+				coal_conf->rx_coal_type = MEDIUM_COALESCE;
+			}		
+				
+		}
+		else if(rx_pkt_size >= 1024){
+			if(coal_conf->rx_coal_type !=  HIGH_COALESCE){
+				coal_conf->rx_timeout = 2;
+				coal_conf->rx_event_count = 3;
+				amd8111e_set_coalesce(dev,RX_INTR_COAL);
+				coal_conf->rx_coal_type = HIGH_COALESCE;
+			}		
+		}
+	}
+    	/* NOW FOR TX INTR COALESC */
+	if(tx_pkt_rate < 800){
+		if(coal_conf->tx_coal_type != NO_COALESCE){
+			
+			coal_conf->tx_timeout = 0x0;
+			coal_conf->tx_event_count = 0;
+			amd8111e_set_coalesce(dev,TX_INTR_COAL);
+			coal_conf->tx_coal_type = NO_COALESCE;
+		}
+	}
+	else{
+	
+		tx_pkt_size = tx_data_rate/tx_pkt_rate;
+		if (tx_pkt_size < 128){
+		
+			if(coal_conf->tx_coal_type != NO_COALESCE){
+			
+				coal_conf->tx_timeout = 0;
+				coal_conf->tx_event_count = 0;
+				amd8111e_set_coalesce(dev,TX_INTR_COAL);
+				coal_conf->tx_coal_type = NO_COALESCE;
+			}
+
+		}
+		else if ( (tx_pkt_size >= 128) && (tx_pkt_size < 512) ){
+	
+			if(coal_conf->tx_coal_type !=  LOW_COALESCE){
+				coal_conf->tx_timeout = 1;
+				coal_conf->tx_event_count = 2;
+				amd8111e_set_coalesce(dev,TX_INTR_COAL);
+				coal_conf->tx_coal_type = LOW_COALESCE;
+
+			}
+		}
+		else if ((tx_pkt_size >= 512) && (tx_pkt_size < 1024)){
+			
+			if(coal_conf->tx_coal_type !=  MEDIUM_COALESCE){
+				coal_conf->tx_timeout = 2;
+				coal_conf->tx_event_count = 5;
+				amd8111e_set_coalesce(dev,TX_INTR_COAL);
+				coal_conf->tx_coal_type = MEDIUM_COALESCE;
+			}		
+				
+		}
+		else if(tx_pkt_size >= 1024){
+			if (tx_pkt_size >= 1024){
+				if(coal_conf->tx_coal_type !=  HIGH_COALESCE){
+					coal_conf->tx_timeout = 4;
+					coal_conf->tx_event_count = 8;
+					amd8111e_set_coalesce(dev,TX_INTR_COAL);
+					coal_conf->tx_coal_type = HIGH_COALESCE;
+				}		
+			}
+		}
+	}
+	return 0;
+
+}
 /*
-This is device interrupt function. It handles transmit, receive and link change interrupts.
+This is device interrupt function. It handles transmit, receive,link change and hardware timer interrupts.
 */
 static void amd8111e_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
@@ -791,7 +1109,7 @@ static void amd8111e_interrupt(int irq, 
 	if(dev == NULL)
 		return;
 
-	spin_lock (&lp->lock);
+	if (regs) spin_lock (&lp->lock);
 	/* disabling interrupt */
 	writel(INTREN, mmio + CMD0);
 
@@ -819,15 +1137,20 @@ static void amd8111e_interrupt(int irq, 
 	/* Check if  Link Change Interrupt has occurred. */
 	if (intr0 & LCINT)
 		amd8111e_link_change(dev);
-	
+
+	/* Check if Hardware Timer Interrupt has occurred. */
+	if (intr0 & STINT)
+		amd8111e_calc_coalesce(dev);
+
 err_no_interrupt:
 	writel( VAL0 | INTREN,mmio + CMD0);
-	spin_unlock(&lp->lock);
-	return;
-
+	
+	if (regs) spin_unlock(&lp->lock);
+	
 }
+
 /*
-This function closes the network interface and copies the new set of statistics into the previous statistics structure so that most recent statistics will be available after the interface is down.
+This function closes the network interface and updates the statistics so that most recent statistics will be available after the interface is down.
 */
 static int amd8111e_close(struct net_device * dev)
 {
@@ -842,10 +1165,15 @@ static int amd8111e_close(struct net_dev
 	
 	netif_carrier_off(lp->amd8111e_net_dev);
 
-	spin_unlock_irq(&lp->lock);
+	/* Delete ipg timer */
+	if(lp->options & OPTION_DYN_IPG_ENABLE)	        
+		del_timer_sync(&lp->ipg_data.ipg_timer);
 
+	spin_unlock_irq(&lp->lock);
 	free_irq(dev->irq, dev);
-	memcpy(&lp->prev_stats,amd8111e_get_stats(dev), sizeof(lp->prev_stats));
+
+	/* Update the statistics before closing */
+	amd8111e_get_stats(dev);
 	lp->opened = 0;
 	return 0;
 }
@@ -867,7 +1195,12 @@ static int amd8111e_open(struct net_devi
 		spin_unlock_irq(&lp->lock);
 		return -ENOMEM;
 	}
-	
+	/* Start ipg timer */
+	if(lp->options & OPTION_DYN_IPG_ENABLE){	        
+		add_timer(&lp->ipg_data.ipg_timer);
+		printk(KERN_INFO "%s: Dynamic IPG Enabled.\n",dev->name);
+	}
+
 	lp->opened = 1;
 
 	spin_unlock_irq(&lp->lock);
@@ -905,11 +1238,10 @@ static int amd8111e_start_xmit(struct sk
 	lp->tx_ring[tx_index].buff_count = cpu_to_le16(skb->len);
 
 	lp->tx_skbuff[tx_index] = skb;
-	lp->tx_ring[tx_index].tx_dr_offset2 = 0;
+	lp->tx_ring[tx_index].tx_flags = 0;
 
 #if AMD8111E_VLAN_TAG_USED
 	if((lp->vlgrp != NULL) && vlan_tx_tag_present(skb)){
-
 		lp->tx_ring[tx_index].tag_ctrl_cmd |= 
 				cpu_to_le32(TCC_VLAN_INSERT);	
 		lp->tx_ring[tx_index].tag_ctrl_info = 
@@ -923,7 +1255,7 @@ static int amd8111e_start_xmit(struct sk
 	    (u32) cpu_to_le32(lp->tx_dma_addr[tx_index]);
 
 	/*  Set FCS and LTINT bits */
-	lp->tx_ring[tx_index].tx_dr_offset2 |=
+	lp->tx_ring[tx_index].tx_flags |=
 	    cpu_to_le16(OWN_BIT | STP_BIT | ENP_BIT|ADD_FCS_BIT|LTINT_BIT);
 
 	lp->tx_idx++;
@@ -946,16 +1278,54 @@ This function returns all the memory map
 static char* amd8111e_read_regs(struct amd8111e_priv* lp)
 {    	
 	void * mmio = lp->mmio;
-        unsigned char * reg_buff;
+        u32 * reg_buff;
 
-     	int i;
-     
      	reg_buff = kmalloc( AMD8111E_REG_DUMP_LEN,GFP_KERNEL);
 	if(NULL == reg_buff)
 		return NULL;
-    	for (i=0; i < AMD8111E_REG_DUMP_LEN; i+=4)
-		reg_buff[i]= readl(mmio + i);	
-	return reg_buff;
+
+	/* Read only necessary registers */
+	reg_buff[0] = readl(mmio + XMT_RING_BASE_ADDR0);
+	reg_buff[1] = readl(mmio + XMT_RING_LEN0);
+	reg_buff[2] = readl(mmio + RCV_RING_BASE_ADDR0);
+	reg_buff[3] = readl(mmio + RCV_RING_LEN0);
+	reg_buff[4] = readl(mmio + CMD0);
+	reg_buff[5] = readl(mmio + CMD2);
+	reg_buff[6] = readl(mmio + CMD3);
+	reg_buff[7] = readl(mmio + CMD7);
+	reg_buff[8] = readl(mmio + INT0);
+	reg_buff[9] = readl(mmio + INTEN0);
+	reg_buff[10] = readl(mmio + LADRF);
+	reg_buff[11] = readl(mmio + LADRF+4);
+	reg_buff[12] = readl(mmio + STAT0);
+
+	return (char *)reg_buff;
+}
+/*
+amd8111e crc generator implementation is different from the kernel
+ether_crc() function.
+*/
+int amd8111e_ether_crc(int len, char* mac_addr)
+{
+	int i,byte;
+	unsigned char octet;
+	u32 crc= INITCRC;
+
+	for(byte=0; byte < len; byte++){
+		octet = mac_addr[byte];
+		for( i=0;i < 8; i++){
+			/*If the next bit form the input stream is 1,subtract				 the divisor (CRC32) from the dividend(crc).*/
+			if( (octet & 0x1) ^ (crc & 0x1) ){
+				crc >>= 1;
+				crc ^= CRC32;
+			}
+			else
+				crc >>= 1;
+			
+			octet >>= 1;
+		}
+	}	
+	return crc; 
 }
 /*
 This function sets promiscuos mode, all-multi mode or the multicast address 
@@ -967,9 +1337,8 @@ static void amd8111e_set_multicast_list(
 	struct amd8111e_priv *lp = dev->priv;
 	u32 mc_filter[2] ;
 	int i,bit_num;
-
 	if(dev->flags & IFF_PROMISC){
-		printk("%s: Setting  promiscuous mode.\n",dev->name);
+		printk(KERN_INFO "%s: Setting  promiscuous mode.\n",dev->name);
 		writel( VAL2 | PROM, lp->mmio + CMD2);
 		return;
 	}
@@ -980,7 +1349,7 @@ static void amd8111e_set_multicast_list(
 		mc_filter[1] = mc_filter[0] = 0xffffffff;
 		lp->mc_list = dev->mc_list;
 		lp->options |= OPTION_MULTICAST_ENABLE;
-		AMD8111E_WRITE_REG64(lp->mmio, LADRF,mc_filter);
+		amd8111e_writeq(*(u64*)mc_filter,lp->mmio + LADRF);
 		return;
 	}
 	if( dev->mc_count == 0 ){
@@ -988,7 +1357,7 @@ static void amd8111e_set_multicast_list(
 		mc_filter[1] = mc_filter[0] = 0;
 		lp->mc_list = 0;
 		lp->options &= ~OPTION_MULTICAST_ENABLE;
-		AMD8111E_WRITE_REG64(lp->mmio, LADRF,mc_filter);
+		amd8111e_writeq(*(u64*)mc_filter,lp->mmio + LADRF);
 		/* disable promiscous mode */
 		writel(PROM, lp->mmio + CMD2);
 		return;
@@ -999,14 +1368,16 @@ static void amd8111e_set_multicast_list(
 	mc_filter[1] = mc_filter[0] = 0;
 	for (i = 0, mc_ptr = dev->mc_list; mc_ptr && i < dev->mc_count;
 		     i++, mc_ptr = mc_ptr->next) {
-		bit_num = ether_crc(ETH_ALEN, mc_ptr->dmi_addr) >> 26;
-			
+		bit_num = ( amd8111e_ether_crc(ETH_ALEN,mc_ptr->dmi_addr)							 >> 26 ) & 0x3f;
 		mc_filter[bit_num >> 5] |= 1 << (bit_num & 31);
 	}	
+	amd8111e_writeq(*(u64*)mc_filter,lp->mmio+ LADRF);
+
+	/* To eliminate PCI posting bug */
+	readl(lp->mmio + CMD2);
 
-	AMD8111E_WRITE_REG64(lp->mmio, LADRF, mc_filter);
-	return;
 }
+
 /*
 This function handles all the  ethtool ioctls. It gives driver info, gets/sets driver speed, gets memory mapped register values, forces auto negotiation, sets/gets WOL options for ethtool application. 
 */
@@ -1029,6 +1400,7 @@ static int amd8111e_ethtool_ioctl(struct
 		strcpy (info.driver, MODULE_NAME);
 		strcpy (info.version, MODULE_VERSION);
 		memset(&info.fw_version, 0, sizeof(info.fw_version));
+		sprintf(info.fw_version,"%u",chip_version);
 		strcpy (info.bus_info, pci_dev->slot_name);
 		info.eedump_len = 0;
 		info.regdump_len = AMD8111E_REG_DUMP_LEN;
@@ -1036,85 +1408,27 @@ static int amd8111e_ethtool_ioctl(struct
 			return -EFAULT;
 		return 0;
 	}
-	case ETHTOOL_GSET:{
-		struct ethtool_cmd cmd = { ETHTOOL_GSET };
-
-		if (!lp->opened) 
-			return -EAGAIN;
-
-		cmd.supported = SUPPORTED_Autoneg |
-				SUPPORTED_100baseT_Half |
-				SUPPORTED_100baseT_Full |
-			  	SUPPORTED_10baseT_Half |
-			        SUPPORTED_10baseT_Full |
-			        SUPPORTED_MII;
-
-		cmd.advertising = ADVERTISED_Autoneg |
-				ADVERTISED_100baseT_Half |
-				ADVERTISED_100baseT_Full |
-			  	ADVERTISED_10baseT_Half |
-			        ADVERTISED_10baseT_Full |
-			        ADVERTISED_MII;
-		cmd.speed = lp->link_config.speed;
-		cmd.duplex = lp->link_config.duplex;
-		cmd.port = 0;
-		cmd.phy_address = PHY_ID;
-		cmd.transceiver = XCVR_EXTERNAL;
-		cmd.autoneg = lp->link_config.autoneg;
-		cmd.maxtxpkt = 0; /* not implemented interrupt coalasing */
-		cmd.maxrxpkt = 0; /* not implemented interrupt coalasing */
-		if (copy_to_user(useraddr, &cmd, sizeof(cmd)))
+	/* get settings */
+	case ETHTOOL_GSET: {
+		struct ethtool_cmd ecmd = { ETHTOOL_GSET };
+		spin_lock_irq(&lp->lock);
+		mii_ethtool_gset(&lp->mii_if, &ecmd);
+		spin_unlock_irq(&lp->lock);
+		if (copy_to_user(useraddr, &ecmd, sizeof(ecmd)))
 			return -EFAULT;
 		return 0;
-		}
+	}
+	/* set settings */
 	case ETHTOOL_SSET: {
-	
-		struct ethtool_cmd cmd;
-
-		if (!lp->opened)
-			return -EAGAIN;
-		if (copy_from_user(&cmd, useraddr, sizeof(cmd)))
+		int r;
+		struct ethtool_cmd ecmd;
+		if (copy_from_user(&ecmd, useraddr, sizeof(ecmd)))
 			return -EFAULT;
 
 		spin_lock_irq(&lp->lock);
-
-		if(cmd.autoneg == AUTONEG_ENABLE){
-			/* keeping the original speeds */
-			if((lp->link_config.speed != SPEED_INVALID)&&
-				(lp->link_config.duplex != DUPLEX_INVALID)){
-			lp->link_config.orig_speed = lp->link_config.speed;
-			lp->link_config.orig_duplex = lp->link_config.duplex;
-			lp->link_config.orig_phy_option = lp->ext_phy_option;
-			}
-
-			lp->ext_phy_option = XPHYANE;
-		}
-		else if(cmd.speed == SPEED_100 && cmd.duplex ==  DUPLEX_HALF)
-			lp->ext_phy_option = XPHYSP;
-		else if(cmd.speed == SPEED_100 && cmd.duplex ==  DUPLEX_FULL)
-			lp->ext_phy_option = XPHYSP |XPHYFD;
-		else if(cmd.speed == SPEED_10 && cmd.duplex ==  DUPLEX_HALF)
-			lp->ext_phy_option = 0;
-		else if(cmd.speed == SPEED_10 && cmd.duplex ==  DUPLEX_FULL)
-			lp->ext_phy_option = XPHYFD;
-		else {	
-			/* setting the original speed */
-			cmd.speed = lp->link_config.orig_speed;
-			cmd.duplex = lp->link_config.orig_duplex;
-			lp->ext_phy_option = lp->link_config.orig_phy_option;
-		}
-		lp->link_config.autoneg = cmd.autoneg;
-		if (cmd.autoneg == AUTONEG_ENABLE) {
-			
-			lp->link_config.speed = SPEED_INVALID;
-			lp->link_config.duplex = DUPLEX_INVALID;
-		} else {
-			lp->link_config.speed = cmd.speed;
-			lp->link_config.duplex = cmd.duplex;
-		}
-		amd8111e_set_ext_phy(dev);
+		r = mii_ethtool_sset(&lp->mii_if, &ecmd);
 		spin_unlock_irq(&lp->lock);
-		return 0;
+		return r;
 	}
 	case ETHTOOL_GREGS: {
 		struct ethtool_regs regs;
@@ -1140,24 +1454,17 @@ static int amd8111e_ethtool_ioctl(struct
 		kfree(regbuf);
 		return ret;
 	}
+	/* restart autonegotiation */
 	case ETHTOOL_NWAY_RST: {
-		int ret;
-		spin_lock_irq(&lp->lock);
-		if(lp->link_config.autoneg == AUTONEG_ENABLE){
-			lp->ext_phy_option = XPHYANE;
-			amd8111e_set_ext_phy(dev);
-			ret = 0;
-		}else
-			ret =  -EINVAL;
-		spin_unlock_irq(&lp->lock);
-		return ret;
+		return mii_nway_restart(&lp->mii_if);
 	}
+	/* get link status */
 	case ETHTOOL_GLINK: {
-		struct ethtool_value val = { ETHTOOL_GLINK };
-
-		val.data = netif_carrier_ok(dev) ? 1 : 0;
+		struct ethtool_value val = {ETHTOOL_GLINK};
+		val.data = mii_link_ok(&lp->mii_if);
 		if (copy_to_user(useraddr, &val, sizeof(val)))
 			return -EFAULT;
+		return 0;
 	}
 	case ETHTOOL_GWOL: {
 		struct ethtool_wolinfo wol_info = { ETHTOOL_GWOL };
@@ -1196,60 +1503,6 @@ static int amd8111e_ethtool_ioctl(struct
 	}
 		return -EOPNOTSUPP;
 }
-static int amd8111e_read_phy(struct amd8111e_priv* lp, int phy_id, int reg, u32* val)
-{
-	void * mmio = lp->mmio;
-	unsigned int reg_val;
-	unsigned int repeat= REPEAT_CNT;
-
-	reg_val = readl(mmio + PHY_ACCESS);
-	while (reg_val & PHY_CMD_ACTIVE)
-		reg_val = readl( mmio + PHY_ACCESS );
-
-	writel( PHY_RD_CMD | ((phy_id & 0x1f) << 21) |
-			   ((reg & 0x1f) << 16),  mmio +PHY_ACCESS);
-	do{
-		reg_val = readl(mmio + PHY_ACCESS);
-		udelay(30);  /* It takes 30 us to read/write data */
-	} while (--repeat && (reg_val & PHY_CMD_ACTIVE));
-	if(reg_val & PHY_RD_ERR)
-		goto err_phy_read;
-	
-	*val = reg_val & 0xffff;
-	return 0;
-err_phy_read:	
-	*val = 0;
-	return -EINVAL;
-	
-}
-static int amd8111e_write_phy(struct amd8111e_priv* lp,int phy_id, int reg, u32 val)
-{
-	unsigned int repeat = REPEAT_CNT
-	void * mmio = lp->mmio;
-	unsigned int reg_val;
-	
-
-	reg_val = readl(mmio + PHY_ACCESS);
-	while (reg_val & PHY_CMD_ACTIVE)
-		reg_val = readl( mmio + PHY_ACCESS );
-
-	writel( PHY_WR_CMD | ((phy_id & 0x1f) << 21) |
-			   ((reg & 0x1f) << 16)|val, mmio + PHY_ACCESS);
-
-	do{
-		reg_val = readl(mmio + PHY_ACCESS);
-		udelay(30);  /* It takes 30 us to read/write the data */
-	} while (--repeat && (reg_val & PHY_CMD_ACTIVE));
-	
-	if(reg_val & PHY_RD_ERR)
-		goto err_phy_write;
-	
-	return 0;
-
-err_phy_write:	
-	return -EINVAL;
-	
-}
 static int amd8111e_ioctl(struct net_device * dev , struct ifreq *ifr, int cmd)
 {
 	struct mii_ioctl_data *data = (struct mii_ioctl_data *)&ifr->ifr_data;
@@ -1317,15 +1570,10 @@ int amd8111e_change_mtu(struct net_devic
 
 	dev->mtu = new_mtu;
 
-	/* if (new_mtu > ETH_DATA_LEN)
-		lp->options |= OPTION_JUMBO_ENABLE;
-	else
-		lp->options &= ~OPTION_JUMBO_ENABLE;
-	*/
 	err = amd8111e_restart(dev);
 	spin_unlock_irq(&lp->lock);
-
-	netif_start_queue(dev);
+	if(!err)
+		netif_start_queue(dev);
 	return err;
 }
 
@@ -1351,73 +1599,41 @@ static int amd8111e_enable_magicpkt(stru
 {
 	writel( VAL1|MPPLBA, lp->mmio + CMD3);
 	writel( VAL0|MPEN_SW, lp->mmio + CMD7);
+
+	/* To eliminate PCI posting bug */
+	readl(lp->mmio + CMD7);
 	return 0;
 }
 
 static int amd8111e_enable_link_change(struct amd8111e_priv* lp)
 {
+
 	/* Adapter is already stoped/suspended/interrupt-disabled */
 	writel(VAL0|LCMODE_SW,lp->mmio + CMD7);
-	return 0;
-}	
-
-/* 
-This function sets the power state of the device. When the device go to lower power states 1,2, and 3 it enables the wake on lan 
-*/  	
-static int amd8111e_set_power_state(struct amd8111e_priv* lp, u32 state)
-{
-	u16 power_control;
-	int pm = lp->pm_cap;
-
-	pci_read_config_word(lp->pci_dev,
-			     pm + PCI_PM_CTRL,
-			     &power_control);
-
-	power_control |= PCI_PM_CTRL_PME_STATUS;
-	power_control &= ~(PCI_PM_CTRL_STATE_MASK);
-	switch (state) {
-	case 0:
-		power_control |= 0;
-		pci_write_config_word(lp->pci_dev,
-				      pm + PCI_PM_CTRL,
-				      power_control);
-		return 0;
-
-	case 1:
-		power_control |= 1;
-		break;
-
-	case 2:
-		power_control |= 2;
-		break;
-
-	case 3:
-		power_control |= 3;
-		break;
-	default:
-
-		printk(KERN_WARNING "%s: Invalid power state (%d) requested.\n",
-		       lp->amd8111e_net_dev->name, state);
-		return -EINVAL;
-	}
 	
-	if(lp->options & OPTION_WAKE_MAGIC_ENABLE)
-		amd8111e_enable_magicpkt(lp);	
-	if(lp->options & OPTION_WAKE_PHY_ENABLE)
-		amd8111e_enable_link_change(lp);	
-
-	/*  Setting new power state. */
-	pci_write_config_word(lp->pci_dev, pm + PCI_PM_CTRL, power_control);
-
+	/* To eliminate PCI posting bug */
+	readl(lp->mmio + CMD7);
 	return 0;
+}	
+/* This function is called when a packet transmission fails to complete within a  resonable period, on the assumption that an interrupts have been failed or the  interface is locked up. This function will reinitialize the hardware */
 
+static void amd8111e_tx_timeout(struct net_device *dev)
+{
+	struct amd8111e_priv* lp = dev->priv;
+	int err;
 
+	printk(KERN_ERR "%s: transmit timed out, resetting\n",
+	 					      dev->name);
+	spin_lock_irq(&lp->lock);
+	err = amd8111e_restart(dev);
+	spin_unlock_irq(&lp->lock);
+	if(!err)
+		netif_wake_queue(dev);
 }
 static int amd8111e_suspend(struct pci_dev *pci_dev, u32 state)
 {	
 	struct net_device *dev = pci_get_drvdata(pci_dev);
 	struct amd8111e_priv *lp = dev->priv;
-	int err;
 	
 	if (!netif_running(dev))
 		return 0;
@@ -1431,37 +1647,54 @@ static int amd8111e_suspend(struct pci_d
 	
 	/* stop chip */
 	spin_lock_irq(&lp->lock);
+	if(lp->options & OPTION_DYN_IPG_ENABLE)	        
+		del_timer_sync(&lp->ipg_data.ipg_timer);
 	amd8111e_stop_chip(lp);
 	spin_unlock_irq(&lp->lock);
 
-	err = amd8111e_set_power_state(lp, state);
-	if (err) {
+	if(lp->options & OPTION_WOL_ENABLE){
+		 /* enable wol */
+		if(lp->options & OPTION_WAKE_MAGIC_ENABLE)
+			amd8111e_enable_magicpkt(lp);	
+		if(lp->options & OPTION_WAKE_PHY_ENABLE)
+			amd8111e_enable_link_change(lp);	
 		
-		spin_lock_irq(&lp->lock);
-		amd8111e_restart(dev);
-		spin_unlock_irq(&lp->lock);
+		pci_enable_wake(pci_dev, 3, 1);
+		pci_enable_wake(pci_dev, 4, 1); /* D3 cold */
 
-		netif_device_attach(dev);
 	}
-	return err;
+	else{		
+		pci_enable_wake(pci_dev, 3, 0);
+		pci_enable_wake(pci_dev, 4, 0); /* 4 == D3 cold */
+	}
+	
+	pci_save_state(pci_dev, lp->pm_state);
+	pci_set_power_state(pci_dev, 3);
+
+	return 0;
 }
 static int amd8111e_resume(struct pci_dev *pci_dev)
 {
 	struct net_device *dev = pci_get_drvdata(pci_dev);
 	struct amd8111e_priv *lp = dev->priv;
-	int err;
 	
 	if (!netif_running(dev))
 		return 0;
 
-	err = amd8111e_set_power_state(lp, 0);
-	if (err)
-		return err;
+	pci_set_power_state(pci_dev, 0);
+	pci_restore_state(pci_dev, lp->pm_state);
+
+	pci_enable_wake(pci_dev, 3, 0);
+	pci_enable_wake(pci_dev, 4, 0); /* D3 cold */
 
 	netif_device_attach(dev);
 
 	spin_lock_irq(&lp->lock);
 	amd8111e_restart(dev);
+	/* Restart ipg timer */
+	if(lp->options & OPTION_DYN_IPG_ENABLE)	        
+		mod_timer(&lp->ipg_data.ipg_timer, 
+				jiffies + (IPG_CONVERGE_TIME * HZ));
 	spin_unlock_irq(&lp->lock);
 
 	return 0;
@@ -1480,6 +1713,65 @@ static void __devexit amd8111e_remove_on
 		pci_set_drvdata(pdev, NULL);
 	}
 }
+static void amd8111e_config_ipg(struct net_device* dev)
+{
+	struct amd8111e_priv *lp = dev->priv;
+	struct ipg_info* ipg_data = &lp->ipg_data;
+	void * mmio = lp->mmio;
+	unsigned int prev_col_cnt = ipg_data->col_cnt;
+	unsigned int total_col_cnt;
+	unsigned int tmp_ipg;
+	
+	if(lp->link_config.duplex == DUPLEX_FULL){
+		ipg_data->ipg = DEFAULT_IPG;
+		return;
+	}
+
+	if(ipg_data->ipg_state == SSTATE){
+		
+		if(ipg_data->timer_tick == IPG_STABLE_TIME){
+			
+			ipg_data->timer_tick = 0;
+			ipg_data->ipg = MIN_IPG - IPG_STEP;
+			ipg_data->current_ipg = MIN_IPG;
+			ipg_data->diff_col_cnt = 0xFFFFFFFF;
+			ipg_data->ipg_state = CSTATE;
+		}
+		else
+			ipg_data->timer_tick++;
+	}
+
+	if(ipg_data->ipg_state == CSTATE){
+		
+		/* Get the current collision count */
+
+		total_col_cnt = ipg_data->col_cnt = 
+				amd8111e_read_mib(mmio, xmt_collisions);
+
+		if ((total_col_cnt - prev_col_cnt) < 
+				(ipg_data->diff_col_cnt)){
+			
+			ipg_data->diff_col_cnt =
+				total_col_cnt - prev_col_cnt ;
+
+			ipg_data->ipg = ipg_data->current_ipg;
+		}
+
+		ipg_data->current_ipg += IPG_STEP;
+
+		if (ipg_data->current_ipg <= MAX_IPG)
+			tmp_ipg = ipg_data->current_ipg;
+		else{
+			tmp_ipg = ipg_data->ipg;
+			ipg_data->ipg_state = SSTATE;
+		}
+		writew((u32)tmp_ipg, mmio + IPG); 
+		writew((u32)(tmp_ipg - IFS1_DELTA), mmio + IFS1); 
+	}
+	 mod_timer(&lp->ipg_data.ipg_timer, jiffies + (IPG_CONVERGE_TIME * HZ));
+	return;
+
+}
 
 static int __devinit amd8111e_probe_one(struct pci_dev *pdev,
 				  const struct pci_device_id *ent)
@@ -1488,7 +1780,6 @@ static int __devinit amd8111e_probe_one(
 	unsigned long reg_addr,reg_len;
 	struct amd8111e_priv* lp;
 	struct net_device* dev;
-	unsigned int chip_version;
 
 	err = pci_enable_device(pdev);
 	if(err){
@@ -1547,11 +1838,16 @@ static int __devinit amd8111e_probe_one(
 #endif	
 	
 	lp = dev->priv;
-	memset (lp, 0, sizeof (*lp));
 	lp->pci_dev = pdev;
 	lp->amd8111e_net_dev = dev;
 	lp->pm_cap = pm_cap;
 
+	/* setting mii default values */
+	lp->mii_if.dev = dev;
+	lp->mii_if.mdio_read = amd8111e_mdio_read;
+	lp->mii_if.mdio_write = amd8111e_mdio_write;
+	lp->mii_if.phy_id = PHY_ID;
+
 	spin_lock_init(&lp->lock);
 
 	lp->mmio = ioremap(reg_addr, reg_len);
@@ -1565,12 +1861,14 @@ static int __devinit amd8111e_probe_one(
 	/* Initializing MAC address */
 	for(i = 0; i < ETH_ADDR_LEN; i++)
 			dev->dev_addr[i] =readb(lp->mmio + PADR + i);
-	/* Setting user defined speed */
-	if (speed_duplex[card_idx] > sizeof(speed_duplex_mapping))
-		lp->ext_phy_option = XPHYANE;
-	else
-		lp->ext_phy_option = 
-				speed_duplex_mapping[speed_duplex[card_idx]];
+	
+	/* Setting user defined parametrs */
+	lp->ext_phy_option = speed_duplex[card_idx];
+	if(coalesce[card_idx])
+		lp->options |= OPTION_INTR_COAL_ENABLE;		
+	if(dynamic_ipg[card_idx++])
+		lp->options |= OPTION_DYN_IPG_ENABLE;	        	
+
 	/* Initialize driver entry points */
 	dev->open = amd8111e_open;
 	dev->hard_start_xmit = amd8111e_start_xmit;
@@ -1580,6 +1878,8 @@ static int __devinit amd8111e_probe_one(
 	dev->do_ioctl = amd8111e_ioctl;
 	dev->change_mtu = amd8111e_change_mtu;
 	dev->irq =pdev->irq;
+	dev->tx_timeout = amd8111e_tx_timeout; 
+	dev->watchdog_timeo = AMD8111E_TX_TIMEOUT; 
 
 #if AMD8111E_VLAN_TAG_USED
 	dev->features |= NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;
@@ -1589,10 +1889,6 @@ static int __devinit amd8111e_probe_one(
 	
 	/* Set receive buffer length and set jumbo option*/
 	amd8111e_set_rx_buff_len(dev);
-	
-
-	/* dev->tx_timeout = tg3_tx_timeout; */
-	/* dev->watchdog_timeo = TG3_TX_TIMEOUT; */
 
 	err = register_netdev(dev);
 	if (err) {
@@ -1603,15 +1899,26 @@ static int __devinit amd8111e_probe_one(
 
 	pci_set_drvdata(pdev, dev);
 	
+	/* Initialize software ipg timer */
+	if(lp->options & OPTION_DYN_IPG_ENABLE){	        
+		init_timer(&lp->ipg_data.ipg_timer);
+		lp->ipg_data.ipg_timer.data = (unsigned long) dev;
+		lp->ipg_data.ipg_timer.function = (void *)&amd8111e_config_ipg;
+		lp->ipg_data.ipg_timer.expires = jiffies + 
+						 IPG_CONVERGE_TIME * HZ;
+		lp->ipg_data.ipg = DEFAULT_IPG;
+		lp->ipg_data.ipg_state = CSTATE;
+	};
+
 	/*  display driver and device information */
 
-    chip_version = (readl(lp->mmio + CHIPID) & 0xf0000000)>>28;
-    printk("%s: AMD-8111e Driver Version: %s\n",dev->name,MODULE_VERSION);
-    printk("%s: [ Rev %x ] PCI 10/100BaseT Ethernet ", dev->name, chip_version);
-    for (i = 0; i < 6; i++)
-	printk("%2.2x%c", dev->dev_addr[i],i == 5 ? ' ' : ':');
-     printk("\n");	
-	return 0;
+    	chip_version = (readl(lp->mmio + CHIPID) & 0xf0000000)>>28;
+    	printk(KERN_INFO "%s: AMD-8111e Driver Version: %s\n",								 dev->name,MODULE_VERSION);
+    	printk(KERN_INFO "%s: [ Rev %x ] PCI 10/100BaseT Ethernet ",							dev->name, chip_version);
+    	for (i = 0; i < 6; i++)
+		printk("%2.2x%c",dev->dev_addr[i],i == 5 ? ' ' : ':');
+    	printk( "\n");	
+    	return 0;
 err_iounmap:
 	iounmap((void *) lp->mmio);
 
diff -urNp linux-2/drivers/net/amd8111e.h linux-3/drivers/net/amd8111e.h
--- linux-2/drivers/net/amd8111e.h	
+++ linux-3/drivers/net/amd8111e.h	
@@ -1,4 +1,7 @@
 /*
+ * Advanced  Micro Devices Inc. AMD8111E Linux Network Driver 
+ * Copyright (C) 2003 Advanced Micro Devices 
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
@@ -27,73 +30,14 @@ Environment:
 	Kernel Mode
 
 Revision History:
-
+ 	3.0.0
+	   Initial Revision.
+	3.0.1
 */
 
 #ifndef _AMD811E_H
 #define _AMD811E_H
 
-/* Hardware definitions */
-
-#define B31_MASK	0x80000000
-#define B30_MASK	0X40000000
-#define B29_MASK	0x20000000
-#define B28_MASK	0x10000000
-#define B27_MASK	0x08000000
-#define B26_MASK	0x04000000
-#define B25_MASK	0x02000000
-#define B24_MASK	0x01000000
-#define B23_MASK	0x00800000
-#define B22_MASK	0x00400000
-#define B21_MASK	0x00200000
-#define B20_MASK	0x00100000
-#define B19_MASK	0x00080000
-#define B18_MASK	0x00040000
-#define B17_MASK	0x00020000
-#define B16_MASK	0x00010000
-
-#define B15_MASK	0x8000
-#define B14_MASK	0x4000
-#define B13_MASK	0x2000
-#define B12_MASK	0x1000
-#define B11_MASK	0x0800
-#define B10_MASK	0x0400
-#define B9_MASK		0x0200
-#define B8_MASK		0x0100
-#define B7_MASK		0x0080
-#define B6_MASK		0x0040
-#define B5_MASK		0x0020
-#define B4_MASK		0x0010
-#define B3_MASK		0x0008
-#define B2_MASK		0x0004
-#define B1_MASK		0x0002
-#define B0_MASK		0x0001
-
-/* PCI register offset */
-#define PCI_ID_REG		0x00
-#define PCI_COMMAND_REG		0x04
-/* #define MEMEN_BIT		B1_MASK */
-/* #define IOEN_BIT		B0_MASK */
-#define PCI_REV_ID_REG		0x08
-#define PCI_MEM_BASE_REG	0x10
-/* #define MEMBASE_MASK		0xFFFFF000 */
-/* #define MEMBASE_SIZE		4096 */
-#define PCI_INTR_REG		0x3C
-#define PCI_STATUS_REG		0x06
-#define PCI_CAP_ID_REG_OFFSET	0x34
-#define PCI_PMC_REG_OFFSET	0x36
-#define PCI_PMCSR_REG_OFFSET	0x38
-
-/* #define NEW_CAP		0x0010  */
-#define PME_EN			0x0100
-
-#define PARTID_MASK		0xFFFFF000
-#define PARTID_START_BIT	12
-
-/* #define LANCE_DWIO_RESET_PORT	0x18
-#define LANCE_WIO_RESET_PORT	0x14 */
-#define MIB_OFFSET		0x28
-
 /* Command style register access
 
 Registers CMD0, CMD2, CMD3,CMD7 and INTEN0 uses a write access technique called command style access. It allows the write to selected bits of this register without altering the bits that are not selected. Command style registers are divided into 4 bytes that can be written independently. Higher order bit of each byte is the  value bit that specifies the value that will be written into the selected bits of register. 
@@ -155,7 +99,7 @@ eg., if the value 10011010b is written i
 #define XMT_RING_LEN2		0x148 	/* Transmit Ring2 length register */
 #define XMT_RING_LEN3		0x14C	/* Transmit Ring3 length register */
 
-#define RCV_RING_LEN0		0x150	/* Transmit Ring0 length register */
+#define RCV_RING_LEN0		0x150	/* Receive Ring0 length register */
 
 #define SRAM_SIZE		0x178	/* SRAM size register */
 #define SRAM_BOUNDARY		0x17A	/* SRAM boundary register */
@@ -164,391 +108,398 @@ eg., if the value 10011010b is written i
 
 #define PADR			0x160	/* Physical address register */
 
+#define IFS1			0x18C	/* Inter-frame spacing Part1 register */
+#define IFS			0x18D	/* Inter-frame spacing register */
+#define IPG			0x18E	/* Inter-frame gap register */
 /* 64bit register */
 
 #define LADRF			0x168	/* Logical address filter register */
 
-/* 8bit regsisters */
-
-#define IFS1			0x18C	/* Inter-frame spacing Part1 register */
-#define IFS			0x18D	/* Inter-frame spacing register */
 
 /* Register Bit Definitions */
+typedef enum {
+
+	ASF_INIT_DONE		= (1 << 1),
+	ASF_INIT_PRESENT	= (1 << 0),
+
+}STAT_ASF_BITS; 
+   
+typedef enum {
+
+	MIB_CMD_ACTIVE		= (1 << 15 ),
+	MIB_RD_CMD		= (1 << 13 ),
+	MIB_CLEAR		= (1 << 12 ),
+	MIB_ADDRESS		= (1 << 0) | (1 << 1) | (1 << 2) | (1 << 3)|
+					(1 << 4) | (1 << 5),
+}MIB_ADDR_BITS;
+
+
+typedef enum {
+	
+	PMAT_DET		= (1 << 12),
+	MP_DET		        = (1 << 11),
+	LC_DET			= (1 << 10),
+	SPEED_MASK		= (1 << 9)|(1 << 8)|(1 << 7),
+	FULL_DPLX		= (1 << 6),
+	LINK_STATS		= (1 << 5),
+	AUTONEG_COMPLETE	= (1 << 4),
+	MIIPD			= (1 << 3),
+	RX_SUSPENDED		= (1 << 2),
+	TX_SUSPENDED		= (1 << 1),
+	RUNNING			= (1 << 0),
+
+}STAT0_BITS;
 
-/* STAT_ASF			0x00, 32bit register */
-#define ASF_INIT_DONE		B1_MASK
-#define ASF_INIT_PRESENT	B0_MASK
-
-/* MIB_ADDR			0x14, 16bit register */
-#define	MIB_CMD_ACTIVE		B15_MASK
-#define	MIB_RD_CMD		B13_MASK
-#define	MIB_CLEAR		B12_MASK
-#define	MIB_ADDRESS		0x0000003F	/* 5:0 */
-
-/* QOS_ADDR			0x1C, 16bit register */
-#define QOS_CMD_ACTIVE		B15_MASK
-#define QOS_WR_CMD		B14_MASK
-#define QOS_RD_CMD		B13_MASK
-#define QOS_ADDRESS		0x0000001F	/* 4:0 */
-
-/* STAT0			0x30, 32bit register */
-#define PAUSE_PEND		B14_MASK
-#define PAUSING			B13_MASK
-#define PMAT_DET		B12_MASK
-#define MP_DET			B11_MASK
-#define LC_DET			B10_MASK
-#define SPEED_MASK		0x0380	/* 9:7 */
-#define FULL_DPLX		B6_MASK
-#define LINK_STATS		B5_MASK
-#define AUTONEG_COMPLETE	B4_MASK
-#define MIIPD			B3_MASK
-#define RX_SUSPENDED		B2_MASK
-#define TX_SUSPENDED		B1_MASK
-#define RUNNING			B0_MASK
 #define PHY_SPEED_10		0x2
 #define PHY_SPEED_100		0x3
 
 /* INT0				0x38, 32bit register */
-#define INTR			B31_MASK
-#define PCSINT			B28_MASK
-#define LCINT			B27_MASK
-#define APINT5			B26_MASK
-#define APINT4			B25_MASK
-#define APINT3			B24_MASK
-#define TINT_SUM		B23_MASK
-#define APINT2			B22_MASK
-#define APINT1			B21_MASK
-#define APINT0			B20_MASK
-#define MIIPDTINT		B19_MASK
-#define MCCIINT			B18_MASK
-#define MCCINT			B17_MASK
-#define MREINT			B16_MASK
-#define RINT_SUM		B15_MASK
-#define SPNDINT			B14_MASK
-#define MPINT			B13_MASK
-#define SINT			B12_MASK
-#define TINT3			B11_MASK
-#define TINT2			B10_MASK
-#define TINT1			B9_MASK
-#define TINT0			B8_MASK
-#define UINT			B7_MASK
-#define STINT			B4_MASK
-#define RINT3			B3_MASK
-#define RINT2			B2_MASK
-#define RINT1			B1_MASK
-#define RINT0			B0_MASK
-
-/* INTEN0			0x40, 32bit register */
-#define VAL3			B31_MASK   /* VAL bit for byte 3 */
-#define VAL2			B23_MASK   /* VAL bit for byte 2 */
-#define VAL1			B15_MASK   /* VAL bit for byte 1 */
-#define VAL0			B7_MASK    /* VAL bit for byte 0 */
-/* VAL3 */
-#define PSCINTEN		B28_MASK
-#define LCINTEN			B27_MASK
-#define APINT5EN		B26_MASK
-#define APINT4EN		B25_MASK
-#define APINT3EN		B24_MASK
-/* VAL2 */
-#define APINT2EN		B22_MASK
-#define APINT1EN		B21_MASK
-#define APINT0EN		B20_MASK
-#define MIIPDTINTEN		B19_MASK
-#define MCCIINTEN		B18_MASK
-#define MCCINTEN		B17_MASK
-#define MREINTEN		B16_MASK
-/* VAL1 */
-#define SPNDINTEN		B14_MASK
-#define MPINTEN			B13_MASK
-#define SINTEN			B12_MASK
-#define TINTEN3			B11_MASK
-#define TINTEN2			B10_MASK
-#define TINTEN1			B9_MASK
-#define TINTEN0			B8_MASK
-/* VAL0 */
-#define STINTEN			B4_MASK
-#define RINTEN3			B3_MASK
-#define RINTEN2			B2_MASK
-#define RINTEN1			B1_MASK
-#define RINTEN0			B0_MASK
-
-#define INTEN0_CLEAR 		0x1F7F7F1F /* Command style register */		
-
-/* CMD0				0x48, 32bit register */
-/* VAL2 */
-#define RDMD3			B19_MASK
-#define RDMD2			B18_MASK
-#define RDMD1			B17_MASK
-#define RDMD0			B16_MASK
-/* VAL1 */
-#define TDMD3			B11_MASK
-#define TDMD2			B10_MASK
-#define TDMD1			B9_MASK
-#define TDMD0			B8_MASK
-/* VAL0 */
-#define UINTCMD			B6_MASK
-#define RX_FAST_SPND		B5_MASK
-#define TX_FAST_SPND		B4_MASK
-#define RX_SPND			B3_MASK
-#define TX_SPND			B2_MASK
-#define INTREN			B1_MASK
-#define RUN			B0_MASK
-
-#define CMD0_CLEAR 		0x000F0F7F   /* Command style register */	
-
-/* CMD2 			0x50, 32bit register */
-/* VAL3 */
-#define CONDUIT_MODE		B29_MASK
-/* VAL2 */
-#define RPA			B19_MASK
-#define DRCVPA			B18_MASK
-#define DRCVBC			B17_MASK
-#define PROM			B16_MASK
-/* VAL1 */
-#define ASTRP_RCV		B13_MASK
-#define FCOLL			B12_MASK
-#define EMBA			B11_MASK
-#define DXMT2PD			B10_MASK
-#define LTINTEN			B9_MASK
-#define DXMTFCS			B8_MASK
-/* VAL0 */
-#define APAD_XMT		B6_MASK
-#define DRTY			B5_MASK
-#define INLOOP			B4_MASK
-#define EXLOOP			B3_MASK
-#define REX_RTRY		B2_MASK
-#define REX_UFLO		B1_MASK
-#define REX_LCOL		B0_MASK
-
-#define CMD2_CLEAR 		0x3F7F3F7F   /* Command style register */
-
-/* CMD3				0x54, 32bit register */
-/* VAL3 */
-#define ASF_INIT_DONE_ALIAS	B29_MASK
-/* VAL2 */
-#define JUMBO			B21_MASK
-#define VSIZE			B20_MASK
-#define VLONLY			B19_MASK
-#define VL_TAG_DEL		B18_MASK
-/* VAL1 */
-#define EN_PMGR			B14_MASK
-#define INTLEVEL		B13_MASK
-#define FORCE_FULL_DUPLEX	B12_MASK
-#define FORCE_LINK_STATUS	B11_MASK
-#define APEP			B10_MASK
-#define MPPLBA			B9_MASK
-/* VAL0 */
-#define RESET_PHY_PULSE		B2_MASK
-#define RESET_PHY		B1_MASK
-#define PHY_RST_POL		B0_MASK
-/* CMD7				0x64, 32bit register */
-/* VAL0 */
-#define PMAT_SAVE_MATCH		B4_MASK
-#define PMAT_MODE		B3_MASK
-#define MPEN_SW			B1_MASK
-#define LCMODE_SW		B0_MASK
-
-#define CMD7_CLEAR  		0x0000001B		/* Command style register */
-/* CTRL0			0x68, 32bit register */
-#define PHY_SEL			0x03000000	/* 25:24 */
-#define RESET_PHY_WIDTH		0x00FF0000	/* 23:16 */
-#define BSWP_REGS		B10_MASK
-#define BSWP_DESC		B9_MASK
-#define BSWP_DATA		B8_MASK
-#define CACHE_ALIGN		B4_MASK
-#define BURST_LIMIT		0x0000000F	/* 3:0 */
-
-/* CTRL1			0x6C, 32bit register */
-#define SLOTMOD_MASK		0x03000000	/* 25:24 */
-#define XMTSP_MASK		0x300	/* 17:16 */
-#define XMTSP_128		0x200
-#define XMTSP_64		0x100
-#define CRTL1_DEFAULT		0x00000017
-
-/* CTRL2			0x70, 32bit register */
-#define FS_MASK			0x00070000	/* 18:16 */
-#define FMDC_MASK		0x00000300	/* 9:8 */
-#define XPHYRST			B7_MASK
-#define XPHYANE			B6_MASK
-#define XPHYFD			B5_MASK
-#define XPHYSP			B3_MASK	/* 4:3 */
-#define APDW_MASK		0x00000007	/* 2:0 */
-
-/* RCV_RING_CFG			0x78, 16bit register */
-#define RCV_DROP3		B11_MASK
-#define RCV_DROP2		B10_MASK
-#define RCV_DROP1		B9_MASK
-#define RCV_DROP0		B8_MASK
-#define RCV_RING_DEFAULT	0x0030	/* 5:4 */
-#define RCV_RING3_EN		B3_MASK
-#define RCV_RING2_EN		B2_MASK
-#define RCV_RING1_EN		B1_MASK
-#define RCV_RING0_EN		B0_MASK
+typedef enum {
+
+	INTR			= (1 << 31),
+	PCSINT			= (1 << 28), 
+	LCINT			= (1 << 27),
+	APINT5			= (1 << 26),
+	APINT4			= (1 << 25),
+	APINT3			= (1 << 24),
+	TINT_SUM		= (1 << 23),
+	APINT2			= (1 << 22),
+	APINT1			= (1 << 21),
+	APINT0			= (1 << 20),
+	MIIPDTINT		= (1 << 19),
+	MCCINT			= (1 << 17),
+	MREINT			= (1 << 16),
+	RINT_SUM		= (1 << 15),
+	SPNDINT			= (1 << 14),
+	MPINT			= (1 << 13),
+	SINT			= (1 << 12),
+	TINT3			= (1 << 11),
+	TINT2			= (1 << 10),
+	TINT1			= (1 << 9),
+	TINT0			= (1 << 8),
+	UINT			= (1 << 7),
+	STINT			= (1 << 4),
+	RINT0			= (1 << 0),
+
+}INT0_BITS;
+
+typedef enum {
+
+	VAL3			= (1 << 31),   /* VAL bit for byte 3 */
+	VAL2			= (1 << 23),   /* VAL bit for byte 2 */
+	VAL1			= (1 << 15),   /* VAL bit for byte 1 */
+	VAL0			= (1 << 7),    /* VAL bit for byte 0 */
+
+}VAL_BITS;
+
+typedef enum {
+
+	/* VAL3 */
+	LCINTEN			= (1 << 27),
+	APINT5EN		= (1 << 26),
+	APINT4EN		= (1 << 25),
+	APINT3EN		= (1 << 24),
+	/* VAL2 */
+	APINT2EN		= (1 << 22),
+	APINT1EN		= (1 << 21),
+	APINT0EN		= (1 << 20),
+	MIIPDTINTEN		= (1 << 19),
+	MCCIINTEN		= (1 << 18),
+	MCCINTEN		= (1 << 17),
+	MREINTEN		= (1 << 16),
+	/* VAL1 */
+	SPNDINTEN		= (1 << 14),
+	MPINTEN			= (1 << 13),
+	TINTEN3			= (1 << 11),
+	SINTEN			= (1 << 12),
+	TINTEN2			= (1 << 10),
+	TINTEN1			= (1 << 9),
+	TINTEN0			= (1 << 8),
+	/* VAL0 */
+	STINTEN			= (1 << 4),
+	RINTEN0			= (1 << 0),
+
+	INTEN0_CLEAR 		= 0x1F7F7F1F, /* Command style register */
+
+}INTEN0_BITS;		
+
+typedef enum {
+	/* VAL2 */
+	RDMD0			= (1 << 16),
+	/* VAL1 */
+	TDMD3			= (1 << 11),
+	TDMD2			= (1 << 10),
+	TDMD1			= (1 << 9),
+	TDMD0			= (1 << 8),
+	/* VAL0 */
+	UINTCMD			= (1 << 6),
+	RX_FAST_SPND		= (1 << 5),
+	TX_FAST_SPND		= (1 << 4),
+	RX_SPND			= (1 << 3),
+	TX_SPND			= (1 << 2),
+	INTREN			= (1 << 1),
+	RUN			= (1 << 0),
+
+	CMD0_CLEAR 		= 0x000F0F7F,   /* Command style register */	
+
+}CMD0_BITS;
+
+typedef enum {
+
+	/* VAL3 */
+	CONDUIT_MODE		= (1 << 29),
+	/* VAL2 */
+	RPA			= (1 << 19),
+	DRCVPA			= (1 << 18),
+	DRCVBC			= (1 << 17),
+	PROM			= (1 << 16),
+	/* VAL1 */
+	ASTRP_RCV		= (1 << 13),
+	RCV_DROP0	  	= (1 << 12),
+	EMBA			= (1 << 11),
+	DXMT2PD			= (1 << 10),
+	LTINTEN			= (1 << 9),
+	DXMTFCS			= (1 << 8),
+	/* VAL0 */
+	APAD_XMT		= (1 << 6),
+	DRTY			= (1 << 5),
+	INLOOP			= (1 << 4),
+	EXLOOP			= (1 << 3),
+	REX_RTRY		= (1 << 2),
+	REX_UFLO		= (1 << 1),
+	REX_LCOL		= (1 << 0),
+
+	CMD2_CLEAR 		= 0x3F7F3F7F,   /* Command style register */
+
+}CMD2_BITS;
+
+typedef enum {
+
+	/* VAL3 */
+	ASF_INIT_DONE_ALIAS	= (1 << 29),
+	/* VAL2 */
+	JUMBO			= (1 << 21),
+	VSIZE			= (1 << 20),	
+	VLONLY			= (1 << 19),
+	VL_TAG_DEL		= (1 << 18),	
+	/* VAL1 */
+	EN_PMGR			= (1 << 14),			
+	INTLEVEL		= (1 << 13),
+	FORCE_FULL_DUPLEX	= (1 << 12),	
+	FORCE_LINK_STATUS	= (1 << 11),	
+	APEP			= (1 << 10),	
+	MPPLBA			= (1 << 9),	
+	/* VAL0 */
+	RESET_PHY_PULSE		= (1 << 2),	
+	RESET_PHY		= (1 << 1),	
+	PHY_RST_POL		= (1 << 0),	
+
+}CMD3_BITS;
+
+
+typedef enum {
+
+	/* VAL0 */
+	PMAT_SAVE_MATCH		= (1 << 4),
+	PMAT_MODE		= (1 << 3),
+	MPEN_SW			= (1 << 1),
+	LCMODE_SW		= (1 << 0),
+
+	CMD7_CLEAR  		= 0x0000001B	/* Command style register */
+
+}CMD7_BITS;
+
+
+typedef enum {
+
+	RESET_PHY_WIDTH		= (0xF << 16) | (0xF<< 20), /* 0x00FF0000 */
+	XMTSP_MASK		= (1 << 9) | (1 << 8),	/* 9:8 */
+	XMTSP_128		= (1 << 9),	/* 9 */	
+	XMTSP_64		= (1 << 8),
+	CACHE_ALIGN		= (1 << 4),
+	BURST_LIMIT_MASK	= (0xF << 0 ),
+	CTRL1_DEFAULT		= 0x00010111,
+
+}CTRL1_BITS;
+
+typedef enum {
+
+	FMDC_MASK		= (1 << 9)|(1 << 8),	/* 9:8 */
+	XPHYRST			= (1 << 7),
+	XPHYANE			= (1 << 6),
+	XPHYFD			= (1 << 5),
+	XPHYSP			= (1 << 4) | (1 << 3),	/* 4:3 */
+	APDW_MASK		= (1 <<	2) | (1 << 1) | (1 << 0), /* 2:0 */
+
+}CTRL2_BITS;
 
 /* XMT_RING_LIMIT		0x7C, 32bit register */
-#define XMT_RING2_LIMIT		0x00FF0000	/* 23:16 */
-#define XMT_RING1_LIMIT		0x0000FF00	/* 15:8 */
-#define XMT_RING0_LIMIT		0x000000FF	/* 7:0 */
-
-/* AUTOPOLL0			0x88, 16bit register */
-#define AP_REG0_EN		B15_MASK
-#define AP_REG0_ADDR_MASK	0x1F00	/* 12:8 */
-#define AP_PHY0_ADDR_MASK	0x001F	/* 4:0 */
+typedef enum {
+
+	XMT_RING2_LIMIT		= (0xFF << 16),	/* 23:16 */
+	XMT_RING1_LIMIT		= (0xFF << 8),	/* 15:8 */
+	XMT_RING0_LIMIT		= (0xFF << 0), 	/* 7:0 */
+
+}XMT_RING_LIMIT_BITS;
+
+typedef enum {
+
+	AP_REG0_EN		= (1 << 15),
+	AP_REG0_ADDR_MASK	= (0xF << 8) |(1 << 12),/* 12:8 */
+	AP_PHY0_ADDR_MASK	= (0xF << 0) |(1 << 4),/* 4:0 */
+
+}AUTOPOLL0_BITS;
 
 /* AUTOPOLL1			0x8A, 16bit register */
-#define AP_REG1_EN		B15_MASK
-#define AP_REG1_ADDR_MASK	0x1F00	/* 12:8 */
-#define AP_PRE_SUP1		B6_MASK
-#define AP_PHY1_DFLT		B5_MASK
-#define AP_PHY1_ADDR_MASK	0x001F	/* 4:0 */
-
-/* AUTOPOLL2			0x8C, 16bit register */
-#define AP_REG2_EN		B15_MASK
-#define AP_REG2_ADDR_MASK	0x1F00	/* 12:8 */
-#define AP_PRE_SUP2		B6_MASK
-#define AP_PHY2_DFLT		B5_MASK
-#define AP_PHY2_ADDR_MASK	0x001F	/* 4:0 */
-
-/* AUTOPOLL3			0x8E, 16bit register */
-#define AP_REG3_EN		B15_MASK
-#define AP_REG3_ADDR_MASK	0x1F00	/* 12:8 */
-#define AP_PRE_SUP3		B6_MASK
-#define AP_PHY3_DFLT		B5_MASK
-#define AP_PHY3_ADDR_MASK	0x001F	/* 4:0 */
-
-/* AUTOPOLL4			0x90, 16bit register */
-#define AP_REG4_EN		B15_MASK
-#define AP_REG4_ADDR_MASK	0x1F00	/* 12:8 */
-#define AP_PRE_SUP4		B6_MASK
-#define AP_PHY4_DFLT		B5_MASK
-#define AP_PHY4_ADDR_MASK	0x001F	/* 4:0 */
-
-/* AUTOPOLL5			0x92, 16bit register */
-#define AP_REG5_EN		B15_MASK
-#define AP_REG5_ADDR_MASK	0x1F00	/* 12:8 */
-#define AP_PRE_SUP5		B6_MASK
-#define AP_PHY5_DFLT		B5_MASK
-#define AP_PHY5_ADDR_MASK	0x001F	/* 4:0 */
+typedef enum {
+
+	AP_REG1_EN		= (1 << 15),
+	AP_REG1_ADDR_MASK	= (0xF << 8) |(1 << 12),/* 12:8 */
+	AP_PRE_SUP1		= (1 << 6),
+	AP_PHY1_DFLT		= (1 << 5),
+	AP_PHY1_ADDR_MASK	= (0xF << 0) |(1 << 4),/* 4:0 */
+
+}AUTOPOLL1_BITS;
+
+
+typedef enum {
+
+	AP_REG2_EN		= (1 << 15),
+	AP_REG2_ADDR_MASK	= (0xF << 8) |(1 << 12),/* 12:8 */
+	AP_PRE_SUP2		= (1 << 6),
+	AP_PHY2_DFLT		= (1 << 5),
+	AP_PHY2_ADDR_MASK	= (0xF << 0) |(1 << 4),/* 4:0 */
+
+}AUTOPOLL2_BITS;
+
+typedef enum {
+
+	AP_REG3_EN		= (1 << 15),
+	AP_REG3_ADDR_MASK	= (0xF << 8) |(1 << 12),/* 12:8 */
+	AP_PRE_SUP3		= (1 << 6),
+	AP_PHY3_DFLT		= (1 << 5),
+	AP_PHY3_ADDR_MASK	= (0xF << 0) |(1 << 4),/* 4:0 */
+
+}AUTOPOLL3_BITS;
+
+
+typedef enum {
+
+	AP_REG4_EN		= (1 << 15),
+	AP_REG4_ADDR_MASK	= (0xF << 8) |(1 << 12),/* 12:8 */
+	AP_PRE_SUP4		= (1 << 6),
+	AP_PHY4_DFLT		= (1 << 5),
+	AP_PHY4_ADDR_MASK	= (0xF << 0) |(1 << 4),/* 4:0 */
+
+}AUTOPOLL4_BITS;
+
+
+typedef enum {
+
+	AP_REG5_EN		= (1 << 15),
+	AP_REG5_ADDR_MASK	= (0xF << 8) |(1 << 12),/* 12:8 */
+	AP_PRE_SUP5		= (1 << 6),
+	AP_PHY5_DFLT		= (1 << 5),
+	AP_PHY5_ADDR_MASK	= (0xF << 0) |(1 << 4),/* 4:0 */
+
+}AUTOPOLL5_BITS;
+
+
+
 
 /* AP_VALUE 			0x98, 32bit ragister */
-#define AP_VAL_ACTIVE		B31_MASK
-#define AP_VAL_RD_CMD		B29_MASK
-#define AP_ADDR			0x00070000	/* 18:16 */
-#define AP_VAL			0x0000FFFF	/* 15:0 */
-
-/* PCS_ANEG			0x9C, 32bit register */
-#define SYNC_LOST		B10_MASK
-#define IMATCH			B9_MASK
-#define CMATCH			B8_MASK
-#define PCS_AN_IDLE		B1_MASK
-#define PCS_AN_CFG		B0_MASK
-
-/* DLY_INT_A			0xA8, 32bit register */
-#define DLY_INT_A_R3		B31_MASK
-#define DLY_INT_A_R2		B30_MASK
-#define DLY_INT_A_R1		B29_MASK
-#define DLY_INT_A_R0		B28_MASK
-#define DLY_INT_A_T3		B27_MASK
-#define DLY_INT_A_T2		B26_MASK
-#define DLY_INT_A_T1		B25_MASK
-#define DLY_INT_A_T0		B24_MASK
-#define EVENT_COUNT_A		0x00FF0000	/* 20:16 */
-#define MAX_DELAY_TIME_A	0x000007FF	/* 10:0 */
-
-/* DLY_INT_B			0xAC, 32bit register */
-#define DLY_INT_B_R3		B31_MASK
-#define DLY_INT_B_R2		B30_MASK
-#define DLY_INT_B_R1		B29_MASK
-#define DLY_INT_B_R0		B28_MASK
-#define DLY_INT_B_T3		B27_MASK
-#define DLY_INT_B_T2		B26_MASK
-#define DLY_INT_B_T1		B25_MASK
-#define DLY_INT_B_T0		B24_MASK
-#define EVENT_COUNT_B		0x00FF0000	/* 20:16 */
-#define MAX_DELAY_TIME_B	0x000007FF	/* 10:0 */
-
-/* DFC_THRESH2			0xC0, 16bit register */
-#define DFC_THRESH2_HIGH	0xFF00	/* 15:8 */
-#define DFC_THRESH2_LOW		0x00FF	/* 7:0 */
-
-/* DFC_THRESH3			0xC2, 16bit register */
-#define DFC_THRESH3_HIGH	0xFF00	/* 15:8 */
-#define DFC_THRESH3_LOW		0x00FF	/* 7:0 */
-
-/* DFC_THRESH0			0xC4, 16bit register */
-#define DFC_THRESH0_HIGH	0xFF00	/* 15:8 */
-#define DFC_THRESH0_LOW		0x00FF	/* 7:0 */
-
-/* DFC_THRESH1			0xC6, 16bit register */
-#define DFC_THRESH1_HIGH	0xFF00	/* 15:8 */
-#define DFC_THRESH1_LOW		0x00FF	/* 7:0 */
+typedef enum {
+
+	AP_VAL_ACTIVE		= (1 << 31),
+	AP_VAL_RD_CMD		= ( 1 << 29),
+	AP_ADDR			= (1 << 18)|(1 << 17)|(1 << 16), /* 18:16 */
+	AP_VAL			= (0xF << 0) | (0xF << 4) |( 0xF << 8) |
+				  (0xF << 12),	/* 15:0 */
+
+}AP_VALUE_BITS;
+
+typedef enum {
+
+	DLY_INT_A_R3		= (1 << 31),
+	DLY_INT_A_R2		= (1 << 30),
+	DLY_INT_A_R1		= (1 << 29),
+	DLY_INT_A_R0		= (1 << 28),
+	DLY_INT_A_T3		= (1 << 27),
+	DLY_INT_A_T2		= (1 << 26),
+	DLY_INT_A_T1		= (1 << 25),
+	DLY_INT_A_T0		= ( 1 << 24),
+	EVENT_COUNT_A		= (0xF << 16) | (0x1 << 20),/* 20:16 */
+	MAX_DELAY_TIME_A	= (0xF << 0) | (0xF << 4) | (1 << 8)|
+				  (1 << 9) | (1 << 10),	/* 10:0 */
+
+}DLY_INT_A_BITS;
+
+typedef enum {
+
+	DLY_INT_B_R3		= (1 << 31),
+	DLY_INT_B_R2		= (1 << 30),
+	DLY_INT_B_R1		= (1 << 29),
+	DLY_INT_B_R0		= (1 << 28),
+	DLY_INT_B_T3		= (1 << 27),
+	DLY_INT_B_T2		= (1 << 26),
+	DLY_INT_B_T1		= (1 << 25),
+	DLY_INT_B_T0		= ( 1 << 24),
+	EVENT_COUNT_B		= (0xF << 16) | (0x1 << 20),/* 20:16 */
+	MAX_DELAY_TIME_B	= (0xF << 0) | (0xF << 4) | (1 << 8)| 
+				  (1 << 9) | (1 << 10),	/* 10:0 */
+}DLY_INT_B_BITS;
+
 
 /* FLOW_CONTROL 		0xC8, 32bit register */
-#define PAUSE_LEN_CHG		B30_MASK
-#define	FFC_EN			B28_MASK
-#define DFC_RING3_EN		B27_MASK
-#define DFC_RING2_EN		B26_MASK
-#define DFC_RING1_EN		B25_MASK
-#define DFC_RING0_EN		B24_MASK
-#define FIXP_CONGEST		B21_MASK
-#define FPA			B20_MASK
-#define NPA			B19_MASK
-#define FIXP			B18_MASK
-#define FCPEN			B17_MASK
-#define FCCMD			B16_MASK
-#define PAUSE_LEN		0x0000FFFF	/* 15:0 */
-
-/* FFC THRESH			0xCC, 32bit register */
-#define FFC_HIGH		0xFFFF0000	/* 31:16 */
-#define FFC_LOW			0x0000FFFF	/* 15:0 */
+typedef enum {
+
+	PAUSE_LEN_CHG		= (1 << 30),
+	FTPE			= (1 << 22),
+	FRPE			= (1 << 21),
+	NAPA			= (1 << 20),
+	NPA			= (1 << 19),
+	FIXP			= ( 1 << 18),
+	FCCMD			= ( 1 << 16),
+	PAUSE_LEN		= (0xF << 0) | (0xF << 4) |( 0xF << 8) |	 				  (0xF << 12),	/* 15:0 */
+
+}FLOW_CONTROL_BITS;
 
 /* PHY_ ACCESS			0xD0, 32bit register */
-#define	PHY_CMD_ACTIVE		B31_MASK
-#define PHY_WR_CMD		B30_MASK
-#define PHY_RD_CMD		B29_MASK
-#define PHY_RD_ERR		B28_MASK
-#define PHY_PRE_SUP		B27_MASK
-#define PHY_ADDR		0x03E00000	/* 25:21 */
-#define PHY_REG_ADDR		0x001F0000	/* 20:16 */
-#define PHY_DATA		0x0000FFFF	/* 15:0 */
-
-/* LED0..3			0xE0..0xE6, 16bit register */
-#define LEDOUT			B15_MASK
-#define LEDPOL			B14_MASK
-#define LEDDIS			B13_MASK
-#define LEDSTRETCH		B12_MASK
-#define LED1000			B8_MASK
-#define LED100			B7_MASK
-#define LEDMP			B6_MASK
-#define LEDFD			B5_MASK
-#define LEDLINK			B4_MASK
-#define LEDRCVMAT		B3_MASK
-#define LEDXMT			B2_MASK
-#define LEDRCV			B1_MASK
-#define LEDCOLOUT		B0_MASK
-
-/* EEPROM_ACC			0x17C, 16bit register */
-#define PVALID			B15_MASK
-#define PREAD			B14_MASK
-#define EEDET			B13_MASK
-#define	EEN			B4_MASK
-#define ECS			B2_MASK
-#define EESK			B1_MASK
-#define edi_edo			b0_MASK
+typedef enum {
+
+	PHY_CMD_ACTIVE		= (1 << 31),
+	PHY_WR_CMD		= (1 << 30),
+	PHY_RD_CMD		= (1 << 29),
+	PHY_RD_ERR		= (1 << 28),
+	PHY_PRE_SUP		= (1 << 27),
+	PHY_ADDR		= (1 << 21) | (1 << 22) | (1 << 23)|
+				  	(1 << 24) |(1 << 25),/* 25:21 */
+	PHY_REG_ADDR		= (1 << 16) | (1 << 17) | (1 << 18)|	 			  	   	  	(1 << 19) | (1 << 20),/* 20:16 */
+	PHY_DATA		= (0xF << 0)|(0xF << 4) |(0xF << 8)|
+					(0xF << 12),/* 15:0 */
+
+}PHY_ACCESS_BITS;
+
 
 /* PMAT0			0x190,	 32bit register */
-#define PMR_ACTIVE		B31_MASK
-#define PMR_WR_CMD		B30_MASK
-#define PMR_RD_CMD		B29_MASK
-#define PMR_BANK		B28_MASK
-#define PMR_ADDR		0x007F0000	/* 22:16 */
-#define PMR_B4			0x000000FF	/* 15:0 */
+typedef enum {
+	PMR_ACTIVE		= (1 << 31),
+	PMR_WR_CMD		= (1 << 30),
+	PMR_RD_CMD		= (1 << 29),
+	PMR_BANK		= (1 <<28),
+	PMR_ADDR		= (0xF << 16)|(1 << 20)|(1 << 21)|
+				  	(1 << 22),/* 22:16 */
+	PMR_B4			= (0xF << 0) | (0xF << 4),/* 15:0 */
+}PMAT0_BITS;
+
 
 /* PMAT1			0x194,	 32bit register */
-#define PMR_B3			0xFF000000	/* 31:24 */
-#define PMR_B2			0x00FF0000	/* 23:16 */
-#define PMR_B1			0x0000FF00	/* 15:8 */
-#define PMR_B0			0x000000FF	/* 7:0 */
+typedef enum {
+	PMR_B3			= (0xF << 24) | (0xF <<28),/* 31:24 */
+	PMR_B2			= (0xF << 16) |(0xF << 20),/* 23:16 */
+	PMR_B1			= (0xF << 8) | (0xF <<12), /* 15:8 */
+	PMR_B0			= (0xF << 0)|(0xF << 4),/* 7:0 */
+}PMAT1_BITS;
 
 /************************************************************************/
 /*                                                                      */
@@ -615,7 +566,7 @@ eg., if the value 10011010b is written i
 #define	 PCI_VENDOR_ID_AMD		0x1022
 #define  PCI_DEVICE_ID_AMD8111E_7462	0x7462
 
-#define MAX_UNITS			16 /* Maximum number of devices possible */
+#define MAX_UNITS			8 /* Maximum number of devices possible */
 
 #define NUM_TX_BUFFERS			32 /* Number of transmit buffers */
 #define NUM_RX_BUFFERS			32 /* Number of receive buffers */	
@@ -637,45 +588,73 @@ eg., if the value 10011010b is written i
 #define MIN_PKT_LEN			60
 #define ETH_ADDR_LEN			6
 
+#define  AMD8111E_TX_TIMEOUT		(3 * HZ)/* 3 sec */
+#define SOFT_TIMER_FREQ 		0xBEBC  /* 0.5 sec */
+#define DELAY_TIMER_CONV		50    /* msec to 10 usec conversion.
+						 Only 500 usec resolution */ 						 
 #define OPTION_VLAN_ENABLE		0x0001
 #define OPTION_JUMBO_ENABLE		0x0002
 #define OPTION_MULTICAST_ENABLE		0x0004
 #define OPTION_WOL_ENABLE		0x0008
 #define OPTION_WAKE_MAGIC_ENABLE	0x0010
 #define OPTION_WAKE_PHY_ENABLE		0x0020
+#define OPTION_INTR_COAL_ENABLE		0x0040
+#define OPTION_DYN_IPG_ENABLE	        0x0080
 
 #define PHY_REG_ADDR_MASK		0x1f
 
+/* ipg parameters */
+#define DEFAULT_IPG			0x60
+#define IFS1_DELTA			36
+#define	IPG_CONVERGE_TIME 0.5
+#define	IPG_STABLE_TIME	5
+#define	MIN_IPG	96
+#define	MAX_IPG	255
+#define IPG_STEP	16
+#define CSTATE  1 
+#define SSTATE  2 
+
 /* Assume contoller gets data 10 times the maximum processing time */
 #define  REPEAT_CNT			10; 
      
 /* amd8111e decriptor flag definitions */
+typedef enum {
 
-#define OWN_BIT			B15_MASK
-#define ADD_FCS_BIT		B13_MASK
-#define LTINT_BIT		B12_MASK
-#define STP_BIT			B9_MASK
-#define ENP_BIT			B8_MASK
-#define KILL_BIT		B6_MASK
-#define TCC_MASK		0x0003
-#define TCC_VLAN_INSERT		B1_MASK
-#define TCC_VLAN_REPLACE	0x0003
-#define RESET_RX_FLAGS		0x0000
+	OWN_BIT		=	(1 << 15),
+	ADD_FCS_BIT	=	(1 << 13),
+	LTINT_BIT	=	(1 << 12),
+	STP_BIT		=	(1 << 9),
+	ENP_BIT		=	(1 << 8),
+	KILL_BIT	= 	(1 << 6),
+	TCC_VLAN_INSERT	=	(1 << 1),
+	TCC_VLAN_REPLACE =	(1 << 1) |( 1<< 0),
+
+}TX_FLAG_BITS;
+
+typedef enum {
+	ERR_BIT 	=	(1 << 14),
+	FRAM_BIT	=  	(1 << 13),
+	OFLO_BIT	=       (1 << 12),
+	CRC_BIT		=	(1 << 11),
+	PAM_BIT		=	(1 << 6),
+	LAFM_BIT	= 	(1 << 5),
+	BAM_BIT		=	(1 << 4),
+	TT_VLAN_TAGGED	= 	(1 << 3) |(1 << 2),/* 0x000 */
+	TT_PRTY_TAGGED	=	(1 << 3),/* 0x0008 */
+
+}RX_FLAG_BITS;
 
-#define ERR_BIT 		B14_MASK
-#define FRAM_BIT		B13_MASK
-#define OFLO_BIT		B12_MASK
-#define CRC_BIT			B11_MASK
-#define PAM_BIT			B6_MASK
-#define LAFM_BIT		B5_MASK
-#define BAM_BIT			B4_MASK
+#define RESET_RX_FLAGS		0x0000
 #define TT_MASK			0x000c
-#define TT_VLAN_TAGGED		0x000c
-#define TT_PRTY_TAGGED		0x0008
+#define TCC_MASK		0x0003
 
 /* driver ioctl parameters */
 #define PHY_ID 			0x01	/* currently it is fixed */
-#define AMD8111E_REG_DUMP_LEN	4096	/* Memory mapped register length */
+#define AMD8111E_REG_DUMP_LEN	 13*sizeof(u32) 
+
+/* crc generator constants */
+#define CRC32 0xedb88320
+#define INITCRC 0xFFFFFFFF
 
 /* amd8111e desriptor format */
 
@@ -683,7 +662,7 @@ struct amd8111e_tx_dr{
 
 	u16 buff_count; /* Size of the buffer pointed by this descriptor */
 
-	u16 tx_dr_offset2;
+	u16 tx_flags;
 
 	u16 tag_ctrl_info;
 
@@ -704,7 +683,7 @@ struct amd8111e_rx_dr{
 
 	u16 buff_count;  /* Len of the buffer pointed by descriptor. */
 
-	u16 rx_dr_offset10;
+	u16 rx_flags;
 
 	u32 buff_phy_addr;
 
@@ -719,10 +698,58 @@ struct amd8111e_link_config{
 	u16				speed;
 	u8				duplex;
 	u8				autoneg;
-	u16 				orig_speed;
-	u8				orig_duplex;
 	u8				reserved;  /* 32bit alignment */
 };
+
+enum coal_type{
+
+	NO_COALESCE,
+	LOW_COALESCE,
+	MEDIUM_COALESCE,
+	HIGH_COALESCE,
+
+};
+
+enum coal_mode{ 
+       	RX_INTR_COAL,
+	TX_INTR_COAL,
+	DISABLE_COAL,
+	ENABLE_COAL,
+
+};
+#define MAX_TIMEOUT	40
+#define MAX_EVENT_COUNT 31
+struct amd8111e_coalesce_conf{
+
+	unsigned int rx_timeout;
+	unsigned int rx_event_count;
+	unsigned long rx_packets;
+	unsigned long rx_prev_packets;
+	unsigned long rx_bytes;
+	unsigned long rx_prev_bytes;
+	unsigned int rx_coal_type;
+	
+	unsigned int tx_timeout;
+	unsigned int tx_event_count;
+	unsigned long tx_packets;
+	unsigned long tx_prev_packets;
+	unsigned long tx_bytes;
+	unsigned long tx_prev_bytes;
+	unsigned int tx_coal_type;
+
+};
+struct ipg_info{
+	
+	unsigned int ipg_state;
+	unsigned int ipg;
+	unsigned int current_ipg;
+	unsigned int col_cnt;
+	unsigned int diff_col_cnt;
+	unsigned int timer_tick;
+	unsigned int prev_ipg;
+	struct timer_list ipg_timer;
+};
+
 struct amd8111e_priv{
 	
 	struct amd8111e_tx_dr*  tx_ring;
@@ -742,45 +769,54 @@ struct amd8111e_priv{
 	void *  mmio;
 	
 	spinlock_t lock;	/* Guard lock */
-	unsigned long  rx_idx, tx_idx;	/* The next free ring entry */
-	unsigned long  tx_complete_idx;
+	unsigned long rx_idx, tx_idx;	/* The next free ring entry */
+	unsigned long tx_complete_idx;
 	unsigned long tx_ring_complete_idx;
 	unsigned long tx_ring_idx;
-	int rx_buff_len;	/* Buffer length of rx buffers */
+	unsigned int rx_buff_len;	/* Buffer length of rx buffers */
 	int options;		/* Options enabled/disabled for the device */
+
 	unsigned long ext_phy_option;
+	
 	struct amd8111e_link_config link_config;
 	int pm_cap;
+	u32 pm_state[12];
 
 	struct net_device *next;
+	int mii;
+	struct mii_if_info mii_if;
 #if AMD8111E_VLAN_TAG_USED
 	struct vlan_group		*vlgrp;
 #endif	
 	char opened;
 	struct net_device_stats stats;
-	struct net_device_stats prev_stats;
 	struct dev_mc_list* mc_list;
+	struct amd8111e_coalesce_conf coal_conf;
+
+	struct ipg_info  ipg_data;	
 	
 };
-#define AMD8111E_READ_REG64(_memMapBase, _offset, _pUlData)	\
-			*(u32*)(_pUlData) = readl(_memMapBase + (_offset));	\
-			*((u32*)(_pUlData))+1) = readl(_memMapBase + ((_offset)+4))
-
-#define AMD8111E_WRITE_REG64(_memMapBase, _offset, _pUlData)	\
-			writel(*(u32*)(_pUlData), _memMapBase + (_offset));	\
-			writel(*(u32*)((u8*)(_pUlData)+4), _memMapBase + ((_offset)+4))	\
+
+/* kernel provided writeq does not write 64 bits into the amd8111e device register instead writes only higher 32bits data into lower 32bits of the register.
+BUG? */
+#define  amd8111e_writeq(_UlData,_memMap)   \
+		writel(*(u32*)(&_UlData), _memMap);	\
+		writel(*(u32*)((u8*)(&_UlData)+4), _memMap+4)	
 
 /* maps the external speed options to internal value */
-static unsigned char speed_duplex_mapping[] = {
+typedef enum {
+	SPEED_AUTONEG,
+	SPEED10_HALF,
+	SPEED10_FULL,
+	SPEED100_HALF,
+	SPEED100_FULL,
+}EXT_PHY_OPTION;
 
-	XPHYANE,		/* Auto-negotiation, speed_duplex option 0 */
-	0,			/* 10M Half,  speed_duplex option 1 */
-	XPHYFD,			/* 10M Full,  speed_duplex option 2 */
-	XPHYSP,			/* 100M Half, speed_duplex option 3 */
-	XPHYFD | XPHYSP		/* 100M Full, speed_duplex option 4 */
-};
 static int card_idx;
 static int speed_duplex[MAX_UNITS] = { 0, };
+static int coalesce[MAX_UNITS] = {1,1,1,1,1,1,1,1};
+static int dynamic_ipg[MAX_UNITS] = {0,0,0,0,0,0,0,0};
+static unsigned int chip_version;
 
 #endif /* _AMD8111E_H */
 
diff -urNp linux-2/drivers/net/apne.c linux-3/drivers/net/apne.c
--- linux-2/drivers/net/apne.c	
+++ linux-3/drivers/net/apne.c	
@@ -285,6 +285,7 @@ static int __init apne_probe1(struct net
     /* Allocate dev->priv and fill in 8390 specific dev fields. */
     if (ethdev_init(dev)) {
 	printk (" unable to get memory for dev->priv.\n");
+	free_irq(IRQ_AMIGA_PORTS, dev);
 	return -ENOMEM;
     }
 
diff -urNp linux-2/drivers/net/arcnet/arcnet.c linux-3/drivers/net/arcnet/arcnet.c
--- linux-2/drivers/net/arcnet/arcnet.c	
+++ linux-3/drivers/net/arcnet/arcnet.c	
@@ -343,7 +343,7 @@ void arcdev_setup(struct net_device *dev
 	dev->hard_header_len = sizeof(struct archdr);
 	dev->mtu = choose_mtu();
 
-	dev->addr_len = 1;
+	dev->addr_len = ARCNET_ALEN;
 	dev->tx_queue_len = 30;
 	dev->broadcast[0] = 0x00;	/* for us, broadcasts are address 0 */
 	dev->watchdog_timeo = TX_TIMEOUT;
diff -urNp linux-2/drivers/net/arcnet/rfc1201.c linux-3/drivers/net/arcnet/rfc1201.c
--- linux-2/drivers/net/arcnet/rfc1201.c	
+++ linux-3/drivers/net/arcnet/rfc1201.c	
@@ -56,6 +56,7 @@ struct ArcProto rfc1201_proto =
 void __init arcnet_rfc1201_init(void)
 {
 	arc_proto_map[ARC_P_IP]
+	    = arc_proto_map[ARC_P_IPV6]
 	    = arc_proto_map[ARC_P_ARP]
 	    = arc_proto_map[ARC_P_RARP]
 	    = arc_proto_map[ARC_P_IPX]
@@ -114,6 +115,8 @@ static unsigned short type_trans(struct 
 	switch (soft->proto) {
 	case ARC_P_IP:
 		return htons(ETH_P_IP);
+	case ARC_P_IPV6:
+		return htons(ETH_P_IPV6);
 	case ARC_P_ARP:
 		return htons(ETH_P_ARP);
 	case ARC_P_RARP:
@@ -388,6 +391,9 @@ static int build_header(struct sk_buff *
 	case ETH_P_IP:
 		soft->proto = ARC_P_IP;
 		break;
+	case ETH_P_IPV6:
+		soft->proto = ARC_P_IPV6;
+		break;
 	case ETH_P_ARP:
 		soft->proto = ARC_P_ARP;
 		break;
diff -urNp linux-2/drivers/net/Config.in linux-3/drivers/net/Config.in
--- linux-2/drivers/net/Config.in	
+++ linux-3/drivers/net/Config.in	
@@ -257,6 +257,9 @@ if [ "$CONFIG_ACENIC" != "n" ]; then
 fi
 dep_tristate 'D-Link DL2000-based Gigabit Ethernet support' CONFIG_DL2K $CONFIG_PCI
 dep_tristate 'Intel(R) PRO/1000 Gigabit Ethernet support' CONFIG_E1000 $CONFIG_PCI
+if [ "$CONFIG_E1000" != "n" ]; then
+   bool '  Use Rx Polling (NAPI)' CONFIG_E1000_NAPI
+fi
 dep_tristate 'MyriCOM Gigabit Ethernet support' CONFIG_MYRI_SBUS $CONFIG_SBUS
 dep_tristate 'National Semiconductor DP83820 support' CONFIG_NS83820 $CONFIG_PCI
 dep_tristate 'Packet Engines Hamachi GNIC-II support' CONFIG_HAMACHI $CONFIG_PCI
diff -urNp linux-2/drivers/net/cs89x0.c linux-3/drivers/net/cs89x0.c
--- linux-2/drivers/net/cs89x0.c	
+++ linux-3/drivers/net/cs89x0.c	
@@ -1629,16 +1629,21 @@ static void set_multicast_list(struct ne
 }
 
 
-static int set_mac_address(struct net_device *dev, void *addr)
+static int set_mac_address(struct net_device *dev, void *p)
 {
 	int i;
+	struct sockaddr *addr = p;
+
 
 	if (netif_running(dev))
 		return -EBUSY;
+
+	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+
 	if (net_debug) {
 		printk("%s: Setting MAC address to ", dev->name);
-		for (i = 0; i < 6; i++)
-			printk(" %2.2x", dev->dev_addr[i] = ((unsigned char *)addr)[i]);
+		for (i = 0; i < dev->addr_len; i++)
+			printk(" %2.2x", dev->dev_addr[i]);
 		printk(".\n");
 	}
 	/* set the Ethernet address */
diff -urNp linux-2/drivers/net/dgrs.c linux-3/drivers/net/dgrs.c
--- linux-2/drivers/net/dgrs.c	
+++ linux-3/drivers/net/dgrs.c	
@@ -1279,8 +1279,10 @@ dgrs_found_device(
 	dev->init = dgrs_probe1;
 	SET_MODULE_OWNER(dev);
 	ether_setup(dev);
-	if (register_netdev(dev) != 0)
+	if (register_netdev(dev) != 0) {
+		kfree(dev);
 		return -EIO;
+	}
 
 	priv->next_dev = dgrs_root_dev;
 	dgrs_root_dev = dev;
diff -urNp linux-2/drivers/net/dl2k.h linux-3/drivers/net/dl2k.h
--- linux-2/drivers/net/dl2k.h	
+++ linux-3/drivers/net/dl2k.h	
@@ -243,7 +243,6 @@ enum TFC_bits {
 	VLANTagInsert = 0x0000000010000000,
 	TFDDone = 0x80000000,
 	VIDShift = 32,
-	CFI = 0x0000100000000000,
 	UsePriorityShift = 48,
 };
 
diff -urNp linux-2/drivers/net/e100/e100.h linux-3/drivers/net/e100/e100.h
--- linux-2/drivers/net/e100/e100.h	
+++ linux-3/drivers/net/e100/e100.h	
@@ -60,7 +60,14 @@
 #include <linux/if_vlan.h>
 #include <linux/mii.h>
 
-#define E100_REGS_LEN 1
+#define E100_CABLE_UNKNOWN	0
+#define E100_CABLE_OK		1		
+#define E100_CABLE_OPEN_NEAR	2	/* Open Circuit Near End  */
+#define E100_CABLE_OPEN_FAR	3	/* Open Circuit Far End   */
+#define E100_CABLE_SHORT_NEAR	4	/* Short Circuit Near End */
+#define E100_CABLE_SHORT_FAR	5	/* Short Circuit Far End  */
+
+#define E100_REGS_LEN 2
 /*
  *  Configure parameters for buffers per controller.
  *  If the machine this is being used on is a faster machine (i.e. > 150MHz)
@@ -105,8 +112,6 @@
 #define E100_MAX_CU_IDLE_WAIT	50	/* Max udelays in wait_cus_idle */
 
 /* HWI feature related constant */
-#define HWI_MAX_LOOP                    100
-#define MAX_SAME_RESULTS		3
 #define HWI_REGISTER_GRANULARITY        80	/* register granularity = 80 Cm */
 #define HWI_NEAR_END_BOUNDARY           1000	/* Near end is defined as < 10 meters */
 
@@ -942,7 +947,6 @@ struct e100_private {
 #ifdef CONFIG_PM
 	u32 pci_state[16];
 #endif
-	char ifname[IFNAMSIZ];
 #ifdef E100_CU_DEBUG	
 	u8 last_cmd;
 	u8 last_sub_cmd;
@@ -956,7 +960,10 @@ struct e100_private {
 #define E100_SPEED_100_FULL 4
 
 /********* function prototypes *************/
+extern int e100_open(struct net_device *);
+extern int e100_close(struct net_device *);
 extern void e100_isolate_driver(struct e100_private *bdp);
+extern unsigned char e100_hw_init(struct e100_private *);
 extern void e100_sw_reset(struct e100_private *bdp, u32 reset_cmd);
 extern u8 e100_start_cu(struct e100_private *bdp, tcb_t *tcb);
 extern void e100_free_non_tx_cmd(struct e100_private *bdp,
@@ -981,14 +988,13 @@ extern unsigned char e100_cu_unknown_sta
 #define TEST_TIMEOUT		0x08
 
 enum test_offsets {
-	E100_EEPROM_TEST_FAIL = 0,
-	E100_CHIP_TIMEOUT,
-	E100_ROM_TEST_FAIL,
-	E100_REG_TEST_FAIL,
-	E100_MAC_TEST_FAIL,
-	E100_LPBK_MAC_FAIL,
-	E100_LPBK_PHY_FAIL,
-	E100_MAX_TEST_RES
+	test_link,
+	test_eeprom,
+	test_self_test,
+	test_loopback_mac,
+	test_loopback_phy,
+	cable_diag,
+	max_test_res,  /* must be last */
 };
 
 #endif
diff -urNp linux-2/drivers/net/e100/e100_main.c linux-3/drivers/net/e100/e100_main.c
--- linux-2/drivers/net/e100/e100_main.c	
+++ linux-3/drivers/net/e100/e100_main.c	
@@ -46,6 +46,24 @@
 
 /* Change Log
  * 
+ * 2.3.13       05/08/03
+ * o Feature remove: /proc/net/PRO_LAN_Adapters support gone completely
+ * o Feature remove: IDIAG support (use ethtool -t instead)
+ * o Cleanup: fixed spelling mistakes found by community
+ * o Feature add: ethtool cable diag test
+ * o Feature add: ethtool parameter support (ring size, xsum, flow ctrl)
+ * o Cleanup: move e100_asf_enable under CONFIG_PM to avoid warning
+ *   [Stephen Rothwell (sfr@canb.auug.org.au)]
+ * o Bug fix: don't call any netif_carrier_* until netdev registered.
+ *   [Andrew Morton (akpm@digeo.com)]
+ * o Cleanup: replace (skb->len - skb->data_len) with skb_headlen(skb)
+ *   [jmorris@intercode.com.au]
+ * o Bug fix: cleanup of Tx skbs after running ethtool diags
+ * o Bug fix: incorrect reporting of ethtool diag overall results
+ * o Bug fix: must hold xmit_lock before stopping queue in ethtool
+ *   operations that require reset h/w and driver structures.
+ * o Bug fix: statistic command failure would stop statistic collection.
+ * 
  * 2.2.21	02/11/03
  * o Removed marketing brand strings. Instead, Using generic string 
  *   "Intel(R) PRO/100 Network Connection" for all adapters.
@@ -61,21 +79,6 @@
  * o New feature: added ICH5 support
  * 
  * 2.1.27	11/20/02
- *   o Bug fix: Device command timeout due to SMBus processing during init
- *   o Bug fix: Not setting/clearing I (Interrupt) bit in tcb correctly
- *   o Bug fix: Not using EEPROM WoL setting as default in ethtool
- *   o Bug fix: Not able to set autoneg on using ethtool when interface down
- *   o Bug fix: Not able to change speed/duplex using ethtool/mii
- *     when interface up
- *   o Bug fix: Ethtool shows autoneg on when forced to 100/Full
- *   o Bug fix: Compiler error when CONFIG_PROC_FS not defined
- *   o Bug fix: 2.5.44 e100 doesn't load with preemptive kernel enabled
- *     (sleep while holding spinlock)
- *   o Bug fix: 2.1.24-k1 doesn't display complete statistics
- *   o Bug fix: System panic due to NULL watchdog timer dereference during
- *     ifconfig down, rmmod and insmod
- *
- * 2.1.24       10/7/02
  */
  
 #include <linux/config.h>
@@ -121,14 +124,13 @@ extern void e100_config_wol(struct e100_
 extern u32 e100_run_diag(struct net_device *dev, u64 *test_info, u32 flags);
 static int e100_ethtool_test(struct net_device *, struct ifreq *);
 static int e100_ethtool_gstrings(struct net_device *, struct ifreq *);
-static char *test_strings[] = {
-	"E100_EEPROM_TEST_FAIL",
-	"E100_CHIP_TIMEOUT",
-	"E100_ROM_TEST_FAIL",
-	"E100_REG_TEST_FAIL",
-	"E100_MAC_TEST_FAIL",
-	"E100_LPBK_MAC_FAIL",
-	"E100_LPBK_PHY_FAIL"
+static char test_strings[][ETH_GSTRING_LEN] = {
+	"Link test     (on/offline)",
+	"Eeprom test   (on/offline)",
+	"Self test        (offline)",
+	"Mac loopback     (offline)",
+	"Phy loopback     (offline)",
+	"Cable diagnostic (offline)"
 };
 
 static int e100_ethtool_led_blink(struct net_device *, struct ifreq *);
@@ -139,10 +141,10 @@ static unsigned char e100_delayed_exec_n
 						  nxmit_cb_entry_t *);
 static void e100_free_nontx_list(struct e100_private *);
 static void e100_non_tx_background(unsigned long);
-
+static inline void e100_tx_skb_free(struct e100_private *bdp, tcb_t *tcb);
 /* Global Data structures and variables */
 char e100_copyright[] __devinitdata = "Copyright (c) 2003 Intel Corporation";
-char e100_driver_version[]="2.2.21-k1";
+char e100_driver_version[]="2.3.13-k1";
 const char *e100_full_driver_name = "Intel(R) PRO/100 Network Driver";
 char e100_short_driver_name[] = "e100";
 static int e100nics = 0;
@@ -155,6 +157,7 @@ static void e100_vlan_rx_kill_vid(struct
 static int e100_notify_reboot(struct notifier_block *, unsigned long event, void *ptr);
 static int e100_suspend(struct pci_dev *pcid, u32 state);
 static int e100_resume(struct pci_dev *pcid);
+static unsigned char e100_asf_enabled(struct e100_private *bdp);
 struct notifier_block e100_notifier_reboot = {
         .notifier_call  = e100_notify_reboot,
         .next           = NULL,
@@ -182,8 +185,6 @@ struct notifier_block e100_notifier_rebo
 static u8 e100_D101M_checksum(struct e100_private *, struct sk_buff *);
 static u8 e100_D102_check_checksum(rfd_t *);
 static int e100_ioctl(struct net_device *, struct ifreq *, int);
-static int e100_open(struct net_device *);
-static int e100_close(struct net_device *);
 static int e100_change_mtu(struct net_device *, int);
 static int e100_xmit_frame(struct sk_buff *, struct net_device *);
 static unsigned char e100_init(struct e100_private *);
@@ -193,7 +194,6 @@ struct net_device_stats *e100_get_stats(
 static void e100intr(int, void *, struct pt_regs *);
 static void e100_print_brd_conf(struct e100_private *);
 static void e100_set_multi(struct net_device *);
-void e100_set_speed_duplex(struct e100_private *);
 
 static u8 e100_pci_setup(struct pci_dev *, struct e100_private *);
 static u8 e100_sw_init(struct e100_private *);
@@ -215,7 +215,6 @@ u16 e100_eeprom_calculate_chksum(struct 
 
 static unsigned char e100_clr_cntrs(struct e100_private *);
 static unsigned char e100_load_microcode(struct e100_private *);
-static unsigned char e100_hw_init(struct e100_private *);
 static unsigned char e100_setup_iaaddr(struct e100_private *, u8 *);
 static unsigned char e100_update_stats(struct e100_private *bdp);
 
@@ -228,7 +227,6 @@ static void e100_set_bool_option(struct 
 				 char *);
 unsigned char e100_wait_exec_cmplx(struct e100_private *, u32, u8, u8);
 void e100_exec_cmplx(struct e100_private *, u32, u8);
-static unsigned char e100_asf_enabled(struct e100_private *bdp);
 
 /**
  * e100_get_rx_struct - retrieve cell to hold skb buff from the pool
@@ -638,25 +636,7 @@ e100_found1(struct pci_dev *pcid, const 
 	} else {
 		bdp->rfd_size = 16;
 	}
-	e100_check_options(e100nics, bdp);
-
-	if (!e100_init(bdp)) {
-		printk(KERN_ERR "e100: Failed to initialize, instance #%d\n",
-		       e100nics);
-		rc = -ENODEV;
-		goto err_pci;
-	}
 
-	/* Check if checksum is valid */
-	cal_checksum = e100_eeprom_calculate_chksum(bdp);
-	read_checksum = e100_eeprom_read(bdp, (bdp->eeprom_size - 1));
-	if (cal_checksum != read_checksum) {
-                printk(KERN_ERR "e100: Corrupted EEPROM on instance #%d\n",
-		       e100nics);
-                rc = -ENODEV;
-                goto err_pci;
-	}
-	
 	dev->vlan_rx_register = e100_vlan_rx_register;
 	dev->vlan_rx_add_vid = e100_vlan_rx_add_vid;
 	dev->vlan_rx_kill_vid = e100_vlan_rx_kill_vid;
@@ -674,15 +654,32 @@ e100_found1(struct pci_dev *pcid, const 
 	dev->features = NETIF_F_SG | NETIF_F_HW_CSUM |
 			NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;
 		
-	e100nics++;
-
-	e100_get_speed_duplex_caps(bdp);
-
 	if ((rc = register_netdev(dev)) != 0) {
 		goto err_pci;
 	}
-        memcpy(bdp->ifname, dev->name, IFNAMSIZ);
-        bdp->ifname[IFNAMSIZ-1] = 0;	
+
+	e100_check_options(e100nics, bdp);
+
+	if (!e100_init(bdp)) {
+		printk(KERN_ERR "e100: Failed to initialize, instance #%d\n",
+		       e100nics);
+		rc = -ENODEV;
+		goto err_unregister_netdev;
+	}
+
+	/* Check if checksum is valid */
+	cal_checksum = e100_eeprom_calculate_chksum(bdp);
+	read_checksum = e100_eeprom_read(bdp, (bdp->eeprom_size - 1));
+	if (cal_checksum != read_checksum) {
+                printk(KERN_ERR "e100: Corrupted EEPROM on instance #%d\n",
+		       e100nics);
+                rc = -ENODEV;
+                goto err_unregister_netdev;
+	}
+	
+	e100nics++;
+
+	e100_get_speed_duplex_caps(bdp);
 
 	printk(KERN_NOTICE
 	       "e100: %s: %s\n", 
@@ -708,6 +705,8 @@ e100_found1(struct pci_dev *pcid, const 
 
 	goto out;
 
+err_unregister_netdev:
+	unregister_netdev(dev);
 err_pci:
 	iounmap(bdp->scb);
 	pci_release_regions(pcid);
@@ -973,7 +972,7 @@ e100_set_bool_option(struct e100_private
 	}
 }
 
-static int
+int
 e100_open(struct net_device *dev)
 {
 	struct e100_private *bdp;
@@ -1011,7 +1010,11 @@ e100_open(struct net_device *dev)
 
 	mod_timer(&(bdp->watchdog_timer), jiffies + (2 * HZ));
 
-	netif_start_queue(dev);
+	if (dev->flags & IFF_UP)
+		/* Otherwise process may sleep forever */
+		netif_wake_queue(dev);
+	else
+		netif_start_queue(dev);
 
 	e100_start_ru(bdp);
 	if ((rc = request_irq(dev->irq, &e100intr, SA_SHIRQ,
@@ -1032,7 +1035,7 @@ exit:
 	return rc;
 }
 
-static int
+int
 e100_close(struct net_device *dev)
 {
 	struct e100_private *bdp = dev->priv;
@@ -1073,7 +1076,8 @@ e100_xmit_frame(struct sk_buff *skb, str
 		goto exit2;
 	}
 
-	if (!TCBS_AVAIL(bdp->tcb_pool) ||
+	/* tcb list may be empty temporarily during releasing resources */
+	if (!TCBS_AVAIL(bdp->tcb_pool) || (bdp->tcb_phys == 0) ||
 	    (bdp->non_tx_command_state != E100_NON_TX_IDLE)) {
 		notify_stop = true;
 		rc = 1;
@@ -1284,10 +1288,8 @@ e100_init(struct e100_private *bdp)
 	/* read NIC's part number */
 	e100_rd_pwa_no(bdp);
 
-	if (!e100_hw_init(bdp)) {
-		printk(KERN_ERR "e100: hw init failed\n");
+	if (!e100_hw_init(bdp))
 		return false;
-	}
 	/* Interrupts are enabled after device reset */
 	e100_disable_clear_intr(bdp);
 
@@ -1329,6 +1331,8 @@ e100_sw_init(struct e100_private *bdp)
 	spin_lock_init(&(bdp->bd_non_tx_lock));
 	spin_lock_init(&(bdp->config_lock));
 	spin_lock_init(&(bdp->mdi_access_lock));
+	/* Initialize configuration data */
+	e100_config_init(bdp);
 
 	return 1;
 }
@@ -1383,11 +1387,11 @@ e100_tco_workaround(struct e100_private 
  *      true - If the adapter was initialized
  *      false - If the adapter failed initialization
  */
-unsigned char __devinit
+unsigned char
 e100_hw_init(struct e100_private *bdp)
 {
 	if (!e100_phy_init(bdp))
-		return false;
+		goto err;
 
 	e100_sw_reset(bdp, PORT_SELECTIVE_RESET);
 
@@ -1397,27 +1401,25 @@ e100_hw_init(struct e100_private *bdp)
 
 	/* Load the CU BASE (set to 0, because we use linear mode) */
 	if (!e100_wait_exec_cmplx(bdp, 0, SCB_CUC_LOAD_BASE, 0))
-		return false;
+		goto err;
 
 	if (!e100_wait_exec_cmplx(bdp, 0, SCB_RUC_LOAD_BASE, 0))
-		return false;
+		goto err;
 
 	/* Load interrupt microcode  */
 	if (e100_load_microcode(bdp)) {
 		bdp->flags |= DF_UCODE_LOADED;
 	}
 
-	e100_config_init(bdp);
-	if (!e100_config(bdp)) {
-		return false;
-	}
+	if (!e100_config(bdp))
+		goto err;
 
 	if (!e100_setup_iaaddr(bdp, bdp->device->dev_addr))
-		return false;
+		goto err;
 
 	/* Clear the internal counters */
 	if (!e100_clr_cntrs(bdp))
-		return false;
+		goto err;
 
 	/* Change for 82558 enhancement */
 	/* If 82558/9 and if the user has enabled flow control, set up the
@@ -1430,6 +1432,9 @@ e100_hw_init(struct e100_private *bdp)
 	}
 
 	return true;
+err:
+	printk(KERN_ERR "e100: hw init failed\n");
+	return false;
 }
 
 /**
@@ -1590,9 +1595,22 @@ e100_alloc_tcb_pool(struct e100_private 
 void
 e100_free_tcb_pool(struct e100_private *bdp)
 {
+	tcb_t *tcb;
+	int i;
+	/* Return tx skbs */ 
+	for (i = 0; i < bdp->params.TxDescriptors; i++) {
+	  	tcb = bdp->tcb_pool.data;
+		tcb += bdp->tcb_pool.head;
+  		e100_tx_skb_free(bdp, tcb);
+		if (NEXT_TCB_TOUSE(bdp->tcb_pool.head) == bdp->tcb_pool.tail)
+		  	break;
+		bdp->tcb_pool.head = NEXT_TCB_TOUSE(bdp->tcb_pool.head);
+	}
 	pci_free_consistent(bdp->pdev,
 			    sizeof (tcb_t) * bdp->params.TxDescriptors,
 			    bdp->tcb_pool.data, bdp->tcb_phys);
+	bdp->tcb_pool.head = 0;
+	bdp->tcb_pool.tail = 1;	
 	bdp->tcb_phys = 0;
 }
 
@@ -1746,12 +1764,10 @@ e100_watchdog(struct net_device *dev)
 				e100_set_multi(dev);
 			}
 		}
-
-		/* Update the statistics needed by the upper interface */
-		/* This should be the last statistic related command
-		 * as it's async. now */
-		e100_dump_stats_cntrs(bdp);
 	}
+	/* Issue command to dump statistics from device.        */
+	/* Check for command completion on next watchdog timer. */
+	e100_dump_stats_cntrs(bdp);
 
 	wmb();
 
@@ -2199,10 +2215,10 @@ e100_prepare_xmit_buff(struct e100_priva
 
 		(tcb->tbd_ptr)->tbd_buf_addr =
 			cpu_to_le32(pci_map_single(bdp->pdev, skb->data,
-						   (skb->len - skb->data_len),
+						   skb_headlen(skb),
 						   PCI_DMA_TODEVICE));
 		(tcb->tbd_ptr)->tbd_buf_cnt =
-			cpu_to_le16(skb->len - skb->data_len);
+			cpu_to_le16(skb_headlen(skb));
 
 		for (i = 0; i < skb_shinfo(skb)->nr_frags;
 		     i++, tbd_arr_ptr++, frag++) {
@@ -2542,6 +2558,7 @@ e100_update_stats(struct e100_private *b
 	pcmd_complete = e100_cmd_complete_location(bdp);
 	if (*pcmd_complete != le32_to_cpu(DUMP_RST_STAT_COMPLETED) &&
 	    *pcmd_complete != le32_to_cpu(DUMP_STAT_COMPLETED)) {
+		*pcmd_complete = 0;
 		return false;
 	}
 
@@ -3039,23 +3056,6 @@ e100_isolate_driver(struct e100_private 
 	e100_sw_reset(bdp, PORT_SELECTIVE_RESET);
 }
 
-void
-e100_set_speed_duplex(struct e100_private *bdp)
-{
-	int carrier_ok;
-	/* Device may lose link with some siwtches when */
-	/* changing speed/duplex to non-autoneg. e100   */
-	/* needs to remember carrier state in order to  */
-	/* start watchdog timer for recovering link     */
-	if ((carrier_ok = netif_carrier_ok(bdp->device)))
-		e100_isolate_driver(bdp);
-	e100_phy_set_speed_duplex(bdp, true);
-	e100_config_fc(bdp);	/* re-config flow-control if necessary */
-	e100_config(bdp);	
-	if (carrier_ok)
-		e100_deisolate_driver(bdp, false);
-}
-
 static void
 e100_tcb_add_C_bit(struct e100_private *bdp)
 {
@@ -3211,6 +3211,144 @@ e100_do_ethtool_ioctl(struct net_device 
 	case ETHTOOL_PHYS_ID:
 		rc = e100_ethtool_led_blink(dev,ifr);
 		break;
+#ifdef	ETHTOOL_GRINGPARAM
+	case ETHTOOL_GRINGPARAM: {
+		struct ethtool_ringparam ering;
+		struct e100_private *bdp = dev->priv;
+		memset((void *) &ering, 0, sizeof(ering));
+		ering.rx_max_pending = E100_MAX_RFD;
+		ering.tx_max_pending = E100_MAX_TCB;
+		ering.rx_pending = bdp->params.RxDescriptors;
+		ering.tx_pending = bdp->params.TxDescriptors;
+		rc = copy_to_user(ifr->ifr_data, &ering, sizeof(ering))
+			? -EFAULT : 0;
+		return rc;
+	}
+#endif
+#ifdef	ETHTOOL_SRINGPARAM
+	case ETHTOOL_SRINGPARAM: {
+		struct ethtool_ringparam ering;
+		struct e100_private *bdp = dev->priv;
+		if (copy_from_user(&ering, ifr->ifr_data, sizeof(ering)))
+			return -EFAULT;
+		if (ering.rx_pending > E100_MAX_RFD 
+		    || ering.rx_pending < E100_MIN_RFD)
+			return -EINVAL;
+		if (ering.tx_pending > E100_MAX_TCB 
+		    || ering.tx_pending < E100_MIN_TCB)
+			return -EINVAL;
+		if (netif_running(dev)) {
+			spin_lock_bh(&dev->xmit_lock);
+			e100_close(dev);
+			spin_unlock_bh(&dev->xmit_lock);
+			/* Use new values to open interface */
+			bdp->params.RxDescriptors = ering.rx_pending;
+			bdp->params.TxDescriptors = ering.tx_pending;
+			e100_hw_init(bdp);
+			e100_open(dev);
+		}
+		else {
+			bdp->params.RxDescriptors = ering.rx_pending;
+			bdp->params.TxDescriptors = ering.tx_pending;
+		}
+		return 0;
+	}
+#endif
+#ifdef	ETHTOOL_GPAUSEPARAM
+	case ETHTOOL_GPAUSEPARAM: {
+		struct ethtool_pauseparam epause;
+		struct e100_private *bdp = dev->priv;
+		memset((void *) &epause, 0, sizeof(epause));
+		if ((bdp->flags & IS_BACHELOR)
+		    && (bdp->params.b_params & PRM_FC)) {
+			epause.autoneg = 1;
+			if (bdp->flags && DF_LINK_FC_CAP) {
+				epause.rx_pause = 1;
+				epause.tx_pause = 1;
+			}
+			if (bdp->flags && DF_LINK_FC_TX_ONLY)
+				epause.tx_pause = 1;
+		}
+		rc = copy_to_user(ifr->ifr_data, &epause, sizeof(epause))
+			? -EFAULT : 0;
+		return rc;
+	}
+#endif
+#ifdef	ETHTOOL_SPAUSEPARAM
+	case ETHTOOL_SPAUSEPARAM: {
+		struct ethtool_pauseparam epause;
+		struct e100_private *bdp = dev->priv;
+		if (!(bdp->flags & IS_BACHELOR))
+			return -EINVAL;
+		if (copy_from_user(&epause, ifr->ifr_data, sizeof(epause)))
+			return -EFAULT;
+		if (epause.autoneg == 1)
+			bdp->params.b_params |= PRM_FC;
+		else
+			bdp->params.b_params &= ~PRM_FC;
+		if (netif_running(dev)) {
+			spin_lock_bh(&dev->xmit_lock);
+			e100_close(dev);
+			spin_unlock_bh(&dev->xmit_lock);
+			e100_hw_init(bdp);
+			e100_open(dev);
+		}
+		return 0;
+	}
+#endif
+#ifdef	ETHTOOL_GRXCSUM
+	case ETHTOOL_GRXCSUM:
+	case ETHTOOL_GTXCSUM:
+	case ETHTOOL_GSG:
+	{	struct ethtool_value eval;
+		struct e100_private *bdp = dev->priv;
+		memset((void *) &eval, 0, sizeof(eval));
+		if ((ecmd.cmd == ETHTOOL_GRXCSUM) 
+		    && (bdp->params.b_params & PRM_XSUMRX))
+			eval.data = 1;
+		else
+			eval.data = 0;
+		rc = copy_to_user(ifr->ifr_data, &eval, sizeof(eval))
+			? -EFAULT : 0;
+		return rc;
+	}
+#endif
+#ifdef	ETHTOOL_SRXCSUM
+	case ETHTOOL_SRXCSUM:
+	case ETHTOOL_STXCSUM:
+	case ETHTOOL_SSG:
+	{	struct ethtool_value eval;
+		struct e100_private *bdp = dev->priv;
+		if (copy_from_user(&eval, ifr->ifr_data, sizeof(eval)))
+			return -EFAULT;
+		if (ecmd.cmd == ETHTOOL_SRXCSUM) {
+			if (eval.data == 1) { 
+				if (bdp->rev_id >= D101MA_REV_ID)
+					bdp->params.b_params |= PRM_XSUMRX;
+				else
+					return -EINVAL;
+			} else {
+				if (bdp->rev_id >= D101MA_REV_ID)
+					bdp->params.b_params &= ~PRM_XSUMRX;
+				else
+					return 0;
+			}
+		} else {
+			if (eval.data == 1)
+				return -EINVAL;
+			else
+				return 0;
+		}
+		if (netif_running(dev)) {
+			spin_lock_bh(&dev->xmit_lock);
+			e100_close(dev);
+			spin_unlock_bh(&dev->xmit_lock);
+			e100_hw_init(bdp);
+			e100_open(dev);
+		}
+		return 0;
+	}
+#endif
 	default:
 		break;
 	}			//switch
@@ -3284,10 +3422,6 @@ e100_ethtool_set_settings(struct net_dev
 	int ethtool_new_speed_duplex;
 	struct ethtool_cmd ecmd;
 
-	if (!capable(CAP_NET_ADMIN)) {
-		return -EPERM;
-	}
-
 	bdp = dev->priv;
 	if (copy_from_user(&ecmd, ifr->ifr_data, sizeof (ecmd))) {
 		return -EFAULT;
@@ -3296,7 +3430,13 @@ e100_ethtool_set_settings(struct net_dev
 	if ((ecmd.autoneg == AUTONEG_ENABLE)
 	    && (bdp->speed_duplex_caps & SUPPORTED_Autoneg)) {
 		bdp->params.e100_speed_duplex = E100_AUTONEG;
-		e100_set_speed_duplex(bdp);
+		if (netif_running(dev)) {
+			spin_lock_bh(&dev->xmit_lock);
+			e100_close(dev);
+			spin_unlock_bh(&dev->xmit_lock);
+			e100_hw_init(bdp);
+			e100_open(dev);
+		}
 	} else {
 		if (ecmd.speed == SPEED_10) {
 			if (ecmd.duplex == DUPLEX_HALF) {
@@ -3327,7 +3467,13 @@ e100_ethtool_set_settings(struct net_dev
 		if (bdp->speed_duplex_caps & ethtool_new_speed_duplex) {
 			bdp->params.e100_speed_duplex =
 				e100_new_speed_duplex;
-			e100_set_speed_duplex(bdp);
+			if (netif_running(dev)) {
+				spin_lock_bh(&dev->xmit_lock);
+				e100_close(dev);
+				spin_unlock_bh(&dev->xmit_lock);
+				e100_hw_init(bdp);
+				e100_open(dev);
+			}
 		} else {
 			return -EOPNOTSUPP;
 		} 
@@ -3362,14 +3508,14 @@ e100_ethtool_test(struct net_device *dev
 	struct ethtool_test *info;
 	int rc = -EFAULT;
 
-	info = kmalloc(sizeof(*info) + E100_MAX_TEST_RES * sizeof(u64),
+	info = kmalloc(sizeof(*info) + max_test_res * sizeof(u64),
 		       GFP_ATOMIC);
 
 	if (!info)
 		return -ENOMEM;
 
 	memset((void *) info, 0, sizeof(*info) +
-				 E100_MAX_TEST_RES * sizeof(u64));
+				 max_test_res * sizeof(u64));
 
 	if (copy_from_user(info, ifr->ifr_data, sizeof(*info)))
 		goto exit;
@@ -3377,7 +3523,7 @@ e100_ethtool_test(struct net_device *dev
 	info->flags = e100_run_diag(dev, info->data, info->flags);
 
 	if (!copy_to_user(ifr->ifr_data, info,
-			 sizeof(*info) + E100_MAX_TEST_RES * sizeof(u64)))
+			 sizeof(*info) + max_test_res * sizeof(u64)))
 		rc = 0;
 exit:
 	kfree(info);
@@ -3391,9 +3537,8 @@ e100_ethtool_gregs(struct net_device *de
 	u32 regs_buff[E100_REGS_LEN];
 	struct ethtool_regs regs = {ETHTOOL_GREGS};
 	void *addr = ifr->ifr_data;
+	u16 mdi_reg;
 
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
 	bdp = dev->priv;
 
 	if(copy_from_user(&regs, addr, sizeof(regs)))
@@ -3403,6 +3548,8 @@ e100_ethtool_gregs(struct net_device *de
 	regs_buff[0] = readb(&(bdp->scb->scb_cmd_hi)) << 24 |
 		readb(&(bdp->scb->scb_cmd_low)) << 16 |
 		readw(&(bdp->scb->scb_status));
+	e100_mdi_read(bdp, MII_NCONFIG, bdp->phy_addr, &mdi_reg);
+	regs_buff[1] = mdi_reg;
 
 	if(copy_to_user(addr, &regs, sizeof(regs)))
 		return -EFAULT;
@@ -3419,14 +3566,17 @@ e100_ethtool_nway_rst(struct net_device 
 {
 	struct e100_private *bdp;
 
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
 	bdp = dev->priv;
 
 	if ((bdp->speed_duplex_caps & SUPPORTED_Autoneg) &&
 	    (bdp->params.e100_speed_duplex == E100_AUTONEG)) {
-		e100_set_speed_duplex(bdp);
+		if (netif_running(dev)) {
+			spin_lock_bh(&dev->xmit_lock);
+			e100_close(dev);
+			spin_unlock_bh(&dev->xmit_lock);
+			e100_hw_init(bdp);
+			e100_open(dev);
+		}
 	} else {
 		return -EFAULT;
 	}
@@ -3452,7 +3602,7 @@ e100_ethtool_get_drvinfo(struct net_devi
 	info.n_stats = E100_STATS_LEN;
 	info.regdump_len  = E100_REGS_LEN * sizeof(u32);
 	info.eedump_len = (bdp->eeprom_size << 1);	
-	info.testinfo_len = E100_MAX_TEST_RES;
+	info.testinfo_len = max_test_res;
 	if (copy_to_user(ifr->ifr_data, &info, sizeof (info)))
 		return -EFAULT;
 
@@ -3471,9 +3621,6 @@ e100_ethtool_eeprom(struct net_device *d
 	void *ptr;
 	u8 *eeprom_data_bytes = (u8 *)eeprom_data;
 
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
 	bdp = dev->priv;
 
 	if (copy_from_user(&ecmd, ifr->ifr_data, sizeof (ecmd)))
@@ -3751,9 +3898,6 @@ e100_ethtool_wol(struct net_device *dev,
 	struct ethtool_wolinfo wolinfo;
 	int res = 0;
 
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
 	bdp = dev->priv;
 
 	if (copy_from_user(&wolinfo, ifr->ifr_data, sizeof (wolinfo))) {
@@ -3802,15 +3946,15 @@ static int e100_ethtool_gstrings(struct 
 	switch (info.string_set) {
 	case ETH_SS_TEST: {
 		int ret = 0;
-		if (info.len > E100_MAX_TEST_RES)
-			info.len = E100_MAX_TEST_RES;
+		if (info.len > max_test_res)
+			info.len = max_test_res;
 		strings = kmalloc(info.len * ETH_GSTRING_LEN, GFP_ATOMIC);
 		if (!strings)
 			return -ENOMEM;
 		memset(strings, 0, info.len * ETH_GSTRING_LEN);
 
 		for (i = 0; i < info.len; i++) {
-			sprintf(strings + i * ETH_GSTRING_LEN, "%-31s",
+			sprintf(strings + i * ETH_GSTRING_LEN, "%s",
 				test_strings[i]);
 		}
 		if (copy_to_user(ifr->ifr_data, &info, sizeof (info)))
@@ -3879,7 +4023,13 @@ e100_mii_ioctl(struct net_device *dev, s
 					bdp->params.e100_speed_duplex = E100_SPEED_10_FULL;
 				else
 					bdp->params.e100_speed_duplex = E100_SPEED_10_HALF;
-				e100_set_speed_duplex(bdp);
+				if (netif_running(dev)) {
+					spin_lock_bh(&dev->xmit_lock);
+					e100_close(dev);
+					spin_unlock_bh(&dev->xmit_lock);
+					e100_hw_init(bdp);
+					e100_open(dev);
+				}
 		}
 		else 
 			/* Only allows changing speed/duplex */
@@ -4162,7 +4312,6 @@ e100_resume(struct pci_dev *pcid)
 
 	return 0;
 }
-#endif /* CONFIG_PM */
 
 /**
  * e100_asf_enabled - checks if ASF is configured on the current adaper
@@ -4188,6 +4337,7 @@ e100_asf_enabled(struct e100_private *bd
 	}
 	return false;
 }
+#endif /* CONFIG_PM */
 
 #ifdef E100_CU_DEBUG
 unsigned char
diff -urNp linux-2/drivers/net/e100/e100_phy.c linux-3/drivers/net/e100/e100_phy.c
--- linux-2/drivers/net/e100/e100_phy.c	
+++ linux-3/drivers/net/e100/e100_phy.c	
@@ -628,8 +628,6 @@ e100_force_speed_duplex(struct e100_priv
 	u16 control;
 	unsigned long expires;
 
-	e100_phy_reset(bdp);
-
 	bdp->flags |= DF_SPEED_FORCED;
 
 	e100_mdi_read(bdp, MII_BMCR, bdp->phy_addr, &control);
@@ -912,6 +910,10 @@ e100_phy_reset(struct e100_private *bdp)
 	u16 ctrl_reg;
 	ctrl_reg = BMCR_RESET;
 	e100_mdi_write(bdp, MII_BMCR, bdp->phy_addr, ctrl_reg);
+	/* ieee 802.3 : The reset process shall be completed       */
+	/* within 0.5 seconds from the settting of PHY reset bit.  */
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(HZ / 2);
 }
 
 unsigned char __devinit
@@ -928,6 +930,7 @@ e100_phy_init(struct e100_private *bdp)
 	bdp->PhyDelay = 0;
 	bdp->zlock_state = ZLOCK_INITIAL;
 
+	e100_phy_reset(bdp);
 	e100_phy_set_speed_duplex(bdp, false);
 	e100_fix_polarity(bdp);
 
diff -urNp linux-2/drivers/net/e100/e100_test.c linux-3/drivers/net/e100/e100_test.c
--- linux-2/drivers/net/e100/e100_test.c	
+++ linux-3/drivers/net/e100/e100_test.c	
@@ -25,7 +25,7 @@
   Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
 *******************************************************************************/
 
-#include "e100.h"
+#include "e100_phy.h"
 #include "e100_config.h"
 
 extern u16 e100_eeprom_read(struct e100_private *, u16);
@@ -46,6 +46,7 @@ static u8 e100_diag_loopback_alloc(struc
 static void e100_diag_loopback_cu_ru_exec(struct e100_private *);
 static u8 e100_diag_check_pkt(u8 *);
 static void e100_diag_loopback_free(struct e100_private *);
+static int e100_cable_diag(struct e100_private *bdp);
 
 #define LB_PACKET_SIZE 1500
 
@@ -60,46 +61,52 @@ u32
 e100_run_diag(struct net_device *dev, u64 *test_info, u32 flags)
 {
 	struct e100_private* bdp = dev->priv;
-	u8 test_result = true;
-
-	e100_isolate_driver(bdp);
+	u8 test_result = 0;
 
+	if (!e100_get_link_state(bdp)) {
+		test_result = ETH_TEST_FL_FAILED;
+		test_info[test_link] = true;
+	}
+	if (!e100_diag_eeprom(dev)) {
+		test_result = ETH_TEST_FL_FAILED;
+		test_info[test_eeprom] = true;
+	}
 	if (flags & ETH_TEST_FL_OFFLINE) {
 		u8 fail_mask;
-		
-		fail_mask = e100_diag_selftest(dev);
-		if (fail_mask) {
-			test_result = false;
-			if (fail_mask & REGISTER_TEST_FAIL)
-				test_info [E100_REG_TEST_FAIL] = true;
-			if (fail_mask & ROM_TEST_FAIL)
-				test_info [E100_ROM_TEST_FAIL] = true;
-			if (fail_mask & SELF_TEST_FAIL)
-				test_info [E100_MAC_TEST_FAIL] = true;
-			if (fail_mask & TEST_TIMEOUT)
-				test_info [E100_CHIP_TIMEOUT] = true;
+		if (netif_running(dev)) {
+			spin_lock_bh(&dev->xmit_lock);
+			e100_close(dev);
+			spin_unlock_bh(&dev->xmit_lock);
+		}
+		if (e100_diag_selftest(dev)) {
+			test_result = ETH_TEST_FL_FAILED;
+			test_info[test_self_test] = true;
 		}
 
 		fail_mask = e100_diag_loopback(dev);
 		if (fail_mask) {
-			test_result = false;
+			test_result = ETH_TEST_FL_FAILED;
 			if (fail_mask & PHY_LOOPBACK)
-				test_info [E100_LPBK_PHY_FAIL] = true;
+				test_info[test_loopback_phy] = true;
 			if (fail_mask & MAC_LOOPBACK)
-				test_info [E100_LPBK_MAC_FAIL] = true;
+				test_info[test_loopback_mac] = true;
 		}
-	}
 
-	if (!e100_diag_eeprom(dev)) {
-		test_result = false;
-		test_info [E100_EEPROM_TEST_FAIL] = true;
+		test_info[cable_diag] = e100_cable_diag(bdp);
+		/* Need hw init regardless of netif_running */
+		e100_hw_init(bdp);
+		if (netif_running(dev)) {
+			e100_open(dev);
+		}
+	}
+	else {
+		test_info[test_self_test] = false;
+		test_info[test_loopback_phy] = false;
+		test_info[test_loopback_mac] = false;
+		test_info[cable_diag] = false;
 	}
 
-	set_current_state(TASK_UNINTERRUPTIBLE);
-	schedule_timeout(HZ * 2);
-    	e100_deisolate_driver(bdp, false);
-
-	return flags | (test_result ? 0 : ETH_TEST_FL_FAILED);
+	return flags | test_result;
 }
 
 /**
@@ -126,8 +133,6 @@ e100_diag_selftest(struct net_device *de
 		}
 	}
 
-	e100_configure_device(bdp);
-
 	return retval;
 }
 
@@ -165,14 +170,14 @@ e100_diag_loopback (struct net_device *d
 	u8 rc = 0;
 
 	printk(KERN_DEBUG "%s: PHY loopback test starts\n", dev->name);
-	e100_sw_reset(dev->priv, PORT_SELECTIVE_RESET);
+	e100_hw_init(dev->priv);
 	if (!e100_diag_one_loopback(dev, PHY_LOOPBACK)) {
 		rc |= PHY_LOOPBACK;
 	}
 	printk(KERN_DEBUG "%s: PHY loopback test ends\n", dev->name);
 
 	printk(KERN_DEBUG "%s: MAC loopback test starts\n", dev->name);
-	e100_sw_reset(dev->priv, PORT_SELECTIVE_RESET);
+	e100_hw_init(dev->priv);
 	if (!e100_diag_one_loopback(dev, MAC_LOOPBACK)) {
 		rc |= MAC_LOOPBACK;
 	}
@@ -257,15 +262,10 @@ e100_diag_config_loopback(struct e100_pr
 		if (set_loopback)
                         /* Set PHY loopback mode */
                         e100_phy_set_loopback(bdp);
-                else {	/* Back to normal speed and duplex */
-                	if (bdp->params.e100_speed_duplex == E100_AUTONEG)
-				/* Reset PHY and do autoneg */
-                        	e100_phy_autoneg(bdp);
-			else    
-				/* Reset PHY and force speed and duplex */
-				e100_force_speed_duplex(bdp);
-		}
-                /* Wait for PHY state change */
+		else
+			/* Reset PHY loopback mode */
+			e100_phy_reset(bdp);	
+		/* Wait for PHY state change */
 		set_current_state(TASK_UNINTERRUPTIBLE);
                 schedule_timeout(HZ);
 	} else { /* For MAC loopback wait 500 msec to take effect */
@@ -348,10 +348,6 @@ static void
 e100_diag_loopback_cu_ru_exec(struct e100_private *bdp)
 {
 	/*load CU & RU base */ 
-	if (!e100_wait_exec_cmplx(bdp, 0, SCB_CUC_LOAD_BASE, 0))
-		printk(KERN_ERR "e100: SCB_CUC_LOAD_BASE failed\n");
-	if(!e100_wait_exec_cmplx(bdp, 0, SCB_RUC_LOAD_BASE, 0))
-		printk(KERN_ERR "e100: SCB_RUC_LOAD_BASE failed!\n");
 	if(!e100_wait_exec_cmplx(bdp, bdp->loopback.dma_handle, SCB_RUC_START, 0))
 		printk(KERN_ERR "e100: SCB_RUC_START failed!\n");
 
@@ -433,3 +429,72 @@ e100_diag_loopback_free (struct e100_pri
 			    bdp->loopback.dma_handle);
 }
 
+static int
+e100_cable_diag(struct e100_private *bdp)
+{	
+	int saved_open_circut = 0xffff;
+	int saved_short_circut = 0xffff;
+	int saved_distance = 0xffff;
+	int saved_same = 0;
+	int cable_status = E100_CABLE_UNKNOWN;
+	int i;
+	
+	/* If we have link, */	
+	if (e100_get_link_state(bdp))
+		return E100_CABLE_OK;
+	
+	if (bdp->rev_id < D102_REV_ID)
+		return E100_CABLE_UNKNOWN;
+
+	/* Disable MDI/MDI-X auto switching */
+        e100_mdi_write(bdp, MII_NCONFIG, bdp->phy_addr,
+		MDI_MDIX_RESET_ALL_MASK);
+	/* Set to 100 Full as required by cable test */
+	e100_mdi_write(bdp, MII_BMCR, bdp->phy_addr,
+		BMCR_SPEED100 | BMCR_FULLDPLX);
+
+	/* Test up to 100 times */
+	for (i = 0; i < 100; i++) {
+		u16 ctrl_reg;
+		int distance, open_circut, short_circut, near_end;
+
+		/* Enable and execute cable test */
+		e100_mdi_write(bdp, HWI_CONTROL_REG, bdp->phy_addr,
+			(HWI_TEST_ENABLE | HWI_TEST_EXECUTE));
+		/* Wait for cable test finished */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HZ/100 + 1);
+		/* Read results */
+		e100_mdi_read(bdp, HWI_CONTROL_REG, bdp->phy_addr, &ctrl_reg);
+		distance = ctrl_reg & HWI_TEST_DISTANCE;
+		open_circut = ctrl_reg & HWI_TEST_HIGHZ_PROBLEM;
+		short_circut = ctrl_reg & HWI_TEST_LOWZ_PROBLEM;
+
+		if ((distance == saved_distance) &&
+	    	    (open_circut == saved_open_circut) &&
+	    	    (short_circut == saved_short_circut)) 
+			saved_same++;
+		else {
+			saved_same = 0;
+			saved_distance = distance;
+			saved_open_circut = open_circut;
+			saved_short_circut = short_circut;
+		}
+		/* If results are the same 3 times */
+		if (saved_same == 3) {
+			near_end = ((distance * HWI_REGISTER_GRANULARITY) <
+			       HWI_NEAR_END_BOUNDARY);
+			if (open_circut)
+				cable_status = (near_end) ? 
+					E100_CABLE_OPEN_NEAR : E100_CABLE_OPEN_FAR;
+			if (short_circut)
+				cable_status = (near_end) ?
+					E100_CABLE_SHORT_NEAR : E100_CABLE_SHORT_FAR;
+			break;
+		}
+	}
+	/* Reset cable test */
+        e100_mdi_write(bdp, HWI_CONTROL_REG, bdp->phy_addr,					       HWI_RESET_ALL_MASK);
+	return cable_status;
+}
+
diff -urNp linux-2/drivers/net/e1000/e1000_ethtool.c linux-3/drivers/net/e1000/e1000_ethtool.c
--- linux-2/drivers/net/e1000/e1000_ethtool.c	
+++ linux-3/drivers/net/e1000/e1000_ethtool.c	
@@ -40,15 +40,60 @@ extern void e1000_down(struct e1000_adap
 extern void e1000_reset(struct e1000_adapter *adapter);
 extern int e1000_set_spd_dplx(struct e1000_adapter *adapter, uint16_t spddplx);
 
-static char e1000_gstrings_stats[][ETH_GSTRING_LEN] = {
-	"rx_packets", "tx_packets", "rx_bytes", "tx_bytes", "rx_errors",
-	"tx_errors", "rx_dropped", "tx_dropped", "multicast", "collisions",
-	"rx_length_errors", "rx_over_errors", "rx_crc_errors",
-	"rx_frame_errors", "rx_fifo_errors", "rx_missed_errors",
-	"tx_aborted_errors", "tx_carrier_errors", "tx_fifo_errors",
-	"tx_heartbeat_errors", "tx_window_errors",
+struct e1000_stats {
+	char stat_string[ETH_GSTRING_LEN];
+	int sizeof_stat;
+	int stat_offset;
 };
-#define E1000_STATS_LEN	sizeof(e1000_gstrings_stats) / ETH_GSTRING_LEN
+
+#define E1000_STAT(m) sizeof(((struct e1000_adapter *)0)->m), \
+		      offsetof(struct e1000_adapter, m)
+static struct e1000_stats e1000_gstrings_stats[] = {
+	{ "rx_packets", E1000_STAT(net_stats.rx_packets) },
+	{ "tx_packets", E1000_STAT(net_stats.tx_packets) },
+	{ "rx_bytes", E1000_STAT(net_stats.rx_bytes) },
+	{ "tx_bytes", E1000_STAT(net_stats.tx_bytes) },
+	{ "rx_errors", E1000_STAT(net_stats.rx_errors) },
+	{ "tx_errors", E1000_STAT(net_stats.tx_errors) },
+	{ "rx_dropped", E1000_STAT(net_stats.rx_dropped) },
+	{ "tx_dropped", E1000_STAT(net_stats.tx_dropped) },
+	{ "multicast", E1000_STAT(net_stats.multicast) },
+	{ "collisions", E1000_STAT(net_stats.collisions) },
+	{ "rx_length_errors", E1000_STAT(net_stats.rx_length_errors) },
+	{ "rx_over_errors", E1000_STAT(net_stats.rx_over_errors) },
+	{ "rx_crc_errors", E1000_STAT(net_stats.rx_crc_errors) },
+	{ "rx_frame_errors", E1000_STAT(net_stats.rx_frame_errors) },
+	{ "rx_fifo_errors", E1000_STAT(net_stats.rx_fifo_errors) },
+	{ "rx_missed_errors", E1000_STAT(net_stats.rx_missed_errors) },
+	{ "tx_aborted_errors", E1000_STAT(net_stats.tx_aborted_errors) },
+	{ "tx_carrier_errors", E1000_STAT(net_stats.tx_carrier_errors) },
+	{ "tx_fifo_errors", E1000_STAT(net_stats.tx_fifo_errors) },
+	{ "tx_heartbeat_errors", E1000_STAT(net_stats.tx_heartbeat_errors) },
+	{ "tx_window_errors", E1000_STAT(net_stats.tx_window_errors) },
+	{ "tx_abort_late_coll", E1000_STAT(stats.latecol) },
+	{ "tx_deferred_ok", E1000_STAT(stats.dc) },
+	{ "tx_single_coll_ok", E1000_STAT(stats.scc) },
+	{ "tx_multi_coll_ok", E1000_STAT(stats.mcc) },
+	{ "rx_long_length_errors", E1000_STAT(stats.roc) },
+	{ "rx_short_length_errors", E1000_STAT(stats.ruc) },
+	{ "rx_align_errors", E1000_STAT(stats.algnerrc) },
+	{ "tx_tcp_seg_good", E1000_STAT(stats.tsctc) },
+	{ "tx_tcp_seg_failed", E1000_STAT(stats.tsctfc) },
+	{ "rx_flow_control_xon", E1000_STAT(stats.xonrxc) },
+	{ "rx_flow_control_xoff", E1000_STAT(stats.xoffrxc) },
+	{ "tx_flow_control_xon", E1000_STAT(stats.xontxc) },
+	{ "tx_flow_control_xoff", E1000_STAT(stats.xofftxc) },
+	{ "rx_csum_offload_good", E1000_STAT(hw_csum_good) },
+	{ "rx_csum_offload_errors", E1000_STAT(hw_csum_err) }
+};
+#define E1000_STATS_LEN	\
+	sizeof(e1000_gstrings_stats) / sizeof(struct e1000_stats)
+static char e1000_gstrings_test[][ETH_GSTRING_LEN] = {
+	"Register test  (offline)", "Eeprom test    (offline)",
+	"Interrupt test (offline)", "Loopback test  (offline)",
+	"Link test   (on/offline)"
+};
+#define E1000_TEST_LEN sizeof(e1000_gstrings_test) / ETH_GSTRING_LEN
 
 static void
 e1000_ethtool_gset(struct e1000_adapter *adapter, struct ethtool_cmd *ecmd)
@@ -154,6 +199,7 @@ e1000_ethtool_gdrvinfo(struct e1000_adap
 	strncpy(drvinfo->fw_version, "N/A", 32);
 	strncpy(drvinfo->bus_info, adapter->pdev->slot_name, 32);
 	drvinfo->n_stats = E1000_STATS_LEN;
+	drvinfo->testinfo_len = E1000_TEST_LEN;
 #define E1000_REGS_LEN 32
 	drvinfo->regdump_len  = E1000_REGS_LEN * sizeof(uint32_t);
 	drvinfo->eedump_len = adapter->hw.eeprom.word_size * 2;
@@ -164,6 +210,7 @@ e1000_ethtool_gregs(struct e1000_adapter
                     struct ethtool_regs *regs, uint32_t *regs_buff)
 {
 	struct e1000_hw *hw = &adapter->hw;
+	uint16_t phy_data;
 
 	regs->version = (1 << 24) | (hw->revision_id << 16) | hw->device_id;
 
@@ -182,6 +229,62 @@ e1000_ethtool_gregs(struct e1000_adapter
 	regs_buff[10] = E1000_READ_REG(hw, TDT);
 	regs_buff[11] = E1000_READ_REG(hw, TIDV);
 
+	regs_buff[12] = adapter->hw.phy_type;  /* PHY type (IGP=1, M88=0) */
+	if(hw->phy_type == e1000_phy_igp) {
+		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
+				    IGP01E1000_PHY_AGC_A);
+		e1000_read_phy_reg(hw, IGP01E1000_PHY_AGC_A &
+				   IGP01E1000_PHY_PAGE_SELECT, &phy_data);
+		regs_buff[13] = (uint32_t)phy_data; /* cable length */
+		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
+				    IGP01E1000_PHY_AGC_B);
+		e1000_read_phy_reg(hw, IGP01E1000_PHY_AGC_B &
+				   IGP01E1000_PHY_PAGE_SELECT, &phy_data);
+		regs_buff[14] = (uint32_t)phy_data; /* cable length */
+		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
+				    IGP01E1000_PHY_AGC_C);
+		e1000_read_phy_reg(hw, IGP01E1000_PHY_AGC_C &
+				   IGP01E1000_PHY_PAGE_SELECT, &phy_data);
+		regs_buff[15] = (uint32_t)phy_data; /* cable length */
+		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
+				    IGP01E1000_PHY_AGC_D);
+		e1000_read_phy_reg(hw, IGP01E1000_PHY_AGC_D &
+				   IGP01E1000_PHY_PAGE_SELECT, &phy_data);
+		regs_buff[16] = (uint32_t)phy_data; /* cable length */
+		regs_buff[17] = 0; /* extended 10bt distance (not needed) */
+		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0);
+		e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS &
+				   IGP01E1000_PHY_PAGE_SELECT, &phy_data);
+		regs_buff[18] = (uint32_t)phy_data; /* cable polarity */
+		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
+				    IGP01E1000_PHY_PCS_INIT_REG);
+		e1000_read_phy_reg(hw, IGP01E1000_PHY_PCS_INIT_REG &
+				   IGP01E1000_PHY_PAGE_SELECT, &phy_data);
+		regs_buff[19] = (uint32_t)phy_data; /* cable polarity */
+		regs_buff[20] = 0; /* polarity correction enabled (always) */
+		regs_buff[22] = 0; /* phy receive errors (unavailable) */
+		regs_buff[23] = regs_buff[18]; /* mdix mode */
+		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0);
+	} else {
+        	e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
+		regs_buff[13] = (uint32_t)phy_data; /* cable length */
+		regs_buff[14] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
+		regs_buff[15] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
+		regs_buff[16] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
+        	e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
+		regs_buff[17] = (uint32_t)phy_data; /* extended 10bt distance */
+		regs_buff[18] = regs_buff[13]; /* cable polarity */
+		regs_buff[19] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
+		regs_buff[20] = regs_buff[17]; /* polarity correction */
+		/* phy receive errors */
+		regs_buff[22] = adapter->phy_stats.receive_errors;
+		regs_buff[23] = regs_buff[13]; /* mdix mode */
+	}
+	regs_buff[21] = adapter->phy_stats.idle_errors;  /* phy idle errors */
+	e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);
+	regs_buff[24] = (uint32_t)phy_data;  /* phy local receiver status */
+	regs_buff[25] = regs_buff[24];  /* phy remote receiver status */
+
 	return;
 }
 
@@ -219,7 +322,7 @@ e1000_ethtool_geeprom(struct e1000_adapt
 		uint16_t i;
 		for (i = 0; i < last_word - first_word + 1; i++)
 			if((ret_val = e1000_read_eeprom(hw, first_word + i, 1,
-						       &eeprom_buff[i])))
+							&eeprom_buff[i])))
 				break;
 	}
 geeprom_error:
@@ -249,7 +352,7 @@ e1000_ethtool_seeprom(struct e1000_adapt
 	first_word = eeprom->offset >> 1;
 	last_word = (eeprom->offset + eeprom->len - 1) >> 1;
 	eeprom_buff = kmalloc(max_len, GFP_KERNEL);
-	if(eeprom_buff == NULL)
+	if(!eeprom_buff)
 		return -ENOMEM;
 
 	ptr = (void *)eeprom_buff;
@@ -284,6 +387,765 @@ seeprom_error:
 	return ret_val;
 }
 
+#define REG_PATTERN_TEST(R, M, W)                                              \
+{                                                                              \
+	uint32_t pat, value;                                                   \
+	uint32_t test[] =                                                      \
+		{0x5A5A5A5A, 0xA5A5A5A5, 0x00000000, 0xFFFFFFFF};              \
+	for(pat = 0; pat < sizeof(test)/sizeof(test[0]); pat++) {              \
+		E1000_WRITE_REG(&adapter->hw, R, (test[pat] & W));             \
+		value = E1000_READ_REG(&adapter->hw, R);                       \
+		if(value != (test[pat] & W & M)) {                             \
+			*data = (adapter->hw.mac_type < e1000_82543) ?         \
+				E1000_82542_##R : E1000_##R;                   \
+			return 1;                                              \
+		}                                                              \
+	}                                                                      \
+}
+
+#define REG_SET_AND_CHECK(R, M, W)                                             \
+{                                                                              \
+	uint32_t value;                                                        \
+	E1000_WRITE_REG(&adapter->hw, R, W & M);                               \
+	value = E1000_READ_REG(&adapter->hw, R);                               \
+	if ((W & M) != (value & M)) {                                          \
+		*data = (adapter->hw.mac_type < e1000_82543) ?                 \
+			E1000_82542_##R : E1000_##R;                           \
+		return 1;                                                      \
+	}                                                                      \
+}
+
+static int
+e1000_reg_test(struct e1000_adapter *adapter, uint64_t *data)
+{
+	uint32_t value;
+	uint32_t i;
+
+	/* The status register is Read Only, so a write should fail.
+	 * Some bits that get toggled are ignored.
+	 */
+	value = (E1000_READ_REG(&adapter->hw, STATUS) & (0xFFFFF833));
+	E1000_WRITE_REG(&adapter->hw, STATUS, (0xFFFFFFFF));
+	if(value != (E1000_READ_REG(&adapter->hw, STATUS) & (0xFFFFF833))) {
+		*data = 1;
+		return 1;
+	}
+
+	REG_PATTERN_TEST(FCAL, 0xFFFFFFFF, 0xFFFFFFFF);
+	REG_PATTERN_TEST(FCAH, 0x0000FFFF, 0xFFFFFFFF);
+	REG_PATTERN_TEST(FCT, 0x0000FFFF, 0xFFFFFFFF);
+	REG_PATTERN_TEST(VET, 0x0000FFFF, 0xFFFFFFFF);
+	REG_PATTERN_TEST(RDTR, 0x0000FFFF, 0xFFFFFFFF);
+	REG_PATTERN_TEST(RDBAH, 0xFFFFFFFF, 0xFFFFFFFF);
+	REG_PATTERN_TEST(RDLEN, 0x000FFF80, 0x000FFFFF);
+	REG_PATTERN_TEST(RDH, 0x0000FFFF, 0x0000FFFF);
+	REG_PATTERN_TEST(RDT, 0x0000FFFF, 0x0000FFFF);
+	REG_PATTERN_TEST(FCRTH, 0x0000FFF8, 0x0000FFF8);
+	REG_PATTERN_TEST(FCTTV, 0x0000FFFF, 0x0000FFFF);
+	REG_PATTERN_TEST(TIPG, 0x3FFFFFFF, 0x3FFFFFFF);
+	REG_PATTERN_TEST(TDBAH, 0xFFFFFFFF, 0xFFFFFFFF);
+	REG_PATTERN_TEST(TDLEN, 0x000FFF80, 0x000FFFFF);
+
+	REG_SET_AND_CHECK(RCTL, 0xFFFFFFFF, 0x00000000);
+	REG_SET_AND_CHECK(RCTL, 0x06DFB3FE, 0x003FFFFB);
+	REG_SET_AND_CHECK(TCTL, 0xFFFFFFFF, 0x00000000);
+
+	if(adapter->hw.mac_type >= e1000_82543) {
+
+		REG_SET_AND_CHECK(RCTL, 0x06DFB3FE, 0xFFFFFFFF);
+		REG_PATTERN_TEST(RDBAL, 0xFFFFFFF0, 0xFFFFFFFF);
+		REG_PATTERN_TEST(TXCW, 0xC000FFFF, 0x0000FFFF);
+		REG_PATTERN_TEST(TDBAL, 0xFFFFFFF0, 0xFFFFFFFF);
+		REG_PATTERN_TEST(TIDV, 0x0000FFFF, 0x0000FFFF);
+
+		for(i = 0; i < E1000_RAR_ENTRIES; i++) {
+			REG_PATTERN_TEST(RA + ((i << 1) << 2), 0xFFFFFFFF,
+					 0xFFFFFFFF);
+			REG_PATTERN_TEST(RA + (((i << 1) + 1) << 2), 0x8003FFFF,
+					 0xFFFFFFFF);
+		}
+
+	} else {
+
+		REG_SET_AND_CHECK(RCTL, 0xFFFFFFFF, 0x01FFFFFF);
+		REG_PATTERN_TEST(RDBAL, 0xFFFFF000, 0xFFFFFFFF);
+		REG_PATTERN_TEST(TXCW, 0x0000FFFF, 0x0000FFFF);
+		REG_PATTERN_TEST(TDBAL, 0xFFFFF000, 0xFFFFFFFF);
+
+	}
+
+	for(i = 0; i < E1000_MC_TBL_SIZE; i++)
+		REG_PATTERN_TEST(MTA + (i << 2), 0xFFFFFFFF, 0xFFFFFFFF);
+
+	return 0;
+}
+
+static int
+e1000_eeprom_test(struct e1000_adapter *adapter, uint64_t *data)
+{
+	uint16_t temp;
+	uint16_t checksum = 0;
+	uint16_t i;
+
+	*data = 0;
+	/* Read and add up the contents of the EEPROM */
+	for(i = 0; i < (EEPROM_CHECKSUM_REG + 1); i++) {
+		if((e1000_read_eeprom(&adapter->hw, i, 1, &temp)) < 0) {
+			*data = 1;
+			break;
+		}
+		checksum += temp;
+	}
+
+	/* If Checksum is not Correct return error else test passed */
+	if((checksum != (uint16_t) EEPROM_SUM) && !(*data))
+		*data = 2;
+
+	return *data;
+}
+
+static void
+e1000_test_intr(int irq,
+		void *data,
+		struct pt_regs *regs)
+{
+	struct net_device *netdev = (struct net_device *) data;
+	struct e1000_adapter *adapter = netdev->priv;
+
+	adapter->test_icr |= E1000_READ_REG(&adapter->hw, ICR);
+
+	return;
+}
+
+static int
+e1000_intr_test(struct e1000_adapter *adapter, uint64_t *data)
+{
+	struct net_device *netdev = adapter->netdev;
+	uint32_t icr, mask, i=0;
+
+	*data = 0;
+
+	/* Hook up test interrupt handler just for this test */
+	if(request_irq
+	   (netdev->irq, &e1000_test_intr, SA_SHIRQ, netdev->name, netdev)) {
+		*data = 1;
+		return -1;
+	}
+
+	/* Disable all the interrupts */
+	E1000_WRITE_REG(&adapter->hw, IMC, 0xFFFFFFFF);
+	msec_delay(10);
+
+	/* Interrupts are disabled, so read interrupt cause
+	 * register (icr) twice to verify that there are no interrupts
+	 * pending.  icr is clear on read.
+	 */
+	icr = E1000_READ_REG(&adapter->hw, ICR);
+	icr = E1000_READ_REG(&adapter->hw, ICR);
+
+	if(icr != 0) {
+		/* if icr is non-zero, there is no point
+		 * running other interrupt tests.
+		 */
+		*data = 2;
+		i = 10;
+	}
+
+	/* Test each interrupt */
+	for(; i < 10; i++) {
+
+		/* Interrupt to test */
+		mask = 1 << i;
+
+		/* Disable the interrupt to be reported in
+		 * the cause register and then force the same
+		 * interrupt and see if one gets posted.  If
+		 * an interrupt was posted to the bus, the
+		 * test failed.
+		 */
+		adapter->test_icr = 0;
+		E1000_WRITE_REG(&adapter->hw, IMC, mask);
+		E1000_WRITE_REG(&adapter->hw, ICS, mask);
+		msec_delay(10);
+
+		if(adapter->test_icr & mask) {
+			*data = 3;
+			break;
+		}
+
+		/* Enable the interrupt to be reported in
+		 * the cause register and then force the same
+		 * interrupt and see if one gets posted.  If
+		 * an interrupt was not posted to the bus, the
+		 * test failed.
+		 */
+		adapter->test_icr = 0;
+		E1000_WRITE_REG(&adapter->hw, IMS, mask);
+		E1000_WRITE_REG(&adapter->hw, ICS, mask);
+		msec_delay(10);
+
+		if(!(adapter->test_icr & mask)) {
+			*data = 4;
+			break;
+		}
+
+		/* Disable the other interrupts to be reported in
+		 * the cause register and then force the other
+		 * interrupts and see if any get posted.  If
+		 * an interrupt was posted to the bus, the
+		 * test failed.
+		 */
+		adapter->test_icr = 0;
+		E1000_WRITE_REG(&adapter->hw, IMC, ~mask);
+		E1000_WRITE_REG(&adapter->hw, ICS, ~mask);
+		msec_delay(10);
+
+		if(adapter->test_icr) {
+			*data = 5;
+			break;
+		}
+	}
+
+	/* Disable all the interrupts */
+	E1000_WRITE_REG(&adapter->hw, IMC, 0xFFFFFFFF);
+	msec_delay(10);
+
+	/* Unhook test interrupt handler */
+	free_irq(netdev->irq, netdev);
+
+	return *data;
+}
+
+static void
+e1000_free_desc_rings(struct e1000_adapter *adapter)
+{
+	struct e1000_desc_ring *txdr = &adapter->test_tx_ring;
+	struct e1000_desc_ring *rxdr = &adapter->test_rx_ring;
+	struct pci_dev *pdev = adapter->pdev;
+	int i;
+
+	if(txdr->desc && txdr->buffer_info) {
+		for(i = 0; i < txdr->count; i++) {
+			if(txdr->buffer_info[i].dma)
+				pci_unmap_single(pdev, txdr->buffer_info[i].dma,
+						 txdr->buffer_info[i].length,
+						 PCI_DMA_TODEVICE);
+			if(txdr->buffer_info[i].skb)
+				dev_kfree_skb(txdr->buffer_info[i].skb);
+		}
+	}
+
+	if(rxdr->desc && rxdr->buffer_info) {
+		for(i = 0; i < rxdr->count; i++) {
+			if(rxdr->buffer_info[i].dma)
+				pci_unmap_single(pdev, rxdr->buffer_info[i].dma,
+						 rxdr->buffer_info[i].length,
+						 PCI_DMA_FROMDEVICE);
+			if(rxdr->buffer_info[i].skb)
+				dev_kfree_skb(rxdr->buffer_info[i].skb);
+		}
+	}
+
+	if(txdr->desc)
+		pci_free_consistent(pdev, txdr->size, txdr->desc, txdr->dma);
+	if(rxdr->desc)
+		pci_free_consistent(pdev, rxdr->size, rxdr->desc, rxdr->dma);
+
+	if(txdr->buffer_info)
+		kfree(txdr->buffer_info);
+	if(rxdr->buffer_info)
+		kfree(rxdr->buffer_info);
+
+	return;
+}
+
+static int
+e1000_setup_desc_rings(struct e1000_adapter *adapter)
+{
+	struct e1000_desc_ring *txdr = &adapter->test_tx_ring;
+	struct e1000_desc_ring *rxdr = &adapter->test_rx_ring;
+	struct pci_dev *pdev = adapter->pdev;
+	uint32_t rctl;
+	int size, i, ret_val;
+
+	/* Setup Tx descriptor ring and Tx buffers */
+
+	txdr->count = 80;
+
+	size = txdr->count * sizeof(struct e1000_buffer);
+	if(!(txdr->buffer_info = kmalloc(size, GFP_KERNEL))) {
+		ret_val = 1;
+		goto err_nomem;
+	}
+	memset(txdr->buffer_info, 0, size);
+
+	txdr->size = txdr->count * sizeof(struct e1000_tx_desc);
+	E1000_ROUNDUP(txdr->size, 4096);
+	if(!(txdr->desc = pci_alloc_consistent(pdev, txdr->size, &txdr->dma))) {
+		ret_val = 2;
+		goto err_nomem;
+	}
+	memset(txdr->desc, 0, txdr->size);
+	txdr->next_to_use = txdr->next_to_clean = 0;
+
+	E1000_WRITE_REG(&adapter->hw, TDBAL,
+			((uint64_t) txdr->dma & 0x00000000FFFFFFFF));
+	E1000_WRITE_REG(&adapter->hw, TDBAH, ((uint64_t) txdr->dma >> 32));
+	E1000_WRITE_REG(&adapter->hw, TDLEN,
+			txdr->count * sizeof(struct e1000_tx_desc));
+	E1000_WRITE_REG(&adapter->hw, TDH, 0);
+	E1000_WRITE_REG(&adapter->hw, TDT, 0);
+	E1000_WRITE_REG(&adapter->hw, TCTL,
+			E1000_TCTL_PSP | E1000_TCTL_EN |
+			E1000_COLLISION_THRESHOLD << E1000_CT_SHIFT |
+			E1000_FDX_COLLISION_DISTANCE << E1000_COLD_SHIFT);
+
+	for(i = 0; i < txdr->count; i++) {
+		struct e1000_tx_desc *tx_desc = E1000_TX_DESC(*txdr, i);
+		struct sk_buff *skb;
+		unsigned int size = 1024;
+
+		if(!(skb = alloc_skb(size, GFP_KERNEL))) {
+			ret_val = 3;
+			goto err_nomem;
+		}
+		skb_put(skb, size);
+		txdr->buffer_info[i].skb = skb;
+		txdr->buffer_info[i].length = skb->len;
+		txdr->buffer_info[i].dma =
+			pci_map_single(pdev, skb->data, skb->len,
+				       PCI_DMA_TODEVICE);
+		tx_desc->buffer_addr = cpu_to_le64(txdr->buffer_info[i].dma);
+		tx_desc->lower.data = cpu_to_le32(skb->len);
+		tx_desc->lower.data |= E1000_TXD_CMD_EOP;
+		tx_desc->lower.data |= E1000_TXD_CMD_IFCS;
+		tx_desc->lower.data |= E1000_TXD_CMD_RPS;
+		tx_desc->upper.data = 0;
+	}
+
+	/* Setup Rx descriptor ring and Rx buffers */
+
+	rxdr->count = 80;
+
+	size = rxdr->count * sizeof(struct e1000_buffer);
+	if(!(rxdr->buffer_info = kmalloc(size, GFP_KERNEL))) {
+		ret_val = 4;
+		goto err_nomem;
+	}
+	memset(rxdr->buffer_info, 0, size);
+
+	rxdr->size = rxdr->count * sizeof(struct e1000_rx_desc);
+	if(!(rxdr->desc = pci_alloc_consistent(pdev, rxdr->size, &rxdr->dma))) {
+		ret_val = 5;
+		goto err_nomem;
+	}
+	memset(rxdr->desc, 0, rxdr->size);
+	rxdr->next_to_use = rxdr->next_to_clean = 0;
+
+	rctl = E1000_READ_REG(&adapter->hw, RCTL);
+	E1000_WRITE_REG(&adapter->hw, RCTL, rctl & ~E1000_RCTL_EN);
+	E1000_WRITE_REG(&adapter->hw, RDBAL,
+			((uint64_t) rxdr->dma & 0xFFFFFFFF));
+	E1000_WRITE_REG(&adapter->hw, RDBAH, ((uint64_t) rxdr->dma >> 32));
+	E1000_WRITE_REG(&adapter->hw, RDLEN, rxdr->size);
+	E1000_WRITE_REG(&adapter->hw, RDH, 0);
+	E1000_WRITE_REG(&adapter->hw, RDT, 0);
+	rctl = E1000_RCTL_EN | E1000_RCTL_BAM | E1000_RCTL_SZ_2048 |
+		E1000_RCTL_LBM_NO | E1000_RCTL_RDMTS_HALF |
+		(adapter->hw.mc_filter_type << E1000_RCTL_MO_SHIFT);
+	E1000_WRITE_REG(&adapter->hw, RCTL, rctl);
+
+	for(i = 0; i < rxdr->count; i++) {
+		struct e1000_rx_desc *rx_desc = E1000_RX_DESC(*rxdr, i);
+		struct sk_buff *skb;
+
+		if(!(skb = alloc_skb(E1000_RXBUFFER_2048 + 2, GFP_KERNEL))) {
+			ret_val = 6;
+			goto err_nomem;
+		}
+		skb_reserve(skb, 2);
+		rxdr->buffer_info[i].skb = skb;
+		rxdr->buffer_info[i].length = E1000_RXBUFFER_2048;
+		rxdr->buffer_info[i].dma =
+			pci_map_single(pdev, skb->data, E1000_RXBUFFER_2048,
+				       PCI_DMA_FROMDEVICE);
+		rx_desc->buffer_addr = cpu_to_le64(rxdr->buffer_info[i].dma);
+		memset(skb->data, 0x00, skb->len);
+	}
+
+	return 0;
+
+      err_nomem:
+	e1000_free_desc_rings(adapter);
+	return ret_val;
+}
+
+static void
+e1000_phy_disable_receiver(struct e1000_adapter *adapter)
+{
+	/* Write out to PHY registers 29 and 30 to disable the Receiver. */
+	e1000_write_phy_reg(&adapter->hw, 29, 0x001F);
+	e1000_write_phy_reg(&adapter->hw, 30, 0x8FFC);
+	e1000_write_phy_reg(&adapter->hw, 29, 0x001A);
+	e1000_write_phy_reg(&adapter->hw, 30, 0x8FF0);
+
+	return;
+}
+
+static void
+e1000_phy_reset_clk_and_crs(struct e1000_adapter *adapter)
+{
+	uint16_t phy_reg;
+
+	/* Because we reset the PHY above, we need to re-force TX_CLK in the
+	 * Extended PHY Specific Control Register to 25MHz clock.  This
+	 * value defaults back to a 2.5MHz clock when the PHY is reset.
+	 */
+	e1000_read_phy_reg(&adapter->hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_reg);
+	phy_reg |= M88E1000_EPSCR_TX_CLK_25;
+	e1000_write_phy_reg(&adapter->hw,
+		M88E1000_EXT_PHY_SPEC_CTRL, phy_reg);
+
+	/* In addition, because of the s/w reset above, we need to enable
+	 * CRS on TX.  This must be set for both full and half duplex
+	 * operation.
+	 */
+	e1000_read_phy_reg(&adapter->hw, M88E1000_PHY_SPEC_CTRL, &phy_reg);
+	phy_reg |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
+	e1000_write_phy_reg(&adapter->hw,
+		M88E1000_PHY_SPEC_CTRL, phy_reg);
+}
+
+static int
+e1000_nonintegrated_phy_loopback(struct e1000_adapter *adapter)
+{
+	uint32_t ctrl_reg;
+	uint16_t phy_reg;
+
+	/* Setup the Device Control Register for PHY loopback test. */
+
+	ctrl_reg = E1000_READ_REG(&adapter->hw, CTRL);
+	ctrl_reg |= (E1000_CTRL_ILOS |		/* Invert Loss-Of-Signal */
+		     E1000_CTRL_FRCSPD |	/* Set the Force Speed Bit */
+		     E1000_CTRL_FRCDPX |	/* Set the Force Duplex Bit */
+		     E1000_CTRL_SPD_1000 |	/* Force Speed to 1000 */
+		     E1000_CTRL_FD);		/* Force Duplex to FULL */
+
+	E1000_WRITE_REG(&adapter->hw, CTRL, ctrl_reg);
+
+	/* Read the PHY Specific Control Register (0x10) */
+	e1000_read_phy_reg(&adapter->hw, M88E1000_PHY_SPEC_CTRL, &phy_reg);
+
+	/* Clear Auto-Crossover bits in PHY Specific Control Register
+	 * (bits 6:5).
+	 */
+	phy_reg &= ~M88E1000_PSCR_AUTO_X_MODE;
+	e1000_write_phy_reg(&adapter->hw, M88E1000_PHY_SPEC_CTRL, phy_reg);
+
+	/* Perform software reset on the PHY */
+	e1000_phy_reset(&adapter->hw);
+
+	/* Have to setup TX_CLK and TX_CRS after software reset */
+	e1000_phy_reset_clk_and_crs(adapter);
+
+	e1000_write_phy_reg(&adapter->hw, PHY_CTRL, 0x8100);
+
+	/* Wait for reset to complete. */
+	udelay(500);
+
+	/* Have to setup TX_CLK and TX_CRS after software reset */
+	e1000_phy_reset_clk_and_crs(adapter);
+
+	/* Write out to PHY registers 29 and 30 to disable the Receiver. */
+	e1000_phy_disable_receiver(adapter);
+
+	/* Set the loopback bit in the PHY control register. */
+	e1000_read_phy_reg(&adapter->hw, PHY_CTRL, &phy_reg);
+	phy_reg |= MII_CR_LOOPBACK;
+	e1000_write_phy_reg(&adapter->hw, PHY_CTRL, phy_reg);
+
+	/* Setup TX_CLK and TX_CRS one more time. */
+	e1000_phy_reset_clk_and_crs(adapter);
+
+	/* Check Phy Configuration */
+	e1000_read_phy_reg(&adapter->hw, PHY_CTRL, &phy_reg);
+	if(phy_reg != 0x4100)
+		 return 9;
+
+	e1000_read_phy_reg(&adapter->hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_reg);
+	if(phy_reg != 0x0070)
+		return 10;
+
+	e1000_read_phy_reg(&adapter->hw, 29, &phy_reg);
+	if(phy_reg != 0x001A)
+		return 11;
+
+	return 0;
+}
+
+static int
+e1000_integrated_phy_loopback(struct e1000_adapter *adapter)
+{
+	uint32_t ctrl_reg = 0;
+	uint32_t stat_reg = 0;
+
+	adapter->hw.autoneg = FALSE;
+
+	if(adapter->hw.phy_type == e1000_phy_m88) {
+		/* Auto-MDI/MDIX Off */
+		e1000_write_phy_reg(&adapter->hw,
+				    M88E1000_PHY_SPEC_CTRL, 0x0808);
+		/* reset to update Auto-MDI/MDIX */
+		e1000_write_phy_reg(&adapter->hw, PHY_CTRL, 0x9140);
+		/* autoneg off */
+		e1000_write_phy_reg(&adapter->hw, PHY_CTRL, 0x8140);
+	}
+	/* force 1000, set loopback */
+	e1000_write_phy_reg(&adapter->hw, PHY_CTRL, 0x4140);
+
+	/* Now set up the MAC to the same speed/duplex as the PHY. */
+	ctrl_reg = E1000_READ_REG(&adapter->hw, CTRL);
+	ctrl_reg &= ~E1000_CTRL_SPD_SEL; /* Clear the speed sel bits */
+	ctrl_reg |= (E1000_CTRL_FRCSPD | /* Set the Force Speed Bit */
+		     E1000_CTRL_FRCDPX | /* Set the Force Duplex Bit */
+		     E1000_CTRL_SPD_1000 |/* Force Speed to 1000 */
+		     E1000_CTRL_FD);	 /* Force Duplex to FULL */
+
+	if(adapter->hw.media_type == e1000_media_type_copper &&
+	   adapter->hw.phy_type == e1000_phy_m88) {
+		ctrl_reg |= E1000_CTRL_ILOS; /* Invert Loss of Signal */
+	} else {
+		/* Set the ILOS bit on the fiber Nic is half
+		 * duplex link is detected. */
+		stat_reg = E1000_READ_REG(&adapter->hw, STATUS);
+		if((stat_reg & E1000_STATUS_FD) == 0)
+			ctrl_reg |= (E1000_CTRL_ILOS | E1000_CTRL_SLU);
+	}
+
+	E1000_WRITE_REG(&adapter->hw, CTRL, ctrl_reg);
+
+	/* Disable the receiver on the PHY so when a cable is plugged in, the
+	 * PHY does not begin to autoneg when a cable is reconnected to the NIC.
+	 */
+	if(adapter->hw.phy_type == e1000_phy_m88)
+		e1000_phy_disable_receiver(adapter);
+
+	udelay(500);
+
+	return 0;
+}
+
+static int
+e1000_set_phy_loopback(struct e1000_adapter *adapter)
+{
+	uint16_t phy_reg = 0;
+	uint16_t count = 0;
+
+	switch (adapter->hw.mac_type) {
+	case e1000_82543:
+		if(adapter->hw.media_type == e1000_media_type_copper) {
+			/* Attempt to setup Loopback mode on Non-integrated PHY.
+			 * Some PHY registers get corrupted at random, so
+			 * attempt this 10 times.
+			 */
+			while(e1000_nonintegrated_phy_loopback(adapter) &&
+			      count++ < 10);
+			if(count < 11)
+				return 0;
+		}
+		break;
+
+	case e1000_82544:
+	case e1000_82540:
+	case e1000_82545:
+	case e1000_82546:
+	case e1000_82541:
+	case e1000_82547:
+		return e1000_integrated_phy_loopback(adapter);
+		break;
+
+	default:
+		/* Default PHY loopback work is to read the MII
+		 * control register and assert bit 14 (loopback mode).
+		 */
+		e1000_read_phy_reg(&adapter->hw, PHY_CTRL, &phy_reg);
+		phy_reg |= MII_CR_LOOPBACK;
+		e1000_write_phy_reg(&adapter->hw, PHY_CTRL, phy_reg);
+		return 0;
+		break;
+	}
+
+	return 8;
+}
+
+static int
+e1000_setup_loopback_test(struct e1000_adapter *adapter)
+{
+	uint32_t rctl;
+
+	if(adapter->hw.media_type == e1000_media_type_fiber) {
+		if(adapter->hw.mac_type == e1000_82545 ||
+		   adapter->hw.mac_type == e1000_82546)
+			return e1000_set_phy_loopback(adapter);
+		else {
+			rctl = E1000_READ_REG(&adapter->hw, RCTL);
+			rctl |= E1000_RCTL_LBM_TCVR;
+			E1000_WRITE_REG(&adapter->hw, RCTL, rctl);
+			return 0;
+		}
+	} else if(adapter->hw.media_type == e1000_media_type_copper)
+		return e1000_set_phy_loopback(adapter);
+
+	return 7;
+}
+
+static void
+e1000_loopback_cleanup(struct e1000_adapter *adapter)
+{
+	uint32_t rctl;
+	uint16_t phy_reg;
+
+	rctl = E1000_READ_REG(&adapter->hw, RCTL);
+	rctl &= ~(E1000_RCTL_LBM_TCVR | E1000_RCTL_LBM_MAC);
+	E1000_WRITE_REG(&adapter->hw, RCTL, rctl);
+
+	if(adapter->hw.media_type == e1000_media_type_copper ||
+	   (adapter->hw.media_type == e1000_media_type_fiber &&
+	    (adapter->hw.mac_type == e1000_82545 ||
+	     adapter->hw.mac_type == e1000_82546))) {
+		adapter->hw.autoneg = TRUE;
+		e1000_read_phy_reg(&adapter->hw, PHY_CTRL, &phy_reg);
+		if(phy_reg & MII_CR_LOOPBACK) {
+			phy_reg &= ~MII_CR_LOOPBACK;
+			e1000_write_phy_reg(&adapter->hw, PHY_CTRL, phy_reg);
+			e1000_phy_reset(&adapter->hw);
+		}
+	}
+}
+
+static void
+e1000_create_lbtest_frame(struct sk_buff *skb, unsigned int frame_size)
+{
+	memset(skb->data, 0xFF, frame_size);
+	frame_size = (frame_size % 2) ? (frame_size - 1) : frame_size;
+	memset(&skb->data[frame_size / 2], 0xAA, frame_size / 2 - 1);
+	memset(&skb->data[frame_size / 2 + 10], 0xBE, 1);
+	memset(&skb->data[frame_size / 2 + 12], 0xAF, 1);
+}
+
+static int
+e1000_check_lbtest_frame(struct sk_buff *skb, unsigned int frame_size)
+{
+	frame_size = (frame_size % 2) ? (frame_size - 1) : frame_size;
+	if(*(skb->data + 3) == 0xFF) {
+		if((*(skb->data + frame_size / 2 + 10) == 0xBE) &&
+		   (*(skb->data + frame_size / 2 + 12) == 0xAF)) {
+			return 0;
+		}
+	}
+	return 13;
+}
+
+static int
+e1000_run_loopback_test(struct e1000_adapter *adapter)
+{
+	struct e1000_desc_ring *txdr = &adapter->test_tx_ring;
+	struct e1000_desc_ring *rxdr = &adapter->test_rx_ring;
+	struct pci_dev *pdev = adapter->pdev;
+	int i;
+
+	E1000_WRITE_REG(&adapter->hw, RDT, rxdr->count - 1);
+
+	for(i = 0; i < 64; i++) {
+		e1000_create_lbtest_frame(txdr->buffer_info[i].skb, 1024);
+		pci_dma_sync_single(pdev, txdr->buffer_info[i].dma,
+				    txdr->buffer_info[i].length,
+				    PCI_DMA_TODEVICE);
+	}
+	E1000_WRITE_REG(&adapter->hw, TDT, i);
+
+	msec_delay(200);
+
+	pci_dma_sync_single(pdev, rxdr->buffer_info[0].dma,
+			    rxdr->buffer_info[0].length, PCI_DMA_FROMDEVICE);
+
+	return e1000_check_lbtest_frame(rxdr->buffer_info[0].skb, 1024);
+}
+
+static int
+e1000_loopback_test(struct e1000_adapter *adapter, uint64_t *data)
+{
+	if((*data = e1000_setup_desc_rings(adapter))) goto err_loopback;
+	if((*data = e1000_setup_loopback_test(adapter))) goto err_loopback;
+	*data = e1000_run_loopback_test(adapter);
+	e1000_loopback_cleanup(adapter);
+	e1000_free_desc_rings(adapter);
+err_loopback:
+	return *data;
+}
+
+static int
+e1000_link_test(struct e1000_adapter *adapter, uint64_t *data)
+{
+	*data = 0;
+	e1000_check_for_link(&adapter->hw);
+
+	if(!(E1000_READ_REG(&adapter->hw, STATUS) & E1000_STATUS_LU)) {
+		*data = 1;
+	}
+	return *data;
+}
+
+static int
+e1000_ethtool_test(struct e1000_adapter *adapter,
+		   struct ethtool_test *eth_test, uint64_t *data)
+{
+	boolean_t if_running = netif_running(adapter->netdev);
+
+	if(eth_test->flags == ETH_TEST_FL_OFFLINE) {
+		/* Offline tests */
+
+		/* Link test performed before hardware reset so autoneg doesn't
+		 * interfere with test result */
+		if(e1000_link_test(adapter, &data[4]))
+			eth_test->flags |= ETH_TEST_FL_FAILED;
+
+		if(if_running)
+			e1000_down(adapter);
+
+		e1000_reset(adapter);
+		if(e1000_reg_test(adapter, &data[0]))
+			eth_test->flags |= ETH_TEST_FL_FAILED;
+
+		e1000_reset(adapter);
+		if(e1000_eeprom_test(adapter, &data[1]))
+			eth_test->flags |= ETH_TEST_FL_FAILED;
+
+		e1000_reset(adapter);
+		if(e1000_intr_test(adapter, &data[2]))
+			eth_test->flags |= ETH_TEST_FL_FAILED;
+
+		e1000_reset(adapter);
+		if(e1000_loopback_test(adapter, &data[3]))
+			eth_test->flags |= ETH_TEST_FL_FAILED;
+
+		e1000_reset(adapter);
+		if(if_running)
+			e1000_up(adapter);
+	} else {
+		/* Online tests */
+		if(e1000_link_test(adapter, &data[4]))
+			eth_test->flags |= ETH_TEST_FL_FAILED;
+
+		/* Offline tests aren't run; pass by default */
+		data[0] = 0;
+		data[1] = 0;
+		data[2] = 0;
+		data[3] = 0;
+	}
+	return 0;
+}
+
 static void
 e1000_ethtool_gwol(struct e1000_adapter *adapter, struct ethtool_wolinfo *wol)
 {
@@ -427,8 +1289,6 @@ e1000_ethtool_ioctl(struct net_device *n
 	}
 	case ETHTOOL_SSET: {
 		struct ethtool_cmd ecmd;
-		if(!capable(CAP_NET_ADMIN))
-			return -EPERM;
 		if(copy_from_user(&ecmd, addr, sizeof(ecmd)))
 			return -EFAULT;
 		return e1000_ethtool_sset(adapter, &ecmd);
@@ -443,24 +1303,46 @@ e1000_ethtool_ioctl(struct net_device *n
 	case ETHTOOL_GSTRINGS: {
 		struct ethtool_gstrings gstrings = { ETHTOOL_GSTRINGS };
 		char *strings = NULL;
+		int err = 0;
 
 		if(copy_from_user(&gstrings, addr, sizeof(gstrings)))
 			return -EFAULT;
 		switch(gstrings.string_set) {
-		case ETH_SS_STATS:
+		case ETH_SS_TEST:
+			gstrings.len = E1000_TEST_LEN;
+			strings = kmalloc(E1000_TEST_LEN * ETH_GSTRING_LEN,
+					  GFP_KERNEL);
+			if(!strings)
+				return -ENOMEM;
+			memcpy(strings, e1000_gstrings_test, E1000_TEST_LEN *
+			       ETH_GSTRING_LEN);
+			break;
+		case ETH_SS_STATS: {
+			int i;
 			gstrings.len = E1000_STATS_LEN;
-			strings = *e1000_gstrings_stats;
+			strings = kmalloc(E1000_STATS_LEN * ETH_GSTRING_LEN,
+					  GFP_KERNEL);
+			if(!strings)
+				return -ENOMEM;
+			for(i=0; i < E1000_STATS_LEN; i++) {
+				memcpy(&strings[i * ETH_GSTRING_LEN],
+				       e1000_gstrings_stats[i].stat_string,
+				       ETH_GSTRING_LEN);
+			}
 			break;
+		}
 		default:
 			return -EOPNOTSUPP;
 		}
 		if(copy_to_user(addr, &gstrings, sizeof(gstrings)))
-			return -EFAULT;
+			err = -EFAULT;
 		addr += offsetof(struct ethtool_gstrings, data);
-		if(copy_to_user(addr, strings,
+		if(!err && copy_to_user(addr, strings,
 		   gstrings.len * ETH_GSTRING_LEN))
-			return -EFAULT;
-		return 0;
+			err = -EFAULT;
+
+		kfree(strings);
+		return err;
 	}
 	case ETHTOOL_GREGS: {
 		struct ethtool_regs regs = {ETHTOOL_GREGS};
@@ -479,8 +1361,6 @@ e1000_ethtool_ioctl(struct net_device *n
 		return 0;
 	}
 	case ETHTOOL_NWAY_RST: {
-		if(!capable(CAP_NET_ADMIN))
-			return -EPERM;
 		if(netif_running(netdev)) {
 			e1000_down(adapter);
 			e1000_up(adapter);
@@ -509,8 +1389,6 @@ e1000_ethtool_ioctl(struct net_device *n
 	}
 	case ETHTOOL_SWOL: {
 		struct ethtool_wolinfo wol;
-		if(!capable(CAP_NET_ADMIN))
-			return -EPERM;
 		if(copy_from_user(&wol, addr, sizeof(wol)) != 0)
 			return -EFAULT;
 		return e1000_ethtool_swol(adapter, &wol);
@@ -522,16 +1400,14 @@ e1000_ethtool_ioctl(struct net_device *n
 		void *ptr;
 		int err = 0;
 
+		if(copy_from_user(&eeprom, addr, sizeof(eeprom)))
+			return -EFAULT;
+
 		eeprom_buff = kmalloc(hw->eeprom.word_size * 2, GFP_KERNEL);
 
-		if(eeprom_buff == NULL)
+		if(!eeprom_buff)
 			return -ENOMEM;
 
-		if(copy_from_user(&eeprom, addr, sizeof(eeprom))) {
-			err = -EFAULT;
-			goto err_geeprom_ioctl;
-		}
-
 		if((err = e1000_ethtool_geeprom(adapter, &eeprom,
 						eeprom_buff)))
 			goto err_geeprom_ioctl;
@@ -554,9 +1430,6 @@ err_geeprom_ioctl:
 	case ETHTOOL_SEEPROM: {
 		struct ethtool_eeprom eeprom;
 
-		if(!capable(CAP_NET_ADMIN))
-			return -EPERM;
-
 		if(copy_from_user(&eeprom, addr, sizeof(eeprom)))
 			return -EFAULT;
 
@@ -565,18 +1438,42 @@ err_geeprom_ioctl:
 	}
 	case ETHTOOL_GSTATS: {
 		struct {
-			struct ethtool_stats cmd;
+			struct ethtool_stats eth_stats;
 			uint64_t data[E1000_STATS_LEN];
 		} stats = { {ETHTOOL_GSTATS, E1000_STATS_LEN} };
 		int i;
 
 		for(i = 0; i < E1000_STATS_LEN; i++)
-			stats.data[i] =
-				((unsigned long *)&adapter->net_stats)[i];
+			stats.data[i] = (e1000_gstrings_stats[i].sizeof_stat ==
+					sizeof(uint64_t)) ?
+				*(uint64_t *)((char *)adapter +
+					e1000_gstrings_stats[i].stat_offset) :
+				*(uint32_t *)((char *)adapter +
+					e1000_gstrings_stats[i].stat_offset);
 		if(copy_to_user(addr, &stats, sizeof(stats)))
 			return -EFAULT;
 		return 0;
 	}
+	case ETHTOOL_TEST: {
+		struct {
+			struct ethtool_test eth_test;
+			uint64_t data[E1000_TEST_LEN];
+		} test = { {ETHTOOL_TEST} };
+		int err;
+
+		if(copy_from_user(&test.eth_test, addr, sizeof(test.eth_test)))
+			return -EFAULT;
+
+		test.eth_test.len = E1000_TEST_LEN;
+
+		if((err = e1000_ethtool_test(adapter, &test.eth_test,
+					     test.data)))
+			return err;
+
+		if(copy_to_user(addr, &test, sizeof(test)) != 0)
+			return -EFAULT;
+		return 0;
+	}
 	default:
 		return -EOPNOTSUPP;
 	}
diff -urNp linux-2/drivers/net/e1000/e1000.h linux-3/drivers/net/e1000/e1000.h
--- linux-2/drivers/net/e1000/e1000.h	
+++ linux-3/drivers/net/e1000/e1000.h	
@@ -63,6 +63,9 @@
 #include <net/pkt_sched.h>
 #include <linux/list.h>
 #include <linux/reboot.h>
+#ifdef NETIF_F_TSO
+#include <net/checksum.h>
+#endif
 #include <linux/tqueue.h>
 #include <linux/mii.h>
 #include <linux/ethtool.h>
@@ -131,6 +134,7 @@ struct e1000_buffer {
 	uint64_t dma;
 	unsigned long length;
 	unsigned long time_stamp;
+	unsigned int next_to_watch;
 };
 
 struct e1000_desc_ring {
@@ -166,7 +170,6 @@ struct e1000_adapter {
 	struct timer_list watchdog_timer;
 	struct timer_list phy_info_timer;
 	struct vlan_group *vlgrp;
-	char *id_string;
 	uint32_t bd_number;
 	uint32_t rx_buffer_len;
 	uint32_t part_num;
@@ -215,6 +218,9 @@ struct e1000_adapter {
 	struct e1000_phy_info phy_info;
 	struct e1000_phy_stats phy_stats;
 
+	uint32_t test_icr;
+	struct e1000_desc_ring test_tx_ring;
+	struct e1000_desc_ring test_rx_ring;
 
 
 	uint32_t pci_state[16];
diff -urNp linux-2/drivers/net/e1000/e1000_hw.c linux-3/drivers/net/e1000/e1000_hw.c
--- linux-2/drivers/net/e1000/e1000_hw.c	
+++ linux-3/drivers/net/e1000/e1000_hw.c	
@@ -185,6 +185,7 @@ e1000_set_mac_type(struct e1000_hw *hw)
         break;
     case E1000_DEV_ID_82546EB_COPPER:
     case E1000_DEV_ID_82546EB_FIBER:
+    case E1000_DEV_ID_82546EB_QUAD_COPPER:
         hw->mac_type = e1000_82546;
         break;
     case E1000_DEV_ID_82541EI:
@@ -288,9 +289,7 @@ e1000_reset_hw(struct e1000_hw *hw)
         /* Configure activity LED after PHY reset */
         led_ctrl = E1000_READ_REG(hw, LEDCTL);
         led_ctrl &= IGP_ACTIVITY_LED_MASK;
-        led_ctrl |= IGP_ACTIVITY_LED_ENABLE;
-        if(hw->mac_type == e1000_82547)
-            led_ctrl |= IGP_LED3_MODE;
+        led_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);
         E1000_WRITE_REG(hw, LEDCTL, led_ctrl);
     }
 
@@ -737,9 +736,7 @@ e1000_setup_copper_link(struct e1000_hw 
         /* Configure activity LED after PHY reset */
         led_ctrl = E1000_READ_REG(hw, LEDCTL);
         led_ctrl &= IGP_ACTIVITY_LED_MASK;
-        led_ctrl |= IGP_ACTIVITY_LED_ENABLE;
-        if(hw->mac_type == e1000_82547)
-            led_ctrl |= IGP_LED3_MODE;
+        led_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);
         E1000_WRITE_REG(hw, LEDCTL, led_ctrl);
 
         if(hw->autoneg_advertised == ADVERTISE_1000_FULL) {
@@ -2293,9 +2290,7 @@ e1000_phy_hw_reset(struct e1000_hw *hw)
         /* Configure activity LED after PHY reset */
         led_ctrl = E1000_READ_REG(hw, LEDCTL);
         led_ctrl &= IGP_ACTIVITY_LED_MASK;
-        led_ctrl |= IGP_ACTIVITY_LED_ENABLE;
-        if(hw->mac_type == e1000_82547)
-            led_ctrl |= IGP_LED3_MODE;
+        led_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);
         E1000_WRITE_REG(hw, LEDCTL, led_ctrl);
     }
 }
@@ -3801,6 +3796,7 @@ e1000_setup_led(struct e1000_hw *hw)
     case E1000_DEV_ID_82540EM_LOM:
     case E1000_DEV_ID_82545EM_COPPER:
     case E1000_DEV_ID_82546EB_COPPER:
+    case E1000_DEV_ID_82546EB_QUAD_COPPER:
     case E1000_DEV_ID_82541EI:
     case E1000_DEV_ID_82541EP:
     case E1000_DEV_ID_82547EI:
@@ -3842,6 +3838,7 @@ e1000_cleanup_led(struct e1000_hw *hw)
     case E1000_DEV_ID_82545EM_FIBER:
     case E1000_DEV_ID_82546EB_COPPER:
     case E1000_DEV_ID_82546EB_FIBER:
+    case E1000_DEV_ID_82546EB_QUAD_COPPER:
     case E1000_DEV_ID_82541EI:
     case E1000_DEV_ID_82541EP:
     case E1000_DEV_ID_82547EI:
@@ -3896,6 +3893,7 @@ e1000_led_on(struct e1000_hw *hw)
     case E1000_DEV_ID_82540EM_LOM:
     case E1000_DEV_ID_82545EM_COPPER:
     case E1000_DEV_ID_82546EB_COPPER:
+    case E1000_DEV_ID_82546EB_QUAD_COPPER:
     case E1000_DEV_ID_82541EI:
     case E1000_DEV_ID_82541EP:
     case E1000_DEV_ID_82547EI:
@@ -3949,6 +3947,7 @@ e1000_led_off(struct e1000_hw *hw)
     case E1000_DEV_ID_82540EM_LOM:
     case E1000_DEV_ID_82545EM_COPPER:
     case E1000_DEV_ID_82546EB_COPPER:
+    case E1000_DEV_ID_82546EB_QUAD_COPPER:
     case E1000_DEV_ID_82541EI:
     case E1000_DEV_ID_82541EP:
     case E1000_DEV_ID_82547EI:
@@ -4206,7 +4205,11 @@ e1000_get_bus_info(struct e1000_hw *hw)
     status = E1000_READ_REG(hw, STATUS);
     hw->bus_type = (status & E1000_STATUS_PCIX_MODE) ?
                    e1000_bus_type_pcix : e1000_bus_type_pci;
-    if(hw->bus_type == e1000_bus_type_pci) {
+
+    if(hw->device_id == E1000_DEV_ID_82546EB_QUAD_COPPER) {
+        hw->bus_speed = (hw->bus_type == e1000_bus_type_pci) ?
+                        e1000_bus_speed_66 : e1000_bus_speed_120;
+    } else if(hw->bus_type == e1000_bus_type_pci) {
         hw->bus_speed = (status & E1000_STATUS_PCI66) ?
                         e1000_bus_speed_66 : e1000_bus_speed_33;
     } else {
diff -urNp linux-2/drivers/net/e1000/e1000_hw.h linux-3/drivers/net/e1000/e1000_hw.h
--- linux-2/drivers/net/e1000/e1000_hw.h	
+++ linux-3/drivers/net/e1000/e1000_hw.h	
@@ -99,6 +99,7 @@ typedef enum {
     e1000_bus_speed_33,
     e1000_bus_speed_66,
     e1000_bus_speed_100,
+    e1000_bus_speed_120,
     e1000_bus_speed_133,
     e1000_bus_speed_reserved
 } e1000_bus_speed;
@@ -314,10 +315,11 @@ void e1000_write_reg_io(struct e1000_hw 
 #define E1000_DEV_ID_82545EM_FIBER       0x1011
 #define E1000_DEV_ID_82546EB_COPPER      0x1010
 #define E1000_DEV_ID_82546EB_FIBER       0x1012
+#define E1000_DEV_ID_82546EB_QUAD_COPPER 0x101D
 #define E1000_DEV_ID_82541EI             0x1013
 #define E1000_DEV_ID_82541EP             0x1018
 #define E1000_DEV_ID_82547EI             0x1019
-#define NUM_DEV_IDS 19
+#define NUM_DEV_IDS 20
 
 #define NODE_ADDRESS_SIZE 6
 #define ETH_LENGTH_OF_ADDRESS 6
@@ -601,7 +603,7 @@ struct e1000_ffvt_entry {
 #define E1000_EECD     0x00010  /* EEPROM/Flash Control - RW */
 #define E1000_EERD     0x00014  /* EEPROM Read - RW */
 #define E1000_CTRL_EXT 0x00018  /* Extended Device Control - RW */
-#define E1000_FLA      0x0001C  /* Flash Access Register - RW */
+#define E1000_FLA      0x0001C  /* Flash Access - RW */
 #define E1000_MDIC     0x00020  /* MDI Control - RW */
 #define E1000_FCAL     0x00028  /* Flow Control Address Low - RW */
 #define E1000_FCAH     0x0002C  /* Flow Control Address High -RW */
@@ -730,6 +732,7 @@ struct e1000_ffvt_entry {
  * the registers function in the same manner.
  */
 #define E1000_82542_CTRL     E1000_CTRL
+#define E1000_82542_CTRL_DUP E1000_CTRL_DUP
 #define E1000_82542_STATUS   E1000_STATUS
 #define E1000_82542_EECD     E1000_EECD
 #define E1000_82542_EERD     E1000_EERD
@@ -1485,7 +1488,6 @@ struct e1000_hw {
 #define E1000_COLLISION_DISTANCE        64
 #define E1000_FDX_COLLISION_DISTANCE    E1000_COLLISION_DISTANCE
 #define E1000_HDX_COLLISION_DISTANCE    E1000_COLLISION_DISTANCE
-#define E1000_GB_HDX_COLLISION_DISTANCE 512
 #define E1000_COLD_SHIFT                12
 
 /* The number of Transmit and Receive Descriptors must be a multiple of 8 */
diff -urNp linux-2/drivers/net/e1000/e1000_main.c linux-3/drivers/net/e1000/e1000_main.c
--- linux-2/drivers/net/e1000/e1000_main.c	
+++ linux-3/drivers/net/e1000/e1000_main.c	
@@ -30,7 +30,14 @@
 
 /* Change Log
  *
- * 5.0.43	3/5/03
+ * 5.1.11	5/6/03
+ *   o Feature: Added support for 82546EB (Quad-port) hardware.
+ *   o Feature: Added support for Diagnostics through Ethtool.
+ *   o Cleanup: Removed /proc support.
+ *   o Cleanup: Removed proprietary IDIAG interface.
+ *   o Bug fix: TSO bug fixes.
+ *
+ * 5.0.42	3/5/03
  *   o Feature: Added support for 82541 and 82547 hardware.
  *   o Feature: Added support for Intel Gigabit PHY (IGP) and a variety of
  *   eeproms.
@@ -46,51 +53,22 @@
  *   shared interrupt instances.
  *
  * 4.4.18       11/27/02
- *   o Feature: Added user-settable knob for interrupt throttle rate (ITR).
- *   o Cleanup: removed large static array allocations.
- *   o Cleanup: C99 struct initializer format.
- *   o Bug fix: restore VLAN settings when interface is brought up.
- *   o Bug fix: return cleanly in probe if error in detecting MAC type.
- *   o Bug fix: Wake up on magic packet by default only if enabled in eeprom.
- *   o Bug fix: Validate MAC address in set_mac.
- *   o Bug fix: Throw away zero-length Tx skbs.
- *   o Bug fix: Make ethtool EEPROM acceses work on older versions of ethtool.
- * 
- * 4.4.12       10/15/02
  */
 
 char e1000_driver_name[] = "e1000";
 char e1000_driver_string[] = "Intel(R) PRO/1000 Network Driver";
-char e1000_driver_version[] = "5.0.43-k1";
+char e1000_driver_version[] = "5.1.11-k1";
 char e1000_copyright[] = "Copyright (c) 1999-2003 Intel Corporation.";
 
 /* e1000_pci_tbl - PCI Device ID Table
  *
- * Private driver_data field (last one) stores an index into e1000_strings
  * Wildcard entries (PCI_ANY_ID) should come last
  * Last entry must be all 0s
  *
  * { Vendor ID, Device ID, SubVendor ID, SubDevice ID,
- *   Class, Class Mask, String Index }
+ *   Class, Class Mask, private data (not used) }
  */
 static struct pci_device_id e1000_pci_tbl[] __devinitdata = {
-	/* Intel(R) PRO/1000 Network Connection */
-	{0x8086, 0x1000, 0x8086, 0x1000, 0, 0, 0},
-	{0x8086, 0x1001, 0x8086, 0x1003, 0, 0, 0},
-	{0x8086, 0x1004, 0x8086, 0x1004, 0, 0, 0},
-	{0x8086, 0x1008, 0x8086, 0x1107, 0, 0, 0},
-	{0x8086, 0x1009, 0x8086, 0x1109, 0, 0, 0},
-	{0x8086, 0x100C, 0x8086, 0x1112, 0, 0, 0},
-	{0x8086, 0x100E, 0x8086, 0x001E, 0, 0, 0},
-	/* Compaq Gigabit Ethernet Server Adapter */
-	{0x8086, 0x1000, 0x0E11, PCI_ANY_ID, 0, 0, 1},
-	{0x8086, 0x1001, 0x0E11, PCI_ANY_ID, 0, 0, 1},
-	{0x8086, 0x1004, 0x0E11, PCI_ANY_ID, 0, 0, 1},
-	/* IBM Mobile, Desktop & Server Adapters */
-	{0x8086, 0x1000, 0x1014, PCI_ANY_ID, 0, 0, 2},
-	{0x8086, 0x1001, 0x1014, PCI_ANY_ID, 0, 0, 2},
-	{0x8086, 0x1004, 0x1014, PCI_ANY_ID, 0, 0, 2},
-	/* Generic */
 	{0x8086, 0x1000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{0x8086, 0x1001, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{0x8086, 0x1004, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
@@ -106,6 +84,7 @@ static struct pci_device_id e1000_pci_tb
 	{0x8086, 0x1016, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{0x8086, 0x1017, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{0x8086, 0x101E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{0x8086, 0x101D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{0x8086, 0x1013, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{0x8086, 0x1019, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	/* required last entry */
@@ -114,12 +93,6 @@ static struct pci_device_id e1000_pci_tb
 
 MODULE_DEVICE_TABLE(pci, e1000_pci_tbl);
 
-static char *e1000_strings[] = {
-	"Intel(R) PRO/1000 Network Connection",
-	"HP Gigabit Ethernet Server Adapter",
-	"IBM Mobile, Desktop & Server Adapters"
-};
-
 /* Local Function Prototypes */
 
 int e1000_up(struct e1000_adapter *adapter);
@@ -130,7 +103,7 @@ int e1000_set_spd_dplx(struct e1000_adap
 static int e1000_init_module(void);
 static void e1000_exit_module(void);
 static int e1000_probe(struct pci_dev *pdev, const struct pci_device_id *ent);
-static void e1000_remove(struct pci_dev *pdev);
+static void __devexit e1000_remove(struct pci_dev *pdev);
 static int e1000_sw_init(struct e1000_adapter *adapter);
 static int e1000_open(struct net_device *netdev);
 static int e1000_close(struct net_device *netdev);
@@ -155,8 +128,14 @@ static void e1000_update_stats(struct e1
 static inline void e1000_irq_disable(struct e1000_adapter *adapter);
 static inline void e1000_irq_enable(struct e1000_adapter *adapter);
 static void e1000_intr(int irq, void *data, struct pt_regs *regs);
-static boolean_t e1000_clean_tx_irq(struct e1000_adapter *adapter);
+#ifdef CONFIG_E1000_NAPI
+static int e1000_clean(struct net_device *netdev, int *budget);
+static boolean_t e1000_clean_rx_irq(struct e1000_adapter *adapter,
+                                    int *work_done, int work_to_do);
+#else
 static boolean_t e1000_clean_rx_irq(struct e1000_adapter *adapter);
+#endif
+static boolean_t e1000_clean_tx_irq(struct e1000_adapter *adapter);
 static void e1000_alloc_rx_buffers(struct e1000_adapter *adapter);
 static int e1000_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd);
 static int e1000_mii_ioctl(struct net_device *netdev, struct ifreq *ifr,
@@ -189,7 +168,6 @@ struct notifier_block e1000_notifier_reb
 	.priority	= 0
 };
 
-
 /* Exported from other modules */
 
 extern void e1000_check_options(struct e1000_adapter *adapter);
@@ -228,8 +206,9 @@ e1000_init_module(void)
 	printk(KERN_INFO "%s\n", e1000_copyright);
 
 	ret = pci_module_init(&e1000_driver);
-	if(ret >= 0)
+	if(ret >= 0) {
 		register_reboot_notifier(&e1000_notifier_reboot);
+	}
 	return ret;
 }
 
@@ -418,6 +397,10 @@ e1000_probe(struct pci_dev *pdev,
 	netdev->do_ioctl = &e1000_ioctl;
 	netdev->tx_timeout = &e1000_tx_timeout;
 	netdev->watchdog_timeo = 5 * HZ;
+#ifdef CONFIG_E1000_NAPI
+	netdev->poll = &e1000_clean;
+	netdev->weight = 64;
+#endif
 	netdev->vlan_rx_register = e1000_vlan_rx_register;
 	netdev->vlan_rx_add_vid = e1000_vlan_rx_add_vid;
 	netdev->vlan_rx_kill_vid = e1000_vlan_rx_kill_vid;
@@ -428,7 +411,6 @@ e1000_probe(struct pci_dev *pdev,
 	netdev->base_addr = adapter->hw.io_base;
 
 	adapter->bd_number = cards_found;
-	adapter->id_string = e1000_strings[ent->driver_data];
 
 	/* setup the private structure */
 
@@ -445,6 +427,12 @@ e1000_probe(struct pci_dev *pdev,
 		netdev->features = NETIF_F_SG;
 	}
 
+#ifdef NETIF_F_TSO
+	if((adapter->hw.mac_type >= e1000_82544) &&
+	   (adapter->hw.mac_type != e1000_82547))
+		netdev->features |= NETIF_F_TSO;
+#endif
+
 	if(pci_using_dac)
 		netdev->features |= NETIF_F_HIGHDMA;
 
@@ -483,15 +471,14 @@ e1000_probe(struct pci_dev *pdev,
 		(void (*)(void *))e1000_tx_timeout_task, netdev);
 
 	register_netdev(netdev);
-	memcpy(adapter->ifname, netdev->name, IFNAMSIZ);
-	adapter->ifname[IFNAMSIZ-1] = 0;
 
 	/* we're going to reset, so assume we have no link for now */
 
 	netif_carrier_off(netdev);
 	netif_stop_queue(netdev);
 
-	printk(KERN_INFO "%s: %s\n", netdev->name, adapter->id_string);
+	printk(KERN_INFO "%s: Intel(R) PRO/1000 Network Connection\n",
+	       netdev->name);
 	e1000_check_options(adapter);
 
 	/* Initial Wake on LAN setting
@@ -551,7 +538,6 @@ e1000_remove(struct pci_dev *pdev)
 
 	e1000_phy_hw_reset(&adapter->hw);
 
-
 	iounmap(adapter->hw.hw_addr);
 	pci_release_regions(pdev);
 
@@ -814,8 +800,9 @@ e1000_configure_tx(struct e1000_adapter 
 
 	e1000_config_collision_dist(&adapter->hw);
 
-	/* Setup Transmit Descriptor Settings for this adapter */
-	adapter->txd_cmd = E1000_TXD_CMD_IFCS | E1000_TXD_CMD_IDE;
+	/* Setup Transmit Descriptor Settings for eop descriptor */
+	adapter->txd_cmd = E1000_TXD_CMD_IDE | E1000_TXD_CMD_EOP |
+		E1000_TXD_CMD_IFCS;
 
 	if(adapter->hw.report_tx_early == 1)
 		adapter->txd_cmd |= E1000_TXD_CMD_RS;
@@ -1413,10 +1400,63 @@ e1000_watchdog(unsigned long data)
 
 #define E1000_TX_FLAGS_CSUM		0x00000001
 #define E1000_TX_FLAGS_VLAN		0x00000002
+#define E1000_TX_FLAGS_TSO		0x00000004
 #define E1000_TX_FLAGS_VLAN_MASK	0xffff0000
 #define E1000_TX_FLAGS_VLAN_SHIFT	16
 
 static inline boolean_t
+e1000_tso(struct e1000_adapter *adapter, struct sk_buff *skb)
+{
+#ifdef NETIF_F_TSO
+	struct e1000_context_desc *context_desc;
+	int i;
+	uint8_t ipcss, ipcso, tucss, tucso, hdr_len;
+	uint16_t ipcse, tucse, mss;
+
+	if(skb_shinfo(skb)->tso_size) {
+		hdr_len = ((skb->h.raw - skb->data) + (skb->h.th->doff << 2));
+		mss = skb_shinfo(skb)->tso_size;
+		skb->nh.iph->tot_len = 0;
+		skb->nh.iph->check = 0;
+		skb->h.th->check = ~csum_tcpudp_magic(skb->nh.iph->saddr,
+		                                      skb->nh.iph->daddr,
+		                                      0,
+		                                      IPPROTO_TCP,
+		                                      0);
+		ipcss = skb->nh.raw - skb->data;
+		ipcso = (void *)&(skb->nh.iph->check) - (void *)skb->data;
+		ipcse = skb->h.raw - skb->data - 1;
+		tucss = skb->h.raw - skb->data;
+		tucso = (void *)&(skb->h.th->check) - (void *)skb->data;
+		tucse = 0;
+
+		i = adapter->tx_ring.next_to_use;
+		context_desc = E1000_CONTEXT_DESC(adapter->tx_ring, i);
+
+		context_desc->lower_setup.ip_fields.ipcss  = ipcss;
+		context_desc->lower_setup.ip_fields.ipcso  = ipcso;
+		context_desc->lower_setup.ip_fields.ipcse  = cpu_to_le16(ipcse);
+		context_desc->upper_setup.tcp_fields.tucss = tucss;
+		context_desc->upper_setup.tcp_fields.tucso = tucso;
+		context_desc->upper_setup.tcp_fields.tucse = cpu_to_le16(tucse);
+		context_desc->tcp_seg_setup.fields.mss     = cpu_to_le16(mss);
+		context_desc->tcp_seg_setup.fields.hdr_len = hdr_len;
+		context_desc->cmd_and_length = cpu_to_le32(
+			E1000_TXD_CMD_DEXT | E1000_TXD_CMD_TSE |
+			E1000_TXD_CMD_IP | E1000_TXD_CMD_TCP |
+			(skb->len - (hdr_len)));
+
+		if(++i == adapter->tx_ring.count) i = 0;
+		adapter->tx_ring.next_to_use = i;
+
+		return TRUE;
+	}
+#endif
+
+	return FALSE;
+}
+
+static inline boolean_t
 e1000_tx_csum(struct e1000_adapter *adapter, struct sk_buff *skb)
 {
 	struct e1000_context_desc *context_desc;
@@ -1434,8 +1474,7 @@ e1000_tx_csum(struct e1000_adapter *adap
 		context_desc->upper_setup.tcp_fields.tucso = cso;
 		context_desc->upper_setup.tcp_fields.tucse = 0;
 		context_desc->tcp_seg_setup.data = 0;
-		context_desc->cmd_and_length =
-			cpu_to_le32(adapter->txd_cmd | E1000_TXD_CMD_DEXT);
+		context_desc->cmd_and_length = cpu_to_le32(E1000_TXD_CMD_DEXT);
 
 		if(++i == adapter->tx_ring.count) i = 0;
 		adapter->tx_ring.next_to_use = i;
@@ -1450,11 +1489,16 @@ e1000_tx_csum(struct e1000_adapter *adap
 #define E1000_MAX_DATA_PER_TXD	(1<<E1000_MAX_TXD_PWR)
 
 static inline int
-e1000_tx_map(struct e1000_adapter *adapter, struct sk_buff *skb)
+e1000_tx_map(struct e1000_adapter *adapter, struct sk_buff *skb,
+	unsigned int first)
 {
 	struct e1000_desc_ring *tx_ring = &adapter->tx_ring;
 	int len = skb->len, offset = 0, size, count = 0, i;
 
+#ifdef NETIF_F_TSO
+	int tso = skb_shinfo(skb)->tso_size;
+#endif
+	int nr_frags = skb_shinfo(skb)->nr_frags;
 	int f;
 	len -= skb->data_len;
 
@@ -1462,6 +1506,12 @@ e1000_tx_map(struct e1000_adapter *adapt
 
 	while(len) {
 		size = min(len, E1000_MAX_DATA_PER_TXD);
+#ifdef NETIF_F_TSO
+		/* Workaround for premature desc write-backs
+		 * in TSO mode.  Append 4-byte sentinel desc */
+		if(tso && !nr_frags && size == len && size > 4)
+			size -= 4;
+#endif
 		tx_ring->buffer_info[i].length = size;
 		tx_ring->buffer_info[i].dma =
 			pci_map_single(adapter->pdev,
@@ -1476,7 +1526,7 @@ e1000_tx_map(struct e1000_adapter *adapt
 		if(++i == tx_ring->count) i = 0;
 	}
 
-	for(f = 0; f < skb_shinfo(skb)->nr_frags; f++) {
+	for(f = 0; f < nr_frags; f++) {
 		struct skb_frag_struct *frag;
 
 		frag = &skb_shinfo(skb)->frags[f];
@@ -1485,6 +1535,12 @@ e1000_tx_map(struct e1000_adapter *adapt
 
 		while(len) {
 			size = min(len, E1000_MAX_DATA_PER_TXD);
+#ifdef NETIF_F_TSO
+			/* Workaround for premature desc write-backs
+			 * in TSO mode.  Append 4-byte sentinel desc */
+			if(tso && f == (nr_frags-1) && size == len && size > 4)
+				size -= 4;
+#endif
 			tx_ring->buffer_info[i].length = size;
 			tx_ring->buffer_info[i].dma =
 				pci_map_page(adapter->pdev,
@@ -1502,6 +1558,7 @@ e1000_tx_map(struct e1000_adapter *adapt
 	}
 	if(--i < 0) i = tx_ring->count - 1;
 	tx_ring->buffer_info[i].skb = skb;
+	tx_ring->buffer_info[first].next_to_watch = i;
 
 	return count;
 }
@@ -1511,11 +1568,14 @@ e1000_tx_queue(struct e1000_adapter *ada
 {
 	struct e1000_desc_ring *tx_ring = &adapter->tx_ring;
 	struct e1000_tx_desc *tx_desc = NULL;
-	uint32_t txd_upper, txd_lower;
+	uint32_t txd_upper = 0, txd_lower = E1000_TXD_CMD_IFCS;
 	int i;
 
-	txd_upper = 0;
-	txd_lower = adapter->txd_cmd;
+	if(tx_flags & E1000_TX_FLAGS_TSO) {
+		txd_lower |= E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D |
+		             E1000_TXD_CMD_TSE;
+		txd_upper |= (E1000_TXD_POPTS_IXSM | E1000_TXD_POPTS_TXSM) << 8;
+	}
 
 	if(tx_flags & E1000_TX_FLAGS_CSUM) {
 		txd_lower |= E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D;
@@ -1538,7 +1598,7 @@ e1000_tx_queue(struct e1000_adapter *ada
 		if(++i == tx_ring->count) i = 0;
 	}
 
-	tx_desc->lower.data |= cpu_to_le32(E1000_TXD_CMD_EOP);
+	tx_desc->lower.data |= cpu_to_le32(adapter->txd_cmd);
 
 	/* Force memory writes to complete before letting h/w
 	 * know there are new descriptors to fetch.  (Only
@@ -1598,6 +1658,7 @@ static int
 e1000_xmit_frame(struct sk_buff *skb, struct net_device *netdev)
 {
 	struct e1000_adapter *adapter = netdev->priv;
+	unsigned int first;
 	int tx_flags = 0;
 
 	if(skb->len <= 0) {
@@ -1623,10 +1684,14 @@ e1000_xmit_frame(struct sk_buff *skb, st
 		tx_flags |= (vlan_tx_tag_get(skb) << E1000_TX_FLAGS_VLAN_SHIFT);
 	}
 
-	if(e1000_tx_csum(adapter, skb))
+	first = adapter->tx_ring.next_to_use;
+	
+	if(e1000_tso(adapter, skb))
+		tx_flags |= E1000_TX_FLAGS_TSO;
+	else if(e1000_tx_csum(adapter, skb))
 		tx_flags |= E1000_TX_FLAGS_CSUM;
 
-	e1000_tx_queue(adapter, e1000_tx_map(adapter, skb), tx_flags);
+	e1000_tx_queue(adapter, e1000_tx_map(adapter, skb, first), tx_flags);
 
 	netdev->trans_start = jiffies;
 
@@ -1858,6 +1923,7 @@ e1000_update_stats(struct e1000_adapter 
 		}
 
 		if((hw->mac_type <= e1000_82546) &&
+		   (hw->phy_type == e1000_phy_m88) &&
 		   !e1000_read_phy_reg(hw, M88E1000_RX_ERR_CNTR, &phy_tmp))
 			adapter->phy_stats.receive_errors += phy_tmp;
 	}
@@ -1904,7 +1970,9 @@ e1000_intr(int irq, void *data, struct p
 	struct net_device *netdev = data;
 	struct e1000_adapter *adapter = netdev->priv;
 	uint32_t icr = E1000_READ_REG(&adapter->hw, ICR);
+#ifndef CONFIG_E1000_NAPI
 	int i;
+#endif
 
 	if(!icr)
 		return;  /* Not our interrupt */
@@ -1914,12 +1982,52 @@ e1000_intr(int irq, void *data, struct p
 		mod_timer(&adapter->watchdog_timer, jiffies);
 	}
 
+#ifdef CONFIG_E1000_NAPI
+	if(netif_rx_schedule_prep(netdev)) {
+
+		/* Disable interrupts and register for poll. The flush 
+		  of the posted write is intentionally left out.
+		*/
+
+		atomic_inc(&adapter->irq_sem);
+		E1000_WRITE_REG(&adapter->hw, IMC, ~0);
+		__netif_rx_schedule(netdev);
+	}
+#else
 	for(i = 0; i < E1000_MAX_INTR; i++)
 		if(!e1000_clean_rx_irq(adapter) &&
 		   !e1000_clean_tx_irq(adapter))
 			break;
+#endif
+}
 
+#ifdef CONFIG_E1000_NAPI
+/**
+ * e1000_clean - NAPI Rx polling callback
+ * @adapter: board private structure
+ **/
+
+static int
+e1000_clean(struct net_device *netdev, int *budget)
+{
+	struct e1000_adapter *adapter = netdev->priv;
+	int work_to_do = min(*budget, netdev->quota);
+	int work_done = 0;
+	
+	e1000_clean_tx_irq(adapter);
+	e1000_clean_rx_irq(adapter, &work_done, work_to_do);
+
+	*budget -= work_done;
+	netdev->quota -= work_done;
+	
+	if(work_done < work_to_do) {
+		netif_rx_complete(netdev);
+		e1000_irq_enable(adapter);
+	}
+
+	return (work_done >= work_to_do);
 }
+#endif
 
 /**
  * e1000_clean_tx_irq - Reclaim resources after transmit completes
@@ -1932,39 +2040,47 @@ e1000_clean_tx_irq(struct e1000_adapter 
 	struct e1000_desc_ring *tx_ring = &adapter->tx_ring;
 	struct net_device *netdev = adapter->netdev;
 	struct pci_dev *pdev = adapter->pdev;
-	struct e1000_tx_desc *tx_desc;
-	int i, cleaned = FALSE;
+	struct e1000_tx_desc *tx_desc, *eop_desc;
+	struct e1000_buffer *buffer_info;
+	int i, eop, cleaned = FALSE;
 
 	i = tx_ring->next_to_clean;
-	tx_desc = E1000_TX_DESC(*tx_ring, i);
+	eop = tx_ring->buffer_info[i].next_to_watch;
+	eop_desc = E1000_TX_DESC(*tx_ring, eop);
 
-	while(tx_desc->upper.data & cpu_to_le32(E1000_TXD_STAT_DD)) {
+	while(eop_desc->upper.data & cpu_to_le32(E1000_TXD_STAT_DD)) {
 
-		cleaned = TRUE;
+		for(cleaned = FALSE; !cleaned; ) {
+			tx_desc = E1000_TX_DESC(*tx_ring, i);
+			buffer_info = &tx_ring->buffer_info[i];
 
-		if(tx_ring->buffer_info[i].dma) {
+			if(buffer_info->dma) {
 
-			pci_unmap_page(pdev,
-			               tx_ring->buffer_info[i].dma,
-			               tx_ring->buffer_info[i].length,
-			               PCI_DMA_TODEVICE);
+				pci_unmap_page(pdev,
+					       buffer_info->dma,
+					       buffer_info->length,
+					       PCI_DMA_TODEVICE);
 
-			tx_ring->buffer_info[i].dma = 0;
-		}
+				buffer_info->dma = 0;
+			}
 
-		if(tx_ring->buffer_info[i].skb) {
+			if(buffer_info->skb) {
 
-			dev_kfree_skb_any(tx_ring->buffer_info[i].skb);
+				dev_kfree_skb_any(buffer_info->skb);
 
-			tx_ring->buffer_info[i].skb = NULL;
-		}
+				buffer_info->skb = NULL;
+			}
 
-		tx_desc->buffer_addr = 0;
-		tx_desc->lower.data = 0;
-		tx_desc->upper.data = 0;
+			tx_desc->buffer_addr = 0;
+			tx_desc->lower.data = 0;
+			tx_desc->upper.data = 0;
 
-		if(++i == tx_ring->count) i = 0;
-		tx_desc = E1000_TX_DESC(*tx_ring, i);
+			cleaned = (i == eop);
+			if(++i == tx_ring->count) i = 0;
+		}
+		
+		eop = tx_ring->buffer_info[i].next_to_watch;
+		eop_desc = E1000_TX_DESC(*tx_ring, eop);
 	}
 
 	tx_ring->next_to_clean = i;
@@ -1981,7 +2097,12 @@ e1000_clean_tx_irq(struct e1000_adapter 
  **/
 
 static boolean_t
+#ifdef CONFIG_E1000_NAPI
+e1000_clean_rx_irq(struct e1000_adapter *adapter, int *work_done,
+                   int work_to_do)
+#else
 e1000_clean_rx_irq(struct e1000_adapter *adapter)
+#endif
 {
 	struct e1000_desc_ring *rx_ring = &adapter->rx_ring;
 	struct net_device *netdev = adapter->netdev;
@@ -1998,6 +2119,13 @@ e1000_clean_rx_irq(struct e1000_adapter 
 
 	while(rx_desc->status & E1000_RXD_STAT_DD) {
 
+#ifdef CONFIG_E1000_NAPI
+		if(*work_done >= work_to_do)
+			break;
+
+		(*work_done)++;
+#endif
+
 		cleaned = TRUE;
 
 		pci_unmap_single(pdev,
@@ -2060,12 +2188,21 @@ e1000_clean_rx_irq(struct e1000_adapter 
 		e1000_rx_checksum(adapter, rx_desc, skb);
 
 		skb->protocol = eth_type_trans(skb, netdev);
+#ifdef CONFIG_E1000_NAPI
+		if(adapter->vlgrp && (rx_desc->status & E1000_RXD_STAT_VP)) {
+			vlan_hwaccel_receive_skb(skb, adapter->vlgrp,
+				(rx_desc->special & E1000_RXD_SPC_VLAN_MASK));
+		} else {
+			netif_receive_skb(skb);
+		}
+#else /* CONFIG_E1000_NAPI */
 		if(adapter->vlgrp && (rx_desc->status & E1000_RXD_STAT_VP)) {
 			vlan_hwaccel_rx(skb, adapter->vlgrp,
 				(rx_desc->special & E1000_RXD_SPC_VLAN_MASK));
 		} else {
 			netif_rx(skb);
 		}
+#endif /* CONFIG_E1000_NAPI */
 		netdev->last_rx = jiffies;
 
 		rx_desc->status = 0;
@@ -2518,7 +2655,6 @@ e1000_notify_reboot(struct notifier_bloc
 	return NOTIFY_DONE;
 }
 
-
 static int
 e1000_suspend(struct pci_dev *pdev, uint32_t state)
 {
diff -urNp linux-2/drivers/net/e1000/e1000_osdep.h linux-3/drivers/net/e1000/e1000_osdep.h
--- linux-2/drivers/net/e1000/e1000_osdep.h	
+++ linux-3/drivers/net/e1000/e1000_osdep.h	
@@ -27,7 +27,7 @@
 *******************************************************************************/
 
 
-/* glue for the OS independant part of e1000
+/* glue for the OS independent part of e1000
  * includes register access macros
  */
 
diff -urNp linux-2/drivers/net/e1000/Makefile linux-3/drivers/net/e1000/Makefile
--- linux-2/drivers/net/e1000/Makefile	
+++ linux-3/drivers/net/e1000/Makefile	
@@ -1,7 +1,7 @@
 ################################################################################
 #
 # 
-# Copyright(c) 1999 - 2002 Intel Corporation. All rights reserved.
+# Copyright(c) 1999 - 2003 Intel Corporation. All rights reserved.
 # 
 # This program is free software; you can redistribute it and/or modify it 
 # under the terms of the GNU General Public License as published by the Free 
diff -urNp linux-2/drivers/net/eepro100.c linux-3/drivers/net/eepro100.c
--- linux-2/drivers/net/eepro100.c	
+++ linux-3/drivers/net/eepro100.c	
@@ -2392,6 +2392,7 @@ static struct pci_device_id eepro100_pci
 	{ PCI_VENDOR_ID_INTEL, 0x103C, PCI_ANY_ID, PCI_ANY_ID, },
 	{ PCI_VENDOR_ID_INTEL, 0x103D, PCI_ANY_ID, PCI_ANY_ID, },
 	{ PCI_VENDOR_ID_INTEL, 0x103E, PCI_ANY_ID, PCI_ANY_ID, },
+	{ PCI_VENDOR_ID_INTEL, 0x1050, PCI_ANY_ID, PCI_ANY_ID, },
 	{ PCI_VENDOR_ID_INTEL, 0x1059, PCI_ANY_ID, PCI_ANY_ID, },
 	{ PCI_VENDOR_ID_INTEL, 0x1227, PCI_ANY_ID, PCI_ANY_ID, },
 	{ PCI_VENDOR_ID_INTEL, 0x1228, PCI_ANY_ID, PCI_ANY_ID, },
diff -urNp linux-2/drivers/net/Makefile linux-3/drivers/net/Makefile
--- linux-2/drivers/net/Makefile	
+++ linux-3/drivers/net/Makefile	
@@ -229,7 +229,7 @@ obj-$(CONFIG_TUN) += tun.o
 obj-$(CONFIG_ETHER00) +=ether00.o
 obj-$(CONFIG_DL2K) += dl2k.o
 obj-$(CONFIG_R8169) += r8169.o
-obj-$(CONFIG_AMD8111_ETH) += amd8111e.o
+obj-$(CONFIG_AMD8111_ETH) += amd8111e.o mii.o
 
 # non-drivers/net drivers who want mii lib
 obj-$(CONFIG_PCMCIA_SMC91C92) += mii.o
diff -urNp linux-2/drivers/net/ns83820.c linux-3/drivers/net/ns83820.c
--- linux-2/drivers/net/ns83820.c	
+++ linux-3/drivers/net/ns83820.c	
@@ -1766,7 +1766,7 @@ static int __devinit ns83820_init_one(st
 	int using_dac = 0;
 
 	/* See if we can set the dma mask early on; failure is fatal. */
-	if (TRY_DAC && !pci_set_dma_mask(pci_dev, 0xffffffffffffffff)) {
+	if (TRY_DAC && !pci_set_dma_mask(pci_dev, 0xffffffffffffffffULL)) {
 		using_dac = 1;
 	} else if (!pci_set_dma_mask(pci_dev, 0xffffffff)) {
 		using_dac = 0;
diff -urNp linux-2/drivers/net/pci-skeleton.c linux-3/drivers/net/pci-skeleton.c
--- linux-2/drivers/net/pci-skeleton.c	
+++ linux-3/drivers/net/pci-skeleton.c	
@@ -602,7 +602,7 @@ static int __devinit netdrv_init_board (
 	*ioaddr_out = NULL;
 	*dev_out = NULL;
 
-	/* dev zeroed in init_etherdev */
+	/* dev zeroed in alloc_etherdev */
 	dev = alloc_etherdev (sizeof (*tp));
 	if (dev == NULL) {
 		printk (KERN_ERR PFX "unable to alloc new ethernet\n");
@@ -789,7 +789,7 @@ static int __devinit netdrv_init_one (st
 	dev->irq = pdev->irq;
 	dev->base_addr = (unsigned long) ioaddr;
 
-	/* dev->priv/tp zeroed and aligned in init_etherdev */
+	/* dev->priv/tp zeroed and aligned in alloc_etherdev */
 	tp = dev->priv;
 
 	/* note: tp->chipset set in netdrv_init_board */
diff -urNp linux-2/drivers/net/pcmcia/aironet4500_cs.c linux-3/drivers/net/pcmcia/aironet4500_cs.c
--- linux-2/drivers/net/pcmcia/aironet4500_cs.c	
+++ linux-3/drivers/net/pcmcia/aironet4500_cs.c	
@@ -282,7 +282,7 @@ static dev_link_t *awc_attach(void)
 	};
 	memset(dev,0,sizeof(struct net_device));
 	dev->priv = kmalloc(sizeof(struct awc_private), GFP_KERNEL);
-	if (!dev->priv ) {printk(KERN_CRIT "out of mem on dev priv alloc \n"); return NULL;};
+	if (!dev->priv ) {printk(KERN_CRIT "out of mem on dev priv alloc \n"); kfree(dev); return NULL;};
 	memset(dev->priv,0,sizeof(struct awc_private));
 	
 //	link->dev->minor = dev->minor;
diff -urNp linux-2/drivers/net/pcnet32.c linux-3/drivers/net/pcnet32.c
--- linux-2/drivers/net/pcnet32.c	
+++ linux-3/drivers/net/pcnet32.c	
@@ -974,7 +974,9 @@ pcnet32_init_ring(struct net_device *dev
 	    }
 	    skb_reserve (rx_skbuff, 2);
 	}
-        lp->rx_dma_addr[i] = pci_map_single(lp->pci_dev, rx_skbuff->tail, rx_skbuff->len, PCI_DMA_FROMDEVICE);
+
+	if (lp->rx_dma_addr[i] == 0) 
+		lp->rx_dma_addr[i] = pci_map_single(lp->pci_dev, rx_skbuff->tail, rx_skbuff->len, PCI_DMA_FROMDEVICE);
 	lp->rx_ring[i].base = (u32)le32_to_cpu(lp->rx_dma_addr[i]);
 	lp->rx_ring[i].buf_length = le16_to_cpu(-PKT_BUF_SZ);
 	lp->rx_ring[i].status = le16_to_cpu(0x8000);
@@ -1009,7 +1011,7 @@ pcnet32_restart(struct net_device *dev, 
     /* ReInit Ring */
     lp->a.write_csr (ioaddr, 0, 1);
     i = 0;
-    while (i++ < 100)
+    while (i++ < 1000)
 	if (lp->a.read_csr (ioaddr, 0) & 0x0100)
 	    break;
 
@@ -1100,6 +1102,7 @@ pcnet32_start_xmit(struct sk_buff *skb, 
     lp->tx_skbuff[entry] = skb;
     lp->tx_dma_addr[entry] = pci_map_single(lp->pci_dev, skb->data, skb->len, PCI_DMA_TODEVICE);
     lp->tx_ring[entry].base = (u32)le32_to_cpu(lp->tx_dma_addr[entry]);
+    wmb(); /* Make sure owner changes after all others are visible */
     lp->tx_ring[entry].status = le16_to_cpu(status);
 
     lp->cur_tx++;
diff -urNp linux-2/drivers/net/ppp_deflate.c linux-3/drivers/net/ppp_deflate.c
--- linux-2/drivers/net/ppp_deflate.c	
+++ linux-3/drivers/net/ppp_deflate.c	
@@ -394,10 +394,10 @@ z_decompress(arg, ibuf, isize, obuf, osi
 
 	/* Check the sequence number. */
 	seq = (ibuf[PPP_HDRLEN] << 8) + ibuf[PPP_HDRLEN+1];
-	if (seq != state->seqno) {
+	if (seq != (state->seqno & 0xffff)) {
 		if (state->debug)
 			printk(KERN_DEBUG "z_decompress%d: bad seq # %d, expected %d\n",
-			       state->unit, seq, state->seqno);
+			       state->unit, seq, state->seqno & 0xffff);
 		return DECOMP_ERROR;
 	}
 	++state->seqno;
diff -urNp linux-2/drivers/net/ppp_generic.c linux-3/drivers/net/ppp_generic.c
--- linux-2/drivers/net/ppp_generic.c	
+++ linux-3/drivers/net/ppp_generic.c	
@@ -666,8 +666,10 @@ static int ppp_ioctl(struct inode *inode
 			if (code == 0)
 				break;
 			err = -EFAULT;
-			if (copy_from_user(code, uprog.filter, len))
+			if (copy_from_user(code, uprog.filter, len)) {
+				kfree(code);
 				break;
+			}
 			err = sk_chk_filter(code, uprog.len);
 			if (err) {
 				kfree(code);
diff -urNp linux-2/drivers/net/r8169.c linux-3/drivers/net/r8169.c
--- linux-2/drivers/net/r8169.c	
+++ linux-3/drivers/net/r8169.c	
@@ -42,6 +42,7 @@ VERSION 1.2	<2002/11/30>
 #include <linux/delay.h>
 #include <linux/crc32.h>
 #include <linux/init.h>
+
 #include <asm/io.h>
 
 #define RTL8169_VERSION "1.2"
@@ -364,8 +365,8 @@ rtl8169_init_board(struct pci_dev *pdev,
 	*ioaddr_out = NULL;
 	*dev_out = NULL;
 
-	// dev zeroed in init_etherdev 
-	dev = init_etherdev(NULL, sizeof (*tp));
+	// dev zeroed in alloc_etherdev 
+	dev = alloc_etherdev(sizeof (*tp));
 	if (dev == NULL) {
 		printk(KERN_ERR PFX "unable to alloc new ethernet\n");
 		return -ENOMEM;
@@ -389,18 +390,18 @@ rtl8169_init_board(struct pci_dev *pdev,
 		printk(KERN_ERR PFX
 		       "region #1 not an MMIO resource, aborting\n");
 		rc = -ENODEV;
-		goto err_out;
+		goto err_out_disable;
 	}
 	// check for weird/broken PCI region reporting
 	if (mmio_len < RTL_MIN_IO_SIZE) {
 		printk(KERN_ERR PFX "Invalid PCI region size(s), aborting\n");
 		rc = -ENODEV;
-		goto err_out;
+		goto err_out_disable;
 	}
 
 	rc = pci_request_regions(pdev, dev->name);
 	if (rc)
-		goto err_out;
+		goto err_out_disable;
 
 	// enable PCI bus-mastering
 	pci_set_master(pdev);
@@ -448,8 +449,10 @@ match:
 err_out_free_res:
 	pci_release_regions(pdev);
 
+err_out_disable:
+	pci_disable_device(pdev);
+
 err_out:
-	unregister_netdev(dev);
 	kfree(dev);
 	return rc;
 }
@@ -462,7 +465,7 @@ rtl8169_init_one(struct pci_dev *pdev, c
 	void *ioaddr = NULL;
 	static int board_idx = -1;
 	static int printed_version = 0;
-	int i;
+	int i, rc;
 	int option = -1, Cap10_100 = 0, Cap1000 = 0;
 
 	assert(pdev != NULL);
@@ -475,20 +478,18 @@ rtl8169_init_one(struct pci_dev *pdev, c
 		printed_version = 1;
 	}
 
-	i = rtl8169_init_board(pdev, &dev, &ioaddr);
-	if (i < 0) {
-		return i;
-	}
+	rc = rtl8169_init_board(pdev, &dev, &ioaddr);
+	if (rc)
+		return rc;
 
 	tp = dev->priv;
 	assert(ioaddr != NULL);
 	assert(dev != NULL);
 	assert(tp != NULL);
 
-	// Get MAC address //
-	for (i = 0; i < MAC_ADDR_LEN; i++) {
+	// Get MAC address.  FIXME: read EEPROM
+	for (i = 0; i < MAC_ADDR_LEN; i++)
 		dev->dev_addr[i] = RTL_R8(MAC0 + i);
-	}
 
 	dev->open = rtl8169_open;
 	dev->hard_start_xmit = rtl8169_start_xmit;
@@ -505,11 +506,20 @@ rtl8169_init_one(struct pci_dev *pdev, c
 	tp->pci_dev = pdev;
 	tp->mmio_addr = ioaddr;
 
+	spin_lock_init(&tp->lock);
+
+	rc = register_netdev(dev);
+	if (rc) {
+		iounmap(ioaddr);
+		pci_release_regions(pdev);
+		pci_disable_device(pdev);
+		kfree(dev);
+		return rc;
+	}
+
 	printk(KERN_DEBUG "%s: Identified chip type is '%s'.\n", dev->name,
 	       rtl_chip_info[tp->chipset].name);
 
-	spin_lock_init(&tp->lock);
-
 	pci_set_drvdata(pdev, dev);
 
 	printk(KERN_INFO "%s: %s at 0x%lx, "
@@ -621,7 +631,7 @@ static void __devexit
 rtl8169_remove_one(struct pci_dev *pdev)
 {
 	struct net_device *dev = pci_get_drvdata(pdev);
-	struct rtl8169_private *tp = (struct rtl8169_private *) (dev->priv);
+	struct rtl8169_private *tp = dev->priv;
 
 	assert(dev != NULL);
 	assert(tp != NULL);
@@ -634,6 +644,7 @@ rtl8169_remove_one(struct pci_dev *pdev)
 	memset(dev, 0xBC,
 	       sizeof (struct net_device) + sizeof (struct rtl8169_private));
 
+	pci_disable_device(pdev);
 	kfree(dev);
 	pci_set_drvdata(pdev, NULL);
 }
@@ -821,10 +832,9 @@ rtl8169_start_xmit(struct sk_buff *skb, 
 	void *ioaddr = tp->mmio_addr;
 	int entry = tp->cur_tx % NUM_TX_DESC;
 
-	if(skb->len < ETH_ZLEN)
-	{
+	if (skb->len < ETH_ZLEN) {
 		skb = skb_padto(skb, ETH_ZLEN);
-		if(skb == NULL)
+		if (skb == NULL)
 			return 0;
 	}
 	
diff -urNp linux-2/drivers/net/sis900.c linux-3/drivers/net/sis900.c
--- linux-2/drivers/net/sis900.c	
+++ linux-3/drivers/net/sis900.c	
@@ -201,7 +201,7 @@ static void sis900_interrupt(int irq, vo
 static int sis900_close(struct net_device *net_dev);
 static int mii_ioctl(struct net_device *net_dev, struct ifreq *rq, int cmd);
 static struct net_device_stats *sis900_get_stats(struct net_device *net_dev);
-static u16 sis900_compute_hashtable_index(u8 *addr, u8 revision);
+static u16 sis900_mcast_bitnr(u8 *addr, u8 revision);
 static void set_rx_mode(struct net_device *net_dev);
 static void sis900_reset(struct net_device *net_dev);
 static void sis630_set_eq(struct net_device *net_dev, u8 revision);
@@ -213,7 +213,7 @@ static void sis900_auto_negotiate(struct
 static void sis900_set_mode (long ioaddr, int speed, int duplex);
 
 /**
- *	sis900_get_mac_addr: - Get MAC address for stand alone SiS900 model
+ *	sis900_get_mac_addr - Get MAC address for stand alone SiS900 model
  *	@pci_dev: the sis900 pci device
  *	@net_dev: the net device to get address for 
  *
@@ -243,7 +243,7 @@ static int __devinit sis900_get_mac_addr
 }
 
 /**
- *	sis630e_get_mac_addr: - Get MAC address for SiS630E model
+ *	sis630e_get_mac_addr - Get MAC address for SiS630E model
  *	@pci_dev: the sis900 pci device
  *	@net_dev: the net device to get address for 
  *
@@ -276,7 +276,7 @@ static int __devinit sis630e_get_mac_add
 
 
 /**
- *	sis635_get_mac_addr: - Get MAC address for SIS635 model
+ *	sis635_get_mac_addr - Get MAC address for SIS635 model
  *	@pci_dev: the sis900 pci device
  *	@net_dev: the net device to get address for 
  *
@@ -312,7 +312,7 @@ static int __devinit sis635_get_mac_addr
 }
 
 /**
- *	sis96x_get_mac_addr: - Get MAC address for SiS962 or SiS963 model
+ *	sis96x_get_mac_addr - Get MAC address for SiS962 or SiS963 model
  *	@pci_dev: the sis900 pci device
  *	@net_dev: the net device to get address for 
  *
@@ -354,7 +354,7 @@ static int __devinit sis96x_get_mac_addr
 }
 
 /**
- *	sis900_probe: - Probe for sis900 device
+ *	sis900_probe - Probe for sis900 device
  *	@pci_dev: the sis900 pci device
  *	@pci_id: the pci device ID
  *
@@ -499,7 +499,7 @@ static int __devinit sis900_probe (struc
 }
 
 /**
- *	sis900_mii_probe: - Probe MII PHY for sis900
+ *	sis900_mii_probe - Probe MII PHY for sis900
  *	@net_dev: the net device to probe for
  *	
  *	Search for total of 32 possible mii phy addresses.
@@ -528,7 +528,7 @@ static int __init sis900_mii_probe (stru
 			mii_status = mdio_read(net_dev, phy_addr, MII_STATUS);
 
 		if (mii_status == 0xffff || mii_status == 0x0000)
-			/* the mii is not accessable, try next one */
+			/* the mii is not accessible, try next one */
 			continue;
 		
 		if ((mii_phy = kmalloc(sizeof(struct mii_phy), GFP_KERNEL)) == NULL) {
@@ -593,7 +593,7 @@ static int __init sis900_mii_probe (stru
 			current->state = TASK_INTERRUPTIBLE;
 			schedule_timeout(0);
 			poll_bit ^= (mdio_read(net_dev, sis_priv->cur_phy, MII_STATUS) & poll_bit);
-			if (jiffies >= timeout) {
+			if (time_after_eq(jiffies, timeout)) {
 				printk(KERN_WARNING "%s: reset phy and link down now\n", net_dev->name);
 				return -ETIME;
 			}
@@ -619,7 +619,7 @@ static int __init sis900_mii_probe (stru
 }
 
 /**
- *	sis900_default_phy: - Select default PHY for sis900 mac.
+ *	sis900_default_phy - Select default PHY for sis900 mac.
  *	@net_dev: the net device to probe for
  *
  *	Select first detected PHY with link as default.
@@ -672,7 +672,7 @@ static u16 sis900_default_phy(struct net
 
 
 /**
- * 	sis900_set_capability: - set the media capability of network adapter.
+ * 	sis900_set_capability - set the media capability of network adapter.
  *	@net_dev : the net device to probe for
  *	@phy : default PHY
  *
@@ -702,7 +702,7 @@ static void sis900_set_capability( struc
 #define eeprom_delay()  inl(ee_addr)
 
 /**
- *	read_eeprom: - Read Serial EEPROM
+ *	read_eeprom - Read Serial EEPROM
  *	@ioaddr: base i/o address
  *	@location: the EEPROM location to read
  *
@@ -752,7 +752,7 @@ static u16 __devinit read_eeprom(long io
 
 /* Read and write the MII management registers using software-generated
    serial MDIO protocol. Note that the command bits and data bits are
-   send out seperately */
+   send out separately */
 #define mdio_delay()    inl(mdio_addr)
 
 static void mdio_idle(long mdio_addr)
@@ -777,7 +777,7 @@ static void mdio_reset(long mdio_addr)
 }
 
 /**
- *	mdio_read: - read MII PHY register
+ *	mdio_read - read MII PHY register
  *	@net_dev: the net device to read
  *	@phy_id: the phy address to read
  *	@location: the phy regiester id to read
@@ -819,7 +819,7 @@ static u16 mdio_read(struct net_device *
 }
 
 /**
- *	mdio_write: - write MII PHY register
+ *	mdio_write - write MII PHY register
  *	@net_dev: the net device to write
  *	@phy_id: the phy address to write
  *	@location: the phy regiester id to write
@@ -873,7 +873,7 @@ static void mdio_write(struct net_device
 
 
 /**
- *	sis900_reset_phy: - reset sis900 mii phy.
+ *	sis900_reset_phy - reset sis900 mii phy.
  *	@net_dev: the net device to write
  *	@phy_addr: default phy address
  *
@@ -896,7 +896,7 @@ static u16 sis900_reset_phy(struct net_d
 }
 
 /**
- *	sis900_open: - open sis900 device
+ *	sis900_open - open sis900 device
  *	@net_dev: the net device to open
  *
  *	Do some initialization and start net interface.
@@ -953,7 +953,7 @@ sis900_open(struct net_device *net_dev)
 }
 
 /**
- *	sis900_init_rxfilter: - Initialize the Rx filter
+ *	sis900_init_rxfilter - Initialize the Rx filter
  *	@net_dev: the net device to initialize for
  *
  *	Set receive filter address to our MAC address
@@ -991,7 +991,7 @@ sis900_init_rxfilter (struct net_device 
 }
 
 /**
- *	sis900_init_tx_ring: - Initialize the Tx descriptor ring
+ *	sis900_init_tx_ring - Initialize the Tx descriptor ring
  *	@net_dev: the net device to initialize for
  *
  *	Initialize the Tx descriptor ring, 
@@ -1024,7 +1024,7 @@ sis900_init_tx_ring(struct net_device *n
 }
 
 /**
- *	sis900_init_rx_ring: - Initialize the Rx descriptor ring
+ *	sis900_init_rx_ring - Initialize the Rx descriptor ring
  *	@net_dev: the net device to initialize for
  *
  *	Initialize the Rx descriptor ring, 
@@ -1078,7 +1078,7 @@ sis900_init_rx_ring(struct net_device *n
 }
 
 /**
- *	sis630_set_eq: - set phy equalizer value for 630 LAN
+ *	sis630_set_eq - set phy equalizer value for 630 LAN
  *	@net_dev: the net device to set equalizer value
  *	@revision: 630 LAN revision number
  *
@@ -1166,7 +1166,7 @@ static void sis630_set_eq(struct net_dev
 }
 
 /**
- *	sis900_timer: - sis900 timer routine
+ *	sis900_timer - sis900 timer routine
  *	@data: pointer to sis900 net device
  *
  *	On each timer ticks we check two things, 
@@ -1236,7 +1236,7 @@ static void sis900_timer(unsigned long d
 }
 
 /**
- *	sis900_check_mode: - check the media mode for sis900
+ *	sis900_check_mode - check the media mode for sis900
  *	@net_dev: the net device to be checked
  *	@mii_phy: the mii phy
  *
@@ -1267,7 +1267,7 @@ static void sis900_check_mode (struct ne
 }
 
 /**
- *	sis900_set_mode: - Set the media mode of mac register.
+ *	sis900_set_mode - Set the media mode of mac register.
  *	@ioaddr: the address of the device
  *	@speed : the transmit speed to be determined
  *	@duplex: the duplex mode to be determined
@@ -1311,7 +1311,7 @@ static void sis900_set_mode (long ioaddr
 }
 
 /**
- *	sis900_auto_negotiate:  Set the Auto-Negotiation Enable/Reset bit.
+ *	sis900_auto_negotiate - Set the Auto-Negotiation Enable/Reset bit.
  *	@net_dev: the net device to read mode for
  *	@phy_addr: mii phy address
  *
@@ -1345,7 +1345,7 @@ static void sis900_auto_negotiate(struct
 
 
 /**
- *	sis900_read_mode: - read media mode for sis900 internal phy
+ *	sis900_read_mode - read media mode for sis900 internal phy
  *	@net_dev: the net device to read mode for
  *	@speed  : the transmit speed to be determined
  *	@duplex : the duplex mode to be determined
@@ -1402,7 +1402,7 @@ static void sis900_read_mode(struct net_
 }
 
 /**
- *	sis900_tx_timeout: - sis900 transmit timeout routine
+ *	sis900_tx_timeout - sis900 transmit timeout routine
  *	@net_dev: the net device to transmit
  *
  *	print transmit timeout status
@@ -1457,7 +1457,7 @@ static void sis900_tx_timeout(struct net
 }
 
 /**
- *	sis900_start_xmit: - sis900 start transmit routine
+ *	sis900_start_xmit - sis900 start transmit routine
  *	@skb: socket buffer pointer to put the data being transmitted
  *	@net_dev: the net device to transmit with
  *
@@ -1527,7 +1527,7 @@ sis900_start_xmit(struct sk_buff *skb, s
 }
 
 /**
- *	sis900_interrupt: - sis900 interrupt handler
+ *	sis900_interrupt - sis900 interrupt handler
  *	@irq: the irq number
  *	@dev_instance: the client data object
  *	@regs: snapshot of processor context
@@ -1586,7 +1586,7 @@ static void sis900_interrupt(int irq, vo
 }
 
 /**
- *	sis900_rx: - sis900 receive routine
+ *	sis900_rx - sis900 receive routine
  *	@net_dev: the net device which receives data
  *
  *	Process receive interrupt events, 
@@ -1725,7 +1725,7 @@ static int sis900_rx(struct net_device *
 }
 
 /**
- *	sis900_finish_xmit: - finish up transmission of packets
+ *	sis900_finish_xmit - finish up transmission of packets
  *	@net_dev: the net device to be transmitted on
  *
  *	Check for error condition and free socket buffer etc 
@@ -1795,7 +1795,7 @@ static void sis900_finish_xmit (struct n
 }
 
 /**
- *	sis900_close: - close sis900 device 
+ *	sis900_close - close sis900 device 
  *	@net_dev: the net device to be closed
  *
  *	Disable interrupts, stop the Tx and Rx Status Machine 
@@ -1851,7 +1851,7 @@ sis900_close(struct net_device *net_dev)
 }
 
 /**
- *	netdev_ethtool_ioctl: - For the basic support of ethtool
+ *	netdev_ethtool_ioctl - For the basic support of ethtool
  *	@net_dev: the net device to command for
  *	@useraddr: start address of interface request
  *
@@ -1885,7 +1885,7 @@ static int netdev_ethtool_ioctl (struct 
 }
 
 /**
- *	mii_ioctl: - process MII i/o control command 
+ *	mii_ioctl - process MII i/o control command 
  *	@net_dev: the net device to command for
  *	@rq: parameter for command
  *	@cmd: the i/o command
@@ -1924,7 +1924,7 @@ static int mii_ioctl(struct net_device *
 }
 
 /**
- *	sis900_get_stats: - Get sis900 read/write statistics 
+ *	sis900_get_stats - Get sis900 read/write statistics 
  *	@net_dev: the net device to get statistics for
  *
  *	get tx/rx statistics for sis900
@@ -1939,7 +1939,7 @@ sis900_get_stats(struct net_device *net_
 }
 
 /**
- *	sis900_set_config: - Set media type by net_device.set_config 
+ *	sis900_set_config - Set media type by net_device.set_config 
  *	@dev: the net device for media type change
  *	@map: ifmap passed by ifconfig
  *
@@ -1976,7 +1976,7 @@ static int sis900_set_config(struct net_
 			status = mdio_read(dev, mii_phy->phy_addr, MII_CONTROL);
                 
 			/* enable auto negotiation and reset the negotioation
-			   (I dont really know what the auto negatiotiation reset
+			   (I don't really know what the auto negatiotiation reset
 			   really means, but it sounds for me right to do one here)*/
 			mdio_write(dev, mii_phy->phy_addr,
 				   MII_CONTROL, status | MII_CNTL_AUTO | MII_CNTL_RST_AUTO);
@@ -2036,7 +2036,7 @@ static int sis900_set_config(struct net_
 }
 
 /**
- *	sis900_compute_hashtable_index: - compute hashtable index 
+ *	sis900_mcast_bitnr - compute hashtable index 
  *	@addr: multicast address
  *	@revision: revision id of chip
  *
@@ -2046,7 +2046,7 @@ static int sis900_set_config(struct net_
  *   	multicast hash table. 
  */
 
-static u16 sis900_compute_hashtable_index(u8 *addr, u8 revision)
+static inline u16 sis900_mcast_bitnr(u8 *addr, u8 revision)
 {
 
 	u32 crc = ether_crc(6, addr);
@@ -2059,7 +2059,7 @@ static u16 sis900_compute_hashtable_inde
 }
 
 /**
- *	set_rx_mode: - Set SiS900 receive mode 
+ *	set_rx_mode - Set SiS900 receive mode 
  *	@net_dev: the net device to be set
  *
  *	Set SiS900 receive mode for promiscuous, multicast, or broadcast mode.
@@ -2100,9 +2100,11 @@ static void set_rx_mode(struct net_devic
 		struct dev_mc_list *mclist;
 		rx_mode = RFAAB;
 		for (i = 0, mclist = net_dev->mc_list; mclist && i < net_dev->mc_count;
-		     i++, mclist = mclist->next)
-			set_bit(sis900_compute_hashtable_index(mclist->dmi_addr, revision),
-				mc_filter);
+		     i++, mclist = mclist->next) {
+			unsigned int bit_nr =
+				sis900_mcast_bitnr(mclist->dmi_addr, revision);
+			mc_filter[bit_nr >> 4] |= (1 << bit_nr);
+		}
 	}
 
 	/* update Multicast Hash Table in Receive Filter */
@@ -2131,7 +2133,7 @@ static void set_rx_mode(struct net_devic
 }
 
 /**
- *	sis900_reset: - Reset sis900 MAC 
+ *	sis900_reset - Reset sis900 MAC 
  *	@net_dev: the net device to reset
  *
  *	reset sis900 MAC and wait until finished
@@ -2166,7 +2168,7 @@ static void sis900_reset(struct net_devi
 }
 
 /**
- *	sis900_remove: - Remove sis900 device 
+ *	sis900_remove - Remove sis900 device 
  *	@pci_dev: the pci device to be removed
  *
  *	remove and release SiS900 net device
@@ -2195,10 +2197,10 @@ static void __devexit sis900_remove(stru
 }
 
 static struct pci_driver sis900_pci_driver = {
-	name:		SIS900_MODULE_NAME,
-	id_table:	sis900_pci_tbl,
-	probe:		sis900_probe,
-	remove:		__devexit_p(sis900_remove),
+	.name		= SIS900_MODULE_NAME,
+	.id_table	= sis900_pci_tbl,
+	.probe		= sis900_probe,
+	.remove		= __devexit_p(sis900_remove),
 };
 
 static int __init sis900_init_module(void)
diff -urNp linux-2/drivers/net/sk98lin/skge.c linux-3/drivers/net/sk98lin/skge.c
--- linux-2/drivers/net/sk98lin/skge.c	
+++ linux-3/drivers/net/sk98lin/skge.c	
@@ -498,7 +498,7 @@ static int __init skge_probe (void)
 		}
 
 		/* Configure DMA attributes. */
-		if (pci_set_dma_mask(pdev, (u64) 0xffffffffffffffff) &&
+		if (pci_set_dma_mask(pdev, (u64) 0xffffffffffffffffULL) &&
 			pci_set_dma_mask(pdev, (u64) 0xffffffff))
 			continue;
 
diff -urNp linux-2/drivers/net/sonic.c linux-3/drivers/net/sonic.c
--- linux-2/drivers/net/sonic.c	
+++ linux-3/drivers/net/sonic.c	
@@ -113,15 +113,6 @@ static int sonic_send_packet(struct sk_b
 	if (sonic_debug > 2)
 		printk("sonic_send_packet: skb=%p, dev=%p\n", skb, dev);
 
-	/* 
-	 * Block a timer-based transmit from overlapping.  This could better be
-	 * done with atomic_swap(1, dev->tbusy), but set_bit() works as well.
-	 */
-	if (test_and_set_bit(0, (void *) &dev->tbusy) != 0) {
-		printk("%s: Transmitter access conflict.\n", dev->name);
-		return 1;
-	}
-
 	/*
 	 * Map the packet data into the logical DMA address space
 	 */
diff -urNp linux-2/drivers/net/sundance.c linux-3/drivers/net/sundance.c
--- linux-2/drivers/net/sundance.c	
+++ linux-3/drivers/net/sundance.c	
@@ -71,19 +71,32 @@
 
 	Versin LK1.06b (D-Link):
 	- New tx scheme, adaptive tx_coalesce
-
+	
+	Version LK1.07 (D-Link):
+	- Fix tx bugs in big-endian machines
+	- Remove unused max_interrupt_work module parameter, the new 
+	  NAPI-like rx scheme doesn't need it.
+	- Remove redundancy get_stats() in intr_handler(), those 
+	  I/O access could affect performance in ARM-based system
+	- Add Linux software VLAN support
+	
+	Version LK1.08 (D-Link):
+	- Fix bug of custom mac address 
+	(StationAddr register only accept word write) 
+
+	Version LK1.09 (D-Link):
+	- Fix the flowctrl bug.	
+	- Set Pause bit in MII ANAR if flow control enabled.	
 */
 
 #define DRV_NAME	"sundance"
-#define DRV_VERSION	"1.01+LK1.06b"
-#define DRV_RELDATE	"6-Nov-2002"
+#define DRV_VERSION	"1.01+LK1.09a"
+#define DRV_RELDATE	"16-May-2003"
 
 
 /* The user-configurable values.
    These may be modified when a driver module is loaded.*/
 static int debug = 1;			/* 1 normal messages, 0 quiet .. 7 verbose. */
-/* Maximum events (Rx packets, etc.) to handle at each interrupt. */
-static int max_interrupt_work = 0;
 /* Maximum number of multicast addresses to filter (vs. rx-all-multicast).
    Typical is a 64 element hash table based on the Ethernet CRC.  */
 static int multicast_filter_limit = 32;
@@ -129,8 +142,7 @@ static char *media[MAX_UNITS];
 /* Operational parameters that usually are not changed. */
 /* Time in jiffies before concluding the transmitter is hung. */
 #define TX_TIMEOUT  (4*HZ)
-
-#define PKT_BUF_SZ		1536			/* Size of each temporary Rx buffer.*/
+#define PKT_BUF_SZ		1536	/* Size of each temporary Rx buffer.*/
 
 #ifndef __KERNEL__
 #define __KERNEL__
@@ -181,12 +193,10 @@ MODULE_AUTHOR("Donald Becker <becker@scy
 MODULE_DESCRIPTION("Sundance Alta Ethernet driver");
 MODULE_LICENSE("GPL");
 
-MODULE_PARM(max_interrupt_work, "i");
 MODULE_PARM(debug, "i");
 MODULE_PARM(rx_copybreak, "i");
 MODULE_PARM(media, "1-" __MODULE_STRING(MAX_UNITS) "s");
 MODULE_PARM(flowctrl, "i");
-MODULE_PARM_DESC(max_interrupt_work, "Sundance Alta maximum events handled per interrupt");
 MODULE_PARM_DESC(debug, "Sundance Alta debug level (0-5)");
 MODULE_PARM_DESC(rx_copybreak, "Sundance Alta copy breakpoint for copy-only-tiny-frames");
 MODULE_PARM_DESC(flowctrl, "Sundance Alta flow control [0|1]");
@@ -502,6 +512,7 @@ static void refill_rx (struct net_device
 static void netdev_error(struct net_device *dev, int intr_status);
 static void netdev_error(struct net_device *dev, int intr_status);
 static void set_rx_mode(struct net_device *dev);
+static int __set_mac_addr(struct net_device *dev);
 static struct net_device_stats *get_stats(struct net_device *dev);
 static int netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 static int  netdev_close(struct net_device *dev);
@@ -662,8 +673,8 @@ static int __devinit sundance_probe1 (st
 				np->an_enable = 1;
 			}
 		}
-		if (flowctrl == 0)
-			np->flowctrl = 0;
+		if (flowctrl == 1)
+			np->flowctrl = 1;
 	}
 
 	/* Fibre PHY? */
@@ -678,6 +689,9 @@ static int __devinit sundance_probe1 (st
 	/* Reset PHY */
 	mdio_write (dev, np->phys[0], MII_BMCR, BMCR_RESET);
 	mdelay (300);
+	/* If flow control enabled, we need to advertise it.*/
+	if (np->flowctrl)
+		mdio_write (dev, np->phys[0], MII_ADVERTISE, np->mii_if.advertising | 0x0400);
 	mdio_write (dev, np->phys[0], MII_BMCR, BMCR_ANENABLE|BMCR_ANRESTART);
 	/* Force media type */
 	if (!np->an_enable) {
@@ -847,17 +861,18 @@ static int netdev_open(struct net_device
 	if (netif_msg_ifup(np))
 		printk(KERN_DEBUG "%s: netdev_open() irq %d.\n",
 			   dev->name, dev->irq);
-
 	init_ring(dev);
 
 	writel(np->rx_ring_dma, ioaddr + RxListPtr);
 	/* The Tx list pointer is written as packets are queued. */
 
-	for (i = 0; i < 6; i++)
-		writeb(dev->dev_addr[i], ioaddr + StationAddr + i);
-
 	/* Initialize other registers. */
+	__set_mac_addr(dev);
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	writew(dev->mtu + 18, ioaddr + MaxFrameSize);
+#else
 	writew(dev->mtu + 14, ioaddr + MaxFrameSize);
+#endif
 	if (dev->mtu > 2047)
 		writel(readl(ioaddr + ASICCtrl) | 0x0C, ioaddr + ASICCtrl);
 
@@ -879,7 +894,7 @@ static int netdev_open(struct net_device
 		writeb(0x01, ioaddr + DebugCtrl1);
 	netif_start_queue(dev);
 
-	writew(StatsEnable | RxEnable | TxEnable, ioaddr + MACCtrl1);
+	writew (StatsEnable | RxEnable | TxEnable, ioaddr + MACCtrl1);
 
 	if (netif_msg_ifup(np))
 		printk(KERN_DEBUG "%s: Done netdev_open(), status: Rx %x Tx %x "
@@ -925,7 +940,7 @@ static void check_duplex(struct net_devi
 			printk(KERN_INFO "%s: Setting %s-duplex based on MII #%d "
 				   "negotiated capability %4.4x.\n", dev->name,
 				   duplex ? "full" : "half", np->phys[0], negotiated);
-		writew(duplex ? 0x20 : 0, ioaddr + MACCtrl0);
+		writew(readw(ioaddr + MACCtrl0) | duplex ? 0x20 : 0, ioaddr + MACCtrl0);
 	}
 }
 
@@ -951,7 +966,7 @@ static void tx_timeout(struct net_device
 {
 	struct netdev_private *np = dev->priv;
 	long ioaddr = dev->base_addr;
-	long flag;
+	unsigned long flag;
 	
 	netif_stop_queue(dev);
 	tasklet_disable(&np->tx_tasklet);
@@ -966,11 +981,11 @@ static void tx_timeout(struct net_device
 		for (i=0; i<TX_RING_SIZE; i++) {
 			printk(KERN_DEBUG "%02x %08x %08x %08x(%02x) %08x %08x\n", i,
 				np->tx_ring_dma + i*sizeof(*np->tx_ring),	
-				np->tx_ring[i].next_desc,
-				np->tx_ring[i].status,
-				(np->tx_ring[i].status >> 2) & 0xff,
-				np->tx_ring[i].frag[0].addr, 
-				np->tx_ring[i].frag[0].length);
+				le32_to_cpu(np->tx_ring[i].next_desc),
+				le32_to_cpu(np->tx_ring[i].status),
+				(le32_to_cpu(np->tx_ring[i].status) >> 2) & 0xff,
+				le32_to_cpu(np->tx_ring[i].frag[0].addr), 
+				le32_to_cpu(np->tx_ring[i].frag[0].length));
 		}
 		printk(KERN_DEBUG "TxListPtr=%08x netif_queue_stopped=%d\n", 
 			readl(dev->base_addr + TxListPtr), 
@@ -1157,7 +1172,6 @@ static void intr_handler(int irq, void *
 	struct net_device *dev = (struct net_device *)dev_instance;
 	struct netdev_private *np;
 	long ioaddr;
-	int boguscnt = max_interrupt_work;
 	int hw_frame_id;
 	int tx_cnt;
 	int tx_status;
@@ -1226,11 +1240,14 @@ static void intr_handler(int irq, void *
 				int entry = np->dirty_tx % TX_RING_SIZE;
 				struct sk_buff *skb;
 				int sw_frame_id;
-				sw_frame_id = (np->tx_ring[entry].status >> 2) & 0xff;
-					if (sw_frame_id == hw_frame_id &&
-						!(np->tx_ring[entry].status & 0x00010000))
+				sw_frame_id = (le32_to_cpu(
+					np->tx_ring[entry].status) >> 2) & 0xff;
+				if (sw_frame_id == hw_frame_id &&
+					!(le32_to_cpu(np->tx_ring[entry].status)
+					& 0x00010000))
 						break;
-					if (sw_frame_id == (hw_frame_id + 1) % TX_RING_SIZE)
+				if (sw_frame_id == (hw_frame_id + 1) % 
+					TX_RING_SIZE)
 						break;
 				skb = np->tx_skbuff[entry];
 				/* Free the original skb. */
@@ -1248,7 +1265,8 @@ static void intr_handler(int irq, void *
 			for (; np->cur_tx - np->dirty_tx > 0; np->dirty_tx++) {
 				int entry = np->dirty_tx % TX_RING_SIZE;
 				struct sk_buff *skb;
-				if (!(np->tx_ring[entry].status & 0x00010000))
+				if (!(le32_to_cpu(np->tx_ring[entry].status) 
+							& 0x00010000))
 					break;
 				skb = np->tx_skbuff[entry];
 				/* Free the original skb. */
@@ -1271,15 +1289,7 @@ static void intr_handler(int irq, void *
 		/* Abnormal error summary/uncommon events handlers. */
 		if (intr_status & (IntrPCIErr | LinkChange | StatsMax))
 			netdev_error(dev, intr_status);
-		if (--boguscnt < 0) {
-			get_stats(dev);
-			if (netif_msg_hw(np))
-				printk(KERN_WARNING "%s: Too much work at interrupt, "
-				   "status=0x%4.4x / 0x%4.4x.\n",
-				   dev->name, intr_status, readw(ioaddr + IntrClear));
-			break;
-		}
-	} while (1);
+	} while (0);
 	if (netif_msg_intr(np))
 		printk(KERN_DEBUG "%s: exiting interrupt, status=%#4.4x.\n",
 			   dev->name, readw(ioaddr + IntrStatus));
@@ -1447,9 +1457,12 @@ static void netdev_error(struct net_devi
 				"full" : "half");
 		}
 		check_duplex (dev);
-		if (np->flowctrl == 0)
-			writew(readw(ioaddr + MACCtrl0) & ~EnbFlowCtrl,
+		if (np->flowctrl && np->mii_if.full_duplex) {
+			writew(readw(ioaddr + MulticastFilter1+2) | 0x0200,
+				ioaddr + MulticastFilter1+2);
+			writew(readw(ioaddr + MACCtrl0) | EnbFlowCtrl,
 				ioaddr + MACCtrl0);
+		}
 	}
 	if (intr_status & StatsMax) {
 		get_stats(dev);
@@ -1463,8 +1476,8 @@ static void netdev_error(struct net_devi
 
 static struct net_device_stats *get_stats(struct net_device *dev)
 {
-	long ioaddr = dev->base_addr;
 	struct netdev_private *np = dev->priv;
+	long ioaddr = dev->base_addr;
 	int i;
 
 	/* We should lock this segment of code for SMP eventually, although
@@ -1477,7 +1490,7 @@ static struct net_device_stats *get_stat
 	np->stats.collisions += readb(ioaddr + StatsLateColl);
 	np->stats.collisions += readb(ioaddr + StatsMultiColl);
 	np->stats.collisions += readb(ioaddr + StatsOneColl);
-	readb(ioaddr + StatsCarrierError);
+	np->stats.tx_carrier_errors += readb(ioaddr + StatsCarrierError);
 	readb(ioaddr + StatsTxDefer);
 	for (i = StatsTxDefer; i <= StatsMcastRx; i++)
 		readb(ioaddr + i);
@@ -1492,6 +1505,7 @@ static struct net_device_stats *get_stat
 static void set_rx_mode(struct net_device *dev)
 {
 	long ioaddr = dev->base_addr;
+	struct netdev_private *np = dev->priv;
 	u16 mc_filter[4];			/* Multicast hash filter */
 	u32 rx_mode;
 	int i;
@@ -1524,11 +1538,28 @@ static void set_rx_mode(struct net_devic
 		writeb(AcceptBroadcast | AcceptMyPhys, ioaddr + RxMode);
 		return;
 	}
+	if (np->mii_if.full_duplex && np->flowctrl)
+		mc_filter[3] |= 0x0200;
+
 	for (i = 0; i < 4; i++)
 		writew(mc_filter[i], ioaddr + MulticastFilter0 + i*2);
 	writeb(rx_mode, ioaddr + RxMode);
 }
 
+static int __set_mac_addr(struct net_device *dev)
+{
+	u16 addr16;
+
+	addr16 = (dev->dev_addr[0] | (dev->dev_addr[1] << 8));
+	writew(addr16, dev->base_addr + StationAddr);
+	addr16 = (dev->dev_addr[2] | (dev->dev_addr[3] << 8));
+	writew(addr16, dev->base_addr + StationAddr+2);
+	addr16 = (dev->dev_addr[4] | (dev->dev_addr[5] << 8));
+	writew(addr16, dev->base_addr + StationAddr+4);
+	return 0;
+}
+	
+
 static int netdev_ethtool_ioctl(struct net_device *dev, void *useraddr)
 {
 	struct netdev_private *np = dev->priv;
@@ -1615,6 +1646,7 @@ static int netdev_ioctl(struct net_devic
 	struct mii_ioctl_data *data = (struct mii_ioctl_data *) & rq->ifr_data;
 	int rc;
 	int i;
+	long ioaddr = dev->base_addr;
 
 	if (!netif_running(dev))
 		return -EINVAL;
@@ -1632,11 +1664,12 @@ static int netdev_ioctl(struct net_devic
 		for (i=0; i<TX_RING_SIZE; i++) {
 			printk(KERN_DEBUG "%02x %08x %08x %08x(%02x) %08x %08x\n", i,
 				np->tx_ring_dma + i*sizeof(*np->tx_ring),	
-				np->tx_ring[i].next_desc,
-				np->tx_ring[i].status,
-				(np->tx_ring[i].status >> 2) & 0xff,
-				np->tx_ring[i].frag[0].addr, 
-				np->tx_ring[i].frag[0].length);
+				le32_to_cpu(np->tx_ring[i].next_desc),
+				le32_to_cpu(np->tx_ring[i].status),
+				(le32_to_cpu(np->tx_ring[i].status) >> 2) 
+					& 0xff,
+				le32_to_cpu(np->tx_ring[i].frag[0].addr), 
+				le32_to_cpu(np->tx_ring[i].frag[0].length));
 		}
 		printk(KERN_DEBUG "TxListPtr=%08x netif_queue_stopped=%d\n", 
 			readl(dev->base_addr + TxListPtr), 
@@ -1646,6 +1679,7 @@ static int netdev_ioctl(struct net_devic
 			np->dirty_tx, np->dirty_tx % TX_RING_SIZE);
 		printk(KERN_DEBUG "cur_rx=%d dirty_rx=%d\n", np->cur_rx, np->dirty_rx);
 		printk(KERN_DEBUG "cur_task=%d\n", np->cur_task);
+		printk(KERN_DEBUG "TxStatus=%04x\n", readw(ioaddr + TxStatus));
 			return 0;
 	}
 				
@@ -1753,10 +1787,10 @@ static void __devexit sundance_remove1 (
 }
 
 static struct pci_driver sundance_driver = {
-	name:		DRV_NAME,
-	id_table:	sundance_pci_tbl,
-	probe:		sundance_probe1,
-	remove:		__devexit_p(sundance_remove1),
+	.name		= DRV_NAME,
+	.id_table	= sundance_pci_tbl,
+	.probe		= sundance_probe1,
+	.remove		= __devexit_p(sundance_remove1),
 };
 
 static int __init sundance_init(void)
diff -urNp linux-2/drivers/net/tlan.c linux-3/drivers/net/tlan.c
--- linux-2/drivers/net/tlan.c	
+++ linux-3/drivers/net/tlan.c	
@@ -166,19 +166,18 @@
  *	                       Thanks to Gunnar Eikman
  *******************************************************************************/
 
-                                                                                
 #include <linux/module.h>
-
-#include "tlan.h"
-
 #include <linux/init.h>
 #include <linux/ioport.h>
 #include <linux/pci.h>
+#include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/delay.h>
 #include <linux/spinlock.h>
+#include <linux/tqueue.h>
 #include <linux/mii.h>
 
+#include "tlan.h"
 
 typedef u32 (TLanIntVectorFunc)( struct net_device *, u16 );
 
@@ -208,7 +207,6 @@ MODULE_PARM_DESC(duplex, "ThunderLAN dup
 MODULE_PARM_DESC(speed, "ThunderLAN port speen setting(s) (0,10,100)");
 MODULE_PARM_DESC(debug, "ThunderLAN debug mask");
 MODULE_PARM_DESC(bbuf, "ThunderLAN use big buffer (0-1)");
-EXPORT_NO_SYMBOLS;
 
 /* Define this to enable Link beat monitoring */
 #undef MONITOR
@@ -218,10 +216,11 @@ static  int		debug;
 
 static	int		bbuf;
 static	u8		*TLanPadBuffer;
+static  dma_addr_t	TLanPadBufferDMA;
 static	char		TLanSignature[] = "TLAN";
-static const char tlan_banner[] = "ThunderLAN driver v1.15\n";
-static int tlan_have_pci;
-static int tlan_have_eisa;
+static  const char tlan_banner[] = "ThunderLAN driver v1.15\n";
+static  int tlan_have_pci;
+static  int tlan_have_eisa;
 
 const char *media[] = {
 	"10BaseT-HD ", "10BaseT-FD ","100baseTx-HD ", 
@@ -347,6 +346,27 @@ static void	TLan_EeReceiveByte( u16, u8 
 static int	TLan_EeReadByte( struct net_device *, u8, u8 * );
 
 
+static void 
+TLan_StoreSKB( struct tlan_list_tag *tag, struct sk_buff *skb)
+{
+	unsigned long addr = (unsigned long)skb;
+	tag->buffer[9].address = (u32)addr;
+	addr >>= 31;	/* >>= 32 is undefined for 32bit arch, stupid C */
+	addr >>= 1;
+	tag->buffer[8].address = (u32)addr;
+}
+
+static struct sk_buff *
+TLan_GetSKB( struct tlan_list_tag *tag)
+{
+	unsigned long addr = tag->buffer[8].address;
+	addr <<= 31;
+	addr <<= 1;
+	addr |= tag->buffer[9].address;
+	return (struct sk_buff *) addr;
+}
+
+
 static TLanIntVectorFunc *TLanIntVector[TLAN_INT_NUMBER_OF_INTS] = {
 	TLan_HandleInvalid,
 	TLan_HandleTxEOF,
@@ -422,10 +442,10 @@ static void __devexit tlan_remove_one( s
 	unregister_netdev( dev );
 
 	if ( priv->dmaStorage ) {
-		kfree( priv->dmaStorage );
+		pci_free_consistent(priv->pciDev, priv->dmaSize, priv->dmaStorage, priv->dmaStorageDMA );
 	}
 
-	release_region( dev->base_addr, 0x10 );
+	pci_release_regions(pdev);
 	
 	kfree( dev );
 		
@@ -433,10 +453,10 @@ static void __devexit tlan_remove_one( s
 } 
 
 static struct pci_driver tlan_driver = {
-	name:		"tlan",
-	id_table:	tlan_pci_tbl,
-	probe:		tlan_init_one,
-	remove:		__devexit_p(tlan_remove_one),	
+	.name		= "tlan",
+	.id_table	= tlan_pci_tbl,
+	.probe		= tlan_init_one,
+	.remove		= __devexit_p(tlan_remove_one),	
 };
 
 static int __init tlan_probe(void)
@@ -445,8 +465,7 @@ static int __init tlan_probe(void)
 	
 	printk(KERN_INFO "%s", tlan_banner);
 	
-	TLanPadBuffer = (u8 *) kmalloc(TLAN_MIN_FRAME_SIZE, 
-					GFP_KERNEL);
+	TLanPadBuffer = (u8 *) pci_alloc_consistent(NULL, TLAN_MIN_FRAME_SIZE, &TLanPadBufferDMA);
 
 	if (TLanPadBuffer == NULL) {
 		printk(KERN_ERR "TLAN: Could not allocate memory for pad buffer.\n");
@@ -471,7 +490,7 @@ static int __init tlan_probe(void)
 
 	if (TLanDevicesInstalled == 0) {
 		pci_unregister_driver(&tlan_driver);
-		kfree(TLanPadBuffer);
+		pci_free_consistent(NULL, TLAN_MIN_FRAME_SIZE, TLanPadBuffer, TLanPadBufferDMA);
 		return -ENODEV;
 	}
 	return 0;
@@ -512,26 +531,44 @@ static int __devinit TLan_probe1(struct 
 	TLanPrivateInfo    *priv;
 	u8		   pci_rev;
 	u16		   device_id;
-	int		   reg;
+	int		   reg, rc = -ENODEV;
+
+	if (pdev) {
+		rc = pci_enable_device(pdev);
+		if (rc)
+			return rc;
 
-	if (pdev && pci_enable_device(pdev))
-		return -EIO;
+		rc = pci_request_regions(pdev, TLanSignature);
+		if (rc) {
+			printk(KERN_ERR "TLAN: Could not reserve IO regions\n");
+			goto err_out;
+		}
+	}
 
-	dev = init_etherdev(NULL, sizeof(TLanPrivateInfo));
+	dev = alloc_etherdev(sizeof(TLanPrivateInfo));
 	if (dev == NULL) {
 		printk(KERN_ERR "TLAN: Could not allocate memory for device.\n");
-		return -ENOMEM;
+		rc = -ENOMEM;
+		goto err_out_regions;
 	}
 	SET_MODULE_OWNER(dev);
 	
 	priv = dev->priv;
 
+	priv->pciDev = pdev;
+	
 	/* Is this a PCI device? */
 	if (pdev) {
 		u32 		   pci_io_base = 0;
 
 		priv->adapter = &board_info[ent->driver_data];
 
+		rc = pci_set_dma_mask(pdev, 0xFFFFFFFF);
+		if (rc) {
+			printk(KERN_ERR "TLAN: No suitable PCI mapping available.\n");
+			goto err_out_free_dev;
+		}
+
 		pci_read_config_byte ( pdev, PCI_REVISION_ID, &pci_rev);
 
 		for ( reg= 0; reg <= 5; reg ++ ) {
@@ -544,9 +581,8 @@ static int __devinit TLan_probe1(struct 
 		}
 		if (!pci_io_base) {
 			printk(KERN_ERR "TLAN: No IO mappings available\n");
-			unregister_netdev(dev);
-			kfree(dev);
-			return -ENODEV;
+			rc = -EIO;
+			goto err_out_free_dev;
 		}
 		
 		dev->base_addr = pci_io_base;
@@ -592,19 +628,22 @@ static int __devinit TLan_probe1(struct 
 	
 	/* This will be used when we get an adapter error from
 	 * within our irq handler */
-	INIT_LIST_HEAD(&priv->tlan_tqueue.list);
-	priv->tlan_tqueue.sync = 0;
-	priv->tlan_tqueue.routine = (void *)(void*)TLan_tx_timeout;
-	priv->tlan_tqueue.data = dev;
+	INIT_TQUEUE(&priv->tlan_tqueue, (void *)(void*)TLan_tx_timeout, dev);
 
 	spin_lock_init(&priv->lock);
 	
-	if (TLan_Init(dev)) {
+	rc = TLan_Init(dev);
+	if (rc) {
+		printk(KERN_ERR "TLAN: Could not set up device.\n");
+		goto err_out_free_dev;
+	}
+
+	rc = register_netdev(dev);
+	if (rc) {
 		printk(KERN_ERR "TLAN: Could not register device.\n");
-		unregister_netdev(dev);
-		kfree(dev);
-		return -EAGAIN;
-	} else {
+		goto err_out_uninit;
+	}
+
 	
 	TLanDevicesInstalled++;
 	boards_found++;
@@ -625,8 +664,19 @@ static int __devinit TLan_probe1(struct 
 			priv->adapter->deviceLabel,
 			priv->adapterRev);
 	return 0;
-	}
 
+err_out_uninit:
+	pci_free_consistent(priv->pciDev, priv->dmaSize, priv->dmaStorage,
+			    priv->dmaStorageDMA );
+err_out_free_dev:
+	kfree(dev);
+err_out_regions:
+	if (pdev)
+		pci_release_regions(pdev);
+err_out:
+	if (pdev)
+		pci_disable_device(pdev);
+	return rc;
 }
 
 
@@ -639,7 +689,7 @@ static void TLan_Eisa_Cleanup(void)
 		dev = TLan_Eisa_Devices;
 		priv = dev->priv;
 		if (priv->dmaStorage) {
-			kfree(priv->dmaStorage);
+			pci_free_consistent(priv->pciDev, priv->dmaSize, priv->dmaStorage, priv->dmaStorageDMA );
 		}
 		release_region( dev->base_addr, 0x10);
 		unregister_netdev( dev );
@@ -657,7 +707,7 @@ static void __exit tlan_exit(void)
 	if (tlan_have_eisa)
 		TLan_Eisa_Cleanup();
 
-	kfree( TLanPadBuffer );
+	pci_free_consistent(NULL, TLAN_MIN_FRAME_SIZE, TLanPadBuffer, TLanPadBufferDMA);
 
 }
 
@@ -792,15 +842,6 @@ static int TLan_Init( struct net_device 
 
 	priv = dev->priv;
 	
-	if (!priv->is_eisa)	/* EISA devices have already requested IO */
-		if (!request_region( dev->base_addr, 0x10, TLanSignature )) {
-			printk(KERN_ERR "TLAN: %s: IO port region 0x%lx size 0x%x in use.\n",
-				dev->name,
-				dev->base_addr,
-				0x10 );
-			return -EIO;
-		}
-	
 	if ( bbuf ) {
 		dma_size = ( TLAN_NUM_RX_LISTS + TLAN_NUM_TX_LISTS )
 	           * ( sizeof(TLanList) + TLAN_MAX_FRAME_SIZE );
@@ -808,21 +849,25 @@ static int TLan_Init( struct net_device 
 		dma_size = ( TLAN_NUM_RX_LISTS + TLAN_NUM_TX_LISTS )
 	           * ( sizeof(TLanList) );
 	}
-	priv->dmaStorage = kmalloc(dma_size, GFP_KERNEL | GFP_DMA);
+	priv->dmaStorage = pci_alloc_consistent(priv->pciDev, dma_size, &priv->dmaStorageDMA);
+	priv->dmaSize = dma_size;
+	
 	if ( priv->dmaStorage == NULL ) {
 		printk(KERN_ERR "TLAN:  Could not allocate lists and buffers for %s.\n",
 			dev->name );
-		release_region( dev->base_addr, 0x10 );
 		return -ENOMEM;
 	}
 	memset( priv->dmaStorage, 0, dma_size );
 	priv->rxList = (TLanList *) 
 		       ( ( ( (u32) priv->dmaStorage ) + 7 ) & 0xFFFFFFF8 );
+	priv->rxListDMA = ( ( ( (u32) priv->dmaStorageDMA ) + 7 ) & 0xFFFFFFF8 );
 	priv->txList = priv->rxList + TLAN_NUM_RX_LISTS;
+	priv->txListDMA = priv->rxListDMA + sizeof(TLanList) * TLAN_NUM_RX_LISTS;
 	if ( bbuf ) {
 		priv->rxBuffer = (u8 *) ( priv->txList + TLAN_NUM_TX_LISTS );
-		priv->txBuffer = priv->rxBuffer
-				 + ( TLAN_NUM_RX_LISTS * TLAN_MAX_FRAME_SIZE );
+		priv->rxBufferDMA =priv->txListDMA + sizeof(TLanList) * TLAN_NUM_TX_LISTS;
+		priv->txBuffer = priv->rxBuffer + ( TLAN_NUM_RX_LISTS * TLAN_MAX_FRAME_SIZE );
+		priv->txBufferDMA = priv->rxBufferDMA + ( TLAN_NUM_RX_LISTS * TLAN_MAX_FRAME_SIZE );
 	}
 
 	err = 0;
@@ -1003,6 +1048,7 @@ static int TLan_StartTx( struct sk_buff 
 {
 	TLanPrivateInfo *priv = dev->priv;
 	TLanList	*tail_list;
+	dma_addr_t	tail_list_phys;
 	u8		*tail_buffer;
 	int		pad;
 	unsigned long	flags;
@@ -1014,6 +1060,7 @@ static int TLan_StartTx( struct sk_buff 
 	}
 
 	tail_list = priv->txList + priv->txTail;
+	tail_list_phys = priv->txListDMA + sizeof(TLanList) * priv->txTail;
 	
 	if ( tail_list->cStat != TLAN_CSTAT_UNUSED ) {
 		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  %s is busy (Head=%d Tail=%d)\n", dev->name, priv->txHead, priv->txTail );
@@ -1028,8 +1075,8 @@ static int TLan_StartTx( struct sk_buff 
 		tail_buffer = priv->txBuffer + ( priv->txTail * TLAN_MAX_FRAME_SIZE );
 		memcpy( tail_buffer, skb->data, skb->len );
 	} else {
-		tail_list->buffer[0].address = virt_to_bus( skb->data );
-		tail_list->buffer[9].address = (u32) skb;
+		tail_list->buffer[0].address = pci_map_single(priv->pciDev, skb->data, skb->len, PCI_DMA_TODEVICE);
+		TLan_StoreSKB(tail_list, skb);
 	}
 
 	pad = TLAN_MIN_FRAME_SIZE - skb->len;
@@ -1038,7 +1085,7 @@ static int TLan_StartTx( struct sk_buff 
 		tail_list->frameSize = (u16) skb->len + pad;
 		tail_list->buffer[0].count = (u32) skb->len;
 		tail_list->buffer[1].count = TLAN_LAST_BUFFER | (u32) pad;
-		tail_list->buffer[1].address = virt_to_bus( TLanPadBuffer );
+		tail_list->buffer[1].address = TLanPadBufferDMA;
 	} else {
 		tail_list->frameSize = (u16) skb->len;
 		tail_list->buffer[0].count = TLAN_LAST_BUFFER | (u32) skb->len;
@@ -1051,14 +1098,14 @@ static int TLan_StartTx( struct sk_buff 
 	if ( ! priv->txInProgress ) {
 		priv->txInProgress = 1;
 		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  Starting TX on buffer %d\n", priv->txTail );
-		outl( virt_to_bus( tail_list ), dev->base_addr + TLAN_CH_PARM );
+		outl( tail_list_phys, dev->base_addr + TLAN_CH_PARM );
 		outl( TLAN_HC_GO, dev->base_addr + TLAN_HOST_CMD );
 	} else {
 		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  Adding buffer %d to TX channel\n", priv->txTail );
 		if ( priv->txTail == 0 ) {
-			( priv->txList + ( TLAN_NUM_TX_LISTS - 1 ) )->forward = virt_to_bus( tail_list );
+			( priv->txList + ( TLAN_NUM_TX_LISTS - 1 ) )->forward = tail_list_phys;
 		} else {
-			( priv->txList + ( priv->txTail - 1 ) )->forward = virt_to_bus( tail_list );
+			( priv->txList + ( priv->txTail - 1 ) )->forward = tail_list_phys;
 		}
 	}
 	spin_unlock_irqrestore(&priv->lock, flags);
@@ -1344,6 +1391,7 @@ u32 TLan_HandleTxEOF( struct net_device 
 	TLanPrivateInfo	*priv = dev->priv;
 	int		eoc = 0;
 	TLanList	*head_list;
+	dma_addr_t	head_list_phys;
 	u32		ack = 0;
 	u16		tmpCStat;
 	
@@ -1353,7 +1401,10 @@ u32 TLan_HandleTxEOF( struct net_device 
 	while (((tmpCStat = head_list->cStat ) & TLAN_CSTAT_FRM_CMP) && (ack < 255)) {
 		ack++;
 		if ( ! bbuf ) {
-			dev_kfree_skb_any( (struct sk_buff *) head_list->buffer[9].address );
+			struct sk_buff *skb = TLan_GetSKB(head_list);
+			pci_unmap_single(priv->pciDev, head_list->buffer[0].address, skb->len, PCI_DMA_TODEVICE);
+			dev_kfree_skb_any(skb);
+			head_list->buffer[8].address = 0;
 			head_list->buffer[9].address = 0;
 		}
 	
@@ -1374,8 +1425,9 @@ u32 TLan_HandleTxEOF( struct net_device 
 	if ( eoc ) {
 		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  Handling TX EOC (Head=%d Tail=%d)\n", priv->txHead, priv->txTail );
 		head_list = priv->txList + priv->txHead;
+		head_list_phys = priv->txListDMA + sizeof(TLanList) * priv->txHead;
 		if ( ( head_list->cStat & TLAN_CSTAT_READY ) == TLAN_CSTAT_READY ) {
-			outl( virt_to_bus( head_list ), dev->base_addr + TLAN_CH_PARM );
+			outl(head_list_phys, dev->base_addr + TLAN_CH_PARM );
 			ack |= TLAN_HC_GO;
 		} else {
 			priv->txInProgress = 0;
@@ -1468,9 +1520,11 @@ u32 TLan_HandleRxEOF( struct net_device 
 	void		*t;
 	u32		frameSize;
 	u16		tmpCStat;
+	dma_addr_t	head_list_phys;
 
 	TLAN_DBG( TLAN_DEBUG_RX, "RECEIVE:  Handling RX EOF (Head=%d Tail=%d)\n", priv->rxHead, priv->rxTail );
 	head_list = priv->rxList + priv->rxHead;
+	head_list_phys = priv->rxListDMA + sizeof(TLanList) * priv->rxHead;
 	
 	while (((tmpCStat = head_list->cStat) & TLAN_CSTAT_FRM_CMP) && (ack < 255)) {
 		frameSize = head_list->frameSize;
@@ -1498,17 +1552,16 @@ u32 TLan_HandleRxEOF( struct net_device 
 			struct sk_buff *new_skb;
 		
 			/*
-		 	*	I changed the algorithm here. What we now do
-		 	*	is allocate the new frame. If this fails we
-		 	*	simply recycle the frame.
-		 	*/
+		 	 *	I changed the algorithm here. What we now do
+		 	 *	is allocate the new frame. If this fails we
+		 	 *	simply recycle the frame.
+		 	 */
 		
 			new_skb = dev_alloc_skb( TLAN_MAX_FRAME_SIZE + 7 );
 			
 			if ( new_skb != NULL ) {
-				/* If this ever happened it would be a problem */
-				/* not any more - ac */
-				skb = (struct sk_buff *) head_list->buffer[9].address;
+				skb = TLan_GetSKB(head_list);
+				pci_unmap_single(priv->pciDev, head_list->buffer[0].address, TLAN_MAX_FRAME_SIZE, PCI_DMA_FROMDEVICE);
 				skb_trim( skb, frameSize );
 
 				priv->stats.rx_bytes += frameSize;
@@ -1519,9 +1572,9 @@ u32 TLan_HandleRxEOF( struct net_device 
 				new_skb->dev = dev;
 				skb_reserve( new_skb, 2 );
 				t = (void *) skb_put( new_skb, TLAN_MAX_FRAME_SIZE );
-				head_list->buffer[0].address = virt_to_bus( t );
+				head_list->buffer[0].address = pci_map_single(priv->pciDev, new_skb->data, TLAN_MAX_FRAME_SIZE, PCI_DMA_FROMDEVICE);
 				head_list->buffer[8].address = (u32) t;
-				head_list->buffer[9].address = (u32) new_skb;
+				TLan_StoreSKB(head_list, new_skb);
 			} else 
 				printk(KERN_WARNING "TLAN:  Couldn't allocate memory for received data.\n" );
 		}
@@ -1529,11 +1582,12 @@ u32 TLan_HandleRxEOF( struct net_device 
 		head_list->forward = 0;
 		head_list->cStat = 0;
 		tail_list = priv->rxList + priv->rxTail;
-		tail_list->forward = virt_to_bus( head_list );
+		tail_list->forward = head_list_phys;
 
 		CIRC_INC( priv->rxHead, TLAN_NUM_RX_LISTS );
 		CIRC_INC( priv->rxTail, TLAN_NUM_RX_LISTS );
 		head_list = priv->rxList + priv->rxHead;
+		head_list_phys = priv->rxListDMA + sizeof(TLanList) * priv->rxHead;
 	}
 
 	if (!ack)
@@ -1545,7 +1599,8 @@ u32 TLan_HandleRxEOF( struct net_device 
 	if ( eoc ) { 
 		TLAN_DBG( TLAN_DEBUG_RX, "RECEIVE:  Handling RX EOC (Head=%d Tail=%d)\n", priv->rxHead, priv->rxTail );
 		head_list = priv->rxList + priv->rxHead;
-		outl( virt_to_bus( head_list ), dev->base_addr + TLAN_CH_PARM );
+		head_list_phys = priv->rxListDMA + sizeof(TLanList) * priv->rxHead;
+		outl(head_list_phys, dev->base_addr + TLAN_CH_PARM );
 		ack |= TLAN_HC_GO | TLAN_HC_RT;
 		priv->rxEocCount++;
 	}
@@ -1611,7 +1666,7 @@ u32 TLan_HandleDummy( struct net_device 
 	 *		host_int	The contents of the HOST_INT
 	 *				port.
 	 *
-	 *	This driver is structured to determine EOC occurances by
+	 *	This driver is structured to determine EOC occurrences by
 	 *	reading the CSTAT member of the list structure.  Tx EOC
 	 *	interrupts are disabled via the DIO INTDIS register.
 	 *	However, TLAN chips before revision 3.0 didn't have this
@@ -1624,15 +1679,17 @@ u32 TLan_HandleTxEOC( struct net_device 
 {
 	TLanPrivateInfo	*priv = dev->priv;
 	TLanList		*head_list;
+	dma_addr_t		head_list_phys;
 	u32			ack = 1;
 	
 	host_int = 0;
 	if ( priv->tlanRev < 0x30 ) {
 		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  Handling TX EOC (Head=%d Tail=%d) -- IRQ\n", priv->txHead, priv->txTail );
 		head_list = priv->txList + priv->txHead;
+		head_list_phys = priv->txListDMA + sizeof(TLanList) * priv->txHead;
 		if ( ( head_list->cStat & TLAN_CSTAT_READY ) == TLAN_CSTAT_READY ) {
 			netif_stop_queue(dev);
-			outl( virt_to_bus( head_list ), dev->base_addr + TLAN_CH_PARM );
+			outl( head_list_phys, dev->base_addr + TLAN_CH_PARM );
 			ack |= TLAN_HC_GO;
 		} else {
 			priv->txInProgress = 0;
@@ -1683,10 +1740,9 @@ u32 TLan_HandleStatusCheck( struct net_d
 		printk( "TLAN:  %s: Adaptor Error = 0x%x\n", dev->name, error );
 		TLan_ReadAndClearStats( dev, TLAN_RECORD );
 		outl( TLAN_HC_AD_RST, dev->base_addr + TLAN_HOST_CMD );
-		
-		queue_task(&priv->tlan_tqueue, &tq_immediate);
-		mark_bh(IMMEDIATE_BH);
-		
+
+		schedule_task(&priv->tlan_tqueue);
+
 		netif_wake_queue(dev);
 		ack = 0;
 	} else {
@@ -1733,7 +1789,7 @@ u32 TLan_HandleStatusCheck( struct net_d
 	 *		host_int	The contents of the HOST_INT
 	 *				port.
 	 *
-	 *	This driver is structured to determine EOC occurances by
+	 *	This driver is structured to determine EOC occurrences by
 	 *	reading the CSTAT member of the list structure.  Rx EOC
 	 *	interrupts are disabled via the DIO INTDIS register.
 	 *	However, TLAN chips before revision 3.0 didn't have this
@@ -1745,13 +1801,13 @@ u32 TLan_HandleStatusCheck( struct net_d
 u32 TLan_HandleRxEOC( struct net_device *dev, u16 host_int )
 {
 	TLanPrivateInfo	*priv = dev->priv;
-	TLanList	*head_list;
+	dma_addr_t	head_list_phys;
 	u32		ack = 1;
 
 	if (  priv->tlanRev < 0x30 ) {
 		TLAN_DBG( TLAN_DEBUG_RX, "RECEIVE:  Handling RX EOC (Head=%d Tail=%d) -- IRQ\n", priv->rxHead, priv->rxTail );
-		head_list = priv->rxList + priv->rxHead;
-		outl( virt_to_bus( head_list ), dev->base_addr + TLAN_CH_PARM );
+		head_list_phys = priv->rxListDMA + sizeof(TLanList) * priv->rxHead;
+		outl( head_list_phys, dev->base_addr + TLAN_CH_PARM );
 		ack |= TLAN_HC_GO | TLAN_HC_RT;
 		priv->rxEocCount++;
 	}
@@ -1888,6 +1944,7 @@ void TLan_ResetLists( struct net_device 
 	TLanPrivateInfo *priv = dev->priv;
 	int		i;
 	TLanList	*list;
+	dma_addr_t	list_phys;
 	struct sk_buff	*skb;
 	void		*t = NULL;
 
@@ -1897,12 +1954,13 @@ void TLan_ResetLists( struct net_device 
 		list = priv->txList + i;
 		list->cStat = TLAN_CSTAT_UNUSED;
 		if ( bbuf ) {
-			list->buffer[0].address = virt_to_bus( priv->txBuffer + ( i * TLAN_MAX_FRAME_SIZE ) );
+			list->buffer[0].address = priv->txBufferDMA + ( i * TLAN_MAX_FRAME_SIZE );
 		} else {
 			list->buffer[0].address = 0;
 		}
 		list->buffer[2].count = 0;
 		list->buffer[2].address = 0;
+		list->buffer[8].address = 0;
 		list->buffer[9].address = 0;
 	}
 
@@ -1910,11 +1968,12 @@ void TLan_ResetLists( struct net_device 
 	priv->rxTail = TLAN_NUM_RX_LISTS - 1;
 	for ( i = 0; i < TLAN_NUM_RX_LISTS; i++ ) {
 		list = priv->rxList + i;
+		list_phys = priv->rxListDMA + sizeof(TLanList) * i;
 		list->cStat = TLAN_CSTAT_READY;
 		list->frameSize = TLAN_MAX_FRAME_SIZE;
 		list->buffer[0].count = TLAN_MAX_FRAME_SIZE | TLAN_LAST_BUFFER;
 		if ( bbuf ) {
-			list->buffer[0].address = virt_to_bus( priv->rxBuffer + ( i * TLAN_MAX_FRAME_SIZE ) );
+			list->buffer[0].address = priv->rxBufferDMA + ( i * TLAN_MAX_FRAME_SIZE );
 		} else {
 			skb = dev_alloc_skb( TLAN_MAX_FRAME_SIZE + 7 );
 			if ( skb == NULL ) {
@@ -1925,14 +1984,14 @@ void TLan_ResetLists( struct net_device 
 				skb_reserve( skb, 2 );
 				t = (void *) skb_put( skb, TLAN_MAX_FRAME_SIZE );
 			}
-			list->buffer[0].address = virt_to_bus( t );
+			list->buffer[0].address = pci_map_single(priv->pciDev, t, TLAN_MAX_FRAME_SIZE, PCI_DMA_FROMDEVICE);
 			list->buffer[8].address = (u32) t;
-			list->buffer[9].address = (u32) skb;
+			TLan_StoreSKB(list, skb);
 		}
 		list->buffer[1].count = 0;
 		list->buffer[1].address = 0;
 		if ( i < TLAN_NUM_RX_LISTS - 1 )
-			list->forward = virt_to_bus( list + 1 );
+			list->forward = list_phys + sizeof(TLanList);
 		else
 			list->forward = 0;
 	}
@@ -1950,23 +2009,26 @@ void TLan_FreeLists( struct net_device *
 	if ( ! bbuf ) {
 		for ( i = 0; i < TLAN_NUM_TX_LISTS; i++ ) {
 			list = priv->txList + i;
-			skb = (struct sk_buff *) list->buffer[9].address;
+			skb = TLan_GetSKB(list);
 			if ( skb ) {
+				pci_unmap_single(priv->pciDev, list->buffer[0].address, skb->len, PCI_DMA_TODEVICE);
 				dev_kfree_skb_any( skb );
+				list->buffer[8].address = 0;
 				list->buffer[9].address = 0;
 			}
 		}
 
 		for ( i = 0; i < TLAN_NUM_RX_LISTS; i++ ) {
 			list = priv->rxList + i;
-			skb = (struct sk_buff *) list->buffer[9].address;
+			skb = TLan_GetSKB(list);
 			if ( skb ) {
+				pci_unmap_single(priv->pciDev, list->buffer[0].address, TLAN_MAX_FRAME_SIZE, PCI_DMA_FROMDEVICE);
 				dev_kfree_skb_any( skb );
+				list->buffer[8].address = 0;
 				list->buffer[9].address = 0;
 			}
 		}
 	}
-
 } /* TLan_FreeLists */
 
 
@@ -2271,8 +2333,8 @@ TLan_FinishReset( struct net_device *dev
 				printk("TLAN: Partner capability: ");
 					for (i = 5; i <= 10; i++)
 						if (partner & (1<<i))
-							printk("%s", media[i-5]);
-							printk("\n");
+							printk("%s",media[i-5]);
+				printk("\n");
 			}
 
 			TLan_DioWrite8( dev->base_addr, TLAN_LED_REG, TLAN_LED_LINK );
@@ -2304,7 +2366,7 @@ TLan_FinishReset( struct net_device *dev
 		if ( debug >= 1 && debug != TLAN_DEBUG_PROBE ) {
 			outb( ( TLAN_HC_REQ_INT >> 8 ), dev->base_addr + TLAN_HOST_CMD + 1 );
 		}
-		outl( virt_to_bus( priv->rxList ), dev->base_addr + TLAN_CH_PARM );
+		outl( priv->rxListDMA, dev->base_addr + TLAN_CH_PARM );
 		outl( TLAN_HC_GO | TLAN_HC_RT, dev->base_addr + TLAN_HOST_CMD );
 	} else {
 		printk( "TLAN: %s: Link inactive, will retry in 10 secs...\n", dev->name );
@@ -2376,7 +2438,7 @@ void TLan_SetMac( struct net_device *dev
 	 *		dev	A pointer to the device structure of the
 	 *			TLAN device having the PHYs to be detailed.
 	 *				
-	 *	This function prints the registers a PHY (aka tranceiver).
+	 *	This function prints the registers a PHY (aka transceiver).
 	 *
 	 ********************************************************************/
 
@@ -2492,7 +2554,7 @@ void TLan_PhyPowerDown( struct net_devic
 
 	/* Wait for 50 ms and powerup
 	 * This is abitrary.  It is intended to make sure the
-	 * tranceiver settles.
+	 * transceiver settles.
 	 */
 	TLan_SetTimer( dev, (HZ/20), TLAN_TIMER_PHY_PUP );
 
@@ -2512,7 +2574,7 @@ void TLan_PhyPowerUp( struct net_device 
 	TLan_MiiWriteReg( dev, priv->phy[priv->phyNum], MII_GEN_CTL, value );
 	TLan_MiiSync(dev->base_addr);
 	/* Wait for 500 ms and reset the
-	 * tranceiver.  The TLAN docs say both 50 ms and
+	 * transceiver.  The TLAN docs say both 50 ms and
 	 * 500 ms, so do the longer, just in case.
 	 */
 	TLan_SetTimer( dev, (HZ/20), TLAN_TIMER_PHY_RESET );
@@ -2627,7 +2689,7 @@ void TLan_PhyStartLink( struct net_devic
         	TLan_MiiWriteReg( dev, phy, TLAN_TLPHY_CTL, tctl );
 	}
 
-	/* Wait for 2 sec to give the tranceiver time
+	/* Wait for 2 sec to give the transceiver time
 	 * to establish link.
 	 */
 	TLan_SetTimer( dev, (4*HZ), TLAN_TIMER_FINISH_RESET );
diff -urNp linux-2/drivers/net/tlan.h linux-3/drivers/net/tlan.h
--- linux-2/drivers/net/tlan.h	2001-07-02 17:03:04.000000000 -0400
+++ linux-3/drivers/net/tlan.h	
@@ -169,15 +169,22 @@ typedef u8 TLanBuffer[TLAN_MAX_FRAME_SIZ
 
 typedef struct tlan_private_tag {
 	struct net_device       *nextDevice;
+	struct pci_dev		*pciDev;
 	void			*dmaStorage;
+	dma_addr_t		dmaStorageDMA;
+	unsigned int		dmaSize;
 	u8			*padBuffer;
 	TLanList                *rxList;
+	dma_addr_t		rxListDMA;
 	u8			*rxBuffer;
+	dma_addr_t		rxBufferDMA;
 	u32                     rxHead;
 	u32                     rxTail;
 	u32			rxEocCount;
 	TLanList                *txList;
+	dma_addr_t		txListDMA;
 	u8			*txBuffer;
+	dma_addr_t		txBufferDMA;
 	u32                     txHead;
 	u32                     txInProgress;
 	u32                     txTail;
diff -urNp linux-2/drivers/net/tulip/tulip_core.c linux-3/drivers/net/tulip/tulip_core.c
--- linux-2/drivers/net/tulip/tulip_core.c	
+++ linux-3/drivers/net/tulip/tulip_core.c	
@@ -63,7 +63,7 @@ const char * const medianame[32] = {
 /* Set the copy breakpoint for the copy-only-tiny-buffer Rx structure. */
 #if defined(__alpha__) || defined(__arm__) || defined(__hppa__) \
 	|| defined(__sparc_) || defined(__ia64__) \
-	|| defined(__sh__) || defined(__mips__)
+	|| defined(__sh__) || defined(__mips__) || defined(__SH5__)
 static int rx_copybreak = 1518;
 #else
 static int rx_copybreak = 100;
@@ -231,6 +231,7 @@ static struct pci_device_id tulip_pci_tb
 	{ 0x1737, 0xAB09, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },
 	{ 0x17B3, 0xAB08, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },
 	{ 0x14f1, 0x1803, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CONEXANT },
+	{ 0x10b9, 0x5261, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DM910X },	/* ALi 1563 integrated ethernet */
 	{ } /* terminate list */
 };
 MODULE_DEVICE_TABLE(pci, tulip_pci_tbl);
@@ -1403,12 +1404,14 @@ static int __devinit tulip_init_one (str
 		csr0 &= ~0xfff10000; /* zero reserved bits 31:20, 16 */
 
 	/* DM9102A has troubles with MRM & clear reserved bits 24:22, 20, 16, 7:1 */
-	if (pdev->vendor == 0x1282 && pdev->device == 0x9102)
+	if ((pdev->vendor == 0x1282 && pdev->device == 0x9102)
+		|| (pdev->vendor == 0x10b9 && pdev->device == 0x5261))
 		csr0 &= ~0x01f100ff;
 
 #if defined(__sparc__)
         /* DM9102A needs 32-dword alignment/burst length on sparc - chip bug? */
-        if (pdev->vendor == 0x1282 && pdev->device == 0x9102)
+	if ((pdev->vendor == 0x1282 && pdev->device == 0x9102)
+		|| (pdev->vendor == 0x10b9 && pdev->device == 0x5261))
                 csr0 = (csr0 & ~0xff00) | 0xe000;
 #endif
 
diff -urNp linux-2/drivers/net/typhoon.c linux-3/drivers/net/typhoon.c
--- linux-2/drivers/net/typhoon.c	
+++ linux-3/drivers/net/typhoon.c	
@@ -40,7 +40,7 @@
 /* Set the copy breakpoint for the copy-only-tiny-frames scheme.
  * Setting to > 1518 effectively disables this feature.
  */
-static int rx_copybreak = 0;
+static int rx_copybreak = 200;
 
 /* end user-configurable values */
 
@@ -85,8 +85,8 @@ static const int multicast_filter_limit 
 #define PKT_BUF_SZ		1536
 
 #define DRV_MODULE_NAME		"typhoon"
-#define DRV_MODULE_VERSION 	"1.0"
-#define DRV_MODULE_RELDATE	"03/02/14"
+#define DRV_MODULE_VERSION 	"1.4.1"
+#define DRV_MODULE_RELDATE	"03/06/26"
 #define PFX			DRV_MODULE_NAME ": "
 #define ERR_PFX			KERN_ERR PFX
 
@@ -150,7 +150,7 @@ struct typhoon_card_info {
 #define TYPHOON_CRYPTO_DES		1
 #define TYPHOON_CRYPTO_3DES		2
 #define	TYPHOON_CRYPTO_VARIABLE		4
-#define TYPHOON_FIBER			5
+#define TYPHOON_FIBER			8
 
 enum typhoon_cards {
 	TYPHOON_TX = 0, TYPHOON_TX95, TYPHOON_TX97, TYPHOON_SVR,
@@ -1798,7 +1798,7 @@ typhoon_interrupt(int irq, void *dev_ins
 	u32 intr_status;
 
 	intr_status = readl(ioaddr + TYPHOON_REG_INTR_STATUS);
-	if(!intr_status)
+	if(!(intr_status & TYPHOON_INTR_HOST_INT))
 		return;
 
 	writel(intr_status, ioaddr + TYPHOON_REG_INTR_STATUS);
@@ -2134,7 +2134,7 @@ typhoon_close(struct net_device *dev)
 	return 0;
 }
 
-#if CONFIG_PM
+#ifdef CONFIG_PM
 static int
 typhoon_resume(struct pci_dev *pdev)
 {
@@ -2482,7 +2482,7 @@ static struct pci_driver typhoon_driver 
 	.id_table	= typhoon_pci_tbl,
 	.probe		= typhoon_init_one,
 	.remove		= __devexit_p(typhoon_remove_one),
-#if CONFIG_PM
+#ifdef CONFIG_PM
 	.suspend	= typhoon_suspend,
 	.resume		= typhoon_resume,
 	.enable_wake	= typhoon_enable_wake,
diff -urNp linux-2/drivers/net/via-rhine.c linux-3/drivers/net/via-rhine.c
--- linux-2/drivers/net/via-rhine.c	
+++ linux-3/drivers/net/via-rhine.c	
@@ -2,6 +2,8 @@
 /*
 	Written 1998-2001 by Donald Becker.
 
+	Current Maintainer: Roger Luethi <rl@hellgate.ch>
+
 	This software may be used and distributed according to the terms of
 	the GNU General Public License (GPL), incorporated herein by reference.
 	Drivers based on or derived from this code fall under the GPL and must
@@ -9,8 +11,9 @@
 	a complete program and may only be used when the entire operating
 	system is licensed under the GPL.
 
-	This driver is designed for the VIA VT86C100A Rhine-I. 
-	It also works with the 6102 Rhine-II, and 6105/6105M Rhine-III.   
+	This driver is designed for the VIA VT86C100A Rhine-I.
+	It also works with the Rhine-II (6102) and Rhine-III (6105/6105L/6105LOM
+	and management NIC 6105M).
 
 	The author may be reached as becker@scyld.com, or C/O
 	Scyld Computing Corporation
@@ -115,11 +118,15 @@
 	- Force flushing for PCI posted writes
 	- More reset code changes
 
+	LK1.1.18 (Roger Luethi)
+	- No filtering multicast in promisc mode (Edward Peng)
+	- Fix for Rhine-I Tx timeouts
+
 */
 
 #define DRV_NAME	"via-rhine"
-#define DRV_VERSION	"1.1.17"
-#define DRV_RELDATE	"March-1-2003"
+#define DRV_VERSION	"1.1.18"
+#define DRV_RELDATE	"July-4-2003"
 
 
 /* A few user-configurable values.
@@ -139,7 +146,7 @@ static int backoff;
    Both 'options[]' and 'full_duplex[]' should exist for driver
    interoperability.
    The media type is usually passed in 'options[]'.
-   The default is autonegotation for speed and duplex.
+   The default is autonegotiation for speed and duplex.
      This should rarely be overridden.
    Use option values 0x10/0x20 for 10Mbps, 0x100,0x200 for 100Mbps.
    Use option values 0x10 and 0x100 for forcing half duplex fixed speed.
@@ -386,17 +393,17 @@ static struct via_rhine_chip_info via_rh
 	{ "VIA VT6102 Rhine-II", RHINE_IOTYPE, 256,
 	  CanHaveMII | HasWOL },
 	{ "VIA VT6105 Rhine-III", RHINE_IOTYPE, 256,
-	  CanHaveMII | HasWOL },	  
+	  CanHaveMII | HasWOL },
 	{ "VIA VT6105M Rhine-III", RHINE_IOTYPE, 256,
-	  CanHaveMII | HasWOL },	  	  	 
+	  CanHaveMII | HasWOL },
 };
 
 static struct pci_device_id via_rhine_pci_tbl[] __devinitdata =
 {
 	{0x1106, 0x3043, PCI_ANY_ID, PCI_ANY_ID, 0, 0, VT86C100A},
 	{0x1106, 0x3065, PCI_ANY_ID, PCI_ANY_ID, 0, 0, VT6102},
-	{0x1106, 0x3106, PCI_ANY_ID, PCI_ANY_ID, 0, 0, VT6105},
-	{0x1106, 0x3053, PCI_ANY_ID, PCI_ANY_ID, 0, 0, VT6105M},	
+	{0x1106, 0x3106, PCI_ANY_ID, PCI_ANY_ID, 0, 0, VT6105}, /* 6105{,L,LOM} */
+	{0x1106, 0x3053, PCI_ANY_ID, PCI_ANY_ID, 0, 0, VT6105M},
 	{0,}			/* terminate list */
 };
 MODULE_DEVICE_TABLE(pci, via_rhine_pci_tbl);
@@ -441,7 +448,7 @@ enum intr_status_bits {
 	IntrRxWakeUp=0x8000,
 	IntrNormalSummary=0x0003, IntrAbnormalSummary=0xC260,
 	IntrTxDescRace=0x080000,	/* mapped from IntrStatus2 */
-	IntrTxErrSummary=0x082210,
+	IntrTxErrSummary=0x082218,
 };
 
 /* The Rx and Tx buffer descriptors. */
@@ -1264,7 +1271,7 @@ static int via_rhine_start_tx(struct sk_
 
 	if (skb->len < ETH_ZLEN) {
 		skb = skb_padto(skb, ETH_ZLEN);
-		if(skb == NULL)
+		if (skb == NULL)
 			return 0;
 	}
 
@@ -1650,11 +1657,18 @@ static void via_rhine_error(struct net_d
 			printk(KERN_INFO "%s: Tx descriptor write-back race.\n",
 				   dev->name);
 	}
-	if (intr_status & ( IntrTxAborted | IntrTxUnderrun | IntrTxDescRace ))
+	if ((intr_status & IntrTxError) && ~( IntrTxAborted | IntrTxUnderrun |
+										   IntrTxDescRace )) {
+		if (debug > 2)
+			printk(KERN_INFO "%s: Unspecified error.\n",
+				   dev->name);
+	}
+	if (intr_status & ( IntrTxAborted | IntrTxUnderrun | IntrTxDescRace |
+						IntrTxError ))
 		via_rhine_restart_tx(dev);
 
 	if (intr_status & ~( IntrLinkChange | IntrStatsMax | IntrTxUnderrun |
- 						 IntrTxError | IntrTxAborted | IntrNormalSummary |
+						 IntrTxError | IntrTxAborted | IntrNormalSummary |
 						 IntrTxDescRace )) {
 		if (debug > 1)
 			printk(KERN_ERR "%s: Something Wicked happened! %8.8x.\n",
@@ -1690,6 +1704,8 @@ static void via_rhine_set_rx_mode(struct
 		/* Unconditionally log net taps. */
 		printk(KERN_NOTICE "%s: Promiscuous mode enabled.\n", dev->name);
 		rx_mode = 0x1C;
+		writel(0xffffffff, ioaddr + MulticastFilter0);
+		writel(0xffffffff, ioaddr + MulticastFilter1);
 	} else if ((dev->mc_count > multicast_filter_limit)
 			   ||  (dev->flags & IFF_ALLMULTI)) {
 		/* Too many to match, or accept all multicasts. */
diff -urNp linux-2/drivers/sound/opl3sa2.c linux-3/drivers/sound/opl3sa2.c
--- linux-2/drivers/sound/opl3sa2.c	
+++ linux-3/drivers/sound/opl3sa2.c	
@@ -390,6 +390,7 @@ static inline int ret_vol_stereo(int lef
 static int opl3sa2_mixer_ioctl(int dev, unsigned int cmd, caddr_t arg)
 {
 	int cmdf = cmd & 0xff;
+	int val;
 
 	opl3sa2_state_t* devc = (opl3sa2_state_t *) mixer_devs[dev]->devc;
 	
@@ -416,18 +417,19 @@ static int opl3sa2_mixer_ioctl(int dev, 
 				arg_to_vol_stereo(*(unsigned int*)arg,
 						  &devc->volume_l, &devc->volume_r); 
 				opl3sa2_set_volume(devc, devc->volume_l, devc->volume_r);
-				*(int*)arg = ret_vol_stereo(devc->volume_l, devc->volume_r);
-				return 0;
+				val = ret_vol_stereo(devc->volume_l, devc->volume_r);
+				break;
 		  
 			case SOUND_MIXER_MIC:
 				arg_to_vol_mono(*(unsigned int*)arg, &devc->mic);
 				opl3sa2_set_mic(devc, devc->mic);
-				*(int*)arg = ret_vol_mono(devc->mic);
-				return 0;
-
+				val = ret_vol_mono(devc->mic);
+				break;
+				
 			default:
 				return -EINVAL;
 		}
+		return put_user(val, (int *)arg);
 	}
 	else {
 		/*
@@ -435,36 +437,40 @@ static int opl3sa2_mixer_ioctl(int dev, 
 		 */
 		switch (cmdf) {
 			case SOUND_MIXER_DEVMASK:
-				*(int*)arg = (SOUND_MASK_VOLUME | SOUND_MASK_MIC);
-				return 0;
+				val = (SOUND_MASK_VOLUME | SOUND_MASK_MIC);
+				break;
 		  
 			case SOUND_MIXER_STEREODEVS:
-				*(int*)arg = SOUND_MASK_VOLUME;
-				return 0;
+				val = SOUND_MASK_VOLUME;
+				break;
 		  
 			case SOUND_MIXER_RECMASK:
 				/* No recording devices */
-				return (*(int*)arg = 0);
+				val = 0;
+				break;
 
 			case SOUND_MIXER_CAPS:
-				*(int*)arg = SOUND_CAP_EXCL_INPUT;
+				val = SOUND_CAP_EXCL_INPUT;
+				break;
 				return 0;
 
 			case SOUND_MIXER_RECSRC:
 				/* No recording source */
-				return (*(int*)arg = 0);
+				val = 0;
+				break;
 
 			case SOUND_MIXER_VOLUME:
-				*(int*)arg = ret_vol_stereo(devc->volume_l, devc->volume_r);
-				return 0;
+				val = ret_vol_stereo(devc->volume_l, devc->volume_r);
+				break;
 			  
 			case SOUND_MIXER_MIC:
-				*(int*)arg = ret_vol_mono(devc->mic);
-				return 0;
+				val = ret_vol_mono(devc->mic);
+				break;
 
 			default:
 				return -EINVAL;
 		}
+		return put_user(val, (int *)arg);
 	}
 }
 /* opl3sa2_mixer_ioctl end */
@@ -473,6 +479,7 @@ static int opl3sa2_mixer_ioctl(int dev, 
 static int opl3sa3_mixer_ioctl(int dev, unsigned int cmd, caddr_t arg)
 {
 	int cmdf = cmd & 0xff;
+	int val;
 
 	opl3sa2_state_t* devc = (opl3sa2_state_t *) mixer_devs[dev]->devc;
 
@@ -497,26 +504,27 @@ static int opl3sa3_mixer_ioctl(int dev, 
 				arg_to_vol_stereo(*(unsigned int*)arg,
 						  &devc->bass_l, &devc->bass_r); 
 				opl3sa3_set_bass(devc, devc->bass_l, devc->bass_r);
-				*(int*)arg = ret_vol_stereo(devc->bass_l, devc->bass_r);
-				return 0;
-		  
+				val = ret_vol_stereo(devc->bass_l, devc->bass_r);
+				break;
+						  
 			case SOUND_MIXER_TREBLE:
 				arg_to_vol_stereo(*(unsigned int*)arg,
 						  &devc->treble_l, &devc->treble_r); 
 				opl3sa3_set_treble(devc, devc->treble_l, devc->treble_r);
-				*(int*)arg = ret_vol_stereo(devc->treble_l, devc->treble_r);
-				return 0;
+				val = ret_vol_stereo(devc->treble_l, devc->treble_r);
+				break;
 
 			case SOUND_MIXER_DIGITAL1:
 				arg_to_vol_stereo(*(unsigned int*)arg,
 						  &devc->wide_l, &devc->wide_r); 
 				opl3sa3_set_wide(devc, devc->wide_l, devc->wide_r);
-				*(int*)arg = ret_vol_stereo(devc->wide_l, devc->wide_r);
-				return 0;
+				val = ret_vol_stereo(devc->wide_l, devc->wide_r);
+				break;
 
 			default:
 				return -EINVAL;
 		}
+		return put_user(val, (int *)arg);
 	}
 	else			
 	{
diff -urNp linux-2/include/linux/ethtool.h linux-3/include/linux/ethtool.h
--- linux-2/include/linux/ethtool.h	
+++ linux-3/include/linux/ethtool.h	
@@ -252,23 +252,23 @@ struct ethtool_stats {
 
 /* CMDs currently supported */
 #define ETHTOOL_GSET		0x00000001 /* Get settings. */
-#define ETHTOOL_SSET		0x00000002 /* Set settings, privileged. */
+#define ETHTOOL_SSET		0x00000002 /* Set settings. */
 #define ETHTOOL_GDRVINFO	0x00000003 /* Get driver info. */
-#define ETHTOOL_GREGS		0x00000004 /* Get NIC registers, privileged. */
+#define ETHTOOL_GREGS		0x00000004 /* Get NIC registers. */
 #define ETHTOOL_GWOL		0x00000005 /* Get wake-on-lan options. */
-#define ETHTOOL_SWOL		0x00000006 /* Set wake-on-lan options, priv. */
+#define ETHTOOL_SWOL		0x00000006 /* Set wake-on-lan options. */
 #define ETHTOOL_GMSGLVL		0x00000007 /* Get driver message level */
-#define ETHTOOL_SMSGLVL		0x00000008 /* Set driver msg level, priv. */
-#define ETHTOOL_NWAY_RST	0x00000009 /* Restart autonegotiation, priv. */
+#define ETHTOOL_SMSGLVL		0x00000008 /* Set driver msg level. */
+#define ETHTOOL_NWAY_RST	0x00000009 /* Restart autonegotiation. */
 #define ETHTOOL_GLINK		0x0000000a /* Get link status (ethtool_value) */
 #define ETHTOOL_GEEPROM		0x0000000b /* Get EEPROM data */
-#define ETHTOOL_SEEPROM		0x0000000c /* Set EEPROM data, priv. */
+#define ETHTOOL_SEEPROM		0x0000000c /* Set EEPROM data. */
 #define ETHTOOL_GCOALESCE	0x0000000e /* Get coalesce config */
-#define ETHTOOL_SCOALESCE	0x0000000f /* Set coalesce config, priv. */
+#define ETHTOOL_SCOALESCE	0x0000000f /* Set coalesce config. */
 #define ETHTOOL_GRINGPARAM	0x00000010 /* Get ring parameters */
-#define ETHTOOL_SRINGPARAM	0x00000011 /* Set ring parameters, priv. */
+#define ETHTOOL_SRINGPARAM	0x00000011 /* Set ring parameters. */
 #define ETHTOOL_GPAUSEPARAM	0x00000012 /* Get pause parameters */
-#define ETHTOOL_SPAUSEPARAM	0x00000013 /* Set pause parameters, priv. */
+#define ETHTOOL_SPAUSEPARAM	0x00000013 /* Set pause parameters. */
 #define ETHTOOL_GRXCSUM		0x00000014 /* Get RX hw csum enable (ethtool_value) */
 #define ETHTOOL_SRXCSUM		0x00000015 /* Set RX hw csum enable (ethtool_value) */
 #define ETHTOOL_GTXCSUM		0x00000016 /* Get TX hw csum enable (ethtool_value) */
@@ -276,8 +276,8 @@ struct ethtool_stats {
 #define ETHTOOL_GSG		0x00000018 /* Get scatter-gather enable
 					    * (ethtool_value) */
 #define ETHTOOL_SSG		0x00000019 /* Set scatter-gather enable
-					    * (ethtool_value), priv. */
-#define ETHTOOL_TEST		0x0000001a /* execute NIC self-test, priv. */
+					    * (ethtool_value). */
+#define ETHTOOL_TEST		0x0000001a /* execute NIC self-test. */
 #define ETHTOOL_GSTRINGS	0x0000001b /* get specified string set */
 #define ETHTOOL_PHYS_ID		0x0000001c /* identify the NIC */
 #define ETHTOOL_GSTATS		0x0000001d /* get NIC-specific statistics */
@@ -299,6 +299,7 @@ struct ethtool_stats {
 #define SUPPORTED_MII			(1 << 9)
 #define SUPPORTED_FIBRE			(1 << 10)
 #define SUPPORTED_BNC			(1 << 11)
+#define SUPPORTED_10000baseT_Full	(1 << 12)
 
 /* Indicates what features are advertised by the interface. */
 #define ADVERTISED_10baseT_Half		(1 << 0)
@@ -313,6 +314,7 @@ struct ethtool_stats {
 #define ADVERTISED_MII			(1 << 9)
 #define ADVERTISED_FIBRE		(1 << 10)
 #define ADVERTISED_BNC			(1 << 11)
+#define ADVERTISED_10000baseT_Full	(1 << 12)
 
 /* The following are all involved in forcing a particular link
  * mode for the device for setting things.  When getting the
@@ -320,10 +322,11 @@ struct ethtool_stats {
  * it was foced up into this mode or autonegotiated.
  */
 
-/* The forced speed, 10Mb, 100Mb, gigabit. */
+/* The forced speed, 10Mb, 100Mb, gigabit, 10GbE. */
 #define SPEED_10		10
 #define SPEED_100		100
 #define SPEED_1000		1000
+#define SPEED_10000		10000
 
 /* Duplex, half or full. */
 #define DUPLEX_HALF		0x00
diff -urNp linux-2/include/linux/if_arcnet.h linux-3/include/linux/if_arcnet.h
--- linux-2/include/linux/if_arcnet.h	2000-12-11 15:59:27.000000000 -0500
+++ linux-3/include/linux/if_arcnet.h	
@@ -25,6 +25,7 @@
 
 /* RFC1201 Protocol ID's */
 #define ARC_P_IP		212	/* 0xD4 */
+#define ARC_P_IPV6		196	/* 0xC4: RFC2497 */
 #define ARC_P_ARP		213	/* 0xD5 */
 #define ARC_P_RARP		214	/* 0xD6 */
 #define ARC_P_IPX		250	/* 0xFA */
@@ -45,6 +46,9 @@
 #define ARC_P_LANSOFT		251	/* 0xFB - what is this? */
 #define ARC_P_ATALK		0xDD
 
+/* Hardware address length */
+#define ARCNET_ALEN	1
+
 /*
  * The RFC1201-specific components of an arcnet packet header.
  */
diff -urNp linux-2/include/linux/pci.h linux-3/include/linux/pci.h
--- linux-2/include/linux/pci.h	
+++ linux-3/include/linux/pci.h	
@@ -773,6 +773,11 @@ static inline void pci_set_drvdata (stru
 	pdev->driver_data = data;
 }
 
+static inline char *pci_name(struct pci_dev *pdev)
+{
+	return pdev->slot_name;
+}
+
 /*
  *  The world is not perfect and supplies us with broken PCI devices.
  *  For at least a part of these bugs we need a work-around, so both
