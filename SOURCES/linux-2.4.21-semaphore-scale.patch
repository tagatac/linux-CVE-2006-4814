diff -urNp linux-850/include/linux/brlock.h linux-860/include/linux/brlock.h
--- linux-850/include/linux/brlock.h
+++ linux-860/include/linux/brlock.h
@@ -35,6 +35,7 @@ enum brlock_indices {
 	BR_GLOBALIRQ_LOCK,
 	BR_NETPROTO_LOCK,
 	BR_AIO_REQ_LOCK,
+	BR_SEMAPHORE_LOCK,
 
 	__BR_END
 };
diff -urNp linux-850/include/linux/ipc.h linux-860/include/linux/ipc.h
--- linux-850/include/linux/ipc.h
+++ linux-860/include/linux/ipc.h
@@ -56,6 +56,7 @@ struct ipc_perm
 /* used by in-kernel data structures */
 struct kern_ipc_perm
 {
+	spinlock_t	lock;
 	key_t		key;
 	uid_t		uid;
 	gid_t		gid;
diff -urNp linux-850/ipc/msg.c linux-860/ipc/msg.c
--- linux-850/ipc/msg.c
+++ linux-860/ipc/msg.c
@@ -93,6 +93,8 @@ static struct ipc_ids msg_ids;
 
 #define msg_lock(id)	((struct msg_queue*)ipc_lock(&msg_ids,id))
 #define msg_unlock(id)	ipc_unlock(&msg_ids,id)
+#define msg_write_lock(id)	((struct msg_queue*)ipc_write_lock(&msg_ids,id))
+#define msg_write_unlock(id)	ipc_write_unlock(&msg_ids,id)
 #define msg_rmid(id)	((struct msg_queue*)ipc_rmid(&msg_ids,id))
 #define msg_checkid(msq, msgid)	\
 	ipc_checkid(&msg_ids,&msq->q_perm,msgid)
@@ -287,7 +289,7 @@ static void freeque (int id)
 
 	expunge_all(msq,-EIDRM);
 	ss_wakeup(&msq->q_senders,1);
-	msg_unlock(id);
+	msg_write_unlock(id);
 		
 	tmp = msq->q_messages.next;
 	while(tmp != &msq->q_messages) {
@@ -521,7 +523,7 @@ asmlinkage long sys_msgctl (int msqid, i
 	}
 
 	down(&msg_ids.sem);
-	msq = msg_lock(msqid);
+	msq = msg_write_lock(msqid);
 	err=-EINVAL;
 	if (msq == NULL)
 		goto out_up;
@@ -556,7 +558,7 @@ asmlinkage long sys_msgctl (int msqid, i
 		 * due to a larger queue size.
 		 */
 		ss_wakeup(&msq->q_senders,0);
-		msg_unlock(msqid);
+		msg_write_unlock(msqid);
 		break;
 	}
 	case IPC_RMID:
@@ -568,7 +570,7 @@ out_up:
 	up(&msg_ids.sem);
 	return err;
 out_unlock_up:
-	msg_unlock(msqid);
+	msg_write_unlock(msqid);
 	goto out_up;
 out_unlock:
 	msg_unlock(msqid);
diff -urNp linux-850/ipc/sem.c linux-860/ipc/sem.c
--- linux-850/ipc/sem.c
+++ linux-860/ipc/sem.c
@@ -69,6 +69,8 @@
 
 #define sem_lock(id)	((struct sem_array*)ipc_lock(&sem_ids,id))
 #define sem_unlock(id)	ipc_unlock(&sem_ids,id)
+#define sem_write_lock(id)	((struct sem_array*)ipc_write_lock(&sem_ids,id))
+#define sem_write_unlock(id)	ipc_write_unlock(&sem_ids,id)
 #define sem_rmid(id)	((struct sem_array*)ipc_rmid(&sem_ids,id))
 #define sem_checkid(sma, semid)	\
 	ipc_checkid(&sem_ids,&sma->sem_perm,semid)
@@ -412,7 +414,7 @@ static void freeary (int id)
 		q->prev = NULL;
 		wake_up_process(q->sleeper); /* doesn't sleep */
 	}
-	sem_unlock(id);
+	sem_write_unlock(id);
 
 	used_sems -= sma->sem_nsems;
 	size = sizeof (*sma) + sma->sem_nsems * sizeof (struct sem);
@@ -711,7 +713,7 @@ static int semctl_down(int semid, int se
 		if(copy_semid_from_user (&setbuf, arg.buf, version))
 			return -EFAULT;
 	}
-	sma = sem_lock(semid);
+	sma = sem_write_lock(semid);
 	if(sma==NULL)
 		return -EINVAL;
 
@@ -738,18 +740,18 @@ static int semctl_down(int semid, int se
 		ipcp->mode = (ipcp->mode & ~S_IRWXUGO)
 				| (setbuf.mode & S_IRWXUGO);
 		sma->sem_ctime = CURRENT_TIME;
-		sem_unlock(semid);
+		sem_write_unlock(semid);
 		err = 0;
 		break;
 	default:
-		sem_unlock(semid);
+		sem_write_unlock(semid);
 		err = -EINVAL;
 		break;
 	}
 	return err;
 
 out_unlock:
-	sem_unlock(semid);
+	sem_write_unlock(semid);
 	return err;
 }
 
diff -urNp linux-850/ipc/shm.c linux-860/ipc/shm.c
--- linux-850/ipc/shm.c
+++ linux-860/ipc/shm.c
@@ -49,8 +49,7 @@ static struct ipc_ids shm_ids;
 
 #define shm_lock(id)	((struct shmid_kernel*)ipc_lock(&shm_ids,id))
 #define shm_unlock(id)	ipc_unlock(&shm_ids,id)
-#define shm_lockall()	ipc_lockall(&shm_ids)
-#define shm_unlockall()	ipc_unlockall(&shm_ids)
+#define shm_unlock_deleted(shp)	ipc_unlock_deleted(&(shp)->shm_perm)
 #define shm_get(id)	((struct shmid_kernel*)ipc_get(&shm_ids,id))
 #define shm_buildid(id, seq) \
 	ipc_buildid(&shm_ids, id, seq)
@@ -124,7 +123,7 @@ static void shm_destroy (struct shmid_ke
 {
 	shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;
 	shm_rmid (shp->id);
-	shm_unlock(shp->id);
+	shm_unlock_deleted(shp);
 	shmem_lock(shp->shm_file, 0);
 	fput (shp->shm_file);
 	kfree (shp);
@@ -408,14 +407,12 @@ asmlinkage long sys_shmctl (int shmid, i
 
 		memset(&shm_info,0,sizeof(shm_info));
 		down(&shm_ids.sem);
-		shm_lockall();
 		shm_info.used_ids = shm_ids.in_use;
 		shm_get_stat (&shm_info.shm_rss, &shm_info.shm_swp);
 		shm_info.shm_tot = shm_tot;
 		shm_info.swap_attempts = 0;
 		shm_info.swap_successes = 0;
 		err = shm_ids.max_id;
-		shm_unlockall();
 		up(&shm_ids.sem);
 		if(copy_to_user (buf, &shm_info, sizeof(shm_info)))
 			return -EFAULT;
diff -urNp linux-850/ipc/util.c linux-860/ipc/util.c
--- linux-850/ipc/util.c
+++ linux-860/ipc/util.c
@@ -74,7 +74,6 @@ void __init ipc_init_ids(struct ipc_ids*
 		printk(KERN_ERR "ipc_init_ids() failed, ipc service disabled.\n");
 		ids->size = 0;
 	}
-	ids->ary = SPIN_LOCK_UNLOCKED;
 	for(i=0;i<ids->size;i++)
 		ids->entries[i].p = NULL;
 }
@@ -120,13 +119,12 @@ static int grow_ary(struct ipc_ids* ids,
 	for(i=ids->size;i<newsize;i++) {
 		new[i].p = NULL;
 	}
-	spin_lock(&ids->ary);
-
+	br_write_lock(BR_SEMAPHORE_LOCK);
 	old = ids->entries;
 	ids->entries = new;
 	i = ids->size;
 	ids->size = newsize;
-	spin_unlock(&ids->ary);
+	br_write_unlock(BR_SEMAPHORE_LOCK);
 	ipc_free(old, sizeof(struct ipc_id)*i);
 	return ids->size;
 }
@@ -165,7 +163,9 @@ found:
 	if(ids->seq > ids->seq_max)
 		ids->seq = 0;
 
-	spin_lock(&ids->ary);
+	new->lock = SPIN_LOCK_UNLOCKED;
+	br_read_lock(BR_SEMAPHORE_LOCK);
+	spin_lock(&new->lock);
 	ids->entries[id].p = new;
 	return id;
 }
diff -urNp linux-850/ipc/util.h linux-860/ipc/util.h
--- linux-850/ipc/util.h
+++ linux-860/ipc/util.h
@@ -5,6 +5,8 @@
  * ipc helper functions (c) 1999 Manfred Spraul <manfreds@colorfullife.com>
  */
 
+#include <linux/brlock.h>
+
 #define USHRT_MAX 0xffff
 #define SEQ_MULTIPLIER	(IPCMNI)
 
@@ -19,7 +21,6 @@ struct ipc_ids {
 	unsigned short seq;
 	unsigned short seq_max;
 	struct semaphore sem;	
-	spinlock_t ary;
 	struct ipc_id* entries;
 };
 
@@ -45,45 +46,100 @@ int ipcperms (struct kern_ipc_perm *ipcp
 void* ipc_alloc(int size);
 void ipc_free(void* ptr, int size);
 
-extern inline void ipc_lockall(struct ipc_ids* ids)
+extern inline struct kern_ipc_perm* ipc_get(struct ipc_ids* ids, int id)
 {
-	spin_lock(&ids->ary);
+	struct kern_ipc_perm* out;
+	int lid = id % SEQ_MULTIPLIER;
+	if(lid >= ids->size)
+		return NULL;
+
+	out = ids->entries[lid].p;
+	return out;
 }
 
-extern inline struct kern_ipc_perm* ipc_get(struct ipc_ids* ids, int id)
+extern inline struct kern_ipc_perm* ipc_lock(struct ipc_ids* ids, int id)
 {
 	struct kern_ipc_perm* out;
 	int lid = id % SEQ_MULTIPLIER;
 	if(lid >= ids->size)
 		return NULL;
 
+	br_read_lock(BR_SEMAPHORE_LOCK);
 	out = ids->entries[lid].p;
+	if (!out) {
+		br_read_unlock(BR_SEMAPHORE_LOCK);
+		return NULL;
+	}
+	spin_lock(&out->lock);
+	/*
+	 * ipc_rmid() may have already freed the ID while ipc_lock()
+	 * was spinning, so verify that the structure is still valid.
+	 */
+	if (lid >= ids->size || !ids->entries[lid].p) {
+		spin_unlock(&out->lock);
+		br_read_unlock(BR_SEMAPHORE_LOCK);
+		return NULL;
+	}
+
 	return out;
 }
 
-extern inline void ipc_unlockall(struct ipc_ids* ids)
+extern inline void ipc_unlock(struct ipc_ids* ids, int id)
 {
-	spin_unlock(&ids->ary);
+	int lid = id % SEQ_MULTIPLIER;
+	struct kern_ipc_perm* out;
+
+	if (lid >= ids->size)
+		return;
+	out = ids->entries[lid].p;
+	if (out)
+		spin_unlock(&out->lock);
+	br_read_unlock(BR_SEMAPHORE_LOCK);
 }
-extern inline struct kern_ipc_perm* ipc_lock(struct ipc_ids* ids, int id)
+
+extern inline void ipc_unlock_deleted(struct kern_ipc_perm* perm)
+{
+	spin_unlock(&perm->lock);
+	br_read_unlock(BR_SEMAPHORE_LOCK);
+	/*
+	 * Wait for other readers waiting on spinlock and
+	 * holding read locks to disappear.
+	 */
+	br_write_lock(BR_SEMAPHORE_LOCK);
+	br_write_unlock(BR_SEMAPHORE_LOCK);
+}
+
+extern inline struct kern_ipc_perm* ipc_write_lock(struct ipc_ids* ids, int id)
 {
 	struct kern_ipc_perm* out;
 	int lid = id % SEQ_MULTIPLIER;
 	if(lid >= ids->size)
 		return NULL;
 
-	spin_lock(&ids->ary);
+	br_write_lock(BR_SEMAPHORE_LOCK);
 	out = ids->entries[lid].p;
-	if(out==NULL)
-		spin_unlock(&ids->ary);
+	if (!out) {
+		br_write_unlock(BR_SEMAPHORE_LOCK);
+		return NULL;
+	}
+	spin_lock(&out->lock);
 	return out;
 }
 
-extern inline void ipc_unlock(struct ipc_ids* ids, int id)
+extern inline void ipc_write_unlock(struct ipc_ids* ids, int id)
 {
-	spin_unlock(&ids->ary);
+	int lid = id % SEQ_MULTIPLIER;
+	struct kern_ipc_perm* out;
+
+	if (lid >= ids->size)
+		return;
+	out = ids->entries[lid].p;
+	if (out)
+		spin_unlock(&out->lock);
+	br_write_unlock(BR_SEMAPHORE_LOCK);
 }
 
+
 extern inline int ipc_buildid(struct ipc_ids* ids, int id, int seq)
 {
 	return SEQ_MULTIPLIER*seq + id;
