diff -urNp linux-1151/Documentation/filesystems/proc.txt linux-1160/Documentation/filesystems/proc.txt
--- linux-1151/Documentation/filesystems/proc.txt
+++ linux-1160/Documentation/filesystems/proc.txt
@@ -326,6 +326,121 @@ Linux uses  slab  pools for memory manag
 Commonly used  objects  have  their  own  slab  pool (such as network buffers,
 directory cache, and so on).
 
+..............................................................................
+
+meminfo:
+
+Provides information about distribution and utilization of memory.  This
+varies by architecture and compile options.  The following is from a
+16GB PIII, which has highmem enabled.  You may not have all of these fields.
+
+> cat /proc/meminfo
+
+
+MemTotal:     16344972 kB
+MemFree:      13634064 kB
+MemShared:           0 kB
+Buffers:          3656 kB
+Cached:        1195708 kB
+SwapCached:          0 kB
+Active:         891636 kB
+ActiveAnon:      15464 kB
+ActiveCache:    534348 kB
+Inact_dirty:    104052 kB
+Inact_laundry:   16484 kB
+Inact_clean:     14976 kB
+Inact_target:   137064 kB
+HighTotal:    15597528 kB
+HighFree:     13629632 kB
+LowTotal:       747444 kB
+LowFree:          4432 kB
+SwapTotal:           0 kB
+SwapFree:            0 kB
+Slab:           684068 kB
+CommitLimit:   7669796 kB
+Committed_AS:   100056 kB
+HugePages_Total:     0
+HugePages_Free:      0
+Hugepagesize:     2048 kB
+
+     MemTotal: Total usable ram (i.e. physical ram minus a few reserved
+               bits and the kernel binary code)
+      MemFree: The sum of LowFree+HighFree
+    MemShared: 0; is here for compat reasons but always zero.
+      Buffers: Relatively temporary storage for raw disk blocks
+               shouldn't get tremendously large (20MB or so)
+       Cached: in-memory cache for files read from the disk (the
+               pagecache).  Doesn't include SwapCached
+   SwapCached: Memory that once was swapped out, is swapped back in but
+               still also is in the swapfile (if memory is needed it
+               doesn't need to be swapped out AGAIN because it is already
+               in the swapfile. This saves I/O)
+       Active: Memory that has been used more recently and usually not
+               reclaimed unless absolutely necessary.
+   ActiveAnon: Active memory which is mapped into user processes, plus
+               swap cache.
+  ActiveCache: Active memory which is caching files and not mapped into
+               user memory.
+  Inact_dirty: Memory which has fallen into disuse and is a candidate
+	       to be reclaimed.
+Inact_laundry: Memory which has been tagged to be reclaimed, but whose
+	       contents have not yet been written out/synced to disk. 
+  Inact_clean: Memory which has been tagged to be reclaimed and has 
+	       been written out/synced to disk. It is now available to
+	       be reallocated by the VM. 
+ Inact_target: A goal metric the kernel uses for making sure there are
+               enough inactive pages around. When exceeded, the kernel
+               will not do work to move pages from active to inactive.
+               A page can also get inactive in a few other ways, e.g. if
+               you do a long sequential I/O, the kernel assumes you're
+               not going to use that memory and makes it inactive
+               preventively. So you can get more inactive pages than the
+               target because the kernel marks some cache as "more likely
+               to be never used" and lets it cheat in the "last used" order.
+   HighTotal:
+    HighFree:  Highmem is all memory above ~860MB of physical memory
+               Highmem areas are for use by userspace programs, or
+               for the pagecache.  The kernel must use tricks to access
+               this memory, making it slower to access than lowmem.
+    LowTotal:
+     LowFree:  Lowmem is memory which can be used for everything that
+               highmem can be used for, but it is also availble for the
+               kernel's use for its own data structures.  Among many
+               other things, it is where everything from the Slab is
+               allocated.  Bad things happen when you're out of lowmem.
+   SwapTotal:  total amount of swap space available
+    SwapFree:  Memory which has been evicted from RAM, and is temporarily
+               on the disk
+ CommitLimit:  Based on the overcommit ratio ('vm.overcommit_ratio'),
+               this is the total amount of  memory currently available to
+               be allocated on the system. This limit is only adhered to
+               if strict overcommit accounting is enabled (mode 2 in
+               'vm.overcommit_memory').
+               The CommitLimit is calculated with the following formula:
+               CommitLimit = ('vm.overcommit_ratio' * Physical RAM) + Swap
+               For example, on a system with 1G of physical RAM and 7G
+               of swap with a `vm.overcommit_ratio` of 30 it would
+               yield a CommitLimit of 7.3G.
+               For more details, see the memory overcommit documentation
+               in vm/overcommit-accounting.
+Committed_AS:  The amount of memory presently allocated on the system.
+               The committed memory is a sum of all of the memory which
+               has been allocated by processes, even if it has not been
+               "used" by them as of yet. A process which malloc()'s 1G
+               of memory, but only touches 300M of it will only show up
+               as using 300M of memory even if it has the address space
+               allocated for the entire 1G. This 1G is memory which has
+               been "committed" to by the VM and can be used at any time
+               by the allocating application. With strict overcommit
+               enabled on the system (mode 2 in 'vm.overcommit_memory'),
+               allocations which would exceed the CommitLimit (detailed
+               above) will not be permitted. This is useful if one needs
+               to guarantee that processes will not fail due to lack of
+               memory once that memory has been successfully allocated.
+HugePages_Total:
+HugePages_Free:
+Hugepagesize:
+
 1.3 IDE devices in /proc/ide
 ----------------------------
 
diff -urNp linux-1151/Documentation/vm/overcommit-accounting linux-1160/Documentation/vm/overcommit-accounting
--- linux-1151/Documentation/vm/overcommit-accounting
+++ linux-1160/Documentation/vm/overcommit-accounting
@@ -22,6 +22,13 @@ The Linux kernel supports four overcommi
 		will never kill a process accessing pages it has mapped
 		except due to a bug (ie report it!)
 
+The overcommit policy is set via the sysctl `vm.overcommit_memory'.
+
+The overcommit percentage is set via `vm.overcommit_ratio'.
+
+The current overcommit limit and amount committed are viewable in
+/proc/meminfo as CommitLimit and Committed_AS respectively.
+
 Gotchas
 -------
 
diff -urNp linux-1151/fs/proc/proc_misc.c linux-1160/fs/proc/proc_misc.c
--- linux-1151/fs/proc/proc_misc.c
+++ linux-1160/fs/proc/proc_misc.c
@@ -159,11 +159,9 @@ static int meminfo_read_proc(char *page,
 	struct sysinfo i;
 	int len;
 	int pg_size ;
-	int committed;
+	unsigned long committed;
+	unsigned long allowed;
 
-	/* FIXME: needs to be in headers */
-	extern atomic_t vm_committed_space;
-	
 /*
  * display in kilobytes.
  */
@@ -173,6 +171,8 @@ static int meminfo_read_proc(char *page,
 	si_swapinfo(&i);
 	pg_size = atomic_read(&page_cache_size) - i.bufferram ;
 	committed = atomic_read(&vm_committed_space);
+	allowed = (i.totalram * sysctl_overcommit_ratio / 100)
+		  + total_swap_pages;
 
 	len = sprintf(page, "        total:    used:    free:  shared: buffers:  cached:\n"
 		"Mem:  %8Lu %8Lu %8Lu %8Lu %8Lu %8Lu\n"
@@ -205,7 +205,9 @@ static int meminfo_read_proc(char *page,
 		"LowTotal:     %8lu kB\n"
 		"LowFree:      %8lu kB\n"
 		"SwapTotal:    %8lu kB\n"
-		"SwapFree:     %8lu kB\n",
+		"SwapFree:     %8lu kB\n"
+		"CommitLimit:  %8lu kB\n"
+		"Committed_AS: %8lu kB\n",
 		K(i.totalram),
 		K(i.freeram),
 		K(i.sharedram),
@@ -224,7 +226,9 @@ static int meminfo_read_proc(char *page,
 		K(i.totalram-i.totalhigh),
 		K(i.freeram-i.freehigh),
 		K(i.totalswap),
-		K(i.freeswap));
+		K(i.freeswap),
+		K(allowed),
+		K(committed));
 
 	len += hugetlb_report_meminfo(page + len);
 
diff -urNp linux-1151/include/linux/mman.h linux-1160/include/linux/mman.h
--- linux-1151/include/linux/mman.h
+++ linux-1160/include/linux/mman.h
@@ -9,6 +9,8 @@
 extern int vm_enough_memory(long pages);
 extern void vm_unacct_memory(long pages);
 extern void vm_validate_enough(char *x);
+extern atomic_t vm_committed_space;
+extern int sysctl_overcommit_ratio;
 
 #ifndef MAP_POPULATE
 # define MAP_POPULATE 0x8000
diff -urNp linux-1151/include/linux/sysctl.h linux-1160/include/linux/sysctl.h
--- linux-1151/include/linux/sysctl.h
+++ linux-1160/include/linux/sysctl.h
@@ -148,6 +148,7 @@ enum
 	VM_MAX_MAP_COUNT=11,	/* int: Maximum number of active map areas */
 	VM_MIN_READAHEAD=12,    /* Min file readahead */
 	VM_MAX_READAHEAD=13,    /* Max file readahead */
+	VM_OVERCOMMIT_RATIO=16,	/* percent of RAM to allow overcommit in */
 	VM_PAGEBUF=22,		/* struct: Control pagebuf parameters */
 	VM_HUGETLB_POOL=23,	/* int: size of the hugetlb pool, in MB */
 };
diff -urNp linux-1151/kernel/fork.c linux-1160/kernel/fork.c
--- linux-1151/kernel/fork.c
+++ linux-1160/kernel/fork.c
@@ -187,7 +187,7 @@ static inline int dup_mmap(struct mm_str
 {
 	struct vm_area_struct * mpnt, *tmp, **pprev;
 	int retval;
-	unsigned long charge = 0;
+	unsigned long charge;
 
 	flush_cache_mm(current->mm);
 	mm->locked_vm = 0;
@@ -218,11 +218,12 @@ static inline int dup_mmap(struct mm_str
 		retval = -ENOMEM;
 		if(mpnt->vm_flags & VM_DONTCOPY)
 			continue;
+		charge = 0;
 		if(mpnt->vm_flags & VM_ACCOUNT) {
 			unsigned int len = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT;
 			if(!vm_enough_memory(len))
 				goto fail_nomem;
-			charge += len;
+			charge = len;
 		}
 		tmp = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
 		if (!tmp)
diff -urNp linux-1151/kernel/sysctl.c linux-1160/kernel/sysctl.c
--- linux-1151/kernel/sysctl.c
+++ linux-1160/kernel/sysctl.c
@@ -48,6 +48,7 @@ extern int panic_timeout;
 extern int C_A_D;
 extern int bdf_prm[], bdflush_min[], bdflush_max[];
 extern int sysctl_overcommit_memory;
+extern int sysctl_overcommit_ratio;
 extern int max_threads;
 extern atomic_t nr_queued_signals;
 extern int max_queued_signals;
@@ -328,6 +329,8 @@ static ctl_table vm_table[] = {
 	 &bdflush_min, &bdflush_max},
 	{VM_OVERCOMMIT_MEMORY, "overcommit_memory", &sysctl_overcommit_memory,
 	 sizeof(sysctl_overcommit_memory), 0644, NULL, &proc_dointvec},
+	{VM_OVERCOMMIT_RATIO, "overcommit_ratio", &sysctl_overcommit_ratio,
+	 sizeof(sysctl_overcommit_ratio), 0644, NULL, &proc_dointvec},
 	{VM_PAGECACHE, "pagecache", &cache_limits,
 	 sizeof(struct cache_limits), 0644, NULL, &proc_dointvec},
 	{VM_PAGERDAEMON, "kswapd",
diff -urNp linux-1151/mm/mmap.c linux-1160/mm/mmap.c
--- linux-1151/mm/mmap.c
+++ linux-1160/mm/mmap.c
@@ -64,7 +64,8 @@ pgprot_t protection_map[16] = {
 	__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111
 };
 
-int sysctl_overcommit_memory;
+int sysctl_overcommit_memory = 0;	/* default is heuristic overcommit */
+int sysctl_overcommit_ratio = 50;	/* default is 50% */
 int max_map_count = DEFAULT_MAX_MAP_COUNT;
 atomic_t vm_committed_space = ATOMIC_INIT(0);
 
@@ -122,20 +123,18 @@ int vm_enough_memory(long pages)
 		atomic_sub(pages, &vm_committed_space);
 		return 0;
 	}
-	allowed = total_swap_pages;
+
+	/* FIXME - need to add arch hooks to get the bits we need 
+	   without the higher overhead crap */
+	si_meminfo(&i);	
+	allowed = i.totalram * sysctl_overcommit_ratio / 100;
+	allowed += total_swap_pages;
 	
-	if(sysctl_overcommit_memory == 2)
-	{
-		/* FIXME - need to add arch hooks to get the bits we need
-		   without the higher overhead crap */
-		si_meminfo(&i);	
-		allowed += i.totalram >> 1;
-	}
 	if(atomic_read(&vm_committed_space) < allowed)
 		return 1;
+
 	atomic_sub(pages, &vm_committed_space);
 	return 0;
-	
 }
 
 void vm_unacct_memory(long pages)
