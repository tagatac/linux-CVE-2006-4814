The VERITAS VxFS filesystem has a problem with the way sync_supers()
was rewritten for Linux 2.4.8, and remains today.  To keep control of
flushing its data and metadata, while respecting user calls to sync,
VxFS needs to leave the s_dirt flag set.  But to escape its loop,
sync_supers() relies on filesystem write_super() to clear s_dirt.  Hang!

It appears that others met this problem: when 2.4.21 added the sync_fs
operation, distinct from write_super.  Whereas sync_fs is usually called
whether or not s_dirt is set, in the sync_supers loop it is called only
when s_dirt is set - no doubt to avoid a similar hang.  But this exposes
a weakness: a prior call to sync_supers may have just cleared the s_dirt
flag, and a waiting call to sync_supers then miss waiting upon that sb.
So although sync_fs is supposed to give a guarantee, it fails to do so.
 
And Linux 2.5 met problems here too.  Although its sync_supers() is just
as in 2.4.8, it has a separate sync_filesystems() to do the new sync_fs.
It faced the complementary issue, that one task generating lots of data
could hold another task indefinitely within the sync system call.  It
solved this by single-threading sync_filesystems through a mutex, with
sb->s_need_sync_fs flag set in one pass, cleared in second sync_fs pass.

The first patch we offered for RHEL3.0 followed that rather heavy-handed
approach, but you rightly objected to the mutex.  This replacement patch
(based upon 2.4.21-1.1931.2.393 source) is much closer to the one we've
been using within VERITAS for the last two years: don't restart from the
beginning of the super_blocks list every time, just when a racing umount
removes the current sb from the list.

We've used list_del_init with list_empty check, instead of list_del with
NULL check, because quite what list_del does to the stale next and prev
pointers tends to vary from release to release: safer to use the well-
defined list_del_init.  We wondered whether to add MS_RDONLY check like
in 2.5, but although it seems a plausible speedup, didn't follow through
the implications.  Tested with ext3 and with jfs, the filesystems which
implement a sync_fs: hmm, did sync_supers(0, 1) ever work on jfs before?
it looks like jfs leaves s_dirt unset.

--- linux-2.4.21-1.1931.2.393/fs/super.c	Thu Aug 14 02:24:50 2003
+++ linux/fs/super.c	Sun Aug 17 17:36:00 2003
@@ -423,7 +423,7 @@
 	struct file_system_type *fs = s->s_type;
 
 	spin_lock(&sb_lock);
-	list_del(&s->s_list);
+	list_del_init(&s->s_list);
 	list_del(&s->s_instances);
 	spin_unlock(&sb_lock);
 	up_write(&s->s_umount);
@@ -500,21 +500,34 @@
 		}
 		return;
 	}
-restart:
+
 	spin_lock(&sb_lock);
+restart:
 	sb = sb_entry(super_blocks.next);
-	while (sb != sb_entry(&super_blocks))
-		if (sb->s_dirt) {
+	while (sb != sb_entry(&super_blocks)) {
+		int (*sync_fs)(struct super_block *) = 0;
+		if (wait && sb->s_op)
+			sync_fs = sb->s_op->sync_fs;
+		if (sb->s_dirt || sync_fs) {
 			sb->s_count++;
 			spin_unlock(&sb_lock);
 			down_read(&sb->s_umount);
-			write_super(sb);
-			if (wait && sb->s_root && sb->s_op && sb->s_op->sync_fs)
-				sb->s_op->sync_fs(sb);
-			drop_super(sb);
-			goto restart;
-		} else
-			sb = sb_entry(sb->s_list.next);
+			if (sb->s_dirt)
+				write_super(sb);
+			if (sync_fs && sb->s_root)
+				sync_fs(sb);
+			up_read(&sb->s_umount);
+			spin_lock(&sb_lock);
+			if (!--sb->s_count) {
+				destroy_super(sb);
+				goto restart;
+			} else if (list_empty(&sb->s_list)) {
+				/* sb has just been removed from the list */
+				goto restart;
+			}
+		}
+		sb = sb_entry(sb->s_list.next);
+	}
 	spin_unlock(&sb_lock);
 }
 
