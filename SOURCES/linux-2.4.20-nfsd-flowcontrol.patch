--- linux-2.4.20/include/linux/sunrpc/svcsock.h.diff	2003-05-29 14:18:53.000000000 -0400
+++ linux-2.4.20/include/linux/sunrpc/svcsock.h	2003-05-29 14:19:12.000000000 -0400
@@ -52,7 +52,7 @@
  * Function prototypes.
  */
 int		svc_makesock(struct svc_serv *, int, unsigned short);
-void		svc_delete_socket(struct svc_sock *);
+void		svc_delete_socket(struct svc_sock *, int);
 int		svc_recv(struct svc_serv *, struct svc_rqst *, long);
 int		svc_send(struct svc_rqst *);
 void		svc_drop(struct svc_rqst *);
--- linux-2.4.20/net/sunrpc/svcsock.c.diff	2003-05-29 11:47:01.000000000 -0400
+++ linux-2.4.20/net/sunrpc/svcsock.c	2003-05-29 14:39:02.000000000 -0400
@@ -34,6 +34,7 @@
 #include <net/sock.h>
 #include <net/checksum.h>
 #include <net/ip.h>
+#include <net/tcp.h>
 #include <asm/uaccess.h>
 #include <asm/ioctls.h>
 
@@ -105,6 +106,21 @@
 	dprintk("svc: service %p, releasing skb %p\n", rqstp, skb);
 	skb_free_datagram(rqstp->rq_sock->sk_sk, skb);
 }
+/*
+ * Any space to write?
+ */
+static inline unsigned long
+svc_sock_wspace(struct svc_sock *svsk)
+{
+	int wspace;
+
+	if (svsk->sk_sock->type == SOCK_STREAM)
+		wspace = tcp_wspace(svsk->sk_sk);
+	else
+		wspace = sock_wspace(svsk->sk_sk);
+ 
+ 	return wspace;
+ }
 
 /*
  * Queue up a socket with data pending. If there are idle nfsd
@@ -134,16 +150,18 @@
 		goto out_unlock;
 	}
 
+	set_bit(SOCK_NOSPACE, &svsk->sk_sock->flags);
 	if (((svsk->sk_reserved + serv->sv_bufsz)*2
-	     > sock_wspace(svsk->sk_sk))
+	     > svc_sock_wspace(svsk))
 	    && !test_bit(SK_CLOSE, &svsk->sk_flags)
 	    && !test_bit(SK_CONN, &svsk->sk_flags)) {
 		/* Don't enqueue while not enough space for reply */
 		dprintk("svc: socket %p  no space, %d*2 > %ld, not enqueued\n",
 			svsk->sk_sk, svsk->sk_reserved+serv->sv_bufsz,
-			sock_wspace(svsk->sk_sk));
+			svc_sock_wspace(svsk));
 		goto out_unlock;
 	}
+	clear_bit(SOCK_NOSPACE, &svsk->sk_sock->flags);
 
 	/* Mark socket as busy. It will remain in this state until the
 	 * server has processed all pending data and put the socket back
@@ -788,7 +806,7 @@
 		test_bit(SK_CLOSE, &svsk->sk_flags));
 
 	if (test_bit(SK_CLOSE, &svsk->sk_flags)) {
-		svc_delete_socket(svsk);
+		svc_delete_socket(svsk, 0);
 		return 0;
 	}
 
@@ -897,7 +915,7 @@
 	return len;
 
  err_delete:
-	svc_delete_socket(svsk);
+	svc_delete_socket(svsk, 0);
 	return -EAGAIN;
 
  error:
@@ -935,7 +953,7 @@
 		printk(KERN_NOTICE "rpc-srv/tcp: %s: sent only %d bytes of %d - shutting down socket\n",
 		       rqstp->rq_sock->sk_server->sv_name,
 		       sent, bufp->len << 2);
-		svc_delete_socket(rqstp->rq_sock);
+		svc_delete_socket(rqstp->rq_sock, (sent > 0));
 		sent = -EAGAIN;
 	}
 	return sent;
@@ -1267,15 +1285,17 @@
  * Remove a dead socket
  */
 void
-svc_delete_socket(struct svc_sock *svsk)
+svc_delete_socket(struct svc_sock *svsk, int doshutdown)
 {
 	struct svc_serv	*serv;
 	struct sock	*sk;
+	struct socket *sock;
 
 	dprintk("svc: svc_delete_socket(%p)\n", svsk);
 
 	serv = svsk->sk_server;
 	sk = svsk->sk_sk;
+	sock = svsk->sk_sock;
 
 	/*
 	 * This only needs to be done once!
@@ -1305,6 +1325,8 @@
 		sock_release(svsk->sk_sock);
 		kfree(svsk);
 	} else {
+		if (doshutdown && sock->ops->shutdown)
+			sock->ops->shutdown(sock, 2 /*SHUT_RDWR */);
 		spin_unlock_bh(&serv->sv_lock);
 		dprintk(KERN_NOTICE "svc: server socket destroy delayed\n");
 		/* svsk->sk_server = NULL; */
--- linux-2.4.20/net/sunrpc/svc.c.diff	2003-05-29 14:19:18.000000000 -0400
+++ linux-2.4.20/net/sunrpc/svc.c	2003-05-29 14:19:38.000000000 -0400
@@ -78,13 +78,13 @@
 		svsk = list_entry(serv->sv_tempsocks.next,
 				  struct svc_sock,
 				  sk_list);
-		svc_delete_socket(svsk);
+		svc_delete_socket(svsk, 0);
 	}
 	while (!list_empty(&serv->sv_permsocks)) {
 		svsk = list_entry(serv->sv_permsocks.next,
 				  struct svc_sock,
 				  sk_list);
-		svc_delete_socket(svsk);
+		svc_delete_socket(svsk, 0);
 	}
 
 	/* Unregister service with the portmapper */
