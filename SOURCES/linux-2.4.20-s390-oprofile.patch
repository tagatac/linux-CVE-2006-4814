diff -urNp linux-441/arch/s390/Makefile linux-442/arch/s390/Makefile
--- linux-441/arch/s390/Makefile
+++ linux-442/arch/s390/Makefile
@@ -39,6 +39,13 @@ ifeq ($(CONFIG_MATHEMU),y)
   CORE_FILES := $(CORE_FILES) arch/s390/math-emu/math-emu.o
 endif
 
+ifdef CONFIG_OPROFILE
+  SUBDIRS += arch/s390/oprofile
+  ifeq ($(CONFIG_OPROFILE),y)
+    DRIVERS += arch/s390/oprofile/oprofile.o
+  endif
+endif
+
 all: image listing
 
 listing: vmlinux
diff -urNp linux-441/arch/s390/config.in linux-442/arch/s390/config.in
--- linux-441/arch/s390/config.in
+++ linux-442/arch/s390/config.in
@@ -65,6 +65,8 @@ fi
 
 source fs/Config.in
 
+source arch/s390/oprofile/Config.in
+
 mainmenu_option next_comment
 comment 'Kernel hacking'
 
diff -urNp linux-441/arch/s390/kernel/entry.S linux-442/arch/s390/kernel/entry.S
--- linux-441/arch/s390/kernel/entry.S
+++ linux-442/arch/s390/kernel/entry.S
@@ -445,7 +445,7 @@ sys_call_table:
         .long  sys_newlstat
         .long  sys_newfstat
         .long  sys_ni_syscall            /* old uname syscall holder */
-        .long  sys_ni_syscall            /* 110 */ /* iopl for i386 */
+        .long  sys_lookup_dcookie	 /* 110 */
         .long  sys_vhangup
         .long  sys_ni_syscall            /* old "idle" system call */
         .long  sys_ni_syscall            /* vm86old for i386 */
diff -urNp linux-441/arch/s390/kernel/irq.c linux-442/arch/s390/kernel/irq.c
--- linux-441/arch/s390/kernel/irq.c
+++ linux-442/arch/s390/kernel/irq.c
@@ -28,6 +28,7 @@
 #include <linux/threads.h>
 #include <linux/smp_lock.h>
 #include <linux/init.h>
+#include <linux/proc_fs.h>
 
 #include <asm/system.h>
 #include <asm/io.h>
@@ -37,6 +38,7 @@
 #include <asm/pgtable.h>
 #include <asm/delay.h>
 #include <asm/lowcore.h>
+#include <asm/uaccess.h>
 
 void          s390_init_IRQ   ( void );
 void          s390_free_irq   ( unsigned int irq, void *dev_id);
@@ -46,6 +48,47 @@ int           s390_request_irq( unsigned
                      const char    *devname,
                      void          *dev_id);
 
+static struct proc_dir_entry * root_irq_dir;
+
+#define HEX_DIGITS 8	/* Same as other 64-bit arches. XXX */
+
+static unsigned int parse_hex_value (const char *buffer,
+unsigned long count, unsigned long *ret)
+{
+	unsigned char hexnum [HEX_DIGITS];
+	unsigned long value;
+	int i;
+
+	if (!count)
+		return -EINVAL;
+	if (count > HEX_DIGITS)
+		count = HEX_DIGITS;
+	if (copy_from_user(hexnum, buffer, count))
+		return -EFAULT;
+
+	/*
+	 * Parse the first 8 characters as a hex string, any non-hex char
+	 * is end-of-string. '00e1', 'e1', '00E1', 'E1' are all the same.
+	 */
+	value = 0;
+
+	for (i = 0; i < count; i++) {
+		unsigned int c = hexnum[i];
+
+		switch (c) {
+			case '0' ... '9': c -= '0'; break;
+			case 'a' ... 'f': c -= 'a'-10; break;
+			case 'A' ... 'F': c -= 'A'-10; break;
+		default:
+			goto out;
+		}
+		value = (value << 4) | c;
+	}
+out:
+	*ret = value;
+	return 0;
+}
+
 #if 0
 /*
  * The following vectors are part of the Linux architecture, there
@@ -321,9 +364,48 @@ int request_irq( unsigned int   irq,
 
 }
 
+static int prof_cpu_mask_read_proc (char *page, char **start, off_t off,
+					int count, int *eof, void *data)
+{
+	unsigned long *mask = (unsigned long *) data;
+	if (count < HEX_DIGITS+1)
+		return -EINVAL;
+	return sprintf (page, "%08lx\n", *mask);
+}
+
+static int prof_cpu_mask_write_proc (struct file *file, const char *buffer,
+					unsigned long count, void *data)
+{
+	unsigned long *mask = (unsigned long *) data, full_count = count, err;
+	unsigned long new_value;
+
+	err = parse_hex_value(buffer, count, &new_value);
+	if (err)
+		return err;
+
+	*mask = new_value;
+	return full_count;
+}
+
+unsigned long prof_cpu_mask = -1;
+
 void init_irq_proc(void)
 {
-        /* For now, nothing... */
+        struct proc_dir_entry *entry;
+
+        /* create /proc/irq */
+        root_irq_dir = proc_mkdir("irq", 0);
+
+        /* create /proc/irq/prof_cpu_mask */
+        entry = create_proc_entry("prof_cpu_mask", 0600, root_irq_dir);
+
+        if (!entry)
+            return;
+
+        entry->nlink = 1;
+        entry->data = (void *)&prof_cpu_mask;
+        entry->read_proc = prof_cpu_mask_read_proc;
+        entry->write_proc = prof_cpu_mask_write_proc;
 }
 
 #ifdef CONFIG_SMP
diff -urNp linux-441/arch/s390/kernel/time.c linux-442/arch/s390/kernel/time.c
--- linux-441/arch/s390/kernel/time.c
+++ linux-442/arch/s390/kernel/time.c
@@ -23,6 +23,7 @@
 #include <linux/init.h>
 #include <linux/smp.h>
 #include <linux/types.h>
+#include <linux/profile.h>
 
 #include <asm/uaccess.h>
 #include <asm/delay.h>
@@ -137,6 +138,54 @@ void do_settimeofday(struct timeval *tv)
 	write_unlock_irq(&xtime_lock);
 }
 
+#ifdef CONFIG_PROFILING
+
+extern char _stext, _etext;
+
+/*
+ * The profiling function is SMP safe. (nothing can mess
+ * around with "current", and the profiling counters are
+ * updated with atomic operations). This is especially
+ * useful with a profiling multiplier != 1
+ */
+static inline void s390_do_profile(struct pt_regs * regs)
+{
+	unsigned long eip;
+	extern unsigned long prof_cpu_mask;
+
+	profile_hook(regs);
+
+	if (user_mode(regs))
+		return;
+
+	if (!prof_buffer)
+		return;
+
+	eip = instruction_pointer(regs);
+
+	/*
+	 * Only measure the CPUs specified by /proc/irq/prof_cpu_mask.
+	 * (default is all CPUs.)
+	 */
+	if (!((1<<smp_processor_id()) & prof_cpu_mask))
+		return;
+
+	eip -= (unsigned long) &_stext;
+	eip >>= prof_shift;
+	/*
+	 * Don't ignore out-of-bounds EIP values silently,
+	 * put them into the last histogram slot, so if
+	 * present, they will show up as a sharp peak.
+	 */
+	if (eip > prof_len-1)
+		eip = prof_len-1;
+	atomic_inc((atomic_t *)&prof_buffer[eip]);
+}
+
+#else
+#define s390_do_profile(regs)  do { ; } while(0)
+#endif /* CONFIG_PROFILING */
+
 /*
  * timer_interrupt() needs to keep up the real-time clock,
  * as well as call the "do_timer()" routine every clocktick
@@ -171,6 +220,7 @@ static void do_comparator_interrupt(stru
 #else
 	do_timer(regs);
 #endif
+	s390_do_profile(regs);
 
 	irq_exit(cpu, 0);
 }
diff -urNp linux-441/arch/s390/oprofile/Config.help linux-442/arch/s390/oprofile/Config.help
--- linux-441/arch/s390/oprofile/Config.help
+++ linux-442/arch/s390/oprofile/Config.help
@@ -0,0 +1,6 @@
+CONFIG_OPROFILE
+  OProfile is a profiling system capable of profiling the
+  whole system, include the kernel, kernel modules, libraries,
+  and applications.
+
+  If unsure, say N.
diff -urNp linux-441/arch/s390/oprofile/Config.in linux-442/arch/s390/oprofile/Config.in
--- linux-441/arch/s390/oprofile/Config.in
+++ linux-442/arch/s390/oprofile/Config.in
@@ -0,0 +1,7 @@
+if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Profiling support'
+   bool 'Profiling support (EXPERIMENTAL)' CONFIG_PROFILING
+   dep_tristate '  OProfile system profiling (EXPERIMENTAL)' CONFIG_OPROFILE $CONFIG_PROFILING
+   endmenu
+fi
diff -urNp linux-441/arch/s390/oprofile/Makefile linux-442/arch/s390/oprofile/Makefile
--- linux-441/arch/s390/oprofile/Makefile
+++ linux-442/arch/s390/oprofile/Makefile
@@ -0,0 +1,11 @@
+# arch/s390/oprofile/Makefile
+
+O_TARGET:=oprofile.o
+obj-m := $(O_TARGET)
+obj-y := init.o timer_int.o \
+         $(addprefix ../../../drivers/oprofile/, \
+           oprof.o cpu_buffer.o buffer_sync.o \
+           event_buffer.o oprofile_files.o \
+           oprofilefs.o oprofile_stats.o )
+
+include $(TOPDIR)/Rules.make
diff -urNp linux-441/arch/s390/oprofile/init.c linux-442/arch/s390/oprofile/init.c
--- linux-441/arch/s390/oprofile/init.c
+++ linux-442/arch/s390/oprofile/init.c
@@ -0,0 +1,26 @@
+/**
+ * @file init.c
+ *
+ * @remark Copyright 2002-2003 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon <levon@movementarian.org>
+ * @author Will Cohen <wcohen@redhat.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/oprofile.h>
+#include <linux/init.h>
+ 
+/* We support CPUs that have performance counters like the IA64
+ * with irq mode samples.
+ */
+ 
+extern int irq_init(struct oprofile_operations ** ops);
+extern void timer_init(struct oprofile_operations ** ops);
+
+int __init oprofile_arch_init(struct oprofile_operations ** ops)
+{
+	timer_init(ops);
+	return 0;
+}
diff -urNp linux-441/arch/s390/oprofile/timer_int.c linux-442/arch/s390/oprofile/timer_int.c
--- linux-441/arch/s390/oprofile/timer_int.c
+++ linux-442/arch/s390/oprofile/timer_int.c
@@ -0,0 +1,59 @@
+/**
+ * @file timer_int.c
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon <levon@movementarian.org>
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/notifier.h>
+#include <linux/smp.h>
+#include <linux/irq.h>
+#include <linux/profile.h>
+#include <linux/oprofile.h>
+#include <asm/ptrace.h>
+ 
+static int timer_notify(struct notifier_block * self, unsigned long val, void * data)
+{
+	struct pt_regs * regs = (struct pt_regs *)data;
+	int cpu = smp_processor_id();
+ 	unsigned long eip = instruction_pointer(regs);
+ 
+	oprofile_add_sample(eip, !user_mode(regs), 0, cpu);
+	return 0;
+}
+ 
+ 
+static struct notifier_block timer_notifier = {
+	.notifier_call	= timer_notify,
+};
+ 
+
+static int timer_start(void)
+{
+	return register_profile_notifier(&timer_notifier);
+}
+
+
+static void timer_stop(void)
+{
+	unregister_profile_notifier(&timer_notifier);
+}
+
+
+static struct oprofile_operations timer_ops = {
+	.start	= timer_start,
+	.stop	= timer_stop,
+	.cpu_type = "timer"
+};
+
+ 
+void __init timer_init(struct oprofile_operations ** ops)
+{
+	*ops = &timer_ops;
+	printk(KERN_INFO "oprofile: using timer interrupt.\n");
+}
diff -urNp linux-441/arch/s390x/Makefile linux-442/arch/s390x/Makefile
--- linux-441/arch/s390x/Makefile
+++ linux-442/arch/s390x/Makefile
@@ -36,6 +36,13 @@ CORE_FILES := arch/s390x/mm/mm.o arch/s3
 DRIVERS := $(DRIVERS) drivers/s390/io.o
 LIBS := $(TOPDIR)/arch/s390x/lib/lib.a $(LIBS) $(TOPDIR)/arch/s390x/lib/lib.a
 
+ifdef CONFIG_OPROFILE
+  SUBDIRS += arch/s390x/oprofile
+  ifeq ($(CONFIG_OPROFILE),y)
+    DRIVERS += arch/s390x/oprofile/oprofile.o
+  endif
+endif
+
 all: image listing
 
 listing: vmlinux
diff -urNp linux-441/arch/s390x/config.in linux-442/arch/s390x/config.in
--- linux-441/arch/s390x/config.in
+++ linux-442/arch/s390x/config.in
@@ -70,6 +70,8 @@ fi
 
 source fs/Config.in
 
+source arch/s390x/oprofile/Config.in
+
 mainmenu_option next_comment
 comment 'Kernel hacking'
 
diff -urNp linux-441/arch/s390x/kernel/entry.S linux-442/arch/s390x/kernel/entry.S
--- linux-441/arch/s390x/kernel/entry.S
+++ linux-442/arch/s390x/kernel/entry.S
@@ -483,7 +483,7 @@ sys_call_table:
         .long  SYSCALL(sys_newlstat,sys32_newlstat_wrapper)
         .long  SYSCALL(sys_newfstat,sys32_newfstat_wrapper)
         .long  SYSCALL(sys_ni_syscall,sys_ni_syscall) /* old uname syscall */
-        .long  SYSCALL(sys_ni_syscall,sys_ni_syscall) /* iopl for i386 */
+        .long  SYSCALL(sys_lookup_dcookie,sys32_lookup_dcookie_wrapper)	/* 110 */
         .long  SYSCALL(sys_vhangup,sys_vhangup)
         .long  SYSCALL(sys_ni_syscall,sys_ni_syscall) /* old "idle" system call */
         .long  SYSCALL(sys_ni_syscall,sys_ni_syscall) /* vm86old for i386 */
diff -urNp linux-441/arch/s390x/kernel/irq.c linux-442/arch/s390x/kernel/irq.c
--- linux-441/arch/s390x/kernel/irq.c
+++ linux-442/arch/s390x/kernel/irq.c
@@ -28,6 +28,7 @@
 #include <linux/threads.h>
 #include <linux/smp_lock.h>
 #include <linux/init.h>
+#include <linux/proc_fs.h>
 
 #include <asm/system.h>
 #include <asm/io.h>
@@ -37,6 +38,7 @@
 #include <asm/pgtable.h>
 #include <asm/delay.h>
 #include <asm/lowcore.h>
+#include <asm/uaccess.h>
 
 void          s390_init_IRQ   ( void );
 void          s390_free_irq   ( unsigned int irq, void *dev_id);
@@ -46,6 +48,47 @@ int           s390_request_irq( unsigned
                      const char    *devname,
                      void          *dev_id);
 
+static struct proc_dir_entry * root_irq_dir;
+
+#define HEX_DIGITS 8	/* Same as other 64-bit arches. XXX */
+
+static unsigned int parse_hex_value (const char *buffer,
+unsigned long count, unsigned long *ret)
+{
+	unsigned char hexnum [HEX_DIGITS];
+	unsigned long value;
+	int i;
+
+	if (!count)
+		return -EINVAL;
+	if (count > HEX_DIGITS)
+		count = HEX_DIGITS;
+	if (copy_from_user(hexnum, buffer, count))
+		return -EFAULT;
+
+	/*
+	 * Parse the first 8 characters as a hex string, any non-hex char
+	 * is end-of-string. '00e1', 'e1', '00E1', 'E1' are all the same.
+	 */
+	value = 0;
+
+	for (i = 0; i < count; i++) {
+		unsigned int c = hexnum[i];
+
+		switch (c) {
+			case '0' ... '9': c -= '0'; break;
+			case 'a' ... 'f': c -= 'a'-10; break;
+			case 'A' ... 'F': c -= 'A'-10; break;
+		default:
+			goto out;
+		}
+		value = (value << 4) | c;
+	}
+out:
+	*ret = value;
+	return 0;
+}
+
 #if 0
 /*
  * The following vectors are part of the Linux architecture, there
@@ -321,9 +364,48 @@ int request_irq( unsigned int   irq,
 
 }
 
+static int prof_cpu_mask_read_proc (char *page, char **start, off_t off,
+					int count, int *eof, void *data)
+{
+	unsigned long *mask = (unsigned long *) data;
+	if (count < HEX_DIGITS+1)
+		return -EINVAL;
+	return sprintf (page, "%08lx\n", *mask);
+}
+
+static int prof_cpu_mask_write_proc (struct file *file, const char *buffer,
+					unsigned long count, void *data)
+{
+	unsigned long *mask = (unsigned long *) data, full_count = count, err;
+	unsigned long new_value;
+
+	err = parse_hex_value(buffer, count, &new_value);
+	if (err)
+		return err;
+
+	*mask = new_value;
+	return full_count;
+}
+
+unsigned long prof_cpu_mask = -1;
+
 void init_irq_proc(void)
 {
-        /* For now, nothing... */
+        struct proc_dir_entry *entry;
+
+        /* create /proc/irq */
+        root_irq_dir = proc_mkdir("irq", 0);
+
+        /* create /proc/irq/prof_cpu_mask */
+        entry = create_proc_entry("prof_cpu_mask", 0600, root_irq_dir);
+
+        if (!entry)
+            return;
+
+        entry->nlink = 1;
+        entry->data = (void *)&prof_cpu_mask;
+        entry->read_proc = prof_cpu_mask_read_proc;
+        entry->write_proc = prof_cpu_mask_write_proc;
 }
 
 #ifdef CONFIG_SMP
diff -urNp linux-441/arch/s390x/kernel/time.c linux-442/arch/s390x/kernel/time.c
--- linux-441/arch/s390x/kernel/time.c
+++ linux-442/arch/s390x/kernel/time.c
@@ -23,6 +23,7 @@
 #include <linux/init.h>
 #include <linux/smp.h>
 #include <linux/types.h>
+#include <linux/profile.h>
 
 #include <asm/uaccess.h>
 #include <asm/delay.h>
@@ -110,6 +111,54 @@ void do_settimeofday(struct timeval *tv)
 	write_unlock_irq(&xtime_lock);
 }
 
+#ifdef CONFIG_PROFILING
+
+extern char _stext, _etext;
+
+/*
+ * The profiling function is SMP safe. (nothing can mess
+ * around with "current", and the profiling counters are
+ * updated with atomic operations). This is especially
+ * useful with a profiling multiplier != 1
+ */
+static inline void s390_do_profile(struct pt_regs * regs)
+{
+	unsigned long eip;
+	extern unsigned long prof_cpu_mask;
+
+	profile_hook(regs);
+
+	if (user_mode(regs))
+		return;
+
+	if (!prof_buffer)
+		return;
+
+	eip = instruction_pointer(regs);
+
+	/*
+	 * Only measure the CPUs specified by /proc/irq/prof_cpu_mask.
+	 * (default is all CPUs.)
+	 */
+	if (!((1<<smp_processor_id()) & prof_cpu_mask))
+		return;
+
+	eip -= (unsigned long) &_stext;
+	eip >>= prof_shift;
+	/*
+	 * Don't ignore out-of-bounds EIP values silently,
+	 * put them into the last histogram slot, so if
+	 * present, they will show up as a sharp peak.
+	 */
+	if (eip > prof_len-1)
+		eip = prof_len-1;
+	atomic_inc((atomic_t *)&prof_buffer[eip]);
+}
+
+#else
+#define s390_do_profile(regs)  do { ; } while(0)
+#endif /* CONFIG_PROFILING */
+
 /*
  * timer_interrupt() needs to keep up the real-time clock,
  * as well as call the "do_timer()" routine every clocktick
@@ -144,6 +193,7 @@ static void do_comparator_interrupt(stru
 #else
 	do_timer(regs);
 #endif
+	s390_do_profile(regs);
 
 	irq_exit(cpu, 0);
 }
diff -urNp linux-441/arch/s390x/kernel/wrapper32.S linux-442/arch/s390x/kernel/wrapper32.S
--- linux-441/arch/s390x/kernel/wrapper32.S
+++ linux-442/arch/s390x/kernel/wrapper32.S
@@ -496,6 +496,14 @@ sys32_newfstat_wrapper:
 	llgtr	%r3,%r3			# struct stat_emu31 *
 	jg	sys32_newfstat		# branch to system call
 
+	.globl	sys32_lookup_dcookie_wrapper
+sys32_lookup_dcookie_wrapper:
+	sllg	%r2,%r2,32
+	lr	%r2,%r3			# pack u64
+	llgtr	%r3,%r4			# char *
+	llgfr	%r4,%r5			# size_t
+	jg	sys_lookup_dcookie	# branch to system call
+
 #sys32_vhangup_wrapper			# void 
 
 	.globl  sys32_wait4_wrapper 
diff -urNp linux-441/arch/s390x/oprofile/Config.help linux-442/arch/s390x/oprofile/Config.help
--- linux-441/arch/s390x/oprofile/Config.help
+++ linux-442/arch/s390x/oprofile/Config.help
@@ -0,0 +1,6 @@
+CONFIG_OPROFILE
+  OProfile is a profiling system capable of profiling the
+  whole system, include the kernel, kernel modules, libraries,
+  and applications.
+
+  If unsure, say N.
diff -urNp linux-441/arch/s390x/oprofile/Config.in linux-442/arch/s390x/oprofile/Config.in
--- linux-441/arch/s390x/oprofile/Config.in
+++ linux-442/arch/s390x/oprofile/Config.in
@@ -0,0 +1,7 @@
+if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Profiling support'
+   bool 'Profiling support (EXPERIMENTAL)' CONFIG_PROFILING
+   dep_tristate '  OProfile system profiling (EXPERIMENTAL)' CONFIG_OPROFILE $CONFIG_PROFILING
+   endmenu
+fi
diff -urNp linux-441/arch/s390x/oprofile/Makefile linux-442/arch/s390x/oprofile/Makefile
--- linux-441/arch/s390x/oprofile/Makefile
+++ linux-442/arch/s390x/oprofile/Makefile
@@ -0,0 +1,11 @@
+# arch/s390x/oprofile/Makefile
+
+O_TARGET:=oprofile.o
+obj-m := $(O_TARGET)
+obj-y := init.o timer_int.o \
+         $(addprefix ../../../drivers/oprofile/, \
+           oprof.o cpu_buffer.o buffer_sync.o \
+           event_buffer.o oprofile_files.o \
+           oprofilefs.o oprofile_stats.o )
+
+include $(TOPDIR)/Rules.make
diff -urNp linux-441/arch/s390x/oprofile/init.c linux-442/arch/s390x/oprofile/init.c
--- linux-441/arch/s390x/oprofile/init.c
+++ linux-442/arch/s390x/oprofile/init.c
@@ -0,0 +1,26 @@
+/**
+ * @file init.c
+ *
+ * @remark Copyright 2002-2003 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon <levon@movementarian.org>
+ * @author Will Cohen <wcohen@redhat.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/oprofile.h>
+#include <linux/init.h>
+ 
+/* We support CPUs that have performance counters like the IA64
+ * with irq mode samples.
+ */
+ 
+extern int irq_init(struct oprofile_operations ** ops);
+extern void timer_init(struct oprofile_operations ** ops);
+
+int __init oprofile_arch_init(struct oprofile_operations ** ops)
+{
+	timer_init(ops);
+	return 0;
+}
diff -urNp linux-441/arch/s390x/oprofile/timer_int.c linux-442/arch/s390x/oprofile/timer_int.c
--- linux-441/arch/s390x/oprofile/timer_int.c
+++ linux-442/arch/s390x/oprofile/timer_int.c
@@ -0,0 +1,59 @@
+/**
+ * @file timer_int.c
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon <levon@movementarian.org>
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/notifier.h>
+#include <linux/smp.h>
+#include <linux/irq.h>
+#include <linux/profile.h>
+#include <linux/oprofile.h>
+#include <asm/ptrace.h>
+ 
+static int timer_notify(struct notifier_block * self, unsigned long val, void * data)
+{
+	struct pt_regs * regs = (struct pt_regs *)data;
+	int cpu = smp_processor_id();
+ 	unsigned long eip = instruction_pointer(regs);
+ 
+	oprofile_add_sample(eip, !user_mode(regs), 0, cpu);
+	return 0;
+}
+ 
+ 
+static struct notifier_block timer_notifier = {
+	.notifier_call	= timer_notify,
+};
+ 
+
+static int timer_start(void)
+{
+	return register_profile_notifier(&timer_notifier);
+}
+
+
+static void timer_stop(void)
+{
+	unregister_profile_notifier(&timer_notifier);
+}
+
+
+static struct oprofile_operations timer_ops = {
+	.start	= timer_start,
+	.stop	= timer_stop,
+	.cpu_type = "timer"
+};
+
+ 
+void __init timer_init(struct oprofile_operations ** ops)
+{
+	*ops = &timer_ops;
+	printk(KERN_INFO "oprofile: using timer interrupt.\n");
+}
diff -urNp linux-441/include/asm-s390/ptrace.h linux-442/include/asm-s390/ptrace.h
--- linux-441/include/asm-s390/ptrace.h
+++ linux-442/include/asm-s390/ptrace.h
@@ -324,7 +324,7 @@ struct user_regs_struct
 
 #ifdef __KERNEL__
 #define user_mode(regs) (((regs)->psw.mask & PSW_PROBLEM_STATE) != 0)
-#define instruction_pointer(regs) ((regs)->psw.addr)
+#define instruction_pointer(regs) (ADDR_BITS_REMOVE((regs)->psw.addr))
 extern void show_regs(struct pt_regs * regs);
 extern char *task_show_regs(struct task_struct *task, char *buffer);
 #endif
diff -urNp linux-441/include/asm-s390/smp.h linux-442/include/asm-s390/smp.h
--- linux-441/include/asm-s390/smp.h
+++ linux-442/include/asm-s390/smp.h
@@ -28,6 +28,15 @@ typedef struct
 
 extern unsigned long cpu_online_map;
 
+/*
+ * Newer 2.5 Linux kernels have cpu_possible.
+ * This provides equivalent function for the older 2.4 kernels.
+ */
+static inline int cpu_possible(int cpu)
+{
+	return (cpu_online_map & (1<<(cpu)));
+}
+
 #define NO_PROC_ID		0xFF		/* No processor magic marker */
 
 /*
diff -urNp linux-441/include/asm-s390/unistd.h linux-442/include/asm-s390/unistd.h
--- linux-441/include/asm-s390/unistd.h
+++ linux-442/include/asm-s390/unistd.h
@@ -104,6 +104,7 @@
 #define __NR_stat               106
 #define __NR_lstat              107
 #define __NR_fstat              108
+#define __NR_lookup_dcookie	110
 #define __NR_vhangup            111
 #define __NR_idle               112
 #define __NR_wait4              114
diff -urNp linux-441/include/asm-s390x/smp.h linux-442/include/asm-s390x/smp.h
--- linux-441/include/asm-s390x/smp.h
+++ linux-442/include/asm-s390x/smp.h
@@ -28,6 +28,15 @@ typedef struct
 
 extern unsigned long cpu_online_map;
 
+/*
+ * Newer 2.5 Linux kernels have cpu_possible.
+ * This provides equivalent function for the older 2.4 kernels.
+ */
+static inline int cpu_possible(int cpu)
+{
+	return (cpu_online_map & (1<<(cpu)));
+}
+
 #define NO_PROC_ID		0xFF		/* No processor magic marker */
 
 /*
diff -urNp linux-441/include/asm-s390x/unistd.h linux-442/include/asm-s390x/unistd.h
--- linux-441/include/asm-s390x/unistd.h
+++ linux-442/include/asm-s390x/unistd.h
@@ -88,6 +88,7 @@
 #define __NR_stat               106
 #define __NR_lstat              107
 #define __NR_fstat              108
+#define __NR_lookup_dcookie	110
 #define __NR_vhangup            111
 #define __NR_idle               112
 #define __NR_wait4              114
