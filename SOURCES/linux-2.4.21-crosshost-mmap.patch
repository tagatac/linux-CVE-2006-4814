diff -urNp linux-1170/arch/alpha/kernel/alpha_ksyms.c linux-1190/arch/alpha/kernel/alpha_ksyms.c
--- linux-1170/arch/alpha/kernel/alpha_ksyms.c
+++ linux-1190/arch/alpha/kernel/alpha_ksyms.c
@@ -204,6 +204,8 @@ EXPORT_SYMBOL(down_interruptible);
 EXPORT_SYMBOL(down_trylock);
 EXPORT_SYMBOL(up);
 
+EXPORT_SYMBOL_GPL(__load_new_mm_context);
+
 /* 
  * SMP-specific symbols.
  */
diff -urNp linux-1170/arch/i386/kernel/i386_ksyms.c linux-1190/arch/i386/kernel/i386_ksyms.c
--- linux-1170/arch/i386/kernel/i386_ksyms.c
+++ linux-1190/arch/i386/kernel/i386_ksyms.c
@@ -153,6 +153,7 @@ EXPORT_SYMBOL(smp_call_function);
 
 /* TLB flushing */
 EXPORT_SYMBOL(flush_tlb_page);
+EXPORT_SYMBOL_GPL(flush_tlb_mm);
 #endif
 
 #if defined(CONFIG_X86_LOCAL_APIC) && defined(CONFIG_PM)
diff -urNp linux-1170/include/linux/mm.h linux-1190/include/linux/mm.h
--- linux-1170/include/linux/mm.h
+++ linux-1190/include/linux/mm.h
@@ -159,6 +159,9 @@ struct vm_operations_struct {
 	void (*close)(struct vm_area_struct * area);
 	struct page * (*nopage)(struct vm_area_struct * area, unsigned long address, int unused);
 	int (*populate)(struct vm_area_struct * area, unsigned long address, unsigned long len, pgprot_t prot, unsigned long pgoff, int nonblock);
+	int (*do_no_page)(struct mm_struct * mm, struct vm_area_struct * vma,
+			  unsigned long address, int write_access, 
+			  pte_t *page_table, pmd_t *pmd);
 };
 
 /* forward declaration; pte_chain is meant to be internal to rmap.c */
@@ -666,6 +669,10 @@ extern int access_process_vm(struct task
 
 extern struct page * follow_page(struct mm_struct *mm, unsigned long address, int write);
 extern struct page * follow_pin_page(struct mm_struct *mm, unsigned long address, int write);
+extern int do_no_page(struct mm_struct * mm, struct vm_area_struct * vma,
+		      unsigned long address, int write_access, 
+		      pte_t *page_table, pmd_t *pmd);
+
 int get_user_pages(struct task_struct *tsk, struct mm_struct *mm, unsigned long start,
 		int len, int write, int force, struct page **pages, struct vm_area_struct **vmas);
 
diff -urNp linux-1170/kernel/ksyms.c linux-1190/kernel/ksyms.c
--- linux-1170/kernel/ksyms.c
+++ linux-1190/kernel/ksyms.c
@@ -134,6 +134,7 @@ EXPORT_SYMBOL(vmap);
 EXPORT_SYMBOL(vmalloc_to_page);
 EXPORT_SYMBOL(mem_map);
 EXPORT_SYMBOL(remap_page_range);
+EXPORT_SYMBOL(zap_page_range);
 EXPORT_SYMBOL(max_mapnr);
 EXPORT_SYMBOL(high_memory);
 EXPORT_SYMBOL(vmtruncate);
@@ -407,6 +408,7 @@ EXPORT_SYMBOL(free_irq);
 #if !defined(CONFIG_IA64)	/* irq_stat is part of struct cpuinfo_ia64 */
 EXPORT_SYMBOL(irq_stat);
 #endif
+EXPORT_SYMBOL(do_no_page);
 
 /* waitqueue handling */
 EXPORT_SYMBOL(add_wait_queue);
diff -urNp linux-1170/mm/memory.c linux-1190/mm/memory.c
--- linux-1170/mm/memory.c
+++ linux-1190/mm/memory.c
@@ -1669,7 +1669,7 @@ out:
  * This is called with the MM semaphore held and the page table
  * spinlock held. Exit with the spinlock released.
  */
-static int do_no_page(struct mm_struct * mm, struct vm_area_struct * vma,
+int do_no_page(struct mm_struct * mm, struct vm_area_struct * vma,
 	unsigned long address, int write_access, pte_t *page_table, pmd_t *pmd)
 {
 	struct pte_chain * pte_chain;
@@ -1784,7 +1784,12 @@ static inline int handle_pte_fault(struc
 		 * drop the lock.
 		 */
 		if (pte_none(entry))
+		{
+			if (vma->vm_ops && vma->vm_ops->do_no_page)
+				return vma->vm_ops->do_no_page(mm, vma, 
+					address, write_access, pte, pmd);
 			return do_no_page(mm, vma, address, write_access, pte, pmd);
+		}
 		return do_swap_page(mm, vma, address, pte, pmd, entry, write_access);
 	}
 
