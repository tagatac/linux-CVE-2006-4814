diff -urNp linux-5680/drivers/block/cciss.c linux-5681/drivers/block/cciss.c
--- linux-5680/drivers/block/cciss.c
+++ linux-5681/drivers/block/cciss.c
@@ -44,6 +44,9 @@
 #include <linux/blk.h>
 #include <linux/blkdev.h>
 #include <linux/genhd.h>
+#if (CONFIG_BLOCKDUMP || CONFIG_BLOCKDUMP_MODULE)
+#include "block_dump.h" 
+#endif
 
 
 #define CCISS_DRIVER_VERSION(maj,min,submin) ((maj<<16)|(min<<8)|(submin))
@@ -186,16 +189,39 @@ static int cciss_proc_get_info(char *buf
 static void cciss_procinit(int i) {}
 #endif /* CONFIG_PROC_FS */
 
-static struct block_device_operations cciss_fops  = {
-	owner:			THIS_MODULE,
-	open:			cciss_open, 
-	release:        	cciss_release,
-        ioctl:			cciss_ioctl,
-	revalidate:		frevalidate_logvol,
-};
+#include "cciss_diskdump.c"
 
 #include "cciss_scsi.c"		/* For SCSI tape support */
 
+
+#if (CONFIG_BLOCKDUMP || CONFIG_BLOCKDUMP_MODULE)
+block_device_operations_dump cciss_blk_fops_dump = {
+	.blk_fops 	  = {
+		.owner      = THIS_MODULE,
+		.open       = cciss_open,
+		.release    = cciss_release,
+		.ioctl      = cciss_ioctl,
+		.revalidate = frevalidate_logvol,
+	},	
+	.block_dump_ops   = &cciss_dump_device_ops,
+	.block_probe 	  = cciss_probe,
+	.block_add_device = cciss_add_device,
+	.poll		  = diskdump_pollcomplete,	
+
+};
+
+#define cciss_fops cciss_blk_fops_dump.blk_fops
+#else
+struct block_device_operations cciss_fops = {	
+	.owner      = THIS_MODULE,
+	.open       = cciss_open,
+	.release    = cciss_release,
+	.ioctl      = cciss_ioctl,
+	.revalidate = frevalidate_logvol,
+};
+
+#endif
+
 #define ENG_GIG	1048576000
 #define ENG_GIG_FACTOR (ENG_GIG/512)
 #define	RAID_UNKNOWN 6
@@ -305,6 +331,7 @@ cciss_proc_write(struct file *file, cons
 		/* might be nice to have "disengage" too, but it's not
 		   safely possible. (only 1 module use count, lock issues.) */
 #	endif
+
 	if (START_MONITOR_THREAD(h, cmd, count, cciss_monitor, &rc) == 0)
 		return rc;
 	return -EINVAL;
@@ -1947,20 +1974,53 @@ static int sendcmd(
 				      2: periph device address is scsi3addr */
 	unsigned int log_unit,
 	__u8	page_code,
-	unsigned char *scsi3addr)
+	unsigned char *scsi3addr,
+	int block_nr,
+	int diskdump)		/* 0: this is not a diskdump command
+				   1: this is a diskdump command */
+				   
 {
 	CommandList_struct *c;
+	ErrorInfo_struct *err_ptr;
+	dma_addr_t tmp_cmd_dma_handle;
+	u64bit tmp_err_dma_handle;
 	int i;
 	unsigned long complete;
 	ctlr_info_t *info_p= hba[ctlr];
 	u64bit buff_dma_handle;
 	int status = IO_OK;
+	u64bit temp64;
+	int temp;
+	int nr_blocks;
+
+	/* For diskdump we will do a read and write in this routine.  
+	   Because the kernel is not in a stable state we will use the
+	   pre-allocated command reserved for diskdump */
+	if ( diskdump == 1 ) {
+		c = cciss_dump_cmnd;
+		err_ptr = c->err_info;
+		tmp_cmd_dma_handle = (__u32) c->busaddr;
+		tmp_err_dma_handle.val32.lower = c->ErrDesc.Addr.lower;
+		tmp_err_dma_handle.val32.upper = c->ErrDesc.Addr.upper;
+		
+		memset(c, 0, sizeof(CommandList_struct));
+		c->err_info = err_ptr;
+		memset(c->err_info, 0, sizeof(ErrorInfo_struct));
 
+		c->busaddr = (__u32) tmp_cmd_dma_handle;
+		c->ErrDesc.Addr.lower = tmp_err_dma_handle.val32.lower;
+		c->ErrDesc.Addr.upper = tmp_err_dma_handle.val32.upper;
+		c->ErrDesc.Len = sizeof(ErrorInfo_struct);
+		c->ctlr = ctlr;
+	}
+	else
 	c = cmd_alloc(info_p, 1);
+
 	if (c == NULL) {
 		printk(KERN_WARNING "cciss: unable to get memory");
 		return IO_ERROR;
 	}
+
 	/* Fill in Command Header */
 	c->Header.ReplyQueue = 0;  /* unused in simple mode */
 	if (buff != NULL) { 	/* buffer to fill */
@@ -2046,6 +2106,54 @@ static int sendcmd(
 			c->Request.CDB[0] = BMIC_WRITE;  /* BMIC Passthru */
 			c->Request.CDB[6] = BMIC_CACHE_FLUSH;
 		break;
+		case CCISS_READ:
+			if (use_unit_num == 1) {
+				c->Header.LUN.LogDev.VolId =
+					hba[ctlr]->drv[log_unit].LunID;
+				c->Header.LUN.LogDev.Mode = 1;
+			}
+			c->ctlr = ctlr;
+			c->cmd_type = CMD_RWREQ;
+			c->Request.CDBLen = 10;
+			c->Request.Type.Type = TYPE_CMD;
+			c->Request.Type.Attribute = ATTR_SIMPLE;
+			c->Request.Type.Direction = XFER_READ;
+			c->Request.Timeout = 0;
+			c->Request.CDB[0] = CCISS_READ;
+			c->Request.CDB[2] = (block_nr >> 24) & 0xff;
+			c->Request.CDB[3] = (block_nr >> 16) & 0xff;
+			c->Request.CDB[4] = (block_nr >> 8) & 0xff;
+			c->Request.CDB[5] = block_nr & 0xff;
+			c->Request.CDB[6] = 0;
+			nr_blocks = size/hba[ctlr]->drv[log_unit].block_size;
+			c->Request.CDB[7] = (nr_blocks >> 8) & 0xff;
+			c->Request.CDB[8] = nr_blocks & 0xff;
+			c->Request.CDB[9] = 0;
+		break;
+		case CCISS_WRITE:
+			if (use_unit_num == 1) {
+				c->Header.LUN.LogDev.VolId =
+					hba[ctlr]->drv[log_unit].LunID;
+				c->Header.LUN.LogDev.Mode = 1;
+			}
+			c->ctlr = ctlr;
+			c->cmd_type = CMD_RWREQ;
+			c->Request.CDBLen = 10;
+			c->Request.Type.Type = TYPE_CMD;
+			c->Request.Type.Attribute = ATTR_SIMPLE;
+			c->Request.Type.Direction = XFER_WRITE;
+			c->Request.Timeout = 0;
+			c->Request.CDB[0] = CCISS_WRITE;
+			c->Request.CDB[2] = (block_nr >> 24) & 0xff;
+			c->Request.CDB[3] = (block_nr >> 16) & 0xff;
+			c->Request.CDB[4] = (block_nr >> 8) & 0xff;
+			c->Request.CDB[5] = block_nr & 0xff;
+			c->Request.CDB[6] = 0;
+			nr_blocks = size/hba[ctlr]->drv[log_unit].block_size;
+			c->Request.CDB[7] = (nr_blocks >> 8) & 0xff;
+			c->Request.CDB[8] = nr_blocks & 0xff;
+			c->Request.CDB[9] = 0;
+		break;
 		default:
 			printk(KERN_WARNING
 				"cciss:  Unknown Command 0x%x sent attempted\n",
@@ -2087,6 +2195,11 @@ resend_cmd1:
          * Send the cmd
          */
         info_p->access.submit_command(info_p, c);
+
+	if ( diskdump == 1 ){
+	        complete = diskdump_pollcomplete(ctlr);
+	}
+	else
         complete = pollcomplete(ctlr);
 
 #ifdef CCISS_DEBUG
@@ -2162,7 +2275,10 @@ cleanup1:	
 	/* unlock the data buffer from DMA */
 	pci_unmap_single(info_p->pdev, (dma_addr_t) buff_dma_handle.val,
                                 size, PCI_DMA_BIDIRECTIONAL);
+
+	if ( diskdump != 1 )
 	cmd_free(info_p, c, 1);
+
         return status;
 } 
 /*
@@ -2942,7 +3058,7 @@ static void cciss_getgeometry(int cntl_n
         }
 	/* Get the firmware version */ 
 	return_code = sendcmd(CISS_INQUIRY, cntl_num, inq_buff, 
-		sizeof(InquiryData_struct), 0, 0 ,0, NULL);
+		sizeof(InquiryData_struct), 0, 0 ,0, NULL, 0, 0);
 	if (return_code == IO_OK) {
 		hba[cntl_num]->firm_ver[0] = inq_buff->data_byte[32];
 		hba[cntl_num]->firm_ver[1] = inq_buff->data_byte[33];
@@ -2954,7 +3070,7 @@ static void cciss_getgeometry(int cntl_n
 	}
 	/* Get the number of logical volumes */ 
 	return_code = sendcmd(CISS_REPORT_LOG, cntl_num, ld_buff, 
-			sizeof(ReportLunData_struct), 0, 0, 0, NULL);
+			sizeof(ReportLunData_struct), 0, 0, 0, NULL, 0, 0);
 
 	if (return_code == IO_OK) {
 #ifdef CCISS_DEBUG
@@ -2995,7 +3111,7 @@ static void cciss_getgeometry(int cntl_n
 
 	  	memset(size_buff, 0, sizeof(ReadCapdata_struct));
 	  	return_code = sendcmd(CCISS_READ_CAPACITY, cntl_num, size_buff, 
-				sizeof( ReadCapdata_struct), 1, i, 0, NULL);
+				sizeof( ReadCapdata_struct), 1, i, 0, NULL, 0, 0);
 	  	if (return_code == IO_OK) {
 			total_size = (0xff & 
 				(unsigned int)(size_buff->total_size[0])) << 24;
@@ -3026,7 +3142,7 @@ static void cciss_getgeometry(int cntl_n
 		/* Execute the command to read the disk geometry */
 		memset(inq_buff, 0, sizeof(InquiryData_struct));
 		return_code = sendcmd(CISS_INQUIRY, cntl_num, inq_buff,
-			sizeof(InquiryData_struct), 1, i, 0xC1, NULL );
+			sizeof(InquiryData_struct), 1, i, 0xC1, NULL, 0, 0);
 	  	if (return_code == IO_OK) {
 			if (inq_buff->data_byte[8] == 0xFF) {
 			   printk(KERN_WARNING "cciss: reading geometry failed, volume does not support reading geometry\n");
@@ -3462,7 +3578,7 @@ static void __devexit cciss_remove_one (
 		/* write all data in the battery backed cache to disks */
  	memset(flush_buf, 0, 4);
 		return_code = sendcmd(CCISS_CACHE_FLUSH, i, flush_buf,
-					4, 0, 0, 0, NULL);
+					4, 0, 0, 0, NULL, 0, 0);
 		if (return_code != IO_OK)
  		printk(KERN_WARNING 
 				"cciss%d: Error flushing cache\n", i);
@@ -3516,6 +3632,7 @@ int __init cciss_init(void)
 EXPORT_NO_SYMBOLS;
 static int __init init_cciss_module(void)
 {
+
 	register_cciss_ioctl32();
 	return cciss_init();
 }
diff -urNp linux-5680/drivers/block/cciss_diskdump.c linux-5681/drivers/block/cciss_diskdump.c
--- linux-5680/drivers/block/cciss_diskdump.c
+++ linux-5681/drivers/block/cciss_diskdump.c
@@ -0,0 +1,241 @@
+
+#include "cciss_cmd.h"
+
+/* global vars */
+static int quiesce_ok = 0;
+static CommandList_struct *cciss_dump_cmnd;
+static ReadCapdata_struct *size_buff;
+#define BLOCK_SECTOR(s) ((s) << (PAGE_SHIFT - 9))
+
+/* function prototypes */
+void *cciss_probe(kdev_t dev);
+static CommandList_struct * cmd_alloc(ctlr_info_t *h, int get_from_pool);
+static int cciss_dump_sanity_check(void *device);
+static int cciss_sanity_check(int ctlr, int lun);
+static int find_ctlr_lun_ids(int *ctlr, int *lun, __u32 LunID);
+static int cciss_dump_rw_block(void *device, int rw, unsigned long dump_block_nr, void *buf, int len, unsigned long start_sect, unsigned long nr_sects);
+static int cciss_dump_quiesce(void *device);
+static int cciss_dump_shutdown(void *device);
+static unsigned long diskdump_pollcomplete(int ctlr);
+static unsigned int cciss_add_device(void *device);
+static int sendcmd(__u8	cmd,int	ctlr,void *buff,size_t	size, unsigned int use_unit_num, unsigned int log_unit,	__u8	page_code, unsigned char *scsi3addr, int block_nr, int diskdump);
+
+#if (CONFIG_BLOCKDUMP || CONFIG_BLOCKDUMP_MODULE)
+static struct block_dump_ops cciss_dump_device_ops = {
+	.sanity_check	= cciss_dump_sanity_check,
+	.rw_block	= cciss_dump_rw_block,
+	.quiesce	= cciss_dump_quiesce,
+	.shutdown	= cciss_dump_shutdown,
+};
+#endif
+
+/* Start of functions */
+
+/*
+ *   Wait polling for a command to complete.
+ *   The memory mapped FIFO is polled for the completion.
+ *   Used only at dump time, interrupts disabled.
+ */
+static unsigned long diskdump_pollcomplete(int ctlr)
+{
+	unsigned long done;
+
+	while (1){
+		done = hba[ctlr]->access.command_completed(hba[ctlr]);
+		if (done == FIFO_EMPTY){
+			udelay(20);
+			continue;
+		} else {
+			unsigned int *tag;
+			tag = (unsigned int *)&cciss_dump_cmnd->Header.Tag;
+			/* our command? compare lower 4 bytes of tag */
+			if (tag[0] != (done & 0x0fffffffc))
+				continue;
+			return done;
+		}
+	}
+}
+
+/*Dummy function.  Nothing to do here. */
+static int cciss_dump_shutdown(void *device) {
+	return 0;
+}
+
+static int cciss_dump_quiesce(void *device) {
+	drive_info_struct *dev = device;
+	int ret, ctlr, lun, temp;
+	char flush_buf[4];
+
+	if(find_ctlr_lun_ids(&ctlr, &lun, dev->LunID)){
+		printk("<1>Could not find controller or LUN.\n");
+		return -1;
+	}
+
+	memset(flush_buf, 0, 4);
+	ret = sendcmd(CCISS_CACHE_FLUSH, ctlr, flush_buf, 4, 0, 0, 0, NULL, 0, 1);
+	if (ret != IO_OK)
+		printk("<1>cciss%d: Error flushing cache\n", ctlr);
+
+	quiesce_ok = 1;
+
+	return 0;
+}
+
+static int cciss_dump_rw_block(void *device, int rw, unsigned long dump_block_nr, void *buf, int len, unsigned long start_sect, unsigned long nr_sects) {
+	drive_info_struct *dev = device;
+	int block_nr = BLOCK_SECTOR(dump_block_nr);
+
+	//this gives the number of bytes to write for len number
+	//of pages of memory.
+	int count = (len * PAGE_SIZE);
+	int ret;
+	int ctlr, lun;
+	__u8 cmd = CCISS_READ;
+
+	if(rw)
+		cmd = CCISS_WRITE;
+
+	if(find_ctlr_lun_ids(&ctlr, &lun, dev->LunID)){
+		printk("<1>Could not find controller or LUN.\n");
+		return -1;
+	}
+
+	if (!quiesce_ok) {
+		printk("<1>quiesce not called\n");
+		return -EIO;
+	}
+
+	/* Calculate start block to be used in the CDB command */
+	block_nr += start_sect;	
+
+
+	if (block_nr + (count/hba[ctlr]->drv[lun].block_size) > nr_sects + start_sect) {
+		printk("<1>block number %d is larger than %lu\n",
+			block_nr + (count/hba[ctlr]->drv[lun].block_size), nr_sects);
+		return -EFBIG;
+	}
+
+	ret = sendcmd(cmd, ctlr, buf, (size_t)count, 1, lun, 0, NULL, block_nr, 1);
+	return ret;
+}
+
+static int cciss_sanity_check(int ctlr, int lun){
+	int block_size;
+	int total_size;
+	int return_code;
+
+	memset(size_buff, 0, sizeof(ReadCapdata_struct));
+
+	return_code = sendcmd(CCISS_READ_CAPACITY, ctlr, size_buff,
+			sizeof(ReadCapdata_struct), 1, lun, 0, NULL, 0, 1);
+
+	if (return_code == IO_OK) {
+		total_size = (0xff & 
+			(unsigned int)(size_buff->total_size[0])) << 24;
+		total_size |= (0xff & 
+			(unsigned int)(size_buff->total_size[1])) << 16;
+		total_size |= (0xff & 
+			(unsigned int)(size_buff->total_size[2])) << 8;
+		total_size |= (0xff & (unsigned int)
+			(size_buff->total_size[3])); 
+		total_size++; 	/* command returns highest */
+				/* block address */
+
+		block_size = (0xff & 
+			(unsigned int)(size_buff->block_size[0])) << 24;
+               	block_size |= (0xff & 
+			(unsigned int)(size_buff->block_size[1])) << 16;
+               	block_size |= (0xff & 
+			(unsigned int)(size_buff->block_size[2])) << 8;
+               	block_size |= (0xff & 
+			(unsigned int)(size_buff->block_size[3]));
+
+	} else {	/* read capacity command failed */ 
+		printk("<1>cciss: read capacity failed\n");
+		return -1;
+	}
+
+	if(hba[ctlr]->drv[lun].nr_blocks != total_size){
+		printk("block_size:%d, blocks:%d, blocks:%d\n", block_size, total_size, hba[ctlr]->drv[lun].nr_blocks );
+		printk("<1>cciss:  blocks read do not match stored value\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+/*Will set ctlr and lun numbers if found and return 0.  If not found it
+  will return 1 to indicate an error */
+static int find_ctlr_lun_ids(int *ctlr, int *lun, __u32 LunID){
+	int i, j;
+	*ctlr = -1;
+	*lun = -1;
+	for(i=0; i<MAX_CTLR; i++){
+		if(hba[i] != NULL){
+			for(j=0; j<NWD; j++){
+				if(hba[i]->drv[j].LunID == LunID) {
+					*ctlr = i;
+					*lun = j;
+					return 0;
+				}
+			}
+		}
+	}
+
+	return 1;
+}
+
+static int cciss_dump_sanity_check(void *device){
+	drive_info_struct *dev = device;
+	int ctlr, lun;
+	int adapter_sanity = 0;
+	int sanity = 0;
+
+	/* Find the controller and LUN by searching for the LUNID in our list
+           of known devices.  If not found then throw an error */
+	if(find_ctlr_lun_ids(&ctlr, &lun, dev->LunID)){
+		printk("<1>Could not find controller or LUN.\n");
+		sanity=-1;
+		return sanity;
+	}
+
+	/* send a CCISS_READ_CAPACITY command here for the drive.  If the
+	   command succeeds then the drive is online.  Then we will check
+	   that the values we get back match what we have recorded.  That
+           way we can tell if anything has changed */
+	adapter_sanity=cciss_sanity_check(ctlr, lun);
+
+	return sanity + adapter_sanity;
+}
+
+void *cciss_probe(kdev_t dev){
+	static int i=0;
+	int ctlr, target;
+	ctlr_info_t *info_p;
+
+	target = MINOR(dev) >> NWD_SHIFT;
+	ctlr = MAJOR(dev) - MAJOR_NR;
+
+	info_p= hba[ctlr];
+	cciss_dump_cmnd = cmd_alloc(info_p, 0);
+
+	size_buff = kmalloc(sizeof( ReadCapdata_struct), GFP_KERNEL);
+        if (size_buff == NULL) {
+                printk(KERN_ERR "cciss: out of memory\n");
+                return NULL;
+        }
+
+
+	/* If the LUN does not exist on the controller then we must
+	   let diskdump know that this device is not valid */
+	if(hba[ctlr]->drv[target].nr_blocks == 0)
+		return NULL;
+	
+	return (void *)&hba[ctlr]->drv[target];
+}
+
+static unsigned int cciss_add_device(void *device) {
+	drive_info_struct *dev = device;
+	
+	return dev->nr_blocks;
+}
diff -urNp linux-5680/drivers/block/cciss_scsi.c linux-5681/drivers/block/cciss_scsi.c
--- linux-5680/drivers/block/cciss_scsi.c
+++ linux-5681/drivers/block/cciss_scsi.c
@@ -46,7 +46,10 @@ static int sendcmd(
 				      2: address is in scsi3addr */
 	unsigned int log_unit,
 	__u8	page_code,
-	unsigned char *scsi3addr );
+	unsigned char *scsi3addr,
+	int block_nr,
+	int diskdump ); 	/* 0: this is not a diskdump command
+				   1: this is a diskdump command */
 
 
 int __init cciss_scsi_detect(Scsi_Host_Template *tpnt);
@@ -322,6 +325,8 @@ print_cmd(CommandList_struct *cp)
 	printk("sgs..........Errorinfo:\n");
 	printk("scsistatus:%d\n", cp->err_info->ScsiStatus);
 	printk("senselen:%d\n", cp->err_info->SenseLen);
+	printk("SenseInfo: ");
+	print_bytes(cp->err_info->SenseInfo, cp->err_info->SenseLen, 1, 0); 
 	printk("cmd status:%d\n", cp->err_info->CommandStatus);
 	printk("resid cnt:%d\n", cp->err_info->ResidualCnt);
 	printk("offense size:%d\n", cp->err_info->MoreErrInfo.Invalid_Cmd.offense_size);
@@ -574,7 +579,7 @@ cciss_find_non_disk_devices(int cntl_num
 
 	/* Get the physical luns */
 	return_code = sendcmd(CISS_REPORT_PHYS, cntl_num, ld_buff,
-			reportlunsize, 0, 0, 0, NULL );
+			reportlunsize, 0, 0, 0, NULL, 0, 0);
 
 	if( return_code == IO_OK) {
 		unsigned char *c = &ld_buff->LUNListLength[0];
@@ -607,7 +612,7 @@ cciss_find_non_disk_devices(int cntl_num
 		memset(inq_buff, 0, sizeof(InquiryData_struct));
 		memcpy(scsi3addr, ld_buff->LUN[i], 8); /* ugly... */
 		return_code = sendcmd(CISS_INQUIRY, cntl_num, inq_buff,
-			sizeof(InquiryData_struct), 2, 0 ,0, scsi3addr );
+			sizeof(InquiryData_struct), 2, 0 ,0, scsi3addr, 0, 0);
 	  	if (return_code == IO_OK) {
 			if(inq_buff->data_byte[8] == 0xFF)
 			{
