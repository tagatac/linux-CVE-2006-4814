diff -urNp linux-1200/include/asm-s390/pgtable.h linux-1210/include/asm-s390/pgtable.h
--- linux-1200/include/asm-s390/pgtable.h
+++ linux-1210/include/asm-s390/pgtable.h
@@ -156,7 +156,6 @@ extern char empty_zero_page[PAGE_SIZE];
 
 /* Bits in the page table entry */
 #define _PAGE_PRESENT   0x001          /* Software                         */
-#define _PAGE_MKCLEAN   0x002          /* Software                         */
 #define _PAGE_ISCLEAN   0x004	       /* Software			   */
 #define _PAGE_RO        0x200          /* HW read-only                     */
 #define _PAGE_INVALID   0x400          /* HW invalid                       */
@@ -230,15 +229,6 @@ extern char empty_zero_page[PAGE_SIZE];
  */
 extern inline void set_pte(pte_t *pteptr, pte_t pteval)
 {
-	if ((pte_val(pteval) & (_PAGE_MKCLEAN|_PAGE_INVALID))
-	    == _PAGE_MKCLEAN) 
-	{
-		pte_val(pteval) &= ~_PAGE_MKCLEAN;
-               
-		asm volatile ("sske %0,%1" 
-				: : "d" (get_storage_key()), "a" (pte_val(pteval)));
-	}
-
 	*pteptr = pteval;
 }
 
@@ -354,7 +344,7 @@ extern inline pte_t pte_mkdirty(pte_t pt
 	 * sske instruction is slow. It is faster to let the
 	 * next instruction set the dirty bit.
 	 */
-	pte_val(pte) &= ~(_PAGE_MKCLEAN | _PAGE_ISCLEAN);
+	pte_val(pte) &= ~_PAGE_ISCLEAN;
 	return pte;
 }
 
@@ -435,15 +425,18 @@ static inline pte_t mk_pte_phys(unsigned
 	pgprot_t __pgprot = (pgprot);					  \
 	unsigned long __physpage = __pa((__page-mem_map) << PAGE_SHIFT);  \
 	pte_t __pte = mk_pte_phys(__physpage, __pgprot);                  \
-	                                                                  \
-	if (!(pgprot_val(__pgprot) & _PAGE_ISCLEAN)) {			  \
-		int __users = !!__page->buffers + !!__page->mapping;      \
-		if (__users + atomic_read(&__page->count) == 1)           \
-			pte_val(__pte) |= _PAGE_MKCLEAN;                  \
-	}								  \
 	__pte;                                                            \
 })
 
+#define SetPageUptodate(_page)						  \
+	do {								  \
+		struct page *__page = (_page);				  \
+		if (!test_and_set_bit(PG_uptodate, &__page->flags))	  \
+			asm volatile ("sske %0,%1"			  \
+			      : : "d" (get_storage_key()),		  \
+			      "a" (__pa((__page-mem_map) << PAGE_SHIFT)));\
+	} while (0)
+
 #define pte_pfn(x) (pte_val(x) >> PAGE_SHIFT)
 #define pte_page(x) pfn_to_page(pte_pfn(x))
 
diff -urNp linux-1200/include/asm-s390x/pgtable.h linux-1210/include/asm-s390x/pgtable.h
--- linux-1200/include/asm-s390x/pgtable.h
+++ linux-1210/include/asm-s390x/pgtable.h
@@ -158,7 +158,6 @@ extern char empty_zero_page[PAGE_SIZE];
 
 /* Bits in the page table entry */
 #define _PAGE_PRESENT   0x001          /* Software                         */
-#define _PAGE_MKCLEAN   0x002          /* Software                         */
 #define _PAGE_ISCLEAN   0x004          /* Software                         */
 #define _PAGE_RO        0x200          /* HW read-only                     */
 #define _PAGE_INVALID   0x400          /* HW invalid                       */
@@ -225,15 +224,6 @@ extern char empty_zero_page[PAGE_SIZE];
  */
 extern inline void set_pte(pte_t *pteptr, pte_t pteval)
 {
-	if ((pte_val(pteval) & (_PAGE_MKCLEAN|_PAGE_INVALID))
-	    == _PAGE_MKCLEAN) 
-	{
-		pte_val(pteval) &= ~_PAGE_MKCLEAN;
-               
-		asm volatile ("sske %0,%1" 
-				: : "d" (0), "a" (pte_val(pteval)));
-	}
-
 	*pteptr = pteval;
 }
 
@@ -373,7 +363,7 @@ extern inline pte_t pte_mkdirty(pte_t pt
 	 * sske instruction is slow. It is faster to let the
 	 * next instruction set the dirty bit.
 	 */
-	pte_val(pte) &= ~(_PAGE_MKCLEAN | _PAGE_ISCLEAN);
+	pte_val(pte) &= ~_PAGE_ISCLEAN;
 	return pte;
 }
 
@@ -454,15 +444,17 @@ extern inline pte_t mk_pte_phys(unsigned
 	pgprot_t __pgprot = (pgprot);					  \
 	unsigned long __physpage = __pa((__page-mem_map) << PAGE_SHIFT);  \
 	pte_t __pte = mk_pte_phys(__physpage, __pgprot);                  \
- 	                                                                  \
-	if (!(pgprot_val(__pgprot) & _PAGE_ISCLEAN)) {			  \
-		int __users = !!__page->buffers + !!__page->mapping;      \
-		if (__users + atomic_read(&__page->count) == 1)           \
-			pte_val(__pte) |= _PAGE_MKCLEAN;                  \
-	}								  \
 	__pte;                                                            \
 })
 
+#define SetPageUptodate(_page)						    \
+	do {								    \
+		struct page *__page = (_page);				    \
+		if (!test_and_set_bit(PG_uptodate, &__page->flags))	    \
+			asm volatile ("sske %0,%1" : : "d" (0),		    \
+				"a" (__pa((__page-mem_map) << PAGE_SHIFT)));\
+	} while (0)
+
 #define pte_pfn(x) (pte_val(x) >> PAGE_SHIFT)
 #define pte_page(x) pfn_to_page(pte_pfn(x))
 
diff -urNp linux-1200/include/linux/mm.h linux-1210/include/linux/mm.h
--- linux-1200/include/linux/mm.h
+++ linux-1210/include/linux/mm.h
@@ -336,7 +336,9 @@ typedef struct page {
 /* Make it prettier to test the above... */
 #define UnlockPage(page)	unlock_page(page)
 #define Page_Uptodate(page)	test_bit(PG_uptodate, &(page)->flags)
-#define SetPageUptodate(page)	set_bit(PG_uptodate, &(page)->flags)
+#ifndef SetPageUptodate
+#define SetPageUptodate(page)	set_bit(PG_uptodate, &(page)->flags)
+#endif
 #define ClearPageUptodate(page)	clear_bit(PG_uptodate, &(page)->flags)
 #define PageDirty(page)		test_bit(PG_dirty, &(page)->flags)
 #define SetPageDirty(page)	set_bit(PG_dirty, &(page)->flags)
