diff -urNp linux-860/arch/ppc64/kernel/process.c linux-870/arch/ppc64/kernel/process.c
--- linux-860/arch/ppc64/kernel/process.c
+++ linux-870/arch/ppc64/kernel/process.c
@@ -312,6 +312,14 @@ copy_thread(int nr, unsigned long clone_
 	return 0;
 }
 
+void show_stack(unsigned long *esp)
+{
+	register unsigned long *sp asm("r1");
+	if (esp == NULL)
+		esp = sp;
+	print_backtrace(esp);
+}
+
 /*
  * Set up a thread for executing a new program
  */
diff -urNp linux-860/arch/s390/kernel/traps.c linux-870/arch/s390/kernel/traps.c
--- linux-860/arch/s390/kernel/traps.c
+++ linux-870/arch/s390/kernel/traps.c
@@ -108,14 +108,71 @@ static inline int kernel_text_address(un
 
 #endif
 
+/*
+ * Return the kernel stack for the current or interrupted thread,
+ * considering that the async stack is useless for purposes of sysrq.
+ * All this acrobatics would not be needed if struct pt_regs pointer
+ * was available when softirq is run, because that is where we printk.
+ * Alas, it's not feasible.
+ */
+static unsigned long *discover_kernel_stack(void)
+{
+	unsigned long sp;
+	unsigned long asp;
+	unsigned long ksp;
+	struct pt_regs *regs;
+
+	/*
+	 * First, check if we are on a thread stack or async stack.
+	 * In case the sp value is returned, we must get actual sp,
+	 * not an approximate value. Unlike the x86, we do not scan,
+	 * we unwind. Thus the "sp = &sp" trick cannot be used.
+	 */
+	asm ( "    lr %0,15\n" : "=r" (sp) );
+
+	ksp = S390_lowcore.kernel_stack;
+	asp = S390_lowcore.async_stack;
+/* P3 */ printk("SP=%08lx AsS=%08lx KS=%08lx\n", sp, asp, ksp);
+	if (sp >= asp - 2*PAGE_SIZE && sp < asp) {
+		/*
+		 * We are on the async stack. Get the kernel stack
+		 * from the top frame, structure of which is defined
+		 * by the SAVE_ALL macro in entry.S.
+		 * Mind that SP_SIZE is aligned to nearest 8.
+		 */
+		regs = (struct pt_regs *) (asp - 144);
+/* P3 */ printk("REGS=%08lx\n", (long)regs);
+		if (regs->psw.mask & PSW_PROBLEM_STATE)
+			return 0;
+		sp = regs->gprs[15];
+/* P3 */ printk("SP=%08lx\n", sp);
+	} else {
+		/*
+		 * We are on kernel stack, or somewhere unknown.
+		 * In both cases, just return whatever we found.
+		 * The worst may happen would be an obviously short trace.
+		 */
+		;
+	}
+	return (unsigned long *)sp;
+}
+
 void show_trace(unsigned long * stack)
 {
 	static char buffer[512];
 	unsigned long backchain, low_addr, high_addr, ret_addr;
 	int i;
 
-	if (!stack)
-		stack = (unsigned long*)&stack;
+	if ((unsigned long)stack < PAGE_SIZE) {
+		/*
+		 * Should not happen in our current kernel, because we
+		 * add have checks or use tsk->thread.ksp in all callers,
+		 * but guard against careless changes and/or accidentially
+		 * backed out patches.
+		 */
+		printk("Null stack\n");
+		return;
+	}
 
 	low_addr = ((unsigned long) stack) & PSW_ADDR_MASK;
 	high_addr = (low_addr & (-THREAD_SIZE)) + THREAD_SIZE;
@@ -123,11 +180,15 @@ void show_trace(unsigned long * stack)
 	backchain = *((unsigned long *) low_addr) & PSW_ADDR_MASK;
 	/* Print up to 20 lines */
 	for (i = 0; i < 20; i++) {
-		if (backchain < low_addr || backchain >= high_addr)
+		if (backchain < low_addr || backchain >= high_addr) {
+			printk("[<->] (0x%lx)\n", backchain);
 			break;
+		}
 		ret_addr = *((unsigned long *) (backchain+56)) & PSW_ADDR_MASK;
-		if (!kernel_text_address(ret_addr))
+		if (!kernel_text_address(ret_addr)) {
+			printk("[<%08lx>] -\n", ret_addr);
 			break;
+		}
 		lookup_symbol(ret_addr, buffer, 512);
 		printk("[<%08lx>] %s (0x%lx)\n", ret_addr,buffer,backchain+56);
 		low_addr = backchain;
@@ -156,9 +217,12 @@ void show_stack(unsigned long *sp)
 
 	// debugging aid: "show_stack(NULL);" prints the
 	// back trace for this cpu.
-
-	if(sp == NULL)
-		sp = (unsigned long*) &sp;
+	if (sp == NULL) {
+		if ((sp = discover_kernel_stack()) == NULL) {
+			printk("User mode stack\n");
+			return;
+		}
+	}
 
 	stack = sp;
 	for (i = 0; i < kstack_depth_to_print; i++) {
diff -urNp linux-860/arch/s390x/kernel/traps.c linux-870/arch/s390x/kernel/traps.c
--- linux-860/arch/s390x/kernel/traps.c
+++ linux-870/arch/s390x/kernel/traps.c
@@ -110,6 +110,55 @@ static inline int kernel_text_address(un
 
 #endif
 
+/*
+ * Return the kernel stack for the current or interrupted thread,
+ * considering that the async stack is useless for purposes of sysrq.
+ * All this acrobatics would not be needed if struct pt_regs pointer
+ * was available when softirq is run, because that is where we printk.
+ * Alas, it's not feasible.
+ */
+static unsigned long *discover_kernel_stack(void)
+{
+	unsigned long sp;
+	unsigned long asp;
+	unsigned long ksp;
+	struct pt_regs *regs;
+
+	/*
+	 * First, check if we are on a thread stack or async stack.
+	 * In case the sp value is returned, we must get actual sp,
+	 * not an approximate value. Unlike the x86, we do not scan,
+	 * we unwind. Thus the "sp = &sp" trick cannot be used.
+	 */
+	asm ( "    lgr %0,15\n" : "=r" (sp) );
+
+	ksp = S390_lowcore.kernel_stack;
+	asp = S390_lowcore.async_stack;
+/* P3 */ printk("SP=%016lx AsS=%016lx KS=%016lx\n", sp, asp, ksp);
+	if (sp >= asp - 2*PAGE_SIZE && sp < asp) {
+		/*
+		 * We are on the async stack. Get the kernel stack
+		 * from the top frame, structure of which is defined
+		 * by the SAVE_ALL macro in entry.S.
+		 * Mind that SP_SIZE is aligned to nearest 8.
+		 */
+		regs = (struct pt_regs *) (asp - 224);
+/* P3 */ printk("REGS=%016lx\n", (long)regs);
+		if (regs->psw.mask & PSW_PROBLEM_STATE)
+			return 0;
+		sp = regs->gprs[15];
+/* P3 */ printk("SP=%016lx\n", sp);
+	} else {
+		/*
+		 * We are on kernel stack, or somewhere unknown.
+		 * In both cases, just return whatever we found.
+		 * The worst may happen would be an obviously short trace.
+		 */
+		;
+	}
+	return (unsigned long *)sp;
+}
+
 void show_trace(unsigned long * stack)
 {
 	unsigned long backchain, low_addr, high_addr, ret_addr;
@@ -117,8 +166,16 @@ void show_trace(unsigned long * stack)
 	/* static to not take up stackspace; if we race here too bad */
 	static char buffer[512];
 
-	if (!stack)
-		stack = (unsigned long*)&stack;
+	if ((unsigned long)stack < PAGE_SIZE) {
+		/*
+		 * Should not happen in our current kernel, because we
+		 * add have checks or use tsk->thread.ksp in all callers,
+		 * but guard against careless changes and/or accidentially
+		 * backed out patches.
+		 */
+		printk("Null stack\n");
+		return;
+	}
 
 	low_addr = ((unsigned long) stack) & PSW_ADDR_MASK;
 	high_addr = (low_addr & (-THREAD_SIZE)) + THREAD_SIZE;
@@ -126,11 +183,15 @@ void show_trace(unsigned long * stack)
 	backchain = *((unsigned long *) low_addr) & PSW_ADDR_MASK;
 	/* Print up to 20 lines */
 	for (i = 0; i < 20; i++) {
-		if (backchain < low_addr || backchain >= high_addr)
+		if (backchain < low_addr || backchain >= high_addr) {
+			printk("[<->] (0x%lx)\n", backchain);
 			break;
+		}
 		ret_addr = *((unsigned long *) (backchain+112)) & PSW_ADDR_MASK;
-		if (!kernel_text_address(ret_addr))
+		if (!kernel_text_address(ret_addr)) {
+			printk("[<%016lx>] -\n", ret_addr);
 			break;
+		}
 		lookup_symbol(ret_addr, buffer, 512);
 		printk("[<%016lx>] %s (0x%lx)\n", ret_addr, buffer, backchain+112);
 		low_addr = backchain;
@@ -160,8 +221,12 @@ void show_stack(unsigned long *sp)
 	// debugging aid: "show_stack(NULL);" prints the
 	// back trace for this cpu.
 
-	if (sp == NULL)
-		sp = (unsigned long*) &sp;
+	if (sp == NULL) {
+		if ((sp = discover_kernel_stack()) == NULL) {
+			printk("User mode stack\n");
+			return;
+		}
+	}
 
 	stack = sp;
 	for (i = 0; i < kstack_depth_to_print; i++) {
diff -urNp linux-860/drivers/char/serial.c linux-870/drivers/char/serial.c
--- linux-860/drivers/char/serial.c
+++ linux-870/drivers/char/serial.c
@@ -262,6 +262,8 @@ static int serial_refcount;
 
 static struct timer_list serial_timer;
 
+extern int sercons_escape_char;
+
 /* serial subtype definitions */
 #ifndef SERIAL_TYPE_NORMAL
 #define SERIAL_TYPE_NORMAL	1
@@ -644,6 +646,15 @@ static _INLINE_ void receive_chars(struc
 				*tty->flip.flag_buf_ptr = TTY_FRAME;
 		}
 #if defined(CONFIG_SERIAL_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+		if (sercons_escape_char == (int) ch) {
+			if (info->line == sercons.index) {
+				if (!break_pressed) {
+					break_pressed = jiffies;
+					goto ignore_char;
+				}
+				break_pressed = 0;
+			}
+		}
 		if (break_pressed && info->line == sercons.index) {
 			if (ch != 0 &&
 			    time_before(jiffies, break_pressed + HZ*5)) {
diff -urNp linux-860/drivers/char/sysrq.c linux-870/drivers/char/sysrq.c
--- linux-860/drivers/char/sysrq.c
+++ linux-870/drivers/char/sysrq.c
@@ -249,12 +249,32 @@ static void sysrq_handle_showregs(int ke
 	if (pt_regs)
 		show_regs(pt_regs);
 }
+
 static struct sysrq_key_op sysrq_showregs_op = {
 	handler:	sysrq_handle_showregs,
 	help_msg:	"showPc",
 	action_msg:	"Show Regs",
 };
 
+static spinlock_t show_lock = SPIN_LOCK_UNLOCKED;
+static void showacpu(void *info)
+{
+	spin_lock(&show_lock);
+	printk("CPU%d:\n", smp_processor_id());
+	show_stack(NULL);
+	spin_unlock(&show_lock);
+}
+static void sysrq_handle_showcpus(int key, struct pt_regs *pt_regs,
+		struct kbd_struct *kbd, struct tty_struct *tty) {
+	showacpu(NULL);
+	smp_call_function(showacpu, NULL, 0, 0);
+}
+static struct sysrq_key_op sysrq_showcpus_op = {
+	handler:	sysrq_handle_showcpus,
+	help_msg:	"shoWcpus",
+	action_msg:	"Show CPUs",
+};
+
 
 static void sysrq_handle_showstate(int key, struct pt_regs *pt_regs,
 		struct kbd_struct *kbd, struct tty_struct *tty) {
@@ -365,7 +385,7 @@ static struct sysrq_key_op *sysrq_key_ta
 /* t */	&sysrq_showstate_op,
 /* u */	&sysrq_mountro_op,
 /* v */	NULL,
-/* w */	NULL,
+/* w */	&sysrq_showcpus_op,
 /* x */	NULL,
 /* w */	NULL,
 /* z */	NULL
diff -urNp linux-860/include/linux/sysctl.h linux-870/include/linux/sysctl.h
--- linux-860/include/linux/sysctl.h
+++ linux-870/include/linux/sysctl.h
@@ -127,6 +127,7 @@ enum
 	KERN_PID_MAX=55,	/* int: max PID value of processes */
  	KERN_CORE_PATTERN=56,	/* string: pattern for core-files */
  	KERN_CORE_SETUID=58,	/* int: set to allow core dumps of setuid apps */
+	KERN_SERCONS_ESC=59,	/* int: ascii code of ser-cons "break" or -1 */
 	KERN_HONOR_UAC_NOPRINT=61, /* int: allow access to UAC_NOPRINT prctl */
 };
 
diff -urNp linux-860/kernel/sysctl.c linux-870/kernel/sysctl.c
--- linux-860/kernel/sysctl.c
+++ linux-870/kernel/sysctl.c
@@ -40,6 +40,8 @@
 
 #if defined(CONFIG_SYSCTL)
 
+int sercons_escape_char = -1;
+
 /* External variables not in a header file. */
 extern int panic_timeout;
 extern int print_fatal_signals;
@@ -284,6 +286,10 @@ static ctl_table kern_table[] = {
 	{KERN_S390_USER_DEBUG_LOGGING,"userprocess_debug",
 	 &sysctl_userprocess_debug,sizeof(int),0644,NULL,&proc_dointvec},
 #endif
+#ifdef CONFIG_SERIAL_CONSOLE
+	{KERN_SERCONS_ESC, "sercons_esc", &sercons_escape_char,
+	 sizeof(int), 0644, NULL, &proc_dointvec},
+#endif
 #ifdef CONFIG_IA64
 	{KERN_HONOR_UAC_NOPRINT, "honor_uac_noprint_prctl", &honor_uac_noprint,
 	 sizeof(int), 0644, NULL, &proc_dointvec},
