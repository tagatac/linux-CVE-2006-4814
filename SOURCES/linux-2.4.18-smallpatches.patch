diff -urNp linux-9020/Documentation/filesystems/proc.txt linux-9030/Documentation/filesystems/proc.txt
--- linux-9020/Documentation/filesystems/proc.txt
+++ linux-9030/Documentation/filesystems/proc.txt
@@ -25,6 +25,7 @@ Table of Contents
   1.5	SCSI info
   1.6	Parallel port info in /proc/parport
   1.7	TTY info in /proc/tty
+  1.8	Miscellaneous kernel statistics in /proc/stat
 
   2	Modifying System Parameters
   2.1	/proc/sys/fs - File system data
@@ -711,6 +712,80 @@ To see  which  tty's  are  currently in 
   unknown              /dev/tty        4    1-63 console 
 
 
+1.8 Miscellaneous kernel statistics in /proc/stat
+-------------------------------------------------
+
+Various pieces of information about kernel activity are available in the
+/proc/stat file.  All of the numbers reported in this file are aggregates
+since the system first booted.  For a quick look, simply cat the file:
+
+  > cat /proc/stat
+  cpu  2255 34 2290 22625563 6290 127 456
+  cpu0 1132 34 1441 11311718 3675 127 438
+  cpu1 1123 0 849 11313845 2614 0 18
+  page 200821 215871
+  swap 1 0
+  intr 114930548 113199788 3 0 5 263 0 4 [... lots more numbers ...]
+  disk_io: (3,0):(53813,29516,400952,24297,431720)
+  ctxt 1990473
+  btime 1062191376
+  processes 2915
+  procs_running 1
+  procs_blocked 0
+
+The very first "cpu" line aggregates the numbers in all of the other "cpuN"
+lines.  These numbers identify the amount of time the CPU has spent performing
+different kinds of work.  Time units are in USER_HZ (typically hundredths of a
+second).  The meanings of the columns are as follows, from left to right:
+
+- user: normal processes executing in user mode
+- nice: niced processes executing in user mode
+- system: processes executing in kernel mode
+- idle: twiddling thumbs
+- iowait: waiting for I/O to complete
+- irq: servicing interrupts
+- softirq: servicing softirqs
+
+The "page" line gives the number of pages that the system paged.  The first
+value is the number of pages that were paged in.  The second value is the
+number of pages that were paged out.
+
+The "swap" line gives the number of pages that were swapped in and out.  The
+first value is the number of swap pages that were read in.  The second value
+is the number of swap pages that were written out.
+
+The "intr" line gives counts of interrupts serviced since boot time, for each
+of the possible system interrupts.  The first value is the total of all
+interrupts serviced; each subsequent value is the total for that particular
+interrupt.
+
+The "disk_io" line gives the I/O stats for active disks.  The meanings of the
+values are as follows, from left to right:
+
+- major: major number of the disk
+- minor: minor number of the disk 
+- total: total aggregate of read plus write operations
+- read_io_ops: number of read operations 
+- blks_read: number of blocks read
+- write_io_ops: number of write operations 
+- blks_written: number of blocks written
+
+The "ctxt" line gives the total number of context switches across all CPUs.
+
+The "btime" line gives the time at which the system booted, in seconds since
+the Unix epoch.
+
+The "processes" line gives the number of processes and threads created, which
+includes (but is not limited to) those created by calls to the fork() and
+clone() system calls.
+
+The "procs_running" line gives the number of processes currently running on
+CPUs.
+
+The "procs_blocked" line gives the number of processes currently blocked,
+waiting for I/O to complete.
+
+
 ------------------------------------------------------------------------------
 Summary
 ------------------------------------------------------------------------------
diff -urNp linux-9020/arch/i386/config.in linux-9030/arch/i386/config.in
--- linux-9020/arch/i386/config.in
+++ linux-9030/arch/i386/config.in
@@ -98,7 +98,7 @@ if [ "$CONFIG_M586MMX" = "y" ]; then
    define_bool CONFIG_X86_F00F_WORKS_OK n
 fi
 if [ "$CONFIG_M686" = "y" ]; then
-   define_int  CONFIG_X86_L1_CACHE_SHIFT 5
+   define_int  CONFIG_X86_L1_CACHE_SHIFT 7
    define_bool CONFIG_X86_HAS_TSC y
    define_bool CONFIG_X86_GOOD_APIC y
    bool 'PGE extensions (not for Cyrix/Transmeta)' CONFIG_X86_PGE
@@ -107,7 +107,7 @@ if [ "$CONFIG_M686" = "y" ]; then
    define_bool CONFIG_X86_F00F_WORKS_OK y
 fi
 if [ "$CONFIG_MPENTIUMIII" = "y" ]; then
-   define_int  CONFIG_X86_L1_CACHE_SHIFT 5
+   define_int  CONFIG_X86_L1_CACHE_SHIFT 7
    define_bool CONFIG_X86_HAS_TSC y
    define_bool CONFIG_X86_GOOD_APIC y
    define_bool CONFIG_X86_PGE y
diff -urNp linux-9020/arch/i386/kernel/entry.S linux-9030/arch/i386/kernel/entry.S
--- linux-9020/arch/i386/kernel/entry.S
+++ linux-9030/arch/i386/kernel/entry.S
@@ -553,7 +553,7 @@ ENTRY(spurious_interrupt_bug)
 .previous
 
 .data
-ENTRY(sys_call_table)
+sys_call_table:
 	.long SYMBOL_NAME(sys_ni_syscall)	/* 0  -  old "setup()" system call*/
 	.long SYMBOL_NAME(sys_exit)
 	.long SYMBOL_NAME(sys_fork)
diff -urNp linux-9020/arch/i386/kernel/pci-pc.c linux-9030/arch/i386/kernel/pci-pc.c
--- linux-9020/arch/i386/kernel/pci-pc.c
+++ linux-9030/arch/i386/kernel/pci-pc.c
@@ -440,8 +440,8 @@ static struct pci_ops pci_direct_conf2 =
 static int __devinit pci_sanity_check(struct pci_ops *o)
 {
 	u16 x;
-	struct pci_bus bus;		/* Fake bus and device */
-	struct pci_dev dev;
+	static struct pci_bus bus;		/* Fake bus and device */
+	static struct pci_dev dev;
 
 	if (pci_probe & PCI_NO_CHECKS)
 		return 1;
@@ -1015,7 +1015,8 @@ struct irq_routing_table * __devinit pci
 		"xor %%ah, %%ah\n"
 		"1:"
 		: "=a" (ret),
-		  "=b" (map)
+		  "=b" (map),
+		  "+m" (opt)
 		: "0" (PCIBIOS_GET_ROUTING_OPTIONS),
 		  "1" (0),
 		  "D" ((long) &opt),
diff -urNp linux-9020/arch/i386/kernel/setup.c linux-9030/arch/i386/kernel/setup.c
--- linux-9020/arch/i386/kernel/setup.c
+++ linux-9030/arch/i386/kernel/setup.c
@@ -452,11 +452,34 @@ static void __init add_memory_region(uns
                                   unsigned long long size, int type)
 {
 	int x = e820.nr_map;
+	static int sillymemwarning = 0;
 
 	if (x == E820MAX) {
 	    printk(KERN_ERR "Ooops! Too many entries in the memory map!\n");
 	    return;
 	}
+	
+#ifndef CONFIG_X86_4G
+	/* for kernels without 4G/4G split, limit the memory at 32Gb, and 
+	 * printk a note pointing at the hugemem kernel from 16Gb onwards
+	 */
+	 
+	 
+	if (start >= 0x800000000ULL)
+		return; /* region starts too high already */
+	if (start + size > 0x800000000ULL)
+		size = 0x800000000ULL - start;
+		
+	if (start + size >= 0x400000000ULL && !sillymemwarning++) {
+		printk("********************************************************\n");
+		printk("* This system has more than 16 Gigabyte of memory.     *\n");
+		printk("* It is recommended that you read the release notes    *\n");
+		printk("* that accompany your copy of Red Hat Enterprise Linux *\n");
+		printk("* about the recommended kernel for such configurations *\n");
+		printk("********************************************************\n");		
+	}
+
+#endif	
 
 	e820.map[x].addr = start;
 	e820.map[x].size = size;
@@ -505,10 +528,10 @@ static int __init sanitize_e820_map(stru
 		struct e820entry *pbios; /* pointer to original bios entry */
 		unsigned long long addr; /* address for this change point */
 	};
-	struct change_member change_point_list[2*E820MAX];
-	struct change_member *change_point[2*E820MAX];
-	struct e820entry *overlap_list[E820MAX];
-	struct e820entry new_bios[E820MAX];
+	static struct change_member change_point_list[2*E820MAX];
+	static struct change_member *change_point[2*E820MAX];
+	static struct e820entry *overlap_list[E820MAX];
+	static struct e820entry new_bios[E820MAX];
 	struct change_member *change_tmp;
 	unsigned long current_type, last_type;
 	unsigned long long last_addr;
diff -urNp linux-9020/arch/i386/lib/memcpy.c linux-9030/arch/i386/lib/memcpy.c
--- linux-9020/arch/i386/lib/memcpy.c
+++ linux-9030/arch/i386/lib/memcpy.c
@@ -6,11 +6,7 @@
 
 void * memcpy(void * to, const void * from, size_t n)
 {
-#ifdef CONFIG_X86_USE_3DNOW
-	return __memcpy3d(to, from, n);
-#else
 	return __memcpy(to, from, n);
-#endif
 }
 
 void * memset(void * s, int c, size_t count)
diff -urNp linux-9020/arch/ppc64/kernel/rtc.c linux-9030/arch/ppc64/kernel/rtc.c
--- linux-9020/arch/ppc64/kernel/rtc.c
+++ linux-9030/arch/ppc64/kernel/rtc.c
@@ -96,6 +96,7 @@ static int rtc_ioctl(struct inode *inode
 	switch (cmd) {
 	case RTC_RD_TIME:	/* Read the time/date from RTC	*/
 	{
+		memset(&wtime, 0, sizeof(struct rtc_time));
 		ppc_md.get_rtc_time(&wtime);
 		break;
 	}
@@ -225,6 +226,7 @@ static int rtc_proc_output (char *buf)
 	
 	p = buf;
 
+	memset(&tm, 0, sizeof(struct rtc_time));
 	ppc_md.get_rtc_time(&tm);
 
 	/*
diff -urNp linux-9020/drivers/addon/cipe/encaps.c linux-9030/drivers/addon/cipe/encaps.c
--- linux-9020/drivers/addon/cipe/encaps.c
+++ linux-9030/drivers/addon/cipe/encaps.c
@@ -217,7 +217,7 @@ unsigned short cipe_decrypt(struct cipe 
     cbc_dec(buf, *len, ((*buf)&0x80) ? &c->rkey_d : &c->key_d);
     (*len)-=blockSize;
     if (((*len) - 4) <= 0) {
-	    printk(KERN_ERR, "%s: CIPE BUG, len==%d, orig_len==%d, buf==%p\n",
+	    printk(KERN_ERR, "CIPE BUG, len==%d, orig_len==%d, buf==%p\n",
 		   *len, *len + blockSize, buf);
 	    return TW_ERROR;
     }
diff -urNp linux-9020/drivers/block/ll_rw_blk.c linux-9030/drivers/block/ll_rw_blk.c
--- linux-9020/drivers/block/ll_rw_blk.c
+++ linux-9030/drivers/block/ll_rw_blk.c
@@ -320,7 +320,7 @@ void blk_queue_bounce_limit(request_queu
 	 */
 	if (dma_addr != BLK_BOUNCE_HIGH && q != old_q) {
 		old_q = q;
-		printk("blk: queue %p, ", q);
+		printk(KERN_INFO "blk: queue %p, ", q);
 		if (dma_addr == BLK_BOUNCE_ANY)
 			printk("no I/O memory limit\n");
 		else
@@ -855,11 +855,13 @@ void req_finished_io(struct request *req
 {
 	struct hd_struct *hd1, *hd2;
 
-	locate_hd_struct(req, &hd1, &hd2);
-	if (hd1)
-		account_io_end(hd1, req);
-	if (hd2)	
-		account_io_end(hd2, req);
+	if (blk_fs_request(req)) {
+		locate_hd_struct(req, &hd1, &hd2);
+		if (hd1)
+			account_io_end(hd1, req);
+		if (hd2)
+			account_io_end(hd2, req);
+	}
 }
 EXPORT_SYMBOL(req_finished_io);
 #endif /* CONFIG_BLK_STATS */
diff -urNp linux-9020/drivers/block/rd.c linux-9030/drivers/block/rd.c
--- linux-9020/drivers/block/rd.c
+++ linux-9030/drivers/block/rd.c
@@ -61,7 +61,7 @@
 #include <linux/blkpg.h>
 
 /* The RAM disk size is now a parameter */
-#define NUM_RAMDISKS 16		/* This cannot be overridden (yet) */ 
+#define NUM_RAMDISKS 256		/* This cannot be overridden (yet) */ 
 
 #ifdef CONFIG_BLK_DEV_INITRD
 static int initrd_users;
diff -urNp linux-9020/drivers/cdrom/cdrom.c linux-9030/drivers/cdrom/cdrom.c
--- linux-9020/drivers/cdrom/cdrom.c
+++ linux-9030/drivers/cdrom/cdrom.c
@@ -1259,7 +1259,7 @@ static int dvd_read_bca(struct cdrom_dev
 	init_cdrom_command(&cgc, buf, sizeof(buf), CGC_DATA_READ);
 	cgc.cmd[0] = GPCMD_READ_DVD_STRUCTURE;
 	cgc.cmd[7] = s->type;
-	cgc.cmd[9] = cgc.buflen = 0xff;
+	cgc.cmd[9] = cgc.buflen & 0xff;
 
 	if ((ret = cdo->generic_packet(cdi, &cgc)))
 		return ret;
@@ -1310,8 +1310,41 @@ static int dvd_read_manufact(struct cdro
 	return ret;
 }
 
+static int check_feature_current(struct cdrom_device_info *cdi, __u16 feature)
+{
+	int ret;
+	u_char buf[12];
+	struct cdrom_generic_command cgc;
+	struct cdrom_device_ops *cdo = cdi->ops;
+
+	init_cdrom_command(&cgc, buf, sizeof(buf), CGC_DATA_READ);
+	cgc.cmd[0] = GPCMD_GET_CONFIGURATION;
+	cgc.cmd[1] = 2; /* only get one feature descriptor */
+	cgc.cmd[2] = feature >> 8;
+	cgc.cmd[3] = feature & 0xff;
+	cgc.cmd[8] = 12;
+
+	if ((ret = cdo->generic_packet(cdi, &cgc)))
+		return 0;
+	if (buf[3] < 8) /* i.e., drive doesn't support the feature */
+		return -EMEDIUMTYPE;
+	if ((buf[10] & 1) == 0) /* feature is not current--invalid media */ 
+		return -EMEDIUMTYPE;
+	return 0;
+}
+
 static int dvd_read_struct(struct cdrom_device_info *cdi, dvd_struct *s)
 {
+	int ret;
+
+	/* do a GET_CONFIGURATION to make sure drive can do
+	 * DVD_READ_STRUCTURE command with current media
+	 */
+	ret = check_feature_current(cdi, CDF_DVD_READ);
+	if (ret)
+		return ret;
+
+	/* actually read the requested DVD structure */
 	switch (s->type) {
 	case DVD_STRUCT_PHYSICAL:
 		return dvd_read_physical(cdi, s);
diff -urNp linux-9020/drivers/char/mem.c linux-9030/drivers/char/mem.c
--- linux-9020/drivers/char/mem.c
+++ linux-9030/drivers/char/mem.c
@@ -45,6 +45,18 @@ extern void mda_console_init(void);
 extern void tapechar_init(void);
 #endif
      
+#ifdef __PAGE_OFFSET
+#define KMEM_START		((unsigned long)__PAGE_OFFSET)
+#else
+#define KMEM_START		((unsigned long)PAGE_OFFSET)
+#endif
+#define KMEM_END		((unsigned long)high_memory)
+
+#define kmem_addr_ok(x)	((((unsigned long)(x) >= KMEM_START) && \
+				  ((unsigned long)(x) <  KMEM_END)) || \
+				 (((unsigned long)(x) >= VMALLOC_START) && \
+				  ((unsigned long)(x) <  VMALLOC_END)))
+
 static ssize_t do_write_mem(struct file * file, void *p, unsigned long realp,
 			    const char * buf, size_t count, loff_t *ppos)
 {
@@ -233,6 +245,9 @@ static ssize_t read_kmem(struct file *fi
 	ssize_t virtr = 0;
 	char * kbuf; /* k-addr because vread() takes vmlist_lock rwlock */
 		
+	if (!kmem_addr_ok(p))
+		return -ENXIO;
+
 	if (p < (unsigned long) high_memory) {
 		read = count;
 		if (count > (unsigned long) high_memory - p)
@@ -298,6 +313,9 @@ static ssize_t write_kmem(struct file * 
 	ssize_t virtr = 0;
 	char * kbuf; /* k-addr because vwrite() takes vmlist_lock rwlock */
 
+	if (!kmem_addr_ok(p))
+		return -ENXIO;
+
 	if (p < (unsigned long) high_memory) {
 		wrote = count;
 		if (count > (unsigned long) high_memory - p)
@@ -587,6 +605,9 @@ static int mmap_kmem(struct file * file,
 	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
 	unsigned long size = vma->vm_end - vma->vm_start;
 
+	if (!kmem_addr_ok(offset))
+		return -ENXIO;
+
 	/*
 	 * If the user is not attempting to mmap a high memory address then
 	 * the standard mmap_mem mechanism will work.  High memory addresses
diff -urNp linux-9020/drivers/char/moxa.c linux-9030/drivers/char/moxa.c
--- linux-9020/drivers/char/moxa.c
+++ linux-9030/drivers/char/moxa.c
@@ -905,6 +905,8 @@ static int moxa_ioctl(struct tty_struct 
 	case TIOCSSERIAL:
 		return (moxa_set_serial_info(ch, (struct serial_struct *) arg));
 	default:
+		if (!capable(CAP_SYS_ADMIN))
+			return -EPERM;
 		retval = MoxaDriverIoctl(cmd, arg, port);
 	}
 	return (retval);
@@ -1766,15 +1768,21 @@ int MoxaDriverIoctl(unsigned int cmd, un
 	switch(cmd)
 	{
 	case MOXA_LOAD_BIOS:
+	 	if (!capable(CAP_SYS_RAWIO))
+			return -EPERM;
 		i = moxaloadbios(dltmp.cardno, dltmp.buf, dltmp.len);
 		return (i);
 	case MOXA_FIND_BOARD:
 		return moxafindcard(dltmp.cardno);
 	case MOXA_LOAD_C320B:
+		if (!capable(CAP_SYS_RAWIO))
+			return -EPERM;
 		moxaload320b(dltmp.cardno, dltmp.buf, dltmp.len);
 	default: /* to keep gcc happy */
 		return (0);
 	case MOXA_LOAD_CODE:
+		if (!capable(CAP_SYS_RAWIO))
+			return -EPERM;
 		i = moxaloadcode(dltmp.cardno, dltmp.buf, dltmp.len);
 		if (i == -1)
 			return (-EFAULT);
diff -urNp linux-9020/drivers/char/pcwd.c linux-9030/drivers/char/pcwd.c
--- linux-9020/drivers/char/pcwd.c
+++ linux-9030/drivers/char/pcwd.c
@@ -932,9 +932,7 @@ pcwatchdog_exit (void)
 		misc_deregister (&temp_miscdev);
 
 	release_region (pcwd_info.io_addr, pcwd_info.card_info->io_size);
-
-	if (pcwd_info.flags & PCWD_PCI_REG)
-		pci_unregister_driver (&pcwd_driver);
+	pci_unregister_driver (&pcwd_driver);
 
 	return;
 }
diff -urNp linux-9020/drivers/char/rtc.c linux-9030/drivers/char/rtc.c
--- linux-9020/drivers/char/rtc.c
+++ linux-9030/drivers/char/rtc.c
@@ -362,7 +362,7 @@ static int rtc_ioctl(struct inode *inode
 		 * means "don't care" or "match all". Only the tm_hour,
 		 * tm_min, and tm_sec values are filled in.
 		 */
-
+		memset(&wtime, 0, sizeof(struct rtc_time));
 		get_rtc_alm_time(&wtime);
 		break; 
 	}
@@ -406,6 +406,7 @@ static int rtc_ioctl(struct inode *inode
 	}
 	case RTC_RD_TIME:	/* Read the time/date from RTC	*/
 	{
+		memset(&wtime, 0, sizeof(struct rtc_time));
 		get_rtc_time(&wtime);
 		break;
 	}
diff -urNp linux-9020/drivers/char/serial.c linux-9030/drivers/char/serial.c
--- linux-9020/drivers/char/serial.c
+++ linux-9030/drivers/char/serial.c
@@ -5748,14 +5748,14 @@ static int __init rs_init(void)
 		    && (state->port != 0 || state->iomem_base != 0))
 			state->irq = detect_uart_irq(state);
 		if (state->io_type == SERIAL_IO_MEM) {
-			printk(KERN_INFO"ttyS%02d%s at 0x%p (irq = %d) is a %s\n",
+			printk(KERN_INFO"ttyS%d%s at 0x%p (irq = %d) is a %s\n",
 	 		       state->line + SERIAL_DEV_OFFSET,
 			       (state->flags & ASYNC_FOURPORT) ? " FourPort" : "",
 			       state->iomem_base, state->irq,
 			       uart_config[state->type].name);
 		}
 		else {
-			printk(KERN_INFO "ttyS%02d%s at 0x%04lx (irq = %d) is a %s\n",
+			printk(KERN_INFO "ttyS%d%s at 0x%04lx (irq = %d) is a %s\n",
 	 		       state->line + SERIAL_DEV_OFFSET,
 			       (state->flags & ASYNC_FOURPORT) ? " FourPort" : "",
 			       state->port, state->irq,
@@ -5907,7 +5907,7 @@ int register_serial(struct serial_struct
 	if ((state->flags & ASYNC_AUTO_IRQ) && CONFIGURED_SERIAL_PORT(state))
 		state->irq = detect_uart_irq(state);
 
-       printk(KERN_INFO "ttyS%02d at %s 0x%04lx (irq = %d) is a %s\n",
+       printk(KERN_INFO "ttyS%d at %s 0x%04lx (irq = %d) is a %s\n",
 	      state->line + SERIAL_DEV_OFFSET,
 	      state->iomem_base ? "iomem" : "port",
 	      state->iomem_base ? (unsigned long)state->iomem_base :
@@ -5937,7 +5937,7 @@ void unregister_serial(int line)
 	if (state->info && state->info->tty)
 		tty_hangup(state->info->tty);
 	state->type = PORT_UNKNOWN;
-	printk(KERN_INFO "ttyS%02d unloaded\n", state->line);
+	printk(KERN_INFO "ttyS%d unloaded\n", state->line);
 	/* These will be hidden, because they are devices that will no longer
 	 * be available to the system. (ie, PCMCIA modems, once ejected)
 	 */
diff -urNp linux-9020/drivers/ide/ide-dma.c linux-9030/drivers/ide/ide-dma.c
--- linux-9020/drivers/ide/ide-dma.c
+++ linux-9030/drivers/ide/ide-dma.c
@@ -141,7 +141,6 @@ struct drive_list_entry drive_blacklist 
 	{ "SAMSUNG CD-ROM SC-148F",	"ALL"		},
 	{ "SAMSUNG CD-ROM SC",	"ALL"		},
 	{ "SanDisk SDP3B-64"	,	"ALL"		},
-	{ "SAMSUNG CD-ROM SN-124",	"ALL"		},
 	{ "PLEXTOR CD-R PX-W8432T",	"ALL"		},
 	{ "ATAPI CD-ROM DRIVE 40X MAXIMUM",	"ALL"		},
 	{ "_NEC DV5800A",               "ALL"           },  
diff -urNp linux-9020/drivers/ide/ide-floppy.c linux-9030/drivers/ide/ide-floppy.c
--- linux-9020/drivers/ide/ide-floppy.c
+++ linux-9030/drivers/ide/ide-floppy.c
@@ -1026,6 +1026,20 @@ static ide_startstop_t idefloppy_transfe
 	return ide_started;
 }
 
+/**
+ * idefloppy_should_report_error()
+ *
+ * Supresses error messages resulting from Medium not present
+ */
+static inline int idefloppy_should_report_error(idefloppy_floppy_t *floppy)
+{
+	if (floppy->sense_key == 0x02 &&
+	    floppy->asc       == 0x3a &&
+	    floppy->ascq      == 0x00)
+		return 0;
+	return 1;
+}
+
 /*
  *	Issue a packet command
  */
@@ -1058,12 +1072,13 @@ static ide_startstop_t idefloppy_issue_p
 		 */
 		if (!test_bit(PC_ABORT, &pc->flags)) {
 			if (!test_bit(PC_SUPPRESS_ERROR, &pc->flags)) {
-				printk(KERN_ERR "ide-floppy: %s: I/O error, "
-						"pc = %2x, key = %2x, "
-						"asc = %2x, ascq = %2x\n",
-						drive->name, pc->c[0],
-						floppy->sense_key,
-						floppy->asc, floppy->ascq);
+				if (idefloppy_should_report_error(floppy))
+					printk(KERN_ERR "ide-floppy: %s: I/O error, "
+					       "pc = %2x, key = %2x, "
+					       "asc = %2x, ascq = %2x\n",
+					       drive->name, pc->c[0],
+					       floppy->sense_key,
+					       floppy->asc, floppy->ascq);
 			}
 			/* Giving up */
 			pc->error = IDEFLOPPY_ERROR_GENERAL;
@@ -1276,14 +1291,16 @@ static ide_startstop_t idefloppy_do_requ
 #endif /* IDEFLOPPY_DEBUG_LOG */
 
 	if (rq->errors >= ERROR_MAX) {
-		if (floppy->failed_pc != NULL)
-			printk(KERN_ERR "ide-floppy: %s: I/O error, pc = %2x,"
-					" key = %2x, asc = %2x, ascq = %2x\n",
-				drive->name, floppy->failed_pc->c[0],
-				floppy->sense_key, floppy->asc, floppy->ascq);
+		if (floppy->failed_pc != NULL) {
+			if (idefloppy_should_report_error(floppy))
+				printk(KERN_ERR "ide-floppy: %s: I/O error, pc = %2x,"
+				       " key = %2x, asc = %2x, ascq = %2x\n",
+				       drive->name, floppy->failed_pc->c[0],
+				       floppy->sense_key, floppy->asc, floppy->ascq);
+		}
 		else
 			printk(KERN_ERR "ide-floppy: %s: I/O error\n",
-				drive->name);
+			       drive->name);
 		idefloppy_do_end_request(drive, 0);
 		return ide_stopped;
 	}
diff -urNp linux-9020/drivers/ide/ide-tape.c linux-9030/drivers/ide/ide-tape.c
--- linux-9020/drivers/ide/ide-tape.c
+++ linux-9030/drivers/ide/ide-tape.c
@@ -1,5 +1,5 @@
 /*
- * linux/drivers/ide/ide-tape.c		Version 1.17b	Dec, 2002
+ * linux/drivers/ide/ide-tape.c		Version 1.17c	Sep, 2003
  *
  * Copyright (C) 1995 - 1999 Gadi Oxman <gadio@netvision.net.il>
  *
@@ -313,6 +313,9 @@
  *			Cosmetic fixes to miscellaneous debugging output messages.
  *			Set the minimum /proc/ide/hd?/settings values for "pipeline",
  *			 "pipeline_min", and "pipeline_max" to 1.
+ * Ver 1.17c Sep 2003	Stuart Hayes <stuart_hayes@dell.com>
+ *			Initialized "feature" in idetape_issue_packet_command
+ *			 (this was causing lockups on certain systems)
  *
  * Here are some words from the first releases of hd.c, which are quoted
  * in ide.c and apply here as well:
@@ -422,7 +425,7 @@
  *		sharing a (fast) ATA-2 disk with any (slow) new ATAPI device.
  */
 
-#define IDETAPE_VERSION "1.17b-ac1"
+#define IDETAPE_VERSION "1.17c"
 
 #include <linux/config.h>
 #include <linux/module.h>
@@ -2367,6 +2370,8 @@ static ide_startstop_t idetape_issue_pac
 	atapi_feature_t feature;
 	atapi_bcount_t bcount;
 
+	feature.all = 0;
+
 #if IDETAPE_DEBUG_BUGS
 	if (tape->pc->c[0] == IDETAPE_REQUEST_SENSE_CMD &&
 	    pc->c[0] == IDETAPE_REQUEST_SENSE_CMD) {
diff -urNp linux-9020/drivers/ieee1394/dma.c linux-9030/drivers/ieee1394/dma.c
--- linux-9020/drivers/ieee1394/dma.c
+++ linux-9030/drivers/ieee1394/dma.c
@@ -85,8 +85,8 @@ int dma_region_alloc(struct dma_region *
 	memset(dma->kvirt, 0, n_pages * PAGE_SIZE);
 
 	/* allocate scatter/gather list */
-	dma->sglist = kmalloc(dma->n_pages * sizeof(struct scatterlist), GFP_KERNEL);
-	if(!dma->sglist) {
+	dma->sglist = vmalloc(dma->n_pages * sizeof(struct scatterlist));
+	if (!dma->sglist) {
 		printk(KERN_ERR "dma_region_alloc: kmalloc(sglist) failed\n");
 		goto err;
 	}
@@ -128,8 +128,8 @@ void dma_region_free(struct dma_region *
 		dma->dev = NULL;
 	}
 
-	if(dma->sglist) {
-		kfree(dma->sglist);
+	if (dma->sglist) {
+		vfree(dma->sglist);
 		dma->sglist = NULL;
 	}
 
diff -urNp linux-9020/drivers/ieee1394/sbp2.h linux-9030/drivers/ieee1394/sbp2.h
--- linux-9020/drivers/ieee1394/sbp2.h
+++ linux-9030/drivers/ieee1394/sbp2.h
@@ -473,9 +473,9 @@ static void sbp2_remove_device(struct sc
 
 #ifdef CONFIG_IEEE1394_SBP2_PHYS_DMA
 static int sbp2_handle_physdma_write(struct hpsb_host *host, int nodeid, int destid, quadlet_t *data,
-                                     u64 addr, unsigned int length);
+                                     u64 addr, unsigned int length, u16 flags);                                    
 static int sbp2_handle_physdma_read(struct hpsb_host *host, int nodeid, quadlet_t *data,
-                                    u64 addr, unsigned int length);
+                                    u64 addr, unsigned int length, u16 flags);
 #endif
 
 /*
diff -urNp linux-9020/drivers/ieee1394/video1394.c linux-9030/drivers/ieee1394/video1394.c
--- linux-9020/drivers/ieee1394/video1394.c
+++ linux-9030/drivers/ieee1394/video1394.c
@@ -216,6 +216,7 @@ alloc_dma_iso_ctx(struct ti_ohci *ohci, 
 	d->frame_size = buf_size;
 	d->buf_size = PAGE_ALIGN(buf_size);
 	d->last_buffer = -1;
+	INIT_LIST_HEAD(&d->link);
 	init_waitqueue_head(&d->waitq);
 
 	/* Init the regions for easy cleanup */
diff -urNp linux-9020/drivers/input/keybdev.c linux-9030/drivers/input/keybdev.c
--- linux-9020/drivers/input/keybdev.c
+++ linux-9030/drivers/input/keybdev.c
@@ -172,7 +172,8 @@ void keybdev_event(struct input_handle *
 	if (type != EV_KEY) return;
 
 	if (emulate_raw(code, down))
-		printk(KERN_WARNING "keyboard.c: can't emulate rawmode for keycode %d\n", code);
+		if (code < BTN_MISC)
+			printk(KERN_WARNING "keybdev.c: can't emulate rawmode for keycode %d\n", code);
 
 	tasklet_schedule(&keyboard_tasklet);
 }
diff -urNp linux-9020/drivers/md/md.c linux-9030/drivers/md/md.c
--- linux-9020/drivers/md/md.c
+++ linux-9030/drivers/md/md.c
@@ -1054,7 +1054,7 @@ static int write_disk_sb(mdk_rdev_t * rd
 		goto skip;
 	}
 
-	printk(KERN_INFO "(write) %s's sb offset: %lu\n", partition_name(dev), sb_offset);
+	dprintk(KERN_INFO "(write) %s's sb offset: %lu\n", partition_name(dev), sb_offset);
 
 	if (!sync_page_io(dev, sb_offset<<1, MD_SB_BYTES, rdev->sb_page, WRITE)) {
 		printk("md: write_disk_sb failed for device %s\n", partition_name(dev));
@@ -1148,26 +1148,26 @@ repeat:
 	if (mddev->sb->not_persistent)
 		goto out;
 
-	printk(KERN_INFO "md: updating md%d RAID superblock on device\n",
+	dprintk(KERN_INFO "md: updating md%d RAID superblock on device\n",
 					mdidx(mddev));
 
 	err = 0;
 	ITERATE_RDEV(mddev,rdev,tmp) {
-		printk(KERN_INFO "md: ");
+		dprintk(KERN_INFO "md: ");
 		if (rdev->faulty)
-			printk("(skipping faulty ");
+			dprintk("(skipping faulty ");
 		else if (rdev->alias_device)
-			printk("(skipping alias ");
+			dprintk("(skipping alias ");
 		else if (disk_faulty(&rdev->sb->this_disk))
-			printk("(skipping new-faulty ");
+			dprintk("(skipping new-faulty ");
 		else {
-			printk("%s [events: %08lx]\n",
+			dprintk("%s [events: %08lx]\n",
 				partition_name(rdev->dev),
 				(unsigned long)rdev->sb->events_lo);
 			err += write_disk_sb(rdev);
 			continue;
 		}
-		printk("%s)\n", partition_name(rdev->dev));
+		dprintk("%s)\n", partition_name(rdev->dev));
 	}
 	if (err) {
 		if (--count) {
@@ -2872,12 +2872,17 @@ static int md_ioctl(struct inode *inode,
 			goto done_unlock;
 
 		case STOP_ARRAY:
-			if (!(err = do_md_stop (mddev, 0)))
+			if (inode->i_bdev->bd_openers > 1)
+				err = -EBUSY;
+			else if (!(err = do_md_stop (mddev, 0)))
 				mddev = NULL;
 			goto done_unlock;
 
 		case STOP_ARRAY_RO:
-			err = do_md_stop (mddev, 1);
+			if (inode->i_bdev->bd_openers > 1)
+				err = -EBUSY;
+			else
+				err = do_md_stop (mddev, 1);
 			goto done_unlock;
 
 	/*
@@ -3775,7 +3780,7 @@ void md_do_recovery(void *data)
 	mdp_disk_t *spare;
 	struct md_list_head *tmp;
 
-	printk(KERN_INFO "md: recovery thread got woken up ...\n");
+	dprintk(KERN_INFO "md: recovery thread got woken up ...\n");
 
 restart:
 	down_read(&all_mddevs_sem);
@@ -3857,7 +3862,7 @@ restart:
 		goto restart;
 	}
 	up_read(&all_mddevs_sem);
-	printk(KERN_INFO "md: recovery thread finished ...\n");
+	dprintk(KERN_INFO "md: recovery thread finished ...\n");
 
 }
 
diff -urNp linux-9020/drivers/md/raid1.c linux-9030/drivers/md/raid1.c
--- linux-9020/drivers/md/raid1.c
+++ linux-9030/drivers/md/raid1.c
@@ -325,18 +325,22 @@ static int raid1_map (mddev_t *mddev, kd
 {
 	raid1_conf_t *conf = mddev_to_conf(mddev);
 	int i, disks = MD_SB_DISKS;
+	unsigned long flags;
 
 	/*
 	 * Later we do read balancing on the read side 
 	 * now we use the first available disk.
 	 */
 
+	md_spin_lock_irqsave(&conf->device_lock, flags);
 	for (i = 0; i < disks; i++) {
 		if (conf->mirrors[i].operational) {
 			*rdev = conf->mirrors[i].dev;
+			md_spin_unlock_irqrestore(&conf->device_lock, flags);
 			return (0);
 		}
 	}
+	md_spin_unlock_irqrestore(&conf->device_lock, flags);
 
 	printk (KERN_ERR "raid1_map(): huh, no more operational devices?\n");
 	return (-1);
@@ -581,6 +585,7 @@ static int raid1_make_request (mddev_t *
 	int disks = MD_SB_DISKS;
 	int i, sum_bhs = 0;
 	struct mirror_info *mirror;
+	kdev_t dev;
 
 	if (!buffer_locked(bh))
 		BUG();
@@ -624,13 +629,16 @@ static int raid1_make_request (mddev_t *
 		/*
 		 * read balancing logic:
 		 */
+		spin_lock_irq(&conf->device_lock);
 		mirror = conf->mirrors + raid1_read_balance(conf, bh);
+		dev = mirror->dev;
+		spin_unlock_irq(&conf->device_lock);
 
 		bh_req = &r1_bh->bh_req;
 		memcpy(bh_req, bh, sizeof(*bh));
 		bh_req->b_blocknr = bh->b_rsector;
-		bh_req->b_dev = mirror->dev;
-		bh_req->b_rdev = mirror->dev;
+		bh_req->b_dev = dev;
+		bh_req->b_rdev = dev;
 	/*	bh_req->b_rsector = bh->n_rsector; */
 		bh_req->b_end_io = raid1_end_request;
 		bh_req->b_private = r1_bh;
@@ -643,6 +651,7 @@ static int raid1_make_request (mddev_t *
 	 */
 
 	bhl = raid1_alloc_bh(conf, conf->raid_disks);
+	spin_lock_irq(&conf->device_lock);
 	for (i = 0; i < disks; i++) {
 		struct buffer_head *mbh;
 		if (!conf->mirrors[i].operational) 
@@ -691,6 +700,7 @@ static int raid1_make_request (mddev_t *
 		r1_bh->mirror_bh_list = mbh;
 		sum_bhs++;
 	}
+	spin_unlock_irq(&conf->device_lock);
 	if (bhl) raid1_free_bh(conf,bhl);
 	if (!sum_bhs) {
 		/* Gag - all mirrors non-operational.. */
@@ -760,6 +770,8 @@ static void mark_disk_bad (mddev_t *mdde
 	mark_disk_inactive(sb->disks+mirror->number);
 	if (!mirror->write_only)
 		sb->active_disks--;
+	else
+		sb->spare_disks--;
 	sb->working_disks--;
 	sb->failed_disks++;
 	mddev->sb_dirty = 1;
@@ -776,6 +788,7 @@ static int raid1_error (mddev_t *mddev, 
 	struct mirror_info * mirrors = conf->mirrors;
 	int disks = MD_SB_DISKS;
 	int i;
+	unsigned long flags;
 
 	/* Find the drive.
 	 * If it is not operational, then we have already marked it as dead
@@ -797,7 +810,9 @@ static int raid1_error (mddev_t *mddev, 
 
 		return 1;
 	}
+	md_spin_lock_irqsave(&conf->device_lock, flags);
 	mark_disk_bad(mddev, i);
+	md_spin_unlock_irqrestore(&conf->device_lock, flags);
 	return 0;
 }
 
@@ -865,7 +880,6 @@ static int raid1_diskop(mddev_t *mddev, 
 	mdp_disk_t *failed_desc, *spare_desc, *added_desc;
 	mdk_rdev_t *spare_rdev, *failed_rdev;
 
-	print_raid1_conf(conf);
 
 	switch (state) {
 	case DISKOP_SPARE_ACTIVE:
@@ -876,6 +890,10 @@ static int raid1_diskop(mddev_t *mddev, 
 
 	md_spin_lock_irq(&conf->device_lock);
 	/*
+	 * Need the conf lock when printing out state else we get BUG()s
+	 */
+	print_raid1_conf(conf);
+	/*
 	 * find the disk ...
 	 */
 	switch (state) {
@@ -1125,12 +1143,12 @@ static int raid1_diskop(mddev_t *mddev, 
 		goto abort;
 	}
 abort:
+	print_raid1_conf(conf);
 	md_spin_unlock_irq(&conf->device_lock);
 	if (state == DISKOP_SPARE_ACTIVE || state == DISKOP_SPARE_INACTIVE)
 		/* should move to "END_REBUILD" when such exists */
 		raid1_shrink_buffers(conf);
 
-	print_raid1_conf(conf);
 	return err;
 }
 
@@ -1189,6 +1207,7 @@ static void raid1d (void *data)
 				
 				conf = mddev_to_conf(mddev);
 				bhl = raid1_alloc_bh(conf, conf->raid_disks); /* don't really need this many */
+				spin_lock_irq(&conf->device_lock);
 				for (i = 0; i < disks ; i++) {
 					if (!conf->mirrors[i].operational)
 						continue;
@@ -1231,6 +1250,7 @@ static void raid1d (void *data)
 
 					sum_bhs++;
 				}
+				spin_unlock_irq(&conf->device_lock);
 				md_atomic_set(&r1_bh->remaining, sum_bhs);
 				if (bhl) raid1_free_bh(conf, bhl);
 				mbh = r1_bh->mirror_bh_list;
@@ -1366,6 +1386,7 @@ static int raid1_sync_request (mddev_t *
 	int disk;
 	int block_nr;
 	int buffs;
+	kdev_t dev;
 
 	if (!sector_nr) {
 		/* we want enough buffers to hold twice the window of 128*/
@@ -1419,6 +1440,7 @@ static int raid1_sync_request (mddev_t *
 	 * could dedicate one to rebuild and others to
 	 * service read requests ..
 	 */
+	spin_lock_irq(&conf->device_lock);
 	disk = conf->last_used;
 	/* make sure disk is operational */
 	while (!conf->mirrors[disk].operational) {
@@ -1430,6 +1452,8 @@ static int raid1_sync_request (mddev_t *
 	conf->last_used = disk;
 	
 	mirror = conf->mirrors+conf->last_used;
+	dev = mirror->dev;
+	spin_unlock_irq(&conf->device_lock);
 	
 	r1_bh = raid1_alloc_buf (conf);
 	r1_bh->master_bh = NULL;
@@ -1440,14 +1464,14 @@ static int raid1_sync_request (mddev_t *
 	block_nr = sector_nr;
 	bsize = 512;
 	while (!(block_nr & 1) && bsize < PAGE_SIZE
-			&& (block_nr+2)*(bsize>>9) < (mddev->sb->size *2)) {
+			&& (block_nr+2)*(bsize>>9) <= (mddev->sb->size * 2)) {
 		block_nr >>= 1;
 		bsize <<= 1;
 	}
 	bh->b_size = bsize;
 	bh->b_list = BUF_LOCKED;
-	bh->b_dev = mirror->dev;
-	bh->b_rdev = mirror->dev;
+	bh->b_dev = dev;
+	bh->b_rdev = dev;
 	bh->b_state = (1<<BH_Req) | (1<<BH_Mapped) | (1<<BH_Lock);
 	if (!bh->b_page)
 		BUG();
diff -urNp linux-9020/drivers/net/wireless_old/orinoco.c linux-9030/drivers/net/wireless_old/orinoco.c
--- linux-9020/drivers/net/wireless_old/orinoco.c
+++ linux-9030/drivers/net/wireless_old/orinoco.c
@@ -1157,6 +1157,12 @@ static void __dldwd_ev_rx(dldwd_priv_t *
 		/* These indicate a SNAP within 802.2 LLC within
 		   802.11 frame which we'll need to de-encapsulate to
 		   the original EthernetII frame. */
+		   
+		if (length < ENCAPS_OVERHEAD) {
+			stats->rx_length_errors++;
+			stats->rx_dropped++;
+			goto drop;
+		}		 
 
 		/* Remove SNAP header, reconstruct EthernetII frame */
 		data_len = length - ENCAPS_OVERHEAD;
diff -urNp linux-9020/drivers/parport/parport_pc.c linux-9030/drivers/parport/parport_pc.c
--- linux-9020/drivers/parport/parport_pc.c
+++ linux-9030/drivers/parport/parport_pc.c
@@ -3022,11 +3022,12 @@ int init_module(void)
 	/* Work out how many ports we have, then get parport_share to parse
 	   the irq values. */
 	unsigned int i;
-	int ret;
+
 	for (i = 0; i < PARPORT_PC_MAX_PORTS && io[i]; i++);
 	if (i) {
-		if (parport_parse_irqs(i, irq, irqval)) return 1;
-		if (parport_parse_dmas(i, dma, dmaval)) return 1;
+		if (parport_parse_irqs(i, irq, irqval) ||
+		    parport_parse_dmas(i, dma, dmaval))
+			return -EINVAL;
 	}
 	else {
 		/* The user can make us use any IRQs or DMAs we find. */
@@ -3059,11 +3060,13 @@ int init_module(void)
 			}
 	}
 
-	ret = !parport_pc_init (io, io_hi, irqval, dmaval);
-	if (ret && registered_parport)
-		pci_unregister_driver (&parport_pc_pci_driver);
+	if (parport_pc_init(io, io_hi, irqval, dmaval) <= 0) {
+		if (registered_parport)
+			pci_unregister_driver(&parport_pc_pci_driver);
+		return -ENODEV;
+	}
 
-	return ret;
+	return 0;
 }
 
 void cleanup_module(void)
diff -urNp linux-9020/drivers/pci/pci.c linux-9030/drivers/pci/pci.c
--- linux-9020/drivers/pci/pci.c
+++ linux-9030/drivers/pci/pci.c
@@ -1030,13 +1030,13 @@ pdev_set_mwi(struct pci_dev *dev)
 	pci_read_config_byte(dev, PCI_CACHE_LINE_SIZE, &cache_size);
 	cache_size <<= 2;
 	if (cache_size != SMP_CACHE_BYTES) {
-		printk(KERN_WARNING "PCI: %s PCI cache line size set incorrectly (%i bytes) by BIOS/FW.\n",
+		printk(KERN_DEBUG "PCI: %s PCI cache line size set incorrectly (%i bytes) by BIOS/FW.\n",
 		       dev->slot_name, cache_size);
 		if (cache_size > SMP_CACHE_BYTES) {
-			printk("PCI: %s cache line size too large - expecting %i.\n", dev->slot_name, SMP_CACHE_BYTES);
+			printk(KERN_DEBUG "PCI: %s cache line size too large - expecting %i.\n", dev->slot_name, SMP_CACHE_BYTES);
 			rc = -EINVAL;
 		} else {
-			printk("PCI: %s PCI cache line size corrected to %i.\n", dev->slot_name, SMP_CACHE_BYTES);
+			printk(KERN_DEBUG "PCI: %s PCI cache line size corrected to %i.\n", dev->slot_name, SMP_CACHE_BYTES);
 			pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE,
 					      SMP_CACHE_BYTES >> 2);
 		}
diff -urNp linux-9020/drivers/pcmcia/yenta.c linux-9030/drivers/pcmcia/yenta.c
--- linux-9020/drivers/pcmcia/yenta.c
+++ linux-9030/drivers/pcmcia/yenta.c
@@ -892,6 +892,9 @@ static int yenta_open(pci_socket_t *sock
 		printk("No cardbus resource!\n");
 		return -1;
 	}
+	
+	if (dev->irq==0)
+		return -1;
 
 	/*
 	 * Ok, start setup.. Map the cardbus registers,
diff -urNp linux-9020/drivers/s390/ccwcache.c linux-9030/drivers/s390/ccwcache.c
--- linux-9020/drivers/s390/ccwcache.c
+++ linux-9030/drivers/s390/ccwcache.c
@@ -146,7 +146,7 @@ ccw_alloc_request ( char *magic, int cpl
 
 	/* determine cache index for the requested size */
 	for (cachind = 0; cachind < CCW_NUMBER_CACHES; cachind ++ )
-	   if ( size_needed < (SMALLEST_SLAB << cachind) ) 
+	   if ( size_needed <= (SMALLEST_SLAB << cachind) ) 
 			break;
 
 	/* Try to fulfill the request from a cache */
diff -urNp linux-9020/drivers/scsi/Makefile linux-9030/drivers/scsi/Makefile
--- linux-9020/drivers/scsi/Makefile
+++ linux-9030/drivers/scsi/Makefile
@@ -99,7 +99,7 @@ obj-$(CONFIG_SCSI_DTC3280)	+= dtc.o
 obj-$(CONFIG_SCSI_NCR53C7xx)	+= 53c7,8xx.o 
 subdir-$(CONFIG_SCSI_SYM53C8XX_2)	+= sym53c8xx_2
 ifeq ($(CONFIG_SCSI_SYM53C8XX_2),y)
-  obj-$(CONFIG_SCSI_SYM53C8XX_2)	+= sym53c8xx_2/sym53c8xx.o
+  obj-$(CONFIG_SCSI_SYM53C8XX_2)	+= sym53c8xx_2/sym53c8xx_2.o
 endif
 obj-$(CONFIG_SCSI_SYM53C8XX)	+= sym53c8xx.o 
 obj-$(CONFIG_SCSI_NCR53C8XX)	+= ncr53c8xx.o 
diff -urNp linux-9020/drivers/scsi/hosts.h linux-9030/drivers/scsi/hosts.h
--- linux-9020/drivers/scsi/hosts.h
+++ linux-9030/drivers/scsi/hosts.h
@@ -36,7 +36,7 @@
 #define SG_ALL 0xff
 
 #define DISABLE_CLUSTERING 0
-#define ENABLE_CLUSTERING 1
+#define ENABLE_CLUSTERING 0
 
 /* The various choices mean:
  * NONE: Self evident.	Host adapter is not capable of scatter-gather.
@@ -473,7 +473,7 @@ struct Scsi_Host
      * alignment to a long boundary.
      */
     unsigned long hostdata[0]  /* Used for storage of host specific stuff */
-        __attribute__ ((aligned (sizeof(unsigned long))));
+        ____cacheline_aligned;
 };
 
 /*
diff -urNp linux-9020/drivers/scsi/ide-scsi.c linux-9030/drivers/scsi/ide-scsi.c
--- linux-9020/drivers/scsi/ide-scsi.c
+++ linux-9030/drivers/scsi/ide-scsi.c
@@ -1,5 +1,5 @@
 /*
- * linux/drivers/scsi/ide-scsi.c	Version 0.93    June 10, 2002
+ * linux/drivers/scsi/ide-scsi.c	Version 0.94    Sept 09, 2003
  *
  * Copyright (C) 1996 - 1999 Gadi Oxman <gadio@netvision.net.il>
  * Copyright (C) 2001 - 2002 Andre Hedrick <andre@linux-ide.org>
@@ -574,6 +574,8 @@ static ide_startstop_t idescsi_issue_pc 
 	/* Request to transfer the entire buffer at once */
 	bcount.all = IDE_MIN(pc->request_transfer, 63 * 1024);
 
+	feature.all = 0;
+	
 	if (drive->using_dma && rq->bh) {
 		if (test_bit(PC_WRITING, &pc->flags))
 			feature.b.dma = !HWIF(drive)->ide_dma_write(drive);
@@ -1140,15 +1142,7 @@ int idescsi_abort (Scsi_Cmnd *cmd)
 
 int idescsi_reset (Scsi_Cmnd *cmd, unsigned int resetflags)
 {
-	ide_drive_t *drive	= idescsi_drives[cmd->target];
-
-	/* We cannot reset the interface holding the lock. We can
-	   drop the lock here however */
-	   
-	spin_unlock(&io_request_lock);
-	(void) ide_do_reset(drive);
-	spin_lock(&io_request_lock);
-	return SCSI_RESET_SUCCESS;
+	return SCSI_RESET_SNOOZE;
 }
 
 int idescsi_bios (Disk *disk, kdev_t dev, int *parm)
diff -urNp linux-9020/drivers/scsi/scsi.c linux-9030/drivers/scsi/scsi.c
--- linux-9020/drivers/scsi/scsi.c
+++ linux-9030/drivers/scsi/scsi.c
@@ -227,8 +227,11 @@ void  scsi_initialize_queue(Scsi_Device 
 }
 
 #ifdef MODULE
-MODULE_PARM(scsi_logging_level, "i");
-MODULE_PARM_DESC(scsi_logging_level, "SCSI logging level; should be zero or nonzero");
+
+#ifdef CONFIG_MODVERSIONS
+#define UNVERSIONED_scsi_logging_level_MODULE_PARM
+static void set_scsi_logging_level(unsigned int *);
+#endif
 
 #else
 
@@ -1113,6 +1116,8 @@ void scsi_done(Scsi_Cmnd * SCpnt)
 	unsigned long flags;
 	int tstatus;
 
+	prefetchw(SCpnt->request.bh);
+
 #if defined(CONFIG_SCSI_DUMP) || defined(CONFIG_SCSI_DUMP_MODULE)
 	if (crashdump_mode())
 		return;
@@ -2684,6 +2689,9 @@ static int __init init_scsi(void)
 	int i;
 
 	printk(KERN_INFO "SCSI subsystem driver " REVISION "\n");
+#ifdef UNVERSIONED_scsi_logging_level_MODULE_PARM
+	set_scsi_logging_level(&scsi_logging_level);
+#endif
 
         if( scsi_init_minimal_dma_pool() != 0 )
         {
@@ -2930,6 +2938,25 @@ scsi_reset_provider(Scsi_Device *dev, in
 }
 
 /*
+ * The following should be the final set of source code in this source file.
+ */
+#ifdef MODULE
+
+#ifdef UNVERSIONED_scsi_logging_level_MODULE_PARM
+#undef scsi_logging_level
+unsigned int scsi_logging_level;
+static void set_scsi_logging_level(unsigned int *p)
+{
+	*p = scsi_logging_level;
+}
+#endif
+
+MODULE_PARM(scsi_logging_level, "i");
+MODULE_PARM_DESC(scsi_logging_level, "SCSI logging level; should be zero or nonzero");
+
+#endif /* MODULE */
+
+/*
  * Overrides for Emacs so that we follow Linus's tabbing style.
  * Emacs will notice this stuff at the end of the file and automatically
  * adjust the settings for this buffer only.  This must remain at the end
diff -urNp linux-9020/drivers/scsi/scsi.h linux-9030/drivers/scsi/scsi.h
--- linux-9020/drivers/scsi/scsi.h
+++ linux-9030/drivers/scsi/scsi.h
@@ -677,8 +677,8 @@ struct scsi_request {
 	unsigned char sr_cmnd[MAX_COMMAND_SIZE];
 	void (*sr_done) (struct scsi_cmnd *);	/* Mid-level done function */
 	int sr_timeout_per_command;
-	unsigned short sr_use_sg;	/* Number of pieces of scatter-gather */
-	unsigned short sr_sglist_len;	/* size of malloc'd scatter-gather list */
+	unsigned int sr_use_sg;	/* Number of pieces of scatter-gather */
+	unsigned int sr_sglist_len;	/* size of malloc'd scatter-gather list */
 	unsigned sr_underflow;	/* Return error if less than
 				   this amount is transferred */
 };
@@ -699,8 +699,8 @@ struct scsi_cmnd {
 	 * struct private is a way of marking it in a sort of C++ type of way.
 	 */
 	struct Scsi_Host *host;
-	unsigned short state;
-	unsigned short owner;
+	unsigned int state;
+	unsigned int owner;
 	Scsi_Device *device;
 	Scsi_Request *sc_request;
 	struct scsi_cmnd *next;
@@ -759,11 +759,11 @@ struct scsi_cmnd {
 
 	/* These elements define the operation we ultimately want to perform */
 	unsigned char data_cmnd[MAX_COMMAND_SIZE];
-	unsigned short old_use_sg;	/* We save  use_sg here when requesting
+	unsigned int old_use_sg;	/* We save  use_sg here when requesting
 					 * sense info */
-	unsigned short use_sg;	/* Number of pieces of scatter-gather */
-	unsigned short sglist_len;	/* size of malloc'd scatter-gather list */
-	unsigned short abort_reason;	/* If the mid-level code requests an
+	unsigned int use_sg;	/* Number of pieces of scatter-gather */
+	unsigned int sglist_len;	/* size of malloc'd scatter-gather list */
+	unsigned int abort_reason;	/* If the mid-level code requests an
 					 * abort, this is the reason. */
 	unsigned bufflen;	/* Size of data buffer */
 	void *buffer;		/* Data buffer */
diff -urNp linux-9020/drivers/scsi/scsi_dma.c linux-9030/drivers/scsi/scsi_dma.c
--- linux-9020/drivers/scsi/scsi_dma.c
+++ linux-9030/drivers/scsi/scsi_dma.c
@@ -69,6 +69,9 @@ static unsigned char **dma_malloc_pages 
  *              to allocate more memory in order to be able to write the
  *              data to disk, you would wedge the system.
  */
+ 
+static int lowest_known_hole;
+
 void *scsi_malloc(unsigned int len)
 {
 	unsigned int nbits, mask;
@@ -82,8 +85,11 @@ void *scsi_malloc(unsigned int len)
 	mask = (1 << nbits) - 1;
 
 	spin_lock_irqsave(&allocator_request_lock, flags);
+	
+	while ((lowest_known_hole < dma_sectors) && (dma_malloc_freelist[lowest_known_hole] == (1<<SECTORS_PER_PAGE)-1))
+		lowest_known_hole++;
 
-	for (i = 0; i < dma_sectors / SECTORS_PER_PAGE; i++)
+	for (i = lowest_known_hole; i < dma_sectors / SECTORS_PER_PAGE; i++)
 		for (j = 0; j <= SECTORS_PER_PAGE - nbits; j++) {
 			if ((dma_malloc_freelist[i] & (mask << j)) == 0) {
 				dma_malloc_freelist[i] |= (mask << j);
@@ -160,6 +166,8 @@ int scsi_free(void *obj, unsigned int le
 			}
 			scsi_dma_free_sectors += nbits;
 			dma_malloc_freelist[page] &= ~(mask << sector);
+			if (page < lowest_known_hole)
+				lowest_known_hole = page;
 			spin_unlock_irqrestore(&allocator_request_lock, flags);
 			return 0;
 		}
@@ -201,6 +209,9 @@ void scsi_resize_dma_pool(void)
 
 	spin_lock_irqsave(&allocator_request_lock, flags);
 
+	/* we're doing major reorgs; reset the lowest free cache */	
+	lowest_known_hole = 0;
+
 	if (!scsi_hostlist) {
 		/*
 		 * Free up the DMA pool.
@@ -287,7 +298,7 @@ void scsi_resize_dma_pool(void)
 #endif
 
 	/* limit DMA memory to 32MB: */
-	new_dma_sectors = (new_dma_sectors + 15) & 0xfff0;
+	new_dma_sectors = min(new_dma_sectors + 15, 0xffffU) & 0xfff0;
 
 	/*
 	 * We never shrink the buffers - this leads to
@@ -348,7 +359,7 @@ void scsi_resize_dma_pool(void)
 			if (new_dma_sectors < (8 * SECTORS_PER_PAGE))
 				break;	/* pretty well hopeless ... */
 			new_dma_sectors = (new_dma_sectors * 3) / 4;
-			new_dma_sectors = (new_dma_sectors + 15) & 0xfff0;
+			new_dma_sectors = min(new_dma_sectors + 15, 0xffffU) & 0xfff0;
 			if (new_dma_sectors <= dma_sectors)
 				break;	/* stick with what we have got */
 		} else
diff -urNp linux-9020/drivers/scsi/scsi_lib.c linux-9030/drivers/scsi/scsi_lib.c
--- linux-9020/drivers/scsi/scsi_lib.c
+++ linux-9030/drivers/scsi/scsi_lib.c
@@ -422,6 +422,7 @@ static Scsi_Cmnd *__scsi_end_request(Scs
 			kdevname(req->rq_dev), req->sector);
 	do {
 		if ((bh = req->bh) != NULL) {
+			prefetch(bh->b_reqnext);
 			nsect = bh->b_size >> 9;
 			blk_finished_io(nsect);
 			req->bh = bh->b_reqnext;
@@ -450,6 +451,13 @@ static Scsi_Cmnd *__scsi_end_request(Scs
 	 */
 	if (req->bh) {
 		/*
+		 * Recount segments whether we are immediately going to
+		 * requeue the command or not, other code might requeue
+		 * it later and since we changed the segment count up above,
+		 * we need it updated.
+		 */
+		recount_segments(SCpnt);
+		/*
 		 * Bleah.  Leftovers again.  Stick the leftovers in
 		 * the front of the queue, and goose the queue again.
 		 */
@@ -1028,15 +1036,6 @@ void scsi_request_fn(request_queue_t * q
 			 */
 			if( req->special != NULL ) {
 				SCpnt = (Scsi_Cmnd *) req->special;
-				/*
-				 * We need to recount the number of
-				 * scatter-gather segments here - the
-				 * normal case code assumes this to be
-				 * correct, as it would be a performance
-				 * lose to always recount.  Handling
-				 * errors is always unusual, of course.
-				 */
-				recount_segments(SCpnt);
 			} else {
 				SCpnt = scsi_allocate_device(SDpnt, FALSE, FALSE);
 			}
diff -urNp linux-9020/drivers/scsi/sg.c linux-9030/drivers/scsi/sg.c
--- linux-9020/drivers/scsi/sg.c
+++ linux-9030/drivers/scsi/sg.c
@@ -1260,7 +1260,6 @@ static void sg_cmd_done_bh(Scsi_Cmnd * S
     SRpnt->sr_request.rq_dev = MKDEV(0, 0);  /* "sg" _disowns_ request blk */
 
     srp->my_cmdp = NULL;
-    srp->done = 1;
     read_unlock(&sg_dev_arr_lock);
 
     SCSI_LOG_TIMEOUT(4, printk("sg...bh: dev=%d, pack_id=%d, res=0x%x\n",
@@ -1323,8 +1322,9 @@ static void sg_cmd_done_bh(Scsi_Cmnd * S
     }
     if (sfp && srp) {
 	/* Now wake up any sg_read() that is waiting for this packet. */
-	wake_up_interruptible(&sfp->read_wait);
 	kill_fasync(&sfp->async_qp, SIGPOLL, POLL_IN);
+	srp->done = 1;
+	wake_up_interruptible(&sfp->read_wait);
     }
 }
 
diff -urNp linux-9020/drivers/sound/opl3sa2.c linux-9030/drivers/sound/opl3sa2.c
--- linux-9020/drivers/sound/opl3sa2.c
+++ linux-9030/drivers/sound/opl3sa2.c
@@ -57,6 +57,7 @@
  *                         (Jan 7, 2001)
  * Zwane Mwaikambo	   Added PM support. (Dec 4 2001)
  * Zwane Mwaikambo	   Code, data structure cleanups. (Feb 15 2002)
+ * Gerald Teschl	   Fixed ISA PnP activate. (Jun 02 2002)
  *
  */
 
@@ -881,10 +882,24 @@ static int __init opl3sa2_isapnp_probe(s
 	}
 	else {
 		if(dev->activate(dev) < 0) {
-			printk(KERN_WARNING PFX "ISA PnP activate failed\n");
-			opl3sa2_state[card].activated = 0;
-			return -ENODEV;
+			/*
+			 * isapnp.c disallows dma=0 but some opl3sa2 cards need it.
+			 * So we set dma by hand and try again
+			 */
+			if (dma < 0 || dma > 7)
+				dma= 0;
+			if (dma2 < 0 || dma2 >7)
+				dma2= 1;
+			isapnp_resource_change(&dev->dma_resource[0], dma, 1);
+			isapnp_resource_change(&dev->dma_resource[1], dma2, 1);
 		}
+		if(!dev->active)
+			if (dev->activate(dev) < 0) {
+				printk(KERN_WARNING PFX "ISA PnP activate failed.\n");
+				opl3sa2_state[card].activated = 0;
+				return -ENODEV;
+			}
+		opl3sa2_state[card].activated = 1;
 
 		printk(KERN_DEBUG
 		       PFX "Activated ISA PnP card %d (active=%d)\n",
diff -urNp linux-9020/drivers/sound/sb_audio.c linux-9030/drivers/sound/sb_audio.c
--- linux-9020/drivers/sound/sb_audio.c
+++ linux-9030/drivers/sound/sb_audio.c
@@ -879,7 +879,7 @@ sb16_copy_from_user(int dev,
 			c -= locallen; p += locallen;
 		}
 		/* used = ( samples * 16 bits size ) */
-		*used = len << 1;
+		*used = (max_in > (max_out << 1)) ? (max_out << 1) : max_in;
 		/* returned = ( samples * 8 bits size ) */
 		*returned = len;
 	}
diff -urNp linux-9020/drivers/sound/via82cxxx_audio.c linux-9030/drivers/sound/via82cxxx_audio.c
--- linux-9020/drivers/sound/via82cxxx_audio.c
+++ linux-9030/drivers/sound/via82cxxx_audio.c
@@ -3,7 +3,7 @@
  * Copyright 1999,2000 Jeff Garzik
  *
  * Updated to support the VIA 8233/8235 audio subsystem
- * Alan Cox <alan@redhat.com> (C) Copyright 2002 Red Hat Inc
+ * Alan Cox <alan@redhat.com> (C) Copyright 2002, 2003 Red Hat Inc
  *
  * Distributed under the GNU GENERAL PUBLIC LICENSE (GPL) Version 2.
  * See the "COPYING" file distributed with this software for more info.
@@ -15,7 +15,7 @@
  */
 
 
-#define VIA_VERSION	"1.9.1-ac2"
+#define VIA_VERSION	"1.9.1-ac2(RH1)"
 
 
 #include <linux/config.h>
@@ -85,10 +85,13 @@
 #define VIA_DEFAULT_FRAG_TIME		20
 #define VIA_DEFAULT_BUFFER_TIME		500
 
+/* the hardware has a 256 fragment limit */
+#define VIA_MIN_FRAG_NUMBER		2
+#define VIA_MAX_FRAG_NUMBER		128
+
 #define VIA_MAX_FRAG_SIZE		PAGE_SIZE
-#define VIA_MIN_FRAG_SIZE		64
+#define VIA_MIN_FRAG_SIZE		(VIA_MAX_BUFFER_DMA_PAGES * PAGE_SIZE / VIA_MAX_FRAG_NUMBER)
 
-#define VIA_MIN_FRAG_NUMBER		2
 
 /* 82C686 function 5 (audio codec) PCI configuration registers */
 #define VIA_ACLINK_STATUS	0x40
@@ -1302,6 +1305,8 @@ static int via_chan_set_buffering (struc
 
 	if (chan->frag_number < VIA_MIN_FRAG_NUMBER)
                 chan->frag_number = VIA_MIN_FRAG_NUMBER;
+        if (chan->frag_number > VIA_MAX_FRAG_NUMBER)
+        	chan->frag_number = VIA_MAX_FRAG_NUMBER;
 
 	if ((chan->frag_number * chan->frag_size) / PAGE_SIZE > VIA_MAX_BUFFER_DMA_PAGES)
 		chan->frag_number = (VIA_MAX_BUFFER_DMA_PAGES * PAGE_SIZE) / chan->frag_size;
@@ -2562,7 +2567,10 @@ handle_one_block:
 		goto handle_one_block;
 
 out:
-	return userbuf - orig_userbuf;
+	if (userbuf - orig_userbuf)
+		return userbuf - orig_userbuf;
+	else
+		return ret;
 }
 
 
diff -urNp linux-9020/drivers/usb/pwc-if.c linux-9030/drivers/usb/pwc-if.c
--- linux-9020/drivers/usb/pwc-if.c
+++ linux-9030/drivers/usb/pwc-if.c
@@ -1517,8 +1517,8 @@ static int pwc_video_ioctl(struct video_
 		                	set_current_state(TASK_RUNNING);
 		                	return -ERESTARTSYS;
 	        	        }
-		                set_current_state(TASK_INTERRUPTIBLE);
 	                	schedule();
+		                set_current_state(TASK_INTERRUPTIBLE);
 			}
 			remove_wait_queue(&pdev->frameq, &wait);
 			set_current_state(TASK_RUNNING);
diff -urNp linux-9020/fs/attr.c linux-9030/fs/attr.c
--- linux-9020/fs/attr.c
+++ linux-9030/fs/attr.c
@@ -33,7 +33,8 @@ int inode_change_ok(struct inode *inode,
 
 	/* Make sure caller can chgrp. */
 	if ((ia_valid & ATTR_GID) &&
-	    (!in_group_p(attr->ia_gid) && attr->ia_gid != inode->i_gid) &&
+	    (current->fsuid != inode->i_uid ||
+	     (!in_group_p(attr->ia_gid) && attr->ia_gid != inode->i_gid)) &&
 	    !capable(CAP_CHOWN))
 		goto error;
 
diff -urNp linux-9020/fs/block_dev.c linux-9030/fs/block_dev.c
--- linux-9020/fs/block_dev.c
+++ linux-9030/fs/block_dev.c
@@ -430,18 +430,27 @@ static struct {
 	struct block_device_operations *bdops;
 } blkdevs[MAX_BLKDEV];
 
-int get_blkdev_list(char * p)
+int get_blkdev_list(char *p, int avail)
 {
-	int i;
-	int len;
+	int i, len;
+
+	len = snprintf(p, avail, "\nBlock devices:\n");
+	if (len >= avail)
+		return avail;
+	avail -= len;
+	p += len;
 
-	len = sprintf(p, "\nBlock devices:\n");
 	for (i = 0; i < MAX_BLKDEV ; i++) {
 		if (blkdevs[i].bdops) {
-			len += sprintf(p+len, "%3d %s\n", i, blkdevs[i].name);
+			len = snprintf(p, avail,
+				"%3d %s\n", i, blkdevs[i].name);
+			if (len >= avail)
+				break;
+			avail -= len;
+			p += len;
 		}
 	}
-	return len;
+	return avail;
 }
 
 /*
diff -urNp linux-9020/fs/buffer.c linux-9030/fs/buffer.c
--- linux-9020/fs/buffer.c
+++ linux-9030/fs/buffer.c
@@ -276,6 +276,10 @@ static int write_some_buffers(kdev_t dev
 
 			spin_unlock(&lru_list_lock);
 			write_locked_buffers(array, count);
+			if (unlikely(current->need_resched)) {
+				__set_current_state(TASK_RUNNING);
+				schedule();
+			}
 			return -EAGAIN;
 		}
 		unlock_buffer(bh);
@@ -887,8 +891,11 @@ void end_buffer_io_async(struct buffer_h
 	/* This is a temporary buffer used for page I/O. */
 	page = bh->b_page;
 
-	if (!uptodate)
+	if (!uptodate) {
 		SetPageError(page);
+		if (PageSwapCache(page))
+			SetPageDirty(page);
+	}
 
 	/*
 	 * Be _very_ careful from here on. Bad things can happen if
@@ -1343,10 +1350,11 @@ void set_bh_page (struct buffer_head *bh
 	if (offset >= PAGE_SIZE)
 		BUG();
 
-	/*
-	 * page_address will return NULL anyways for highmem pages
-	 */
-	bh->b_data = page_address(page) + offset;
+	if (PageHighMem(page)) {
+		bh->b_data = (char *)offset;
+	} else {
+		bh->b_data = page_address(page) + offset;
+	}
 	bh->b_page = page;
 }
 EXPORT_SYMBOL(set_bh_page);
@@ -2116,6 +2124,7 @@ int block_commit_write(struct page *page
 	kunmap(page);
 	return 0;
 }
+EXPORT_SYMBOL(block_commit_write);
 
 int generic_commit_write(struct file *file, struct page *page,
 		unsigned from, unsigned to)
diff -urNp linux-9020/fs/coda/upcall.c linux-9030/fs/coda/upcall.c
--- linux-9020/fs/coda/upcall.c
+++ linux-9030/fs/coda/upcall.c
@@ -543,6 +543,11 @@ int venus_pioctl(struct super_block *sb,
 		goto exit;
         }
 
+        if (data->vi.out_size > VC_MAXDATASIZE) {
+		error = -EINVAL;
+		goto exit;
+	}
+
         inp->coda_ioctl.VFid = *fid;
     
         /* the cmd field was mutated by increasing its size field to
@@ -571,26 +576,37 @@ int venus_pioctl(struct super_block *sb,
 		       error, coda_f2s(fid));
 		goto exit; 
 	}
-        
-	/* Copy out the OUT buffer. */
+
+	if ((unsigned long)outp->coda_ioctl.data > outsize) {
+                CDEBUG(D_FILE, "too large coda_ioctl.data %lu\n",
+		       (unsigned long)outp->coda_ioctl.data);
+		error = -EINVAL;
+		goto exit;
+	}
+
+	if (outsize - (unsigned long)outp->coda_ioctl.data < outp->coda_ioctl.len) {
+                CDEBUG(D_FILE, "reply size %d < reply len %ld\n", outsize,
+		       (long)outp->coda_ioctl.data + outp->coda_ioctl.len);
+		error = -EINVAL;
+		goto exit;
+	}
+
         if (outp->coda_ioctl.len > data->vi.out_size) {
-                CDEBUG(D_FILE, "return len %d <= request len %d\n",
-                      outp->coda_ioctl.len, 
-                      data->vi.out_size);
+                CDEBUG(D_FILE, "return len %d > request len %d\n",
+		       outp->coda_ioctl.len, data->vi.out_size);
 		error = -EINVAL;
-        } else {
-		error = verify_area(VERIFY_WRITE, data->vi.out, 
-                                    data->vi.out_size);
-		if ( error ) goto exit;
-
-		if (copy_to_user(data->vi.out, 
-				 (char *)outp + (long)outp->coda_ioctl.data, 
-				 data->vi.out_size)) {
-			error = -EINVAL;
-			goto exit;
-		}
+		goto exit;
         }
 
+	/* Copy out the OUT buffer. */
+	error = verify_area(VERIFY_WRITE, data->vi.out, outp->coda_ioctl.len);
+	if ( error ) goto exit;
+
+	if (copy_to_user(data->vi.out, 
+			 (char *)outp + (unsigned long)outp->coda_ioctl.data, 
+			 outp->coda_ioctl.len)) {
+	    error = -EINVAL;
+	}
  exit:
 	CODA_FREE(inp, insize);
 	return error;
diff -urNp linux-9020/fs/devices.c linux-9030/fs/devices.c
--- linux-9020/fs/devices.c
+++ linux-9030/fs/devices.c
@@ -38,23 +38,33 @@ struct device_struct {
 static rwlock_t chrdevs_lock = RW_LOCK_UNLOCKED;
 static struct device_struct chrdevs[MAX_CHRDEV];
 
-extern int get_blkdev_list(char *);
+extern int get_blkdev_list(char *, int);
 
-int get_device_list(char * page)
+int get_device_list(char *page)
 {
-	int i;
-	int len;
+	int i, len, avail;
+
+	avail = PAGE_SIZE;
+
+	len = snprintf(page, avail, "Character devices:\n");
+	avail -= len;
+	page += len;
 
-	len = sprintf(page, "Character devices:\n");
 	read_lock(&chrdevs_lock);
 	for (i = 0; i < MAX_CHRDEV ; i++) {
 		if (chrdevs[i].fops) {
-			len += sprintf(page+len, "%3d %s\n", i, chrdevs[i].name);
+			len = snprintf(page, avail,
+				"%3d %s\n", i, chrdevs[i].name);
+			if (len >= avail)
+				break;
+			avail -= len;
+			page += len;
 		}
 	}
 	read_unlock(&chrdevs_lock);
-	len += get_blkdev_list(page+len);
-	return len;
+
+	avail = get_blkdev_list(page, avail);
+	return (int)PAGE_SIZE - avail;
 }
 
 /*
diff -urNp linux-9020/fs/exec.c linux-9030/fs/exec.c
--- linux-9020/fs/exec.c
+++ linux-9030/fs/exec.c
@@ -725,11 +725,28 @@ static inline void flush_old_files(struc
 	write_unlock(&files->file_lock);
 }
 
+void get_task_comm(char *buf, struct task_struct *tsk)
+{
+	/* buf must be at least sizeof(tsk->comm) in size */
+	task_lock(tsk);
+	memcpy(buf, tsk->comm, sizeof(tsk->comm));
+	task_unlock(tsk);
+}
+
+void set_task_comm(struct task_struct *tsk, char *buf)
+{
+	task_lock(tsk);
+	strncpy(tsk->comm, buf, sizeof(tsk->comm));
+	tsk->comm[sizeof(tsk->comm)-1]='\0';
+	task_unlock(tsk);
+}
+
 int flush_old_exec(struct linux_binprm * bprm)
 {
 	char * name;
 	int i, ch, retval;
 	struct files_struct * files;
+	char tcomm[sizeof(current->comm)];
 
 	/*
 	 * Make sure we have private file handles. Ask the
@@ -772,10 +789,11 @@ int flush_old_exec(struct linux_binprm *
 		if (ch == '/')
 			i = 0;
 		else
-			if (i < 15)
-				current->comm[i++] = ch;
+			if (i < (sizeof(tcomm) - 1))
+				tcomm[i++] = ch;
 	}
-	current->comm[i] = '\0';
+	tcomm[i] = '\0';
+	set_task_comm(current, tcomm);
 
 	current->flags &= ~PF_RELOCEXEC;
 #if defined(__i386__)
@@ -1275,10 +1293,21 @@ void format_corename(char *corename, con
 static void zap_threads (struct mm_struct *mm)
 {
 	struct task_struct *g, *p;
+	struct task_struct *tsk = current;
+	struct completion *vfork_done = tsk->vfork_done;
+
+	/*
+	 * Make sure nobody is waiting for us to release the VM,
+	 * otherwise we can deadlock when we wait on each other
+	 */
+	if (vfork_done) {
+		tsk->vfork_done = NULL;
+		complete(vfork_done);
+	}
 
 	read_lock(&tasklist_lock);
 	do_each_thread(g,p)
-		if (mm == p->mm && p != current) {
+		if (mm == p->mm && p != tsk) {
 			force_sig_specific(SIGKILL, p);
 			mm->core_waiters++;
 		}
diff -urNp linux-9020/fs/ext2/dir.c linux-9030/fs/ext2/dir.c
--- linux-9020/fs/ext2/dir.c
+++ linux-9030/fs/ext2/dir.c
@@ -328,6 +328,12 @@ struct ext2_dir_entry_2 * ext2_find_entr
 			de = (ext2_dirent *) kaddr;
 			kaddr += PAGE_CACHE_SIZE - reclen;
 			while ((char *) de <= kaddr) {
+				if (de->rec_len == 0) {
+					ext2_error(dir->i_sb, __FUNCTION__,
+						"zero-length directory entry");
+					ext2_put_page(page);
+					goto out;
+				}
 				if (ext2_match (namelen, name, de))
 					goto found;
 				de = ext2_next_entry(de);
@@ -336,7 +342,16 @@ struct ext2_dir_entry_2 * ext2_find_entr
 		}
 		if (++n >= npages)
 			n = 0;
+		/* next page is past the blocks we've got */
+		if (unlikely(n > (dir->i_blocks >> (PAGE_CACHE_SHIFT - 9)))) {
+			ext2_error(dir->i_sb, __FUNCTION__,
+				"dir %lu size %lld exceeds block count %llu",
+				dir->i_ino, dir->i_size,
+				(unsigned long long)dir->i_blocks);
+			goto out;
+		}
 	} while (n != start);
+out:
 	return NULL;
 
 found:
@@ -524,7 +539,8 @@ int ext2_make_empty(struct inode *inode,
 		goto fail;
 
 	base = page_address(page);
-
+	
+	memset(base, 0, chunk_size); 
 	de = (struct ext2_dir_entry_2 *) base;
 	de->name_len = 1;
 	de->rec_len = cpu_to_le16(EXT2_DIR_REC_LEN(1));
diff -urNp linux-9020/fs/ext2/inode.c linux-9030/fs/ext2/inode.c
--- linux-9020/fs/ext2/inode.c
+++ linux-9030/fs/ext2/inode.c
@@ -564,6 +564,7 @@ out:
 	if (err == -EAGAIN)
 		goto changed;
 
+	goal = 0;
 	if (ext2_find_goal(inode, iblock, chain, partial, &goal) < 0)
 		goto changed;
 
diff -urNp linux-9020/fs/ext3/inode.c linux-9030/fs/ext3/inode.c
--- linux-9020/fs/ext3/inode.c
+++ linux-9030/fs/ext3/inode.c
@@ -85,7 +85,7 @@ int ext3_forget(handle_t *handle, int is
 	    (!is_metadata && !ext3_should_journal_data(inode))) {
 		if (bh) {
 			BUFFER_TRACE(bh, "call journal_forget");
-			ext3_journal_forget(handle, bh);
+			return ext3_journal_forget(handle, bh);
 		}
 		return 0;
 	}
@@ -801,6 +801,7 @@ out:
 	if (err == -EAGAIN)
 		goto changed;
 
+	goal = 0;
 	if (ext3_find_goal(inode, iblock, chain, partial, &goal) < 0)
 		goto changed;
 
@@ -1528,37 +1529,53 @@ struct address_space_operations ext3_aop
 };
 
 /*
+ * ext3_block_truncate_page_prepare just grabs a page ready for use by
+ * ext3_block_truncate_page() itself.  We need to do the page grab
+ * before starting a transaction, as the page lock ranks above a
+ * transaction acquire in locking terms.
+ */
+static inline struct page * 
+ext3_block_truncate_page_prepare(struct address_space *mapping, 
+				 loff_t from, unsigned blocksize)
+{
+	unsigned offset = from & (PAGE_CACHE_SIZE-1);
+	unsigned length = offset & (blocksize-1);
+	unsigned long index;
+	struct page *page;
+	
+	if (!length)
+		return NULL;
+	
+	index = from >> PAGE_CACHE_SHIFT;
+	page = find_or_create_page(mapping, index, GFP_NOFS);
+	if (page)
+		return page;
+	return ERR_PTR(-ENOMEM);
+}
+
+
+/*
  * ext3_block_truncate_page() zeroes out a mapping from file offset `from'
  * up to the end of the block which corresponds to `from'.
  * This required during truncate. We need to physically zero the tail end
  * of that block so it doesn't yield old data if the file is later grown.
  */
 static int ext3_block_truncate_page(handle_t *handle,
-		struct address_space *mapping, loff_t from)
+				    struct address_space *mapping, loff_t from,
+				    struct page *page, unsigned blocksize)
 {
 	unsigned long index = from >> PAGE_CACHE_SHIFT;
 	unsigned offset = from & (PAGE_CACHE_SIZE-1);
-	unsigned blocksize, iblock, length, pos;
+	unsigned iblock, length, pos;
 	struct inode *inode = mapping->host;
-	struct page *page;
 	struct buffer_head *bh;
 	int err;
 
-	blocksize = inode->i_sb->s_blocksize;
 	length = offset & (blocksize - 1);
 
-	/* Block boundary? Nothing to do */
-	if (!length)
-		return 0;
-
 	length = blocksize - length;
 	iblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);
 
-	page = grab_cache_page(mapping, index);
-	err = -ENOMEM;
-	if (!page)
-		goto out;
-
 	if (!page->buffers)
 		create_empty_buffers(page, inode->i_dev, blocksize);
 
@@ -1620,7 +1637,6 @@ static int ext3_block_truncate_page(hand
 unlock:
 	UnlockPage(page);
 	page_cache_release(page);
-out:
 	return err;
 }
 
@@ -2007,7 +2023,8 @@ void ext3_truncate(struct inode * inode)
 	int n;
 	long last_block;
 	unsigned blocksize;
-
+	struct page *page;
+	
 	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
 	    S_ISLNK(inode->i_mode)))
 		return;
@@ -2018,17 +2035,23 @@ void ext3_truncate(struct inode * inode)
 
 	ext3_discard_prealloc(inode);
 
-	handle = start_transaction(inode);
-	if (IS_ERR(handle))
-		return;		/* AKPM: return what? */
-
 	blocksize = inode->i_sb->s_blocksize;
 	last_block = (inode->i_size + blocksize-1)
 					>> EXT3_BLOCK_SIZE_BITS(inode->i_sb);
 
-	ext3_block_truncate_page(handle, inode->i_mapping, inode->i_size);
-		
+	page = ext3_block_truncate_page_prepare
+		(inode->i_mapping, inode->i_size, blocksize);
+	if (IS_ERR(page))
+		return;
+	
+	handle = start_transaction(inode);
+	if (IS_ERR(handle))
+		goto out_unlock;
 
+	if (page)
+		ext3_block_truncate_page(handle, inode->i_mapping, 
+					 inode->i_size, page, blocksize);
+		
 	n = ext3_block_to_path(inode, last_block, offsets);
 	if (n == 0)
 		goto out_stop;	/* error */
@@ -2142,6 +2165,14 @@ out_stop:
 		ext3_orphan_del(handle, inode);
 
 	ext3_journal_stop(handle, inode);
+	return;
+	
+out_unlock:
+	if (page) {
+		UnlockPage(page);
+		page_cache_release(page);
+	}
+	return;		/* AKPM: return what? */
 }
 
 /* 
@@ -2300,8 +2331,6 @@ void ext3_read_inode(struct inode * inod
 		inode->u.ext3_i.i_data[block] = iloc.raw_inode->i_block[block];
 	INIT_LIST_HEAD(&inode->u.ext3_i.i_orphan);
 
-	brelse (iloc.bh);
-
 	if (S_ISREG(inode->i_mode)) {
 		inode->i_op = &ext3_file_inode_operations;
 		inode->i_fop = &ext3_file_operations;
@@ -2321,6 +2350,7 @@ void ext3_read_inode(struct inode * inod
 		init_special_inode(inode, inode->i_mode,
 				   le32_to_cpu(iloc.raw_inode->i_block[0]));
 	}
+	brelse (iloc.bh);
 	ext3_set_inode_flags(inode);
 #ifdef CONFIG_EXT3_FS_XATTR
 	init_rwsem(&inode->u.ext3_i.xattr_sem);
diff -urNp linux-9020/fs/ext3/ioctl.c linux-9030/fs/ext3/ioctl.c
--- linux-9020/fs/ext3/ioctl.c
+++ linux-9030/fs/ext3/ioctl.c
@@ -115,13 +115,11 @@ flags_err:
 		if (IS_ERR(handle))
 			return PTR_ERR(handle);
 		err = ext3_reserve_inode_write(handle, inode, &iloc);
-		if (err)
-			return err;
-
-		inode->i_ctime = CURRENT_TIME;
-		inode->i_generation = generation;
-
-		err = ext3_mark_iloc_dirty(handle, inode, &iloc);
+		if (!err) {
+			inode->i_ctime = CURRENT_TIME;
+			inode->i_generation = generation;
+			err = ext3_mark_iloc_dirty(handle, inode, &iloc);
+		}
 		ext3_journal_stop(handle, inode);
 		return err;
 	}
diff -urNp linux-9020/fs/ext3/super.c linux-9030/fs/ext3/super.c
--- linux-9020/fs/ext3/super.c
+++ linux-9030/fs/ext3/super.c
@@ -136,6 +136,32 @@ static int ext3_error_behaviour(struct s
 	return EXT3_ERRORS_CONTINUE;
 }
 
+
+void ext3_journal_abort_handle(const char *caller, 
+			       const char *err_fn,
+			       struct buffer_head *bh,
+			       handle_t *handle,
+			       int err)
+{
+	char nbuf[16];
+	const char *errstr = ext3_decode_error(NULL, err, nbuf);
+	
+	if (bh)
+		BUFFER_TRACE(bh, "abort");
+
+	if (!handle->h_err)
+		handle->h_err = err;
+
+	if (is_handle_aborted(handle))
+		return;
+	
+	printk(KERN_ERR "%s: aborting transaction: %s in %s\n", 
+	       caller, errstr, err_fn);
+
+	journal_abort_handle(handle);
+}
+
+
 /* Deal with the reporting of failure conditions on a filesystem such as
  * inconsistencies detected or read IO failures.
  *
@@ -861,6 +887,12 @@ static void ext3_orphan_cleanup (struct 
 		return;
 	}
 
+	if (is_read_only(sb->s_dev)) {
+		printk(KERN_ERR "EXT3-fs: write access "
+			"unavailable, skipping orphan cleanup.\n");
+		return;
+	}
+
 	if (sb->u.ext3_sb.s_mount_state & EXT3_ERROR_FS) {
 		if (es->s_last_orphan)
 			jbd_debug(1, "Errors on filesystem, "
@@ -1755,6 +1787,19 @@ int ext3_remount (struct super_block * s
 				return -EROFS;
 			}
 			/*
+			 * If we have an unprocessed orphan list hanging
+			 * around from a previously readonly bdev mount,
+			 * require a full umount/remount for now.
+			 */
+			if (es->s_last_orphan) {
+				printk(KERN_WARNING "EXT3-fs: %s: couldn't "
+				       "remount RDWR because of unprocessed "
+				       "orphan inode list.  Please "
+				       "umount/remount instead.\n",
+				       bdevname(sb->s_dev));
+				return -EINVAL;
+			}
+			/*
 			 * Mounting a RDONLY partition read-write, so reread
 			 * and store the current valid flag.  (It may have
 			 * been changed by e2fsck since we originally mounted
diff -urNp linux-9020/fs/inode.c linux-9030/fs/inode.c
--- linux-9020/fs/inode.c
+++ linux-9030/fs/inode.c
@@ -994,7 +994,8 @@ repeat:
  
 struct inode * new_inode(struct super_block *sb)
 {
-	static unsigned long last_ino;
+	/* limit inums to 32 bits to avoid problems with legacy 32-bit apps */
+	static unsigned int last_ino;
 	struct inode * inode;
 
 	spin_lock_prefetch(&inode_lock);
@@ -1097,7 +1098,8 @@ static inline unsigned long hash(struct 
  
 ino_t iunique(struct super_block *sb, ino_t max_reserved)
 {
-	static ino_t counter = 0;
+	/* limit inums to 32 bits to avoid problems with legacy 32-bit apps */
+	static unsigned int counter;
 	struct inode *inode;
 	struct list_head * head;
 	ino_t res;
@@ -1370,7 +1372,7 @@ void update_mctime (struct inode *inode)
 	if (IS_RDONLY(inode))
 		return;
 	inode->i_ctime = inode->i_mtime = CURRENT_TIME;
-	mark_inode_dirty (inode);
+	mark_inode_dirty_sync (inode);
 }
 
 
diff -urNp linux-9020/fs/jbd/journal.c linux-9030/fs/jbd/journal.c
--- linux-9020/fs/jbd/journal.c
+++ linux-9030/fs/jbd/journal.c
@@ -676,6 +676,7 @@ struct journal_head * journal_get_descri
 
 	bh = getblk(journal->j_dev, blocknr, journal->j_blocksize);
 	lock_buffer(bh);
+	memset(bh->b_data, 0, journal->j_blocksize);
 	BUFFER_TRACE(bh, "return this buffer");
 	return journal_add_journal_head(bh);
 }
@@ -918,7 +919,7 @@ int journal_create(journal_t *journal)
 		__brelse(bh);
 	}
 
-	sync_dev(journal->j_dev);
+	fsync_no_super(journal->j_dev);
 	jbd_debug(1, "JBD: journal cleared.\n");
 
 	/* OK, fill in the initial static fields in the new superblock */
diff -urNp linux-9020/fs/jbd/revoke.c linux-9030/fs/jbd/revoke.c
--- linux-9020/fs/jbd/revoke.c
+++ linux-9030/fs/jbd/revoke.c
@@ -326,7 +326,12 @@ int journal_revoke(handle_t *handle, uns
            first having the revoke cancelled: it's illegal to free a
            block twice without allocating it in between! */
 	if (bh) {
-		J_ASSERT_BH(bh, !test_bit(BH_Revoked, &bh->b_state));
+		if (!J_EXPECT_BH(bh, !test_bit(BH_Revoked, &bh->b_state),
+				 "inconsistent data on disk")) {
+			if (!bh_in)
+				brelse(bh);
+			return -EIO;
+		}
 		set_bit(BH_Revoked, &bh->b_state);
 		set_bit(BH_RevokeValid, &bh->b_state);
 		if (bh_in) {
diff -urNp linux-9020/fs/jbd/transaction.c linux-9030/fs/jbd/transaction.c
--- linux-9020/fs/jbd/transaction.c
+++ linux-9030/fs/jbd/transaction.c
@@ -1219,12 +1219,13 @@ void journal_release_buffer (handle_t *h
  * Allow this call even if the handle has aborted --- it may be part of
  * the caller's cleanup after an abort.
  */
-void journal_forget (handle_t *handle, struct buffer_head *bh)
+int journal_forget (handle_t *handle, struct buffer_head *bh)
 {
 	transaction_t *transaction = handle->h_transaction;
 	journal_t *journal = transaction->t_journal;
 	struct journal_head *jh;
-
+	int err = 0;
+	
 	BUFFER_TRACE(bh, "entry");
 
 	lock_journal(journal);
@@ -1234,6 +1235,14 @@ void journal_forget (handle_t *handle, s
 		goto not_jbd;
 	jh = bh2jh(bh);
 
+	/* Critical error: attempting to delete a bitmap buffer, maybe?
+	 * Don't do any jbd operations, and return an error. */
+	if (!J_EXPECT_JH(jh, !jh->b_committed_data,
+			 "inconsistent data on disk")) {
+		err = -EIO;
+		goto not_jbd;
+	}
+
 	if (jh->b_transaction == handle->h_transaction) {
 		J_ASSERT_JH(jh, !jh->b_frozen_data);
 
@@ -1244,7 +1253,6 @@ void journal_forget (handle_t *handle, s
 		clear_bit(BH_JBDDirty, &bh->b_state);
 
 		JBUFFER_TRACE(jh, "belongs to current transaction: unfile");
-		J_ASSERT_JH(jh, !jh->b_committed_data);
 
 		__journal_unfile_buffer(jh);
 		jh->b_transaction = 0;
@@ -1270,7 +1278,7 @@ void journal_forget (handle_t *handle, s
 				spin_unlock(&journal_datalist_lock);
 				unlock_journal(journal);
 				__bforget(bh);
-				return;
+				return 0;
 			}
 		}
 		
@@ -1293,7 +1301,7 @@ not_jbd:
 	spin_unlock(&journal_datalist_lock);
 	unlock_journal(journal);
 	__brelse(bh);
-	return;
+	return err;
 }
 
 #if 0	/* Unused */
diff -urNp linux-9020/fs/jfs/jfs_logmgr.c linux-9030/fs/jfs/jfs_logmgr.c
--- linux-9020/fs/jfs/jfs_logmgr.c
+++ linux-9030/fs/jfs/jfs_logmgr.c
@@ -1677,7 +1677,7 @@ static int lbmLogInit(struct jfs_log * l
 		if (lbuf == 0)
 			goto error;
 		lbuf->l_bh.b_data = lbuf->l_ldata =
-		    (char *) __get_free_page(GFP_KERNEL);
+		    (char *) get_zeroed_page(GFP_KERNEL);
 		if (lbuf->l_ldata == 0) {
 			kfree(lbuf);
 			goto error;
diff -urNp linux-9020/fs/jfs/jfs_metapage.c linux-9030/fs/jfs/jfs_metapage.c
--- linux-9020/fs/jfs/jfs_metapage.c
+++ linux-9030/fs/jfs/jfs_metapage.c
@@ -375,6 +375,10 @@ struct metapage *__get_metapage(struct i
 		}
 		mp->data = kmap(mp->page) + page_offset;
 	}
+
+	if (new)
+		memset(mp->data, 0, PSIZE);
+
 	jfs_info("__get_metapage: returning = 0x%p", mp);
 	return mp;
 
diff -urNp linux-9020/fs/jfs/super.c linux-9030/fs/jfs/super.c
--- linux-9020/fs/jfs/super.c
+++ linux-9030/fs/jfs/super.c
@@ -398,10 +398,10 @@ static void init_once(void *foo, kmem_ca
 
 	if ((flags & (SLAB_CTOR_VERIFY | SLAB_CTOR_CONSTRUCTOR)) ==
 	    SLAB_CTOR_CONSTRUCTOR) {
+		memset(jfs_ip, 0, sizeof(struct jfs_inode_info));
 		INIT_LIST_HEAD(&jfs_ip->anon_inode_list);
 		init_rwsem(&jfs_ip->rdwrlock);
 		init_MUTEX(&jfs_ip->commit_sem);
-		jfs_ip->atlhead = 0;
 		jfs_ip->active_ag = -1;
 #ifdef CONFIG_JFS_POSIX_ACL
 		jfs_ip->i_acl = JFS_ACL_NOT_CACHED;
diff -urNp linux-9020/fs/locks.c linux-9030/fs/locks.c
--- linux-9020/fs/locks.c
+++ linux-9030/fs/locks.c
@@ -1097,7 +1097,6 @@ static void time_out_leases(struct inode
 			before = &fl->fl_next;
 			continue;
 		}
-		printk(KERN_INFO "lease broken - owner pid = %d\n", fl->fl_pid);
 		lease_modify(before, fl->fl_type & ~F_INPROGRESS);
 		if (fl == *before)	/* lease_modify may have freed fl */
 			before = &fl->fl_next;
diff -urNp linux-9020/fs/namei.c linux-9030/fs/namei.c
--- linux-9020/fs/namei.c
+++ linux-9030/fs/namei.c
@@ -547,8 +547,10 @@ int link_path_walk(const char * name, st
 			goto out_dput;
 
 		if (inode->i_op->follow_link) {
+			struct vfsmount *mnt = mntget(nd->mnt);
 			err = do_follow_link(dentry, nd);
 			dput(dentry);
+			mntput(mnt);
 			if (err)
 				goto return_err;
 			err = -ENOENT;
@@ -605,8 +607,10 @@ last_component:
 		inode = dentry->d_inode;
 		if ((lookup_flags & LOOKUP_FOLLOW)
 		    && inode && inode->i_op && inode->i_op->follow_link) {
+			struct vfsmount *mnt = mntget(nd->mnt);
 			err = do_follow_link(dentry, nd);
 			dput(dentry);
+			mntput(mnt);
 			if (err)
 				goto return_err;
 			inode = nd->dentry->d_inode;
@@ -1013,6 +1017,7 @@ int open_namei(const char * pathname, in
 	int acc_mode, error = 0;
 	struct inode *inode;
 	struct dentry *dentry;
+	struct vfsmount *mnt;
 	struct dentry *dir;
 	int count = 0;
 
@@ -1196,8 +1201,10 @@ do_link:
 	 * are done. Procfs-like symlinks just set LAST_BIND.
 	 */
 	UPDATE_ATIME(dentry->d_inode);
+	mnt = mntget(nd->mnt);
 	error = dentry->d_inode->i_op->follow_link(dentry, nd);
 	dput(dentry);
+	mntput(mnt);
 	if (error)
 		return error;
 	if (nd->last_type == LAST_BIND) {
diff -urNp linux-9020/fs/open.c linux-9030/fs/open.c
--- linux-9020/fs/open.c
+++ linux-9030/fs/open.c
@@ -701,6 +701,8 @@ asmlinkage long sys_fchown(unsigned int 
 	return error;
 }
 
+static struct file *__dentry_open(struct dentry *, struct vfsmount *, int, struct file *);
+
 /*
  * Note that while the flag value (low two bits) for sys_open means:
  *	00 - read-only
@@ -719,6 +721,7 @@ struct file *filp_open(const char * file
 {
 	int namei_flags, error;
 	struct nameidata nd;
+	struct file *f;
 
 	namei_flags = flags;
 	if ((namei_flags+1) & O_ACCMODE)
@@ -726,24 +729,39 @@ struct file *filp_open(const char * file
 	if (namei_flags & O_TRUNC)
 		namei_flags |= 2;
 
+	error = -ENFILE;
+	f = get_empty_filp();
+	if (f == NULL)
+		return ERR_PTR(error);
+
 	error = open_namei(filename, namei_flags, mode, &nd);
 	if (!error)
-		return dentry_open(nd.dentry, nd.mnt, flags);
+		return __dentry_open(nd.dentry, nd.mnt, flags, f);
 
+	put_filp(f);
 	return ERR_PTR(error);
 }
 
 struct file *dentry_open(struct dentry *dentry, struct vfsmount *mnt, int flags)
 {
-	struct file * f;
+	struct file *f;
+
+	f = get_empty_filp();
+	if (f == NULL) {
+		dput(dentry);
+		mntput(mnt);
+		return ERR_PTR(-ENFILE);
+	}
+
+	return __dentry_open(dentry, mnt, flags, f);
+}
+
+static struct file *__dentry_open(struct dentry *dentry, struct vfsmount *mnt, int flags, struct file *f)
+{
 	struct inode *inode;
 	static LIST_HEAD(kill_list);
 	int error;
 
-	error = -ENFILE;
-	f = get_empty_filp();
-	if (!f)
-		goto cleanup_dentry;
 	f->f_flags = flags;
 	f->f_mode = (flags+1) & O_ACCMODE;
 	inode = dentry->d_inode;
@@ -799,7 +817,6 @@ cleanup_all:
 	f->f_vfsmnt = NULL;
 cleanup_file:
 	put_filp(f);
-cleanup_dentry:
 	dput(dentry);
 	mntput(mnt);
 	return ERR_PTR(error);
diff -urNp linux-9020/fs/proc/array.c linux-9030/fs/proc/array.c
--- linux-9020/fs/proc/array.c
+++ linux-9030/fs/proc/array.c
@@ -86,10 +86,13 @@ static inline char * task_name(struct ta
 {
 	int i;
 	char * name;
+	char tcomm[sizeof(p->comm)];
+
+	get_task_comm(tcomm, p);
 
 	ADDBUF(buf, "Name:\t");
-	name = p->comm;
-	i = sizeof(p->comm);
+	name = tcomm;
+	i = sizeof(tcomm);
 	do {
 		unsigned char c = *name;
 		name++;
@@ -319,6 +322,7 @@ int proc_pid_stat(struct task_struct *ta
 	int res;
 	pid_t ppid;
 	struct mm_struct *mm;
+	char tcomm[sizeof(task->comm)];
 
 	state = *get_task_state(task);
 	vsize = eip = esp = 0;
@@ -344,6 +348,8 @@ int proc_pid_stat(struct task_struct *ta
 		up_read(&mm->mmap_sem);
 	}
 
+	get_task_comm(tcomm, task);
+
 	wchan = 0;
 	if (current->uid == task->uid || current->euid == task->uid ||
 							capable(CAP_SYS_NICE))
@@ -360,10 +366,10 @@ int proc_pid_stat(struct task_struct *ta
 	ppid = task->pid ? task->group_leader->real_parent->tgid : 0;
 	read_unlock(&tasklist_lock);
 	res = sprintf(buffer,"%d (%s) %c %d %d %d %d %d %lu %lu \
-%lu %lu %lu %lu %lu %ld %ld %ld %ld %ld %ld %lu %lu %ld %lu %lu %lu %lu %lu \
+%lu %lu %lu %lu %lu %lu %lu %ld %ld %ld %ld %lu %lu %ld %lu %lu %lu %lu %lu \
 %lu %lu %lu %lu %lu %lu %lu %lu %d %d %lu %lu %lu %lu %lu %lu\n",
 		task->pid,
-		task->comm,
+		tcomm,
 		state,
 		ppid,
 		task->pgrp,
diff -urNp linux-9020/fs/proc/base.c linux-9030/fs/proc/base.c
--- linux-9020/fs/proc/base.c
+++ linux-9030/fs/proc/base.c
@@ -164,11 +164,15 @@ static int proc_pid_environ(struct task_
 
 	task_lock(task);
 	mm = task->mm;
-	if (mm)
-		atomic_inc(&mm->mm_users);
+	if (mm) {
+		if (mm->env_end)
+			atomic_inc(&mm->mm_users);
+		else
+			mm = NULL;
+	}
 	task_unlock(task);
 	if (mm) {
-		unsigned int len = mm->env_end - mm->env_start;
+		int len = mm->env_end - mm->env_start;
 		if (len > PAGE_SIZE)
 			len = PAGE_SIZE;
 		res = access_process_vm(task, mm->env_start, buffer, len, 0);
@@ -185,18 +189,27 @@ static int proc_pid_cmdline(struct task_
 	int res = 0;
 	task_lock(task);
 	mm = task->mm;
-	if (mm)
-		atomic_inc(&mm->mm_users);
+	if (mm) {
+		if (mm->arg_end)
+			atomic_inc(&mm->mm_users);
+		else
+			mm = NULL;
+	}
 	task_unlock(task);
 	if (mm) {
 		int len = mm->arg_end - mm->arg_start;
 		if (len > PAGE_SIZE)
 			len = PAGE_SIZE;
 		res = access_process_vm(task, mm->arg_start, buffer, len, 0);
+		/*
+		 * If the length is > 4Kb we need to add a 0 to the end 
+		 */
+		if ((len == PAGE_SIZE) && (res > 0))
+		    buffer[res-1] = '\0';
+		    
 		// If the nul at the end of args has been overwritten, then
 		// assume application is using setproctitle(3).
-		if ( res > 0 && buffer[res-1] != '\0' )
-		{
+		if (res > 0 && buffer[res-1] != '\0' && mm->env_end) {
 			len = strnlen( buffer, res );
 			if ( len < res )
 			{
@@ -729,6 +742,7 @@ static int task_dumpable(struct task_str
 static struct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task, int ino)
 {
 	struct inode * inode;
+	pid_t pid;
 
 	/* We need a new inode */
 	
@@ -739,9 +753,10 @@ static struct inode *proc_pid_make_inode
 	/* Common stuff */
 
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
-	inode->i_ino = fake_ino(task->pid, ino);
+	pid = task->pid;
+	inode->i_ino = fake_ino(pid, ino);
 
-	if (!task->pid)
+	if (!pid)
 		goto out_unlock;
 
 	/*
@@ -760,6 +775,7 @@ out:
 	return inode;
 
 out_unlock:
+	inode->u.generic_ip = NULL;	/* paranoia, but... */
 	iput(inode);
 	return NULL;
 }
@@ -864,8 +880,8 @@ static struct dentry *proc_lookupfd(stru
 	return NULL;
 
 out_unlock2:
-	put_files_struct(files);
 	read_unlock(&files->file_lock);
+	put_files_struct(files);
 out_unlock:
 	iput(inode);
 out:
diff -urNp linux-9020/fs/proc/generic.c linux-9030/fs/proc/generic.c
--- linux-9020/fs/proc/generic.c
+++ linux-9030/fs/proc/generic.c
@@ -258,6 +258,7 @@ struct dentry *proc_lookup(struct inode 
 	struct inode *inode;
 	struct proc_dir_entry * de;
 	int error;
+	extern void de_put(struct proc_dir_entry *);
 
 	error = -ENOENT;
 	inode = NULL;
@@ -271,7 +272,9 @@ struct dentry *proc_lookup(struct inode 
 			if (!memcmp(dentry->d_name.name, de->name, de->namelen)) {
 				int ino = de->low_ino;
 				error = -EINVAL;
+				atomic_inc(&de->count);
 				inode = proc_get_inode(dir->i_sb, ino, de);
+				de_put(de);
 				break;
 			}
 		}
diff -urNp linux-9020/fs/proc/inode-alloc.txt linux-9030/fs/proc/inode-alloc.txt
--- linux-9020/fs/proc/inode-alloc.txt
+++ linux-9030/fs/proc/inode-alloc.txt
@@ -4,7 +4,7 @@ Current inode allocations in the proc-fs
   00000001-00000fff	static entries	(goners)
        001		root-ino
 
-  00001000-00001fff	dynamic entries
+  00001000-0000ffff	dynamic entries
   0001xxxx-7fffxxxx	pid-dir entries for pid 1-7fff
   80000000-ffffffff	unused
 
diff -urNp linux-9020/fs/proc/inode.c linux-9030/fs/proc/inode.c
--- linux-9020/fs/proc/inode.c
+++ linux-9030/fs/proc/inode.c
@@ -32,7 +32,7 @@ static inline struct proc_dir_entry * de
 /*
  * Decrements the use count and checks for deferred deletion.
  */
-static void de_put(struct proc_dir_entry *de)
+void de_put(struct proc_dir_entry *de)
 {
 	if (de) {	
 		lock_kernel();		
diff -urNp linux-9020/fs/proc/kcore.c linux-9030/fs/proc/kcore.c
--- linux-9020/fs/proc/kcore.c
+++ linux-9030/fs/proc/kcore.c
@@ -102,6 +102,12 @@ static ssize_t read_kcore(struct file *f
 
 #define roundup(x, y)  ((((x)+((y)-1))/(y))*(y))
 
+#ifdef CONFIG_IA64
+#undef kern_addr_valid
+#define kern_addr_valid(va) (page_is_ram(__pa(va) >> PAGE_SHIFT))
+extern int page_is_ram(unsigned long);
+#endif
+
 /* An ELF note in memory */
 struct memelfnote
 {
@@ -120,12 +126,14 @@ static size_t get_kcore_size(int *num_vm
 
 	*num_vma = 0;
 	size = ((size_t)high_memory - PAGE_OFFSET);
+#ifndef CONFIG_IA64
 	for (m = vmlist; m; m = m->next) {
 		try = ((size_t)m->addr - PAGE_OFFSET) + m->size;
 		if (try > size)
 			size = try;
 		*num_vma = *num_vma + 1;
 	}
+#endif
 	*elf_buflen =	sizeof(struct elfhdr) + 
 			(*num_vma + 2) * sizeof(struct elf_phdr) + 
 			3 * (sizeof(struct elf_note) + 4) +
@@ -242,6 +250,7 @@ static void elf_kcore_store_hdr(char *bu
 	phdr->p_filesz	= phdr->p_memsz = ((unsigned long)high_memory - PAGE_OFFSET);
 	phdr->p_align	= PAGE_SIZE;
 
+#ifndef CONFIG_IA64
 	/* setup ELF PT_LOAD program header for every vmalloc'd area */
 	for (m=vmlist; m; m=m->next) {
 		if (m->flags & VM_IOREMAP) /* don't dump ioremap'd stuff! (TA) */
@@ -259,6 +268,7 @@ static void elf_kcore_store_hdr(char *bu
 		phdr->p_filesz	= phdr->p_memsz	= m->size;
 		phdr->p_align	= PAGE_SIZE;
 	}
+#endif
 
 	/*
 	 * Set up the notes in similar form to SVR4 core dumps made
@@ -396,6 +406,7 @@ static ssize_t read_kcore(struct file *f
 		tsz = buflen;
 		
 	while (buflen) {
+#ifndef CONFIG_IA64
 		if ((start >= VMALLOC_START) && (start < VMALLOC_END)) {
 			char * elf_buf;
 			struct vm_struct *m;
@@ -441,8 +452,10 @@ static ssize_t read_kcore(struct file *f
 				return -EFAULT;
 			}
 			kfree(elf_buf);
-		} else if ((start > PAGE_OFFSET) && (start < 
-						(unsigned long)high_memory)) {
+		} else
+#endif
+		if (start >= PAGE_OFFSET &&
+		    start < (unsigned long)high_memory) {
 			if (kern_addr_valid(start)) {
 				if (copy_to_user(buffer, (char *)start, tsz))
 					return -EFAULT;
diff -urNp linux-9020/fs/proc/root.c linux-9030/fs/proc/root.c
--- linux-9020/fs/proc/root.c
+++ linux-9030/fs/proc/root.c
@@ -86,6 +86,34 @@ static struct dentry *proc_root_lookup(s
 	return proc_pid_lookup(dir, dentry);
 }
 
+/*
+ * This is a verbatim copy of default_llseek which also kills
+ * the cursor in file->private_data. See fs/proc/base.c:get_pid_list().
+ */
+static loff_t proc_root_llseek(struct file *file, loff_t offset, int origin)
+{
+	long long retval;
+
+	switch (origin) {
+		case 2:
+			offset += file->f_dentry->d_inode->i_size;
+			break;
+		case 1:
+			offset += file->f_pos;
+	}
+	retval = -EINVAL;
+	if (offset >= 0) {
+		if (offset != file->f_pos) {
+			file->f_pos = offset;
+			file->f_reada = 0;
+			file->f_version = ++event;
+			file->private_data = 0;		/* kill cursor */
+		}
+		retval = offset;
+	}
+	return retval;
+}
+
 static int proc_root_readdir(struct file * filp,
 	void * dirent, filldir_t filldir)
 {
@@ -107,6 +135,7 @@ static int proc_root_readdir(struct file
  * directory handling functions for that..
  */
 static struct file_operations proc_root_operations = {
+	llseek:		 proc_root_llseek,
 	read:		 generic_read_dir,
 	readdir:	 proc_root_readdir,
 };
diff -urNp linux-9020/fs/quota_v2.c linux-9030/fs/quota_v2.c
--- linux-9020/fs/quota_v2.c
+++ linux-9030/fs/quota_v2.c
@@ -128,7 +128,7 @@ static void mem2diskdqb(struct v2_disk_d
 
 static dqbuf_t getdqbuf(void)
 {
-	dqbuf_t buf = kmalloc(V2_DQBLKSIZE, GFP_KERNEL);
+	dqbuf_t buf = kmalloc(V2_DQBLKSIZE, GFP_NOFS);
 	if (!buf)
 		printk(KERN_WARNING "VFS: Not enough memory for quota buffers.\n");
 	return buf;
diff -urNp linux-9020/fs/select.c linux-9030/fs/select.c
--- linux-9020/fs/select.c
+++ linux-9030/fs/select.c
@@ -31,6 +31,7 @@
 #include <linux/fs.h>
 
 #include <asm/uaccess.h>
+#include <asm/div64.h>
 
 #define ROUND_UP(x,y) (((x)+(y)-1)/(y))
 #define DEFAULT_POLLMASK (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM)
@@ -578,24 +579,33 @@ static int do_poll(unsigned int nfds, un
 	return count;
 }
 
-asmlinkage long sys_poll(struct pollfd * ufds, unsigned int nfds, long timeout)
+asmlinkage long sys_poll(struct pollfd *ufds, unsigned int nfds, int timeout_msecs)
 {
 	int i, j, fdcount, err;
 	struct pollfd **fds;
 	poll_table table, *wait;
 	int nchunks, nleft;
+	long timeout;
+	int64_t lltimeout;
 
 	/* Do a sanity check on nfds ... */
-	if (nfds > current->files->max_fdset && nfds > OPEN_MAX)
+	if (nfds > current->rlim[RLIMIT_NOFILE].rlim_cur)
 		return -EINVAL;
 
-	if (timeout) {
-		/* Careful about overflow in the intermediate values */
-		if ((unsigned long) timeout < MAX_SCHEDULE_TIMEOUT / HZ)
-			timeout = (unsigned long)(timeout*HZ+999)/1000+1;
-		else /* Negative or overflow */
+	if (timeout_msecs) {
+		if (timeout_msecs < 0)
 			timeout = MAX_SCHEDULE_TIMEOUT;
-	}
+		else {
+			lltimeout = (int64_t)timeout_msecs * HZ + 999;
+			do_div(lltimeout, 1000);
+			lltimeout++;
+			if (lltimeout > MAX_SCHEDULE_TIMEOUT)
+				timeout = MAX_SCHEDULE_TIMEOUT;
+			else
+				timeout = (long)lltimeout;
+		}
+	} else
+		timeout = 0;
 
 	poll_initwait(&table);
 	wait = &table;
diff -urNp linux-9020/fs/udf/super.c linux-9030/fs/udf/super.c
--- linux-9020/fs/udf/super.c
+++ linux-9030/fs/udf/super.c
@@ -1427,7 +1427,7 @@ udf_read_super(struct super_block *sb, v
 
 	if (udf_check_valid(sb, uopt.novrs, silent)) /* read volume recognition sequences */
 	{
-		printk("UDF-fs: No VRS found\n");
+		udf_debug("UDF-fs: No VRS found\n");
  		goto error_out;
 	}
 
diff -urNp linux-9020/include/asm-i386/pgtable-3level.h linux-9030/include/asm-i386/pgtable-3level.h
--- linux-9020/include/asm-i386/pgtable-3level.h
+++ linux-9030/include/asm-i386/pgtable-3level.h
@@ -1,6 +1,8 @@
 #ifndef _I386_PGTABLE_3LEVEL_H
 #define _I386_PGTABLE_3LEVEL_H
 
+#include <asm/system.h>
+
 /*
  * Intel Physical Address Extension (PAE) Mode - three-level page
  * tables on PPro+ CPUs.
diff -urNp linux-9020/include/asm-i386/processor.h linux-9030/include/asm-i386/processor.h
--- linux-9020/include/asm-i386/processor.h
+++ linux-9030/include/asm-i386/processor.h
@@ -17,6 +17,7 @@
 #include <linux/cache.h>
 #include <linux/config.h>
 #include <linux/threads.h>
+#include <linux/compiler.h>
 
 struct desc_struct {
 	unsigned long a,b;
@@ -536,7 +537,7 @@ struct extended_sigtable {
 /* REP NOP (PAUSE) is a good thing to insert into busy-wait loops. */
 static inline void rep_nop(void)
 {
-	__asm__ __volatile__("rep;nop");
+	__asm__ __volatile__("rep;nop" ::: "memory");
 }
 
 #define cpu_relax()	rep_nop()
@@ -549,8 +550,13 @@ extern inline void prefetch(const void *
 {
 	__asm__ __volatile__ ("prefetchnta (%0)" : : "r"(x));
 }
+#define ARCH_HAS_PREFETCHW
+extern inline void prefetchw(const void *x)
+{
+	__asm__ __volatile__ ("prefetchnta (%0)" : : "r"(x));
+}
 
-#elif CONFIG_X86_USE_3DNOW
+#elif defined(CONFIG_X86_USE_3DNOW)
 
 #define ARCH_HAS_PREFETCH
 #define ARCH_HAS_PREFETCHW
@@ -558,11 +564,17 @@ extern inline void prefetch(const void *
 
 extern inline void prefetch(const void *x)
 {
+#if defined(CONFIG_MK7) && !defined(CONFIG_MK8)
+	if (likely((x) != (const void *)0))
+#endif
 	 __asm__ __volatile__ ("prefetch (%0)" : : "r"(x));
 }
 
 extern inline void prefetchw(const void *x)
 {
+#if defined(CONFIG_MK7) && !defined(CONFIG_MK8)
+	if (likely((x) != (const void *)0))
+#endif
 	 __asm__ __volatile__ ("prefetchw (%0)" : : "r"(x));
 }
 #define spin_lock_prefetch(x)	prefetchw(x)
diff -urNp linux-9020/include/asm-i386/string.h linux-9030/include/asm-i386/string.h
--- linux-9020/include/asm-i386/string.h
+++ linux-9030/include/asm-i386/string.h
@@ -308,45 +308,11 @@ __asm__ __volatile__( \
 
 #define __HAVE_ARCH_MEMCPY
 
-#ifdef CONFIG_X86_USE_3DNOW
-
-#include <asm/mmx.h>
-
-/*
- *	This CPU favours 3DNow strongly (eg AMD Athlon)
- */
-
-static inline void * __constant_memcpy3d(void * to, const void * from, size_t len)
-{
-	if (len < 512)
-		return __constant_memcpy(to, from, len);
-	return _mmx_memcpy(to, from, len);
-}
-
-static __inline__ void *__memcpy3d(void *to, const void *from, size_t len)
-{
-	if (len < 512)
-		return __memcpy(to, from, len);
-	return _mmx_memcpy(to, from, len);
-}
-
-#define memcpy(t, f, n) \
-(__builtin_constant_p(n) ? \
- __constant_memcpy3d((t),(f),(n)) : \
- __memcpy3d((t),(f),(n)))
-
-#else
-
-/*
- *	No 3D Now!
- */
- 
 #define memcpy(t, f, n) \
 (__builtin_constant_p(n) ? \
  __constant_memcpy((t),(f),(n)) : \
  __memcpy((t),(f),(n)))
 
-#endif
 
 /*
  * struct_cpy(x,y), copy structure *x into (matching structure) *y.
diff -urNp linux-9020/include/asm-ia64/processor.h linux-9030/include/asm-ia64/processor.h
--- linux-9020/include/asm-ia64/processor.h
+++ linux-9030/include/asm-ia64/processor.h
@@ -689,7 +689,13 @@ ia64_set_lrr0 (unsigned long val)
 	asm volatile ("mov cr.lrr0=%0;; srlz.d" :: "r"(val) : "memory");
 }
 
-#define cpu_relax()	do { } while (0)
+static inline void
+ia64_hint_pause (void)
+{
+	asm volatile ("hint @pause" ::: "memory");
+}
+
+#define cpu_relax()     ia64_hint_pause()
 
 
 static inline void
diff -urNp linux-9020/include/asm-s390/processor.h linux-9030/include/asm-s390/processor.h
--- linux-9020/include/asm-s390/processor.h
+++ linux-9030/include/asm-s390/processor.h
@@ -153,7 +153,10 @@ unsigned long get_wchan(struct task_stru
 #define init_task       (init_task_union.task)
 #define init_stack      (init_task_union.stack)
 
-#define cpu_relax()	do { } while (0)
+/*
+ * cpu_relax is a barrier in 2.5 and on i386 in 2.4.
+ */
+#define cpu_relax()	__asm__ __volatile__("": : :"memory")
 
 /*
  * Set of msr bits that gdb can change on behalf of a process.
diff -urNp linux-9020/include/asm-s390x/processor.h linux-9030/include/asm-s390x/processor.h
--- linux-9020/include/asm-s390x/processor.h
+++ linux-9030/include/asm-s390x/processor.h
@@ -164,7 +164,10 @@ extern void __free_task_struct(struct ta
 #define init_task       (init_task_union.task)
 #define init_stack      (init_task_union.stack)
 
-#define cpu_relax()	do { } while (0)
+/*
+ * cpu_relax is a barrier in 2.5 and on i386 in 2.4.
+ */
+#define cpu_relax()	__asm__ __volatile__("": : :"memory")
 
 /*
  * Set of msr bits that gdb can change on behalf of a process.
diff -urNp linux-9020/include/asm-x86_64/processor.h linux-9030/include/asm-x86_64/processor.h
--- linux-9020/include/asm-x86_64/processor.h
+++ linux-9030/include/asm-x86_64/processor.h
@@ -462,7 +462,7 @@ struct extended_sigtable {
 /* REP NOP (PAUSE) is a good thing to insert into busy-wait loops. */
 extern inline void rep_nop(void)
 {
-	__asm__ __volatile__("rep;nop");
+	__asm__ __volatile__("rep;nop" ::: "memory");
 }
 
 static __inline__ void __monitor(const void *eax, unsigned long ecx,
diff -urNp linux-9020/include/linux/brlock.h linux-9030/include/linux/brlock.h
--- linux-9020/include/linux/brlock.h
+++ linux-9030/include/linux/brlock.h
@@ -83,7 +83,8 @@ extern void __br_lock_usage_bug (void);
 
 #ifdef __BRLOCK_USE_ATOMICS
 
-static inline void br_read_lock (enum brlock_indices idx)
+static inline __attribute__((always_inline)) void 
+br_read_lock (enum brlock_indices idx)
 {
 	/*
 	 * This causes a link-time bug message if an
@@ -95,7 +96,8 @@ static inline void br_read_lock (enum br
 	read_lock(&__brlock_array[smp_processor_id()][idx]);
 }
 
-static inline void br_read_unlock (enum brlock_indices idx)
+static inline __attribute__((always_inline)) void 
+br_read_unlock (enum brlock_indices idx)
 {
 	if (idx >= __BR_END)
 		__br_lock_usage_bug();
@@ -104,7 +106,8 @@ static inline void br_read_unlock (enum 
 }
 
 #else /* ! __BRLOCK_USE_ATOMICS */
-static inline void br_read_lock (enum brlock_indices idx)
+static inline __attribute__((always_inline)) void 
+br_read_lock (enum brlock_indices idx)
 {
 	unsigned int *ctr;
 	spinlock_t *lock;
@@ -143,7 +146,8 @@ again:
 	}
 }
 
-static inline void br_read_unlock (enum brlock_indices idx)
+static inline __attribute__((always_inline)) void 
+br_read_unlock (enum brlock_indices idx)
 {
 	unsigned int *ctr;
 
@@ -162,14 +166,16 @@ static inline void br_read_unlock (enum 
 extern void FASTCALL(__br_write_lock (enum brlock_indices idx));
 extern void FASTCALL(__br_write_unlock (enum brlock_indices idx));
 
-static inline void br_write_lock (enum brlock_indices idx)
+static inline __attribute__((always_inline)) void 
+br_write_lock (enum brlock_indices idx)
 {
 	if (idx >= __BR_END)
 		__br_lock_usage_bug();
 	__br_write_lock(idx);
 }
 
-static inline void br_write_unlock (enum brlock_indices idx)
+static inline __attribute__((always_inline)) void 
+br_write_unlock (enum brlock_indices idx)
 {
 	if (idx >= __BR_END)
 		__br_lock_usage_bug();
diff -urNp linux-9020/include/linux/cdrom.h linux-9030/include/linux/cdrom.h
--- linux-9020/include/linux/cdrom.h
+++ linux-9030/include/linux/cdrom.h
@@ -504,7 +504,8 @@ struct cdrom_generic_command
  * of MODE_SENSE_POWER_PAGE */
 #define GPMODE_CDROM_PAGE		0x0d
 
-
+/* Features */
+#define CDF_DVD_READ		0x001f
 
 /* DVD struct types */
 #define DVD_STRUCT_PHYSICAL	0x00
diff -urNp linux-9020/include/linux/coda.h linux-9030/include/linux/coda.h
--- linux-9020/include/linux/coda.h
+++ linux-9030/include/linux/coda.h
@@ -767,8 +767,8 @@ union coda_downcalls {
 #define PIOCPARM_MASK 0x0000ffff
 struct ViceIoctl {
         caddr_t in, out;        /* Data to be transferred in, or out */
-        short in_size;          /* Size of input buffer <= 2K */
-        short out_size;         /* Maximum size of output buffer, <= 2K */
+        u_short in_size;        /* Size of input buffer <= 2K */
+        u_short out_size;       /* Maximum size of output buffer, <= 2K */
 };
 
 struct PioctlData {
diff -urNp linux-9020/include/linux/dcache.h linux-9030/include/linux/dcache.h
--- linux-9020/include/linux/dcache.h
+++ linux-9030/include/linux/dcache.h
@@ -63,7 +63,7 @@ static __inline__ unsigned int full_name
 }
 
 /* XXX: check good value for 64bit */ 
-#define DNAME_INLINE_LEN 32
+#define DNAME_INLINE_LEN 24
 
 struct dcookie_struct;
  
diff -urNp linux-9020/include/linux/ext2_fs_sb.h linux-9030/include/linux/ext2_fs_sb.h
--- linux-9020/include/linux/ext2_fs_sb.h
+++ linux-9030/include/linux/ext2_fs_sb.h
@@ -22,7 +22,7 @@
  */
 /* #define EXT2_MAX_GROUP_DESC	8 */
 
-#define EXT2_MAX_GROUP_LOADED	8
+#define EXT2_MAX_GROUP_LOADED	32
 
 /*
  * second extended-fs super-block data in memory
diff -urNp linux-9020/include/linux/ext3_fs_sb.h linux-9030/include/linux/ext3_fs_sb.h
--- linux-9020/include/linux/ext3_fs_sb.h
+++ linux-9030/include/linux/ext3_fs_sb.h
@@ -27,7 +27,7 @@
  */
 /* #define EXT3_MAX_GROUP_DESC	8 */
 
-#define EXT3_MAX_GROUP_LOADED	8
+#define EXT3_MAX_GROUP_LOADED	32
 
 /*
  * third extended-fs super-block data in memory
diff -urNp linux-9020/include/linux/ext3_jbd.h linux-9030/include/linux/ext3_jbd.h
--- linux-9020/include/linux/ext3_jbd.h
+++ linux-9030/include/linux/ext3_jbd.h
@@ -84,6 +84,8 @@ int ext3_reserve_inode_write(handle_t *h
 
 int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode);
 
+void ext3_journal_abort_handle(const char *caller, const char *err_fn, struct buffer_head *bh, handle_t *handle, int err);
+
 /*
  * Wrapper functions with which ext3 calls into JBD.  The intent here is
  * to allow these to be turned into appropriate stubs so ext3 can control
@@ -91,25 +93,6 @@ int ext3_mark_inode_dirty(handle_t *hand
  * been done yet.
  */
 
-static inline void ext3_journal_abort_handle(const char *caller, 
-					     const char *err_fn,
-					     struct buffer_head *bh,
-					     handle_t *handle,
-					     int err)
-{
-	char nbuf[16];
-	const char *errstr = ext3_decode_error(NULL, err, nbuf);
-	
-	printk(KERN_ERR "%s: aborting transaction: %s in %s", 
-	       caller, errstr, err_fn);
-
-	if (bh)
-		BUFFER_TRACE(bh, "abort");
-	journal_abort_handle(handle);
-	if (!handle->h_err)
-		handle->h_err = err;
-}
-
 static inline int
 __ext3_journal_get_undo_access(const char *where,
 			       handle_t *handle, struct buffer_head *bh)
@@ -140,10 +123,13 @@ __ext3_journal_dirty_data(const char *wh
 	return err;
 }
 
-static inline void
-ext3_journal_forget(handle_t *handle, struct buffer_head *bh)
+static inline int
+__ext3_journal_forget(const char *where, handle_t *handle, struct buffer_head *bh)
 {
-	journal_forget(handle, bh);
+	int err = journal_forget(handle, bh);
+	if (err)
+		ext3_journal_abort_handle(where, __FUNCTION__, bh, handle,err);
+	return err;
 }
 
 static inline int
@@ -189,6 +175,8 @@ __ext3_journal_dirty_metadata(const char
 	__ext3_journal_get_create_access(__FUNCTION__, (handle), (bh))
 #define ext3_journal_dirty_metadata(handle, bh) \
 	__ext3_journal_dirty_metadata(__FUNCTION__, (handle), (bh))
+#define ext3_journal_forget(handle, bh) \
+	__ext3_journal_forget(__FUNCTION__, (handle), (bh))
 
 
 
diff -urNp linux-9020/include/linux/fs.h linux-9030/include/linux/fs.h
--- linux-9020/include/linux/fs.h
+++ linux-9030/include/linux/fs.h
@@ -270,8 +270,8 @@ struct buffer_head {
 	/* First cache line: */
 	struct buffer_head *b_next;	/* Hash queue list */
 	unsigned long b_blocknr;	/* block number */
-	unsigned short b_size;		/* block size */
-	unsigned short b_list;		/* List that this buffer appears */
+	unsigned int b_size;		/* block size */
+	unsigned int b_list;		/* List that this buffer appears */
 	kdev_t b_dev;			/* device (B_FREE = free) */
 
 	atomic_t b_count;		/* users using this block */
@@ -485,7 +485,7 @@ struct inode {
 	unsigned long		i_blksize;
 	unsigned long		i_blocks;
 	unsigned long		i_version;
-	unsigned short		i_bytes;
+	unsigned int		i_bytes;
 	struct semaphore	i_sem;
 	struct rw_semaphore	i_alloc_sem;
 	struct semaphore	i_zombie;
diff -urNp linux-9020/include/linux/jbd.h linux-9030/include/linux/jbd.h
--- linux-9020/include/linux/jbd.h
+++ linux-9030/include/linux/jbd.h
@@ -278,12 +278,14 @@ void buffer_assertion_failure(struct buf
 #define J_EXPECT_JH(jh, expr, why...)	J_ASSERT_JH(jh, expr)
 #else
 #define __journal_expect(expr, why...)					     \
-	do {								     \
-		if (!(expr)) {						     \
+	({								     \
+		int val = (expr);					     \
+		if (!val) {						     \
 			printk(KERN_ERR "EXT3-fs unexpected failure: %s;\n", # expr); \
-			printk(KERN_ERR why);				     \
+			printk(KERN_ERR why "\n");			     \
 		}							     \
-	} while (0)
+		val;							     \
+	})
 #define J_EXPECT(expr, why...)		__journal_expect(expr, ## why)
 #define J_EXPECT_BH(bh, expr, why...)	__journal_expect(expr, ## why)
 #define J_EXPECT_JH(jh, expr, why...)	__journal_expect(expr, ## why)
@@ -778,7 +780,11 @@ extern int	 journal_dirty_data (handle_t
 				struct buffer_head *, int async);
 extern int	 journal_dirty_metadata (handle_t *, struct buffer_head *);
 extern void	 journal_release_buffer (handle_t *, struct buffer_head *);
+#ifdef __GENKSYMS__ /* preserve KMI/ABI ksyms compatibility for mod linkage */
 extern void	 journal_forget (handle_t *, struct buffer_head *);
+#else
+extern int	 journal_forget (handle_t *, struct buffer_head *);
+#endif
 extern void	 journal_sync_buffer (struct buffer_head *);
 extern int	 journal_flushpage(journal_t *, struct page *, unsigned long);
 extern int	 journal_try_to_free_buffers(journal_t *, struct page *, int);
diff -urNp linux-9020/include/linux/module.h linux-9030/include/linux/module.h
--- linux-9020/include/linux/module.h
+++ linux-9030/include/linux/module.h
@@ -295,7 +295,7 @@ static const char __module_license[] __a
 "license=" license
 
 #define GPL_HEADER() \
-static const char cpyright="This software may be freely redistributed under the terms of the GNU General Public License.";
+static const char cpyright[]="This software may be freely redistributed under the terms of the GNU General Public License.";
 
 /* Define the module variable, and usage macros.  */
 extern struct module __this_module;
@@ -411,7 +411,7 @@ __attribute__((section("__ksymtab"))) =	
 
 #ifdef MODULE
 /* Force a module to export no symbols.  */
-#define EXPORT_NO_SYMBOLS  __asm__(".section __ksymtab\n.previous")
+#define EXPORT_NO_SYMBOLS  __asm__(".section __ksymtab, \"a\"\n.previous")
 #else
 #define EXPORT_NO_SYMBOLS
 #endif /* MODULE */
diff -urNp linux-9020/include/linux/netfilter_arp/arp_tables.h linux-9030/include/linux/netfilter_arp/arp_tables.h
--- linux-9020/include/linux/netfilter_arp/arp_tables.h
+++ linux-9030/include/linux/netfilter_arp/arp_tables.h
@@ -111,7 +111,7 @@ struct arpt_counters
 #define ARPT_INV_ARPHRD		0x0080	/* Invert the sense of ARP HRD. */
 #define ARPT_INV_ARPPRO		0x0100	/* Invert the sense of ARP PRO. */
 #define ARPT_INV_ARPHLN		0x0200	/* Invert the sense of ARP HLN. */
-#define ARPT_INV_MASK		0x007F	/* All possible flag bits mask. */
+#define ARPT_INV_MASK		0x03FF	/* All possible flag bits mask. */
 
 /* This structure defines each of the firewall rules.  Consists of 3
    parts which are 1) general ARP header stuff 2) match specific
diff -urNp linux-9020/include/linux/proc_fs.h linux-9030/include/linux/proc_fs.h
--- linux-9020/include/linux/proc_fs.h
+++ linux-9030/include/linux/proc_fs.h
@@ -25,7 +25,7 @@ enum {
 /* Finally, the dynamically allocatable proc entries are reserved: */
 
 #define PROC_DYNAMIC_FIRST 4096
-#define PROC_NDYNAMIC      4096
+#define PROC_NDYNAMIC      (65536 - PROC_DYNAMIC_FIRST)
 
 #define PROC_SUPER_MAGIC 0x9fa0
 
@@ -217,4 +217,9 @@ extern struct proc_dir_entry proc_root_d
 
 #endif /* CONFIG_PROC_FS */
 
+static inline struct proc_dir_entry *PDE(const struct inode *inode)
+{
+	return (struct proc_dir_entry *)inode->u.generic_ip;
+}
+
 #endif /* _LINUX_PROC_FS_H */
diff -urNp linux-9020/include/linux/sched.h linux-9030/include/linux/sched.h
--- linux-9020/include/linux/sched.h
+++ linux-9030/include/linux/sched.h
@@ -529,7 +529,7 @@ struct task_struct {
 	struct user_struct *user;
 /* limits */
 	struct rlimit rlim[RLIM_NLIMITS];
-	unsigned short used_math;
+	unsigned int used_math;
 	char comm[16];
 /* file system info */
 	int link_count, total_link_count;
@@ -989,6 +989,8 @@ extern int do_fork(unsigned long, unsign
 extern void reap_thread(task_t *p);
 extern void release_task(struct task_struct * p);
 
+extern void set_task_comm(struct task_struct *tsk, char *from);
+extern void get_task_comm(char *to, struct task_struct *tsk);
 
 extern void FASTCALL(add_wait_queue(wait_queue_head_t *q, wait_queue_t * wait));
 extern void FASTCALL(add_wait_queue_exclusive(wait_queue_head_t *q, wait_queue_t * wait));
diff -urNp linux-9020/kernel/acct.c linux-9030/kernel/acct.c
--- linux-9020/kernel/acct.c
+++ linux-9030/kernel/acct.c
@@ -168,7 +168,7 @@ asmlinkage long sys_acct(const char *nam
 		if (IS_ERR(tmp))
 			goto out;
 		/* Difference from BSD - they don't do O_APPEND */
-		file = filp_open(tmp, O_WRONLY|O_APPEND, 0);
+		file = filp_open(tmp, O_WRONLY | O_APPEND | O_LARGEFILE, 0);
 		putname(tmp);
 		if (IS_ERR(file)) {
 			error = PTR_ERR(file);
@@ -359,6 +359,10 @@ static void do_acct_process(long exitcod
 int acct_process(long exitcode)
 {
 	struct file *file = NULL;
+	/* Don't serialise exit on BKL when accounting is off */
+	if (!acct_file)
+		return 0;
+
 	lock_kernel();
 	if (acct_file) {
 		file = acct_file;
diff -urNp linux-9020/kernel/fork.c linux-9030/kernel/fork.c
--- linux-9020/kernel/fork.c
+++ linux-9030/kernel/fork.c
@@ -1209,7 +1209,7 @@ void __init proc_caches_init(void)
  
 	vm_area_cachep = kmem_cache_create("vm_area_struct",
 			sizeof(struct vm_area_struct), 0,
-			SLAB_HWCACHE_ALIGN, NULL, NULL);
+			0, NULL, NULL);
 	if(!vm_area_cachep)
 		panic("vma_init: Cannot alloc vm_area_struct SLAB cache");
 
diff -urNp linux-9020/kernel/kmod.c linux-9030/kernel/kmod.c
--- linux-9020/kernel/kmod.c
+++ linux-9030/kernel/kmod.c
@@ -131,8 +131,14 @@ int exec_usermodehelper(char *program_pa
 	}
 
 	/* Give kmod all effective privileges.. */
-	curtask->euid = curtask->fsuid = 0;
-	curtask->egid = curtask->fsgid = 0;
+	curtask->euid = curtask->uid = curtask->suid = curtask->fsuid = 0;
+	curtask->egid = curtask->gid = curtask->sgid = curtask->fsgid = 0;
+
+	memcpy(&curtask->rlim[0], &init_task.rlim[0],
+		sizeof(struct rlimit) * RLIM_NLIMITS);
+
+	curtask->ngroups = 0;
+
 	cap_set_full(curtask->cap_effective);
 
 	/* Allow execve args to be in kernel space. */
@@ -219,7 +225,11 @@ int request_module(const char * module_n
 
 	pid = kernel_thread(exec_modprobe, (void*) module_name, 0);
 	if (pid < 0) {
-		printk(KERN_ERR "request_module[%s]: fork failed, errno %d\n", module_name, -pid);
+		if (pid != -EPERM) {
+			printk(KERN_ERR
+				"request_module[%s]: fork failed, errno %d\n",
+				module_name, -pid);
+		}
 		atomic_dec(&kmod_concurrent);
 		return pid;
 	}
diff -urNp linux-9020/kernel/module.c linux-9030/kernel/module.c
--- linux-9020/kernel/module.c
+++ linux-9030/kernel/module.c
@@ -58,6 +58,8 @@ struct module *module_list = &kernel_mod
 
 #endif	/* defined(CONFIG_MODULES) || defined(CONFIG_KALLSYMS) */
 
+#if defined(CONFIG_MODULES)
+
 /*
  * module load notification support
  */
@@ -85,6 +87,8 @@ int unregister_module_notifier(struct no
 }
 EXPORT_SYMBOL(unregister_module_notifier);
 
+#endif
+
 /* inter_module functions are always available, even when the kernel is
  * compiled without modules.  Consumers of inter_module_xxx routines
  * will always work, even when both are built into the kernel, this
@@ -441,6 +445,9 @@ sys_init_module(const char *name_user, s
 				"exceeds size of created module.\n");
 		goto err2;
 	}
+	
+	if (mod->size < 0)
+		goto err2;
 
 	/* Make sure all interesting pointers are sane.  */
 
@@ -609,13 +616,13 @@ sys_init_module(const char *name_user, s
 err3:
 	put_mod_name(n_name);
 err2:
-	if (mod2)
-		vfree(mod2);
 	*mod = mod_tmp;
 	strcpy((char *)mod->name, name_tmp);	/* We know there is room for this */
 err1:
 	put_mod_name(name);
 err0:
+	if (mod2)
+		vfree(mod2);
 	unlock_kernel();
 	kfree(name_tmp);
 	return error;
diff -urNp linux-9020/kernel/ptrace.c linux-9030/kernel/ptrace.c
--- linux-9020/kernel/ptrace.c
+++ linux-9030/kernel/ptrace.c
@@ -186,6 +186,7 @@ int access_process_vm(struct task_struct
 			memcpy(maddr + offset, buf, bytes);
 			flush_page_to_ram(page);
 			flush_icache_user_range(vma, page, addr, bytes);
+			set_page_dirty(page);
 		} else {
 			memcpy(buf, maddr + offset, bytes);
 			flush_page_to_ram(page);
diff -urNp linux-9020/kernel/softirq.c linux-9030/kernel/softirq.c
--- linux-9020/kernel/softirq.c
+++ linux-9030/kernel/softirq.c
@@ -63,12 +63,23 @@ static inline void wakeup_softirqd(unsig
 		wake_up_process(tsk);
 }
 
+/*
+ * We restart softirq processing MAX_SOFTIRQ_RESTART times,
+ * and we fall back to softirqd after that.
+ *
+ * This number has been established via experimentation.
+ * The two things to balance is latency against fairness -
+ * we want to handle softirqs as soon as possible, but they
+ * should not be able to lock up the box.
+ */
+#define MAX_SOFTIRQ_RESTART 10
+
 asmlinkage void do_softirq()
 {
+	int max_restart = MAX_SOFTIRQ_RESTART;
 	int cpu = smp_processor_id();
 	__u32 pending;
 	unsigned long flags;
-	__u32 mask;
 
 	if (in_interrupt())
 		return;
@@ -95,7 +106,6 @@ asmlinkage void do_softirq()
 		}
 #endif /* !CONFIG_PARISC && !CONFIG_ARCH_S390 */
 
-		mask = ~pending;
 		local_bh_disable();
 restart:
 		/* Reset the pending bitmask before enabling irqs */
@@ -115,10 +125,8 @@ restart:
 		local_irq_disable();
 
 		pending = softirq_pending(cpu);
-		if (pending & mask) {
-			mask &= ~pending;
+		if (pending && --max_restart)
 			goto restart;
-		}
 		__local_bh_enable();
 
 		if (pending)
diff -urNp linux-9020/kernel/sys.c linux-9030/kernel/sys.c
--- linux-9020/kernel/sys.c
+++ linux-9030/kernel/sys.c
@@ -74,6 +74,7 @@ extern int system_running;
  *	and the like. 
  */
 
+static int reboot_in_progress;
 static struct notifier_block *reboot_notifier_list;
 rwlock_t notifier_lock = RW_LOCK_UNLOCKED;
 
@@ -367,6 +368,8 @@ asmlinkage long sys_reboot(int magic1, i
 	lock_kernel();
 	switch (cmd) {
 	case LINUX_REBOOT_CMD_RESTART:
+		if (reboot_in_progress++)
+			goto nested_reboot_error;
 		notifier_call_chain(&reboot_notifier_list, SYS_RESTART, NULL);
 		printk(KERN_EMERG "Restarting system.\n");
 		machine_restart(NULL);
@@ -381,6 +384,8 @@ asmlinkage long sys_reboot(int magic1, i
 		break;
 
 	case LINUX_REBOOT_CMD_HALT:
+		if (reboot_in_progress++)
+			goto nested_reboot_error;
 		notifier_call_chain(&reboot_notifier_list, SYS_HALT, NULL);
 		printk(KERN_EMERG "System halted.\n");
 		machine_halt();
@@ -388,6 +393,8 @@ asmlinkage long sys_reboot(int magic1, i
 		break;
 
 	case LINUX_REBOOT_CMD_POWER_OFF:
+		if (reboot_in_progress++)
+			goto nested_reboot_error;
 		notifier_call_chain(&reboot_notifier_list, SYS_POWER_OFF, NULL);
 		printk(KERN_EMERG "Power down.\n");
 		machine_power_off();
@@ -401,6 +408,8 @@ asmlinkage long sys_reboot(int magic1, i
 		}
 		buffer[sizeof(buffer) - 1] = '\0';
 
+		if (reboot_in_progress++)
+			goto nested_reboot_error;
 		notifier_call_chain(&reboot_notifier_list, SYS_RESTART, buffer);
 		printk(KERN_EMERG "Restarting system with command '%s'.\n", buffer);
 		machine_restart(buffer);
@@ -412,11 +421,16 @@ asmlinkage long sys_reboot(int magic1, i
 	}
 	unlock_kernel();
 	return 0;
+
+nested_reboot_error:
+	unlock_kernel();
+	return -EBUSY;
 }
 
 static void deferred_cad(void *dummy)
 {
-	notifier_call_chain(&reboot_notifier_list, SYS_RESTART, NULL);
+	if (!reboot_in_progress++)
+		notifier_call_chain(&reboot_notifier_list, SYS_RESTART, NULL);
 	machine_restart(NULL);
 }
 
@@ -1232,6 +1246,8 @@ asmlinkage long sys_setrlimit(unsigned i
 		return -EINVAL;
 	if(copy_from_user(&new_rlim, rlim, sizeof(*rlim)))
 		return -EFAULT;
+       if (new_rlim.rlim_cur > new_rlim.rlim_max)
+               return -EINVAL;
 	old_rlim = current->rlim + resource;
 	if (((new_rlim.rlim_cur > old_rlim->rlim_max) ||
 	     (new_rlim.rlim_max > old_rlim->rlim_max)) &&
diff -urNp linux-9020/lib/inflate.c linux-9030/lib/inflate.c
--- linux-9020/lib/inflate.c
+++ linux-9030/lib/inflate.c
@@ -368,6 +368,7 @@ DEBG("huft5 ");
     if ((j = *p++) != 0)
       v[x[j]++] = i;
   } while (++i < n);
+  n = x[g];			/* set n to length of v */
 
 DEBG("h6 ");
 
@@ -404,13 +405,14 @@ DEBG1("1 ");
 DEBG1("2 ");
           f -= a + 1;           /* deduct codes from patterns left */
           xp = c + k;
-          while (++j < z)       /* try smaller tables up to z bits */
-          {
-            if ((f <<= 1) <= *++xp)
-              break;            /* enough codes to use up j bits */
-            f -= *xp;           /* else deduct codes from patterns */
+	  if (j < z)
+            while (++j < z)       /* try smaller tables up to z bits */
+            {
+              if ((f <<= 1) <= *++xp)
+                break;            /* enough codes to use up j bits */
+              f -= *xp;           /* else deduct codes from patterns */
+            }
           }
-        }
 DEBG1("3 ");
         z = 1 << j;             /* table entries for j-bit table */
 
diff -urNp linux-9020/mm/filemap.c linux-9030/mm/filemap.c
--- linux-9020/mm/filemap.c
+++ linux-9030/mm/filemap.c
@@ -1648,6 +1648,8 @@ page_not_up_to_date:
 			UnlockPage(page);
 			goto page_ok;
 		}
+		/* Get rid of any stale I/O errors */
+		ClearPageError(page);
 
 readpage:
 		/* ... and start the actual read. The read will unlock the page. */
diff -urNp linux-9020/mm/memory.c linux-9030/mm/memory.c
--- linux-9020/mm/memory.c
+++ linux-9030/mm/memory.c
@@ -1716,6 +1716,13 @@ static int do_swap_page(struct mm_struct
 	}
 	lock_page(page);
 
+	if (!Page_Uptodate(page)) {
+		unlock_page(page);
+		page_cache_release(page);
+		pte_chain_free(pte_chain);
+		return 0;
+	}
+
 	/*
 	 * Back out if somebody else faulted in this pte while we
 	 * released the page table lock.
diff -urNp linux-9020/mm/shmem.c linux-9030/mm/shmem.c
--- linux-9020/mm/shmem.c
+++ linux-9030/mm/shmem.c
@@ -1111,7 +1111,6 @@ static void do_shmem_file_read(struct fi
 	struct address_space *mapping = inode->i_mapping;
 	unsigned long index, offset;
 	loff_t pos = *ppos;
-	int nr = 1;
 
 	if (unlikely(pos < 0))
 		return;
@@ -1119,9 +1118,10 @@ static void do_shmem_file_read(struct fi
 	index = pos >> PAGE_CACHE_SHIFT;
 	offset = pos & ~PAGE_CACHE_MASK;
 
-	while (nr && desc->count) {
+	for (;;) {
 		struct page *page;
-		unsigned long end_index, nr;
+		unsigned long end_index;
+		int nr, ret;
 
 		end_index = inode->i_size >> PAGE_CACHE_SHIFT;
 		if (index > end_index)
@@ -1132,10 +1132,10 @@ static void do_shmem_file_read(struct fi
 			if (nr <= offset)
 				break;
 		}
+		nr -= offset;
 
-		nr = nr - offset;
-
-		if ((desc->error = shmem_getpage(inode, index, &page)))
+		desc->error = shmem_getpage(inode, index, &page);
+		if (desc->error)
 			break;
 
 		if (mapping->i_mmap_shared != NULL)
@@ -1151,12 +1151,14 @@ static void do_shmem_file_read(struct fi
 		 * "pos" here (the actor routine has to update the user buffer
 		 * pointers and the remaining count).
 		 */
-		nr = file_read_actor(desc, page, offset, nr);
-		offset += nr;
+		ret = file_read_actor(desc, page, offset, nr);
+		offset += ret;
 		index += offset >> PAGE_CACHE_SHIFT;
 		offset &= ~PAGE_CACHE_MASK;
 	
 		page_cache_release(page);
+		if (nr != ret || !desc->count)
+			break;
 	}
 
 	*ppos = ((loff_t) index << PAGE_CACHE_SHIFT) + offset;
diff -urNp linux-9020/mm/swapfile.c linux-9030/mm/swapfile.c
--- linux-9020/mm/swapfile.c
+++ linux-9030/mm/swapfile.c
@@ -734,7 +734,7 @@ asmlinkage long sys_swapoff(const char *
 	if(IS_ERR(tmp))
 		return PTR_ERR(tmp);
 		
-	victim = filp_open(tmp, O_RDWR, 0);
+	victim = filp_open(tmp, O_RDWR | O_LARGEFILE, 0);
 	err = PTR_ERR(victim);
 	if (IS_ERR(victim))
 		goto out;
diff -urNp linux-9020/mm/vmalloc.c linux-9030/mm/vmalloc.c
--- linux-9020/mm/vmalloc.c
+++ linux-9030/mm/vmalloc.c
@@ -266,6 +266,9 @@ void vfree(void * addr)
 	}
 	write_unlock(&vmlist_lock);
 	printk(KERN_ERR "Trying to vfree() nonexistent vm area (%p)\n", addr);
+#ifdef __i386__	
+	show_stack(NULL);
+#endif	
 }
 
 void * __vmalloc (unsigned long size, int gfp_mask, pgprot_t prot)
@@ -295,7 +298,7 @@ void * vmap(struct page **pages, int cou
 	struct vm_struct *area;
 	unsigned long size = count << PAGE_SHIFT;
 
-	if (!size || size > (max_mapnr << PAGE_SHIFT))
+	if (!size || count > max_mapnr)
 		return NULL;
 	area = get_vm_area(size, flags);
 	if (!area) {
diff -urNp linux-9020/net/appletalk/ddp.c linux-9030/net/appletalk/ddp.c
--- linux-9020/net/appletalk/ddp.c
+++ linux-9030/net/appletalk/ddp.c
@@ -978,6 +978,23 @@ static int atrtr_ioctl(unsigned int cmd,
 
 	if (copy_from_user(&rt, arg, sizeof(rt)))
 		return -EFAULT;
+		
+	if(rt.rt_dev)
+	{
+		char *colon;
+		struct net_device *dev;
+		char   devname[IFNAMSIZ];
+
+		if (copy_from_user(devname, rt.rt_dev, IFNAMSIZ-1))
+			return -EFAULT;
+		devname[IFNAMSIZ-1] = 0;
+		colon = strchr(devname, ':');
+		if (colon)
+			*colon = 0;
+		dev = __dev_get_by_name(devname);
+		if(dev == NULL)
+			return -ENODEV;
+	}
 
 	switch (cmd) {
 		case SIOCDELRT:
@@ -987,13 +1004,6 @@ static int atrtr_ioctl(unsigned int cmd,
 						&rt.rt_dst)->sat_addr);
 
 		case SIOCADDRT:
-			/* FIXME: the name of the device is still in user
-			 * space, isn't it? */
-			if (rt.rt_dev) {
-				dev = __dev_get_by_name(rt.rt_dev);
-				if (!dev)
-					return -ENODEV;
-			}			
 			return atrtr_create(&rt, dev);
 	}
 	return -EINVAL;
diff -urNp linux-9020/net/sunrpc/sched.c linux-9030/net/sunrpc/sched.c
--- linux-9020/net/sunrpc/sched.c
+++ linux-9030/net/sunrpc/sched.c
@@ -707,7 +707,7 @@ rpc_allocate(unsigned int flags, unsigne
 	else if (flags & RPC_TASK_ASYNC)
 		gfp = GFP_RPC;
 	else
-		gfp = GFP_KERNEL;
+		gfp = GFP_NOFS;
 
 	do {
 		if ((buffer = (u32 *) kmalloc(size, gfp)) != NULL) {
@@ -721,7 +721,8 @@ rpc_allocate(unsigned int flags, unsigne
 		}
 		if (flags & RPC_TASK_ASYNC)
 			return NULL;
-		yield();
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ/50);
 	} while (!signalled());
 
 	return NULL;
diff -urNp linux-9020/net/sunrpc/svcsock.c linux-9030/net/sunrpc/svcsock.c
--- linux-9020/net/sunrpc/svcsock.c
+++ linux-9030/net/sunrpc/svcsock.c
@@ -1001,7 +1001,7 @@ svc_tcp_init(struct svc_sock *svsk)
 				    3 * svsk->sk_server->sv_bufsz);
 
 		set_bit(SK_CHNGBUF, &svsk->sk_flags);
-		if (sk->sk_state != TCP_ESTABLISHED) 
+		if (sk->state != TCP_ESTABLISHED) 
 			set_bit(SK_CLOSE, &svsk->sk_flags);
 	}
 
