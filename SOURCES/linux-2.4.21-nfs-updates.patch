diff -urNp linux-6080/fs/lockd/clntproc.c linux-6090/fs/lockd/clntproc.c
--- linux-6080/fs/lockd/clntproc.c
+++ linux-6090/fs/lockd/clntproc.c
@@ -146,7 +146,7 @@ nlmclnt_proc(struct inode *inode, int cm
 	 * perform the RPC call asynchronously. */
 	if ((IS_SETLK(cmd) || IS_SETLKW(cmd))
 	    && fl->fl_type == F_UNLCK
-	    && (current->flags & PF_EXITING)) {
+	    && ((current->flags & PF_EXITING) || signalled())) {
 		sigfillset(&current->blocked);	/* Mask all signals */
 		recalc_sigpending();
 		spin_unlock_irqrestore(&current->sighand->siglock, flags);
diff -urNp linux-6080/fs/locks.c linux-6090/fs/locks.c
--- linux-6080/fs/locks.c
+++ linux-6090/fs/locks.c
@@ -1766,7 +1766,14 @@ void locks_remove_posix(struct file *fil
 	before = &inode->i_flock;
 	while ((fl = *before) != NULL) {
 		if ((fl->fl_flags & FL_POSIX) && fl->fl_owner == owner) {
+			struct file *filp = fl->fl_file;
+			/* Note: locks_unlock_delete() can sleep, and
+			 * so we may race with the call to sys_close()
+			 * by the thread that actually owns this filp.
+			 */
+			get_file(filp);
 			locks_unlock_delete(before);
+			fput(filp);
 			before = &inode->i_flock;
 			continue;
 		}
diff -urNp linux-6080/fs/nfs/dir.c linux-6090/fs/nfs/dir.c
--- linux-6080/fs/nfs/dir.c
+++ linux-6090/fs/nfs/dir.c
@@ -493,7 +493,7 @@ int nfs_check_verifier(struct inode *dir
 		return 1;
 	if (nfs_revalidate_inode(NFS_SERVER(dir), dir))
 		return 0;
-	return time_after(dentry->d_time, NFS_MTIME_UPDATE(dir));
+	return time_after_eq(dentry->d_time, NFS_MTIME_UPDATE(dir));
 }
 
 /*
@@ -628,6 +628,11 @@ static int nfs_dentry_delete(struct dent
 		/* Unhash it, so that ->d_iput() would be called */
 		return 1;
 	}
+	if (!(dentry->d_sb->s_flags & MS_ACTIVE)) {
+		/* Unhash it, so that ancestors of killed async unlink
+		 * files will be cleaned up during umount */
+		return 1;
+	}
 	return 0;
 
 }
@@ -777,7 +782,7 @@ int nfs_cached_lookup(struct inode *dir,
 /*
  * Code common to create, mkdir, and mknod.
  */
-static int nfs_instantiate(struct dentry *dentry, struct nfs_fh *fhandle,
+int nfs_instantiate(struct dentry *dentry, struct nfs_fh *fhandle,
 				struct nfs_fattr *fattr)
 {
 	struct inode *inode;
@@ -787,20 +792,14 @@ static int nfs_instantiate(struct dentry
 		struct inode *dir = dentry->d_parent->d_inode;
 		error = NFS_PROTO(dir)->lookup(dir, &dentry->d_name, fhandle, fattr);
 		if (error)
-			goto out_err;
+			return error;
 	}
 	inode = nfs_fhget(dentry, fhandle, fattr);
 	if (inode) {
 		d_instantiate(dentry, inode);
 		nfs_renew_times(dentry);
-	} else {
+	} else
 		error = -ENOMEM;
-		goto out_err;
-	}
-	return error;
-
-out_err:
-	d_drop(dentry);
 	return error;
 }
 
@@ -813,8 +812,6 @@ out_err:
 static int nfs_create(struct inode *dir, struct dentry *dentry, int mode)
 {
 	struct iattr attr;
-	struct nfs_fattr fattr;
-	struct nfs_fh fhandle;
 	int error;
 
 	dfprintk(VFS, "NFS: create(%x/%ld, %s\n",
@@ -830,11 +827,8 @@ static int nfs_create(struct inode *dir,
 	 * does not pass the create flags.
 	 */
 	nfs_zap_caches(dir);
-	error = NFS_PROTO(dir)->create(dir, &dentry->d_name,
-					 &attr, 0, &fhandle, &fattr);
-	if (!error)
-		error = nfs_instantiate(dentry, &fhandle, &fattr);
-	else
+	error = NFS_PROTO(dir)->create(dir, dentry, &attr, 0);
+	if (error)
 		d_drop(dentry);
 	return error;
 }
@@ -860,7 +854,7 @@ static int nfs_mknod(struct inode *dir, 
 					&fhandle, &fattr);
 	if (!error)
 		error = nfs_instantiate(dentry, &fhandle, &fattr);
-	else
+	if (error)
 		d_drop(dentry);
 	return error;
 }
@@ -895,7 +889,7 @@ static int nfs_mkdir(struct inode *dir, 
 					&fattr);
 	if (!error)
 		error = nfs_instantiate(dentry, &fhandle, &fattr);
-	else
+	if (error)
 		d_drop(dentry);
 	return error;
 }
@@ -1026,7 +1020,10 @@ static int nfs_safe_remove(struct dentry
 	if (inode)
 		NFS_CACHEINV(inode);
 	error = NFS_PROTO(dir)->remove(dir, &dentry->d_name);
-	if (error < 0)
+
+	/* if server returned ENOENT, assume that the dentry is already gone
+	 * and update the cache accordingly */
+	if (error < 0 && error != -ENOENT)
 		goto out;
 	if (inode)
 		inode->i_nlink--;
@@ -1106,8 +1103,9 @@ dentry->d_parent->d_name.name, dentry->d
 		if (error == -EEXIST)
 			printk("nfs_proc_symlink: %s/%s already exists??\n",
 			       dentry->d_parent->d_name.name, dentry->d_name.name);
-		d_drop(dentry);
 	}
+	if (error)
+		d_drop(dentry);
 
 out:
 	return error;
@@ -1191,9 +1189,11 @@ static int nfs_rename(struct inode *old_
 	 */
 	if (!new_inode)
 		goto go_ahead;
-	if (S_ISDIR(new_inode->i_mode))
-		goto out;
-	else if (atomic_read(&new_dentry->d_count) > 1) {
+	if (S_ISDIR(new_inode->i_mode)) {
+		error = -EISDIR;
+		if (!S_ISDIR(old_inode->i_mode))
+			goto out;
+	} else if (atomic_read(&new_dentry->d_count) > 1) {
 		int err;
 		/* copy the target dentry's name */
 		dentry = d_alloc(new_dentry->d_parent,
@@ -1238,6 +1238,12 @@ go_ahead:
 	nfs_zap_caches(old_dir);
 	error = NFS_PROTO(old_dir)->rename(old_dir, &old_dentry->d_name,
 					   new_dir, &new_dentry->d_name);
+	/*
+	 * Invalidate the attribute cache so we pick up attributes changed
+	 * by the server during the RENAME operation.  Note that attributes
+	 * can change even if an error is returned (NFSERR_MLINK, eg).
+	 */
+	NFS_CACHEINV(old_inode);
 out:
 	if (rehash)
 		d_rehash(rehash);
diff -urNp linux-6080/fs/nfs/file.c linux-6090/fs/nfs/file.c
--- linux-6080/fs/nfs/file.c
+++ linux-6090/fs/nfs/file.c
@@ -91,7 +91,7 @@ nfs_file_flush(struct file *file)
 	if (file->f_mode & FMODE_READ)
 		nfs_pagein_inode(inode, 0, 0);
 
-	status = nfs_wb_file(inode, file);
+	status = nfs_wb_all(inode);
 	if (!status) {
 		status = file->f_error;
 		file->f_error = 0;
@@ -173,7 +173,7 @@ nfs_fsync(struct file *file, struct dent
 	dfprintk(VFS, "nfs: fsync(%x/%ld)\n", inode->i_dev, inode->i_ino);
 
 	lock_kernel();
-	status = nfs_wb_file(inode, file);
+	status = nfs_wb_all(inode);
 	if (!status) {
 		status = file->f_error;
 		file->f_error = 0;
@@ -283,6 +283,96 @@ out_swapfile:
 	goto out;
 }
 
+static int
+do_getlk(struct inode *inode, int cmd, struct file_lock *fl)
+{
+	int status;
+
+	lock_kernel();
+	status = nlmclnt_proc(inode, cmd, fl);
+	unlock_kernel();
+	return status;
+}
+
+static int
+do_unlk(struct inode *inode, int cmd, struct file_lock *fl)
+{
+	sigset_t oldset;
+	int status;
+
+	rpc_clnt_sigmask(NFS_CLIENT(inode), &oldset);
+	/*
+	 * Flush all pending writes before doing anything
+	 * with locks..
+	 */
+	filemap_fdatasync(inode->i_mapping);
+	down(&inode->i_sem);
+	nfs_wb_all(inode);
+	up(&inode->i_sem);
+	filemap_fdatawait(inode->i_mapping);
+
+	/* NOTE: special case
+	 *	If we're signalled while cleaning up locks on process exit, we
+	 *	still need to complete the unlock.
+	 */
+	lock_kernel();
+	status = nlmclnt_proc(inode, cmd, fl);
+	unlock_kernel();
+	rpc_clnt_sigunmask(NFS_CLIENT(inode), &oldset);
+	return status;
+}
+
+static int
+do_setlk(struct file *filp, int cmd, struct file_lock *fl)
+{
+	struct inode * inode = filp->f_dentry->d_inode;
+	int status;
+
+	/*
+	 * Flush all pending writes before doing anything
+	 * with locks..
+	 */
+	status = filemap_fdatasync(inode->i_mapping);
+	if (status == 0) {
+		down(&inode->i_sem);
+		status = nfs_wb_all(inode);
+		up(&inode->i_sem);
+		if (status == 0)
+			status = filemap_fdatawait(inode->i_mapping);
+	}
+	if (status < 0)
+		return status;
+
+	lock_kernel();
+	status = nlmclnt_proc(inode, cmd, fl);
+	/* If we were signalled we still need to ensure that
+	 * we clean up any state on the server. We therefore
+	 * record the lock call as having succeeded in order to
+	 * ensure that locks_remove_posix() cleans it out when
+	 * the process exits.
+	 */
+	if (status == -EINTR || status == -ERESTARTSYS) {
+		fl->fl_type = F_UNLCK;
+		nlmclnt_proc(inode, cmd, fl);
+	} 
+
+	unlock_kernel();
+	if (status < 0)
+		return status;
+
+	/*
+	 * Make sure we clear the cache whenever we try to get the lock.
+	 * This makes locking act as a cache coherency point.
+	 */
+	filemap_fdatasync(inode->i_mapping);
+	down(&inode->i_sem);
+	nfs_wb_all(inode);      /* we may have slept */
+	up(&inode->i_sem);
+	filemap_fdatawait(inode->i_mapping);
+	nfs_zap_caches(inode);
+	return 0;
+}
+
 /*
  * Lock a (portion of) a file
  */
@@ -290,8 +380,6 @@ int
 nfs_lock(struct file *filp, int cmd, struct file_lock *fl)
 {
 	struct inode * inode = filp->f_dentry->d_inode;
-	int	status = 0;
-	int	status2;
 
 	dprintk("NFS: nfs_lock(f=%4x/%ld, t=%x, fl=%x, r=%Ld:%Ld)\n",
 			inode->i_dev, inode->i_ino,
@@ -308,8 +396,8 @@ nfs_lock(struct file *filp, int cmd, str
 	/* Fake OK code if mounted without NLM support */
 	if (NFS_SERVER(inode)->flags & NFS_MOUNT_NONLM) {
 		if (IS_GETLK(cmd))
-			status = LOCK_USE_CLNT;
-		goto out_ok;
+			return LOCK_USE_CLNT;
+		return 0;
 	}
 
 	/*
@@ -322,42 +410,9 @@ nfs_lock(struct file *filp, int cmd, str
 	if (!fl->fl_owner || (fl->fl_flags & (FL_POSIX|FL_BROKEN)) != FL_POSIX)
 		return -ENOLCK;
 
-	/*
-	 * Flush all pending writes before doing anything
-	 * with locks..
-	 */
-	status = filemap_fdatasync(inode->i_mapping);
-	down(&inode->i_sem);
-	status2 = nfs_wb_all(inode);
-	if (status2 && !status)
-		status = status2;
-	up(&inode->i_sem);
-	status2 = filemap_fdatawait(inode->i_mapping);
-	if (status2 && !status)
-		status = status2;
-	if (status < 0)
-		return status;
-
-	lock_kernel();
-	status = nlmclnt_proc(inode, cmd, fl);
-	unlock_kernel();
-	if (status < 0)
-		return status;
-	
-	status = 0;
-
-	/*
-	 * Make sure we clear the cache whenever we try to get the lock.
-	 * This makes locking act as a cache coherency point.
-	 */
- out_ok:
-	if ((IS_SETLK(cmd) || IS_SETLKW(cmd)) && fl->fl_type != F_UNLCK) {
-		filemap_fdatasync(inode->i_mapping);
-		down(&inode->i_sem);
-		nfs_wb_all(inode);      /* we may have slept */
-		up(&inode->i_sem);
-		filemap_fdatawait(inode->i_mapping);
-		nfs_zap_caches(inode);
-	}
-	return status;
+	if (IS_GETLK(cmd))
+		return do_getlk(inode, cmd, fl);
+	if (fl->fl_type == F_UNLCK)
+		return do_unlk(inode, cmd, fl);
+	return do_setlk(filp, cmd, fl);
 }
diff -urNp linux-6080/fs/nfs/inode.c linux-6090/fs/nfs/inode.c
--- linux-6080/fs/nfs/inode.c
+++ linux-6090/fs/nfs/inode.c
@@ -184,7 +184,7 @@ nfs_write_inode(struct inode *inode, int
 {
 	int flags = sync ? FLUSH_WAIT : 0;
 
-	nfs_sync_file(inode, NULL, 0, 0, flags);
+	nfs_sync_file(inode, 0, 0, flags);
 }
 
 static void
@@ -638,6 +638,7 @@ out_fail:
 	return NULL;
 }
 
+#define TOOBIG(_arg) ((_arg) > LONG_MAX)
 static int
 nfs_statfs(struct super_block *sb, struct statfs *buf)
 {
@@ -650,24 +651,44 @@ nfs_statfs(struct super_block *sb, struc
 
 	error = server->rpc_ops->statfs(server, NFS_FH(sb->s_root->d_inode), &res);
 	buf->f_type = NFS_SUPER_MAGIC;
-	if (error < 0)
+	if (error < 0) {
+		printk("nfs_statfs: statfs error = %d\n", -error);
 		goto out_err;
+	}
 
 	buf->f_bsize = sb->s_blocksize;
 	blockbits = sb->s_blocksize_bits;
 	blockres = (1 << blockbits) - 1;
+	buf->f_namelen = server->namelen;
+
+	/*
+	 * Make sure things fit
+	 */
+	if (TOOBIG(((res.tbytes + blockres) >> blockbits)))
+		goto too_big;
+	if (TOOBIG(((res.fbytes + blockres) >> blockbits)))
+		goto too_big;
+	if (TOOBIG(((res.abytes + blockres) >> blockbits)))
+		goto too_big;
+	if (TOOBIG(res.tfiles) || TOOBIG(res.afiles))
+		goto too_big;
+
 	buf->f_blocks = (res.tbytes + blockres) >> blockbits;
 	buf->f_bfree = (res.fbytes + blockres) >> blockbits;
 	buf->f_bavail = (res.abytes + blockres) >> blockbits;
 	buf->f_files = res.tfiles;
 	buf->f_ffree = res.afiles;
-	buf->f_namelen = server->namelen;
 	return 0;
+
+ too_big:
+ 	dprintk("nfs_statfs: failed: EOVERFLOW\n");
+	buf->f_files = buf->f_ffree = -1;
+
  out_err:
-	printk("nfs_statfs: statfs error = %d\n", -error);
 	buf->f_bsize = buf->f_blocks = buf->f_bfree = buf->f_bavail = -1;
 	return 0;
 }
+#undef TOOBIG
 
 static int nfs_show_options(struct seq_file *m, struct vfsmount *mnt)
 {
@@ -1244,6 +1265,15 @@ __nfs_refresh_inode(struct inode *inode,
 	}
 
 	/*
+	 * Set the invalid flag if the last attempt at invalidating
+	 * the inode didn't empty the clean_pages list.
+	 */
+	if (NFS_FLAGS(inode) & NFS_INO_MAPPED) {
+		NFS_FLAGS(inode) &= ~NFS_INO_MAPPED;
+		invalid = 1;
+	}
+
+	/*
 	 * If we have pending writebacks, things can get
 	 * messy.
 	 */
@@ -1299,6 +1329,12 @@ __nfs_refresh_inode(struct inode *inode,
 		NFS_ATTRTIMEO(inode) = NFS_MINATTRTIMEO(inode);
 		NFS_ATTRTIMEO_UPDATE(inode) = jiffies;
 		invalidate_inode_pages(inode);
+		if (!list_empty(&inode->i_mapping->clean_pages)) {
+			dfprintk(PAGECACHE,
+				 "NFS: clean_pages for %x/%lu is not empty\n",
+				 inode->i_dev, inode->i_ino);
+			NFS_FLAGS(inode) |= NFS_INO_MAPPED;
+		}
 		memset(NFS_COOKIEVERF(inode), 0, sizeof(NFS_COOKIEVERF(inode)));
 	} else if (time_after(jiffies, NFS_ATTRTIMEO_UPDATE(inode)+NFS_ATTRTIMEO(inode))) {
 		if ((NFS_ATTRTIMEO(inode) <<= 1) > NFS_MAXATTRTIMEO(inode))
diff -urNp linux-6080/fs/nfs/nfs2xdr.c linux-6090/fs/nfs/nfs2xdr.c
--- linux-6080/fs/nfs/nfs2xdr.c
+++ linux-6090/fs/nfs/nfs2xdr.c
@@ -572,8 +572,11 @@ nfs_xdr_readlinkres(struct rpc_rqst *req
 	strlen = (u32*)kmap_atomic(rcvbuf->pages[0], KM_USER0);
 	/* Convert length of symlink */
 	len = ntohl(*strlen);
-	if (len > rcvbuf->page_len)
-		len = rcvbuf->page_len;
+	if (len >= rcvbuf->page_len - sizeof(u32) || len > NFS2_MAXPATHLEN) {
+		dprintk("NFS: READLINK server returned giant symlink!\n");
+		kunmap(rcvbuf->pages[0]);
+		return -ENAMETOOLONG;
+        }
 	*strlen = len;
 	/* NULL terminate the string we got */
 	string = (char *)(strlen + 1);
diff -urNp linux-6080/fs/nfs/nfs3proc.c linux-6090/fs/nfs/nfs3proc.c
--- linux-6080/fs/nfs/nfs3proc.c
+++ linux-6090/fs/nfs/nfs3proc.c
@@ -18,6 +18,11 @@
 
 #define NFSDBG_FACILITY		NFSDBG_PROC
 
+#ifdef CONFIG_NFS_ACL
+static int nfs3_proc_set_default_acl(struct inode *dir, struct inode *inode,
+					mode_t mode);
+#endif
+
 /* A wrapper to handle the EJUKEBOX error message */
 static int
 nfs3_rpc_wrapper(struct rpc_clnt *clnt, struct rpc_message *msg, int flags)
@@ -46,6 +51,7 @@ nfs3_rpc_call_wrapper(struct rpc_clnt *c
 
 #define rpc_call(clnt, proc, argp, resp, flags) \
 		nfs3_rpc_call_wrapper(clnt, proc, argp, resp, flags)
+#undef rpc_call_sync
 #define rpc_call_sync(clnt, msg, flags) \
 		nfs3_rpc_wrapper(clnt, msg, flags)
 
@@ -246,16 +252,20 @@ nfs3_proc_write(struct inode *inode, str
  * For now, we don't implement O_EXCL.
  */
 static int
-nfs3_proc_create(struct inode *dir, struct qstr *name, struct iattr *sattr,
-		 int flags, struct nfs_fh *fhandle, struct nfs_fattr *fattr)
+nfs3_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,
+		 int flags)
 {
+	struct nfs_fh		fhandle;
+	struct nfs_fattr	fattr;
 	struct nfs_fattr	dir_attr;
-	struct nfs3_createargs	arg = { NFS_FH(dir), name->name, name->len,
+	struct nfs3_createargs	arg = { NFS_FH(dir), dentry->d_name.name,
+					dentry->d_name.len,
 					sattr, 0, { 0, 0 } };
-	struct nfs3_diropres	res = { &dir_attr, fhandle, fattr };
+	struct nfs3_diropres	res = { &dir_attr, &fhandle, &fattr };
+	mode_t			mode = sattr->ia_mode;
 	int			status;
 
-	dprintk("NFS call  create %s\n", name->name);
+	dprintk("NFS call  create %s\n", dentry->d_name.name);
 	arg.createmode = NFS3_CREATE_UNCHECKED;
 	if (flags & O_EXCL) {
 		arg.createmode  = NFS3_CREATE_EXCLUSIVE;
@@ -265,7 +275,7 @@ nfs3_proc_create(struct inode *dir, stru
 
 again:
 	dir_attr.valid = 0;
-	fattr->valid = 0;
+	fattr.valid = 0;
 	status = rpc_call(NFS_CLIENT(dir), NFS3PROC_CREATE, &arg, &res, 0);
 	nfs_refresh_inode(dir, &dir_attr);
 
@@ -288,23 +298,31 @@ again:
 	}
 
 exit:
-	dprintk("NFS reply create: %d\n", status);
+	if (status == 0)
+		status = nfs_instantiate(dentry, &fhandle, &fattr);
+	if (status != 0)
+		goto out;
 
 	/* When we created the file with exclusive semantics, make
 	 * sure we set the attributes afterwards. */
 	if (status == 0 && arg.createmode == NFS3_CREATE_EXCLUSIVE) {
-		struct nfs3_sattrargs	arg = { fhandle, sattr, 0, 0 };
+		struct nfs3_sattrargs	arg = { &fhandle, sattr, 0, 0 };
 		dprintk("NFS call  setattr (post-create)\n");
 
 		/* Note: we could use a guarded setattr here, but I'm
 		 * not sure this buys us anything (and I'd have
 		 * to revamp the NFSv3 XDR code) */
-		fattr->valid = 0;
+		fattr.valid = 0;
 		status = rpc_call(NFS_CLIENT(dir), NFS3PROC_SETATTR,
-						&arg, fattr, 0);
+						&arg, &fattr, 0);
 		dprintk("NFS reply setattr (post-create): %d\n", status);
 	}
-
+#ifdef CONFIG_NFS_ACL
+	if (status == 0)
+		status = nfs3_proc_set_default_acl(dir, dentry->d_inode, mode);
+#endif
+out:
+	dprintk("NFS reply create: %d\n", status);
 	return status;
 }
 
@@ -508,7 +526,7 @@ nfs3_proc_mknod(struct inode *dir, struc
 	default:	return -EINVAL;
 	}
 
-	dprintk("NFS call  mknod %s %x\n", name->name, rdev);
+	dprintk("NFS call  mknod %s %lx\n", name->name, (unsigned long)rdev);
 	dir_attr.valid = 0;
 	fattr->valid = 0;
 	status = rpc_call(NFS_CLIENT(dir), NFS3PROC_MKNOD, &arg, &res, 0);
@@ -788,6 +806,36 @@ cleanup:
 }
 #endif  /* CONFIG_NFS_ACL */
 
+#ifdef CONFIG_NFS_ACL
+static int
+nfs3_proc_set_default_acl(struct inode *dir, struct inode *inode, mode_t mode)
+{
+	struct posix_acl *dfacl, *acl;
+	int error = 0;
+
+	dfacl = nfs3_proc_getacl(dir, ACL_TYPE_DEFAULT);
+	if (IS_ERR(dfacl)) {
+		error = PTR_ERR(dfacl);
+		return (error == -EOPNOTSUPP) ? 0 : error;
+	}
+	if (!dfacl)
+		return 0;
+	acl = posix_acl_clone(dfacl, GFP_KERNEL);
+	error = -ENOMEM;
+	if (!acl)
+		goto out_release_dfacl;
+	error = posix_acl_create_masq(acl, &mode);
+	if (error < 0)
+		goto out_release_acl;
+	error = nfs3_proc_setacl(inode, ACL_TYPE_ACCESS, acl);
+out_release_acl:
+	posix_acl_release(acl);
+out_release_dfacl:
+	posix_acl_release(dfacl);
+	return error;
+}
+#endif	/* CONFIG_NFS_ACL */
+
 extern u32 *nfs3_decode_dirent(u32 *, struct nfs_entry *, int);
 
 struct nfs_rpc_ops	nfs_v3_clientops = {
diff -urNp linux-6080/fs/nfs/nfs3xdr.c linux-6090/fs/nfs/nfs3xdr.c
--- linux-6080/fs/nfs/nfs3xdr.c
+++ linux-6090/fs/nfs/nfs3xdr.c
@@ -827,8 +827,11 @@ nfs3_xdr_readlinkres(struct rpc_rqst *re
 	strlen = (u32*)kmap_atomic(rcvbuf->pages[0], KM_USER0);
 	/* Convert length of symlink */
 	len = ntohl(*strlen);
-	if (len > rcvbuf->page_len)
-		len = rcvbuf->page_len;
+	if (len >= rcvbuf->page_len - sizeof(u32)) {
+		dprintk("NFS: READLINK server returned giant symlink!\n");
+		kunmap(rcvbuf->pages[0]);
+		return -ENAMETOOLONG;
+        }
 	*strlen = len;
 	/* NULL terminate the string we got */
 	string = (char *)(strlen + 1);
diff -urNp linux-6080/fs/nfs/pagelist.c linux-6090/fs/nfs/pagelist.c
--- linux-6080/fs/nfs/pagelist.c
+++ linux-6090/fs/nfs/pagelist.c
@@ -364,7 +364,6 @@ nfs_scan_lru_timeout(struct list_head *h
  * nfs_scan_list - Scan a list for matching requests
  * @head: One of the NFS inode request lists
  * @dst: Destination list
- * @file: if set, ensure we match requests from this file
  * @idx_start: lower bound of page->index to scan
  * @npages: idx_start + npages sets the upper bound to scan.
  *
@@ -376,7 +375,6 @@ nfs_scan_lru_timeout(struct list_head *h
  */
 int
 nfs_scan_list(struct list_head *head, struct list_head *dst,
-	      struct file *file,
 	      unsigned long idx_start, unsigned int npages)
 {
 	struct list_head	*pos, *tmp;
@@ -395,9 +393,6 @@ nfs_scan_list(struct list_head *head, st
 
 		req = nfs_list_entry(pos);
 
-		if (file && req->wb_file != file)
-			continue;
-
 		pg_idx = page_index(req->wb_page);
 		if (pg_idx < idx_start)
 			continue;
diff -urNp linux-6080/fs/nfs/proc.c linux-6090/fs/nfs/proc.c
--- linux-6080/fs/nfs/proc.c
+++ linux-6090/fs/nfs/proc.c
@@ -164,17 +164,21 @@ nfs_proc_write(struct inode *inode, stru
 }
 
 static int
-nfs_proc_create(struct inode *dir, struct qstr *name, struct iattr *sattr,
-		int flags, struct nfs_fh *fhandle, struct nfs_fattr *fattr)
+nfs_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,
+		int flags)
 {
-	struct nfs_createargs	arg = { NFS_FH(dir), name->name,
-					name->len, sattr };
-	struct nfs_diropok	res = { fhandle, fattr };
+	struct nfs_fh		fhandle;
+	struct nfs_fattr	fattr;
+	struct nfs_createargs	arg = { NFS_FH(dir), dentry->d_name.name,
+					dentry->d_name.len, sattr };
+	struct nfs_diropok	res = { &fhandle, &fattr };
 	int			status;
 
-	fattr->valid = 0;
-	dprintk("NFS call  create %s\n", name->name);
+	fattr.valid = 0;
+	dprintk("NFS call  create %s\n", dentry->d_name.name);
 	status = rpc_call(NFS_CLIENT(dir), NFSPROC_CREATE, &arg, &res, 0);
+	if (status == 0)
+		status = nfs_instantiate(dentry, &fhandle, &fattr);
 	dprintk("NFS reply create: %d\n", status);
 	return status;
 }
diff -urNp linux-6080/fs/nfs/read.c linux-6090/fs/nfs/read.c
--- linux-6080/fs/nfs/read.c
+++ linux-6090/fs/nfs/read.c
@@ -371,7 +371,7 @@ static int
 nfs_scan_read(struct inode *inode, struct list_head *dst, unsigned long idx_start, unsigned int npages)
 {
 	int	res;
-	res = nfs_scan_list(&inode->u.nfs_i.read, dst, NULL, idx_start, npages);
+	res = nfs_scan_list(&inode->u.nfs_i.read, dst, idx_start, npages);
 	inode->u.nfs_i.nread -= res;
 	if ((inode->u.nfs_i.nread == 0) != list_empty(&inode->u.nfs_i.read))
 		printk(KERN_ERR "NFS: desynchronized value of nfs_i.nread.\n");
diff -urNp linux-6080/fs/nfs/write.c linux-6090/fs/nfs/write.c
--- linux-6080/fs/nfs/write.c
+++ linux-6090/fs/nfs/write.c
@@ -225,8 +225,20 @@ nfs_writepage(struct page *page)
 	struct inode *inode = page->mapping->host;
 	unsigned long end_index;
 	unsigned offset = PAGE_CACHE_SIZE;
+	int inode_referenced = 0;
 	int err, is_sync;
 
+	/*
+	 * Note: We need to ensure that we have a reference to the inode
+	 *       if we are to do asynchronous writes. If not, waiting
+	 *       in nfs_wait_on_request() may deadlock with clear_inode().
+	 *
+	 *       If igrab() fails here, then it is in any case safe to
+	 *       call nfs_wb_page(), since there will be no pending writes.
+	 */
+	if (igrab(inode) != NULL)
+		inode_referenced = 1;
+
 	end_index = inode->i_size >> PAGE_CACHE_SHIFT;
 
 	/* Ensure we've flushed out any previous writes */
@@ -245,7 +257,8 @@ nfs_writepage(struct page *page)
 do_it:
 	lock_kernel();
 	is_sync = (IS_SYNC(inode) || NFS_FLUSH(inode));
-	if (NFS_SERVER(inode)->wsize >= PAGE_CACHE_SIZE && !is_sync) {
+	if (NFS_SERVER(inode)->wsize >= PAGE_CACHE_SIZE && !is_sync &&
+		inode_referenced) {
 		err = nfs_writepage_async(NULL, inode, page, 0, offset);
 		if (err >= 0)
 			err = 0;
@@ -257,6 +270,8 @@ do_it:
 	unlock_kernel();
 out:
 	UnlockPage(page);
+	if (inode_referenced)
+		iput(inode);
 	return err; 
 }
 
@@ -432,7 +447,7 @@ nfs_mark_request_commit(struct nfs_page 
  * Interruptible by signals only if mounted with intr flag.
  */
 static int
-nfs_wait_on_requests(struct inode *inode, struct file *file, unsigned long idx_start, unsigned int npages)
+nfs_wait_on_requests(struct inode *inode, unsigned long idx_start, unsigned int npages)
 {
 	struct list_head	*p, *head;
 	unsigned long		idx_end;
@@ -451,9 +466,6 @@ nfs_wait_on_requests(struct inode *inode
 		unsigned long pg_idx;
 		struct nfs_page *req = nfs_inode_wb_entry(p);
 
-		if (file && req->wb_file != file)
-			continue;
-
 		pg_idx = page_index(req->wb_page);
 		if (pg_idx < idx_start)
 			break;
@@ -525,7 +537,6 @@ nfs_scan_lru_dirty(struct nfs_server *se
  * nfs_scan_dirty - Scan an inode for dirty requests
  * @inode: NFS inode to scan
  * @dst: destination list
- * @file: if set, ensure we match requests from this file
  * @idx_start: lower bound of page->index to scan.
  * @npages: idx_start + npages sets the upper bound to scan.
  *
@@ -533,10 +544,10 @@ nfs_scan_lru_dirty(struct nfs_server *se
  * The requests are *not* checked to ensure that they form a contiguous set.
  */
 static int
-nfs_scan_dirty(struct inode *inode, struct list_head *dst, struct file *file, unsigned long idx_start, unsigned int npages)
+nfs_scan_dirty(struct inode *inode, struct list_head *dst, unsigned long idx_start, unsigned int npages)
 {
 	int	res;
-	res = nfs_scan_list(&inode->u.nfs_i.dirty, dst, file, idx_start, npages);
+	res = nfs_scan_list(&inode->u.nfs_i.dirty, dst, idx_start, npages);
 	inode->u.nfs_i.ndirty -= res;
 	if ((inode->u.nfs_i.ndirty == 0) != list_empty(&inode->u.nfs_i.dirty))
 		printk(KERN_ERR "NFS: desynchronized value of nfs_i.ndirty.\n");
@@ -564,7 +575,7 @@ nfs_scan_lru_commit_timeout(struct nfs_s
 	npages = nfs_scan_lru_timeout(&server->lru_commit, dst, 1);
 	if (npages) {
 		inode = nfs_list_entry(dst->next)->wb_inode;
-		npages += nfs_scan_list(&inode->u.nfs_i.commit, dst, NULL, 0, 0);
+		npages += nfs_scan_list(&inode->u.nfs_i.commit, dst, 0, 0);
 		inode->u.nfs_i.ncommit -= npages;
 	}
 	return npages;
@@ -591,7 +602,7 @@ nfs_scan_lru_commit(struct nfs_server *s
 	npages = nfs_scan_lru(&server->lru_commit, dst, 1);
 	if (npages) {
 		inode = nfs_list_entry(dst->next)->wb_inode;
-		npages += nfs_scan_list(&inode->u.nfs_i.commit, dst, NULL, 0, 0);
+		npages += nfs_scan_list(&inode->u.nfs_i.commit, dst, 0, 0);
 		inode->u.nfs_i.ncommit -= npages;
 	}
 	return npages;
@@ -601,7 +612,6 @@ nfs_scan_lru_commit(struct nfs_server *s
  * nfs_scan_commit - Scan an inode for commit requests
  * @inode: NFS inode to scan
  * @dst: destination list
- * @file: if set, ensure we collect requests from this file only.
  * @idx_start: lower bound of page->index to scan.
  * @npages: idx_start + npages sets the upper bound to scan.
  *
@@ -609,10 +619,10 @@ nfs_scan_lru_commit(struct nfs_server *s
  * The requests are *not* checked to ensure that they form a contiguous set.
  */
 static int
-nfs_scan_commit(struct inode *inode, struct list_head *dst, struct file *file, unsigned long idx_start, unsigned int npages)
+nfs_scan_commit(struct inode *inode, struct list_head *dst, unsigned long idx_start, unsigned int npages)
 {
 	int	res;
-	res = nfs_scan_list(&inode->u.nfs_i.commit, dst, file, idx_start, npages);
+	res = nfs_scan_list(&inode->u.nfs_i.commit, dst, idx_start, npages);
 	inode->u.nfs_i.ncommit -= res;
 	if ((inode->u.nfs_i.ncommit == 0) != list_empty(&inode->u.nfs_i.commit))
 		printk(KERN_ERR "NFS: desynchronized value of nfs_i.ncommit.\n");
@@ -741,14 +751,14 @@ nfs_strategy(struct inode *inode)
 #ifdef CONFIG_NFS_V3
 	if (NFS_PROTO(inode)->version == 2) {
 		if (dirty >= NFS_STRATEGY_PAGES * wpages)
-			nfs_flush_file(inode, NULL, 0, 0, 0);
+			nfs_flush_file(inode, 0, 0, 0);
 	} else if (dirty >= wpages) {
-		nfs_flush_file(inode, NULL, 0, 0, 0);
+		nfs_flush_file(inode, 0, 0, 0);
 	} else if (dirty && flush)
-		nfs_flush_file(inode, NULL, 0, 0, 0);
+		nfs_flush_file(inode, 0, 0, 0);
 #else
 	if (dirty >= NFS_STRATEGY_PAGES * wpages)
-		nfs_flush_file(inode, NULL, 0, 0, 0);
+		nfs_flush_file(inode, 0, 0, 0);
 #endif
 }
 
@@ -1068,6 +1078,9 @@ nfs_writeback_done(struct rpc_task *task
 			SetPageError(page);
 			if (req->wb_file)
 				req->wb_file->f_error = task->tk_status;
+			if (task->tk_status == -ESTALE)
+				NFS_FLAGS(inode) |= NFS_INO_STALE;
+
 			nfs_inode_remove_request(req);
 			dprintk(", error = %d\n", task->tk_status);
 			goto next;
@@ -1218,6 +1231,9 @@ nfs_commit_done(struct rpc_task *task)
 		if (task->tk_status < 0) {
 			if (req->wb_file)
 				req->wb_file->f_error = task->tk_status;
+			if (task->tk_status == -ESTALE)
+				NFS_FLAGS(inode) |= NFS_INO_STALE;
+
 			nfs_inode_remove_request(req);
 			dprintk(", error = %d\n", task->tk_status);
 			goto next;
@@ -1240,7 +1256,7 @@ nfs_commit_done(struct rpc_task *task)
 }
 #endif
 
-int nfs_flush_file(struct inode *inode, struct file *file, unsigned long idx_start,
+int nfs_flush_file(struct inode *inode, unsigned long idx_start,
 		   unsigned int npages, int how)
 {
 	LIST_HEAD(head);
@@ -1248,7 +1264,7 @@ int nfs_flush_file(struct inode *inode, 
 				error = 0;
 
 	spin_lock(&nfs_wreq_lock);
-	res = nfs_scan_dirty(inode, &head, file, idx_start, npages);
+	res = nfs_scan_dirty(inode, &head, idx_start, npages);
 	spin_unlock(&nfs_wreq_lock);
 	if (res)
 		error = nfs_flush_list(&head, NFS_SERVER(inode)->wpages, how);
@@ -1258,15 +1274,14 @@ int nfs_flush_file(struct inode *inode, 
 }
 
 #ifdef CONFIG_NFS_V3
-int nfs_commit_file(struct inode *inode, struct file *file, unsigned long idx_start,
-		    unsigned int npages, int how)
+int nfs_commit_file(struct inode *inode, int how)
 {
 	LIST_HEAD(head);
 	int			res,
 				error = 0;
 
 	spin_lock(&nfs_wreq_lock);
-	res = nfs_scan_commit(inode, &head, file, idx_start, npages);
+	res = nfs_scan_commit(inode, &head, 0, 0);
 	spin_unlock(&nfs_wreq_lock);
 	if (res)
 		error = nfs_commit_list(&head, how);
@@ -1276,7 +1291,7 @@ int nfs_commit_file(struct inode *inode,
 }
 #endif
 
-int nfs_sync_file(struct inode *inode, struct file *file, unsigned long idx_start,
+int nfs_sync_file(struct inode *inode, unsigned long idx_start,
 		  unsigned int npages, int how)
 {
 	int	error,
@@ -1285,18 +1300,15 @@ int nfs_sync_file(struct inode *inode, s
 	wait = how & FLUSH_WAIT;
 	how &= ~FLUSH_WAIT;
 
-	if (!inode && file)
-		inode = file->f_dentry->d_inode;
-
 	do {
 		error = 0;
 		if (wait)
-			error = nfs_wait_on_requests(inode, file, idx_start, npages);
+			error = nfs_wait_on_requests(inode, idx_start, npages);
 		if (error == 0)
-			error = nfs_flush_file(inode, file, idx_start, npages, how);
+			error = nfs_flush_file(inode, idx_start, npages, how);
 #ifdef CONFIG_NFS_V3
 		if (error == 0)
-			error = nfs_commit_file(inode, file, idx_start, npages, how);
+			error = nfs_commit_file(inode, how);
 #endif
 	} while (error > 0);
 	return error;
diff -urNp linux-6080/fs/nfsd/nfs3xdr.c linux-6090/fs/nfsd/nfs3xdr.c
--- linux-6080/fs/nfsd/nfs3xdr.c
+++ linux-6090/fs/nfsd/nfs3xdr.c
@@ -284,7 +284,7 @@ xdr_argsize_check(struct svc_rqst *rqstp
 {
 	struct svc_buf	*buf = &rqstp->rq_argbuf;
 
-	return p - buf->base <= buf->buflen;
+	return p >= buf->base && p <= buf->base + buf->buflen;
 }
 
 static inline int
@@ -774,6 +774,8 @@ encode_entry(struct readdir_cd *cd, cons
 			dchild = lookup_one_len(name, dparent,namlen);
 		if (IS_ERR(dchild))
 			goto noexec;
+		if (d_mountpoint(dchild))
+			goto noexec;
 		if (fh_compose(&fh, exp, dchild, cd->dirfh) != 0 || !dchild->d_inode)
 			goto noexec;
 		p = encode_post_op_attr(cd->rqstp, p, &fh);
diff -urNp linux-6080/fs/nfsd/nfscache.c linux-6090/fs/nfsd/nfscache.c
--- linux-6080/fs/nfsd/nfscache.c
+++ linux-6090/fs/nfsd/nfscache.c
@@ -184,7 +184,10 @@ nfsd_cache_lookup(struct svc_rqst *rqstp
 		    xid == rp->c_xid && proc == rp->c_proc &&
 		    proto == rp->c_prot && vers == rp->c_vers &&
 		    time_before(jiffies, rp->c_timestamp + 120*HZ) &&
-		    memcmp((char*)&rqstp->rq_addr, (char*)&rp->c_addr, sizeof(rp->c_addr))==0) {
+		    rqstp->rq_addr.sin_family == rp->c_addr.sin_family &&
+		    memcmp((char*)&rqstp->rq_addr.sin_addr, 
+				(char*)&rp->c_addr.sin_addr,
+				sizeof(rp->c_addr.sin_addr)) == 0) {
 			nfsdstats.rchits++;
 			goto found_entry;
 		}
diff -urNp linux-6080/fs/nfsd/nfsfh.c linux-6090/fs/nfsd/nfsfh.c
--- linux-6080/fs/nfsd/nfsfh.c
+++ linux-6090/fs/nfsd/nfsfh.c
@@ -712,7 +712,7 @@ fh_verify(struct svc_rqst *rqstp, struct
 			tdentry = parent;
 		}
 		if (exp->ex_dentry != tdentry) {
-			error = nfserr_stale;
+			error = nfserr_acces;
 			printk("fh_verify: no root_squashed access at %s/%s.\n",
 			       dentry->d_parent->d_name.name,
 			       dentry->d_name.name);
diff -urNp linux-6080/fs/nfsd/vfs.c linux-6090/fs/nfsd/vfs.c
--- linux-6080/fs/nfsd/vfs.c
+++ linux-6090/fs/nfsd/vfs.c
@@ -945,7 +945,6 @@ nfsd_create_v3(struct svc_rqst *rqstp, s
 	struct inode	*dirp;
 	int		err;
 	__u32		v_mtime=0, v_atime=0;
-	int		v_mode=0;
 
 	err = nfserr_perm;
 	if (!flen)
@@ -982,16 +981,11 @@ nfsd_create_v3(struct svc_rqst *rqstp, s
 		goto out;
 
 	if (createmode == NFS3_CREATE_EXCLUSIVE) {
-		/* while the verifier would fit in mtime+atime,
-		 * solaris7 gets confused (bugid 4218508) if these have
-		 * the high bit set, so we use the mode as well
+		/* solaris7 gets confused (bugid 4218508) if these have
+		 * the high bit set, so just turn it off.
 		 */
 		v_mtime = verifier[0]&0x7fffffff;
 		v_atime = verifier[1]&0x7fffffff;
-		v_mode  = S_IFREG
-			| ((verifier[0]&0x80000000) >> (32-7)) /* u+x */
-			| ((verifier[1]&0x80000000) >> (32-9)) /* u+r */
-			;
 	}
 	
 	if (dchild->d_inode) {
@@ -1009,7 +1003,6 @@ nfsd_create_v3(struct svc_rqst *rqstp, s
 		case NFS3_CREATE_EXCLUSIVE:
 			if (   dchild->d_inode->i_mtime == v_mtime
 			    && dchild->d_inode->i_atime == v_atime
-			    && dchild->d_inode->i_mode  == v_mode
 			    && dchild->d_inode->i_size  == 0 )
 				break;
 			 /* fallthru */
@@ -1036,23 +1029,19 @@ nfsd_create_v3(struct svc_rqst *rqstp, s
 		goto out;
 
 	if (createmode == NFS3_CREATE_EXCLUSIVE) {
-		/* Cram the verifier into atime/mtime/mode */
+		/* Cram the verifier into atime/mtime */
 		iap->ia_valid = ATTR_MTIME|ATTR_ATIME
-			| ATTR_MTIME_SET|ATTR_ATIME_SET
-			| ATTR_MODE;
+			| ATTR_MTIME_SET|ATTR_ATIME_SET;
 		iap->ia_mtime = v_mtime;
 		iap->ia_atime = v_atime;
-		iap->ia_mode  = v_mode;
 	}
 
 	/* Set file attributes.
-	 * Mode has already been set but we might need to reset it
-	 * for CREATE_EXCLUSIVE
 	 * Irix appears to send along the gid when it tries to
 	 * implement setgid directories via NFS. Clear out all that cruft.
 	 */
  set_attr:
-	if ((iap->ia_valid &= ~(ATTR_UID|ATTR_GID)) != 0)
+	if ((iap->ia_valid &= ~(ATTR_UID|ATTR_GID|ATTR_MODE)) != 0)
  		err = nfsd_setattr(rqstp, resfhp, iap, 0, (time_t)0);
 
  out:
diff -urNp linux-6080/include/linux/nfs_fs.h linux-6090/include/linux/nfs_fs.h
--- linux-6080/include/linux/nfs_fs.h
+++ linux-6090/include/linux/nfs_fs.h
@@ -167,6 +167,11 @@ extern int nfs_check_stale(struct inode 
 extern int nfs_notify_change(struct dentry *, struct iattr *);
 
 /*
+ * linux/fs/nfs/dir.c
+ */
+extern int nfs_instantiate(struct dentry *, struct nfs_fh *, struct nfs_fattr *);
+
+/*
  * linux/fs/nfs/file.c
  */
 extern struct inode_operations nfs_file_inode_operations;
@@ -235,13 +240,13 @@ extern int  nfs_updatepage(struct file *
  * Try to write back everything synchronously (but check the
  * return value!)
  */
-extern int  nfs_sync_file(struct inode *, struct file *, unsigned long, unsigned int, int);
-extern int  nfs_flush_file(struct inode *, struct file *, unsigned long, unsigned int, int);
+extern int  nfs_sync_file(struct inode *, unsigned long, unsigned int, int);
+extern int  nfs_flush_file(struct inode *, unsigned long, unsigned int, int);
 extern int  nfs_flush_list(struct list_head *, int, int);
 extern int  nfs_scan_lru_dirty(struct nfs_server *, struct list_head *);
 extern int  nfs_scan_lru_dirty_timeout(struct nfs_server *, struct list_head *);
 #ifdef CONFIG_NFS_V3
-extern int  nfs_commit_file(struct inode *, struct file *, unsigned long, unsigned int, int);
+extern int  nfs_commit_file(struct inode *, int);
 extern int  nfs_commit_list(struct list_head *, int);
 extern int  nfs_scan_lru_commit(struct nfs_server *, struct list_head *);
 extern int  nfs_scan_lru_commit_timeout(struct nfs_server *, struct list_head *);
@@ -262,7 +267,7 @@ nfs_have_writebacks(struct inode *inode)
 static inline int
 nfs_wb_all(struct inode *inode)
 {
-	int error = nfs_sync_file(inode, 0, 0, 0, FLUSH_WAIT);
+	int error = nfs_sync_file(inode, 0, 0, FLUSH_WAIT);
 	return (error < 0) ? error : 0;
 }
 
@@ -272,17 +277,7 @@ nfs_wb_all(struct inode *inode)
 static inline int
 nfs_wb_page(struct inode *inode, struct page* page)
 {
-	int error = nfs_sync_file(inode, 0, page_index(page), 1, FLUSH_WAIT | FLUSH_STABLE);
-	return (error < 0) ? error : 0;
-}
-
-/*
- * Write back all pending writes for one user.. 
- */
-static inline int
-nfs_wb_file(struct inode *inode, struct file *file)
-{
-	int error = nfs_sync_file(inode, file, 0, 0, FLUSH_WAIT);
+	int error = nfs_sync_file(inode, page_index(page), 1, FLUSH_WAIT | FLUSH_STABLE);
 	return (error < 0) ? error : 0;
 }
 
diff -urNp linux-6080/include/linux/nfs_fs_i.h linux-6090/include/linux/nfs_fs_i.h
--- linux-6080/include/linux/nfs_fs_i.h
+++ linux-6090/include/linux/nfs_fs_i.h
@@ -100,6 +100,7 @@ struct nfs_inode_info {
 #define NFS_INO_REVALIDATING	0x0004		/* revalidating attrs */
 #define NFS_IS_SNAPSHOT		0x0010		/* a snapshot file */
 #define NFS_INO_FLUSH		0x0020		/* inode is due for flushing */
+#define NFS_INO_MAPPED		0x0040		/* page invalidation failed */
 
 /*
  * NFS lock info
diff -urNp linux-6080/include/linux/nfs_page.h linux-6090/include/linux/nfs_page.h
--- linux-6080/include/linux/nfs_page.h
+++ linux-6090/include/linux/nfs_page.h
@@ -53,7 +53,7 @@ extern	void nfs_list_add_request(struct 
 extern	int nfs_scan_lru(struct list_head *, struct list_head *, int);
 extern	int nfs_scan_lru_timeout(struct list_head *, struct list_head *, int);
 extern	int nfs_scan_list(struct list_head *, struct list_head *,
-			  struct file *, unsigned long, unsigned int);
+				unsigned long, unsigned int);
 extern	int nfs_coalesce_requests(struct list_head *, struct list_head *,
 				  unsigned int);
 extern  int nfs_wait_on_request(struct nfs_page *);
diff -urNp linux-6080/include/linux/nfs_xdr.h linux-6090/include/linux/nfs_xdr.h
--- linux-6080/include/linux/nfs_xdr.h
+++ linux-6090/include/linux/nfs_xdr.h
@@ -359,8 +359,8 @@ struct nfs_rpc_ops {
 			    struct page *, struct nfs_writeverf *verfp);
 	int	(*commit)  (struct inode *, struct nfs_fattr *,
 			    unsigned long, unsigned int);
-	int	(*create)  (struct inode *, struct qstr *, struct iattr *,
-			    int, struct nfs_fh *, struct nfs_fattr *);
+	int	(*create)  (struct inode *, struct dentry *, struct iattr *,
+			    int);
 	int	(*remove)  (struct inode *, struct qstr *);
 	int	(*unlink_setup)  (struct rpc_message *,
 			    struct dentry *, struct qstr *);
diff -urNp linux-6080/include/linux/nfsd/const.h linux-6090/include/linux/nfsd/const.h
--- linux-6080/include/linux/nfsd/const.h
+++ linux-6090/include/linux/nfsd/const.h
@@ -12,6 +12,7 @@
 #include <linux/nfs.h>
 #include <linux/nfs2.h>
 #include <linux/nfs3.h>
+#include <asm/page.h>
 
 /*
  * Maximum protocol version supported by knfsd
@@ -19,9 +20,16 @@
 #define NFSSVC_MAXVERS		3
 
 /*
- * Maximum blocksize supported by daemon currently at 8K
+ * Maximum blocksize supported by daemon.  We want the largest
+ * value which 1) fits in a UDP datagram less some headers
+ * 2) is a multiple of page size 3) can be successfully kmalloc()ed
+ * by each nfsd.
  */
-#define NFSSVC_MAXBLKSIZE	(8*1024)
+#if PAGE_SIZE > (16*1024)
+#define NFSSVC_MAXBLKSIZE	(32*1024)
+#else
+#define NFSSVC_MAXBLKSIZE	(2*PAGE_SIZE)
+#endif
 
 #ifdef __KERNEL__
 
diff -urNp linux-6080/include/linux/nfsd/xdr3.h linux-6090/include/linux/nfsd/xdr3.h
--- linux-6080/include/linux/nfsd/xdr3.h
+++ linux-6090/include/linux/nfsd/xdr3.h
@@ -42,7 +42,7 @@ struct nfsd3_writeargs {
 	__u32			count;
 	int			stable;
 	__u8 *			data;
-	int			len;
+	__u32			len;
 };
 
 struct nfsd3_createargs {
diff -urNp linux-6080/include/linux/sunrpc/sched.h linux-6090/include/linux/sunrpc/sched.h
--- linux-6080/include/linux/sunrpc/sched.h
+++ linux-6090/include/linux/sunrpc/sched.h
@@ -112,6 +112,7 @@ typedef void			(*rpc_action)(struct rpc_
 #define RPC_TASK_ROOTCREDS	0x0040		/* force root creds */
 #define RPC_TASK_DYNAMIC	0x0080		/* task was kmalloc'ed */
 #define RPC_TASK_KILLED		0x0100		/* task was killed */
+#define RPC_TASK_NOINTR		0x0400		/* uninterruptible task */
 
 #define RPC_IS_ASYNC(t)		((t)->tk_flags & RPC_TASK_ASYNC)
 #define RPC_IS_SETUID(t)	((t)->tk_flags & RPC_TASK_SETUID)
@@ -121,6 +122,7 @@ typedef void			(*rpc_action)(struct rpc_
 #define RPC_ASSASSINATED(t)	((t)->tk_flags & RPC_TASK_KILLED)
 #define RPC_IS_ACTIVATED(t)	((t)->tk_active)
 #define RPC_DO_CALLBACK(t)	((t)->tk_callback != NULL)
+#define RPC_TASK_UNINTERRUPTIBLE(t) ((t)->tk_flags & RPC_TASK_NOINTR)
 
 #define RPC_TASK_SLEEPING	0
 #define RPC_TASK_RUNNING	1
diff -urNp linux-6080/include/linux/sunrpc/timer.h linux-6090/include/linux/sunrpc/timer.h
--- linux-6080/include/linux/sunrpc/timer.h
+++ linux-6090/include/linux/sunrpc/timer.h
@@ -15,7 +15,11 @@ struct rpc_rtt {
 	long timeo;		/* default timeout value */
 	long srtt[5];		/* smoothed round trip time << 3 */
 	long sdrtt[5];		/* soothed medium deviation of RTT */
-	atomic_t  ntimeouts;	/* Global count of the number of timeouts */
+#ifdef __GENKSYMS__ /* preserve KMI/ABI ksyms compatibility for mod linkage */
+	atomic_t ntimeouts;	/* obsolete */
+#else
+	int  ntimeouts[5];	/* Number of timeouts for the last request */
+#endif
 };
 
 
@@ -23,19 +27,27 @@ extern void rpc_init_rtt(struct rpc_rtt 
 extern void rpc_update_rtt(struct rpc_rtt *rt, int timer, long m);
 extern long rpc_calc_rto(struct rpc_rtt *rt, int timer);
 
-static inline void rpc_inc_timeo(struct rpc_rtt *rt)
+static inline void rpc_set_timeo(struct rpc_rtt *rt, int timer, int ntimeo)
 {
-	atomic_inc(&rt->ntimeouts);
+	int *t;
+	if (!timer)
+		return;
+	t = &rt->ntimeouts[timer-1];
+	if (ntimeo < *t) {
+		if (*t > 0)
+			(*t)--;
+	} else {
+		if (ntimeo > 8)
+			ntimeo = 8;
+		*t = ntimeo;
+	}
 }
 
-static inline void rpc_clear_timeo(struct rpc_rtt *rt)
+static inline int rpc_ntimeo(struct rpc_rtt *rt, int timer)
 {
-	atomic_set(&rt->ntimeouts, 0);
-}
-
-static inline int rpc_ntimeo(struct rpc_rtt *rt)
-{
-	return atomic_read(&rt->ntimeouts);
+	if (!timer)
+		return 0;
+	return rt->ntimeouts[timer-1];
 }
 
 #endif /* _LINUX_SUNRPC_TIMER_H */
diff -urNp linux-6080/include/linux/sunrpc/xprt.h linux-6090/include/linux/sunrpc/xprt.h
--- linux-6080/include/linux/sunrpc/xprt.h
+++ linux-6090/include/linux/sunrpc/xprt.h
@@ -117,7 +117,11 @@ struct rpc_rqst {
 
 	long			rq_xtime;	/* when transmitted */
 	int			rq_ntimeo;
-	int			rq_nresend;
+#ifdef __GENKSYMS__ /* preserve KMI/ABI ksyms compatibility for linkage */
+	int			rq_nresend;	/* obsolete */
+#else
+	int			rq_ntrans;
+#endif
 };
 #define rq_svec			rq_snd_buf.head
 #define rq_slen			rq_snd_buf.len
diff -urNp linux-6080/mm/filemap.c linux-6090/mm/filemap.c
--- linux-6080/mm/filemap.c
+++ linux-6090/mm/filemap.c
@@ -3405,11 +3405,12 @@ do_generic_file_write(struct file *file,
 			PAGE_BUG(page);
 		}
 
-		kaddr = kmap(page);
 		status = mapping->a_ops->prepare_write(file, page, offset, offset+bytes);
 		if (status)
 			goto sync_failure;
+		kaddr = kmap(page);
 		page_fault = __copy_from_user(kaddr+offset, buf, bytes);
+		kunmap(page);
 		flush_dcache_page(page);
 		status = mapping->a_ops->commit_write(file, page, offset, offset+bytes);
 		if (page_fault)
@@ -3424,7 +3425,6 @@ do_generic_file_write(struct file *file,
 			buf += status;
 		}
 unlock:
-		kunmap(page);
 		/* Mark it unlocked again and drop the page.. */
 		UnlockPage(page);
 		if (deactivate)
@@ -3462,7 +3462,6 @@ sync_failure:
 	 * If blocksize < pagesize, prepare_write() may have instantiated a
 	 * few blocks outside i_size.  Trim these off again.
 	 */
-	kunmap(page);
 	UnlockPage(page);
 	page_cache_release(page);
 	if (pos + bytes > inode->i_size)
diff -urNp linux-6080/net/sunrpc/sched.c linux-6090/net/sunrpc/sched.c
--- linux-6080/net/sunrpc/sched.c
+++ linux-6090/net/sunrpc/sched.c
@@ -564,7 +564,11 @@ __rpc_execute(struct rpc_task *task)
 			if (current->pid == rpciod_pid)
 				printk(KERN_ERR "RPC: rpciod waiting on sync task!\n");
 
-			__wait_event(task->tk_wait, !RPC_IS_SLEEPING(task));
+			if (RPC_TASK_UNINTERRUPTIBLE(task)) {
+				__wait_event(task->tk_wait, !RPC_IS_SLEEPING(task));
+			} else {
+				__wait_event_interruptible(task->tk_wait, !RPC_IS_SLEEPING(task), status);
+			}
 			dprintk("RPC: %4d sync task resuming\n", task->tk_pid);
 
 			/*
@@ -761,8 +765,11 @@ rpc_init_task(struct rpc_task *task, str
 	list_add(&task->tk_task, &all_tasks);
 	spin_unlock(&rpc_sched_lock);
 
-	if (clnt)
+	if (clnt) {
 		atomic_inc(&clnt->cl_users);
+		if (!clnt->cl_intr)
+			task->tk_flags |= RPC_TASK_NOINTR;
+	}
 
 #ifdef RPC_DEBUG
 	task->tk_magic = 0xf00baa;
diff -urNp linux-6080/net/sunrpc/timer.c linux-6090/net/sunrpc/timer.c
--- linux-6080/net/sunrpc/timer.c
+++ linux-6090/net/sunrpc/timer.c
@@ -22,7 +22,7 @@ rpc_init_rtt(struct rpc_rtt *rt, long ti
 		rt->srtt[i] = t;
 		rt->sdrtt[i] = RPC_RTO_INIT;
 	}
-	atomic_set(&rt->ntimeouts, 0);
+	memset(rt->ntimeouts, 0, sizeof(rt->ntimeouts));
 }
 
 void
diff -urNp linux-6080/net/sunrpc/xprt.c linux-6090/net/sunrpc/xprt.c
--- linux-6080/net/sunrpc/xprt.c
+++ linux-6090/net/sunrpc/xprt.c
@@ -139,18 +139,21 @@ xprt_from_sock(struct sock *sk)
 static int
 __xprt_lock_write(struct rpc_xprt *xprt, struct rpc_task *task)
 {
+	struct rpc_rqst *req = task->tk_rqstp;
 	if (!xprt->snd_task) {
 		if (xprt->nocong || __xprt_get_cong(xprt, task)) {
 			xprt->snd_task = task;
-			if (task->tk_rqstp)
-				task->tk_rqstp->rq_bytes_sent = 0;
+			if (req) {
+				req->rq_bytes_sent = 0;
+				req->rq_ntrans++;
+			}
 		}
 	}
 	if (xprt->snd_task != task) {
 		dprintk("RPC: %4d TCP write queue full\n", task->tk_pid);
 		task->tk_timeout = 0;
 		task->tk_status = -EAGAIN;
-		if (task->tk_rqstp && task->tk_rqstp->rq_nresend)
+		if (req && req->rq_ntrans)
 			rpc_sleep_on(&xprt->resend, task, NULL, NULL);
 		else
 			rpc_sleep_on(&xprt->sending, task, NULL, NULL);
@@ -184,9 +187,12 @@ __xprt_lock_write_next(struct rpc_xprt *
 			return;
 	}
 	if (xprt->nocong || __xprt_get_cong(xprt, task)) {
+		struct rpc_rqst *req = task->tk_rqstp;
 		xprt->snd_task = task;
-		if (task->tk_rqstp)
-			task->tk_rqstp->rq_bytes_sent = 0;
+		if (req) {
+			req->rq_bytes_sent = 0;
+			req->rq_ntrans++;
+		}
 	}
 }
 
@@ -591,14 +597,14 @@ xprt_complete_rqst(struct rpc_xprt *xprt
 
 	/* Adjust congestion window */
 	if (!xprt->nocong) {
+		int timer = rpcproc_timer(clnt, task->tk_msg.rpc_proc);
 		xprt_adjust_cwnd(xprt, copied);
 		__xprt_put_cong(xprt, req);
-	       	if (!req->rq_nresend) {
-			int timer = rpcproc_timer(clnt, task->tk_msg.rpc_proc);
+	       	if (req->rq_ntrans == 1) {
 			if (timer)
 				rpc_update_rtt(&clnt->cl_rtt, timer, (long)jiffies - req->rq_xtime);
 		}
-		rpc_clear_timeo(&clnt->cl_rtt);
+		rpc_set_timeo(&clnt->cl_rtt, timer, req->rq_ntrans - 1);
 	}
 
 #ifdef RPC_PROFILE
@@ -1064,7 +1070,7 @@ xprt_timer(struct rpc_task *task)
 		goto out;
 
 	xprt_adjust_cwnd(req->rq_xprt, -ETIMEDOUT);
-	req->rq_nresend++;
+	__xprt_put_cong(xprt, req);
 
 	dprintk("RPC: %4d xprt_timer (%s request)\n",
 		task->tk_pid, req ? "pending" : "backlogged");
@@ -1218,8 +1224,9 @@ do_xprt_transmit(struct rpc_task *task)
 	spin_lock_bh(&xprt->sock_lock);
 	/* Set the task's receive timeout value */
 	if (!xprt->nocong) {
-		task->tk_timeout = rpc_calc_rto(&clnt->cl_rtt,
-				rpcproc_timer(clnt, task->tk_msg.rpc_proc));
+		int timer = rpcproc_timer(clnt, task->tk_msg.rpc_proc);
+		task->tk_timeout = rpc_calc_rto(&clnt->cl_rtt, timer);
+		task->tk_timeout <<= rpc_ntimeo(&clnt->cl_rtt, timer);
 		task->tk_timeout <<= clnt->cl_timeout.to_retries
 			- req->rq_timeout.to_retries;
 		if (task->tk_timeout > req->rq_timeout.to_maxval)
@@ -1541,6 +1548,9 @@ xprt_create_socket(int proto, struct rpc
 	if (resvport && xprt_bindresvport(sock) < 0)
 		goto failed;
 
+	/* don't hang waiting for kswapd */
+	sock->sk->allocation = GFP_NOFS;
+
 	return sock;
 
 failed:
