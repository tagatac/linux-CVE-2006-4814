diff -urNp linux-8080/drivers/addon/qla2200/qla2x00.c linux-8081/drivers/addon/qla2200/qla2x00.c
--- linux-8080/drivers/addon/qla2200/qla2x00.c
+++ linux-8081/drivers/addon/qla2200/qla2x00.c
@@ -90,6 +90,8 @@ static unsigned long mem_id[1000];
 #include "scsi.h"
 #include "hosts.h"
 
+#include "scsi_dump.h"
+
 #if defined(ISP2300)
 #include <linux/ip.h>
 #include <linux/if_arp.h>
@@ -563,6 +565,10 @@ static inline cont_a64_entry_t *qla2x00_
 STATIC inline void 
 qla2x00_free_request_resources(scsi_qla_host_t *dest_ha, srb_t *sp);
  
+#if defined(CONFIG_DISKDUMP) || defined(CONFIG_DISKDUMP_MODULE)
+static int qla2x00_dump_sanity_check(Scsi_Device *);
+static void qla2x00_dump_poll(Scsi_Device *);
+#endif
 
 #include "qla_inline.h"
 
@@ -3195,9 +3201,9 @@ qla2x00_eh_wait_on_command(scsi_qla_host
 
 
 #if !defined(SH_HAS_HOST_LOCK)
-		spin_unlock_irq(&io_request_lock);
+		spin_unlock_irq_dump(&io_request_lock);
 #else
-		spin_unlock_irq(ha->host->host_lock);
+		spin_unlock_irq_dump(ha->host->host_lock);
 #endif
 
 		set_current_state(TASK_UNINTERRUPTIBLE);
@@ -3825,9 +3831,9 @@ qla2xxx_eh_device_reset(Scsi_Cmnd *cmd)
  	spin_unlock_irqrestore(&ha->list_lock, flags);
 
 #if !defined(SH_HAS_HOST_LOCK)
-	spin_unlock_irq(&io_request_lock);
+	spin_unlock_irq_dump(&io_request_lock);
 #else
-	spin_unlock_irq(ha->host->host_lock);
+	spin_unlock_irq_dump(ha->host->host_lock);
 #endif
 	/* Blocking call-Does context switching if abort isp is active etc */  
 	if (qla2x00_wait_for_hba_online(ha) != QL_STATUS_SUCCESS) {
@@ -4242,9 +4248,9 @@ qla2xxx_eh_host_reset(Scsi_Cmnd *cmd)
 			(int)b, (int)t, (int)l, ha->host_no);)
 
 #if !defined(SH_HAS_HOST_LOCK)
-	spin_unlock_irq(&io_request_lock);
+	spin_unlock_irq_dump(&io_request_lock);
 #else
-	spin_unlock_irq(ha->host->host_lock);
+	spin_unlock_irq_dump(ha->host->host_lock);
 #endif
 	/* Blocking call-Does context switching if abort isp is active etc*/  
 	if( qla2x00_wait_for_hba_online(ha) != QL_STATUS_SUCCESS){
@@ -23410,7 +23416,20 @@ update_flash:
 /*
 * Declarations for load module
 */
+#if defined(CONFIG_DISKDUMP) || defined(CONFIG_DISKDUMP_MODULE)
+static struct scsi_dump_ops qla2x00_dump_ops = {
+	.sanity_check	= qla2x00_dump_sanity_check,
+	.poll		= qla2x00_dump_poll
+};
+
+static  Scsi_Host_Template_dump driver_template_dump = {
+	.hostt		= QLA2100_LINUX_TEMPLATE,
+	.dump_ops	= &qla2x00_dump_ops
+};
+#define driver_template	(driver_template_dump.hostt)
+#else
 static  Scsi_Host_Template driver_template = QLA2100_LINUX_TEMPLATE;
+#endif
 #include "scsi_module.c"
 
 /****************************************************************************/
@@ -24153,4 +24172,48 @@ static int apidev_cleanup() 
 #endif
 #endif
 
+#if defined(CONFIG_DISKDUMP) || defined(CONFIG_DISKDUMP_MODULE)
+static int
+qla2x00_dump_sanity_check(Scsi_Device *device)
+{
+	scsi_qla_host_t *ha = (scsi_qla_host_t *) device->host->hostdata;
+	fc_port_t	*fcport;
+	os_lun_t	*lq;
+
+	if (ha == NULL)
+		return -ENXIO;
+		
+#if !defined(SCSI_HAS_HOST_LOCK)
+	/* message request lock is busy */
+	if (spin_is_locked(&io_request_lock))
+		return -EBUSY;
+#else
+	/* message host lock is busy */
+	if (spin_is_locked(ha->host->host_lock))
+		return -EBUSY;
+#endif
+	/* A link down judgment */
+	if((lq = GET_LU_Q(ha, device->id, device->lun)) == NULL)
+		return -ENXIO;
+
+	fcport = lq->fclun->fcport;
+	if (atomic_read(&fcport->state) != FC_ONLINE)
+		return -ENXIO;
+
+	return 0;
+}
+
+static void
+qla2x00_dump_poll(Scsi_Device *device)
+{
+	scsi_qla_host_t *ha = (scsi_qla_host_t *) device->host->hostdata;
+
+	if (ha == NULL)
+		return;
+
+	/* check interrupt pending */
+	qla2x00_intr_handler(0, ha, NULL);
+}
+#endif
+
 EXPORT_NO_SYMBOLS;
diff -urNp linux-8080/drivers/addon/qla2200/qla2x00.h linux-8081/drivers/addon/qla2200/qla2x00.h
--- linux-8080/drivers/addon/qla2200/qla2x00.h
+++ linux-8081/drivers/addon/qla2200/qla2x00.h
@@ -41,6 +41,8 @@ extern "C" {
 #include <asm/bitops.h>
 #include <asm/semaphore.h>
 
+#include <linux/diskdumplib.h>
+
 #define QLOGIC_COMPANY_NAME	"QLogic Corporation"
 
 /*
@@ -4481,6 +4483,13 @@ void qla2x00_setup(char *s);
 #define TEMPLATE_NEED_PLUG_TIMER
 #endif
 
+/* diskdump */
+#if defined(CONFIG_DISKDUMP) || defined(CONFIG_DISKDUMP_MODULE)
+#define TEMPLATE_DISK_DUMP	disk_dump: 1,
+#else
+#define TEMPLATE_DISK_DUMP
+#endif
+
 /*
  * There are several Scsi_Host members that are RHEL3 specific
  * yet depend on the SCSI_HAS_HOST_LOCK define for visibility.
@@ -4536,8 +4545,32 @@ TEMPLATE_SINGLE_SG_OK						\
 TEMPLATE_CAN_DO_VARYIO						\
 TEMPLATE_VARY_IO						\
 TEMPLATE_NEED_PLUG_TIMER					\
-	use_clustering: ENABLE_CLUSTERING			\
+	use_clustering: ENABLE_CLUSTERING,			\
+TEMPLATE_DISK_DUMP						\
 }
 
+#if defined(CONFIG_DISKDUMP) || defined(CONFIG_DISKDUMP_MODULE)
+#undef	add_timer
+#define	add_timer	diskdump_add_timer
+#undef	del_timer_sync
+#define	del_timer_sync	diskdump_del_timer
+#undef	del_timer
+#define	del_timer	diskdump_del_timer
+#undef	mod_timer
+#define	mod_timer	diskdump_mod_timer
+#undef	schedule_timeout
+#define schedule_timeout diskdump_schedule_timeout
+
+#define spin_unlock_irq_dump(host_lock)			\
+	do {						\
+		if (crashdump_mode())			\
+			spin_unlock(host_lock);		\
+		else					\
+			spin_unlock_irq(host_lock);	\
+	} while (0)
+#else
+#define spin_unlock_irq_dump(host_lock)	spin_unlock_irq(host_lock)
+#endif
+
 #endif /* _IO_HBA_QLA2100_H */
 
