diff -urNp linux-6220/drivers/block/genhd.c linux-7000/drivers/block/genhd.c
--- linux-6220/drivers/block/genhd.c
+++ linux-7000/drivers/block/genhd.c
@@ -28,15 +28,74 @@
 /*
  * Global kernel list of partitioning information.
  *
- * XXX: you should _never_ access this directly.
- *	the only reason this is exported is source compatiblity.
+ *	you should _never_ access this directly but use the access functions
  */
-/*static*/ struct gendisk *gendisk_head;
+static struct gendisk *gendisk_head;
 static struct gendisk *gendisk_array[MAX_BLKDEV];
-static rwlock_t gendisk_lock = RW_LOCK_UNLOCKED;
 
-EXPORT_SYMBOL(gendisk_head);
 
+/* Global kernel list of callback functions for formatting
+ * device and partition names correctly for registered drivers
+ * in /proc/partitions
+ */
+devname_t callback_devname_table[MAX_BLKDEV];
+static spinlock_t devname_lock = SPIN_LOCK_UNLOCKED;
+
+
+/**
+ * register_callback_devname_table - Used by drivers to specify the
+ * callback functions to be called in the partition check path to
+ * get the right names for the driver controlled devices in /proc/partitions
+ *
+ * This will be invoked during the initialization of such drivers.
+ *
+ * Returns: 0 --> registration of callback function SUCCESS
+            < 0--> registration of callback function FAILURE
+ */
+int
+register_callback_devname_table(int major_num, void *function)
+{
+	if (major_num > MAX_BLKDEV)
+		return -EINVAL;
+	spin_lock(&devname_lock);
+	callback_devname_table[major_num] = function;
+	spin_unlock(&devname_lock);
+	return 0;
+}
+
+EXPORT_SYMBOL(register_callback_devname_table);
+
+/**
+ * unregister_callback_devname_table - Will be used by the drivers which
+ * had registered their callback functions to format the device names
+ * during driver init to do the corresponding unregistrations.
+ *
+ * This will be called during the driver exit paths.
+ */
+int
+unregister_callback_devname_table(int major_num)
+{
+	if (major_num > MAX_BLKDEV)
+		return -EINVAL;
+	spin_lock(&devname_lock);
+	callback_devname_table[major_num] = NULL;
+	spin_unlock(&devname_lock);
+	return 0;
+}
+
+EXPORT_SYMBOL(unregister_callback_devname_table);
+
+/**
+ * get_callback_function_for_disk_name  - Returns the callback function
+ * which is previously registered for that particular driver (major).
+ */
+void *
+get_callback_from_devname_table(int major_num)
+{
+	return (void *)callback_devname_table[major_num];
+}
+
+EXPORT_SYMBOL(get_callback_from_devname_table);
 
 /**
  * add_gendisk - add partitioning information to kernel list
@@ -49,8 +108,9 @@ void
 add_gendisk(struct gendisk *gp)
 {
 	struct gendisk *sgp;
+	unsigned long flags;
 
-	write_lock(&gendisk_lock);
+	br_write_lock_irqsave(BR_GENHD_LOCK, flags);
 
 	/*
  	 *	In 2.5 this will go away. Fix the drivers who rely on
@@ -70,7 +130,7 @@ add_gendisk(struct gendisk *gp)
 	gp->next = gendisk_head;
 	gendisk_head = gp;
 out:
-	write_unlock(&gendisk_lock);
+	br_write_unlock_irqrestore(BR_GENHD_LOCK, flags);
 }
 
 EXPORT_SYMBOL(add_gendisk);
@@ -87,15 +147,16 @@ void
 del_gendisk(struct gendisk *gp)
 {
 	struct gendisk **gpp;
+	unsigned long flags;
 
-	write_lock(&gendisk_lock);
+	br_write_lock_irqsave(BR_GENHD_LOCK, flags);
 	gendisk_array[gp->major] = NULL;
 	for (gpp = &gendisk_head; *gpp; gpp = &((*gpp)->next))
 		if (*gpp == gp)
 			break;
 	if (*gpp)
 		*gpp = (*gpp)->next;
-	write_unlock(&gendisk_lock);
+	br_write_unlock_irqrestore(BR_GENHD_LOCK, flags);
 }
 
 EXPORT_SYMBOL(del_gendisk);
@@ -114,8 +175,8 @@ get_gendisk(kdev_t dev)
 	struct gendisk *gp = NULL;
 	int maj = MAJOR(dev);
 
-	read_lock(&gendisk_lock);
-	if ((gp = gendisk_array[maj]))
+	br_read_lock(BR_GENHD_LOCK);
+	if (likely((gp = gendisk_array[maj]) != NULL))
 		goto out;
 
 	/* This is needed for early 2.4 source compatiblity.  --hch */
@@ -123,7 +184,7 @@ get_gendisk(kdev_t dev)
 		if (gp->major == maj)
 			break;
 out:
-	read_unlock(&gendisk_lock);
+	br_read_unlock(BR_GENHD_LOCK);
 	return gp;
 }
 
@@ -144,11 +205,11 @@ walk_gendisk(int (*walk)(struct gendisk 
 	struct gendisk *gp;
 	int error = 0;
 
-	read_lock(&gendisk_lock);
+	br_read_lock(BR_GENHD_LOCK);
 	for (gp = gendisk_head; gp; gp = gp->next)
 		if ((error = walk(gp, data)))
 			break;
-	read_unlock(&gendisk_lock);
+	br_read_unlock(BR_GENHD_LOCK);
 
 	return error;
 }
@@ -160,7 +221,7 @@ static void *part_start(struct seq_file 
 	struct gendisk *gp;
 	loff_t pos = *ppos;
 
-	read_lock(&gendisk_lock);
+	br_read_lock(BR_GENHD_LOCK);
 	for (gp = gendisk_head; gp; gp = gp->next)
 		if (!pos--)
 			return gp;
@@ -175,7 +236,7 @@ static void *part_next(struct seq_file *
 
 static void part_stop(struct seq_file *s, void *v)
 {
-	read_unlock(&gendisk_lock);
+	br_read_unlock(BR_GENHD_LOCK);
 }
 
 static int part_show(struct seq_file *s, void *v)
@@ -201,7 +262,7 @@ static int part_show(struct seq_file *s,
 
 			disk_round_stats(hd);
 			seq_printf(s, "%4d  %4d %10d %s "
-				      "%d %d %d %d %d %d %d %d %d %d %d\n",
+				      "%u %u %u %u %u %u %u %u %u %u %u\n",
 				      gp->major, n, gp->sizes[n],
 				      disk_name(gp, n, buf),
 				      hd->rd_ios, hd->rd_merges,
diff -urNp linux-6220/fs/partitions/check.c linux-7000/fs/partitions/check.c
--- linux-6220/fs/partitions/check.c
+++ linux-7000/fs/partitions/check.c
@@ -119,6 +119,23 @@ char *disk_name (struct gendisk *hd, int
 			return buf + pos;
 	}
 
+	/* The device driver can provide its own naming -- a callback
+	 * function for such drivers would have been registered with
+	 * global callback_devname_table[]. Check this and call it!
+	 *
+	 * The driver callback function would return 0 on SUCCESS
+	 */
+	if (get_callback_from_devname_table(hd->major)) {
+		devname_t devname_callback;
+		kdev_t dev = MKDEV(hd->major, minor);
+		*buf = 0;
+	        devname_callback = (devname_t)get_callback_from_devname_table(hd->major);
+		if ((*devname_callback)(dev, buf))
+			printk (KERN_ERR "disk_name():devname() failed!\n");
+		else
+	 		return buf;
+	}
+
 #ifdef CONFIG_ARCH_S390
 	if (genhd_dasd_name
 	    && genhd_dasd_name (buf, unit, part, hd) == 0)
diff -urNp linux-6220/include/linux/brlock.h linux-7000/include/linux/brlock.h
--- linux-6220/include/linux/brlock.h
+++ linux-7000/include/linux/brlock.h
@@ -38,6 +38,7 @@ enum brlock_indices {
 	BR_SEMAPHORE_LOCK,
 	BR_LRU_LOCK,
 	BR_PAGECACHE_LOCK,
+	BR_GENHD_LOCK,
 
 	__BR_END
 };
diff -urNp linux-6220/include/linux/genhd.h linux-7000/include/linux/genhd.h
--- linux-6220/include/linux/genhd.h
+++ linux-7000/include/linux/genhd.h
@@ -86,6 +86,12 @@ struct hd_struct {
 
 #define GENHD_FL_REMOVABLE  1
 
+
+extern int register_callback_devname_table(int major_num, void *function);
+extern int unregister_callback_devname_table(int major_num);
+extern void *get_callback_from_devname_table(int major_num);
+typedef int (*devname_t)(kdev_t dev, char *buffer);
+
 struct gendisk {
 	int major;			/* major number of driver */
 	const char *major_name;		/* name of major driver */
