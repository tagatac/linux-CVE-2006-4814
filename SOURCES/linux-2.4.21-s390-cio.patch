diff -urNp linux-460/drivers/s390/block/dasd.c linux-461/drivers/s390/block/dasd.c
--- linux-460/drivers/s390/block/dasd.c
+++ linux-461/drivers/s390/block/dasd.c
@@ -2291,9 +2291,7 @@ dasd_handle_state_change_pending (devsta
 	ccw_req_t *cqr;
 
 	device_addr = dasd_device_from_devno (stat->devno);
-
 	if (device_addr == NULL) {
-
 		MESSAGE (KERN_DEBUG,
                          "unable to find device for state change pending "
                          "interrupt: devno%04x", 
@@ -2301,9 +2299,8 @@ dasd_handle_state_change_pending (devsta
                 return;
 	} 
 
-        /* re-activate first request in queue */
+        /* re-activate requests in queue */
         cqr = (*device_addr)->queue.head;
-
 	if (cqr == NULL) {
 		MESSAGE (KERN_DEBUG,
 			 "got state change pending interrupt on"
@@ -2312,26 +2309,24 @@ dasd_handle_state_change_pending (devsta
 		return;
 	}
         
-        if (cqr->status == CQR_STATUS_PENDING) {
-                
-                DEV_MESSAGE (KERN_DEBUG, (*device_addr), "%s",
-                             "device request queue restarted by "
-                             "state change pending interrupt");
-                
-                del_timer_sync (&(*device_addr)->blocking_timer);
-                
-                check_then_set (&cqr->status,
-                                CQR_STATUS_PENDING, CQR_STATUS_QUEUED);
-                
+        while (cqr) {
+                if (cqr->status == CQR_STATUS_PENDING) {       
+                        DEV_MESSAGE (KERN_DEBUG, (*device_addr), "%s",
+                                     "device request queue restarted by "
+                                     "state change pending interrupt");
+                        del_timer_sync (&(*device_addr)->blocking_timer);
+                        cqr->status = CQR_STATUS_QUEUED;
+                }
+                if (cqr->status == CQR_STATUS_IN_IO) {
+                        DEV_MESSAGE (KERN_DEBUG, (*device_addr), "%s",
+                                     "redriving state change pending condition "
+                                     "while in IO");
+                        cqr->status = CQR_STATUS_QUEUED; 
+                }
+		cqr = cqr->next;
         }
-	if (cqr->status == CQR_STATUS_IN_IO) {
-		cqr->status = CQR_STATUS_QUEUED;
-		DEV_MESSAGE (KERN_WARNING, (*device_addr), "%s",
-				"redriving state change pending condition while in IO");
-	}
-
         dasd_schedule_bh (*device_addr);
-
+        
 } /* end dasd_handle_state_change_pending */
 
 /*
@@ -3820,9 +3815,8 @@ dasd_oper_handler (int irq, devreg_t * d
 			break;
 	}
 
-        if ( device &&
-             (device->level == DASD_STATE_ONLINE) &&
-	     (!device->accessible) ) {
+        if (device &&
+            device->level >= DASD_STATE_NEW) {
                 s390irq_spin_lock_irqsave (device->devinfo.irq, 
                                            flags);
 		DEV_MESSAGE (KERN_DEBUG, device, "%s",
@@ -4083,13 +4077,18 @@ dasd_state_known_to_accept (dasd_device_
                 rc = s390_request_irq_special (device->devinfo.irq,
                                                device->discipline->int_handler,
                                                dasd_not_oper_handler,
-                                               0, DASD_NAME,
+                                               SA_DOPATHGROUP, DASD_NAME,
                                                &device->dev_status);
                 if ( rc ) {
 
                         MESSAGE (KERN_DEBUG, "%s",
                                  "No request IRQ");
 
+			if (rc == -EUSERS) {
+				/* Device is reserved by someone else. */
+				device->level = DASD_STATE_BOXED;
+			}
+
                         goto out;
                 }
         }
@@ -4838,7 +4837,7 @@ dasd_break_boxed (dasd_range_t  *range,
         rc = s390_request_irq_special (device->devinfo.irq,
                                        device->discipline->int_handler,
                                        dasd_not_oper_handler,
-                                       0, 
+                                       SA_DOPATHGROUP | SA_FORCE, 
                                        DASD_NAME,
                                        &device->dev_status);
         if ( rc ) 
@@ -5189,8 +5188,8 @@ dasd_statistics_write (struct file *file
 
 	buffer[user_len] = 0;
         
-	MESSAGE (KERN_INFO,
-                 "/proc/dasd/statictics: '%s'",
+	MESSAGE_LOG (KERN_INFO,
+                     "/proc/dasd/statistics: '%s'",
                  buffer);
 
 #ifdef DASD_PROFILE
@@ -5213,7 +5212,7 @@ dasd_statistics_write (struct file *file
                         sizeof (dasd_profile_info_t));
                 
                 MESSAGE (KERN_INFO, "%s",
-                         "Statictics reset");
+                         "Statistics reset");
 
 	} else {
 
@@ -5229,7 +5228,7 @@ dasd_statistics_write (struct file *file
                         dasd_profile_level = DASD_PROFILE_ON;
                         
                         MESSAGE (KERN_INFO, "%s",
-                                 "Statictics switched on");
+                                 "Statistics switched on");
                         
                 } else if (!strncmp (buffer + offset, "off", 3)) {
                         
@@ -5241,7 +5240,7 @@ dasd_statistics_write (struct file *file
                         dasd_profile_level = DASD_PROFILE_OFF;
                         
                         MESSAGE (KERN_INFO, "%s",
-                                 "Statictics switched off");
+                                 "Statistics switched off");
 
                 } else {
 
diff -urNp linux-460/drivers/s390/block/dasd_3990_erp.c linux-461/drivers/s390/block/dasd_3990_erp.c
--- linux-460/drivers/s390/block/dasd_3990_erp.c
+++ linux-461/drivers/s390/block/dasd_3990_erp.c
@@ -46,7 +46,6 @@ log_erp_chain (ccw_req_t *cqr,
                 *end,
                 buffer[80];
         
-        
         /* dump sense data */
         if (device->discipline            && 
             device->discipline->dump_sense  ) {
@@ -58,7 +57,7 @@ log_erp_chain (ccw_req_t *cqr,
         /* log the channel program */
         while (loop_cqr != NULL) {
                 
-                DEV_MESSAGE (KERN_ERR, device, 
+                DEV_MESSAGE_LOG (KERN_ERR, device, 
                              "(%s) ERP chain report for req: %p",
                              caller == 0 ? "EXAMINE" : "ACTION",
                              loop_cqr);
@@ -76,19 +75,17 @@ log_erp_chain (ccw_req_t *cqr,
                                  nl,
                                  nl[0], nl[1], nl[2], nl[3],
                                  nl[4], nl[5], nl[6], nl[7],
-                                 nl[8], nl[9], nl[10], nl[11],
-                                 nl[12], nl[13], nl[14], nl[15]);
+                                 nl[8], nl[9], nl[10],nl[11],
+                                 nl[12],nl[13],nl[14],nl[15]);
         
-                        DEV_MESSAGE (KERN_ERR, device, "%s", 
+                        DEV_MESSAGE_LOG (KERN_ERR, device, "%s", 
                                      buffer);
-                        
                         nl +=16;
                 }        
                	
-		DEV_MESSAGE (KERN_ERR, device,
+		DEV_MESSAGE_LOG (KERN_ERR, device,
 				"DATA area is at: %p",
 				loop_cqr->data);
-
 		nl      = (char *) loop_cqr->data;
 		end_cqr = nl + loop_cqr->datasize;
 
@@ -102,12 +99,11 @@ log_erp_chain (ccw_req_t *cqr,
                                   nl,
                                   nl[0], nl[1], nl[2], nl[3],
                                   nl[4], nl[5], nl[6], nl[7],
-                                  nl[8], nl[9], nl[10], nl[11],
-                                 nl[12], nl[13], nl[14], nl[15]);
+                                 nl[8], nl[9], nl[10],nl[11],
+                                 nl[12],nl[13],nl[14],nl[15]);
 
-                        DEV_MESSAGE (KERN_ERR, device, "%s",
+                        DEV_MESSAGE_LOG (KERN_ERR, device, "%s",
                                      buffer);
-
                         nl +=16;
               }
 	       	
@@ -115,7 +111,7 @@ log_erp_chain (ccw_req_t *cqr,
                 
                 if (loop_cqr->cplength > 40) { /* log only parts of the CP */
 
-                        DEV_MESSAGE (KERN_ERR, device, "%s",
+                        DEV_MESSAGE_LOG (KERN_ERR, device, "%s",
                                       "Start of channel program:");
                         
                         for (i = 0; i < 20; i += 2) { 
@@ -131,13 +127,12 @@ log_erp_chain (ccw_req_t *cqr,
                                          nl[8], nl[9], nl[10], nl[11],
                                          nl[12], nl[13], nl[14], nl[15]);
                                 
-                                DEV_MESSAGE (KERN_ERR, device, "%s",
+                                DEV_MESSAGE_LOG (KERN_ERR, device, "%s",
                                              buffer);
-
                                 nl += 16;
                         }
                         
-                        DEV_MESSAGE (KERN_ERR, device, "%s",
+                        DEV_MESSAGE_LOG (KERN_ERR, device, "%s",
                                      "End of channel program:");
                         
                         nl  = (char *) loop_cqr->cpaddr;
@@ -156,15 +151,14 @@ log_erp_chain (ccw_req_t *cqr,
                                          nl[8], nl[9], nl[10], nl[11],
                                          nl[12], nl[13], nl[14], nl[15]);
                                 
-                                DEV_MESSAGE (KERN_ERR, device, "%s",
+                                DEV_MESSAGE_LOG (KERN_ERR, device, "%s",
                                              buffer);
-                                
                                 nl += 16;
                         }
                         
                 } else { /* log the whole CP */
                         
-                        DEV_MESSAGE (KERN_ERR, device, "%s",
+                        DEV_MESSAGE_LOG (KERN_ERR, device, "%s",
                                       "Channel program (complete):");
                         
                         for (i = 0; i < (loop_cqr->cplength + 4); i += 2) { 
@@ -177,12 +171,11 @@ log_erp_chain (ccw_req_t *cqr,
                                          nl,
                                          nl[0], nl[1], nl[2], nl[3],
                                          nl[4], nl[5], nl[6], nl[7],
-                                         nl[8], nl[9], nl[10], nl[11],
-                                         nl[12], nl[13], nl[14], nl[15]);
+                                         nl[8], nl[9], nl[10],nl[11],
+                                         nl[12],nl[13],nl[14],nl[15]);
                                 
-                                DEV_MESSAGE (KERN_ERR, device, "%s",
+                                DEV_MESSAGE_LOG (KERN_ERR, device, "%s",
                                              buffer);
-                                
                                 nl += 16;
                         }
                 }
@@ -201,7 +194,7 @@ log_erp_chain (ccw_req_t *cqr,
                         
                                 nl -= 10*8;     /* start some bytes before */
                                 
-                                DEV_MESSAGE (KERN_ERR, device, 
+                                DEV_MESSAGE_LOG (KERN_ERR, device, 
                                              "Failed CCW (%p) (area):",
                                              (void *)(long)cpa);
                                 
@@ -215,26 +208,22 @@ log_erp_chain (ccw_req_t *cqr,
                                                  nl,
                                                  nl[0], nl[1], nl[2], nl[3],
                                                  nl[4], nl[5], nl[6], nl[7],
-                                                 nl[8], nl[9], nl[10], nl[11],
-                                                 nl[12], nl[13], nl[14], nl[15]);
-
-                                        DEV_MESSAGE (KERN_ERR, device, "%s",
-                                                     buffer);
+                                                 nl[8], nl[9], nl[10],nl[11],
+                                                 nl[12],nl[13],nl[14],nl[15]);
                                         
+                                        DEV_MESSAGE_LOG (KERN_ERR, device, 
+                                                         "%s", buffer);
                                         nl += 16;
                                 }
-                                
                         } else {
-                                
-                                DEV_MESSAGE (KERN_ERR, device, 
-                                             "Failed CCW (%p) already logged",
+                                DEV_MESSAGE_LOG (KERN_ERR, device, 
+                                                 "Failed CCW (%p) already "
+                                                 "logged",
                                              (void *)(long)cpa);
                         }
                 }
-                
                 loop_cqr = loop_cqr->refers;
         }
-        
 } /* end log_erp_chain */
 
 /*
@@ -606,9 +595,8 @@ dasd_3990_erp_alternate_path (ccw_req_t 
                              ioinfo[irq]->opm);
 
 		/* reset status to queued to handle the request again... */
-		check_then_set (&erp->status,
-                                CQR_STATUS_ERROR,
-                                CQR_STATUS_QUEUED);
+		if (erp->status > CQR_STATUS_QUEUED)
+                        erp->status = CQR_STATUS_QUEUED;
 
                 erp->retries = 1;
                 
@@ -619,12 +607,10 @@ dasd_3990_erp_alternate_path (ccw_req_t 
                              "opm=%x) -> permanent error",
                              erp->dstat->lpum,
                              ioinfo[irq]->opm);
-                
-                /* post request with permanent error */
-                check_then_set (&erp->status,
-                                CQR_STATUS_ERROR,
-                                CQR_STATUS_FAILED);
 
+                /* post request with permanent error */
+		if (erp->status > CQR_STATUS_QUEUED)
+                        erp->status = CQR_STATUS_FAILED;
         }
         
 } /* end dasd_3990_erp_alternate_path */
@@ -778,14 +764,18 @@ dasd_3990_erp_action_4 (ccw_req_t *erp,
                         dasd_3990_erp_block_queue (erp,
                                                    30);
                 } else {
-			DEV_MESSAGE (KERN_INFO, device, "redriving request immediately, %d retries left", erp->retries);
+
                         /* no state change pending - retry */
+			DEV_MESSAGE (KERN_INFO, device, 
+                                     "redriving request immediately, "
+                                     "%d retries left", 
+                                     erp->retries);
+
                         check_then_set (&erp->status,
                                         CQR_STATUS_ERROR,
                                         CQR_STATUS_QUEUED);
                 }
         }
-
 	return erp;
 
 } /* end dasd_3990_erp_action_4 */
@@ -2403,7 +2393,7 @@ dasd_3990_erp_compound_code (ccw_req_t *
                 switch (sense[28]) {
                 case 0x17:
                         /* issue a Diagnostic Control command with an 
-                                * Inhibit Write subcommand and controler modifier */
+                         * Inhibit Write subcommand and controler modifier */
                         erp = dasd_3990_erp_DCTL (erp,
                                                   0x20);
                         break;
@@ -2716,7 +2706,8 @@ dasd_3990_erp_add_erp (ccw_req_t *cqr)
 	if (!erp) {
                 if (cqr->retries <= 0) {
                         DEV_MESSAGE (KERN_ERR, device, "%s",
-                                     "Unable to allocate ERP request (NO retries left)");
+                                     "Unable to allocate ERP request "
+                                     "(NO retries left)");
                 
                         check_then_set (&cqr->status,
                                         CQR_STATUS_ERROR,
@@ -2726,7 +2717,8 @@ dasd_3990_erp_add_erp (ccw_req_t *cqr)
 
                 } else {
                         DEV_MESSAGE (KERN_ERR, device,
-                                     "Unable to allocate ERP request (%i retries left)",
+                                     "Unable to allocate ERP request "
+                                     "(%i retries left)",
                                      cqr->retries);
                 
                         if (!timer_pending(&device->timer)) {
@@ -3186,8 +3178,9 @@ dasd_3990_erp_action (ccw_req_t *cqr)
                 dasd_chanq_enq_head (&device->queue,
                                      erp);
         } else {
-                if ((erp->status == CQR_STATUS_FILLED ) || (erp != device->queue.head)) {
-                        /* something strange happened - log the error and panic */
+                if ((erp->status == CQR_STATUS_FILLED ) || 
+                    (erp != device->queue.head)) {
+                        /* something strange happened - log error and panic */
                         /* print current erp_chain */
                         DEV_MESSAGE (KERN_DEBUG, device, "%s",
                                      "ERP chain at END of ERP-ACTION");
@@ -3205,7 +3198,8 @@ dasd_3990_erp_action (ccw_req_t *cqr)
                                                      temp_erp->refers);
                                 }
                         }
-                        panic ("Problems with ERP chain!!! Please report to linux390@de.ibm.com");
+                        panic ("Problems with ERP chain!!! "
+                               "Please report to linux390@de.ibm.com");
                 }
 
         }
diff -urNp linux-460/drivers/s390/block/dasd_diag.c linux-461/drivers/s390/block/dasd_diag.c
--- linux-460/drivers/s390/block/dasd_diag.c
+++ linux-461/drivers/s390/block/dasd_diag.c
@@ -545,7 +545,7 @@ dasd_diag_init (void)
 
 	if (MACHINE_IS_VM) {
 
-		MESSAGE (KERN_INFO,
+		MESSAGE_LOG (KERN_INFO,
                          "%s discipline initializing",
                          dasd_diag_discipline.name);
 
@@ -555,8 +555,9 @@ dasd_diag_init (void)
 		dasd_discipline_add (&dasd_diag_discipline);
 	} else {
 
-		MESSAGE (KERN_INFO,
-			"Machine is not VM: %s discipline not initializing",
+		MESSAGE_LOG (KERN_INFO,
+                             "Machine is not VM: %s discipline not "
+                             "initializing",
                          dasd_diag_discipline.name);
 
 		rc = -EINVAL;
@@ -569,7 +570,7 @@ dasd_diag_cleanup (void)
 {
 	if (MACHINE_IS_VM) {
 
-		MESSAGE (KERN_INFO,
+		MESSAGE_LOG (KERN_INFO,
                          "%s discipline cleaning up",
                          dasd_diag_discipline.name);
 
@@ -578,8 +579,9 @@ dasd_diag_cleanup (void)
 		ctl_clear_bit (0, 9);
 	} else {
 
-		MESSAGE (KERN_INFO,
-                         "Machine is not VM: %s discipline not initializing",
+		MESSAGE_LOG (KERN_INFO,
+                             "Machine is not VM: %s discipline not "
+                             "initializing",
                          dasd_diag_discipline.name);
 	}
 }
diff -urNp linux-460/drivers/s390/block/dasd_eckd.c linux-461/drivers/s390/block/dasd_eckd.c
--- linux-460/drivers/s390/block/dasd_eckd.c
+++ linux-461/drivers/s390/block/dasd_eckd.c
@@ -1779,7 +1779,7 @@ dasd_eckd_init (void)
 {
 	int rc = 0;
 
-	MESSAGE (KERN_INFO,
+	MESSAGE_LOG (KERN_INFO,
 		"%s discipline initializing", 
                  dasd_eckd_discipline.name);
 
@@ -1808,7 +1808,7 @@ void
 dasd_eckd_cleanup (void)
 {
 
-	MESSAGE (KERN_INFO,
+	MESSAGE_LOG (KERN_INFO,
 		"%s discipline cleaning up", 
                  dasd_eckd_discipline.name);
 
diff -urNp linux-460/drivers/s390/block/dasd_fba.c linux-461/drivers/s390/block/dasd_fba.c
--- linux-460/drivers/s390/block/dasd_fba.c
+++ linux-461/drivers/s390/block/dasd_fba.c
@@ -450,7 +450,7 @@ dasd_fba_init (void)
 {
 	int rc = 0;
 
-	MESSAGE (KERN_INFO,
+	MESSAGE_LOG (KERN_INFO,
                  "%s discipline initializing", 
                  dasd_fba_discipline.name);
 
@@ -481,7 +481,7 @@ dasd_fba_init (void)
 void
 dasd_fba_cleanup( void ) {
 
-        MESSAGE (KERN_INFO,
+        MESSAGE_LOG (KERN_INFO,
                  "%s discipline cleaning up", 
                  dasd_fba_discipline.name);
 
diff -urNp linux-460/drivers/s390/block/dasd_int.h linux-461/drivers/s390/block/dasd_int.h
--- linux-460/drivers/s390/block/dasd_int.h
+++ linux-461/drivers/s390/block/dasd_int.h
@@ -303,6 +303,35 @@ do { \
                   d_args); \
 } while(0)
 
+/* messages to be written via klogd only */
+#define DEV_MESSAGE_LOG(d_loglevel,d_device,d_string,d_args...)\
+do { \
+        int d_devno = d_device->devinfo.devno; \
+        int d_irq = d_device->devinfo.irq; \
+        char *d_name = d_device->name; \
+        int d_major = MAJOR(d_device->kdev); \
+        int d_minor = MINOR(d_device->kdev); \
+\
+        printk(d_loglevel PRINTK_HEADER \
+               " /dev/%-7s(%3d:%3d),%04x@%02x: " \
+               d_string "\n", \
+               d_name, \
+               d_major, \
+               d_minor, \
+               d_devno, \
+               d_irq, \
+               d_args); \
+} while(0)
+
+/* general messages to be written via klogd only */
+#define MESSAGE_LOG(d_loglevel,d_string,d_args...)\
+do { \
+        printk(d_loglevel PRINTK_HEADER \
+               " " d_string "\n", \
+               d_args); \
+} while(0)
+
+
 struct dasd_device_t;
 struct request;
 
diff -urNp linux-460/drivers/s390/char/tape_core.c linux-461/drivers/s390/char/tape_core.c
--- linux-460/drivers/s390/char/tape_core.c
+++ linux-461/drivers/s390/char/tape_core.c
@@ -428,7 +428,7 @@ tape_enable_device(struct tape_device *d
 
 	/* Register IRQ. */
 	rc = s390_request_irq_special(device->devinfo.irq, __tape_do_irq,
-				      tape_noper_handler, 0,
+				      tape_noper_handler, SA_DOPATHGROUP,
 				      TAPE_MAGIC, &device->devstat);
 	if (rc)
 		return rc;
@@ -1320,6 +1320,7 @@ MODULE_AUTHOR("(C) 2001 IBM Deutschland 
 	      "Michael Holzheu (cotte@de.ibm.com,holzheu@de.ibm.com)");
 MODULE_DESCRIPTION("Linux on zSeries channel attached "
 		   "tape device driver ($Revision: 1.6 $)");
+MODULE_LICENSE("GPL");
 
 module_init(tape_init);
 module_exit(tape_exit);
diff -urNp linux-460/drivers/s390/s390io.c linux-461/drivers/s390/s390io.c
--- linux-460/drivers/s390/s390io.c
+++ linux-461/drivers/s390/s390io.c
@@ -792,6 +792,8 @@ do_adapter_IO (__u32 intparm)
 	return;
 }
 
+void s390_free_irq (unsigned int irq, void *dev_id);
+
 /*
  * Note : internal use of irqflags SA_PROBE for NOT path grouping 
  *
@@ -828,7 +830,11 @@ s390_request_irq_special (int irq,
 	 */
 	s390irq_spin_lock_irqsave (irq, flags);
 
-	if (!ioinfo[irq]->ui.flags.ready) {
+	if (ioinfo[irq]->ui.flags.unfriendly &&
+	    !(irqflags & SA_FORCE)) {
+		retval = -EUSERS;
+
+	} else if (!ioinfo[irq]->ui.flags.ready) {
 		retry = 5;
 
 		ioinfo[irq]->irq_desc.handler = io_handler;
@@ -862,12 +868,55 @@ s390_request_irq_special (int irq,
 	s390irq_spin_unlock_irqrestore (irq, flags);
 
 	if (retval == 0) {
+		if (irqflags & SA_DOPATHGROUP) {
+			ioinfo[irq]->ui.flags.pgid_supp = 1;
+			ioinfo[irq]->ui.flags.notacccap = 1;
+		}
+		if ((irqflags & SA_DOPATHGROUP) &&
+		    (!ioinfo[irq]->ui.flags.pgid ||
+		     irqflags & SA_PROBE)) {
+			pgid_t pgid;
+			int i, mask;
+			/* 
+			 * Do an initial SensePGID to find out if device
+			 * is locked by someone else.
+			 */
+			memcpy(&pgid, global_pgid, sizeof(pgid_t));
+			
+			retval = -EAGAIN;
+			for (i=0; i<8 && retval==-EAGAIN; i++) {
+
+				mask = (0x80 >> i) & ioinfo[irq]->opm;
+				
+				if (!mask)
+					continue;
+				
+				retval = s390_SensePGID(irq, mask, &pgid);
+				
+				if (retval == -EOPNOTSUPP) 
+					/* Doesn't prevent us from proceeding */
+					retval = 0;
+			}
+			
+		}
 		if (!(irqflags & SA_PROBE) &&
+		    (irqflags & SA_DOPATHGROUP) &&
 		    (!ioinfo[irq]->ui.flags.unfriendly)) 
 			s390_DevicePathVerification (irq, 0);
 
-		ioinfo[irq]->ui.flags.newreq = 1;
-		ioinfo[irq]->nopfunc = not_oper_handler;
+		if (ioinfo[irq]->ui.flags.unfriendly &&
+		    !(irqflags & SA_FORCE)) {
+			/* 
+			 * We found out during path verification that the
+			 * device is locked by someone else and we have to
+			 * let the device driver know.
+			 */
+			retval = -EUSERS;
+			free_irq(irq, dev_id);
+		} else {
+			ioinfo[irq]->ui.flags.newreq = 1;
+			ioinfo[irq]->nopfunc = not_oper_handler;
+		}
 	}
 
 	if (cio_debug_initialized)
@@ -3160,7 +3209,16 @@ s390_process_IRQ (unsigned int irq)
 		if (!ioinfo[irq]->ui.flags.ready)
 			return (ending_status);
 
-		memcpy (udp, &(ioinfo[irq]->devstat), sdevstat);
+		/*
+		 * Special case: We got a deferred cc 3 on a basic sense.
+		 * We have to notify the device driver of the former unit
+		 * check, but must not confuse it by calling it with the status
+		 * for the failed basic sense.
+		 */
+		if (ioinfo[irq]->ui.flags.w4sense)
+			ioinfo[irq]->ui.flags.w4sense = 0;
+		else
+			memcpy (udp, &(ioinfo[irq]->devstat), sdevstat);
 
 		ioinfo[irq]->devstat.intparm = 0;
 
@@ -4541,69 +4599,50 @@ s390_device_recognition_irq (int irq)
 		int irq_ret;
 		devstat_t devstat;
 
-		irq_ret = request_irq (irq,
-				       init_IRQ_handler,
-				       SA_PROBE, "INIT", &devstat);
+		if (ioinfo[irq]->ui.flags.pgid_supp)
+			irq_ret = request_irq (irq,
+					       init_IRQ_handler,
+					       SA_PROBE | SA_DOPATHGROUP,
+					       "INIT", &devstat);
+		else
+			irq_ret = request_irq (irq,
+					       init_IRQ_handler,
+					       SA_PROBE, "INIT", &devstat);
 
 		if (!irq_ret) {
 			ret = enable_cpu_sync_isc (irq);
 
 			if (!ret) {
- 				pgid_t pgid;
-				int i, mask;
- 				/*
- 				 * First thing we should do is a sensePGID in
- 				 * order to find out how we can proceed with
- 				 * the recognition process. 
- 				 * An unfriendly (locked by so else) device 
- 				 * won't take kindly to our attempts at 
- 				 * SetPGID and SenseID...
- 				 */
-  
- 				memcpy(&pgid, global_pgid, sizeof(pgid_t));
-
-				ret = -EAGAIN;
-				for (i=0; i<8 && ret==-EAGAIN; i++) {
-
-					mask = (0x80 >> i) & ioinfo[irq]->opm;
-
-					if (!mask)
-						continue;
-
-					ret = s390_SensePGID(irq, mask, &pgid);
-
+				ioinfo[irq]->ui.flags.unknown = 0;
+				
+				memset (&ioinfo[irq]->senseid, '\0',
+					sizeof (senseid_t));
+				
+				if (cio_sid_with_pgid) {
+					
+					ret = s390_DevicePathVerification(irq,0);
+					
 					if (ret == -EOPNOTSUPP) 
 						/* 
 						 * Doesn't prevent us from proceeding
 						 */
 						ret = 0;
-
 				}
- 				
- 				if (!ret && !ioinfo[irq]->ui.flags.unfriendly) {
-
-					ioinfo[irq]->ui.flags.unknown = 0;
-					
-					memset (&ioinfo[irq]->senseid, '\0',
-						sizeof (senseid_t));
-					
-					if (cio_sid_with_pgid) {
-						
-						ret = s390_DevicePathVerification(irq,0);
-						
-						if (ret == -EOPNOTSUPP) 
-							/* 
-							 * Doesn't prevent us from proceeding
-							 */
-							ret = 0;
+				
+				/*
+				 * we'll fallthrough here if we don't want
+				 * to do SPID before SID
+				 */
+				if (!ret) {
+					ret = s390_SenseID (irq, &ioinfo[irq]->senseid, 0xff);
+					if (ret == -ETIMEDOUT) {
+						/* SenseID timed out.
+						 * We consider this device to be
+						 * boxed for now.
+						 */
+						ioinfo[irq]->ui.flags.unfriendly = 1;
 					}
 
-					/*
-					 * we'll fallthrough here if we don't want
-					 * to do SPID before SID
-					 */
-					if (!ret) {
-						s390_SenseID (irq, &ioinfo[irq]->senseid, 0xff);
 #if 0				/* FIXME */
 				/*
 				 * We initially check the configuration data for
@@ -4646,7 +4685,6 @@ s390_device_recognition_irq (int irq)
 					}
 				}
 #endif
-					}
 				}
 				disable_cpu_sync_isc (irq);
 
@@ -4742,6 +4780,13 @@ s390_trigger_resense(int irq)
 		return -EBUSY;
 	}
 
+	/* 
+	 * This function is called by dasd if it just executed a "steal lock".
+	 * Therefore, re-initialize the 'unfriendly' flag to 0.
+	 * We run into timeouts if the device is still boxed...
+	 */
+	ioinfo[irq]->ui.flags.unfriendly = 0;
+
 	s390_device_recognition_irq(irq);
 
 	return 0;
@@ -4923,8 +4968,6 @@ s390_validate_subchannel (int irq, int e
 	if (ioinfo[irq]->st)
 		return -ENODEV;
 
-	ioinfo[irq]->ui.flags.pgid_supp = 1;
-
 	ioinfo[irq]->opm = ioinfo[irq]->schib.pmcw.pim
 	    & ioinfo[irq]->schib.pmcw.pam & ioinfo[irq]->schib.pmcw.pom;
 
@@ -5603,7 +5646,7 @@ s390_SenseID (int irq, senseid_t * sid, 
 
 	if (!ioinfo[irq]->ui.flags.unknown)
 		irq_ret = 0;
-	else
+	else if (irq_ret != -ETIMEDOUT)
 		irq_ret = -ENODEV;
 
 	return (irq_ret);
@@ -5871,9 +5914,24 @@ s390_DevicePathVerification (int irq, __
 			       "No logical path for sch %d...\n",
 			       irq);
 
-			if (ioinfo[irq]->nopfunc)
-				ioinfo[irq]->nopfunc(irq, DEVSTAT_NOT_ACC);
-
+			if (ioinfo[irq]->nopfunc) {
+				if (ioinfo[irq]->ui.flags.notacccap)
+					ioinfo[irq]->nopfunc(irq,
+							     DEVSTAT_NOT_ACC);
+				else {
+					not_oper_handler_func_t nopfunc =
+						ioinfo[irq]->nopfunc;
+#ifdef CONFIG_PROC_FS
+					/* remove procfs entry */
+					if (cio_proc_devinfo)
+						cio_procfs_device_remove
+							(ioinfo[irq]->devno);
+#endif
+					free_irq(irq,
+						 ioinfo[irq]->irq_desc.dev_id);
+					nopfunc(irq, DEVSTAT_DEVICE_GONE);
+				}
+			}
 			return -ENODEV;
 		}
 		if (!old_opm) {
@@ -5931,7 +5989,9 @@ s390_DevicePathVerification (int irq, __
 		return 0;
 	}
 
-	return s390_do_path_verification (irq, usermask);
+	if (ioinfo[irq]->ui.flags.ready)
+		return s390_do_path_verification (irq, usermask);
+	return 0;
 
 }
 
@@ -7275,10 +7335,15 @@ s390_do_chpid_processing( __u8 chpid)
 			
 			s390irq_spin_unlock(irq);
 			
-			/* Tell the device driver not to disturb us. */
+			/* 
+			 * Tell the device driver not to disturb us. 
+			 * If the driver is not capable of handling
+			 * DEVSTAT_NOT_ACC, it doesn't want path grouping anyway.
+			 */
 			if (ioinfo[irq]->ui.flags.ready &&
 			    schib->pmcw.pim != 0x80 &&
-			    ioinfo[irq]->nopfunc) {
+			    ioinfo[irq]->nopfunc &&
+			    ioinfo[irq]->ui.flags.notacccap) {
 				if (err)
 					ioinfo[irq]->nopfunc(irq, DEVSTAT_NOT_ACC_ERR);
 				else
@@ -7413,7 +7478,8 @@ s390_do_res_acc_processing( __u8 chpid, 
 				/* Tell the device driver not to disturb us. */
 				if (ioinfo[irq]->ui.flags.ready &&
 				    ioinfo[irq]->schib.pmcw.pim != 0x80 &&
-				    ioinfo[irq]->nopfunc)
+				    ioinfo[irq]->nopfunc &&
+				    ioinfo[irq]->ui.flags.notacccap)
 					ioinfo[irq]->nopfunc(irq, DEVSTAT_NOT_ACC);
 
 				ioinfo[irq]->ui.flags.noio = 1;
@@ -7489,7 +7555,8 @@ s390_do_res_acc_processing( __u8 chpid, 
 				/* Tell the device driver not to disturb us. */
 				if (ioinfo[irq]->ui.flags.ready &&
 				    ioinfo[irq]->schib.pmcw.pim != 0x80 &&
-				    ioinfo[irq]->nopfunc)
+				    ioinfo[irq]->nopfunc &&
+				    ioinfo[irq]->ui.flags.notacccap)
 					ioinfo[irq]->nopfunc(irq, DEVSTAT_NOT_ACC);
 
 				ioinfo[irq]->ui.flags.noio = 1;
@@ -7515,11 +7582,41 @@ s390_do_res_acc_processing( __u8 chpid, 
 	}
 }
 
+static int
+__get_chpid_from_lir(void *data)
+{
+	struct lir {
+		u8  iq;
+		u8  ic;
+		u16 sci;
+		/* incident-node descriptor */
+		u32 indesc[28];
+		/* attached-node descriptor */
+		u32 andesc[28];
+		/* incident-specific information */
+		u32 isinfo[28];
+	} *lir;
+
+	lir = (struct lir*) data;
+	if (!(lir->iq&0x80))
+		/* NULL link incident record */
+		return -EINVAL;
+	if (!(lir->indesc[0]&0xc0000000))
+		/* node descriptor not valid */
+		return -EINVAL;
+	if (!(lir->indesc[0]&0x10000000))
+		/* don't handle device-type nodes - FIXME */
+		return -EINVAL;
+	/* Byte 3 contains the chpid. Could also be CTCA, but we don't care */
+
+	return (u16) (lir->indesc[0]&0x000000ff);
+}
+
 void 
 s390_process_css( void ) 
 {
 
-	int ccode, do_sei;
+	int ccode, do_sei, chpid;
 
 	CIO_TRACE_EVENT( 2, "prcss");
 
@@ -7672,9 +7769,11 @@ s390_process_css( void ) 
 				       chsc_area_sei->response_block.
 				       response_block_data.sei_res.rsid);
 			
-			s390_do_chpid_processing(chsc_area_sei->response_block.
-						 response_block_data.sei_res.rsid);
-			
+			chpid = __get_chpid_from_lir(chsc_area_sei->response_block.
+						     response_block_data.sei_res.
+						     ccdf);
+			if (chpid >= 0)
+				s390_do_chpid_processing(chpid);
 			break;
 			
 		case 2: /* i/o resource accessibiliy */
@@ -7814,7 +7913,8 @@ __process_chp_gone(int irq, int chpid)
 		/* Tell the device driver not to disturb us. */
 		if (ioinfo[irq]->ui.flags.ready &&
 		    schib->pmcw.pim != 0x80 &&
-		    ioinfo[irq]->nopfunc) {
+		    ioinfo[irq]->nopfunc &&
+		    ioinfo[irq]->ui.flags.notacccap) {
 			if (err)
 				ioinfo[irq]->nopfunc(irq, DEVSTAT_NOT_ACC_ERR);
 			else
@@ -7849,7 +7949,8 @@ __process_chp_come(int irq, int chpid)
 		/* Tell the device driver not to disturb us. */
 		if (ioinfo[irq]->ui.flags.ready &&
 		    schib->pmcw.pim != 0x80 &&
-		    ioinfo[irq]->nopfunc)
+		    ioinfo[irq]->nopfunc &&
+		    ioinfo[irq]->ui.flags.notacccap)
 			ioinfo[irq]->nopfunc(irq, DEVSTAT_NOT_ACC);
 		
 		ioinfo[irq]->ui.flags.noio = 1;
@@ -8224,7 +8325,8 @@ __vary_chpid_offline(int irq, int chpid)
 		/* Tell the device driver not to disturb us. */
 		if (ioinfo[irq]->ui.flags.ready &&
 		    schib->pmcw.pim != 0x80 &&
-		    ioinfo[irq]->nopfunc)
+		    ioinfo[irq]->nopfunc &&
+		    ioinfo[irq]->ui.flags.notacccap)
 			ioinfo[irq]->nopfunc(irq, DEVSTAT_NOT_ACC);
 		
 		if (out)
@@ -8254,7 +8356,8 @@ __vary_chpid_online(int irq, int chpid)
 		/* Tell the device driver not to disturb us. */
 		if (ioinfo[irq]->ui.flags.ready &&
 		    schib->pmcw.pim != 0x80 &&
-		    ioinfo[irq]->nopfunc)
+		    ioinfo[irq]->nopfunc &&
+		    ioinfo[irq]->ui.flags.notacccap)
 			ioinfo[irq]->nopfunc(irq, DEVSTAT_NOT_ACC);
 		
 		ioinfo[irq]->ui.flags.noio = 1;
@@ -8264,10 +8367,7 @@ __vary_chpid_online(int irq, int chpid)
 			/* Wait for interrupt. */
 			break;
 		
-		if (ioinfo[irq]->ui.flags.ready)
-			s390_schedule_path_verification(irq);
-		else
-			ioinfo[irq]->ui.flags.noio = 0;
+		s390_schedule_path_verification(irq);
 		
 		break;
 	}
diff -urNp linux-460/include/asm-s390/irq.h linux-461/include/asm-s390/irq.h
--- linux-460/include/asm-s390/irq.h
+++ linux-461/include/asm-s390/irq.h
@@ -421,14 +421,8 @@ typedef struct chsc_area_t {
 				__u32 reserved2;
 				/* word 5 */
 				__u32 reserved3;
-				/* word 6 */
-				__u32 ccdf;       /* content-code dependent field */
-				/* word 7 */
-				__u32 reserved4;
-				/* word 8 */
-				__u32 reserved5;
-				/* word 9 */
-				__u32 reserved6;
+				/* word 6-102 */
+				__u32 ccdf[96];   /* content-code dependent field */
 			} __attribute__ ((packed,aligned(8))) sei_res;
 			struct {
 				/* word 2 */
@@ -446,6 +440,8 @@ typedef struct chsc_area_t {
 				__u8 chpid[8];    /* chpids 0-7 */
 				/* words 6-9 */
 				__u16 fla[8];     /* full link addresses 0-7 */
+				/* words 10-102 */
+				__u32 padding[92];
 			} __attribute__ ((packed,aligned(8))) ssd_res;
 		} response_block_data;
 	} __attribute__ ((packed,aligned(8))) response_block;
diff -urNp linux-460/include/asm-s390/s390io.h linux-461/include/asm-s390/s390io.h
--- linux-460/include/asm-s390/s390io.h
+++ linux-461/include/asm-s390/s390io.h
@@ -60,7 +60,8 @@ typedef struct _ioinfo {
 	   unsigned int  unfriendly: 1;  /* device is locked by someone else */
 	   unsigned int  killio    : 1;  /* currently killing pending io */
 	   unsigned int  noio      : 1;  /* don't let drivers start io */
-           unsigned int  unused    : (sizeof(unsigned int)*8 - 27); /* unused */
+	   unsigned int  notacccap : 1;  /* capable of handling DEVSTAT_NOT_ACC */
+           unsigned int  unused    : (sizeof(unsigned int)*8 - 28); /* unused */
               } __attribute__ ((packed)) flags;
         } ui;
 
diff -urNp linux-460/include/asm-s390/signal.h linux-461/include/asm-s390/signal.h
--- linux-460/include/asm-s390/signal.h
+++ linux-461/include/asm-s390/signal.h
@@ -127,6 +127,8 @@ typedef unsigned long sigset_t;
 #define SA_PROBE                SA_ONESHOT
 #define SA_SAMPLE_RANDOM        SA_RESTART
 #define SA_SHIRQ                0x04000000
+#define SA_DOPATHGROUP          0x00100000
+#define SA_FORCE                0x00200000
 #endif
 
 #define SIG_BLOCK          0    /* for blocking signals */
diff -urNp linux-460/include/asm-s390x/irq.h linux-461/include/asm-s390x/irq.h
--- linux-460/include/asm-s390x/irq.h
+++ linux-461/include/asm-s390x/irq.h
@@ -422,14 +422,8 @@ typedef struct chsc_area_t {
 				__u32 reserved2;
 				/* word 5 */
 				__u32 reserved3;
-				/* word 6 */
-				__u32 ccdf;       /* content-code dependent field */
-				/* word 7 */
-				__u32 reserved4;
-				/* word 8 */
-				__u32 reserved5;
-				/* word 9 */
-				__u32 reserved6;
+				/* word 6-102 */
+				__u32 ccdf[96];   /* content-code dependent field */
 			} __attribute__ ((packed,aligned(8))) sei_res;
 			struct {
 				/* word 2 */
@@ -447,6 +441,8 @@ typedef struct chsc_area_t {
 				__u8 chpid[8];    /* chpids 0-7 */
 				/* words 6-9 */
 				__u16 fla[8];     /* full link addresses 0-7 */
+				/* words 10-102 */
+				__u32 padding[92];
 			} __attribute__ ((packed,aligned(8))) ssd_res;
 		} response_block_data;
 	} __attribute__ ((packed,aligned(8))) response_block;
diff -urNp linux-460/include/asm-s390x/s390io.h linux-461/include/asm-s390x/s390io.h
--- linux-460/include/asm-s390x/s390io.h
+++ linux-461/include/asm-s390x/s390io.h
@@ -60,7 +60,8 @@ typedef struct _ioinfo {
 	   unsigned int  unfriendly: 1;  /* device is locked by someone else */
 	   unsigned int  killio    : 1;  /* currently killing pending io */
 	   unsigned int  noio      : 1;  /* don't let drivers start io */
-           unsigned int  unused    : (sizeof(unsigned int)*8 - 27); /* unused */
+	   unsigned int  notacccap : 1;  /* capable of handling DEVSTAT_NOT_ACC */
+           unsigned int  unused    : (sizeof(unsigned int)*8 - 28); /* unused */
               } __attribute__ ((packed)) flags;
         } ui;
 
diff -urNp linux-460/include/asm-s390x/signal.h linux-461/include/asm-s390x/signal.h
--- linux-460/include/asm-s390x/signal.h
+++ linux-461/include/asm-s390x/signal.h
@@ -127,6 +127,8 @@ typedef unsigned long sigset_t;
 #define SA_PROBE                SA_ONESHOT
 #define SA_SAMPLE_RANDOM        SA_RESTART
 #define SA_SHIRQ                0x04000000
+#define SA_DOPATHGROUP          0x00100000
+#define SA_FORCE                0x00200000
 #endif
 
 #define SIG_BLOCK          0    /* for blocking signals */
