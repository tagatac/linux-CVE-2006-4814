diff -urNp linux-5413/arch/ppc64/kernel/ioctl32.c linux-5420/arch/ppc64/kernel/ioctl32.c
--- linux-5413/arch/ppc64/kernel/ioctl32.c
+++ linux-5420/arch/ppc64/kernel/ioctl32.c
@@ -3720,9 +3720,7 @@ COMPATIBLE_IOCTL(FBIOGET_CURSORSTATE),
 COMPATIBLE_IOCTL(FBIOPUT_CURSORSTATE),
 COMPATIBLE_IOCTL(FBIOGET_CON2FBMAP),
 COMPATIBLE_IOCTL(FBIOPUT_CON2FBMAP),
-#if 0
 COMPATIBLE_IOCTL(FBIOBLANK),
-#endif
 /* Little f */
 COMPATIBLE_IOCTL(FIOCLEX),
 COMPATIBLE_IOCTL(FIONCLEX),
diff -urNp linux-5413/drivers/video/matrox/matroxfb_base.h linux-5420/drivers/video/matrox/matroxfb_base.h
--- linux-5413/drivers/video/matrox/matroxfb_base.h
+++ linux-5420/drivers/video/matrox/matroxfb_base.h
@@ -111,6 +111,9 @@
 #if defined(__alpha__) || defined(__mc68000__)
 #define READx_WORKS
 #define MEMCPYTOIO_WORKS
+#elif defined(__powerpc64__)
+#define RAW_READx_WORKS
+#define MEMCPYTOIO_WORKS
 #else
 #define READx_FAILS
 /* recheck __ppc__, maybe that __ppc__ needs MEMCPYTOIO_WRITEL */
@@ -196,6 +199,32 @@ static inline void mga_writew(vaddr_t va
 static inline void mga_writel(vaddr_t va, unsigned int offs, u_int32_t value) {
 	writel(value, va.vaddr + offs);
 }
+
+#elif defined(RAW_READx_WORKS)
+static inline unsigned int mga_readb(vaddr_t va, unsigned int offs) {
+	return __raw_readb(va.vaddr + offs);
+}
+
+static inline unsigned int mga_readw(vaddr_t va, unsigned int offs) {
+	return __raw_readw(va.vaddr + offs);
+}
+
+static inline u_int32_t mga_readl(vaddr_t va, unsigned int offs) {
+	return __raw_readl(va.vaddr + offs);
+}
+
+static inline void mga_writeb(vaddr_t va, unsigned int offs, u_int8_t value) {
+	__raw_writeb(value, va.vaddr + offs);
+}
+
+static inline void mga_writew(vaddr_t va, unsigned int offs, u_int16_t value) {
+	__raw_writew(value, va.vaddr + offs);
+}
+
+static inline void mga_writel(vaddr_t va, unsigned int offs, u_int32_t value) {
+	__raw_writel(value, va.vaddr + offs);
+}
+
 #else
 static inline unsigned int mga_readb(vaddr_t va, unsigned int offs) {
 	return *(volatile u_int8_t*)(va.vaddr + offs);
diff -urNp linux-5413/include/asm-ppc64/eeh.h linux-5420/include/asm-ppc64/eeh.h
--- linux-5413/include/asm-ppc64/eeh.h
+++ linux-5420/include/asm-ppc64/eeh.h
@@ -128,6 +128,17 @@ static inline void eeh_writew(u16 val, v
 	volatile u16 *vaddr = (volatile u16 *)IO_TOKEN_TO_ADDR(addr);
 	out_le16(vaddr, val);
 }
+static inline u16 eeh_raw_readw(void *addr) {
+	volatile u16 *vaddr = (volatile u16 *)IO_TOKEN_TO_ADDR(addr);
+	u16 val = in_be16(vaddr);
+	if (EEH_POSSIBLE_ERROR(addr, vaddr, val, u16))
+		return eeh_check_failure(addr, val);
+	return val;
+}
+static inline void eeh_raw_writew(u16 val, void *addr) {
+	volatile u16 *vaddr = (volatile u16 *)IO_TOKEN_TO_ADDR(addr);
+	out_be16(vaddr, val);
+}
 static inline u32 eeh_readl(void *addr) {
 	volatile u32 *vaddr = (volatile u32 *)IO_TOKEN_TO_ADDR(addr);
 	u32 val = in_le32(vaddr);
@@ -139,6 +150,17 @@ static inline void eeh_writel(u32 val, v
 	volatile u32 *vaddr = (volatile u32 *)IO_TOKEN_TO_ADDR(addr);
 	out_le32(vaddr, val);
 }
+static inline u32 eeh_raw_readl(void *addr) {
+	volatile u32 *vaddr = (volatile u32 *)IO_TOKEN_TO_ADDR(addr);
+	u32 val = in_be32(vaddr);
+	if (EEH_POSSIBLE_ERROR(addr, vaddr, val, u32))
+		return eeh_check_failure(addr, val);
+	return val;
+}
+static inline void eeh_raw_writel(u32 val, void *addr) {
+	volatile u32 *vaddr = (volatile u32 *)IO_TOKEN_TO_ADDR(addr);
+	out_be32(vaddr, val);
+}
 
 static inline void eeh_memset_io(void *addr, int c, unsigned long n) {
 	void *vaddr = (void *)IO_TOKEN_TO_ADDR(addr);
diff -urNp linux-5413/include/asm-ppc64/io.h linux-5420/include/asm-ppc64/io.h
--- linux-5413/include/asm-ppc64/io.h
+++ linux-5420/include/asm-ppc64/io.h
@@ -67,6 +67,18 @@ extern int have_print;
 #define outl(val, port)		eeh_outl(val, (unsigned long)port)
 
 /*
+ * The __raw_read/write macros don't do byte-swapping. 
+ * They are needed for some PCI devices such as the Matrox graphics 
+ * adapter which is programmed to operate in big endian mode.
+ */
+#define __raw_readb(addr)		eeh_readb((void*)(addr))
+#define __raw_readw(addr)		eeh_raw_readw((void*)(addr))
+#define __raw_readl(addr)		eeh_raw_readl((void*)(addr))
+#define __raw_writeb(data, addr)	eeh_writeb((data), ((void*)(addr)))
+#define __raw_writew(data, addr)	eeh_raw_writew((data), ((void*)(addr)))
+#define __raw_writel(data, addr)	eeh_raw_writel((data), ((void*)(addr)))
+
+/*
  * The insw/outsw/insl/outsl macros don't do byte-swapping.
  * They are only used in practice for transferring buffers which
  * are arrays of bytes, and byte-swapping is not appropriate in
diff -urNp linux-5413/include/video/fbcon.h linux-5420/include/video/fbcon.h
--- linux-5413/include/video/fbcon.h
+++ linux-5420/include/video/fbcon.h
@@ -207,7 +207,7 @@ extern int set_all_vcs(int fbidx, struct
 #define fb_memset sbus_memset_io
 
 #elif defined(__i386__) || defined(__alpha__) || \
-      defined(__x86_64__) || defined(__hppa__)
+      defined(__x86_64__) || defined(__hppa__) || defined(__powerpc64__)
 
 #define fb_readb __raw_readb
 #define fb_readw __raw_readw
