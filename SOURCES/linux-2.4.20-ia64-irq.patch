--- linux-2.4.20/include/asm-ia64/machvec.h.larry	2003-04-11 11:25:00.000000000 -0400
+++ linux-2.4.20/include/asm-ia64/machvec.h	2003-04-11 11:33:28.000000000 -0400
@@ -17,7 +17,7 @@
 struct pci_dev;
 struct pt_regs;
 struct scatterlist;
-struct irq_desc;
+struct irq_desc_t;
 struct page;
 
 typedef void ia64_mv_setup_t (char **);
@@ -32,7 +32,7 @@
 typedef void ia64_mv_log_print_t (void);
 typedef void ia64_mv_send_ipi_t (int, int, int, int);
 typedef void ia64_mv_global_tlb_purge_t (unsigned long, unsigned long, unsigned long);
-typedef struct irq_desc *ia64_mv_irq_desc (unsigned int);
+typedef struct irq_desc_t *ia64_mv_irq_desc (unsigned int);
 typedef u8 ia64_mv_irq_to_vector (u8);
 typedef unsigned int ia64_mv_local_vector_to_irq (u8 vector);
 
--- linux-2.4.20/include/asm-ia64/hw_irq.h.larry	2003-04-11 11:25:00.000000000 -0400
+++ linux-2.4.20/include/asm-ia64/hw_irq.h	2003-04-11 11:33:28.000000000 -0400
@@ -86,14 +86,16 @@
 	platform_send_ipi(smp_processor_id(), vector, IA64_IPI_DM_INT, 0);
 }
 
+typedef int irq_cpustat_t;       /* dummy for upper level cpmpatibility */
+
 /*
  * Default implementations for the irq-descriptor API:
  */
 
-extern struct irq_desc _irq_desc[NR_IRQS];
+extern irq_desc_t _irq_desc[NR_IRQS];
 
 #ifndef CONFIG_IA64_GENERIC
-static inline struct irq_desc *
+static inline struct irq_desc_t *
 __ia64_irq_desc (unsigned int irq)
 {
 	return _irq_desc + irq;
@@ -123,10 +125,10 @@
  */
 
 /* Return a pointer to the irq descriptor for IRQ.  */
-static inline struct irq_desc *
-irq_desc (int irq)
+static inline irq_desc_t *
+ia64_irq_desc (int irq)
 {
-	return platform_irq_desc(irq);
+	return (irq_desc_t *)platform_irq_desc(irq);
 }
 
 /* Extract the IA-64 vector that corresponds to IRQ.  */
--- linux-2.4.20/include/asm-ia64/hardirq.h.larry	2003-04-11 11:25:00.000000000 -0400
+++ linux-2.4.20/include/asm-ia64/hardirq.h	2003-04-11 11:33:28.000000000 -0400
@@ -30,6 +30,12 @@
 #define local_syscall_count()		/* unused on IA-64 */
 #define local_nmi_count()		0
 
+#define local_irq_count(cpu)    irq_count(cpu)
+#define local_bh_count(cpu)     bh_count(cpu)
+
+#define hardirq_trylock(cpu)            local_hardirq_trylock()
+#define hardirq_endlock(cpu)            local_hardirq_endlock()
+
 /*
  * Are we in an interrupt context? Either doing bottom half or hardware interrupt
  * processing?
--- linux-2.4.20/arch/ia64/hp/sim/hpsim_irq.c.larry	2003-04-11 11:28:21.000000000 -0400
+++ linux-2.4.20/arch/ia64/hp/sim/hpsim_irq.c	2003-04-11 11:33:28.000000000 -0400
@@ -39,7 +39,7 @@
 	int i;
 
 	for (i = 0; i < NR_IRQS; ++i) {
-		idesc = irq_desc(i);
+		idesc = ia64_irq_desc(i);
 		if (idesc->handler == &no_irq_type)
 			idesc->handler = &irq_type_hp_sim;
 	}
--- linux-2.4.20/arch/ia64/kernel/mca.c.larry	2003-04-11 11:28:21.000000000 -0400
+++ linux-2.4.20/arch/ia64/kernel/mca.c	2003-04-11 11:33:28.000000000 -0400
@@ -524,7 +524,7 @@
 		if (cpev >= 0) {
 			for (irq = 0; irq < NR_IRQS; ++irq)
 				if (irq_to_vector(irq) == cpev) {
-					desc = irq_desc(irq);
+					desc = ia64_irq_desc(irq);
 					desc->status |= IRQ_PER_CPU;
 					desc->handler = &irq_type_iosapic_level;
 					setup_irq(irq, &mca_cpe_irqaction);
--- linux-2.4.20/arch/ia64/kernel/irq_ia64.c.larry	2003-04-11 11:28:21.000000000 -0400
+++ linux-2.4.20/arch/ia64/kernel/irq_ia64.c	2003-04-11 11:33:28.000000000 -0400
@@ -162,7 +162,7 @@
 
 	for (irq = 0; irq < NR_IRQS; ++irq)
 		if (irq_to_vector(irq) == vec) {
-			desc = irq_desc(irq);
+			desc = ia64_irq_desc(irq);
 			desc->status |= IRQ_PER_CPU;
 			desc->handler = &irq_type_ia64_lsapic;
 			if (action)
--- linux-2.4.20/arch/ia64/kernel/irq.c.larry	2003-04-11 11:28:21.000000000 -0400
+++ linux-2.4.20/arch/ia64/kernel/irq.c	2003-04-11 11:33:28.000000000 -0400
@@ -64,11 +64,11 @@
 /*
  * Controller mappings for all interrupt sources:
  */
-irq_desc_t _irq_desc[NR_IRQS] __cacheline_aligned =
+irq_desc_t _irq_desc[NR_IRQS] =
 	{ [0 ... NR_IRQS-1] = { IRQ_DISABLED, &no_irq_type, NULL, 0, SPIN_LOCK_UNLOCKED}};
 
 #ifdef CONFIG_IA64_GENERIC
-struct irq_desc *
+irq_desc_t *
 __ia64_irq_desc (unsigned int irq)
 {
 	return _irq_desc + irq;
@@ -165,7 +165,7 @@
 	*p++ = '\n';
 
 	for (i = 0 ; i < NR_IRQS ; i++) {
-		idesc = irq_desc(i);
+		idesc = ia64_irq_desc(i);
 		action = idesc->action;
 		if (!action)
 			continue;
@@ -522,7 +522,7 @@
 
 inline void disable_irq_nosync(unsigned int irq)
 {
-	irq_desc_t *desc = irq_desc(irq);
+	irq_desc_t *desc = ia64_irq_desc(irq);
 	unsigned long flags;
 
 	spin_lock_irqsave(&desc->lock, flags);
@@ -554,7 +554,7 @@
 	if (!really_local_irq_count()) {
 		do {
 			barrier();
-		} while (irq_desc(irq)->status & IRQ_INPROGRESS);
+		} while (ia64_irq_desc(irq)->status & IRQ_INPROGRESS);
 	}
 #endif
 }
@@ -572,7 +572,7 @@
 
 void enable_irq(unsigned int irq)
 {
-	irq_desc_t *desc = irq_desc(irq);
+	irq_desc_t *desc = ia64_irq_desc(irq);
 	unsigned long flags;
 
 	spin_lock_irqsave(&desc->lock, flags);
@@ -615,7 +615,7 @@
 	 * handled by some other CPU. (or is disabled)
 	 */
 	int cpu = smp_processor_id();
-	irq_desc_t *desc = irq_desc(irq);
+	irq_desc_t *desc = ia64_irq_desc(irq);
 	struct irqaction * action;
 	unsigned int status;
 
@@ -792,7 +792,7 @@
 	if (irq >= NR_IRQS)
 		return;
 
-	desc = irq_desc(irq);
+	desc = ia64_irq_desc(irq);
 	spin_lock_irqsave(&desc->lock,flags);
 	p = &desc->action;
 	for (;;) {
@@ -857,7 +857,7 @@
 	 * flush such a longstanding irq before considering it as spurious.
 	 */
 	for (i = NR_IRQS-1; i > 0; i--)  {
-		desc = irq_desc(i);
+		desc = ia64_irq_desc(i);
 
 		spin_lock_irq(&desc->lock);
 		if (!desc->action)
@@ -875,7 +875,7 @@
 	 * happened in the previous stage, it may have masked itself)
 	 */
 	for (i = NR_IRQS-1; i > 0; i--) {
-		desc = irq_desc(i);
+		desc = ia64_irq_desc(i);
 
 		spin_lock_irq(&desc->lock);
 		if (!desc->action) {
@@ -897,7 +897,7 @@
 	 */
 	val = 0;
 	for (i = 0; i < NR_IRQS; i++) {
-		irq_desc_t *desc = irq_desc(i);
+		irq_desc_t *desc = ia64_irq_desc(i);
 		unsigned int status;
 
 		spin_lock_irq(&desc->lock);
@@ -938,7 +938,7 @@
 
 	mask = 0;
 	for (i = 0; i < 16; i++) {
-		irq_desc_t *desc = irq_desc(i);
+		irq_desc_t *desc = ia64_irq_desc(i);
 		unsigned int status;
 
 		spin_lock_irq(&desc->lock);
@@ -983,7 +983,7 @@
 	nr_irqs = 0;
 	irq_found = 0;
 	for (i = 0; i < NR_IRQS; i++) {
-		irq_desc_t *desc = irq_desc(i);
+		irq_desc_t *desc = ia64_irq_desc(i);
 		unsigned int status;
 
 		spin_lock_irq(&desc->lock);
@@ -1012,7 +1012,7 @@
 	int shared = 0;
 	unsigned long flags;
 	struct irqaction *old, **p;
-	irq_desc_t *desc = irq_desc(irq);
+	irq_desc_t *desc = ia64_irq_desc(irq);
 
 	/*
 	 * Some drivers like serial.c use request_irq() heavily,
@@ -1145,7 +1145,7 @@
 	const char *buf = buffer;
 	int redir;
 
-	if (!irq_desc(irq)->handler->set_affinity)
+	if (!ia64_irq_desc(irq)->handler->set_affinity)
 		return -EIO;
 
 	if (buf[0] == 'r' || buf[0] == 'R') {
@@ -1165,7 +1165,7 @@
 	if (!(new_value & cpu_online_map))
 		return -EINVAL;
 
-	irq_desc(irq)->handler->set_affinity(irq | (redir? IA64_IRQ_REDIRECTED :0), new_value);
+	ia64_irq_desc(irq)->handler->set_affinity(irq | (redir? IA64_IRQ_REDIRECTED :0), new_value);
 
 	return full_count;
 }
@@ -1201,7 +1201,7 @@
 {
 	char name [MAX_NAMELEN];
 
-	if (!root_irq_dir || (irq_desc(irq)->handler == &no_irq_type) || irq_dir[irq])
+	if (!root_irq_dir || (ia64_irq_desc(irq)->handler == &no_irq_type) || irq_dir[irq])
 		return;
 
 	memset(name, 0, MAX_NAMELEN);
@@ -1253,7 +1253,7 @@
 	 * Create entries for all existing IRQs.
 	 */
 	for (i = 0; i < NR_IRQS; i++) {
-		if (irq_desc(i)->handler == &no_irq_type)
+		if (ia64_irq_desc(i)->handler == &no_irq_type)
 			continue;
 		register_irq_proc(i);
 	}
--- linux-2.4.20/arch/ia64/kernel/iosapic.c.larry	2003-04-11 11:28:21.000000000 -0400
+++ linux-2.4.20/arch/ia64/kernel/iosapic.c	2003-04-11 11:33:28.000000000 -0400
@@ -362,7 +362,7 @@
 static void
 iosapic_ack_edge_irq (unsigned int irq)
 {
-	irq_desc_t *idesc = irq_desc(irq);
+	irq_desc_t *idesc = ia64_irq_desc(irq);
 	/*
 	 * Once we have recorded IRQ_PENDING already, we can mask the
 	 * interrupt for real. This prevents IRQ storms from unhandled
@@ -472,7 +472,7 @@
 		irq_type = &irq_type_iosapic_level;
 	}
 
-	idesc = irq_desc(vector);
+	idesc = ia64_irq_desc(vector);
 	if (idesc->handler != irq_type) {
 		if (idesc->handler != &no_irq_type)
 			printk("%s: changing vector %d from %s to %s\n",
@@ -787,7 +787,7 @@
 			dev->irq = vector;
 
 			irq_type = &irq_type_iosapic_level;
-			idesc = irq_desc(vector);
+			idesc = ia64_irq_desc(vector);
 			if (idesc->handler != irq_type) {
 				if (idesc->handler != &no_irq_type)
 					printk("%s: changing vector %d from %s to %s\n",
--- linux-2.4.20/include/asm-ia64/system.h.orig	2003-04-14 11:46:20.000000000 -0400
+++ linux-2.4.20/include/asm-ia64/system.h	2003-04-14 12:00:01.000000000 -0400
@@ -187,6 +187,15 @@
 #endif /* !CONFIG_IA64_DEBUG_IRQ */
 
 #define local_irq_enable()	__asm__ __volatile__ (";; ssm psr.i;; srlz.d" ::: "memory")
+#define local_save_flags(flags) __asm__ __volatile__ ("mov %0=psr" : "=r" (flags) :: "memory")
+
+#define irqs_disabled()		 			\
+	({						\
+		unsigned long flags;			\
+		local_save_flags(flags);		\
+		(flags & IA64_PSR_I) == 0;		\
+	})
+
 
 #define __cli()			local_irq_disable ()
 #define __save_flags(flags)	__asm__ __volatile__ ("mov %0=psr" : "=r" (flags) :: "memory")
