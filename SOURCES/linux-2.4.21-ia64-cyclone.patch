diff -urNp linux-276/arch/ia64/config.in linux-278/arch/ia64/config.in
--- linux-276/arch/ia64/config.in
+++ linux-278/arch/ia64/config.in
@@ -99,6 +99,8 @@ bool 'Performance monitor support' CONFI
 tristate '/proc/pal support' CONFIG_IA64_PALINFO
 tristate '/proc/efi/vars support' CONFIG_EFI_VARS
 
+bool 'Support Cyclone(EXA) Clock' CONFIG_IA64_CYCLONE
+
 bool 'Networking support' CONFIG_NET
 bool 'System V IPC' CONFIG_SYSVIPC
 bool 'BSD Process Accounting' CONFIG_BSD_PROCESS_ACCT
diff -urNp linux-276/arch/ia64/kernel/Makefile linux-278/arch/ia64/kernel/Makefile
--- linux-276/arch/ia64/kernel/Makefile
+++ linux-278/arch/ia64/kernel/Makefile
@@ -25,5 +25,6 @@ obj-$(CONFIG_PCI) += pci.o
 obj-$(CONFIG_SMP) += smp.o smpboot.o
 obj-$(CONFIG_IA64_MCA) += mca.o mca_asm.o
 obj-$(CONFIG_IA64_BRL_EMU) += brl_emu.o
+obj-$(CONFIG_IA64_CYCLONE) += cyclone.o
 
 include $(TOPDIR)/Rules.make
diff -urNp linux-276/arch/ia64/kernel/acpi.c linux-278/arch/ia64/kernel/acpi.c
--- linux-276/arch/ia64/kernel/acpi.c
+++ linux-278/arch/ia64/kernel/acpi.c
@@ -43,6 +43,7 @@
 #include <asm/machvec.h>
 #include <asm/page.h>
 #include <asm/system.h>
+#include <asm/cyclone.h>
 
 
 #define PREFIX			"ACPI: "
@@ -269,6 +270,17 @@ acpi_hp_csr_space(acpi_handle obj, u64 *
 	acpi_os_free(buf.pointer);
 	return status;
 }
+
+/* Hook from generic ACPI tables.c */
+void __init acpi_madt_oem_check(char *oem_id, char *oem_table_id)
+{
+		 if (!strncmp(oem_id, "IBM", 3) &&
+		     (!strncmp(oem_table_id, "SERMOW", 6))){
+		 		 /*Start cyclone clock*/
+		 		 cyclone_setup(0);
+		 }
+}
+
 #endif /* CONFIG_ACPI */
 
 #ifdef CONFIG_ACPI_BOOT
@@ -554,6 +566,9 @@ acpi_parse_madt (unsigned long phys_addr
 		ipi_base_addr = (unsigned long) ioremap(acpi_madt->lapic_address, 0);
 
 	printk(KERN_INFO PREFIX "Local APIC address 0x%lx\n", ipi_base_addr);
+
+	acpi_madt_oem_check(acpi_madt->header.oem_id,
+			acpi_madt->header.oem_table_id);
 	return 0;
 }
 
diff -urNp linux-276/arch/ia64/kernel/cyclone.c linux-278/arch/ia64/kernel/cyclone.c
--- linux-276/arch/ia64/kernel/cyclone.c
+++ linux-278/arch/ia64/kernel/cyclone.c
@@ -0,0 +1,119 @@
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/param.h>
+#include <asm/io.h>
+
+/* IBM Summit (EXA) Cyclone Timer code*/
+#define CYCLONE_CBAR_ADDR 0xFEB00CD0
+#define CYCLONE_PMCC_OFFSET 0x51A0
+#define CYCLONE_MPMC_OFFSET 0x51D0
+#define CYCLONE_MPCS_OFFSET 0x51A8
+#define CYCLONE_TIMER_FREQ 100000000
+
+int use_cyclone;
+int __init cyclone_setup(char *str) 
+{
+		 use_cyclone = 1;
+		 return 1;
+}
+
+static u32* volatile cyclone_timer;		 /* Cyclone MPMC0 register */
+static u32 last_tick_cyclone;
+
+static unsigned long delay_at_last_interrupt;
+
+unsigned long do_gettimeoffset_cyclone(void)
+{
+		 u32 offset;
+
+		 /* Read the cyclone timer */
+		 offset = cyclone_timer[0];
+		 /* .. relative to previous jiffy */
+		 offset = offset - last_tick_cyclone;
+
+		 /* convert cyclone ticks to microseconds */		 
+		 offset = offset/(CYCLONE_TIMER_FREQ/1000000);
+
+		 /* our adjusted time offset in microseconds */
+		 return delay_at_last_interrupt + (unsigned long)offset;
+}
+
+void mark_timeoffset_cyclone(void)
+{
+		 last_tick_cyclone += CYCLONE_TIMER_FREQ/HZ;
+}
+
+
+void __init init_cyclone_clock(void)
+{
+		 u64* reg;		 
+		 u64 base;		 		 /* saved cyclone base address */
+		 u64 offset;		 		 /* offset from pageaddr to cyclone_timer register */
+		 int i;
+		 
+		 printk(KERN_INFO "Summit chipset: Starting Cyclone Counter.\n");
+
+		 /* find base address */
+		 offset = (CYCLONE_CBAR_ADDR);
+		 reg = (u64*)ioremap_nocache(offset, sizeof(u64));
+		 if(!reg){
+		 		 printk(KERN_ERR "Summit chipset: Could not find valid CBAR register.\n");
+		 		 use_cyclone = 0;
+		 		 return;
+		 }
+		 base = *reg;		 
+		 if(!base){
+		 		 printk(KERN_ERR "Summit chipset: Could not find valid CBAR value.\n");
+		 		 use_cyclone = 0;
+		 		 return;
+		 }
+		 iounmap(reg);
+		 		 
+		 /* setup PMCC */
+		 offset = (base + CYCLONE_PMCC_OFFSET);
+		 reg = (u64*)ioremap_nocache(offset, sizeof(u64));
+		 if(!reg){
+		 		 printk(KERN_ERR "Summit chipset: Could not find valid PMCC register.\n");
+		 		 use_cyclone = 0;
+		 		 return;
+		 }
+		 reg[0] = 0x00000001;
+		 iounmap(reg);
+		 
+		 /* setup MPCS */
+		 offset = (base + CYCLONE_MPCS_OFFSET);
+		 reg = (u64*)ioremap_nocache(offset, sizeof(u64));
+		 if(!reg){
+		 		 printk(KERN_ERR "Summit chipset: Could not find valid MPCS register.\n");
+		 		 use_cyclone = 0;
+		 		 return;
+		 }
+		 reg[0] = 0x00000001;
+		 iounmap(reg);
+		 
+		 /* map in cyclone_timer */
+		 offset = (base + CYCLONE_MPMC_OFFSET);
+		 cyclone_timer = (u32*)ioremap_nocache(offset, sizeof(u32));
+		 if(!cyclone_timer){
+		 		 printk(KERN_ERR "Summit chipset: Could not find valid MPMC register.\n");
+		 		 use_cyclone = 0;
+		 		 return;
+		 }
+
+		 /*quick test to make sure its ticking*/
+		 for(i=0; i<3; i++){
+		 		 u32 old = cyclone_timer[0];
+		 		 int stall = 100;
+		 		 while(stall--) barrier();
+		 		 if(cyclone_timer[0] == old){
+		 		 		 printk(KERN_ERR "Summit chipset: Counter not counting! DISABLED\n");
+		 		 		 iounmap(cyclone_timer);
+		 		 		 cyclone_timer = 0;
+		 		 		 use_cyclone = 0;
+		 		 		 return;
+		 		 }
+		 }
+		 last_tick_cyclone = cyclone_timer[0];
+}
+
diff -urNp linux-276/arch/ia64/kernel/time.c linux-278/arch/ia64/kernel/time.c
--- linux-276/arch/ia64/kernel/time.c
+++ linux-278/arch/ia64/kernel/time.c
@@ -23,6 +23,7 @@
 #include <asm/ptrace.h>
 #include <asm/sal.h>
 #include <asm/system.h>
+#include <asm/cyclone.h>
 
 extern rwlock_t xtime_lock;
 extern unsigned long wall_jiffies;
@@ -45,6 +46,9 @@ gettimeoffset (void)
 	unsigned long now, last_tick;
 #	define time_keeper_id	0	/* smp_processor_id() of time-keeper */
 
+	if (use_cyclone)
+		return do_gettimeoffset_cyclone() + lost * (1000000 / HZ);
+
 	last_tick = (cpu_data(time_keeper_id)->itm_next
 		     - (lost + 1)*cpu_data(time_keeper_id)->itm_delta);
 
@@ -153,6 +157,8 @@ timer_interrupt(int irq, void *dev_id, s
 			write_lock(&xtime_lock);
 			do_timer(regs);
 			local_cpu_data->itm_next = new_itm;
+			if (use_cyclone)
+				mark_timeoffset_cyclone();
 			write_unlock(&xtime_lock);
 		} else
 			local_cpu_data->itm_next = new_itm;
@@ -267,4 +273,6 @@ time_init (void)
 	register_percpu_irq(IA64_TIMER_VECTOR, &timer_irqaction);
 	efi_gettimeofday((struct timeval *) &xtime);
 	ia64_init_itm();
+	if (use_cyclone)
+		init_cyclone_clock();
 }
diff -urNp linux-276/include/asm-ia64/cyclone.h linux-278/include/asm-ia64/cyclone.h
--- linux-276/include/asm-ia64/cyclone.h
+++ linux-278/include/asm-ia64/cyclone.h
@@ -0,0 +1,22 @@
+#ifndef ASM_IA64_CYCLONE_H
+#define ASM_IA64_CYCLONE_H
+
+#ifdef		 CONFIG_IA64_CYCLONE
+extern int use_cyclone;
+extern int __init cyclone_setup(char*);
+extern unsigned long do_gettimeoffset_cyclone(void);
+extern void mark_timeoffset_cyclone(void);
+extern void __init init_cyclone_clock(void);
+#else		 /* CONFIG_IA64_CYCLONE */
+#define use_cyclone 0
+static inline void cyclone_setup(char* s) 
+{
+		 printk(KERN_ERR "Cyclone Counter: System not configured"
+		 		 		 		 		 " w/ CONFIG_IA64_CYCLONE.\n");
+}
+static inline unsigned long do_gettimeoffset_cyclone(void){}
+static inline void mark_timeoffset_cyclone(void){}
+static inline void init_cyclone_clock(void){}
+#endif		 /* CONFIG_IA64_CYCLONE */
+
+#endif		 /* !ASM_IA64_CYCLONE_H */
