diff -urNp linux-5400/Documentation/Configure.help linux-5410/Documentation/Configure.help
--- linux-5400/Documentation/Configure.help
+++ linux-5410/Documentation/Configure.help
@@ -19356,6 +19356,20 @@ CONFIG_ACPI
   The ACPI Sourceforge project may also be of interest:
   <http://sf.net/projects/acpi/>
 
+ACPI Processor Enumeration Only
+CONFIG_ACPI_HT_ONLY
+  This option enables limited ACPI support -- just enough to
+  enumerate processors from the ACPI Multiple APIC Description
+  Table (MADT).  Note that ACPI supports both logical (e.g. Hyper-
+  Threading) and physical processors, where the MultiProcessor
+  Specification (MPS) table only supports physical processors.
+
+  Full ACPI support (CONFIG_ACPI) is preferred.  Use this option
+  only if you wish to limit ACPI's role to processor enumeration.
+
+  In this configuration, ACPI defaults to off. It must be enabled
+  on the command-line with the "acpismp=force" option.
+
 Enable ACPI 2.0 with errata 1.3
 CONFIG_ACPI20
   Enable support for the 2.0 version of the ACPI interpreter.  See the
@@ -19451,6 +19465,53 @@ CONFIG_ACPI_TOSHIBA
   If you have a legacy free Toshiba laptop (such as the Libretto L1
   series), say Y.
 
+ACPI ASUS/Medion Laptop Extras
+CONFIG_ACPI_ASUS
+  This driver provides support for extra features of ACPI-compatible
+  ASUS laptops. As some of Medion laptops are made by ASUS, it may also
+  support some Medion laptops (such as 9675 for example).  It makes all
+  the extra buttons generate standard ACPI events that go through
+  /proc/acpi/events, and (on some models) adds support for changing the
+  display brightness and output, switching the LCD backlight on and off,
+  and most importantly, allows you to blink those fancy LEDs intended
+  for reporting mail and wireless status.
+  
+  All settings are changed via /proc/acpi/asus directory entries. Owner
+  and group for these entries can be set with asus_uid and asus_gid
+  parameters.
+  
+  More information and a userspace daemon for handling the extra buttons
+  at <http://sourceforge.net/projects/acpi4asus/>.
+  
+  If you have an ACPI-compatible ASUS laptop, say Y or M here. This
+  driver is still under development, so if your laptop is unsupported or
+  something works not quite as expected, please use the mailing list
+  available on the above page (acpi4asus-user@lists.sourceforge.net)
+  
+ACPI Toshiba Laptop Extras
+CONFIG_ACPI_TOSHIBA
+  This driver adds support for access to certain system settings
+  on "legacy free" Toshiba laptops.  These laptops can be recognized by
+  their lack of a BIOS setup menu and APM support.
+
+  On these machines, all system configuration is handled through the
+  ACPI.  This driver is required for access to controls not covered
+  by the general ACPI drivers, such as LCD brightness, video output,
+  etc.
+
+  This driver differs from the non-ACPI Toshiba laptop driver (located
+  under "Processor type and features") in several aspects.
+  Configuration is accessed by reading and writing text files in the
+  /proc tree instead of by program interface to /dev.  Furthermore, no
+  power management functions are exposed, as those are handled by the
+  general ACPI drivers.
+
+  More information about this driver is available at
+  <http://memebeam.org/toys/ToshibaAcpiDriver>.
+
+  If you have a legacy free Toshiba laptop (such as the Libretto L1
+  series), say Y.
+
 Advanced Power Management BIOS support
 CONFIG_APM
   APM is a BIOS specification for saving power using several different
diff -urNp linux-5400/Documentation/kernel-parameters.txt linux-5410/Documentation/kernel-parameters.txt
--- linux-5400/Documentation/kernel-parameters.txt
+++ linux-5410/Documentation/kernel-parameters.txt
@@ -344,6 +344,18 @@ running once the system is up.
 			memory; to be used when the kernel is not able
 			to see the whole system memory or for test.
 
+	mem=nn[KMG]@ss[KMG]
+			[KNL,BOOT] Force usage of a specific region of memory
+			Region of memory to be used, from ss to ss+nn.
+
+	mem=nn[KMG]#ss[KMG]
+			[KNL,BOOT,ACPI] Mark specific memory as ACPI data.
+			Region of memory to be used, from ss to ss+nn.
+
+	mem=nn[KMG]$ss[KMG]
+			[KNL,BOOT,ACPI] Mark specific memory as reserved.
+			Region of memory to be used, from ss to ss+nn.
+
 	memfrac=	[KNL]
 
 	mga=		[HW,DRM]
diff -urNp linux-5400/drivers/acpi/Config.in linux-5410/drivers/acpi/Config.in
--- linux-5400/drivers/acpi/Config.in
+++ linux-5410/drivers/acpi/Config.in
@@ -1,17 +1,94 @@
 #
-# ACPI configuration
+# ACPI Configuration
 #
-#mainmenu_option next_comment
-#comment 'ACPI Configuration'
 
-dep_bool     '    ACPI Debug Statements' CONFIG_ACPI_DEBUG $CONFIG_ACPI
-dep_tristate '    ACPI Bus Manager' CONFIG_ACPI_BUSMGR $CONFIG_ACPI
+if [ "$CONFIG_X86" = "y" ]; then
 
-dep_tristate '      System' CONFIG_ACPI_SYS $CONFIG_ACPI_BUSMGR $CONFIG_ACPI
-dep_tristate '      Processor' CONFIG_ACPI_CPU $CONFIG_ACPI_BUSMGR $CONFIG_ACPI
-dep_tristate '      Button' CONFIG_ACPI_BUTTON $CONFIG_ACPI_BUSMGR $CONFIG_ACPI
-dep_tristate '      AC Adapter' CONFIG_ACPI_AC $CONFIG_ACPI_BUSMGR $CONFIG_ACPI
-dep_tristate '      Embedded Controller' CONFIG_ACPI_EC $CONFIG_ACPI_BUSMGR $CONFIG_ACPI
-dep_tristate '      Control Method Battery' CONFIG_ACPI_CMBATT $CONFIG_ACPI_BUSMGR $CONFIG_ACPI $CONFIG_ACPI_EC
-dep_tristate '      Thermal' CONFIG_ACPI_THERMAL $CONFIG_ACPI_BUSMGR $CONFIG_ACPI  $CONFIG_ACPI_EC
-#endmenu
+  mainmenu_option next_comment
+  comment 'ACPI Support'
+  bool         'ACPI Support' CONFIG_ACPI
+  if [ "$CONFIG_ACPI" = "y" ]; then
+    if [ "$CONFIG_X86_LOCAL_APIC" = "y" ]; then
+      bool         'CPU Enumeration Only' CONFIG_ACPI_HT_ONLY
+    fi
+
+    if [ "$CONFIG_ACPI_HT_ONLY" = "n" ]; then
+      define_bool CONFIG_ACPI_BOOT		y
+      define_bool CONFIG_ACPI_BUS		y
+      define_bool CONFIG_ACPI_INTERPRETER	y
+      define_bool CONFIG_ACPI_EC		y
+      define_bool CONFIG_ACPI_POWER		y
+      if [ "$CONFIG_PCI" = "y" ]; then
+        define_bool CONFIG_ACPI_PCI		y
+      fi
+      define_bool CONFIG_ACPI_SLEEP		n
+      define_bool CONFIG_ACPI_SYSTEM		y
+      tristate     '  AC Adapter'	CONFIG_ACPI_AC
+      tristate     '  Battery'		CONFIG_ACPI_BATTERY
+      tristate     '  Button'		CONFIG_ACPI_BUTTON
+      tristate     '  Fan'		CONFIG_ACPI_FAN
+      tristate     '  Processor'	CONFIG_ACPI_PROCESSOR
+      dep_tristate '  Thermal Zone' 	CONFIG_ACPI_THERMAL $CONFIG_ACPI_PROCESSOR
+      if [ "$CONFIG_NUMA" = "y" ]; then
+        dep_bool       '  NUMA support'     CONFIG_ACPI_NUMA $CONFIG_NUMA
+      fi
+      tristate     '  ASUS Laptop Extras'  CONFIG_ACPI_ASUS
+      tristate     '  Toshiba Laptop Extras'	CONFIG_ACPI_TOSHIBA
+      bool         '  Debug Statements'	CONFIG_ACPI_DEBUG
+      if [ "$CONFIG_X86_64" = "y" ] ; then
+        bool	   '  ACPI PM timer support' CONFIG_ACPI_PMTMR
+      fi
+    fi
+  fi
+
+  endmenu
+
+fi
+
+
+if [ "$CONFIG_IA64" = "y" ]; then
+
+  if [ "$CONFIG_IA64_SGI_SN" = "y" ]; then
+    mainmenu_option next_comment
+    comment 'ACPI Support'
+    define_bool CONFIG_ACPI		y
+    define_bool CONFIG_ACPI_EFI		y
+    define_bool CONFIG_ACPI_BOOT	y
+    define_bool CONFIG_ACPI_BUS		n
+    define_bool CONFIG_ACPI_INTERPRETER n
+    define_bool CONFIG_ACPI_PCI		n
+    define_bool CONFIG_ACPI_POWER 	n
+    define_bool CONFIG_ACPI_SYSTEM 	n
+    define_bool CONFIG_ACPI_BUTTON	n
+    define_bool CONFIG_ACPI_FAN		n
+    define_bool CONFIG_ACPI_PROCESSOR	n
+    define_bool CONFIG_ACPI_THERMAL	n
+    define_bool CONFIG_ACPI_NUMA	y
+    endmenu
+  fi
+
+  if [ "$CONFIG_IA64_HP_SIM" = "n" ]; then
+    mainmenu_option next_comment
+    comment 'ACPI Support'
+    if [ "$CONFIG_PCI" = "y" ]; then
+      define_bool CONFIG_ACPI_PCI 	y
+    fi
+    define_bool CONFIG_ACPI		y
+    define_bool CONFIG_ACPI_EFI		y
+    define_bool CONFIG_ACPI_BOOT	y
+    define_bool CONFIG_ACPI_BUS		y
+    define_bool CONFIG_ACPI_INTERPRETER y
+    define_bool CONFIG_ACPI_POWER 	y
+    define_bool CONFIG_ACPI_SYSTEM 	y
+    tristate     '  Button'		CONFIG_ACPI_BUTTON
+    tristate     '  Fan'		CONFIG_ACPI_FAN
+    tristate     '  Processor'		CONFIG_ACPI_PROCESSOR
+    dep_tristate '  Thermal Zone'       CONFIG_ACPI_THERMAL $CONFIG_ACPI_PROCESSOR
+    if [ "$CONFIG_NUMA" = "y" ]; then
+      dep_bool       '  NUMA support'       CONFIG_ACPI_NUMA $CONFIG_NUMA
+    fi
+    bool         '  Debug Statements' 	CONFIG_ACPI_DEBUG
+    endmenu
+  fi
+
+fi
diff -urNp linux-5400/drivers/acpi/Makefile linux-5410/drivers/acpi/Makefile
--- linux-5400/drivers/acpi/Makefile
+++ linux-5410/drivers/acpi/Makefile
@@ -4,51 +4,55 @@
 
 O_TARGET := acpi.o
 
-export-objs := acpi_ksyms.o
-
 export ACPI_CFLAGS
 
-ACPI_CFLAGS := -D_LINUX -I$(CURDIR)/include
-
-#
-# CONFIG_ACPI_KERNEL_CONFIG is currently only IA64
-#
-ifdef CONFIG_ACPI_KERNEL_CONFIG
-  ACPI_CFLAGS += -DCONFIG_ACPI_KERNEL_CONFIG_ONLY
-endif
-
-acpi-subdirs := utilities dispatcher events hardware \
-		executer namespace parser resources tables
+ACPI_CFLAGS	:= -Os 
 
 ifdef CONFIG_ACPI_DEBUG
-  ACPI_CFLAGS += -DACPI_DEBUG -Wno-unused
-endif
-
-ifdef CONFIG_ACPI_DEBUGGER
-  ACPI_CFLAGS += -DENABLE_DEBUGGER
-  acpi-subdirs += debugger
+  ACPI_CFLAGS	+= -DACPI_DEBUG_OUTPUT
 endif
 
-EXTRA_CFLAGS += $(ACPI_CFLAGS)
+EXTRA_CFLAGS	+= $(ACPI_CFLAGS)
 
-mod-subdirs  := ospm
+export-objs 	:= acpi_ksyms.o processor.o
 
-subdir-$(CONFIG_ACPI) 		+= $(acpi-subdirs)
-subdir-$(CONFIG_ACPI_BUSMGR)	+= ospm
+obj-y		:= acpi_ksyms.o 
 
-obj-$(CONFIG_ACPI)	+= driver.o os.o acpi_ksyms.o
-obj-$(CONFIG_ACPI)	+= $(foreach dir,$(acpi-subdirs),$(dir)/$(dir).o) 
-ifdef CONFIG_ACPI_KERNEL_CONFIG
-   obj-$(CONFIG_ACPI) 	+= acpiconf.o osconf.o
+#
+# ACPI Boot-Time Table Parsing
+#
+ifeq ($(CONFIG_ACPI_BOOT),y)
+  obj-y		+= tables.o blacklist.o
 endif
 
-ifeq ($(CONFIG_ACPI_BUSMGR),y)
-	obj-y			+= ospm/ospm.o
+#
+# ACPI Core Subsystem (Interpreter)
+#
+ifeq ($(CONFIG_ACPI_INTERPRETER),y)
+  obj-y		+= osl.o utils.o
+  subdir-y	+= dispatcher events executer hardware namespace parser \
+		   resources tables utilities
+  obj-y 	+= $(foreach dir,$(subdir-y),$(dir)/$(dir).o)
 endif
 
-# commented out until we distribute it -ASG
-#ifeq ($(CONFIG_KDB),y)
-#	obj-m	+= kdb/kdbm_acpi.o
-#endif
+#
+# ACPI Bus and Device Drivers
+#
+ifeq ($(CONFIG_ACPI_BUS),y)
+  obj-y				+= bus.o 
+  obj-$(CONFIG_ACPI_AC) 	+= ac.o
+  obj-$(CONFIG_ACPI_BATTERY)	+= battery.o
+  obj-$(CONFIG_ACPI_BUTTON)	+= button.o
+  obj-$(CONFIG_ACPI_EC)		+= ec.o
+  obj-$(CONFIG_ACPI_FAN)	+= fan.o
+  obj-$(CONFIG_ACPI_PCI)	+= pci_root.o pci_link.o pci_irq.o pci_bind.o
+  obj-$(CONFIG_ACPI_POWER)	+= power.o
+  obj-$(CONFIG_ACPI_PROCESSOR)	+= processor.o
+  obj-$(CONFIG_ACPI_THERMAL)	+= thermal.o
+  obj-$(CONFIG_ACPI_SYSTEM)	+= system.o
+  obj-$(CONFIG_ACPI_NUMA)	+= numa.o
+  obj-$(CONFIG_ACPI_ASUS)	+= asus_acpi.o
+  obj-$(CONFIG_ACPI_TOSHIBA)	+= toshiba_acpi.o
+endif
 
 include $(TOPDIR)/Rules.make
diff -urNp linux-5400/drivers/acpi/ac.c linux-5410/drivers/acpi/ac.c
--- linux-5400/drivers/acpi/ac.c
+++ linux-5410/drivers/acpi/ac.c
@@ -0,0 +1,346 @@
+/*
+ *  acpi_ac.c - ACPI AC Adapter Driver ($Revision: 26 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/compatmac.h>
+#include <linux/proc_fs.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+
+#define _COMPONENT		ACPI_AC_COMPONENT
+ACPI_MODULE_NAME		("acpi_ac")
+
+MODULE_AUTHOR("Paul Diefenbaugh");
+MODULE_DESCRIPTION(ACPI_AC_DRIVER_NAME);
+MODULE_LICENSE("GPL");
+
+#define PREFIX			"ACPI: "
+
+
+int acpi_ac_add (struct acpi_device *device);
+int acpi_ac_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_ac_driver = {
+	.name =		ACPI_AC_DRIVER_NAME,
+	.class =	ACPI_AC_CLASS,
+	.ids =		ACPI_AC_HID,
+	.ops =		{
+				.add =		acpi_ac_add,
+				.remove =	acpi_ac_remove,
+			},
+};
+
+struct acpi_ac {
+	acpi_handle		handle;
+	unsigned long		state;
+};
+
+
+/* --------------------------------------------------------------------------
+                               AC Adapter Management
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_ac_get_state (
+	struct acpi_ac		*ac)
+{
+	acpi_status		status = AE_OK;
+
+	ACPI_FUNCTION_TRACE("acpi_ac_get_state");
+
+	if (!ac)
+		return_VALUE(-EINVAL);
+
+	status = acpi_evaluate_integer(ac->handle, "_PSR", NULL, &ac->state);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error reading AC Adapter state\n"));
+		ac->state = ACPI_AC_STATUS_UNKNOWN;
+		return_VALUE(-ENODEV);
+	}
+	
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+struct proc_dir_entry		*acpi_ac_dir = NULL;
+
+static int
+acpi_ac_read_state (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_ac		*ac = (struct acpi_ac *) data;
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_ac_read_state");
+
+	if (!ac || (off != 0))
+		goto end;
+
+	if (acpi_ac_get_state(ac)) {
+		p += sprintf(p, "ERROR: Unable to read AC Adapter state\n");
+		goto end;
+	}
+
+	p += sprintf(p, "state:                   ");
+	switch (ac->state) {
+	case ACPI_AC_STATUS_OFFLINE:
+		p += sprintf(p, "off-line\n");
+		break;
+	case ACPI_AC_STATUS_ONLINE:
+		p += sprintf(p, "on-line\n");
+		break;
+	default:
+		p += sprintf(p, "unknown\n");
+		break;
+	}
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_ac_add_fs (
+	struct acpi_device	*device)
+{
+	struct proc_dir_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_ac_add_fs");
+
+	if (!acpi_device_dir(device)) {
+		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
+			acpi_ac_dir);
+		if (!acpi_device_dir(device))
+			return_VALUE(-ENODEV);
+	}
+
+	/* 'state' [R] */
+	entry = create_proc_entry(ACPI_AC_FILE_STATE,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_AC_FILE_STATE));
+	else {
+		entry->read_proc = acpi_ac_read_state;
+		entry->data = acpi_driver_data(device);
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_ac_remove_fs (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_ac_remove_fs");
+
+	if (acpi_device_dir(device)) {
+		remove_proc_entry(acpi_device_bid(device), acpi_ac_dir);
+		acpi_device_dir(device) = NULL;
+	}
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                   Driver Model
+   -------------------------------------------------------------------------- */
+
+void
+acpi_ac_notify (
+	acpi_handle		handle,
+	u32			event,
+	void			*data)
+{
+	struct acpi_ac		*ac = (struct acpi_ac *) data;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_ac_notify");
+
+	if (!ac)
+		return;
+
+	if (acpi_bus_get_device(ac->handle, &device))
+		return_VOID;
+
+	switch (event) {
+	case ACPI_AC_NOTIFY_STATUS:
+		acpi_ac_get_state(ac);
+		acpi_bus_generate_event(device, event, (u32) ac->state);
+		break;
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Unsupported event [0x%x]\n", event));
+		break;
+	}
+
+	return_VOID;
+}
+
+
+int
+acpi_ac_add (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_ac		*ac = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_ac_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	ac = kmalloc(sizeof(struct acpi_ac), GFP_KERNEL);
+	if (!ac)
+		return_VALUE(-ENOMEM);
+	memset(ac, 0, sizeof(struct acpi_ac));
+
+	ac->handle = device->handle;
+	sprintf(acpi_device_name(device), "%s", ACPI_AC_DEVICE_NAME);
+	sprintf(acpi_device_class(device), "%s", ACPI_AC_CLASS);
+	acpi_driver_data(device) = ac;
+
+	result = acpi_ac_get_state(ac);
+	if (result)
+		goto end;
+
+	result = acpi_ac_add_fs(device);
+	if (result)
+		goto end;
+
+	status = acpi_install_notify_handler(ac->handle,
+		ACPI_DEVICE_NOTIFY, acpi_ac_notify, ac);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error installing notify handler\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	printk(KERN_INFO PREFIX "%s [%s] (%s)\n", 
+		acpi_device_name(device), acpi_device_bid(device), 
+		ac->state?"on-line":"off-line");
+
+end:
+	if (result) {
+		acpi_ac_remove_fs(device);
+		kfree(ac);
+	}
+
+	return_VALUE(result);
+}
+
+
+int
+acpi_ac_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_ac		*ac = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_ac_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	ac = (struct acpi_ac *) acpi_driver_data(device);
+
+	status = acpi_remove_notify_handler(ac->handle,
+		ACPI_DEVICE_NOTIFY, acpi_ac_notify);
+	if (ACPI_FAILURE(status))
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error removing notify handler\n"));
+
+	acpi_ac_remove_fs(device);
+
+	kfree(ac);
+
+	return_VALUE(0);
+}
+
+
+int __init
+acpi_ac_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_ac_init");
+
+	acpi_ac_dir = proc_mkdir(ACPI_AC_CLASS, acpi_root_dir);
+	if (!acpi_ac_dir)
+		return_VALUE(-ENODEV);
+
+	result = acpi_bus_register_driver(&acpi_ac_driver);
+	if (result < 0) {
+		remove_proc_entry(ACPI_AC_CLASS, acpi_root_dir);
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+
+
+void __exit
+acpi_ac_exit (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_ac_exit");
+
+	acpi_bus_unregister_driver(&acpi_ac_driver);
+
+	remove_proc_entry(ACPI_AC_CLASS, acpi_root_dir);
+
+	return_VOID;
+}
+
+
+module_init(acpi_ac_init);
+module_exit(acpi_ac_exit);
diff -urNp linux-5400/drivers/acpi/acpi_ksyms.c linux-5410/drivers/acpi/acpi_ksyms.c
--- linux-5400/drivers/acpi/acpi_ksyms.c
+++ linux-5410/drivers/acpi/acpi_ksyms.c
@@ -1,64 +1,56 @@
 /*
- *  ksyms.c - ACPI exported symbols
+ *  acpi_ksyms.c - ACPI Kernel Symbols ($Revision: 15 $)
  *
- *  Copyright (C) 2000 Andrew Grover
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
  *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 
-#include <linux/config.h>
 #include <linux/module.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/types.h>
 #include <linux/acpi.h>
-#include "acpi.h"
-#include "acdebug.h"
 
-extern int acpi_in_debugger;
-extern FADT_DESCRIPTOR acpi_fadt;
+#ifdef CONFIG_ACPI_INTERPRETER
 
-#define _COMPONENT	OS_DEPENDENT
-	MODULE_NAME	("symbols")
+/* ACPI Debugger */
 
 #ifdef ENABLE_DEBUGGER
+
+extern int			acpi_in_debugger;
+
 EXPORT_SYMBOL(acpi_in_debugger);
 EXPORT_SYMBOL(acpi_db_user_commands);
-#endif
 
-#ifdef ACPI_DEBUG
+#endif /* ENABLE_DEBUGGER */
+
+/* ACPI Core Subsystem */
+
+#ifdef ACPI_DEBUG_OUTPUT
+EXPORT_SYMBOL(acpi_dbg_layer);
+EXPORT_SYMBOL(acpi_dbg_level);
 EXPORT_SYMBOL(acpi_ut_debug_print_raw);
 EXPORT_SYMBOL(acpi_ut_debug_print);
 EXPORT_SYMBOL(acpi_ut_status_exit);
+EXPORT_SYMBOL(acpi_ut_value_exit);
 EXPORT_SYMBOL(acpi_ut_exit);
 EXPORT_SYMBOL(acpi_ut_trace);
-#endif
-
-EXPORT_SYMBOL(acpi_gbl_FADT);
-
-EXPORT_SYMBOL(acpi_os_free);
-EXPORT_SYMBOL(acpi_os_printf);
-EXPORT_SYMBOL(acpi_os_callocate);
-EXPORT_SYMBOL(acpi_os_sleep);
-EXPORT_SYMBOL(acpi_os_stall);
-EXPORT_SYMBOL(acpi_os_queue_for_execution);
-
-EXPORT_SYMBOL(acpi_dbg_layer);
-EXPORT_SYMBOL(acpi_dbg_level);
-
-EXPORT_SYMBOL(acpi_format_exception);
+#endif /*ACPI_DEBUG_OUTPUT*/
 
 EXPORT_SYMBOL(acpi_get_handle);
 EXPORT_SYMBOL(acpi_get_parent);
@@ -69,7 +61,6 @@ EXPORT_SYMBOL(acpi_get_next_object);
 EXPORT_SYMBOL(acpi_evaluate_object);
 EXPORT_SYMBOL(acpi_get_table);
 EXPORT_SYMBOL(acpi_get_firmware_table);
-
 EXPORT_SYMBOL(acpi_install_notify_handler);
 EXPORT_SYMBOL(acpi_remove_notify_handler);
 EXPORT_SYMBOL(acpi_install_gpe_handler);
@@ -78,40 +69,89 @@ EXPORT_SYMBOL(acpi_install_address_space
 EXPORT_SYMBOL(acpi_remove_address_space_handler);
 EXPORT_SYMBOL(acpi_install_fixed_event_handler);
 EXPORT_SYMBOL(acpi_remove_fixed_event_handler);
-
 EXPORT_SYMBOL(acpi_acquire_global_lock);
 EXPORT_SYMBOL(acpi_release_global_lock);
-
+EXPORT_SYMBOL(acpi_install_gpe_block);
+EXPORT_SYMBOL(acpi_remove_gpe_block);
 EXPORT_SYMBOL(acpi_get_current_resources);
 EXPORT_SYMBOL(acpi_get_possible_resources);
+EXPORT_SYMBOL(acpi_walk_resources);
 EXPORT_SYMBOL(acpi_set_current_resources);
-
 EXPORT_SYMBOL(acpi_enable_event);
 EXPORT_SYMBOL(acpi_disable_event);
 EXPORT_SYMBOL(acpi_clear_event);
-
 EXPORT_SYMBOL(acpi_get_timer_duration);
 EXPORT_SYMBOL(acpi_get_timer);
+EXPORT_SYMBOL(acpi_get_sleep_type_data);
+EXPORT_SYMBOL(acpi_get_register);
+EXPORT_SYMBOL(acpi_set_register);
+EXPORT_SYMBOL(acpi_enter_sleep_state);
+EXPORT_SYMBOL(acpi_enter_sleep_state_s4bios);
+EXPORT_SYMBOL(acpi_get_system_info);
+EXPORT_SYMBOL(acpi_get_devices);
+
+/* ACPI OS Services Layer (acpi_osl.c) */
 
+EXPORT_SYMBOL(acpi_os_free);
+EXPORT_SYMBOL(acpi_os_printf);
+EXPORT_SYMBOL(acpi_os_sleep);
+EXPORT_SYMBOL(acpi_os_stall);
+EXPORT_SYMBOL(acpi_os_signal);
+EXPORT_SYMBOL(acpi_os_queue_for_execution);
 EXPORT_SYMBOL(acpi_os_signal_semaphore);
 EXPORT_SYMBOL(acpi_os_create_semaphore);
 EXPORT_SYMBOL(acpi_os_delete_semaphore);
 EXPORT_SYMBOL(acpi_os_wait_semaphore);
 
-EXPORT_SYMBOL(acpi_os_read_port);
-EXPORT_SYMBOL(acpi_os_write_port);
+EXPORT_SYMBOL(acpi_os_read_pci_configuration);
+
+/* ACPI Utilities (acpi_utils.c) */
+
+EXPORT_SYMBOL(acpi_extract_package);
+EXPORT_SYMBOL(acpi_evaluate_integer);
+EXPORT_SYMBOL(acpi_evaluate_reference);
+
+#endif /*CONFIG_ACPI_INTERPRETER*/
+
+
+/* ACPI Bus Driver (acpi_bus.c) */
+
+#ifdef CONFIG_ACPI_BUS
 
 EXPORT_SYMBOL(acpi_fadt);
-EXPORT_SYMBOL(acpi_hw_register_bit_access);
-EXPORT_SYMBOL(acpi_hw_obtain_sleep_type_register_data);
-EXPORT_SYMBOL(acpi_enter_sleep_state);
-EXPORT_SYMBOL(acpi_get_system_info);
-EXPORT_SYMBOL(acpi_leave_sleep_state);
 EXPORT_SYMBOL(acpi_walk_namespace);
-/*EXPORT_SYMBOL(acpi_save_state_mem);*/
-/*EXPORT_SYMBOL(acpi_save_state_disk);*/
-EXPORT_SYMBOL(acpi_hw_register_read);
-EXPORT_SYMBOL(acpi_set_firmware_waking_vector);
-EXPORT_SYMBOL(acpi_subsystem_status);
+EXPORT_SYMBOL(acpi_root_dir);
+EXPORT_SYMBOL(acpi_bus_get_device);
+EXPORT_SYMBOL(acpi_bus_get_status);
+EXPORT_SYMBOL(acpi_bus_get_power);
+EXPORT_SYMBOL(acpi_bus_set_power);
+EXPORT_SYMBOL(acpi_bus_generate_event);
+EXPORT_SYMBOL(acpi_bus_receive_event);
+EXPORT_SYMBOL(acpi_bus_register_driver);
+EXPORT_SYMBOL(acpi_bus_unregister_driver);
+EXPORT_SYMBOL(acpi_bus_scan);
+EXPORT_SYMBOL(acpi_init);
+
+#endif /*CONFIG_ACPI_BUS*/
+
+
+/* ACPI PCI Driver (pci_irq.c) */
+
+#ifdef CONFIG_ACPI_PCI
+
+#include <linux/pci.h>
+extern int acpi_pci_irq_enable(struct pci_dev *dev);
+EXPORT_SYMBOL(acpi_pci_irq_enable);
+extern int acpi_pci_irq_lookup (int segment, int bus, int device, int pin);
+EXPORT_SYMBOL(acpi_pci_irq_lookup);
+EXPORT_SYMBOL(acpi_pci_register_driver);
+EXPORT_SYMBOL(acpi_pci_unregister_driver);
+#endif /*CONFIG_ACPI_PCI */
+
+#ifdef CONFIG_ACPI_EC
+/* ACPI EC driver (ec.c) */
+
+EXPORT_SYMBOL(ec_read);
+EXPORT_SYMBOL(ec_write);
+#endif
 
-EXPORT_SYMBOL(acpi_os_signal);
diff -urNp linux-5400/drivers/acpi/asus_acpi.c linux-5410/drivers/acpi/asus_acpi.c
--- linux-5400/drivers/acpi/asus_acpi.c
+++ linux-5410/drivers/acpi/asus_acpi.c
@@ -0,0 +1,969 @@
+/*
+ *  asus_acpi.c - Asus Laptop ACPI Extras
+ *
+ *
+ *  Copyright (C) 2002, 2003 Julien Lerouge, Karol Kozimor
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ *  The development page for this driver is located at
+ *  http://sourceforge.net/projects/acpi4asus/
+ *
+ *  Credits:
+ *  Johann Wiesner - Small compile fixes
+ *  John Belmonte  - ACPI code for Toshiba laptop was a good starting point.
+ *
+ *  TODO
+ *  add Fn key status
+ *  Add mode selection on module loading (parameter) -> still necessary ?
+ *  Complete display switching -- may require dirty hacks?
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <acpi/acpi_drivers.h>
+#include <acpi/acpi_bus.h>
+#include <asm/uaccess.h>
+
+#define ASUS_ACPI_VERSION "0.24a"
+
+#define PROC_ASUS       "asus"	//the directory
+#define PROC_MLED       "mled"
+#define PROC_WLED       "wled"
+#define PROC_INFOS      "info"
+#define PROC_LCD        "lcd"
+#define PROC_BRN        "brn"
+#define PROC_DISP       "disp"
+
+#define ACPI_HOTK_NAME          "Asus Laptop ACPI Extras Driver"
+#define ACPI_HOTK_CLASS         "hotkey"
+#define ACPI_HOTK_DEVICE_NAME   "Hotkey"
+#define ACPI_HOTK_HID           "ATK0100"
+
+/*
+ * Some events we use, same for all Asus
+ */
+#define BR_UP       0x10      		
+#define BR_DOWN     0x20
+
+/*
+ * Flags for hotk status
+ */
+#define MLED_ON     0x01	//is MLED ON ?
+#define WLED_ON     0x02
+
+MODULE_AUTHOR("Julien Lerouge, Karol Kozimor");
+MODULE_DESCRIPTION(ACPI_HOTK_NAME);
+MODULE_LICENSE("GPL");
+EXPORT_NO_SYMBOLS;
+
+
+static uid_t asus_uid = 0;
+static gid_t asus_gid = 0;
+MODULE_PARM(asus_uid, "i");
+MODULE_PARM_DESC(uid, "UID for entries in /proc/acpi/asus.\n");
+MODULE_PARM(asus_gid, "i");
+MODULE_PARM_DESC(gid, "GID for entries in /proc/acpi/asus.\n");
+
+
+/* For each model, all features implemented */
+struct model_data {
+	char *name;		//name of the laptop
+	char *mt_mled;		//method to handle mled
+	char *mled_status;	//node to handle mled reading
+	char *mt_wled;		//method to handle wled
+	char *wled_status;	//node to handle wled reading
+	char *mt_lcd_switch;	//method to turn LCD ON/OFF
+	char *lcd_status;	//node to read LCD panel state
+	char *brightness_up;	//method to set brightness up
+	char *brightness_down;	//guess what ?
+	char *brightness_set;	//method to set absolute brightness
+	char *brightness_get;	//method to get absolute brightness
+	char *brightness_status;//node to get brightness
+	char *display_set;	//method to set video output
+	char *display_get;	//method to get video output
+};
+
+/*
+ * This is the main structure, we can use it to store anything interesting
+ * about the hotk device
+ */
+struct asus_hotk {
+	struct acpi_device *device;	//the device we are in
+	acpi_handle handle;		//the handle of the hotk device
+	char status;			//status of the hotk, for LEDs, ...
+	struct model_data *methods;	//methods available on the laptop
+	u8 brightness;			//brighness level
+	enum {
+		L2X = 0,	//L200D -> TODO check Q11 (Fn+F8)
+				//	   Calling this method simply hang the
+				//	   computer, ISMI method hangs the laptop.
+		L3X,		//L3C
+		L3D,		//L3400D
+		M2X,		//M2400E
+		S1X,		//S1300A -> TODO special keys do not work ?
+		D1X,		//D1
+		L1X,		//L1400B
+		A1X, 		//A1340D, A1300F
+		J1X,		//S200 (J1)
+				//TODO  A1370D does not seems to have a ATK device 
+				//	L8400 model doesn't have ATK
+		END_MODEL,
+	} model;		//Models currently supported
+	u16 event_count[128];	//count for each event TODO make this better
+};
+
+/* Here we go */
+#define L3X_PREFIX "\\_SB.PCI0.PX40.ECD0."
+#define S1X_PREFIX "\\_SB.PCI0.PX40."
+#define L1X_PREFIX S1X_PREFIX
+#define A1X_PREFIX "\\_SB.PCI0.ISA.EC0."
+#define J1X_PREFIX A1X_PREFIX
+
+static struct model_data model_conf[END_MODEL] = {
+        /*
+	 * name|  mled |mled read|  wled |wled read| lcd sw |lcd read | 
+	 * br up|br down | br set | br read | br status|set disp | get disp
+	 *
+	 * br set and read shall be in hotk device !
+	 * same for set disp
+	 *
+	 * TODO I have seen a SWBX and AIBX method on some models, like L1400B,
+	 * it seems to be a kind of switch, but what for ?
+	 *
+	 */
+	{"L2X", "MLED", "\\SGP6", "WLED", "\\RCP3", "\\Q10", "\\SGP0", 
+	 "\\Q0E", "\\Q0F", NULL, NULL, NULL, "SDSP", "\\INFB"},
+
+	{"L3X", "MLED", NULL, "WLED", NULL, L3X_PREFIX "_Q10", "\\GL32", 
+	 L3X_PREFIX "_Q0F", L3X_PREFIX "_Q0E", "SPLV", "GPLV", "\\BLVL", "SDSP", 
+	 "\\_SB.PCI0.PCI1.VGAC.NMAP"},
+
+	{"L3D", "MLED", "\\MALD", "WLED", NULL, "\\Q10", "\\BKLG",
+	 "\\Q0E", "\\Q0F", "SPLV", "GPLV", "\\BLVL", "SDSP", "\\INFB"},
+
+	{"M2X", "MLED", NULL, "WLED", NULL, "\\Q10", "\\GP06", 
+	 "\\Q0E","\\Q0F", "SPLV", "GPLV", NULL, "SDSP", "\\INFB"},
+	
+	{"S1X", "MLED", "\\EMLE", "WLED", NULL, S1X_PREFIX "Q10", "\\PNOF", 
+	 S1X_PREFIX "Q0F", S1X_PREFIX "Q0E", "SPLV", "GPLV", "\\BRIT", NULL, NULL},
+	
+	{"D1X", "MLED", NULL, NULL, NULL, "\\Q0D", "\\GP11", 
+	 "\\Q0C", "\\Q0B", NULL, NULL, "\\BLVL", "SDSP","\\INFB"},
+
+	{"L1X", "MLED", NULL, "WLED", NULL, L1X_PREFIX "Q10", "\\PNOF", 
+	 L1X_PREFIX "Q0F", L1X_PREFIX "Q0E", "SPLV", "GPLV", "\\BRIT", NULL, NULL},
+
+	{"A1X", "MLED", "\\MAIL", NULL, NULL, A1X_PREFIX "_Q10", "\\BKLI",
+	 A1X_PREFIX "_Q0E", A1X_PREFIX "_Q0F", NULL, NULL, NULL, NULL, NULL},
+
+	{"J1X", "MLED", "\\MAIL", NULL, NULL, J1X_PREFIX "_Q10", "\\BKLI",
+	 J1X_PREFIX "_Q0B", J1X_PREFIX "_Q0A", NULL, NULL, NULL, NULL, NULL}
+};
+
+/* procdir we use */
+static struct proc_dir_entry *asus_proc_dir = NULL;
+
+/*
+ * This header is made available to allow proper configuration given model,
+ * revision number , ... this info cannot go in struct asus_hotk because it is
+ * available before the hotk
+ */
+static struct acpi_table_header *asus_info = NULL;
+
+/*
+ * The hotkey driver declaration
+ */
+static int asus_hotk_add(struct acpi_device *device);
+static int asus_hotk_remove(struct acpi_device *device, int type);
+static struct acpi_driver asus_hotk_driver = {
+	.name = 	ACPI_HOTK_NAME,
+	.class = 	ACPI_HOTK_CLASS,
+	.ids = 		ACPI_HOTK_HID,
+	.ops = 		{
+				.add = 		asus_hotk_add,
+				.remove = 	asus_hotk_remove,
+			},
+};
+
+/* 
+ * This function evaluates an ACPI method, given an int as parameter, the
+ * method is searched within the scope of the handle, can be NULL. The output
+ * of the method is written is output, which can also be NULL
+ *
+ * returns 1 if write is successful, 0 else. 
+ */
+static int write_acpi_int(acpi_handle handle, const char *method, int val,
+			  struct acpi_buffer *output)
+{
+	struct acpi_object_list params;	//list of input parameters (an int here)
+	union acpi_object in_obj;	//the only param we use
+	acpi_status status;
+
+	params.count = 1;
+	params.pointer = &in_obj;
+	in_obj.type = ACPI_TYPE_INTEGER;
+	in_obj.integer.value = val;
+
+	status = acpi_evaluate_object(handle, (char *) method, &params, output);
+	return (status == AE_OK);
+}
+
+
+static int read_acpi_int(acpi_handle handle, const char *method, int *val)
+{
+	struct acpi_buffer output;
+	union acpi_object out_obj;
+	acpi_status status;
+
+	output.length = sizeof(out_obj);
+	output.pointer = &out_obj;
+
+	status = acpi_evaluate_object(handle, (char*) method, NULL, &output);
+	*val = out_obj.integer.value;
+	return (status == AE_OK) && (out_obj.type == ACPI_TYPE_INTEGER);
+}
+
+/*
+ * We write our info in page, we begin at offset off and cannot write more
+ * than count bytes. We set eof to 1 if we handle those 2 values. We return the
+ * number of bytes written in page
+ */
+static int
+proc_read_info(char *page, char **start, off_t off, int count, int *eof,
+		void *data)
+{
+	int len = 0;
+	struct asus_hotk *hotk = (struct asus_hotk *) data;
+	char buf[16];		//enough for all info
+	/*
+	 * We use the easy way, we don't care of off and count, so we don't set eof
+	 * to 1
+	 */
+
+	len += sprintf(page, ACPI_HOTK_NAME " " ASUS_ACPI_VERSION "\n");
+	len +=
+	    sprintf(page + len, "Model reference    : %s\n",
+		    hotk->methods->name);
+	if (asus_info) {
+		snprintf(buf, 5, "%s", asus_info->signature);
+		len += sprintf(page + len, "ACPI signature     : %s\n", buf);
+		snprintf(buf, 16, "%d", asus_info->length);
+		len += sprintf(page + len, "Table length       : %s\n", buf);
+		snprintf(buf, 16, "%d", asus_info->revision);
+		len += sprintf(page + len, "ACPI minor version : %s\n", buf);
+		snprintf(buf, 16, "%d", asus_info->checksum);
+		len += sprintf(page + len, "Checksum           : %s\n", buf);
+		snprintf(buf, 7, "%s", asus_info->oem_id);
+		len += sprintf(page + len, "OEM identification : %s\n", buf);
+		snprintf(buf, 9, "%s", asus_info->oem_table_id);
+		len += sprintf(page + len, "OEM table id       : %s\n", buf);
+		snprintf(buf, 16, "%x", asus_info->oem_revision);
+		len += sprintf(page + len, "OEM rev number     : 0x%s\n", buf);
+		snprintf(buf, 5, "%s", asus_info->asl_compiler_id);
+		len += sprintf(page + len, "ASL comp vendor ID : %s\n", buf);
+		snprintf(buf, 16, "%x", asus_info->asl_compiler_revision);
+		len += sprintf(page + len, "ASL comp rev number: 0x%s\n", buf);
+	}
+
+	return len;
+}
+
+
+/* 
+ * proc file handlers
+ */
+static int
+proc_read_mled(char *page, char **start, off_t off, int count, int *eof,
+	       void *data)
+{
+	int len = 0;
+	struct asus_hotk *hotk = (struct asus_hotk *) data;
+	int led_status = 0;
+	/*
+	 * We use the easy way, we don't care of off and count, so we don't set eof
+	 * to 1
+	 */
+	if (hotk->methods->mled_status) {
+		if (read_acpi_int(NULL, hotk->methods->mled_status, 
+				  &led_status))
+			len =  sprintf(page, "%d\n", led_status);
+		else
+			printk(KERN_NOTICE "Asus ACPI: Error reading MLED "
+			       "status\n");
+	} else {
+		len = sprintf(page, "%d\n", (hotk->status & MLED_ON) ? 1 : 0);
+	}
+
+	return len;
+}
+ 
+static int parse_arg(const char *buf, unsigned long count, int *val)
+{
+	char s[32];
+	if (!count)
+		return 0;
+	if (count > 31)
+		return -EINVAL;
+	if (copy_from_user(s, buf, count))
+		return -EFAULT;
+	s[count] = 0;
+	if (sscanf(s, "%i", val) != 1)
+		return -EINVAL;
+	return count;
+}
+
+static int
+proc_write_mled(struct file *file, const char *buffer,
+		unsigned long count, void *data)
+{
+	int value;
+	int led_out = 0;
+	struct asus_hotk *hotk = (struct asus_hotk *) data;
+
+	count = parse_arg(buffer, count, &value);
+	if (count > 0)
+		led_out = ~value & 1;
+
+	hotk->status =
+	    (value) ? (hotk->status | MLED_ON) : (hotk->status & ~MLED_ON);
+
+	/* We don't have to check mt_mled exists if we are here :) */
+	if (!write_acpi_int(hotk->handle, hotk->methods->mt_mled, led_out,
+			    NULL))
+		printk(KERN_NOTICE "Asus ACPI: MLED write failed\n");
+
+
+
+	return count;
+}
+
+/*
+ * We write our info in page, we begin at offset off and cannot write more
+ * than count bytes. We set eof to 1 if we handle those 2 values. We return the
+ * number of bytes written in page
+ */
+static int
+proc_read_wled(char *page, char **start, off_t off, int count, int *eof,
+	       void *data)
+{
+	int len = 0;
+	struct asus_hotk *hotk = (struct asus_hotk *) data;
+	int led_status;
+
+	if (hotk->methods->wled_status) {
+		if (read_acpi_int(NULL, hotk->methods->mled_status, 
+				  &led_status))
+			len = sprintf(page, "%d\n", led_status);
+		else
+			printk(KERN_NOTICE "Asus ACPI: Error reading WLED "
+			       "status\n");
+	} else {
+		len = sprintf(page, "%d\n", (hotk->status & WLED_ON) ? 1 : 0);
+	}
+
+	return len;
+}
+
+static int
+proc_write_wled(struct file *file, const char *buffer,
+		unsigned long count, void *data)
+{
+	int value;
+	int led_out = 0;
+	struct asus_hotk *hotk = (struct asus_hotk *) data;
+
+	/* scan expression.  Multiple expressions may be delimited with ; */
+	count = parse_arg(buffer, count, &value);
+	if (count > 0)
+		led_out = value & 1;
+
+	hotk->status =
+	    (value) ? (hotk->status | WLED_ON) : (hotk->status & ~WLED_ON);
+
+	/* We don't have to check if mt_wled exists if we are here :) */
+	if (!write_acpi_int(hotk->handle, hotk->methods->mt_wled, led_out,
+			    NULL))
+		printk(KERN_NOTICE "Asus ACPI: WLED write failed\n");
+
+
+	return count;
+}
+
+
+static int get_lcd_state(struct asus_hotk *hotk)
+{
+	int lcd = 0;
+
+	/* We don't have to check anything, if we are here */
+	if (!read_acpi_int(NULL, hotk->methods->lcd_status, &lcd))
+		printk(KERN_NOTICE "Asus ACPI: Error reading LCD status\n");
+	
+	if (hotk->model == L2X)
+		lcd = ~lcd;
+	
+	return (lcd & 1);
+}
+
+
+static int
+proc_read_lcd(char *page, char **start, off_t off, int count, int *eof,
+	      void *data)
+{
+	return sprintf(page, "%d\n", get_lcd_state((struct asus_hotk *) data));
+}
+
+
+static int
+proc_write_lcd(struct file *file, const char *buffer,
+	       unsigned long count, void *data)
+{
+	int value;
+	int lcd = 0;
+	acpi_status status = 0;
+	int lcd_status = 0;
+	struct asus_hotk *hotk = (struct asus_hotk *) data;
+
+	/* scan expression.  Multiple expressions may be delimited with ; */
+	count = parse_arg(buffer, count, &value);
+	if (count > 0)
+		lcd = value & 1;
+
+	lcd_status = get_lcd_state(hotk);
+
+	if (lcd_status != lcd) {
+		/* switch */
+		status =
+		    acpi_evaluate_object(NULL, hotk->methods->mt_lcd_switch,
+					 NULL, NULL);
+		if (ACPI_FAILURE(status))
+			printk(KERN_NOTICE "Asus ACPI: Error switching LCD\n");
+	}
+
+	return count;
+}
+
+
+/*
+ * Change the brightness level
+ */
+static void set_brightness(int value, struct asus_hotk *hotk)
+{
+	acpi_status status = 0;
+
+	/* ATKD laptop */
+	if(hotk->methods->brightness_set) {
+		if (!write_acpi_int(hotk->handle, hotk->methods->brightness_set, 
+				    value, NULL))
+			printk(KERN_NOTICE "Asus ACPI: Error changing brightness\n");
+		return;
+	}
+
+	/* HOTK laptop if we are here, act as appropriate */
+	value -= hotk->brightness;
+	while (value != 0) {
+		status = acpi_evaluate_object(NULL, (value > 0) ? 
+					      hotk->methods->brightness_up : 
+					      hotk->methods->brightness_down,
+					      NULL, NULL);
+		(value > 0) ? value-- : value++;
+		if (ACPI_FAILURE(status))
+			printk(KERN_NOTICE "Asus ACPI: Error changing brightness\n");
+	}
+	return;
+}
+
+static int read_brightness(struct asus_hotk *hotk)
+{
+	int value;
+	
+	if(hotk->methods->brightness_get) { /* ATKD laptop */
+		if (!read_acpi_int(hotk->handle, hotk->methods->brightness_get, 
+				   &value))
+			printk(KERN_NOTICE "Asus ACPI: Error reading brightness\n");
+	} else if (hotk->methods->brightness_status) { /* For D1 for example */
+		if (!read_acpi_int(NULL, hotk->methods->brightness_status, 
+				   &value))
+			printk(KERN_NOTICE "Asus ACPI: Error reading brightness\n");
+	} else /* HOTK laptop */
+		value = hotk->brightness;
+	return value;
+}
+
+static int
+proc_read_brn(char *page, char **start, off_t off, int count, int *eof,
+	      void *data)
+{
+	struct asus_hotk *hotk = (struct asus_hotk *) data;
+	return sprintf(page, "%d\n", read_brightness(hotk));
+}
+
+static int
+proc_write_brn(struct file *file, const char *buffer,
+	       unsigned long count, void *data)
+{
+	int value;
+	struct asus_hotk *hotk = (struct asus_hotk *) data;
+
+	/* scan expression.  Multiple expressions may be delimited with ; */
+	count = parse_arg(buffer, count, &value);
+	if (count > 0) {
+		value = (0 < value) ? ((15 < value) ? 15 : value) : 0;
+			/* 0 <= value <= 15 */
+		set_brightness(value, hotk);
+	} else {
+		printk(KERN_NOTICE "Asus ACPI: Error reading user input\n");
+	}
+
+	return count;
+}
+
+static void set_display(int value, struct asus_hotk *hotk)
+{
+	/* no sanity check needed for now */
+	if (!write_acpi_int(hotk->handle, hotk->methods->display_set, 
+			    value, NULL))
+		printk(KERN_NOTICE "Asus ACPI: Error setting display\n");
+	return;
+}
+
+/*
+ * Now, *this* one could be more user-friendly, but so far, no-one has 
+ * complained. The significance of bits is the same as in proc_write_disp()
+ */
+
+static int
+proc_read_disp(char *page, char **start, off_t off, int count, int *eof,
+	      void *data)
+{
+	int value = 0;
+	struct asus_hotk *hotk = (struct asus_hotk *) data;
+	
+	if (!read_acpi_int(hotk->handle, hotk->methods->display_get, &value))
+		printk(KERN_NOTICE "Asus ACPI: Error reading display status\n");
+	return sprintf(page, "%d\n", value);
+}
+
+/*
+ * Preliminary support for display switching. As of now: 0x01 should activate 
+ * the LCD output, 0x02 should do for CRT, and 0x04 for TV-Out. Any combination 
+ * (bitwise) of these will suffice. I never actually tested 3 displays hooked up 
+ * simultaneously, so be warned.
+ */
+
+static int
+proc_write_disp(struct file *file, const char *buffer,
+	       unsigned long count, void *data)
+{
+	int value;
+	struct asus_hotk *hotk = (struct asus_hotk *) data;
+
+	/* scan expression.  Multiple expressions may be delimited with ; */
+	count = parse_arg(buffer, count, &value);
+	if (count > 0)
+		set_display(value, hotk);
+	else {
+		printk(KERN_NOTICE "Asus ACPI: Error reading user input\n");
+	}
+
+	return count;
+}
+
+static int asus_hotk_add_fs(struct acpi_device *device)
+{
+	struct proc_dir_entry *proc;
+	struct asus_hotk *hotk = acpi_driver_data(device);
+	mode_t mode;
+	
+	/*
+	 * If parameter uid or gid is not changed, keep the default setting for
+	 * our proc entries (-rw-rw-rw-) else, it means we care about security,
+	 * and then set to -rw-rw----
+	 */
+
+	if ((asus_uid == 0) && (asus_gid == 0)){
+		mode = S_IFREG | S_IRUGO | S_IWUGO;
+	}else{
+		mode = S_IFREG | S_IRUSR | S_IRGRP | S_IWUSR | S_IWGRP;
+	}
+
+	acpi_device_dir(device) = asus_proc_dir;
+	if (!acpi_device_dir(device))
+		return(-ENODEV);
+
+	proc = create_proc_entry(PROC_INFOS, mode, acpi_device_dir(device));
+	if (proc) {
+		proc->read_proc = proc_read_info;
+		proc->data = acpi_driver_data(device);
+		proc->owner = THIS_MODULE;
+		proc->uid = asus_uid;
+		proc->gid = asus_gid;;
+	} else {
+		printk(KERN_NOTICE "  Unable to create " PROC_INFOS
+		       " fs entry\n");
+	}
+
+	if (hotk->methods->mt_wled) {
+		proc = create_proc_entry(PROC_WLED, mode, acpi_device_dir(device));
+		if (proc) {
+			proc->write_proc = proc_write_wled;
+			proc->read_proc = proc_read_wled;
+			proc->data = acpi_driver_data(device);
+			proc->owner = THIS_MODULE;
+			proc->uid = asus_uid;
+			proc->gid = asus_gid;;
+		} else {
+			printk(KERN_NOTICE "  Unable to create " PROC_WLED
+			       " fs entry\n");
+		}
+	}
+
+	if (hotk->methods->mt_mled) {
+		proc = create_proc_entry(PROC_MLED, mode, acpi_device_dir(device));
+		if (proc) {
+			proc->write_proc = proc_write_mled;
+			proc->read_proc = proc_read_mled;
+			proc->data = acpi_driver_data(device);
+			proc->owner = THIS_MODULE;
+			proc->uid = asus_uid;
+			proc->gid = asus_gid;;
+		} else {
+			printk(KERN_NOTICE "  Unable to create " PROC_MLED
+			       " fs entry\n");
+		}
+	}
+
+	/* 
+	 * We need both read node and write method as LCD switch is also accessible
+	 * from keyboard 
+	 */
+	if (hotk->methods->mt_lcd_switch && hotk->methods->lcd_status) {
+		proc = create_proc_entry(PROC_LCD, mode, acpi_device_dir(device));
+		if (proc) {
+			proc->write_proc = proc_write_lcd;
+			proc->read_proc = proc_read_lcd;
+			proc->data = acpi_driver_data(device);
+			proc->owner = THIS_MODULE;
+			proc->uid = asus_uid;
+			proc->gid = asus_gid;;
+		} else {
+			printk(KERN_NOTICE "  Unable to create " PROC_LCD
+			       " fs entry\n");
+		}
+	}
+	
+	if ((hotk->methods->brightness_up && hotk->methods->brightness_down) ||
+	    (hotk->methods->brightness_get && hotk->methods->brightness_get)) {
+		proc = create_proc_entry(PROC_BRN, mode, acpi_device_dir(device));
+		if (proc) {
+			proc->write_proc = proc_write_brn;
+			proc->read_proc = proc_read_brn;
+			proc->data = acpi_driver_data(device);
+			proc->owner = THIS_MODULE;
+			proc->uid = asus_uid;
+			proc->gid = asus_gid;;
+		} else {
+			printk(KERN_NOTICE "  Unable to create " PROC_BRN
+			       " fs entry\n");
+		}
+	}
+
+	if (hotk->methods->display_set) {
+		proc = create_proc_entry(PROC_DISP, mode, acpi_device_dir(device));
+		if (proc) {
+			proc->write_proc = proc_write_disp;
+			proc->read_proc = proc_read_disp;
+			proc->data = acpi_driver_data(device);
+			proc->owner = THIS_MODULE;
+			proc->uid = asus_uid;
+			proc->gid = asus_gid;;
+		} else {
+			printk(KERN_NOTICE "  Unable to create " PROC_DISP
+			       " fs entry\n");
+		}
+	}
+
+	return (AE_OK);
+}
+
+
+static void asus_hotk_notify(acpi_handle handle, u32 event, void *data)
+{
+	/* TODO Find a better way to handle events count. Here, in data, we receive
+	 * the hotk, so we can make anything !!
+	 */
+	struct asus_hotk *hotk = (struct asus_hotk *) data;
+
+	if (!hotk)
+		return;
+
+	if ((event & ~((u32) BR_UP)) < 16) {
+		hotk->brightness = (event & ~((u32) BR_UP));
+	} else if ((event & ~((u32) BR_DOWN)) < 16 ) {
+		hotk->brightness = (event & ~((u32) BR_DOWN));
+	}
+
+	acpi_bus_generate_event(hotk->device, event,
+				hotk->event_count[event % 128]++);
+
+	return;
+}
+
+/*
+ * This function is used to initialize the hotk with right values. In this
+ * method, we can make all the detection we want, and modify the hotk struct
+ */
+static int asus_hotk_get_info(struct asus_hotk *hotk)
+{
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *model = NULL;
+
+	/* 
+	 * We have to write 0 on init this far for all ASUS models
+	 */
+	if (!write_acpi_int(hotk->handle, "INIT", 0, &buffer)) {
+		printk(KERN_NOTICE "  Hotkey initialization failed\n");
+		return -ENODEV;
+	}
+
+	/*
+	 * Here, we also use asus_info to make decision. For example, on INIT
+	 * method, S1X and L1X models both reports to be L84F, but they don't
+	 * have the same methods (L1X has WLED, S1X don't)
+	 */
+	model = (union acpi_object *) buffer.pointer;
+	if (model->type == ACPI_TYPE_STRING) {
+		printk(KERN_NOTICE "  %s model detected, ", model->string.pointer);
+	}
+
+	hotk->model = END_MODEL;
+	if (strncmp(model->string.pointer, "L3D", 3) == 0)
+		hotk->model = L3D;
+		/*
+		 * L2B has same settings that L3X, except for GL32, but as
+		 * there is no node to get the LCD status, and as GL32 is never
+		 * used anywhere else, I assume it's safe, even if lcd get is
+		 * broken for this model (TODO fix it ?)
+		 */
+	else if (strncmp(model->string.pointer, "L3", 2) == 0 ||
+		 strncmp(model->string.pointer, "L2B", 3) == 0)
+		hotk->model = L3X;
+	else if (strncmp(model->string.pointer, "M2", 2) == 0)
+		hotk->model = M2X;
+	else if (strncmp(model->string.pointer, "L2", 2) == 0)
+		hotk->model = L2X;
+	else if (strncmp(model->string.pointer, "L8", 2) == 0)
+		/* S1300A reports L84F, but L1400B too */
+		if (strncmp(asus_info->oem_table_id, "L1", 2) == 0)
+			hotk->model = L1X;
+		else
+			hotk->model = S1X;
+	else if (strncmp(model->string.pointer, "D1", 2) == 0)
+		hotk->model = D1X;
+	else if (strncmp(model->string.pointer, "A1", 2) == 0)
+		hotk->model = A1X;
+	else if (strncmp(model->string.pointer, "J1", 2) == 0)
+		hotk->model = J1X;
+
+
+	if (hotk->model == END_MODEL) {
+		/* By default use the same values, as I don't know others */
+		printk("unsupported, trying default values, contact the "
+		       "developers\n");
+		hotk->model = L2X;
+	} else {
+		printk("supported\n");
+	}
+
+	hotk->methods = &model_conf[hotk->model];
+
+	acpi_os_free(model);
+
+	return AE_OK;
+}
+
+
+
+static int asus_hotk_check(struct asus_hotk *hotk)
+{
+	int result = 0;
+
+	if (!hotk)
+		return(-EINVAL);
+
+	result = acpi_bus_get_status(hotk->device);
+	if (result)
+		return(result);
+
+	if (hotk->device->status.present) {
+		result = asus_hotk_get_info(hotk);
+	} else {
+		printk(KERN_NOTICE "  Hotkey device not present, aborting\n");
+		return(-EINVAL);
+	}
+
+	return(result);
+}
+
+
+
+static int asus_hotk_add(struct acpi_device *device)
+{
+	struct asus_hotk *hotk = NULL;
+	acpi_status status = AE_OK;
+	int result;
+
+	if (!device)
+		return(-EINVAL);
+
+	hotk =
+	    (struct asus_hotk *) kmalloc(sizeof(struct asus_hotk), GFP_KERNEL);
+	if (!hotk)
+		return(-ENOMEM);
+	memset(hotk, 0, sizeof(struct asus_hotk));
+
+	hotk->handle = device->handle;
+	sprintf(acpi_device_name(device), "%s", ACPI_HOTK_DEVICE_NAME);
+	sprintf(acpi_device_class(device), "%s", ACPI_HOTK_CLASS);
+	acpi_driver_data(device) = hotk;
+	hotk->device = device;
+
+
+	result = asus_hotk_check(hotk);
+	if (result)
+		goto end;
+
+	result = asus_hotk_add_fs(device);
+	if (result)
+		goto end;
+
+	/*
+	 * We install the handler, it will receive the hotk in parameter, so, we
+	 * could add other data to the hotk struct
+	 */
+	status = acpi_install_notify_handler(hotk->handle, ACPI_SYSTEM_NOTIFY,
+					     asus_hotk_notify, hotk);
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_NOTICE
+		       "  Error installing notify handler\n");
+	} else {
+		printk(KERN_DEBUG
+		       "  Notify Handler installed successfully\n");
+	}
+
+	/* For HOTK laptops: init the hotk->brightness value */
+	if ((!hotk->methods->brightness_get) && (!hotk->methods->brightness_status) &&
+	    (hotk->methods->brightness_up && hotk->methods->brightness_down)) {
+		status = acpi_evaluate_object(NULL, hotk->methods->brightness_down,
+					      NULL, NULL);
+		if (ACPI_FAILURE(status))
+			printk(KERN_NOTICE "  Error changing brightness\n");
+		status = acpi_evaluate_object(NULL, hotk->methods->brightness_up,
+					      NULL, NULL);
+		if (ACPI_FAILURE(status))
+			printk(KERN_NOTICE "  Error changing brightness\n");
+	}
+
+      end:
+	if (result) {
+		kfree(hotk);
+	}
+
+	return(result);
+}
+
+
+
+
+static int asus_hotk_remove(struct acpi_device *device, int type)
+{
+	acpi_status status = 0;
+	struct asus_hotk *hotk = NULL;
+
+	if (!device || !acpi_driver_data(device))
+		return(-EINVAL);
+
+	hotk = (struct asus_hotk *) acpi_driver_data(device);
+
+	status = acpi_remove_notify_handler(hotk->handle, ACPI_SYSTEM_NOTIFY,
+					    asus_hotk_notify);
+	if (ACPI_FAILURE(status))
+		printk(KERN_NOTICE "Error removing notify handler\n");
+
+	kfree(hotk);
+
+	return(0);
+}
+
+
+
+
+static int __init asus_acpi_init(void)
+{
+	int result = 0;
+	acpi_status status = 0;
+	struct acpi_buffer dsdt = { ACPI_ALLOCATE_BUFFER, NULL };
+
+	printk(KERN_NOTICE "Asus Laptop ACPI Extras version %s\n",
+	       ASUS_ACPI_VERSION);
+	/*
+	 * Here is the code to know the model we are running on. We need to
+	 * know this before calling the acpi_bus_register_driver function, in
+	 * case the HID for the laptop we are running on is different from
+	 * ACPI_HOTK_HID, which I have never seen yet :)
+	 * 
+	 * This information is then available in the global var asus_info
+	 */
+	status = acpi_get_table(ACPI_TABLE_DSDT, 1, &dsdt);
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_NOTICE "  Couldn't get the DSDT table header\n");
+	} else {
+		asus_info = (struct acpi_table_header *) dsdt.pointer;
+	}
+
+	asus_proc_dir = proc_mkdir(PROC_ASUS, acpi_root_dir);
+	if (!asus_proc_dir)
+		return(-ENODEV);
+	asus_proc_dir->owner = THIS_MODULE;
+
+	result = acpi_bus_register_driver(&asus_hotk_driver);
+	if (result < 0) {
+		printk(KERN_NOTICE "  Error registering " ACPI_HOTK_NAME " \n");
+		remove_proc_entry(PROC_ASUS, acpi_root_dir);
+		return(-ENODEV);
+	}
+
+	return(0);
+}
+
+
+
+static void __exit asus_acpi_exit(void)
+{
+	acpi_bus_unregister_driver(&asus_hotk_driver);
+	remove_proc_entry(PROC_ASUS, acpi_root_dir);
+
+	acpi_os_free(asus_info);
+
+	return;
+}
+
+module_init(asus_acpi_init);
+module_exit(asus_acpi_exit);
diff -urNp linux-5400/drivers/acpi/battery.c linux-5410/drivers/acpi/battery.c
--- linux-5400/drivers/acpi/battery.c
+++ linux-5410/drivers/acpi/battery.c
@@ -0,0 +1,825 @@
+/*
+ *  acpi_battery.c - ACPI Battery Driver ($Revision: 36 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/compatmac.h>
+#include <linux/proc_fs.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+
+#define _COMPONENT		ACPI_BATTERY_COMPONENT
+ACPI_MODULE_NAME		("acpi_battery")
+
+MODULE_AUTHOR("Paul Diefenbaugh");
+MODULE_DESCRIPTION(ACPI_BATTERY_DRIVER_NAME);
+MODULE_LICENSE("GPL");
+
+#define PREFIX			"ACPI: "
+
+
+#define ACPI_BATTERY_VALUE_UNKNOWN 0xFFFFFFFF
+
+#define ACPI_BATTERY_FORMAT_BIF	"NNNNNNNNNSSSS"
+#define ACPI_BATTERY_FORMAT_BST	"NNNN"
+
+static int acpi_battery_add (struct acpi_device *device);
+static int acpi_battery_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_battery_driver = {
+	.name =		ACPI_BATTERY_DRIVER_NAME,
+	.class =	ACPI_BATTERY_CLASS,
+	.ids =		ACPI_BATTERY_HID,
+	.ops =		{
+				.add =		acpi_battery_add,
+				.remove =	acpi_battery_remove,
+			},
+};
+
+struct acpi_battery_status {
+	acpi_integer		state;
+	acpi_integer		present_rate;
+	acpi_integer		remaining_capacity;
+	acpi_integer		present_voltage;
+};
+
+struct acpi_battery_info {
+	acpi_integer		power_unit;
+	acpi_integer		design_capacity;
+	acpi_integer		last_full_capacity;
+	acpi_integer		battery_technology;
+	acpi_integer		design_voltage;
+	acpi_integer		design_capacity_warning;
+	acpi_integer		design_capacity_low;
+	acpi_integer		battery_capacity_granularity_1;
+	acpi_integer		battery_capacity_granularity_2;
+	acpi_string		model_number;
+	acpi_string		serial_number;
+	acpi_string		battery_type;
+	acpi_string		oem_info;
+};
+
+struct acpi_battery_flags {
+	u8			present:1;	/* Bay occupied? */
+	u8			power_unit:1;	/* 0=watts, 1=apms */
+	u8			alarm:1;	/* _BTP present? */
+	u8			reserved:5;
+};
+
+struct acpi_battery_trips {
+	unsigned long		warning;
+	unsigned long		low;
+};
+
+struct acpi_battery {
+	acpi_handle		handle;
+	struct acpi_battery_flags flags;
+	struct acpi_battery_trips trips;
+	unsigned long		alarm;
+	struct acpi_battery_info *info;
+};
+
+
+/* --------------------------------------------------------------------------
+                               Battery Management
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_battery_get_info (
+	struct acpi_battery	*battery,
+	struct acpi_battery_info **bif)
+{
+	int			result = 0;
+	acpi_status 		status = 0;
+	struct acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	struct acpi_buffer	format = {sizeof(ACPI_BATTERY_FORMAT_BIF),
+						ACPI_BATTERY_FORMAT_BIF};
+	struct acpi_buffer	data = {0, NULL};
+	union acpi_object	*package = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_get_info");
+
+	if (!battery || !bif)
+		return_VALUE(-EINVAL);
+
+	/* Evalute _BIF */
+
+	status = acpi_evaluate_object(battery->handle, "_BIF", NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _BIF\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	package = (union acpi_object *) buffer.pointer;
+
+	/* Extract Package Data */
+
+	status = acpi_extract_package(package, &format, &data);
+	if (status != AE_BUFFER_OVERFLOW) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error extracting _BIF\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	data.pointer = kmalloc(data.length, GFP_KERNEL);
+	if (!data.pointer) {
+		result = -ENOMEM;
+		goto end;
+	}
+	memset(data.pointer, 0, data.length);
+
+	status = acpi_extract_package(package, &format, &data);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error extracting _BIF\n"));
+		kfree(data.pointer);
+		result = -ENODEV;
+		goto end;
+	}
+
+end:
+	acpi_os_free(buffer.pointer);
+
+	if (!result)
+		(*bif) = (struct acpi_battery_info *) data.pointer;
+
+	return_VALUE(result);
+}
+
+static int
+acpi_battery_get_status (
+	struct acpi_battery	*battery,
+	struct acpi_battery_status **bst)
+{
+	int			result = 0;
+	acpi_status 		status = 0;
+	struct acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	struct acpi_buffer	format = {sizeof(ACPI_BATTERY_FORMAT_BST),
+						ACPI_BATTERY_FORMAT_BST};
+	struct acpi_buffer	data = {0, NULL};
+	union acpi_object	*package = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_get_status");
+
+	if (!battery || !bst)
+		return_VALUE(-EINVAL);
+
+	/* Evalute _BST */
+
+	status = acpi_evaluate_object(battery->handle, "_BST", NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _BST\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	package = (union acpi_object *) buffer.pointer;
+
+	/* Extract Package Data */
+
+	status = acpi_extract_package(package, &format, &data);
+	if (status != AE_BUFFER_OVERFLOW) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error extracting _BST\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	data.pointer = kmalloc(data.length, GFP_KERNEL);
+	if (!data.pointer) {
+		result = -ENOMEM;
+		goto end;
+	}
+	memset(data.pointer, 0, data.length);
+
+	status = acpi_extract_package(package, &format, &data);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error extracting _BST\n"));
+		kfree(data.pointer);
+		result = -ENODEV;
+		goto end;
+	}
+
+end:
+	acpi_os_free(buffer.pointer);
+
+	if (!result)
+		(*bst) = (struct acpi_battery_status *) data.pointer;
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_battery_set_alarm (
+	struct acpi_battery	*battery,
+	unsigned long		alarm)
+{
+	acpi_status		status = 0;
+	union acpi_object	arg0 = {ACPI_TYPE_INTEGER};
+	struct acpi_object_list	arg_list = {1, &arg0};
+
+	ACPI_FUNCTION_TRACE("acpi_battery_set_alarm");
+
+	if (!battery)
+		return_VALUE(-EINVAL);
+
+	if (!battery->flags.alarm)
+		return_VALUE(-ENODEV);
+
+	arg0.integer.value = alarm;
+
+	status = acpi_evaluate_object(battery->handle, "_BTP", &arg_list, NULL);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Alarm set to %d\n", (u32) alarm));
+
+	battery->alarm = alarm;
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_battery_check (
+	struct acpi_battery	*battery)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	acpi_handle		handle = NULL;
+	struct acpi_device	*device = NULL;
+	struct acpi_battery_info *bif = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_check");
+	
+	if (!battery)
+		return_VALUE(-EINVAL);
+
+	result = acpi_bus_get_device(battery->handle, &device);
+	if (result)
+		return_VALUE(result);
+
+	result = acpi_bus_get_status(device);
+	if (result)
+		return_VALUE(result);
+
+	/* Insertion? */
+
+	if (!battery->flags.present && device->status.battery_present) {
+
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Battery inserted\n"));
+
+		/* Evalute _BIF to get certain static information */
+
+		result = acpi_battery_get_info(battery, &bif);
+		if (result)
+			return_VALUE(result);
+
+		battery->flags.power_unit = bif->power_unit;
+		battery->trips.warning = bif->design_capacity_warning;
+		battery->trips.low = bif->design_capacity_low;
+		kfree(bif);
+
+		/* See if alarms are supported, and if so, set default */
+
+		status = acpi_get_handle(battery->handle, "_BTP", &handle);
+		if (ACPI_SUCCESS(status)) {
+			battery->flags.alarm = 1;
+			acpi_battery_set_alarm(battery, battery->trips.warning);
+		}
+	}
+
+	/* Removal? */
+
+	else if (battery->flags.present && !device->status.battery_present) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Battery removed\n"));
+	}
+
+	battery->flags.present = device->status.battery_present;
+
+	return_VALUE(result);
+}
+
+
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+struct proc_dir_entry		*acpi_battery_dir = NULL;
+
+static int
+acpi_battery_read_info (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	int			result = 0;
+	struct acpi_battery	*battery = (struct acpi_battery *) data;
+	struct acpi_battery_info *bif = NULL;
+	char			*units = "?";
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_read_info");
+
+	if (!battery)
+		goto end;
+
+	if (battery->flags.present)
+		p += sprintf(p, "present:                 yes\n");
+	else {
+		p += sprintf(p, "present:                 no\n");
+		goto end;
+	}
+
+	/* Battery Info (_BIF) */
+
+	result = acpi_battery_get_info(battery, &bif);
+	if (result || !bif) {
+		p += sprintf(p, "ERROR: Unable to read battery information\n");
+		goto end;
+	}
+
+	units = bif->power_unit ? ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS;
+					
+	if (bif->design_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
+		p += sprintf(p, "design capacity:         unknown\n");
+	else
+		p += sprintf(p, "design capacity:         %d %sh\n",
+			(u32) bif->design_capacity, units);
+
+	if (bif->last_full_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
+		p += sprintf(p, "last full capacity:      unknown\n");
+	else
+		p += sprintf(p, "last full capacity:      %d %sh\n",
+			(u32) bif->last_full_capacity, units);
+
+	switch ((u32) bif->battery_technology) {
+	case 0:
+		p += sprintf(p, "battery technology:      non-rechargeable\n");
+		break;
+	case 1:
+		p += sprintf(p, "battery technology:      rechargeable\n");
+		break;
+	default:
+		p += sprintf(p, "battery technology:      unknown\n");
+		break;
+	}
+
+	if (bif->design_voltage == ACPI_BATTERY_VALUE_UNKNOWN)
+		p += sprintf(p, "design voltage:          unknown\n");
+	else
+		p += sprintf(p, "design voltage:          %d mV\n",
+			(u32) bif->design_voltage);
+	
+	p += sprintf(p, "design capacity warning: %d %sh\n",
+		(u32) bif->design_capacity_warning, units);
+	p += sprintf(p, "design capacity low:     %d %sh\n",
+		(u32) bif->design_capacity_low, units);
+	p += sprintf(p, "capacity granularity 1:  %d %sh\n",
+		(u32) bif->battery_capacity_granularity_1, units);
+	p += sprintf(p, "capacity granularity 2:  %d %sh\n",
+		(u32) bif->battery_capacity_granularity_2, units);
+	p += sprintf(p, "model number:            %s\n",
+		bif->model_number);
+	p += sprintf(p, "serial number:           %s\n",
+		bif->serial_number);
+	p += sprintf(p, "battery type:            %s\n",
+		bif->battery_type);
+	p += sprintf(p, "OEM info:                %s\n",
+		bif->oem_info);
+
+end:
+	kfree(bif);
+
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_battery_read_state (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	int			result = 0;
+	struct acpi_battery	*battery = (struct acpi_battery *) data;
+	struct acpi_battery_status *bst = NULL;
+	char			*units = "?";
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_read_state");
+
+	if (!battery)
+		goto end;
+
+	if (battery->flags.present)
+		p += sprintf(p, "present:                 yes\n");
+	else {
+		p += sprintf(p, "present:                 no\n");
+		goto end;
+	}
+
+	/* Battery Units */
+
+	units = battery->flags.power_unit ? ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS;
+
+	/* Battery Status (_BST) */
+
+	result = acpi_battery_get_status(battery, &bst);
+	if (result || !bst) {
+		p += sprintf(p, "ERROR: Unable to read battery status\n");
+		goto end;
+	}
+
+	if (!(bst->state & 0x04))
+		p += sprintf(p, "capacity state:          ok\n");
+	else
+		p += sprintf(p, "capacity state:          critical\n");
+
+	if ((bst->state & 0x01) && (bst->state & 0x02))
+		p += sprintf(p, "charging state:          charging/discharging\n");
+	else if (bst->state & 0x01)
+		p += sprintf(p, "charging state:          discharging\n");
+	else if (bst->state & 0x02)
+		p += sprintf(p, "charging state:          charging\n");
+	else
+		p += sprintf(p, "charging state:          unknown\n");
+
+	if (bst->present_rate == ACPI_BATTERY_VALUE_UNKNOWN)
+		p += sprintf(p, "present rate:            unknown\n");
+	else
+		p += sprintf(p, "present rate:            %d %s\n",
+			(u32) bst->present_rate, units);
+
+	if (bst->remaining_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
+		p += sprintf(p, "remaining capacity:      unknown\n");
+	else
+		p += sprintf(p, "remaining capacity:      %d %sh\n",
+			(u32) bst->remaining_capacity, units);
+
+	if (bst->present_voltage == ACPI_BATTERY_VALUE_UNKNOWN)
+		p += sprintf(p, "present voltage:         unknown\n");
+	else
+		p += sprintf(p, "present voltage:         %d mV\n",
+			(u32) bst->present_voltage);
+
+end:
+	kfree(bst);
+
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_battery_read_alarm (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_battery	*battery = (struct acpi_battery *) data;
+	char			*units = "?";
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_read_alarm");
+
+	if (!battery)
+		goto end;
+
+	if (!battery->flags.present) {
+		p += sprintf(p, "present:                 no\n");
+		goto end;
+	}
+
+	/* Battery Units */
+	
+	units = battery->flags.power_unit ? ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS;
+
+	/* Battery Alarm */
+
+	p += sprintf(p, "alarm:                   ");
+	if (!battery->alarm)
+		p += sprintf(p, "unsupported\n");
+	else
+		p += sprintf(p, "%d %sh\n", (u32) battery->alarm, units);
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_battery_write_alarm (
+	struct file		*file,
+	const char		*buffer,
+	unsigned long		count,
+	void			*data)
+{
+	int			result = 0;
+	struct acpi_battery	*battery = (struct acpi_battery *) data;
+	char			alarm_string[12] = {'\0'};
+
+	ACPI_FUNCTION_TRACE("acpi_battery_write_alarm");
+
+	if (!battery || (count > sizeof(alarm_string) - 1))
+		return_VALUE(-EINVAL);
+
+	if (!battery->flags.present)
+		return_VALUE(-ENODEV);
+
+	if (copy_from_user(alarm_string, buffer, count))
+		return_VALUE(-EFAULT);
+	
+	alarm_string[count] = '\0';
+
+	result = acpi_battery_set_alarm(battery, 
+		simple_strtoul(alarm_string, NULL, 0));
+	if (result)
+		return_VALUE(result);
+
+	return_VALUE(count);
+}
+
+
+static int
+acpi_battery_add_fs (
+	struct acpi_device	*device)
+{
+	struct proc_dir_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_add_fs");
+
+	if (!acpi_device_dir(device)) {
+		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
+			acpi_battery_dir);
+		if (!acpi_device_dir(device))
+			return_VALUE(-ENODEV);
+	}
+
+	/* 'info' [R] */
+	entry = create_proc_entry(ACPI_BATTERY_FILE_INFO,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_BATTERY_FILE_INFO));
+	else {
+		entry->read_proc = acpi_battery_read_info;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'status' [R] */
+	entry = create_proc_entry(ACPI_BATTERY_FILE_STATUS,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_BATTERY_FILE_STATUS));
+	else {
+		entry->read_proc = acpi_battery_read_state;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'alarm' [R/W] */
+	entry = create_proc_entry(ACPI_BATTERY_FILE_ALARM,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_BATTERY_FILE_ALARM));
+	else {
+		entry->read_proc = acpi_battery_read_alarm;
+		entry->write_proc = acpi_battery_write_alarm;
+		entry->data = acpi_driver_data(device);
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_battery_remove_fs (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_battery_remove_fs");
+
+	if (acpi_device_dir(device)) {
+		remove_proc_entry(acpi_device_bid(device), acpi_battery_dir);
+		acpi_device_dir(device) = NULL;
+	}
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                 Driver Interface
+   -------------------------------------------------------------------------- */
+
+static void
+acpi_battery_notify (
+	acpi_handle		handle,
+	u32			event,
+	void			*data)
+{
+	struct acpi_battery	*battery = (struct acpi_battery *) data;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_notify");
+
+	if (!battery)
+		return_VOID;
+
+	if (acpi_bus_get_device(handle, &device))
+		return_VOID;
+
+	switch (event) {
+	case ACPI_BATTERY_NOTIFY_STATUS:
+	case ACPI_BATTERY_NOTIFY_INFO:
+		acpi_battery_check(battery);
+		acpi_bus_generate_event(device, event, battery->flags.present);
+		break;
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Unsupported event [0x%x]\n", event));
+		break;
+	}
+
+	return_VOID;
+}
+
+
+static int
+acpi_battery_add (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	acpi_status		status = 0;
+	struct acpi_battery	*battery = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_add");
+	
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	battery = kmalloc(sizeof(struct acpi_battery), GFP_KERNEL);
+	if (!battery)
+		return_VALUE(-ENOMEM);
+	memset(battery, 0, sizeof(struct acpi_battery));
+
+	battery->handle = device->handle;
+	sprintf(acpi_device_name(device), "%s", ACPI_BATTERY_DEVICE_NAME);
+	sprintf(acpi_device_class(device), "%s", ACPI_BATTERY_CLASS);
+	acpi_driver_data(device) = battery;
+
+	result = acpi_battery_check(battery);
+	if (result)
+		goto end;
+
+	result = acpi_battery_add_fs(device);
+	if (result)
+		goto end;
+
+	status = acpi_install_notify_handler(battery->handle,
+		ACPI_DEVICE_NOTIFY, acpi_battery_notify, battery);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error installing notify handler\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	printk(KERN_INFO PREFIX "%s Slot [%s] (battery %s)\n",
+		ACPI_BATTERY_DEVICE_NAME, acpi_device_bid(device),
+		device->status.battery_present?"present":"absent");
+		
+end:
+	if (result) {
+		acpi_battery_remove_fs(device);
+		kfree(battery);
+	}
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_battery_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	acpi_status		status = 0;
+	struct acpi_battery	*battery = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	battery = (struct acpi_battery *) acpi_driver_data(device);
+
+	status = acpi_remove_notify_handler(battery->handle,
+		ACPI_DEVICE_NOTIFY, acpi_battery_notify);
+	if (ACPI_FAILURE(status))
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error removing notify handler\n"));
+
+	acpi_battery_remove_fs(device);
+
+	kfree(battery);
+
+	return_VALUE(0);
+}
+
+
+static int __init
+acpi_battery_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_init");
+
+	acpi_battery_dir = proc_mkdir(ACPI_BATTERY_CLASS, acpi_root_dir);
+	if (!acpi_battery_dir)
+		return_VALUE(-ENODEV);
+
+	result = acpi_bus_register_driver(&acpi_battery_driver);
+	if (result < 0) {
+		remove_proc_entry(ACPI_BATTERY_CLASS, acpi_root_dir);
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+
+
+static void __exit
+acpi_battery_exit (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_battery_exit");
+
+	acpi_bus_unregister_driver(&acpi_battery_driver);
+
+	remove_proc_entry(ACPI_BATTERY_CLASS, acpi_root_dir);
+
+	return_VOID;
+}
+
+
+module_init(acpi_battery_init);
+module_exit(acpi_battery_exit);
diff -urNp linux-5400/drivers/acpi/blacklist.c linux-5410/drivers/acpi/blacklist.c
--- linux-5400/drivers/acpi/blacklist.c
+++ linux-5410/drivers/acpi/blacklist.c
@@ -0,0 +1,141 @@
+/*
+ *  blacklist.c
+ *
+ *  Check to see if the given machine has a known bad ACPI BIOS
+ *
+ *  Copyright (C) 2002 Andy Grover <andrew.grover@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/acpi.h>
+#include <acpi/acpi_bus.h>
+
+#define	PREFIX			"ACPI: "
+
+enum acpi_blacklist_predicates
+{
+        all_versions,
+        less_than_or_equal,
+        equal,
+        greater_than_or_equal,
+};
+
+struct acpi_blacklist_item
+{
+        char            oem_id[7];
+        char            oem_table_id[9];
+        u32             oem_revision;
+        acpi_table_type table;
+        enum acpi_blacklist_predicates oem_revision_predicate;
+        char            *reason;
+        u32             is_critical_error;
+};
+
+/*
+ * POLICY: If *anything* doesn't work, put it on the blacklist.
+ *	   If they are critical errors, mark it critical, and abort driver load.
+ */
+static struct acpi_blacklist_item acpi_blacklist[] __initdata =
+{
+	/* Portege 7020, BIOS 8.10 */
+	{"TOSHIB", "7020CT  ", 0x19991112, ACPI_DSDT, all_versions, "Implicit Return", 0},
+	/* Portege 4030 */
+	{"TOSHIB", "4030    ", 0x19991112, ACPI_DSDT, all_versions, "Implicit Return", 0},
+	/* Portege 310/320, BIOS 7.1 */
+	{"TOSHIB", "310     ", 0x19990511, ACPI_DSDT, all_versions, "Implicit Return", 0},
+	/* Seattle 2, old bios rev. */
+	{"INTEL ", "440BX   ", 0x00001000, ACPI_DSDT, less_than_or_equal, "Field beyond end of region", 0},
+	/* ASUS K7M */
+	{"ASUS  ", "K7M     ", 0x00001000, ACPI_DSDT, less_than_or_equal, "Field beyond end of region", 0},
+	/* Intel 810 Motherboard? */
+	{"MNTRAL", "MO81010A", 0x00000012, ACPI_DSDT, less_than_or_equal, "Field beyond end of region", 0},
+	/* Compaq Presario 711FR */
+	{"COMAPQ", "EAGLES", 0x06040000, ACPI_DSDT, less_than_or_equal, "SCI issues (C2 disabled)", 0},
+	/* Compaq Presario 1700 */
+	{"PTLTD ", "  DSDT  ", 0x06040000, ACPI_DSDT, less_than_or_equal, "Multiple problems", 1},
+	/* Sony FX120, FX140, FX150? */
+	{"SONY  ", "U0      ", 0x20010313, ACPI_DSDT, less_than_or_equal, "ACPI driver problem", 1},
+	/* Compaq Presario 800, Insyde BIOS */
+	{"INT440", "SYSFexxx", 0x00001001, ACPI_DSDT, less_than_or_equal, "Does not use _REG to protect EC OpRegions", 1},
+	/* IBM 600E - _ADR should return 7, but it returns 1 */
+	{"IBM   ", "TP600E  ", 0x00000105, ACPI_DSDT, less_than_or_equal, "Incorrect _ADR", 1},
+	{"ASUS\0\0", "P2B-S   ", 0, ACPI_DSDT, all_versions, "Bogus PCI routing", 1},
+
+	{""}
+};
+
+
+int __init
+acpi_blacklisted(void)
+{
+	int i = 0;
+	int blacklisted = 0;
+	struct acpi_table_header *table_header;
+
+	while (acpi_blacklist[i].oem_id[0] != '\0')
+	{
+		if (acpi_get_table_header_early(acpi_blacklist[i].table, &table_header)) {
+			i++;
+			continue;
+		}
+
+		if (strncmp(acpi_blacklist[i].oem_id, table_header->oem_id, 6)) {
+			i++;
+			continue;
+		}
+
+		if (strncmp(acpi_blacklist[i].oem_table_id, table_header->oem_table_id, 8)) {
+			i++;
+			continue;
+		}
+
+		if ((acpi_blacklist[i].oem_revision_predicate == all_versions)
+		    || (acpi_blacklist[i].oem_revision_predicate == less_than_or_equal
+		        && table_header->oem_revision <= acpi_blacklist[i].oem_revision)
+		    || (acpi_blacklist[i].oem_revision_predicate == greater_than_or_equal
+		        && table_header->oem_revision >= acpi_blacklist[i].oem_revision)
+		    || (acpi_blacklist[i].oem_revision_predicate == equal
+		        && table_header->oem_revision == acpi_blacklist[i].oem_revision)) {
+
+			printk(KERN_ERR PREFIX "Vendor \"%6.6s\" System \"%8.8s\" "
+				"Revision 0x%x has a known ACPI BIOS problem.\n",
+				acpi_blacklist[i].oem_id,
+				acpi_blacklist[i].oem_table_id,
+				acpi_blacklist[i].oem_revision);
+
+			printk(KERN_ERR PREFIX "Reason: %s. This is a %s error\n",
+				acpi_blacklist[i].reason,
+				(acpi_blacklist[i].is_critical_error ? "non-recoverable" : "recoverable"));
+
+			blacklisted = acpi_blacklist[i].is_critical_error;
+			break;
+		}
+		else {
+			i++;
+		}
+	}
+
+	return blacklisted;
+}
+
diff -urNp linux-5400/drivers/acpi/bus.c linux-5410/drivers/acpi/bus.c
--- linux-5400/drivers/acpi/bus.c
+++ linux-5410/drivers/acpi/bus.c
@@ -0,0 +1,2140 @@
+/*
+ *  acpi_bus.c - ACPI Bus Driver ($Revision: 77 $)
+ *
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/ioport.h>
+#include <linux/list.h>
+#include <linux/sched.h>
+#include <linux/pm.h>
+#include <linux/proc_fs.h>
+#include <linux/reboot.h>
+#ifdef CONFIG_X86
+#include <asm/mpspec.h>
+#endif
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+#include <acpi/acinterp.h>	/* for acpi_ex_eisa_id_to_string() */
+
+
+#define _COMPONENT		ACPI_BUS_COMPONENT
+ACPI_MODULE_NAME		("acpi_bus")
+
+MODULE_AUTHOR("Paul Diefenbaugh");
+MODULE_DESCRIPTION(ACPI_BUS_DRIVER_NAME);
+MODULE_LICENSE("GPL");
+
+#define	PREFIX			"ACPI: "
+
+extern void eisa_set_level_irq(unsigned int irq);
+
+extern int			acpi_disabled;
+
+FADT_DESCRIPTOR			acpi_fadt;
+struct acpi_device		*acpi_root;
+struct proc_dir_entry		*acpi_root_dir;
+
+#define STRUCT_TO_INT(s)	(*((int*)&s))
+
+
+/* --------------------------------------------------------------------------
+                          Linux Driver Model (LDM) Support
+   -------------------------------------------------------------------------- */
+
+#ifdef CONFIG_LDM
+
+static int acpi_device_probe(struct device *dev);
+static int acpi_device_remove(struct device *dev);
+static int acpi_device_suspend(struct device *dev, u32 state, u32 stage);
+static int acpi_device_resume(struct device *dev, u32 stage);
+
+static struct device_driver acpi_bus_driver = {
+	.probe = acpi_device_probe,
+	.remove = acpi_device_remove,	
+	.suspend = acpi_device_suspend,
+	.resume = acpi_device_resume,
+};
+
+
+static int
+acpi_device_probe (
+	struct device		*dev)
+{
+	ACPI_FUNCTION_TRACE("acpi_device_probe");
+
+	if (!dev)
+		return_VALUE(-EINVAL);
+
+	/* TBD */
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_device_remove (
+	struct device		*dev)
+{
+	ACPI_FUNCTION_TRACE("acpi_device_remove");
+
+	if (!dev)
+		return_VALUE(-EINVAL);
+
+	/* TBD */
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_device_suspend (
+	struct device		*dev,
+	u32			state,
+	u32			stage)
+{
+	ACPI_FUNCTION_TRACE("acpi_device_suspend");
+
+	if (!dev)
+		return_VALUE(-EINVAL);
+
+	/* TBD */
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_device_resume (
+	struct device		*dev,
+	u32			stage)
+{
+	ACPI_FUNCTION_TRACE("acpi_device_resume");
+
+	if (!dev)
+		return_VALUE(-EINVAL);
+
+	/* TBD */
+
+	return_VALUE(0);
+}
+
+#if 0 /* not used ATM */
+static int
+acpi_platform_add (
+	struct device		*dev)
+{
+	ACPI_FUNCTION_TRACE("acpi_platform_add");
+
+	if (!dev)
+		return -EINVAL;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device %s (%s) added\n",
+		dev->name, dev->bus_id));
+
+	/* TBD */
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_platform_remove (
+	struct device		*dev)
+{
+	ACPI_FUNCTION_TRACE("acpi_platform_add");
+
+	if (!dev)
+		return -EINVAL;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device %s (%s) removed\n",
+		dev->name, dev->bus_id));
+
+	/* TBD */
+
+	return_VALUE(0);
+}
+#endif /* unused */
+
+
+#endif /*CONFIG_LDM*/
+
+
+static int
+acpi_device_register (
+	struct acpi_device	*device,
+	struct acpi_device	*parent)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_device_register");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+#ifdef CONFIG_LDM
+	sprintf(device->dev.name, "ACPI device %s:%s", 
+		device->pnp.hardware_id, device->pnp.unique_id);
+	strncpy(device->dev.bus_id, device->pnp.bus_id, sizeof(acpi_bus_id));
+	if (parent)
+		device->dev.parent = &parent->dev;
+	device->dev.driver = &acpi_bus_driver;
+
+	result = device_register(&device->dev);
+#endif /*CONFIG_LDM*/
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_device_unregister (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_device_unregister");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+#ifdef CONFIG_LDM
+	put_device(&device->dev);
+#endif /*CONFIG_LDM*/
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                Device Management
+   -------------------------------------------------------------------------- */
+
+static void
+acpi_bus_data_handler (
+	acpi_handle		handle,
+	u32			function,
+	void			*context)
+{
+	ACPI_FUNCTION_TRACE("acpi_bus_data_handler");
+
+	/* TBD */
+
+	return_VOID;
+}
+
+
+int
+acpi_bus_get_device (
+	acpi_handle		handle,
+	struct acpi_device	**device)
+{
+	acpi_status		status = AE_OK;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_get_device");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	/* TBD: Support fixed-feature devices */
+
+	status = acpi_get_data(handle, acpi_bus_data_handler, (void**) device);
+	if (ACPI_FAILURE(status) || !*device) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Error getting context for object [%p]\n",
+			handle));
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+
+int
+acpi_bus_get_status (
+	struct acpi_device	*device)
+{
+	acpi_status		status = AE_OK;
+	unsigned long		sta = 0;
+	
+	ACPI_FUNCTION_TRACE("acpi_bus_get_status");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	/*
+	 * Evaluate _STA if present.
+	 */
+	if (device->flags.dynamic_status) {
+		status = acpi_evaluate_integer(device->handle, "_STA", NULL, &sta);
+		if (ACPI_FAILURE(status))
+			return_VALUE(-ENODEV);
+		STRUCT_TO_INT(device->status) = (int) sta;
+	}
+
+	/*
+	 * Otherwise we assume the status of our parent (unless we don't
+	 * have one, in which case status is implied).
+	 */
+	else if (device->parent)
+		device->status = device->parent->status;
+	else
+		STRUCT_TO_INT(device->status) = 0x0F;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] status [%08x]\n", 
+		device->pnp.bus_id, (u32) STRUCT_TO_INT(device->status)));
+
+	return_VALUE(0);
+}
+
+
+/*
+static int
+acpi_bus_create_device_fs (struct device *device)
+{
+	ACPI_FUNCTION_TRACE("acpi_bus_create_device_fs");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	if (device->dir.entry)
+		return_VALUE(-EEXIST);
+
+	if (!device->parent)
+		device->dir.entry = proc_mkdir(device->pnp.bus_id, NULL);
+	else
+		device->dir.entry = proc_mkdir(device->pnp.bus_id,
+			device->parent->fs.entry);
+
+	if (!device->dir.entry) {
+		printk(KERN_ERR PREFIX "Unable to create fs entry '%s'\n",
+			device->pnp.bus_id);
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_bus_remove_device_fs (struct device *device)
+{
+	ACPI_FUNCTION_TRACE("acpi_bus_create_device_fs");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	if (!device->dir.entry)
+		return_VALUE(-ENODEV);
+
+	if (!device->parent)
+		remove_proc_entry(device->pnp_bus_id, NULL);
+	else
+		remove_proc_entry(device->pnp.bus_id, device->parent->fs.entry);
+
+	device->dir.entry = NULL;
+
+	return_VALUE(0);
+}
+*/
+
+
+/* --------------------------------------------------------------------------
+                                 Power Management
+   -------------------------------------------------------------------------- */
+
+int
+acpi_bus_get_power (
+	acpi_handle		handle,
+	int			*state)
+{
+	int			result = 0;
+	acpi_status             status = 0;
+	struct acpi_device	*device = NULL;
+	unsigned long		psc = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_get_power");
+
+	result = acpi_bus_get_device(handle, &device);
+	if (result)
+		return_VALUE(result);
+
+	*state = ACPI_STATE_UNKNOWN;
+
+	if (!device->flags.power_manageable) {
+		/* TBD: Non-recursive algorithm for walking up hierarchy */
+		if (device->parent)
+			*state = device->parent->power.state;
+		else
+			*state = ACPI_STATE_D0;
+	}
+	else {
+		/*
+		 * Get the device's power state either directly (via _PSC) or 
+		 * indirectly (via power resources).
+		 */
+		if (device->power.flags.explicit_get) {
+			status = acpi_evaluate_integer(device->handle, "_PSC", 
+				NULL, &psc);
+			if (ACPI_FAILURE(status))
+				return_VALUE(-ENODEV);
+			device->power.state = (int) psc;
+		}
+		else if (device->power.flags.power_resources) {
+			result = acpi_power_get_inferred_state(device);
+			if (result)
+				return_VALUE(result);
+		}
+
+		*state = device->power.state;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] power state is D%d\n",
+		device->pnp.bus_id, device->power.state));
+
+	return_VALUE(0);
+}
+
+
+int
+acpi_bus_set_power (
+	acpi_handle		handle,
+	int			state)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_device	*device = NULL;
+	char			object_name[5] = {'_','P','S','0'+state,'\0'};
+
+	ACPI_FUNCTION_TRACE("acpi_bus_set_power");
+
+	result = acpi_bus_get_device(handle, &device);
+	if (result)
+		return_VALUE(result);
+
+	if ((state < ACPI_STATE_D0) || (state > ACPI_STATE_D3))
+		return_VALUE(-EINVAL);
+
+	/* Make sure this is a valid target state */
+
+	if (!device->flags.power_manageable) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Device is not power manageable\n"));
+		return_VALUE(-ENODEV);
+	}
+	if (state == device->power.state) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at D%d\n", state));
+		return_VALUE(0);
+	}
+	if (!device->power.states[state].flags.valid) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Device does not support D%d\n", state));
+		return_VALUE(-ENODEV);
+	}
+	if (device->parent && (state < device->parent->power.state)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Cannot set device to a higher-powered state than parent\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	/*
+	 * Transition Power
+	 * ----------------
+	 * On transitions to a high-powered state we first apply power (via
+	 * power resources) then evalute _PSx.  Conversly for transitions to
+	 * a lower-powered state.
+	 */ 
+	if (state < device->power.state) {
+		if (device->power.flags.power_resources) {
+			result = acpi_power_transition(device, state);
+			if (result)
+				goto end;
+		}
+		if (device->power.states[state].flags.explicit_set) {
+			status = acpi_evaluate_object(device->handle, 
+				object_name, NULL, NULL);
+			if (ACPI_FAILURE(status)) {
+				result = -ENODEV;
+				goto end;
+			}
+		}
+	}
+	else {
+		if (device->power.states[state].flags.explicit_set) {
+			status = acpi_evaluate_object(device->handle, 
+				object_name, NULL, NULL);
+			if (ACPI_FAILURE(status)) {
+				result = -ENODEV;
+				goto end;
+			}
+		}
+		if (device->power.flags.power_resources) {
+			result = acpi_power_transition(device, state);
+			if (result)
+				goto end;
+		}
+	}
+
+end:
+	if (result)
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Error transitioning device [%s] to D%d\n",
+			device->pnp.bus_id, state));
+	else
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] transitioned to D%d\n",
+			device->pnp.bus_id, state));
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_bus_get_power_flags (
+	struct acpi_device	*device)
+{
+	acpi_status             status = 0;
+	acpi_handle		handle = 0;
+	u32                     i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_get_power_flags");
+
+	if (!device)
+		return -ENODEV;
+
+	/*
+	 * Power Management Flags
+	 */
+	status = acpi_get_handle(device->handle, "_PSC", &handle);
+	if (ACPI_SUCCESS(status))
+		device->power.flags.explicit_get = 1;
+	status = acpi_get_handle(device->handle, "_IRC", &handle);
+	if (ACPI_SUCCESS(status))
+		device->power.flags.inrush_current = 1;
+	status = acpi_get_handle(device->handle, "_PRW", &handle);
+	if (ACPI_SUCCESS(status))
+		device->power.flags.wake_capable = 1;
+
+	/*
+	 * Enumerate supported power management states
+	 */
+	for (i = ACPI_STATE_D0; i <= ACPI_STATE_D3; i++) {
+		struct acpi_device_power_state *ps = &device->power.states[i];
+		char		object_name[5] = {'_','P','R','0'+i,'\0'};
+
+		/* Evaluate "_PRx" to se if power resources are referenced */
+		acpi_evaluate_reference(device->handle, object_name, NULL,
+			&ps->resources);
+		if (ps->resources.count) {
+			device->power.flags.power_resources = 1;
+			ps->flags.valid = 1;
+		}
+
+		/* Evaluate "_PSx" to see if we can do explicit sets */
+		object_name[2] = 'S';
+		status = acpi_get_handle(device->handle, object_name, &handle);
+		if (ACPI_SUCCESS(status)) {
+			ps->flags.explicit_set = 1;
+			ps->flags.valid = 1;
+		}
+
+		/* State is valid if we have some power control */
+		if (ps->resources.count || ps->flags.explicit_set)
+			ps->flags.valid = 1;
+
+		ps->power = -1;		/* Unknown - driver assigned */
+		ps->latency = -1;	/* Unknown - driver assigned */
+	}
+
+	/* Set defaults for D0 and D3 states (always valid) */
+	device->power.states[ACPI_STATE_D0].flags.valid = 1;
+	device->power.states[ACPI_STATE_D0].power = 100;
+	device->power.states[ACPI_STATE_D3].flags.valid = 1;
+	device->power.states[ACPI_STATE_D3].power = 0;
+
+	/*
+	 * System Power States
+	 * -------------------
+	 */
+	/* TBD: S1-S4 power state support and resource requirements. */
+	/*
+	for (i=ACPI_STATE_S1; i<ACPI_STATE_S5; i++) {
+		char name[5] = {'_','S',('0'+i),'D','\0'};
+		status = acpi_evaluate_integer(device->handle, name, NULL,
+			&state);
+		if (ACPI_FAILURE(status))
+			continue;
+	}
+	*/
+
+	/* TBD: System wake support and resource requirements. */
+
+	device->power.state = ACPI_STATE_UNKNOWN;
+
+	return 0;
+}
+
+
+/* --------------------------------------------------------------------------
+                              Performance Management
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_bus_get_perf_flags (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_bus_get_perf_flags");
+
+	if (!device)
+		return -ENODEV;
+
+	device->performance.state = ACPI_STATE_UNKNOWN;
+
+	return 0;
+}
+
+
+/* --------------------------------------------------------------------------
+                                Event Management
+   -------------------------------------------------------------------------- */
+
+static spinlock_t		acpi_bus_event_lock = SPIN_LOCK_UNLOCKED;
+
+LIST_HEAD(acpi_bus_event_list);
+DECLARE_WAIT_QUEUE_HEAD(acpi_bus_event_queue);
+
+extern int			event_is_open;
+
+int
+acpi_bus_generate_event (
+	struct acpi_device	*device,
+	u8			type,
+	int			data)
+{
+	struct acpi_bus_event	*event = NULL;
+	u32			flags = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_generate_event");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	/* drop event on the floor if no one's listening */
+	if (!event_is_open)
+		return_VALUE(0);
+
+	event = kmalloc(sizeof(struct acpi_bus_event), GFP_ATOMIC);
+	if (!event)
+		return_VALUE(-ENOMEM);
+
+	sprintf(event->device_class, "%s", device->pnp.device_class);
+	sprintf(event->bus_id, "%s", device->pnp.bus_id);
+	event->type = type;
+	event->data = data;
+
+	spin_lock_irqsave(&acpi_bus_event_lock, flags);
+	list_add_tail(&event->node, &acpi_bus_event_list);
+	spin_unlock_irqrestore(&acpi_bus_event_lock, flags);
+
+	wake_up_interruptible(&acpi_bus_event_queue);
+
+	return_VALUE(0);
+}
+
+int
+acpi_bus_receive_event (
+	struct acpi_bus_event	*event)
+{
+	u32			flags = 0;
+	struct acpi_bus_event	*entry = NULL;
+
+	DECLARE_WAITQUEUE(wait, current);
+
+	ACPI_FUNCTION_TRACE("acpi_bus_receive_event");
+
+	if (!event)
+		return -EINVAL;
+
+	if (list_empty(&acpi_bus_event_list)) {
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_wait_queue(&acpi_bus_event_queue, &wait);
+
+		if (list_empty(&acpi_bus_event_list))
+			schedule();
+
+		remove_wait_queue(&acpi_bus_event_queue, &wait);
+		set_current_state(TASK_RUNNING);
+
+		if (signal_pending(current))
+			return_VALUE(-ERESTARTSYS);
+	}
+
+	spin_lock_irqsave(&acpi_bus_event_lock, flags);
+	entry = list_entry(acpi_bus_event_list.next, struct acpi_bus_event, node);
+	if (entry)
+		list_del(&entry->node);
+	spin_unlock_irqrestore(&acpi_bus_event_lock, flags);
+
+	if (!entry)
+		return_VALUE(-ENODEV);
+
+	memcpy(event, entry, sizeof(struct acpi_bus_event));
+
+	kfree(entry);
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                               Namespace Management
+   -------------------------------------------------------------------------- */
+
+#define WALK_UP			0
+#define WALK_DOWN		1
+
+typedef int (*acpi_bus_walk_callback)(struct acpi_device*, int, void*);
+
+#define HAS_CHILDREN(d)		((d)->children.next != &((d)->children))
+#define HAS_SIBLINGS(d)		(((d)->parent) && ((d)->node.next != &(d)->parent->children))
+#define NODE_TO_DEVICE(n)	(list_entry(n, struct acpi_device, node))
+
+
+/**
+ * acpi_bus_walk
+ * -------------
+ * Used to walk the ACPI Bus's device namespace.  Can walk down (depth-first)
+ * or up.  Able to parse starting at any node in the namespace.  Note that a
+ * callback return value of -ELOOP will terminate the walk.
+ *
+ * @start:	starting point
+ * callback:	function to call for every device encountered while parsing
+ * direction:	direction to parse (up or down)
+ * @data:	context for this search operation
+ */
+static int
+acpi_bus_walk (
+	struct acpi_device	*start, 
+	acpi_bus_walk_callback	callback, 
+	int			direction, 
+	void			*data)
+{
+	int			result = 0;
+	int			level = 0;
+	struct acpi_device	*device = NULL;
+
+	if (!start || !callback)
+		return -EINVAL;
+
+	device = start;
+
+	/*
+	 * Parse Namespace
+	 * ---------------
+	 * Parse a given subtree (specified by start) in the given direction.
+	 * Walking 'up' simply means that we execute the callback on leaf
+	 * devices prior to their parents (useful for things like removing
+	 * or powering down a subtree).
+	 */
+
+	while (device) {
+
+		if (direction == WALK_DOWN)
+			if (-ELOOP == callback(device, level, data))
+				break;
+
+		/* Depth First */
+
+		if (HAS_CHILDREN(device)) {
+			device = NODE_TO_DEVICE(device->children.next);
+			++level;
+			continue;
+		}
+
+		if (direction == WALK_UP)
+			if (-ELOOP == callback(device, level, data))
+				break;
+
+		/* Now Breadth */
+
+		if (HAS_SIBLINGS(device)) {
+			device = NODE_TO_DEVICE(device->node.next);
+			continue;
+		}
+
+		/* Scope Exhausted - Find Next */
+
+		while ((device = device->parent)) {
+			--level;
+			if (HAS_SIBLINGS(device)) {
+				device = NODE_TO_DEVICE(device->node.next);
+				break;
+			}
+		}
+	}
+
+	if ((direction == WALK_UP) && (result == 0))
+		callback(start, level, data);
+
+	return result;
+}
+
+
+/* --------------------------------------------------------------------------
+                             Notification Handling
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_bus_check_device (
+	struct acpi_device	*device,
+	int			*status_changed)
+{
+	acpi_status             status = 0;
+	struct acpi_device_status old_status;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_check_device");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	if (status_changed)
+		*status_changed = 0;
+
+	old_status = device->status;
+
+	/*
+	 * Make sure this device's parent is present before we go about
+	 * messing with the device.
+	 */
+	if (device->parent && !device->parent->status.present) {
+		device->status = device->parent->status;
+		if (STRUCT_TO_INT(old_status) != STRUCT_TO_INT(device->status)) {
+			if (status_changed)
+				*status_changed = 1;
+		}
+		return_VALUE(0);
+	}
+
+	status = acpi_bus_get_status(device);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	if (STRUCT_TO_INT(old_status) == STRUCT_TO_INT(device->status))
+		return_VALUE(0);
+
+	if (status_changed)
+		*status_changed = 1;
+	
+	/*
+	 * Device Insertion/Removal
+	 */
+	if ((device->status.present) && !(old_status.present)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device insertion detected\n"));
+		/* TBD: Handle device insertion */
+	}
+	else if (!(device->status.present) && (old_status.present)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device removal detected\n"));
+		/* TBD: Handle device removal */
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_bus_check_scope (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	int			status_changed = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_check_scope");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	/* Status Change? */
+	result = acpi_bus_check_device(device, &status_changed);
+	if (result)
+		return_VALUE(result);
+
+	if (!status_changed)
+		return_VALUE(0);
+
+	/*
+	 * TBD: Enumerate child devices within this device's scope and
+	 *       run acpi_bus_check_device()'s on them.
+	 */
+
+	return_VALUE(0);
+}
+
+
+/**
+ * acpi_bus_notify
+ * ---------------
+ * Callback for all 'system-level' device notifications (values 0x00-0x7F).
+ */
+static void 
+acpi_bus_notify (
+	acpi_handle             handle,
+	u32                     type,
+	void                    *data)
+{
+	int			result = 0;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_notify");
+
+	if (acpi_bus_get_device(handle, &device))
+		return_VOID;
+
+	switch (type) {
+
+	case ACPI_NOTIFY_BUS_CHECK:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received BUS CHECK notification for device [%s]\n", 
+			device->pnp.bus_id));
+		result = acpi_bus_check_scope(device);
+		/* 
+		 * TBD: We'll need to outsource certain events to non-ACPI
+		 *	drivers via the device manager (device.c).
+		 */
+		break;
+
+	case ACPI_NOTIFY_DEVICE_CHECK:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received DEVICE CHECK notification for device [%s]\n", 
+			device->pnp.bus_id));
+		result = acpi_bus_check_device(device, NULL);
+		/* 
+		 * TBD: We'll need to outsource certain events to non-ACPI
+		 *	drivers via the device manager (device.c).
+		 */
+		break;
+
+	case ACPI_NOTIFY_DEVICE_WAKE:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received DEVICE WAKE notification for device [%s]\n", 
+			device->pnp.bus_id));
+		/* TBD */
+		break;
+
+	case ACPI_NOTIFY_EJECT_REQUEST:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received EJECT REQUEST notification for device [%s]\n", 
+			device->pnp.bus_id));
+		/* TBD */
+		break;
+
+	case ACPI_NOTIFY_DEVICE_CHECK_LIGHT:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received DEVICE CHECK LIGHT notification for device [%s]\n", 
+			device->pnp.bus_id));
+		/* TBD: Exactly what does 'light' mean? */
+		break;
+
+	case ACPI_NOTIFY_FREQUENCY_MISMATCH:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received FREQUENCY MISMATCH notification for device [%s]\n", 
+			device->pnp.bus_id));
+		/* TBD */
+		break;
+
+	case ACPI_NOTIFY_BUS_MODE_MISMATCH:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received BUS MODE MISMATCH notification for device [%s]\n", 
+			device->pnp.bus_id));
+		/* TBD */
+		break;
+
+	case ACPI_NOTIFY_POWER_FAULT:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received POWER FAULT notification for device [%s]\n", 
+			device->pnp.bus_id));
+		/* TBD */
+		break;
+
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received unknown/unsupported notification [%08x]\n", 
+			type));
+		break;
+	}
+
+	return_VOID;
+}
+
+
+/* --------------------------------------------------------------------------
+                                 Driver Management
+   -------------------------------------------------------------------------- */
+
+static LIST_HEAD(acpi_bus_drivers);
+static DECLARE_MUTEX(acpi_bus_drivers_lock);
+
+
+/**
+ * acpi_bus_match 
+ * --------------
+ * Checks the device's hardware (_HID) or compatible (_CID) ids to see if it
+ * matches the specified driver's criteria.
+ */
+static int
+acpi_bus_match (
+	struct acpi_device	*device,
+	struct acpi_driver	*driver)
+{
+	int error = 0;
+
+	if (device->flags.hardware_id)
+		if (strstr(driver->ids, device->pnp.hardware_id))
+			goto Done;
+
+	if (device->flags.compatible_ids) {
+		struct acpi_compatible_id_list *cid_list = device->pnp.cid_list;
+		int i;
+
+		/* compare multiple _CID entries against driver ids */
+		for (i = 0; i < cid_list->count; i++)
+		{
+			if (strstr(driver->ids, cid_list->id[i].value))
+				goto Done;
+		}
+	}
+	error = -ENOENT;
+
+ Done:
+	
+	return error;
+}
+
+
+/**
+ * acpi_bus_driver_init 
+ * --------------------
+ * Used to initialize a device via its device driver.  Called whenever a 
+ * driver is bound to a device.  Invokes the driver's add() and start() ops.
+ */
+static int
+acpi_bus_driver_init (
+	struct acpi_device	*device, 
+	struct acpi_driver	*driver)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_driver_init");
+
+	if (!device || !driver)
+		return_VALUE(-EINVAL);
+
+	if (!driver->ops.add)
+		return_VALUE(-ENOSYS);
+
+	result = driver->ops.add(device);
+	if (result) {
+		device->driver = NULL;
+		acpi_driver_data(device) = NULL;
+		return_VALUE(result);
+	}
+
+	device->driver = driver;
+
+	/*
+	 * TBD - Configuration Management: Assign resources to device based
+	 * upon possible configuration and currently allocated resources.
+	 */
+
+	if (driver->ops.start) {
+		result = driver->ops.start(device);
+		if (result && driver->ops.remove)
+			driver->ops.remove(device, ACPI_BUS_REMOVAL_NORMAL);
+		return_VALUE(result);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Driver successfully bound to device\n"));
+
+#ifdef CONFIG_LDM
+	/* 
+	 * Update the device information (in the global device hierarchy) now
+	 * that there's a driver bound to it.
+	 */
+	strncpy(device->dev.name, device->pnp.device_name, 
+		sizeof(device->dev.name));
+#endif
+
+	if (driver->ops.scan) {
+		driver->ops.scan(device);
+	}
+
+	return_VALUE(0);
+}
+
+
+/**
+ * acpi_bus_attach 
+ * -------------
+ * Callback for acpi_bus_walk() used to find devices that match a specific 
+ * driver's criteria and then attach the driver.
+ */
+static int
+acpi_bus_attach (
+	struct acpi_device	*device, 
+	int			level, 
+	void			*data)
+{
+	int			result = 0;
+	struct acpi_driver	*driver = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_attach");
+
+	if (!device || !data)
+		return_VALUE(-EINVAL);
+
+	driver = (struct acpi_driver *) data;
+
+	if (device->driver)
+		return_VALUE(-EEXIST);
+
+	if (!device->status.present)
+		return_VALUE(-ENODEV);
+
+	result = acpi_bus_match(device, driver);
+	if (result)
+		return_VALUE(result);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found driver [%s] for device [%s]\n",
+		driver->name, device->pnp.bus_id));
+	
+	result = acpi_bus_driver_init(device, driver);
+	if (result)
+		return_VALUE(result);
+
+	down(&acpi_bus_drivers_lock);
+	++driver->references;
+	up(&acpi_bus_drivers_lock);
+
+	return_VALUE(0);
+}
+
+
+/**
+ * acpi_bus_unattach 
+ * -----------------
+ * Callback for acpi_bus_walk() used to find devices that match a specific 
+ * driver's criteria and unattach the driver.
+ */
+static int
+acpi_bus_unattach (
+	struct acpi_device	*device, 
+	int			level, 
+	void			*data)
+{
+	int			result = 0;
+	struct acpi_driver	*driver = (struct acpi_driver *) data;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_unattach");
+
+	if (!device || !driver)
+		return_VALUE(-EINVAL);
+
+	if (device->driver != driver)
+		return_VALUE(-ENOENT);
+
+	if (!driver->ops.remove)
+		return_VALUE(-ENOSYS);
+
+	result = driver->ops.remove(device, ACPI_BUS_REMOVAL_NORMAL);
+	if (result)
+		return_VALUE(result);
+
+	device->driver = NULL;
+	acpi_driver_data(device) = NULL;
+
+	down(&acpi_bus_drivers_lock);
+	driver->references--;
+	up(&acpi_bus_drivers_lock);
+
+	return_VALUE(0);
+}
+
+
+/**
+ * acpi_bus_find_driver 
+ * --------------------
+ * Parses the list of registered drivers looking for a driver applicable for
+ * the specified device.
+ */
+static int
+acpi_bus_find_driver (
+	struct acpi_device	*device)
+{
+	int			result = -ENODEV;
+	struct list_head	*entry = NULL;
+	struct acpi_driver	*driver = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_find_driver");
+
+	if (!device || device->driver)
+		return_VALUE(-EINVAL);
+
+	down(&acpi_bus_drivers_lock);
+
+	list_for_each(entry, &acpi_bus_drivers) {
+
+		driver = list_entry(entry, struct acpi_driver, node);
+
+		if (acpi_bus_match(device, driver))
+			continue;
+
+		result = acpi_bus_driver_init(device, driver);
+		if (!result)
+			++driver->references;
+
+		break;
+	}
+
+	up(&acpi_bus_drivers_lock);
+
+	return_VALUE(result);
+}
+
+
+/**
+ * acpi_bus_register_driver 
+ * ------------------------ 
+ * Registers a driver with the ACPI bus.  Searches the namespace for all
+ * devices that match the driver's criteria and binds.
+ */
+int
+acpi_bus_register_driver (
+	struct acpi_driver	*driver)
+{
+	ACPI_FUNCTION_TRACE("acpi_bus_register_driver");
+
+	if (!driver)
+		return_VALUE(-EINVAL);
+
+	if (acpi_disabled)
+		return_VALUE(-ENODEV);
+
+	down(&acpi_bus_drivers_lock);
+	list_add_tail(&driver->node, &acpi_bus_drivers);
+	up(&acpi_bus_drivers_lock);
+
+	acpi_bus_walk(acpi_root, acpi_bus_attach, 
+		WALK_DOWN, driver);
+
+	return_VALUE(driver->references);
+}
+
+
+/**
+ * acpi_bus_unregister_driver 
+ * --------------------------
+ * Unregisters a driver with the ACPI bus.  Searches the namespace for all
+ * devices that match the driver's criteria and unbinds.
+ */
+int
+acpi_bus_unregister_driver (
+	struct acpi_driver	*driver)
+{
+	ACPI_FUNCTION_TRACE("acpi_bus_unregister_driver");
+
+	if (!driver)
+		return_VALUE(-EINVAL);
+
+	acpi_bus_walk(acpi_root, acpi_bus_unattach, WALK_UP, driver);
+
+	if (driver->references)
+		return_VALUE(driver->references);
+
+	down(&acpi_bus_drivers_lock);
+	list_del(&driver->node);
+	up(&acpi_bus_drivers_lock);
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                 Device Enumeration
+   -------------------------------------------------------------------------- */
+
+static int 
+acpi_bus_get_flags (
+	struct acpi_device	*device)
+{
+	acpi_status		status = AE_OK;
+	acpi_handle		temp = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_get_flags");
+
+	/* Presence of _STA indicates 'dynamic_status' */
+	status = acpi_get_handle(device->handle, "_STA", &temp);
+	if (ACPI_SUCCESS(status))
+		device->flags.dynamic_status = 1;
+
+	/* Presence of _CID indicates 'compatible_ids' */
+	status = acpi_get_handle(device->handle, "_CID", &temp);
+	if (ACPI_SUCCESS(status))
+		device->flags.compatible_ids = 1;
+
+	/* Presence of _RMV indicates 'removable' */
+	status = acpi_get_handle(device->handle, "_RMV", &temp);
+	if (ACPI_SUCCESS(status))
+		device->flags.removable = 1;
+
+	/* Presence of _EJD|_EJ0 indicates 'ejectable' */
+	status = acpi_get_handle(device->handle, "_EJD", &temp);
+	if (ACPI_SUCCESS(status))
+		device->flags.ejectable = 1;
+	else {
+		status = acpi_get_handle(device->handle, "_EJ0", &temp);
+		if (ACPI_SUCCESS(status))
+			device->flags.ejectable = 1;
+	}
+
+	/* Presence of _LCK indicates 'lockable' */
+	status = acpi_get_handle(device->handle, "_LCK", &temp);
+	if (ACPI_SUCCESS(status))
+		device->flags.lockable = 1;
+
+	/* Presence of _PS0|_PR0 indicates 'power manageable' */
+	status = acpi_get_handle(device->handle, "_PS0", &temp);
+	if (ACPI_FAILURE(status))
+		status = acpi_get_handle(device->handle, "_PR0", &temp);
+	if (ACPI_SUCCESS(status))
+		device->flags.power_manageable = 1;
+
+	/* TBD: Peformance management */
+
+	return_VALUE(0);
+}
+
+
+static int 
+acpi_bus_add (
+	struct acpi_device	**child,
+	struct acpi_device	*parent,
+	acpi_handle		handle,
+	int			type)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_device	*device = NULL;
+	char			bus_id[5] = {'?',0};
+	struct acpi_buffer	buffer = {0, NULL};
+	struct acpi_device_info	*info;
+	char			*hid = NULL;
+	char			*uid = NULL;
+	struct acpi_compatible_id_list *cid_list = NULL;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_add");
+
+	if (!child)
+		return_VALUE(-EINVAL);
+
+	device = kmalloc(sizeof(struct acpi_device), GFP_KERNEL);
+	if (!device) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Memory allocation error\n"));
+		return_VALUE(-ENOMEM);
+	}
+	memset(device, 0, sizeof(struct acpi_device));
+
+	device->handle = handle;
+	device->parent = parent;
+
+	/*
+	 * Bus ID
+	 * ------
+	 * The device's Bus ID is simply the object name.
+	 * TBD: Shouldn't this value be unique (within the ACPI namespace)?
+	 */
+	switch (type) {
+	case ACPI_BUS_TYPE_SYSTEM:
+		sprintf(device->pnp.bus_id, "%s", "ACPI");
+		break;
+	case ACPI_BUS_TYPE_POWER_BUTTON:
+		sprintf(device->pnp.bus_id, "%s", "PWRF");
+		break;
+	case ACPI_BUS_TYPE_SLEEP_BUTTON:
+		sprintf(device->pnp.bus_id, "%s", "SLPF");
+		break;
+	default:
+		buffer.length = sizeof(bus_id);
+		buffer.pointer = bus_id;
+		acpi_get_name(handle, ACPI_SINGLE_NAME, &buffer);
+		/* Clean up trailing underscores (if any) */
+		for (i = 3; i > 1; i--) {
+			if (bus_id[i] == '_')
+				bus_id[i] = '\0';
+			else
+				break;
+		}
+		sprintf(device->pnp.bus_id, "%s", bus_id);
+		buffer.pointer = NULL;
+		break;
+	}
+
+	/*
+	 * Flags
+	 * -----
+	 * Get prior to calling acpi_bus_get_status() so we know whether
+	 * or not _STA is present.  Note that we only look for object
+	 * handles -- cannot evaluate objects until we know the device is
+	 * present and properly initialized.
+	 */
+	result = acpi_bus_get_flags(device);
+	if (result)
+		goto end;
+
+	/*
+	 * Status
+	 * ------
+	 * See if the device is present.  We always assume that non-Device()
+	 * objects (e.g. thermal zones, power resources, processors, etc.) are
+	 * present, functioning, etc. (at least when parent object is present).
+	 * Note that _STA has a different meaning for some objects (e.g.
+	 * power resources) so we need to be careful how we use it.
+	 */
+	switch (type) {
+	case ACPI_BUS_TYPE_DEVICE:
+		result = acpi_bus_get_status(device);
+		if (!result)
+			break;
+		if (!device->status.present)
+			result = -ENOENT;
+		goto end;
+	default:
+		STRUCT_TO_INT(device->status) = 0x0F;
+		break;
+	}
+
+	/*
+	 * Initialize Device
+	 * -----------------
+	 * TBD: Synch with Core's enumeration/initialization process.
+	 */
+
+	/*
+	 * Hardware ID, Unique ID, & Bus Address
+	 * -------------------------------------
+	 */
+	switch (type) {
+	case ACPI_BUS_TYPE_DEVICE:
+		buffer.length = ACPI_ALLOCATE_BUFFER;
+		buffer.pointer = NULL;
+		status = acpi_get_object_info(handle, &buffer);
+		if (ACPI_FAILURE(status)) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				"Error reading device info\n"));
+			result = -ENODEV;
+			goto end;
+		}
+		info = buffer.pointer;
+		if (info->valid & ACPI_VALID_HID)
+			hid = info->hardware_id.value;
+		if (info->valid & ACPI_VALID_UID)
+			uid = info->unique_id.value;
+		if (info->valid & ACPI_VALID_CID) {
+			cid_list = &info->compatibility_id;
+			device->pnp.cid_list = kmalloc(cid_list->size, GFP_KERNEL);
+			if (device->pnp.cid_list)
+				memcpy(device->pnp.cid_list, cid_list, cid_list->size);
+			else
+				ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Memory allocation error\n"));
+		}
+		if (info->valid & ACPI_VALID_ADR) {
+			device->pnp.bus_address = info->address;
+			device->flags.bus_address = 1;
+		}
+		break;
+	case ACPI_BUS_TYPE_POWER:
+		hid = ACPI_POWER_HID;
+		break;
+	case ACPI_BUS_TYPE_PROCESSOR:
+		hid = ACPI_PROCESSOR_HID;
+		break;
+	case ACPI_BUS_TYPE_SYSTEM:
+		hid = ACPI_SYSTEM_HID;
+		break;
+	case ACPI_BUS_TYPE_THERMAL:
+		hid = ACPI_THERMAL_HID;
+		break;
+	case ACPI_BUS_TYPE_POWER_BUTTON:
+		hid = ACPI_BUTTON_HID_POWERF;
+		break;
+	case ACPI_BUS_TYPE_SLEEP_BUTTON:
+		hid = ACPI_BUTTON_HID_SLEEPF;
+		break;
+	}
+
+	/* 
+	 * \_SB
+	 * ----
+	 * Fix for the system root bus device -- the only root-level device.
+	 */
+	if ((parent == ACPI_ROOT_OBJECT) && (type == ACPI_BUS_TYPE_DEVICE)) {
+		hid = ACPI_BUS_HID;
+		sprintf(device->pnp.device_name, "%s", ACPI_BUS_DEVICE_NAME);
+		sprintf(device->pnp.device_class, "%s", ACPI_BUS_CLASS);
+	}
+
+	if (hid) {
+		sprintf(device->pnp.hardware_id, "%s", hid);
+		device->flags.hardware_id = 1;
+	}
+	if (uid) {
+		sprintf(device->pnp.unique_id, "%s", uid);
+		device->flags.unique_id = 1;
+	}
+
+	/*
+	 * If we called get_object_info, we now are finished with the buffer,
+	 * so we can free it.
+	 */
+	if (buffer.pointer)
+		acpi_os_free(buffer.pointer);
+
+	/*
+	 * Power Management
+	 * ----------------
+	 */
+	if (device->flags.power_manageable) {
+		result = acpi_bus_get_power_flags(device);
+		if (result)
+			goto end;
+	}
+
+	/*
+	 * Performance Management
+	 * ----------------------
+	 */
+	if (device->flags.performance_manageable) {
+		result = acpi_bus_get_perf_flags(device);
+		if (result)
+			goto end;
+	}
+
+	/*
+	 * Context
+	 * -------
+	 * Attach this 'struct acpi_device' to the ACPI object.  This makes
+	 * resolutions from handle->device very efficient.  Note that we need
+	 * to be careful with fixed-feature devices as they all attach to the
+	 * root object.
+	 */
+	switch (type) {
+	case ACPI_BUS_TYPE_POWER_BUTTON:
+	case ACPI_BUS_TYPE_SLEEP_BUTTON:
+		break;
+	default:
+		status = acpi_attach_data(device->handle,
+			acpi_bus_data_handler, device);
+		break;
+	}
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error attaching device data\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	/*
+	 * Linkage
+	 * -------
+	 * Link this device to its parent and siblings.
+	 */
+	INIT_LIST_HEAD(&device->children);
+	if (!device->parent)
+		INIT_LIST_HEAD(&device->node);
+	else
+		list_add_tail(&device->node, &device->parent->children);
+
+#ifdef CONFIG_ACPI_DEBUG
+	{
+		char			*type_string = NULL;
+		char			name[80] = {'?','\0'};
+		struct acpi_buffer	buffer = {sizeof(name), name};
+
+		acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
+
+		switch (type) {
+		case ACPI_BUS_TYPE_DEVICE:
+			type_string = "Device";
+			break;
+		case ACPI_BUS_TYPE_POWER:
+			type_string = "Power Resource";
+			break;
+		case ACPI_BUS_TYPE_PROCESSOR:
+			type_string = "Processor";
+			break;
+		case ACPI_BUS_TYPE_SYSTEM:
+			type_string = "System";
+			break;
+		case ACPI_BUS_TYPE_THERMAL:
+			type_string = "Thermal Zone";
+			break;
+		case ACPI_BUS_TYPE_POWER_BUTTON:
+			type_string = "Power Button";
+			sprintf(name, "PWRB");
+			break;
+		case ACPI_BUS_TYPE_SLEEP_BUTTON:
+			type_string = "Sleep Button";
+			sprintf(name, "SLPB");
+			break;
+		}
+
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %s %s [%p]\n", 
+			type_string, name, handle));
+	}
+#endif /*CONFIG_ACPI_DEBUG*/
+
+	/*
+	 * Global Device Hierarchy:
+	 * ------------------------
+	 * Register this device with the global device hierarchy.
+	 */
+	acpi_device_register(device, parent);
+
+	/*
+	 * Bind _ADR-Based Devices
+	 * -----------------------
+	 * If there's a a bus address (_ADR) then we utilize the parent's 
+	 * 'bind' function (if exists) to bind the ACPI- and natively-
+	 * enumerated device representations.
+	 */
+	if (device->flags.bus_address) {
+		if (device->parent && device->parent->ops.bind)
+			device->parent->ops.bind(device);
+	}
+
+	/*
+	 * Locate & Attach Driver
+	 * ----------------------
+	 * If there's a hardware id (_HID) or compatible ids (_CID) we check
+	 * to see if there's a driver installed for this kind of device.  Note
+	 * that drivers can install before or after a device is enumerated.
+	 *
+	 * TBD: Assumes LDM provides driver hot-plug capability.
+	 */
+	if (device->flags.hardware_id || device->flags.compatible_ids)
+		acpi_bus_find_driver(device);
+
+end:
+	if (result) {
+		if (device->pnp.cid_list) {
+			kfree(device->pnp.cid_list);
+		}
+		kfree(device);
+		return_VALUE(result);
+	}
+	*child = device;
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_bus_remove (
+	struct acpi_device	*device, 
+	int			type)
+{
+	ACPI_FUNCTION_TRACE("acpi_bus_remove");
+
+	if (!device)
+		return_VALUE(-ENODEV);
+
+	acpi_device_unregister(device);
+
+#if 0
+	if (device->pnp.cid_list)
+		kfree(device->pnp.cid_list);
+#endif
+	kfree(device);
+
+	return_VALUE(0);
+}
+
+
+int
+acpi_bus_scan (
+	struct acpi_device	*start)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_device	*parent = NULL;
+	struct acpi_device	*child = NULL;
+	acpi_handle		phandle = 0;
+	acpi_handle		chandle = 0;
+	acpi_object_type	type = 0;
+	u32			level = 1;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_scan");
+
+	if (!start)
+		return_VALUE(-EINVAL);
+
+	parent = start;
+	phandle = start->handle;
+	
+	/*
+	 * Parse through the ACPI namespace, identify all 'devices', and
+	 * create a new 'struct acpi_device' for each.
+	 */
+	while ((level > 0) && parent) {
+
+		status = acpi_get_next_object(ACPI_TYPE_ANY, phandle,
+			chandle, &chandle);
+
+		/*
+		 * If this scope is exhausted then move our way back up.
+		 */
+		if (ACPI_FAILURE(status)) {
+			level--;
+			chandle = phandle;
+			acpi_get_parent(phandle, &phandle);
+			if (parent->parent)
+				parent = parent->parent;
+			continue;
+		}
+
+		status = acpi_get_type(chandle, &type);
+		if (ACPI_FAILURE(status))
+			continue;
+
+		/*
+		 * If this is a scope object then parse it (depth-first).
+		 */
+		if (type == ACPI_TYPE_LOCAL_SCOPE) {
+			level++;
+			phandle = chandle;
+			chandle = 0;
+			continue;
+		}
+
+		/*
+		 * We're only interested in objects that we consider 'devices'.
+		 */
+		switch (type) {
+		case ACPI_TYPE_DEVICE:
+			type = ACPI_BUS_TYPE_DEVICE;
+			break;
+		case ACPI_TYPE_PROCESSOR:
+			type = ACPI_BUS_TYPE_PROCESSOR;
+			break;
+		case ACPI_TYPE_THERMAL:
+			type = ACPI_BUS_TYPE_THERMAL;
+			break;
+		case ACPI_TYPE_POWER:
+			type = ACPI_BUS_TYPE_POWER;
+			break;
+		default:
+			continue;
+		}
+
+		status = acpi_bus_add(&child, parent, chandle, type);
+		if (ACPI_FAILURE(status))
+			continue;
+
+		/*
+		 * If the device is present, enabled, and functioning then
+		 * parse its scope (depth-first).  Note that we need to
+		 * represent absent devices to facilitate PnP notifications
+		 * -- but only the subtree head (not all of its children,
+		 * which will be enumerated when the parent is inserted).
+		 *
+		 * TBD: Need notifications and other detection mechanisms
+		 *	in place before we can fully implement this.
+		 */
+		if (child->status.present) {
+			status = acpi_get_next_object(ACPI_TYPE_ANY, chandle,
+				0, NULL);
+			if (ACPI_SUCCESS(status)) {
+				level++;
+				phandle = chandle;
+				chandle = 0;
+				parent = child;
+			}
+		}
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_bus_scan_fixed (
+	struct acpi_device	*root)
+{
+	int			result = 0;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_scan_fixed");
+
+	if (!root)
+		return_VALUE(-ENODEV);
+
+	/*
+	 * Enumerate all fixed-feature devices.
+	 */
+	if (acpi_fadt.pwr_button == 0)
+		result = acpi_bus_add(&device, acpi_root, 
+			NULL, ACPI_BUS_TYPE_POWER_BUTTON);
+
+	if (acpi_fadt.sleep_button == 0)
+		result = acpi_bus_add(&device, acpi_root, 
+			NULL, ACPI_BUS_TYPE_SLEEP_BUTTON);
+
+	return_VALUE(result);
+}
+
+
+/* --------------------------------------------------------------------------
+                             Initialization/Cleanup
+   -------------------------------------------------------------------------- */
+
+static int __init
+acpi_bus_init_irq (void)
+{
+	acpi_status		status = AE_OK;
+	union acpi_object	arg = {ACPI_TYPE_INTEGER};
+	struct acpi_object_list	arg_list = {1, &arg};
+	char			*message = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_init_irq");
+
+	/* 
+	 * Let the system know what interrupt model we are using by
+	 * evaluating the \_PIC object, if exists.
+	 */
+
+	switch (acpi_irq_model) {
+	case ACPI_IRQ_MODEL_PIC:
+		message = "PIC";
+		break;
+	case ACPI_IRQ_MODEL_IOAPIC:
+		message = "IOAPIC";
+		break;
+	case ACPI_IRQ_MODEL_IOSAPIC:
+		message = "IOSAPIC";
+		break;
+	default:
+		printk(KERN_WARNING PREFIX "Unknown interrupt routing model\n");
+		return_VALUE(-ENODEV);
+	}
+
+	printk(KERN_INFO PREFIX "Using %s for interrupt routing\n", message);
+
+	arg.integer.value = acpi_irq_model;
+
+	status = acpi_evaluate_object(NULL, "\\_PIC", &arg_list, NULL);
+	if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PIC\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+
+#ifdef CONFIG_X86_64
+void
+acpi_machine_reset(void)
+{
+	acpi_status status;
+	FADT_DESCRIPTOR *f = &acpi_fadt;
+
+	if (f->reset_register.register_bit_width != 8) {
+		printk(KERN_WARNING PREFIX "invalid reset register bit width: 0x%x\n", f->reset_register.register_bit_width);
+		return_VOID;
+	}
+
+	if (f->reset_register.register_bit_offset != 0) {
+		printk(KERN_WARNING PREFIX "invalid reset register bit offset: 0x%x\n", f->reset_register.register_bit_offset);
+		return_VOID;
+	}
+
+	if ((f->reset_register.address_space_id != ACPI_ADR_SPACE_SYSTEM_IO) &&
+	    (f->reset_register.address_space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY) &&
+	    (f->reset_register.address_space_id != ACPI_ADR_SPACE_PCI_CONFIG)) {
+		printk(KERN_WARNING PREFIX "invalid reset register address space id: 0x%x\n", f->reset_register.address_space_id);
+		return_VOID;
+	}
+
+	status = acpi_hw_low_level_write(f->reset_register.register_bit_width, f->reset_value, &f->reset_register);
+
+	if (status != AE_OK)
+		printk(KERN_WARNING "ACPI system reset failed 0x%x\n", status);
+}
+#endif
+
+static int __init
+acpi_bus_init (void)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_buffer	buffer = {sizeof(acpi_fadt), &acpi_fadt};
+
+	ACPI_FUNCTION_TRACE("acpi_bus_init");
+
+	status = acpi_initialize_subsystem();
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX "Unable to initialize the ACPI Interpreter\n");
+		goto error0;
+	}
+
+	status = acpi_load_tables();
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX "Unable to load the System Description Tables\n");
+		goto error0;
+	}
+
+	/*
+	 * Get a separate copy of the FADT for use by other drivers.
+	 */
+	status = acpi_get_table(ACPI_TABLE_FADT, 1, &buffer);
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX "Unable to get the FADT\n");
+		goto error1;
+	}
+
+#ifdef CONFIG_X86
+        /* Ensure the SCI is set to level-triggered, active-low */
+	if (acpi_ioapic) {
+		extern int acpi_sci_override_gsi;
+		/*
+		 * now that acpi_fadt is initialized,
+		 * update it with result from INT_SRC_OVR parsing
+		 */
+		acpi_fadt.sci_int = acpi_sci_override_gsi;
+	} else
+                eisa_set_level_irq(acpi_fadt.sci_int);
+#endif
+
+	/*
+	 * Set up system reset via ACPI, if defined correctly in FADT and
+         * the hardware doesn't include an 8042 KBD controller.
+	 */
+#ifdef CONFIG_X86_64
+	if (acpi_fadt.header.revision >= 2) {
+		if (acpi_fadt.reset_reg_sup) {
+			printk(KERN_INFO PREFIX "System reset via FADT Reset Register supported.\n");
+			if (!(acpi_fadt.iapc_boot_arch & BAF_8042_KEYBOARD_CONTROLLER))
+				machine_reset = acpi_machine_reset;
+		}
+	}
+#endif
+
+	status = acpi_enable_subsystem(ACPI_FULL_INITIALIZATION);
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX "Unable to start the ACPI Interpreter\n");
+		goto error1;
+	}
+
+#ifdef CONFIG_ACPI_EC
+	/*
+	 * ACPI 2.0 requires the EC driver to be loaded and work before
+	 * the EC device is found in the namespace. This is accomplished
+	 * by looking for the ECDT table, and getting the EC parameters out
+	 * of that.
+	 */
+	result = acpi_ec_ecdt_probe();
+	if (result) {
+		goto error1;
+	}
+#endif
+
+	status = acpi_initialize_objects(ACPI_FULL_INITIALIZATION);
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX "Unable to initialize ACPI objects\n");
+		goto error1;
+	}
+
+	printk(KERN_INFO PREFIX "Interpreter enabled\n");
+
+	/*
+	 * Get the system interrupt model and evaluate \_PIC.
+	 */
+	result = acpi_bus_init_irq();
+	if (result)
+		goto error1;
+
+	/*
+	 * Register the for all standard device notifications.
+	 */
+	status = acpi_install_notify_handler(ACPI_ROOT_OBJECT, ACPI_SYSTEM_NOTIFY, &acpi_bus_notify, NULL);
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX "Unable to register for device notifications\n");
+		result = -ENODEV;
+		goto error1;
+	}
+
+	/*
+	 * Create the root device in the bus's device tree
+	 */
+	result = acpi_bus_add(&acpi_root, NULL, ACPI_ROOT_OBJECT, 
+		ACPI_BUS_TYPE_SYSTEM);
+	if (result)
+		goto error2;
+
+	/*
+	 * Create the top ACPI proc directory
+	 */
+	acpi_device_dir(acpi_root) = proc_mkdir(ACPI_BUS_FILE_ROOT, NULL);
+	if (!acpi_root) {
+		result = -ENODEV;
+		goto error3;
+	}
+	acpi_root_dir = acpi_device_dir(acpi_root);
+
+	/*
+	 * Install drivers required for proper enumeration of the
+	 * ACPI namespace.
+	 */
+	acpi_system_init();	/* ACPI System */
+	acpi_power_init();	/* ACPI Bus Power Management */
+#ifdef CONFIG_ACPI_EC
+	acpi_ec_init();		/* ACPI Embedded Controller */
+#endif
+#ifdef CONFIG_ACPI_PCI
+	acpi_pci_link_init();	/* ACPI PCI Interrupt Link */
+	acpi_pci_root_init();	/* ACPI PCI Root Bridge */
+#endif
+	/*
+	 * Enumerate devices in the ACPI namespace.
+	 */
+	result = acpi_bus_scan_fixed(acpi_root);
+	if (result)
+		goto error4;
+	result = acpi_bus_scan(acpi_root);
+	if (result)
+		goto error4;
+
+	return_VALUE(0);
+
+	/* Mimic structured exception handling */
+error4:
+	remove_proc_entry(ACPI_BUS_FILE_ROOT, NULL);
+error3:
+	acpi_bus_remove(acpi_root, ACPI_BUS_REMOVAL_NORMAL);
+error2:
+	acpi_remove_notify_handler(ACPI_ROOT_OBJECT,
+		ACPI_SYSTEM_NOTIFY, &acpi_bus_notify);
+error1:
+	acpi_terminate();
+error0:
+	return_VALUE(-ENODEV);
+}
+
+
+static void __exit
+acpi_bus_exit (void)
+{
+	acpi_status		status = AE_OK;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_exit");
+
+	status = acpi_remove_notify_handler(ACPI_ROOT_OBJECT,
+		ACPI_SYSTEM_NOTIFY, acpi_bus_notify);
+	if (ACPI_FAILURE(status))
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error removing notify handler\n"));
+
+#ifdef CONFIG_ACPI_PCI
+	acpi_pci_root_exit();
+	acpi_pci_link_exit();
+#endif
+#ifdef CONFIG_ACPI_EC
+	acpi_ec_exit();
+#endif
+	acpi_power_exit();
+	acpi_system_exit();
+
+	acpi_bus_remove(acpi_root, ACPI_BUS_REMOVAL_NORMAL);
+
+	remove_proc_entry(ACPI_BUS_FILE_ROOT, NULL);
+
+	status = acpi_terminate();
+	if (ACPI_FAILURE(status))
+		printk(KERN_ERR PREFIX "Unable to terminate the ACPI Interpreter\n");
+	else
+		printk(KERN_ERR PREFIX "Interpreter disabled\n");
+
+	return_VOID;
+}
+
+
+int __init
+acpi_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_init");
+
+	printk(KERN_INFO PREFIX "Subsystem revision %08x\n",
+		ACPI_CA_VERSION);
+
+	/* Initial core debug level excludes drivers, so include them now */
+	acpi_set_debug(ACPI_DEBUG_LOW);
+
+	if (acpi_disabled) {
+		printk(KERN_INFO PREFIX "Disabled via command line (acpi=off)\n");
+		return -ENODEV;
+	}
+
+#ifdef CONFIG_PM
+	if (PM_IS_ACTIVE()) {
+		printk(KERN_INFO PREFIX "APM is already active, exiting\n");
+		return -ENODEV;
+	}
+#endif
+
+	result = acpi_bus_init();
+	if (result)
+		return_VALUE(result);
+
+#ifdef CONFIG_PM
+	pm_active = 1;
+#endif
+
+	return_VALUE(0);
+}
+
+
+void __exit
+acpi_exit (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_exit");
+
+#ifdef CONFIG_PM
+	pm_active = 0;
+#endif
+
+	acpi_bus_exit();
+
+	return_VOID;
+}
+
+
+int __init
+acpi_setup(char *str)
+{
+	while (str && *str) {
+		if (strncmp(str, "off", 3) == 0)
+			acpi_disabled = 1;
+		str = strchr(str, ',');
+		if (str)
+			str += strspn(str, ", \t");
+	}
+	return 1;
+}
+
+
+__setup("acpi=", acpi_setup);
diff -urNp linux-5400/drivers/acpi/button.c linux-5410/drivers/acpi/button.c
--- linux-5400/drivers/acpi/button.c
+++ linux-5410/drivers/acpi/button.c
@@ -0,0 +1,498 @@
+/*
+ *  acpi_button.c - ACPI Button Driver ($Revision: 29 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/compatmac.h>
+#include <linux/proc_fs.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+
+#define _COMPONENT		ACPI_BUTTON_COMPONENT
+ACPI_MODULE_NAME		("acpi_button")
+
+MODULE_AUTHOR("Paul Diefenbaugh");
+MODULE_DESCRIPTION(ACPI_BUTTON_DRIVER_NAME);
+MODULE_LICENSE("GPL");
+
+#define PREFIX			"ACPI: "
+
+
+static int acpi_button_add (struct acpi_device *device);
+static int acpi_button_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_button_driver = {
+	.name =		ACPI_BUTTON_DRIVER_NAME,
+	.class =	ACPI_BUTTON_CLASS,
+	.ids =		"ACPI_FPB,ACPI_FSB,PNP0C0D,PNP0C0C,PNP0C0E",
+	.ops =		{
+				.add =		acpi_button_add,
+				.remove =	acpi_button_remove,
+			},
+};
+
+struct acpi_button {
+	acpi_handle		handle;
+	struct acpi_device	*device;	/* Fixed button kludge */
+	u8			type;
+	unsigned long		pushed;
+};
+
+
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+static struct proc_dir_entry	*acpi_button_dir = NULL;
+
+static int
+acpi_button_read_info (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_button	*button = (struct acpi_button *) data;
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_button_read_info");
+
+	if (!button || !button->device)
+		goto end;
+
+	p += sprintf(p, "type:                    %s\n", 
+		acpi_device_name(button->device));
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+static int
+acpi_button_lid_read_state(
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_button	*button = (struct acpi_button *) data;
+	char			*p = page;
+	int			len = 0;
+	acpi_status		status=AE_OK;
+	unsigned long		state;
+
+	ACPI_FUNCTION_TRACE("acpi_button_lid_read_state");
+
+	if (!button || !button->device)
+		goto end;
+
+	status=acpi_evaluate_integer(button->handle,"_LID",NULL,&state);
+	if (ACPI_FAILURE(status)){
+	    p += sprintf(p, "state:      unsupported\n");
+	}
+	else{
+	    p += sprintf(p, "state:      %s\n", (state ? "open" : "closed")); 
+	}
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+static int
+acpi_button_add_fs (
+	struct acpi_device	*device)
+{
+	struct proc_dir_entry	*entry = NULL;
+	struct acpi_button	*button = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_button_add_fs");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	button = acpi_driver_data(device);
+
+	switch (button->type) {
+	case ACPI_BUTTON_TYPE_POWER:
+	case ACPI_BUTTON_TYPE_POWERF:
+			entry = proc_mkdir(ACPI_BUTTON_SUBCLASS_POWER, 
+				acpi_button_dir);
+		break;
+	case ACPI_BUTTON_TYPE_SLEEP:
+	case ACPI_BUTTON_TYPE_SLEEPF:
+			entry = proc_mkdir(ACPI_BUTTON_SUBCLASS_SLEEP, 
+				acpi_button_dir);
+		break;
+	case ACPI_BUTTON_TYPE_LID:
+			entry = proc_mkdir(ACPI_BUTTON_SUBCLASS_LID, 
+				acpi_button_dir);
+		break;
+	}
+
+	acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device), entry);
+	if (!acpi_device_dir(device))
+		return_VALUE(-ENODEV);
+
+	/* 'info' [R] */
+	entry = create_proc_entry(ACPI_BUTTON_FILE_INFO,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_BUTTON_FILE_INFO));
+	else {
+		entry->read_proc = acpi_button_read_info;
+		entry->data = acpi_driver_data(device);
+	}
+	
+	if (button->type==ACPI_BUTTON_TYPE_LID){
+	    /* 'state' [R] */
+	    entry = create_proc_entry(ACPI_BUTTON_FILE_STATE,
+			S_IRUGO, acpi_device_dir(device));
+	    if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			  "Unable to create '%s' fs entry\n",
+			   ACPI_BUTTON_FILE_STATE));
+	    else {
+		entry->read_proc = acpi_button_lid_read_state;
+		entry->data = acpi_driver_data(device);
+	    }
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_button_remove_fs (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_button_remove_fs");
+
+	if (acpi_device_dir(device)) {
+		remove_proc_entry(acpi_device_bid(device), acpi_button_dir);
+		acpi_device_dir(device) = NULL;
+	}
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                Driver Interface
+   -------------------------------------------------------------------------- */
+
+void
+acpi_button_notify (
+	acpi_handle		handle,
+	u32			event,
+	void			*data)
+{
+	struct acpi_button	*button = (struct acpi_button *) data;
+
+	ACPI_FUNCTION_TRACE("acpi_button_notify");
+
+	if (!button || !button->device)
+		return_VOID;
+
+	switch (event) {
+	case ACPI_BUTTON_NOTIFY_STATUS:
+		acpi_bus_generate_event(button->device, event, ++button->pushed);
+		break;
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Unsupported event [0x%x]\n", event));
+		break;
+	}
+
+	return_VOID;
+}
+
+
+acpi_status
+acpi_button_notify_fixed (
+	void			*data)
+{
+	struct acpi_button	*button = (struct acpi_button *) data;
+	
+	ACPI_FUNCTION_TRACE("acpi_button_notify_fixed");
+
+	if (!button)
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+
+	acpi_button_notify(button->handle, ACPI_BUTTON_NOTIFY_STATUS, button);
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+
+static int
+acpi_button_add (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_button	*button = NULL;
+
+	static struct acpi_device *power_button;
+	static struct acpi_device *sleep_button;
+	static struct acpi_device *lid_button;
+
+	ACPI_FUNCTION_TRACE("acpi_button_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	button = kmalloc(sizeof(struct acpi_button), GFP_KERNEL);
+	if (!button)
+		return_VALUE(-ENOMEM);
+	memset(button, 0, sizeof(struct acpi_button));
+
+	button->device = device;
+	button->handle = device->handle;
+	acpi_driver_data(device) = button;
+
+	/*
+	 * Determine the button type (via hid), as fixed-feature buttons
+	 * need to be handled a bit differently than generic-space.
+	 */
+	if (!strcmp(acpi_device_hid(device), ACPI_BUTTON_HID_POWER)) {
+		button->type = ACPI_BUTTON_TYPE_POWER;
+		sprintf(acpi_device_name(device), "%s",
+			ACPI_BUTTON_DEVICE_NAME_POWER);
+		sprintf(acpi_device_class(device), "%s/%s", 
+			ACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_POWER);
+	}
+	else if (!strcmp(acpi_device_hid(device), ACPI_BUTTON_HID_POWERF)) {
+		button->type = ACPI_BUTTON_TYPE_POWERF;
+		sprintf(acpi_device_name(device), "%s",
+			ACPI_BUTTON_DEVICE_NAME_POWERF);
+		sprintf(acpi_device_class(device), "%s/%s", 
+			ACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_POWER);
+	}
+	else if (!strcmp(acpi_device_hid(device), ACPI_BUTTON_HID_SLEEP)) {
+		button->type = ACPI_BUTTON_TYPE_SLEEP;
+		sprintf(acpi_device_name(device), "%s",
+			ACPI_BUTTON_DEVICE_NAME_SLEEP);
+		sprintf(acpi_device_class(device), "%s/%s", 
+			ACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_SLEEP);
+	}
+	else if (!strcmp(acpi_device_hid(device), ACPI_BUTTON_HID_SLEEPF)) {
+		button->type = ACPI_BUTTON_TYPE_SLEEPF;
+		sprintf(acpi_device_name(device), "%s",
+			ACPI_BUTTON_DEVICE_NAME_SLEEPF);
+		sprintf(acpi_device_class(device), "%s/%s", 
+			ACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_SLEEP);
+	}
+	else if (!strcmp(acpi_device_hid(device), ACPI_BUTTON_HID_LID)) {
+		button->type = ACPI_BUTTON_TYPE_LID;
+		sprintf(acpi_device_name(device), "%s",
+			ACPI_BUTTON_DEVICE_NAME_LID);
+		sprintf(acpi_device_class(device), "%s/%s", 
+			ACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_LID);
+	}
+	else {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unsupported hid [%s]\n",
+			acpi_device_hid(device)));
+		result = -ENODEV;
+		goto end;
+	}
+
+	/*
+	 * Ensure only one button of each type is used.
+	 */
+	switch (button->type) {
+	case ACPI_BUTTON_TYPE_POWER:
+	case ACPI_BUTTON_TYPE_POWERF:
+		if (!power_button)
+			power_button = device;
+		else {
+			kfree(button);
+			return_VALUE(-ENODEV);
+		}
+		break;
+	case ACPI_BUTTON_TYPE_SLEEP:
+	case ACPI_BUTTON_TYPE_SLEEPF:
+		if (!sleep_button)
+			sleep_button = device;
+		else {
+			kfree(button);
+			return_VALUE(-ENODEV);
+		}
+		break;
+	case ACPI_BUTTON_TYPE_LID:
+		if (!lid_button)
+			lid_button = device;
+		else {
+			kfree(button);
+			return_VALUE(-ENODEV);
+		}
+		break;
+	}
+
+	result = acpi_button_add_fs(device);
+	if (result)
+		goto end;
+
+	switch (button->type) {
+	case ACPI_BUTTON_TYPE_POWERF:
+		status = acpi_install_fixed_event_handler (
+			ACPI_EVENT_POWER_BUTTON,
+			acpi_button_notify_fixed,
+			button);
+		break;
+	case ACPI_BUTTON_TYPE_SLEEPF:
+		status = acpi_install_fixed_event_handler (
+			ACPI_EVENT_SLEEP_BUTTON,
+			acpi_button_notify_fixed,
+			button);
+		break;
+	default:
+		status = acpi_install_notify_handler (
+			button->handle,
+			ACPI_DEVICE_NOTIFY,
+			acpi_button_notify,
+			button);
+		break;
+	}
+
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error installing notify handler\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	printk(KERN_INFO PREFIX "%s [%s]\n", 
+		acpi_device_name(device), acpi_device_bid(device));
+
+end:
+	if (result) {
+		acpi_button_remove_fs(device);
+		kfree(button);
+	}
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_button_remove (struct acpi_device *device, int type)
+{
+	acpi_status		status = 0;
+	struct acpi_button	*button = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_button_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	button = acpi_driver_data(device);
+
+	/* Unregister for device notifications. */
+	switch (button->type) {
+	case ACPI_BUTTON_TYPE_POWERF:
+		status = acpi_remove_fixed_event_handler(
+			ACPI_EVENT_POWER_BUTTON, acpi_button_notify_fixed);
+		break;
+	case ACPI_BUTTON_TYPE_SLEEPF:
+		status = acpi_remove_fixed_event_handler(
+			ACPI_EVENT_SLEEP_BUTTON, acpi_button_notify_fixed);
+		break;
+	default:
+		status = acpi_remove_notify_handler(button->handle,
+			ACPI_DEVICE_NOTIFY, acpi_button_notify);
+		break;
+	}
+
+	if (ACPI_FAILURE(status))
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error removing notify handler\n"));
+
+	acpi_button_remove_fs(device);	
+
+	kfree(button);
+
+	return_VALUE(0);
+}
+
+
+static int __init
+acpi_button_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_button_init");
+
+	acpi_button_dir = proc_mkdir(ACPI_BUTTON_CLASS, acpi_root_dir);
+	if (!acpi_button_dir)
+		return_VALUE(-ENODEV);
+
+	result = acpi_bus_register_driver(&acpi_button_driver);
+	if (result < 0) {
+		remove_proc_entry(ACPI_BUTTON_CLASS, acpi_root_dir);
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+
+
+static void __exit
+acpi_button_exit (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_button_exit");
+
+	acpi_bus_unregister_driver(&acpi_button_driver);
+
+	remove_proc_entry(ACPI_BUTTON_CLASS, acpi_root_dir);
+
+	return_VOID;
+}
+
+
+module_init(acpi_button_init);
+module_exit(acpi_button_exit);
diff -urNp linux-5400/drivers/acpi/debugger/Makefile linux-5410/drivers/acpi/debugger/Makefile
--- linux-5400/drivers/acpi/debugger/Makefile
+++ linux-5410/drivers/acpi/debugger/Makefile
@@ -1,12 +0,0 @@
-#
-# Makefile for all Linux ACPI interpreter subdirectories
-# EXCEPT for the ospm directory
-#
-
-O_TARGET := $(notdir $(CURDIR)).o
-
-obj-$(CONFIG_ACPI) := $(patsubst %.c,%.o,$(wildcard *.c))
-
-EXTRA_CFLAGS += $(ACPI_CFLAGS)
-
-include $(TOPDIR)/Rules.make
diff -urNp linux-5400/drivers/acpi/debugger/dbcmds.c linux-5410/drivers/acpi/debugger/dbcmds.c
--- linux-5400/drivers/acpi/debugger/dbcmds.c
+++ linux-5410/drivers/acpi/debugger/dbcmds.c
@@ -1,996 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: dbcmds - debug commands and output routines
- *              $Revision: 66 $
- *
- ******************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include "acpi.h"
-#include "acparser.h"
-#include "acdispat.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "acparser.h"
-#include "acevents.h"
-#include "acinterp.h"
-#include "acdebug.h"
-#include "actables.h"
-#include "acresrc.h"
-
-#ifdef ENABLE_DEBUGGER
-
-#define _COMPONENT          ACPI_DEBUGGER
-	 MODULE_NAME         ("dbcmds")
-
-
-/*
- * Arguments for the Objects command
- * These object types map directly to the ACPI_TYPES
- */
-
-ARGUMENT_INFO         acpi_db_object_types [] =
-{ {"ANY"},
-	{"NUMBERS"},
-	{"STRINGS"},
-	{"BUFFERS"},
-	{"PACKAGES"},
-	{"FIELDS"},
-	{"DEVICES"},
-	{"EVENTS"},
-	{"METHODS"},
-	{"MUTEXES"},
-	{"REGIONS"},
-	{"POWERRESOURCES"},
-	{"PROCESSORS"},
-	{"THERMALZONES"},
-	{"BUFFERFIELDS"},
-	{"DDBHANDLES"},
-	{NULL}           /* Must be null terminated */
-};
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_walk_for_references
- *
- * PARAMETERS:  Callback from Walk_namespace
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Check if this namespace object refers to the target object
- *              that is passed in as the context value.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_db_walk_for_references (
-	acpi_handle             obj_handle,
-	u32                     nesting_level,
-	void                    *context,
-	void                    **return_value)
-{
-	acpi_operand_object     *obj_desc = (acpi_operand_object *) context;
-	acpi_namespace_node     *node = (acpi_namespace_node *) obj_handle;
-
-
-	/* Check for match against the namespace node itself */
-
-	if (node == (void *) obj_desc) {
-		acpi_os_printf ("Object is a Node [%4.4s]\n", &node->name);
-	}
-
-	/* Check for match against the object attached to the node */
-
-	if (node->object == obj_desc) {
-		acpi_os_printf ("Reference at Node->Object %p [%4.4s]\n", node, &node->name);
-	}
-
-	/* Check first child for a match */
-	/* TBD: [Investigate] probably now obsolete with new datastructure */
-
-	if (node->child == (void *) obj_desc) {
-		acpi_os_printf ("Reference at Node->Child %p [%4.4s]\n", node, &node->name);
-	}
-
-	return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_find_references
- *
- * PARAMETERS:  Object_arg      - String with hex value of the object
- *
- * RETURN:      None
- *
- * DESCRIPTION: Search namespace for all references to the input object
- *
- ******************************************************************************/
-
-void
-acpi_db_find_references (
-	NATIVE_CHAR             *object_arg)
-{
-	acpi_operand_object     *obj_desc;
-
-
-	/* Convert string to object pointer */
-
-	obj_desc = (acpi_operand_object *) STRTOUL (object_arg, NULL, 16);
-
-	/* Search all nodes in namespace */
-
-	acpi_walk_namespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
-			  acpi_db_walk_for_references, (void *) obj_desc, NULL);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_display_locks
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display information about internal mutexes.
- *
- ******************************************************************************/
-
-void
-acpi_db_display_locks (void)
-{
-	u32                     i;
-
-
-	for (i = 0; i < MAX_MTX; i++) {
-		acpi_os_printf ("%26s : %s\n", acpi_ut_get_mutex_name (i),
-				 acpi_gbl_acpi_mutex_info[i].owner_id == ACPI_MUTEX_NOT_ACQUIRED
-						? "Locked" : "Unlocked");
-	}
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_display_table_info
- *
- * PARAMETERS:  Table_arg       - String with name of table to be displayed
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display information about loaded tables.  Current
- *              implementation displays all loaded tables.
- *
- ******************************************************************************/
-
-void
-acpi_db_display_table_info (
-	NATIVE_CHAR             *table_arg)
-{
-	u32                     i;
-
-
-	for (i = 0; i < NUM_ACPI_TABLES; i++) {
-		if (acpi_gbl_acpi_tables[i].pointer) {
-			acpi_os_printf ("%s at %p length %X\n", acpi_gbl_acpi_table_data[i].name,
-					 acpi_gbl_acpi_tables[i].pointer, acpi_gbl_acpi_tables[i].length);
-		}
-	}
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_unload_acpi_table
- *
- * PARAMETERS:  Table_arg       - Name of the table to be unloaded
- *              Instance_arg    - Which instance of the table to unload (if
- *                                there are multiple tables of the same type)
- *
- * RETURN:      Nonde
- *
- * DESCRIPTION: Unload an ACPI table.
- *              Instance is not implemented
- *
- ******************************************************************************/
-
-void
-acpi_db_unload_acpi_table (
-	NATIVE_CHAR             *table_arg,
-	NATIVE_CHAR             *instance_arg)
-{
-	u32                     i;
-	acpi_status             status;
-
-
-	/* Search all tables for the target type */
-
-	for (i = 0; i < NUM_ACPI_TABLES; i++) {
-		if (!STRNCMP (table_arg, acpi_gbl_acpi_table_data[i].signature,
-				acpi_gbl_acpi_table_data[i].sig_length)) {
-			/* Found the table, unload it */
-
-			status = acpi_unload_table (i);
-			if (ACPI_SUCCESS (status)) {
-				acpi_os_printf ("[%s] unloaded and uninstalled\n", table_arg);
-			}
-			else {
-				acpi_os_printf ("%s, while unloading [%s]\n",
-					acpi_format_exception (status), table_arg);
-			}
-
-			return;
-		}
-	}
-
-	acpi_os_printf ("Unknown table type [%s]\n", table_arg);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_set_method_breakpoint
- *
- * PARAMETERS:  Location            - AML offset of breakpoint
- *              Walk_state          - Current walk info
- *              Op                  - Current Op (from parse walk)
- *
- * RETURN:      None
- *
- * DESCRIPTION: Set a breakpoint in a control method at the specified
- *              AML offset
- *
- ******************************************************************************/
-
-void
-acpi_db_set_method_breakpoint (
-	NATIVE_CHAR             *location,
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op)
-{
-	u32                     address;
-
-
-	if (!op) {
-		acpi_os_printf ("There is no method currently executing\n");
-		return;
-	}
-
-	/* Get and verify the breakpoint address */
-
-	address = STRTOUL (location, NULL, 16);
-	if (address <= op->aml_offset) {
-		acpi_os_printf ("Breakpoint %X is beyond current address %X\n", address, op->aml_offset);
-	}
-
-	/* Save breakpoint in current walk */
-
-	walk_state->method_breakpoint = address;
-	acpi_os_printf ("Breakpoint set at AML offset %X\n", address);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_set_method_call_breakpoint
- *
- * PARAMETERS:  Op                  - Current Op (from parse walk)
- *
- * RETURN:      None
- *
- * DESCRIPTION: Set a breakpoint in a control method at the specified
- *              AML offset
- *
- ******************************************************************************/
-
-void
-acpi_db_set_method_call_breakpoint (
-	acpi_parse_object       *op)
-{
-
-
-	if (!op) {
-		acpi_os_printf ("There is no method currently executing\n");
-		return;
-	}
-
-
-	acpi_gbl_step_to_next_call = TRUE;
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_disassemble_aml
- *
- * PARAMETERS:  Statements          - Number of statements to disassemble
- *              Op                  - Current Op (from parse walk)
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display disassembled AML (ASL) starting from Op for the number
- *              of statements specified.
- *
- ******************************************************************************/
-
-void
-acpi_db_disassemble_aml (
-	NATIVE_CHAR             *statements,
-	acpi_parse_object       *op)
-{
-	u32                     num_statements = 8;
-
-
-	if (!op) {
-		acpi_os_printf ("There is no method currently executing\n");
-		return;
-	}
-
-	if (statements) {
-		num_statements = STRTOUL (statements, NULL, 0);
-	}
-
-
-	acpi_db_display_op (NULL, op, num_statements);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_dump_namespace
- *
- * PARAMETERS:  Start_arg       - Node to begin namespace dump
- *              Depth_arg       - Maximum tree depth to be dumped
- *
- * RETURN:      None
- *
- * DESCRIPTION: Dump entire namespace or a subtree.  Each node is displayed
- *              with type and other information.
- *
- ******************************************************************************/
-
-void
-acpi_db_dump_namespace (
-	NATIVE_CHAR             *start_arg,
-	NATIVE_CHAR             *depth_arg)
-{
-	acpi_handle             subtree_entry = acpi_gbl_root_node;
-	u32                     max_depth = ACPI_UINT32_MAX;
-
-
-	/* No argument given, just start at the root and dump entire namespace */
-
-	if (start_arg) {
-		/* Check if numeric argument, must be a Node */
-
-		if ((start_arg[0] >= 0x30) && (start_arg[0] <= 0x39)) {
-			subtree_entry = (acpi_handle) STRTOUL (start_arg, NULL, 16);
-			if (!acpi_os_readable (subtree_entry, sizeof (acpi_namespace_node))) {
-				acpi_os_printf ("Address %p is invalid in this address space\n", subtree_entry);
-				return;
-			}
-
-			if (!VALID_DESCRIPTOR_TYPE ((subtree_entry), ACPI_DESC_TYPE_NAMED)) {
-				acpi_os_printf ("Address %p is not a valid Named object\n", subtree_entry);
-				return;
-			}
-		}
-
-		/* Alpha argument */
-
-		else {
-			/* The parameter is a name string that must be resolved to a Named obj*/
-
-			subtree_entry = acpi_db_local_ns_lookup (start_arg);
-			if (!subtree_entry) {
-				subtree_entry = acpi_gbl_root_node;
-			}
-		}
-
-		/* Now we can check for the depth argument */
-
-		if (depth_arg) {
-			max_depth = STRTOUL (depth_arg, NULL, 0);
-		}
-	}
-
-
-	acpi_db_set_output_destination (DB_DUPLICATE_OUTPUT);
-	acpi_os_printf ("ACPI Namespace (from %p subtree):\n", subtree_entry);
-
-	/* Display the subtree */
-
-	acpi_db_set_output_destination (DB_REDIRECTABLE_OUTPUT);
-	acpi_ns_dump_objects (ACPI_TYPE_ANY, ACPI_DISPLAY_SUMMARY, max_depth, ACPI_UINT32_MAX, subtree_entry);
-	acpi_db_set_output_destination (DB_CONSOLE_OUTPUT);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_dump_namespace_by_owner
- *
- * PARAMETERS:  Owner_arg       - Owner ID whose nodes will be displayed
- *              Depth_arg       - Maximum tree depth to be dumped
- *
- * RETURN:      None
- *
- * DESCRIPTION: Dump elements of the namespace that are owned by the Owner_id.
- *
- ******************************************************************************/
-
-void
-acpi_db_dump_namespace_by_owner (
-	NATIVE_CHAR             *owner_arg,
-	NATIVE_CHAR             *depth_arg)
-{
-	acpi_handle             subtree_entry = acpi_gbl_root_node;
-	u32                     max_depth = ACPI_UINT32_MAX;
-	u16                     owner_id;
-
-
-	owner_id = (u16) STRTOUL (owner_arg, NULL, 0);
-
-
-	/* Now we can check for the depth argument */
-
-	if (depth_arg) {
-		max_depth = STRTOUL (depth_arg, NULL, 0);
-	}
-
-
-	acpi_db_set_output_destination (DB_DUPLICATE_OUTPUT);
-	acpi_os_printf ("ACPI Namespace by owner %X:\n", owner_id);
-
-	/* Display the subtree */
-
-	acpi_db_set_output_destination (DB_REDIRECTABLE_OUTPUT);
-	acpi_ns_dump_objects (ACPI_TYPE_ANY, ACPI_DISPLAY_SUMMARY, max_depth, owner_id, subtree_entry);
-	acpi_db_set_output_destination (DB_CONSOLE_OUTPUT);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_send_notify
- *
- * PARAMETERS:  Name            - Name of ACPI object to send the notify to
- *              Value           - Value of the notify to send.
- *
- * RETURN:      None
- *
- * DESCRIPTION: Send an ACPI notification.  The value specified is sent to the
- *              named object as an ACPI notify.
- *
- ******************************************************************************/
-
-void
-acpi_db_send_notify (
-	NATIVE_CHAR             *name,
-	u32                     value)
-{
-	acpi_namespace_node     *node;
-
-
-	/* Translate name to an Named object */
-
-	node = acpi_db_local_ns_lookup (name);
-	if (!node) {
-		return;
-	}
-
-	/* Decode Named object type */
-
-	switch (node->type) {
-	case ACPI_TYPE_DEVICE:
-	case ACPI_TYPE_THERMAL:
-
-		 /* Send the notify */
-
-		acpi_ev_queue_notify_request (node, value);
-		break;
-
-	default:
-		acpi_os_printf ("Named object is not a device or a thermal object\n");
-		break;
-	}
-
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_set_method_data
- *
- * PARAMETERS:  Type_arg        - L for local, A for argument
- *              Index_arg       - which one
- *              Value_arg       - Value to set.
- *
- * RETURN:      None
- *
- * DESCRIPTION: Set a local or argument for the running control method.
- *              NOTE: only object supported is Number.
- *
- ******************************************************************************/
-
-void
-acpi_db_set_method_data (
-	NATIVE_CHAR             *type_arg,
-	NATIVE_CHAR             *index_arg,
-	NATIVE_CHAR             *value_arg)
-{
-	NATIVE_CHAR             type;
-	u32                     index;
-	u32                     value;
-	acpi_walk_state         *walk_state;
-	acpi_operand_object     *obj_desc;
-
-
-	/* Validate Type_arg */
-
-	STRUPR (type_arg);
-	type = type_arg[0];
-	if ((type != 'L') &&
-		(type != 'A')) {
-		acpi_os_printf ("Invalid SET operand: %s\n", type_arg);
-		return;
-	}
-
-	/* Get the index and value */
-
-	index = STRTOUL (index_arg, NULL, 16);
-	value = STRTOUL (value_arg, NULL, 16);
-
-	walk_state = acpi_ds_get_current_walk_state (acpi_gbl_current_walk_list);
-	if (!walk_state) {
-		acpi_os_printf ("There is no method currently executing\n");
-		return;
-	}
-
-
-	/* Create and initialize the new object */
-
-	obj_desc = acpi_ut_create_internal_object (ACPI_TYPE_INTEGER);
-	if (!obj_desc) {
-		acpi_os_printf ("Could not create an internal object\n");
-		return;
-	}
-
-	obj_desc->integer.value = value;
-
-
-	/* Store the new object into the target */
-
-	switch (type) {
-	case 'A':
-
-		/* Set a method argument */
-
-		if (index > MTH_NUM_ARGS) {
-			acpi_os_printf ("Arg%d - Invalid argument name\n", index);
-			return;
-		}
-
-		acpi_ds_store_object_to_local (AML_ARG_OP, index, obj_desc, walk_state);
-		obj_desc = walk_state->arguments[index].object;
-
-		acpi_os_printf ("Arg%d: ", index);
-		acpi_db_display_internal_object (obj_desc, walk_state);
-		break;
-
-	case 'L':
-
-		/* Set a method local */
-
-		if (index > MTH_NUM_LOCALS) {
-			acpi_os_printf ("Local%d - Invalid local variable name\n", index);
-			return;
-		}
-
-		acpi_ds_store_object_to_local (AML_LOCAL_OP, index, obj_desc, walk_state);
-		obj_desc = walk_state->local_variables[index].object;
-
-		acpi_os_printf ("Local%d: ", index);
-		acpi_db_display_internal_object (obj_desc, walk_state);
-		break;
-
-	default:
-		break;
-	}
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_walk_for_specific_objects
- *
- * PARAMETERS:  Callback from Walk_namespace
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Display short info about objects in the namespace
- *
- ******************************************************************************/
-
-acpi_status
-acpi_db_walk_for_specific_objects (
-	acpi_handle             obj_handle,
-	u32                     nesting_level,
-	void                    *context,
-	void                    **return_value)
-{
-	acpi_operand_object     *obj_desc;
-	acpi_status             status;
-	u32                     buf_size;
-	NATIVE_CHAR             buffer[64];
-
-
-	obj_desc = ((acpi_namespace_node *)obj_handle)->object;
-	buf_size = sizeof (buffer) / sizeof (*buffer);
-
-	/* Get and display the full pathname to this object */
-
-	status = acpi_ns_handle_to_pathname (obj_handle, &buf_size, buffer);
-
-	if (ACPI_FAILURE (status)) {
-		acpi_os_printf ("Could Not get pathname for object %p\n", obj_handle);
-		return (AE_OK);
-	}
-
-	acpi_os_printf ("%32s", buffer);
-
-
-	/* Display short information about the object */
-
-	if (obj_desc) {
-		switch (obj_desc->common.type) {
-		case ACPI_TYPE_METHOD:
-			acpi_os_printf (" #Args %d Concurrency %X", obj_desc->method.param_count, obj_desc->method.concurrency);
-			break;
-
-		case ACPI_TYPE_INTEGER:
-			acpi_os_printf (" Value %X", obj_desc->integer.value);
-			break;
-
-		case ACPI_TYPE_STRING:
-			acpi_os_printf (" \"%s\"", obj_desc->string.pointer);
-			break;
-
-		case ACPI_TYPE_REGION:
-			acpi_os_printf (" Space_id %X Address %X Length %X", obj_desc->region.space_id, obj_desc->region.address, obj_desc->region.length);
-			break;
-
-		case ACPI_TYPE_PACKAGE:
-			acpi_os_printf (" #Elements %X", obj_desc->package.count);
-			break;
-
-		case ACPI_TYPE_BUFFER:
-			acpi_os_printf (" Length %X", obj_desc->buffer.length);
-			break;
-		}
-	}
-
-	acpi_os_printf ("\n");
-	return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_display_objects
- *
- * PARAMETERS:  Obj_type_arg        - Type of object to display
- *              Display_count_arg   - Max depth to display
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display objects in the namespace of the requested type
- *
- ******************************************************************************/
-
-acpi_status
-acpi_db_display_objects (
-	NATIVE_CHAR             *obj_type_arg,
-	NATIVE_CHAR             *display_count_arg)
-{
-	acpi_object_type8       type;
-
-
-	/* Get the object type */
-
-	type = acpi_db_match_argument (obj_type_arg, acpi_db_object_types);
-	if (type == ACPI_TYPE_NOT_FOUND) {
-		acpi_os_printf ("Invalid or unsupported argument\n");
-		return (AE_OK);
-	}
-
-	acpi_db_set_output_destination (DB_DUPLICATE_OUTPUT);
-	acpi_os_printf ("Objects of type [%s] defined in the current ACPI Namespace: \n", acpi_ut_get_type_name (type));
-
-	acpi_db_set_output_destination (DB_REDIRECTABLE_OUTPUT);
-
-	/* Walk the namespace from the root */
-
-	acpi_walk_namespace (type, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
-			   acpi_db_walk_for_specific_objects, (void *) &type, NULL);
-
-	acpi_db_set_output_destination (DB_CONSOLE_OUTPUT);
-	return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_walk_and_match_name
- *
- * PARAMETERS:  Callback from Walk_namespace
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Find a particular name/names within the namespace.  Wildcards
- *              are supported -- '?' matches any character.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_db_walk_and_match_name (
-	acpi_handle             obj_handle,
-	u32                     nesting_level,
-	void                    *context,
-	void                    **return_value)
-{
-	acpi_status             status;
-	NATIVE_CHAR             *requested_name = (NATIVE_CHAR *) context;
-	u32                     i;
-	u32                     buf_size;
-	NATIVE_CHAR             buffer[96];
-
-
-	/* Check for a name match */
-
-	for (i = 0; i < 4; i++) {
-		/* Wildcard support */
-
-		if ((requested_name[i] != '?') &&
-			(requested_name[i] != ((NATIVE_CHAR *) (&((acpi_namespace_node *) obj_handle)->name))[i])) {
-			/* No match, just exit */
-
-			return (AE_OK);
-		}
-	}
-
-
-	/* Get the full pathname to this object */
-
-	buf_size = sizeof (buffer) / sizeof (*buffer);
-
-	status = acpi_ns_handle_to_pathname (obj_handle, &buf_size, buffer);
-	if (ACPI_FAILURE (status)) {
-		acpi_os_printf ("Could Not get pathname for object %p\n", obj_handle);
-	}
-
-	else {
-		acpi_os_printf ("%32s (%p) - %s\n", buffer, obj_handle,
-			acpi_ut_get_type_name (((acpi_namespace_node *) obj_handle)->type));
-	}
-
-	return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_find_name_in_namespace
- *
- * PARAMETERS:  Name_arg        - The 4-character ACPI name to find.
- *                                wildcards are supported.
- *
- * RETURN:      None
- *
- * DESCRIPTION: Search the namespace for a given name (with wildcards)
- *
- ******************************************************************************/
-
-acpi_status
-acpi_db_find_name_in_namespace (
-	NATIVE_CHAR             *name_arg)
-{
-
-	if (STRLEN (name_arg) > 4) {
-		acpi_os_printf ("Name must be no longer than 4 characters\n");
-		return (AE_OK);
-	}
-
-	/* Walk the namespace from the root */
-
-	acpi_walk_namespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
-			   acpi_db_walk_and_match_name, name_arg, NULL);
-
-	acpi_db_set_output_destination (DB_CONSOLE_OUTPUT);
-	return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_set_scope
- *
- * PARAMETERS:  Name                - New scope path
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Set the "current scope" as maintained by this utility.
- *              The scope is used as a prefix to ACPI paths.
- *
- ******************************************************************************/
-
-void
-acpi_db_set_scope (
-	NATIVE_CHAR             *name)
-{
-
-	if (!name || name[0] == 0) {
-		acpi_os_printf ("Current scope: %s\n", acpi_gbl_db_scope_buf);
-		return;
-	}
-
-	acpi_db_prep_namestring (name);
-
-	/* TBD: [Future] Validate scope here */
-
-	if (name[0] == '\\') {
-		STRCPY (acpi_gbl_db_scope_buf, name);
-		STRCAT (acpi_gbl_db_scope_buf, "\\");
-	}
-
-	else {
-		STRCAT (acpi_gbl_db_scope_buf, name);
-		STRCAT (acpi_gbl_db_scope_buf, "\\");
-	}
-
-	acpi_os_printf ("New scope: %s\n", acpi_gbl_db_scope_buf);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_display_resources
- *
- * PARAMETERS:  Object_arg      - String with hex value of the object
- *
- * RETURN:      None
- *
- * DESCRIPTION:
- *
- ******************************************************************************/
-
-void
-acpi_db_display_resources (
-	NATIVE_CHAR             *object_arg)
-{
-#ifndef _IA16
-	acpi_operand_object     *obj_desc;
-	acpi_status             status;
-	acpi_buffer             return_obj;
-
-
-	acpi_db_set_output_destination (DB_REDIRECTABLE_OUTPUT);
-
-	/* Convert string to object pointer */
-
-	obj_desc = (acpi_operand_object *) STRTOUL (object_arg, NULL, 16);
-
-	/* Prepare for a return object of arbitrary size */
-
-	return_obj.pointer          = acpi_gbl_db_buffer;
-	return_obj.length           = ACPI_DEBUG_BUFFER_SIZE;
-
-
-	/* _PRT */
-
-	acpi_os_printf ("Evaluating _PRT\n");
-
-	status = acpi_evaluate_object (obj_desc, "_PRT", NULL, &return_obj);
-	if (ACPI_FAILURE (status)) {
-		acpi_os_printf ("Could not obtain _PRT: %s\n", acpi_format_exception (status));
-		goto get_crs;
-	}
-
-	return_obj.pointer          = acpi_gbl_db_buffer;
-	return_obj.length           = ACPI_DEBUG_BUFFER_SIZE;
-
-	status = acpi_get_irq_routing_table (obj_desc, &return_obj);
-	if (ACPI_FAILURE (status)) {
-		acpi_os_printf ("Get_irq_routing_table failed: %s\n", acpi_format_exception (status));
-	}
-
-	else {
-		acpi_rs_dump_irq_list ((u8 *) acpi_gbl_db_buffer);
-	}
-
-
-	/* _CRS */
-
-get_crs:
-	acpi_os_printf ("Evaluating _CRS\n");
-
-	return_obj.pointer          = acpi_gbl_db_buffer;
-	return_obj.length           = ACPI_DEBUG_BUFFER_SIZE;
-
-	status = acpi_evaluate_object (obj_desc, "_CRS", NULL, &return_obj);
-	if (ACPI_FAILURE (status)) {
-		acpi_os_printf ("Could not obtain _CRS: %s\n", acpi_format_exception (status));
-		goto get_prs;
-	}
-
-	return_obj.pointer          = acpi_gbl_db_buffer;
-	return_obj.length           = ACPI_DEBUG_BUFFER_SIZE;
-
-	status = acpi_get_current_resources (obj_desc, &return_obj);
-	if (ACPI_FAILURE (status)) {
-		acpi_os_printf ("Acpi_get_current_resources failed: %s\n", acpi_format_exception (status));
-	}
-
-	else {
-		acpi_rs_dump_resource_list ((acpi_resource *) acpi_gbl_db_buffer);
-	}
-
-
-	/* _PRS */
-
-get_prs:
-	acpi_os_printf ("Evaluating _PRS\n");
-
-	return_obj.pointer          = acpi_gbl_db_buffer;
-	return_obj.length           = ACPI_DEBUG_BUFFER_SIZE;
-
-	status = acpi_evaluate_object (obj_desc, "_PRS", NULL, &return_obj);
-	if (ACPI_FAILURE (status)) {
-		acpi_os_printf ("Could not obtain _PRS: %s\n", acpi_format_exception (status));
-		goto cleanup;
-	}
-
-	return_obj.pointer          = acpi_gbl_db_buffer;
-	return_obj.length           = ACPI_DEBUG_BUFFER_SIZE;
-
-	status = acpi_get_possible_resources (obj_desc, &return_obj);
-	if (ACPI_FAILURE (status)) {
-		acpi_os_printf ("Acpi_get_possible_resources failed: %s\n", acpi_format_exception (status));
-	}
-
-	else {
-		acpi_rs_dump_resource_list ((acpi_resource *) acpi_gbl_db_buffer);
-	}
-
-
-cleanup:
-
-	acpi_db_set_output_destination (DB_CONSOLE_OUTPUT);
-	return;
-#endif
-
-}
-
-
-#endif /* ENABLE_DEBUGGER */
diff -urNp linux-5400/drivers/acpi/debugger/dbdisasm.c linux-5410/drivers/acpi/debugger/dbdisasm.c
--- linux-5400/drivers/acpi/debugger/dbdisasm.c
+++ linux-5410/drivers/acpi/debugger/dbdisasm.c
@@ -1,715 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: dbdisasm - parser op tree display routines
- *              $Revision: 50 $
- *
- ******************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include "acpi.h"
-#include "acparser.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "acdebug.h"
-
-
-#ifdef ENABLE_DEBUGGER
-
-#define _COMPONENT          ACPI_DEBUGGER
-	 MODULE_NAME         ("dbdisasm")
-
-
-#define MAX_SHOW_ENTRY      128
-#define BLOCK_PAREN         1
-#define BLOCK_BRACE         2
-#define DB_NO_OP_INFO       "            [%2.2d]  "
-#define DB_FULL_OP_INFO     "%5.5X #%4.4X [%2.2d]  "
-
-
-NATIVE_CHAR                 *acpi_gbl_db_disasm_indent = "....";
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_block_type
- *
- * PARAMETERS:  Op              - Object to be examined
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Type of block for this op (parens or braces)
- *
- ******************************************************************************/
-
-u32
-acpi_db_block_type (
-	acpi_parse_object       *op)
-{
-
-	switch (op->opcode) {
-	case AML_METHOD_OP:
-		return (BLOCK_BRACE);
-		break;
-
-	default:
-		break;
-	}
-
-	return (BLOCK_PAREN);
-
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ps_display_object_pathname
- *
- * PARAMETERS:  Op              - Object whose pathname is to be obtained
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Diplay the pathname associated with a named object.  Two
- *              versions. One searches the parse tree (for parser-only
- *              applications suchas Acpi_dump), and the other searches the
- *              ACPI namespace (the parse tree is probably deleted)
- *
- ******************************************************************************/
-
-#ifdef PARSER_ONLY
-
-acpi_status
-acpi_ps_display_object_pathname (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op)
-{
-	acpi_parse_object       *target_op;
-
-
-	/* Search parent tree up to the root if necessary */
-
-	target_op = acpi_ps_find (op, op->value.name, 0, 0);
-	if (!target_op) {
-		/*
-		 * Didn't find the name in the parse tree.  This may be
-		 * a problem, or it may simply be one of the predefined names
-		 * (such as _OS_).  Rather than worry about looking up all
-		 * the predefined names, just display the name as given
-		 */
-		acpi_os_printf (" **** Path not found in parse tree");
-	}
-
-	else {
-		/* The target was found, print the name and complete path */
-
-		acpi_os_printf (" (Path ");
-		acpi_db_display_path (target_op);
-		acpi_os_printf (")");
-	}
-
-	return (AE_OK);
-}
-
-#else
-
-acpi_status
-acpi_ps_display_object_pathname (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op)
-{
-	acpi_status             status;
-	acpi_namespace_node     *node;
-	NATIVE_CHAR             buffer[MAX_SHOW_ENTRY];
-	u32                     buffer_size = MAX_SHOW_ENTRY;
-	u32                     debug_level;
-
-
-	/* Save current debug level so we don't get extraneous debug output */
-
-	debug_level = acpi_dbg_level;
-	acpi_dbg_level = 0;
-
-	/* Just get the Node out of the Op object */
-
-	node = op->node;
-	if (!node) {
-		/* Node not defined in this scope, look it up */
-
-		status = acpi_ns_lookup (walk_state->scope_info, op->value.string, ACPI_TYPE_ANY,
-				  IMODE_EXECUTE, NS_SEARCH_PARENT, walk_state, &(node));
-
-		if (ACPI_FAILURE (status)) {
-			/*
-			 * We can't get the pathname since the object
-			 * is not in the namespace.  This can happen during single
-			 * stepping where a dynamic named object is *about* to be created.
-			 */
-			acpi_os_printf (" [Path not found]");
-			goto exit;
-		}
-
-		/* Save it for next time. */
-
-		op->node = node;
-	}
-
-	/* Convert Named_desc/handle to a full pathname */
-
-	status = acpi_ns_handle_to_pathname (node, &buffer_size, buffer);
-	if (ACPI_FAILURE (status)) {
-		acpi_os_printf ("****Could not get pathname****)");
-		goto exit;
-	}
-
-	acpi_os_printf (" (Path %s)", buffer);
-
-
-exit:
-	/* Restore the debug level */
-
-	acpi_dbg_level = debug_level;
-	return (status);
-}
-
-#endif
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_display_op
- *
- * PARAMETERS:  Origin          - Starting object
- *              Num_opcodes     - Max number of opcodes to be displayed
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display parser object and its children
- *
- ******************************************************************************/
-
-void
-acpi_db_display_op (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *origin,
-	u32                     num_opcodes)
-{
-	acpi_parse_object       *op = origin;
-	acpi_parse_object       *arg;
-	acpi_parse_object       *depth;
-	u32                     depth_count = 0;
-	u32                     last_depth = 0;
-	u32                     i;
-	u32                     j;
-
-
-	if (op) {
-		while (op) {
-			/* indentation */
-
-			depth_count = 0;
-			if (!acpi_gbl_db_opt_verbose) {
-				depth_count++;
-			}
-
-			/* Determine the nesting depth of this argument */
-
-			for (depth = op->parent; depth; depth = depth->parent) {
-				arg = acpi_ps_get_arg (depth, 0);
-				while (arg && arg != origin) {
-					arg = arg->next;
-				}
-
-				if (arg) {
-					break;
-				}
-
-				depth_count++;
-			}
-
-
-			/* Open a new block if we are nested further than last time */
-
-			if (depth_count > last_depth) {
-				VERBOSE_PRINT ((DB_NO_OP_INFO, last_depth));
-				for (i = 0; i < last_depth; i++) {
-					acpi_os_printf ("%s", acpi_gbl_db_disasm_indent);
-				}
-
-				if (acpi_db_block_type (op) == BLOCK_PAREN) {
-					acpi_os_printf ("(\n");
-				}
-				else {
-					acpi_os_printf ("{\n");
-				}
-			}
-
-			/* Close a block if we are nested less than last time */
-
-			else if (depth_count < last_depth) {
-				for (j = 0; j < (last_depth - depth_count); j++) {
-					VERBOSE_PRINT ((DB_NO_OP_INFO, last_depth - j));
-					for (i = 0; i < (last_depth - j - 1); i++) {
-						acpi_os_printf ("%s", acpi_gbl_db_disasm_indent);
-					}
-
-					if (acpi_db_block_type (op) == BLOCK_PAREN) {
-						acpi_os_printf (")\n");
-					}
-					else {
-						acpi_os_printf ("}\n");
-					}
-				}
-			}
-
-			/* In verbose mode, print the AML offset, opcode and depth count */
-
-			VERBOSE_PRINT ((DB_FULL_OP_INFO, (unsigned) op->aml_offset, op->opcode, depth_count));
-
-
-			/* Indent the output according to the depth count */
-
-			for (i = 0; i < depth_count; i++) {
-				acpi_os_printf ("%s", acpi_gbl_db_disasm_indent);
-			}
-
-
-			/* Now print the opcode */
-
-			acpi_db_display_opcode (walk_state, op);
-
-			/* Resolve a name reference */
-
-			if ((op->opcode == AML_INT_NAMEPATH_OP && op->value.name)  &&
-				(op->parent) &&
-				(acpi_gbl_db_opt_verbose)) {
-				acpi_ps_display_object_pathname (walk_state, op);
-			}
-
-			acpi_os_printf ("\n");
-
-			/* Get the next node in the tree */
-
-			op = acpi_ps_get_depth_next (origin, op);
-			last_depth = depth_count;
-
-			num_opcodes--;
-			if (!num_opcodes) {
-				op = NULL;
-			}
-		}
-
-		/* Close the last block(s) */
-
-		depth_count = last_depth -1;
-		for (i = 0; i < last_depth; i++) {
-			VERBOSE_PRINT ((DB_NO_OP_INFO, last_depth - i));
-			for (j = 0; j < depth_count; j++) {
-				acpi_os_printf ("%s", acpi_gbl_db_disasm_indent);
-			}
-			acpi_os_printf ("}\n");
-			depth_count--;
-		}
-
-	}
-
-	else {
-		acpi_db_display_opcode (walk_state, op);
-	}
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_display_namestring
- *
- * PARAMETERS:  Name                - ACPI Name string to store
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display namestring. Handles prefix characters
- *
- ******************************************************************************/
-
-void
-acpi_db_display_namestring (
-	NATIVE_CHAR             *name)
-{
-	u32                     seg_count;
-	u8                      do_dot = FALSE;
-
-
-	if (!name) {
-		acpi_os_printf ("<NULL NAME PTR>");
-		return;
-	}
-
-	if (acpi_ps_is_prefix_char (GET8 (name))) {
-		/* append prefix character */
-
-		acpi_os_printf ("%1c", GET8 (name));
-		name++;
-	}
-
-	switch (GET8 (name)) {
-	case AML_DUAL_NAME_PREFIX:
-		seg_count = 2;
-		name++;
-		break;
-
-	case AML_MULTI_NAME_PREFIX_OP:
-		seg_count = (u32) GET8 (name + 1);
-		name += 2;
-		break;
-
-	default:
-		seg_count = 1;
-		break;
-	}
-
-	while (seg_count--) {
-		/* append Name segment */
-
-		if (do_dot) {
-			/* append dot */
-
-			acpi_os_printf (".");
-		}
-
-		acpi_os_printf ("%4.4s", name);
-		do_dot = TRUE;
-
-		name += 4;
-	}
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_display_path
- *
- * PARAMETERS:  Op                  - Named Op whose path is to be constructed
- *
- * RETURN:      None
- *
- * DESCRIPTION: Walk backwards from current scope and display the name
- *              of each previous level of scope up to the root scope
- *              (like "pwd" does with file systems)
- *
- ******************************************************************************/
-
-void
-acpi_db_display_path (
-	acpi_parse_object       *op)
-{
-	acpi_parse_object       *prev;
-	acpi_parse_object       *search;
-	u32                     name;
-	u8                      do_dot = FALSE;
-	acpi_parse_object       *name_path;
-	const acpi_opcode_info  *op_info;
-
-
-	/* We are only interested in named objects */
-
-	op_info = acpi_ps_get_opcode_info (op->opcode);
-	if (!(op_info->flags & AML_NSNODE)) {
-		return;
-	}
-
-
-	if (op_info->flags & AML_CREATE) {
-		/* Field creation - check for a fully qualified namepath */
-
-		if (op->opcode == AML_CREATE_FIELD_OP) {
-			name_path = acpi_ps_get_arg (op, 3);
-		}
-		else {
-			name_path = acpi_ps_get_arg (op, 2);
-		}
-
-		if ((name_path) &&
-			(name_path->value.string) &&
-			(name_path->value.string[0] == '\\')) {
-			acpi_db_display_namestring (name_path->value.string);
-			return;
-		}
-	}
-
-	prev = NULL;            /* Start with Root Node */
-
-	while (prev != op) {
-		/* Search upwards in the tree to find scope with "prev" as its parent */
-
-		search = op;
-		for (; ;) {
-			if (search->parent == prev) {
-				break;
-			}
-
-			/* Go up one level */
-
-			search = search->parent;
-		}
-
-		if (prev) {
-			op_info = acpi_ps_get_opcode_info (search->opcode);
-			if (!(op_info->flags & AML_FIELD)) {
-				/* below root scope, append scope name */
-
-				if (do_dot) {
-					/* append dot */
-
-					acpi_os_printf (".");
-				}
-
-				if (op_info->flags & AML_CREATE) {
-					if (op->opcode == AML_CREATE_FIELD_OP) {
-						name_path = acpi_ps_get_arg (op, 3);
-					}
-					else {
-						name_path = acpi_ps_get_arg (op, 2);
-					}
-
-					if ((name_path) &&
-						(name_path->value.string)) {
-						acpi_os_printf ("%4.4s", name_path->value.string);
-					}
-				}
-
-				else {
-					name = acpi_ps_get_name (search);
-					acpi_os_printf ("%4.4s", &name);
-				}
-
-				do_dot = TRUE;
-			}
-		}
-
-		prev = search;
-	}
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_display_opcode
- *
- * PARAMETERS:  Op                  - Op that is to be printed
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Store printed op in a Buffer and return its length
- *              (or -1 if out of space)
- *
- * NOTE: Terse mode prints out ASL-like code.  Verbose mode adds more info.
- *
- ******************************************************************************/
-
-void
-acpi_db_display_opcode (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op)
-{
-	u8                      *byte_data;
-	u32                     byte_count;
-	u32                     i;
-	const acpi_opcode_info  *op_info = NULL;
-	u32                     name;
-
-
-	if (!op) {
-		acpi_os_printf ("<NULL OP PTR>");
-	}
-
-
-	/* op and arguments */
-
-	switch (op->opcode) {
-
-	case AML_BYTE_OP:
-
-		if (acpi_gbl_db_opt_verbose) {
-			acpi_os_printf ("(u8) 0x%2.2X", op->value.integer8);
-		}
-
-		else {
-			acpi_os_printf ("0x%2.2X", op->value.integer8);
-		}
-
-		break;
-
-
-	case AML_WORD_OP:
-
-		if (acpi_gbl_db_opt_verbose) {
-			acpi_os_printf ("(u16) 0x%4.4X", op->value.integer16);
-		}
-
-		else {
-			acpi_os_printf ("0x%4.4X", op->value.integer16);
-		}
-
-		break;
-
-
-	case AML_DWORD_OP:
-
-		if (acpi_gbl_db_opt_verbose) {
-			acpi_os_printf ("(u32) 0x%8.8X", op->value.integer32);
-		}
-
-		else {
-			acpi_os_printf ("0x%8.8X", op->value.integer32);
-		}
-
-		break;
-
-
-	case AML_QWORD_OP:
-
-		if (acpi_gbl_db_opt_verbose) {
-			acpi_os_printf ("(u64) 0x%8.8X%8.8X", op->value.integer64.hi,
-					 op->value.integer64.lo);
-		}
-
-		else {
-			acpi_os_printf ("0x%8.8X%8.8X", op->value.integer64.hi,
-					 op->value.integer64.lo);
-		}
-
-		break;
-
-
-	case AML_STRING_OP:
-
-		if (op->value.string) {
-			acpi_os_printf ("\"%s\"", op->value.string);
-		}
-
-		else {
-			acpi_os_printf ("<\"NULL STRING PTR\">");
-		}
-
-		break;
-
-
-	case AML_INT_STATICSTRING_OP:
-
-		if (op->value.string) {
-			acpi_os_printf ("\"%s\"", op->value.string);
-		}
-
-		else {
-			acpi_os_printf ("\"<NULL STATIC STRING PTR>\"");
-		}
-
-		break;
-
-
-	case AML_INT_NAMEPATH_OP:
-
-		acpi_db_display_namestring (op->value.name);
-		break;
-
-
-	case AML_INT_NAMEDFIELD_OP:
-
-		acpi_os_printf ("Named_field (Length 0x%8.8X)  ", op->value.integer32);
-		break;
-
-
-	case AML_INT_RESERVEDFIELD_OP:
-
-		acpi_os_printf ("Reserved_field (Length 0x%8.8X) ", op->value.integer32);
-		break;
-
-
-	case AML_INT_ACCESSFIELD_OP:
-
-		acpi_os_printf ("Access_field (Length 0x%8.8X) ", op->value.integer32);
-		break;
-
-
-	case AML_INT_BYTELIST_OP:
-
-		if (acpi_gbl_db_opt_verbose) {
-			acpi_os_printf ("Byte_list   (Length 0x%8.8X)  ", op->value.integer32);
-		}
-
-		else {
-			acpi_os_printf ("0x%2.2X", op->value.integer32);
-
-			byte_count = op->value.integer32;
-			byte_data = ((acpi_parse2_object *) op)->data;
-
-			for (i = 0; i < byte_count; i++) {
-				acpi_os_printf (", 0x%2.2X", byte_data[i]);
-			}
-		}
-
-		break;
-
-
-	default:
-
-		/* Just get the opcode name and print it */
-
-		op_info = acpi_ps_get_opcode_info (op->opcode);
-		acpi_os_printf ("%s", op_info->name);
-
-
-#ifndef PARSER_ONLY
-		if ((op->opcode == AML_INT_RETURN_VALUE_OP) &&
-			(walk_state->results) &&
-			(walk_state->results->results.num_results)) {
-			acpi_db_decode_internal_object (walk_state->results->results.obj_desc [walk_state->results->results.num_results-1]);
-		}
-#endif
-
-		break;
-	}
-
-	if (!op_info) {
-		/* If there is another element in the list, add a comma */
-
-		if (op->next) {
-			acpi_os_printf (",");
-		}
-	}
-
-	/*
-	 * If this is a named opcode, print the associated name value
-	 */
-	op_info = acpi_ps_get_opcode_info (op->opcode);
-	if (op && (op_info->flags & AML_NAMED)) {
-		name = acpi_ps_get_name (op);
-		acpi_os_printf (" %4.4s", &name);
-
-		if (acpi_gbl_db_opt_verbose) {
-			acpi_os_printf (" (Path \\");
-			acpi_db_display_path (op);
-			acpi_os_printf (")");
-		}
-	}
-}
-
-
-#endif  /* ENABLE_DEBUGGER */
-
diff -urNp linux-5400/drivers/acpi/debugger/dbdisply.c linux-5410/drivers/acpi/debugger/dbdisply.c
--- linux-5400/drivers/acpi/debugger/dbdisply.c
+++ linux-5410/drivers/acpi/debugger/dbdisply.c
@@ -1,794 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: dbdisply - debug display commands
- *              $Revision: 57 $
- *
- ******************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include "acpi.h"
-#include "acparser.h"
-#include "amlcode.h"
-#include "acdispat.h"
-#include "acnamesp.h"
-#include "acparser.h"
-#include "acevents.h"
-#include "acinterp.h"
-#include "acdebug.h"
-
-
-#ifdef ENABLE_DEBUGGER
-
-
-#define _COMPONENT          ACPI_DEBUGGER
-	 MODULE_NAME         ("dbdisply")
-
-
-/******************************************************************************
- *
- * FUNCTION:    Acpi_db_get_pointer
- *
- * PARAMETERS:  Target          - Pointer to string to be converted
- *
- * RETURN:      Converted pointer
- *
- * DESCRIPTION: Convert an ascii pointer value to a real value
- *
- *****************************************************************************/
-
-void *
-acpi_db_get_pointer (
-	void                    *target)
-{
-	void                    *obj_ptr;
-
-
-#ifdef _IA16
-#include <stdio.h>
-
-	/* Have to handle 16-bit pointers of the form segment:offset */
-
-	if (!sscanf (target, "%p", &obj_ptr)) {
-		acpi_os_printf ("Invalid pointer: %s\n", target);
-		return (NULL);
-	}
-
-#else
-
-	/* Simple flat pointer */
-
-	obj_ptr = (void *) STRTOUL (target, NULL, 16);
-
-#endif
-
-	return (obj_ptr);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_dump_parser_descriptor
- *
- * PARAMETERS:  Op              - A parser Op descriptor
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display a formatted parser object
- *
- ******************************************************************************/
-
-void
-acpi_db_dump_parser_descriptor (
-	acpi_parse_object       *op)
-{
-	const acpi_opcode_info  *info;
-
-
-	info = acpi_ps_get_opcode_info (op->opcode);
-
-	acpi_os_printf ("Parser Op Descriptor:\n");
-	acpi_os_printf ("%20.20s : %4.4X\n", "Opcode", op->opcode);
-
-	DEBUG_ONLY_MEMBERS (acpi_os_printf ("%20.20s : %s\n", "Opcode Name", info->name));
-
-	acpi_os_printf ("%20.20s : %p\n", "Value/Arg_list", op->value);
-	acpi_os_printf ("%20.20s : %p\n", "Parent", op->parent);
-	acpi_os_printf ("%20.20s : %p\n", "Next_op", op->next);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_decode_and_display_object
- *
- * PARAMETERS:  Target          - String with object to be displayed.  Names
- *                                and hex pointers are supported.
- *              Output_type     - Byte, Word, Dword, or Qword (B|W|D|Q)
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display a formatted ACPI object
- *
- ******************************************************************************/
-
-void
-acpi_db_decode_and_display_object (
-	NATIVE_CHAR             *target,
-	NATIVE_CHAR             *output_type)
-{
-	void                    *obj_ptr;
-	acpi_namespace_node     *node;
-	u32                     display = DB_BYTE_DISPLAY;
-	NATIVE_CHAR             buffer[80];
-	acpi_buffer             ret_buf;
-	acpi_status             status;
-	u32                     size;
-
-
-	if (!target) {
-		return;
-	}
-
-	/* Decode the output type */
-
-	if (output_type) {
-		STRUPR (output_type);
-		if (output_type[0] == 'W') {
-			display = DB_WORD_DISPLAY;
-		}
-		else if (output_type[0] == 'D') {
-			display = DB_DWORD_DISPLAY;
-		}
-		else if (output_type[0] == 'Q') {
-			display = DB_QWORD_DISPLAY;
-		}
-	}
-
-
-	ret_buf.length = sizeof (buffer);
-	ret_buf.pointer = buffer;
-
-	/* Differentiate between a number and a name */
-
-	if ((target[0] >= 0x30) && (target[0] <= 0x39)) {
-		obj_ptr = acpi_db_get_pointer (target);
-		if (!acpi_os_readable (obj_ptr, 16)) {
-			acpi_os_printf ("Address %p is invalid in this address space\n", obj_ptr);
-			return;
-		}
-
-		/* Decode the object type */
-
-		if (VALID_DESCRIPTOR_TYPE ((obj_ptr), ACPI_DESC_TYPE_NAMED)) {
-			/* This is a Node */
-
-			if (!acpi_os_readable (obj_ptr, sizeof (acpi_namespace_node))) {
-				acpi_os_printf ("Cannot read entire Named object at address %p\n", obj_ptr);
-				return;
-			}
-
-			node = obj_ptr;
-			goto dump_nte;
-		}
-
-		else if (VALID_DESCRIPTOR_TYPE ((obj_ptr), ACPI_DESC_TYPE_INTERNAL)) {
-			/* This is an ACPI OBJECT */
-
-			if (!acpi_os_readable (obj_ptr, sizeof (acpi_operand_object))) {
-				acpi_os_printf ("Cannot read entire ACPI object at address %p\n", obj_ptr);
-				return;
-			}
-
-			acpi_ut_dump_buffer (obj_ptr, sizeof (acpi_operand_object), display, ACPI_UINT32_MAX);
-			acpi_ex_dump_object_descriptor (obj_ptr, 1);
-		}
-
-		else if (VALID_DESCRIPTOR_TYPE ((obj_ptr), ACPI_DESC_TYPE_PARSER)) {
-			/* This is an Parser Op object */
-
-			if (!acpi_os_readable (obj_ptr, sizeof (acpi_parse_object))) {
-				acpi_os_printf ("Cannot read entire Parser object at address %p\n", obj_ptr);
-				return;
-			}
-
-
-			acpi_ut_dump_buffer (obj_ptr, sizeof (acpi_parse_object), display, ACPI_UINT32_MAX);
-			acpi_db_dump_parser_descriptor ((acpi_parse_object *) obj_ptr);
-		}
-
-		else {
-			size = 16;
-			if (acpi_os_readable (obj_ptr, 64)) {
-				size = 64;
-			}
-
-			/* Just dump some memory */
-
-			acpi_ut_dump_buffer (obj_ptr, size, display, ACPI_UINT32_MAX);
-		}
-
-		return;
-	}
-
-
-	/* The parameter is a name string that must be resolved to a Named obj */
-
-	node = acpi_db_local_ns_lookup (target);
-	if (!node) {
-		return;
-	}
-
-
-dump_nte:
-	/* Now dump the Named obj */
-
-	status = acpi_get_name (node, ACPI_FULL_PATHNAME, &ret_buf);
-	if (ACPI_FAILURE (status)) {
-		acpi_os_printf ("Could not convert name to pathname\n");
-	}
-
-	else {
-		acpi_os_printf ("Object (%p) Pathname: %s\n", node, ret_buf.pointer);
-	}
-
-	if (!acpi_os_readable (node, sizeof (acpi_namespace_node))) {
-		acpi_os_printf ("Invalid Named object at address %p\n", node);
-		return;
-	}
-
-	acpi_ut_dump_buffer ((void *) node, sizeof (acpi_namespace_node), display, ACPI_UINT32_MAX);
-	acpi_ex_dump_node (node, 1);
-
-	if (node->object) {
-		acpi_os_printf ("\n_attached Object (%p):\n", node->object);
-		if (!acpi_os_readable (node->object, sizeof (acpi_operand_object))) {
-			acpi_os_printf ("Invalid internal ACPI Object at address %p\n", node->object);
-			return;
-		}
-
-		acpi_ut_dump_buffer ((void *) node->object, sizeof (acpi_operand_object), display, ACPI_UINT32_MAX);
-		acpi_ex_dump_object_descriptor (node->object, 1);
-	}
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_decode_internal_object
- *
- * PARAMETERS:  Obj_desc        - Object to be displayed
- *
- * RETURN:      None
- *
- * DESCRIPTION: Short display of an internal object.  Numbers and Strings.
- *
- ******************************************************************************/
-
-void
-acpi_db_decode_internal_object (
-	acpi_operand_object     *obj_desc)
-{
-	u32                     i;
-
-
-	if (!obj_desc) {
-		return;
-	}
-
-	acpi_os_printf (" %s", acpi_ut_get_type_name (obj_desc->common.type));
-
-	switch (obj_desc->common.type) {
-	case ACPI_TYPE_INTEGER:
-
-		acpi_os_printf (" %.8X%.8X", HIDWORD (obj_desc->integer.value),
-				 LODWORD (obj_desc->integer.value));
-		break;
-
-
-	case ACPI_TYPE_STRING:
-
-		acpi_os_printf ("(%d) \"%.24s",
-				obj_desc->string.length, obj_desc->string.pointer);
-
-		if (obj_desc->string.length > 24)
-		{
-			acpi_os_printf ("...");
-		}
-		else
-		{
-			acpi_os_printf ("\"");
-		}
-		break;
-
-
-	case ACPI_TYPE_BUFFER:
-
-		acpi_os_printf ("(%d)", obj_desc->buffer.length);
-		for (i = 0; (i < 8) && (i < obj_desc->buffer.length); i++) {
-			acpi_os_printf (" %2.2X", obj_desc->buffer.pointer[i]);
-		}
-		break;
-	}
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_display_internal_object
- *
- * PARAMETERS:  Obj_desc        - Object to be displayed
- *              Walk_state      - Current walk state
- *
- * RETURN:      None
- *
- * DESCRIPTION: Short display of an internal object
- *
- ******************************************************************************/
-
-void
-acpi_db_display_internal_object (
-	acpi_operand_object     *obj_desc,
-	acpi_walk_state         *walk_state)
-{
-	u8                      type;
-
-
-	acpi_os_printf ("%p ", obj_desc);
-
-	if (!obj_desc) {
-		acpi_os_printf ("<Null_obj>\n");
-		return;
-	}
-
-
-	/* Decode the object type */
-
-	else if (VALID_DESCRIPTOR_TYPE (obj_desc, ACPI_DESC_TYPE_PARSER)) {
-		acpi_os_printf ("<Parser> ");
-	}
-
-	else if (VALID_DESCRIPTOR_TYPE (obj_desc, ACPI_DESC_TYPE_NAMED)) {
-		acpi_os_printf ("<Node>          Name %4.4s Type-%s",
-				  &((acpi_namespace_node *)obj_desc)->name,
-				  acpi_ut_get_type_name (((acpi_namespace_node *) obj_desc)->type));
-		if (((acpi_namespace_node *) obj_desc)->flags & ANOBJ_METHOD_ARG) {
-			acpi_os_printf (" [Method Arg]");
-		}
-		if (((acpi_namespace_node *) obj_desc)->flags & ANOBJ_METHOD_LOCAL) {
-			acpi_os_printf (" [Method Local]");
-		}
-	}
-
-	else if (VALID_DESCRIPTOR_TYPE (obj_desc, ACPI_DESC_TYPE_INTERNAL)) {
-		type = obj_desc->common.type;
-		if (type > INTERNAL_TYPE_MAX) {
-			acpi_os_printf (" Type %x [Invalid Type]", type);
-			return;
-		}
-
-		/* Decode the ACPI object type */
-
-		switch (obj_desc->common.type) {
-		case INTERNAL_TYPE_REFERENCE:
-			switch (obj_desc->reference.opcode) {
-			case AML_ZERO_OP:
-				acpi_os_printf ("[Const]         Zero (0) [Null Target]", 0);
-				break;
-
-			case AML_ONES_OP:
-				acpi_os_printf ("[Const]         Ones (0xFFFFFFFFFFFFFFFF) [No Limit]");
-				break;
-
-			case AML_ONE_OP:
-				acpi_os_printf ("[Const]         One (1)");
-				break;
-
-			case AML_REVISION_OP:
-				acpi_os_printf ("[Const]         Revision (%X)", ACPI_CA_SUPPORT_LEVEL);
-				break;
-
-			case AML_LOCAL_OP:
-				acpi_os_printf ("[Local%d]", obj_desc->reference.offset);
-				if (walk_state) {
-					obj_desc = walk_state->local_variables[obj_desc->reference.offset].object;
-					acpi_os_printf (" %p", obj_desc);
-					acpi_db_decode_internal_object (obj_desc);
-				}
-				break;
-
-			case AML_ARG_OP:
-				acpi_os_printf ("[Arg%d] ", obj_desc->reference.offset);
-				if (walk_state) {
-					obj_desc = walk_state->arguments[obj_desc->reference.offset].object;
-					acpi_os_printf (" %p", obj_desc);
-					acpi_db_decode_internal_object (obj_desc);
-				}
-				break;
-
-			case AML_DEBUG_OP:
-				acpi_os_printf ("[Debug] ");
-				break;
-
-			case AML_INDEX_OP:
-				acpi_os_printf ("[Index]   ");
-				acpi_db_decode_internal_object (obj_desc->reference.object);
-				break;
-
-			default:
-				break;
-
-			}
-			break;
-
-		default:
-			acpi_os_printf ("<Obj> ");
-			acpi_os_printf ("         ");
-			acpi_db_decode_internal_object (obj_desc);
-			break;
-		}
-	}
-
-	else {
-		acpi_os_printf ("<Not a valid ACPI Object Descriptor> ");
-	}
-
-	acpi_os_printf ("\n");
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_display_method_info
- *
- * PARAMETERS:  Start_op        - Root of the control method parse tree
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display information about the current method
- *
- ******************************************************************************/
-
-void
-acpi_db_display_method_info (
-	acpi_parse_object       *start_op)
-{
-	acpi_walk_state         *walk_state;
-	acpi_operand_object     *obj_desc;
-	acpi_namespace_node     *node;
-	acpi_parse_object       *root_op;
-	acpi_parse_object       *op;
-	const acpi_opcode_info  *op_info;
-	u32                     num_ops = 0;
-	u32                     num_operands = 0;
-	u32                     num_operators = 0;
-	u32                     num_remaining_ops = 0;
-	u32                     num_remaining_operands = 0;
-	u32                     num_remaining_operators = 0;
-	u32                     num_args;
-	u32                     concurrency;
-	u8                      count_remaining = FALSE;
-
-
-	walk_state = acpi_ds_get_current_walk_state (acpi_gbl_current_walk_list);
-	if (!walk_state) {
-		acpi_os_printf ("There is no method currently executing\n");
-		return;
-	}
-
-	obj_desc = walk_state->method_desc;
-	node = walk_state->method_node;
-
-	num_args = obj_desc->method.param_count;
-	concurrency = obj_desc->method.concurrency;
-
-	acpi_os_printf ("Currently executing control method is [%4.4s]\n", &node->name);
-	acpi_os_printf ("%X arguments, max concurrency = %X\n", num_args, concurrency);
-
-
-	root_op = start_op;
-	while (root_op->parent) {
-		root_op = root_op->parent;
-	}
-
-	op = root_op;
-
-	while (op) {
-		if (op == start_op) {
-			count_remaining = TRUE;
-		}
-
-		num_ops++;
-		if (count_remaining) {
-			num_remaining_ops++;
-		}
-
-		/* Decode the opcode */
-
-		op_info = acpi_ps_get_opcode_info (op->opcode);
-		switch (op_info->class) {
-		case AML_CLASS_ARGUMENT:
-			if (count_remaining) {
-				num_remaining_operands++;
-			}
-
-			num_operands++;
-			break;
-
-		case AML_CLASS_UNKNOWN:
-			/* Bad opcode or ASCII character */
-
-			continue;
-
-		default:
-			if (count_remaining) {
-				num_remaining_operators++;
-			}
-
-			num_operators++;
-			break;
-		}
-
-
-		op = acpi_ps_get_depth_next (start_op, op);
-	}
-
-	acpi_os_printf ("Method contains:     %X AML Opcodes - %X Operators, %X Operands\n",
-			 num_ops, num_operators, num_operands);
-
-	acpi_os_printf ("Remaining to execute: %X AML Opcodes - %X Operators, %X Operands\n",
-			 num_remaining_ops, num_remaining_operators, num_remaining_operands);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_display_locals
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display all locals for the currently running control method
- *
- ******************************************************************************/
-
-void
-acpi_db_display_locals (void)
-{
-	u32                     i;
-	acpi_walk_state         *walk_state;
-	acpi_operand_object     *obj_desc;
-	acpi_namespace_node     *node;
-
-
-	walk_state = acpi_ds_get_current_walk_state (acpi_gbl_current_walk_list);
-	if (!walk_state) {
-		acpi_os_printf ("There is no method currently executing\n");
-		return;
-	}
-
-	obj_desc = walk_state->method_desc;
-	node = walk_state->method_node;
-
-
-	acpi_os_printf ("Local Variables for method [%4.4s]:\n", &node->name);
-
-	for (i = 0; i < MTH_NUM_LOCALS; i++) {
-		obj_desc = walk_state->local_variables[i].object;
-		acpi_os_printf ("Local%d: ", i);
-		acpi_db_display_internal_object (obj_desc, walk_state);
-	}
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_display_arguments
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display all arguments for the currently running control method
- *
- ******************************************************************************/
-
-void
-acpi_db_display_arguments (void)
-{
-	u32                     i;
-	acpi_walk_state         *walk_state;
-	acpi_operand_object     *obj_desc;
-	u32                     num_args;
-	u32                     concurrency;
-	acpi_namespace_node     *node;
-
-
-	walk_state = acpi_ds_get_current_walk_state (acpi_gbl_current_walk_list);
-	if (!walk_state) {
-		acpi_os_printf ("There is no method currently executing\n");
-		return;
-	}
-
-	obj_desc = walk_state->method_desc;
-	node = walk_state->method_node;
-
-	num_args = obj_desc->method.param_count;
-	concurrency = obj_desc->method.concurrency;
-
-	acpi_os_printf ("Method [%4.4s] has %X arguments, max concurrency = %X\n", &node->name, num_args, concurrency);
-
-	for (i = 0; i < num_args; i++) {
-		obj_desc = walk_state->arguments[i].object;
-		acpi_os_printf ("Arg%d: ", i);
-		acpi_db_display_internal_object (obj_desc, walk_state);
-	}
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_display_results
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display current contents of a method result stack
- *
- ******************************************************************************/
-
-void
-acpi_db_display_results (void)
-{
-	u32                     i;
-	acpi_walk_state         *walk_state;
-	acpi_operand_object     *obj_desc;
-	u32                     num_results = 0;
-	acpi_namespace_node     *node;
-
-
-	walk_state = acpi_ds_get_current_walk_state (acpi_gbl_current_walk_list);
-	if (!walk_state) {
-		acpi_os_printf ("There is no method currently executing\n");
-		return;
-	}
-
-	obj_desc = walk_state->method_desc;
-	node = walk_state->method_node;
-
-	if (walk_state->results) {
-		num_results = walk_state->results->results.num_results;
-	}
-
-	acpi_os_printf ("Method [%4.4s] has %X stacked result objects\n", &node->name, num_results);
-
-	for (i = 0; i < num_results; i++) {
-		obj_desc = walk_state->results->results.obj_desc[i];
-		acpi_os_printf ("Result%d: ", i);
-		acpi_db_display_internal_object (obj_desc, walk_state);
-	}
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_display_calling_tree
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display current calling tree of nested control methods
- *
- ******************************************************************************/
-
-void
-acpi_db_display_calling_tree (void)
-{
-	u32                     i;
-	acpi_walk_state         *walk_state;
-	acpi_namespace_node     *node;
-
-
-	walk_state = acpi_ds_get_current_walk_state (acpi_gbl_current_walk_list);
-	if (!walk_state) {
-		acpi_os_printf ("There is no method currently executing\n");
-		return;
-	}
-
-	node = walk_state->method_node;
-
-	acpi_os_printf ("Current Control Method Call Tree\n");
-
-	for (i = 0; walk_state; i++) {
-		node = walk_state->method_node;
-
-		acpi_os_printf ("  [%4.4s]\n", &node->name);
-
-		walk_state = walk_state->next;
-	}
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_display_result_object
- *
- * PARAMETERS:  Obj_desc        - Object to be displayed
- *              Walk_state      - Current walk state
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display the result of an AML opcode
- *
- ******************************************************************************/
-
-void
-acpi_db_display_result_object (
-	acpi_operand_object     *obj_desc,
-	acpi_walk_state         *walk_state)
-{
-
-	/* TBD: [Future] We don't always want to display the result.
-	 * For now, only display if single stepping
-	 * however, this output is very useful in other contexts also
-	 */
-	if (!acpi_gbl_cm_single_step) {
-		return;
-	}
-
-	acpi_os_printf ("Result_obj: ");
-	acpi_db_display_internal_object (obj_desc, walk_state);
-	acpi_os_printf ("\n");
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_display_argument_object
- *
- * PARAMETERS:  Obj_desc        - Object to be displayed
- *              Walk_state      - Current walk state
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display the result of an AML opcode
- *
- ******************************************************************************/
-
-void
-acpi_db_display_argument_object (
-	acpi_operand_object     *obj_desc,
-	acpi_walk_state         *walk_state)
-{
-
-
-	if (!acpi_gbl_cm_single_step) {
-		return;
-	}
-
-	acpi_os_printf ("Arg_obj: ");
-	acpi_db_display_internal_object (obj_desc, walk_state);
-}
-
-#endif /* ENABLE_DEBUGGER */
-
diff -urNp linux-5400/drivers/acpi/debugger/dbexec.c linux-5410/drivers/acpi/debugger/dbexec.c
--- linux-5400/drivers/acpi/debugger/dbexec.c
+++ linux-5410/drivers/acpi/debugger/dbexec.c
@@ -1,404 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: dbexec - debugger control method execution
- *              $Revision: 34 $
- *
- ******************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include "acpi.h"
-#include "acparser.h"
-#include "acdispat.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "acparser.h"
-#include "acevents.h"
-#include "acinterp.h"
-#include "acdebug.h"
-#include "actables.h"
-
-#ifdef ENABLE_DEBUGGER
-
-#define _COMPONENT          ACPI_DEBUGGER
-	 MODULE_NAME         ("dbexec")
-
-
-db_method_info              acpi_gbl_db_method_info;
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_execute_method
- *
- * PARAMETERS:  Info            - Valid info segment
- *              Return_obj      - Where to put return object
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Execute a control method.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_db_execute_method (
-	db_method_info          *info,
-	acpi_buffer             *return_obj)
-{
-	acpi_status             status;
-	acpi_object_list        param_objects;
-	acpi_object             params[MTH_NUM_ARGS];
-	u32                     i;
-
-
-	if (acpi_gbl_db_output_to_file && !acpi_dbg_level) {
-		acpi_os_printf ("Warning: debug output is not enabled!\n");
-	}
-
-	/* Are there arguments to the method? */
-
-	if (info->args && info->args[0]) {
-		for (i = 0; info->args[i] && i < MTH_NUM_ARGS; i++) {
-			params[i].type              = ACPI_TYPE_INTEGER;
-			params[i].integer.value     = STRTOUL (info->args[i], NULL, 16);
-		}
-
-		param_objects.pointer       = params;
-		param_objects.count         = i;
-	}
-
-	else {
-		/* Setup default parameters */
-
-		params[0].type              = ACPI_TYPE_INTEGER;
-		params[0].integer.value     = 0x01020304;
-
-		params[1].type              = ACPI_TYPE_STRING;
-		params[1].string.length     = 12;
-		params[1].string.pointer    = "AML Debugger";
-
-		param_objects.pointer       = params;
-		param_objects.count         = 2;
-	}
-
-	/* Prepare for a return object of arbitrary size */
-
-	return_obj->pointer          = acpi_gbl_db_buffer;
-	return_obj->length           = ACPI_DEBUG_BUFFER_SIZE;
-
-
-	/* Do the actual method execution */
-
-	status = acpi_evaluate_object (NULL, info->pathname, &param_objects, return_obj);
-
-	acpi_gbl_cm_single_step = FALSE;
-	acpi_gbl_method_executing = FALSE;
-
-	return (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_execute_setup
- *
- * PARAMETERS:  Info            - Valid method info
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Setup info segment prior to method execution
- *
- ******************************************************************************/
-
-void
-acpi_db_execute_setup (
-	db_method_info          *info)
-{
-
-	/* Catenate the current scope to the supplied name */
-
-	info->pathname[0] = 0;
-	if ((info->name[0] != '\\') &&
-		(info->name[0] != '/')) {
-		STRCAT (info->pathname, acpi_gbl_db_scope_buf);
-	}
-
-	STRCAT (info->pathname, info->name);
-	acpi_db_prep_namestring (info->pathname);
-
-	acpi_db_set_output_destination (DB_DUPLICATE_OUTPUT);
-	acpi_os_printf ("Executing %s\n", info->pathname);
-
-	if (info->flags & EX_SINGLE_STEP) {
-		acpi_gbl_cm_single_step = TRUE;
-		acpi_db_set_output_destination (DB_CONSOLE_OUTPUT);
-	}
-
-	else {
-		/* No single step, allow redirection to a file */
-
-		acpi_db_set_output_destination (DB_REDIRECTABLE_OUTPUT);
-	}
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_get_outstanding_allocations
- *
- * PARAMETERS:  None
- *
- * RETURN:      Current global allocation count minus cache entries
- *
- * DESCRIPTION: Determine the current number of "outstanding" allocations --
- *              those allocations that have not been freed and also are not
- *              in one of the various object caches.
- *
- ******************************************************************************/
-
-u32
-acpi_db_get_outstanding_allocations (void)
-{
-	u32                     i;
-	u32                     outstanding = 0;
-
-
-#ifdef ACPI_DBG_TRACK_ALLOCATIONS
-
-	for (i = ACPI_MEM_LIST_FIRST_CACHE_LIST; i < ACPI_NUM_MEM_LISTS; i++) {
-		outstanding += (acpi_gbl_memory_lists[i].total_allocated -
-				  acpi_gbl_memory_lists[i].total_freed -
-				  acpi_gbl_memory_lists[i].cache_depth);
-	}
-#endif
-
-	return (outstanding);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_execute
- *
- * PARAMETERS:  Name                - Name of method to execute
- *              Args                - Parameters to the method
- *              Flags               - single step/no single step
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Execute a control method.  Name is relative to the current
- *              scope.
- *
- ******************************************************************************/
-
-void
-acpi_db_execute (
-	NATIVE_CHAR             *name,
-	NATIVE_CHAR             **args,
-	u32                     flags)
-{
-	acpi_status             status;
-	acpi_buffer             return_obj;
-
-
-#ifdef ACPI_DEBUG
-	u32                     previous_allocations;
-	u32                     allocations;
-
-
-	/* Memory allocation tracking */
-
-	previous_allocations = acpi_db_get_outstanding_allocations ();
-#endif
-
-	acpi_gbl_db_method_info.name = name;
-	acpi_gbl_db_method_info.args = args;
-	acpi_gbl_db_method_info.flags = flags;
-
-	acpi_db_execute_setup (&acpi_gbl_db_method_info);
-	status = acpi_db_execute_method (&acpi_gbl_db_method_info, &return_obj);
-
-	/*
-	 * Allow any handlers in separate threads to complete.
-	 * (Such as Notify handlers invoked from AML executed above).
-	 */
-	acpi_os_sleep (0, 10);
-
-
-#ifdef ACPI_DEBUG
-
-	/* Memory allocation tracking */
-
-	allocations = acpi_db_get_outstanding_allocations () - previous_allocations;
-
-	acpi_db_set_output_destination (DB_DUPLICATE_OUTPUT);
-
-	if (allocations > 0) {
-		acpi_os_printf ("Outstanding: %ld allocations after execution\n",
-				  allocations);
-	}
-#endif
-
-	if (ACPI_FAILURE (status)) {
-		acpi_os_printf ("Execution of %s failed with status %s\n",
-			acpi_gbl_db_method_info.pathname, acpi_format_exception (status));
-	}
-
-	else {
-		/* Display a return object, if any */
-
-		if (return_obj.length) {
-			acpi_os_printf ("Execution of %s returned object %p Buflen %X\n",
-				acpi_gbl_db_method_info.pathname, return_obj.pointer, return_obj.length);
-			acpi_db_dump_object (return_obj.pointer, 1);
-		}
-	}
-
-	acpi_db_set_output_destination (DB_CONSOLE_OUTPUT);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_method_thread
- *
- * PARAMETERS:  Context             - Execution info segment
- *
- * RETURN:      None
- *
- * DESCRIPTION: Debugger execute thread.  Waits for a command line, then
- *              simply dispatches it.
- *
- ******************************************************************************/
-
-void
-acpi_db_method_thread (
-	void                    *context)
-{
-	acpi_status             status;
-	db_method_info          *info = context;
-	u32                     i;
-	acpi_buffer             return_obj;
-
-
-	for (i = 0; i < info->num_loops; i++) {
-		status = acpi_db_execute_method (info, &return_obj);
-		if (ACPI_SUCCESS (status)) {
-			if (return_obj.length) {
-				acpi_os_printf ("Execution of %s returned object %p Buflen %X\n",
-					info->pathname, return_obj.pointer, return_obj.length);
-				acpi_db_dump_object (return_obj.pointer, 1);
-			}
-		}
-	}
-
-	/* Signal our completion */
-
-	acpi_os_signal_semaphore (info->thread_gate, 1);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_create_execution_threads
- *
- * PARAMETERS:  Num_threads_arg         - Number of threads to create
- *              Num_loops_arg           - Loop count for the thread(s)
- *              Method_name_arg         - Control method to execute
- *
- * RETURN:      None
- *
- * DESCRIPTION: Create threads to execute method(s)
- *
- ******************************************************************************/
-
-void
-acpi_db_create_execution_threads (
-	NATIVE_CHAR             *num_threads_arg,
-	NATIVE_CHAR             *num_loops_arg,
-	NATIVE_CHAR             *method_name_arg)
-{
-	acpi_status             status;
-	u32                     num_threads;
-	u32                     num_loops;
-	u32                     i;
-	acpi_handle             thread_gate;
-
-
-	/* Get the arguments */
-
-	num_threads = STRTOUL (num_threads_arg, NULL, 0);
-	num_loops = STRTOUL (num_loops_arg, NULL, 0);
-
-	if (!num_threads || !num_loops) {
-		acpi_os_printf ("Bad argument: Threads %X, Loops %X\n", num_threads, num_loops);
-		return;
-	}
-
-
-	/* Create the synchronization semaphore */
-
-	status = acpi_os_create_semaphore (1, 0, &thread_gate);
-	if (ACPI_FAILURE (status)) {
-		acpi_os_printf ("Could not create semaphore, %s\n", acpi_format_exception (status));
-		return;
-	}
-
-	/* Setup the context to be passed to each thread */
-
-	acpi_gbl_db_method_info.name = method_name_arg;
-	acpi_gbl_db_method_info.args = NULL;
-	acpi_gbl_db_method_info.flags = 0;
-	acpi_gbl_db_method_info.num_loops = num_loops;
-	acpi_gbl_db_method_info.thread_gate = thread_gate;
-
-	acpi_db_execute_setup (&acpi_gbl_db_method_info);
-
-
-	/* Create the threads */
-
-	acpi_os_printf ("Creating %X threads to execute %X times each\n", num_threads, num_loops);
-
-	for (i = 0; i < (num_threads); i++) {
-		acpi_os_queue_for_execution (OSD_PRIORITY_MED, acpi_db_method_thread, &acpi_gbl_db_method_info);
-	}
-
-
-	/* Wait for all threads to complete */
-
-	i = num_threads;
-	while (i)   /* Brain damage for OSD implementations that only support wait of 1 unit */ {
-		status = acpi_os_wait_semaphore (thread_gate, 1, WAIT_FOREVER);
-		i--;
-	}
-
-	/* Cleanup and exit */
-
-	acpi_os_delete_semaphore (thread_gate);
-
-	acpi_db_set_output_destination (DB_DUPLICATE_OUTPUT);
-	acpi_os_printf ("All threads (%X) have completed\n", num_threads);
-	acpi_db_set_output_destination (DB_CONSOLE_OUTPUT);
-}
-
-
-#endif /* ENABLE_DEBUGGER */
-
-
diff -urNp linux-5400/drivers/acpi/debugger/dbfileio.c linux-5410/drivers/acpi/debugger/dbfileio.c
--- linux-5400/drivers/acpi/debugger/dbfileio.c
+++ linux-5410/drivers/acpi/debugger/dbfileio.c
@@ -1,381 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: dbfileio - Debugger file I/O commands.  These can't usually
- *              be used when running the debugger in Ring 0 (Kernel mode)
- *              $Revision: 53 $
- *
- ******************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include "acpi.h"
-#include "acdebug.h"
-#include "acnamesp.h"
-#include "acparser.h"
-#include "acevents.h"
-#include "actables.h"
-
-#ifdef ENABLE_DEBUGGER
-
-#define _COMPONENT          ACPI_DEBUGGER
-	 MODULE_NAME         ("dbfileio")
-
-
-/*
- * NOTE: this is here for lack of a better place.  It is used in all
- * flavors of the debugger, need LCD file
- */
-#ifdef ACPI_APPLICATION
-#include <stdio.h>
-FILE                        *acpi_gbl_debug_file = NULL;
-#endif
-
-
-acpi_table_header           *acpi_gbl_db_table_ptr = NULL;
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_match_argument
- *
- * PARAMETERS:  User_argument           - User command line
- *              Arguments               - Array of commands to match against
- *
- * RETURN:      Index into command array or ACPI_TYPE_NOT_FOUND if not found
- *
- * DESCRIPTION: Search command array for a command match
- *
- ******************************************************************************/
-
-acpi_object_type8
-acpi_db_match_argument (
-	NATIVE_CHAR             *user_argument,
-	ARGUMENT_INFO           *arguments)
-{
-	u32                     i;
-
-
-	if (!user_argument || user_argument[0] == 0) {
-		return (ACPI_TYPE_NOT_FOUND);
-	}
-
-	for (i = 0; arguments[i].name; i++) {
-		if (STRSTR (arguments[i].name, user_argument) == arguments[i].name) {
-			return ((acpi_object_type8) i);
-		}
-	}
-
-	/* Argument not recognized */
-
-	return (ACPI_TYPE_NOT_FOUND);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_close_debug_file
- *
- * PARAMETERS:  None
- *
- * RETURN:      Status
- *
- * DESCRIPTION: If open, close the current debug output file
- *
- ******************************************************************************/
-
-void
-acpi_db_close_debug_file (
-	void)
-{
-
-#ifdef ACPI_APPLICATION
-
-	if (acpi_gbl_debug_file) {
-	   fclose (acpi_gbl_debug_file);
-	   acpi_gbl_debug_file = NULL;
-	   acpi_gbl_db_output_to_file = FALSE;
-	   acpi_os_printf ("Debug output file %s closed\n", acpi_gbl_db_debug_filename);
-	}
-#endif
-
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_open_debug_file
- *
- * PARAMETERS:  Name                - Filename to open
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Open a file where debug output will be directed.
- *
- ******************************************************************************/
-
-void
-acpi_db_open_debug_file (
-	NATIVE_CHAR             *name)
-{
-
-#ifdef ACPI_APPLICATION
-
-	acpi_db_close_debug_file ();
-	acpi_gbl_debug_file = fopen (name, "w+");
-	if (acpi_gbl_debug_file) {
-		acpi_os_printf ("Debug output file %s opened\n", name);
-		STRCPY (acpi_gbl_db_debug_filename, name);
-		acpi_gbl_db_output_to_file = TRUE;
-	}
-	else {
-		acpi_os_printf ("Could not open debug file %s\n", name);
-	}
-
-#endif
-}
-
-
-#ifdef ACPI_APPLICATION
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_load_table
- *
- * PARAMETERS:  fp              - File that contains table
- *              Table_ptr       - Return value, buffer with table
- *              Table_lenght    - Return value, length of table
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Load the DSDT from the file pointer
- *
- ******************************************************************************/
-
-acpi_status
-acpi_db_load_table(
-	FILE                    *fp,
-	acpi_table_header       **table_ptr,
-	u32                     *table_length)
-{
-	acpi_table_header       table_header;
-	u8                      *aml_start;
-	u32                     aml_length;
-	u32                     actual;
-	acpi_status             status;
-
-
-	/* Read the table header */
-
-	if (fread (&table_header, 1, sizeof (table_header), fp) != sizeof (acpi_table_header)) {
-		acpi_os_printf ("Couldn't read the table header\n");
-		return (AE_BAD_SIGNATURE);
-	}
-
-
-	/* Validate the table header/length */
-
-	status = acpi_tb_validate_table_header (&table_header);
-	if ((ACPI_FAILURE (status)) ||
-		(table_header.length > 524288)) /* 1/2 Mbyte should be enough */ {
-		acpi_os_printf ("Table header is invalid!\n");
-		return (AE_ERROR);
-	}
-
-
-	/* We only support a limited number of table types */
-
-	if (STRNCMP ((char *) table_header.signature, DSDT_SIG, 4) &&
-		STRNCMP ((char *) table_header.signature, PSDT_SIG, 4) &&
-		STRNCMP ((char *) table_header.signature, SSDT_SIG, 4)) {
-		acpi_os_printf ("Table signature is invalid\n");
-		DUMP_BUFFER (&table_header, sizeof (acpi_table_header));
-		return (AE_ERROR);
-	}
-
-	/* Allocate a buffer for the table */
-
-	*table_length = table_header.length;
-	*table_ptr = acpi_os_allocate ((size_t) *table_length);
-	if (!*table_ptr) {
-		acpi_os_printf ("Could not allocate memory for ACPI table %4.4s (size=%X)\n",
-				 table_header.signature, table_header.length);
-		return (AE_NO_MEMORY);
-	}
-
-
-	aml_start = (u8 *) *table_ptr + sizeof (table_header);
-	aml_length = *table_length - sizeof (table_header);
-
-	/* Copy the header to the buffer */
-
-	MEMCPY (*table_ptr, &table_header, sizeof (table_header));
-
-	/* Get the rest of the table */
-
-	actual = fread (aml_start, 1, (size_t) aml_length, fp);
-	if (actual == aml_length) {
-		return (AE_OK);
-	}
-
-	if (actual > 0) {
-		acpi_os_printf ("Warning - reading table, asked for %X got %X\n", aml_length, actual);
-		return (AE_OK);
-	}
-
-
-	acpi_os_printf ("Error - could not read the table file\n");
-	acpi_os_free (*table_ptr);
-	*table_ptr = NULL;
-	*table_length = 0;
-
-	return (AE_ERROR);
-}
-#endif
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Ae_local_load_table
- *
- * PARAMETERS:  Table_ptr       - pointer to a buffer containing the entire
- *                                table to be loaded
- *
- * RETURN:      Status
- *
- * DESCRIPTION: This function is called to load a table from the caller's
- *              buffer.  The buffer must contain an entire ACPI Table including
- *              a valid header.  The header fields will be verified, and if it
- *              is determined that the table is invalid, the call will fail.
- *
- *              If the call fails an appropriate status will be returned.
- *
- ******************************************************************************/
-
-acpi_status
-ae_local_load_table (
-	acpi_table_header       *table_ptr)
-{
-	acpi_status             status;
-	acpi_table_desc         table_info;
-
-
-	FUNCTION_TRACE ("Ae_local_load_table");
-
-	if (!table_ptr) {
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
-	}
-
-	/* Install the new table into the local data structures */
-
-	table_info.pointer = table_ptr;
-
-	status = acpi_tb_install_table (NULL, &table_info);
-	if (ACPI_FAILURE (status)) {
-		/* Free table allocated by Acpi_tb_get_table */
-
-		acpi_tb_delete_single_table (&table_info);
-		return_ACPI_STATUS (status);
-	}
-
-
-#ifndef PARSER_ONLY
-	status = acpi_ns_load_table (table_info.installed_desc, acpi_gbl_root_node);
-	if (ACPI_FAILURE (status)) {
-		/* Uninstall table and free the buffer */
-
-		acpi_tb_delete_acpi_table (ACPI_TABLE_DSDT);
-		return_ACPI_STATUS (status);
-	}
-#endif
-
-	return_ACPI_STATUS (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_load_acpi_table
- *
- * PARAMETERS:  Filname         - File where table is located
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Load an ACPI table from a file
- *
- ******************************************************************************/
-
-acpi_status
-acpi_db_load_acpi_table (
-	NATIVE_CHAR             *filename)
-{
-#ifdef ACPI_APPLICATION
-	FILE                    *fp;
-	acpi_status             status;
-	u32                     table_length;
-
-
-	/* Open the file */
-
-	fp = fopen (filename, "rb");
-	if (!fp) {
-		acpi_os_printf ("Could not open file %s\n", filename);
-		return (AE_ERROR);
-	}
-
-
-	/* Get the entire file */
-
-	acpi_os_printf ("Loading Acpi table from file %s\n", filename);
-	status = acpi_db_load_table (fp, &acpi_gbl_db_table_ptr, &table_length);
-	fclose(fp);
-
-	if (ACPI_FAILURE (status)) {
-		acpi_os_printf ("Couldn't get table from the file\n");
-		return (status);
-	}
-
-	/* Attempt to recognize and install the table */
-
-	status = ae_local_load_table (acpi_gbl_db_table_ptr);
-	if (ACPI_FAILURE (status)) {
-		if (status == AE_EXIST) {
-			acpi_os_printf ("Table %4.4s is already installed\n",
-					  &acpi_gbl_db_table_ptr->signature);
-		}
-		else {
-			acpi_os_printf ("Could not install table, %s\n",
-					  acpi_format_exception (status));
-		}
-
-		acpi_os_free (acpi_gbl_db_table_ptr);
-		return (status);
-	}
-
-	acpi_os_printf ("%4.4s at %p successfully installed and loaded\n",
-			  &acpi_gbl_db_table_ptr->signature, acpi_gbl_db_table_ptr);
-
-	acpi_gbl_acpi_hardware_present = FALSE;
-
-#endif  /* ACPI_APPLICATION */
-	return (AE_OK);
-}
-
-
-#endif  /* ENABLE_DEBUGGER */
-
diff -urNp linux-5400/drivers/acpi/debugger/dbhistry.c linux-5410/drivers/acpi/debugger/dbhistry.c
--- linux-5400/drivers/acpi/debugger/dbhistry.c
+++ linux-5410/drivers/acpi/debugger/dbhistry.c
@@ -1,201 +0,0 @@
-/******************************************************************************
- *
- * Module Name: dbhistry - debugger HISTORY command
- *              $Revision: 19 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include "acpi.h"
-#include "acparser.h"
-#include "acdispat.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "acparser.h"
-#include "acevents.h"
-#include "acinterp.h"
-#include "acdebug.h"
-#include "actables.h"
-
-#ifdef ENABLE_DEBUGGER
-
-#define _COMPONENT          ACPI_DEBUGGER
-	 MODULE_NAME         ("dbhistry")
-
-
-#define HI_NO_HISTORY       0
-#define HI_RECORD_HISTORY   1
-#define HISTORY_SIZE        20
-
-
-typedef struct history_info
-{
-	NATIVE_CHAR             command[80];
-	u32                     cmd_num;
-
-} HISTORY_INFO;
-
-
-HISTORY_INFO                acpi_gbl_history_buffer[HISTORY_SIZE];
-u16                         acpi_gbl_lo_history = 0;
-u16                         acpi_gbl_num_history = 0;
-u16                         acpi_gbl_next_history_index = 0;
-u32                         acpi_gbl_next_cmd_num = 1;
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_add_to_history
- *
- * PARAMETERS:  Command_line    - Command to add
- *
- * RETURN:      None
- *
- * DESCRIPTION: Add a command line to the history buffer.
- *
- ******************************************************************************/
-
-void
-acpi_db_add_to_history (
-	NATIVE_CHAR             *command_line)
-{
-
-
-	/* Put command into the next available slot */
-
-	STRCPY (acpi_gbl_history_buffer[acpi_gbl_next_history_index].command, command_line);
-
-	acpi_gbl_history_buffer[acpi_gbl_next_history_index].cmd_num = acpi_gbl_next_cmd_num;
-
-	/* Adjust indexes */
-
-	if ((acpi_gbl_num_history == HISTORY_SIZE) &&
-		(acpi_gbl_next_history_index == acpi_gbl_lo_history)) {
-		acpi_gbl_lo_history++;
-		if (acpi_gbl_lo_history >= HISTORY_SIZE) {
-			acpi_gbl_lo_history = 0;
-		}
-	}
-
-	acpi_gbl_next_history_index++;
-	if (acpi_gbl_next_history_index >= HISTORY_SIZE) {
-		acpi_gbl_next_history_index = 0;
-	}
-
-
-	acpi_gbl_next_cmd_num++;
-	if (acpi_gbl_num_history < HISTORY_SIZE) {
-		acpi_gbl_num_history++;
-	}
-
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_display_history
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display the contents of the history buffer
- *
- ******************************************************************************/
-
-void
-acpi_db_display_history (void)
-{
-	NATIVE_UINT             i;
-	u16                     history_index;
-
-
-	history_index = acpi_gbl_lo_history;
-
-	/* Dump entire history buffer */
-
-	for (i = 0; i < acpi_gbl_num_history; i++) {
-		acpi_os_printf ("%ld %s\n", acpi_gbl_history_buffer[history_index].cmd_num,
-				 acpi_gbl_history_buffer[history_index].command);
-
-		history_index++;
-		if (history_index >= HISTORY_SIZE) {
-			history_index = 0;
-		}
-	}
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_get_from_history
- *
- * PARAMETERS:  Command_num_arg         - String containing the number of the
- *                                        command to be retrieved
- *
- * RETURN:      None
- *
- * DESCRIPTION: Get a command from the history buffer
- *
- ******************************************************************************/
-
-NATIVE_CHAR *
-acpi_db_get_from_history (
-	NATIVE_CHAR             *command_num_arg)
-{
-	NATIVE_UINT             i;
-	u16                     history_index;
-	u32                     cmd_num;
-
-
-	if (command_num_arg == NULL) {
-		cmd_num = acpi_gbl_next_cmd_num - 1;
-	}
-
-	else {
-		cmd_num = STRTOUL (command_num_arg, NULL, 0);
-	}
-
-
-	/* Search history buffer */
-
-	history_index = acpi_gbl_lo_history;
-	for (i = 0; i < acpi_gbl_num_history; i++) {
-		if (acpi_gbl_history_buffer[history_index].cmd_num == cmd_num) {
-			/* Found the commnad, return it */
-
-			return (acpi_gbl_history_buffer[history_index].command);
-		}
-
-
-		history_index++;
-		if (history_index >= HISTORY_SIZE) {
-			history_index = 0;
-		}
-	}
-
-	acpi_os_printf ("Invalid history number: %d\n", history_index);
-	return (NULL);
-}
-
-
-#endif /* ENABLE_DEBUGGER */
-
diff -urNp linux-5400/drivers/acpi/debugger/dbinput.c linux-5410/drivers/acpi/debugger/dbinput.c
--- linux-5400/drivers/acpi/debugger/dbinput.c
+++ linux-5410/drivers/acpi/debugger/dbinput.c
@@ -1,924 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: dbinput - user front-end to the AML debugger
- *              $Revision: 72 $
- *
- ******************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include "acpi.h"
-#include "acparser.h"
-#include "actables.h"
-#include "acnamesp.h"
-#include "acinterp.h"
-#include "acdebug.h"
-
-
-#ifdef ENABLE_DEBUGGER
-
-#define _COMPONENT          ACPI_DEBUGGER
-	 MODULE_NAME         ("dbinput")
-
-
-/*
- * Globals that are specific to the debugger
- */
-
-NATIVE_CHAR                 acpi_gbl_db_line_buf[80];
-NATIVE_CHAR                 acpi_gbl_db_parsed_buf[80];
-NATIVE_CHAR                 acpi_gbl_db_scope_buf[40];
-NATIVE_CHAR                 acpi_gbl_db_debug_filename[40];
-NATIVE_CHAR                 *acpi_gbl_db_args[DB_MAX_ARGS];
-NATIVE_CHAR                 *acpi_gbl_db_buffer = NULL;
-NATIVE_CHAR                 *acpi_gbl_db_filename = NULL;
-u8                          acpi_gbl_db_output_to_file = FALSE;
-
-u32                         acpi_gbl_db_debug_level = ACPI_LV_VERBOSITY2;
-u32                         acpi_gbl_db_console_debug_level = NORMAL_DEFAULT | ACPI_LV_TABLES;
-u8                          acpi_gbl_db_output_flags = DB_CONSOLE_OUTPUT;
-
-
-u8                          acpi_gbl_db_opt_tables    = FALSE;
-u8                          acpi_gbl_db_opt_disasm    = FALSE;
-u8                          acpi_gbl_db_opt_stats     = FALSE;
-u8                          acpi_gbl_db_opt_parse_jit = FALSE;
-u8                          acpi_gbl_db_opt_verbose   = TRUE;
-u8                          acpi_gbl_db_opt_ini_methods = TRUE;
-
-/*
- * Statistic globals
- */
-u16                         acpi_gbl_obj_type_count[INTERNAL_TYPE_NODE_MAX+1];
-u16                         acpi_gbl_node_type_count[INTERNAL_TYPE_NODE_MAX+1];
-u16                         acpi_gbl_obj_type_count_misc;
-u16                         acpi_gbl_node_type_count_misc;
-u32                         acpi_gbl_num_nodes;
-u32                         acpi_gbl_num_objects;
-
-
-u32                         acpi_gbl_size_of_parse_tree;
-u32                         acpi_gbl_size_of_method_trees;
-u32                         acpi_gbl_size_of_node_entries;
-u32                         acpi_gbl_size_of_acpi_objects;
-
-/*
- * Top-level debugger commands.
- *
- * This list of commands must match the string table below it
- */
-
-enum acpi_ex_debugger_commands
-{
-	CMD_NOT_FOUND = 0,
-	CMD_NULL,
-	CMD_ALLOCATIONS,
-	CMD_ARGS,
-	CMD_ARGUMENTS,
-	CMD_BREAKPOINT,
-	CMD_CALL,
-	CMD_CLOSE,
-	CMD_DEBUG,
-	CMD_DUMP,
-	CMD_ENABLEACPI,
-	CMD_EVENT,
-	CMD_EXECUTE,
-	CMD_EXIT,
-	CMD_FIND,
-	CMD_GO,
-	CMD_HELP,
-	CMD_HELP2,
-	CMD_HISTORY,
-	CMD_HISTORY_EXE,
-	CMD_HISTORY_LAST,
-	CMD_INFORMATION,
-	CMD_INTO,
-	CMD_LEVEL,
-	CMD_LIST,
-	CMD_LOAD,
-	CMD_LOCALS,
-	CMD_LOCKS,
-	CMD_METHODS,
-	CMD_NAMESPACE,
-	CMD_NOTIFY,
-	CMD_OBJECT,
-	CMD_OPEN,
-	CMD_OWNER,
-	CMD_PREFIX,
-	CMD_QUIT,
-	CMD_REFERENCES,
-	CMD_RESOURCES,
-	CMD_RESULTS,
-	CMD_SET,
-	CMD_STATS,
-	CMD_STOP,
-	CMD_TABLES,
-	CMD_TERMINATE,
-	CMD_THREADS,
-	CMD_TREE,
-	CMD_UNLOAD
-};
-
-#define CMD_FIRST_VALID     2
-
-
-const COMMAND_INFO          acpi_gbl_db_commands[] =
-{ {"<NOT FOUND>",  0},
-	{"<NULL>",       0},
-	{"ALLOCATIONS",  0},
-	{"ARGS",         0},
-	{"ARGUMENTS",    0},
-	{"BREAKPOINT",   1},
-	{"CALL",         0},
-	{"CLOSE",        0},
-	{"DEBUG",        1},
-	{"DUMP",         1},
-	{"ENABLEACPI",   0},
-	{"EVENT",        1},
-	{"EXECUTE",      1},
-	{"EXIT",         0},
-	{"FIND",         1},
-	{"GO",           0},
-	{"HELP",         0},
-	{"?",            0},
-	{"HISTORY",      0},
-	{"!",            1},
-	{"!!",           0},
-	{"INFORMATION",  0},
-	{"INTO",         0},
-	{"LEVEL",        0},
-	{"LIST",         0},
-	{"LOAD",         1},
-	{"LOCALS",       0},
-	{"LOCKS",        0},
-	{"METHODS",      0},
-	{"NAMESPACE",    0},
-	{"NOTIFY",       2},
-	{"OBJECT",       1},
-	{"OPEN",         1},
-	{"OWNER",        1},
-	{"PREFIX",       0},
-	{"QUIT",         0},
-	{"REFERENCES",   1},
-	{"RESOURCES",    1},
-	{"RESULTS",      0},
-	{"SET",          3},
-	{"STATS",        0},
-	{"STOP",         0},
-	{"TABLES",       0},
-	{"TERMINATE",    0},
-	{"THREADS",      3},
-	{"TREE",         0},
-	{"UNLOAD",       1},
-	{NULL,           0}
-};
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_display_help
- *
- * PARAMETERS:  Help_type       - Subcommand (optional)
- *
- * RETURN:      None
- *
- * DESCRIPTION: Print a usage message.
- *
- ******************************************************************************/
-
-void
-acpi_db_display_help (
-	NATIVE_CHAR             *help_type)
-{
-
-
-	/* No parameter, just give the overview */
-
-	if (!help_type)
-	{
-		acpi_os_printf ("ACPI CA Debugger Commands\n\n");
-		acpi_os_printf ("The following classes of commands are available. Help is available for\n");
-		acpi_os_printf ("each class by entering \"Help <Class_name>\"\n\n");
-		acpi_os_printf ("  [GENERAL]       General-Purpose Commands\n");
-		acpi_os_printf ("  [NAMESPACE]     Namespace Access Commands\n");
-		acpi_os_printf ("  [METHOD]        Control Method Execution Commands\n");
-		acpi_os_printf ("  [FILE]          File I/O Commands\n");
-		return;
-
-	}
-
-
-	/*
-	 * Parameter is the command class
-	 *
-	 * The idea here is to keep each class of commands smaller than a screenful
-	 */
-
-	switch (help_type[0])
-	{
-	case 'G':
-		acpi_os_printf ("\n_general-Purpose Commands\n\n");
-		acpi_os_printf ("Allocations                       Display list of current memory allocations\n");
-		acpi_os_printf ("Dump <Address>|<Namepath>\n");
-		acpi_os_printf ("   [Byte|Word|Dword|Qword]        Display ACPI objects or memory\n");
-		acpi_os_printf ("Enable_acpi                       Enable ACPI (hardware) mode\n");
-		acpi_os_printf ("Help                              This help screen\n");
-		acpi_os_printf ("History                           Display command history buffer\n");
-		acpi_os_printf ("Level [<Debug_level>] [console]   Get/Set debug level for file or console\n");
-		acpi_os_printf ("Locks                             Current status of internal mutexes\n");
-		acpi_os_printf ("Quit or Exit                      Exit this command\n");
-		acpi_os_printf ("Stats [Allocations|Memory|Misc\n");
-		acpi_os_printf ("     |Objects|Tables]             Display namespace and memory statistics\n");
-		acpi_os_printf ("Tables                            Display info about loaded ACPI tables\n");
-		acpi_os_printf ("Unload <Table_sig> [Instance]     Unload an ACPI table\n");
-		acpi_os_printf ("! <Command_number>                Execute command from history buffer\n");
-		acpi_os_printf ("!!                                Execute last command again\n");
-		return;
-
-	case 'N':
-		acpi_os_printf ("\n_namespace Access Commands\n\n");
-		acpi_os_printf ("Debug <Namepath> [Arguments]      Single Step a control method\n");
-		acpi_os_printf ("Event <F|G> <Value>               Generate Acpi_event (Fixed/GPE)\n");
-		acpi_os_printf ("Execute <Namepath> [Arguments]    Execute control method\n");
-		acpi_os_printf ("Find <Name> (? is wildcard)       Find ACPI name(s) with wildcards\n");
-		acpi_os_printf ("Method                            Display list of loaded control methods\n");
-		acpi_os_printf ("Namespace [<Addr>|<Path>] [Depth] Display loaded namespace tree/subtree\n");
-		acpi_os_printf ("Notify <Name_path> <Value>        Send a notification\n");
-		acpi_os_printf ("Objects <Object_type>             Display all objects of the given type\n");
-		acpi_os_printf ("Owner <Owner_id> [Depth]          Display loaded namespace by object owner\n");
-		acpi_os_printf ("Prefix [<Name_path>]              Set or Get current execution prefix\n");
-		acpi_os_printf ("References <Addr>                 Find all references to object at addr\n");
-		acpi_os_printf ("Resources xxx                     Get and display resources\n");
-		acpi_os_printf ("Terminate                         Delete namespace and all internal objects\n");
-		acpi_os_printf ("Thread <Threads><Loops><Name_path> Spawn threads to execute method(s)\n");
-		return;
-
-	case 'M':
-		acpi_os_printf ("\n_control Method Execution Commands\n\n");
-		acpi_os_printf ("Arguments (or Args)               Display method arguments\n");
-		acpi_os_printf ("Breakpoint <Aml_offset>           Set an AML execution breakpoint\n");
-		acpi_os_printf ("Call                              Run to next control method invocation\n");
-		acpi_os_printf ("Go                                Allow method to run to completion\n");
-		acpi_os_printf ("Information                       Display info about the current method\n");
-		acpi_os_printf ("Into                              Step into (not over) a method call\n");
-		acpi_os_printf ("List [# of Aml Opcodes]           Display method ASL statements\n");
-		acpi_os_printf ("Locals                            Display method local variables\n");
-		acpi_os_printf ("Results                           Display method result stack\n");
-		acpi_os_printf ("Set <A|L> <#> <Value>             Set method data (Arguments/Locals)\n");
-		acpi_os_printf ("Stop                              Terminate control method\n");
-		acpi_os_printf ("Tree                              Display control method calling tree\n");
-		acpi_os_printf ("<Enter>                           Single step next AML opcode (over calls)\n");
-		return;
-
-	case 'F':
-		acpi_os_printf ("\n_file I/O Commands\n\n");
-		acpi_os_printf ("Close                             Close debug output file\n");
-		acpi_os_printf ("Open <Output Filename>            Open a file for debug output\n");
-		acpi_os_printf ("Load <Input Filename>             Load ACPI table from a file\n");
-		return;
-
-	default:
-		acpi_os_printf ("Unrecognized Command Class: %x\n", help_type);
-		return;
-	}
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_get_next_token
- *
- * PARAMETERS:  String          - Command buffer
- *              Next            - Return value, end of next token
- *
- * RETURN:      Pointer to the start of the next token.
- *
- * DESCRIPTION: Command line parsing.  Get the next token on the command line
- *
- ******************************************************************************/
-
-NATIVE_CHAR *
-acpi_db_get_next_token (
-	NATIVE_CHAR             *string,
-	NATIVE_CHAR             **next)
-{
-	NATIVE_CHAR             *start;
-
-	/* At end of buffer? */
-
-	if (!string || !(*string))
-	{
-		return (NULL);
-	}
-
-
-	/* Get rid of any spaces at the beginning */
-
-	if (*string == ' ')
-	{
-		while (*string && (*string == ' '))
-		{
-			string++;
-		}
-
-		if (!(*string))
-		{
-			return (NULL);
-		}
-	}
-
-	start = string;
-
-	/* Find end of token */
-
-	while (*string && (*string != ' '))
-	{
-		string++;
-	}
-
-
-	if (!(*string))
-	{
-		*next = NULL;
-	}
-
-	else
-	{
-		*string = 0;
-		*next = string + 1;
-	}
-
-	return (start);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_get_line
- *
- * PARAMETERS:  Input_buffer        - Command line buffer
- *
- * RETURN:      None
- *
- * DESCRIPTION: Get the next command line from the user.  Gets entire line
- *              up to the next newline
- *
- ******************************************************************************/
-
-u32
-acpi_db_get_line (
-	NATIVE_CHAR             *input_buffer)
-{
-	u32                     i;
-	u32                     count;
-	NATIVE_CHAR             *next;
-	NATIVE_CHAR             *this;
-
-
-	STRCPY (acpi_gbl_db_parsed_buf, input_buffer);
-	STRUPR (acpi_gbl_db_parsed_buf);
-
-	this = acpi_gbl_db_parsed_buf;
-	for (i = 0; i < DB_MAX_ARGS; i++)
-	{
-		acpi_gbl_db_args[i] = acpi_db_get_next_token (this, &next);
-		if (!acpi_gbl_db_args[i])
-		{
-			break;
-		}
-
-		this = next;
-	}
-
-
-	/* Uppercase the actual command */
-
-	if (acpi_gbl_db_args[0])
-	{
-		STRUPR (acpi_gbl_db_args[0]);
-	}
-
-	count = i;
-	if (count)
-	{
-		count--;  /* Number of args only */
-	}
-
-	return (count);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_match_command
- *
- * PARAMETERS:  User_command            - User command line
- *
- * RETURN:      Index into command array, -1 if not found
- *
- * DESCRIPTION: Search command array for a command match
- *
- ******************************************************************************/
-
-u32
-acpi_db_match_command (
-	NATIVE_CHAR             *user_command)
-{
-	u32                     i;
-
-
-	if (!user_command || user_command[0] == 0)
-	{
-		return (CMD_NULL);
-	}
-
-	for (i = CMD_FIRST_VALID; acpi_gbl_db_commands[i].name; i++)
-	{
-		if (STRSTR (acpi_gbl_db_commands[i].name, user_command) == acpi_gbl_db_commands[i].name)
-		{
-			return (i);
-		}
-	}
-
-	/* Command not recognized */
-
-	return (CMD_NOT_FOUND);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_command_dispatch
- *
- * PARAMETERS:  Input_buffer        - Command line buffer
- *              Walk_state          - Current walk
- *              Op                  - Current (executing) parse op
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Command dispatcher.  Called from two places:
- *
- ******************************************************************************/
-
-acpi_status
-acpi_db_command_dispatch (
-	NATIVE_CHAR             *input_buffer,
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op)
-{
-	u32                     temp;
-	u32                     command_index;
-	u32                     param_count;
-	NATIVE_CHAR             *command_line;
-	acpi_status             status = AE_CTRL_TRUE;
-
-
-	/* If Acpi_terminate has been called, terminate this thread */
-
-	if (acpi_gbl_db_terminate_threads)
-	{
-		return (AE_CTRL_TERMINATE);
-	}
-
-	param_count = acpi_db_get_line (input_buffer);
-	command_index = acpi_db_match_command (acpi_gbl_db_args[0]);
-	temp = 0;
-
-	/* Verify that we have the minimum number of params */
-
-	if (param_count < acpi_gbl_db_commands[command_index].min_args)
-	{
-		acpi_os_printf ("%d parameters entered, [%s] requires %d parameters\n",
-				  param_count, acpi_gbl_db_commands[command_index].name, acpi_gbl_db_commands[command_index].min_args);
-		return (AE_CTRL_TRUE);
-	}
-
-	/* Decode and dispatch the command */
-
-	switch (command_index)
-	{
-	case CMD_NULL:
-		if (op)
-		{
-			return (AE_OK);
-		}
-		break;
-
-	case CMD_ALLOCATIONS:
-
-#ifdef ACPI_DBG_TRACK_ALLOCATIONS
-		acpi_ut_dump_allocations ((u32) -1, NULL);
-#endif
-		break;
-
-	case CMD_ARGS:
-	case CMD_ARGUMENTS:
-		acpi_db_display_arguments ();
-		break;
-
-	case CMD_BREAKPOINT:
-		acpi_db_set_method_breakpoint (acpi_gbl_db_args[1], walk_state, op);
-		break;
-
-	case CMD_CALL:
-		acpi_db_set_method_call_breakpoint (op);
-		status = AE_OK;
-		break;
-
-	case CMD_CLOSE:
-		acpi_db_close_debug_file ();
-		break;
-
-	case CMD_DEBUG:
-		acpi_db_execute (acpi_gbl_db_args[1], &acpi_gbl_db_args[2], EX_SINGLE_STEP);
-		break;
-
-	case CMD_DUMP:
-		acpi_db_decode_and_display_object (acpi_gbl_db_args[1], acpi_gbl_db_args[2]);
-		break;
-
-	case CMD_ENABLEACPI:
-		status = acpi_enable();
-		if (ACPI_FAILURE(status))
-		{
-			acpi_os_printf("Acpi_enable failed (Status=%X)\n", status);
-			return (status);
-		}
-		break;
-
-	case CMD_EVENT:
-		acpi_os_printf ("Event command not implemented\n");
-		break;
-
-	case CMD_EXECUTE:
-		acpi_db_execute (acpi_gbl_db_args[1], &acpi_gbl_db_args[2], EX_NO_SINGLE_STEP);
-		break;
-
-	case CMD_FIND:
-		acpi_db_find_name_in_namespace (acpi_gbl_db_args[1]);
-		break;
-
-	case CMD_GO:
-		acpi_gbl_cm_single_step = FALSE;
-		return (AE_OK);
-
-	case CMD_HELP:
-	case CMD_HELP2:
-		acpi_db_display_help (acpi_gbl_db_args[1]);
-		break;
-
-	case CMD_HISTORY:
-		acpi_db_display_history ();
-		break;
-
-	case CMD_HISTORY_EXE:
-		command_line = acpi_db_get_from_history (acpi_gbl_db_args[1]);
-		if (!command_line)
-		{
-			return (AE_CTRL_TRUE);
-		}
-
-		status = acpi_db_command_dispatch (command_line, walk_state, op);
-		if (ACPI_SUCCESS (status))
-		{
-			status = AE_CTRL_TRUE;
-		}
-		return (status);
-		break;
-
-	case CMD_HISTORY_LAST:
-		command_line = acpi_db_get_from_history (NULL);
-		if (!command_line)
-		{
-			return (AE_CTRL_TRUE);
-		}
-
-		status = acpi_db_command_dispatch (command_line, walk_state, op);
-		if (ACPI_SUCCESS (status))
-		{
-			status = AE_CTRL_TRUE;
-		}
-		return (status);
-
-	case CMD_INFORMATION:
-		acpi_db_display_method_info (op);
-		break;
-
-	case CMD_INTO:
-		if (op)
-		{
-			acpi_gbl_cm_single_step = TRUE;
-
-/* TBD: Must get current walk state */
-			/* Acpi_gbl_Method_breakpoint = 0; */
-			return (AE_OK);
-		}
-		break;
-
-	case CMD_LEVEL:
-		if (param_count == 0)
-		{
-			acpi_os_printf ("Current debug level for file output is:  %8.8lX\n", acpi_gbl_db_debug_level);
-			acpi_os_printf ("Current debug level for console output is: %8.8lX\n", acpi_gbl_db_console_debug_level);
-		}
-		else if (param_count == 2)
-		{
-			temp = acpi_gbl_db_console_debug_level;
-			acpi_gbl_db_console_debug_level = STRTOUL (acpi_gbl_db_args[1], NULL, 16);
-			acpi_os_printf ("Debug Level for console output was %8.8lX, now %8.8lX\n", temp, acpi_gbl_db_console_debug_level);
-		}
-		else
-		{
-			temp = acpi_gbl_db_debug_level;
-			acpi_gbl_db_debug_level = STRTOUL (acpi_gbl_db_args[1], NULL, 16);
-			acpi_os_printf ("Debug Level for file output was %8.8lX, now %8.8lX\n", temp, acpi_gbl_db_debug_level);
-		}
-		break;
-
-	case CMD_LIST:
-		acpi_db_disassemble_aml (acpi_gbl_db_args[1], op);
-		break;
-
-	case CMD_LOAD:
-		status = acpi_db_load_acpi_table (acpi_gbl_db_args[1]);
-		if (ACPI_FAILURE (status))
-		{
-			return (status);
-		}
-		break;
-
-	case CMD_LOCKS:
-		acpi_db_display_locks ();
-		break;
-
-	case CMD_LOCALS:
-		acpi_db_display_locals ();
-		break;
-
-	case CMD_METHODS:
-		acpi_db_display_objects ("METHOD", acpi_gbl_db_args[1]);
-		break;
-
-	case CMD_NAMESPACE:
-		acpi_db_dump_namespace (acpi_gbl_db_args[1], acpi_gbl_db_args[2]);
-		break;
-
-	case CMD_NOTIFY:
-		temp = STRTOUL (acpi_gbl_db_args[2], NULL, 0);
-		acpi_db_send_notify (acpi_gbl_db_args[1], temp);
-		break;
-
-	case CMD_OBJECT:
-		acpi_db_display_objects (STRUPR (acpi_gbl_db_args[1]), acpi_gbl_db_args[2]);
-		break;
-
-	case CMD_OPEN:
-		acpi_db_open_debug_file (acpi_gbl_db_args[1]);
-		break;
-
-	case CMD_OWNER:
-		acpi_db_dump_namespace_by_owner (acpi_gbl_db_args[1], acpi_gbl_db_args[2]);
-		break;
-
-	case CMD_PREFIX:
-		acpi_db_set_scope (acpi_gbl_db_args[1]);
-		break;
-
-	case CMD_REFERENCES:
-		acpi_db_find_references (acpi_gbl_db_args[1]);
-		break;
-
-	case CMD_RESOURCES:
-		acpi_db_display_resources (acpi_gbl_db_args[1]);
-		break;
-
-	case CMD_RESULTS:
-		acpi_db_display_results ();
-		break;
-
-	case CMD_SET:
-		acpi_db_set_method_data (acpi_gbl_db_args[1], acpi_gbl_db_args[2], acpi_gbl_db_args[3]);
-		break;
-
-	case CMD_STATS:
-		acpi_db_display_statistics (acpi_gbl_db_args[1]);
-		break;
-
-	case CMD_STOP:
-		return (AE_AML_ERROR);
-		break;
-
-	case CMD_TABLES:
-		acpi_db_display_table_info (acpi_gbl_db_args[1]);
-		break;
-
-	case CMD_TERMINATE:
-		acpi_db_set_output_destination (DB_REDIRECTABLE_OUTPUT);
-		acpi_ut_subsystem_shutdown ();
-
-		/* TBD: [Restructure] Need some way to re-initialize without re-creating the semaphores! */
-
-		/*  Acpi_initialize (NULL); */
-		break;
-
-	case CMD_THREADS:
-		acpi_db_create_execution_threads (acpi_gbl_db_args[1], acpi_gbl_db_args[2], acpi_gbl_db_args[3]);
-		break;
-
-	case CMD_TREE:
-		acpi_db_display_calling_tree ();
-		break;
-
-	case CMD_UNLOAD:
-		acpi_db_unload_acpi_table (acpi_gbl_db_args[1], acpi_gbl_db_args[2]);
-		break;
-
-	case CMD_EXIT:
-	case CMD_QUIT:
-		if (op)
-		{
-			acpi_os_printf ("Method execution terminated\n");
-			return (AE_CTRL_TERMINATE);
-		}
-
-		if (!acpi_gbl_db_output_to_file)
-		{
-			acpi_dbg_level = DEBUG_DEFAULT;
-		}
-
-		/* Shutdown */
-
-		/* Acpi_ut_subsystem_shutdown (); */
-		acpi_db_close_debug_file ();
-
-		acpi_gbl_db_terminate_threads = TRUE;
-
-		return (AE_CTRL_TERMINATE);
-
-	case CMD_NOT_FOUND:
-		acpi_os_printf ("Unknown Command\n");
-		return (AE_CTRL_TRUE);
-	}
-
-
-	/* Add all commands that come here to the history buffer */
-
-	acpi_db_add_to_history (input_buffer);
-	return (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_execute_thread
- *
- * PARAMETERS:  Context         - Not used
- *
- * RETURN:      None
- *
- * DESCRIPTION: Debugger execute thread.  Waits for a command line, then
- *              simply dispatches it.
- *
- ******************************************************************************/
-
-void
-acpi_db_execute_thread (
-	void                    *context)
-{
-	acpi_status             status = AE_OK;
-
-
-	while (status != AE_CTRL_TERMINATE)
-	{
-		acpi_gbl_method_executing = FALSE;
-		acpi_gbl_step_to_next_call = FALSE;
-
-		acpi_ut_acquire_mutex (ACPI_MTX_DEBUG_CMD_READY);
-		status = acpi_db_command_dispatch (acpi_gbl_db_line_buf, NULL, NULL);
-		acpi_ut_release_mutex (ACPI_MTX_DEBUG_CMD_COMPLETE);
-	}
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_single_thread
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Debugger execute thread.  Waits for a command line, then
- *              simply dispatches it.
- *
- ******************************************************************************/
-
-void
-acpi_db_single_thread (
-	void)
-{
-	acpi_status             status = AE_OK;
-
-
-	acpi_gbl_method_executing = FALSE;
-	acpi_gbl_step_to_next_call = FALSE;
-
-	status = acpi_db_command_dispatch (acpi_gbl_db_line_buf, NULL, NULL);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_user_commands
- *
- * PARAMETERS:  Prompt              - User prompt (depends on mode)
- *              Op                  - Current executing parse op
- *
- * RETURN:      None
- *
- * DESCRIPTION: Command line execution for the AML debugger.  Commands are
- *              matched and dispatched here.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_db_user_commands (
-	NATIVE_CHAR             prompt,
-	acpi_parse_object       *op)
-{
-	acpi_status             status = AE_OK;
-
-
-	/* TBD: [Restructure] Need a separate command line buffer for step mode */
-
-	while (!acpi_gbl_db_terminate_threads)
-	{
-		/* Force output to console until a command is entered */
-
-		acpi_db_set_output_destination (DB_CONSOLE_OUTPUT);
-
-		/* Different prompt if method is executing */
-
-		if (!acpi_gbl_method_executing)
-		{
-			acpi_os_printf ("%1c ", DB_COMMAND_PROMPT);
-		}
-		else
-		{
-			acpi_os_printf ("%1c ", DB_EXECUTE_PROMPT);
-		}
-
-		/* Get the user input line */
-
-		acpi_os_get_line (acpi_gbl_db_line_buf);
-
-
-		/* Check for single or multithreaded debug */
-
-		if (acpi_gbl_debugger_configuration & DEBUGGER_MULTI_THREADED)
-		{
-			/*
-			 * Signal the debug thread that we have a command to execute,
-			 * and wait for the command to complete.
-			 */
-			acpi_ut_release_mutex (ACPI_MTX_DEBUG_CMD_READY);
-			acpi_ut_acquire_mutex (ACPI_MTX_DEBUG_CMD_COMPLETE);
-		}
-
-		else
-		{
-			/* Just call to the command line interpreter */
-
-			acpi_db_single_thread ();
-		}
-	}
-
-
-	/*
-	 * Only this thread (the original thread) should actually terminate the subsystem,
-	 * because all the semaphores are deleted during termination
-	 */
-	acpi_terminate ();
-	return (status);
-}
-
-
-#endif  /* ENABLE_DEBUGGER */
-
diff -urNp linux-5400/drivers/acpi/debugger/dbstats.c linux-5410/drivers/acpi/debugger/dbstats.c
--- linux-5400/drivers/acpi/debugger/dbstats.c
+++ linux-5410/drivers/acpi/debugger/dbstats.c
@@ -1,456 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: dbstats - Generation and display of ACPI table statistics
- *              $Revision: 47 $
- *
- ******************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include <acpi.h>
-#include <acdebug.h>
-#include <amlcode.h>
-#include <acparser.h>
-#include <acnamesp.h>
-
-#ifdef ENABLE_DEBUGGER
-
-#define _COMPONENT          ACPI_DEBUGGER
-	 MODULE_NAME         ("dbstats")
-
-/*
- * Statistics subcommands
- */
-ARGUMENT_INFO               acpi_db_stat_types [] =
-{ {"ALLOCATIONS"},
-	{"OBJECTS"},
-	{"MEMORY"},
-	{"MISC"},
-	{"TABLES"},
-	{"SIZES"},
-	{"STACK"},
-	{NULL}           /* Must be null terminated */
-};
-
-#define CMD_ALLOCATIONS     0
-#define CMD_OBJECTS         1
-#define CMD_MEMORY          2
-#define CMD_MISC            3
-#define CMD_TABLES          4
-#define CMD_SIZES           5
-#define CMD_STACK           6
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_enumerate_object
- *
- * PARAMETERS:  Obj_desc            - Object to be counted
- *
- * RETURN:      None
- *
- * DESCRIPTION: Add this object to the global counts, by object type.
- *              Recursively handles subobjects and packages.
- *
- *              [TBD] Restructure - remove recursion.
- *
- ******************************************************************************/
-
-void
-acpi_db_enumerate_object (
-	acpi_operand_object     *obj_desc)
-{
-	u32                     type;
-	u32                     i;
-
-
-	if (!obj_desc)
-	{
-		return;
-	}
-
-
-	/* Enumerate this object first */
-
-	acpi_gbl_num_objects++;
-
-	type = obj_desc->common.type;
-	if (type > INTERNAL_TYPE_NODE_MAX)
-	{
-		acpi_gbl_obj_type_count_misc++;
-	}
-	else
-	{
-		acpi_gbl_obj_type_count [type]++;
-	}
-
-	/* Count the sub-objects */
-
-	switch (type)
-	{
-	case ACPI_TYPE_PACKAGE:
-		for (i = 0; i< obj_desc->package.count; i++)
-		{
-			acpi_db_enumerate_object (obj_desc->package.elements[i]);
-		}
-		break;
-
-	case ACPI_TYPE_DEVICE:
-		acpi_db_enumerate_object (obj_desc->device.sys_handler);
-		acpi_db_enumerate_object (obj_desc->device.drv_handler);
-		acpi_db_enumerate_object (obj_desc->device.addr_handler);
-		break;
-
-	case ACPI_TYPE_REGION:
-		acpi_db_enumerate_object (obj_desc->region.addr_handler);
-		break;
-
-	case ACPI_TYPE_POWER:
-		acpi_db_enumerate_object (obj_desc->power_resource.sys_handler);
-		acpi_db_enumerate_object (obj_desc->power_resource.drv_handler);
-		break;
-
-	case ACPI_TYPE_PROCESSOR:
-		acpi_db_enumerate_object (obj_desc->processor.sys_handler);
-		acpi_db_enumerate_object (obj_desc->processor.drv_handler);
-		acpi_db_enumerate_object (obj_desc->processor.addr_handler);
-		break;
-
-	case ACPI_TYPE_THERMAL:
-		acpi_db_enumerate_object (obj_desc->thermal_zone.sys_handler);
-		acpi_db_enumerate_object (obj_desc->thermal_zone.drv_handler);
-		acpi_db_enumerate_object (obj_desc->thermal_zone.addr_handler);
-		break;
-	}
-}
-
-
-#ifndef PARSER_ONLY
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_classify_one_object
- *
- * PARAMETERS:  Callback for Walk_namespace
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Enumerate both the object descriptor (including subobjects) and
- *              the parent namespace node.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_db_classify_one_object (
-	acpi_handle             obj_handle,
-	u32                     nesting_level,
-	void                    *context,
-	void                    **return_value)
-{
-	acpi_namespace_node     *node;
-	acpi_operand_object     *obj_desc;
-	u32                     type;
-
-
-	acpi_gbl_num_nodes++;
-
-	node = (acpi_namespace_node *) obj_handle;
-	obj_desc = ((acpi_namespace_node *) obj_handle)->object;
-
-	acpi_db_enumerate_object (obj_desc);
-
-	type = node->type;
-	if (type > INTERNAL_TYPE_NODE_MAX)
-	{
-		acpi_gbl_node_type_count_misc++;
-	}
-
-	else
-	{
-		acpi_gbl_node_type_count [type]++;
-	}
-
-	return AE_OK;
-
-
-	/* TBD: These need to be counted during the initial parsing phase */
-	/*
-	if (Acpi_ps_is_named_op (Op->Opcode))
-	{
-		Num_nodes++;
-	}
-
-	if (Is_method)
-	{
-		Num_method_elements++;
-	}
-
-	Num_grammar_elements++;
-	Op = Acpi_ps_get_depth_next (Root, Op);
-
-	Size_of_parse_tree          = (Num_grammar_elements - Num_method_elements) * (u32) sizeof (acpi_parse_object);
-	Size_of_method_trees        = Num_method_elements * (u32) sizeof (acpi_parse_object);
-	Size_of_node_entries        = Num_nodes * (u32) sizeof (acpi_namespace_node);
-	Size_of_acpi_objects        = Num_nodes * (u32) sizeof (acpi_operand_object);
-
-	*/
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_count_namespace_objects
- *
- * PARAMETERS:  None
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Count and classify the entire namespace, including all
- *              namespace nodes and attached objects.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_db_count_namespace_objects (
-	void)
-{
-	u32                     i;
-
-
-	acpi_gbl_num_nodes = 0;
-	acpi_gbl_num_objects = 0;
-
-	acpi_gbl_obj_type_count_misc = 0;
-	for (i = 0; i < (INTERNAL_TYPE_NODE_MAX -1); i++)
-	{
-		acpi_gbl_obj_type_count [i] = 0;
-		acpi_gbl_node_type_count [i] = 0;
-	}
-
-	acpi_ns_walk_namespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
-			   FALSE, acpi_db_classify_one_object, NULL, NULL);
-
-	return (AE_OK);
-}
-
-#endif
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_display_statistics
- *
- * PARAMETERS:  Type_arg        - Subcommand
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Display various statistics
- *
- ******************************************************************************/
-
-acpi_status
-acpi_db_display_statistics (
-	NATIVE_CHAR             *type_arg)
-{
-	u32                     i;
-	u32                     type;
-	u32                     outstanding;
-	u32                     size;
-
-
-	if (!acpi_gbl_DSDT)
-	{
-		acpi_os_printf ("*** Warning: There is no DSDT loaded\n");
-	}
-
-	if (!type_arg)
-	{
-		acpi_os_printf ("The following subcommands are available:\n  ALLOCATIONS, OBJECTS, MEMORY, MISC, SIZES, TABLES\n");
-		return (AE_OK);
-	}
-
-	STRUPR (type_arg);
-	type = acpi_db_match_argument (type_arg, acpi_db_stat_types);
-	if (type == (u32) -1)
-	{
-		acpi_os_printf ("Invalid or unsupported argument\n");
-		return (AE_OK);
-	}
-
-
-	switch (type)
-	{
-#ifndef PARSER_ONLY
-	case CMD_ALLOCATIONS:
-#ifdef ACPI_DBG_TRACK_ALLOCATIONS
-		acpi_ut_dump_allocation_info ();
-#endif
-		break;
-#endif
-
-	case CMD_TABLES:
-
-		acpi_os_printf ("ACPI Table Information:\n\n");
-		if (acpi_gbl_DSDT)
-		{
-			acpi_os_printf ("DSDT Length:................% 7ld (%X)\n", acpi_gbl_DSDT->length, acpi_gbl_DSDT->length);
-		}
-		break;
-
-	case CMD_OBJECTS:
-
-#ifndef PARSER_ONLY
-
-		acpi_db_count_namespace_objects ();
-
-		acpi_os_printf ("\n_objects defined in the current namespace:\n\n");
-
-		acpi_os_printf ("%16.16s % 10.10s % 10.10s\n", "ACPI_TYPE", "NODES", "OBJECTS");
-
-		for (i = 0; i < INTERNAL_TYPE_NODE_MAX; i++)
-		{
-			acpi_os_printf ("%16.16s % 10ld% 10ld\n", acpi_ut_get_type_name (i),
-				acpi_gbl_node_type_count [i], acpi_gbl_obj_type_count [i]);
-		}
-		acpi_os_printf ("%16.16s % 10ld% 10ld\n", "Misc/Unknown",
-			acpi_gbl_node_type_count_misc, acpi_gbl_obj_type_count_misc);
-
-		acpi_os_printf ("%16.16s % 10ld% 10ld\n", "TOTALS:",
-			acpi_gbl_num_nodes, acpi_gbl_num_objects);
-
-#endif
-		break;
-
-	case CMD_MEMORY:
-
-#ifdef ACPI_DBG_TRACK_ALLOCATIONS
-		acpi_os_printf ("\n----Object and Cache Statistics---------------------------------------------\n");
-
-		for (i = 0; i < ACPI_NUM_MEM_LISTS; i++)
-		{
-			acpi_os_printf ("\n%s\n", acpi_gbl_memory_lists[i].list_name);
-
-			if (acpi_gbl_memory_lists[i].max_cache_depth > 0)
-			{
-				acpi_os_printf ("  Cache: [Depth Max Avail Size]         % 7d % 7d % 7d % 7d B\n",
-						acpi_gbl_memory_lists[i].cache_depth,
-						acpi_gbl_memory_lists[i].max_cache_depth,
-						acpi_gbl_memory_lists[i].max_cache_depth - acpi_gbl_memory_lists[i].cache_depth,
-						(acpi_gbl_memory_lists[i].cache_depth * acpi_gbl_memory_lists[i].object_size));
-
-				acpi_os_printf ("  Cache: [Requests Hits Misses Obj_size] % 7d % 7d % 7d % 7d B\n",
-						acpi_gbl_memory_lists[i].cache_requests,
-						acpi_gbl_memory_lists[i].cache_hits,
-						acpi_gbl_memory_lists[i].cache_requests - acpi_gbl_memory_lists[i].cache_hits,
-						acpi_gbl_memory_lists[i].object_size);
-			}
-
-			outstanding = acpi_gbl_memory_lists[i].total_allocated -
-					  acpi_gbl_memory_lists[i].total_freed -
-					  acpi_gbl_memory_lists[i].cache_depth;
-
-			if (acpi_gbl_memory_lists[i].object_size)
-			{
-				size = ROUND_UP_TO_1K (outstanding * acpi_gbl_memory_lists[i].object_size);
-			}
-			else
-			{
-				size = ROUND_UP_TO_1K (acpi_gbl_memory_lists[i].current_total_size);
-			}
-
-			acpi_os_printf ("  Mem:   [Alloc Free Outstanding Size]  % 7d % 7d % 7d % 7d Kb\n",
-					acpi_gbl_memory_lists[i].total_allocated,
-					acpi_gbl_memory_lists[i].total_freed,
-					outstanding, size);
-		}
-#endif
-
-		break;
-
-	case CMD_MISC:
-
-		acpi_os_printf ("\n_miscellaneous Statistics:\n\n");
-		acpi_os_printf ("Calls to Acpi_ps_find:.. ........% 7ld\n", acpi_gbl_ps_find_count);
-		acpi_os_printf ("Calls to Acpi_ns_lookup:..........% 7ld\n", acpi_gbl_ns_lookup_count);
-
-		acpi_os_printf ("\n");
-
-		acpi_os_printf ("Mutex usage:\n\n");
-		for (i = 0; i < NUM_MTX; i++)
-		{
-			acpi_os_printf ("%-28s:     % 7ld\n", acpi_ut_get_mutex_name (i), acpi_gbl_acpi_mutex_info[i].use_count);
-		}
-		break;
-
-
-	case CMD_SIZES:
-
-		acpi_os_printf ("\n_internal object sizes:\n\n");
-
-		acpi_os_printf ("Common         %3d\n", sizeof (ACPI_OBJECT_COMMON));
-		acpi_os_printf ("Number         %3d\n", sizeof (ACPI_OBJECT_INTEGER));
-		acpi_os_printf ("String         %3d\n", sizeof (ACPI_OBJECT_STRING));
-		acpi_os_printf ("Buffer         %3d\n", sizeof (ACPI_OBJECT_BUFFER));
-		acpi_os_printf ("Package        %3d\n", sizeof (ACPI_OBJECT_PACKAGE));
-		acpi_os_printf ("Buffer_field   %3d\n", sizeof (ACPI_OBJECT_BUFFER_FIELD));
-		acpi_os_printf ("Device         %3d\n", sizeof (ACPI_OBJECT_DEVICE));
-		acpi_os_printf ("Event          %3d\n", sizeof (ACPI_OBJECT_EVENT));
-		acpi_os_printf ("Method         %3d\n", sizeof (ACPI_OBJECT_METHOD));
-		acpi_os_printf ("Mutex          %3d\n", sizeof (ACPI_OBJECT_MUTEX));
-		acpi_os_printf ("Region         %3d\n", sizeof (ACPI_OBJECT_REGION));
-		acpi_os_printf ("Power_resource %3d\n", sizeof (ACPI_OBJECT_POWER_RESOURCE));
-		acpi_os_printf ("Processor      %3d\n", sizeof (ACPI_OBJECT_PROCESSOR));
-		acpi_os_printf ("Thermal_zone   %3d\n", sizeof (ACPI_OBJECT_THERMAL_ZONE));
-		acpi_os_printf ("Region_field   %3d\n", sizeof (ACPI_OBJECT_REGION_FIELD));
-		acpi_os_printf ("Bank_field     %3d\n", sizeof (ACPI_OBJECT_BANK_FIELD));
-		acpi_os_printf ("Index_field    %3d\n", sizeof (ACPI_OBJECT_INDEX_FIELD));
-		acpi_os_printf ("Reference      %3d\n", sizeof (ACPI_OBJECT_REFERENCE));
-		acpi_os_printf ("Notify_handler %3d\n", sizeof (ACPI_OBJECT_NOTIFY_HANDLER));
-		acpi_os_printf ("Addr_handler   %3d\n", sizeof (ACPI_OBJECT_ADDR_HANDLER));
-		acpi_os_printf ("Extra          %3d\n", sizeof (ACPI_OBJECT_EXTRA));
-
-		acpi_os_printf ("\n");
-
-		acpi_os_printf ("Parse_object   %3d\n", sizeof (acpi_parse_object));
-		acpi_os_printf ("Parse2_object  %3d\n", sizeof (acpi_parse2_object));
-		acpi_os_printf ("Operand_object %3d\n", sizeof (acpi_operand_object));
-		acpi_os_printf ("Namespace_node %3d\n", sizeof (acpi_namespace_node));
-
-		break;
-
-
-	case CMD_STACK:
-
-		size = acpi_gbl_entry_stack_pointer - acpi_gbl_lowest_stack_pointer;
-
-		acpi_os_printf ("\n_subsystem Stack Usage:\n\n");
-		acpi_os_printf ("Entry Stack Pointer        %X\n", acpi_gbl_entry_stack_pointer);
-		acpi_os_printf ("Lowest Stack Pointer       %X\n", acpi_gbl_lowest_stack_pointer);
-		acpi_os_printf ("Stack Use                  %X (%d)\n", size, size);
-		acpi_os_printf ("Deepest Procedure Nesting  %d\n", acpi_gbl_deepest_nesting);
-		break;
-	}
-
-	acpi_os_printf ("\n");
-	return (AE_OK);
-}
-
-
-#endif /* ENABLE_DEBUGGER  */
diff -urNp linux-5400/drivers/acpi/debugger/dbutils.c linux-5410/drivers/acpi/debugger/dbutils.c
--- linux-5400/drivers/acpi/debugger/dbutils.c
+++ linux-5410/drivers/acpi/debugger/dbutils.c
@@ -1,384 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: dbutils - AML debugger utilities
- *              $Revision: 45 $
- *
- ******************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include "acpi.h"
-#include "acparser.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "acparser.h"
-#include "acevents.h"
-#include "acinterp.h"
-#include "acdebug.h"
-#include "acdispat.h"
-
-
-#ifdef ENABLE_DEBUGGER
-
-#define _COMPONENT          ACPI_DEBUGGER
-	 MODULE_NAME         ("dbutils")
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_set_output_destination
- *
- * PARAMETERS:  Output_flags        - Current flags word
- *
- * RETURN:      None
- *
- * DESCRIPTION: Set the current destination for debugger output.  Alos sets
- *              the debug output level accordingly.
- *
- ******************************************************************************/
-
-void
-acpi_db_set_output_destination (
-	u32                     output_flags)
-{
-
-	acpi_gbl_db_output_flags = (u8) output_flags;
-
-	if (output_flags & DB_REDIRECTABLE_OUTPUT) {
-		if (acpi_gbl_db_output_to_file) {
-			acpi_dbg_level = acpi_gbl_db_debug_level;
-		}
-	}
-	else {
-		acpi_dbg_level = acpi_gbl_db_console_debug_level;
-	}
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_dump_buffer
- *
- * PARAMETERS:  Address             - Pointer to the buffer
- *
- * RETURN:      None
- *
- * DESCRIPTION: Print a portion of a buffer
- *
- ******************************************************************************/
-
-void
-acpi_db_dump_buffer (
-	u32                     address)
-{
-
-	acpi_os_printf ("\n_location %X:\n", address);
-
-	acpi_dbg_level |= ACPI_LV_TABLES;
-	acpi_ut_dump_buffer ((u8 *) address, 64, DB_BYTE_DISPLAY, ACPI_UINT32_MAX);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_dump_object
- *
- * PARAMETERS:  Obj_desc        - External ACPI object to dump
- *              Level           - Nesting level.
- *
- * RETURN:      None
- *
- * DESCRIPTION: Dump the contents of an ACPI external object
- *
- ******************************************************************************/
-
-void
-acpi_db_dump_object (
-	acpi_object             *obj_desc,
-	u32                     level)
-{
-	u32                     i;
-
-
-	if (!obj_desc) {
-		acpi_os_printf ("[Null Object]\n");
-		return;
-	}
-
-	for (i = 0; i < level; i++) {
-		acpi_os_printf (" ");
-	}
-
-	switch (obj_desc->type) {
-	case ACPI_TYPE_ANY:
-
-		acpi_os_printf ("[Object Reference] = %p\n", obj_desc->reference.handle);
-		break;
-
-
-	case ACPI_TYPE_INTEGER:
-
-		acpi_os_printf ("[Integer] = %8.8X%8.8X\n", HIDWORD (obj_desc->integer.value),
-				 LODWORD (obj_desc->integer.value));
-		break;
-
-
-	case ACPI_TYPE_STRING:
-
-		acpi_os_printf ("[String] Value: ");
-		for (i = 0; i < obj_desc->string.length; i++) {
-			acpi_os_printf ("%c", obj_desc->string.pointer[i]);
-		}
-		acpi_os_printf ("\n");
-		break;
-
-
-	case ACPI_TYPE_BUFFER:
-
-		acpi_os_printf ("[Buffer] = ");
-		acpi_ut_dump_buffer ((u8 *) obj_desc->buffer.pointer, obj_desc->buffer.length, DB_DWORD_DISPLAY, _COMPONENT);
-		break;
-
-
-	case ACPI_TYPE_PACKAGE:
-
-		acpi_os_printf ("[Package] Contains %d Elements: \n", obj_desc->package.count);
-
-		for (i = 0; i < obj_desc->package.count; i++) {
-			acpi_db_dump_object (&obj_desc->package.elements[i], level+1);
-		}
-		break;
-
-
-	case INTERNAL_TYPE_REFERENCE:
-
-		acpi_os_printf ("[Object Reference] = %p\n", obj_desc->reference.handle);
-		break;
-
-
-	case ACPI_TYPE_PROCESSOR:
-
-		acpi_os_printf ("[Processor]\n");
-		break;
-
-
-	case ACPI_TYPE_POWER:
-
-		acpi_os_printf ("[Power Resource]\n");
-		break;
-
-
-	default:
-
-		acpi_os_printf ("[Unknown Type] %X \n", obj_desc->type);
-		break;
-	}
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_prep_namestring
- *
- * PARAMETERS:  Name            - String to prepare
- *
- * RETURN:      None
- *
- * DESCRIPTION: Translate all forward slashes and dots to backslashes.
- *
- ******************************************************************************/
-
-void
-acpi_db_prep_namestring (
-	NATIVE_CHAR             *name)
-{
-
-
-	if (!name) {
-		return;
-	}
-
-	STRUPR (name);
-
-	/* Convert a leading forward slash to a backslash */
-
-	if (*name == '/') {
-		*name = '\\';
-	}
-
-	/* Ignore a leading backslash, this is the root prefix */
-
-	if (*name == '\\') {
-		name++;
-	}
-
-	/* Convert all slash path separators to dots */
-
-	while (*name) {
-		if ((*name == '/') ||
-			(*name == '\\')) {
-			*name = '.';
-		}
-
-		name++;
-	}
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_second_pass_parse
- *
- * PARAMETERS:  Root            - Root of the parse tree
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Second pass parse of the ACPI tables.  We need to wait until
- *              second pass to parse the control methods
- *
- ******************************************************************************/
-
-acpi_status
-acpi_db_second_pass_parse (
-	acpi_parse_object       *root)
-{
-	acpi_parse_object       *op = root;
-	acpi_parse2_object      *method;
-	acpi_parse_object       *search_op;
-	acpi_parse_object       *start_op;
-	acpi_status             status = AE_OK;
-	u32                     base_aml_offset;
-	acpi_walk_state         *walk_state;
-
-
-	FUNCTION_ENTRY ();
-
-
-	acpi_os_printf ("Pass two parse ....\n");
-
-
-	while (op) {
-		if (op->opcode == AML_METHOD_OP) {
-			method = (acpi_parse2_object *) op;
-
-			walk_state = acpi_ds_create_walk_state (TABLE_ID_DSDT,
-					   NULL, NULL, NULL);
-			if (!walk_state) {
-				return (AE_NO_MEMORY);
-			}
-
-
-			walk_state->parser_state.aml        =
-			walk_state->parser_state.aml_start  = method->data;
-			walk_state->parser_state.aml_end    =
-			walk_state->parser_state.pkg_end    = method->data + method->length;
-			walk_state->parser_state.start_scope = op;
-
-			walk_state->descending_callback     = acpi_ds_load1_begin_op;
-			walk_state->ascending_callback      = acpi_ds_load1_end_op;
-
-
-			status = acpi_ps_parse_aml (walk_state);
-
-
-			base_aml_offset = (method->value.arg)->aml_offset + 1;
-			start_op = (method->value.arg)->next;
-			search_op = start_op;
-
-			while (search_op) {
-				search_op->aml_offset += base_aml_offset;
-				search_op = acpi_ps_get_depth_next (start_op, search_op);
-			}
-
-		}
-
-		if (op->opcode == AML_REGION_OP) {
-			/* TBD: [Investigate] this isn't quite the right thing to do! */
-			/*
-			 *
-			 * Method = (ACPI_DEFERRED_OP *) Op;
-			 * Status = Acpi_ps_parse_aml (Op, Method->Body, Method->Body_length);
-			 */
-		}
-
-		if (ACPI_FAILURE (status)) {
-			break;
-		}
-
-		op = acpi_ps_get_depth_next (root, op);
-	}
-
-	return (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_local_ns_lookup
- *
- * PARAMETERS:  Name            - Name to lookup
- *
- * RETURN:      Pointer to a namespace node
- *
- * DESCRIPTION: Lookup a name in the ACPI namespace
- *
- ******************************************************************************/
-
-acpi_namespace_node *
-acpi_db_local_ns_lookup (
-	NATIVE_CHAR             *name)
-{
-	NATIVE_CHAR             *internal_path;
-	acpi_status             status;
-	acpi_namespace_node     *node = NULL;
-
-
-	acpi_db_prep_namestring (name);
-
-	/* Build an internal namestring */
-
-	status = acpi_ns_internalize_name (name, &internal_path);
-	if (ACPI_FAILURE (status)) {
-		acpi_os_printf ("Invalid namestring: %s\n", name);
-		return (NULL);
-	}
-
-	/* Lookup the name */
-
-	/* TBD: [Investigate] what scope do we use? */
-	/* Use the root scope for the start of the search */
-
-	status = acpi_ns_lookup (NULL, internal_path, ACPI_TYPE_ANY, IMODE_EXECUTE,
-			   NS_NO_UPSEARCH | NS_DONT_OPEN_SCOPE, NULL, &node);
-
-	if (ACPI_FAILURE (status)) {
-		acpi_os_printf ("Could not locate name: %s %s\n", name, acpi_format_exception (status));
-	}
-
-
-	ACPI_MEM_FREE (internal_path);
-
-	return (node);
-}
-
-
-#endif /* ENABLE_DEBUGGER */
-
-
diff -urNp linux-5400/drivers/acpi/debugger/dbxface.c linux-5410/drivers/acpi/debugger/dbxface.c
--- linux-5400/drivers/acpi/debugger/dbxface.c
+++ linux-5410/drivers/acpi/debugger/dbxface.c
@@ -1,321 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: dbxface - AML Debugger external interfaces
- *              $Revision: 45 $
- *
- ******************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include "acpi.h"
-#include "acparser.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "acparser.h"
-#include "acevents.h"
-#include "acinterp.h"
-#include "acdebug.h"
-
-
-#ifdef ENABLE_DEBUGGER
-
-#define _COMPONENT          ACPI_DEBUGGER
-	 MODULE_NAME         ("dbxface")
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_single_step
- *
- * PARAMETERS:  Walk_state      - Current walk
- *              Op              - Current executing op
- *              Opcode_class    - Class of the current AML Opcode
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Called just before execution of an AML opcode.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_db_single_step (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op,
-	u32                     opcode_class)
-{
-	acpi_parse_object       *next;
-	acpi_status             status = AE_OK;
-	u32                     original_debug_level;
-	acpi_parse_object       *display_op;
-
-
-	FUNCTION_ENTRY ();
-
-	/* Is there a breakpoint set? */
-
-	if (walk_state->method_breakpoint) {
-		/* Check if the breakpoint has been reached or passed */
-
-		if (walk_state->method_breakpoint <= op->aml_offset) {
-			/* Hit the breakpoint, resume single step, reset breakpoint */
-
-			acpi_os_printf ("***Break*** at AML offset %X\n", op->aml_offset);
-			acpi_gbl_cm_single_step = TRUE;
-			acpi_gbl_step_to_next_call = FALSE;
-			walk_state->method_breakpoint = 0;
-		}
-	}
-
-	/*
-	 * Check if this is an opcode that we are interested in --
-	 * namely, opcodes that have arguments
-	 */
-	if (op->opcode == AML_INT_NAMEDFIELD_OP) {
-		return (AE_OK);
-	}
-
-	switch (opcode_class) {
-	case AML_CLASS_UNKNOWN:
-	case AML_CLASS_ARGUMENT:    /* constants, literals, etc.  do nothing */
-		return (AE_OK);
-		break;
-	}
-
-	/*
-	 * Under certain debug conditions, display this opcode and its operands
-	 */
-	if ((acpi_gbl_db_output_to_file)        ||
-		(acpi_gbl_cm_single_step)           ||
-		(acpi_dbg_level & ACPI_LV_PARSE)) {
-		if ((acpi_gbl_db_output_to_file)    ||
-			(acpi_dbg_level & ACPI_LV_PARSE)) {
-			acpi_os_printf ("\n[Aml_debug] Next AML Opcode to execute:\n");
-		}
-
-		/*
-		 * Display this op (and only this op - zero out the NEXT field temporarily,
-		 * and disable parser trace output for the duration of the display because
-		 * we don't want the extraneous debug output)
-		 */
-		original_debug_level = acpi_dbg_level;
-		acpi_dbg_level &= ~(ACPI_LV_PARSE | ACPI_LV_FUNCTIONS);
-		next = op->next;
-		op->next = NULL;
-
-
-		display_op = op;
-		if (op->parent) {
-			if ((op->parent->opcode == AML_IF_OP) ||
-				(op->parent->opcode == AML_WHILE_OP)) {
-				display_op = op->parent;
-			}
-		}
-
-		/* Now we can display it */
-
-		acpi_db_display_op (walk_state, display_op, ACPI_UINT32_MAX);
-
-		if ((op->opcode == AML_IF_OP) ||
-			(op->opcode == AML_WHILE_OP)) {
-			if (walk_state->control_state->common.value) {
-				acpi_os_printf ("Predicate was TRUE, executed block\n");
-			}
-			else {
-				acpi_os_printf ("Predicate is FALSE, skipping block\n");
-			}
-		}
-
-		else if (op->opcode == AML_ELSE_OP) {
-			/* TBD */
-		}
-
-		/* Restore everything */
-
-		op->next = next;
-		acpi_os_printf ("\n");
-		acpi_dbg_level = original_debug_level;
-	}
-
-	/* If we are not single stepping, just continue executing the method */
-
-	if (!acpi_gbl_cm_single_step) {
-		return (AE_OK);
-	}
-
-
-	/*
-	 * If we are executing a step-to-call command,
-	 * Check if this is a method call.
-	 */
-	if (acpi_gbl_step_to_next_call) {
-		if (op->opcode != AML_INT_METHODCALL_OP) {
-			/* Not a method call, just keep executing */
-
-			return (AE_OK);
-		}
-
-		/* Found a method call, stop executing */
-
-		acpi_gbl_step_to_next_call = FALSE;
-	}
-
-
-	/*
-	 * If the next opcode is a method call, we will "step over" it
-	 * by default.
-	 */
-	if (op->opcode == AML_INT_METHODCALL_OP) {
-		acpi_gbl_cm_single_step = FALSE; /* No more single step while executing called method */
-
-		/* Set the breakpoint on the call, it will stop execution as soon as we return */
-
-		/* TBD: [Future] don't kill the user breakpoint! */
-
-		walk_state->method_breakpoint = /* Op->Aml_offset + */ 1; /* Must be non-zero! */
-	}
-
-
-	/* TBD: [Investigate] what are the namespace locking issues here */
-
-	/* Acpi_ut_release_mutex (ACPI_MTX_NAMESPACE); */
-
-	/* Go into the command loop and await next user command */
-
-	acpi_gbl_method_executing = TRUE;
-	status = AE_CTRL_TRUE;
-	while (status == AE_CTRL_TRUE) {
-		if (acpi_gbl_debugger_configuration == DEBUGGER_MULTI_THREADED) {
-			/* Handshake with the front-end that gets user command lines */
-
-			acpi_ut_release_mutex (ACPI_MTX_DEBUG_CMD_COMPLETE);
-			acpi_ut_acquire_mutex (ACPI_MTX_DEBUG_CMD_READY);
-		}
-
-		else {
-			/* Single threaded, we must get a command line ourselves */
-
-			/* Force output to console until a command is entered */
-
-			acpi_db_set_output_destination (DB_CONSOLE_OUTPUT);
-
-			/* Different prompt if method is executing */
-
-			if (!acpi_gbl_method_executing) {
-				acpi_os_printf ("%1c ", DB_COMMAND_PROMPT);
-			}
-			else {
-				acpi_os_printf ("%1c ", DB_EXECUTE_PROMPT);
-			}
-
-			/* Get the user input line */
-
-			acpi_os_get_line (acpi_gbl_db_line_buf);
-		}
-
-		status = acpi_db_command_dispatch (acpi_gbl_db_line_buf, walk_state, op);
-	}
-
-	/* Acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE); */
-
-	/* User commands complete, continue execution of the interrupted method */
-
-	return (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_initialize
- *
- * PARAMETERS:  None
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Init and start debugger
- *
- ******************************************************************************/
-
-int
-acpi_db_initialize (void)
-{
-
-
-	/* Init globals */
-
-	acpi_gbl_db_buffer = acpi_os_callocate (ACPI_DEBUG_BUFFER_SIZE);
-
-	/* Initial scope is the root */
-
-	acpi_gbl_db_scope_buf [0] = '\\';
-	acpi_gbl_db_scope_buf [1] = 0;
-
-
-	/*
-	 * If configured for multi-thread support, the debug executor runs in
-	 * a separate thread so that the front end can be in another address
-	 * space, environment, or even another machine.
-	 */
-	if (acpi_gbl_debugger_configuration & DEBUGGER_MULTI_THREADED) {
-		/* These were created with one unit, grab it */
-
-		acpi_ut_acquire_mutex (ACPI_MTX_DEBUG_CMD_COMPLETE);
-		acpi_ut_acquire_mutex (ACPI_MTX_DEBUG_CMD_READY);
-
-		/* Create the debug execution thread to execute commands */
-
-		acpi_os_queue_for_execution (0, acpi_db_execute_thread, NULL);
-	}
-
-	if (!acpi_gbl_db_opt_verbose) {
-		acpi_gbl_db_disasm_indent = " ";
-		acpi_gbl_db_opt_disasm = TRUE;
-		acpi_gbl_db_opt_stats = FALSE;
-	}
-
-	return (0);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_db_terminate
- *
- * PARAMETERS:  None
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Stop debugger
- *
- ******************************************************************************/
-
-void
-acpi_db_terminate (void)
-{
-
-	if (acpi_gbl_db_table_ptr) {
-		acpi_os_free (acpi_gbl_db_table_ptr);
-	}
-	if (acpi_gbl_db_buffer) {
-		acpi_os_free (acpi_gbl_db_buffer);
-	}
-}
-
-
-#endif /* ENABLE_DEBUGGER */
diff -urNp linux-5400/drivers/acpi/dispatcher/Makefile linux-5410/drivers/acpi/dispatcher/Makefile
--- linux-5400/drivers/acpi/dispatcher/Makefile
+++ linux-5410/drivers/acpi/dispatcher/Makefile
@@ -1,11 +1,10 @@
 #
 # Makefile for all Linux ACPI interpreter subdirectories
-# EXCEPT for the ospm directory
 #
 
 O_TARGET := $(notdir $(CURDIR)).o
 
-obj-$(CONFIG_ACPI) := $(patsubst %.c,%.o,$(wildcard *.c))
+obj-$(CONFIG_ACPI_INTERPRETER) := $(patsubst %.c,%.o,$(wildcard *.c))
 
 EXTRA_CFLAGS += $(ACPI_CFLAGS)
 
diff -urNp linux-5400/drivers/acpi/dispatcher/dsfield.c linux-5410/drivers/acpi/dispatcher/dsfield.c
--- linux-5400/drivers/acpi/dispatcher/dsfield.c
+++ linux-5410/drivers/acpi/dispatcher/dsfield.c
@@ -1,78 +1,98 @@
 /******************************************************************************
  *
  * Module Name: dsfield - Dispatcher field routines
- *              $Revision: 46 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "amlcode.h"
-#include "acdispat.h"
-#include "acinterp.h"
-#include "acnamesp.h"
-#include "acparser.h"
+#include <acpi/acpi.h>
+#include <acpi/amlcode.h>
+#include <acpi/acdispat.h>
+#include <acpi/acinterp.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acparser.h>
 
 
 #define _COMPONENT          ACPI_DISPATCHER
-	 MODULE_NAME         ("dsfield")
+	 ACPI_MODULE_NAME    ("dsfield")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_create_buffer_field
+ * FUNCTION:    acpi_ds_create_buffer_field
  *
  * PARAMETERS:  Opcode              - The opcode to be executed
  *              Operands            - List of operands for the opcode
- *              Walk_state          - Current state
+ *              walk_state          - Current state
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Execute the Create_field operators:
- *              Create_bit_field_op,
- *              Create_byte_field_op,
- *              Create_word_field_op,
- *              Create_dWord_field_op,
- *              Create_qWord_field_op,
- *              Create_field_op     (all of which define fields in buffers)
+ * DESCRIPTION: Execute the create_field operators:
+ *              create_bit_field_op,
+ *              create_byte_field_op,
+ *              create_word_field_op,
+ *              create_dword_field_op,
+ *              create_qword_field_op,
+ *              create_field_op     (all of which define fields in buffers)
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ds_create_buffer_field (
-	acpi_parse_object       *op,
-	acpi_walk_state         *walk_state)
+	union acpi_parse_object         *op,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_parse_object       *arg;
-	acpi_namespace_node     *node;
-	acpi_status             status;
-	acpi_operand_object     *obj_desc;
+	union acpi_parse_object         *arg;
+	struct acpi_namespace_node      *node;
+	acpi_status                     status;
+	union acpi_operand_object       *obj_desc;
+	union acpi_operand_object       *second_desc = NULL;
+	u32                             flags;
 
 
-	FUNCTION_TRACE ("Ds_create_buffer_field");
+	ACPI_FUNCTION_TRACE ("ds_create_buffer_field");
 
 
-	/* Get the Name_string argument */
+	/* Get the name_string argument */
 
-	if (op->opcode == AML_CREATE_FIELD_OP) {
+	if (op->common.aml_opcode == AML_CREATE_FIELD_OP) {
 		arg = acpi_ps_get_arg (op, 3);
 	}
 	else {
@@ -86,13 +106,25 @@ acpi_ds_create_buffer_field (
 	}
 
 	/*
-	 * Enter the Name_string into the namespace
+	 * During the load phase, we want to enter the name of the field into
+	 * the namespace.  During the execute phase (when we evaluate the size
+	 * operand), we want to lookup the name
 	 */
-	status = acpi_ns_lookup (walk_state->scope_info, arg->value.string,
-			 INTERNAL_TYPE_DEF_ANY, IMODE_LOAD_PASS1,
-			 NS_NO_UPSEARCH | NS_DONT_OPEN_SCOPE,
-			 walk_state, &(node));
+	if (walk_state->parse_flags & ACPI_PARSE_EXECUTE) {
+		flags = ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE;
+	}
+	else {
+		flags = ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE | ACPI_NS_ERROR_IF_FOUND;
+	}
+
+	/*
+	 * Enter the name_string into the namespace
+	 */
+	status = acpi_ns_lookup (walk_state->scope_info, arg->common.value.string,
+			 ACPI_TYPE_ANY, ACPI_IMODE_LOAD_PASS1,
+			 flags, walk_state, &(node));
 	if (ACPI_FAILURE (status)) {
+		ACPI_REPORT_NSERROR (arg->common.value.string, status);
 		return_ACPI_STATUS (status);
 	}
 
@@ -100,14 +132,15 @@ acpi_ds_create_buffer_field (
 	 * for now, we will put it in the "op" object that the parser uses, so we
 	 * can get it again at the end of this scope
 	 */
-	op->node = node;
+	op->common.node = node;
 
 	/*
 	 * If there is no object attached to the node, this node was just created and
 	 * we need to create the field object.  Otherwise, this was a lookup of an
 	 * existing node and we don't want to create the field object again.
 	 */
-	if (node->object) {
+	obj_desc = acpi_ns_get_attached_object (node);
+	if (obj_desc) {
 		return_ACPI_STATUS (AE_OK);
 	}
 
@@ -125,27 +158,21 @@ acpi_ds_create_buffer_field (
 	}
 
 	/*
-	 * Allocate a method object for this field unit
-	 */
-	obj_desc->buffer_field.extra = acpi_ut_create_internal_object (
-			   INTERNAL_TYPE_EXTRA);
-	if (!obj_desc->buffer_field.extra) {
-		status = AE_NO_MEMORY;
-		goto cleanup;
-	}
-
-	/*
 	 * Remember location in AML stream of the field unit
 	 * opcode and operands -- since the buffer and index
 	 * operands must be evaluated.
 	 */
-	obj_desc->buffer_field.extra->extra.aml_start = ((acpi_parse2_object *) op)->data;
-	obj_desc->buffer_field.extra->extra.aml_length = ((acpi_parse2_object *) op)->length;
+	second_desc                 = obj_desc->common.next_object;
+	second_desc->extra.aml_start = op->named.data;
+	second_desc->extra.aml_length = op->named.length;
 	obj_desc->buffer_field.node = node;
 
-	/* Attach constructed field descriptor to parent node */
+	/* Attach constructed field descriptors to parent node */
 
 	status = acpi_ns_attach_object (node, obj_desc, ACPI_TYPE_BUFFER_FIELD);
+	if (ACPI_FAILURE (status)) {
+		goto cleanup;
+	}
 
 
 cleanup:
@@ -159,10 +186,10 @@ cleanup:
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_get_field_names
+ * FUNCTION:    acpi_ds_get_field_names
  *
- * PARAMETERS:  Info            - Create_field info structure
- *  `           Walk_state      - Current method state
+ * PARAMETERS:  Info            - create_field info structure
+ *  `           walk_state      - Current method state
  *              Arg             - First parser arg for the field name list
  *
  * RETURN:      Status
@@ -174,14 +201,15 @@ cleanup:
 
 acpi_status
 acpi_ds_get_field_names (
-	ACPI_CREATE_FIELD_INFO  *info,
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *arg)
+	struct acpi_create_field_info   *info,
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *arg)
 {
-	acpi_status             status;
+	acpi_status                     status;
+	acpi_integer                    position;
 
 
-	PROC_NAME("acpi_ds_get_field_names"); 
+	ACPI_FUNCTION_TRACE_PTR ("ds_get_field_names", info);
 
 
 	/* First field starts at bit zero */
@@ -194,51 +222,78 @@ acpi_ds_get_field_names (
 		/*
 		 * Three types of field elements are handled:
 		 * 1) Offset - specifies a bit offset
-		 * 2) Access_as - changes the access mode
+		 * 2) access_as - changes the access mode
 		 * 3) Name - Enters a new named field into the namespace
 		 */
-		switch (arg->opcode) {
+		switch (arg->common.aml_opcode) {
 		case AML_INT_RESERVEDFIELD_OP:
 
-			info->field_bit_position += arg->value.size;
+			position = (acpi_integer) info->field_bit_position
+					 + (acpi_integer) arg->common.value.size;
+
+			if (position > ACPI_UINT32_MAX) {
+				ACPI_REPORT_ERROR (("Bit offset within field too large (> 0xFFFFFFFF)\n"));
+				return_ACPI_STATUS (AE_SUPPORT);
+			}
+
+			info->field_bit_position = (u32) position;
 			break;
 
 
 		case AML_INT_ACCESSFIELD_OP:
 
 			/*
-			 * Get a new Access_type and Access_attribute for all
-			 * entries (until end or another Access_as keyword)
+			 * Get a new access_type and access_attribute -- to be used for all
+			 * field units that follow, until field end or another access_as keyword.
+			 *
+			 * In field_flags, preserve the flag bits other than the ACCESS_TYPE bits
 			 */
-			info->field_flags = (u8) ((info->field_flags & FIELD_ACCESS_TYPE_MASK) ||
-					  ((u8) (arg->value.integer >> 8)));
+			info->field_flags = (u8) ((info->field_flags & ~(AML_FIELD_ACCESS_TYPE_MASK)) |
+					  ((u8) ((u32) arg->common.value.integer >> 8)));
+
+			info->attribute = (u8) (arg->common.value.integer);
 			break;
 
 
 		case AML_INT_NAMEDFIELD_OP:
 
-			/* Enter a new field name into the namespace */
+			/* Lookup the name */
 
 			status = acpi_ns_lookup (walk_state->scope_info,
-					  (NATIVE_CHAR *) &((acpi_parse2_object *)arg)->name,
-					  info->field_type, IMODE_LOAD_PASS1,
-					  NS_NO_UPSEARCH | NS_DONT_OPEN_SCOPE,
-					  NULL, &info->field_node);
+					  (char *) &arg->named.name,
+					  info->field_type, ACPI_IMODE_EXECUTE, ACPI_NS_DONT_OPEN_SCOPE,
+					  walk_state, &info->field_node);
 			if (ACPI_FAILURE (status)) {
-				return_ACPI_STATUS (status);
+				ACPI_REPORT_NSERROR ((char *) &arg->named.name, status);
+				if (status != AE_ALREADY_EXISTS) {
+					return_ACPI_STATUS (status);
+				}
+
+				/* Already exists, ignore error */
+			}
+			else {
+				arg->common.node = info->field_node;
+				info->field_bit_length = arg->common.value.size;
+
+				/* Create and initialize an object for the new Field Node */
+
+				status = acpi_ex_prep_field_value (info);
+				if (ACPI_FAILURE (status)) {
+					return_ACPI_STATUS (status);
+				}
 			}
 
-			/* Create and initialize an object for the new Field Node */
+			/* Keep track of bit position for the next field */
 
-			info->field_bit_length = arg->value.size;
+			position = (acpi_integer) info->field_bit_position
+					 + (acpi_integer) arg->common.value.size;
 
-			status = acpi_ex_prep_field_value (info);
-			if (ACPI_FAILURE (status)) {
-				return_ACPI_STATUS (status);
+			if (position > ACPI_UINT32_MAX) {
+				ACPI_REPORT_ERROR (("Field [%4.4s] bit offset too large (> 0xFFFFFFFF)\n",
+						(char *) &info->field_node->name));
+				return_ACPI_STATUS (AE_SUPPORT);
 			}
 
-			/* Keep track of bit position for the next field */
-
 			info->field_bit_position += info->field_bit_length;
 			break;
 
@@ -246,12 +301,11 @@ acpi_ds_get_field_names (
 		default:
 
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid opcode in field list: %X\n",
-				arg->opcode));
-			return_ACPI_STATUS (AE_AML_ERROR);
-			break;
+				arg->common.aml_opcode));
+			return_ACPI_STATUS (AE_AML_BAD_OPCODE);
 		}
 
-		arg = arg->next;
+		arg = arg->common.next;
 	}
 
 	return_ACPI_STATUS (AE_OK);
@@ -260,11 +314,11 @@ acpi_ds_get_field_names (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_create_field
+ * FUNCTION:    acpi_ds_create_field
  *
  * PARAMETERS:  Op              - Op containing the Field definition and args
- *              Region_node     - Object for the containing Operation Region
- *  `           Walk_state      - Current method state
+ *              region_node     - Object for the containing Operation Region
+ *  `           walk_state      - Current method state
  *
  * RETURN:      Status
  *
@@ -274,41 +328,43 @@ acpi_ds_get_field_names (
 
 acpi_status
 acpi_ds_create_field (
-	acpi_parse_object       *op,
-	acpi_namespace_node     *region_node,
-	acpi_walk_state         *walk_state)
+	union acpi_parse_object         *op,
+	struct acpi_namespace_node      *region_node,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status = AE_AML_ERROR;
-	acpi_parse_object       *arg;
-	ACPI_CREATE_FIELD_INFO  info;
+	acpi_status                     status;
+	union acpi_parse_object         *arg;
+	struct acpi_create_field_info   info;
 
 
-	FUNCTION_TRACE_PTR ("Ds_create_field", op);
+	ACPI_FUNCTION_TRACE_PTR ("ds_create_field", op);
 
 
-	/* First arg is the name of the parent Op_region (must already exist) */
+	/* First arg is the name of the parent op_region (must already exist) */
 
-	arg = op->value.arg;
+	arg = op->common.value.arg;
 	if (!region_node) {
-		status = acpi_ns_lookup (walk_state->scope_info, arg->value.name,
-				  ACPI_TYPE_REGION, IMODE_EXECUTE,
-				  NS_SEARCH_PARENT, walk_state, &region_node);
+		status = acpi_ns_lookup (walk_state->scope_info, arg->common.value.name,
+				  ACPI_TYPE_REGION, ACPI_IMODE_EXECUTE,
+				  ACPI_NS_SEARCH_PARENT, walk_state, &region_node);
 		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_NSERROR (arg->common.value.name, status);
 			return_ACPI_STATUS (status);
 		}
 	}
 
 	/* Second arg is the field flags */
 
-	arg = arg->next;
-	info.field_flags = arg->value.integer8;
+	arg = arg->common.next;
+	info.field_flags = (u8) arg->common.value.integer;
+	info.attribute = 0;
 
 	/* Each remaining arg is a Named Field */
 
-	info.field_type = INTERNAL_TYPE_REGION_FIELD;
+	info.field_type = ACPI_TYPE_LOCAL_REGION_FIELD;
 	info.region_node = region_node;
 
-	status = acpi_ds_get_field_names (&info, walk_state, arg->next);
+	status = acpi_ds_get_field_names (&info, walk_state, arg->common.next);
 
 	return_ACPI_STATUS (status);
 }
@@ -316,11 +372,95 @@ acpi_ds_create_field (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_create_bank_field
+ * FUNCTION:    acpi_ds_init_field_objects
  *
  * PARAMETERS:  Op              - Op containing the Field definition and args
- *              Region_node     - Object for the containing Operation Region
- *  `           Walk_state      - Current method state
+ *  `           walk_state      - Current method state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: For each "Field Unit" name in the argument list that is
+ *              part of the field declaration, enter the name into the
+ *              namespace.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_init_field_objects (
+	union acpi_parse_object         *op,
+	struct acpi_walk_state          *walk_state)
+{
+	acpi_status                     status;
+	union acpi_parse_object         *arg = NULL;
+	struct acpi_namespace_node      *node;
+	u8                              type = 0;
+
+
+	ACPI_FUNCTION_TRACE_PTR ("ds_init_field_objects", op);
+
+
+	switch (walk_state->opcode) {
+	case AML_FIELD_OP:
+		arg = acpi_ps_get_arg (op, 2);
+		type = ACPI_TYPE_LOCAL_REGION_FIELD;
+		break;
+
+	case AML_BANK_FIELD_OP:
+		arg = acpi_ps_get_arg (op, 4);
+		type = ACPI_TYPE_LOCAL_BANK_FIELD;
+		break;
+
+	case AML_INDEX_FIELD_OP:
+		arg = acpi_ps_get_arg (op, 3);
+		type = ACPI_TYPE_LOCAL_INDEX_FIELD;
+		break;
+
+	default:
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
+
+	/*
+	 * Walk the list of entries in the field_list
+	 */
+	while (arg) {
+		/* Ignore OFFSET and ACCESSAS terms here */
+
+		if (arg->common.aml_opcode == AML_INT_NAMEDFIELD_OP) {
+			status = acpi_ns_lookup (walk_state->scope_info,
+					  (char *) &arg->named.name,
+					  type, ACPI_IMODE_LOAD_PASS1,
+					  ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE | ACPI_NS_ERROR_IF_FOUND,
+					  walk_state, &node);
+			if (ACPI_FAILURE (status)) {
+				ACPI_REPORT_NSERROR ((char *) &arg->named.name, status);
+				if (status != AE_ALREADY_EXISTS) {
+					return_ACPI_STATUS (status);
+				}
+
+				/* Name already exists, just ignore this error */
+
+				status = AE_OK;
+			}
+
+			arg->common.node = node;
+		}
+
+		/* Move to next field in the list */
+
+		arg = arg->common.next;
+	}
+
+	return_ACPI_STATUS (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_create_bank_field
+ *
+ * PARAMETERS:  Op              - Op containing the Field definition and args
+ *              region_node     - Object for the containing Operation Region
+ *  `           walk_state      - Current method state
  *
  * RETURN:      Status
  *
@@ -330,56 +470,58 @@ acpi_ds_create_field (
 
 acpi_status
 acpi_ds_create_bank_field (
-	acpi_parse_object       *op,
-	acpi_namespace_node     *region_node,
-	acpi_walk_state         *walk_state)
+	union acpi_parse_object         *op,
+	struct acpi_namespace_node      *region_node,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status = AE_AML_ERROR;
-	acpi_parse_object       *arg;
-	ACPI_CREATE_FIELD_INFO  info;
+	acpi_status                     status;
+	union acpi_parse_object         *arg;
+	struct acpi_create_field_info   info;
 
 
-	FUNCTION_TRACE_PTR ("Ds_create_bank_field", op);
+	ACPI_FUNCTION_TRACE_PTR ("ds_create_bank_field", op);
 
 
-	/* First arg is the name of the parent Op_region (must already exist) */
+	/* First arg is the name of the parent op_region (must already exist) */
 
-	arg = op->value.arg;
+	arg = op->common.value.arg;
 	if (!region_node) {
-		status = acpi_ns_lookup (walk_state->scope_info, arg->value.name,
-				  ACPI_TYPE_REGION, IMODE_EXECUTE,
-				  NS_SEARCH_PARENT, walk_state, &region_node);
+		status = acpi_ns_lookup (walk_state->scope_info, arg->common.value.name,
+				  ACPI_TYPE_REGION, ACPI_IMODE_EXECUTE,
+				  ACPI_NS_SEARCH_PARENT, walk_state, &region_node);
 		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_NSERROR (arg->common.value.name, status);
 			return_ACPI_STATUS (status);
 		}
 	}
 
-	/* Second arg is the Bank Register (must already exist) */
+	/* Second arg is the Bank Register (Field) (must already exist) */
 
-	arg = arg->next;
-	status = acpi_ns_lookup (walk_state->scope_info, arg->value.string,
-			  INTERNAL_TYPE_BANK_FIELD_DEFN, IMODE_EXECUTE,
-			  NS_SEARCH_PARENT, walk_state, &info.register_node);
+	arg = arg->common.next;
+	status = acpi_ns_lookup (walk_state->scope_info, arg->common.value.string,
+			  ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
+			  ACPI_NS_SEARCH_PARENT, walk_state, &info.register_node);
 	if (ACPI_FAILURE (status)) {
+		ACPI_REPORT_NSERROR (arg->common.value.string, status);
 		return_ACPI_STATUS (status);
 	}
 
-	/* Third arg is the Bank_value */
+	/* Third arg is the bank_value */
 
-	arg = arg->next;
-	info.bank_value = arg->value.integer32;
+	arg = arg->common.next;
+	info.bank_value = (u32) arg->common.value.integer;
 
 	/* Fourth arg is the field flags */
 
-	arg = arg->next;
-	info.field_flags = arg->value.integer8;
+	arg = arg->common.next;
+	info.field_flags = (u8) arg->common.value.integer;
 
 	/* Each remaining arg is a Named Field */
 
-	info.field_type = INTERNAL_TYPE_BANK_FIELD;
+	info.field_type = ACPI_TYPE_LOCAL_BANK_FIELD;
 	info.region_node = region_node;
 
-	status = acpi_ds_get_field_names (&info, walk_state, arg->next);
+	status = acpi_ds_get_field_names (&info, walk_state, arg->common.next);
 
 	return_ACPI_STATUS (status);
 }
@@ -387,11 +529,11 @@ acpi_ds_create_bank_field (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_create_index_field
+ * FUNCTION:    acpi_ds_create_index_field
  *
  * PARAMETERS:  Op              - Op containing the Field definition and args
- *              Region_node     - Object for the containing Operation Region
- *  `           Walk_state      - Current method state
+ *              region_node     - Object for the containing Operation Region
+ *  `           walk_state      - Current method state
  *
  * RETURN:      Status
  *
@@ -401,50 +543,51 @@ acpi_ds_create_bank_field (
 
 acpi_status
 acpi_ds_create_index_field (
-	acpi_parse_object       *op,
-	acpi_namespace_node     *region_node,
-	acpi_walk_state         *walk_state)
+	union acpi_parse_object         *op,
+	struct acpi_namespace_node      *region_node,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status;
-	acpi_parse_object       *arg;
-	ACPI_CREATE_FIELD_INFO  info;
+	acpi_status                     status;
+	union acpi_parse_object         *arg;
+	struct acpi_create_field_info   info;
 
 
-	FUNCTION_TRACE_PTR ("Ds_create_index_field", op);
+	ACPI_FUNCTION_TRACE_PTR ("ds_create_index_field", op);
 
 
 	/* First arg is the name of the Index register (must already exist) */
 
-	arg = op->value.arg;
-	status = acpi_ns_lookup (walk_state->scope_info, arg->value.string,
-			  ACPI_TYPE_ANY, IMODE_EXECUTE,
-			  NS_SEARCH_PARENT, walk_state, &info.register_node);
+	arg = op->common.value.arg;
+	status = acpi_ns_lookup (walk_state->scope_info, arg->common.value.string,
+			  ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
+			  ACPI_NS_SEARCH_PARENT, walk_state, &info.register_node);
 	if (ACPI_FAILURE (status)) {
+		ACPI_REPORT_NSERROR (arg->common.value.string, status);
 		return_ACPI_STATUS (status);
 	}
 
 	/* Second arg is the data register (must already exist) */
 
-	arg = arg->next;
-	status = acpi_ns_lookup (walk_state->scope_info, arg->value.string,
-			  INTERNAL_TYPE_INDEX_FIELD_DEFN, IMODE_EXECUTE,
-			  NS_SEARCH_PARENT, walk_state, &info.data_register_node);
+	arg = arg->common.next;
+	status = acpi_ns_lookup (walk_state->scope_info, arg->common.value.string,
+			  ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
+			  ACPI_NS_SEARCH_PARENT, walk_state, &info.data_register_node);
 	if (ACPI_FAILURE (status)) {
+		ACPI_REPORT_NSERROR (arg->common.value.string, status);
 		return_ACPI_STATUS (status);
 	}
 
 	/* Next arg is the field flags */
 
-	arg = arg->next;
-	info.field_flags = arg->value.integer8;
-
+	arg = arg->common.next;
+	info.field_flags = (u8) arg->common.value.integer;
 
 	/* Each remaining arg is a Named Field */
 
-	info.field_type = INTERNAL_TYPE_INDEX_FIELD;
+	info.field_type = ACPI_TYPE_LOCAL_INDEX_FIELD;
 	info.region_node = region_node;
 
-	status = acpi_ds_get_field_names (&info, walk_state, arg->next);
+	status = acpi_ds_get_field_names (&info, walk_state, arg->common.next);
 
 	return_ACPI_STATUS (status);
 }
diff -urNp linux-5400/drivers/acpi/dispatcher/dsinit.c linux-5410/drivers/acpi/dispatcher/dsinit.c
--- linux-5400/drivers/acpi/dispatcher/dsinit.c
+++ linux-5410/drivers/acpi/dispatcher/dsinit.c
@@ -0,0 +1,235 @@
+/******************************************************************************
+ *
+ * Module Name: dsinit - Object initialization namespace walk
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+
+#include <acpi/acpi.h>
+#include <acpi/acdispat.h>
+#include <acpi/acnamesp.h>
+
+#define _COMPONENT          ACPI_DISPATCHER
+	 ACPI_MODULE_NAME    ("dsinit")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_init_one_object
+ *
+ * PARAMETERS:  obj_handle      - Node
+ *              Level           - Current nesting level
+ *              Context         - Points to a init info struct
+ *              return_value    - Not used
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Callback from acpi_walk_namespace. Invoked for every object
+ *              within the namespace.
+ *
+ *              Currently, the only objects that require initialization are:
+ *              1) Methods
+ *              2) Operation Regions
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_init_one_object (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *context,
+	void                            **return_value)
+{
+	acpi_object_type                type;
+	acpi_status                     status;
+	struct acpi_init_walk_info      *info = (struct acpi_init_walk_info *) context;
+
+
+	ACPI_FUNCTION_NAME ("ds_init_one_object");
+
+
+	/*
+	 * We are only interested in objects owned by the table that
+	 * was just loaded
+	 */
+	if (((struct acpi_namespace_node *) obj_handle)->owner_id !=
+			info->table_desc->table_id) {
+		return (AE_OK);
+	}
+
+	info->object_count++;
+
+	/* And even then, we are only interested in a few object types */
+
+	type = acpi_ns_get_type (obj_handle);
+
+	switch (type) {
+	case ACPI_TYPE_REGION:
+
+		status = acpi_ds_initialize_region (obj_handle);
+		if (ACPI_FAILURE (status)) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Region %p [%4.4s] - Init failure, %s\n",
+				obj_handle, ((struct acpi_namespace_node *) obj_handle)->name.ascii,
+				acpi_format_exception (status)));
+		}
+
+		info->op_region_count++;
+		break;
+
+
+	case ACPI_TYPE_METHOD:
+
+		info->method_count++;
+
+		/* Print a dot for each method unless we are going to print the entire pathname */
+
+		if (!(acpi_dbg_level & ACPI_LV_INIT_NAMES)) {
+			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT, "."));
+		}
+
+		/*
+		 * Set the execution data width (32 or 64) based upon the
+		 * revision number of the parent ACPI table.
+		 * TBD: This is really for possible future support of integer width
+		 * on a per-table basis. Currently, we just use a global for the width.
+		 */
+		if (info->table_desc->pointer->revision == 1) {
+			((struct acpi_namespace_node *) obj_handle)->flags |= ANOBJ_DATA_WIDTH_32;
+		}
+
+		/*
+		 * Always parse methods to detect errors, we may delete
+		 * the parse tree below
+		 */
+		status = acpi_ds_parse_method (obj_handle);
+		if (ACPI_FAILURE (status)) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Method %p [%4.4s] - parse failure, %s\n",
+				obj_handle, ((struct acpi_namespace_node *) obj_handle)->name.ascii,
+				acpi_format_exception (status)));
+
+			/* This parse failed, but we will continue parsing more methods */
+
+			break;
+		}
+
+		/*
+		 * Delete the parse tree.  We simple re-parse the method
+		 * for every execution since there isn't much overhead
+		 */
+		acpi_ns_delete_namespace_subtree (obj_handle);
+		acpi_ns_delete_namespace_by_owner (((struct acpi_namespace_node *) obj_handle)->object->method.owning_id);
+		break;
+
+
+	case ACPI_TYPE_DEVICE:
+
+		info->device_count++;
+		break;
+
+
+	default:
+		break;
+	}
+
+	/*
+	 * We ignore errors from above, and always return OK, since
+	 * we don't want to abort the walk on a single error.
+	 */
+	return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_initialize_objects
+ *
+ * PARAMETERS:  table_desc      - Descriptor for parent ACPI table
+ *              start_node      - Root of subtree to be initialized.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Walk the namespace starting at "start_node" and perform any
+ *              necessary initialization on the objects found therein
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_initialize_objects (
+	struct acpi_table_desc          *table_desc,
+	struct acpi_namespace_node      *start_node)
+{
+	acpi_status                     status;
+	struct acpi_init_walk_info      info;
+
+
+	ACPI_FUNCTION_TRACE ("ds_initialize_objects");
+
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+		"**** Starting initialization of namespace objects ****\n"));
+	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT, "Parsing all Control Methods:"));
+
+	info.method_count   = 0;
+	info.op_region_count = 0;
+	info.object_count   = 0;
+	info.device_count   = 0;
+	info.table_desc     = table_desc;
+
+	/* Walk entire namespace from the supplied root */
+
+	status = acpi_walk_namespace (ACPI_TYPE_ANY, start_node, ACPI_UINT32_MAX,
+			  acpi_ds_init_one_object, &info, NULL);
+	if (ACPI_FAILURE (status)) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "walk_namespace failed, %s\n",
+			acpi_format_exception (status)));
+	}
+
+	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT,
+		"\nTable [%4.4s](id %4.4X) - %hd Objects with %hd Devices %hd Methods %hd Regions\n",
+		table_desc->pointer->signature, table_desc->table_id, info.object_count,
+		info.device_count, info.method_count, info.op_region_count));
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+		"%hd Methods, %hd Regions\n", info.method_count, info.op_region_count));
+
+	return_ACPI_STATUS (AE_OK);
+}
+
+
diff -urNp linux-5400/drivers/acpi/dispatcher/dsmethod.c linux-5410/drivers/acpi/dispatcher/dsmethod.c
--- linux-5400/drivers/acpi/dispatcher/dsmethod.c
+++ linux-5410/drivers/acpi/dispatcher/dsmethod.c
@@ -1,51 +1,67 @@
 /******************************************************************************
  *
  * Module Name: dsmethod - Parser/Interpreter interface - control method parsing
- *              $Revision: 69 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
-#include "amlcode.h"
-#include "acdispat.h"
-#include "acinterp.h"
-#include "acnamesp.h"
-#include "actables.h"
-#include "acdebug.h"
+#include <acpi/acpi.h>
+#include <acpi/acparser.h>
+#include <acpi/amlcode.h>
+#include <acpi/acdispat.h>
+#include <acpi/acinterp.h>
+#include <acpi/acnamesp.h>
 
 
 #define _COMPONENT          ACPI_DISPATCHER
-	 MODULE_NAME         ("dsmethod")
+	 ACPI_MODULE_NAME    ("dsmethod")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_parse_method
+ * FUNCTION:    acpi_ds_parse_method
  *
- * PARAMETERS:  Obj_handle      - Node of the method
+ * PARAMETERS:  obj_handle      - Node of the method
  *              Level           - Current nesting level
  *              Context         - Points to a method counter
- *              Return_value    - Not used
+ *              return_value    - Not used
  *
  * RETURN:      Status
  *
@@ -58,17 +74,17 @@
 
 acpi_status
 acpi_ds_parse_method (
-	acpi_handle             obj_handle)
+	acpi_handle                     obj_handle)
 {
-	acpi_status             status;
-	acpi_operand_object     *obj_desc;
-	acpi_parse_object       *op;
-	acpi_namespace_node     *node;
-	acpi_owner_id           owner_id;
-	acpi_walk_state         *walk_state;
+	acpi_status                     status;
+	union acpi_operand_object       *obj_desc;
+	union acpi_parse_object         *op;
+	struct acpi_namespace_node      *node;
+	acpi_owner_id                   owner_id;
+	struct acpi_walk_state          *walk_state;
 
 
-	FUNCTION_TRACE_PTR ("Ds_parse_method", obj_handle);
+	ACPI_FUNCTION_TRACE_PTR ("ds_parse_method", obj_handle);
 
 
 	/* Parameter Validation */
@@ -77,14 +93,13 @@ acpi_ds_parse_method (
 		return_ACPI_STATUS (AE_NULL_ENTRY);
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "**** Parsing [%4.4s] **** Named_obj=%p\n",
-		(char*)&((acpi_namespace_node *)obj_handle)->name, obj_handle));
-
+	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "**** Parsing [%4.4s] **** named_obj=%p\n",
+		((struct acpi_namespace_node *) obj_handle)->name.ascii, obj_handle));
 
 	/* Extract the method object from the method Node */
 
-	node = (acpi_namespace_node *) obj_handle;
-	obj_desc = node->object;
+	node = (struct acpi_namespace_node *) obj_handle;
+	obj_desc = acpi_ns_get_attached_object (node);
 	if (!obj_desc) {
 		return_ACPI_STATUS (AE_NULL_OBJECT);
 	}
@@ -112,13 +127,20 @@ acpi_ds_parse_method (
 
 	/* Init new op with the method name and pointer back to the Node */
 
-	acpi_ps_set_name (op, node->name);
-	op->node = node;
+	acpi_ps_set_name (op, node->name.integer);
+	op->common.node = node;
+
+	/*
+	 * Get a new owner_id for objects created by this method. Namespace
+	 * objects (such as Operation Regions) can be created during the
+	 * first pass parse.
+	 */
+	owner_id = acpi_ut_allocate_owner_id (ACPI_OWNER_TYPE_METHOD);
+	obj_desc->method.owning_id = owner_id;
 
 	/* Create and initialize a new walk state */
 
-	walk_state = acpi_ds_create_walk_state (TABLE_ID_DSDT,
-			   NULL, NULL, NULL);
+	walk_state = acpi_ds_create_walk_state (owner_id, NULL, NULL, NULL);
 	if (!walk_state) {
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
@@ -126,7 +148,7 @@ acpi_ds_parse_method (
 	status = acpi_ds_init_aml_walk (walk_state, op, node, obj_desc->method.aml_start,
 			  obj_desc->method.aml_length, NULL, NULL, 1);
 	if (ACPI_FAILURE (status)) {
-		/* TBD: delete walk state */
+		acpi_ds_delete_walk_state (walk_state);
 		return_ACPI_STATUS (status);
 	}
 
@@ -145,27 +167,22 @@ acpi_ds_parse_method (
 		return_ACPI_STATUS (status);
 	}
 
-	/* Get a new Owner_id for objects created by this method */
-
-	owner_id = acpi_ut_allocate_owner_id (OWNER_TYPE_METHOD);
-	obj_desc->method.owning_id = owner_id;
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "**** [%4.4s] Parsed **** Named_obj=%p Op=%p\n",
-		(char*)&((acpi_namespace_node *)obj_handle)->name, obj_handle, op));
+	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
+		"**** [%4.4s] Parsed **** named_obj=%p Op=%p\n",
+		((struct acpi_namespace_node *) obj_handle)->name.ascii, obj_handle, op));
 
 	acpi_ps_delete_parse_tree (op);
-
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_begin_method_execution
+ * FUNCTION:    acpi_ds_begin_method_execution
  *
- * PARAMETERS:  Method_node         - Node of the method
- *              Obj_desc            - The method object
- *              Calling_method_node - Caller of this method (if non-null)
+ * PARAMETERS:  method_node         - Node of the method
+ *              obj_desc            - The method object
+ *              calling_method_node - Caller of this method (if non-null)
  *
  * RETURN:      Status
  *
@@ -179,21 +196,20 @@ acpi_ds_parse_method (
 
 acpi_status
 acpi_ds_begin_method_execution (
-	acpi_namespace_node     *method_node,
-	acpi_operand_object     *obj_desc,
-	acpi_namespace_node     *calling_method_node)
+	struct acpi_namespace_node      *method_node,
+	union acpi_operand_object       *obj_desc,
+	struct acpi_namespace_node      *calling_method_node)
 {
-	acpi_status             status = AE_OK;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE_PTR ("Ds_begin_method_execution", method_node);
+	ACPI_FUNCTION_TRACE_PTR ("ds_begin_method_execution", method_node);
 
 
 	if (!method_node) {
 		return_ACPI_STATUS (AE_NULL_ENTRY);
 	}
 
-
 	/*
 	 * If there is a concurrency limit on this method, we need to
 	 * obtain a unit from the method semaphore.
@@ -201,7 +217,7 @@ acpi_ds_begin_method_execution (
 	if (obj_desc->method.semaphore) {
 		/*
 		 * Allow recursive method calls, up to the reentrancy/concurrency
-		 * limit imposed by the SERIALIZED rule and the Sync_level method
+		 * limit imposed by the SERIALIZED rule and the sync_level method
 		 * parameter.
 		 *
 		 * The point of this code is to avoid permanently blocking a
@@ -218,25 +234,23 @@ acpi_ds_begin_method_execution (
 		 * interpreter if we block
 		 */
 		status = acpi_ex_system_wait_semaphore (obj_desc->method.semaphore,
-				 WAIT_FOREVER);
+				 ACPI_WAIT_FOREVER);
 	}
 
-
 	/*
 	 * Increment the method parse tree thread count since it has been
 	 * reentered one more time (even if it is the same thread)
 	 */
 	obj_desc->method.thread_count++;
-
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_call_control_method
+ * FUNCTION:    acpi_ds_call_control_method
  *
- * PARAMETERS:  Walk_state          - Current state of the walk
+ * PARAMETERS:  walk_state          - Current state of the walk
  *              Op                  - Current Op to be walked
  *
  * RETURN:      Status
@@ -247,18 +261,18 @@ acpi_ds_begin_method_execution (
 
 acpi_status
 acpi_ds_call_control_method (
-	acpi_walk_list          *walk_list,
-	acpi_walk_state         *this_walk_state,
-	acpi_parse_object       *op)  /* TBD: This operand is obsolete */
+	struct acpi_thread_state        *thread,
+	struct acpi_walk_state          *this_walk_state,
+	union acpi_parse_object         *op)
 {
-	acpi_status             status;
-	acpi_namespace_node     *method_node;
-	acpi_operand_object     *obj_desc;
-	acpi_walk_state         *next_walk_state;
-	u32                     i;
+	acpi_status                     status;
+	struct acpi_namespace_node      *method_node;
+	union acpi_operand_object       *obj_desc;
+	struct acpi_walk_state          *next_walk_state;
+	u32                             i;
 
 
-	FUNCTION_TRACE_PTR ("Ds_call_control_method", this_walk_state);
+	ACPI_FUNCTION_TRACE_PTR ("ds_call_control_method", this_walk_state);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Execute method %p, currentstate=%p\n",
 		this_walk_state->prev_op, this_walk_state));
@@ -276,6 +290,8 @@ acpi_ds_call_control_method (
 		return_ACPI_STATUS (AE_NULL_OBJECT);
 	}
 
+	obj_desc->method.owning_id = acpi_ut_allocate_owner_id (ACPI_OWNER_TYPE_METHOD);
+
 	/* Init for new method, wait on concurrency semaphore */
 
 	status = acpi_ds_begin_method_execution (method_node, obj_desc,
@@ -284,19 +300,17 @@ acpi_ds_call_control_method (
 		return_ACPI_STATUS (status);
 	}
 
-
 	/* 1) Parse: Create a new walk state for the preempting walk */
 
 	next_walk_state = acpi_ds_create_walk_state (obj_desc->method.owning_id,
 			  op, obj_desc, NULL);
 	if (!next_walk_state) {
 		return_ACPI_STATUS (AE_NO_MEMORY);
-		goto cleanup;
 	}
 
 	/* Create and init a Root Node */
 
-	op = acpi_ps_alloc_op (AML_SCOPE_OP);
+	op = acpi_ps_create_scope_op ();
 	if (!op) {
 		status = AE_NO_MEMORY;
 		goto cleanup;
@@ -306,7 +320,7 @@ acpi_ds_call_control_method (
 			  obj_desc->method.aml_start, obj_desc->method.aml_length,
 			  NULL, NULL, 1);
 	if (ACPI_FAILURE (status)) {
-		/* TBD: delete walk state */
+		acpi_ds_delete_walk_state (next_walk_state);
 		goto cleanup;
 	}
 
@@ -315,11 +329,10 @@ acpi_ds_call_control_method (
 	status = acpi_ps_parse_aml (next_walk_state);
 	acpi_ps_delete_parse_tree (op);
 
-
 	/* 2) Execute: Create a new state for the preempting walk */
 
 	next_walk_state = acpi_ds_create_walk_state (obj_desc->method.owning_id,
-			  NULL, obj_desc, walk_list);
+			  NULL, obj_desc, thread);
 	if (!next_walk_state) {
 		status = AE_NO_MEMORY;
 		goto cleanup;
@@ -353,8 +366,8 @@ acpi_ds_call_control_method (
 
 	this_walk_state->num_operands = 0;
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Starting nested execution, newstate=%p\n",
-		next_walk_state));
+	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+		"Starting nested execution, newstate=%p\n", next_walk_state));
 
 	return_ACPI_STATUS (AE_OK);
 
@@ -362,7 +375,7 @@ acpi_ds_call_control_method (
 	/* On error, we must delete the new walk state */
 
 cleanup:
-	acpi_ds_terminate_control_method (next_walk_state);
+	(void) acpi_ds_terminate_control_method (next_walk_state);
 	acpi_ds_delete_walk_state (next_walk_state);
 	return_ACPI_STATUS (status);
 
@@ -371,9 +384,9 @@ cleanup:
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_restart_control_method
+ * FUNCTION:    acpi_ds_restart_control_method
  *
- * PARAMETERS:  Walk_state          - State of the method when it was preempted
+ * PARAMETERS:  walk_state          - State of the method when it was preempted
  *              Op                  - Pointer to new current op
  *
  * RETURN:      Status
@@ -384,13 +397,13 @@ cleanup:
 
 acpi_status
 acpi_ds_restart_control_method (
-	acpi_walk_state         *walk_state,
-	acpi_operand_object     *return_desc)
+	struct acpi_walk_state          *walk_state,
+	union acpi_operand_object       *return_desc)
 {
-	acpi_status             status;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE_PTR ("Ds_restart_control_method", walk_state);
+	ACPI_FUNCTION_TRACE_PTR ("ds_restart_control_method", walk_state);
 
 
 	if (return_desc) {
@@ -405,7 +418,6 @@ acpi_ds_restart_control_method (
 				return_ACPI_STATUS (status);
 			}
 		}
-
 		else {
 			/*
 			 * Delete the return value if it will not be used by the
@@ -413,24 +425,22 @@ acpi_ds_restart_control_method (
 			 */
 			acpi_ut_remove_reference (return_desc);
 		}
-
 	}
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-		"Method=%p Return=%p Return_used?=%X Res_stack=%p State=%p\n",
+		"Method=%p Return=%p return_used?=%X res_stack=%p State=%p\n",
 		walk_state->method_call_op, return_desc, walk_state->return_used,
 		walk_state->results, walk_state));
 
-
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_terminate_control_method
+ * FUNCTION:    acpi_ds_terminate_control_method
  *
- * PARAMETERS:  Walk_state          - State of the method
+ * PARAMETERS:  walk_state          - State of the method
  *
  * RETURN:      Status
  *
@@ -442,16 +452,21 @@ acpi_ds_restart_control_method (
 
 acpi_status
 acpi_ds_terminate_control_method (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_operand_object     *obj_desc;
-	acpi_namespace_node     *method_node;
+	union acpi_operand_object       *obj_desc;
+	struct acpi_namespace_node      *method_node;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE_PTR ("Ds_terminate_control_method", walk_state);
+	ACPI_FUNCTION_TRACE_PTR ("ds_terminate_control_method", walk_state);
 
 
-	/* The method object should be stored in the walk state */
+	if (!walk_state) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* The current method object was saved in the walk state */
 
 	obj_desc = walk_state->method_desc;
 	if (!obj_desc) {
@@ -467,14 +482,22 @@ acpi_ds_terminate_control_method (
 	 * If this is the last thread executing the method,
 	 * we have additional cleanup to perform
 	 */
-	acpi_ut_acquire_mutex (ACPI_MTX_PARSER);
-
+	status = acpi_ut_acquire_mutex (ACPI_MTX_PARSER);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	/* Signal completion of the execution of this method if necessary */
 
 	if (walk_state->method_desc->method.semaphore) {
-		acpi_os_signal_semaphore (
-			walk_state->method_desc->method.semaphore, 1);
+		status = acpi_os_signal_semaphore (
+				  walk_state->method_desc->method.semaphore, 1);
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_ERROR (("Could not signal method semaphore\n"));
+			status = AE_OK;
+
+			/* Ignore error and continue cleanup */
+		}
 	}
 
 	/* Decrement the thread count on the method parse tree */
@@ -493,7 +516,11 @@ acpi_ds_terminate_control_method (
 		 * Delete any namespace entries created immediately underneath
 		 * the method
 		 */
-		acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+		status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
+
 		if (method_node->child) {
 			acpi_ns_delete_namespace_subtree (method_node);
 		}
@@ -503,11 +530,14 @@ acpi_ds_terminate_control_method (
 		 * the namespace
 		 */
 		acpi_ns_delete_namespace_by_owner (walk_state->method_desc->method.owning_id);
-		acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+		status = acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
 	}
 
-	acpi_ut_release_mutex (ACPI_MTX_PARSER);
-	return_ACPI_STATUS (AE_OK);
+	status = acpi_ut_release_mutex (ACPI_MTX_PARSER);
+	return_ACPI_STATUS (status);
 }
 
 
diff -urNp linux-5400/drivers/acpi/dispatcher/dsmthdat.c linux-5410/drivers/acpi/dispatcher/dsmthdat.c
--- linux-5400/drivers/acpi/dispatcher/dsmthdat.c
+++ linux-5410/drivers/acpi/dispatcher/dsmthdat.c
@@ -1,193 +1,196 @@
 /*******************************************************************************
  *
  * Module Name: dsmthdat - control method arguments and local variables
- *              $Revision: 49 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
-#include "acdispat.h"
-#include "acinterp.h"
-#include "amlcode.h"
-#include "acnamesp.h"
+#include <acpi/acpi.h>
+#include <acpi/acdispat.h>
+#include <acpi/amlcode.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acinterp.h>
 
 
 #define _COMPONENT          ACPI_DISPATCHER
-	 MODULE_NAME         ("dsmthdat")
+	 ACPI_MODULE_NAME    ("dsmthdat")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_method_data_init
+ * FUNCTION:    acpi_ds_method_data_init
  *
- * PARAMETERS:  Walk_state          - Current walk state object
+ * PARAMETERS:  walk_state          - Current walk state object
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Initialize the data structures that hold the method's arguments
  *              and locals.  The data struct is an array of NTEs for each.
- *              This allows Ref_of and De_ref_of to work properly for these
+ *              This allows ref_of and de_ref_of to work properly for these
  *              special data types.
  *
+ * NOTES:       walk_state fields are initialized to zero by the
+ *              ACPI_MEM_CALLOCATE().
+ *
+ *              A pseudo-Namespace Node is assigned to each argument and local
+ *              so that ref_of() can return a pointer to the Node.
+ *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ds_method_data_init (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	u32                     i;
+	u32                             i;
 
 
-	FUNCTION_TRACE ("Ds_method_data_init");
+	ACPI_FUNCTION_TRACE ("ds_method_data_init");
 
-	/*
-	 * Walk_state fields are initialized to zero by the
-	 * ACPI_MEM_CALLOCATE().
-	 *
-	 * An Node is assigned to each argument and local so
-	 * that Ref_of() can return a pointer to the Node.
-	 */
 
 	/* Init the method arguments */
 
-	for (i = 0; i < MTH_NUM_ARGS; i++) {
-		MOVE_UNALIGNED32_TO_32 (&walk_state->arguments[i].name,
-				 NAMEOF_ARG_NTE);
-		walk_state->arguments[i].name      |= (i << 24);
-		walk_state->arguments[i].data_type  = ACPI_DESC_TYPE_NAMED;
-		walk_state->arguments[i].type       = ACPI_TYPE_ANY;
-		walk_state->arguments[i].flags      = ANOBJ_END_OF_PEER_LIST | ANOBJ_METHOD_ARG;
+	for (i = 0; i < ACPI_METHOD_NUM_ARGS; i++) {
+		ACPI_MOVE_32_TO_32 (&walk_state->arguments[i].name,
+				   NAMEOF_ARG_NTE);
+		walk_state->arguments[i].name.integer |= (i << 24);
+		walk_state->arguments[i].descriptor   = ACPI_DESC_TYPE_NAMED;
+		walk_state->arguments[i].type         = ACPI_TYPE_ANY;
+		walk_state->arguments[i].flags        = ANOBJ_END_OF_PEER_LIST | ANOBJ_METHOD_ARG;
 	}
 
 	/* Init the method locals */
 
-	for (i = 0; i < MTH_NUM_LOCALS; i++) {
-		MOVE_UNALIGNED32_TO_32 (&walk_state->local_variables[i].name,
-				 NAMEOF_LOCAL_NTE);
-
-		walk_state->local_variables[i].name  |= (i << 24);
-		walk_state->local_variables[i].data_type = ACPI_DESC_TYPE_NAMED;
-		walk_state->local_variables[i].type   = ACPI_TYPE_ANY;
-		walk_state->local_variables[i].flags  = ANOBJ_END_OF_PEER_LIST | ANOBJ_METHOD_LOCAL;
+	for (i = 0; i < ACPI_METHOD_NUM_LOCALS; i++) {
+		ACPI_MOVE_32_TO_32 (&walk_state->local_variables[i].name,
+				   NAMEOF_LOCAL_NTE);
+
+		walk_state->local_variables[i].name.integer |= (i << 24);
+		walk_state->local_variables[i].descriptor  = ACPI_DESC_TYPE_NAMED;
+		walk_state->local_variables[i].type        = ACPI_TYPE_ANY;
+		walk_state->local_variables[i].flags       = ANOBJ_END_OF_PEER_LIST | ANOBJ_METHOD_LOCAL;
 	}
 
-	return_ACPI_STATUS (AE_OK);
+	return_VOID;
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_method_data_delete_all
+ * FUNCTION:    acpi_ds_method_data_delete_all
  *
- * PARAMETERS:  Walk_state          - Current walk state object
+ * PARAMETERS:  walk_state          - Current walk state object
  *
- * RETURN:      Status
+ * RETURN:      None
  *
  * DESCRIPTION: Delete method locals and arguments.  Arguments are only
  *              deleted if this method was called from another method.
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ds_method_data_delete_all (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	u32                     index;
-	acpi_operand_object     *object;
+	u32                             index;
 
 
-	FUNCTION_TRACE ("Ds_method_data_delete_all");
+	ACPI_FUNCTION_TRACE ("ds_method_data_delete_all");
 
 
-	/* Delete the locals */
+	/* Detach the locals */
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Deleting local variables in %p\n", walk_state));
+	for (index = 0; index < ACPI_METHOD_NUM_LOCALS; index++) {
+		if (walk_state->local_variables[index].object) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Deleting Local%d=%p\n",
+					index, walk_state->local_variables[index].object));
 
-	for (index = 0; index < MTH_NUM_LOCALS; index++) {
-		object = walk_state->local_variables[index].object;
-		if (object) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Deleting Local%d=%p\n", index, object));
+			/* Detach object (if present) and remove a reference */
 
-			/* Remove first */
-
-			walk_state->local_variables[index].object = NULL;
-
-			/* Was given a ref when stored */
-
-			acpi_ut_remove_reference (object);
-	   }
+			acpi_ns_detach_object (&walk_state->local_variables[index]);
+		}
 	}
 
+	/* Detach the arguments */
 
-	/* Delete the arguments */
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Deleting arguments in %p\n", walk_state));
-
-	for (index = 0; index < MTH_NUM_ARGS; index++) {
-		object = walk_state->arguments[index].object;
-		if (object) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Deleting Arg%d=%p\n", index, object));
-
-			/* Remove first */
-
-			walk_state->arguments[index].object = NULL;
+	for (index = 0; index < ACPI_METHOD_NUM_ARGS; index++) {
+		if (walk_state->arguments[index].object) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Deleting Arg%d=%p\n",
+					index, walk_state->arguments[index].object));
 
-			 /* Was given a ref when stored */
+			/* Detach object (if present) and remove a reference */
 
-			acpi_ut_remove_reference (object);
+			acpi_ns_detach_object (&walk_state->arguments[index]);
 		}
 	}
 
-	return_ACPI_STATUS (AE_OK);
+	return_VOID;
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_method_data_init_args
+ * FUNCTION:    acpi_ds_method_data_init_args
  *
  * PARAMETERS:  *Params         - Pointer to a parameter list for the method
- *              Max_param_count - The arg count for this method
- *              Walk_state      - Current walk state object
+ *              max_param_count - The arg count for this method
+ *              walk_state      - Current walk state object
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Initialize arguments for a method
+ * DESCRIPTION: Initialize arguments for a method.  The parameter list is a list
+ *              of ACPI operand objects, either null terminated or whose length
+ *              is defined by max_param_count.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ds_method_data_init_args (
-	acpi_operand_object     **params,
-	u32                     max_param_count,
-	acpi_walk_state         *walk_state)
+	union acpi_operand_object       **params,
+	u32                             max_param_count,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status;
-	u32                     mindex;
-	u32                     pindex;
+	acpi_status                     status;
+	u32                             index = 0;
 
 
-	FUNCTION_TRACE_PTR ("Ds_method_data_init_args", params);
+	ACPI_FUNCTION_TRACE_PTR ("ds_method_data_init_args", params);
 
 
 	if (!params) {
@@ -197,293 +200,224 @@ acpi_ds_method_data_init_args (
 
 	/* Copy passed parameters into the new method stack frame  */
 
-	for (pindex = mindex = 0;
-		(mindex < MTH_NUM_ARGS) && (pindex < max_param_count);
-		mindex++) {
-		if (params[pindex]) {
-			/*
-			 * A valid parameter.
-			 * Set the current method argument to the
-			 * Params[Pindex++] argument object descriptor
-			 */
-			status = acpi_ds_store_object_to_local (AML_ARG_OP, mindex,
-					  params[pindex], walk_state);
-			if (ACPI_FAILURE (status)) {
-				break;
-			}
-
-			pindex++;
+	while ((index < ACPI_METHOD_NUM_ARGS) && (index < max_param_count) && params[index]) {
+		/*
+		 * A valid parameter.
+		 * Store the argument in the method/walk descriptor
+		 */
+		status = acpi_ds_store_object_to_local (AML_ARG_OP, index, params[index],
+				 walk_state);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
 		}
 
-		else {
-			break;
-		}
+		index++;
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "%d args passed to method\n", pindex));
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "%d args passed to method\n", index));
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_method_data_get_entry
+ * FUNCTION:    acpi_ds_method_data_get_node
  *
  * PARAMETERS:  Opcode              - Either AML_LOCAL_OP or AML_ARG_OP
- *              Index               - Which local_var or argument to get
- *              Entry               - Pointer to where a pointer to the stack
- *                                    entry is returned.
- *              Walk_state          - Current walk state object
- *
- * RETURN:      Status
+ *              Index               - which local_var or argument whose type
+ *                                      to get
+ *              walk_state          - Current walk state object
  *
- * DESCRIPTION: Get the address of the object entry given by Opcode:Index
+ * RETURN:      Get the Node associated with a local or arg.
  *
  ******************************************************************************/
 
 acpi_status
-acpi_ds_method_data_get_entry (
-	u16                     opcode,
-	u32                     index,
-	acpi_walk_state         *walk_state,
-	acpi_operand_object     ***entry)
+acpi_ds_method_data_get_node (
+	u16                             opcode,
+	u32                             index,
+	struct acpi_walk_state          *walk_state,
+	struct acpi_namespace_node      **node)
 {
-
-	FUNCTION_TRACE_U32 ("Ds_method_data_get_entry", index);
+	ACPI_FUNCTION_TRACE ("ds_method_data_get_node");
 
 
 	/*
-	 * Get the requested object.
-	 * The stack "Opcode" is either a Local_variable or an Argument
+	 * Method Locals and Arguments are supported
 	 */
 	switch (opcode) {
-
 	case AML_LOCAL_OP:
 
-		if (index > MTH_MAX_LOCAL) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Local_var index %d is invalid (max %d)\n",
-				index, MTH_MAX_LOCAL));
-			return_ACPI_STATUS (AE_BAD_PARAMETER);
+		if (index > ACPI_METHOD_MAX_LOCAL) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Local index %d is invalid (max %d)\n",
+				index, ACPI_METHOD_MAX_LOCAL));
+			return_ACPI_STATUS (AE_AML_INVALID_INDEX);
 		}
 
-		*entry = (acpi_operand_object  **)
-				 &walk_state->local_variables[index].object;
-		break;
+		/* Return a pointer to the pseudo-node */
 
+		*node = &walk_state->local_variables[index];
+		break;
 
 	case AML_ARG_OP:
 
-		if (index > MTH_MAX_ARG) {
+		if (index > ACPI_METHOD_MAX_ARG) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Arg index %d is invalid (max %d)\n",
-				index, MTH_MAX_ARG));
-			return_ACPI_STATUS (AE_BAD_PARAMETER);
+				index, ACPI_METHOD_MAX_ARG));
+			return_ACPI_STATUS (AE_AML_INVALID_INDEX);
 		}
 
-		*entry = (acpi_operand_object  **)
-				 &walk_state->arguments[index].object;
-		break;
+		/* Return a pointer to the pseudo-node */
 
+		*node = &walk_state->arguments[index];
+		break;
 
 	default:
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Opcode %d is invalid\n", opcode));
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
+		return_ACPI_STATUS (AE_AML_BAD_OPCODE);
 	}
 
-
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_method_data_set_entry
+ * FUNCTION:    acpi_ds_method_data_set_value
  *
  * PARAMETERS:  Opcode              - Either AML_LOCAL_OP or AML_ARG_OP
- *              Index               - Which local_var or argument to get
+ *              Index               - which local_var or argument to get
  *              Object              - Object to be inserted into the stack entry
- *              Walk_state          - Current walk state object
+ *              walk_state          - Current walk state object
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Insert an object onto the method stack at entry Opcode:Index.
+ *              Note: There is no "implicit conversion" for locals.
  *
  ******************************************************************************/
 
 acpi_status
-acpi_ds_method_data_set_entry (
-	u16                     opcode,
-	u32                     index,
-	acpi_operand_object     *object,
-	acpi_walk_state         *walk_state)
+acpi_ds_method_data_set_value (
+	u16                             opcode,
+	u32                             index,
+	union acpi_operand_object       *object,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status;
-	acpi_operand_object     **entry;
+	acpi_status                     status;
+	struct acpi_namespace_node      *node;
+
 
+	ACPI_FUNCTION_TRACE ("ds_method_data_set_value");
 
-	FUNCTION_TRACE ("Ds_method_data_set_entry");
 
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+		"obj %p op %X, ref count = %d [%s]\n", object,
+		opcode, object->common.reference_count,
+		acpi_ut_get_type_name (object->common.type)));
 
-	/* Get a pointer to the stack entry to set */
+	/* Get the namespace node for the arg/local */
 
-	status = acpi_ds_method_data_get_entry (opcode, index, walk_state, &entry);
+	status = acpi_ds_method_data_get_node (opcode, index, walk_state, &node);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
-	/* Increment ref count so object can't be deleted while installed */
-
+	/*
+	 * Increment ref count so object can't be deleted while installed.
+	 * NOTE: We do not copy the object in order to preserve the call by
+	 * reference semantics of ACPI Control Method invocation.
+	 * (See ACPI specification 2.0_c)
+	 */
 	acpi_ut_add_reference (object);
 
-	/* Install the object into the stack entry */
-
-	*entry = object;
+	/* Install the object */
 
-	return_ACPI_STATUS (AE_OK);
+	node->object = object;
+	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_method_data_get_type
+ * FUNCTION:    acpi_ds_method_data_get_type
  *
  * PARAMETERS:  Opcode              - Either AML_LOCAL_OP or AML_ARG_OP
- *              Index               - Which local_var or argument whose type
+ *              Index               - which local_var or argument whose type
  *                                      to get
- *              Walk_state          - Current walk state object
+ *              walk_state          - Current walk state object
  *
- * RETURN:      Data type of selected Arg or Local
- *              Used only in Exec_monadic2()/Type_op.
+ * RETURN:      Data type of current value of the selected Arg or Local
  *
  ******************************************************************************/
 
-acpi_object_type8
+acpi_object_type
 acpi_ds_method_data_get_type (
-	u16                     opcode,
-	u32                     index,
-	acpi_walk_state         *walk_state)
+	u16                             opcode,
+	u32                             index,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status;
-	acpi_operand_object     **entry;
-	acpi_operand_object     *object;
+	acpi_status                     status;
+	struct acpi_namespace_node      *node;
+	union acpi_operand_object       *object;
 
 
-	FUNCTION_TRACE ("Ds_method_data_get_type");
+	ACPI_FUNCTION_TRACE ("ds_method_data_get_type");
 
 
-	/* Get a pointer to the requested stack entry */
+	/* Get the namespace node for the arg/local */
 
-	status = acpi_ds_method_data_get_entry (opcode, index, walk_state, &entry);
+	status = acpi_ds_method_data_get_node (opcode, index, walk_state, &node);
 	if (ACPI_FAILURE (status)) {
 		return_VALUE ((ACPI_TYPE_NOT_FOUND));
 	}
 
-	/* Get the object from the method stack */
-
-	object = *entry;
-
-	/* Get the object type */
+	/* Get the object */
 
+	object = acpi_ns_get_attached_object (node);
 	if (!object) {
-		/* Any == 0 => "uninitialized" -- see spec 15.2.3.5.2.28 */
-		return_VALUE (ACPI_TYPE_ANY);
-	}
-
-	return_VALUE (object->common.type);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ds_method_data_get_node
- *
- * PARAMETERS:  Opcode              - Either AML_LOCAL_OP or AML_ARG_OP
- *              Index               - Which local_var or argument whose type
- *                                      to get
- *              Walk_state          - Current walk state object
- *
- * RETURN:      Get the Node associated with a local or arg.
- *
- ******************************************************************************/
+		/* Uninitialized local/arg, return TYPE_ANY */
 
-acpi_namespace_node *
-acpi_ds_method_data_get_node (
-	u16                     opcode,
-	u32                     index,
-	acpi_walk_state         *walk_state)
-{
-	acpi_namespace_node     *node = NULL;
-
-
-	FUNCTION_TRACE ("Ds_method_data_get_node");
-
-
-	switch (opcode) {
-
-	case AML_LOCAL_OP:
-
-		if (index > MTH_MAX_LOCAL) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Local index %d is invalid (max %d)\n",
-				index, MTH_MAX_LOCAL));
-			return_PTR (node);
-		}
-
-		node =  &walk_state->local_variables[index];
-		break;
-
-
-	case AML_ARG_OP:
-
-		if (index > MTH_MAX_ARG) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Arg index %d is invalid (max %d)\n",
-				index, MTH_MAX_ARG));
-			return_PTR (node);
-		}
-
-		node = &walk_state->arguments[index];
-		break;
-
-
-	default:
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Opcode %d is invalid\n", opcode));
-		break;
+		return_VALUE (ACPI_TYPE_ANY);
 	}
 
+	/* Get the object type */
 
-	return_PTR (node);
+	return_VALUE (ACPI_GET_OBJECT_TYPE (object));
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_method_data_get_value
+ * FUNCTION:    acpi_ds_method_data_get_value
  *
  * PARAMETERS:  Opcode              - Either AML_LOCAL_OP or AML_ARG_OP
- *              Index               - Which local_var or argument to get
- *              Walk_state          - Current walk state object
- *              *Dest_desc          - Ptr to Descriptor into which selected Arg
+ *              Index               - which local_var or argument to get
+ *              walk_state          - Current walk state object
+ *              *dest_desc          - Ptr to Descriptor into which selected Arg
  *                                    or Local value should be copied
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Retrieve value of selected Arg or Local from the method frame
  *              at the current top of the method stack.
- *              Used only in Acpi_ex_resolve_to_value().
+ *              Used only in acpi_ex_resolve_to_value().
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ds_method_data_get_value (
-	u16                     opcode,
-	u32                     index,
-	acpi_walk_state         *walk_state,
-	acpi_operand_object     **dest_desc)
+	u16                             opcode,
+	u32                             index,
+	struct acpi_walk_state          *walk_state,
+	union acpi_operand_object       **dest_desc)
 {
-	acpi_status             status;
-	acpi_operand_object     **entry;
-	acpi_operand_object     *object;
+	acpi_status                     status;
+	struct acpi_namespace_node      *node;
+	union acpi_operand_object       *object;
 
 
-	FUNCTION_TRACE ("Ds_method_data_get_value");
+	ACPI_FUNCTION_TRACE ("ds_method_data_get_value");
 
 
 	/* Validate the object descriptor */
@@ -493,24 +427,22 @@ acpi_ds_method_data_get_value (
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
+	/* Get the namespace node for the arg/local */
 
-	/* Get a pointer to the requested method stack entry */
-
-	status = acpi_ds_method_data_get_entry (opcode, index, walk_state, &entry);
+	status = acpi_ds_method_data_get_node (opcode, index, walk_state, &node);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
-	/* Get the object from the method stack */
-
-	object = *entry;
+	/* Get the object from the node */
 
+	object = node->object;
 
 	/* Examine the returned object, it must be valid. */
 
 	if (!object) {
 		/*
-		 * Index points to uninitialized object stack value.
+		 * Index points to uninitialized object.
 		 * This means that either 1) The expected argument was
 		 * not passed to the method, or 2) A local variable
 		 * was referenced by the method (via the ASL)
@@ -519,25 +451,25 @@ acpi_ds_method_data_get_value (
 		switch (opcode) {
 		case AML_ARG_OP:
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Uninitialized Arg[%d] at entry %p\n",
-				index, entry));
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Uninitialized Arg[%d] at node %p\n",
+				index, node));
 
 			return_ACPI_STATUS (AE_AML_UNINITIALIZED_ARG);
-			break;
 
 		case AML_LOCAL_OP:
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Uninitialized Local[%d] at entry %p\n",
-				index, entry));
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Uninitialized Local[%d] at node %p\n",
+				index, node));
 
 			return_ACPI_STATUS (AE_AML_UNINITIALIZED_LOCAL);
-			break;
+
+		default:
+			return_ACPI_STATUS (AE_AML_INTERNAL);
 		}
 	}
 
-
 	/*
-	 * Index points to initialized and valid object stack value.
+	 * The Index points to an initialized and valid object.
 	 * Return an additional reference to the object
 	 */
 	*dest_desc = object;
@@ -549,125 +481,126 @@ acpi_ds_method_data_get_value (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_method_data_delete_value
+ * FUNCTION:    acpi_ds_method_data_delete_value
  *
  * PARAMETERS:  Opcode              - Either AML_LOCAL_OP or AML_ARG_OP
- *              Index               - Which local_var or argument to delete
- *              Walk_state          - Current walk state object
+ *              Index               - which local_var or argument to delete
+ *              walk_state          - Current walk state object
  *
- * RETURN:      Status
+ * RETURN:      None
  *
  * DESCRIPTION: Delete the entry at Opcode:Index on the method stack.  Inserts
  *              a null into the stack slot after the object is deleted.
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ds_method_data_delete_value (
-	u16                     opcode,
-	u32                     index,
-	acpi_walk_state         *walk_state)
+	u16                             opcode,
+	u32                             index,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status;
-	acpi_operand_object     **entry;
-	acpi_operand_object     *object;
+	acpi_status                     status;
+	struct acpi_namespace_node      *node;
+	union acpi_operand_object       *object;
 
 
-	FUNCTION_TRACE ("Ds_method_data_delete_value");
+	ACPI_FUNCTION_TRACE ("ds_method_data_delete_value");
 
 
-	/* Get a pointer to the requested entry */
+	/* Get the namespace node for the arg/local */
 
-	status = acpi_ds_method_data_get_entry (opcode, index, walk_state, &entry);
+	status = acpi_ds_method_data_get_node (opcode, index, walk_state, &node);
 	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
+		return_VOID;
 	}
 
-	/* Get the current entry in this slot k */
+	/* Get the associated object */
 
-	object = *entry;
+	object = acpi_ns_get_attached_object (node);
 
 	/*
 	 * Undefine the Arg or Local by setting its descriptor
 	 * pointer to NULL. Locals/Args can contain both
 	 * ACPI_OPERAND_OBJECTS and ACPI_NAMESPACE_NODEs
 	 */
-	*entry = NULL;
+	node->object = NULL;
 
 	if ((object) &&
-		(VALID_DESCRIPTOR_TYPE (object, ACPI_DESC_TYPE_INTERNAL))) {
+		(ACPI_GET_DESCRIPTOR_TYPE (object) == ACPI_DESC_TYPE_OPERAND)) {
 		/*
-		 * There is a valid object in this slot
+		 * There is a valid object.
 		 * Decrement the reference count by one to balance the
-		 * increment when the object was stored in the slot.
+		 * increment when the object was stored.
 		 */
 		acpi_ut_remove_reference (object);
 	}
 
-	return_ACPI_STATUS (AE_OK);
+	return_VOID;
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_store_object_to_local
+ * FUNCTION:    acpi_ds_store_object_to_local
  *
  * PARAMETERS:  Opcode              - Either AML_LOCAL_OP or AML_ARG_OP
- *              Index               - Which local_var or argument to set
- *              Src_desc            - Value to be stored
- *              Walk_state          - Current walk state
+ *              Index               - which local_var or argument to set
+ *              obj_desc            - Value to be stored
+ *              walk_state          - Current walk state
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Store a value in an Arg or Local.  The Src_desc is installed
+ * DESCRIPTION: Store a value in an Arg or Local.  The obj_desc is installed
  *              as the new value for the Arg or Local and the reference count
- *              for Src_desc is incremented.
+ *              for obj_desc is incremented.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ds_store_object_to_local (
-	u16                     opcode,
-	u32                     index,
-	acpi_operand_object     *src_desc,
-	acpi_walk_state         *walk_state)
+	u16                             opcode,
+	u32                             index,
+	union acpi_operand_object       *obj_desc,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status;
-	acpi_operand_object     **entry;
+	acpi_status                     status;
+	struct acpi_namespace_node      *node;
+	union acpi_operand_object       *current_obj_desc;
 
 
-	FUNCTION_TRACE ("Ds_method_data_set_value");
+	ACPI_FUNCTION_TRACE ("ds_store_object_to_local");
 	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Opcode=%d Idx=%d Obj=%p\n",
-		opcode, index, src_desc));
+		opcode, index, obj_desc));
 
 
 	/* Parameter validation */
 
-	if (!src_desc) {
+	if (!obj_desc) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
+	/* Get the namespace node for the arg/local */
 
-	/* Get a pointer to the requested method stack entry */
-
-	status = acpi_ds_method_data_get_entry (opcode, index, walk_state, &entry);
+	status = acpi_ds_method_data_get_node (opcode, index, walk_state, &node);
 	if (ACPI_FAILURE (status)) {
-		goto cleanup;
+		return_ACPI_STATUS (status);
 	}
 
-	if (*entry == src_desc) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Obj=%p already installed!\n", src_desc));
-		goto cleanup;
+	current_obj_desc = acpi_ns_get_attached_object (node);
+	if (current_obj_desc == obj_desc) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Obj=%p already installed!\n",
+			obj_desc));
+		return_ACPI_STATUS (status);
 	}
 
-
 	/*
 	 * If there is an object already in this slot, we either
 	 * have to delete it, or if this is an argument and there
 	 * is an object reference stored there, we have to do
 	 * an indirect store!
 	 */
-	if (*entry) {
+	if (current_obj_desc) {
 		/*
 		 * Check for an indirect store if an argument
 		 * contains an object reference (stored as an Node).
@@ -675,45 +608,46 @@ acpi_ds_store_object_to_local (
 		 * locals, since a store to a local should overwrite
 		 * anything there, including an object reference.
 		 *
-		 * If both Arg0 and Local0 contain Ref_of (Local4):
+		 * If both Arg0 and Local0 contain ref_of (Local4):
 		 *
 		 * Store (1, Arg0)             - Causes indirect store to local4
 		 * Store (1, Local0)           - Stores 1 in local0, overwriting
 		 *                                  the reference to local4
-		 * Store (1, De_refof (Local0)) - Causes indirect store to local4
+		 * Store (1, de_refof (Local0)) - Causes indirect store to local4
 		 *
 		 * Weird, but true.
 		 */
-		if ((opcode == AML_ARG_OP) &&
-			(VALID_DESCRIPTOR_TYPE (*entry, ACPI_DESC_TYPE_NAMED))) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-				"Arg (%p) is an Obj_ref(Node), storing in %p\n",
-				src_desc, *entry));
-
-			/* Detach an existing object from the Node */
-
-			acpi_ns_detach_object ((acpi_namespace_node *) *entry);
-
+		if (opcode == AML_ARG_OP) {
 			/*
-			 * Store this object into the Node
-			 * (do the indirect store)
+			 * Make sure that the object is the correct type.  This may be overkill, but
+			 * it is here because references were NS nodes in the past.  Now they are
+			 * operand objects of type Reference.
 			 */
-			status = acpi_ns_attach_object ((acpi_namespace_node *) *entry, src_desc,
-					   src_desc->common.type);
-			return_ACPI_STATUS (status);
-		}
-
+			if (ACPI_GET_DESCRIPTOR_TYPE (current_obj_desc) != ACPI_DESC_TYPE_OPERAND) {
+				ACPI_REPORT_ERROR (("Invalid descriptor type while storing to method arg: %X\n",
+					current_obj_desc->common.type));
+				return_ACPI_STATUS (AE_AML_INTERNAL);
+			}
 
-#ifdef ACPI_ENABLE_IMPLICIT_CONVERSION
-		/*
-		 * Perform "Implicit conversion" of the new object to the type of the
-		 * existing object
-		 */
-		status = acpi_ex_convert_to_target_type ((*entry)->common.type, &src_desc, walk_state);
-		if (ACPI_FAILURE (status)) {
-			goto cleanup;
+			/*
+			 * If we have a valid reference object that came from ref_of(), do the
+			 * indirect store
+			 */
+			if ((current_obj_desc->common.type == ACPI_TYPE_LOCAL_REFERENCE) &&
+				(current_obj_desc->reference.opcode == AML_REF_OF_OP)) {
+				ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+					"Arg (%p) is an obj_ref(Node), storing in node %p\n",
+					obj_desc, current_obj_desc));
+
+				/*
+				 * Store this object to the Node
+				 * (perform the indirect store)
+				 */
+				status = acpi_ex_store_object_to_node (obj_desc,
+						 current_obj_desc->reference.object, walk_state);
+				return_ACPI_STATUS (status);
+			}
 		}
-#endif
 
 		/*
 		 * Delete the existing object
@@ -722,27 +656,14 @@ acpi_ds_store_object_to_local (
 		acpi_ds_method_data_delete_value (opcode, index, walk_state);
 	}
 
-
 	/*
-	 * Install the Obj_stack descriptor (*Src_desc) into
+	 * Install the obj_stack descriptor (*obj_desc) into
 	 * the descriptor for the Arg or Local.
 	 * Install the new object in the stack entry
 	 * (increments the object reference count by one)
 	 */
-	status = acpi_ds_method_data_set_entry (opcode, index, src_desc, walk_state);
-	if (ACPI_FAILURE (status)) {
-		goto cleanup;
-	}
-
-	/* Normal exit */
-
-	return_ACPI_STATUS (AE_OK);
-
-
-	/* Error exit */
-
-cleanup:
-
+	status = acpi_ds_method_data_set_value (opcode, index, obj_desc, walk_state);
 	return_ACPI_STATUS (status);
 }
 
+
diff -urNp linux-5400/drivers/acpi/dispatcher/dsobject.c linux-5410/drivers/acpi/dispatcher/dsobject.c
--- linux-5400/drivers/acpi/dispatcher/dsobject.c
+++ linux-5410/drivers/acpi/dispatcher/dsobject.c
@@ -1,692 +1,612 @@
 /******************************************************************************
  *
  * Module Name: dsobject - Dispatcher object management routines
- *              $Revision: 81 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
-#include "amlcode.h"
-#include "acdispat.h"
-#include "acinterp.h"
-#include "acnamesp.h"
+#include <acpi/acpi.h>
+#include <acpi/acparser.h>
+#include <acpi/amlcode.h>
+#include <acpi/acdispat.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acinterp.h>
 
 #define _COMPONENT          ACPI_DISPATCHER
-	 MODULE_NAME         ("dsobject")
+	 ACPI_MODULE_NAME    ("dsobject")
 
 
-/*******************************************************************************
+#ifndef ACPI_NO_METHOD_EXECUTION
+/*****************************************************************************
  *
- * FUNCTION:    Acpi_ds_init_one_object
+ * FUNCTION:    acpi_ds_build_internal_object
  *
- * PARAMETERS:  Obj_handle      - Node
- *              Level           - Current nesting level
- *              Context         - Points to a init info struct
- *              Return_value    - Not used
+ * PARAMETERS:  walk_state      - Current walk state
+ *              Op              - Parser object to be translated
+ *              obj_desc_ptr    - Where the ACPI internal object is returned
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Callback from Acpi_walk_namespace. Invoked for every object
- *              within the  namespace.
- *
- *              Currently, the only objects that require initialization are:
- *              1) Methods
- *              2) Op Regions
+ * DESCRIPTION: Translate a parser Op object to the equivalent namespace object
+ *              Simple objects are any objects other than a package object!
  *
- ******************************************************************************/
+ ****************************************************************************/
 
 acpi_status
-acpi_ds_init_one_object (
-	acpi_handle             obj_handle,
-	u32                     level,
-	void                    *context,
-	void                    **return_value)
+acpi_ds_build_internal_object (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op,
+	union acpi_operand_object       **obj_desc_ptr)
 {
-	acpi_object_type8       type;
-	acpi_status             status;
-	acpi_init_walk_info     *info = (acpi_init_walk_info *) context;
-	u8                      table_revision;
-
-
-	PROC_NAME ("Ds_init_one_object");
-
-
-	info->object_count++;
-	table_revision = info->table_desc->pointer->revision;
-
-	/*
-	 * We are only interested in objects owned by the table that
-	 * was just loaded
-	 */
-	if (((acpi_namespace_node *) obj_handle)->owner_id !=
-			info->table_desc->table_id) {
-		return (AE_OK);
-	}
-
-
-	/* And even then, we are only interested in a few object types */
-
-	type = acpi_ns_get_type (obj_handle);
-
-	switch (type) {
+	union acpi_operand_object       *obj_desc;
+	acpi_status                     status;
 
-	case ACPI_TYPE_REGION:
 
-		acpi_ds_initialize_region (obj_handle);
+	ACPI_FUNCTION_TRACE ("ds_build_internal_object");
 
-		info->op_region_count++;
-		break;
-
-
-	case ACPI_TYPE_METHOD:
-
-		info->method_count++;
-
-		if (!(acpi_dbg_level & ACPI_LV_INIT)) {
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK, "."));
-		}
-
-		/*
-		 * Set the execution data width (32 or 64) based upon the
-		 * revision number of the parent ACPI table.
-		 */
-		if (table_revision == 1) {
-			((acpi_namespace_node *)obj_handle)->flags |= ANOBJ_DATA_WIDTH_32;
-		}
 
+	*obj_desc_ptr = NULL;
+	if (op->common.aml_opcode == AML_INT_NAMEPATH_OP) {
 		/*
-		 * Always parse methods to detect errors, we may delete
-		 * the parse tree below
+		 * This is an named object reference.  If this name was
+		 * previously looked up in the namespace, it was stored in this op.
+		 * Otherwise, go ahead and look it up now
 		 */
-		status = acpi_ds_parse_method (obj_handle);
-		if (ACPI_FAILURE (status)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Method %p [%4.4s] - parse failure, %s\n",
-				obj_handle, (char*)&((acpi_namespace_node *)obj_handle)->name,
-				acpi_format_exception (status)));
+		if (!op->common.node) {
+			status = acpi_ns_lookup (walk_state->scope_info, op->common.value.string,
+					  ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
+					  ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE, NULL,
+					  (struct acpi_namespace_node **) &(op->common.node));
 
-			/* This parse failed, but we will continue parsing more methods */
-
-			break;
+			if (ACPI_FAILURE (status)) {
+				ACPI_REPORT_NSERROR (op->common.value.string, status);
+				return_ACPI_STATUS (status);
+			}
 		}
-
-		/*
-		 * Delete the parse tree.  We simple re-parse the method
-		 * for every execution since there isn't much overhead
-		 */
-		acpi_ns_delete_namespace_subtree (obj_handle);
-		break;
-
-	default:
-		break;
 	}
 
-	/*
-	 * We ignore errors from above, and always return OK, since
-	 * we don't want to abort the walk on a single error.
-	 */
-	return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ds_initialize_objects
- *
- * PARAMETERS:  None
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Walk the entire namespace and perform any necessary
- *              initialization on the objects found therein
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ds_initialize_objects (
-	acpi_table_desc         *table_desc,
-	acpi_namespace_node     *start_node)
-{
-	acpi_status             status;
-	acpi_init_walk_info     info;
-
-
-	FUNCTION_TRACE ("Ds_initialize_objects");
-
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-		"**** Starting initialization of namespace objects ****\n"));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK, "Parsing Methods:"));
-
-
-	info.method_count   = 0;
-	info.op_region_count = 0;
-	info.object_count   = 0;
-	info.table_desc     = table_desc;
-
+	/* Create and init the internal ACPI object */
 
-	/* Walk entire namespace from the supplied root */
+	obj_desc = acpi_ut_create_internal_object ((acpi_ps_get_opcode_info (op->common.aml_opcode))->object_type);
+	if (!obj_desc) {
+		return_ACPI_STATUS (AE_NO_MEMORY);
+	}
 
-	status = acpi_walk_namespace (ACPI_TYPE_ANY, start_node, ACPI_UINT32_MAX,
-			  acpi_ds_init_one_object, &info, NULL);
+	status = acpi_ds_init_object_from_op (walk_state, op, op->common.aml_opcode, &obj_desc);
 	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Walk_namespace failed! %x\n", status));
+		acpi_ut_remove_reference (obj_desc);
+		return_ACPI_STATUS (status);
 	}
 
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK,
-		"\n%d Control Methods found and parsed (%d nodes total)\n",
-		info.method_count, info.object_count));
-	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-		"%d Control Methods found\n", info.method_count));
-	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-		"%d Op Regions found\n", info.op_region_count));
-
+	*obj_desc_ptr = obj_desc;
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ds_init_object_from_op
+ * FUNCTION:    acpi_ds_build_internal_buffer_obj
  *
- * PARAMETERS:  Op              - Parser op used to init the internal object
- *              Opcode          - AML opcode associated with the object
- *              Obj_desc        - Namespace object to be initialized
+ * PARAMETERS:  walk_state      - Current walk state
+ *              Op              - Parser object to be translated
+ *              buffer_length   - Length of the buffer
+ *              obj_desc_ptr    - Where the ACPI internal object is returned
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Initialize a namespace object from a parser Op and its
- *              associated arguments.  The namespace object is a more compact
- *              representation of the Op and its arguments.
+ * DESCRIPTION: Translate a parser Op package object to the equivalent
+ *              namespace object
  *
  ****************************************************************************/
 
 acpi_status
-acpi_ds_init_object_from_op (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op,
-	u16                     opcode,
-	acpi_operand_object     **ret_obj_desc)
+acpi_ds_build_internal_buffer_obj (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op,
+	u32                             buffer_length,
+	union acpi_operand_object       **obj_desc_ptr)
 {
-	acpi_status             status;
-	acpi_parse_object       *arg;
-	acpi_parse2_object      *byte_list;
-	acpi_operand_object     *arg_desc;
-	const acpi_opcode_info  *op_info;
-	acpi_operand_object     *obj_desc;
-
+	union acpi_parse_object         *arg;
+	union acpi_operand_object       *obj_desc;
+	union acpi_parse_object         *byte_list;
+	u32                             byte_list_length = 0;
 
-	PROC_NAME ("Ds_init_object_from_op");
 
+	ACPI_FUNCTION_TRACE ("ds_build_internal_buffer_obj");
 
-	obj_desc = *ret_obj_desc;
-	op_info = acpi_ps_get_opcode_info (opcode);
-	if (op_info->class == AML_CLASS_UNKNOWN) {
-		/* Unknown opcode */
 
-		return (AE_TYPE);
+	obj_desc = *obj_desc_ptr;
+	if (obj_desc) {
+		/*
+		 * We are evaluating a Named buffer object "Name (xxxx, Buffer)".
+		 * The buffer object already exists (from the NS node)
+		 */
 	}
+	else {
+		/* Create a new buffer object */
 
-
-	/* Get and prepare the first argument */
-
-	switch (obj_desc->common.type) {
-	case ACPI_TYPE_BUFFER:
-
-		/* First arg is a number */
-
-		acpi_ds_create_operand (walk_state, op->value.arg, 0);
-		arg_desc = walk_state->operands [walk_state->num_operands - 1];
-		acpi_ds_obj_stack_pop (1, walk_state);
-
-		/* Resolve the object (could be an arg or local) */
-
-		status = acpi_ex_resolve_to_value (&arg_desc, walk_state);
-		if (ACPI_FAILURE (status)) {
-			acpi_ut_remove_reference (arg_desc);
-			return (status);
+		obj_desc = acpi_ut_create_internal_object (ACPI_TYPE_BUFFER);
+		*obj_desc_ptr = obj_desc;
+		if (!obj_desc) {
+			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
+	}
 
-		/* We are expecting a number */
+	/*
+	 * Second arg is the buffer data (optional) byte_list can be either
+	 * individual bytes or a string initializer.  In either case, a
+	 * byte_list appears in the AML.
+	 */
+	arg = op->common.value.arg;         /* skip first arg */
 
-		if (arg_desc->common.type != ACPI_TYPE_INTEGER) {
+	byte_list = arg->named.next;
+	if (byte_list) {
+		if (byte_list->common.aml_opcode != AML_INT_BYTELIST_OP) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Expecting number, got obj: %p type %X\n",
-				arg_desc, arg_desc->common.type));
-			acpi_ut_remove_reference (arg_desc);
+				"Expecting bytelist, got AML opcode %X in op %p\n",
+				byte_list->common.aml_opcode, byte_list));
+
+			acpi_ut_remove_reference (obj_desc);
 			return (AE_TYPE);
 		}
 
-		/* Get the value, delete the internal object */
+		byte_list_length = (u32) byte_list->common.value.integer;
+	}
 
-		obj_desc->buffer.length = (u32) arg_desc->integer.value;
-		acpi_ut_remove_reference (arg_desc);
+	/*
+	 * The buffer length (number of bytes) will be the larger of:
+	 * 1) The specified buffer length and
+	 * 2) The length of the initializer byte list
+	 */
+	obj_desc->buffer.length = buffer_length;
+	if (byte_list_length > buffer_length) {
+		obj_desc->buffer.length = byte_list_length;
+	}
 
-		/* Allocate the buffer */
+	/* Allocate the buffer */
 
-		if (obj_desc->buffer.length == 0) {
-			obj_desc->buffer.pointer = NULL;
-			REPORT_WARNING (("Buffer created with zero length in AML\n"));
-			break;
+	if (obj_desc->buffer.length == 0) {
+		obj_desc->buffer.pointer = NULL;
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+			"Buffer defined with zero length in AML, creating\n"));
+	}
+	else {
+		obj_desc->buffer.pointer = ACPI_MEM_CALLOCATE (
+				   obj_desc->buffer.length);
+		if (!obj_desc->buffer.pointer) {
+			acpi_ut_delete_object_desc (obj_desc);
+			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
 
-		else {
-			obj_desc->buffer.pointer = ACPI_MEM_CALLOCATE (
-					   obj_desc->buffer.length);
+		/* Initialize buffer from the byte_list (if present) */
 
-			if (!obj_desc->buffer.pointer) {
-				return (AE_NO_MEMORY);
-			}
+		if (byte_list) {
+			ACPI_MEMCPY (obj_desc->buffer.pointer, byte_list->named.data,
+					  byte_list_length);
 		}
+	}
 
-		/*
-		 * Second arg is the buffer data (optional) Byte_list can be either
-		 * individual bytes or a string initializer.
-		 */
-		arg = op->value.arg;         /* skip first arg */
-
-		byte_list = (acpi_parse2_object *) arg->next;
-		if (byte_list) {
-			if (byte_list->opcode != AML_INT_BYTELIST_OP) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Expecting bytelist, got: %p\n",
-					byte_list));
-				return (AE_TYPE);
-			}
+	obj_desc->buffer.flags |= AOPOBJ_DATA_VALID;
+	op->common.node = (struct acpi_namespace_node *) obj_desc;
+	return_ACPI_STATUS (AE_OK);
+}
 
-			MEMCPY (obj_desc->buffer.pointer, byte_list->data,
-					obj_desc->buffer.length);
-		}
 
-		break;
+/*****************************************************************************
+ *
+ * FUNCTION:    acpi_ds_build_internal_package_obj
+ *
+ * PARAMETERS:  walk_state      - Current walk state
+ *              Op              - Parser object to be translated
+ *              package_length  - Number of elements in the package
+ *              obj_desc_ptr    - Where the ACPI internal object is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Translate a parser Op package object to the equivalent
+ *              namespace object
+ *
+ ****************************************************************************/
 
+acpi_status
+acpi_ds_build_internal_package_obj (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op,
+	u32                             package_length,
+	union acpi_operand_object       **obj_desc_ptr)
+{
+	union acpi_parse_object         *arg;
+	union acpi_parse_object         *parent;
+	union acpi_operand_object       *obj_desc = NULL;
+	u32                             package_list_length;
+	acpi_status                     status = AE_OK;
+	u32                             i;
 
-	case ACPI_TYPE_PACKAGE:
 
-		/*
-		 * When called, an internal package object has already been built and
-		 * is pointed to by Obj_desc. Acpi_ds_build_internal_object builds another
-		 * internal package object, so remove reference to the original so
-		 * that it is deleted.  Error checking is done within the remove
-		 * reference function.
-		 */
-		acpi_ut_remove_reference (obj_desc);
-		status = acpi_ds_build_internal_object (walk_state, op, ret_obj_desc);
-		break;
+	ACPI_FUNCTION_TRACE ("ds_build_internal_package_obj");
 
-	case ACPI_TYPE_INTEGER:
-		obj_desc->integer.value = op->value.integer;
-		break;
 
+	/* Find the parent of a possibly nested package */
 
-	case ACPI_TYPE_STRING:
-		obj_desc->string.pointer = op->value.string;
-		obj_desc->string.length = STRLEN (op->value.string);
+	parent = op->common.parent;
+	while ((parent->common.aml_opcode == AML_PACKAGE_OP)    ||
+		   (parent->common.aml_opcode == AML_VAR_PACKAGE_OP)) {
+		parent = parent->common.parent;
+	}
 
+	obj_desc = *obj_desc_ptr;
+	if (obj_desc) {
 		/*
-		 * The string is contained in the ACPI table, don't ever try
-		 * to delete it
+		 * We are evaluating a Named package object "Name (xxxx, Package)".
+		 * Get the existing package object from the NS node
 		 */
-		obj_desc->common.flags |= AOPOBJ_STATIC_POINTER;
-		break;
-
-
-	case ACPI_TYPE_METHOD:
-		break;
-
-
-	case INTERNAL_TYPE_REFERENCE:
-
-		switch (op_info->type) {
-		case AML_TYPE_LOCAL_VARIABLE:
-
-			/* Split the opcode into a base opcode + offset */
-
-			obj_desc->reference.opcode = AML_LOCAL_OP;
-			obj_desc->reference.offset = opcode - AML_LOCAL_OP;
-			break;
+	}
+	else {
+		obj_desc = acpi_ut_create_internal_object (ACPI_TYPE_PACKAGE);
+		*obj_desc_ptr = obj_desc;
+		if (!obj_desc) {
+			return_ACPI_STATUS (AE_NO_MEMORY);
+		}
 
+		obj_desc->package.node = parent->common.node;
+	}
 
-		case AML_TYPE_METHOD_ARGUMENT:
+	obj_desc->package.count = package_length;
 
-			/* Split the opcode into a base opcode + offset */
+	/* Count the number of items in the package list */
 
-			obj_desc->reference.opcode = AML_ARG_OP;
-			obj_desc->reference.offset = opcode - AML_ARG_OP;
-			break;
+	package_list_length = 0;
+	arg = op->common.value.arg;
+	arg = arg->common.next;
+	while (arg) {
+		package_list_length++;
+		arg = arg->common.next;
+	}
 
+	/*
+	 * The package length (number of elements) will be the greater
+	 * of the specified length and the length of the initializer list
+	 */
+	if (package_list_length > package_length) {
+		obj_desc->package.count = package_list_length;
+	}
 
-		default: /* Constants, Literals, etc.. */
+	/*
+	 * Allocate the pointer array (array of pointers to the
+	 * individual objects). Add an extra pointer slot so
+	 * that the list is always null terminated.
+	 */
+	obj_desc->package.elements = ACPI_MEM_CALLOCATE (
+			 ((acpi_size) obj_desc->package.count + 1) * sizeof (void *));
 
-			if (op->opcode == AML_INT_NAMEPATH_OP) {
-				/* Node was saved in Op */
+	if (!obj_desc->package.elements) {
+		acpi_ut_delete_object_desc (obj_desc);
+		return_ACPI_STATUS (AE_NO_MEMORY);
+	}
 
-				obj_desc->reference.node = op->node;
-			}
+	/*
+	 * Now init the elements of the package
+	 */
+	i = 0;
+	arg = op->common.value.arg;
+	arg = arg->common.next;
+	while (arg) {
+		if (arg->common.aml_opcode == AML_INT_RETURN_VALUE_OP) {
+			/* Object (package or buffer) is already built */
 
-			obj_desc->reference.opcode = opcode;
-			break;
+			obj_desc->package.elements[i] = ACPI_CAST_PTR (union acpi_operand_object, arg->common.node);
+		}
+		else {
+			status = acpi_ds_build_internal_object (walk_state, arg,
+					  &obj_desc->package.elements[i]);
 		}
 
-		break;
-
-
-	default:
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unimplemented data type: %x\n",
-			obj_desc->common.type));
-
-		break;
+		i++;
+		arg = arg->common.next;
 	}
 
-	return (AE_OK);
+	obj_desc->package.flags |= AOPOBJ_DATA_VALID;
+	op->common.node = (struct acpi_namespace_node *) obj_desc;
+	return_ACPI_STATUS (status);
 }
 
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ds_build_internal_simple_obj
+ * FUNCTION:    acpi_ds_create_node
  *
- * PARAMETERS:  Op              - Parser object to be translated
- *              Obj_desc_ptr    - Where the ACPI internal object is returned
+ * PARAMETERS:  walk_state      - Current walk state
+ *              Node            - NS Node to be initialized
+ *              Op              - Parser object to be translated
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Translate a parser Op object to the equivalent namespace object
- *              Simple objects are any objects other than a package object!
+ * DESCRIPTION: Create the object to be associated with a namespace node
  *
  ****************************************************************************/
 
-static acpi_status
-acpi_ds_build_internal_simple_obj (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op,
-	acpi_operand_object     **obj_desc_ptr)
+acpi_status
+acpi_ds_create_node (
+	struct acpi_walk_state          *walk_state,
+	struct acpi_namespace_node      *node,
+	union acpi_parse_object         *op)
 {
-	acpi_operand_object     *obj_desc;
-	acpi_object_type8       type;
-	acpi_status             status;
-	u32                     length;
-	char                    *name;
+	acpi_status                     status;
+	union acpi_operand_object       *obj_desc;
 
 
-	FUNCTION_TRACE ("Ds_build_internal_simple_obj");
-
-
-	if (op->opcode == AML_INT_NAMEPATH_OP) {
-		/*
-		 * This is an object reference.  If The name was
-		 * previously looked up in the NS, it is stored in this op.
-		 * Otherwise, go ahead and look it up now
-		 */
-		if (!op->node) {
-			status = acpi_ns_lookup (walk_state->scope_info,
-					  op->value.string, ACPI_TYPE_ANY,
-					  IMODE_EXECUTE,
-					  NS_SEARCH_PARENT | NS_DONT_OPEN_SCOPE,
-					  NULL,
-					  (acpi_namespace_node **)&(op->node));
+	ACPI_FUNCTION_TRACE_PTR ("ds_create_node", op);
 
-			if (ACPI_FAILURE (status)) {
-				if (status == AE_NOT_FOUND) {
-					name = NULL;
-					acpi_ns_externalize_name (ACPI_UINT32_MAX, op->value.string, &length, &name);
-
-					if (name) {
-						REPORT_WARNING (("Reference %s at AML %X not found\n",
-								 name, op->aml_offset));
-						ACPI_MEM_FREE (name);
-					}
-
-					else {
-						REPORT_WARNING (("Reference %s at AML %X not found\n",
-								   op->value.string, op->aml_offset));
-					}
-
-					*obj_desc_ptr = NULL;
-				}
-
-				else {
-					return_ACPI_STATUS (status);
-				}
-			}
-		}
 
-		/*
-		 * The reference will be a Reference
-		 * TBD: [Restructure] unless we really need a separate
-		 *  type of INTERNAL_TYPE_REFERENCE change
-		 *  Acpi_ds_map_opcode_to_data_type to handle this case
-		 */
-		type = INTERNAL_TYPE_REFERENCE;
-	}
-	else {
-		type = acpi_ds_map_opcode_to_data_type (op->opcode, NULL);
+	/*
+	 * Because of the execution pass through the non-control-method
+	 * parts of the table, we can arrive here twice.  Only init
+	 * the named object node the first time through
+	 */
+	if (acpi_ns_get_attached_object (node)) {
+		return_ACPI_STATUS (AE_OK);
 	}
 
+	if (!op->common.value.arg) {
+		/* No arguments, there is nothing to do */
 
-	/* Create and init the internal ACPI object */
-
-	obj_desc = acpi_ut_create_internal_object (type);
-	if (!obj_desc) {
-		return_ACPI_STATUS (AE_NO_MEMORY);
+		return_ACPI_STATUS (AE_OK);
 	}
 
-	status = acpi_ds_init_object_from_op (walk_state, op, op->opcode, &obj_desc);
+	/* Build an internal object for the argument(s) */
+
+	status = acpi_ds_build_internal_object (walk_state, op->common.value.arg, &obj_desc);
 	if (ACPI_FAILURE (status)) {
-		acpi_ut_remove_reference (obj_desc);
 		return_ACPI_STATUS (status);
 	}
 
-	*obj_desc_ptr = obj_desc;
+	/* Re-type the object according to its argument */
 
-	return_ACPI_STATUS (AE_OK);
+	node->type = ACPI_GET_OBJECT_TYPE (obj_desc);
+
+	/* Attach obj to node */
+
+	status = acpi_ns_attach_object (node, obj_desc, node->type);
+
+	/* Remove local reference to the object */
+
+	acpi_ut_remove_reference (obj_desc);
+	return_ACPI_STATUS (status);
 }
 
+#endif /* ACPI_NO_METHOD_EXECUTION */
+
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ds_build_internal_package_obj
+ * FUNCTION:    acpi_ds_init_object_from_op
  *
- * PARAMETERS:  Op              - Parser object to be translated
- *              Obj_desc_ptr    - Where the ACPI internal object is returned
+ * PARAMETERS:  walk_state      - Current walk state
+ *              Op              - Parser op used to init the internal object
+ *              Opcode          - AML opcode associated with the object
+ *              ret_obj_desc    - Namespace object to be initialized
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Translate a parser Op package object to the equivalent
- *              namespace object
+ * DESCRIPTION: Initialize a namespace object from a parser Op and its
+ *              associated arguments.  The namespace object is a more compact
+ *              representation of the Op and its arguments.
  *
  ****************************************************************************/
 
 acpi_status
-acpi_ds_build_internal_package_obj (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op,
-	acpi_operand_object     **obj_desc_ptr)
+acpi_ds_init_object_from_op (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op,
+	u16                             opcode,
+	union acpi_operand_object       **ret_obj_desc)
 {
-	acpi_parse_object       *arg;
-	acpi_operand_object     *obj_desc;
-	acpi_status             status = AE_OK;
+	const struct acpi_opcode_info   *op_info;
+	union acpi_operand_object       *obj_desc;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE ("Ds_build_internal_package_obj");
+	ACPI_FUNCTION_TRACE ("ds_init_object_from_op");
 
 
-	obj_desc = acpi_ut_create_internal_object (ACPI_TYPE_PACKAGE);
-	*obj_desc_ptr = obj_desc;
-	if (!obj_desc) {
-		return_ACPI_STATUS (AE_NO_MEMORY);
+	obj_desc = *ret_obj_desc;
+	op_info = acpi_ps_get_opcode_info (opcode);
+	if (op_info->class == AML_CLASS_UNKNOWN) {
+		/* Unknown opcode */
+
+		return_ACPI_STATUS (AE_TYPE);
 	}
 
-	if (op->opcode == AML_VAR_PACKAGE_OP) {
+	/* Perform per-object initialization */
+
+	switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
+	case ACPI_TYPE_BUFFER:
+
 		/*
-		 * Variable length package parameters are evaluated JIT
+		 * Defer evaluation of Buffer term_arg operand
 		 */
-		return_ACPI_STATUS (AE_OK);
-	}
+		obj_desc->buffer.node     = (struct acpi_namespace_node *) walk_state->operands[0];
+		obj_desc->buffer.aml_start = op->named.data;
+		obj_desc->buffer.aml_length = op->named.length;
+		break;
 
-	/* The first argument must be the package length */
 
-	arg = op->value.arg;
-	obj_desc->package.count = arg->value.integer32;
+	case ACPI_TYPE_PACKAGE:
 
-	/*
-	 * Allocate the array of pointers (ptrs to the
-	 * individual objects) Add an extra pointer slot so
-	 * that the list is always null terminated.
-	 */
-	obj_desc->package.elements = ACPI_MEM_CALLOCATE (
-			 (obj_desc->package.count + 1) * sizeof (void *));
+		/*
+		 * Defer evaluation of Package term_arg operand
+		 */
+		obj_desc->package.node     = (struct acpi_namespace_node *) walk_state->operands[0];
+		obj_desc->package.aml_start = op->named.data;
+		obj_desc->package.aml_length = op->named.length;
+		break;
 
-	if (!obj_desc->package.elements) {
-		acpi_ut_delete_object_desc (obj_desc);
-		return_ACPI_STATUS (AE_NO_MEMORY);
-	}
 
-	obj_desc->package.next_element = obj_desc->package.elements;
+	case ACPI_TYPE_INTEGER:
 
-	/*
-	 * Now init the elements of the package
-	 */
-	arg = arg->next;
-	while (arg) {
-		if (arg->opcode == AML_PACKAGE_OP) {
-			status = acpi_ds_build_internal_package_obj (walk_state, arg,
-					  obj_desc->package.next_element);
-		}
+		switch (op_info->type) {
+		case AML_TYPE_CONSTANT:
+			/*
+			 * Resolve AML Constants here - AND ONLY HERE!
+			 * All constants are integers.
+			 * We mark the integer with a flag that indicates that it started life
+			 * as a constant -- so that stores to constants will perform as expected (noop).
+			 * (zero_op is used as a placeholder for optional target operands.)
+			 */
+			obj_desc->common.flags = AOPOBJ_AML_CONSTANT;
 
-		else {
-			status = acpi_ds_build_internal_simple_obj (walk_state, arg,
-					  obj_desc->package.next_element);
-		}
+			switch (opcode) {
+			case AML_ZERO_OP:
 
-		obj_desc->package.next_element++;
-		arg = arg->next;
-	}
+				obj_desc->integer.value = 0;
+				break;
 
-	obj_desc->package.flags |= AOPOBJ_DATA_VALID;
-	return_ACPI_STATUS (status);
-}
+			case AML_ONE_OP:
 
+				obj_desc->integer.value = 1;
+				break;
 
-/*****************************************************************************
- *
- * FUNCTION:    Acpi_ds_build_internal_object
- *
- * PARAMETERS:  Op              - Parser object to be translated
- *              Obj_desc_ptr    - Where the ACPI internal object is returned
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Translate a parser Op object to the equivalent namespace
- *              object
- *
- ****************************************************************************/
+			case AML_ONES_OP:
+
+				obj_desc->integer.value = ACPI_INTEGER_MAX;
+
+				/* Truncate value if we are executing from a 32-bit ACPI table */
+
+#ifndef ACPI_NO_METHOD_EXECUTION
+				acpi_ex_truncate_for32bit_table (obj_desc);
+#endif
+				break;
+
+			case AML_REVISION_OP:
+
+				obj_desc->integer.value = ACPI_CA_SUPPORT_LEVEL;
+				break;
+
+			default:
+
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown constant opcode %X\n", opcode));
+				status = AE_AML_OPERAND_TYPE;
+				break;
+			}
+			break;
 
-acpi_status
-acpi_ds_build_internal_object (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op,
-	acpi_operand_object     **obj_desc_ptr)
-{
-	acpi_status             status;
 
+		case AML_TYPE_LITERAL:
+
+			obj_desc->integer.value = op->common.value.integer;
+			break;
 
-	switch (op->opcode) {
-	case AML_PACKAGE_OP:
-	case AML_VAR_PACKAGE_OP:
 
-		status = acpi_ds_build_internal_package_obj (walk_state, op, obj_desc_ptr);
+		default:
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown Integer type %X\n", op_info->type));
+			status = AE_AML_OPERAND_TYPE;
+			break;
+		}
 		break;
 
 
-	default:
+	case ACPI_TYPE_STRING:
 
-		status = acpi_ds_build_internal_simple_obj (walk_state, op, obj_desc_ptr);
+		obj_desc->string.pointer = op->common.value.string;
+		obj_desc->string.length = (u32) ACPI_STRLEN (op->common.value.string);
+
+		/*
+		 * The string is contained in the ACPI table, don't ever try
+		 * to delete it
+		 */
+		obj_desc->common.flags |= AOPOBJ_STATIC_POINTER;
 		break;
-	}
 
-	return (status);
-}
 
+	case ACPI_TYPE_METHOD:
+		break;
 
-/*****************************************************************************
- *
- * FUNCTION:    Acpi_ds_create_node
- *
- * PARAMETERS:  Op              - Parser object to be translated
- *              Obj_desc_ptr    - Where the ACPI internal object is returned
- *
- * RETURN:      Status
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
 
-acpi_status
-acpi_ds_create_node (
-	acpi_walk_state         *walk_state,
-	acpi_namespace_node     *node,
-	acpi_parse_object       *op)
-{
-	acpi_status             status;
-	acpi_operand_object     *obj_desc;
+	case ACPI_TYPE_LOCAL_REFERENCE:
 
+		switch (op_info->type) {
+		case AML_TYPE_LOCAL_VARIABLE:
 
-	FUNCTION_TRACE_PTR ("Ds_create_node", op);
+			/* Split the opcode into a base opcode + offset */
 
+			obj_desc->reference.opcode = AML_LOCAL_OP;
+			obj_desc->reference.offset = opcode - AML_LOCAL_OP;
 
-	/*
-	 * Because of the execution pass through the non-control-method
-	 * parts of the table, we can arrive here twice.  Only init
-	 * the named object node the first time through
-	 */
-	if (node->object) {
-		return_ACPI_STATUS (AE_OK);
-	}
+#ifndef ACPI_NO_METHOD_EXECUTION
+			status = acpi_ds_method_data_get_node (AML_LOCAL_OP, obj_desc->reference.offset,
+					 walk_state, (struct acpi_namespace_node **) &obj_desc->reference.object);
+#endif
+			break;
 
-	if (!op->value.arg) {
-		/* No arguments, there is nothing to do */
 
-		return_ACPI_STATUS (AE_OK);
-	}
+		case AML_TYPE_METHOD_ARGUMENT:
 
-	/* Build an internal object for the argument(s) */
+			/* Split the opcode into a base opcode + offset */
 
-	status = acpi_ds_build_internal_object (walk_state, op->value.arg, &obj_desc);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
+			obj_desc->reference.opcode = AML_ARG_OP;
+			obj_desc->reference.offset = opcode - AML_ARG_OP;
+			break;
 
-	/* Re-type the object according to it's argument */
+		default: /* Other literals, etc.. */
 
-	node->type = obj_desc->common.type;
+			if (op->common.aml_opcode == AML_INT_NAMEPATH_OP) {
+				/* Node was saved in Op */
 
-	/* Init obj */
+				obj_desc->reference.node = op->common.node;
+			}
 
-	status = acpi_ns_attach_object (node, obj_desc, (u8) node->type);
+			obj_desc->reference.opcode = opcode;
+			break;
+		}
+		break;
 
-	/* Remove local reference to the object */
 
-	acpi_ut_remove_reference (obj_desc);
+	default:
+
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unimplemented data type: %X\n",
+			ACPI_GET_OBJECT_TYPE (obj_desc)));
+
+		status = AE_AML_OPERAND_TYPE;
+		break;
+	}
+
 	return_ACPI_STATUS (status);
 }
 
diff -urNp linux-5400/drivers/acpi/dispatcher/dsopcode.c linux-5410/drivers/acpi/dispatcher/dsopcode.c
--- linux-5400/drivers/acpi/dispatcher/dsopcode.c
+++ linux-5410/drivers/acpi/dispatcher/dsopcode.c
@@ -2,126 +2,118 @@
  *
  * Module Name: dsopcode - Dispatcher Op Region support and handling of
  *                         "control" opcodes
- *              $Revision: 56 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
-#include "amlcode.h"
-#include "acdispat.h"
-#include "acinterp.h"
-#include "acnamesp.h"
-#include "acevents.h"
-#include "actables.h"
+#include <acpi/acpi.h>
+#include <acpi/acparser.h>
+#include <acpi/amlcode.h>
+#include <acpi/acdispat.h>
+#include <acpi/acinterp.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acevents.h>
 
 #define _COMPONENT          ACPI_DISPATCHER
-	 MODULE_NAME         ("dsopcode")
+	 ACPI_MODULE_NAME    ("dsopcode")
 
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ds_get_buffer_field_arguments
+ * FUNCTION:    acpi_ds_execute_arguments
  *
- * PARAMETERS:  Obj_desc        - A valid Buffer_field object
+ * PARAMETERS:  Node                - Parent NS node
+ *              aml_length          - Length of executable AML
+ *              aml_start           - Pointer to the AML
  *
  * RETURN:      Status.
  *
- * DESCRIPTION: Get Buffer_field Buffer and Index. This implements the late
- *              evaluation of these field attributes.
+ * DESCRIPTION: Late execution of region or field arguments
  *
  ****************************************************************************/
 
 acpi_status
-acpi_ds_get_buffer_field_arguments (
-	acpi_operand_object     *obj_desc)
+acpi_ds_execute_arguments (
+	struct acpi_namespace_node      *node,
+	struct acpi_namespace_node      *scope_node,
+	u32                             aml_length,
+	u8                              *aml_start)
 {
-	acpi_operand_object     *extra_desc;
-	acpi_namespace_node     *node;
-	acpi_parse_object       *op;
-	acpi_parse_object       *field_op;
-	acpi_status             status;
-	acpi_table_desc         *table_desc;
-	acpi_walk_state         *walk_state;
-
+	acpi_status                     status;
+	union acpi_parse_object         *op;
+	struct acpi_walk_state          *walk_state;
+	union acpi_parse_object         *arg;
 
-	FUNCTION_TRACE_PTR ("Ds_get_buffer_field_arguments", obj_desc);
 
-
-	if (obj_desc->common.flags & AOPOBJ_DATA_VALID) {
-		return_ACPI_STATUS (AE_OK);
-	}
-
-
-	/* Get the AML pointer (method object) and Buffer_field node */
-
-	extra_desc = obj_desc->buffer_field.extra;
-	node = obj_desc->buffer_field.node;
-
-	DEBUG_EXEC(acpi_ut_display_init_pathname (node, " [Field]"));
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[%4.4s] Buffer_field JIT Init\n",
-		(char*)&node->name));
+	ACPI_FUNCTION_TRACE ("ds_execute_arguments");
 
 
 	/*
-	 * Allocate a new parser op to be the root of the parsed
-	 * Op_region tree
+	 * Allocate a new parser op to be the root of the parsed tree
 	 */
-	op = acpi_ps_alloc_op (AML_SCOPE_OP);
+	op = acpi_ps_alloc_op (AML_INT_EVAL_SUBTREE_OP);
 	if (!op) {
-		return (AE_NO_MEMORY);
+		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
-	/* Save the Node for use in Acpi_ps_parse_aml */
-
-	op->node = acpi_ns_get_parent_object (node);
+	/* Save the Node for use in acpi_ps_parse_aml */
 
-	/* Get a handle to the parent ACPI table */
-
-	status = acpi_tb_handle_to_object (node->owner_id, &table_desc);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
+	op->common.node = scope_node;
 
 	/* Create and initialize a new parser state */
 
-	walk_state = acpi_ds_create_walk_state (TABLE_ID_DSDT,
-			   NULL, NULL, NULL);
+	walk_state = acpi_ds_create_walk_state (0, NULL, NULL, NULL);
 	if (!walk_state) {
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
-	status = acpi_ds_init_aml_walk (walk_state, op, NULL, extra_desc->extra.aml_start,
-			  extra_desc->extra.aml_length, NULL, NULL, 1);
+	status = acpi_ds_init_aml_walk (walk_state, op, NULL, aml_start,
+			  aml_length, NULL, NULL, 1);
 	if (ACPI_FAILURE (status)) {
-		/* TBD: delete walk state */
+		acpi_ds_delete_walk_state (walk_state);
 		return_ACPI_STATUS (status);
 	}
 
-	/* TBD: No Walk flags?? */
-
-	walk_state->parse_flags = 0;
+	walk_state->parse_flags = ACPI_PARSE_DEFERRED_OP;
 
-	/* Pass1: Parse the entire Buffer_field declaration */
+	/* Pass1: Parse the entire declaration */
 
 	status = acpi_ps_parse_aml (walk_state);
 	if (ACPI_FAILURE (status)) {
@@ -129,204 +121,250 @@ acpi_ds_get_buffer_field_arguments (
 		return_ACPI_STATUS (status);
 	}
 
-	/* Get and init the actual Field_unit Op created above */
-
-	field_op = op->value.arg;
-	op->node = node;
-
+	/* Get and init the Op created above */
 
-	field_op = op->value.arg;
-	field_op->node = node;
+	arg = op->common.value.arg;
+	op->common.node = node;
+	arg->common.node = node;
 	acpi_ps_delete_parse_tree (op);
 
-	/* Evaluate the address and length arguments for the Op_region */
+	/* Evaluate the address and length arguments for the Buffer Field */
 
-	op = acpi_ps_alloc_op (AML_SCOPE_OP);
+	op = acpi_ps_alloc_op (AML_INT_EVAL_SUBTREE_OP);
 	if (!op) {
-		return (AE_NO_MEMORY);
+		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
-	op->node = acpi_ns_get_parent_object (node);
+	op->common.node = scope_node;
 
 	/* Create and initialize a new parser state */
 
-	walk_state = acpi_ds_create_walk_state (TABLE_ID_DSDT,
-			   NULL, NULL, NULL);
+	walk_state = acpi_ds_create_walk_state (0, NULL, NULL, NULL);
 	if (!walk_state) {
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
-	status = acpi_ds_init_aml_walk (walk_state, op, NULL, extra_desc->extra.aml_start,
-			  extra_desc->extra.aml_length, NULL, NULL, 3);
+	status = acpi_ds_init_aml_walk (walk_state, op, NULL, aml_start,
+			  aml_length, NULL, NULL, 3);
 	if (ACPI_FAILURE (status)) {
-		/* TBD: delete walk state */
+		acpi_ds_delete_walk_state (walk_state);
 		return_ACPI_STATUS (status);
 	}
 
 	status = acpi_ps_parse_aml (walk_state);
 	acpi_ps_delete_parse_tree (op);
-
-	/*
-	 * The pseudo-method object is no longer needed since the region is
-	 * now initialized
-	 */
-	acpi_ut_remove_reference (obj_desc->buffer_field.extra);
-	obj_desc->buffer_field.extra = NULL;
-
 	return_ACPI_STATUS (status);
 }
 
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ds_get_region_arguments
+ * FUNCTION:    acpi_ds_get_buffer_field_arguments
  *
- * PARAMETERS:  Obj_desc        - A valid region object
+ * PARAMETERS:  obj_desc        - A valid buffer_field object
  *
  * RETURN:      Status.
  *
- * DESCRIPTION: Get region address and length.  This implements the late
- *              evaluation of these region attributes.
+ * DESCRIPTION: Get buffer_field Buffer and Index. This implements the late
+ *              evaluation of these field attributes.
  *
  ****************************************************************************/
 
 acpi_status
-acpi_ds_get_region_arguments (
-	acpi_operand_object     *obj_desc)
+acpi_ds_get_buffer_field_arguments (
+	union acpi_operand_object       *obj_desc)
 {
-	acpi_operand_object     *extra_desc = NULL;
-	acpi_namespace_node     *node;
-	acpi_parse_object       *op;
-	acpi_parse_object       *region_op;
-	acpi_status             status;
-	acpi_table_desc         *table_desc;
-	acpi_walk_state         *walk_state;
+	union acpi_operand_object       *extra_desc;
+	struct acpi_namespace_node      *node;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE_PTR ("Ds_get_region_arguments", obj_desc);
+	ACPI_FUNCTION_TRACE_PTR ("ds_get_buffer_field_arguments", obj_desc);
 
 
-	if (obj_desc->region.flags & AOPOBJ_DATA_VALID) {
+	if (obj_desc->common.flags & AOPOBJ_DATA_VALID) {
 		return_ACPI_STATUS (AE_OK);
 	}
 
+	/* Get the AML pointer (method object) and buffer_field node */
 
-	/* Get the AML pointer (method object) and region node */
+	extra_desc = acpi_ns_get_secondary_object (obj_desc);
+	node = obj_desc->buffer_field.node;
 
-	extra_desc = obj_desc->region.extra;
-	node = obj_desc->region.node;
+	ACPI_DEBUG_EXEC(acpi_ut_display_init_pathname (ACPI_TYPE_BUFFER_FIELD, node, NULL));
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[%4.4s] buffer_field JIT Init\n",
+		node->name.ascii));
 
-	DEBUG_EXEC(acpi_ut_display_init_pathname (node, " [Operation Region]"));
+	/* Execute the AML code for the term_arg arguments */
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[%4.4s] Op_region Init at AML %p\n",
-		(char*)&node->name, extra_desc->extra.aml_start));
+	status = acpi_ds_execute_arguments (node, acpi_ns_get_parent_node (node),
+			 extra_desc->extra.aml_length, extra_desc->extra.aml_start);
+	return_ACPI_STATUS (status);
+}
 
-	/*
-	 * Allocate a new parser op to be the root of the parsed
-	 * Op_region tree
-	 */
-	op = acpi_ps_alloc_op (AML_SCOPE_OP);
-	if (!op) {
-		return (AE_NO_MEMORY);
-	}
 
-	/* Save the Node for use in Acpi_ps_parse_aml */
+/*****************************************************************************
+ *
+ * FUNCTION:    acpi_ds_get_buffer_arguments
+ *
+ * PARAMETERS:  obj_desc        - A valid Bufferobject
+ *
+ * RETURN:      Status.
+ *
+ * DESCRIPTION: Get Buffer length and initializer byte list.  This implements
+ *              the late evaluation of these attributes.
+ *
+ ****************************************************************************/
 
-	op->node = acpi_ns_get_parent_object (node);
+acpi_status
+acpi_ds_get_buffer_arguments (
+	union acpi_operand_object       *obj_desc)
+{
+	struct acpi_namespace_node      *node;
+	acpi_status                     status;
 
-	/* Get a handle to the parent ACPI table */
 
-	status = acpi_tb_handle_to_object (node->owner_id, &table_desc);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
+	ACPI_FUNCTION_TRACE_PTR ("ds_get_buffer_arguments", obj_desc);
 
-	/* Create and initialize a new parser state */
 
-	walk_state = acpi_ds_create_walk_state (TABLE_ID_DSDT,
-			   op, NULL, NULL);
-	if (!walk_state) {
-		return_ACPI_STATUS (AE_NO_MEMORY);
+	if (obj_desc->common.flags & AOPOBJ_DATA_VALID) {
+		return_ACPI_STATUS (AE_OK);
 	}
 
-	status = acpi_ds_init_aml_walk (walk_state, op, NULL, extra_desc->extra.aml_start,
-			  extra_desc->extra.aml_length, NULL, NULL, 1);
-	if (ACPI_FAILURE (status)) {
-		/* TBD: delete walk state */
-		return_ACPI_STATUS (status);
+	/* Get the Buffer node */
+
+	node = obj_desc->buffer.node;
+	if (!node) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"No pointer back to NS node in buffer %p\n", obj_desc));
+		return_ACPI_STATUS (AE_AML_INTERNAL);
 	}
 
-	/* TBD: No Walk flags?? */
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Buffer JIT Init\n"));
 
-	walk_state->parse_flags = 0;
+	/* Execute the AML code for the term_arg arguments */
 
-	/* Parse the entire Op_region declaration, creating a parse tree */
+	status = acpi_ds_execute_arguments (node, node,
+			 obj_desc->buffer.aml_length, obj_desc->buffer.aml_start);
+	return_ACPI_STATUS (status);
+}
 
-	status = acpi_ps_parse_aml (walk_state);
-	if (ACPI_FAILURE (status)) {
-		acpi_ps_delete_parse_tree (op);
-		return_ACPI_STATUS (status);
-	}
 
-	/* Get and init the actual Region_op created above */
+/*****************************************************************************
+ *
+ * FUNCTION:    acpi_ds_get_package_arguments
+ *
+ * PARAMETERS:  obj_desc        - A valid Packageobject
+ *
+ * RETURN:      Status.
+ *
+ * DESCRIPTION: Get Package length and initializer byte list.  This implements
+ *              the late evaluation of these attributes.
+ *
+ ****************************************************************************/
 
-	region_op = op->value.arg;
-	op->node = node;
+acpi_status
+acpi_ds_get_package_arguments (
+	union acpi_operand_object       *obj_desc)
+{
+	struct acpi_namespace_node      *node;
+	acpi_status                     status;
 
 
-	region_op = op->value.arg;
-	region_op->node = node;
-	acpi_ps_delete_parse_tree (op);
+	ACPI_FUNCTION_TRACE_PTR ("ds_get_package_arguments", obj_desc);
 
-	/* Evaluate the address and length arguments for the Op_region */
 
-	op = acpi_ps_alloc_op (AML_SCOPE_OP);
-	if (!op) {
-		return (AE_NO_MEMORY);
+	if (obj_desc->common.flags & AOPOBJ_DATA_VALID) {
+		return_ACPI_STATUS (AE_OK);
 	}
 
-	op->node = acpi_ns_get_parent_object (node);
+	/* Get the Package node */
 
-	/* Create and initialize a new parser state */
+	node = obj_desc->package.node;
+	if (!node) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"No pointer back to NS node in package %p\n", obj_desc));
+		return_ACPI_STATUS (AE_AML_INTERNAL);
+	}
 
-	walk_state = acpi_ds_create_walk_state (TABLE_ID_DSDT,
-			   op, NULL, NULL);
-	if (!walk_state) {
-		return_ACPI_STATUS (AE_NO_MEMORY);
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Package JIT Init\n"));
+
+	/* Execute the AML code for the term_arg arguments */
+
+	status = acpi_ds_execute_arguments (node, node,
+			 obj_desc->package.aml_length, obj_desc->package.aml_start);
+	return_ACPI_STATUS (status);
+}
+
+
+/*****************************************************************************
+ *
+ * FUNCTION:    acpi_ds_get_region_arguments
+ *
+ * PARAMETERS:  obj_desc        - A valid region object
+ *
+ * RETURN:      Status.
+ *
+ * DESCRIPTION: Get region address and length.  This implements the late
+ *              evaluation of these region attributes.
+ *
+ ****************************************************************************/
+
+acpi_status
+acpi_ds_get_region_arguments (
+	union acpi_operand_object       *obj_desc)
+{
+	struct acpi_namespace_node      *node;
+	acpi_status                     status;
+	union acpi_operand_object       *extra_desc;
+
+
+	ACPI_FUNCTION_TRACE_PTR ("ds_get_region_arguments", obj_desc);
+
+
+	if (obj_desc->region.flags & AOPOBJ_DATA_VALID) {
+		return_ACPI_STATUS (AE_OK);
 	}
 
-	status = acpi_ds_init_aml_walk (walk_state, op, NULL, extra_desc->extra.aml_start,
-			  extra_desc->extra.aml_length, NULL, NULL, 3);
-	if (ACPI_FAILURE (status)) {
-		/* TBD: delete walk state */
-		return_ACPI_STATUS (status);
+	extra_desc = acpi_ns_get_secondary_object (obj_desc);
+	if (!extra_desc) {
+		return_ACPI_STATUS (AE_NOT_EXIST);
 	}
 
-	status = acpi_ps_parse_aml (walk_state);
-	acpi_ps_delete_parse_tree (op);
+	/* Get the Region node */
+
+	node = obj_desc->region.node;
 
+	ACPI_DEBUG_EXEC(acpi_ut_display_init_pathname (ACPI_TYPE_REGION, node, NULL));
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[%4.4s] op_region Init at AML %p\n",
+		node->name.ascii, extra_desc->extra.aml_start));
+
+
+	status = acpi_ds_execute_arguments (node, acpi_ns_get_parent_node (node),
+			 extra_desc->extra.aml_length, extra_desc->extra.aml_start);
 	return_ACPI_STATUS (status);
 }
 
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ds_initialize_region
+ * FUNCTION:    acpi_ds_initialize_region
  *
  * PARAMETERS:  Op              - A valid region Op object
  *
  * RETURN:      Status
  *
- * DESCRIPTION:
+ * DESCRIPTION: Front end to ev_initialize_region
  *
  ****************************************************************************/
 
 acpi_status
 acpi_ds_initialize_region (
-	acpi_handle             obj_handle)
+	acpi_handle                     obj_handle)
 {
-	acpi_operand_object     *obj_desc;
-	acpi_status             status;
+	union acpi_operand_object       *obj_desc;
+	acpi_status                     status;
 
 
 	obj_desc = acpi_ns_get_attached_object (obj_handle);
@@ -334,301 +372,276 @@ acpi_ds_initialize_region (
 	/* Namespace is NOT locked */
 
 	status = acpi_ev_initialize_region (obj_desc, FALSE);
-
 	return (status);
 }
 
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ds_eval_buffer_field_operands
+ * FUNCTION:    acpi_ds_init_buffer_field
  *
- * PARAMETERS:  Op              - A valid Buffer_field Op object
+ * PARAMETERS:  aml_opcode      - create_xxx_field
+ *              obj_desc        - buffer_field object
+ *              buffer_desc     - Host Buffer
+ *              offset_desc     - Offset into buffer
+ *              Length          - Length of field (CREATE_FIELD_OP only)
+ *              Result          - Where to store the result
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Get Buffer_field Buffer and Index
- *              Called from Acpi_ds_exec_end_op during Buffer_field parse tree walk
- *
- * ACPI SPECIFICATION REFERENCES:
- *  Each of the Buffer Field opcodes is defined as specified in in-line
- *  comments below. For each one, use the following definitions.
- *
- *  Def_bit_field   :=  Bit_field_op    Src_buf Bit_idx Destination
- *  Def_byte_field  :=  Byte_field_op   Src_buf Byte_idx Destination
- *  Def_create_field := Create_field_op Src_buf Bit_idx Num_bits Name_string
- *  Def_dWord_field :=  DWord_field_op  Src_buf Byte_idx Destination
- *  Def_word_field  :=  Word_field_op   Src_buf Byte_idx Destination
- *  Bit_index       :=  Term_arg=>Integer
- *  Byte_index      :=  Term_arg=>Integer
- *  Destination     :=  Name_string
- *  Num_bits        :=  Term_arg=>Integer
- *  Source_buf      :=  Term_arg=>Buffer
+ * DESCRIPTION: Perform actual initialization of a buffer field
  *
  ****************************************************************************/
 
 acpi_status
-acpi_ds_eval_buffer_field_operands (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op)
+acpi_ds_init_buffer_field (
+	u16                             aml_opcode,
+	union acpi_operand_object       *obj_desc,
+	union acpi_operand_object       *buffer_desc,
+	union acpi_operand_object       *offset_desc,
+	union acpi_operand_object       *length_desc,
+	union acpi_operand_object       *result_desc)
 {
-	acpi_status             status;
-	acpi_operand_object     *obj_desc;
-	acpi_namespace_node     *node;
-	acpi_parse_object       *next_op;
-	u32                     offset;
-	u32                     bit_offset;
-	u32                     bit_count;
-	u8                      field_flags;
-	acpi_operand_object     *res_desc = NULL;
-	acpi_operand_object     *cnt_desc = NULL;
-	acpi_operand_object     *off_desc = NULL;
-	acpi_operand_object     *src_desc = NULL;
-
-
-	FUNCTION_TRACE_PTR ("Ds_eval_buffer_field_operands", op);
-
-
-	/*
-	 * This is where we evaluate the address and length fields of the
-	 * Create_xxx_field declaration
-	 */
-	node =  op->node;
-
-	/* Next_op points to the op that holds the Buffer */
-
-	next_op = op->value.arg;
-
-	/* Acpi_evaluate/create the address and length operands */
-
-	status = acpi_ds_create_operands (walk_state, next_op);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
+	u32                             offset;
+	u32                             bit_offset;
+	u32                             bit_count;
+	u8                              field_flags;
+	acpi_status                     status;
 
-	obj_desc = acpi_ns_get_attached_object (node);
-	if (!obj_desc) {
-		return_ACPI_STATUS (AE_NOT_EXIST);
-	}
 
+	ACPI_FUNCTION_TRACE_PTR ("ds_init_buffer_field", obj_desc);
 
-	/* Resolve the operands */
 
-	status = acpi_ex_resolve_operands (op->opcode, WALK_OPERANDS, walk_state);
-	DUMP_OPERANDS (WALK_OPERANDS, IMODE_EXECUTE, acpi_ps_get_opcode_name (op->opcode),
-			  walk_state->num_operands, "after Acpi_ex_resolve_operands");
+	/* Host object must be a Buffer */
 
-	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "(%s) bad operand(s) (%X)\n",
-			acpi_ps_get_opcode_name (op->opcode), status));
+	if (ACPI_GET_OBJECT_TYPE (buffer_desc) != ACPI_TYPE_BUFFER) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Target of Create Field is not a Buffer object - %s\n",
+			acpi_ut_get_object_type_name (buffer_desc)));
 
+		status = AE_AML_OPERAND_TYPE;
 		goto cleanup;
 	}
 
-	/* Get the operands */
-
-	if (AML_CREATE_FIELD_OP == op->opcode) {
-		res_desc = walk_state->operands[3];
-		cnt_desc = walk_state->operands[2];
-	}
-	else {
-		res_desc = walk_state->operands[2];
-	}
-
-	off_desc = walk_state->operands[1];
-	src_desc = walk_state->operands[0];
-
-
-	offset = (u32) off_desc->integer.value;
-
 	/*
-	 * If Res_desc is a Name, it will be a direct name pointer after
-	 * Acpi_ex_resolve_operands()
+	 * The last parameter to all of these opcodes (result_desc) started
+	 * out as a name_string, and should therefore now be a NS node
+	 * after resolution in acpi_ex_resolve_operands().
 	 */
-	if (!VALID_DESCRIPTOR_TYPE (res_desc, ACPI_DESC_TYPE_NAMED)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "(%s) destination must be a Node\n",
-			acpi_ps_get_opcode_name (op->opcode)));
+	if (ACPI_GET_DESCRIPTOR_TYPE (result_desc) != ACPI_DESC_TYPE_NAMED) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "(%s) destination must be a NS Node\n",
+			acpi_ps_get_opcode_name (aml_opcode)));
 
 		status = AE_AML_OPERAND_TYPE;
 		goto cleanup;
 	}
 
+	offset = (u32) offset_desc->integer.value;
+
 	/*
 	 * Setup the Bit offsets and counts, according to the opcode
 	 */
-	switch (op->opcode) {
-
-	/* Def_create_field */
-
+	switch (aml_opcode) {
 	case AML_CREATE_FIELD_OP:
 
 		/* Offset is in bits, count is in bits */
 
-		bit_offset  = offset;
-		bit_count   = (u32) cnt_desc->integer.value;
-		field_flags = ACCESS_BYTE_ACC;
+		bit_offset = offset;
+		bit_count  = (u32) length_desc->integer.value;
+		field_flags = AML_FIELD_ACCESS_BYTE;
 		break;
 
-
-	/* Def_create_bit_field */
-
 	case AML_CREATE_BIT_FIELD_OP:
 
 		/* Offset is in bits, Field is one bit */
 
-		bit_offset  = offset;
-		bit_count   = 1;
-		field_flags = ACCESS_BYTE_ACC;
+		bit_offset = offset;
+		bit_count  = 1;
+		field_flags = AML_FIELD_ACCESS_BYTE;
 		break;
 
-
-	/* Def_create_byte_field */
-
 	case AML_CREATE_BYTE_FIELD_OP:
 
 		/* Offset is in bytes, field is one byte */
 
-		bit_offset  = 8 * offset;
-		bit_count   = 8;
-		field_flags = ACCESS_BYTE_ACC;
+		bit_offset = 8 * offset;
+		bit_count  = 8;
+		field_flags = AML_FIELD_ACCESS_BYTE;
 		break;
 
-
-	/* Def_create_word_field */
-
 	case AML_CREATE_WORD_FIELD_OP:
 
 		/* Offset is in bytes, field is one word */
 
-		bit_offset  = 8 * offset;
-		bit_count   = 16;
-		field_flags = ACCESS_WORD_ACC;
+		bit_offset = 8 * offset;
+		bit_count  = 16;
+		field_flags = AML_FIELD_ACCESS_WORD;
 		break;
 
-
-	/* Def_create_dWord_field */
-
 	case AML_CREATE_DWORD_FIELD_OP:
 
 		/* Offset is in bytes, field is one dword */
 
-		bit_offset  = 8 * offset;
-		bit_count   = 32;
-		field_flags = ACCESS_DWORD_ACC;
+		bit_offset = 8 * offset;
+		bit_count  = 32;
+		field_flags = AML_FIELD_ACCESS_DWORD;
 		break;
 
-
-	/* Def_create_qWord_field */
-
 	case AML_CREATE_QWORD_FIELD_OP:
 
 		/* Offset is in bytes, field is one qword */
 
-		bit_offset  = 8 * offset;
-		bit_count   = 64;
-		field_flags = ACCESS_QWORD_ACC;
+		bit_offset = 8 * offset;
+		bit_count  = 64;
+		field_flags = AML_FIELD_ACCESS_QWORD;
 		break;
 
-
 	default:
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Internal error - unknown field creation opcode %02x\n",
-			op->opcode));
+			"Unknown field creation opcode %02x\n",
+			aml_opcode));
 		status = AE_AML_BAD_OPCODE;
 		goto cleanup;
 	}
 
 
+	/* Entire field must fit within the current length of the buffer */
+
+	if ((bit_offset + bit_count) >
+		(8 * (u32) buffer_desc->buffer.length)) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Field size %d exceeds Buffer size %d (bits)\n",
+			 bit_offset + bit_count, 8 * (u32) buffer_desc->buffer.length));
+		status = AE_AML_BUFFER_LIMIT;
+		goto cleanup;
+	}
+
 	/*
-	 * Setup field according to the object type
+	 * Initialize areas of the field object that are common to all fields
+	 * For field_flags, use LOCK_RULE = 0 (NO_LOCK), UPDATE_RULE = 0 (UPDATE_PRESERVE)
 	 */
-	switch (src_desc->common.type) {
+	status = acpi_ex_prep_common_field_object (obj_desc, field_flags, 0,
+			  bit_offset, bit_count);
+	if (ACPI_FAILURE (status)) {
+		goto cleanup;
+	}
 
-	/* Source_buff :=  Term_arg=>Buffer */
+	obj_desc->buffer_field.buffer_obj = buffer_desc;
 
-	case ACPI_TYPE_BUFFER:
+	/* Reference count for buffer_desc inherits obj_desc count */
 
-		if ((bit_offset + bit_count) >
-			(8 * (u32) src_desc->buffer.length)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Field size %d exceeds Buffer size %d (bits)\n",
-				 bit_offset + bit_count, 8 * (u32) src_desc->buffer.length));
-			status = AE_AML_BUFFER_LIMIT;
-			goto cleanup;
-		}
+	buffer_desc->common.reference_count = (u16) (buffer_desc->common.reference_count +
+			  obj_desc->common.reference_count);
 
 
-		/*
-		 * Initialize areas of the field object that are common to all fields
-		 * For Field_flags, use LOCK_RULE = 0 (NO_LOCK), UPDATE_RULE = 0 (UPDATE_PRESERVE)
-		 */
-		status = acpi_ex_prep_common_field_object (obj_desc, field_flags,
-				  bit_offset, bit_count);
-		if (ACPI_FAILURE (status)) {
-			return_ACPI_STATUS (status);
-		}
+cleanup:
 
-		obj_desc->buffer_field.buffer_obj = src_desc;
+	/* Always delete the operands */
 
-		/* Reference count for Src_desc inherits Obj_desc count */
+	acpi_ut_remove_reference (offset_desc);
+	acpi_ut_remove_reference (buffer_desc);
 
-		src_desc->common.reference_count = (u16) (src_desc->common.reference_count +
-				  obj_desc->common.reference_count);
+	if (aml_opcode == AML_CREATE_FIELD_OP) {
+		acpi_ut_remove_reference (length_desc);
+	}
 
-		break;
+	/* On failure, delete the result descriptor */
 
+	if (ACPI_FAILURE (status)) {
+		acpi_ut_remove_reference (result_desc); /* Result descriptor */
+	}
+	else {
+		/* Now the address and length are valid for this buffer_field */
 
-	/* Improper object type */
+		obj_desc->buffer_field.flags |= AOPOBJ_DATA_VALID;
+	}
 
-	default:
+	return_ACPI_STATUS (status);
+}
 
-		if ((src_desc->common.type > (u8) INTERNAL_TYPE_REFERENCE) || !acpi_ut_valid_object_type (src_desc->common.type)) /* TBD: This line MUST be a single line until Acpi_src can handle it (block deletion) */ {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Tried to create field in invalid object type %X\n",
-				src_desc->common.type));
-		}
 
-		else {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Tried to create field in improper object type - %s\n",
-				acpi_ut_get_type_name (src_desc->common.type)));
-		}
+/*****************************************************************************
+ *
+ * FUNCTION:    acpi_ds_eval_buffer_field_operands
+ *
+ * PARAMETERS:  walk_state      - Current walk
+ *              Op              - A valid buffer_field Op object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get buffer_field Buffer and Index
+ *              Called from acpi_ds_exec_end_op during buffer_field parse tree walk
+ *
+ ****************************************************************************/
 
-		status = AE_AML_OPERAND_TYPE;
-		goto cleanup;
-	}
+acpi_status
+acpi_ds_eval_buffer_field_operands (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op)
+{
+	acpi_status                     status;
+	union acpi_operand_object       *obj_desc;
+	struct acpi_namespace_node      *node;
+	union acpi_parse_object         *next_op;
 
 
-	if (AML_CREATE_FIELD_OP == op->opcode) {
-		/* Delete object descriptor unique to Create_field */
+	ACPI_FUNCTION_TRACE_PTR ("ds_eval_buffer_field_operands", op);
 
-		acpi_ut_remove_reference (cnt_desc);
-		cnt_desc = NULL;
-	}
 
+	/*
+	 * This is where we evaluate the address and length fields of the
+	 * create_xxx_field declaration
+	 */
+	node =  op->common.node;
+
+	/* next_op points to the op that holds the Buffer */
 
-cleanup:
+	next_op = op->common.value.arg;
 
-	/* Always delete the operands */
+	/* Evaluate/create the address and length operands */
 
-	acpi_ut_remove_reference (off_desc);
-	acpi_ut_remove_reference (src_desc);
+	status = acpi_ds_create_operands (walk_state, next_op);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
-	if (AML_CREATE_FIELD_OP == op->opcode) {
-		acpi_ut_remove_reference (cnt_desc);
+	obj_desc = acpi_ns_get_attached_object (node);
+	if (!obj_desc) {
+		return_ACPI_STATUS (AE_NOT_EXIST);
 	}
 
-	/* On failure, delete the result descriptor */
+	/* Resolve the operands */
+
+	status = acpi_ex_resolve_operands (op->common.aml_opcode,
+			  ACPI_WALK_OPERANDS, walk_state);
+
+	ACPI_DUMP_OPERANDS (ACPI_WALK_OPERANDS, ACPI_IMODE_EXECUTE,
+			  acpi_ps_get_opcode_name (op->common.aml_opcode),
+			  walk_state->num_operands, "after acpi_ex_resolve_operands");
 
 	if (ACPI_FAILURE (status)) {
-		acpi_ut_remove_reference (res_desc); /* Result descriptor */
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "(%s) bad operand(s) (%X)\n",
+			acpi_ps_get_opcode_name (op->common.aml_opcode), status));
+
+		return_ACPI_STATUS (status);
 	}
 
+	/* Initialize the Buffer Field */
+
+	if (op->common.aml_opcode == AML_CREATE_FIELD_OP) {
+		/* NOTE: Slightly different operands for this opcode */
+
+		status = acpi_ds_init_buffer_field (op->common.aml_opcode, obj_desc,
+				 walk_state->operands[0], walk_state->operands[1],
+				 walk_state->operands[2], walk_state->operands[3]);
+	}
 	else {
-		/* Now the address and length are valid for this Buffer_field */
+		/* All other, create_xxx_field opcodes */
 
-		obj_desc->buffer_field.flags |= AOPOBJ_DATA_VALID;
+		status = acpi_ds_init_buffer_field (op->common.aml_opcode, obj_desc,
+				 walk_state->operands[0], walk_state->operands[1],
+						  NULL, walk_state->operands[2]);
 	}
 
 	return_ACPI_STATUS (status);
@@ -637,46 +650,47 @@ cleanup:
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ds_eval_region_operands
+ * FUNCTION:    acpi_ds_eval_region_operands
  *
- * PARAMETERS:  Op              - A valid region Op object
+ * PARAMETERS:  walk_state      - Current walk
+ *              Op              - A valid region Op object
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Get region address and length
- *              Called from Acpi_ds_exec_end_op during Op_region parse tree walk
+ *              Called from acpi_ds_exec_end_op during op_region parse tree walk
  *
  ****************************************************************************/
 
 acpi_status
 acpi_ds_eval_region_operands (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op)
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op)
 {
-	acpi_status             status;
-	acpi_operand_object     *obj_desc;
-	acpi_operand_object     *operand_desc;
-	acpi_namespace_node     *node;
-	acpi_parse_object       *next_op;
+	acpi_status                     status;
+	union acpi_operand_object       *obj_desc;
+	union acpi_operand_object       *operand_desc;
+	struct acpi_namespace_node      *node;
+	union acpi_parse_object         *next_op;
 
 
-	FUNCTION_TRACE_PTR ("Ds_eval_region_operands", op);
+	ACPI_FUNCTION_TRACE_PTR ("ds_eval_region_operands", op);
 
 
 	/*
-	 * This is where we evaluate the address and length fields of the Op_region declaration
+	 * This is where we evaluate the address and length fields of the op_region declaration
 	 */
-	node =  op->node;
+	node =  op->common.node;
 
-	/* Next_op points to the op that holds the Space_iD */
+	/* next_op points to the op that holds the space_iD */
 
-	next_op = op->value.arg;
+	next_op = op->common.value.arg;
 
-	/* Next_op points to address op */
+	/* next_op points to address op */
 
-	next_op = next_op->next;
+	next_op = next_op->common.next;
 
-	/* Acpi_evaluate/create the address and length operands */
+	/* Evaluate/create the address and length operands */
 
 	status = acpi_ds_create_operands (walk_state, next_op);
 	if (ACPI_FAILURE (status)) {
@@ -685,15 +699,14 @@ acpi_ds_eval_region_operands (
 
 	/* Resolve the length and address operands to numbers */
 
-	status = acpi_ex_resolve_operands (op->opcode, WALK_OPERANDS, walk_state);
+	status = acpi_ex_resolve_operands (op->common.aml_opcode, ACPI_WALK_OPERANDS, walk_state);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
-	DUMP_OPERANDS (WALK_OPERANDS, IMODE_EXECUTE,
-			  acpi_ps_get_opcode_name (op->opcode),
-			  1, "after Acpi_ex_resolve_operands");
-
+	ACPI_DUMP_OPERANDS (ACPI_WALK_OPERANDS, ACPI_IMODE_EXECUTE,
+			  acpi_ps_get_opcode_name (op->common.aml_opcode),
+			  1, "after acpi_ex_resolve_operands");
 
 	obj_desc = acpi_ns_get_attached_object (node);
 	if (!obj_desc) {
@@ -715,12 +728,12 @@ acpi_ds_eval_region_operands (
 	 */
 	operand_desc = walk_state->operands[walk_state->num_operands - 2];
 
-	obj_desc->region.address = (ACPI_PHYSICAL_ADDRESS) operand_desc->integer.value;
+	obj_desc->region.address = (acpi_physical_address) operand_desc->integer.value;
 	acpi_ut_remove_reference (operand_desc);
 
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Rgn_obj %p Addr %8.8X%8.8X Len %X\n",
-		obj_desc, HIDWORD(obj_desc->region.address), LODWORD(obj_desc->region.address),
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "rgn_obj %p Addr %8.8X%8.8X Len %X\n",
+		obj_desc,
+		ACPI_HIDWORD (obj_desc->region.address), ACPI_LODWORD (obj_desc->region.address),
 		obj_desc->region.length));
 
 	/* Now the address and length are valid for this opregion */
@@ -731,11 +744,106 @@ acpi_ds_eval_region_operands (
 }
 
 
+/*****************************************************************************
+ *
+ * FUNCTION:    acpi_ds_eval_data_object_operands
+ *
+ * PARAMETERS:  walk_state      - Current walk
+ *              Op              - A valid data_object Op object
+ *              obj_desc        - data_object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get the operands and complete the following data objec types:
+ *              Buffer
+ *              Package
+ *
+ ****************************************************************************/
+
+acpi_status
+acpi_ds_eval_data_object_operands (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op,
+	union acpi_operand_object       *obj_desc)
+{
+	acpi_status                     status;
+	union acpi_operand_object       *arg_desc;
+	u32                             length;
+
+
+	ACPI_FUNCTION_TRACE ("ds_eval_data_object_operands");
+
+
+	/* The first operand (for all of these data objects) is the length */
+
+	status = acpi_ds_create_operand (walk_state, op->common.value.arg, 1);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	status = acpi_ex_resolve_operands (walk_state->opcode,
+			  &(walk_state->operands [walk_state->num_operands -1]),
+			  walk_state);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/* Extract length operand */
+
+	arg_desc = walk_state->operands [walk_state->num_operands - 1];
+	length = (u32) arg_desc->integer.value;
+
+	/* Cleanup for length operand */
+
+	status = acpi_ds_obj_stack_pop (1, walk_state);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	acpi_ut_remove_reference (arg_desc);
+
+	/*
+	 * Create the actual data object
+	 */
+	switch (op->common.aml_opcode) {
+	case AML_BUFFER_OP:
+
+		status = acpi_ds_build_internal_buffer_obj (walk_state, op, length, &obj_desc);
+		break;
+
+	case AML_PACKAGE_OP:
+	case AML_VAR_PACKAGE_OP:
+
+		status = acpi_ds_build_internal_package_obj (walk_state, op, length, &obj_desc);
+		break;
+
+	default:
+		return_ACPI_STATUS (AE_AML_BAD_OPCODE);
+	}
+
+	if (ACPI_SUCCESS (status)) {
+		/*
+		 * Return the object in the walk_state, unless the parent is a package --
+		 * in this case, the return object will be stored in the parse tree
+		 * for the package.
+		 */
+		if ((!op->common.parent) ||
+			((op->common.parent->common.aml_opcode != AML_PACKAGE_OP) &&
+			 (op->common.parent->common.aml_opcode != AML_VAR_PACKAGE_OP) &&
+			 (op->common.parent->common.aml_opcode != AML_NAME_OP))) {
+			walk_state->result_obj = obj_desc;
+		}
+	}
+
+	return_ACPI_STATUS (status);
+}
+
+
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_exec_begin_control_op
+ * FUNCTION:    acpi_ds_exec_begin_control_op
  *
- * PARAMETERS:  Walk_list       - The list that owns the walk stack
+ * PARAMETERS:  walk_list       - The list that owns the walk stack
  *              Op              - The control Op
  *
  * RETURN:      Status
@@ -747,20 +855,20 @@ acpi_ds_eval_region_operands (
 
 acpi_status
 acpi_ds_exec_begin_control_op (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op)
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op)
 {
-	acpi_status             status = AE_OK;
-	acpi_generic_state      *control_state;
+	acpi_status                     status = AE_OK;
+	union acpi_generic_state        *control_state;
 
 
-	PROC_NAME ("Ds_exec_begin_control_op");
+	ACPI_FUNCTION_NAME ("ds_exec_begin_control_op");
 
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Op=%p Opcode=%2.2X State=%p\n", op,
-		op->opcode, walk_state));
+		op->common.aml_opcode, walk_state));
 
-	switch (op->opcode) {
+	switch (op->common.aml_opcode) {
 	case AML_IF_OP:
 	case AML_WHILE_OP:
 
@@ -774,19 +882,19 @@ acpi_ds_exec_begin_control_op (
 			status = AE_NO_MEMORY;
 			break;
 		}
-
-		acpi_ut_push_generic_state (&walk_state->control_state, control_state);
-
 		/*
 		 * Save a pointer to the predicate for multiple executions
 		 * of a loop
 		 */
-		walk_state->control_state->control.aml_predicate_start =
-				 walk_state->parser_state.aml - 1;
-				 /* TBD: can this be removed? */
-				 /*Acpi_ps_pkg_length_encoding_size (GET8 (Walk_state->Parser_state->Aml));*/
-		break;
+		control_state->control.aml_predicate_start = walk_state->parser_state.aml - 1;
+		control_state->control.package_end = walk_state->parser_state.pkg_end;
+		control_state->control.opcode = op->common.aml_opcode;
+
 
+		/* Push the control state on this walk's control stack */
+
+		acpi_ut_push_generic_state (&walk_state->control_state, control_state);
+		break;
 
 	case AML_ELSE_OP:
 
@@ -799,12 +907,10 @@ acpi_ds_exec_begin_control_op (
 
 		break;
 
-
 	case AML_RETURN_OP:
 
 		break;
 
-
 	default:
 		break;
 	}
@@ -815,9 +921,9 @@ acpi_ds_exec_begin_control_op (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_exec_end_control_op
+ * FUNCTION:    acpi_ds_exec_end_control_op
  *
- * PARAMETERS:  Walk_list       - The list that owns the walk stack
+ * PARAMETERS:  walk_list       - The list that owns the walk stack
  *              Op              - The control Op
  *
  * RETURN:      Status
@@ -825,22 +931,21 @@ acpi_ds_exec_begin_control_op (
  * DESCRIPTION: Handles all control ops encountered during control method
  *              execution.
  *
- *
  ******************************************************************************/
 
 acpi_status
 acpi_ds_exec_end_control_op (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op)
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op)
 {
-	acpi_status             status = AE_OK;
-	acpi_generic_state      *control_state;
+	acpi_status                     status = AE_OK;
+	union acpi_generic_state        *control_state;
 
 
-	PROC_NAME ("Ds_exec_end_control_op");
+	ACPI_FUNCTION_NAME ("ds_exec_end_control_op");
 
 
-	switch (op->opcode) {
+	switch (op->common.aml_opcode) {
 	case AML_IF_OP:
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "[IF_OP] Op=%p\n", op));
@@ -890,17 +995,17 @@ acpi_ds_exec_end_control_op (
 	case AML_RETURN_OP:
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-			"[RETURN_OP] Op=%p Arg=%p\n",op, op->value.arg));
+			"[RETURN_OP] Op=%p Arg=%p\n",op, op->common.value.arg));
 
 		/*
 		 * One optional operand -- the return value
 		 * It can be either an immediate operand or a result that
 		 * has been bubbled up the tree
 		 */
-		if (op->value.arg) {
+		if (op->common.value.arg) {
 			/* Return statement has an immediate operand */
 
-			status = acpi_ds_create_operands (walk_state, op->value.arg);
+			status = acpi_ds_create_operands (walk_state, op->common.value.arg);
 			if (ACPI_FAILURE (status)) {
 				return (status);
 			}
@@ -917,12 +1022,11 @@ acpi_ds_exec_end_control_op (
 
 			/*
 			 * Get the return value and save as the last result
-			 * value.  This is the only place where Walk_state->Return_desc
+			 * value.  This is the only place where walk_state->return_desc
 			 * is set to anything other than zero!
 			 */
 			walk_state->return_desc = walk_state->operands[0];
 		}
-
 		else if ((walk_state->results) &&
 				 (walk_state->results->results.num_results > 0)) {
 			/*
@@ -934,18 +1038,17 @@ acpi_ds_exec_end_control_op (
 			 *
 			 * Allow references created by the Index operator to return unchanged.
 			 */
-			if (VALID_DESCRIPTOR_TYPE (walk_state->results->results.obj_desc [0], ACPI_DESC_TYPE_INTERNAL) &&
-				((walk_state->results->results.obj_desc [0])->common.type == INTERNAL_TYPE_REFERENCE) &&
+			if ((ACPI_GET_DESCRIPTOR_TYPE (walk_state->results->results.obj_desc[0]) == ACPI_DESC_TYPE_OPERAND) &&
+				(ACPI_GET_OBJECT_TYPE (walk_state->results->results.obj_desc [0]) == ACPI_TYPE_LOCAL_REFERENCE) &&
 				((walk_state->results->results.obj_desc [0])->reference.opcode != AML_INDEX_OP)) {
-					status = acpi_ex_resolve_to_value (&walk_state->results->results.obj_desc [0], walk_state);
-					if (ACPI_FAILURE (status)) {
-						return (status);
-					}
+				status = acpi_ex_resolve_to_value (&walk_state->results->results.obj_desc [0], walk_state);
+				if (ACPI_FAILURE (status)) {
+					return (status);
+				}
 			}
 
 			walk_state->return_desc = walk_state->results->results.obj_desc [0];
 		}
-
 		else {
 			/* No return operand */
 
@@ -960,7 +1063,7 @@ acpi_ds_exec_end_control_op (
 
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-			"Completed RETURN_OP State=%p, Ret_val=%p\n",
+			"Completed RETURN_OP State=%p, ret_val=%p\n",
 			walk_state, walk_state->return_desc));
 
 		/* End the control method execution right now */
@@ -979,7 +1082,7 @@ acpi_ds_exec_end_control_op (
 
 		/* Call up to the OS service layer to handle this */
 
-		acpi_os_signal (ACPI_SIGNAL_BREAKPOINT, "Executed AML Breakpoint opcode");
+		status = acpi_os_signal (ACPI_SIGNAL_BREAKPOINT, "Executed AML Breakpoint opcode");
 
 		/* If and when it returns, all done. */
 
@@ -987,43 +1090,47 @@ acpi_ds_exec_end_control_op (
 
 
 	case AML_BREAK_OP:
+	case AML_CONTINUE_OP: /* ACPI 2.0 */
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-			"Break to end of current package, Op=%p\n", op));
 
-		/* TBD: update behavior for ACPI 2.0 */
+		/* Pop and delete control states until we find a while */
 
-		/*
-		 * As per the ACPI specification:
-		 *      "The break operation causes the current package
-		 *          execution to complete"
-		 *      "Break -- Stop executing the current code package
-		 *          at this point"
-		 *
-		 * Returning AE_FALSE here will cause termination of
-		 * the current package, and execution will continue one
-		 * level up, starting with the completion of the parent Op.
-		 */
-		status = AE_CTRL_FALSE;
-		break;
+		while (walk_state->control_state &&
+				(walk_state->control_state->control.opcode != AML_WHILE_OP)) {
+			control_state = acpi_ut_pop_generic_state (&walk_state->control_state);
+			acpi_ut_delete_generic_state (control_state);
+		}
 
+		/* No while found? */
 
-	case AML_CONTINUE_OP: /* ACPI 2.0 */
+		if (!walk_state->control_state) {
+			return (AE_AML_NO_WHILE);
+		}
+
+		/* Was: walk_state->aml_last_while = walk_state->control_state->Control.aml_predicate_start; */
+
+		walk_state->aml_last_while = walk_state->control_state->control.package_end;
 
-		status = AE_NOT_IMPLEMENTED;
+		/* Return status depending on opcode */
+
+		if (op->common.aml_opcode == AML_BREAK_OP) {
+			status = AE_CTRL_BREAK;
+		}
+		else {
+			status = AE_CTRL_CONTINUE;
+		}
 		break;
 
 
 	default:
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown control opcode=%X Op=%p\n",
-			op->opcode, op));
+			op->common.aml_opcode, op));
 
 		status = AE_AML_BAD_OPCODE;
 		break;
 	}
 
-
 	return (status);
 }
 
diff -urNp linux-5400/drivers/acpi/dispatcher/dsutils.c linux-5410/drivers/acpi/dispatcher/dsutils.c
--- linux-5400/drivers/acpi/dispatcher/dsutils.c
+++ linux-5410/drivers/acpi/dispatcher/dsutils.c
@@ -1,48 +1,67 @@
 /*******************************************************************************
  *
  * Module Name: dsutils - Dispatcher utilities
- *              $Revision: 80 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
-#include "amlcode.h"
-#include "acdispat.h"
-#include "acinterp.h"
-#include "acnamesp.h"
-#include "acdebug.h"
+#include <acpi/acpi.h>
+#include <acpi/acparser.h>
+#include <acpi/amlcode.h>
+#include <acpi/acdispat.h>
+#include <acpi/acinterp.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acdebug.h>
 
 #define _COMPONENT          ACPI_DISPATCHER
-	 MODULE_NAME         ("dsutils")
+	 ACPI_MODULE_NAME    ("dsutils")
 
+#ifndef ACPI_NO_METHOD_EXECUTION
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_is_result_used
+ * FUNCTION:    acpi_ds_is_result_used
  *
  * PARAMETERS:  Op
- *              Result_obj
- *              Walk_state
+ *              result_obj
+ *              walk_state
  *
  * RETURN:      Status
  *
@@ -52,13 +71,13 @@
 
 u8
 acpi_ds_is_result_used (
-	acpi_parse_object       *op,
-	acpi_walk_state         *walk_state)
+	union acpi_parse_object         *op,
+	struct acpi_walk_state          *walk_state)
 {
-	const acpi_opcode_info  *parent_info;
+	const struct acpi_opcode_info   *parent_info;
 
 
-	FUNCTION_TRACE_PTR ("Ds_is_result_used", op);
+	ACPI_FUNCTION_TRACE_PTR ("ds_is_result_used", op);
 
 
 	/* Must have both an Op and a Result Object */
@@ -68,29 +87,25 @@ acpi_ds_is_result_used (
 		return_VALUE (TRUE);
 	}
 
-
 	/*
 	 * If there is no parent, the result can't possibly be used!
 	 * (An executing method typically has no parent, since each
 	 * method is parsed separately)  However, a method that is
 	 * invoked from another method has a parent.
 	 */
-	if (!op->parent) {
+	if (!op->common.parent) {
 		return_VALUE (FALSE);
 	}
 
-
 	/*
 	 * Get info on the parent.  The root Op is AML_SCOPE
 	 */
-
-	parent_info = acpi_ps_get_opcode_info (op->parent->opcode);
+	parent_info = acpi_ps_get_opcode_info (op->common.parent->common.aml_opcode);
 	if (parent_info->class == AML_CLASS_UNKNOWN) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown parent opcode. Op=%p\n", op));
 		return_VALUE (FALSE);
 	}
 
-
 	/*
 	 * Decide what to do with the result based on the parent.  If
 	 * the parent opcode will not use the result, delete the object.
@@ -98,88 +113,100 @@ acpi_ds_is_result_used (
 	 * as an operand later.
 	 */
 	switch (parent_info->class) {
-	/*
-	 * In these cases, the parent will never use the return object
-	 */
-	case AML_CLASS_CONTROL:        /* IF, ELSE, WHILE only */
+	case AML_CLASS_CONTROL:
 
-		switch (op->parent->opcode) {
+		switch (op->common.parent->common.aml_opcode) {
 		case AML_RETURN_OP:
 
 			/* Never delete the return value associated with a return opcode */
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-				"Result used, [RETURN] opcode=%X Op=%p\n", op->opcode, op));
-			return_VALUE (TRUE);
-			break;
+			goto result_used;
 
 		case AML_IF_OP:
 		case AML_WHILE_OP:
 
 			/*
 			 * If we are executing the predicate AND this is the predicate op,
-			 * we will use the return value!
+			 * we will use the return value
 			 */
-			if ((walk_state->control_state->common.state == CONTROL_PREDICATE_EXECUTING) &&
+			if ((walk_state->control_state->common.state == ACPI_CONTROL_PREDICATE_EXECUTING) &&
 				(walk_state->control_state->control.predicate_op == op)) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-					"Result used as a predicate, [IF/WHILE] opcode=%X Op=%p\n",
-					op->opcode, op));
-				return_VALUE (TRUE);
+				goto result_used;
 			}
+			break;
 
+		default:
+			/* Ignore other control opcodes */
 			break;
 		}
 
+		/* The general control opcode returns no result */
 
-		/* Fall through to not used case below */
+		goto result_not_used;
 
 
-	case AML_CLASS_NAMED_OBJECT:   /* Scope, method, etc. */
 	case AML_CLASS_CREATE:
 
 		/*
-		 * These opcodes allow Term_arg(s) as operands and therefore
-		 * method calls.  The result is used.
+		 * These opcodes allow term_arg(s) as operands and therefore
+		 * the operands can be method calls.  The result is used.
 		 */
-		if ((op->parent->opcode == AML_REGION_OP)               ||
-			(op->parent->opcode == AML_CREATE_FIELD_OP)         ||
-			(op->parent->opcode == AML_CREATE_BIT_FIELD_OP)     ||
-			(op->parent->opcode == AML_CREATE_BYTE_FIELD_OP)    ||
-			(op->parent->opcode == AML_CREATE_WORD_FIELD_OP)    ||
-			(op->parent->opcode == AML_CREATE_DWORD_FIELD_OP)   ||
-			(op->parent->opcode == AML_CREATE_QWORD_FIELD_OP)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-				"Result used, [Region or Create_field] opcode=%X Op=%p\n",
-				op->opcode, op));
-			return_VALUE (TRUE);
+		goto result_used;
+
+
+	case AML_CLASS_NAMED_OBJECT:
+
+		if ((op->common.parent->common.aml_opcode == AML_REGION_OP)      ||
+			(op->common.parent->common.aml_opcode == AML_DATA_REGION_OP) ||
+			(op->common.parent->common.aml_opcode == AML_PACKAGE_OP)     ||
+			(op->common.parent->common.aml_opcode == AML_VAR_PACKAGE_OP) ||
+			(op->common.parent->common.aml_opcode == AML_BUFFER_OP)      ||
+			(op->common.parent->common.aml_opcode == AML_INT_EVAL_SUBTREE_OP)) {
+			/*
+			 * These opcodes allow term_arg(s) as operands and therefore
+			 * the operands can be method calls.  The result is used.
+			 */
+			goto result_used;
 		}
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-			"Result not used, Parent opcode=%X Op=%p\n", op->opcode, op));
+		goto result_not_used;
 
-		return_VALUE (FALSE);
-		break;
 
-	/*
-	 * In all other cases. the parent will actually use the return
-	 * object, so keep it.
-	 */
 	default:
-		break;
+
+		/*
+		 * In all other cases. the parent will actually use the return
+		 * object, so keep it.
+		 */
+		goto result_used;
 	}
 
+
+result_used:
+	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Result of [%s] used by Parent [%s] Op=%p\n",
+			acpi_ps_get_opcode_name (op->common.aml_opcode),
+			acpi_ps_get_opcode_name (op->common.parent->common.aml_opcode), op));
+
 	return_VALUE (TRUE);
+
+
+result_not_used:
+	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Result of [%s] not used by Parent [%s] Op=%p\n",
+			acpi_ps_get_opcode_name (op->common.aml_opcode),
+			acpi_ps_get_opcode_name (op->common.parent->common.aml_opcode), op));
+
+	return_VALUE (FALSE);
+
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_delete_result_if_not_used
+ * FUNCTION:    acpi_ds_delete_result_if_not_used
  *
  * PARAMETERS:  Op
- *              Result_obj
- *              Walk_state
+ *              result_obj
+ *              walk_state
  *
  * RETURN:      Status
  *
@@ -192,15 +219,15 @@ acpi_ds_is_result_used (
 
 void
 acpi_ds_delete_result_if_not_used (
-	acpi_parse_object       *op,
-	acpi_operand_object     *result_obj,
-	acpi_walk_state         *walk_state)
+	union acpi_parse_object         *op,
+	union acpi_operand_object       *result_obj,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_operand_object     *obj_desc;
-	acpi_status             status;
+	union acpi_operand_object       *obj_desc;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE_PTR ("Ds_delete_result_if_not_used", result_obj);
+	ACPI_FUNCTION_TRACE_PTR ("ds_delete_result_if_not_used", result_obj);
 
 
 	if (!op) {
@@ -215,7 +242,7 @@ acpi_ds_delete_result_if_not_used (
 
 	if (!acpi_ds_is_result_used (op, walk_state)) {
 		/*
-		 * Must pop the result stack (Obj_desc should be equal to Result_obj)
+		 * Must pop the result stack (obj_desc should be equal to result_obj)
 		 */
 		status = acpi_ds_result_pop (&obj_desc, walk_state);
 		if (ACPI_SUCCESS (status)) {
@@ -229,9 +256,89 @@ acpi_ds_delete_result_if_not_used (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_create_operand
+ * FUNCTION:    acpi_ds_resolve_operands
+ *
+ * PARAMETERS:  walk_state          - Current walk state with operands on stack
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Resolve all operands to their values.  Used to prepare
+ *              arguments to a control method invocation (a call from one
+ *              method to another.)
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ds_resolve_operands (
+	struct acpi_walk_state          *walk_state)
+{
+	u32                             i;
+	acpi_status                     status = AE_OK;
+
+
+	ACPI_FUNCTION_TRACE_PTR ("ds_resolve_operands", walk_state);
+
+
+	/*
+	 * Attempt to resolve each of the valid operands
+	 * Method arguments are passed by value, not by reference
+	 */
+	for (i = 0; i < walk_state->num_operands; i++) {
+		status = acpi_ex_resolve_to_value (&walk_state->operands[i], walk_state);
+		if (ACPI_FAILURE (status)) {
+			break;
+		}
+	}
+
+	return_ACPI_STATUS (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_clear_operands
+ *
+ * PARAMETERS:  walk_state          - Current walk state with operands on stack
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Clear all operands on the current walk state operand stack.
+ *
+ ******************************************************************************/
+
+void
+acpi_ds_clear_operands (
+	struct acpi_walk_state          *walk_state)
+{
+	u32                             i;
+
+
+	ACPI_FUNCTION_TRACE_PTR ("acpi_ds_clear_operands", walk_state);
+
+
+	/*
+	 * Remove a reference on each operand on the stack
+	 */
+	for (i = 0; i < walk_state->num_operands; i++) {
+		/*
+		 * Remove a reference to all operands, including both
+		 * "Arguments" and "Targets".
+		 */
+		acpi_ut_remove_reference (walk_state->operands[i]);
+		walk_state->operands[i] = NULL;
+	}
+
+	walk_state->num_operands = 0;
+	return_VOID;
+}
+#endif
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ds_create_operand
  *
- * PARAMETERS:  Walk_state
+ * PARAMETERS:  walk_state
  *              Arg
  *
  * RETURN:      Status
@@ -245,34 +352,32 @@ acpi_ds_delete_result_if_not_used (
 
 acpi_status
 acpi_ds_create_operand (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *arg,
-	u32                     arg_index)
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *arg,
+	u32                             arg_index)
 {
-	acpi_status             status = AE_OK;
-	NATIVE_CHAR             *name_string;
-	u32                     name_length;
-	acpi_object_type8       data_type;
-	acpi_operand_object     *obj_desc;
-	acpi_parse_object       *parent_op;
-	u16                     opcode;
-	u32                     flags;
-	operating_mode          interpreter_mode;
-	const acpi_opcode_info  *op_info;
+	acpi_status                     status = AE_OK;
+	char                            *name_string;
+	u32                             name_length;
+	union acpi_operand_object       *obj_desc;
+	union acpi_parse_object         *parent_op;
+	u16                             opcode;
+	acpi_interpreter_mode           interpreter_mode;
+	const struct acpi_opcode_info   *op_info;
 
 
-	FUNCTION_TRACE_PTR ("Ds_create_operand", arg);
+	ACPI_FUNCTION_TRACE_PTR ("ds_create_operand", arg);
 
 
 	/* A valid name must be looked up in the namespace */
 
-	if ((arg->opcode == AML_INT_NAMEPATH_OP) &&
-		(arg->value.string)) {
+	if ((arg->common.aml_opcode == AML_INT_NAMEPATH_OP) &&
+		(arg->common.value.string)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Getting a name: Arg=%p\n", arg));
 
 		/* Get the entire name string from the AML stream */
 
-		status = acpi_ex_get_name_string (ACPI_TYPE_ANY, arg->value.buffer,
+		status = acpi_ex_get_name_string (ACPI_TYPE_ANY, arg->common.value.buffer,
 				  &name_string, &name_length);
 
 		if (ACPI_FAILURE (status)) {
@@ -281,7 +386,7 @@ acpi_ds_create_operand (
 
 		/*
 		 * All prefixes have been handled, and the name is
-		 * in Name_string
+		 * in name_string
 		 */
 
 		/*
@@ -290,46 +395,41 @@ acpi_ds_create_operand (
 		 * IMODE_EXECUTE) in order to support the creation of
 		 * namespace objects during the execution of control methods.
 		 */
-		parent_op = arg->parent;
-		op_info = acpi_ps_get_opcode_info (parent_op->opcode);
+		parent_op = arg->common.parent;
+		op_info = acpi_ps_get_opcode_info (parent_op->common.aml_opcode);
 		if ((op_info->flags & AML_NSNODE) &&
-			(parent_op->opcode != AML_INT_METHODCALL_OP) &&
-			(parent_op->opcode != AML_REGION_OP) &&
-			(parent_op->opcode != AML_INT_NAMEPATH_OP)) {
+			(parent_op->common.aml_opcode != AML_INT_METHODCALL_OP) &&
+			(parent_op->common.aml_opcode != AML_REGION_OP) &&
+			(parent_op->common.aml_opcode != AML_INT_NAMEPATH_OP)) {
 			/* Enter name into namespace if not found */
 
-			interpreter_mode = IMODE_LOAD_PASS2;
+			interpreter_mode = ACPI_IMODE_LOAD_PASS2;
 		}
 
 		else {
 			/* Return a failure if name not found */
 
-			interpreter_mode = IMODE_EXECUTE;
+			interpreter_mode = ACPI_IMODE_EXECUTE;
 		}
 
 		status = acpi_ns_lookup (walk_state->scope_info, name_string,
 				 ACPI_TYPE_ANY, interpreter_mode,
-				 NS_SEARCH_PARENT | NS_DONT_OPEN_SCOPE,
+				 ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE,
 				 walk_state,
-				 (acpi_namespace_node **) &obj_desc);
-
-		/* Free the namestring created above */
-
-		ACPI_MEM_FREE (name_string);
-
+				 ACPI_CAST_INDIRECT_PTR (struct acpi_namespace_node, &obj_desc));
 		/*
 		 * The only case where we pass through (ignore) a NOT_FOUND
-		 * error is for the Cond_ref_of opcode.
+		 * error is for the cond_ref_of opcode.
 		 */
 		if (status == AE_NOT_FOUND) {
-			if (parent_op->opcode == AML_COND_REF_OF_OP) {
+			if (parent_op->common.aml_opcode == AML_COND_REF_OF_OP) {
 				/*
 				 * For the Conditional Reference op, it's OK if
 				 * the name is not found;  We just need a way to
 				 * indicate this to the interpreter, set the
 				 * object to the root
 				 */
-				obj_desc = (acpi_operand_object *) acpi_gbl_root_node;
+				obj_desc = ACPI_CAST_PTR (union acpi_operand_object, acpi_gbl_root_node);
 				status = AE_OK;
 			}
 
@@ -339,14 +439,17 @@ acpi_ds_create_operand (
 				 * very serious error at this point
 				 */
 				status = AE_AML_NAME_NOT_FOUND;
-
-				/* TBD: Externalize Name_string and print */
-
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-						"Object name was not found in namespace\n"));
 			}
 		}
 
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_NSERROR (name_string, status);
+		}
+
+		/* Free the namestring created above */
+
+		ACPI_MEM_FREE (name_string);
+
 		/* Check status from the lookup */
 
 		if (ACPI_FAILURE (status)) {
@@ -359,47 +462,42 @@ acpi_ds_create_operand (
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
-		DEBUGGER_EXEC (acpi_db_display_argument_object (obj_desc, walk_state));
+		ACPI_DEBUGGER_EXEC (acpi_db_display_argument_object (obj_desc, walk_state));
 	}
 
 
 	else {
 		/* Check for null name case */
 
-		if (arg->opcode == AML_INT_NAMEPATH_OP) {
+		if (arg->common.aml_opcode == AML_INT_NAMEPATH_OP) {
 			/*
 			 * If the name is null, this means that this is an
 			 * optional result parameter that was not specified
-			 * in the original ASL.  Create an Reference for a
-			 * placeholder
+			 * in the original ASL.  Create a Zero Constant for a
+			 * placeholder.  (Store to a constant is a Noop.)
 			 */
 			opcode = AML_ZERO_OP;       /* Has no arguments! */
 
 			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Null namepath: Arg=%p\n", arg));
-
-			/*
-			 * TBD: [Investigate] anything else needed for the
-			 * zero op lvalue?
-			 */
 		}
 
 		else {
-			opcode = arg->opcode;
+			opcode = arg->common.aml_opcode;
 		}
 
+		/* Get the object type of the argument */
 
-		/* Get the data type of the argument */
-
-		data_type = acpi_ds_map_opcode_to_data_type (opcode, &flags);
-		if (data_type == INTERNAL_TYPE_INVALID) {
+		op_info = acpi_ps_get_opcode_info (opcode);
+		if (op_info->object_type == ACPI_TYPE_INVALID) {
 			return_ACPI_STATUS (AE_NOT_IMPLEMENTED);
 		}
 
-		if (flags & OP_HAS_RETURN_VALUE) {
+		if (op_info->flags & AML_HAS_RETVAL) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
 				"Argument previously created, already stacked \n"));
 
-			DEBUGGER_EXEC (acpi_db_display_argument_object (walk_state->operands [walk_state->num_operands - 1], walk_state));
+			ACPI_DEBUGGER_EXEC (acpi_db_display_argument_object (
+				walk_state->operands [walk_state->num_operands - 1], walk_state));
 
 			/*
 			 * Use value that was already previously returned
@@ -415,13 +513,11 @@ acpi_ds_create_operand (
 					acpi_format_exception (status)));
 				return_ACPI_STATUS (status);
 			}
-
 		}
-
 		else {
 			/* Create an ACPI_INTERNAL_OBJECT for the argument */
 
-			obj_desc = acpi_ut_create_internal_object (data_type);
+			obj_desc = acpi_ut_create_internal_object (op_info->object_type);
 			if (!obj_desc) {
 				return_ACPI_STATUS (AE_NO_MEMORY);
 			}
@@ -434,7 +530,7 @@ acpi_ds_create_operand (
 				acpi_ut_delete_object_desc (obj_desc);
 				return_ACPI_STATUS (status);
 			}
-	   }
+		}
 
 		/* Put the operand object on the object stack */
 
@@ -443,7 +539,7 @@ acpi_ds_create_operand (
 			return_ACPI_STATUS (status);
 		}
 
-		DEBUGGER_EXEC (acpi_db_display_argument_object (obj_desc, walk_state));
+		ACPI_DEBUGGER_EXEC (acpi_db_display_argument_object (obj_desc, walk_state));
 	}
 
 	return_ACPI_STATUS (AE_OK);
@@ -452,9 +548,9 @@ acpi_ds_create_operand (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_create_operands
+ * FUNCTION:    acpi_ds_create_operands
  *
- * PARAMETERS:  First_arg           - First argument of a parser argument tree
+ * PARAMETERS:  first_arg           - First argument of a parser argument tree
  *
  * RETURN:      Status
  *
@@ -466,15 +562,15 @@ acpi_ds_create_operand (
 
 acpi_status
 acpi_ds_create_operands (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *first_arg)
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *first_arg)
 {
-	acpi_status             status = AE_OK;
-	acpi_parse_object       *arg;
-	u32                     arg_count = 0;
+	acpi_status                     status = AE_OK;
+	union acpi_parse_object         *arg;
+	u32                             arg_count = 0;
 
 
-	FUNCTION_TRACE_PTR ("Ds_create_operands", first_arg);
+	ACPI_FUNCTION_TRACE_PTR ("ds_create_operands", first_arg);
 
 
 	/* For all arguments in the list... */
@@ -491,7 +587,7 @@ acpi_ds_create_operands (
 
 		/* Move on to next argument, if any */
 
-		arg = arg->next;
+		arg = arg->common.next;
 		arg_count++;
 	}
 
@@ -504,7 +600,7 @@ cleanup:
 	 * pop everything off of the operand stack and delete those
 	 * objects
 	 */
-	acpi_ds_obj_stack_pop_and_delete (arg_count, walk_state);
+	(void) acpi_ds_obj_stack_pop_and_delete (arg_count, walk_state);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "While creating Arg %d - %s\n",
 		(arg_count + 1), acpi_format_exception (status)));
@@ -512,307 +608,3 @@ cleanup:
 }
 
 
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ds_resolve_operands
- *
- * PARAMETERS:  Walk_state          - Current walk state with operands on stack
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Resolve all operands to their values.  Used to prepare
- *              arguments to a control method invocation (a call from one
- *              method to another.)
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ds_resolve_operands (
-	acpi_walk_state         *walk_state)
-{
-	u32                     i;
-	acpi_status             status = AE_OK;
-
-
-	FUNCTION_TRACE_PTR ("Ds_resolve_operands", walk_state);
-
-
-	/*
-	 * Attempt to resolve each of the valid operands
-	 * Method arguments are passed by value, not by reference
-	 */
-
-	/*
-	 * TBD: [Investigate] Note from previous parser:
-	 *   Ref_of problem with Acpi_ex_resolve_to_value() conversion.
-	 */
-	for (i = 0; i < walk_state->num_operands; i++) {
-		status = acpi_ex_resolve_to_value (&walk_state->operands[i], walk_state);
-		if (ACPI_FAILURE (status)) {
-			break;
-		}
-	}
-
-	return_ACPI_STATUS (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ds_map_opcode_to_data_type
- *
- * PARAMETERS:  Opcode          - AML opcode to map
- *              Out_flags       - Additional info about the opcode
- *
- * RETURN:      The ACPI type associated with the opcode
- *
- * DESCRIPTION: Convert a raw AML opcode to the associated ACPI data type,
- *              if any.  If the opcode returns a value as part of the
- *              intepreter execution, a flag is returned in Out_flags.
- *
- ******************************************************************************/
-
-acpi_object_type8
-acpi_ds_map_opcode_to_data_type (
-	u16                     opcode,
-	u32                     *out_flags)
-{
-	acpi_object_type8       data_type = INTERNAL_TYPE_INVALID;
-	const acpi_opcode_info  *op_info;
-	u32                     flags = 0;
-
-
-	PROC_NAME ("Ds_map_opcode_to_data_type");
-
-
-	op_info = acpi_ps_get_opcode_info (opcode);
-	if (op_info->class == AML_CLASS_UNKNOWN) {
-		/* Unknown opcode */
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown AML opcode: %x\n", opcode));
-		return (data_type);
-	}
-
-
-/*
- * TBD: Use op class
- */
-
-	switch (op_info->type) {
-
-	case AML_TYPE_LITERAL:
-
-		switch (opcode) {
-		case AML_BYTE_OP:
-		case AML_WORD_OP:
-		case AML_DWORD_OP:
-		case AML_QWORD_OP:
-
-			data_type = ACPI_TYPE_INTEGER;
-			break;
-
-
-		case AML_STRING_OP:
-
-			data_type = ACPI_TYPE_STRING;
-			break;
-
-		case AML_INT_NAMEPATH_OP:
-			data_type = INTERNAL_TYPE_REFERENCE;
-			break;
-
-		default:
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Unknown (type LITERAL) AML opcode: %x\n", opcode));
-			break;
-		}
-		break;
-
-
-	case AML_TYPE_DATA_TERM:
-
-		switch (opcode) {
-		case AML_BUFFER_OP:
-
-			data_type = ACPI_TYPE_BUFFER;
-			break;
-
-		case AML_PACKAGE_OP:
-		case AML_VAR_PACKAGE_OP:
-
-			data_type = ACPI_TYPE_PACKAGE;
-			break;
-
-		default:
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Unknown (type DATA_TERM) AML opcode: %x\n", opcode));
-			break;
-		}
-		break;
-
-
-	case AML_TYPE_CONSTANT:
-	case AML_TYPE_METHOD_ARGUMENT:
-	case AML_TYPE_LOCAL_VARIABLE:
-
-		data_type = INTERNAL_TYPE_REFERENCE;
-		break;
-
-
-	case AML_TYPE_EXEC_1A_0T_1R:
-	case AML_TYPE_EXEC_1A_1T_1R:
-	case AML_TYPE_EXEC_2A_0T_1R:
-	case AML_TYPE_EXEC_2A_1T_1R:
-	case AML_TYPE_EXEC_2A_2T_1R:
-	case AML_TYPE_EXEC_3A_1T_1R:
-	case AML_TYPE_EXEC_6A_0T_1R:
-	case AML_TYPE_RETURN:
-
-		flags = OP_HAS_RETURN_VALUE;
-		data_type = ACPI_TYPE_ANY;
-		break;
-
-
-	case AML_TYPE_METHOD_CALL:
-
-		flags = OP_HAS_RETURN_VALUE;
-		data_type = ACPI_TYPE_METHOD;
-		break;
-
-
-	case AML_TYPE_NAMED_FIELD:
-	case AML_TYPE_NAMED_SIMPLE:
-	case AML_TYPE_NAMED_COMPLEX:
-	case AML_TYPE_NAMED_NO_OBJ:
-
-		data_type = acpi_ds_map_named_opcode_to_data_type (opcode);
-		break;
-
-
-	case AML_TYPE_EXEC_1A_0T_0R:
-	case AML_TYPE_EXEC_2A_0T_0R:
-	case AML_TYPE_EXEC_3A_0T_0R:
-	case AML_TYPE_EXEC_1A_1T_0R:
-	case AML_TYPE_CONTROL:
-
-		/* No mapping needed at this time */
-
-		break;
-
-
-	default:
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Unimplemented data type opcode: %x\n", opcode));
-		break;
-	}
-
-	/* Return flags to caller if requested */
-
-	if (out_flags) {
-		*out_flags = flags;
-	}
-
-	return (data_type);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ds_map_named_opcode_to_data_type
- *
- * PARAMETERS:  Opcode              - The Named AML opcode to map
- *
- * RETURN:      The ACPI type associated with the named opcode
- *
- * DESCRIPTION: Convert a raw Named AML opcode to the associated data type.
- *              Named opcodes are a subsystem of the AML opcodes.
- *
- ******************************************************************************/
-
-acpi_object_type8
-acpi_ds_map_named_opcode_to_data_type (
-	u16                     opcode)
-{
-	acpi_object_type8       data_type;
-
-
-	FUNCTION_ENTRY ();
-
-
-	/* Decode Opcode */
-
-	switch (opcode) {
-	case AML_SCOPE_OP:
-		data_type = INTERNAL_TYPE_SCOPE;
-		break;
-
-	case AML_DEVICE_OP:
-		data_type = ACPI_TYPE_DEVICE;
-		break;
-
-	case AML_THERMAL_ZONE_OP:
-		data_type = ACPI_TYPE_THERMAL;
-		break;
-
-	case AML_METHOD_OP:
-		data_type = ACPI_TYPE_METHOD;
-		break;
-
-	case AML_POWER_RES_OP:
-		data_type = ACPI_TYPE_POWER;
-		break;
-
-	case AML_PROCESSOR_OP:
-		data_type = ACPI_TYPE_PROCESSOR;
-		break;
-
-	case AML_FIELD_OP:                              /* Field_op */
-		data_type = INTERNAL_TYPE_FIELD_DEFN;
-		break;
-
-	case AML_INDEX_FIELD_OP:                        /* Index_field_op */
-		data_type = INTERNAL_TYPE_INDEX_FIELD_DEFN;
-		break;
-
-	case AML_BANK_FIELD_OP:                         /* Bank_field_op */
-		data_type = INTERNAL_TYPE_BANK_FIELD_DEFN;
-		break;
-
-	case AML_INT_NAMEDFIELD_OP:                     /* NO CASE IN ORIGINAL  */
-		data_type = ACPI_TYPE_ANY;
-		break;
-
-	case AML_NAME_OP:                               /* Name_op - special code in original */
-	case AML_INT_NAMEPATH_OP:
-		data_type = ACPI_TYPE_ANY;
-		break;
-
-	case AML_ALIAS_OP:
-		data_type = INTERNAL_TYPE_ALIAS;
-		break;
-
-	case AML_MUTEX_OP:
-		data_type = ACPI_TYPE_MUTEX;
-		break;
-
-	case AML_EVENT_OP:
-		data_type = ACPI_TYPE_EVENT;
-		break;
-
-	case AML_DATA_REGION_OP:
-	case AML_REGION_OP:
-		data_type = ACPI_TYPE_REGION;
-		break;
-
-
-	default:
-		data_type = ACPI_TYPE_ANY;
-		break;
-
-	}
-
-	return (data_type);
-}
-
-
diff -urNp linux-5400/drivers/acpi/dispatcher/dswexec.c linux-5410/drivers/acpi/dispatcher/dswexec.c
--- linux-5400/drivers/acpi/dispatcher/dswexec.c
+++ linux-5410/drivers/acpi/dispatcher/dswexec.c
@@ -2,45 +2,64 @@
  *
  * Module Name: dswexec - Dispatcher method execution callbacks;
  *                        dispatch to interpreter.
- *              $Revision: 79 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
-#include "amlcode.h"
-#include "acdispat.h"
-#include "acinterp.h"
-#include "acnamesp.h"
-#include "acdebug.h"
+#include <acpi/acpi.h>
+#include <acpi/acparser.h>
+#include <acpi/amlcode.h>
+#include <acpi/acdispat.h>
+#include <acpi/acinterp.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acdebug.h>
+#include <acpi/acdisasm.h>
 
 
 #define _COMPONENT          ACPI_DISPATCHER
-	 MODULE_NAME         ("dswexec")
+	 ACPI_MODULE_NAME    ("dswexec")
 
 /*
- * Dispatch tables for opcode classes
+ * Dispatch table for opcode classes
  */
-ACPI_EXECUTE_OP         acpi_gbl_op_type_dispatch [] = {
+static ACPI_EXECUTE_OP      acpi_gbl_op_type_dispatch [] = {
 			 acpi_ex_opcode_1A_0T_0R,
 			 acpi_ex_opcode_1A_0T_1R,
 			 acpi_ex_opcode_1A_1T_0R,
@@ -55,9 +74,9 @@ ACPI_EXECUTE_OP         acpi_gbl_op_type
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ds_get_predicate_value
+ * FUNCTION:    acpi_ds_get_predicate_value
  *
- * PARAMETERS:  Walk_state      - Current state of the parse tree walk
+ * PARAMETERS:  walk_state      - Current state of the parse tree walk
  *
  * RETURN:      Status
  *
@@ -67,18 +86,18 @@ ACPI_EXECUTE_OP         acpi_gbl_op_type
 
 acpi_status
 acpi_ds_get_predicate_value (
-	acpi_walk_state         *walk_state,
-	u32                     has_result_obj) {
-	acpi_status             status = AE_OK;
-	acpi_operand_object     *obj_desc;
+	struct acpi_walk_state          *walk_state,
+	union acpi_operand_object       *result_obj) {
+	acpi_status                     status = AE_OK;
+	union acpi_operand_object       *obj_desc;
 
 
-	FUNCTION_TRACE_PTR ("Ds_get_predicate_value", walk_state);
+	ACPI_FUNCTION_TRACE_PTR ("ds_get_predicate_value", walk_state);
 
 
 	walk_state->control_state->common.state = 0;
 
-	if (has_result_obj) {
+	if (result_obj) {
 		status = acpi_ds_result_pop (&obj_desc, walk_state);
 		if (ACPI_FAILURE (status)) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
@@ -88,7 +107,6 @@ acpi_ds_get_predicate_value (
 			return_ACPI_STATUS (status);
 		}
 	}
-
 	else {
 		status = acpi_ds_create_operand (walk_state, walk_state->op, 0);
 		if (ACPI_FAILURE (status)) {
@@ -104,30 +122,28 @@ acpi_ds_get_predicate_value (
 	}
 
 	if (!obj_desc) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No predicate Obj_desc=%p State=%p\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No predicate obj_desc=%p State=%p\n",
 			obj_desc, walk_state));
 
 		return_ACPI_STATUS (AE_AML_NO_OPERAND);
 	}
 
-
 	/*
 	 * Result of predicate evaluation currently must
 	 * be a number
 	 */
-	if (obj_desc->common.type != ACPI_TYPE_INTEGER) {
+	if (ACPI_GET_OBJECT_TYPE (obj_desc) != ACPI_TYPE_INTEGER) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Bad predicate (not a number) Obj_desc=%p State=%p Type=%X\n",
-			obj_desc, walk_state, obj_desc->common.type));
+			"Bad predicate (not a number) obj_desc=%p State=%p Type=%X\n",
+			obj_desc, walk_state, ACPI_GET_OBJECT_TYPE (obj_desc)));
 
 		status = AE_AML_OPERAND_TYPE;
 		goto cleanup;
 	}
 
-
 	/* Truncate the predicate to 32-bits if necessary */
 
-	acpi_ex_truncate_for32bit_table (obj_desc, walk_state);
+	acpi_ex_truncate_for32bit_table (obj_desc);
 
 	/*
 	 * Save the result of the predicate evaluation on
@@ -136,7 +152,6 @@ acpi_ds_get_predicate_value (
 	if (obj_desc->integer.value) {
 		walk_state->control_state->common.value = TRUE;
 	}
-
 	else {
 		/*
 		 * Predicate is FALSE, we will just toss the
@@ -149,12 +164,12 @@ acpi_ds_get_predicate_value (
 
 cleanup:
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Completed a predicate eval=%X Op=%pn",
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Completed a predicate eval=%X Op=%p\n",
 		walk_state->control_state->common.value, walk_state->op));
 
 	 /* Break to debugger to display result */
 
-	DEBUGGER_EXEC (acpi_db_display_result_object (obj_desc, walk_state));
+	ACPI_DEBUGGER_EXEC (acpi_db_display_result_object (obj_desc, walk_state));
 
 	/*
 	 * Delete the predicate result object (we know that
@@ -162,17 +177,17 @@ cleanup:
 	 */
 	acpi_ut_remove_reference (obj_desc);
 
-	walk_state->control_state->common.state = CONTROL_NORMAL;
+	walk_state->control_state->common.state = ACPI_CONTROL_NORMAL;
 	return_ACPI_STATUS (status);
 }
 
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ds_exec_begin_op
+ * FUNCTION:    acpi_ds_exec_begin_op
  *
- * PARAMETERS:  Walk_state      - Current state of the parse tree walk
- *              Out_op          - Return op if a new one is created
+ * PARAMETERS:  walk_state      - Current state of the parse tree walk
+ *              out_op          - Return op if a new one is created
  *
  * RETURN:      Status
  *
@@ -184,15 +199,15 @@ cleanup:
 
 acpi_status
 acpi_ds_exec_begin_op (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       **out_op)
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         **out_op)
 {
-	acpi_parse_object       *op;
-	acpi_status             status = AE_OK;
-	u32                     opcode_class;
+	union acpi_parse_object         *op;
+	acpi_status                     status = AE_OK;
+	u32                             opcode_class;
 
 
-	FUNCTION_TRACE_PTR ("Ds_exec_begin_op", walk_state);
+	ACPI_FUNCTION_TRACE_PTR ("ds_exec_begin_op", walk_state);
 
 
 	op = walk_state->op;
@@ -204,8 +219,18 @@ acpi_ds_exec_begin_op (
 
 		op = *out_op;
 		walk_state->op = op;
-		walk_state->op_info = acpi_ps_get_opcode_info (op->opcode);
-		walk_state->opcode = op->opcode;
+		walk_state->opcode = op->common.aml_opcode;
+		walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
+
+		if (acpi_ns_opens_scope (walk_state->op_info->object_type)) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "(%s) Popping scope for Op %p\n",
+				acpi_ut_get_type_name (walk_state->op_info->object_type), op));
+
+			status = acpi_ds_scope_stack_pop (walk_state);
+			if (ACPI_FAILURE (status)) {
+				return_ACPI_STATUS (status);
+			}
+		}
 	}
 
 	if (op == walk_state->origin) {
@@ -223,11 +248,11 @@ acpi_ds_exec_begin_op (
 	 */
 	if ((walk_state->control_state) &&
 		(walk_state->control_state->common.state ==
-			CONTROL_CONDITIONAL_EXECUTING)) {
+			ACPI_CONTROL_CONDITIONAL_EXECUTING)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Exec predicate Op=%p State=%p\n",
 				  op, walk_state));
 
-		walk_state->control_state->common.state = CONTROL_PREDICATE_EXECUTING;
+		walk_state->control_state->common.state = ACPI_CONTROL_PREDICATE_EXECUTING;
 
 		/* Save start of predicate */
 
@@ -239,7 +264,7 @@ acpi_ds_exec_begin_op (
 
 	/* We want to send namepaths to the load code */
 
-	if (op->opcode == AML_INT_NAMEPATH_OP) {
+	if (op->common.aml_opcode == AML_INT_NAMEPATH_OP) {
 		opcode_class = AML_CLASS_NAMED_OBJECT;
 	}
 
@@ -260,7 +285,7 @@ acpi_ds_exec_begin_op (
 
 	case AML_CLASS_NAMED_OBJECT:
 
-		if (walk_state->walk_type == WALK_METHOD) {
+		if (walk_state->walk_type == ACPI_WALK_METHOD) {
 			/*
 			 * Found a named object declaration during method
 			 * execution;  we must enter this object into the
@@ -271,19 +296,16 @@ acpi_ds_exec_begin_op (
 			status = acpi_ds_load2_begin_op (walk_state, NULL);
 		}
 
-
-		if (op->opcode == AML_REGION_OP) {
+		if (op->common.aml_opcode == AML_REGION_OP) {
 			status = acpi_ds_result_stack_push (walk_state);
 		}
-
 		break;
 
 
-	/* most operators with arguments */
-
 	case AML_CLASS_EXECUTE:
 	case AML_CLASS_CREATE:
 
+		/* most operators with arguments */
 		/* Start a new result/operand state */
 
 		status = acpi_ds_result_stack_push (walk_state);
@@ -302,9 +324,9 @@ acpi_ds_exec_begin_op (
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ds_exec_end_op
+ * FUNCTION:    acpi_ds_exec_end_op
  *
- * PARAMETERS:  Walk_state      - Current state of the parse tree walk
+ * PARAMETERS:  walk_state      - Current state of the parse tree walk
  *              Op              - Op that has been just been completed in the
  *                                walk;  Arguments have now been evaluated.
  *
@@ -318,18 +340,17 @@ acpi_ds_exec_begin_op (
 
 acpi_status
 acpi_ds_exec_end_op (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_parse_object       *op;
-	acpi_status             status = AE_OK;
-	u32                     op_type;
-	u32                     op_class;
-	acpi_parse_object       *next_op;
-	acpi_parse_object       *first_arg;
-	u32                     i;
+	union acpi_parse_object         *op;
+	acpi_status                     status = AE_OK;
+	u32                             op_type;
+	u32                             op_class;
+	union acpi_parse_object         *next_op;
+	union acpi_parse_object         *first_arg;
 
 
-	FUNCTION_TRACE_PTR ("Ds_exec_end_op", walk_state);
+	ACPI_FUNCTION_TRACE_PTR ("ds_exec_end_op", walk_state);
 
 
 	op      = walk_state->op;
@@ -337,11 +358,11 @@ acpi_ds_exec_end_op (
 	op_class = walk_state->op_info->class;
 
 	if (op_class == AML_CLASS_UNKNOWN) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown opcode %X\n", op->opcode));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown opcode %X\n", op->common.aml_opcode));
 		return_ACPI_STATUS (AE_NOT_IMPLEMENTED);
 	}
 
-	first_arg = op->value.arg;
+	first_arg = op->common.value.arg;
 
 	/* Init the walk state */
 
@@ -349,22 +370,19 @@ acpi_ds_exec_end_op (
 	walk_state->return_desc = NULL;
 	walk_state->result_obj = NULL;
 
-
 	/* Call debugger for single step support (DEBUG build only) */
 
-	DEBUGGER_EXEC (status = acpi_db_single_step (walk_state, op, op_class));
-	DEBUGGER_EXEC (if (ACPI_FAILURE (status)) {return_ACPI_STATUS (status);});
+	ACPI_DEBUGGER_EXEC (status = acpi_db_single_step (walk_state, op, op_class));
+	ACPI_DEBUGGER_EXEC (if (ACPI_FAILURE (status)) {return_ACPI_STATUS (status);});
 
-
-	switch (op_class) {
 	/* Decode the Opcode Class */
 
-	case AML_CLASS_ARGUMENT: /* constants, literals, etc.  do nothing */
+	switch (op_class) {
+	case AML_CLASS_ARGUMENT:    /* constants, literals, etc. -- do nothing */
 		break;
 
-	/* most operators with arguments */
 
-	case AML_CLASS_EXECUTE:
+	case AML_CLASS_EXECUTE:     /* most operators with arguments */
 
 		/* Build resolved operand stack */
 
@@ -385,48 +403,28 @@ acpi_ds_exec_end_op (
 		status = acpi_ex_resolve_operands (walk_state->opcode,
 				  &(walk_state->operands [walk_state->num_operands -1]),
 				  walk_state);
-		if (ACPI_FAILURE (status)) {
-			/* TBD: must pop and delete operands */
-
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "[%s]: Could not resolve operands, %s\n",
-				acpi_ps_get_opcode_name (walk_state->opcode), acpi_format_exception (status)));
+		if (ACPI_SUCCESS (status)) {
+			ACPI_DUMP_OPERANDS (ACPI_WALK_OPERANDS, ACPI_IMODE_EXECUTE,
+					  acpi_ps_get_opcode_name (walk_state->opcode),
+					  walk_state->num_operands, "after ex_resolve_operands");
 
 			/*
-			 * On error, we must delete all the operands and clear the
-			 * operand stack
+			 * Dispatch the request to the appropriate interpreter handler
+			 * routine.  There is one routine per opcode "type" based upon the
+			 * number of opcode arguments and return type.
 			 */
-			for (i = 0; i < walk_state->num_operands; i++) {
-				acpi_ut_remove_reference (walk_state->operands[i]);
-				walk_state->operands[i] = NULL;
-			}
-
-			walk_state->num_operands = 0;
-			goto cleanup;
+			status = acpi_gbl_op_type_dispatch [op_type] (walk_state);
 		}
-
-		DUMP_OPERANDS (WALK_OPERANDS, IMODE_EXECUTE, acpi_ps_get_opcode_name (walk_state->opcode),
-				  walk_state->num_operands, "after Ex_resolve_operands");
-
-		/*
-		 * Dispatch the request to the appropriate interpreter handler
-		 * routine.  There is one routine per opcode "type" based upon the
-		 * number of opcode arguments and return type.
-		 */
-		status = acpi_gbl_op_type_dispatch [op_type] (walk_state);
-
-
-		/* Delete argument objects and clear the operand stack */
-
-		for (i = 0; i < walk_state->num_operands; i++) {
-			/*
-			 * Remove a reference to all operands, including both
-			 * "Arguments" and "Targets".
-			 */
-			acpi_ut_remove_reference (walk_state->operands[i]);
-			walk_state->operands[i] = NULL;
+		else {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"[%s]: Could not resolve operands, %s\n",
+				acpi_ps_get_opcode_name (walk_state->opcode),
+				acpi_format_exception (status)));
 		}
 
-		walk_state->num_operands = 0;
+		/* Always delete the argument objects and clear the operand stack */
+
+		acpi_ds_clear_operands (walk_state);
 
 		/*
 		 * If a result object was returned from above, push it on the
@@ -445,11 +443,14 @@ acpi_ds_exec_end_op (
 		switch (op_type) {
 		case AML_TYPE_CONTROL:    /* Type 1 opcode, IF/ELSE/WHILE/NOOP */
 
-			/* 1 Operand, 0 External_result, 0 Internal_result */
+			/* 1 Operand, 0 external_result, 0 internal_result */
 
 			status = acpi_ds_exec_end_control_op (walk_state, op);
+			if (ACPI_FAILURE (status)) {
+				break;
+			}
 
-			acpi_ds_result_stack_pop (walk_state);
+			status = acpi_ds_result_stack_pop (walk_state);
 			break;
 
 
@@ -461,13 +462,13 @@ acpi_ds_exec_end_op (
 			 * (AML_METHODCALL) Op->Value->Arg->Node contains
 			 * the method Node pointer
 			 */
-			/* Next_op points to the op that holds the method name */
+			/* next_op points to the op that holds the method name */
 
 			next_op = first_arg;
 
-			/* Next_op points to first argument op */
+			/* next_op points to first argument op */
 
-			next_op = next_op->next;
+			next_op = next_op->common.next;
 
 			/*
 			 * Get the method's arguments and put them on the operand stack
@@ -478,13 +479,15 @@ acpi_ds_exec_end_op (
 			}
 
 			/*
-			 * Since the operands will be passed to another
-			 * control method, we must resolve all local
-			 * references here (Local variables, arguments
-			 * to *this* method, etc.)
+			 * Since the operands will be passed to another control method,
+			 * we must resolve all local references here (Local variables,
+			 * arguments to *this* method, etc.)
 			 */
 			status = acpi_ds_resolve_operands (walk_state);
 			if (ACPI_FAILURE (status)) {
+				/* On error, clear all resolved operands */
+
+				acpi_ds_clear_operands (walk_state);
 				break;
 			}
 
@@ -499,13 +502,12 @@ acpi_ds_exec_end_op (
 			 * especially the operand count!
 			 */
 			return_ACPI_STATUS (status);
-			break;
 
 
 		case AML_TYPE_CREATE_FIELD:
 
 			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-				"Executing Create_field Buffer/Index Op=%p\n", op));
+				"Executing create_field Buffer/Index Op=%p\n", op));
 
 			status = acpi_ds_load2_end_op (walk_state);
 			if (ACPI_FAILURE (status)) {
@@ -516,18 +518,65 @@ acpi_ds_exec_end_op (
 			break;
 
 
+		case AML_TYPE_CREATE_OBJECT:
+
+			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+				"Executing create_object (Buffer/Package) Op=%p\n", op));
+
+			switch (op->common.parent->common.aml_opcode) {
+			case AML_NAME_OP:
+
+				/*
+				 * Put the Node on the object stack (Contains the ACPI Name of
+				 * this object)
+				 */
+				walk_state->operands[0] = (void *) op->common.parent->common.node;
+				walk_state->num_operands = 1;
+
+				status = acpi_ds_create_node (walk_state, op->common.parent->common.node, op->common.parent);
+				if (ACPI_FAILURE (status)) {
+					break;
+				}
+
+				/* Fall through */
+				/*lint -fallthrough */
+
+			case AML_INT_EVAL_SUBTREE_OP:
+
+				status = acpi_ds_eval_data_object_operands (walk_state, op,
+						  acpi_ns_get_attached_object (op->common.parent->common.node));
+				break;
+
+			default:
+
+				status = acpi_ds_eval_data_object_operands (walk_state, op, NULL);
+				break;
+			}
+
+			/*
+			 * If a result object was returned from above, push it on the
+			 * current result stack
+			 */
+			if (ACPI_SUCCESS (status) &&
+				walk_state->result_obj) {
+				status = acpi_ds_result_push (walk_state->result_obj, walk_state);
+			}
+			break;
+
+
 		case AML_TYPE_NAMED_FIELD:
 		case AML_TYPE_NAMED_COMPLEX:
 		case AML_TYPE_NAMED_SIMPLE:
+		case AML_TYPE_NAMED_NO_OBJ:
 
 			status = acpi_ds_load2_end_op (walk_state);
 			if (ACPI_FAILURE (status)) {
 				break;
 			}
 
-			if (op->opcode == AML_REGION_OP) {
+			if (op->common.aml_opcode == AML_REGION_OP) {
 				ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-					"Executing Op_region Address/Length Op=%p\n", op));
+					"Executing op_region Address/Length Op=%p\n", op));
 
 				status = acpi_ds_eval_region_operands (walk_state, op);
 				if (ACPI_FAILURE (status)) {
@@ -539,23 +588,26 @@ acpi_ds_exec_end_op (
 
 			break;
 
+
 		case AML_TYPE_UNDEFINED:
 
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Undefined opcode type Op=%p\n", op));
 			return_ACPI_STATUS (AE_NOT_IMPLEMENTED);
-			break;
 
 
 		case AML_TYPE_BOGUS:
-			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Internal opcode=%X type Op=%p\n",
+
+			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+				"Internal opcode=%X type Op=%p\n",
 				walk_state->opcode, op));
 			break;
 
+
 		default:
 
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 				"Unimplemented opcode, class=%X type=%X Opcode=%X Op=%p\n",
-				op_class, op_type, op->opcode, op));
+				op_class, op_type, op->common.aml_opcode, op));
 
 			status = AE_NOT_IMPLEMENTED;
 			break;
@@ -563,10 +615,10 @@ acpi_ds_exec_end_op (
 	}
 
 	/*
-	 * ACPI 2.0 support for 64-bit integers:
-	 * Truncate numeric result value if we are executing from a 32-bit ACPI table
+	 * ACPI 2.0 support for 64-bit integers: Truncate numeric
+	 * result value if we are executing from a 32-bit ACPI table
 	 */
-	acpi_ex_truncate_for32bit_table (walk_state->result_obj, walk_state);
+	acpi_ex_truncate_for32bit_table (walk_state->result_obj);
 
 	/*
 	 * Check if we just completed the evaluation of a
@@ -575,9 +627,9 @@ acpi_ds_exec_end_op (
 
 	if ((walk_state->control_state) &&
 		(walk_state->control_state->common.state ==
-			CONTROL_PREDICATE_EXECUTING) &&
+			ACPI_CONTROL_PREDICATE_EXECUTING) &&
 		(walk_state->control_state->control.predicate_op == op)) {
-		status = acpi_ds_get_predicate_value (walk_state, !! walk_state->result_obj);
+		status = acpi_ds_get_predicate_value (walk_state, walk_state->result_obj);
 		walk_state->result_obj = NULL;
 	}
 
@@ -586,7 +638,7 @@ cleanup:
 	if (walk_state->result_obj) {
 		/* Break to debugger to display result */
 
-		DEBUGGER_EXEC (acpi_db_display_result_object (walk_state->result_obj, walk_state));
+		ACPI_DEBUGGER_EXEC (acpi_db_display_result_object (walk_state->result_obj, walk_state));
 
 		/*
 		 * Delete the result op if and only if:
@@ -596,12 +648,26 @@ cleanup:
 		acpi_ds_delete_result_if_not_used (op, walk_state->result_obj, walk_state);
 	}
 
+#ifdef _UNDER_DEVELOPMENT
+
+	if (walk_state->parser_state.aml == walk_state->parser_state.aml_end) {
+		acpi_db_method_end (walk_state);
+	}
+#endif
+
 	/* Always clear the object stack */
 
-	/* TBD: [Investigate] Clear stack of return value,
-	but don't delete it */
 	walk_state->num_operands = 0;
 
+#ifdef ACPI_DISASSEMBLER
+
+	/* On error, display method locals/args */
+
+	if (ACPI_FAILURE (status)) {
+		acpi_dm_dump_method_info (status, walk_state, op);
+	}
+#endif
+
 	return_ACPI_STATUS (status);
 }
 
diff -urNp linux-5400/drivers/acpi/dispatcher/dswload.c linux-5410/drivers/acpi/dispatcher/dswload.c
--- linux-5400/drivers/acpi/dispatcher/dswload.c
+++ linux-5410/drivers/acpi/dispatcher/dswload.c
@@ -1,48 +1,66 @@
 /******************************************************************************
  *
  * Module Name: dswload - Dispatcher namespace load callbacks
- *              $Revision: 50 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
-#include "amlcode.h"
-#include "acdispat.h"
-#include "acinterp.h"
-#include "acnamesp.h"
-#include "acevents.h"
+#include <acpi/acpi.h>
+#include <acpi/acparser.h>
+#include <acpi/amlcode.h>
+#include <acpi/acdispat.h>
+#include <acpi/acinterp.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acevents.h>
 
 
 #define _COMPONENT          ACPI_DISPATCHER
-	 MODULE_NAME         ("dswload")
+	 ACPI_MODULE_NAME    ("dswload")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_init_callbacks
+ * FUNCTION:    acpi_ds_init_callbacks
  *
- * PARAMETERS:  Walk_state      - Current state of the parse tree walk
- *              Pass_number     - 1, 2, or 3
+ * PARAMETERS:  walk_state      - Current state of the parse tree walk
+ *              pass_number     - 1, 2, or 3
  *
  * RETURN:      Status
  *
@@ -52,8 +70,8 @@
 
 acpi_status
 acpi_ds_init_callbacks (
-	acpi_walk_state         *walk_state,
-	u32                     pass_number)
+	struct acpi_walk_state          *walk_state,
+	u32                             pass_number)
 {
 
 	switch (pass_number) {
@@ -70,14 +88,15 @@ acpi_ds_init_callbacks (
 		break;
 
 	case 3:
+#ifndef ACPI_NO_METHOD_EXECUTION
 		walk_state->parse_flags      |= ACPI_PARSE_EXECUTE  | ACPI_PARSE_DELETE_TREE;
 		walk_state->descending_callback = acpi_ds_exec_begin_op;
 		walk_state->ascending_callback = acpi_ds_exec_end_op;
+#endif
 		break;
 
 	default:
 		return (AE_BAD_PARAMETER);
-		break;
 	}
 
 	return (AE_OK);
@@ -86,9 +105,9 @@ acpi_ds_init_callbacks (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_load1_begin_op
+ * FUNCTION:    acpi_ds_load1_begin_op
  *
- * PARAMETERS:  Walk_state      - Current state of the parse tree walk
+ * PARAMETERS:  walk_state      - Current state of the parse tree walk
  *              Op              - Op that has been just been reached in the
  *                                walk;  Arguments have not been evaluated yet.
  *
@@ -100,33 +119,42 @@ acpi_ds_init_callbacks (
 
 acpi_status
 acpi_ds_load1_begin_op (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       **out_op)
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         **out_op)
 {
-	acpi_parse_object       *op;
-	acpi_namespace_node     *node;
-	acpi_status             status;
-	acpi_object_type8       data_type;
-	NATIVE_CHAR             *path;
+	union acpi_parse_object         *op;
+	struct acpi_namespace_node      *node;
+	acpi_status                     status;
+	acpi_object_type                object_type;
+	char                            *path;
+	u32                             flags;
+
 
+	ACPI_FUNCTION_NAME ("ds_load1_begin_op");
 
-	PROC_NAME ("Ds_load1_begin_op");
 
 	op = walk_state->op;
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Op=%p State=%p\n", op, walk_state));
 
-
 	/* We are only interested in opcodes that have an associated name */
 
-	if (walk_state->op) {
-	   if (!(walk_state->op_info->flags & AML_NAMED)) {
+	if (op) {
+		if (!(walk_state->op_info->flags & AML_NAMED)) {
+#if 0
+			if ((walk_state->op_info->class == AML_CLASS_EXECUTE) ||
+				(walk_state->op_info->class == AML_CLASS_CONTROL)) {
+				acpi_os_printf ("\n\n***EXECUTABLE OPCODE %s***\n\n", walk_state->op_info->name);
+				*out_op = op;
+				return (AE_CTRL_SKIP);
+			}
+#endif
 			*out_op = op;
 			return (AE_OK);
 		}
 
 		/* Check if this object has already been installed in the namespace */
 
-		if (op->node) {
+		if (op->common.node) {
 			*out_op = op;
 			return (AE_OK);
 		}
@@ -136,30 +164,117 @@ acpi_ds_load1_begin_op (
 
 	/* Map the raw opcode into an internal object type */
 
-	data_type = acpi_ds_map_named_opcode_to_data_type (walk_state->opcode);
-
+	object_type = walk_state->op_info->object_type;
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-		"State=%p Op=%p Type=%x\n", walk_state, op, data_type));
+		"State=%p Op=%p [%s] ", walk_state, op, acpi_ut_get_type_name (object_type)));
 
+	switch (walk_state->opcode) {
+	case AML_SCOPE_OP:
 
-	if (walk_state->opcode == AML_SCOPE_OP) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-			"State=%p Op=%p Type=%x\n", walk_state, op, data_type));
-	}
+		/*
+		 * The target name of the Scope() operator must exist at this point so
+		 * that we can actually open the scope to enter new names underneath it.
+		 * Allow search-to-root for single namesegs.
+		 */
+		status = acpi_ns_lookup (walk_state->scope_info, path, object_type,
+				  ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT, walk_state, &(node));
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_NSERROR (path, status);
+			return (status);
+		}
 
-	/*
-	 * Enter the named type into the internal namespace.  We enter the name
-	 * as we go downward in the parse tree.  Any necessary subobjects that involve
-	 * arguments to the opcode must be created as we go back up the parse tree later.
-	 */
-	status = acpi_ns_lookup (walk_state->scope_info, path, data_type,
-			  IMODE_LOAD_PASS1, NS_NO_UPSEARCH, walk_state, &(node));
+		/*
+		 * Check to make sure that the target is
+		 * one of the opcodes that actually opens a scope
+		 */
+		switch (node->type) {
+		case ACPI_TYPE_LOCAL_SCOPE:         /* Scope  */
+		case ACPI_TYPE_DEVICE:
+		case ACPI_TYPE_POWER:
+		case ACPI_TYPE_PROCESSOR:
+		case ACPI_TYPE_THERMAL:
+
+			/* These are acceptable types */
+			break;
 
-	if (ACPI_FAILURE (status)) {
-		return (status);
+		case ACPI_TYPE_INTEGER:
+		case ACPI_TYPE_STRING:
+		case ACPI_TYPE_BUFFER:
+
+			/*
+			 * These types we will allow, but we will change the type.  This
+			 * enables some existing code of the form:
+			 *
+			 *  Name (DEB, 0)
+			 *  Scope (DEB) { ... }
+			 *
+			 * Note: silently change the type here.  On the second pass, we will report a warning
+			 */
+
+			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Type override - [%4.4s] had invalid type (%s) for Scope operator, changed to (Scope)\n",
+				path, acpi_ut_get_type_name (node->type)));
+
+			node->type = ACPI_TYPE_ANY;
+			walk_state->scope_info->common.value = ACPI_TYPE_ANY;
+			break;
+
+		default:
+
+			/* All other types are an error */
+
+			ACPI_REPORT_ERROR (("Invalid type (%s) for target of Scope operator [%4.4s] (Cannot override)\n",
+				acpi_ut_get_type_name (node->type), path));
+
+			return (AE_AML_OPERAND_TYPE);
+		}
+		break;
+
+
+	default:
+
+		/*
+		 * For all other named opcodes, we will enter the name into the namespace.
+		 *
+		 * Setup the search flags.
+		 * Since we are entering a name into the namespace, we do not want to
+		 * enable the search-to-root upsearch.
+		 *
+		 * There are only two conditions where it is acceptable that the name
+		 * already exists:
+		 *    1) the Scope() operator can reopen a scoping object that was
+		 *       previously defined (Scope, Method, Device, etc.)
+		 *    2) Whenever we are parsing a deferred opcode (op_region, Buffer,
+		 *       buffer_field, or Package), the name of the object is already
+		 *       in the namespace.
+		 */
+		flags = ACPI_NS_NO_UPSEARCH;
+		if ((walk_state->opcode != AML_SCOPE_OP) &&
+			(!(walk_state->parse_flags & ACPI_PARSE_DEFERRED_OP))) {
+			flags |= ACPI_NS_ERROR_IF_FOUND;
+			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DISPATCH, "Cannot already exist\n"));
+		}
+		else {
+			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DISPATCH, "Both Find or Create allowed\n"));
+		}
+
+		/*
+		 * Enter the named type into the internal namespace.  We enter the name
+		 * as we go downward in the parse tree.  Any necessary subobjects that involve
+		 * arguments to the opcode must be created as we go back up the parse tree later.
+		 */
+		status = acpi_ns_lookup (walk_state->scope_info, path, object_type,
+				  ACPI_IMODE_LOAD_PASS1, flags, walk_state, &(node));
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_NSERROR (path, status);
+			return (status);
+		}
+		break;
 	}
 
+
+	/* Common exit */
+
 	if (!op) {
 		/* Create a new op */
 
@@ -171,13 +286,18 @@ acpi_ds_load1_begin_op (
 
 	/* Initialize */
 
-	((acpi_parse2_object *)op)->name = node->name;
+	op->named.name = node->name.integer;
+
+#if (defined (ACPI_NO_METHOD_EXECUTION) || defined (ACPI_CONSTANT_EVAL_ONLY))
+	op->named.path = (u8 *) path;
+#endif
+
 
 	/*
 	 * Put the Node in the "op" object that the parser uses, so we
 	 * can get it again quickly when this scope is closed
 	 */
-	op->node = node;
+	op->common.node = node;
 	acpi_ps_append_arg (acpi_ps_get_parent_scope (&walk_state->parser_state), op);
 
 	*out_op = op;
@@ -187,9 +307,9 @@ acpi_ds_load1_begin_op (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_load1_end_op
+ * FUNCTION:    acpi_ds_load1_end_op
  *
- * PARAMETERS:  Walk_state      - Current state of the parse tree walk
+ * PARAMETERS:  walk_state      - Current state of the parse tree walk
  *              Op              - Op that has been just been completed in the
  *                                walk;  Arguments have now been evaluated.
  *
@@ -202,57 +322,107 @@ acpi_ds_load1_begin_op (
 
 acpi_status
 acpi_ds_load1_end_op (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_parse_object       *op;
-	acpi_object_type8       data_type;
+	union acpi_parse_object         *op;
+	acpi_object_type                object_type;
+	acpi_status                     status = AE_OK;
+
 
+	ACPI_FUNCTION_NAME ("ds_load1_end_op");
 
-	PROC_NAME ("Ds_load1_end_op");
 
 	op = walk_state->op;
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Op=%p State=%p\n", op, walk_state));
 
-
 	/* We are only interested in opcodes that have an associated name */
 
-	if (!(walk_state->op_info->flags & AML_NAMED)) {
+	if (!(walk_state->op_info->flags & (AML_NAMED | AML_FIELD))) {
 		return (AE_OK);
 	}
 
-	/* Get the type to determine if we should pop the scope */
+	/* Get the object type to determine if we should pop the scope */
 
-	data_type = acpi_ds_map_named_opcode_to_data_type (op->opcode);
+	object_type = walk_state->op_info->object_type;
 
-	if (op->opcode == AML_NAME_OP) {
-		/* For Name opcode, check the argument */
+#ifndef ACPI_NO_METHOD_EXECUTION
+	if (walk_state->op_info->flags & AML_FIELD) {
+		if (walk_state->opcode == AML_FIELD_OP         ||
+			walk_state->opcode == AML_BANK_FIELD_OP    ||
+			walk_state->opcode == AML_INDEX_FIELD_OP) {
+			status = acpi_ds_init_field_objects (op, walk_state);
+		}
+		return (status);
+	}
 
-		if (op->value.arg) {
-			data_type = acpi_ds_map_opcode_to_data_type (
-					  (op->value.arg)->opcode, NULL);
-			((acpi_namespace_node *)op->node)->type =
-					  (u8) data_type;
+
+	if (op->common.aml_opcode == AML_REGION_OP) {
+		status = acpi_ex_create_region (op->named.data, op->named.length,
+				   (acpi_adr_space_type) ((op->common.value.arg)->common.value.integer), walk_state);
+		if (ACPI_FAILURE (status)) {
+			return (status);
+		}
+	}
+#endif
+
+	if (op->common.aml_opcode == AML_NAME_OP) {
+		/* For Name opcode, get the object type from the argument */
+
+		if (op->common.value.arg) {
+			object_type = (acpi_ps_get_opcode_info ((op->common.value.arg)->common.aml_opcode))->object_type;
+			op->common.node->type = (u8) object_type;
+		}
+	}
+
+	if (op->common.aml_opcode == AML_METHOD_OP) {
+		/*
+		 * method_op pkg_length name_string method_flags term_list
+		 *
+		 * Note: We must create the method node/object pair as soon as we
+		 * see the method declaration.  This allows later pass1 parsing
+		 * of invocations of the method (need to know the number of
+		 * arguments.)
+		 */
+		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+			"LOADING-Method: State=%p Op=%p named_obj=%p\n",
+			walk_state, op, op->named.node));
+
+		if (!acpi_ns_get_attached_object (op->named.node)) {
+			walk_state->operands[0] = (void *) op->named.node;
+			walk_state->num_operands = 1;
+
+			status = acpi_ds_create_operands (walk_state, op->common.value.arg);
+			if (ACPI_SUCCESS (status)) {
+				status = acpi_ex_create_method (op->named.data,
+						   op->named.length, walk_state);
+			}
+			walk_state->operands[0] = NULL;
+			walk_state->num_operands = 0;
+
+			if (ACPI_FAILURE (status)) {
+				return (status);
+			}
 		}
 	}
 
 	/* Pop the scope stack */
 
-	if (acpi_ns_opens_scope (data_type)) {
+	if (acpi_ns_opens_scope (object_type)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "(%s): Popping scope for Op %p\n",
-			acpi_ut_get_type_name (data_type), op));
+			acpi_ut_get_type_name (object_type), op));
 
-		acpi_ds_scope_stack_pop (walk_state);
+		status = acpi_ds_scope_stack_pop (walk_state);
 	}
 
-	return (AE_OK);
+	return (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_load2_begin_op
+ * FUNCTION:    acpi_ds_load2_begin_op
  *
- * PARAMETERS:  Walk_state      - Current state of the parse tree walk
+ * PARAMETERS:  walk_state      - Current state of the parse tree walk
  *              Op              - Op that has been just been reached in the
  *                                walk;  Arguments have not been evaluated yet.
  *
@@ -264,35 +434,28 @@ acpi_ds_load1_end_op (
 
 acpi_status
 acpi_ds_load2_begin_op (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       **out_op)
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         **out_op)
 {
-	acpi_parse_object       *op;
-	acpi_namespace_node     *node;
-	acpi_status             status;
-	acpi_object_type8       data_type;
-	NATIVE_CHAR             *buffer_ptr;
-	void                    *original = NULL;
+	union acpi_parse_object         *op;
+	struct acpi_namespace_node      *node;
+	acpi_status                     status;
+	acpi_object_type                object_type;
+	char                            *buffer_ptr;
 
 
-	PROC_NAME ("Ds_load2_begin_op");
+	ACPI_FUNCTION_TRACE ("ds_load2_begin_op");
+
 
 	op = walk_state->op;
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Op=%p State=%p\n", op, walk_state));
 
-
 	if (op) {
 		/* We only care about Namespace opcodes here */
 
-		if (!(walk_state->op_info->flags & AML_NSOPCODE) &&
-			walk_state->opcode != AML_INT_NAMEPATH_OP) {
-			return (AE_OK);
-		}
-
-		/* TBD: [Restructure] Temp! same code as in psparse */
-
-		if (!(walk_state->op_info->flags & AML_NAMED)) {
-			return (AE_OK);
+		if ((!(walk_state->op_info->flags & AML_NSOPCODE) && (walk_state->opcode != AML_INT_NAMEPATH_OP)) ||
+			(!(walk_state->op_info->flags & AML_NAMED))) {
+			return_ACPI_STATUS (AE_OK);
 		}
 
 		/*
@@ -301,61 +464,125 @@ acpi_ds_load2_begin_op (
 		if (walk_state->opcode == AML_INT_NAMEPATH_OP) {
 			/* For Namepath op, get the path string */
 
-			buffer_ptr = op->value.string;
+			buffer_ptr = op->common.value.string;
 			if (!buffer_ptr) {
 				/* No name, just exit */
 
-				return (AE_OK);
+				return_ACPI_STATUS (AE_OK);
 			}
 		}
 		else {
 			/* Get name from the op */
 
-			buffer_ptr = (NATIVE_CHAR *) &((acpi_parse2_object *)op)->name;
+			buffer_ptr = (char *) &op->named.name;
 		}
 	}
 	else {
+		/* Get the namestring from the raw AML */
+
 		buffer_ptr = acpi_ps_get_next_namestring (&walk_state->parser_state);
 	}
 
+	/* Map the opcode into an internal object type */
 
-	/* Map the raw opcode into an internal object type */
-
-	data_type = acpi_ds_map_named_opcode_to_data_type (walk_state->opcode);
+	object_type = walk_state->op_info->object_type;
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-		"State=%p Op=%p Type=%x\n", walk_state, op, data_type));
+		"State=%p Op=%p Type=%X\n", walk_state, op, object_type));
+
 
+	switch (walk_state->opcode) {
+	case AML_FIELD_OP:
+	case AML_BANK_FIELD_OP:
+	case AML_INDEX_FIELD_OP:
 
-	if (walk_state->opcode == AML_FIELD_OP         ||
-		walk_state->opcode == AML_BANK_FIELD_OP    ||
-		walk_state->opcode == AML_INDEX_FIELD_OP) {
 		node = NULL;
 		status = AE_OK;
-	}
+		break;
+
+	case AML_INT_NAMEPATH_OP:
 
-	else if (walk_state->opcode == AML_INT_NAMEPATH_OP) {
 		/*
-		 * The Name_path is an object reference to an existing object. Don't enter the
+		 * The name_path is an object reference to an existing object. Don't enter the
 		 * name into the namespace, but look it up for use later
 		 */
-		status = acpi_ns_lookup (walk_state->scope_info, buffer_ptr, data_type,
-				  IMODE_EXECUTE, NS_SEARCH_PARENT, walk_state, &(node));
-	}
+		status = acpi_ns_lookup (walk_state->scope_info, buffer_ptr, object_type,
+				  ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT, walk_state, &(node));
+		break;
 
-	else {
-		if (op && op->node) {
-			original = op->node;
-			node = op->node;
+	case AML_SCOPE_OP:
 
-			if (acpi_ns_opens_scope (data_type)) {
-				status = acpi_ds_scope_stack_push (node, data_type, walk_state);
+		/*
+		 * The Path is an object reference to an existing object.  Don't enter the
+		 * name into the namespace, but look it up for use later
+		 */
+		status = acpi_ns_lookup (walk_state->scope_info, buffer_ptr, object_type,
+				  ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT, walk_state, &(node));
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_NSERROR (buffer_ptr, status);
+			return_ACPI_STATUS (status);
+		}
+		/*
+		 * We must check to make sure that the target is
+		 * one of the opcodes that actually opens a scope
+		 */
+		switch (node->type) {
+		case ACPI_TYPE_LOCAL_SCOPE:         /* Scope */
+		case ACPI_TYPE_DEVICE:
+		case ACPI_TYPE_POWER:
+		case ACPI_TYPE_PROCESSOR:
+		case ACPI_TYPE_THERMAL:
+
+			/* These are acceptable types */
+			break;
+
+		case ACPI_TYPE_INTEGER:
+		case ACPI_TYPE_STRING:
+		case ACPI_TYPE_BUFFER:
+
+			/*
+			 * These types we will allow, but we will change the type.  This
+			 * enables some existing code of the form:
+			 *
+			 *  Name (DEB, 0)
+			 *  Scope (DEB) { ... }
+			 */
+
+			ACPI_REPORT_WARNING (("Type override - [%4.4s] had invalid type (%s) for Scope operator, changed to (Scope)\n",
+				buffer_ptr, acpi_ut_get_type_name (node->type)));
+
+			node->type = ACPI_TYPE_ANY;
+			walk_state->scope_info->common.value = ACPI_TYPE_ANY;
+			break;
+
+		default:
+
+			/* All other types are an error */
+
+			ACPI_REPORT_ERROR (("Invalid type (%s) for target of Scope operator [%4.4s]\n",
+				acpi_ut_get_type_name (node->type), buffer_ptr));
+
+			return (AE_AML_OPERAND_TYPE);
+		}
+		break;
+
+	default:
+
+		/* All other opcodes */
+
+		if (op && op->common.node) {
+			/* This op/node was previously entered into the namespace */
+
+			node = op->common.node;
+
+			if (acpi_ns_opens_scope (object_type)) {
+				status = acpi_ds_scope_stack_push (node, object_type, walk_state);
 				if (ACPI_FAILURE (status)) {
-					return (status);
+					return_ACPI_STATUS (status);
 				}
 
 			}
-			return (AE_OK);
+			return_ACPI_STATUS (AE_OK);
 		}
 
 		/*
@@ -363,50 +590,50 @@ acpi_ds_load2_begin_op (
 		 * as we go downward in the parse tree.  Any necessary subobjects that involve
 		 * arguments to the opcode must be created as we go back up the parse tree later.
 		 */
-		status = acpi_ns_lookup (walk_state->scope_info, buffer_ptr, data_type,
-				  IMODE_EXECUTE, NS_NO_UPSEARCH, walk_state, &(node));
+		status = acpi_ns_lookup (walk_state->scope_info, buffer_ptr, object_type,
+				  ACPI_IMODE_EXECUTE, ACPI_NS_NO_UPSEARCH, walk_state, &(node));
+		break;
 	}
 
-	if (ACPI_SUCCESS (status)) {
-		if (!op) {
-			/* Create a new op */
+	if (ACPI_FAILURE (status)) {
+		ACPI_REPORT_NSERROR (buffer_ptr, status);
+		return_ACPI_STATUS (status);
+	}
 
-			op = acpi_ps_alloc_op (walk_state->opcode);
-			if (!op) {
-				return (AE_NO_MEMORY);
-			}
 
-			/* Initialize */
+	if (!op) {
+		/* Create a new op */
 
-			((acpi_parse2_object *)op)->name = node->name;
-			*out_op = op;
+		op = acpi_ps_alloc_op (walk_state->opcode);
+		if (!op) {
+			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
 
-		/*
-		 * Put the Node in the "op" object that the parser uses, so we
-		 * can get it again quickly when this scope is closed
-		 */
-		op->node = node;
-
-		if (original) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "old %p new %p\n", original, node));
+		/* Initialize the new op */
 
-			if (original != node) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-					"Lookup match error: old %p new %p\n", original, node));
-			}
+		if (node) {
+			op->named.name = node->name.integer;
+		}
+		if (out_op) {
+			*out_op = op;
 		}
 	}
 
-	return (status);
+	/*
+	 * Put the Node in the "op" object that the parser uses, so we
+	 * can get it again quickly when this scope is closed
+	 */
+	op->common.node = node;
+
+	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_load2_end_op
+ * FUNCTION:    acpi_ds_load2_end_op
  *
- * PARAMETERS:  Walk_state      - Current state of the parse tree walk
+ * PARAMETERS:  walk_state      - Current state of the parse tree walk
  *              Op              - Op that has been just been completed in the
  *                                walk;  Arguments have now been evaluated.
  *
@@ -419,48 +646,44 @@ acpi_ds_load2_begin_op (
 
 acpi_status
 acpi_ds_load2_end_op (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_parse_object       *op;
-	acpi_status             status = AE_OK;
-	acpi_object_type8       data_type;
-	acpi_namespace_node     *node;
-	acpi_parse_object       *arg;
-	acpi_namespace_node     *new_node;
-	u32                     i;
+	union acpi_parse_object         *op;
+	acpi_status                     status = AE_OK;
+	acpi_object_type                object_type;
+	struct acpi_namespace_node      *node;
+	union acpi_parse_object         *arg;
+	struct acpi_namespace_node      *new_node;
+#ifndef ACPI_NO_METHOD_EXECUTION
+	u32                             i;
+#endif
 
 
-	PROC_NAME ("Ds_load2_end_op");
+	ACPI_FUNCTION_TRACE ("ds_load2_end_op");
 
 	op = walk_state->op;
-	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Op=%p State=%p\n", op, walk_state));
-
+	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Opcode [%s] Op %p State %p\n",
+			walk_state->op_info->name, op, walk_state));
 
 	/* Only interested in opcodes that have namespace objects */
 
 	if (!(walk_state->op_info->flags & AML_NSOBJECT)) {
-		return (AE_OK);
+		return_ACPI_STATUS (AE_OK);
 	}
 
-	if (op->opcode == AML_SCOPE_OP) {
+	if (op->common.aml_opcode == AML_SCOPE_OP) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
 			"Ending scope Op=%p State=%p\n", op, walk_state));
-
-		if (((acpi_parse2_object *)op)->name == -1) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unnamed scope! Op=%p State=%p\n",
-				op, walk_state));
-			return (AE_OK);
-		}
 	}
 
 
-	data_type = acpi_ds_map_named_opcode_to_data_type (op->opcode);
+	object_type = walk_state->op_info->object_type;
 
 	/*
 	 * Get the Node/name from the earlier lookup
 	 * (It was saved in the *op structure)
 	 */
-	node = op->node;
+	node = op->common.node;
 
 	/*
 	 * Put the Node on the object stack (Contains the ACPI Name of
@@ -471,11 +694,14 @@ acpi_ds_load2_end_op (
 
 	/* Pop the scope stack */
 
-	if (acpi_ns_opens_scope (data_type)) {
-
+	if (acpi_ns_opens_scope (object_type) && (op->common.aml_opcode != AML_INT_METHODCALL_OP)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "(%s) Popping scope for Op %p\n",
-			acpi_ut_get_type_name (data_type), op));
-		acpi_ds_scope_stack_pop (walk_state);
+			acpi_ut_get_type_name (object_type), op));
+
+		status = acpi_ds_scope_stack_pop (walk_state);
+		if (ACPI_FAILURE (status)) {
+			goto cleanup;
+		}
 	}
 
 	/*
@@ -507,14 +733,16 @@ acpi_ds_load2_end_op (
 	 */
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-		"Create-Load [%s] State=%p Op=%p Named_obj=%p\n",
-		acpi_ps_get_opcode_name (op->opcode), walk_state, op, node));
+		"Create-Load [%s] State=%p Op=%p named_obj=%p\n",
+		acpi_ps_get_opcode_name (op->common.aml_opcode), walk_state, op, node));
 
 	/* Decode the opcode */
 
-	arg = op->value.arg;
+	arg = op->common.value.arg;
 
 	switch (walk_state->op_info->type) {
+#ifndef ACPI_NO_METHOD_EXECUTION
+
 	case AML_TYPE_CREATE_FIELD:
 
 		/*
@@ -527,24 +755,25 @@ acpi_ds_load2_end_op (
 
 	 case AML_TYPE_NAMED_FIELD:
 
-		arg = op->value.arg;
-		switch (op->opcode) {
+		switch (op->common.aml_opcode) {
 		case AML_INDEX_FIELD_OP:
 
-			status = acpi_ds_create_index_field (op, (acpi_handle) arg->node,
+			status = acpi_ds_create_index_field (op, (acpi_handle) arg->common.node,
 					   walk_state);
 			break;
 
-
 		case AML_BANK_FIELD_OP:
 
-			status = acpi_ds_create_bank_field (op, arg->node, walk_state);
+			status = acpi_ds_create_bank_field (op, arg->common.node, walk_state);
 			break;
 
-
 		case AML_FIELD_OP:
 
-			status = acpi_ds_create_field (op, arg->node, walk_state);
+			status = acpi_ds_create_field (op, arg->common.node, walk_state);
+			break;
+
+		default:
+			/* All NAMED_FIELD opcodes must be handled above */
 			break;
 		}
 		break;
@@ -557,31 +786,27 @@ acpi_ds_load2_end_op (
 			goto cleanup;
 		}
 
-		switch (op->opcode) {
+		switch (op->common.aml_opcode) {
 		case AML_PROCESSOR_OP:
 
 			status = acpi_ex_create_processor (walk_state);
 			break;
 
-
 		case AML_POWER_RES_OP:
 
 			status = acpi_ex_create_power_resource (walk_state);
 			break;
 
-
 		case AML_MUTEX_OP:
 
 			status = acpi_ex_create_mutex (walk_state);
 			break;
 
-
 		case AML_EVENT_OP:
 
 			status = acpi_ex_create_event (walk_state);
 			break;
 
-
 		case AML_DATA_REGION_OP:
 
 			status = acpi_ex_create_table_region (walk_state);
@@ -597,7 +822,6 @@ acpi_ds_load2_end_op (
 
 			status = AE_OK;
 			goto cleanup;
-			break;
 		}
 
 		/* Delete operands */
@@ -608,40 +832,32 @@ acpi_ds_load2_end_op (
 		}
 
 		break;
-
+#endif /* ACPI_NO_METHOD_EXECUTION */
 
 	case AML_TYPE_NAMED_COMPLEX:
 
-		switch (op->opcode) {
-		case AML_METHOD_OP:
-			/*
-			 * Method_op Pkg_length Names_string Method_flags Term_list
-			 */
-			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-				"LOADING-Method: State=%p Op=%p Named_obj=%p\n",
-				walk_state, op, node));
-
-			if (!node->object) {
-				status = acpi_ds_create_operands (walk_state, arg);
-				if (ACPI_FAILURE (status)) {
-					goto cleanup;
-				}
-
-				status = acpi_ex_create_method (((acpi_parse2_object *) op)->data,
-						   ((acpi_parse2_object *) op)->length,
-						   walk_state);
-			}
-			break;
-
-
+		switch (op->common.aml_opcode) {
+#ifndef ACPI_NO_METHOD_EXECUTION
 		case AML_REGION_OP:
 			/*
-			 * The Op_region is not fully parsed at this time. Only valid argument is the Space_id.
+			 * The op_region is not fully parsed at this time. Only valid argument is the space_id.
 			 * (We must save the address of the AML of the address and length operands)
 			 */
-			status = acpi_ex_create_region (((acpi_parse2_object *) op)->data,
-					  ((acpi_parse2_object *) op)->length,
-							 (ACPI_ADR_SPACE_TYPE) arg->value.integer, walk_state);
+			/*
+			 * If we have a valid region, initialize it
+			 * Namespace is NOT locked at this point.
+			 */
+			status = acpi_ev_initialize_region (acpi_ns_get_attached_object (node), FALSE);
+			if (ACPI_FAILURE (status)) {
+				/*
+				 *  If AE_NOT_EXIST is returned, it is not fatal
+				 *  because many regions get created before a handler
+				 *  is installed for said region.
+				 */
+				if (AE_NOT_EXIST == status) {
+					status = AE_OK;
+				}
+			}
 			break;
 
 
@@ -649,6 +865,13 @@ acpi_ds_load2_end_op (
 
 			status = acpi_ds_create_node (walk_state, node, op);
 			break;
+#endif /* ACPI_NO_METHOD_EXECUTION */
+
+
+		default:
+			/* All NAMED_COMPLEX opcodes must be handled above */
+			/* Note: Method objects were already created in Pass 1 */
+			break;
 		}
 		break;
 
@@ -662,29 +885,34 @@ acpi_ds_load2_end_op (
 	case AML_CLASS_METHOD_CALL:
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-			"RESOLVING-Method_call: State=%p Op=%p Named_obj=%p\n",
+			"RESOLVING-method_call: State=%p Op=%p named_obj=%p\n",
 			walk_state, op, node));
 
 		/*
 		 * Lookup the method name and save the Node
 		 */
-		status = acpi_ns_lookup (walk_state->scope_info, arg->value.string,
-				  ACPI_TYPE_ANY, IMODE_LOAD_PASS2,
-				  NS_SEARCH_PARENT | NS_DONT_OPEN_SCOPE,
+		status = acpi_ns_lookup (walk_state->scope_info, arg->common.value.string,
+				  ACPI_TYPE_ANY, ACPI_IMODE_LOAD_PASS2,
+				  ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE,
 				  walk_state, &(new_node));
 		if (ACPI_SUCCESS (status)) {
-			/* TBD: has name already been resolved by here ??*/
-
-			/* TBD: [Restructure] Make sure that what we found is indeed a method! */
-			/* We didn't search for a method on purpose, to see if the name would resolve! */
+			/*
+			 * Make sure that what we found is indeed a method
+			 * We didn't search for a method on purpose, to see if the name would resolve
+			 */
+			if (new_node->type != ACPI_TYPE_METHOD) {
+				status = AE_AML_OPERAND_TYPE;
+			}
 
 			/* We could put the returned object (Node) on the object stack for later, but
 			 * for now, we will put it in the "op" object that the parser uses, so we
 			 * can get it again at the end of this scope
 			 */
-			op->node = new_node;
+			op->common.node = new_node;
+		}
+		else {
+			ACPI_REPORT_NSERROR (arg->common.value.string, status);
 		}
-
 		break;
 
 
@@ -692,14 +920,13 @@ acpi_ds_load2_end_op (
 		break;
 	}
 
-
 cleanup:
 
 	/* Remove the Node pushed at the very beginning */
 
 	walk_state->operands[0] = NULL;
 	walk_state->num_operands = 0;
-	return (status);
+	return_ACPI_STATUS (status);
 }
 
 
diff -urNp linux-5400/drivers/acpi/dispatcher/dswscope.c linux-5410/drivers/acpi/dispatcher/dswscope.c
--- linux-5400/drivers/acpi/dispatcher/dswscope.c
+++ linux-5410/drivers/acpi/dispatcher/dswscope.c
@@ -1,36 +1,53 @@
 /******************************************************************************
  *
  * Module Name: dswscope - Scope stack manipulation
- *              $Revision: 49 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acinterp.h"
-#include "acdispat.h"
+#include <acpi/acpi.h>
+#include <acpi/acdispat.h>
 
 
 #define _COMPONENT          ACPI_DISPATCHER
-	 MODULE_NAME         ("dswscope")
+	 ACPI_MODULE_NAME    ("dswscope")
 
 
 #define STACK_POP(head) head
@@ -38,7 +55,7 @@
 
 /****************************************************************************
  *
- * FUNCTION:    Acpi_ds_scope_stack_clear
+ * FUNCTION:    acpi_ds_scope_stack_clear
  *
  * PARAMETERS:  None
  *
@@ -49,11 +66,11 @@
 
 void
 acpi_ds_scope_stack_clear (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_generic_state      *scope_info;
+	union acpi_generic_state        *scope_info;
 
-	PROC_NAME ("Ds_scope_stack_clear");
+	ACPI_FUNCTION_NAME ("ds_scope_stack_clear");
 
 
 	while (walk_state->scope_info) {
@@ -63,7 +80,7 @@ acpi_ds_scope_stack_clear (
 		walk_state->scope_info = scope_info->scope.next;
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-			"Popped object type %X\n", scope_info->common.value));
+			"Popped object type (%s)\n", acpi_ut_get_type_name (scope_info->common.value)));
 		acpi_ut_delete_generic_state (scope_info);
 	}
 }
@@ -71,7 +88,7 @@ acpi_ds_scope_stack_clear (
 
 /****************************************************************************
  *
- * FUNCTION:    Acpi_ds_scope_stack_push
+ * FUNCTION:    acpi_ds_scope_stack_push
  *
  * PARAMETERS:  *Node,              - Name to be made current
  *              Type,               - Type of frame being pushed
@@ -83,27 +100,28 @@ acpi_ds_scope_stack_clear (
 
 acpi_status
 acpi_ds_scope_stack_push (
-	acpi_namespace_node     *node,
-	acpi_object_type8       type,
-	acpi_walk_state         *walk_state)
+	struct acpi_namespace_node      *node,
+	acpi_object_type                type,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_generic_state      *scope_info;
+	union acpi_generic_state        *scope_info;
+	union acpi_generic_state        *old_scope_info;
 
 
-	FUNCTION_TRACE ("Ds_scope_stack_push");
+	ACPI_FUNCTION_TRACE ("ds_scope_stack_push");
 
 
 	if (!node) {
 		/* Invalid scope   */
 
-		REPORT_ERROR (("Ds_scope_stack_push: null scope passed\n"));
+		ACPI_REPORT_ERROR (("ds_scope_stack_push: null scope passed\n"));
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
 	/* Make sure object type is valid */
 
-	if (!acpi_ex_validate_object_type (type)) {
-		REPORT_WARNING (("Ds_scope_stack_push: type code out of range\n"));
+	if (!acpi_ut_valid_object_type (type)) {
+		ACPI_REPORT_WARNING (("ds_scope_stack_push: type code out of range\n"));
 	}
 
 
@@ -120,6 +138,28 @@ acpi_ds_scope_stack_push (
 	scope_info->scope.node      = node;
 	scope_info->common.value    = (u16) type;
 
+	walk_state->scope_depth++;
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+		"[%.2d] Pushed scope ", (u32) walk_state->scope_depth));
+
+	old_scope_info = walk_state->scope_info;
+	if (old_scope_info) {
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_EXEC,
+			"[%4.4s] (%10s)",
+			old_scope_info->scope.node->name.ascii,
+			acpi_ut_get_type_name (old_scope_info->common.value)));
+	}
+	else {
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_EXEC,
+			"[\\___] (%10s)", "ROOT"));
+	}
+
+	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_EXEC,
+		", New scope -> [%4.4s] (%s)\n",
+		scope_info->scope.node->name.ascii,
+		acpi_ut_get_type_name (scope_info->common.value)));
+
 	/* Push new scope object onto stack */
 
 	acpi_ut_push_generic_state (&walk_state->scope_info, scope_info);
@@ -130,7 +170,7 @@ acpi_ds_scope_stack_push (
 
 /****************************************************************************
  *
- * FUNCTION:    Acpi_ds_scope_stack_pop
+ * FUNCTION:    acpi_ds_scope_stack_pop
  *
  * PARAMETERS:  Type                - The type of frame to be found
  *
@@ -147,12 +187,13 @@ acpi_ds_scope_stack_push (
 
 acpi_status
 acpi_ds_scope_stack_pop (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_generic_state      *scope_info;
+	union acpi_generic_state        *scope_info;
+	union acpi_generic_state        *new_scope_info;
 
 
-	FUNCTION_TRACE ("Ds_scope_stack_pop");
+	ACPI_FUNCTION_TRACE ("ds_scope_stack_pop");
 
 
 	/*
@@ -163,8 +204,25 @@ acpi_ds_scope_stack_pop (
 		return_ACPI_STATUS (AE_STACK_UNDERFLOW);
 	}
 
+	walk_state->scope_depth--;
+
 	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-		"Popped object type %X\n", scope_info->common.value));
+		"[%.2d] Popped scope [%4.4s] (%10s), New scope -> ",
+		(u32) walk_state->scope_depth,
+		scope_info->scope.node->name.ascii,
+		acpi_ut_get_type_name (scope_info->common.value)));
+
+	new_scope_info = walk_state->scope_info;
+	if (new_scope_info) {
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_EXEC,
+			"[%4.4s] (%s)\n",
+			new_scope_info->scope.node->name.ascii,
+			acpi_ut_get_type_name (new_scope_info->common.value)));
+	}
+	else {
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_EXEC,
+			"[\\___] (ROOT)\n"));
+	}
 
 	acpi_ut_delete_generic_state (scope_info);
 
diff -urNp linux-5400/drivers/acpi/dispatcher/dswstate.c linux-5410/drivers/acpi/dispatcher/dswstate.c
--- linux-5400/drivers/acpi/dispatcher/dswstate.c
+++ linux-5410/drivers/acpi/dispatcher/dswstate.c
@@ -1,46 +1,62 @@
 /******************************************************************************
  *
  * Module Name: dswstate - Dispatcher parse tree walk management routines
- *              $Revision: 54 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "amlcode.h"
-#include "acparser.h"
-#include "acdispat.h"
-#include "acnamesp.h"
-#include "acinterp.h"
+#include <acpi/acpi.h>
+#include <acpi/acparser.h>
+#include <acpi/acdispat.h>
+#include <acpi/acnamesp.h>
 
 #define _COMPONENT          ACPI_DISPATCHER
-	 MODULE_NAME         ("dswstate")
+	 ACPI_MODULE_NAME    ("dswstate")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_result_insert
+ * FUNCTION:    acpi_ds_result_insert
  *
  * PARAMETERS:  Object              - Object to push
- *              Walk_state          - Current Walk state
+ *              walk_state          - Current Walk state
  *
  * RETURN:      Status
  *
@@ -50,14 +66,14 @@
 
 acpi_status
 acpi_ds_result_insert (
-	void                    *object,
-	u32                     index,
-	acpi_walk_state         *walk_state)
+	void                            *object,
+	u32                             index,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_generic_state      *state;
+	union acpi_generic_state        *state;
 
 
-	PROC_NAME ("Ds_result_insert");
+	ACPI_FUNCTION_NAME ("ds_result_insert");
 
 
 	state = walk_state->results;
@@ -67,7 +83,7 @@ acpi_ds_result_insert (
 		return (AE_NOT_EXIST);
 	}
 
-	if (index >= OBJ_NUM_OPERANDS) {
+	if (index >= ACPI_OBJ_NUM_OPERANDS) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"Index out of range: %X Obj=%p State=%p Num=%X\n",
 			index, object, walk_state, state->results.num_results));
@@ -86,7 +102,7 @@ acpi_ds_result_insert (
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
 		"Obj=%p [%s] State=%p Num=%X Cur=%X\n",
-		object, object ? acpi_ut_get_type_name (((acpi_operand_object *) object)->common.type) : "NULL",
+		object, object ? acpi_ut_get_object_type_name ((union acpi_operand_object *) object) : "NULL",
 		walk_state, state->results.num_results, walk_state->current_result));
 
 	return (AE_OK);
@@ -95,10 +111,10 @@ acpi_ds_result_insert (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_result_remove
+ * FUNCTION:    acpi_ds_result_remove
  *
  * PARAMETERS:  Object              - Where to return the popped object
- *              Walk_state          - Current Walk state
+ *              walk_state          - Current Walk state
  *
  * RETURN:      Status
  *
@@ -109,14 +125,14 @@ acpi_ds_result_insert (
 
 acpi_status
 acpi_ds_result_remove (
-	acpi_operand_object     **object,
-	u32                     index,
-	acpi_walk_state         *walk_state)
+	union acpi_operand_object       **object,
+	u32                             index,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_generic_state      *state;
+	union acpi_generic_state        *state;
 
 
-	PROC_NAME ("Ds_result_remove");
+	ACPI_FUNCTION_NAME ("ds_result_remove");
 
 
 	state = walk_state->results;
@@ -126,13 +142,12 @@ acpi_ds_result_remove (
 		return (AE_NOT_EXIST);
 	}
 
-	if (index >= OBJ_NUM_OPERANDS) {
+	if (index >= ACPI_OBJ_MAX_OPERAND) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"Index out of range: %X State=%p Num=%X\n",
 			index, walk_state, state->results.num_results));
 	}
 
-
 	/* Check for a valid result object */
 
 	if (!state->results.obj_desc [index]) {
@@ -151,7 +166,7 @@ acpi_ds_result_remove (
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
 		"Obj=%p [%s] Index=%X State=%p Num=%X\n",
-		*object, (*object) ? acpi_ut_get_type_name ((*object)->common.type) : "NULL",
+		*object, (*object) ? acpi_ut_get_object_type_name (*object) : "NULL",
 		index, walk_state, state->results.num_results));
 
 	return (AE_OK);
@@ -160,10 +175,10 @@ acpi_ds_result_remove (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_result_pop
+ * FUNCTION:    acpi_ds_result_pop
  *
  * PARAMETERS:  Object              - Where to return the popped object
- *              Walk_state          - Current Walk state
+ *              walk_state          - Current Walk state
  *
  * RETURN:      Status
  *
@@ -174,14 +189,14 @@ acpi_ds_result_remove (
 
 acpi_status
 acpi_ds_result_pop (
-	acpi_operand_object     **object,
-	acpi_walk_state         *walk_state)
+	union acpi_operand_object       **object,
+	struct acpi_walk_state          *walk_state)
 {
-	u32                     index;
-	acpi_generic_state      *state;
+	acpi_native_uint                index;
+	union acpi_generic_state        *state;
 
 
-	PROC_NAME ("Ds_result_pop");
+	ACPI_FUNCTION_NAME ("ds_result_pop");
 
 
 	state = walk_state->results;
@@ -199,7 +214,7 @@ acpi_ds_result_pop (
 
 	state->results.num_results--;
 
-	for (index = OBJ_NUM_OPERANDS; index; index--) {
+	for (index = ACPI_OBJ_NUM_OPERANDS; index; index--) {
 		/* Check for a valid result object */
 
 		if (state->results.obj_desc [index -1]) {
@@ -207,8 +222,8 @@ acpi_ds_result_pop (
 			state->results.obj_desc [index -1] = NULL;
 
 			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Obj=%p [%s] Index=%X State=%p Num=%X\n",
-				*object, (*object) ? acpi_ut_get_type_name ((*object)->common.type) : "NULL",
-				index -1, walk_state, state->results.num_results));
+				*object, (*object) ? acpi_ut_get_object_type_name (*object) : "NULL",
+				(u32) index -1, walk_state, state->results.num_results));
 
 			return (AE_OK);
 		}
@@ -220,10 +235,10 @@ acpi_ds_result_pop (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_result_pop_from_bottom
+ * FUNCTION:    acpi_ds_result_pop_from_bottom
  *
  * PARAMETERS:  Object              - Where to return the popped object
- *              Walk_state          - Current Walk state
+ *              walk_state          - Current Walk state
  *
  * RETURN:      Status
  *
@@ -234,14 +249,14 @@ acpi_ds_result_pop (
 
 acpi_status
 acpi_ds_result_pop_from_bottom (
-	acpi_operand_object     **object,
-	acpi_walk_state         *walk_state)
+	union acpi_operand_object       **object,
+	struct acpi_walk_state          *walk_state)
 {
-	u32                     index;
-	acpi_generic_state      *state;
+	acpi_native_uint                index;
+	union acpi_generic_state        *state;
 
 
-	PROC_NAME ("Ds_result_pop_from_bottom");
+	ACPI_FUNCTION_NAME ("ds_result_pop_from_bottom");
 
 
 	state = walk_state->results;
@@ -251,7 +266,6 @@ acpi_ds_result_pop_from_bottom (
 		return (AE_NOT_EXIST);
 	}
 
-
 	if (!state->results.num_results) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No result objects! State=%p\n", walk_state));
 		return (AE_AML_NO_RETURN_VALUE);
@@ -273,12 +287,12 @@ acpi_ds_result_pop_from_bottom (
 
 	if (!*object) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Null operand! State=%p #Ops=%X, Index=%X\n",
-			walk_state, state->results.num_results, index));
+			walk_state, state->results.num_results, (u32) index));
 		return (AE_AML_NO_RETURN_VALUE);
 	}
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Obj=%p [%s], Results=%p State=%p\n",
-		*object, (*object) ? acpi_ut_get_type_name ((*object)->common.type) : "NULL",
+		*object, (*object) ? acpi_ut_get_object_type_name (*object) : "NULL",
 		state, walk_state));
 
 
@@ -288,10 +302,10 @@ acpi_ds_result_pop_from_bottom (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_result_push
+ * FUNCTION:    acpi_ds_result_push
  *
  * PARAMETERS:  Object              - Where to return the popped object
- *              Walk_state          - Current Walk state
+ *              walk_state          - Current Walk state
  *
  * RETURN:      Status
  *
@@ -301,13 +315,13 @@ acpi_ds_result_pop_from_bottom (
 
 acpi_status
 acpi_ds_result_push (
-	acpi_operand_object     *object,
-	acpi_walk_state         *walk_state)
+	union acpi_operand_object       *object,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_generic_state      *state;
+	union acpi_generic_state        *state;
 
 
-	PROC_NAME ("Ds_result_push");
+	ACPI_FUNCTION_NAME ("ds_result_push");
 
 
 	state = walk_state->results;
@@ -316,7 +330,7 @@ acpi_ds_result_push (
 		return (AE_AML_INTERNAL);
 	}
 
-	if (state->results.num_results == OBJ_NUM_OPERANDS) {
+	if (state->results.num_results == ACPI_OBJ_NUM_OPERANDS) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"Result stack overflow: Obj=%p State=%p Num=%X\n",
 			object, walk_state, state->results.num_results));
@@ -329,12 +343,11 @@ acpi_ds_result_push (
 		return (AE_BAD_PARAMETER);
 	}
 
-
 	state->results.obj_desc [state->results.num_results] = object;
 	state->results.num_results++;
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Obj=%p [%s] State=%p Num=%X Cur=%X\n",
-		object, object ? acpi_ut_get_type_name (((acpi_operand_object *) object)->common.type) : "NULL",
+		object, object ? acpi_ut_get_object_type_name ((union acpi_operand_object *) object) : "NULL",
 		walk_state, state->results.num_results, walk_state->current_result));
 
 	return (AE_OK);
@@ -343,24 +356,24 @@ acpi_ds_result_push (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_result_stack_push
+ * FUNCTION:    acpi_ds_result_stack_push
  *
  * PARAMETERS:  Object              - Object to push
- *              Walk_state          - Current Walk state
+ *              walk_state          - Current Walk state
  *
  * RETURN:      Status
  *
- * DESCRIPTION:
+ * DESCRIPTION: Push an object onto the walk_state result stack.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ds_result_stack_push (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_generic_state      *state;
+	union acpi_generic_state        *state;
 
-	PROC_NAME ("Ds_result_stack_push");
+	ACPI_FUNCTION_NAME ("ds_result_stack_push");
 
 
 	state = acpi_ut_create_generic_state ();
@@ -380,23 +393,23 @@ acpi_ds_result_stack_push (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_result_stack_pop
+ * FUNCTION:    acpi_ds_result_stack_pop
  *
- * PARAMETERS:  Walk_state          - Current Walk state
+ * PARAMETERS:  walk_state          - Current Walk state
  *
  * RETURN:      Status
  *
- * DESCRIPTION:
+ * DESCRIPTION: Pop an object off of the walk_state result stack.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ds_result_stack_pop (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_generic_state      *state;
+	union acpi_generic_state        *state;
 
-	PROC_NAME ("Ds_result_stack_pop");
+	ACPI_FUNCTION_NAME ("ds_result_stack_pop");
 
 
 	/* Check for stack underflow */
@@ -411,7 +424,7 @@ acpi_ds_result_stack_pop (
 	state = acpi_ut_pop_generic_state (&walk_state->results);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-		"Result=%p Remaining_results=%X State=%p\n",
+		"Result=%p remaining_results=%X State=%p\n",
 		state, state->results.num_results, walk_state));
 
 	acpi_ut_delete_generic_state (state);
@@ -422,9 +435,9 @@ acpi_ds_result_stack_pop (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_obj_stack_delete_all
+ * FUNCTION:    acpi_ds_obj_stack_delete_all
  *
- * PARAMETERS:  Walk_state          - Current Walk state
+ * PARAMETERS:  walk_state          - Current Walk state
  *
  * RETURN:      Status
  *
@@ -435,17 +448,17 @@ acpi_ds_result_stack_pop (
 
 acpi_status
 acpi_ds_obj_stack_delete_all (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	u32                     i;
+	u32                             i;
 
 
-	FUNCTION_TRACE_PTR ("Ds_obj_stack_delete_all", walk_state);
+	ACPI_FUNCTION_TRACE_PTR ("ds_obj_stack_delete_all", walk_state);
 
 
 	/* The stack size is configurable, but fixed */
 
-	for (i = 0; i < OBJ_NUM_OPERANDS; i++) {
+	for (i = 0; i < ACPI_OBJ_NUM_OPERANDS; i++) {
 		if (walk_state->operands[i]) {
 			acpi_ut_remove_reference (walk_state->operands[i]);
 			walk_state->operands[i] = NULL;
@@ -458,10 +471,10 @@ acpi_ds_obj_stack_delete_all (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_obj_stack_push
+ * FUNCTION:    acpi_ds_obj_stack_push
  *
  * PARAMETERS:  Object              - Object to push
- *              Walk_state          - Current Walk state
+ *              walk_state          - Current Walk state
  *
  * RETURN:      Status
  *
@@ -471,15 +484,15 @@ acpi_ds_obj_stack_delete_all (
 
 acpi_status
 acpi_ds_obj_stack_push (
-	void                    *object,
-	acpi_walk_state         *walk_state)
+	void                            *object,
+	struct acpi_walk_state          *walk_state)
 {
-	PROC_NAME ("Ds_obj_stack_push");
+	ACPI_FUNCTION_NAME ("ds_obj_stack_push");
 
 
 	/* Check for stack overflow */
 
-	if (walk_state->num_operands >= OBJ_NUM_OPERANDS) {
+	if (walk_state->num_operands >= ACPI_OBJ_NUM_OPERANDS) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"overflow! Obj=%p State=%p #Ops=%X\n",
 			object, walk_state, walk_state->num_operands));
@@ -492,7 +505,7 @@ acpi_ds_obj_stack_push (
 	walk_state->num_operands++;
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Obj=%p [%s] State=%p #Ops=%X\n",
-			  object, acpi_ut_get_type_name (((acpi_operand_object *) object)->common.type),
+			  object, acpi_ut_get_object_type_name ((union acpi_operand_object *) object),
 			  walk_state, walk_state->num_operands));
 
 	return (AE_OK);
@@ -502,10 +515,10 @@ acpi_ds_obj_stack_push (
 #if 0
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_obj_stack_pop_object
+ * FUNCTION:    acpi_ds_obj_stack_pop_object
  *
- * PARAMETERS:  Pop_count           - Number of objects/entries to pop
- *              Walk_state          - Current Walk state
+ * PARAMETERS:  pop_count           - Number of objects/entries to pop
+ *              walk_state          - Current Walk state
  *
  * RETURN:      Status
  *
@@ -516,10 +529,10 @@ acpi_ds_obj_stack_push (
 
 acpi_status
 acpi_ds_obj_stack_pop_object (
-	acpi_operand_object     **object,
-	acpi_walk_state         *walk_state)
+	union acpi_operand_object       **object,
+	struct acpi_walk_state          *walk_state)
 {
-	PROC_NAME ("Ds_obj_stack_pop_object");
+	ACPI_FUNCTION_NAME ("ds_obj_stack_pop_object");
 
 
 	/* Check for stack underflow */
@@ -552,7 +565,7 @@ acpi_ds_obj_stack_pop_object (
 	walk_state->operands [walk_state->num_operands] = NULL;
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Obj=%p [%s] State=%p #Ops=%X\n",
-			  *object, acpi_ut_get_type_name ((*object)->common.type),
+			  *object, acpi_ut_get_object_type_name (*object),
 			  walk_state, walk_state->num_operands));
 
 	return (AE_OK);
@@ -561,10 +574,10 @@ acpi_ds_obj_stack_pop_object (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_obj_stack_pop
+ * FUNCTION:    acpi_ds_obj_stack_pop
  *
- * PARAMETERS:  Pop_count           - Number of objects/entries to pop
- *              Walk_state          - Current Walk state
+ * PARAMETERS:  pop_count           - Number of objects/entries to pop
+ *              walk_state          - Current Walk state
  *
  * RETURN:      Status
  *
@@ -575,12 +588,12 @@ acpi_ds_obj_stack_pop_object (
 
 acpi_status
 acpi_ds_obj_stack_pop (
-	u32                     pop_count,
-	acpi_walk_state         *walk_state)
+	u32                             pop_count,
+	struct acpi_walk_state          *walk_state)
 {
-	u32                     i;
+	u32                             i;
 
-	PROC_NAME ("Ds_obj_stack_pop");
+	ACPI_FUNCTION_NAME ("ds_obj_stack_pop");
 
 
 	for (i = 0; i < pop_count; i++) {
@@ -608,10 +621,10 @@ acpi_ds_obj_stack_pop (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_obj_stack_pop_and_delete
+ * FUNCTION:    acpi_ds_obj_stack_pop_and_delete
  *
- * PARAMETERS:  Pop_count           - Number of objects/entries to pop
- *              Walk_state          - Current Walk state
+ * PARAMETERS:  pop_count           - Number of objects/entries to pop
+ *              walk_state          - Current Walk state
  *
  * RETURN:      Status
  *
@@ -622,13 +635,13 @@ acpi_ds_obj_stack_pop (
 
 acpi_status
 acpi_ds_obj_stack_pop_and_delete (
-	u32                     pop_count,
-	acpi_walk_state         *walk_state)
+	u32                             pop_count,
+	struct acpi_walk_state          *walk_state)
 {
-	u32                     i;
-	acpi_operand_object     *obj_desc;
+	u32                             i;
+	union acpi_operand_object       *obj_desc;
 
-	PROC_NAME ("Ds_obj_stack_pop_and_delete");
+	ACPI_FUNCTION_NAME ("ds_obj_stack_pop_and_delete");
 
 
 	for (i = 0; i < pop_count; i++) {
@@ -660,11 +673,11 @@ acpi_ds_obj_stack_pop_and_delete (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_obj_stack_get_value
+ * FUNCTION:    acpi_ds_obj_stack_get_value
  *
  * PARAMETERS:  Index               - Stack index whose value is desired.  Based
  *                                    on the top of the stack (index=0 == top)
- *              Walk_state          - Current Walk state
+ *              walk_state          - Current Walk state
  *
  * RETURN:      Status
  *
@@ -675,11 +688,11 @@ acpi_ds_obj_stack_pop_and_delete (
 
 void *
 acpi_ds_obj_stack_get_value (
-	u32                     index,
-	acpi_walk_state         *walk_state)
+	u32                             index,
+	struct acpi_walk_state          *walk_state)
 {
 
-	FUNCTION_TRACE_PTR ("Ds_obj_stack_get_value", walk_state);
+	ACPI_FUNCTION_TRACE_PTR ("ds_obj_stack_get_value", walk_state);
 
 
 	/* Can't do it if the stack is empty */
@@ -694,67 +707,66 @@ acpi_ds_obj_stack_get_value (
 		return_PTR (NULL);
 	}
 
-
-	return_PTR (walk_state->operands[(NATIVE_UINT)(walk_state->num_operands - 1) -
+	return_PTR (walk_state->operands[(acpi_native_uint)(walk_state->num_operands - 1) -
 			  index]);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_get_current_walk_state
+ * FUNCTION:    acpi_ds_get_current_walk_state
  *
- * PARAMETERS:  Walk_list       - Get current active state for this walk list
+ * PARAMETERS:  Thread          - Get current active state for this Thread
  *
  * RETURN:      Pointer to the current walk state
  *
  * DESCRIPTION: Get the walk state that is at the head of the list (the "current"
- *              walk state.
+ *              walk state.)
  *
  ******************************************************************************/
 
-acpi_walk_state *
+struct acpi_walk_state *
 acpi_ds_get_current_walk_state (
-	acpi_walk_list          *walk_list)
+	struct acpi_thread_state        *thread)
 
 {
-	PROC_NAME ("Ds_get_current_walk_state");
-
+	ACPI_FUNCTION_NAME ("ds_get_current_walk_state");
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Ds_get_current_walk_state, =%p\n",
-		walk_list->walk_state));
 
-	if (!walk_list) {
+	if (!thread) {
 		return (NULL);
 	}
 
-	return (walk_list->walk_state);
+	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Current walk_state %p\n",
+		thread->walk_state_list));
+
+	return (thread->walk_state_list);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_push_walk_state
+ * FUNCTION:    acpi_ds_push_walk_state
  *
- * PARAMETERS:  Walk_state      - State to push
- *              Walk_list       - The list that owns the walk stack
+ * PARAMETERS:  walk_state      - State to push
+ *              walk_list       - The list that owns the walk stack
  *
  * RETURN:      None
  *
- * DESCRIPTION: Place the Walk_state at the head of the state list.
+ * DESCRIPTION: Place the walk_state at the head of the state list.
  *
  ******************************************************************************/
 
 void
 acpi_ds_push_walk_state (
-	acpi_walk_state         *walk_state,
-	acpi_walk_list          *walk_list)
+	struct acpi_walk_state          *walk_state,
+	struct acpi_thread_state        *thread)
 {
-	FUNCTION_TRACE ("Ds_push_walk_state");
+	ACPI_FUNCTION_TRACE ("ds_push_walk_state");
 
 
-	walk_state->next    = walk_list->walk_state;
-	walk_list->walk_state = walk_state;
+	walk_state->next      = thread->walk_state_list;
+	thread->walk_state_list = walk_state;
 
 	return_VOID;
 }
@@ -762,11 +774,11 @@ acpi_ds_push_walk_state (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_pop_walk_state
+ * FUNCTION:    acpi_ds_pop_walk_state
  *
- * PARAMETERS:  Walk_list       - The list that owns the walk stack
+ * PARAMETERS:  walk_list       - The list that owns the walk stack
  *
- * RETURN:      A Walk_state object popped from the stack
+ * RETURN:      A walk_state object popped from the stack
  *
  * DESCRIPTION: Remove and return the walkstate object that is at the head of
  *              the walk stack for the given walk list.  NULL indicates that
@@ -774,27 +786,27 @@ acpi_ds_push_walk_state (
  *
  ******************************************************************************/
 
-acpi_walk_state *
+struct acpi_walk_state *
 acpi_ds_pop_walk_state (
-	acpi_walk_list          *walk_list)
+	struct acpi_thread_state        *thread)
 {
-	acpi_walk_state         *walk_state;
+	struct acpi_walk_state          *walk_state;
 
 
-	FUNCTION_TRACE ("Ds_pop_walk_state");
+	ACPI_FUNCTION_TRACE ("ds_pop_walk_state");
 
 
-	walk_state = walk_list->walk_state;
+	walk_state = thread->walk_state_list;
 
 	if (walk_state) {
 		/* Next walk state becomes the current walk state */
 
-		walk_list->walk_state = walk_state->next;
+		thread->walk_state_list = walk_state->next;
 
 		/*
 		 * Don't clear the NEXT field, this serves as an indicator
 		 * that there is a parent WALK STATE
-		 *     Walk_state->Next = NULL;
+		 *     NO: walk_state->Next = NULL;
 		 */
 	}
 
@@ -804,30 +816,30 @@ acpi_ds_pop_walk_state (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_create_walk_state
+ * FUNCTION:    acpi_ds_create_walk_state
  *
  * PARAMETERS:  Origin          - Starting point for this walk
- *              Walk_list       - Owning walk list
+ *              Thread          - Current thread state
  *
  * RETURN:      Pointer to the new walk state.
  *
- * DESCRIPTION: Allocate and initialize a new walk state.  The current walk state
- *              is set to this new state.
+ * DESCRIPTION: Allocate and initialize a new walk state.  The current walk
+ *              state is set to this new state.
  *
  ******************************************************************************/
 
-acpi_walk_state *
+struct acpi_walk_state *
 acpi_ds_create_walk_state (
-	acpi_owner_id           owner_id,
-	acpi_parse_object       *origin,
-	acpi_operand_object     *mth_desc,
-	acpi_walk_list          *walk_list)
+	acpi_owner_id                   owner_id,
+	union acpi_parse_object         *origin,
+	union acpi_operand_object       *mth_desc,
+	struct acpi_thread_state        *thread)
 {
-	acpi_walk_state         *walk_state;
-	acpi_status             status;
+	struct acpi_walk_state          *walk_state;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Ds_create_walk_state");
+	ACPI_FUNCTION_TRACE ("ds_create_walk_state");
 
 
 	walk_state = acpi_ut_acquire_from_cache (ACPI_MEM_LIST_WALK);
@@ -839,11 +851,13 @@ acpi_ds_create_walk_state (
 	walk_state->owner_id        = owner_id;
 	walk_state->origin          = origin;
 	walk_state->method_desc     = mth_desc;
-	walk_state->walk_list       = walk_list;
+	walk_state->thread          = thread;
+
+	walk_state->parser_state.start_op = origin;
 
 	/* Init the method args/local */
 
-#ifndef _ACPI_ASL_COMPILER
+#if (!defined (ACPI_NO_METHOD_EXECUTION) && !defined (ACPI_CONSTANT_EVAL_ONLY))
 	acpi_ds_method_data_init (walk_state);
 #endif
 
@@ -856,20 +870,19 @@ acpi_ds_create_walk_state (
 
 	/* Put the new state at the head of the walk list */
 
-	if (walk_list) {
-		acpi_ds_push_walk_state (walk_state, walk_list);
+	if (thread) {
+		acpi_ds_push_walk_state (walk_state, thread);
 	}
 
 	return_PTR (walk_state);
 }
 
 
-#ifndef _ACPI_ASL_COMPILER
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_init_aml_walk
+ * FUNCTION:    acpi_ds_init_aml_walk
  *
- * PARAMETERS:  Walk_state      - New state to be initialized
+ * PARAMETERS:  walk_state      - New state to be initialized
  *
  * RETURN:      None
  *
@@ -879,20 +892,21 @@ acpi_ds_create_walk_state (
 
 acpi_status
 acpi_ds_init_aml_walk (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op,
-	acpi_namespace_node     *method_node,
-	u8                      *aml_start,
-	u32                     aml_length,
-	acpi_operand_object     **params,
-	acpi_operand_object     **return_obj_desc,
-	u32                     pass_number)
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op,
+	struct acpi_namespace_node      *method_node,
+	u8                              *aml_start,
+	u32                             aml_length,
+	union acpi_operand_object       **params,
+	union acpi_operand_object       **return_obj_desc,
+	u32                             pass_number)
 {
-	acpi_status             status;
-	acpi_parse_state        *parser_state = &walk_state->parser_state;
+	acpi_status                     status;
+	struct acpi_parse_state         *parser_state = &walk_state->parser_state;
+	union acpi_parse_object         *extra_op;
 
 
-	FUNCTION_TRACE ("Ds_init_aml_walk");
+	ACPI_FUNCTION_TRACE ("ds_init_aml_walk");
 
 
 	walk_state->parser_state.aml    =
@@ -900,8 +914,7 @@ acpi_ds_init_aml_walk (
 	walk_state->parser_state.aml_end =
 	walk_state->parser_state.pkg_end = aml_start + aml_length;
 
-	/* The Next_op of the Next_walk will be the beginning of the method */
-	/* TBD: [Restructure] -- obsolete? */
+	/* The next_op of the next_walk will be the beginning of the method */
 
 	walk_state->next_op             = NULL;
 	walk_state->params              = params;
@@ -914,11 +927,10 @@ acpi_ds_init_aml_walk (
 
 	if (method_node) {
 		walk_state->parser_state.start_node = method_node;
-		walk_state->walk_type               = WALK_METHOD;
+		walk_state->walk_type               = ACPI_WALK_METHOD;
 		walk_state->method_node             = method_node;
 		walk_state->method_desc             = acpi_ns_get_attached_object (method_node);
 
-
 		/* Push start scope on scope stack and make it current  */
 
 		status = acpi_ds_scope_stack_push (method_node, ACPI_TYPE_METHOD, walk_state);
@@ -928,13 +940,29 @@ acpi_ds_init_aml_walk (
 
 		/* Init the method arguments */
 
-		acpi_ds_method_data_init_args (params, MTH_NUM_ARGS, walk_state);
+		status = acpi_ds_method_data_init_args (params, ACPI_METHOD_NUM_ARGS, walk_state);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
 	}
-
 	else {
-		/* Setup the current scope */
+		/*
+		 * Setup the current scope.
+		 * Find a Named Op that has a namespace node associated with it.
+		 * search upwards from this Op.  Current scope is the first
+		 * Op with a namespace node.
+		 */
+		extra_op = parser_state->start_op;
+		while (extra_op && !extra_op->common.node) {
+			extra_op = extra_op->common.parent;
+		}
+		if (!extra_op) {
+			parser_state->start_node = NULL;
+		}
+		else {
+			parser_state->start_node = extra_op->common.node;
+		}
 
-		parser_state->start_node = parser_state->start_op->node;
 		if (parser_state->start_node) {
 			/* Push start scope on scope stack and make it current  */
 
@@ -946,18 +974,16 @@ acpi_ds_init_aml_walk (
 		}
 	}
 
-	acpi_ds_init_callbacks (walk_state, pass_number);
-
-	return_ACPI_STATUS (AE_OK);
+	status = acpi_ds_init_callbacks (walk_state, pass_number);
+	return_ACPI_STATUS (status);
 }
-#endif
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ds_delete_walk_state
+ * FUNCTION:    acpi_ds_delete_walk_state
  *
- * PARAMETERS:  Walk_state      - State to delete
+ * PARAMETERS:  walk_state      - State to delete
  *
  * RETURN:      Status
  *
@@ -967,12 +993,12 @@ acpi_ds_init_aml_walk (
 
 void
 acpi_ds_delete_walk_state (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_generic_state      *state;
+	union acpi_generic_state        *state;
 
 
-	FUNCTION_TRACE_PTR ("Ds_delete_walk_state", walk_state);
+	ACPI_FUNCTION_TRACE_PTR ("ds_delete_walk_state", walk_state);
 
 
 	if (!walk_state) {
@@ -984,7 +1010,6 @@ acpi_ds_delete_walk_state (
 		return;
 	}
 
-
 	if (walk_state->parser_state.scope) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "%p walk still has a scope list\n", walk_state));
 	}
@@ -1023,7 +1048,7 @@ acpi_ds_delete_walk_state (
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_ds_delete_walk_state_cache
+ * FUNCTION:    acpi_ds_delete_walk_state_cache
  *
  * PARAMETERS:  None
  *
@@ -1038,7 +1063,7 @@ void
 acpi_ds_delete_walk_state_cache (
 	void)
 {
-	FUNCTION_TRACE ("Ds_delete_walk_state_cache");
+	ACPI_FUNCTION_TRACE ("ds_delete_walk_state_cache");
 
 
 	acpi_ut_delete_generic_cache (ACPI_MEM_LIST_WALK);
diff -urNp linux-5400/drivers/acpi/driver.c linux-5410/drivers/acpi/driver.c
--- linux-5400/drivers/acpi/driver.c
+++ linux-5410/drivers/acpi/driver.c
@@ -1,217 +0,0 @@
-/*
- *  driver.c - ACPI driver
- *
- *  Copyright (C) 2000 Andrew Henroid
- *  Copyright (C) 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-/*
- * Changes
- * David Woodhouse <dwmw2@redhat.com> 2000-12-6
- * - Fix interruptible_sleep_on() races
- * Andrew Grover <andrew.grover@intel.com> 2001-2-28
- * - Major revamping
- * Peter Breuer <ptb@it.uc3m.es> 2001-5-20
- * - parse boot time params.
- */
-
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/slab.h>
-#include <linux/proc_fs.h>
-#include <linux/sysctl.h>
-#include <linux/pm.h>
-#include <linux/acpi.h>
-#include <asm/uaccess.h>
-#include "acpi.h"
-
-
-#define _COMPONENT	OS_DEPENDENT
-	MODULE_NAME	("driver")
-
-FADT_DESCRIPTOR acpi_fadt;
-
-static int acpi_disabled = 0;
-
-enum acpi_blacklist_predicates
-{
-	all_versions,
-	less_than_or_equal,
-	equal,
-	greater_than_or_equal,
-};
-
-struct acpi_blacklist_item
-{
-	char oem_id[7];
-	char oem_table_id[9];
-	u32  oem_revision;
-	enum acpi_blacklist_predicates oem_revision_predicate;
-};
-
-/*
- * Currently, this blacklists based on items in the FADT. We may want to
- * expand this to using other ACPI tables in the future, too.
- */
-static struct acpi_blacklist_item acpi_blacklist[] __initdata = 
-{
-	{"TOSHIB", "750     ", 0x970814, less_than_or_equal}, /* Portege 7020, BIOS 8.10 */
-	{""}
-};
-
-int
-acpi_blacklisted(FADT_DESCRIPTOR *fadt)
-{
-	int i = 0;
-
-	while (acpi_blacklist[i].oem_id[0] != '\0')
-	{
-		if (strncmp(acpi_blacklist[i].oem_id, fadt->header.oem_id, 6)) {
-			i++;
-			continue;
-		}
-
-		if (strncmp(acpi_blacklist[i].oem_table_id, fadt->header.oem_table_id, 8)) {
-			i++;
-			continue;
-		}
-
-		if (acpi_blacklist[i].oem_revision_predicate == all_versions)
-			return TRUE;
-
-		if (acpi_blacklist[i].oem_revision_predicate == less_than_or_equal
-		    && fadt->header.oem_revision <= acpi_blacklist[i].oem_revision)
-			return TRUE;
-
-		if (acpi_blacklist[i].oem_revision_predicate == greater_than_or_equal
-		    && fadt->header.oem_revision >= acpi_blacklist[i].oem_revision)
-			return TRUE;
-
-		if (acpi_blacklist[i].oem_revision_predicate == equal
-		    && fadt->header.oem_revision == acpi_blacklist[i].oem_revision)
-			return TRUE;
-
-		i++;
-	}
-
-	return FALSE;
-}
-
-/*
- * Start the interpreter
- */
-int
-acpi_init(void)
-{
-	acpi_buffer		buffer;
-	acpi_system_info	sys_info;
-
-	if (PM_IS_ACTIVE()) {
-		printk(KERN_NOTICE "ACPI: APM is already active, exiting\n");
-		return -ENODEV;
-	}
-
-	if (acpi_disabled) {
-		printk(KERN_NOTICE "ACPI: disabled by cmdline, exiting\n");
-		return -ENODEV;
-	}
-
-	if (!ACPI_SUCCESS(acpi_initialize_subsystem())) {
-		printk(KERN_ERR "ACPI: Driver initialization failed\n");
-		return -ENODEV;
-	}
-
-	/* from this point on, on error we must call acpi_terminate() */
-	if (!ACPI_SUCCESS(acpi_load_tables())) {
-		printk(KERN_ERR "ACPI: System description table load failed\n");
-		acpi_terminate();
-		return -ENODEV;
-	}
-
-	/* get a separate copy of the FADT for use by other drivers */
-	memset(&acpi_fadt, 0, sizeof(acpi_fadt));
-	buffer.pointer = &acpi_fadt;
-	buffer.length = sizeof(acpi_fadt);
-
-	if (!ACPI_SUCCESS(acpi_get_table(ACPI_TABLE_FADT, 1, &buffer))) {
-		printk(KERN_ERR "ACPI: Could not get FADT\n");
-		acpi_terminate();
-		return -ENODEV;
-	}
-
-	if (acpi_blacklisted(&acpi_fadt)) {
-		printk(KERN_ERR "ACPI: On blacklist -- BIOS not fully ACPI compliant\n");
-		acpi_terminate();
-		return -ENODEV;
-	}
-
-	buffer.length  = sizeof(sys_info);
-	buffer.pointer = &sys_info;
-
-	if (!ACPI_SUCCESS (acpi_get_system_info(&buffer))) {
-		printk(KERN_ERR "ACPI: Could not get system info\n");
-		acpi_terminate();
-		return -ENODEV;
-	}
-
-	printk(KERN_INFO "ACPI: Core Subsystem version [%x]\n", sys_info.acpi_ca_version);
-
-	if (!ACPI_SUCCESS(acpi_enable_subsystem(ACPI_FULL_INITIALIZATION))) {
-		printk(KERN_ERR "ACPI: Subsystem enable failed\n");
-		acpi_terminate();
-		return -ENODEV;
-	}
-
-	printk(KERN_INFO "ACPI: Subsystem enabled\n");
-
-	pm_active = 1;
-
-	return 0;
-}
-
-/*
- * Terminate the interpreter
- */
-void
-acpi_exit(void)
-{
-	acpi_terminate();
-
-	pm_active = 0;
-
-	printk(KERN_ERR "ACPI: Subsystem disabled\n");
-}
-
-module_init(acpi_init);
-module_exit(acpi_exit);
-
-#ifndef MODULE
-static int __init acpi_setup(char *str) {
-	while (str && *str) {
-	if (strncmp(str, "off", 3) == 0)
-		acpi_disabled = 1;
-	str = strchr(str, ',');
-	if (str)
-		str += strspn(str, ", \t");
-	}
-	return 1;
-}
-
-__setup("acpi=", acpi_setup);
-#endif
diff -urNp linux-5400/drivers/acpi/ec.c linux-5410/drivers/acpi/ec.c
--- linux-5400/drivers/acpi/ec.c
+++ linux-5410/drivers/acpi/ec.c
@@ -0,0 +1,859 @@
+/*
+ *  acpi_ec.c - ACPI Embedded Controller Driver ($Revision: 36 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/compatmac.h>
+#include <linux/proc_fs.h>
+#include <asm/io.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+
+#define _COMPONENT		ACPI_EC_COMPONENT
+ACPI_MODULE_NAME		("acpi_ec")
+
+#define PREFIX			"ACPI: "
+
+
+#define ACPI_EC_FLAG_OBF	0x01	/* Output buffer full */
+#define ACPI_EC_FLAG_IBF	0x02	/* Input buffer full */
+#define ACPI_EC_FLAG_SCI	0x20	/* EC-SCI occurred */
+
+#define ACPI_EC_EVENT_OBF	0x01	/* Output buffer full */
+#define ACPI_EC_EVENT_IBE	0x02	/* Input buffer empty */
+
+#define ACPI_EC_UDELAY		100	/* Poll @ 100us increments */
+#define ACPI_EC_UDELAY_COUNT	1000	/* Wait 10ms max. during EC ops */
+#define ACPI_EC_UDELAY_GLK	1000	/* Wait 1ms max. to get global lock */
+
+#define ACPI_EC_COMMAND_READ	0x80
+#define ACPI_EC_COMMAND_WRITE	0x81
+#define ACPI_EC_COMMAND_QUERY	0x84
+
+static int acpi_ec_add (struct acpi_device *device);
+static int acpi_ec_remove (struct acpi_device *device, int type);
+static int acpi_ec_start (struct acpi_device *device);
+static int acpi_ec_stop (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_ec_driver = {
+	.name =		ACPI_EC_DRIVER_NAME,
+	.class =	ACPI_EC_CLASS,
+	.ids =		ACPI_EC_HID,
+	.ops =		{
+				.add =		acpi_ec_add,
+				.remove =	acpi_ec_remove,
+				.start =	acpi_ec_start,
+				.stop =		acpi_ec_stop,
+			},
+};
+
+struct acpi_ec {
+	acpi_handle			handle;
+	unsigned long			uid;
+	unsigned long			gpe_bit;
+	struct acpi_generic_address	status_addr;
+	struct acpi_generic_address	command_addr;
+	struct acpi_generic_address	data_addr;
+	unsigned long			global_lock;
+	spinlock_t			lock;
+};
+
+/* If we find an EC via the ECDT, we need to keep a ptr to its context */
+static struct acpi_ec	*ec_ecdt;
+
+/* External interfaces use first EC only, so remember */
+static struct acpi_device *first_ec;
+
+/* --------------------------------------------------------------------------
+                             Transaction Management
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_ec_wait (
+	struct acpi_ec		*ec,
+	u8			event)
+{
+	u32			acpi_ec_status = 0;
+	u32			i = ACPI_EC_UDELAY_COUNT;
+
+	if (!ec)
+		return -EINVAL;
+
+	/* Poll the EC status register waiting for the event to occur. */
+	switch (event) {
+	case ACPI_EC_EVENT_OBF:
+		do {
+			acpi_hw_low_level_read(8, &acpi_ec_status, &ec->status_addr);
+			if (acpi_ec_status & ACPI_EC_FLAG_OBF)
+				return 0;
+			udelay(ACPI_EC_UDELAY);
+		} while (--i>0);
+		break;
+	case ACPI_EC_EVENT_IBE:
+		do {
+			acpi_hw_low_level_read(8, &acpi_ec_status, &ec->status_addr);
+			if (!(acpi_ec_status & ACPI_EC_FLAG_IBF))
+				return 0;
+			udelay(ACPI_EC_UDELAY);
+		} while (--i>0);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return -ETIME;
+}
+
+
+static int
+acpi_ec_read (
+	struct acpi_ec		*ec,
+	u8			address,
+	u32			*data)
+{
+	acpi_status		status = AE_OK;
+	int			result = 0;
+	unsigned long		flags = 0;
+	u32			glk = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_read");
+
+	if (!ec || !data)
+		return_VALUE(-EINVAL);
+
+	*data = 0;
+
+	if (ec->global_lock) {
+		status = acpi_acquire_global_lock(ACPI_EC_UDELAY_GLK, &glk);
+		if (ACPI_FAILURE(status))
+			return_VALUE(-ENODEV);
+	}
+	
+	spin_lock_irqsave(&ec->lock, flags);
+
+	acpi_hw_low_level_write(8, ACPI_EC_COMMAND_READ, &ec->command_addr);
+	result = acpi_ec_wait(ec, ACPI_EC_EVENT_IBE);
+	if (result)
+		goto end;
+
+	acpi_hw_low_level_write(8, address, &ec->data_addr);
+	result = acpi_ec_wait(ec, ACPI_EC_EVENT_OBF);
+	if (result)
+		goto end;
+
+
+	acpi_hw_low_level_read(8, data, &ec->data_addr);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Read [%02x] from address [%02x]\n",
+		*data, address));
+
+end:
+	spin_unlock_irqrestore(&ec->lock, flags);
+
+	if (ec->global_lock)
+		acpi_release_global_lock(glk);
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_ec_write (
+	struct acpi_ec		*ec,
+	u8			address,
+	u8			data)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	unsigned long		flags = 0;
+	u32			glk = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_write");
+
+	if (!ec)
+		return_VALUE(-EINVAL);
+
+	if (ec->global_lock) {
+		status = acpi_acquire_global_lock(ACPI_EC_UDELAY_GLK, &glk);
+		if (ACPI_FAILURE(status))
+			return_VALUE(-ENODEV);
+	}
+
+	spin_lock_irqsave(&ec->lock, flags);
+
+	acpi_hw_low_level_write(8, ACPI_EC_COMMAND_WRITE, &ec->command_addr);
+	result = acpi_ec_wait(ec, ACPI_EC_EVENT_IBE);
+	if (result)
+		goto end;
+
+	acpi_hw_low_level_write(8, address, &ec->data_addr);
+	result = acpi_ec_wait(ec, ACPI_EC_EVENT_IBE);
+	if (result)
+		goto end;
+
+	acpi_hw_low_level_write(8, data, &ec->data_addr);
+	result = acpi_ec_wait(ec, ACPI_EC_EVENT_IBE);
+	if (result)
+		goto end;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Wrote [%02x] to address [%02x]\n",
+		data, address));
+
+end:
+	spin_unlock_irqrestore(&ec->lock, flags);
+
+	if (ec->global_lock)
+		acpi_release_global_lock(glk);
+
+	return_VALUE(result);
+}
+
+/*
+ * Externally callable EC access functions. For now, assume 1 EC only
+ */
+int
+ec_read(u8 addr, u8 *val)
+{
+	struct acpi_ec *ec;
+	int err;
+	u32 temp_data;
+
+	if (!first_ec)
+		return -ENODEV;
+
+	ec = acpi_driver_data(first_ec);
+
+	err = acpi_ec_read(ec, addr, &temp_data);
+
+	if (!err) {
+		*val = temp_data;
+		return 0;
+	}
+	else
+		return err;
+}
+
+int
+ec_write(u8 addr, u8 val)
+{
+	struct acpi_ec *ec;
+	int err;
+
+	if (!first_ec)
+		return -ENODEV;
+
+	ec = acpi_driver_data(first_ec);
+
+	err = acpi_ec_write(ec, addr, val);
+
+	return err;
+}
+
+
+static int
+acpi_ec_query (
+	struct acpi_ec		*ec,
+	u32			*data)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	unsigned long		flags = 0;
+	u32			glk = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_query");
+
+	if (!ec || !data)
+		return_VALUE(-EINVAL);
+
+	*data = 0;
+
+	if (ec->global_lock) {
+		status = acpi_acquire_global_lock(ACPI_EC_UDELAY_GLK, &glk);
+		if (ACPI_FAILURE(status))
+			return_VALUE(-ENODEV);
+	}
+
+	/*
+	 * Query the EC to find out which _Qxx method we need to evaluate.
+	 * Note that successful completion of the query causes the ACPI_EC_SCI
+	 * bit to be cleared (and thus clearing the interrupt source).
+	 */
+	spin_lock_irqsave(&ec->lock, flags);
+
+	acpi_hw_low_level_write(8, ACPI_EC_COMMAND_QUERY, &ec->command_addr);
+	result = acpi_ec_wait(ec, ACPI_EC_EVENT_OBF);
+	if (result)
+		goto end;
+	
+	acpi_hw_low_level_read(8, data, &ec->data_addr);
+	if (!*data)
+		result = -ENODATA;
+
+end:
+	spin_unlock_irqrestore(&ec->lock, flags);
+
+	if (ec->global_lock)
+		acpi_release_global_lock(glk);
+
+	return_VALUE(result);
+}
+
+
+/* --------------------------------------------------------------------------
+                                Event Management
+   -------------------------------------------------------------------------- */
+
+struct acpi_ec_query_data {
+	acpi_handle		handle;
+	u8			data;
+};
+
+static void
+acpi_ec_gpe_query (
+	void			*ec_cxt)
+{
+	struct acpi_ec		*ec = (struct acpi_ec *) ec_cxt;
+	u32			value = 0;
+	unsigned long		flags = 0;
+	static char		object_name[5] = {'_','Q','0','0','\0'};
+	const char		hex[] = {'0','1','2','3','4','5','6','7',
+				         '8','9','A','B','C','D','E','F'};
+
+	ACPI_FUNCTION_TRACE("acpi_ec_gpe_query");
+
+	if (!ec_cxt)
+		goto end;	
+
+	spin_lock_irqsave(&ec->lock, flags);
+	acpi_hw_low_level_read(8, &value, &ec->command_addr);
+	spin_unlock_irqrestore(&ec->lock, flags);
+
+	/* TBD: Implement asynch events!
+	 * NOTE: All we care about are EC-SCI's.  Other EC events are
+	 * handled via polling (yuck!).  This is because some systems
+	 * treat EC-SCIs as level (versus EDGE!) triggered, preventing
+	 *  a purely interrupt-driven approach (grumble, grumble).
+	 */
+	if (!(value & ACPI_EC_FLAG_SCI))
+		goto end;
+
+	if (acpi_ec_query(ec, &value))
+		goto end;
+	
+	object_name[2] = hex[((value >> 4) & 0x0F)];
+	object_name[3] = hex[(value & 0x0F)];
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Evaluating %s\n", object_name));
+
+	acpi_evaluate_object(ec->handle, object_name, NULL, NULL);
+
+end:
+	acpi_enable_gpe(NULL, ec->gpe_bit, ACPI_NOT_ISR);
+}
+
+static void
+acpi_ec_gpe_handler (
+	void			*data)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_ec		*ec = (struct acpi_ec *) data;
+
+	if (!ec)
+		return;
+
+	acpi_disable_gpe(NULL, ec->gpe_bit, ACPI_ISR);
+
+	status = acpi_os_queue_for_execution(OSD_PRIORITY_GPE,
+		acpi_ec_gpe_query, ec);
+}
+
+/* --------------------------------------------------------------------------
+                             Address Space Management
+   -------------------------------------------------------------------------- */
+
+static acpi_status
+acpi_ec_space_setup (
+	acpi_handle		region_handle,
+	u32			function,
+	void			*handler_context,
+	void			**return_context)
+{
+	/*
+	 * The EC object is in the handler context and is needed
+	 * when calling the acpi_ec_space_handler.
+	 */
+	*return_context = handler_context;
+
+	return AE_OK;
+}
+
+
+static acpi_status
+acpi_ec_space_handler (
+	u32			function,
+	acpi_physical_address	address,
+	u32			bit_width,
+	acpi_integer		*value,
+	void			*handler_context,
+	void			*region_context)
+{
+	int			result = 0;
+	struct acpi_ec		*ec = NULL;
+	u32			temp = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_space_handler");
+
+	if ((address > 0xFF) || (bit_width != 8) || !value || !handler_context)
+		return_VALUE(AE_BAD_PARAMETER);
+
+	ec = (struct acpi_ec *) handler_context;
+
+	switch (function) {
+	case ACPI_READ:
+		result = acpi_ec_read(ec, (u8) address, &temp);
+		*value = (acpi_integer) temp;
+		break;
+	case ACPI_WRITE:
+		result = acpi_ec_write(ec, (u8) address, (u8) *value);
+		break;
+	default:
+		result = -EINVAL;
+		break;
+	}
+
+	switch (result) {
+	case -EINVAL:
+		return_VALUE(AE_BAD_PARAMETER);
+		break;
+	case -ENODEV:
+		return_VALUE(AE_NOT_FOUND);
+		break;
+	case -ETIME:
+		return_VALUE(AE_TIME);
+		break;
+	default:
+		return_VALUE(AE_OK);
+	}
+
+}
+
+
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+struct proc_dir_entry		*acpi_ec_dir = NULL;
+
+
+static int
+acpi_ec_read_info (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_ec		*ec = (struct acpi_ec *) data;
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_read_info");
+
+	if (!ec || (off != 0))
+		goto end;
+
+	p += sprintf(p, "gpe bit:                 0x%02x\n",
+		(u32) ec->gpe_bit);
+	p += sprintf(p, "ports:                   0x%02x, 0x%02x\n",
+		(u32) ec->status_addr.address, (u32) ec->data_addr.address);
+	p += sprintf(p, "use global lock:         %s\n",
+		ec->global_lock?"yes":"no");
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_ec_add_fs (
+	struct acpi_device	*device)
+{
+	struct proc_dir_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_add_fs");
+
+	if (!acpi_device_dir(device)) {
+		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
+			acpi_ec_dir);
+		if (!acpi_device_dir(device))
+			return_VALUE(-ENODEV);
+	}
+
+	entry = create_proc_read_entry(ACPI_EC_FILE_INFO, S_IRUGO,
+		acpi_device_dir(device), acpi_ec_read_info,
+		acpi_driver_data(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+			"Unable to create '%s' fs entry\n",
+			ACPI_EC_FILE_INFO));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_ec_remove_fs (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_ec_remove_fs");
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                               Driver Interface
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_ec_add (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_ec		*ec = NULL;
+	unsigned long		uid;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	ec = kmalloc(sizeof(struct acpi_ec), GFP_KERNEL);
+	if (!ec)
+		return_VALUE(-ENOMEM);
+	memset(ec, 0, sizeof(struct acpi_ec));
+
+	ec->handle = device->handle;
+	ec->uid = -1;
+	ec->lock = SPIN_LOCK_UNLOCKED;
+	sprintf(acpi_device_name(device), "%s", ACPI_EC_DEVICE_NAME);
+	sprintf(acpi_device_class(device), "%s", ACPI_EC_CLASS);
+	acpi_driver_data(device) = ec;
+
+	/* Use the global lock for all EC transactions? */
+	acpi_evaluate_integer(ec->handle, "_GLK", NULL, &ec->global_lock);
+
+	/* If our UID matches the UID for the ECDT-enumerated EC,
+	   we now have the *real* EC info, so kill the makeshift one.*/
+	acpi_evaluate_integer(ec->handle, "_UID", NULL, &uid);
+	if (ec_ecdt && ec_ecdt->uid == uid) {
+		acpi_remove_address_space_handler(ACPI_ROOT_OBJECT,
+			ACPI_ADR_SPACE_EC, &acpi_ec_space_handler);
+	
+		acpi_remove_gpe_handler(NULL, ec_ecdt->gpe_bit, &acpi_ec_gpe_handler);
+
+		kfree(ec_ecdt);
+	}
+
+	/* Get GPE bit assignment (EC events). */
+	/* TODO: Add support for _GPE returning a package */
+	status = acpi_evaluate_integer(ec->handle, "_GPE", NULL, &ec->gpe_bit);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error obtaining GPE bit assignment\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	result = acpi_ec_add_fs(device);
+	if (result)
+		goto end;
+
+	printk(KERN_INFO PREFIX "%s [%s] (gpe %d)\n",
+		acpi_device_name(device), acpi_device_bid(device),
+		(u32) ec->gpe_bit);
+
+	if (!first_ec)
+		first_ec = device;
+
+end:
+	if (result)
+		kfree(ec);
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_ec_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	struct acpi_ec		*ec = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_remove");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	ec = acpi_driver_data(device);
+
+	acpi_ec_remove_fs(device);
+
+	kfree(ec);
+
+	return_VALUE(0);
+}
+
+
+static acpi_status
+acpi_ec_io_ports (
+	struct acpi_resource	*resource,
+	void			*context)
+{
+	struct acpi_ec		*ec = (struct acpi_ec *) context;
+	struct acpi_generic_address *addr;
+
+	if (resource->id != ACPI_RSTYPE_IO) {
+		return AE_OK;
+	}
+
+	/*
+	 * The first address region returned is the data port, and
+	 * the second address region returned is the status/command
+	 * port.
+	 */
+	if (ec->data_addr.register_bit_width == 0) {
+		addr = &ec->data_addr;
+	} else if (ec->command_addr.register_bit_width == 0) {
+		addr = &ec->command_addr;
+	} else {
+		return AE_CTRL_TERMINATE;
+	}
+
+	addr->address_space_id = ACPI_ADR_SPACE_SYSTEM_IO;
+	addr->register_bit_width = 8;
+	addr->register_bit_offset = 0;
+	addr->address = resource->data.io.min_base_address;
+
+	return AE_OK;
+}
+
+
+static int
+acpi_ec_start (
+	struct acpi_device	*device)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_ec		*ec = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_start");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	ec = acpi_driver_data(device);
+
+	if (!ec)
+		return_VALUE(-EINVAL);
+
+	/*
+	 * Get I/O port addresses. Convert to GAS format.
+	 */
+	status = acpi_walk_resources(ec->handle, METHOD_NAME__CRS,
+		acpi_ec_io_ports, ec);
+	if (ACPI_FAILURE(status) || ec->command_addr.register_bit_width == 0) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error getting I/O port addresses"));
+		return_VALUE(-ENODEV);
+	}
+
+	ec->status_addr = ec->command_addr;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "gpe=0x%02x, ports=0x%2x,0x%2x\n",
+		(u32) ec->gpe_bit, (u32) ec->command_addr.address,
+		(u32) ec->data_addr.address));
+
+	/*
+	 * Install GPE handler
+	 */
+	status = acpi_install_gpe_handler(NULL, ec->gpe_bit,
+		ACPI_EVENT_EDGE_TRIGGERED, &acpi_ec_gpe_handler, ec);
+	if (ACPI_FAILURE(status)) {
+		return_VALUE(-ENODEV);
+	}
+
+	status = acpi_install_address_space_handler (ec->handle,
+			ACPI_ADR_SPACE_EC, &acpi_ec_space_handler,
+			&acpi_ec_space_setup, ec);
+	if (ACPI_FAILURE(status)) {
+		acpi_remove_gpe_handler(NULL, ec->gpe_bit, &acpi_ec_gpe_handler);
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(AE_OK);
+}
+
+
+static int
+acpi_ec_stop (
+	struct acpi_device	*device,
+	int			type)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_ec		*ec = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_stop");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	ec = acpi_driver_data(device);
+
+	status = acpi_remove_address_space_handler(ec->handle,
+		ACPI_ADR_SPACE_EC, &acpi_ec_space_handler);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	status = acpi_remove_gpe_handler(NULL, ec->gpe_bit, &acpi_ec_gpe_handler);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	return_VALUE(0);
+}
+
+
+int __init
+acpi_ec_ecdt_probe (void)
+{
+	acpi_status		status;
+	struct acpi_table_ecdt 	*ecdt_ptr;
+
+	status = acpi_get_firmware_table("ECDT", 1, ACPI_LOGICAL_ADDRESSING, 
+		(struct acpi_table_header **) &ecdt_ptr);
+	if (ACPI_FAILURE(status))
+		return 0;
+
+	printk(KERN_INFO PREFIX "Found ECDT\n");
+
+	 /*
+	 * Generate a temporary ec context to use until the namespace is scanned
+	 */
+	ec_ecdt = kmalloc(sizeof(struct acpi_ec), GFP_KERNEL);
+	if (!ec_ecdt)
+		return -ENOMEM;
+	memset(ec_ecdt, 0, sizeof(struct acpi_ec));
+
+	ec_ecdt->command_addr = ecdt_ptr->ec_control;
+	ec_ecdt->status_addr = ecdt_ptr->ec_control;
+	ec_ecdt->data_addr = ecdt_ptr->ec_data;
+	ec_ecdt->gpe_bit = ecdt_ptr->gpe_bit;
+	ec_ecdt->lock = SPIN_LOCK_UNLOCKED;
+	/* use the GL just to be safe */
+	ec_ecdt->global_lock = TRUE;
+	ec_ecdt->uid = ecdt_ptr->uid;
+
+	status = acpi_get_handle(NULL, ecdt_ptr->ec_id, &ec_ecdt->handle);
+	if (ACPI_FAILURE(status)) {
+		goto error;
+	}
+
+	/*
+	 * Install GPE handler
+	 */
+	status = acpi_install_gpe_handler(NULL, ec_ecdt->gpe_bit,
+		ACPI_EVENT_EDGE_TRIGGERED, &acpi_ec_gpe_handler,
+		ec_ecdt);
+	if (ACPI_FAILURE(status)) {
+		goto error;
+	}
+
+	status = acpi_install_address_space_handler (ACPI_ROOT_OBJECT,
+			ACPI_ADR_SPACE_EC, &acpi_ec_space_handler,
+			&acpi_ec_space_setup, ec_ecdt);
+	if (ACPI_FAILURE(status)) {
+		acpi_remove_gpe_handler(NULL, ec_ecdt->gpe_bit,
+			&acpi_ec_gpe_handler);
+		goto error;
+	}
+
+	return 0;
+
+error:
+	printk(KERN_ERR PREFIX "Could not use ECDT\n");
+	kfree(ec_ecdt);
+	ec_ecdt = NULL;
+
+	return -ENODEV;
+}
+
+
+int __init
+acpi_ec_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_init");
+
+	acpi_ec_dir = proc_mkdir(ACPI_EC_CLASS, acpi_root_dir);
+	if (!acpi_ec_dir)
+		return_VALUE(-ENODEV);
+
+	result = acpi_bus_register_driver(&acpi_ec_driver);
+	if (result < 0) {
+		remove_proc_entry(ACPI_EC_CLASS, acpi_root_dir);
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+
+/* EC can't be unloaded atm, so don't compile these */
+#if 0
+void __exit
+acpi_ec_exit (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_ec_exit");
+
+	acpi_bus_unregister_driver(&acpi_ec_driver);
+
+	remove_proc_entry(ACPI_EC_CLASS, acpi_root_dir);
+
+	return_VOID;
+}
+#endif /* 0 */
+
diff -urNp linux-5400/drivers/acpi/events/Makefile linux-5410/drivers/acpi/events/Makefile
--- linux-5400/drivers/acpi/events/Makefile
+++ linux-5410/drivers/acpi/events/Makefile
@@ -1,11 +1,10 @@
 #
 # Makefile for all Linux ACPI interpreter subdirectories
-# EXCEPT for the ospm directory
 #
 
 O_TARGET := $(notdir $(CURDIR)).o
 
-obj-$(CONFIG_ACPI) := $(patsubst %.c,%.o,$(wildcard *.c))
+obj-$(CONFIG_ACPI_INTERPRETER) := $(patsubst %.c,%.o,$(wildcard *.c))
 
 EXTRA_CFLAGS += $(ACPI_CFLAGS)
 
diff -urNp linux-5400/drivers/acpi/events/evevent.c linux-5410/drivers/acpi/events/evevent.c
--- linux-5400/drivers/acpi/events/evevent.c
+++ linux-5410/drivers/acpi/events/evevent.c
@@ -1,49 +1,62 @@
 /******************************************************************************
  *
- * Module Name: evevent - Fixed and General Purpose Acpi_event
- *                          handling and dispatch
- *              $Revision: 51 $
+ * Module Name: evevent - Fixed Event handling and dispatch
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#include "acpi.h"
-#include "achware.h"
-#include "acevents.h"
-#include "acnamesp.h"
+#include <acpi/acpi.h>
+#include <acpi/acevents.h>
 
 #define _COMPONENT          ACPI_EVENTS
-	 MODULE_NAME         ("evevent")
+	 ACPI_MODULE_NAME    ("evevent")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_initialize
+ * FUNCTION:    acpi_ev_initialize
  *
  * PARAMETERS:  None
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Ensures that the system control interrupt (SCI) is properly
- *              configured, disables SCI event sources, installs the SCI
- *              handler
+ * DESCRIPTION: Initialize global data structures for events.
  *
  ******************************************************************************/
 
@@ -51,10 +64,10 @@ acpi_status
 acpi_ev_initialize (
 	void)
 {
-	acpi_status             status;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Ev_initialize");
+	ACPI_FUNCTION_TRACE ("ev_initialize");
 
 
 	/* Make sure we have ACPI tables */
@@ -64,48 +77,60 @@ acpi_ev_initialize (
 		return_ACPI_STATUS (AE_NO_ACPI_TABLES);
 	}
 
-
-	/* Make sure the BIOS supports ACPI mode */
-
-	if (SYS_MODE_LEGACY == acpi_hw_get_mode_capabilities()) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "ACPI Mode is not supported!\n"));
-		return_ACPI_STATUS (AE_ERROR);
-	}
-
-
-	acpi_gbl_original_mode = acpi_hw_get_mode();
-
 	/*
-	 * Initialize the Fixed and General Purpose Acpi_events prior. This is
-	 * done prior to enabling SCIs to prevent interrupts from occuring
-	 * before handers are installed.
+	 * Initialize the Fixed and General Purpose Events. This is
+	 * done prior to enabling SCIs to prevent interrupts from
+	 * occurring before handers are installed.
 	 */
 	status = acpi_ev_fixed_event_initialize ();
 	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_FATAL, "Unable to initialize fixed events.\n"));
+		ACPI_REPORT_ERROR ((
+				"Unable to initialize fixed events, %s\n",
+				acpi_format_exception (status)));
 		return_ACPI_STATUS (status);
 	}
 
 	status = acpi_ev_gpe_initialize ();
 	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_FATAL, "Unable to initialize general purpose events.\n"));
+		ACPI_REPORT_ERROR ((
+				"Unable to initialize general purpose events, %s\n",
+				acpi_format_exception (status)));
 		return_ACPI_STATUS (status);
 	}
 
-	/* Install the SCI handler */
+	return_ACPI_STATUS (status);
+}
 
-	status = acpi_ev_install_sci_handler ();
-	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_FATAL, "Unable to install System Control Interrupt Handler\n"));
-		return_ACPI_STATUS (status);
-	}
 
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_handler_initialize
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install interrupt handlers for the SCI and Global Lock
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_handler_initialize (
+	void)
+{
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE ("ev_handler_initialize");
 
-	/* Install handlers for control method GPE handlers (_Lxx, _Exx) */
 
-	status = acpi_ev_init_gpe_control_methods ();
+	/* Install the SCI handler */
+
+	status = acpi_ev_install_sci_handler ();
 	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_FATAL, "Unable to initialize Gpe control methods\n"));
+		ACPI_REPORT_ERROR ((
+				"Unable to install System Control Interrupt Handler, %s\n",
+				acpi_format_exception (status)));
 		return_ACPI_STATUS (status);
 	}
 
@@ -113,44 +138,55 @@ acpi_ev_initialize (
 
 	status = acpi_ev_init_global_lock_handler ();
 	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_FATAL, "Unable to initialize Global Lock handler\n"));
+		ACPI_REPORT_ERROR ((
+				"Unable to initialize Global Lock handler, %s\n",
+				acpi_format_exception (status)));
 		return_ACPI_STATUS (status);
 	}
 
-
+	acpi_gbl_events_initialized = TRUE;
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_fixed_event_initialize
+ * FUNCTION:    acpi_ev_fixed_event_initialize
  *
  * PARAMETERS:  None
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Initialize the Fixed Acpi_event data structures
+ * DESCRIPTION: Install the fixed event handlers and enable the fixed events.
  *
  ******************************************************************************/
 
 acpi_status
-acpi_ev_fixed_event_initialize(void)
+acpi_ev_fixed_event_initialize (
+	void)
 {
-	int                     i = 0;
+	acpi_native_uint                i;
+	acpi_status                     status;
 
-	/* Initialize the structure that keeps track of fixed event handlers */
 
+	/*
+	 * Initialize the structure that keeps track of fixed event handlers
+	 * and enable the fixed events.
+	 */
 	for (i = 0; i < ACPI_NUM_FIXED_EVENTS; i++) {
 		acpi_gbl_fixed_event_handlers[i].handler = NULL;
 		acpi_gbl_fixed_event_handlers[i].context = NULL;
-	}
 
-	acpi_hw_register_bit_access (ACPI_WRITE, ACPI_MTX_LOCK, TMR_EN, 0);
-	acpi_hw_register_bit_access (ACPI_WRITE, ACPI_MTX_LOCK, GBL_EN, 0);
-	acpi_hw_register_bit_access (ACPI_WRITE, ACPI_MTX_LOCK, PWRBTN_EN, 0);
-	acpi_hw_register_bit_access (ACPI_WRITE, ACPI_MTX_LOCK, SLPBTN_EN, 0);
-	acpi_hw_register_bit_access (ACPI_WRITE, ACPI_MTX_LOCK, RTC_EN, 0);
+		/* Enable the fixed event */
+
+		if (acpi_gbl_fixed_event_info[i].enable_register_id != 0xFF) {
+			status = acpi_set_register (acpi_gbl_fixed_event_info[i].enable_register_id,
+					 0, ACPI_MTX_LOCK);
+			if (ACPI_FAILURE (status)) {
+				return (status);
+			}
+		}
+	}
 
 	return (AE_OK);
 }
@@ -158,7 +194,7 @@ acpi_ev_fixed_event_initialize(void)
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_fixed_event_detect
+ * FUNCTION:    acpi_ev_fixed_event_detect
  *
  * PARAMETERS:  None
  *
@@ -169,54 +205,41 @@ acpi_ev_fixed_event_initialize(void)
  ******************************************************************************/
 
 u32
-acpi_ev_fixed_event_detect (void)
+acpi_ev_fixed_event_detect (
+	void)
 {
-	u32                     int_status = INTERRUPT_NOT_HANDLED;
-	u32                     status_register;
-	u32                     enable_register;
+	u32                             int_status = ACPI_INTERRUPT_NOT_HANDLED;
+	u32                             fixed_status;
+	u32                             fixed_enable;
+	acpi_native_uint                i;
 
 
-	PROC_NAME ("Ev_fixed_event_detect");
+	ACPI_FUNCTION_NAME ("ev_fixed_event_detect");
 
 
 	/*
 	 * Read the fixed feature status and enable registers, as all the cases
-	 * depend on their values.
+	 * depend on their values.  Ignore errors here.
 	 */
-	status_register = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, PM1_STS);
-	enable_register = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, PM1_EN);
+	(void) acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_STATUS, &fixed_status);
+	(void) acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_ENABLE, &fixed_enable);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INTERRUPTS,
-		"Fixed Acpi_event Block: Enable %08X Status %08X\n",
-		enable_register, status_register));
-
+		"Fixed Event Block: Enable %08X Status %08X\n",
+		fixed_enable, fixed_status));
 
-	/* power management timer roll over */
-
-	if ((status_register & ACPI_STATUS_PMTIMER) &&
-		(enable_register & ACPI_ENABLE_PMTIMER)) {
-		int_status |= acpi_ev_fixed_event_dispatch (ACPI_EVENT_PMTIMER);
-	}
-
-	/* global event (BIOS wants the global lock) */
-
-	if ((status_register & ACPI_STATUS_GLOBAL) &&
-		(enable_register & ACPI_ENABLE_GLOBAL)) {
-		int_status |= acpi_ev_fixed_event_dispatch (ACPI_EVENT_GLOBAL);
-	}
-
-	/* power button event */
-
-	if ((status_register & ACPI_STATUS_POWER_BUTTON) &&
-		(enable_register & ACPI_ENABLE_POWER_BUTTON)) {
-		int_status |= acpi_ev_fixed_event_dispatch (ACPI_EVENT_POWER_BUTTON);
-	}
+	/*
+	 * Check for all possible Fixed Events and dispatch those that are active
+	 */
+	for (i = 0; i < ACPI_NUM_FIXED_EVENTS; i++) {
+		/* Both the status and enable bits must be on for this event */
 
-	/* sleep button event */
+		if ((fixed_status & acpi_gbl_fixed_event_info[i].status_bit_mask) &&
+			(fixed_enable & acpi_gbl_fixed_event_info[i].enable_bit_mask)) {
+			/* Found an active (signalled) event */
 
-	if ((status_register & ACPI_STATUS_SLEEP_BUTTON) &&
-		(enable_register & ACPI_ENABLE_SLEEP_BUTTON)) {
-		int_status |= acpi_ev_fixed_event_dispatch (ACPI_EVENT_SLEEP_BUTTON);
+			int_status |= acpi_ev_fixed_event_dispatch ((u32) i);
+		}
 	}
 
 	return (int_status);
@@ -225,7 +248,7 @@ acpi_ev_fixed_event_detect (void)
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_fixed_event_dispatch
+ * FUNCTION:    acpi_ev_fixed_event_dispatch
  *
  * PARAMETERS:  Event               - Event type
  *
@@ -238,590 +261,37 @@ acpi_ev_fixed_event_detect (void)
 
 u32
 acpi_ev_fixed_event_dispatch (
-	u32                     event)
+	u32                             event)
 {
-	u32                     register_id;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	/* Clear the status bit */
 
-	switch (event) {
-	case ACPI_EVENT_PMTIMER:
-		register_id = TMR_STS;
-		break;
-
-	case ACPI_EVENT_GLOBAL:
-		register_id = GBL_STS;
-		break;
-
-	case ACPI_EVENT_POWER_BUTTON:
-		register_id = PWRBTN_STS;
-		break;
-
-	case ACPI_EVENT_SLEEP_BUTTON:
-		register_id = SLPBTN_STS;
-		break;
-
-	case ACPI_EVENT_RTC:
-		register_id = RTC_STS;
-		break;
-
-	default:
-		return 0;
-		break;
-	}
-
-	acpi_hw_register_bit_access (ACPI_WRITE, ACPI_MTX_DO_NOT_LOCK, register_id, 1);
+	(void) acpi_set_register (acpi_gbl_fixed_event_info[event].status_register_id,
+			 1, ACPI_MTX_DO_NOT_LOCK);
 
 	/*
 	 * Make sure we've got a handler.  If not, report an error.
 	 * The event is disabled to prevent further interrupts.
 	 */
 	if (NULL == acpi_gbl_fixed_event_handlers[event].handler) {
-		register_id = (PM1_EN | REGISTER_BIT_ID(register_id));
+		(void) acpi_set_register (acpi_gbl_fixed_event_info[event].enable_register_id,
+				0, ACPI_MTX_DO_NOT_LOCK);
 
-		acpi_hw_register_bit_access (ACPI_WRITE, ACPI_MTX_DO_NOT_LOCK,
-				 register_id, 0);
-
-		REPORT_ERROR (
-			("Ev_gpe_dispatch: No installed handler for fixed event [%08X]\n",
+		ACPI_REPORT_ERROR (
+			("No installed handler for fixed event [%08X]\n",
 			event));
 
-		return (INTERRUPT_NOT_HANDLED);
+		return (ACPI_INTERRUPT_NOT_HANDLED);
 	}
 
-	/* Invoke the handler */
+	/* Invoke the Fixed Event handler */
 
 	return ((acpi_gbl_fixed_event_handlers[event].handler)(
 			  acpi_gbl_fixed_event_handlers[event].context));
 }
 
 
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ev_gpe_initialize
- *
- * PARAMETERS:  None
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Initialize the GPE data structures
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ev_gpe_initialize (void)
-{
-	u32                     i;
-	u32                     j;
-	u32                     register_index;
-	u32                     gpe_number;
-	u16                     gpe0register_count;
-	u16                     gpe1_register_count;
-
-
-	FUNCTION_TRACE ("Ev_gpe_initialize");
-
-	/*
-	 * Set up various GPE counts
-	 *
-	 * You may ask,why are the GPE register block lengths divided by 2?
-	 * From the ACPI 2.0 Spec, section, 4.7.1.6 General-Purpose Event
-	 * Registers, we have,
-	 *
-	 * "Each register block contains two registers of equal length
-	 * GPEx_STS and GPEx_EN (where x is 0 or 1). The length of the
-	 * GPE0_STS and GPE0_EN registers is equal to half the GPE0_LEN
-	 * The length of the GPE1_STS and GPE1_EN registers is equal to
-	 * half the GPE1_LEN. If a generic register block is not supported
-	 * then its respective block pointer and block length values in the
-	 * FADT table contain zeros. The GPE0_LEN and GPE1_LEN do not need
-	 * to be the same size."
-	 */
-	gpe0register_count          = (u16) DIV_2 (acpi_gbl_FADT->gpe0blk_len);
-	gpe1_register_count         = (u16) DIV_2 (acpi_gbl_FADT->gpe1_blk_len);
-	acpi_gbl_gpe_register_count = gpe0register_count + gpe1_register_count;
-
-	if (!acpi_gbl_gpe_register_count) {
-		REPORT_WARNING (("Zero GPEs are defined in the FADT\n"));
-		return_ACPI_STATUS (AE_OK);
-	}
-
-	/*
-	 * Allocate the Gpe information block
-	 */
-	acpi_gbl_gpe_registers = ACPI_MEM_CALLOCATE (acpi_gbl_gpe_register_count *
-			  sizeof (acpi_gpe_registers));
-	if (!acpi_gbl_gpe_registers) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Could not allocate the Gpe_registers block\n"));
-		return_ACPI_STATUS (AE_NO_MEMORY);
-	}
-
-	/*
-	 * Allocate the Gpe dispatch handler block
-	 * There are eight distinct GP events per register.
-	 * Initialization to zeros is sufficient
-	 */
-	acpi_gbl_gpe_info = ACPI_MEM_CALLOCATE (MUL_8 (acpi_gbl_gpe_register_count) *
-			  sizeof (acpi_gpe_level_info));
-	if (!acpi_gbl_gpe_info) {
-		ACPI_MEM_FREE (acpi_gbl_gpe_registers);
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not allocate the Gpe_info block\n"));
-		return_ACPI_STATUS (AE_NO_MEMORY);
-	}
-
-	/* Set the Gpe validation table to GPE_INVALID */
-
-	MEMSET (acpi_gbl_gpe_valid, (int) ACPI_GPE_INVALID, ACPI_NUM_GPE);
-
-	/*
-	 * Initialize the Gpe information and validation blocks.  A goal of these
-	 * blocks is to hide the fact that there are two separate GPE register sets
-	 * In a given block, the status registers occupy the first half, and
-	 * the enable registers occupy the second half.
-	 */
-
-	/* GPE Block 0 */
-
-	register_index = 0;
-
-	for (i = 0; i < gpe0register_count; i++) {
-		acpi_gbl_gpe_registers[register_index].status_addr =
-				 (u16) (ACPI_GET_ADDRESS (acpi_gbl_FADT->Xgpe0blk.address) + i);
-
-		acpi_gbl_gpe_registers[register_index].enable_addr =
-				 (u16) (ACPI_GET_ADDRESS (acpi_gbl_FADT->Xgpe0blk.address) + i + gpe0register_count);
-
-		acpi_gbl_gpe_registers[register_index].gpe_base = (u8) MUL_8 (i);
-
-		for (j = 0; j < 8; j++) {
-			gpe_number = acpi_gbl_gpe_registers[register_index].gpe_base + j;
-			acpi_gbl_gpe_valid[gpe_number] = (u8) register_index;
-		}
-
-		/*
-		 * Clear the status/enable registers.  Note that status registers
-		 * are cleared by writing a '1', while enable registers are cleared
-		 * by writing a '0'.
-		 */
-		acpi_os_write_port (acpi_gbl_gpe_registers[register_index].enable_addr, 0x00, 8);
-		acpi_os_write_port (acpi_gbl_gpe_registers[register_index].status_addr, 0xFF, 8);
-
-		register_index++;
-	}
-
-	/* GPE Block 1 */
-
-	for (i = 0; i < gpe1_register_count; i++) {
-		acpi_gbl_gpe_registers[register_index].status_addr =
-				 (u16) (ACPI_GET_ADDRESS (acpi_gbl_FADT->Xgpe1_blk.address) + i);
-
-		acpi_gbl_gpe_registers[register_index].enable_addr =
-				 (u16) (ACPI_GET_ADDRESS (acpi_gbl_FADT->Xgpe1_blk.address) + i + gpe1_register_count);
-
-		acpi_gbl_gpe_registers[register_index].gpe_base =
-				 (u8) (acpi_gbl_FADT->gpe1_base + MUL_8 (i));
-
-		for (j = 0; j < 8; j++) {
-			gpe_number = acpi_gbl_gpe_registers[register_index].gpe_base + j;
-			acpi_gbl_gpe_valid[gpe_number] = (u8) register_index;
-		}
-
-		/*
-		 * Clear the status/enable registers.  Note that status registers
-		 * are cleared by writing a '1', while enable registers are cleared
-		 * by writing a '0'.
-		 */
-		acpi_os_write_port (acpi_gbl_gpe_registers[register_index].enable_addr, 0x00, 8);
-		acpi_os_write_port (acpi_gbl_gpe_registers[register_index].status_addr, 0xFF, 8);
-
-		register_index++;
-	}
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "GPE registers: %X@%8.8X%8.8X (Blk0) %X@%8.8X%8.8X (Blk1)\n",
-		gpe0register_count, HIDWORD(acpi_gbl_FADT->Xgpe0blk.address), LODWORD(acpi_gbl_FADT->Xgpe0blk.address),
-		gpe1_register_count, HIDWORD(acpi_gbl_FADT->Xgpe1_blk.address), LODWORD(acpi_gbl_FADT->Xgpe1_blk.address)));
-
-	return_ACPI_STATUS (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ev_save_method_info
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Called from Acpi_walk_namespace. Expects each object to be a
- *              control method under the _GPE portion of the namespace.
- *              Extract the name and GPE type from the object, saving this
- *              information for quick lookup during GPE dispatch
- *
- *              The name of each GPE control method is of the form:
- *                  "_Lnn" or "_Enn"
- *              Where:
- *                  L      - means that the GPE is level triggered
- *                  E      - means that the GPE is edge triggered
- *                  nn     - is the GPE number
- *
- ******************************************************************************/
-
-static acpi_status
-acpi_ev_save_method_info (
-	acpi_handle             obj_handle,
-	u32                     level,
-	void                    *obj_desc,
-	void                    **return_value)
-{
-	u32                     gpe_number;
-	NATIVE_CHAR             name[ACPI_NAME_SIZE + 1];
-	u8                      type;
-
-
-	PROC_NAME ("Ev_save_method_info");
-
-
-	/* Extract the name from the object and convert to a string */
-
-	MOVE_UNALIGNED32_TO_32 (name, &((acpi_namespace_node *) obj_handle)->name);
-	name[ACPI_NAME_SIZE] = 0;
-
-	/*
-	 * Edge/Level determination is based on the 2nd s8 of the method name
-	 */
-	if (name[1] == 'L') {
-		type = ACPI_EVENT_LEVEL_TRIGGERED;
-	}
-	else if (name[1] == 'E') {
-		type = ACPI_EVENT_EDGE_TRIGGERED;
-	}
-	else {
-		/* Unknown method type, just ignore it! */
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Unknown GPE method type: %s (name not of form _Lnn or _Enn)\n",
-			name));
-		return (AE_OK);
-	}
-
-	/* Convert the last two characters of the name to the Gpe Number */
-
-	gpe_number = STRTOUL (&name[2], NULL, 16);
-	if (gpe_number == ACPI_UINT32_MAX) {
-		/* Conversion failed; invalid method, just ignore it */
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Could not extract GPE number from name: %s (name not of form _Lnn or _Enn)\n",
-			name));
-		return (AE_OK);
-	}
-
-	/* Ensure that we have a valid GPE number */
-
-	if (acpi_gbl_gpe_valid[gpe_number] == ACPI_GPE_INVALID) {
-		/* Not valid, all we can do here is ignore it */
-
-		return (AE_OK);
-	}
-
-	/*
-	 * Now we can add this information to the Gpe_info block
-	 * for use during dispatch of this GPE.
-	 */
-	acpi_gbl_gpe_info [gpe_number].type         = type;
-	acpi_gbl_gpe_info [gpe_number].method_handle = obj_handle;
-
-
-	/*
-	 * Enable the GPE (SCIs should be disabled at this point)
-	 */
-	acpi_hw_enable_gpe (gpe_number);
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Registered GPE method %s as GPE number %X\n",
-		name, gpe_number));
-	return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ev_init_gpe_control_methods
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Obtain the control methods associated with the GPEs.
- *
- *              NOTE: Must be called AFTER namespace initialization!
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ev_init_gpe_control_methods (void)
-{
-	acpi_status             status;
-
-
-	FUNCTION_TRACE ("Ev_init_gpe_control_methods");
-
-
-	/* Get a permanent handle to the _GPE object */
-
-	status = acpi_get_handle (NULL, "\\_GPE", &acpi_gbl_gpe_obj_handle);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
-
-	/* Traverse the namespace under \_GPE to find all methods there */
-
-	status = acpi_walk_namespace (ACPI_TYPE_METHOD, acpi_gbl_gpe_obj_handle,
-			  ACPI_UINT32_MAX, acpi_ev_save_method_info,
-			  NULL, NULL);
-
-	return_ACPI_STATUS (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ev_gpe_detect
- *
- * PARAMETERS:  None
- *
- * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED
- *
- * DESCRIPTION: Detect if any GP events have occurred
- *
- ******************************************************************************/
-
-u32
-acpi_ev_gpe_detect (void)
-{
-	u32                     int_status = INTERRUPT_NOT_HANDLED;
-	u32                     i;
-	u32                     j;
-	u8                      enabled_status_byte;
-	u8                      bit_mask;
-
-
-	PROC_NAME ("Ev_gpe_detect");
-
-
-	/*
-	 * Read all of the 8-bit GPE status and enable registers
-	 * in both of the register blocks, saving all of it.
-	 * Find all currently active GP events.
-	 */
-	for (i = 0; i < acpi_gbl_gpe_register_count; i++) {
-		acpi_os_read_port (acpi_gbl_gpe_registers[i].status_addr,
-				&acpi_gbl_gpe_registers[i].status, 8);
-
-		acpi_os_read_port (acpi_gbl_gpe_registers[i].enable_addr,
-				&acpi_gbl_gpe_registers[i].enable, 8);
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_INTERRUPTS,
-			"GPE block at %X - Enable %08X Status %08X\n",
-			acpi_gbl_gpe_registers[i].enable_addr,
-			acpi_gbl_gpe_registers[i].status,
-			acpi_gbl_gpe_registers[i].enable));
-
-		/* First check if there is anything active at all in this register */
-
-		enabled_status_byte = (u8) (acpi_gbl_gpe_registers[i].status &
-				   acpi_gbl_gpe_registers[i].enable);
-
-		if (!enabled_status_byte) {
-			/* No active GPEs in this register, move on */
-
-			continue;
-		}
-
-		/* Now look at the individual GPEs in this byte register */
-
-		for (j = 0, bit_mask = 1; j < 8; j++, bit_mask <<= 1) {
-			/* Examine one GPE bit */
-
-			if (enabled_status_byte & bit_mask) {
-				/*
-				 * Found an active GPE.  Dispatch the event to a handler
-				 * or method.
-				 */
-				int_status |= acpi_ev_gpe_dispatch (
-						  acpi_gbl_gpe_registers[i].gpe_base + j);
-			}
-		}
-	}
-
-	return (int_status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ev_asynch_execute_gpe_method
- *
- * PARAMETERS:  Gpe_number      - The 0-based Gpe number
- *
- * RETURN:      None
- *
- * DESCRIPTION: Perform the actual execution of a GPE control method.  This
- *              function is called from an invocation of Acpi_os_queue_for_execution
- *              (and therefore does NOT execute at interrupt level) so that
- *              the control method itself is not executed in the context of
- *              the SCI interrupt handler.
- *
- ******************************************************************************/
-
-static void
-acpi_ev_asynch_execute_gpe_method (
-	void                    *context)
-{
-	unsigned long           gpe_number = (unsigned long) context;
-	acpi_gpe_level_info     gpe_info;
-
-
-	FUNCTION_TRACE ("Ev_asynch_execute_gpe_method");
-
-	/*
-	 * Take a snapshot of the GPE info for this level
-	 */
-	acpi_ut_acquire_mutex (ACPI_MTX_EVENTS);
-	gpe_info = acpi_gbl_gpe_info [gpe_number];
-	acpi_ut_release_mutex (ACPI_MTX_EVENTS);
-
-	/*
-	 * Method Handler (_Lxx, _Exx):
-	 * ----------------------------
-	 * Evaluate the _Lxx/_Exx control method that corresponds to this GPE.
-	 */
-	if (gpe_info.method_handle) {
-		acpi_ns_evaluate_by_handle (gpe_info.method_handle, NULL, NULL);
-	}
-
-	/*
-	 * Level-Triggered?
-	 * ----------------
-	 * If level-triggered we clear the GPE status bit after handling the event.
-	 */
-	if (gpe_info.type & ACPI_EVENT_LEVEL_TRIGGERED) {
-		acpi_hw_clear_gpe (gpe_number);
-	}
-
-	/*
-	 * Enable the GPE.
-	 */
-	acpi_hw_enable_gpe (gpe_number);
-
-	return_VOID;
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ev_gpe_dispatch
- *
- * PARAMETERS:  Gpe_number      - The 0-based Gpe number
- *
- * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED
- *
- * DESCRIPTION: Handle and dispatch a General Purpose Acpi_event.
- *              Clears the status bit for the requested event.
- *
- * TBD: [Investigate] is this still valid or necessary:
- * The Gpe handler differs from the fixed events in that it clears the enable
- * bit rather than the status bit to clear the interrupt.  This allows
- * software outside of interrupt context to determine what caused the SCI and
- * dispatch the correct AML.
- *
- ******************************************************************************/
-
-u32
-acpi_ev_gpe_dispatch (
-	u32                     gpe_number)
-{
-	acpi_gpe_level_info     gpe_info;
-
-
-	FUNCTION_TRACE ("Ev_gpe_dispatch");
-
-
-	/*
-	 * Valid GPE number?
-	 */
-	if (acpi_gbl_gpe_valid[gpe_number] == ACPI_GPE_INVALID) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid GPE bit [%X].\n", gpe_number));
-		return_VALUE (INTERRUPT_NOT_HANDLED);
-	}
-
-	/*
-	 * Disable the GPE.
-	 */
-	acpi_hw_disable_gpe (gpe_number);
-
-	gpe_info = acpi_gbl_gpe_info [gpe_number];
-
-	/*
-	 * Edge-Triggered?
-	 * ---------------
-	 * If edge-triggered, clear the GPE status bit now.  Note that
-	 * level-triggered events are cleared after the GPE is serviced.
-	 */
-	if (gpe_info.type & ACPI_EVENT_EDGE_TRIGGERED) {
-		acpi_hw_clear_gpe (gpe_number);
-	}
-		/*
-		 * Function Handler (e.g. EC)?
-		 */
-	if (gpe_info.handler) {
-		/* Invoke function handler (at interrupt level). */
-
-		gpe_info.handler (gpe_info.context);
-
-		/* Level-Triggered? */
-
-		if (gpe_info.type & ACPI_EVENT_LEVEL_TRIGGERED) {
-			acpi_hw_clear_gpe (gpe_number);
-		}
-
-		/* Enable GPE */
-
-		acpi_hw_enable_gpe (gpe_number);
-	}
-
-	/*
-	 * Method Handler (e.g. _Exx/_Lxx)?
-	 */
-	else if (gpe_info.method_handle) {
-		if (ACPI_FAILURE(acpi_os_queue_for_execution (OSD_PRIORITY_GPE,
-			acpi_ev_asynch_execute_gpe_method, (void*) (u64)gpe_number))) {
-			/*
-			 * Shoudn't occur, but if it does report an error. Note that
-			 * the GPE will remain disabled until the ACPI Core Subsystem
-			 * is restarted, or the handler is removed/reinstalled.
-			 */
-			REPORT_ERROR (("Acpi_ev_gpe_dispatch: Unable to queue handler for GPE bit [%X]\n", gpe_number));
-		}
-	}
-
-	/*
-	 * No Handler? Report an error and leave the GPE disabled.
-	 */
-	else {
-		REPORT_ERROR (("Acpi_ev_gpe_dispatch: No installed handler for GPE [%X]\n", gpe_number));
-
-		/* Level-Triggered? */
-
-		if (gpe_info.type & ACPI_EVENT_LEVEL_TRIGGERED) {
-			acpi_hw_clear_gpe (gpe_number);
-		}
-	}
-
-	return_VALUE (INTERRUPT_HANDLED);
-}
diff -urNp linux-5400/drivers/acpi/events/evgpe.c linux-5410/drivers/acpi/events/evgpe.c
--- linux-5400/drivers/acpi/events/evgpe.c
+++ linux-5410/drivers/acpi/events/evgpe.c
@@ -0,0 +1,425 @@
+/******************************************************************************
+ *
+ * Module Name: evgpe - General Purpose Event handling and dispatch
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include <acpi/acevents.h>
+#include <acpi/acnamesp.h>
+
+#define _COMPONENT          ACPI_EVENTS
+	 ACPI_MODULE_NAME    ("evgpe")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_get_gpe_event_info
+ *
+ * PARAMETERS:  gpe_device          - Device node.  NULL for GPE0/GPE1
+ *              gpe_number          - Raw GPE number
+ *
+ * RETURN:      A GPE event_info struct. NULL if not a valid GPE
+ *
+ * DESCRIPTION: Returns the event_info struct associated with this GPE.
+ *              Validates the gpe_block and the gpe_number
+ *
+ *              Should be called only when the GPE lists are semaphore locked
+ *              and not subject to change.
+ *
+ ******************************************************************************/
+
+struct acpi_gpe_event_info *
+acpi_ev_get_gpe_event_info (
+	acpi_handle                     gpe_device,
+	u32                             gpe_number)
+{
+	union acpi_operand_object       *obj_desc;
+	struct acpi_gpe_block_info      *gpe_block;
+	acpi_native_uint                i;
+
+
+	ACPI_FUNCTION_ENTRY ();
+
+
+	/* A NULL gpe_block means use the FADT-defined GPE block(s) */
+
+	if (!gpe_device) {
+		/* Examine GPE Block 0 and 1 (These blocks are permanent) */
+
+		for (i = 0; i < ACPI_MAX_GPE_BLOCKS; i++) {
+			gpe_block = acpi_gbl_gpe_fadt_blocks[i];
+			if (gpe_block) {
+				if ((gpe_number >= gpe_block->block_base_number) &&
+					(gpe_number < gpe_block->block_base_number + (gpe_block->register_count * 8))) {
+					return (&gpe_block->event_info[gpe_number - gpe_block->block_base_number]);
+				}
+			}
+		}
+
+		/* The gpe_number was not in the range of either FADT GPE block */
+
+		return (NULL);
+	}
+
+	/*
+	 * A Non-null gpe_device means this is a GPE Block Device.
+	 */
+	obj_desc = acpi_ns_get_attached_object ((struct acpi_namespace_node *) gpe_device);
+	if (!obj_desc ||
+		!obj_desc->device.gpe_block) {
+		return (NULL);
+	}
+
+	gpe_block = obj_desc->device.gpe_block;
+
+	if ((gpe_number >= gpe_block->block_base_number) &&
+		(gpe_number < gpe_block->block_base_number + (gpe_block->register_count * 8))) {
+		return (&gpe_block->event_info[gpe_number - gpe_block->block_base_number]);
+	}
+
+	return (NULL);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_gpe_detect
+ *
+ * PARAMETERS:  gpe_xrupt_list      - Interrupt block for this interrupt.
+ *                                    Can have multiple GPE blocks attached.
+ *
+ * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED
+ *
+ * DESCRIPTION: Detect if any GP events have occurred.  This function is
+ *              executed at interrupt level.
+ *
+ ******************************************************************************/
+
+u32
+acpi_ev_gpe_detect (
+	struct acpi_gpe_xrupt_info      *gpe_xrupt_list)
+{
+	u32                             int_status = ACPI_INTERRUPT_NOT_HANDLED;
+	u8                              enabled_status_byte;
+	u8                              bit_mask;
+	struct acpi_gpe_register_info   *gpe_register_info;
+	u32                             in_value;
+	acpi_status                     status;
+	struct acpi_gpe_block_info      *gpe_block;
+	u32                             gpe_number;
+	u32                             i;
+	u32                             j;
+
+
+	ACPI_FUNCTION_NAME ("ev_gpe_detect");
+
+
+	/* Examine all GPE blocks attached to this interrupt level */
+
+	acpi_os_acquire_lock (acpi_gbl_gpe_lock, ACPI_ISR);
+	gpe_block = gpe_xrupt_list->gpe_block_list_head;
+	while (gpe_block) {
+		/*
+		 * Read all of the 8-bit GPE status and enable registers
+		 * in this GPE block, saving all of them.
+		 * Find all currently active GP events.
+		 */
+		for (i = 0; i < gpe_block->register_count; i++) {
+			/* Get the next status/enable pair */
+
+			gpe_register_info = &gpe_block->register_info[i];
+
+			/* Read the Status Register */
+
+			status = acpi_hw_low_level_read (ACPI_GPE_REGISTER_WIDTH, &in_value,
+					 &gpe_register_info->status_address);
+			gpe_register_info->status = (u8) in_value;
+			if (ACPI_FAILURE (status)) {
+				goto unlock_and_exit;
+			}
+
+			/* Read the Enable Register */
+
+			status = acpi_hw_low_level_read (ACPI_GPE_REGISTER_WIDTH, &in_value,
+					 &gpe_register_info->enable_address);
+			gpe_register_info->enable = (u8) in_value;
+			if (ACPI_FAILURE (status)) {
+				goto unlock_and_exit;
+			}
+
+			ACPI_DEBUG_PRINT ((ACPI_DB_INTERRUPTS,
+				"GPE pair: Status %8.8X%8.8X = %02X, Enable %8.8X%8.8X = %02X\n",
+				ACPI_HIDWORD (gpe_register_info->status_address.address),
+				ACPI_LODWORD (gpe_register_info->status_address.address),
+				gpe_register_info->status,
+				ACPI_HIDWORD (gpe_register_info->enable_address.address),
+				ACPI_LODWORD (gpe_register_info->enable_address.address),
+				gpe_register_info->enable));
+
+			/* First check if there is anything active at all in this register */
+
+			enabled_status_byte = (u8) (gpe_register_info->status &
+					   gpe_register_info->enable);
+			if (!enabled_status_byte) {
+				/* No active GPEs in this register, move on */
+
+				continue;
+			}
+
+			/* Now look at the individual GPEs in this byte register */
+
+			for (j = 0, bit_mask = 1; j < ACPI_GPE_REGISTER_WIDTH; j++, bit_mask <<= 1) {
+				/* Examine one GPE bit */
+
+				if (enabled_status_byte & bit_mask) {
+					/*
+					 * Found an active GPE. Dispatch the event to a handler
+					 * or method.
+					 */
+					gpe_number = (i * ACPI_GPE_REGISTER_WIDTH) + j;
+
+					int_status |= acpi_ev_gpe_dispatch (
+							  &gpe_block->event_info[gpe_number],
+							  gpe_number + gpe_block->register_info[gpe_number].base_gpe_number);
+				}
+			}
+		}
+
+		gpe_block = gpe_block->next;
+	}
+
+unlock_and_exit:
+
+	acpi_os_release_lock (acpi_gbl_gpe_lock, ACPI_ISR);
+	return (int_status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_asynch_execute_gpe_method
+ *
+ * PARAMETERS:  Context (gpe_event_info) - Info for this GPE
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Perform the actual execution of a GPE control method.  This
+ *              function is called from an invocation of acpi_os_queue_for_execution
+ *              (and therefore does NOT execute at interrupt level) so that
+ *              the control method itself is not executed in the context of
+ *              an interrupt handler.
+ *
+ ******************************************************************************/
+
+static void ACPI_SYSTEM_XFACE
+acpi_ev_asynch_execute_gpe_method (
+	void                            *context)
+{
+	struct acpi_gpe_event_info      *gpe_event_info = (void *) context;
+	u32                             gpe_number = 0;
+	acpi_status                     status;
+	struct acpi_gpe_event_info      local_gpe_event_info;
+
+
+	ACPI_FUNCTION_TRACE ("ev_asynch_execute_gpe_method");
+
+
+	status = acpi_ut_acquire_mutex (ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE (status)) {
+		return_VOID;
+	}
+
+	/* Must revalidate the gpe_number/gpe_block */
+
+	if (!acpi_ev_valid_gpe_event (gpe_event_info)) {
+		status = acpi_ut_release_mutex (ACPI_MTX_EVENTS);
+		return_VOID;
+	}
+
+	/*
+	 * Take a snapshot of the GPE info for this level - we copy the
+	 * info to prevent a race condition with remove_handler/remove_block.
+	 */
+	ACPI_MEMCPY (&local_gpe_event_info, gpe_event_info, sizeof (struct acpi_gpe_event_info));
+
+	status = acpi_ut_release_mutex (ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE (status)) {
+		return_VOID;
+	}
+
+	if (local_gpe_event_info.method_node) {
+		/*
+		 * Invoke the GPE Method (_Lxx, _Exx):
+		 * (Evaluate the _Lxx/_Exx control method that corresponds to this GPE.)
+		 */
+		status = acpi_ns_evaluate_by_handle (local_gpe_event_info.method_node, NULL, NULL);
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_ERROR (("%s while evaluating method [%4.4s] for GPE[%2X]\n",
+				acpi_format_exception (status),
+				local_gpe_event_info.method_node->name.ascii, gpe_number));
+		}
+	}
+
+	if (local_gpe_event_info.flags & ACPI_EVENT_LEVEL_TRIGGERED) {
+		/*
+		 * GPE is level-triggered, we clear the GPE status bit after handling
+		 * the event.
+		 */
+		status = acpi_hw_clear_gpe (&local_gpe_event_info);
+		if (ACPI_FAILURE (status)) {
+			return_VOID;
+		}
+	}
+
+	/* Enable this GPE */
+
+	(void) acpi_hw_enable_gpe (&local_gpe_event_info);
+	return_VOID;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_gpe_dispatch
+ *
+ * PARAMETERS:  gpe_event_info  - info for this GPE
+ *              gpe_number      - Number relative to the parent GPE block
+ *
+ * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED
+ *
+ * DESCRIPTION: Dispatch a General Purpose Event to either a function (e.g. EC)
+ *              or method (e.g. _Lxx/_Exx) handler.
+ *
+ *              This function executes at interrupt level.
+ *
+ ******************************************************************************/
+
+u32
+acpi_ev_gpe_dispatch (
+	struct acpi_gpe_event_info      *gpe_event_info,
+	u32                             gpe_number)
+{
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE ("ev_gpe_dispatch");
+
+
+	/*
+	 * If edge-triggered, clear the GPE status bit now.  Note that
+	 * level-triggered events are cleared after the GPE is serviced.
+	 */
+	if (gpe_event_info->flags & ACPI_EVENT_EDGE_TRIGGERED) {
+		status = acpi_hw_clear_gpe (gpe_event_info);
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_ERROR (("acpi_ev_gpe_dispatch: Unable to clear GPE[%2X]\n",
+				gpe_number));
+			return_VALUE (ACPI_INTERRUPT_NOT_HANDLED);
+		}
+	}
+
+	/*
+	 * Dispatch the GPE to either an installed handler, or the control
+	 * method associated with this GPE (_Lxx or _Exx).
+	 * If a handler exists, we invoke it and do not attempt to run the method.
+	 * If there is neither a handler nor a method, we disable the level to
+	 * prevent further events from coming in here.
+	 */
+	if (gpe_event_info->handler) {
+		/* Invoke the installed handler (at interrupt level) */
+
+		gpe_event_info->handler (gpe_event_info->context);
+	}
+	else if (gpe_event_info->method_node) {
+		/*
+		 * Disable GPE, so it doesn't keep firing before the method has a
+		 * chance to run.
+		 */
+		status = acpi_hw_disable_gpe (gpe_event_info);
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_ERROR (("acpi_ev_gpe_dispatch: Unable to disable GPE[%2X]\n",
+				gpe_number));
+			return_VALUE (ACPI_INTERRUPT_NOT_HANDLED);
+		}
+
+		/* Execute the method associated with the GPE. */
+
+		if (ACPI_FAILURE (acpi_os_queue_for_execution (OSD_PRIORITY_GPE,
+				 acpi_ev_asynch_execute_gpe_method,
+				 gpe_event_info))) {
+			ACPI_REPORT_ERROR ((
+				"acpi_ev_gpe_dispatch: Unable to queue handler for GPE[%2X], event is disabled\n",
+				gpe_number));
+		}
+	}
+	else {
+		/* No handler or method to run! */
+
+		ACPI_REPORT_ERROR ((
+			"acpi_ev_gpe_dispatch: No handler or method for GPE[%2X], disabling event\n",
+			gpe_number));
+
+		/*
+		 * Disable the GPE.  The GPE will remain disabled until the ACPI
+		 * Core Subsystem is restarted, or the handler is reinstalled.
+		 */
+		status = acpi_hw_disable_gpe (gpe_event_info);
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_ERROR (("acpi_ev_gpe_dispatch: Unable to disable GPE[%2X]\n",
+				gpe_number));
+			return_VALUE (ACPI_INTERRUPT_NOT_HANDLED);
+		}
+	}
+
+	/* It is now safe to clear level-triggered events. */
+
+	if (gpe_event_info->flags & ACPI_EVENT_LEVEL_TRIGGERED) {
+		status = acpi_hw_clear_gpe (gpe_event_info);
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_ERROR (("acpi_ev_gpe_dispatch: Unable to clear GPE[%2X]\n",
+				gpe_number));
+			return_VALUE (ACPI_INTERRUPT_NOT_HANDLED);
+		}
+	}
+
+	return_VALUE (ACPI_INTERRUPT_HANDLED);
+}
+
diff -urNp linux-5400/drivers/acpi/events/evgpeblk.c linux-5410/drivers/acpi/events/evgpeblk.c
--- linux-5400/drivers/acpi/events/evgpeblk.c
+++ linux-5410/drivers/acpi/events/evgpeblk.c
@@ -0,0 +1,903 @@
+/******************************************************************************
+ *
+ * Module Name: evgpeblk - GPE block creation and initialization.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include <acpi/acevents.h>
+#include <acpi/acnamesp.h>
+
+#define _COMPONENT          ACPI_EVENTS
+	 ACPI_MODULE_NAME    ("evgpeblk")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_valid_gpe_event
+ *
+ * PARAMETERS:  gpe_event_info - Info for this GPE
+ *
+ * RETURN:      TRUE if the gpe_event is valid
+ *
+ * DESCRIPTION: Validate a GPE event.  DO NOT CALL FROM INTERRUPT LEVEL.
+ *              Should be called only when the GPE lists are semaphore locked
+ *              and not subject to change.
+ *
+ ******************************************************************************/
+
+u8
+acpi_ev_valid_gpe_event (
+	struct acpi_gpe_event_info      *gpe_event_info)
+{
+	struct acpi_gpe_xrupt_info      *gpe_xrupt_block;
+	struct acpi_gpe_block_info      *gpe_block;
+
+
+	ACPI_FUNCTION_ENTRY ();
+
+
+	/* No need for spin lock since we are not changing any list elements */
+
+	/* Walk the GPE interrupt levels */
+
+	gpe_xrupt_block = acpi_gbl_gpe_xrupt_list_head;
+	while (gpe_xrupt_block) {
+		gpe_block = gpe_xrupt_block->gpe_block_list_head;
+
+		/* Walk the GPE blocks on this interrupt level */
+
+		while (gpe_block) {
+			if ((&gpe_block->event_info[0] <= gpe_event_info) &&
+				(&gpe_block->event_info[((acpi_size) gpe_block->register_count) * 8] > gpe_event_info)) {
+				return (TRUE);
+			}
+
+			gpe_block = gpe_block->next;
+		}
+
+		gpe_xrupt_block = gpe_xrupt_block->next;
+	}
+
+	return (FALSE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_walk_gpe_list
+ *
+ * PARAMETERS:  gpe_walk_callback   - Routine called for each GPE block
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Walk the GPE lists.
+ *              FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_walk_gpe_list (
+	ACPI_GPE_CALLBACK       gpe_walk_callback)
+{
+	struct acpi_gpe_block_info      *gpe_block;
+	struct acpi_gpe_xrupt_info      *gpe_xrupt_info;
+	acpi_status                     status = AE_OK;
+
+
+	ACPI_FUNCTION_TRACE ("ev_walk_gpe_list");
+
+
+	acpi_os_acquire_lock (acpi_gbl_gpe_lock, ACPI_ISR);
+
+	/* Walk the interrupt level descriptor list */
+
+	gpe_xrupt_info = acpi_gbl_gpe_xrupt_list_head;
+	while (gpe_xrupt_info) {
+		/* Walk all Gpe Blocks attached to this interrupt level */
+
+		gpe_block = gpe_xrupt_info->gpe_block_list_head;
+		while (gpe_block) {
+			/* One callback per GPE block */
+
+			status = gpe_walk_callback (gpe_xrupt_info, gpe_block);
+			if (ACPI_FAILURE (status)) {
+				goto unlock_and_exit;
+			}
+
+			gpe_block = gpe_block->next;
+		}
+
+		gpe_xrupt_info = gpe_xrupt_info->next;
+	}
+
+unlock_and_exit:
+	acpi_os_release_lock (acpi_gbl_gpe_lock, ACPI_ISR);
+	return_ACPI_STATUS (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_save_method_info
+ *
+ * PARAMETERS:  Callback from walk_namespace
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Called from acpi_walk_namespace. Expects each object to be a
+ *              control method under the _GPE portion of the namespace.
+ *              Extract the name and GPE type from the object, saving this
+ *              information for quick lookup during GPE dispatch
+ *
+ *              The name of each GPE control method is of the form:
+ *                  "_Lnn" or "_Enn"
+ *                  Where:
+ *                      L      - means that the GPE is level triggered
+ *                      E      - means that the GPE is edge triggered
+ *                      nn     - is the GPE number [in HEX]
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ev_save_method_info (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *obj_desc,
+	void                            **return_value)
+{
+	struct acpi_gpe_block_info      *gpe_block = (void *) obj_desc;
+	struct acpi_gpe_event_info      *gpe_event_info;
+	u32                             gpe_number;
+	char                            name[ACPI_NAME_SIZE + 1];
+	u8                              type;
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE ("ev_save_method_info");
+
+
+	/* Extract the name from the object and convert to a string */
+
+	ACPI_MOVE_32_TO_32 (name,
+			   &((struct acpi_namespace_node *) obj_handle)->name.integer);
+	name[ACPI_NAME_SIZE] = 0;
+
+	/*
+	 * Edge/Level determination is based on the 2nd character
+	 * of the method name
+	 */
+	switch (name[1]) {
+	case 'L':
+		type = ACPI_EVENT_LEVEL_TRIGGERED;
+		break;
+
+	case 'E':
+		type = ACPI_EVENT_EDGE_TRIGGERED;
+		break;
+
+	default:
+		/* Unknown method type, just ignore it! */
+
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Unknown GPE method type: %s (name not of form _Lnn or _Enn)\n",
+			name));
+		return_ACPI_STATUS (AE_OK);
+	}
+
+	/* Convert the last two characters of the name to the GPE Number */
+
+	gpe_number = ACPI_STRTOUL (&name[2], NULL, 16);
+	if (gpe_number == ACPI_UINT32_MAX) {
+		/* Conversion failed; invalid method, just ignore it */
+
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Could not extract GPE number from name: %s (name is not of form _Lnn or _Enn)\n",
+			name));
+		return_ACPI_STATUS (AE_OK);
+	}
+
+	/* Ensure that we have a valid GPE number for this GPE block */
+
+	if ((gpe_number < gpe_block->block_base_number) ||
+		(gpe_number >= (gpe_block->block_base_number + (gpe_block->register_count * 8)))) {
+		/*
+		 * Not valid for this GPE block, just ignore it
+		 * However, it may be valid for a different GPE block, since GPE0 and GPE1
+		 * methods both appear under \_GPE.
+		 */
+		return_ACPI_STATUS (AE_OK);
+	}
+
+	/*
+	 * Now we can add this information to the gpe_event_info block
+	 * for use during dispatch of this GPE.
+	 */
+	gpe_event_info = &gpe_block->event_info[gpe_number - gpe_block->block_base_number];
+
+	gpe_event_info->flags    = type;
+	gpe_event_info->method_node = (struct acpi_namespace_node *) obj_handle;
+
+	/* Enable the GPE (SCIs should be disabled at this point) */
+
+	status = acpi_hw_enable_gpe (gpe_event_info);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_LOAD,
+		"Registered GPE method %s as GPE number 0x%.2X\n",
+		name, gpe_number));
+	return_ACPI_STATUS (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_get_gpe_xrupt_block
+ *
+ * PARAMETERS:  interrupt_level     - Interrupt for a GPE block
+ *
+ * RETURN:      A GPE interrupt block
+ *
+ * DESCRIPTION: Get or Create a GPE interrupt block.  There is one interrupt
+ *              block per unique interrupt level used for GPEs.
+ *              Should be called only when the GPE lists are semaphore locked
+ *              and not subject to change.
+ *
+ ******************************************************************************/
+
+static struct acpi_gpe_xrupt_info *
+acpi_ev_get_gpe_xrupt_block (
+	u32                             interrupt_level)
+{
+	struct acpi_gpe_xrupt_info      *next_gpe_xrupt;
+	struct acpi_gpe_xrupt_info      *gpe_xrupt;
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE ("ev_get_gpe_xrupt_block");
+
+
+	/* No need for spin lock since we are not changing any list elements here */
+
+	next_gpe_xrupt = acpi_gbl_gpe_xrupt_list_head;
+	while (next_gpe_xrupt) {
+		if (next_gpe_xrupt->interrupt_level == interrupt_level) {
+			return_PTR (next_gpe_xrupt);
+		}
+
+		next_gpe_xrupt = next_gpe_xrupt->next;
+	}
+
+	/* Not found, must allocate a new xrupt descriptor */
+
+	gpe_xrupt = ACPI_MEM_CALLOCATE (sizeof (struct acpi_gpe_xrupt_info));
+	if (!gpe_xrupt) {
+		return_PTR (NULL);
+	}
+
+	gpe_xrupt->interrupt_level = interrupt_level;
+
+	/* Install new interrupt descriptor with spin lock */
+
+	acpi_os_acquire_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
+	if (acpi_gbl_gpe_xrupt_list_head) {
+		next_gpe_xrupt = acpi_gbl_gpe_xrupt_list_head;
+		while (next_gpe_xrupt->next) {
+			next_gpe_xrupt = next_gpe_xrupt->next;
+		}
+
+		next_gpe_xrupt->next = gpe_xrupt;
+		gpe_xrupt->previous = next_gpe_xrupt;
+	}
+	else {
+		acpi_gbl_gpe_xrupt_list_head = gpe_xrupt;
+	}
+	acpi_os_release_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
+
+	/* Install new interrupt handler if not SCI_INT */
+
+	if (interrupt_level != acpi_gbl_FADT->sci_int) {
+		status = acpi_os_install_interrupt_handler (interrupt_level,
+				 acpi_ev_gpe_xrupt_handler, gpe_xrupt);
+		if (ACPI_FAILURE (status)) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Could not install GPE interrupt handler at level 0x%X\n",
+				interrupt_level));
+			return_PTR (NULL);
+		}
+	}
+
+	return_PTR (gpe_xrupt);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_delete_gpe_xrupt
+ *
+ * PARAMETERS:  gpe_xrupt       - A GPE interrupt info block
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Remove and free a gpe_xrupt block. Remove an associated
+ *              interrupt handler if not the SCI interrupt.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ev_delete_gpe_xrupt (
+	struct acpi_gpe_xrupt_info      *gpe_xrupt)
+{
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE ("ev_delete_gpe_xrupt");
+
+
+	/* We never want to remove the SCI interrupt handler */
+
+	if (gpe_xrupt->interrupt_level == acpi_gbl_FADT->sci_int) {
+		gpe_xrupt->gpe_block_list_head = NULL;
+		return_ACPI_STATUS (AE_OK);
+	}
+
+	/* Disable this interrupt */
+
+	status = acpi_os_remove_interrupt_handler (gpe_xrupt->interrupt_level,
+			   acpi_ev_gpe_xrupt_handler);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/* Unlink the interrupt block with lock */
+
+	acpi_os_acquire_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
+	if (gpe_xrupt->previous) {
+		gpe_xrupt->previous->next = gpe_xrupt->next;
+	}
+
+	if (gpe_xrupt->next) {
+		gpe_xrupt->next->previous = gpe_xrupt->previous;
+	}
+	acpi_os_release_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
+
+	/* Free the block */
+
+	ACPI_MEM_FREE (gpe_xrupt);
+	return_ACPI_STATUS (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_install_gpe_block
+ *
+ * PARAMETERS:  gpe_block       - New GPE block
+ *              interrupt_level - Level to be associated with this GPE block
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install new GPE block with mutex support
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ev_install_gpe_block (
+	struct acpi_gpe_block_info      *gpe_block,
+	u32                             interrupt_level)
+{
+	struct acpi_gpe_block_info      *next_gpe_block;
+	struct acpi_gpe_xrupt_info      *gpe_xrupt_block;
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE ("ev_install_gpe_block");
+
+
+	status = acpi_ut_acquire_mutex (ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	gpe_xrupt_block = acpi_ev_get_gpe_xrupt_block (interrupt_level);
+	if (!gpe_xrupt_block) {
+		status = AE_NO_MEMORY;
+		goto unlock_and_exit;
+	}
+
+	/* Install the new block at the end of the list for this interrupt with lock */
+
+	acpi_os_acquire_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
+	if (gpe_xrupt_block->gpe_block_list_head) {
+		next_gpe_block = gpe_xrupt_block->gpe_block_list_head;
+		while (next_gpe_block->next) {
+			next_gpe_block = next_gpe_block->next;
+		}
+
+		next_gpe_block->next = gpe_block;
+		gpe_block->previous = next_gpe_block;
+	}
+	else {
+		gpe_xrupt_block->gpe_block_list_head = gpe_block;
+	}
+
+	gpe_block->xrupt_block = gpe_xrupt_block;
+	acpi_os_release_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
+
+unlock_and_exit:
+	status = acpi_ut_release_mutex (ACPI_MTX_EVENTS);
+	return_ACPI_STATUS (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_delete_gpe_block
+ *
+ * PARAMETERS:  gpe_block       - Existing GPE block
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install new GPE block with mutex support
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_delete_gpe_block (
+	struct acpi_gpe_block_info      *gpe_block)
+{
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE ("ev_install_gpe_block");
+
+
+	status = acpi_ut_acquire_mutex (ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/* Disable all GPEs in this block */
+
+	status = acpi_hw_disable_gpe_block (gpe_block->xrupt_block, gpe_block);
+
+	if (!gpe_block->previous && !gpe_block->next) {
+		/* This is the last gpe_block on this interrupt */
+
+		status = acpi_ev_delete_gpe_xrupt (gpe_block->xrupt_block);
+		if (ACPI_FAILURE (status)) {
+			goto unlock_and_exit;
+		}
+	}
+	else {
+		/* Remove the block on this interrupt with lock */
+
+		acpi_os_acquire_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
+		if (gpe_block->previous) {
+			gpe_block->previous->next = gpe_block->next;
+		}
+		else {
+			gpe_block->xrupt_block->gpe_block_list_head = gpe_block->next;
+		}
+
+		if (gpe_block->next) {
+			gpe_block->next->previous = gpe_block->previous;
+		}
+		acpi_os_release_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
+	}
+
+	/* Free the gpe_block */
+
+	ACPI_MEM_FREE (gpe_block->register_info);
+	ACPI_MEM_FREE (gpe_block->event_info);
+	ACPI_MEM_FREE (gpe_block);
+
+unlock_and_exit:
+	status = acpi_ut_release_mutex (ACPI_MTX_EVENTS);
+	return_ACPI_STATUS (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_create_gpe_info_blocks
+ *
+ * PARAMETERS:  gpe_block   - New GPE block
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create the register_info and event_info blocks for this GPE block
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ev_create_gpe_info_blocks (
+	struct acpi_gpe_block_info      *gpe_block)
+{
+	struct acpi_gpe_register_info   *gpe_register_info = NULL;
+	struct acpi_gpe_event_info      *gpe_event_info = NULL;
+	struct acpi_gpe_event_info      *this_event;
+	struct acpi_gpe_register_info   *this_register;
+	acpi_native_uint                i;
+	acpi_native_uint                j;
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE ("ev_create_gpe_info_blocks");
+
+
+	/* Allocate the GPE register information block */
+
+	gpe_register_info = ACPI_MEM_CALLOCATE (
+			  (acpi_size) gpe_block->register_count *
+			  sizeof (struct acpi_gpe_register_info));
+	if (!gpe_register_info) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Could not allocate the gpe_register_info table\n"));
+		return_ACPI_STATUS (AE_NO_MEMORY);
+	}
+
+	/*
+	 * Allocate the GPE event_info block. There are eight distinct GPEs
+	 * per register.  Initialization to zeros is sufficient.
+	 */
+	gpe_event_info = ACPI_MEM_CALLOCATE (
+			   ((acpi_size) gpe_block->register_count * ACPI_GPE_REGISTER_WIDTH) *
+			   sizeof (struct acpi_gpe_event_info));
+	if (!gpe_event_info) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not allocate the gpe_event_info table\n"));
+		status = AE_NO_MEMORY;
+		goto error_exit;
+	}
+
+	/* Save the new Info arrays in the GPE block */
+
+	gpe_block->register_info = gpe_register_info;
+	gpe_block->event_info  = gpe_event_info;
+
+	/*
+	 * Initialize the GPE Register and Event structures.  A goal of these
+	 * tables is to hide the fact that there are two separate GPE register sets
+	 * in a given gpe hardware block, the status registers occupy the first half,
+	 * and the enable registers occupy the second half.
+	 */
+	this_register = gpe_register_info;
+	this_event   = gpe_event_info;
+
+	for (i = 0; i < gpe_block->register_count; i++) {
+		/* Init the register_info for this GPE register (8 GPEs) */
+
+		this_register->base_gpe_number = (u8) (gpe_block->block_base_number +
+				   (i * ACPI_GPE_REGISTER_WIDTH));
+
+		ACPI_STORE_ADDRESS (this_register->status_address.address,
+				 (gpe_block->block_address.address
+				 + i));
+
+		ACPI_STORE_ADDRESS (this_register->enable_address.address,
+				 (gpe_block->block_address.address
+				 + i
+				 + gpe_block->register_count));
+
+		this_register->status_address.address_space_id = gpe_block->block_address.address_space_id;
+		this_register->enable_address.address_space_id = gpe_block->block_address.address_space_id;
+		this_register->status_address.register_bit_width = ACPI_GPE_REGISTER_WIDTH;
+		this_register->enable_address.register_bit_width = ACPI_GPE_REGISTER_WIDTH;
+		this_register->status_address.register_bit_offset = ACPI_GPE_REGISTER_WIDTH;
+		this_register->enable_address.register_bit_offset = ACPI_GPE_REGISTER_WIDTH;
+
+		/* Init the event_info for each GPE within this register */
+
+		for (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {
+			this_event->bit_mask = acpi_gbl_decode_to8bit[j];
+			this_event->register_info = this_register;
+			this_event++;
+		}
+
+		/*
+		 * Clear the status/enable registers.  Note that status registers
+		 * are cleared by writing a '1', while enable registers are cleared
+		 * by writing a '0'.
+		 */
+		status = acpi_hw_low_level_write (ACPI_GPE_REGISTER_WIDTH, 0x00,
+				 &this_register->enable_address);
+		if (ACPI_FAILURE (status)) {
+			goto error_exit;
+		}
+
+		status = acpi_hw_low_level_write (ACPI_GPE_REGISTER_WIDTH, 0xFF,
+				 &this_register->status_address);
+		if (ACPI_FAILURE (status)) {
+			goto error_exit;
+		}
+
+		this_register++;
+	}
+
+	return_ACPI_STATUS (AE_OK);
+
+
+error_exit:
+	if (gpe_register_info) {
+		ACPI_MEM_FREE (gpe_register_info);
+	}
+	if (gpe_event_info) {
+		ACPI_MEM_FREE (gpe_event_info);
+	}
+
+	return_ACPI_STATUS (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_create_gpe_block
+ *
+ * PARAMETERS:  gpe_device          - Handle to the parent GPE block
+ *              gpe_block_address   - Address and space_iD
+ *              register_count      - Number of GPE register pairs in the block
+ *              gpe_block_base_number - Starting GPE number for the block
+ *              interrupt_level     - H/W interrupt for the block
+ *              return_gpe_block    - Where the new block descriptor is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create and Install a block of GPE registers
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_create_gpe_block (
+	struct acpi_namespace_node      *gpe_device,
+	struct acpi_generic_address     *gpe_block_address,
+	u32                             register_count,
+	u8                              gpe_block_base_number,
+	u32                             interrupt_level,
+	struct acpi_gpe_block_info      **return_gpe_block)
+{
+	struct acpi_gpe_block_info      *gpe_block;
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE ("ev_create_gpe_block");
+
+
+	if (!register_count) {
+		return_ACPI_STATUS (AE_OK);
+	}
+
+	/* Allocate a new GPE block */
+
+	gpe_block = ACPI_MEM_CALLOCATE (sizeof (struct acpi_gpe_block_info));
+	if (!gpe_block) {
+		return_ACPI_STATUS (AE_NO_MEMORY);
+	}
+
+	/* Initialize the new GPE block */
+
+	gpe_block->register_count = register_count;
+	gpe_block->block_base_number = gpe_block_base_number;
+
+	ACPI_MEMCPY (&gpe_block->block_address, gpe_block_address, sizeof (struct acpi_generic_address));
+
+	/* Create the register_info and event_info sub-structures */
+
+	status = acpi_ev_create_gpe_info_blocks (gpe_block);
+	if (ACPI_FAILURE (status)) {
+		ACPI_MEM_FREE (gpe_block);
+		return_ACPI_STATUS (status);
+	}
+
+	/* Install the new block in the global list(s) */
+
+	status = acpi_ev_install_gpe_block (gpe_block, interrupt_level);
+	if (ACPI_FAILURE (status)) {
+		ACPI_MEM_FREE (gpe_block);
+		return_ACPI_STATUS (status);
+	}
+
+	/* Dump info about this GPE block */
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_INIT, "GPE %02d to %02d [%4.4s] %d regs at %8.8X%8.8X on int %d\n",
+		gpe_block->block_base_number,
+		(u32) (gpe_block->block_base_number +
+				((gpe_block->register_count * ACPI_GPE_REGISTER_WIDTH) -1)),
+		gpe_device->name.ascii,
+		gpe_block->register_count,
+		ACPI_HIDWORD (gpe_block->block_address.address),
+		ACPI_LODWORD (gpe_block->block_address.address),
+		interrupt_level));
+
+	/* Find all GPE methods (_Lxx, _Exx) for this block */
+
+	status = acpi_ns_walk_namespace (ACPI_TYPE_METHOD, gpe_device,
+			  ACPI_UINT32_MAX, ACPI_NS_WALK_NO_UNLOCK, acpi_ev_save_method_info,
+			  gpe_block, NULL);
+
+	/* Return the new block */
+
+	if (return_gpe_block) {
+		(*return_gpe_block) = gpe_block;
+	}
+
+	return_ACPI_STATUS (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_gpe_initialize
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Initialize the GPE data structures
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ev_gpe_initialize (void)
+{
+	u32                             register_count0 = 0;
+	u32                             register_count1 = 0;
+	u32                             gpe_number_max = 0;
+	acpi_handle                     gpe_device;
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE ("ev_gpe_initialize");
+
+
+	/* Get a handle to the predefined _GPE object */
+
+	status = acpi_get_handle (NULL, "\\_GPE", &gpe_device);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/*
+	 * Initialize the GPE Blocks defined in the FADT
+	 *
+	 * Why the GPE register block lengths are divided by 2:  From the ACPI Spec,
+	 * section "General-Purpose Event Registers", we have:
+	 *
+	 * "Each register block contains two registers of equal length
+	 *  GPEx_STS and GPEx_EN (where x is 0 or 1). The length of the
+	 *  GPE0_STS and GPE0_EN registers is equal to half the GPE0_LEN
+	 *  The length of the GPE1_STS and GPE1_EN registers is equal to
+	 *  half the GPE1_LEN. If a generic register block is not supported
+	 *  then its respective block pointer and block length values in the
+	 *  FADT table contain zeros. The GPE0_LEN and GPE1_LEN do not need
+	 *  to be the same size."
+	 */
+
+	/*
+	 * Determine the maximum GPE number for this machine.
+	 *
+	 * Note: both GPE0 and GPE1 are optional, and either can exist without
+	 * the other.
+	 *
+	 * If EITHER the register length OR the block address are zero, then that
+	 * particular block is not supported.
+	 */
+	if (acpi_gbl_FADT->gpe0_blk_len &&
+		acpi_gbl_FADT->xgpe0_blk.address) {
+		/* GPE block 0 exists (has both length and address > 0) */
+
+		register_count0 = (u16) (acpi_gbl_FADT->gpe0_blk_len / 2);
+
+		gpe_number_max = (register_count0 * ACPI_GPE_REGISTER_WIDTH) - 1;
+
+		/* Install GPE Block 0 */
+
+		status = acpi_ev_create_gpe_block (gpe_device, &acpi_gbl_FADT->xgpe0_blk,
+				 register_count0, 0, acpi_gbl_FADT->sci_int, &acpi_gbl_gpe_fadt_blocks[0]);
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_ERROR ((
+				"Could not create GPE Block 0, %s\n",
+				acpi_format_exception (status)));
+		}
+	}
+
+	if (acpi_gbl_FADT->gpe1_blk_len &&
+		acpi_gbl_FADT->xgpe1_blk.address) {
+		/* GPE block 1 exists (has both length and address > 0) */
+
+		register_count1 = (u16) (acpi_gbl_FADT->gpe1_blk_len / 2);
+
+		/* Check for GPE0/GPE1 overlap (if both banks exist) */
+
+		if ((register_count0) &&
+			(gpe_number_max >= acpi_gbl_FADT->gpe1_base)) {
+			ACPI_REPORT_ERROR ((
+				"GPE0 block (GPE 0 to %d) overlaps the GPE1 block (GPE %d to %d) - Ignoring GPE1\n",
+				gpe_number_max, acpi_gbl_FADT->gpe1_base,
+				acpi_gbl_FADT->gpe1_base +
+				((register_count1 * ACPI_GPE_REGISTER_WIDTH) - 1)));
+
+			/* Ignore GPE1 block by setting the register count to zero */
+
+			register_count1 = 0;
+		}
+		else {
+			/* Install GPE Block 1 */
+
+			status = acpi_ev_create_gpe_block (gpe_device, &acpi_gbl_FADT->xgpe1_blk,
+					 register_count1, acpi_gbl_FADT->gpe1_base,
+					 acpi_gbl_FADT->sci_int, &acpi_gbl_gpe_fadt_blocks[1]);
+			if (ACPI_FAILURE (status)) {
+				ACPI_REPORT_ERROR ((
+					"Could not create GPE Block 1, %s\n",
+					acpi_format_exception (status)));
+			}
+
+			/*
+			 * GPE0 and GPE1 do not have to be contiguous in the GPE number
+			 * space. However, GPE0 always starts at GPE number zero.
+			 */
+			gpe_number_max = acpi_gbl_FADT->gpe1_base +
+					   ((register_count1 * ACPI_GPE_REGISTER_WIDTH) - 1);
+		}
+	}
+
+	/* Exit if there are no GPE registers */
+
+	if ((register_count0 + register_count1) == 0) {
+		/* GPEs are not required by ACPI, this is OK */
+
+		ACPI_REPORT_INFO (("There are no GPE blocks defined in the FADT\n"));
+		return_ACPI_STATUS (AE_OK);
+	}
+
+	/* Check for Max GPE number out-of-range */
+
+	if (gpe_number_max > ACPI_GPE_MAX) {
+		ACPI_REPORT_ERROR (("Maximum GPE number from FADT is too large: 0x%X\n",
+			gpe_number_max));
+		return_ACPI_STATUS (AE_BAD_VALUE);
+	}
+
+	return_ACPI_STATUS (AE_OK);
+}
+
+
diff -urNp linux-5400/drivers/acpi/events/evmisc.c linux-5410/drivers/acpi/events/evmisc.c
--- linux-5400/drivers/acpi/events/evmisc.c
+++ linux-5410/drivers/acpi/events/evmisc.c
@@ -1,42 +1,92 @@
 /******************************************************************************
  *
- * Module Name: evmisc - ACPI device notification handler dispatch
- *                       and ACPI Global Lock support
- *              $Revision: 35 $
+ * Module Name: evmisc - Miscellaneous event manager support functions
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#include "acpi.h"
-#include "acevents.h"
-#include "acnamesp.h"
-#include "acinterp.h"
-#include "achware.h"
+#include <acpi/acpi.h>
+#include <acpi/acevents.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acinterp.h>
 
 #define _COMPONENT          ACPI_EVENTS
-	 MODULE_NAME         ("evmisc")
+	 ACPI_MODULE_NAME    ("evmisc")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_queue_notify_request
+ * FUNCTION:    acpi_ev_is_notify_object
+ *
+ * PARAMETERS:  Node            - Node to check
+ *
+ * RETURN:      TRUE if notifies allowed on this object
+ *
+ * DESCRIPTION: Check type of node for a object that supports notifies.
+ *
+ *              TBD: This could be replaced by a flag bit in the node.
+ *
+ ******************************************************************************/
+
+u8
+acpi_ev_is_notify_object (
+	struct acpi_namespace_node      *node)
+{
+	switch (node->type) {
+	case ACPI_TYPE_DEVICE:
+	case ACPI_TYPE_PROCESSOR:
+	case ACPI_TYPE_POWER:
+	case ACPI_TYPE_THERMAL:
+		/*
+		 * These are the ONLY objects that can receive ACPI notifications
+		 */
+		return (TRUE);
+
+	default:
+		return (FALSE);
+	}
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_queue_notify_request
  *
  * PARAMETERS:
  *
@@ -49,16 +99,16 @@
 
 acpi_status
 acpi_ev_queue_notify_request (
-	acpi_namespace_node     *node,
-	u32                     notify_value)
+	struct acpi_namespace_node      *node,
+	u32                             notify_value)
 {
-	acpi_operand_object     *obj_desc;
-	acpi_operand_object     *handler_obj = NULL;
-	acpi_generic_state      *notify_info;
-	acpi_status             status = AE_OK;
+	union acpi_operand_object       *obj_desc;
+	union acpi_operand_object       *handler_obj = NULL;
+	union acpi_generic_state        *notify_info;
+	acpi_status                     status = AE_OK;
 
 
-	PROC_NAME ("Ev_queue_notify_request");
+	ACPI_FUNCTION_NAME ("ev_queue_notify_request");
 
 
 	/*
@@ -92,43 +142,38 @@ acpi_ev_queue_notify_request (
 		break;
 	}
 
-
 	/*
-	 * Get the notify object attached to the device Node
+	 * Get the notify object attached to the NS Node
 	 */
 	obj_desc = acpi_ns_get_attached_object (node);
 	if (obj_desc) {
-
 		/* We have the notify object, Get the right handler */
 
 		switch (node->type) {
 		case ACPI_TYPE_DEVICE:
-			if (notify_value <= MAX_SYS_NOTIFY) {
-				handler_obj = obj_desc->device.sys_handler;
-			}
-			else {
-				handler_obj = obj_desc->device.drv_handler;
-			}
-			break;
-
 		case ACPI_TYPE_THERMAL:
-			if (notify_value <= MAX_SYS_NOTIFY) {
-				handler_obj = obj_desc->thermal_zone.sys_handler;
+		case ACPI_TYPE_PROCESSOR:
+		case ACPI_TYPE_POWER:
+
+			if (notify_value <= ACPI_MAX_SYS_NOTIFY) {
+				handler_obj = obj_desc->common_notify.system_notify;
 			}
 			else {
-				handler_obj = obj_desc->thermal_zone.drv_handler;
+				handler_obj = obj_desc->common_notify.device_notify;
 			}
 			break;
+
+		default:
+			/* All other types are not supported */
+			return (AE_TYPE);
 		}
 	}
 
-
 	/* If there is any handler to run, schedule the dispatcher */
 
-	if ((acpi_gbl_sys_notify.handler && (notify_value <= MAX_SYS_NOTIFY)) ||
-		(acpi_gbl_drv_notify.handler && (notify_value > MAX_SYS_NOTIFY)) ||
+	if ((acpi_gbl_system_notify.handler && (notify_value <= ACPI_MAX_SYS_NOTIFY)) ||
+		(acpi_gbl_device_notify.handler && (notify_value > ACPI_MAX_SYS_NOTIFY)) ||
 		handler_obj) {
-
 		notify_info = acpi_ut_create_generic_state ();
 		if (!notify_info) {
 			return (AE_NO_MEMORY);
@@ -149,7 +194,8 @@ acpi_ev_queue_notify_request (
 	if (!handler_obj) {
 		/* There is no per-device notify handler for this device */
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "No notify handler for node %p \n", node));
+		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+			"No notify handler for [%4.4s] node %p\n", node->name.ascii, node));
 	}
 
 	return (status);
@@ -158,7 +204,7 @@ acpi_ev_queue_notify_request (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_notify_dispatch
+ * FUNCTION:    acpi_ev_notify_dispatch
  *
  * PARAMETERS:
  *
@@ -169,42 +215,40 @@ acpi_ev_queue_notify_request (
  *
  ******************************************************************************/
 
-void
+void ACPI_SYSTEM_XFACE
 acpi_ev_notify_dispatch (
-	void                    *context)
+	void                            *context)
 {
-	acpi_generic_state      *notify_info = (acpi_generic_state *) context;
-	acpi_notify_handler     global_handler = NULL;
-	void                    *global_context = NULL;
-	acpi_operand_object     *handler_obj;
+	union acpi_generic_state        *notify_info = (union acpi_generic_state *) context;
+	acpi_notify_handler             global_handler = NULL;
+	void                            *global_context = NULL;
+	union acpi_operand_object       *handler_obj;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	/*
 	 * We will invoke a global notify handler if installed.
 	 * This is done _before_ we invoke the per-device handler attached to the device.
 	 */
-	if (notify_info->notify.value <= MAX_SYS_NOTIFY) {
+	if (notify_info->notify.value <= ACPI_MAX_SYS_NOTIFY) {
 		/* Global system notification handler */
 
-		if (acpi_gbl_sys_notify.handler) {
-			global_handler = acpi_gbl_sys_notify.handler;
-			global_context = acpi_gbl_sys_notify.context;
+		if (acpi_gbl_system_notify.handler) {
+			global_handler = acpi_gbl_system_notify.handler;
+			global_context = acpi_gbl_system_notify.context;
 		}
 	}
-
 	else {
 		/* Global driver notification handler */
 
-		if (acpi_gbl_drv_notify.handler) {
-			global_handler = acpi_gbl_drv_notify.handler;
-			global_context = acpi_gbl_drv_notify.context;
+		if (acpi_gbl_device_notify.handler) {
+			global_handler = acpi_gbl_device_notify.handler;
+			global_context = acpi_gbl_device_notify.context;
 		}
 	}
 
-
 	/* Invoke the system handler first, if present */
 
 	if (global_handler) {
@@ -215,8 +259,8 @@ acpi_ev_notify_dispatch (
 
 	handler_obj = notify_info->notify.handler_obj;
 	if (handler_obj) {
-		handler_obj->notify_handler.handler (notify_info->notify.node, notify_info->notify.value,
-				  handler_obj->notify_handler.context);
+		handler_obj->notify.handler (notify_info->notify.node, notify_info->notify.value,
+				  handler_obj->notify.context);
 	}
 
 	/* All done with the info object */
@@ -227,7 +271,7 @@ acpi_ev_notify_dispatch (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_global_lock_thread
+ * FUNCTION:    acpi_ev_global_lock_thread
  *
  * RETURN:      None
  *
@@ -237,25 +281,30 @@ acpi_ev_notify_dispatch (
  *
  ******************************************************************************/
 
-static void
+static void ACPI_SYSTEM_XFACE
 acpi_ev_global_lock_thread (
-	void                    *context)
+	void                            *context)
 {
+	acpi_status                     status;
+
 
 	/* Signal threads that are waiting for the lock */
 
 	if (acpi_gbl_global_lock_thread_count) {
 		/* Send sufficient units to the semaphore */
 
-		acpi_os_signal_semaphore (acpi_gbl_global_lock_semaphore,
+		status = acpi_os_signal_semaphore (acpi_gbl_global_lock_semaphore,
 				 acpi_gbl_global_lock_thread_count);
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_ERROR (("Could not signal Global Lock semaphore\n"));
+		}
 	}
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_global_lock_handler
+ * FUNCTION:    acpi_ev_global_lock_handler
  *
  * RETURN:      Status
  *
@@ -267,10 +316,10 @@ acpi_ev_global_lock_thread (
 
 static u32
 acpi_ev_global_lock_handler (
-	void                    *context)
+	void                            *context)
 {
-	u8                      acquired = FALSE;
-	void                    *global_lock;
+	u8                              acquired = FALSE;
+	acpi_status                     status;
 
 
 	/*
@@ -278,8 +327,7 @@ acpi_ev_global_lock_handler (
 	 * If we don't get it now, it will be marked pending and we will
 	 * take another interrupt when it becomes free.
 	 */
-	global_lock = acpi_gbl_FACS->global_lock;
-	ACPI_ACQUIRE_GLOBAL_LOCK (global_lock, acquired);
+	ACPI_ACQUIRE_GLOBAL_LOCK (acpi_gbl_common_fACS.global_lock, acquired);
 	if (acquired) {
 		/* Got the lock, now wake all threads waiting for it */
 
@@ -287,17 +335,23 @@ acpi_ev_global_lock_handler (
 
 		/* Run the Global Lock thread which will signal all waiting threads */
 
-		acpi_os_queue_for_execution (OSD_PRIORITY_HIGH, acpi_ev_global_lock_thread,
-				  context);
+		status = acpi_os_queue_for_execution (OSD_PRIORITY_HIGH,
+				  acpi_ev_global_lock_thread, context);
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_ERROR (("Could not queue Global Lock thread, %s\n",
+				acpi_format_exception (status)));
+
+			return (ACPI_INTERRUPT_NOT_HANDLED);
+		}
 	}
 
-	return (INTERRUPT_HANDLED);
+	return (ACPI_INTERRUPT_HANDLED);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_init_global_lock_handler
+ * FUNCTION:    acpi_ev_init_global_lock_handler
  *
  * RETURN:      Status
  *
@@ -308,10 +362,10 @@ acpi_ev_global_lock_handler (
 acpi_status
 acpi_ev_init_global_lock_handler (void)
 {
-	acpi_status             status;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Ev_init_global_lock_handler");
+	ACPI_FUNCTION_TRACE ("ev_init_global_lock_handler");
 
 
 	acpi_gbl_global_lock_present = TRUE;
@@ -320,7 +374,7 @@ acpi_ev_init_global_lock_handler (void)
 
 	/*
 	 * If the global lock does not exist on this platform, the attempt
-	 * to enable GBL_STS will fail (the GBL_EN bit will not stick)
+	 * to enable GBL_STATUS will fail (the GBL_ENABLE bit will not stick)
 	 * Map to AE_OK, but mark global lock as not present.
 	 * Any attempt to actually use the global lock will be flagged
 	 * with an error.
@@ -336,7 +390,7 @@ acpi_ev_init_global_lock_handler (void)
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_ev_acquire_global_lock
+ * FUNCTION:    acpi_ev_acquire_global_lock
  *
  * RETURN:      Status
  *
@@ -345,116 +399,170 @@ acpi_ev_init_global_lock_handler (void)
  *****************************************************************************/
 
 acpi_status
-acpi_ev_acquire_global_lock(void)
+acpi_ev_acquire_global_lock (
+	u16                             timeout)
 {
-	acpi_status             status = AE_OK;
-	u8                      acquired = FALSE;
-	void                    *global_lock;
+	acpi_status                     status = AE_OK;
+	u8                              acquired = FALSE;
 
 
-	FUNCTION_TRACE ("Ev_acquire_global_lock");
+	ACPI_FUNCTION_TRACE ("ev_acquire_global_lock");
 
+
+#ifndef ACPI_APPLICATION
 	/* Make sure that we actually have a global lock */
 
 	if (!acpi_gbl_global_lock_present) {
 		return_ACPI_STATUS (AE_NO_GLOBAL_LOCK);
 	}
+#endif
 
 	/* One more thread wants the global lock */
 
 	acpi_gbl_global_lock_thread_count++;
 
-
-	/* If we (OS side) have the hardware lock already, we are done */
+	/* If we (OS side vs. BIOS side) have the hardware lock already, we are done */
 
 	if (acpi_gbl_global_lock_acquired) {
 		return_ACPI_STATUS (AE_OK);
 	}
 
-	/* Only if the FACS is valid */
-
-	if (!acpi_gbl_FACS) {
-		return_ACPI_STATUS (AE_OK);
-	}
-
-
 	/* We must acquire the actual hardware lock */
 
-	global_lock = acpi_gbl_FACS->global_lock;
-	ACPI_ACQUIRE_GLOBAL_LOCK (global_lock, acquired);
+	ACPI_ACQUIRE_GLOBAL_LOCK (acpi_gbl_common_fACS.global_lock, acquired);
 	if (acquired) {
 	   /* We got the lock */
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Acquired the Global Lock\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Acquired the HW Global Lock\n"));
 
 		acpi_gbl_global_lock_acquired = TRUE;
 		return_ACPI_STATUS (AE_OK);
 	}
 
-
 	/*
 	 * Did not get the lock.  The pending bit was set above, and we must now
 	 * wait until we get the global lock released interrupt.
 	 */
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Waiting for the HW Global Lock\n"));
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Waiting for the HW Global Lock\n"));
 
-	 /*
-	  * Acquire the global lock semaphore first.
-	  * Since this wait will block, we must release the interpreter
-	  */
+	/*
+	 * Acquire the global lock semaphore first.
+	 * Since this wait will block, we must release the interpreter
+	 */
 	status = acpi_ex_system_wait_semaphore (acpi_gbl_global_lock_semaphore,
-			  ACPI_UINT32_MAX);
+			  timeout);
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_release_global_lock
+ * FUNCTION:    acpi_ev_release_global_lock
  *
  * DESCRIPTION: Releases ownership of the Global Lock.
  *
  ******************************************************************************/
 
-void
+acpi_status
 acpi_ev_release_global_lock (void)
 {
-	u8                      pending = FALSE;
-	void                    *global_lock;
+	u8                              pending = FALSE;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE ("Ev_release_global_lock");
+	ACPI_FUNCTION_TRACE ("ev_release_global_lock");
 
 
 	if (!acpi_gbl_global_lock_thread_count) {
-		REPORT_WARNING(("Global Lock has not be acquired, cannot release\n"));
-		return_VOID;
+		ACPI_REPORT_WARNING(("Cannot release HW Global Lock, it has not been acquired\n"));
+		return_ACPI_STATUS (AE_NOT_ACQUIRED);
 	}
 
-   /* One fewer thread has the global lock */
+	/* One fewer thread has the global lock */
 
 	acpi_gbl_global_lock_thread_count--;
+	if (acpi_gbl_global_lock_thread_count) {
+		/* There are still some threads holding the lock, cannot release */
 
-	/* Have all threads released the lock? */
+		return_ACPI_STATUS (AE_OK);
+	}
 
-	if (!acpi_gbl_global_lock_thread_count) {
-		/*
-		 * No more threads holding lock, we can do the actual hardware
-		 * release
-		 */
-		global_lock = acpi_gbl_FACS->global_lock;
-		ACPI_RELEASE_GLOBAL_LOCK (global_lock, pending);
-		acpi_gbl_global_lock_acquired = FALSE;
+	/*
+	 * No more threads holding lock, we can do the actual hardware
+	 * release
+	 */
+	ACPI_RELEASE_GLOBAL_LOCK (acpi_gbl_common_fACS.global_lock, pending);
+	acpi_gbl_global_lock_acquired = FALSE;
 
+	/*
+	 * If the pending bit was set, we must write GBL_RLS to the control
+	 * register
+	 */
+	if (pending) {
+		status = acpi_set_register (ACPI_BITREG_GLOBAL_LOCK_RELEASE, 1, ACPI_MTX_LOCK);
+	}
+
+	return_ACPI_STATUS (status);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_ev_terminate
+ *
+ * PARAMETERS:  none
+ *
+ * RETURN:      none
+ *
+ * DESCRIPTION: Disable events and free memory allocated for table storage.
+ *
+ ******************************************************************************/
+
+void
+acpi_ev_terminate (void)
+{
+	acpi_native_uint                i;
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE ("ev_terminate");
+
+
+	if (acpi_gbl_events_initialized) {
 		/*
-		 * If the pending bit was set, we must write GBL_RLS to the control
-		 * register
+		 * Disable all event-related functionality.
+		 * In all cases, on error, print a message but obviously we don't abort.
 		 */
-		if (pending) {
-			acpi_hw_register_bit_access (ACPI_WRITE, ACPI_MTX_LOCK,
-					 GBL_RLS, 1);
+
+		/* Disable all fixed events */
+
+		for (i = 0; i < ACPI_NUM_FIXED_EVENTS; i++) {
+			status = acpi_disable_event ((u32) i, 0);
+			if (ACPI_FAILURE (status)) {
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not disable fixed event %d\n", (u32) i));
+			}
+		}
+
+		/* Disable all GPEs in all GPE blocks */
+
+		status = acpi_ev_walk_gpe_list (acpi_hw_disable_gpe_block);
+
+		/* Remove SCI handler */
+
+		status = acpi_ev_remove_sci_handler ();
+		if (ACPI_FAILURE(status)) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not remove SCI handler\n"));
 		}
 	}
 
+	/* Return to original mode if necessary */
+
+	if (acpi_gbl_original_mode == ACPI_SYS_MODE_LEGACY) {
+		status = acpi_disable ();
+		if (ACPI_FAILURE (status)) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "acpi_disable failed\n"));
+		}
+	}
 	return_VOID;
 }
+
diff -urNp linux-5400/drivers/acpi/events/evregion.c linux-5410/drivers/acpi/events/evregion.c
--- linux-5400/drivers/acpi/events/evregion.c
+++ linux-5410/drivers/acpi/events/evregion.c
@@ -1,66 +1,93 @@
 /******************************************************************************
  *
- * Module Name: evregion - ACPI Address_space (Op_region) handler dispatch
- *              $Revision: 113 $
+ * Module Name: evregion - ACPI address_space (op_region) handler dispatch
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acevents.h"
-#include "acnamesp.h"
-#include "acinterp.h"
-#include "amlcode.h"
+#include <acpi/acpi.h>
+#include <acpi/acevents.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acinterp.h>
 
 #define _COMPONENT          ACPI_EVENTS
-	 MODULE_NAME         ("evregion")
+	 ACPI_MODULE_NAME    ("evregion")
+
+#define ACPI_NUM_DEFAULT_SPACES     4
+
+u8                              acpi_gbl_default_address_spaces[ACPI_NUM_DEFAULT_SPACES] = {
+			 ACPI_ADR_SPACE_SYSTEM_MEMORY,
+			 ACPI_ADR_SPACE_SYSTEM_IO,
+			 ACPI_ADR_SPACE_PCI_CONFIG,
+			 ACPI_ADR_SPACE_DATA_TABLE};
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_install_default_address_space_handlers
+ * FUNCTION:    acpi_ev_init_address_spaces
  *
- * PARAMETERS:
+ * PARAMETERS:  None
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Installs the core subsystem address space handlers.
+ * DESCRIPTION: Installs the core subsystem default address space handlers.
  *
  ******************************************************************************/
 
 acpi_status
-acpi_ev_install_default_address_space_handlers (
-	void)
-{
-	acpi_status             status;
+acpi_ev_init_address_spaces (
+	void) {
+	acpi_status                     status;
+	acpi_native_uint                i;
 
 
-	FUNCTION_TRACE ("Ev_install_default_address_space_handlers");
+	ACPI_FUNCTION_TRACE ("ev_init_address_spaces");
 
 
 	/*
 	 * All address spaces (PCI Config, EC, SMBus) are scope dependent
-	 * and registration must occur for a specific device.  In the case
-	 * system memory and IO address spaces there is currently no device
-	 * associated with the address space.  For these we use the root.
+	 * and registration must occur for a specific device.
+	 *
+	 * In the case of the system memory and IO address spaces there is currently
+	 * no device associated with the address space.  For these we use the root.
+	 *
 	 * We install the default PCI config space handler at the root so
 	 * that this space is immediately available even though the we have
 	 * not enumerated all the PCI Root Buses yet.  This is to conform
@@ -68,45 +95,39 @@ acpi_ev_install_default_address_space_ha
 	 * space must be always available -- even though we are nowhere
 	 * near ready to find the PCI root buses at this point.
 	 *
-	 * NOTE: We ignore AE_EXIST because this means that a handler has
-	 * already been installed (via Acpi_install_address_space_handler)
+	 * NOTE: We ignore AE_ALREADY_EXISTS because this means that a handler
+	 * has already been installed (via acpi_install_address_space_handler).
+	 * Similar for AE_SAME_HANDLER.
 	 */
-	status = acpi_install_address_space_handler (acpi_gbl_root_node,
-			   ACPI_ADR_SPACE_SYSTEM_MEMORY,
-			   ACPI_DEFAULT_HANDLER, NULL, NULL);
-	if ((ACPI_FAILURE (status)) &&
-		(status != AE_EXIST)) {
-		return_ACPI_STATUS (status);
-	}
-
-	status = acpi_install_address_space_handler (acpi_gbl_root_node,
-			   ACPI_ADR_SPACE_SYSTEM_IO,
-			   ACPI_DEFAULT_HANDLER, NULL, NULL);
-	if ((ACPI_FAILURE (status)) &&
-		(status != AE_EXIST)) {
-		return_ACPI_STATUS (status);
-	}
-
-	status = acpi_install_address_space_handler (acpi_gbl_root_node,
-			   ACPI_ADR_SPACE_PCI_CONFIG,
-			   ACPI_DEFAULT_HANDLER, NULL, NULL);
-	if ((ACPI_FAILURE (status)) &&
-		(status != AE_EXIST)) {
-		return_ACPI_STATUS (status);
-	}
 
+	for (i = 0; i < ACPI_NUM_DEFAULT_SPACES; i++) {
+		status = acpi_install_address_space_handler ((acpi_handle) acpi_gbl_root_node,
+				  acpi_gbl_default_address_spaces[i],
+				  ACPI_DEFAULT_HANDLER, NULL, NULL);
+		switch (status) {
+		case AE_OK:
+		case AE_SAME_HANDLER:
+		case AE_ALREADY_EXISTS:
+
+			/* These exceptions are all OK */
+
+			break;
+
+		default:
+
+			return_ACPI_STATUS (status);
+		}
+	}
 
 	return_ACPI_STATUS (AE_OK);
 }
 
 
-/* TBD: [Restructure] Move elsewhere */
-
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_execute_reg_method
+ * FUNCTION:    acpi_ev_execute_reg_method
  *
- * PARAMETERS:  Region_obj          - Object structure
+ * PARAMETERS:  region_obj          - Object structure
  *              Function            - On (1) or Off (0)
  *
  * RETURN:      Status
@@ -117,25 +138,31 @@ acpi_ev_install_default_address_space_ha
 
 static acpi_status
 acpi_ev_execute_reg_method (
-	acpi_operand_object    *region_obj,
-	u32                     function)
+	union acpi_operand_object      *region_obj,
+	u32                             function)
 {
-	acpi_operand_object    *params[3];
-	acpi_status             status;
+	union acpi_operand_object      *params[3];
+	union acpi_operand_object      *region_obj2;
+	acpi_status                     status;
+
 
+	ACPI_FUNCTION_TRACE ("ev_execute_reg_method");
 
-	FUNCTION_TRACE ("Ev_execute_reg_method");
 
+	region_obj2 = acpi_ns_get_secondary_object (region_obj);
+	if (!region_obj2) {
+		return_ACPI_STATUS (AE_NOT_EXIST);
+	}
 
-	if (region_obj->region.extra->extra.method_REG == NULL) {
+	if (region_obj2->extra.method_REG == NULL) {
 		return_ACPI_STATUS (AE_OK);
 	}
 
 	/*
-	 *  _REG method has two arguments
-	 *  Arg0:   Integer: Operation region space ID
-	 *          Same value as Region_obj->Region.Space_id
-	 *  Arg1:   Integer: connection status
+	 * _REG method has two arguments
+	 * Arg0:   Integer: Operation region space ID
+	 *          Same value as region_obj->Region.space_id
+	 * Arg1:   Integer: connection status
 	 *          1 for connecting the handler,
 	 *          0 for disconnecting the handler
 	 *          Passed as a parameter
@@ -151,18 +178,16 @@ acpi_ev_execute_reg_method (
 		goto cleanup;
 	}
 
-	/*
-	 *  Set up the parameter objects
-	 */
-	params[0]->integer.value  = region_obj->region.space_id;
+	/* Set up the parameter objects */
+
+	params[0]->integer.value = region_obj->region.space_id;
 	params[1]->integer.value = function;
 	params[2] = NULL;
 
-	/*
-	 *  Execute the method, no return value
-	 */
-	DEBUG_EXEC(acpi_ut_display_init_pathname (region_obj->region.extra->extra.method_REG, " [Method]"));
-	status = acpi_ns_evaluate_by_handle (region_obj->region.extra->extra.method_REG, params, NULL);
+	/* Execute the method, no return value */
+
+	ACPI_DEBUG_EXEC(acpi_ut_display_init_pathname (ACPI_TYPE_METHOD, region_obj2->extra.method_REG, NULL));
+	status = acpi_ns_evaluate_by_handle (region_obj2->extra.method_REG, params, NULL);
 
 	acpi_ut_remove_reference (params[1]);
 
@@ -175,13 +200,13 @@ cleanup:
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_address_space_dispatch
+ * FUNCTION:    acpi_ev_address_space_dispatch
  *
- * PARAMETERS:  Region_obj          - internal region object
- *              Space_id            - ID of the address space (0-255)
+ * PARAMETERS:  region_obj          - internal region object
+ *              space_id            - ID of the address space (0-255)
  *              Function            - Read or Write operation
  *              Address             - Where in the space to read or write
- *              Bit_width           - Field width in bits (8, 16, or 32)
+ *              bit_width           - Field width in bits (8, 16, 32, or 64)
  *              Value               - Pointer to in or out value
  *
  * RETURN:      Status
@@ -193,121 +218,142 @@ cleanup:
 
 acpi_status
 acpi_ev_address_space_dispatch (
-	acpi_operand_object     *region_obj,
-	u32                     function,
-	ACPI_PHYSICAL_ADDRESS   address,
-	u32                     bit_width,
-	u32                     *value)
+	union acpi_operand_object       *region_obj,
+	u32                             function,
+	acpi_physical_address           address,
+	u32                             bit_width,
+	void                            *value)
 {
-	acpi_status             status;
-	acpi_adr_space_handler  handler;
-	acpi_adr_space_setup    region_setup;
-	acpi_operand_object     *handler_desc;
-	void                    *region_context = NULL;
+	acpi_status                     status;
+	acpi_status                     status2;
+	acpi_adr_space_handler          handler;
+	acpi_adr_space_setup            region_setup;
+	union acpi_operand_object       *handler_desc;
+	union acpi_operand_object       *region_obj2;
+	void                            *region_context = NULL;
 
 
-	FUNCTION_TRACE ("Ev_address_space_dispatch");
+	ACPI_FUNCTION_TRACE ("ev_address_space_dispatch");
 
 
-	/*
-	 * Ensure that there is a handler associated with this region
-	 */
-	handler_desc = region_obj->region.addr_handler;
+	region_obj2 = acpi_ns_get_secondary_object (region_obj);
+	if (!region_obj2) {
+		return_ACPI_STATUS (AE_NOT_EXIST);
+	}
+
+	/* Ensure that there is a handler associated with this region */
+
+	handler_desc = region_obj->region.address_space;
 	if (!handler_desc) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "no handler for region(%p) [%s]\n",
 			region_obj, acpi_ut_get_region_name (region_obj->region.space_id)));
 
-		return_ACPI_STATUS(AE_NOT_EXIST);
+		return_ACPI_STATUS (AE_NOT_EXIST);
 	}
 
 	/*
 	 * It may be the case that the region has never been initialized
 	 * Some types of regions require special init code
 	 */
-	if (!(region_obj->region.flags & AOPOBJ_INITIALIZED)) {
+	if (!(region_obj->region.flags & AOPOBJ_SETUP_COMPLETE)) {
 		/*
 		 * This region has not been initialized yet, do it
 		 */
-		region_setup = handler_desc->addr_handler.setup;
+		region_setup = handler_desc->address_space.setup;
 		if (!region_setup) {
-			/*
-			 *  Bad news, no init routine and not init'd
-			 */
+			/* No initialization routine, exit with error */
+
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No init routine for region(%p) [%s]\n",
 				region_obj, acpi_ut_get_region_name (region_obj->region.space_id)));
-			return_ACPI_STATUS (AE_UNKNOWN_STATUS);
+			return_ACPI_STATUS (AE_NOT_EXIST);
 		}
 
 		/*
 		 * We must exit the interpreter because the region setup will potentially
-		 * execute control methods
+		 * execute control methods (e.g., _REG method for this region)
 		 */
 		acpi_ex_exit_interpreter ();
 
 		status = region_setup (region_obj, ACPI_REGION_ACTIVATE,
-				  handler_desc->addr_handler.context, &region_context);
+				  handler_desc->address_space.context, &region_context);
 
 		/* Re-enter the interpreter */
 
-		acpi_ex_enter_interpreter ();
+		status2 = acpi_ex_enter_interpreter ();
+		if (ACPI_FAILURE (status2)) {
+			return_ACPI_STATUS (status2);
+		}
+
+		/* Check for failure of the Region Setup */
 
-		/*
-		 *  Init routine may fail
-		 */
 		if (ACPI_FAILURE (status)) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Region Init: %s [%s]\n",
 				acpi_format_exception (status),
 				acpi_ut_get_region_name (region_obj->region.space_id)));
-			return_ACPI_STATUS(status);
+			return_ACPI_STATUS (status);
 		}
 
-		region_obj->region.flags |= AOPOBJ_INITIALIZED;
-
 		/*
-		 *  Save the returned context for use in all accesses to
-		 *  this particular region.
+		 * Region initialization may have been completed by region_setup
 		 */
-		region_obj->region.extra->extra.region_context = region_context;
+		if (!(region_obj->region.flags & AOPOBJ_SETUP_COMPLETE)) {
+			region_obj->region.flags |= AOPOBJ_SETUP_COMPLETE;
+
+			if (region_obj2->extra.region_context) {
+				/* The handler for this region was already installed */
+
+				ACPI_MEM_FREE (region_context);
+			}
+			else {
+				/*
+				 * Save the returned context for use in all accesses to
+				 * this particular region
+				 */
+				region_obj2->extra.region_context = region_context;
+			}
+		}
 	}
 
-	/*
-	 *  We have everything we need, begin the process
-	 */
-	handler = handler_desc->addr_handler.handler;
+	/* We have everything we need, we can invoke the address space handler */
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
-		"Addrhandler %p (%p), Address %8.8X%8.8X\n",
-		&region_obj->region.addr_handler->addr_handler, handler, HIDWORD(address),
-		LODWORD(address)));
+	handler = handler_desc->address_space.handler;
 
-	if (!(handler_desc->addr_handler.flags & ADDR_HANDLER_DEFAULT_INSTALLED)) {
-		/*
-		 *  For handlers other than the default (supplied) handlers, we must
-		 *  exit the interpreter because the handler *might* block -- we don't
-		 *  know what it will do, so we can't hold the lock on the intepreter.
+	ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
+		"Handler %p (@%p) Address %8.8X%8.8X [%s]\n",
+		&region_obj->region.address_space->address_space, handler,
+		ACPI_HIDWORD (address), ACPI_LODWORD (address),
+		acpi_ut_get_region_name (region_obj->region.space_id)));
+
+	if (!(handler_desc->address_space.flags & ACPI_ADDR_HANDLER_DEFAULT_INSTALLED)) {
+		/*
+		 * For handlers other than the default (supplied) handlers, we must
+		 * exit the interpreter because the handler *might* block -- we don't
+		 * know what it will do, so we can't hold the lock on the intepreter.
 		 */
 		acpi_ex_exit_interpreter();
 	}
 
-	/*
-	 *  Invoke the handler.
-	 */
+	/* Call the handler */
+
 	status = handler (function, address, bit_width, value,
-			 handler_desc->addr_handler.context,
-			 region_obj->region.extra->extra.region_context);
+			 handler_desc->address_space.context,
+			 region_obj2->extra.region_context);
 
 	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Region handler: %s [%s]\n",
-			acpi_format_exception (status),
-			acpi_ut_get_region_name (region_obj->region.space_id)));
+		ACPI_REPORT_ERROR (("Handler for [%s] returned %s\n",
+			acpi_ut_get_region_name (region_obj->region.space_id),
+			acpi_format_exception (status)));
 	}
 
-	if (!(handler_desc->addr_handler.flags & ADDR_HANDLER_DEFAULT_INSTALLED)) {
+	if (!(handler_desc->address_space.flags & ACPI_ADDR_HANDLER_DEFAULT_INSTALLED)) {
 		/*
 		 * We just returned from a non-default handler, we must re-enter the
 		 * interpreter
 		 */
-		acpi_ex_enter_interpreter ();
+		status2 = acpi_ex_enter_interpreter ();
+		if (ACPI_FAILURE (status2)) {
+			return_ACPI_STATUS (status2);
+		}
 	}
 
 	return_ACPI_STATUS (status);
@@ -315,10 +361,10 @@ acpi_ev_address_space_dispatch (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_disassociate_region_from_handler
+ * FUNCTION:    acpi_ev_detach_region
  *
- * PARAMETERS:  Region_obj      - Region Object
- *              Acpi_ns_is_locked - Namespace Region Already Locked?
+ * PARAMETERS:  region_obj      - Region Object
+ *              acpi_ns_is_locked - Namespace Region Already Locked?
  *
  * RETURN:      None
  *
@@ -328,112 +374,118 @@ acpi_ev_address_space_dispatch (
  ******************************************************************************/
 
 void
-acpi_ev_disassociate_region_from_handler(
-	acpi_operand_object     *region_obj,
-	u8                      acpi_ns_is_locked)
+acpi_ev_detach_region(
+	union acpi_operand_object       *region_obj,
+	u8                              acpi_ns_is_locked)
 {
-	acpi_operand_object     *handler_obj;
-	acpi_operand_object     *obj_desc;
-	acpi_operand_object     **last_obj_ptr;
-	acpi_adr_space_setup    region_setup;
-	void                    *region_context;
-	acpi_status             status;
+	union acpi_operand_object       *handler_obj;
+	union acpi_operand_object       *obj_desc;
+	union acpi_operand_object       **last_obj_ptr;
+	acpi_adr_space_setup            region_setup;
+	void                            *region_context;
+	union acpi_operand_object       *region_obj2;
+	acpi_status                     status;
+
 
+	ACPI_FUNCTION_TRACE ("ev_detach_region");
 
-	FUNCTION_TRACE ("Ev_disassociate_region_from_handler");
 
+	region_obj2 = acpi_ns_get_secondary_object (region_obj);
+	if (!region_obj2) {
+		return_VOID;
+	}
+	region_context = region_obj2->extra.region_context;
 
-	region_context = region_obj->region.extra->extra.region_context;
+	/* Get the address handler from the region object */
 
-	/*
-	 *  Get the address handler from the region object
-	 */
-	handler_obj = region_obj->region.addr_handler;
+	handler_obj = region_obj->region.address_space;
 	if (!handler_obj) {
-		/*
-		 *  This region has no handler, all done
-		 */
+		/* This region has no handler, all done */
+
 		return_VOID;
 	}
 
+	/* Find this region in the handler's list */
 
-	/*
-	 *  Find this region in the handler's list
-	 */
-	obj_desc = handler_obj->addr_handler.region_list;
-	last_obj_ptr = &handler_obj->addr_handler.region_list;
+	obj_desc = handler_obj->address_space.region_list;
+	last_obj_ptr = &handler_obj->address_space.region_list;
 
 	while (obj_desc) {
-		/*
-		 *  See if this is the one
-		 */
+		/* Is this the correct Region? */
+
 		if (obj_desc == region_obj) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
 				"Removing Region %p from address handler %p\n",
 				region_obj, handler_obj));
-			/*
-			 *  This is it, remove it from the handler's list
-			 */
+
+			/* This is it, remove it from the handler's list */
+
 			*last_obj_ptr = obj_desc->region.next;
 			obj_desc->region.next = NULL;           /* Must clear field */
 
 			if (acpi_ns_is_locked) {
-				acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+				status = acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+				if (ACPI_FAILURE (status)) {
+					return_VOID;
+				}
 			}
 
-			/*
-			 *  Now stop region accesses by executing the _REG method
-			 */
-			acpi_ev_execute_reg_method (region_obj, 0);
+			/* Now stop region accesses by executing the _REG method */
+
+			status = acpi_ev_execute_reg_method (region_obj, 0);
+			if (ACPI_FAILURE (status)) {
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "%s from region _REG, [%s]\n",
+					acpi_format_exception (status),
+					acpi_ut_get_region_name (region_obj->region.space_id)));
+			}
 
 			if (acpi_ns_is_locked) {
-				acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+				status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+				if (ACPI_FAILURE (status)) {
+					return_VOID;
+				}
 			}
 
-			/*
-			 *  Call the setup handler with the deactivate notification
-			 */
-			region_setup = handler_obj->addr_handler.setup;
+			/* Call the setup handler with the deactivate notification */
+
+			region_setup = handler_obj->address_space.setup;
 			status = region_setup (region_obj, ACPI_REGION_DEACTIVATE,
-					  handler_obj->addr_handler.context, &region_context);
+					  handler_obj->address_space.context, &region_context);
+
+			/* Init routine may fail, Just ignore errors */
 
-			/*
-			 *  Init routine may fail, Just ignore errors
-			 */
 			if (ACPI_FAILURE (status)) {
 				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "%s from region init, [%s]\n",
 					acpi_format_exception (status),
 					acpi_ut_get_region_name (region_obj->region.space_id)));
 			}
 
-			region_obj->region.flags &= ~(AOPOBJ_INITIALIZED);
+			region_obj->region.flags &= ~(AOPOBJ_SETUP_COMPLETE);
 
 			/*
-			 *  Remove handler reference in the region
+			 * Remove handler reference in the region
 			 *
-			 *  NOTE: this doesn't mean that the region goes away
-			 *  The region is just inaccessible as indicated to
-			 *  the _REG method
+			 * NOTE: this doesn't mean that the region goes away
+			 * The region is just inaccessible as indicated to
+			 * the _REG method
 			 *
-			 *  If the region is on the handler's list
-			 *  this better be the region's handler
+			 * If the region is on the handler's list
+			 * this better be the region's handler
 			 */
-			region_obj->region.addr_handler = NULL;
+			region_obj->region.address_space = NULL;
+			acpi_ut_remove_reference (handler_obj);
 
 			return_VOID;
+		}
 
-		} /* found the right handler */
+		/* Walk the linked list of handlers */
 
-		/*
-		 *  Move through the linked list of handlers
-		 */
 		last_obj_ptr = &obj_desc->region.next;
 		obj_desc = obj_desc->region.next;
 	}
 
-	/*
-	 *  If we get here, the region was not in the handler's region list
-	 */
+	/* If we get here, the region was not in the handler's region list */
+
 	ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
 		"Cannot remove region %p from address handler %p\n",
 		region_obj, handler_obj));
@@ -444,11 +496,11 @@ acpi_ev_disassociate_region_from_handler
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_associate_region_and_handler
+ * FUNCTION:    acpi_ev_attach_region
  *
- * PARAMETERS:  Handler_obj     - Handler Object
- *              Region_obj      - Region Object
- *              Acpi_ns_is_locked - Namespace Region Already Locked?
+ * PARAMETERS:  handler_obj     - Handler Object
+ *              region_obj      - Region Object
+ *              acpi_ns_is_locked - Namespace Region Already Locked?
  *
  * RETURN:      None
  *
@@ -458,15 +510,16 @@ acpi_ev_disassociate_region_from_handler
  ******************************************************************************/
 
 acpi_status
-acpi_ev_associate_region_and_handler (
-	acpi_operand_object     *handler_obj,
-	acpi_operand_object     *region_obj,
-	u8                      acpi_ns_is_locked)
+acpi_ev_attach_region (
+	union acpi_operand_object       *handler_obj,
+	union acpi_operand_object       *region_obj,
+	u8                              acpi_ns_is_locked)
 {
-	acpi_status     status;
+	acpi_status                     status;
+	acpi_status                     status2;
 
 
-	FUNCTION_TRACE ("Ev_associate_region_and_handler");
+	ACPI_FUNCTION_TRACE ("ev_attach_region");
 
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
@@ -474,28 +527,38 @@ acpi_ev_associate_region_and_handler (
 		region_obj, handler_obj, acpi_ut_get_region_name (region_obj->region.space_id)));
 
 
-	/*
-	 *  Link this region to the front of the handler's list
-	 */
-	region_obj->region.next = handler_obj->addr_handler.region_list;
-	handler_obj->addr_handler.region_list = region_obj;
+	/* Link this region to the front of the handler's list */
 
-	/*
-	 *  set the region's handler
-	 */
-	region_obj->region.addr_handler = handler_obj;
+	region_obj->region.next = handler_obj->address_space.region_list;
+	handler_obj->address_space.region_list = region_obj;
+
+	/* Install the region's handler */
+
+	if (region_obj->region.address_space) {
+		return_ACPI_STATUS (AE_ALREADY_EXISTS);
+	}
+
+	region_obj->region.address_space = handler_obj;
+	acpi_ut_add_reference (handler_obj);
 
 	/*
-	 *  Last thing, tell all users that this region is usable
+	 * Tell all users that this region is usable by running the _REG
+	 * method
 	 */
 	if (acpi_ns_is_locked) {
-		acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+		status2 = acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+		if (ACPI_FAILURE (status2)) {
+			return_ACPI_STATUS (status2);
+		}
 	}
 
 	status = acpi_ev_execute_reg_method (region_obj, 1);
 
 	if (acpi_ns_is_locked) {
-		acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+		status2 = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+		if (ACPI_FAILURE (status2)) {
+			return_ACPI_STATUS (status2);
+		}
 	}
 
 	return_ACPI_STATUS (status);
@@ -504,14 +567,14 @@ acpi_ev_associate_region_and_handler (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_addr_handler_helper
+ * FUNCTION:    acpi_ev_install_handler
  *
  * PARAMETERS:  Handle              - Node to be dumped
  *              Level               - Nesting level of the handle
- *              Context             - Passed into Acpi_ns_walk_namespace
+ *              Context             - Passed into acpi_ns_walk_namespace
  *
- * DESCRIPTION: This routine checks to see if the object is a Region if it
- *              is then the address handler is installed in it.
+ * DESCRIPTION: This routine installs an address handler into objects that are
+ *              of type Region or Device.
  *
  *              If the Object is a Device, and the device has a handler of
  *              the same type then the search is terminated in that branch.
@@ -522,23 +585,23 @@ acpi_ev_associate_region_and_handler (
  ******************************************************************************/
 
 acpi_status
-acpi_ev_addr_handler_helper (
-	acpi_handle             obj_handle,
-	u32                     level,
-	void                    *context,
-	void                    **return_value)
+acpi_ev_install_handler (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *context,
+	void                            **return_value)
 {
-	acpi_operand_object     *handler_obj;
-	acpi_operand_object     *tmp_obj;
-	acpi_operand_object     *obj_desc;
-	acpi_namespace_node     *node;
-	acpi_status             status;
+	union acpi_operand_object       *handler_obj;
+	union acpi_operand_object       *next_handler_obj;
+	union acpi_operand_object       *obj_desc;
+	struct acpi_namespace_node      *node;
+	acpi_status                     status;
 
 
-	PROC_NAME ("Ev_addr_handler_helper");
+	ACPI_FUNCTION_NAME ("ev_install_handler");
 
 
-	handler_obj = (acpi_operand_object *) context;
+	handler_obj = (union acpi_operand_object   *) context;
 
 	/* Parameter validation */
 
@@ -554,8 +617,8 @@ acpi_ev_addr_handler_helper (
 	}
 
 	/*
-	 *  We only care about regions.and objects
-	 *  that can have address handlers
+	 * We only care about regions.and objects
+	 * that are allowed to have address space handlers
 	 */
 	if ((node->type != ACPI_TYPE_DEVICE) &&
 		(node->type != ACPI_TYPE_REGION) &&
@@ -567,81 +630,70 @@ acpi_ev_addr_handler_helper (
 
 	obj_desc = acpi_ns_get_attached_object (node);
 	if (!obj_desc) {
-		/*
-		 *  The object DNE, we don't care about it
-		 */
+		/* No object, just exit */
+
 		return (AE_OK);
 	}
 
-	/*
-	 *  Devices are handled different than regions
-	 */
-	if (IS_THIS_OBJECT_TYPE (obj_desc, ACPI_TYPE_DEVICE)) {
-		/*
-		 *  See if this guy has any handlers
-		 */
-		tmp_obj = obj_desc->device.addr_handler;
-		while (tmp_obj) {
-			/*
-			 *  Now let's see if it's for the same address space.
-			 */
-			if (tmp_obj->addr_handler.space_id == handler_obj->addr_handler.space_id) {
-				/*
-				 *  It's for the same address space
-				 */
+	/* Devices are handled different than regions */
+
+	if (ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_DEVICE) {
+		/* Check if this Device already has a handler for this address space */
+
+		next_handler_obj = obj_desc->device.address_space;
+		while (next_handler_obj) {
+			/* Found a handler, is it for the same address space? */
+
+			if (next_handler_obj->address_space.space_id == handler_obj->address_space.space_id) {
 				ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
 					"Found handler for region [%s] in device %p(%p) handler %p\n",
-					acpi_ut_get_region_name (handler_obj->addr_handler.space_id),
-					obj_desc, tmp_obj, handler_obj));
+					acpi_ut_get_region_name (handler_obj->address_space.space_id),
+					obj_desc, next_handler_obj, handler_obj));
 
 				/*
-				 *  Since the object we found it on was a device, then it
-				 *  means that someone has already installed a handler for
-				 *  the branch of the namespace from this device on.  Just
-				 *  bail out telling the walk routine to not traverse this
-				 *  branch.  This preserves the scoping rule for handlers.
+				 * Since the object we found it on was a device, then it
+				 * means that someone has already installed a handler for
+				 * the branch of the namespace from this device on.  Just
+				 * bail out telling the walk routine to not traverse this
+				 * branch.  This preserves the scoping rule for handlers.
 				 */
 				return (AE_CTRL_DEPTH);
 			}
 
-			/*
-			 *  Move through the linked list of handlers
-			 */
-			tmp_obj = tmp_obj->addr_handler.next;
+			/* Walk the linked list of handlers attached to this device */
+
+			next_handler_obj = next_handler_obj->address_space.next;
 		}
 
 		/*
-		 *  As long as the device didn't have a handler for this
-		 *  space we don't care about it.  We just ignore it and
-		 *  proceed.
+		 * As long as the device didn't have a handler for this
+		 * space we don't care about it.  We just ignore it and
+		 * proceed.
 		 */
 		return (AE_OK);
 	}
 
-	/*
-	 *  Only here if it was a region
-	 */
-	if (obj_desc->region.space_id != handler_obj->addr_handler.space_id) {
+	/* Object is a Region */
+
+	if (obj_desc->region.space_id != handler_obj->address_space.space_id) {
 		/*
-		 *  This region is for a different address space
-		 *  ignore it
+		 * This region is for a different address space
+		 * -- just ignore it
 		 */
 		return (AE_OK);
 	}
 
 	/*
-	 *  Now we have a region and it is for the handler's address
-	 *  space type.
+	 * Now we have a region and it is for the handler's address
+	 * space type.
 	 *
-	 *  First disconnect region for any previous handler (if any)
+	 * First disconnect region for any previous handler (if any)
 	 */
-	acpi_ev_disassociate_region_from_handler (obj_desc, FALSE);
+	acpi_ev_detach_region (obj_desc, FALSE);
 
-	/*
-	 *  Then connect the region to the new handler
-	 */
-	status = acpi_ev_associate_region_and_handler (handler_obj, obj_desc, FALSE);
+	/* Connect the region to the new handler */
 
+	status = acpi_ev_attach_region (handler_obj, obj_desc, FALSE);
 	return (status);
 }
 
diff -urNp linux-5400/drivers/acpi/events/evrgnini.c linux-5410/drivers/acpi/events/evrgnini.c
--- linux-5400/drivers/acpi/events/evrgnini.c
+++ linux-5410/drivers/acpi/events/evrgnini.c
@@ -1,47 +1,63 @@
 /******************************************************************************
  *
- * Module Name: evrgnini- ACPI Address_space (Op_region) init
- *              $Revision: 48 $
+ * Module Name: evrgnini- ACPI address_space (op_region) init
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acevents.h"
-#include "acnamesp.h"
-#include "acinterp.h"
-#include "amlcode.h"
+#include <acpi/acpi.h>
+#include <acpi/acevents.h>
+#include <acpi/acnamesp.h>
 
 #define _COMPONENT          ACPI_EVENTS
-	 MODULE_NAME         ("evrgnini")
+	 ACPI_MODULE_NAME    ("evrgnini")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_system_memory_region_setup
+ * FUNCTION:    acpi_ev_system_memory_region_setup
  *
- * PARAMETERS:  Region_obj          - region we are interested in
- *              Function            - start or stop
- *              Handler_context     - Address space handler context
- *              Region_context      - Region specific context
+ * PARAMETERS:  region_obj          - Region we are interested in
+ *              Function            - Start or stop
+ *              handler_context     - Address space handler context
+ *              region_context      - Region specific context
  *
  * RETURN:      Status
  *
@@ -51,12 +67,16 @@
 
 acpi_status
 acpi_ev_system_memory_region_setup (
-	acpi_handle             handle,
-	u32                     function,
-	void                    *handler_context,
-	void                    **region_context)
+	acpi_handle                     handle,
+	u32                             function,
+	void                            *handler_context,
+	void                            **region_context)
 {
-	FUNCTION_TRACE ("Ev_system_memory_region_setup");
+	union acpi_operand_object       *region_desc = (union acpi_operand_object *) handle;
+	struct acpi_mem_space_context   *local_region_context;
+
+
+	ACPI_FUNCTION_TRACE ("ev_system_memory_region_setup");
 
 
 	if (function == ACPI_REGION_DEACTIVATE) {
@@ -67,26 +87,31 @@ acpi_ev_system_memory_region_setup (
 		return_ACPI_STATUS (AE_OK);
 	}
 
+	/* Create a new context */
 
-	/* Activate.  Create a new context */
-
-	*region_context = ACPI_MEM_CALLOCATE (sizeof (acpi_mem_space_context));
-	if (!(*region_context)) {
+	local_region_context = ACPI_MEM_CALLOCATE (sizeof (struct acpi_mem_space_context));
+	if (!(local_region_context)) {
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
+	/* Save the region length and address for use in the handler */
+
+	local_region_context->length = region_desc->region.length;
+	local_region_context->address = region_desc->region.address;
+
+	*region_context = local_region_context;
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_io_space_region_setup
+ * FUNCTION:    acpi_ev_io_space_region_setup
  *
- * PARAMETERS:  Region_obj          - region we are interested in
- *              Function            - start or stop
- *              Handler_context     - Address space handler context
- *              Region_context      - Region specific context
+ * PARAMETERS:  region_obj          - Region we are interested in
+ *              Function            - Start or stop
+ *              handler_context     - Address space handler context
+ *              region_context      - Region specific context
  *
  * RETURN:      Status
  *
@@ -96,12 +121,12 @@ acpi_ev_system_memory_region_setup (
 
 acpi_status
 acpi_ev_io_space_region_setup (
-	acpi_handle             handle,
-	u32                     function,
-	void                    *handler_context,
-	void                    **region_context)
+	acpi_handle                     handle,
+	u32                             function,
+	void                            *handler_context,
+	void                            **region_context)
 {
-	FUNCTION_TRACE ("Ev_io_space_region_setup");
+	ACPI_FUNCTION_TRACE ("ev_io_space_region_setup");
 
 
 	if (function == ACPI_REGION_DEACTIVATE) {
@@ -117,12 +142,12 @@ acpi_ev_io_space_region_setup (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_pci_config_region_setup
+ * FUNCTION:    acpi_ev_pci_config_region_setup
  *
- * PARAMETERS:  Region_obj          - region we are interested in
- *              Function            - start or stop
- *              Handler_context     - Address space handler context
- *              Region_context      - Region specific context
+ * PARAMETERS:  region_obj          - Region we are interested in
+ *              Function            - Start or stop
+ *              handler_context     - Address space handler context
+ *              region_context      - Region specific context
  *
  * RETURN:      Status
  *
@@ -134,128 +159,155 @@ acpi_ev_io_space_region_setup (
 
 acpi_status
 acpi_ev_pci_config_region_setup (
-	acpi_handle             handle,
-	u32                     function,
-	void                    *handler_context,
-	void                    **region_context)
+	acpi_handle                     handle,
+	u32                             function,
+	void                            *handler_context,
+	void                            **region_context)
 {
-	acpi_status             status = AE_OK;
-	acpi_integer            temp;
-	acpi_pci_id             *pci_id = *region_context;
-	acpi_operand_object     *handler_obj;
-	acpi_namespace_node     *node;
-	acpi_operand_object     *region_obj = (acpi_operand_object *) handle;
-	acpi_device_id          object_hID;
+	acpi_status                     status = AE_OK;
+	acpi_integer                    pci_value;
+	struct acpi_pci_id              *pci_id = *region_context;
+	union acpi_operand_object       *handler_obj;
+	struct acpi_namespace_node      *parent_node;
+	struct acpi_namespace_node      *pci_root_node;
+	union acpi_operand_object       *region_obj = (union acpi_operand_object   *) handle;
+	struct acpi_device_id           object_hID;
 
 
-	FUNCTION_TRACE ("Ev_pci_config_region_setup");
+	ACPI_FUNCTION_TRACE ("ev_pci_config_region_setup");
 
 
-	handler_obj = region_obj->region.addr_handler;
+	handler_obj = region_obj->region.address_space;
 	if (!handler_obj) {
 		/*
-		 *  No installed handler. This shouldn't happen because the dispatch
-		 *  routine checks before we get here, but we check again just in case.
+		 * No installed handler. This shouldn't happen because the dispatch
+		 * routine checks before we get here, but we check again just in case.
 		 */
 		ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
 			"Attempting to init a region %p, with no handler\n", region_obj));
 		return_ACPI_STATUS (AE_NOT_EXIST);
 	}
 
+	*region_context = NULL;
 	if (function == ACPI_REGION_DEACTIVATE) {
 		if (pci_id) {
 			ACPI_MEM_FREE (pci_id);
-			*region_context = NULL;
 		}
-
 		return_ACPI_STATUS (status);
 	}
 
-
-	/* Create a new context */
-
-	pci_id = ACPI_MEM_CALLOCATE (sizeof (acpi_pci_id));
-	if (!pci_id) {
-		return_ACPI_STATUS (AE_NO_MEMORY);
-	}
-
-	/*
-	 *  For PCI Config space access, we have to pass the segment, bus,
-	 *  device and function numbers.  This routine must acquire those.
-	 */
+	parent_node = acpi_ns_get_parent_node (region_obj->region.node);
 
 	/*
-	 *  First get device and function numbers from the _ADR object
-	 *  in the parent's scope.
-	 */
-	node = acpi_ns_get_parent_object (region_obj->region.node);
-
-
-	/* Acpi_evaluate the _ADR object */
-
-	status = acpi_ut_evaluate_numeric_object (METHOD_NAME__ADR, node, &temp);
-
-	/*
-	 *  The default is zero, since the allocation above zeroed the data, just
-	 *  do nothing on failures.
-	 */
-	if (ACPI_SUCCESS (status)) {
-		pci_id->device = HIWORD (temp);
-		pci_id->function = LOWORD (temp);
-	}
-
-	/*
-	 *  Get the _SEG and _BBN values from the device upon which the handler
-	 *  is installed.
+	 * Get the _SEG and _BBN values from the device upon which the handler
+	 * is installed.
 	 *
-	 *  We need to get the _SEG and _BBN objects relative to the PCI BUS device.
-	 *  This is the device the handler has been registered to handle.
+	 * We need to get the _SEG and _BBN objects relative to the PCI BUS device.
+	 * This is the device the handler has been registered to handle.
 	 */
 
 	/*
-	 *  If the Addr_handler.Node is still pointing to the root, we need
-	 *  to scan upward for a PCI Root bridge and re-associate the Op_region
-	 *  handlers with that device.
+	 * If the address_space.Node is still pointing to the root, we need
+	 * to scan upward for a PCI Root bridge and re-associate the op_region
+	 * handlers with that device.
 	 */
-	if (handler_obj->addr_handler.node == acpi_gbl_root_node) {
-		/*
-		 * Node is currently the parent object
-		 */
-		while (node != acpi_gbl_root_node) {
-			status = acpi_ut_execute_HID (node, &object_hID);
+	if (handler_obj->address_space.node == acpi_gbl_root_node) {
+		/* Start search from the parent object */
+
+		pci_root_node = parent_node;
+		while (pci_root_node != acpi_gbl_root_node) {
+			status = acpi_ut_execute_HID (pci_root_node, &object_hID);
 			if (ACPI_SUCCESS (status)) {
-				if (!(STRNCMP (object_hID.buffer, PCI_ROOT_HID_STRING,
+				/* Got a valid _HID, check if this is a PCI root */
+
+				if (!(ACPI_STRNCMP (object_hID.value, PCI_ROOT_HID_STRING,
 						   sizeof (PCI_ROOT_HID_STRING)))) {
-					acpi_install_address_space_handler (node,
+					/* Install a handler for this PCI root bridge */
+
+					status = acpi_install_address_space_handler ((acpi_handle) pci_root_node,
 							   ACPI_ADR_SPACE_PCI_CONFIG,
 							   ACPI_DEFAULT_HANDLER, NULL, NULL);
+					if (ACPI_FAILURE (status)) {
+						if (status == AE_SAME_HANDLER) {
+							/*
+							 * It is OK if the handler is already installed on the root
+							 * bridge.  Still need to return a context object for the
+							 * new PCI_Config operation region, however.
+							 */
+							status = AE_OK;
+						}
+						else {
+							ACPI_REPORT_ERROR ((
+								"Could not install pci_config handler for Root Bridge %4.4s, %s\n",
+								pci_root_node->name.ascii, acpi_format_exception (status)));
+						}
+					}
 					break;
 				}
 			}
 
-			node = acpi_ns_get_parent_object (node);
+			pci_root_node = acpi_ns_get_parent_node (pci_root_node);
 		}
+
+		/* PCI root bridge not found, use namespace root node */
 	}
 	else {
-		node = handler_obj->addr_handler.node;
+		pci_root_node = handler_obj->address_space.node;
 	}
 
 	/*
-	 * The PCI segment number comes from the _SEG method
+	 * If this region is now initialized, we are done.
+	 * (install_address_space_handler could have initialized it)
 	 */
-	status = acpi_ut_evaluate_numeric_object (METHOD_NAME__SEG, node, &temp);
-	if (ACPI_SUCCESS (status)) {
-		pci_id->segment = LOWORD (temp);
+	if (region_obj->region.flags & AOPOBJ_SETUP_COMPLETE) {
+		return_ACPI_STATUS (AE_OK);
+	}
+
+	/* Region is still not initialized. Create a new context */
+
+	pci_id = ACPI_MEM_CALLOCATE (sizeof (struct acpi_pci_id));
+	if (!pci_id) {
+		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
 	/*
-	 * The PCI bus number comes from the _BBN method
+	 * For PCI_Config space access, we need the segment, bus,
+	 * device and function numbers.  Acquire them here.
+	 */
+
+	/*
+	 * Get the PCI device and function numbers from the _ADR object
+	 * contained in the parent's scope.
+	 */
+	status = acpi_ut_evaluate_numeric_object (METHOD_NAME__ADR, parent_node, &pci_value);
+
+	/*
+	 * The default is zero, and since the allocation above zeroed
+	 * the data, just do nothing on failure.
 	 */
-	status = acpi_ut_evaluate_numeric_object (METHOD_NAME__BBN, node, &temp);
 	if (ACPI_SUCCESS (status)) {
-		pci_id->bus = LOWORD (temp);
+		pci_id->device  = ACPI_HIWORD (ACPI_LODWORD (pci_value));
+		pci_id->function = ACPI_LOWORD (ACPI_LODWORD (pci_value));
 	}
 
+	/* The PCI segment number comes from the _SEG method */
+
+	status = acpi_ut_evaluate_numeric_object (METHOD_NAME__SEG, pci_root_node, &pci_value);
+	if (ACPI_SUCCESS (status)) {
+		pci_id->segment = ACPI_LOWORD (pci_value);
+	}
+
+	/* The PCI bus number comes from the _BBN method */
+
+	status = acpi_ut_evaluate_numeric_object (METHOD_NAME__BBN, pci_root_node, &pci_value);
+	if (ACPI_SUCCESS (status)) {
+		pci_id->bus = ACPI_LOWORD (pci_value);
+	}
+
+	/* Complete this device's pci_id */
+
+	acpi_os_derive_pci_id (pci_root_node, region_obj->region.node, &pci_id);
+
 	*region_context = pci_id;
 	return_ACPI_STATUS (AE_OK);
 }
@@ -263,12 +315,12 @@ acpi_ev_pci_config_region_setup (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_pci_bar_region_setup
+ * FUNCTION:    acpi_ev_pci_bar_region_setup
  *
- * PARAMETERS:  Region_obj          - region we are interested in
- *              Function            - start or stop
- *              Handler_context     - Address space handler context
- *              Region_context      - Region specific context
+ * PARAMETERS:  region_obj          - Region we are interested in
+ *              Function            - Start or stop
+ *              handler_context     - Address space handler context
+ *              region_context      - Region specific context
  *
  * RETURN:      Status
  *
@@ -280,13 +332,12 @@ acpi_ev_pci_config_region_setup (
 
 acpi_status
 acpi_ev_pci_bar_region_setup (
-	acpi_handle             handle,
-	u32                     function,
-	void                    *handler_context,
-	void                    **region_context)
+	acpi_handle                     handle,
+	u32                             function,
+	void                            *handler_context,
+	void                            **region_context)
 {
-
-	FUNCTION_TRACE ("Ev_pci_bar_region_setup");
+	ACPI_FUNCTION_TRACE ("ev_pci_bar_region_setup");
 
 
 	return_ACPI_STATUS (AE_OK);
@@ -295,12 +346,12 @@ acpi_ev_pci_bar_region_setup (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_cmos_region_setup
+ * FUNCTION:    acpi_ev_cmos_region_setup
  *
- * PARAMETERS:  Region_obj          - region we are interested in
- *              Function            - start or stop
- *              Handler_context     - Address space handler context
- *              Region_context      - Region specific context
+ * PARAMETERS:  region_obj          - Region we are interested in
+ *              Function            - Start or stop
+ *              handler_context     - Address space handler context
+ *              region_context      - Region specific context
  *
  * RETURN:      Status
  *
@@ -312,13 +363,12 @@ acpi_ev_pci_bar_region_setup (
 
 acpi_status
 acpi_ev_cmos_region_setup (
-	acpi_handle             handle,
-	u32                     function,
-	void                    *handler_context,
-	void                    **region_context)
+	acpi_handle                     handle,
+	u32                             function,
+	void                            *handler_context,
+	void                            **region_context)
 {
-
-	FUNCTION_TRACE ("Ev_cmos_region_setup");
+	ACPI_FUNCTION_TRACE ("ev_cmos_region_setup");
 
 
 	return_ACPI_STATUS (AE_OK);
@@ -327,12 +377,12 @@ acpi_ev_cmos_region_setup (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_default_region_setup
+ * FUNCTION:    acpi_ev_default_region_setup
  *
- * PARAMETERS:  Region_obj          - region we are interested in
- *              Function            - start or stop
- *              Handler_context     - Address space handler context
- *              Region_context      - Region specific context
+ * PARAMETERS:  region_obj          - Region we are interested in
+ *              Function            - Start or stop
+ *              handler_context     - Address space handler context
+ *              region_context      - Region specific context
  *
  * RETURN:      Status
  *
@@ -342,12 +392,12 @@ acpi_ev_cmos_region_setup (
 
 acpi_status
 acpi_ev_default_region_setup (
-	acpi_handle             handle,
-	u32                     function,
-	void                    *handler_context,
-	void                    **region_context)
+	acpi_handle                     handle,
+	u32                             function,
+	void                            *handler_context,
+	void                            **region_context)
 {
-	FUNCTION_TRACE ("Ev_default_region_setup");
+	ACPI_FUNCTION_TRACE ("ev_default_region_setup");
 
 
 	if (function == ACPI_REGION_DEACTIVATE) {
@@ -363,9 +413,10 @@ acpi_ev_default_region_setup (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_initialize_region
+ * FUNCTION:    acpi_ev_initialize_region
  *
- * PARAMETERS:  Region_obj - Region we are initializing
+ * PARAMETERS:  region_obj      - Region we are initializing
+ *              acpi_ns_locked  - Is namespace locked?
  *
  * RETURN:      Status
  *
@@ -375,7 +426,7 @@ acpi_ev_default_region_setup (
  *              Get the appropriate address space handler for a newly
  *              created region.
  *
- *              This also performs address space specific intialization.  For
+ *              This also performs address space specific initialization.  For
  *              example, PCI regions must have an _ADR object that contains
  *              a PCI address in the scope of the definition.  This address is
  *              required to perform an access to PCI config space.
@@ -384,113 +435,124 @@ acpi_ev_default_region_setup (
 
 acpi_status
 acpi_ev_initialize_region (
-	acpi_operand_object     *region_obj,
-	u8                      acpi_ns_locked)
+	union acpi_operand_object       *region_obj,
+	u8                              acpi_ns_locked)
 {
-	acpi_operand_object     *handler_obj;
-	acpi_operand_object     *obj_desc;
-	ACPI_ADR_SPACE_TYPE     space_id;
-	acpi_namespace_node     *node;
-	acpi_status             status;
-	acpi_namespace_node     *method_node;
-	acpi_name               *reg_name_ptr = (acpi_name *) METHOD_NAME__REG;
+	union acpi_operand_object       *handler_obj;
+	union acpi_operand_object       *obj_desc;
+	acpi_adr_space_type             space_id;
+	struct acpi_namespace_node      *node;
+	acpi_status                     status;
+	struct acpi_namespace_node      *method_node;
+	acpi_name                       *reg_name_ptr = (acpi_name *) METHOD_NAME__REG;
+	union acpi_operand_object       *region_obj2;
 
 
-	FUNCTION_TRACE_U32 ("Ev_initialize_region", acpi_ns_locked);
+	ACPI_FUNCTION_TRACE_U32 ("ev_initialize_region", acpi_ns_locked);
 
 
 	if (!region_obj) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	node = acpi_ns_get_parent_object (region_obj->region.node);
+	if (region_obj->common.flags & AOPOBJ_OBJECT_INITIALIZED) {
+		return_ACPI_STATUS (AE_OK);
+	}
+
+	region_obj2 = acpi_ns_get_secondary_object (region_obj);
+	if (!region_obj2) {
+		return_ACPI_STATUS (AE_NOT_EXIST);
+	}
+
+	node = acpi_ns_get_parent_node (region_obj->region.node);
 	space_id = region_obj->region.space_id;
 
-	region_obj->region.addr_handler = NULL;
-	region_obj->region.extra->extra.method_REG = NULL;
-	region_obj->region.flags &= ~(AOPOBJ_INITIALIZED);
+	/* Setup defaults */
+
+	region_obj->region.address_space = NULL;
+	region_obj2->extra.method_REG = NULL;
+	region_obj->common.flags &= ~(AOPOBJ_SETUP_COMPLETE);
+	region_obj->common.flags |= AOPOBJ_OBJECT_INITIALIZED;
+
+	/* Find any "_REG" method associated with this region definition */
 
-	/*
-	 *  Find any "_REG" associated with this region definition
-	 */
 	status = acpi_ns_search_node (*reg_name_ptr, node,
 			  ACPI_TYPE_METHOD, &method_node);
 	if (ACPI_SUCCESS (status)) {
 		/*
-		 *  The _REG method is optional and there can be only one per region
-		 *  definition.  This will be executed when the handler is attached
-		 *  or removed
+		 * The _REG method is optional and there can be only one per region
+		 * definition.  This will be executed when the handler is attached
+		 * or removed
 		 */
-		region_obj->region.extra->extra.method_REG = method_node;
+		region_obj2->extra.method_REG = method_node;
 	}
 
 	/*
-	 *  The following loop depends upon the root Node having no parent
-	 *  ie: Acpi_gbl_Root_node->Parent_entry being set to NULL
+	 * The following loop depends upon the root Node having no parent
+	 * ie: acpi_gbl_root_node->parent_entry being set to NULL
 	 */
 	while (node) {
-		/*
-		 *  Check to see if a handler exists
-		 */
+		/* Check to see if a handler exists */
+
 		handler_obj = NULL;
 		obj_desc = acpi_ns_get_attached_object (node);
 		if (obj_desc) {
-			/*
-			 *  can only be a handler if the object exists
-			 */
+			/* Can only be a handler if the object exists */
+
 			switch (node->type) {
 			case ACPI_TYPE_DEVICE:
 
-				handler_obj = obj_desc->device.addr_handler;
+				handler_obj = obj_desc->device.address_space;
 				break;
 
 			case ACPI_TYPE_PROCESSOR:
 
-				handler_obj = obj_desc->processor.addr_handler;
+				handler_obj = obj_desc->processor.address_space;
 				break;
 
 			case ACPI_TYPE_THERMAL:
 
-				handler_obj = obj_desc->thermal_zone.addr_handler;
+				handler_obj = obj_desc->thermal_zone.address_space;
+				break;
+
+			default:
+				/* Ignore other objects */
 				break;
 			}
 
 			while (handler_obj) {
-				/*
-				 *  This guy has at least one address handler
-				 *  see if it has the type we want
-				 */
-				if (handler_obj->addr_handler.space_id == space_id) {
+				/* Is this handler of the correct type? */
+
+				if (handler_obj->address_space.space_id == space_id) {
+					/* Found correct handler */
+
 					ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
 						"Found handler %p for region %p in obj %p\n",
 						handler_obj, region_obj, obj_desc));
 
-					/*
-					 *  Found it! Now update the region and the handler
-					 */
-					acpi_ev_associate_region_and_handler (handler_obj, region_obj,
-							acpi_ns_locked);
+					status = acpi_ev_attach_region (handler_obj, region_obj,
+							 acpi_ns_locked);
+
 					return_ACPI_STATUS (AE_OK);
 				}
 
-				handler_obj = handler_obj->addr_handler.next;
+				/* Try next handler in the list */
 
-			} /* while handlerobj */
+				handler_obj = handler_obj->address_space.next;
+			}
 		}
 
 		/*
-		 *  This one does not have the handler we need
-		 *  Pop up one level
+		 * This node does not have the handler we need;
+		 * Pop up one level
 		 */
-		node = acpi_ns_get_parent_object (node);
+		node = acpi_ns_get_parent_node (node);
+	}
 
-	} /* while Node != ROOT */
+	/* If we get here, there is no handler for this region */
 
-	/*
-	 *  If we get here, there is no handler for this region
-	 */
 	ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
-		"No handler for Region_type %s(%X) (Region_obj %p)\n",
+		"No handler for region_type %s(%X) (region_obj %p)\n",
 		acpi_ut_get_region_name (space_id), space_id, region_obj));
 
 	return_ACPI_STATUS (AE_NOT_EXIST);
diff -urNp linux-5400/drivers/acpi/events/evsci.c linux-5410/drivers/acpi/events/evsci.c
--- linux-5400/drivers/acpi/events/evsci.c
+++ linux-5410/drivers/acpi/events/evsci.c
@@ -2,281 +2,198 @@
  *
  * Module Name: evsci - System Control Interrupt configuration and
  *                      legacy to ACPI mode state transition functions
- *              $Revision: 74 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#include "acpi.h"
-#include "acnamesp.h"
-#include "achware.h"
-#include "acevents.h"
+#include <acpi/acpi.h>
+#include <acpi/acevents.h>
 
 
 #define _COMPONENT          ACPI_EVENTS
-	 MODULE_NAME         ("evsci")
-
-
-/*
- * Elements correspond to counts for TMR, NOT_USED, GBL, PWR_BTN, SLP_BTN, RTC,
- * and GENERAL respectively.  These counts are modified by the ACPI interrupt
- * handler.
- *
- * TBD: [Investigate] Note that GENERAL should probably be split out into
- * one element for each bit in the GPE registers
- */
+	 ACPI_MODULE_NAME    ("evsci")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_sci_handler
+ * FUNCTION:    acpi_ev_sci_xrupt_handler
  *
  * PARAMETERS:  Context   - Calling Context
  *
  * RETURN:      Status code indicates whether interrupt was handled.
  *
  * DESCRIPTION: Interrupt handler that will figure out what function or
- *              control method to call to deal with a SCI.  Installed
- *              using BU interrupt support.
+ *              control method to call to deal with a SCI.
  *
  ******************************************************************************/
 
-static u32
-acpi_ev_sci_handler (void *context)
+static u32 ACPI_SYSTEM_XFACE
+acpi_ev_sci_xrupt_handler (
+	void                            *context)
 {
-	u32                     interrupt_handled = INTERRUPT_NOT_HANDLED;
+	struct acpi_gpe_xrupt_info      *gpe_xrupt_list = context;
+	u32                             interrupt_handled = ACPI_INTERRUPT_NOT_HANDLED;
 
 
-	FUNCTION_TRACE("Ev_sci_handler");
+	ACPI_FUNCTION_TRACE("ev_sci_xrupt_handler");
 
 
 	/*
-	 * Make sure that ACPI is enabled by checking SCI_EN.  Note that we are
-	 * required to treat the SCI interrupt as sharable, level, active low.
+	 * We are guaranteed by the ACPI CA initialization/shutdown code that
+	 * if this interrupt handler is installed, ACPI is enabled.
 	 */
-	if (!acpi_hw_register_bit_access (ACPI_READ, ACPI_MTX_DO_NOT_LOCK, SCI_EN)) {
-		/* ACPI is not enabled;  this interrupt cannot be for us */
-
-		return_VALUE (INTERRUPT_NOT_HANDLED);
-	}
 
 	/*
-	 * Fixed Acpi_events:
-	 * -------------
-	 * Check for and dispatch any Fixed Acpi_events that have occurred
+	 * Fixed Events:
+	 * Check for and dispatch any Fixed Events that have occurred
 	 */
 	interrupt_handled |= acpi_ev_fixed_event_detect ();
 
 	/*
-	 * GPEs:
-	 * -----
+	 * General Purpose Events:
 	 * Check for and dispatch any GPEs that have occurred
 	 */
-	interrupt_handled |= acpi_ev_gpe_detect ();
+	interrupt_handled |= acpi_ev_gpe_detect (gpe_xrupt_list);
 
 	return_VALUE (interrupt_handled);
 }
 
 
-/******************************************************************************
- *
- * FUNCTION:    Acpi_ev_install_sci_handler
- *
- * PARAMETERS:  none
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Installs SCI handler.
- *
- ******************************************************************************/
-
-u32
-acpi_ev_install_sci_handler (void)
-{
-	u32                     status = AE_OK;
-
-
-	FUNCTION_TRACE ("Ev_install_sci_handler");
-
-
-	status = acpi_os_install_interrupt_handler ((u32) acpi_gbl_FADT->sci_int,
-			   acpi_ev_sci_handler, NULL);
-	return_ACPI_STATUS (status);
-}
-
-
-/******************************************************************************
-
+/*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_remove_sci_handler
+ * FUNCTION:    acpi_ev_gpe_xrupt_handler
  *
- * PARAMETERS:  none
+ * PARAMETERS:  Context   - Calling Context
  *
- * RETURN:      E_OK if handler uninstalled OK, E_ERROR if handler was not
- *              installed to begin with
+ * RETURN:      Status code indicates whether interrupt was handled.
  *
- * DESCRIPTION: Restores original status of all fixed event enable bits and
- *              removes SCI handler.
+ * DESCRIPTION: Handler for GPE Block Device interrupts
  *
  ******************************************************************************/
 
-acpi_status
-acpi_ev_remove_sci_handler (void)
+u32 ACPI_SYSTEM_XFACE
+acpi_ev_gpe_xrupt_handler (
+	void                            *context)
 {
-	FUNCTION_TRACE ("Ev_remove_sci_handler");
-
+	struct acpi_gpe_xrupt_info      *gpe_xrupt_list = context;
+	u32                             interrupt_handled = ACPI_INTERRUPT_NOT_HANDLED;
 
-#if 0
-	/* TBD:[Investigate] Figure this out!!  Disable all events first ???  */
 
-	if (original_fixed_enable_bit_status ^ 1 << acpi_event_index (TMR_FIXED_EVENT)) {
-		acpi_event_disable_event (TMR_FIXED_EVENT);
-	}
+	ACPI_FUNCTION_TRACE("ev_gpe_xrupt_handler");
 
-	if (original_fixed_enable_bit_status ^ 1 << acpi_event_index (GBL_FIXED_EVENT)) {
-		acpi_event_disable_event (GBL_FIXED_EVENT);
-	}
 
-	if (original_fixed_enable_bit_status ^ 1 << acpi_event_index (PWR_BTN_FIXED_EVENT)) {
-		acpi_event_disable_event (PWR_BTN_FIXED_EVENT);
-	}
-
-	if (original_fixed_enable_bit_status ^ 1 << acpi_event_index (SLP_BTN_FIXED_EVENT)) {
-		acpi_event_disable_event (SLP_BTN_FIXED_EVENT);
-	}
-
-	if (original_fixed_enable_bit_status ^ 1 << acpi_event_index (RTC_FIXED_EVENT)) {
-		acpi_event_disable_event (RTC_FIXED_EVENT);
-	}
-
-	original_fixed_enable_bit_status = 0;
-
-#endif
+	/*
+	 * We are guaranteed by the ACPI CA initialization/shutdown code that
+	 * if this interrupt handler is installed, ACPI is enabled.
+	 */
 
-	acpi_os_remove_interrupt_handler ((u32) acpi_gbl_FADT->sci_int,
-			   acpi_ev_sci_handler);
+	/*
+	 * GPEs:
+	 * Check for and dispatch any GPEs that have occurred
+	 */
+	interrupt_handled |= acpi_ev_gpe_detect (gpe_xrupt_list);
 
-	return_ACPI_STATUS (AE_OK);
+	return_VALUE (interrupt_handled);
 }
 
 
-/*******************************************************************************
+/******************************************************************************
  *
- * FUNCTION:    Acpi_ev_restore_acpi_state
+ * FUNCTION:    acpi_ev_install_sci_handler
  *
  * PARAMETERS:  none
  *
- * RETURN:      none
+ * RETURN:      Status
  *
- * DESCRIPTION: Restore the original ACPI state of the machine
+ * DESCRIPTION: Installs SCI handler.
  *
  ******************************************************************************/
 
-void
-acpi_ev_restore_acpi_state (void)
+u32
+acpi_ev_install_sci_handler (void)
 {
-	u32                     index;
-
-
-	FUNCTION_TRACE ("Ev_restore_acpi_state");
-
-
-	/* Restore the state of the chipset enable bits. */
+	u32                             status = AE_OK;
 
-	if (acpi_gbl_restore_acpi_chipset == TRUE) {
-		/* Restore the fixed events */
 
-		if (acpi_hw_register_read (ACPI_MTX_LOCK, PM1_EN) !=
-				acpi_gbl_pm1_enable_register_save) {
-			acpi_hw_register_write (ACPI_MTX_LOCK, PM1_EN,
-				acpi_gbl_pm1_enable_register_save);
-		}
+	ACPI_FUNCTION_TRACE ("ev_install_sci_handler");
 
 
-		/* Ensure that all status bits are clear */
-
-		acpi_hw_clear_acpi_status ();
-
-
-		/* Now restore the GPEs */
-
-		for (index = 0; index < DIV_2 (acpi_gbl_FADT->gpe0blk_len); index++) {
-			if (acpi_hw_register_read (ACPI_MTX_LOCK, GPE0_EN_BLOCK | index) !=
-					acpi_gbl_gpe0enable_register_save[index]) {
-				acpi_hw_register_write (ACPI_MTX_LOCK, GPE0_EN_BLOCK | index,
-					acpi_gbl_gpe0enable_register_save[index]);
-			}
-		}
-
-		/* GPE 1 present? */
-
-		if (acpi_gbl_FADT->gpe1_blk_len) {
-			for (index = 0; index < DIV_2 (acpi_gbl_FADT->gpe1_blk_len); index++) {
-				if (acpi_hw_register_read (ACPI_MTX_LOCK, GPE1_EN_BLOCK | index) !=
-					acpi_gbl_gpe1_enable_register_save[index]) {
-					acpi_hw_register_write (ACPI_MTX_LOCK, GPE1_EN_BLOCK | index,
-						acpi_gbl_gpe1_enable_register_save[index]);
-				}
-			}
-		}
-
-		if (acpi_hw_get_mode() != acpi_gbl_original_mode) {
-			acpi_hw_set_mode (acpi_gbl_original_mode);
-		}
-	}
-
-	return_VOID;
+	status = acpi_os_install_interrupt_handler ((u32) acpi_gbl_FADT->sci_int,
+			   acpi_ev_sci_xrupt_handler, acpi_gbl_gpe_xrupt_list_head);
+	return_ACPI_STATUS (status);
 }
 
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_ev_terminate
+ * FUNCTION:    acpi_ev_remove_sci_handler
  *
  * PARAMETERS:  none
  *
- * RETURN:      none
+ * RETURN:      E_OK if handler uninstalled OK, E_ERROR if handler was not
+ *              installed to begin with
+ *
+ * DESCRIPTION: Remove the SCI interrupt handler.  No further SCIs will be
+ *              taken.
  *
- * DESCRIPTION: free memory allocated for table storage.
+ * Note:  It doesn't seem important to disable all events or set the event
+ *        enable registers to their original values.  The OS should disable
+ *        the SCI interrupt level when the handler is removed, so no more
+ *        events will come in.
  *
  ******************************************************************************/
 
-void
-acpi_ev_terminate (void)
+acpi_status
+acpi_ev_remove_sci_handler (void)
 {
+	acpi_status                     status;
 
-	FUNCTION_TRACE ("Ev_terminate");
 
+	ACPI_FUNCTION_TRACE ("ev_remove_sci_handler");
 
-	/*
-	 * Free global tables, etc.
-	 */
-	if (acpi_gbl_gpe_registers) {
-		ACPI_MEM_FREE (acpi_gbl_gpe_registers);
-	}
-
-	if (acpi_gbl_gpe_info) {
-		ACPI_MEM_FREE (acpi_gbl_gpe_info);
-	}
 
-	return_VOID;
+	/* Just let the OS remove the handler and disable the level */
+
+	status = acpi_os_remove_interrupt_handler ((u32) acpi_gbl_FADT->sci_int,
+			   acpi_ev_sci_xrupt_handler);
+
+	return_ACPI_STATUS (status);
 }
 
 
diff -urNp linux-5400/drivers/acpi/events/evxface.c linux-5410/drivers/acpi/events/evxface.c
--- linux-5400/drivers/acpi/events/evxface.c
+++ linux-5410/drivers/acpi/events/evxface.c
@@ -1,43 +1,59 @@
 /******************************************************************************
  *
  * Module Name: evxface - External interfaces for ACPI events
- *              $Revision: 116 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "achware.h"
-#include "acnamesp.h"
-#include "acevents.h"
-#include "amlcode.h"
-#include "acinterp.h"
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acevents.h>
+#include <acpi/acinterp.h>
 
 #define _COMPONENT          ACPI_EVENTS
-	 MODULE_NAME         ("evxface")
+	 ACPI_MODULE_NAME    ("evxface")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_install_fixed_event_handler
+ * FUNCTION:    acpi_install_fixed_event_handler
  *
  * PARAMETERS:  Event           - Event type to enable.
  *              Handler         - Pointer to the handler function for the
@@ -53,14 +69,14 @@
 
 acpi_status
 acpi_install_fixed_event_handler (
-	u32                     event,
-	acpi_event_handler      handler,
-	void                    *context)
+	u32                             event,
+	acpi_event_handler              handler,
+	void                            *context)
 {
-	acpi_status             status;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Acpi_install_fixed_event_handler");
+	ACPI_FUNCTION_TRACE ("acpi_install_fixed_event_handler");
 
 
 	/* Parameter validation */
@@ -69,23 +85,25 @@ acpi_install_fixed_event_handler (
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	acpi_ut_acquire_mutex (ACPI_MTX_EVENTS);
+	status = acpi_ut_acquire_mutex (ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	/* Don't allow two handlers. */
 
 	if (NULL != acpi_gbl_fixed_event_handlers[event].handler) {
-		status = AE_EXIST;
+		status = AE_ALREADY_EXISTS;
 		goto cleanup;
 	}
 
-
 	/* Install the handler before enabling the event */
 
 	acpi_gbl_fixed_event_handlers[event].handler = handler;
 	acpi_gbl_fixed_event_handlers[event].context = context;
 
-	status = acpi_enable_event (event, ACPI_EVENT_FIXED, 0);
-	if (!ACPI_SUCCESS (status)) {
+	status = acpi_enable_event (event, 0);
+	if (ACPI_FAILURE (status)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Could not enable fixed event.\n"));
 
 		/* Remove the handler */
@@ -93,7 +111,6 @@ acpi_install_fixed_event_handler (
 		acpi_gbl_fixed_event_handlers[event].handler = NULL;
 		acpi_gbl_fixed_event_handlers[event].context = NULL;
 	}
-
 	else {
 		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
 			"Enabled fixed event %X, Handler=%p\n", event, handler));
@@ -101,14 +118,14 @@ acpi_install_fixed_event_handler (
 
 
 cleanup:
-	acpi_ut_release_mutex (ACPI_MTX_EVENTS);
+	(void) acpi_ut_release_mutex (ACPI_MTX_EVENTS);
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_remove_fixed_event_handler
+ * FUNCTION:    acpi_remove_fixed_event_handler
  *
  * PARAMETERS:  Event           - Event type to disable.
  *              Handler         - Address of the handler
@@ -121,13 +138,13 @@ cleanup:
 
 acpi_status
 acpi_remove_fixed_event_handler (
-	u32                     event,
-	acpi_event_handler      handler)
+	u32                             event,
+	acpi_event_handler              handler)
 {
-	acpi_status             status = AE_OK;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE ("Acpi_remove_fixed_event_handler");
+	ACPI_FUNCTION_TRACE ("acpi_remove_fixed_event_handler");
 
 
 	/* Parameter validation */
@@ -136,18 +153,21 @@ acpi_remove_fixed_event_handler (
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	acpi_ut_acquire_mutex (ACPI_MTX_EVENTS);
+	status = acpi_ut_acquire_mutex (ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	/* Disable the event before removing the handler */
 
-	status = acpi_disable_event(event, ACPI_EVENT_FIXED, 0);
+	status = acpi_disable_event (event, 0);
 
 	/* Always Remove the handler */
 
 	acpi_gbl_fixed_event_handlers[event].handler = NULL;
 	acpi_gbl_fixed_event_handlers[event].context = NULL;
 
-	if (!ACPI_SUCCESS (status)) {
+	if (ACPI_FAILURE (status)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_WARN,
 			"Could not write to fixed event enable register.\n"));
 	}
@@ -155,19 +175,19 @@ acpi_remove_fixed_event_handler (
 		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Disabled fixed event %X.\n", event));
 	}
 
-	acpi_ut_release_mutex (ACPI_MTX_EVENTS);
+	(void) acpi_ut_release_mutex (ACPI_MTX_EVENTS);
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_install_notify_handler
+ * FUNCTION:    acpi_install_notify_handler
  *
  * PARAMETERS:  Device          - The device for which notifies will be handled
- *              Handler_type    - The type of handler:
- *                                  ACPI_SYSTEM_NOTIFY: System_handler (00-7f)
- *                                  ACPI_DEVICE_NOTIFY: Driver_handler (80-ff)
+ *              handler_type    - The type of handler:
+ *                                  ACPI_SYSTEM_NOTIFY: system_handler (00-7f)
+ *                                  ACPI_DEVICE_NOTIFY: driver_handler (80-ff)
  *              Handler         - Address of the handler
  *              Context         - Value passed to the handler on each GPE
  *
@@ -179,33 +199,37 @@ acpi_remove_fixed_event_handler (
 
 acpi_status
 acpi_install_notify_handler (
-	acpi_handle             device,
-	u32                     handler_type,
-	acpi_notify_handler     handler,
-	void                    *context)
+	acpi_handle                     device,
+	u32                             handler_type,
+	acpi_notify_handler             handler,
+	void                            *context)
 {
-	acpi_operand_object     *obj_desc;
-	acpi_operand_object     *notify_obj;
-	acpi_namespace_node     *device_node;
-	acpi_status             status = AE_OK;
+	union acpi_operand_object       *obj_desc;
+	union acpi_operand_object       *notify_obj;
+	struct acpi_namespace_node      *node;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Acpi_install_notify_handler");
+	ACPI_FUNCTION_TRACE ("acpi_install_notify_handler");
 
 
 	/* Parameter validation */
 
-	if ((!handler) ||
+	if ((!device)  ||
+		(!handler) ||
 		(handler_type > ACPI_MAX_NOTIFY_HANDLER_TYPE)) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	/* Convert and validate the device handle */
 
-	device_node = acpi_ns_map_handle_to_node (device);
-	if (!device_node) {
+	node = acpi_ns_map_handle_to_node (device);
+	if (!node) {
 		status = AE_BAD_PARAMETER;
 		goto unlock_and_exit;
 	}
@@ -220,22 +244,22 @@ acpi_install_notify_handler (
 		/* Make sure the handler is not already installed */
 
 		if (((handler_type == ACPI_SYSTEM_NOTIFY) &&
-			  acpi_gbl_sys_notify.handler) ||
+				acpi_gbl_system_notify.handler)        ||
 			((handler_type == ACPI_DEVICE_NOTIFY) &&
-			  acpi_gbl_drv_notify.handler)) {
-			status = AE_EXIST;
+				acpi_gbl_device_notify.handler)) {
+			status = AE_ALREADY_EXISTS;
 			goto unlock_and_exit;
 		}
 
 		if (handler_type == ACPI_SYSTEM_NOTIFY) {
-			acpi_gbl_sys_notify.node = device_node;
-			acpi_gbl_sys_notify.handler = handler;
-			acpi_gbl_sys_notify.context = context;
+			acpi_gbl_system_notify.node  = node;
+			acpi_gbl_system_notify.handler = handler;
+			acpi_gbl_system_notify.context = context;
 		}
 		else /* ACPI_DEVICE_NOTIFY */ {
-			acpi_gbl_drv_notify.node = device_node;
-			acpi_gbl_drv_notify.handler = handler;
-			acpi_gbl_drv_notify.context = context;
+			acpi_gbl_device_notify.node  = node;
+			acpi_gbl_device_notify.handler = handler;
+			acpi_gbl_device_notify.context = context;
 		}
 
 		/* Global notify handler installed */
@@ -247,37 +271,31 @@ acpi_install_notify_handler (
 	 * Note that only certain object types can receive notifications.
 	 */
 	else {
-		/*
-		 * These are the ONLY objects that can receive ACPI notifications
-		 */
-		if ((device_node->type != ACPI_TYPE_DEVICE)    &&
-			(device_node->type != ACPI_TYPE_PROCESSOR) &&
-			(device_node->type != ACPI_TYPE_POWER)     &&
-			(device_node->type != ACPI_TYPE_THERMAL)) {
-			status = AE_BAD_PARAMETER;
+		/* Notifies allowed on this object? */
+
+		if (!acpi_ev_is_notify_object (node)) {
+			status = AE_TYPE;
 			goto unlock_and_exit;
 		}
 
 		/* Check for an existing internal object */
 
-		obj_desc = acpi_ns_get_attached_object (device_node);
+		obj_desc = acpi_ns_get_attached_object (node);
 		if (obj_desc) {
-
 			/* Object exists - make sure there's no handler */
 
 			if (((handler_type == ACPI_SYSTEM_NOTIFY) &&
-				  obj_desc->device.sys_handler) ||
+					obj_desc->common_notify.system_notify) ||
 				((handler_type == ACPI_DEVICE_NOTIFY) &&
-				  obj_desc->device.drv_handler)) {
-				status = AE_EXIST;
+					obj_desc->common_notify.device_notify)) {
+				status = AE_ALREADY_EXISTS;
 				goto unlock_and_exit;
 			}
 		}
-
 		else {
 			/* Create a new object */
 
-			obj_desc = acpi_ut_create_internal_object (device_node->type);
+			obj_desc = acpi_ut_create_internal_object (node->type);
 			if (!obj_desc) {
 				status = AE_NO_MEMORY;
 				goto unlock_and_exit;
@@ -285,7 +303,12 @@ acpi_install_notify_handler (
 
 			/* Attach new object to the Node */
 
-			status = acpi_ns_attach_object (device, obj_desc, (u8) device_node->type);
+			status = acpi_ns_attach_object (device, obj_desc, node->type);
+
+			/* Remove local reference to the object */
+
+			acpi_ut_remove_reference (obj_desc);
+
 			if (ACPI_FAILURE (status)) {
 				goto unlock_and_exit;
 			}
@@ -293,41 +316,39 @@ acpi_install_notify_handler (
 
 		/* Install the handler */
 
-		notify_obj = acpi_ut_create_internal_object (INTERNAL_TYPE_NOTIFY);
+		notify_obj = acpi_ut_create_internal_object (ACPI_TYPE_LOCAL_NOTIFY);
 		if (!notify_obj) {
 			status = AE_NO_MEMORY;
 			goto unlock_and_exit;
 		}
 
-		notify_obj->notify_handler.node = device_node;
-		notify_obj->notify_handler.handler = handler;
-		notify_obj->notify_handler.context = context;
-
+		notify_obj->notify.node   = node;
+		notify_obj->notify.handler = handler;
+		notify_obj->notify.context = context;
 
 		if (handler_type == ACPI_SYSTEM_NOTIFY) {
-			obj_desc->device.sys_handler = notify_obj;
+			obj_desc->common_notify.system_notify = notify_obj;
 		}
-
 		else /* ACPI_DEVICE_NOTIFY */ {
-			obj_desc->device.drv_handler = notify_obj;
+			obj_desc->common_notify.device_notify = notify_obj;
 		}
 	}
 
 
 unlock_and_exit:
-	acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_remove_notify_handler
+ * FUNCTION:    acpi_remove_notify_handler
  *
  * PARAMETERS:  Device          - The device for which notifies will be handled
- *              Handler_type    - The type of handler:
- *                                  ACPI_SYSTEM_NOTIFY: System_handler (00-7f)
- *                                  ACPI_DEVICE_NOTIFY: Driver_handler (80-ff)
+ *              handler_type    - The type of handler:
+ *                                  ACPI_SYSTEM_NOTIFY: system_handler (00-7f)
+ *                                  ACPI_DEVICE_NOTIFY: driver_handler (80-ff)
  *              Handler         - Address of the handler
  * RETURN:      Status
  *
@@ -337,32 +358,36 @@ unlock_and_exit:
 
 acpi_status
 acpi_remove_notify_handler (
-	acpi_handle             device,
-	u32                     handler_type,
-	acpi_notify_handler     handler)
+	acpi_handle                     device,
+	u32                             handler_type,
+	acpi_notify_handler             handler)
 {
-	acpi_operand_object     *notify_obj;
-	acpi_operand_object     *obj_desc;
-	acpi_namespace_node     *device_node;
-	acpi_status             status = AE_OK;
+	union acpi_operand_object       *notify_obj;
+	union acpi_operand_object       *obj_desc;
+	struct acpi_namespace_node      *node;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Acpi_remove_notify_handler");
+	ACPI_FUNCTION_TRACE ("acpi_remove_notify_handler");
 
 
 	/* Parameter validation */
 
-	if ((!handler) ||
+	if ((!device)  ||
+		(!handler) ||
 		(handler_type > ACPI_MAX_NOTIFY_HANDLER_TYPE)) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	/* Convert and validate the device handle */
 
-	device_node = acpi_ns_map_handle_to_node (device);
-	if (!device_node) {
+	node = acpi_ns_map_handle_to_node (device);
+	if (!node) {
 		status = AE_BAD_PARAMETER;
 		goto unlock_and_exit;
 	}
@@ -374,22 +399,22 @@ acpi_remove_notify_handler (
 		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Removing notify handler for ROOT object.\n"));
 
 		if (((handler_type == ACPI_SYSTEM_NOTIFY) &&
-			  !acpi_gbl_sys_notify.handler) ||
+			  !acpi_gbl_system_notify.handler) ||
 			((handler_type == ACPI_DEVICE_NOTIFY) &&
-			  !acpi_gbl_drv_notify.handler)) {
+			  !acpi_gbl_device_notify.handler)) {
 			status = AE_NOT_EXIST;
 			goto unlock_and_exit;
 		}
 
 		if (handler_type == ACPI_SYSTEM_NOTIFY) {
-			acpi_gbl_sys_notify.node  = NULL;
-			acpi_gbl_sys_notify.handler = NULL;
-			acpi_gbl_sys_notify.context = NULL;
+			acpi_gbl_system_notify.node  = NULL;
+			acpi_gbl_system_notify.handler = NULL;
+			acpi_gbl_system_notify.context = NULL;
 		}
 		else {
-			acpi_gbl_drv_notify.node  = NULL;
-			acpi_gbl_drv_notify.handler = NULL;
-			acpi_gbl_drv_notify.context = NULL;
+			acpi_gbl_device_notify.node  = NULL;
+			acpi_gbl_device_notify.handler = NULL;
+			acpi_gbl_device_notify.context = NULL;
 		}
 	}
 
@@ -397,20 +422,16 @@ acpi_remove_notify_handler (
 	 * All Other Objects
 	 */
 	else {
-		/*
-		 * These are the ONLY objects that can receive ACPI notifications
-		 */
-		if ((device_node->type != ACPI_TYPE_DEVICE)    &&
-			(device_node->type != ACPI_TYPE_PROCESSOR) &&
-			(device_node->type != ACPI_TYPE_POWER)     &&
-			(device_node->type != ACPI_TYPE_THERMAL)) {
-			status = AE_BAD_PARAMETER;
+		/* Notifies allowed on this object? */
+
+		if (!acpi_ev_is_notify_object (node)) {
+			status = AE_TYPE;
 			goto unlock_and_exit;
 		}
 
 		/* Check for an existing internal object */
 
-		obj_desc = acpi_ns_get_attached_object (device_node);
+		obj_desc = acpi_ns_get_attached_object (node);
 		if (!obj_desc) {
 			status = AE_NOT_EXIST;
 			goto unlock_and_exit;
@@ -419,14 +440,14 @@ acpi_remove_notify_handler (
 		/* Object exists - make sure there's an existing handler */
 
 		if (handler_type == ACPI_SYSTEM_NOTIFY) {
-			notify_obj = obj_desc->device.sys_handler;
+			notify_obj = obj_desc->common_notify.system_notify;
 		}
 		else {
-			notify_obj = obj_desc->device.drv_handler;
+			notify_obj = obj_desc->common_notify.device_notify;
 		}
 
 		if ((!notify_obj) ||
-			(notify_obj->notify_handler.handler != handler)) {
+			(notify_obj->notify.handler != handler)) {
 			status = AE_BAD_PARAMETER;
 			goto unlock_and_exit;
 		}
@@ -434,10 +455,10 @@ acpi_remove_notify_handler (
 		/* Remove the handler */
 
 		if (handler_type == ACPI_SYSTEM_NOTIFY) {
-			obj_desc->device.sys_handler = NULL;
+			obj_desc->common_notify.system_notify = NULL;
 		}
 		else {
-			obj_desc->device.drv_handler = NULL;
+			obj_desc->common_notify.device_notify = NULL;
 		}
 
 		acpi_ut_remove_reference (notify_obj);
@@ -445,17 +466,17 @@ acpi_remove_notify_handler (
 
 
 unlock_and_exit:
-	acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_install_gpe_handler
+ * FUNCTION:    acpi_install_gpe_handler
  *
- * PARAMETERS:  Gpe_number      - The GPE number.  The numbering scheme is
- *                                bank 0 first, then bank 1.
+ * PARAMETERS:  gpe_number      - The GPE number within the GPE block
+ *              gpe_block       - GPE block (NULL == FADT GPEs)
  *              Type            - Whether this GPE should be treated as an
  *                                edge- or level-triggered interrupt.
  *              Handler         - Address of the handler
@@ -469,124 +490,150 @@ unlock_and_exit:
 
 acpi_status
 acpi_install_gpe_handler (
-	u32                     gpe_number,
-	u32                     type,
-	acpi_gpe_handler        handler,
-	void                    *context)
+	acpi_handle                     gpe_device,
+	u32                             gpe_number,
+	u32                             type,
+	acpi_gpe_handler                handler,
+	void                            *context)
 {
-	acpi_status             status = AE_OK;
+	acpi_status                     status;
+	struct acpi_gpe_event_info      *gpe_event_info;
 
 
-	FUNCTION_TRACE ("Acpi_install_gpe_handler");
+	ACPI_FUNCTION_TRACE ("acpi_install_gpe_handler");
 
 
 	/* Parameter validation */
 
-	if (!handler || (gpe_number > ACPI_GPE_MAX)) {
+	if (!handler) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
+	status = acpi_ut_acquire_mutex (ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
 	/* Ensure that we have a valid GPE number */
 
-	if (acpi_gbl_gpe_valid[gpe_number] == ACPI_GPE_INVALID) {
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	gpe_event_info = acpi_ev_get_gpe_event_info (gpe_device, gpe_number);
+	if (!gpe_event_info) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
 	}
 
-	acpi_ut_acquire_mutex (ACPI_MTX_EVENTS);
-
 	/* Make sure that there isn't a handler there already */
 
-	if (acpi_gbl_gpe_info[gpe_number].handler) {
-		status = AE_EXIST;
-		goto cleanup;
+	if (gpe_event_info->handler) {
+		status = AE_ALREADY_EXISTS;
+		goto unlock_and_exit;
 	}
 
 	/* Install the handler */
 
-	acpi_gbl_gpe_info[gpe_number].handler = handler;
-	acpi_gbl_gpe_info[gpe_number].context = context;
-	acpi_gbl_gpe_info[gpe_number].type = (u8) type;
+	acpi_os_acquire_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
+	gpe_event_info->handler = handler;
+	gpe_event_info->context = context;
+	gpe_event_info->flags = (u8) type;
+	acpi_os_release_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
 
 	/* Clear the GPE (of stale events), the enable it */
 
-	acpi_hw_clear_gpe (gpe_number);
-	acpi_hw_enable_gpe (gpe_number);
+	status = acpi_hw_clear_gpe (gpe_event_info);
+	if (ACPI_FAILURE (status)) {
+		goto unlock_and_exit;
+	}
+
+	status = acpi_hw_enable_gpe (gpe_event_info);
 
 
-cleanup:
-	acpi_ut_release_mutex (ACPI_MTX_EVENTS);
+unlock_and_exit:
+	(void) acpi_ut_release_mutex (ACPI_MTX_EVENTS);
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_remove_gpe_handler
+ * FUNCTION:    acpi_remove_gpe_handler
  *
- * PARAMETERS:  Gpe_number      - The event to remove a handler
+ * PARAMETERS:  gpe_number      - The event to remove a handler
+ *              gpe_block       - GPE block (NULL == FADT GPEs)
  *              Handler         - Address of the handler
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Remove a handler for a General Purpose Acpi_event.
+ * DESCRIPTION: Remove a handler for a General Purpose acpi_event.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_remove_gpe_handler (
-	u32                     gpe_number,
-	acpi_gpe_handler        handler)
+	acpi_handle                     gpe_device,
+	u32                             gpe_number,
+	acpi_gpe_handler                handler)
 {
-	acpi_status             status = AE_OK;
+	acpi_status                     status;
+	struct acpi_gpe_event_info      *gpe_event_info;
 
 
-	FUNCTION_TRACE ("Acpi_remove_gpe_handler");
+	ACPI_FUNCTION_TRACE ("acpi_remove_gpe_handler");
 
 
 	/* Parameter validation */
 
-	if (!handler || (gpe_number > ACPI_GPE_MAX)) {
+	if (!handler) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
+	status = acpi_ut_acquire_mutex (ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
 	/* Ensure that we have a valid GPE number */
 
-	if (acpi_gbl_gpe_valid[gpe_number] == ACPI_GPE_INVALID) {
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	gpe_event_info = acpi_ev_get_gpe_event_info (gpe_device, gpe_number);
+	if (!gpe_event_info) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
 	}
 
 	/* Disable the GPE before removing the handler */
 
-	acpi_hw_disable_gpe (gpe_number);
-
-	acpi_ut_acquire_mutex (ACPI_MTX_EVENTS);
+	status = acpi_hw_disable_gpe (gpe_event_info);
+	if (ACPI_FAILURE (status)) {
+		goto unlock_and_exit;
+	}
 
 	/* Make sure that the installed handler is the same */
 
-	if (acpi_gbl_gpe_info[gpe_number].handler != handler) {
-		acpi_hw_enable_gpe (gpe_number);
+	if (gpe_event_info->handler != handler) {
+		(void) acpi_hw_enable_gpe (gpe_event_info);
 		status = AE_BAD_PARAMETER;
-		goto cleanup;
+		goto unlock_and_exit;
 	}
 
 	/* Remove the handler */
 
-	acpi_gbl_gpe_info[gpe_number].handler = NULL;
-	acpi_gbl_gpe_info[gpe_number].context = NULL;
+	acpi_os_acquire_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
+	gpe_event_info->handler = NULL;
+	gpe_event_info->context = NULL;
+	acpi_os_release_lock (acpi_gbl_gpe_lock, ACPI_NOT_ISR);
 
 
-cleanup:
-	acpi_ut_release_mutex (ACPI_MTX_EVENTS);
+unlock_and_exit:
+	(void) acpi_ut_release_mutex (ACPI_MTX_EVENTS);
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_acquire_global_lock
+ * FUNCTION:    acpi_acquire_global_lock
  *
  * PARAMETERS:  Timeout         - How long the caller is willing to wait
- *              Out_handle      - A handle to the lock if acquired
+ *              out_handle      - A handle to the lock if acquired
  *
  * RETURN:      Status
  *
@@ -596,32 +643,38 @@ cleanup:
 
 acpi_status
 acpi_acquire_global_lock (
-	void)
+	u16                             timeout,
+	u32                             *handle)
 {
-	acpi_status             status;
+	acpi_status                     status;
+
 
+	if (!handle) {
+		return (AE_BAD_PARAMETER);
+	}
 
 	status = acpi_ex_enter_interpreter ();
 	if (ACPI_FAILURE (status)) {
 		return (status);
 	}
 
-	/*
-	 * TBD: [Restructure] add timeout param to internal interface, and
-	 * perhaps INTERPRETER_LOCKED
-	 */
-	status = acpi_ev_acquire_global_lock ();
+	status = acpi_ev_acquire_global_lock (timeout);
 	acpi_ex_exit_interpreter ();
 
+	if (ACPI_SUCCESS (status)) {
+		acpi_gbl_global_lock_handle++;
+		*handle = acpi_gbl_global_lock_handle;
+	}
+
 	return (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_release_global_lock
+ * FUNCTION:    acpi_release_global_lock
  *
- * PARAMETERS:  Handle      - Returned from Acpi_acquire_global_lock
+ * PARAMETERS:  Handle      - Returned from acpi_acquire_global_lock
  *
  * RETURN:      Status
  *
@@ -631,11 +684,17 @@ acpi_acquire_global_lock (
 
 acpi_status
 acpi_release_global_lock (
-	void)
+	u32                             handle)
 {
+	acpi_status                     status;
+
 
-	acpi_ev_release_global_lock ();
-	return (AE_OK);
+	if (handle != acpi_gbl_global_lock_handle) {
+		return (AE_NOT_ACQUIRED);
+	}
+
+	status = acpi_ev_release_global_lock ();
+	return (status);
 }
 
 
diff -urNp linux-5400/drivers/acpi/events/evxfevnt.c linux-5410/drivers/acpi/events/evxfevnt.c
--- linux-5400/drivers/acpi/events/evxfevnt.c
+++ linux-5410/drivers/acpi/events/evxfevnt.c
@@ -1,43 +1,58 @@
 /******************************************************************************
  *
  * Module Name: evxfevnt - External Interfaces, ACPI event disable/enable
- *              $Revision: 38 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "achware.h"
-#include "acnamesp.h"
-#include "acevents.h"
-#include "amlcode.h"
-#include "acinterp.h"
+#include <acpi/acpi.h>
+#include <acpi/acevents.h>
+#include <acpi/acnamesp.h>
 
 #define _COMPONENT          ACPI_EVENTS
-	 MODULE_NAME         ("evxfevnt")
+	 ACPI_MODULE_NAME    ("evxfevnt")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_enable
+ * FUNCTION:    acpi_enable
  *
  * PARAMETERS:  None
  *
@@ -50,74 +65,79 @@
 acpi_status
 acpi_enable (void)
 {
-	acpi_status             status;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE ("Acpi_enable");
+	ACPI_FUNCTION_TRACE ("acpi_enable");
 
 
-	/* Make sure we've got ACPI tables */
+	/* Make sure we have the FADT*/
 
-	if (!acpi_gbl_DSDT) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "No ACPI tables present!\n"));
+	if (!acpi_gbl_FADT) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "No FADT information present!\n"));
 		return_ACPI_STATUS (AE_NO_ACPI_TABLES);
 	}
 
-	/* Make sure the BIOS supports ACPI mode */
-
-	if (SYS_MODE_LEGACY == acpi_hw_get_mode_capabilities()) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Only legacy mode supported!\n"));
-		return_ACPI_STATUS (AE_ERROR);
+	if (acpi_hw_get_mode() == ACPI_SYS_MODE_ACPI) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_INIT, "System is already in ACPI mode\n"));
 	}
+	else {
+		/* Transition to ACPI mode */
 
-	/* Transition to ACPI mode */
+		status = acpi_hw_set_mode (ACPI_SYS_MODE_ACPI);
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_ERROR (("Could not transition to ACPI mode.\n"));
+			return_ACPI_STATUS (status);
+		}
 
-	status = acpi_hw_set_mode (SYS_MODE_ACPI);
-	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_FATAL, "Could not transition to ACPI mode.\n"));
-		return_ACPI_STATUS (status);
+		ACPI_DEBUG_PRINT ((ACPI_DB_INIT, "Transition to ACPI mode successful\n"));
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_OK, "Transition to ACPI mode successful\n"));
-
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_disable
+ * FUNCTION:    acpi_disable
  *
  * PARAMETERS:  None
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Returns the system to original ACPI/legacy mode, and
- *              uninstalls the SCI interrupt handler.
+ * DESCRIPTION: Transfers the system into LEGACY mode.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_disable (void)
 {
-	acpi_status             status;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE ("Acpi_disable");
+	ACPI_FUNCTION_TRACE ("acpi_disable");
 
 
-	/* Restore original mode  */
+	if (!acpi_gbl_FADT) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "No FADT information present!\n"));
+		return_ACPI_STATUS (AE_NO_ACPI_TABLES);
+	}
 
-	status = acpi_hw_set_mode (acpi_gbl_original_mode);
-	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unable to transition to original mode"));
-		return_ACPI_STATUS (status);
+	if (acpi_hw_get_mode() == ACPI_SYS_MODE_LEGACY) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_INIT, "System is already in legacy (non-ACPI) mode\n"));
 	}
+	else {
+		/* Transition to LEGACY mode */
+
+		status = acpi_hw_set_mode (ACPI_SYS_MODE_LEGACY);
 
-	/* Unload the SCI interrupt handler  */
+		if (ACPI_FAILURE (status)) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not exit ACPI mode to legacy mode"));
+			return_ACPI_STATUS (status);
+		}
 
-	acpi_ev_remove_sci_handler ();
-	acpi_ev_restore_acpi_state ();
+		ACPI_DEBUG_PRINT ((ACPI_DB_INIT, "ACPI mode disabled\n"));
+	}
 
 	return_ACPI_STATUS (status);
 }
@@ -125,107 +145,179 @@ acpi_disable (void)
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_enable_event
+ * FUNCTION:    acpi_enable_event
  *
- * PARAMETERS:  Event           - The fixed event or GPE to be enabled
- *              Type            - The type of event
- *              Flags           - Just enable, or also wake enable?
+ * PARAMETERS:  Event           - The fixed eventto be enabled
+ *              Flags           - Reserved
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Enable an ACPI event (fixed and general purpose)
+ * DESCRIPTION: Enable an ACPI event (fixed)
  *
  ******************************************************************************/
 
 acpi_status
 acpi_enable_event (
-	u32                     event,
-	u32                     type,
-	u32                     flags)
+	u32                             event,
+	u32                             flags)
 {
-	acpi_status             status = AE_OK;
-	u32                     register_id;
+	acpi_status                     status = AE_OK;
+	u32                             value;
 
 
-	FUNCTION_TRACE ("Acpi_enable_event");
+	ACPI_FUNCTION_TRACE ("acpi_enable_event");
 
 
-	/* The Type must be either Fixed Acpi_event or GPE */
+	/* Decode the Fixed Event */
 
-	switch (type) {
+	if (event > ACPI_EVENT_MAX) {
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
 
-	case ACPI_EVENT_FIXED:
+	/*
+	 * Enable the requested fixed event (by writing a one to the
+	 * enable register bit)
+	 */
+	status = acpi_set_register (acpi_gbl_fixed_event_info[event].enable_register_id,
+			 1, ACPI_MTX_LOCK);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
-		/* Decode the Fixed Acpi_event */
+	/* Make sure that the hardware responded */
 
-		switch (event) {
-		case ACPI_EVENT_PMTIMER:
-			register_id = TMR_EN;
-			break;
+	status = acpi_get_register (acpi_gbl_fixed_event_info[event].enable_register_id,
+			  &value, ACPI_MTX_LOCK);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
-		case ACPI_EVENT_GLOBAL:
-			register_id = GBL_EN;
-			break;
+	if (value != 1) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Could not enable %s event\n", acpi_ut_get_event_name (event)));
+		return_ACPI_STATUS (AE_NO_HARDWARE_RESPONSE);
+	}
 
-		case ACPI_EVENT_POWER_BUTTON:
-			register_id = PWRBTN_EN;
-			break;
+	return_ACPI_STATUS (status);
+}
 
-		case ACPI_EVENT_SLEEP_BUTTON:
-			register_id = SLPBTN_EN;
-			break;
 
-		case ACPI_EVENT_RTC:
-			register_id = RTC_EN;
-			break;
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_enable_gpe
+ *
+ * PARAMETERS:  gpe_device      - Parent GPE Device
+ *              gpe_number      - GPE level within the GPE block
+ *              Flags           - Just enable, or also wake enable?
+ *                                Called from ISR or not
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Enable an ACPI event (general purpose)
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_enable_gpe (
+	acpi_handle                     gpe_device,
+	u32                             gpe_number,
+	u32                             flags)
+{
+	acpi_status                     status = AE_OK;
+	struct acpi_gpe_event_info      *gpe_event_info;
 
-		default:
-			return_ACPI_STATUS (AE_BAD_PARAMETER);
-			break;
-		}
 
-		/*
-		 * Enable the requested fixed event (by writing a one to the
-		 * enable register bit)
-		 */
-		acpi_hw_register_bit_access (ACPI_WRITE, ACPI_MTX_LOCK, register_id, 1);
-
-		if (1 != acpi_hw_register_bit_access(ACPI_READ, ACPI_MTX_LOCK, register_id)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Fixed event bit clear when it should be set\n"));
-			return_ACPI_STATUS (AE_NO_HARDWARE_RESPONSE);
+	ACPI_FUNCTION_TRACE ("acpi_enable_gpe");
+
+
+	/* Use semaphore lock if not executing at interrupt level */
+
+	if (flags & ACPI_NOT_ISR) {
+		status = acpi_ut_acquire_mutex (ACPI_MTX_EVENTS);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
 		}
+	}
 
-		break;
+	/* Ensure that we have a valid GPE number */
 
+	gpe_event_info = acpi_ev_get_gpe_event_info (gpe_device, gpe_number);
+	if (!gpe_event_info) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
 
-	case ACPI_EVENT_GPE:
+	/* Enable the requested GPE number */
 
-		/* Ensure that we have a valid GPE number */
+	status = acpi_hw_enable_gpe (gpe_event_info);
+	if (ACPI_FAILURE (status)) {
+		goto unlock_and_exit;
+	}
 
-		if ((event > ACPI_GPE_MAX) ||
-			(acpi_gbl_gpe_valid[event] == ACPI_GPE_INVALID)) {
-			return_ACPI_STATUS (AE_BAD_PARAMETER);
-		}
+	if (flags & ACPI_EVENT_WAKE_ENABLE) {
+		acpi_hw_enable_gpe_for_wakeup (gpe_event_info);
+	}
 
+unlock_and_exit:
+	if (flags & ACPI_NOT_ISR) {
+		(void) acpi_ut_release_mutex (ACPI_MTX_EVENTS);
+	}
+	return_ACPI_STATUS (status);
+}
 
-		/* Enable the requested GPE number */
 
-		if (flags & ACPI_EVENT_ENABLE) {
-			acpi_hw_enable_gpe (event);
-		}
-		if (flags & ACPI_EVENT_WAKE_ENABLE) {
-			acpi_hw_enable_gpe_for_wakeup (event);
-		}
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_disable_event
+ *
+ * PARAMETERS:  Event           - The fixed eventto be enabled
+ *              Flags           - Reserved
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Disable an ACPI event (fixed)
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_disable_event (
+	u32                             event,
+	u32                             flags)
+{
+	acpi_status                     status = AE_OK;
+	u32                             value;
 
-		break;
 
+	ACPI_FUNCTION_TRACE ("acpi_disable_event");
 
-	default:
 
-		status = AE_BAD_PARAMETER;
+	/* Decode the Fixed Event */
+
+	if (event > ACPI_EVENT_MAX) {
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
+
+	/*
+	 * Disable the requested fixed event (by writing a zero to the
+	 * enable register bit)
+	 */
+	status = acpi_set_register (acpi_gbl_fixed_event_info[event].enable_register_id,
+			 0, ACPI_MTX_LOCK);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	status = acpi_get_register (acpi_gbl_fixed_event_info[event].enable_register_id,
+			 &value, ACPI_MTX_LOCK);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
 	}
 
+	if (value != 0) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Could not disable %s events\n", acpi_ut_get_event_name (event)));
+		return_ACPI_STATUS (AE_NO_HARDWARE_RESPONSE);
+	}
 
 	return_ACPI_STATUS (status);
 }
@@ -233,293 +325,412 @@ acpi_enable_event (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_disable_event
+ * FUNCTION:    acpi_disable_gpe
  *
- * PARAMETERS:  Event           - The fixed event or GPE to be enabled
- *              Type            - The type of event, fixed or general purpose
- *              Flags           - Wake disable vs. non-wake disable
+ * PARAMETERS:  gpe_device      - Parent GPE Device
+ *              gpe_number      - GPE level within the GPE block
+ *              Flags           - Just enable, or also wake enable?
+ *                                Called from ISR or not
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Disable an ACPI event (fixed and general purpose)
+ * DESCRIPTION: Disable an ACPI event (general purpose)
  *
  ******************************************************************************/
 
 acpi_status
-acpi_disable_event (
-	u32                     event,
-	u32                     type,
-	u32                     flags)
+acpi_disable_gpe (
+	acpi_handle                     gpe_device,
+	u32                             gpe_number,
+	u32                             flags)
 {
-	acpi_status             status = AE_OK;
-	u32                     register_id;
+	acpi_status                     status = AE_OK;
+	struct acpi_gpe_event_info      *gpe_event_info;
+
+
+	ACPI_FUNCTION_TRACE ("acpi_disable_gpe");
+
+
+	/* Use semaphore lock if not executing at interrupt level */
+
+	if (flags & ACPI_NOT_ISR) {
+		status = acpi_ut_acquire_mutex (ACPI_MTX_EVENTS);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
+	}
 
+	/* Ensure that we have a valid GPE number */
 
-	FUNCTION_TRACE ("Acpi_disable_event");
+	gpe_event_info = acpi_ev_get_gpe_event_info (gpe_device, gpe_number);
+	if (!gpe_event_info) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	/*
+	 * Only disable the requested GPE number for wake if specified.
+	 * Otherwise, turn it totally off
+	 */
+	if (flags & ACPI_EVENT_WAKE_DISABLE) {
+		acpi_hw_disable_gpe_for_wakeup (gpe_event_info);
+	}
+	else {
+		status = acpi_hw_disable_gpe (gpe_event_info);
+	}
 
+unlock_and_exit:
+	if (flags & ACPI_NOT_ISR) {
+		(void) acpi_ut_release_mutex (ACPI_MTX_EVENTS);
+	}
+	return_ACPI_STATUS (status);
+}
 
-	/* The Type must be either Fixed Acpi_event or GPE */
 
-	switch (type) {
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_clear_event
+ *
+ * PARAMETERS:  Event           - The fixed event to be cleared
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Clear an ACPI event (fixed)
+ *
+ ******************************************************************************/
 
-	case ACPI_EVENT_FIXED:
+acpi_status
+acpi_clear_event (
+	u32                             event)
+{
+	acpi_status                     status = AE_OK;
 
-		/* Decode the Fixed Acpi_event */
 
-		switch (event) {
-		case ACPI_EVENT_PMTIMER:
-			register_id = TMR_EN;
-			break;
+	ACPI_FUNCTION_TRACE ("acpi_clear_event");
 
-		case ACPI_EVENT_GLOBAL:
-			register_id = GBL_EN;
-			break;
 
-		case ACPI_EVENT_POWER_BUTTON:
-			register_id = PWRBTN_EN;
-			break;
+	/* Decode the Fixed Event */
 
-		case ACPI_EVENT_SLEEP_BUTTON:
-			register_id = SLPBTN_EN;
-			break;
+	if (event > ACPI_EVENT_MAX) {
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
 
-		case ACPI_EVENT_RTC:
-			register_id = RTC_EN;
-			break;
+	/*
+	 * Clear the requested fixed event (By writing a one to the
+	 * status register bit)
+	 */
+	status = acpi_set_register (acpi_gbl_fixed_event_info[event].status_register_id,
+			1, ACPI_MTX_LOCK);
 
-		default:
-			return_ACPI_STATUS (AE_BAD_PARAMETER);
-			break;
-		}
+	return_ACPI_STATUS (status);
+}
 
-		/*
-		 * Disable the requested fixed event (by writing a zero to the
-		 * enable register bit)
-		 */
-		acpi_hw_register_bit_access (ACPI_WRITE, ACPI_MTX_LOCK, register_id, 0);
-
-		if (0 != acpi_hw_register_bit_access(ACPI_READ, ACPI_MTX_LOCK, register_id)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Fixed event bit set when it should be clear,\n"));
-			return_ACPI_STATUS (AE_NO_HARDWARE_RESPONSE);
-		}
 
-		break;
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_clear_gpe
+ *
+ * PARAMETERS:  gpe_device      - Parent GPE Device
+ *              gpe_number      - GPE level within the GPE block
+ *              Flags           - Called from an ISR or not
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Clear an ACPI event (general purpose)
+ *
+ ******************************************************************************/
 
+acpi_status
+acpi_clear_gpe (
+	acpi_handle                     gpe_device,
+	u32                             gpe_number,
+	u32                             flags)
+{
+	acpi_status                     status = AE_OK;
+	struct acpi_gpe_event_info      *gpe_event_info;
 
-	case ACPI_EVENT_GPE:
 
-		/* Ensure that we have a valid GPE number */
+	ACPI_FUNCTION_TRACE ("acpi_clear_gpe");
 
-		if ((event > ACPI_GPE_MAX) ||
-			(acpi_gbl_gpe_valid[event] == ACPI_GPE_INVALID)) {
-			return_ACPI_STATUS (AE_BAD_PARAMETER);
-		}
 
-		/* Disable the requested GPE number */
+	/* Use semaphore lock if not executing at interrupt level */
 
-		if (flags & ACPI_EVENT_DISABLE) {
-			acpi_hw_disable_gpe (event);
-		}
-		if (flags & ACPI_EVENT_WAKE_DISABLE) {
-			acpi_hw_disable_gpe_for_wakeup (event);
+	if (flags & ACPI_NOT_ISR) {
+		status = acpi_ut_acquire_mutex (ACPI_MTX_EVENTS);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
 		}
+	}
 
-		break;
-
+	/* Ensure that we have a valid GPE number */
 
-	default:
+	gpe_event_info = acpi_ev_get_gpe_event_info (gpe_device, gpe_number);
+	if (!gpe_event_info) {
 		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
 	}
 
+	status = acpi_hw_clear_gpe (gpe_event_info);
+
+unlock_and_exit:
+	if (flags & ACPI_NOT_ISR) {
+		(void) acpi_ut_release_mutex (ACPI_MTX_EVENTS);
+	}
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_clear_event
+ * FUNCTION:    acpi_get_event_status
  *
- * PARAMETERS:  Event           - The fixed event or GPE to be cleared
- *              Type            - The type of event
+ * PARAMETERS:  Event           - The fixed event
+ *              Event Status    - Where the current status of the event will
+ *                                be returned
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Clear an ACPI event (fixed and general purpose)
+ * DESCRIPTION: Obtains and returns the current status of the event
  *
  ******************************************************************************/
 
 acpi_status
-acpi_clear_event (
-	u32                     event,
-	u32                     type)
+acpi_get_event_status (
+	u32                             event,
+	acpi_event_status               *event_status)
 {
-	acpi_status             status = AE_OK;
-	u32                     register_id;
-
+	acpi_status                     status = AE_OK;
 
-	FUNCTION_TRACE ("Acpi_clear_event");
 
+	ACPI_FUNCTION_TRACE ("acpi_get_event_status");
 
-	/* The Type must be either Fixed Acpi_event or GPE */
 
-	switch (type) {
+	if (!event_status) {
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
 
-	case ACPI_EVENT_FIXED:
+	/* Decode the Fixed Event */
 
-		/* Decode the Fixed Acpi_event */
+	if (event > ACPI_EVENT_MAX) {
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
 
-		switch (event) {
-		case ACPI_EVENT_PMTIMER:
-			register_id = TMR_STS;
-			break;
+	/* Get the status of the requested fixed event */
 
-		case ACPI_EVENT_GLOBAL:
-			register_id = GBL_STS;
-			break;
+	status = acpi_get_register (acpi_gbl_fixed_event_info[event].status_register_id,
+			  event_status, ACPI_MTX_LOCK);
 
-		case ACPI_EVENT_POWER_BUTTON:
-			register_id = PWRBTN_STS;
-			break;
+	return_ACPI_STATUS (status);
+}
 
-		case ACPI_EVENT_SLEEP_BUTTON:
-			register_id = SLPBTN_STS;
-			break;
 
-		case ACPI_EVENT_RTC:
-			register_id = RTC_STS;
-			break;
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_gpe_status
+ *
+ * PARAMETERS:  gpe_device      - Parent GPE Device
+ *              gpe_number      - GPE level within the GPE block
+ *              Flags           - Called from an ISR or not
+ *              Event Status    - Where the current status of the event will
+ *                                be returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get status of an event (general purpose)
+ *
+ ******************************************************************************/
 
-		default:
-			return_ACPI_STATUS (AE_BAD_PARAMETER);
-			break;
-		}
+acpi_status
+acpi_get_gpe_status (
+	acpi_handle                     gpe_device,
+	u32                             gpe_number,
+	u32                             flags,
+	acpi_event_status               *event_status)
+{
+	acpi_status                     status = AE_OK;
+	struct acpi_gpe_event_info      *gpe_event_info;
 
-		/*
-		 * Clear the requested fixed event (By writing a one to the
-		 * status register bit)
-		 */
-		acpi_hw_register_bit_access (ACPI_WRITE, ACPI_MTX_LOCK, register_id, 1);
-		break;
 
+	ACPI_FUNCTION_TRACE ("acpi_get_gpe_status");
 
-	case ACPI_EVENT_GPE:
 
-		/* Ensure that we have a valid GPE number */
+	/* Use semaphore lock if not executing at interrupt level */
 
-		if ((event > ACPI_GPE_MAX) ||
-			(acpi_gbl_gpe_valid[event] == ACPI_GPE_INVALID)) {
-			return_ACPI_STATUS (AE_BAD_PARAMETER);
+	if (flags & ACPI_NOT_ISR) {
+		status = acpi_ut_acquire_mutex (ACPI_MTX_EVENTS);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
 		}
+	}
 
+	/* Ensure that we have a valid GPE number */
 
-		acpi_hw_clear_gpe (event);
-		break;
+	gpe_event_info = acpi_ev_get_gpe_event_info (gpe_device, gpe_number);
+	if (!gpe_event_info) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
 
+	/* Obtain status on the requested GPE number */
 
-	default:
+	status = acpi_hw_get_gpe_status (gpe_event_info, event_status);
 
-		status = AE_BAD_PARAMETER;
+unlock_and_exit:
+	if (flags & ACPI_NOT_ISR) {
+		(void) acpi_ut_release_mutex (ACPI_MTX_EVENTS);
 	}
-
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_get_event_status
+ * FUNCTION:    acpi_install_gpe_block
  *
- * PARAMETERS:  Event           - The fixed event or GPE
- *              Type            - The type of event
- *              Status          - Where the current status of the event will
- *                                be returned
+ * PARAMETERS:  gpe_device          - Handle to the parent GPE Block Device
+ *              gpe_block_address   - Address and space_iD
+ *              register_count      - Number of GPE register pairs in the block
+ *              interrupt_level     - H/W interrupt for the block
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Obtains and returns the current status of the event
+ * DESCRIPTION: Create and Install a block of GPE registers
  *
  ******************************************************************************/
 
-
 acpi_status
-acpi_get_event_status (
-	u32                     event,
-	u32                     type,
-	acpi_event_status       *event_status)
+acpi_install_gpe_block (
+	acpi_handle                     gpe_device,
+	struct acpi_generic_address     *gpe_block_address,
+	u32                             register_count,
+	u32                             interrupt_level)
 {
-	acpi_status             status = AE_OK;
-	u32                     register_id;
+	acpi_status                     status;
+	union acpi_operand_object       *obj_desc;
+	struct acpi_namespace_node      *node;
+	struct acpi_gpe_block_info      *gpe_block;
 
 
-	FUNCTION_TRACE ("Acpi_get_event_status");
+	ACPI_FUNCTION_TRACE ("acpi_install_gpe_block");
 
 
-	if (!event_status) {
+	if ((!gpe_device)      ||
+		(!gpe_block_address) ||
+		(!register_count)) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
 
-	/* The Type must be either Fixed Acpi_event or GPE */
-
-	switch (type) {
+	node = acpi_ns_map_handle_to_node (gpe_device);
+	if (!node) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
 
-	case ACPI_EVENT_FIXED:
+	/*
+	 * For user-installed GPE Block Devices, the gpe_block_base_number
+	 * is always zero
+	 */
+	status = acpi_ev_create_gpe_block (node, gpe_block_address, register_count,
+			  0, interrupt_level, &gpe_block);
+	if (ACPI_FAILURE (status)) {
+		goto unlock_and_exit;
+	}
 
-		/* Decode the Fixed Acpi_event */
+	/* Get the device_object attached to the node */
 
-		switch (event) {
-		case ACPI_EVENT_PMTIMER:
-			register_id = TMR_STS;
-			break;
+	obj_desc = acpi_ns_get_attached_object (node);
+	if (!obj_desc) {
+		/* No object, create a new one */
 
-		case ACPI_EVENT_GLOBAL:
-			register_id = GBL_STS;
-			break;
+		obj_desc = acpi_ut_create_internal_object (ACPI_TYPE_DEVICE);
+		if (!obj_desc) {
+			status = AE_NO_MEMORY;
+			goto unlock_and_exit;
+		}
 
-		case ACPI_EVENT_POWER_BUTTON:
-			register_id = PWRBTN_STS;
-			break;
+		status = acpi_ns_attach_object (node, obj_desc, ACPI_TYPE_DEVICE);
 
-		case ACPI_EVENT_SLEEP_BUTTON:
-			register_id = SLPBTN_STS;
-			break;
+		/* Remove local reference to the object */
 
-		case ACPI_EVENT_RTC:
-			register_id = RTC_STS;
-			break;
+		acpi_ut_remove_reference (obj_desc);
 
-		default:
-			return_ACPI_STATUS (AE_BAD_PARAMETER);
-			break;
+		if (ACPI_FAILURE (status)) {
+			goto unlock_and_exit;
 		}
+	}
+
+	/* Install the GPE block in the device_object */
 
-		/* Get the status of the requested fixed event */
+	obj_desc->device.gpe_block = gpe_block;
 
-		*event_status = acpi_hw_register_bit_access (ACPI_READ, ACPI_MTX_LOCK, register_id);
-		break;
 
+unlock_and_exit:
+	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	return_ACPI_STATUS (status);
+}
 
-	case ACPI_EVENT_GPE:
 
-		/* Ensure that we have a valid GPE number */
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_remove_gpe_block
+ *
+ * PARAMETERS:  gpe_device          - Handle to the parent GPE Block Device
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Remove a previously installed block of GPE registers
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_remove_gpe_block (
+	acpi_handle                     gpe_device)
+{
+	union acpi_operand_object       *obj_desc;
+	acpi_status                     status;
+	struct acpi_namespace_node      *node;
 
-		if ((event > ACPI_GPE_MAX) ||
-			(acpi_gbl_gpe_valid[event] == ACPI_GPE_INVALID)) {
-			return_ACPI_STATUS (AE_BAD_PARAMETER);
-		}
 
+	ACPI_FUNCTION_TRACE ("acpi_remove_gpe_block");
 
-		/* Obtain status on the requested GPE number */
 
-		acpi_hw_get_gpe_status (event, event_status);
-		break;
+	if (!gpe_device) {
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
 
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
 
-	default:
+	node = acpi_ns_map_handle_to_node (gpe_device);
+	if (!node) {
 		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	/* Get the device_object attached to the node */
+
+	obj_desc = acpi_ns_get_attached_object (node);
+	if (!obj_desc ||
+		!obj_desc->device.gpe_block) {
+		return_ACPI_STATUS (AE_NULL_OBJECT);
+	}
+
+	/* Delete the GPE block (but not the device_object) */
+
+	status = acpi_ev_delete_gpe_block (obj_desc->device.gpe_block);
+	if (ACPI_SUCCESS (status)) {
+		obj_desc->device.gpe_block = NULL;
 	}
 
+unlock_and_exit:
+	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 	return_ACPI_STATUS (status);
 }
 
diff -urNp linux-5400/drivers/acpi/events/evxfregn.c linux-5410/drivers/acpi/events/evxfregn.c
--- linux-5400/drivers/acpi/events/evxfregn.c
+++ linux-5410/drivers/acpi/events/evxfregn.c
@@ -2,84 +2,101 @@
  *
  * Module Name: evxfregn - External Interfaces, ACPI Operation Regions and
  *                         Address Spaces.
- *              $Revision: 40 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "achware.h"
-#include "acnamesp.h"
-#include "acevents.h"
-#include "amlcode.h"
-#include "acinterp.h"
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acevents.h>
+#include <acpi/acinterp.h>
 
 #define _COMPONENT          ACPI_EVENTS
-	 MODULE_NAME         ("evxfregn")
+	 ACPI_MODULE_NAME    ("evxfregn")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_install_address_space_handler
+ * FUNCTION:    acpi_install_address_space_handler
  *
  * PARAMETERS:  Device          - Handle for the device
- *              Space_id        - The address space ID
+ *              space_id        - The address space ID
  *              Handler         - Address of the handler
  *              Setup           - Address of the setup function
  *              Context         - Value passed to the handler on each access
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Install a handler for all Op_regions of a given Space_id.
+ * DESCRIPTION: Install a handler for all op_regions of a given space_id.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_install_address_space_handler (
-	acpi_handle             device,
-	ACPI_ADR_SPACE_TYPE     space_id,
-	acpi_adr_space_handler  handler,
-	acpi_adr_space_setup    setup,
-	void                    *context)
+	acpi_handle                     device,
+	acpi_adr_space_type             space_id,
+	acpi_adr_space_handler          handler,
+	acpi_adr_space_setup            setup,
+	void                            *context)
 {
-	acpi_operand_object     *obj_desc;
-	acpi_operand_object     *handler_obj;
-	acpi_namespace_node     *node;
-	acpi_status             status = AE_OK;
-	acpi_object_type8       type;
-	u16                     flags = 0;
+	union acpi_operand_object       *obj_desc;
+	union acpi_operand_object       *handler_obj;
+	struct acpi_namespace_node      *node;
+	acpi_status                     status;
+	acpi_object_type                type;
+	u16                             flags = 0;
 
 
-	FUNCTION_TRACE ("Acpi_install_address_space_handler");
+	ACPI_FUNCTION_TRACE ("acpi_install_address_space_handler");
 
 
 	/* Parameter validation */
 
-	if ((!device)   ||
-		((!handler)  && (handler != ACPI_DEFAULT_HANDLER)) ||
-		(space_id > ACPI_MAX_ADDRESS_SPACE)) {
+	if (!device) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	/* Convert and validate the device handle */
 
@@ -103,7 +120,7 @@ acpi_install_address_space_handler (
 	}
 
 	if (handler == ACPI_DEFAULT_HANDLER) {
-		flags = ADDR_HANDLER_DEFAULT_INSTALLED;
+		flags = ACPI_ADDR_HANDLER_DEFAULT_INSTALLED;
 
 		switch (space_id) {
 		case ACPI_ADR_SPACE_SYSTEM_MEMORY:
@@ -131,55 +148,65 @@ acpi_install_address_space_handler (
 			setup   = acpi_ev_pci_bar_region_setup;
 			break;
 
+		case ACPI_ADR_SPACE_DATA_TABLE:
+			handler = acpi_ex_data_table_space_handler;
+			setup   = NULL;
+			break;
+
 		default:
-			status = AE_NOT_EXIST;
+			status = AE_BAD_PARAMETER;
 			goto unlock_and_exit;
-			break;
 		}
 	}
 
-	/*
-	 * If the caller hasn't specified a setup routine, use the default
-	 */
+	/* If the caller hasn't specified a setup routine, use the default */
+
 	if (!setup) {
 		setup = acpi_ev_default_region_setup;
 	}
 
-	/*
-	 * Check for an existing internal object
-	 */
+	/* Check for an existing internal object */
+
 	obj_desc = acpi_ns_get_attached_object (node);
 	if (obj_desc) {
 		/*
-		 * The object exists.
+		 * The attached device object already exists.
 		 * Make sure the handler is not already installed.
 		 */
+		handler_obj = obj_desc->device.address_space;
 
-		/* check the address handler the user requested */
+		/* Walk the handler list for this device */
 
-		handler_obj = obj_desc->device.addr_handler;
 		while (handler_obj) {
-			/*
-			 * We have an Address handler, see if user requested this
-			 * address space.
-			 */
-			if(handler_obj->addr_handler.space_id == space_id) {
-				status = AE_EXIST;
+			/* Same space_id indicates a handler already installed */
+
+			if(handler_obj->address_space.space_id == space_id) {
+				if (handler_obj->address_space.handler == handler) {
+					/*
+					 * It is (relatively) OK to attempt to install the SAME
+					 * handler twice. This can easily happen with PCI_Config space.
+					 */
+					status = AE_SAME_HANDLER;
+					goto unlock_and_exit;
+				}
+				else {
+					/* A handler is already installed */
+
+					status = AE_ALREADY_EXISTS;
+				}
 				goto unlock_and_exit;
 			}
 
-			/*
-			 * Move through the linked list of handlers
-			 */
-			handler_obj = handler_obj->addr_handler.next;
+			/* Walk the linked list of handlers */
+
+			handler_obj = handler_obj->address_space.next;
 		}
 	}
-
 	else {
 		ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
 			"Creating object on Device %p while installing handler\n", node));
 
-		/* Obj_desc does not exist, create one */
+		/* obj_desc does not exist, create one */
 
 		if (node->type == ACPI_TYPE_ANY) {
 			type = ACPI_TYPE_DEVICE;
@@ -200,110 +227,117 @@ acpi_install_address_space_handler (
 
 		/* Attach the new object to the Node */
 
-		status = acpi_ns_attach_object (node, obj_desc, (u8) type);
+		status = acpi_ns_attach_object (node, obj_desc, type);
+
+		/* Remove local reference to the object */
+
+		acpi_ut_remove_reference (obj_desc);
+
 		if (ACPI_FAILURE (status)) {
-			acpi_ut_remove_reference (obj_desc);
 			goto unlock_and_exit;
 		}
 	}
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
-		"Installing address handler for region %s(%X) on Device %p(%p)\n",
-		acpi_ut_get_region_name (space_id), space_id, node, obj_desc));
+		"Installing address handler for region %s(%X) on Device %4.4s %p(%p)\n",
+		acpi_ut_get_region_name (space_id), space_id, node->name.ascii, node, obj_desc));
 
 	/*
-	 * Now we can install the handler
+	 * Install the handler
 	 *
-	 * At this point we know that there is no existing handler.
-	 * So, we just allocate the object for the handler and link it
+	 * At this point there is no existing handler.
+	 * Just allocate the object for the handler and link it
 	 * into the list.
 	 */
-	handler_obj = acpi_ut_create_internal_object (INTERNAL_TYPE_ADDRESS_HANDLER);
+	handler_obj = acpi_ut_create_internal_object (ACPI_TYPE_LOCAL_ADDRESS_HANDLER);
 	if (!handler_obj) {
 		status = AE_NO_MEMORY;
 		goto unlock_and_exit;
 	}
 
-	handler_obj->addr_handler.space_id  = (u8) space_id;
-	handler_obj->addr_handler.hflags    = flags;
-	handler_obj->addr_handler.next      = obj_desc->device.addr_handler;
-	handler_obj->addr_handler.region_list = NULL;
-	handler_obj->addr_handler.node      = node;
-	handler_obj->addr_handler.handler   = handler;
-	handler_obj->addr_handler.context   = context;
-	handler_obj->addr_handler.setup     = setup;
+	/* Init handler obj */
+
+	handler_obj->address_space.space_id  = (u8) space_id;
+	handler_obj->address_space.hflags    = flags;
+	handler_obj->address_space.region_list = NULL;
+	handler_obj->address_space.node      = node;
+	handler_obj->address_space.handler   = handler;
+	handler_obj->address_space.context   = context;
+	handler_obj->address_space.setup     = setup;
+
+	/* Install at head of Device.address_space list */
+
+	handler_obj->address_space.next      = obj_desc->device.address_space;
+
+	/*
+	 * The Device object is the first reference on the handler_obj.
+	 * Each region that uses the handler adds a reference.
+	 */
+	obj_desc->device.address_space = handler_obj;
 
 	/*
-	 * Now walk the namespace finding all of the regions this
+	 * Walk the namespace finding all of the regions this
 	 * handler will manage.
 	 *
-	 * We start at the device and search the branch toward
+	 * Start at the device and search the branch toward
 	 * the leaf nodes until either the leaf is encountered or
 	 * a device is detected that has an address handler of the
 	 * same type.
 	 *
-	 * In either case we back up and search down the remainder
+	 * In either case, back up and search down the remainder
 	 * of the branch
 	 */
-	status = acpi_ns_walk_namespace (ACPI_TYPE_ANY, device,
-			 ACPI_UINT32_MAX, NS_WALK_UNLOCK,
-			 acpi_ev_addr_handler_helper,
-			 handler_obj, NULL);
-
-	/*
-	 * Place this handler 1st on the list
-	 */
-	handler_obj->common.reference_count =
-			 (u16) (handler_obj->common.reference_count +
-			 obj_desc->common.reference_count - 1);
-	obj_desc->device.addr_handler = handler_obj;
-
+	status = acpi_ns_walk_namespace (ACPI_TYPE_ANY, device, ACPI_UINT32_MAX,
+			  ACPI_NS_WALK_UNLOCK, acpi_ev_install_handler,
+			  handler_obj, NULL);
 
 unlock_and_exit:
-	acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_remove_address_space_handler
+ * FUNCTION:    acpi_remove_address_space_handler
  *
- * PARAMETERS:  Space_id        - The address space ID
+ * PARAMETERS:  Device          - Handle for the device
+ *              space_id        - The address space ID
  *              Handler         - Address of the handler
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Install a handler for accesses on an Operation Region
+ * DESCRIPTION: Remove a previously installed handler.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_remove_address_space_handler (
-	acpi_handle             device,
-	ACPI_ADR_SPACE_TYPE     space_id,
-	acpi_adr_space_handler  handler)
+	acpi_handle                     device,
+	acpi_adr_space_type             space_id,
+	acpi_adr_space_handler          handler)
 {
-	acpi_operand_object     *obj_desc;
-	acpi_operand_object     *handler_obj;
-	acpi_operand_object     *region_obj;
-	acpi_operand_object     **last_obj_ptr;
-	acpi_namespace_node     *node;
-	acpi_status             status = AE_OK;
+	union acpi_operand_object       *obj_desc;
+	union acpi_operand_object       *handler_obj;
+	union acpi_operand_object       *region_obj;
+	union acpi_operand_object       **last_obj_ptr;
+	struct acpi_namespace_node      *node;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Acpi_remove_address_space_handler");
+	ACPI_FUNCTION_TRACE ("acpi_remove_address_space_handler");
 
 
 	/* Parameter validation */
 
-	if ((!device)   ||
-		((!handler)  && (handler != ACPI_DEFAULT_HANDLER)) ||
-		(space_id > ACPI_MAX_ADDRESS_SPACE)) {
+	if (!device) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	/* Convert and validate the device handle */
 
@@ -313,7 +347,6 @@ acpi_remove_address_space_handler (
 		goto unlock_and_exit;
 	}
 
-
 	/* Make sure the internal object exists */
 
 	obj_desc = acpi_ns_get_attached_object (node);
@@ -322,25 +355,22 @@ acpi_remove_address_space_handler (
 		goto unlock_and_exit;
 	}
 
-	/*
-	 * find the address handler the user requested
-	 */
-	handler_obj = obj_desc->device.addr_handler;
-	last_obj_ptr = &obj_desc->device.addr_handler;
+	/* Find the address handler the user requested */
+
+	handler_obj = obj_desc->device.address_space;
+	last_obj_ptr = &obj_desc->device.address_space;
 	while (handler_obj) {
-		/*
-		 * We have a handler, see if user requested this one
-		 */
-		if (handler_obj->addr_handler.space_id == space_id) {
-			/*
-			 * Got it, first dereference this in the Regions
-			 */
+		/* We have a handler, see if user requested this one */
+
+		if (handler_obj->address_space.space_id == space_id) {
+			/* Matched space_id, first dereference this in the Regions */
+
 			ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
 				"Removing address handler %p(%p) for region %s on Device %p(%p)\n",
 				handler_obj, handler, acpi_ut_get_region_name (space_id),
 				node, obj_desc));
 
-			region_obj = handler_obj->addr_handler.region_list;
+			region_obj = handler_obj->address_space.region_list;
 
 			/* Walk the handler's region list */
 
@@ -352,51 +382,42 @@ acpi_remove_address_space_handler (
 				 * The region is just inaccessible as indicated to
 				 * the _REG method
 				 */
-				acpi_ev_disassociate_region_from_handler(region_obj, TRUE);
+				acpi_ev_detach_region (region_obj, TRUE);
 
 				/*
-				 * Walk the list, since we took the first region and it
-				 * was removed from the list by the dissassociate call
-				 * we just get the first item on the list again
+				 * Walk the list: Just grab the head because the
+				 * detach_region removed the previous head.
 				 */
-				region_obj = handler_obj->addr_handler.region_list;
+				region_obj = handler_obj->address_space.region_list;
 
 			}
 
-			/*
-			 * Remove this Handler object from the list
-			 */
-			*last_obj_ptr = handler_obj->addr_handler.next;
-
-			/*
-			 * Now we can delete the handler object
-			 */
-			acpi_ut_remove_reference (handler_obj);
-			acpi_ut_remove_reference (handler_obj);
+			/* Remove this Handler object from the list */
 
+			*last_obj_ptr = handler_obj->address_space.next;
+
+			/* Now we can delete the handler object */
+
+			acpi_ut_remove_reference (handler_obj);
 			goto unlock_and_exit;
 		}
 
-		/*
-		 * Move through the linked list of handlers
-		 */
-		last_obj_ptr = &handler_obj->addr_handler.next;
-		handler_obj = handler_obj->addr_handler.next;
+		/* Walk the linked list of handlers */
+
+		last_obj_ptr = &handler_obj->address_space.next;
+		handler_obj = handler_obj->address_space.next;
 	}
 
+	/* The handler does not exist */
 
-	/*
-	 * The handler does not exist
-	 */
 	ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
-		"Unable to remove address handler %p for %s(%X), Dev_node %p, obj %p\n",
+		"Unable to remove address handler %p for %s(%X), dev_node %p, obj %p\n",
 		handler, acpi_ut_get_region_name (space_id), space_id, node, obj_desc));
 
 	status = AE_NOT_EXIST;
 
-
 unlock_and_exit:
-	acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 	return_ACPI_STATUS (status);
 }
 
diff -urNp linux-5400/drivers/acpi/executer/Makefile linux-5410/drivers/acpi/executer/Makefile
--- linux-5400/drivers/acpi/executer/Makefile
+++ linux-5410/drivers/acpi/executer/Makefile
@@ -1,11 +1,10 @@
 #
 # Makefile for all Linux ACPI interpreter subdirectories
-# EXCEPT for the ospm directory
 #
 
 O_TARGET := $(notdir $(CURDIR)).o
 
-obj-$(CONFIG_ACPI) := $(patsubst %.c,%.o,$(wildcard *.c))
+obj-$(CONFIG_ACPI_INTERPRETER) := $(patsubst %.c,%.o,$(wildcard *.c))
 
 EXTRA_CFLAGS += $(ACPI_CFLAGS)
 
diff -urNp linux-5400/drivers/acpi/executer/exconfig.c linux-5410/drivers/acpi/executer/exconfig.c
--- linux-5400/drivers/acpi/executer/exconfig.c
+++ linux-5410/drivers/acpi/executer/exconfig.c
@@ -1,242 +1,459 @@
 /******************************************************************************
  *
  * Module Name: exconfig - Namespace reconfiguration (Load/Unload opcodes)
- *              $Revision: 44 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
-#include "acinterp.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "acevents.h"
-#include "actables.h"
-#include "acdispat.h"
+#include <acpi/acpi.h>
+#include <acpi/acinterp.h>
+#include <acpi/amlcode.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acevents.h>
+#include <acpi/actables.h>
 
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("exconfig")
+	 ACPI_MODULE_NAME    ("exconfig")
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_load_table_op
+ * FUNCTION:    acpi_ex_add_table
  *
- * PARAMETERS:  Rgn_desc        - Op region where the table will be obtained
- *              Ddb_handle      - Where a handle to the table will be returned
+ * PARAMETERS:  Table               - Pointer to raw table
+ *              parent_node         - Where to load the table (scope)
+ *              ddb_handle          - Where to return the table handle.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Common function to Install and Load an ACPI table with a
+ *              returned table handle.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_add_table (
+	struct acpi_table_header        *table,
+	struct acpi_namespace_node      *parent_node,
+	union acpi_operand_object       **ddb_handle)
+{
+	acpi_status                     status;
+	struct acpi_table_desc          table_info;
+	union acpi_operand_object       *obj_desc;
+
+
+	ACPI_FUNCTION_TRACE ("ex_add_table");
+
+
+	/* Create an object to be the table handle */
+
+	obj_desc = acpi_ut_create_internal_object (ACPI_TYPE_LOCAL_REFERENCE);
+	if (!obj_desc) {
+		return_ACPI_STATUS (AE_NO_MEMORY);
+	}
+
+	/* Install the new table into the local data structures */
+
+	table_info.pointer     = table;
+	table_info.length      = (acpi_size) table->length;
+	table_info.allocation  = ACPI_MEM_ALLOCATED;
+
+	status = acpi_tb_install_table (&table_info);
+	if (ACPI_FAILURE (status)) {
+		goto cleanup;
+	}
+
+	/* Add the table to the namespace */
+
+	status = acpi_ns_load_table (table_info.installed_desc, parent_node);
+	if (ACPI_FAILURE (status)) {
+		/* Uninstall table on error */
+
+		(void) acpi_tb_uninstall_table (table_info.installed_desc);
+		goto cleanup;
+	}
+
+	/* Init the table handle */
+
+	obj_desc->reference.opcode = AML_LOAD_OP;
+	obj_desc->reference.object = table_info.installed_desc;
+	*ddb_handle = obj_desc;
+	return_ACPI_STATUS (AE_OK);
+
+
+cleanup:
+	acpi_ut_remove_reference (obj_desc);
+	return_ACPI_STATUS (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_load_table_op
+ *
+ * PARAMETERS:  walk_state          - Current state with operands
+ *              return_desc         - Where to store the return object
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Load an ACPI table
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
-acpi_ex_load_op (
-	acpi_operand_object     *rgn_desc,
-	acpi_operand_object     *ddb_handle)
+acpi_ex_load_table_op (
+	struct acpi_walk_state          *walk_state,
+	union acpi_operand_object       **return_desc)
 {
-	acpi_status             status;
-	acpi_operand_object     *table_desc = NULL;
-	u8                      *table_ptr;
-	u8                      *table_data_ptr;
-	acpi_table_header       table_header;
-	acpi_table_desc         table_info;
-	u32                     i;
+	acpi_status                     status;
+	union acpi_operand_object       **operand = &walk_state->operands[0];
+	struct acpi_table_header        *table;
+	struct acpi_namespace_node      *parent_node;
+	struct acpi_namespace_node      *start_node;
+	struct acpi_namespace_node      *parameter_node = NULL;
+	union acpi_operand_object       *ddb_handle;
+
 
+	ACPI_FUNCTION_TRACE ("ex_load_table_op");
 
-	FUNCTION_TRACE ("Ex_load_op");
 
-	/* TBD: [Unhandled] Object can be either a field or an opregion */
+#if 0
+	/*
+	 * Make sure that the signature does not match one of the tables that
+	 * is already loaded.
+	 */
+	status = acpi_tb_match_signature (operand[0]->string.pointer, NULL);
+	if (status == AE_OK) {
+		/* Signature matched -- don't allow override */
 
+		return_ACPI_STATUS (AE_ALREADY_EXISTS);
+	}
+#endif
 
-	/* Get the table header */
+	/* Find the ACPI table */
 
-	table_header.length = 0;
-	for (i = 0; i < sizeof (acpi_table_header); i++) {
-		status = acpi_ev_address_space_dispatch (rgn_desc, ACPI_READ_ADR_SPACE,
-				   (ACPI_PHYSICAL_ADDRESS) i, 8,
-				   (u32 *) ((u8 *) &table_header + i));
+	status = acpi_tb_find_table (operand[0]->string.pointer,
+			   operand[1]->string.pointer,
+			   operand[2]->string.pointer, &table);
+	if (ACPI_FAILURE (status)) {
+		if (status != AE_NOT_FOUND) {
+			return_ACPI_STATUS (status);
+		}
+
+		/* Not found, return an Integer=0 and AE_OK */
+
+		ddb_handle = acpi_ut_create_internal_object (ACPI_TYPE_INTEGER);
+		if (!ddb_handle) {
+			return_ACPI_STATUS (AE_NO_MEMORY);
+		}
+
+		ddb_handle->integer.value = 0;
+		*return_desc = ddb_handle;
+
+		return_ACPI_STATUS (AE_OK);
+	}
+
+	/* Default nodes */
+
+	start_node = walk_state->scope_info->scope.node;
+	parent_node = acpi_gbl_root_node;
+
+	/* root_path (optional parameter) */
+
+	if (operand[3]->string.length > 0) {
+		/*
+		 * Find the node referenced by the root_path_string. This is the
+		 * location within the namespace where the table will be loaded.
+		 */
+		status = acpi_ns_get_node_by_path (operand[3]->string.pointer, start_node,
+				   ACPI_NS_SEARCH_PARENT, &parent_node);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
 	}
 
-	/* Allocate a buffer for the entire table */
+	/* parameter_path (optional parameter) */
 
-	table_ptr = ACPI_MEM_ALLOCATE (table_header.length);
-	if (!table_ptr) {
-		return_ACPI_STATUS (AE_NO_MEMORY);
+	if (operand[4]->string.length > 0) {
+		if ((operand[4]->string.pointer[0] != '\\') &&
+			(operand[4]->string.pointer[0] != '^')) {
+			/*
+			 * Path is not absolute, so it will be relative to the node
+			 * referenced by the root_path_string (or the NS root if omitted)
+			 */
+			start_node = parent_node;
+		}
+
+		/*
+		 * Find the node referenced by the parameter_path_string
+		 */
+		status = acpi_ns_get_node_by_path (operand[4]->string.pointer, start_node,
+				   ACPI_NS_SEARCH_PARENT, &parameter_node);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
 	}
 
-	/* Copy the header to the buffer */
+	/* Load the table into the namespace */
 
-	MEMCPY (table_ptr, &table_header, sizeof (acpi_table_header));
-	table_data_ptr = table_ptr + sizeof (acpi_table_header);
+	status = acpi_ex_add_table (table, parent_node, &ddb_handle);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
+	/* Parameter Data (optional) */
 
-	/* Get the table from the op region */
+	if (parameter_node) {
+		/* Store the parameter data into the optional parameter object */
 
-	for (i = 0; i < table_header.length; i++) {
-		status = acpi_ev_address_space_dispatch (rgn_desc, ACPI_READ_ADR_SPACE,
-				   (ACPI_PHYSICAL_ADDRESS) i, 8,
-				   (u32 *) (table_data_ptr + i));
+		status = acpi_ex_store (operand[5], ACPI_CAST_PTR (union acpi_operand_object, parameter_node),
+				 walk_state);
 		if (ACPI_FAILURE (status)) {
-			goto cleanup;
+			(void) acpi_ex_unload_table (ddb_handle);
 		}
 	}
 
+	return_ACPI_STATUS  (status);
+}
 
-	/* Table must be either an SSDT or a PSDT */
 
-	if ((!STRNCMP (table_header.signature,
-			  acpi_gbl_acpi_table_data[ACPI_TABLE_PSDT].signature,
-			  acpi_gbl_acpi_table_data[ACPI_TABLE_PSDT].sig_length)) &&
-		(!STRNCMP (table_header.signature,
-				 acpi_gbl_acpi_table_data[ACPI_TABLE_SSDT].signature,
-				 acpi_gbl_acpi_table_data[ACPI_TABLE_SSDT].sig_length))) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Table has invalid signature [%4.4s], must be SSDT or PSDT\n",
-			(char*)table_header.signature));
-		status = AE_BAD_SIGNATURE;
-		goto cleanup;
-	}
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_load_op
+ *
+ * PARAMETERS:  obj_desc        - Region or Field where the table will be
+ *                                obtained
+ *              Target          - Where a handle to the table will be stored
+ *              walk_state      - Current state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Load an ACPI table from a field or operation region
+ *
+ ******************************************************************************/
 
-	/* Create an object to be the table handle */
+acpi_status
+acpi_ex_load_op (
+	union acpi_operand_object       *obj_desc,
+	union acpi_operand_object       *target,
+	struct acpi_walk_state          *walk_state)
+{
+	acpi_status                     status;
+	union acpi_operand_object       *ddb_handle;
+	union acpi_operand_object       *buffer_desc = NULL;
+	struct acpi_table_header        *table_ptr = NULL;
+	u8                              *table_data_ptr;
+	struct acpi_table_header        table_header;
+	u32                             i;
+
+	ACPI_FUNCTION_TRACE ("ex_load_op");
+
+
+	/* Object can be either an op_region or a Field */
+
+	switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
+	case ACPI_TYPE_REGION:
+
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Load from Region %p %s\n",
+			obj_desc, acpi_ut_get_object_type_name (obj_desc)));
+
+		/* Get the table header */
+
+		table_header.length = 0;
+		for (i = 0; i < sizeof (struct acpi_table_header); i++) {
+			status = acpi_ev_address_space_dispatch (obj_desc, ACPI_READ,
+					   (acpi_physical_address) i, 8,
+					   ((u8 *) &table_header) + i);
+			if (ACPI_FAILURE (status)) {
+				return_ACPI_STATUS (status);
+			}
+		}
 
-	table_desc = acpi_ut_create_internal_object (INTERNAL_TYPE_REFERENCE);
-	if (!table_desc) {
-		status = AE_NO_MEMORY;
-		goto cleanup;
-	}
+		/* Allocate a buffer for the entire table */
 
+		table_ptr = ACPI_MEM_ALLOCATE (table_header.length);
+		if (!table_ptr) {
+			return_ACPI_STATUS (AE_NO_MEMORY);
+		}
 
-	/* Install the new table into the local data structures */
+		/* Copy the header to the buffer */
 
-	table_info.pointer     = (acpi_table_header *) table_ptr;
-	table_info.length      = table_header.length;
-	table_info.allocation  = ACPI_MEM_ALLOCATED;
-	table_info.base_pointer = table_ptr;
+		ACPI_MEMCPY (table_ptr, &table_header, sizeof (struct acpi_table_header));
+		table_data_ptr = ACPI_PTR_ADD (u8, table_ptr, sizeof (struct acpi_table_header));
 
-	status = acpi_tb_install_table (NULL, &table_info);
-	if (ACPI_FAILURE (status)) {
-		goto cleanup;
-	}
+		/* Get the table from the op region */
 
-	/* Add the table to the namespace */
+		for (i = 0; i < table_header.length; i++) {
+			status = acpi_ev_address_space_dispatch (obj_desc, ACPI_READ,
+					   (acpi_physical_address) i, 8,
+					   ((u8 *) table_data_ptr + i));
+			if (ACPI_FAILURE (status)) {
+				goto cleanup;
+			}
+		}
+		break;
 
-	/* TBD: [Restructure] - change to whatever new interface is appropriate */
-/*
-	Status = Acpi_load_namespace ();
-	if (ACPI_FAILURE (Status))
-	{
-*/
-		/* TBD: [Errors] Unload the table on failure ? */
-/*
-		goto Cleanup;
+
+	case ACPI_TYPE_LOCAL_REGION_FIELD:
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
+	case ACPI_TYPE_LOCAL_INDEX_FIELD:
+
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Load from Field %p %s\n",
+			obj_desc, acpi_ut_get_object_type_name (obj_desc)));
+
+		/*
+		 * The length of the field must be at least as large as the table.
+		 * Read the entire field and thus the entire table.  Buffer is
+		 * allocated during the read.
+		 */
+		status = acpi_ex_read_data_from_field (walk_state, obj_desc, &buffer_desc);
+		if (ACPI_FAILURE (status)) {
+			goto cleanup;
+		}
+
+		table_ptr = ACPI_CAST_PTR (struct acpi_table_header, buffer_desc->buffer.pointer);
+		break;
+
+
+	default:
+		return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 	}
-*/
 
+	/* The table must be either an SSDT or a PSDT */
 
-	/* TBD: [Investigate] we need a pointer to the table desc */
+	if ((!ACPI_STRNCMP (table_ptr->signature,
+			  acpi_gbl_table_data[ACPI_TABLE_PSDT].signature,
+			  acpi_gbl_table_data[ACPI_TABLE_PSDT].sig_length)) &&
+		(!ACPI_STRNCMP (table_ptr->signature,
+				 acpi_gbl_table_data[ACPI_TABLE_SSDT].signature,
+				 acpi_gbl_table_data[ACPI_TABLE_SSDT].sig_length))) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Table has invalid signature [%4.4s], must be SSDT or PSDT\n",
+			table_ptr->signature));
+		status = AE_BAD_SIGNATURE;
+		goto cleanup;
+	}
 
-	/* Init the table handle */
+	/* Install the new table into the local data structures */
 
-	table_desc->reference.opcode = AML_LOAD_OP;
-	table_desc->reference.object = table_info.installed_desc;
+	status = acpi_ex_add_table (table_ptr, acpi_gbl_root_node, &ddb_handle);
+	if (ACPI_FAILURE (status)) {
+		goto cleanup;
+	}
 
-	/* TBD: store the tabledesc into the Ddb_handle target */
-	/* Ddb_handle = Table_desc; */
+	/* Store the ddb_handle into the Target operand */
+
+	status = acpi_ex_store (ddb_handle, target, walk_state);
+	if (ACPI_FAILURE (status)) {
+		(void) acpi_ex_unload_table (ddb_handle);
+	}
 
 	return_ACPI_STATUS (status);
 
 
 cleanup:
 
-	ACPI_MEM_FREE (table_desc);
-	ACPI_MEM_FREE (table_ptr);
+	if (buffer_desc) {
+		acpi_ut_remove_reference (buffer_desc);
+	}
+	else {
+		ACPI_MEM_FREE (table_ptr);
+	}
 	return_ACPI_STATUS (status);
 }
 
 
-/*****************************************************************************
+/*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_unload_table
+ * FUNCTION:    acpi_ex_unload_table
  *
- * PARAMETERS:  Ddb_handle          - Handle to a previously loaded table
+ * PARAMETERS:  ddb_handle          - Handle to a previously loaded table
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Unload an ACPI table
  *
- ****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
 acpi_ex_unload_table (
-	acpi_operand_object     *ddb_handle)
+	union acpi_operand_object       *ddb_handle)
 {
-	acpi_status             status = AE_NOT_IMPLEMENTED;
-	acpi_operand_object     *table_desc = ddb_handle;
-	acpi_table_desc         *table_info;
+	acpi_status                     status = AE_NOT_IMPLEMENTED;
+	union acpi_operand_object       *table_desc = ddb_handle;
+	struct acpi_table_desc          *table_info;
 
 
-	FUNCTION_TRACE ("Ex_unload_table");
+	ACPI_FUNCTION_TRACE ("ex_unload_table");
 
 
 	/*
 	 * Validate the handle
-	 * Although the handle is partially validated in Acpi_ex_reconfiguration(),
-	 * when it calls Acpi_ex_resolve_operands(), the handle is more completely
+	 * Although the handle is partially validated in acpi_ex_reconfiguration(),
+	 * when it calls acpi_ex_resolve_operands(), the handle is more completely
 	 * validated here.
 	 */
 	if ((!ddb_handle) ||
-		(!VALID_DESCRIPTOR_TYPE (ddb_handle, ACPI_DESC_TYPE_INTERNAL)) ||
-		(((acpi_operand_object  *)ddb_handle)->common.type !=
-				INTERNAL_TYPE_REFERENCE)) {
+		(ACPI_GET_DESCRIPTOR_TYPE (ddb_handle) != ACPI_DESC_TYPE_OPERAND) ||
+		(ACPI_GET_OBJECT_TYPE (ddb_handle) != ACPI_TYPE_LOCAL_REFERENCE)) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	/* Get the actual table descriptor from the Ddb_handle */
+	/* Get the actual table descriptor from the ddb_handle */
 
-	table_info = (acpi_table_desc *) table_desc->reference.object;
+	table_info = (struct acpi_table_desc *) table_desc->reference.object;
 
 	/*
 	 * Delete the entire namespace under this table Node
-	 * (Offset contains the Table_id)
+	 * (Offset contains the table_id)
 	 */
-	status = acpi_ns_delete_namespace_by_owner (table_info->table_id);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
+	acpi_ns_delete_namespace_by_owner (table_info->table_id);
 
 	/* Delete the table itself */
 
-	acpi_tb_uninstall_table (table_info->installed_desc);
+	(void) acpi_tb_uninstall_table (table_info->installed_desc);
 
-	/* Delete the table descriptor (Ddb_handle) */
+	/* Delete the table descriptor (ddb_handle) */
 
 	acpi_ut_remove_reference (table_desc);
-
 	return_ACPI_STATUS (status);
 }
 
diff -urNp linux-5400/drivers/acpi/executer/exconvrt.c linux-5410/drivers/acpi/executer/exconvrt.c
--- linux-5400/drivers/acpi/executer/exconvrt.c
+++ linux-5410/drivers/acpi/executer/exconvrt.c
@@ -1,49 +1,63 @@
 /******************************************************************************
  *
  * Module Name: exconvrt - Object conversion routines
- *              $Revision: 24 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
-#include "acnamesp.h"
-#include "acinterp.h"
-#include "acevents.h"
-#include "amlcode.h"
-#include "acdispat.h"
+#include <acpi/acpi.h>
+#include <acpi/acinterp.h>
+#include <acpi/amlcode.h>
 
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("exconvrt")
+	 ACPI_MODULE_NAME    ("exconvrt")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_convert_to_integer
+ * FUNCTION:    acpi_ex_convert_to_integer
  *
- * PARAMETERS:  *Obj_desc       - Object to be converted.  Must be an
+ * PARAMETERS:  *obj_desc       - Object to be converted.  Must be an
  *                                Integer, Buffer, or String
- *              Walk_state      - Current method state
+ *              walk_state      - Current method state
  *
  * RETURN:      Status
  *
@@ -53,60 +67,40 @@
 
 acpi_status
 acpi_ex_convert_to_integer (
-	acpi_operand_object     *obj_desc,
-	acpi_operand_object     **result_desc,
-	acpi_walk_state         *walk_state)
+	union acpi_operand_object       *obj_desc,
+	union acpi_operand_object       **result_desc,
+	struct acpi_walk_state          *walk_state)
 {
-	u32                     i;
-	acpi_operand_object     *ret_desc;
-	u32                     count;
-	char                    *pointer;
-	acpi_integer            result;
-	u32                     integer_size = sizeof (acpi_integer);
+	u32                             i;
+	union acpi_operand_object       *ret_desc;
+	u32                             count;
+	u8                              *pointer;
+	acpi_integer                    result;
+	acpi_status                     status;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_TRACE_PTR ("ex_convert_to_integer", obj_desc);
 
 
-	switch (obj_desc->common.type) {
+	switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
 	case ACPI_TYPE_INTEGER:
 		*result_desc = obj_desc;
-		return (AE_OK);
+		return_ACPI_STATUS (AE_OK);
 
 	case ACPI_TYPE_STRING:
-		pointer = obj_desc->string.pointer;
+		pointer = (u8 *) obj_desc->string.pointer;
 		count   = obj_desc->string.length;
 		break;
 
 	case ACPI_TYPE_BUFFER:
-		pointer = (char *) obj_desc->buffer.pointer;
+		pointer = obj_desc->buffer.pointer;
 		count   = obj_desc->buffer.length;
 		break;
 
 	default:
-		return (AE_TYPE);
-	}
-
-	/*
-	 * Create a new integer
-	 */
-	ret_desc = acpi_ut_create_internal_object (ACPI_TYPE_INTEGER);
-	if (!ret_desc) {
-		return (AE_NO_MEMORY);
-	}
-
-
-	/* Handle both ACPI 1.0 and ACPI 2.0 Integer widths */
-
-	if (walk_state->method_node->flags & ANOBJ_DATA_WIDTH_32) {
-		/*
-		 * We are running a method that exists in a 32-bit ACPI table.
-		 * Truncate the value to 32 bits by zeroing out the upper 32-bit field
-		 */
-		integer_size = sizeof (u32);
+		return_ACPI_STATUS (AE_TYPE);
 	}
 
-
 	/*
 	 * Convert the buffer/string to an integer.  Note that both buffers and
 	 * strings are treated as raw data - we don't convert ascii to hex for
@@ -120,23 +114,24 @@ acpi_ex_convert_to_integer (
 
 	/* Transfer no more than an integer's worth of data */
 
-	if (count > integer_size) {
-		count = integer_size;
+	if (count > acpi_gbl_integer_byte_width) {
+		count = acpi_gbl_integer_byte_width;
 	}
 
 	/*
 	 * String conversion is different than Buffer conversion
 	 */
-	switch (obj_desc->common.type) {
+	switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
 	case ACPI_TYPE_STRING:
 
-		/* TBD: Need to use 64-bit STRTOUL */
-
 		/*
 		 * Convert string to an integer
 		 * String must be hexadecimal as per the ACPI specification
 		 */
-		result = STRTOUL (pointer, NULL, 16);
+		status = acpi_ut_strtoul64 ((char *) pointer, 16, &result);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
 		break;
 
 
@@ -154,14 +149,31 @@ acpi_ex_convert_to_integer (
 			 */
 			result |= (((acpi_integer) pointer[i]) << (i * 8));
 		}
+		break;
 
+
+	default:
+		/* No other types can get here */
 		break;
 	}
 
-	/* Save the Result, delete original descriptor, store new descriptor */
+	/*
+	 * Create a new integer
+	 */
+	ret_desc = acpi_ut_create_internal_object (ACPI_TYPE_INTEGER);
+	if (!ret_desc) {
+		return_ACPI_STATUS (AE_NO_MEMORY);
+	}
+
+	/* Save the Result */
 
 	ret_desc->integer.value = result;
 
+	/*
+	 * If we are about to overwrite the original object on the operand stack,
+	 * we must remove a reference on the original object because we are
+	 * essentially removing it from the stack.
+	 */
 	if (*result_desc == obj_desc) {
 		if (walk_state->opcode != AML_STORE_OP) {
 			acpi_ut_remove_reference (obj_desc);
@@ -169,139 +181,152 @@ acpi_ex_convert_to_integer (
 	}
 
 	*result_desc = ret_desc;
-	return (AE_OK);
+	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_convert_to_buffer
+ * FUNCTION:    acpi_ex_convert_to_buffer
  *
- * PARAMETERS:  *Obj_desc       - Object to be converted.  Must be an
+ * PARAMETERS:  *obj_desc       - Object to be converted.  Must be an
  *                                Integer, Buffer, or String
- *              Walk_state      - Current method state
+ *              walk_state      - Current method state
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Convert an ACPI Object to an Buffer
+ * DESCRIPTION: Convert an ACPI Object to a Buffer
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ex_convert_to_buffer (
-	acpi_operand_object     *obj_desc,
-	acpi_operand_object     **result_desc,
-	acpi_walk_state         *walk_state)
+	union acpi_operand_object       *obj_desc,
+	union acpi_operand_object       **result_desc,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_operand_object     *ret_desc;
-	u32                     i;
-	u32                     integer_size = sizeof (acpi_integer);
-	u8                      *new_buf;
+	union acpi_operand_object       *ret_desc;
+	u32                             i;
+	u8                              *new_buf;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_TRACE_PTR ("ex_convert_to_buffer", obj_desc);
 
 
-	switch (obj_desc->common.type) {
-	case ACPI_TYPE_INTEGER:
+	switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
+	case ACPI_TYPE_BUFFER:
 
-		/*
-		 * Create a new Buffer
-		 */
-		ret_desc = acpi_ut_create_internal_object (ACPI_TYPE_BUFFER);
-		if (!ret_desc) {
-			return (AE_NO_MEMORY);
-		}
+		/* No conversion necessary */
 
-		/* Handle both ACPI 1.0 and ACPI 2.0 Integer widths */
+		*result_desc = obj_desc;
+		return_ACPI_STATUS (AE_OK);
 
-		if (walk_state->method_node->flags & ANOBJ_DATA_WIDTH_32) {
-			/*
-			 * We are running a method that exists in a 32-bit ACPI table.
-			 * Truncate the value to 32 bits by zeroing out the upper
-			 * 32-bit field
-			 */
-			integer_size = sizeof (u32);
-		}
 
-		/* Need enough space for one integers */
+	case ACPI_TYPE_INTEGER:
 
-		ret_desc->buffer.length = integer_size;
-		new_buf = ACPI_MEM_CALLOCATE (integer_size);
-		if (!new_buf) {
-			REPORT_ERROR
-				(("Ex_convert_to_buffer: Buffer allocation failure\n"));
-			acpi_ut_remove_reference (ret_desc);
-			return (AE_NO_MEMORY);
+		/*
+		 * Create a new Buffer object.
+		 * Need enough space for one integer
+		 */
+		ret_desc = acpi_ut_create_buffer_object (acpi_gbl_integer_byte_width);
+		if (!ret_desc) {
+			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
 
 		/* Copy the integer to the buffer */
 
-		for (i = 0; i < integer_size; i++) {
+		new_buf = ret_desc->buffer.pointer;
+		for (i = 0; i < acpi_gbl_integer_byte_width; i++) {
 			new_buf[i] = (u8) (obj_desc->integer.value >> (i * 8));
 		}
-		ret_desc->buffer.pointer = new_buf;
-
-		/* Return the new buffer descriptor */
-
-		if (*result_desc == obj_desc) {
-			if (walk_state->opcode != AML_STORE_OP) {
-				acpi_ut_remove_reference (obj_desc);
-			}
-		}
-
-		*result_desc = ret_desc;
 		break;
 
 
 	case ACPI_TYPE_STRING:
-		*result_desc = obj_desc;
-		break;
 
+		/*
+		 * Create a new Buffer object
+		 * Size will be the string length
+		 */
+		ret_desc = acpi_ut_create_buffer_object ((acpi_size) obj_desc->string.length);
+		if (!ret_desc) {
+			return_ACPI_STATUS (AE_NO_MEMORY);
+		}
 
-	case ACPI_TYPE_BUFFER:
-		*result_desc = obj_desc;
+		/* Copy the string to the buffer */
+
+		new_buf = ret_desc->buffer.pointer;
+		ACPI_STRNCPY ((char *) new_buf, (char *) obj_desc->string.pointer,
+			obj_desc->string.length);
 		break;
 
 
 	default:
-		return (AE_TYPE);
-		break;
-   }
+		return_ACPI_STATUS (AE_TYPE);
+	}
+
+	/* Mark buffer initialized */
+
+	ret_desc->common.flags |= AOPOBJ_DATA_VALID;
+
+	/*
+	 * If we are about to overwrite the original object on the operand stack,
+	 * we must remove a reference on the original object because we are
+	 * essentially removing it from the stack.
+	 */
+	if (*result_desc == obj_desc) {
+		if (walk_state->opcode != AML_STORE_OP) {
+			acpi_ut_remove_reference (obj_desc);
+		}
+	}
 
-	return (AE_OK);
+	*result_desc = ret_desc;
+	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_convert_ascii
+ * FUNCTION:    acpi_ex_convert_ascii
  *
- * PARAMETERS:  Integer
+ * PARAMETERS:  Integer         - Value to be converted
+ *              Base            - 10 or 16
+ *              String          - Where the string is returned
+ *              data_width      - Size of data item to be converted
  *
  * RETURN:      Actual string length
  *
- * DESCRIPTION: Convert an ACPI Integer to a hex string
+ * DESCRIPTION: Convert an ACPI Integer to a hex or decimal string
  *
  ******************************************************************************/
 
 u32
 acpi_ex_convert_to_ascii (
-	acpi_integer            integer,
-	u32                     base,
-	u8                      *string)
+	acpi_integer                    integer,
+	u32                             base,
+	u8                              *string,
+	u8                              data_width)
 {
-	u32                     i;
-	u32                     j;
-	u32                     k = 0;
-	u8                      hex_digit;
-	acpi_integer            digit;
-	u32                     remainder;
-	u32                     length = sizeof (acpi_integer);
-	u8                      leading_zero = TRUE;
+	u32                             i;
+	u32                             j;
+	u32                             k = 0;
+	char                            hex_digit;
+	acpi_integer                    digit;
+	u32                             remainder;
+	u32                             length;
+	u8                              leading_zero;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
+
+	if (data_width < sizeof (acpi_integer)) {
+		leading_zero = FALSE;
+		length = data_width;
+	}
+	else {
+		leading_zero = TRUE;
+		length = sizeof (acpi_integer);
+	}
 
 
 	switch (base) {
@@ -313,7 +338,7 @@ acpi_ex_convert_to_ascii (
 
 			digit = integer;
 			for (j = 1; j < i; j++) {
-				acpi_ut_short_divide (&digit, 10, &digit, &remainder);
+				(void) acpi_ut_short_divide (&digit, 10, &digit, &remainder);
 			}
 
 			/* Create the decimal digit */
@@ -323,7 +348,7 @@ acpi_ex_convert_to_ascii (
 			}
 
 			if (!leading_zero) {
-				string[k] = (u8) (ASCII_ZERO + remainder);
+				string[k] = (u8) (ACPI_ASCII_ZERO + remainder);
 				k++;
 			}
 		}
@@ -336,12 +361,12 @@ acpi_ex_convert_to_ascii (
 		for (i = 0, j = ((length * 2) -1); i < (length * 2); i++, j--) {
 
 			hex_digit = acpi_ut_hex_to_ascii_char (integer, (j * 4));
-			if (hex_digit != ASCII_ZERO) {
+			if (hex_digit != ACPI_ASCII_ZERO) {
 				leading_zero = FALSE;
 			}
 
 			if (!leading_zero) {
-				string[k] = hex_digit;
+				string[k] = (u8) hex_digit;
 				k++;
 			}
 		}
@@ -358,22 +383,22 @@ acpi_ex_convert_to_ascii (
 	 * Finally, null terminate the string and return the length
 	 */
 	if (!k) {
-		string [0] = ASCII_ZERO;
+		string [0] = ACPI_ASCII_ZERO;
 		k = 1;
 	}
-	string [k] = 0;
 
+	string [k] = 0;
 	return (k);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_convert_to_string
+ * FUNCTION:    acpi_ex_convert_to_string
  *
- * PARAMETERS:  *Obj_desc       - Object to be converted.  Must be an
+ * PARAMETERS:  *obj_desc       - Object to be converted.  Must be an
  *                                Integer, Buffer, or String
- *              Walk_state      - Current method state
+ *              walk_state      - Current method state
  *
  * RETURN:      Status
  *
@@ -383,39 +408,39 @@ acpi_ex_convert_to_ascii (
 
 acpi_status
 acpi_ex_convert_to_string (
-	acpi_operand_object     *obj_desc,
-	acpi_operand_object     **result_desc,
-	u32                     base,
-	u32                     max_length,
-	acpi_walk_state         *walk_state)
+	union acpi_operand_object       *obj_desc,
+	union acpi_operand_object       **result_desc,
+	u32                             base,
+	u32                             max_length,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_operand_object     *ret_desc;
-	u32                     i;
-	u32                     index;
-	u32                     string_length;
-	u32                     integer_size = sizeof (acpi_integer);
-	u8                      *new_buf;
-	u8                      *pointer;
+	union acpi_operand_object       *ret_desc;
+	u32                             i;
+	u32                             string_length;
+	u8                              *new_buf;
+	u8                              *pointer;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_TRACE_PTR ("ex_convert_to_string", obj_desc);
 
 
-	switch (obj_desc->common.type) {
-	case ACPI_TYPE_INTEGER:
+	switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
+	case ACPI_TYPE_STRING:
 
-		/* Handle both ACPI 1.0 and ACPI 2.0 Integer widths */
+		if (max_length >= obj_desc->string.length) {
+			*result_desc = obj_desc;
+			return_ACPI_STATUS (AE_OK);
+		}
+		else {
+			/* Must copy the string first and then truncate it */
 
-		if (walk_state->method_node->flags & ANOBJ_DATA_WIDTH_32) {
-			/*
-			 * We are running a method that exists in a 32-bit ACPI table.
-			 * Truncate the value to 32 bits by zeroing out the upper
-			 * 32-bit field
-			 */
-			integer_size = sizeof (u32);
+			return_ACPI_STATUS (AE_NOT_IMPLEMENTED);
 		}
 
-		string_length = integer_size * 2;
+
+	case ACPI_TYPE_INTEGER:
+
+		string_length = acpi_gbl_integer_byte_width * 2;
 		if (base == 10) {
 			string_length = ACPI_MAX_DECIMAL_DIGITS;
 		}
@@ -425,23 +450,22 @@ acpi_ex_convert_to_string (
 		 */
 		ret_desc = acpi_ut_create_internal_object (ACPI_TYPE_STRING);
 		if (!ret_desc) {
-			return (AE_NO_MEMORY);
+			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
 
 		/* Need enough space for one ASCII integer plus null terminator */
 
-		new_buf = ACPI_MEM_CALLOCATE (string_length + 1);
+		new_buf = ACPI_MEM_CALLOCATE ((acpi_size) string_length + 1);
 		if (!new_buf) {
-			REPORT_ERROR
-				(("Ex_convert_to_string: Buffer allocation failure\n"));
+			ACPI_REPORT_ERROR
+				(("ex_convert_to_string: Buffer allocation failure\n"));
 			acpi_ut_remove_reference (ret_desc);
-			return (AE_NO_MEMORY);
+			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
 
-
 		/* Convert */
 
-		i = acpi_ex_convert_to_ascii (obj_desc->integer.value, base, new_buf);
+		i = acpi_ex_convert_to_ascii (obj_desc->integer.value, base, new_buf, sizeof (acpi_integer));
 
 		/* Null terminate at the correct place */
 
@@ -455,29 +479,25 @@ acpi_ex_convert_to_string (
 		}
 
 		ret_desc->buffer.pointer = new_buf;
-
-		/* Return the new buffer descriptor */
-
-		if (*result_desc == obj_desc) {
-			if (walk_state->opcode != AML_STORE_OP) {
-				acpi_ut_remove_reference (obj_desc);
-			}
-		}
-
-		*result_desc = ret_desc;
 		break;
 
 
 	case ACPI_TYPE_BUFFER:
 
-		string_length = obj_desc->buffer.length * 3;
-		if (base == 10) {
-			string_length = obj_desc->buffer.length * 4;
+		/* Find the string length */
+
+		pointer = obj_desc->buffer.pointer;
+		for (string_length = 0; string_length < obj_desc->buffer.length; string_length++) {
+			/* Exit on null terminator */
+
+			if (!pointer[string_length]) {
+				break;
+			}
 		}
 
 		if (max_length > ACPI_MAX_STRING_CONVERSION) {
 			if (string_length > ACPI_MAX_STRING_CONVERSION) {
-				return (AE_AML_STRING_LIMIT);
+				return_ACPI_STATUS (AE_AML_STRING_LIMIT);
 			}
 		}
 
@@ -486,7 +506,7 @@ acpi_ex_convert_to_string (
 		 */
 		ret_desc = acpi_ut_create_internal_object (ACPI_TYPE_STRING);
 		if (!ret_desc) {
-			return (AE_NO_MEMORY);
+			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
 
 		/* String length is the lesser of the Max or the actual length */
@@ -495,92 +515,77 @@ acpi_ex_convert_to_string (
 			string_length = max_length;
 		}
 
-		new_buf = ACPI_MEM_CALLOCATE (string_length + 1);
+		new_buf = ACPI_MEM_CALLOCATE ((acpi_size) string_length + 1);
 		if (!new_buf) {
-			REPORT_ERROR
-				(("Ex_convert_to_string: Buffer allocation failure\n"));
+			ACPI_REPORT_ERROR
+				(("ex_convert_to_string: Buffer allocation failure\n"));
 			acpi_ut_remove_reference (ret_desc);
-			return (AE_NO_MEMORY);
+			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
 
-		/*
-		 * Convert each byte of the buffer to two ASCII characters plus a space.
-		 */
-		pointer = obj_desc->buffer.pointer;
-		index = 0;
-		for (i = 0, index = 0; i < obj_desc->buffer.length; i++) {
-			index = acpi_ex_convert_to_ascii (pointer[i], base, &new_buf[index]);
+		/* Copy the appropriate number of buffer characters */
 
-			new_buf[index] = ' ';
-			index++;
-		}
+		ACPI_MEMCPY (new_buf, pointer, string_length);
 
 		/* Null terminate */
 
-		new_buf [index-1] = 0;
+		new_buf [string_length] = 0;
 		ret_desc->buffer.pointer = new_buf;
-		ret_desc->string.length = STRLEN ((char *) new_buf);
-
-
-		/* Return the new buffer descriptor */
-
-		if (*result_desc == obj_desc) {
-			if (walk_state->opcode != AML_STORE_OP) {
-				acpi_ut_remove_reference (obj_desc);
-			}
-		}
-
-		*result_desc = ret_desc;
+		ret_desc->string.length = string_length;
 		break;
 
 
-	case ACPI_TYPE_STRING:
-
-		if (max_length >= obj_desc->string.length) {
-			*result_desc = obj_desc;
-		}
+	default:
+		return_ACPI_STATUS (AE_TYPE);
+	}
 
-		else {
-			/* Must copy the string first and then truncate it */
 
-			return (AE_NOT_IMPLEMENTED);
+	/*
+	 * If we are about to overwrite the original object on the operand stack,
+	 * we must remove a reference on the original object because we are
+	 * essentially removing it from the stack.
+	 */
+	if (*result_desc == obj_desc) {
+		if (walk_state->opcode != AML_STORE_OP) {
+			acpi_ut_remove_reference (obj_desc);
 		}
-		break;
-
-
-	default:
-		return (AE_TYPE);
-		break;
-   }
+	}
 
-	return (AE_OK);
+	*result_desc = ret_desc;
+	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_convert_to_target_type
+ * FUNCTION:    acpi_ex_convert_to_target_type
  *
- * PARAMETERS:  *Obj_desc       - Object to be converted.
- *              Walk_state      - Current method state
+ * PARAMETERS:  destination_type    - Current type of the destination
+ *              source_desc         - Source object to be converted.
+ *              walk_state          - Current method state
  *
  * RETURN:      Status
  *
- * DESCRIPTION:
+ * DESCRIPTION: Implements "implicit conversion" rules for storing an object.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ex_convert_to_target_type (
-	acpi_object_type8       destination_type,
-	acpi_operand_object     **obj_desc,
-	acpi_walk_state         *walk_state)
+	acpi_object_type                destination_type,
+	union acpi_operand_object       *source_desc,
+	union acpi_operand_object       **result_desc,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status = AE_OK;
+	acpi_status                     status = AE_OK;
+
 
+	ACPI_FUNCTION_TRACE ("ex_convert_to_target_type");
 
-	FUNCTION_TRACE ("Ex_convert_to_target_type");
 
+	/* Default behavior */
+
+	*result_desc = source_desc;
 
 	/*
 	 * If required by the target,
@@ -592,7 +597,7 @@ acpi_ex_convert_to_target_type (
 	case ARGI_INTEGER_REF:      /* Handles Increment, Decrement cases */
 
 		switch (destination_type) {
-		case INTERNAL_TYPE_REGION_FIELD:
+		case ACPI_TYPE_LOCAL_REGION_FIELD:
 			/*
 			 * Named field can always handle conversions
 			 */
@@ -601,10 +606,10 @@ acpi_ex_convert_to_target_type (
 		default:
 			/* No conversion allowed for these types */
 
-			if (destination_type != (*obj_desc)->common.type) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-					"Target does not allow conversion of type %s to %s\n",
-					acpi_ut_get_type_name ((*obj_desc)->common.type),
+			if (destination_type != ACPI_GET_OBJECT_TYPE (source_desc)) {
+				ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+					"Explicit operator, will store (%s) over existing type (%s)\n",
+					acpi_ut_get_object_type_name (source_desc),
 					acpi_ut_get_type_name (destination_type)));
 				status = AE_TYPE;
 			}
@@ -617,13 +622,13 @@ acpi_ex_convert_to_target_type (
 		switch (destination_type) {
 		case ACPI_TYPE_INTEGER:
 		case ACPI_TYPE_BUFFER_FIELD:
-		case INTERNAL_TYPE_BANK_FIELD:
-		case INTERNAL_TYPE_INDEX_FIELD:
+		case ACPI_TYPE_LOCAL_BANK_FIELD:
+		case ACPI_TYPE_LOCAL_INDEX_FIELD:
 			/*
 			 * These types require an Integer operand.  We can convert
 			 * a Buffer or a String to an Integer if necessary.
 			 */
-			status = acpi_ex_convert_to_integer (*obj_desc, obj_desc, walk_state);
+			status = acpi_ex_convert_to_integer (source_desc, result_desc, walk_state);
 			break;
 
 
@@ -633,17 +638,22 @@ acpi_ex_convert_to_target_type (
 			 * The operand must be a String.  We can convert an
 			 * Integer or Buffer if necessary
 			 */
-			status = acpi_ex_convert_to_string (*obj_desc, obj_desc, 16, ACPI_UINT32_MAX, walk_state);
+			status = acpi_ex_convert_to_string (source_desc, result_desc, 16, ACPI_UINT32_MAX, walk_state);
 			break;
 
 
 		case ACPI_TYPE_BUFFER:
 
 			/*
-			 * The operand must be a String.  We can convert an
-			 * Integer or Buffer if necessary
+			 * The operand must be a Buffer.  We can convert an
+			 * Integer or String if necessary
 			 */
-			status = acpi_ex_convert_to_buffer (*obj_desc, obj_desc, walk_state);
+			status = acpi_ex_convert_to_buffer (source_desc, result_desc, walk_state);
+			break;
+
+
+		default:
+			status = AE_AML_INTERNAL;
 			break;
 		}
 		break;
@@ -651,21 +661,20 @@ acpi_ex_convert_to_target_type (
 
 	case ARGI_REFERENCE:
 		/*
-		 * Create_xxxx_field cases - we are storing the field object into the name
+		 * create_xxxx_field cases - we are storing the field object into the name
 		 */
 		break;
 
 
 	default:
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Unknown Target type ID 0x%X Op %s Dest_type %s\n",
+			"Unknown Target type ID 0x%X Op %s dest_type %s\n",
 			GET_CURRENT_ARG_TYPE (walk_state->op_info->runtime_args),
 			walk_state->op_info->name, acpi_ut_get_type_name (destination_type)));
 
 		status = AE_AML_INTERNAL;
 	}
 
-
 	/*
 	 * Source-to-Target conversion semantics:
 	 *
diff -urNp linux-5400/drivers/acpi/executer/excreate.c linux-5410/drivers/acpi/executer/excreate.c
--- linux-5400/drivers/acpi/executer/excreate.c
+++ linux-5410/drivers/acpi/executer/excreate.c
@@ -1,48 +1,65 @@
 /******************************************************************************
  *
  * Module Name: excreate - Named object creation
- *              $Revision: 71 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
-#include "acinterp.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "acevents.h"
-#include "acdispat.h"
+#include <acpi/acpi.h>
+#include <acpi/acinterp.h>
+#include <acpi/amlcode.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acevents.h>
+#include <acpi/actables.h>
 
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("excreate")
+	 ACPI_MODULE_NAME    ("excreate")
 
 
+#ifndef ACPI_NO_METHOD_EXECUTION
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ex_create_alias
+ * FUNCTION:    acpi_ex_create_alias
  *
- * PARAMETERS:  Walk_state           - Current state, contains List of
- *                                      operands for the opcode
+ * PARAMETERS:  walk_state           - Current state, contains operands
  *
  * RETURN:      Status
  *
@@ -52,32 +69,69 @@
 
 acpi_status
 acpi_ex_create_alias (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_namespace_node     *source_node;
-	acpi_status             status;
+	struct acpi_namespace_node      *target_node;
+	struct acpi_namespace_node      *alias_node;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE ("Ex_create_alias");
+	ACPI_FUNCTION_TRACE ("ex_create_alias");
 
 
 	/* Get the source/alias operands (both namespace nodes) */
 
-	source_node = (acpi_namespace_node *) walk_state->operands[1];
+	alias_node = (struct acpi_namespace_node *) walk_state->operands[0];
+	target_node = (struct acpi_namespace_node *) walk_state->operands[1];
 
-
-	/* Attach the original source object to the new Alias Node */
-
-	status = acpi_ns_attach_object ((acpi_namespace_node *) walk_state->operands[0],
-			   source_node->object,
-			   source_node->type);
+	if (target_node->type == ACPI_TYPE_LOCAL_ALIAS) {
+		/*
+		 * Dereference an existing alias so that we don't create a chain
+		 * of aliases.  With this code, we guarantee that an alias is
+		 * always exactly one level of indirection away from the
+		 * actual aliased name.
+		 */
+		target_node = (struct acpi_namespace_node *) target_node->object;
+	}
 
 	/*
-	 * The new alias assumes the type of the source, but it points
-	 * to the same object.  The reference count of the object has an
-	 * additional reference to prevent deletion out from under either the
-	 * source or the alias Node
+	 * For objects that can never change (i.e., the NS node will
+	 * permanently point to the same object), we can simply attach
+	 * the object to the new NS node.  For other objects (such as
+	 * Integers, buffers, etc.), we have to point the Alias node
+	 * to the original Node.
 	 */
+	switch (target_node->type) {
+	case ACPI_TYPE_INTEGER:
+	case ACPI_TYPE_STRING:
+	case ACPI_TYPE_BUFFER:
+	case ACPI_TYPE_PACKAGE:
+	case ACPI_TYPE_BUFFER_FIELD:
+
+		/*
+		 * The new alias has the type ALIAS and points to the original
+		 * NS node, not the object itself.  This is because for these
+		 * types, the object can change dynamically via a Store.
+		 */
+		alias_node->type = ACPI_TYPE_LOCAL_ALIAS;
+		alias_node->object = ACPI_CAST_PTR (union acpi_operand_object, target_node);
+		break;
+
+	default:
+
+		/* Attach the original source object to the new Alias Node */
+
+		/*
+		 * The new alias assumes the type of the target, and it points
+		 * to the same object.  The reference count of the object has an
+		 * additional reference to prevent deletion out from under either the
+		 * target node or the alias Node
+		 */
+		status = acpi_ns_attach_object (alias_node,
+				 acpi_ns_get_attached_object (target_node),
+				 target_node->type);
+		break;
+	}
 
 	/* Since both operands are Nodes, we don't need to delete them */
 
@@ -87,9 +141,9 @@ acpi_ex_create_alias (
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ex_create_event
+ * FUNCTION:    acpi_ex_create_event
  *
- * PARAMETERS:  Walk_state          - Current state
+ * PARAMETERS:  walk_state          - Current state
  *
  * RETURN:      Status
  *
@@ -99,13 +153,13 @@ acpi_ex_create_alias (
 
 acpi_status
 acpi_ex_create_event (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status;
-	acpi_operand_object     *obj_desc;
+	acpi_status                     status;
+	union acpi_operand_object       *obj_desc;
 
 
-	FUNCTION_TRACE ("Ex_create_event");
+	ACPI_FUNCTION_TRACE ("ex_create_event");
 
 
 	obj_desc = acpi_ut_create_internal_object (ACPI_TYPE_EVENT);
@@ -114,11 +168,11 @@ acpi_ex_create_event (
 		goto cleanup;
 	}
 
-	/* Create the actual OS semaphore */
-
-	/* TBD: [Investigate] should be created with 0 or 1 units? */
-
-	status = acpi_os_create_semaphore (ACPI_NO_UNIT_LIMIT, 1,
+	/*
+	 * Create the actual OS semaphore, with zero initial units -- meaning
+	 * that the event is created in an unsignalled state
+	 */
+	status = acpi_os_create_semaphore (ACPI_NO_UNIT_LIMIT, 0,
 			   &obj_desc->event.semaphore);
 	if (ACPI_FAILURE (status)) {
 		goto cleanup;
@@ -126,8 +180,8 @@ acpi_ex_create_event (
 
 	/* Attach object to the Node */
 
-	status = acpi_ns_attach_object ((acpi_namespace_node *) walk_state->operands[0],
-			   obj_desc, (u8) ACPI_TYPE_EVENT);
+	status = acpi_ns_attach_object ((struct acpi_namespace_node *) walk_state->operands[0],
+			   obj_desc, ACPI_TYPE_EVENT);
 
 cleanup:
 	/*
@@ -141,27 +195,27 @@ cleanup:
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ex_create_mutex
+ * FUNCTION:    acpi_ex_create_mutex
  *
- * PARAMETERS:  Walk_state          - Current state
+ * PARAMETERS:  walk_state          - Current state
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Create a new mutex object
  *
- *              Mutex (Name[0], Sync_level[1])
+ *              Mutex (Name[0], sync_level[1])
  *
  ****************************************************************************/
 
 acpi_status
 acpi_ex_create_mutex (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status = AE_OK;
-	acpi_operand_object     *obj_desc;
+	acpi_status                     status = AE_OK;
+	union acpi_operand_object       *obj_desc;
 
 
-	FUNCTION_TRACE_PTR ("Ex_create_mutex", WALK_OPERANDS);
+	ACPI_FUNCTION_TRACE_PTR ("ex_create_mutex", ACPI_WALK_OPERANDS);
 
 
 	/* Create the new mutex object */
@@ -172,8 +226,11 @@ acpi_ex_create_mutex (
 		goto cleanup;
 	}
 
-	/* Create the actual OS semaphore */
-
+	/*
+	 * Create the actual OS semaphore.
+	 * One unit max to make it a mutex, with one initial unit to allow
+	 * the mutex to be acquired.
+	 */
 	status = acpi_os_create_semaphore (1, 1, &obj_desc->mutex.semaphore);
 	if (ACPI_FAILURE (status)) {
 		goto cleanup;
@@ -182,9 +239,10 @@ acpi_ex_create_mutex (
 	/* Init object and attach to NS node */
 
 	obj_desc->mutex.sync_level = (u8) walk_state->operands[1]->integer.value;
+	obj_desc->mutex.node = (struct acpi_namespace_node *) walk_state->operands[0];
 
-	status = acpi_ns_attach_object ((acpi_namespace_node *) walk_state->operands[0],
-			  obj_desc, (u8) ACPI_TYPE_MUTEX);
+	status = acpi_ns_attach_object (obj_desc->mutex.node,
+			 obj_desc, ACPI_TYPE_MUTEX);
 
 
 cleanup:
@@ -199,12 +257,12 @@ cleanup:
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ex_create_region
+ * FUNCTION:    acpi_ex_create_region
  *
- * PARAMETERS:  Aml_start           - Pointer to the region declaration AML
- *              Aml_length          - Max length of the declaration AML
+ * PARAMETERS:  aml_start           - Pointer to the region declaration AML
+ *              aml_length          - Max length of the declaration AML
  *              Operands            - List of operands for the opcode
- *              Walk_state          - Current state
+ *              walk_state          - Current state
  *
  * RETURN:      Status
  *
@@ -214,28 +272,29 @@ cleanup:
 
 acpi_status
 acpi_ex_create_region (
-	u8                      *aml_start,
-	u32                     aml_length,
-	u8                      region_space,
-	acpi_walk_state         *walk_state)
+	u8                              *aml_start,
+	u32                             aml_length,
+	u8                              region_space,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status;
-	acpi_operand_object     *obj_desc;
-	acpi_namespace_node     *node;
+	acpi_status                     status;
+	union acpi_operand_object       *obj_desc;
+	struct acpi_namespace_node      *node;
+	union acpi_operand_object       *region_obj2;
 
 
-	FUNCTION_TRACE ("Ex_create_region");
+	ACPI_FUNCTION_TRACE ("ex_create_region");
 
 
 	/* Get the Node from the object stack  */
 
-	node = (acpi_namespace_node *) walk_state->operands[0];
+	node = walk_state->op->common.node;
 
 	/*
 	 * If the region object is already attached to this node,
 	 * just return
 	 */
-	if (node->object) {
+	if (acpi_ns_get_attached_object (node)) {
 		return_ACPI_STATUS (AE_OK);
 	}
 
@@ -243,9 +302,9 @@ acpi_ex_create_region (
 	 * Space ID must be one of the predefined IDs, or in the user-defined
 	 * range
 	 */
-	if ((region_space >= NUM_REGION_TYPES) &&
-		(region_space < USER_REGION_BEGIN)) {
-		REPORT_ERROR (("Invalid Address_space type %X\n", region_space));
+	if ((region_space >= ACPI_NUM_PREDEFINED_REGIONS) &&
+		(region_space < ACPI_USER_REGION_BEGIN)) {
+		ACPI_REPORT_ERROR (("Invalid address_space type %X\n", region_space));
 		return_ACPI_STATUS (AE_AML_INVALID_SPACE_ID);
 	}
 
@@ -261,21 +320,13 @@ acpi_ex_create_region (
 		goto cleanup;
 	}
 
-	/* Allocate a method object for this region */
-
-	obj_desc->region.extra = acpi_ut_create_internal_object (
-			 INTERNAL_TYPE_EXTRA);
-	if (!obj_desc->region.extra) {
-		status = AE_NO_MEMORY;
-		goto cleanup;
-	}
-
 	/*
 	 * Remember location in AML stream of address & length
 	 * operands since they need to be evaluated at run time.
 	 */
-	obj_desc->region.extra->extra.aml_start = aml_start;
-	obj_desc->region.extra->extra.aml_length = aml_length;
+	region_obj2                 = obj_desc->common.next_object;
+	region_obj2->extra.aml_start = aml_start;
+	region_obj2->extra.aml_length = aml_length;
 
 	/* Init the region from the operands */
 
@@ -286,102 +337,137 @@ acpi_ex_create_region (
 
 	/* Install the new region object in the parent Node */
 
-	status = acpi_ns_attach_object (node, obj_desc,
-			  (u8) ACPI_TYPE_REGION);
-	if (ACPI_FAILURE (status)) {
-		goto cleanup;
-	}
+	status = acpi_ns_attach_object (node, obj_desc, ACPI_TYPE_REGION);
 
-	/*
-	 * If we have a valid region, initialize it
-	 * Namespace is NOT locked at this point.
-	 */
-	status = acpi_ev_initialize_region (obj_desc, FALSE);
-	if (ACPI_FAILURE (status)) {
-		/*
-		 *  If AE_NOT_EXIST is returned, it is not fatal
-		 *  because many regions get created before a handler
-		 *  is installed for said region.
-		 */
-		if (AE_NOT_EXIST == status) {
-			status = AE_OK;
-		}
-	}
 
 cleanup:
 
 	/* Remove local reference to the object */
 
 	acpi_ut_remove_reference (obj_desc);
-
 	return_ACPI_STATUS (status);
 }
 
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ex_create_table_region
+ * FUNCTION:    acpi_ex_create_table_region
  *
- * PARAMETERS:  Walk_state          - Current state
+ * PARAMETERS:  walk_state          - Current state
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Create a new Data_table_region object
+ * DESCRIPTION: Create a new data_table_region object
  *
  ****************************************************************************/
 
 acpi_status
 acpi_ex_create_table_region (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status = AE_OK;
+	acpi_status                     status;
+	union acpi_operand_object       **operand = &walk_state->operands[0];
+	union acpi_operand_object       *obj_desc;
+	struct acpi_namespace_node      *node;
+	struct acpi_table_header        *table;
+	union acpi_operand_object       *region_obj2;
 
 
-	FUNCTION_TRACE ("Ex_create_table_region");
+	ACPI_FUNCTION_TRACE ("ex_create_table_region");
 
-/*
-	acpi_operand_object     *Obj_desc;
-	Obj_desc = Acpi_ut_create_internal_object (ACPI_TYPE_REGION);
-	if (!Obj_desc)
-	{
-		Status = AE_NO_MEMORY;
-		goto Cleanup;
+	/* Get the Node from the object stack  */
+
+	node = walk_state->op->common.node;
+
+	/*
+	 * If the region object is already attached to this node,
+	 * just return
+	 */
+	if (acpi_ns_get_attached_object (node)) {
+		return_ACPI_STATUS (AE_OK);
 	}
 
+	/* Find the ACPI table */
 
-Cleanup:
-*/
+	status = acpi_tb_find_table (operand[1]->string.pointer,
+			   operand[2]->string.pointer,
+			   operand[3]->string.pointer, &table);
+
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/* Create the region descriptor */
+
+	obj_desc = acpi_ut_create_internal_object (ACPI_TYPE_REGION);
+	if (!obj_desc) {
+		return_ACPI_STATUS (AE_NO_MEMORY);
+	}
+
+	region_obj2                     = obj_desc->common.next_object;
+	region_obj2->extra.region_context = NULL;
+
+	/* Init the region from the operands */
+
+	obj_desc->region.space_id = REGION_DATA_TABLE;
+	obj_desc->region.address = (acpi_physical_address) ACPI_TO_INTEGER (table);
+	obj_desc->region.length = table->length;
+	obj_desc->region.node   = node;
+	obj_desc->region.flags  = AOPOBJ_DATA_VALID;
 
+	/* Install the new region object in the parent Node */
+
+	status = acpi_ns_attach_object (node, obj_desc, ACPI_TYPE_REGION);
+	if (ACPI_FAILURE (status)) {
+		goto cleanup;
+	}
+
+	status = acpi_ev_initialize_region (obj_desc, FALSE);
+	if (ACPI_FAILURE (status)) {
+		if (status == AE_NOT_EXIST) {
+			status = AE_OK;
+		}
+		else {
+			goto cleanup;
+		}
+	}
+
+	obj_desc->region.flags |= AOPOBJ_SETUP_COMPLETE;
+
+
+cleanup:
+
+	/* Remove local reference to the object */
+
+	acpi_ut_remove_reference (obj_desc);
 	return_ACPI_STATUS (status);
 }
 
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ex_create_processor
+ * FUNCTION:    acpi_ex_create_processor
  *
- * PARAMETERS:  Op              - Op containing the Processor definition and
- *                                args
- *              Processor_node  - Parent Node for the processor object
+ * PARAMETERS:  walk_state          - Current state
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Create a new processor object and populate the fields
  *
- *              Processor (Name[0], Cpu_iD[1], Pblock_addr[2], Pblock_length[3])
+ *              Processor (Name[0], cpu_iD[1], pblock_addr[2], pblock_length[3])
  *
  ****************************************************************************/
 
 acpi_status
 acpi_ex_create_processor (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_operand_object     **operand = &walk_state->operands[0];
-	acpi_operand_object     *obj_desc;
-	acpi_status             status;
+	union acpi_operand_object       **operand = &walk_state->operands[0];
+	union acpi_operand_object       *obj_desc;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE_PTR ("Ex_create_processor", walk_state);
+	ACPI_FUNCTION_TRACE_PTR ("ex_create_processor", walk_state);
 
 
 	/* Create the processor object */
@@ -395,13 +481,13 @@ acpi_ex_create_processor (
 	 * Initialize the processor object from the operands
 	 */
 	obj_desc->processor.proc_id = (u8)          operand[1]->integer.value;
-	obj_desc->processor.address = (ACPI_IO_ADDRESS) operand[2]->integer.value;
+	obj_desc->processor.address = (acpi_io_address) operand[2]->integer.value;
 	obj_desc->processor.length = (u8)           operand[3]->integer.value;
 
 	/* Install the processor object in the parent Node */
 
-	status = acpi_ns_attach_object ((acpi_namespace_node *) operand[0],
-			  obj_desc, (u8) ACPI_TYPE_PROCESSOR);
+	status = acpi_ns_attach_object ((struct acpi_namespace_node *) operand[0],
+			  obj_desc, ACPI_TYPE_PROCESSOR);
 
 
 	/* Remove local reference to the object */
@@ -413,30 +499,28 @@ acpi_ex_create_processor (
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ex_create_power_resource
+ * FUNCTION:    acpi_ex_create_power_resource
  *
- * PARAMETERS:  Op              - Op containing the Power_resource definition
- *                                and args
- *              Power_node      - Parent Node for the power object
+ * PARAMETERS:  walk_state          - Current state
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Create a new Power_resource object and populate the fields
+ * DESCRIPTION: Create a new power_resource object and populate the fields
  *
- *              Power_resource (Name[0], System_level[1], Resource_order[2])
+ *              power_resource (Name[0], system_level[1], resource_order[2])
  *
  ****************************************************************************/
 
 acpi_status
 acpi_ex_create_power_resource (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_operand_object     **operand = &walk_state->operands[0];
-	acpi_status             status;
-	acpi_operand_object     *obj_desc;
+	union acpi_operand_object       **operand = &walk_state->operands[0];
+	acpi_status                     status;
+	union acpi_operand_object       *obj_desc;
 
 
-	FUNCTION_TRACE_PTR ("Ex_create_power_resource", walk_state);
+	ACPI_FUNCTION_TRACE_PTR ("ex_create_power_resource", walk_state);
 
 
 	/* Create the power resource object */
@@ -453,8 +537,8 @@ acpi_ex_create_power_resource (
 
 	/* Install the  power resource object in the parent Node */
 
-	status = acpi_ns_attach_object ((acpi_namespace_node *) operand[0],
-			  obj_desc, (u8) ACPI_TYPE_POWER);
+	status = acpi_ns_attach_object ((struct acpi_namespace_node *) operand[0],
+			  obj_desc, ACPI_TYPE_POWER);
 
 
 	/* Remove local reference to the object */
@@ -463,15 +547,15 @@ acpi_ex_create_power_resource (
 	return_ACPI_STATUS (status);
 }
 
+#endif
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ex_create_method
+ * FUNCTION:    acpi_ex_create_method
  *
- * PARAMETERS:  Aml_start       - First byte of the method's AML
- *              Aml_length      - AML byte count for this method
- *              Method_flags    - AML method flag byte
- *              Method          - Method Node
+ * PARAMETERS:  aml_start       - First byte of the method's AML
+ *              aml_length      - AML byte count for this method
+ *              walk_state      - Current state
  *
  * RETURN:      Status
  *
@@ -481,17 +565,17 @@ acpi_ex_create_power_resource (
 
 acpi_status
 acpi_ex_create_method (
-	u8                      *aml_start,
-	u32                     aml_length,
-	acpi_walk_state         *walk_state)
+	u8                              *aml_start,
+	u32                             aml_length,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_operand_object     **operand = &walk_state->operands[0];
-	acpi_operand_object     *obj_desc;
-	acpi_status             status;
-	u8                      method_flags;
+	union acpi_operand_object       **operand = &walk_state->operands[0];
+	union acpi_operand_object       *obj_desc;
+	acpi_status                     status;
+	u8                              method_flags;
 
 
-	FUNCTION_TRACE_PTR ("Ex_create_method", walk_state);
+	ACPI_FUNCTION_TRACE_PTR ("ex_create_method", walk_state);
 
 
 	/* Create a new method object */
@@ -520,7 +604,7 @@ acpi_ex_create_method (
 	if (method_flags & METHOD_FLAGS_SERIALIZED) {
 		/*
 		 * ACPI 1.0: Concurrency = 1
-		 * ACPI 2.0: Concurrency = (Sync_level (in method declaration) + 1)
+		 * ACPI 2.0: Concurrency = (sync_level (in method declaration) + 1)
 		 */
 		obj_desc->method.concurrency = (u8)
 				  (((method_flags & METHOD_FLAGS_SYNCH_LEVEL) >> 4) + 1);
@@ -532,8 +616,8 @@ acpi_ex_create_method (
 
 	/* Attach the new object to the method Node */
 
-	status = acpi_ns_attach_object ((acpi_namespace_node *) operand[0],
-			  obj_desc, (u8) ACPI_TYPE_METHOD);
+	status = acpi_ns_attach_object ((struct acpi_namespace_node *) operand[0],
+			  obj_desc, ACPI_TYPE_METHOD);
 
 	/* Remove local reference to the object */
 
diff -urNp linux-5400/drivers/acpi/executer/exdump.c linux-5410/drivers/acpi/executer/exdump.c
--- linux-5400/drivers/acpi/executer/exdump.c
+++ linux-5410/drivers/acpi/executer/exdump.c
@@ -1,271 +1,198 @@
 /******************************************************************************
  *
  * Module Name: exdump - Interpreter debug output routines
- *              $Revision: 126 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acinterp.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "actables.h"
-#include "acparser.h"
+#include <acpi/acpi.h>
+#include <acpi/acinterp.h>
+#include <acpi/amlcode.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acparser.h>
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("exdump")
+	 ACPI_MODULE_NAME    ("exdump")
 
 
 /*
  * The following routines are used for debug output only
  */
 
-#if defined(ACPI_DEBUG) || defined(ENABLE_DEBUGGER)
+#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ex_show_hex_value
+ * FUNCTION:    acpi_ex_dump_operand
  *
- * PARAMETERS:  Byte_count          - Number of bytes to print (1, 2, or 4)
- *              *Aml_start            - Address in AML stream of bytes to print
- *              Interpreter_mode    - Current running mode (load1/Load2/Exec)
- *              Lead_space          - # of spaces to print ahead of value
- *                                    0 => none ahead but one behind
- *
- * DESCRIPTION: Print Byte_count byte(s) starting at Aml_start as a single
- *              value, in hex.  If Byte_count > 1 or the value printed is > 9, also
- *              print in decimal.
- *
- ****************************************************************************/
-
-void
-acpi_ex_show_hex_value (
-	u32                     byte_count,
-	u8                      *aml_start,
-	u32                     lead_space)
-{
-	u32                     value;                  /*  Value retrieved from AML stream */
-	u32                     show_decimal_value;
-	u32                     length;                 /*  Length of printed field */
-	u8                      *current_aml_ptr = NULL; /* Pointer to current byte of AML value    */
-
-
-	FUNCTION_TRACE ("Ex_show_hex_value");
-
-
-	if (!aml_start) {
-		REPORT_ERROR (("Ex_show_hex_value: null pointer\n"));
-	}
-
-	/*
-	 * AML numbers are always stored little-endian,
-	 * even if the processor is big-endian.
-	 */
-	for (current_aml_ptr = aml_start + byte_count,
-			value = 0;
-			current_aml_ptr > aml_start; ) {
-		value = (value << 8) + (u32)* --current_aml_ptr;
-	}
-
-	length = lead_space * byte_count + 2;
-	if (byte_count > 1) {
-		length += (byte_count - 1);
-	}
-
-	show_decimal_value = (byte_count > 1 || value > 9);
-	if (show_decimal_value) {
-		length += 3 + acpi_ex_digits_needed (value, 10);
-	}
-
-	for (length = lead_space; length; --length ) {
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_LOAD, " "));
-	}
-
-	while (byte_count--) {
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_LOAD, "%02x", *aml_start++));
-
-		if (byte_count) {
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_LOAD, " "));
-		}
-	}
-
-	if (show_decimal_value) {
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_LOAD, " [%d]", value));
-	}
-
-	if (0 == lead_space) {
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_LOAD, " "));
-	}
-
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_LOAD, "\n"));
-	return_VOID;
-}
-
-
-/*****************************************************************************
- *
- * FUNCTION:    Acpi_ex_dump_operand
- *
- * PARAMETERS:  *Entry_desc         - Pointer to entry to be dumped
+ * PARAMETERS:  *obj_desc         - Pointer to entry to be dumped
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Dump a stack entry
+ * DESCRIPTION: Dump an operand object
  *
  ****************************************************************************/
 
-acpi_status
+void
 acpi_ex_dump_operand (
-	acpi_operand_object     *entry_desc)
+	union acpi_operand_object       *obj_desc)
 {
-	u8                      *buf = NULL;
-	u32                     length;
-	u32                     i;
+	u8                              *buf = NULL;
+	u32                             length;
+	union acpi_operand_object       **element;
+	u16                             element_index;
 
 
-	PROC_NAME ("Ex_dump_operand")
+	ACPI_FUNCTION_NAME ("ex_dump_operand")
 
 
-	if (!entry_desc) {
+	if (!((ACPI_LV_EXEC & acpi_dbg_level) && (_COMPONENT & acpi_dbg_layer))) {
+		return;
+	}
+
+	if (!obj_desc) {
 		/*
 		 * This usually indicates that something serious is wrong --
 		 * since most (if not all)
 		 * code that dumps the stack expects something to be there!
 		 */
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Null stack entry ptr\n"));
-		return (AE_OK);
+		acpi_os_printf ("Null stack entry ptr\n");
+		return;
 	}
 
-	if (VALID_DESCRIPTOR_TYPE (entry_desc, ACPI_DESC_TYPE_NAMED)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "%p NS Node: ", entry_desc));
-		DUMP_ENTRY (entry_desc, ACPI_LV_INFO);
-		return (AE_OK);
+	if (ACPI_GET_DESCRIPTOR_TYPE (obj_desc) == ACPI_DESC_TYPE_NAMED) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "%p NS Node: ", obj_desc));
+		ACPI_DUMP_ENTRY (obj_desc, ACPI_LV_EXEC);
+		return;
 	}
 
-	if (!VALID_DESCRIPTOR_TYPE (entry_desc, ACPI_DESC_TYPE_INTERNAL)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "%p Is not a local object \n", entry_desc));
-		DUMP_BUFFER (entry_desc, sizeof (acpi_operand_object));
-		return (AE_OK);
+	if (ACPI_GET_DESCRIPTOR_TYPE (obj_desc) != ACPI_DESC_TYPE_OPERAND) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "%p is not a local object\n", obj_desc));
+		ACPI_DUMP_BUFFER (obj_desc, sizeof (union acpi_operand_object));
+		return;
 	}
 
-	/*  Entry_desc is a valid object */
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "%p ", entry_desc));
-
-	switch (entry_desc->common.type) {
-	case INTERNAL_TYPE_REFERENCE:
-
-		switch (entry_desc->reference.opcode) {
-		case AML_ZERO_OP:
-
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Reference: Zero\n"));
-			break;
-
+	/*  obj_desc is a valid object */
 
-		case AML_ONE_OP:
-
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Reference: One\n"));
-			break;
-
-
-		case AML_ONES_OP:
-
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Reference: Ones\n"));
-			break;
-
-
-		case AML_REVISION_OP:
-
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Reference: Revision\n"));
-			break;
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "%p ", obj_desc));
 
+	switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
+	case ACPI_TYPE_LOCAL_REFERENCE:
 
+		switch (obj_desc->reference.opcode) {
 		case AML_DEBUG_OP:
 
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Reference: Debug\n"));
+			acpi_os_printf ("Reference: Debug\n");
 			break;
 
 
 		case AML_NAME_OP:
 
-			DUMP_PATHNAME (entry_desc->reference.object, "Reference: Name: ",
+			ACPI_DUMP_PATHNAME (obj_desc->reference.object, "Reference: Name: ",
 					  ACPI_LV_INFO, _COMPONENT);
-			DUMP_ENTRY (entry_desc->reference.object, ACPI_LV_INFO);
+			ACPI_DUMP_ENTRY (obj_desc->reference.object, ACPI_LV_INFO);
 			break;
 
 
 		case AML_INDEX_OP:
 
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Reference: Index %p\n",
-					 entry_desc->reference.object));
+			acpi_os_printf ("Reference: Index %p\n",
+					 obj_desc->reference.object);
+			break;
+
+
+		case AML_REF_OF_OP:
+
+			acpi_os_printf ("Reference: (ref_of) %p\n",
+					 obj_desc->reference.object);
 			break;
 
 
 		case AML_ARG_OP:
 
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Reference: Arg%d",
-					 entry_desc->reference.offset));
+			acpi_os_printf ("Reference: Arg%d",
+					 obj_desc->reference.offset);
 
-			if (ACPI_TYPE_INTEGER == entry_desc->common.type) {
+			if (ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_INTEGER) {
 				/* Value is a Number */
 
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, " value is [%8.8X%8.8x]",
-						  HIDWORD(entry_desc->integer.value),
-						  LODWORD(entry_desc->integer.value)));
+				acpi_os_printf (" value is [%8.8X%8.8x]",
+						 ACPI_HIDWORD(obj_desc->integer.value),
+						 ACPI_LODWORD(obj_desc->integer.value));
 			}
 
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "\n"));
+			acpi_os_printf ("\n");
 			break;
 
 
 		case AML_LOCAL_OP:
 
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Reference: Local%d",
-					 entry_desc->reference.offset));
+			acpi_os_printf ("Reference: Local%d",
+					 obj_desc->reference.offset);
 
-			if (ACPI_TYPE_INTEGER == entry_desc->common.type) {
+			if (ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_INTEGER) {
 
 				/* Value is a Number */
 
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, " value is [%8.8X%8.8x]",
-						  HIDWORD(entry_desc->integer.value),
-						  LODWORD(entry_desc->integer.value)));
+				acpi_os_printf (" value is [%8.8X%8.8x]",
+						 ACPI_HIDWORD(obj_desc->integer.value),
+						 ACPI_LODWORD(obj_desc->integer.value));
 			}
 
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "\n"));
+			acpi_os_printf ("\n");
 			break;
 
 
 		case AML_INT_NAMEPATH_OP:
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Reference.Node->Name %X\n",
-					 entry_desc->reference.node->name));
+
+			acpi_os_printf ("Reference.Node->Name %X\n",
+					 obj_desc->reference.node->name.integer);
 			break;
 
+
 		default:
 
 			/*  unknown opcode  */
 
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Unknown opcode=%X\n",
-				entry_desc->reference.opcode));
+			acpi_os_printf ("Unknown Reference opcode=%X\n",
+				obj_desc->reference.opcode);
 			break;
 
 		}
@@ -275,11 +202,11 @@ acpi_ex_dump_operand (
 
 	case ACPI_TYPE_BUFFER:
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Buffer len %X @ %p \n",
-				 entry_desc->buffer.length,
-				 entry_desc->buffer.pointer));
+		acpi_os_printf ("Buffer len %X @ %p \n",
+				 obj_desc->buffer.length,
+				 obj_desc->buffer.pointer);
 
-		length = entry_desc->buffer.length;
+		length = obj_desc->buffer.length;
 
 		if (length > 64) {
 			length = 64;
@@ -287,13 +214,13 @@ acpi_ex_dump_operand (
 
 		/* Debug only -- dump the buffer contents */
 
-		if (entry_desc->buffer.pointer) {
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Buffer Contents: "));
+		if (obj_desc->buffer.pointer) {
+			acpi_os_printf ("Buffer Contents: ");
 
-			for (buf = entry_desc->buffer.pointer; length--; ++buf) {
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, " %02x", *buf));
+			for (buf = obj_desc->buffer.pointer; length--; ++buf) {
+				acpi_os_printf (" %02x", *buf);
 			}
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO,"\n"));
+			acpi_os_printf ("\n");
 		}
 
 		break;
@@ -301,135 +228,104 @@ acpi_ex_dump_operand (
 
 	case ACPI_TYPE_INTEGER:
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Integer %8.8X%8.8X\n",
-				 HIDWORD (entry_desc->integer.value),
-				 LODWORD (entry_desc->integer.value)));
-		break;
-
-
-	case INTERNAL_TYPE_IF:
-
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "If [Integer] %8.8X%8.8X\n",
-				 HIDWORD (entry_desc->integer.value),
-				 LODWORD (entry_desc->integer.value)));
-		break;
-
-
-	case INTERNAL_TYPE_WHILE:
-
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "While [Integer] %8.8X%8.8X\n",
-				 HIDWORD (entry_desc->integer.value),
-				 LODWORD (entry_desc->integer.value)));
+		acpi_os_printf ("Integer %8.8X%8.8X\n",
+				 ACPI_HIDWORD (obj_desc->integer.value),
+				 ACPI_LODWORD (obj_desc->integer.value));
 		break;
 
 
 	case ACPI_TYPE_PACKAGE:
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Package count %X @ %p\n",
-				 entry_desc->package.count, entry_desc->package.elements));
+		acpi_os_printf ("Package count %X @ %p\n",
+				 obj_desc->package.count, obj_desc->package.elements);
 
 		/*
 		 * If elements exist, package vector pointer is valid,
 		 * and debug_level exceeds 1, dump package's elements.
 		 */
-		if (entry_desc->package.count &&
-			entry_desc->package.elements &&
+		if (obj_desc->package.count &&
+			obj_desc->package.elements &&
 			acpi_dbg_level > 1) {
-			acpi_operand_object**element;
-			u16                 element_index;
-
-			for (element_index = 0, element = entry_desc->package.elements;
-				  element_index < entry_desc->package.count;
+			for (element_index = 0, element = obj_desc->package.elements;
+				  element_index < obj_desc->package.count;
 				  ++element_index, ++element) {
 				acpi_ex_dump_operand (*element);
 			}
 		}
-
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "\n"));
-
+		acpi_os_printf ("\n");
 		break;
 
 
 	case ACPI_TYPE_REGION:
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Region %s (%X)",
-			acpi_ut_get_region_name (entry_desc->region.space_id),
-			entry_desc->region.space_id));
+		acpi_os_printf ("Region %s (%X)",
+			acpi_ut_get_region_name (obj_desc->region.space_id),
+			obj_desc->region.space_id);
 
 		/*
 		 * If the address and length have not been evaluated,
 		 * don't print them.
 		 */
-		if (!(entry_desc->region.flags & AOPOBJ_DATA_VALID)) {
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "\n"));
+		if (!(obj_desc->region.flags & AOPOBJ_DATA_VALID)) {
+			acpi_os_printf ("\n");
 		}
 		else {
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, " base %8.8X%8.8X Length %X\n",
-				HIDWORD(entry_desc->region.address),
-				LODWORD(entry_desc->region.address),
-				entry_desc->region.length));
+			acpi_os_printf (" base %8.8X%8.8X Length %X\n",
+				ACPI_HIDWORD (obj_desc->region.address),
+				ACPI_LODWORD (obj_desc->region.address),
+				obj_desc->region.length);
 		}
 		break;
 
 
 	case ACPI_TYPE_STRING:
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "String length %X @ %p \"",
-				 entry_desc->string.length, entry_desc->string.pointer));
-
-		for (i = 0; i < entry_desc->string.length; i++) {
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "%c",
-					 entry_desc->string.pointer[i]));
-		}
-
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "\"\n"));
+		acpi_os_printf ("String length %X @ %p ",
+				 obj_desc->string.length, obj_desc->string.pointer);
+		acpi_ut_print_string (obj_desc->string.pointer, ACPI_UINT8_MAX);
+		acpi_os_printf ("\n");
 		break;
 
 
-	case INTERNAL_TYPE_BANK_FIELD:
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Bank_field\n"));
+		acpi_os_printf ("bank_field\n");
 		break;
 
 
-	case INTERNAL_TYPE_REGION_FIELD:
+	case ACPI_TYPE_LOCAL_REGION_FIELD:
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO,
-			"Region_field: bits=%X bitaccwidth=%X lock=%X update=%X at byte=%X bit=%X of below:\n",
-			entry_desc->field.bit_length,    entry_desc->field.access_bit_width,
-			entry_desc->field.lock_rule,     entry_desc->field.update_rule,
-			entry_desc->field.base_byte_offset, entry_desc->field.start_field_bit_offset));
-		DUMP_STACK_ENTRY (entry_desc->field.region_obj);
+		acpi_os_printf (
+			"region_field: Bits=%X acc_width=%X Lock=%X Update=%X at byte=%X bit=%X of below:\n",
+			obj_desc->field.bit_length, obj_desc->field.access_byte_width,
+			obj_desc->field.field_flags & AML_FIELD_LOCK_RULE_MASK,
+			obj_desc->field.field_flags & AML_FIELD_UPDATE_RULE_MASK,
+			obj_desc->field.base_byte_offset, obj_desc->field.start_field_bit_offset);
+		ACPI_DUMP_STACK_ENTRY (obj_desc->field.region_obj);
 		break;
 
 
-	case INTERNAL_TYPE_INDEX_FIELD:
+	case ACPI_TYPE_LOCAL_INDEX_FIELD:
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Index_field\n"));
+		acpi_os_printf ("index_field\n");
 		break;
 
 
 	case ACPI_TYPE_BUFFER_FIELD:
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO,
-			"Buffer_field: %X bits at byte %X bit %X of \n",
-			entry_desc->buffer_field.bit_length, entry_desc->buffer_field.base_byte_offset,
-			entry_desc->buffer_field.start_field_bit_offset));
+		acpi_os_printf (
+			"buffer_field: %X bits at byte %X bit %X of \n",
+			obj_desc->buffer_field.bit_length, obj_desc->buffer_field.base_byte_offset,
+			obj_desc->buffer_field.start_field_bit_offset);
 
-		if (!entry_desc->buffer_field.buffer_obj)
-		{
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "*NULL* \n"));
+		if (!obj_desc->buffer_field.buffer_obj) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "*NULL* \n"));
 		}
-
-		else if (ACPI_TYPE_BUFFER !=
-				  entry_desc->buffer_field.buffer_obj->common.type)
-		{
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "*not a Buffer* \n"));
+		else if (ACPI_GET_OBJECT_TYPE (obj_desc->buffer_field.buffer_obj) != ACPI_TYPE_BUFFER) {
+			acpi_os_printf ("*not a Buffer* \n");
 		}
-
-		else
-		{
-			DUMP_STACK_ENTRY (entry_desc->buffer_field.buffer_obj);
+		else {
+			ACPI_DUMP_STACK_ENTRY (obj_desc->buffer_field.buffer_obj);
 		}
 
 		break;
@@ -437,81 +333,67 @@ acpi_ex_dump_operand (
 
 	case ACPI_TYPE_EVENT:
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Event\n"));
+		acpi_os_printf ("Event\n");
 		break;
 
 
 	case ACPI_TYPE_METHOD:
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO,
+		acpi_os_printf (
 			"Method(%X) @ %p:%X\n",
-			entry_desc->method.param_count,
-			entry_desc->method.aml_start, entry_desc->method.aml_length));
+			obj_desc->method.param_count,
+			obj_desc->method.aml_start, obj_desc->method.aml_length);
 		break;
 
 
 	case ACPI_TYPE_MUTEX:
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Mutex\n"));
+		acpi_os_printf ("Mutex\n");
 		break;
 
 
 	case ACPI_TYPE_DEVICE:
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Device\n"));
+		acpi_os_printf ("Device\n");
 		break;
 
 
 	case ACPI_TYPE_POWER:
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Power\n"));
+		acpi_os_printf ("Power\n");
 		break;
 
 
 	case ACPI_TYPE_PROCESSOR:
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Processor\n"));
+		acpi_os_printf ("Processor\n");
 		break;
 
 
 	case ACPI_TYPE_THERMAL:
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Thermal\n"));
+		acpi_os_printf ("Thermal\n");
 		break;
 
 
 	default:
-		/*  unknown Entry_desc->Common.Type value   */
-
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "Unknown Type %X\n",
-			entry_desc->common.type));
-
-		/* Back up to previous entry */
-
-		entry_desc--;
-
+		/* Unknown Type */
 
-		/* TBD: [Restructure]  Change to use dump object routine !! */
-		/*       What is all of this?? */
-
-		DUMP_BUFFER (entry_desc, sizeof (acpi_operand_object));
-		DUMP_BUFFER (++entry_desc, sizeof (acpi_operand_object));
-		DUMP_BUFFER (++entry_desc, sizeof (acpi_operand_object));
+		acpi_os_printf ("Unknown Type %X\n", ACPI_GET_OBJECT_TYPE (obj_desc));
 		break;
-
 	}
 
-	return (AE_OK);
+	return;
 }
 
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ex_dump_operands
+ * FUNCTION:    acpi_ex_dump_operands
  *
- * PARAMETERS:  Interpreter_mode     - Load or Exec
+ * PARAMETERS:  interpreter_mode     - Load or Exec
  *              *Ident              - Identification
- *              Num_levels          - # of stack entries to dump above line
+ *              num_levels          - # of stack entries to dump above line
  *              *Note               - Output notation
  *
  * DESCRIPTION: Dump the object stack
@@ -520,54 +402,45 @@ acpi_ex_dump_operand (
 
 void
 acpi_ex_dump_operands (
-	acpi_operand_object     **operands,
-	operating_mode          interpreter_mode,
-	NATIVE_CHAR             *ident,
-	u32                     num_levels,
-	NATIVE_CHAR             *note,
-	NATIVE_CHAR             *module_name,
-	u32                     line_number)
+	union acpi_operand_object       **operands,
+	acpi_interpreter_mode           interpreter_mode,
+	char                            *ident,
+	u32                             num_levels,
+	char                            *note,
+	char                            *module_name,
+	u32                             line_number)
 {
-	NATIVE_UINT             i;
-	acpi_operand_object     **entry_desc;
+	acpi_native_uint                i;
+	union acpi_operand_object       **obj_desc;
 
 
-	PROC_NAME ("Ex_dump_operands");
+	ACPI_FUNCTION_NAME ("ex_dump_operands");
 
 
-	if (!ident)
-	{
+	if (!ident) {
 		ident = "?";
 	}
 
-	if (!note)
-	{
+	if (!note) {
 		note = "?";
 	}
 
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
 		"************* Operand Stack Contents (Opcode [%s], %d Operands)\n",
 		ident, num_levels));
 
-	if (num_levels == 0)
-	{
+	if (num_levels == 0) {
 		num_levels = 1;
 	}
 
-	/* Dump the stack starting at the top, working down */
-
-	for (i = 0; num_levels > 0; i--, num_levels--)
-	{
-		entry_desc = &operands[i];
+	/* Dump the operand stack starting at the top */
 
-		if (ACPI_FAILURE (acpi_ex_dump_operand (*entry_desc)))
-		{
-			break;
-		}
+	for (i = 0; num_levels > 0; i--, num_levels--) {
+		obj_desc = &operands[i];
+		acpi_ex_dump_operand (*obj_desc);
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
 		"************* Stack dump from %s(%d), %s\n",
 		module_name, line_number, note));
 	return;
@@ -576,7 +449,59 @@ acpi_ex_dump_operands (
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ex_dump_node
+ * FUNCTION:    acpi_ex_out*
+ *
+ * PARAMETERS:  Title               - Descriptive text
+ *              Value               - Value to be displayed
+ *
+ * DESCRIPTION: Object dump output formatting functions.  These functions
+ *              reduce the number of format strings required and keeps them
+ *              all in one place for easy modification.
+ *
+ ****************************************************************************/
+
+void
+acpi_ex_out_string (
+	char                            *title,
+	char                            *value)
+{
+	acpi_os_printf ("%20s : %s\n", title, value);
+}
+
+void
+acpi_ex_out_pointer (
+	char                            *title,
+	void                            *value)
+{
+	acpi_os_printf ("%20s : %p\n", title, value);
+}
+
+void
+acpi_ex_out_integer (
+	char                            *title,
+	u32                             value)
+{
+	acpi_os_printf ("%20s : %X\n", title, value);
+}
+
+void
+acpi_ex_out_address (
+	char                            *title,
+	acpi_physical_address           value)
+{
+
+#if ACPI_MACHINE_WIDTH == 16
+	acpi_os_printf ("%20s : %p\n", title, value);
+#else
+	acpi_os_printf ("%20s : %8.8X%8.8X\n", title,
+			 ACPI_HIDWORD (value), ACPI_LODWORD (value));
+#endif
+}
+
+
+/*****************************************************************************
+ *
+ * FUNCTION:    acpi_ex_dump_node
  *
  * PARAMETERS:  *Node           - Descriptor to dump
  *              Flags               - Force display
@@ -587,37 +512,34 @@ acpi_ex_dump_operands (
 
 void
 acpi_ex_dump_node (
-	acpi_namespace_node     *node,
-	u32                     flags)
+	struct acpi_namespace_node      *node,
+	u32                             flags)
 {
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
-	if (!flags)
-	{
-		if (!((ACPI_LV_OBJECTS & acpi_dbg_level) && (_COMPONENT & acpi_dbg_layer)))
-		{
+	if (!flags) {
+		if (!((ACPI_LV_OBJECTS & acpi_dbg_level) && (_COMPONENT & acpi_dbg_layer))) {
 			return;
 		}
 	}
 
-
-	acpi_os_printf ("%20s : %4.4s\n", "Name",           (char*)&node->name);
-	acpi_os_printf ("%20s : %s\n",  "Type",             acpi_ut_get_type_name (node->type));
-	acpi_os_printf ("%20s : %X\n",  "Flags",            node->flags);
-	acpi_os_printf ("%20s : %X\n",  "Owner Id",         node->owner_id);
-	acpi_os_printf ("%20s : %X\n",  "Reference Count",  node->reference_count);
-	acpi_os_printf ("%20s : %p\n",  "Attached Object",  node->object);
-	acpi_os_printf ("%20s : %p\n",  "Child_list",       node->child);
-	acpi_os_printf ("%20s : %p\n",  "Next_peer",        node->peer);
-	acpi_os_printf ("%20s : %p\n",  "Parent",           acpi_ns_get_parent_object (node));
+	acpi_os_printf ("%20s : %4.4s\n",     "Name", node->name.ascii);
+	acpi_ex_out_string ("Type",           acpi_ut_get_type_name (node->type));
+	acpi_ex_out_integer ("Flags",         node->flags);
+	acpi_ex_out_integer ("Owner Id",      node->owner_id);
+	acpi_ex_out_integer ("Reference Count", node->reference_count);
+	acpi_ex_out_pointer ("Attached Object", acpi_ns_get_attached_object (node));
+	acpi_ex_out_pointer ("child_list",    node->child);
+	acpi_ex_out_pointer ("next_peer",     node->peer);
+	acpi_ex_out_pointer ("Parent",        acpi_ns_get_parent_node (node));
 }
 
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ex_dump_object_descriptor
+ * FUNCTION:    acpi_ex_dump_object_descriptor
  *
  * PARAMETERS:  *Object             - Descriptor to dump
  *              Flags               - Force display
@@ -628,253 +550,240 @@ acpi_ex_dump_node (
 
 void
 acpi_ex_dump_object_descriptor (
-	acpi_operand_object     *obj_desc,
-	u32                     flags)
+	union acpi_operand_object       *obj_desc,
+	u32                             flags)
 {
-	const acpi_opcode_info  *op_info;
+	u32                             i;
 
 
-	FUNCTION_TRACE ("Ex_dump_object_descriptor");
+	ACPI_FUNCTION_TRACE ("ex_dump_object_descriptor");
 
 
-	if (!flags)
-	{
-		if (!((ACPI_LV_OBJECTS & acpi_dbg_level) && (_COMPONENT & acpi_dbg_layer)))
-		{
-			return;
+	if (!flags) {
+		if (!((ACPI_LV_OBJECTS & acpi_dbg_level) && (_COMPONENT & acpi_dbg_layer))) {
+			return_VOID;
 		}
 	}
 
-	if (!(VALID_DESCRIPTOR_TYPE (obj_desc, ACPI_DESC_TYPE_INTERNAL)))
-	{
-		acpi_os_printf ("%p is not a valid ACPI object\n", obj_desc);
+	if (ACPI_GET_DESCRIPTOR_TYPE (obj_desc) == ACPI_DESC_TYPE_NAMED) {
+		acpi_ex_dump_node ((struct acpi_namespace_node *) obj_desc, flags);
+		acpi_os_printf ("\nAttached Object (%p):\n", ((struct acpi_namespace_node *) obj_desc)->object);
+		acpi_ex_dump_object_descriptor (((struct acpi_namespace_node *) obj_desc)->object, flags);
 		return;
 	}
 
+	if (ACPI_GET_DESCRIPTOR_TYPE (obj_desc) != ACPI_DESC_TYPE_OPERAND) {
+		acpi_os_printf ("ex_dump_object_descriptor: %p is not a valid ACPI object\n", obj_desc);
+		return_VOID;
+	}
+
 	/* Common Fields */
 
-	acpi_os_printf ("%20s : %X\n", "Reference Count", obj_desc->common.reference_count);
-	acpi_os_printf ("%20s : %X\n", "Flags", obj_desc->common.flags);
+	acpi_ex_out_string ("Type",          acpi_ut_get_object_type_name (obj_desc));
+	acpi_ex_out_integer ("Reference Count", obj_desc->common.reference_count);
+	acpi_ex_out_integer ("Flags",        obj_desc->common.flags);
 
 	/* Object-specific Fields */
 
-	switch (obj_desc->common.type)
-	{
+	switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
 	case ACPI_TYPE_INTEGER:
 
-		acpi_os_printf ("%20s : %s\n", "Type", "Integer");
-		acpi_os_printf ("%20s : %X%8.8X\n", "Value", HIDWORD (obj_desc->integer.value),
-				  LODWORD (obj_desc->integer.value));
+		acpi_os_printf ("%20s : %8.8X%8.8X\n", "Value",
+				  ACPI_HIDWORD (obj_desc->integer.value),
+				  ACPI_LODWORD (obj_desc->integer.value));
 		break;
 
 
 	case ACPI_TYPE_STRING:
 
-		acpi_os_printf ("%20s : %s\n", "Type", "String");
-		acpi_os_printf ("%20s : %X\n", "Length", obj_desc->string.length);
-		acpi_os_printf ("%20s : %p\n", "Pointer", obj_desc->string.pointer);
+		acpi_ex_out_integer ("Length",       obj_desc->string.length);
+
+		acpi_os_printf ("%20s : %p ", "Pointer", obj_desc->string.pointer);
+		acpi_ut_print_string (obj_desc->string.pointer, ACPI_UINT8_MAX);
+		acpi_os_printf ("\n");
 		break;
 
 
 	case ACPI_TYPE_BUFFER:
 
-		acpi_os_printf ("%20s : %s\n", "Type", "Buffer");
-		acpi_os_printf ("%20s : %X\n", "Length", obj_desc->buffer.length);
-		acpi_os_printf ("%20s : %p\n", "Pointer", obj_desc->buffer.pointer);
+		acpi_ex_out_integer ("Length",       obj_desc->buffer.length);
+		acpi_ex_out_pointer ("Pointer",      obj_desc->buffer.pointer);
+		ACPI_DUMP_BUFFER (obj_desc->buffer.pointer, obj_desc->buffer.length);
 		break;
 
 
 	case ACPI_TYPE_PACKAGE:
 
-		acpi_os_printf ("%20s : %s\n", "Type", "Package");
-		acpi_os_printf ("%20s : %X\n", "Flags", obj_desc->package.flags);
-		acpi_os_printf ("%20s : %X\n", "Count", obj_desc->package.count);
-		acpi_os_printf ("%20s : %p\n", "Elements", obj_desc->package.elements);
-		acpi_os_printf ("%20s : %p\n", "Next_element", obj_desc->package.next_element);
-		break;
-
-
-	case ACPI_TYPE_BUFFER_FIELD:
-
-		acpi_os_printf ("%20s : %s\n", "Type", "Buffer_field");
-		acpi_os_printf ("%20s : %X\n", "Bit_length", obj_desc->buffer_field.bit_length);
-		acpi_os_printf ("%20s : %X\n", "Bit_offset", obj_desc->buffer_field.start_field_bit_offset);
-		acpi_os_printf ("%20s : %X\n", "Base_byte_offset",obj_desc->buffer_field.base_byte_offset);
-		acpi_os_printf ("%20s : %p\n", "Buffer_obj", obj_desc->buffer_field.buffer_obj);
+		acpi_ex_out_integer ("Flags",        obj_desc->package.flags);
+		acpi_ex_out_integer ("Count",        obj_desc->package.count);
+		acpi_ex_out_pointer ("Elements",     obj_desc->package.elements);
+
+		/* Dump the package contents */
+
+		if (obj_desc->package.count > 0) {
+			acpi_os_printf ("\nPackage Contents:\n");
+			for (i = 0; i < obj_desc->package.count; i++) {
+				acpi_os_printf ("[%.3d] %p", i, obj_desc->package.elements[i]);
+				if (obj_desc->package.elements[i]) {
+					acpi_os_printf (" %s", acpi_ut_get_object_type_name (obj_desc->package.elements[i]));
+				}
+				acpi_os_printf ("\n");
+			}
+		}
 		break;
 
 
 	case ACPI_TYPE_DEVICE:
 
-		acpi_os_printf ("%20s : %s\n", "Type", "Device");
-		acpi_os_printf ("%20s : %p\n", "Addr_handler", obj_desc->device.addr_handler);
-		acpi_os_printf ("%20s : %p\n", "Sys_handler", obj_desc->device.sys_handler);
-		acpi_os_printf ("%20s : %p\n", "Drv_handler", obj_desc->device.drv_handler);
+		acpi_ex_out_pointer ("address_space", obj_desc->device.address_space);
+		acpi_ex_out_pointer ("system_notify", obj_desc->device.system_notify);
+		acpi_ex_out_pointer ("device_notify", obj_desc->device.device_notify);
 		break;
 
+
 	case ACPI_TYPE_EVENT:
 
-		acpi_os_printf ("%20s : %s\n", "Type", "Event");
-		acpi_os_printf ("%20s : %X\n", "Semaphore", obj_desc->event.semaphore);
+		acpi_ex_out_pointer ("Semaphore",    obj_desc->event.semaphore);
 		break;
 
 
 	case ACPI_TYPE_METHOD:
 
-		acpi_os_printf ("%20s : %s\n", "Type", "Method");
-		acpi_os_printf ("%20s : %X\n", "Param_count", obj_desc->method.param_count);
-		acpi_os_printf ("%20s : %X\n", "Concurrency", obj_desc->method.concurrency);
-		acpi_os_printf ("%20s : %p\n", "Semaphore", obj_desc->method.semaphore);
-		acpi_os_printf ("%20s : %X\n", "Aml_length", obj_desc->method.aml_length);
-		acpi_os_printf ("%20s : %X\n", "Aml_start", obj_desc->method.aml_start);
+		acpi_ex_out_integer ("param_count",  obj_desc->method.param_count);
+		acpi_ex_out_integer ("Concurrency",  obj_desc->method.concurrency);
+		acpi_ex_out_pointer ("Semaphore",    obj_desc->method.semaphore);
+		acpi_ex_out_integer ("owning_id",    obj_desc->method.owning_id);
+		acpi_ex_out_integer ("aml_length",   obj_desc->method.aml_length);
+		acpi_ex_out_pointer ("aml_start",    obj_desc->method.aml_start);
 		break;
 
 
 	case ACPI_TYPE_MUTEX:
 
-		acpi_os_printf ("%20s : %s\n", "Type", "Mutex");
-		acpi_os_printf ("%20s : %X\n", "Sync_level", obj_desc->mutex.sync_level);
-		acpi_os_printf ("%20s : %p\n", "Owner", obj_desc->mutex.owner);
-		acpi_os_printf ("%20s : %X\n", "Acquisition_depth", obj_desc->mutex.acquisition_depth);
-		acpi_os_printf ("%20s : %p\n", "Semaphore", obj_desc->mutex.semaphore);
+		acpi_ex_out_integer ("sync_level",   obj_desc->mutex.sync_level);
+		acpi_ex_out_pointer ("owner_thread", obj_desc->mutex.owner_thread);
+		acpi_ex_out_integer ("acquisition_depth",obj_desc->mutex.acquisition_depth);
+		acpi_ex_out_pointer ("Semaphore",    obj_desc->mutex.semaphore);
 		break;
 
 
 	case ACPI_TYPE_REGION:
 
-		acpi_os_printf ("%20s : %s\n", "Type", "Region");
-		acpi_os_printf ("%20s : %X\n", "Space_id", obj_desc->region.space_id);
-		acpi_os_printf ("%20s : %X\n", "Flags", obj_desc->region.flags);
-		acpi_os_printf ("%20s : %X\n", "Address", obj_desc->region.address);
-		acpi_os_printf ("%20s : %X\n", "Length", obj_desc->region.length);
-		acpi_os_printf ("%20s : %p\n", "Addr_handler", obj_desc->region.addr_handler);
-		acpi_os_printf ("%20s : %p\n", "Next", obj_desc->region.next);
+		acpi_ex_out_integer ("space_id",     obj_desc->region.space_id);
+		acpi_ex_out_integer ("Flags",        obj_desc->region.flags);
+		acpi_ex_out_address ("Address",      obj_desc->region.address);
+		acpi_ex_out_integer ("Length",       obj_desc->region.length);
+		acpi_ex_out_pointer ("address_space", obj_desc->region.address_space);
+		acpi_ex_out_pointer ("Next",         obj_desc->region.next);
 		break;
 
 
 	case ACPI_TYPE_POWER:
 
-		acpi_os_printf ("%20s : %s\n", "Type", "Power_resource");
-		acpi_os_printf ("%20s : %X\n", "System_level", obj_desc->power_resource.system_level);
-		acpi_os_printf ("%20s : %X\n", "Resource_order", obj_desc->power_resource.resource_order);
-		acpi_os_printf ("%20s : %p\n", "Sys_handler", obj_desc->power_resource.sys_handler);
-		acpi_os_printf ("%20s : %p\n", "Drv_handler", obj_desc->power_resource.drv_handler);
+		acpi_ex_out_integer ("system_level", obj_desc->power_resource.system_level);
+		acpi_ex_out_integer ("resource_order", obj_desc->power_resource.resource_order);
+		acpi_ex_out_pointer ("system_notify", obj_desc->power_resource.system_notify);
+		acpi_ex_out_pointer ("device_notify", obj_desc->power_resource.device_notify);
 		break;
 
 
 	case ACPI_TYPE_PROCESSOR:
 
-		acpi_os_printf ("%20s : %s\n", "Type", "Processor");
-		acpi_os_printf ("%20s : %X\n", "Processor ID", obj_desc->processor.proc_id);
-		acpi_os_printf ("%20s : %X\n", "Length", obj_desc->processor.length);
-		acpi_os_printf ("%20s : %X\n", "Address", obj_desc->processor.address);
-		acpi_os_printf ("%20s : %p\n", "Sys_handler", obj_desc->processor.sys_handler);
-		acpi_os_printf ("%20s : %p\n", "Drv_handler", obj_desc->processor.drv_handler);
-		acpi_os_printf ("%20s : %p\n", "Addr_handler", obj_desc->processor.addr_handler);
+		acpi_ex_out_integer ("Processor ID", obj_desc->processor.proc_id);
+		acpi_ex_out_integer ("Length",       obj_desc->processor.length);
+		acpi_ex_out_address ("Address",      (acpi_physical_address) obj_desc->processor.address);
+		acpi_ex_out_pointer ("system_notify", obj_desc->processor.system_notify);
+		acpi_ex_out_pointer ("device_notify", obj_desc->processor.device_notify);
+		acpi_ex_out_pointer ("address_space", obj_desc->processor.address_space);
 		break;
 
 
 	case ACPI_TYPE_THERMAL:
 
-		acpi_os_printf ("%20s : %s\n", "Type", "Thermal_zone");
-		acpi_os_printf ("%20s : %p\n", "Sys_handler", obj_desc->thermal_zone.sys_handler);
-		acpi_os_printf ("%20s : %p\n", "Drv_handler", obj_desc->thermal_zone.drv_handler);
-		acpi_os_printf ("%20s : %p\n", "Addr_handler", obj_desc->thermal_zone.addr_handler);
+		acpi_ex_out_pointer ("system_notify", obj_desc->thermal_zone.system_notify);
+		acpi_ex_out_pointer ("device_notify", obj_desc->thermal_zone.device_notify);
+		acpi_ex_out_pointer ("address_space", obj_desc->thermal_zone.address_space);
 		break;
 
 
-	case INTERNAL_TYPE_REGION_FIELD:
-
-		acpi_os_printf ("%20s : %p\n", "Access_bit_width", obj_desc->field.access_bit_width);
-		acpi_os_printf ("%20s : %p\n", "Bit_length", obj_desc->field.bit_length);
-		acpi_os_printf ("%20s : %p\n", "Base_byte_offset",obj_desc->field.base_byte_offset);
-		acpi_os_printf ("%20s : %p\n", "Bit_offset", obj_desc->field.start_field_bit_offset);
-		acpi_os_printf ("%20s : %p\n", "Region_obj", obj_desc->field.region_obj);
-		break;
-
-
-	case INTERNAL_TYPE_BANK_FIELD:
-
-		acpi_os_printf ("%20s : %s\n", "Type", "Bank_field");
-		acpi_os_printf ("%20s : %X\n", "Access_bit_width", obj_desc->bank_field.access_bit_width);
-		acpi_os_printf ("%20s : %X\n", "Lock_rule", obj_desc->bank_field.lock_rule);
-		acpi_os_printf ("%20s : %X\n", "Update_rule", obj_desc->bank_field.update_rule);
-		acpi_os_printf ("%20s : %X\n", "Bit_length", obj_desc->bank_field.bit_length);
-		acpi_os_printf ("%20s : %X\n", "Bit_offset", obj_desc->bank_field.start_field_bit_offset);
-		acpi_os_printf ("%20s : %X\n", "Base_byte_offset", obj_desc->bank_field.base_byte_offset);
-		acpi_os_printf ("%20s : %X\n", "Value", obj_desc->bank_field.value);
-		acpi_os_printf ("%20s : %p\n", "Region_obj", obj_desc->bank_field.region_obj);
-		acpi_os_printf ("%20s : %X\n", "Bank_register_obj", obj_desc->bank_field.bank_register_obj);
-		break;
-
-
-	case INTERNAL_TYPE_INDEX_FIELD:
-
-		acpi_os_printf ("%20s : %s\n", "Type", "Index_field");
-		acpi_os_printf ("%20s : %X\n", "Access_bit_width", obj_desc->index_field.access_bit_width);
-		acpi_os_printf ("%20s : %X\n", "Lock_rule", obj_desc->index_field.lock_rule);
-		acpi_os_printf ("%20s : %X\n", "Update_rule", obj_desc->index_field.update_rule);
-		acpi_os_printf ("%20s : %X\n", "Bit_length", obj_desc->index_field.bit_length);
-		acpi_os_printf ("%20s : %X\n", "Bit_offset", obj_desc->index_field.start_field_bit_offset);
-		acpi_os_printf ("%20s : %X\n", "Value", obj_desc->index_field.value);
-		acpi_os_printf ("%20s : %X\n", "Index", obj_desc->index_field.index_obj);
-		acpi_os_printf ("%20s : %X\n", "Data", obj_desc->index_field.data_obj);
-		break;
-
-
-	case INTERNAL_TYPE_REFERENCE:
-
-		op_info = acpi_ps_get_opcode_info (obj_desc->reference.opcode);
+	case ACPI_TYPE_BUFFER_FIELD:
+	case ACPI_TYPE_LOCAL_REGION_FIELD:
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
+	case ACPI_TYPE_LOCAL_INDEX_FIELD:
+
+		acpi_ex_out_integer ("field_flags",  obj_desc->common_field.field_flags);
+		acpi_ex_out_integer ("access_byte_width", obj_desc->common_field.access_byte_width);
+		acpi_ex_out_integer ("bit_length",   obj_desc->common_field.bit_length);
+		acpi_ex_out_integer ("fld_bit_offset", obj_desc->common_field.start_field_bit_offset);
+		acpi_ex_out_integer ("base_byte_offset", obj_desc->common_field.base_byte_offset);
+		acpi_ex_out_integer ("datum_valid_bits", obj_desc->common_field.datum_valid_bits);
+		acpi_ex_out_integer ("end_fld_valid_bits", obj_desc->common_field.end_field_valid_bits);
+		acpi_ex_out_integer ("end_buf_valid_bits", obj_desc->common_field.end_buffer_valid_bits);
+		acpi_ex_out_pointer ("parent_node",  obj_desc->common_field.node);
+
+		switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
+		case ACPI_TYPE_BUFFER_FIELD:
+			acpi_ex_out_pointer ("buffer_obj",   obj_desc->buffer_field.buffer_obj);
+			break;
+
+		case ACPI_TYPE_LOCAL_REGION_FIELD:
+			acpi_ex_out_pointer ("region_obj",   obj_desc->field.region_obj);
+			break;
+
+		case ACPI_TYPE_LOCAL_BANK_FIELD:
+			acpi_ex_out_integer ("Value",        obj_desc->bank_field.value);
+			acpi_ex_out_pointer ("region_obj",   obj_desc->bank_field.region_obj);
+			acpi_ex_out_pointer ("bank_obj",     obj_desc->bank_field.bank_obj);
+			break;
+
+		case ACPI_TYPE_LOCAL_INDEX_FIELD:
+			acpi_ex_out_integer ("Value",        obj_desc->index_field.value);
+			acpi_ex_out_pointer ("Index",        obj_desc->index_field.index_obj);
+			acpi_ex_out_pointer ("Data",         obj_desc->index_field.data_obj);
+			break;
 
-		acpi_os_printf ("%20s : %s\n", "Type", "Reference");
-		acpi_os_printf ("%20s : %X\n", "Target_type", obj_desc->reference.target_type);
-		acpi_os_printf ("%20s : %s\n", "Opcode", op_info->name);
-		acpi_os_printf ("%20s : %X\n", "Offset", obj_desc->reference.offset);
-		acpi_os_printf ("%20s : %p\n", "Obj_desc", obj_desc->reference.object);
-		acpi_os_printf ("%20s : %p\n", "Node", obj_desc->reference.node);
-		acpi_os_printf ("%20s : %p\n", "Where", obj_desc->reference.where);
+		default:
+			/* All object types covered above */
+			break;
+		}
 		break;
 
 
-	case INTERNAL_TYPE_ADDRESS_HANDLER:
+	case ACPI_TYPE_LOCAL_REFERENCE:
 
-		acpi_os_printf ("%20s : %s\n", "Type", "Address Handler");
-		acpi_os_printf ("%20s : %X\n", "Space_id", obj_desc->addr_handler.space_id);
-		acpi_os_printf ("%20s : %p\n", "Next", obj_desc->addr_handler.next);
-		acpi_os_printf ("%20s : %p\n", "Region_list", obj_desc->addr_handler.region_list);
-		acpi_os_printf ("%20s : %p\n", "Node", obj_desc->addr_handler.node);
-		acpi_os_printf ("%20s : %p\n", "Handler", obj_desc->addr_handler.handler);
-		acpi_os_printf ("%20s : %p\n", "Context", obj_desc->addr_handler.context);
+		acpi_ex_out_integer ("target_type",  obj_desc->reference.target_type);
+		acpi_ex_out_string ("Opcode",        (acpi_ps_get_opcode_info (obj_desc->reference.opcode))->name);
+		acpi_ex_out_integer ("Offset",       obj_desc->reference.offset);
+		acpi_ex_out_pointer ("obj_desc",     obj_desc->reference.object);
+		acpi_ex_out_pointer ("Node",         obj_desc->reference.node);
+		acpi_ex_out_pointer ("Where",        obj_desc->reference.where);
 		break;
 
 
-	case INTERNAL_TYPE_NOTIFY:
+	case ACPI_TYPE_LOCAL_ADDRESS_HANDLER:
 
-		acpi_os_printf ("%20s : %s\n", "Type", "Notify Handler");
-		acpi_os_printf ("%20s : %p\n", "Node", obj_desc->notify_handler.node);
-		acpi_os_printf ("%20s : %p\n", "Handler", obj_desc->notify_handler.handler);
-		acpi_os_printf ("%20s : %p\n", "Context", obj_desc->notify_handler.context);
+		acpi_ex_out_integer ("space_id",     obj_desc->address_space.space_id);
+		acpi_ex_out_pointer ("Next",         obj_desc->address_space.next);
+		acpi_ex_out_pointer ("region_list",  obj_desc->address_space.region_list);
+		acpi_ex_out_pointer ("Node",         obj_desc->address_space.node);
+		acpi_ex_out_pointer ("Context",      obj_desc->address_space.context);
 		break;
 
 
-	case INTERNAL_TYPE_ALIAS:
-	case INTERNAL_TYPE_FIELD_DEFN:
-	case INTERNAL_TYPE_BANK_FIELD_DEFN:
-	case INTERNAL_TYPE_INDEX_FIELD_DEFN:
-	case INTERNAL_TYPE_IF:
-	case INTERNAL_TYPE_ELSE:
-	case INTERNAL_TYPE_WHILE:
-	case INTERNAL_TYPE_SCOPE:
-	case INTERNAL_TYPE_DEF_ANY:
+	case ACPI_TYPE_LOCAL_NOTIFY:
 
-		acpi_os_printf ("*** Structure display not implemented for type %X! ***\n",
-			obj_desc->common.type);
+		acpi_ex_out_pointer ("Node",         obj_desc->notify.node);
+		acpi_ex_out_pointer ("Context",      obj_desc->notify.context);
 		break;
 
 
+	case ACPI_TYPE_LOCAL_ALIAS:
+	case ACPI_TYPE_LOCAL_EXTRA:
+	case ACPI_TYPE_LOCAL_DATA:
 	default:
 
-		acpi_os_printf ("*** Cannot display unknown type %X! ***\n", obj_desc->common.type);
+		acpi_os_printf ("ex_dump_object_descriptor: Display not implemented for object type %s\n",
+			acpi_ut_get_object_type_name (obj_desc));
 		break;
 	}
 
diff -urNp linux-5400/drivers/acpi/executer/exfield.c linux-5410/drivers/acpi/executer/exfield.c
--- linux-5400/drivers/acpi/executer/exfield.c
+++ linux-5410/drivers/acpi/executer/exfield.c
@@ -1,69 +1,85 @@
 /******************************************************************************
  *
  * Module Name: exfield - ACPI AML (p-code) execution - field manipulation
- *              $Revision: 95 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acdispat.h"
-#include "acinterp.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "achware.h"
-#include "acevents.h"
+#include <acpi/acpi.h>
+#include <acpi/acdispat.h>
+#include <acpi/acinterp.h>
 
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("exfield")
+	 ACPI_MODULE_NAME    ("exfield")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_read_data_from_field
+ * FUNCTION:    acpi_ex_read_data_from_field
  *
- * PARAMETERS:  Mode                - ACPI_READ or ACPI_WRITE
- *              *Field_node         - Parent node for field to be accessed
- *              *Buffer             - Value(s) to be read or written
- *              Buffer_length       - Number of bytes to transfer
+ * PARAMETERS:  walk_state          - Current execution state
+ *              obj_desc            - The named field
+ *              ret_buffer_desc     - Where the return data object is stored
  *
- * RETURN:      Status3
+ * RETURN:      Status
  *
- * DESCRIPTION: Read or write a named field
+ * DESCRIPTION: Read from a named field.  Returns either an Integer or a
+ *              Buffer, depending on the size of the field.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ex_read_data_from_field (
-	acpi_operand_object     *obj_desc,
-	acpi_operand_object     **ret_buffer_desc)
+	struct acpi_walk_state          *walk_state,
+	union acpi_operand_object       *obj_desc,
+	union acpi_operand_object       **ret_buffer_desc)
 {
-	acpi_status             status;
-	acpi_operand_object     *buffer_desc;
-	u32                     length;
-	void                    *buffer;
+	acpi_status                     status;
+	union acpi_operand_object       *buffer_desc;
+	acpi_size                       length;
+	void                            *buffer;
+	u8                              locked;
 
 
-	FUNCTION_TRACE_PTR ("Ex_read_data_from_field", obj_desc);
+	ACPI_FUNCTION_TRACE_PTR ("ex_read_data_from_field", obj_desc);
 
 
 	/* Parameter validation */
@@ -72,6 +88,44 @@ acpi_ex_read_data_from_field (
 		return_ACPI_STATUS (AE_AML_NO_OPERAND);
 	}
 
+	if (ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_BUFFER_FIELD) {
+		/*
+		 * If the buffer_field arguments have not been previously evaluated,
+		 * evaluate them now and save the results.
+		 */
+		if (!(obj_desc->common.flags & AOPOBJ_DATA_VALID)) {
+			status = acpi_ds_get_buffer_field_arguments (obj_desc);
+			if (ACPI_FAILURE (status)) {
+				return_ACPI_STATUS (status);
+			}
+		}
+	}
+	else if ((ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_LOCAL_REGION_FIELD) &&
+			 (obj_desc->field.region_obj->region.space_id == ACPI_ADR_SPACE_SMBUS)) {
+		/*
+		 * This is an SMBus read.  We must create a buffer to hold the data
+		 * and directly access the region handler.
+		 */
+		buffer_desc = acpi_ut_create_buffer_object (ACPI_SMBUS_BUFFER_SIZE);
+		if (!buffer_desc) {
+			return_ACPI_STATUS (AE_NO_MEMORY);
+		}
+
+		/* Lock entire transaction if requested */
+
+		locked = acpi_ex_acquire_global_lock (obj_desc->common_field.field_flags);
+
+		/*
+		 * Perform the read.
+		 * Note: Smbus protocol value is passed in upper 16-bits of Function
+		 */
+		status = acpi_ex_access_region (obj_desc, 0,
+				  ACPI_CAST_PTR (acpi_integer, buffer_desc->buffer.pointer),
+				  ACPI_READ | (obj_desc->field.attribute << 16));
+		acpi_ex_release_global_lock (locked);
+		goto exit;
+	}
+
 	/*
 	 * Allocate a buffer for the contents of the field.
 	 *
@@ -82,28 +136,16 @@ acpi_ex_read_data_from_field (
 	 *
 	 * Note: Field.length is in bits.
 	 */
-	length = ROUND_BITS_UP_TO_BYTES (obj_desc->field.bit_length);
-
-	if (length > sizeof (acpi_integer)) {
+	length = (acpi_size) ACPI_ROUND_BITS_UP_TO_BYTES (obj_desc->field.bit_length);
+	if (length > acpi_gbl_integer_byte_width) {
 		/* Field is too large for an Integer, create a Buffer instead */
 
-		buffer_desc = acpi_ut_create_internal_object (ACPI_TYPE_BUFFER);
+		buffer_desc = acpi_ut_create_buffer_object (length);
 		if (!buffer_desc) {
 			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
-
-		/* Create the actual read buffer */
-
-		buffer_desc->buffer.pointer = ACPI_MEM_CALLOCATE (length);
-		if (!buffer_desc->buffer.pointer) {
-			acpi_ut_remove_reference (buffer_desc);
-			return_ACPI_STATUS (AE_NO_MEMORY);
-		}
-
-		buffer_desc->buffer.length = length;
 		buffer = buffer_desc->buffer.pointer;
 	}
-
 	else {
 		/* Field will fit within an Integer (normal case) */
 
@@ -112,39 +154,34 @@ acpi_ex_read_data_from_field (
 			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
 
-		length = sizeof (buffer_desc->integer.value);
+		length = acpi_gbl_integer_byte_width;
+		buffer_desc->integer.value = 0;
 		buffer = &buffer_desc->integer.value;
 	}
 
+	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
+		"Obj=%p Type=%X Buf=%p Len=%X\n",
+		obj_desc, ACPI_GET_OBJECT_TYPE (obj_desc), buffer, (u32) length));
+	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
+		"field_write: bit_len=%X bit_off=%X byte_off=%X\n",
+		obj_desc->common_field.bit_length,
+		obj_desc->common_field.start_field_bit_offset,
+		obj_desc->common_field.base_byte_offset));
 
-	/* Read from the appropriate field */
-
-	switch (obj_desc->common.type) {
-	case ACPI_TYPE_BUFFER_FIELD:
-		status = acpi_ex_access_buffer_field (ACPI_READ, obj_desc, buffer, length);
-		break;
-
-	case INTERNAL_TYPE_REGION_FIELD:
-		status = acpi_ex_access_region_field (ACPI_READ, obj_desc, buffer, length);
-		break;
+	/* Lock entire transaction if requested */
 
-	case INTERNAL_TYPE_BANK_FIELD:
-		status = acpi_ex_access_bank_field (ACPI_READ, obj_desc, buffer, length);
-		break;
+	locked = acpi_ex_acquire_global_lock (obj_desc->common_field.field_flags);
 
-	case INTERNAL_TYPE_INDEX_FIELD:
-		status = acpi_ex_access_index_field (ACPI_READ, obj_desc, buffer, length);
-		break;
+	/* Read from the field */
 
-	default:
-		status = AE_AML_INTERNAL;
-	}
+	status = acpi_ex_extract_from_field (obj_desc, buffer, (u32) length);
+	acpi_ex_release_global_lock (locked);
 
 
+exit:
 	if (ACPI_FAILURE (status)) {
 		acpi_ut_remove_reference (buffer_desc);
 	}
-
 	else if (ret_buffer_desc) {
 		*ret_buffer_desc = buffer_desc;
 	}
@@ -155,31 +192,33 @@ acpi_ex_read_data_from_field (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_write_data_to_field
+ * FUNCTION:    acpi_ex_write_data_to_field
  *
- * PARAMETERS:  Mode                - ACPI_READ or ACPI_WRITE
- *              *Field_node         - Parent node for field to be accessed
- *              *Buffer             - Value(s) to be read or written
- *              Buffer_length       - Number of bytes to transfer
+ * PARAMETERS:  source_desc         - Contains data to write
+ *              obj_desc            - The named field
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Read or write a named field
+ * DESCRIPTION: Write to a named field
  *
  ******************************************************************************/
 
-
 acpi_status
 acpi_ex_write_data_to_field (
-	acpi_operand_object     *source_desc,
-	acpi_operand_object     *obj_desc)
+	union acpi_operand_object       *source_desc,
+	union acpi_operand_object       *obj_desc,
+	union acpi_operand_object       **result_desc)
 {
-	acpi_status             status;
-	u32                     length;
-	void                    *buffer;
+	acpi_status                     status;
+	u32                             length;
+	u32                             required_length;
+	void                            *buffer;
+	void                            *new_buffer;
+	u8                              locked;
+	union acpi_operand_object       *buffer_desc;
 
 
-	FUNCTION_TRACE_PTR ("Ex_write_data_to_field", obj_desc);
+	ACPI_FUNCTION_TRACE_PTR ("ex_write_data_to_field", obj_desc);
 
 
 	/* Parameter validation */
@@ -188,11 +227,67 @@ acpi_ex_write_data_to_field (
 		return_ACPI_STATUS (AE_AML_NO_OPERAND);
 	}
 
+	if (ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_BUFFER_FIELD) {
+		/*
+		 * If the buffer_field arguments have not been previously evaluated,
+		 * evaluate them now and save the results.
+		 */
+		if (!(obj_desc->common.flags & AOPOBJ_DATA_VALID)) {
+			status = acpi_ds_get_buffer_field_arguments (obj_desc);
+			if (ACPI_FAILURE (status)) {
+				return_ACPI_STATUS (status);
+			}
+		}
+	}
+	else if ((ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_LOCAL_REGION_FIELD) &&
+			 (obj_desc->field.region_obj->region.space_id == ACPI_ADR_SPACE_SMBUS)) {
+		/*
+		 * This is an SMBus write.  We will bypass the entire field mechanism
+		 * and handoff the buffer directly to the handler.
+		 *
+		 * Source must be a buffer of sufficient size (ACPI_SMBUS_BUFFER_SIZE).
+		 */
+		if (ACPI_GET_OBJECT_TYPE (source_desc) != ACPI_TYPE_BUFFER) {
+			ACPI_REPORT_ERROR (("SMBus write requires Buffer, found type %s\n",
+				acpi_ut_get_object_type_name (source_desc)));
+			return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
+		}
+
+		if (source_desc->buffer.length < ACPI_SMBUS_BUFFER_SIZE) {
+			ACPI_REPORT_ERROR (("SMBus write requires Buffer of length %X, found length %X\n",
+				ACPI_SMBUS_BUFFER_SIZE, source_desc->buffer.length));
+			return_ACPI_STATUS (AE_AML_BUFFER_LIMIT);
+		}
+
+		buffer_desc = acpi_ut_create_buffer_object (ACPI_SMBUS_BUFFER_SIZE);
+		if (!buffer_desc) {
+			return_ACPI_STATUS (AE_NO_MEMORY);
+		}
+
+		buffer = buffer_desc->buffer.pointer;
+		ACPI_MEMCPY (buffer, source_desc->buffer.pointer, ACPI_SMBUS_BUFFER_SIZE);
+
+		/* Lock entire transaction if requested */
+
+		locked = acpi_ex_acquire_global_lock (obj_desc->common_field.field_flags);
+
+		/*
+		 * Perform the write (returns status and perhaps data in the same buffer)
+		 * Note: SMBus protocol type is passed in upper 16-bits of Function.
+		 */
+		status = acpi_ex_access_region (obj_desc, 0,
+				  (acpi_integer *) buffer,
+				  ACPI_WRITE | (obj_desc->field.attribute << 16));
+		acpi_ex_release_global_lock (locked);
+
+		*result_desc = buffer_desc;
+		return_ACPI_STATUS (status);
+	}
 
 	/*
 	 * Get a pointer to the data to be written
 	 */
-	switch (source_desc->common.type) {
+	switch (ACPI_GET_OBJECT_TYPE (source_desc)) {
 	case ACPI_TYPE_INTEGER:
 		buffer = &source_desc->integer.value;
 		length = sizeof (source_desc->integer.value);
@@ -212,315 +307,58 @@ acpi_ex_write_data_to_field (
 		return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 	}
 
-
 	/*
-	 * Decode the type of field to be written
+	 * We must have a buffer that is at least as long as the field
+	 * we are writing to.  This is because individual fields are
+	 * indivisible and partial writes are not supported -- as per
+	 * the ACPI specification.
 	 */
-	switch (obj_desc->common.type) {
-	case ACPI_TYPE_BUFFER_FIELD:
-		status = acpi_ex_access_buffer_field (ACPI_WRITE, obj_desc, buffer, length);
-		break;
-
-	case INTERNAL_TYPE_REGION_FIELD:
-		status = acpi_ex_access_region_field (ACPI_WRITE, obj_desc, buffer, length);
-		break;
-
-	case INTERNAL_TYPE_BANK_FIELD:
-		status = acpi_ex_access_bank_field (ACPI_WRITE, obj_desc, buffer, length);
-		break;
-
-	case INTERNAL_TYPE_INDEX_FIELD:
-		status = acpi_ex_access_index_field (ACPI_WRITE, obj_desc, buffer, length);
-		break;
-
-	default:
-		return_ACPI_STATUS (AE_AML_INTERNAL);
-	}
-
-
-	return_ACPI_STATUS (status);
-}
+	new_buffer = NULL;
+	required_length = ACPI_ROUND_BITS_UP_TO_BYTES (obj_desc->common_field.bit_length);
 
+	if (length < required_length) {
+		/* We need to create a new buffer */
 
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ex_access_buffer_field
- *
- * PARAMETERS:  Mode                - ACPI_READ or ACPI_WRITE
- *              *Field_node         - Parent node for field to be accessed
- *              *Buffer             - Value(s) to be read or written
- *              Buffer_length       - Number of bytes to transfer
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Read or write a named field
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ex_access_buffer_field (
-	u32                     mode,
-	acpi_operand_object     *obj_desc,
-	void                    *buffer,
-	u32                     buffer_length)
-{
-	acpi_status             status;
-
-
-	FUNCTION_TRACE_PTR ("Ex_access_buffer_field", obj_desc);
-
-
-	/*
-	 * If the Buffer_field arguments have not been previously evaluated,
-	 * evaluate them now and save the results.
-	 */
-	if (!(obj_desc->common.flags & AOPOBJ_DATA_VALID)) {
-		status = acpi_ds_get_buffer_field_arguments (obj_desc);
-		if (ACPI_FAILURE (status)) {
-			return_ACPI_STATUS (status);
+		new_buffer = ACPI_MEM_CALLOCATE (required_length);
+		if (!new_buffer) {
+			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
-	}
-
-
-	status = acpi_ex_common_access_field (mode, obj_desc, buffer, buffer_length);
-
-	return_ACPI_STATUS (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ex_access_region_field
- *
- * PARAMETERS:  Mode                - ACPI_READ or ACPI_WRITE
- *              *Field_node         - Parent node for field to be accessed
- *              *Buffer             - Value(s) to be read or written
- *              Buffer_length       - Number of bytes to transfer
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Read or write a named field
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ex_access_region_field (
-	u32                     mode,
-	acpi_operand_object     *obj_desc,
-	void                    *buffer,
-	u32                     buffer_length)
-{
-	acpi_status             status;
-	u8                      locked;
-
-
-	FUNCTION_TRACE_PTR ("Ex_access_region_field", obj_desc);
-
-
-	/*
-	 * Get the global lock if needed
-	 */
-	locked = acpi_ex_acquire_global_lock (obj_desc->field.lock_rule);
-
-	status = acpi_ex_common_access_field (mode, obj_desc, buffer, buffer_length);
 
-
-	/*
-	 * Release global lock if we acquired it earlier
-	 */
-	acpi_ex_release_global_lock (locked);
-
-	return_ACPI_STATUS (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ex_access_bank_field
- *
- * PARAMETERS:  Mode                - ACPI_READ or ACPI_WRITE
- *              *Field_node         - Parent node for field to be accessed
- *              *Buffer             - Value(s) to be read or written
- *              Buffer_length       - Number of bytes to transfer
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Read or write a Bank Field
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ex_access_bank_field (
-	u32                     mode,
-	acpi_operand_object     *obj_desc,
-	void                    *buffer,
-	u32                     buffer_length)
-{
-	acpi_status             status;
-	u8                      locked;
-
-
-	FUNCTION_TRACE_PTR ("Ex_access_bank_field", obj_desc);
-
-
-	/*
-	 * Get the global lock if needed
-	 */
-	locked = acpi_ex_acquire_global_lock (obj_desc->bank_field.lock_rule);
-
-
-	/*
-	 * Write the Bank_value to the Bank_register to select the bank.
-	 * The Bank_value for this Bank_field is specified in the
-	 * Bank_field ASL declaration. The Bank_register is always a Field in
-	 * an operation region.
-	 */
-	status = acpi_ex_common_access_field (ACPI_WRITE,
-			 obj_desc->bank_field.bank_register_obj,
-			 &obj_desc->bank_field.value,
-			 sizeof (obj_desc->bank_field.value));
-	if (ACPI_FAILURE (status)) {
-		goto cleanup;
-	}
-
-	/*
-	 * The bank was successfully selected, now read or write the actual
-	 * data.
-	 */
-	status = acpi_ex_common_access_field (mode, obj_desc, buffer, buffer_length);
-
-
-cleanup:
-	/*
-	 * Release global lock if we acquired it earlier
-	 */
-	acpi_ex_release_global_lock (locked);
-
-	return_ACPI_STATUS (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ex_access_index_field
- *
- * PARAMETERS:  Mode                - ACPI_READ or ACPI_WRITE
- *              *Field_node         - Parent node for field to be accessed
- *              *Buffer             - Value(s) to be read or written
- *              Buffer_length       - Number of bytes to transfer
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Read or write a Index Field
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ex_access_index_field (
-	u32                     mode,
-	acpi_operand_object     *obj_desc,
-	void                    *buffer,
-	u32                     buffer_length)
-{
-	acpi_status             status;
-	u8                      locked;
-
-
-	FUNCTION_TRACE_PTR ("Ex_access_index_field", obj_desc);
-
-
-	/*
-	 * Get the global lock if needed
-	 */
-	locked = acpi_ex_acquire_global_lock (obj_desc->index_field.lock_rule);
-
-
-	/*
-	 * Set Index value to select proper Data register
-	 */
-	status = acpi_ex_common_access_field (ACPI_WRITE,
-			 obj_desc->index_field.index_obj,
-			 &obj_desc->index_field.value,
-			 sizeof (obj_desc->index_field.value));
-	if (ACPI_FAILURE (status)) {
-		goto cleanup;
-	}
-
-	/* Now read/write the data register */
-
-	status = acpi_ex_common_access_field (mode, obj_desc->index_field.data_obj,
-			  buffer, buffer_length);
-
-cleanup:
-	/*
-	 * Release global lock if we acquired it earlier
-	 */
-	acpi_ex_release_global_lock (locked);
-
-	return_ACPI_STATUS (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ex_common_access_field
- *
- * PARAMETERS:  Mode                - ACPI_READ or ACPI_WRITE
- *              *Field_node         - Parent node for field to be accessed
- *              *Buffer             - Value(s) to be read or written
- *              Buffer_length       - Size of buffer, in bytes.  Must be large
- *                                    enough for all bits of the field.
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Read or write a named field
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ex_common_access_field (
-	u32                     mode,
-	acpi_operand_object     *obj_desc,
-	void                    *buffer,
-	u32                     buffer_length)
-{
-	acpi_status             status;
-
-
-	FUNCTION_TRACE_PTR ("Ex_common_access_field", obj_desc);
-
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Obj=%p Type=%X Buf=%p Len=%X\n",
-		obj_desc, obj_desc->common.type, buffer, buffer_length));
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Mode=%d Bit_len=%X Bit_off=%X Byte_off=%X\n",
-		mode, obj_desc->common_field.bit_length,
+		/*
+		 * Copy the original data to the new buffer, starting
+		 * at Byte zero.  All unused (upper) bytes of the
+		 * buffer will be 0.
+		 */
+		ACPI_MEMCPY ((char *) new_buffer, (char *) buffer, length);
+		buffer = new_buffer;
+		length = required_length;
+	}
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
+		"Obj=%p Type=%X Buf=%p Len=%X\n",
+		obj_desc, ACPI_GET_OBJECT_TYPE (obj_desc), buffer, length));
+	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
+		"field_read: bit_len=%X bit_off=%X byte_off=%X\n",
+		obj_desc->common_field.bit_length,
 		obj_desc->common_field.start_field_bit_offset,
 		obj_desc->common_field.base_byte_offset));
 
+	/* Lock entire transaction if requested */
 
-	/* Perform the actual read or write of the field */
+	locked = acpi_ex_acquire_global_lock (obj_desc->common_field.field_flags);
 
-	switch (mode) {
-	case ACPI_READ:
-
-		status = acpi_ex_extract_from_field (obj_desc, buffer, buffer_length);
-		break;
-
-
-	case ACPI_WRITE:
-
-		status = acpi_ex_insert_into_field (obj_desc, buffer, buffer_length);
-		break;
+	/* Write to the field */
 
+	status = acpi_ex_insert_into_field (obj_desc, buffer, length);
+	acpi_ex_release_global_lock (locked);
 
-	default:
+	/* Free temporary buffer if we used one */
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown I/O Mode: %X\n", mode));
-		status = AE_BAD_PARAMETER;
-		break;
+	if (new_buffer) {
+		ACPI_MEM_FREE (new_buffer);
 	}
 
-
 	return_ACPI_STATUS (status);
 }
 
+
diff -urNp linux-5400/drivers/acpi/executer/exfldio.c linux-5410/drivers/acpi/executer/exfldio.c
--- linux-5400/drivers/acpi/executer/exfldio.c
+++ linux-5410/drivers/acpi/executer/exfldio.c
@@ -1,73 +1,94 @@
 /******************************************************************************
  *
  * Module Name: exfldio - Aml Field I/O
- *              $Revision: 66 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acinterp.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "achware.h"
-#include "acevents.h"
-#include "acdispat.h"
+#include <acpi/acpi.h>
+#include <acpi/acinterp.h>
+#include <acpi/amlcode.h>
+#include <acpi/acevents.h>
+#include <acpi/acdispat.h>
 
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("exfldio")
+	 ACPI_MODULE_NAME    ("exfldio")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_setup_field
+ * FUNCTION:    acpi_ex_setup_region
  *
- * PARAMETERS:  *Obj_desc           - Field to be read or written
- *              Field_datum_byte_offset  - Current offset into the field
+ * PARAMETERS:  *obj_desc               - Field to be read or written
+ *              field_datum_byte_offset - Byte offset of this datum within the
+ *                                        parent field
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Common processing for Acpi_ex_extract_from_field and
- *              Acpi_ex_insert_into_field
+ * DESCRIPTION: Common processing for acpi_ex_extract_from_field and
+ *              acpi_ex_insert_into_field. Initialize the
  *
  ******************************************************************************/
 
 acpi_status
-acpi_ex_setup_field (
-	acpi_operand_object     *obj_desc,
-	u32                     field_datum_byte_offset)
+acpi_ex_setup_region (
+	union acpi_operand_object       *obj_desc,
+	u32                             field_datum_byte_offset)
 {
-	acpi_status             status = AE_OK;
-	acpi_operand_object     *rgn_desc;
+	acpi_status                     status = AE_OK;
+	union acpi_operand_object       *rgn_desc;
 
 
-	FUNCTION_TRACE_U32 ("Ex_setup_field", field_datum_byte_offset);
+	ACPI_FUNCTION_TRACE_U32 ("ex_setup_region", field_datum_byte_offset);
 
 
 	rgn_desc = obj_desc->common_field.region_obj;
 
-	if (ACPI_TYPE_REGION != rgn_desc->common.type) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Needed Region, found type %x %s\n",
-			rgn_desc->common.type, acpi_ut_get_type_name (rgn_desc->common.type)));
+	/* We must have a valid region */
+
+	if (ACPI_GET_OBJECT_TYPE (rgn_desc) != ACPI_TYPE_REGION) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Needed Region, found type %X (%s)\n",
+			ACPI_GET_OBJECT_TYPE (rgn_desc),
+			acpi_ut_get_object_type_name (rgn_desc)));
+
 		return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 	}
 
@@ -76,30 +97,36 @@ acpi_ex_setup_field (
 	 * evaluate them now and save the results.
 	 */
 	if (!(rgn_desc->region.flags & AOPOBJ_DATA_VALID)) {
-
 		status = acpi_ds_get_region_arguments (rgn_desc);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
 	}
 
+	if (rgn_desc->region.space_id == ACPI_ADR_SPACE_SMBUS) {
+		/* SMBus has a non-linear address space */
+
+		return_ACPI_STATUS (AE_OK);
+	}
+
 	/*
 	 * Validate the request.  The entire request from the byte offset for a
 	 * length of one field datum (access width) must fit within the region.
 	 * (Region length is specified in bytes)
 	 */
-	if (rgn_desc->region.length < (obj_desc->common_field.base_byte_offset +
-			   field_datum_byte_offset +
-			   obj_desc->common_field.access_byte_width)) {
+	if (rgn_desc->region.length < (obj_desc->common_field.base_byte_offset
+			   + field_datum_byte_offset
+			   + obj_desc->common_field.access_byte_width)) {
 		if (rgn_desc->region.length < obj_desc->common_field.access_byte_width) {
 			/*
-			 * This is the case where the Access_type (Acc_word, etc.) is wider
+			 * This is the case where the access_type (acc_word, etc.) is wider
 			 * than the region itself.  For example, a region of length one
 			 * byte, and a field with Dword access specified.
 			 */
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Field access width (%d bytes) too large for region size (%X)\n",
-				obj_desc->common_field.access_byte_width, rgn_desc->region.length));
+				"Field [%4.4s] access width (%d bytes) too large for region [%4.4s] (length %X)\n",
+				obj_desc->common_field.node->name.ascii, obj_desc->common_field.access_byte_width,
+				rgn_desc->region.node->name.ascii, rgn_desc->region.length));
 		}
 
 		/*
@@ -107,10 +134,10 @@ acpi_ex_setup_field (
 		 * exceeds region length, indicate an error
 		 */
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Field base+offset+width %X+%X+%X exceeds region size (%X bytes) field=%p region=%p\n",
-			obj_desc->common_field.base_byte_offset, field_datum_byte_offset,
-			obj_desc->common_field.access_byte_width,
-			rgn_desc->region.length, obj_desc, rgn_desc));
+			"Field [%4.4s] Base+Offset+Width %X+%X+%X is beyond end of region [%4.4s] (length %X)\n",
+			obj_desc->common_field.node->name.ascii, obj_desc->common_field.base_byte_offset,
+			field_datum_byte_offset, obj_desc->common_field.access_byte_width,
+			rgn_desc->region.node->name.ascii, rgn_desc->region.length));
 
 		return_ACPI_STATUS (AE_AML_REGION_LIMIT);
 	}
@@ -121,116 +148,415 @@ acpi_ex_setup_field (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_read_field_datum
+ * FUNCTION:    acpi_ex_access_region
  *
- * PARAMETERS:  *Obj_desc           - Field to be read
- *              *Value              - Where to store value (must be 32 bits)
+ * PARAMETERS:  *obj_desc               - Field to be read
+ *              field_datum_byte_offset - Byte offset of this datum within the
+ *                                        parent field
+ *              *Value                  - Where to store value (must at least
+ *                                        the size of acpi_integer)
+ *              Function                - Read or Write flag plus other region-
+ *                                        dependent flags
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Retrieve the value of the given field
+ * DESCRIPTION: Read or Write a single field datum to an Operation Region.
  *
  ******************************************************************************/
 
 acpi_status
-acpi_ex_read_field_datum (
-	acpi_operand_object     *obj_desc,
-	u32                     field_datum_byte_offset,
-	u32                     *value)
+acpi_ex_access_region (
+	union acpi_operand_object       *obj_desc,
+	u32                             field_datum_byte_offset,
+	acpi_integer                    *value,
+	u32                             function)
 {
-	acpi_status             status;
-	acpi_operand_object     *rgn_desc;
-	ACPI_PHYSICAL_ADDRESS   address;
-	u32                     local_value;
+	acpi_status                     status;
+	union acpi_operand_object       *rgn_desc;
+	acpi_physical_address           address;
+
+
+	ACPI_FUNCTION_TRACE ("ex_access_region");
+
+
+	/*
+	 * Ensure that the region operands are fully evaluated and verify
+	 * the validity of the request
+	 */
+	status = acpi_ex_setup_region (obj_desc, field_datum_byte_offset);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/*
+	 * The physical address of this field datum is:
+	 *
+	 * 1) The base of the region, plus
+	 * 2) The base offset of the field, plus
+	 * 3) The current offset into the field
+	 */
+	rgn_desc = obj_desc->common_field.region_obj;
+	address = rgn_desc->region.address
+			 + obj_desc->common_field.base_byte_offset
+			 + field_datum_byte_offset;
+
+	if ((function & ACPI_IO_MASK) == ACPI_READ) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD, "[READ]"));
+	}
+	else {
+		ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD, "[WRITE]"));
+	}
+
+	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_BFIELD,
+		" Region[%s-%X] Access %X Base:Off %X:%X at %8.8X%8.8X\n",
+		acpi_ut_get_region_name (rgn_desc->region.space_id),
+		rgn_desc->region.space_id,
+		obj_desc->common_field.access_byte_width,
+		obj_desc->common_field.base_byte_offset,
+		field_datum_byte_offset,
+		ACPI_HIDWORD (address), ACPI_LODWORD (address)));
+
+	/* Invoke the appropriate address_space/op_region handler */
+
+	status = acpi_ev_address_space_dispatch (rgn_desc, function,
+			  address, ACPI_MUL_8 (obj_desc->common_field.access_byte_width), value);
+
+	if (ACPI_FAILURE (status)) {
+		if (status == AE_NOT_IMPLEMENTED) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Region %s(%X) not implemented\n",
+				acpi_ut_get_region_name (rgn_desc->region.space_id),
+				rgn_desc->region.space_id));
+		}
+		else if (status == AE_NOT_EXIST) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Region %s(%X) has no handler\n",
+				acpi_ut_get_region_name (rgn_desc->region.space_id),
+				rgn_desc->region.space_id));
+		}
+	}
+
+	return_ACPI_STATUS (status);
+}
+
 
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_register_overflow
+ *
+ * PARAMETERS:  *obj_desc               - Register(Field) to be written
+ *              Value                   - Value to be stored
+ *
+ * RETURN:      TRUE if value overflows the field, FALSE otherwise
+ *
+ * DESCRIPTION: Check if a value is out of range of the field being written.
+ *              Used to check if the values written to Index and Bank registers
+ *              are out of range.  Normally, the value is simply truncated
+ *              to fit the field, but this case is most likely a serious
+ *              coding error in the ASL.
+ *
+ ******************************************************************************/
 
-	FUNCTION_TRACE_U32 ("Ex_read_field_datum", field_datum_byte_offset);
+u8
+acpi_ex_register_overflow (
+	union acpi_operand_object       *obj_desc,
+	acpi_integer                    value)
+{
 
+	if (obj_desc->common_field.bit_length >= ACPI_INTEGER_BIT_SIZE) {
+		/*
+		 * The field is large enough to hold the maximum integer, so we can
+		 * never overflow it.
+		 */
+		return (FALSE);
+	}
 
-	if (!value) {
-		local_value = 0;
-		value = &local_value;   /*  support reads without saving value  */
+	if (value >= ((acpi_integer) 1 << obj_desc->common_field.bit_length)) {
+		/*
+		 * The Value is larger than the maximum value that can fit into
+		 * the register.
+		 */
+		return (TRUE);
 	}
 
-	/* Clear the entire return buffer first, [Very Important!] */
+	/* The Value will fit into the field with no truncation */
+
+	return (FALSE);
+}
 
-	*value = 0;
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_field_datum_io
+ *
+ * PARAMETERS:  *obj_desc               - Field to be read
+ *              field_datum_byte_offset - Byte offset of this datum within the
+ *                                        parent field
+ *              *Value                  - Where to store value (must be 64 bits)
+ *              read_write              - Read or Write flag
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Read or Write a single datum of a field.  The field_type is
+ *              demultiplexed here to handle the different types of fields
+ *              (buffer_field, region_field, index_field, bank_field)
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_field_datum_io (
+	union acpi_operand_object       *obj_desc,
+	u32                             field_datum_byte_offset,
+	acpi_integer                    *value,
+	u32                             read_write)
+{
+	acpi_status                     status;
+	acpi_integer                    local_value;
+
+
+	ACPI_FUNCTION_TRACE_U32 ("ex_field_datum_io", field_datum_byte_offset);
+
+
+	if (read_write == ACPI_READ) {
+		if (!value) {
+			local_value = 0;
+			value = &local_value; /* To support reads without saving return value */
+		}
+
+		/* Clear the entire return buffer first, [Very Important!] */
+
+		*value = 0;
+	}
 
 	/*
-	 * Buffer_fields - Read from a Buffer
-	 * Other Fields - Read from a Operation Region.
+	 * The four types of fields are:
+	 *
+	 * buffer_fields - Read/write from/to a Buffer
+	 * region_fields - Read/write from/to a Operation Region.
+	 * bank_fields  - Write to a Bank Register, then read/write from/to an op_region
+	 * index_fields - Write to an Index Register, then read/write from/to a Data Register
 	 */
-	switch (obj_desc->common.type) {
+	switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
 	case ACPI_TYPE_BUFFER_FIELD:
-
 		/*
-		 * For Buffer_fields, we only need to copy the data from the
-		 * source buffer.  Length is the field width in bytes.
+		 * If the buffer_field arguments have not been previously evaluated,
+		 * evaluate them now and save the results.
 		 */
-		MEMCPY (value, (obj_desc->buffer_field.buffer_obj)->buffer.pointer
-				  + obj_desc->buffer_field.base_byte_offset + field_datum_byte_offset,
-				  obj_desc->common_field.access_byte_width);
+		if (!(obj_desc->common.flags & AOPOBJ_DATA_VALID)) {
+			status = acpi_ds_get_buffer_field_arguments (obj_desc);
+			if (ACPI_FAILURE (status)) {
+				return_ACPI_STATUS (status);
+			}
+		}
+
+		if (read_write == ACPI_READ) {
+			/*
+			 * Copy the data from the source buffer.
+			 * Length is the field width in bytes.
+			 */
+			ACPI_MEMCPY (value, (obj_desc->buffer_field.buffer_obj)->buffer.pointer
+					  + obj_desc->buffer_field.base_byte_offset
+					  + field_datum_byte_offset,
+					  obj_desc->common_field.access_byte_width);
+		}
+		else {
+			/*
+			 * Copy the data to the target buffer.
+			 * Length is the field width in bytes.
+			 */
+			ACPI_MEMCPY ((obj_desc->buffer_field.buffer_obj)->buffer.pointer
+					+ obj_desc->buffer_field.base_byte_offset
+					+ field_datum_byte_offset,
+					value, obj_desc->common_field.access_byte_width);
+		}
+
 		status = AE_OK;
 		break;
 
 
-	case INTERNAL_TYPE_REGION_FIELD:
-	case INTERNAL_TYPE_BANK_FIELD:
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
+
+		/* Ensure that the bank_value is not beyond the capacity of the register */
+
+		if (acpi_ex_register_overflow (obj_desc->bank_field.bank_obj,
+				  (acpi_integer) obj_desc->bank_field.value)) {
+			return_ACPI_STATUS (AE_AML_REGISTER_LIMIT);
+		}
 
 		/*
-		 * For other fields, we need to go through an Operation Region
-		 * (Only types that will get here are Region_fields and Bank_fields)
+		 * For bank_fields, we must write the bank_value to the bank_register
+		 * (itself a region_field) before we can access the data.
 		 */
-		status = acpi_ex_setup_field (obj_desc, field_datum_byte_offset);
+		status = acpi_ex_insert_into_field (obj_desc->bank_field.bank_obj,
+				 &obj_desc->bank_field.value,
+				 sizeof (obj_desc->bank_field.value));
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
 
 		/*
-		 * The physical address of this field datum is:
-		 *
-		 * 1) The base of the region, plus
-		 * 2) The base offset of the field, plus
-		 * 3) The current offset into the field
-		 */
-		rgn_desc = obj_desc->common_field.region_obj;
-		address = rgn_desc->region.address + obj_desc->common_field.base_byte_offset +
-				 field_datum_byte_offset;
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD, "Region %s(%X) width %X base:off %X:%X at %8.8X%8.8X\n",
-			acpi_ut_get_region_name (rgn_desc->region.space_id),
-			rgn_desc->region.space_id, obj_desc->common_field.access_bit_width,
-			obj_desc->common_field.base_byte_offset, field_datum_byte_offset,
-			HIDWORD(address), LODWORD(address)));
+		 * Now that the Bank has been selected, fall through to the
+		 * region_field case and write the datum to the Operation Region
+		 */
 
-		/* Invoke the appropriate Address_space/Op_region handler */
+		/*lint -fallthrough */
 
-		status = acpi_ev_address_space_dispatch (rgn_desc, ACPI_READ_ADR_SPACE,
-				  address, obj_desc->common_field.access_bit_width, value);
-		if (status == AE_NOT_IMPLEMENTED) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Region %s(%X) not implemented\n",
-				acpi_ut_get_region_name (rgn_desc->region.space_id),
-				rgn_desc->region.space_id));
+
+	case ACPI_TYPE_LOCAL_REGION_FIELD:
+		/*
+		 * For simple region_fields, we just directly access the owning
+		 * Operation Region.
+		 */
+		status = acpi_ex_access_region (obj_desc, field_datum_byte_offset, value,
+				  read_write);
+		break;
+
+
+	case ACPI_TYPE_LOCAL_INDEX_FIELD:
+
+
+		/* Ensure that the index_value is not beyond the capacity of the register */
+
+		if (acpi_ex_register_overflow (obj_desc->index_field.index_obj,
+				  (acpi_integer) obj_desc->index_field.value)) {
+			return_ACPI_STATUS (AE_AML_REGISTER_LIMIT);
 		}
 
-		else if (status == AE_NOT_EXIST) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Region %s(%X) has no handler\n",
-				acpi_ut_get_region_name (rgn_desc->region.space_id),
-				rgn_desc->region.space_id));
+		/* Write the index value to the index_register (itself a region_field) */
+
+		status = acpi_ex_insert_into_field (obj_desc->index_field.index_obj,
+				 &obj_desc->index_field.value,
+				 sizeof (obj_desc->index_field.value));
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
+
+		if (read_write == ACPI_READ) {
+			/* Read the datum from the data_register */
+
+			status = acpi_ex_extract_from_field (obj_desc->index_field.data_obj,
+					  value, obj_desc->common_field.access_byte_width);
+		}
+		else {
+			/* Write the datum to the Data register */
+
+			status = acpi_ex_insert_into_field (obj_desc->index_field.data_obj,
+					  value, obj_desc->common_field.access_byte_width);
 		}
 		break;
 
 
 	default:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "%p, wrong source type - %s\n",
-			obj_desc, acpi_ut_get_type_name (obj_desc->common.type)));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "%p, Wrong object type - %s\n",
+			obj_desc, acpi_ut_get_object_type_name (obj_desc)));
 		status = AE_AML_INTERNAL;
 		break;
 	}
 
+	if (ACPI_SUCCESS (status)) {
+		if (read_write == ACPI_READ) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD, "Value Read=%8.8X%8.8X\n",
+					   ACPI_HIDWORD (*value), ACPI_LODWORD (*value)));
+		}
+		else {
+			ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD, "Value Written=%8.8X%8.8X\n",
+					   ACPI_HIDWORD (*value), ACPI_LODWORD (*value)));
+		}
+	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD, "Returned value=%08X \n", *value));
+	return_ACPI_STATUS (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_write_with_update_rule
+ *
+ * PARAMETERS:  *obj_desc           - Field to be set
+ *              Value               - Value to store
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Apply the field update rule to a field write
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_write_with_update_rule (
+	union acpi_operand_object       *obj_desc,
+	acpi_integer                    mask,
+	acpi_integer                    field_value,
+	u32                             field_datum_byte_offset)
+{
+	acpi_status                     status = AE_OK;
+	acpi_integer                    merged_value;
+	acpi_integer                    current_value;
+
+
+	ACPI_FUNCTION_TRACE_U32 ("ex_write_with_update_rule", mask);
+
+
+	/* Start with the new bits  */
+
+	merged_value = field_value;
+
+	/* If the mask is all ones, we don't need to worry about the update rule */
+
+	if (mask != ACPI_INTEGER_MAX) {
+		/* Decode the update rule */
+
+		switch (obj_desc->common_field.field_flags & AML_FIELD_UPDATE_RULE_MASK) {
+		case AML_FIELD_UPDATE_PRESERVE:
+			/*
+			 * Check if update rule needs to be applied (not if mask is all
+			 * ones)  The left shift drops the bits we want to ignore.
+			 */
+			if ((~mask << (ACPI_MUL_8 (sizeof (mask)) -
+					 ACPI_MUL_8 (obj_desc->common_field.access_byte_width))) != 0) {
+				/*
+				 * Read the current contents of the byte/word/dword containing
+				 * the field, and merge with the new field value.
+				 */
+				status = acpi_ex_field_datum_io (obj_desc, field_datum_byte_offset,
+						  &current_value, ACPI_READ);
+				merged_value |= (current_value & ~mask);
+			}
+			break;
+
+		case AML_FIELD_UPDATE_WRITE_AS_ONES:
+
+			/* Set positions outside the field to all ones */
+
+			merged_value |= ~mask;
+			break;
+
+		case AML_FIELD_UPDATE_WRITE_AS_ZEROS:
+
+			/* Set positions outside the field to all zeros */
+
+			merged_value &= mask;
+			break;
+
+		default:
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"write_with_update_rule: Unknown update_rule setting: %X\n",
+				(obj_desc->common_field.field_flags & AML_FIELD_UPDATE_RULE_MASK)));
+			return_ACPI_STATUS (AE_AML_OPERAND_VALUE);
+		}
+	}
+
+	/* Write the merged value */
+
+	status = acpi_ex_field_datum_io (obj_desc, field_datum_byte_offset,
+			  &merged_value, ACPI_WRITE);
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
+		"Mask %8.8X%8.8X datum_offset %X Value %8.8X%8.8X, merged_value %8.8X%8.8X\n",
+		ACPI_HIDWORD (mask), ACPI_LODWORD (mask),
+		field_datum_byte_offset,
+		ACPI_HIDWORD (field_value), ACPI_LODWORD (field_value),
+		ACPI_HIDWORD (merged_value),ACPI_LODWORD (merged_value)));
 
 	return_ACPI_STATUS (status);
 }
@@ -238,43 +564,65 @@ acpi_ex_read_field_datum (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_get_buffer_datum
+ * FUNCTION:    acpi_ex_get_buffer_datum
  *
- * PARAMETERS:  Merged_datum        - Value to store
- *              Buffer              - Receiving buffer
- *              Byte_granularity    - 1/2/4 Granularity of the field
+ * PARAMETERS:  Datum               - Where the Datum is returned
+ *              Buffer              - Raw field buffer
+ *              buffer_length       - Entire length (used for big-endian only)
+ *              byte_granularity    - 1/2/4/8 Granularity of the field
  *                                    (aka Datum Size)
- *              Offset              - Datum offset into the buffer
+ *              buffer_offset       - Datum offset into the buffer
  *
  * RETURN:      none
  *
- * DESCRIPTION: Store the merged datum to the buffer according to the
+ * DESCRIPTION: Get a datum from the buffer according to the buffer field
  *              byte granularity
  *
  ******************************************************************************/
 
-static void
-acpi_ex_get_buffer_datum(
-	u32                     *datum,
-	void                    *buffer,
-	u32                     byte_granularity,
-	u32                     offset)
+void
+acpi_ex_get_buffer_datum (
+	acpi_integer                    *datum,
+	void                            *buffer,
+	u32                             buffer_length,
+	u32                             byte_granularity,
+	u32                             buffer_offset)
 {
+	u32                             index;
+
+
+	ACPI_FUNCTION_ENTRY ();
 
-	FUNCTION_ENTRY ();
 
+	/* Get proper index into buffer (handles big/little endian) */
+
+	index = ACPI_BUFFER_INDEX (buffer_length, buffer_offset, byte_granularity);
+
+	/* Move the requested number of bytes */
 
 	switch (byte_granularity) {
 	case ACPI_FIELD_BYTE_GRANULARITY:
-		*datum = ((u8 *) buffer) [offset];
+
+		*datum = ((u8 *) buffer) [index];
 		break;
 
 	case ACPI_FIELD_WORD_GRANULARITY:
-		MOVE_UNALIGNED16_TO_32 (datum, &(((u16 *) buffer) [offset]));
+
+		ACPI_MOVE_16_TO_64 (datum, &(((u16 *) buffer) [index]));
 		break;
 
 	case ACPI_FIELD_DWORD_GRANULARITY:
-		MOVE_UNALIGNED32_TO_32 (datum, &(((u32 *) buffer) [offset]));
+
+		ACPI_MOVE_32_TO_64 (datum, &(((u32 *) buffer) [index]));
+		break;
+
+	case ACPI_FIELD_QWORD_GRANULARITY:
+
+		ACPI_MOVE_64_TO_64 (datum, &(((u64 *) buffer) [index]));
+		break;
+
+	default:
+		/* Should not get here */
 		break;
 	}
 }
@@ -282,13 +630,14 @@ acpi_ex_get_buffer_datum(
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_set_buffer_datum
+ * FUNCTION:    acpi_ex_set_buffer_datum
  *
- * PARAMETERS:  Merged_datum        - Value to store
+ * PARAMETERS:  merged_datum        - Value to store
  *              Buffer              - Receiving buffer
- *              Byte_granularity    - 1/2/4 Granularity of the field
+ *              buffer_length       - Entire length (used for big-endian only)
+ *              byte_granularity    - 1/2/4/8 Granularity of the field
  *                                    (aka Datum Size)
- *              Offset              - Datum offset into the buffer
+ *              buffer_offset       - Datum offset into the buffer
  *
  * RETURN:      none
  *
@@ -297,28 +646,48 @@ acpi_ex_get_buffer_datum(
  *
  ******************************************************************************/
 
-static void
+void
 acpi_ex_set_buffer_datum (
-	u32                     merged_datum,
-	void                    *buffer,
-	u32                     byte_granularity,
-	u32                     offset)
+	acpi_integer                    merged_datum,
+	void                            *buffer,
+	u32                             buffer_length,
+	u32                             byte_granularity,
+	u32                             buffer_offset)
 {
+	u32                             index;
+
+	ACPI_FUNCTION_ENTRY ();
+
+
+	/* Get proper index into buffer (handles big/little endian) */
 
-	FUNCTION_ENTRY ();
+	index = ACPI_BUFFER_INDEX (buffer_length, buffer_offset, byte_granularity);
 
+	/* Move the requested number of bytes */
 
 	switch (byte_granularity) {
 	case ACPI_FIELD_BYTE_GRANULARITY:
-		((u8 *) buffer) [offset] = (u8) merged_datum;
+
+		((u8 *) buffer) [index] = (u8) merged_datum;
 		break;
 
 	case ACPI_FIELD_WORD_GRANULARITY:
-		MOVE_UNALIGNED16_TO_16 (&(((u16 *) buffer)[offset]), &merged_datum);
+
+		ACPI_MOVE_64_TO_16 (&(((u16 *) buffer)[index]), &merged_datum);
 		break;
 
 	case ACPI_FIELD_DWORD_GRANULARITY:
-		MOVE_UNALIGNED32_TO_32 (&(((u32 *) buffer)[offset]), &merged_datum);
+
+		ACPI_MOVE_64_TO_32 (&(((u32 *) buffer)[index]), &merged_datum);
+		break;
+
+	case ACPI_FIELD_QWORD_GRANULARITY:
+
+		ACPI_MOVE_64_TO_64 (&(((u64 *) buffer)[index]), &merged_datum);
+		break;
+
+	default:
+		/* Should not get here */
 		break;
 	}
 }
@@ -326,9 +695,9 @@ acpi_ex_set_buffer_datum (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_extract_from_field
+ * FUNCTION:    acpi_ex_extract_from_field
  *
- * PARAMETERS:  *Obj_desc           - Field to be read
+ * PARAMETERS:  *obj_desc           - Field to be read
  *              *Value              - Where to store value
  *
  * RETURN:      Status
@@ -339,29 +708,30 @@ acpi_ex_set_buffer_datum (
 
 acpi_status
 acpi_ex_extract_from_field (
-	acpi_operand_object     *obj_desc,
-	void                    *buffer,
-	u32                     buffer_length)
+	union acpi_operand_object       *obj_desc,
+	void                            *buffer,
+	u32                             buffer_length)
 {
-	acpi_status             status;
-	u32                     field_datum_byte_offset;
-	u32                     datum_offset;
-	u32                     previous_raw_datum;
-	u32                     this_raw_datum = 0;
-	u32                     merged_datum = 0;
-	u32                     byte_field_length;
-	u32                     datum_count;
+	acpi_status                     status;
+	u32                             field_datum_byte_offset;
+	u32                             datum_offset;
+	acpi_integer                    previous_raw_datum;
+	acpi_integer                    this_raw_datum = 0;
+	acpi_integer                    merged_datum = 0;
+	u32                             byte_field_length;
+	u32                             datum_count;
 
 
-	FUNCTION_TRACE ("Ex_extract_from_field");
+	ACPI_FUNCTION_TRACE ("ex_extract_from_field");
 
 
 	/*
 	 * The field must fit within the caller's buffer
 	 */
-	byte_field_length = ROUND_BITS_UP_TO_BYTES (obj_desc->common_field.bit_length);
+	byte_field_length = ACPI_ROUND_BITS_UP_TO_BYTES (obj_desc->common_field.bit_length);
 	if (byte_field_length > buffer_length) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Field size %X (bytes) too large for buffer (%X)\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
+			"Field size %X (bytes) too large for buffer (%X)\n",
 			byte_field_length, buffer_length));
 
 		return_ACPI_STATUS (AE_BUFFER_OVERFLOW);
@@ -369,26 +739,27 @@ acpi_ex_extract_from_field (
 
 	/* Convert field byte count to datum count, round up if necessary */
 
-	datum_count = ROUND_UP_TO (byte_field_length, obj_desc->common_field.access_byte_width);
+	datum_count = ACPI_ROUND_UP_TO (byte_field_length,
+			   obj_desc->common_field.access_byte_width);
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-		"Byte_len=%x, Datum_len=%x, Bit_gran=%x, Byte_gran=%x\n",
-		byte_field_length, datum_count, obj_desc->common_field.access_bit_width,
-		obj_desc->common_field.access_byte_width));
+	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
+		"byte_len=%X, datum_len=%X, byte_gran=%X\n",
+		byte_field_length, datum_count,obj_desc->common_field.access_byte_width));
 
 	/*
 	 * Clear the caller's buffer (the whole buffer length as given)
 	 * This is very important, especially in the cases where a byte is read,
 	 * but the buffer is really a u32 (4 bytes).
 	 */
-	MEMSET (buffer, 0, buffer_length);
+	ACPI_MEMSET (buffer, 0, buffer_length);
 
 	/* Read the first raw datum to prime the loop */
 
 	field_datum_byte_offset = 0;
 	datum_offset= 0;
 
-	status = acpi_ex_read_field_datum (obj_desc, field_datum_byte_offset, &previous_raw_datum);
+	status = acpi_ex_field_datum_io (obj_desc, field_datum_byte_offset,
+			  &previous_raw_datum, ACPI_READ);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
@@ -397,7 +768,7 @@ acpi_ex_extract_from_field (
 	/* We might actually be done if the request fits in one datum */
 
 	if ((datum_count == 1) &&
-		(obj_desc->common_field.access_flags & AFIELD_SINGLE_DATUM)) {
+		(obj_desc->common_field.flags & AOPOBJ_SINGLE_DATUM)) {
 		/* 1) Shift the valid data bits down to start at bit 0 */
 
 		merged_datum = (previous_raw_datum >> obj_desc->common_field.start_field_bit_offset);
@@ -405,13 +776,13 @@ acpi_ex_extract_from_field (
 		/* 2) Mask off any upper unused bits (bits not part of the field) */
 
 		if (obj_desc->common_field.end_buffer_valid_bits) {
-			merged_datum &= MASK_BITS_ABOVE (obj_desc->common_field.end_buffer_valid_bits);
+			merged_datum &= ACPI_MASK_BITS_ABOVE (obj_desc->common_field.end_buffer_valid_bits);
 		}
 
 		/* Store the datum to the caller buffer */
 
-		acpi_ex_set_buffer_datum (merged_datum, buffer, obj_desc->common_field.access_byte_width,
-				datum_offset);
+		acpi_ex_set_buffer_datum (merged_datum, buffer, buffer_length,
+				obj_desc->common_field.access_byte_width, datum_offset);
 
 		return_ACPI_STATUS (AE_OK);
 	}
@@ -427,17 +798,18 @@ acpi_ex_extract_from_field (
 		 * to perform a final read, since this would potentially read
 		 * past the end of the region.
 		 *
-		 * TBD: [Investigate] It may make more sense to just split the aligned
-		 * and non-aligned cases since the aligned case is so very simple,
+		 * We could just split the aligned and non-aligned cases since the
+		 * aligned case is so very simple, but this would require more code.
 		 */
-		if ((obj_desc->common_field.start_field_bit_offset != 0)  ||
+		if ((obj_desc->common_field.start_field_bit_offset != 0) ||
 			((obj_desc->common_field.start_field_bit_offset == 0) &&
 			(datum_offset < (datum_count -1)))) {
 			/*
 			 * Get the next raw datum, it contains some or all bits
 			 * of the current field datum
 			 */
-			status = acpi_ex_read_field_datum (obj_desc, field_datum_byte_offset, &this_raw_datum);
+			status = acpi_ex_field_datum_io (obj_desc, field_datum_byte_offset,
+					  &this_raw_datum, ACPI_READ);
 			if (ACPI_FAILURE (status)) {
 				return_ACPI_STATUS (status);
 			}
@@ -451,7 +823,6 @@ acpi_ex_extract_from_field (
 
 			merged_datum = previous_raw_datum;
 		}
-
 		else {
 			/*
 			 * Put together the appropriate bits of the two raw data to make a
@@ -474,7 +845,7 @@ acpi_ex_extract_from_field (
 				 */
 				if (obj_desc->common_field.end_buffer_valid_bits) {
 					merged_datum &=
-						MASK_BITS_ABOVE (obj_desc->common_field.end_buffer_valid_bits);
+						ACPI_MASK_BITS_ABOVE (obj_desc->common_field.end_buffer_valid_bits);
 				}
 			}
 		}
@@ -483,8 +854,8 @@ acpi_ex_extract_from_field (
 		 * Store the merged field datum in the caller's buffer, according to
 		 * the granularity of the field (size of each datum).
 		 */
-		acpi_ex_set_buffer_datum (merged_datum, buffer, obj_desc->common_field.access_byte_width,
-				datum_offset);
+		acpi_ex_set_buffer_datum (merged_datum, buffer, buffer_length,
+				obj_desc->common_field.access_byte_width, datum_offset);
 
 		/*
 		 * Save the raw datum that was just acquired since it may contain bits
@@ -500,214 +871,9 @@ acpi_ex_extract_from_field (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_write_field_datum
- *
- * PARAMETERS:  *Obj_desc           - Field to be set
- *              Value               - Value to store
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Store the value into the given field
- *
- ******************************************************************************/
-
-static acpi_status
-acpi_ex_write_field_datum (
-	acpi_operand_object     *obj_desc,
-	u32                     field_datum_byte_offset,
-	u32                     value)
-{
-	acpi_status             status = AE_OK;
-	acpi_operand_object     *rgn_desc = NULL;
-	ACPI_PHYSICAL_ADDRESS   address;
-
-
-	FUNCTION_TRACE_U32 ("Ex_write_field_datum", field_datum_byte_offset);
-
-
-	/*
-	 * Buffer_fields - Read from a Buffer
-	 * Other Fields - Read from a Operation Region.
-	 */
-	switch (obj_desc->common.type) {
-	case ACPI_TYPE_BUFFER_FIELD:
-
-		/*
-		 * For Buffer_fields, we only need to copy the data to the
-		 * target buffer.  Length is the field width in bytes.
-		 */
-		MEMCPY ((obj_desc->buffer_field.buffer_obj)->buffer.pointer
-				+ obj_desc->buffer_field.base_byte_offset + field_datum_byte_offset,
-				&value, obj_desc->common_field.access_byte_width);
-		status = AE_OK;
-		break;
-
-
-	case INTERNAL_TYPE_REGION_FIELD:
-	case INTERNAL_TYPE_BANK_FIELD:
-
-		/*
-		 * For other fields, we need to go through an Operation Region
-		 * (Only types that will get here are Region_fields and Bank_fields)
-		 */
-		status = acpi_ex_setup_field (obj_desc, field_datum_byte_offset);
-		if (ACPI_FAILURE (status)) {
-			return_ACPI_STATUS (status);
-		}
-
-		/*
-		 * The physical address of this field datum is:
-		 *
-		 * 1) The base of the region, plus
-		 * 2) The base offset of the field, plus
-		 * 3) The current offset into the field
-		 */
-		rgn_desc = obj_desc->common_field.region_obj;
-		address = rgn_desc->region.address +
-				 obj_desc->common_field.base_byte_offset +
-				 field_datum_byte_offset;
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
-			"Store %X in Region %s(%X) at %8.8X%8.8X width %X\n",
-			value, acpi_ut_get_region_name (rgn_desc->region.space_id),
-			rgn_desc->region.space_id, HIDWORD(address), LODWORD(address),
-			obj_desc->common_field.access_bit_width));
-
-		/* Invoke the appropriate Address_space/Op_region handler */
-
-		status = acpi_ev_address_space_dispatch (rgn_desc, ACPI_WRITE_ADR_SPACE,
-				  address, obj_desc->common_field.access_bit_width, &value);
-
-		if (status == AE_NOT_IMPLEMENTED) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"**** Region type %s(%X) not implemented\n",
-				acpi_ut_get_region_name (rgn_desc->region.space_id),
-				rgn_desc->region.space_id));
-		}
-
-		else if (status == AE_NOT_EXIST) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"**** Region type %s(%X) does not have a handler\n",
-				acpi_ut_get_region_name (rgn_desc->region.space_id),
-				rgn_desc->region.space_id));
-		}
-
-		break;
-
-
-	default:
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "%p, wrong source type - %s\n",
-			obj_desc, acpi_ut_get_type_name (obj_desc->common.type)));
-		status = AE_AML_INTERNAL;
-		break;
-	}
-
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD, "Value written=%08X \n", value));
-	return_ACPI_STATUS (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ex_write_field_datum_with_update_rule
- *
- * PARAMETERS:  *Obj_desc           - Field to be set
- *              Value               - Value to store
- *
- * RETURN:      Status
+ * FUNCTION:    acpi_ex_insert_into_field
  *
- * DESCRIPTION: Apply the field update rule to a field write
- *
- ******************************************************************************/
-
-static acpi_status
-acpi_ex_write_field_datum_with_update_rule (
-	acpi_operand_object     *obj_desc,
-	u32                     mask,
-	u32                     field_value,
-	u32                     field_datum_byte_offset)
-{
-	acpi_status             status = AE_OK;
-	u32                     merged_value;
-	u32                     current_value;
-
-
-	FUNCTION_TRACE ("Ex_write_field_datum_with_update_rule");
-
-
-	/* Start with the new bits  */
-
-	merged_value = field_value;
-
-	/* If the mask is all ones, we don't need to worry about the update rule */
-
-	if (mask != ACPI_UINT32_MAX) {
-		/* Decode the update rule */
-
-		switch (obj_desc->common_field.update_rule) {
-		case UPDATE_PRESERVE:
-			/*
-			 * Check if update rule needs to be applied (not if mask is all
-			 * ones)  The left shift drops the bits we want to ignore.
-			 */
-			if ((~mask << (sizeof (mask) * 8 -
-					  obj_desc->common_field.access_bit_width)) != 0) {
-				/*
-				 * Read the current contents of the byte/word/dword containing
-				 * the field, and merge with the new field value.
-				 */
-				status = acpi_ex_read_field_datum (obj_desc, field_datum_byte_offset,
-						  &current_value);
-				merged_value |= (current_value & ~mask);
-			}
-			break;
-
-
-		case UPDATE_WRITE_AS_ONES:
-
-			/* Set positions outside the field to all ones */
-
-			merged_value |= ~mask;
-			break;
-
-
-		case UPDATE_WRITE_AS_ZEROS:
-
-			/* Set positions outside the field to all zeros */
-
-			merged_value &= mask;
-			break;
-
-
-		default:
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Write_with_update_rule: Unknown Update_rule setting: %x\n",
-				obj_desc->common_field.update_rule));
-			return_ACPI_STATUS (AE_AML_OPERAND_VALUE);
-			break;
-		}
-	}
-
-
-	/* Write the merged value */
-
-	status = acpi_ex_write_field_datum (obj_desc, field_datum_byte_offset,
-			  merged_value);
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD, "Mask %X Datum_offset %X Value %X, Merged_value %X\n",
-		mask, field_datum_byte_offset, field_value, merged_value));
-
-	return_ACPI_STATUS (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ex_insert_into_field
- *
- * PARAMETERS:  *Obj_desc           - Field to be set
+ * PARAMETERS:  *obj_desc           - Field to be set
  *              Buffer              - Value to store
  *
  * RETURN:      Status
@@ -718,22 +884,22 @@ acpi_ex_write_field_datum_with_update_ru
 
 acpi_status
 acpi_ex_insert_into_field (
-	acpi_operand_object     *obj_desc,
-	void                    *buffer,
-	u32                     buffer_length)
+	union acpi_operand_object       *obj_desc,
+	void                            *buffer,
+	u32                             buffer_length)
 {
-	acpi_status             status;
-	u32                     field_datum_byte_offset;
-	u32                     datum_offset;
-	u32                     mask;
-	u32                     merged_datum;
-	u32                     previous_raw_datum;
-	u32                     this_raw_datum;
-	u32                     byte_field_length;
-	u32                     datum_count;
+	acpi_status                     status;
+	u32                             field_datum_byte_offset;
+	u32                             datum_offset;
+	acpi_integer                    mask;
+	acpi_integer                    merged_datum;
+	acpi_integer                    previous_raw_datum;
+	acpi_integer                    this_raw_datum;
+	u32                             byte_field_length;
+	u32                             datum_count;
 
 
-	FUNCTION_TRACE ("Ex_insert_into_field");
+	ACPI_FUNCTION_TRACE ("ex_insert_into_field");
 
 
 	/*
@@ -742,24 +908,21 @@ acpi_ex_insert_into_field (
 	 * larger than the field, this typically happens when an integer is
 	 * written to a field that is actually smaller than an integer.
 	 */
-	byte_field_length = ROUND_BITS_UP_TO_BYTES (obj_desc->common_field.bit_length);
+	byte_field_length = ACPI_ROUND_BITS_UP_TO_BYTES (obj_desc->common_field.bit_length);
 	if (buffer_length < byte_field_length) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Buffer length %X too small for field %X\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD, "Buffer length %X too small for field %X\n",
 			buffer_length, byte_field_length));
 
-		/* TBD: Need a better error code */
-
 		return_ACPI_STATUS (AE_BUFFER_OVERFLOW);
 	}
 
 	/* Convert byte count to datum count, round up if necessary */
 
-	datum_count = ROUND_UP_TO (byte_field_length, obj_desc->common_field.access_byte_width);
+	datum_count = ACPI_ROUND_UP_TO (byte_field_length, obj_desc->common_field.access_byte_width);
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-		"Byte_len=%x, Datum_len=%x, Bit_gran=%x, Byte_gran=%x\n",
-		byte_field_length, datum_count, obj_desc->common_field.access_bit_width,
-		obj_desc->common_field.access_byte_width));
+	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
+		"byte_len=%X, datum_len=%X, byte_gran=%X\n",
+		byte_field_length, datum_count, obj_desc->common_field.access_byte_width));
 
 	/*
 	 * Break the request into up to three parts (similar to an I/O request):
@@ -772,7 +935,7 @@ acpi_ex_insert_into_field (
 
 	/* Get a single datum from the caller's buffer */
 
-	acpi_ex_get_buffer_datum (&previous_raw_datum, buffer,
+	acpi_ex_get_buffer_datum (&previous_raw_datum, buffer, buffer_length,
 			obj_desc->common_field.access_byte_width, datum_offset);
 
 	/*
@@ -781,19 +944,19 @@ acpi_ex_insert_into_field (
 	 * Note: The code in this section also handles the aligned case
 	 *
 	 * Construct Mask with 1 bits where the field is, 0 bits elsewhere
-	 * (Only the bottom 5 bits of Bit_length are valid for a shift operation)
+	 * (Only the bottom 5 bits of bit_length are valid for a shift operation)
 	 *
 	 * Mask off bits that are "below" the field (if any)
 	 */
-	mask = MASK_BITS_BELOW (obj_desc->common_field.start_field_bit_offset);
+	mask = ACPI_MASK_BITS_BELOW (obj_desc->common_field.start_field_bit_offset);
 
 	/* If the field fits in one datum, may need to mask upper bits */
 
-	if ((obj_desc->common_field.access_flags & AFIELD_SINGLE_DATUM) &&
+	if ((obj_desc->common_field.flags & AOPOBJ_SINGLE_DATUM) &&
 		 obj_desc->common_field.end_field_valid_bits) {
 		/* There are bits above the field, mask them off also */
 
-		mask &= MASK_BITS_ABOVE (obj_desc->common_field.end_field_valid_bits);
+		mask &= ACPI_MASK_BITS_ABOVE (obj_desc->common_field.end_field_valid_bits);
 	}
 
 	/* Shift and mask the value into the field position */
@@ -803,7 +966,7 @@ acpi_ex_insert_into_field (
 
 	/* Apply the update rule (if necessary) and write the datum to the field */
 
-	status = acpi_ex_write_field_datum_with_update_rule (obj_desc, mask, merged_datum,
+	status = acpi_ex_write_with_update_rule (obj_desc, mask, merged_datum,
 			   field_datum_byte_offset);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
@@ -812,7 +975,7 @@ acpi_ex_insert_into_field (
 	/* If the entire field fits within one datum, we are done. */
 
 	if ((datum_count == 1) &&
-	   (obj_desc->common_field.access_flags & AFIELD_SINGLE_DATUM)) {
+	   (obj_desc->common_field.flags & AOPOBJ_SINGLE_DATUM)) {
 		return_ACPI_STATUS (AE_OK);
 	}
 
@@ -835,7 +998,7 @@ acpi_ex_insert_into_field (
 		 * Get the next raw buffer datum.  It may contain bits of the previous
 		 * field datum
 		 */
-		acpi_ex_get_buffer_datum (&this_raw_datum, buffer,
+		acpi_ex_get_buffer_datum (&this_raw_datum, buffer, buffer_length,
 				obj_desc->common_field.access_byte_width, datum_offset);
 
 		/* Create the field datum based on the field alignment */
@@ -849,7 +1012,6 @@ acpi_ex_insert_into_field (
 				(previous_raw_datum >> obj_desc->common_field.datum_valid_bits) |
 				(this_raw_datum << obj_desc->common_field.start_field_bit_offset);
 		}
-
 		else {
 			/* Field began aligned on datum boundary */
 
@@ -874,24 +1036,23 @@ acpi_ex_insert_into_field (
 				 *
 				 * Mask off the unused bits above (after) the end-of-field
 				 */
-				mask = MASK_BITS_ABOVE (obj_desc->common_field.end_field_valid_bits);
+				mask = ACPI_MASK_BITS_ABOVE (obj_desc->common_field.end_field_valid_bits);
 				merged_datum &= mask;
 
 				/* Write the last datum with the update rule */
 
-				status = acpi_ex_write_field_datum_with_update_rule (obj_desc, mask,
-						  merged_datum, field_datum_byte_offset);
+				status = acpi_ex_write_with_update_rule (obj_desc, mask, merged_datum,
+						   field_datum_byte_offset);
 				if (ACPI_FAILURE (status)) {
 					return_ACPI_STATUS (status);
 				}
 			}
 		}
-
 		else {
 			/* Normal case -- write the completed datum */
 
-			status = acpi_ex_write_field_datum (obj_desc,
-					  field_datum_byte_offset, merged_datum);
+			status = acpi_ex_field_datum_io (obj_desc, field_datum_byte_offset,
+					  &merged_datum, ACPI_WRITE);
 			if (ACPI_FAILURE (status)) {
 				return_ACPI_STATUS (status);
 			}
diff -urNp linux-5400/drivers/acpi/executer/exmisc.c linux-5410/drivers/acpi/executer/exmisc.c
--- linux-5400/drivers/acpi/executer/exmisc.c
+++ linux-5410/drivers/acpi/executer/exmisc.c
@@ -2,122 +2,229 @@
 /******************************************************************************
  *
  * Module Name: exmisc - ACPI AML (p-code) execution - specific opcodes
- *              $Revision: 92 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
-#include "acinterp.h"
-#include "amlcode.h"
-#include "acdispat.h"
+#include <acpi/acpi.h>
+#include <acpi/acinterp.h>
+#include <acpi/amlcode.h>
 
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("exmisc")
+	 ACPI_MODULE_NAME    ("exmisc")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_get_object_reference
+ * FUNCTION:    acpi_ex_get_object_reference
  *
- * PARAMETERS:  Obj_desc        - Create a reference to this object
- *              Return_desc        - Where to store the reference
+ * PARAMETERS:  obj_desc            - Create a reference to this object
+ *              return_desc         - Where to store the reference
+ *              walk_state          - Current state
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Obtain and return a "reference" to the target object
- *              Common code for the Ref_of_op and the Cond_ref_of_op.
+ *              Common code for the ref_of_op and the cond_ref_of_op.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ex_get_object_reference (
-	acpi_operand_object     *obj_desc,
-	acpi_operand_object     **return_desc,
-	acpi_walk_state         *walk_state)
+	union acpi_operand_object       *obj_desc,
+	union acpi_operand_object       **return_desc,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status = AE_OK;
+	union acpi_operand_object       *reference_obj;
+	union acpi_operand_object       *referenced_obj;
 
 
-	FUNCTION_TRACE_PTR ("Ex_get_object_reference", obj_desc);
+	ACPI_FUNCTION_TRACE_PTR ("ex_get_object_reference", obj_desc);
 
 
-	if (VALID_DESCRIPTOR_TYPE (obj_desc, ACPI_DESC_TYPE_INTERNAL)) {
-		if (obj_desc->common.type != INTERNAL_TYPE_REFERENCE) {
-			*return_desc = NULL;
-			status = AE_TYPE;
-			goto cleanup;
+	*return_desc = NULL;
+
+	switch (ACPI_GET_DESCRIPTOR_TYPE (obj_desc)) {
+	case ACPI_DESC_TYPE_OPERAND:
+
+		if (ACPI_GET_OBJECT_TYPE (obj_desc) != ACPI_TYPE_LOCAL_REFERENCE) {
+			return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 		}
 
 		/*
-		 * Not a Name -- an indirect name pointer would have
-		 * been converted to a direct name pointer in Acpi_ex_resolve_operands
+		 * Must be a reference to a Local or Arg
 		 */
 		switch (obj_desc->reference.opcode) {
 		case AML_LOCAL_OP:
 		case AML_ARG_OP:
 
-			*return_desc = (void *) acpi_ds_method_data_get_node (obj_desc->reference.opcode,
-					  obj_desc->reference.offset, walk_state);
+			/* The referenced object is the pseudo-node for the local/arg */
+
+			referenced_obj = obj_desc->reference.object;
 			break;
 
 		default:
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "(Internal) Unknown Ref subtype %02x\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown Reference subtype %X\n",
 				obj_desc->reference.opcode));
-			*return_desc = NULL;
-			status = AE_AML_INTERNAL;
-			goto cleanup;
+			return_ACPI_STATUS (AE_AML_INTERNAL);
 		}
+		break;
 
-	}
 
-	else if (VALID_DESCRIPTOR_TYPE (obj_desc, ACPI_DESC_TYPE_NAMED)) {
-		/* Must be a named object;  Just return the Node */
+	case ACPI_DESC_TYPE_NAMED:
 
-		*return_desc = obj_desc;
+		/*
+		 * A named reference that has already been resolved to a Node
+		 */
+		referenced_obj = obj_desc;
+		break;
+
+
+	default:
+
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid descriptor type %X in %p\n",
+			ACPI_GET_DESCRIPTOR_TYPE (obj_desc), obj_desc));
+		return_ACPI_STATUS (AE_TYPE);
 	}
 
-	else {
-		*return_desc = NULL;
-		status = AE_TYPE;
+
+	/* Create a new reference object */
+
+	reference_obj = acpi_ut_create_internal_object (ACPI_TYPE_LOCAL_REFERENCE);
+	if (!reference_obj) {
+		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
+	reference_obj->reference.opcode = AML_REF_OF_OP;
+	reference_obj->reference.object = referenced_obj;
+	*return_desc = reference_obj;
 
-cleanup:
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Object %p Type [%s], returning Reference %p\n",
+		obj_desc, acpi_ut_get_object_type_name (obj_desc), *return_desc));
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Obj=%p Ref=%p\n", obj_desc, *return_desc));
-	return_ACPI_STATUS (status);
+	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_do_concatenate
+ * FUNCTION:    acpi_ex_concat_template
  *
- * PARAMETERS:  *Obj_desc           - Object to be converted.  Must be an
+ * PARAMETERS:  *obj_desc           - Object to be converted.  Must be an
  *                                    Integer, Buffer, or String
- *              Walk_state          - Current walk state
+ *              walk_state          - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Concatenate two resource templates
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_concat_template (
+	union acpi_operand_object       *obj_desc1,
+	union acpi_operand_object       *obj_desc2,
+	union acpi_operand_object       **actual_return_desc,
+	struct acpi_walk_state          *walk_state)
+{
+	union acpi_operand_object       *return_desc;
+	u8                              *new_buf;
+	u8                              *end_tag1;
+	u8                              *end_tag2;
+	acpi_size                       length1;
+	acpi_size                       length2;
+
+
+	ACPI_FUNCTION_TRACE ("ex_concat_template");
+
+
+	/* Find the end_tags in each resource template */
+
+	end_tag1 = acpi_ut_get_resource_end_tag (obj_desc1);
+	end_tag2 = acpi_ut_get_resource_end_tag (obj_desc2);
+	if (!end_tag1 || !end_tag2) {
+		return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
+	}
+
+	/* Compute the length of each part */
+
+	length1 = ACPI_PTR_DIFF (end_tag1, obj_desc1->buffer.pointer);
+	length2 = ACPI_PTR_DIFF (end_tag2, obj_desc2->buffer.pointer) +
+			  2; /* Size of END_TAG */
+
+	/* Create a new buffer object for the result */
+
+	return_desc = acpi_ut_create_buffer_object (length1 + length2);
+	if (!return_desc) {
+		return_ACPI_STATUS (AE_NO_MEMORY);
+	}
+
+	/* Copy the templates to the new descriptor */
+
+	new_buf = return_desc->buffer.pointer;
+	ACPI_MEMCPY (new_buf, obj_desc1->buffer.pointer, length1);
+	ACPI_MEMCPY (new_buf + length1, obj_desc2->buffer.pointer, length2);
+
+	/* Compute the new checksum */
+
+	new_buf[return_desc->buffer.length - 1] =
+			acpi_ut_generate_checksum (return_desc->buffer.pointer,
+					   (return_desc->buffer.length - 1));
+
+	/* Return the completed template descriptor */
+
+	*actual_return_desc = return_desc;
+	return_ACPI_STATUS (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_do_concatenate
+ *
+ * PARAMETERS:  obj_desc1           - First source object
+ *              obj_desc2           - Second source object
+ *              actual_return_desc  - Where to place the return object
+ *              walk_state          - Current walk state
  *
  * RETURN:      Status
  *
@@ -127,75 +234,54 @@ cleanup:
 
 acpi_status
 acpi_ex_do_concatenate (
-	acpi_operand_object     *obj_desc,
-	acpi_operand_object     *obj_desc2,
-	acpi_operand_object     **actual_return_desc,
-	acpi_walk_state         *walk_state)
+	union acpi_operand_object       *obj_desc1,
+	union acpi_operand_object       *obj_desc2,
+	union acpi_operand_object       **actual_return_desc,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status;
-	u32                     i;
-	acpi_integer            this_integer;
-	acpi_operand_object     *return_desc;
-	NATIVE_CHAR             *new_buf;
-	u32                     integer_size = sizeof (acpi_integer);
+	acpi_status                     status;
+	u32                             i;
+	acpi_integer                    this_integer;
+	union acpi_operand_object       *return_desc;
+	char                            *new_buf;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	/*
 	 * There are three cases to handle:
-	 * 1) Two Integers concatenated to produce a buffer
-	 * 2) Two Strings concatenated to produce a string
-	 * 3) Two Buffers concatenated to produce a buffer
+	 *
+	 * 1) Two Integers concatenated to produce a new Buffer
+	 * 2) Two Strings concatenated to produce a new String
+	 * 3) Two Buffers concatenated to produce a new Buffer
 	 */
-	switch (obj_desc->common.type) {
+	switch (ACPI_GET_OBJECT_TYPE (obj_desc1)) {
 	case ACPI_TYPE_INTEGER:
 
-		/* Handle both ACPI 1.0 and ACPI 2.0 Integer widths */
-
-		if (walk_state->method_node->flags & ANOBJ_DATA_WIDTH_32) {
-			/*
-			 * We are running a method that exists in a 32-bit ACPI table.
-			 * Truncate the value to 32 bits by zeroing out the upper
-			 * 32-bit field
-			 */
-			integer_size = sizeof (u32);
-		}
-
-		/* Result of two integers is a buffer */
+		/* Result of two Integers is a Buffer */
+		/* Need enough buffer space for two integers */
 
-		return_desc = acpi_ut_create_internal_object (ACPI_TYPE_BUFFER);
+		return_desc = acpi_ut_create_buffer_object (acpi_gbl_integer_byte_width * 2);
 		if (!return_desc) {
 			return (AE_NO_MEMORY);
 		}
 
-		/* Need enough space for two integers */
-
-		return_desc->buffer.length = integer_size * 2;
-		new_buf = ACPI_MEM_CALLOCATE (return_desc->buffer.length);
-		if (!new_buf) {
-			REPORT_ERROR
-				(("Ex_do_concatenate: Buffer allocation failure\n"));
-			status = AE_NO_MEMORY;
-			goto cleanup;
-		}
-
-		return_desc->buffer.pointer = (u8 *) new_buf;
+		new_buf = (char *) return_desc->buffer.pointer;
 
 		/* Convert the first integer */
 
-		this_integer = obj_desc->integer.value;
-		for (i = 0; i < integer_size; i++) {
-			new_buf[i] = (u8) this_integer;
+		this_integer = obj_desc1->integer.value;
+		for (i = 0; i < acpi_gbl_integer_byte_width; i++) {
+			new_buf[i] = (char) this_integer;
 			this_integer >>= 8;
 		}
 
 		/* Convert the second integer */
 
 		this_integer = obj_desc2->integer.value;
-		for (; i < (integer_size * 2); i++) {
-			new_buf[i] = (u8) this_integer;
+		for (; i < (ACPI_MUL_2 (acpi_gbl_integer_byte_width)); i++) {
+			new_buf[i] = (char) this_integer;
 			this_integer >>= 8;
 		}
 
@@ -204,6 +290,8 @@ acpi_ex_do_concatenate (
 
 	case ACPI_TYPE_STRING:
 
+		/* Result of two Strings is a String */
+
 		return_desc = acpi_ut_create_internal_object (ACPI_TYPE_STRING);
 		if (!return_desc) {
 			return (AE_NO_MEMORY);
@@ -211,66 +299,60 @@ acpi_ex_do_concatenate (
 
 		/* Operand0 is string  */
 
-		new_buf = ACPI_MEM_ALLOCATE (obj_desc->string.length +
-				  obj_desc2->string.length + 1);
+		new_buf = ACPI_MEM_CALLOCATE ((acpi_size) obj_desc1->string.length +
+				   (acpi_size) obj_desc2->string.length + 1);
 		if (!new_buf) {
-			REPORT_ERROR
-				(("Ex_do_concatenate: String allocation failure\n"));
+			ACPI_REPORT_ERROR
+				(("ex_do_concatenate: String allocation failure\n"));
 			status = AE_NO_MEMORY;
 			goto cleanup;
 		}
 
-		STRCPY (new_buf, obj_desc->string.pointer);
-		STRCPY (new_buf + obj_desc->string.length,
+		/* Concatenate the strings */
+
+		ACPI_STRCPY (new_buf, obj_desc1->string.pointer);
+		ACPI_STRCPY (new_buf + obj_desc1->string.length,
 				  obj_desc2->string.pointer);
 
-		/* Point the return object to the new string */
+		/* Complete the String object initialization */
 
 		return_desc->string.pointer = new_buf;
-		return_desc->string.length = obj_desc->string.length +=
-				  obj_desc2->string.length;
+		return_desc->string.length = obj_desc1->string.length +
+				   obj_desc2->string.length;
 		break;
 
 
 	case ACPI_TYPE_BUFFER:
 
-		/* Operand0 is a buffer */
+		/* Result of two Buffers is a Buffer */
 
-		return_desc = acpi_ut_create_internal_object (ACPI_TYPE_BUFFER);
+		return_desc = acpi_ut_create_buffer_object (
+				   (acpi_size) obj_desc1->buffer.length +
+				   (acpi_size) obj_desc2->buffer.length);
 		if (!return_desc) {
 			return (AE_NO_MEMORY);
 		}
 
-		new_buf = ACPI_MEM_ALLOCATE (obj_desc->buffer.length +
-				  obj_desc2->buffer.length);
-		if (!new_buf) {
-			REPORT_ERROR
-				(("Ex_do_concatenate: Buffer allocation failure\n"));
-			status = AE_NO_MEMORY;
-			goto cleanup;
-		}
+		new_buf = (char *) return_desc->buffer.pointer;
 
-		MEMCPY (new_buf, obj_desc->buffer.pointer,
-				  obj_desc->buffer.length);
-		MEMCPY (new_buf + obj_desc->buffer.length, obj_desc2->buffer.pointer,
-				   obj_desc2->buffer.length);
+		/* Concatenate the buffers */
 
-		/*
-		 * Point the return object to the new buffer
-		 */
+		ACPI_MEMCPY (new_buf, obj_desc1->buffer.pointer,
+				  obj_desc1->buffer.length);
+		ACPI_MEMCPY (new_buf + obj_desc1->buffer.length, obj_desc2->buffer.pointer,
+				   obj_desc2->buffer.length);
 
-		return_desc->buffer.pointer    = (u8 *) new_buf;
-		return_desc->buffer.length     = obj_desc->buffer.length +
-				 obj_desc2->buffer.length;
 		break;
 
 
 	default:
+
+		/* Invalid object type, should not happen here */
+
 		status = AE_AML_INTERNAL;
 		return_desc = NULL;
 	}
 
-
 	*actual_return_desc = return_desc;
 	return (AE_OK);
 
@@ -284,11 +366,11 @@ cleanup:
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_do_math_op
+ * FUNCTION:    acpi_ex_do_math_op
  *
  * PARAMETERS:  Opcode              - AML opcode
  *              Operand0            - Integer operand #0
- *              Operand0            - Integer operand #1
+ *              Operand1            - Integer operand #1
  *
  * RETURN:      Integer result of the operation
  *
@@ -300,9 +382,9 @@ cleanup:
 
 acpi_integer
 acpi_ex_do_math_op (
-	u16                     opcode,
-	acpi_integer            operand0,
-	acpi_integer            operand1)
+	u16                             opcode,
+	acpi_integer                    operand0,
+	acpi_integer                    operand1)
 {
 
 
@@ -342,12 +424,12 @@ acpi_ex_do_math_op (
 		return (operand0 * operand1);
 
 
-	case AML_SHIFT_LEFT_OP:         /* Shift_left (Operand, Shift_count, Result) */
+	case AML_SHIFT_LEFT_OP:         /* shift_left (Operand, shift_count, Result) */
 
 		return (operand0 << operand1);
 
 
-	case AML_SHIFT_RIGHT_OP:        /* Shift_right (Operand, Shift_count, Result) */
+	case AML_SHIFT_RIGHT_OP:        /* shift_right (Operand, shift_count, Result) */
 
 		return (operand0 >> operand1);
 
@@ -365,11 +447,11 @@ acpi_ex_do_math_op (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_do_logical_op
+ * FUNCTION:    acpi_ex_do_logical_op
  *
  * PARAMETERS:  Opcode              - AML opcode
  *              Operand0            - Integer operand #0
- *              Operand0            - Integer operand #1
+ *              Operand1            - Integer operand #1
  *
  * RETURN:      TRUE/FALSE result of the operation
  *
@@ -386,9 +468,9 @@ acpi_ex_do_math_op (
 
 u8
 acpi_ex_do_logical_op (
-	u16                     opcode,
-	acpi_integer            operand0,
-	acpi_integer            operand1)
+	u16                             opcode,
+	acpi_integer                    operand0,
+	acpi_integer                    operand1)
 {
 
 
@@ -432,6 +514,9 @@ acpi_ex_do_logical_op (
 			return (TRUE);
 		}
 		break;
+
+	default:
+		break;
 	}
 
 	return (FALSE);
diff -urNp linux-5400/drivers/acpi/executer/exmutex.c linux-5410/drivers/acpi/executer/exmutex.c
--- linux-5400/drivers/acpi/executer/exmutex.c
+++ linux-5410/drivers/acpi/executer/exmutex.c
@@ -2,107 +2,136 @@
 /******************************************************************************
  *
  * Module Name: exmutex - ASL Mutex Acquire/Release functions
- *              $Revision: 7 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acinterp.h"
-#include "acnamesp.h"
-#include "achware.h"
-#include "acevents.h"
+#include <acpi/acpi.h>
+#include <acpi/acinterp.h>
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("exmutex")
+	 ACPI_MODULE_NAME    ("exmutex")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_unlink_mutex
+ * FUNCTION:    acpi_ex_unlink_mutex
  *
- * PARAMETERS:  *Obj_desc           - The mutex to be unlinked
+ * PARAMETERS:  *obj_desc           - The mutex to be unlinked
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Remove a mutex from the "Acquired_mutex" list
+ * DESCRIPTION: Remove a mutex from the "acquired_mutex" list
  *
  ******************************************************************************/
 
 void
 acpi_ex_unlink_mutex (
-	acpi_operand_object     *obj_desc)
+	union acpi_operand_object       *obj_desc)
 {
+	struct acpi_thread_state        *thread = obj_desc->mutex.owner_thread;
+
+
+	if (!thread) {
+		return;
+	}
 
 	if (obj_desc->mutex.next) {
 		(obj_desc->mutex.next)->mutex.prev = obj_desc->mutex.prev;
 	}
+
 	if (obj_desc->mutex.prev) {
 		(obj_desc->mutex.prev)->mutex.next = obj_desc->mutex.next;
 	}
+	else {
+		thread->acquired_mutex_list = obj_desc->mutex.next;
+	}
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_link_mutex
+ * FUNCTION:    acpi_ex_link_mutex
  *
- * PARAMETERS:  *Obj_desc           - The mutex to be linked
- *              *List_head          - head of the "Acquired_mutex" list
+ * PARAMETERS:  *obj_desc           - The mutex to be linked
+ *              *list_head          - head of the "acquired_mutex" list
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Add a mutex to the "Acquired_mutex" list for this walk
+ * DESCRIPTION: Add a mutex to the "acquired_mutex" list for this walk
  *
  ******************************************************************************/
 
 void
 acpi_ex_link_mutex (
-	acpi_operand_object     *obj_desc,
-	acpi_operand_object     *list_head)
+	union acpi_operand_object       *obj_desc,
+	struct acpi_thread_state        *thread)
 {
+	union acpi_operand_object       *list_head;
+
+
+	list_head = thread->acquired_mutex_list;
 
 	/* This object will be the first object in the list */
 
-	obj_desc->mutex.prev = list_head;
-	obj_desc->mutex.next = list_head->mutex.next;
+	obj_desc->mutex.prev = NULL;
+	obj_desc->mutex.next = list_head;
 
 	/* Update old first object to point back to this object */
 
-	if (list_head->mutex.next) {
-		(list_head->mutex.next)->mutex.prev = obj_desc;
+	if (list_head) {
+		list_head->mutex.prev = obj_desc;
 	}
 
 	/* Update list head */
 
-	list_head->mutex.next = obj_desc;
+	thread->acquired_mutex_list = obj_desc;
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_acquire_mutex
+ * FUNCTION:    acpi_ex_acquire_mutex
  *
- * PARAMETERS:  *Time_desc          - The 'time to delay' object descriptor
- *              *Obj_desc           - The object descriptor for this op
+ * PARAMETERS:  *time_desc          - The 'time to delay' object descriptor
+ *              *obj_desc           - The object descriptor for this op
  *
  * RETURN:      Status
  *
@@ -112,32 +141,48 @@ acpi_ex_link_mutex (
 
 acpi_status
 acpi_ex_acquire_mutex (
-	acpi_operand_object     *time_desc,
-	acpi_operand_object     *obj_desc,
-	acpi_walk_state         *walk_state)
+	union acpi_operand_object       *time_desc,
+	union acpi_operand_object       *obj_desc,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status;
+	acpi_status                     status;
+
 
+	ACPI_FUNCTION_TRACE_PTR ("ex_acquire_mutex", obj_desc);
 
-	FUNCTION_TRACE_PTR ("Ex_acquire_mutex", obj_desc);
 
 	if (!obj_desc) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
+	/* Sanity check -- we must have a valid thread ID */
+
+	if (!walk_state->thread) {
+		ACPI_REPORT_ERROR (("Cannot acquire Mutex [%4.4s], null thread info\n",
+				obj_desc->mutex.node->name.ascii));
+		return_ACPI_STATUS (AE_AML_INTERNAL);
+	}
+
 	/*
 	 * Current Sync must be less than or equal to the sync level of the
 	 * mutex.  This mechanism provides some deadlock prevention
 	 */
-	if (walk_state->current_sync_level > obj_desc->mutex.sync_level) {
+	if (walk_state->thread->current_sync_level > obj_desc->mutex.sync_level) {
+		ACPI_REPORT_ERROR (("Cannot acquire Mutex [%4.4s], incorrect sync_level\n",
+				obj_desc->mutex.node->name.ascii));
 		return_ACPI_STATUS (AE_AML_MUTEX_ORDER);
 	}
 
 	/*
-	 * If the mutex is already owned by this thread,
-	 * just increment the acquisition depth
+	 * Support for multiple acquires by the owning thread
 	 */
-	if (obj_desc->mutex.owner == walk_state) {
+
+	if ((obj_desc->mutex.owner_thread) &&
+		(obj_desc->mutex.owner_thread->thread_id == walk_state->thread->thread_id)) {
+		/*
+		 * The mutex is already owned by this thread,
+		 * just increment the acquisition depth
+		 */
 		obj_desc->mutex.acquisition_depth++;
 		return_ACPI_STATUS (AE_OK);
 	}
@@ -146,21 +191,21 @@ acpi_ex_acquire_mutex (
 
 	status = acpi_ex_system_acquire_mutex (time_desc, obj_desc);
 	if (ACPI_FAILURE (status)) {
-		/* Includes failure from a timeout on Time_desc */
+		/* Includes failure from a timeout on time_desc */
 
 		return_ACPI_STATUS (status);
 	}
 
 	/* Have the mutex, update mutex and walk info */
 
-	obj_desc->mutex.owner = walk_state;
+	obj_desc->mutex.owner_thread    = walk_state->thread;
 	obj_desc->mutex.acquisition_depth = 1;
-	walk_state->current_sync_level = obj_desc->mutex.sync_level;
 
-	/* Link the mutex to the walk state for force-unlock at method exit */
+	walk_state->thread->current_sync_level = obj_desc->mutex.sync_level;
 
-	acpi_ex_link_mutex (obj_desc, (acpi_operand_object *)
-			 &(walk_state->walk_list->acquired_mutex_list));
+	/* Link the mutex to the current thread for force-unlock at method exit */
+
+	acpi_ex_link_mutex (obj_desc, walk_state->thread);
 
 	return_ACPI_STATUS (AE_OK);
 }
@@ -168,9 +213,9 @@ acpi_ex_acquire_mutex (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_release_mutex
+ * FUNCTION:    acpi_ex_release_mutex
  *
- * PARAMETERS:  *Obj_desc           - The object descriptor for this op
+ * PARAMETERS:  *obj_desc           - The object descriptor for this op
  *
  * RETURN:      Status
  *
@@ -180,13 +225,13 @@ acpi_ex_acquire_mutex (
 
 acpi_status
 acpi_ex_release_mutex (
-	acpi_operand_object     *obj_desc,
-	acpi_walk_state         *walk_state)
+	union acpi_operand_object       *obj_desc,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Ex_release_mutex");
+	ACPI_FUNCTION_TRACE ("ex_release_mutex");
 
 
 	if (!obj_desc) {
@@ -195,13 +240,28 @@ acpi_ex_release_mutex (
 
 	/* The mutex must have been previously acquired in order to release it */
 
-	if (!obj_desc->mutex.owner) {
+	if (!obj_desc->mutex.owner_thread) {
+		ACPI_REPORT_ERROR (("Cannot release Mutex [%4.4s], not acquired\n",
+				obj_desc->mutex.node->name.ascii));
 		return_ACPI_STATUS (AE_AML_MUTEX_NOT_ACQUIRED);
 	}
 
+	/* Sanity check -- we must have a valid thread ID */
+
+	if (!walk_state->thread) {
+		ACPI_REPORT_ERROR (("Cannot release Mutex [%4.4s], null thread info\n",
+				obj_desc->mutex.node->name.ascii));
+		return_ACPI_STATUS (AE_AML_INTERNAL);
+	}
+
 	/* The Mutex is owned, but this thread must be the owner */
 
-	if (obj_desc->mutex.owner != walk_state) {
+	if (obj_desc->mutex.owner_thread->thread_id != walk_state->thread->thread_id) {
+		ACPI_REPORT_ERROR ((
+			"Thread %X cannot release Mutex [%4.4s] acquired by thread %X\n",
+			walk_state->thread->thread_id,
+			obj_desc->mutex.node->name.ascii,
+			obj_desc->mutex.owner_thread->thread_id));
 		return_ACPI_STATUS (AE_AML_NOT_OWNER);
 	}
 
@@ -209,7 +269,9 @@ acpi_ex_release_mutex (
 	 * The sync level of the mutex must be less than or
 	 * equal to the current sync level
 	 */
-	if (obj_desc->mutex.sync_level > walk_state->current_sync_level) {
+	if (obj_desc->mutex.sync_level > walk_state->thread->current_sync_level) {
+		ACPI_REPORT_ERROR (("Cannot release Mutex [%4.4s], incorrect sync_level\n",
+				obj_desc->mutex.node->name.ascii));
 		return_ACPI_STATUS (AE_AML_MUTEX_ORDER);
 	}
 
@@ -223,6 +285,9 @@ acpi_ex_release_mutex (
 		return_ACPI_STATUS (AE_OK);
 	}
 
+	/* Unlink the mutex from the owner's list */
+
+	acpi_ex_unlink_mutex (obj_desc);
 
 	/* Release the mutex */
 
@@ -230,12 +295,8 @@ acpi_ex_release_mutex (
 
 	/* Update the mutex and walk state */
 
-	obj_desc->mutex.owner = NULL;
-	walk_state->current_sync_level = obj_desc->mutex.sync_level;
-
-	/* Unlink the mutex from the owner's list */
-
-	acpi_ex_unlink_mutex (obj_desc);
+	obj_desc->mutex.owner_thread = NULL;
+	walk_state->thread->current_sync_level = obj_desc->mutex.sync_level;
 
 	return_ACPI_STATUS (status);
 }
@@ -243,9 +304,9 @@ acpi_ex_release_mutex (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_release_all_mutexes
+ * FUNCTION:    acpi_ex_release_all_mutexes
  *
- * PARAMETERS:  *Mutex_list           - Head of the mutex list
+ * PARAMETERS:  *mutex_list           - Head of the mutex list
  *
  * RETURN:      Status
  *
@@ -253,15 +314,16 @@ acpi_ex_release_mutex (
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ex_release_all_mutexes (
-	acpi_operand_object     *list_head)
+	struct acpi_thread_state        *thread)
 {
-	acpi_operand_object     *next = list_head->mutex.next;
-	acpi_operand_object     *this;
+	union acpi_operand_object       *next = thread->acquired_mutex_list;
+	union acpi_operand_object       *this;
+	acpi_status                     status;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	/*
@@ -271,19 +333,21 @@ acpi_ex_release_all_mutexes (
 		this = next;
 		next = this->mutex.next;
 
-		/* Mark mutex un-owned */
-
-		this->mutex.owner = NULL;
-		this->mutex.prev = NULL;
-		this->mutex.next = NULL;
-		this->mutex.acquisition_depth = 0;
+		this->mutex.acquisition_depth = 1;
+		this->mutex.prev             = NULL;
+		this->mutex.next             = NULL;
 
 		 /* Release the mutex */
 
-		acpi_ex_system_release_mutex (this);
-	}
+		status = acpi_ex_system_release_mutex (this);
+		if (ACPI_FAILURE (status)) {
+			continue;
+		}
+
+		/* Mark mutex unowned */
 
-	return (AE_OK);
+		this->mutex.owner_thread     = NULL;
+	}
 }
 
 
diff -urNp linux-5400/drivers/acpi/executer/exnames.c linux-5410/drivers/acpi/executer/exnames.c
--- linux-5400/drivers/acpi/executer/exnames.c
+++ linux-5410/drivers/acpi/executer/exnames.c
@@ -2,36 +2,53 @@
 /******************************************************************************
  *
  * Module Name: exnames - interpreter/scanner name load/execute
- *              $Revision: 83 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acinterp.h"
-#include "amlcode.h"
-#include "acnamesp.h"
+#include <acpi/acpi.h>
+#include <acpi/acinterp.h>
+#include <acpi/amlcode.h>
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("exnames")
+	 ACPI_MODULE_NAME    ("exnames")
 
 
 /* AML Package Length encodings */
@@ -44,11 +61,11 @@
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_allocate_name_string
+ * FUNCTION:    acpi_ex_allocate_name_string
  *
- * PARAMETERS:  Prefix_count        - Count of parent levels. Special cases:
+ * PARAMETERS:  prefix_count        - Count of parent levels. Special cases:
  *                                    (-1) = root,  0 = none
- *              Num_name_segs       - count of 4-character name segments
+ *              num_name_segs       - count of 4-character name segments
  *
  * RETURN:      A pointer to the allocated string segment.  This segment must
  *              be deleted by the caller.
@@ -58,24 +75,24 @@
  *
  ******************************************************************************/
 
-NATIVE_CHAR *
+char *
 acpi_ex_allocate_name_string (
-	u32                     prefix_count,
-	u32                     num_name_segs)
+	u32                             prefix_count,
+	u32                             num_name_segs)
 {
-	NATIVE_CHAR             *temp_ptr;
-	NATIVE_CHAR             *name_string;
-	u32                      size_needed;
+	char                            *temp_ptr;
+	char                            *name_string;
+	u32                              size_needed;
 
-	FUNCTION_TRACE ("Ex_allocate_name_string");
+	ACPI_FUNCTION_TRACE ("ex_allocate_name_string");
 
 
 	/*
-	 * Allow room for all \ and ^ prefixes, all segments, and a Multi_name_prefix.
+	 * Allow room for all \ and ^ prefixes, all segments, and a multi_name_prefix.
 	 * Also, one byte for the null terminator.
 	 * This may actually be somewhat longer than needed.
 	 */
-	if (prefix_count == (u32) -1) {
+	if (prefix_count == ACPI_UINT32_MAX) {
 		/* Special case for root */
 
 		size_needed = 1 + (ACPI_NAME_SIZE * num_name_segs) + 2 + 1;
@@ -90,7 +107,7 @@ acpi_ex_allocate_name_string (
 	 */
 	name_string = ACPI_MEM_ALLOCATE (size_needed);
 	if (!name_string) {
-		REPORT_ERROR (("Ex_allocate_name_string: Could not allocate size %d\n", size_needed));
+		ACPI_REPORT_ERROR (("ex_allocate_name_string: Could not allocate size %d\n", size_needed));
 		return_PTR (NULL);
 	}
 
@@ -98,10 +115,9 @@ acpi_ex_allocate_name_string (
 
 	/* Set up Root or Parent prefixes if needed */
 
-	if (prefix_count == (u32) -1) {
+	if (prefix_count == ACPI_UINT32_MAX) {
 		*temp_ptr++ = AML_ROOT_PREFIX;
 	}
-
 	else {
 		while (prefix_count--) {
 			*temp_ptr++ = AML_PARENT_PREFIX;
@@ -117,7 +133,6 @@ acpi_ex_allocate_name_string (
 		*temp_ptr++ = AML_MULTI_NAME_PREFIX_OP;
 		*temp_ptr++ = (char) num_name_segs;
 	}
-
 	else if (2 == num_name_segs) {
 		/* Set up dual prefixes */
 
@@ -125,7 +140,7 @@ acpi_ex_allocate_name_string (
 	}
 
 	/*
-	 * Terminate string following prefixes. Acpi_ex_name_segment() will
+	 * Terminate string following prefixes. acpi_ex_name_segment() will
 	 * append the segment(s)
 	 */
 	*temp_ptr = 0;
@@ -135,9 +150,9 @@ acpi_ex_allocate_name_string (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_name_segment
+ * FUNCTION:    acpi_ex_name_segment
  *
- * PARAMETERS:  Interpreter_mode    - Current running mode (load1/Load2/Exec)
+ * PARAMETERS:  interpreter_mode    - Current running mode (load1/Load2/Exec)
  *
  * RETURN:      Status
  *
@@ -147,16 +162,16 @@ acpi_ex_allocate_name_string (
 
 acpi_status
 acpi_ex_name_segment (
-	u8                      **in_aml_address,
-	NATIVE_CHAR             *name_string)
+	u8                              **in_aml_address,
+	char                            *name_string)
 {
-	u8                      *aml_address = *in_aml_address;
-	acpi_status             status = AE_OK;
-	u32                     index;
-	NATIVE_CHAR             char_buf[5];
+	char                            *aml_address = (void *) *in_aml_address;
+	acpi_status                     status = AE_OK;
+	u32                             index;
+	char                            char_buf[5];
 
 
-	FUNCTION_TRACE ("Ex_name_segment");
+	ACPI_FUNCTION_TRACE ("ex_name_segment");
 
 
 	/*
@@ -172,34 +187,32 @@ acpi_ex_name_segment (
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "Bytes from stream:\n"));
 
-	for (index = 4;
-		(index > 0) && (acpi_ut_valid_acpi_character (*aml_address));
-		--index) {
-		char_buf[4 - index] = *aml_address++;
-		ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "%c\n", char_buf[4 - index]));
+	for (index = 0;
+		(index < ACPI_NAME_SIZE) && (acpi_ut_valid_acpi_character (*aml_address));
+		index++) {
+		char_buf[index] = *aml_address++;
+		ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "%c\n", char_buf[index]));
 	}
 
 
 	/* Valid name segment  */
 
-	if (0 == index) {
+	if (index == 4) {
 		/* Found 4 valid characters */
 
 		char_buf[4] = '\0';
 
 		if (name_string) {
-			STRCAT (name_string, char_buf);
+			ACPI_STRCAT (name_string, char_buf);
 			ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
 				"Appended to - %s \n", name_string));
 		}
-
 		else {
 			ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
 				"No Name string - %s \n", char_buf));
 		}
 	}
-
-	else if (4 == index) {
+	else if (index == 0) {
 		/*
 		 * First character was not a valid name character,
 		 * so we are looking at something other than a name.
@@ -209,7 +222,6 @@ acpi_ex_name_segment (
 			char_buf[0]));
 		status = AE_CTRL_PENDING;
 	}
-
 	else {
 		/* Segment started with one or more valid characters, but fewer than 4 */
 
@@ -218,16 +230,16 @@ acpi_ex_name_segment (
 			*aml_address, aml_address));
 	}
 
-	*in_aml_address = aml_address;
+	*in_aml_address = (u8 *) aml_address;
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_get_name_string
+ * FUNCTION:    acpi_ex_get_name_string
  *
- * PARAMETERS:  Data_type           - Data type to be associated with this name
+ * PARAMETERS:  data_type           - Data type to be associated with this name
  *
  * RETURN:      Status
  *
@@ -235,30 +247,28 @@ acpi_ex_name_segment (
  *
  ******************************************************************************/
 
-
 acpi_status
 acpi_ex_get_name_string (
-	acpi_object_type8       data_type,
-	u8                      *in_aml_address,
-	NATIVE_CHAR             **out_name_string,
-	u32                     *out_name_length)
+	acpi_object_type                data_type,
+	u8                              *in_aml_address,
+	char                            **out_name_string,
+	u32                             *out_name_length)
 {
-	acpi_status             status = AE_OK;
-	u8                      *aml_address = in_aml_address;
-	NATIVE_CHAR             *name_string = NULL;
-	u32                     num_segments;
-	u32                     prefix_count = 0;
-	u8                      prefix = 0;
-	u8                      has_prefix = FALSE;
-
-
-	FUNCTION_TRACE_PTR ("Ex_get_name_string", aml_address);
-
-
-	if (INTERNAL_TYPE_REGION_FIELD == data_type  ||
-		INTERNAL_TYPE_BANK_FIELD == data_type    ||
-		INTERNAL_TYPE_INDEX_FIELD == data_type) {
-		/* Disallow prefixes for types associated with Field_unit names */
+	acpi_status                     status = AE_OK;
+	u8                              *aml_address = in_aml_address;
+	char                            *name_string = NULL;
+	u32                             num_segments;
+	u32                             prefix_count = 0;
+	u8                              has_prefix = FALSE;
+
+
+	ACPI_FUNCTION_TRACE_PTR ("ex_get_name_string", aml_address);
+
+
+	if (ACPI_TYPE_LOCAL_REGION_FIELD == data_type  ||
+		ACPI_TYPE_LOCAL_BANK_FIELD == data_type    ||
+		ACPI_TYPE_LOCAL_INDEX_FIELD == data_type) {
+		/* Disallow prefixes for types associated with field_unit names */
 
 		name_string = acpi_ex_allocate_name_string (0, 1);
 		if (!name_string) {
@@ -268,24 +278,22 @@ acpi_ex_get_name_string (
 			status = acpi_ex_name_segment (&aml_address, name_string);
 		}
 	}
-
 	else {
 		/*
-		 * Data_type is not a field name.
+		 * data_type is not a field name.
 		 * Examine first character of name for root or parent prefix operators
 		 */
 		switch (*aml_address) {
-
 		case AML_ROOT_PREFIX:
 
-			prefix = *aml_address++;
-			ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "Root_prefix: %x\n", prefix));
+			ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "root_prefix(\\) at %p\n", aml_address));
 
 			/*
-			 * Remember that we have a Root_prefix --
-			 * see comment in Acpi_ex_allocate_name_string()
+			 * Remember that we have a root_prefix --
+			 * see comment in acpi_ex_allocate_name_string()
 			 */
-			prefix_count = (u32) -1;
+			aml_address++;
+			prefix_count = ACPI_UINT32_MAX;
 			has_prefix = TRUE;
 			break;
 
@@ -295,18 +303,21 @@ acpi_ex_get_name_string (
 			/* Increment past possibly multiple parent prefixes */
 
 			do {
-				prefix = *aml_address++;
-				ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "Parent_prefix: %x\n", prefix));
+				ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "parent_prefix (^) at %p\n", aml_address));
 
-				++prefix_count;
+				aml_address++;
+				prefix_count++;
 
 			} while (*aml_address == AML_PARENT_PREFIX);
+
 			has_prefix = TRUE;
 			break;
 
 
 		default:
 
+			/* Not a prefix character */
+
 			break;
 		}
 
@@ -314,12 +325,11 @@ acpi_ex_get_name_string (
 		/* Examine first character of name for name segment prefix operator */
 
 		switch (*aml_address) {
-
 		case AML_DUAL_NAME_PREFIX:
 
-			prefix = *aml_address++;
-			ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "Dual_name_prefix: %x\n", prefix));
+			ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "dual_name_prefix at %p\n", aml_address));
 
+			aml_address++;
 			name_string = acpi_ex_allocate_name_string (prefix_count, 2);
 			if (!name_string) {
 				status = AE_NO_MEMORY;
@@ -339,12 +349,12 @@ acpi_ex_get_name_string (
 
 		case AML_MULTI_NAME_PREFIX_OP:
 
-			prefix = *aml_address++;
-			ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "Multi_name_prefix: %x\n", prefix));
+			ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "multi_name_prefix at %p\n", aml_address));
 
 			/* Fetch count of segments remaining in name path */
 
-			num_segments = *aml_address++;
+			aml_address++;
+			num_segments = *aml_address;
 
 			name_string = acpi_ex_allocate_name_string (prefix_count, num_segments);
 			if (!name_string) {
@@ -354,11 +364,12 @@ acpi_ex_get_name_string (
 
 			/* Indicate that we processed a prefix */
 
+			aml_address++;
 			has_prefix = TRUE;
 
 			while (num_segments &&
 					(status = acpi_ex_name_segment (&aml_address, name_string)) == AE_OK) {
-				--num_segments;
+				num_segments--;
 			}
 
 			break;
@@ -366,10 +377,10 @@ acpi_ex_get_name_string (
 
 		case 0:
 
-			/* Null_name valid as of 8-12-98 ASL/AML Grammar Update */
+			/* null_name valid as of 8-12-98 ASL/AML Grammar Update */
 
-			if (-1 == prefix_count) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Name_seg is \"\\\" followed by NULL\n"));
+			if (prefix_count == ACPI_UINT32_MAX) {
+				ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "name_seg is \"\\\" followed by NULL\n"));
 			}
 
 			/* Consume the NULL byte */
@@ -396,20 +407,17 @@ acpi_ex_get_name_string (
 
 			status = acpi_ex_name_segment (&aml_address, name_string);
 			break;
-
-		}   /* Switch (Peek_op ())   */
+		}
 	}
 
-
 	if (AE_CTRL_PENDING == status && has_prefix) {
 		/* Ran out of segments after processing a prefix */
 
-		REPORT_ERROR (
-			("Ex_do_name: Malformed Name at %p\n", name_string));
+		ACPI_REPORT_ERROR (
+			("ex_do_name: Malformed Name at %p\n", name_string));
 		status = AE_AML_BAD_NAME;
 	}
 
-
 	*out_name_string = name_string;
 	*out_name_length = (u32) (aml_address - in_aml_address);
 
diff -urNp linux-5400/drivers/acpi/executer/exoparg1.c linux-5410/drivers/acpi/executer/exoparg1.c
--- linux-5400/drivers/acpi/executer/exoparg1.c
+++ linux-5410/drivers/acpi/executer/exoparg1.c
@@ -2,39 +2,57 @@
 /******************************************************************************
  *
  * Module Name: exoparg1 - AML execution - opcodes with 1 argument
- *              $Revision: 120 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
-#include "acdispat.h"
-#include "acinterp.h"
-#include "amlcode.h"
-#include "acnamesp.h"
+#include <acpi/acpi.h>
+#include <acpi/acparser.h>
+#include <acpi/acdispat.h>
+#include <acpi/acinterp.h>
+#include <acpi/amlcode.h>
+#include <acpi/acnamesp.h>
 
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("exoparg1")
+	 ACPI_MODULE_NAME    ("exoparg1")
 
 
 /*!
@@ -59,12 +77,11 @@
  * fully resolved operands.
 !*/
 
-
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_opcode_1A_0T_0R
+ * FUNCTION:    acpi_ex_opcode_1A_0T_0R
  *
- * PARAMETERS:  Walk_state          - Current state (contains AML opcode)
+ * PARAMETERS:  walk_state          - Current state (contains AML opcode)
  *
  * RETURN:      Status
  *
@@ -75,45 +92,45 @@
 
 acpi_status
 acpi_ex_opcode_1A_0T_0R (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_operand_object     **operand = &walk_state->operands[0];
-	acpi_status             status = AE_OK;
+	union acpi_operand_object       **operand = &walk_state->operands[0];
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE_STR ("Ex_opcode_1A_0T_0R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_1A_0T_0R", acpi_ps_get_opcode_name (walk_state->opcode));
 
 
-	/* Examine the opcode */
+	/* Examine the AML opcode */
 
 	switch (walk_state->opcode) {
-	case AML_RELEASE_OP:    /*  Release (Mutex_object) */
+	case AML_RELEASE_OP:    /*  Release (mutex_object) */
 
 		status = acpi_ex_release_mutex (operand[0], walk_state);
 		break;
 
 
-	case AML_RESET_OP:      /*  Reset (Event_object) */
+	case AML_RESET_OP:      /*  Reset (event_object) */
 
 		status = acpi_ex_system_reset_event (operand[0]);
 		break;
 
 
-	case AML_SIGNAL_OP:     /*  Signal (Event_object) */
+	case AML_SIGNAL_OP:     /*  Signal (event_object) */
 
 		status = acpi_ex_system_signal_event (operand[0]);
 		break;
 
 
-	case AML_SLEEP_OP:      /*  Sleep (Msec_time) */
+	case AML_SLEEP_OP:      /*  Sleep (msec_time) */
 
-		acpi_ex_system_do_suspend ((u32) operand[0]->integer.value);
+		status = acpi_ex_system_do_suspend ((u32) operand[0]->integer.value);
 		break;
 
 
-	case AML_STALL_OP:      /*  Stall (Usec_time) */
+	case AML_STALL_OP:      /*  Stall (usec_time) */
 
-		acpi_ex_system_do_stall ((u32) operand[0]->integer.value);
+		status = acpi_ex_system_do_stall ((u32) operand[0]->integer.value);
 		break;
 
 
@@ -125,7 +142,7 @@ acpi_ex_opcode_1A_0T_0R (
 
 	default:                /*  Unknown opcode  */
 
-		REPORT_ERROR (("Acpi_ex_opcode_1A_0T_0R: Unknown opcode %X\n",
+		ACPI_REPORT_ERROR (("acpi_ex_opcode_1A_0T_0R: Unknown opcode %X\n",
 			walk_state->opcode));
 		status = AE_AML_BAD_OPCODE;
 		break;
@@ -137,9 +154,9 @@ acpi_ex_opcode_1A_0T_0R (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_opcode_1A_1T_0R
+ * FUNCTION:    acpi_ex_opcode_1A_1T_0R
  *
- * PARAMETERS:  Walk_state          - Current state (contains AML opcode)
+ * PARAMETERS:  walk_state          - Current state (contains AML opcode)
  *
  * RETURN:      Status
  *
@@ -150,25 +167,26 @@ acpi_ex_opcode_1A_0T_0R (
 
 acpi_status
 acpi_ex_opcode_1A_1T_0R (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status = AE_OK;
-	acpi_operand_object     **operand = &walk_state->operands[0];
+	acpi_status                     status = AE_OK;
+	union acpi_operand_object       **operand = &walk_state->operands[0];
 
 
-	FUNCTION_TRACE_STR ("Ex_opcode_1A_1T_0R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_1A_1T_0R", acpi_ps_get_opcode_name (walk_state->opcode));
 
 
-	switch (walk_state->opcode) {
+	/* Examine the AML opcode */
 
+	switch (walk_state->opcode) {
 	case AML_LOAD_OP:
 
-		status = acpi_ex_load_op (operand[0], operand[1]);
+		status = acpi_ex_load_op (operand[0], operand[1], walk_state);
 		break;
 
 	default:                        /* Unknown opcode */
 
-		REPORT_ERROR (("Acpi_ex_opcode_1A_1T_0R: Unknown opcode %X\n",
+		ACPI_REPORT_ERROR (("acpi_ex_opcode_1A_1T_0R: Unknown opcode %X\n",
 			walk_state->opcode));
 		status = AE_AML_BAD_OPCODE;
 		goto cleanup;
@@ -183,9 +201,9 @@ cleanup:
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_opcode_1A_1T_1R
+ * FUNCTION:    acpi_ex_opcode_1A_1T_1R
  *
- * PARAMETERS:  Walk_state          - Current state (contains AML opcode)
+ * PARAMETERS:  walk_state          - Current state (contains AML opcode)
  *
  * RETURN:      Status
  *
@@ -196,22 +214,22 @@ cleanup:
 
 acpi_status
 acpi_ex_opcode_1A_1T_1R (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status = AE_OK;
-	acpi_operand_object     **operand = &walk_state->operands[0];
-	acpi_operand_object     *return_desc = NULL;
-	acpi_operand_object     *return_desc2 = NULL;
-	u32                     temp32;
-	u32                     i;
-	u32                     j;
-	acpi_integer            digit;
+	acpi_status                     status = AE_OK;
+	union acpi_operand_object       **operand = &walk_state->operands[0];
+	union acpi_operand_object       *return_desc = NULL;
+	union acpi_operand_object       *return_desc2 = NULL;
+	u32                             temp32;
+	u32                             i;
+	u32                             power_of_ten;
+	acpi_integer                    digit;
 
 
-	FUNCTION_TRACE_STR ("Ex_opcode_1A_1T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_1A_1T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
 
 
-	/* Create a return object of type Integer for most opcodes */
+	/* Examine the AML opcode */
 
 	switch (walk_state->opcode) {
 	case AML_BIT_NOT_OP:
@@ -221,156 +239,162 @@ acpi_ex_opcode_1A_1T_1R (
 	case AML_TO_BCD_OP:
 	case AML_COND_REF_OF_OP:
 
+		/* Create a return object of type Integer for these opcodes */
+
 		return_desc = acpi_ut_create_internal_object (ACPI_TYPE_INTEGER);
 		if (!return_desc) {
 			status = AE_NO_MEMORY;
 			goto cleanup;
 		}
 
-		break;
-	}
+		switch (walk_state->opcode) {
+		case AML_BIT_NOT_OP:            /* Not (Operand, Result)  */
 
+			return_desc->integer.value = ~operand[0]->integer.value;
+			break;
 
-	switch (walk_state->opcode) {
 
-	case AML_BIT_NOT_OP:            /* Not (Operand, Result)  */
+		case AML_FIND_SET_LEFT_BIT_OP:  /* find_set_left_bit (Operand, Result) */
 
-		return_desc->integer.value = ~operand[0]->integer.value;
-		break;
+			return_desc->integer.value = operand[0]->integer.value;
 
+			/*
+			 * Acpi specification describes Integer type as a little
+			 * endian unsigned value, so this boundary condition is valid.
+			 */
+			for (temp32 = 0; return_desc->integer.value && temp32 < ACPI_INTEGER_BIT_SIZE; ++temp32) {
+				return_desc->integer.value >>= 1;
+			}
 
-	case AML_FIND_SET_LEFT_BIT_OP:  /* Find_set_left_bit (Operand, Result) */
+			return_desc->integer.value = temp32;
+			break;
 
 
-		return_desc->integer.value = operand[0]->integer.value;
+		case AML_FIND_SET_RIGHT_BIT_OP: /* find_set_right_bit (Operand, Result) */
 
-		/*
-		 * Acpi specification describes Integer type as a little
-		 * endian unsigned value, so this boundary condition is valid.
-		 */
-		for (temp32 = 0; return_desc->integer.value && temp32 < ACPI_INTEGER_BIT_SIZE; ++temp32) {
-			return_desc->integer.value >>= 1;
-		}
+			return_desc->integer.value = operand[0]->integer.value;
 
-		return_desc->integer.value = temp32;
-		break;
+			/*
+			 * The Acpi specification describes Integer type as a little
+			 * endian unsigned value, so this boundary condition is valid.
+			 */
+			for (temp32 = 0; return_desc->integer.value && temp32 < ACPI_INTEGER_BIT_SIZE; ++temp32) {
+				return_desc->integer.value <<= 1;
+			}
 
+			/* Since the bit position is one-based, subtract from 33 (65) */
 
-	case AML_FIND_SET_RIGHT_BIT_OP: /* Find_set_right_bit (Operand, Result) */
+			return_desc->integer.value = temp32 == 0 ? 0 : (ACPI_INTEGER_BIT_SIZE + 1) - temp32;
+			break;
 
 
-		return_desc->integer.value = operand[0]->integer.value;
+		case AML_FROM_BCD_OP:           /* from_bcd (BCDValue, Result) */
 
-		/*
-		 * The Acpi specification describes Integer type as a little
-		 * endian unsigned value, so this boundary condition is valid.
-		 */
-		for (temp32 = 0; return_desc->integer.value && temp32 < ACPI_INTEGER_BIT_SIZE; ++temp32) {
-			return_desc->integer.value <<= 1;
-		}
+			/*
+			 * The 64-bit ACPI integer can hold 16 4-bit BCD characters
+			 * (if table is 32-bit, integer can hold 8 BCD characters)
+			 * Convert each 4-bit BCD value
+			 */
+			power_of_ten = 1;
+			return_desc->integer.value = 0;
+			digit = operand[0]->integer.value;
 
-		/* Since the bit position is one-based, subtract from 33 (65) */
+			/* Convert each BCD digit (each is one nybble wide) */
 
-		return_desc->integer.value = temp32 == 0 ? 0 : (ACPI_INTEGER_BIT_SIZE + 1) - temp32;
-		break;
+			for (i = 0; (i < acpi_gbl_integer_nybble_width) && (digit > 0); i++) {
+				/* Get the least significant 4-bit BCD digit */
 
+				temp32 = ((u32) digit) & 0xF;
 
-	case AML_FROM_BCD_OP:           /* From_bcd (BCDValue, Result) */
+				/* Check the range of the digit */
 
-		/*
-		 * The 64-bit ACPI integer can hold 16 4-bit BCD integers
-		 */
-		return_desc->integer.value = 0;
-		for (i = 0; i < ACPI_MAX_BCD_DIGITS; i++) {
-			/* Get one BCD digit */
+				if (temp32 > 9) {
+					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+						"BCD digit too large (not decimal): 0x%X\n",
+						temp32));
 
-			digit = (acpi_integer) ((operand[0]->integer.value >> (i * 4)) & 0xF);
+					status = AE_AML_NUMERIC_OVERFLOW;
+					goto cleanup;
+				}
 
-			/* Check the range of the digit */
+				/* Sum the digit into the result with the current power of 10 */
 
-			if (digit > 9) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "BCD digit too large: %d\n",
-					(u32) digit));
-				status = AE_AML_NUMERIC_OVERFLOW;
-				goto cleanup;
-			}
+				return_desc->integer.value += (((acpi_integer) temp32) * power_of_ten);
 
-			if (digit > 0) {
-				/* Sum into the result with the appropriate power of 10 */
+				/* Shift to next BCD digit */
 
-				for (j = 0; j < i; j++) {
-					digit *= 10;
-				}
+				digit >>= 4;
 
-				return_desc->integer.value += digit;
+				/* Next power of 10 */
+
+				power_of_ten *= 10;
 			}
-		}
-		break;
+			break;
 
 
-	case AML_TO_BCD_OP:             /* To_bcd (Operand, Result) */
+		case AML_TO_BCD_OP:             /* to_bcd (Operand, Result) */
 
-		if (operand[0]->integer.value > ACPI_MAX_BCD_VALUE) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "BCD overflow: %8.8X%8.8X\n",
-				HIDWORD(operand[0]->integer.value), LODWORD(operand[0]->integer.value)));
-			status = AE_AML_NUMERIC_OVERFLOW;
-			goto cleanup;
-		}
+			return_desc->integer.value = 0;
+			digit = operand[0]->integer.value;
 
-		return_desc->integer.value = 0;
-		for (i = 0; i < ACPI_MAX_BCD_DIGITS; i++) {
-			/* Divide by nth factor of 10 */
+			/* Each BCD digit is one nybble wide */
 
-			temp32 = 0;
-			digit = operand[0]->integer.value;
-			for (j = 0; j < i; j++) {
-				acpi_ut_short_divide (&digit, 10, &digit, &temp32);
+			for (i = 0; (i < acpi_gbl_integer_nybble_width) && (digit > 0); i++) {
+				(void) acpi_ut_short_divide (&digit, 10, &digit, &temp32);
+
+				/* Insert the BCD digit that resides in the remainder from above */
+
+				return_desc->integer.value |= (((acpi_integer) temp32) << (i * 4));
 			}
 
-			/* Create the BCD digit from the remainder above */
+			/* Overflow if there is any data left in Digit */
 
 			if (digit > 0) {
-				return_desc->integer.value += (temp32 << (i * 4));
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Integer too large to convert to BCD: %8.8X%8.8X\n",
+					ACPI_HIDWORD(operand[0]->integer.value),
+					ACPI_LODWORD(operand[0]->integer.value)));
+				status = AE_AML_NUMERIC_OVERFLOW;
+				goto cleanup;
 			}
-		}
-		break;
+			break;
 
 
-	case AML_COND_REF_OF_OP:        /* Cond_ref_of (Source_object, Result) */
+		case AML_COND_REF_OF_OP:        /* cond_ref_of (source_object, Result) */
 
-		/*
-		 * This op is a little strange because the internal return value is
-		 * different than the return value stored in the result descriptor
-		 * (There are really two return values)
-		 */
-		if ((acpi_namespace_node *) operand[0] == acpi_gbl_root_node) {
 			/*
-			 * This means that the object does not exist in the namespace,
-			 * return FALSE
+			 * This op is a little strange because the internal return value is
+			 * different than the return value stored in the result descriptor
+			 * (There are really two return values)
 			 */
-			return_desc->integer.value = 0;
+			if ((struct acpi_namespace_node *) operand[0] == acpi_gbl_root_node) {
+				/*
+				 * This means that the object does not exist in the namespace,
+				 * return FALSE
+				 */
+				return_desc->integer.value = 0;
+				goto cleanup;
+			}
 
-			/*
-			 * Must delete the result descriptor since there is no reference
-			 * being returned
-			 */
-			acpi_ut_remove_reference (operand[1]);
-			goto cleanup;
-		}
+			/* Get the object reference, store it, and remove our reference */
 
-		/* Get the object reference and store it */
+			status = acpi_ex_get_object_reference (operand[0], &return_desc2, walk_state);
+			if (ACPI_FAILURE (status)) {
+				goto cleanup;
+			}
 
-		status = acpi_ex_get_object_reference (operand[0], &return_desc2, walk_state);
-		if (ACPI_FAILURE (status)) {
-			goto cleanup;
-		}
+			status = acpi_ex_store (return_desc2, operand[1], walk_state);
+			acpi_ut_remove_reference (return_desc2);
 
-		status = acpi_ex_store (return_desc2, operand[1], walk_state);
+			/* The object exists in the namespace, return TRUE */
 
-		/* The object exists in the namespace, return TRUE */
+			return_desc->integer.value = ACPI_INTEGER_MAX;
+			goto cleanup;
 
-		return_desc->integer.value = ACPI_INTEGER_MAX;
-		goto cleanup;
+
+		default:
+			/* No other opcodes get here */
+			break;
+		}
 		break;
 
 
@@ -386,16 +410,19 @@ acpi_ex_opcode_1A_1T_1R (
 			return_ACPI_STATUS (status);
 		}
 
-		/*
-		 * Normally, we would remove a reference on the Operand[0] parameter;
-		 * But since it is being used as the internal return object
-		 * (meaning we would normally increment it), the two cancel out,
-		 * and we simply don't do anything.
-		 */
-		walk_state->result_obj = operand[0];
-		walk_state->operands[0] = NULL; /* Prevent deletion */
+		/* It is possible that the Store already produced a return object */
+
+		if (!walk_state->result_obj) {
+			/*
+			 * Normally, we would remove a reference on the Operand[0] parameter;
+			 * But since it is being used as the internal return object
+			 * (meaning we would normally increment it), the two cancel out,
+			 * and we simply don't do anything.
+			 */
+			walk_state->result_obj = operand[0];
+			walk_state->operands[0] = NULL; /* Prevent deletion */
+		}
 		return_ACPI_STATUS (status);
-		break;
 
 
 	/*
@@ -403,58 +430,54 @@ acpi_ex_opcode_1A_1T_1R (
 	 */
 	case AML_COPY_OP:               /* Copy (Source, Target) */
 
-		status = AE_NOT_IMPLEMENTED;
-		goto cleanup;
+		status = acpi_ut_copy_iobject_to_iobject (operand[0], &return_desc, walk_state);
 		break;
 
 
-	case AML_TO_DECSTRING_OP:       /* To_decimal_string (Data, Result) */
+	case AML_TO_DECSTRING_OP:       /* to_decimal_string (Data, Result) */
 
 		status = acpi_ex_convert_to_string (operand[0], &return_desc, 10, ACPI_UINT32_MAX, walk_state);
 		break;
 
 
-	case AML_TO_HEXSTRING_OP:       /* To_hex_string (Data, Result) */
+	case AML_TO_HEXSTRING_OP:       /* to_hex_string (Data, Result) */
 
 		status = acpi_ex_convert_to_string (operand[0], &return_desc, 16, ACPI_UINT32_MAX, walk_state);
 		break;
 
 
-	case AML_TO_BUFFER_OP:          /* To_buffer (Data, Result) */
+	case AML_TO_BUFFER_OP:          /* to_buffer (Data, Result) */
 
 		status = acpi_ex_convert_to_buffer (operand[0], &return_desc, walk_state);
 		break;
 
 
-	case AML_TO_INTEGER_OP:         /* To_integer (Data, Result) */
+	case AML_TO_INTEGER_OP:         /* to_integer (Data, Result) */
 
 		status = acpi_ex_convert_to_integer (operand[0], &return_desc, walk_state);
 		break;
 
 
-	/*
-	 * These are two obsolete opcodes
-	 */
-	case AML_SHIFT_LEFT_BIT_OP:     /*  Shift_left_bit (Source, Bit_num) */
-	case AML_SHIFT_RIGHT_BIT_OP:    /*  Shift_right_bit (Source, Bit_num) */
-
+	case AML_SHIFT_LEFT_BIT_OP:     /*  shift_left_bit (Source, bit_num) */
+	case AML_SHIFT_RIGHT_BIT_OP:    /*  shift_right_bit (Source, bit_num) */
 
+		/*
+		 * These are two obsolete opcodes
+		 */
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "%s is obsolete and not implemented\n",
 				  acpi_ps_get_opcode_name (walk_state->opcode)));
 		status = AE_SUPPORT;
 		goto cleanup;
-		break;
 
 
 	default:                        /* Unknown opcode */
 
-		REPORT_ERROR (("Acpi_ex_opcode_1A_1T_1R: Unknown opcode %X\n",
+		ACPI_REPORT_ERROR (("acpi_ex_opcode_1A_1T_1R: Unknown opcode %X\n",
 			walk_state->opcode));
 		status = AE_AML_BAD_OPCODE;
 		goto cleanup;
 	}
 
-
 	/*
 	 * Store the return value computed above into the target object
 	 */
@@ -463,7 +486,9 @@ acpi_ex_opcode_1A_1T_1R (
 
 cleanup:
 
-	walk_state->result_obj = return_desc;
+	if (!walk_state->result_obj) {
+		walk_state->result_obj = return_desc;
+	}
 
 	/* Delete return object on error */
 
@@ -477,9 +502,9 @@ cleanup:
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_opcode_1A_0T_1R
+ * FUNCTION:    acpi_ex_opcode_1A_0T_1R
  *
- * PARAMETERS:  Walk_state          - Current state (contains AML opcode)
+ * PARAMETERS:  walk_state          - Current state (contains AML opcode)
  *
  * RETURN:      Status
  *
@@ -489,23 +514,22 @@ cleanup:
 
 acpi_status
 acpi_ex_opcode_1A_0T_1R (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_operand_object     **operand = &walk_state->operands[0];
-	acpi_operand_object     *temp_desc;
-	acpi_operand_object     *return_desc = NULL;
-	acpi_status             status = AE_OK;
-	u32                     type;
-	acpi_integer            value;
+	union acpi_operand_object       **operand = &walk_state->operands[0];
+	union acpi_operand_object       *temp_desc;
+	union acpi_operand_object       *return_desc = NULL;
+	acpi_status                     status = AE_OK;
+	u32                             type;
+	acpi_integer                    value;
 
 
-	FUNCTION_TRACE_STR ("Ex_opcode_1A_0T_0R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_1A_0T_0R", acpi_ps_get_opcode_name (walk_state->opcode));
 
 
-	/* Get the operand and decode the opcode */
+	/* Examine the AML opcode */
 
 	switch (walk_state->opcode) {
-
 	case AML_LNOT_OP:               /* LNot (Operand) */
 
 		return_desc = acpi_ut_create_internal_object (ACPI_TYPE_INTEGER);
@@ -523,18 +547,18 @@ acpi_ex_opcode_1A_0T_1R (
 
 		/*
 		 * Since we are expecting a Reference operand, it
-		 * can be either a Node or an internal object.
+		 * can be either a NS Node or an internal object.
 		 */
 		return_desc = operand[0];
-		if (VALID_DESCRIPTOR_TYPE (operand[0], ACPI_DESC_TYPE_INTERNAL)) {
+		if (ACPI_GET_DESCRIPTOR_TYPE (operand[0]) == ACPI_DESC_TYPE_OPERAND) {
 			/* Internal reference object - prevent deletion */
 
 			acpi_ut_add_reference (return_desc);
 		}
 
 		/*
-		 * Convert the Return_desc Reference to a Number
-		 * (This removes a reference on the Return_desc object)
+		 * Convert the return_desc Reference to a Number
+		 * (This removes a reference on the return_desc object)
 		 */
 		status = acpi_ex_resolve_operands (AML_LNOT_OP, &return_desc, walk_state);
 		if (ACPI_FAILURE (status)) {
@@ -545,7 +569,7 @@ acpi_ex_opcode_1A_0T_1R (
 		}
 
 		/*
-		 * Return_desc is now guaranteed to be an Integer object
+		 * return_desc is now guaranteed to be an Integer object
 		 * Do the actual increment or decrement
 		 */
 		if (AML_INCREMENT_OP == walk_state->opcode) {
@@ -561,83 +585,13 @@ acpi_ex_opcode_1A_0T_1R (
 		break;
 
 
-	case AML_TYPE_OP:               /* Object_type (Source_object) */
-
-		if (INTERNAL_TYPE_REFERENCE == operand[0]->common.type) {
-			/*
-			 * Not a Name -- an indirect name pointer would have
-			 * been converted to a direct name pointer in Resolve_operands
-			 */
-			switch (operand[0]->reference.opcode) {
-			case AML_ZERO_OP:
-			case AML_ONE_OP:
-			case AML_ONES_OP:
-			case AML_REVISION_OP:
-
-				/* Constants are of type Integer */
-
-				type = ACPI_TYPE_INTEGER;
-				break;
-
+	case AML_TYPE_OP:               /* object_type (source_object) */
 
-			case AML_DEBUG_OP:
-
-				/* Per 1.0b spec, Debug object is of type "Debug_object" */
-
-				type = ACPI_TYPE_DEBUG_OBJECT;
-				break;
-
-
-			case AML_INDEX_OP:
-
-				/* Get the type of this reference (index into another object) */
-
-				type = operand[0]->reference.target_type;
-				if (type == ACPI_TYPE_PACKAGE) {
-					/*
-					 * The main object is a package, we want to get the type
-					 * of the individual package element that is referenced by
-					 * the index.
-					 */
-					type = (*(operand[0]->reference.where))->common.type;
-				}
-
-				break;
-
-
-			case AML_LOCAL_OP:
-			case AML_ARG_OP:
-
-				type = acpi_ds_method_data_get_type (operand[0]->reference.opcode,
-						  operand[0]->reference.offset, walk_state);
-				break;
-
-
-			default:
-
-				REPORT_ERROR (("Acpi_ex_opcode_1A_0T_1R/Type_op: Internal error - Unknown Reference subtype %X\n",
-					operand[0]->reference.opcode));
-				status = AE_AML_INTERNAL;
-				goto cleanup;
-			}
-		}
-
-		else {
-			/*
-			 * It's not a Reference, so it must be a direct name pointer.
-			 */
-			type = acpi_ns_get_type ((acpi_namespace_node *) operand[0]);
-
-			/* Convert internal types to external types */
-
-			switch (type) {
-			case INTERNAL_TYPE_REGION_FIELD:
-			case INTERNAL_TYPE_BANK_FIELD:
-			case INTERNAL_TYPE_INDEX_FIELD:
-
-				type = ACPI_TYPE_FIELD_UNIT;
-			}
+		/* Get the type of the base object */
 
+		status = acpi_ex_resolve_multiple (walk_state, operand[0], &type, NULL);
+		if (ACPI_FAILURE (status)) {
+			goto cleanup;
 		}
 
 		/* Allocate a descriptor to hold the type. */
@@ -652,44 +606,38 @@ acpi_ex_opcode_1A_0T_1R (
 		break;
 
 
-	case AML_SIZE_OF_OP:            /* Size_of (Source_object) */
+	case AML_SIZE_OF_OP:            /* size_of (source_object) */
 
-		temp_desc = operand[0];
-		if (VALID_DESCRIPTOR_TYPE (operand[0], ACPI_DESC_TYPE_NAMED)) {
-			temp_desc = acpi_ns_get_attached_object ((acpi_namespace_node *) operand[0]);
-		}
+		/* Get the base object */
 
-		if (!temp_desc) {
-			value = 0;
+		status = acpi_ex_resolve_multiple (walk_state, operand[0], &type, &temp_desc);
+		if (ACPI_FAILURE (status)) {
+			goto cleanup;
 		}
 
-		else {
-			switch (temp_desc->common.type) {
-			case ACPI_TYPE_BUFFER:
-				value = temp_desc->buffer.length;
-				break;
-
-			case ACPI_TYPE_STRING:
-				value = temp_desc->string.length;
-				break;
-
-			case ACPI_TYPE_PACKAGE:
-				value = temp_desc->package.count;
-				break;
-
-			case INTERNAL_TYPE_REFERENCE:
-
-				/* TBD: this must be a reference to a buf/str/pkg?? */
-
-				value = 4;
-				break;
-
-			default:
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Not Buf/Str/Pkg - found type %X\n",
-					temp_desc->common.type));
-				status = AE_AML_OPERAND_TYPE;
-				goto cleanup;
-			}
+		/*
+		 * Type is guaranteed to be a buffer, string, or package at this
+		 * point (even if the original operand was an object reference, it
+		 * will be resolved and typechecked during operand resolution.)
+		 */
+		switch (type) {
+		case ACPI_TYPE_BUFFER:
+			value = temp_desc->buffer.length;
+			break;
+
+		case ACPI_TYPE_STRING:
+			value = temp_desc->string.length;
+			break;
+
+		case ACPI_TYPE_PACKAGE:
+			value = temp_desc->package.count;
+			break;
+
+		default:
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "size_of, Not Buf/Str/Pkg - found type %s\n",
+				acpi_ut_get_type_name (type)));
+			status = AE_AML_OPERAND_TYPE;
+			goto cleanup;
 		}
 
 		/*
@@ -706,7 +654,7 @@ acpi_ex_opcode_1A_0T_1R (
 		break;
 
 
-	case AML_REF_OF_OP:             /* Ref_of (Source_object) */
+	case AML_REF_OF_OP:             /* ref_of (source_object) */
 
 		status = acpi_ex_get_object_reference (operand[0], &return_desc, walk_state);
 		if (ACPI_FAILURE (status)) {
@@ -715,79 +663,113 @@ acpi_ex_opcode_1A_0T_1R (
 		break;
 
 
-	case AML_DEREF_OF_OP:           /* Deref_of (Obj_reference) */
+	case AML_DEREF_OF_OP:           /* deref_of (obj_reference | String) */
 
-		/* Check for a method local or argument */
+		/* Check for a method local or argument, or standalone String */
 
-		if (!VALID_DESCRIPTOR_TYPE (operand[0], ACPI_DESC_TYPE_NAMED)) {
-			/*
-			 * Must resolve/dereference the local/arg reference first
-			 */
-			switch (operand[0]->reference.opcode) {
-			/* Set Operand[0] to the value of the local/arg */
+		if (ACPI_GET_DESCRIPTOR_TYPE (operand[0]) != ACPI_DESC_TYPE_NAMED) {
+			switch (ACPI_GET_OBJECT_TYPE (operand[0])) {
+			case ACPI_TYPE_LOCAL_REFERENCE:
+				/*
+				 * This is a deref_of (local_x | arg_x)
+				 *
+				 * Must resolve/dereference the local/arg reference first
+				 */
+				switch (operand[0]->reference.opcode) {
+				case AML_LOCAL_OP:
+				case AML_ARG_OP:
+
+					/* Set Operand[0] to the value of the local/arg */
+
+					status = acpi_ds_method_data_get_value (operand[0]->reference.opcode,
+							 operand[0]->reference.offset, walk_state, &temp_desc);
+					if (ACPI_FAILURE (status)) {
+						goto cleanup;
+					}
 
-			case AML_LOCAL_OP:
-			case AML_ARG_OP:
+					/*
+					 * Delete our reference to the input object and
+					 * point to the object just retrieved
+					 */
+					acpi_ut_remove_reference (operand[0]);
+					operand[0] = temp_desc;
+					break;
 
-				acpi_ds_method_data_get_value (operand[0]->reference.opcode,
-						operand[0]->reference.offset, walk_state, &temp_desc);
+				case AML_REF_OF_OP:
 
-				/*
-				 * Delete our reference to the input object and
-				 * point to the object just retrieved
-				 */
-				acpi_ut_remove_reference (operand[0]);
-				operand[0] = temp_desc;
-				break;
+					/* Get the object to which the reference refers */
 
-			default:
+					temp_desc = operand[0]->reference.object;
+					acpi_ut_remove_reference (operand[0]);
+					operand[0] = temp_desc;
+					break;
 
-				/* Index op - handled below */
-				break;
-			}
-		}
+				default:
 
+					/* Must be an Index op - handled below */
+					break;
+				}
+				break;
 
-		/* Operand[0] may have changed from the code above */
 
-		if (VALID_DESCRIPTOR_TYPE (operand[0], ACPI_DESC_TYPE_NAMED)) {
-			/* Get the actual object from the Node (This is the dereference) */
+			case ACPI_TYPE_STRING:
 
-			return_desc = ((acpi_namespace_node *) operand[0])->object;
+				/*
+				 * This is a deref_of (String). The string is a reference to a named ACPI object.
+				 *
+				 * 1) Find the owning Node
+				 * 2) Dereference the node to an actual object.  Could be a Field, so we nee
+				 *    to resolve the node to a value.
+				 */
+				status = acpi_ns_get_node_by_path (operand[0]->string.pointer,
+						  walk_state->scope_info->scope.node, ACPI_NS_SEARCH_PARENT,
+						  ACPI_CAST_INDIRECT_PTR (struct acpi_namespace_node, &return_desc));
+				if (ACPI_FAILURE (status)) {
+					goto cleanup;
+				}
 
-			/* Returning a pointer to the object, add another reference! */
+				status = acpi_ex_resolve_node_to_value (
+						  ACPI_CAST_INDIRECT_PTR (struct acpi_namespace_node, &return_desc), walk_state);
+				goto cleanup;
 
-			acpi_ut_add_reference (return_desc);
-		}
 
-		else {
-			/*
-			 * This must be a reference object produced by the Index
-			 * ASL operation -- check internal opcode
-			 */
-			if ((operand[0]->reference.opcode != AML_INDEX_OP) &&
-				(operand[0]->reference.opcode != AML_REF_OF_OP)) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown opcode in ref(%p) - %X\n",
-					operand[0], operand[0]->reference.opcode));
+			default:
 
-				status = AE_TYPE;
+				status = AE_AML_OPERAND_TYPE;
 				goto cleanup;
 			}
+		}
 
+		/* Operand[0] may have changed from the code above */
 
+		if (ACPI_GET_DESCRIPTOR_TYPE (operand[0]) == ACPI_DESC_TYPE_NAMED) {
+			/*
+			 * This is a deref_of (object_reference)
+			 * Get the actual object from the Node (This is the dereference).
+			 * -- This case may only happen when a local_x or arg_x is dereferenced above.
+			 */
+			return_desc = acpi_ns_get_attached_object ((struct acpi_namespace_node *) operand[0]);
+		}
+		else {
+			/*
+			 * This must be a reference object produced by either the Index() or
+			 * ref_of() operator
+			 */
 			switch (operand[0]->reference.opcode) {
 			case AML_INDEX_OP:
 
 				/*
-				 * Supported target types for the Index operator are
-				 * 1) A Buffer
-				 * 2) A Package
+				 * The target type for the Index operator must be
+				 * either a Buffer or a Package
 				 */
-				if (operand[0]->reference.target_type == ACPI_TYPE_BUFFER_FIELD) {
+				switch (operand[0]->reference.target_type) {
+				case ACPI_TYPE_BUFFER_FIELD:
+
+					temp_desc = operand[0]->reference.object;
+
 					/*
-					 * The target is a buffer, we must create a new object that
-					 * contains one element of the buffer, the element pointed
-					 * to by the index.
+					 * Create a new object that contains one element of the
+					 * buffer -- the element pointed to by the index.
 					 *
 					 * NOTE: index into a buffer is NOT a pointer to a
 					 * sub-buffer of the main buffer, it is only a pointer to a
@@ -799,20 +781,21 @@ acpi_ex_opcode_1A_0T_1R (
 						goto cleanup;
 					}
 
-					temp_desc = operand[0]->reference.object;
+					/*
+					 * Since we are returning the value of the buffer at the
+					 * indexed location, we don't need to add an additional
+					 * reference to the buffer itself.
+					 */
 					return_desc->integer.value =
 						temp_desc->buffer.pointer[operand[0]->reference.offset];
+					break;
 
-					/* TBD: [Investigate] (see below) Don't add an additional
-					 * ref!
-					 */
-				}
 
-				else if (operand[0]->reference.target_type == ACPI_TYPE_PACKAGE) {
+				case ACPI_TYPE_PACKAGE:
+
 					/*
-					 * The target is a package, we want to return the referenced
-					 * element of the package.  We must add another reference to
-					 * this object, however.
+					 * Return the referenced element of the package.  We must add
+					 * another reference to the referenced object, however.
 					 */
 					return_desc = *(operand[0]->reference.where);
 					if (!return_desc) {
@@ -821,7 +804,6 @@ acpi_ex_opcode_1A_0T_1R (
 						 * an uninitialized package element and is thus a
 						 * severe error.
 						 */
-
 						ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "NULL package element obj %p\n",
 							operand[0]));
 						status = AE_AML_UNINITIALIZED_ELEMENT;
@@ -829,15 +811,16 @@ acpi_ex_opcode_1A_0T_1R (
 					}
 
 					acpi_ut_add_reference (return_desc);
-				}
+					break;
+
+
+				default:
 
-				else {
-					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown Target_type %X in obj %p\n",
+					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown Index target_type %X in obj %p\n",
 						operand[0]->reference.target_type, operand[0]));
 					status = AE_AML_OPERAND_TYPE;
 					goto cleanup;
 				}
-
 				break;
 
 
@@ -845,19 +828,31 @@ acpi_ex_opcode_1A_0T_1R (
 
 				return_desc = operand[0]->reference.object;
 
+				if (ACPI_GET_DESCRIPTOR_TYPE (return_desc) == ACPI_DESC_TYPE_NAMED) {
+
+					return_desc = acpi_ns_get_attached_object ((struct acpi_namespace_node *) return_desc);
+				}
+
 				/* Add another reference to the object! */
 
 				acpi_ut_add_reference (return_desc);
 				break;
+
+
+			default:
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown opcode in ref(%p) - %X\n",
+					operand[0], operand[0]->reference.opcode));
+
+				status = AE_TYPE;
+				goto cleanup;
 			}
 		}
-
 		break;
 
 
 	default:
 
-		REPORT_ERROR (("Acpi_ex_opcode_1A_0T_1R: Unknown opcode %X\n",
+		ACPI_REPORT_ERROR (("acpi_ex_opcode_1A_0T_1R: Unknown opcode %X\n",
 			walk_state->opcode));
 		status = AE_AML_BAD_OPCODE;
 		goto cleanup;
diff -urNp linux-5400/drivers/acpi/executer/exoparg2.c linux-5410/drivers/acpi/executer/exoparg2.c
--- linux-5400/drivers/acpi/executer/exoparg2.c
+++ linux-5410/drivers/acpi/executer/exoparg2.c
@@ -1,40 +1,56 @@
 /******************************************************************************
  *
  * Module Name: exoparg2 - AML execution - opcodes with 2 arguments
- *              $Revision: 97 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
-#include "acnamesp.h"
-#include "acinterp.h"
-#include "acevents.h"
-#include "amlcode.h"
-#include "acdispat.h"
+#include <acpi/acpi.h>
+#include <acpi/acparser.h>
+#include <acpi/acinterp.h>
+#include <acpi/acevents.h>
+#include <acpi/amlcode.h>
 
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("exoparg2")
+	 ACPI_MODULE_NAME    ("exoparg2")
 
 
 /*!
@@ -62,9 +78,9 @@
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_opcode_2A_0T_0R
+ * FUNCTION:    acpi_ex_opcode_2A_0T_0R
  *
- * PARAMETERS:  Walk_state          - Current walk state
+ * PARAMETERS:  walk_state          - Current walk state
  *
  * RETURN:      Status
  *
@@ -77,57 +93,52 @@
 
 acpi_status
 acpi_ex_opcode_2A_0T_0R (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_operand_object     **operand = &walk_state->operands[0];
-	acpi_namespace_node     *node;
-	acpi_status             status = AE_OK;
+	union acpi_operand_object       **operand = &walk_state->operands[0];
+	struct acpi_namespace_node      *node;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE_STR ("Ex_opcode_2A_0T_0R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_2A_0T_0R",
+			acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	/* Examine the opcode */
 
 	switch (walk_state->opcode) {
-
-	case AML_NOTIFY_OP:         /* Notify (Notify_object, Notify_value) */
+	case AML_NOTIFY_OP:         /* Notify (notify_object, notify_value) */
 
 		/* The first operand is a namespace node */
 
-		node = (acpi_namespace_node *) operand[0];
+		node = (struct acpi_namespace_node *) operand[0];
 
-		/* The node must refer to a device or thermal zone */
+		/* Notifies allowed on this object? */
 
-		if (node && operand[1])     /* TBD: is this check necessary? */ {
-			switch (node->type) {
-			case ACPI_TYPE_DEVICE:
-			case ACPI_TYPE_THERMAL:
-
-				/*
-				 * Dispatch the notify to the appropriate handler
-				 * NOTE: the request is queued for execution after this method
-				 * completes.  The notify handlers are NOT invoked synchronously
-				 * from this thread -- because handlers may in turn run other
-				 * control methods.
-				 */
-				status = acpi_ev_queue_notify_request (node,
-						 (u32) operand[1]->integer.value);
-				break;
-
-			default:
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unexpected notify object type %X\n",
-					node->type));
+		if (!acpi_ev_is_notify_object (node)) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unexpected notify object type [%s]\n",
+					acpi_ut_get_type_name (node->type)));
 
-				status = AE_AML_OPERAND_TYPE;
-				break;
-			}
+			status = AE_AML_OPERAND_TYPE;
+			break;
 		}
+
+		/*
+		 * Dispatch the notify to the appropriate handler
+		 * NOTE: the request is queued for execution after this method
+		 * completes.  The notify handlers are NOT invoked synchronously
+		 * from this thread -- because handlers may in turn run other
+		 * control methods.
+		 */
+		status = acpi_ev_queue_notify_request (node,
+				  (u32) operand[1]->integer.value);
 		break;
 
+
 	default:
 
-		REPORT_ERROR (("Acpi_ex_opcode_2A_0T_0R: Unknown opcode %X\n", walk_state->opcode));
+		ACPI_REPORT_ERROR (("acpi_ex_opcode_2A_0T_0R: Unknown opcode %X\n",
+				walk_state->opcode));
 		status = AE_AML_BAD_OPCODE;
 	}
 
@@ -137,9 +148,9 @@ acpi_ex_opcode_2A_0T_0R (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_opcode_2A_2T_1R
+ * FUNCTION:    acpi_ex_opcode_2A_2T_1R
  *
- * PARAMETERS:  Walk_state          - Current walk state
+ * PARAMETERS:  walk_state          - Current walk state
  *
  * RETURN:      Status
  *
@@ -150,22 +161,22 @@ acpi_ex_opcode_2A_0T_0R (
 
 acpi_status
 acpi_ex_opcode_2A_2T_1R (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_operand_object     **operand = &walk_state->operands[0];
-	acpi_operand_object     *return_desc1 = NULL;
-	acpi_operand_object     *return_desc2 = NULL;
-	acpi_status             status;
+	union acpi_operand_object       **operand = &walk_state->operands[0];
+	union acpi_operand_object       *return_desc1 = NULL;
+	union acpi_operand_object       *return_desc2 = NULL;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE_STR ("Ex_opcode_2A_2T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_2A_2T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	/*
 	 * Execute the opcode
 	 */
 	switch (walk_state->opcode) {
-	case AML_DIVIDE_OP:             /* Divide (Dividend, Divisor, Remainder_result Quotient_result) */
+	case AML_DIVIDE_OP:             /* Divide (Dividend, Divisor, remainder_result quotient_result) */
 
 		return_desc1 = acpi_ut_create_internal_object (ACPI_TYPE_INTEGER);
 		if (!return_desc1) {
@@ -179,7 +190,7 @@ acpi_ex_opcode_2A_2T_1R (
 			goto cleanup;
 		}
 
-		/* Quotient to Return_desc1, remainder to Return_desc2 */
+		/* Quotient to return_desc1, remainder to return_desc2 */
 
 		status = acpi_ut_divide (&operand[0]->integer.value, &operand[1]->integer.value,
 				   &return_desc1->integer.value, &return_desc2->integer.value);
@@ -191,11 +202,10 @@ acpi_ex_opcode_2A_2T_1R (
 
 	default:
 
-		REPORT_ERROR (("Acpi_ex_opcode_2A_2T_1R: Unknown opcode %X\n",
+		ACPI_REPORT_ERROR (("acpi_ex_opcode_2A_2T_1R: Unknown opcode %X\n",
 				walk_state->opcode));
 		status = AE_AML_BAD_OPCODE;
 		goto cleanup;
-		break;
 	}
 
 
@@ -235,9 +245,9 @@ cleanup:
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_opcode_2A_1T_1R
+ * FUNCTION:    acpi_ex_opcode_2A_1T_1R
  *
- * PARAMETERS:  Walk_state          - Current walk state
+ * PARAMETERS:  walk_state          - Current walk state
  *
  * RETURN:      Status
  *
@@ -248,16 +258,17 @@ cleanup:
 
 acpi_status
 acpi_ex_opcode_2A_1T_1R (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_operand_object     **operand   = &walk_state->operands[0];
-	acpi_operand_object     *return_desc = NULL;
-	acpi_operand_object     *temp_desc;
-	u32                     index;
-	acpi_status             status      = AE_OK;
+	union acpi_operand_object       **operand = &walk_state->operands[0];
+	union acpi_operand_object       *return_desc = NULL;
+	union acpi_operand_object       *temp_desc = NULL;
+	u32                             index;
+	acpi_status                     status = AE_OK;
+	acpi_size                       length;
 
 
-	FUNCTION_TRACE_STR ("Ex_opcode_2A_1T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_2A_1T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	/*
@@ -280,7 +291,7 @@ acpi_ex_opcode_2A_1T_1R (
 
 
 	switch (walk_state->opcode) {
-	case AML_MOD_OP:                /* Mod (Dividend, Divisor, Remainder_result (ACPI 2.0) */
+	case AML_MOD_OP:                /* Mod (Dividend, Divisor, remainder_result (ACPI 2.0) */
 
 		return_desc = acpi_ut_create_internal_object (ACPI_TYPE_INTEGER);
 		if (!return_desc) {
@@ -288,11 +299,10 @@ acpi_ex_opcode_2A_1T_1R (
 			goto cleanup;
 		}
 
-		/* Return_desc will contain the remainder */
+		/* return_desc will contain the remainder */
 
 		status = acpi_ut_divide (&operand[0]->integer.value, &operand[1]->integer.value,
 				  NULL, &return_desc->integer.value);
-
 		break;
 
 
@@ -305,17 +315,17 @@ acpi_ex_opcode_2A_1T_1R (
 		 * guaranteed to be either Integer/String/Buffer by the operand
 		 * resolution mechanism above.
 		 */
-		switch (operand[0]->common.type) {
+		switch (ACPI_GET_OBJECT_TYPE (operand[0])) {
 		case ACPI_TYPE_INTEGER:
-			status = acpi_ex_convert_to_integer (operand[1], &operand[1], walk_state);
+			status = acpi_ex_convert_to_integer (operand[1], &temp_desc, walk_state);
 			break;
 
 		case ACPI_TYPE_STRING:
-			status = acpi_ex_convert_to_string (operand[1], &operand[1], 16, ACPI_UINT32_MAX, walk_state);
+			status = acpi_ex_convert_to_string (operand[1], &temp_desc, 16, ACPI_UINT32_MAX, walk_state);
 			break;
 
 		case ACPI_TYPE_BUFFER:
-			status = acpi_ex_convert_to_buffer (operand[1], &operand[1], walk_state);
+			status = acpi_ex_convert_to_buffer (operand[1], &temp_desc, walk_state);
 			break;
 
 		default:
@@ -331,20 +341,69 @@ acpi_ex_opcode_2A_1T_1R (
 		 * (Both are Integer, String, or Buffer), and we can now perform the
 		 * concatenation.
 		 */
-		status = acpi_ex_do_concatenate (operand[0], operand[1], &return_desc, walk_state);
+		status = acpi_ex_do_concatenate (operand[0], temp_desc, &return_desc, walk_state);
+		if (temp_desc != operand[1]) {
+			acpi_ut_remove_reference (temp_desc);
+		}
 		break;
 
 
-	case AML_TO_STRING_OP:          /* To_string (Buffer, Length, Result) (ACPI 2.0) */
+	case AML_TO_STRING_OP:          /* to_string (Buffer, Length, Result) (ACPI 2.0) */
+
+		/*
+		 * Input object is guaranteed to be a buffer at this point (it may have
+		 * been converted.)  Copy the raw buffer data to a new object of type String.
+		 */
+
+		/* Get the length of the new string */
+
+		length = 0;
+		if (operand[1]->integer.value == 0) {
+			/* Handle optional length value */
+
+			operand[1]->integer.value = ACPI_INTEGER_MAX;
+		}
+
+		while ((length < operand[0]->buffer.length) &&
+			   (length < operand[1]->integer.value) &&
+			   (operand[0]->buffer.pointer[length])) {
+			length++;
+		}
+
+		if (length > ACPI_MAX_STRING_CONVERSION) {
+			status = AE_AML_STRING_LIMIT;
+			goto cleanup;
+		}
+
+		/* Create the internal return object */
 
-		status = acpi_ex_convert_to_string (operand[0], &return_desc, 16,
-				  (u32) operand[1]->integer.value, walk_state);
+		return_desc = acpi_ut_create_internal_object (ACPI_TYPE_STRING);
+		if (!return_desc) {
+			status = AE_NO_MEMORY;
+			goto cleanup;
+		}
+
+		/* Allocate a new string buffer (Length + 1 for null terminator) */
+
+		return_desc->string.pointer = ACPI_MEM_CALLOCATE (length + 1);
+		if (!return_desc->string.pointer) {
+			status = AE_NO_MEMORY;
+			goto cleanup;
+		}
+
+		/* Copy the raw buffer data with no transform */
+
+		ACPI_MEMCPY (return_desc->string.pointer, operand[0]->buffer.pointer, length);
+
+		/* Set the string length */
+
+		return_desc->string.length = (u32) length;
 		break;
 
 
-	case AML_CONCAT_RES_OP:         /* Concatenate_res_template (Buffer, Buffer, Result) (ACPI 2.0) */
+	case AML_CONCAT_RES_OP:         /* concatenate_res_template (Buffer, Buffer, Result) (ACPI 2.0) */
 
-		status = AE_NOT_IMPLEMENTED;
+		status = acpi_ex_concat_template (operand[0], operand[1], &return_desc, walk_state);
 		break;
 
 
@@ -352,7 +411,7 @@ acpi_ex_opcode_2A_1T_1R (
 
 		/* Create the internal return object */
 
-		return_desc = acpi_ut_create_internal_object (INTERNAL_TYPE_REFERENCE);
+		return_desc = acpi_ut_create_internal_object (ACPI_TYPE_LOCAL_REFERENCE);
 		if (!return_desc) {
 			status = AE_NO_MEMORY;
 			goto cleanup;
@@ -363,73 +422,52 @@ acpi_ex_opcode_2A_1T_1R (
 		/*
 		 * At this point, the Source operand is either a Package or a Buffer
 		 */
-		if (operand[0]->common.type == ACPI_TYPE_PACKAGE) {
+		if (ACPI_GET_OBJECT_TYPE (operand[0]) == ACPI_TYPE_PACKAGE) {
 			/* Object to be indexed is a Package */
 
 			if (index >= operand[0]->package.count) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Index value beyond package end\n"));
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Index value (%X) beyond package end (%X)\n",
+					index, operand[0]->package.count));
 				status = AE_AML_PACKAGE_LIMIT;
 				goto cleanup;
 			}
 
-			if ((operand[2]->common.type == INTERNAL_TYPE_REFERENCE) &&
-				(operand[2]->reference.opcode == AML_ZERO_OP)) {
-				/*
-				 * There is no actual result descriptor (the Zero_op Result
-				 * descriptor is a placeholder), so just delete the placeholder and
-				 * return a reference to the package element
-				 */
-				acpi_ut_remove_reference (operand[2]);
-			}
-
-			else {
-				/*
-				 * Each element of the package is an internal object.  Get the one
-				 * we are after.
-				 */
-				temp_desc                        = operand[0]->package.elements [index];
-				return_desc->reference.opcode    = AML_INDEX_OP;
-				return_desc->reference.target_type = temp_desc->common.type;
-				return_desc->reference.object    = temp_desc;
-
-				status = acpi_ex_store (return_desc, operand[2], walk_state);
-				return_desc->reference.object    = NULL;
-			}
-
-			/*
-			 * The local return object must always be a reference to the package element,
-			 * not the element itself.
-			 */
-			return_desc->reference.opcode    = AML_INDEX_OP;
 			return_desc->reference.target_type = ACPI_TYPE_PACKAGE;
+			return_desc->reference.object    = operand[0]->package.elements [index];
 			return_desc->reference.where     = &operand[0]->package.elements [index];
 		}
-
 		else {
 			/* Object to be indexed is a Buffer */
 
 			if (index >= operand[0]->buffer.length) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Index value beyond end of buffer\n"));
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Index value (%X) beyond end of buffer (%X)\n",
+					index, operand[0]->buffer.length));
 				status = AE_AML_BUFFER_LIMIT;
 				goto cleanup;
 			}
 
-			return_desc->reference.opcode      = AML_INDEX_OP;
 			return_desc->reference.target_type = ACPI_TYPE_BUFFER_FIELD;
-			return_desc->reference.object      = operand[0];
-			return_desc->reference.offset      = index;
-
-			status = acpi_ex_store (return_desc, operand[2], walk_state);
+			return_desc->reference.object    = operand[0];
 		}
 
+		/* Complete the Index reference object */
+
+		return_desc->reference.opcode    = AML_INDEX_OP;
+		return_desc->reference.offset    = index;
+
+		/* Store the reference to the Target */
+
+		status = acpi_ex_store (return_desc, operand[2], walk_state);
+
+		/* Return the reference */
+
 		walk_state->result_obj = return_desc;
 		goto cleanup;
-		break;
 
 
 	default:
 
-		REPORT_ERROR (("Acpi_ex_opcode_2A_1T_1R: Unknown opcode %X\n",
+		ACPI_REPORT_ERROR (("acpi_ex_opcode_2A_1T_1R: Unknown opcode %X\n",
 				walk_state->opcode));
 		status = AE_AML_BAD_OPCODE;
 		break;
@@ -440,7 +478,7 @@ store_result_to_target:
 
 	if (ACPI_SUCCESS (status)) {
 		/*
-		 * Store the result of the operation (which is now in Return_desc) into
+		 * Store the result of the operation (which is now in return_desc) into
 		 * the Target descriptor.
 		 */
 		status = acpi_ex_store (return_desc, operand[2], walk_state);
@@ -448,7 +486,9 @@ store_result_to_target:
 			goto cleanup;
 		}
 
-		walk_state->result_obj = return_desc;
+		if (!walk_state->result_obj) {
+			walk_state->result_obj = return_desc;
+		}
 	}
 
 
@@ -466,9 +506,9 @@ cleanup:
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_opcode_2A_0T_1R
+ * FUNCTION:    acpi_ex_opcode_2A_0T_1R
  *
- * PARAMETERS:  Walk_state          - Current walk state
+ * PARAMETERS:  walk_state          - Current walk state
  *
  * RETURN:      Status
  *
@@ -478,15 +518,15 @@ cleanup:
 
 acpi_status
 acpi_ex_opcode_2A_0T_1R (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_operand_object     **operand = &walk_state->operands[0];
-	acpi_operand_object     *return_desc = NULL;
-	acpi_status             status = AE_OK;
-	u8                      logical_result = FALSE;
+	union acpi_operand_object       **operand = &walk_state->operands[0];
+	union acpi_operand_object       *return_desc = NULL;
+	acpi_status                     status = AE_OK;
+	u8                              logical_result = FALSE;
 
 
-	FUNCTION_TRACE_STR ("Ex_opcode_2A_0T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_2A_0T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	/* Create the internal return object */
@@ -500,7 +540,7 @@ acpi_ex_opcode_2A_0T_1R (
 	/*
 	 * Execute the Opcode
 	 */
-	if (walk_state->op_info->flags & AML_LOGICAL) /* Logical_op (Operand0, Operand1) */ {
+	if (walk_state->op_info->flags & AML_LOGICAL) /* logical_op (Operand0, Operand1) */ {
 		logical_result = acpi_ex_do_logical_op (walk_state->opcode,
 				 operand[0]->integer.value,
 				 operand[1]->integer.value);
@@ -509,7 +549,7 @@ acpi_ex_opcode_2A_0T_1R (
 
 
 	switch (walk_state->opcode) {
-	case AML_ACQUIRE_OP:            /* Acquire (Mutex_object, Timeout) */
+	case AML_ACQUIRE_OP:            /* Acquire (mutex_object, Timeout) */
 
 		status = acpi_ex_acquire_mutex (operand[1], operand[0], walk_state);
 		if (status == AE_TIME) {
@@ -519,7 +559,7 @@ acpi_ex_opcode_2A_0T_1R (
 		break;
 
 
-	case AML_WAIT_OP:               /* Wait (Event_object, Timeout) */
+	case AML_WAIT_OP:               /* Wait (event_object, Timeout) */
 
 		status = acpi_ex_system_wait_event (operand[1], operand[0]);
 		if (status == AE_TIME) {
@@ -531,16 +571,16 @@ acpi_ex_opcode_2A_0T_1R (
 
 	default:
 
-		REPORT_ERROR (("Acpi_ex_opcode_2A_0T_1R: Unknown opcode %X\n", walk_state->opcode));
+		ACPI_REPORT_ERROR (("acpi_ex_opcode_2A_0T_1R: Unknown opcode %X\n",
+			walk_state->opcode));
 		status = AE_AML_BAD_OPCODE;
 		goto cleanup;
-		break;
 	}
 
 
 store_logical_result:
 	/*
-	 * Set return value to according to Logical_result. logical TRUE (all ones)
+	 * Set return value to according to logical_result. logical TRUE (all ones)
 	 * Default is FALSE (zero)
 	 */
 	if (logical_result) {
diff -urNp linux-5400/drivers/acpi/executer/exoparg3.c linux-5410/drivers/acpi/executer/exoparg3.c
--- linux-5400/drivers/acpi/executer/exoparg3.c
+++ linux-5410/drivers/acpi/executer/exoparg3.c
@@ -2,37 +2,55 @@
 /******************************************************************************
  *
  * Module Name: exoparg3 - AML execution - opcodes with 3 arguments
- *              $Revision: 3 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acinterp.h"
-#include "acparser.h"
-#include "amlcode.h"
+#include <acpi/acpi.h>
+#include <acpi/acinterp.h>
+#include <acpi/acparser.h>
+#include <acpi/amlcode.h>
 
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("exoparg3")
+	 ACPI_MODULE_NAME    ("exoparg3")
 
 
 /*!
@@ -60,9 +78,9 @@
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_opcode_3A_0T_0R
+ * FUNCTION:    acpi_ex_opcode_3A_0T_0R
  *
- * PARAMETERS:  Walk_state          - Current walk state
+ * PARAMETERS:  walk_state          - Current walk state
  *
  * RETURN:      Status
  *
@@ -72,27 +90,27 @@
 
 acpi_status
 acpi_ex_opcode_3A_0T_0R (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_operand_object     **operand = &walk_state->operands[0];
-	ACPI_SIGNAL_FATAL_INFO  *fatal;
-	acpi_status             status = AE_OK;
+	union acpi_operand_object       **operand = &walk_state->operands[0];
+	struct acpi_signal_fatal_info   *fatal;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE_STR ("Ex_opcode_3A_0T_0R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_3A_0T_0R", acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	switch (walk_state->opcode) {
 
-	case AML_FATAL_OP:          /* Fatal (Fatal_type Fatal_code Fatal_arg)   */
+	case AML_FATAL_OP:          /* Fatal (fatal_type fatal_code fatal_arg)   */
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-			"Fatal_op: Type %x Code %x Arg %x <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n",
+			"fatal_op: Type %X Code %X Arg %X <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n",
 			(u32) operand[0]->integer.value, (u32) operand[1]->integer.value,
 			(u32) operand[2]->integer.value));
 
 
-		fatal = ACPI_MEM_ALLOCATE (sizeof (ACPI_SIGNAL_FATAL_INFO));
+		fatal = ACPI_MEM_ALLOCATE (sizeof (struct acpi_signal_fatal_info));
 		if (fatal) {
 			fatal->type     = (u32) operand[0]->integer.value;
 			fatal->code     = (u32) operand[1]->integer.value;
@@ -102,7 +120,7 @@ acpi_ex_opcode_3A_0T_0R (
 		/*
 		 * Always signal the OS!
 		 */
-		acpi_os_signal (ACPI_SIGNAL_FATAL, fatal);
+		status = acpi_os_signal (ACPI_SIGNAL_FATAL, fatal);
 
 		/* Might return while OS is shutting down, just continue */
 
@@ -112,11 +130,10 @@ acpi_ex_opcode_3A_0T_0R (
 
 	default:
 
-		REPORT_ERROR (("Acpi_ex_opcode_3A_0T_0R: Unknown opcode %X\n",
+		ACPI_REPORT_ERROR (("acpi_ex_opcode_3A_0T_0R: Unknown opcode %X\n",
 				walk_state->opcode));
 		status = AE_AML_BAD_OPCODE;
 		goto cleanup;
-		break;
 	}
 
 
@@ -128,9 +145,9 @@ cleanup:
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_opcode_3A_1T_1R
+ * FUNCTION:    acpi_ex_opcode_3A_1T_1R
  *
- * PARAMETERS:  Walk_state          - Current walk state
+ * PARAMETERS:  walk_state          - Current walk state
  *
  * RETURN:      Status
  *
@@ -140,17 +157,17 @@ cleanup:
 
 acpi_status
 acpi_ex_opcode_3A_1T_1R (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_operand_object     **operand = &walk_state->operands[0];
-	acpi_operand_object     *return_desc = NULL;
-	char                    *buffer;
-	acpi_status             status = AE_OK;
-	u32                     index;
-	u32                     length;
+	union acpi_operand_object       **operand = &walk_state->operands[0];
+	union acpi_operand_object       *return_desc = NULL;
+	char                            *buffer;
+	acpi_status                     status = AE_OK;
+	acpi_native_uint                index;
+	acpi_size                       length;
 
 
-	FUNCTION_TRACE_STR ("Ex_opcode_3A_1T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_3A_1T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	switch (walk_state->opcode) {
@@ -160,7 +177,7 @@ acpi_ex_opcode_3A_1T_1R (
 		 * Create the return object.  The Source operand is guaranteed to be
 		 * either a String or a Buffer, so just use its type.
 		 */
-		return_desc = acpi_ut_create_internal_object (operand[0]->common.type);
+		return_desc = acpi_ut_create_internal_object (ACPI_GET_OBJECT_TYPE (operand[0]));
 		if (!return_desc) {
 			status = AE_NO_MEMORY;
 			goto cleanup;
@@ -168,8 +185,8 @@ acpi_ex_opcode_3A_1T_1R (
 
 		/* Get the Integer values from the objects */
 
-		index = (u32) operand[1]->integer.value;
-		length = (u32) operand[2]->integer.value;
+		index = (acpi_native_uint) operand[1]->integer.value;
+		length = (acpi_size) operand[2]->integer.value;
 
 		/*
 		 * If the index is beyond the length of the String/Buffer, or if the
@@ -181,37 +198,36 @@ acpi_ex_opcode_3A_1T_1R (
 
 			if ((index + length) >
 				operand[0]->string.length) {
-				length = operand[0]->string.length - index;
+				length = (acpi_size) operand[0]->string.length - index;
 			}
 
 			/* Allocate a new buffer for the String/Buffer */
 
-			buffer = ACPI_MEM_CALLOCATE (length + 1);
+			buffer = ACPI_MEM_CALLOCATE ((acpi_size) length + 1);
 			if (!buffer) {
-				return (AE_NO_MEMORY);
+				status = AE_NO_MEMORY;
+				goto cleanup;
 			}
 
 			/* Copy the portion requested */
 
-			MEMCPY (buffer, operand[0]->string.pointer + index,
-					length);
+			ACPI_MEMCPY (buffer, operand[0]->string.pointer + index,
+					  length);
 
 			/* Set the length of the new String/Buffer */
 
 			return_desc->string.pointer = buffer;
-			return_desc->string.length = length;
+			return_desc->string.length = (u32) length;
 		}
-
 		break;
 
 
 	default:
 
-		REPORT_ERROR (("Acpi_ex_opcode_3A_0T_0R: Unknown opcode %X\n",
+		ACPI_REPORT_ERROR (("acpi_ex_opcode_3A_0T_0R: Unknown opcode %X\n",
 				walk_state->opcode));
 		status = AE_AML_BAD_OPCODE;
 		goto cleanup;
-		break;
 	}
 
 	/* Store the result in the target */
@@ -228,7 +244,9 @@ cleanup:
 
 	/* Set the return object and exit */
 
-	walk_state->result_obj = return_desc;
+	if (!walk_state->result_obj) {
+		walk_state->result_obj = return_desc;
+	}
 	return_ACPI_STATUS (status);
 }
 
diff -urNp linux-5400/drivers/acpi/executer/exoparg6.c linux-5410/drivers/acpi/executer/exoparg6.c
--- linux-5400/drivers/acpi/executer/exoparg6.c
+++ linux-5410/drivers/acpi/executer/exoparg6.c
@@ -2,37 +2,55 @@
 /******************************************************************************
  *
  * Module Name: exoparg6 - AML execution - opcodes with 6 arguments
- *              $Revision: 4 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acinterp.h"
-#include "acparser.h"
-#include "amlcode.h"
+#include <acpi/acpi.h>
+#include <acpi/acinterp.h>
+#include <acpi/acparser.h>
+#include <acpi/amlcode.h>
 
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("exoparg6")
+	 ACPI_MODULE_NAME    ("exoparg6")
 
 
 /*!
@@ -60,11 +78,11 @@
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_do_match
+ * FUNCTION:    acpi_ex_do_match
  *
- * PARAMETERS:  Match_op        - The AML match operand
- *              Package_value   - Value from the target package
- *              Match_value     - Value to be matched
+ * PARAMETERS:  match_op        - The AML match operand
+ *              package_value   - Value from the target package
+ *              match_value     - Value to be matched
  *
  * RETURN:      TRUE if the match is successful, FALSE otherwise
  *
@@ -74,9 +92,9 @@
 
 u8
 acpi_ex_do_match (
-	u32                     match_op,
-	acpi_integer            package_value,
-	acpi_integer            match_value)
+	u32                             match_op,
+	acpi_integer                    package_value,
+	acpi_integer                    match_value)
 {
 
 	switch (match_op) {
@@ -137,9 +155,9 @@ acpi_ex_do_match (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_opcode_6A_0T_1R
+ * FUNCTION:    acpi_ex_opcode_6A_0T_1R
  *
- * PARAMETERS:  Walk_state          - Current walk state
+ * PARAMETERS:  walk_state          - Current walk state
  *
  * RETURN:      Status
  *
@@ -149,23 +167,23 @@ acpi_ex_do_match (
 
 acpi_status
 acpi_ex_opcode_6A_0T_1R (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_operand_object     **operand = &walk_state->operands[0];
-	acpi_operand_object     *return_desc = NULL;
-	acpi_status             status = AE_OK;
-	u32                     index;
-	acpi_operand_object     *this_element;
+	union acpi_operand_object       **operand = &walk_state->operands[0];
+	union acpi_operand_object       *return_desc = NULL;
+	acpi_status                     status = AE_OK;
+	u32                             index;
+	union acpi_operand_object       *this_element;
 
 
-	FUNCTION_TRACE_STR ("Ex_opcode_6A_0T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
+	ACPI_FUNCTION_TRACE_STR ("ex_opcode_6A_0T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
 
 
 	switch (walk_state->opcode) {
 	case AML_MATCH_OP:
 		/*
-		 * Match (Search_package[0], Match_op1[1], Match_object1[2],
-		 *                          Match_op2[3], Match_object2[4], Start_index[5])
+		 * Match (search_package[0], match_op1[1], match_object1[2],
+		 *                          match_op2[3], match_object2[4], start_index[5])
 		 */
 
 		/* Validate match comparison sub-opcodes */
@@ -199,8 +217,9 @@ acpi_ex_opcode_6A_0T_1R (
 		 * Examine each element until a match is found.  Within the loop,
 		 * "continue" signifies that the current element does not match
 		 * and the next should be examined.
+		 *
 		 * Upon finding a match, the loop will terminate via "break" at
-		 * the bottom.  If it terminates "normally", Match_value will be -1
+		 * the bottom.  If it terminates "normally", match_value will be -1
 		 * (its initial value) indicating that no match was found.  When
 		 * returned as a Number, this will produce the Ones value as specified.
 		 */
@@ -209,27 +228,21 @@ acpi_ex_opcode_6A_0T_1R (
 
 			/*
 			 * Treat any NULL or non-numeric elements as non-matching.
-			 * TBD [Unhandled] - if an element is a Name,
-			 *      should we examine its value?
 			 */
 			if (!this_element ||
-				this_element->common.type != ACPI_TYPE_INTEGER) {
+				ACPI_GET_OBJECT_TYPE (this_element) != ACPI_TYPE_INTEGER) {
 				continue;
 			}
 
-
 			/*
-			 * Within these switch statements:
-			 *      "break" (exit from the switch) signifies a match;
-			 *      "continue" (proceed to next iteration of enclosing
-			 *          "for" loop) signifies a non-match.
+			 * "continue" (proceed to next iteration of enclosing
+			 * "for" loop) signifies a non-match.
 			 */
 			if (!acpi_ex_do_match ((u32) operand[1]->integer.value,
 					   this_element->integer.value, operand[2]->integer.value)) {
 				continue;
 			}
 
-
 			if (!acpi_ex_do_match ((u32) operand[3]->integer.value,
 					   this_element->integer.value, operand[4]->integer.value)) {
 				continue;
@@ -246,18 +259,16 @@ acpi_ex_opcode_6A_0T_1R (
 
 	case AML_LOAD_TABLE_OP:
 
-		status = AE_NOT_IMPLEMENTED;
-		goto cleanup;
+		status = acpi_ex_load_table_op (walk_state, &return_desc);
 		break;
 
 
 	default:
 
-		REPORT_ERROR (("Acpi_ex_opcode_3A_0T_0R: Unknown opcode %X\n",
+		ACPI_REPORT_ERROR (("acpi_ex_opcode_3A_0T_0R: Unknown opcode %X\n",
 				walk_state->opcode));
 		status = AE_AML_BAD_OPCODE;
 		goto cleanup;
-		break;
 	}
 
 
diff -urNp linux-5400/drivers/acpi/executer/exprep.c linux-5410/drivers/acpi/executer/exprep.c
--- linux-5400/drivers/acpi/executer/exprep.c
+++ linux-5410/drivers/acpi/executer/exprep.c
@@ -2,292 +2,348 @@
 /******************************************************************************
  *
  * Module Name: exprep - ACPI AML (p-code) execution - field prep utilities
- *              $Revision: 99 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acinterp.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "acparser.h"
+#include <acpi/acpi.h>
+#include <acpi/acinterp.h>
+#include <acpi/amlcode.h>
+#include <acpi/acnamesp.h>
 
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("exprep")
+	 ACPI_MODULE_NAME    ("exprep")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_decode_field_access_type
+ * FUNCTION:    acpi_ex_decode_field_access
  *
  * PARAMETERS:  Access          - Encoded field access bits
  *              Length          - Field length.
  *
- * RETURN:      Field granularity (8, 16, 32 or 64)
+ * RETURN:      Field granularity (8, 16, 32 or 64) and
+ *              byte_alignment (1, 2, 3, or 4)
  *
- * DESCRIPTION: Decode the Access_type bits of a field definition.
+ * DESCRIPTION: Decode the access_type bits of a field definition.
  *
  ******************************************************************************/
 
 static u32
-acpi_ex_decode_field_access_type (
-	u32                     access,
-	u16                     length,
-	u32                     *alignment)
+acpi_ex_decode_field_access (
+	union acpi_operand_object       *obj_desc,
+	u8                              field_flags,
+	u32                             *return_byte_alignment)
 {
-	PROC_NAME ("Ex_decode_field_access_type");
+	u32                             access;
+	u8                              byte_alignment;
+	u8                              bit_length;
+/*    u32                             Length; */
 
 
+	ACPI_FUNCTION_NAME ("ex_decode_field_access");
+
+
+	access = (field_flags & AML_FIELD_ACCESS_TYPE_MASK);
+
 	switch (access) {
-	case ACCESS_ANY_ACC:
+	case AML_FIELD_ACCESS_ANY:
+
+		byte_alignment = 1;
+		bit_length = 8;
 
-		*alignment = 8;
+#if 0
+		/*
+		 * TBD: optimize
+		 *
+		 * Any attempt to optimize the access size to the size of the field
+		 * must take into consideration the length of the region and take
+		 * care that an access to the field will not attempt to access
+		 * beyond the end of the region.
+		 */
 
 		/* Use the length to set the access type */
 
+		length = obj_desc->common_field.bit_length;
+
 		if (length <= 8) {
-			return (8);
+			bit_length = 8;
 		}
 		else if (length <= 16) {
-			return (16);
+			bit_length = 16;
 		}
 		else if (length <= 32) {
-			return (32);
+			bit_length = 32;
 		}
 		else if (length <= 64) {
-			return (64);
+			bit_length = 64;
 		}
+		else {
+			/* Larger than Qword - just use byte-size chunks */
 
-		/* Default is 8 (byte) */
-
-		return (8);
+			bit_length = 8;
+		}
+#endif
 		break;
 
-	case ACCESS_BYTE_ACC:
-		*alignment = 8;
-		return (8);
+	case AML_FIELD_ACCESS_BYTE:
+	case AML_FIELD_ACCESS_BUFFER:   /* ACPI 2.0 (SMBus Buffer) */
+		byte_alignment = 1;
+		bit_length    = 8;
 		break;
 
-	case ACCESS_WORD_ACC:
-		*alignment = 16;
-		return (16);
+	case AML_FIELD_ACCESS_WORD:
+		byte_alignment = 2;
+		bit_length    = 16;
 		break;
 
-	case ACCESS_DWORD_ACC:
-		*alignment = 32;
-		return (32);
+	case AML_FIELD_ACCESS_DWORD:
+		byte_alignment = 4;
+		bit_length    = 32;
 		break;
 
-	case ACCESS_QWORD_ACC:  /* ACPI 2.0 */
-		*alignment = 64;
-		return (64);
+	case AML_FIELD_ACCESS_QWORD:    /* ACPI 2.0 */
+		byte_alignment = 8;
+		bit_length    = 64;
 		break;
 
 	default:
 		/* Invalid field access type */
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Unknown field access type %x\n",
+			"Unknown field access type %X\n",
 			access));
 		return (0);
 	}
+
+	if (ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_BUFFER_FIELD) {
+		/*
+		 * buffer_field access can be on any byte boundary, so the
+		 * byte_alignment is always 1 byte -- regardless of any byte_alignment
+		 * implied by the field access type.
+		 */
+		byte_alignment = 1;
+	}
+
+	*return_byte_alignment = byte_alignment;
+	return (bit_length);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_prep_common_field_object
+ * FUNCTION:    acpi_ex_prep_common_field_object
  *
- * PARAMETERS:  Obj_desc            - The field object
- *              Field_flags         - Access, Lock_rule, and Update_rule.
- *                                    The format of a Field_flag is described
+ * PARAMETERS:  obj_desc            - The field object
+ *              field_flags         - Access, lock_rule, and update_rule.
+ *                                    The format of a field_flag is described
  *                                    in the ACPI specification
- *              Field_bit_position  - Field start position
- *              Field_bit_length    - Field length in number of bits
+ *              field_bit_position  - Field start position
+ *              field_bit_length    - Field length in number of bits
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Initialize the areas of the field object that are common
- *              to the various types of fields.
+ *              to the various types of fields.  Note: This is very "sensitive"
+ *              code because we are solving the general case for field
+ *              alignment.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ex_prep_common_field_object (
-	acpi_operand_object     *obj_desc,
-	u8                      field_flags,
-	u32                     field_bit_position,
-	u32                     field_bit_length)
+	union acpi_operand_object       *obj_desc,
+	u8                              field_flags,
+	u8                              field_attribute,
+	u32                             field_bit_position,
+	u32                             field_bit_length)
 {
-	u32                     access_bit_width;
-	u32                     alignment;
-	u32                     nearest_byte_address;
+	u32                             access_bit_width;
+	u32                             byte_alignment;
+	u32                             nearest_byte_address;
 
 
-	FUNCTION_TRACE ("Ex_prep_common_field_object");
+	ACPI_FUNCTION_TRACE ("ex_prep_common_field_object");
 
 
 	/*
 	 * Note: the structure being initialized is the
-	 * ACPI_COMMON_FIELD_INFO;  No structure fields outside of the common area
-	 * are initialized by this procedure.
+	 * ACPI_COMMON_FIELD_INFO;  No structure fields outside of the common
+	 * area are initialized by this procedure.
 	 */
-
-	/* Demultiplex the Field_flags byte */
-
-	obj_desc->common_field.lock_rule = (u8) ((field_flags & LOCK_RULE_MASK)
-			 >> LOCK_RULE_SHIFT);
-	obj_desc->common_field.update_rule = (u8) ((field_flags & UPDATE_RULE_MASK)
-			 >> UPDATE_RULE_SHIFT);
-	/* Other misc fields */
-
-	obj_desc->common_field.bit_length = (u16) field_bit_length;
+	obj_desc->common_field.field_flags = field_flags;
+	obj_desc->common_field.attribute = field_attribute;
+	obj_desc->common_field.bit_length = field_bit_length;
 
 	/*
 	 * Decode the access type so we can compute offsets.  The access type gives
 	 * two pieces of information - the width of each field access and the
-	 * necessary alignment of the access.  For Any_acc, the width used is the
-	 * largest necessary/possible in an attempt to access the whole field in one
-	 * I/O operation.  However, for Any_acc, the alignment is 8. For all other
-	 * access types (Byte, Word, Dword, Qword), the width is the same as the
-	 * alignment.
+	 * necessary byte_alignment (address granularity) of the access.
+	 *
+	 * For any_acc, the access_bit_width is the largest width that is both
+	 * necessary and possible in an attempt to access the whole field in one
+	 * I/O operation.  However, for any_acc, the byte_alignment is always one
+	 * byte.
+	 *
+	 * For all Buffer Fields, the byte_alignment is always one byte.
+	 *
+	 * For all other access types (Byte, Word, Dword, Qword), the Bitwidth is
+	 * the same (equivalent) as the byte_alignment.
 	 */
-	access_bit_width = acpi_ex_decode_field_access_type (
-			   ((field_flags & ACCESS_TYPE_MASK) >> ACCESS_TYPE_SHIFT),
-			   obj_desc->field.bit_length, &alignment);
+	access_bit_width = acpi_ex_decode_field_access (obj_desc, field_flags,
+			  &byte_alignment);
 	if (!access_bit_width) {
 		return_ACPI_STATUS (AE_AML_OPERAND_VALUE);
 	}
 
 	/* Setup width (access granularity) fields */
 
-	obj_desc->common_field.access_bit_width = (u8) access_bit_width;         /* 8, 16, 32, 64 */
-	obj_desc->common_field.access_byte_width = (u8) DIV_8 (access_bit_width); /* 1, 2,  4,  8 */
-
-	if (obj_desc->common.type == ACPI_TYPE_BUFFER_FIELD) {
-		/*
-		 * Buffer_field access can be on any byte boundary, so the
-		 * alignment is always 8 (regardless of any alignment implied by the
-		 * field access type.)
-		 */
-		alignment = 8;
-	}
-
+	obj_desc->common_field.access_byte_width = (u8)
+			ACPI_DIV_8 (access_bit_width); /* 1, 2, 4,  8 */
 
 	/*
-	 * Base_byte_offset is the address of the start of the field within the region. It is
-	 * the byte address of the first *datum* (field-width data unit) of the field.
-	 * (i.e., the first datum that contains at least the first *bit* of the field.)
+	 * base_byte_offset is the address of the start of the field within the
+	 * region.  It is the byte address of the first *datum* (field-width data
+	 * unit) of the field. (i.e., the first datum that contains at least the
+	 * first *bit* of the field.)
+	 *
+	 * Note: byte_alignment is always either equal to the access_bit_width or 8
+	 * (Byte access), and it defines the addressing granularity of the parent
+	 * region or buffer.
 	 */
-	nearest_byte_address                      = ROUND_BITS_DOWN_TO_BYTES (field_bit_position);
-	obj_desc->common_field.base_byte_offset   = ROUND_DOWN (nearest_byte_address,
-			   DIV_8 (alignment));
+	nearest_byte_address =
+			ACPI_ROUND_BITS_DOWN_TO_BYTES (field_bit_position);
+	obj_desc->common_field.base_byte_offset =
+			ACPI_ROUND_DOWN (nearest_byte_address, byte_alignment);
 
 	/*
-	 * Start_field_bit_offset is the offset of the first bit of the field within a field datum.
-	 * This is calculated as the number of bits from the Base_byte_offset. In other words,
-	 * the start of the field is relative to a byte address, regardless of the access type
-	 * of the field.
+	 * start_field_bit_offset is the offset of the first bit of the field within
+	 * a field datum.
 	 */
-	obj_desc->common_field.start_field_bit_offset = (u8) (MOD_8 (field_bit_position));
+	obj_desc->common_field.start_field_bit_offset = (u8)
+		(field_bit_position - ACPI_MUL_8 (obj_desc->common_field.base_byte_offset));
 
 	/*
-	 * Datum_valid_bits is the number of valid field bits in the first field datum.
+	 * Valid bits -- the number of bits that compose a partial datum,
+	 * 1) At the end of the field within the region (arbitrary starting bit
+	 *    offset)
+	 * 2) At the end of a buffer used to contain the field (starting offset
+	 *    always zero)
 	 */
-	obj_desc->common_field.datum_valid_bits   = (u8) (access_bit_width -
-			   obj_desc->common_field.start_field_bit_offset);
+	obj_desc->common_field.end_field_valid_bits = (u8)
+		((obj_desc->common_field.start_field_bit_offset + field_bit_length) %
+				  access_bit_width);
+	/* start_buffer_bit_offset always = 0 */
+
+	obj_desc->common_field.end_buffer_valid_bits = (u8)
+		(field_bit_length % access_bit_width);
 
 	/*
-	 * Valid bits -- the number of bits that compose a partial datum,
-	 * 1) At the end of the field within the region (arbitrary starting bit offset)
-	 * 2) At the end of a buffer used to contain the field (starting offset always zero)
+	 * datum_valid_bits is the number of valid field bits in the first
+	 * field datum.
 	 */
-	obj_desc->common_field.end_field_valid_bits = (u8) ((obj_desc->common_field.start_field_bit_offset +
-			   field_bit_length) % access_bit_width);
-	obj_desc->common_field.end_buffer_valid_bits = (u8) (field_bit_length % access_bit_width); /* Start_buffer_bit_offset always = 0 */
-
+	obj_desc->common_field.datum_valid_bits  = (u8)
+		(access_bit_width - obj_desc->common_field.start_field_bit_offset);
 
 	/*
-	 * Does the entire field fit within a single field access element
-	 * (datum)?  (without crossing a datum boundary)
+	 * Does the entire field fit within a single field access element? (datum)
+	 * (i.e., without crossing a datum boundary)
 	 */
-	if ((obj_desc->common_field.start_field_bit_offset + obj_desc->common_field.bit_length) <=
-		(u16) obj_desc->common_field.access_bit_width) {
-		obj_desc->common_field.access_flags |= AFIELD_SINGLE_DATUM;
+	if ((obj_desc->common_field.start_field_bit_offset + field_bit_length) <=
+			(u16) access_bit_width) {
+		obj_desc->common.flags |= AOPOBJ_SINGLE_DATUM;
 	}
 
-
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_prep_field_value
+ * FUNCTION:    acpi_ex_prep_field_value
  *
  * PARAMETERS:  Node                - Owning Node
- *              Region_node         - Region in which field is being defined
- *              Field_flags         - Access, Lock_rule, and Update_rule.
- *              Field_bit_position  - Field start position
- *              Field_bit_length    - Field length in number of bits
+ *              region_node         - Region in which field is being defined
+ *              field_flags         - Access, lock_rule, and update_rule.
+ *              field_bit_position  - Field start position
+ *              field_bit_length    - Field length in number of bits
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Construct an acpi_operand_object of type Def_field and
+ * DESCRIPTION: Construct an union acpi_operand_object of type def_field and
  *              connect it to the parent Node.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ex_prep_field_value (
-	ACPI_CREATE_FIELD_INFO  *info)
+	struct acpi_create_field_info   *info)
 {
-	acpi_operand_object     *obj_desc;
-	u32                     type;
-	acpi_status             status;
+	union acpi_operand_object       *obj_desc;
+	u32                             type;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Ex_prep_field_value");
+	ACPI_FUNCTION_TRACE ("ex_prep_field_value");
 
 
 	/* Parameter validation */
 
-	if (info->field_type != INTERNAL_TYPE_INDEX_FIELD) {
+	if (info->field_type != ACPI_TYPE_LOCAL_INDEX_FIELD) {
 		if (!info->region_node) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Null Region_node\n"));
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Null region_node\n"));
 			return_ACPI_STATUS (AE_AML_NO_OPERAND);
 		}
 
 		type = acpi_ns_get_type (info->region_node);
 		if (type != ACPI_TYPE_REGION) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Needed Region, found type %X %s\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Needed Region, found type %X %s\n",
 				type, acpi_ut_get_type_name (type)));
 
 			return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 		}
 	}
 
-	/* Allocate a new region object */
+	/* Allocate a new field object */
 
 	obj_desc = acpi_ut_create_internal_object (info->field_type);
 	if (!obj_desc) {
@@ -296,8 +352,9 @@ acpi_ex_prep_field_value (
 
 	/* Initialize areas of the object that are common to all fields */
 
+	obj_desc->common_field.node = info->field_node;
 	status = acpi_ex_prep_common_field_object (obj_desc, info->field_flags,
-			  info->field_bit_position, info->field_bit_length);
+			 info->attribute, info->field_bit_position, info->field_bit_length);
 	if (ACPI_FAILURE (status)) {
 		acpi_ut_delete_object_desc (obj_desc);
 		return_ACPI_STATUS (status);
@@ -306,44 +363,48 @@ acpi_ex_prep_field_value (
 	/* Initialize areas of the object that are specific to the field type */
 
 	switch (info->field_type) {
-	case INTERNAL_TYPE_REGION_FIELD:
+	case ACPI_TYPE_LOCAL_REGION_FIELD:
 
-		obj_desc->field.region_obj  = acpi_ns_get_attached_object (info->region_node);
+		obj_desc->field.region_obj   = acpi_ns_get_attached_object (info->region_node);
 
 		/* An additional reference for the container */
 
 		acpi_ut_add_reference (obj_desc->field.region_obj);
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Region_field: Bitoff=%X Off=%X Gran=%X Region %p\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
+			"region_field: Bitoff=%X Off=%X Gran=%X Region %p\n",
 			obj_desc->field.start_field_bit_offset, obj_desc->field.base_byte_offset,
-			obj_desc->field.access_bit_width, obj_desc->field.region_obj));
+			obj_desc->field.access_byte_width, obj_desc->field.region_obj));
 		break;
 
 
-	case INTERNAL_TYPE_BANK_FIELD:
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
 
-		obj_desc->bank_field.value         = info->bank_value;
-		obj_desc->bank_field.region_obj    = acpi_ns_get_attached_object (info->region_node);
-		obj_desc->bank_field.bank_register_obj = acpi_ns_get_attached_object (info->register_node);
+		obj_desc->bank_field.value   = info->bank_value;
+		obj_desc->bank_field.region_obj = acpi_ns_get_attached_object (info->region_node);
+		obj_desc->bank_field.bank_obj = acpi_ns_get_attached_object (info->register_node);
 
 		/* An additional reference for the attached objects */
 
 		acpi_ut_add_reference (obj_desc->bank_field.region_obj);
-		acpi_ut_add_reference (obj_desc->bank_field.bank_register_obj);
+		acpi_ut_add_reference (obj_desc->bank_field.bank_obj);
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Bank Field: Bit_off=%X Off=%X Gran=%X Region %p Bank_reg %p\n",
-			obj_desc->bank_field.start_field_bit_offset, obj_desc->bank_field.base_byte_offset,
-			obj_desc->field.access_bit_width, obj_desc->bank_field.region_obj,
-			obj_desc->bank_field.bank_register_obj));
+		ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
+			"Bank Field: bit_off=%X Off=%X Gran=%X Region %p bank_reg %p\n",
+			obj_desc->bank_field.start_field_bit_offset,
+			obj_desc->bank_field.base_byte_offset,
+			obj_desc->field.access_byte_width,
+			obj_desc->bank_field.region_obj,
+			obj_desc->bank_field.bank_obj));
 		break;
 
 
-	case INTERNAL_TYPE_INDEX_FIELD:
+	case ACPI_TYPE_LOCAL_INDEX_FIELD:
 
 		obj_desc->index_field.index_obj = acpi_ns_get_attached_object (info->register_node);
 		obj_desc->index_field.data_obj = acpi_ns_get_attached_object (info->data_register_node);
-		obj_desc->index_field.value  = (u32) (info->field_bit_position /
-				  obj_desc->field.access_bit_width);
+		obj_desc->index_field.value  = (u32)
+			(info->field_bit_position / ACPI_MUL_8 (obj_desc->field.access_byte_width));
 
 		if (!obj_desc->index_field.data_obj || !obj_desc->index_field.index_obj) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Null Index Object\n"));
@@ -355,22 +416,29 @@ acpi_ex_prep_field_value (
 		acpi_ut_add_reference (obj_desc->index_field.data_obj);
 		acpi_ut_add_reference (obj_desc->index_field.index_obj);
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Index_field: bitoff=%X off=%X gran=%X Index %p Data %p\n",
-			obj_desc->index_field.start_field_bit_offset, obj_desc->index_field.base_byte_offset,
-			obj_desc->field.access_bit_width, obj_desc->index_field.index_obj,
+		ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
+			"index_field: bitoff=%X off=%X gran=%X Index %p Data %p\n",
+			obj_desc->index_field.start_field_bit_offset,
+			obj_desc->index_field.base_byte_offset,
+			obj_desc->field.access_byte_width,
+			obj_desc->index_field.index_obj,
 			obj_desc->index_field.data_obj));
 		break;
+
+	default:
+		/* No other types should get here */
+		break;
 	}
 
 	/*
-	 * Store the constructed descriptor (Obj_desc) into the parent Node,
-	 * preserving the current type of that Named_obj.
+	 * Store the constructed descriptor (obj_desc) into the parent Node,
+	 * preserving the current type of that named_obj.
 	 */
 	status = acpi_ns_attach_object (info->field_node, obj_desc,
-			  (u8) acpi_ns_get_type (info->field_node));
+			  acpi_ns_get_type (info->field_node));
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "set Named_obj %p (%4.4s) val = %p\n",
-		info->field_node, (char*)&(info->field_node->name), obj_desc));
+	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD, "set named_obj %p (%4.4s) val = %p\n",
+			info->field_node, info->field_node->name.ascii, obj_desc));
 
 	/* Remove local reference to the object */
 
diff -urNp linux-5400/drivers/acpi/executer/exregion.c linux-5410/drivers/acpi/executer/exregion.c
--- linux-5400/drivers/acpi/executer/exregion.c
+++ linux-5410/drivers/acpi/executer/exregion.c
@@ -1,52 +1,66 @@
 
 /******************************************************************************
  *
- * Module Name: exregion - ACPI default Op_region (address space) handlers
- *              $Revision: 61 $
+ * Module Name: exregion - ACPI default op_region (address space) handlers
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acinterp.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "achware.h"
-#include "acevents.h"
+#include <acpi/acpi.h>
+#include <acpi/acinterp.h>
 
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("exregion")
+	 ACPI_MODULE_NAME    ("exregion")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_system_memory_space_handler
+ * FUNCTION:    acpi_ex_system_memory_space_handler
  *
  * PARAMETERS:  Function            - Read or Write operation
  *              Address             - Where in the space to read or write
- *              Bit_width           - Field width in bits (8, 16, or 32)
+ *              bit_width           - Field width in bits (8, 16, or 32)
  *              Value               - Pointer to in or out value
- *              Handler_context     - Pointer to Handler's context
- *              Region_context      - Pointer to context specific to the
+ *              handler_context     - Pointer to Handler's context
+ *              region_context      - Pointer to context specific to the
  *                                    accessed region
  *
  * RETURN:      Status
@@ -57,20 +71,23 @@
 
 acpi_status
 acpi_ex_system_memory_space_handler (
-	u32                     function,
-	ACPI_PHYSICAL_ADDRESS   address,
-	u32                     bit_width,
-	u32                     *value,
-	void                    *handler_context,
-	void                    *region_context)
+	u32                             function,
+	acpi_physical_address           address,
+	u32                             bit_width,
+	acpi_integer                    *value,
+	void                            *handler_context,
+	void                            *region_context)
 {
-	acpi_status             status = AE_OK;
-	void                    *logical_addr_ptr = NULL;
-	acpi_mem_space_context  *mem_info = region_context;
-	u32                     length;
+	acpi_status                     status = AE_OK;
+	void                            *logical_addr_ptr = NULL;
+	struct acpi_mem_space_context   *mem_info = region_context;
+	u32                             length;
+	acpi_size                       window_size;
+#ifndef ACPI_MISALIGNED_TRANSFERS
+	u32                             remainder;
+#endif
 
-
-	FUNCTION_TRACE ("Ex_system_memory_space_handler");
+	ACPI_FUNCTION_TRACE ("ex_system_memory_space_handler");
 
 
 	/* Validate and translate the bit width */
@@ -88,14 +105,28 @@ acpi_ex_system_memory_space_handler (
 		length = 4;
 		break;
 
+	case 64:
+		length = 8;
+		break;
+
 	default:
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid System_memory width %d\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid system_memory width %d\n",
 			bit_width));
 		return_ACPI_STATUS (AE_AML_OPERAND_VALUE);
-		break;
 	}
 
 
+#ifndef ACPI_MISALIGNED_TRANSFERS
+	/*
+	 * Hardware does not support non-aligned data transfers, we must verify
+	 * the request.
+	 */
+	(void) acpi_ut_short_divide ((acpi_integer *) &address, length, NULL, &remainder);
+	if (remainder != 0) {
+		return_ACPI_STATUS (AE_AML_ALIGNMENT);
+	}
+#endif
+
 	/*
 	 * Does the request fit into the cached memory mapping?
 	 * Is 1) Address below the current mapping? OR
@@ -115,61 +146,80 @@ acpi_ex_system_memory_space_handler (
 					   mem_info->mapped_length);
 		}
 
-		mem_info->mapped_length = 0; /* In case of failure below */
+		/*
+		 * Don't attempt to map memory beyond the end of the region, and
+		 * constrain the maximum mapping size to something reasonable.
+		 */
+		window_size = (acpi_size) ((mem_info->address + mem_info->length) - address);
+		if (window_size > ACPI_SYSMEM_REGION_WINDOW_SIZE) {
+			window_size = ACPI_SYSMEM_REGION_WINDOW_SIZE;
+		}
 
 		/* Create a new mapping starting at the address given */
 
-		status = acpi_os_map_memory (address, SYSMEM_REGION_WINDOW_SIZE,
+		status = acpi_os_map_memory (address, window_size,
 				  (void **) &mem_info->mapped_logical_address);
 		if (ACPI_FAILURE (status)) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not map memory at %8.8X%8.8X, size %X\n",
+				ACPI_HIDWORD (address), ACPI_LODWORD (address), (u32) window_size));
+			mem_info->mapped_length = 0;
 			return_ACPI_STATUS (status);
 		}
 
 		/* Save the physical address and mapping size */
 
 		mem_info->mapped_physical_address = address;
-		mem_info->mapped_length = SYSMEM_REGION_WINDOW_SIZE;
+		mem_info->mapped_length = window_size;
 	}
 
-
 	/*
 	 * Generate a logical pointer corresponding to the address we want to
 	 * access
 	 */
-
-	/* TBD: should these pointers go to 64-bit in all cases ? */
-
 	logical_addr_ptr = mem_info->mapped_logical_address +
 			  ((acpi_integer) address - (acpi_integer) mem_info->mapped_physical_address);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-		"System_memory %d (%d width) Address=%8.8X%8.8X\n", function, bit_width,
-		HIDWORD (address), LODWORD (address)));
-
-   /* Perform the memory read or write */
+		"system_memory %d (%d width) Address=%8.8X%8.8X\n", function, bit_width,
+		ACPI_HIDWORD (address), ACPI_LODWORD (address)));
 
+   /*
+	* Perform the memory read or write
+	*
+	* Note: For machines that do not support non-aligned transfers, the target
+	* address was checked for alignment above.  We do not attempt to break the
+	* transfer up into smaller (byte-size) chunks because the AML specifically
+	* asked for a transfer width that the hardware may require.
+	*/
 	switch (function) {
+	case ACPI_READ:
 
-	case ACPI_READ_ADR_SPACE:
-
+		*value = 0;
 		switch (bit_width) {
 		case 8:
-			*value = (u32)* (u8 *) logical_addr_ptr;
+			*value = (acpi_integer) *((u8 *) logical_addr_ptr);
 			break;
 
 		case 16:
-			MOVE_UNALIGNED16_TO_32 (value, logical_addr_ptr);
+			*value = (acpi_integer) *((u16 *) logical_addr_ptr);
 			break;
 
 		case 32:
-			MOVE_UNALIGNED32_TO_32 (value, logical_addr_ptr);
+			*value = (acpi_integer) *((u32 *) logical_addr_ptr);
 			break;
-		}
 
+#if ACPI_MACHINE_WIDTH != 16
+		case 64:
+			*value = (acpi_integer) *((u64 *) logical_addr_ptr);
+			break;
+#endif
+		default:
+			/* bit_width was already validated */
+			break;
+		}
 		break;
 
-
-	case ACPI_WRITE_ADR_SPACE:
+	case ACPI_WRITE:
 
 		switch (bit_width) {
 		case 8:
@@ -177,16 +227,24 @@ acpi_ex_system_memory_space_handler (
 			break;
 
 		case 16:
-			MOVE_UNALIGNED16_TO_16 (logical_addr_ptr, value);
+			*(u16 *) logical_addr_ptr = (u16) *value;
 			break;
 
 		case 32:
-			MOVE_UNALIGNED32_TO_32 (logical_addr_ptr, value);
+			*(u32 *) logical_addr_ptr = (u32) *value;
 			break;
-		}
 
-		break;
+#if ACPI_MACHINE_WIDTH != 16
+		case 64:
+			*(u64 *) logical_addr_ptr = (u64) *value;
+			break;
+#endif
 
+		default:
+			/* bit_width was already validated */
+			break;
+		}
+		break;
 
 	default:
 		status = AE_BAD_PARAMETER;
@@ -199,14 +257,14 @@ acpi_ex_system_memory_space_handler (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_system_io_space_handler
+ * FUNCTION:    acpi_ex_system_io_space_handler
  *
  * PARAMETERS:  Function            - Read or Write operation
  *              Address             - Where in the space to read or write
- *              Bit_width           - Field width in bits (8, 16, or 32)
+ *              bit_width           - Field width in bits (8, 16, or 32)
  *              Value               - Pointer to in or out value
- *              Handler_context     - Pointer to Handler's context
- *              Region_context      - Pointer to context specific to the
+ *              handler_context     - Pointer to Handler's context
+ *              region_context      - Pointer to context specific to the
  *                                    accessed region
  *
  * RETURN:      Status
@@ -217,40 +275,38 @@ acpi_ex_system_memory_space_handler (
 
 acpi_status
 acpi_ex_system_io_space_handler (
-	u32                     function,
-	ACPI_PHYSICAL_ADDRESS   address,
-	u32                     bit_width,
-	u32                     *value,
-	void                    *handler_context,
-	void                    *region_context)
+	u32                             function,
+	acpi_physical_address           address,
+	u32                             bit_width,
+	acpi_integer                    *value,
+	void                            *handler_context,
+	void                            *region_context)
 {
-	acpi_status             status = AE_OK;
+	acpi_status                     status = AE_OK;
+	u32                             value32;
 
 
-	FUNCTION_TRACE ("Ex_system_io_space_handler");
+	ACPI_FUNCTION_TRACE ("ex_system_io_space_handler");
 
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-		"System_iO %d (%d width) Address=%8.8X%8.8X\n", function, bit_width,
-		HIDWORD (address), LODWORD (address)));
+		"system_iO %d (%d width) Address=%8.8X%8.8X\n", function, bit_width,
+		ACPI_HIDWORD (address), ACPI_LODWORD (address)));
 
 	/* Decode the function parameter */
 
 	switch (function) {
+	case ACPI_READ:
 
-	case ACPI_READ_ADR_SPACE:
-
-		*value = 0;
-		status = acpi_os_read_port ((ACPI_IO_ADDRESS) address, value, bit_width);
+		status = acpi_os_read_port ((acpi_io_address) address, &value32, bit_width);
+		*value = value32;
 		break;
 
+	case ACPI_WRITE:
 
-	case ACPI_WRITE_ADR_SPACE:
-
-		status = acpi_os_write_port ((ACPI_IO_ADDRESS) address, *value, bit_width);
+		status = acpi_os_write_port ((acpi_io_address) address, (u32) *value, bit_width);
 		break;
 
-
 	default:
 		status = AE_BAD_PARAMETER;
 		break;
@@ -262,14 +318,14 @@ acpi_ex_system_io_space_handler (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_pci_config_space_handler
+ * FUNCTION:    acpi_ex_pci_config_space_handler
  *
  * PARAMETERS:  Function            - Read or Write operation
  *              Address             - Where in the space to read or write
- *              Bit_width           - Field width in bits (8, 16, or 32)
+ *              bit_width           - Field width in bits (8, 16, or 32)
  *              Value               - Pointer to in or out value
- *              Handler_context     - Pointer to Handler's context
- *              Region_context      - Pointer to context specific to the
+ *              handler_context     - Pointer to Handler's context
+ *              region_context      - Pointer to context specific to the
  *                                    accessed region
  *
  * RETURN:      Status
@@ -280,56 +336,53 @@ acpi_ex_system_io_space_handler (
 
 acpi_status
 acpi_ex_pci_config_space_handler (
-	u32                     function,
-	ACPI_PHYSICAL_ADDRESS   address,
-	u32                     bit_width,
-	u32                     *value,
-	void                    *handler_context,
-	void                    *region_context)
+	u32                             function,
+	acpi_physical_address           address,
+	u32                             bit_width,
+	acpi_integer                    *value,
+	void                            *handler_context,
+	void                            *region_context)
 {
-	acpi_status             status = AE_OK;
-	acpi_pci_id             *pci_id;
-	u16                     pci_register;
+	acpi_status                     status = AE_OK;
+	struct acpi_pci_id              *pci_id;
+	u16                             pci_register;
 
 
-	FUNCTION_TRACE ("Ex_pci_config_space_handler");
+	ACPI_FUNCTION_TRACE ("ex_pci_config_space_handler");
 
 
 	/*
-	 *  The arguments to Acpi_os(Read|Write)Pci_cfg(Byte|Word|Dword) are:
+	 *  The arguments to acpi_os(Read|Write)pci_configuration are:
 	 *
-	 *  Pci_segment is the PCI bus segment range 0-31
-	 *  Pci_bus     is the PCI bus number range 0-255
-	 *  Pci_device  is the PCI device number range 0-31
-	 *  Pci_function is the PCI device function number
-	 *  Pci_register is the Config space register range 0-255 bytes
+	 *  pci_segment is the PCI bus segment range 0-31
+	 *  pci_bus     is the PCI bus number range 0-255
+	 *  pci_device  is the PCI device number range 0-31
+	 *  pci_function is the PCI device function number
+	 *  pci_register is the Config space register range 0-255 bytes
 	 *
 	 *  Value - input value for write, output address for read
 	 *
 	 */
-	pci_id      = (acpi_pci_id *) region_context;
-	pci_register = (u16) address;
+	pci_id      = (struct acpi_pci_id *) region_context;
+	pci_register = (u16) (u32) address;
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-		"Pci_config %d (%d) Seg(%04x) Bus(%04x) Dev(%04x) Func(%04x) Reg(%04x)\n",
+		"pci_config %d (%d) Seg(%04x) Bus(%04x) Dev(%04x) Func(%04x) Reg(%04x)\n",
 		function, bit_width, pci_id->segment, pci_id->bus, pci_id->device,
 		pci_id->function, pci_register));
 
 	switch (function) {
-
-	case ACPI_READ_ADR_SPACE:
+	case ACPI_READ:
 
 		*value = 0;
 		status = acpi_os_read_pci_configuration (pci_id, pci_register, value, bit_width);
 		break;
 
-
-	case ACPI_WRITE_ADR_SPACE:
+	case ACPI_WRITE:
 
 		status = acpi_os_write_pci_configuration (pci_id, pci_register, *value, bit_width);
 		break;
 
-
 	default:
 
 		status = AE_BAD_PARAMETER;
@@ -342,14 +395,14 @@ acpi_ex_pci_config_space_handler (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_cmos_space_handler
+ * FUNCTION:    acpi_ex_cmos_space_handler
  *
  * PARAMETERS:  Function            - Read or Write operation
  *              Address             - Where in the space to read or write
- *              Bit_width           - Field width in bits (8, 16, or 32)
+ *              bit_width           - Field width in bits (8, 16, or 32)
  *              Value               - Pointer to in or out value
- *              Handler_context     - Pointer to Handler's context
- *              Region_context      - Pointer to context specific to the
+ *              handler_context     - Pointer to Handler's context
+ *              region_context      - Pointer to context specific to the
  *                                    accessed region
  *
  * RETURN:      Status
@@ -360,17 +413,17 @@ acpi_ex_pci_config_space_handler (
 
 acpi_status
 acpi_ex_cmos_space_handler (
-	u32                     function,
-	ACPI_PHYSICAL_ADDRESS   address,
-	u32                     bit_width,
-	u32                     *value,
-	void                    *handler_context,
-	void                    *region_context)
+	u32                             function,
+	acpi_physical_address           address,
+	u32                             bit_width,
+	acpi_integer                    *value,
+	void                            *handler_context,
+	void                            *region_context)
 {
-	acpi_status             status = AE_OK;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE ("Ex_cmos_space_handler");
+	ACPI_FUNCTION_TRACE ("ex_cmos_space_handler");
 
 
 	return_ACPI_STATUS (status);
@@ -379,37 +432,97 @@ acpi_ex_cmos_space_handler (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_pci_bar_space_handler
+ * FUNCTION:    acpi_ex_pci_bar_space_handler
  *
  * PARAMETERS:  Function            - Read or Write operation
  *              Address             - Where in the space to read or write
- *              Bit_width           - Field width in bits (8, 16, or 32)
+ *              bit_width           - Field width in bits (8, 16, or 32)
  *              Value               - Pointer to in or out value
- *              Handler_context     - Pointer to Handler's context
- *              Region_context      - Pointer to context specific to the
+ *              handler_context     - Pointer to Handler's context
+ *              region_context      - Pointer to context specific to the
  *                                    accessed region
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Handler for the PCI Bar_target address space (Op Region)
+ * DESCRIPTION: Handler for the PCI bar_target address space (Op Region)
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ex_pci_bar_space_handler (
-	u32                     function,
-	ACPI_PHYSICAL_ADDRESS   address,
-	u32                     bit_width,
-	u32                     *value,
-	void                    *handler_context,
-	void                    *region_context)
+	u32                             function,
+	acpi_physical_address           address,
+	u32                             bit_width,
+	acpi_integer                    *value,
+	void                            *handler_context,
+	void                            *region_context)
 {
-	acpi_status             status = AE_OK;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE ("Ex_pci_bar_space_handler");
+	ACPI_FUNCTION_TRACE ("ex_pci_bar_space_handler");
 
 
 	return_ACPI_STATUS (status);
 }
 
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_data_table_space_handler
+ *
+ * PARAMETERS:  Function            - Read or Write operation
+ *              Address             - Where in the space to read or write
+ *              bit_width           - Field width in bits (8, 16, or 32)
+ *              Value               - Pointer to in or out value
+ *              handler_context     - Pointer to Handler's context
+ *              region_context      - Pointer to context specific to the
+ *                                    accessed region
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Handler for the Data Table address space (Op Region)
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_data_table_space_handler (
+	u32                             function,
+	acpi_physical_address           address,
+	u32                             bit_width,
+	acpi_integer                    *value,
+	void                            *handler_context,
+	void                            *region_context)
+{
+	acpi_status                     status = AE_OK;
+	u32                             byte_width = ACPI_DIV_8 (bit_width);
+	u32                             i;
+	char                            *logical_addr_ptr;
+
+
+	ACPI_FUNCTION_TRACE ("ex_data_table_space_handler");
+
+
+	logical_addr_ptr = ACPI_PHYSADDR_TO_PTR (address);
+
+
+   /* Perform the memory read or write */
+
+	switch (function) {
+	case ACPI_READ:
+
+		for (i = 0; i < byte_width; i++) {
+			((char *) value) [i] = logical_addr_ptr[i];
+		}
+		break;
+
+	case ACPI_WRITE:
+	default:
+
+		return_ACPI_STATUS (AE_SUPPORT);
+	}
+
+	return_ACPI_STATUS (status);
+}
+
+
diff -urNp linux-5400/drivers/acpi/executer/exresnte.c linux-5410/drivers/acpi/executer/exresnte.c
--- linux-5400/drivers/acpi/executer/exresnte.c
+++ linux-5410/drivers/acpi/executer/exresnte.c
@@ -2,51 +2,65 @@
 /******************************************************************************
  *
  * Module Name: exresnte - AML Interpreter object resolution
- *              $Revision: 43 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "amlcode.h"
-#include "acparser.h"
-#include "acdispat.h"
-#include "acinterp.h"
-#include "acnamesp.h"
-#include "actables.h"
-#include "acevents.h"
+#include <acpi/acpi.h>
+#include <acpi/acdispat.h>
+#include <acpi/acinterp.h>
+#include <acpi/acnamesp.h>
 
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("exresnte")
+	 ACPI_MODULE_NAME    ("exresnte")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_resolve_node_to_value
+ * FUNCTION:    acpi_ex_resolve_node_to_value
  *
- * PARAMETERS:  Object_ptr      - Pointer to a location that contains
+ * PARAMETERS:  object_ptr      - Pointer to a location that contains
  *                                a pointer to a NS node, and will receive a
  *                                pointer to the resolved object.
- *              Walk_state      - Current state.  Valid only if executing AML
+ *              walk_state      - Current state.  Valid only if executing AML
  *                                code.  NULL if simply resolving an object
  *
  * RETURN:      Status
@@ -67,32 +81,39 @@
 
 acpi_status
 acpi_ex_resolve_node_to_value (
-	acpi_namespace_node     **object_ptr,
-	acpi_walk_state         *walk_state)
+	struct acpi_namespace_node      **object_ptr,
+	struct acpi_walk_state          *walk_state)
 
 {
-	acpi_status             status = AE_OK;
-	acpi_operand_object     *source_desc;
-	acpi_operand_object     *obj_desc = NULL;
-	acpi_namespace_node     *node;
-	acpi_object_type8       entry_type;
-	acpi_integer            temp_val;
+	acpi_status                     status = AE_OK;
+	union acpi_operand_object       *source_desc;
+	union acpi_operand_object       *obj_desc = NULL;
+	struct acpi_namespace_node      *node;
+	acpi_object_type                entry_type;
 
 
-	FUNCTION_TRACE ("Ex_resolve_node_to_value");
+	ACPI_FUNCTION_TRACE ("ex_resolve_node_to_value");
 
 
 	/*
-	 * The stack pointer points to a acpi_namespace_node (Node).  Get the
+	 * The stack pointer points to a struct acpi_namespace_node (Node).  Get the
 	 * object that is attached to the Node.
 	 */
-	node      = *object_ptr;
-	source_desc  = acpi_ns_get_attached_object (node);
+	node       = *object_ptr;
+	source_desc = acpi_ns_get_attached_object (node);
 	entry_type = acpi_ns_get_type ((acpi_handle) node);
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Entry=%p Source_desc=%p Type=%X\n",
-		 node, source_desc, entry_type));
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Entry=%p source_desc=%p [%s]\n",
+		 node, source_desc, acpi_ut_get_type_name (entry_type)));
 
+	if (entry_type == ACPI_TYPE_LOCAL_ALIAS) {
+		/* There is always exactly one level of indirection */
+
+		node       = (struct acpi_namespace_node *) node->object;
+		source_desc = acpi_ns_get_attached_object (node);
+		entry_type = acpi_ns_get_type ((acpi_handle) node);
+		*object_ptr = node;
+	}
 
 	/*
 	 * Several object types require no further processing:
@@ -115,42 +136,47 @@ acpi_ex_resolve_node_to_value (
 	 * of the attached object or pointer
 	 */
 	switch (entry_type) {
-
 	case ACPI_TYPE_PACKAGE:
 
-		if (ACPI_TYPE_PACKAGE != source_desc->common.type) {
+		if (ACPI_GET_OBJECT_TYPE (source_desc) != ACPI_TYPE_PACKAGE) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Object not a Package, type %s\n",
-				acpi_ut_get_type_name (source_desc->common.type)));
+				acpi_ut_get_object_type_name (source_desc)));
 			return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 		}
 
-		/* Return an additional reference to the object */
+		status = acpi_ds_get_package_arguments (source_desc);
+		if (ACPI_SUCCESS (status)) {
+			/* Return an additional reference to the object */
 
-		obj_desc = source_desc;
-		acpi_ut_add_reference (obj_desc);
+			obj_desc = source_desc;
+			acpi_ut_add_reference (obj_desc);
+		}
 		break;
 
 
 	case ACPI_TYPE_BUFFER:
 
-		if (ACPI_TYPE_BUFFER != source_desc->common.type) {
+		if (ACPI_GET_OBJECT_TYPE (source_desc) != ACPI_TYPE_BUFFER) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Object not a Buffer, type %s\n",
-				acpi_ut_get_type_name (source_desc->common.type)));
+				acpi_ut_get_object_type_name (source_desc)));
 			return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 		}
 
-		/* Return an additional reference to the object */
+		status = acpi_ds_get_buffer_arguments (source_desc);
+		if (ACPI_SUCCESS (status)) {
+			/* Return an additional reference to the object */
 
-		obj_desc = source_desc;
-		acpi_ut_add_reference (obj_desc);
+			obj_desc = source_desc;
+			acpi_ut_add_reference (obj_desc);
+		}
 		break;
 
 
 	case ACPI_TYPE_STRING:
 
-		if (ACPI_TYPE_STRING != source_desc->common.type) {
+		if (ACPI_GET_OBJECT_TYPE (source_desc) != ACPI_TYPE_STRING) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Object not a String, type %s\n",
-				acpi_ut_get_type_name (source_desc->common.type)));
+				acpi_ut_get_object_type_name (source_desc)));
 			return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 		}
 
@@ -163,9 +189,9 @@ acpi_ex_resolve_node_to_value (
 
 	case ACPI_TYPE_INTEGER:
 
-		if (ACPI_TYPE_INTEGER != source_desc->common.type) {
+		if (ACPI_GET_OBJECT_TYPE (source_desc) != ACPI_TYPE_INTEGER) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Object not a Integer, type %s\n",
-				acpi_ut_get_type_name (source_desc->common.type)));
+				acpi_ut_get_object_type_name (source_desc)));
 			return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 		}
 
@@ -177,17 +203,16 @@ acpi_ex_resolve_node_to_value (
 
 
 	case ACPI_TYPE_BUFFER_FIELD:
-	case INTERNAL_TYPE_REGION_FIELD:
-	case INTERNAL_TYPE_BANK_FIELD:
-	case INTERNAL_TYPE_INDEX_FIELD:
+	case ACPI_TYPE_LOCAL_REGION_FIELD:
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
+	case ACPI_TYPE_LOCAL_INDEX_FIELD:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Field_read Node=%p Source_desc=%p Type=%X\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "field_read Node=%p source_desc=%p Type=%X\n",
 			node, source_desc, entry_type));
 
-		status = acpi_ex_read_data_from_field (source_desc, &obj_desc);
+		status = acpi_ex_read_data_from_field (walk_state, source_desc, &obj_desc);
 		break;
 
-
 	/*
 	 * For these objects, just return the object attached to the Node
 	 */
@@ -206,7 +231,7 @@ acpi_ex_resolve_node_to_value (
 		break;
 
 
-	/* TYPE_Any is untyped, and thus there is no object associated with it */
+	/* TYPE_ANY is untyped, and thus there is no object associated with it */
 
 	case ACPI_TYPE_ANY:
 
@@ -214,64 +239,16 @@ acpi_ex_resolve_node_to_value (
 			node));
 
 		return_ACPI_STATUS (AE_AML_OPERAND_TYPE);  /* Cannot be AE_TYPE */
-		break;
-
-
-	/*
-	 * The only named references allowed are named constants
-	 *   e.g. -- Name (\OSFL, Ones)
-	 */
-	case INTERNAL_TYPE_REFERENCE:
 
-		switch (source_desc->reference.opcode) {
 
-		case AML_ZERO_OP:
+	case ACPI_TYPE_LOCAL_REFERENCE:
 
-			temp_val = 0;
-			break;
+		/* No named references are allowed here */
 
-		case AML_ONE_OP:
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unsupported Reference opcode %X\n",
+			source_desc->reference.opcode));
 
-			temp_val = 1;
-			break;
-
-		case AML_ONES_OP:
-
-			temp_val = ACPI_INTEGER_MAX;
-			break;
-
-		case AML_REVISION_OP:
-
-			temp_val = ACPI_CA_SUPPORT_LEVEL;
-			break;
-
-		default:
-
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unsupported reference opcode %X\n",
-				source_desc->reference.opcode));
-
-			return_ACPI_STATUS (AE_AML_BAD_OPCODE);
-		}
-
-		/* Create object for result */
-
-		obj_desc = acpi_ut_create_internal_object (ACPI_TYPE_INTEGER);
-		if (!obj_desc) {
-			return_ACPI_STATUS (AE_NO_MEMORY);
-		}
-
-		obj_desc->integer.value = temp_val;
-
-		/*
-		 * Truncate value if we are executing from a 32-bit ACPI table
-		 * AND actually executing AML code.  If we are resolving
-		 * an object in the namespace via an external call to the
-		 * subsystem, we will have a null Walk_state
-		 */
-		if (walk_state) {
-			acpi_ex_truncate_for32bit_table (obj_desc, walk_state);
-		}
-		break;
+		return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 
 
 	/* Default case is for unknown types */
@@ -283,7 +260,7 @@ acpi_ex_resolve_node_to_value (
 
 		return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 
-	} /* switch (Entry_type) */
+	} /* switch (entry_type) */
 
 
 	/* Put the object descriptor on the stack */
diff -urNp linux-5400/drivers/acpi/executer/exresolv.c linux-5410/drivers/acpi/executer/exresolv.c
--- linux-5400/drivers/acpi/executer/exresolv.c
+++ linux-5410/drivers/acpi/executer/exresolv.c
@@ -2,156 +2,66 @@
 /******************************************************************************
  *
  * Module Name: exresolv - AML Interpreter object resolution
- *              $Revision: 101 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "amlcode.h"
-#include "acparser.h"
-#include "acdispat.h"
-#include "acinterp.h"
-#include "acnamesp.h"
-#include "actables.h"
-#include "acevents.h"
+#include <acpi/acpi.h>
+#include <acpi/amlcode.h>
+#include <acpi/acdispat.h>
+#include <acpi/acinterp.h>
+#include <acpi/acnamesp.h>
 
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("exresolv")
+	 ACPI_MODULE_NAME    ("exresolv")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_get_buffer_field_value
+ * FUNCTION:    acpi_ex_resolve_to_value
  *
- * PARAMETERS:  *Obj_desc           - Pointer to a Buffer_field
- *              *Result_desc        - Pointer to an empty descriptor which will
- *                                    become an Integer with the field's value
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Retrieve the value from a Buffer_field
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ex_get_buffer_field_value (
-	acpi_operand_object     *obj_desc,
-	acpi_operand_object     *result_desc)
-{
-	acpi_status             status;
-	u32                     mask;
-	u8                      *location;
-
-
-	FUNCTION_TRACE ("Ex_get_buffer_field_value");
-
-
-	/*
-	 * Parameter validation
-	 */
-	if (!obj_desc) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Internal - null field pointer\n"));
-		return_ACPI_STATUS (AE_AML_NO_OPERAND);
-	}
-
-	if (!(obj_desc->common.flags & AOPOBJ_DATA_VALID)) {
-		status = acpi_ds_get_buffer_field_arguments (obj_desc);
-		if (ACPI_FAILURE (status)) {
-			return_ACPI_STATUS (status);
-		}
-	}
-
-	if (!obj_desc->buffer_field.buffer_obj) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Internal - null container pointer\n"));
-		return_ACPI_STATUS (AE_AML_INTERNAL);
-	}
-
-	if (ACPI_TYPE_BUFFER != obj_desc->buffer_field.buffer_obj->common.type) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Internal - container is not a Buffer\n"));
-		return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
-	}
-
-	if (!result_desc) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Internal - null result pointer\n"));
-		return_ACPI_STATUS (AE_AML_INTERNAL);
-	}
-
-
-	/* Field location is (base of buffer) + (byte offset) */
-
-	location = obj_desc->buffer_field.buffer_obj->buffer.pointer
-			 + obj_desc->buffer_field.base_byte_offset;
-
-	/*
-	 * Construct Mask with as many 1 bits as the field width
-	 *
-	 * NOTE: Only the bottom 5 bits are valid for a shift operation, so
-	 *  special care must be taken for any shift greater than 31 bits.
-	 *
-	 * TBD: [Unhandled] Fields greater than 32 bits will not work.
-	 */
-	if (obj_desc->buffer_field.bit_length < 32) {
-		mask = ((u32) 1 << obj_desc->buffer_field.bit_length) - (u32) 1;
-	}
-	else {
-		mask = ACPI_UINT32_MAX;
-	}
-
-	result_desc->integer.type = (u8) ACPI_TYPE_INTEGER;
-
-	/* Get the 32 bit value at the location */
-
-	MOVE_UNALIGNED32_TO_32 (&result_desc->integer.value, location);
-
-	/*
-	 * Shift the 32-bit word containing the field, and mask off the
-	 * resulting value
-	 */
-	result_desc->integer.value =
-		(result_desc->integer.value >> obj_desc->buffer_field.start_field_bit_offset) & mask;
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-		"** Read from buffer %p byte %d bit %d width %d addr %p mask %08X val %8.8X%8.8X\n",
-		obj_desc->buffer_field.buffer_obj->buffer.pointer,
-		obj_desc->buffer_field.base_byte_offset,
-		obj_desc->buffer_field.start_field_bit_offset,
-		obj_desc->buffer_field.bit_length,
-		location, mask,
-		HIDWORD(result_desc->integer.value),
-		LODWORD(result_desc->integer.value)));
-
-	return_ACPI_STATUS (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ex_resolve_to_value
- *
- * PARAMETERS:  **Stack_ptr         - Points to entry on Obj_stack, which can
- *                                    be either an (acpi_operand_object *)
+ * PARAMETERS:  **stack_ptr         - Points to entry on obj_stack, which can
+ *                                    be either an (union acpi_operand_object *)
  *                                    or an acpi_handle.
- *              Walk_state          - Current method state
+ *              walk_state          - Current method state
  *
  * RETURN:      Status
  *
@@ -161,13 +71,13 @@ acpi_ex_get_buffer_field_value (
 
 acpi_status
 acpi_ex_resolve_to_value (
-	acpi_operand_object     **stack_ptr,
-	acpi_walk_state         *walk_state)
+	union acpi_operand_object       **stack_ptr,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE_PTR ("Ex_resolve_to_value", stack_ptr);
+	ACPI_FUNCTION_TRACE_PTR ("ex_resolve_to_value", stack_ptr);
 
 
 	if (!stack_ptr || !*stack_ptr) {
@@ -175,13 +85,12 @@ acpi_ex_resolve_to_value (
 		return_ACPI_STATUS (AE_AML_NO_OPERAND);
 	}
 
-
 	/*
-	 * The entity pointed to by the Stack_ptr can be either
-	 * 1) A valid acpi_operand_object, or
-	 * 2) A acpi_namespace_node (Named_obj)
+	 * The entity pointed to by the stack_ptr can be either
+	 * 1) A valid union acpi_operand_object, or
+	 * 2) A struct acpi_namespace_node (named_obj)
 	 */
-	if (VALID_DESCRIPTOR_TYPE (*stack_ptr, ACPI_DESC_TYPE_INTERNAL)) {
+	if (ACPI_GET_DESCRIPTOR_TYPE (*stack_ptr) == ACPI_DESC_TYPE_OPERAND) {
 		status = acpi_ex_resolve_object_to_value (stack_ptr, walk_state);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
@@ -189,30 +98,30 @@ acpi_ex_resolve_to_value (
 	}
 
 	/*
-	 * Object on the stack may have changed if Acpi_ex_resolve_object_to_value()
+	 * Object on the stack may have changed if acpi_ex_resolve_object_to_value()
 	 * was called (i.e., we can't use an _else_ here.)
 	 */
-	if (VALID_DESCRIPTOR_TYPE (*stack_ptr, ACPI_DESC_TYPE_NAMED)) {
-		status = acpi_ex_resolve_node_to_value ((acpi_namespace_node **) stack_ptr,
+	if (ACPI_GET_DESCRIPTOR_TYPE (*stack_ptr) == ACPI_DESC_TYPE_NAMED) {
+		status = acpi_ex_resolve_node_to_value (
+				  ACPI_CAST_INDIRECT_PTR (struct acpi_namespace_node, stack_ptr),
 				  walk_state);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
 	}
 
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Resolved object %p\n", *stack_ptr));
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Resolved object %p\n", *stack_ptr));
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_resolve_object_to_value
+ * FUNCTION:    acpi_ex_resolve_object_to_value
  *
- * PARAMETERS:  Stack_ptr       - Pointer to a stack location that contains a
+ * PARAMETERS:  stack_ptr       - Pointer to a stack location that contains a
  *                                ptr to an internal object.
- *              Walk_state      - Current method state
+ *              walk_state      - Current method state
  *
  * RETURN:      Status
  *
@@ -223,36 +132,34 @@ acpi_ex_resolve_to_value (
 
 acpi_status
 acpi_ex_resolve_object_to_value (
-	acpi_operand_object     **stack_ptr,
-	acpi_walk_state         *walk_state)
+	union acpi_operand_object       **stack_ptr,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status = AE_OK;
-	acpi_operand_object     *stack_desc;
-	void                    *temp_node;
-	acpi_operand_object     *obj_desc;
-	u16                     opcode;
+	acpi_status                     status = AE_OK;
+	union acpi_operand_object       *stack_desc;
+	void                            *temp_node;
+	union acpi_operand_object       *obj_desc;
+	u16                             opcode;
 
 
-	FUNCTION_TRACE ("Ex_resolve_object_to_value");
+	ACPI_FUNCTION_TRACE ("ex_resolve_object_to_value");
 
 
 	stack_desc = *stack_ptr;
 
-	/* This is an acpi_operand_object  */
+	/* This is an union acpi_operand_object    */
 
-	switch (stack_desc->common.type) {
-
-	case INTERNAL_TYPE_REFERENCE:
+	switch (ACPI_GET_OBJECT_TYPE (stack_desc)) {
+	case ACPI_TYPE_LOCAL_REFERENCE:
 
 		opcode = stack_desc->reference.opcode;
 
 		switch (opcode) {
-
 		case AML_NAME_OP:
 
 			/*
 			 * Convert indirect name ptr to a direct name ptr.
-			 * Then, Acpi_ex_resolve_node_to_value can be used to get the value
+			 * Then, acpi_ex_resolve_node_to_value can be used to get the value
 			 */
 			temp_node = stack_desc->reference.object;
 
@@ -286,58 +193,11 @@ acpi_ex_resolve_object_to_value (
 			acpi_ut_remove_reference (stack_desc);
 			*stack_ptr = obj_desc;
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "[Arg/Local %d] Value_obj is %p\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Arg/Local %d] value_obj is %p\n",
 				stack_desc->reference.offset, obj_desc));
 			break;
 
 
-		/*
-		 * For constants, we must change the reference/constant object
-		 * to a real integer object
-		 */
-		case AML_ZERO_OP:
-		case AML_ONE_OP:
-		case AML_ONES_OP:
-		case AML_REVISION_OP:
-
-			/* Create a new integer object */
-
-			obj_desc = acpi_ut_create_internal_object (ACPI_TYPE_INTEGER);
-			if (!obj_desc) {
-				return_ACPI_STATUS (AE_NO_MEMORY);
-			}
-
-			switch (opcode) {
-			case AML_ZERO_OP:
-				obj_desc->integer.value = 0;
-				break;
-
-			case AML_ONE_OP:
-				obj_desc->integer.value = 1;
-				break;
-
-			case AML_ONES_OP:
-				obj_desc->integer.value = ACPI_INTEGER_MAX;
-
-				/* Truncate value if we are executing from a 32-bit ACPI table */
-
-				acpi_ex_truncate_for32bit_table (obj_desc, walk_state);
-				break;
-
-			case AML_REVISION_OP:
-				obj_desc->integer.value = ACPI_CA_SUPPORT_LEVEL;
-				break;
-			}
-
-			/*
-			 * Remove a reference from the original reference object
-			 * and put the new object in its place
-			 */
-			acpi_ut_remove_reference (stack_desc);
-			*stack_ptr = obj_desc;
-			break;
-
-
 		case AML_INDEX_OP:
 
 			switch (stack_desc->reference.target_type) {
@@ -348,6 +208,7 @@ acpi_ex_resolve_object_to_value (
 
 
 			case ACPI_TYPE_PACKAGE:
+
 				obj_desc = *stack_desc->reference.where;
 				if (obj_desc) {
 					/*
@@ -359,7 +220,6 @@ acpi_ex_resolve_object_to_value (
 					acpi_ut_add_reference (obj_desc);
 					*stack_ptr = obj_desc;
 				}
-
 				else {
 					/*
 					 * A NULL object descriptor means an unitialized element of
@@ -372,83 +232,243 @@ acpi_ex_resolve_object_to_value (
 				}
 				break;
 
+
 			default:
+
 				/* Invalid reference object */
 
 				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-					"Unknown Target_type %X in Index/Reference obj %p\n",
+					"Unknown target_type %X in Index/Reference obj %p\n",
 					stack_desc->reference.target_type, stack_desc));
 				status = AE_AML_INTERNAL;
 				break;
 			}
-
 			break;
 
 
+		case AML_REF_OF_OP:
 		case AML_DEBUG_OP:
 
 			/* Just leave the object as-is */
+
 			break;
 
 
 		default:
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown Reference object subtype %02X in %p\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown Reference opcode %X in %p\n",
 				opcode, stack_desc));
 			status = AE_AML_INTERNAL;
 			break;
+		}
+		break;
 
-		}   /* switch (Opcode) */
 
-		break; /* case INTERNAL_TYPE_REFERENCE */
+	case ACPI_TYPE_BUFFER:
 
+		status = acpi_ds_get_buffer_arguments (stack_desc);
+		break;
 
-	case ACPI_TYPE_BUFFER_FIELD:
 
-		obj_desc = acpi_ut_create_internal_object (ACPI_TYPE_ANY);
-		if (!obj_desc) {
-			return_ACPI_STATUS (AE_NO_MEMORY);
-		}
+	case ACPI_TYPE_PACKAGE:
+
+		status = acpi_ds_get_package_arguments (stack_desc);
+		break;
 
-		status = acpi_ex_get_buffer_field_value (stack_desc, obj_desc);
-		if (ACPI_FAILURE (status)) {
-			acpi_ut_remove_reference (obj_desc);
-			obj_desc = NULL;
-		}
 
+	/*
+	 * These cases may never happen here, but just in case..
+	 */
+	case ACPI_TYPE_BUFFER_FIELD:
+	case ACPI_TYPE_LOCAL_REGION_FIELD:
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
+	case ACPI_TYPE_LOCAL_INDEX_FIELD:
+
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "field_read source_desc=%p Type=%X\n",
+			stack_desc, ACPI_GET_OBJECT_TYPE (stack_desc)));
+
+		status = acpi_ex_read_data_from_field (walk_state, stack_desc, &obj_desc);
 		*stack_ptr = (void *) obj_desc;
 		break;
 
+	default:
+		break;
+	}
 
-	case INTERNAL_TYPE_BANK_FIELD:
+	return_ACPI_STATUS (status);
+}
 
-		obj_desc = acpi_ut_create_internal_object (ACPI_TYPE_ANY);
-		if (!obj_desc) {
-			return_ACPI_STATUS (AE_NO_MEMORY);
-		}
 
-		/* TBD: WRONG! */
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_resolve_multiple
+ *
+ * PARAMETERS:  walk_state          - Current state (contains AML opcode)
+ *              Operand             - Starting point for resolution
+ *              return_type         - Where the object type is returned
+ *              return_desc         - Where the resolved object is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Return the base object and type.  Traverse a reference list if
+ *              necessary to get to the base object.
+ *
+ ******************************************************************************/
 
-		status = acpi_ex_get_buffer_field_value (stack_desc, obj_desc);
-		if (ACPI_FAILURE (status)) {
-			acpi_ut_remove_reference (obj_desc);
-			obj_desc = NULL;
+acpi_status
+acpi_ex_resolve_multiple (
+	struct acpi_walk_state          *walk_state,
+	union acpi_operand_object       *operand,
+	acpi_object_type                *return_type,
+	union acpi_operand_object       **return_desc)
+{
+	union acpi_operand_object       *obj_desc = (void *) operand;
+	struct acpi_namespace_node      *node;
+	acpi_object_type                type;
+
+
+	ACPI_FUNCTION_TRACE ("acpi_ex_resolve_multiple");
+
+
+	/*
+	 * For reference objects created via the ref_of or Index operators,
+	 * we need to get to the base object (as per the ACPI specification
+	 * of the object_type and size_of operators). This means traversing
+	 * the list of possibly many nested references.
+	 */
+	while (ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_LOCAL_REFERENCE) {
+		switch (obj_desc->reference.opcode) {
+		case AML_REF_OF_OP:
+
+			/* Dereference the reference pointer */
+
+			node = obj_desc->reference.object;
+
+			/* All "References" point to a NS node */
+
+			if (ACPI_GET_DESCRIPTOR_TYPE (node) != ACPI_DESC_TYPE_NAMED) {
+				return_ACPI_STATUS (AE_AML_INTERNAL);
+			}
+
+			/* Get the attached object */
+
+			obj_desc = acpi_ns_get_attached_object (node);
+			if (!obj_desc) {
+				/* No object, use the NS node type */
+
+				type = acpi_ns_get_type (node);
+				goto exit;
+			}
+
+			/* Check for circular references */
+
+			if (obj_desc == operand) {
+				return_ACPI_STATUS (AE_AML_CIRCULAR_REFERENCE);
+			}
+			break;
+
+
+		case AML_INDEX_OP:
+
+			/* Get the type of this reference (index into another object) */
+
+			type = obj_desc->reference.target_type;
+			if (type != ACPI_TYPE_PACKAGE) {
+				goto exit;
+			}
+
+			/*
+			 * The main object is a package, we want to get the type
+			 * of the individual package element that is referenced by
+			 * the index.
+			 *
+			 * This could of course in turn be another reference object.
+			 */
+			obj_desc = *(obj_desc->reference.where);
+			break;
+
+
+		case AML_INT_NAMEPATH_OP:
+
+			/* Dereference the reference pointer */
+
+			node = obj_desc->reference.node;
+
+			/* All "References" point to a NS node */
+
+			if (ACPI_GET_DESCRIPTOR_TYPE (node) != ACPI_DESC_TYPE_NAMED) {
+				return_ACPI_STATUS (AE_AML_INTERNAL);
+			}
+
+			/* Get the attached object */
+
+			obj_desc = acpi_ns_get_attached_object (node);
+			if (!obj_desc) {
+				/* No object, use the NS node type */
+
+				type = acpi_ns_get_type (node);
+				goto exit;
+			}
+
+			/* Check for circular references */
+
+			if (obj_desc == operand) {
+				return_ACPI_STATUS (AE_AML_CIRCULAR_REFERENCE);
+			}
+			break;
+
+
+		case AML_DEBUG_OP:
+
+			/* The Debug Object is of type "debug_object" */
+
+			type = ACPI_TYPE_DEBUG_OBJECT;
+			goto exit;
+
+
+		default:
+
+			ACPI_REPORT_ERROR (("acpi_ex_resolve_multiple: Unknown Reference subtype %X\n",
+				obj_desc->reference.opcode));
+			return_ACPI_STATUS (AE_AML_INTERNAL);
 		}
+	}
 
-		*stack_ptr = (void *) obj_desc;
-		break;
+	/*
+	 * Now we are guaranteed to have an object that has not been created
+	 * via the ref_of or Index operators.
+	 */
+	type = ACPI_GET_OBJECT_TYPE (obj_desc);
 
 
-	/* TBD: [Future] - may need to handle Index_field, and Def_field someday */
+exit:
+	/* Convert internal types to external types */
 
-	default:
+	switch (type) {
+	case ACPI_TYPE_LOCAL_REGION_FIELD:
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
+	case ACPI_TYPE_LOCAL_INDEX_FIELD:
 
+		type = ACPI_TYPE_FIELD_UNIT;
 		break;
 
-	}   /* switch (Stack_desc->Common.Type) */
+	case ACPI_TYPE_LOCAL_SCOPE:
 
+		/* Per ACPI Specification, Scope is untyped */
 
-	return_ACPI_STATUS (status);
+		type = ACPI_TYPE_ANY;
+		break;
+
+	default:
+		/* No change to Type required */
+		break;
+	}
+
+	*return_type = type;
+	if (return_desc) {
+		*return_desc = obj_desc;
+	}
+	return_ACPI_STATUS (AE_OK);
 }
 
 
diff -urNp linux-5400/drivers/acpi/executer/exresop.c linux-5410/drivers/acpi/executer/exresop.c
--- linux-5400/drivers/acpi/executer/exresop.c
+++ linux-5410/drivers/acpi/executer/exresop.c
@@ -2,49 +2,63 @@
 /******************************************************************************
  *
  * Module Name: exresop - AML Interpreter operand/object resolution
- *              $Revision: 41 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "amlcode.h"
-#include "acparser.h"
-#include "acdispat.h"
-#include "acinterp.h"
-#include "acnamesp.h"
-#include "actables.h"
-#include "acevents.h"
+#include <acpi/acpi.h>
+#include <acpi/amlcode.h>
+#include <acpi/acparser.h>
+#include <acpi/acinterp.h>
 
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("exresop")
+	 ACPI_MODULE_NAME    ("exresop")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_check_object_type
+ * FUNCTION:    acpi_ex_check_object_type
  *
- * PARAMETERS:  Type_needed         Object type needed
- *              This_type           Actual object type
+ * PARAMETERS:  type_needed         Object type needed
+ *              this_type           Actual object type
  *              Object              Object pointer
  *
  * RETURN:      Status
@@ -55,11 +69,11 @@
 
 acpi_status
 acpi_ex_check_object_type (
-	acpi_object_type        type_needed,
-	acpi_object_type        this_type,
-	void                    *object)
+	acpi_object_type                type_needed,
+	acpi_object_type                this_type,
+	void                            *object)
 {
-	PROC_NAME ("Ex_check_object_type");
+	ACPI_FUNCTION_NAME ("ex_check_object_type");
 
 
 	if (type_needed == ACPI_TYPE_ANY) {
@@ -68,8 +82,20 @@ acpi_ex_check_object_type (
 		return (AE_OK);
 	}
 
+	if (type_needed == ACPI_TYPE_LOCAL_REFERENCE) {
+		/*
+		 * Allow the AML "Constant" opcodes (Zero, One, etc.) to be reference
+		 * objects and thus allow them to be targets.  (As per the ACPI
+		 * specification, a store to a constant is a noop.)
+		 */
+		if ((this_type == ACPI_TYPE_INTEGER) &&
+			(((union acpi_operand_object *) object)->common.flags & AOPOBJ_AML_CONSTANT)) {
+			return (AE_OK);
+		}
+	}
+
 	if (type_needed != this_type) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"Needed [%s], found [%s] %p\n",
 			acpi_ut_get_type_name (type_needed),
 			acpi_ut_get_type_name (this_type), object));
@@ -83,40 +109,42 @@ acpi_ex_check_object_type (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_resolve_operands
+ * FUNCTION:    acpi_ex_resolve_operands
  *
- * PARAMETERS:  Opcode              Opcode being interpreted
- *              Stack_ptr           Top of operand stack
+ * PARAMETERS:  Opcode              - Opcode being interpreted
+ *              stack_ptr           - Pointer to the operand stack to be
+ *                                    resolved
+ *              walk_state          - Current state
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Convert stack entries to required types
- *
- *      Each nibble in Arg_types represents one required operand
- *      and indicates the required Type:
+ * DESCRIPTION: Convert multiple input operands to the types required by the
+ *              target operator.
  *
- *      The corresponding stack entry will be converted to the
- *      required type if possible, else return an exception
+ *      Each 5-bit group in arg_types represents one required
+ *      operand and indicates the required Type. The corresponding operand
+ *      will be converted to the required type if possible, otherwise we
+ *      abort with an exception.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ex_resolve_operands (
-	u16                     opcode,
-	acpi_operand_object     **stack_ptr,
-	acpi_walk_state         *walk_state)
+	u16                             opcode,
+	union acpi_operand_object       **stack_ptr,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_operand_object     *obj_desc;
-	acpi_status             status = AE_OK;
-	u8                      object_type;
-	void                    *temp_node;
-	u32                     arg_types;
-	const acpi_opcode_info  *op_info;
-	u32                     this_arg_type;
-	acpi_object_type        type_needed;
+	union acpi_operand_object       *obj_desc;
+	acpi_status                     status = AE_OK;
+	u8                              object_type;
+	void                            *temp_node;
+	u32                             arg_types;
+	const struct acpi_opcode_info   *op_info;
+	u32                             this_arg_type;
+	acpi_object_type                type_needed;
 
 
-	FUNCTION_TRACE_U32 ("Ex_resolve_operands", opcode);
+	ACPI_FUNCTION_TRACE_U32 ("ex_resolve_operands", opcode);
 
 
 	op_info = acpi_ps_get_opcode_info (opcode);
@@ -124,7 +152,6 @@ acpi_ex_resolve_operands (
 		return_ACPI_STATUS (AE_AML_BAD_OPCODE);
 	}
 
-
 	arg_types = op_info->runtime_args;
 	if (arg_types == ARGI_INVALID_OPCODE) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Internal - %X is not a valid AML opcode\n",
@@ -133,12 +160,11 @@ acpi_ex_resolve_operands (
 		return_ACPI_STATUS (AE_AML_INTERNAL);
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Opcode %X Operand_types=%X \n",
-		opcode, arg_types));
-
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Opcode %X [%s] operand_types=%X \n",
+		opcode, op_info->name, arg_types));
 
 	/*
-	 * Normal exit is with (Arg_types == 0) at end of argument list.
+	 * Normal exit is with (arg_types == 0) at end of argument list.
 	 * Function will return an exception from within the loop upon
 	 * finding an entry which is not (or cannot be converted
 	 * to) the required type; if stack underflows; or upon
@@ -158,27 +184,31 @@ acpi_ex_resolve_operands (
 
 		/* Decode the descriptor type */
 
-		if (VALID_DESCRIPTOR_TYPE (obj_desc, ACPI_DESC_TYPE_NAMED)) {
+		switch (ACPI_GET_DESCRIPTOR_TYPE (obj_desc)) {
+		case ACPI_DESC_TYPE_NAMED:
+
 			/* Node */
 
-			object_type = ((acpi_namespace_node *) obj_desc)->type;
-		}
+			object_type = ((struct acpi_namespace_node *) obj_desc)->type;
+			break;
+
+
+		case ACPI_DESC_TYPE_OPERAND:
 
-		else if (VALID_DESCRIPTOR_TYPE (obj_desc, ACPI_DESC_TYPE_INTERNAL)) {
 			/* ACPI internal object */
 
-			object_type = obj_desc->common.type;
+			object_type = ACPI_GET_OBJECT_TYPE (obj_desc);
 
 			/* Check for bad acpi_object_type */
 
-			if (!acpi_ex_validate_object_type (object_type)) {
+			if (!acpi_ut_valid_object_type (object_type)) {
 				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Bad operand object type [%X]\n",
 					object_type));
 
 				return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 			}
 
-			if (object_type == (u8) INTERNAL_TYPE_REFERENCE) {
+			if (object_type == (u8) ACPI_TYPE_LOCAL_REFERENCE) {
 				/*
 				 * Decode the Reference
 				 */
@@ -187,39 +217,36 @@ acpi_ex_resolve_operands (
 					return_ACPI_STATUS (AE_AML_BAD_OPCODE);
 				}
 
-
 				switch (obj_desc->reference.opcode) {
-				case AML_ZERO_OP:
-				case AML_ONE_OP:
-				case AML_ONES_OP:
 				case AML_DEBUG_OP:
 				case AML_NAME_OP:
 				case AML_INDEX_OP:
+				case AML_REF_OF_OP:
 				case AML_ARG_OP:
 				case AML_LOCAL_OP:
-				case AML_REVISION_OP:
 
-					DEBUG_ONLY_MEMBERS (ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+					ACPI_DEBUG_ONLY_MEMBERS (ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
 						"Reference Opcode: %s\n", op_info->name)));
 					break;
 
 				default:
-					ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-						"Reference Opcode: Unknown [%02x]\n",
+					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+						"Unknown Reference Opcode %X\n",
 						obj_desc->reference.opcode));
 
 					return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
-					break;
 				}
 			}
-		}
+			break;
+
+
+		default:
 
-		else {
 			/* Invalid descriptor */
 
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 				"Bad descriptor type %X in Obj %p\n",
-				obj_desc->common.data_type, obj_desc));
+				ACPI_GET_DESCRIPTOR_TYPE (obj_desc), obj_desc));
 
 			return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 		}
@@ -231,34 +258,45 @@ acpi_ex_resolve_operands (
 		this_arg_type = GET_CURRENT_ARG_TYPE (arg_types);
 		INCREMENT_ARG_LIST (arg_types);
 
-
 		/*
 		 * Handle cases where the object does not need to be
 		 * resolved to a value
 		 */
 		switch (this_arg_type) {
+		case ARGI_REF_OR_STRING:        /* Can be a String or Reference */
 
-		case ARGI_REFERENCE:            /* References */
+			if ((ACPI_GET_DESCRIPTOR_TYPE (obj_desc) == ACPI_DESC_TYPE_OPERAND) &&
+				(ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_STRING)) {
+				/*
+				 * String found - the string references a named object and must be
+				 * resolved to a node
+				 */
+				goto next_operand;
+			}
+
+			/* Else not a string - fall through to the normal Reference case below */
+			/*lint -fallthrough */
+
+		case ARGI_REFERENCE:            /* References: */
 		case ARGI_INTEGER_REF:
 		case ARGI_OBJECT_REF:
 		case ARGI_DEVICE_REF:
-		case ARGI_TARGETREF:            /* TBD: must implement implicit conversion rules before store */
+		case ARGI_TARGETREF:            /* Allows implicit conversion rules before store */
 		case ARGI_FIXED_TARGET:         /* No implicit conversion before store to target */
-		case ARGI_SIMPLE_TARGET:        /* Name, Local, or Arg - no implicit conversion */
+		case ARGI_SIMPLE_TARGET:        /* Name, Local, or Arg - no implicit conversion  */
 
-			/* Need an operand of type INTERNAL_TYPE_REFERENCE */
+			/* Need an operand of type ACPI_TYPE_LOCAL_REFERENCE */
 
-			if (VALID_DESCRIPTOR_TYPE (obj_desc, ACPI_DESC_TYPE_NAMED))            /* direct name ptr OK as-is */ {
+			if (ACPI_GET_DESCRIPTOR_TYPE (obj_desc) == ACPI_DESC_TYPE_NAMED) /* Node (name) ptr OK as-is */ {
 				goto next_operand;
 			}
 
-			status = acpi_ex_check_object_type (INTERNAL_TYPE_REFERENCE,
+			status = acpi_ex_check_object_type (ACPI_TYPE_LOCAL_REFERENCE,
 					  object_type, obj_desc);
 			if (ACPI_FAILURE (status)) {
 				return_ACPI_STATUS (status);
 			}
 
-
 			if (AML_NAME_OP == obj_desc->reference.opcode) {
 				/*
 				 * Convert an indirect name ptr to direct name ptr and put
@@ -268,25 +306,27 @@ acpi_ex_resolve_operands (
 				acpi_ut_remove_reference (obj_desc);
 				(*stack_ptr) = temp_node;
 			}
-
 			goto next_operand;
-			break;
 
 
 		case ARGI_ANYTYPE:
 
 			/*
-			 * We don't want to resolve Index_op reference objects during
-			 * a store because this would be an implicit De_ref_of operation.
+			 * We don't want to resolve index_op reference objects during
+			 * a store because this would be an implicit de_ref_of operation.
 			 * Instead, we just want to store the reference object.
 			 * -- All others must be resolved below.
 			 */
 			if ((opcode == AML_STORE_OP) &&
-				((*stack_ptr)->common.type == INTERNAL_TYPE_REFERENCE) &&
+				(ACPI_GET_OBJECT_TYPE (*stack_ptr) == ACPI_TYPE_LOCAL_REFERENCE) &&
 				((*stack_ptr)->reference.opcode == AML_INDEX_OP)) {
 				goto next_operand;
 			}
 			break;
+
+		default:
+			/* All cases covered above */
+			break;
 		}
 
 
@@ -298,6 +338,9 @@ acpi_ex_resolve_operands (
 			return_ACPI_STATUS (status);
 		}
 
+		/* Get the resolved object */
+
+		obj_desc = *stack_ptr;
 
 		/*
 		 * Check the resulting object (value) type
@@ -321,20 +364,6 @@ acpi_ex_resolve_operands (
 			type_needed = ACPI_TYPE_EVENT;
 			break;
 
-		case ARGI_REGION:
-
-			/* Need an operand of type ACPI_TYPE_REGION */
-
-			type_needed = ACPI_TYPE_REGION;
-			break;
-
-		case ARGI_IF:   /* If */
-
-			/* Need an operand of type INTERNAL_TYPE_IF */
-
-			type_needed = INTERNAL_TYPE_IF;
-			break;
-
 		case ARGI_PACKAGE:   /* Package */
 
 			/* Need an operand of type ACPI_TYPE_PACKAGE */
@@ -358,22 +387,21 @@ acpi_ex_resolve_operands (
 			/*
 			 * Need an operand of type ACPI_TYPE_INTEGER,
 			 * But we can implicitly convert from a STRING or BUFFER
+			 * Aka - "Implicit Source Operand Conversion"
 			 */
-			status = acpi_ex_convert_to_integer (*stack_ptr, stack_ptr, walk_state);
+			status = acpi_ex_convert_to_integer (obj_desc, stack_ptr, walk_state);
 			if (ACPI_FAILURE (status)) {
 				if (status == AE_TYPE) {
-					ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 						"Needed [Integer/String/Buffer], found [%s] %p\n",
-						acpi_ut_get_type_name ((*stack_ptr)->common.type), *stack_ptr));
+						acpi_ut_get_object_type_name (obj_desc), obj_desc));
 
 					return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 				}
 
 				return_ACPI_STATUS (status);
 			}
-
 			goto next_operand;
-			break;
 
 
 		case ARGI_BUFFER:
@@ -381,22 +409,21 @@ acpi_ex_resolve_operands (
 			/*
 			 * Need an operand of type ACPI_TYPE_BUFFER,
 			 * But we can implicitly convert from a STRING or INTEGER
+			 * Aka - "Implicit Source Operand Conversion"
 			 */
-			status = acpi_ex_convert_to_buffer (*stack_ptr, stack_ptr, walk_state);
+			status = acpi_ex_convert_to_buffer (obj_desc, stack_ptr, walk_state);
 			if (ACPI_FAILURE (status)) {
 				if (status == AE_TYPE) {
-					ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 						"Needed [Integer/String/Buffer], found [%s] %p\n",
-						acpi_ut_get_type_name ((*stack_ptr)->common.type), *stack_ptr));
+						acpi_ut_get_object_type_name (obj_desc), obj_desc));
 
 					return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 				}
 
 				return_ACPI_STATUS (status);
 			}
-
 			goto next_operand;
-			break;
 
 
 		case ARGI_STRING:
@@ -404,95 +431,146 @@ acpi_ex_resolve_operands (
 			/*
 			 * Need an operand of type ACPI_TYPE_STRING,
 			 * But we can implicitly convert from a BUFFER or INTEGER
+			 * Aka - "Implicit Source Operand Conversion"
 			 */
-			status = acpi_ex_convert_to_string (*stack_ptr, stack_ptr, 16, ACPI_UINT32_MAX, walk_state);
+			status = acpi_ex_convert_to_string (obj_desc, stack_ptr, 16, ACPI_UINT32_MAX, walk_state);
 			if (ACPI_FAILURE (status)) {
 				if (status == AE_TYPE) {
-					ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 						"Needed [Integer/String/Buffer], found [%s] %p\n",
-						acpi_ut_get_type_name ((*stack_ptr)->common.type), *stack_ptr));
+						acpi_ut_get_object_type_name (obj_desc), obj_desc));
 
 					return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 				}
 
 				return_ACPI_STATUS (status);
 			}
-
 			goto next_operand;
-			break;
 
 
 		case ARGI_COMPUTEDATA:
 
 			/* Need an operand of type INTEGER, STRING or BUFFER */
 
-			if ((ACPI_TYPE_INTEGER != (*stack_ptr)->common.type) &&
-				(ACPI_TYPE_STRING != (*stack_ptr)->common.type) &&
-				(ACPI_TYPE_BUFFER != (*stack_ptr)->common.type)) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+			switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
+			case ACPI_TYPE_INTEGER:
+			case ACPI_TYPE_STRING:
+			case ACPI_TYPE_BUFFER:
+
+				/* Valid operand */
+			   break;
+
+			default:
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 					"Needed [Integer/String/Buffer], found [%s] %p\n",
-					acpi_ut_get_type_name ((*stack_ptr)->common.type), *stack_ptr));
+					acpi_ut_get_object_type_name (obj_desc), obj_desc));
 
 				return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 			}
 			goto next_operand;
-			break;
 
 
-		case ARGI_DATAOBJECT:
-			/*
-			 * ARGI_DATAOBJECT is only used by the Size_of operator.
-			 *
-			 * The ACPI specification allows Size_of to return the size of
-			 *  a Buffer, String or Package.  However, the MS ACPI.SYS AML
-			 *  Interpreter also allows an Node reference to return without
-			 *  error with a size of 4.
-			 */
+		case ARGI_BUFFER_OR_STRING:
+
+			/* Need an operand of type STRING or BUFFER */
+
+			switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
+			case ACPI_TYPE_STRING:
+			case ACPI_TYPE_BUFFER:
 
-			/* Need a buffer, string, package or Node reference */
+				/* Valid operand */
+			   break;
 
-			if (((*stack_ptr)->common.type != ACPI_TYPE_BUFFER) &&
-				((*stack_ptr)->common.type != ACPI_TYPE_STRING) &&
-				((*stack_ptr)->common.type != ACPI_TYPE_PACKAGE) &&
-				((*stack_ptr)->common.type != INTERNAL_TYPE_REFERENCE)) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-					"Needed [Buf/Str/Pkg/Ref], found [%s] %p\n",
-					acpi_ut_get_type_name ((*stack_ptr)->common.type), *stack_ptr));
+			case ACPI_TYPE_INTEGER:
+
+				/* Highest priority conversion is to type Buffer */
+
+				status = acpi_ex_convert_to_buffer (obj_desc, stack_ptr, walk_state);
+				if (ACPI_FAILURE (status)) {
+					return_ACPI_STATUS (status);
+				}
+				break;
+
+			default:
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+					"Needed [Integer/String/Buffer], found [%s] %p\n",
+					acpi_ut_get_object_type_name (obj_desc), obj_desc));
 
 				return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 			}
+			goto next_operand;
+
 
+		case ARGI_DATAOBJECT:
 			/*
-			 * If this is a reference, only allow a reference to an Node.
+			 * ARGI_DATAOBJECT is only used by the size_of operator.
+			 * Need a buffer, string, package, or ref_of reference.
+			 *
+			 * The only reference allowed here is a direct reference to
+			 * a namespace node.
 			 */
-			if ((*stack_ptr)->common.type == INTERNAL_TYPE_REFERENCE) {
-				if (!(*stack_ptr)->reference.node) {
-					ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-						"Needed [Node Reference], found [%p]\n",
-						*stack_ptr));
+			switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
+			case ACPI_TYPE_PACKAGE:
+			case ACPI_TYPE_STRING:
+			case ACPI_TYPE_BUFFER:
+			case ACPI_TYPE_LOCAL_REFERENCE:
+
+				/* Valid operand */
+				break;
+
+			default:
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+					"Needed [Buffer/String/Package/Reference], found [%s] %p\n",
+					acpi_ut_get_object_type_name (obj_desc), obj_desc));
 
-					return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
-				}
+				return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 			}
 			goto next_operand;
-			break;
 
 
 		case ARGI_COMPLEXOBJ:
 
 			/* Need a buffer or package or (ACPI 2.0) String */
 
-			if (((*stack_ptr)->common.type != ACPI_TYPE_BUFFER) &&
-				((*stack_ptr)->common.type != ACPI_TYPE_STRING) &&
-				((*stack_ptr)->common.type != ACPI_TYPE_PACKAGE)) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-					"Needed [Buf/Pkg], found [%s] %p\n",
-					acpi_ut_get_type_name ((*stack_ptr)->common.type), *stack_ptr));
+			switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
+			case ACPI_TYPE_PACKAGE:
+			case ACPI_TYPE_STRING:
+			case ACPI_TYPE_BUFFER:
+
+				/* Valid operand */
+				break;
+
+			default:
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+					"Needed [Buffer/String/Package], found [%s] %p\n",
+					acpi_ut_get_object_type_name (obj_desc), obj_desc));
+
+				return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
+			}
+			goto next_operand;
+
+
+		case ARGI_REGION_OR_FIELD:
+
+			/* Need an operand of type ACPI_TYPE_REGION or a FIELD in a region */
+
+			switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
+			case ACPI_TYPE_REGION:
+			case ACPI_TYPE_LOCAL_REGION_FIELD:
+			case ACPI_TYPE_LOCAL_BANK_FIELD:
+			case ACPI_TYPE_LOCAL_INDEX_FIELD:
+
+				/* Valid operand */
+				break;
+
+			default:
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+					"Needed [Region/region_field], found [%s] %p\n",
+					acpi_ut_get_object_type_name (obj_desc), obj_desc));
 
 				return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 			}
 			goto next_operand;
-			break;
 
 
 		default:
@@ -500,27 +578,25 @@ acpi_ex_resolve_operands (
 			/* Unknown type */
 
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Internal - Unknown ARGI type %X\n",
+				"Internal - Unknown ARGI (required operand) type %X\n",
 				this_arg_type));
 
 			return_ACPI_STATUS (AE_BAD_PARAMETER);
 		}
 
-
 		/*
 		 * Make sure that the original object was resolved to the
 		 * required object type (Simple cases only).
 		 */
 		status = acpi_ex_check_object_type (type_needed,
-				  (*stack_ptr)->common.type, *stack_ptr);
+				  ACPI_GET_OBJECT_TYPE (*stack_ptr), *stack_ptr);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
 
-
 next_operand:
 		/*
-		 * If more operands needed, decrement Stack_ptr to point
+		 * If more operands needed, decrement stack_ptr to point
 		 * to next operand on stack
 		 */
 		if (GET_CURRENT_ARG_TYPE (arg_types)) {
@@ -529,7 +605,6 @@ next_operand:
 
 	}   /* while (*Types) */
 
-
 	return_ACPI_STATUS (status);
 }
 
diff -urNp linux-5400/drivers/acpi/executer/exstore.c linux-5410/drivers/acpi/executer/exstore.c
--- linux-5400/drivers/acpi/executer/exstore.c
+++ linux-5410/drivers/acpi/executer/exstore.c
@@ -2,113 +2,142 @@
 /******************************************************************************
  *
  * Module Name: exstore - AML Interpreter object store support
- *              $Revision: 150 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
-#include "acdispat.h"
-#include "acinterp.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "actables.h"
+#include <acpi/acpi.h>
+#include <acpi/acdispat.h>
+#include <acpi/acinterp.h>
+#include <acpi/amlcode.h>
+#include <acpi/acnamesp.h>
 
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("exstore")
+	 ACPI_MODULE_NAME    ("exstore")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_store
+ * FUNCTION:    acpi_ex_store
  *
- * PARAMETERS:  *Source_desc        - Value to be stored
- *              *Dest_desc          - Where to store it.  Must be an NS node
- *                                    or an acpi_operand_object of type
+ * PARAMETERS:  *source_desc        - Value to be stored
+ *              *dest_desc          - Where to store it.  Must be an NS node
+ *                                    or an union acpi_operand_object of type
  *                                    Reference;
+ *              walk_state          - Current walk state
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Store the value described by Source_desc into the location
- *              described by Dest_desc. Called by various interpreter
+ * DESCRIPTION: Store the value described by source_desc into the location
+ *              described by dest_desc. Called by various interpreter
  *              functions to store the result of an operation into
- *              the destination operand.
+ *              the destination operand -- not just simply the actual "Store"
+ *              ASL operator.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ex_store (
-	acpi_operand_object     *source_desc,
-	acpi_operand_object     *dest_desc,
-	acpi_walk_state         *walk_state)
+	union acpi_operand_object       *source_desc,
+	union acpi_operand_object       *dest_desc,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status = AE_OK;
-	acpi_operand_object     *ref_desc = dest_desc;
+	acpi_status                     status = AE_OK;
+	union acpi_operand_object       *ref_desc = dest_desc;
 
 
-	FUNCTION_TRACE_PTR ("Ex_store", dest_desc);
+	ACPI_FUNCTION_TRACE_PTR ("ex_store", dest_desc);
 
 
 	/* Validate parameters */
 
 	if (!source_desc || !dest_desc) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Internal - null pointer\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Null parameter\n"));
 		return_ACPI_STATUS (AE_AML_NO_OPERAND);
 	}
 
-	/* Dest_desc can be either a namespace node or an ACPI object */
+	/* dest_desc can be either a namespace node or an ACPI object */
 
-	if (VALID_DESCRIPTOR_TYPE (dest_desc, ACPI_DESC_TYPE_NAMED)) {
+	if (ACPI_GET_DESCRIPTOR_TYPE (dest_desc) == ACPI_DESC_TYPE_NAMED) {
 		/*
 		 * Dest is a namespace node,
-		 * Storing an object into a Name "container"
+		 * Storing an object into a Named node.
 		 */
 		status = acpi_ex_store_object_to_node (source_desc,
-				 (acpi_namespace_node *) dest_desc, walk_state);
-
-		/* All done, that's it */
+				 (struct acpi_namespace_node *) dest_desc, walk_state);
 
 		return_ACPI_STATUS (status);
 	}
 
+	/* Destination object must be a Reference or a Constant object */
+
+	switch (ACPI_GET_OBJECT_TYPE (dest_desc)) {
+	case ACPI_TYPE_LOCAL_REFERENCE:
+		break;
+
+	case ACPI_TYPE_INTEGER:
+
+		/* Allow stores to Constants -- a Noop as per ACPI spec */
+
+		if (dest_desc->common.flags & AOPOBJ_AML_CONSTANT) {
+			return_ACPI_STATUS (AE_OK);
+		}
+
+		/*lint -fallthrough */
 
-	/* Destination object must be an object of type Reference */
+	default:
 
-	if (dest_desc->common.type != INTERNAL_TYPE_REFERENCE) {
 		/* Destination is not an Reference */
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Destination is not a Reference_obj [%p]\n", dest_desc));
+			"Destination is not a Reference or Constant object [%p]\n", dest_desc));
 
-		DUMP_STACK_ENTRY (source_desc);
-		DUMP_STACK_ENTRY (dest_desc);
-		DUMP_OPERANDS (&dest_desc, IMODE_EXECUTE, "Ex_store",
-				  2, "Target is not a Reference_obj");
+		ACPI_DUMP_STACK_ENTRY (source_desc);
+		ACPI_DUMP_STACK_ENTRY (dest_desc);
+		ACPI_DUMP_OPERANDS (&dest_desc, ACPI_IMODE_EXECUTE, "ex_store",
+				  2, "Target is not a Reference or Constant object");
 
 		return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 	}
 
-
 	/*
 	 * Examine the Reference opcode.  These cases are handled:
 	 *
@@ -116,11 +145,10 @@ acpi_ex_store (
 	 * 2) Store to an indexed area of a Buffer or Package
 	 * 3) Store to a Method Local or Arg
 	 * 4) Store to the debug object
-	 * 5) Store to a constant -- a noop
 	 */
 	switch (ref_desc->reference.opcode) {
-
 	case AML_NAME_OP:
+	case AML_REF_OF_OP:
 
 		/* Storing an object into a Name "container" */
 
@@ -153,23 +181,24 @@ acpi_ex_store (
 		 * Storing to the Debug object causes the value stored to be
 		 * displayed and otherwise has no effect -- see ACPI Specification
 		 */
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "**** Write to Debug Object: ****:\n\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "**** Write to Debug Object: ****:\n\n"));
 
 		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "[ACPI Debug] %s: ",
-				  acpi_ut_get_type_name (source_desc->common.type)));
+				  acpi_ut_get_object_type_name (source_desc)));
 
-		switch (source_desc->common.type) {
+		switch (ACPI_GET_OBJECT_TYPE (source_desc)) {
 		case ACPI_TYPE_INTEGER:
 
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "0x%X (%d)\n",
-				(u32) source_desc->integer.value, (u32) source_desc->integer.value));
+			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "%8.8X%8.8X\n",
+					ACPI_HIDWORD (source_desc->integer.value),
+					ACPI_LODWORD (source_desc->integer.value)));
 			break;
 
 
 		case ACPI_TYPE_BUFFER:
 
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "Length 0x%X\n",
-				(u32) source_desc->buffer.length));
+			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "Length %.2X\n",
+					(u32) source_desc->buffer.length));
 			break;
 
 
@@ -181,47 +210,31 @@ acpi_ex_store (
 
 		case ACPI_TYPE_PACKAGE:
 
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "Elements - %p\n",
-				source_desc->package.elements));
+			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "Elements Ptr - %p\n",
+					source_desc->package.elements));
 			break;
 
 
 		default:
 
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "@0x%p\n", source_desc));
+			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DEBUG_OBJECT, "Type %s %p\n",
+					acpi_ut_get_object_type_name (source_desc), source_desc));
 			break;
 		}
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "\n"));
-		break;
-
-
-	case AML_ZERO_OP:
-	case AML_ONE_OP:
-	case AML_ONES_OP:
-	case AML_REVISION_OP:
-
-		/*
-		 * Storing to a constant is a no-op -- see ACPI Specification
-		 * Delete the reference descriptor, however
-		 */
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_EXEC, "\n"));
 		break;
 
 
 	default:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Internal - Unknown Reference subtype %02x\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown Reference opcode %X\n",
 			ref_desc->reference.opcode));
-
-		/* TBD: [Restructure] use object dump routine !! */
-
-		DUMP_BUFFER (ref_desc, sizeof (acpi_operand_object));
+		ACPI_DUMP_ENTRY (ref_desc, ACPI_LV_ERROR);
 
 		status = AE_AML_INTERNAL;
 		break;
-
-	}   /* switch (Ref_desc->Reference.Opcode) */
-
+	}
 
 	return_ACPI_STATUS (status);
 }
@@ -229,38 +242,38 @@ acpi_ex_store (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_store_object_to_index
+ * FUNCTION:    acpi_ex_store_object_to_index
  *
- * PARAMETERS:  *Source_desc          - Value to be stored
- *              *Node               - Named object to receive the value
+ * PARAMETERS:  *source_desc            - Value to be stored
+ *              *dest_desc              - Named object to receive the value
+ *              walk_state              - Current walk state
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Store the object to the named object.
+ * DESCRIPTION: Store the object to indexed Buffer or Package element
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ex_store_object_to_index (
-	acpi_operand_object     *source_desc,
-	acpi_operand_object     *dest_desc,
-	acpi_walk_state         *walk_state)
+	union acpi_operand_object       *source_desc,
+	union acpi_operand_object       *index_desc,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status = AE_OK;
-	acpi_operand_object     *obj_desc;
-	u32                     length;
-	u32                     i;
-	u8                      value = 0;
+	acpi_status                     status = AE_OK;
+	union acpi_operand_object       *obj_desc;
+	union acpi_operand_object       *new_desc;
+	u8                              value = 0;
 
 
-	FUNCTION_TRACE ("Ex_store_object_to_index");
+	ACPI_FUNCTION_TRACE ("ex_store_object_to_index");
 
 
 	/*
 	 * Destination must be a reference pointer, and
 	 * must point to either a buffer or a package
 	 */
-	switch (dest_desc->reference.target_type) {
+	switch (index_desc->reference.target_type) {
 	case ACPI_TYPE_PACKAGE:
 		/*
 		 * Storing to a package element is not simple.  The source must be
@@ -268,74 +281,34 @@ acpi_ex_store_object_to_index (
 		 * source is copied into the destination - we can't just point to the
 		 * source object.
 		 */
-		if (dest_desc->reference.target_type == ACPI_TYPE_PACKAGE) {
-			/*
-			 * The object at *(Dest_desc->Reference.Where) is the
-			 * element within the package that is to be modified.
-			 */
-			obj_desc = *(dest_desc->reference.where);
-			if (obj_desc) {
-				/*
-				 * If the Destination element is a package, we will delete
-				 *  that object and construct a new one.
-				 *
-				 * TBD: [Investigate] Should both the src and dest be required
-				 *      to be packages?
-				 *       && (Source_desc->Common.Type == ACPI_TYPE_PACKAGE)
-				 */
-				if (obj_desc->common.type == ACPI_TYPE_PACKAGE) {
-					/* Take away the reference for being part of a package */
-
-					acpi_ut_remove_reference (obj_desc);
-					obj_desc = NULL;
-				}
-			}
+		/*
+		 * The object at *(index_desc->Reference.Where) is the
+		 * element within the package that is to be modified.
+		 */
+		obj_desc = *(index_desc->reference.where);
+
+		/* Do the conversion/store */
 
-			if (!obj_desc) {
-				/*
-				 * If the Obj_desc is NULL, it means that an uninitialized package
-				 * element has been used as a destination (this is OK), therefore,
-				 * we must create the destination element to match the type of the
-				 * source element NOTE: Source_desccan be of any type.
-				 */
-				obj_desc = acpi_ut_create_internal_object (source_desc->common.type);
-				if (!obj_desc) {
-					return_ACPI_STATUS (AE_NO_MEMORY);
-				}
-
-				/*
-				 * If the source is a package, copy the source to the new dest
-				 */
-				if (ACPI_TYPE_PACKAGE == obj_desc->common.type) {
-					status = acpi_ut_copy_ipackage_to_ipackage (source_desc, obj_desc, walk_state);
-					if (ACPI_FAILURE (status)) {
-						acpi_ut_remove_reference (obj_desc);
-						return_ACPI_STATUS (status);
-					}
-				}
+		status = acpi_ex_store_object_to_object (source_desc, obj_desc, &new_desc,
+				  walk_state);
+		if (ACPI_FAILURE (status)) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Could not store object to indexed package element\n"));
+			return_ACPI_STATUS (status);
+		}
 
-				/* Install the new descriptor into the package */
+		/*
+		 * If a new object was created, we must install it as the new
+		 * package element
+		 */
+		if (new_desc != obj_desc) {
+			acpi_ut_remove_reference (obj_desc);
+			*(index_desc->reference.where) = new_desc;
 
-				*(dest_desc->reference.where) = obj_desc;
-			}
+			/* If same as the original source, add a reference */
 
-			if (ACPI_TYPE_PACKAGE != obj_desc->common.type) {
-				/*
-				 * The destination element is not a package, so we need to
-				 * convert the contents of the source (Source_desc) and copy into
-				 * the destination (Obj_desc)
-				 */
-				status = acpi_ex_store_object_to_object (source_desc, obj_desc,
-						  walk_state);
-				if (ACPI_FAILURE (status)) {
-					/*
-					 * An error occurrered when copying the internal object
-					 * so delete the reference.
-					 */
-					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-						"Unable to copy the internal object\n"));
-					return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
-				}
+			if (new_desc == source_desc) {
+				acpi_ut_add_reference (new_desc);
 			}
 		}
 		break;
@@ -343,21 +316,20 @@ acpi_ex_store_object_to_index (
 
 	case ACPI_TYPE_BUFFER_FIELD:
 
-
-		/* TBD: can probably call the generic Buffer/Field routines */
-
 		/*
-		 * Storing into a buffer at a location defined by an Index.
+		 * Store into a Buffer (not actually a real buffer_field) at a
+		 * location defined by an Index.
 		 *
-		 * Each 8-bit element of the source object is written to the
-		 * 8-bit Buffer Field of the Index destination object.
+		 * The first 8-bit element of the source object is written to the
+		 * 8-bit Buffer location defined by the Index destination object,
+		 * according to the ACPI 2.0 specification.
 		 */
 
 		/*
-		 * Set the Obj_desc to the destination object and type check.
+		 * Make sure the target is a Buffer
 		 */
-		obj_desc = dest_desc->reference.object;
-		if (obj_desc->common.type != ACPI_TYPE_BUFFER) {
+		obj_desc = index_desc->reference.object;
+		if (ACPI_GET_OBJECT_TYPE (obj_desc) != ACPI_TYPE_BUFFER) {
 			return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 		}
 
@@ -365,84 +337,65 @@ acpi_ex_store_object_to_index (
 		 * The assignment of the individual elements will be slightly
 		 * different for each source type.
 		 */
-		switch (source_desc->common.type) {
+		switch (ACPI_GET_OBJECT_TYPE (source_desc)) {
 		case ACPI_TYPE_INTEGER:
-			/*
-			 * Type is Integer, assign bytewise
-			 * This loop to assign each of the elements is somewhat
-			 * backward because of the Big Endian-ness of IA-64
-			 */
-			length = sizeof (acpi_integer);
-			for (i = length; i != 0; i--) {
-				value = (u8)(source_desc->integer.value >> (MUL_8 (i - 1)));
-				obj_desc->buffer.pointer[dest_desc->reference.offset] = value;
-			}
-			break;
 
+			/* Use the least-significant byte of the integer */
 
-		case ACPI_TYPE_BUFFER:
-			/*
-			 * Type is Buffer, the Length is in the structure.
-			 * Just loop through the elements and assign each one in turn.
-			 */
-			length = source_desc->buffer.length;
-			for (i = 0; i < length; i++) {
-				value = source_desc->buffer.pointer[i];
-				obj_desc->buffer.pointer[dest_desc->reference.offset] = value;
-			}
+			value = (u8) (source_desc->integer.value);
 			break;
 
+		case ACPI_TYPE_BUFFER:
 
-		case ACPI_TYPE_STRING:
-			/*
-			 * Type is String, the Length is in the structure.
-			 * Just loop through the elements and assign each one in turn.
-			 */
-			length = source_desc->string.length;
-			for (i = 0; i < length; i++) {
-				value = source_desc->string.pointer[i];
-				obj_desc->buffer.pointer[dest_desc->reference.offset] = value;
-			}
+			value = source_desc->buffer.pointer[0];
 			break;
 
+		case ACPI_TYPE_STRING:
+
+			value = (u8) source_desc->string.pointer[0];
+			break;
 
 		default:
 
-			/* Other types are invalid */
+			/* All other types are invalid */
 
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Source must be Number/Buffer/String type, not %X\n",
-				source_desc->common.type));
-			status = AE_AML_OPERAND_TYPE;
-			break;
+				"Source must be Integer/Buffer/String type, not %s\n",
+				acpi_ut_get_object_type_name (source_desc)));
+			return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 		}
+
+		/* Store the source value into the target buffer byte */
+
+		obj_desc->buffer.pointer[index_desc->reference.offset] = value;
 		break;
 
 
 	default:
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Target is not a Package or Buffer_field\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Target is not a Package or buffer_field\n"));
 		status = AE_AML_OPERAND_TYPE;
 		break;
 	}
 
-
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_store_object_to_node
+ * FUNCTION:    acpi_ex_store_object_to_node
  *
- * PARAMETERS:  *Source_desc           - Value to be stored
- *              *Node                  - Named object to receive the value
+ * PARAMETERS:  source_desc             - Value to be stored
+ *              Node                    - Named object to receive the value
+ *              walk_state              - Current walk state
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Store the object to the named object.
  *
  *              The Assignment of an object to a named object is handled here
- *              The val passed in will replace the current value (if any)
+ *              The value passed in will replace the current value (if any)
  *              with the input value.
  *
  *              When storing into an object the data is converted to the
@@ -450,41 +403,34 @@ acpi_ex_store_object_to_index (
  *              that the target object type (for an initialized target) will
  *              not be changed by a store operation.
  *
- *              NOTE: the global lock is acquired early.  This will result
- *              in the global lock being held a bit longer.  Also, if the
- *              function fails during set up we may get the lock when we
- *              don't really need it.  I don't think we care.
+ *              Assumes parameters are already validated.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ex_store_object_to_node (
-	acpi_operand_object     *source_desc,
-	acpi_namespace_node     *node,
-	acpi_walk_state         *walk_state)
+	union acpi_operand_object       *source_desc,
+	struct acpi_namespace_node      *node,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status = AE_OK;
-	acpi_operand_object     *target_desc;
-	acpi_object_type8       target_type = ACPI_TYPE_ANY;
+	acpi_status                     status = AE_OK;
+	union acpi_operand_object       *target_desc;
+	union acpi_operand_object       *new_desc;
+	acpi_object_type                target_type;
 
 
-	FUNCTION_TRACE ("Ex_store_object_to_node");
+	ACPI_FUNCTION_TRACE_PTR ("ex_store_object_to_node", source_desc);
 
 
 	/*
-	 * Assuming the parameters were already validated
-	 */
-
-	/*
 	 * Get current type of the node, and object attached to Node
 	 */
 	target_type = acpi_ns_get_type (node);
 	target_desc = acpi_ns_get_attached_object (node);
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Storing %p(%s) into node %p(%s)\n",
-		node, acpi_ut_get_type_name (source_desc->common.type),
-		source_desc, acpi_ut_get_type_name (target_type)));
-
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Storing %p(%s) into node %p(%s)\n",
+		source_desc, acpi_ut_get_object_type_name (source_desc),
+			  node, acpi_ut_get_type_name (target_type)));
 
 	/*
 	 * Resolve the source object to an actual value
@@ -495,20 +441,19 @@ acpi_ex_store_object_to_node (
 		return_ACPI_STATUS (status);
 	}
 
-
 	/*
 	 * Do the actual store operation
 	 */
 	switch (target_type) {
 	case ACPI_TYPE_BUFFER_FIELD:
-	case INTERNAL_TYPE_REGION_FIELD:
-	case INTERNAL_TYPE_BANK_FIELD:
-	case INTERNAL_TYPE_INDEX_FIELD:
+	case ACPI_TYPE_LOCAL_REGION_FIELD:
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
+	case ACPI_TYPE_LOCAL_INDEX_FIELD:
 
 		/*
 		 * For fields, copy the source data to the target field.
 		 */
-		status = acpi_ex_write_data_to_field (source_desc, target_desc);
+		status = acpi_ex_write_data_to_field (source_desc, target_desc, &walk_state->result_obj);
 		break;
 
 
@@ -522,122 +467,44 @@ acpi_ex_store_object_to_node (
 		 *
 		 * Copy and/or convert the source object to a new target object
 		 */
-		status = acpi_ex_store_object (source_desc, target_type, &target_desc, walk_state);
+		status = acpi_ex_store_object_to_object (source_desc, target_desc, &new_desc, walk_state);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
 
-		/*
-		 * Store the new Target_desc as the new value of the Name, and set
-		 * the Name's type to that of the value being stored in it.
-		 * Source_desc reference count is incremented by Attach_object.
-		 */
-		status = acpi_ns_attach_object (node, target_desc, target_type);
+		if (new_desc != target_desc) {
+			/*
+			 * Store the new new_desc as the new value of the Name, and set
+			 * the Name's type to that of the value being stored in it.
+			 * source_desc reference count is incremented by attach_object.
+			 *
+			 * Note: This may change the type of the node if an explicit store
+			 * has been performed such that the node/object type has been
+			 * changed.
+			 */
+			status = acpi_ns_attach_object (node, new_desc, new_desc->common.type);
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-			"Store %s into %s via Convert/Attach\n",
-			acpi_ut_get_type_name (target_desc->common.type),
-			acpi_ut_get_type_name (target_type)));
+			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+				"Store %s into %s via Convert/Attach\n",
+				acpi_ut_get_object_type_name (source_desc),
+				acpi_ut_get_object_type_name (new_desc)));
+		}
 		break;
 
 
 	default:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
 			"Storing %s (%p) directly into node (%p), no implicit conversion\n",
-			acpi_ut_get_type_name (source_desc->common.type), source_desc, node));
+			acpi_ut_get_object_type_name (source_desc), source_desc, node));
 
 		/* No conversions for all other types.  Just attach the source object */
 
-		status = acpi_ns_attach_object (node, source_desc, source_desc->common.type);
+		status = acpi_ns_attach_object (node, source_desc, ACPI_GET_OBJECT_TYPE (source_desc));
 		break;
 	}
 
-
 	return_ACPI_STATUS (status);
 }
 
 
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ex_store_object_to_object
- *
- * PARAMETERS:  *Source_desc           - Value to be stored
- *              *Dest_desc          - Object to receive the value
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Store an object to another object.
- *
- *              The Assignment of an object to another (not named) object
- *              is handled here.
- *              The val passed in will replace the current value (if any)
- *              with the input value.
- *
- *              When storing into an object the data is converted to the
- *              target object type then stored in the object.  This means
- *              that the target object type (for an initialized target) will
- *              not be changed by a store operation.
- *
- *              This module allows destination types of Number, String,
- *              and Buffer.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ex_store_object_to_object (
-	acpi_operand_object     *source_desc,
-	acpi_operand_object     *dest_desc,
-	acpi_walk_state         *walk_state)
-{
-	acpi_status             status = AE_OK;
-	acpi_object_type8       destination_type = dest_desc->common.type;
-
-
-	FUNCTION_TRACE ("Ex_store_object_to_object");
-
-
-	/*
-	 *  Assuming the parameters are valid!
-	 */
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Storing %p(%s) to %p(%s)\n",
-			  source_desc, acpi_ut_get_type_name (source_desc->common.type),
-			  dest_desc, acpi_ut_get_type_name (dest_desc->common.type)));
-
-
-	/*
-	 * From this interface, we only support Integers/Strings/Buffers
-	 */
-	switch (destination_type) {
-	case ACPI_TYPE_INTEGER:
-	case ACPI_TYPE_STRING:
-	case ACPI_TYPE_BUFFER:
-		break;
-
-	default:
-		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Store into %s not implemented\n",
-			acpi_ut_get_type_name (dest_desc->common.type)));
-
-		return_ACPI_STATUS (AE_NOT_IMPLEMENTED);
-	}
-
-
-	/*
-	 * Resolve the source object to an actual value
-	 * (If it is a reference object)
-	 */
-	status = acpi_ex_resolve_object (&source_desc, destination_type, walk_state);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
-
-
-	/*
-	 * Copy and/or convert the source object to the destination object
-	 */
-	status = acpi_ex_store_object (source_desc, destination_type, &dest_desc, walk_state);
-
-
-	return_ACPI_STATUS (status);
-}
-
diff -urNp linux-5400/drivers/acpi/executer/exstoren.c linux-5410/drivers/acpi/executer/exstoren.c
--- linux-5400/drivers/acpi/executer/exstoren.c
+++ linux-5410/drivers/acpi/executer/exstoren.c
@@ -3,128 +3,136 @@
  *
  * Module Name: exstoren - AML Interpreter object store support,
  *                        Store to Node (namespace object)
- *              $Revision: 40 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
-#include "acdispat.h"
-#include "acinterp.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "actables.h"
+#include <acpi/acpi.h>
+#include <acpi/acinterp.h>
 
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("exstoren")
+	 ACPI_MODULE_NAME    ("exstoren")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_resolve_object
+ * FUNCTION:    acpi_ex_resolve_object
  *
- * PARAMETERS:  Source_desc_ptr     - Pointer to the source object
- *              Target_type         - Current type of the target
- *              Walk_state          - Current walk state
+ * PARAMETERS:  source_desc_ptr     - Pointer to the source object
+ *              target_type         - Current type of the target
+ *              walk_state          - Current walk state
  *
- * RETURN:      Status, resolved object in Source_desc_ptr.
+ * RETURN:      Status, resolved object in source_desc_ptr.
  *
  * DESCRIPTION: Resolve an object.  If the object is a reference, dereference
- *              it and return the actual object in the Source_desc_ptr.
+ *              it and return the actual object in the source_desc_ptr.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ex_resolve_object (
-	acpi_operand_object     **source_desc_ptr,
-	acpi_object_type8       target_type,
-	acpi_walk_state         *walk_state)
+	union acpi_operand_object       **source_desc_ptr,
+	acpi_object_type                target_type,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_operand_object     *source_desc = *source_desc_ptr;
-	acpi_status             status = AE_OK;
+	union acpi_operand_object       *source_desc = *source_desc_ptr;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE ("Ex_resolve_object");
+	ACPI_FUNCTION_TRACE ("ex_resolve_object");
 
 
 	/*
-	 * Ensure we have a Source that can be stored in the target
+	 * Ensure we have a Target that can be stored to
 	 */
 	switch (target_type) {
-
-	/* This case handles the "interchangeable" types Integer, String, and Buffer. */
-
-	/*
-	 * These cases all require only Integers or values that
-	 * can be converted to Integers (Strings or Buffers)
-	 */
 	case ACPI_TYPE_BUFFER_FIELD:
-	case INTERNAL_TYPE_REGION_FIELD:
-	case INTERNAL_TYPE_BANK_FIELD:
-	case INTERNAL_TYPE_INDEX_FIELD:
+	case ACPI_TYPE_LOCAL_REGION_FIELD:
+	case ACPI_TYPE_LOCAL_BANK_FIELD:
+	case ACPI_TYPE_LOCAL_INDEX_FIELD:
+		/*
+		 * These cases all require only Integers or values that
+		 * can be converted to Integers (Strings or Buffers)
+		 */
 
-	/*
-	 * Stores into a Field/Region or into a Buffer/String
-	 * are all essentially the same.
-	 */
 	case ACPI_TYPE_INTEGER:
 	case ACPI_TYPE_STRING:
 	case ACPI_TYPE_BUFFER:
 
+		/*
+		 * Stores into a Field/Region or into a Integer/Buffer/String
+		 * are all essentially the same.  This case handles the
+		 * "interchangeable" types Integer, String, and Buffer.
+		 */
+		if (ACPI_GET_OBJECT_TYPE (source_desc) == ACPI_TYPE_LOCAL_REFERENCE) {
+			/* Resolve a reference object first */
 
-		/* TBD: FIX - check for source==REF, resolve, then check type */
+			status = acpi_ex_resolve_to_value (source_desc_ptr, walk_state);
+			if (ACPI_FAILURE (status)) {
+				break;
+			}
+		}
 
 		/*
-		 * If Source_desc is not a valid type, try to resolve it to one.
+		 * Must have a Integer, Buffer, or String
 		 */
-		if ((source_desc->common.type != ACPI_TYPE_INTEGER)    &&
-			(source_desc->common.type != ACPI_TYPE_BUFFER)     &&
-			(source_desc->common.type != ACPI_TYPE_STRING)) {
+		if ((ACPI_GET_OBJECT_TYPE (source_desc) != ACPI_TYPE_INTEGER)    &&
+			(ACPI_GET_OBJECT_TYPE (source_desc) != ACPI_TYPE_BUFFER)     &&
+			(ACPI_GET_OBJECT_TYPE (source_desc) != ACPI_TYPE_STRING)) {
 			/*
-			 * Initially not a valid type, convert
+			 * Conversion successful but still not a valid type
 			 */
-			status = acpi_ex_resolve_to_value (source_desc_ptr, walk_state);
-			if (ACPI_SUCCESS (status) &&
-				(source_desc->common.type != ACPI_TYPE_INTEGER)    &&
-				(source_desc->common.type != ACPI_TYPE_BUFFER)     &&
-				(source_desc->common.type != ACPI_TYPE_STRING)) {
-				/*
-				 * Conversion successful but still not a valid type
-				 */
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-					"Cannot assign type %s to %s (must be type Int/Str/Buf)\n",
-					acpi_ut_get_type_name ((*source_desc_ptr)->common.type),
-					acpi_ut_get_type_name (target_type)));
-				status = AE_AML_OPERAND_TYPE;
-			}
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Cannot assign type %s to %s (must be type Int/Str/Buf)\n",
+				acpi_ut_get_object_type_name (source_desc),
+				acpi_ut_get_type_name (target_type)));
+			status = AE_AML_OPERAND_TYPE;
 		}
 		break;
 
 
-	case INTERNAL_TYPE_ALIAS:
+	case ACPI_TYPE_LOCAL_ALIAS:
 
 		/*
-		 * Aliases are resolved by Acpi_ex_prep_operands
+		 * Aliases are resolved by acpi_ex_prep_operands
 		 */
 		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Store into Alias - should never happen\n"));
 		status = AE_AML_INTERNAL;
@@ -147,12 +155,12 @@ acpi_ex_resolve_object (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_store_object
+ * FUNCTION:    acpi_ex_store_object_to_object
  *
- * PARAMETERS:  Source_desc         - Object to store
- *              Target_type         - Current type of the target
- *              Target_desc_ptr     - Pointer to the target
- *              Walk_state          - Current walk state
+ * PARAMETERS:  source_desc         - Object to store
+ *              dest_desc           - Object to receive a copy of the source
+ *              new_desc            - New object if dest_desc is obsoleted
+ *              walk_state          - Current walk state
  *
  * RETURN:      Status
  *
@@ -161,93 +169,123 @@ acpi_ex_resolve_object (
  *              conversion), and a copy of the value of the source to
  *              the target.
  *
+ *              The Assignment of an object to another (not named) object
+ *              is handled here.
+ *              The Source passed in will replace the current value (if any)
+ *              with the input value.
+ *
+ *              When storing into an object the data is converted to the
+ *              target object type then stored in the object.  This means
+ *              that the target object type (for an initialized target) will
+ *              not be changed by a store operation.
+ *
+ *              This module allows destination types of Number, String,
+ *              Buffer, and Package.
+ *
+ *              Assumes parameters are already validated.  NOTE: source_desc
+ *              resolution (from a reference object) must be performed by
+ *              the caller if necessary.
+ *
  ******************************************************************************/
 
 acpi_status
-acpi_ex_store_object (
-	acpi_operand_object     *source_desc,
-	acpi_object_type8       target_type,
-	acpi_operand_object     **target_desc_ptr,
-	acpi_walk_state         *walk_state)
+acpi_ex_store_object_to_object (
+	union acpi_operand_object       *source_desc,
+	union acpi_operand_object       *dest_desc,
+	union acpi_operand_object       **new_desc,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_operand_object     *target_desc = *target_desc_ptr;
-	acpi_status             status = AE_OK;
+	union acpi_operand_object       *actual_src_desc;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE ("Ex_store_object");
+	ACPI_FUNCTION_TRACE_PTR ("ex_store_object_to_object", source_desc);
 
 
-	/*
-	 * Perform the "implicit conversion" of the source to the current type
-	 * of the target - As per the ACPI specification.
-	 *
-	 * If no conversion performed, Source_desc is left alone, otherwise it
-	 * is updated with a new object.
-	 */
-	status = acpi_ex_convert_to_target_type (target_type, &source_desc, walk_state);
-	if (ACPI_FAILURE (status)) {
+	actual_src_desc = source_desc;
+	if (!dest_desc) {
+		/*
+		 * There is no destination object (An uninitialized node or
+		 * package element), so we can simply copy the source object
+		 * creating a new destination object
+		 */
+		status = acpi_ut_copy_iobject_to_iobject (actual_src_desc, new_desc, walk_state);
 		return_ACPI_STATUS (status);
 	}
 
-	/*
-	 * We now have two objects of identical types, and we can perform a
-	 * copy of the *value* of the source object.
-	 */
-	switch (target_type) {
-	case ACPI_TYPE_ANY:
-	case INTERNAL_TYPE_DEF_ANY:
-
+	if (ACPI_GET_OBJECT_TYPE (source_desc) != ACPI_GET_OBJECT_TYPE (dest_desc)) {
 		/*
-		 * The target namespace node is uninitialized (has no target object),
-		 * and will take on the type of the source object
+		 * The source type does not match the type of the destination.
+		 * Perform the "implicit conversion" of the source to the current type
+		 * of the target as per the ACPI specification.
+		 *
+		 * If no conversion performed, actual_src_desc = source_desc.
+		 * Otherwise, actual_src_desc is a temporary object to hold the
+		 * converted object.
 		 */
-		*target_desc_ptr = source_desc;
-		break;
+		status = acpi_ex_convert_to_target_type (ACPI_GET_OBJECT_TYPE (dest_desc), source_desc,
+				  &actual_src_desc, walk_state);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
 
+		if (source_desc == actual_src_desc) {
+			/*
+			 * No conversion was performed.  Return the source_desc as the
+			 * new object.
+			 */
+			*new_desc = source_desc;
+			return_ACPI_STATUS (AE_OK);
+		}
+	}
 
+	/*
+	 * We now have two objects of identical types, and we can perform a
+	 * copy of the *value* of the source object.
+	 */
+	switch (ACPI_GET_OBJECT_TYPE (dest_desc)) {
 	case ACPI_TYPE_INTEGER:
 
-		target_desc->integer.value = source_desc->integer.value;
+		dest_desc->integer.value = actual_src_desc->integer.value;
 
 		/* Truncate value if we are executing from a 32-bit ACPI table */
 
-		acpi_ex_truncate_for32bit_table (target_desc, walk_state);
+		acpi_ex_truncate_for32bit_table (dest_desc);
 		break;
 
 	case ACPI_TYPE_STRING:
 
-		status = acpi_ex_copy_string_to_string (source_desc, target_desc);
+		status = acpi_ex_store_string_to_string (actual_src_desc, dest_desc);
 		break;
 
-
 	case ACPI_TYPE_BUFFER:
 
-		status = acpi_ex_copy_buffer_to_buffer (source_desc, target_desc);
+		status = acpi_ex_store_buffer_to_buffer (actual_src_desc, dest_desc);
 		break;
 
-
 	case ACPI_TYPE_PACKAGE:
 
-		/*
-		 * TBD: [Unhandled] Not real sure what to do here
-		 */
-		status = AE_NOT_IMPLEMENTED;
+		status = acpi_ut_copy_iobject_to_iobject (actual_src_desc, &dest_desc, walk_state);
 		break;
 
-
 	default:
-
 		/*
 		 * All other types come here.
 		 */
 		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Store into type %s not implemented\n",
-			acpi_ut_get_type_name (target_type)));
+			acpi_ut_get_object_type_name (dest_desc)));
 
 		status = AE_NOT_IMPLEMENTED;
 		break;
 	}
 
+	if (actual_src_desc != source_desc) {
+		/* Delete the intermediate (temporary) source object */
+
+		acpi_ut_remove_reference (actual_src_desc);
+	}
 
+	*new_desc = dest_desc;
 	return_ACPI_STATUS (status);
 }
 
diff -urNp linux-5400/drivers/acpi/executer/exstorob.c linux-5410/drivers/acpi/executer/exstorob.c
--- linux-5400/drivers/acpi/executer/exstorob.c
+++ linux-5410/drivers/acpi/executer/exstorob.c
@@ -2,48 +2,61 @@
 /******************************************************************************
  *
  * Module Name: exstorob - AML Interpreter object store support, store to object
- *              $Revision: 37 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
-#include "acdispat.h"
-#include "acinterp.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "actables.h"
+#include <acpi/acpi.h>
+#include <acpi/acinterp.h>
 
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("exstorob")
+	 ACPI_MODULE_NAME    ("exstorob")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_copy_buffer_to_buffer
+ * FUNCTION:    acpi_ex_store_buffer_to_buffer
  *
- * PARAMETERS:  Source_desc         - Source object to copy
- *              Target_desc         - Destination object of the copy
+ * PARAMETERS:  source_desc         - Source object to copy
+ *              target_desc         - Destination object of the copy
  *
  * RETURN:      Status
  *
@@ -52,33 +65,35 @@
  ******************************************************************************/
 
 acpi_status
-acpi_ex_copy_buffer_to_buffer (
-	acpi_operand_object     *source_desc,
-	acpi_operand_object     *target_desc)
+acpi_ex_store_buffer_to_buffer (
+	union acpi_operand_object       *source_desc,
+	union acpi_operand_object       *target_desc)
 {
-	u32                     length;
-	u8                      *buffer;
+	u32                             length;
+	u8                              *buffer;
 
 
-	PROC_NAME ("Ex_copy_buffer_to_buffer");
+	ACPI_FUNCTION_TRACE_PTR ("ex_store_buffer_to_buffer", source_desc);
 
 
 	/*
-	 * We know that Source_desc is a buffer by now
+	 * We know that source_desc is a buffer by now
 	 */
 	buffer = (u8 *) source_desc->buffer.pointer;
 	length = source_desc->buffer.length;
 
 	/*
-	 * If target is a buffer of length zero, allocate a new
-	 * buffer of the proper length
+	 * If target is a buffer of length zero or is a static buffer,
+	 * allocate a new buffer of the proper length
 	 */
-	if (target_desc->buffer.length == 0) {
+	if ((target_desc->buffer.length == 0) ||
+		(target_desc->common.flags & AOPOBJ_STATIC_POINTER)) {
 		target_desc->buffer.pointer = ACPI_MEM_ALLOCATE (length);
 		if (!target_desc->buffer.pointer) {
-			return (AE_NO_MEMORY);
+			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
 
+		target_desc->common.flags &= ~AOPOBJ_STATIC_POINTER;
 		target_desc->buffer.length = length;
 	}
 
@@ -89,31 +104,33 @@ acpi_ex_copy_buffer_to_buffer (
 	if (length <= target_desc->buffer.length) {
 		/* Clear existing buffer and copy in the new one */
 
-		MEMSET (target_desc->buffer.pointer, 0, target_desc->buffer.length);
-		MEMCPY (target_desc->buffer.pointer, buffer, length);
+		ACPI_MEMSET (target_desc->buffer.pointer, 0, target_desc->buffer.length);
+		ACPI_MEMCPY (target_desc->buffer.pointer, buffer, length);
 	}
-
 	else {
 		/*
 		 * Truncate the source, copy only what will fit
 		 */
-		MEMCPY (target_desc->buffer.pointer, buffer, target_desc->buffer.length);
+		ACPI_MEMCPY (target_desc->buffer.pointer, buffer, target_desc->buffer.length);
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
 			"Truncating src buffer from %X to %X\n",
 			length, target_desc->buffer.length));
 	}
 
-	return (AE_OK);
+	/* Copy flags */
+
+	target_desc->buffer.flags = source_desc->buffer.flags;
+	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_copy_string_to_string
+ * FUNCTION:    acpi_ex_store_string_to_string
  *
- * PARAMETERS:  Source_desc         - Source object to copy
- *              Target_desc         - Destination object of the copy
+ * PARAMETERS:  source_desc         - Source object to copy
+ *              target_desc         - Destination object of the copy
  *
  * RETURN:      Status
  *
@@ -122,36 +139,39 @@ acpi_ex_copy_buffer_to_buffer (
  ******************************************************************************/
 
 acpi_status
-acpi_ex_copy_string_to_string (
-	acpi_operand_object     *source_desc,
-	acpi_operand_object     *target_desc)
+acpi_ex_store_string_to_string (
+	union acpi_operand_object       *source_desc,
+	union acpi_operand_object       *target_desc)
 {
-	u32                     length;
-	u8                      *buffer;
+	u32                             length;
+	u8                              *buffer;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_TRACE_PTR ("ex_store_string_to_string", source_desc);
 
 
 	/*
-	 * We know that Source_desc is a string by now.
+	 * We know that source_desc is a string by now.
 	 */
 	buffer = (u8 *) source_desc->string.pointer;
 	length = source_desc->string.length;
 
 	/*
-	 * Setting a string value replaces the old string
+	 * Replace existing string value if it will fit and the string
+	 * pointer is not a static pointer (part of an ACPI table)
 	 */
-	if (length < target_desc->string.length) {
-		/* Clear old string and copy in the new one */
-
-		MEMSET (target_desc->string.pointer, 0, target_desc->string.length);
-		MEMCPY (target_desc->string.pointer, buffer, length);
+	if ((length < target_desc->string.length) &&
+	   (!(target_desc->common.flags & AOPOBJ_STATIC_POINTER))) {
+		/*
+		 * String will fit in existing non-static buffer.
+		 * Clear old string and copy in the new one
+		 */
+		ACPI_MEMSET (target_desc->string.pointer, 0, (acpi_size) target_desc->string.length + 1);
+		ACPI_MEMCPY (target_desc->string.pointer, buffer, length);
 	}
-
 	else {
 		/*
-		 * Free the current buffer, then allocate a buffer
+		 * Free the current buffer, then allocate a new buffer
 		 * large enough to hold the value
 		 */
 		if (target_desc->string.pointer &&
@@ -162,16 +182,19 @@ acpi_ex_copy_string_to_string (
 			ACPI_MEM_FREE (target_desc->string.pointer);
 		}
 
-		target_desc->string.pointer = ACPI_MEM_ALLOCATE (length + 1);
+		target_desc->string.pointer = ACPI_MEM_CALLOCATE ((acpi_size) length + 1);
 		if (!target_desc->string.pointer) {
-			return (AE_NO_MEMORY);
+			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
 
-		target_desc->string.length = length;
-		MEMCPY (target_desc->string.pointer, buffer, length);
+		target_desc->common.flags &= ~AOPOBJ_STATIC_POINTER;
+		ACPI_MEMCPY (target_desc->string.pointer, buffer, length);
 	}
 
-	return (AE_OK);
+	/* Set the new target length */
+
+	target_desc->string.length = length;
+	return_ACPI_STATUS (AE_OK);
 }
 
 
diff -urNp linux-5400/drivers/acpi/executer/exsystem.c linux-5410/drivers/acpi/executer/exsystem.c
--- linux-5400/drivers/acpi/executer/exsystem.c
+++ linux-5410/drivers/acpi/executer/exsystem.c
@@ -2,42 +2,58 @@
 /******************************************************************************
  *
  * Module Name: exsystem - Interface to OS services
- *              $Revision: 67 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acinterp.h"
-#include "acnamesp.h"
-#include "achware.h"
-#include "acevents.h"
+#include <acpi/acpi.h>
+#include <acpi/acinterp.h>
+#include <acpi/acevents.h>
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("exsystem")
+	 ACPI_MODULE_NAME    ("exsystem")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_system_wait_semaphore
+ * FUNCTION:    acpi_ex_system_wait_semaphore
  *
  * PARAMETERS:  Semaphore           - OSD semaphore to wait on
  *              Timeout             - Max time to wait
@@ -52,13 +68,14 @@
 
 acpi_status
 acpi_ex_system_wait_semaphore (
-	acpi_handle             semaphore,
-	u32                     timeout)
+	acpi_handle                     semaphore,
+	u16                             timeout)
 {
-	acpi_status             status;
+	acpi_status                     status;
+	acpi_status                     status2;
 
 
-	FUNCTION_TRACE ("Ex_system_wait_semaphore");
+	ACPI_FUNCTION_TRACE ("ex_system_wait_semaphore");
 
 
 	status = acpi_os_wait_semaphore (semaphore, 1, 0);
@@ -78,11 +95,11 @@ acpi_ex_system_wait_semaphore (
 
 		/* Reacquire the interpreter */
 
-		status = acpi_ex_enter_interpreter ();
-		if (ACPI_SUCCESS (status)) {
-			/* Restore the timeout exception */
+		status2 = acpi_ex_enter_interpreter ();
+		if (ACPI_FAILURE (status2)) {
+			/* Report fatal error, could not acquire interpreter */
 
-			status = AE_TIME;
+			return_ACPI_STATUS (status2);
 		}
 	}
 
@@ -92,21 +109,24 @@ acpi_ex_system_wait_semaphore (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_system_do_stall
+ * FUNCTION:    acpi_ex_system_do_stall
  *
- * PARAMETERS:  How_long            - The amount of time to stall
+ * PARAMETERS:  how_long            - The amount of time to stall
  *
- * RETURN:      None
+ * RETURN:      Status
  *
  * DESCRIPTION: Suspend running thread for specified amount of time.
  *
  ******************************************************************************/
 
-void
+acpi_status
 acpi_ex_system_do_stall (
-	u32                     how_long)
+	u32                             how_long)
 {
-	FUNCTION_ENTRY ();
+	acpi_status                     status = AE_OK;
+
+
+	ACPI_FUNCTION_ENTRY ();
 
 
 	if (how_long > 1000) /* 1 millisecond */ {
@@ -114,24 +134,26 @@ acpi_ex_system_do_stall (
 
 		acpi_ex_exit_interpreter ();
 
-		acpi_os_stall (how_long);
+		acpi_os_sleep (0, (how_long / 1000) + 1);
 
 		/* And now we must get the interpreter again */
 
-		acpi_ex_enter_interpreter ();
+		status = acpi_ex_enter_interpreter ();
 	}
 
 	else {
-		acpi_os_sleep (0, (how_long / 1000) + 1);
+		acpi_os_stall (how_long);
 	}
+
+	return (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_system_do_suspend
+ * FUNCTION:    acpi_ex_system_do_suspend
  *
- * PARAMETERS:  How_long            - The amount of time to suspend
+ * PARAMETERS:  how_long            - The amount of time to suspend
  *
  * RETURN:      None
  *
@@ -139,12 +161,14 @@ acpi_ex_system_do_stall (
  *
  ******************************************************************************/
 
-void
+acpi_status
 acpi_ex_system_do_suspend (
-	u32                     how_long)
+	u32                             how_long)
 {
+	acpi_status                     status;
 
-	FUNCTION_ENTRY ();
+
+	ACPI_FUNCTION_ENTRY ();
 
 
 	/* Since this thread will sleep, we must release the interpreter */
@@ -156,34 +180,35 @@ acpi_ex_system_do_suspend (
 
 	/* And now we must get the interpreter again */
 
-	acpi_ex_enter_interpreter ();
+	status = acpi_ex_enter_interpreter ();
+	return (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_system_acquire_mutex
+ * FUNCTION:    acpi_ex_system_acquire_mutex
  *
- * PARAMETERS:  *Time_desc          - The 'time to delay' object descriptor
- *              *Obj_desc           - The object descriptor for this op
+ * PARAMETERS:  *time_desc          - The 'time to delay' object descriptor
+ *              *obj_desc           - The object descriptor for this op
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Provides an access point to perform synchronization operations
  *              within the AML.  This function will cause a lock to be generated
- *              for the Mutex pointed to by Obj_desc.
+ *              for the Mutex pointed to by obj_desc.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ex_system_acquire_mutex (
-	acpi_operand_object     *time_desc,
-	acpi_operand_object     *obj_desc)
+	union acpi_operand_object       *time_desc,
+	union acpi_operand_object       *obj_desc)
 {
-	acpi_status             status = AE_OK;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE_PTR ("Ex_system_acquire_mutex", obj_desc);
+	ACPI_FUNCTION_TRACE_PTR ("ex_system_acquire_mutex", obj_desc);
 
 
 	if (!obj_desc) {
@@ -194,21 +219,21 @@ acpi_ex_system_acquire_mutex (
 	 * Support for the _GL_ Mutex object -- go get the global lock
 	 */
 	if (obj_desc->mutex.semaphore == acpi_gbl_global_lock_semaphore) {
-		status = acpi_ev_acquire_global_lock ();
+		status = acpi_ev_acquire_global_lock ((u16) time_desc->integer.value);
 		return_ACPI_STATUS (status);
 	}
 
 	status = acpi_ex_system_wait_semaphore (obj_desc->mutex.semaphore,
-			  (u32) time_desc->integer.value);
+			  (u16) time_desc->integer.value);
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_system_release_mutex
+ * FUNCTION:    acpi_ex_system_release_mutex
  *
- * PARAMETERS:  *Obj_desc           - The object descriptor for this op
+ * PARAMETERS:  *obj_desc           - The object descriptor for this op
  *
  * RETURN:      Status
  *
@@ -221,12 +246,12 @@ acpi_ex_system_acquire_mutex (
 
 acpi_status
 acpi_ex_system_release_mutex (
-	acpi_operand_object     *obj_desc)
+	union acpi_operand_object       *obj_desc)
 {
-	acpi_status             status = AE_OK;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE ("Ex_system_release_mutex");
+	ACPI_FUNCTION_TRACE ("ex_system_release_mutex");
 
 
 	if (!obj_desc) {
@@ -237,8 +262,8 @@ acpi_ex_system_release_mutex (
 	 * Support for the _GL_ Mutex object -- release the global lock
 	 */
 	if (obj_desc->mutex.semaphore == acpi_gbl_global_lock_semaphore) {
-		acpi_ev_release_global_lock ();
-		return_ACPI_STATUS (AE_OK);
+		status = acpi_ev_release_global_lock ();
+		return_ACPI_STATUS (status);
 	}
 
 	status = acpi_os_signal_semaphore (obj_desc->mutex.semaphore, 1);
@@ -248,9 +273,9 @@ acpi_ex_system_release_mutex (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_system_signal_event
+ * FUNCTION:    acpi_ex_system_signal_event
  *
- * PARAMETERS:  *Obj_desc           - The object descriptor for this op
+ * PARAMETERS:  *obj_desc           - The object descriptor for this op
  *
  * RETURN:      AE_OK
  *
@@ -261,12 +286,12 @@ acpi_ex_system_release_mutex (
 
 acpi_status
 acpi_ex_system_signal_event (
-	acpi_operand_object     *obj_desc)
+	union acpi_operand_object       *obj_desc)
 {
-	acpi_status             status = AE_OK;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE ("Ex_system_signal_event");
+	ACPI_FUNCTION_TRACE ("ex_system_signal_event");
 
 
 	if (obj_desc) {
@@ -279,10 +304,10 @@ acpi_ex_system_signal_event (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_system_wait_event
+ * FUNCTION:    acpi_ex_system_wait_event
  *
- * PARAMETERS:  *Time_desc          - The 'time to delay' object descriptor
- *              *Obj_desc           - The object descriptor for this op
+ * PARAMETERS:  *time_desc          - The 'time to delay' object descriptor
+ *              *obj_desc           - The object descriptor for this op
  *
  * RETURN:      Status
  *
@@ -294,30 +319,29 @@ acpi_ex_system_signal_event (
 
 acpi_status
 acpi_ex_system_wait_event (
-	acpi_operand_object     *time_desc,
-	acpi_operand_object     *obj_desc)
+	union acpi_operand_object       *time_desc,
+	union acpi_operand_object       *obj_desc)
 {
-	acpi_status             status = AE_OK;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE ("Ex_system_wait_event");
+	ACPI_FUNCTION_TRACE ("ex_system_wait_event");
 
 
 	if (obj_desc) {
 		status = acpi_ex_system_wait_semaphore (obj_desc->event.semaphore,
-				  (u32) time_desc->integer.value);
+				  (u16) time_desc->integer.value);
 	}
 
-
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_system_reset_event
+ * FUNCTION:    acpi_ex_system_reset_event
  *
- * PARAMETERS:  *Obj_desc           - The object descriptor for this op
+ * PARAMETERS:  *obj_desc           - The object descriptor for this op
  *
  * RETURN:      Status
  *
@@ -327,13 +351,13 @@ acpi_ex_system_wait_event (
 
 acpi_status
 acpi_ex_system_reset_event (
-	acpi_operand_object     *obj_desc)
+	union acpi_operand_object       *obj_desc)
 {
-	acpi_status             status = AE_OK;
-	void                    *temp_semaphore;
+	acpi_status                     status = AE_OK;
+	void                            *temp_semaphore;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	/*
@@ -342,7 +366,7 @@ acpi_ex_system_reset_event (
 	 */
 	status = acpi_os_create_semaphore (ACPI_NO_UNIT_LIMIT, 0, &temp_semaphore);
 	if (ACPI_SUCCESS (status)) {
-		acpi_os_delete_semaphore (obj_desc->event.semaphore);
+		(void) acpi_os_delete_semaphore (obj_desc->event.semaphore);
 		obj_desc->event.semaphore = temp_semaphore;
 	}
 
diff -urNp linux-5400/drivers/acpi/executer/exutils.c linux-5410/drivers/acpi/executer/exutils.c
--- linux-5400/drivers/acpi/executer/exutils.c
+++ linux-5410/drivers/acpi/executer/exutils.c
@@ -2,26 +2,44 @@
 /******************************************************************************
  *
  * Module Name: exutils - interpreter/scanner utilities
- *              $Revision: 85 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
@@ -41,45 +59,48 @@
 
 #define DEFINE_AML_GLOBALS
 
-#include "acpi.h"
-#include "acparser.h"
-#include "acinterp.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "acevents.h"
-#include "acparser.h"
+#include <acpi/acpi.h>
+#include <acpi/acinterp.h>
+#include <acpi/amlcode.h>
+#include <acpi/acevents.h>
 
 #define _COMPONENT          ACPI_EXECUTER
-	 MODULE_NAME         ("exutils")
+	 ACPI_MODULE_NAME    ("exutils")
 
 
+#ifndef ACPI_NO_METHOD_EXECUTION
+
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_enter_interpreter
+ * FUNCTION:    acpi_ex_enter_interpreter
  *
  * PARAMETERS:  None
  *
- * DESCRIPTION: Enter the interpreter execution region
- *              TBD: should be a macro
+ * DESCRIPTION: Enter the interpreter execution region.  Failure to enter
+ *              the interpreter region is a fatal system error
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ex_enter_interpreter (void)
 {
-	acpi_status             status;
+	acpi_status                     status;
 
-	FUNCTION_TRACE ("Ex_enter_interpreter");
+	ACPI_FUNCTION_TRACE ("ex_enter_interpreter");
 
 
 	status = acpi_ut_acquire_mutex (ACPI_MTX_EXECUTE);
+	if (ACPI_FAILURE (status)) {
+		ACPI_REPORT_ERROR (("Could not acquire interpreter mutex\n"));
+	}
+
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_exit_interpreter
+ * FUNCTION:    acpi_ex_exit_interpreter
  *
  * PARAMETERS:  None
  *
@@ -95,56 +116,31 @@ acpi_ex_enter_interpreter (void)
  *          already executing
  *      7) About to invoke a user-installed opregion handler
  *
- *              TBD: should be a macro
- *
  ******************************************************************************/
 
 void
 acpi_ex_exit_interpreter (void)
 {
-	FUNCTION_TRACE ("Ex_exit_interpreter");
-
-
-	acpi_ut_release_mutex (ACPI_MTX_EXECUTE);
-
-	return_VOID;
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ex_validate_object_type
- *
- * PARAMETERS:  Type            Object type to validate
- *
- * DESCRIPTION: Determine if a type is a valid ACPI object type
- *
- ******************************************************************************/
+	acpi_status                     status;
 
-u8
-acpi_ex_validate_object_type (
-	acpi_object_type        type)
-{
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_TRACE ("ex_exit_interpreter");
 
 
-	if ((type > ACPI_TYPE_MAX && type < INTERNAL_TYPE_BEGIN) ||
-		(type > INTERNAL_TYPE_MAX)) {
-		return (FALSE);
+	status = acpi_ut_release_mutex (ACPI_MTX_EXECUTE);
+	if (ACPI_FAILURE (status)) {
+		ACPI_REPORT_ERROR (("Could not release interpreter mutex\n"));
 	}
 
-	return (TRUE);
+	return_VOID;
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_truncate_for32bit_table
+ * FUNCTION:    acpi_ex_truncate_for32bit_table
  *
- * PARAMETERS:  Obj_desc        - Object to be truncated
- *              Walk_state      - Current walk state
- *                                (A method must be executing)
+ * PARAMETERS:  obj_desc        - Object to be truncated
  *
  * RETURN:      none
  *
@@ -155,11 +151,10 @@ acpi_ex_validate_object_type (
 
 void
 acpi_ex_truncate_for32bit_table (
-	acpi_operand_object     *obj_desc,
-	acpi_walk_state         *walk_state)
+	union acpi_operand_object       *obj_desc)
 {
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	/*
@@ -167,12 +162,11 @@ acpi_ex_truncate_for32bit_table (
 	 * a control method
 	 */
 	if ((!obj_desc) ||
-		(obj_desc->common.type != ACPI_TYPE_INTEGER) ||
-		(!walk_state->method_node)) {
+		(ACPI_GET_OBJECT_TYPE (obj_desc) != ACPI_TYPE_INTEGER)) {
 		return;
 	}
 
-	if (walk_state->method_node->flags & ANOBJ_DATA_WIDTH_32) {
+	if (acpi_gbl_integer_byte_width == 4) {
 		/*
 		 * We are running a method that exists in a 32-bit ACPI table.
 		 * Truncate the value to 32 bits by zeroing out the upper 32-bit field
@@ -184,9 +178,10 @@ acpi_ex_truncate_for32bit_table (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_acquire_global_lock
+ * FUNCTION:    acpi_ex_acquire_global_lock
  *
- * PARAMETERS:  Rule            - Lock rule: Always_lock, Never_lock
+ * PARAMETERS:  field_flags           - Flags with Lock rule:
+ *                                      always_lock or never_lock
  *
  * RETURN:      TRUE/FALSE indicating whether the lock was actually acquired
  *
@@ -198,25 +193,24 @@ acpi_ex_truncate_for32bit_table (
 
 u8
 acpi_ex_acquire_global_lock (
-	u32                     rule)
+	u32                             field_flags)
 {
-	u8                      locked = FALSE;
-	acpi_status             status;
+	u8                              locked = FALSE;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Ex_acquire_global_lock");
+	ACPI_FUNCTION_TRACE ("ex_acquire_global_lock");
 
 
-	/* Only attempt lock if the Rule says so */
+	/* Only attempt lock if the always_lock bit is set */
 
-	if (rule == (u32) GLOCK_ALWAYS_LOCK) {
-		/* We should attempt to get the lock */
+	if (field_flags & AML_FIELD_LOCK_RULE_MASK) {
+		/* We should attempt to get the lock, wait forever */
 
-		status = acpi_ev_acquire_global_lock ();
+		status = acpi_ev_acquire_global_lock (ACPI_WAIT_FOREVER);
 		if (ACPI_SUCCESS (status)) {
 			locked = TRUE;
 		}
-
 		else {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not acquire Global Lock, %s\n",
 				acpi_format_exception (status)));
@@ -229,10 +223,10 @@ acpi_ex_acquire_global_lock (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_release_global_lock
+ * FUNCTION:    acpi_ex_release_global_lock
  *
- * PARAMETERS:  Locked_by_me    - Return value from corresponding call to
- *                                Acquire_global_lock.
+ * PARAMETERS:  locked_by_me    - Return value from corresponding call to
+ *                                acquire_global_lock.
  *
  * RETURN:      Status
  *
@@ -240,12 +234,14 @@ acpi_ex_acquire_global_lock (
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ex_release_global_lock (
-	u8                      locked_by_me)
+	u8                              locked_by_me)
 {
+	acpi_status                     status;
 
-	FUNCTION_TRACE ("Ex_release_global_lock");
+
+	ACPI_FUNCTION_TRACE ("ex_release_global_lock");
 
 
 	/* Only attempt unlock if the caller locked it */
@@ -253,17 +249,22 @@ acpi_ex_release_global_lock (
 	if (locked_by_me) {
 		/* OK, now release the lock */
 
-		acpi_ev_release_global_lock ();
-	}
+		status = acpi_ev_release_global_lock ();
+		if (ACPI_FAILURE (status)) {
+			/* Report the error, but there isn't much else we can do */
 
+			ACPI_REPORT_ERROR (("Could not release ACPI Global Lock, %s\n",
+				acpi_format_exception (status)));
+		}
+	}
 
-	return_ACPI_STATUS (AE_OK);
+	return_VOID;
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_digits_needed
+ * FUNCTION:    acpi_ex_digits_needed
  *
  * PARAMETERS:  Value           - Value to be represented
  *              Base            - Base of representation
@@ -274,26 +275,30 @@ acpi_ex_release_global_lock (
 
 u32
 acpi_ex_digits_needed (
-	acpi_integer            value,
-	u32                     base)
+	acpi_integer                    value,
+	u32                             base)
 {
-	u32                     num_digits = 0;
+	u32                             num_digits;
+	acpi_integer                    current_value;
+	acpi_integer                    quotient;
 
 
-	FUNCTION_TRACE ("Ex_digits_needed");
+	ACPI_FUNCTION_TRACE ("ex_digits_needed");
 
 
-	if (base < 1) {
-		REPORT_ERROR (("Ex_digits_needed: Internal error - Invalid base\n"));
+	/*
+	 * acpi_integer is unsigned, so we don't worry about a '-'
+	 */
+	if ((current_value = value) == 0) {
+	    return_VALUE (1);
 	}
 
-	else {
-		/*
-		 * acpi_integer is unsigned, which is why we don't worry about a '-'
-		 */
-		for (num_digits = 1;
-			(acpi_ut_short_divide (&value, base, &value, NULL));
-			++num_digits) { ; }
+	num_digits = 0;
+
+	while (current_value) {
+		(void) acpi_ut_short_divide (&current_value, base, &quotient, NULL);
+		num_digits++;
+		current_value = quotient;
 	}
 
 	return_VALUE (num_digits);
@@ -302,115 +307,74 @@ acpi_ex_digits_needed (
 
 /*******************************************************************************
  *
- * FUNCTION:    ntohl
- *
- * PARAMETERS:  Value           - Value to be converted
- *
- * DESCRIPTION: Convert a 32-bit value to big-endian (swap the bytes)
- *
- ******************************************************************************/
-
-static u32
-_ntohl (
-	u32                     value)
-{
-	union {
-		u32                 value;
-		u8                  bytes[4];
-	} out;
-
-	union {
-		u32                 value;
-		u8                  bytes[4];
-	} in;
-
-
-	FUNCTION_ENTRY ();
-
-
-	in.value = value;
-
-	out.bytes[0] = in.bytes[3];
-	out.bytes[1] = in.bytes[2];
-	out.bytes[2] = in.bytes[1];
-	out.bytes[3] = in.bytes[0];
-
-	return (out.value);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ex_eisa_id_to_string
+ * FUNCTION:    acpi_ex_eisa_id_to_string
  *
- * PARAMETERS:  Numeric_id      - EISA ID to be converted
- *              Out_string      - Where to put the converted string (8 bytes)
+ * PARAMETERS:  numeric_id      - EISA ID to be converted
+ *              out_string      - Where to put the converted string (8 bytes)
  *
  * DESCRIPTION: Convert a numeric EISA ID to string representation
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ex_eisa_id_to_string (
-	u32                     numeric_id,
-	NATIVE_CHAR             *out_string)
+	u32                             numeric_id,
+	char                            *out_string)
 {
-	u32                     id;
+	u32                             eisa_id;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
-	/* swap to big-endian to get contiguous bits */
+	/* Swap ID to big-endian to get contiguous bits */
 
-	id = _ntohl (numeric_id);
+	eisa_id = acpi_ut_dword_byte_swap (numeric_id);
 
-	out_string[0] = (char) ('@' + ((id >> 26) & 0x1f));
-	out_string[1] = (char) ('@' + ((id >> 21) & 0x1f));
-	out_string[2] = (char) ('@' + ((id >> 16) & 0x1f));
-	out_string[3] = acpi_ut_hex_to_ascii_char (id, 12);
-	out_string[4] = acpi_ut_hex_to_ascii_char (id, 8);
-	out_string[5] = acpi_ut_hex_to_ascii_char (id, 4);
-	out_string[6] = acpi_ut_hex_to_ascii_char (id, 0);
+	out_string[0] = (char) ('@' + (((unsigned long) eisa_id >> 26) & 0x1f));
+	out_string[1] = (char) ('@' + ((eisa_id >> 21) & 0x1f));
+	out_string[2] = (char) ('@' + ((eisa_id >> 16) & 0x1f));
+	out_string[3] = acpi_ut_hex_to_ascii_char ((acpi_integer) eisa_id, 12);
+	out_string[4] = acpi_ut_hex_to_ascii_char ((acpi_integer) eisa_id, 8);
+	out_string[5] = acpi_ut_hex_to_ascii_char ((acpi_integer) eisa_id, 4);
+	out_string[6] = acpi_ut_hex_to_ascii_char ((acpi_integer) eisa_id, 0);
 	out_string[7] = 0;
-
-	return (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ex_unsigned_integer_to_string
+ * FUNCTION:    acpi_ex_unsigned_integer_to_string
  *
  * PARAMETERS:  Value           - Value to be converted
- *              Out_string      - Where to put the converted string (8 bytes)
+ *              out_string      - Where to put the converted string (8 bytes)
  *
  * RETURN:      Convert a number to string representation
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ex_unsigned_integer_to_string (
-	acpi_integer            value,
-	NATIVE_CHAR             *out_string)
+	acpi_integer                    value,
+	char                            *out_string)
 {
-	u32                     count;
-	u32                     digits_needed;
-	u32                     remainder;
+	u32                             count;
+	u32                             digits_needed;
+	u32                             remainder;
+	acpi_integer                    quotient;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	digits_needed = acpi_ex_digits_needed (value, 10);
 	out_string[digits_needed] = 0;
 
 	for (count = digits_needed; count > 0; count--) {
-		acpi_ut_short_divide (&value, 10, &value, &remainder);
-		out_string[count-1] = (NATIVE_CHAR) ('0' + remainder);
+		(void) acpi_ut_short_divide (&value, 10, &quotient, &remainder);
+		out_string[count-1] = (char) ('0' + remainder);\
+		value = quotient;
 	}
-
-	return (AE_OK);
 }
 
-
+#endif
diff -urNp linux-5400/drivers/acpi/fan.c linux-5410/drivers/acpi/fan.c
--- linux-5400/drivers/acpi/fan.c
+++ linux-5410/drivers/acpi/fan.c
@@ -0,0 +1,296 @@
+/*
+ *  acpi_fan.c - ACPI Fan Driver ($Revision: 28 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/compatmac.h>
+#include <linux/proc_fs.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+
+#define _COMPONENT		ACPI_FAN_COMPONENT
+ACPI_MODULE_NAME		("acpi_fan")
+
+MODULE_AUTHOR("Paul Diefenbaugh");
+MODULE_DESCRIPTION(ACPI_FAN_DRIVER_NAME);
+MODULE_LICENSE("GPL");
+
+#define PREFIX			"ACPI: "
+
+
+int acpi_fan_add (struct acpi_device *device);
+int acpi_fan_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_fan_driver = {
+	.name =		ACPI_FAN_DRIVER_NAME,
+	.class =	ACPI_FAN_CLASS,
+	.ids =		ACPI_FAN_HID,
+	.ops =		{
+				.add =		acpi_fan_add,
+				.remove =	acpi_fan_remove,
+			},
+};
+
+struct acpi_fan {
+	acpi_handle		handle;
+};
+
+
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+struct proc_dir_entry		*acpi_fan_dir = NULL;
+
+
+static int
+acpi_fan_read_state (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_fan		*fan = (struct acpi_fan *) data;
+	char			*p = page;
+	int			len = 0;
+	int			state = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_fan_read_state");
+
+	if (!fan || (off != 0))
+		goto end;
+
+	if (acpi_bus_get_power(fan->handle, &state))
+		goto end;
+
+	p += sprintf(p, "status:                  %s\n",
+		!state?"on":"off");
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_fan_write_state (
+	struct file		*file,
+	const char		*buffer,
+	unsigned long		count,
+	void			*data)
+{
+	int			result = 0;
+	struct acpi_fan		*fan = (struct acpi_fan *) data;
+	char			state_string[12] = {'\0'};
+
+	ACPI_FUNCTION_TRACE("acpi_fan_write_state");
+
+	if (!fan || (count > sizeof(state_string) - 1))
+		return_VALUE(-EINVAL);
+	
+	if (copy_from_user(state_string, buffer, count))
+		return_VALUE(-EFAULT);
+	
+	state_string[count] = '\0';
+	
+	result = acpi_bus_set_power(fan->handle, 
+		simple_strtoul(state_string, NULL, 0));
+	if (result)
+		return_VALUE(result);
+
+	return_VALUE(count);
+}
+
+
+static int
+acpi_fan_add_fs (
+	struct acpi_device	*device)
+{
+	struct proc_dir_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_fan_add_fs");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	if (!acpi_device_dir(device)) {
+		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
+			acpi_fan_dir);
+		if (!acpi_device_dir(device))
+			return_VALUE(-ENODEV);
+	}
+
+	/* 'status' [R/W] */
+	entry = create_proc_entry(ACPI_FAN_FILE_STATE,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_FAN_FILE_STATE));
+	else {
+		entry->read_proc = acpi_fan_read_state;
+		entry->write_proc = acpi_fan_write_state;
+		entry->data = acpi_driver_data(device);
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_fan_remove_fs (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_fan_remove_fs");
+
+	if (acpi_device_dir(device)) {
+		remove_proc_entry(acpi_device_bid(device), acpi_fan_dir);
+		acpi_device_dir(device) = NULL;
+	}
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                 Driver Interface
+   -------------------------------------------------------------------------- */
+
+int
+acpi_fan_add (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	struct acpi_fan		*fan = NULL;
+	int			state = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_fan_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	fan = kmalloc(sizeof(struct acpi_fan), GFP_KERNEL);
+	if (!fan)
+		return_VALUE(-ENOMEM);
+	memset(fan, 0, sizeof(struct acpi_fan));
+
+	fan->handle = device->handle;
+	sprintf(acpi_device_name(device), "%s", ACPI_FAN_DEVICE_NAME);
+	sprintf(acpi_device_class(device), "%s", ACPI_FAN_CLASS);
+	acpi_driver_data(device) = fan;
+
+	result = acpi_bus_get_power(fan->handle, &state);
+	if (result) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error reading power state\n"));
+		goto end;
+	}
+
+	result = acpi_fan_add_fs(device);
+	if (result)
+		goto end;
+
+	printk(KERN_INFO PREFIX "%s [%s] (%s)\n",
+		acpi_device_name(device), acpi_device_bid(device),
+		!device->power.state?"on":"off");
+
+end:
+	if (result)
+		kfree(fan);
+
+	return_VALUE(result);
+}
+
+
+int
+acpi_fan_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	struct acpi_fan		*fan = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_fan_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	fan = (struct acpi_fan *) acpi_driver_data(device);
+
+	acpi_fan_remove_fs(device);
+
+	kfree(fan);
+
+	return_VALUE(0);
+}
+
+
+int __init
+acpi_fan_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_fan_init");
+
+	acpi_fan_dir = proc_mkdir(ACPI_FAN_CLASS, acpi_root_dir);
+	if (!acpi_fan_dir)
+		return_VALUE(-ENODEV);
+
+	result = acpi_bus_register_driver(&acpi_fan_driver);
+	if (result < 0) {
+		remove_proc_entry(ACPI_FAN_CLASS, acpi_root_dir);
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+
+
+void __exit
+acpi_fan_exit (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_fan_exit");
+
+	acpi_bus_unregister_driver(&acpi_fan_driver);
+
+	remove_proc_entry(ACPI_FAN_CLASS, acpi_root_dir);
+
+	return_VOID;
+}
+
+
+module_init(acpi_fan_init);
+module_exit(acpi_fan_exit);
+
diff -urNp linux-5400/drivers/acpi/hardware/Makefile linux-5410/drivers/acpi/hardware/Makefile
--- linux-5400/drivers/acpi/hardware/Makefile
+++ linux-5410/drivers/acpi/hardware/Makefile
@@ -1,11 +1,10 @@
 #
 # Makefile for all Linux ACPI interpreter subdirectories
-# EXCEPT for the ospm directory
 #
 
 O_TARGET := $(notdir $(CURDIR)).o
 
-obj-$(CONFIG_ACPI) := $(patsubst %.c,%.o,$(wildcard *.c))
+obj-$(CONFIG_ACPI_INTERPRETER) := $(patsubst %.c,%.o,$(wildcard *.c))
 
 EXTRA_CFLAGS += $(ACPI_CFLAGS)
 
diff -urNp linux-5400/drivers/acpi/hardware/hwacpi.c linux-5410/drivers/acpi/hardware/hwacpi.c
--- linux-5400/drivers/acpi/hardware/hwacpi.c
+++ linux-5410/drivers/acpi/hardware/hwacpi.c
@@ -2,40 +2,57 @@
 /******************************************************************************
  *
  * Module Name: hwacpi - ACPI Hardware Initialization/Mode Interface
- *              $Revision: 46 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "achware.h"
+#include <acpi/acpi.h>
 
 
 #define _COMPONENT          ACPI_HARDWARE
-	 MODULE_NAME         ("hwacpi")
+	 ACPI_MODULE_NAME    ("hwacpi")
 
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_hw_initialize
+ * FUNCTION:    acpi_hw_initialize
  *
  * PARAMETERS:  None
  *
@@ -49,182 +66,120 @@ acpi_status
 acpi_hw_initialize (
 	void)
 {
-	acpi_status             status = AE_OK;
-	u32                     index;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Hw_initialize");
+	ACPI_FUNCTION_TRACE ("hw_initialize");
 
 
 	/* We must have the ACPI tables by the time we get here */
 
 	if (!acpi_gbl_FADT) {
-		acpi_gbl_restore_acpi_chipset = FALSE;
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No FADT!\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "A FADT is not loaded\n"));
 
 		return_ACPI_STATUS (AE_NO_ACPI_TABLES);
 	}
 
-	/* Identify current ACPI/legacy mode   */
-
-	switch (acpi_gbl_system_flags & SYS_MODES_MASK) {
-	case (SYS_MODE_ACPI):
-
-		acpi_gbl_original_mode = SYS_MODE_ACPI;
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "System supports ACPI mode only.\n"));
-		break;
-
-
-	case (SYS_MODE_LEGACY):
-
-		acpi_gbl_original_mode = SYS_MODE_LEGACY;
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-			"Tables loaded from buffer, hardware assumed to support LEGACY mode only.\n"));
-		break;
-
+	/* Sanity check the FADT for valid values */
 
-	case (SYS_MODE_ACPI | SYS_MODE_LEGACY):
-
-		if (acpi_hw_get_mode () == SYS_MODE_ACPI) {
-			acpi_gbl_original_mode = SYS_MODE_ACPI;
-		}
-		else {
-			acpi_gbl_original_mode = SYS_MODE_LEGACY;
-		}
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-			"System supports both ACPI and LEGACY modes.\n"));
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-			"System is currently in %s mode.\n",
-			(acpi_gbl_original_mode == SYS_MODE_ACPI) ? "ACPI" : "LEGACY"));
-		break;
+	status = acpi_ut_validate_fadt ();
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
 	}
 
-
-	if (acpi_gbl_system_flags & SYS_MODE_ACPI) {
-		/* Target system supports ACPI mode */
-
-		/*
-		 * The purpose of this code is to save the initial state
-		 * of the ACPI event enable registers. An exit function will be
-		 * registered which will restore this state when the application
-		 * exits. The exit function will also clear all of the ACPI event
-		 * status bits prior to restoring the original mode.
-		 *
-		 * The location of the PM1a_evt_blk enable registers is defined as the
-		 * base of PM1a_evt_blk + DIV_2(PM1a_evt_blk_length). Since the spec further
-		 * fully defines the PM1a_evt_blk to be a total of 4 bytes, the offset
-		 * for the enable registers is always 2 from the base. It is hard
-		 * coded here. If this changes in the spec, this code will need to
-		 * be modified. The PM1b_evt_blk behaves as expected.
-		 */
-		acpi_gbl_pm1_enable_register_save = (u16) acpi_hw_register_read (
-				   ACPI_MTX_LOCK, PM1_EN);
-
-
-		/*
-		 * The GPEs behave similarly, except that the length of the register
-		 * block is not fixed, so the buffer must be allocated with malloc
-		 */
-		if (ACPI_VALID_ADDRESS (acpi_gbl_FADT->Xgpe0blk.address) &&
-			acpi_gbl_FADT->gpe0blk_len) {
-			/* GPE0 specified in FADT  */
-
-			acpi_gbl_gpe0enable_register_save = ACPI_MEM_ALLOCATE (
-					   DIV_2 (acpi_gbl_FADT->gpe0blk_len));
-			if (!acpi_gbl_gpe0enable_register_save) {
-				return_ACPI_STATUS (AE_NO_MEMORY);
-			}
-
-			/* Save state of GPE0 enable bits */
-
-			for (index = 0; index < DIV_2 (acpi_gbl_FADT->gpe0blk_len); index++) {
-				acpi_gbl_gpe0enable_register_save[index] =
-					(u8) acpi_hw_register_read (ACPI_MTX_LOCK, GPE0_EN_BLOCK | index);
-			}
-		}
-
-		else {
-			acpi_gbl_gpe0enable_register_save = NULL;
-		}
-
-		if (ACPI_VALID_ADDRESS (acpi_gbl_FADT->Xgpe1_blk.address) &&
-			acpi_gbl_FADT->gpe1_blk_len) {
-			/* GPE1 defined */
-
-			acpi_gbl_gpe1_enable_register_save = ACPI_MEM_ALLOCATE (
-					   DIV_2 (acpi_gbl_FADT->gpe1_blk_len));
-			if (!acpi_gbl_gpe1_enable_register_save) {
-				return_ACPI_STATUS (AE_NO_MEMORY);
-			}
-
-			/* save state of GPE1 enable bits */
-
-			for (index = 0; index < DIV_2 (acpi_gbl_FADT->gpe1_blk_len); index++) {
-				acpi_gbl_gpe1_enable_register_save[index] =
-					(u8) acpi_hw_register_read (ACPI_MTX_LOCK, GPE1_EN_BLOCK | index);
-			}
-		}
-
-		else {
-			acpi_gbl_gpe1_enable_register_save = NULL;
-		}
-	}
-
-	return_ACPI_STATUS (status);
+	return_ACPI_STATUS (AE_OK);
 }
 
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_hw_set_mode
+ * FUNCTION:    acpi_hw_set_mode
  *
  * PARAMETERS:  Mode            - SYS_MODE_ACPI or SYS_MODE_LEGACY
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Transitions the system into the requested mode or does nothing
- *              if the system is already in that mode.
+ * DESCRIPTION: Transitions the system into the requested mode.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_hw_set_mode (
-	u32                     mode)
+	u32                             mode)
 {
 
-	acpi_status             status = AE_NO_HARDWARE_RESPONSE;
+	acpi_status                     status;
+	u32                             retry;
 
 
-	FUNCTION_TRACE ("Hw_set_mode");
+	ACPI_FUNCTION_TRACE ("hw_set_mode");
 
+	/*
+	 * ACPI 2.0 clarified that if SMI_CMD in FADT is zero,
+	 * system does not support mode transition.
+	 */
+	if (!acpi_gbl_FADT->smi_cmd) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No SMI_CMD in FADT, mode transition failed.\n"));
+		return_ACPI_STATUS (AE_NO_HARDWARE_RESPONSE);
+	}
+
+	/*
+	 * ACPI 2.0 clarified the meaning of ACPI_ENABLE and ACPI_DISABLE
+	 * in FADT: If it is zero, enabling or disabling is not supported.
+	 * As old systems may have used zero for mode transition,
+	 * we make sure both the numbers are zero to determine these
+	 * transitions are not supported.
+	 */
+	if (!acpi_gbl_FADT->acpi_enable && !acpi_gbl_FADT->acpi_disable) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "No mode transition supported in this system.\n"));
+		return_ACPI_STATUS (AE_OK);
+	}
+
+	switch (mode) {
+	case ACPI_SYS_MODE_ACPI:
 
-	if (mode == SYS_MODE_ACPI) {
 		/* BIOS should have disabled ALL fixed and GP events */
 
-		acpi_os_write_port (acpi_gbl_FADT->smi_cmd, acpi_gbl_FADT->acpi_enable, 8);
+		status = acpi_os_write_port (acpi_gbl_FADT->smi_cmd,
+				  (u32) acpi_gbl_FADT->acpi_enable, 8);
 		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Attempting to enable ACPI mode\n"));
-	}
+		break;
+
+	case ACPI_SYS_MODE_LEGACY:
 
-	else if (mode == SYS_MODE_LEGACY) {
 		/*
 		 * BIOS should clear all fixed status bits and restore fixed event
 		 * enable bits to default
 		 */
-		acpi_os_write_port (acpi_gbl_FADT->smi_cmd, acpi_gbl_FADT->acpi_disable, 8);
+		status = acpi_os_write_port (acpi_gbl_FADT->smi_cmd,
+				 (u32) acpi_gbl_FADT->acpi_disable, 8);
 		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
 				 "Attempting to enable Legacy (non-ACPI) mode\n"));
+		break;
+
+	default:
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	/* Give the platform some time to react */
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
-	acpi_os_stall (20000);
+	/*
+	 * Some hardware takes a LONG time to switch modes. Give them 3 sec to
+	 * do so, but allow faster systems to proceed more quickly.
+	 */
+	retry = 3000;
+	while (retry) {
+		status = AE_NO_HARDWARE_RESPONSE;
 
-	if (acpi_hw_get_mode () == mode) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Mode %X successfully enabled\n", mode));
-		status = AE_OK;
+		if (acpi_hw_get_mode() == mode) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Mode %X successfully enabled\n", mode));
+			status = AE_OK;
+			break;
+		}
+		acpi_os_stall(1000);
+		retry--;
 	}
 
 	return_ACPI_STATUS (status);
@@ -233,7 +188,7 @@ acpi_hw_set_mode (
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_hw_get_mode
+ * FUNCTION:    acpi_hw_get_mode
  *
  * PARAMETERS:  none
  *
@@ -247,74 +202,21 @@ acpi_hw_set_mode (
 u32
 acpi_hw_get_mode (void)
 {
+	acpi_status                     status;
+	u32                             value;
 
-	FUNCTION_TRACE ("Hw_get_mode");
 
+	ACPI_FUNCTION_TRACE ("hw_get_mode");
 
-	if (acpi_hw_register_bit_access (ACPI_READ, ACPI_MTX_LOCK, SCI_EN)) {
-		return_VALUE (SYS_MODE_ACPI);
-	}
-	else {
-		return_VALUE (SYS_MODE_LEGACY);
+	status = acpi_get_register (ACPI_BITREG_SCI_ENABLE, &value, ACPI_MTX_LOCK);
+	if (ACPI_FAILURE (status)) {
+		return_VALUE (ACPI_SYS_MODE_LEGACY);
 	}
-}
-
-
-/******************************************************************************
- *
- * FUNCTION:    Acpi_hw_get_mode_capabilities
- *
- * PARAMETERS:  none
- *
- * RETURN:      logical OR of SYS_MODE_ACPI and SYS_MODE_LEGACY determined at initial
- *              system state.
- *
- * DESCRIPTION: Returns capablities of system
- *
- ******************************************************************************/
-
-u32
-acpi_hw_get_mode_capabilities (void)
-{
-
-	FUNCTION_TRACE ("Hw_get_mode_capabilities");
-
-
-	if (!(acpi_gbl_system_flags & SYS_MODES_MASK)) {
-		if (acpi_hw_get_mode () == SYS_MODE_LEGACY) {
-			/*
-			 * Assume that if this call is being made, Acpi_init has been called
-			 * and ACPI support has been established by the presence of the
-			 * tables.  Therefore since we're in SYS_MODE_LEGACY, the system
-			 * must support both modes
-			 */
-			acpi_gbl_system_flags |= (SYS_MODE_ACPI | SYS_MODE_LEGACY);
-		}
-
-		else {
-			/* TBD: [Investigate] !!! this may be unsafe... */
-			/*
-			 * system is is ACPI mode, so try to switch back to LEGACY to see if
-			 * it is supported
-			 */
-			acpi_hw_set_mode (SYS_MODE_LEGACY);
-
-			if (acpi_hw_get_mode () == SYS_MODE_LEGACY) {
-				/* Now in SYS_MODE_LEGACY, so both are supported */
-
-				acpi_gbl_system_flags |= (SYS_MODE_ACPI | SYS_MODE_LEGACY);
-				acpi_hw_set_mode (SYS_MODE_ACPI);
-			}
-
-			else {
-				/* Still in SYS_MODE_ACPI so this must be an ACPI only system */
 
-				acpi_gbl_system_flags |= SYS_MODE_ACPI;
-			}
-		}
+	if (value) {
+		return_VALUE (ACPI_SYS_MODE_ACPI);
+	}
+	else {
+		return_VALUE (ACPI_SYS_MODE_LEGACY);
 	}
-
-	return_VALUE (acpi_gbl_system_flags & SYS_MODES_MASK);
 }
-
-
diff -urNp linux-5400/drivers/acpi/hardware/hwgpe.c linux-5410/drivers/acpi/hardware/hwgpe.c
--- linux-5400/drivers/acpi/hardware/hwgpe.c
+++ linux-5410/drivers/acpi/hardware/hwgpe.c
@@ -2,42 +2,58 @@
 /******************************************************************************
  *
  * Module Name: hwgpe - Low level GPE enable/disable/clear functions
- *              $Revision: 35 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#include "acpi.h"
-#include "achware.h"
-#include "acnamesp.h"
-#include "acevents.h"
+#include <acpi/acpi.h>
+#include <acpi/acevents.h>
 
 #define _COMPONENT          ACPI_HARDWARE
-	 MODULE_NAME         ("hwgpe")
+	 ACPI_MODULE_NAME    ("hwgpe")
 
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_hw_enable_gpe
+ * FUNCTION:    acpi_hw_enable_gpe
  *
- * PARAMETERS:  Gpe_number      - The GPE
+ * PARAMETERS:  gpe_number      - The GPE
  *
  * RETURN:      None
  *
@@ -45,43 +61,41 @@
  *
  ******************************************************************************/
 
-void
+acpi_status
 acpi_hw_enable_gpe (
-	u32                     gpe_number)
+	struct acpi_gpe_event_info      *gpe_event_info)
 {
-	u32                     in_byte;
-	u32                     register_index;
-	u32                     bit_mask;
-
-
-	FUNCTION_ENTRY ();
+	u32                             in_byte;
+	acpi_status                     status;
 
 
-	/*
-	 * Translate GPE number to index into global registers array.
-	 */
-	register_index = acpi_gbl_gpe_valid[gpe_number];
+	ACPI_FUNCTION_ENTRY ();
 
-	/*
-	 * Figure out the bit offset for this GPE within the target register.
-	 */
-	bit_mask = acpi_gbl_decode_to8bit [MOD_8 (gpe_number)];
 
 	/*
 	 * Read the current value of the register, set the appropriate bit
 	 * to enable the GPE, and write out the new register.
 	 */
-	in_byte = 0;
-	acpi_os_read_port (acpi_gbl_gpe_registers[register_index].enable_addr, &in_byte, 8);
-	acpi_os_write_port (acpi_gbl_gpe_registers[register_index].enable_addr,
-			   (in_byte | bit_mask), 8);
+	status = acpi_hw_low_level_read (8, &in_byte,
+			  &gpe_event_info->register_info->enable_address);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
+
+	/* Write with the new GPE bit enabled */
+
+	status = acpi_hw_low_level_write (8, (in_byte | gpe_event_info->bit_mask),
+			  &gpe_event_info->register_info->enable_address);
+
+	return (status);
 }
 
+
 /******************************************************************************
  *
- * FUNCTION:    Acpi_hw_enable_gpe_for_wakeup
+ * FUNCTION:    acpi_hw_enable_gpe_for_wakeup
  *
- * PARAMETERS:  Gpe_number      - The GPE
+ * PARAMETERS:  gpe_number      - The GPE
  *
  * RETURN:      None
  *
@@ -92,36 +106,33 @@ acpi_hw_enable_gpe (
 
 void
 acpi_hw_enable_gpe_for_wakeup (
-	u32                     gpe_number)
+	struct acpi_gpe_event_info      *gpe_event_info)
 {
-	u32                     register_index;
-	u32                     bit_mask;
+	struct acpi_gpe_register_info   *gpe_register_info;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
-	/*
-	 * Translate GPE number to index into global registers array.
-	 */
-	register_index = acpi_gbl_gpe_valid[gpe_number];
+	/* Get the info block for the entire GPE register */
 
-	/*
-	 * Figure out the bit offset for this GPE within the target register.
-	 */
-	bit_mask = acpi_gbl_decode_to8bit [MOD_8 (gpe_number)];
+	gpe_register_info = gpe_event_info->register_info;
+	if (!gpe_register_info) {
+		return;
+	}
 
 	/*
 	 * Set the bit so we will not disable this when sleeping
 	 */
-	acpi_gbl_gpe_registers[register_index].wake_enable |= bit_mask;
+	gpe_register_info->wake_enable |= gpe_event_info->bit_mask;
 }
 
+
 /******************************************************************************
  *
- * FUNCTION:    Acpi_hw_disable_gpe
+ * FUNCTION:    acpi_hw_disable_gpe
  *
- * PARAMETERS:  Gpe_number      - The GPE
+ * PARAMETERS:  gpe_number      - The GPE
  *
  * RETURN:      None
  *
@@ -129,45 +140,53 @@ acpi_hw_enable_gpe_for_wakeup (
  *
  ******************************************************************************/
 
-void
+acpi_status
 acpi_hw_disable_gpe (
-	u32                     gpe_number)
+	struct acpi_gpe_event_info      *gpe_event_info)
 {
-	u32                     in_byte;
-	u32                     register_index;
-	u32                     bit_mask;
+	u32                             in_byte;
+	acpi_status                     status;
+	struct acpi_gpe_register_info   *gpe_register_info;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
-	/*
-	 * Translate GPE number to index into global registers array.
-	 */
-	register_index = acpi_gbl_gpe_valid[gpe_number];
+	/* Get the info block for the entire GPE register */
 
-	/*
-	 * Figure out the bit offset for this GPE within the target register.
-	 */
-	bit_mask = acpi_gbl_decode_to8bit [MOD_8 (gpe_number)];
+	gpe_register_info = gpe_event_info->register_info;
+	if (!gpe_register_info) {
+		return (AE_BAD_PARAMETER);
+	}
 
 	/*
 	 * Read the current value of the register, clear the appropriate bit,
 	 * and write out the new register value to disable the GPE.
 	 */
-	in_byte = 0;
-	acpi_os_read_port (acpi_gbl_gpe_registers[register_index].enable_addr, &in_byte, 8);
-	acpi_os_write_port (acpi_gbl_gpe_registers[register_index].enable_addr,
-			 (in_byte & ~bit_mask), 8);
+	status = acpi_hw_low_level_read (8, &in_byte,
+			  &gpe_register_info->enable_address);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
+
+	/* Write the byte with this GPE bit cleared */
+
+	status = acpi_hw_low_level_write (8, (in_byte & ~(gpe_event_info->bit_mask)),
+			  &gpe_register_info->enable_address);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
 
-	acpi_hw_disable_gpe_for_wakeup(gpe_number);
+	acpi_hw_disable_gpe_for_wakeup (gpe_event_info);
+	return (AE_OK);
 }
 
+
 /******************************************************************************
  *
- * FUNCTION:    Acpi_hw_disable_gpe_for_wakeup
+ * FUNCTION:    acpi_hw_disable_gpe_for_wakeup
  *
- * PARAMETERS:  Gpe_number      - The GPE
+ * PARAMETERS:  gpe_number      - The GPE
  *
  * RETURN:      None
  *
@@ -178,36 +197,33 @@ acpi_hw_disable_gpe (
 
 void
 acpi_hw_disable_gpe_for_wakeup (
-	u32                     gpe_number)
+	struct acpi_gpe_event_info      *gpe_event_info)
 {
-	u32                     register_index;
-	u32                     bit_mask;
+	struct acpi_gpe_register_info   *gpe_register_info;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
-	/*
-	 * Translate GPE number to index into global registers array.
-	 */
-	register_index = acpi_gbl_gpe_valid[gpe_number];
+	/* Get the info block for the entire GPE register */
 
-	/*
-	 * Figure out the bit offset for this GPE within the target register.
-	 */
-	bit_mask = acpi_gbl_decode_to8bit [MOD_8 (gpe_number)];
+	gpe_register_info = gpe_event_info->register_info;
+	if (!gpe_register_info) {
+		return;
+	}
 
 	/*
 	 * Clear the bit so we will disable this when sleeping
 	 */
-	acpi_gbl_gpe_registers[register_index].wake_enable &= ~bit_mask;
+	gpe_register_info->wake_enable &= ~(gpe_event_info->bit_mask);
 }
 
+
 /******************************************************************************
  *
- * FUNCTION:    Acpi_hw_clear_gpe
+ * FUNCTION:    acpi_hw_clear_gpe
  *
- * PARAMETERS:  Gpe_number      - The GPE
+ * PARAMETERS:  gpe_number      - The GPE
  *
  * RETURN:      None
  *
@@ -215,40 +231,32 @@ acpi_hw_disable_gpe_for_wakeup (
  *
  ******************************************************************************/
 
-void
+acpi_status
 acpi_hw_clear_gpe (
-	u32                     gpe_number)
+	struct acpi_gpe_event_info      *gpe_event_info)
 {
-	u32                     register_index;
-	u32                     bit_mask;
+	acpi_status                     status;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	/*
-	 * Translate GPE number to index into global registers array.
-	 */
-	register_index = acpi_gbl_gpe_valid[gpe_number];
-
-	/*
-	 * Figure out the bit offset for this GPE within the target register.
-	 */
-	bit_mask = acpi_gbl_decode_to8bit [MOD_8 (gpe_number)];
-
-	/*
 	 * Write a one to the appropriate bit in the status register to
 	 * clear this GPE.
 	 */
-	acpi_os_write_port (acpi_gbl_gpe_registers[register_index].status_addr, bit_mask, 8);
+	status = acpi_hw_low_level_write (8, gpe_event_info->bit_mask,
+			  &gpe_event_info->register_info->status_address);
+
+	return (status);
 }
 
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_hw_get_gpe_status
+ * FUNCTION:    acpi_hw_get_gpe_status
  *
- * PARAMETERS:  Gpe_number      - The GPE
+ * PARAMETERS:  gpe_number      - The GPE
  *
  * RETURN:      None
  *
@@ -256,127 +264,317 @@ acpi_hw_clear_gpe (
  *
  ******************************************************************************/
 
-void
+acpi_status
 acpi_hw_get_gpe_status (
-	u32                     gpe_number,
-	acpi_event_status       *event_status)
+	struct acpi_gpe_event_info      *gpe_event_info,
+	acpi_event_status               *event_status)
 {
-	u32                     in_byte = 0;
-	u32                     register_index = 0;
-	u32                     bit_mask = 0;
+	u32                             in_byte;
+	u8                              bit_mask;
+	struct acpi_gpe_register_info   *gpe_register_info;
+	acpi_status                     status;
+	acpi_event_status               local_event_status = 0;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	if (!event_status) {
-		return;
+		return (AE_BAD_PARAMETER);
 	}
 
-	(*event_status) = 0;
+	/* Get the info block for the entire GPE register */
 
-	/*
-	 * Translate GPE number to index into global registers array.
-	 */
-	register_index = acpi_gbl_gpe_valid[gpe_number];
+	gpe_register_info = gpe_event_info->register_info;
 
-	/*
-	 * Figure out the bit offset for this GPE within the target register.
-	 */
-	bit_mask = acpi_gbl_decode_to8bit [MOD_8 (gpe_number)];
+	/* Get the register bitmask for this GPE */
+
+	bit_mask = gpe_event_info->bit_mask;
+
+	/* GPE Enabled? */
+
+	status = acpi_hw_low_level_read (8, &in_byte, &gpe_register_info->enable_address);
+	if (ACPI_FAILURE (status)) {
+		goto unlock_and_exit;
+	}
 
-	/*
-	 * Enabled?:
-	 */
-	in_byte = 0;
-	acpi_os_read_port (acpi_gbl_gpe_registers[register_index].enable_addr, &in_byte, 8);
 	if (bit_mask & in_byte) {
-		(*event_status) |= ACPI_EVENT_FLAG_ENABLED;
+		local_event_status |= ACPI_EVENT_FLAG_ENABLED;
 	}
 
-	/*
-	 * Enabled for wake?:
-	 */
-	if (bit_mask & acpi_gbl_gpe_registers[register_index].wake_enable) {
-		(*event_status) |= ACPI_EVENT_FLAG_WAKE_ENABLED;
+	/* GPE Enabled for wake? */
+
+	if (bit_mask & gpe_register_info->wake_enable) {
+		local_event_status |= ACPI_EVENT_FLAG_WAKE_ENABLED;
+	}
+
+	/* GPE active (set)? */
+
+	status = acpi_hw_low_level_read (8, &in_byte, &gpe_register_info->status_address);
+	if (ACPI_FAILURE (status)) {
+		goto unlock_and_exit;
 	}
 
-	/*
-	 * Set?
-	 */
-	in_byte = 0;
-	acpi_os_read_port (acpi_gbl_gpe_registers[register_index].status_addr, &in_byte, 8);
 	if (bit_mask & in_byte) {
-		(*event_status) |= ACPI_EVENT_FLAG_SET;
+		local_event_status |= ACPI_EVENT_FLAG_SET;
 	}
+
+	/* Set return value */
+
+	(*event_status) = local_event_status;
+
+
+unlock_and_exit:
+	return (status);
 }
 
+
 /******************************************************************************
  *
- * FUNCTION:    Acpi_hw_disable_non_wakeup_gpes
+ * FUNCTION:    acpi_hw_disable_gpe_block
  *
- * PARAMETERS:  None
+ * PARAMETERS:  gpe_xrupt_info      - GPE Interrupt info
+ *              gpe_block           - Gpe Block info
  *
- * RETURN:      None
+ * RETURN:      Status
  *
- * DESCRIPTION: Disable all non-wakeup GPEs
- *              Call with interrupts disabled. The interrupt handler also
- *              modifies Acpi_gbl_Gpe_registers[i].Enable, so it should not be
- *              given the chance to run until after non-wake GPEs are
- *              re-enabled.
+ * DESCRIPTION: Disable all GPEs within a GPE block
  *
  ******************************************************************************/
 
-void
-acpi_hw_disable_non_wakeup_gpes (
-	void)
+acpi_status
+acpi_hw_disable_gpe_block (
+	struct acpi_gpe_xrupt_info      *gpe_xrupt_info,
+	struct acpi_gpe_block_info      *gpe_block)
 {
-	u32                     i;
+	u32                             i;
+	struct acpi_gpe_register_info   *gpe_register_info;
+	acpi_status                     status;
 
-	FUNCTION_ENTRY ();
 
-	for (i = 0; i < acpi_gbl_gpe_register_count; i++) {
+	/* Get the register info for the entire GPE block */
+
+	gpe_register_info = gpe_block->register_info;
+
+	/* Examine each GPE Register within the block */
+
+	for (i = 0; i < gpe_block->register_count; i++) {
+		status = acpi_hw_low_level_write (8, 0x00,
+				 &gpe_block->register_info[i].enable_address);
+		if (ACPI_FAILURE (status)) {
+			return (status);
+		}
+	}
+
+	return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_clear_gpe_block
+ *
+ * PARAMETERS:  gpe_xrupt_info      - GPE Interrupt info
+ *              gpe_block           - Gpe Block info
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Clear all GPEs within a GPE block
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_hw_clear_gpe_block (
+	struct acpi_gpe_xrupt_info      *gpe_xrupt_info,
+	struct acpi_gpe_block_info      *gpe_block)
+{
+	u32                             i;
+	struct acpi_gpe_register_info   *gpe_register_info;
+	acpi_status                     status;
+
+
+	/* Get the register info for the entire GPE block */
+
+	gpe_register_info = gpe_block->register_info;
+
+	/* Examine each GPE Register within the block */
+
+	for (i = 0; i < gpe_block->register_count; i++) {
+		status = acpi_hw_low_level_write (8, 0xFF,
+				 &gpe_block->register_info[i].status_address);
+		if (ACPI_FAILURE (status)) {
+			return (status);
+		}
+	}
+
+	return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_disable_non_wakeup_gpe_block
+ *
+ * PARAMETERS:  gpe_xrupt_info      - GPE Interrupt info
+ *              gpe_block           - Gpe Block info
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Disable all GPEs except wakeup GPEs in a GPE block
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_hw_disable_non_wakeup_gpe_block (
+	struct acpi_gpe_xrupt_info      *gpe_xrupt_info,
+	struct acpi_gpe_block_info      *gpe_block)
+{
+	u32                             i;
+	struct acpi_gpe_register_info   *gpe_register_info;
+	u32                             in_value;
+	acpi_status                     status;
+
+
+	/* Get the register info for the entire GPE block */
+
+	gpe_register_info = gpe_block->register_info;
+
+	/* Examine each GPE Register within the block */
+
+	for (i = 0; i < gpe_block->register_count; i++) {
 		/*
 		 * Read the enabled status of all GPEs. We
 		 * will be using it to restore all the GPEs later.
 		 */
-		acpi_os_read_port (acpi_gbl_gpe_registers[i].enable_addr,
-				&acpi_gbl_gpe_registers[i].enable, 8);
+		status = acpi_hw_low_level_read (8, &in_value,
+				 &gpe_register_info->enable_address);
+		if (ACPI_FAILURE (status)) {
+			return (status);
+		}
+
+		gpe_register_info->enable = (u8) in_value;
 
 		/*
-		 * Disable all GPEs but wakeup GPEs.
+		 * Disable all GPEs except wakeup GPEs.
 		 */
-		acpi_os_write_port(acpi_gbl_gpe_registers[i].enable_addr,
-				acpi_gbl_gpe_registers[i].wake_enable, 8);
+		status = acpi_hw_low_level_write (8, gpe_register_info->wake_enable,
+				&gpe_register_info->enable_address);
+		if (ACPI_FAILURE (status)) {
+			return (status);
+		}
+
+		gpe_register_info++;
 	}
+
+	return (AE_OK);
 }
 
+
 /******************************************************************************
  *
- * FUNCTION:    Acpi_hw_enable_non_wakeup_gpes
+ * FUNCTION:    acpi_hw_disable_non_wakeup_gpes
  *
  * PARAMETERS:  None
  *
  * RETURN:      None
  *
- * DESCRIPTION: Enable all non-wakeup GPEs we previously enabled.
+ * DESCRIPTION: Disable all non-wakeup GPEs
+ *              Called with interrupts disabled. The interrupt handler also
+ *              modifies gpe_register_info->Enable, so it should not be
+ *              given the chance to run until after non-wake GPEs are
+ *              re-enabled.
  *
  ******************************************************************************/
 
-void
-acpi_hw_enable_non_wakeup_gpes (
+acpi_status
+acpi_hw_disable_non_wakeup_gpes (
 	void)
 {
-	u32                     i;
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_ENTRY ();
+
+
+	status = acpi_ev_walk_gpe_list (acpi_hw_disable_non_wakeup_gpe_block);
+
+	return (status);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_enable_non_wakeup_gpe_block
+ *
+ * PARAMETERS:  gpe_xrupt_info      - GPE Interrupt info
+ *              gpe_block           - Gpe Block info
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Enable a single GPE.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_hw_enable_non_wakeup_gpe_block (
+	struct acpi_gpe_xrupt_info      *gpe_xrupt_info,
+	struct acpi_gpe_block_info      *gpe_block)
+{
+	u32                             i;
+	struct acpi_gpe_register_info   *gpe_register_info;
+	acpi_status                     status;
+
+
+	/* This callback processes one entire GPE block */
 
-	FUNCTION_ENTRY ();
+	/* Get the register info for the entire GPE block */
 
-	for (i = 0; i < acpi_gbl_gpe_register_count; i++) {
+	gpe_register_info = gpe_block->register_info;
+
+	/* Examine each GPE register within the block */
+
+	for (i = 0; i < gpe_block->register_count; i++) {
 		/*
 		 * We previously stored the enabled status of all GPEs.
 		 * Blast them back in.
 		 */
-		acpi_os_write_port(acpi_gbl_gpe_registers[i].enable_addr,
-				acpi_gbl_gpe_registers[i].enable, 8);
+		status = acpi_hw_low_level_write (8, gpe_register_info->enable,
+				 &gpe_register_info->enable_address);
+		if (ACPI_FAILURE (status)) {
+			return (status);
+		}
+
+		gpe_register_info++;
 	}
+
+
+	return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_hw_enable_non_wakeup_gpes
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Enable all non-wakeup GPEs we previously enabled.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_hw_enable_non_wakeup_gpes (
+	void)
+{
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_ENTRY ();
+
+
+	status = acpi_ev_walk_gpe_list (acpi_hw_enable_non_wakeup_gpe_block);
+
+	return (status);
 }
diff -urNp linux-5400/drivers/acpi/hardware/hwregs.c linux-5410/drivers/acpi/hardware/hwregs.c
--- linux-5400/drivers/acpi/hardware/hwregs.c
+++ linux-5410/drivers/acpi/hardware/hwregs.c
@@ -3,71 +3,60 @@
  *
  * Module Name: hwregs - Read/write access functions for the various ACPI
  *                       control and status registers.
- *              $Revision: 110 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "achware.h"
-#include "acnamesp.h"
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acevents.h>
 
 #define _COMPONENT          ACPI_HARDWARE
-	 MODULE_NAME         ("hwregs")
+	 ACPI_MODULE_NAME    ("hwregs")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_hw_get_bit_shift
+ * FUNCTION:    acpi_hw_clear_acpi_status
  *
- * PARAMETERS:  Mask            - Input mask to determine bit shift from.
- *                                Must have at least 1 bit set.
- *
- * RETURN:      Bit location of the lsb of the mask
- *
- * DESCRIPTION: Returns the bit number for the low order bit that's set.
- *
- ******************************************************************************/
-
-u32
-acpi_hw_get_bit_shift (
-	u32                     mask)
-{
-	u32                     shift;
-
-
-	FUNCTION_TRACE ("Hw_get_bit_shift");
-
-
-	for (shift = 0; ((mask >> shift) & 1) == 0; shift++) { ; }
-
-	return_VALUE (shift);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_hw_clear_acpi_status
- *
- * PARAMETERS:  none
+ * PARAMETERS:  Flags           - Lock the hardware or not
  *
  * RETURN:      none
  *
@@ -75,506 +64,403 @@ acpi_hw_get_bit_shift (
  *
  ******************************************************************************/
 
-void
-acpi_hw_clear_acpi_status (void)
+acpi_status
+acpi_hw_clear_acpi_status (
+	u32                             flags)
 {
-	u16                     gpe_length;
-	u16                     index;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Hw_clear_acpi_status");
+	ACPI_FUNCTION_TRACE ("hw_clear_acpi_status");
 
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_IO, "About to write %04X to %04X\n",
-		ALL_FIXED_STS_BITS,
-		(u16) ACPI_GET_ADDRESS (acpi_gbl_FADT->Xpm1a_evt_blk.address)));
-
+		ACPI_BITMASK_ALL_FIXED_STATUS,
+		(u16) acpi_gbl_FADT->xpm1a_evt_blk.address));
 
-	acpi_ut_acquire_mutex (ACPI_MTX_HARDWARE);
-
-	acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, PM1_STS, ALL_FIXED_STS_BITS);
-
-
-	if (ACPI_VALID_ADDRESS (acpi_gbl_FADT->Xpm1b_evt_blk.address)) {
-		acpi_os_write_port ((ACPI_IO_ADDRESS)
-			ACPI_GET_ADDRESS (acpi_gbl_FADT->Xpm1b_evt_blk.address),
-			ALL_FIXED_STS_BITS, 16);
+	if (flags & ACPI_MTX_LOCK) {
+		status = acpi_ut_acquire_mutex (ACPI_MTX_HARDWARE);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
 	}
 
-	/* now clear the GPE Bits */
+	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_STATUS,
+			  ACPI_BITMASK_ALL_FIXED_STATUS);
+	if (ACPI_FAILURE (status)) {
+		goto unlock_and_exit;
+	}
 
-	if (acpi_gbl_FADT->gpe0blk_len) {
-		gpe_length = (u16) DIV_2 (acpi_gbl_FADT->gpe0blk_len);
+	/* Clear the fixed events */
 
-		for (index = 0; index < gpe_length; index++) {
-			acpi_os_write_port ((ACPI_IO_ADDRESS) (
-				ACPI_GET_ADDRESS (acpi_gbl_FADT->Xgpe0blk.address) + index),
-					0xFF, 8);
+	if (acpi_gbl_FADT->xpm1b_evt_blk.address) {
+		status = acpi_hw_low_level_write (16, ACPI_BITMASK_ALL_FIXED_STATUS,
+				 &acpi_gbl_FADT->xpm1b_evt_blk);
+		if (ACPI_FAILURE (status)) {
+			goto unlock_and_exit;
 		}
 	}
 
-	if (acpi_gbl_FADT->gpe1_blk_len) {
-		gpe_length = (u16) DIV_2 (acpi_gbl_FADT->gpe1_blk_len);
+	/* Clear the GPE Bits in all GPE registers in all GPE blocks */
 
-		for (index = 0; index < gpe_length; index++) {
-			acpi_os_write_port ((ACPI_IO_ADDRESS) (
-				ACPI_GET_ADDRESS (acpi_gbl_FADT->Xgpe1_blk.address) + index),
-				0xFF, 8);
-		}
-	}
+	status = acpi_ev_walk_gpe_list (acpi_hw_clear_gpe_block);
 
-	acpi_ut_release_mutex (ACPI_MTX_HARDWARE);
-	return_VOID;
+unlock_and_exit:
+	if (flags & ACPI_MTX_LOCK) {
+		(void) acpi_ut_release_mutex (ACPI_MTX_HARDWARE);
+	}
+	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_hw_obtain_sleep_type_register_data
+ * FUNCTION:    acpi_get_sleep_type_data
  *
- * PARAMETERS:  Sleep_state       - Numeric state requested
- *              *Slp_Typ_a         - Pointer to byte to receive SLP_TYPa value
- *              *Slp_Typ_b         - Pointer to byte to receive SLP_TYPb value
+ * PARAMETERS:  sleep_state         - Numeric sleep state
+ *              *sleep_type_a        - Where SLP_TYPa is returned
+ *              *sleep_type_b        - Where SLP_TYPb is returned
  *
  * RETURN:      Status - ACPI status
  *
- * DESCRIPTION: Acpi_hw_obtain_sleep_type_register_data() obtains the SLP_TYP and
- *              SLP_TYPb values for the sleep state requested.
+ * DESCRIPTION: Obtain the SLP_TYPa and SLP_TYPb values for the requested sleep
+ *              state.
  *
  ******************************************************************************/
 
 acpi_status
-acpi_hw_obtain_sleep_type_register_data (
-	u8                      sleep_state,
-	u8                      *slp_typ_a,
-	u8                      *slp_typ_b)
+acpi_get_sleep_type_data (
+	u8                              sleep_state,
+	u8                              *sleep_type_a,
+	u8                              *sleep_type_b)
 {
-	acpi_status             status = AE_OK;
-	acpi_operand_object     *obj_desc;
+	acpi_status                     status = AE_OK;
+	union acpi_operand_object       *obj_desc;
 
 
-	FUNCTION_TRACE ("Hw_obtain_sleep_type_register_data");
+	ACPI_FUNCTION_TRACE ("acpi_get_sleep_type_data");
 
 
 	/*
-	 *  Validate parameters
+	 * Validate parameters
 	 */
 	if ((sleep_state > ACPI_S_STATES_MAX) ||
-		!slp_typ_a || !slp_typ_b) {
+		!sleep_type_a || !sleep_type_b) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
 	/*
-	 *  Acpi_evaluate the namespace object containing the values for this state
+	 * Evaluate the namespace object containing the values for this state
 	 */
-	status = acpi_ns_evaluate_by_name ((NATIVE_CHAR *) acpi_gbl_db_sleep_states[sleep_state],
+	status = acpi_ns_evaluate_by_name ((char *) acpi_gbl_db_sleep_states[sleep_state],
 			  NULL, &obj_desc);
 	if (ACPI_FAILURE (status)) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "%s while evaluating sleep_state [%s]\n",
+			acpi_format_exception (status), acpi_gbl_db_sleep_states[sleep_state]));
+
 		return_ACPI_STATUS (status);
 	}
 
+	/* Must have a return object */
+
 	if (!obj_desc) {
-		REPORT_ERROR (("Missing Sleep State object\n"));
-		return_ACPI_STATUS (AE_NOT_EXIST);
+		ACPI_REPORT_ERROR (("Missing Sleep State object\n"));
+		status = AE_NOT_EXIST;
 	}
 
-	/*
-	 *  We got something, now ensure it is correct.  The object must
-	 *  be a package and must have at least 2 numeric values as the
-	 *  two elements
-	 */
+	/* It must be of type Package */
 
-	/* Even though Acpi_evaluate_object resolves package references,
-	 * Ns_evaluate dpesn't. So, we do it here.
-	 */
-	status = acpi_ut_resolve_package_references(obj_desc);
+	else if (ACPI_GET_OBJECT_TYPE (obj_desc) != ACPI_TYPE_PACKAGE) {
+		ACPI_REPORT_ERROR (("Sleep State object not a Package\n"));
+		status = AE_AML_OPERAND_TYPE;
+	}
 
-	if (obj_desc->package.count < 2) {
-		/* Must have at least two elements */
+	/* The package must have at least two elements */
 
-		REPORT_ERROR (("Sleep State package does not have at least two elements\n"));
-		status = AE_ERROR;
+	else if (obj_desc->package.count < 2) {
+		ACPI_REPORT_ERROR (("Sleep State package does not have at least two elements\n"));
+		status = AE_AML_NO_OPERAND;
 	}
 
-	else if (((obj_desc->package.elements[0])->common.type !=
-			 ACPI_TYPE_INTEGER) ||
-			 ((obj_desc->package.elements[1])->common.type !=
-				ACPI_TYPE_INTEGER)) {
-		/* Must have two  */
+	/* The first two elements must both be of type Integer */
 
-		REPORT_ERROR (("Sleep State package elements are not both of type Number\n"));
-		status = AE_ERROR;
+	else if ((ACPI_GET_OBJECT_TYPE (obj_desc->package.elements[0]) != ACPI_TYPE_INTEGER) ||
+			 (ACPI_GET_OBJECT_TYPE (obj_desc->package.elements[1]) != ACPI_TYPE_INTEGER)) {
+		ACPI_REPORT_ERROR (("Sleep State package elements are not both Integers (%s, %s)\n",
+			acpi_ut_get_object_type_name (obj_desc->package.elements[0]),
+			acpi_ut_get_object_type_name (obj_desc->package.elements[1])));
+		status = AE_AML_OPERAND_TYPE;
 	}
-
 	else {
 		/*
-		 *  Valid _Sx_ package size, type, and value
+		 * Valid _Sx_ package size, type, and value
 		 */
-		*slp_typ_a = (u8) (obj_desc->package.elements[0])->integer.value;
-
-		*slp_typ_b = (u8) (obj_desc->package.elements[1])->integer.value;
+		*sleep_type_a = (u8) (obj_desc->package.elements[0])->integer.value;
+		*sleep_type_b = (u8) (obj_desc->package.elements[1])->integer.value;
 	}
 
-
 	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Bad Sleep object %p type %X\n",
-			obj_desc, obj_desc->common.type));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "While evaluating sleep_state [%s], bad Sleep object %p type %s\n",
+			acpi_gbl_db_sleep_states[sleep_state], obj_desc, acpi_ut_get_object_type_name (obj_desc)));
 	}
 
 	acpi_ut_remove_reference (obj_desc);
-
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_hw_register_bit_access
+ * FUNCTION:    acpi_hw_get_register_bit_mask
  *
- * PARAMETERS:  Read_write      - Either ACPI_READ or ACPI_WRITE.
- *              Use_lock        - Lock the hardware
- *              Register_id     - index of ACPI Register to access
- *              Value           - (only used on write) value to write to the
- *                                Register.  Shifted all the way right.
+ * PARAMETERS:  register_id         - Index of ACPI Register to access
  *
- * RETURN:      Value written to or read from specified Register.  This value
- *              is shifted all the way right.
+ * RETURN:      The bit mask to be used when accessing the register
  *
- * DESCRIPTION: Generic ACPI Register read/write function.
+ * DESCRIPTION: Map register_id into a register bit mask.
  *
  ******************************************************************************/
 
-u32
-acpi_hw_register_bit_access (
-	NATIVE_UINT             read_write,
-	u8                      use_lock,
-	u32                     register_id,
-	...)                    /* Value (only used on write) */
+struct acpi_bit_register_info *
+acpi_hw_get_bit_register_info (
+	u32                             register_id)
 {
-	u32                     register_value = 0;
-	u32                     mask = 0;
-	u32                     value = 0;
-	va_list                 marker;
-
+	ACPI_FUNCTION_NAME ("hw_get_bit_register_info");
 
-	FUNCTION_TRACE ("Hw_register_bit_access");
 
-
-	if (read_write == ACPI_WRITE) {
-		va_start (marker, register_id);
-		value = va_arg (marker, u32);
-		va_end (marker);
+	if (register_id > ACPI_BITREG_MAX) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid bit_register ID: %X\n", register_id));
+		return (NULL);
 	}
 
-	if (ACPI_MTX_LOCK == use_lock) {
-		acpi_ut_acquire_mutex (ACPI_MTX_HARDWARE);
-	}
+	return (&acpi_gbl_bit_register_info[register_id]);
+}
 
-	/*
-	 * Decode the Register ID
-	 * Register id = Register block id | bit id
-	 *
-	 * Check bit id to fine locate Register offset.
-	 * Check Mask to determine Register offset, and then read-write.
-	 */
-	switch (REGISTER_BLOCK_ID (register_id)) {
-	case PM1_STS:
 
-		switch (register_id) {
-		case TMR_STS:
-			mask = TMR_STS_MASK;
-			break;
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_register
+ *
+ * PARAMETERS:  register_id     - ID of ACPI bit_register to access
+ *              return_value    - Value that was read from the register
+ *              Flags           - Lock the hardware or not
+ *
+ * RETURN:      Value is read from specified Register.  Value returned is
+ *              normalized to bit0 (is shifted all the way right)
+ *
+ * DESCRIPTION: ACPI bit_register read function.
+ *
+ ******************************************************************************/
 
-		case BM_STS:
-			mask = BM_STS_MASK;
-			break;
+acpi_status
+acpi_get_register (
+	u32                             register_id,
+	u32                             *return_value,
+	u32                             flags)
+{
+	u32                             register_value = 0;
+	struct acpi_bit_register_info   *bit_reg_info;
+	acpi_status                     status;
 
-		case GBL_STS:
-			mask = GBL_STS_MASK;
-			break;
 
-		case PWRBTN_STS:
-			mask = PWRBTN_STS_MASK;
-			break;
+	ACPI_FUNCTION_TRACE ("acpi_get_register");
 
-		case SLPBTN_STS:
-			mask = SLPBTN_STS_MASK;
-			break;
 
-		case RTC_STS:
-			mask = RTC_STS_MASK;
-			break;
+	/* Get the info structure corresponding to the requested ACPI Register */
 
-		case WAK_STS:
-			mask = WAK_STS_MASK;
-			break;
+	bit_reg_info = acpi_hw_get_bit_register_info (register_id);
+	if (!bit_reg_info) {
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
 
-		default:
-			mask = 0;
-			break;
+	if (flags & ACPI_MTX_LOCK) {
+		status = acpi_ut_acquire_mutex (ACPI_MTX_HARDWARE);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
 		}
+	}
 
-		register_value = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, PM1_STS);
+	status = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK,
+			  bit_reg_info->parent_register, &register_value);
 
-		if (read_write == ACPI_WRITE) {
-			/*
-			 * Status Registers are different from the rest.  Clear by
-			 * writing 1, writing 0 has no effect.  So, the only relevent
-			 * information is the single bit we're interested in, all
-			 * others should be written as 0 so they will be left
-			 * unchanged
-			 */
-			value <<= acpi_hw_get_bit_shift (mask);
-			value &= mask;
+	if (flags & ACPI_MTX_LOCK) {
+		(void) acpi_ut_release_mutex (ACPI_MTX_HARDWARE);
+	}
 
-			if (value) {
-				acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, PM1_STS,
-					(u16) value);
-				register_value = 0;
-			}
-		}
+	if (ACPI_SUCCESS (status)) {
+		/* Normalize the value that was read */
 
-		break;
+		register_value = ((register_value & bit_reg_info->access_bit_mask)
+				   >> bit_reg_info->bit_position);
 
+		*return_value = register_value;
 
-	case PM1_EN:
+		ACPI_DEBUG_PRINT ((ACPI_DB_IO, "Read value %8.8X register %X\n",
+				register_value, bit_reg_info->parent_register));
+	}
 
-		switch (register_id) {
-		case TMR_EN:
-			mask = TMR_EN_MASK;
-			break;
+	return_ACPI_STATUS (status);
+}
 
-		case GBL_EN:
-			mask = GBL_EN_MASK;
-			break;
 
-		case PWRBTN_EN:
-			mask = PWRBTN_EN_MASK;
-			break;
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_set_register
+ *
+ * PARAMETERS:  register_id     - ID of ACPI bit_register to access
+ *              Value           - (only used on write) value to write to the
+ *                                Register, NOT pre-normalized to the bit pos.
+ *              Flags           - Lock the hardware or not
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: ACPI Bit Register write function.
+ *
+ ******************************************************************************/
 
-		case SLPBTN_EN:
-			mask = SLPBTN_EN_MASK;
-			break;
+acpi_status
+acpi_set_register (
+	u32                             register_id,
+	u32                             value,
+	u32                             flags)
+{
+	u32                             register_value = 0;
+	struct acpi_bit_register_info   *bit_reg_info;
+	acpi_status                     status;
 
-		case RTC_EN:
-			mask = RTC_EN_MASK;
-			break;
 
-		default:
-			mask = 0;
-			break;
-		}
+	ACPI_FUNCTION_TRACE_U32 ("acpi_set_register", register_id);
 
-		register_value = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, PM1_EN);
 
-		if (read_write == ACPI_WRITE) {
-			register_value &= ~mask;
-			value          <<= acpi_hw_get_bit_shift (mask);
-			value          &= mask;
-			register_value |= value;
+	/* Get the info structure corresponding to the requested ACPI Register */
 
-			acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, PM1_EN, (u16) register_value);
+	bit_reg_info = acpi_hw_get_bit_register_info (register_id);
+	if (!bit_reg_info) {
+		ACPI_REPORT_ERROR (("Bad ACPI HW register_id: %X\n", register_id));
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
+
+	if (flags & ACPI_MTX_LOCK) {
+		status = acpi_ut_acquire_mutex (ACPI_MTX_HARDWARE);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
 		}
+	}
 
-		break;
+	/* Always do a register read first so we can insert the new bits  */
 
+	status = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK,
+			  bit_reg_info->parent_register, &register_value);
+	if (ACPI_FAILURE (status)) {
+		goto unlock_and_exit;
+	}
 
-	case PM1_CONTROL:
+	/*
+	 * Decode the Register ID
+	 * Register id = Register block id | bit id
+	 *
+	 * Check bit id to fine locate Register offset.
+	 * Check Mask to determine Register offset, and then read-write.
+	 */
+	switch (bit_reg_info->parent_register) {
+	case ACPI_REGISTER_PM1_STATUS:
 
-		switch (register_id) {
-		case SCI_EN:
-			mask = SCI_EN_MASK;
-			break;
+		/*
+		 * Status Registers are different from the rest.  Clear by
+		 * writing 1, writing 0 has no effect.  So, the only relevant
+		 * information is the single bit we're interested in, all others should
+		 * be written as 0 so they will be left unchanged
+		 */
+		value = ACPI_REGISTER_PREPARE_BITS (value,
+				 bit_reg_info->bit_position, bit_reg_info->access_bit_mask);
+		if (value) {
+			status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
+					 ACPI_REGISTER_PM1_STATUS, (u16) value);
+			register_value = 0;
+		}
+		break;
 
-		case BM_RLD:
-			mask = BM_RLD_MASK;
-			break;
 
-		case GBL_RLS:
-			mask = GBL_RLS_MASK;
-			break;
+	case ACPI_REGISTER_PM1_ENABLE:
 
-		case SLP_TYPE_A:
-		case SLP_TYPE_B:
-			mask = SLP_TYPE_X_MASK;
-			break;
+		ACPI_REGISTER_INSERT_VALUE (register_value, bit_reg_info->bit_position,
+				bit_reg_info->access_bit_mask, value);
 
-		case SLP_EN:
-			mask = SLP_EN_MASK;
-			break;
+		status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
+				  ACPI_REGISTER_PM1_ENABLE, (u16) register_value);
+		break;
 
-		default:
-			mask = 0;
-			break;
-		}
 
+	case ACPI_REGISTER_PM1_CONTROL:
 
 		/*
 		 * Read the PM1 Control register.
 		 * Note that at this level, the fact that there are actually TWO
-		 * registers (A and B) and that B may not exist, are abstracted.
+		 * registers (A and B - and that B may not exist) is abstracted.
 		 */
-		register_value = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, PM1_CONTROL);
-
 		ACPI_DEBUG_PRINT ((ACPI_DB_IO, "PM1 control: Read %X\n", register_value));
 
-		if (read_write == ACPI_WRITE) {
-			register_value &= ~mask;
-			value          <<= acpi_hw_get_bit_shift (mask);
-			value          &= mask;
-			register_value |= value;
+		ACPI_REGISTER_INSERT_VALUE (register_value, bit_reg_info->bit_position,
+				bit_reg_info->access_bit_mask, value);
 
-			/*
-			 * SLP_TYPE_x Registers are written differently
-			 * than any other control Registers with
-			 * respect to A and B Registers.  The value
-			 * for A may be different than the value for B
-			 *
-			 * Therefore, pass the Register_id, not just generic PM1_CONTROL,
-			 * because we need to do different things. Yuck.
-			 */
-			acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, register_id,
-					(u16) register_value);
-		}
+		status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, register_id,
+				(u16) register_value);
 		break;
 
 
-	case PM2_CONTROL:
+	case ACPI_REGISTER_PM2_CONTROL:
 
-		switch (register_id) {
-		case ARB_DIS:
-			mask = ARB_DIS_MASK;
-			break;
-
-		default:
-			mask = 0;
-			break;
+		status = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK,
+				 ACPI_REGISTER_PM2_CONTROL, &register_value);
+		if (ACPI_FAILURE (status)) {
+			goto unlock_and_exit;
 		}
 
-		register_value = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, PM2_CONTROL);
-
 		ACPI_DEBUG_PRINT ((ACPI_DB_IO, "PM2 control: Read %X from %8.8X%8.8X\n",
-			register_value, HIDWORD(acpi_gbl_FADT->Xpm2_cnt_blk.address),
-			LODWORD(acpi_gbl_FADT->Xpm2_cnt_blk.address)));
-
-		if (read_write == ACPI_WRITE) {
-			register_value &= ~mask;
-			value          <<= acpi_hw_get_bit_shift (mask);
-			value          &= mask;
-			register_value |= value;
-
-			ACPI_DEBUG_PRINT ((ACPI_DB_IO, "About to write %04X to %8.8X%8.8X\n",
-				register_value,
-				HIDWORD(acpi_gbl_FADT->Xpm2_cnt_blk.address),
-				LODWORD(acpi_gbl_FADT->Xpm2_cnt_blk.address)));
-
-			acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
-					   PM2_CONTROL, (u8) (register_value));
-		}
-		break;
-
-
-	case PM_TIMER:
-
-		mask = TMR_VAL_MASK;
-		register_value = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK,
-				 PM_TIMER);
-		ACPI_DEBUG_PRINT ((ACPI_DB_IO, "PM_TIMER: Read %X from %8.8X%8.8X\n",
 			register_value,
-			HIDWORD(acpi_gbl_FADT->Xpm_tmr_blk.address),
-			LODWORD(acpi_gbl_FADT->Xpm_tmr_blk.address)));
-
-		break;
-
-
-	case GPE1_EN_BLOCK:
-	case GPE1_STS_BLOCK:
-	case GPE0_EN_BLOCK:
-	case GPE0_STS_BLOCK:
-
-		/* Determine the bit to be accessed
-		 *
-		 *  (u32) Register_id:
-		 *      31      24       16       8        0
-		 *      +--------+--------+--------+--------+
-		 *      |  gpe_block_id   |  gpe_bit_number |
-		 *      +--------+--------+--------+--------+
-		 *
-		 *     gpe_block_id is one of GPE[01]_EN_BLOCK and GPE[01]_STS_BLOCK
-		 *     gpe_bit_number is relative from the gpe_block (0x00~0xFF)
-		 */
-		mask = REGISTER_BIT_ID(register_id); /* gpe_bit_number */
-		register_id = REGISTER_BLOCK_ID(register_id) | (mask >> 3);
-		mask = acpi_gbl_decode_to8bit [mask % 8];
-
-		/*
-		 * The base address of the GPE 0 Register Block
-		 * Plus 1/2 the length of the GPE 0 Register Block
-		 * The enable Register is the Register following the Status Register
-		 * and each Register is defined as 1/2 of the total Register Block
-		 */
-
-		/*
-		 * This sets the bit within Enable_bit that needs to be written to
-		 * the Register indicated in Mask to a 1, all others are 0
-		 */
+			ACPI_HIDWORD (acpi_gbl_FADT->xpm2_cnt_blk.address),
+			ACPI_LODWORD (acpi_gbl_FADT->xpm2_cnt_blk.address)));
 
-		/* Now get the current Enable Bits in the selected Reg */
+		ACPI_REGISTER_INSERT_VALUE (register_value, bit_reg_info->bit_position,
+				bit_reg_info->access_bit_mask, value);
 
-		register_value = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, register_id);
-		ACPI_DEBUG_PRINT ((ACPI_DB_IO, "GPE Enable bits: Read %X from %X\n",
-			register_value, register_id));
-
-		if (read_write == ACPI_WRITE) {
-			register_value &= ~mask;
-			value          <<= acpi_hw_get_bit_shift (mask);
-			value          &= mask;
-			register_value |= value;
+		ACPI_DEBUG_PRINT ((ACPI_DB_IO, "About to write %4.4X to %8.8X%8.8X\n",
+			register_value,
+			ACPI_HIDWORD (acpi_gbl_FADT->xpm2_cnt_blk.address),
+			ACPI_LODWORD (acpi_gbl_FADT->xpm2_cnt_blk.address)));
 
-			/*
-			 * This write will put the Action state into the General Purpose
-			 * Enable Register indexed by the value in Mask
-			 */
-			ACPI_DEBUG_PRINT ((ACPI_DB_IO, "About to write %04X to %04X\n",
-				register_value, register_id));
-			acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, register_id,
-				(u8) register_value);
-			register_value = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK,
-					   register_id);
-		}
+		status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
+				   ACPI_REGISTER_PM2_CONTROL, (u8) (register_value));
 		break;
 
 
-	case SMI_CMD_BLOCK:
-	case PROCESSOR_BLOCK:
-
-		/* Not used by any callers at this time - therefore, not implemented */
-
 	default:
-
-		mask = 0;
 		break;
 	}
 
-	if (ACPI_MTX_LOCK == use_lock) {
-		acpi_ut_release_mutex (ACPI_MTX_HARDWARE);
+
+unlock_and_exit:
+
+	if (flags & ACPI_MTX_LOCK) {
+		(void) acpi_ut_release_mutex (ACPI_MTX_HARDWARE);
 	}
 
+	/* Normalize the value that was read */
 
-	register_value &= mask;
-	register_value >>= acpi_hw_get_bit_shift (mask);
+	ACPI_DEBUG_EXEC (register_value = ((register_value & bit_reg_info->access_bit_mask) >> bit_reg_info->bit_position));
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_IO, "Register I/O: returning %X\n", register_value));
-	return_VALUE (register_value);
+	ACPI_DEBUG_PRINT ((ACPI_DB_IO, "Set bits: %8.8X actual %8.8X register %X\n",
+			value, register_value, bit_reg_info->parent_register));
+	return_ACPI_STATUS (status);
 }
 
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_hw_register_read
+ * FUNCTION:    acpi_hw_register_read
  *
- * PARAMETERS:  Use_lock               - Mutex hw access.
- *              Register_id            - Register_iD + Offset.
+ * PARAMETERS:  use_lock               - Mutex hw access.
+ *              register_id            - register_iD + Offset.
  *
  * RETURN:      Value read or written.
  *
@@ -583,112 +469,109 @@ acpi_hw_register_bit_access (
  *
  ******************************************************************************/
 
-u32
+acpi_status
 acpi_hw_register_read (
-	u8                      use_lock,
-	u32                     register_id)
+	u8                              use_lock,
+	u32                             register_id,
+	u32                             *return_value)
 {
-	u32                     value = 0;
-	u32                     bank_offset;
+	u32                             value1 = 0;
+	u32                             value2 = 0;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Hw_register_read");
+	ACPI_FUNCTION_TRACE ("hw_register_read");
 
 
 	if (ACPI_MTX_LOCK == use_lock) {
-		acpi_ut_acquire_mutex (ACPI_MTX_HARDWARE);
+		status = acpi_ut_acquire_mutex (ACPI_MTX_HARDWARE);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
 	}
 
+	switch (register_id) {
+	case ACPI_REGISTER_PM1_STATUS:           /* 16-bit access */
 
-	switch (REGISTER_BLOCK_ID(register_id)) {
-	case PM1_STS: /* 16-bit access */
-
-		value =  acpi_hw_low_level_read (16, &acpi_gbl_FADT->Xpm1a_evt_blk, 0);
-		value |= acpi_hw_low_level_read (16, &acpi_gbl_FADT->Xpm1b_evt_blk, 0);
-		break;
-
+		status = acpi_hw_low_level_read (16, &value1, &acpi_gbl_FADT->xpm1a_evt_blk);
+		if (ACPI_FAILURE (status)) {
+			goto unlock_and_exit;
+		}
 
-	case PM1_EN: /* 16-bit access*/
+		/* PM1B is optional */
 
-		bank_offset = DIV_2 (acpi_gbl_FADT->pm1_evt_len);
-		value =  acpi_hw_low_level_read (16, &acpi_gbl_FADT->Xpm1a_evt_blk, bank_offset);
-		value |= acpi_hw_low_level_read (16, &acpi_gbl_FADT->Xpm1b_evt_blk, bank_offset);
+		status = acpi_hw_low_level_read (16, &value2, &acpi_gbl_FADT->xpm1b_evt_blk);
+		value1 |= value2;
 		break;
 
 
-	case PM1_CONTROL: /* 16-bit access */
-
-		value =  acpi_hw_low_level_read (16, &acpi_gbl_FADT->Xpm1a_cnt_blk, 0);
-		value |= acpi_hw_low_level_read (16, &acpi_gbl_FADT->Xpm1b_cnt_blk, 0);
-		break;
+	case ACPI_REGISTER_PM1_ENABLE:           /* 16-bit access */
 
+		status = acpi_hw_low_level_read (16, &value1, &acpi_gbl_xpm1a_enable);
+		if (ACPI_FAILURE (status)) {
+			goto unlock_and_exit;
+		}
 
-	case PM2_CONTROL: /* 8-bit access */
+		/* PM1B is optional */
 
-		value =  acpi_hw_low_level_read (8, &acpi_gbl_FADT->Xpm2_cnt_blk, 0);
+		status = acpi_hw_low_level_read (16, &value2, &acpi_gbl_xpm1b_enable);
+		value1 |= value2;
 		break;
 
 
-	case PM_TIMER: /* 32-bit access */
-
-		value =  acpi_hw_low_level_read (32, &acpi_gbl_FADT->Xpm_tmr_blk, 0);
-		break;
-
+	case ACPI_REGISTER_PM1_CONTROL:          /* 16-bit access */
 
-	/*
-	 * For the GPE? Blocks, the lower word of Register_id contains the
-	 * byte offset for which to read, as each part of each block may be
-	 * several bytes long.
-	 */
-	case GPE0_STS_BLOCK: /* 8-bit access */
+		status = acpi_hw_low_level_read (16, &value1, &acpi_gbl_FADT->xpm1a_cnt_blk);
+		if (ACPI_FAILURE (status)) {
+			goto unlock_and_exit;
+		}
 
-		bank_offset = REGISTER_BIT_ID(register_id);
-		value = acpi_hw_low_level_read (8, &acpi_gbl_FADT->Xgpe0blk, bank_offset);
+		status = acpi_hw_low_level_read (16, &value2, &acpi_gbl_FADT->xpm1b_cnt_blk);
+		value1 |= value2;
 		break;
 
-	case GPE0_EN_BLOCK: /* 8-bit access */
-
-		bank_offset = DIV_2 (acpi_gbl_FADT->gpe0blk_len) + REGISTER_BIT_ID(register_id);
-		value = acpi_hw_low_level_read (8, &acpi_gbl_FADT->Xgpe0blk, bank_offset);
-		break;
 
-	case GPE1_STS_BLOCK: /* 8-bit access */
+	case ACPI_REGISTER_PM2_CONTROL:          /* 8-bit access */
 
-		bank_offset = REGISTER_BIT_ID(register_id);
-		value = acpi_hw_low_level_read (8, &acpi_gbl_FADT->Xgpe1_blk, bank_offset);
+		status = acpi_hw_low_level_read (8, &value1, &acpi_gbl_FADT->xpm2_cnt_blk);
 		break;
 
-	case GPE1_EN_BLOCK: /* 8-bit access */
 
-		bank_offset = DIV_2 (acpi_gbl_FADT->gpe1_blk_len) + REGISTER_BIT_ID(register_id);
-		value = acpi_hw_low_level_read (8, &acpi_gbl_FADT->Xgpe1_blk, bank_offset);
+	case ACPI_REGISTER_PM_TIMER:             /* 32-bit access */
+
+		status = acpi_hw_low_level_read (32, &value1, &acpi_gbl_FADT->xpm_tmr_blk);
 		break;
 
-	case SMI_CMD_BLOCK: /* 8bit */
+	case ACPI_REGISTER_SMI_COMMAND_BLOCK:    /* 8-bit access */
 
-		acpi_os_read_port (acpi_gbl_FADT->smi_cmd, &value, 8);
+		status = acpi_os_read_port (acpi_gbl_FADT->smi_cmd, &value1, 8);
 		break;
 
 	default:
-		/* Value will be returned as 0 */
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown Register ID: %X\n", register_id));
+		status = AE_BAD_PARAMETER;
 		break;
 	}
 
-
+unlock_and_exit:
 	if (ACPI_MTX_LOCK == use_lock) {
-		acpi_ut_release_mutex (ACPI_MTX_HARDWARE);
+		(void) acpi_ut_release_mutex (ACPI_MTX_HARDWARE);
+	}
+
+	if (ACPI_SUCCESS (status)) {
+		*return_value = value1;
 	}
 
-	return_VALUE (value);
+	return_ACPI_STATUS (status);
 }
 
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_hw_register_write
+ * FUNCTION:    acpi_hw_register_write
  *
- * PARAMETERS:  Use_lock               - Mutex hw access.
- *              Register_id            - Register_iD + Offset.
+ * PARAMETERS:  use_lock               - Mutex hw access.
+ *              register_id            - register_iD + Offset.
  *
  * RETURN:      Value read or written.
  *
@@ -697,160 +580,147 @@ acpi_hw_register_read (
  *
  ******************************************************************************/
 
-void
+acpi_status
 acpi_hw_register_write (
-	u8                      use_lock,
-	u32                     register_id,
-	u32                     value)
+	u8                              use_lock,
+	u32                             register_id,
+	u32                             value)
 {
-	u32                     bank_offset;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Hw_register_write");
+	ACPI_FUNCTION_TRACE ("hw_register_write");
 
 
 	if (ACPI_MTX_LOCK == use_lock) {
-		acpi_ut_acquire_mutex (ACPI_MTX_HARDWARE);
+		status = acpi_ut_acquire_mutex (ACPI_MTX_HARDWARE);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
 	}
 
+	switch (register_id) {
+	case ACPI_REGISTER_PM1_STATUS:           /* 16-bit access */
 
-	switch (REGISTER_BLOCK_ID (register_id)) {
-	case PM1_STS: /* 16-bit access */
-
-		acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1a_evt_blk, 0);
-		acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1b_evt_blk, 0);
-		break;
-
-
-	case PM1_EN: /* 16-bit access*/
-
-		bank_offset = DIV_2 (acpi_gbl_FADT->pm1_evt_len);
-		acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1a_evt_blk, bank_offset);
-		acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1b_evt_blk, bank_offset);
-		break;
-
+		status = acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->xpm1a_evt_blk);
+		if (ACPI_FAILURE (status)) {
+			goto unlock_and_exit;
+		}
 
-	case PM1_CONTROL: /* 16-bit access */
+		/* PM1B is optional */
 
-		acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1a_cnt_blk, 0);
-		acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1b_cnt_blk, 0);
+		status = acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->xpm1b_evt_blk);
 		break;
 
 
-	case PM1A_CONTROL: /* 16-bit access */
-
-		acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1a_cnt_blk, 0);
-		break;
+	case ACPI_REGISTER_PM1_ENABLE:           /* 16-bit access*/
 
+		status = acpi_hw_low_level_write (16, value, &acpi_gbl_xpm1a_enable);
+		if (ACPI_FAILURE (status)) {
+			goto unlock_and_exit;
+		}
 
-	case PM1B_CONTROL: /* 16-bit access */
+		/* PM1B is optional */
 
-		acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1b_cnt_blk, 0);
+		status = acpi_hw_low_level_write (16, value, &acpi_gbl_xpm1b_enable);
 		break;
 
 
-	case PM2_CONTROL: /* 8-bit access */
-
-		acpi_hw_low_level_write (8, value, &acpi_gbl_FADT->Xpm2_cnt_blk, 0);
-		break;
-
+	case ACPI_REGISTER_PM1_CONTROL:          /* 16-bit access */
 
-	case PM_TIMER: /* 32-bit access */
+		status = acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->xpm1a_cnt_blk);
+		if (ACPI_FAILURE (status)) {
+			goto unlock_and_exit;
+		}
 
-		acpi_hw_low_level_write (32, value, &acpi_gbl_FADT->Xpm_tmr_blk, 0);
+		status = acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->xpm1b_cnt_blk);
 		break;
 
 
-	case GPE0_STS_BLOCK: /* 8-bit access */
+	case ACPI_REGISTER_PM1A_CONTROL:         /* 16-bit access */
 
-		bank_offset = REGISTER_BIT_ID(register_id);
-		acpi_hw_low_level_write (8, value, &acpi_gbl_FADT->Xgpe0blk, bank_offset);
+		status = acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->xpm1a_cnt_blk);
 		break;
 
 
-	case GPE0_EN_BLOCK: /* 8-bit access */
+	case ACPI_REGISTER_PM1B_CONTROL:         /* 16-bit access */
 
-		bank_offset = DIV_2 (acpi_gbl_FADT->gpe0blk_len) + REGISTER_BIT_ID(register_id);
-		acpi_hw_low_level_write (8, value, &acpi_gbl_FADT->Xgpe0blk, bank_offset);
+		status = acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->xpm1b_cnt_blk);
 		break;
 
 
-	case GPE1_STS_BLOCK: /* 8-bit access */
+	case ACPI_REGISTER_PM2_CONTROL:          /* 8-bit access */
 
-		bank_offset = REGISTER_BIT_ID(register_id);
-		acpi_hw_low_level_write (8, value, &acpi_gbl_FADT->Xgpe1_blk, bank_offset);
+		status = acpi_hw_low_level_write (8, value, &acpi_gbl_FADT->xpm2_cnt_blk);
 		break;
 
 
-	case GPE1_EN_BLOCK: /* 8-bit access */
+	case ACPI_REGISTER_PM_TIMER:             /* 32-bit access */
 
-		bank_offset = DIV_2 (acpi_gbl_FADT->gpe1_blk_len) + REGISTER_BIT_ID(register_id);
-		acpi_hw_low_level_write (8, value, &acpi_gbl_FADT->Xgpe1_blk, bank_offset);
+		status = acpi_hw_low_level_write (32, value, &acpi_gbl_FADT->xpm_tmr_blk);
 		break;
 
 
-	case SMI_CMD_BLOCK: /* 8bit */
+	case ACPI_REGISTER_SMI_COMMAND_BLOCK:    /* 8-bit access */
 
-		/* For 2.0, SMI_CMD is always in IO space */
-		/* TBD: what about 1.0? 0.71? */
+		/* SMI_CMD is currently always in IO space */
 
-		acpi_os_write_port (acpi_gbl_FADT->smi_cmd, value, 8);
+		status = acpi_os_write_port (acpi_gbl_FADT->smi_cmd, value, 8);
 		break;
 
 
 	default:
-		value = 0;
+		status = AE_BAD_PARAMETER;
 		break;
 	}
 
-
+unlock_and_exit:
 	if (ACPI_MTX_LOCK == use_lock) {
-		acpi_ut_release_mutex (ACPI_MTX_HARDWARE);
+		(void) acpi_ut_release_mutex (ACPI_MTX_HARDWARE);
 	}
 
-	return_VOID;
+	return_ACPI_STATUS (status);
 }
 
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_hw_low_level_read
+ * FUNCTION:    acpi_hw_low_level_read
  *
- * PARAMETERS:  Register            - GAS register structure
- *              Offset              - Offset from the base address in the GAS
- *              Width               - 8, 16, or 32
+ * PARAMETERS:  Width               - 8, 16, or 32
+ *              Value               - Where the value is returned
+ *              Register            - GAS register structure
  *
- * RETURN:      Value read
+ * RETURN:      Status
  *
  * DESCRIPTION: Read from either memory, IO, or PCI config space.
  *
  ******************************************************************************/
 
-u32
+acpi_status
 acpi_hw_low_level_read (
-	u32                     width,
-	acpi_generic_address    *reg,
-	u32                     offset)
+	u32                             width,
+	u32                             *value,
+	struct acpi_generic_address     *reg)
 {
-	u32                     value = 0;
-	ACPI_PHYSICAL_ADDRESS   mem_address;
-	ACPI_IO_ADDRESS         io_address;
-	acpi_pci_id             pci_id;
-	u16                     pci_register;
+	struct acpi_pci_id              pci_id;
+	u16                             pci_register;
+	acpi_status                     status;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_NAME ("hw_low_level_read");
 
 
 	/*
 	 * Must have a valid pointer to a GAS structure, and
-	 * a non-zero address within
+	 * a non-zero address within. However, don't return an error
+	 * because the PM1A/B code must not fail if B isn't present.
 	 */
 	if ((!reg) ||
-		(!ACPI_VALID_ADDRESS (reg->address))) {
-		return 0;
+		(!reg->address)) {
+		return (AE_OK);
 	}
-
+	*value = 0;
 
 	/*
 	 * Three address spaces supported:
@@ -859,17 +729,16 @@ acpi_hw_low_level_read (
 	switch (reg->address_space_id) {
 	case ACPI_ADR_SPACE_SYSTEM_MEMORY:
 
-		mem_address = (ACPI_PHYSICAL_ADDRESS) (ACPI_GET_ADDRESS (reg->address) + offset);
-
-		acpi_os_read_memory (mem_address, &value, width);
+		status = acpi_os_read_memory (
+				 (acpi_physical_address) reg->address,
+				 value, width);
 		break;
 
 
 	case ACPI_ADR_SPACE_SYSTEM_IO:
 
-		io_address = (ACPI_IO_ADDRESS) (ACPI_GET_ADDRESS (reg->address) + offset);
-
-		acpi_os_read_port (io_address, &value, width);
+		status = acpi_os_read_port ((acpi_io_address) reg->address,
+				 value, width);
 		break;
 
 
@@ -877,60 +746,68 @@ acpi_hw_low_level_read (
 
 		pci_id.segment = 0;
 		pci_id.bus     = 0;
-		pci_id.device  = ACPI_PCI_DEVICE (ACPI_GET_ADDRESS (reg->address));
-		pci_id.function = ACPI_PCI_FUNCTION (ACPI_GET_ADDRESS (reg->address));
-		pci_register   = (u16) (ACPI_PCI_REGISTER (ACPI_GET_ADDRESS (reg->address)) + offset);
+		pci_id.device  = ACPI_PCI_DEVICE (reg->address);
+		pci_id.function = ACPI_PCI_FUNCTION (reg->address);
+		pci_register   = (u16) ACPI_PCI_REGISTER (reg->address);
 
-		acpi_os_read_pci_configuration (&pci_id, pci_register, &value, width);
+		status = acpi_os_read_pci_configuration (&pci_id, pci_register,
+				 value, width);
 		break;
+
+
+	default:
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Unsupported address space: %X\n", reg->address_space_id));
+		return (AE_BAD_PARAMETER);
 	}
 
-	return value;
+	ACPI_DEBUG_PRINT ((ACPI_DB_IO, "Read:  %8.8X width %2d from %8.8X%8.8X (%s)\n",
+			*value, width,
+			ACPI_HIDWORD (reg->address),
+			ACPI_LODWORD (reg->address),
+			acpi_ut_get_region_name (reg->address_space_id)));
+
+	return (status);
 }
 
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_hw_low_level_write
+ * FUNCTION:    acpi_hw_low_level_write
  *
  * PARAMETERS:  Width               - 8, 16, or 32
  *              Value               - To be written
  *              Register            - GAS register structure
- *              Offset              - Offset from the base address in the GAS
  *
+ * RETURN:      Status
  *
- * RETURN:      Value read
- *
- * DESCRIPTION: Read from either memory, IO, or PCI config space.
+ * DESCRIPTION: Write to either memory, IO, or PCI config space.
  *
  ******************************************************************************/
 
-void
+acpi_status
 acpi_hw_low_level_write (
-	u32                     width,
-	u32                     value,
-	acpi_generic_address    *reg,
-	u32                     offset)
+	u32                             width,
+	u32                             value,
+	struct acpi_generic_address     *reg)
 {
-	ACPI_PHYSICAL_ADDRESS   mem_address;
-	ACPI_IO_ADDRESS         io_address;
-	acpi_pci_id             pci_id;
-	u16                     pci_register;
+	struct acpi_pci_id              pci_id;
+	u16                             pci_register;
+	acpi_status                     status;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_NAME ("hw_low_level_write");
 
 
 	/*
 	 * Must have a valid pointer to a GAS structure, and
-	 * a non-zero address within
+	 * a non-zero address within. However, don't return an error
+	 * because the PM1A/B code must not fail if B isn't present.
 	 */
 	if ((!reg) ||
-		(!ACPI_VALID_ADDRESS (reg->address))) {
-		return;
+		(!reg->address)) {
+		return (AE_OK);
 	}
-
-
 	/*
 	 * Three address spaces supported:
 	 * Memory, Io, or PCI config.
@@ -938,17 +815,16 @@ acpi_hw_low_level_write (
 	switch (reg->address_space_id) {
 	case ACPI_ADR_SPACE_SYSTEM_MEMORY:
 
-		mem_address = (ACPI_PHYSICAL_ADDRESS) (ACPI_GET_ADDRESS (reg->address) + offset);
-
-		acpi_os_write_memory (mem_address, value, width);
+		status = acpi_os_write_memory (
+				 (acpi_physical_address) reg->address,
+				 value, width);
 		break;
 
 
 	case ACPI_ADR_SPACE_SYSTEM_IO:
 
-		io_address = (ACPI_IO_ADDRESS) (ACPI_GET_ADDRESS (reg->address) + offset);
-
-		acpi_os_write_port (io_address, value, width);
+		status = acpi_os_write_port ((acpi_io_address) reg->address,
+				 value, width);
 		break;
 
 
@@ -956,11 +832,26 @@ acpi_hw_low_level_write (
 
 		pci_id.segment = 0;
 		pci_id.bus     = 0;
-		pci_id.device  = ACPI_PCI_DEVICE (ACPI_GET_ADDRESS (reg->address));
-		pci_id.function = ACPI_PCI_FUNCTION (ACPI_GET_ADDRESS (reg->address));
-		pci_register   = (u16) (ACPI_PCI_REGISTER (ACPI_GET_ADDRESS (reg->address)) + offset);
+		pci_id.device  = ACPI_PCI_DEVICE (reg->address);
+		pci_id.function = ACPI_PCI_FUNCTION (reg->address);
+		pci_register   = (u16) ACPI_PCI_REGISTER (reg->address);
 
-		acpi_os_write_pci_configuration (&pci_id, pci_register, value, width);
+		status = acpi_os_write_pci_configuration (&pci_id, pci_register,
+				 (acpi_integer) value, width);
 		break;
+
+
+	default:
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Unsupported address space: %X\n", reg->address_space_id));
+		return (AE_BAD_PARAMETER);
 	}
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_IO, "Wrote: %8.8X width %2d   to %8.8X%8.8X (%s)\n",
+			value, width,
+			ACPI_HIDWORD (reg->address),
+			ACPI_LODWORD (reg->address),
+			acpi_ut_get_region_name (reg->address_space_id)));
+
+	return (status);
 }
diff -urNp linux-5400/drivers/acpi/hardware/hwsleep.c linux-5410/drivers/acpi/hardware/hwsleep.c
--- linux-5400/drivers/acpi/hardware/hwsleep.c
+++ linux-5410/drivers/acpi/hardware/hwsleep.c
@@ -2,70 +2,82 @@
 /******************************************************************************
  *
  * Name: hwsleep.c - ACPI Hardware Sleep/Wake Interface
- *              $Revision: 22 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#include "acpi.h"
-#include "acnamesp.h"
-#include "achware.h"
+#include <acpi/acpi.h>
 
 #define _COMPONENT          ACPI_HARDWARE
-	 MODULE_NAME         ("hwsleep")
+	 ACPI_MODULE_NAME    ("hwsleep")
 
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_set_firmware_waking_vector
+ * FUNCTION:    acpi_set_firmware_waking_vector
  *
- * PARAMETERS:  Physical_address    - Physical address of ACPI real mode
+ * PARAMETERS:  physical_address    - Physical address of ACPI real mode
  *                                    entry point.
  *
- * RETURN:      AE_OK or AE_ERROR
+ * RETURN:      Status
  *
- * DESCRIPTION: Access function for d_firmware_waking_vector field in FACS
+ * DESCRIPTION: access function for d_firmware_waking_vector field in FACS
  *
  ******************************************************************************/
 
 acpi_status
 acpi_set_firmware_waking_vector (
-	ACPI_PHYSICAL_ADDRESS physical_address)
+	acpi_physical_address physical_address)
 {
 
-	FUNCTION_TRACE ("Acpi_set_firmware_waking_vector");
-
-
-	/* Make sure that we have an FACS */
+	ACPI_FUNCTION_TRACE ("acpi_set_firmware_waking_vector");
 
-	if (!acpi_gbl_FACS) {
-		return_ACPI_STATUS (AE_NO_ACPI_TABLES);
-	}
 
 	/* Set the vector */
 
-	if (acpi_gbl_FACS->vector_width == 32) {
-		* (u32 *) acpi_gbl_FACS->firmware_waking_vector = (u32) physical_address;
+	if (acpi_gbl_common_fACS.vector_width == 32) {
+		*(ACPI_CAST_PTR (u32, acpi_gbl_common_fACS.firmware_waking_vector))
+				= (u32) physical_address;
 	}
 	else {
-		*acpi_gbl_FACS->firmware_waking_vector = physical_address;
+		*acpi_gbl_common_fACS.firmware_waking_vector
+				= physical_address;
 	}
 
 	return_ACPI_STATUS (AE_OK);
@@ -74,167 +86,300 @@ acpi_set_firmware_waking_vector (
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_get_firmware_waking_vector
+ * FUNCTION:    acpi_get_firmware_waking_vector
  *
- * PARAMETERS:  *Physical_address   - Output buffer where contents of
- *                                    the Firmware_waking_vector field of
+ * PARAMETERS:  *physical_address   - Output buffer where contents of
+ *                                    the firmware_waking_vector field of
  *                                    the FACS will be stored.
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Access function for d_firmware_waking_vector field in FACS
+ * DESCRIPTION: Access function for firmware_waking_vector field in FACS
  *
  ******************************************************************************/
 
 acpi_status
 acpi_get_firmware_waking_vector (
-	ACPI_PHYSICAL_ADDRESS *physical_address)
+	acpi_physical_address *physical_address)
 {
 
-	FUNCTION_TRACE ("Acpi_get_firmware_waking_vector");
+	ACPI_FUNCTION_TRACE ("acpi_get_firmware_waking_vector");
 
 
 	if (!physical_address) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	/* Make sure that we have an FACS */
-
-	if (!acpi_gbl_FACS) {
-		return_ACPI_STATUS (AE_NO_ACPI_TABLES);
-	}
-
 	/* Get the vector */
 
-	if (acpi_gbl_FACS->vector_width == 32) {
-		*physical_address = * (u32 *) acpi_gbl_FACS->firmware_waking_vector;
+	if (acpi_gbl_common_fACS.vector_width == 32) {
+		*physical_address = (acpi_physical_address)
+			*(ACPI_CAST_PTR (u32, acpi_gbl_common_fACS.firmware_waking_vector));
 	}
 	else {
-		*physical_address = *acpi_gbl_FACS->firmware_waking_vector;
+		*physical_address =
+			*acpi_gbl_common_fACS.firmware_waking_vector;
 	}
 
 	return_ACPI_STATUS (AE_OK);
 }
 
+
 /******************************************************************************
  *
- * FUNCTION:    Acpi_enter_sleep_state
+ * FUNCTION:    acpi_enter_sleep_state_prep
  *
- * PARAMETERS:  Sleep_state         - Which sleep state to enter
+ * PARAMETERS:  sleep_state         - Which sleep state to enter
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Enter a system sleep state (see ACPI 2.0 spec p 231)
+ * DESCRIPTION: Prepare to enter a system sleep state (see ACPI 2.0 spec p 231)
+ *              This function must execute with interrupts enabled.
+ *              We break sleeping into 2 stages so that OSPM can handle
+ *              various OS-specific tasks between the two steps.
  *
  ******************************************************************************/
 
 acpi_status
-acpi_enter_sleep_state (
-	u8                  sleep_state)
+acpi_enter_sleep_state_prep (
+	u8                          sleep_state)
 {
-	acpi_status         status;
-	acpi_object_list    arg_list;
-	acpi_object         arg;
-	u8                  type_a;
-	u8                  type_b;
-	u16                 PM1Acontrol;
-	u16                 PM1Bcontrol;
+	acpi_status                 status;
+	struct acpi_object_list     arg_list;
+	union acpi_object           arg;
 
 
-	FUNCTION_TRACE ("Acpi_enter_sleep_state");
+	ACPI_FUNCTION_TRACE ("acpi_enter_sleep_state_prep");
 
 
 	/*
 	 * _PSW methods could be run here to enable wake-on keyboard, LAN, etc.
 	 */
-	status = acpi_hw_obtain_sleep_type_register_data (sleep_state, &type_a, &type_b);
-	if (!ACPI_SUCCESS (status)) {
-		return status;
+	status = acpi_get_sleep_type_data (sleep_state,
+			  &acpi_gbl_sleep_type_a, &acpi_gbl_sleep_type_b);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
 	}
 
-	/* run the _PTS and _GTS methods */
+	/* Setup parameter object */
 
-	MEMSET(&arg_list, 0, sizeof(arg_list));
 	arg_list.count = 1;
 	arg_list.pointer = &arg;
 
-	MEMSET(&arg, 0, sizeof(arg));
 	arg.type = ACPI_TYPE_INTEGER;
 	arg.integer.value = sleep_state;
 
-	acpi_evaluate_object (NULL, "\\_PTS", &arg_list, NULL);
-	acpi_evaluate_object (NULL, "\\_GTS", &arg_list, NULL);
+	/* Run the _PTS and _GTS methods */
 
-	/* clear wake status */
+	status = acpi_evaluate_object (NULL, "\\_PTS", &arg_list, NULL);
+	if (ACPI_FAILURE (status) && status != AE_NOT_FOUND) {
+		return_ACPI_STATUS (status);
+	}
 
-	acpi_hw_register_bit_access (ACPI_WRITE, ACPI_MTX_LOCK, WAK_STS, 1);
+	status = acpi_evaluate_object (NULL, "\\_GTS", &arg_list, NULL);
+	if (ACPI_FAILURE (status) && status != AE_NOT_FOUND) {
+		return_ACPI_STATUS (status);
+	}
 
-	disable ();
+	return_ACPI_STATUS (AE_OK);
+}
 
-	acpi_hw_disable_non_wakeup_gpes();
 
-	PM1Acontrol = (u16) acpi_hw_register_read (ACPI_MTX_LOCK, PM1_CONTROL);
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_enter_sleep_state
+ *
+ * PARAMETERS:  sleep_state         - Which sleep state to enter
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Enter a system sleep state (see ACPI 2.0 spec p 231)
+ *              THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED
+ *
+ ******************************************************************************/
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_OK, "Entering S%d\n", sleep_state));
+acpi_status
+acpi_enter_sleep_state (
+	u8                              sleep_state)
+{
+	u32                             PM1Acontrol;
+	u32                             PM1Bcontrol;
+	struct acpi_bit_register_info   *sleep_type_reg_info;
+	struct acpi_bit_register_info   *sleep_enable_reg_info;
+	u32                             in_value;
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE ("acpi_enter_sleep_state");
+
+
+	if ((acpi_gbl_sleep_type_a > ACPI_SLEEP_TYPE_MAX) ||
+		(acpi_gbl_sleep_type_b > ACPI_SLEEP_TYPE_MAX)) {
+		ACPI_REPORT_ERROR (("Sleep values out of range: A=%X B=%X\n",
+			acpi_gbl_sleep_type_a, acpi_gbl_sleep_type_b));
+		return_ACPI_STATUS (AE_AML_OPERAND_VALUE);
+	}
+
+
+	sleep_type_reg_info = acpi_hw_get_bit_register_info (ACPI_BITREG_SLEEP_TYPE_A);
+	sleep_enable_reg_info = acpi_hw_get_bit_register_info (ACPI_BITREG_SLEEP_ENABLE);
+
+	/* Clear wake status */
+
+	status = acpi_set_register (ACPI_BITREG_WAKE_STATUS, 1, ACPI_MTX_DO_NOT_LOCK);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	status = acpi_hw_clear_acpi_status(ACPI_MTX_DO_NOT_LOCK);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/* Disable BM arbitration */
+
+	status = acpi_set_register (ACPI_BITREG_ARB_DISABLE, 1, ACPI_MTX_DO_NOT_LOCK);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	status = acpi_hw_disable_non_wakeup_gpes();
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/* Get current value of PM1A control */
+
+	status = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_CONTROL, &PM1Acontrol);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+	ACPI_DEBUG_PRINT ((ACPI_DB_INIT, "Entering sleep state [S%d]\n", sleep_state));
 
-	/* mask off SLP_EN and SLP_TYP fields */
+	/* Clear SLP_EN and SLP_TYP fields */
 
-	PM1Acontrol &= ~(SLP_TYPE_X_MASK | SLP_EN_MASK);
+	PM1Acontrol &= ~(sleep_type_reg_info->access_bit_mask | sleep_enable_reg_info->access_bit_mask);
 	PM1Bcontrol = PM1Acontrol;
 
-	/* mask in SLP_TYP */
+	/* Insert SLP_TYP bits */
 
-	PM1Acontrol |= (type_a << acpi_hw_get_bit_shift (SLP_TYPE_X_MASK));
-	PM1Bcontrol |= (type_b << acpi_hw_get_bit_shift (SLP_TYPE_X_MASK));
+	PM1Acontrol |= (acpi_gbl_sleep_type_a << sleep_type_reg_info->bit_position);
+	PM1Bcontrol |= (acpi_gbl_sleep_type_b << sleep_type_reg_info->bit_position);
 
-	/* write #1: fill in SLP_TYP data */
+	/* Write #1: fill in SLP_TYP data */
 
-	acpi_hw_register_write (ACPI_MTX_LOCK, PM1A_CONTROL, PM1Acontrol);
-	acpi_hw_register_write (ACPI_MTX_LOCK, PM1B_CONTROL, PM1Bcontrol);
+	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1A_CONTROL, PM1Acontrol);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1B_CONTROL, PM1Bcontrol);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
-	/* mask in SLP_EN */
+	/* Insert SLP_ENABLE bit */
 
-	PM1Acontrol |= (1 << acpi_hw_get_bit_shift (SLP_EN_MASK));
-	PM1Bcontrol |= (1 << acpi_hw_get_bit_shift (SLP_EN_MASK));
+	PM1Acontrol |= sleep_enable_reg_info->access_bit_mask;
+	PM1Bcontrol |= sleep_enable_reg_info->access_bit_mask;
 
-	/* flush caches */
+	/* Write #2: SLP_TYP + SLP_EN */
 
-	wbinvd();
+	ACPI_FLUSH_CPU_CACHE ();
 
-	/* write #2: SLP_TYP + SLP_EN */
+	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1A_CONTROL, PM1Acontrol);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
-	acpi_hw_register_write (ACPI_MTX_LOCK, PM1A_CONTROL, PM1Acontrol);
-	acpi_hw_register_write (ACPI_MTX_LOCK, PM1B_CONTROL, PM1Bcontrol);
+	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1B_CONTROL, PM1Bcontrol);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	/*
 	 * Wait a second, then try again. This is to get S4/5 to work on all machines.
 	 */
 	if (sleep_state > ACPI_STATE_S3) {
-		acpi_os_stall(1000000);
-
-		acpi_hw_register_write (ACPI_MTX_LOCK, PM1_CONTROL,
-			(1 << acpi_hw_get_bit_shift (SLP_EN_MASK)));
+		/*
+		 * We wait so long to allow chipsets that poll this reg very slowly to
+		 * still read the right value. Ideally, this entire block would go
+		 * away entirely.
+		 */
+		acpi_os_stall (10000000);
+
+		status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_CONTROL,
+				 sleep_enable_reg_info->access_bit_mask);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
 	}
 
-	/* wait until we enter sleep state */
+	/* Wait until we enter sleep state */
 
 	do {
-		acpi_os_stall(10000);
-	}
-	while (!acpi_hw_register_bit_access (ACPI_READ, ACPI_MTX_LOCK, WAK_STS));
+		status = acpi_get_register (ACPI_BITREG_WAKE_STATUS, &in_value, ACPI_MTX_DO_NOT_LOCK);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
 
-	acpi_hw_enable_non_wakeup_gpes();
+		/* Spin until we wake */
 
-	enable ();
+	} while (!in_value);
 
 	return_ACPI_STATUS (AE_OK);
 }
 
+
 /******************************************************************************
  *
- * FUNCTION:    Acpi_leave_sleep_state
+ * FUNCTION:    acpi_enter_sleep_state_s4bios
  *
- * PARAMETERS:  Sleep_state         - Which sleep state we just exited
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Perform a S4 bios request.
+ *              THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_enter_sleep_state_s4bios (
+	void)
+{
+	u32                             in_value;
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE ("acpi_enter_sleep_state_s4bios");
+
+	acpi_set_register (ACPI_BITREG_WAKE_STATUS, 1, ACPI_MTX_DO_NOT_LOCK);
+	acpi_hw_clear_acpi_status(ACPI_MTX_DO_NOT_LOCK);
+
+	acpi_hw_disable_non_wakeup_gpes();
+
+	ACPI_FLUSH_CPU_CACHE();
+
+	status = acpi_os_write_port (acpi_gbl_FADT->smi_cmd, (u32) acpi_gbl_FADT->S4bios_req, 8);
+
+	do {
+		acpi_os_stall(1000);
+		status = acpi_get_register (ACPI_BITREG_WAKE_STATUS, &in_value, ACPI_MTX_DO_NOT_LOCK);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
+	} while (!in_value);
+
+	return_ACPI_STATUS (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_leave_sleep_state
+ *
+ * PARAMETERS:  sleep_state         - Which sleep state we just exited
  *
  * RETURN:      Status
  *
@@ -244,29 +389,49 @@ acpi_enter_sleep_state (
 
 acpi_status
 acpi_leave_sleep_state (
-	u8                  sleep_state)
+	u8                          sleep_state)
 {
-	acpi_object_list    arg_list;
-	acpi_object         arg;
+	struct acpi_object_list     arg_list;
+	union acpi_object           arg;
+	acpi_status                 status;
 
 
-	FUNCTION_TRACE ("Acpi_leave_sleep_state");
+	ACPI_FUNCTION_TRACE ("acpi_leave_sleep_state");
 
 
-	MEMSET (&arg_list, 0, sizeof(arg_list));
+	/* Ensure enter_sleep_state_prep -> enter_sleep_state ordering */
+
+	acpi_gbl_sleep_type_a = ACPI_SLEEP_TYPE_INVALID;
+
+	/* Setup parameter object */
+
 	arg_list.count = 1;
 	arg_list.pointer = &arg;
 
-	MEMSET (&arg, 0, sizeof(arg));
 	arg.type = ACPI_TYPE_INTEGER;
 	arg.integer.value = sleep_state;
 
-	acpi_evaluate_object (NULL, "\\_BFS", &arg_list, NULL);
-	acpi_evaluate_object (NULL, "\\_WAK", &arg_list, NULL);
+	/* Ignore any errors from these methods */
+
+	status = acpi_evaluate_object (NULL, "\\_BFS", &arg_list, NULL);
+	if (ACPI_FAILURE (status) && status != AE_NOT_FOUND) {
+		ACPI_REPORT_ERROR (("Method _BFS failed, %s\n", acpi_format_exception (status)));
+	}
+
+	status = acpi_evaluate_object (NULL, "\\_WAK", &arg_list, NULL);
+	if (ACPI_FAILURE (status) && status != AE_NOT_FOUND) {
+		ACPI_REPORT_ERROR (("Method _WAK failed, %s\n", acpi_format_exception (status)));
+	}
 
 	/* _WAK returns stuff - do we want to look at it? */
 
-	acpi_hw_enable_non_wakeup_gpes();
+	status = acpi_hw_enable_non_wakeup_gpes();
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
-	return_ACPI_STATUS (AE_OK);
+	/* Disable BM arbitration */
+	status = acpi_set_register (ACPI_BITREG_ARB_DISABLE, 0, ACPI_MTX_LOCK);
+
+	return_ACPI_STATUS (status);
 }
diff -urNp linux-5400/drivers/acpi/hardware/hwtimer.c linux-5410/drivers/acpi/hardware/hwtimer.c
--- linux-5400/drivers/acpi/hardware/hwtimer.c
+++ linux-5410/drivers/acpi/hardware/hwtimer.c
@@ -2,38 +2,55 @@
 /******************************************************************************
  *
  * Name: hwtimer.c - ACPI Power Management Timer Interface
- *              $Revision: 14 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#include "acpi.h"
-#include "achware.h"
+#include <acpi/acpi.h>
 
 #define _COMPONENT          ACPI_HARDWARE
-	 MODULE_NAME         ("hwtimer")
+	 ACPI_MODULE_NAME    ("hwtimer")
 
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_get_timer_resolution
+ * FUNCTION:    acpi_get_timer_resolution
  *
  * PARAMETERS:  none
  *
@@ -45,9 +62,9 @@
 
 acpi_status
 acpi_get_timer_resolution (
-	u32                     *resolution)
+	u32                             *resolution)
 {
-	FUNCTION_TRACE ("Acpi_get_timer_resolution");
+	ACPI_FUNCTION_TRACE ("acpi_get_timer_resolution");
 
 
 	if (!resolution) {
@@ -57,7 +74,6 @@ acpi_get_timer_resolution (
 	if (0 == acpi_gbl_FADT->tmr_val_ext) {
 		*resolution = 24;
 	}
-
 	else {
 		*resolution = 32;
 	}
@@ -68,7 +84,7 @@ acpi_get_timer_resolution (
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_get_timer
+ * FUNCTION:    acpi_get_timer
  *
  * PARAMETERS:  none
  *
@@ -80,31 +96,33 @@ acpi_get_timer_resolution (
 
 acpi_status
 acpi_get_timer (
-	u32                     *ticks)
+	u32                             *ticks)
 {
-	FUNCTION_TRACE ("Acpi_get_timer");
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE ("acpi_get_timer");
 
 
 	if (!ticks) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	acpi_os_read_port ((ACPI_IO_ADDRESS)
-		ACPI_GET_ADDRESS (acpi_gbl_FADT->Xpm_tmr_blk.address), ticks, 32);
+	status = acpi_hw_low_level_read (32, ticks, &acpi_gbl_FADT->xpm_tmr_blk);
 
-	return_ACPI_STATUS (AE_OK);
+	return_ACPI_STATUS (status);
 }
 
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_get_timer_duration
+ * FUNCTION:    acpi_get_timer_duration
  *
- * PARAMETERS:  Start_ticks
- *              End_ticks
- *              Time_elapsed
+ * PARAMETERS:  start_ticks
+ *              end_ticks
+ *              time_elapsed
  *
- * RETURN:      Time_elapsed
+ * RETURN:      time_elapsed
  *
  * DESCRIPTION: Computes the time elapsed (in microseconds) between two
  *              PM Timer time stamps, taking into account the possibility of
@@ -115,27 +133,29 @@ acpi_get_timer (
  *              transitions (unlike many CPU timestamp counters) -- making it
  *              a versatile and accurate timer.
  *
- *              Note that this function accomodates only a single timer
+ *              Note that this function accommodates only a single timer
  *              rollover.  Thus for 24-bit timers, this function should only
  *              be used for calculating durations less than ~4.6 seconds
- *              (~20 hours for 32-bit timers).
+ *              (~20 minutes for 32-bit timers) -- calculations below
+ *
+ *              2**24 Ticks / 3,600,000 Ticks/Sec = 4.66 sec
+ *              2**32 Ticks / 3,600,000 Ticks/Sec = 1193 sec or 19.88 minutes
  *
  ******************************************************************************/
 
 acpi_status
 acpi_get_timer_duration (
-	u32                     start_ticks,
-	u32                     end_ticks,
-	u32                     *time_elapsed)
+	u32                             start_ticks,
+	u32                             end_ticks,
+	u32                             *time_elapsed)
 {
-	u32                     delta_ticks = 0;
-	u32                     seconds = 0;
-	u32                     milliseconds = 0;
-	u32                     microseconds = 0;
-	u32                     remainder = 0;
+	u32                             delta_ticks = 0;
+	union uint64_overlay            normalized_ticks;
+	acpi_status                     status;
+	acpi_integer                    out_quotient;
 
 
-	FUNCTION_TRACE ("Acpi_get_timer_duration");
+	ACPI_FUNCTION_TRACE ("acpi_get_timer_duration");
 
 
 	if (!time_elapsed) {
@@ -150,21 +170,18 @@ acpi_get_timer_duration (
 	if (start_ticks < end_ticks) {
 		delta_ticks = end_ticks - start_ticks;
 	}
-
 	else if (start_ticks > end_ticks) {
-		/* 24-bit Timer */
-
 		if (0 == acpi_gbl_FADT->tmr_val_ext) {
+			/* 24-bit Timer */
+
 			delta_ticks = (((0x00FFFFFF - start_ticks) + end_ticks) & 0x00FFFFFF);
 		}
-
-		/* 32-bit Timer */
-
 		else {
+			/* 32-bit Timer */
+
 			delta_ticks = (0xFFFFFFFF - start_ticks) + end_ticks;
 		}
 	}
-
 	else {
 		*time_elapsed = 0;
 		return_ACPI_STATUS (AE_OK);
@@ -173,49 +190,18 @@ acpi_get_timer_duration (
 	/*
 	 * Compute Duration:
 	 * -----------------
-	 * Since certain compilers (gcc/Linux, argh!) don't support 64-bit
-	 * divides in kernel-space we have to do some trickery to preserve
-	 * accuracy while using 32-bit math.
-	 *
-	 * TBD: Change to use 64-bit math when supported.
 	 *
-	 * The process is as follows:
-	 *  1. Compute the number of seconds by dividing Delta Ticks by
-	 *     the timer frequency.
-	 *  2. Compute the number of milliseconds in the remainder from step #1
-	 *     by multiplying by 1000 and then dividing by the timer frequency.
-	 *  3. Compute the number of microseconds in the remainder from step #2
-	 *     by multiplying by 1000 and then dividing by the timer frequency.
-	 *  4. Add the results from steps 1, 2, and 3 to get the total duration.
+	 * Requires a 64-bit divide:
 	 *
-	 * Example: The time elapsed for Delta_ticks = 0xFFFFFFFF should be
-	 *          1199864031 microseconds.  This is computed as follows:
-	 *          Step #1: Seconds = 1199; Remainder = 3092840
-	 *          Step #2: Milliseconds = 864; Remainder = 113120
-	 *          Step #3: Microseconds = 31; Remainder = <don't care!>
+	 * time_elapsed = (delta_ticks * 1000000) / PM_TIMER_FREQUENCY;
 	 */
+	normalized_ticks.full = ((u64) delta_ticks) * 1000000;
 
-	/* Step #1 */
-
-	seconds = delta_ticks / PM_TIMER_FREQUENCY;
-	remainder = delta_ticks % PM_TIMER_FREQUENCY;
-
-	/* Step #2 */
-
-	milliseconds = (remainder * 1000) / PM_TIMER_FREQUENCY;
-	remainder = (remainder * 1000) % PM_TIMER_FREQUENCY;
+	status = acpi_ut_short_divide (&normalized_ticks.full, PM_TIMER_FREQUENCY,
+			   &out_quotient, NULL);
 
-	/* Step #3 */
-
-	microseconds = (remainder * 1000) / PM_TIMER_FREQUENCY;
-
-	/* Step #4 */
-
-	*time_elapsed = seconds * 1000000;
-	*time_elapsed += milliseconds * 1000;
-	*time_elapsed += microseconds;
-
-	return_ACPI_STATUS (AE_OK);
+	*time_elapsed = (u32) out_quotient;
+	return_ACPI_STATUS (status);
 }
 
 
diff -urNp linux-5400/drivers/acpi/include/acconfig.h linux-5410/drivers/acpi/include/acconfig.h
--- linux-5400/drivers/acpi/include/acconfig.h
+++ linux-5410/drivers/acpi/include/acconfig.h
@@ -1,162 +0,0 @@
-/******************************************************************************
- *
- * Name: acconfig.h - Global configuration constants
- *       $Revision: 74 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _ACCONFIG_H
-#define _ACCONFIG_H
-
-
-/******************************************************************************
- *
- * Compile-time options
- *
- *****************************************************************************/
-
-/*
- * ACPI_DEBUG           - This switch enables all the debug facilities of the ACPI
- *                          subsystem.  This includes the DEBUG_PRINT output statements
- *                          When disabled, all DEBUG_PRINT statements are compiled out.
- *
- * ACPI_APPLICATION     - Use this switch if the subsystem is going to be run
- *                          at the application level.
- *
- */
-
-
-/******************************************************************************
- *
- * Subsystem Constants
- *
- *****************************************************************************/
-
-
-/* Version string */
-
-#define ACPI_CA_VERSION             0x20011018
-
-/* Version of ACPI supported */
-
-#define ACPI_CA_SUPPORT_LEVEL       2
-
-
-/* Maximum objects in the various object caches */
-
-#define MAX_STATE_CACHE_DEPTH       64         /* State objects for stacks */
-#define MAX_PARSE_CACHE_DEPTH       96          /* Parse tree objects */
-#define MAX_EXTPARSE_CACHE_DEPTH    64          /* Parse tree objects */
-#define MAX_OBJECT_CACHE_DEPTH      64          /* Interpreter operand objects */
-#define MAX_WALK_CACHE_DEPTH        4           /* Objects for parse tree walks (method execution) */
-
-
-/* String size constants */
-
-#define MAX_STRING_LENGTH           512
-#define PATHNAME_MAX                256     /* A full namespace pathname */
-
-
-/* Maximum count for a semaphore object */
-
-#define MAX_SEMAPHORE_COUNT         256
-
-
-/* Max reference count (for debug only) */
-
-#define MAX_REFERENCE_COUNT         0x400
-
-
-/* Size of cached memory mapping for system memory operation region */
-
-#define SYSMEM_REGION_WINDOW_SIZE   4096
-
-
-/*
- * Debugger threading model
- * Use single threaded if the entire subsystem is contained in an application
- * Use multiple threaded when the subsystem is running in the kernel.
- *
- * By default the model is single threaded if ACPI_APPLICATION is set,
- * multi-threaded if ACPI_APPLICATION is not set.
- */
-
-#define DEBUGGER_SINGLE_THREADED    0
-#define DEBUGGER_MULTI_THREADED     1
-
-#ifdef ACPI_APPLICATION
-#define DEBUGGER_THREADING          DEBUGGER_SINGLE_THREADED
-
-#else
-#define DEBUGGER_THREADING          DEBUGGER_MULTI_THREADED
-#endif
-
-
-/******************************************************************************
- *
- * ACPI Specification constants (Do not change unless the specification changes)
- *
- *****************************************************************************/
-
-/*
- * Method info (in WALK_STATE), containing local variables and argumetns
- */
-
-#define MTH_NUM_LOCALS              8
-#define MTH_MAX_LOCAL               7
-
-#define MTH_NUM_ARGS                7
-#define MTH_MAX_ARG                 6
-
-/* Maximum length of resulting string when converting from a buffer */
-
-#define ACPI_MAX_STRING_CONVERSION  200
-
-/*
- * Operand Stack (in WALK_STATE), Must be large enough to contain MTH_MAX_ARG
- */
-
-#define OBJ_NUM_OPERANDS            8
-#define OBJ_MAX_OPERAND             7
-
-/* Names within the namespace are 4 bytes long */
-
-#define ACPI_NAME_SIZE              4
-#define PATH_SEGMENT_LENGTH         5           /* 4 chars for name + 1 s8 for separator */
-#define PATH_SEPARATOR              '.'
-
-
-/* Constants used in searching for the RSDP in low memory */
-
-#define LO_RSDP_WINDOW_BASE         0           /* Physical Address */
-#define HI_RSDP_WINDOW_BASE         0xE0000     /* Physical Address */
-#define LO_RSDP_WINDOW_SIZE         0x400
-#define HI_RSDP_WINDOW_SIZE         0x20000
-#define RSDP_SCAN_STEP              16
-
-/* Maximum Space_ids for Operation Regions */
-
-#define ACPI_MAX_ADDRESS_SPACE      255
-#define ACPI_NUM_ADDRESS_SPACES     256
-
-
-#endif /* _ACCONFIG_H */
-
diff -urNp linux-5400/drivers/acpi/include/acdebug.h linux-5410/drivers/acpi/include/acdebug.h
--- linux-5400/drivers/acpi/include/acdebug.h
+++ linux-5410/drivers/acpi/include/acdebug.h
@@ -1,410 +0,0 @@
-/******************************************************************************
- *
- * Name: acdebug.h - ACPI/AML debugger
- *       $Revision: 50 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACDEBUG_H__
-#define __ACDEBUG_H__
-
-
-#define DB_MAX_ARGS             8  /* Must be max method args + 1 */
-
-#define DB_COMMAND_PROMPT      '-'
-#define DB_EXECUTE_PROMPT      '%'
-
-
-extern int                      optind;
-extern NATIVE_CHAR              *optarg;
-extern u8                       *aml_start;
-extern u32                      aml_length;
-
-extern u8                       acpi_gbl_db_opt_tables;
-extern u8                       acpi_gbl_db_opt_disasm;
-extern u8                       acpi_gbl_db_opt_stats;
-extern u8                       acpi_gbl_db_opt_parse_jit;
-extern u8                       acpi_gbl_db_opt_verbose;
-extern u8                       acpi_gbl_db_opt_ini_methods;
-
-
-extern NATIVE_CHAR              *acpi_gbl_db_args[DB_MAX_ARGS];
-extern NATIVE_CHAR              acpi_gbl_db_line_buf[80];
-extern NATIVE_CHAR              acpi_gbl_db_scope_buf[40];
-extern NATIVE_CHAR              acpi_gbl_db_debug_filename[40];
-extern u8                       acpi_gbl_db_output_to_file;
-extern NATIVE_CHAR              *acpi_gbl_db_buffer;
-extern NATIVE_CHAR              *acpi_gbl_db_filename;
-extern NATIVE_CHAR              *acpi_gbl_db_disasm_indent;
-extern u8                       acpi_gbl_db_output_flags;
-extern u32                      acpi_gbl_db_debug_level;
-extern u32                      acpi_gbl_db_console_debug_level;
-extern acpi_table_header        *acpi_gbl_db_table_ptr;
-
-/*
- * Statistic globals
- */
-extern u16                      acpi_gbl_obj_type_count[INTERNAL_TYPE_NODE_MAX+1];
-extern u16                      acpi_gbl_node_type_count[INTERNAL_TYPE_NODE_MAX+1];
-extern u16                      acpi_gbl_obj_type_count_misc;
-extern u16                      acpi_gbl_node_type_count_misc;
-extern u32                      acpi_gbl_num_nodes;
-extern u32                      acpi_gbl_num_objects;
-
-
-extern u32                      acpi_gbl_size_of_parse_tree;
-extern u32                      acpi_gbl_size_of_method_trees;
-extern u32                      acpi_gbl_size_of_node_entries;
-extern u32                      acpi_gbl_size_of_acpi_objects;
-
-
-#define ACPI_DEBUG_BUFFER_SIZE  4196
-
-#define DB_REDIRECTABLE_OUTPUT  0x01
-#define DB_CONSOLE_OUTPUT       0x02
-#define DB_DUPLICATE_OUTPUT     0x03
-
-
-typedef struct command_info
-{
-	NATIVE_CHAR             *name;          /* Command Name */
-	u8                      min_args;       /* Minimum arguments required */
-
-} COMMAND_INFO;
-
-
-typedef struct argument_info
-{
-	NATIVE_CHAR             *name;          /* Argument Name */
-
-} ARGUMENT_INFO;
-
-
-#define PARAM_LIST(pl)                  pl
-
-#define DBTEST_OUTPUT_LEVEL(lvl)        if (acpi_gbl_db_opt_verbose)
-
-#define VERBOSE_PRINT(fp)               DBTEST_OUTPUT_LEVEL(lvl) {\
-			  acpi_os_printf PARAM_LIST(fp);}
-
-#define EX_NO_SINGLE_STEP       1
-#define EX_SINGLE_STEP          2
-
-
-/* Prototypes */
-
-
-/*
- * dbapi - external debugger interfaces
- */
-
-int
-acpi_db_initialize (
-	void);
-
-void
-acpi_db_terminate (
-	void);
-
-acpi_status
-acpi_db_single_step (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op,
-	u32                     op_type);
-
-
-/*
- * dbcmds - debug commands and output routines
- */
-
-
-void
-acpi_db_display_table_info (
-	NATIVE_CHAR             *table_arg);
-
-void
-acpi_db_unload_acpi_table (
-	NATIVE_CHAR             *table_arg,
-	NATIVE_CHAR             *instance_arg);
-
-void
-acpi_db_set_method_breakpoint (
-	NATIVE_CHAR             *location,
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op);
-
-void
-acpi_db_set_method_call_breakpoint (
-	acpi_parse_object       *op);
-
-void
-acpi_db_disassemble_aml (
-	NATIVE_CHAR             *statements,
-	acpi_parse_object       *op);
-
-void
-acpi_db_dump_namespace (
-	NATIVE_CHAR             *start_arg,
-	NATIVE_CHAR             *depth_arg);
-
-void
-acpi_db_dump_namespace_by_owner (
-	NATIVE_CHAR             *owner_arg,
-	NATIVE_CHAR             *depth_arg);
-
-void
-acpi_db_send_notify (
-	NATIVE_CHAR             *name,
-	u32                     value);
-
-void
-acpi_db_set_method_data (
-	NATIVE_CHAR             *type_arg,
-	NATIVE_CHAR             *index_arg,
-	NATIVE_CHAR             *value_arg);
-
-acpi_status
-acpi_db_display_objects (
-	NATIVE_CHAR             *obj_type_arg,
-	NATIVE_CHAR             *display_count_arg);
-
-acpi_status
-acpi_db_find_name_in_namespace (
-	NATIVE_CHAR             *name_arg);
-
-void
-acpi_db_set_scope (
-	NATIVE_CHAR             *name);
-
-void
-acpi_db_find_references (
-	NATIVE_CHAR             *object_arg);
-
-void
-acpi_db_display_locks (void);
-
-
-void
-acpi_db_display_resources (
-	NATIVE_CHAR             *object_arg);
-
-
-/*
- * dbdisasm - AML disassembler
- */
-
-void
-acpi_db_display_op (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *origin,
-	u32                     num_opcodes);
-
-void
-acpi_db_display_namestring (
-	NATIVE_CHAR             *name);
-
-void
-acpi_db_display_path (
-	acpi_parse_object       *op);
-
-void
-acpi_db_display_opcode (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op);
-
-void
-acpi_db_decode_internal_object (
-	acpi_operand_object     *obj_desc);
-
-
-/*
- * dbdisply - debug display commands
- */
-
-
-void
-acpi_db_display_method_info (
-	acpi_parse_object       *op);
-
-void
-acpi_db_decode_and_display_object (
-	NATIVE_CHAR             *target,
-	NATIVE_CHAR             *output_type);
-
-void
-acpi_db_display_result_object (
-	acpi_operand_object     *obj_desc,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_db_display_all_methods (
-	NATIVE_CHAR             *display_count_arg);
-
-void
-acpi_db_display_internal_object (
-	acpi_operand_object     *obj_desc,
-	acpi_walk_state         *walk_state);
-
-void
-acpi_db_display_arguments (
-	void);
-
-void
-acpi_db_display_locals (
-	void);
-
-void
-acpi_db_display_results (
-	void);
-
-void
-acpi_db_display_calling_tree (
-	void);
-
-void
-acpi_db_display_argument_object (
-	acpi_operand_object     *obj_desc,
-	acpi_walk_state         *walk_state);
-
-
-/*
- * dbexec - debugger control method execution
- */
-
-void
-acpi_db_execute (
-	NATIVE_CHAR             *name,
-	NATIVE_CHAR             **args,
-	u32                     flags);
-
-void
-acpi_db_create_execution_threads (
-	NATIVE_CHAR             *num_threads_arg,
-	NATIVE_CHAR             *num_loops_arg,
-	NATIVE_CHAR             *method_name_arg);
-
-
-/*
- * dbfileio - Debugger file I/O commands
- */
-
-acpi_object_type8
-acpi_db_match_argument (
-	NATIVE_CHAR             *user_argument,
-	ARGUMENT_INFO           *arguments);
-
-
-void
-acpi_db_close_debug_file (
-	void);
-
-void
-acpi_db_open_debug_file (
-	NATIVE_CHAR             *name);
-
-acpi_status
-acpi_db_load_acpi_table (
-	NATIVE_CHAR             *filename);
-
-
-/*
- * dbhistry - debugger HISTORY command
- */
-
-void
-acpi_db_add_to_history (
-	NATIVE_CHAR             *command_line);
-
-void
-acpi_db_display_history (void);
-
-NATIVE_CHAR *
-acpi_db_get_from_history (
-	NATIVE_CHAR             *command_num_arg);
-
-
-/*
- * dbinput - user front-end to the AML debugger
- */
-
-acpi_status
-acpi_db_command_dispatch (
-	NATIVE_CHAR             *input_buffer,
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op);
-
-void
-acpi_db_execute_thread (
-	void                    *context);
-
-acpi_status
-acpi_db_user_commands (
-	NATIVE_CHAR             prompt,
-	acpi_parse_object       *op);
-
-
-/*
- * dbstats - Generation and display of ACPI table statistics
- */
-
-void
-acpi_db_generate_statistics (
-	acpi_parse_object       *root,
-	u8                      is_method);
-
-
-acpi_status
-acpi_db_display_statistics (
-	NATIVE_CHAR             *type_arg);
-
-
-/*
- * dbutils - AML debugger utilities
- */
-
-void
-acpi_db_set_output_destination (
-	u32                     where);
-
-void
-acpi_db_dump_buffer (
-	u32                     address);
-
-void
-acpi_db_dump_object (
-	acpi_object             *obj_desc,
-	u32                     level);
-
-void
-acpi_db_prep_namestring (
-	NATIVE_CHAR             *name);
-
-
-acpi_status
-acpi_db_second_pass_parse (
-	acpi_parse_object       *root);
-
-acpi_namespace_node *
-acpi_db_local_ns_lookup (
-	NATIVE_CHAR             *name);
-
-
-#endif  /* __ACDEBUG_H__ */
diff -urNp linux-5400/drivers/acpi/include/acdispat.h linux-5410/drivers/acpi/include/acdispat.h
--- linux-5400/drivers/acpi/include/acdispat.h
+++ linux-5410/drivers/acpi/include/acdispat.h
@@ -1,453 +0,0 @@
-/******************************************************************************
- *
- * Name: acdispat.h - dispatcher (parser to interpreter interface)
- *       $Revision: 45 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#ifndef _ACDISPAT_H_
-#define _ACDISPAT_H_
-
-
-#define NAMEOF_LOCAL_NTE    "__L0"
-#define NAMEOF_ARG_NTE      "__A0"
-
-
-/* Common interfaces */
-
-acpi_status
-acpi_ds_obj_stack_push (
-	void                    *object,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ds_obj_stack_pop (
-	u32                     pop_count,
-	acpi_walk_state         *walk_state);
-
-void *
-acpi_ds_obj_stack_get_value (
-	u32                     index,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ds_obj_stack_pop_object (
-	acpi_operand_object     **object,
-	acpi_walk_state         *walk_state);
-
-
-/* dsopcode - support for late evaluation */
-
-acpi_status
-acpi_ds_get_buffer_field_arguments (
-	acpi_operand_object     *obj_desc);
-
-acpi_status
-acpi_ds_get_region_arguments (
-	acpi_operand_object     *rgn_desc);
-
-
-/* dsctrl - Parser/Interpreter interface, control stack routines */
-
-
-acpi_status
-acpi_ds_exec_begin_control_op (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op);
-
-acpi_status
-acpi_ds_exec_end_control_op (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op);
-
-
-/* dsexec - Parser/Interpreter interface, method execution callbacks */
-
-
-acpi_status
-acpi_ds_get_predicate_value (
-	acpi_walk_state         *walk_state,
-	u32                     has_result_obj);
-
-acpi_status
-acpi_ds_exec_begin_op (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       **out_op);
-
-acpi_status
-acpi_ds_exec_end_op (
-	acpi_walk_state         *state);
-
-
-/* dsfield - Parser/Interpreter interface for AML fields */
-
-acpi_status
-acpi_ds_create_field (
-	acpi_parse_object       *op,
-	acpi_namespace_node     *region_node,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ds_create_bank_field (
-	acpi_parse_object       *op,
-	acpi_namespace_node     *region_node,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ds_create_index_field (
-	acpi_parse_object       *op,
-	acpi_namespace_node     *region_node,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ds_create_buffer_field (
-	acpi_parse_object       *op,
-	acpi_walk_state         *walk_state);
-
-
-/* dsload - Parser/Interpreter interface, namespace load callbacks */
-
-acpi_status
-acpi_ds_load1_begin_op (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       **out_op);
-
-acpi_status
-acpi_ds_load1_end_op (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ds_load2_begin_op (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       **out_op);
-
-acpi_status
-acpi_ds_load2_end_op (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ds_init_callbacks (
-	acpi_walk_state         *walk_state,
-	u32                     pass_number);
-
-
-/* dsmthdat - method data (locals/args) */
-
-
-acpi_status
-acpi_ds_store_object_to_local (
-	u16                     opcode,
-	u32                     index,
-	acpi_operand_object     *src_desc,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ds_method_data_get_entry (
-	u16                     opcode,
-	u32                     index,
-	acpi_walk_state         *walk_state,
-	acpi_operand_object     ***node);
-
-acpi_status
-acpi_ds_method_data_delete_all (
-	acpi_walk_state         *walk_state);
-
-u8
-acpi_ds_is_method_value (
-	acpi_operand_object     *obj_desc);
-
-acpi_object_type8
-acpi_ds_method_data_get_type (
-	u16                     opcode,
-	u32                     index,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ds_method_data_get_value (
-	u16                     opcode,
-	u32                     index,
-	acpi_walk_state         *walk_state,
-	acpi_operand_object     **dest_desc);
-
-acpi_status
-acpi_ds_method_data_delete_value (
-	u16                     opcode,
-	u32                     index,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ds_method_data_init_args (
-	acpi_operand_object     **params,
-	u32                     max_param_count,
-	acpi_walk_state         *walk_state);
-
-acpi_namespace_node *
-acpi_ds_method_data_get_node (
-	u16                     opcode,
-	u32                     index,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ds_method_data_init (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ds_method_data_set_entry (
-	u16                     opcode,
-	u32                     index,
-	acpi_operand_object     *object,
-	acpi_walk_state         *walk_state);
-
-
-/* dsmethod - Parser/Interpreter interface - control method parsing */
-
-acpi_status
-acpi_ds_parse_method (
-	acpi_handle             obj_handle);
-
-acpi_status
-acpi_ds_call_control_method (
-	acpi_walk_list          *walk_list,
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op);
-
-acpi_status
-acpi_ds_restart_control_method (
-	acpi_walk_state         *walk_state,
-	acpi_operand_object     *return_desc);
-
-acpi_status
-acpi_ds_terminate_control_method (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ds_begin_method_execution (
-	acpi_namespace_node     *method_node,
-	acpi_operand_object     *obj_desc,
-	acpi_namespace_node     *calling_method_node);
-
-
-/* dsobj - Parser/Interpreter interface - object initialization and conversion */
-
-acpi_status
-acpi_ds_init_one_object (
-	acpi_handle             obj_handle,
-	u32                     level,
-	void                    *context,
-	void                    **return_value);
-
-acpi_status
-acpi_ds_initialize_objects (
-	acpi_table_desc         *table_desc,
-	acpi_namespace_node     *start_node);
-
-acpi_status
-acpi_ds_build_internal_package_obj (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op,
-	acpi_operand_object     **obj_desc);
-
-acpi_status
-acpi_ds_build_internal_object (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op,
-	acpi_operand_object     **obj_desc_ptr);
-
-acpi_status
-acpi_ds_init_object_from_op (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op,
-	u16                     opcode,
-	acpi_operand_object     **obj_desc);
-
-acpi_status
-acpi_ds_create_node (
-	acpi_walk_state         *walk_state,
-	acpi_namespace_node     *node,
-	acpi_parse_object       *op);
-
-
-/* dsregn - Parser/Interpreter interface - Op Region parsing */
-
-acpi_status
-acpi_ds_eval_buffer_field_operands (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op);
-
-acpi_status
-acpi_ds_eval_region_operands (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op);
-
-acpi_status
-acpi_ds_initialize_region (
-	acpi_handle             obj_handle);
-
-
-/* dsutils - Parser/Interpreter interface utility routines */
-
-u8
-acpi_ds_is_result_used (
-	acpi_parse_object       *op,
-	acpi_walk_state         *walk_state);
-
-void
-acpi_ds_delete_result_if_not_used (
-	acpi_parse_object       *op,
-	acpi_operand_object     *result_obj,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ds_create_operand (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *arg,
-	u32                     args_remaining);
-
-acpi_status
-acpi_ds_create_operands (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *first_arg);
-
-acpi_status
-acpi_ds_resolve_operands (
-	acpi_walk_state         *walk_state);
-
-acpi_object_type8
-acpi_ds_map_opcode_to_data_type (
-	u16                     opcode,
-	u32                     *out_flags);
-
-acpi_object_type8
-acpi_ds_map_named_opcode_to_data_type (
-	u16                     opcode);
-
-
-/*
- * dswscope - Scope Stack manipulation
- */
-
-acpi_status
-acpi_ds_scope_stack_push (
-	acpi_namespace_node     *node,
-	acpi_object_type8       type,
-	acpi_walk_state         *walk_state);
-
-
-acpi_status
-acpi_ds_scope_stack_pop (
-	acpi_walk_state         *walk_state);
-
-void
-acpi_ds_scope_stack_clear (
-	acpi_walk_state         *walk_state);
-
-
-/* dswstate - parser WALK_STATE management routines */
-
-acpi_walk_state *
-acpi_ds_create_walk_state (
-	acpi_owner_id           owner_id,
-	acpi_parse_object       *origin,
-	acpi_operand_object     *mth_desc,
-	acpi_walk_list          *walk_list);
-
-acpi_status
-acpi_ds_init_aml_walk (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op,
-	acpi_namespace_node     *method_node,
-	u8                      *aml_start,
-	u32                     aml_length,
-	acpi_operand_object     **params,
-	acpi_operand_object     **return_obj_desc,
-	u32                     pass_number);
-
-acpi_status
-acpi_ds_obj_stack_delete_all (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ds_obj_stack_pop_and_delete (
-	u32                     pop_count,
-	acpi_walk_state         *walk_state);
-
-void
-acpi_ds_delete_walk_state (
-	acpi_walk_state         *walk_state);
-
-acpi_walk_state *
-acpi_ds_pop_walk_state (
-	acpi_walk_list          *walk_list);
-
-void
-acpi_ds_push_walk_state (
-	acpi_walk_state         *walk_state,
-	acpi_walk_list          *walk_list);
-
-acpi_status
-acpi_ds_result_stack_pop (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ds_result_stack_push (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ds_result_stack_clear (
-	acpi_walk_state         *walk_state);
-
-acpi_walk_state *
-acpi_ds_get_current_walk_state (
-	acpi_walk_list          *walk_list);
-
-void
-acpi_ds_delete_walk_state_cache (
-	void);
-
-acpi_status
-acpi_ds_result_insert (
-	void                    *object,
-	u32                     index,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ds_result_remove (
-	acpi_operand_object     **object,
-	u32                     index,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ds_result_pop (
-	acpi_operand_object     **object,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ds_result_push (
-	acpi_operand_object     *object,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ds_result_pop_from_bottom (
-	acpi_operand_object     **object,
-	acpi_walk_state         *walk_state);
-
-#endif /* _ACDISPAT_H_ */
diff -urNp linux-5400/drivers/acpi/include/acevents.h linux-5410/drivers/acpi/include/acevents.h
--- linux-5400/drivers/acpi/include/acevents.h
+++ linux-5410/drivers/acpi/include/acevents.h
@@ -1,217 +0,0 @@
-/******************************************************************************
- *
- * Name: acevents.h - Event subcomponent prototypes and defines
- *       $Revision: 66 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACEVENTS_H__
-#define __ACEVENTS_H__
-
-
-acpi_status
-acpi_ev_initialize (
-	void);
-
-
-/*
- * Acpi_evfixed - Fixed event handling
- */
-
-acpi_status
-acpi_ev_fixed_event_initialize (
-	void);
-
-u32
-acpi_ev_fixed_event_detect (
-	void);
-
-u32
-acpi_ev_fixed_event_dispatch (
-	u32                     acpi_event);
-
-
-/*
- * Acpi_evglock - Global Lock support
- */
-
-acpi_status
-acpi_ev_acquire_global_lock(
-	void);
-
-void
-acpi_ev_release_global_lock(
-	void);
-
-acpi_status
-acpi_ev_init_global_lock_handler (
-	void);
-
-
-/*
- * Acpi_evgpe - GPE handling and dispatch
- */
-
-acpi_status
-acpi_ev_gpe_initialize (
-	void);
-
-acpi_status
-acpi_ev_init_gpe_control_methods (
-	void);
-
-u32
-acpi_ev_gpe_dispatch (
-	u32                     gpe_number);
-
-u32
-acpi_ev_gpe_detect (
-	void);
-
-
-/*
- * Acpi_evnotify - Device Notify handling and dispatch
- */
-
-acpi_status
-acpi_ev_queue_notify_request (
-	acpi_namespace_node     *node,
-	u32                     notify_value);
-
-void
-acpi_ev_notify_dispatch (
-	void                    *context);
-
-/*
- * Acpi_evregion - Address Space handling
- */
-
-acpi_status
-acpi_ev_install_default_address_space_handlers (
-	void);
-
-acpi_status
-acpi_ev_address_space_dispatch (
-	acpi_operand_object    *region_obj,
-	u32                     function,
-	ACPI_PHYSICAL_ADDRESS   address,
-	u32                     bit_width,
-	u32                     *value);
-
-
-acpi_status
-acpi_ev_addr_handler_helper (
-	acpi_handle             obj_handle,
-	u32                     level,
-	void                    *context,
-	void                    **return_value);
-
-void
-acpi_ev_disassociate_region_from_handler(
-	acpi_operand_object    *region_obj,
-	u8                      acpi_ns_is_locked);
-
-
-acpi_status
-acpi_ev_associate_region_and_handler (
-	acpi_operand_object     *handler_obj,
-	acpi_operand_object     *region_obj,
-	u8                      acpi_ns_is_locked);
-
-
-/*
- * Acpi_evregini - Region initialization and setup
- */
-
-acpi_status
-acpi_ev_system_memory_region_setup (
-	acpi_handle             handle,
-	u32                     function,
-	void                    *handler_context,
-	void                    **region_context);
-
-acpi_status
-acpi_ev_io_space_region_setup (
-	acpi_handle             handle,
-	u32                     function,
-	void                    *handler_context,
-	void                    **region_context);
-
-acpi_status
-acpi_ev_pci_config_region_setup (
-	acpi_handle             handle,
-	u32                     function,
-	void                    *handler_context,
-	void                    **region_context);
-
-acpi_status
-acpi_ev_cmos_region_setup (
-	acpi_handle             handle,
-	u32                     function,
-	void                    *handler_context,
-	void                    **region_context);
-
-acpi_status
-acpi_ev_pci_bar_region_setup (
-	acpi_handle             handle,
-	u32                     function,
-	void                    *handler_context,
-	void                    **region_context);
-
-acpi_status
-acpi_ev_default_region_setup (
-	acpi_handle             handle,
-	u32                     function,
-	void                    *handler_context,
-	void                    **region_context);
-
-acpi_status
-acpi_ev_initialize_region (
-	acpi_operand_object     *region_obj,
-	u8                      acpi_ns_locked);
-
-
-/*
- * Evsci - SCI (System Control Interrupt) handling/dispatch
- */
-
-u32
-acpi_ev_install_sci_handler (
-	void);
-
-acpi_status
-acpi_ev_remove_sci_handler (
-	void);
-
-u32
-acpi_ev_initialize_sCI (
-	u32                     program_sCI);
-
-void
-acpi_ev_restore_acpi_state (
-	void);
-
-void
-acpi_ev_terminate (
-	void);
-
-
-#endif  /* __ACEVENTS_H__  */
diff -urNp linux-5400/drivers/acpi/include/acexcep.h linux-5410/drivers/acpi/include/acexcep.h
--- linux-5400/drivers/acpi/include/acexcep.h
+++ linux-5410/drivers/acpi/include/acexcep.h
@@ -1,248 +0,0 @@
-/******************************************************************************
- *
- * Name: acexcep.h - Exception codes returned by the ACPI subsystem
- *       $Revision: 50 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACEXCEP_H__
-#define __ACEXCEP_H__
-
-
-/*
- * Exceptions returned by external ACPI interfaces
- */
-
-#define AE_CODE_ENVIRONMENTAL           0x0000
-#define AE_CODE_PROGRAMMER              0x1000
-#define AE_CODE_ACPI_TABLES             0x2000
-#define AE_CODE_AML                     0x3000
-#define AE_CODE_CONTROL                 0x4000
-#define AE_CODE_MASK                    0xF000
-
-
-#define ACPI_SUCCESS(a)                 (!(a))
-#define ACPI_FAILURE(a)                 (a)
-
-
-#define AE_OK                           (acpi_status) 0x0000
-
-/*
- * Environmental exceptions
- */
-#define AE_ERROR                        (acpi_status) (0x0001 | AE_CODE_ENVIRONMENTAL)
-#define AE_NO_ACPI_TABLES               (acpi_status) (0x0002 | AE_CODE_ENVIRONMENTAL)
-#define AE_NO_NAMESPACE                 (acpi_status) (0x0003 | AE_CODE_ENVIRONMENTAL)
-#define AE_NO_MEMORY                    (acpi_status) (0x0004 | AE_CODE_ENVIRONMENTAL)
-#define AE_NOT_FOUND                    (acpi_status) (0x0005 | AE_CODE_ENVIRONMENTAL)
-#define AE_NOT_EXIST                    (acpi_status) (0x0006 | AE_CODE_ENVIRONMENTAL)
-#define AE_EXIST                        (acpi_status) (0x0007 | AE_CODE_ENVIRONMENTAL)
-#define AE_TYPE                         (acpi_status) (0x0008 | AE_CODE_ENVIRONMENTAL)
-#define AE_NULL_OBJECT                  (acpi_status) (0x0009 | AE_CODE_ENVIRONMENTAL)
-#define AE_NULL_ENTRY                   (acpi_status) (0x000A | AE_CODE_ENVIRONMENTAL)
-#define AE_BUFFER_OVERFLOW              (acpi_status) (0x000B | AE_CODE_ENVIRONMENTAL)
-#define AE_STACK_OVERFLOW               (acpi_status) (0x000C | AE_CODE_ENVIRONMENTAL)
-#define AE_STACK_UNDERFLOW              (acpi_status) (0x000D | AE_CODE_ENVIRONMENTAL)
-#define AE_NOT_IMPLEMENTED              (acpi_status) (0x000E | AE_CODE_ENVIRONMENTAL)
-#define AE_VERSION_MISMATCH             (acpi_status) (0x000F | AE_CODE_ENVIRONMENTAL)
-#define AE_SUPPORT                      (acpi_status) (0x0010 | AE_CODE_ENVIRONMENTAL)
-#define AE_SHARE                        (acpi_status) (0x0011 | AE_CODE_ENVIRONMENTAL)
-#define AE_LIMIT                        (acpi_status) (0x0012 | AE_CODE_ENVIRONMENTAL)
-#define AE_TIME                         (acpi_status) (0x0013 | AE_CODE_ENVIRONMENTAL)
-#define AE_UNKNOWN_STATUS               (acpi_status) (0x0014 | AE_CODE_ENVIRONMENTAL)
-#define AE_ACQUIRE_DEADLOCK             (acpi_status) (0x0015 | AE_CODE_ENVIRONMENTAL)
-#define AE_RELEASE_DEADLOCK             (acpi_status) (0x0016 | AE_CODE_ENVIRONMENTAL)
-#define AE_NOT_ACQUIRED                 (acpi_status) (0x0017 | AE_CODE_ENVIRONMENTAL)
-#define AE_ALREADY_ACQUIRED             (acpi_status) (0x0018 | AE_CODE_ENVIRONMENTAL)
-#define AE_NO_HARDWARE_RESPONSE         (acpi_status) (0x0019 | AE_CODE_ENVIRONMENTAL)
-#define AE_NO_GLOBAL_LOCK               (acpi_status) (0x001A | AE_CODE_ENVIRONMENTAL)
-
-#define AE_CODE_ENV_MAX                 0x001A
-
-/*
- * Programmer exceptions
- */
-#define AE_BAD_PARAMETER                (acpi_status) (0x0001 | AE_CODE_PROGRAMMER)
-#define AE_BAD_CHARACTER                (acpi_status) (0x0002 | AE_CODE_PROGRAMMER)
-#define AE_BAD_PATHNAME                 (acpi_status) (0x0003 | AE_CODE_PROGRAMMER)
-#define AE_BAD_DATA                     (acpi_status) (0x0004 | AE_CODE_PROGRAMMER)
-#define AE_BAD_ADDRESS                  (acpi_status) (0x0005 | AE_CODE_PROGRAMMER)
-
-#define AE_CODE_PGM_MAX                 0x0005
-
-
-/*
- * Acpi table exceptions
- */
-#define AE_BAD_SIGNATURE                (acpi_status) (0x0001 | AE_CODE_ACPI_TABLES)
-#define AE_BAD_HEADER                   (acpi_status) (0x0002 | AE_CODE_ACPI_TABLES)
-#define AE_BAD_CHECKSUM                 (acpi_status) (0x0003 | AE_CODE_ACPI_TABLES)
-#define AE_BAD_VALUE                    (acpi_status) (0x0004 | AE_CODE_ACPI_TABLES)
-
-#define AE_CODE_TBL_MAX                 0x0003
-
-
-/*
- * AML exceptions.  These are caused by problems with
- * the actual AML byte stream
- */
-#define AE_AML_ERROR                    (acpi_status) (0x0001 | AE_CODE_AML)
-#define AE_AML_PARSE                    (acpi_status) (0x0002 | AE_CODE_AML)
-#define AE_AML_BAD_OPCODE               (acpi_status) (0x0003 | AE_CODE_AML)
-#define AE_AML_NO_OPERAND               (acpi_status) (0x0004 | AE_CODE_AML)
-#define AE_AML_OPERAND_TYPE             (acpi_status) (0x0005 | AE_CODE_AML)
-#define AE_AML_OPERAND_VALUE            (acpi_status) (0x0006 | AE_CODE_AML)
-#define AE_AML_UNINITIALIZED_LOCAL      (acpi_status) (0x0007 | AE_CODE_AML)
-#define AE_AML_UNINITIALIZED_ARG        (acpi_status) (0x0008 | AE_CODE_AML)
-#define AE_AML_UNINITIALIZED_ELEMENT    (acpi_status) (0x0009 | AE_CODE_AML)
-#define AE_AML_NUMERIC_OVERFLOW         (acpi_status) (0x000A | AE_CODE_AML)
-#define AE_AML_REGION_LIMIT             (acpi_status) (0x000B | AE_CODE_AML)
-#define AE_AML_BUFFER_LIMIT             (acpi_status) (0x000C | AE_CODE_AML)
-#define AE_AML_PACKAGE_LIMIT            (acpi_status) (0x000D | AE_CODE_AML)
-#define AE_AML_DIVIDE_BY_ZERO           (acpi_status) (0x000E | AE_CODE_AML)
-#define AE_AML_BAD_NAME                 (acpi_status) (0x000F | AE_CODE_AML)
-#define AE_AML_NAME_NOT_FOUND           (acpi_status) (0x0010 | AE_CODE_AML)
-#define AE_AML_INTERNAL                 (acpi_status) (0x0011 | AE_CODE_AML)
-#define AE_AML_INVALID_SPACE_ID         (acpi_status) (0x0012 | AE_CODE_AML)
-#define AE_AML_STRING_LIMIT             (acpi_status) (0x0013 | AE_CODE_AML)
-#define AE_AML_NO_RETURN_VALUE          (acpi_status) (0x0014 | AE_CODE_AML)
-#define AE_AML_METHOD_LIMIT             (acpi_status) (0x0015 | AE_CODE_AML)
-#define AE_AML_NOT_OWNER                (acpi_status) (0x0016 | AE_CODE_AML)
-#define AE_AML_MUTEX_ORDER              (acpi_status) (0x0017 | AE_CODE_AML)
-#define AE_AML_MUTEX_NOT_ACQUIRED       (acpi_status) (0x0018 | AE_CODE_AML)
-#define AE_AML_INVALID_RESOURCE_TYPE    (acpi_status) (0x0019 | AE_CODE_AML)
-
-#define AE_CODE_AML_MAX                 0x0019
-
-/*
- * Internal exceptions used for control
- */
-#define AE_CTRL_RETURN_VALUE            (acpi_status) (0x0001 | AE_CODE_CONTROL)
-#define AE_CTRL_PENDING                 (acpi_status) (0x0002 | AE_CODE_CONTROL)
-#define AE_CTRL_TERMINATE               (acpi_status) (0x0003 | AE_CODE_CONTROL)
-#define AE_CTRL_TRUE                    (acpi_status) (0x0004 | AE_CODE_CONTROL)
-#define AE_CTRL_FALSE                   (acpi_status) (0x0005 | AE_CODE_CONTROL)
-#define AE_CTRL_DEPTH                   (acpi_status) (0x0006 | AE_CODE_CONTROL)
-#define AE_CTRL_END                     (acpi_status) (0x0007 | AE_CODE_CONTROL)
-#define AE_CTRL_TRANSFER                (acpi_status) (0x0008 | AE_CODE_CONTROL)
-
-#define AE_CODE_CTRL_MAX                0x0008
-
-
-#ifdef DEFINE_ACPI_GLOBALS
-
-/*
- * String versions of the exception codes above
- * These strings must match the corresponding defines exactly
- */
-NATIVE_CHAR const   *acpi_gbl_exception_names_env[] =
-{
-	"AE_OK",
-	"AE_ERROR",
-	"AE_NO_ACPI_TABLES",
-	"AE_NO_NAMESPACE",
-	"AE_NO_MEMORY",
-	"AE_NOT_FOUND",
-	"AE_NOT_EXIST",
-	"AE_EXIST",
-	"AE_TYPE",
-	"AE_NULL_OBJECT",
-	"AE_NULL_ENTRY",
-	"AE_BUFFER_OVERFLOW",
-	"AE_STACK_OVERFLOW",
-	"AE_STACK_UNDERFLOW",
-	"AE_NOT_IMPLEMENTED",
-	"AE_VERSION_MISMATCH",
-	"AE_SUPPORT",
-	"AE_SHARE",
-	"AE_LIMIT",
-	"AE_TIME",
-	"AE_UNKNOWN_STATUS",
-	"AE_ACQUIRE_DEADLOCK",
-	"AE_RELEASE_DEADLOCK",
-	"AE_NOT_ACQUIRED",
-	"AE_ALREADY_ACQUIRED",
-	"AE_NO_HARDWARE_RESPONSE",
-	"AE_NO_GLOBAL_LOCK",
-};
-
-NATIVE_CHAR const   *acpi_gbl_exception_names_pgm[] =
-{
-	"AE_BAD_PARAMETER",
-	"AE_BAD_CHARACTER",
-	"AE_BAD_PATHNAME",
-	"AE_BAD_DATA",
-	"AE_BAD_ADDRESS",
-};
-
-NATIVE_CHAR const   *acpi_gbl_exception_names_tbl[] =
-{
-	"AE_BAD_SIGNATURE",
-	"AE_BAD_HEADER",
-	"AE_BAD_CHECKSUM",
-	"AE_BAD_VALUE",
-};
-
-NATIVE_CHAR const   *acpi_gbl_exception_names_aml[] =
-{
-	"AE_AML_ERROR",
-	"AE_AML_PARSE",
-	"AE_AML_BAD_OPCODE",
-	"AE_AML_NO_OPERAND",
-	"AE_AML_OPERAND_TYPE",
-	"AE_AML_OPERAND_VALUE",
-	"AE_AML_UNINITIALIZED_LOCAL",
-	"AE_AML_UNINITIALIZED_ARG",
-	"AE_AML_UNINITIALIZED_ELEMENT",
-	"AE_AML_NUMERIC_OVERFLOW",
-	"AE_AML_REGION_LIMIT",
-	"AE_AML_BUFFER_LIMIT",
-	"AE_AML_PACKAGE_LIMIT",
-	"AE_AML_DIVIDE_BY_ZERO",
-	"AE_AML_BAD_NAME",
-	"AE_AML_NAME_NOT_FOUND",
-	"AE_AML_INTERNAL",
-	"AE_AML_INVALID_SPACE_ID",
-	"AE_AML_STRING_LIMIT",
-	"AE_AML_NO_RETURN_VALUE",
-	"AE_AML_METHOD_LIMIT",
-	"AE_AML_NOT_OWNER",
-	"AE_AML_MUTEX_ORDER",
-	"AE_AML_MUTEX_NOT_ACQUIRED",
-	"AE_AML_INVALID_RESOURCE_TYPE",
-};
-
-NATIVE_CHAR const   *acpi_gbl_exception_names_ctrl[] =
-{
-	"AE_CTRL_RETURN_VALUE",
-	"AE_CTRL_PENDING",
-	"AE_CTRL_TERMINATE",
-	"AE_CTRL_TRUE",
-	"AE_CTRL_FALSE",
-	"AE_CTRL_DEPTH",
-	"AE_CTRL_END",
-	"AE_CTRL_TRANSFER",
-};
-
-#endif /* ACPI GLOBALS */
-
-
-#endif /* __ACEXCEP_H__ */
diff -urNp linux-5400/drivers/acpi/include/acglobal.h linux-5410/drivers/acpi/include/acglobal.h
--- linux-5400/drivers/acpi/include/acglobal.h
+++ linux-5410/drivers/acpi/include/acglobal.h
@@ -1,232 +0,0 @@
-/******************************************************************************
- *
- * Name: acglobal.h - Declarations for global variables
- *       $Revision: 106 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACGLOBAL_H__
-#define __ACGLOBAL_H__
-
-
-/*
- * Ensure that the globals are actually defined only once.
- *
- * The use of these defines allows a single list of globals (here) in order
- * to simplify maintenance of the code.
- */
-#ifdef DEFINE_ACPI_GLOBALS
-#define ACPI_EXTERN
-#else
-#define ACPI_EXTERN extern
-#endif
-
-
-/*****************************************************************************
- *
- * Debug support
- *
- ****************************************************************************/
-
-/* Runtime configuration of debug print levels */
-
-extern      u32                         acpi_dbg_level;
-extern      u32                         acpi_dbg_layer;
-
-/* Procedure nesting level for debug output */
-
-extern      u32                         acpi_gbl_nesting_level;
-
-
-/*****************************************************************************
- *
- * ACPI Table globals
- *
- ****************************************************************************/
-
-/*
- * Table pointers.
- * Although these pointers are somewhat redundant with the global Acpi_table,
- * they are convenient because they are typed pointers.
- *
- * These tables are single-table only; meaning that there can be at most one
- * of each in the system.  Each global points to the actual table.
- *
- */
-ACPI_EXTERN RSDP_DESCRIPTOR             *acpi_gbl_RSDP;
-ACPI_EXTERN xsdt_descriptor             *acpi_gbl_XSDT;
-ACPI_EXTERN FADT_DESCRIPTOR             *acpi_gbl_FADT;
-ACPI_EXTERN acpi_table_header           *acpi_gbl_DSDT;
-ACPI_EXTERN acpi_common_facs            *acpi_gbl_FACS;
-
-/*
- * Since there may be multiple SSDTs and PSDTS, a single pointer is not
- * sufficient; Therefore, there isn't one!
- */
-
-
-/*
- * ACPI Table info arrays
- */
-extern      acpi_table_desc             acpi_gbl_acpi_tables[NUM_ACPI_TABLES];
-extern      ACPI_TABLE_SUPPORT          acpi_gbl_acpi_table_data[NUM_ACPI_TABLES];
-
-/*
- * Predefined mutex objects.  This array contains the
- * actual OS mutex handles, indexed by the local ACPI_MUTEX_HANDLEs.
- * (The table maps local handles to the real OS handles)
- */
-ACPI_EXTERN acpi_mutex_info             acpi_gbl_acpi_mutex_info [NUM_MTX];
-
-
-/*****************************************************************************
- *
- * Miscellaneous globals
- *
- ****************************************************************************/
-
-
-ACPI_EXTERN ACPI_MEMORY_LIST            acpi_gbl_memory_lists[ACPI_NUM_MEM_LISTS];
-ACPI_EXTERN ACPI_OBJECT_NOTIFY_HANDLER  acpi_gbl_drv_notify;
-ACPI_EXTERN ACPI_OBJECT_NOTIFY_HANDLER  acpi_gbl_sys_notify;
-ACPI_EXTERN u8                         *acpi_gbl_gpe0enable_register_save;
-ACPI_EXTERN u8                         *acpi_gbl_gpe1_enable_register_save;
-ACPI_EXTERN acpi_walk_state            *acpi_gbl_breakpoint_walk;
-ACPI_EXTERN acpi_handle                 acpi_gbl_global_lock_semaphore;
-
-ACPI_EXTERN u32                         acpi_gbl_global_lock_thread_count;
-ACPI_EXTERN u32                         acpi_gbl_restore_acpi_chipset;
-ACPI_EXTERN u32                         acpi_gbl_original_mode;
-ACPI_EXTERN u32                         acpi_gbl_edge_level_save;
-ACPI_EXTERN u32                         acpi_gbl_irq_enable_save;
-ACPI_EXTERN u32                         acpi_gbl_rsdp_original_location;
-ACPI_EXTERN u32                         acpi_gbl_ns_lookup_count;
-ACPI_EXTERN u32                         acpi_gbl_ps_find_count;
-ACPI_EXTERN u16                         acpi_gbl_pm1_enable_register_save;
-ACPI_EXTERN u16                         acpi_gbl_next_table_owner_id;
-ACPI_EXTERN u16                         acpi_gbl_next_method_owner_id;
-ACPI_EXTERN u8                          acpi_gbl_debugger_configuration;
-ACPI_EXTERN u8                          acpi_gbl_global_lock_acquired;
-ACPI_EXTERN u8                          acpi_gbl_step_to_next_call;
-ACPI_EXTERN u8                          acpi_gbl_acpi_hardware_present;
-ACPI_EXTERN u8                          acpi_gbl_global_lock_present;
-
-extern u8                               acpi_gbl_shutdown;
-extern u32                              acpi_gbl_system_flags;
-extern u32                              acpi_gbl_startup_flags;
-extern const u8                         acpi_gbl_decode_to8bit[8];
-extern const NATIVE_CHAR                *acpi_gbl_db_sleep_states[ACPI_NUM_SLEEP_STATES];
-
-
-/*****************************************************************************
- *
- * Namespace globals
- *
- ****************************************************************************/
-
-#define NUM_NS_TYPES                    INTERNAL_TYPE_INVALID+1
-#define NUM_PREDEFINED_NAMES            9
-
-
-ACPI_EXTERN acpi_namespace_node         acpi_gbl_root_node_struct;
-ACPI_EXTERN acpi_namespace_node        *acpi_gbl_root_node;
-
-extern const u8                         acpi_gbl_ns_properties[NUM_NS_TYPES];
-extern const predefined_names           acpi_gbl_pre_defined_names [NUM_PREDEFINED_NAMES];
-
-#ifdef ACPI_DEBUG
-ACPI_EXTERN u32                         acpi_gbl_current_node_count;
-ACPI_EXTERN u32                         acpi_gbl_current_node_size;
-ACPI_EXTERN u32                         acpi_gbl_max_concurrent_node_count;
-ACPI_EXTERN unsigned long               acpi_gbl_entry_stack_pointer;
-ACPI_EXTERN u32                         acpi_gbl_lowest_stack_pointer;
-ACPI_EXTERN u32                         acpi_gbl_deepest_nesting;
-#endif
-
-/*****************************************************************************
- *
- * Interpreter globals
- *
- ****************************************************************************/
-
-
-ACPI_EXTERN acpi_walk_list             *acpi_gbl_current_walk_list;
-
-/* Address Space handlers */
-
-ACPI_EXTERN acpi_adr_space_info         acpi_gbl_address_spaces[ACPI_NUM_ADDRESS_SPACES];
-
-/* Control method single step flag */
-
-ACPI_EXTERN u8                          acpi_gbl_cm_single_step;
-
-
-/*****************************************************************************
- *
- * Parser globals
- *
- ****************************************************************************/
-
-ACPI_EXTERN acpi_parse_object           *acpi_gbl_parsed_namespace_root;
-
-
-/*****************************************************************************
- *
- * Event globals
- *
- ****************************************************************************/
-
-ACPI_EXTERN acpi_fixed_event_info       acpi_gbl_fixed_event_handlers[ACPI_NUM_FIXED_EVENTS];
-ACPI_EXTERN acpi_handle                 acpi_gbl_gpe_obj_handle;
-ACPI_EXTERN u32                         acpi_gbl_gpe_register_count;
-ACPI_EXTERN acpi_gpe_registers         *acpi_gbl_gpe_registers;
-ACPI_EXTERN acpi_gpe_level_info        *acpi_gbl_gpe_info;
-
-/*
- * Gpe validation and translation table
- * Indexed by the GPE number, returns GPE_INVALID if the GPE is not supported.
- * Otherwise, returns a valid index into the global GPE table.
- *
- * This table is needed because the GPE numbers supported by block 1 do not
- * have to be contiguous with the GPE numbers supported by block 0.
- */
-ACPI_EXTERN u8                          acpi_gbl_gpe_valid [ACPI_NUM_GPE];
-
-/* Acpi_event counter for debug only */
-
-#ifdef ACPI_DEBUG
-ACPI_EXTERN u32                         acpi_gbl_event_count[ACPI_NUM_FIXED_EVENTS];
-#endif
-
-
-/*****************************************************************************
- *
- * Debugger globals
- *
- ****************************************************************************/
-
-#ifdef ENABLE_DEBUGGER
-ACPI_EXTERN u8                          acpi_gbl_method_executing;
-ACPI_EXTERN u8                          acpi_gbl_db_terminate_threads;
-#endif
-
-
-#endif /* __ACGLOBAL_H__ */
diff -urNp linux-5400/drivers/acpi/include/achware.h linux-5410/drivers/acpi/include/achware.h
--- linux-5400/drivers/acpi/include/achware.h
+++ linux-5410/drivers/acpi/include/achware.h
@@ -1,166 +0,0 @@
-/******************************************************************************
- *
- * Name: achware.h -- hardware specific interfaces
- *       $Revision: 56 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACHWARE_H__
-#define __ACHWARE_H__
-
-
-/* PM Timer ticks per second (HZ) */
-#define PM_TIMER_FREQUENCY  3579545
-
-
-/* Prototypes */
-
-
-acpi_status
-acpi_hw_initialize (
-	void);
-
-acpi_status
-acpi_hw_shutdown (
-	void);
-
-acpi_status
-acpi_hw_initialize_system_info (
-	void);
-
-acpi_status
-acpi_hw_set_mode (
-	u32                     mode);
-
-u32
-acpi_hw_get_mode (
-	void);
-
-u32
-acpi_hw_get_mode_capabilities (
-	void);
-
-/* Register I/O Prototypes */
-
-
-u32
-acpi_hw_register_bit_access (
-	NATIVE_UINT             read_write,
-	u8                      use_lock,
-	u32                     register_id,
-	... /* DWORD Write Value */);
-
-u32
-acpi_hw_register_read (
-	u8                      use_lock,
-	u32                     register_id);
-
-void
-acpi_hw_register_write (
-	u8                      use_lock,
-	u32                     register_id,
-	u32                     value);
-
-u32
-acpi_hw_low_level_read (
-	u32                     width,
-	acpi_generic_address    *reg,
-	u32                     offset);
-
-void
-acpi_hw_low_level_write (
-	u32                     width,
-	u32                     value,
-	acpi_generic_address    *reg,
-	u32                     offset);
-
-void
-acpi_hw_clear_acpi_status (
-   void);
-
-u32
-acpi_hw_get_bit_shift (
-	u32                     mask);
-
-
-/* GPE support */
-
-void
-acpi_hw_enable_gpe (
-	u32                     gpe_number);
-
-void
-acpi_hw_enable_gpe_for_wakeup (
-	u32                     gpe_number);
-
-void
-acpi_hw_disable_gpe (
-	u32                     gpe_number);
-
-void
-acpi_hw_disable_gpe_for_wakeup (
-	u32                     gpe_number);
-
-void
-acpi_hw_clear_gpe (
-	u32                     gpe_number);
-
-void
-acpi_hw_get_gpe_status (
-	u32                     gpe_number,
-	acpi_event_status       *event_status);
-
-void
-acpi_hw_disable_non_wakeup_gpes (
-	void);
-
-void
-acpi_hw_enable_non_wakeup_gpes (
-	void);
-
-
-/* Sleep Prototypes */
-
-acpi_status
-acpi_hw_obtain_sleep_type_register_data (
-	u8                      sleep_state,
-	u8                      *slp_typ_a,
-	u8                      *slp_typ_b);
-
-
-/* ACPI Timer prototypes */
-
-acpi_status
-acpi_get_timer_resolution (
-	u32                     *resolution);
-
-acpi_status
-acpi_get_timer (
-	u32                     *ticks);
-
-acpi_status
-acpi_get_timer_duration (
-	u32                     start_ticks,
-	u32                     end_ticks,
-	u32                     *time_elapsed);
-
-
-#endif /* __ACHWARE_H__ */
diff -urNp linux-5400/drivers/acpi/include/acinterp.h linux-5410/drivers/acpi/include/acinterp.h
--- linux-5400/drivers/acpi/include/acinterp.h
+++ linux-5410/drivers/acpi/include/acinterp.h
@@ -1,704 +0,0 @@
-/******************************************************************************
- *
- * Name: acinterp.h - Interpreter subcomponent prototypes and defines
- *       $Revision: 116 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACINTERP_H__
-#define __ACINTERP_H__
-
-
-#define WALK_OPERANDS       &(walk_state->operands [walk_state->num_operands -1])
-
-
-/* Interpreter constants */
-
-#define AML_END_OF_BLOCK            -1
-#define PUSH_PKG_LENGTH             1
-#define DO_NOT_PUSH_PKG_LENGTH      0
-
-
-#define STACK_TOP                   0
-#define STACK_BOTTOM                (u32) -1
-
-/* Constants for global "When_to_parse_methods" */
-
-#define METHOD_PARSE_AT_INIT        0x0
-#define METHOD_PARSE_JUST_IN_TIME   0x1
-#define METHOD_DELETE_AT_COMPLETION 0x2
-
-
-acpi_status
-acpi_ex_resolve_operands (
-	u16                     opcode,
-	acpi_operand_object     **stack_ptr,
-	acpi_walk_state         *walk_state);
-
-
-/*
- * amxface - External interpreter interfaces
- */
-
-acpi_status
-acpi_ex_load_table (
-	acpi_table_type         table_id);
-
-acpi_status
-acpi_ex_execute_method (
-	acpi_namespace_node     *method_node,
-	acpi_operand_object     **params,
-	acpi_operand_object     **return_obj_desc);
-
-
-/*
- * amconvrt - object conversion
- */
-
-acpi_status
-acpi_ex_convert_to_integer (
-	acpi_operand_object     *obj_desc,
-	acpi_operand_object     **result_desc,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_convert_to_buffer (
-	acpi_operand_object     *obj_desc,
-	acpi_operand_object     **result_desc,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_convert_to_string (
-	acpi_operand_object     *obj_desc,
-	acpi_operand_object     **result_desc,
-	u32                     base,
-	u32                     max_length,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_convert_to_target_type (
-	acpi_object_type8       destination_type,
-	acpi_operand_object     **obj_desc,
-	acpi_walk_state         *walk_state);
-
-
-/*
- * amfield - ACPI AML (p-code) execution - field manipulation
- */
-
-acpi_status
-acpi_ex_extract_from_field (
-	acpi_operand_object     *obj_desc,
-	void                    *buffer,
-	u32                     buffer_length);
-
-acpi_status
-acpi_ex_insert_into_field (
-	acpi_operand_object     *obj_desc,
-	void                    *buffer,
-	u32                     buffer_length);
-
-acpi_status
-acpi_ex_setup_field (
-	acpi_operand_object     *obj_desc,
-	u32                     field_byte_offset);
-
-acpi_status
-acpi_ex_read_field_datum (
-	acpi_operand_object     *obj_desc,
-	u32                     field_byte_offset,
-	u32                     *value);
-
-acpi_status
-acpi_ex_common_access_field (
-	u32                     mode,
-	acpi_operand_object     *obj_desc,
-	void                    *buffer,
-	u32                     buffer_length);
-
-
-acpi_status
-acpi_ex_access_index_field (
-	u32                     mode,
-	acpi_operand_object     *obj_desc,
-	void                    *buffer,
-	u32                     buffer_length);
-
-acpi_status
-acpi_ex_access_bank_field (
-	u32                     mode,
-	acpi_operand_object     *obj_desc,
-	void                    *buffer,
-	u32                     buffer_length);
-
-acpi_status
-acpi_ex_access_region_field (
-	u32                     mode,
-	acpi_operand_object     *obj_desc,
-	void                    *buffer,
-	u32                     buffer_length);
-
-
-acpi_status
-acpi_ex_access_buffer_field (
-	u32                     mode,
-	acpi_operand_object     *obj_desc,
-	void                    *buffer,
-	u32                     buffer_length);
-
-acpi_status
-acpi_ex_read_data_from_field (
-	acpi_operand_object     *obj_desc,
-	acpi_operand_object     **ret_buffer_desc);
-
-acpi_status
-acpi_ex_write_data_to_field (
-	acpi_operand_object     *source_desc,
-	acpi_operand_object     *obj_desc);
-
-/*
- * ammisc - ACPI AML (p-code) execution - specific opcodes
- */
-
-acpi_status
-acpi_ex_opcode_3A_0T_0R (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_opcode_3A_1T_1R (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_opcode_6A_0T_1R (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_get_object_reference (
-	acpi_operand_object     *obj_desc,
-	acpi_operand_object     **return_desc,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_do_concatenate (
-	acpi_operand_object     *obj_desc,
-	acpi_operand_object     *obj_desc2,
-	acpi_operand_object     **actual_return_desc,
-	acpi_walk_state         *walk_state);
-
-u8
-acpi_ex_do_logical_op (
-	u16                     opcode,
-	acpi_integer            operand0,
-	acpi_integer            operand1);
-
-acpi_integer
-acpi_ex_do_math_op (
-	u16                     opcode,
-	acpi_integer            operand0,
-	acpi_integer            operand1);
-
-acpi_status
-acpi_ex_load_op (
-	acpi_operand_object     *rgn_desc,
-	acpi_operand_object     *ddb_handle);
-
-acpi_status
-acpi_ex_unload_table (
-	acpi_operand_object     *ddb_handle);
-
-acpi_status
-acpi_ex_create_mutex (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_create_processor (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_create_power_resource (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_create_region (
-	u8                      *aml_start,
-	u32                     aml_length,
-	u8                      region_space,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_create_table_region (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_create_event (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_create_alias (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_create_method (
-	u8                      *aml_start,
-	u32                     aml_length,
-	acpi_walk_state         *walk_state);
-
-
-/*
- * ammutex - mutex support
- */
-
-acpi_status
-acpi_ex_acquire_mutex (
-	acpi_operand_object     *time_desc,
-	acpi_operand_object     *obj_desc,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_release_mutex (
-	acpi_operand_object     *obj_desc,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_release_all_mutexes (
-	acpi_operand_object     *mutex_list);
-
-void
-acpi_ex_unlink_mutex (
-	acpi_operand_object     *obj_desc);
-
-
-/*
- * amprep - ACPI AML (p-code) execution - prep utilities
- */
-
-acpi_status
-acpi_ex_prep_common_field_object (
-	acpi_operand_object     *obj_desc,
-	u8                      field_flags,
-	u32                     field_position,
-	u32                     field_length);
-
-acpi_status
-acpi_ex_prep_region_field_value (
-	acpi_namespace_node     *node,
-	acpi_handle             region,
-	u8                      field_flags,
-	u32                     field_position,
-	u32                     field_length);
-
-acpi_status
-acpi_ex_prep_bank_field_value (
-	acpi_namespace_node     *node,
-	acpi_namespace_node     *region_node,
-	acpi_namespace_node     *bank_register_node,
-	u32                     bank_val,
-	u8                      field_flags,
-	u32                     field_position,
-	u32                     field_length);
-
-acpi_status
-acpi_ex_prep_index_field_value (
-	acpi_namespace_node     *node,
-	acpi_namespace_node     *index_reg,
-	acpi_namespace_node     *data_reg,
-	u8                      field_flags,
-	u32                     field_position,
-	u32                     field_length);
-
-acpi_status
-acpi_ex_prep_field_value (
-	ACPI_CREATE_FIELD_INFO  *info);
-
-/*
- * amsystem - Interface to OS services
- */
-
-acpi_status
-acpi_ex_system_do_notify_op (
-	acpi_operand_object     *value,
-	acpi_operand_object     *obj_desc);
-
-void
-acpi_ex_system_do_suspend(
-	u32                     time);
-
-void
-acpi_ex_system_do_stall (
-	u32                     time);
-
-acpi_status
-acpi_ex_system_acquire_mutex(
-	acpi_operand_object     *time,
-	acpi_operand_object     *obj_desc);
-
-acpi_status
-acpi_ex_system_release_mutex(
-	acpi_operand_object     *obj_desc);
-
-acpi_status
-acpi_ex_system_signal_event(
-	acpi_operand_object     *obj_desc);
-
-acpi_status
-acpi_ex_system_wait_event(
-	acpi_operand_object     *time,
-	acpi_operand_object     *obj_desc);
-
-acpi_status
-acpi_ex_system_reset_event(
-	acpi_operand_object     *obj_desc);
-
-acpi_status
-acpi_ex_system_wait_semaphore (
-	acpi_handle             semaphore,
-	u32                     timeout);
-
-
-/*
- * ammonadic - ACPI AML (p-code) execution, monadic operators
- */
-
-acpi_status
-acpi_ex_opcode_1A_0T_0R (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_opcode_1A_0T_1R (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_opcode_1A_1T_1R (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_opcode_1A_1T_0R (
-	acpi_walk_state         *walk_state);
-
-/*
- * amdyadic - ACPI AML (p-code) execution, dyadic operators
- */
-
-acpi_status
-acpi_ex_opcode_2A_0T_0R (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_opcode_2A_0T_1R (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_opcode_2A_1T_1R (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_opcode_2A_2T_1R (
-	acpi_walk_state         *walk_state);
-
-
-/*
- * amresolv  - Object resolution and get value functions
- */
-
-acpi_status
-acpi_ex_resolve_to_value (
-	acpi_operand_object     **stack_ptr,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_resolve_node_to_value (
-	acpi_namespace_node     **stack_ptr,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_resolve_object_to_value (
-	acpi_operand_object     **stack_ptr,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_get_buffer_field_value (
-	acpi_operand_object     *field_desc,
-	acpi_operand_object     *result_desc);
-
-
-/*
- * amdump - Scanner debug output routines
- */
-
-void
-acpi_ex_show_hex_value (
-	u32                     byte_count,
-	u8                      *aml_start,
-	u32                     lead_space);
-
-
-acpi_status
-acpi_ex_dump_operand (
-	acpi_operand_object     *entry_desc);
-
-void
-acpi_ex_dump_operands (
-	acpi_operand_object     **operands,
-	operating_mode          interpreter_mode,
-	NATIVE_CHAR             *ident,
-	u32                     num_levels,
-	NATIVE_CHAR             *note,
-	NATIVE_CHAR             *module_name,
-	u32                     line_number);
-
-void
-acpi_ex_dump_object_descriptor (
-	acpi_operand_object     *object,
-	u32                     flags);
-
-
-void
-acpi_ex_dump_node (
-	acpi_namespace_node     *node,
-	u32                     flags);
-
-
-/*
- * amnames - interpreter/scanner name load/execute
- */
-
-NATIVE_CHAR *
-acpi_ex_allocate_name_string (
-	u32                     prefix_count,
-	u32                     num_name_segs);
-
-u32
-acpi_ex_good_char (
-	u32                     character);
-
-acpi_status
-acpi_ex_name_segment (
-	u8                      **in_aml_address,
-	NATIVE_CHAR             *name_string);
-
-acpi_status
-acpi_ex_get_name_string (
-	acpi_object_type8       data_type,
-	u8                      *in_aml_address,
-	NATIVE_CHAR             **out_name_string,
-	u32                     *out_name_length);
-
-acpi_status
-acpi_ex_do_name (
-	acpi_object_type        data_type,
-	operating_mode          load_exec_mode);
-
-
-/*
- * amstore - Object store support
- */
-
-acpi_status
-acpi_ex_store (
-	acpi_operand_object     *val_desc,
-	acpi_operand_object     *dest_desc,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_store_object_to_index (
-	acpi_operand_object     *val_desc,
-	acpi_operand_object     *dest_desc,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_store_object_to_node (
-	acpi_operand_object     *source_desc,
-	acpi_namespace_node     *node,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_store_object_to_object (
-	acpi_operand_object     *source_desc,
-	acpi_operand_object     *dest_desc,
-	acpi_walk_state         *walk_state);
-
-
-/*
- *
- */
-
-acpi_status
-acpi_ex_resolve_object (
-	acpi_operand_object     **source_desc_ptr,
-	acpi_object_type8       target_type,
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ex_store_object (
-	acpi_operand_object     *source_desc,
-	acpi_object_type8       target_type,
-	acpi_operand_object     **target_desc_ptr,
-	acpi_walk_state         *walk_state);
-
-
-/*
- * amcopy - object copy
- */
-
-acpi_status
-acpi_ex_copy_buffer_to_buffer (
-	acpi_operand_object     *source_desc,
-	acpi_operand_object     *target_desc);
-
-acpi_status
-acpi_ex_copy_string_to_string (
-	acpi_operand_object     *source_desc,
-	acpi_operand_object     *target_desc);
-
-acpi_status
-acpi_ex_copy_integer_to_index_field (
-	acpi_operand_object     *source_desc,
-	acpi_operand_object     *target_desc);
-
-acpi_status
-acpi_ex_copy_integer_to_bank_field (
-	acpi_operand_object     *source_desc,
-	acpi_operand_object     *target_desc);
-
-acpi_status
-acpi_ex_copy_data_to_named_field (
-	acpi_operand_object     *source_desc,
-	acpi_namespace_node     *node);
-
-acpi_status
-acpi_ex_copy_integer_to_buffer_field (
-	acpi_operand_object     *source_desc,
-	acpi_operand_object     *target_desc);
-
-/*
- * amutils - interpreter/scanner utilities
- */
-
-acpi_status
-acpi_ex_enter_interpreter (
-	void);
-
-void
-acpi_ex_exit_interpreter (
-	void);
-
-void
-acpi_ex_truncate_for32bit_table (
-	acpi_operand_object     *obj_desc,
-	acpi_walk_state         *walk_state);
-
-u8
-acpi_ex_validate_object_type (
-	acpi_object_type        type);
-
-u8
-acpi_ex_acquire_global_lock (
-	u32                     rule);
-
-acpi_status
-acpi_ex_release_global_lock (
-	u8                      locked);
-
-u32
-acpi_ex_digits_needed (
-	acpi_integer            value,
-	u32                     base);
-
-acpi_status
-acpi_ex_eisa_id_to_string (
-	u32                     numeric_id,
-	NATIVE_CHAR             *out_string);
-
-acpi_status
-acpi_ex_unsigned_integer_to_string (
-	acpi_integer            value,
-	NATIVE_CHAR             *out_string);
-
-
-/*
- * amregion - default Op_region handlers
- */
-
-acpi_status
-acpi_ex_system_memory_space_handler (
-	u32                     function,
-	ACPI_PHYSICAL_ADDRESS   address,
-	u32                     bit_width,
-	u32                     *value,
-	void                    *handler_context,
-	void                    *region_context);
-
-acpi_status
-acpi_ex_system_io_space_handler (
-	u32                     function,
-	ACPI_PHYSICAL_ADDRESS   address,
-	u32                     bit_width,
-	u32                     *value,
-	void                    *handler_context,
-	void                    *region_context);
-
-acpi_status
-acpi_ex_pci_config_space_handler (
-	u32                     function,
-	ACPI_PHYSICAL_ADDRESS   address,
-	u32                     bit_width,
-	u32                     *value,
-	void                    *handler_context,
-	void                    *region_context);
-
-acpi_status
-acpi_ex_cmos_space_handler (
-	u32                     function,
-	ACPI_PHYSICAL_ADDRESS   address,
-	u32                     bit_width,
-	u32                     *value,
-	void                    *handler_context,
-	void                    *region_context);
-
-acpi_status
-acpi_ex_pci_bar_space_handler (
-	u32                     function,
-	ACPI_PHYSICAL_ADDRESS   address,
-	u32                     bit_width,
-	u32                     *value,
-	void                    *handler_context,
-	void                    *region_context);
-
-acpi_status
-acpi_ex_embedded_controller_space_handler (
-	u32                     function,
-	ACPI_PHYSICAL_ADDRESS   address,
-	u32                     bit_width,
-	u32                     *value,
-	void                    *handler_context,
-	void                    *region_context);
-
-acpi_status
-acpi_ex_sm_bus_space_handler (
-	u32                     function,
-	ACPI_PHYSICAL_ADDRESS   address,
-	u32                     bit_width,
-	u32                     *value,
-	void                    *handler_context,
-	void                    *region_context);
-
-
-#endif /* __INTERP_H__ */
diff -urNp linux-5400/drivers/acpi/include/aclocal.h linux-5410/drivers/acpi/include/aclocal.h
--- linux-5400/drivers/acpi/include/aclocal.h
+++ linux-5410/drivers/acpi/include/aclocal.h
@@ -1,973 +0,0 @@
-/******************************************************************************
- *
- * Name: aclocal.h - Internal data types used across the ACPI subsystem
- *       $Revision: 138 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACLOCAL_H__
-#define __ACLOCAL_H__
-
-
-#define WAIT_FOREVER                    ((u32) -1)
-
-typedef void*                           acpi_mutex;
-typedef u32                             ACPI_MUTEX_HANDLE;
-
-
-#define ACPI_MEMORY_MODE                0x01
-#define ACPI_LOGICAL_ADDRESSING         0x00
-#define ACPI_PHYSICAL_ADDRESSING        0x01
-
-/* Object descriptor types */
-
-#define ACPI_CACHED_OBJECT              0x11    /* ORed in when object is cached */
-#define ACPI_DESC_TYPE_STATE            0x20
-#define ACPI_DESC_TYPE_STATE_UPDATE     0x21
-#define ACPI_DESC_TYPE_STATE_PACKAGE    0x22
-#define ACPI_DESC_TYPE_STATE_CONTROL    0x23
-#define ACPI_DESC_TYPE_STATE_RPSCOPE    0x24
-#define ACPI_DESC_TYPE_STATE_PSCOPE     0x25
-#define ACPI_DESC_TYPE_STATE_WSCOPE     0x26
-#define ACPI_DESC_TYPE_STATE_RESULT     0x27
-#define ACPI_DESC_TYPE_STATE_NOTIFY     0x28
-#define ACPI_DESC_TYPE_WALK             0x44
-#define ACPI_DESC_TYPE_PARSER           0x66
-#define ACPI_DESC_TYPE_INTERNAL         0x88
-#define ACPI_DESC_TYPE_NAMED            0xAA
-
-
-/*****************************************************************************
- *
- * Mutex typedefs and structs
- *
- ****************************************************************************/
-
-
-/*
- * Predefined handles for the mutex objects used within the subsystem
- * All mutex objects are automatically created by Acpi_ut_mutex_initialize.
- *
- * The acquire/release ordering protocol is implied via this list.  Mutexes
- * with a lower value must be acquired before mutexes with a higher value.
- *
- * NOTE: any changes here must be reflected in the Acpi_gbl_Mutex_names table also!
- */
-
-#define ACPI_MTX_EXECUTE                0
-#define ACPI_MTX_INTERPRETER            1
-#define ACPI_MTX_PARSER                 2
-#define ACPI_MTX_DISPATCHER             3
-#define ACPI_MTX_TABLES                 4
-#define ACPI_MTX_OP_REGIONS             5
-#define ACPI_MTX_NAMESPACE              6
-#define ACPI_MTX_EVENTS                 7
-#define ACPI_MTX_HARDWARE               8
-#define ACPI_MTX_CACHES                 9
-#define ACPI_MTX_MEMORY                 10
-#define ACPI_MTX_DEBUG_CMD_COMPLETE     11
-#define ACPI_MTX_DEBUG_CMD_READY        12
-
-#define MAX_MTX                         12
-#define NUM_MTX                         MAX_MTX+1
-
-
-#if defined(ACPI_DEBUG) || defined(ENABLE_DEBUGGER)
-#ifdef DEFINE_ACPI_GLOBALS
-
-/* Names for the mutexes used in the subsystem */
-
-static NATIVE_CHAR          *acpi_gbl_mutex_names[] =
-{
-	"ACPI_MTX_Execute",
-	"ACPI_MTX_Interpreter",
-	"ACPI_MTX_Parser",
-	"ACPI_MTX_Dispatcher",
-	"ACPI_MTX_Tables",
-	"ACPI_MTX_Op_regions",
-	"ACPI_MTX_Namespace",
-	"ACPI_MTX_Events",
-	"ACPI_MTX_Hardware",
-	"ACPI_MTX_Caches",
-	"ACPI_MTX_Memory",
-	"ACPI_MTX_Debug_cmd_complete",
-	"ACPI_MTX_Debug_cmd_ready",
-};
-
-#endif
-#endif
-
-
-/* Table for the global mutexes */
-
-typedef struct acpi_mutex_info
-{
-	acpi_mutex                  mutex;
-	u32                         use_count;
-	u32                         owner_id;
-
-} acpi_mutex_info;
-
-/* This owner ID means that the mutex is not in use (unlocked) */
-
-#define ACPI_MUTEX_NOT_ACQUIRED         (u32) (-1)
-
-
-/* Lock flag parameter for various interfaces */
-
-#define ACPI_MTX_DO_NOT_LOCK            0
-#define ACPI_MTX_LOCK                   1
-
-
-typedef u16                             acpi_owner_id;
-#define OWNER_TYPE_TABLE                0x0
-#define OWNER_TYPE_METHOD               0x1
-#define FIRST_METHOD_ID                 0x0000
-#define FIRST_TABLE_ID                  0x8000
-
-/* TBD: [Restructure] get rid of the need for this! */
-
-#define TABLE_ID_DSDT                   (acpi_owner_id) 0x8000
-
-
-/* Field access granularities */
-
-#define ACPI_FIELD_BYTE_GRANULARITY     1
-#define ACPI_FIELD_WORD_GRANULARITY     2
-#define ACPI_FIELD_DWORD_GRANULARITY    4
-#define ACPI_FIELD_QWORD_GRANULARITY    8
-
-/*****************************************************************************
- *
- * Namespace typedefs and structs
- *
- ****************************************************************************/
-
-
-/* Operational modes of the AML interpreter/scanner */
-
-typedef enum
-{
-	IMODE_LOAD_PASS1                = 0x01,
-	IMODE_LOAD_PASS2                = 0x02,
-	IMODE_EXECUTE                   = 0x0E
-
-} operating_mode;
-
-
-/*
- * The Node describes a named object that appears in the AML
- * An Acpi_node is used to store Nodes.
- *
- * Data_type is used to differentiate between internal descriptors, and MUST
- * be the first byte in this structure.
- */
-
-typedef struct acpi_node
-{
-	u8                      data_type;
-	u8                      type;           /* Type associated with this name */
-	u16                     owner_id;
-	u32                     name;           /* ACPI Name, always 4 chars per ACPI spec */
-
-
-	union acpi_operand_obj  *object;        /* Pointer to attached ACPI object (optional) */
-	struct acpi_node        *child;         /* first child */
-	struct acpi_node        *peer;          /* Next peer*/
-	u16                     reference_count; /* Current count of references and children */
-	u8                      flags;
-
-} acpi_namespace_node;
-
-
-#define ENTRY_NOT_FOUND             NULL
-
-
-/* Node flags */
-
-#define ANOBJ_AML_ATTACHMENT            0x01
-#define ANOBJ_END_OF_PEER_LIST          0x02
-#define ANOBJ_DATA_WIDTH_32             0x04     /* Parent table is 64-bits */
-#define ANOBJ_METHOD_ARG                0x08
-#define ANOBJ_METHOD_LOCAL              0x10
-#define ANOBJ_METHOD_NO_RETVAL          0x20
-#define ANOBJ_METHOD_SOME_NO_RETVAL     0x40
-
-#define ANOBJ_IS_BIT_OFFSET             0x80
-
-
-/*
- * ACPI Table Descriptor.  One per ACPI table
- */
-typedef struct acpi_table_desc
-{
-	struct acpi_table_desc  *prev;
-	struct acpi_table_desc  *next;
-	struct acpi_table_desc  *installed_desc;
-	acpi_table_header       *pointer;
-	void                    *base_pointer;
-	u8                      *aml_start;
-	u64                     physical_address;
-	u32                     aml_length;
-	u32                     length;
-	u32                     count;
-	acpi_owner_id           table_id;
-	u8                      type;
-	u8                      allocation;
-	u8                      loaded_into_namespace;
-
-} acpi_table_desc;
-
-
-typedef struct
-{
-	NATIVE_CHAR             *search_for;
-	acpi_handle             *list;
-	u32                     *count;
-
-} find_context;
-
-
-typedef struct
-{
-	acpi_namespace_node     *node;
-} ns_search_data;
-
-
-/*
- * Predefined Namespace items
- */
-typedef struct
-{
-	NATIVE_CHAR             *name;
-	acpi_object_type8       type;
-	NATIVE_CHAR             *val;
-
-} predefined_names;
-
-
-/* Object types used during package copies */
-
-
-#define ACPI_COPY_TYPE_SIMPLE           0
-#define ACPI_COPY_TYPE_PACKAGE          1
-
-/* Info structure used to convert external<->internal namestrings */
-
-typedef struct acpi_namestring_info
-{
-	NATIVE_CHAR             *external_name;
-	NATIVE_CHAR             *next_external_char;
-	NATIVE_CHAR             *internal_name;
-	u32                     length;
-	u32                     num_segments;
-	u32                     num_carats;
-	u8                      fully_qualified;
-
-} acpi_namestring_info;
-
-
-/* Field creation info */
-
-typedef struct
-{
-	acpi_namespace_node     *region_node;
-	acpi_namespace_node     *field_node;
-	acpi_namespace_node     *register_node;
-	acpi_namespace_node     *data_register_node;
-	u32                     bank_value;
-	u32                     field_bit_position;
-	u32                     field_bit_length;
-	u8                      field_flags;
-	u8                      field_type;
-
-} ACPI_CREATE_FIELD_INFO;
-
-/*
- * Field flags: Bits 00 - 03 : Access_type (Any_acc, Byte_acc, etc.)
- *                   04      : Lock_rule (1 == Lock)
- *                   05 - 06 : Update_rule
- */
-
-#define FIELD_ACCESS_TYPE_MASK      0x0F
-#define FIELD_LOCK_RULE_MASK        0x10
-#define FIELD_UPDATE_RULE_MASK      0x60
-
-
-/*****************************************************************************
- *
- * Event typedefs and structs
- *
- ****************************************************************************/
-
-
-/* Status bits. */
-
-#define ACPI_STATUS_PMTIMER             0x0001
-#define ACPI_STATUS_BUSMASTER           0x0010
-#define ACPI_STATUS_GLOBAL              0x0020
-#define ACPI_STATUS_POWER_BUTTON        0x0100
-#define ACPI_STATUS_SLEEP_BUTTON        0x0200
-#define ACPI_STATUS_RTC_ALARM           0x0400
-
-/* Enable bits. */
-
-#define ACPI_ENABLE_PMTIMER             0x0001
-#define ACPI_ENABLE_GLOBAL              0x0020
-#define ACPI_ENABLE_POWER_BUTTON        0x0100
-#define ACPI_ENABLE_SLEEP_BUTTON        0x0200
-#define ACPI_ENABLE_RTC_ALARM           0x0400
-
-
-/*
- * Entry in the Address_space (AKA Operation Region) table
- */
-
-typedef struct
-{
-	acpi_adr_space_handler  handler;
-	void                    *context;
-
-} acpi_adr_space_info;
-
-
-/* Values and addresses of the GPE registers (both banks) */
-
-typedef struct
-{
-	u16                     status_addr;    /* Address of status reg */
-	u16                     enable_addr;    /* Address of enable reg */
-	u8                      status;         /* Current value of status reg */
-	u8                      enable;         /* Current value of enable reg */
-	u8                      wake_enable;    /* Mask of bits to keep enabled when sleeping */
-	u8                      gpe_base;       /* Base GPE number */
-
-} acpi_gpe_registers;
-
-
-#define ACPI_GPE_LEVEL_TRIGGERED        1
-#define ACPI_GPE_EDGE_TRIGGERED         2
-
-
-/* Information about each particular GPE level */
-
-typedef struct
-{
-	u8                      type;           /* Level or Edge */
-
-	acpi_handle             method_handle;  /* Method handle for direct (fast) execution */
-	acpi_gpe_handler        handler;        /* Address of handler, if any */
-	void                    *context;       /* Context to be passed to handler */
-
-} acpi_gpe_level_info;
-
-
-/* Information about each particular fixed event */
-
-typedef struct
-{
-	acpi_event_handler      handler;        /* Address of handler. */
-	void                    *context;       /* Context to be passed to handler */
-
-} acpi_fixed_event_info;
-
-
-/* Information used during field processing */
-
-typedef struct
-{
-	u8                      skip_field;
-	u8                      field_flag;
-	u32                     pkg_length;
-
-} acpi_field_info;
-
-
-/*****************************************************************************
- *
- * Generic "state" object for stacks
- *
- ****************************************************************************/
-
-
-#define CONTROL_NORMAL                  0xC0
-#define CONTROL_CONDITIONAL_EXECUTING   0xC1
-#define CONTROL_PREDICATE_EXECUTING     0xC2
-#define CONTROL_PREDICATE_FALSE         0xC3
-#define CONTROL_PREDICATE_TRUE          0xC4
-
-
-/* Forward declarations */
-struct acpi_walk_state;
-struct acpi_walk_list;
-struct acpi_parse_obj;
-struct acpi_obj_mutex;
-
-
-#define ACPI_STATE_COMMON                  /* Two 32-bit fields and a pointer */\
-	u8                      data_type;          /* To differentiate various internal objs */\
-	u8                      flags; \
-	u16                     value; \
-	u16                     state; \
-	u16                     acpi_eval; \
-	void                    *next; \
-
-typedef struct acpi_common_state
-{
-	ACPI_STATE_COMMON
-} acpi_common_state;
-
-
-/*
- * Update state - used to traverse complex objects such as packages
- */
-typedef struct acpi_update_state
-{
-	ACPI_STATE_COMMON
-	union acpi_operand_obj  *object;
-
-} acpi_update_state;
-
-
-/*
- * Pkg state - used to traverse nested package structures
- */
-typedef struct acpi_pkg_state
-{
-	ACPI_STATE_COMMON
-	union acpi_operand_obj  *source_object;
-	union acpi_operand_obj  *dest_object;
-	struct acpi_walk_state  *walk_state;
-	void                    *this_target_obj;
-	u32                     num_packages;
-	u16                     index;
-
-} acpi_pkg_state;
-
-
-/*
- * Control state - one per if/else and while constructs.
- * Allows nesting of these constructs
- */
-typedef struct acpi_control_state
-{
-	ACPI_STATE_COMMON
-	struct acpi_parse_obj   *predicate_op;
-	u8                      *aml_predicate_start; /* Start of if/while predicate */
-
-} acpi_control_state;
-
-
-/*
- * Scope state - current scope during namespace lookups
- */
-typedef struct acpi_scope_state
-{
-	ACPI_STATE_COMMON
-	acpi_namespace_node     *node;
-
-} acpi_scope_state;
-
-
-typedef struct acpi_pscope_state
-{
-	ACPI_STATE_COMMON
-	struct acpi_parse_obj   *op;            /* current op being parsed */
-	u8                      *arg_end;       /* current argument end */
-	u8                      *pkg_end;       /* current package end */
-	u32                     arg_list;       /* next argument to parse */
-	u32                     arg_count;      /* Number of fixed arguments */
-
-} acpi_pscope_state;
-
-
-/*
- * Result values - used to accumulate the results of nested
- * AML arguments
- */
-typedef struct acpi_result_values
-{
-	ACPI_STATE_COMMON
-	union acpi_operand_obj  *obj_desc [OBJ_NUM_OPERANDS];
-	u8                      num_results;
-	u8                      last_insert;
-
-} acpi_result_values;
-
-
-typedef
-acpi_status (*acpi_parse_downwards) (
-	struct acpi_walk_state  *walk_state,
-	struct acpi_parse_obj   **out_op);
-
-typedef
-acpi_status (*acpi_parse_upwards) (
-	struct acpi_walk_state  *walk_state);
-
-
-/*
- * Notify info - used to pass info to the deferred notify
- * handler/dispatcher.
- */
-typedef struct acpi_notify_info
-{
-	ACPI_STATE_COMMON
-	acpi_namespace_node     *node;
-	union acpi_operand_obj  *handler_obj;
-
-} acpi_notify_info;
-
-
-/* Generic state is union of structs above */
-
-typedef union acpi_gen_state
-{
-	acpi_common_state       common;
-	acpi_control_state      control;
-	acpi_update_state       update;
-	acpi_scope_state        scope;
-	acpi_pscope_state       parse_scope;
-	acpi_pkg_state          pkg;
-	acpi_result_values      results;
-	acpi_notify_info        notify;
-
-} acpi_generic_state;
-
-
-/*****************************************************************************
- *
- * Interpreter typedefs and structs
- *
- ****************************************************************************/
-
-typedef
-acpi_status (*ACPI_EXECUTE_OP) (
-	struct acpi_walk_state  *walk_state);
-
-
-/*****************************************************************************
- *
- * Parser typedefs and structs
- *
- ****************************************************************************/
-
-/*
- * AML opcode, name, and argument layout
- */
-typedef struct acpi_opcode_info
-{
-	u32                     parse_args;     /* Grammar/Parse time arguments */
-	u32                     runtime_args;   /* Interpret time arguments */
-	u16                     flags;          /* Misc flags */
-	u8                      class;          /* Opcode class */
-	u8                      type;           /* Opcode type */
-
-#ifdef _OPCODE_NAMES
-	NATIVE_CHAR             *name;          /* op name (debug only) */
-#endif
-
-} acpi_opcode_info;
-
-
-typedef union acpi_parse_val
-{
-	acpi_integer            integer;        /* integer constant (Up to 64 bits) */
-	uint64_struct           integer64;      /* Structure overlay for 2 32-bit Dwords */
-	u32                     integer32;      /* integer constant, 32 bits only */
-	u16                     integer16;      /* integer constant, 16 bits only */
-	u8                      integer8;       /* integer constant, 8 bits only */
-	u32                     size;           /* bytelist or field size */
-	NATIVE_CHAR             *string;        /* NULL terminated string */
-	u8                      *buffer;        /* buffer or string */
-	NATIVE_CHAR             *name;          /* NULL terminated string */
-	struct acpi_parse_obj   *arg;           /* arguments and contained ops */
-
-} acpi_parse_value;
-
-
-#define ACPI_PARSE_COMMON \
-	u8                      data_type;      /* To differentiate various internal objs */\
-	u8                      flags;          /* Type of Op */\
-	u16                     opcode;         /* AML opcode */\
-	u32                     aml_offset;     /* offset of declaration in AML */\
-	struct acpi_parse_obj   *parent;        /* parent op */\
-	struct acpi_parse_obj   *next;          /* next op */\
-	DEBUG_ONLY_MEMBERS (\
-	NATIVE_CHAR             op_name[16])    /* op name (debug only) */\
-			  /* NON-DEBUG members below: */\
-	acpi_namespace_node     *node;          /* for use by interpreter */\
-	acpi_parse_value        value;          /* Value or args associated with the opcode */\
-
-
-/*
- * generic operation (eg. If, While, Store)
- */
-typedef struct acpi_parse_obj
-{
-	ACPI_PARSE_COMMON
-} acpi_parse_object;
-
-
-/*
- * Extended Op for named ops (Scope, Method, etc.), deferred ops (Methods and Op_regions),
- * and bytelists.
- */
-typedef struct acpi_parse2_obj
-{
-	ACPI_PARSE_COMMON
-	u8                      *data;          /* AML body or bytelist data */
-	u32                     length;         /* AML length */
-	u32                     name;           /* 4-byte name or zero if no name */
-
-} acpi_parse2_object;
-
-
-/*
- * Parse state - one state per parser invocation and each control
- * method.
- */
-typedef struct acpi_parse_state
-{
-	u32                     aml_size;
-	u8                      *aml_start;     /* first AML byte */
-	u8                      *aml;           /* next AML byte */
-	u8                      *aml_end;       /* (last + 1) AML byte */
-	u8                      *pkg_start;     /* current package begin */
-	u8                      *pkg_end;       /* current package end */
-
-	struct acpi_parse_obj   *start_op;      /* root of parse tree */
-	struct acpi_node        *start_node;
-	union acpi_gen_state    *scope;         /* current scope */
-
-
-	struct acpi_parse_obj   *start_scope;
-
-
-} acpi_parse_state;
-
-
-/*****************************************************************************
- *
- * Hardware and PNP
- *
- ****************************************************************************/
-
-
-/* PCI */
-#define PCI_ROOT_HID_STRING             "PNP0A03"
-
-/*
- * The #define's and enum below establish an abstract way of identifying what
- * register block and register is to be accessed.  Do not change any of the
- * values as they are used in switch statements and offset calculations.
- */
-
-#define REGISTER_BLOCK_MASK             0xFF00  /* Register Block Id    */
-#define BIT_IN_REGISTER_MASK            0x00FF  /* Bit Id in the Register Block Id    */
-#define BYTE_IN_REGISTER_MASK           0x00FF  /* Register Offset in the Register Block    */
-
-#define REGISTER_BLOCK_ID(reg_id)       (reg_id & REGISTER_BLOCK_MASK)
-#define REGISTER_BIT_ID(reg_id)         (reg_id & BIT_IN_REGISTER_MASK)
-#define REGISTER_OFFSET(reg_id)         (reg_id & BYTE_IN_REGISTER_MASK)
-
-/*
- * Access Rule
- *  To access a Register Bit:
- *  -> Use Bit Name (= Register Block Id | Bit Id) defined in the enum.
- *
- *  To access a Register:
- *  -> Use Register Id (= Register Block Id | Register Offset)
- */
-
-
-/*
- * Register Block Id
- */
-#define PM1_STS                         0x0100
-#define PM1_EN                          0x0200
-#define PM1_CONTROL                     0x0300
-#define PM1A_CONTROL                    0x0400
-#define PM1B_CONTROL                    0x0500
-#define PM2_CONTROL                     0x0600
-#define PM_TIMER                        0x0700
-#define PROCESSOR_BLOCK                 0x0800
-#define GPE0_STS_BLOCK                  0x0900
-#define GPE0_EN_BLOCK                   0x0A00
-#define GPE1_STS_BLOCK                  0x0B00
-#define GPE1_EN_BLOCK                   0x0C00
-#define SMI_CMD_BLOCK                   0x0D00
-
-/*
- * Address space bitmasks for mmio or io spaces
- */
-
-#define SMI_CMD_ADDRESS_SPACE           0x01
-#define PM1_BLK_ADDRESS_SPACE           0x02
-#define PM2_CNT_BLK_ADDRESS_SPACE       0x04
-#define PM_TMR_BLK_ADDRESS_SPACE        0x08
-#define GPE0_BLK_ADDRESS_SPACE          0x10
-#define GPE1_BLK_ADDRESS_SPACE          0x20
-
-/*
- * Control bit definitions
- */
-#define TMR_STS                         (PM1_STS | 0x01)
-#define BM_STS                          (PM1_STS | 0x02)
-#define GBL_STS                         (PM1_STS | 0x03)
-#define PWRBTN_STS                      (PM1_STS | 0x04)
-#define SLPBTN_STS                      (PM1_STS | 0x05)
-#define RTC_STS                         (PM1_STS | 0x06)
-#define WAK_STS                         (PM1_STS | 0x07)
-
-#define TMR_EN                          (PM1_EN | 0x01)
-			 /* no BM_EN */
-#define GBL_EN                          (PM1_EN | 0x03)
-#define PWRBTN_EN                       (PM1_EN | 0x04)
-#define SLPBTN_EN                       (PM1_EN | 0x05)
-#define RTC_EN                          (PM1_EN | 0x06)
-#define WAK_EN                          (PM1_EN | 0x07)
-
-#define SCI_EN                          (PM1_CONTROL | 0x01)
-#define BM_RLD                          (PM1_CONTROL | 0x02)
-#define GBL_RLS                         (PM1_CONTROL | 0x03)
-#define SLP_TYPE_A                      (PM1_CONTROL | 0x04)
-#define SLP_TYPE_B                      (PM1_CONTROL | 0x05)
-#define SLP_EN                          (PM1_CONTROL | 0x06)
-
-#define ARB_DIS                         (PM2_CONTROL | 0x01)
-
-#define TMR_VAL                         (PM_TIMER | 0x01)
-
-#define GPE0_STS                        (GPE0_STS_BLOCK | 0x01)
-#define GPE0_EN                         (GPE0_EN_BLOCK  | 0x01)
-
-#define GPE1_STS                        (GPE1_STS_BLOCK | 0x01)
-#define GPE1_EN                         (GPE1_EN_BLOCK  | 0x01)
-
-
-#define TMR_STS_MASK                    0x0001
-#define BM_STS_MASK                     0x0010
-#define GBL_STS_MASK                    0x0020
-#define PWRBTN_STS_MASK                 0x0100
-#define SLPBTN_STS_MASK                 0x0200
-#define RTC_STS_MASK                    0x0400
-#define WAK_STS_MASK                    0x8000
-
-#define ALL_FIXED_STS_BITS              (TMR_STS_MASK   | BM_STS_MASK  | GBL_STS_MASK \
-					  | PWRBTN_STS_MASK | SLPBTN_STS_MASK \
-					  | RTC_STS_MASK | WAK_STS_MASK)
-
-#define TMR_EN_MASK                     0x0001
-#define GBL_EN_MASK                     0x0020
-#define PWRBTN_EN_MASK                  0x0100
-#define SLPBTN_EN_MASK                  0x0200
-#define RTC_EN_MASK                     0x0400
-
-#define SCI_EN_MASK                     0x0001
-#define BM_RLD_MASK                     0x0002
-#define GBL_RLS_MASK                    0x0004
-#define SLP_TYPE_X_MASK                 0x1C00
-#define SLP_EN_MASK                     0x2000
-
-#define ARB_DIS_MASK                    0x0001
-#define TMR_VAL_MASK                    0xFFFFFFFF
-
-#define GPE0_STS_MASK
-#define GPE0_EN_MASK
-
-#define GPE1_STS_MASK
-#define GPE1_EN_MASK
-
-
-#define ACPI_READ                       1
-#define ACPI_WRITE                      2
-
-
-/*****************************************************************************
- *
- * Resource descriptors
- *
- ****************************************************************************/
-
-
-/* Resource_type values */
-
-#define RESOURCE_TYPE_MEMORY_RANGE              0
-#define RESOURCE_TYPE_IO_RANGE                  1
-#define RESOURCE_TYPE_BUS_NUMBER_RANGE          2
-
-/* Resource descriptor types and masks */
-
-#define RESOURCE_DESC_TYPE_LARGE                0x80
-#define RESOURCE_DESC_TYPE_SMALL                0x00
-
-#define RESOURCE_DESC_TYPE_MASK                 0x80
-#define RESOURCE_DESC_SMALL_MASK                0x78        /* Only bits 6:3 contain the type */
-
-
-/*
- * Small resource descriptor types
- * Note: The 3 length bits (2:0) must be zero
- */
-#define RESOURCE_DESC_IRQ_FORMAT                0x20
-#define RESOURCE_DESC_DMA_FORMAT                0x28
-#define RESOURCE_DESC_START_DEPENDENT           0x30
-#define RESOURCE_DESC_END_DEPENDENT             0x38
-#define RESOURCE_DESC_IO_PORT                   0x40
-#define RESOURCE_DESC_FIXED_IO_PORT             0x48
-#define RESOURCE_DESC_SMALL_VENDOR              0x70
-#define RESOURCE_DESC_END_TAG                   0x78
-
-/*
- * Large resource descriptor types
- */
-
-#define RESOURCE_DESC_MEMORY_24                 0x81
-#define RESOURCE_DESC_GENERAL_REGISTER          0x82
-#define RESOURCE_DESC_LARGE_VENDOR              0x84
-#define RESOURCE_DESC_MEMORY_32                 0x85
-#define RESOURCE_DESC_FIXED_MEMORY_32           0x86
-#define RESOURCE_DESC_DWORD_ADDRESS_SPACE       0x87
-#define RESOURCE_DESC_WORD_ADDRESS_SPACE        0x88
-#define RESOURCE_DESC_EXTENDED_XRUPT            0x89
-#define RESOURCE_DESC_QWORD_ADDRESS_SPACE       0x8A
-
-
-/* String version of device HIDs and UIDs */
-
-#define ACPI_DEVICE_ID_LENGTH                   0x09
-
-typedef struct
-{
-	char            buffer[ACPI_DEVICE_ID_LENGTH];
-
-} acpi_device_id;
-
-
-/*****************************************************************************
- *
- * Miscellaneous
- *
- ****************************************************************************/
-
-#define ASCII_ZERO                      0x30
-
-/*****************************************************************************
- *
- * Debugger
- *
- ****************************************************************************/
-
-typedef struct dbmethodinfo
-{
-	acpi_handle             thread_gate;
-	NATIVE_CHAR             *name;
-	NATIVE_CHAR             **args;
-	u32                     flags;
-	u32                     num_loops;
-	NATIVE_CHAR             pathname[128];
-
-} db_method_info;
-
-
-/*****************************************************************************
- *
- * Debug
- *
- ****************************************************************************/
-
-typedef struct
-{
-	u32                     component_id;
-	NATIVE_CHAR             *proc_name;
-	NATIVE_CHAR             *module_name;
-
-} acpi_debug_print_info;
-
-
-/* Entry for a memory allocation (debug only) */
-
-
-#define MEM_MALLOC                      0
-#define MEM_CALLOC                      1
-#define MAX_MODULE_NAME                 16
-
-#define ACPI_COMMON_DEBUG_MEM_HEADER \
-	struct acpi_debug_mem_block *previous; \
-	struct acpi_debug_mem_block *next; \
-	u32                         size; \
-	u32                         component; \
-	u32                         line; \
-	NATIVE_CHAR                 module[MAX_MODULE_NAME]; \
-	u8                          alloc_type;
-
-
-typedef struct
-{
-	ACPI_COMMON_DEBUG_MEM_HEADER
-
-} acpi_debug_mem_header;
-
-typedef struct acpi_debug_mem_block
-{
-	ACPI_COMMON_DEBUG_MEM_HEADER
-	u64                         user_space;
-
-} acpi_debug_mem_block;
-
-
-#define ACPI_MEM_LIST_GLOBAL            0
-#define ACPI_MEM_LIST_NSNODE            1
-
-#define ACPI_MEM_LIST_FIRST_CACHE_LIST  2
-#define ACPI_MEM_LIST_STATE             2
-#define ACPI_MEM_LIST_PSNODE            3
-#define ACPI_MEM_LIST_PSNODE_EXT        4
-#define ACPI_MEM_LIST_OPERAND           5
-#define ACPI_MEM_LIST_WALK              6
-#define ACPI_MEM_LIST_MAX               6
-#define ACPI_NUM_MEM_LISTS              7
-
-
-typedef struct
-{
-	void                        *list_head;
-	u16                         link_offset;
-	u16                         max_cache_depth;
-	u16                         cache_depth;
-	u16                         object_size;
-
-#ifdef ACPI_DBG_TRACK_ALLOCATIONS
-
-	/* Statistics for debug memory tracking only */
-
-	u32                         total_allocated;
-	u32                         total_freed;
-	u32                         current_total_size;
-	u32                         cache_requests;
-	u32                         cache_hits;
-	char                        *list_name;
-#endif
-
-} ACPI_MEMORY_LIST;
-
-
-#endif /* __ACLOCAL_H__ */
diff -urNp linux-5400/drivers/acpi/include/acmacros.h linux-5410/drivers/acpi/include/acmacros.h
--- linux-5400/drivers/acpi/include/acmacros.h
+++ linux-5410/drivers/acpi/include/acmacros.h
@@ -1,584 +0,0 @@
-/******************************************************************************
- *
- * Name: acmacros.h - C macros for the entire subsystem.
- *       $Revision: 97 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACMACROS_H__
-#define __ACMACROS_H__
-
-
-/*
- * Data manipulation macros
- */
-
-#ifndef LOWORD
-#define LOWORD(l)                       ((u16)(NATIVE_UINT)(l))
-#endif
-
-#ifndef HIWORD
-#define HIWORD(l)                       ((u16)((((NATIVE_UINT)(l)) >> 16) & 0xFFFF))
-#endif
-
-#ifndef LOBYTE
-#define LOBYTE(l)                       ((u8)(u16)(l))
-#endif
-
-#ifndef HIBYTE
-#define HIBYTE(l)                       ((u8)((((u16)(l)) >> 8) & 0xFF))
-#endif
-
-#define BIT0(x)                         ((((x) & 0x01) > 0) ? 1 : 0)
-#define BIT1(x)                         ((((x) & 0x02) > 0) ? 1 : 0)
-#define BIT2(x)                         ((((x) & 0x04) > 0) ? 1 : 0)
-
-#define BIT3(x)                         ((((x) & 0x08) > 0) ? 1 : 0)
-#define BIT4(x)                         ((((x) & 0x10) > 0) ? 1 : 0)
-#define BIT5(x)                         ((((x) & 0x20) > 0) ? 1 : 0)
-#define BIT6(x)                         ((((x) & 0x40) > 0) ? 1 : 0)
-#define BIT7(x)                         ((((x) & 0x80) > 0) ? 1 : 0)
-
-#define LOW_BASE(w)                     ((u16) ((w) & 0x0000FFFF))
-#define MID_BASE(b)                     ((u8) (((b) & 0x00FF0000) >> 16))
-#define HI_BASE(b)                      ((u8) (((b) & 0xFF000000) >> 24))
-#define LOW_LIMIT(w)                    ((u16) ((w) & 0x0000FFFF))
-#define HI_LIMIT(b)                     ((u8) (((b) & 0x00FF0000) >> 16))
-
-
-#ifdef _IA16
-/*
- * For 16-bit addresses, we have to assume that the upper 32 bits
- * are zero.
- */
-#ifndef LODWORD
-#define LODWORD(l)                      (l)
-#endif
-
-#ifndef HIDWORD
-#define HIDWORD(l)                      (0)
-#endif
-
-#define ACPI_GET_ADDRESS(a)             ((a).lo)
-#define ACPI_STORE_ADDRESS(a,b)         {(a).hi=0;(a).lo=(b);}
-#define ACPI_VALID_ADDRESS(a)           ((a).hi | (a).lo)
-
-#else
-#ifdef ACPI_NO_INTEGER64_SUPPORT
-/*
- * acpi_integer is 32-bits, no 64-bit support on this platform
- */
-#ifndef LODWORD
-#define LODWORD(l)                      ((u32)(l))
-#endif
-
-#ifndef HIDWORD
-#define HIDWORD(l)                      (0)
-#endif
-
-#define ACPI_GET_ADDRESS(a)             (a)
-#define ACPI_STORE_ADDRESS(a,b)         ((a)=(b))
-#define ACPI_VALID_ADDRESS(a)           (a)
-
-#else
-
-/*
- * Full 64-bit address/integer on both 32-bit and 64-bit platforms
- */
-#ifndef LODWORD
-#define LODWORD(l)                      ((u32)(u64)(l))
-#endif
-
-#ifndef HIDWORD
-#define HIDWORD(l)                      ((u32)(((*(uint64_struct *)(&l))).hi))
-#endif
-
-#define ACPI_GET_ADDRESS(a)             (a)
-#define ACPI_STORE_ADDRESS(a,b)         ((a)=(b))
-#define ACPI_VALID_ADDRESS(a)           (a)
-#endif
-#endif
-
- /*
-  * Extract a byte of data using a pointer.  Any more than a byte and we
-  * get into potential aligment issues -- see the STORE macros below
-  */
-#define GET8(addr)                      (*(u8*)(addr))
-
-/* Pointer arithmetic */
-
-
-#define POINTER_ADD(t,a,b)              (t *) ((NATIVE_UINT)(a) + (NATIVE_UINT)(b))
-#define POINTER_DIFF(a,b)               ((u32) ((NATIVE_UINT)(a) - (NATIVE_UINT)(b)))
-
-/*
- * Macros for moving data around to/from buffers that are possibly unaligned.
- * If the hardware supports the transfer of unaligned data, just do the store.
- * Otherwise, we have to move one byte at a time.
- */
-
-#ifdef _HW_ALIGNMENT_SUPPORT
-
-/* The hardware supports unaligned transfers, just do the move */
-
-#define MOVE_UNALIGNED16_TO_16(d,s)     *(u16*)(d) = *(u16*)(s)
-#define MOVE_UNALIGNED32_TO_32(d,s)     *(u32*)(d) = *(u32*)(s)
-#define MOVE_UNALIGNED16_TO_32(d,s)     *(u32*)(d) = *(u16*)(s)
-#define MOVE_UNALIGNED64_TO_64(d,s)     *(u64*)(d) = *(u64*)(s)
-
-#else
-/*
- * The hardware does not support unaligned transfers.  We must move the
- * data one byte at a time.  These macros work whether the source or
- * the destination (or both) is/are unaligned.
- */
-
-#define MOVE_UNALIGNED16_TO_16(d,s)     {((u8 *)(d))[0] = ((u8 *)(s))[0];\
-	 ((u8 *)(d))[1] = ((u8 *)(s))[1];}
-
-#define MOVE_UNALIGNED32_TO_32(d,s)     {((u8 *)(d))[0] = ((u8 *)(s))[0];\
-			  ((u8 *)(d))[1] = ((u8 *)(s))[1];\
-			  ((u8 *)(d))[2] = ((u8 *)(s))[2];\
-			  ((u8 *)(d))[3] = ((u8 *)(s))[3];}
-
-#define MOVE_UNALIGNED16_TO_32(d,s)     {(*(u32*)(d)) = 0; MOVE_UNALIGNED16_TO_16(d,s);}
-
-#define MOVE_UNALIGNED64_TO_64(d,s)     {((u8 *)(d))[0] = ((u8 *)(s))[0];\
-					   ((u8 *)(d))[1] = ((u8 *)(s))[1];\
-					   ((u8 *)(d))[2] = ((u8 *)(s))[2];\
-					   ((u8 *)(d))[3] = ((u8 *)(s))[3];\
-					   ((u8 *)(d))[4] = ((u8 *)(s))[4];\
-					   ((u8 *)(d))[5] = ((u8 *)(s))[5];\
-					   ((u8 *)(d))[6] = ((u8 *)(s))[6];\
-					   ((u8 *)(d))[7] = ((u8 *)(s))[7];}
-
-#endif
-
-
-/*
- * Fast power-of-two math macros for non-optimized compilers
- */
-
-#define _DIV(value,power_of2)           ((u32) ((value) >> (power_of2)))
-#define _MUL(value,power_of2)           ((u32) ((value) << (power_of2)))
-#define _MOD(value,divisor)             ((u32) ((value) & ((divisor) -1)))
-
-#define DIV_2(a)                        _DIV(a,1)
-#define MUL_2(a)                        _MUL(a,1)
-#define MOD_2(a)                        _MOD(a,2)
-
-#define DIV_4(a)                        _DIV(a,2)
-#define MUL_4(a)                        _MUL(a,2)
-#define MOD_4(a)                        _MOD(a,4)
-
-#define DIV_8(a)                        _DIV(a,3)
-#define MUL_8(a)                        _MUL(a,3)
-#define MOD_8(a)                        _MOD(a,8)
-
-#define DIV_16(a)                       _DIV(a,4)
-#define MUL_16(a)                       _MUL(a,4)
-#define MOD_16(a)                       _MOD(a,16)
-
-
-/*
- * Rounding macros (Power of two boundaries only)
- */
-#define ROUND_DOWN(value,boundary)      ((value) & (~((boundary)-1)))
-#define ROUND_UP(value,boundary)        (((value) + ((boundary)-1)) & (~((boundary)-1)))
-
-#define ROUND_DOWN_TO_32_BITS(a)        ROUND_DOWN(a,4)
-#define ROUND_DOWN_TO_64_BITS(a)        ROUND_DOWN(a,8)
-#define ROUND_DOWN_TO_NATIVE_WORD(a)    ROUND_DOWN(a,ALIGNED_ADDRESS_BOUNDARY)
-
-#define ROUND_UP_TO_32_bITS(a)          ROUND_UP(a,4)
-#define ROUND_UP_TO_64_bITS(a)          ROUND_UP(a,8)
-#define ROUND_UP_TO_NATIVE_WORD(a)      ROUND_UP(a,ALIGNED_ADDRESS_BOUNDARY)
-
-#define ROUND_PTR_UP_TO_4(a,b)          ((b *)(((NATIVE_UINT)(a) + 3) & ~3))
-#define ROUND_PTR_UP_TO_8(a,b)          ((b *)(((NATIVE_UINT)(a) + 7) & ~7))
-
-#define ROUND_BITS_UP_TO_BYTES(a)       DIV_8((a) + 7)
-#define ROUND_BITS_DOWN_TO_BYTES(a)     DIV_8((a))
-
-#define ROUND_UP_TO_1K(a)               (((a) + 1023) >> 10)
-
-/* Generic (non-power-of-two) rounding */
-
-#define ROUND_UP_TO(value,boundary)     (((value) + ((boundary)-1)) / (boundary))
-
-/*
- * Bitmask creation
- * Bit positions start at zero.
- * MASK_BITS_ABOVE creates a mask starting AT the position and above
- * MASK_BITS_BELOW creates a mask starting one bit BELOW the position
- */
-#define MASK_BITS_ABOVE(position)       (~(((u32)(-1)) << ((u32) (position))))
-#define MASK_BITS_BELOW(position)       (((u32)(-1)) << ((u32) (position)))
-
-
-/* Macros for GAS addressing */
-
-#ifndef _IA16
-
-#define ACPI_PCI_DEVICE_MASK            (u64) 0x0000FFFF00000000
-#define ACPI_PCI_FUNCTION_MASK          (u64) 0x00000000FFFF0000
-#define ACPI_PCI_REGISTER_MASK          (u64) 0x000000000000FFFF
-
-#define ACPI_PCI_FUNCTION(a)            (u16) ((((a) & ACPI_PCI_FUNCTION_MASK) >> 16))
-#define ACPI_PCI_DEVICE(a)              (u16) ((((a) & ACPI_PCI_DEVICE_MASK) >> 32))
-#define ACPI_PCI_REGISTER(a)            (u16) (((a) & ACPI_PCI_REGISTER_MASK))
-
-#else
-
-/* No support for GAS and PCI IDs in 16-bit mode  */
-
-#define ACPI_PCI_FUNCTION(a)            (u16) ((a) & 0xFFFF0000)
-#define ACPI_PCI_DEVICE(a)              (u16) ((a) & 0x0000FFFF)
-#define ACPI_PCI_REGISTER(a)            (u16) ((a) & 0x0000FFFF)
-
-#endif
-
-/*
- * An acpi_handle (which is actually an acpi_namespace_node *) can appear in some contexts,
- * such as on ap_obj_stack, where a pointer to an acpi_operand_object can also
- * appear.  This macro is used to distinguish them.
- *
- * The Data_type field is the first field in both structures.
- */
-#define VALID_DESCRIPTOR_TYPE(d,t)      (((acpi_namespace_node *)d)->data_type == t)
-
-
-/* Macro to test the object type */
-
-#define IS_THIS_OBJECT_TYPE(d,t)        (((acpi_operand_object  *)d)->common.type == (u8)t)
-
-/* Macro to check the table flags for SINGLE or MULTIPLE tables are allowed */
-
-#define IS_SINGLE_TABLE(x)              (((x) & 0x01) == ACPI_TABLE_SINGLE ? 1 : 0)
-
-/*
- * Macro to check if a pointer is within an ACPI table.
- * Parameter (a) is the pointer to check.  Parameter (b) must be defined
- * as a pointer to an acpi_table_header.  (b+1) then points past the header,
- * and ((u8 *)b+b->Length) points one byte past the end of the table.
- */
-#ifndef _IA16
-#define IS_IN_ACPI_TABLE(a,b)           (((u8 *)(a) >= (u8 *)(b + 1)) &&\
-							   ((u8 *)(a) < ((u8 *)b + b->length)))
-
-#else
-#define IS_IN_ACPI_TABLE(a,b)           (_segment)(a) == (_segment)(b) &&\
-									 (((u8 *)(a) >= (u8 *)(b + 1)) &&\
-									 ((u8 *)(a) < ((u8 *)b + b->length)))
-#endif
-
-/*
- * Macros for the master AML opcode table
- */
-#ifdef ACPI_DEBUG
-#define ACPI_OP(name,Pargs,Iargs,class,type,flags)     {Pargs,Iargs,flags,class,type,name}
-#else
-#define ACPI_OP(name,Pargs,Iargs,class,type,flags)     {Pargs,Iargs,flags,class,type}
-#endif
-
-#define ARG_TYPE_WIDTH                  5
-#define ARG_1(x)                        ((u32)(x))
-#define ARG_2(x)                        ((u32)(x) << (1 * ARG_TYPE_WIDTH))
-#define ARG_3(x)                        ((u32)(x) << (2 * ARG_TYPE_WIDTH))
-#define ARG_4(x)                        ((u32)(x) << (3 * ARG_TYPE_WIDTH))
-#define ARG_5(x)                        ((u32)(x) << (4 * ARG_TYPE_WIDTH))
-#define ARG_6(x)                        ((u32)(x) << (5 * ARG_TYPE_WIDTH))
-
-#define ARGI_LIST1(a)                   (ARG_1(a))
-#define ARGI_LIST2(a,b)                 (ARG_1(b)|ARG_2(a))
-#define ARGI_LIST3(a,b,c)               (ARG_1(c)|ARG_2(b)|ARG_3(a))
-#define ARGI_LIST4(a,b,c,d)             (ARG_1(d)|ARG_2(c)|ARG_3(b)|ARG_4(a))
-#define ARGI_LIST5(a,b,c,d,e)           (ARG_1(e)|ARG_2(d)|ARG_3(c)|ARG_4(b)|ARG_5(a))
-#define ARGI_LIST6(a,b,c,d,e,f)         (ARG_1(f)|ARG_2(e)|ARG_3(d)|ARG_4(c)|ARG_5(b)|ARG_6(a))
-
-#define ARGP_LIST1(a)                   (ARG_1(a))
-#define ARGP_LIST2(a,b)                 (ARG_1(a)|ARG_2(b))
-#define ARGP_LIST3(a,b,c)               (ARG_1(a)|ARG_2(b)|ARG_3(c))
-#define ARGP_LIST4(a,b,c,d)             (ARG_1(a)|ARG_2(b)|ARG_3(c)|ARG_4(d))
-#define ARGP_LIST5(a,b,c,d,e)           (ARG_1(a)|ARG_2(b)|ARG_3(c)|ARG_4(d)|ARG_5(e))
-#define ARGP_LIST6(a,b,c,d,e,f)         (ARG_1(a)|ARG_2(b)|ARG_3(c)|ARG_4(d)|ARG_5(e)|ARG_6(f))
-
-#define GET_CURRENT_ARG_TYPE(list)      (list & ((u32) 0x1F))
-#define INCREMENT_ARG_LIST(list)        (list >>= ((u32) ARG_TYPE_WIDTH))
-
-
-/*
- * Build a GAS structure from earlier ACPI table entries (V1.0 and 0.71 extensions)
- *
- * 1) Address space
- * 2) Length in bytes -- convert to length in bits
- * 3) Bit offset is zero
- * 4) Reserved field is zero
- * 5) Expand address to 64 bits
- */
-#define ASL_BUILD_GAS_FROM_ENTRY(a,b,c,d)   {a.address_space_id = (u8) d;\
-											 a.register_bit_width = (u8) MUL_8 (b);\
-											 a.register_bit_offset = 0;\
-											 a.reserved = 0;\
-											 ACPI_STORE_ADDRESS (a.address,c);}
-
-/* ACPI V1.0 entries -- address space is always I/O */
-
-#define ASL_BUILD_GAS_FROM_V1_ENTRY(a,b,c)  ASL_BUILD_GAS_FROM_ENTRY(a,b,c,ACPI_ADR_SPACE_SYSTEM_IO)
-
-
-/*
- * Reporting macros that are never compiled out
- */
-
-#define PARAM_LIST(pl)                  pl
-
-/*
- * Error reporting.  These versions add callers module and line#.  Since
- * _THIS_MODULE gets compiled out when ACPI_DEBUG isn't defined, only
- * use it in debug mode.
- */
-
-#ifdef ACPI_DEBUG
-
-#define REPORT_INFO(fp)                 {acpi_ut_report_info(_THIS_MODULE,__LINE__,_COMPONENT); \
-											acpi_os_printf PARAM_LIST(fp);}
-#define REPORT_ERROR(fp)                {acpi_ut_report_error(_THIS_MODULE,__LINE__,_COMPONENT); \
-											acpi_os_printf PARAM_LIST(fp);}
-#define REPORT_WARNING(fp)              {acpi_ut_report_warning(_THIS_MODULE,__LINE__,_COMPONENT); \
-											acpi_os_printf PARAM_LIST(fp);}
-
-#else
-
-#define REPORT_INFO(fp)                 {acpi_ut_report_info("ACPI",__LINE__,_COMPONENT); \
-											acpi_os_printf PARAM_LIST(fp);}
-#define REPORT_ERROR(fp)                {acpi_ut_report_error("ACPI",__LINE__,_COMPONENT); \
-											acpi_os_printf PARAM_LIST(fp);}
-#define REPORT_WARNING(fp)              {acpi_ut_report_warning("ACPI",__LINE__,_COMPONENT); \
-											acpi_os_printf PARAM_LIST(fp);}
-
-#endif
-
-/* Error reporting.  These versions pass thru the module and line# */
-
-#define _REPORT_INFO(a,b,c,fp)          {acpi_ut_report_info(a,b,c); \
-											acpi_os_printf PARAM_LIST(fp);}
-#define _REPORT_ERROR(a,b,c,fp)         {acpi_ut_report_error(a,b,c); \
-											acpi_os_printf PARAM_LIST(fp);}
-#define _REPORT_WARNING(a,b,c,fp)       {acpi_ut_report_warning(a,b,c); \
-											acpi_os_printf PARAM_LIST(fp);}
-
-/*
- * Debug macros that are conditionally compiled
- */
-
-#ifdef ACPI_DEBUG
-
-#define MODULE_NAME(name)               static char *_THIS_MODULE = name;
-
-/*
- * Function entry tracing.
- * The first parameter should be the procedure name as a quoted string.  This is declared
- * as a local string ("_Proc_name) so that it can be also used by the function exit macros below.
- */
-
-#define PROC_NAME(a)                    acpi_debug_print_info _dbg;     \
-										_dbg.component_id = _COMPONENT; \
-										_dbg.proc_name   = a;           \
-										_dbg.module_name = _THIS_MODULE;
-
-#define FUNCTION_TRACE(a)               PROC_NAME(a)\
-										acpi_ut_trace(__LINE__,&_dbg)
-#define FUNCTION_TRACE_PTR(a,b)         PROC_NAME(a)\
-										acpi_ut_trace_ptr(__LINE__,&_dbg,(void *)b)
-#define FUNCTION_TRACE_U32(a,b)         PROC_NAME(a)\
-										acpi_ut_trace_u32(__LINE__,&_dbg,(u32)b)
-#define FUNCTION_TRACE_STR(a,b)         PROC_NAME(a)\
-										acpi_ut_trace_str(__LINE__,&_dbg,(NATIVE_CHAR *)b)
-
-#define FUNCTION_ENTRY()                acpi_ut_track_stack_ptr()
-
-/*
- * Function exit tracing.
- * WARNING: These macros include a return statement.  This is usually considered
- * bad form, but having a separate exit macro is very ugly and difficult to maintain.
- * One of the FUNCTION_TRACE macros above must be used in conjunction with these macros
- * so that "_Proc_name" is defined.
- */
-#define return_VOID                     {acpi_ut_exit(__LINE__,&_dbg);return;}
-#define return_ACPI_STATUS(s)           {acpi_ut_status_exit(__LINE__,&_dbg,s);return(s);}
-#define return_VALUE(s)                 {acpi_ut_value_exit(__LINE__,&_dbg,s);return(s);}
-#define return_PTR(s)                   {acpi_ut_ptr_exit(__LINE__,&_dbg,(u8 *)s);return(s);}
-
-
-/* Conditional execution */
-
-#define DEBUG_EXEC(a)                   a
-#define NORMAL_EXEC(a)
-
-#define DEBUG_DEFINE(a)                 a;
-#define DEBUG_ONLY_MEMBERS(a)           a;
-#define _OPCODE_NAMES
-#define _VERBOSE_STRUCTURES
-
-
-/* Stack and buffer dumping */
-
-#define DUMP_STACK_ENTRY(a)             acpi_ex_dump_operand(a)
-#define DUMP_OPERANDS(a,b,c,d,e)        acpi_ex_dump_operands(a,b,c,d,e,_THIS_MODULE,__LINE__)
-
-
-#define DUMP_ENTRY(a,b)                 acpi_ns_dump_entry (a,b)
-#define DUMP_TABLES(a,b)                acpi_ns_dump_tables(a,b)
-#define DUMP_PATHNAME(a,b,c,d)          acpi_ns_dump_pathname(a,b,c,d)
-#define DUMP_RESOURCE_LIST(a)           acpi_rs_dump_resource_list(a)
-#define DUMP_BUFFER(a,b)                acpi_ut_dump_buffer((u8 *)a,b,DB_BYTE_DISPLAY,_COMPONENT)
-#define BREAK_MSG(a)                    acpi_os_signal (ACPI_SIGNAL_BREAKPOINT,(a))
-
-
-/*
- * Generate INT3 on ACPI_ERROR (Debug only!)
- */
-
-#define ERROR_BREAK
-#ifdef  ERROR_BREAK
-#define BREAK_ON_ERROR(lvl)              if ((lvl)&ACPI_ERROR) acpi_os_signal(ACPI_SIGNAL_BREAKPOINT,"Fatal error encountered\n")
-#else
-#define BREAK_ON_ERROR(lvl)
-#endif
-
-/*
- * Master debug print macros
- * Print iff:
- *    1) Debug print for the current component is enabled
- *    2) Debug error level or trace level for the print statement is enabled
- */
-
-#define ACPI_DEBUG_PRINT(pl)            acpi_ut_debug_print PARAM_LIST(pl)
-#define ACPI_DEBUG_PRINT_RAW(pl)        acpi_ut_debug_print_raw PARAM_LIST(pl)
-
-
-#else
-/*
- * This is the non-debug case -- make everything go away,
- * leaving no executable debug code!
- */
-
-#define MODULE_NAME(name)
-#define _THIS_MODULE ""
-
-#define DEBUG_EXEC(a)
-#define NORMAL_EXEC(a)                  a;
-
-#define DEBUG_DEFINE(a)
-#define DEBUG_ONLY_MEMBERS(a)
-#define PROC_NAME(a)
-#define FUNCTION_TRACE(a)
-#define FUNCTION_TRACE_PTR(a,b)
-#define FUNCTION_TRACE_U32(a,b)
-#define FUNCTION_TRACE_STR(a,b)
-#define FUNCTION_EXIT
-#define FUNCTION_STATUS_EXIT(s)
-#define FUNCTION_VALUE_EXIT(s)
-#define FUNCTION_ENTRY()
-#define DUMP_STACK_ENTRY(a)
-#define DUMP_OPERANDS(a,b,c,d,e)
-#define DUMP_ENTRY(a,b)
-#define DUMP_TABLES(a,b)
-#define DUMP_PATHNAME(a,b,c,d)
-#define DUMP_RESOURCE_LIST(a)
-#define DUMP_BUFFER(a,b)
-#define ACPI_DEBUG_PRINT(pl)
-#define ACPI_DEBUG_PRINT_RAW(pl)
-#define BREAK_MSG(a)
-
-#define return_VOID                     return
-#define return_ACPI_STATUS(s)           return(s)
-#define return_VALUE(s)                 return(s)
-#define return_PTR(s)                   return(s)
-
-#endif
-
-/*
- * Some code only gets executed when the debugger is built in.
- * Note that this is entirely independent of whether the
- * DEBUG_PRINT stuff (set by ACPI_DEBUG) is on, or not.
- */
-#ifdef ENABLE_DEBUGGER
-#define DEBUGGER_EXEC(a)                a
-#else
-#define DEBUGGER_EXEC(a)
-#endif
-
-
-/*
- * For 16-bit code, we want to shrink some things even though
- * we are using ACPI_DEBUG to get the debug output
- */
-#ifdef _IA16
-#undef DEBUG_ONLY_MEMBERS
-#undef _VERBOSE_STRUCTURES
-#define DEBUG_ONLY_MEMBERS(a)
-#endif
-
-
-#ifdef ACPI_DEBUG
-/*
- * 1) Set name to blanks
- * 2) Copy the object name
- */
-#define ADD_OBJECT_NAME(a,b)            MEMSET (a->common.name, ' ', sizeof (a->common.name));\
-										STRNCPY (a->common.name, acpi_gbl_ns_type_names[b], sizeof (a->common.name))
-#else
-
-#define ADD_OBJECT_NAME(a,b)
-#endif
-
-
-/*
- * Memory allocation tracking (DEBUG ONLY)
- */
-
-#ifndef ACPI_DBG_TRACK_ALLOCATIONS
-
-/* Memory allocation */
-
-#define ACPI_MEM_ALLOCATE(a)            acpi_os_allocate(a)
-#define ACPI_MEM_CALLOCATE(a)           acpi_os_callocate(a)
-#define ACPI_MEM_FREE(a)                acpi_os_free(a)
-#define ACPI_MEM_TRACKING(a)
-
-
-#else
-
-/* Memory allocation */
-
-#define ACPI_MEM_ALLOCATE(a)            acpi_ut_allocate(a,_COMPONENT,_THIS_MODULE,__LINE__)
-#define ACPI_MEM_CALLOCATE(a)           acpi_ut_callocate(a, _COMPONENT,_THIS_MODULE,__LINE__)
-#define ACPI_MEM_FREE(a)                acpi_ut_free(a,_COMPONENT,_THIS_MODULE,__LINE__)
-#define ACPI_MEM_TRACKING(a)            a
-
-#endif /* ACPI_DBG_TRACK_ALLOCATIONS */
-
-
-#define ACPI_GET_STACK_POINTER          _asm {mov eax, ebx}
-
-#endif /* ACMACROS_H */
diff -urNp linux-5400/drivers/acpi/include/acnamesp.h linux-5410/drivers/acpi/include/acnamesp.h
--- linux-5400/drivers/acpi/include/acnamesp.h
+++ linux-5410/drivers/acpi/include/acnamesp.h
@@ -1,423 +0,0 @@
-/******************************************************************************
- *
- * Name: acnamesp.h - Namespace subcomponent prototypes and defines
- *       $Revision: 110 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACNAMESP_H__
-#define __ACNAMESP_H__
-
-
-/* To search the entire name space, pass this as Search_base */
-
-#define NS_ALL                  ((acpi_handle)0)
-
-/*
- * Elements of Acpi_ns_properties are bit significant
- * and should be one-to-one with values of acpi_object_type
- */
-#define NSP_NORMAL              0
-#define NSP_NEWSCOPE            1   /* a definition of this type opens a name scope */
-#define NSP_LOCAL               2   /* suppress search of enclosing scopes */
-
-
-/* Definitions of the predefined namespace names  */
-
-#define ACPI_UNKNOWN_NAME       (u32) 0x3F3F3F3F     /* Unknown name is  "????" */
-#define ACPI_ROOT_NAME          (u32) 0x2F202020     /* Root name is     "/   " */
-#define ACPI_SYS_BUS_NAME       (u32) 0x5F53425F     /* Sys bus name is  "_SB_" */
-
-#define NS_ROOT_PATH            "/"
-#define NS_SYSTEM_BUS           "_SB_"
-
-
-/* Flags for Acpi_ns_lookup, Acpi_ns_search_and_enter */
-
-#define NS_NO_UPSEARCH          0
-#define NS_SEARCH_PARENT        0x01
-#define NS_DONT_OPEN_SCOPE      0x02
-#define NS_NO_PEER_SEARCH       0x04
-#define NS_ERROR_IF_FOUND       0x08
-
-#define NS_WALK_UNLOCK          TRUE
-#define NS_WALK_NO_UNLOCK       FALSE
-
-
-acpi_status
-acpi_ns_load_namespace (
-	void);
-
-acpi_status
-acpi_ns_initialize_objects (
-	void);
-
-acpi_status
-acpi_ns_initialize_devices (
-	void);
-
-
-/* Namespace init - nsxfinit */
-
-acpi_status
-acpi_ns_init_one_device (
-	acpi_handle             obj_handle,
-	u32                     nesting_level,
-	void                    *context,
-	void                    **return_value);
-
-acpi_status
-acpi_ns_init_one_object (
-	acpi_handle             obj_handle,
-	u32                     level,
-	void                    *context,
-	void                    **return_value);
-
-
-acpi_status
-acpi_ns_walk_namespace (
-	acpi_object_type8       type,
-	acpi_handle             start_object,
-	u32                     max_depth,
-	u8                      unlock_before_callback,
-	acpi_walk_callback      user_function,
-	void                    *context,
-	void                    **return_value);
-
-acpi_namespace_node *
-acpi_ns_get_next_node (
-	acpi_object_type8       type,
-	acpi_namespace_node     *parent,
-	acpi_namespace_node     *child);
-
-acpi_status
-acpi_ns_delete_namespace_by_owner (
-	u16                     table_id);
-
-
-/* Namespace loading - nsload */
-
-acpi_status
-acpi_ns_one_complete_parse (
-	u32                     pass_number,
-	acpi_table_desc         *table_desc);
-
-acpi_status
-acpi_ns_parse_table (
-	acpi_table_desc         *table_desc,
-	acpi_namespace_node     *scope);
-
-acpi_status
-acpi_ns_load_table (
-	acpi_table_desc         *table_desc,
-	acpi_namespace_node     *node);
-
-acpi_status
-acpi_ns_load_table_by_type (
-	acpi_table_type         table_type);
-
-
-/*
- * Top-level namespace access - nsaccess
- */
-
-
-acpi_status
-acpi_ns_root_initialize (
-	void);
-
-acpi_status
-acpi_ns_lookup (
-	acpi_generic_state      *scope_info,
-	NATIVE_CHAR             *name,
-	acpi_object_type8       type,
-	operating_mode          interpreter_mode,
-	u32                     flags,
-	acpi_walk_state         *walk_state,
-	acpi_namespace_node     **ret_node);
-
-
-/*
- * Named object allocation/deallocation - nsalloc
- */
-
-
-acpi_namespace_node *
-acpi_ns_create_node (
-	u32                     name);
-
-void
-acpi_ns_delete_node (
-	acpi_namespace_node     *node);
-
-acpi_status
-acpi_ns_delete_namespace_subtree (
-	acpi_namespace_node     *parent_handle);
-
-void
-acpi_ns_detach_object (
-	acpi_namespace_node     *node);
-
-void
-acpi_ns_delete_children (
-	acpi_namespace_node     *parent);
-
-
-/*
- * Namespace modification - nsmodify
- */
-
-acpi_status
-acpi_ns_unload_namespace (
-	acpi_handle             handle);
-
-acpi_status
-acpi_ns_delete_subtree (
-	acpi_handle             start_handle);
-
-
-/*
- * Namespace dump/print utilities - nsdump
- */
-
-void
-acpi_ns_dump_tables (
-	acpi_handle             search_base,
-	u32                     max_depth);
-
-void
-acpi_ns_dump_entry (
-	acpi_handle             handle,
-	u32                     debug_level);
-
-acpi_status
-acpi_ns_dump_pathname (
-	acpi_handle             handle,
-	NATIVE_CHAR             *msg,
-	u32                     level,
-	u32                     component);
-
-void
-acpi_ns_dump_root_devices (
-	void);
-
-void
-acpi_ns_dump_objects (
-	acpi_object_type8       type,
-	u8                      display_type,
-	u32                     max_depth,
-	u32                     ownder_id,
-	acpi_handle             start_handle);
-
-
-/*
- * Namespace evaluation functions - nseval
- */
-
-acpi_status
-acpi_ns_evaluate_by_handle (
-	acpi_namespace_node     *prefix_node,
-	acpi_operand_object     **params,
-	acpi_operand_object     **return_object);
-
-acpi_status
-acpi_ns_evaluate_by_name (
-	NATIVE_CHAR             *pathname,
-	acpi_operand_object     **params,
-	acpi_operand_object     **return_object);
-
-acpi_status
-acpi_ns_evaluate_relative (
-	acpi_namespace_node     *prefix_node,
-	NATIVE_CHAR             *pathname,
-	acpi_operand_object     **params,
-	acpi_operand_object     **return_object);
-
-acpi_status
-acpi_ns_execute_control_method (
-	acpi_namespace_node     *method_node,
-	acpi_operand_object     **params,
-	acpi_operand_object     **return_obj_desc);
-
-acpi_status
-acpi_ns_get_object_value (
-	acpi_namespace_node     *object_node,
-	acpi_operand_object     **return_obj_desc);
-
-
-/*
- * Parent/Child/Peer utility functions - nsfamily
- */
-
-acpi_name
-acpi_ns_find_parent_name (
-	acpi_namespace_node     *node_to_search);
-
-u8
-acpi_ns_exist_downstream_sibling (
-	acpi_namespace_node     *this_node);
-
-
-/*
- * Scope manipulation - nsscope
- */
-
-u32
-acpi_ns_opens_scope (
-	acpi_object_type8       type);
-
-NATIVE_CHAR *
-acpi_ns_get_table_pathname (
-	acpi_namespace_node     *node);
-
-NATIVE_CHAR *
-acpi_ns_name_of_current_scope (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ns_handle_to_pathname (
-	acpi_handle             obj_handle,
-	u32                     *buf_size,
-	NATIVE_CHAR             *user_buffer);
-
-u8
-acpi_ns_pattern_match (
-	acpi_namespace_node     *obj_node,
-	NATIVE_CHAR             *search_for);
-
-acpi_status
-acpi_ns_get_node (
-	NATIVE_CHAR             *pathname,
-	acpi_namespace_node     *in_prefix_node,
-	acpi_namespace_node     **out_node);
-
-u32
-acpi_ns_get_pathname_length (
-	acpi_namespace_node     *node);
-
-
-/*
- * Object management for NTEs - nsobject
- */
-
-acpi_status
-acpi_ns_attach_object (
-	acpi_namespace_node     *node,
-	acpi_operand_object     *object,
-	acpi_object_type8       type);
-
-
-/*
- * Namespace searching and entry - nssearch
- */
-
-acpi_status
-acpi_ns_search_and_enter (
-	u32                     entry_name,
-	acpi_walk_state         *walk_state,
-	acpi_namespace_node     *node,
-	operating_mode          interpreter_mode,
-	acpi_object_type8       type,
-	u32                     flags,
-	acpi_namespace_node     **ret_node);
-
-acpi_status
-acpi_ns_search_node (
-	u32                     entry_name,
-	acpi_namespace_node     *node,
-	acpi_object_type8       type,
-	acpi_namespace_node     **ret_node);
-
-void
-acpi_ns_install_node (
-	acpi_walk_state         *walk_state,
-	acpi_namespace_node     *parent_node,   /* Parent */
-	acpi_namespace_node     *node,      /* New Child*/
-	acpi_object_type8       type);
-
-
-/*
- * Utility functions - nsutils
- */
-
-u8
-acpi_ns_valid_root_prefix (
-	NATIVE_CHAR             prefix);
-
-u8
-acpi_ns_valid_path_separator (
-	NATIVE_CHAR             sep);
-
-acpi_object_type8
-acpi_ns_get_type (
-	acpi_namespace_node     *node);
-
-void *
-acpi_ns_get_attached_object (
-	acpi_namespace_node     *node);
-
-u32
-acpi_ns_local (
-	acpi_object_type8       type);
-
-acpi_status
-acpi_ns_build_internal_name (
-	acpi_namestring_info    *info);
-
-acpi_status
-acpi_ns_get_internal_name_length (
-	acpi_namestring_info    *info);
-
-acpi_status
-acpi_ns_internalize_name (
-	NATIVE_CHAR             *dotted_name,
-	NATIVE_CHAR             **converted_name);
-
-acpi_status
-acpi_ns_externalize_name (
-	u32                     internal_name_length,
-	NATIVE_CHAR             *internal_name,
-	u32                     *converted_name_length,
-	NATIVE_CHAR             **converted_name);
-
-acpi_namespace_node *
-acpi_ns_map_handle_to_node (
-	acpi_handle             handle);
-
-acpi_handle
-acpi_ns_convert_entry_to_handle(
-	acpi_namespace_node     *node);
-
-void
-acpi_ns_terminate (
-	void);
-
-acpi_namespace_node *
-acpi_ns_get_parent_object (
-	acpi_namespace_node     *node);
-
-
-acpi_namespace_node *
-acpi_ns_get_next_valid_node (
-	acpi_namespace_node     *node);
-
-
-#endif /* __ACNAMESP_H__ */
diff -urNp linux-5400/drivers/acpi/include/acobject.h linux-5410/drivers/acpi/include/acobject.h
--- linux-5400/drivers/acpi/include/acobject.h
+++ linux-5410/drivers/acpi/include/acobject.h
@@ -1,451 +0,0 @@
-
-/******************************************************************************
- *
- * Name: acobject.h - Definition of acpi_operand_object  (Internal object only)
- *       $Revision: 93 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _ACOBJECT_H
-#define _ACOBJECT_H
-
-
-/*
- * The acpi_operand_object  is used to pass AML operands from the dispatcher
- * to the interpreter, and to keep track of the various handlers such as
- * address space handlers and notify handlers.  The object is a constant
- * size in order to allow them to be cached and reused.
- *
- * All variants of the acpi_operand_object  are defined with the same
- * sequence of field types, with fields that are not used in a particular
- * variant being named "Reserved".  This is not strictly necessary, but
- * may in some circumstances simplify understanding if these structures
- * need to be displayed in a debugger having limited (or no) support for
- * union types.  It also simplifies some debug code in Dump_table() which
- * dumps multi-level values: fetching Buffer.Pointer suffices to pick up
- * the value or next level for any of several types.
- */
-
-/******************************************************************************
- *
- * Common Descriptors
- *
- *****************************************************************************/
-
-/*
- * Common area for all objects.
- *
- * Data_type is used to differentiate between internal descriptors, and MUST
- * be the first byte in this structure.
- */
-
-
-#define ACPI_OBJECT_COMMON_HEADER           /* SIZE/ALIGNMENT: 32-bits plus trailing 8-bit flag */\
-	u8                          data_type;          /* To differentiate various internal objs */\
-	u8                          type;               /* acpi_object_type */\
-	u16                         reference_count;    /* For object deletion management */\
-	u8                          flags; \
-
-/* Defines for flag byte above */
-
-#define AOPOBJ_STATIC_ALLOCATION    0x1
-#define AOPOBJ_STATIC_POINTER       0x2
-#define AOPOBJ_DATA_VALID           0x4
-#define AOPOBJ_ZERO_CONST           0x4
-#define AOPOBJ_INITIALIZED          0x8
-
-
-/*
- * Common bitfield for the field objects
- * "Field Datum"    -- a datum from the actual field object
- * "Buffer Datum"   -- a datum from a user buffer, read from or to be written to the field
- */
-#define ACPI_COMMON_FIELD_INFO              /* SIZE/ALIGNMENT: 24 bits + three 32-bit values */\
-	u8                          access_flags;\
-	u16                         bit_length;         /* Length of field in bits */\
-	u32                         base_byte_offset;   /* Byte offset within containing object */\
-	u8                          access_bit_width;   /* Read/Write size in bits (from ASL Access_type)*/\
-	u8                          access_byte_width;  /* Read/Write size in bytes */\
-	u8                          update_rule;        /* How neighboring field bits are handled */\
-	u8                          lock_rule;          /* Global Lock: 1 = "Must Lock" */\
-	u8                          start_field_bit_offset;/* Bit offset within first field datum (0-63) */\
-	u8                          datum_valid_bits;   /* Valid bit in first "Field datum" */\
-	u8                          end_field_valid_bits; /* Valid bits in the last "field datum" */\
-	u8                          end_buffer_valid_bits; /* Valid bits in the last "buffer datum" */\
-	u32                         value;              /* Value to store into the Bank or Index register */
-
-
-/* Access flag bits */
-
-#define AFIELD_SINGLE_DATUM         0x1
-
-
-/*
- * Fields common to both Strings and Buffers
- */
-#define ACPI_COMMON_BUFFER_INFO \
-	u32                         length;
-
-
-/******************************************************************************
- *
- * Individual Object Descriptors
- *
- *****************************************************************************/
-
-
-typedef struct /* COMMON */
-{
-	ACPI_OBJECT_COMMON_HEADER
-
-} ACPI_OBJECT_COMMON;
-
-
-typedef struct /* CACHE_LIST */
-{
-	ACPI_OBJECT_COMMON_HEADER
-	union acpi_operand_obj      *next;              /* Link for object cache and internal lists*/
-
-} ACPI_OBJECT_CACHE_LIST;
-
-
-typedef struct /* NUMBER - has value */
-{
-	ACPI_OBJECT_COMMON_HEADER
-
-	acpi_integer                value;
-
-} ACPI_OBJECT_INTEGER;
-
-
-typedef struct /* STRING - has length and pointer - Null terminated, ASCII characters only */
-{
-	ACPI_OBJECT_COMMON_HEADER
-	ACPI_COMMON_BUFFER_INFO
-	NATIVE_CHAR                 *pointer;           /* String value in AML stream or in allocated space */
-
-} ACPI_OBJECT_STRING;
-
-
-typedef struct /* BUFFER - has length and pointer - not null terminated */
-{
-	ACPI_OBJECT_COMMON_HEADER
-	ACPI_COMMON_BUFFER_INFO
-	u8                          *pointer;           /* Buffer value in AML stream or in allocated space */
-
-} ACPI_OBJECT_BUFFER;
-
-
-typedef struct /* PACKAGE - has count, elements, next element */
-{
-	ACPI_OBJECT_COMMON_HEADER
-
-	u32                         count;              /* # of elements in package */
-	union acpi_operand_obj      **elements;         /* Array of pointers to Acpi_objects */
-	union acpi_operand_obj      **next_element;     /* used only while initializing */
-
-} ACPI_OBJECT_PACKAGE;
-
-
-typedef struct /* DEVICE - has handle and notification handler/context */
-{
-	ACPI_OBJECT_COMMON_HEADER
-
-	union acpi_operand_obj      *sys_handler;        /* Handler for system notifies */
-	union acpi_operand_obj      *drv_handler;        /* Handler for driver notifies */
-	union acpi_operand_obj      *addr_handler;       /* Handler for Address space */
-
-} ACPI_OBJECT_DEVICE;
-
-
-typedef struct /* EVENT */
-{
-	ACPI_OBJECT_COMMON_HEADER
-	void                        *semaphore;
-
-} ACPI_OBJECT_EVENT;
-
-
-#define INFINITE_CONCURRENCY        0xFF
-
-typedef struct /* METHOD */
-{
-	ACPI_OBJECT_COMMON_HEADER
-	u8                          method_flags;
-	u8                          param_count;
-
-	u32                         aml_length;
-
-	void                        *semaphore;
-	u8                          *aml_start;
-
-	u8                          concurrency;
-	u8                          thread_count;
-	acpi_owner_id               owning_id;
-
-} ACPI_OBJECT_METHOD;
-
-
-typedef struct acpi_obj_mutex /* MUTEX */
-{
-	ACPI_OBJECT_COMMON_HEADER
-	u16                         sync_level;
-	u16                         acquisition_depth;
-
-	void                        *semaphore;
-	void                        *owner;
-	union acpi_operand_obj      *prev;              /* Link for list of acquired mutexes */
-	union acpi_operand_obj      *next;              /* Link for list of acquired mutexes */
-
-} ACPI_OBJECT_MUTEX;
-
-
-typedef struct /* REGION */
-{
-	ACPI_OBJECT_COMMON_HEADER
-
-	u8                          space_id;
-	u32                         length;
-	ACPI_PHYSICAL_ADDRESS       address;
-	union acpi_operand_obj      *extra;             /* Pointer to executable AML (in region definition) */
-
-	union acpi_operand_obj      *addr_handler;      /* Handler for system notifies */
-	acpi_namespace_node         *node;              /* containing object */
-	union acpi_operand_obj      *next;
-
-} ACPI_OBJECT_REGION;
-
-
-typedef struct /* POWER RESOURCE - has Handle and notification handler/context*/
-{
-	ACPI_OBJECT_COMMON_HEADER
-
-	u32                         system_level;
-	u32                         resource_order;
-
-	union acpi_operand_obj      *sys_handler;       /* Handler for system notifies */
-	union acpi_operand_obj      *drv_handler;       /* Handler for driver notifies */
-
-} ACPI_OBJECT_POWER_RESOURCE;
-
-
-typedef struct /* PROCESSOR - has Handle and notification handler/context*/
-{
-	ACPI_OBJECT_COMMON_HEADER
-
-	u32                         proc_id;
-	u32                         length;
-	ACPI_IO_ADDRESS             address;
-
-	union acpi_operand_obj      *sys_handler;       /* Handler for system notifies */
-	union acpi_operand_obj      *drv_handler;       /* Handler for driver notifies */
-	union acpi_operand_obj      *addr_handler;      /* Handler for Address space */
-
-} ACPI_OBJECT_PROCESSOR;
-
-
-typedef struct /* THERMAL ZONE - has Handle and Handler/Context */
-{
-	ACPI_OBJECT_COMMON_HEADER
-
-	union acpi_operand_obj      *sys_handler;       /* Handler for system notifies */
-	union acpi_operand_obj      *drv_handler;       /* Handler for driver notifies */
-	union acpi_operand_obj      *addr_handler;      /* Handler for Address space */
-
-} ACPI_OBJECT_THERMAL_ZONE;
-
-
-/*
- * Fields.  All share a common header/info field.
- */
-
-typedef struct /* COMMON FIELD (for BUFFER, REGION, BANK, and INDEX fields) */
-{
-	ACPI_OBJECT_COMMON_HEADER
-	ACPI_COMMON_FIELD_INFO
-	union acpi_operand_obj      *region_obj;        /* Containing Operation Region object */
-			 /* (REGION/BANK fields only) */
-} ACPI_OBJECT_FIELD_COMMON;
-
-
-typedef struct /* REGION FIELD */
-{
-	ACPI_OBJECT_COMMON_HEADER
-	ACPI_COMMON_FIELD_INFO
-	union acpi_operand_obj      *region_obj;        /* Containing Op_region object */
-
-} ACPI_OBJECT_REGION_FIELD;
-
-
-typedef struct /* BANK FIELD */
-{
-	ACPI_OBJECT_COMMON_HEADER
-	ACPI_COMMON_FIELD_INFO
-
-	union acpi_operand_obj      *region_obj;        /* Containing Op_region object */
-	union acpi_operand_obj      *bank_register_obj; /* Bank_select Register object */
-
-} ACPI_OBJECT_BANK_FIELD;
-
-
-typedef struct /* INDEX FIELD */
-{
-	ACPI_OBJECT_COMMON_HEADER
-	ACPI_COMMON_FIELD_INFO
-
-	/*
-	 * No "Region_obj" pointer needed since the Index and Data registers
-	 * are each field definitions unto themselves.
-	 */
-	union acpi_operand_obj      *index_obj;         /* Index register */
-	union acpi_operand_obj      *data_obj;          /* Data register */
-
-
-} ACPI_OBJECT_INDEX_FIELD;
-
-
-/* The Buffer_field is different in that it is part of a Buffer, not an Op_region */
-
-typedef struct /* BUFFER FIELD */
-{
-	ACPI_OBJECT_COMMON_HEADER
-	ACPI_COMMON_FIELD_INFO
-
-	union acpi_operand_obj      *extra;             /* Pointer to executable AML (in field definition) */
-	acpi_namespace_node         *node;              /* Parent (containing) object node */
-	union acpi_operand_obj      *buffer_obj;        /* Containing Buffer object */
-
-} ACPI_OBJECT_BUFFER_FIELD;
-
-
-/*
- * Handlers
- */
-
-typedef struct /* NOTIFY HANDLER */
-{
-	ACPI_OBJECT_COMMON_HEADER
-
-	acpi_namespace_node         *node;               /* Parent device */
-	acpi_notify_handler         handler;
-	void                        *context;
-
-} ACPI_OBJECT_NOTIFY_HANDLER;
-
-
-/* Flags for address handler */
-
-#define ADDR_HANDLER_DEFAULT_INSTALLED  0x1
-
-
-typedef struct /* ADDRESS HANDLER */
-{
-	ACPI_OBJECT_COMMON_HEADER
-
-	u8                          space_id;
-	u16                         hflags;
-	acpi_adr_space_handler      handler;
-
-	acpi_namespace_node         *node;              /* Parent device */
-	void                        *context;
-	acpi_adr_space_setup        setup;
-	union acpi_operand_obj      *region_list;       /* regions using this handler */
-	union acpi_operand_obj      *next;
-
-} ACPI_OBJECT_ADDR_HANDLER;
-
-
-/*
- * The Reference object type is used for these opcodes:
- * Arg[0-6], Local[0-7], Index_op, Name_op, Zero_op, One_op, Ones_op, Debug_op
- */
-
-typedef struct /* Reference - Local object type */
-{
-	ACPI_OBJECT_COMMON_HEADER
-
-	u8                          target_type;        /* Used for Index_op */
-	u16                         opcode;
-	u32                         offset;             /* Used for Arg_op, Local_op, and Index_op */
-
-	void                        *object;            /* Name_op=>HANDLE to obj, Index_op=>acpi_operand_object */
-	acpi_namespace_node         *node;
-	union acpi_operand_obj      **where;
-
-} ACPI_OBJECT_REFERENCE;
-
-
-/*
- * Extra object is used as additional storage for types that
- * have AML code in their declarations (Term_args) that must be
- * evaluated at run time.
- *
- * Currently: Region and Field_unit types
- */
-
-typedef struct /* EXTRA */
-{
-	ACPI_OBJECT_COMMON_HEADER
-	u8                          byte_fill1;
-	u16                         word_fill1;
-	u32                         aml_length;
-	u8                          *aml_start;
-	acpi_namespace_node         *method_REG;        /* _REG method for this region (if any) */
-	void                        *region_context;    /* Region-specific data */
-
-} ACPI_OBJECT_EXTRA;
-
-
-/******************************************************************************
- *
- * acpi_operand_object  Descriptor - a giant union of all of the above
- *
- *****************************************************************************/
-
-typedef union acpi_operand_obj
-{
-	ACPI_OBJECT_COMMON          common;
-	ACPI_OBJECT_CACHE_LIST      cache;
-	ACPI_OBJECT_INTEGER         integer;
-	ACPI_OBJECT_STRING          string;
-	ACPI_OBJECT_BUFFER          buffer;
-	ACPI_OBJECT_PACKAGE         package;
-	ACPI_OBJECT_BUFFER_FIELD    buffer_field;
-	ACPI_OBJECT_DEVICE          device;
-	ACPI_OBJECT_EVENT           event;
-	ACPI_OBJECT_METHOD          method;
-	ACPI_OBJECT_MUTEX           mutex;
-	ACPI_OBJECT_REGION          region;
-	ACPI_OBJECT_POWER_RESOURCE  power_resource;
-	ACPI_OBJECT_PROCESSOR       processor;
-	ACPI_OBJECT_THERMAL_ZONE    thermal_zone;
-	ACPI_OBJECT_FIELD_COMMON    common_field;
-	ACPI_OBJECT_REGION_FIELD    field;
-	ACPI_OBJECT_BANK_FIELD      bank_field;
-	ACPI_OBJECT_INDEX_FIELD     index_field;
-	ACPI_OBJECT_REFERENCE       reference;
-	ACPI_OBJECT_NOTIFY_HANDLER  notify_handler;
-	ACPI_OBJECT_ADDR_HANDLER    addr_handler;
-	ACPI_OBJECT_EXTRA           extra;
-
-} acpi_operand_object;
-
-#endif /* _ACOBJECT_H */
diff -urNp linux-5400/drivers/acpi/include/acoutput.h linux-5410/drivers/acpi/include/acoutput.h
--- linux-5400/drivers/acpi/include/acoutput.h
+++ linux-5410/drivers/acpi/include/acoutput.h
@@ -1,182 +0,0 @@
-/******************************************************************************
- *
- * Name: acoutput.h -- debug output
- *       $Revision: 84 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACOUTPUT_H__
-#define __ACOUTPUT_H__
-
-/*
- * Debug levels and component IDs.  These are used to control the
- * granularity of the output of the DEBUG_PRINT macro -- on a per-
- * component basis and a per-exception-type basis.
- */
-
-/* Component IDs are used in the global "Debug_layer" */
-
-#define ACPI_UTILITIES              0x00000001
-#define ACPI_HARDWARE               0x00000002
-#define ACPI_EVENTS                 0x00000004
-#define ACPI_TABLES                 0x00000008
-#define ACPI_NAMESPACE              0x00000010
-#define ACPI_PARSER                 0x00000020
-#define ACPI_DISPATCHER             0x00000040
-#define ACPI_EXECUTER               0x00000080
-#define ACPI_RESOURCES              0x00000100
-#define ACPI_DEBUGGER               0x00000200
-#define ACPI_OS_SERVICES            0x00000400
-
-#define ACPI_BUS                    0x00010000
-#define ACPI_SYSTEM                 0x00020000
-#define ACPI_POWER                  0x00040000
-#define ACPI_EC                     0x00080000
-#define ACPI_AC_ADAPTER             0x00100000
-#define ACPI_BATTERY                0x00200000
-#define ACPI_BUTTON                 0x00400000
-#define ACPI_PROCESSOR              0x00800000
-#define ACPI_THERMAL                0x01000000
-#define ACPI_FAN                    0x02000000
-
-#define ACPI_ALL_COMPONENTS         0x0FFFFFFF
-
-#define ACPI_COMPONENT_DEFAULT      (ACPI_ALL_COMPONENTS)
-
-
-#define ACPI_COMPILER               0x10000000
-#define ACPI_TOOLS                  0x20000000
-
-
-/*
- * Raw debug output levels, do not use these in the DEBUG_PRINT macros
- */
-
-#define ACPI_LV_OK                  0x00000001
-#define ACPI_LV_INFO                0x00000002
-#define ACPI_LV_WARN                0x00000004
-#define ACPI_LV_ERROR               0x00000008
-#define ACPI_LV_FATAL               0x00000010
-#define ACPI_LV_DEBUG_OBJECT        0x00000020
-#define ACPI_LV_ALL_EXCEPTIONS      0x0000003F
-
-
-/* Trace verbosity level 1 [Standard Trace Level] */
-
-#define ACPI_LV_PARSE               0x00000040
-#define ACPI_LV_LOAD                0x00000080
-#define ACPI_LV_DISPATCH            0x00000100
-#define ACPI_LV_EXEC                0x00000200
-#define ACPI_LV_NAMES               0x00000400
-#define ACPI_LV_OPREGION            0x00000800
-#define ACPI_LV_BFIELD              0x00001000
-#define ACPI_LV_TABLES              0x00002000
-#define ACPI_LV_VALUES              0x00004000
-#define ACPI_LV_OBJECTS             0x00008000
-#define ACPI_LV_RESOURCES           0x00010000
-#define ACPI_LV_USER_REQUESTS       0x00020000
-#define ACPI_LV_PACKAGE             0x00040000
-#define ACPI_LV_INIT                0x00080000
-#define ACPI_LV_VERBOSITY1          0x000FFF40 | ACPI_LV_ALL_EXCEPTIONS
-
-/* Trace verbosity level 2 [Function tracing and memory allocation] */
-
-#define ACPI_LV_ALLOCATIONS         0x00100000
-#define ACPI_LV_FUNCTIONS           0x00200000
-#define ACPI_LV_VERBOSITY2          0x00300000 | ACPI_LV_VERBOSITY1
-#define ACPI_LV_ALL                 ACPI_LV_VERBOSITY2
-
-/* Trace verbosity level 3 [Threading, I/O, and Interrupts] */
-
-#define ACPI_LV_MUTEX               0x01000000
-#define ACPI_LV_THREADS             0x02000000
-#define ACPI_LV_IO                  0x04000000
-#define ACPI_LV_INTERRUPTS          0x08000000
-#define ACPI_LV_VERBOSITY3          0x0F000000 | ACPI_LV_VERBOSITY2
-
-/*
- * Debug level macros that are used in the DEBUG_PRINT macros
- */
-
-#define ACPI_DEBUG_LEVEL(dl)       dl,__LINE__,&_dbg
-
-/* Exception level -- used in the global "Debug_level" */
-
-#define ACPI_DB_OK                  ACPI_DEBUG_LEVEL (ACPI_LV_OK)
-#define ACPI_DB_INFO                ACPI_DEBUG_LEVEL (ACPI_LV_INFO)
-#define ACPI_DB_WARN                ACPI_DEBUG_LEVEL (ACPI_LV_WARN)
-#define ACPI_DB_ERROR               ACPI_DEBUG_LEVEL (ACPI_LV_ERROR)
-#define ACPI_DB_FATAL               ACPI_DEBUG_LEVEL (ACPI_LV_FATAL)
-#define ACPI_DB_DEBUG_OBJECT        ACPI_DEBUG_LEVEL (ACPI_LV_DEBUG_OBJECT)
-#define ACPI_DB_ALL_EXCEPTIONS      ACPI_DEBUG_LEVEL (ACPI_LV_ALL_EXCEPTIONS)
-
-
-/* Trace level -- also used in the global "Debug_level" */
-
-#define ACPI_DB_THREADS             ACPI_DEBUG_LEVEL (ACPI_LV_THREADS)
-#define ACPI_DB_PARSE               ACPI_DEBUG_LEVEL (ACPI_LV_PARSE)
-#define ACPI_DB_DISPATCH            ACPI_DEBUG_LEVEL (ACPI_LV_DISPATCH)
-#define ACPI_DB_LOAD                ACPI_DEBUG_LEVEL (ACPI_LV_LOAD)
-#define ACPI_DB_EXEC                ACPI_DEBUG_LEVEL (ACPI_LV_EXEC)
-#define ACPI_DB_NAMES               ACPI_DEBUG_LEVEL (ACPI_LV_NAMES)
-#define ACPI_DB_OPREGION            ACPI_DEBUG_LEVEL (ACPI_LV_OPREGION)
-#define ACPI_DB_BFIELD              ACPI_DEBUG_LEVEL (ACPI_LV_BFIELD)
-#define ACPI_DB_TABLES              ACPI_DEBUG_LEVEL (ACPI_LV_TABLES)
-#define ACPI_DB_FUNCTIONS           ACPI_DEBUG_LEVEL (ACPI_LV_FUNCTIONS)
-#define ACPI_DB_VALUES              ACPI_DEBUG_LEVEL (ACPI_LV_VALUES)
-#define ACPI_DB_OBJECTS             ACPI_DEBUG_LEVEL (ACPI_LV_OBJECTS)
-#define ACPI_DB_ALLOCATIONS         ACPI_DEBUG_LEVEL (ACPI_LV_ALLOCATIONS)
-#define ACPI_DB_RESOURCES           ACPI_DEBUG_LEVEL (ACPI_LV_RESOURCES)
-#define ACPI_DB_IO                  ACPI_DEBUG_LEVEL (ACPI_LV_IO)
-#define ACPI_DB_INTERRUPTS          ACPI_DEBUG_LEVEL (ACPI_LV_INTERRUPTS)
-#define ACPI_DB_USER_REQUESTS       ACPI_DEBUG_LEVEL (ACPI_LV_USER_REQUESTS)
-#define ACPI_DB_PACKAGE             ACPI_DEBUG_LEVEL (ACPI_LV_PACKAGE)
-#define ACPI_DB_MUTEX               ACPI_DEBUG_LEVEL (ACPI_LV_MUTEX)
-#define ACPI_DB_INIT                ACPI_DEBUG_LEVEL (ACPI_LV_INIT)
-
-#define ACPI_DB_ALL                 ACPI_DEBUG_LEVEL (0x0FFFFF80)
-
-
-/* Exceptionally verbose output -- also used in the global "Debug_level" */
-
-#define ACPI_DB_AML_DISASSEMBLE     0x10000000
-#define ACPI_DB_VERBOSE_INFO        0x20000000
-#define ACPI_DB_FULL_TABLES         0x40000000
-#define ACPI_DB_EVENTS              0x80000000
-
-#define ACPI_DB_VERBOSE             0xF0000000
-
-
-/* Defaults for Debug_level, debug and normal */
-
-#define DEBUG_DEFAULT               (ACPI_LV_OK | ACPI_LV_WARN | ACPI_LV_ERROR | ACPI_LV_DEBUG_OBJECT)
-#define NORMAL_DEFAULT              (ACPI_LV_OK | ACPI_LV_WARN | ACPI_LV_ERROR | ACPI_LV_DEBUG_OBJECT)
-#define DEBUG_ALL                   (ACPI_LV_AML_DISASSEMBLE | ACPI_LV_ALL_EXCEPTIONS | ACPI_LV_ALL)
-
-/* Misc defines */
-
-#define HEX                         0x01
-#define ASCII                       0x02
-#define FULL_ADDRESS                0x04
-#define CHARS_PER_LINE              16          /* used in Dump_buf function */
-
-
-#endif /* __ACOUTPUT_H__ */
diff -urNp linux-5400/drivers/acpi/include/acparser.h linux-5410/drivers/acpi/include/acparser.h
--- linux-5400/drivers/acpi/include/acparser.h
+++ linux-5410/drivers/acpi/include/acparser.h
@@ -1,293 +0,0 @@
-/******************************************************************************
- *
- * Module Name: acparser.h - AML Parser subcomponent prototypes and defines
- *       $Revision: 54 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#ifndef __ACPARSER_H__
-#define __ACPARSER_H__
-
-
-#define OP_HAS_RETURN_VALUE         1
-
-/* variable # arguments */
-
-#define ACPI_VAR_ARGS               ACPI_UINT32_MAX
-
-/* maximum virtual address */
-
-#define ACPI_MAX_AML                ((u8 *)(~0UL))
-
-
-#define ACPI_PARSE_DELETE_TREE          0x0001
-#define ACPI_PARSE_NO_TREE_DELETE       0x0000
-#define ACPI_PARSE_TREE_MASK            0x0001
-
-#define ACPI_PARSE_LOAD_PASS1           0x0010
-#define ACPI_PARSE_LOAD_PASS2           0x0020
-#define ACPI_PARSE_EXECUTE              0x0030
-#define ACPI_PARSE_MODE_MASK            0x0030
-
-/* psapi - Parser external interfaces */
-
-acpi_status
-acpi_psx_load_table (
-	u8                      *pcode_addr,
-	u32                     pcode_length);
-
-acpi_status
-acpi_psx_execute (
-	acpi_namespace_node     *method_node,
-	acpi_operand_object     **params,
-	acpi_operand_object     **return_obj_desc);
-
-/******************************************************************************
- *
- * Parser interfaces
- *
- *****************************************************************************/
-
-
-/* psargs - Parse AML opcode arguments */
-
-u8 *
-acpi_ps_get_next_package_end (
-	acpi_parse_state        *parser_state);
-
-u32
-acpi_ps_get_next_package_length (
-	acpi_parse_state        *parser_state);
-
-NATIVE_CHAR *
-acpi_ps_get_next_namestring (
-	acpi_parse_state        *parser_state);
-
-void
-acpi_ps_get_next_simple_arg (
-	acpi_parse_state        *parser_state,
-	u32                     arg_type,       /* type of argument */
-	acpi_parse_object       *arg);           /* (OUT) argument data */
-
-void
-acpi_ps_get_next_namepath (
-	acpi_parse_state        *parser_state,
-	acpi_parse_object       *arg,
-	u32                     *arg_count,
-	u8                      method_call);
-
-acpi_parse_object *
-acpi_ps_get_next_field (
-	acpi_parse_state        *parser_state);
-
-acpi_parse_object *
-acpi_ps_get_next_arg (
-	acpi_parse_state        *parser_state,
-	u32                     arg_type,
-	u32                     *arg_count);
-
-
-/* psopcode - AML Opcode information */
-
-const acpi_opcode_info *
-acpi_ps_get_opcode_info (
-	u16                     opcode);
-
-NATIVE_CHAR *
-acpi_ps_get_opcode_name (
-	u16                     opcode);
-
-
-/* psparse - top level parsing routines */
-
-acpi_status
-acpi_ps_find_object (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       **out_op);
-
-void
-acpi_ps_delete_parse_tree (
-	acpi_parse_object       *root);
-
-acpi_status
-acpi_ps_parse_loop (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ps_parse_aml (
-	acpi_walk_state         *walk_state);
-
-acpi_status
-acpi_ps_parse_table (
-	u8                      *aml,
-	u32                     aml_size,
-	acpi_parse_downwards    descending_callback,
-	acpi_parse_upwards      ascending_callback,
-	acpi_parse_object       **root_object);
-
-u16
-acpi_ps_peek_opcode (
-	acpi_parse_state        *state);
-
-
-/* psscope - Scope stack management routines */
-
-
-acpi_status
-acpi_ps_init_scope (
-	acpi_parse_state        *parser_state,
-	acpi_parse_object       *root);
-
-acpi_parse_object *
-acpi_ps_get_parent_scope (
-	acpi_parse_state        *state);
-
-u8
-acpi_ps_has_completed_scope (
-	acpi_parse_state        *parser_state);
-
-void
-acpi_ps_pop_scope (
-	acpi_parse_state        *parser_state,
-	acpi_parse_object       **op,
-	u32                     *arg_list,
-	u32                     *arg_count);
-
-acpi_status
-acpi_ps_push_scope (
-	acpi_parse_state        *parser_state,
-	acpi_parse_object       *op,
-	u32                     remaining_args,
-	u32                     arg_count);
-
-void
-acpi_ps_cleanup_scope (
-	acpi_parse_state        *state);
-
-
-/* pstree - parse tree manipulation routines */
-
-void
-acpi_ps_append_arg(
-	acpi_parse_object       *op,
-	acpi_parse_object       *arg);
-
-acpi_parse_object*
-acpi_ps_find (
-	acpi_parse_object       *scope,
-	NATIVE_CHAR             *path,
-	u16                     opcode,
-	u32                     create);
-
-acpi_parse_object *
-acpi_ps_get_arg(
-	acpi_parse_object       *op,
-	u32                      argn);
-
-acpi_parse_object *
-acpi_ps_get_child (
-	acpi_parse_object       *op);
-
-acpi_parse_object *
-acpi_ps_get_depth_next (
-	acpi_parse_object       *origin,
-	acpi_parse_object       *op);
-
-
-/* pswalk - parse tree walk routines */
-
-acpi_status
-acpi_ps_walk_parsed_aml (
-	acpi_parse_object       *start_op,
-	acpi_parse_object       *end_op,
-	acpi_operand_object     *mth_desc,
-	acpi_namespace_node     *start_node,
-	acpi_operand_object     **params,
-	acpi_operand_object     **caller_return_desc,
-	acpi_owner_id           owner_id,
-	acpi_parse_downwards    descending_callback,
-	acpi_parse_upwards      ascending_callback);
-
-acpi_status
-acpi_ps_get_next_walk_op (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op,
-	acpi_parse_upwards      ascending_callback);
-
-
-/* psutils - parser utilities */
-
-void
-acpi_ps_init_op (
-	acpi_parse_object       *op,
-	u16                     opcode);
-
-acpi_parse_object *
-acpi_ps_alloc_op (
-	u16                     opcode);
-
-void
-acpi_ps_free_op (
-	acpi_parse_object       *op);
-
-void
-acpi_ps_delete_parse_cache (
-	void);
-
-u8
-acpi_ps_is_leading_char (
-	u32                     c);
-
-u8
-acpi_ps_is_prefix_char (
-	u32                     c);
-
-u32
-acpi_ps_get_name(
-	acpi_parse_object       *op);
-
-void
-acpi_ps_set_name(
-	acpi_parse_object       *op,
-	u32                     name);
-
-
-/* psdump - display parser tree */
-
-u32
-acpi_ps_sprint_path (
-	NATIVE_CHAR             *buffer_start,
-	u32                     buffer_size,
-	acpi_parse_object       *op);
-
-u32
-acpi_ps_sprint_op (
-	NATIVE_CHAR             *buffer_start,
-	u32                     buffer_size,
-	acpi_parse_object       *op);
-
-void
-acpi_ps_show (
-	acpi_parse_object       *op);
-
-
-#endif /* __ACPARSER_H__ */
diff -urNp linux-5400/drivers/acpi/include/acpi.h linux-5410/drivers/acpi/include/acpi.h
--- linux-5400/drivers/acpi/include/acpi.h
+++ linux-5410/drivers/acpi/include/acpi.h
@@ -1,51 +0,0 @@
-/******************************************************************************
- *
- * Name: acpi.h - Master include file, Publics and external data.
- *       $Revision: 54 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACPI_H__
-#define __ACPI_H__
-
-/*
- * Common includes for all ACPI driver files
- * We put them here because we don't want to duplicate them
- * in the rest of the source code again and again.
- */
-#include "acconfig.h"           /* Configuration constants */
-#include "platform/acenv.h"     /* Target environment specific items */
-#include "actypes.h"            /* Fundamental common data types */
-#include "acexcep.h"            /* ACPI exception codes */
-#include "acmacros.h"           /* C macros */
-#include "actbl.h"              /* ACPI table definitions */
-#include "aclocal.h"            /* Internal data types */
-#include "acoutput.h"           /* Error output and Debug macros */
-#include "acpiosxf.h"           /* Interfaces to the ACPI-to-OS layer*/
-#include "acpixf.h"             /* ACPI core subsystem external interfaces */
-#include "acobject.h"           /* ACPI internal object */
-#include "acstruct.h"           /* Common structures */
-#include "acglobal.h"           /* All global variables */
-#include "achware.h"            /* Hardware defines and interfaces */
-#include "acutils.h"            /* Utility interfaces */
-
-
-#endif /* __ACPI_H__ */
diff -urNp linux-5400/drivers/acpi/include/acpiosxf.h linux-5410/drivers/acpi/include/acpiosxf.h
--- linux-5400/drivers/acpi/include/acpiosxf.h
+++ linux-5410/drivers/acpi/include/acpiosxf.h
@@ -1,307 +0,0 @@
-
-/******************************************************************************
- *
- * Name: acpiosxf.h - All interfaces to the OS Services Layer (OSL).  These
- *                    interfaces must be implemented by OSL to interface the
- *                    ACPI components to the host operating system.
- *
- *****************************************************************************/
-
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACPIOSXF_H__
-#define __ACPIOSXF_H__
-
-#include "platform/acenv.h"
-#include "actypes.h"
-
-
-/* Priorities for Acpi_os_queue_for_execution */
-
-#define OSD_PRIORITY_GPE            1
-#define OSD_PRIORITY_HIGH           2
-#define OSD_PRIORITY_MED            3
-#define OSD_PRIORITY_LO             4
-
-#define ACPI_NO_UNIT_LIMIT          ((u32) -1)
-#define ACPI_MUTEX_SEM              1
-
-
-/* Functions for Acpi_os_signal */
-
-#define ACPI_SIGNAL_FATAL           0
-#define ACPI_SIGNAL_BREAKPOINT      1
-
-typedef struct acpi_fatal_info
-{
-	u32                     type;
-	u32                     code;
-	u32                     argument;
-
-} ACPI_SIGNAL_FATAL_INFO;
-
-
-/*
- * Types specific to the OS service interfaces
- */
-
-typedef
-u32 (*OSD_HANDLER) (
-	void                    *context);
-
-typedef
-void (*OSD_EXECUTION_CALLBACK) (
-	void                    *context);
-
-
-/*
- * OSL Initialization and shutdown primitives
- */
-
-acpi_status
-acpi_os_initialize (
-	void);
-
-acpi_status
-acpi_os_terminate (
-	void);
-
-acpi_status
-acpi_os_get_root_pointer (
-	u32                     flags,
-	ACPI_PHYSICAL_ADDRESS   *rsdp_physical_address);
-
-
-/*
- * Synchronization primitives
- */
-
-acpi_status
-acpi_os_create_semaphore (
-	u32                     max_units,
-	u32                     initial_units,
-	acpi_handle             *out_handle);
-
-acpi_status
-acpi_os_delete_semaphore (
-	acpi_handle             handle);
-
-acpi_status
-acpi_os_wait_semaphore (
-	acpi_handle             handle,
-	u32                     units,
-	u32                     timeout);
-
-acpi_status
-acpi_os_signal_semaphore (
-	acpi_handle             handle,
-	u32                     units);
-
-
-/*
- * Memory allocation and mapping
- */
-
-void *
-acpi_os_allocate (
-	u32                     size);
-
-void *
-acpi_os_callocate (
-	u32                     size);
-
-void
-acpi_os_free (
-	void *                  memory);
-
-acpi_status
-acpi_os_map_memory (
-	ACPI_PHYSICAL_ADDRESS   physical_address,
-	u32                     length,
-	void                    **logical_address);
-
-void
-acpi_os_unmap_memory (
-	void                    *logical_address,
-	u32                     length);
-
-acpi_status
-acpi_os_get_physical_address (
-	void                    *logical_address,
-	ACPI_PHYSICAL_ADDRESS   *physical_address);
-
-
-/*
- * Interrupt handlers
- */
-
-acpi_status
-acpi_os_install_interrupt_handler (
-	u32                     interrupt_number,
-	OSD_HANDLER             service_routine,
-	void                    *context);
-
-acpi_status
-acpi_os_remove_interrupt_handler (
-	u32                     interrupt_number,
-	OSD_HANDLER             service_routine);
-
-
-/*
- * Threads and Scheduling
- */
-
-u32
-acpi_os_get_thread_id (
-	void);
-
-acpi_status
-acpi_os_queue_for_execution (
-	u32                     priority,
-	OSD_EXECUTION_CALLBACK  function,
-	void                    *context);
-
-void
-acpi_os_sleep (
-	u32                     seconds,
-	u32                     milliseconds);
-
-void
-acpi_os_stall (
-	u32                     microseconds);
-
-
-/*
- * Platform and hardware-independent I/O interfaces
- */
-
-acpi_status
-acpi_os_read_port (
-	ACPI_IO_ADDRESS         address,
-	void                    *value,
-	u32                     width);
-
-
-acpi_status
-acpi_os_write_port (
-	ACPI_IO_ADDRESS         address,
-	NATIVE_UINT             value,
-	u32                     width);
-
-
-/*
- * Platform and hardware-independent physical memory interfaces
- */
-
-acpi_status
-acpi_os_read_memory (
-	ACPI_PHYSICAL_ADDRESS   address,
-	void                    *value,
-	u32                     width);
-
-
-acpi_status
-acpi_os_write_memory (
-	ACPI_PHYSICAL_ADDRESS   address,
-	NATIVE_UINT             value,
-	u32                     width);
-
-
-/*
- * Platform and hardware-independent PCI configuration space access
- */
-
-acpi_status
-acpi_os_read_pci_configuration (
-	acpi_pci_id             *pci_id,
-	u32                     register,
-	void                    *value,
-	u32                     width);
-
-
-acpi_status
-acpi_os_write_pci_configuration (
-	acpi_pci_id             *pci_id,
-	u32                     register,
-	NATIVE_UINT             value,
-	u32                     width);
-
-
-/*
- * Miscellaneous
- */
-
-u8
-acpi_os_readable (
-	void                    *pointer,
-	u32                     length);
-
-
-u8
-acpi_os_writable (
-	void                    *pointer,
-	u32                     length);
-
-u32
-acpi_os_get_timer (
-	void);
-
-acpi_status
-acpi_os_signal (
-	u32                     function,
-	void                    *info);
-
-/*
- * Debug print routines
- */
-
-s32
-acpi_os_printf (
-	const NATIVE_CHAR       *format,
-	...);
-
-s32
-acpi_os_vprintf (
-	const NATIVE_CHAR       *format,
-	va_list                 args);
-
-
-/*
- * Debug input
- */
-
-u32
-acpi_os_get_line (
-	NATIVE_CHAR             *buffer);
-
-
-/*
- * Debug
- */
-
-void
-acpi_os_dbg_assert(
-	void                    *failed_assertion,
-	void                    *file_name,
-	u32                     line_number,
-	NATIVE_CHAR             *message);
-
-
-#endif /* __ACPIOSXF_H__ */
diff -urNp linux-5400/drivers/acpi/include/acpixf.h linux-5410/drivers/acpi/include/acpixf.h
--- linux-5400/drivers/acpi/include/acpixf.h
+++ linux-5410/drivers/acpi/include/acpixf.h
@@ -1,326 +0,0 @@
-
-/******************************************************************************
- *
- * Name: acpixf.h - External interfaces to the ACPI subsystem
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#ifndef __ACXFACE_H__
-#define __ACXFACE_H__
-
-#include "actypes.h"
-#include "actbl.h"
-
-
- /*
- * Global interfaces
- */
-
-acpi_status
-acpi_initialize_subsystem (
-	void);
-
-acpi_status
-acpi_enable_subsystem (
-	u32                     flags);
-
-acpi_status
-acpi_terminate (
-	void);
-
-acpi_status
-acpi_subsystem_status (
-	void);
-
-acpi_status
-acpi_enable (
-	void);
-
-acpi_status
-acpi_disable (
-	void);
-
-acpi_status
-acpi_get_system_info (
-	acpi_buffer             *ret_buffer);
-
-const char *
-acpi_format_exception (
-	acpi_status             exception);
-
-
-/*
- * ACPI Memory manager
- */
-
-void *
-acpi_allocate (
-	u32                     size);
-
-void *
-acpi_callocate (
-	u32                     size);
-
-void
-acpi_free (
-	void                    *address);
-
-
-/*
- * ACPI table manipulation interfaces
- */
-
-acpi_status
-acpi_find_root_pointer (
-	u32                     flags,
-	ACPI_PHYSICAL_ADDRESS   *rsdp_physical_address);
-
-acpi_status
-acpi_load_tables (
-	void);
-
-acpi_status
-acpi_load_table (
-	acpi_table_header       *table_ptr);
-
-acpi_status
-acpi_unload_table (
-	acpi_table_type         table_type);
-
-acpi_status
-acpi_get_table_header (
-	acpi_table_type         table_type,
-	u32                     instance,
-	acpi_table_header       *out_table_header);
-
-acpi_status
-acpi_get_table (
-	acpi_table_type         table_type,
-	u32                     instance,
-	acpi_buffer             *ret_buffer);
-
-acpi_status
-acpi_get_firmware_table (
-	acpi_string             signature,
-	u32                     instance,
-	u32                     flags,
-	acpi_table_header       **table_pointer);
-
-
-/*
- * Namespace and name interfaces
- */
-
-acpi_status
-acpi_walk_namespace (
-	acpi_object_type        type,
-	acpi_handle             start_object,
-	u32                     max_depth,
-	acpi_walk_callback      user_function,
-	void                    *context,
-	void *                  *return_value);
-
-acpi_status
-acpi_get_devices (
-	NATIVE_CHAR             *HID,
-	acpi_walk_callback      user_function,
-	void                    *context,
-	void                    **return_value);
-
-acpi_status
-acpi_get_name (
-	acpi_handle             handle,
-	u32                     name_type,
-	acpi_buffer             *ret_path_ptr);
-
-acpi_status
-acpi_get_handle (
-	acpi_handle             parent,
-	acpi_string             pathname,
-	acpi_handle             *ret_handle);
-
-
-/*
- * Object manipulation and enumeration
- */
-
-acpi_status
-acpi_evaluate_object (
-	acpi_handle             object,
-	acpi_string             pathname,
-	acpi_object_list        *parameter_objects,
-	acpi_buffer             *return_object_buffer);
-
-acpi_status
-acpi_get_object_info (
-	acpi_handle             device,
-	acpi_device_info        *info);
-
-acpi_status
-acpi_get_next_object (
-	acpi_object_type        type,
-	acpi_handle             parent,
-	acpi_handle             child,
-	acpi_handle             *out_handle);
-
-acpi_status
-acpi_get_type (
-	acpi_handle             object,
-	acpi_object_type        *out_type);
-
-acpi_status
-acpi_get_parent (
-	acpi_handle             object,
-	acpi_handle             *out_handle);
-
-
-/*
- * Event handler interfaces
- */
-
-acpi_status
-acpi_install_fixed_event_handler (
-	u32                     acpi_event,
-	acpi_event_handler      handler,
-	void                    *context);
-
-acpi_status
-acpi_remove_fixed_event_handler (
-	u32                     acpi_event,
-	acpi_event_handler      handler);
-
-acpi_status
-acpi_install_notify_handler (
-	acpi_handle             device,
-	u32                     handler_type,
-	acpi_notify_handler     handler,
-	void                    *context);
-
-acpi_status
-acpi_remove_notify_handler (
-	acpi_handle             device,
-	u32                     handler_type,
-	acpi_notify_handler     handler);
-
-acpi_status
-acpi_install_address_space_handler (
-	acpi_handle             device,
-	ACPI_ADR_SPACE_TYPE     space_id,
-	acpi_adr_space_handler  handler,
-	acpi_adr_space_setup    setup,
-	void                    *context);
-
-acpi_status
-acpi_remove_address_space_handler (
-	acpi_handle             device,
-	ACPI_ADR_SPACE_TYPE     space_id,
-	acpi_adr_space_handler  handler);
-
-acpi_status
-acpi_install_gpe_handler (
-	u32                     gpe_number,
-	u32                     type,
-	acpi_gpe_handler        handler,
-	void                    *context);
-
-acpi_status
-acpi_acquire_global_lock (
-	void);
-
-acpi_status
-acpi_release_global_lock (
-	void);
-
-acpi_status
-acpi_remove_gpe_handler (
-	u32                     gpe_number,
-	acpi_gpe_handler        handler);
-
-acpi_status
-acpi_enable_event (
-	u32                     acpi_event,
-	u32                     type,
-	u32                     flags);
-
-acpi_status
-acpi_disable_event (
-	u32                     acpi_event,
-	u32                     type,
-	u32                     flags);
-
-acpi_status
-acpi_clear_event (
-	u32                     acpi_event,
-	u32                     type);
-
-acpi_status
-acpi_get_event_status (
-	u32                     acpi_event,
-	u32                     type,
-	acpi_event_status       *event_status);
-
-/*
- * Resource interfaces
- */
-
-acpi_status
-acpi_get_current_resources(
-	acpi_handle             device_handle,
-	acpi_buffer             *ret_buffer);
-
-acpi_status
-acpi_get_possible_resources(
-	acpi_handle             device_handle,
-	acpi_buffer             *ret_buffer);
-
-acpi_status
-acpi_set_current_resources (
-	acpi_handle             device_handle,
-	acpi_buffer             *in_buffer);
-
-acpi_status
-acpi_get_irq_routing_table (
-	acpi_handle             bus_device_handle,
-	acpi_buffer             *ret_buffer);
-
-
-/*
- * Hardware (ACPI device) interfaces
- */
-
-acpi_status
-acpi_set_firmware_waking_vector (
-	ACPI_PHYSICAL_ADDRESS   physical_address);
-
-acpi_status
-acpi_get_firmware_waking_vector (
-	ACPI_PHYSICAL_ADDRESS   *physical_address);
-
-acpi_status
-acpi_enter_sleep_state (
-	u8 sleep_state);
-
-acpi_status
-acpi_leave_sleep_state (
-	u8 sleep_state);
-
-#endif /* __ACXFACE_H__ */
diff -urNp linux-5400/drivers/acpi/include/acresrc.h linux-5410/drivers/acpi/include/acresrc.h
--- linux-5400/drivers/acpi/include/acresrc.h
+++ linux-5410/drivers/acpi/include/acresrc.h
@@ -1,320 +0,0 @@
-/******************************************************************************
- *
- * Name: acresrc.h - Resource Manager function prototypes
- *       $Revision: 25 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACRESRC_H__
-#define __ACRESRC_H__
-
-
-/*
- *  Function prototypes called from Acpi* APIs
- */
-
-acpi_status
-acpi_rs_get_prt_method_data (
-	acpi_handle             handle,
-	acpi_buffer             *ret_buffer);
-
-
-acpi_status
-acpi_rs_get_crs_method_data (
-	acpi_handle             handle,
-	acpi_buffer             *ret_buffer);
-
-acpi_status
-acpi_rs_get_prs_method_data (
-	acpi_handle             handle,
-	acpi_buffer             *ret_buffer);
-
-acpi_status
-acpi_rs_set_srs_method_data (
-	acpi_handle             handle,
-	acpi_buffer             *ret_buffer);
-
-acpi_status
-acpi_rs_create_resource_list (
-	acpi_operand_object     *byte_stream_buffer,
-	u8                      *output_buffer,
-	u32                     *output_buffer_length);
-
-acpi_status
-acpi_rs_create_byte_stream (
-	acpi_resource           *linked_list_buffer,
-	u8                      *output_buffer,
-	u32                     *output_buffer_length);
-
-acpi_status
-acpi_rs_create_pci_routing_table (
-	acpi_operand_object     *method_return_object,
-	u8                      *output_buffer,
-	u32                     *output_buffer_length);
-
-
-/*
- *Function prototypes called from Acpi_rs_create*APIs
- */
-
-void
-acpi_rs_dump_resource_list (
-	acpi_resource           *resource);
-
-void
-acpi_rs_dump_irq_list (
-	u8                      *route_table);
-
-acpi_status
-acpi_rs_get_byte_stream_start (
-	u8                      *byte_stream_buffer,
-	u8                      **byte_stream_start,
-	u32                     *size);
-
-acpi_status
-acpi_rs_calculate_list_length (
-	u8                      *byte_stream_buffer,
-	u32                     byte_stream_buffer_length,
-	u32                     *size_needed);
-
-acpi_status
-acpi_rs_calculate_byte_stream_length (
-	acpi_resource           *linked_list_buffer,
-	u32                     *size_needed);
-
-acpi_status
-acpi_rs_calculate_pci_routing_table_length (
-	acpi_operand_object     *package_object,
-	u32                     *buffer_size_needed);
-
-acpi_status
-acpi_rs_byte_stream_to_list (
-	u8                      *byte_stream_buffer,
-	u32                     byte_stream_buffer_length,
-	u8                      **output_buffer);
-
-acpi_status
-acpi_rs_list_to_byte_stream (
-	acpi_resource           *linked_list,
-	u32                     byte_stream_size_needed,
-	u8                      **output_buffer);
-
-acpi_status
-acpi_rs_io_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size);
-
-acpi_status
-acpi_rs_fixed_io_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size);
-
-acpi_status
-acpi_rs_io_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed);
-
-acpi_status
-acpi_rs_fixed_io_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed);
-
-acpi_status
-acpi_rs_irq_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size);
-
-acpi_status
-acpi_rs_irq_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed);
-
-acpi_status
-acpi_rs_dma_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size);
-
-acpi_status
-acpi_rs_dma_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed);
-
-acpi_status
-acpi_rs_address16_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size);
-
-acpi_status
-acpi_rs_address16_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed);
-
-acpi_status
-acpi_rs_address32_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size);
-
-acpi_status
-acpi_rs_address32_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed);
-
-acpi_status
-acpi_rs_address64_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size);
-
-acpi_status
-acpi_rs_address64_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed);
-
-acpi_status
-acpi_rs_start_dependent_functions_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size);
-
-acpi_status
-acpi_rs_end_dependent_functions_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size);
-
-acpi_status
-acpi_rs_start_dependent_functions_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed);
-
-acpi_status
-acpi_rs_end_dependent_functions_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed);
-
-acpi_status
-acpi_rs_memory24_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size);
-
-acpi_status
-acpi_rs_memory24_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed);
-
-acpi_status
-acpi_rs_memory32_range_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size
-);
-
-acpi_status
-acpi_rs_fixed_memory32_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size);
-
-acpi_status
-acpi_rs_memory32_range_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed);
-
-acpi_status
-acpi_rs_fixed_memory32_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed);
-
-acpi_status
-acpi_rs_extended_irq_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size);
-
-acpi_status
-acpi_rs_extended_irq_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed);
-
-acpi_status
-acpi_rs_end_tag_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size);
-
-acpi_status
-acpi_rs_end_tag_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed);
-
-acpi_status
-acpi_rs_vendor_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size);
-
-acpi_status
-acpi_rs_vendor_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed);
-
-u8
-acpi_rs_get_resource_type (
-	u8                      resource_start_byte);
-
-#endif  /* __ACRESRC_H__ */
diff -urNp linux-5400/drivers/acpi/include/acstruct.h linux-5410/drivers/acpi/include/acstruct.h
--- linux-5400/drivers/acpi/include/acstruct.h
+++ linux-5410/drivers/acpi/include/acstruct.h
@@ -1,199 +0,0 @@
-/******************************************************************************
- *
- * Name: acstruct.h - Internal structs
- *       $Revision: 10 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACSTRUCT_H__
-#define __ACSTRUCT_H__
-
-
-/*****************************************************************************
- *
- * Tree walking typedefs and structs
- *
- ****************************************************************************/
-
-
-/*
- * Walk state - current state of a parse tree walk.  Used for both a leisurely stroll through
- * the tree (for whatever reason), and for control method execution.
- */
-
-#define NEXT_OP_DOWNWARD    1
-#define NEXT_OP_UPWARD      2
-
-#define WALK_NON_METHOD     0
-#define WALK_METHOD         1
-#define WALK_METHOD_RESTART 2
-
-typedef struct acpi_walk_state
-{
-	u8                      data_type;                          /* To differentiate various internal objs MUST BE FIRST!*/\
-	acpi_owner_id           owner_id;                           /* Owner of objects created during the walk */
-	u8                      last_predicate;                     /* Result of last predicate */
-	u8                      current_result;                     /* */
-	u8                      next_op_info;                       /* Info about Next_op */
-	u8                      num_operands;                       /* Stack pointer for Operands[] array */
-	u8                      return_used;
-	u8                      walk_type;
-	u16                     current_sync_level;                 /* Mutex Sync (nested acquire) level */
-	u16                     opcode;                             /* Current AML opcode */
-	u32                     arg_count;                          /* push for fixed or var args */
-	u32                     aml_offset;
-	u32                     arg_types;
-	u32                     method_breakpoint;                  /* For single stepping */
-	u32                     parse_flags;
-	u32                     prev_arg_types;
-
-
-	u8                      *aml_last_while;
-	struct acpi_node        arguments[MTH_NUM_ARGS];            /* Control method arguments */
-	union acpi_operand_obj  **caller_return_desc;
-	acpi_generic_state      *control_state;                     /* List of control states (nested IFs) */
-	struct acpi_node        local_variables[MTH_NUM_LOCALS];    /* Control method locals */
-	struct acpi_node        *method_call_node;                  /* Called method Node*/
-	acpi_parse_object       *method_call_op;                    /* Method_call Op if running a method */
-	union acpi_operand_obj  *method_desc;                       /* Method descriptor if running a method */
-	struct acpi_node        *method_node;                       /* Method Node if running a method */
-	acpi_parse_object       *op;                                /* Current parser op */
-	union acpi_operand_obj  *operands[OBJ_NUM_OPERANDS+1];      /* Operands passed to the interpreter (+1 for NULL terminator) */
-	const acpi_opcode_info  *op_info;                           /* Info on current opcode */
-	acpi_parse_object       *origin;                            /* Start of walk [Obsolete] */
-	union acpi_operand_obj  **params;
-	acpi_parse_state        parser_state;                       /* Current state of parser */
-	union acpi_operand_obj  *result_obj;
-	acpi_generic_state      *results;                           /* Stack of accumulated results */
-	union acpi_operand_obj  *return_desc;                       /* Return object, if any */
-	acpi_generic_state      *scope_info;                        /* Stack of nested scopes */
-
-/* TBD: Obsolete with removal of WALK procedure ? */
-	acpi_parse_object       *prev_op;                           /* Last op that was processed */
-	acpi_parse_object       *next_op;                           /* next op to be processed */
-
-
-	acpi_parse_downwards    descending_callback;
-	acpi_parse_upwards      ascending_callback;
-	struct acpi_walk_list   *walk_list;
-	struct acpi_walk_state  *next;                              /* Next Walk_state in list */
-
-
-} acpi_walk_state;
-
-
-/*
- * Walk list - head of a tree of walk states.  Multiple walk states are created when there
- * are nested control methods executing.
- */
-typedef struct acpi_walk_list
-{
-
-	acpi_walk_state         *walk_state;
-	ACPI_OBJECT_MUTEX       acquired_mutex_list;               /* List of all currently acquired mutexes */
-
-} acpi_walk_list;
-
-
-/* Info used by Acpi_ps_init_objects */
-
-typedef struct acpi_init_walk_info
-{
-	u16                     method_count;
-	u16                     op_region_count;
-	u16                     field_count;
-	u16                     op_region_init;
-	u16                     field_init;
-	u16                     object_count;
-	acpi_table_desc         *table_desc;
-
-} acpi_init_walk_info;
-
-
-/* Info used by TBD */
-
-typedef struct acpi_device_walk_info
-{
-	u16                     device_count;
-	u16                     num_STA;
-	u16                     num_INI;
-	acpi_table_desc         *table_desc;
-
-} acpi_device_walk_info;
-
-
-/* TBD: [Restructure] Merge with struct above */
-
-typedef struct acpi_walk_info
-{
-	u32                     debug_level;
-	u32                     owner_id;
-	u8                      display_type;
-
-} acpi_walk_info;
-
-/* Display Types */
-
-#define ACPI_DISPLAY_SUMMARY    0
-#define ACPI_DISPLAY_OBJECTS    1
-
-typedef struct acpi_get_devices_info
-{
-	acpi_walk_callback      user_function;
-	void                    *context;
-	NATIVE_CHAR             *hid;
-
-} acpi_get_devices_info;
-
-
-typedef union acpi_aml_operands
-{
-	acpi_operand_object         *operands[7];
-
-	struct
-	{
-		ACPI_OBJECT_INTEGER     *type;
-		ACPI_OBJECT_INTEGER     *code;
-		ACPI_OBJECT_INTEGER     *argument;
-
-	} fatal;
-
-	struct
-	{
-		acpi_operand_object     *source;
-		ACPI_OBJECT_INTEGER     *index;
-		acpi_operand_object     *target;
-
-	} index;
-
-	struct
-	{
-		acpi_operand_object     *source;
-		ACPI_OBJECT_INTEGER     *index;
-		ACPI_OBJECT_INTEGER     *length;
-		acpi_operand_object     *target;
-
-	} mid;
-
-} ACPI_AML_OPERANDS;
-
-
-#endif
diff -urNp linux-5400/drivers/acpi/include/actables.h linux-5410/drivers/acpi/include/actables.h
--- linux-5400/drivers/acpi/include/actables.h
+++ linux-5410/drivers/acpi/include/actables.h
@@ -1,200 +0,0 @@
-/******************************************************************************
- *
- * Name: actables.h - ACPI table management
- *       $Revision: 32 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACTABLES_H__
-#define __ACTABLES_H__
-
-
-/* Used in Acpi_tb_map_acpi_table for size parameter if table header is to be used */
-
-#define SIZE_IN_HEADER          0
-
-
-acpi_status
-acpi_tb_handle_to_object (
-	u16                     table_id,
-	acpi_table_desc         **table_desc);
-
-/*
- * tbconvrt - Table conversion routines
- */
-
-acpi_status
-acpi_tb_convert_to_xsdt (
-	acpi_table_desc         *table_info,
-	u32                     *number_of_tables);
-
-acpi_status
-acpi_tb_convert_table_fadt (
-	void);
-
-acpi_status
-acpi_tb_build_common_facs (
-	acpi_table_desc         *table_info);
-
-u32
-acpi_tb_get_table_count (
-	RSDP_DESCRIPTOR         *RSDP,
-	acpi_table_header       *RSDT);
-
-/*
- * tbget - Table "get" routines
- */
-
-acpi_status
-acpi_tb_get_table_ptr (
-	acpi_table_type         table_type,
-	u32                     instance,
-	acpi_table_header       **table_ptr_loc);
-
-acpi_status
-acpi_tb_get_table (
-	ACPI_PHYSICAL_ADDRESS   physical_address,
-	acpi_table_header       *buffer_ptr,
-	acpi_table_desc         *table_info);
-
-acpi_status
-acpi_tb_verify_rsdp (
-	ACPI_PHYSICAL_ADDRESS   RSDP_physical_address);
-
-acpi_status
-acpi_tb_get_table_facs (
-	acpi_table_header       *buffer_ptr,
-	acpi_table_desc         *table_info);
-
-ACPI_PHYSICAL_ADDRESS
-acpi_tb_get_rsdt_address (
-	void);
-
-acpi_status
-acpi_tb_validate_rsdt (
-	acpi_table_header       *table_ptr);
-
-acpi_status
-acpi_tb_get_table_pointer (
-	ACPI_PHYSICAL_ADDRESS   physical_address,
-	u32                     flags,
-	u32                     *size,
-	acpi_table_header       **table_ptr);
-
-/*
- * tbgetall - Get all firmware ACPI tables
- */
-
-acpi_status
-acpi_tb_get_all_tables (
-	u32                     number_of_tables,
-	acpi_table_header       *buffer_ptr);
-
-
-/*
- * tbinstall - Table installation
- */
-
-acpi_status
-acpi_tb_install_table (
-	acpi_table_header       *table_ptr,
-	acpi_table_desc         *table_info);
-
-acpi_status
-acpi_tb_recognize_table (
-	acpi_table_header       *table_ptr,
-	acpi_table_desc         *table_info);
-
-acpi_status
-acpi_tb_init_table_descriptor (
-	acpi_table_type         table_type,
-	acpi_table_desc         *table_info);
-
-
-/*
- * tbremove - Table removal and deletion
- */
-
-void
-acpi_tb_delete_acpi_tables (
-	void);
-
-void
-acpi_tb_delete_acpi_table (
-	acpi_table_type         type);
-
-void
-acpi_tb_delete_single_table (
-	acpi_table_desc         *table_desc);
-
-acpi_table_desc *
-acpi_tb_uninstall_table (
-	acpi_table_desc         *table_desc);
-
-void
-acpi_tb_free_acpi_tables_of_type (
-	acpi_table_desc         *table_info);
-
-
-/*
- * tbrsd - RSDP, RSDT utilities
- */
-
-acpi_status
-acpi_tb_get_table_rsdt (
-	u32                     *number_of_tables);
-
-u8 *
-acpi_tb_scan_memory_for_rsdp (
-	u8                      *start_address,
-	u32                     length);
-
-acpi_status
-acpi_tb_find_rsdp (
-	acpi_table_desc         *table_info,
-	u32                     flags);
-
-
-/*
- * tbutils - common table utilities
- */
-
-acpi_status
-acpi_tb_map_acpi_table (
-	ACPI_PHYSICAL_ADDRESS   physical_address,
-	u32                     *size,
-	acpi_table_header       **logical_address);
-
-acpi_status
-acpi_tb_verify_table_checksum (
-	acpi_table_header       *table_header);
-
-u8
-acpi_tb_checksum (
-	void                    *buffer,
-	u32                     length);
-
-acpi_status
-acpi_tb_validate_table_header (
-	acpi_table_header       *table_header);
-
-
-#endif /* __ACTABLES_H__ */
diff -urNp linux-5400/drivers/acpi/include/actbl.h linux-5410/drivers/acpi/include/actbl.h
--- linux-5400/drivers/acpi/include/actbl.h
+++ linux-5410/drivers/acpi/include/actbl.h
@@ -1,217 +0,0 @@
-/******************************************************************************
- *
- * Name: actbl.h - Table data structures defined in ACPI specification
- *       $Revision: 46 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACTBL_H__
-#define __ACTBL_H__
-
-
-/*
- *  Values for description table header signatures
- */
-
-#define RSDP_NAME               "RSDP"
-#define RSDP_SIG                "RSD PTR "  /* RSDT Pointer signature */
-#define APIC_SIG                "APIC"      /* Multiple APIC Description Table */
-#define DSDT_SIG                "DSDT"      /* Differentiated System Description Table */
-#define FADT_SIG                "FACP"      /* Fixed ACPI Description Table */
-#define FACS_SIG                "FACS"      /* Firmware ACPI Control Structure */
-#define PSDT_SIG                "PSDT"      /* Persistent System Description Table */
-#define RSDT_SIG                "RSDT"      /* Root System Description Table */
-#define XSDT_SIG                "XSDT"      /* Extended  System Description Table */
-#define SSDT_SIG                "SSDT"      /* Secondary System Description Table */
-#define SBST_SIG                "SBST"      /* Smart Battery Specification Table */
-#define SPIC_SIG                "SPIC"      /* iosapic table */
-#define BOOT_SIG                "BOOT"      /* Boot table */
-
-
-#define GL_OWNED                0x02        /* Ownership of global lock is bit 1 */
-
-/* values of Mapic.Model */
-
-#define DUAL_PIC                0
-#define MULTIPLE_APIC           1
-
-/* values of Type in APIC_HEADER */
-
-#define APIC_PROC               0
-#define APIC_IO                 1
-
-
-/*
- * Common table types.  The base code can remain
- * constant if the underlying tables are changed
- */
-#define RSDT_DESCRIPTOR         RSDT_DESCRIPTOR_REV2
-#define xsdt_descriptor         XSDT_DESCRIPTOR_REV2
-#define FACS_DESCRIPTOR         facs_descriptor_rev2
-#define FADT_DESCRIPTOR         fadt_descriptor_rev2
-
-
-#pragma pack(1)
-
-/*
- * Architecture-independent tables
- * The architecture dependent tables are in separate files
- */
-
-typedef struct  /* Root System Descriptor Pointer */
-{
-	NATIVE_CHAR             signature [8];          /* contains "RSD PTR " */
-	u8                      checksum;               /* to make sum of struct == 0 */
-	NATIVE_CHAR             oem_id [6];             /* OEM identification */
-	u8                      revision;               /* Must be 0 for 1.0, 2 for 2.0 */
-	u32                     rsdt_physical_address;  /* 32-bit physical address of RSDT */
-	u32                     length;                 /* XSDT Length in bytes including hdr */
-	u64                     xsdt_physical_address;  /* 64-bit physical address of XSDT */
-	u8                      extended_checksum;      /* Checksum of entire table */
-	NATIVE_CHAR             reserved [3];           /* reserved field must be 0 */
-
-} RSDP_DESCRIPTOR;
-
-
-typedef struct  /* ACPI common table header */
-{
-	NATIVE_CHAR             signature [4];          /* identifies type of table */
-	u32                     length;                 /* length of table, in bytes,
-			  * including header */
-	u8                      revision;               /* specification minor version # */
-	u8                      checksum;               /* to make sum of entire table == 0 */
-	NATIVE_CHAR             oem_id [6];             /* OEM identification */
-	NATIVE_CHAR             oem_table_id [8];       /* OEM table identification */
-	u32                     oem_revision;           /* OEM revision number */
-	NATIVE_CHAR             asl_compiler_id [4];    /* ASL compiler vendor ID */
-	u32                     asl_compiler_revision;  /* ASL compiler revision number */
-
-} acpi_table_header;
-
-
-typedef struct  /* Common FACS for internal use */
-{
-	u32                     *global_lock;
-	u64                     *firmware_waking_vector;
-	u8                      vector_width;
-
-} acpi_common_facs;
-
-
-typedef struct  /* APIC Table */
-{
-	acpi_table_header       header;                 /* table header */
-	u32                     local_apic_address;     /* Physical address for accessing local APICs */
-	u32                     PCATcompat      : 1;    /* a one indicates system also has dual 8259s */
-	u32                     reserved1       : 31;
-
-} APIC_TABLE;
-
-
-typedef struct  /* APIC Header */
-{
-	u8                      type;                   /* APIC type.  Either APIC_PROC or APIC_IO */
-	u8                      length;                 /* Length of APIC structure */
-
-} APIC_HEADER;
-
-
-typedef struct  /* Processor APIC */
-{
-	APIC_HEADER             header;
-	u8                      processor_apic_id;      /* ACPI processor id */
-	u8                      local_apic_id;          /* processor's local APIC id */
-	u32                     processor_enabled: 1;   /* Processor is usable if set */
-	u32                     reserved1       : 31;
-
-} PROCESSOR_APIC;
-
-
-typedef struct  /* IO APIC */
-{
-	APIC_HEADER             header;
-	u8                      io_apic_id;             /* I/O APIC ID */
-	u8                      reserved;               /* reserved - must be zero */
-	u32                     io_apic_address;        /* APIC's physical address */
-	u32                     vector;                 /* interrupt vector index where INTI
-			  * lines start */
-} IO_APIC;
-
-
-/*
-**  IA64 TODO:  Add SAPIC Tables
-*/
-
-/*
-**  IA64 TODO:  Modify Smart Battery Description to comply with ACPI IA64
-**              extensions.
-*/
-typedef struct  /* Smart Battery Description Table */
-{
-	acpi_table_header       header;
-	u32                     warning_level;
-	u32                     low_level;
-	u32                     critical_level;
-
-} SMART_BATTERY_DESCRIPTION_TABLE;
-
-
-#pragma pack()
-
-
-/*
- * ACPI Table information.  We save the table address, length,
- * and type of memory allocation (mapped or allocated) for each
- * table for 1) when we exit, and 2) if a new table is installed
- */
-
-#define ACPI_MEM_NOT_ALLOCATED  0
-#define ACPI_MEM_ALLOCATED      1
-#define ACPI_MEM_MAPPED         2
-
-/* Definitions for the Flags bitfield member of ACPI_TABLE_SUPPORT */
-
-#define ACPI_TABLE_SINGLE       0
-#define ACPI_TABLE_MULTIPLE     1
-
-
-/* Data about each known table type */
-
-typedef struct _acpi_table_support
-{
-	NATIVE_CHAR             *name;
-	NATIVE_CHAR             *signature;
-	u8                      sig_length;
-	u8                      flags;
-	u16                     status;
-	void                    **global_ptr;
-
-} ACPI_TABLE_SUPPORT;
-
-/*
- * Get the architecture-specific tables
- */
-
-#include "actbl1.h"   /* Acpi 1.0 table defintions */
-#include "actbl71.h"  /* Acpi 0.71 IA-64 Extension table defintions */
-#include "actbl2.h"   /* Acpi 2.0 table definitions */
-
-#endif /* __ACTBL_H__ */
diff -urNp linux-5400/drivers/acpi/include/actbl1.h linux-5410/drivers/acpi/include/actbl1.h
--- linux-5400/drivers/acpi/include/actbl1.h
+++ linux-5410/drivers/acpi/include/actbl1.h
@@ -1,123 +0,0 @@
-/******************************************************************************
- *
- * Name: actbl1.h - ACPI 1.0 tables
- *       $Revision: 17 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACTBL1_H__
-#define __ACTBL1_H__
-
-#pragma pack(1)
-
-/*************************************/
-/* ACPI Specification Rev 1.0 for    */
-/* the Root System Description Table */
-/*************************************/
-typedef struct
-{
-	acpi_table_header       header;                 /* Table header */
-	u32                     table_offset_entry [1]; /* Array of pointers to other */
-			 /* ACPI tables */
-} RSDT_DESCRIPTOR_REV1;
-
-
-/***************************************/
-/* ACPI Specification Rev 1.0 for      */
-/* the Firmware ACPI Control Structure */
-/***************************************/
-typedef struct
-{
-	NATIVE_CHAR             signature[4];           /* signature "FACS" */
-	u32                     length;                 /* length of structure, in bytes */
-	u32                     hardware_signature;     /* hardware configuration signature */
-	u32                     firmware_waking_vector; /* ACPI OS waking vector */
-	u32                     global_lock;            /* Global Lock */
-	u32                     S4bios_f        : 1;    /* Indicates if S4BIOS support is present */
-	u32                     reserved1       : 31;   /* must be 0 */
-	u8                      resverved3 [40];        /* reserved - must be zero */
-
-} facs_descriptor_rev1;
-
-
-/************************************/
-/* ACPI Specification Rev 1.0 for   */
-/* the Fixed ACPI Description Table */
-/************************************/
-typedef struct
-{
-	acpi_table_header       header;                 /* table header */
-	u32                     firmware_ctrl;          /* Physical address of FACS */
-	u32                     dsdt;                   /* Physical address of DSDT */
-	u8                      model;                  /* System Interrupt Model */
-	u8                      reserved1;              /* reserved */
-	u16                     sci_int;                /* System vector of SCI interrupt */
-	u32                     smi_cmd;                /* Port address of SMI command port */
-	u8                      acpi_enable;            /* value to write to smi_cmd to enable ACPI */
-	u8                      acpi_disable;           /* value to write to smi_cmd to disable ACPI */
-	u8                      S4bios_req;             /* Value to write to SMI CMD to enter S4BIOS state */
-	u8                      reserved2;              /* reserved - must be zero */
-	u32                     pm1a_evt_blk;           /* Port address of Power Mgt 1a Acpi_event Reg Blk */
-	u32                     pm1b_evt_blk;           /* Port address of Power Mgt 1b Acpi_event Reg Blk */
-	u32                     pm1a_cnt_blk;           /* Port address of Power Mgt 1a Control Reg Blk */
-	u32                     pm1b_cnt_blk;           /* Port address of Power Mgt 1b Control Reg Blk */
-	u32                     pm2_cnt_blk;            /* Port address of Power Mgt 2 Control Reg Blk */
-	u32                     pm_tmr_blk;             /* Port address of Power Mgt Timer Ctrl Reg Blk */
-	u32                     gpe0blk;                /* Port addr of General Purpose Acpi_event 0 Reg Blk */
-	u32                     gpe1_blk;               /* Port addr of General Purpose Acpi_event 1 Reg Blk */
-	u8                      pm1_evt_len;            /* Byte Length of ports at pm1_x_evt_blk */
-	u8                      pm1_cnt_len;            /* Byte Length of ports at pm1_x_cnt_blk */
-	u8                      pm2_cnt_len;            /* Byte Length of ports at pm2_cnt_blk */
-	u8                      pm_tm_len;              /* Byte Length of ports at pm_tm_blk */
-	u8                      gpe0blk_len;            /* Byte Length of ports at gpe0_blk */
-	u8                      gpe1_blk_len;           /* Byte Length of ports at gpe1_blk */
-	u8                      gpe1_base;              /* offset in gpe model where gpe1 events start */
-	u8                      reserved3;              /* reserved */
-	u16                     plvl2_lat;              /* worst case HW latency to enter/exit C2 state */
-	u16                     plvl3_lat;              /* worst case HW latency to enter/exit C3 state */
-	u16                     flush_size;             /* Size of area read to flush caches */
-	u16                     flush_stride;           /* Stride used in flushing caches */
-	u8                      duty_offset;            /* bit location of duty cycle field in p_cnt reg */
-	u8                      duty_width;             /* bit width of duty cycle field in p_cnt reg */
-	u8                      day_alrm;               /* index to day-of-month alarm in RTC CMOS RAM */
-	u8                      mon_alrm;               /* index to month-of-year alarm in RTC CMOS RAM */
-	u8                      century;                /* index to century in RTC CMOS RAM */
-	u8                      reserved4;              /* reserved */
-	u8                      reserved4a;             /* reserved */
-	u8                      reserved4b;             /* reserved */
-	u32                     wb_invd         : 1;    /* wbinvd instruction works properly */
-	u32                     wb_invd_flush   : 1;    /* wbinvd flushes but does not invalidate */
-	u32                     proc_c1         : 1;    /* all processors support C1 state */
-	u32                     plvl2_up        : 1;    /* C2 state works on MP system */
-	u32                     pwr_button      : 1;    /* Power button is handled as a generic feature */
-	u32                     sleep_button    : 1;    /* Sleep button is handled as a generic feature, or not present */
-	u32                     fixed_rTC       : 1;    /* RTC wakeup stat not in fixed register space */
-	u32                     rtcs4           : 1;    /* RTC wakeup stat not possible from S4 */
-	u32                     tmr_val_ext     : 1;    /* tmr_val is 32 bits */
-	u32                     reserved5       : 23;   /* reserved - must be zero */
-
-}  fadt_descriptor_rev1;
-
-#pragma pack()
-
-#endif /* __ACTBL1_H__ */
-
-
diff -urNp linux-5400/drivers/acpi/include/actbl2.h linux-5410/drivers/acpi/include/actbl2.h
--- linux-5400/drivers/acpi/include/actbl2.h
+++ linux-5410/drivers/acpi/include/actbl2.h
@@ -1,186 +0,0 @@
-/******************************************************************************
- *
- * Name: actbl2.h - ACPI Specification Revision 2.0 Tables
- *       $Revision: 24 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACTBL2_H__
-#define __ACTBL2_H__
-
-/*
- * Prefered Power Management Profiles
- */
-#define PM_UNSPECIFIED                  0
-#define PM_DESKTOP                      1
-#define PM_MOBILE                       2
-#define PM_WORKSTATION                  3
-#define PM_ENTERPRISE_SERVER            4
-#define PM_SOHO_SERVER                  5
-#define PM_APPLIANCE_PC                 6
-
-/*
- * ACPI Boot Arch Flags
- */
-#define BAF_LEGACY_DEVICES              0x0001
-#define BAF_8042_KEYBOARD_CONTROLLER    0x0002
-
-#define FADT2_REVISION_ID               3
-
-
-#pragma pack(1)
-
-/*
- * ACPI Specification Rev 2.0 for the Root System Description Table
- */
-typedef struct
-{
-	acpi_table_header       header;                 /* Table header */
-	u32                     table_offset_entry [1]; /* Array of pointers to  */
-			 /* other tables' headers */
-} RSDT_DESCRIPTOR_REV2;
-
-
-/*
- * ACPI Specification Rev 2.0 for the Extended System Description Table (XSDT)
- */
-typedef struct
-{
-	acpi_table_header       header;                 /* Table header */
-	u64                     table_offset_entry [1]; /* Array of pointers to  */
-			 /* other tables' headers */
-} XSDT_DESCRIPTOR_REV2;
-
-
-/*
- * ACPI Specification Rev 2.0 for the Firmware ACPI Control Structure
- */
-typedef struct
-{
-	NATIVE_CHAR             signature[4];           /* signature "FACS" */
-	u32                     length;                 /* length of structure, in bytes */
-	u32                     hardware_signature;     /* hardware configuration signature */
-	u32                     firmware_waking_vector; /* 32bit physical address of the Firmware Waking Vector. */
-	u32                     global_lock;            /* Global Lock used to synchronize access to shared hardware resources */
-	u32                     S4bios_f        : 1;    /* Indicates if S4BIOS support is present */
-	u32                     reserved1       : 31;   /* must be 0 */
-	u64                     Xfirmware_waking_vector; /* 64bit physical address of the Firmware Waking Vector. */
-	u8                      version;                /* Version of this table */
-	u8                      reserved3 [31];         /* reserved - must be zero */
-
-} facs_descriptor_rev2;
-
-
-/*
- * ACPI Specification Rev 2.0 for the Generic Address Structure (GAS)
- */
-typedef struct
-{
-	u8                      address_space_id;       /* Address space where struct or register exists. */
-	u8                      register_bit_width;     /* Size in bits of given register */
-	u8                      register_bit_offset;    /* Bit offset within the register */
-	u8                      reserved;               /* Must be 0 */
-	u64                     address;                /* 64-bit address of struct or register */
-
-} acpi_generic_address;
-
-
-/*
- * ACPI Specification Rev 2.0 for the Fixed ACPI Description Table
- */
-typedef struct
-{
-	acpi_table_header       header;             /* table header */
-	u32                     V1_firmware_ctrl;   /* 32-bit physical address of FACS */
-	u32                     V1_dsdt;            /* 32-bit physical address of DSDT */
-	u8                      reserved1;          /* System Interrupt Model isn't used in ACPI 2.0*/
-	u8                      prefer_PM_profile;  /* Conveys preferred power management profile to OSPM. */
-	u16                     sci_int;            /* System vector of SCI interrupt */
-	u32                     smi_cmd;            /* Port address of SMI command port */
-	u8                      acpi_enable;        /* value to write to smi_cmd to enable ACPI */
-	u8                      acpi_disable;       /* value to write to smi_cmd to disable ACPI */
-	u8                      S4bios_req;         /* Value to write to SMI CMD to enter S4BIOS state */
-	u8                      pstate_cnt;         /* processor performance state control*/
-	u32                     V1_pm1a_evt_blk;    /* Port address of Power Mgt 1a Acpi_event Reg Blk */
-	u32                     V1_pm1b_evt_blk;    /* Port address of Power Mgt 1b Acpi_event Reg Blk */
-	u32                     V1_pm1a_cnt_blk;    /* Port address of Power Mgt 1a Control Reg Blk */
-	u32                     V1_pm1b_cnt_blk;    /* Port address of Power Mgt 1b Control Reg Blk */
-	u32                     V1_pm2_cnt_blk;     /* Port address of Power Mgt 2 Control Reg Blk */
-	u32                     V1_pm_tmr_blk;      /* Port address of Power Mgt Timer Ctrl Reg Blk */
-	u32                     V1_gpe0blk;         /* Port addr of General Purpose Acpi_event 0 Reg Blk */
-	u32                     V1_gpe1_blk;        /* Port addr of General Purpose Acpi_event 1 Reg Blk */
-	u8                      pm1_evt_len;        /* Byte Length of ports at pm1_x_evt_blk */
-	u8                      pm1_cnt_len;        /* Byte Length of ports at pm1_x_cnt_blk */
-	u8                      pm2_cnt_len;        /* Byte Length of ports at pm2_cnt_blk */
-	u8                      pm_tm_len;          /* Byte Length of ports at pm_tm_blk */
-	u8                      gpe0blk_len;        /* Byte Length of ports at gpe0_blk */
-	u8                      gpe1_blk_len;       /* Byte Length of ports at gpe1_blk */
-	u8                      gpe1_base;          /* offset in gpe model where gpe1 events start */
-	u8                      cst_cnt;            /* Support for the _CST object and C States change notification.*/
-	u16                     plvl2_lat;          /* worst case HW latency to enter/exit C2 state */
-	u16                     plvl3_lat;          /* worst case HW latency to enter/exit C3 state */
-	u16                     flush_size;         /* number of flush strides that need to be read */
-	u16                     flush_stride;       /* Processor's memory cache line width, in bytes */
-	u8                      duty_offset;        /* Processor_s duty cycle index in processor's P_CNT reg*/
-	u8                      duty_width;         /* Processor_s duty cycle value bit width in P_CNT register.*/
-	u8                      day_alrm;           /* index to day-of-month alarm in RTC CMOS RAM */
-	u8                      mon_alrm;           /* index to month-of-year alarm in RTC CMOS RAM */
-	u8                      century;            /* index to century in RTC CMOS RAM */
-	u16                     iapc_boot_arch;     /* IA-PC Boot Architecture Flags. See Table 5-10 for description*/
-	u8                      reserved2;          /* reserved */
-	u32                     wb_invd     : 1;    /* wbinvd instruction works properly */
-	u32                     wb_invd_flush : 1;  /* wbinvd flushes but does not invalidate */
-	u32                     proc_c1     : 1;    /* all processors support C1 state */
-	u32                     plvl2_up    : 1;    /* C2 state works on MP system */
-	u32                     pwr_button  : 1;    /* Power button is handled as a generic feature */
-	u32                     sleep_button : 1;   /* Sleep button is handled as a generic feature, or not present */
-	u32                     fixed_rTC   : 1;    /* RTC wakeup stat not in fixed register space */
-	u32                     rtcs4       : 1;    /* RTC wakeup stat not possible from S4 */
-	u32                     tmr_val_ext : 1;    /* tmr_val is 32 bits */
-	u32                     dock_cap    : 1;    /* Supports Docking */
-	u32                     reset_reg_sup : 1;  /* Indicates system supports system reset via the FADT RESET_REG*/
-	u32                     sealed_case : 1;    /* Indicates system has no internal expansion capabilities and case is sealed. */
-	u32                     headless    : 1;    /* Indicates system does not have local video capabilities or local input devices.*/
-	u32                     cpu_sw_sleep : 1;   /* Indicates to OSPM that a processor native instruction */
-			   /* must be executed after writing the SLP_TYPx register. */
-	u32                     reserved6   : 18;   /* reserved - must be zero */
-
-	acpi_generic_address    reset_register;     /* Reset register address in GAS format */
-	u8                      reset_value;        /* Value to write to the Reset_register port to reset the system. */
-	u8                      reserved7[3];       /* These three bytes must be zero */
-	u64                     Xfirmware_ctrl;     /* 64-bit physical address of FACS */
-	u64                     Xdsdt;              /* 64-bit physical address of DSDT */
-	acpi_generic_address    Xpm1a_evt_blk;      /* Extended Power Mgt 1a Acpi_event Reg Blk address */
-	acpi_generic_address    Xpm1b_evt_blk;      /* Extended Power Mgt 1b Acpi_event Reg Blk address */
-	acpi_generic_address    Xpm1a_cnt_blk;      /* Extended Power Mgt 1a Control Reg Blk address */
-	acpi_generic_address    Xpm1b_cnt_blk;      /* Extended Power Mgt 1b Control Reg Blk address */
-	acpi_generic_address    Xpm2_cnt_blk;       /* Extended Power Mgt 2 Control Reg Blk address */
-	acpi_generic_address    Xpm_tmr_blk;        /* Extended Power Mgt Timer Ctrl Reg Blk address */
-	acpi_generic_address    Xgpe0blk;           /* Extended General Purpose Acpi_event 0 Reg Blk address */
-	acpi_generic_address    Xgpe1_blk;          /* Extended General Purpose Acpi_event 1 Reg Blk address */
-
-}  fadt_descriptor_rev2;
-
-
-#pragma pack()
-
-#endif /* __ACTBL2_H__ */
-
diff -urNp linux-5400/drivers/acpi/include/actbl71.h linux-5410/drivers/acpi/include/actbl71.h
--- linux-5400/drivers/acpi/include/actbl71.h
+++ linux-5410/drivers/acpi/include/actbl71.h
@@ -1,147 +0,0 @@
-/******************************************************************************
- *
- * Name: actbl71.h - IA-64 Extensions to the ACPI Spec Rev. 0.71
- *                   This file includes tables specific to this
- *                   specification revision.
- *       $Revision: 11 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACTBL71_H__
-#define __ACTBL71_H__
-
-
-/* 0.71 FADT Address_space data item bitmasks defines */
-/* If the associated bit is zero then it is in memory space else in io space */
-
-#define SMI_CMD_ADDRESS_SPACE       0x01
-#define PM1_BLK_ADDRESS_SPACE       0x02
-#define PM2_CNT_BLK_ADDRESS_SPACE   0x04
-#define PM_TMR_BLK_ADDRESS_SPACE    0x08
-#define GPE0_BLK_ADDRESS_SPACE      0x10
-#define GPE1_BLK_ADDRESS_SPACE      0x20
-
-/* Only for clarity in declarations */
-
-typedef u64                 IO_ADDRESS;
-
-
-#pragma pack(1)
-typedef struct  /* Root System Descriptor Pointer */
-{
-	NATIVE_CHAR             signature [8];          /* contains "RSD PTR " */
-	u8                      checksum;               /* to make sum of struct == 0 */
-	NATIVE_CHAR             oem_id [6];             /* OEM identification */
-	u8                      reserved;               /* Must be 0 for 1.0, 2 for 2.0 */
-	u64                     rsdt_physical_address;  /* 64-bit physical address of RSDT */
-} RSDP_DESCRIPTOR_REV071;
-
-
-/*****************************************/
-/* IA64 Extensions to ACPI Spec Rev 0.71 */
-/* for the Root System Description Table */
-/*****************************************/
-typedef struct
-{
-	acpi_table_header   header;                 /* Table header */
-	u32                 reserved_pad;           /* IA64 alignment, must be 0 */
-	u64                 table_offset_entry [1]; /* Array of pointers to other */
-			   /* tables' headers */
-} RSDT_DESCRIPTOR_REV071;
-
-
-/*******************************************/
-/* IA64 Extensions to ACPI Spec Rev 0.71   */
-/* for the Firmware ACPI Control Structure */
-/*******************************************/
-typedef struct
-{
-	NATIVE_CHAR         signature[4];         /* signature "FACS" */
-	u32                 length;               /* length of structure, in bytes */
-	u32                 hardware_signature;   /* hardware configuration signature */
-	u32                 reserved4;            /* must be 0 */
-	u64                 firmware_waking_vector; /* ACPI OS waking vector */
-	u64                 global_lock;          /* Global Lock */
-	u32                 S4bios_f      : 1;    /* Indicates if S4BIOS support is present */
-	u32                 reserved1     : 31;   /* must be 0 */
-	u8                  reserved3 [28];       /* reserved - must be zero */
-
-} facs_descriptor_rev071;
-
-
-/******************************************/
-/* IA64 Extensions to ACPI Spec Rev 0.71  */
-/* for the Fixed ACPI Description Table   */
-/******************************************/
-typedef struct
-{
-	acpi_table_header   header;             /* table header */
-	u32                 reserved_pad;       /* IA64 alignment, must be 0 */
-	u64                 firmware_ctrl;      /* 64-bit Physical address of FACS */
-	u64                 dsdt;               /* 64-bit Physical address of DSDT */
-	u8                  model;              /* System Interrupt Model */
-	u8                  address_space;      /* Address Space Bitmask */
-	u16                 sci_int;            /* System vector of SCI interrupt */
-	u8                  acpi_enable;        /* value to write to smi_cmd to enable ACPI */
-	u8                  acpi_disable;       /* value to write to smi_cmd to disable ACPI */
-	u8                  S4bios_req;         /* Value to write to SMI CMD to enter S4BIOS state */
-	u8                  reserved2;          /* reserved - must be zero */
-	u64                 smi_cmd;            /* Port address of SMI command port */
-	u64                 pm1a_evt_blk;       /* Port address of Power Mgt 1a Acpi_event Reg Blk */
-	u64                 pm1b_evt_blk;       /* Port address of Power Mgt 1b Acpi_event Reg Blk */
-	u64                 pm1a_cnt_blk;       /* Port address of Power Mgt 1a Control Reg Blk */
-	u64                 pm1b_cnt_blk;       /* Port address of Power Mgt 1b Control Reg Blk */
-	u64                 pm2_cnt_blk;        /* Port address of Power Mgt 2 Control Reg Blk */
-	u64                 pm_tmr_blk;         /* Port address of Power Mgt Timer Ctrl Reg Blk */
-	u64                 gpe0blk;            /* Port addr of General Purpose Acpi_event 0 Reg Blk */
-	u64                 gpe1_blk;           /* Port addr of General Purpose Acpi_event 1 Reg Blk */
-	u8                  pm1_evt_len;        /* Byte Length of ports at pm1_x_evt_blk */
-	u8                  pm1_cnt_len;        /* Byte Length of ports at pm1_x_cnt_blk */
-	u8                  pm2_cnt_len;        /* Byte Length of ports at pm2_cnt_blk */
-	u8                  pm_tm_len;          /* Byte Length of ports at pm_tm_blk */
-	u8                  gpe0blk_len;        /* Byte Length of ports at gpe0_blk */
-	u8                  gpe1_blk_len;       /* Byte Length of ports at gpe1_blk */
-	u8                  gpe1_base;          /* offset in gpe model where gpe1 events start */
-	u8                  reserved3;          /* reserved */
-	u16                 plvl2_lat;          /* worst case HW latency to enter/exit C2 state */
-	u16                 plvl3_lat;          /* worst case HW latency to enter/exit C3 state */
-	u8                  day_alrm;           /* index to day-of-month alarm in RTC CMOS RAM */
-	u8                  mon_alrm;           /* index to month-of-year alarm in RTC CMOS RAM */
-	u8                  century;            /* index to century in RTC CMOS RAM */
-	u8                  reserved4;          /* reserved */
-	u32                 flush_cash  : 1;    /* PAL_FLUSH_CACHE is correctly supported */
-	u32                 reserved5   : 1;    /* reserved - must be zero */
-	u32                 proc_c1     : 1;    /* all processors support C1 state */
-	u32                 plvl2_up    : 1;    /* C2 state works on MP system */
-	u32                 pwr_button  : 1;    /* Power button is handled as a generic feature */
-	u32                 sleep_button : 1;   /* Sleep button is handled as a generic feature, or not present */
-	u32                 fixed_rTC   : 1;    /* RTC wakeup stat not in fixed register space */
-	u32                 rtcs4       : 1;    /* RTC wakeup stat not possible from S4 */
-	u32                 tmr_val_ext : 1;    /* tmr_val is 32 bits */
-	u32                 dock_cap    : 1;    /* Supports Docking */
-	u32                 reserved6   : 22;    /* reserved - must be zero */
-
-}  fadt_descriptor_rev071;
-
-#pragma pack()
-
-#endif /* __ACTBL71_H__ */
-
diff -urNp linux-5400/drivers/acpi/include/actypes.h linux-5410/drivers/acpi/include/actypes.h
--- linux-5400/drivers/acpi/include/actypes.h
+++ linux-5410/drivers/acpi/include/actypes.h
@@ -1,1118 +0,0 @@
-/******************************************************************************
- *
- * Name: actypes.h - Common data types for the entire ACPI subsystem
- *       $Revision: 193 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACTYPES_H__
-#define __ACTYPES_H__
-
-/*! [Begin] no source code translation (keep the typedefs) */
-
-/*
- * Data types - Fixed across all compilation models
- *
- * BOOLEAN      Logical Boolean.
- *              1 byte value containing a 0 for FALSE or a 1 for TRUE.
- *              Other values are undefined.
- *
- * INT8         8-bit  (1 byte) signed value
- * UINT8        8-bit  (1 byte) unsigned value
- * INT16        16-bit (2 byte) signed value
- * UINT16       16-bit (2 byte) unsigned value
- * INT32        32-bit (4 byte) signed value
- * UINT32       32-bit (4 byte) unsigned value
- * INT64        64-bit (8 byte) signed value
- * UINT64       64-bit (8 byte) unsigned value
- * NATIVE_INT   32-bit on IA-32, 64-bit on IA-64 signed value
- * NATIVE_UINT  32-bit on IA-32, 64-bit on IA-64 unsigned value
- * UCHAR        Character. 1 byte unsigned value.
- */
-
-#ifndef BITS_PER_LONG
-#error "define BITS_PER_LONG"
-#endif
-
-#if BITS_PER_LONG == 64
-/*
- * 64-bit type definitions
- */
-typedef unsigned char                   UINT8;
-typedef unsigned char                   BOOLEAN;
-typedef unsigned char                   UCHAR;
-typedef unsigned short                  UINT16;
-typedef int                             INT32;
-typedef unsigned int                    UINT32;
-typedef COMPILER_DEPENDENT_UINT64       UINT64;
-
-typedef UINT64                          NATIVE_UINT;
-typedef long long                          NATIVE_INT;
-
-typedef NATIVE_UINT                     ACPI_TBLPTR;
-typedef UINT64                          ACPI_IO_ADDRESS;
-typedef UINT64                          ACPI_PHYSICAL_ADDRESS;
-
-#define ALIGNED_ADDRESS_BOUNDARY        0x00000008      /* No hardware alignment support in IA64 */
-#define ACPI_USE_NATIVE_DIVIDE                          /* Native 64-bit integer support */
-
-
-#elif BITS_PER_LONG == 16
-/*
- * 16-bit type definitions
- */
-typedef unsigned char                   UINT8;
-typedef unsigned char                   BOOLEAN;
-typedef unsigned char                   UCHAR;
-typedef unsigned int                    UINT16;
-typedef long                            INT32;
-typedef int                             INT16;
-typedef unsigned long                   UINT32;
-
-typedef struct
-{
-	UINT32                                  Lo;
-	UINT32                                  Hi;
-
-} UINT64;
-
-typedef UINT16                          NATIVE_UINT;
-typedef INT16                           NATIVE_INT;
-
-typedef UINT32                          ACPI_TBLPTR;
-typedef UINT32                          ACPI_IO_ADDRESS;
-typedef char                            *ACPI_PHYSICAL_ADDRESS;
-
-#define ALIGNED_ADDRESS_BOUNDARY        0x00000002
-#define _HW_ALIGNMENT_SUPPORT
-#define ACPI_USE_NATIVE_DIVIDE                          /* No 64-bit integers, ok to use native divide */
-
-/*
- * (16-bit only) internal integers must be 32-bits, so
- * 64-bit integers cannot be supported
- */
-#define ACPI_NO_INTEGER64_SUPPORT
-
-
-#elif BITS_PER_LONG == 32
-/*
- * 32-bit type definitions (default)
- */
-typedef unsigned char                   UINT8;
-typedef unsigned char                   BOOLEAN;
-typedef unsigned char                   UCHAR;
-typedef unsigned short                  UINT16;
-typedef int                             INT32;
-typedef unsigned int                    UINT32;
-typedef COMPILER_DEPENDENT_UINT64       UINT64;
-
-typedef UINT32                          NATIVE_UINT;
-typedef INT32                           NATIVE_INT;
-
-typedef NATIVE_UINT                     ACPI_TBLPTR;
-typedef UINT32                          ACPI_IO_ADDRESS;
-typedef UINT64                          ACPI_PHYSICAL_ADDRESS;
-
-#define ALIGNED_ADDRESS_BOUNDARY        0x00000004
-#define _HW_ALIGNMENT_SUPPORT
-
-#else
-#error "unknown BITS_PER_LONG"
-#endif
-
-
-
-/*
- * Miscellaneous common types
- */
-
-typedef UINT32                          UINT32_BIT;
-typedef NATIVE_UINT                     ACPI_PTRDIFF;
-typedef char                            NATIVE_CHAR;
-
-
-/*
- * Data type ranges
- */
-
-#define ACPI_UINT8_MAX                  (UINT8)  0xFF
-#define ACPI_UINT16_MAX                 (UINT16) 0xFFFF
-#define ACPI_UINT32_MAX                 (UINT32) 0xFFFFFFFF
-#define ACPI_UINT64_MAX                 (UINT64) 0xFFFFFFFFFFFFFFFF
-
-
-#ifdef DEFINE_ALTERNATE_TYPES
-/*
- * Types used only in translated source
- */
-typedef INT32                           s32;
-typedef UINT8                           u8;
-typedef UINT16                          u16;
-typedef UINT32                          u32;
-typedef UINT64                          u64;
-#endif
-/*! [End] no source code translation !*/
-
-
-/*
- * Useful defines
- */
-
-#ifdef FALSE
-#undef FALSE
-#endif
-#define FALSE                           (1 == 0)
-
-#ifdef TRUE
-#undef TRUE
-#endif
-#define TRUE                            (1 == 1)
-
-#ifndef NULL
-#define NULL                            (void *) 0
-#endif
-
-
-/*
- * Local datatypes
- */
-
-typedef u32                             acpi_status;    /* All ACPI Exceptions */
-typedef u32                             acpi_name;      /* 4-byte ACPI name */
-typedef char*                           acpi_string;    /* Null terminated ASCII string */
-typedef void*                           acpi_handle;    /* Actually a ptr to an Node */
-
-typedef struct
-{
-	u32                         lo;
-	u32                         hi;
-
-} uint64_struct;
-
-typedef union
-{
-	u64                         full;
-	uint64_struct               part;
-
-} uint64_overlay;
-
-
-/*
- * Acpi integer width. In ACPI version 1, integers are
- * 32 bits.  In ACPI version 2, integers are 64 bits.
- * Note that this pertains to the ACPI integer type only, not
- * other integers used in the implementation of the ACPI CA
- * subsystem.
- */
-#ifdef ACPI_NO_INTEGER64_SUPPORT
-
-/* 32-bit integers only, no 64-bit support */
-
-typedef u32                             acpi_integer;
-#define ACPI_INTEGER_MAX                ACPI_UINT32_MAX
-#define ACPI_INTEGER_BIT_SIZE           32
-#define ACPI_MAX_BCD_VALUE              99999999
-#define ACPI_MAX_BCD_DIGITS             8
-#define ACPI_MAX_DECIMAL_DIGITS         10
-
-#define ACPI_USE_NATIVE_DIVIDE          /* Use compiler native 32-bit divide */
-
-
-#else
-
-/* 64-bit integers */
-
-typedef u64                             acpi_integer;
-#define ACPI_INTEGER_MAX                ACPI_UINT64_MAX
-#define ACPI_INTEGER_BIT_SIZE           64
-#define ACPI_MAX_BCD_VALUE              9999999999999999
-#define ACPI_MAX_BCD_DIGITS             16
-#define ACPI_MAX_DECIMAL_DIGITS         19
-
-#ifdef _IA64
-#define ACPI_USE_NATIVE_DIVIDE          /* Use compiler native 64-bit divide */
-#endif
-#endif
-
-
-/*
- * Constants with special meanings
- */
-
-#define ACPI_ROOT_OBJECT                (acpi_handle)(-1)
-
-
-/*
- * Initialization sequence
- */
-#define ACPI_FULL_INITIALIZATION        0x00
-#define ACPI_NO_ADDRESS_SPACE_INIT      0x01
-#define ACPI_NO_HARDWARE_INIT           0x02
-#define ACPI_NO_EVENT_INIT              0x04
-#define ACPI_NO_ACPI_ENABLE             0x08
-#define ACPI_NO_DEVICE_INIT             0x10
-#define ACPI_NO_OBJECT_INIT             0x20
-
-/*
- * Initialization state
- */
-#define ACPI_INITIALIZED_OK             0x01
-
-/*
- * Power state values
- */
-
-#define ACPI_STATE_UNKNOWN              (u8) 0xFF
-
-#define ACPI_STATE_S0                   (u8) 0
-#define ACPI_STATE_S1                   (u8) 1
-#define ACPI_STATE_S2                   (u8) 2
-#define ACPI_STATE_S3                   (u8) 3
-#define ACPI_STATE_S4                   (u8) 4
-#define ACPI_STATE_S5                   (u8) 5
-#define ACPI_S_STATES_MAX               ACPI_STATE_S5
-#define ACPI_S_STATE_COUNT              6
-
-#define ACPI_STATE_D0                   (u8) 0
-#define ACPI_STATE_D1                   (u8) 1
-#define ACPI_STATE_D2                   (u8) 2
-#define ACPI_STATE_D3                   (u8) 3
-#define ACPI_D_STATES_MAX               ACPI_STATE_D3
-#define ACPI_D_STATE_COUNT              4
-
-/*
- * Standard notify values
- */
-#define ACPI_NOTIFY_BUS_CHECK           (u8) 0
-#define ACPI_NOTIFY_DEVICE_CHECK        (u8) 1
-#define ACPI_NOTIFY_DEVICE_WAKE         (u8) 2
-#define ACPI_NOTIFY_EJECT_REQUEST       (u8) 3
-#define ACPI_NOTIFY_DEVICE_CHECK_LIGHT  (u8) 4
-#define ACPI_NOTIFY_FREQUENCY_MISMATCH  (u8) 5
-#define ACPI_NOTIFY_BUS_MODE_MISMATCH   (u8) 6
-#define ACPI_NOTIFY_POWER_FAULT         (u8) 7
-
-
-/*
- *  Table types.  These values are passed to the table related APIs
- */
-
-typedef u32                             acpi_table_type;
-
-#define ACPI_TABLE_RSDP                 (acpi_table_type) 0
-#define ACPI_TABLE_DSDT                 (acpi_table_type) 1
-#define ACPI_TABLE_FADT                 (acpi_table_type) 2
-#define ACPI_TABLE_FACS                 (acpi_table_type) 3
-#define ACPI_TABLE_PSDT                 (acpi_table_type) 4
-#define ACPI_TABLE_SSDT                 (acpi_table_type) 5
-#define ACPI_TABLE_XSDT                 (acpi_table_type) 6
-#define ACPI_TABLE_MAX                  6
-#define NUM_ACPI_TABLES                 (ACPI_TABLE_MAX+1)
-
-
-/*
- * Types associated with names.  The first group of
- * values correspond to the definition of the ACPI
- * Object_type operator (See the ACPI Spec). Therefore,
- * only add to the first group if the spec changes!
- *
- * Types must be kept in sync with the Acpi_ns_properties
- * and Acpi_ns_type_names arrays
- */
-
-typedef u32                             acpi_object_type;
-typedef u8                              acpi_object_type8;
-
-
-#define ACPI_TYPE_ANY                   0  /* 0x00  */
-#define ACPI_TYPE_INTEGER               1  /* 0x01  Byte/Word/Dword/Zero/One/Ones */
-#define ACPI_TYPE_STRING                2  /* 0x02  */
-#define ACPI_TYPE_BUFFER                3  /* 0x03  */
-#define ACPI_TYPE_PACKAGE               4  /* 0x04  Byte_const, multiple Data_term/Constant/Super_name */
-#define ACPI_TYPE_FIELD_UNIT            5  /* 0x05  */
-#define ACPI_TYPE_DEVICE                6  /* 0x06  Name, multiple Node */
-#define ACPI_TYPE_EVENT                 7  /* 0x07  */
-#define ACPI_TYPE_METHOD                8  /* 0x08  Name, Byte_const, multiple Code */
-#define ACPI_TYPE_MUTEX                 9  /* 0x09  */
-#define ACPI_TYPE_REGION                10 /* 0x0A  */
-#define ACPI_TYPE_POWER                 11 /* 0x0B  Name,Byte_const,Word_const,multi Node */
-#define ACPI_TYPE_PROCESSOR             12 /* 0x0C  Name,Byte_const,DWord_const,Byte_const,multi Nm_o */
-#define ACPI_TYPE_THERMAL               13 /* 0x0D  Name, multiple Node */
-#define ACPI_TYPE_BUFFER_FIELD          14 /* 0x0E  */
-#define ACPI_TYPE_DDB_HANDLE            15 /* 0x0F  */
-#define ACPI_TYPE_DEBUG_OBJECT          16 /* 0x10  */
-
-#define ACPI_TYPE_MAX                   16
-
-/*
- * This section contains object types that do not relate to the ACPI Object_type operator.
- * They are used for various internal purposes only.  If new predefined ACPI_TYPEs are
- * added (via the ACPI specification), these internal types must move upwards.
- * Also, values exceeding the largest official ACPI Object_type must not overlap with
- * defined AML opcodes.
- */
-#define INTERNAL_TYPE_BEGIN             17
-
-#define INTERNAL_TYPE_REGION_FIELD      17 /* 0x11  */
-#define INTERNAL_TYPE_BANK_FIELD        18 /* 0x12  */
-#define INTERNAL_TYPE_INDEX_FIELD       19 /* 0x13  */
-#define INTERNAL_TYPE_REFERENCE         20 /* 0x14  Arg#, Local#, Name, Debug; used only in descriptors */
-#define INTERNAL_TYPE_ALIAS             21 /* 0x15  */
-#define INTERNAL_TYPE_NOTIFY            22 /* 0x16  */
-#define INTERNAL_TYPE_ADDRESS_HANDLER   23 /* 0x17  */
-#define INTERNAL_TYPE_RESOURCE          24 /* 0x18  */
-#define INTERNAL_TYPE_RESOURCE_FIELD    25 /* 0x19  */
-
-
-#define INTERNAL_TYPE_NODE_MAX          25
-
-/* These are pseudo-types because there are never any namespace nodes with these types */
-
-#define INTERNAL_TYPE_FIELD_DEFN        26 /* 0x1A  Name, Byte_const, multiple Field_element */
-#define INTERNAL_TYPE_BANK_FIELD_DEFN   27 /* 0x1B  2 Name,DWord_const,Byte_const,multi Field_element */
-#define INTERNAL_TYPE_INDEX_FIELD_DEFN  28 /* 0x1C  2 Name, Byte_const, multiple Field_element */
-#define INTERNAL_TYPE_IF                29 /* 0x1D  */
-#define INTERNAL_TYPE_ELSE              30 /* 0x1E  */
-#define INTERNAL_TYPE_WHILE             31 /* 0x1F  */
-#define INTERNAL_TYPE_SCOPE             32 /* 0x20  Name, multiple Node */
-#define INTERNAL_TYPE_DEF_ANY           33 /* 0x21  type is Any, suppress search of enclosing scopes */
-#define INTERNAL_TYPE_EXTRA             34 /* 0x22  */
-
-#define INTERNAL_TYPE_MAX               34
-
-#define INTERNAL_TYPE_INVALID           35
-#define ACPI_TYPE_NOT_FOUND             0xFF
-
-
-/*
- * Bitmapped ACPI types
- * Used internally only
- */
-#define ACPI_BTYPE_ANY                  0x00000000
-#define ACPI_BTYPE_INTEGER              0x00000001
-#define ACPI_BTYPE_STRING               0x00000002
-#define ACPI_BTYPE_BUFFER               0x00000004
-#define ACPI_BTYPE_PACKAGE              0x00000008
-#define ACPI_BTYPE_FIELD_UNIT           0x00000010
-#define ACPI_BTYPE_DEVICE               0x00000020
-#define ACPI_BTYPE_EVENT                0x00000040
-#define ACPI_BTYPE_METHOD               0x00000080
-#define ACPI_BTYPE_MUTEX                0x00000100
-#define ACPI_BTYPE_REGION               0x00000200
-#define ACPI_BTYPE_POWER                0x00000400
-#define ACPI_BTYPE_PROCESSOR            0x00000800
-#define ACPI_BTYPE_THERMAL              0x00001000
-#define ACPI_BTYPE_BUFFER_FIELD         0x00002000
-#define ACPI_BTYPE_DDB_HANDLE           0x00004000
-#define ACPI_BTYPE_DEBUG_OBJECT         0x00008000
-#define ACPI_BTYPE_REFERENCE            0x00010000
-#define ACPI_BTYPE_RESOURCE             0x00020000
-
-#define ACPI_BTYPE_COMPUTE_DATA         (ACPI_BTYPE_INTEGER | ACPI_BTYPE_STRING | ACPI_BTYPE_BUFFER)
-
-#define ACPI_BTYPE_DATA                 (ACPI_BTYPE_COMPUTE_DATA  | ACPI_BTYPE_PACKAGE)
-#define ACPI_BTYPE_DATA_REFERENCE       (ACPI_BTYPE_DATA | ACPI_BTYPE_REFERENCE | ACPI_BTYPE_DDB_HANDLE)
-#define ACPI_BTYPE_DEVICE_OBJECTS       (ACPI_BTYPE_DEVICE | ACPI_BTYPE_THERMAL | ACPI_BTYPE_PROCESSOR)
-#define ACPI_BTYPE_OBJECTS_AND_REFS     0x0001FFFF  /* ARG or LOCAL */
-#define ACPI_BTYPE_ALL_OBJECTS          0x0000FFFF
-
-
-/*
- * Acpi_event Types:
- * ------------
- * Fixed & general purpose...
- */
-
-typedef u32                             acpi_event_type;
-
-#define ACPI_EVENT_FIXED                (acpi_event_type) 0
-#define ACPI_EVENT_GPE                  (acpi_event_type) 1
-
-/*
- * Fixed events
- */
-
-#define ACPI_EVENT_PMTIMER              (acpi_event_type) 0
-	/*
-	 * There's no bus master event so index 1 is used for IRQ's that are not
-	 * handled by the SCI handler
-	 */
-#define ACPI_EVENT_NOT_USED             (acpi_event_type) 1
-#define ACPI_EVENT_GLOBAL               (acpi_event_type) 2
-#define ACPI_EVENT_POWER_BUTTON         (acpi_event_type) 3
-#define ACPI_EVENT_SLEEP_BUTTON         (acpi_event_type) 4
-#define ACPI_EVENT_RTC                  (acpi_event_type) 5
-#define ACPI_EVENT_GENERAL              (acpi_event_type) 6
-#define ACPI_EVENT_MAX                  6
-#define ACPI_NUM_FIXED_EVENTS           (acpi_event_type) 7
-
-#define ACPI_GPE_INVALID                0xFF
-#define ACPI_GPE_MAX                    0xFF
-#define ACPI_NUM_GPE                    256
-
-#define ACPI_EVENT_LEVEL_TRIGGERED      (acpi_event_type) 1
-#define ACPI_EVENT_EDGE_TRIGGERED       (acpi_event_type) 2
-
-/*
- * GPEs
- */
-#define ACPI_EVENT_ENABLE               0x1
-#define ACPI_EVENT_WAKE_ENABLE	        0x2
-
-#define ACPI_EVENT_DISABLE              0x1
-#define ACPI_EVENT_WAKE_DISABLE         0x2
-
-
-/*
- * Acpi_event Status:
- * -------------
- * The encoding of acpi_event_status is illustrated below.
- * Note that a set bit (1) indicates the property is TRUE
- * (e.g. if bit 0 is set then the event is enabled).
- * +-------------+-+-+-+
- * |   Bits 31:3 |2|1|0|
- * +-------------+-+-+-+
- *          |     | | |
- *          |     | | +- Enabled?
- *          |     | +--- Enabled for wake?
- *          |     +----- Set?
- *          +----------- <Reserved>
- */
-typedef u32                             acpi_event_status;
-
-#define ACPI_EVENT_FLAG_DISABLED        (acpi_event_status) 0x00
-#define ACPI_EVENT_FLAG_ENABLED         (acpi_event_status) 0x01
-#define ACPI_EVENT_FLAG_WAKE_ENABLED    (acpi_event_status) 0x02
-#define ACPI_EVENT_FLAG_SET             (acpi_event_status) 0x04
-
-
-/* Notify types */
-
-#define ACPI_SYSTEM_NOTIFY              0
-#define ACPI_DEVICE_NOTIFY              1
-#define ACPI_MAX_NOTIFY_HANDLER_TYPE    1
-
-#define MAX_SYS_NOTIFY                  0x7f
-
-
-/* Address Space (Operation Region) Types */
-
-typedef u8                              ACPI_ADR_SPACE_TYPE;
-
-#define ACPI_ADR_SPACE_SYSTEM_MEMORY    (ACPI_ADR_SPACE_TYPE) 0
-#define ACPI_ADR_SPACE_SYSTEM_IO        (ACPI_ADR_SPACE_TYPE) 1
-#define ACPI_ADR_SPACE_PCI_CONFIG       (ACPI_ADR_SPACE_TYPE) 2
-#define ACPI_ADR_SPACE_EC               (ACPI_ADR_SPACE_TYPE) 3
-#define ACPI_ADR_SPACE_SMBUS            (ACPI_ADR_SPACE_TYPE) 4
-#define ACPI_ADR_SPACE_CMOS             (ACPI_ADR_SPACE_TYPE) 5
-#define ACPI_ADR_SPACE_PCI_BAR_TARGET   (ACPI_ADR_SPACE_TYPE) 6
-
-
-/*
- * External ACPI object definition
- */
-
-typedef union acpi_obj
-{
-	acpi_object_type            type;   /* See definition of Acpi_ns_type for values */
-	struct
-	{
-		acpi_object_type            type;
-		acpi_integer                value;      /* The actual number */
-	} integer;
-
-	struct
-	{
-		acpi_object_type            type;
-		u32                         length;     /* # of bytes in string, excluding trailing null */
-		NATIVE_CHAR                 *pointer;   /* points to the string value */
-	} string;
-
-	struct
-	{
-		acpi_object_type            type;
-		u32                         length;     /* # of bytes in buffer */
-		u8                          *pointer;   /* points to the buffer */
-	} buffer;
-
-	struct
-	{
-		acpi_object_type            type;
-		u32                         fill1;
-		acpi_handle                 handle;     /* object reference */
-	} reference;
-
-	struct
-	{
-		acpi_object_type            type;
-		u32                         count;      /* # of elements in package */
-		union acpi_obj              *elements;  /* Pointer to an array of ACPI_OBJECTs */
-	} package;
-
-	struct
-	{
-		acpi_object_type            type;
-		u32                         proc_id;
-		ACPI_IO_ADDRESS             pblk_address;
-		u32                         pblk_length;
-	} processor;
-
-	struct
-	{
-		acpi_object_type            type;
-		u32                         system_level;
-		u32                         resource_order;
-	} power_resource;
-
-} acpi_object, *PACPI_OBJECT;
-
-
-/*
- * List of objects, used as a parameter list for control method evaluation
- */
-
-typedef struct acpi_obj_list
-{
-	u32                         count;
-	acpi_object                 *pointer;
-
-} acpi_object_list, *PACPI_OBJECT_LIST;
-
-
-/*
- * Miscellaneous common Data Structures used by the interfaces
- */
-
-typedef struct
-{
-	u32                         length;         /* Length in bytes of the buffer */
-	void                        *pointer;       /* pointer to buffer */
-
-} acpi_buffer;
-
-
-/*
- * Name_type for Acpi_get_name
- */
-
-#define ACPI_FULL_PATHNAME              0
-#define ACPI_SINGLE_NAME                1
-#define ACPI_NAME_TYPE_MAX              1
-
-
-/*
- * Structure and flags for Acpi_get_system_info
- */
-
-#define SYS_MODE_UNKNOWN                0x0000
-#define SYS_MODE_ACPI                   0x0001
-#define SYS_MODE_LEGACY                 0x0002
-#define SYS_MODES_MASK                  0x0003
-
-
-/*
- * ACPI Table Info.  One per ACPI table _type_
- */
-typedef struct acpi_table_info
-{
-	u32                         count;
-
-} acpi_table_info;
-
-
-/*
- * System info returned by Acpi_get_system_info()
- */
-
-typedef struct _acpi_sys_info
-{
-	u32                         acpi_ca_version;
-	u32                         flags;
-	u32                         timer_resolution;
-	u32                         reserved1;
-	u32                         reserved2;
-	u32                         debug_level;
-	u32                         debug_layer;
-	u32                         num_table_types;
-	acpi_table_info             table_info [NUM_ACPI_TABLES];
-
-} acpi_system_info;
-
-
-/*
- * Various handlers and callback procedures
- */
-
-typedef
-u32 (*acpi_event_handler) (
-	void                        *context);
-
-typedef
-void (*acpi_gpe_handler) (
-	void                        *context);
-
-typedef
-void (*acpi_notify_handler) (
-	acpi_handle                 device,
-	u32                         value,
-	void                        *context);
-
-
-/* Address Spaces (Operation Regions */
-
-#define ACPI_READ_ADR_SPACE     1
-#define ACPI_WRITE_ADR_SPACE    2
-
-typedef
-acpi_status (*acpi_adr_space_handler) (
-	u32                         function,
-	ACPI_PHYSICAL_ADDRESS       address,
-	u32                         bit_width,
-	u32                         *value,
-	void                        *handler_context,
-	void                        *region_context);
-
-#define ACPI_DEFAULT_HANDLER            ((acpi_adr_space_handler) NULL)
-
-
-typedef
-acpi_status (*acpi_adr_space_setup) (
-	acpi_handle                 region_handle,
-	u32                         function,
-	void                        *handler_context,
-	void                        **region_context);
-
-#define ACPI_REGION_ACTIVATE    0
-#define ACPI_REGION_DEACTIVATE  1
-
-typedef
-acpi_status (*acpi_walk_callback) (
-	acpi_handle                 obj_handle,
-	u32                         nesting_level,
-	void                        *context,
-	void                        **return_value);
-
-
-/* Interrupt handler return values */
-
-#define INTERRUPT_NOT_HANDLED           0x00
-#define INTERRUPT_HANDLED               0x01
-
-
-/* Structure and flags for Acpi_get_device_info */
-
-#define ACPI_VALID_HID                  0x1
-#define ACPI_VALID_UID                  0x2
-#define ACPI_VALID_ADR                  0x4
-#define ACPI_VALID_STA                  0x8
-
-
-#define ACPI_COMMON_OBJ_INFO \
-	acpi_object_type            type;           /* ACPI object type */ \
-	acpi_name                   name            /* ACPI object Name */
-
-
-typedef struct
-{
-	ACPI_COMMON_OBJ_INFO;
-} acpi_obj_info_header;
-
-
-typedef struct
-{
-	ACPI_COMMON_OBJ_INFO;
-
-	u32                         valid;              /*  Are the next bits legit? */
-	NATIVE_CHAR                 hardware_id[9];     /*  _HID value if any */
-	NATIVE_CHAR                 unique_id[9];       /*  _UID value if any */
-	acpi_integer                address;            /*  _ADR value if any */
-	u32                         current_status;     /*  _STA value */
-} acpi_device_info;
-
-
-/* Context structs for address space handlers */
-
-typedef struct
-{
-	u16                         segment;
-	u16                         bus;
-	u16                         device;
-	u16                         function;
-} acpi_pci_id;
-
-
-typedef struct
-{
-	ACPI_PHYSICAL_ADDRESS       mapped_physical_address;
-	u8                          *mapped_logical_address;
-	u32                         mapped_length;
-} acpi_mem_space_context;
-
-
-/* Sleep states */
-
-#define ACPI_NUM_SLEEP_STATES           7
-
-
-/*
- * Definitions for Resource Attributes
- */
-
-/*
- *  Memory Attributes
- */
-#define READ_ONLY_MEMORY                (u8) 0x00
-#define READ_WRITE_MEMORY               (u8) 0x01
-
-#define NON_CACHEABLE_MEMORY            (u8) 0x00
-#define CACHABLE_MEMORY                 (u8) 0x01
-#define WRITE_COMBINING_MEMORY          (u8) 0x02
-#define PREFETCHABLE_MEMORY             (u8) 0x03
-
-/*
- *  IO Attributes
- *  The ISA IO ranges are:     n000-n0FFh,  n400-n4_fFh, n800-n8_fFh, n_c00-n_cFFh.
- *  The non-ISA IO ranges are: n100-n3_fFh, n500-n7_fFh, n900-n_bFFh, n_cD0-n_fFFh.
- */
-#define NON_ISA_ONLY_RANGES             (u8) 0x01
-#define ISA_ONLY_RANGES                 (u8) 0x02
-#define ENTIRE_RANGE                    (NON_ISA_ONLY_RANGES | ISA_ONLY_RANGES)
-
-/*
- *  IO Port Descriptor Decode
- */
-#define DECODE_10                       (u8) 0x00    /* 10-bit IO address decode */
-#define DECODE_16                       (u8) 0x01    /* 16-bit IO address decode */
-
-/*
- *  IRQ Attributes
- */
-#define EDGE_SENSITIVE                  (u8) 0x00
-#define LEVEL_SENSITIVE                 (u8) 0x01
-
-#define ACTIVE_HIGH                     (u8) 0x00
-#define ACTIVE_LOW                      (u8) 0x01
-
-#define EXCLUSIVE                       (u8) 0x00
-#define SHARED                          (u8) 0x01
-
-/*
- *  DMA Attributes
- */
-#define COMPATIBILITY                   (u8) 0x00
-#define TYPE_A                          (u8) 0x01
-#define TYPE_B                          (u8) 0x02
-#define TYPE_F                          (u8) 0x03
-
-#define NOT_BUS_MASTER                  (u8) 0x00
-#define BUS_MASTER                      (u8) 0x01
-
-#define TRANSFER_8                      (u8) 0x00
-#define TRANSFER_8_16                   (u8) 0x01
-#define TRANSFER_16                     (u8) 0x02
-
-/*
- * Start Dependent Functions Priority definitions
- */
-#define GOOD_CONFIGURATION              (u8) 0x00
-#define ACCEPTABLE_CONFIGURATION        (u8) 0x01
-#define SUB_OPTIMAL_CONFIGURATION       (u8) 0x02
-
-/*
- *  16, 32 and 64-bit Address Descriptor resource types
- */
-#define MEMORY_RANGE                    (u8) 0x00
-#define IO_RANGE                        (u8) 0x01
-#define BUS_NUMBER_RANGE                (u8) 0x02
-
-#define ADDRESS_NOT_FIXED               (u8) 0x00
-#define ADDRESS_FIXED                   (u8) 0x01
-
-#define POS_DECODE                      (u8) 0x00
-#define SUB_DECODE                      (u8) 0x01
-
-#define PRODUCER                        (u8) 0x00
-#define CONSUMER                        (u8) 0x01
-
-
-/*
- *  Structures used to describe device resources
- */
-typedef struct
-{
-	u32                         edge_level;
-	u32                         active_high_low;
-	u32                         shared_exclusive;
-	u32                         number_of_interrupts;
-	u32                         interrupts[1];
-
-} acpi_resource_irq;
-
-typedef struct
-{
-	u32                         type;
-	u32                         bus_master;
-	u32                         transfer;
-	u32                         number_of_channels;
-	u32                         channels[1];
-
-} acpi_resource_dma;
-
-typedef struct
-{
-	u32                         compatibility_priority;
-	u32                         performance_robustness;
-
-} acpi_resource_start_dpf;
-
-/*
- * END_DEPENDENT_FUNCTIONS_RESOURCE struct is not
- *  needed because it has no fields
- */
-
-typedef struct
-{
-	u32                         io_decode;
-	u32                         min_base_address;
-	u32                         max_base_address;
-	u32                         alignment;
-	u32                         range_length;
-
-} acpi_resource_io;
-
-typedef struct
-{
-	u32                         base_address;
-	u32                         range_length;
-
-} acpi_resource_fixed_io;
-
-typedef struct
-{
-	u32                         length;
-	u8                          reserved[1];
-
-} acpi_resource_vendor;
-
-typedef struct
-{
-	u32                         read_write_attribute;
-	u32                         min_base_address;
-	u32                         max_base_address;
-	u32                         alignment;
-	u32                         range_length;
-
-} acpi_resource_mem24;
-
-typedef struct
-{
-	u32                         read_write_attribute;
-	u32                         min_base_address;
-	u32                         max_base_address;
-	u32                         alignment;
-	u32                         range_length;
-
-} acpi_resource_mem32;
-
-typedef struct
-{
-	u32                         read_write_attribute;
-	u32                         range_base_address;
-	u32                         range_length;
-
-} acpi_resource_fixed_mem32;
-
-typedef struct
-{
-	u16                         cache_attribute;
-	u16                         read_write_attribute;
-
-} acpi_memory_attribute;
-
-typedef struct
-{
-	u16                         range_attribute;
-	u16                         reserved;
-
-} acpi_io_attribute;
-
-typedef struct
-{
-	u16                         reserved1;
-	u16                         reserved2;
-
-} acpi_bus_attribute;
-
-typedef union
-{
-	acpi_memory_attribute       memory;
-	acpi_io_attribute           io;
-	acpi_bus_attribute          bus;
-
-} acpi_resource_attribute;
-
-typedef struct
-{
-	u32                         index;
-	u32                         string_length;
-	NATIVE_CHAR                 *string_ptr;
-
-} acpi_resource_source;
-
-typedef struct
-{
-	u32                         resource_type;
-	u32                         producer_consumer;
-	u32                         decode;
-	u32                         min_address_fixed;
-	u32                         max_address_fixed;
-	acpi_resource_attribute     attribute;
-	u32                         granularity;
-	u32                         min_address_range;
-	u32                         max_address_range;
-	u32                         address_translation_offset;
-	u32                         address_length;
-	acpi_resource_source        resource_source;
-
-} acpi_resource_address16;
-
-typedef struct
-{
-	u32                         resource_type;
-	u32                         producer_consumer;
-	u32                         decode;
-	u32                         min_address_fixed;
-	u32                         max_address_fixed;
-	acpi_resource_attribute     attribute;
-	u32                         granularity;
-	u32                         min_address_range;
-	u32                         max_address_range;
-	u32                         address_translation_offset;
-	u32                         address_length;
-	acpi_resource_source        resource_source;
-
-} acpi_resource_address32;
-
-typedef struct
-{
-	u32                         resource_type;
-	u32                         producer_consumer;
-	u32                         decode;
-	u32                         min_address_fixed;
-	u32                         max_address_fixed;
-	acpi_resource_attribute     attribute;
-	u64                         granularity;
-	u64                         min_address_range;
-	u64                         max_address_range;
-	u64                         address_translation_offset;
-	u64                         address_length;
-	acpi_resource_source        resource_source;
-
-} acpi_resource_address64;
-
-typedef struct
-{
-	u32                         producer_consumer;
-	u32                         edge_level;
-	u32                         active_high_low;
-	u32                         shared_exclusive;
-	u32                         number_of_interrupts;
-	acpi_resource_source        resource_source;
-	u32                         interrupts[1];
-
-} acpi_resource_ext_irq;
-
-
-/* ACPI_RESOURCE_TYPEs */
-
-#define ACPI_RSTYPE_IRQ                 0
-#define ACPI_RSTYPE_DMA                 1
-#define ACPI_RSTYPE_START_DPF           2
-#define ACPI_RSTYPE_END_DPF             3
-#define ACPI_RSTYPE_IO                  4
-#define ACPI_RSTYPE_FIXED_IO            5
-#define ACPI_RSTYPE_VENDOR              6
-#define ACPI_RSTYPE_END_TAG             7
-#define ACPI_RSTYPE_MEM24               8
-#define ACPI_RSTYPE_MEM32               9
-#define ACPI_RSTYPE_FIXED_MEM32         10
-#define ACPI_RSTYPE_ADDRESS16           11
-#define ACPI_RSTYPE_ADDRESS32           12
-#define ACPI_RSTYPE_ADDRESS64           13
-#define ACPI_RSTYPE_EXT_IRQ             14
-
-typedef u32                     acpi_resource_type;
-
-typedef union
-{
-	acpi_resource_irq           irq;
-	acpi_resource_dma           dma;
-	acpi_resource_start_dpf     start_dpf;
-	acpi_resource_io            io;
-	acpi_resource_fixed_io      fixed_io;
-	acpi_resource_vendor        vendor_specific;
-	acpi_resource_mem24         memory24;
-	acpi_resource_mem32         memory32;
-	acpi_resource_fixed_mem32   fixed_memory32;
-	acpi_resource_address16     address16;
-	acpi_resource_address32     address32;
-	acpi_resource_address64     address64;
-	acpi_resource_ext_irq       extended_irq;
-
-} acpi_resource_data;
-
-typedef struct acpi_resource
-{
-	acpi_resource_type          id;
-	u32                         length;
-	acpi_resource_data          data;
-
-} acpi_resource;
-
-#define ACPI_RESOURCE_LENGTH            12
-#define ACPI_RESOURCE_LENGTH_NO_DATA    8       /* Id + Length fields */
-
-#define SIZEOF_RESOURCE(type)   (ACPI_RESOURCE_LENGTH_NO_DATA + sizeof (type))
-
-#define NEXT_RESOURCE(res)      (acpi_resource *)((u8 *) res + res->length)
-
-
-/*
- * END: Definitions for Resource Attributes
- */
-
-
-typedef struct pci_routing_table
-{
-	u32                         length;
-	u32                         pin;
-	acpi_integer                address;        /* here for 64-bit alignment */
-	u32                         source_index;
-	NATIVE_CHAR                 source[4];      /* pad to 64 bits so sizeof() works in all cases */
-
-} pci_routing_table;
-
-
-/*
- * END: Definitions for PCI Routing tables
- */
-
-#endif /* __ACTYPES_H__ */
diff -urNp linux-5400/drivers/acpi/include/acutils.h linux-5410/drivers/acpi/include/acutils.h
--- linux-5400/drivers/acpi/include/acutils.h
+++ linux-5410/drivers/acpi/include/acutils.h
@@ -1,662 +0,0 @@
-/******************************************************************************
- *
- * Name: acutils.h -- prototypes for the common (subsystem-wide) procedures
- *       $Revision: 117 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _ACUTILS_H
-#define _ACUTILS_H
-
-
-typedef
-acpi_status (*ACPI_PKG_CALLBACK) (
-	u8                      object_type,
-	acpi_operand_object     *source_object,
-	acpi_generic_state      *state,
-	void                    *context);
-
-
-acpi_status
-acpi_ut_walk_package_tree (
-	acpi_operand_object     *source_object,
-	void                    *target_object,
-	ACPI_PKG_CALLBACK       walk_callback,
-	void                    *context);
-
-
-typedef struct acpi_pkg_info
-{
-	u8                      *free_space;
-	u32                     length;
-	u32                     object_space;
-	u32                     num_packages;
-} acpi_pkg_info;
-
-#define REF_INCREMENT       (u16) 0
-#define REF_DECREMENT       (u16) 1
-#define REF_FORCE_DELETE    (u16) 2
-
-/* Acpi_ut_dump_buffer */
-
-#define DB_BYTE_DISPLAY     1
-#define DB_WORD_DISPLAY     2
-#define DB_DWORD_DISPLAY    4
-#define DB_QWORD_DISPLAY    8
-
-
-/* Global initialization interfaces */
-
-void
-acpi_ut_init_globals (
-	void);
-
-void
-acpi_ut_terminate (
-	void);
-
-
-/*
- * Ut_init - miscellaneous initialization and shutdown
- */
-
-acpi_status
-acpi_ut_hardware_initialize (
-	void);
-
-acpi_status
-acpi_ut_subsystem_shutdown (
-	void);
-
-acpi_status
-acpi_ut_validate_fadt (
-	void);
-
-/*
- * Ut_global - Global data structures and procedures
- */
-
-#ifdef ACPI_DEBUG
-
-NATIVE_CHAR *
-acpi_ut_get_mutex_name (
-	u32                     mutex_id);
-
-NATIVE_CHAR *
-acpi_ut_get_type_name (
-	u32                     type);
-
-NATIVE_CHAR *
-acpi_ut_get_region_name (
-	u8                      space_id);
-
-#endif
-
-
-u8
-acpi_ut_hex_to_ascii_char (
-	acpi_integer            integer,
-	u32                     position);
-
-u8
-acpi_ut_valid_object_type (
-	u32                     type);
-
-acpi_owner_id
-acpi_ut_allocate_owner_id (
-	u32                     id_type);
-
-
-/*
- * Ut_clib - Local implementations of C library functions
- */
-
-#ifndef ACPI_USE_SYSTEM_CLIBRARY
-
-u32
-acpi_ut_strlen (
-	const NATIVE_CHAR       *string);
-
-NATIVE_CHAR *
-acpi_ut_strcpy (
-	NATIVE_CHAR             *dst_string,
-	const NATIVE_CHAR       *src_string);
-
-NATIVE_CHAR *
-acpi_ut_strncpy (
-	NATIVE_CHAR             *dst_string,
-	const NATIVE_CHAR       *src_string,
-	NATIVE_UINT             count);
-
-u32
-acpi_ut_strncmp (
-	const NATIVE_CHAR       *string1,
-	const NATIVE_CHAR       *string2,
-	NATIVE_UINT             count);
-
-u32
-acpi_ut_strcmp (
-	const NATIVE_CHAR       *string1,
-	const NATIVE_CHAR       *string2);
-
-NATIVE_CHAR *
-acpi_ut_strcat (
-	NATIVE_CHAR             *dst_string,
-	const NATIVE_CHAR       *src_string);
-
-NATIVE_CHAR *
-acpi_ut_strncat (
-	NATIVE_CHAR             *dst_string,
-	const NATIVE_CHAR       *src_string,
-	NATIVE_UINT             count);
-
-u32
-acpi_ut_strtoul (
-	const NATIVE_CHAR       *string,
-	NATIVE_CHAR             **terminator,
-	u32                     base);
-
-NATIVE_CHAR *
-acpi_ut_strstr (
-	NATIVE_CHAR             *string1,
-	NATIVE_CHAR             *string2);
-
-void *
-acpi_ut_memcpy (
-	void                    *dest,
-	const void              *src,
-	NATIVE_UINT             count);
-
-void *
-acpi_ut_memset (
-	void                    *dest,
-	NATIVE_UINT             value,
-	NATIVE_UINT             count);
-
-u32
-acpi_ut_to_upper (
-	u32                     c);
-
-u32
-acpi_ut_to_lower (
-	u32                     c);
-
-#endif /* ACPI_USE_SYSTEM_CLIBRARY */
-
-/*
- * Ut_copy - Object construction and conversion interfaces
- */
-
-acpi_status
-acpi_ut_build_simple_object(
-	acpi_operand_object     *obj,
-	acpi_object             *user_obj,
-	u8                      *data_space,
-	u32                     *buffer_space_used);
-
-acpi_status
-acpi_ut_build_package_object (
-	acpi_operand_object     *obj,
-	u8                      *buffer,
-	u32                     *space_used);
-
-acpi_status
-acpi_ut_copy_iobject_to_eobject (
-	acpi_operand_object     *obj,
-	acpi_buffer             *ret_buffer);
-
-acpi_status
-acpi_ut_copy_esimple_to_isimple(
-	acpi_object             *user_obj,
-	acpi_operand_object     **return_obj);
-
-acpi_status
-acpi_ut_copy_eobject_to_iobject (
-	acpi_object             *obj,
-	acpi_operand_object     **internal_obj);
-
-acpi_status
-acpi_ut_copy_isimple_to_isimple (
-	acpi_operand_object     *source_obj,
-	acpi_operand_object     *dest_obj);
-
-acpi_status
-acpi_ut_copy_ipackage_to_ipackage (
-	acpi_operand_object     *source_obj,
-	acpi_operand_object     *dest_obj,
-	acpi_walk_state         *walk_state);
-
-
-/*
- * Ut_create - Object creation
- */
-
-acpi_status
-acpi_ut_update_object_reference (
-	acpi_operand_object     *object,
-	u16                     action);
-
-
-/*
- * Ut_debug - Debug interfaces
- */
-
-void
-acpi_ut_init_stack_ptr_trace (
-	void);
-
-void
-acpi_ut_track_stack_ptr (
-	void);
-
-void
-acpi_ut_trace (
-	u32                     line_number,
-	acpi_debug_print_info   *dbg_info);
-
-void
-acpi_ut_trace_ptr (
-	u32                     line_number,
-	acpi_debug_print_info   *dbg_info,
-	void                    *pointer);
-
-void
-acpi_ut_trace_u32 (
-	u32                     line_number,
-	acpi_debug_print_info   *dbg_info,
-	u32                     integer);
-
-void
-acpi_ut_trace_str (
-	u32                     line_number,
-	acpi_debug_print_info   *dbg_info,
-	NATIVE_CHAR             *string);
-
-void
-acpi_ut_exit (
-	u32                     line_number,
-	acpi_debug_print_info   *dbg_info);
-
-void
-acpi_ut_status_exit (
-	u32                     line_number,
-	acpi_debug_print_info   *dbg_info,
-	acpi_status             status);
-
-void
-acpi_ut_value_exit (
-	u32                     line_number,
-	acpi_debug_print_info   *dbg_info,
-	acpi_integer            value);
-
-void
-acpi_ut_ptr_exit (
-	u32                     line_number,
-	acpi_debug_print_info   *dbg_info,
-	u8                      *ptr);
-
-void
-acpi_ut_report_info (
-	NATIVE_CHAR             *module_name,
-	u32                     line_number,
-	u32                     component_id);
-
-void
-acpi_ut_report_error (
-	NATIVE_CHAR             *module_name,
-	u32                     line_number,
-	u32                     component_id);
-
-void
-acpi_ut_report_warning (
-	NATIVE_CHAR             *module_name,
-	u32                     line_number,
-	u32                     component_id);
-
-void
-acpi_ut_dump_buffer (
-	u8                      *buffer,
-	u32                     count,
-	u32                     display,
-	u32                     component_id);
-
-void
-acpi_ut_debug_print (
-	u32                     requested_debug_level,
-	u32                     line_number,
-	acpi_debug_print_info   *dbg_info,
-	char                    *format,
-	...) ACPI_PRINTF_LIKE_FUNC;
-
-void
-acpi_ut_debug_print_raw (
-	u32                     requested_debug_level,
-	u32                     line_number,
-	acpi_debug_print_info   *dbg_info,
-	char                    *format,
-	...) ACPI_PRINTF_LIKE_FUNC;
-
-
-/*
- * Ut_delete - Object deletion
- */
-
-void
-acpi_ut_delete_internal_obj (
-	acpi_operand_object     *object);
-
-void
-acpi_ut_delete_internal_package_object (
-	acpi_operand_object     *object);
-
-void
-acpi_ut_delete_internal_simple_object (
-	acpi_operand_object     *object);
-
-acpi_status
-acpi_ut_delete_internal_object_list (
-	acpi_operand_object     **obj_list);
-
-
-/*
- * Ut_eval - object evaluation
- */
-
-/* Method name strings */
-
-#define METHOD_NAME__HID        "_HID"
-#define METHOD_NAME__UID        "_UID"
-#define METHOD_NAME__ADR        "_ADR"
-#define METHOD_NAME__STA        "_STA"
-#define METHOD_NAME__REG        "_REG"
-#define METHOD_NAME__SEG        "_SEG"
-#define METHOD_NAME__BBN        "_BBN"
-#define METHOD_NAME__PRT        "_PRT"
-
-
-acpi_status
-acpi_ut_evaluate_numeric_object (
-	NATIVE_CHAR             *object_name,
-	acpi_namespace_node     *device_node,
-	acpi_integer            *address);
-
-acpi_status
-acpi_ut_execute_HID (
-	acpi_namespace_node     *device_node,
-	acpi_device_id          *hid);
-
-acpi_status
-acpi_ut_execute_STA (
-	acpi_namespace_node     *device_node,
-	u32                     *status_flags);
-
-acpi_status
-acpi_ut_execute_UID (
-	acpi_namespace_node     *device_node,
-	acpi_device_id          *uid);
-
-
-/*
- * Ut_mutex - mutual exclusion interfaces
- */
-
-acpi_status
-acpi_ut_mutex_initialize (
-	void);
-
-void
-acpi_ut_mutex_terminate (
-	void);
-
-acpi_status
-acpi_ut_create_mutex (
-	ACPI_MUTEX_HANDLE       mutex_id);
-
-acpi_status
-acpi_ut_delete_mutex (
-	ACPI_MUTEX_HANDLE       mutex_id);
-
-acpi_status
-acpi_ut_acquire_mutex (
-	ACPI_MUTEX_HANDLE       mutex_id);
-
-acpi_status
-acpi_ut_release_mutex (
-	ACPI_MUTEX_HANDLE       mutex_id);
-
-
-/*
- * Ut_object - internal object create/delete/cache routines
- */
-
-acpi_operand_object  *
-acpi_ut_create_internal_object_dbg (
-	NATIVE_CHAR             *module_name,
-	u32                     line_number,
-	u32                     component_id,
-	acpi_object_type8       type);
-
-void *
-acpi_ut_allocate_object_desc_dbg (
-	NATIVE_CHAR             *module_name,
-	u32                     line_number,
-	u32                     component_id);
-
-#define acpi_ut_create_internal_object(t) acpi_ut_create_internal_object_dbg (_THIS_MODULE,__LINE__,_COMPONENT,t)
-#define acpi_ut_allocate_object_desc()  acpi_ut_allocate_object_desc_dbg (_THIS_MODULE,__LINE__,_COMPONENT)
-
-void
-acpi_ut_delete_object_desc (
-	acpi_operand_object     *object);
-
-u8
-acpi_ut_valid_internal_object (
-	void                    *object);
-
-
-/*
- * Ut_ref_cnt - Object reference count management
- */
-
-void
-acpi_ut_add_reference (
-	acpi_operand_object     *object);
-
-void
-acpi_ut_remove_reference (
-	acpi_operand_object     *object);
-
-/*
- * Ut_size - Object size routines
- */
-
-acpi_status
-acpi_ut_get_simple_object_size (
-	acpi_operand_object     *obj,
-	u32                     *obj_length);
-
-acpi_status
-acpi_ut_get_package_object_size (
-	acpi_operand_object     *obj,
-	u32                     *obj_length);
-
-acpi_status
-acpi_ut_get_object_size(
-	acpi_operand_object     *obj,
-	u32                     *obj_length);
-
-
-/*
- * Ut_state - Generic state creation/cache routines
- */
-
-void
-acpi_ut_push_generic_state (
-	acpi_generic_state      **list_head,
-	acpi_generic_state      *state);
-
-acpi_generic_state *
-acpi_ut_pop_generic_state (
-	acpi_generic_state      **list_head);
-
-
-acpi_generic_state *
-acpi_ut_create_generic_state (
-	void);
-
-acpi_generic_state *
-acpi_ut_create_update_state (
-	acpi_operand_object     *object,
-	u16                     action);
-
-acpi_generic_state *
-acpi_ut_create_pkg_state (
-	void                    *internal_object,
-	void                    *external_object,
-	u16                     index);
-
-acpi_status
-acpi_ut_create_update_state_and_push (
-	acpi_operand_object     *object,
-	u16                     action,
-	acpi_generic_state      **state_list);
-
-acpi_status
-acpi_ut_create_pkg_state_and_push (
-	void                    *internal_object,
-	void                    *external_object,
-	u16                     index,
-	acpi_generic_state      **state_list);
-
-acpi_generic_state *
-acpi_ut_create_control_state (
-	void);
-
-void
-acpi_ut_delete_generic_state (
-	acpi_generic_state      *state);
-
-void
-acpi_ut_delete_generic_state_cache (
-	void);
-
-void
-acpi_ut_delete_object_cache (
-	void);
-
-/*
- * utmisc
- */
-
-acpi_status
-acpi_ut_divide (
-	acpi_integer            *in_dividend,
-	acpi_integer            *in_divisor,
-	acpi_integer            *out_quotient,
-	acpi_integer            *out_remainder);
-
-acpi_status
-acpi_ut_short_divide (
-	acpi_integer            *in_dividend,
-	u32                     divisor,
-	acpi_integer            *out_quotient,
-	u32                     *out_remainder);
-
-u8
-acpi_ut_valid_acpi_name (
-	u32                     name);
-
-u8
-acpi_ut_valid_acpi_character (
-	NATIVE_CHAR             character);
-
-NATIVE_CHAR *
-acpi_ut_strupr (
-	NATIVE_CHAR             *src_string);
-
-acpi_status
-acpi_ut_resolve_package_references (
-	acpi_operand_object     *obj_desc);
-
-
-#ifdef ACPI_DEBUG
-void
-acpi_ut_display_init_pathname (
-	acpi_handle             obj_handle,
-	char                    *path);
-
-#endif
-
-
-/*
- * Utalloc - memory allocation and object caching
- */
-
-void *
-acpi_ut_acquire_from_cache (
-	u32                     list_id);
-
-void
-acpi_ut_release_to_cache (
-	u32                     list_id,
-	void                    *object);
-
-void
-acpi_ut_delete_generic_cache (
-	u32                     list_id);
-
-
-/* Debug Memory allocation functions */
-
-void *
-acpi_ut_allocate (
-	u32                     size,
-	u32                     component,
-	NATIVE_CHAR             *module,
-	u32                     line);
-
-void *
-acpi_ut_callocate (
-	u32                     size,
-	u32                     component,
-	NATIVE_CHAR             *module,
-	u32                     line);
-
-void
-acpi_ut_free (
-	void                    *address,
-	u32                     component,
-	NATIVE_CHAR             *module,
-	u32                     line);
-
-#ifdef ACPI_DBG_TRACK_ALLOCATIONS
-void
-acpi_ut_dump_allocation_info (
-	void);
-
-void
-acpi_ut_dump_allocations (
-	u32                     component,
-	NATIVE_CHAR             *module);
-#endif
-
-
-#endif /* _ACUTILS_H */
diff -urNp linux-5400/drivers/acpi/include/amlcode.h linux-5410/drivers/acpi/include/amlcode.h
--- linux-5400/drivers/acpi/include/amlcode.h
+++ linux-5410/drivers/acpi/include/amlcode.h
@@ -1,459 +0,0 @@
-/******************************************************************************
- *
- * Name: amlcode.h - Definitions for AML, as included in "definition blocks"
- *                   Declarations and definitions contained herein are derived
- *                   directly from the ACPI specification.
- *       $Revision: 58 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __AMLCODE_H__
-#define __AMLCODE_H__
-
-
-/* primary opcodes */
-
-#define AML_NULL_CHAR               (u16) 0x00
-
-#define AML_ZERO_OP                 (u16) 0x00
-#define AML_ONE_OP                  (u16) 0x01
-#define AML_UNASSIGNED              (u16) 0x02
-#define AML_ALIAS_OP                (u16) 0x06
-#define AML_NAME_OP                 (u16) 0x08
-#define AML_BYTE_OP                 (u16) 0x0a
-#define AML_WORD_OP                 (u16) 0x0b
-#define AML_DWORD_OP                (u16) 0x0c
-#define AML_STRING_OP               (u16) 0x0d
-#define AML_QWORD_OP                (u16) 0x0e     /* ACPI 2.0 */
-#define AML_SCOPE_OP                (u16) 0x10
-#define AML_BUFFER_OP               (u16) 0x11
-#define AML_PACKAGE_OP              (u16) 0x12
-#define AML_VAR_PACKAGE_OP          (u16) 0x13     /* ACPI 2.0 */
-#define AML_METHOD_OP               (u16) 0x14
-#define AML_DUAL_NAME_PREFIX        (u16) 0x2e
-#define AML_MULTI_NAME_PREFIX_OP    (u16) 0x2f
-#define AML_NAME_CHAR_SUBSEQ        (u16) 0x30
-#define AML_NAME_CHAR_FIRST         (u16) 0x41
-#define AML_OP_PREFIX               (u16) 0x5b
-#define AML_ROOT_PREFIX             (u16) 0x5c
-#define AML_PARENT_PREFIX           (u16) 0x5e
-#define AML_LOCAL_OP                (u16) 0x60
-#define AML_LOCAL0                  (u16) 0x60
-#define AML_LOCAL1                  (u16) 0x61
-#define AML_LOCAL2                  (u16) 0x62
-#define AML_LOCAL3                  (u16) 0x63
-#define AML_LOCAL4                  (u16) 0x64
-#define AML_LOCAL5                  (u16) 0x65
-#define AML_LOCAL6                  (u16) 0x66
-#define AML_LOCAL7                  (u16) 0x67
-#define AML_ARG_OP                  (u16) 0x68
-#define AML_ARG0                    (u16) 0x68
-#define AML_ARG1                    (u16) 0x69
-#define AML_ARG2                    (u16) 0x6a
-#define AML_ARG3                    (u16) 0x6b
-#define AML_ARG4                    (u16) 0x6c
-#define AML_ARG5                    (u16) 0x6d
-#define AML_ARG6                    (u16) 0x6e
-#define AML_STORE_OP                (u16) 0x70
-#define AML_REF_OF_OP               (u16) 0x71
-#define AML_ADD_OP                  (u16) 0x72
-#define AML_CONCAT_OP               (u16) 0x73
-#define AML_SUBTRACT_OP             (u16) 0x74
-#define AML_INCREMENT_OP            (u16) 0x75
-#define AML_DECREMENT_OP            (u16) 0x76
-#define AML_MULTIPLY_OP             (u16) 0x77
-#define AML_DIVIDE_OP               (u16) 0x78
-#define AML_SHIFT_LEFT_OP           (u16) 0x79
-#define AML_SHIFT_RIGHT_OP          (u16) 0x7a
-#define AML_BIT_AND_OP              (u16) 0x7b
-#define AML_BIT_NAND_OP             (u16) 0x7c
-#define AML_BIT_OR_OP               (u16) 0x7d
-#define AML_BIT_NOR_OP              (u16) 0x7e
-#define AML_BIT_XOR_OP              (u16) 0x7f
-#define AML_BIT_NOT_OP              (u16) 0x80
-#define AML_FIND_SET_LEFT_BIT_OP    (u16) 0x81
-#define AML_FIND_SET_RIGHT_BIT_OP   (u16) 0x82
-#define AML_DEREF_OF_OP             (u16) 0x83
-#define AML_CONCAT_RES_OP           (u16) 0x84     /* ACPI 2.0 */
-#define AML_MOD_OP                  (u16) 0x85     /* ACPI 2.0 */
-#define AML_NOTIFY_OP               (u16) 0x86
-#define AML_SIZE_OF_OP              (u16) 0x87
-#define AML_INDEX_OP                (u16) 0x88
-#define AML_MATCH_OP                (u16) 0x89
-#define AML_CREATE_DWORD_FIELD_OP   (u16) 0x8a
-#define AML_CREATE_WORD_FIELD_OP    (u16) 0x8b
-#define AML_CREATE_BYTE_FIELD_OP    (u16) 0x8c
-#define AML_CREATE_BIT_FIELD_OP     (u16) 0x8d
-#define AML_TYPE_OP                 (u16) 0x8e
-#define AML_CREATE_QWORD_FIELD_OP   (u16) 0x8f     /* ACPI 2.0 */
-#define AML_LAND_OP                 (u16) 0x90
-#define AML_LOR_OP                  (u16) 0x91
-#define AML_LNOT_OP                 (u16) 0x92
-#define AML_LEQUAL_OP               (u16) 0x93
-#define AML_LGREATER_OP             (u16) 0x94
-#define AML_LLESS_OP                (u16) 0x95
-#define AML_TO_BUFFER_OP            (u16) 0x96     /* ACPI 2.0 */
-#define AML_TO_DECSTRING_OP         (u16) 0x97     /* ACPI 2.0 */
-#define AML_TO_HEXSTRING_OP         (u16) 0x98     /* ACPI 2.0 */
-#define AML_TO_INTEGER_OP           (u16) 0x99     /* ACPI 2.0 */
-#define AML_TO_STRING_OP            (u16) 0x9c     /* ACPI 2.0 */
-#define AML_COPY_OP                 (u16) 0x9d     /* ACPI 2.0 */
-#define AML_MID_OP                  (u16) 0x9e     /* ACPI 2.0 */
-#define AML_CONTINUE_OP             (u16) 0x9f     /* ACPI 2.0 */
-#define AML_IF_OP                   (u16) 0xa0
-#define AML_ELSE_OP                 (u16) 0xa1
-#define AML_WHILE_OP                (u16) 0xa2
-#define AML_NOOP_OP                 (u16) 0xa3
-#define AML_RETURN_OP               (u16) 0xa4
-#define AML_BREAK_OP                (u16) 0xa5
-#define AML_BREAK_POINT_OP          (u16) 0xcc
-#define AML_ONES_OP                 (u16) 0xff
-
-/* prefixed opcodes */
-
-#define AML_EXTOP                   (u16) 0x005b
-
-
-#define AML_MUTEX_OP                (u16) 0x5b01
-#define AML_EVENT_OP                (u16) 0x5b02
-#define AML_SHIFT_RIGHT_BIT_OP      (u16) 0x5b10
-#define AML_SHIFT_LEFT_BIT_OP       (u16) 0x5b11
-#define AML_COND_REF_OF_OP          (u16) 0x5b12
-#define AML_CREATE_FIELD_OP         (u16) 0x5b13
-#define AML_LOAD_TABLE_OP           (u16) 0x5b1f     /* ACPI 2.0 */
-#define AML_LOAD_OP                 (u16) 0x5b20
-#define AML_STALL_OP                (u16) 0x5b21
-#define AML_SLEEP_OP                (u16) 0x5b22
-#define AML_ACQUIRE_OP              (u16) 0x5b23
-#define AML_SIGNAL_OP               (u16) 0x5b24
-#define AML_WAIT_OP                 (u16) 0x5b25
-#define AML_RESET_OP                (u16) 0x5b26
-#define AML_RELEASE_OP              (u16) 0x5b27
-#define AML_FROM_BCD_OP             (u16) 0x5b28
-#define AML_TO_BCD_OP               (u16) 0x5b29
-#define AML_UNLOAD_OP               (u16) 0x5b2a
-#define AML_REVISION_OP             (u16) 0x5b30
-#define AML_DEBUG_OP                (u16) 0x5b31
-#define AML_FATAL_OP                (u16) 0x5b32
-#define AML_REGION_OP               (u16) 0x5b80
-#define AML_FIELD_OP                (u16) 0x5b81
-#define AML_DEVICE_OP               (u16) 0x5b82
-#define AML_PROCESSOR_OP            (u16) 0x5b83
-#define AML_POWER_RES_OP            (u16) 0x5b84
-#define AML_THERMAL_ZONE_OP         (u16) 0x5b85
-#define AML_INDEX_FIELD_OP          (u16) 0x5b86
-#define AML_BANK_FIELD_OP           (u16) 0x5b87
-#define AML_DATA_REGION_OP          (u16) 0x5b88     /* ACPI 2.0 */
-
-
-/* Bogus opcodes (they are actually two separate opcodes) */
-
-#define AML_LGREATEREQUAL_OP        (u16) 0x9295
-#define AML_LLESSEQUAL_OP           (u16) 0x9294
-#define AML_LNOTEQUAL_OP            (u16) 0x9293
-
-
-/*
- * Internal opcodes
- * Use only "Unknown" AML opcodes, don't attempt to use
- * any valid ACPI ASCII values (A-Z, 0-9, '-')
- */
-
-#define AML_INT_NAMEPATH_OP         (u16) 0x002d
-#define AML_INT_NAMEDFIELD_OP       (u16) 0x0030
-#define AML_INT_RESERVEDFIELD_OP    (u16) 0x0031
-#define AML_INT_ACCESSFIELD_OP      (u16) 0x0032
-#define AML_INT_BYTELIST_OP         (u16) 0x0033
-#define AML_INT_STATICSTRING_OP     (u16) 0x0034
-#define AML_INT_METHODCALL_OP       (u16) 0x0035
-#define AML_INT_RETURN_VALUE_OP     (u16) 0x0036
-
-
-#define ARG_NONE                    0x0
-
-/*
- * Argument types for the AML Parser
- * Each field in the Arg_types u32 is 5 bits, allowing for a maximum of 6 arguments.
- * There can be up to 31 unique argument types
- */
-
-#define ARGP_BYTEDATA               0x01
-#define ARGP_BYTELIST               0x02
-#define ARGP_CHARLIST               0x03
-#define ARGP_DATAOBJ                0x04
-#define ARGP_DATAOBJLIST            0x05
-#define ARGP_DWORDDATA              0x06
-#define ARGP_FIELDLIST              0x07
-#define ARGP_NAME                   0x08
-#define ARGP_NAMESTRING             0x09
-#define ARGP_OBJLIST                0x0A
-#define ARGP_PKGLENGTH              0x0B
-#define ARGP_SUPERNAME              0x0C
-#define ARGP_TARGET                 0x0D
-#define ARGP_TERMARG                0x0E
-#define ARGP_TERMLIST               0x0F
-#define ARGP_WORDDATA               0x10
-#define ARGP_QWORDDATA              0x11
-#define ARGP_SIMPLENAME             0x12
-
-/*
- * Resolved argument types for the AML Interpreter
- * Each field in the Arg_types u32 is 5 bits, allowing for a maximum of 6 arguments.
- * There can be up to 31 unique argument types (0 is end-of-arg-list indicator)
- */
-
-/* "Standard" ACPI types are 1-15 (0x0F) */
-
-#define ARGI_INTEGER                ACPI_TYPE_INTEGER       /* 1 */
-#define ARGI_STRING                 ACPI_TYPE_STRING        /* 2 */
-#define ARGI_BUFFER                 ACPI_TYPE_BUFFER        /* 3 */
-#define ARGI_PACKAGE                ACPI_TYPE_PACKAGE       /* 4 */
-#define ARGI_EVENT                  ACPI_TYPE_EVENT
-#define ARGI_MUTEX                  ACPI_TYPE_MUTEX
-#define ARGI_REGION                 ACPI_TYPE_REGION
-#define ARGI_DDBHANDLE              ACPI_TYPE_DDB_HANDLE
-
-/* Custom types are 0x10 through 0x1F */
-
-#define ARGI_IF                     0x10
-#define ARGI_ANYOBJECT              0x11
-#define ARGI_ANYTYPE                0x12
-#define ARGI_COMPUTEDATA            0x13     /* Buffer, String, or Integer */
-#define ARGI_DATAOBJECT             0x14     /* Buffer, String, package or reference to a Node - Used only by Size_of operator*/
-#define ARGI_COMPLEXOBJ             0x15     /* Buffer, String, or package (Used by INDEX op only) */
-#define ARGI_INTEGER_REF            0x16
-#define ARGI_OBJECT_REF             0x17
-#define ARGI_DEVICE_REF             0x18
-#define ARGI_REFERENCE              0x19
-#define ARGI_TARGETREF              0x1A     /* Target, subject to implicit conversion */
-#define ARGI_FIXED_TARGET           0x1B     /* Target, no implicit conversion */
-#define ARGI_SIMPLE_TARGET          0x1C     /* Name, Local, Arg -- no implicit conversion */
-#define ARGI_BUFFERSTRING           0x1D
-
-#define ARGI_INVALID_OPCODE         0xFFFFFFFF
-
-
-/*
- * hash offsets
- */
-#define AML_EXTOP_HASH_OFFSET       22
-#define AML_LNOT_HASH_OFFSET        19
-
-
-/*
- * opcode groups and types
- */
-
-#define OPGRP_NAMED                 0x01
-#define OPGRP_FIELD                 0x02
-#define OPGRP_BYTELIST              0x04
-
-
-/*
- * Opcode information
- */
-
-/* Opcode flags */
-
-#define AML_HAS_ARGS                0x0800
-#define AML_HAS_TARGET              0x0400
-#define AML_HAS_RETVAL              0x0200
-#define AML_NSOBJECT                0x0100
-#define AML_NSOPCODE                0x0080
-#define AML_NSNODE                  0x0040
-#define AML_NAMED                   0x0020
-#define AML_DEFER                   0x0010
-#define AML_FIELD                   0x0008
-#define AML_CREATE                  0x0004
-#define AML_MATH                    0x0002
-#define AML_LOGICAL                 0x0001
-
-/* Convenient flag groupings */
-
-#define AML_FLAGS_EXEC_1A_0T_0R     AML_HAS_ARGS                                   /* Monadic1  */
-#define AML_FLAGS_EXEC_1A_0T_1R     AML_HAS_ARGS |                  AML_HAS_RETVAL /* Monadic2  */
-#define AML_FLAGS_EXEC_1A_1T_0R     AML_HAS_ARGS | AML_HAS_TARGET
-#define AML_FLAGS_EXEC_1A_1T_1R     AML_HAS_ARGS | AML_HAS_TARGET | AML_HAS_RETVAL /* Monadic2_r */
-#define AML_FLAGS_EXEC_2A_0T_0R     AML_HAS_ARGS                                   /* Dyadic1   */
-#define AML_FLAGS_EXEC_2A_0T_1R     AML_HAS_ARGS |                  AML_HAS_RETVAL /* Dyadic2   */
-#define AML_FLAGS_EXEC_2A_1T_1R     AML_HAS_ARGS | AML_HAS_TARGET | AML_HAS_RETVAL /* Dyadic2_r  */
-#define AML_FLAGS_EXEC_2A_2T_1R     AML_HAS_ARGS | AML_HAS_TARGET | AML_HAS_RETVAL
-#define AML_FLAGS_EXEC_3A_0T_0R     AML_HAS_ARGS
-#define AML_FLAGS_EXEC_3A_1T_1R     AML_HAS_ARGS | AML_HAS_TARGET | AML_HAS_RETVAL
-#define AML_FLAGS_EXEC_6A_0T_1R     AML_HAS_ARGS |                  AML_HAS_RETVAL
-
-
-/*
- * The opcode Type is used in a dispatch table, do not change
- * without updating the table.
- */
-#define AML_TYPE_EXEC_1A_0T_0R      0x00 /* Monadic1  */
-#define AML_TYPE_EXEC_1A_0T_1R      0x01 /* Monadic2  */
-#define AML_TYPE_EXEC_1A_1T_0R      0x02
-#define AML_TYPE_EXEC_1A_1T_1R      0x03 /* Monadic2_r */
-#define AML_TYPE_EXEC_2A_0T_0R      0x04 /* Dyadic1   */
-#define AML_TYPE_EXEC_2A_0T_1R      0x05 /* Dyadic2   */
-#define AML_TYPE_EXEC_2A_1T_1R      0x06 /* Dyadic2_r  */
-#define AML_TYPE_EXEC_2A_2T_1R      0x07
-#define AML_TYPE_EXEC_3A_0T_0R      0x08
-#define AML_TYPE_EXEC_3A_1T_1R      0x09
-#define AML_TYPE_EXEC_6A_0T_1R      0x0A
-/* End of types used in dispatch table */
-
-#define AML_TYPE_LITERAL            0x0B
-#define AML_TYPE_CONSTANT           0x0C
-#define AML_TYPE_METHOD_ARGUMENT    0x0D
-#define AML_TYPE_LOCAL_VARIABLE     0x0E
-#define AML_TYPE_DATA_TERM          0x0F
-
-/* Generic for an op that returns a value */
-
-#define AML_TYPE_METHOD_CALL        0x10
-
-/* Misc */
-
-#define AML_TYPE_CREATE_FIELD       0x11
-#define AML_TYPE_CONTROL            0x12
-#define AML_TYPE_NAMED_NO_OBJ       0x13
-#define AML_TYPE_NAMED_FIELD        0x14
-#define AML_TYPE_NAMED_SIMPLE       0x15
-#define AML_TYPE_NAMED_COMPLEX      0x16
-#define AML_TYPE_RETURN             0x17
-
-#define AML_TYPE_UNDEFINED          0x18
-#define AML_TYPE_BOGUS              0x19
-
-
-/*
- * Opcode classes
- */
-#define AML_CLASS_EXECUTE           0x00
-#define AML_CLASS_CREATE            0x01
-#define AML_CLASS_ARGUMENT          0x02
-#define AML_CLASS_NAMED_OBJECT      0x03
-#define AML_CLASS_CONTROL           0x04
-#define AML_CLASS_ASCII             0x05
-#define AML_CLASS_PREFIX            0x06
-#define AML_CLASS_INTERNAL          0x07
-#define AML_CLASS_RETURN_VALUE      0x08
-#define AML_CLASS_METHOD_CALL       0x09
-#define AML_CLASS_UNKNOWN           0x0A
-
-
-/* Predefined Operation Region Space_iDs */
-
-typedef enum
-{
-	REGION_MEMORY                   = 0,
-	REGION_IO,
-	REGION_PCI_CONFIG,
-	REGION_EC,
-	REGION_SMBUS,
-	REGION_CMOS,
-	REGION_PCI_BAR,
-	REGION_FIXED_HW                 = 0x7F,
-
-} AML_REGION_TYPES;
-
-
-/* Comparison operation codes for Match_op operator */
-
-typedef enum
-{
-	MATCH_MTR                       = 0,
-	MATCH_MEQ                       = 1,
-	MATCH_MLE                       = 2,
-	MATCH_MLT                       = 3,
-	MATCH_MGE                       = 4,
-	MATCH_MGT                       = 5
-
-} AML_MATCH_OPERATOR;
-
-#define MAX_MATCH_OPERATOR          5
-
-
-/* Field Access Types */
-
-#define ACCESS_TYPE_MASK            0x0f
-#define ACCESS_TYPE_SHIFT           0
-
-typedef enum
-{
-	ACCESS_ANY_ACC                  = 0,
-	ACCESS_BYTE_ACC                 = 1,
-	ACCESS_WORD_ACC                 = 2,
-	ACCESS_DWORD_ACC                = 3,
-	ACCESS_QWORD_ACC                = 4,    /* ACPI 2.0 */
-	ACCESS_BLOCK_ACC                = 4,
-	ACCESS_SMBSEND_RECV_ACC         = 5,
-	ACCESS_SMBQUICK_ACC             = 6
-
-} AML_ACCESS_TYPE;
-
-
-/* Field Lock Rules */
-
-#define LOCK_RULE_MASK              0x10
-#define LOCK_RULE_SHIFT             4
-
-typedef enum
-{
-	GLOCK_NEVER_LOCK                = 0,
-	GLOCK_ALWAYS_LOCK               = 1
-
-} AML_LOCK_RULE;
-
-
-/* Field Update Rules */
-
-#define UPDATE_RULE_MASK            0x060
-#define UPDATE_RULE_SHIFT           5
-
-typedef enum
-{
-	UPDATE_PRESERVE                 = 0,
-	UPDATE_WRITE_AS_ONES            = 1,
-	UPDATE_WRITE_AS_ZEROS           = 2
-
-} AML_UPDATE_RULE;
-
-
-/* bit fields in Method_flags byte */
-
-#define METHOD_FLAGS_ARG_COUNT      0x07
-#define METHOD_FLAGS_SERIALIZED     0x08
-#define METHOD_FLAGS_SYNCH_LEVEL    0xF0
-
-
-/* Array sizes.  Used for range checking also */
-
-#define NUM_REGION_TYPES            7
-#define NUM_ACCESS_TYPES            7
-#define NUM_UPDATE_RULES            3
-#define NUM_MATCH_OPS               7
-#define NUM_OPCODES                 256
-#define NUM_FIELD_NAMES             2
-
-
-#define USER_REGION_BEGIN           0x80
-
-
-#endif /* __AMLCODE_H__ */
diff -urNp linux-5400/drivers/acpi/include/platform/acenv.h linux-5410/drivers/acpi/include/platform/acenv.h
--- linux-5400/drivers/acpi/include/platform/acenv.h
+++ linux-5410/drivers/acpi/include/platform/acenv.h
@@ -1,294 +0,0 @@
-/******************************************************************************
- *
- * Name: acenv.h - Generation environment specific items
- *       $Revision: 77 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACENV_H__
-#define __ACENV_H__
-
-
-/*
- * Configuration for ACPI tools and utilities
- */
-
-#ifdef _ACPI_DUMP_APP
-#define ACPI_DEBUG
-#define ACPI_APPLICATION
-#define ENABLE_DEBUGGER
-#define ACPI_USE_SYSTEM_CLIBRARY
-#define PARSER_ONLY
-#endif
-
-#ifdef _ACPI_EXEC_APP
-#undef DEBUGGER_THREADING
-#define DEBUGGER_THREADING      DEBUGGER_SINGLE_THREADED
-#define ACPI_DEBUG
-#define ACPI_APPLICATION
-#define ENABLE_DEBUGGER
-#define ACPI_USE_SYSTEM_CLIBRARY
-#endif
-
-#ifdef _ACPI_ASL_COMPILER
-#define ACPI_DEBUG
-#define ACPI_APPLICATION
-#define ENABLE_DEBUGGER
-#define ACPI_USE_SYSTEM_CLIBRARY
-#endif
-
-/*
- * Memory allocation tracking.  Used only if
- * 1) This is the debug version
- * 2) This is NOT a 16-bit version of the code (not enough real-mode memory)
- */
-#ifdef ACPI_DEBUG
-#ifndef _IA16
-#define ACPI_DBG_TRACK_ALLOCATIONS
-#endif
-#endif
-
-/*
- * Environment configuration.  The purpose of this file is to interface to the
- * local generation environment.
- *
- * 1) ACPI_USE_SYSTEM_CLIBRARY - Define this if linking to an actual C library.
- *      Otherwise, local versions of string/memory functions will be used.
- * 2) ACPI_USE_STANDARD_HEADERS - Define this if linking to a C library and
- *      the standard header files may be used.
- *
- * The ACPI subsystem only uses low level C library functions that do not call
- * operating system services and may therefore be inlined in the code.
- *
- * It may be necessary to tailor these include files to the target
- * generation environment.
- *
- *
- * Functions and constants used from each header:
- *
- * string.h:    memcpy
- *              memset
- *              strcat
- *              strcmp
- *              strcpy
- *              strlen
- *              strncmp
- *              strncat
- *              strncpy
- *
- * stdlib.h:    strtoul
- *
- * stdarg.h:    va_list
- *              va_arg
- *              va_start
- *              va_end
- *
- */
-
-/*! [Begin] no source code translation */
-
-#ifdef _LINUX
-#include "aclinux.h"
-
-#elif _AED_EFI
-#include "acefi.h"
-
-#elif WIN32
-#include "acwin.h"
-
-#elif __FreeBSD__
-#include "acfreebsd.h"
-
-#else
-
-/* All other environments */
-
-#define ACPI_USE_STANDARD_HEADERS
-
-/* Name of host operating system (returned by the _OS_ namespace object) */
-
-#define ACPI_OS_NAME         "Intel ACPI/CA Core Subsystem"
-
-/* This macro is used to tag functions as "printf-like" because
- * some compilers can catch printf format string problems. MSVC
- * doesn't, so this is proprocessed away.
- */
-#define ACPI_PRINTF_LIKE_FUNC
-
-#endif
-
-
-/*! [End] no source code translation !*/
-
-/******************************************************************************
- *
- * C library configuration
- *
- *****************************************************************************/
-
-#ifdef ACPI_USE_SYSTEM_CLIBRARY
-/*
- * Use the standard C library headers.
- * We want to keep these to a minimum.
- *
- */
-
-#ifdef ACPI_USE_STANDARD_HEADERS
-/*
- * Use the standard headers from the standard locations
- */
-#include <stdarg.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-
-#endif /* ACPI_USE_STANDARD_HEADERS */
-
-/*
- * We will be linking to the standard Clib functions
- */
-
-#define STRSTR(s1,s2)   strstr((s1), (s2))
-#define STRUPR(s)       acpi_ut_strupr ((s))
-#define STRLEN(s)       (u32) strlen((s))
-#define STRCPY(d,s)     strcpy((d), (s))
-#define STRNCPY(d,s,n)  strncpy((d), (s), (NATIVE_INT)(n))
-#define STRNCMP(d,s,n)  strncmp((d), (s), (NATIVE_INT)(n))
-#define STRCMP(d,s)     strcmp((d), (s))
-#define STRCAT(d,s)     strcat((d), (s))
-#define STRNCAT(d,s,n)  strncat((d), (s), (NATIVE_INT)(n))
-#define STRTOUL(d,s,n)  strtoul((d), (s), (NATIVE_INT)(n))
-#define MEMCPY(d,s,n)   memcpy((d), (s), (NATIVE_INT)(n))
-#define MEMSET(d,s,n)   memset((d), (s), (NATIVE_INT)(n))
-#define TOUPPER         toupper
-#define TOLOWER         tolower
-#define IS_XDIGIT       isxdigit
-
-/******************************************************************************
- *
- * Not using native C library, use local implementations
- *
- *****************************************************************************/
-#else
-
-/*
- * Use local definitions of C library macros and functions
- * NOTE: The function implementations may not be as efficient
- * as an inline or assembly code implementation provided by a
- * native C library.
- */
-
-#ifndef va_arg
-
-#ifndef _VALIST
-#define _VALIST
-typedef char *va_list;
-#endif /* _VALIST */
-
-/*
- * Storage alignment properties
- */
-
-#define  _AUPBND         (sizeof (NATIVE_INT) - 1)
-#define  _ADNBND         (sizeof (NATIVE_INT) - 1)
-
-/*
- * Variable argument list macro definitions
- */
-
-#define _bnd(X, bnd)    (((sizeof (X)) + (bnd)) & (~(bnd)))
-#define va_arg(ap, T)   (*(T *)(((ap) += (_bnd (T, _AUPBND))) - (_bnd (T,_ADNBND))))
-#define va_end(ap)      (void) 0
-#define va_start(ap, A) (void) ((ap) = (((char *) &(A)) + (_bnd (A,_AUPBND))))
-
-#endif /* va_arg */
-
-
-#define STRSTR(s1,s2)    acpi_ut_strstr ((s1), (s2))
-#define STRUPR(s)        acpi_ut_strupr ((s))
-#define STRLEN(s)        acpi_ut_strlen ((s))
-#define STRCPY(d,s)      acpi_ut_strcpy ((d), (s))
-#define STRNCPY(d,s,n)   acpi_ut_strncpy ((d), (s), (n))
-#define STRNCMP(d,s,n)   acpi_ut_strncmp ((d), (s), (n))
-#define STRCMP(d,s)      acpi_ut_strcmp ((d), (s))
-#define STRCAT(d,s)      acpi_ut_strcat ((d), (s))
-#define STRNCAT(d,s,n)   acpi_ut_strncat ((d), (s), (n))
-#define STRTOUL(d,s,n)   acpi_ut_strtoul ((d), (s),(n))
-#define MEMCPY(d,s,n)    acpi_ut_memcpy ((d), (s), (n))
-#define MEMSET(d,v,n)    acpi_ut_memset ((d), (v), (n))
-#define TOUPPER          acpi_ut_to_upper
-#define TOLOWER          acpi_ut_to_lower
-
-#endif /* ACPI_USE_SYSTEM_CLIBRARY */
-
-
-/******************************************************************************
- *
- * Assembly code macros
- *
- *****************************************************************************/
-
-/*
- * Handle platform- and compiler-specific assembly language differences.
- * These should already have been defined by the platform includes above.
- *
- * Notes:
- * 1) Interrupt 3 is used to break into a debugger
- * 2) Interrupts are turned off during ACPI register setup
- */
-
-/* Unrecognized compiler, use defaults */
-#ifndef ACPI_ASM_MACROS
-
-#define ACPI_ASM_MACROS
-#define causeinterrupt(level)
-#define BREAKPOINT3
-#define disable()
-#define enable()
-#define halt()
-#define ACPI_ACQUIRE_GLOBAL_LOCK(Glptr, acq)
-#define ACPI_RELEASE_GLOBAL_LOCK(Glptr, acq)
-
-#endif /* ACPI_ASM_MACROS */
-
-
-#ifdef ACPI_APPLICATION
-
-/* Don't want software interrupts within a ring3 application */
-
-#undef causeinterrupt
-#undef BREAKPOINT3
-#define causeinterrupt(level)
-#define BREAKPOINT3
-#endif
-
-
-/******************************************************************************
- *
- * Compiler-specific
- *
- *****************************************************************************/
-
-/* this has been moved to compiler-specific headers, which are included from the
-   platform header. */
-
-
-#endif /* __ACENV_H__ */
diff -urNp linux-5400/drivers/acpi/include/platform/acgcc.h linux-5410/drivers/acpi/include/platform/acgcc.h
--- linux-5400/drivers/acpi/include/platform/acgcc.h
+++ linux-5410/drivers/acpi/include/platform/acgcc.h
@@ -1,196 +0,0 @@
-/******************************************************************************
- *
- * Name: acgcc.h - GCC specific defines, etc.
- *       $Revision: 14 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACGCC_H__
-#define __ACGCC_H__
-
-
-#ifdef __ia64__
-#define _IA64
-
-#define COMPILER_DEPENDENT_UINT64   unsigned long
-/* Single threaded */
-#define ACPI_APPLICATION
-
-#define ACPI_ASM_MACROS
-#define causeinterrupt(level)
-#define BREAKPOINT3
-#define disable() __cli()
-#define enable()  __sti()
-
-/*! [Begin] no source code translation */
-
-#include <asm/pal.h>
-
-#define halt()              ia64_pal_halt_light()           /* PAL_HALT[_LIGHT] */
-#define safe_halt()         ia64_pal_halt(1)                /* PAL_HALT */
-
-
-#define ACPI_ACQUIRE_GLOBAL_LOCK(GLptr, Acq) \
-	do { \
-	__asm__ volatile ("1:  ld4      r29=%1\n"  \
-		";;\n"                  \
-		"mov    ar.ccv=r29\n"   \
-		"mov    r2=r29\n"       \
-		"shr.u  r30=r29,1\n"    \
-		"and    r29=-4,r29\n"   \
-		";;\n"                  \
-		"add    r29=2,r29\n"    \
-		"and    r30=1,r30\n"    \
-		";;\n"                  \
-		"add    r29=r29,r30\n"  \
-		";;\n"                  \
-		"cmpxchg4.acq   r30=%1,r29,ar.ccv\n" \
-		";;\n"                  \
-		"cmp.eq p6,p7=r2,r30\n" \
-		"(p7) br.dpnt.few 1b\n" \
-		"cmp.gt p8,p9=3,r29\n"  \
-		";;\n"                  \
-		"(p8) mov %0=-1\n"      \
-		"(p9) mov %0=r0\n"      \
-		:"=r"(Acq):"m"(GLptr):"r2","r29","r30","memory"); \
-	} while (0)
-
-#define ACPI_RELEASE_GLOBAL_LOCK(GLptr, Acq) \
-	do { \
-	__asm__ volatile ("1:  ld4      r29=%1\n" \
-		";;\n"                  \
-		"mov    ar.ccv=r29\n"   \
-		"mov    r2=r29\n"       \
-		"and    r29=-4,r29\n"   \
-		";;\n"                  \
-		"cmpxchg4.acq   r30=%1,r29,ar.ccv\n" \
-		";;\n"                  \
-		"cmp.eq p6,p7=r2,r30\n" \
-		"(p7) br.dpnt.few 1b\n" \
-		"and    %0=1,r2\n"      \
-		";;\n"                  \
-		:"=r"(Acq):"m"(GLptr):"r2","r29","r30","memory"); \
-	} while (0)
-/*! [End] no source code translation !*/
-
-
-#elif __i386__ /* DO IA32 */
-#define COMPILER_DEPENDENT_UINT64   unsigned long long
-#define ACPI_ASM_MACROS
-#define causeinterrupt(level)
-#define BREAKPOINT3
-#define disable() __cli()
-#define enable()  __sti()
-#define halt()    __asm__ __volatile__ ("sti; hlt":::"memory")
-
-/*! [Begin] no source code translation
- *
- * A brief explanation as GNU inline assembly is a bit hairy
- *  %0 is the output parameter in EAX ("=a")
- *  %1 and %2 are the input parameters in ECX ("c")
- *  and an immediate value ("i") respectively
- *  All actual register references are preceded with "%%" as in "%%edx"
- *  Immediate values in the assembly are preceded by "$" as in "$0x1"
- *  The final asm parameter are the operation altered non-output registers.
- */
-#define ACPI_ACQUIRE_GLOBAL_LOCK(GLptr, Acq) \
-	do { \
-		int dummy; \
-		asm("1:     movl (%1),%%eax;" \
-			"movl   %%eax,%%edx;" \
-			"andl   %2,%%edx;" \
-			"btsl   $0x1,%%edx;" \
-			"adcl   $0x0,%%edx;" \
-			"lock;  cmpxchgl %%edx,(%1);" \
-			"jnz    1b;" \
-			"cmpb   $0x3,%%dl;" \
-			"sbbl   %%eax,%%eax" \
-			:"=a"(Acq),"=c"(dummy):"c"(GLptr),"i"(~1L):"dx"); \
-	} while(0)
-
-#define ACPI_RELEASE_GLOBAL_LOCK(GLptr, Acq) \
-	do { \
-		int dummy; \
-		asm("1:     movl (%1),%%eax;" \
-			"movl   %%eax,%%edx;" \
-			"andl   %2,%%edx;" \
-			"lock;  cmpxchgl %%edx,(%1);" \
-			"jnz    1b;" \
-			"andl   $0x1,%%eax" \
-			:"=a"(Acq),"=c"(dummy):"c"(GLptr),"i"(~3L):"dx"); \
-	} while(0)
-#elif __x86_64__ 
-#define COMPILER_DEPENDENT_UINT64   unsigned long long
-#define ACPI_ASM_MACROS
-#define causeinterrupt(level)
-#define BREAKPOINT3
-#define disable() __cli()
-#define enable()  __sti()
-#define halt()    __asm__ __volatile__ ("sti; hlt":::"memory")
-
-/*! [Begin] no source code translation
- *
- * A brief explanation as GNU inline assembly is a bit hairy
- *  %0 is the output parameter in RAX ("=a")
- *  %1 and %2 are the input parameters in RCX ("c")
- *  and an immediate value ("i") respectively
- *  All actual register references are preceded with "%%" as in "%%edx"
- *  Immediate values in the assembly are preceded by "$" as in "$0x1"
- *  The final asm parameter are the operation altered non-output registers.
- */
-#define ACPI_ACQUIRE_GLOBAL_LOCK(GLptr, Acq) \
-	do { \
-		unsigned long dummy; \
-		asm("1:     movl (%2),%%eax;" \
-			"movl   %%eax,%%edx;" \
-			"andq   %2,%%rdx;" \
-			"btsl   $0x1,%%edx;" \
-			"adcl   $0x0,%%edx;" \
-			"lock;  cmpxchgl %%edx,(%1);" \
-			"jnz    1b;" \
-			"cmpb   $0x3,%%dl;" \
-			"sbbl   %%eax,%%eax" \
-			:"=a"(Acq),"=c"(dummy):"c"(GLptr),"i"(~1L):"dx"); \
-	} while(0)
-
-#define ACPI_RELEASE_GLOBAL_LOCK(GLptr, Acq) \
-	do { \
-		unsigned long dummy; \
-		asm("1:     movl (%2),%%eax;" \
-			"movl   %%eax,%%edx;" \
-			"andq   %2,%%rdx;" \
-			"lock;  cmpxchgl %%edx,(%1);" \
-			"jnz    1b;" \
-			"andl   $0x1,%%eax" \
-			:"=a"(Acq),"=c"(dummy):"c"(GLptr),"i"(~3L):"dx"); \
-	} while(0)
-
-/*! [End] no source code translation !*/
-
-#endif
-
-/* This macro is used to tag functions as "printf-like" because
- * some compilers (like GCC) can catch printf format string problems.
- */
-#define ACPI_PRINTF_LIKE_FUNC __attribute__ ((__format__ (__printf__, 4, 5)))
-
-
-#endif /* __ACGCC_H__ */
diff -urNp linux-5400/drivers/acpi/include/platform/aclinux.h linux-5410/drivers/acpi/include/platform/aclinux.h
--- linux-5400/drivers/acpi/include/platform/aclinux.h
+++ linux-5410/drivers/acpi/include/platform/aclinux.h
@@ -1,71 +0,0 @@
-/******************************************************************************
- *
- * Name: aclinux.h - OS specific defines, etc.
- *       $Revision: 14 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACLINUX_H__
-#define __ACLINUX_H__
-
-#define ACPI_OS_NAME                "Linux"
-
-#define ACPI_USE_SYSTEM_CLIBRARY
-
-#ifdef __KERNEL__
-
-#include <linux/config.h>
-#include <linux/string.h>
-#include <linux/kernel.h>
-#include <linux/ctype.h>
-#include <asm/system.h>
-#include <asm/atomic.h>
-#include <asm/div64.h>
-
-#define strtoul simple_strtoul
-
-#else
-
-#include <stdarg.h>
-#include <string.h>
-#include <stdlib.h>
-#include <ctype.h>
-
-#endif
-
-/* Linux uses GCC */
-
-#include "acgcc.h"
-
-#undef DEBUGGER_THREADING
-#define DEBUGGER_THREADING          DEBUGGER_SINGLE_THREADED
-
-#if BITS_PER_LONG < 64
-/* Linux ia32 can't do int64 well */
-#define ACPI_NO_INTEGER64_SUPPORT
-/* And the ia32 kernel doesn't include 64-bit divide support */
-#define ACPI_DIV64(dividend, divisor) do_div(dividend, divisor)
-#else
-#define ACPI_DIV64(dividend, divisor) ACPI_DIVIDE(dividend, divisor)
-#endif
-
-
-#endif /* __ACLINUX_H__ */
diff -urNp linux-5400/drivers/acpi/kdb/README.txt linux-5410/drivers/acpi/kdb/README.txt
--- linux-5400/drivers/acpi/kdb/README.txt
+++ linux-5410/drivers/acpi/kdb/README.txt
@@ -1,36 +0,0 @@
-Using the ACPI debugger with kdb
---------------------------------
-
-ACPI CA includes a full-featured debugger, which allows the examination of
-a running system's ACPI tables, as well as running and stepping through
-control methods.
-
-Configuration
--------------
-1) Edit the main acpi Makefile. On the ACPI_CFLAGS line, remove the '#', thus
-   enabling the debugger.
-
-2) Download the latest kdb patch from:
-
-   ftp://oss.sgi.com/www/projects/kdb/download/ix86/ 
-
-   Follow the instructions at http://oss.sgi.com/projects/kdb/ on how to
-   install the patch and configure KDB.
-
-3) This would probably be a good time to recompile the kernel, and make sure
-   kdb works (Hitting the Pause key should drop you into it. Type "go" to exit
-   it.
-
-4) The kdb <--> ACPI debugger interface is a module. Type "make modules", and
-   it will be built and placed in drivers/acpi/kdb.
-
-5) Change to that directory and type "insmod kdbm_acpi.o". This loads the
-   module we just built.
-
-6) Break back into kdb. If you type help, you should now see "acpi" listed as
-   a command, at the bottom.
-
-7) Type "acpi". You are now in the ACPI debugger. While hosted by kdb, it is
-   wholly separate, and has many ACPI-specific commands. Type "?" or "help"
-   to get a listing of the command categories, and then "help <category>" for
-   a list of commands and their descriptions
diff -urNp linux-5400/drivers/acpi/kdb/kdbm_acpi.c linux-5410/drivers/acpi/kdb/kdbm_acpi.c
--- linux-5400/drivers/acpi/kdb/kdbm_acpi.c
+++ linux-5410/drivers/acpi/kdb/kdbm_acpi.c
@@ -1,54 +0,0 @@
-/*
- *  kdbm_acpi.c - kdb debugger module interface for ACPI debugger
- *
- *  Copyright (C) 2000 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include <linux/types.h>
-#include <linux/kdb.h>
-#include <linux/module.h>
-
-#include "acpi.h"
-#include "acdebug.h"
-
-extern int acpi_in_debugger;
-
-static int
-kdbm_acpi(int argc, const char **argv, const char **envp, struct pt_regs *regs)
-{
-	acpi_in_debugger = 1;
-
-	acpi_db_user_commands(DB_COMMAND_PROMPT, NULL);
-
-	acpi_in_debugger = 0;
-
-	return 0;
-}
-
-int
-init_module(void)
-{
-	kdb_register("acpi", kdbm_acpi, "", "Enter ACPI debugger", 0);
-
-	return 0;
-}
-
-void
-cleanup_module(void)
-{
-	kdb_unregister("acpi");
-}
diff -urNp linux-5400/drivers/acpi/namespace/Makefile linux-5410/drivers/acpi/namespace/Makefile
--- linux-5400/drivers/acpi/namespace/Makefile
+++ linux-5410/drivers/acpi/namespace/Makefile
@@ -1,11 +1,10 @@
 #
 # Makefile for all Linux ACPI interpreter subdirectories
-# EXCEPT for the ospm directory
 #
 
 O_TARGET := $(notdir $(CURDIR)).o
 
-obj-$(CONFIG_ACPI) := $(patsubst %.c,%.o,$(wildcard *.c))
+obj-$(CONFIG_ACPI_INTERPRETER) := $(patsubst %.c,%.o,$(wildcard *.c))
 
 EXTRA_CFLAGS += $(ACPI_CFLAGS)
 
diff -urNp linux-5400/drivers/acpi/namespace/nsaccess.c linux-5410/drivers/acpi/namespace/nsaccess.c
--- linux-5400/drivers/acpi/namespace/nsaccess.c
+++ linux-5410/drivers/acpi/namespace/nsaccess.c
@@ -1,43 +1,60 @@
 /*******************************************************************************
  *
  * Module Name: nsaccess - Top-level functions for accessing ACPI namespace
- *              $Revision: 135 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "amlcode.h"
-#include "acinterp.h"
-#include "acnamesp.h"
-#include "acdispat.h"
+#include <acpi/acpi.h>
+#include <acpi/amlcode.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acdispat.h>
 
 
 #define _COMPONENT          ACPI_NAMESPACE
-	 MODULE_NAME         ("nsaccess")
+	 ACPI_MODULE_NAME    ("nsaccess")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_root_initialize
+ * FUNCTION:    acpi_ns_root_initialize
  *
  * PARAMETERS:  None
  *
@@ -52,42 +69,44 @@
 acpi_status
 acpi_ns_root_initialize (void)
 {
-	acpi_status             status = AE_OK;
-	const predefined_names  *init_val = NULL;
-	acpi_namespace_node     *new_node;
-	acpi_operand_object     *obj_desc;
+	acpi_status                         status;
+	const struct acpi_predefined_names *init_val = NULL;
+	struct acpi_namespace_node          *new_node;
+	union acpi_operand_object           *obj_desc;
+	acpi_string                         val = NULL;
 
 
-	FUNCTION_TRACE ("Ns_root_initialize");
+	ACPI_FUNCTION_TRACE ("ns_root_initialize");
 
 
-	acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	/*
 	 * The global root ptr is initially NULL, so a non-NULL value indicates
-	 * that Acpi_ns_root_initialize() has already been called; just return.
+	 * that acpi_ns_root_initialize() has already been called; just return.
 	 */
 	if (acpi_gbl_root_node) {
 		status = AE_OK;
 		goto unlock_and_exit;
 	}
 
-
 	/*
 	 * Tell the rest of the subsystem that the root is initialized
 	 * (This is OK because the namespace is locked)
 	 */
 	acpi_gbl_root_node = &acpi_gbl_root_node_struct;
 
-
 	/* Enter the pre-defined names in the name table */
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Entering predefined entries into namespace\n"));
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+		"Entering predefined entries into namespace\n"));
 
 	for (init_val = acpi_gbl_pre_defined_names; init_val->name; init_val++) {
 		status = acpi_ns_lookup (NULL, init_val->name, init_val->type,
-				 IMODE_LOAD_PASS2, NS_NO_UPSEARCH,
-				 NULL, &new_node);
+				  ACPI_IMODE_LOAD_PASS2, ACPI_NS_NO_UPSEARCH, NULL, &new_node);
 
 		if (ACPI_FAILURE (status) || (!new_node)) /* Must be on same line for code converter */ {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
@@ -97,10 +116,20 @@ acpi_ns_root_initialize (void)
 
 		/*
 		 * Name entered successfully.
-		 * If entry in Pre_defined_names[] specifies an
+		 * If entry in pre_defined_names[] specifies an
 		 * initial value, create the initial value.
 		 */
 		if (init_val->val) {
+			status = acpi_os_predefined_override (init_val, &val);
+			if (ACPI_FAILURE (status)) {
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not override predefined %s\n",
+					init_val->name));
+			}
+
+			if (!val) {
+				val = init_val->val;
+			}
+
 			/*
 			 * Entry requests an initial value, allocate a
 			 * descriptor for it.
@@ -116,13 +145,24 @@ acpi_ns_root_initialize (void)
 			 * internal representation. Only types actually
 			 * used for initial values are implemented here.
 			 */
-
 			switch (init_val->type) {
+			case ACPI_TYPE_METHOD:
+				obj_desc->method.param_count =
+						(u8) ACPI_STRTOUL (val, NULL, 10);
+				obj_desc->common.flags |= AOPOBJ_DATA_VALID;
+
+#if defined (ACPI_NO_METHOD_EXECUTION) || defined (ACPI_CONSTANT_EVAL_ONLY)
+
+				/* Compiler cheats by putting parameter count in the owner_iD */
+
+				new_node->owner_id = obj_desc->method.param_count;
+#endif
+				break;
 
 			case ACPI_TYPE_INTEGER:
 
 				obj_desc->integer.value =
-						(acpi_integer) STRTOUL (init_val->val, NULL, 10);
+						(acpi_integer) ACPI_STRTOUL (val, NULL, 10);
 				break;
 
 
@@ -131,25 +171,25 @@ acpi_ns_root_initialize (void)
 				/*
 				 * Build an object around the static string
 				 */
-				obj_desc->string.length = STRLEN (init_val->val);
-				obj_desc->string.pointer = init_val->val;
+				obj_desc->string.length = (u32) ACPI_STRLEN (val);
+				obj_desc->string.pointer = val;
 				obj_desc->common.flags |= AOPOBJ_STATIC_POINTER;
 				break;
 
 
 			case ACPI_TYPE_MUTEX:
 
+				obj_desc->mutex.node = new_node;
 				obj_desc->mutex.sync_level =
-						 (u16) STRTOUL (init_val->val, NULL, 10);
+						 (u16) ACPI_STRTOUL (val, NULL, 10);
 
-				if (STRCMP (init_val->name, "_GL_") == 0) {
+				if (ACPI_STRCMP (init_val->name, "_GL_") == 0) {
 					/*
 					 * Create a counting semaphore for the
 					 * global lock
 					 */
 					status = acpi_os_create_semaphore (ACPI_NO_UNIT_LIMIT,
 							 1, &obj_desc->mutex.semaphore);
-
 					if (ACPI_FAILURE (status)) {
 						goto unlock_and_exit;
 					}
@@ -160,13 +200,11 @@ acpi_ns_root_initialize (void)
 					 */
 					acpi_gbl_global_lock_semaphore = obj_desc->mutex.semaphore;
 				}
-
 				else {
 					/* Create a mutex */
 
 					status = acpi_os_create_semaphore (1, 1,
 							   &obj_desc->mutex.semaphore);
-
 					if (ACPI_FAILURE (status)) {
 						goto unlock_and_exit;
 					}
@@ -175,7 +213,7 @@ acpi_ns_root_initialize (void)
 
 
 			default:
-				REPORT_ERROR (("Unsupported initial type value %X\n",
+				ACPI_REPORT_ERROR (("Unsupported initial type value %X\n",
 					init_val->type));
 				acpi_ut_remove_reference (obj_desc);
 				obj_desc = NULL;
@@ -184,7 +222,7 @@ acpi_ns_root_initialize (void)
 
 			/* Store pointer to value descriptor in the Node */
 
-			acpi_ns_attach_object (new_node, obj_desc, obj_desc->common.type);
+			status = acpi_ns_attach_object (new_node, obj_desc, ACPI_GET_OBJECT_TYPE (obj_desc));
 
 			/* Remove local reference to the object */
 
@@ -194,23 +232,23 @@ acpi_ns_root_initialize (void)
 
 
 unlock_and_exit:
-	acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_lookup
+ * FUNCTION:    acpi_ns_lookup
  *
- * PARAMETERS:  Prefix_node     - Search scope if name is not fully qualified
+ * PARAMETERS:  prefix_node     - Search scope if name is not fully qualified
  *              Pathname        - Search pathname, in internal format
  *                                (as represented in the AML stream)
  *              Type            - Type associated with name
- *              Interpreter_mode - IMODE_LOAD_PASS2 => add name if not found
+ *              interpreter_mode - IMODE_LOAD_PASS2 => add name if not found
  *              Flags           - Flags describing the search restrictions
- *              Walk_state      - Current state of the walk
- *              Return_node     - Where the Node is placed (if found
+ *              walk_state      - Current state of the walk
+ *              return_node     - Where the Node is placed (if found
  *                                or created successfully)
  *
  * RETURN:      Status
@@ -224,44 +262,41 @@ unlock_and_exit:
 
 acpi_status
 acpi_ns_lookup (
-	acpi_generic_state      *scope_info,
-	NATIVE_CHAR             *pathname,
-	acpi_object_type8       type,
-	operating_mode          interpreter_mode,
-	u32                     flags,
-	acpi_walk_state         *walk_state,
-	acpi_namespace_node     **return_node)
+	union acpi_generic_state        *scope_info,
+	char                            *pathname,
+	acpi_object_type                type,
+	acpi_interpreter_mode           interpreter_mode,
+	u32                             flags,
+	struct acpi_walk_state          *walk_state,
+	struct acpi_namespace_node      **return_node)
 {
-	acpi_status             status;
-	acpi_namespace_node     *prefix_node;
-	acpi_namespace_node     *current_node = NULL;
-	acpi_namespace_node     *scope_to_push = NULL;
-	acpi_namespace_node     *this_node = NULL;
-	u32                     num_segments;
-	acpi_name               simple_name;
-	u8                      null_name_path = FALSE;
-	acpi_object_type8       type_to_check_for;
-	acpi_object_type8       this_search_type;
-	u32                     local_flags = flags & ~NS_ERROR_IF_FOUND;
-
-	DEBUG_EXEC              (u32 i;)
+	acpi_status                     status;
+	char                            *path = pathname;
+	struct acpi_namespace_node      *prefix_node;
+	struct acpi_namespace_node      *current_node = NULL;
+	struct acpi_namespace_node      *this_node = NULL;
+	u32                             num_segments;
+	u32                             num_carats;
+	acpi_name                       simple_name;
+	acpi_object_type                type_to_check_for;
+	acpi_object_type                this_search_type;
+	u32                             search_parent_flag = ACPI_NS_SEARCH_PARENT;
+	u32                             local_flags = flags & ~(ACPI_NS_ERROR_IF_FOUND |
+			   ACPI_NS_SEARCH_PARENT);
 
 
-	FUNCTION_TRACE ("Ns_lookup");
+	ACPI_FUNCTION_TRACE ("ns_lookup");
 
 
 	if (!return_node) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-
 	acpi_gbl_ns_lookup_count++;
-
-	*return_node = ENTRY_NOT_FOUND;
-
+	*return_node = ACPI_ENTRY_NOT_FOUND;
 
 	if (!acpi_gbl_root_node) {
-		return (AE_NO_NAMESPACE);
+		return_ACPI_STATUS (AE_NO_NAMESPACE);
 	}
 
 	/*
@@ -270,248 +305,273 @@ acpi_ns_lookup (
 	 */
 	if ((!scope_info) ||
 		(!scope_info->scope.node)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "Null scope prefix, using root node (%p)\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
+			"Null scope prefix, using root node (%p)\n",
 			acpi_gbl_root_node));
 
 		prefix_node = acpi_gbl_root_node;
 	}
 	else {
 		prefix_node = scope_info->scope.node;
-	}
-
-
-	/*
-	 * This check is explicitly split to relax the Type_to_check_for
-	 * conditions for Bank_field_defn. Originally, both Bank_field_defn and
-	 * Def_field_defn caused Type_to_check_for to be set to ACPI_TYPE_REGION,
-	 * but the Bank_field_defn may also check for a Field definition as well
-	 * as an Operation_region.
-	 */
-	if (INTERNAL_TYPE_FIELD_DEFN == type) {
-		/* Def_field_defn defines fields in a Region */
-
-		type_to_check_for = ACPI_TYPE_REGION;
-	}
-
-	else if (INTERNAL_TYPE_BANK_FIELD_DEFN == type) {
-		/* Bank_field_defn defines data fields in a Field Object */
-
-		type_to_check_for = ACPI_TYPE_ANY;
-	}
+		if (ACPI_GET_DESCRIPTOR_TYPE (prefix_node) != ACPI_DESC_TYPE_NAMED) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "[%p] Not a namespace node\n",
+				prefix_node));
+			return_ACPI_STATUS (AE_AML_INTERNAL);
+		}
 
-	else {
-		type_to_check_for = type;
+		/*
+		 * This node might not be a actual "scope" node (such as a
+		 * Device/Method, etc.)  It could be a Package or other object node.
+		 * Backup up the tree to find the containing scope node.
+		 */
+		while (!acpi_ns_opens_scope (prefix_node->type) &&
+				prefix_node->type != ACPI_TYPE_ANY) {
+			prefix_node = acpi_ns_get_parent_node (prefix_node);
+		}
 	}
 
+	/* Save type   TBD: may be no longer necessary */
 
-	/* TBD: [Restructure] - Move the pathname stuff into a new procedure */
-
-	/* Examine the name pointer */
+	type_to_check_for = type;
 
+	/*
+	 * Begin examination of the actual pathname
+	 */
 	if (!pathname) {
-		/*  8-12-98 ASL Grammar Update supports null Name_path  */
+		/* A Null name_path is allowed and refers to the root */
 
-		null_name_path = TRUE;
 		num_segments = 0;
-		this_node = acpi_gbl_root_node;
+		this_node    = acpi_gbl_root_node;
+		path     = "";
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
-			"Null Pathname (Zero segments),  Flags=%x\n", flags));
+			"Null Pathname (Zero segments), Flags=%X\n", flags));
 	}
-
 	else {
 		/*
-		 * Valid name pointer (Internal name format)
+		 * Name pointer is valid (and must be in internal name format)
 		 *
-		 * Check for prefixes.  As represented in the AML stream, a
-		 * Pathname consists of an optional scope prefix followed by
-		 * a segment part.
+		 * Check for scope prefixes:
 		 *
-		 * If present, the scope prefix is either a Root_prefix (in
-		 * which case the name is fully qualified), or zero or more
-		 * Parent_prefixes (in which case the name's scope is relative
-		 * to the current scope).
+		 * As represented in the AML stream, a namepath consists of an
+		 * optional scope prefix followed by a name segment part.
 		 *
-		 * The segment part consists of either:
-		 *  - A single 4-byte name segment, or
-		 *  - A Dual_name_prefix followed by two 4-byte name segments, or
-		 *  - A Multi_name_prefix_op, followed by a byte indicating the
-		 *    number of segments and the segments themselves.
+		 * If present, the scope prefix is either a Root Prefix (in
+		 * which case the name is fully qualified), or one or more
+		 * Parent Prefixes (in which case the name's scope is relative
+		 * to the current scope).
 		 */
-		if (*pathname == AML_ROOT_PREFIX) {
-			/* Pathname is fully qualified, look in root name table */
-
-			current_node = acpi_gbl_root_node;
+		if (*path == (u8) AML_ROOT_PREFIX) {
+			/* Pathname is fully qualified, start from the root */
 
-			/* point to segment part */
+			this_node = acpi_gbl_root_node;
+			search_parent_flag = ACPI_NS_NO_UPSEARCH;
 
-			pathname++;
+			/* Point to name segment part */
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "Searching from root [%p]\n",
-				current_node));
+			path++;
 
-			/* Direct reference to root, "\" */
-
-			if (!(*pathname)) {
-				this_node = acpi_gbl_root_node;
-				goto check_for_new_scope_and_exit;
-			}
+			ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
+				"Path is absolute from root [%p]\n", this_node));
 		}
-
 		else {
 			/* Pathname is relative to current scope, start there */
 
-			current_node = prefix_node;
-
-			ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "Searching relative to pfx scope [%p]\n",
-				prefix_node));
+			ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
+				"Searching relative to prefix scope [%4.4s] (%p)\n",
+				prefix_node->name.ascii, prefix_node));
 
 			/*
-			 * Handle up-prefix (carat).  More than one prefix
-			 * is supported
+			 * Handle multiple Parent Prefixes (carat) by just getting
+			 * the parent node for each prefix instance.
 			 */
-			while (*pathname == AML_PARENT_PREFIX) {
-				/* Point to segment part or next Parent_prefix */
+			this_node = prefix_node;
+			num_carats = 0;
+			while (*path == (u8) AML_PARENT_PREFIX) {
+				/* Name is fully qualified, no search rules apply */
 
-				pathname++;
+				search_parent_flag = ACPI_NS_NO_UPSEARCH;
+				/*
+				 * Point past this prefix to the name segment
+				 * part or the next Parent Prefix
+				 */
+				path++;
 
-				/*  Backup to the parent's scope  */
+				/* Backup to the parent node */
 
-				this_node = acpi_ns_get_parent_object (current_node);
+				num_carats++;
+				this_node = acpi_ns_get_parent_node (this_node);
 				if (!this_node) {
 					/* Current scope has no parent scope */
 
-					REPORT_ERROR (
-						("Too many parent prefixes (^) - reached root\n"));
+					ACPI_REPORT_ERROR (
+						("ACPI path has too many parent prefixes (^) - reached beyond root node\n"));
 					return_ACPI_STATUS (AE_NOT_FOUND);
 				}
+			}
 
-				current_node = this_node;
+			if (search_parent_flag == ACPI_NS_NO_UPSEARCH) {
+				ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
+					"Search scope is [%4.4s], path has %d carat(s)\n",
+					this_node->name.ascii, num_carats));
 			}
 		}
 
-
 		/*
-		 * Examine the name prefix opcode, if any,
-		 * to determine the number of segments
+		 * Determine the number of ACPI name segments in this pathname.
+		 *
+		 * The segment part consists of either:
+		 *  - A Null name segment (0)
+		 *  - A dual_name_prefix followed by two 4-byte name segments
+		 *  - A multi_name_prefix followed by a byte indicating the
+		 *      number of segments and the segments themselves.
+		 *  - A single 4-byte name segment
+		 *
+		 * Examine the name prefix opcode, if any, to determine the number of
+		 * segments.
 		 */
-		if (*pathname == AML_DUAL_NAME_PREFIX) {
-			num_segments = 2;
+		switch (*path) {
+		case 0:
+			/*
+			 * Null name after a root or parent prefixes. We already
+			 * have the correct target node and there are no name segments.
+			 */
+			num_segments = 0;
+			type = this_node->type;
+
+			ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
+				"Prefix-only Pathname (Zero name segments), Flags=%X\n", flags));
+			break;
+
+		case AML_DUAL_NAME_PREFIX:
+
+			/* More than one name_seg, search rules do not apply */
 
-			/* point to first segment */
+			search_parent_flag = ACPI_NS_NO_UPSEARCH;
 
-			pathname++;
+			/* Two segments, point to first name segment */
+
+			num_segments = 2;
+			path++;
 
 			ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
 				"Dual Pathname (2 segments, Flags=%X)\n", flags));
-		}
+			break;
+
+		case AML_MULTI_NAME_PREFIX_OP:
 
-		else if (*pathname == AML_MULTI_NAME_PREFIX_OP) {
-			num_segments = (u32)* (u8 *) ++pathname;
+			/* More than one name_seg, search rules do not apply */
 
-			/* point to first segment */
+			search_parent_flag = ACPI_NS_NO_UPSEARCH;
 
-			pathname++;
+			/* Extract segment count, point to first name segment */
+
+			path++;
+			num_segments = (u32) (u8) *path;
+			path++;
 
 			ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
 				"Multi Pathname (%d Segments, Flags=%X) \n",
 				num_segments, flags));
-		}
+			break;
 
-		else {
+		default:
 			/*
-			 * No Dual or Multi prefix, hence there is only one
-			 * segment and Pathname is already pointing to it.
+			 * Not a Null name, no Dual or Multi prefix, hence there is
+			 * only one name segment and Pathname is already pointing to it.
 			 */
 			num_segments = 1;
 
 			ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
 				"Simple Pathname (1 segment, Flags=%X)\n", flags));
+			break;
 		}
 
-#ifdef ACPI_DEBUG
-
-		/* TBD: [Restructure] Make this a procedure */
-
-		/* Debug only: print the entire name that we are about to lookup */
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "["));
-
-		for (i = 0; i < num_segments; i++) {
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_NAMES, "%4.4s/", (char*)&pathname[i * 4]));
-		}
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_NAMES, "]\n"));
-#endif
+		ACPI_DEBUG_EXEC (acpi_ns_print_pathname (num_segments, path));
 	}
 
 
 	/*
-	 * Search namespace for each segment of the name.
-	 * Loop through and verify/add each name segment.
+	 * Search namespace for each segment of the name.  Loop through and
+	 * verify (or add to the namespace) each name segment.
+	 *
+	 * The object type is significant only at the last name
+	 * segment.  (We don't care about the types along the path, only
+	 * the type of the final target object.)
 	 */
-	while (num_segments-- && current_node) {
-		/*
-		 * Search for the current name segment under the current
-		 * named object.  The Type is significant only at the last (topmost)
-		 * level.  (We don't care about the types along the path, only
-		 * the type of the final target object.)
-		 */
-		this_search_type = ACPI_TYPE_ANY;
+	this_search_type = ACPI_TYPE_ANY;
+	current_node = this_node;
+	while (num_segments && current_node) {
+		num_segments--;
 		if (!num_segments) {
+			/*
+			 * This is the last segment, enable typechecking
+			 */
 			this_search_type = type;
-			local_flags = flags;
-		}
 
-		/* Pluck one ACPI name from the front of the pathname */
+			/*
+			 * Only allow automatic parent search (search rules) if the caller
+			 * requested it AND we have a single, non-fully-qualified name_seg
+			 */
+			if ((search_parent_flag != ACPI_NS_NO_UPSEARCH) &&
+				(flags & ACPI_NS_SEARCH_PARENT)) {
+				local_flags |= ACPI_NS_SEARCH_PARENT;
+			}
+
+			/* Set error flag according to caller */
 
-		MOVE_UNALIGNED32_TO_32 (&simple_name, pathname);
+			if (flags & ACPI_NS_ERROR_IF_FOUND) {
+				local_flags |= ACPI_NS_ERROR_IF_FOUND;
+			}
+		}
 
-		/* Try to find the ACPI name */
+		/* Extract one ACPI name from the front of the pathname */
 
-		status = acpi_ns_search_and_enter (simple_name, walk_state,
-				   current_node, interpreter_mode,
-				   this_search_type, local_flags,
-				   &this_node);
+		ACPI_MOVE_32_TO_32 (&simple_name, path);
 
+		/* Try to find the single (4 character) ACPI name */
+
+		status = acpi_ns_search_and_enter (simple_name, walk_state, current_node,
+				  interpreter_mode, this_search_type, local_flags, &this_node);
 		if (ACPI_FAILURE (status)) {
 			if (status == AE_NOT_FOUND) {
-				/* Name not found in ACPI namespace  */
+				/* Name not found in ACPI namespace */
 
 				ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
-					"Name [%4.4s] not found in scope %p\n",
-					(char*)&simple_name, current_node));
+					"Name [%4.4s] not found in scope [%4.4s] %p\n",
+					(char *) &simple_name, (char *) &current_node->name,
+					current_node));
 			}
 
+			*return_node = this_node;
 			return_ACPI_STATUS (status);
 		}
 
-
 		/*
-		 * If 1) This is the last segment (Num_segments == 0)
-		 *    2) and looking for a specific type
+		 * Sanity typecheck of the target object:
+		 *
+		 * If 1) This is the last segment (num_segments == 0)
+		 *    2) And we are looking for a specific type
 		 *       (Not checking for TYPE_ANY)
 		 *    3) Which is not an alias
-		 *    4) which is not a local type (TYPE_DEF_ANY)
-		 *    5) which is not a local type (TYPE_SCOPE)
-		 *    6) which is not a local type (TYPE_INDEX_FIELD_DEFN)
-		 *    7) and type of object is known (not TYPE_ANY)
-		 *    8) and object does not match request
+		 *    4) Which is not a local type (TYPE_SCOPE)
+		 *    5) And the type of target object is known (not TYPE_ANY)
+		 *    6) And target object does not match what we are looking for
 		 *
 		 * Then we have a type mismatch.  Just warn and ignore it.
 		 */
 		if ((num_segments       == 0)                               &&
 			(type_to_check_for  != ACPI_TYPE_ANY)                   &&
-			(type_to_check_for  != INTERNAL_TYPE_ALIAS)             &&
-			(type_to_check_for  != INTERNAL_TYPE_DEF_ANY)           &&
-			(type_to_check_for  != INTERNAL_TYPE_SCOPE)             &&
-			(type_to_check_for  != INTERNAL_TYPE_INDEX_FIELD_DEFN)  &&
+			(type_to_check_for  != ACPI_TYPE_LOCAL_ALIAS)           &&
+			(type_to_check_for  != ACPI_TYPE_LOCAL_SCOPE)           &&
 			(this_node->type    != ACPI_TYPE_ANY)                   &&
 			(this_node->type    != type_to_check_for)) {
 			/* Complain about a type mismatch */
 
-			REPORT_WARNING (
-				("Ns_lookup: %4.4s, type %X, checking for type %X\n",
-				(char*)&simple_name, this_node->type, type_to_check_for));
+			ACPI_REPORT_WARNING (
+				("ns_lookup: Type mismatch on %4.4s (%s), searching for (%s)\n",
+				(char *) &simple_name, acpi_ut_get_type_name (this_node->type),
+				acpi_ut_get_type_name (type_to_check_for)));
 		}
 
 		/*
@@ -519,57 +579,29 @@ acpi_ns_lookup (
 		 * specific type, but the type of found object is known, use that type
 		 * to see if it opens a scope.
 		 */
-		if ((0 == num_segments) && (ACPI_TYPE_ANY == type)) {
+		if ((num_segments == 0) && (type == ACPI_TYPE_ANY)) {
 			type = this_node->type;
 		}
 
-		if ((num_segments || acpi_ns_opens_scope (type)) &&
-			(this_node->child == NULL)) {
-			/*
-			 * More segments or the type implies enclosed scope,
-			 * and the next scope has not been allocated.
-			 */
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Load mode=%X  This_node=%p\n",
-				interpreter_mode, this_node));
-		}
+		/* Point to next name segment and make this node current */
 
+		path += ACPI_NAME_SIZE;
 		current_node = this_node;
-
-		/* point to next name segment */
-
-		pathname += ACPI_NAME_SIZE;
 	}
 
-
 	/*
 	 * Always check if we need to open a new scope
 	 */
-check_for_new_scope_and_exit:
-
-	if (!(flags & NS_DONT_OPEN_SCOPE) && (walk_state)) {
+	if (!(flags & ACPI_NS_DONT_OPEN_SCOPE) && (walk_state)) {
 		/*
-		 * If entry is a type which opens a scope,
-		 * push the new scope on the scope stack.
+		 * If entry is a type which opens a scope, push the new scope on the
+		 * scope stack.
 		 */
-		if (acpi_ns_opens_scope (type_to_check_for)) {
-			/*  8-12-98 ASL Grammar Update supports null Name_path  */
-
-			if (null_name_path) {
-				/* TBD: [Investigate] - is this the correct thing to do? */
-
-				scope_to_push = NULL;
-			}
-			else {
-				scope_to_push = this_node;
-			}
-
-			status = acpi_ds_scope_stack_push (scope_to_push, type,
-					   walk_state);
+		if (acpi_ns_opens_scope (type)) {
+			status = acpi_ds_scope_stack_push (this_node, type, walk_state);
 			if (ACPI_FAILURE (status)) {
 				return_ACPI_STATUS (status);
 			}
-
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Set global scope to %p\n", scope_to_push));
 		}
 	}
 
diff -urNp linux-5400/drivers/acpi/namespace/nsalloc.c linux-5410/drivers/acpi/namespace/nsalloc.c
--- linux-5400/drivers/acpi/namespace/nsalloc.c
+++ linux-5410/drivers/acpi/namespace/nsalloc.c
@@ -1,43 +1,60 @@
 /*******************************************************************************
  *
  * Module Name: nsalloc - Namespace allocation and deletion utilities
- *              $Revision: 60 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acnamesp.h"
-#include "acinterp.h"
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
 
 
 #define _COMPONENT          ACPI_NAMESPACE
-	 MODULE_NAME         ("nsalloc")
+	 ACPI_MODULE_NAME    ("nsalloc")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_create_node
+ * FUNCTION:    acpi_ns_create_node
  *
- * PARAMETERS:  Acpi_name       - Name of the new node
+ * PARAMETERS:  acpi_name       - Name of the new node
  *
  * RETURN:      None
  *
@@ -45,26 +62,26 @@
  *
  ******************************************************************************/
 
-acpi_namespace_node *
+struct acpi_namespace_node *
 acpi_ns_create_node (
-	u32                     name)
+	u32                             name)
 {
-	acpi_namespace_node     *node;
+	struct acpi_namespace_node      *node;
 
 
-	FUNCTION_TRACE ("Ns_create_node");
+	ACPI_FUNCTION_TRACE ("ns_create_node");
 
 
-	node = ACPI_MEM_CALLOCATE (sizeof (acpi_namespace_node));
+	node = ACPI_MEM_CALLOCATE (sizeof (struct acpi_namespace_node));
 	if (!node) {
 		return_PTR (NULL);
 	}
 
 	ACPI_MEM_TRACKING (acpi_gbl_memory_lists[ACPI_MEM_LIST_NSNODE].total_allocated++);
 
-	node->data_type      = ACPI_DESC_TYPE_NAMED;
-	node->name           = name;
+	node->name.integer   = name;
 	node->reference_count = 1;
+	ACPI_SET_DESCRIPTOR_TYPE (node, ACPI_DESC_TYPE_NAMED);
 
 	return_PTR (node);
 }
@@ -72,7 +89,7 @@ acpi_ns_create_node (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_delete_node
+ * FUNCTION:    acpi_ns_delete_node
  *
  * PARAMETERS:  Node            - Node to be deleted
  *
@@ -84,78 +101,150 @@ acpi_ns_create_node (
 
 void
 acpi_ns_delete_node (
-	acpi_namespace_node     *node)
+	struct acpi_namespace_node      *node)
 {
-	acpi_namespace_node     *parent_node;
-	acpi_namespace_node     *prev_node;
-	acpi_namespace_node     *next_node;
+	struct acpi_namespace_node      *parent_node;
+	struct acpi_namespace_node      *prev_node;
+	struct acpi_namespace_node      *next_node;
 
 
-	FUNCTION_TRACE_PTR ("Ns_delete_node", node);
+	ACPI_FUNCTION_TRACE_PTR ("ns_delete_node", node);
 
 
-	parent_node = acpi_ns_get_parent_object (node);
+	parent_node = acpi_ns_get_parent_node (node);
 
 	prev_node = NULL;
 	next_node = parent_node->child;
 
+	/* Find the node that is the previous peer in the parent's child list */
+
 	while (next_node != node) {
 		prev_node = next_node;
 		next_node = prev_node->peer;
 	}
 
 	if (prev_node) {
+		/* Node is not first child, unlink it */
+
 		prev_node->peer = next_node->peer;
 		if (next_node->flags & ANOBJ_END_OF_PEER_LIST) {
 			prev_node->flags |= ANOBJ_END_OF_PEER_LIST;
 		}
 	}
 	else {
-		parent_node->child = next_node->peer;
+		/* Node is first child (has no previous peer) */
+
+		if (next_node->flags & ANOBJ_END_OF_PEER_LIST) {
+			/* No peers at all */
+
+			parent_node->child = NULL;
+		}
+		else {   /* Link peer list to parent */
+
+			parent_node->child = next_node->peer;
+		}
 	}
 
 
 	ACPI_MEM_TRACKING (acpi_gbl_memory_lists[ACPI_MEM_LIST_NSNODE].total_freed++);
 
 	/*
-	 * Detach an object if there is one
+	 * Detach an object if there is one then delete the node
 	 */
-	if (node->object) {
-		acpi_ns_detach_object (node);
-	}
-
+	acpi_ns_detach_object (node);
 	ACPI_MEM_FREE (node);
 	return_VOID;
 }
 
 
+#ifdef ACPI_ALPHABETIC_NAMESPACE
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_compare_names
+ *
+ * PARAMETERS:  Name1           - First name to compare
+ *              Name2           - Second name to compare
+ *
+ * RETURN:      value from strncmp
+ *
+ * DESCRIPTION: Compare two ACPI names.  Names that are prefixed with an
+ *              underscore are forced to be alphabetically first.
+ *
+ ******************************************************************************/
+
+int
+acpi_ns_compare_names (
+	char                            *name1,
+	char                            *name2)
+{
+	char                            reversed_name1[ACPI_NAME_SIZE];
+	char                            reversed_name2[ACPI_NAME_SIZE];
+	u32                             i;
+	u32                             j;
+
+
+	/*
+	 * Replace all instances of "underscore" with a value that is smaller so
+	 * that all names that are prefixed with underscore(s) are alphabetically
+	 * first.
+	 *
+	 * Reverse the name bytewise so we can just do a 32-bit compare instead
+	 * of a strncmp.
+	 */
+	for (i = 0, j= (ACPI_NAME_SIZE - 1); i < ACPI_NAME_SIZE; i++, j--) {
+		reversed_name1[j] = name1[i];
+		if (name1[i] == '_') {
+			reversed_name1[j] = '*';
+		}
+
+		reversed_name2[j] = name2[i];
+		if (name2[i] == '_') {
+			reversed_name2[j] = '*';
+		}
+	}
+
+	return (*(int *) reversed_name1 - *(int *) reversed_name2);
+}
+#endif
+
+
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_install_node
+ * FUNCTION:    acpi_ns_install_node
  *
- * PARAMETERS:  Walk_state      - Current state of the walk
- *              Parent_node     - The parent of the new Node
+ * PARAMETERS:  walk_state      - Current state of the walk
+ *              parent_node     - The parent of the new Node
  *              Node            - The new Node to install
  *              Type            - ACPI object type of the new Node
  *
  * RETURN:      None
  *
- * DESCRIPTION: Initialize a new entry within a namespace table.
+ * DESCRIPTION: Initialize a new namespace node and install it amongst
+ *              its peers.
+ *
+ *              Note: Current namespace lookup is linear search.  However, the
+ *              nodes are linked in alphabetical order to 1) put all reserved
+ *              names (start with underscore) first, and to 2) make a readable
+ *              namespace dump.
  *
  ******************************************************************************/
 
 void
 acpi_ns_install_node (
-	acpi_walk_state         *walk_state,
-	acpi_namespace_node     *parent_node,   /* Parent */
-	acpi_namespace_node     *node,          /* New Child*/
-	acpi_object_type8       type)
+	struct acpi_walk_state          *walk_state,
+	struct acpi_namespace_node      *parent_node,   /* Parent */
+	struct acpi_namespace_node      *node,          /* New Child*/
+	acpi_object_type                type)
 {
-	u16                     owner_id = TABLE_ID_DSDT;
-	acpi_namespace_node     *child_node;
+	u16                             owner_id = 0;
+	struct acpi_namespace_node      *child_node;
+#ifdef ACPI_ALPHABETIC_NAMESPACE
+
+	struct acpi_namespace_node      *previous_child_node;
+#endif
 
 
-	FUNCTION_TRACE ("Ns_install_node");
+	ACPI_FUNCTION_TRACE ("ns_install_node");
 
 
 	/*
@@ -167,17 +256,65 @@ acpi_ns_install_node (
 		owner_id = walk_state->owner_id;
 	}
 
-
-	/* link the new entry into the parent and existing children */
-
-	/* TBD: Could be first, last, or alphabetic */
+	/* Link the new entry into the parent and existing children */
 
 	child_node = parent_node->child;
 	if (!child_node) {
 		parent_node->child = node;
+		node->flags |= ANOBJ_END_OF_PEER_LIST;
+		node->peer = parent_node;
 	}
-
 	else {
+#ifdef ACPI_ALPHABETIC_NAMESPACE
+		/*
+		 * Walk the list whilst searching for the the correct
+		 * alphabetic placement.
+		 */
+		previous_child_node = NULL;
+		while (acpi_ns_compare_names (child_node->name.ascii, node->name.ascii) < 0) {
+			if (child_node->flags & ANOBJ_END_OF_PEER_LIST) {
+				/* Last peer;  Clear end-of-list flag */
+
+				child_node->flags &= ~ANOBJ_END_OF_PEER_LIST;
+
+				/* This node is the new peer to the child node */
+
+				child_node->peer = node;
+
+				/* This node is the new end-of-list */
+
+				node->flags |= ANOBJ_END_OF_PEER_LIST;
+				node->peer = parent_node;
+				break;
+			}
+
+			/* Get next peer */
+
+			previous_child_node = child_node;
+			child_node = child_node->peer;
+		}
+
+		/* Did the node get inserted at the end-of-list? */
+
+		if (!(node->flags & ANOBJ_END_OF_PEER_LIST)) {
+			/*
+			 * Loop above terminated without reaching the end-of-list.
+			 * Insert the new node at the current location
+			 */
+			if (previous_child_node) {
+				/* Insert node alphabetically */
+
+				node->peer = child_node;
+				previous_child_node->peer = node;
+			}
+			else {
+				/* Insert node alphabetically at start of list */
+
+				node->peer = child_node;
+				parent_node->child = node;
+			}
+		}
+#else
 		while (!(child_node->flags & ANOBJ_END_OF_PEER_LIST)) {
 			child_node = child_node->peer;
 		}
@@ -187,61 +324,25 @@ acpi_ns_install_node (
 		/* Clear end-of-list flag */
 
 		child_node->flags &= ~ANOBJ_END_OF_PEER_LIST;
+		node->flags     |= ANOBJ_END_OF_PEER_LIST;
+		node->peer = parent_node;
+#endif
 	}
 
 	/* Init the new entry */
 
-	node->owner_id  = owner_id;
-	node->flags     |= ANOBJ_END_OF_PEER_LIST;
-	node->peer      = parent_node;
-
-
-	/*
-	 * If adding a name with unknown type, or having to
-	 * add the region in order to define fields in it, we
-	 * have a forward reference.
-	 */
-	if ((ACPI_TYPE_ANY == type) ||
-		(INTERNAL_TYPE_FIELD_DEFN == type) ||
-		(INTERNAL_TYPE_BANK_FIELD_DEFN == type)) {
-		/*
-		 * We don't want to abort here, however!
-		 * We will fill in the actual type when the
-		 * real definition is found later.
-		 */
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "[%4.4s] is a forward reference\n",
-			(char*)&node->name));
-	}
-
-	/*
-	 * The Def_field_defn and Bank_field_defn cases are actually
-	 * looking up the Region in which the field will be defined
-	 */
-	if ((INTERNAL_TYPE_FIELD_DEFN == type) ||
-		(INTERNAL_TYPE_BANK_FIELD_DEFN == type)) {
-		type = ACPI_TYPE_REGION;
-	}
-
-	/*
-	 * Scope, Def_any, and Index_field_defn are bogus "types" which do
-	 * not actually have anything to do with the type of the name
-	 * being looked up.  Save any other value of Type as the type of
-	 * the entry.
-	 */
-	if ((type != INTERNAL_TYPE_SCOPE) &&
-		(type != INTERNAL_TYPE_DEF_ANY) &&
-		(type != INTERNAL_TYPE_INDEX_FIELD_DEFN)) {
-		node->type = (u8) type;
-	}
+	node->owner_id = owner_id;
+	node->type = (u8) type;
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "%4.4s added to %p at %p\n",
-		(char*)&node->name, parent_node, node));
+	ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "%4.4s (%s) added to %4.4s (%s) %p at %p\n",
+		node->name.ascii, acpi_ut_get_type_name (node->type),
+		parent_node->name.ascii, acpi_ut_get_type_name (parent_node->type), parent_node, node));
 
 	/*
 	 * Increment the reference count(s) of all parents up to
 	 * the root!
 	 */
-	while ((node = acpi_ns_get_parent_object (node)) != NULL) {
+	while ((node = acpi_ns_get_parent_node (node)) != NULL) {
 		node->reference_count++;
 	}
 
@@ -251,27 +352,28 @@ acpi_ns_install_node (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_delete_children
+ * FUNCTION:    acpi_ns_delete_children
  *
- * PARAMETERS:  Parent_node     - Delete this objects children
+ * PARAMETERS:  parent_node     - Delete this objects children
  *
  * RETURN:      None.
  *
- * DESCRIPTION: Delete all children of the parent object. Deletes a
- *              "scope".
+ * DESCRIPTION: Delete all children of the parent object. In other words,
+ *              deletes a "scope".
  *
  ******************************************************************************/
 
 void
 acpi_ns_delete_children (
-	acpi_namespace_node     *parent_node)
+	struct acpi_namespace_node      *parent_node)
 {
-	acpi_namespace_node     *child_node;
-	acpi_namespace_node     *next_node;
-	u8                      flags;
+	struct acpi_namespace_node      *child_node;
+	struct acpi_namespace_node      *next_node;
+	struct acpi_namespace_node      *node;
+	u8                              flags;
 
 
-	FUNCTION_TRACE_PTR ("Ns_delete_children", parent_node);
+	ACPI_FUNCTION_TRACE_PTR ("ns_delete_children", parent_node);
 
 
 	if (!parent_node) {
@@ -305,13 +407,32 @@ acpi_ns_delete_children (
 
 		ACPI_MEM_TRACKING (acpi_gbl_memory_lists[ACPI_MEM_LIST_NSNODE].total_freed++);
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Object %p, Remaining %X\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Object %p, Remaining %X\n",
 			child_node, acpi_gbl_current_node_count));
 
 		/*
 		 * Detach an object if there is one, then free the child node
 		 */
 		acpi_ns_detach_object (child_node);
+
+		/*
+		 * Decrement the reference count(s) of all parents up to
+		 * the root! (counts were incremented when the node was created)
+		 */
+		node = child_node;
+		while ((node = acpi_ns_get_parent_node (node)) != NULL) {
+			node->reference_count--;
+		}
+
+		/* There should be only one reference remaining on this node */
+
+		if (child_node->reference_count != 1) {
+			ACPI_REPORT_WARNING (("Existing references (%d) on node being deleted (%p)\n",
+				child_node->reference_count, child_node));
+		}
+
+		/* Now we can delete the node */
+
 		ACPI_MEM_FREE (child_node);
 
 		/* And move on to the next child in the list */
@@ -331,30 +452,30 @@ acpi_ns_delete_children (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_delete_namespace_subtree
+ * FUNCTION:    acpi_ns_delete_namespace_subtree
  *
- * PARAMETERS:  Parent_node     - Root of the subtree to be deleted
+ * PARAMETERS:  parent_node     - Root of the subtree to be deleted
  *
  * RETURN:      None.
  *
  * DESCRIPTION: Delete a subtree of the namespace.  This includes all objects
- *              stored within the subtree.  Scope tables are deleted also
+ *              stored within the subtree.
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ns_delete_namespace_subtree (
-	acpi_namespace_node     *parent_node)
+	struct acpi_namespace_node      *parent_node)
 {
-	acpi_namespace_node     *child_node = NULL;
-	u32                     level = 1;
+	struct acpi_namespace_node      *child_node = NULL;
+	u32                             level = 1;
 
 
-	FUNCTION_TRACE ("Ns_delete_namespace_subtree");
+	ACPI_FUNCTION_TRACE ("ns_delete_namespace_subtree");
 
 
 	if (!parent_node) {
-		return_ACPI_STATUS (AE_OK);
+		return_VOID;
 	}
 
 	/*
@@ -383,7 +504,6 @@ acpi_ns_delete_namespace_subtree (
 				child_node    = 0;
 			}
 		}
-
 		else {
 			/*
 			 * No more children of this parent node.
@@ -403,17 +523,17 @@ acpi_ns_delete_namespace_subtree (
 
 			/* Move up the tree to the grandparent */
 
-			parent_node = acpi_ns_get_parent_object (parent_node);
+			parent_node = acpi_ns_get_parent_node (parent_node);
 		}
 	}
 
-	return_ACPI_STATUS (AE_OK);
+	return_VOID;
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_remove_reference
+ * FUNCTION:    acpi_ns_remove_reference
  *
  * PARAMETERS:  Node           - Named node whose reference count is to be
  *                               decremented
@@ -426,47 +546,50 @@ acpi_ns_delete_namespace_subtree (
  *
  ******************************************************************************/
 
-static void
+void
 acpi_ns_remove_reference (
-	acpi_namespace_node     *node)
+	struct acpi_namespace_node      *node)
 {
-	acpi_namespace_node     *next_node;
+	struct acpi_namespace_node      *parent_node;
+	struct acpi_namespace_node      *this_node;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	/*
 	 * Decrement the reference count(s) of this node and all
 	 * nodes up to the root,  Delete anything with zero remaining references.
 	 */
-	next_node = node;
-	while (next_node) {
-		/* Decrement the reference count on this node*/
+	this_node = node;
+	while (this_node) {
+		/* Prepare to move up to parent */
+
+		parent_node = acpi_ns_get_parent_node (this_node);
+
+		/* Decrement the reference count on this node */
 
-		next_node->reference_count--;
+		this_node->reference_count--;
 
 		/* Delete the node if no more references */
 
-		if (!next_node->reference_count) {
+		if (!this_node->reference_count) {
 			/* Delete all children and delete the node */
 
-			acpi_ns_delete_children (next_node);
-			acpi_ns_delete_node (next_node);
+			acpi_ns_delete_children (this_node);
+			acpi_ns_delete_node (this_node);
 		}
 
-		/* Move up to parent */
-
-		next_node = acpi_ns_get_parent_object (next_node);
+		this_node = parent_node;
 	}
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_delete_namespace_by_owner
+ * FUNCTION:    acpi_ns_delete_namespace_by_owner
  *
- * PARAMETERS:  Owner_id    - All nodes with this owner will be deleted
+ * PARAMETERS:  owner_id    - All nodes with this owner will be deleted
  *
  * RETURN:      Status
  *
@@ -476,65 +599,71 @@ acpi_ns_remove_reference (
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ns_delete_namespace_by_owner (
-	u16                     owner_id)
+	u16                             owner_id)
 {
-	acpi_namespace_node     *child_node;
-	u32                     level;
-	acpi_namespace_node     *parent_node;
+	struct acpi_namespace_node      *child_node;
+	struct acpi_namespace_node      *deletion_node;
+	u32                             level;
+	struct acpi_namespace_node      *parent_node;
 
 
-	FUNCTION_TRACE ("Ns_delete_namespace_by_owner");
+	ACPI_FUNCTION_TRACE_U32 ("ns_delete_namespace_by_owner", owner_id);
 
 
-	parent_node = acpi_gbl_root_node;
-	child_node  = 0;
-	level       = 1;
+	parent_node   = acpi_gbl_root_node;
+	child_node    = NULL;
+	deletion_node = NULL;
+	level         = 1;
 
 	/*
 	 * Traverse the tree of nodes until we bubble back up
 	 * to where we started.
 	 */
 	while (level > 0) {
-		/* Get the next node in this scope (NULL if none) */
+		/*
+		 * Get the next child of this parent node. When child_node is NULL,
+		 * the first child of the parent is returned
+		 */
+		child_node = acpi_ns_get_next_node (ACPI_TYPE_ANY, parent_node, child_node);
+
+		if (deletion_node) {
+			acpi_ns_remove_reference (deletion_node);
+			deletion_node = NULL;
+		}
 
-		child_node = acpi_ns_get_next_node (ACPI_TYPE_ANY, parent_node,
-				 child_node);
 		if (child_node) {
 			if (child_node->owner_id == owner_id) {
-				/* Found a child node - detach any attached object */
+				/* Found a matching child node - detach any attached object */
 
 				acpi_ns_detach_object (child_node);
 			}
 
 			/* Check if this node has any children */
 
-			if (acpi_ns_get_next_node (ACPI_TYPE_ANY, child_node, 0)) {
+			if (acpi_ns_get_next_node (ACPI_TYPE_ANY, child_node, NULL)) {
 				/*
 				 * There is at least one child of this node,
 				 * visit the node
 				 */
 				level++;
 				parent_node   = child_node;
-				child_node    = 0;
+				child_node    = NULL;
 			}
-
 			else if (child_node->owner_id == owner_id) {
-				acpi_ns_remove_reference (child_node);
+				deletion_node = child_node;
 			}
 		}
-
 		else {
 			/*
 			 * No more children of this parent node.
 			 * Move up to the grandparent.
 			 */
 			level--;
-
 			if (level != 0) {
 				if (parent_node->owner_id == owner_id) {
-					acpi_ns_remove_reference (parent_node);
+					deletion_node = parent_node;
 				}
 			}
 
@@ -544,11 +673,11 @@ acpi_ns_delete_namespace_by_owner (
 
 			/* Move up the tree to the grandparent */
 
-			parent_node = acpi_ns_get_parent_object (parent_node);
+			parent_node = acpi_ns_get_parent_node (parent_node);
 		}
 	}
 
-	return_ACPI_STATUS (AE_OK);
+	return_VOID;
 }
 
 
diff -urNp linux-5400/drivers/acpi/namespace/nsdump.c linux-5410/drivers/acpi/namespace/nsdump.c
--- linux-5400/drivers/acpi/namespace/nsdump.c
+++ linux-5410/drivers/acpi/namespace/nsdump.c
@@ -1,45 +1,102 @@
 /******************************************************************************
  *
  * Module Name: nsdump - table dumping routines for debug
- *              $Revision: 105 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acinterp.h"
-#include "acnamesp.h"
-#include "actables.h"
-#include "acparser.h"
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acparser.h>
 
 
 #define _COMPONENT          ACPI_NAMESPACE
-	 MODULE_NAME         ("nsdump")
+	 ACPI_MODULE_NAME    ("nsdump")
 
+#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
 
-#if defined(ACPI_DEBUG) || defined(ENABLE_DEBUGGER)
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_dump_pathname
+ * FUNCTION:    acpi_ns_print_pathname
+ *
+ * PARAMETERS:  num_segment         - Number of ACPI name segments
+ *              Pathname            - The compressed (internal) path
+ *
+ * DESCRIPTION: Print an object's full namespace pathname
+ *
+ ******************************************************************************/
+
+void
+acpi_ns_print_pathname (
+	u32                             num_segments,
+	char                            *pathname)
+{
+	ACPI_FUNCTION_NAME ("ns_print_pathname");
+
+
+	if (!(acpi_dbg_level & ACPI_LV_NAMES) || !(acpi_dbg_layer & ACPI_NAMESPACE)) {
+		return;
+	}
+
+		/* Print the entire name */
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "["));
+
+	while (num_segments) {
+		acpi_os_printf ("%4.4s", pathname);
+		pathname += ACPI_NAME_SIZE;
+
+		num_segments--;
+		if (num_segments) {
+			acpi_os_printf (".");
+		}
+	}
+
+	acpi_os_printf ("]\n");
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_dump_pathname
  *
  * PARAMETERS:  Handle              - Object
  *              Msg                 - Prefix message
@@ -51,85 +108,65 @@
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ns_dump_pathname (
-	acpi_handle             handle,
-	NATIVE_CHAR             *msg,
-	u32                     level,
-	u32                     component)
+	acpi_handle                     handle,
+	char                            *msg,
+	u32                             level,
+	u32                             component)
 {
-	NATIVE_CHAR             *buffer;
-	u32                     length;
-
 
-	FUNCTION_TRACE ("Ns_dump_pathname");
+	ACPI_FUNCTION_TRACE ("ns_dump_pathname");
 
 
 	/* Do this only if the requested debug level and component are enabled */
 
 	if (!(acpi_dbg_level & level) || !(acpi_dbg_layer & component)) {
-		return_ACPI_STATUS (AE_OK);
-	}
-
-	buffer = ACPI_MEM_ALLOCATE (PATHNAME_MAX);
-	if (!buffer) {
-		return_ACPI_STATUS (AE_NO_MEMORY);
+		return_VOID;
 	}
 
 	/* Convert handle to a full pathname and print it (with supplied message) */
 
-	length = PATHNAME_MAX;
-	if (ACPI_SUCCESS (acpi_ns_handle_to_pathname (handle, &length, buffer))) {
-		acpi_os_printf ("%s %s (%p)\n", msg, buffer, handle);
-	}
-
-	ACPI_MEM_FREE (buffer);
-
-	return_ACPI_STATUS (AE_OK);
+	acpi_ns_print_node_pathname (handle, msg);
+	acpi_os_printf ("\n");
+	return_VOID;
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_dump_one_object
+ * FUNCTION:    acpi_ns_dump_one_object
  *
  * PARAMETERS:  Handle              - Node to be dumped
  *              Level               - Nesting level of the handle
- *              Context             - Passed into Walk_namespace
+ *              Context             - Passed into walk_namespace
  *
  * DESCRIPTION: Dump a single Node
- *              This procedure is a User_function called by Acpi_ns_walk_namespace.
+ *              This procedure is a user_function called by acpi_ns_walk_namespace.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ns_dump_one_object (
-	acpi_handle             obj_handle,
-	u32                     level,
-	void                    *context,
-	void                    **return_value)
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *context,
+	void                            **return_value)
 {
-	acpi_walk_info          *info = (acpi_walk_info *) context;
-	acpi_namespace_node     *this_node;
-	acpi_operand_object     *obj_desc = NULL;
-	acpi_object_type8       obj_type;
-	acpi_object_type8       type;
-	u32                     bytes_to_dump;
-	u32                     downstream_sibling_mask = 0;
-	u32                     level_tmp;
-	u32                     which_bit;
-	u32                     i;
-
+	struct acpi_walk_info           *info = (struct acpi_walk_info *) context;
+	struct acpi_namespace_node      *this_node;
+	union acpi_operand_object       *obj_desc = NULL;
+	acpi_object_type                obj_type;
+	acpi_object_type                type;
+	u32                             bytes_to_dump;
+	u32                             dbg_level;
+	u32                             i;
 
-	PROC_NAME ("Ns_dump_one_object");
 
+	ACPI_FUNCTION_NAME ("ns_dump_one_object");
 
-	this_node = acpi_ns_map_handle_to_node (obj_handle);
-
-	level_tmp   = level;
-	type        = this_node->type;
-	which_bit   = 1;
 
+	/* Is output enabled? */
 
 	if (!(acpi_dbg_level & info->debug_level)) {
 		return (AE_OK);
@@ -140,6 +177,9 @@ acpi_ns_dump_one_object (
 		return (AE_OK);
 	}
 
+	this_node = acpi_ns_map_handle_to_node (obj_handle);
+	type = this_node->type;
+
 	/* Check if the owner matches */
 
 	if ((info->owner_id != ACPI_UINT32_MAX) &&
@@ -147,68 +187,30 @@ acpi_ns_dump_one_object (
 		return (AE_OK);
 	}
 
-
 	/* Indent the object according to the level */
 
-	while (level_tmp--) {
-
-		/* Print appropriate characters to form tree structure */
-
-		if (level_tmp) {
-			if (downstream_sibling_mask & which_bit) {
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "|"));
-			}
-
-			else {
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " "));
-			}
-
-			which_bit <<= 1;
-		}
-
-		else {
-			if (acpi_ns_exist_downstream_sibling (this_node + 1)) {
-				downstream_sibling_mask |= (1 << (level - 1));
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "+"));
-			}
-
-			else {
-				downstream_sibling_mask &= ACPI_UINT32_MAX ^ (1 << (level - 1));
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "+"));
-			}
-
-			if (this_node->child == NULL) {
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "-"));
-			}
-
-			else if (acpi_ns_exist_downstream_sibling (this_node->child)) {
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "+"));
-			}
-
-			else {
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "-"));
-			}
-		}
-	}
-
+	acpi_os_printf ("%2d%*s", (u32) level - 1, (int) level * 2, " ");
 
-	/* Check the integrity of our data */
+	/* Check the node type and name */
 
-	if (type > INTERNAL_TYPE_MAX) {
-		type = INTERNAL_TYPE_DEF_ANY;                                /* prints as *ERROR* */
+	if (type > ACPI_TYPE_LOCAL_MAX) {
+		ACPI_REPORT_WARNING (("Invalid ACPI Type %08X\n", type));
 	}
 
-	if (!acpi_ut_valid_acpi_name (this_node->name)) {
-		REPORT_WARNING (("Invalid ACPI Name %08X\n", this_node->name));
+	if (!acpi_ut_valid_acpi_name (this_node->name.integer)) {
+		ACPI_REPORT_WARNING (("Invalid ACPI Name %08X\n", this_node->name.integer));
 	}
 
 	/*
 	 * Now we can print out the pertinent information
 	 */
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " %4.4s %-12s %p",
-			(char*)&this_node->name, acpi_ut_get_type_name (type), this_node));
+	acpi_os_printf ("%4.4s %-12s %p ",
+			this_node->name.ascii, acpi_ut_get_type_name (type), this_node);
 
-	obj_desc = this_node->object;
+	dbg_level = acpi_dbg_level;
+	acpi_dbg_level = 0;
+	obj_desc = acpi_ns_get_attached_object (this_node);
+	acpi_dbg_level = dbg_level;
 
 	switch (info->display_type) {
 	case ACPI_DISPLAY_SUMMARY:
@@ -216,110 +218,148 @@ acpi_ns_dump_one_object (
 		if (!obj_desc) {
 			/* No attached object, we are done */
 
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "\n"));
+			acpi_os_printf ("\n");
 			return (AE_OK);
 		}
 
-
 		switch (type) {
 		case ACPI_TYPE_PROCESSOR:
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " ID %d Addr %.4X Len %.4X\n",
+
+			acpi_os_printf ("ID %X Len %.4X Addr %p\n",
 					 obj_desc->processor.proc_id,
-					 obj_desc->processor.address,
-					 (unsigned)obj_desc->processor.length));
+					 obj_desc->processor.length,
+					 (char *) obj_desc->processor.address);
 			break;
 
+
 		case ACPI_TYPE_DEVICE:
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " Notification object: %p", obj_desc));
+
+			acpi_os_printf ("Notify object: %p", obj_desc);
 			break;
 
+
 		case ACPI_TYPE_METHOD:
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " Args %d Len %.4X Aml %p \n",
-					 obj_desc->method.param_count,
+
+			acpi_os_printf ("Args %X Len %.4X Aml %p\n",
+					 (u32) obj_desc->method.param_count,
 					 obj_desc->method.aml_length,
-					 obj_desc->method.aml_start));
+					 obj_desc->method.aml_start);
 			break;
 
+
 		case ACPI_TYPE_INTEGER:
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " = %8.8X%8.8X\n",
-					 HIDWORD (obj_desc->integer.value),
-					 LODWORD (obj_desc->integer.value)));
+
+			acpi_os_printf ("= %8.8X%8.8X\n",
+					 ACPI_HIDWORD (obj_desc->integer.value),
+					 ACPI_LODWORD (obj_desc->integer.value));
 			break;
 
+
 		case ACPI_TYPE_PACKAGE:
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " Elements %.2X\n",
-					 obj_desc->package.count));
+
+			if (obj_desc->common.flags & AOPOBJ_DATA_VALID) {
+				acpi_os_printf ("Elements %.2X\n",
+						 obj_desc->package.count);
+			}
+			else {
+				acpi_os_printf ("[Length not yet evaluated]\n");
+			}
 			break;
 
-		case ACPI_TYPE_BUFFER:
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " Len %.2X",
-					 obj_desc->buffer.length));
 
-			/* Dump some of the buffer */
+		case ACPI_TYPE_BUFFER:
 
-			if (obj_desc->buffer.length > 0) {
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " ="));
-				for (i = 0; (i < obj_desc->buffer.length && i < 12); i++) {
-					ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " %.2X",
-							obj_desc->buffer.pointer[i]));
+			if (obj_desc->common.flags & AOPOBJ_DATA_VALID) {
+				acpi_os_printf ("Len %.2X",
+						 obj_desc->buffer.length);
+
+				/* Dump some of the buffer */
+
+				if (obj_desc->buffer.length > 0) {
+					acpi_os_printf (" =");
+					for (i = 0; (i < obj_desc->buffer.length && i < 12); i++) {
+						acpi_os_printf (" %.2hX", obj_desc->buffer.pointer[i]);
+					}
 				}
+				acpi_os_printf ("\n");
+			}
+			else {
+				acpi_os_printf ("[Length not yet evaluated]\n");
 			}
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "\n"));
 			break;
 
+
 		case ACPI_TYPE_STRING:
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " Len %.2X",
-					 obj_desc->string.length));
 
-			if (obj_desc->string.length > 0) {
-				 ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " = \"%.32s\"...",
-						 obj_desc->string.pointer));
-			}
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "\n"));
+			acpi_os_printf ("Len %.2X ", obj_desc->string.length);
+			acpi_ut_print_string (obj_desc->string.pointer, 32);
+			acpi_os_printf ("\n");
 			break;
 
+
 		case ACPI_TYPE_REGION:
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " [%s]",
-					 acpi_ut_get_region_name (obj_desc->region.space_id)));
+
+			acpi_os_printf ("[%s]", acpi_ut_get_region_name (obj_desc->region.space_id));
 			if (obj_desc->region.flags & AOPOBJ_DATA_VALID) {
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " Addr %8.8X%8.8X Len %.4X\n",
-						 HIDWORD(obj_desc->region.address),
-						 LODWORD(obj_desc->region.address),
-						 obj_desc->region.length));
+				acpi_os_printf (" Addr %8.8X%8.8X Len %.4X\n",
+						 ACPI_HIDWORD (obj_desc->region.address),
+						 ACPI_LODWORD (obj_desc->region.address),
+						 obj_desc->region.length);
 			}
 			else {
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " [Address/Length not evaluated]\n"));
+				acpi_os_printf (" [Address/Length not yet evaluated]\n");
 			}
 			break;
 
-		case INTERNAL_TYPE_REFERENCE:
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " [%s]\n",
-					 acpi_ps_get_opcode_name (obj_desc->reference.opcode)));
+
+		case ACPI_TYPE_LOCAL_REFERENCE:
+
+			acpi_os_printf ("[%s]\n",
+					acpi_ps_get_opcode_name (obj_desc->reference.opcode));
 			break;
 
+
 		case ACPI_TYPE_BUFFER_FIELD:
 
-			/* TBD: print Buffer name when we can easily get it */
+			if (obj_desc->buffer_field.buffer_obj &&
+				obj_desc->buffer_field.buffer_obj->buffer.node) {
+				acpi_os_printf ("Buf [%4.4s]",
+						obj_desc->buffer_field.buffer_obj->buffer.node->name.ascii);
+			}
 			break;
 
-		case INTERNAL_TYPE_REGION_FIELD:
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " Rgn [%4.4s]",
-					 (char *) &obj_desc->common_field.region_obj->region.node->name));
+
+		case ACPI_TYPE_LOCAL_REGION_FIELD:
+
+			acpi_os_printf ("Rgn [%4.4s]",
+					obj_desc->common_field.region_obj->region.node->name.ascii);
 			break;
 
-		case INTERNAL_TYPE_BANK_FIELD:
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " Rgn [%4.4s]",
-					 (char *) &obj_desc->common_field.region_obj->region.node->name));
+
+		case ACPI_TYPE_LOCAL_BANK_FIELD:
+
+			acpi_os_printf ("Rgn [%4.4s] Bnk [%4.4s]",
+					obj_desc->common_field.region_obj->region.node->name.ascii,
+					obj_desc->bank_field.bank_obj->common_field.node->name.ascii);
 			break;
 
-		case INTERNAL_TYPE_INDEX_FIELD:
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " Rgn [%4.4s]",
-					 (char *) &obj_desc->index_field.index_obj->common_field.region_obj->region.node->name));
+
+		case ACPI_TYPE_LOCAL_INDEX_FIELD:
+
+			acpi_os_printf ("Idx [%4.4s] Dat [%4.4s]",
+					obj_desc->index_field.index_obj->common_field.node->name.ascii,
+					obj_desc->index_field.data_obj->common_field.node->name.ascii);
+			break;
+
+
+		case ACPI_TYPE_LOCAL_ALIAS:
+
+			acpi_os_printf ("Target %4.4s (%p)\n", ((struct acpi_namespace_node *) obj_desc)->name.ascii, obj_desc);
 			break;
 
 		default:
 
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " Object %p\n", obj_desc));
+			acpi_os_printf ("Object %p\n", obj_desc);
 			break;
 		}
 
@@ -327,77 +367,74 @@ acpi_ns_dump_one_object (
 
 		switch (type) {
 		case ACPI_TYPE_BUFFER_FIELD:
-		case INTERNAL_TYPE_REGION_FIELD:
-		case INTERNAL_TYPE_BANK_FIELD:
-		case INTERNAL_TYPE_INDEX_FIELD:
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " Off %.2X Len %.2X Acc %.2d\n",
-					 (obj_desc->common_field.base_byte_offset * 8) + obj_desc->common_field.start_field_bit_offset,
-					 obj_desc->common_field.bit_length,
-					 obj_desc->common_field.access_bit_width));
+		case ACPI_TYPE_LOCAL_REGION_FIELD:
+		case ACPI_TYPE_LOCAL_BANK_FIELD:
+		case ACPI_TYPE_LOCAL_INDEX_FIELD:
+
+			acpi_os_printf (" Off %.2X Len %.2X Acc %.2hd\n",
+					(obj_desc->common_field.base_byte_offset * 8)
+						+ obj_desc->common_field.start_field_bit_offset,
+					obj_desc->common_field.bit_length,
+					obj_desc->common_field.access_byte_width);
 			break;
-		}
 
+		default:
+			break;
+		}
 		break;
 
 
 	case ACPI_DISPLAY_OBJECTS:
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "%p O:%p",
-				this_node, obj_desc));
-
+		acpi_os_printf ("O:%p", obj_desc);
 		if (!obj_desc) {
 			/* No attached object, we are done */
 
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "\n"));
+			acpi_os_printf ("\n");
 			return (AE_OK);
 		}
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "(R%d)",
-				obj_desc->common.reference_count));
+		acpi_os_printf ("(R%d)",
+				obj_desc->common.reference_count);
 
 		switch (type) {
-
 		case ACPI_TYPE_METHOD:
 
 			/* Name is a Method and its AML offset/length are set */
 
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " M:%p-%X\n",
-					 obj_desc->method.aml_start,
-					 obj_desc->method.aml_length));
-
+			acpi_os_printf (" M:%p-%X\n", obj_desc->method.aml_start,
+					  obj_desc->method.aml_length);
 			break;
 
-
 		case ACPI_TYPE_INTEGER:
 
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " N:%X%X\n",
-					 HIDWORD(obj_desc->integer.value),
-					 LODWORD(obj_desc->integer.value)));
+			acpi_os_printf (" N:%X%X\n", ACPI_HIDWORD(obj_desc->integer.value),
+					 ACPI_LODWORD(obj_desc->integer.value));
 			break;
 
-
 		case ACPI_TYPE_STRING:
 
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " S:%p-%X\n",
-					 obj_desc->string.pointer,
-					 obj_desc->string.length));
+			acpi_os_printf (" S:%p-%X\n", obj_desc->string.pointer,
+					  obj_desc->string.length);
 			break;
 
-
 		case ACPI_TYPE_BUFFER:
 
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " B:%p-%X\n",
-					 obj_desc->buffer.pointer,
-					 obj_desc->buffer.length));
+			acpi_os_printf (" B:%p-%X\n", obj_desc->buffer.pointer,
+					  obj_desc->buffer.length);
 			break;
 
-
 		default:
 
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "\n"));
+			acpi_os_printf ("\n");
 			break;
 		}
 		break;
+
+
+	default:
+		acpi_os_printf ("\n");
+		break;
 	}
 
 	/* If debug turned off, done */
@@ -409,48 +446,55 @@ acpi_ns_dump_one_object (
 
 	/* If there is an attached object, display it */
 
-	obj_desc = this_node->object;
+	dbg_level    = acpi_dbg_level;
+	acpi_dbg_level = 0;
+	obj_desc     = acpi_ns_get_attached_object (this_node);
+	acpi_dbg_level = dbg_level;
 
 	/* Dump attached objects */
 
 	while (obj_desc) {
-		obj_type = INTERNAL_TYPE_INVALID;
+		obj_type = ACPI_TYPE_INVALID;
+		acpi_os_printf ("      Attached Object %p: ", obj_desc);
 
 		/* Decode the type of attached object and dump the contents */
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "        Attached Object %p: ", obj_desc));
+		switch (ACPI_GET_DESCRIPTOR_TYPE (obj_desc)) {
+		case ACPI_DESC_TYPE_NAMED:
 
-		if (VALID_DESCRIPTOR_TYPE (obj_desc, ACPI_DESC_TYPE_NAMED)) {
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "(Ptr to Node)\n"));
-			bytes_to_dump = sizeof (acpi_namespace_node);
-		}
+			acpi_os_printf ("(Ptr to Node)\n");
+			bytes_to_dump = sizeof (struct acpi_namespace_node);
+			break;
 
 
-		else if (VALID_DESCRIPTOR_TYPE (obj_desc, ACPI_DESC_TYPE_INTERNAL)) {
-			obj_type = obj_desc->common.type;
+		case ACPI_DESC_TYPE_OPERAND:
 
-			if (obj_type > INTERNAL_TYPE_MAX) {
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "(Ptr to ACPI Object type %X [UNKNOWN])\n", obj_type));
+			obj_type = ACPI_GET_OBJECT_TYPE (obj_desc);
+
+			if (obj_type > ACPI_TYPE_LOCAL_MAX) {
+				acpi_os_printf ("(Ptr to ACPI Object type %X [UNKNOWN])\n", obj_type);
 				bytes_to_dump = 32;
 			}
-
 			else {
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "(Ptr to ACPI Object type %2.2X [%s])\n",
-						   obj_type, acpi_ut_get_type_name (obj_type)));
-				bytes_to_dump = sizeof (acpi_operand_object);
+				acpi_os_printf ("(Ptr to ACPI Object type %s, %X)\n",
+						   acpi_ut_get_type_name (obj_type), obj_type);
+				bytes_to_dump = sizeof (union acpi_operand_object);
 			}
-		}
+			break;
+
+
+		default:
 
-		else {
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "(String or Buffer - not descriptor)\n"));
+			acpi_os_printf ("(String or Buffer ptr - not an object descriptor)\n");
 			bytes_to_dump = 16;
+			break;
 		}
 
-		DUMP_BUFFER (obj_desc, bytes_to_dump);
+		ACPI_DUMP_BUFFER (obj_desc, bytes_to_dump);
 
 		/* If value is NOT an internal object, we are done */
 
-		if (VALID_DESCRIPTOR_TYPE (obj_desc, ACPI_DESC_TYPE_NAMED)) {
+		if (ACPI_GET_DESCRIPTOR_TYPE (obj_desc) != ACPI_DESC_TYPE_OPERAND) {
 			goto cleanup;
 		}
 
@@ -459,78 +503,78 @@ acpi_ns_dump_one_object (
 		 */
 		switch (obj_type) {
 		case ACPI_TYPE_STRING:
-			obj_desc = (acpi_operand_object *) obj_desc->string.pointer;
+			obj_desc = (void *) obj_desc->string.pointer;
 			break;
 
 		case ACPI_TYPE_BUFFER:
-			obj_desc = (acpi_operand_object *) obj_desc->buffer.pointer;
+			obj_desc = (void *) obj_desc->buffer.pointer;
 			break;
 
 		case ACPI_TYPE_BUFFER_FIELD:
-			obj_desc = (acpi_operand_object *) obj_desc->buffer_field.buffer_obj;
+			obj_desc = (union acpi_operand_object *) obj_desc->buffer_field.buffer_obj;
 			break;
 
 		case ACPI_TYPE_PACKAGE:
-			obj_desc = (acpi_operand_object *) obj_desc->package.elements;
+			obj_desc = (void *) obj_desc->package.elements;
 			break;
 
 		case ACPI_TYPE_METHOD:
-			obj_desc = (acpi_operand_object *) obj_desc->method.aml_start;
+			obj_desc = (void *) obj_desc->method.aml_start;
 			break;
 
-		case INTERNAL_TYPE_REGION_FIELD:
-			obj_desc = (acpi_operand_object *) obj_desc->field.region_obj;
+		case ACPI_TYPE_LOCAL_REGION_FIELD:
+			obj_desc = (void *) obj_desc->field.region_obj;
 			break;
 
-		case INTERNAL_TYPE_BANK_FIELD:
-			obj_desc = (acpi_operand_object *) obj_desc->bank_field.region_obj;
+		case ACPI_TYPE_LOCAL_BANK_FIELD:
+			obj_desc = (void *) obj_desc->bank_field.region_obj;
 			break;
 
-		case INTERNAL_TYPE_INDEX_FIELD:
-			obj_desc = (acpi_operand_object *) obj_desc->index_field.index_obj;
+		case ACPI_TYPE_LOCAL_INDEX_FIELD:
+			obj_desc = (void *) obj_desc->index_field.index_obj;
 			break;
 
-	   default:
+		default:
 			goto cleanup;
 		}
 
-		obj_type = INTERNAL_TYPE_INVALID;    /* Terminate loop after next pass */
+		obj_type = ACPI_TYPE_INVALID;  /* Terminate loop after next pass */
 	}
 
 cleanup:
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "\n"));
+	acpi_os_printf ("\n");
 	return (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_dump_objects
+ * FUNCTION:    acpi_ns_dump_objects
  *
  * PARAMETERS:  Type                - Object type to be dumped
- *              Max_depth           - Maximum depth of dump.  Use ACPI_UINT32_MAX
+ *              max_depth           - Maximum depth of dump.  Use ACPI_UINT32_MAX
  *                                    for an effectively unlimited depth.
- *              Owner_id            - Dump only objects owned by this ID.  Use
+ *              owner_id            - Dump only objects owned by this ID.  Use
  *                                    ACPI_UINT32_MAX to match all owners.
- *              Start_handle        - Where in namespace to start/end search
+ *              start_handle        - Where in namespace to start/end search
  *
  * DESCRIPTION: Dump typed objects within the loaded namespace.
- *              Uses Acpi_ns_walk_namespace in conjunction with Acpi_ns_dump_one_object.
+ *              Uses acpi_ns_walk_namespace in conjunction with acpi_ns_dump_one_object.
  *
  ******************************************************************************/
 
 void
 acpi_ns_dump_objects (
-	acpi_object_type8       type,
-	u8                      display_type,
-	u32                     max_depth,
-	u32                     owner_id,
-	acpi_handle             start_handle)
+	acpi_object_type                type,
+	u8                              display_type,
+	u32                             max_depth,
+	u32                             owner_id,
+	acpi_handle                     start_handle)
 {
-	acpi_walk_info          info;
+	struct acpi_walk_info           info;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	info.debug_level = ACPI_LV_TABLES;
@@ -538,97 +582,19 @@ acpi_ns_dump_objects (
 	info.display_type = display_type;
 
 
-	acpi_ns_walk_namespace (type, start_handle, max_depth, NS_WALK_NO_UNLOCK, acpi_ns_dump_one_object,
-			   (void *) &info, NULL);
-}
-
-
-#ifndef _ACPI_ASL_COMPILER
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ns_dump_one_device
- *
- * PARAMETERS:  Handle              - Node to be dumped
- *              Level               - Nesting level of the handle
- *              Context             - Passed into Walk_namespace
- *
- * DESCRIPTION: Dump a single Node that represents a device
- *              This procedure is a User_function called by Acpi_ns_walk_namespace.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ns_dump_one_device (
-	acpi_handle             obj_handle,
-	u32                     level,
-	void                    *context,
-	void                    **return_value)
-{
-	acpi_device_info        info;
-	acpi_status             status;
-	u32                     i;
-
-
-	PROC_NAME ("Ns_dump_one_device");
-
-
-	status = acpi_ns_dump_one_object (obj_handle, level, context, return_value);
-
-	status = acpi_get_object_info (obj_handle, &info);
-	if (ACPI_SUCCESS (status)) {
-		for (i = 0; i < level; i++) {
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " "));
-		}
-
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "    HID: %s, ADR: %8.8X%8.8X, Status: %x\n",
-				  info.hardware_id, HIDWORD(info.address), LODWORD(info.address), info.current_status));
-	}
-
-	return (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ns_dump_root_devices
- *
- * PARAMETERS:  None
- *
- * DESCRIPTION: Dump all objects of type "device"
- *
- ******************************************************************************/
-
-void
-acpi_ns_dump_root_devices (void)
-{
-	acpi_handle             sys_bus_handle;
-
-
-	PROC_NAME ("Ns_dump_root_devices");
-
-
-	/* Only dump the table if tracing is enabled */
-
-	if (!(ACPI_LV_TABLES & acpi_dbg_level)) {
-		return;
-	}
-
-	acpi_get_handle (0, NS_SYSTEM_BUS, &sys_bus_handle);
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_TABLES, "Display of all devices in the namespace:\n"));
-	acpi_ns_walk_namespace (ACPI_TYPE_DEVICE, sys_bus_handle, ACPI_UINT32_MAX, NS_WALK_NO_UNLOCK,
-			   acpi_ns_dump_one_device, NULL, NULL);
+	(void) acpi_ns_walk_namespace (type, start_handle, max_depth,
+			 ACPI_NS_WALK_NO_UNLOCK, acpi_ns_dump_one_object,
+			 (void *) &info, NULL);
 }
 
-#endif
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_dump_tables
+ * FUNCTION:    acpi_ns_dump_tables
  *
- * PARAMETERS:  Search_base         - Root of subtree to be dumped, or
+ * PARAMETERS:  search_base         - Root of subtree to be dumped, or
  *                                    NS_ALL to dump the entire namespace
- *              Max_depth           - Maximum depth of dump.  Use INT_MAX
+ *              max_depth           - Maximum depth of dump.  Use INT_MAX
  *                                    for an effectively unlimited depth.
  *
  * DESCRIPTION: Dump the name space, or a portion of it.
@@ -637,13 +603,13 @@ acpi_ns_dump_root_devices (void)
 
 void
 acpi_ns_dump_tables (
-	acpi_handle             search_base,
-	u32                     max_depth)
+	acpi_handle                     search_base,
+	u32                             max_depth)
 {
-	acpi_handle             search_handle = search_base;
+	acpi_handle                     search_handle = search_base;
 
 
-	FUNCTION_TRACE ("Ns_dump_tables");
+	ACPI_FUNCTION_TRACE ("ns_dump_tables");
 
 
 	if (!acpi_gbl_root_node) {
@@ -651,11 +617,11 @@ acpi_ns_dump_tables (
 		 * If the name space has not been initialized,
 		 * there is nothing to dump.
 		 */
-		ACPI_DEBUG_PRINT ((ACPI_DB_TABLES, "name space not initialized!\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_TABLES, "namespace not initialized!\n"));
 		return_VOID;
 	}
 
-	if (NS_ALL == search_base) {
+	if (ACPI_NS_ALL == search_base) {
 		/*  entire namespace    */
 
 		search_handle = acpi_gbl_root_node;
@@ -671,10 +637,10 @@ acpi_ns_dump_tables (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_dump_entry
+ * FUNCTION:    acpi_ns_dump_entry
  *
  * PARAMETERS:  Handle              - Node to be dumped
- *              Debug_level         - Output level
+ *              debug_level         - Output level
  *
  * DESCRIPTION: Dump a single Node
  *
@@ -682,19 +648,20 @@ acpi_ns_dump_tables (
 
 void
 acpi_ns_dump_entry (
-	acpi_handle             handle,
-	u32                     debug_level)
+	acpi_handle                     handle,
+	u32                             debug_level)
 {
-	acpi_walk_info          info;
+	struct acpi_walk_info           info;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	info.debug_level = debug_level;
 	info.owner_id = ACPI_UINT32_MAX;
+	info.display_type = ACPI_DISPLAY_SUMMARY;
 
-	acpi_ns_dump_one_object (handle, 1, &info, NULL);
+	(void) acpi_ns_dump_one_object (handle, 1, &info, NULL);
 }
 
 #endif
diff -urNp linux-5400/drivers/acpi/namespace/nsdumpdv.c linux-5410/drivers/acpi/namespace/nsdumpdv.c
--- linux-5400/drivers/acpi/namespace/nsdumpdv.c
+++ linux-5410/drivers/acpi/namespace/nsdumpdv.c
@@ -0,0 +1,145 @@
+/******************************************************************************
+ *
+ * Module Name: nsdump - table dumping routines for debug
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
+
+
+#define _COMPONENT          ACPI_NAMESPACE
+	 ACPI_MODULE_NAME    ("nsdumpdv")
+
+
+#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_dump_one_device
+ *
+ * PARAMETERS:  Handle              - Node to be dumped
+ *              Level               - Nesting level of the handle
+ *              Context             - Passed into walk_namespace
+ *
+ * DESCRIPTION: Dump a single Node that represents a device
+ *              This procedure is a user_function called by acpi_ns_walk_namespace.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_dump_one_device (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *context,
+	void                            **return_value)
+{
+	struct acpi_buffer              buffer;
+	struct acpi_device_info         *info;
+	acpi_status                     status;
+	u32                             i;
+
+
+	ACPI_FUNCTION_NAME ("ns_dump_one_device");
+
+
+	status = acpi_ns_dump_one_object (obj_handle, level, context, return_value);
+
+	buffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;
+	status = acpi_get_object_info (obj_handle, &buffer);
+	if (ACPI_SUCCESS (status)) {
+		info = buffer.pointer;
+		for (i = 0; i < level; i++) {
+			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " "));
+		}
+
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "    HID: %s, ADR: %8.8X%8.8X, Status: %X\n",
+				  info->hardware_id.value,
+				  ACPI_HIDWORD (info->address), ACPI_LODWORD (info->address),
+				  info->current_status));
+		ACPI_MEM_FREE (info);
+	}
+
+	return (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_dump_root_devices
+ *
+ * PARAMETERS:  None
+ *
+ * DESCRIPTION: Dump all objects of type "device"
+ *
+ ******************************************************************************/
+
+void
+acpi_ns_dump_root_devices (void)
+{
+	acpi_handle                     sys_bus_handle;
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_NAME ("ns_dump_root_devices");
+
+
+	/* Only dump the table if tracing is enabled */
+
+	if (!(ACPI_LV_TABLES & acpi_dbg_level)) {
+		return;
+	}
+
+	status = acpi_get_handle (0, ACPI_NS_SYSTEM_BUS, &sys_bus_handle);
+	if (ACPI_FAILURE (status)) {
+		return;
+	}
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_TABLES, "Display of all devices in the namespace:\n"));
+
+	status = acpi_ns_walk_namespace (ACPI_TYPE_DEVICE, sys_bus_handle,
+			 ACPI_UINT32_MAX, ACPI_NS_WALK_NO_UNLOCK,
+			 acpi_ns_dump_one_device, NULL, NULL);
+}
+
+#endif
+
+
diff -urNp linux-5400/drivers/acpi/namespace/nseval.c linux-5410/drivers/acpi/namespace/nseval.c
--- linux-5400/drivers/acpi/namespace/nseval.c
+++ linux-5410/drivers/acpi/namespace/nseval.c
@@ -2,51 +2,68 @@
  *
  * Module Name: nseval - Object evaluation interfaces -- includes control
  *                       method lookup and execution.
- *              $Revision: 102 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "amlcode.h"
-#include "acparser.h"
-#include "acinterp.h"
-#include "acnamesp.h"
+#include <acpi/acpi.h>
+#include <acpi/acparser.h>
+#include <acpi/acinterp.h>
+#include <acpi/acnamesp.h>
 
 
 #define _COMPONENT          ACPI_NAMESPACE
-	 MODULE_NAME         ("nseval")
+	 ACPI_MODULE_NAME    ("nseval")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_evaluate_relative
+ * FUNCTION:    acpi_ns_evaluate_relative
  *
  * PARAMETERS:  Handle              - The relative containing object
- *              *Pathname           - Name of method to execute, If NULL, the
+ *              Pathname            - Name of method to execute, If NULL, the
  *                                    handle is the object to execute
- *              **Params            - List of parameters to pass to the method,
+ *              Params              - List of parameters to pass to the method,
  *                                    terminated by NULL.  Params itself may be
  *                                    NULL if no parameters are being passed.
- *              *Return_object      - Where to put method's return value (if
+ *              return_object       - Where to put method's return value (if
  *                                    any).  If NULL, no value is returned.
  *
  * RETURN:      Status
@@ -60,19 +77,19 @@
 
 acpi_status
 acpi_ns_evaluate_relative (
-	acpi_namespace_node     *handle,
-	NATIVE_CHAR             *pathname,
-	acpi_operand_object     **params,
-	acpi_operand_object     **return_object)
+	struct acpi_namespace_node      *handle,
+	char                            *pathname,
+	union acpi_operand_object       **params,
+	union acpi_operand_object       **return_object)
 {
-	acpi_namespace_node     *prefix_node;
-	acpi_status             status;
-	acpi_namespace_node     *node = NULL;
-	NATIVE_CHAR             *internal_path = NULL;
-	acpi_generic_state      scope_info;
+	struct acpi_namespace_node      *prefix_node;
+	acpi_status                     status;
+	struct acpi_namespace_node      *node = NULL;
+	char                            *internal_path = NULL;
+	union acpi_generic_state        scope_info;
 
 
-	FUNCTION_TRACE ("Ns_evaluate_relative");
+	ACPI_FUNCTION_TRACE ("ns_evaluate_relative");
 
 
 	/*
@@ -91,11 +108,14 @@ acpi_ns_evaluate_relative (
 
 	/* Get the prefix handle and Node */
 
-	acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	prefix_node = acpi_ns_map_handle_to_node (handle);
 	if (!prefix_node) {
-		acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+		(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 		status = AE_BAD_PARAMETER;
 		goto cleanup;
 	}
@@ -104,13 +124,13 @@ acpi_ns_evaluate_relative (
 
 	scope_info.scope.node = prefix_node;
 	status = acpi_ns_lookup (&scope_info, internal_path, ACPI_TYPE_ANY,
-			 IMODE_EXECUTE, NS_NO_UPSEARCH, NULL,
+			 ACPI_IMODE_EXECUTE, ACPI_NS_NO_UPSEARCH, NULL,
 			 &node);
 
-	acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 
 	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Object [%s] not found [%s]\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "Object [%s] not found [%s]\n",
 			pathname, acpi_format_exception (status)));
 		goto cleanup;
 	}
@@ -119,12 +139,12 @@ acpi_ns_evaluate_relative (
 	 * Now that we have a handle to the object, we can attempt
 	 * to evaluate it.
 	 */
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "%s [%p] Value %p\n",
-		pathname, node, node->object));
+	ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "%s [%p] Value %p\n",
+		pathname, node, acpi_ns_get_attached_object (node)));
 
 	status = acpi_ns_evaluate_by_handle (node, params, return_object);
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "*** Completed eval of object %s ***\n",
+	ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "*** Completed eval of object %s ***\n",
 		pathname));
 
 cleanup:
@@ -136,12 +156,12 @@ cleanup:
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_evaluate_by_name
+ * FUNCTION:    acpi_ns_evaluate_by_name
  *
  * PARAMETERS:  Pathname            - Fully qualified pathname to the object
- *              *Return_object      - Where to put method's return value (if
+ *              return_object       - Where to put method's return value (if
  *                                    any).  If NULL, no value is returned.
- *              **Params            - List of parameters to pass to the method,
+ *              Params              - List of parameters to pass to the method,
  *                                    terminated by NULL.  Params itself may be
  *                                    NULL if no parameters are being passed.
  *
@@ -156,16 +176,16 @@ cleanup:
 
 acpi_status
 acpi_ns_evaluate_by_name (
-	NATIVE_CHAR             *pathname,
-	acpi_operand_object     **params,
-	acpi_operand_object     **return_object)
+	char                            *pathname,
+	union acpi_operand_object       **params,
+	union acpi_operand_object       **return_object)
 {
-	acpi_status             status;
-	acpi_namespace_node     *node = NULL;
-	NATIVE_CHAR             *internal_path = NULL;
+	acpi_status                     status;
+	struct acpi_namespace_node      *node = NULL;
+	char                            *internal_path = NULL;
 
 
-	FUNCTION_TRACE ("Ns_evaluate_by_name");
+	ACPI_FUNCTION_TRACE ("ns_evaluate_by_name");
 
 
 	/* Build an internal name string for the method */
@@ -175,18 +195,21 @@ acpi_ns_evaluate_by_name (
 		return_ACPI_STATUS (status);
 	}
 
-	acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	/* Lookup the name in the namespace */
 
 	status = acpi_ns_lookup (NULL, internal_path, ACPI_TYPE_ANY,
-			 IMODE_EXECUTE, NS_NO_UPSEARCH, NULL,
+			 ACPI_IMODE_EXECUTE, ACPI_NS_NO_UPSEARCH, NULL,
 			 &node);
 
-	acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 
 	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Object at [%s] was not found, status=%.4X\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "Object at [%s] was not found, status=%.4X\n",
 			pathname, status));
 		goto cleanup;
 	}
@@ -195,12 +218,12 @@ acpi_ns_evaluate_by_name (
 	 * Now that we have a handle to the object, we can attempt
 	 * to evaluate it.
 	 */
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "%s [%p] Value %p\n",
-		pathname, node, node->object));
+	ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "%s [%p] Value %p\n",
+		pathname, node, acpi_ns_get_attached_object (node)));
 
 	status = acpi_ns_evaluate_by_handle (node, params, return_object);
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "*** Completed eval of object %s ***\n",
+	ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "*** Completed eval of object %s ***\n",
 		pathname));
 
 
@@ -218,13 +241,13 @@ cleanup:
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_evaluate_by_handle
+ * FUNCTION:    acpi_ns_evaluate_by_handle
  *
  * PARAMETERS:  Handle              - Method Node to execute
- *              **Params            - List of parameters to pass to the method,
+ *              Params              - List of parameters to pass to the method,
  *                                    terminated by NULL.  Params itself may be
  *                                    NULL if no parameters are being passed.
- *              *Return_object      - Where to put method's return value (if
+ *              return_object       - Where to put method's return value (if
  *                                    any).  If NULL, no value is returned.
  *
  * RETURN:      Status
@@ -237,16 +260,16 @@ cleanup:
 
 acpi_status
 acpi_ns_evaluate_by_handle (
-	acpi_namespace_node     *handle,
-	acpi_operand_object     **params,
-	acpi_operand_object     **return_object)
+	struct acpi_namespace_node      *handle,
+	union acpi_operand_object       **params,
+	union acpi_operand_object       **return_object)
 {
-	acpi_namespace_node     *node;
-	acpi_status             status;
-	acpi_operand_object     *local_return_object;
+	struct acpi_namespace_node      *node;
+	acpi_status                     status;
+	union acpi_operand_object       *local_return_object;
 
 
-	FUNCTION_TRACE ("Ns_evaluate_by_handle");
+	ACPI_FUNCTION_TRACE ("ns_evaluate_by_handle");
 
 
 	/* Check if namespace has been initialized */
@@ -269,15 +292,17 @@ acpi_ns_evaluate_by_handle (
 
 	/* Get the prefix handle and Node */
 
-	acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	node = acpi_ns_map_handle_to_node (handle);
 	if (!node) {
-		acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+		(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-
 	/*
 	 * Two major cases here:
 	 * 1) The object is an actual control method -- execute it.
@@ -285,7 +310,7 @@ acpi_ns_evaluate_by_handle (
 	 *      value
 	 *
 	 * In both cases, the namespace is unlocked by the
-	 *  Acpi_ns* procedure
+	 *  acpi_ns* procedure
 	 */
 	if (acpi_ns_get_type (node) == ACPI_TYPE_METHOD) {
 		/*
@@ -294,7 +319,6 @@ acpi_ns_evaluate_by_handle (
 		status = acpi_ns_execute_control_method (node, params,
 				 &local_return_object);
 	}
-
 	else {
 		/*
 		 * Case 2) Object is NOT a method, just return its
@@ -303,7 +327,6 @@ acpi_ns_evaluate_by_handle (
 		status = acpi_ns_get_object_value (node, &local_return_object);
 	}
 
-
 	/*
 	 * Check if there is a return value on the stack that must
 	 * be dealt with
@@ -323,16 +346,13 @@ acpi_ns_evaluate_by_handle (
 			*return_object = local_return_object;
 		}
 
+		/* Map AE_CTRL_RETURN_VALUE to AE_OK, we are done with it */
 
-		/* Map AE_RETURN_VALUE to AE_OK, we are done with it */
-
-		if (status == AE_CTRL_RETURN_VALUE) {
-			status = AE_OK;
-		}
+		status = AE_OK;
 	}
 
 	/*
-	 * Namespace was unlocked by the handling Acpi_ns* function,
+	 * Namespace was unlocked by the handling acpi_ns* function,
 	 * so we just return
 	 */
 	return_ACPI_STATUS (status);
@@ -341,13 +361,13 @@ acpi_ns_evaluate_by_handle (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_execute_control_method
+ * FUNCTION:    acpi_ns_execute_control_method
  *
- * PARAMETERS:  Method_node     - The object/method
- *              **Params            - List of parameters to pass to the method,
+ * PARAMETERS:  method_node         - The method to execute
+ *              Params              - List of parameters to pass to the method,
  *                                    terminated by NULL.  Params itself may be
  *                                    NULL if no parameters are being passed.
- *              **Return_obj_desc   - List of result objects to be returned
+ *              return_obj_desc     - List of result objects to be returned
  *                                    from the method.
  *
  * RETURN:      Status
@@ -360,15 +380,15 @@ acpi_ns_evaluate_by_handle (
 
 acpi_status
 acpi_ns_execute_control_method (
-	acpi_namespace_node     *method_node,
-	acpi_operand_object     **params,
-	acpi_operand_object     **return_obj_desc)
+	struct acpi_namespace_node      *method_node,
+	union acpi_operand_object       **params,
+	union acpi_operand_object       **return_obj_desc)
 {
-	acpi_status             status;
-	acpi_operand_object     *obj_desc;
+	acpi_status                     status;
+	union acpi_operand_object       *obj_desc;
 
 
-	FUNCTION_TRACE ("Ns_execute_control_method");
+	ACPI_FUNCTION_TRACE ("ns_execute_control_method");
 
 
 	/* Verify that there is a method associated with this object */
@@ -377,21 +397,16 @@ acpi_ns_execute_control_method (
 	if (!obj_desc) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No attached method object\n"));
 
-		acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+		(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 		return_ACPI_STATUS (AE_NULL_OBJECT);
 	}
 
+	ACPI_DUMP_PATHNAME (method_node, "Execute Method:",
+		ACPI_LV_INFO, _COMPONENT);
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Control method at Offset %p Length %x]\n",
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Method at AML address %p Length %X\n",
 		obj_desc->method.aml_start + 1, obj_desc->method.aml_length - 1));
 
-	DUMP_PATHNAME (method_node, "Ns_execute_control_method: Executing",
-		ACPI_LV_NAMES, _COMPONENT);
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "At offset %p\n",
-			obj_desc->method.aml_start + 1));
-
-
 	/*
 	 * Unlock the namespace before execution.  This allows namespace access
 	 * via the external Acpi* interfaces while a method is being executed.
@@ -399,7 +414,10 @@ acpi_ns_execute_control_method (
 	 * interpreter locks to ensure that no thread is using the portion of the
 	 * namespace that is being deleted.
 	 */
-	acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	status = acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	/*
 	 * Execute the method via the interpreter.  The interpreter is locked
@@ -419,129 +437,79 @@ acpi_ns_execute_control_method (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_get_object_value
+ * FUNCTION:    acpi_ns_get_object_value
  *
- * PARAMETERS:  Node         - The object
+ * PARAMETERS:  Node                - The object
+ *              return_obj_desc     - Where the objects value is returned
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Return the current value of the object
  *
- * MUTEX:       Assumes namespace is locked
+ * MUTEX:       Assumes namespace is locked, leaves namespace unlocked
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ns_get_object_value (
-	acpi_namespace_node     *node,
-	acpi_operand_object     **return_obj_desc)
+	struct acpi_namespace_node      *node,
+	union acpi_operand_object       **return_obj_desc)
 {
-	acpi_status             status = AE_OK;
-	acpi_operand_object     *obj_desc;
-	acpi_operand_object     *source_desc;
+	acpi_status                     status = AE_OK;
+	struct acpi_namespace_node      *resolved_node = node;
 
 
-	FUNCTION_TRACE ("Ns_get_object_value");
+	ACPI_FUNCTION_TRACE ("ns_get_object_value");
 
 
 	/*
-	 *  We take the value from certain objects directly
+	 * Objects require additional resolution steps (e.g., the
+	 * Node may be a field that must be read, etc.) -- we can't just grab
+	 * the object out of the node.
 	 */
-	if ((node->type == ACPI_TYPE_PROCESSOR) ||
-		(node->type == ACPI_TYPE_POWER)) {
-		/*
-		 *  Create a Reference object to contain the object
-		 */
-		obj_desc = acpi_ut_create_internal_object (node->type);
-		if (!obj_desc) {
-		   status = AE_NO_MEMORY;
-		   goto unlock_and_exit;
-		}
-
-		/*
-		 *  Get the attached object
-		 */
-		source_desc = acpi_ns_get_attached_object (node);
-		if (!source_desc) {
-			status = AE_NULL_OBJECT;
-			goto unlock_and_exit;
-		}
-
-		/*
-		 * Just copy from the original to the return object
-		 *
-		 * TBD: [Future] - need a low-level object copy that handles
-		 * the reference count automatically.  (Don't want to copy it)
-		 */
-		MEMCPY (obj_desc, source_desc, sizeof (acpi_operand_object));
-		obj_desc->common.reference_count = 1;
-		acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
-	}
-
 
 	/*
-	 * Other objects require a reference object wrapper which we
-	 * then attempt to resolve.
+	 * Use resolve_node_to_value() to get the associated value. This call
+	 * always deletes obj_desc (allocated above).
+	 *
+	 * NOTE: we can get away with passing in NULL for a walk state
+	 * because obj_desc is guaranteed to not be a reference to either
+	 * a method local or a method argument (because this interface can only be
+	 * called from the acpi_evaluate external interface, never called from
+	 * a running control method.)
+	 *
+	 * Even though we do not directly invoke the interpreter
+	 * for this, we must enter it because we could access an opregion.
+	 * The opregion access code assumes that the interpreter
+	 * is locked.
+	 *
+	 * We must release the namespace lock before entering the
+	 * intepreter.
 	 */
-	else {
-		/* Create an Reference object to contain the object */
-
-		obj_desc = acpi_ut_create_internal_object (INTERNAL_TYPE_REFERENCE);
-		if (!obj_desc) {
-		   status = AE_NO_MEMORY;
-		   goto unlock_and_exit;
-		}
-
-		/* Construct a descriptor pointing to the name */
-
-		obj_desc->reference.opcode = (u8) AML_NAME_OP;
-		obj_desc->reference.object = (void *) node;
+	status = acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
+	status = acpi_ex_enter_interpreter ();
+	if (ACPI_SUCCESS (status)) {
+		status = acpi_ex_resolve_node_to_value (&resolved_node, NULL);
 		/*
-		 * Use Resolve_to_value() to get the associated value. This call
-		 * always deletes Obj_desc (allocated above).
-		 *
-		 * NOTE: we can get away with passing in NULL for a walk state
-		 * because Obj_desc is guaranteed to not be a reference to either
-		 * a method local or a method argument
-		 *
-		 * Even though we do not directly invoke the interpreter
-		 * for this, we must enter it because we could access an opregion.
-		 * The opregion access code assumes that the interpreter
-		 * is locked.
-		 *
-		 * We must release the namespace lock before entering the
-		 * intepreter.
+		 * If acpi_ex_resolve_node_to_value() succeeded, the return value was
+		 * placed in resolved_node.
 		 */
-		acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
-		status = acpi_ex_enter_interpreter ();
-		if (ACPI_SUCCESS (status)) {
-			status = acpi_ex_resolve_to_value (&obj_desc, NULL);
+		acpi_ex_exit_interpreter ();
 
-			acpi_ex_exit_interpreter ();
+		if (ACPI_SUCCESS (status)) {
+			status = AE_CTRL_RETURN_VALUE;
+			*return_obj_desc = ACPI_CAST_PTR (union acpi_operand_object, resolved_node);
+			ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "Returning object %p [%s]\n",
+				*return_obj_desc, acpi_ut_get_object_type_name (*return_obj_desc)));
 		}
 	}
 
-	/*
-	 * If Acpi_ex_resolve_to_value() succeeded, the return value was
-	 * placed in Obj_desc.
-	 */
-	if (ACPI_SUCCESS (status)) {
-		status = AE_CTRL_RETURN_VALUE;
-
-		*return_obj_desc = obj_desc;
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Returning obj %p\n", *return_obj_desc));
-	}
-
 	/* Namespace is unlocked */
 
 	return_ACPI_STATUS (status);
-
-
-unlock_and_exit:
-
-	/* Unlock the namespace */
-
-	acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
-	return_ACPI_STATUS (status);
 }
+
diff -urNp linux-5400/drivers/acpi/namespace/nsinit.c linux-5410/drivers/acpi/namespace/nsinit.c
--- linux-5400/drivers/acpi/namespace/nsinit.c
+++ linux-5410/drivers/acpi/namespace/nsinit.c
@@ -1,41 +1,59 @@
 /******************************************************************************
  *
  * Module Name: nsinit - namespace initialization
- *              $Revision: 33 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acnamesp.h"
-#include "acdispat.h"
-#include "acinterp.h"
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acdispat.h>
+#include <acpi/acinterp.h>
 
 #define _COMPONENT          ACPI_NAMESPACE
-	 MODULE_NAME         ("nsinit")
+	 ACPI_MODULE_NAME    ("nsinit")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_initialize_objects
+ * FUNCTION:    acpi_ns_initialize_objects
  *
  * PARAMETERS:  None
  *
@@ -50,24 +68,20 @@ acpi_status
 acpi_ns_initialize_objects (
 	void)
 {
-	acpi_status             status;
-	acpi_init_walk_info     info;
+	acpi_status                     status;
+	struct acpi_init_walk_info      info;
 
 
-	FUNCTION_TRACE ("Ns_initialize_objects");
+	ACPI_FUNCTION_TRACE ("ns_initialize_objects");
 
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
 		"**** Starting initialization of namespace objects ****\n"));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK, "Completing Region and Field initialization:"));
+	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT, "Completing Region/Field/Buffer/Package initialization:"));
 
+	/* Set all init info to zero */
 
-	info.field_count = 0;
-	info.field_init = 0;
-	info.op_region_count = 0;
-	info.op_region_init = 0;
-	info.object_count = 0;
-
+	ACPI_MEMSET (&info, 0, sizeof (struct acpi_init_walk_info));
 
 	/* Walk entire namespace from the supplied root */
 
@@ -75,17 +89,21 @@ acpi_ns_initialize_objects (
 			  ACPI_UINT32_MAX, acpi_ns_init_one_object,
 			  &info, NULL);
 	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Walk_namespace failed! %x\n", status));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "walk_namespace failed! %s\n",
+			acpi_format_exception (status)));
 	}
 
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK,
-		"\n%d/%d Regions, %d/%d Fields initialized (%d nodes total)\n",
-		info.op_region_init, info.op_region_count, info.field_init,
-		info.field_count, info.object_count));
+	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT,
+		"\nInitialized %hd/%hd Regions %hd/%hd Fields %hd/%hd Buffers %hd/%hd Packages (%hd nodes)\n",
+		info.op_region_init, info.op_region_count,
+		info.field_init,    info.field_count,
+		info.buffer_init,   info.buffer_count,
+		info.package_init,  info.package_count, info.object_count));
+
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-		"%d Control Methods found\n", info.method_count));
+		"%hd Control Methods found\n", info.method_count));
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-		"%d Op Regions found\n", info.op_region_count));
+		"%hd Op Regions found\n", info.op_region_count));
 
 	return_ACPI_STATUS (AE_OK);
 }
@@ -93,7 +111,7 @@ acpi_ns_initialize_objects (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_initialize_devices
+ * FUNCTION:    acpi_ns_initialize_devices
  *
  * PARAMETERS:  None
  *
@@ -111,30 +129,33 @@ acpi_status
 acpi_ns_initialize_devices (
 	void)
 {
-	acpi_status             status;
-	acpi_device_walk_info   info;
+	acpi_status                     status;
+	struct acpi_device_walk_info    info;
+
 
+	ACPI_FUNCTION_TRACE ("ns_initialize_devices");
 
-	FUNCTION_TRACE ("Ns_initialize_devices");
 
+	/* Init counters */
 
 	info.device_count = 0;
 	info.num_STA = 0;
 	info.num_INI = 0;
 
+	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT, "Executing all Device _STA and_INI methods:"));
 
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK, "Executing device _INI methods:"));
+	/* Walk namespace for all objects of type Device */
 
 	status = acpi_ns_walk_namespace (ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
 			  ACPI_UINT32_MAX, FALSE, acpi_ns_init_one_device, &info, NULL);
 
 	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Walk_namespace failed! %x\n", status));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "walk_namespace failed! %s\n",
+			acpi_format_exception (status)));
 	}
 
-
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK,
-		"\n%d Devices found: %d _STA, %d _INI\n",
+	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT,
+		"\n%hd Devices found containing: %hd _STA, %hd _INI methods\n",
 		info.device_count, info.num_STA, info.num_INI));
 
 	return_ACPI_STATUS (status);
@@ -143,16 +164,16 @@ acpi_ns_initialize_devices (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_init_one_object
+ * FUNCTION:    acpi_ns_init_one_object
  *
- * PARAMETERS:  Obj_handle      - Node
+ * PARAMETERS:  obj_handle      - Node
  *              Level           - Current nesting level
  *              Context         - Points to a init info struct
- *              Return_value    - Not used
+ *              return_value    - Not used
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Callback from Acpi_walk_namespace. Invoked for every object
+ * DESCRIPTION: Callback from acpi_walk_namespace. Invoked for every object
  *              within the  namespace.
  *
  *              Currently, the only objects that require initialization are:
@@ -163,37 +184,62 @@ acpi_ns_initialize_devices (
 
 acpi_status
 acpi_ns_init_one_object (
-	acpi_handle             obj_handle,
-	u32                     level,
-	void                    *context,
-	void                    **return_value)
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *context,
+	void                            **return_value)
 {
-	acpi_object_type8       type;
-	acpi_status             status;
-	acpi_init_walk_info     *info = (acpi_init_walk_info *) context;
-	acpi_namespace_node     *node = (acpi_namespace_node *) obj_handle;
-	acpi_operand_object     *obj_desc;
+	acpi_object_type                type;
+	acpi_status                     status;
+	struct acpi_init_walk_info      *info = (struct acpi_init_walk_info *) context;
+	struct acpi_namespace_node      *node = (struct acpi_namespace_node *) obj_handle;
+	union acpi_operand_object       *obj_desc;
 
 
-	PROC_NAME ("Ns_init_one_object");
+	ACPI_FUNCTION_NAME ("ns_init_one_object");
 
 
 	info->object_count++;
 
-
 	/* And even then, we are only interested in a few object types */
 
 	type = acpi_ns_get_type (obj_handle);
-	obj_desc = node->object;
+	obj_desc = acpi_ns_get_attached_object (node);
 	if (!obj_desc) {
 		return (AE_OK);
 	}
 
-	if ((type != ACPI_TYPE_REGION) &&
-		(type != ACPI_TYPE_BUFFER_FIELD)) {
+	/* Increment counters for object types we are looking for */
+
+	switch (type) {
+	case ACPI_TYPE_REGION:
+		info->op_region_count++;
+		break;
+
+	case ACPI_TYPE_BUFFER_FIELD:
+		info->field_count++;
+		break;
+
+	case ACPI_TYPE_BUFFER:
+		info->buffer_count++;
+		break;
+
+	case ACPI_TYPE_PACKAGE:
+		info->package_count++;
+		break;
+
+	default:
+
+		/* No init required, just exit now */
 		return (AE_OK);
 	}
 
+	/*
+	 * If the object is already initialized, nothing else to do
+	 */
+	if (obj_desc->common.flags & AOPOBJ_DATA_VALID) {
+		return (AE_OK);
+	}
 
 	/*
 	 * Must lock the interpreter before executing AML code
@@ -203,61 +249,59 @@ acpi_ns_init_one_object (
 		return (status);
 	}
 
+	/*
+	 * Each of these types can contain executable AML code within
+	 * the declaration.
+	 */
 	switch (type) {
-
 	case ACPI_TYPE_REGION:
 
-		info->op_region_count++;
-		if (obj_desc->common.flags & AOPOBJ_DATA_VALID) {
-			break;
-		}
-
 		info->op_region_init++;
 		status = acpi_ds_get_region_arguments (obj_desc);
-		if (ACPI_FAILURE (status)) {
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_ERROR, "\n"));
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-					"%s while getting region arguments [%4.4s]\n",
-					acpi_format_exception (status), (char*)&node->name));
-		}
-
-		if (!(acpi_dbg_level & ACPI_LV_INIT)) {
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK, "."));
-		}
-
 		break;
 
 
 	case ACPI_TYPE_BUFFER_FIELD:
 
-		info->field_count++;
-		if (obj_desc->common.flags & AOPOBJ_DATA_VALID) {
-			break;
-		}
-
 		info->field_init++;
 		status = acpi_ds_get_buffer_field_arguments (obj_desc);
-		if (ACPI_FAILURE (status)) {
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_ERROR, "\n"));
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-					"%s while getting buffer field arguments [%4.4s]\n",
-					acpi_format_exception (status), (char*)&node->name));
-		}
-		if (!(acpi_dbg_level & ACPI_LV_INIT)) {
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK, "."));
-		}
+		break;
+
 
+	case ACPI_TYPE_BUFFER:
 
+		info->buffer_init++;
+		status = acpi_ds_get_buffer_arguments (obj_desc);
+		break;
+
+
+	case ACPI_TYPE_PACKAGE:
+
+		info->package_init++;
+		status = acpi_ds_get_package_arguments (obj_desc);
 		break;
 
 	default:
+		/* No other types can get here */
 		break;
 	}
 
+	if (ACPI_FAILURE (status)) {
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_ERROR, "\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Could not execute arguments for [%4.4s] (%s), %s\n",
+				node->name.ascii, acpi_ut_get_type_name (type), acpi_format_exception (status)));
+	}
+
+	/* Print a dot for each object unless we are going to print the entire pathname */
+
+	if (!(acpi_dbg_level & ACPI_LV_INIT_NAMES)) {
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT, "."));
+	}
 
 	/*
 	 * We ignore errors from above, and always return OK, since
-	 * we don't want to abort the walk on a single error.
+	 * we don't want to abort the walk on any single error.
 	 */
 	acpi_ex_exit_interpreter ();
 	return (AE_OK);
@@ -266,7 +310,7 @@ acpi_ns_init_one_object (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_init_one_device
+ * FUNCTION:    acpi_ns_init_one_device
  *
  * PARAMETERS:  acpi_walk_callback
  *
@@ -280,40 +324,46 @@ acpi_ns_init_one_object (
 
 acpi_status
 acpi_ns_init_one_device (
-	acpi_handle             obj_handle,
-	u32                     nesting_level,
-	void                    *context,
-	void                    **return_value)
+	acpi_handle                     obj_handle,
+	u32                             nesting_level,
+	void                            *context,
+	void                            **return_value)
 {
-	acpi_status             status;
-	acpi_namespace_node    *node;
-	u32                     flags;
-	acpi_device_walk_info  *info = (acpi_device_walk_info *) context;
+	acpi_status                     status;
+	struct acpi_namespace_node     *node;
+	u32                             flags;
+	struct acpi_device_walk_info   *info = (struct acpi_device_walk_info *) context;
 
 
-	FUNCTION_TRACE ("Ns_init_one_device");
+	ACPI_FUNCTION_TRACE ("ns_init_one_device");
 
 
-	if (!(acpi_dbg_level & ACPI_LV_INIT)) {
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK, "."));
+	if ((acpi_dbg_level <= ACPI_LV_ALL_EXCEPTIONS) && (!(acpi_dbg_level & ACPI_LV_INFO))) {
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT, "."));
 	}
 
 	info->device_count++;
 
-	acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	node = acpi_ns_map_handle_to_node (obj_handle);
 	if (!node) {
-		acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
-		return (AE_BAD_PARAMETER);
+		(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	status = acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	/*
 	 * Run _STA to determine if we can run _INI on the device.
 	 */
-	DEBUG_EXEC (acpi_ut_display_init_pathname (node, "_STA [Method]"));
+	ACPI_DEBUG_EXEC (acpi_ut_display_init_pathname (ACPI_TYPE_METHOD, node, "_STA"));
 	status = acpi_ut_execute_STA (node, &flags);
 	if (ACPI_FAILURE (status)) {
 		/* Ignore error and move on to next device */
@@ -329,36 +379,41 @@ acpi_ns_init_one_device (
 		return_ACPI_STATUS(AE_CTRL_DEPTH);
 	}
 
-
 	/*
 	 * The device is present. Run _INI.
 	 */
-	DEBUG_EXEC (acpi_ut_display_init_pathname (obj_handle, "_INI [Method]"));
+	ACPI_DEBUG_EXEC (acpi_ut_display_init_pathname (ACPI_TYPE_METHOD, obj_handle, "_INI"));
 	status = acpi_ns_evaluate_relative (obj_handle, "_INI", NULL, NULL);
-	if (AE_NOT_FOUND == status) {
-		/* No _INI means device requires no initialization */
+	if (ACPI_FAILURE (status)) {
+		/* No _INI (AE_NOT_FOUND) means device requires no initialization */
 
-		status = AE_OK;
-	}
+		if (status != AE_NOT_FOUND) {
+			/* Ignore error and move on to next device */
 
-	else if (ACPI_FAILURE (status)) {
-		/* Ignore error and move on to next device */
+	#ifdef ACPI_DEBUG_OUTPUT
+			char                *scope_name = acpi_ns_get_external_pathname (obj_handle);
 
-#ifdef ACPI_DEBUG
-		NATIVE_CHAR *scope_name = acpi_ns_get_table_pathname (obj_handle);
+			ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "%s._INI failed: %s\n",
+					scope_name, acpi_format_exception (status)));
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "%s._INI failed: %s\n",
-				scope_name, acpi_format_exception (status)));
+			ACPI_MEM_FREE (scope_name);
+	#endif
+		}
 
-		ACPI_MEM_FREE (scope_name);
-#endif
+		status = AE_OK;
 	}
-
 	else {
 		/* Count of successful INIs */
 
 		info->num_INI++;
 	}
 
-	return_ACPI_STATUS (AE_OK);
+	if (acpi_gbl_init_handler) {
+		/* External initialization handler is present, call it */
+
+		status = acpi_gbl_init_handler (obj_handle, ACPI_INIT_DEVICE_INI);
+	}
+
+
+	return_ACPI_STATUS (status);
 }
diff -urNp linux-5400/drivers/acpi/namespace/nsload.c linux-5410/drivers/acpi/namespace/nsload.c
--- linux-5400/drivers/acpi/namespace/nsload.c
+++ linux-5410/drivers/acpi/namespace/nsload.c
@@ -1,239 +1,91 @@
 /******************************************************************************
  *
  * Module Name: nsload - namespace loading/expanding/contracting procedures
- *              $Revision: 47 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acinterp.h"
-#include "acnamesp.h"
-#include "amlcode.h"
-#include "acparser.h"
-#include "acdispat.h"
-#include "acdebug.h"
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acdispat.h>
 
 
 #define _COMPONENT          ACPI_NAMESPACE
-	 MODULE_NAME         ("nsload")
+	 ACPI_MODULE_NAME    ("nsload")
 
 
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_load_namespace
- *
- * PARAMETERS:  Display_aml_during_load
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Load the name space from what ever is pointed to by DSDT.
- *              (DSDT points to either the BIOS or a buffer.)
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ns_load_namespace (
-	void)
-{
-	acpi_status             status;
-
-
-	FUNCTION_TRACE ("Acpi_load_name_space");
-
-
-	/* There must be at least a DSDT installed */
-
-	if (acpi_gbl_DSDT == NULL) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "DSDT is not in memory\n"));
-		return_ACPI_STATUS (AE_NO_ACPI_TABLES);
-	}
-
-
-	/*
-	 * Load the namespace.  The DSDT is required,
-	 * but the SSDT and PSDT tables are optional.
-	 */
-	status = acpi_ns_load_table_by_type (ACPI_TABLE_DSDT);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
-
-	/* Ignore exceptions from these */
-
-	acpi_ns_load_table_by_type (ACPI_TABLE_SSDT);
-	acpi_ns_load_table_by_type (ACPI_TABLE_PSDT);
-
-
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK,
-		"ACPI Namespace successfully loaded at root %p\n",
-		acpi_gbl_root_node));
-
-
-	return_ACPI_STATUS (status);
-}
-
+#ifndef ACPI_NO_METHOD_EXECUTION
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_one_parse_pass
+ * FUNCTION:    acpi_ns_load_table
  *
- * PARAMETERS:
+ * PARAMETERS:  table_desc      - Descriptor for table to be loaded
+ *              Node            - Owning NS node
  *
  * RETURN:      Status
  *
- * DESCRIPTION:
+ * DESCRIPTION: Load one ACPI table into the namespace
  *
  ******************************************************************************/
 
 acpi_status
-acpi_ns_one_complete_parse (
-	u32                     pass_number,
-	acpi_table_desc         *table_desc)
+acpi_ns_load_table (
+	struct acpi_table_desc          *table_desc,
+	struct acpi_namespace_node      *node)
 {
-	acpi_parse_object       *parse_root;
-	acpi_status             status;
-	acpi_walk_state         *walk_state;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Ns_one_complete_parse");
-
-
-	/* Create and init a Root Node */
-
-	parse_root = acpi_ps_alloc_op (AML_SCOPE_OP);
-	if (!parse_root) {
-		return_ACPI_STATUS (AE_NO_MEMORY);
-	}
-
-	((acpi_parse2_object *) parse_root)->name = ACPI_ROOT_NAME;
+	ACPI_FUNCTION_TRACE ("ns_load_table");
 
 
-	/* Create and initialize a new walk state */
+	/* Check if table contains valid AML (must be DSDT, PSDT, SSDT, etc.) */
 
-	walk_state = acpi_ds_create_walk_state (TABLE_ID_DSDT,
-			   NULL, NULL, NULL);
-	if (!walk_state) {
-		acpi_ps_free_op (parse_root);
-		return_ACPI_STATUS (AE_NO_MEMORY);
-	}
+	if (!(acpi_gbl_table_data[table_desc->type].flags & ACPI_TABLE_EXECUTABLE)) {
+		/* Just ignore this table */
 
-	status = acpi_ds_init_aml_walk (walk_state, parse_root, NULL, table_desc->aml_start,
-			  table_desc->aml_length, NULL, NULL, pass_number);
-	if (ACPI_FAILURE (status)) {
-		acpi_ds_delete_walk_state (walk_state);
-		return_ACPI_STATUS (status);
+		return_ACPI_STATUS (AE_OK);
 	}
 
-	/* Parse the AML */
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "*PARSE* pass %d parse\n", pass_number));
-	status = acpi_ps_parse_aml (walk_state);
-
-	acpi_ps_delete_parse_tree (parse_root);
-	return_ACPI_STATUS (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ns_parse_table
- *
- * PARAMETERS:  Table_desc      - An ACPI table descriptor for table to parse
- *              Start_node      - Where to enter the table into the namespace
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Parse AML within an ACPI table and return a tree of ops
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ns_parse_table (
-	acpi_table_desc         *table_desc,
-	acpi_namespace_node     *start_node)
-{
-	acpi_status             status;
-
-
-	FUNCTION_TRACE ("Ns_parse_table");
-
-
-	/*
-	 * AML Parse, pass 1
-	 *
-	 * In this pass, we load most of the namespace.  Control methods
-	 * are not parsed until later.  A parse tree is not created.  Instead,
-	 * each Parser Op subtree is deleted when it is finished.  This saves
-	 * a great deal of memory, and allows a small cache of parse objects
-	 * to service the entire parse.  The second pass of the parse then
-	 * performs another complete parse of the AML..
-	 */
-	status = acpi_ns_one_complete_parse (1, table_desc);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
-
-
-	/*
-	 * AML Parse, pass 2
-	 *
-	 * In this pass, we resolve forward references and other things
-	 * that could not be completed during the first pass.
-	 * Another complete parse of the AML is performed, but the
-	 * overhead of this is compensated for by the fact that the
-	 * parse objects are all cached.
-	 */
-	status = acpi_ns_one_complete_parse (2, table_desc);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
-
-	return_ACPI_STATUS (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ns_load_table
- *
- * PARAMETERS:  Table_desc      - Descriptor for table to be loaded
- *              Node            - Owning NS node
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Load one ACPI table into the namespace
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ns_load_table (
-	acpi_table_desc         *table_desc,
-	acpi_namespace_node     *node)
-{
-	acpi_status             status;
-
-
-	FUNCTION_TRACE ("Ns_load_table");
-
+	/* Check validity of the AML start and length */
 
 	if (!table_desc->aml_start) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Null AML pointer\n"));
@@ -242,13 +94,13 @@ acpi_ns_load_table (
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "AML block at %p\n", table_desc->aml_start));
 
+	/* Ignore table if there is no AML contained within */
 
 	if (!table_desc->aml_length) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Zero-length AML block\n"));
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
+		ACPI_REPORT_WARNING (("Zero-length AML block in table [%4.4s]\n", table_desc->pointer->signature));
+		return_ACPI_STATUS (AE_OK);
 	}
 
-
 	/*
 	 * Parse the table and load the namespace with all named
 	 * objects found within.  Control methods are NOT parsed
@@ -260,9 +112,13 @@ acpi_ns_load_table (
 	 */
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "**** Loading table into namespace ****\n"));
 
-	acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
 	status = acpi_ns_parse_table (table_desc, node->child);
-	acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
@@ -288,9 +144,9 @@ acpi_ns_load_table (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_load_table_by_type
+ * FUNCTION:    acpi_ns_load_table_by_type
  *
- * PARAMETERS:  Table_type          - Id of the table type to load
+ * PARAMETERS:  table_type          - Id of the table type to load
  *
  * RETURN:      Status
  *
@@ -302,30 +158,31 @@ acpi_ns_load_table (
 
 acpi_status
 acpi_ns_load_table_by_type (
-	acpi_table_type         table_type)
+	acpi_table_type                 table_type)
 {
-	u32                     i;
-	acpi_status             status = AE_OK;
-	acpi_table_desc         *table_desc;
-
+	u32                             i;
+	acpi_status                     status;
+	struct acpi_table_desc          *table_desc;
 
-	FUNCTION_TRACE ("Ns_load_table_by_type");
 
+	ACPI_FUNCTION_TRACE ("ns_load_table_by_type");
 
-	acpi_ut_acquire_mutex (ACPI_MTX_TABLES);
 
+	status = acpi_ut_acquire_mutex (ACPI_MTX_TABLES);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	/*
 	 * Table types supported are:
 	 * DSDT (one), SSDT/PSDT (multiple)
 	 */
 	switch (table_type) {
-
 	case ACPI_TABLE_DSDT:
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Loading DSDT\n"));
 
-		table_desc = &acpi_gbl_acpi_tables[ACPI_TABLE_DSDT];
+		table_desc = acpi_gbl_table_lists[ACPI_TABLE_DSDT].next;
 
 		/* If table already loaded into namespace, just return */
 
@@ -333,8 +190,6 @@ acpi_ns_load_table_by_type (
 			goto unlock_and_exit;
 		}
 
-		table_desc->table_id = TABLE_ID_DSDT;
-
 		/* Now load the single DSDT */
 
 		status = acpi_ns_load_table (table_desc, acpi_gbl_root_node);
@@ -348,13 +203,13 @@ acpi_ns_load_table_by_type (
 	case ACPI_TABLE_SSDT:
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Loading %d SSDTs\n",
-			acpi_gbl_acpi_tables[ACPI_TABLE_SSDT].count));
+			acpi_gbl_table_lists[ACPI_TABLE_SSDT].count));
 
 		/*
 		 * Traverse list of SSDT tables
 		 */
-		table_desc = &acpi_gbl_acpi_tables[ACPI_TABLE_SSDT];
-		for (i = 0; i < acpi_gbl_acpi_tables[ACPI_TABLE_SSDT].count; i++) {
+		table_desc = acpi_gbl_table_lists[ACPI_TABLE_SSDT].next;
+		for (i = 0; i < acpi_gbl_table_lists[ACPI_TABLE_SSDT].count; i++) {
 			/*
 			 * Only attempt to load table if it is not
 			 * already loaded!
@@ -376,14 +231,14 @@ acpi_ns_load_table_by_type (
 	case ACPI_TABLE_PSDT:
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Loading %d PSDTs\n",
-			acpi_gbl_acpi_tables[ACPI_TABLE_PSDT].count));
+			acpi_gbl_table_lists[ACPI_TABLE_PSDT].count));
 
 		/*
 		 * Traverse list of PSDT tables
 		 */
-		table_desc = &acpi_gbl_acpi_tables[ACPI_TABLE_PSDT];
+		table_desc = acpi_gbl_table_lists[ACPI_TABLE_PSDT].next;
 
-		for (i = 0; i < acpi_gbl_acpi_tables[ACPI_TABLE_PSDT].count; i++) {
+		for (i = 0; i < acpi_gbl_table_lists[ACPI_TABLE_PSDT].count; i++) {
 			/* Only attempt to load table if it is not already loaded! */
 
 			if (!table_desc->loaded_into_namespace) {
@@ -408,43 +263,92 @@ acpi_ns_load_table_by_type (
 
 
 unlock_and_exit:
+	(void) acpi_ut_release_mutex (ACPI_MTX_TABLES);
+	return_ACPI_STATUS (status);
+}
 
-	acpi_ut_release_mutex (ACPI_MTX_TABLES);
 
-	return_ACPI_STATUS (status);
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_load_namespace
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Load the name space from what ever is pointed to by DSDT.
+ *              (DSDT points to either the BIOS or a buffer.)
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_load_namespace (
+	void)
+{
+	acpi_status                     status;
+
 
+	ACPI_FUNCTION_TRACE ("acpi_load_name_space");
+
+
+	/* There must be at least a DSDT installed */
+
+	if (acpi_gbl_DSDT == NULL) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "DSDT is not in memory\n"));
+		return_ACPI_STATUS (AE_NO_ACPI_TABLES);
+	}
+
+	/*
+	 * Load the namespace.  The DSDT is required,
+	 * but the SSDT and PSDT tables are optional.
+	 */
+	status = acpi_ns_load_table_by_type (ACPI_TABLE_DSDT);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/* Ignore exceptions from these */
+
+	(void) acpi_ns_load_table_by_type (ACPI_TABLE_SSDT);
+	(void) acpi_ns_load_table_by_type (ACPI_TABLE_PSDT);
+
+	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT,
+		"ACPI Namespace successfully loaded at root %p\n",
+		acpi_gbl_root_node));
+
+	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_delete_subtree
+ * FUNCTION:    acpi_ns_delete_subtree
  *
- * PARAMETERS:  Start_handle        - Handle in namespace where search begins
+ * PARAMETERS:  start_handle        - Handle in namespace where search begins
  *
  * RETURNS      Status
  *
  * DESCRIPTION: Walks the namespace starting at the given handle and deletes
  *              all objects, entries, and scopes in the entire subtree.
  *
- *              TBD: [Investigate] What if any part of this subtree is in use?
- *              (i.e. on one of the object stacks?)
+ *              Namespace/Interpreter should be locked or the subsystem should
+ *              be in shutdown before this routine is called.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ns_delete_subtree (
-	acpi_handle             start_handle)
+	acpi_handle                     start_handle)
 {
-	acpi_status             status;
-	acpi_handle             child_handle;
-	acpi_handle             parent_handle;
-	acpi_handle             next_child_handle;
-	acpi_handle             dummy;
-	u32                     level;
+	acpi_status                     status;
+	acpi_handle                     child_handle;
+	acpi_handle                     parent_handle;
+	acpi_handle                     next_child_handle;
+	acpi_handle                     dummy;
+	u32                             level;
 
 
-	FUNCTION_TRACE ("Ns_delete_subtree");
+	ACPI_FUNCTION_TRACE ("ns_delete_subtree");
 
 
 	parent_handle = start_handle;
@@ -463,7 +367,6 @@ acpi_ns_delete_subtree (
 
 		child_handle = next_child_handle;
 
-
 		/* Did we get a new object? */
 
 		if (ACPI_SUCCESS (status)) {
@@ -480,7 +383,6 @@ acpi_ns_delete_subtree (
 				child_handle = 0;
 			}
 		}
-
 		else {
 			/*
 			 * No more children in this object, go back up to
@@ -493,7 +395,10 @@ acpi_ns_delete_subtree (
 			acpi_ns_delete_children (child_handle);
 
 			child_handle = parent_handle;
-			acpi_get_parent (parent_handle, &parent_handle);
+			status = acpi_get_parent (parent_handle, &parent_handle);
+			if (ACPI_FAILURE (status)) {
+				return_ACPI_STATUS (status);
+			}
 		}
 	}
 
@@ -507,7 +412,7 @@ acpi_ns_delete_subtree (
 
 /*******************************************************************************
  *
- *  FUNCTION:       Acpi_ns_unload_name_space
+ *  FUNCTION:       acpi_ns_unload_name_space
  *
  *  PARAMETERS:     Handle          - Root of namespace subtree to be deleted
  *
@@ -521,12 +426,12 @@ acpi_ns_delete_subtree (
 
 acpi_status
 acpi_ns_unload_namespace (
-	acpi_handle             handle)
+	acpi_handle                     handle)
 {
-	acpi_status             status;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Ns_unload_name_space");
+	ACPI_FUNCTION_TRACE ("ns_unload_name_space");
 
 
 	/* Parameter validation */
@@ -539,7 +444,6 @@ acpi_ns_unload_namespace (
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-
 	/* This function does the real work */
 
 	status = acpi_ns_delete_subtree (handle);
@@ -547,4 +451,5 @@ acpi_ns_unload_namespace (
 	return_ACPI_STATUS (status);
 }
 
+#endif
 
diff -urNp linux-5400/drivers/acpi/namespace/nsnames.c linux-5410/drivers/acpi/namespace/nsnames.c
--- linux-5400/drivers/acpi/namespace/nsnames.c
+++ linux-5410/drivers/acpi/namespace/nsnames.c
@@ -1,126 +1,175 @@
 /*******************************************************************************
  *
  * Module Name: nsnames - Name manipulation and search
- *              $Revision: 64 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "amlcode.h"
-#include "acinterp.h"
-#include "acnamesp.h"
+#include <acpi/acpi.h>
+#include <acpi/amlcode.h>
+#include <acpi/acnamesp.h>
 
 
 #define _COMPONENT          ACPI_NAMESPACE
-	 MODULE_NAME         ("nsnames")
+	 ACPI_MODULE_NAME    ("nsnames")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_get_table_pathname
+ * FUNCTION:    acpi_ns_build_external_path
  *
- * PARAMETERS:  Node        - Scope whose name is needed
+ * PARAMETERS:  Node            - NS node whose pathname is needed
+ *              Size            - Size of the pathname
+ *              *name_buffer    - Where to return the pathname
  *
- * RETURN:      Pointer to storage containing the fully qualified name of
- *              the scope, in Label format (all segments strung together
- *              with no separators)
+ * RETURN:      Places the pathname into the name_buffer, in external format
+ *              (name segments separated by path separators)
  *
- * DESCRIPTION: Used for debug printing in Acpi_ns_search_table().
+ * DESCRIPTION: Generate a full pathaname
  *
  ******************************************************************************/
 
-NATIVE_CHAR *
-acpi_ns_get_table_pathname (
-	acpi_namespace_node     *node)
+void
+acpi_ns_build_external_path (
+	struct acpi_namespace_node      *node,
+	acpi_size                       size,
+	char                            *name_buffer)
 {
-	NATIVE_CHAR             *name_buffer;
-	u32                     size;
-	acpi_name               name;
-	acpi_namespace_node     *child_node;
-	acpi_namespace_node     *parent_node;
+	acpi_size                       index;
+	struct acpi_namespace_node      *parent_node;
 
 
-	FUNCTION_TRACE_PTR ("Ns_get_table_pathname", node);
+	ACPI_FUNCTION_NAME ("ns_build_external_path");
 
 
-	if (!acpi_gbl_root_node || !node) {
-		/*
-		 * If the name space has not been initialized,
-		 * this function should not have been called.
-		 */
-		return_PTR (NULL);
+	/* Special case for root */
+
+	index = size - 1;
+	if (index < ACPI_NAME_SIZE) {
+		name_buffer[0] = AML_ROOT_PREFIX;
+		name_buffer[1] = 0;
+		return;
 	}
 
-	child_node = node->child;
+	/* Store terminator byte, then build name backwards */
 
+	parent_node = node;
+	name_buffer[index] = 0;
 
-	/* Calculate required buffer size based on depth below root */
+	while ((index > ACPI_NAME_SIZE) && (parent_node != acpi_gbl_root_node)) {
+		index -= ACPI_NAME_SIZE;
+
+		/* Put the name into the buffer */
 
-	size = 1;
-	parent_node = child_node;
-	while (parent_node) {
-		parent_node = acpi_ns_get_parent_object (parent_node);
-		if (parent_node) {
-			size += ACPI_NAME_SIZE;
-		}
+		ACPI_MOVE_32_TO_32 ((name_buffer + index), &parent_node->name);
+		parent_node = acpi_ns_get_parent_node (parent_node);
+
+		/* Prefix name with the path separator */
+
+		index--;
+		name_buffer[index] = ACPI_PATH_SEPARATOR;
 	}
 
+	/* Overwrite final separator with the root prefix character */
 
-	/* Allocate a buffer to be returned to caller */
+	name_buffer[index] = AML_ROOT_PREFIX;
 
-	name_buffer = ACPI_MEM_CALLOCATE (size + 1);
-	if (!name_buffer) {
-		REPORT_ERROR (("Ns_get_table_pathname: allocation failure\n"));
-		return_PTR (NULL);
+	if (index != 0) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Could not construct pathname; index=%X, size=%X, Path=%s\n",
+			(u32) index, (u32) size, &name_buffer[size]));
 	}
 
+	return;
+}
 
-	/* Store terminator byte, then build name backwards */
 
-	name_buffer[size] = '\0';
-	while ((size > ACPI_NAME_SIZE) &&
-		acpi_ns_get_parent_object (child_node)) {
-		size -= ACPI_NAME_SIZE;
-		name = acpi_ns_find_parent_name (child_node);
+#ifdef ACPI_DEBUG_OUTPUT
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_get_external_pathname
+ *
+ * PARAMETERS:  Node            - NS node whose pathname is needed
+ *
+ * RETURN:      Pointer to storage containing the fully qualified name of
+ *              the node, In external format (name segments separated by path
+ *              separators.)
+ *
+ * DESCRIPTION: Used for debug printing in acpi_ns_search_table().
+ *
+ ******************************************************************************/
 
-		/* Put the name into the buffer */
+char *
+acpi_ns_get_external_pathname (
+	struct acpi_namespace_node      *node)
+{
+	char                            *name_buffer;
+	acpi_size                       size;
+
+
+	ACPI_FUNCTION_TRACE_PTR ("ns_get_external_pathname", node);
 
-		MOVE_UNALIGNED32_TO_32 ((name_buffer + size), &name);
-		child_node = acpi_ns_get_parent_object (child_node);
-	}
 
-	name_buffer[--size] = AML_ROOT_PREFIX;
+	/* Calculate required buffer size based on depth below root */
+
+	size = acpi_ns_get_pathname_length (node);
+
+	/* Allocate a buffer to be returned to caller */
 
-	if (size != 0) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Bad pointer returned; size=%X\n", size));
+	name_buffer = ACPI_MEM_CALLOCATE (size);
+	if (!name_buffer) {
+		ACPI_REPORT_ERROR (("ns_get_table_pathname: allocation failure\n"));
+		return_PTR (NULL);
 	}
 
+	/* Build the path in the allocated buffer */
+
+	acpi_ns_build_external_path (node, size, name_buffer);
 	return_PTR (name_buffer);
 }
+#endif
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_get_pathname_length
+ * FUNCTION:    acpi_ns_get_pathname_length
  *
  * PARAMETERS:  Node        - Namespace node
  *
@@ -130,31 +179,27 @@ acpi_ns_get_table_pathname (
  *
  ******************************************************************************/
 
-u32
+acpi_size
 acpi_ns_get_pathname_length (
-	acpi_namespace_node     *node)
+	struct acpi_namespace_node      *node)
 {
-	u32                     size;
-	acpi_namespace_node     *next_node;
+	acpi_size                       size;
+	struct acpi_namespace_node      *next_node;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	/*
 	 * Compute length of pathname as 5 * number of name segments.
 	 * Go back up the parent tree to the root
 	 */
-	for (size = 0, next_node = node;
-		  acpi_ns_get_parent_object (next_node);
-		  next_node = acpi_ns_get_parent_object (next_node)) {
-		size += PATH_SEGMENT_LENGTH;
-	}
-
-	/* Special case for size still 0 - no parent for "special" nodes */
+	size = 0;
+	next_node = node;
 
-	if (!size) {
-		size = PATH_SEGMENT_LENGTH;
+	while (next_node && (next_node != acpi_gbl_root_node)) {
+		size += ACPI_PATH_SEGMENT_LENGTH;
+		next_node = acpi_ns_get_parent_node (next_node);
 	}
 
 	return (size + 1);
@@ -163,100 +208,53 @@ acpi_ns_get_pathname_length (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_handle_to_pathname
+ * FUNCTION:    acpi_ns_handle_to_pathname
  *
- * PARAMETERS:  Target_handle           - Handle of named object whose name is
+ * PARAMETERS:  target_handle           - Handle of named object whose name is
  *                                        to be found
- *              Buf_size                - Size of the buffer provided
- *              User_buffer             - Where the pathname is returned
+ *              Buffer                  - Where the pathname is returned
  *
  * RETURN:      Status, Buffer is filled with pathname if status is AE_OK
  *
  * DESCRIPTION: Build and return a full namespace pathname
  *
- * MUTEX:       Locks Namespace
- *
  ******************************************************************************/
 
 acpi_status
 acpi_ns_handle_to_pathname (
-	acpi_handle             target_handle,
-	u32                     *buf_size,
-	NATIVE_CHAR             *user_buffer)
+	acpi_handle                     target_handle,
+	struct acpi_buffer              *buffer)
 {
-	acpi_status             status = AE_OK;
-	acpi_namespace_node     *node;
-	u32                     path_length;
-	u32                     user_buf_size;
-	acpi_name               name;
-	u32                     size;
-
-
-	FUNCTION_TRACE_PTR ("Ns_handle_to_pathname", target_handle);
-
-
-	if (!acpi_gbl_root_node) {
-		/*
-		 * If the name space has not been initialized,
-		 * this function should not have been called.
-		 */
-		return_ACPI_STATUS (AE_NO_NAMESPACE);
-	}
+	acpi_status                     status;
+	struct acpi_namespace_node      *node;
+	acpi_size                       required_size;
 
-	node = acpi_ns_map_handle_to_node (target_handle);
-	if (!node) {
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
-	}
-
-
-	/* Set return length to the required path length */
-
-	path_length = acpi_ns_get_pathname_length (node);
-	size = path_length - 1;
 
-	user_buf_size = *buf_size;
-	*buf_size = path_length;
+	ACPI_FUNCTION_TRACE_PTR ("ns_handle_to_pathname", target_handle);
 
-	/* Check if the user buffer is sufficiently large */
 
-	if (path_length > user_buf_size) {
-		status = AE_BUFFER_OVERFLOW;
-		goto exit;
+	node = acpi_ns_map_handle_to_node (target_handle);
+	if (!node) {
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	/* Store null terminator */
+	/* Determine size required for the caller buffer */
 
-	user_buffer[size] = 0;
-	size -= ACPI_NAME_SIZE;
+	required_size = acpi_ns_get_pathname_length (node);
 
-	/* Put the original ACPI name at the end of the path */
+	/* Validate/Allocate/Clear caller buffer */
 
-	MOVE_UNALIGNED32_TO_32 ((user_buffer + size),
-			 &node->name);
-
-	user_buffer[--size] = PATH_SEPARATOR;
-
-	/* Build name backwards, putting "." between segments */
-
-	while ((size > ACPI_NAME_SIZE) && node) {
-		size -= ACPI_NAME_SIZE;
-		name = acpi_ns_find_parent_name (node);
-		MOVE_UNALIGNED32_TO_32 ((user_buffer + size), &name);
-
-		user_buffer[--size] = PATH_SEPARATOR;
-		node = acpi_ns_get_parent_object (node);
+	status = acpi_ut_initialize_buffer (buffer, required_size);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
 	}
 
-	/*
-	 * Overlay the "." preceding the first segment with
-	 * the root name "\"
-	 */
-	user_buffer[size] = '\\';
+	/* Build the path in the caller buffer */
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Len=%X, %s \n", path_length, user_buffer));
+	acpi_ns_build_external_path (node, required_size, buffer->pointer);
 
-exit:
-	return_ACPI_STATUS (status);
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "%s [%X] \n", (char *) buffer->pointer, (u32) required_size));
+	return_ACPI_STATUS (AE_OK);
 }
 
 
diff -urNp linux-5400/drivers/acpi/namespace/nsobject.c linux-5410/drivers/acpi/namespace/nsobject.c
--- linux-5400/drivers/acpi/namespace/nsobject.c
+++ linux-5410/drivers/acpi/namespace/nsobject.c
@@ -2,43 +2,58 @@
  *
  * Module Name: nsobject - Utilities for objects attached to namespace
  *                         table entries
- *              $Revision: 67 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "acinterp.h"
-#include "actables.h"
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
 
 
 #define _COMPONENT          ACPI_NAMESPACE
-	 MODULE_NAME         ("nsobject")
+	 ACPI_MODULE_NAME    ("nsobject")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_attach_object
+ * FUNCTION:    acpi_ns_attach_object
  *
  * PARAMETERS:  Node                - Parent Node
  *              Object              - Object to be attached
@@ -48,6 +63,8 @@
  * DESCRIPTION: Record the given object as the value associated with the
  *              name whose acpi_handle is passed.  If Object is NULL
  *              and Type is ACPI_TYPE_ANY, set the name as having no value.
+ *              Note: Future may require that the Node->Flags field be passed
+ *              as a parameter.
  *
  * MUTEX:       Assumes namespace is locked
  *
@@ -55,206 +72,169 @@
 
 acpi_status
 acpi_ns_attach_object (
-	acpi_namespace_node     *node,
-	acpi_operand_object     *object,
-	acpi_object_type8       type)
+	struct acpi_namespace_node      *node,
+	union acpi_operand_object       *object,
+	acpi_object_type                type)
 {
-	acpi_operand_object     *obj_desc;
-	acpi_operand_object     *previous_obj_desc;
-	acpi_object_type8       obj_type = ACPI_TYPE_ANY;
-	u8                      flags;
+	union acpi_operand_object       *obj_desc;
+	union acpi_operand_object       *last_obj_desc;
+	acpi_object_type                object_type = ACPI_TYPE_ANY;
 
 
-	FUNCTION_TRACE ("Ns_attach_object");
+	ACPI_FUNCTION_TRACE ("ns_attach_object");
 
 
 	/*
 	 * Parameter validation
 	 */
-	if (!acpi_gbl_root_node) {
-		/* Name space not initialized  */
-
-		REPORT_ERROR (("Ns_attach_object: Namespace not initialized\n"));
-		return_ACPI_STATUS (AE_NO_NAMESPACE);
-	}
-
 	if (!node) {
 		/* Invalid handle */
 
-		REPORT_ERROR (("Ns_attach_object: Null Named_obj handle\n"));
+		ACPI_REPORT_ERROR (("ns_attach_object: Null named_obj handle\n"));
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
 	if (!object && (ACPI_TYPE_ANY != type)) {
 		/* Null object */
 
-		REPORT_ERROR (("Ns_attach_object: Null object, but type not ACPI_TYPE_ANY\n"));
+		ACPI_REPORT_ERROR (("ns_attach_object: Null object, but type not ACPI_TYPE_ANY\n"));
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	if (!VALID_DESCRIPTOR_TYPE (node, ACPI_DESC_TYPE_NAMED)) {
+	if (ACPI_GET_DESCRIPTOR_TYPE (node) != ACPI_DESC_TYPE_NAMED) {
 		/* Not a name handle */
 
-		REPORT_ERROR (("Ns_attach_object: Invalid handle\n"));
+		ACPI_REPORT_ERROR (("ns_attach_object: Invalid handle\n"));
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
 	/* Check if this object is already attached */
 
 	if (node->object == object) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Obj %p already installed in Name_obj %p\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Obj %p already installed in name_obj %p\n",
 			object, node));
 
 		return_ACPI_STATUS (AE_OK);
 	}
 
-
-	/* Get the current flags field of the Node */
-
-	flags = node->flags;
-	flags &= ~ANOBJ_AML_ATTACHMENT;
-
-
 	/* If null object, we will just install it */
 
 	if (!object) {
-		obj_desc = NULL;
-		obj_type = ACPI_TYPE_ANY;
+		obj_desc   = NULL;
+		object_type = ACPI_TYPE_ANY;
 	}
 
 	/*
 	 * If the source object is a namespace Node with an attached object,
 	 * we will use that (attached) object
 	 */
-	else if (VALID_DESCRIPTOR_TYPE (object, ACPI_DESC_TYPE_NAMED) &&
-			((acpi_namespace_node *) object)->object) {
+	else if ((ACPI_GET_DESCRIPTOR_TYPE (object) == ACPI_DESC_TYPE_NAMED) &&
+			((struct acpi_namespace_node *) object)->object) {
 		/*
 		 * Value passed is a name handle and that name has a
 		 * non-null value.  Use that name's value and type.
 		 */
-		obj_desc = ((acpi_namespace_node *) object)->object;
-		obj_type = ((acpi_namespace_node *) object)->type;
-
-		/*
-		 * Copy appropriate flags
-		 */
-		if (((acpi_namespace_node *) object)->flags & ANOBJ_AML_ATTACHMENT) {
-			flags |= ANOBJ_AML_ATTACHMENT;
-		}
+		obj_desc   = ((struct acpi_namespace_node *) object)->object;
+		object_type = ((struct acpi_namespace_node *) object)->type;
 	}
 
-
 	/*
 	 * Otherwise, we will use the parameter object, but we must type
 	 * it first
 	 */
 	else {
-		obj_desc = (acpi_operand_object *) object;
+		obj_desc = (union acpi_operand_object   *) object;
 
-		/* If a valid type (non-ANY) was given, just use it */
-
-		if (ACPI_TYPE_ANY != type) {
-			obj_type = type;
-		}
+		/* Use the given type */
 
-		else {
-			/*
-			 * Cannot figure out the type -- set to Def_any which
-			 * will print as an error in the name table dump
-			 */
-			if (acpi_dbg_level > 0) {
-				DUMP_PATHNAME (node,
-					"Ns_attach_object confused: setting bogus type for ",
-					ACPI_LV_INFO, _COMPONENT);
-
-				if (VALID_DESCRIPTOR_TYPE (object, ACPI_DESC_TYPE_NAMED)) {
-					DUMP_PATHNAME (object, "name ", ACPI_LV_INFO, _COMPONENT);
-				}
-
-				else {
-					DUMP_PATHNAME (object, "object ", ACPI_LV_INFO, _COMPONENT);
-					DUMP_STACK_ENTRY (object);
-				}
-			}
-
-			obj_type = INTERNAL_TYPE_DEF_ANY;
-		}
+		object_type = type;
 	}
 
-
 	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Installing %p into Node %p [%4.4s]\n",
-		obj_desc, node, (char*)&node->name));
+		obj_desc, node, node->name.ascii));
 
+	/* Detach an existing attached object if present */
 
-	/*
-	 * Must increment the new value's reference count
-	 * (if it is an internal object)
-	 */
-	acpi_ut_add_reference (obj_desc);
-
-	/* Save the existing object (if any) for deletion later */
-
-	previous_obj_desc = node->object;
-
-	/* Install the object and set the type, flags */
-
-	node->object   = obj_desc;
-	node->type     = (u8) obj_type;
-	node->flags    |= flags;
-
+	if (node->object) {
+		acpi_ns_detach_object (node);
+	}
 
-	/*
-	 * Delete an existing attached object.
-	 */
-	if (previous_obj_desc) {
-		/* One for the attach to the Node */
+	if (obj_desc) {
+		/*
+		 * Must increment the new value's reference count
+		 * (if it is an internal object)
+		 */
+		acpi_ut_add_reference (obj_desc);
 
-		acpi_ut_remove_reference (previous_obj_desc);
+		/*
+		 * Handle objects with multiple descriptors - walk
+		 * to the end of the descriptor list
+		 */
+		last_obj_desc = obj_desc;
+		while (last_obj_desc->common.next_object) {
+			last_obj_desc = last_obj_desc->common.next_object;
+		}
 
-		/* Now delete */
+		/* Install the object at the front of the object list */
 
-		acpi_ut_remove_reference (previous_obj_desc);
+		last_obj_desc->common.next_object = node->object;
 	}
 
+	node->type     = (u8) object_type;
+	node->object   = obj_desc;
+
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_detach_object
+ * FUNCTION:    acpi_ns_detach_object
  *
- * PARAMETERS:  Node           - An object whose Value will be deleted
+ * PARAMETERS:  Node           - An node whose object will be detached
  *
  * RETURN:      None.
  *
- * DESCRIPTION: Delete the Value associated with a namespace object.  If the
- *              Value is an allocated object, it is freed.  Otherwise, the
- *              field is simply cleared.
+ * DESCRIPTION: Detach/delete an object associated with a namespace node.
+ *              if the object is an allocated object, it is freed.
+ *              Otherwise, the field is simply cleared.
  *
  ******************************************************************************/
 
 void
 acpi_ns_detach_object (
-	acpi_namespace_node     *node)
+	struct acpi_namespace_node      *node)
 {
-	acpi_operand_object     *obj_desc;
+	union acpi_operand_object       *obj_desc;
 
 
-	FUNCTION_TRACE ("Ns_detach_object");
+	ACPI_FUNCTION_TRACE ("ns_detach_object");
 
 
 	obj_desc = node->object;
-	if (!obj_desc) {
+
+	if (!obj_desc ||
+		(ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_LOCAL_DATA)) {
 		return_VOID;
 	}
 
 	/* Clear the entry in all cases */
 
 	node->object = NULL;
+	if (ACPI_GET_DESCRIPTOR_TYPE (obj_desc) == ACPI_DESC_TYPE_OPERAND) {
+		node->object = obj_desc->common.next_object;
+		if (node->object &&
+		   (ACPI_GET_OBJECT_TYPE (node->object) != ACPI_TYPE_LOCAL_DATA)) {
+			node->object = node->object->common.next_object;
+		}
+	}
+
+	/* Reset the node type to untyped */
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Object=%p Value=%p Name %4.4s\n",
-		node, obj_desc, (char*)&node->name));
+	node->type = ACPI_TYPE_ANY;
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "Node %p [%4.4s] Object %p\n",
+		node, node->name.ascii, obj_desc));
 
 	/* Remove one reference on the object (and all subobjects) */
 
@@ -265,30 +245,216 @@ acpi_ns_detach_object (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_get_attached_object
+ * FUNCTION:    acpi_ns_get_attached_object
  *
  * PARAMETERS:  Node             - Parent Node to be examined
  *
  * RETURN:      Current value of the object field from the Node whose
  *              handle is passed
  *
+ * DESCRIPTION: Obtain the object attached to a namespace node.
+ *
  ******************************************************************************/
 
-void *
+union acpi_operand_object *
 acpi_ns_get_attached_object (
-	acpi_namespace_node     *node)
+	struct acpi_namespace_node      *node)
 {
-	FUNCTION_TRACE_PTR ("Ns_get_attached_object", node);
+	ACPI_FUNCTION_TRACE_PTR ("ns_get_attached_object", node);
 
 
 	if (!node) {
-		/* handle invalid */
-
 		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Null Node ptr\n"));
 		return_PTR (NULL);
 	}
 
+	if (!node->object ||
+			((ACPI_GET_DESCRIPTOR_TYPE (node->object) != ACPI_DESC_TYPE_OPERAND) &&
+			 (ACPI_GET_DESCRIPTOR_TYPE (node->object) != ACPI_DESC_TYPE_NAMED))  ||
+		(ACPI_GET_OBJECT_TYPE (node->object) == ACPI_TYPE_LOCAL_DATA)) {
+		return_PTR (NULL);
+	}
+
 	return_PTR (node->object);
 }
 
 
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_get_secondary_object
+ *
+ * PARAMETERS:  Node             - Parent Node to be examined
+ *
+ * RETURN:      Current value of the object field from the Node whose
+ *              handle is passed.
+ *
+ * DESCRIPTION: Obtain a secondary object associated with a namespace node.
+ *
+ ******************************************************************************/
+
+union acpi_operand_object *
+acpi_ns_get_secondary_object (
+	union acpi_operand_object       *obj_desc)
+{
+	ACPI_FUNCTION_TRACE_PTR ("ns_get_secondary_object", obj_desc);
+
+
+	if ((!obj_desc)                                               ||
+		(ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_LOCAL_DATA) ||
+		(!obj_desc->common.next_object)                           ||
+		(ACPI_GET_OBJECT_TYPE (obj_desc->common.next_object) == ACPI_TYPE_LOCAL_DATA)) {
+		return_PTR (NULL);
+	}
+
+	return_PTR (obj_desc->common.next_object);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_attach_data
+ *
+ * PARAMETERS:  Node            - Namespace node
+ *              Handler         - Handler to be associated with the data
+ *              Data            - Data to be attached
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Low-level attach data.  Create and attach a Data object.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_attach_data (
+	struct acpi_namespace_node      *node,
+	acpi_object_handler             handler,
+	void                            *data)
+{
+	union acpi_operand_object       *prev_obj_desc;
+	union acpi_operand_object       *obj_desc;
+	union acpi_operand_object       *data_desc;
+
+
+	/* We only allow one attachment per handler */
+
+	prev_obj_desc = NULL;
+	obj_desc = node->object;
+	while (obj_desc) {
+		if ((ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_LOCAL_DATA) &&
+			(obj_desc->data.handler == handler)) {
+			return (AE_ALREADY_EXISTS);
+		}
+
+		prev_obj_desc = obj_desc;
+		obj_desc = obj_desc->common.next_object;
+	}
+
+	/* Create an internal object for the data */
+
+	data_desc = acpi_ut_create_internal_object (ACPI_TYPE_LOCAL_DATA);
+	if (!data_desc) {
+		return (AE_NO_MEMORY);
+	}
+
+	data_desc->data.handler = handler;
+	data_desc->data.pointer = data;
+
+	/* Install the data object */
+
+	if (prev_obj_desc) {
+		prev_obj_desc->common.next_object = data_desc;
+	}
+	else {
+		node->object = data_desc;
+	}
+
+	return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_detach_data
+ *
+ * PARAMETERS:  Node            - Namespace node
+ *              Handler         - Handler associated with the data
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Low-level detach data.  Delete the data node, but the caller
+ *              is responsible for the actual data.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_detach_data (
+	struct acpi_namespace_node      *node,
+	acpi_object_handler             handler)
+{
+	union acpi_operand_object       *obj_desc;
+	union acpi_operand_object       *prev_obj_desc;
+
+
+	prev_obj_desc = NULL;
+	obj_desc = node->object;
+	while (obj_desc) {
+		if ((ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_LOCAL_DATA) &&
+			(obj_desc->data.handler == handler)) {
+			if (prev_obj_desc) {
+				prev_obj_desc->common.next_object = obj_desc->common.next_object;
+			}
+			else {
+				node->object = obj_desc->common.next_object;
+			}
+
+			acpi_ut_remove_reference (obj_desc);
+			return (AE_OK);
+		}
+
+		prev_obj_desc = obj_desc;
+		obj_desc = obj_desc->common.next_object;
+	}
+
+	return (AE_NOT_FOUND);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_get_attached_data
+ *
+ * PARAMETERS:  Node            - Namespace node
+ *              Handler         - Handler associated with the data
+ *              Data            - Where the data is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Low level interface to obtain data previously associated with
+ *              a namespace node.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_get_attached_data (
+	struct acpi_namespace_node      *node,
+	acpi_object_handler             handler,
+	void                            **data)
+{
+	union acpi_operand_object       *obj_desc;
+
+
+	obj_desc = node->object;
+	while (obj_desc) {
+		if ((ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_LOCAL_DATA) &&
+			(obj_desc->data.handler == handler)) {
+			*data = obj_desc->data.pointer;
+			return (AE_OK);
+		}
+
+		obj_desc = obj_desc->common.next_object;
+	}
+
+	return (AE_NOT_FOUND);
+}
+
+
diff -urNp linux-5400/drivers/acpi/namespace/nsparse.c linux-5410/drivers/acpi/namespace/nsparse.c
--- linux-5400/drivers/acpi/namespace/nsparse.c
+++ linux-5410/drivers/acpi/namespace/nsparse.c
@@ -0,0 +1,170 @@
+/******************************************************************************
+ *
+ * Module Name: nsparse - namespace interface to AML parser
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acparser.h>
+#include <acpi/acdispat.h>
+
+
+#define _COMPONENT          ACPI_NAMESPACE
+	 ACPI_MODULE_NAME    ("nsparse")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ns_one_complete_parse
+ *
+ * PARAMETERS:  pass_number             - 1 or 2
+ *              table_desc              - The table to be parsed.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Perform one complete parse of an ACPI/AML table.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_one_complete_parse (
+	u32                             pass_number,
+	struct acpi_table_desc          *table_desc)
+{
+	union acpi_parse_object         *parse_root;
+	acpi_status                     status;
+	struct acpi_walk_state          *walk_state;
+
+
+	ACPI_FUNCTION_TRACE ("ns_one_complete_parse");
+
+
+	/* Create and init a Root Node */
+
+	parse_root = acpi_ps_create_scope_op ();
+	if (!parse_root) {
+		return_ACPI_STATUS (AE_NO_MEMORY);
+	}
+
+	/* Create and initialize a new walk state */
+
+	walk_state = acpi_ds_create_walk_state (table_desc->table_id,
+			   NULL, NULL, NULL);
+	if (!walk_state) {
+		acpi_ps_free_op (parse_root);
+		return_ACPI_STATUS (AE_NO_MEMORY);
+	}
+
+	status = acpi_ds_init_aml_walk (walk_state, parse_root, NULL, table_desc->aml_start,
+			  table_desc->aml_length, NULL, NULL, pass_number);
+	if (ACPI_FAILURE (status)) {
+		acpi_ds_delete_walk_state (walk_state);
+		return_ACPI_STATUS (status);
+	}
+
+	/* Parse the AML */
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "*PARSE* pass %d parse\n", pass_number));
+	status = acpi_ps_parse_aml (walk_state);
+
+	acpi_ps_delete_parse_tree (parse_root);
+	return_ACPI_STATUS (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_parse_table
+ *
+ * PARAMETERS:  table_desc      - An ACPI table descriptor for table to parse
+ *              start_node      - Where to enter the table into the namespace
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Parse AML within an ACPI table and return a tree of ops
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ns_parse_table (
+	struct acpi_table_desc          *table_desc,
+	struct acpi_namespace_node      *start_node)
+{
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE ("ns_parse_table");
+
+
+	/*
+	 * AML Parse, pass 1
+	 *
+	 * In this pass, we load most of the namespace.  Control methods
+	 * are not parsed until later.  A parse tree is not created.  Instead,
+	 * each Parser Op subtree is deleted when it is finished.  This saves
+	 * a great deal of memory, and allows a small cache of parse objects
+	 * to service the entire parse.  The second pass of the parse then
+	 * performs another complete parse of the AML..
+	 */
+	status = acpi_ns_one_complete_parse (1, table_desc);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/*
+	 * AML Parse, pass 2
+	 *
+	 * In this pass, we resolve forward references and other things
+	 * that could not be completed during the first pass.
+	 * Another complete parse of the AML is performed, but the
+	 * overhead of this is compensated for by the fact that the
+	 * parse objects are all cached.
+	 */
+	status = acpi_ns_one_complete_parse (2, table_desc);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	return_ACPI_STATUS (status);
+}
+
+
diff -urNp linux-5400/drivers/acpi/namespace/nssearch.c linux-5410/drivers/acpi/namespace/nssearch.c
--- linux-5400/drivers/acpi/namespace/nssearch.c
+++ linux-5410/drivers/acpi/namespace/nssearch.c
@@ -1,52 +1,69 @@
 /*******************************************************************************
  *
  * Module Name: nssearch - Namespace search
- *              $Revision: 75 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "amlcode.h"
-#include "acinterp.h"
-#include "acnamesp.h"
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
 
 
 #define _COMPONENT          ACPI_NAMESPACE
-	 MODULE_NAME         ("nssearch")
+	 ACPI_MODULE_NAME    ("nssearch")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_search_node
+ * FUNCTION:    acpi_ns_search_node
  *
- * PARAMETERS:  *Target_name        - Ascii ACPI name to search for
- *              *Node               - Starting table where search will begin
+ * PARAMETERS:  *target_name        - Ascii ACPI name to search for
+ *              *Node               - Starting node where search will begin
  *              Type                - Object type to match
- *              **Return_node       - Where the matched Named obj is returned
+ *              **return_node       - Where the matched Named obj is returned
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Search a single namespace table.  Performs a simple search,
- *              does not add entries or search parents.
+ * DESCRIPTION: Search a single level of the namespace.  Performs a
+ *              simple search of the specified level, and does not add
+ *              entries or search parents.
  *
  *
  *      Named object lists are built (and subsequently dumped) in the
@@ -62,75 +79,52 @@
 
 acpi_status
 acpi_ns_search_node (
-	u32                     target_name,
-	acpi_namespace_node     *node,
-	acpi_object_type8       type,
-	acpi_namespace_node     **return_node)
+	u32                             target_name,
+	struct acpi_namespace_node      *node,
+	acpi_object_type                type,
+	struct acpi_namespace_node      **return_node)
 {
-	acpi_namespace_node     *next_node;
+	struct acpi_namespace_node      *next_node;
 
 
-	FUNCTION_TRACE ("Ns_search_node");
+	ACPI_FUNCTION_TRACE ("ns_search_node");
 
 
-#ifdef ACPI_DEBUG
+#ifdef ACPI_DEBUG_OUTPUT
 	if (ACPI_LV_NAMES & acpi_dbg_level) {
-		NATIVE_CHAR         *scope_name;
+		char                        *scope_name;
 
-		scope_name = acpi_ns_get_table_pathname (node);
+		scope_name = acpi_ns_get_external_pathname (node);
 		if (scope_name) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "Searching %s [%p] For %4.4s (type %X)\n",
-				scope_name, node, (char*)&target_name, type));
+			ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "Searching %s [%p] For %4.4s (%s)\n",
+				scope_name, node, (char *) &target_name, acpi_ut_get_type_name (type)));
 
 			ACPI_MEM_FREE (scope_name);
 		}
 	}
 #endif
 
-
 	/*
-	 * Search for name in this table, which is to say that we must search
-	 * for the name among the children of this object
+	 * Search for name at this namespace level, which is to say that we
+	 * must search for the name among the children of this object
 	 */
 	next_node = node->child;
 	while (next_node) {
 		/* Check for match against the name */
 
-		if (next_node->name == target_name) {
-			/*
-			 * Found matching entry.  Capture the type if appropriate, before
-			 * returning the entry.
-			 *
-			 * The Def_field_defn and Bank_field_defn cases are actually looking up
-			 * the Region in which the field will be defined
-			 */
-			if ((INTERNAL_TYPE_FIELD_DEFN == type) ||
-				(INTERNAL_TYPE_BANK_FIELD_DEFN == type)) {
-				type = ACPI_TYPE_REGION;
-			}
-
+		if (next_node->name.integer == target_name) {
 			/*
-			 * Scope, Def_any, and Index_field_defn are bogus "types" which do not
-			 * actually have anything to do with the type of the name being
-			 * looked up.  For any other value of Type, if the type stored in
-			 * the entry is Any (i.e. unknown), save the actual type.
+			 * Found matching entry.
 			 */
-			if (type != INTERNAL_TYPE_SCOPE &&
-				type != INTERNAL_TYPE_DEF_ANY &&
-				type != INTERNAL_TYPE_INDEX_FIELD_DEFN &&
-				next_node->type == ACPI_TYPE_ANY) {
-				next_node->type = (u8) type;
-			}
-
 			ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
-				"Name %4.4s (actual type %X) found at %p\n",
-				(char*)&target_name, next_node->type, next_node));
+				"Name %4.4s Type [%s] found in scope [%4.4s] %p\n",
+				(char *) &target_name, acpi_ut_get_type_name (next_node->type),
+				next_node->name.ascii, next_node));
 
 			*return_node = next_node;
 			return_ACPI_STATUS (AE_OK);
 		}
 
-
 		/*
 		 * The last entry in the list points back to the parent,
 		 * so a flag is used to indicate the end-of-list
@@ -146,11 +140,12 @@ acpi_ns_search_node (
 		next_node = next_node->peer;
 	}
 
+	/* Searched entire namespace level, not found */
 
-	/* Searched entire table, not found */
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "Name %4.4s (type %X) not found at %p\n",
-		(char*)&target_name, type, next_node));
+	ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
+		"Name %4.4s Type [%s] not found in search in scope [%4.4s] %p first child %p\n",
+		(char *) &target_name, acpi_ut_get_type_name (type),
+		node->name.ascii, node, node->child));
 
 	return_ACPI_STATUS (AE_NOT_FOUND);
 }
@@ -158,18 +153,18 @@ acpi_ns_search_node (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_search_parent_tree
+ * FUNCTION:    acpi_ns_search_parent_tree
  *
- * PARAMETERS:  *Target_name        - Ascii ACPI name to search for
- *              *Node               - Starting table where search will begin
+ * PARAMETERS:  *target_name        - Ascii ACPI name to search for
+ *              *Node               - Starting node where search will begin
  *              Type                - Object type to match
- *              **Return_node       - Where the matched Named Obj is returned
+ *              **return_node       - Where the matched Named Obj is returned
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Called when a name has not been found in the current namespace
- *              table.  Before adding it or giving up, ACPI scope rules require
- *              searching enclosing scopes in cases identified by Acpi_ns_local().
+ *              level.  Before adding it or giving up, ACPI scope rules require
+ *              searching enclosing scopes in cases identified by acpi_ns_local().
  *
  *              "A name is located by finding the matching name in the current
  *              name space, and then in the parent name space. If the parent
@@ -183,55 +178,53 @@ acpi_ns_search_node (
 
 static acpi_status
 acpi_ns_search_parent_tree (
-	u32                     target_name,
-	acpi_namespace_node     *node,
-	acpi_object_type8       type,
-	acpi_namespace_node     **return_node)
+	u32                             target_name,
+	struct acpi_namespace_node      *node,
+	acpi_object_type                type,
+	struct acpi_namespace_node      **return_node)
 {
-	acpi_status             status;
-	acpi_namespace_node     *parent_node;
+	acpi_status                     status;
+	struct acpi_namespace_node      *parent_node;
 
 
-	FUNCTION_TRACE ("Ns_search_parent_tree");
+	ACPI_FUNCTION_TRACE ("ns_search_parent_tree");
 
 
-	parent_node = acpi_ns_get_parent_object (node);
+	parent_node = acpi_ns_get_parent_node (node);
 
 	/*
-	 * If there is no parent (at the root) or type is "local", we won't be
-	 * searching the parent tree.
+	 * If there is no parent (i.e., we are at the root) or
+	 * type is "local", we won't be searching the parent tree.
 	 */
-	if ((acpi_ns_local (type)) ||
-		(!parent_node)) {
-		if (!parent_node) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "[%4.4s] has no parent\n",
-				(char*)&target_name));
-		}
-
-		if (acpi_ns_local (type)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "[%4.4s] type %X is local(no search)\n",
-				(char*)&target_name, type));
-		}
+	if (!parent_node) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "[%4.4s] has no parent\n",
+			(char *) &target_name));
+		 return_ACPI_STATUS (AE_NOT_FOUND);
+	}
 
+	if (acpi_ns_local (type)) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
+			"[%4.4s] type [%s] must be local to this scope (no parent search)\n",
+			(char *) &target_name, acpi_ut_get_type_name (type)));
 		return_ACPI_STATUS (AE_NOT_FOUND);
 	}
 
-
 	/* Search the parent tree */
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "Searching parent for %4.4s\n", (char*)&target_name));
+	ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "Searching parent for %4.4s\n", (char *) &target_name));
 
 	/*
 	 * Search parents until found the target or we have backed up to
 	 * the root
 	 */
 	while (parent_node) {
-		/* Search parent scope */
-		/* TBD: [Investigate] Why ACPI_TYPE_ANY? */
-
+		/*
+		 * Search parent scope.  Use TYPE_ANY because we don't care about the
+		 * object type at this point, we only care about the existence of
+		 * the actual name we are searching for.  Typechecking comes later.
+		 */
 		status = acpi_ns_search_node (target_name, parent_node,
 				   ACPI_TYPE_ANY, return_node);
-
 		if (ACPI_SUCCESS (status)) {
 			return_ACPI_STATUS (status);
 		}
@@ -240,10 +233,9 @@ acpi_ns_search_parent_tree (
 		 * Not found here, go up another level
 		 * (until we reach the root)
 		 */
-		parent_node = acpi_ns_get_parent_object (parent_node);
+		parent_node = acpi_ns_get_parent_node (parent_node);
 	}
 
-
 	/* Not found in parent tree */
 
 	return_ACPI_STATUS (AE_NOT_FOUND);
@@ -252,71 +244,67 @@ acpi_ns_search_parent_tree (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_search_and_enter
+ * FUNCTION:    acpi_ns_search_and_enter
  *
- * PARAMETERS:  Target_name         - Ascii ACPI name to search for (4 chars)
- *              Walk_state          - Current state of the walk
- *              *Node               - Starting table where search will begin
- *              Interpreter_mode    - Add names only in MODE_Load_pass_x.
+ * PARAMETERS:  target_name         - Ascii ACPI name to search for (4 chars)
+ *              walk_state          - Current state of the walk
+ *              *Node               - Starting node where search will begin
+ *              interpreter_mode    - Add names only in ACPI_MODE_LOAD_PASS_x.
  *                                    Otherwise,search only.
  *              Type                - Object type to match
  *              Flags               - Flags describing the search restrictions
- *              **Return_node       - Where the Node is returned
+ *              **return_node       - Where the Node is returned
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Search for a name segment in a single name table,
+ * DESCRIPTION: Search for a name segment in a single namespace level,
  *              optionally adding it if it is not found.  If the passed
  *              Type is not Any and the type previously stored in the
  *              entry was Any (i.e. unknown), update the stored type.
  *
- *              In IMODE_EXECUTE, search only.
+ *              In ACPI_IMODE_EXECUTE, search only.
  *              In other modes, search and add if not found.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_ns_search_and_enter (
-	u32                     target_name,
-	acpi_walk_state         *walk_state,
-	acpi_namespace_node     *node,
-	operating_mode          interpreter_mode,
-	acpi_object_type8       type,
-	u32                     flags,
-	acpi_namespace_node     **return_node)
+	u32                             target_name,
+	struct acpi_walk_state          *walk_state,
+	struct acpi_namespace_node      *node,
+	acpi_interpreter_mode           interpreter_mode,
+	acpi_object_type                type,
+	u32                             flags,
+	struct acpi_namespace_node      **return_node)
 {
-	acpi_status             status;
-	acpi_namespace_node     *new_node;
+	acpi_status                     status;
+	struct acpi_namespace_node      *new_node;
 
 
-	FUNCTION_TRACE ("Ns_search_and_enter");
+	ACPI_FUNCTION_TRACE ("ns_search_and_enter");
 
 
 	/* Parameter validation */
 
 	if (!node || !target_name || !return_node) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Null param-  Table %p Name %X Return %p\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Null param: Node %p Name %X return_node %p\n",
 			node, target_name, return_node));
 
-		REPORT_ERROR (("Ns_search_and_enter: bad (null) parameter\n"));
+		ACPI_REPORT_ERROR (("ns_search_and_enter: Null parameter\n"));
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-
 	/* Name must consist of printable characters */
 
 	if (!acpi_ut_valid_acpi_name (target_name)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "*** Bad character in name: %08x *** \n",
+		ACPI_REPORT_ERROR (("ns_search_and_enter: Bad character in ACPI Name: %X\n",
 			target_name));
-
-		REPORT_ERROR (("Ns_search_and_enter: Bad character in ACPI Name\n"));
 		return_ACPI_STATUS (AE_BAD_CHARACTER);
 	}
 
+	/* Try to find the name in the namespace level specified by the caller */
 
-	/* Try to find the name in the table specified by the caller */
-
-	*return_node = ENTRY_NOT_FOUND;
+	*return_node = ACPI_ENTRY_NOT_FOUND;
 	status = acpi_ns_search_node (target_name, node, type, return_node);
 	if (status != AE_NOT_FOUND) {
 		/*
@@ -324,8 +312,8 @@ acpi_ns_search_and_enter (
 		 * return the error
 		 */
 		if ((status == AE_OK) &&
-			(flags & NS_ERROR_IF_FOUND)) {
-			status = AE_EXIST;
+			(flags & ACPI_NS_ERROR_IF_FOUND)) {
+			status = AE_ALREADY_EXISTS;
 		}
 
 		/*
@@ -335,9 +323,8 @@ acpi_ns_search_and_enter (
 		return_ACPI_STATUS (status);
 	}
 
-
 	/*
-	 * Not found in the table.  If we are NOT performing the
+	 * The name was not found.  If we are NOT performing the
 	 * first pass (name entry) of loading the namespace, search
 	 * the parent tree (all the way to the root if necessary.)
 	 * We don't want to perform the parent search when the
@@ -345,10 +332,10 @@ acpi_ns_search_and_enter (
 	 * the search when namespace references are being resolved
 	 * (load pass 2) and during the execution phase.
 	 */
-	if ((interpreter_mode != IMODE_LOAD_PASS1) &&
-		(flags & NS_SEARCH_PARENT)) {
+	if ((interpreter_mode != ACPI_IMODE_LOAD_PASS1) &&
+		(flags & ACPI_NS_SEARCH_PARENT)) {
 		/*
-		 * Not found in table - search parent tree according
+		 * Not found at this level - search parent tree according
 		 * to ACPI specification
 		 */
 		status = acpi_ns_search_parent_tree (target_name, node,
@@ -358,18 +345,16 @@ acpi_ns_search_and_enter (
 		}
 	}
 
-
 	/*
 	 * In execute mode, just search, never add names.  Exit now.
 	 */
-	if (interpreter_mode == IMODE_EXECUTE) {
+	if (interpreter_mode == ACPI_IMODE_EXECUTE) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "%4.4s Not found in %p [Not adding]\n",
-			(char*)&target_name, node));
+			(char *) &target_name, node));
 
 		return_ACPI_STATUS (AE_NOT_FOUND);
 	}
 
-
 	/* Create the new named object */
 
 	new_node = acpi_ns_create_node (target_name);
diff -urNp linux-5400/drivers/acpi/namespace/nsutils.c linux-5410/drivers/acpi/namespace/nsutils.c
--- linux-5400/drivers/acpi/namespace/nsutils.c
+++ linux-5410/drivers/acpi/namespace/nsutils.c
@@ -2,42 +2,198 @@
  *
  * Module Name: nsutils - Utilities for accessing ACPI namespace, accessing
  *                        parents and siblings and Scope manipulation
- *              $Revision: 92 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acnamesp.h"
-#include "acinterp.h"
-#include "amlcode.h"
-#include "actables.h"
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
+#include <acpi/amlcode.h>
+#include <acpi/actables.h>
 
 #define _COMPONENT          ACPI_NAMESPACE
-	 MODULE_NAME         ("nsutils")
+	 ACPI_MODULE_NAME    ("nsutils")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_valid_root_prefix
+ * FUNCTION:    acpi_ns_report_error
+ *
+ * PARAMETERS:  module_name         - Caller's module name (for error output)
+ *              line_number         - Caller's line number (for error output)
+ *              component_id        - Caller's component ID (for error output)
+ *              Message             - Error message to use on failure
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print warning message with full pathname
+ *
+ ******************************************************************************/
+
+void
+acpi_ns_report_error (
+	char                            *module_name,
+	u32                             line_number,
+	u32                             component_id,
+	char                            *internal_name,
+	acpi_status                     lookup_status)
+{
+	acpi_status                     status;
+	char                            *name = NULL;
+
+
+	acpi_os_printf ("%8s-%04d: *** Error: Looking up ",
+		module_name, line_number);
+
+	if (lookup_status == AE_BAD_CHARACTER) {
+		/* There is a non-ascii character in the name */
+
+		acpi_os_printf ("[0x%4.4X] (NON-ASCII)\n", *(ACPI_CAST_PTR (u32, internal_name)));
+	}
+	else {
+		/* Convert path to external format */
+
+		status = acpi_ns_externalize_name (ACPI_UINT32_MAX, internal_name, NULL, &name);
+
+		/* Print target name */
+
+		if (ACPI_SUCCESS (status)) {
+			acpi_os_printf ("[%s]", name);
+		}
+		else {
+			acpi_os_printf ("[COULD NOT EXTERNALIZE NAME]");
+		}
+
+		if (name) {
+			ACPI_MEM_FREE (name);
+		}
+	}
+
+	acpi_os_printf (" in namespace, %s\n",
+		acpi_format_exception (lookup_status));
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_report_method_error
+ *
+ * PARAMETERS:  module_name         - Caller's module name (for error output)
+ *              line_number         - Caller's line number (for error output)
+ *              component_id        - Caller's component ID (for error output)
+ *              Message             - Error message to use on failure
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print warning message with full pathname
+ *
+ ******************************************************************************/
+
+void
+acpi_ns_report_method_error (
+	char                            *module_name,
+	u32                             line_number,
+	u32                             component_id,
+	char                            *message,
+	struct acpi_namespace_node      *prefix_node,
+	char                            *path,
+	acpi_status                     method_status)
+{
+	acpi_status                     status;
+	struct acpi_namespace_node      *node = prefix_node;
+
+
+	if (path) {
+		status = acpi_ns_get_node_by_path (path, prefix_node, ACPI_NS_NO_UPSEARCH, &node);
+		if (ACPI_FAILURE (status)) {
+			acpi_os_printf ("report_method_error: Could not get node\n");
+			return;
+		}
+	}
+
+	acpi_os_printf ("%8s-%04d: *** Error: ", module_name, line_number);
+	acpi_ns_print_node_pathname (node, message);
+	acpi_os_printf (", %s\n", acpi_format_exception (method_status));
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_print_node_pathname
+ *
+ * PARAMETERS:  Node                - Object
+ *              Msg                 - Prefix message
+ *
+ * DESCRIPTION: Print an object's full namespace pathname
+ *              Manages allocation/freeing of a pathname buffer
+ *
+ ******************************************************************************/
+
+void
+acpi_ns_print_node_pathname (
+	struct acpi_namespace_node      *node,
+	char                            *msg)
+{
+	struct acpi_buffer              buffer;
+	acpi_status                     status;
+
+
+	/* Convert handle to a full pathname and print it (with supplied message) */
+
+	buffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;
+
+	status = acpi_ns_handle_to_pathname (node, &buffer);
+	if (ACPI_SUCCESS (status)) {
+		if (msg) {
+			acpi_os_printf ("%s ", msg);
+		}
+
+		acpi_os_printf ("[%s] (Node %p)", (char *) buffer.pointer, node);
+		ACPI_MEM_FREE (buffer.pointer);
+	}
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_valid_root_prefix
  *
  * PARAMETERS:  Prefix          - Character to be checked
  *
@@ -49,7 +205,7 @@
 
 u8
 acpi_ns_valid_root_prefix (
-	NATIVE_CHAR             prefix)
+	char                            prefix)
 {
 
 	return ((u8) (prefix == '\\'));
@@ -58,7 +214,7 @@ acpi_ns_valid_root_prefix (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_valid_path_separator
+ * FUNCTION:    acpi_ns_valid_path_separator
  *
  * PARAMETERS:  Sep              - Character to be checked
  *
@@ -70,7 +226,7 @@ acpi_ns_valid_root_prefix (
 
 u8
 acpi_ns_valid_path_separator (
-	NATIVE_CHAR             sep)
+	char                            sep)
 {
 
 	return ((u8) (sep == '.'));
@@ -79,7 +235,7 @@ acpi_ns_valid_path_separator (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_get_type
+ * FUNCTION:    acpi_ns_get_type
  *
  * PARAMETERS:  Handle              - Parent Node to be examined
  *
@@ -87,25 +243,25 @@ acpi_ns_valid_path_separator (
  *
  ******************************************************************************/
 
-acpi_object_type8
+acpi_object_type
 acpi_ns_get_type (
-	acpi_namespace_node     *node)
+	struct acpi_namespace_node      *node)
 {
-	FUNCTION_TRACE ("Ns_get_type");
+	ACPI_FUNCTION_TRACE ("ns_get_type");
 
 
 	if (!node) {
-		REPORT_WARNING (("Ns_get_type: Null Node ptr"));
+		ACPI_REPORT_WARNING (("ns_get_type: Null Node ptr"));
 		return_VALUE (ACPI_TYPE_ANY);
 	}
 
-	return_VALUE (node->type);
+	return_VALUE ((acpi_object_type) node->type);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_local
+ * FUNCTION:    acpi_ns_local
  *
  * PARAMETERS:  Type            - A namespace object type
  *
@@ -116,25 +272,25 @@ acpi_ns_get_type (
 
 u32
 acpi_ns_local (
-	acpi_object_type8       type)
+	acpi_object_type                type)
 {
-	FUNCTION_TRACE ("Ns_local");
+	ACPI_FUNCTION_TRACE ("ns_local");
 
 
 	if (!acpi_ut_valid_object_type (type)) {
 		/* Type code out of range  */
 
-		REPORT_WARNING (("Ns_local: Invalid Object Type\n"));
-		return_VALUE (NSP_NORMAL);
+		ACPI_REPORT_WARNING (("ns_local: Invalid Object Type\n"));
+		return_VALUE (ACPI_NS_NORMAL);
 	}
 
-	return_VALUE ((u32) acpi_gbl_ns_properties[type] & NSP_LOCAL);
+	return_VALUE ((u32) acpi_gbl_ns_properties[type] & ACPI_NS_LOCAL);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_get_internal_name_length
+ * FUNCTION:    acpi_ns_get_internal_name_length
  *
  * PARAMETERS:  Info            - Info struct initialized with the
  *                                external name pointer.
@@ -146,15 +302,15 @@ acpi_ns_local (
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ns_get_internal_name_length (
-	acpi_namestring_info    *info)
+	struct acpi_namestring_info     *info)
 {
-	NATIVE_CHAR             *next_external_char;
-	u32                     i;
+	char                            *next_external_char;
+	u32                             i;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	next_external_char = info->external_name;
@@ -164,18 +320,17 @@ acpi_ns_get_internal_name_length (
 
 	/*
 	 * For the internal name, the required length is 4 bytes
-	 * per segment, plus 1 each for Root_prefix, Multi_name_prefix_op,
+	 * per segment, plus 1 each for root_prefix, multi_name_prefix_op,
 	 * segment count, trailing null (which is not really needed,
 	 * but no there's harm in putting it there)
 	 *
-	 * strlen() + 1 covers the first Name_seg, which has no
+	 * strlen() + 1 covers the first name_seg, which has no
 	 * path separator
 	 */
 	if (acpi_ns_valid_root_prefix (next_external_char[0])) {
 		info->fully_qualified = TRUE;
 		next_external_char++;
 	}
-
 	else {
 		/*
 		 * Handle Carat prefixes
@@ -205,14 +360,12 @@ acpi_ns_get_internal_name_length (
 			  4 + info->num_carats;
 
 	info->next_external_char = next_external_char;
-
-	return (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_build_internal_name
+ * FUNCTION:    acpi_ns_build_internal_name
  *
  * PARAMETERS:  Info            - Info struct fully initialized
  *
@@ -225,16 +378,16 @@ acpi_ns_get_internal_name_length (
 
 acpi_status
 acpi_ns_build_internal_name (
-	acpi_namestring_info    *info)
+	struct acpi_namestring_info     *info)
 {
-	u32                     num_segments = info->num_segments;
-	NATIVE_CHAR             *internal_name = info->internal_name;
-	NATIVE_CHAR             *external_name = info->next_external_char;
-	NATIVE_CHAR             *result = NULL;
-	u32                     i;
+	u32                             num_segments = info->num_segments;
+	char                            *internal_name = info->internal_name;
+	char                            *external_name = info->next_external_char;
+	char                            *result = NULL;
+	acpi_native_uint                i;
 
 
-	FUNCTION_TRACE ("Ns_build_internal_name");
+	ACPI_FUNCTION_TRACE ("ns_build_internal_name");
 
 
 	/* Setup the correct prefixes, counts, and pointers */
@@ -255,7 +408,6 @@ acpi_ns_build_internal_name (
 			result = &internal_name[3];
 		}
 	}
-
 	else {
 		/*
 		 * Not fully qualified.
@@ -268,23 +420,20 @@ acpi_ns_build_internal_name (
 			}
 		}
 
-		if (num_segments == 1) {
+		if (num_segments <= 1) {
 			result = &internal_name[i];
 		}
-
 		else if (num_segments == 2) {
 			internal_name[i] = AML_DUAL_NAME_PREFIX;
-			result = &internal_name[i+1];
+			result = &internal_name[(acpi_native_uint) (i+1)];
 		}
-
 		else {
 			internal_name[i] = AML_MULTI_NAME_PREFIX_OP;
-			internal_name[i+1] = (char) num_segments;
-			result = &internal_name[i+2];
+			internal_name[(acpi_native_uint) (i+1)] = (char) num_segments;
+			result = &internal_name[(acpi_native_uint) (i+2)];
 		}
 	}
 
-
 	/* Build the name (minus path separators) */
 
 	for (; num_segments; num_segments--) {
@@ -295,11 +444,10 @@ acpi_ns_build_internal_name (
 
 				result[i] = '_';
 			}
-
 			else {
 				/* Convert the character to uppercase and save it */
 
-				result[i] = (char) TOUPPER (*external_name);
+				result[i] = (char) ACPI_TOUPPER ((int) *external_name);
 				external_name++;
 			}
 		}
@@ -317,18 +465,17 @@ acpi_ns_build_internal_name (
 		result += ACPI_NAME_SIZE;
 	}
 
-
 	/* Terminate the string */
 
 	*result = 0;
 
 	if (info->fully_qualified) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "returning [%p] (abs) \"\\%s\"\n",
-			internal_name, &internal_name[0]));
+			internal_name, internal_name));
 	}
 	else {
 		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "returning [%p] (rel) \"%s\"\n",
-			internal_name, &internal_name[2]));
+			internal_name, internal_name));
 	}
 
 	return_ACPI_STATUS (AE_OK);
@@ -337,9 +484,9 @@ acpi_ns_build_internal_name (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_internalize_name
+ * FUNCTION:    acpi_ns_internalize_name
  *
- * PARAMETERS:  *External_name          - External representation of name
+ * PARAMETERS:  *external_name          - External representation of name
  *              **Converted Name        - Where to return the resulting
  *                                        internal represention of the name
  *
@@ -352,15 +499,15 @@ acpi_ns_build_internal_name (
 
 acpi_status
 acpi_ns_internalize_name (
-	NATIVE_CHAR             *external_name,
-	NATIVE_CHAR             **converted_name)
+	char                            *external_name,
+	char                            **converted_name)
 {
-	NATIVE_CHAR             *internal_name;
-	acpi_namestring_info    info;
-	acpi_status             status;
+	char                            *internal_name;
+	struct acpi_namestring_info     info;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Ns_internalize_name");
+	ACPI_FUNCTION_TRACE ("ns_internalize_name");
 
 
 	if ((!external_name)     ||
@@ -369,7 +516,6 @@ acpi_ns_internalize_name (
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-
 	/* Get the length of the new internal name */
 
 	info.external_name = external_name;
@@ -398,10 +544,10 @@ acpi_ns_internalize_name (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_externalize_name
+ * FUNCTION:    acpi_ns_externalize_name
  *
- * PARAMETERS:  *Internal_name         - Internal representation of name
- *              **Converted_name       - Where to return the resulting
+ * PARAMETERS:  *internal_name         - Internal representation of name
+ *              **converted_name       - Where to return the resulting
  *                                       external representation of name
  *
  * RETURN:      Status
@@ -413,29 +559,28 @@ acpi_ns_internalize_name (
 
 acpi_status
 acpi_ns_externalize_name (
-	u32                     internal_name_length,
-	char                    *internal_name,
-	u32                     *converted_name_length,
-	char                    **converted_name)
-{
-	u32                     prefix_length = 0;
-	u32                     names_index = 0;
-	u32                     names_count = 0;
-	u32                     i = 0;
-	u32                     j = 0;
+	u32                             internal_name_length,
+	char                            *internal_name,
+	u32                             *converted_name_length,
+	char                            **converted_name)
+{
+	acpi_native_uint                names_index = 0;
+	acpi_native_uint                num_segments = 0;
+	acpi_native_uint                required_length;
+	acpi_native_uint                prefix_length = 0;
+	acpi_native_uint                i = 0;
+	acpi_native_uint                j = 0;
 
 
-	FUNCTION_TRACE ("Ns_externalize_name");
+	ACPI_FUNCTION_TRACE ("ns_externalize_name");
 
 
 	if (!internal_name_length   ||
 		!internal_name          ||
-		!converted_name_length  ||
 		!converted_name) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-
 	/*
 	 * Check for a prefix (one '\' | one or more '^').
 	 */
@@ -446,9 +591,12 @@ acpi_ns_externalize_name (
 
 	case '^':
 		for (i = 0; i < internal_name_length; i++) {
-			if (internal_name[i] != '^') {
+			if (internal_name[i] == '^') {
 				prefix_length = i + 1;
 			}
+			else {
+				break;
+			}
 		}
 
 		if (i == internal_name_length) {
@@ -456,6 +604,9 @@ acpi_ns_externalize_name (
 		}
 
 		break;
+
+	default:
+		break;
 	}
 
 	/*
@@ -464,62 +615,61 @@ acpi_ns_externalize_name (
 	 */
 	if (prefix_length < internal_name_length) {
 		switch (internal_name[prefix_length]) {
+		case AML_MULTI_NAME_PREFIX_OP:
 
-		/* <count> 4-byte names */
+			/* <count> 4-byte names */
 
-		case AML_MULTI_NAME_PREFIX_OP:
 			names_index = prefix_length + 2;
-			names_count = (u32) internal_name[prefix_length + 1];
+			num_segments = (acpi_native_uint) (u8) internal_name[(acpi_native_uint) (prefix_length + 1)];
 			break;
 
+		case AML_DUAL_NAME_PREFIX:
 
-		/* two 4-byte names */
+			/* Two 4-byte names */
 
-		case AML_DUAL_NAME_PREFIX:
 			names_index = prefix_length + 1;
-			names_count = 2;
+			num_segments = 2;
 			break;
 
+		case 0:
 
-		/* Null_name */
+			/* null_name */
 
-		case 0:
 			names_index = 0;
-			names_count = 0;
+			num_segments = 0;
 			break;
 
+		default:
 
-		/* one 4-byte name */
+			/* one 4-byte name */
 
-		default:
 			names_index = prefix_length;
-			names_count = 1;
+			num_segments = 1;
 			break;
 		}
 	}
 
 	/*
-	 * Calculate the length of Converted_name, which equals the length
+	 * Calculate the length of converted_name, which equals the length
 	 * of the prefix, length of all object names, length of any required
 	 * punctuation ('.') between object names, plus the NULL terminator.
 	 */
-	*converted_name_length = prefix_length + (4 * names_count) +
-			   ((names_count > 0) ? (names_count - 1) : 0) + 1;
+	required_length = prefix_length + (4 * num_segments) +
+			   ((num_segments > 0) ? (num_segments - 1) : 0) + 1;
 
 	/*
 	 * Check to see if we're still in bounds.  If not, there's a problem
-	 * with Internal_name (invalid format).
+	 * with internal_name (invalid format).
 	 */
-	if (*converted_name_length > internal_name_length) {
-		REPORT_ERROR (("Ns_externalize_name: Invalid internal name\n"));
+	if (required_length > internal_name_length) {
+		ACPI_REPORT_ERROR (("ns_externalize_name: Invalid internal name\n"));
 		return_ACPI_STATUS (AE_BAD_PATHNAME);
 	}
 
 	/*
-	 * Build Converted_name...
+	 * Build converted_name...
 	 */
-
-	(*converted_name) = ACPI_MEM_CALLOCATE (*converted_name_length);
+	*converted_name = ACPI_MEM_CALLOCATE (required_length);
 	if (!(*converted_name)) {
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
@@ -530,8 +680,8 @@ acpi_ns_externalize_name (
 		(*converted_name)[j++] = internal_name[i];
 	}
 
-	if (names_count > 0) {
-		for (i = 0; i < names_count; i++) {
+	if (num_segments > 0) {
+		for (i = 0; i < num_segments; i++) {
 			if (i > 0) {
 				(*converted_name)[j++] = '.';
 			}
@@ -543,13 +693,17 @@ acpi_ns_externalize_name (
 		}
 	}
 
+	if (converted_name_length) {
+		*converted_name_length = (u32) required_length;
+	}
+
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_map_handle_to_node
+ * FUNCTION:    acpi_ns_map_handle_to_node
  *
  * PARAMETERS:  Handle          - Handle to be converted to an Node
  *
@@ -557,20 +711,21 @@ acpi_ns_externalize_name (
  *
  * DESCRIPTION: Convert a namespace handle to a real Node
  *
+ * Note: Real integer handles allow for more verification
+ *       and keep all pointers within this subsystem.
+ *
  ******************************************************************************/
 
-acpi_namespace_node *
+struct acpi_namespace_node *
 acpi_ns_map_handle_to_node (
-	acpi_handle             handle)
+	acpi_handle                     handle)
 {
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	/*
-	 * Simple implementation for now;
-	 * TBD: [Future] Real integer handles allow for more verification
-	 * and keep all pointers within this subsystem!
+	 * Simple implementation.
 	 */
 	if (!handle) {
 		return (NULL);
@@ -580,20 +735,19 @@ acpi_ns_map_handle_to_node (
 		return (acpi_gbl_root_node);
 	}
 
-
 	/* We can at least attempt to verify the handle */
 
-	if (!VALID_DESCRIPTOR_TYPE (handle, ACPI_DESC_TYPE_NAMED)) {
+	if (ACPI_GET_DESCRIPTOR_TYPE (handle) != ACPI_DESC_TYPE_NAMED) {
 		return (NULL);
 	}
 
-	return ((acpi_namespace_node *) handle);
+	return ((struct acpi_namespace_node *) handle);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_convert_entry_to_handle
+ * FUNCTION:    acpi_ns_convert_entry_to_handle
  *
  * PARAMETERS:  Node          - Node to be converted to a Handle
  *
@@ -605,14 +759,12 @@ acpi_ns_map_handle_to_node (
 
 acpi_handle
 acpi_ns_convert_entry_to_handle (
-	acpi_namespace_node         *node)
+	struct acpi_namespace_node          *node)
 {
 
 
 	/*
 	 * Simple implementation for now;
-	 * TBD: [Future] Real integer handles allow for more verification
-	 * and keep all pointers within this subsystem!
 	 */
 	return ((acpi_handle) node);
 
@@ -624,7 +776,7 @@ acpi_ns_convert_entry_to_handle (
 		return (NULL);
 	}
 
-	if (Node == Acpi_gbl_Root_node)
+	if (Node == acpi_gbl_root_node)
 	{
 		return (ACPI_ROOT_OBJECT);
 	}
@@ -637,7 +789,7 @@ acpi_ns_convert_entry_to_handle (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_terminate
+ * FUNCTION:    acpi_ns_terminate
  *
  * PARAMETERS:  none
  *
@@ -650,39 +802,32 @@ acpi_ns_convert_entry_to_handle (
 void
 acpi_ns_terminate (void)
 {
-	acpi_operand_object     *obj_desc;
-	acpi_namespace_node     *this_node;
+	union acpi_operand_object       *obj_desc;
 
 
-	FUNCTION_TRACE ("Ns_terminate");
+	ACPI_FUNCTION_TRACE ("ns_terminate");
 
 
-	this_node = acpi_gbl_root_node;
-
 	/*
-	 * 1) Free the entire namespace -- all objects, tables, and stacks
+	 * 1) Free the entire namespace -- all nodes and objects
 	 *
-	 * Delete all objects linked to the root
-	 * (additional table descriptors)
+	 * Delete all object descriptors attached to namepsace nodes
 	 */
-	acpi_ns_delete_namespace_subtree (this_node);
+	acpi_ns_delete_namespace_subtree (acpi_gbl_root_node);
 
-	/* Detach any object(s) attached to the root */
+	/* Detach any objects attached to the root */
 
-	obj_desc = acpi_ns_get_attached_object (this_node);
+	obj_desc = acpi_ns_get_attached_object (acpi_gbl_root_node);
 	if (obj_desc) {
-		acpi_ns_detach_object (this_node);
-		acpi_ut_remove_reference (obj_desc);
+		acpi_ns_detach_object (acpi_gbl_root_node);
 	}
 
-	acpi_ns_delete_children (this_node);
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Namespace freed\n"));
 
-
 	/*
 	 * 2) Now we can delete the ACPI tables
 	 */
-	acpi_tb_delete_acpi_tables ();
+	acpi_tb_delete_all_tables ();
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "ACPI Tables freed\n"));
 
 	return_VOID;
@@ -691,7 +836,7 @@ acpi_ns_terminate (void)
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_opens_scope
+ * FUNCTION:    acpi_ns_opens_scope
  *
  * PARAMETERS:  Type        - A valid namespace type
  *
@@ -702,34 +847,36 @@ acpi_ns_terminate (void)
 
 u32
 acpi_ns_opens_scope (
-	acpi_object_type8       type)
+	acpi_object_type                type)
 {
-	FUNCTION_TRACE_U32 ("Ns_opens_scope", type);
+	ACPI_FUNCTION_TRACE_STR ("ns_opens_scope", acpi_ut_get_type_name (type));
 
 
 	if (!acpi_ut_valid_object_type (type)) {
 		/* type code out of range  */
 
-		REPORT_WARNING (("Ns_opens_scope: Invalid Object Type\n"));
-		return_VALUE (NSP_NORMAL);
+		ACPI_REPORT_WARNING (("ns_opens_scope: Invalid Object Type %X\n", type));
+		return_VALUE (ACPI_NS_NORMAL);
 	}
 
-	return_VALUE (((u32) acpi_gbl_ns_properties[type]) & NSP_NEWSCOPE);
+	return_VALUE (((u32) acpi_gbl_ns_properties[type]) & ACPI_NS_NEWSCOPE);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_get_node
+ * FUNCTION:    acpi_ns_get_node_by_path
  *
  * PARAMETERS:  *Pathname   - Name to be found, in external (ASL) format. The
  *                            \ (backslash) and ^ (carat) prefixes, and the
  *                            . (period) to separate segments are supported.
- *              Start_node  - Root of subtree to be searched, or NS_ALL for the
+ *              start_node  - Root of subtree to be searched, or NS_ALL for the
  *                            root of the name space.  If Name is fully
  *                            qualified (first s8 is '\'), the passed value
  *                            of Scope will not be accessed.
- *              Return_node - Where the Node is returned
+ *              Flags       - Used to indicate whether to perform upsearch or
+ *                            not.
+ *              return_node - Where the Node is returned
  *
  * DESCRIPTION: Look up a name relative to a given scope and return the
  *              corresponding Node.  NOTE: Scope can be null.
@@ -739,40 +886,36 @@ acpi_ns_opens_scope (
  ******************************************************************************/
 
 acpi_status
-acpi_ns_get_node (
-	NATIVE_CHAR             *pathname,
-	acpi_namespace_node     *start_node,
-	acpi_namespace_node     **return_node)
+acpi_ns_get_node_by_path (
+	char                            *pathname,
+	struct acpi_namespace_node      *start_node,
+	u32                             flags,
+	struct acpi_namespace_node      **return_node)
 {
-	acpi_generic_state      scope_info;
-	acpi_status             status;
-	NATIVE_CHAR             *internal_path = NULL;
+	union acpi_generic_state        scope_info;
+	acpi_status                     status;
+	char                            *internal_path = NULL;
 
 
-	FUNCTION_TRACE_PTR ("Ns_get_node", pathname);
+	ACPI_FUNCTION_TRACE_PTR ("ns_get_node_by_path", pathname);
 
 
-	/* Ensure that the namespace has been initialized */
-
-	if (!acpi_gbl_root_node) {
-		return_ACPI_STATUS (AE_NO_NAMESPACE);
-	}
+	if (pathname) {
+		/* Convert path to internal representation */
 
-	if (!pathname) {
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
+		status = acpi_ns_internalize_name (pathname, &internal_path);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
 	}
 
+	/* Must lock namespace during lookup */
 
-	/* Convert path to internal representation */
-
-	status = acpi_ns_internalize_name (pathname, &internal_path);
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
-
-	acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
-
 	/* Setup lookup scope (search starting point) */
 
 	scope_info.scope.node = start_node;
@@ -780,30 +923,30 @@ acpi_ns_get_node (
 	/* Lookup the name in the namespace */
 
 	status = acpi_ns_lookup (&scope_info, internal_path,
-			 ACPI_TYPE_ANY, IMODE_EXECUTE,
-			 NS_NO_UPSEARCH | NS_DONT_OPEN_SCOPE,
+			 ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
+			 (flags | ACPI_NS_DONT_OPEN_SCOPE),
 			 NULL, return_node);
-
 	if (ACPI_FAILURE (status)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "%s, %s\n",
 				internal_path, acpi_format_exception (status)));
 	}
 
-
-	acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
-
 	/* Cleanup */
 
-	ACPI_MEM_FREE (internal_path);
+	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+
+	if (internal_path) {
+		ACPI_MEM_FREE (internal_path);
+	}
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_find_parent_name
+ * FUNCTION:    acpi_ns_find_parent_name
  *
- * PARAMETERS:  *Child_node            - Named Obj whose name is to be found
+ * PARAMETERS:  *child_node            - Named Obj whose name is to be found
  *
  * RETURN:      The ACPI name
  *
@@ -815,75 +958,39 @@ acpi_ns_get_node (
 
 acpi_name
 acpi_ns_find_parent_name (
-	acpi_namespace_node     *child_node)
+	struct acpi_namespace_node      *child_node)
 {
-	acpi_namespace_node     *parent_node;
+	struct acpi_namespace_node      *parent_node;
 
 
-	FUNCTION_TRACE ("Ns_find_parent_name");
+	ACPI_FUNCTION_TRACE ("ns_find_parent_name");
 
 
 	if (child_node) {
 		/* Valid entry.  Get the parent Node */
 
-		parent_node = acpi_ns_get_parent_object (child_node);
+		parent_node = acpi_ns_get_parent_node (child_node);
 		if (parent_node) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Parent of %p [%4.4s] is %p [%4.4s]\n",
-				child_node, (char*)&child_node->name, parent_node, (char*)&parent_node->name));
+				child_node, child_node->name.ascii,
+				parent_node, parent_node->name.ascii));
 
-			if (parent_node->name) {
-				return_VALUE (parent_node->name);
+			if (parent_node->name.integer) {
+				return_VALUE ((acpi_name) parent_node->name.integer);
 			}
 		}
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "unable to find parent of %p (%4.4s)\n",
-			child_node, (char*)&child_node->name));
+			child_node, child_node->name.ascii));
 	}
 
 	return_VALUE (ACPI_UNKNOWN_NAME);
 }
 
 
-#if defined(ACPI_DEBUG) || defined(ENABLE_DEBUGGER)
-
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_exist_downstream_sibling
- *
- * PARAMETERS:  *Node          - pointer to first Node to examine
- *
- * RETURN:      TRUE if sibling is found, FALSE otherwise
- *
- * DESCRIPTION: Searches remainder of scope being processed to determine
- *              whether there is a downstream sibling to the current
- *              object.  This function is used to determine what type of
- *              line drawing character to use when displaying namespace
- *              trees.
- *
- ******************************************************************************/
-
-u8
-acpi_ns_exist_downstream_sibling (
-	acpi_namespace_node     *node)
-{
-
-	if (!node) {
-		return (FALSE);
-	}
-
-	if (node->name) {
-		return (TRUE);
-	}
-
-	return (FALSE);
-}
-
-#endif /* ACPI_DEBUG */
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ns_get_parent_object
+ * FUNCTION:    acpi_ns_get_parent_node
  *
  * PARAMETERS:  Node       - Current table entry
  *
@@ -894,13 +1001,11 @@ acpi_ns_exist_downstream_sibling (
  ******************************************************************************/
 
 
-acpi_namespace_node *
-acpi_ns_get_parent_object (
-	acpi_namespace_node     *node)
+struct acpi_namespace_node *
+acpi_ns_get_parent_node (
+	struct acpi_namespace_node      *node)
 {
-
-
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	if (!node) {
@@ -925,7 +1030,7 @@ acpi_ns_get_parent_object (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_get_next_valid_node
+ * FUNCTION:    acpi_ns_get_next_valid_node
  *
  * PARAMETERS:  Node       - Current table entry
  *
@@ -938,9 +1043,9 @@ acpi_ns_get_parent_object (
  ******************************************************************************/
 
 
-acpi_namespace_node *
+struct acpi_namespace_node *
 acpi_ns_get_next_valid_node (
-	acpi_namespace_node     *node)
+	struct acpi_namespace_node      *node)
 {
 
 	/* If we are at the end of this peer list, return NULL */
diff -urNp linux-5400/drivers/acpi/namespace/nswalk.c linux-5410/drivers/acpi/namespace/nswalk.c
--- linux-5400/drivers/acpi/namespace/nswalk.c
+++ linux-5410/drivers/acpi/namespace/nswalk.c
@@ -1,49 +1,66 @@
 /******************************************************************************
  *
  * Module Name: nswalk - Functions for walking the ACPI namespace
- *              $Revision: 26 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acinterp.h"
-#include "acnamesp.h"
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
 
 
 #define _COMPONENT          ACPI_NAMESPACE
-	 MODULE_NAME         ("nswalk")
+	 ACPI_MODULE_NAME    ("nswalk")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_get_next_node
+ * FUNCTION:    acpi_ns_get_next_node
  *
  * PARAMETERS:  Type                - Type of node to be searched for
- *              Parent_node         - Parent node whose children we are
+ *              parent_node         - Parent node whose children we are
  *                                     getting
- *              Child_node          - Previous child that was found.
+ *              child_node          - Previous child that was found.
  *                                    The NEXT child will be returned
  *
- * RETURN:      acpi_namespace_node - Pointer to the NEXT child or NULL if
+ * RETURN:      struct acpi_namespace_node - Pointer to the NEXT child or NULL if
  *                                    none is found.
  *
  * DESCRIPTION: Return the next peer node within the namespace.  If Handle
@@ -52,16 +69,16 @@
  *
  ******************************************************************************/
 
-acpi_namespace_node *
+struct acpi_namespace_node *
 acpi_ns_get_next_node (
-	acpi_object_type8       type,
-	acpi_namespace_node     *parent_node,
-	acpi_namespace_node     *child_node)
+	acpi_object_type                type,
+	struct acpi_namespace_node      *parent_node,
+	struct acpi_namespace_node      *child_node)
 {
-	acpi_namespace_node     *next_node = NULL;
+	struct acpi_namespace_node      *next_node = NULL;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	if (!child_node) {
@@ -81,7 +98,7 @@ acpi_ns_get_next_node (
 	/* If any type is OK, we are done */
 
 	if (type == ACPI_TYPE_ANY) {
-		/* Next_node is NULL if we are at the end-of-list */
+		/* next_node is NULL if we are at the end-of-list */
 
 		return (next_node);
 	}
@@ -108,22 +125,22 @@ acpi_ns_get_next_node (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ns_walk_namespace
+ * FUNCTION:    acpi_ns_walk_namespace
  *
  * PARAMETERS:  Type                - acpi_object_type to search for
- *              Start_node          - Handle in namespace where search begins
- *              Max_depth           - Depth to which search is to reach
- *              Unlock_before_callback- Whether to unlock the NS before invoking
+ *              start_node          - Handle in namespace where search begins
+ *              max_depth           - Depth to which search is to reach
+ *              unlock_before_callback- Whether to unlock the NS before invoking
  *                                    the callback routine
- *              User_function       - Called when an object of "Type" is found
+ *              user_function       - Called when an object of "Type" is found
  *              Context             - Passed to user function
- *              Return_value        - from the User_function if terminated early.
+ *              return_value        - from the user_function if terminated early.
  *                                    Otherwise, returns NULL.
  * RETURNS:     Status
  *
  * DESCRIPTION: Performs a modified depth-first walk of the namespace tree,
- *              starting (and ending) at the node specified by Start_handle.
- *              The User_function is called whenever a node that matches
+ *              starting (and ending) at the node specified by start_handle.
+ *              The user_function is called whenever a node that matches
  *              the type parameter is found.  If the user function returns
  *              a non-zero value, the search is terminated immediately and this
  *              value is returned to the caller.
@@ -138,22 +155,23 @@ acpi_ns_get_next_node (
 
 acpi_status
 acpi_ns_walk_namespace (
-	acpi_object_type8       type,
-	acpi_handle             start_node,
-	u32                     max_depth,
-	u8                      unlock_before_callback,
-	acpi_walk_callback      user_function,
-	void                    *context,
-	void                    **return_value)
+	acpi_object_type                type,
+	acpi_handle                     start_node,
+	u32                             max_depth,
+	u8                              unlock_before_callback,
+	acpi_walk_callback              user_function,
+	void                            *context,
+	void                            **return_value)
 {
-	acpi_status             status;
-	acpi_namespace_node     *child_node;
-	acpi_namespace_node     *parent_node;
-	acpi_object_type8        child_type;
-	u32                     level;
+	acpi_status                     status;
+	acpi_status                     mutex_status;
+	struct acpi_namespace_node      *child_node;
+	struct acpi_namespace_node      *parent_node;
+	acpi_object_type                child_type;
+	u32                             level;
 
 
-	FUNCTION_TRACE ("Ns_walk_namespace");
+	ACPI_FUNCTION_TRACE ("ns_walk_namespace");
 
 
 	/* Special case for the namespace Root Node */
@@ -172,7 +190,7 @@ acpi_ns_walk_namespace (
 	/*
 	 * Traverse the tree of nodes until we bubble back up to where we
 	 * started. When Level is zero, the loop is done because we have
-	 * bubbled up to (and passed) the original parent handle (Start_entry)
+	 * bubbled up to (and passed) the original parent handle (start_entry)
 	 */
 	while (level > 0) {
 		/* Get the next node in this scope.  Null if not found */
@@ -194,14 +212,20 @@ acpi_ns_walk_namespace (
 				 * callback function
 				 */
 				if (unlock_before_callback) {
-					acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+					mutex_status = acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+					if (ACPI_FAILURE (mutex_status)) {
+						return_ACPI_STATUS (mutex_status);
+					}
 				}
 
 				status = user_function (child_node, level,
 						 context, return_value);
 
 				if (unlock_before_callback) {
-					acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+					mutex_status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+					if (ACPI_FAILURE (mutex_status)) {
+						return_ACPI_STATUS (mutex_status);
+					}
 				}
 
 				switch (status) {
@@ -216,14 +240,12 @@ acpi_ns_walk_namespace (
 					/* Exit now, with OK status */
 
 					return_ACPI_STATUS (AE_OK);
-					break;
 
 				default:
 
 					/* All others are valid exceptions */
 
 					return_ACPI_STATUS (status);
-					break;
 				}
 			}
 
@@ -247,16 +269,15 @@ acpi_ns_walk_namespace (
 				}
 			}
 		}
-
 		else {
 			/*
-			 * No more children of this node (Acpi_ns_get_next_node
+			 * No more children of this node (acpi_ns_get_next_node
 			 * failed), go back upwards in the namespace tree to
 			 * the node's parent.
 			 */
 			level--;
 			child_node = parent_node;
-			parent_node = acpi_ns_get_parent_object (parent_node);
+			parent_node = acpi_ns_get_parent_node (parent_node);
 		}
 	}
 
diff -urNp linux-5400/drivers/acpi/namespace/nsxfeval.c linux-5410/drivers/acpi/namespace/nsxfeval.c
--- linux-5400/drivers/acpi/namespace/nsxfeval.c
+++ linux-5410/drivers/acpi/namespace/nsxfeval.c
@@ -0,0 +1,747 @@
+/*******************************************************************************
+ *
+ * Module Name: nsxfeval - Public interfaces to the ACPI subsystem
+ *                         ACPI Object evaluation interfaces
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
+
+
+#define _COMPONENT          ACPI_NAMESPACE
+	 ACPI_MODULE_NAME    ("nsxfeval")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_evaluate_object_typed
+ *
+ * PARAMETERS:  Handle              - Object handle (optional)
+ *              *Pathname           - Object pathname (optional)
+ *              **external_params   - List of parameters to pass to method,
+ *                                    terminated by NULL.  May be NULL
+ *                                    if no parameters are being passed.
+ *              *return_buffer      - Where to put method's return value (if
+ *                                    any).  If NULL, no value is returned.
+ *              return_type         - Expected type of return object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Find and evaluate the given object, passing the given
+ *              parameters if necessary.  One of "Handle" or "Pathname" must
+ *              be valid (non-null)
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_evaluate_object_typed (
+	acpi_handle                     handle,
+	acpi_string                     pathname,
+	struct acpi_object_list         *external_params,
+	struct acpi_buffer              *return_buffer,
+	acpi_object_type                return_type)
+{
+	acpi_status                     status;
+	u8                              must_free = FALSE;
+
+
+	ACPI_FUNCTION_TRACE ("acpi_evaluate_object_typed");
+
+
+	/* Return buffer must be valid */
+
+	if (!return_buffer) {
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
+
+	if (return_buffer->length == ACPI_ALLOCATE_BUFFER) {
+		must_free = TRUE;
+	}
+
+	/* Evaluate the object */
+
+	status = acpi_evaluate_object (handle, pathname, external_params, return_buffer);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/* Type ANY means "don't care" */
+
+	if (return_type == ACPI_TYPE_ANY) {
+		return_ACPI_STATUS (AE_OK);
+	}
+
+	if (return_buffer->length == 0) {
+		/* Error because caller specifically asked for a return value */
+
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"No return value\n"));
+
+		return_ACPI_STATUS (AE_NULL_OBJECT);
+	}
+
+	/* Examine the object type returned from evaluate_object */
+
+	if (((union acpi_object *) return_buffer->pointer)->type == return_type) {
+		return_ACPI_STATUS (AE_OK);
+	}
+
+	/* Return object type does not match requested type */
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+		"Incorrect return type [%s] requested [%s]\n",
+		acpi_ut_get_type_name (((union acpi_object *) return_buffer->pointer)->type),
+		acpi_ut_get_type_name (return_type)));
+
+	if (must_free) {
+		/* Caller used ACPI_ALLOCATE_BUFFER, free the return buffer */
+
+		acpi_os_free (return_buffer->pointer);
+		return_buffer->pointer = NULL;
+	}
+
+	return_buffer->length = 0;
+	return_ACPI_STATUS (AE_TYPE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_evaluate_object
+ *
+ * PARAMETERS:  Handle              - Object handle (optional)
+ *              *Pathname           - Object pathname (optional)
+ *              **external_params   - List of parameters to pass to method,
+ *                                    terminated by NULL.  May be NULL
+ *                                    if no parameters are being passed.
+ *              *return_buffer      - Where to put method's return value (if
+ *                                    any).  If NULL, no value is returned.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Find and evaluate the given object, passing the given
+ *              parameters if necessary.  One of "Handle" or "Pathname" must
+ *              be valid (non-null)
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_evaluate_object (
+	acpi_handle                     handle,
+	acpi_string                     pathname,
+	struct acpi_object_list         *external_params,
+	struct acpi_buffer              *return_buffer)
+{
+	acpi_status                     status;
+	union acpi_operand_object       **internal_params = NULL;
+	union acpi_operand_object       *internal_return_obj = NULL;
+	acpi_size                       buffer_space_needed;
+	u32                             i;
+
+
+	ACPI_FUNCTION_TRACE ("acpi_evaluate_object");
+
+
+	/*
+	 * If there are parameters to be passed to the object
+	 * (which must be a control method), the external objects
+	 * must be converted to internal objects
+	 */
+	if (external_params && external_params->count) {
+		/*
+		 * Allocate a new parameter block for the internal objects
+		 * Add 1 to count to allow for null terminated internal list
+		 */
+		internal_params = ACPI_MEM_CALLOCATE (((acpi_size) external_params->count + 1) *
+				  sizeof (void *));
+		if (!internal_params) {
+			return_ACPI_STATUS (AE_NO_MEMORY);
+		}
+
+		/*
+		 * Convert each external object in the list to an
+		 * internal object
+		 */
+		for (i = 0; i < external_params->count; i++) {
+			status = acpi_ut_copy_eobject_to_iobject (&external_params->pointer[i],
+					 &internal_params[i]);
+			if (ACPI_FAILURE (status)) {
+				acpi_ut_delete_internal_object_list (internal_params);
+				return_ACPI_STATUS (status);
+			}
+		}
+		internal_params[external_params->count] = NULL;
+	}
+
+	/*
+	 * Three major cases:
+	 * 1) Fully qualified pathname
+	 * 2) No handle, not fully qualified pathname (error)
+	 * 3) Valid handle
+	 */
+	if ((pathname) &&
+		(acpi_ns_valid_root_prefix (pathname[0]))) {
+		/*
+		 *  The path is fully qualified, just evaluate by name
+		 */
+		status = acpi_ns_evaluate_by_name (pathname, internal_params,
+				 &internal_return_obj);
+	}
+	else if (!handle) {
+		/*
+		 * A handle is optional iff a fully qualified pathname
+		 * is specified.  Since we've already handled fully
+		 * qualified names above, this is an error
+		 */
+		if (!pathname) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Both Handle and Pathname are NULL\n"));
+		}
+		else {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Handle is NULL and Pathname is relative\n"));
+		}
+
+		status = AE_BAD_PARAMETER;
+	}
+	else {
+		/*
+		 * We get here if we have a handle -- and if we have a
+		 * pathname it is relative.  The handle will be validated
+		 * in the lower procedures
+		 */
+		if (!pathname) {
+			/*
+			 * The null pathname case means the handle is for
+			 * the actual object to be evaluated
+			 */
+			status = acpi_ns_evaluate_by_handle (handle, internal_params,
+					  &internal_return_obj);
+		}
+		else {
+		   /*
+			* Both a Handle and a relative Pathname
+			*/
+			status = acpi_ns_evaluate_relative (handle, pathname, internal_params,
+					  &internal_return_obj);
+		}
+	}
+
+
+	/*
+	 * If we are expecting a return value, and all went well above,
+	 * copy the return value to an external object.
+	 */
+	if (return_buffer) {
+		if (!internal_return_obj) {
+			return_buffer->length = 0;
+		}
+		else {
+			if (ACPI_GET_DESCRIPTOR_TYPE (internal_return_obj) == ACPI_DESC_TYPE_NAMED) {
+				/*
+				 * If we received a NS Node as a return object, this means that
+				 * the object we are evaluating has nothing interesting to
+				 * return (such as a mutex, etc.)  We return an error because
+				 * these types are essentially unsupported by this interface.
+				 * We don't check up front because this makes it easier to add
+				 * support for various types at a later date if necessary.
+				 */
+				status = AE_TYPE;
+				internal_return_obj = NULL; /* No need to delete a NS Node */
+				return_buffer->length = 0;
+			}
+
+			if (ACPI_SUCCESS (status)) {
+				/*
+				 * Find out how large a buffer is needed
+				 * to contain the returned object
+				 */
+				status = acpi_ut_get_object_size (internal_return_obj,
+						   &buffer_space_needed);
+				if (ACPI_SUCCESS (status)) {
+					/* Validate/Allocate/Clear caller buffer */
+
+					status = acpi_ut_initialize_buffer (return_buffer, buffer_space_needed);
+					if (ACPI_FAILURE (status)) {
+						/*
+						 * Caller's buffer is too small or a new one can't be allocated
+						 */
+						ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+							"Needed buffer size %X, %s\n",
+							(u32) buffer_space_needed, acpi_format_exception (status)));
+					}
+					else {
+						/*
+						 *  We have enough space for the object, build it
+						 */
+						status = acpi_ut_copy_iobject_to_eobject (internal_return_obj,
+								  return_buffer);
+					}
+				}
+			}
+		}
+	}
+
+	/* Delete the return and parameter objects */
+
+	if (internal_return_obj) {
+		/*
+		 * Delete the internal return object. (Or at least
+		 * decrement the reference count by one)
+		 */
+		acpi_ut_remove_reference (internal_return_obj);
+	}
+
+	/*
+	 * Free the input parameter list (if we created one),
+	 */
+	if (internal_params) {
+		/* Free the allocated parameter block */
+
+		acpi_ut_delete_internal_object_list (internal_params);
+	}
+
+	return_ACPI_STATUS (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_walk_namespace
+ *
+ * PARAMETERS:  Type                - acpi_object_type to search for
+ *              start_object        - Handle in namespace where search begins
+ *              max_depth           - Depth to which search is to reach
+ *              user_function       - Called when an object of "Type" is found
+ *              Context             - Passed to user function
+ *              return_value        - Location where return value of
+ *                                    user_function is put if terminated early
+ *
+ * RETURNS      Return value from the user_function if terminated early.
+ *              Otherwise, returns NULL.
+ *
+ * DESCRIPTION: Performs a modified depth-first walk of the namespace tree,
+ *              starting (and ending) at the object specified by start_handle.
+ *              The user_function is called whenever an object that matches
+ *              the type parameter is found.  If the user function returns
+ *              a non-zero value, the search is terminated immediately and this
+ *              value is returned to the caller.
+ *
+ *              The point of this procedure is to provide a generic namespace
+ *              walk routine that can be called from multiple places to
+ *              provide multiple services;  the User Function can be tailored
+ *              to each task, whether it is a print function, a compare
+ *              function, etc.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_walk_namespace (
+	acpi_object_type                type,
+	acpi_handle                     start_object,
+	u32                             max_depth,
+	acpi_walk_callback              user_function,
+	void                            *context,
+	void                            **return_value)
+{
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE ("acpi_walk_namespace");
+
+
+	/* Parameter validation */
+
+	if ((type > ACPI_TYPE_EXTERNAL_MAX) ||
+		(!max_depth)                    ||
+		(!user_function)) {
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
+
+	/*
+	 * Lock the namespace around the walk.
+	 * The namespace will be unlocked/locked around each call
+	 * to the user function - since this function
+	 * must be allowed to make Acpi calls itself.
+	 */
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	status = acpi_ns_walk_namespace (type, start_object, max_depth, ACPI_NS_WALK_UNLOCK,
+			  user_function, context, return_value);
+
+	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	return_ACPI_STATUS (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ns_get_device_callback
+ *
+ * PARAMETERS:  Callback from acpi_get_device
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Takes callbacks from walk_namespace and filters out all non-
+ *              present devices, or if they specified a HID, it filters based
+ *              on that.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ns_get_device_callback (
+	acpi_handle                     obj_handle,
+	u32                             nesting_level,
+	void                            *context,
+	void                            **return_value)
+{
+	struct acpi_get_devices_info    *info = context;
+	acpi_status                     status;
+	struct acpi_namespace_node      *node;
+	u32                             flags;
+	struct acpi_device_id           hid;
+	struct acpi_compatible_id_list *cid;
+	acpi_native_uint                i;
+
+
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
+
+	node = acpi_ns_map_handle_to_node (obj_handle);
+	status = acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
+
+	if (!node) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* Run _STA to determine if device is present */
+
+	status = acpi_ut_execute_STA (node, &flags);
+	if (ACPI_FAILURE (status)) {
+		return (AE_CTRL_DEPTH);
+	}
+
+	if (!(flags & 0x01)) {
+		/* Don't return at the device or children of the device if not there */
+
+		return (AE_CTRL_DEPTH);
+	}
+
+	/* Filter based on device HID & CID */
+
+	if (info->hid != NULL) {
+		status = acpi_ut_execute_HID (node, &hid);
+		if (status == AE_NOT_FOUND) {
+			return (AE_OK);
+		}
+		else if (ACPI_FAILURE (status)) {
+			return (AE_CTRL_DEPTH);
+		}
+
+		if (ACPI_STRNCMP (hid.value, info->hid, sizeof (hid.value)) != 0) {
+			/* Get the list of Compatible IDs */
+
+			status = acpi_ut_execute_CID (node, &cid);
+			if (status == AE_NOT_FOUND) {
+				return (AE_OK);
+			}
+			else if (ACPI_FAILURE (status)) {
+				return (AE_CTRL_DEPTH);
+			}
+
+			/* Walk the CID list */
+
+			for (i = 0; i < cid->count; i++) {
+				if (ACPI_STRNCMP (cid->id[i].value, info->hid,
+						 sizeof (struct acpi_compatible_id)) != 0) {
+					ACPI_MEM_FREE (cid);
+					return (AE_OK);
+				}
+			}
+			ACPI_MEM_FREE (cid);
+		}
+	}
+
+	status = info->user_function (obj_handle, nesting_level, info->context, return_value);
+	return (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_devices
+ *
+ * PARAMETERS:  HID                 - HID to search for. Can be NULL.
+ *              user_function       - Called when a matching object is found
+ *              Context             - Passed to user function
+ *              return_value        - Location where return value of
+ *                                    user_function is put if terminated early
+ *
+ * RETURNS      Return value from the user_function if terminated early.
+ *              Otherwise, returns NULL.
+ *
+ * DESCRIPTION: Performs a modified depth-first walk of the namespace tree,
+ *              starting (and ending) at the object specified by start_handle.
+ *              The user_function is called whenever an object of type
+ *              Device is found.  If the user function returns
+ *              a non-zero value, the search is terminated immediately and this
+ *              value is returned to the caller.
+ *
+ *              This is a wrapper for walk_namespace, but the callback performs
+ *              additional filtering. Please see acpi_get_device_callback.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_get_devices (
+	char                            *HID,
+	acpi_walk_callback              user_function,
+	void                            *context,
+	void                            **return_value)
+{
+	acpi_status                     status;
+	struct acpi_get_devices_info    info;
+
+
+	ACPI_FUNCTION_TRACE ("acpi_get_devices");
+
+
+	/* Parameter validation */
+
+	if (!user_function) {
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
+
+	/*
+	 * We're going to call their callback from OUR callback, so we need
+	 * to know what it is, and their context parameter.
+	 */
+	info.context      = context;
+	info.user_function = user_function;
+	info.hid          = HID;
+
+	/*
+	 * Lock the namespace around the walk.
+	 * The namespace will be unlocked/locked around each call
+	 * to the user function - since this function
+	 * must be allowed to make Acpi calls itself.
+	 */
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	status = acpi_ns_walk_namespace (ACPI_TYPE_DEVICE,
+			   ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
+			   ACPI_NS_WALK_UNLOCK,
+			   acpi_ns_get_device_callback, &info,
+			   return_value);
+
+	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	return_ACPI_STATUS (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_attach_data
+ *
+ * PARAMETERS:  obj_handle          - Namespace node
+ *              Handler             - Handler for this attachment
+ *              Data                - Pointer to data to be attached
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Attach arbitrary data and handler to a namespace node.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_attach_data (
+	acpi_handle                     obj_handle,
+	acpi_object_handler             handler,
+	void                            *data)
+{
+	struct acpi_namespace_node      *node;
+	acpi_status                     status;
+
+
+	/* Parameter validation */
+
+	if (!obj_handle ||
+		!handler    ||
+		!data) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
+
+	/* Convert and validate the handle */
+
+	node = acpi_ns_map_handle_to_node (obj_handle);
+	if (!node) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	status = acpi_ns_attach_data (node, handler, data);
+
+unlock_and_exit:
+	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	return (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_detach_data
+ *
+ * PARAMETERS:  obj_handle          - Namespace node handle
+ *              Handler             - Handler used in call to acpi_attach_data
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Remove data that was previously attached to a node.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_detach_data (
+	acpi_handle                     obj_handle,
+	acpi_object_handler             handler)
+{
+	struct acpi_namespace_node      *node;
+	acpi_status                     status;
+
+
+	/* Parameter validation */
+
+	if (!obj_handle ||
+		!handler) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
+
+	/* Convert and validate the handle */
+
+	node = acpi_ns_map_handle_to_node (obj_handle);
+	if (!node) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	status = acpi_ns_detach_data (node, handler);
+
+unlock_and_exit:
+	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	return (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_get_data
+ *
+ * PARAMETERS:  obj_handle          - Namespace node
+ *              Handler             - Handler used in call to attach_data
+ *              Data                - Where the data is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Retrieve data that was previously attached to a namespace node.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_get_data (
+	acpi_handle                     obj_handle,
+	acpi_object_handler             handler,
+	void                            **data)
+{
+	struct acpi_namespace_node      *node;
+	acpi_status                     status;
+
+
+	/* Parameter validation */
+
+	if (!obj_handle ||
+		!handler    ||
+		!data) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
+
+	/* Convert and validate the handle */
+
+	node = acpi_ns_map_handle_to_node (obj_handle);
+	if (!node) {
+		status = AE_BAD_PARAMETER;
+		goto unlock_and_exit;
+	}
+
+	status = acpi_ns_get_attached_data (node, handler, data);
+
+unlock_and_exit:
+	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	return (status);
+}
+
+
diff -urNp linux-5400/drivers/acpi/namespace/nsxfname.c linux-5410/drivers/acpi/namespace/nsxfname.c
--- linux-5400/drivers/acpi/namespace/nsxfname.c
+++ linux-5410/drivers/acpi/namespace/nsxfname.c
@@ -2,50 +2,63 @@
  *
  * Module Name: nsxfname - Public interfaces to the ACPI subsystem
  *                         ACPI Namespace oriented interfaces
- *              $Revision: 82 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acinterp.h"
-#include "acnamesp.h"
-#include "amlcode.h"
-#include "acparser.h"
-#include "acdispat.h"
-#include "acevents.h"
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
 
 
 #define _COMPONENT          ACPI_NAMESPACE
-	 MODULE_NAME         ("nsxfname")
+	 ACPI_MODULE_NAME    ("nsxfname")
 
 
-/****************************************************************************
+/******************************************************************************
  *
- * FUNCTION:    Acpi_get_handle
+ * FUNCTION:    acpi_get_handle
  *
  * PARAMETERS:  Parent          - Object to search under (search scope).
- *              Path_name       - Pointer to an asciiz string containing the
+ *              path_name       - Pointer to an asciiz string containing the
  *                                  name
- *              Ret_handle      - Where the return handle is placed
+ *              ret_handle      - Where the return handle is placed
  *
  * RETURN:      Status
  *
@@ -58,16 +71,16 @@
 
 acpi_status
 acpi_get_handle (
-	acpi_handle             parent,
-	acpi_string             pathname,
-	acpi_handle             *ret_handle)
+	acpi_handle                     parent,
+	acpi_string                     pathname,
+	acpi_handle                     *ret_handle)
 {
-	acpi_status             status;
-	acpi_namespace_node     *node = NULL;
-	acpi_namespace_node     *prefix_node = NULL;
+	acpi_status                     status;
+	struct acpi_namespace_node      *node = NULL;
+	struct acpi_namespace_node      *prefix_node = NULL;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	/* Parameter Validation */
@@ -79,20 +92,26 @@ acpi_get_handle (
 	/* Convert a parent handle to a prefix node */
 
 	if (parent) {
-		acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+		status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+		if (ACPI_FAILURE (status)) {
+			return (status);
+		}
 
 		prefix_node = acpi_ns_map_handle_to_node (parent);
 		if (!prefix_node) {
-			acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+			(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 			return (AE_BAD_PARAMETER);
 		}
 
-		acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+		status = acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+		if (ACPI_FAILURE (status)) {
+			return (status);
+		}
 	}
 
 	/* Special case for root, since we can't search for it */
 
-	if (STRCMP (pathname, NS_ROOT_PATH) == 0) {
+	if (ACPI_STRCMP (pathname, ACPI_NS_ROOT_PATH) == 0) {
 		*ret_handle = acpi_ns_convert_entry_to_handle (acpi_gbl_root_node);
 		return (AE_OK);
 	}
@@ -100,7 +119,8 @@ acpi_get_handle (
 	/*
 	 *  Find the Node and convert to a handle
 	 */
-	status = acpi_ns_get_node (pathname, prefix_node, &node);
+	status = acpi_ns_get_node_by_path (pathname, prefix_node, ACPI_NS_NO_UPSEARCH,
+			  &node);
 
 	*ret_handle = NULL;
 	if (ACPI_SUCCESS (status)) {
@@ -111,90 +131,90 @@ acpi_get_handle (
 }
 
 
-/****************************************************************************
+/******************************************************************************
  *
- * FUNCTION:    Acpi_get_name
+ * FUNCTION:    acpi_get_name
  *
  * PARAMETERS:  Handle          - Handle to be converted to a pathname
- *              Name_type       - Full pathname or single segment
- *              Ret_path_ptr    - Buffer for returned path
+ *              name_type       - Full pathname or single segment
+ *              Buffer          - Buffer for returned path
  *
  * RETURN:      Pointer to a string containing the fully qualified Name.
  *
  * DESCRIPTION: This routine returns the fully qualified name associated with
- *              the Handle parameter.  This and the Acpi_pathname_to_handle are
+ *              the Handle parameter.  This and the acpi_pathname_to_handle are
  *              complementary functions.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_get_name (
-	acpi_handle             handle,
-	u32                     name_type,
-	acpi_buffer             *ret_path_ptr)
+	acpi_handle                     handle,
+	u32                             name_type,
+	struct acpi_buffer              *buffer)
 {
-	acpi_status             status;
-	acpi_namespace_node     *node;
+	acpi_status                     status;
+	struct acpi_namespace_node      *node;
 
 
-	/* Buffer pointer must be valid always */
+	/* Parameter validation */
 
-	if (!ret_path_ptr || (name_type > ACPI_NAME_TYPE_MAX)) {
+	if (name_type > ACPI_NAME_TYPE_MAX) {
 		return (AE_BAD_PARAMETER);
 	}
 
-	/* Allow length to be zero and ignore the pointer */
-
-	if ((ret_path_ptr->length) &&
-	   (!ret_path_ptr->pointer)) {
-		return (AE_BAD_PARAMETER);
+	status = acpi_ut_validate_buffer (buffer);
+	if (ACPI_FAILURE (status)) {
+		return (status);
 	}
 
 	if (name_type == ACPI_FULL_PATHNAME) {
 		/* Get the full pathname (From the namespace root) */
 
-		status = acpi_ns_handle_to_pathname (handle, &ret_path_ptr->length,
-				   ret_path_ptr->pointer);
+		status = acpi_ns_handle_to_pathname (handle, buffer);
 		return (status);
 	}
 
 	/*
 	 * Wants the single segment ACPI name.
-	 * Validate handle and convert to an Node
+	 * Validate handle and convert to a namespace Node
 	 */
-	acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
+
 	node = acpi_ns_map_handle_to_node (handle);
 	if (!node) {
 		status = AE_BAD_PARAMETER;
 		goto unlock_and_exit;
 	}
 
-	/* Check if name will fit in buffer */
+	/* Validate/Allocate/Clear caller buffer */
 
-	if (ret_path_ptr->length < PATH_SEGMENT_LENGTH) {
-		ret_path_ptr->length = PATH_SEGMENT_LENGTH;
-		status = AE_BUFFER_OVERFLOW;
+	status = acpi_ut_initialize_buffer (buffer, ACPI_PATH_SEGMENT_LENGTH);
+	if (ACPI_FAILURE (status)) {
 		goto unlock_and_exit;
 	}
 
 	/* Just copy the ACPI name from the Node and zero terminate it */
 
-	STRNCPY (ret_path_ptr->pointer, (NATIVE_CHAR *) &node->name,
+	ACPI_STRNCPY (buffer->pointer, node->name.ascii,
 			 ACPI_NAME_SIZE);
-	((NATIVE_CHAR *) ret_path_ptr->pointer) [ACPI_NAME_SIZE] = 0;
+	((char *) buffer->pointer) [ACPI_NAME_SIZE] = 0;
 	status = AE_OK;
 
 
 unlock_and_exit:
 
-	acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 	return (status);
 }
 
 
-/****************************************************************************
+/******************************************************************************
  *
- * FUNCTION:    Acpi_get_object_info
+ * FUNCTION:    acpi_get_object_info
  *
  * PARAMETERS:  Handle          - Object Handle
  *              Info            - Where the info is returned
@@ -209,93 +229,127 @@ unlock_and_exit:
 
 acpi_status
 acpi_get_object_info (
-	acpi_handle             handle,
-	acpi_device_info        *info)
+	acpi_handle                     handle,
+	struct acpi_buffer              *buffer)
 {
-	acpi_device_id          hid;
-	acpi_device_id          uid;
-	acpi_status             status;
-	u32                     device_status = 0;
-	acpi_integer            address = 0;
-	acpi_namespace_node     *node;
+	acpi_status                     status;
+	struct acpi_namespace_node      *node;
+	struct acpi_device_info         info;
+	struct acpi_device_info         *return_info;
+	struct acpi_compatible_id_list *cid_list = NULL;
+	acpi_size                       size;
 
 
 	/* Parameter validation */
 
-	if (!handle || !info) {
+	if (!handle || !buffer) {
 		return (AE_BAD_PARAMETER);
 	}
 
-	acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	status = acpi_ut_validate_buffer (buffer);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
+
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
 
 	node = acpi_ns_map_handle_to_node (handle);
 	if (!node) {
-		acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+		(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 		return (AE_BAD_PARAMETER);
 	}
 
-	info->type      = node->type;
-	info->name      = node->name;
+	/* Init return structure */
 
-	acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	size = sizeof (struct acpi_device_info);
+	ACPI_MEMSET (&info, 0, size);
 
-	/*
-	 * If not a device, we are all done.
-	 */
-	if (info->type != ACPI_TYPE_DEVICE) {
-		return (AE_OK);
+	info.type  = node->type;
+	info.name  = node->name.integer;
+	info.valid = 0;
+
+	status = acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return (status);
 	}
 
+	/* If not a device, we are all done */
 
-	/*
-	 * Get extra info for ACPI devices only.  Run the
-	 * _HID, _UID, _STA, and _ADR methods.  Note: none
-	 * of these methods are required, so they may or may
-	 * not be present.  The Info->Valid bits are used
-	 * to indicate which methods ran successfully.
-	 */
-	info->valid = 0;
+	if (info.type == ACPI_TYPE_DEVICE) {
+		/*
+		 * Get extra info for ACPI Devices objects only:
+		 * Run the Device _HID, _UID, _CID, _STA, and _ADR methods.
+		 *
+		 * Note: none of these methods are required, so they may or may
+		 * not be present for this device.  The Info.Valid bitfield is used
+		 * to indicate which methods were found and ran successfully.
+		 */
+
+		/* Execute the Device._HID method */
+
+		status = acpi_ut_execute_HID (node, &info.hardware_id);
+		if (ACPI_SUCCESS (status)) {
+			info.valid |= ACPI_VALID_HID;
+		}
 
-	/* Execute the _HID method and save the result */
+		/* Execute the Device._UID method */
 
-	status = acpi_ut_execute_HID (node, &hid);
-	if (ACPI_SUCCESS (status)) {
-		STRNCPY (info->hardware_id, hid.buffer, sizeof(info->hardware_id));
+		status = acpi_ut_execute_UID (node, &info.unique_id);
+		if (ACPI_SUCCESS (status)) {
+			info.valid |= ACPI_VALID_UID;
+		}
 
-		info->valid |= ACPI_VALID_HID;
-	}
+		/* Execute the Device._CID method */
 
-	/* Execute the _UID method and save the result */
+		status = acpi_ut_execute_CID (node, &cid_list);
+		if (ACPI_SUCCESS (status)) {
+			size += ((acpi_size) cid_list->count - 1) *
+					 sizeof (struct acpi_compatible_id);
+			info.valid |= ACPI_VALID_CID;
+		}
 
-	status = acpi_ut_execute_UID (node, &uid);
-	if (ACPI_SUCCESS (status)) {
-		STRCPY (info->unique_id, uid.buffer);
+		/* Execute the Device._STA method */
 
-		info->valid |= ACPI_VALID_UID;
+		status = acpi_ut_execute_STA (node, &info.current_status);
+		if (ACPI_SUCCESS (status)) {
+			info.valid |= ACPI_VALID_STA;
+		}
+
+		/* Execute the Device._ADR method */
+
+		status = acpi_ut_evaluate_numeric_object (METHOD_NAME__ADR, node,
+				  &info.address);
+		if (ACPI_SUCCESS (status)) {
+			info.valid |= ACPI_VALID_ADR;
+		}
+
+		status = AE_OK;
 	}
 
-	/*
-	 * Execute the _STA method and save the result
-	 * _STA is not always present
-	 */
-	status = acpi_ut_execute_STA (node, &device_status);
-	if (ACPI_SUCCESS (status)) {
-		info->current_status = device_status;
-		info->valid |= ACPI_VALID_STA;
+	/* Validate/Allocate/Clear caller buffer */
+
+	status = acpi_ut_initialize_buffer (buffer, size);
+	if (ACPI_FAILURE (status)) {
+		goto cleanup;
 	}
 
-	/*
-	 * Execute the _ADR method and save result if successful
-	 * _ADR is not always present
-	 */
-	status = acpi_ut_evaluate_numeric_object (METHOD_NAME__ADR,
-			  node, &address);
+	/* Populate the return buffer */
 
-	if (ACPI_SUCCESS (status)) {
-		info->address = address;
-		info->valid |= ACPI_VALID_ADR;
+	return_info = buffer->pointer;
+	ACPI_MEMCPY (return_info, &info, sizeof (struct acpi_device_info));
+
+	if (cid_list) {
+		ACPI_MEMCPY (&return_info->compatibility_id, cid_list, cid_list->size);
 	}
 
-	return (AE_OK);
+
+cleanup:
+	if (cid_list) {
+		ACPI_MEM_FREE (cid_list);
+	}
+	return (status);
 }
 
diff -urNp linux-5400/drivers/acpi/namespace/nsxfobj.c linux-5410/drivers/acpi/namespace/nsxfobj.c
--- linux-5400/drivers/acpi/namespace/nsxfobj.c
+++ linux-5410/drivers/acpi/namespace/nsxfobj.c
@@ -2,345 +2,60 @@
  *
  * Module Name: nsxfobj - Public interfaces to the ACPI subsystem
  *                         ACPI Object oriented interfaces
- *              $Revision: 95 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acinterp.h"
-#include "acnamesp.h"
-#include "acdispat.h"
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
 
 
 #define _COMPONENT          ACPI_NAMESPACE
-	 MODULE_NAME         ("nsxfobj")
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_evaluate_object
- *
- * PARAMETERS:  Handle              - Object handle (optional)
- *              *Pathname           - Object pathname (optional)
- *              **External_params   - List of parameters to pass to method,
- *                                    terminated by NULL.  May be NULL
- *                                    if no parameters are being passed.
- *              *Return_buffer      - Where to put method's return value (if
- *                                    any).  If NULL, no value is returned.
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Find and evaluate the given object, passing the given
- *              parameters if necessary.  One of "Handle" or "Pathname" must
- *              be valid (non-null)
- *
- ******************************************************************************/
-
-acpi_status
-acpi_evaluate_object (
-	acpi_handle             handle,
-	acpi_string             pathname,
-	acpi_object_list        *external_params,
-	acpi_buffer             *return_buffer)
-{
-	acpi_status             status;
-	acpi_operand_object     **internal_params = NULL;
-	acpi_operand_object     *internal_return_obj = NULL;
-	u32                     buffer_space_needed;
-	u32                     user_buffer_length;
-	u32                     i;
-
-
-	FUNCTION_TRACE ("Acpi_evaluate_object");
-
-
-	/*
-	 * If there are parameters to be passed to the object
-	 * (which must be a control method), the external objects
-	 * must be converted to internal objects
-	 */
-	if (external_params && external_params->count) {
-		/*
-		 * Allocate a new parameter block for the internal objects
-		 * Add 1 to count to allow for null terminated internal list
-		 */
-		internal_params = ACPI_MEM_CALLOCATE ((external_params->count + 1) * sizeof (void *));
-		if (!internal_params) {
-			return_ACPI_STATUS (AE_NO_MEMORY);
-		}
-
-
-		/*
-		 * Convert each external object in the list to an
-		 * internal object
-		 */
-		for (i = 0; i < external_params->count; i++) {
-			status = acpi_ut_copy_eobject_to_iobject (&external_params->pointer[i],
-					 &internal_params[i]);
-
-			if (ACPI_FAILURE (status)) {
-				acpi_ut_delete_internal_object_list (internal_params);
-				return_ACPI_STATUS (status);
-			}
-		}
-		internal_params[external_params->count] = NULL;
-	}
-
-
-	/*
-	 * Three major cases:
-	 * 1) Fully qualified pathname
-	 * 2) No handle, not fully qualified pathname (error)
-	 * 3) Valid handle
-	 */
-	if ((pathname) &&
-		(acpi_ns_valid_root_prefix (pathname[0]))) {
-		/*
-		 *  The path is fully qualified, just evaluate by name
-		 */
-		status = acpi_ns_evaluate_by_name (pathname, internal_params, &internal_return_obj);
-	}
-
-	else if (!handle) {
-		/*
-		 * A handle is optional iff a fully qualified pathname
-		 * is specified.  Since we've already handled fully
-		 * qualified names above, this is an error
-		 */
-		if (!pathname) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Both Handle and Pathname are NULL\n"));
-		}
-
-		else {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Handle is NULL and Pathname is relative\n"));
-		}
-
-		status = AE_BAD_PARAMETER;
-	}
-
-	else {
-		/*
-		 * We get here if we have a handle -- and if we have a
-		 * pathname it is relative.  The handle will be validated
-		 * in the lower procedures
-		 */
-		if (!pathname) {
-			/*
-			 * The null pathname case means the handle is for
-			 * the actual object to be evaluated
-			 */
-			status = acpi_ns_evaluate_by_handle (handle, internal_params, &internal_return_obj);
-		}
-
-		else {
-		   /*
-			* Both a Handle and a relative Pathname
-			*/
-			status = acpi_ns_evaluate_relative (handle, pathname, internal_params,
-					 &internal_return_obj);
-		}
-	}
-
-
-	/*
-	 * If we are expecting a return value, and all went well above,
-	 * copy the return value to an external object.
-	 */
-
-	if (return_buffer) {
-		user_buffer_length = return_buffer->length;
-		return_buffer->length = 0;
-
-		if (internal_return_obj) {
-			if (VALID_DESCRIPTOR_TYPE (internal_return_obj, ACPI_DESC_TYPE_NAMED)) {
-				/*
-				 * If we got an Node as a return object,
-				 * this means the object we are evaluating
-				 * has nothing interesting to return (such
-				 * as a mutex, etc.)  We return an error
-				 * because these types are essentially
-				 * unsupported by this interface.  We
-				 * don't check up front because this makes
-				 * it easier to add support for various
-				 * types at a later date if necessary.
-				 */
-				status = AE_TYPE;
-				internal_return_obj = NULL; /* No need to delete an Node */
-			}
-
-			if (ACPI_SUCCESS (status)) {
-				/*
-				 * Find out how large a buffer is needed
-				 * to contain the returned object
-				 */
-				status = acpi_ut_get_object_size (internal_return_obj,
-						   &buffer_space_needed);
-				if (ACPI_SUCCESS (status)) {
-					/*
-					 * Check if there is enough room in the
-					 * caller's buffer
-					 */
-					if (user_buffer_length < buffer_space_needed) {
-						/*
-						 * Caller's buffer is too small, can't
-						 * give him partial results fail the call
-						 * but return the buffer size needed
-						 */
-						ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-							"Needed buffer size %X, received %X\n",
-							buffer_space_needed, user_buffer_length));
-
-						return_buffer->length = buffer_space_needed;
-						status = AE_BUFFER_OVERFLOW;
-					}
-
-					else {
-						/*
-						 *  We have enough space for the object, build it
-						 */
-						status = acpi_ut_copy_iobject_to_eobject (internal_return_obj,
-								  return_buffer);
-						return_buffer->length = buffer_space_needed;
-					}
-				}
-			}
-		}
-	}
-
-
-	/* Delete the return and parameter objects */
-
-	if (internal_return_obj) {
-		/*
-		 * Delete the internal return object. (Or at least
-		 * decrement the reference count by one)
-		 */
-		acpi_ut_remove_reference (internal_return_obj);
-	}
-
-	/*
-	 * Free the input parameter list (if we created one),
-	 */
-	if (internal_params) {
-		/* Free the allocated parameter block */
-
-		acpi_ut_delete_internal_object_list (internal_params);
-	}
-
-	return_ACPI_STATUS (status);
-}
-
+	 ACPI_MODULE_NAME    ("nsxfobj")
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_get_next_object
- *
- * PARAMETERS:  Type            - Type of object to be searched for
- *              Parent          - Parent object whose children we are getting
- *              Last_child      - Previous child that was found.
- *                                The NEXT child will be returned
- *              Ret_handle      - Where handle to the next object is placed
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Return the next peer object within the namespace.  If Handle is
- *              valid, Scope is ignored.  Otherwise, the first object within
- *              Scope is returned.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_get_next_object (
-	acpi_object_type        type,
-	acpi_handle             parent,
-	acpi_handle             child,
-	acpi_handle             *ret_handle)
-{
-	acpi_status             status = AE_OK;
-	acpi_namespace_node     *node;
-	acpi_namespace_node     *parent_node = NULL;
-	acpi_namespace_node     *child_node = NULL;
-
-
-	/* Parameter validation */
-
-	if (type > ACPI_TYPE_MAX) {
-		return (AE_BAD_PARAMETER);
-	}
-
-	acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
-
-	/* If null handle, use the parent */
-
-	if (!child) {
-		/* Start search at the beginning of the specified scope */
-
-		parent_node = acpi_ns_map_handle_to_node (parent);
-		if (!parent_node) {
-			status = AE_BAD_PARAMETER;
-			goto unlock_and_exit;
-		}
-	}
-
-	/* Non-null handle, ignore the parent */
-
-	else {
-		/* Convert and validate the handle */
-
-		child_node = acpi_ns_map_handle_to_node (child);
-		if (!child_node) {
-			status = AE_BAD_PARAMETER;
-			goto unlock_and_exit;
-		}
-	}
-
-
-	/* Internal function does the real work */
-
-	node = acpi_ns_get_next_node ((acpi_object_type8) type,
-			   parent_node, child_node);
-	if (!node) {
-		status = AE_NOT_FOUND;
-		goto unlock_and_exit;
-	}
-
-	if (ret_handle) {
-		*ret_handle = acpi_ns_convert_entry_to_handle (node);
-	}
-
-
-unlock_and_exit:
-
-	acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
-	return (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_get_type
+ * FUNCTION:    acpi_get_type
  *
  * PARAMETERS:  Handle          - Handle of object whose type is desired
- *              *Ret_type       - Where the type will be placed
+ *              *ret_type       - Where the type will be placed
  *
  * RETURN:      Status
  *
@@ -350,10 +65,11 @@ unlock_and_exit:
 
 acpi_status
 acpi_get_type (
-	acpi_handle             handle,
-	acpi_object_type        *ret_type)
+	acpi_handle                     handle,
+	acpi_object_type                *ret_type)
 {
-	acpi_namespace_node     *node;
+	struct acpi_namespace_node      *node;
+	acpi_status                     status;
 
 
 	/* Parameter Validation */
@@ -371,30 +87,33 @@ acpi_get_type (
 		return (AE_OK);
 	}
 
-	acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
 
 	/* Convert and validate the handle */
 
 	node = acpi_ns_map_handle_to_node (handle);
 	if (!node) {
-		acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+		(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 		return (AE_BAD_PARAMETER);
 	}
 
 	*ret_type = node->type;
 
 
-	acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
-	return (AE_OK);
+	status = acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	return (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_get_parent
+ * FUNCTION:    acpi_get_parent
  *
  * PARAMETERS:  Handle          - Handle of object whose parent is desired
- *              Ret_handle      - Where the parent handle will be placed
+ *              ret_handle      - Where the parent handle will be placed
  *
  * RETURN:      Status
  *
@@ -405,11 +124,11 @@ acpi_get_type (
 
 acpi_status
 acpi_get_parent (
-	acpi_handle             handle,
-	acpi_handle             *ret_handle)
+	acpi_handle                     handle,
+	acpi_handle                     *ret_handle)
 {
-	acpi_namespace_node     *node;
-	acpi_status             status = AE_OK;
+	struct acpi_namespace_node      *node;
+	acpi_status                     status;
 
 
 	if (!ret_handle) {
@@ -422,8 +141,10 @@ acpi_get_parent (
 		return (AE_NULL_ENTRY);
 	}
 
-
-	acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
 
 	/* Convert and validate the handle */
 
@@ -433,237 +154,106 @@ acpi_get_parent (
 		goto unlock_and_exit;
 	}
 
-
 	/* Get the parent entry */
 
 	*ret_handle =
-		acpi_ns_convert_entry_to_handle (acpi_ns_get_parent_object (node));
+		acpi_ns_convert_entry_to_handle (acpi_ns_get_parent_node (node));
 
-	/* Return exeption if parent is null */
+	/* Return exception if parent is null */
 
-	if (!acpi_ns_get_parent_object (node)) {
+	if (!acpi_ns_get_parent_node (node)) {
 		status = AE_NULL_ENTRY;
 	}
 
 
 unlock_and_exit:
 
-	acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 	return (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_walk_namespace
- *
- * PARAMETERS:  Type                - acpi_object_type to search for
- *              Start_object        - Handle in namespace where search begins
- *              Max_depth           - Depth to which search is to reach
- *              User_function       - Called when an object of "Type" is found
- *              Context             - Passed to user function
- *              Return_value        - Location where return value of
- *                                    User_function is put if terminated early
- *
- * RETURNS      Return value from the User_function if terminated early.
- *              Otherwise, returns NULL.
- *
- * DESCRIPTION: Performs a modified depth-first walk of the namespace tree,
- *              starting (and ending) at the object specified by Start_handle.
- *              The User_function is called whenever an object that matches
- *              the type parameter is found.  If the user function returns
- *              a non-zero value, the search is terminated immediately and this
- *              value is returned to the caller.
- *
- *              The point of this procedure is to provide a generic namespace
- *              walk routine that can be called from multiple places to
- *              provide multiple services;  the User Function can be tailored
- *              to each task, whether it is a print function, a compare
- *              function, etc.
+ * FUNCTION:    acpi_get_next_object
  *
- ******************************************************************************/
-
-acpi_status
-acpi_walk_namespace (
-	acpi_object_type        type,
-	acpi_handle             start_object,
-	u32                     max_depth,
-	acpi_walk_callback      user_function,
-	void                    *context,
-	void                    **return_value)
-{
-	acpi_status             status;
-
-
-	FUNCTION_TRACE ("Acpi_walk_namespace");
-
-
-	/* Parameter validation */
-
-	if ((type > ACPI_TYPE_MAX)  ||
-		(!max_depth)            ||
-		(!user_function)) {
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * Lock the namespace around the walk.
-	 * The namespace will be unlocked/locked around each call
-	 * to the user function - since this function
-	 * must be allowed to make Acpi calls itself.
-	 */
-	acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
-	status = acpi_ns_walk_namespace ((acpi_object_type8) type, start_object,
-			  max_depth, NS_WALK_UNLOCK, user_function, context,
-			  return_value);
-
-	acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
-
-	return_ACPI_STATUS (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ns_get_device_callback
- *
- * PARAMETERS:  Callback from Acpi_get_device
+ * PARAMETERS:  Type            - Type of object to be searched for
+ *              Parent          - Parent object whose children we are getting
+ *              last_child      - Previous child that was found.
+ *                                The NEXT child will be returned
+ *              ret_handle      - Where handle to the next object is placed
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Takes callbacks from Walk_namespace and filters out all non-
- *              present devices, or if they specified a HID, it filters based
- *              on that.
+ * DESCRIPTION: Return the next peer object within the namespace.  If Handle is
+ *              valid, Scope is ignored.  Otherwise, the first object within
+ *              Scope is returned.
  *
  ******************************************************************************/
 
-static acpi_status
-acpi_ns_get_device_callback (
-	acpi_handle             obj_handle,
-	u32                     nesting_level,
-	void                    *context,
-	void                    **return_value)
+acpi_status
+acpi_get_next_object (
+	acpi_object_type                type,
+	acpi_handle                     parent,
+	acpi_handle                     child,
+	acpi_handle                     *ret_handle)
 {
-	acpi_status             status;
-	acpi_namespace_node     *node;
-	u32                     flags;
-	acpi_device_id          device_id;
-	acpi_get_devices_info   *info;
+	acpi_status                     status;
+	struct acpi_namespace_node      *node;
+	struct acpi_namespace_node      *parent_node = NULL;
+	struct acpi_namespace_node      *child_node = NULL;
 
 
-	info = context;
-
-	acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
-	node = acpi_ns_map_handle_to_node (obj_handle);
-	acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	/* Parameter validation */
 
-	if (!node) {
+	if (type > ACPI_TYPE_EXTERNAL_MAX) {
 		return (AE_BAD_PARAMETER);
 	}
 
-	/*
-	 * Run _STA to determine if device is present
-	 */
-	status = acpi_ut_execute_STA (node, &flags);
+	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
 	if (ACPI_FAILURE (status)) {
-		return (AE_CTRL_DEPTH);
+		return (status);
 	}
 
-	if (!(flags & 0x01)) {
-		/* don't return at the device or children of the device if not there */
-		return (AE_CTRL_DEPTH);
-	}
+	/* If null handle, use the parent */
 
-	/*
-	 * Filter based on device HID
-	 */
-	if (info->hid != NULL) {
-		status = acpi_ut_execute_HID (node, &device_id);
-		if (status == AE_NOT_FOUND) {
-			return (AE_OK);
-		}
+	if (!child) {
+		/* Start search at the beginning of the specified scope */
 
-		else if (ACPI_FAILURE (status)) {
-			return (AE_CTRL_DEPTH);
+		parent_node = acpi_ns_map_handle_to_node (parent);
+		if (!parent_node) {
+			status = AE_BAD_PARAMETER;
+			goto unlock_and_exit;
 		}
+	}
+	else {
+		/* Non-null handle, ignore the parent */
+		/* Convert and validate the handle */
 
-		if (STRNCMP (device_id.buffer, info->hid, sizeof (device_id.buffer)) != 0) {
-			return (AE_OK);
+		child_node = acpi_ns_map_handle_to_node (child);
+		if (!child_node) {
+			status = AE_BAD_PARAMETER;
+			goto unlock_and_exit;
 		}
 	}
 
-	info->user_function (obj_handle, nesting_level, info->context, return_value);
-	return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_get_devices
- *
- * PARAMETERS:  HID                 - HID to search for. Can be NULL.
- *              User_function       - Called when a matching object is found
- *              Context             - Passed to user function
- *              Return_value        - Location where return value of
- *                                    User_function is put if terminated early
- *
- * RETURNS      Return value from the User_function if terminated early.
- *              Otherwise, returns NULL.
- *
- * DESCRIPTION: Performs a modified depth-first walk of the namespace tree,
- *              starting (and ending) at the object specified by Start_handle.
- *              The User_function is called whenever an object that matches
- *              the type parameter is found.  If the user function returns
- *              a non-zero value, the search is terminated immediately and this
- *              value is returned to the caller.
- *
- *              This is a wrapper for Walk_namespace, but the callback performs
- *              additional filtering. Please see Acpi_get_device_callback.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_get_devices (
-	NATIVE_CHAR             *HID,
-	acpi_walk_callback      user_function,
-	void                    *context,
-	void                    **return_value)
-{
-	acpi_status             status;
-	acpi_get_devices_info   info;
-
-
-	FUNCTION_TRACE ("Acpi_get_devices");
-
-
-	/* Parameter validation */
+	/* Internal function does the real work */
 
-	if (!user_function) {
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	node = acpi_ns_get_next_node (type, parent_node, child_node);
+	if (!node) {
+		status = AE_NOT_FOUND;
+		goto unlock_and_exit;
 	}
 
-	/*
-	 * We're going to call their callback from OUR callback, so we need
-	 * to know what it is, and their context parameter.
-	 */
-	info.context      = context;
-	info.user_function = user_function;
-	info.hid          = HID;
+	if (ret_handle) {
+		*ret_handle = acpi_ns_convert_entry_to_handle (node);
+	}
 
-	/*
-	 * Lock the namespace around the walk.
-	 * The namespace will be unlocked/locked around each call
-	 * to the user function - since this function
-	 * must be allowed to make Acpi calls itself.
-	 */
-	acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
-	status = acpi_ns_walk_namespace (ACPI_TYPE_DEVICE,
-			   ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
-			   NS_WALK_UNLOCK,
-			   acpi_ns_get_device_callback, &info,
-			   return_value);
 
-	acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+unlock_and_exit:
 
-	return_ACPI_STATUS (status);
+	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+	return (status);
 }
+
+
diff -urNp linux-5400/drivers/acpi/numa.c linux-5410/drivers/acpi/numa.c
--- linux-5400/drivers/acpi/numa.c
+++ linux-5410/drivers/acpi/numa.c
@@ -0,0 +1,187 @@
+/*
+ *  acpi_numa.c - ACPI NUMA support
+ *
+ *  Copyright (C) 2002 Takayoshi Kochi <t-kochi@bq.jp.nec.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/acpi.h>
+
+#define PREFIX			"ACPI: "
+
+extern int __init acpi_table_parse_madt_family (enum acpi_table_id id, unsigned long madt_size, int entry_id, acpi_madt_entry_handler handler);
+
+void __init
+acpi_table_print_srat_entry (
+	acpi_table_entry_header	*header)
+{
+	if (!header)
+		return;
+
+	switch (header->type) {
+
+	case ACPI_SRAT_PROCESSOR_AFFINITY:
+	{
+		struct acpi_table_processor_affinity *p =
+			(struct acpi_table_processor_affinity*) header;
+		printk(KERN_INFO PREFIX "SRAT Processor (id[0x%02x] eid[0x%02x]) in proximity domain %d %s\n",
+		       p->apic_id, p->lsapic_eid, p->proximity_domain,
+		       p->flags.enabled?"enabled":"disabled");
+	}
+		break;
+
+	case ACPI_SRAT_MEMORY_AFFINITY:
+	{
+		struct acpi_table_memory_affinity *p =
+			(struct acpi_table_memory_affinity*) header;
+		printk(KERN_INFO PREFIX "SRAT Memory (0x%08x%08x length 0x%08x%08x type 0x%x) in proximity domain %d %s%s\n",
+		       p->base_addr_hi, p->base_addr_lo, p->length_hi, p->length_lo,
+		       p->memory_type, p->proximity_domain,
+		       p->flags.enabled ? "enabled" : "disabled",
+		       p->flags.hot_pluggable ? " hot-pluggable" : "");
+	}
+		break;
+
+	default:
+		printk(KERN_WARNING PREFIX "Found unsupported SRAT entry (type = 0x%x)\n",
+			header->type);
+		break;
+	}
+}
+
+
+static int __init
+acpi_parse_slit (unsigned long phys_addr, unsigned long size)
+{
+	struct acpi_table_slit	*slit;
+	u32			localities;
+
+	if (!phys_addr || !size)
+		return -EINVAL;
+
+	slit = (struct acpi_table_slit *) __va(phys_addr);
+
+	/* downcast just for %llu vs %lu for i386/ia64  */
+	localities = (u32) slit->localities;
+
+	printk(KERN_INFO PREFIX "SLIT localities %ux%u\n", localities, localities);
+
+	acpi_numa_slit_init(slit);
+
+	return 0;
+}
+
+
+static int __init
+acpi_parse_processor_affinity (acpi_table_entry_header *header)
+{
+	struct acpi_table_processor_affinity *processor_affinity = NULL;
+
+	processor_affinity = (struct acpi_table_processor_affinity*) header;
+	if (!processor_affinity)
+		return -EINVAL;
+
+	acpi_table_print_srat_entry(header);
+
+	/* let architecture-dependent part to do it */
+	acpi_numa_processor_affinity_init(processor_affinity);
+
+	return 0;
+}
+
+
+static int __init
+acpi_parse_memory_affinity (acpi_table_entry_header *header)
+{
+	struct acpi_table_memory_affinity *memory_affinity = NULL;
+
+	memory_affinity = (struct acpi_table_memory_affinity*) header;
+	if (!memory_affinity)
+		return -EINVAL;
+
+	acpi_table_print_srat_entry(header);
+
+	/* let architecture-dependent part to do it */
+	acpi_numa_memory_affinity_init(memory_affinity);
+
+	return 0;
+}
+
+
+static int __init
+acpi_parse_srat (unsigned long phys_addr, unsigned long size)
+{
+	struct acpi_table_srat	*srat = NULL;
+
+	if (!phys_addr || !size)
+		return -EINVAL;
+
+	srat = (struct acpi_table_srat *) __va(phys_addr);
+
+	printk(KERN_INFO PREFIX "SRAT revision %d\n", srat->table_revision);
+
+	return 0;
+}
+
+
+int __init
+acpi_table_parse_srat (
+	enum acpi_srat_entry_id	id,
+	acpi_madt_entry_handler	handler)
+{
+	return acpi_table_parse_madt_family(ACPI_SRAT, sizeof(struct acpi_table_srat),
+					    id, handler);
+}
+
+
+int __init
+acpi_numa_init()
+{
+	int			result;
+
+	/* SRAT: Static Resource Affinity Table */
+	result = acpi_table_parse(ACPI_SRAT, acpi_parse_srat);
+
+	if (result > 0) {
+		result = acpi_table_parse_srat(ACPI_SRAT_PROCESSOR_AFFINITY,
+					       acpi_parse_processor_affinity);
+		result = acpi_table_parse_srat(ACPI_SRAT_MEMORY_AFFINITY,
+					       acpi_parse_memory_affinity);
+	} else {
+		/* FIXME */
+		printk("Warning: acpi_table_parse(ACPI_SRAT) returned %d!\n",result);
+	}
+
+	/* SLIT: System Locality Information Table */
+	result = acpi_table_parse(ACPI_SLIT, acpi_parse_slit);
+	if (result < 1) {
+		/* FIXME */
+		printk("Warning: acpi_table_parse(ACPI_SLIT) returned %d!\n",result);
+	}
+
+	acpi_numa_arch_fixup();
+	return 0;
+}
diff -urNp linux-5400/drivers/acpi/os.c linux-5410/drivers/acpi/os.c
--- linux-5400/drivers/acpi/os.c
+++ linux-5410/drivers/acpi/os.c
@@ -1,920 +0,0 @@
-/******************************************************************************
- * 
- * Module Name: os.c - Linux OSL functions
- *		$Revision: 49 $
- *
- *****************************************************************************/
-
-/*
- *  os.c - OS-dependent functions
- *
- *  Copyright (C) 2000 Andrew Henroid
- *  Copyright (C) 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-/* Changes
- *
- * Christopher Liebman <liebman@sponsera.com> 2001-5-15
- * - Fixed improper kernel_thread parameters 
- */
-
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/mm.h>
-#include <linux/pci.h>
-#include <linux/interrupt.h>
-#include <linux/kmod.h>
-#include <linux/delay.h>
-#include <asm/io.h>
-#include <acpi.h>
-
-#ifdef CONFIG_ACPI_EFI
-#include <linux/efi.h>
-#endif
-
-#ifdef _IA64
-#include <asm/hw_irq.h>
-#endif 
-
-#define _COMPONENT	ACPI_OS_SERVICES
-	MODULE_NAME	("os")
-
-typedef struct 
-{
-    OSD_EXECUTION_CALLBACK  function;
-    void		    *context;
-} ACPI_OS_DPC;
-
-
-/*****************************************************************************
- *			       Debugger Stuff
- *****************************************************************************/
-
-#ifdef ENABLE_DEBUGGER
-
-#include <linux/kdb.h>
-
-/* stuff for debugger support */
-int acpi_in_debugger = 0;
-extern NATIVE_CHAR line_buf[80];
-
-#endif
-
-
-/*****************************************************************************
- *				    Globals
- *****************************************************************************/
-
-static int acpi_irq_irq = 0;
-static OSD_HANDLER acpi_irq_handler = NULL;
-static void *acpi_irq_context = NULL;
-
-
-/******************************************************************************
- *				   Functions
- *****************************************************************************/
-
-acpi_status
-acpi_os_initialize(void)
-{
-	return AE_OK;
-}
-
-acpi_status
-acpi_os_terminate(void)
-{
-	if (acpi_irq_handler) {
-		acpi_os_remove_interrupt_handler(acpi_irq_irq,
-						 acpi_irq_handler);
-	}
-
-	return AE_OK;
-}
-
-s32
-acpi_os_printf(const NATIVE_CHAR *fmt,...)
-{
-	s32 size;
-	va_list args;
-	va_start(args, fmt);
-	size = acpi_os_vprintf(fmt, args);
-	va_end(args);
-
-	return size;
-}
-
-s32
-acpi_os_vprintf(const NATIVE_CHAR *fmt, va_list args)
-{
-	static char buffer[512];
-	int size = vsprintf(buffer, fmt, args);
-
-#ifdef ENABLE_DEBUGGER
-	if (acpi_in_debugger) {
-		kdb_printf("%s", buffer);
-	} else {
-		printk("%s", buffer);
-	}
-#else
-	printk("%s", buffer);
-#endif
-
-	return size;
-}
-
-void *
-acpi_os_allocate(u32 size)
-{
-	return kmalloc(size, GFP_KERNEL);
-}
-
-void *
-acpi_os_callocate(u32 size)
-{
-	void *ptr = acpi_os_allocate(size);
-	if (ptr)
-		memset(ptr, 0, size);
-
-	return ptr;
-}
-
-void
-acpi_os_free(void *ptr)
-{
-	kfree(ptr);
-}
-
-
-acpi_status
-acpi_os_get_root_pointer(u32 flags, ACPI_PHYSICAL_ADDRESS *phys_addr)
-{
-#ifndef CONFIG_ACPI_EFI
-	if (ACPI_FAILURE(acpi_find_root_pointer(flags, phys_addr))) {
-		printk(KERN_ERR "ACPI: System description tables not found\n");
-		return AE_ERROR;
-	}
-#else /*CONFIG_ACPI_EFI*/
-	if (efi.acpi20)
-		*phys_addr = (ACPI_PHYSICAL_ADDRESS) efi.acpi20;
-	else if (efi.acpi)
-		*phys_addr = (ACPI_PHYSICAL_ADDRESS) efi.acpi;
-	else {
-		printk(KERN_ERR "ACPI: System description tables not found\n");
-		*phys_addr = NULL;
-		return AE_ERROR;
-	}
-#endif /*CONFIG_ACPI_EFI*/
-
-	return AE_OK;
-}
-
-acpi_status
-acpi_os_map_memory(ACPI_PHYSICAL_ADDRESS phys, u32 size, void **virt)
-{
-	if (phys > ULONG_MAX) {
-		printk(KERN_ERR "ACPI: Cannot map memory that high\n");
-		return AE_ERROR;
-	}
-
-	*virt = ioremap((unsigned long) phys, size);
-	if (!*virt)
-		return AE_ERROR;
-
-	return AE_OK;
-}
-
-void
-acpi_os_unmap_memory(void *virt, u32 size)
-{
-	iounmap(virt);
-}
-
-acpi_status
-acpi_os_get_physical_address(void *virt, ACPI_PHYSICAL_ADDRESS *phys)
-{
-	if(!phys || !virt)
-		return AE_BAD_PARAMETER;
-
-	*phys = virt_to_phys(virt);
-
-	return AE_OK;
-}
-
-static void
-acpi_irq(int irq, void *dev_id, struct pt_regs *regs)
-{
-	(*acpi_irq_handler)(acpi_irq_context);
-}
-
-acpi_status
-acpi_os_install_interrupt_handler(u32 irq, OSD_HANDLER handler, void *context)
-{
-#ifdef _IA64
-	irq = isa_irq_to_vector(irq);
-#endif /*_IA64*/
-	acpi_irq_irq = irq;
-	acpi_irq_handler = handler;
-	acpi_irq_context = context;
-	if (request_irq(irq,
-			acpi_irq,
-			SA_SHIRQ,
-			"acpi",
-			acpi_irq)) {
-		printk(KERN_ERR "ACPI: SCI (IRQ%d) allocation failed\n", irq);
-		return AE_ERROR;
-	}
-
-	return AE_OK;
-}
-
-acpi_status
-acpi_os_remove_interrupt_handler(u32 irq, OSD_HANDLER handler)
-{
-	if (acpi_irq_handler) {
-#ifdef _IA64
-		irq = isa_irq_to_vector(irq);
-#endif /*_IA64*/
-		free_irq(irq, acpi_irq);
-		acpi_irq_handler = NULL;
-	}
-
-	return AE_OK;
-}
-
-/*
- * Running in interpreter thread context, safe to sleep
- */
-
-void
-acpi_os_sleep(u32 sec, u32 ms)
-{
-	current->state = TASK_INTERRUPTIBLE;
-	schedule_timeout(HZ * sec + (ms * HZ) / 1000);
-}
-
-void
-acpi_os_stall(u32 us)
-{
-	if (us > 10000) {
-		mdelay(us / 1000);
-	}
-	else {
-		udelay(us);
-	}
-}
-
-acpi_status
-acpi_os_read_port(
-	ACPI_IO_ADDRESS	port,
-	void		*value,
-	u32		width)
-{
-	u32 dummy;
-
-	if (!value)
-		value = &dummy;
-
-	switch (width)
-	{
-	case 8:
-		*(u8*)  value = inb(port);
-		break;
-	case 16:
-		*(u16*) value = inw(port);
-		break;
-	case 32:
-		*(u32*) value = inl(port);
-		break;
-	default:
-		BUG();
-	}
-
-	return AE_OK;
-}
-
-acpi_status
-acpi_os_write_port(
-	ACPI_IO_ADDRESS	port,
-	NATIVE_UINT	value,
-	u32		width)
-{
-	switch (width)
-	{
-	case 8:
-		outb(value, port);
-		break;
-	case 16:
-		outw(value, port);
-		break;
-	case 32:
-		outl(value, port);
-		break;
-	default:
-		BUG();
-	}
-
-	return AE_OK;
-}
-
-acpi_status
-acpi_os_read_memory(
-	ACPI_PHYSICAL_ADDRESS	phys_addr,
-	void			*value,
-	u32			width)
-{
-	u32 dummy;
-
-	if (!value)
-		value = &dummy;
-
-	switch (width)
-	{
-	case 8:
-		*(u8*) value = *(u8*) phys_to_virt(phys_addr);
-		break;
-	case 16:
-		*(u16*) value = *(u16*) phys_to_virt(phys_addr);
-		break;
-	case 32:
-		*(u32*) value = *(u32*) phys_to_virt(phys_addr);
-		break;
-	default:
-		BUG();
-	}
-
-	return AE_OK;
-}
-
-acpi_status
-acpi_os_write_memory(
-	ACPI_PHYSICAL_ADDRESS	phys_addr,
-	NATIVE_UINT		value,
-	u32			width)
-{
-	switch (width)
-	{
-	case 8:
-		*(u8*) phys_to_virt(phys_addr) = value;
-		break;
-	case 16:
-		*(u16*) phys_to_virt(phys_addr) = value;
-		break;
-	case 32:
-		*(u32*) phys_to_virt(phys_addr) = value;
-		break;
-	default:
-		BUG();
-	}
-
-	return AE_OK;
-}
-
-
-#ifdef CONFIG_ACPI_PCI
-
-/* Architecture-dependent low-level PCI configuration access functions. */
-extern int (*pci_config_read)(int seg, int bus, int dev, int fn, int reg, int len, u32 *val);
-extern int (*pci_config_write)(int seg, int bus, int dev, int fn, int reg, int len, u32 val);
-
-acpi_status
-acpi_os_read_pci_configuration (
-	acpi_pci_id             *pci_id,
-	u32                     reg,
-	void                    *value,
-	u32                     width)
-{
-	int			result = 0;
-	if (!value)
-		return AE_ERROR;
-
-	switch (width)
-	{
-	case 8:
-		result = pci_config_read(pci_id->segment, pci_id->bus, 
-			pci_id->device, pci_id->function, reg, 1, value);
-		break;
-	case 16:
-		result = pci_config_read(pci_id->segment, pci_id->bus, 
-			pci_id->device, pci_id->function, reg, 2, value);
-		break;
-	case 32:
-		result = pci_config_read(pci_id->segment, pci_id->bus, 
-			pci_id->device, pci_id->function, reg, 4, value);
-		break;
-	default:
-		BUG();
-	}
-
-	return (result ? AE_ERROR : AE_OK);
-}
-
-ACPI_STATUS
-acpi_os_write_pci_configuration (
-	acpi_pci_id             *pci_id,
-	u32                     reg,
-	NATIVE_UINT             value,
-	u32                     width)
-{
-	int			result = 0;
-
-	switch (width)
-	{
-	case 8:
-		result = pci_config_write(pci_id->segment, pci_id->bus, 
-			pci_id->device, pci_id->function, reg, 1, value);
-		break;
-	case 16:
-		result = pci_config_write(pci_id->segment, pci_id->bus, 
-			pci_id->device, pci_id->function, reg, 2, value);
-		break;
-	case 32:
-		result = pci_config_write(pci_id->segment, pci_id->bus, 
-			pci_id->device, pci_id->function, reg, 4, value);
-		break;
-	default:
-		BUG();
-	}
-
-	return (result ? AE_ERROR : AE_OK);
-}
-
-#else /*CONFIG_ACPI_PCI*/
-
-acpi_status
-acpi_os_read_pci_configuration (
-	acpi_pci_id	*pci_id,
-	u32		reg,
-	void		*value,
-	u32		width)
-{
-	int devfn = PCI_DEVFN(pci_id->device, pci_id->function);
-	struct pci_dev *dev = pci_find_slot(pci_id->bus, devfn);
-
-	if (!value || !dev)
-		return AE_ERROR;
-
-	switch (width)
-	{
-	case 8:
-		if (pci_read_config_byte(dev, reg, (u8*) value))
-			return AE_ERROR;
-		break;
-	case 16:
-		if (pci_read_config_word(dev, reg, (u16*) value))
-			return AE_ERROR;
-		break;
-	case 32:
-		if (pci_read_config_dword(dev, reg, (u32*) value))
-			return AE_ERROR;
-		break;
-	default:
-		BUG();
-	}
-
-	return AE_OK;
-}
-
-acpi_status
-acpi_os_write_pci_configuration (
-	acpi_pci_id	*pci_id,
-	u32		reg,
-	NATIVE_UINT	value,
-	u32		width)
-{
-	int devfn = PCI_DEVFN(pci_id->device, pci_id->function);
-	struct pci_dev *dev = pci_find_slot(pci_id->bus, devfn);
-
-	if (!dev)
-		return AE_ERROR;
-
-	switch (width)
-	{
-	case 8:
-		if (pci_write_config_byte(dev, reg, value))
-			return AE_ERROR;
-		break;
-	case 16:
-		if (pci_write_config_word(dev, reg, value))
-			return AE_ERROR;
-		break;
-	case 32:
-		if (pci_write_config_dword(dev, reg, value))
-			return AE_ERROR;
-		break;
-	default:
-		BUG();
-	}
-
-	return AE_OK;
-}
-
-#endif /*CONFIG_ACPI_PCI*/
-
-
-acpi_status
-acpi_os_load_module (
-	char *module_name)
-{
-	PROC_NAME("acpi_os_load_module");
-
-	if (!module_name)
-		return AE_BAD_PARAMETER;
-
-	if (0 > request_module(module_name)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Unable to load module [%s].\n", module_name));
-		return AE_ERROR;
-	}
-
-	return AE_OK;
-}
-
-acpi_status
-acpi_os_unload_module (
-	char *module_name)
-{
-	if (!module_name)
-		return AE_BAD_PARAMETER;
-
-	/* TODO: How on Linux? */
-	/* this is done automatically for all modules with
-	use_count = 0, I think. see: MOD_INC_USE_COUNT -ASG */
-
-	return AE_OK;
-}
-
-
-/*
- * See acpi_os_queue_for_execution()
- */
-static int
-acpi_os_queue_exec (
-	void *context)
-{
-	ACPI_OS_DPC		*dpc = (ACPI_OS_DPC*)context;
-
-	PROC_NAME("acpi_os_queue_exec");
-
-	daemonize();
-	strcpy(current->comm, "kacpidpc");
-    
-	if (!dpc || !dpc->function)
-		return AE_BAD_PARAMETER;
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Executing function [%p(%p)].\n", dpc->function, dpc->context));
-
-	dpc->function(dpc->context);
-
-	kfree(dpc);
-
-	return 1;
-}
-
-static void
-acpi_os_schedule_exec (
-	void *context)
-{
-	ACPI_OS_DPC		*dpc = NULL;
-	int			thread_pid = -1;
-
-	PROC_NAME("acpi_os_schedule_exec");
-
-	dpc = (ACPI_OS_DPC*)context;
-	if (!dpc) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid (NULL) context.\n"));
-		return;
-	}
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Creating new thread to run function [%p(%p)].\n", dpc->function, dpc->context));
-
-	thread_pid = kernel_thread(acpi_os_queue_exec, dpc, 
-		(CLONE_FS | CLONE_FILES | SIGCHLD));
-	if (thread_pid < 0) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Call to kernel_thread() failed.\n"));
-		acpi_os_free(dpc);
-	}
-}
-
-acpi_status
-acpi_os_queue_for_execution(
-	u32			priority,
-	OSD_EXECUTION_CALLBACK	function,
-	void			*context)
-{
-	acpi_status 		status = AE_OK;
-	ACPI_OS_DPC 		*dpc = NULL;
-
-	PROC_NAME("acpi_os_queue_for_execution");
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Scheduling function [%p(%p)] for deferred execution.\n", function, context));
-
-	if (!function)
-		return AE_BAD_PARAMETER;
-
-	/*
-	 * Queue via DPC:
-	 * --------------
-	 * Note that we have to use two different processes for queuing DPCs:
-	 *	 Interrupt-Level: Use schedule_task; can't spawn a new thread.
-	 *	    Kernel-Level: Spawn a new kernel thread, as schedule_task has
-	 *			  its limitations (e.g. single-threaded model), and
-	 *			  all other task queues run at interrupt-level.
-	 */
-	switch (priority) {
-
-	case OSD_PRIORITY_GPE:
-	{
-		static struct tq_struct task;
-
-		/*
-		 * Allocate/initialize DPC structure.  Note that this memory will be
-		 * freed by the callee.
-		 */
-		dpc = kmalloc(sizeof(ACPI_OS_DPC), GFP_ATOMIC);
-		if (!dpc) 
-			return AE_NO_MEMORY;
-
-		dpc->function = function;
-		dpc->context = context;
-
-		memset(&task, 0, sizeof(struct tq_struct));
-
-		task.routine = acpi_os_schedule_exec;
-		task.data = (void*)dpc;
-
-		if (schedule_task(&task) < 0) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Call to schedule_task() failed.\n"));
-			status = AE_ERROR;
-		}
-	}
-	break;
-
-	default:
-		/*
-		 * Allocate/initialize DPC structure.  Note that this memory will be
-		 * freed by the callee.
-		 */
-		dpc = kmalloc(sizeof(ACPI_OS_DPC), GFP_KERNEL);
-		if (!dpc) 
-			return AE_NO_MEMORY;
-
-		dpc->function = function;
-		dpc->context = context;
-
-		acpi_os_schedule_exec(dpc);
-		break;
-	}
-
-	return status;
-}
-
-
-acpi_status
-acpi_os_create_semaphore(
-	u32		max_units,
-	u32		initial_units,
-	acpi_handle	*handle)
-{
-	struct semaphore	*sem = NULL;
-
-	PROC_NAME("acpi_os_create_semaphore");
-
-	sem = acpi_os_callocate(sizeof(struct semaphore));
-	if (!sem)
-		return AE_NO_MEMORY;
-
-	sema_init(sem, initial_units);
-
-	*handle = (acpi_handle*)sem;
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Creating semaphore[%p|%d].\n", *handle, initial_units));
-
-	return AE_OK;
-}
-
-
-/* 
- * TODO: A better way to delete semaphores?  Linux doesn't have a
- * 'delete_semaphore()' function -- may result in an invalid
- * pointer dereference for non-synchronized consumers.	Should
- * we at least check for blocked threads and signal/cancel them?
- */
-
-acpi_status
-acpi_os_delete_semaphore(
-	acpi_handle	handle)
-{
-	struct semaphore *sem = (struct semaphore*) handle;
-
-	PROC_NAME("acpi_os_delete_semaphore");
-
-	if (!sem) 
-		return AE_BAD_PARAMETER;
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Deleting semaphore[%p].\n", handle));
-
-	acpi_os_free(sem); sem =  NULL;
-
-	return AE_OK;
-}
-
-
-/*
- * TODO: The kernel doesn't have a 'down_timeout' function -- had to
- * improvise.  The process is to sleep for one scheduler quantum
- * until the semaphore becomes available.  Downside is that this
- * may result in starvation for timeout-based waits when there's
- * lots of semaphore activity.
- *
- * TODO: Support for units > 1?
- */
-acpi_status
-acpi_os_wait_semaphore(
-	acpi_handle		handle,
-	u32			units,
-	u32			timeout)
-{
-	acpi_status		status = AE_OK;
-	struct semaphore	*sem = (struct semaphore*)handle;
-	int			ret = 0;
-
-	PROC_NAME("acpi_os_wait_semaphore");
-
-	if (!sem || (units < 1)) 
-		return AE_BAD_PARAMETER;
-
-	if (units > 1)
-		return AE_SUPPORT;
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Waiting for semaphore[%p|%d|%d]\n", handle, units, timeout));
-
-	switch (timeout)
-	{
-		/*
-		 * No Wait:
-		 * --------
-		 * A zero timeout value indicates that we shouldn't wait - just
-		 * acquire the semaphore if available otherwise return AE_TIME
-		 * (a.k.a. 'would block').
-		 */
-		case 0:
-		if(down_trylock(sem))
-			status = AE_TIME;
-		break;
-
-		/*
-		 * Wait Indefinitely:
-		 * ------------------
-		 */
-		case WAIT_FOREVER:
-		ret = down_interruptible(sem);
-		if (ret < 0)
-			status = AE_ERROR;
-		break;
-
-		/*
-		 * Wait w/ Timeout:
-		 * ----------------
-		 */
-		default:
-		// TODO: A better timeout algorithm?
-		{
-			int i = 0;
-			static const int quantum_ms = 1000/HZ;
-
-			ret = down_trylock(sem);
-			for (i = timeout; (i > 0 && ret < 0); i -= quantum_ms) {
-				current->state = TASK_INTERRUPTIBLE;
-				schedule_timeout(1);
-				ret = down_trylock(sem);
-			}
-	
-			if (ret != 0)
-			 status = AE_TIME;
-			}
-		break;
-	}
-
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Failed to acquire semaphore[%p|%d|%d]\n", handle, units, timeout));
-	}
-	else {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Acquired semaphore[%p|%d|%d]\n", handle, units, timeout));
-	}
-
-	return status;
-}
-
-
-/*
- * TODO: Support for units > 1?
- */
-acpi_status
-acpi_os_signal_semaphore(
-    acpi_handle 	    handle, 
-    u32 		    units)
-{
-	struct semaphore *sem = (struct semaphore *) handle;
-
-	PROC_NAME("acpi_os_signal_semaphore");
-
-	if (!sem || (units < 1)) 
-		return AE_BAD_PARAMETER;
-
-	if (units > 1)
-		return AE_SUPPORT;
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Signaling semaphore[%p|%d]\n", handle, units));
-
-	up(sem);
-
-	return AE_OK;
-}
-
-u32
-acpi_os_get_line(NATIVE_CHAR *buffer)
-{
-
-#ifdef ENABLE_DEBUGGER
-	if (acpi_in_debugger) {
-		u32 chars;
-
-		kdb_read(buffer, sizeof(line_buf));
-
-		/* remove the CR kdb includes */ 
-		chars = strlen(buffer) - 1;
-		buffer[chars] = '\0';
-	}
-#endif
-
-	return 0;
-}
-
-/*
- * We just have to assume we're dealing with valid memory
- */
-
-BOOLEAN
-acpi_os_readable(void *ptr, u32 len)
-{
-	return 1;
-}
-
-BOOLEAN
-acpi_os_writable(void *ptr, u32 len)
-{
-	return 1;
-}
-
-u32
-acpi_os_get_thread_id (void)
-{
-	if (!in_interrupt())
-		return current->pid;
-
-	return 0;
-}
-
-acpi_status
-acpi_os_signal (
-    u32		function,
-    void	*info)
-{
-	switch (function)
-	{
-	case ACPI_SIGNAL_FATAL:
-		printk(KERN_ERR "ACPI: Fatal opcode executed\n");
-		break;
-	case ACPI_SIGNAL_BREAKPOINT:
-		{
-			char *bp_info = (char*) info;
-
-			printk(KERN_ERR "ACPI breakpoint: %s\n", bp_info);
-		}
-	default:
-		break;
-	}
-
-	return AE_OK;
-}
-
-acpi_status
-acpi_os_breakpoint(NATIVE_CHAR *msg)
-{
-	acpi_os_printf("breakpoint: %s", msg);
-	
-	return AE_OK;
-}
-
diff -urNp linux-5400/drivers/acpi/osl.c linux-5410/drivers/acpi/osl.c
--- linux-5400/drivers/acpi/osl.c
+++ linux-5410/drivers/acpi/osl.c
@@ -0,0 +1,1013 @@
+/*
+ *  acpi_osl.c - OS-dependent functions ($Revision: 80 $)
+ *
+ *  Copyright (C) 2000       Andrew Henroid
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/kmod.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi.h>
+
+#ifdef CONFIG_ACPI_EFI
+#include <linux/efi.h>
+u64 efi_mem_attributes (u64 phys_addr);
+#endif
+
+
+#define _COMPONENT		ACPI_OS_SERVICES
+ACPI_MODULE_NAME	("osl")
+
+#define PREFIX		"ACPI: "
+
+struct acpi_os_dpc
+{
+    OSD_EXECUTION_CALLBACK  function;
+    void		    *context;
+};
+
+
+#ifdef ENABLE_DEBUGGER
+#include <linux/kdb.h>
+/* stuff for debugger support */
+int acpi_in_debugger = 0;
+extern char line_buf[80];
+#endif /*ENABLE_DEBUGGER*/
+
+static int acpi_irq_irq = 0;
+static OSD_HANDLER acpi_irq_handler = NULL;
+static void *acpi_irq_context = NULL;
+
+
+acpi_status
+acpi_os_initialize(void)
+{
+	/*
+	 * Initialize PCI configuration space access, as we'll need to access
+	 * it while walking the namespace (bus 0 and root bridges w/ _BBNs).
+	 */
+#ifdef CONFIG_ACPI_PCI
+	pcibios_config_init();
+	if (!pci_config_read || !pci_config_write) {
+		printk(KERN_ERR PREFIX "Access to PCI configuration space unavailable\n");
+		return AE_NULL_ENTRY;
+	}
+#endif
+
+	return AE_OK;
+}
+
+acpi_status
+acpi_os_terminate(void)
+{
+	if (acpi_irq_handler) {
+		acpi_os_remove_interrupt_handler(acpi_irq_irq,
+						 acpi_irq_handler);
+	}
+
+	return AE_OK;
+}
+
+void
+acpi_os_printf(const char *fmt,...)
+{
+	va_list args;
+	va_start(args, fmt);
+	acpi_os_vprintf(fmt, args);
+	va_end(args);
+}
+
+void
+acpi_os_vprintf(const char *fmt, va_list args)
+{
+	static char buffer[512];
+	
+	vsprintf(buffer, fmt, args);
+
+#ifdef ENABLE_DEBUGGER
+	if (acpi_in_debugger) {
+		kdb_printf("%s", buffer);
+	} else {
+		printk("%s", buffer);
+	}
+#else
+	printk("%s", buffer);
+#endif
+}
+
+void *
+acpi_os_allocate(acpi_size size)
+{
+	return kmalloc(size, GFP_KERNEL);
+}
+
+void
+acpi_os_free(void *ptr)
+{
+	kfree(ptr);
+}
+
+acpi_status
+acpi_os_get_root_pointer(u32 flags, struct acpi_pointer *addr)
+{
+#ifdef CONFIG_ACPI_EFI
+	addr->pointer_type = ACPI_PHYSICAL_POINTER;
+	if (efi.acpi20)
+		addr->pointer.physical = (acpi_physical_address) virt_to_phys(efi.acpi20);
+	else if (efi.acpi)
+		addr->pointer.physical = (acpi_physical_address) virt_to_phys(efi.acpi);
+	else {
+		printk(KERN_ERR PREFIX "System description tables not found\n");
+		return AE_NOT_FOUND;
+	}
+#else
+	if (ACPI_FAILURE(acpi_find_root_pointer(flags, addr))) {
+		printk(KERN_ERR PREFIX "System description tables not found\n");
+		return AE_NOT_FOUND;
+	}
+#endif /*CONFIG_ACPI_EFI*/
+
+	return AE_OK;
+}
+
+acpi_status
+acpi_os_map_memory(acpi_physical_address phys, acpi_size size, void **virt)
+{
+#ifdef CONFIG_ACPI_EFI
+	if (EFI_MEMORY_WB & efi_mem_attributes(phys)) {
+		*virt = phys_to_virt(phys);
+	} else {
+		*virt = ioremap(phys, size);
+	}
+#else
+	if (phys > ULONG_MAX) {
+		printk(KERN_ERR PREFIX "Cannot map memory that high\n");
+		return AE_BAD_PARAMETER;
+	}
+	/*
+	 * ioremap checks to ensure this is in reserved space
+	 */
+	*virt = ioremap((unsigned long) phys, size);
+#endif
+
+	if (!*virt)
+		return AE_NO_MEMORY;
+
+	return AE_OK;
+}
+
+void
+acpi_os_unmap_memory(void *virt, acpi_size size)
+{
+	iounmap(virt);
+}
+
+acpi_status
+acpi_os_get_physical_address(void *virt, acpi_physical_address *phys)
+{
+	if(!phys || !virt)
+		return AE_BAD_PARAMETER;
+
+	*phys = virt_to_phys(virt);
+
+	return AE_OK;
+}
+
+#define ACPI_MAX_OVERRIDE_LEN 100
+
+static char __initdata acpi_os_name[ACPI_MAX_OVERRIDE_LEN];
+
+acpi_status
+acpi_os_predefined_override (const struct acpi_predefined_names *init_val,
+		             acpi_string *new_val)
+{
+	if (!init_val || !new_val)
+		return AE_BAD_PARAMETER;
+
+	*new_val = NULL;
+	if (!memcmp (init_val->name, "_OS_", 4) && strlen(acpi_os_name)) {
+		printk(KERN_INFO PREFIX "Overriding _OS definition: %s\n",
+		       acpi_os_name);
+		*new_val = acpi_os_name;
+	}
+
+	return AE_OK;
+}
+
+acpi_status
+acpi_os_table_override (struct acpi_table_header *existing_table,
+			struct acpi_table_header **new_table)
+{
+	if (!existing_table || !new_table)
+		return AE_BAD_PARAMETER;
+
+	*new_table = NULL;
+	return AE_OK;
+}
+
+static void
+acpi_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+	(*acpi_irq_handler)(acpi_irq_context);
+}
+
+acpi_status
+acpi_os_install_interrupt_handler(u32 irq, OSD_HANDLER handler, void *context)
+{
+	/*
+	 * Ignore the irq from the core, and use the value in our copy of the
+	 * FADT. It may not be the same if an interrupt source override exists
+	 * for the SCI.
+	 */
+	irq = acpi_fadt.sci_int;
+
+#ifdef CONFIG_IA64
+	irq = gsi_to_vector(irq);
+#endif
+	acpi_irq_irq = irq;
+	acpi_irq_handler = handler;
+	acpi_irq_context = context;
+	if (request_irq(irq, acpi_irq, SA_SHIRQ, "acpi", acpi_irq)) {
+		printk(KERN_ERR PREFIX "SCI (IRQ%d) allocation failed\n", irq);
+		return AE_NOT_ACQUIRED;
+	}
+
+	return AE_OK;
+}
+
+acpi_status
+acpi_os_remove_interrupt_handler(u32 irq, OSD_HANDLER handler)
+{
+	if (acpi_irq_handler) {
+#ifdef CONFIG_IA64
+		irq = gsi_to_vector(irq);
+#endif
+		free_irq(irq, acpi_irq);
+		acpi_irq_handler = NULL;
+	}
+
+	return AE_OK;
+}
+
+/*
+ * Running in interpreter thread context, safe to sleep
+ */
+
+void
+acpi_os_sleep(u32 sec, u32 ms)
+{
+	current->state = TASK_INTERRUPTIBLE;
+	schedule_timeout(HZ * sec + (ms * HZ) / 1000);
+}
+
+void
+acpi_os_stall(u32 us)
+{
+	if (us > 10000) {
+		mdelay(us / 1000);
+	}
+	else {
+		udelay(us);
+	}
+}
+
+acpi_status
+acpi_os_read_port(
+	acpi_io_address	port,
+	u32		*value,
+	u32		width)
+{
+	u32 dummy;
+
+	if (!value)
+		value = &dummy;
+
+	switch (width)
+	{
+	case 8:
+		*(u8*)  value = inb(port);
+		break;
+	case 16:
+		*(u16*) value = inw(port);
+		break;
+	case 32:
+		*(u32*) value = inl(port);
+		break;
+	default:
+		BUG();
+	}
+
+	return AE_OK;
+}
+
+acpi_status
+acpi_os_write_port(
+	acpi_io_address	port,
+	u32		value,
+	u32		width)
+{
+	switch (width)
+	{
+	case 8:
+		outb(value, port);
+		break;
+	case 16:
+		outw(value, port);
+		break;
+	case 32:
+		outl(value, port);
+		break;
+	default:
+		BUG();
+	}
+
+	return AE_OK;
+}
+
+acpi_status
+acpi_os_read_memory(
+	acpi_physical_address	phys_addr,
+	u32			*value,
+	u32			width)
+{
+	u32			dummy;
+	void			*virt_addr;
+
+#ifdef CONFIG_ACPI_EFI
+	int			iomem = 0;
+
+	if (EFI_MEMORY_WB & efi_mem_attributes(phys_addr)) {
+		virt_addr = phys_to_virt(phys_addr);
+	} else {
+		iomem = 1;
+		virt_addr = ioremap(phys_addr, width);
+	}
+#else
+	virt_addr = phys_to_virt(phys_addr);
+#endif
+	if (!value)
+		value = &dummy;
+
+	switch (width) {
+	case 8:
+		*(u8*) value = *(u8*) virt_addr;
+		break;
+	case 16:
+		*(u16*) value = *(u16*) virt_addr;
+		break;
+	case 32:
+		*(u32*) value = *(u32*) virt_addr;
+		break;
+	default:
+		BUG();
+	}
+
+#ifdef CONFIG_ACPI_EFI
+	if (iomem)
+		iounmap(virt_addr);
+#endif
+
+	return AE_OK;
+}
+
+acpi_status
+acpi_os_write_memory(
+	acpi_physical_address	phys_addr,
+	u32			value,
+	u32			width)
+{
+	void			*virt_addr;
+
+#ifdef CONFIG_ACPI_EFI
+	int			iomem = 0;
+
+	if (EFI_MEMORY_WB & efi_mem_attributes(phys_addr)) {
+		virt_addr = phys_to_virt(phys_addr);
+	} else {
+		iomem = 1;
+		virt_addr = ioremap(phys_addr, width);
+	}
+#else
+	virt_addr = phys_to_virt(phys_addr);
+#endif
+
+	switch (width) {
+	case 8:
+		*(u8*) virt_addr = value;
+		break;
+	case 16:
+		*(u16*) virt_addr = value;
+		break;
+	case 32:
+		*(u32*) virt_addr = value;
+		break;
+	default:
+		BUG();
+	}
+
+#ifdef CONFIG_ACPI_EFI
+	if (iomem)
+		iounmap(virt_addr);
+#endif
+
+	return AE_OK;
+}
+
+#ifdef CONFIG_ACPI_PCI
+
+acpi_status
+acpi_os_read_pci_configuration (
+	struct acpi_pci_id	*pci_id,
+	u32			reg,
+	void			*value,
+	u32			width)
+{
+	int			result = 0;
+	if (!value)
+		return AE_BAD_PARAMETER;
+
+	switch (width)
+	{
+	case 8:
+		result = pci_config_read(pci_id->segment, pci_id->bus,
+			pci_id->device, pci_id->function, reg, 1, value);
+		break;
+	case 16:
+		result = pci_config_read(pci_id->segment, pci_id->bus,
+			pci_id->device, pci_id->function, reg, 2, value);
+		break;
+	case 32:
+		result = pci_config_read(pci_id->segment, pci_id->bus,
+			pci_id->device, pci_id->function, reg, 4, value);
+		break;
+	default:
+		BUG();
+	}
+
+	return (result ? AE_ERROR : AE_OK);
+}
+
+acpi_status
+acpi_os_write_pci_configuration (
+	struct acpi_pci_id	*pci_id,
+	u32			reg,
+	acpi_integer		value,
+	u32			width)
+{
+	int			result = 0;
+
+	switch (width)
+	{
+	case 8:
+		result = pci_config_write(pci_id->segment, pci_id->bus,
+			pci_id->device, pci_id->function, reg, 1, value);
+		break;
+	case 16:
+		result = pci_config_write(pci_id->segment, pci_id->bus,
+			pci_id->device, pci_id->function, reg, 2, value);
+		break;
+	case 32:
+		result = pci_config_write(pci_id->segment, pci_id->bus,
+			pci_id->device, pci_id->function, reg, 4, value);
+		break;
+	default:
+		BUG();
+	}
+
+	return (result ? AE_ERROR : AE_OK);
+}
+
+static void
+acpi_os_derive_pci_id_2 (
+	acpi_handle		rhandle,        /* upper bound  */
+	acpi_handle		chandle,        /* current node */
+	struct acpi_pci_id	**id,
+	int			*is_bridge,
+	u8			*bus_number)
+{
+	acpi_handle		handle;
+	struct acpi_pci_id	*pci_id = *id;
+	acpi_status		status;
+	unsigned long		temp;
+	acpi_object_type	type;
+	u8			tu8;
+
+	acpi_get_parent(chandle, &handle);
+	if (handle != rhandle) {
+		acpi_os_derive_pci_id_2(rhandle, handle, &pci_id, is_bridge, bus_number);
+
+		status = acpi_get_type(handle, &type);
+		if ( (ACPI_FAILURE(status)) || (type != ACPI_TYPE_DEVICE) )
+			return;
+
+		status = acpi_evaluate_integer(handle, METHOD_NAME__ADR, NULL, &temp);
+		if (ACPI_SUCCESS(status)) {
+			pci_id->device  = ACPI_HIWORD (ACPI_LODWORD (temp));
+			pci_id->function = ACPI_LOWORD (ACPI_LODWORD (temp));
+
+			if (*is_bridge)
+				pci_id->bus = *bus_number;
+
+			/* any nicer way to get bus number of bridge ? */
+			status = acpi_os_read_pci_configuration(pci_id, 0x0e, &tu8, 8);
+			if (ACPI_SUCCESS(status) &&
+			    ((tu8 & 0x7f) == 1 || (tu8 & 0x7f) == 2)) {
+				status = acpi_os_read_pci_configuration(pci_id, 0x18, &tu8, 8);
+				if (!ACPI_SUCCESS(status)) {
+					/* Certainly broken...  FIX ME */
+					return;
+				}
+				*is_bridge = 1;
+				pci_id->bus = tu8;
+				status = acpi_os_read_pci_configuration(pci_id, 0x19, &tu8, 8);
+				if (ACPI_SUCCESS(status)) {
+					*bus_number = tu8;
+				}
+			} else
+				*is_bridge = 0;
+		}
+	}
+}
+
+void
+acpi_os_derive_pci_id (
+	acpi_handle		rhandle,        /* upper bound  */
+	acpi_handle		chandle,        /* current node */
+	struct acpi_pci_id	**id)
+{
+	int is_bridge = 1;
+	u8 bus_number = (*id)->bus;
+
+	acpi_os_derive_pci_id_2(rhandle, chandle, id, &is_bridge, &bus_number);
+}
+
+#else /*!CONFIG_ACPI_PCI*/
+
+acpi_status
+acpi_os_write_pci_configuration (
+	struct acpi_pci_id	*pci_id,
+	u32			reg,
+	acpi_integer		value,
+	u32			width)
+{
+	return (AE_SUPPORT);
+}
+
+acpi_status
+acpi_os_read_pci_configuration (
+	struct acpi_pci_id	*pci_id,
+	u32			reg,
+	void			*value,
+	u32			width)
+{
+	return (AE_SUPPORT);
+}
+
+void
+acpi_os_derive_pci_id (
+	acpi_handle		rhandle,        /* upper bound  */
+	acpi_handle		chandle,        /* current node */
+	struct acpi_pci_id	**id)
+{
+}
+
+#endif /*CONFIG_ACPI_PCI*/
+
+static void
+acpi_os_execute_deferred (
+	void *context)
+{
+	struct acpi_os_dpc	*dpc = NULL;
+
+	ACPI_FUNCTION_TRACE ("os_execute_deferred");
+
+	dpc = (struct acpi_os_dpc *) context;
+	if (!dpc) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid (NULL) context.\n"));
+		return_VOID;
+	}
+
+	dpc->function(dpc->context);
+
+	kfree(dpc);
+
+	return_VOID;
+}
+
+acpi_status
+acpi_os_queue_for_execution(
+	u32			priority,
+	OSD_EXECUTION_CALLBACK	function,
+	void			*context)
+{
+	acpi_status 		status = AE_OK;
+	struct acpi_os_dpc	*dpc = NULL;
+	struct tq_struct	*task;
+
+	ACPI_FUNCTION_TRACE ("os_queue_for_execution");
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Scheduling function [%p(%p)] for deferred execution.\n", function, context));
+
+	if (!function)
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+
+	/*
+	 * Allocate/initialize DPC structure.  Note that this memory will be
+	 * freed by the callee.  The kernel handles the tq_struct list  in a
+	 * way that allows us to also free its memory inside the callee.
+	 * Because we may want to schedule several tasks with different
+	 * parameters we can't use the approach some kernel code uses of
+	 * having a static tq_struct.
+	 * We can save time and code by allocating the DPC and tq_structs
+	 * from the same memory.
+	 */
+	dpc = kmalloc(sizeof(struct acpi_os_dpc)+sizeof(struct tq_struct), GFP_ATOMIC);
+	if (!dpc)
+		return_ACPI_STATUS (AE_NO_MEMORY);
+
+	dpc->function = function;
+	dpc->context = context;
+
+	task = (void *)(dpc+1);
+	INIT_TQUEUE(task, acpi_os_execute_deferred, (void*)dpc);
+
+	if (!schedule_task(task)) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Call to schedule_task() failed.\n"));
+		kfree(dpc);
+		status = AE_ERROR;
+	}
+
+	return_ACPI_STATUS (status);
+}
+
+/*
+ * Allocate the memory for a spinlock and initialize it.
+ */
+acpi_status
+acpi_os_create_lock (
+	acpi_handle	*out_handle)
+{
+	spinlock_t *lock_ptr;
+
+	ACPI_FUNCTION_TRACE ("os_create_lock");
+
+	lock_ptr = acpi_os_allocate(sizeof(spinlock_t));
+
+	spin_lock_init(lock_ptr);
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Creating spinlock[%p].\n", lock_ptr));
+
+	*out_handle = lock_ptr;
+
+	return_ACPI_STATUS (AE_OK);
+}
+
+
+/*
+ * Deallocate the memory for a spinlock.
+ */
+void
+acpi_os_delete_lock (
+	acpi_handle	handle)
+{
+	ACPI_FUNCTION_TRACE ("os_create_lock");
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Deleting spinlock[%p].\n", handle));
+
+	acpi_os_free(handle);
+
+	return_VOID;
+}
+
+/*
+ * Acquire a spinlock.
+ *
+ * handle is a pointer to the spinlock_t.
+ * flags is *not* the result of save_flags - it is an ACPI-specific flag variable
+ *   that indicates whether we are at interrupt level.
+ */
+void
+acpi_os_acquire_lock (
+	acpi_handle	handle,
+	u32		flags)
+{
+	ACPI_FUNCTION_TRACE ("os_acquire_lock");
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Acquiring spinlock[%p] from %s level\n", handle,
+		((flags & ACPI_NOT_ISR) ? "non-interrupt" : "interrupt")));
+
+	if (flags & ACPI_NOT_ISR)
+		ACPI_DISABLE_IRQS();
+
+	spin_lock(handle);
+
+	return_VOID;
+}
+
+
+/*
+ * Release a spinlock. See above.
+ */
+void
+acpi_os_release_lock (
+	acpi_handle	handle,
+	u32		flags)
+{
+	ACPI_FUNCTION_TRACE ("os_release_lock");
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Releasing spinlock[%p] from %s level\n", handle,
+		((flags & ACPI_NOT_ISR) ? "non-interrupt" : "interrupt")));
+
+	spin_unlock(handle);
+
+	if (flags & ACPI_NOT_ISR)
+		ACPI_ENABLE_IRQS();
+
+	return_VOID;
+}
+
+
+acpi_status
+acpi_os_create_semaphore(
+	u32		max_units,
+	u32		initial_units,
+	acpi_handle	*handle)
+{
+	struct semaphore	*sem = NULL;
+
+	ACPI_FUNCTION_TRACE ("os_create_semaphore");
+
+	sem = acpi_os_allocate(sizeof(struct semaphore));
+	if (!sem)
+		return_ACPI_STATUS (AE_NO_MEMORY);
+	memset(sem, 0, sizeof(struct semaphore));
+
+	sema_init(sem, initial_units);
+
+	*handle = (acpi_handle*)sem;
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Creating semaphore[%p|%d].\n", *handle, initial_units));
+
+	return_ACPI_STATUS (AE_OK);
+}
+
+
+/*
+ * TODO: A better way to delete semaphores?  Linux doesn't have a
+ * 'delete_semaphore()' function -- may result in an invalid
+ * pointer dereference for non-synchronized consumers.	Should
+ * we at least check for blocked threads and signal/cancel them?
+ */
+
+acpi_status
+acpi_os_delete_semaphore(
+	acpi_handle	handle)
+{
+	struct semaphore *sem = (struct semaphore*) handle;
+
+	ACPI_FUNCTION_TRACE ("os_delete_semaphore");
+
+	if (!sem)
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Deleting semaphore[%p].\n", handle));
+
+	acpi_os_free(sem); sem =  NULL;
+
+	return_ACPI_STATUS (AE_OK);
+}
+
+
+/*
+ * TODO: The kernel doesn't have a 'down_timeout' function -- had to
+ * improvise.  The process is to sleep for one scheduler quantum
+ * until the semaphore becomes available.  Downside is that this
+ * may result in starvation for timeout-based waits when there's
+ * lots of semaphore activity.
+ *
+ * TODO: Support for units > 1?
+ */
+acpi_status
+acpi_os_wait_semaphore(
+	acpi_handle		handle,
+	u32			units,
+	u16			timeout)
+{
+	acpi_status		status = AE_OK;
+	struct semaphore	*sem = (struct semaphore*)handle;
+	int			ret = 0;
+
+	ACPI_FUNCTION_TRACE ("os_wait_semaphore");
+
+	if (!sem || (units < 1))
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+
+	if (units > 1)
+		return_ACPI_STATUS (AE_SUPPORT);
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Waiting for semaphore[%p|%d|%d]\n", handle, units, timeout));
+
+	if (in_interrupt())
+		timeout = 0;
+
+	switch (timeout)
+	{
+		/*
+		 * No Wait:
+		 * --------
+		 * A zero timeout value indicates that we shouldn't wait - just
+		 * acquire the semaphore if available otherwise return AE_TIME
+		 * (a.k.a. 'would block').
+		 */
+		case 0:
+		if(down_trylock(sem))
+			status = AE_TIME;
+		break;
+
+		/*
+		 * Wait Indefinitely:
+		 * ------------------
+		 */
+		case ACPI_WAIT_FOREVER:
+		down(sem);
+		break;
+
+		/*
+		 * Wait w/ Timeout:
+		 * ----------------
+		 */
+		default:
+		// TODO: A better timeout algorithm?
+		{
+			int i = 0;
+			static const int quantum_ms = 1000/HZ;
+
+			ret = down_trylock(sem);
+			for (i = timeout; (i > 0 && ret < 0); i -= quantum_ms) {
+				current->state = TASK_INTERRUPTIBLE;
+				schedule_timeout(1);
+				ret = down_trylock(sem);
+			}
+	
+			if (ret != 0)
+				status = AE_TIME;
+		}
+		break;
+	}
+
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Failed to acquire semaphore[%p|%d|%d], %s\n", 
+			handle, units, timeout, acpi_format_exception(status)));
+	}
+	else {
+		ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Acquired semaphore[%p|%d|%d]\n", handle, units, timeout));
+	}
+
+	return_ACPI_STATUS (status);
+}
+
+
+/*
+ * TODO: Support for units > 1?
+ */
+acpi_status
+acpi_os_signal_semaphore(
+    acpi_handle 	    handle,
+    u32 		    units)
+{
+	struct semaphore *sem = (struct semaphore *) handle;
+
+	ACPI_FUNCTION_TRACE ("os_signal_semaphore");
+
+	if (!sem || (units < 1))
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+
+	if (units > 1)
+		return_ACPI_STATUS (AE_SUPPORT);
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Signaling semaphore[%p|%d]\n", handle, units));
+
+	up(sem);
+
+	return_ACPI_STATUS (AE_OK);
+}
+
+u32
+acpi_os_get_line(char *buffer)
+{
+
+#ifdef ENABLE_DEBUGGER
+	if (acpi_in_debugger) {
+		u32 chars;
+
+		kdb_read(buffer, sizeof(line_buf));
+
+		/* remove the CR kdb includes */
+		chars = strlen(buffer) - 1;
+		buffer[chars] = '\0';
+	}
+#endif
+
+	return 0;
+}
+
+/*
+ * We just have to assume we're dealing with valid memory
+ */
+
+BOOLEAN
+acpi_os_readable(void *ptr, acpi_size len)
+{
+	return 1;
+}
+
+BOOLEAN
+acpi_os_writable(void *ptr, acpi_size len)
+{
+	return 1;
+}
+
+u32
+acpi_os_get_thread_id (void)
+{
+	if (!in_interrupt())
+		return current->pid;
+
+	return 0;
+}
+
+acpi_status
+acpi_os_signal (
+    u32		function,
+    void	*info)
+{
+	switch (function)
+	{
+	case ACPI_SIGNAL_FATAL:
+		printk(KERN_ERR PREFIX "Fatal opcode executed\n");
+		break;
+	case ACPI_SIGNAL_BREAKPOINT:
+		{
+			char *bp_info = (char*) info;
+
+			printk(KERN_ERR "ACPI breakpoint: %s\n", bp_info);
+		}
+	default:
+		break;
+	}
+
+	return AE_OK;
+}
+
+int __init
+acpi_os_name_setup(char *str)
+{
+	char *p = acpi_os_name;
+	int count = ACPI_MAX_OVERRIDE_LEN-1;
+
+	if (!str || !*str)
+		return 0;
+
+	for (; count-- && str && *str; str++) {
+		if (isalnum(*str) || *str == ' ' || *str == ':')
+			*p++ = *str;
+		else if (*str == '\'' || *str == '"')
+			continue;
+		else
+			break;
+	}
+	*p = 0;
+
+	return 1;
+		
+}
+
+__setup("acpi_os_name=", acpi_os_name_setup);
diff -urNp linux-5400/drivers/acpi/ospm/Makefile linux-5410/drivers/acpi/ospm/Makefile
--- linux-5400/drivers/acpi/ospm/Makefile
+++ linux-5410/drivers/acpi/ospm/Makefile
@@ -1,22 +0,0 @@
-#
-# Makefile for the Linux OSPM code.
-#
-
-O_TARGET := $(notdir $(CURDIR)).o
-
-ACPI_CFLAGS += -I$(CURDIR)/include
-
-EXTRA_CFLAGS += $(ACPI_CFLAGS)
-
-subdir-$(CONFIG_ACPI_BUSMGR)	+= busmgr
-subdir-$(CONFIG_ACPI_EC)	+= ec
-subdir-$(CONFIG_ACPI_SYS)	+= system
-subdir-$(CONFIG_ACPI_CPU)	+= processor
-subdir-$(CONFIG_ACPI_CMBATT)	+= battery
-subdir-$(CONFIG_ACPI_AC)	+= ac_adapter
-subdir-$(CONFIG_ACPI_BUTTON)	+= button
-subdir-$(CONFIG_ACPI_THERMAL)	+= thermal
-
-obj-y				+= $(foreach dir,$(subdir-y),$(dir)/ospm_$(dir).o)
-
-include $(TOPDIR)/Rules.make
diff -urNp linux-5400/drivers/acpi/ospm/ac_adapter/Makefile linux-5410/drivers/acpi/ospm/ac_adapter/Makefile
--- linux-5400/drivers/acpi/ospm/ac_adapter/Makefile
+++ linux-5410/drivers/acpi/ospm/ac_adapter/Makefile
@@ -1,6 +0,0 @@
-O_TARGET	:= ospm_$(notdir $(CURDIR)).o
-obj-m		:= $(O_TARGET)
-EXTRA_CFLAGS	+= $(ACPI_CFLAGS)
-obj-y		:= $(patsubst %.c,%.o,$(wildcard *.c))
-
-include $(TOPDIR)/Rules.make
diff -urNp linux-5400/drivers/acpi/ospm/ac_adapter/ac.c linux-5410/drivers/acpi/ospm/ac_adapter/ac.c
--- linux-5400/drivers/acpi/ospm/ac_adapter/ac.c
+++ linux-5410/drivers/acpi/ospm/ac_adapter/ac.c
@@ -1,398 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: ac.c
- *   $Revision: 23 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include <acpi.h>
-#include "ac.h"
-
-
-#define _COMPONENT		ACPI_AC_ADAPTER
-	MODULE_NAME 		("ac")
-
-
-/****************************************************************************
- *                            Internal Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:	ac_print
- *
- * PARAMETERS:	
- *
- * RETURN:	
- *
- * DESCRIPTION: Prints out information on a specific ac_adapter.
- *
- ****************************************************************************/
-
-void
-ac_print (
-	AC_CONTEXT		*ac_adapter)
-{
-#ifdef ACPI_DEBUG
-
-	acpi_buffer		buffer;
-
-	PROC_NAME("ac_print");
-
-	if (!ac_adapter) {
-		return;
-	}
-
-	buffer.length = 256;
-	buffer.pointer = acpi_os_callocate(buffer.length);
-	if (!buffer.pointer) {
-		return;
-	}
-
-	/*
-	 * Get the full pathname for this ACPI object.
-	 */
-	acpi_get_name(ac_adapter->acpi_handle, ACPI_FULL_PATHNAME, &buffer);
-
-	/*
-	 * Print out basic adapter information.
-	 */
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "+------------------------------------------------------------\n"));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "| AC Adapter[%02x]:[%p] %s\n", ac_adapter->device_handle, ac_adapter->acpi_handle, (char*)buffer.pointer));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "+------------------------------------------------------------\n"));
-
-	acpi_os_free(buffer.pointer);
-#endif /*ACPI_DEBUG*/
-
-	return;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	ac_add_device
- *
- * PARAMETERS:	
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-ac_add_device(
-	BM_HANDLE		device_handle,
-	void			**context)
-{
-	acpi_status 		status = AE_OK;
-	BM_DEVICE		*device = NULL;
-	AC_CONTEXT		*ac_adapter = NULL;
-	acpi_device_info	info;
-
-	FUNCTION_TRACE("ac_add_device");
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Adding ac_adapter device [%02x].\n", device_handle));
-
-	if (!context || *context) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid (NULL) context."));
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * Get information on this device.
-	 */
-	status = bm_get_device_info(device_handle, &device);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Allocate a new AC_CONTEXT structure.
-	 */
-	ac_adapter = acpi_os_callocate(sizeof(AC_CONTEXT));
-	if (!ac_adapter) {
-		return_ACPI_STATUS(AE_NO_MEMORY);
-	}
-
-	ac_adapter->device_handle = device->handle;
-	ac_adapter->acpi_handle = device->acpi_handle;
-
-	/*
-	 * Get information on this object.
-	 */
-	status = acpi_get_object_info(ac_adapter->acpi_handle, &info);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unable to get object info for ac_adapter device."));
-		goto end;
-	}
-
-	/*
-	 * _UID?
-	 * -----
-	 */
-	if (info.valid & ACPI_VALID_UID) {
-		strncpy(ac_adapter->uid, info.unique_id, sizeof(info.unique_id));
-	}
-	else {
-		strncpy(ac_adapter->uid, "0", sizeof("0"));
-	}
-
-	/*
-	 * _STA?
-	 * -----
-	 */
-	if (!(info.valid & ACPI_VALID_STA)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Must have valid _STA.\n"));
-		status = AE_ERROR;
-		goto end;
-	}
-
-	status = ac_osl_add_device(ac_adapter);
-	if (ACPI_FAILURE(status)) {
-		goto end;
-	}
-
-	*context = ac_adapter;
-
-	ac_print(ac_adapter);
-
-end:
-	if (ACPI_FAILURE(status)) {
-		acpi_os_free(ac_adapter);
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	ac_remove_device
- *
- * PARAMETERS:	
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-ac_remove_device (
-	void			**context)
-{
-	acpi_status 		status = AE_OK;
-	AC_CONTEXT		*ac_adapter = NULL;
-
-	FUNCTION_TRACE("ac_remove_device");
-
-	if (!context || !*context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	ac_adapter = (AC_CONTEXT*)*context;
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Removing ac_adapter device [%02x].\n", ac_adapter->device_handle));
-
-	ac_osl_remove_device(ac_adapter);
-
-	acpi_os_free(ac_adapter);
-
-	*context = NULL;
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *                             External Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:	ac_initialize
- *
- * PARAMETERS:	<none>
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-ac_initialize (void)
-{
-	acpi_status		status = AE_OK;
-	BM_DEVICE_ID		criteria;
-	BM_DRIVER		driver;
-
-	FUNCTION_TRACE("ac_initialize");
-
-	MEMSET(&criteria, 0, sizeof(BM_DEVICE_ID));
-	MEMSET(&driver, 0, sizeof(BM_DRIVER));
-
-	driver.notify = &ac_notify;
-	driver.request = &ac_request;
-
-	/*
-	 * Register driver for AC Adapter devices.
-	 */
-	MEMCPY(criteria.hid, AC_HID_AC_ADAPTER, sizeof(AC_HID_AC_ADAPTER));
-
-	status = bm_register_driver(&criteria, &driver);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	ac_terminate
- *
- * PARAMETERS:	<none>
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-ac_terminate (void)
-{
-	acpi_status 		status = AE_OK;
-	BM_DEVICE_ID		criteria;
-	BM_DRIVER		driver;
-
-	FUNCTION_TRACE("ac_terminate");
-
-	MEMSET(&criteria, 0, sizeof(BM_DEVICE_ID));
-	MEMSET(&driver, 0, sizeof(BM_DRIVER));
-
-	/*
-	 * Unregister driver for AC Adapter devices.
-	 */
-	MEMCPY(criteria.hid, AC_HID_AC_ADAPTER, sizeof(AC_HID_AC_ADAPTER));
-
-	driver.notify = &ac_notify;
-	driver.request = &ac_request;
-
-	status = bm_unregister_driver(&criteria, &driver);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/*****************************************************************************
- *
- * FUNCTION:	ac_notify
- *
- * PARAMETERS:	<none>
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-acpi_status
-ac_notify (
-	BM_NOTIFY		notify_type,
-	BM_HANDLE		device_handle,
-	void			**context)
-{
-	acpi_status 		status = AE_OK;
-
-	FUNCTION_TRACE("ac_notify");
-
-	if (!context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	switch (notify_type) {
-
-	case BM_NOTIFY_DEVICE_ADDED:
-		status = ac_add_device(device_handle, context);
-		break;
-
-	case BM_NOTIFY_DEVICE_REMOVED:
-		status = ac_remove_device(context);
-		break;
-
-	case AC_NOTIFY_STATUS_CHANGE:
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Status change event detected.\n"));
-		status = ac_osl_generate_event(notify_type,
-			((AC_CONTEXT*)*context));
-		break;
-
-	default:
-		status = AE_SUPPORT;
-		break;
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	ac_request
- *
- * PARAMETERS:	
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-ac_request (
-	BM_REQUEST		*request,
-	void			*context)
-{
-	acpi_status 		status = AE_OK;
-
-	FUNCTION_TRACE("ac_request");
-
-	/*
-	 * Must have a valid request structure and context.
-	 */
-	if (!request || !context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * Handle Request:
-	 * ---------------
-	 */
-	switch (request->command) {
-
-	default:
-		status = AE_SUPPORT;
-		break;
-	}
-
-	request->status = status;
-
-	return_ACPI_STATUS(status);
-}
diff -urNp linux-5400/drivers/acpi/ospm/ac_adapter/ac_osl.c linux-5410/drivers/acpi/ospm/ac_adapter/ac_osl.c
--- linux-5400/drivers/acpi/ospm/ac_adapter/ac_osl.c
+++ linux-5410/drivers/acpi/ospm/ac_adapter/ac_osl.c
@@ -1,257 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: ac_osl.c
- *   $Revision: 10 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/proc_fs.h>
-#include <acpi.h>
-#include "ac.h"
-
-
-MODULE_AUTHOR("Andrew Grover");
-MODULE_DESCRIPTION("ACPI Component Architecture (CA) - AC Adapter Driver");
-MODULE_LICENSE("GPL");
-
-
-#define AC_PROC_ROOT		"ac_adapter"
-#define AC_PROC_STATUS		"status"
-#define AC_ON_LINE		"on-line"
-#define AC_OFF_LINE		"off-line"
-
-extern struct proc_dir_entry	*bm_proc_root;
-static struct proc_dir_entry	*ac_proc_root = NULL;
-
-
-/****************************************************************************
- *
- * FUNCTION:	ac_osl_proc_read_status
- *
- ****************************************************************************/
-
-static int
-ac_osl_proc_read_status (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*context)
-{
-	acpi_status 		status = AE_OK;
-	AC_CONTEXT		*ac_adapter = NULL;
-	char			*p = page;
-	int			len;
-
-	if (!context) {
-		goto end;
-	}
-
-	ac_adapter = (AC_CONTEXT*)context;
-
-	/* don't get status more than once for a single proc read */
-	if (off != 0) {
-		goto end;
-	}
-
-	status = bm_evaluate_simple_integer(ac_adapter->acpi_handle,
-		"_PSR", &(ac_adapter->is_online));
-	if (ACPI_FAILURE(status)) {
-		p += sprintf(p, "Error reading AC Adapter status\n");
-		goto end;
-	}
-
-	if (ac_adapter->is_online) {
-		p += sprintf(p, "Status:                  %s\n",
-			AC_ON_LINE);
-	}
-	else {
-		p += sprintf(p, "Status:                  %s\n",
-			AC_OFF_LINE);
-	}
-
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return(len);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	ac_osl_add_device
- *
- ****************************************************************************/
-
-acpi_status
-ac_osl_add_device(
-	AC_CONTEXT		*ac_adapter)
-{
-	struct proc_dir_entry	*proc_entry = NULL;
-
-	if (!ac_adapter) {
-		return(AE_BAD_PARAMETER);
-	}
-
-	printk(KERN_INFO "ACPI: AC Adapter found\n");
-
-	proc_entry = proc_mkdir(ac_adapter->uid, ac_proc_root);
-	if (!proc_entry) {
-		return(AE_ERROR);
-	}
-
-	create_proc_read_entry(AC_PROC_STATUS, S_IFREG | S_IRUGO,
-		proc_entry, ac_osl_proc_read_status, (void*)ac_adapter);
-
-	return(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	ac_osl_remove_device
- *
- ****************************************************************************/
-
-acpi_status
-ac_osl_remove_device (
-	AC_CONTEXT		*ac_adapter)
-{
-	char			proc_entry[64];
-
-	if (!ac_adapter) {
-		return(AE_BAD_PARAMETER);
-	}
-
-	sprintf(proc_entry, "%s/%s", ac_adapter->uid, AC_PROC_STATUS);
-	remove_proc_entry(proc_entry, ac_proc_root);
-
-	sprintf(proc_entry, "%s", ac_adapter->uid);
-	remove_proc_entry(proc_entry, ac_proc_root);
-
-	return(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	ac_osl_generate_event
- *
- ****************************************************************************/
-
-acpi_status
-ac_osl_generate_event (
-	u32			event,
-	AC_CONTEXT		*ac_adapter)
-{
-	acpi_status		status = AE_OK;
-
-	if (!ac_adapter) {
-		return(AE_BAD_PARAMETER);
-	}
-
-	switch (event) {
-
-	case AC_NOTIFY_STATUS_CHANGE:
-		status = bm_osl_generate_event(ac_adapter->device_handle,
-			AC_PROC_ROOT, ac_adapter->uid, event, 0);
-		break;
-
-	default:
-		return(AE_BAD_PARAMETER);
-		break;
-	}
-
-	return(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	ac_osl_init
- *
- * PARAMETERS:	<none>
- *
- * RETURN:	0: Success
- *
- * DESCRIPTION: Module initialization.
- *
- ****************************************************************************/
-
-static int __init
-ac_osl_init (void)
-{
-	acpi_status		status = AE_OK;
-
-	ac_proc_root = proc_mkdir(AC_PROC_ROOT, bm_proc_root);
-	if (!ac_proc_root) {
-		status = AE_ERROR;
-	}
-	else {
-		status = ac_initialize();
-		if (ACPI_FAILURE(status)) {
-			remove_proc_entry(AC_PROC_ROOT, bm_proc_root);
-		}
-
-	}
-
-	return (ACPI_SUCCESS(status)) ? 0 : -ENODEV;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	ac_osl_cleanup
- *
- * PARAMETERS:	<none>
- *
- * RETURN:	<none>
- *
- * DESCRIPTION: Module cleanup.
- *
- ****************************************************************************/
-
-static void __exit
-ac_osl_cleanup (void)
-{
-	ac_terminate();
-
-	if (ac_proc_root) {
-		remove_proc_entry(AC_PROC_ROOT, bm_proc_root);
-	}
-
-	return;
-}
-
-
-module_init(ac_osl_init);
-module_exit(ac_osl_cleanup);
diff -urNp linux-5400/drivers/acpi/ospm/battery/Makefile linux-5410/drivers/acpi/ospm/battery/Makefile
--- linux-5400/drivers/acpi/ospm/battery/Makefile
+++ linux-5410/drivers/acpi/ospm/battery/Makefile
@@ -1,6 +0,0 @@
-O_TARGET	:= ospm_$(notdir $(CURDIR)).o
-obj-m		:= $(O_TARGET)
-EXTRA_CFLAGS	+= $(ACPI_CFLAGS)
-obj-y		:= $(patsubst %.c,%.o,$(wildcard *.c))
-
-include $(TOPDIR)/Rules.make
diff -urNp linux-5400/drivers/acpi/ospm/battery/bt.c linux-5410/drivers/acpi/ospm/battery/bt.c
--- linux-5400/drivers/acpi/ospm/battery/bt.c
+++ linux-5410/drivers/acpi/ospm/battery/bt.c
@@ -1,654 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: bt.c
- *   $Revision: 29 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include <acpi.h>
-#include "bt.h"
-
-
-#define _COMPONENT		ACPI_BATTERY
-	MODULE_NAME 		("bt")
-
-
-/****************************************************************************
- *                            Internal Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:	bt_print
- *
- * PARAMETERS:	
- *
- * RETURN:	
- *
- * DESCRIPTION: Prints out information on a specific battery.
- *
- ****************************************************************************/
-
-void
-bt_print (
-	BT_CONTEXT		*battery)
-{
-#ifdef ACPI_DEBUG
-	acpi_buffer 		buffer;
-
-	PROC_NAME("bt_print");
-
-	if (!battery) {
-		return;
-	}
-
-	buffer.length = 256;
-	buffer.pointer = acpi_os_callocate(buffer.length);
-	if (!buffer.pointer) {
-		return;
-	}
-
-	/*
-	 * Get the full pathname for this ACPI object.
-	 */
-	acpi_get_name(battery->acpi_handle, ACPI_FULL_PATHNAME, &buffer);
-
-	/*
-	 * Print out basic battery information.
-	 */
-
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "+------------------------------------------------------------\n"));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "| Battery[%02x]:[%p] %s\n", battery->device_handle, battery->acpi_handle, (char*)buffer.pointer));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "|   uid[%s] is_present[%d] power_units[%s]\n", battery->uid, battery->is_present, battery->power_units));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "+------------------------------------------------------------\n"));
-
-	acpi_os_free(buffer.pointer);
-#endif /*ACPI_DEBUG*/
-
-	return;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	bt_get_info
- *
- * PARAMETERS:	
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- * NOTES:	Allocates battery_info - which must be freed by the caller.
- *
- ****************************************************************************/
-
-acpi_status
-bt_get_info (
-	BT_CONTEXT		*battery,
-	BT_BATTERY_INFO 	**battery_info)
-{
-	acpi_status 		status = AE_OK;
-	acpi_buffer 		bif_buffer, package_format, package_data;
-	acpi_object 		*package = NULL;
-
-	FUNCTION_TRACE("bt_get_info");
-
-	if (!battery || !battery_info || *battery_info) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	memset(&bif_buffer, 0, sizeof(acpi_buffer));
-
-	/*
-	 * Evalute _BIF:
-	 * -------------
-	 * And be sure to deallocate bif_buffer.pointer!
-	 */
-	status = bm_evaluate_object(battery->acpi_handle, "_BIF", NULL,
-		&bif_buffer);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Extract Package Data:
-	 * ---------------------
-	 * Type-cast this bif_buffer to a package and use helper
-	 * functions to convert results into BT_BATTERY_INFO structure.
-	 * The first attempt is just to get the size of the package
-	 * data; the second gets the data (once we know the required
-	 * bif_buffer size).
-	 */
-	status = bm_cast_buffer(&bif_buffer, (void**)&package,
-		sizeof(acpi_object));
-	if (ACPI_FAILURE(status)) {
-		goto end;
-	}
-
-	package_format.length = sizeof("NNNNNNNNNSSSS");
-	package_format.pointer = "NNNNNNNNNSSSS";
-
-	memset(&package_data, 0, sizeof(acpi_buffer));
-
-	status = bm_extract_package_data(package, &package_format,
-		&package_data);
-	if (status != AE_BUFFER_OVERFLOW) {
-		if (status == AE_OK) {
-			status = AE_ERROR;
-		}
-		goto end;
-	}
-
-	package_data.pointer = acpi_os_callocate(package_data.length);
-	if (!package_data.pointer) {
-		return_ACPI_STATUS(AE_NO_MEMORY);
-	}
-
-	status = bm_extract_package_data(package, &package_format,
-		&package_data);
-	if (ACPI_FAILURE(status)) {
-		acpi_os_free(package_data.pointer);
-		goto end;
-	}
-
-	*battery_info = package_data.pointer;
-
-end:
-	acpi_os_free(bif_buffer.pointer);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	bt_get_status
- *
- * PARAMETERS:	
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bt_get_status (
-	BT_CONTEXT		*battery,
-	BT_BATTERY_STATUS	**battery_status)
-{
-	acpi_status 		status = AE_OK;
-	acpi_buffer 		bst_buffer, package_format, package_data;
-	acpi_object 		*package = NULL;
-
-	FUNCTION_TRACE("bt_get_status");
-
-	if (!battery || !battery_status || *battery_status) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	memset(&bst_buffer, 0, sizeof(acpi_buffer));
-
-	/*
-	 * Evalute _BST:
-	 * -------------
-	 * And be sure to deallocate bst_buffer.pointer!
-	 */
-	status = bm_evaluate_object(battery->acpi_handle, "_BST",
-		NULL, &bst_buffer);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Extract Package Data:
-	 * ---------------------
-	 * Type-cast this bst_buffer to a package and use helper
-	 * functions to convert results into BT_BATTERY_STATUS structure.
-	 * The first attempt is just to get the size of the package data;
-	 * the second gets the data (once we know the required bst_buffer
-	 * size).
-	 */
-	status = bm_cast_buffer(&bst_buffer, (void**)&package,
-		sizeof(acpi_object));
-	if (ACPI_FAILURE(status)) {
-		goto end;
-	}
-
-	package_format.length = sizeof("NNNN");
-	package_format.pointer = "NNNN";
-
-	memset(&package_data, 0, sizeof(acpi_buffer));
-
-	status = bm_extract_package_data(package, &package_format,
-		&package_data);
-	if (status != AE_BUFFER_OVERFLOW) {
-		if (status == AE_OK) {
-			status = AE_ERROR;
-		}
-		goto end;
-	}
-
-	package_data.pointer = acpi_os_callocate(package_data.length);
-	if (!package_data.pointer) {
-		return_ACPI_STATUS(AE_NO_MEMORY);
-	}
-
-	status = bm_extract_package_data(package, &package_format,
-		&package_data);
-	if (ACPI_FAILURE(status)) {
-		acpi_os_free(package_data.pointer);
-		goto end;
-	}
-
-	*battery_status = package_data.pointer;
-
-end:
-	acpi_os_free(bst_buffer.pointer);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	bt_check_device
- *
- * PARAMETERS:	
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bt_check_device (
-	BT_CONTEXT		*battery)
-{
-	acpi_status 		status = AE_OK;
-	BM_DEVICE_STATUS	battery_status = BM_STATUS_UNKNOWN;
-	u32 			was_present = FALSE;
-	BT_BATTERY_INFO 	*battery_info = NULL;
-
-	FUNCTION_TRACE("bt_check_device");
-
-	if (!battery) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	was_present = battery->is_present;
-
-	/*
-	 * Battery Present?
-	 * ----------------
-	 * Get the device status and check if battery slot is occupied.
-	 */
-	status = bm_get_device_status(battery->device_handle, &battery_status);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Unable to get battery status.\n"));
-		return_ACPI_STATUS(status);
-	}
-
-	if (battery_status & BM_STATUS_BATTERY_PRESENT) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Battery socket occupied.\n"));
-		battery->is_present = TRUE;
-	}
-	else {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Battery socket not occupied.\n"));
-		battery->is_present = FALSE;
-	}
-
-	/*
-	 * Battery Appeared?
-	 * -----------------
-	 */
-	if (!was_present && battery->is_present) {
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Battery insertion detected.\n"));
-
-		/*
-		 * Units of Power?
-		 * ---------------
-		 * Get the 'units of power', as we'll need this to report
-		 * status information.
-		 */
-		status = bt_get_info(battery, &battery_info);
-		if (ACPI_SUCCESS(status)) {
-			battery->power_units = (battery_info->power_unit)
-				? BT_POWER_UNITS_AMPS : BT_POWER_UNITS_WATTS;
-			acpi_os_free(battery_info);
-		}
-	}
-
-	/*
-	 * Battery Disappeared?
-	 * --------------------
-	 */
-	else if (was_present && !battery->is_present) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Battery removal detected.\n"));
-		battery->power_units = BT_POWER_UNITS_DEFAULT;
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/*****************************************************************************
- *
- * FUNCTION:	bt_add_device
- *
- * PARAMETERS:	
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bt_add_device (
-	BM_HANDLE		device_handle,
-	void			**context)
-{
-	acpi_status 		status = AE_OK;
-	BM_DEVICE		*device = NULL;
-	BT_CONTEXT		*battery = NULL;
-
-	FUNCTION_TRACE("bt_add_device");
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Adding battery device [%02x].\n", device_handle));
-
-	if (!context || *context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * Get information on this device.
-	 */
-	status = bm_get_device_info(device_handle, &device);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Allocate a new BT_CONTEXT structure.
-	 */
-	battery = acpi_os_callocate(sizeof(BT_CONTEXT));
-	if (!battery) {
-		return_ACPI_STATUS(AE_NO_MEMORY);
-	}
-
-	battery->device_handle = device->handle;
-	battery->acpi_handle = device->acpi_handle;
-	strncpy(battery->uid, device->id.uid, sizeof(battery->uid));
-
-	battery->power_units = BT_POWER_UNITS_DEFAULT;
-	battery->is_present = FALSE;
-
-	/*
-	 * See if battery is really present.
-	 */
-	status = bt_check_device(battery);
-	if (ACPI_FAILURE(status)) {
-		goto end;
-	}
-
-	status = bt_osl_add_device(battery);
-	if (ACPI_FAILURE(status)) {
-		goto end;
-	}
-
-	*context = battery;
-
-	bt_print(battery);
-
-end:
-	if (ACPI_FAILURE(status)) {
-		acpi_os_free(battery);
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/*****************************************************************************
- *
- * FUNCTION:	bt_remove_device
- *
- * PARAMETERS:	
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bt_remove_device (
-	void			**context)
-{
-	acpi_status 		status = AE_OK;
-	BT_CONTEXT		*battery = NULL;
-
-	FUNCTION_TRACE("bt_remove_device");
-
-	if (!context || !*context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	battery = (BT_CONTEXT*)*context;
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Removing battery device [%02x].\n", battery->device_handle));
-
-	bt_osl_remove_device(battery);
-
-	acpi_os_free(battery);
-
-	*context = NULL;
-
-	return_ACPI_STATUS(status);
-}
-
-
-/*****************************************************************************
- *                               External Functions
- *****************************************************************************/
-
-/*****************************************************************************
- *
- * FUNCTION:	bt_initialize
- *
- * PARAMETERS:	<none>
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bt_initialize (void)
-{
-	acpi_status		status = AE_OK;
-	BM_DEVICE_ID		criteria;
-	BM_DRIVER		driver;
-
-	FUNCTION_TRACE("bt_initialize");
-
-	memset(&criteria, 0, sizeof(BM_DEVICE_ID));
-	memset(&driver, 0, sizeof(BM_DRIVER));
-
-	/*
-	 * Register driver for driver method battery devices.
-	 */
-	MEMCPY(criteria.hid, BT_HID_CM_BATTERY, sizeof(BT_HID_CM_BATTERY));
-
-	driver.notify = &bt_notify;
-	driver.request = &bt_request;
-
-	status = bm_register_driver(&criteria, &driver);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	bt_terminate
- *
- * PARAMETERS:	<none>
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bt_terminate (void)
-{
-	acpi_status		status = AE_OK;
-	BM_DEVICE_ID		criteria;
-	BM_DRIVER		driver;
-
-	FUNCTION_TRACE("bt_terminate");
-
-	memset(&criteria, 0, sizeof(BM_DEVICE_ID));
-	memset(&driver, 0, sizeof(BM_DRIVER));
-
-	/*
-	 * Unregister driver for driver method battery devices.
-	 */
-	MEMCPY(criteria.hid, BT_HID_CM_BATTERY, sizeof(BT_HID_CM_BATTERY));
-
-	driver.notify = &bt_notify;
-	driver.request = &bt_request;
-
-	status = bm_unregister_driver(&criteria, &driver);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	bt_notify
- *
- * PARAMETERS:	<none>
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bt_notify (
-	BM_NOTIFY		notify_type,
-	BM_HANDLE		device_handle,
-	void			**context)
-{
-	acpi_status 		status = AE_OK;
-
-	FUNCTION_TRACE("bt_notify");
-
-	if (!context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	switch (notify_type) {
-
-	case BM_NOTIFY_DEVICE_ADDED:
-		status = bt_add_device(device_handle, context);
-		break;
-
-	case BM_NOTIFY_DEVICE_REMOVED:
-		status = bt_remove_device(context);
-		break;
-
-	case BT_NOTIFY_STATUS_CHANGE:
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Status change (_BST) event detected.\n"));
-		status = bt_osl_generate_event(notify_type,
-			((BT_CONTEXT*)*context));
-		break;
-
-	case BT_NOTIFY_INFORMATION_CHANGE:
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Information change (_BIF) event detected.\n"));
-		status = bt_check_device((BT_CONTEXT*)*context);
-		if (ACPI_SUCCESS(status)) {
-			status = bt_osl_generate_event(notify_type,
-				((BT_CONTEXT*)*context));
-		}
-		break;
-
-	default:
-		status = AE_SUPPORT;
-		break;
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	bt_request
- *
- * PARAMETERS:	
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bt_request (
-	BM_REQUEST		*request,
-	void			*context)
-{
-	acpi_status 		status = AE_OK;
-
-	FUNCTION_TRACE("bt_request");
-
-	/*
-	 * Must have a valid request structure and context.
-	 */
-	if (!request || !context)
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-
-	/*
-	 * Handle request:
-	 * ---------------
-	 */
-	switch (request->command) {
-
-	default:
-		status = AE_SUPPORT;
-		break;
-	}
-
-	request->status = status;
-
-	return_ACPI_STATUS(status);
-}
diff -urNp linux-5400/drivers/acpi/ospm/battery/bt_osl.c linux-5410/drivers/acpi/ospm/battery/bt_osl.c
--- linux-5400/drivers/acpi/ospm/battery/bt_osl.c
+++ linux-5410/drivers/acpi/ospm/battery/bt_osl.c
@@ -1,443 +0,0 @@
-/******************************************************************************
- *
- * Module Name: bt_osl.c
- *   $Revision: 24 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-/*
- * Changes:
- * Brendan Burns <bburns@wso.williams.edu> 2000-11-15
- * - added proc battery interface
- * - parse returned data from _BST and _BIF
- * Andy Grover <andrew.grover@intel.com> 2000-12-8
- * - improved proc interface
- */
-
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/proc_fs.h>
-#include <acpi.h>
-#include "bt.h"
-
-
-MODULE_AUTHOR("Andrew Grover");
-MODULE_DESCRIPTION("ACPI Component Architecture (CA) - Control Method Battery Driver");
-MODULE_LICENSE("GPL");
-
-
-#define BT_PROC_ROOT		"battery"
-#define BT_PROC_STATUS		"status"
-#define BT_PROC_INFO		"info"
-
-extern struct proc_dir_entry	*bm_proc_root;
-static struct proc_dir_entry	*bt_proc_root = NULL;
-
-
-/****************************************************************************
- *
- * FUNCTION:	bt_osl_proc_read_info
- *
- ****************************************************************************/
-
-static int
-bt_osl_proc_read_info (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*context)
-{
-	BT_CONTEXT		*battery = NULL;
-	BT_BATTERY_INFO 	*battery_info = NULL;
-	char			*p = page;
-	int 			len = 0;
-
-	if (!context || (off != 0)) {
-		goto end;
-	}
-
-	battery = (BT_CONTEXT*)context;
-
-	/*
-	 * Battery Present?
-	 * ----------------
-	 */
-	if (!battery->is_present) {
-		p += sprintf(p, "Present:                 no\n");
-		goto end;
-	}
-	else {
-		p += sprintf(p, "Present:                 yes\n");
-	}
-
-	/*
-	 * Get Battery Information:
-	 * ------------------------
-	 */
-	if (ACPI_FAILURE(bt_get_info(battery, &battery_info))) {
-		p += sprintf(p, "Error reading battery information (_BIF)\n");
-		goto end;
-	}
-
-	if (battery_info->design_capacity == BT_UNKNOWN) {
-		p += sprintf(p, "Design Capacity:         unknown\n");
-	}
-	else {
-		p += sprintf(p, "Design Capacity:         %d %sh\n",
-			 (u32)battery_info->design_capacity,
-			 battery->power_units);
-	}
-	
-	if (battery_info->last_full_capacity == BT_UNKNOWN) {
-		p += sprintf(p, "Last Full Capacity:      unknown\n");
-	}
-	else {
-		p += sprintf(p, "Last Full Capacity:      %d %sh\n",
-			 (u32)battery_info->last_full_capacity,
-			 battery->power_units);
-	}
-
-	if (battery_info->battery_technology == 0) {
-		p += sprintf(p, "Battery Technology:      primary (non-rechargeable)\n");
-	}
-	else if (battery_info->battery_technology == 1) {
-		p += sprintf(p, "Battery Technology:      secondary (rechargeable)\n");
-	}
-	else {
-		p += sprintf(p, "Battery Technology:      unknown\n");
-	}
-
-	if (battery_info->design_voltage == BT_UNKNOWN) {
-		p += sprintf(p, "Design Voltage:          unknown\n");
-	}
-	else {
-		p += sprintf(p, "Design Voltage:          %d mV\n",
-			 (u32)battery_info->design_voltage);
-	}
-	
-	p += sprintf(p, "Design Capacity Warning: %d %sh\n",
-		(u32)battery_info->design_capacity_warning,
-		battery->power_units);
-	p += sprintf(p, "Design Capacity Low:     %d %sh\n",
-		(u32)battery_info->design_capacity_low,
-		battery->power_units);
-	p += sprintf(p, "Capacity Granularity 1:  %d %sh\n",
-		(u32)battery_info->battery_capacity_granularity_1,
-		battery->power_units);
-	p += sprintf(p, "Capacity Granularity 2:  %d %sh\n",
-		(u32)battery_info->battery_capacity_granularity_2,
-		battery->power_units);
-	p += sprintf(p, "Model Number:            %s\n",
-		battery_info->model_number);
-	p += sprintf(p, "Serial Number:           %s\n",
-		battery_info->serial_number);
-	p += sprintf(p, "Battery Type:            %s\n",
-		battery_info->battery_type);
-	p += sprintf(p, "OEM Info:                %s\n",
-		battery_info->oem_info);
-	
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	acpi_os_free(battery_info);
-
-	return(len);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	bt_osl_proc_read_status
- *
- ****************************************************************************/
-
-static int
-bt_osl_proc_read_status (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*context)
-{
-	BT_CONTEXT		*battery = NULL;
-	BT_BATTERY_STATUS	*battery_status = NULL;
-	char			*p = page;
-	int 			len = 0;
-
-	if (!context || (off != 0)) {
-		goto end;
-	}
-
-	battery = (BT_CONTEXT*)context;
-
-	/*
-	 * Battery Present?
-	 * ----------------
-	 */
-	if (!battery->is_present) {
-		p += sprintf(p, "Present:                 no\n");
-		goto end;
-	}
-	else {
-		p += sprintf(p, "Present:                 yes\n");
-	}
-
-	/*
-	 * Get Battery Status:
-	 * -------------------
-	 */
-	if (ACPI_FAILURE(bt_get_status(battery, &battery_status))) {
-		p += sprintf(p, "Error reading battery status (_BST)\n");
-		goto end;
-	}
-
-	/*
-	 * Store Data:
-	 * -----------
-	 */
-
-	if (!battery_status->state) {
-		p += sprintf(p, "State:                   ok\n");
-	}
-	else {
-		if (battery_status->state & 0x1)
-			p += sprintf(p, "State:                   discharging\n");
-		if (battery_status->state & 0x2)
-			p += sprintf(p, "State:                   charging\n");
-		if (battery_status->state & 0x4)
-			p += sprintf(p, "State:                   critically low\n");
-	}
-
-	if (battery_status->present_rate == BT_UNKNOWN) {
-		p += sprintf(p, "Present Rate:            unknown\n");
-	}
-	else {
-		p += sprintf(p, "Present Rate:            %d %s\n",
-			(u32)battery_status->present_rate,
-			battery->power_units);
-	}
-
-	if (battery_status->remaining_capacity == BT_UNKNOWN) {
-		p += sprintf(p, "Remaining Capacity:      unknown\n");
-	}
-	else {
-		p += sprintf(p, "Remaining Capacity:      %d %sh\n",
-			(u32)battery_status->remaining_capacity,
-			battery->power_units);
-	}
-
-	if (battery_status->present_voltage == BT_UNKNOWN) {
-		p += sprintf(p, "Battery Voltage:         unknown\n");
-	}
-	else {
-		p += sprintf(p, "Battery Voltage:         %d mV\n",
-			(u32)battery_status->present_voltage);
-	}
-
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	acpi_os_free(battery_status);
-
-	return(len);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	bt_osl_add_device
- *
- ****************************************************************************/
-
-acpi_status
-bt_osl_add_device(
-	BT_CONTEXT		*battery)
-{
-	struct proc_dir_entry	*proc_entry = NULL;
-
-	if (!battery) {
-		return(AE_BAD_PARAMETER);
-	}
-
-	if (battery->is_present) {
-		printk("ACPI: Battery socket found, battery present\n");
-	}
-	else {
-		printk("ACPI: Battery socket found, battery absent\n");
-	}
-
-	proc_entry = proc_mkdir(battery->uid, bt_proc_root);
-	if (!proc_entry) {
-		return(AE_ERROR);
-	}
-
-	create_proc_read_entry(BT_PROC_STATUS, S_IFREG | S_IRUGO,
-		proc_entry, bt_osl_proc_read_status, (void*)battery);
-
-	create_proc_read_entry(BT_PROC_INFO, S_IFREG | S_IRUGO,
-		proc_entry, bt_osl_proc_read_info, (void*)battery);
-
-	return(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	bt_osl_remove_device
- *
- ****************************************************************************/
-
-acpi_status
-bt_osl_remove_device (
-	BT_CONTEXT		*battery)
-{
-	char			proc_entry[64];
-
-	if (!battery) {
-		return(AE_BAD_PARAMETER);
-	}
-
-	sprintf(proc_entry, "%s/%s", battery->uid, BT_PROC_INFO);
-	remove_proc_entry(proc_entry, bt_proc_root);
-
-	sprintf(proc_entry, "%s/%s", battery->uid, BT_PROC_STATUS);
-	remove_proc_entry(proc_entry, bt_proc_root);
-
-	sprintf(proc_entry, "%s", battery->uid);
-	remove_proc_entry(proc_entry, bt_proc_root);
-
-	return(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	bt_osl_generate_event
- *
- ****************************************************************************/
-
-acpi_status
-bt_osl_generate_event (
-	u32			event,
-	BT_CONTEXT		*battery)
-{
-	acpi_status		status = AE_OK;
-
-	if (!battery) {
-		return(AE_BAD_PARAMETER);
-	}
-
-	switch (event) {
-
-	case BT_NOTIFY_STATUS_CHANGE:
-	case BT_NOTIFY_INFORMATION_CHANGE:
-		status = bm_osl_generate_event(battery->device_handle,
-			BT_PROC_ROOT, battery->uid, event, 0);
-		break;
-
-	default:
-		return(AE_BAD_PARAMETER);
-		break;
-	}
-
-	return(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	bt_osl_init
- *
- * PARAMETERS:	<none>
- *
- * RETURN:	0: Success
- *
- * DESCRIPTION: Module initialization.
- *
- ****************************************************************************/
-
-static int __init
-bt_osl_init (void)
-{
-	acpi_status		status = AE_OK;
-
-	/* abort if no busmgr */
-	if (!bm_proc_root)
-		return -ENODEV;
-
-	bt_proc_root = proc_mkdir(BT_PROC_ROOT, bm_proc_root);
-	if (!bt_proc_root) {
-		status = AE_ERROR;
-	}
-	else {
-		status = bt_initialize();
-		if (ACPI_FAILURE(status)) {
-			remove_proc_entry(BT_PROC_ROOT, bm_proc_root);
-		}
-	}
-
-	return (ACPI_SUCCESS(status)) ? 0 : -ENODEV;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	bt_osl_cleanup
- *
- * PARAMETERS:	<none>
- *
- * RETURN:	<none>
- *
- * DESCRIPTION: Module cleanup.
- *
- ****************************************************************************/
-
-static void __exit
-bt_osl_cleanup (void)
-{
-	bt_terminate();
-
-	if (bt_proc_root) {
-		remove_proc_entry(BT_PROC_ROOT, bm_proc_root);
-	}
-
-	return;
-}
-
-
-module_init(bt_osl_init);
-module_exit(bt_osl_cleanup);
diff -urNp linux-5400/drivers/acpi/ospm/busmgr/Makefile linux-5410/drivers/acpi/ospm/busmgr/Makefile
--- linux-5400/drivers/acpi/ospm/busmgr/Makefile
+++ linux-5410/drivers/acpi/ospm/busmgr/Makefile
@@ -1,8 +0,0 @@
-export-objs	:= bm_osl.o
-
-O_TARGET	:= ospm_$(notdir $(CURDIR)).o
-obj-m		:= $(O_TARGET)
-EXTRA_CFLAGS	+= $(ACPI_CFLAGS)
-obj-y		:= $(patsubst %.c,%.o,$(wildcard *.c))
-
-include $(TOPDIR)/Rules.make
diff -urNp linux-5400/drivers/acpi/ospm/busmgr/bm.c linux-5410/drivers/acpi/ospm/busmgr/bm.c
--- linux-5400/drivers/acpi/ospm/busmgr/bm.c
+++ linux-5410/drivers/acpi/ospm/busmgr/bm.c
@@ -1,1146 +0,0 @@
-/******************************************************************************
- *
- * Module Name: bm.c
- *   $Revision: 48 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <acpi.h>
-#include "bm.h"
-
-
-#define _COMPONENT		ACPI_BUS
-	MODULE_NAME		("bm")
-
-
-/****************************************************************************
- *                                  Globals
- ****************************************************************************/
-
-extern fadt_descriptor_rev2	acpi_fadt;
-/* TBD: Make dynamically sizeable. */
-BM_NODE_LIST			node_list;
-
-
-/****************************************************************************
- *                            Internal Functions
- ****************************************************************************/
-
-/*****************************************************************************
- *
- * FUNCTION:    bm_print_object
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-void
-bm_print_object (
-	acpi_handle		handle)
-{
-	acpi_buffer		buffer;
-	acpi_handle		parent;
-	acpi_object_type	type;
-
-	buffer.length = 256;
-	buffer.pointer = acpi_os_callocate(buffer.length);
-	if (!buffer.pointer) {
-		return;
-	}
-
-	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
-	acpi_get_parent(handle, &parent);
-	acpi_get_type(handle, &type);
-
-	/*
-	 * TBD: Hack to get around scope identification problem.
-	 */
-	if (type == ACPI_TYPE_ANY) {
-		if (ACPI_SUCCESS(acpi_get_next_object(ACPI_TYPE_ANY,
-			handle, 0, NULL))) {
-			type = INTERNAL_TYPE_SCOPE;
-		}
-	}
-
-	switch (type)
-	 {
-	case INTERNAL_TYPE_SCOPE:
-		acpi_os_printf("SCOPE: ");
-		break;
-	case ACPI_TYPE_INTEGER:
-		acpi_os_printf("SIMPLE (number): ");
-		break;
-	case ACPI_TYPE_STRING:
-		acpi_os_printf("SIMPLE (string): ");
-		break;
-	case ACPI_TYPE_BUFFER:
-		acpi_os_printf("SIMPLE (buffer): ");
-		break;
-	case ACPI_TYPE_PACKAGE:
-		acpi_os_printf("SIMPLE (package): ");
-		break;
-	case ACPI_TYPE_FIELD_UNIT:
-		acpi_os_printf("FIELD UNIT: ");
-		break;
-	case ACPI_TYPE_DEVICE:
-		acpi_os_printf("DEVICE: ");
-		break;
-	case ACPI_TYPE_EVENT:
-		acpi_os_printf("EVENT: ");
-		break;
-	case ACPI_TYPE_METHOD:
-		acpi_os_printf("CONTROL METHOD: ");
-		break;
-	case ACPI_TYPE_MUTEX:
-		acpi_os_printf("MUTEX: ");
-		break;
-	case ACPI_TYPE_REGION:
-		acpi_os_printf("OPERATION REGION: ");
-		break;
-	case ACPI_TYPE_POWER:
-		acpi_os_printf("POWER RESOURCE: ");
-		break;
-	case ACPI_TYPE_PROCESSOR:
-		acpi_os_printf("PROCESSOR: ");
-		break;
-	case ACPI_TYPE_THERMAL:
-		acpi_os_printf("THERMAL ZONE: ");
-		break;
-	case ACPI_TYPE_BUFFER_FIELD:
-		acpi_os_printf("BUFFER FIELD: ");
-		break;
-	case ACPI_TYPE_DDB_HANDLE:
-		acpi_os_printf("DDB HANDLE: ");
-		break;
-	default:
-		acpi_os_printf("OTHER (%d): ", type);
-		break;
-	}
-
-	acpi_os_printf("Object[%p][%s] parent[%p].\n", handle, (char*)buffer.pointer, parent);
-
-	acpi_os_free(buffer.pointer);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_print_node
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-void
-bm_print_node (
-	BM_NODE			*node,
-	u32                     flags)
-{
-#ifdef ACPI_DEBUG
-	acpi_buffer             buffer;
-	BM_DEVICE		*device = NULL;
-	char                    *type_string = NULL;
-
-	PROC_NAME("bm_print_node");
-
-	if (!node) {
-		return;
-	}
-
-	device = &(node->device);
-
-	if (flags & BM_PRINT_PRESENT) {
-		if (!BM_DEVICE_PRESENT(device)) {
-			return;
-		}
-	}
-
-	buffer.length = 256;
-	buffer.pointer = acpi_os_callocate(buffer.length);
-	if (!buffer.pointer) {
-		return;
-	}
-
-	acpi_get_name(device->acpi_handle, ACPI_FULL_PATHNAME, &buffer);
-
-	switch(device->id.type) {
-	case BM_TYPE_SYSTEM:
-		type_string = " System";
-		break;
-	case BM_TYPE_SCOPE:
-		type_string = "  Scope";
-		break;
-	case BM_TYPE_PROCESSOR:
-		type_string = "   Proc";
-		break;
-	case BM_TYPE_THERMAL_ZONE:
-		type_string = "Thermal";
-		break;
-	case BM_TYPE_POWER_RESOURCE:
-		type_string = "  Power";
-		break;
-	case BM_TYPE_FIXED_BUTTON:
-		type_string = " Button";
-		break;
-	case BM_TYPE_DEVICE:
-		type_string = " Device";
-		break;
-	default:
-		type_string = "Unknown";
-		break;
-	}
-
-	if (!(flags & BM_PRINT_GROUP)) {
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "+-------------------------------------------------------------------------------\n"));
-	}
-
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "| %s[%02x]:[%p] flags[%02x] hid[%s] %s\n", type_string, device->handle, device->acpi_handle, device->flags, (device->id.hid[0] ? device->id.hid : "       "), (char*)buffer.pointer));
-
-	if (flags & BM_PRINT_IDENTIFICATION) {
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "|   identification: uid[%s] adr[%08x]\n", device->id.uid, device->id.adr));
-	}
-
-	if (flags & BM_PRINT_LINKAGE) {
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "|   linkage: this[%p] parent[%p] next[%p]\n", node, node->parent, node->next));
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "|     scope.head[%p] scope.tail[%p]\n", node->scope.head, node->scope.tail));
-	}
-
-	if (flags & BM_PRINT_POWER) {
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "|   power: state[D%d] flags[%08x]\n", device->power.state, device->power.flags));
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "|     S0[%02x] S1[%02x] S2[%02x] S3[%02x] S4[%02x] S5[%02x]\n", device->power.dx_supported[0], device->power.dx_supported[1], device->power.dx_supported[2], device->power.dx_supported[3], device->power.dx_supported[4], device->power.dx_supported[5]));
-	}
-
-	if (!(flags & BM_PRINT_GROUP)) {
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "+-------------------------------------------------------------------------------\n"));
-	}
-
-	acpi_os_free(buffer.pointer);
-#endif /*ACPI_DEBUG*/
-
-	return;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_print_hierarchy
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-void
-bm_print_hierarchy (void)
-{
-#ifdef ACPI_DEBUG
-	u32			i = 0;
-
-	FUNCTION_TRACE("bm_print_hierarchy");
-
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "+------------------------------------------------------------\n"));
-
-	for (i = 0; i < node_list.count; i++) {
-		bm_print_node(node_list.nodes[i], BM_PRINT_GROUP | BM_PRINT_PRESENT);
-	}
-
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "+------------------------------------------------------------\n"));
-#endif /*ACPI_DEBUG*/
-
-	return_VOID;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_get_status
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_get_status (
-	BM_DEVICE		*device)
-{
-	acpi_status           status = AE_OK;
-
-	if (!device) {
-		return AE_BAD_PARAMETER;
-	}
-
-	device->status = BM_STATUS_UNKNOWN;
-
-	/*
-	 * Dynamic Status?
-	 * ---------------
-	 * If _STA isn't present we just return the default status.
-	 */
-	if (!(device->flags & BM_FLAGS_DYNAMIC_STATUS)) {
-		device->status = BM_STATUS_DEFAULT;
-		return AE_OK;
-	}
-
-	/*
-	 * Evaluate _STA:
-	 * --------------
-	 */
-	status = bm_evaluate_simple_integer(device->acpi_handle, "_STA",
-		&(device->status));
-
-	return status;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_get_identification
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_get_identification (
-	BM_DEVICE		*device)
-{
-	acpi_status             status = AE_OK;
-	acpi_device_info        info;
-
-	if (!device) {
-		return AE_BAD_PARAMETER;
-	}
-
-	if (!(device->flags & BM_FLAGS_IDENTIFIABLE)) {
-		return AE_OK;
-	}
-
-	device->id.uid[0] = BM_UID_UNKNOWN;
-	device->id.hid[0] = BM_HID_UNKNOWN;
-	device->id.adr = BM_ADDRESS_UNKNOWN;
-
-	/*
-	 * Get Object Info:
-	 * ----------------
-	 * Evalute _UID, _HID, and _ADR...
-	 */
-	status = acpi_get_object_info(device->acpi_handle, &info);
-	if (ACPI_FAILURE(status)) {
-		return status;
-	}
-
-	if (info.valid & ACPI_VALID_UID) {
-		MEMCPY((void*)device->id.uid, (void*)info.unique_id,
-			sizeof(BM_DEVICE_UID));
-	}
-
-	if (info.valid & ACPI_VALID_HID) {
-		MEMCPY((void*)device->id.hid, (void*)info.hardware_id,
-			sizeof(BM_DEVICE_HID));
-	}
-
-	if (info.valid & ACPI_VALID_ADR) {
-		device->id.adr = info.address;
-	}
-
-	return status;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_get_flags
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_get_flags (
-	BM_DEVICE		*device)
-{
-	acpi_handle		acpi_handle = NULL;
-
-	if (!device) {
-		return AE_BAD_PARAMETER;
-	}
-
-	device->flags = BM_FLAGS_UNKNOWN;
-
-	switch (device->id.type) {
-
-	case BM_TYPE_DEVICE:
-
-		/*
-		 * Presence of _DCK indicates a docking station.
-		 */
-		if (ACPI_SUCCESS(acpi_get_handle(device->acpi_handle,
-			"_DCK", &acpi_handle))) {
-			device->flags |= BM_FLAGS_DOCKING_STATION;
-		}
-
-		/*
-		 * Presence of _EJD and/or _EJx indicates 'ejectable'.
-		 * TBD: _EJx...
-		 */
-		if (ACPI_SUCCESS(acpi_get_handle(device->acpi_handle,
-			"_EJD", &acpi_handle))) {
-			device->flags |= BM_FLAGS_EJECTABLE;
-		}
-
-		/*
-		 * Presence of _PR0 or _PS0 indicates 'power manageable'.
-		 */
-		if (ACPI_SUCCESS(acpi_get_handle(device->acpi_handle,
-			"_PR0", &acpi_handle)) ||
-			ACPI_SUCCESS(acpi_get_handle(device->acpi_handle,
-			"_PS0", &acpi_handle))) {
-			device->flags |= BM_FLAGS_POWER_CONTROL;
-		}
-
-		/*
-		 * Presence of _CRS indicates 'configurable'.
-		 */
-		if (ACPI_SUCCESS(acpi_get_handle(device->acpi_handle,
-			"_CRS", &acpi_handle))) {
-			device->flags |= BM_FLAGS_CONFIGURABLE;
-		}
-
-		/* Fall through to next case statement. */
-
-	case BM_TYPE_PROCESSOR:
-	case BM_TYPE_THERMAL_ZONE:
-	case BM_TYPE_POWER_RESOURCE:
-		/*
-		 * Presence of _HID or _ADR indicates 'identifiable'.
-		 */
-		if (ACPI_SUCCESS(acpi_get_handle(device->acpi_handle,
-			"_HID", &acpi_handle)) ||
-		   ACPI_SUCCESS(acpi_get_handle(device->acpi_handle,
-		   "_ADR", &acpi_handle))) {
-			device->flags |= BM_FLAGS_IDENTIFIABLE;
-		}
-
-		/*
-		 * Presence of _STA indicates 'dynamic status'.
-		 */
-		if (ACPI_SUCCESS(acpi_get_handle(device->acpi_handle,
-			"_STA", &acpi_handle))) {
-			device->flags |= BM_FLAGS_DYNAMIC_STATUS;
-		}
-
-		break;
-	}
-
-	return AE_OK;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_add_namespace_device
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_add_namespace_device (
-	acpi_handle             acpi_handle,
-	acpi_object_type        acpi_type,
-	BM_NODE			*parent,
-	BM_NODE			**child)
-{
-	acpi_status             status = AE_OK;
-	BM_NODE			*node = NULL;
-	BM_DEVICE		*device = NULL;
-
-	FUNCTION_TRACE("bm_add_namespace_device");
-
-	if (!parent || !child) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	if (node_list.count > BM_HANDLES_MAX) {
-		return_ACPI_STATUS(AE_NO_MEMORY);
-	}
-
-	(*child) = NULL;
-
-	/*
-	 * Create Node:
-	 * ------------
-	 */
-	node = acpi_os_callocate(sizeof(BM_NODE));
-	if (!node) {
-		return_ACPI_STATUS(AE_NO_MEMORY);
-	}
-
-	node->parent = parent;
-	node->next = NULL;
-
-	device = &(node->device);
-
-	device->handle = node_list.count;
-	device->acpi_handle = acpi_handle;
-
-	/*
-	 * Device Type:
-	 * ------------
-	 */
-	switch (acpi_type) {
-	case INTERNAL_TYPE_SCOPE:
-		device->id.type = BM_TYPE_SCOPE;
-		break;
-	case ACPI_TYPE_PROCESSOR:
-		device->id.type = BM_TYPE_PROCESSOR;
-		break;
-	case ACPI_TYPE_THERMAL:
-		device->id.type = BM_TYPE_THERMAL_ZONE;
-		break;
-	case ACPI_TYPE_POWER:
-		device->id.type = BM_TYPE_POWER_RESOURCE;
-		break;
-	case ACPI_TYPE_DEVICE:
-		device->id.type = BM_TYPE_DEVICE;
-		break;
-	}
-
-	/*
-	 * Get Other Device Info:
-	 * ----------------------
-	 * But only if this device's parent is present (which implies
-	 * this device MAY be present).
-	 */
-	if (BM_NODE_PRESENT(node->parent)) {
-		/*
-		 * Device Flags
-		 */
-		status = bm_get_flags(device);
-		if (ACPI_FAILURE(status)) {
-			goto end;
-		}
-
-		/*
-		 * Device Identification
-		 */
-		status = bm_get_identification(device);
-		if (ACPI_FAILURE(status)) {
-			goto end;
-		}
-
-		/*
-		 * Device Status
-		 */
-		status = bm_get_status(device);
-		if (ACPI_FAILURE(status)) {
-			goto end;
-		}
-
-		/*
-		 * Power Management:
-		 * -----------------
-		 * If this node doesn't provide direct power control
-		 * then we inherit PM capabilities from its parent.
-		 *
-		 * TBD: Inherit!
-		 */
-		if (BM_IS_POWER_CONTROL(device)) {
-			status = bm_get_pm_capabilities(node);
-			if (ACPI_FAILURE(status)) {
-				goto end;
-			}
-		}
-	}
-
-end:
-	if (ACPI_FAILURE(status)) {
-		acpi_os_free(node);
-	}
-	else {
-		/*
-		 * Add to the node_list.
-		 */
-		node_list.nodes[node_list.count++] = node;
-
-		/*
-		 * Formulate Hierarchy:
-		 * --------------------
-		 * Arrange within the namespace by assigning the parent and
-		 * adding to the parent device's list of children (scope).
-		 */
-		if (!parent->scope.head) {
-			parent->scope.head = node;
-		}
-		else {
-			if (!parent->scope.tail) {
-				(parent->scope.head)->next = node;
-			}
-			else {
-				(parent->scope.tail)->next = node;
-			}
-		}
-		parent->scope.tail = node;
-
-		(*child) = node;
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_enumerate_namespace
- *
- * PARAMETERS:  <none>
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_enumerate_namespace (void)
-{
-	acpi_status		status = AE_OK;
-	acpi_handle             parent_handle = ACPI_ROOT_OBJECT;
-	acpi_handle             child_handle = NULL;
-	BM_NODE			*parent = NULL;
-	BM_NODE			*child = NULL;
-	acpi_object_type        acpi_type = 0;
-	u32                     level = 1;
-
-	FUNCTION_TRACE("bm_enumerate_namespace");
-
-	parent = node_list.nodes[0];
-
-	/*
-	 * Enumerate ACPI Namespace:
-	 * -------------------------
-	 * Parse through the ACPI namespace, identify all 'devices',
-	 * and create a new entry for each in our collection.
-	 */
-	while (level > 0) {
-
-		/*
-		 * Get the next object at this level.
-		 */
-		status = acpi_get_next_object(ACPI_TYPE_ANY, parent_handle, child_handle, &child_handle);
-		if (ACPI_SUCCESS(status)) {
-			/*
-			 * TBD: This is a hack to get around the problem
-			 *       identifying scope objects.  Scopes
-			 *       somehow need to be uniquely identified.
-			 */
-			status = acpi_get_type(child_handle, &acpi_type);
-			if (ACPI_SUCCESS(status) && (acpi_type == ACPI_TYPE_ANY)) {
-				status = acpi_get_next_object(ACPI_TYPE_ANY, child_handle, 0, NULL);
-				if (ACPI_SUCCESS(status)) {
-					acpi_type = INTERNAL_TYPE_SCOPE;
-				}
-			}
-
-			/*
-			 * Device?
-			 * -------
-			 * If this object is a 'device', insert into the
-			 * ACPI Bus Manager's local hierarchy and search
-			 * the object's scope for any child devices (a
-			 * depth-first search).
-			 */
-			switch (acpi_type) {
-			case INTERNAL_TYPE_SCOPE:
-			case ACPI_TYPE_DEVICE:
-			case ACPI_TYPE_PROCESSOR:
-			case ACPI_TYPE_THERMAL:
-			case ACPI_TYPE_POWER:
-				status = bm_add_namespace_device(child_handle, acpi_type, parent, &child);
-				if (ACPI_SUCCESS(status)) {
-					status = acpi_get_next_object(ACPI_TYPE_ANY, child_handle, 0, NULL);
-					if (ACPI_SUCCESS(status)) {
-						level++;
-						parent_handle = child_handle;
-						child_handle = 0;
-						parent = child;
-					}
-				}
-				break;
-			}
-		}
-
-		/*
-		 * Scope Exhausted:
-		 * ----------------
-		 * No more children in this object's scope, Go back up
-		 * in the namespace tree to the object's parent.
-		 */
-		else {
-			level--;
-			child_handle = parent_handle;
-			acpi_get_parent(parent_handle,
-				&parent_handle);
-
-			if (parent) {
-				parent = parent->parent;
-			}
-			else {
-				return_ACPI_STATUS(AE_NULL_ENTRY);
-			}
-		}
-	}
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_add_fixed_feature_device
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_add_fixed_feature_device (
-	BM_NODE			*parent,
-	BM_DEVICE_TYPE		device_type,
-	char			*device_hid)
-{
-	acpi_status             status = AE_OK;
-	BM_NODE			*node = NULL;
-
-	FUNCTION_TRACE("bm_add_fixed_feature_device");
-
-	if (!parent) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	if (node_list.count > BM_HANDLES_MAX) {
-		return_ACPI_STATUS(AE_NO_MEMORY);
-	}
-
-	/*
-	 * Allocate the new device and add to the device array.
-	 */
-	node = acpi_os_callocate(sizeof(BM_NODE));
-	if (!node) {
-		return_ACPI_STATUS(AE_NO_MEMORY);
-	}
-
-	/*
-	 * Get device info.
-	 */
-	node->device.handle = node_list.count;
-	node->device.acpi_handle = ACPI_ROOT_OBJECT;
-	node->device.id.type = BM_TYPE_FIXED_BUTTON;
-	if (device_hid) {
-		MEMCPY((void*)node->device.id.hid, device_hid,
-			sizeof(node->device.id.hid));
-	}
-	node->device.flags = BM_FLAGS_FIXED_FEATURE;
-	node->device.status = BM_STATUS_DEFAULT;
-	/* TBD: Device PM capabilities */
-
-	/*
-	 * Add to the node_list.
-	 */
-	node_list.nodes[node_list.count++] = node;
-
-	/*
-	 * Formulate Hierarchy:
-	 * --------------------
-	 * Arrange within the namespace by assigning the parent and
-	 * adding to the parent device's list of children (scope).
-	 */
-	node->parent = parent;
-	node->next = NULL;
-
-	if (parent) {
-		if (!parent->scope.head) {
-			parent->scope.head = node;
-		}
-		else {
-			if (!parent->scope.tail) {
-				(parent->scope.head)->next = node;
-			}
-			else {
-				(parent->scope.tail)->next = node;
-			}
-		}
-		parent->scope.tail = node;
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_enumerate_fixed_features
- *
- * PARAMETERS:  <none>
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_enumerate_fixed_features (void)
-{
-	FUNCTION_TRACE("bm_enumerate_fixed_features");
-
-	/*
-	 * Root Object:
-	 * ------------
-	 * Fabricate the root object, which happens to always get a
-	 * device_handle of zero.
-	 */
-	node_list.nodes[0] = acpi_os_callocate(sizeof(BM_NODE));
-	if (NULL == (node_list.nodes[0])) {
-		return_ACPI_STATUS(AE_NO_MEMORY);
-	}
-
-	node_list.nodes[0]->device.handle = BM_HANDLE_ROOT;
-	node_list.nodes[0]->device.acpi_handle = ACPI_ROOT_OBJECT;
-	node_list.nodes[0]->device.flags = BM_FLAGS_UNKNOWN;
-	node_list.nodes[0]->device.status = BM_STATUS_DEFAULT;
-	node_list.nodes[0]->device.id.type = BM_TYPE_SYSTEM;
-	/* TBD: Get system PM capabilities (Sx states?) */
-
-	node_list.count++;
-
-	/*
-	 * Fixed Features:
-	 * ---------------
-	 * Enumerate fixed-feature devices (e.g. power and sleep buttons).
-	 */
-	if (acpi_fadt.pwr_button == 0) {
-		bm_add_fixed_feature_device(node_list.nodes[0],
-			BM_TYPE_FIXED_BUTTON, BM_HID_POWER_BUTTON);
-	}
-
-	if (acpi_fadt.sleep_button == 0) {
-		bm_add_fixed_feature_device(node_list.nodes[0],
-			BM_TYPE_FIXED_BUTTON, BM_HID_SLEEP_BUTTON);
-	}
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_get_handle
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_get_handle (
-	acpi_handle             acpi_handle,
-	BM_HANDLE               *device_handle)
-{
-	acpi_status             status = AE_NOT_FOUND;
-	u32			i = 0;
-
-	FUNCTION_TRACE("bm_get_handle");
-
-	if (!device_handle) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	*device_handle = BM_HANDLE_UNKNOWN;
-
-	/*
-	 * Search all devices for a match on the ACPI handle.
-	 */
-	for (i=0; i<node_list.count; i++) {
-
-		if (!node_list.nodes[i]) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid (NULL) node entry [%p] detected.\n", device_handle));
-			status = AE_NULL_ENTRY;
-			break;
-		}
-
-		if (node_list.nodes[i]->device.acpi_handle == acpi_handle) {
-			*device_handle = node_list.nodes[i]->device.handle;
-			status = AE_OK;
-			break;
-		}
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_get_node
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_get_node (
-	BM_HANDLE               device_handle,
-	acpi_handle             acpi_handle,
-	BM_NODE			**node)
-{
-	acpi_status             status = AE_OK;
-
-	FUNCTION_TRACE("bm_get_node");
-
-	if (!node) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/* busmgr failed to init, but we're being called by subordinate drivers */
-	if (node_list.count < 1) {
-		return_ACPI_STATUS(AE_NOT_FOUND);
-	}
-
-	/*
-	 * If no device handle, resolve acpi handle to device handle.
-	 */
-	if (!device_handle && acpi_handle) {
-		status = bm_get_handle(acpi_handle, &device_handle);
-		if (ACPI_FAILURE(status))
-			return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Valid device handle?
-	 */
-	if (device_handle > BM_HANDLES_MAX) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid node handle [%02x] detected.\n", device_handle));
-		return_ACPI_STATUS(AE_ERROR);
-	}
-
-	*node = node_list.nodes[device_handle];
-
-	/*
-	 * Valid node?
-	 */
-	if (!(*node)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid (NULL) node entry [%02x] detected.\n", device_handle));
-		return_ACPI_STATUS(AE_NULL_ENTRY);
-	}
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/****************************************************************************
- *                            External Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:    bm_initialize
- *
- * PARAMETERS:  <none>
- *
- * RETURN:      Exception code.
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_initialize (void)
-{
-	acpi_status             status = AE_OK;
-	u32                     start = 0;
-	u32                     stop = 0;
-	u32                     elapsed = 0;
-
-	FUNCTION_TRACE("bm_initialize");
-
-	MEMSET(&node_list, 0, sizeof(BM_NODE_LIST));
-
-	status = acpi_get_timer(&start);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Building device hierarchy.\n"));
-
-	/*
-	 * Enumerate ACPI fixed-feature devices.
-	 */
-	status = bm_enumerate_fixed_features();
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Enumerate the ACPI namespace.
-	 */
-	status = bm_enumerate_namespace();
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	acpi_get_timer(&stop);
-	acpi_get_timer_duration(start, stop, &elapsed);
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Building device hierarchy took [%d] microseconds.\n", elapsed));
-
-	/*
-	 * Display hierarchy.
-	 */
-	bm_print_hierarchy();
-
-	/*
-	 * Register for all standard and device-specific notifications.
-	 */
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Registering for all device notifications.\n"));
-
-	status = acpi_install_notify_handler(ACPI_ROOT_OBJECT,
-		ACPI_SYSTEM_NOTIFY, &bm_notify, NULL);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unable to register for standard notifications.\n"));
-		return_ACPI_STATUS(status);
-	}
-
-	status = acpi_install_notify_handler(ACPI_ROOT_OBJECT,
-		ACPI_DEVICE_NOTIFY, &bm_notify, NULL);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unable to register for device-specific notifications.\n"));
-		return_ACPI_STATUS(status);
-	}
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "ACPI Bus Manager enabled.\n"));
-
-	/*
-	 * Initialize built-in power resource driver.
-	 */
-	bm_pr_initialize();
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_terminate
- *
- * PARAMETERS:  <none>
- *
- * RETURN:      Exception code.
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_terminate (void)
-{
-	acpi_status             status = AE_OK;
-	u32                     i = 0;
-
-	FUNCTION_TRACE("bm_terminate");
-
-	/*
-	 * Terminate built-in power resource driver.
-	 */
-	bm_pr_terminate();
-
-	/*
-	 * Unregister for all notifications.
-	 */
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Unregistering for device notifications.\n"));
-
-	status = acpi_remove_notify_handler(ACPI_ROOT_OBJECT,
-		ACPI_SYSTEM_NOTIFY, &bm_notify);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unable to un-register for standard notifications.\n"));
-	}
-
-	status = acpi_remove_notify_handler(ACPI_ROOT_OBJECT,
-		ACPI_DEVICE_NOTIFY, &bm_notify);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unable to un-register for device-specific notifications.\n"));
-	}
-
-	/*
-	 * Parse through the device array, freeing all entries.
-	 */
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Removing device hierarchy.\n"));
-	for (i = 0; i < node_list.count; i++) {
-		if (node_list.nodes[i]) {
-			acpi_os_free(node_list.nodes[i]);
-		}
-	}
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "ACPI Bus Manager disabled.\n"));
-
-	return_ACPI_STATUS(AE_OK);
-}
diff -urNp linux-5400/drivers/acpi/ospm/busmgr/bm_osl.c linux-5410/drivers/acpi/ospm/busmgr/bm_osl.c
--- linux-5400/drivers/acpi/ospm/busmgr/bm_osl.c
+++ linux-5410/drivers/acpi/ospm/busmgr/bm_osl.c
@@ -1,390 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: bm_osl.c
- *   $Revision: 17 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/proc_fs.h>
-#include <linux/spinlock.h>
-#include <linux/poll.h>
-#include <asm/uaccess.h>
-#include <acpi.h>
-#include "bm.h"
-
-
-MODULE_AUTHOR("Andrew Grover");
-MODULE_DESCRIPTION("ACPI Component Architecture (CA) - ACPI Bus Manager");
-MODULE_LICENSE("GPL");
-
-
-/*****************************************************************************
- *                               Types & Defines
- *****************************************************************************/
-
-typedef struct
-{
-	BM_HANDLE		device_handle;
-	char			*device_type;
-	char			*device_instance;
-	u32			event_type;
-	u32			event_data;
-	struct list_head	list;
-} BM_OSL_EVENT;
-
-
-#define BM_PROC_ROOT		"acpi"
-#define BM_PROC_EVENT		"event"
-#define BM_PROC_DEVICES		"devices"
-
-#define BM_MAX_STRING_LENGTH	80
-
-
-/****************************************************************************
- *                                  Globals
- ****************************************************************************/
-
-struct proc_dir_entry		*bm_proc_root = NULL;
-static struct proc_dir_entry	*bm_proc_event = NULL;
-
-#ifdef ACPI_DEBUG
-static u32			save_dbg_layer;
-static u32			save_dbg_level;
-#endif /*ACPI_DEBUG*/
-
-extern BM_NODE_LIST		node_list;
-
-static spinlock_t		bm_osl_event_lock = SPIN_LOCK_UNLOCKED;
-
-static LIST_HEAD(bm_event_list);
-
-static DECLARE_WAIT_QUEUE_HEAD(bm_event_wait_queue);
-
-static int event_is_open = 0;
-
-
-/****************************************************************************
- *                                 Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:	bm_osl_generate_event
- *
- * DESCRIPTION: Generates an event for user-space consumption by writing
- *              the event data to the 'event' file.
- *
- ****************************************************************************/
-
-acpi_status
-bm_osl_generate_event (
-	BM_HANDLE		device_handle,
-	char			*device_type,
-	char			*device_instance,
-	u32			event_type,
-	u32			event_data)
-{
-	BM_OSL_EVENT		*event = NULL;
-	unsigned long		flags = 0;
-
-	/* drop event on the floor if no one's listening */
-	if (!event_is_open)
-		return (AE_OK);
-
-	/*
-	 * Allocate a new event structure.
-	 */
-	event = acpi_os_callocate(sizeof(BM_OSL_EVENT));
-	if (!event)
-		goto alloc_error;
-
-	event->device_type = acpi_os_callocate(strlen(device_type)
-		+ sizeof(char));
-	if (!event->device_type)
-		goto alloc_error;
-
-	event->device_instance = acpi_os_callocate(strlen(device_instance)
-		+ sizeof(char));
-	if (!event->device_instance)
-		goto alloc_error;
-
-	/*
-	 * Set event data.
-	 */
-	event->device_handle = device_handle;
-	strcpy(event->device_type, device_type);
-	strcpy(event->device_instance, device_instance);
-	event->event_type = event_type;
-	event->event_data = event_data;
-
-	/*
-	 * Add to the end of our event list.
-	 */
-	spin_lock_irqsave(&bm_osl_event_lock, flags);
-	list_add_tail(&event->list, &bm_event_list);
-	spin_unlock_irqrestore(&bm_osl_event_lock, flags);
-
-	/*
-	 * Signal waiting threads (if any).
-	 */
-	wake_up_interruptible(&bm_event_wait_queue);
-
-	return(AE_OK);
-
-alloc_error:
-	if (event->device_instance)
-		acpi_os_free(event->device_instance);
-
-	if (event->device_type)
-		acpi_os_free(event->device_type);
-
-	if (event)
-		acpi_os_free(event);		
-
-	return (AE_NO_MEMORY);
-}
-
-static int bm_osl_open_event(struct inode *inode, struct file *file)
-{
-	spin_lock_irq (&bm_osl_event_lock);
-
-	if(event_is_open)
-		goto out_busy;
-
-	event_is_open = 1;
-
-	spin_unlock_irq (&bm_osl_event_lock);
-	return 0;
-
-out_busy:
-	spin_unlock_irq (&bm_osl_event_lock);
-	return -EBUSY;
-}
-
-
-static int bm_osl_close_event(struct inode *inode, struct file *file)
-{
-	event_is_open = 0;
-	return 0;
-}
-
-/****************************************************************************
- *
- * FUNCTION:	bm_osl_read_event
- *
- * DESCRIPTION: Handles reads to the 'event' file by blocking user-mode
- *              threads until data (an event) is generated.
- *
- ****************************************************************************/
-static ssize_t
-bm_osl_read_event(
-	struct file		*file,
-	char			*buf,
-	size_t			count,
-	loff_t			*ppos)
-{
-	BM_OSL_EVENT		*event = NULL;
-	unsigned long		flags = 0;
-	static char		str[BM_MAX_STRING_LENGTH];
-	static int		chars_remaining = 0;
-	static char 		*ptr;
-
-	if (!chars_remaining) {
-		DECLARE_WAITQUEUE(wait, current);
-
-		if (list_empty(&bm_event_list)) {
-
-			if (file->f_flags & O_NONBLOCK)
-				return -EAGAIN;
-
-			set_current_state(TASK_INTERRUPTIBLE);
-			add_wait_queue(&bm_event_wait_queue, &wait);
-
-			if (list_empty(&bm_event_list)) {
-				schedule();
-			}
-
-			remove_wait_queue(&bm_event_wait_queue, &wait);
-			set_current_state(TASK_RUNNING);
-
-			if (signal_pending(current)) {
-				return -ERESTARTSYS;
-			}
-		}
-
-		spin_lock_irqsave(&bm_osl_event_lock, flags);
-		event = list_entry(bm_event_list.next, BM_OSL_EVENT, list);
-		list_del(&event->list);
-		spin_unlock_irqrestore(&bm_osl_event_lock, flags);
-
-		chars_remaining = sprintf(str, "%s %s %08x %08x\n",
-			event->device_type, event->device_instance,
-			event->event_type, event->event_data);
-		ptr = str;
-
-		acpi_os_free(event->device_type);
-		acpi_os_free(event->device_instance);
-		acpi_os_free(event);
-	}
-
-	if (chars_remaining < count)
-		count = chars_remaining;
-	
-	if (copy_to_user(buf, ptr, count))
-		return -EFAULT;
-
-	*ppos += count;
-	chars_remaining -= count;
-	ptr += count;
-
-	return count;
-}
-
-/****************************************************************************
- *
- * FUNCTION:	bm_osl_poll_event
- *
- * DESCRIPTION: Handles poll() of the 'event' file by blocking user-mode 
- *              threads until data (an event) is generated.
- *
- ****************************************************************************/
-static unsigned int
-bm_osl_poll_event(
-	struct file		*file, 
-	poll_table		*wait)
-{
-	poll_wait(file, &bm_event_wait_queue, wait);
-	if (!list_empty(&bm_event_list))
-		return POLLIN | POLLRDNORM;
-	return 0;
-}
-
-struct file_operations proc_event_operations = {
-	open:		bm_osl_open_event,
-	read:		bm_osl_read_event,
-	release:	bm_osl_close_event,
-	poll:		bm_osl_poll_event,	
-};
-
-/****************************************************************************
- *
- * FUNCTION:    bm_osl_init
- *
- ****************************************************************************/
-
-int
-bm_osl_init(void)
-{
-	acpi_status		status = AE_OK;
-
-	status = acpi_subsystem_status();
-	if (ACPI_FAILURE(status))
-		return -ENODEV;
-
-	bm_proc_root = proc_mkdir(BM_PROC_ROOT, NULL);
-	if (!bm_proc_root) {
-		return(AE_ERROR);
-	}
-
-	bm_proc_event = create_proc_entry(BM_PROC_EVENT, S_IRUSR, bm_proc_root);
-	if (bm_proc_event) {
-		bm_proc_event->proc_fops = &proc_event_operations;
-	}
-
-	status = bm_initialize();
-
-	return (ACPI_SUCCESS(status)) ? 0 : -ENODEV;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_osl_cleanup
- *
- ****************************************************************************/
-
-void
-bm_osl_cleanup(void)
-{
-	bm_terminate();
-
-	if (bm_proc_event) {
-		remove_proc_entry(BM_PROC_EVENT, bm_proc_root);
-		bm_proc_event = NULL;
-	}
-
-	if (bm_proc_root) {
-		remove_proc_entry(BM_PROC_ROOT, NULL);
-		bm_proc_root = NULL;
-	}
-
-	return;
-}
-
-
-module_init(bm_osl_init);
-module_exit(bm_osl_cleanup);
-
-
-/****************************************************************************
- *                                  Symbols
- ****************************************************************************/
-
-/* bm.c */
-
-EXPORT_SYMBOL(bm_get_node);
-
-/* bmdriver.c */
-
-EXPORT_SYMBOL(bm_get_device_power_state);
-EXPORT_SYMBOL(bm_set_device_power_state);
-EXPORT_SYMBOL(bm_get_device_info);
-EXPORT_SYMBOL(bm_get_device_status);
-EXPORT_SYMBOL(bm_get_device_context);
-EXPORT_SYMBOL(bm_register_driver);
-EXPORT_SYMBOL(bm_unregister_driver);
-
-/* bmsearch.c */
-
-EXPORT_SYMBOL(bm_search);
-
-/* bmrequest.c */
-
-EXPORT_SYMBOL(bm_request);
-
-/* bmutils.c */
-
-EXPORT_SYMBOL(bm_extract_package_data);
-EXPORT_SYMBOL(bm_evaluate_object);
-EXPORT_SYMBOL(bm_evaluate_simple_integer);
-EXPORT_SYMBOL(bm_evaluate_reference_list);
-EXPORT_SYMBOL(bm_copy_to_buffer);
-EXPORT_SYMBOL(bm_cast_buffer);
-
-/* bm_proc.c */
-
-EXPORT_SYMBOL(bm_osl_generate_event);
-EXPORT_SYMBOL(bm_proc_root);
diff -urNp linux-5400/drivers/acpi/ospm/busmgr/bmdriver.c linux-5410/drivers/acpi/ospm/busmgr/bmdriver.c
--- linux-5400/drivers/acpi/ospm/busmgr/bmdriver.c
+++ linux-5410/drivers/acpi/ospm/busmgr/bmdriver.c
@@ -1,469 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: bmdriver.c
- *   $Revision: 21 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include <acpi.h>
-#include "bm.h"
-
-#define _COMPONENT		ACPI_BUS
-	MODULE_NAME		("bmdriver")
-
-
-/****************************************************************************
- *                            External Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:    bm_get_device_power_state
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_get_device_power_state (
-	BM_HANDLE               device_handle,
-	BM_POWER_STATE		*state)
-{
-	acpi_status             status = AE_OK;
-	BM_NODE			*node = NULL;
-
-	FUNCTION_TRACE("bm_get_device_power_state");
-
-	if (!state) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	*state = ACPI_STATE_UNKNOWN;
-
-	/*
-	 * Resolve device handle to node.
-	 */
-	status = bm_get_node(device_handle, 0, &node);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Get the current power state.
-	 */
-	status = bm_get_power_state(node);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	*state = node->device.power.state;
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_set_device_power_state
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_set_device_power_state (
-	BM_HANDLE               device_handle,
-	BM_POWER_STATE		state)
-{
-	acpi_status           status = AE_OK;
-	BM_NODE			*node = NULL;
-
-	FUNCTION_TRACE("bm_set_device_power_state");
-
-	/*
-	 * Resolve device handle to node.
-	 */
-	status = bm_get_node(device_handle, 0, &node);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Set the current power state.
-	 */
-	status = bm_set_power_state(node, state);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_get_device_status
- *
- * PARAMETERS:
- *    device_handle is really an index number into the array of BM_DEVICE
- *                  structures in info_list.  This data item is passed to
- *                  the registered program's "notify" callback.  It is used
- *                  to retrieve the specific BM_DEVICE structure instance
- *                  associated with the callback.
- *    device_status is a pointer that receives the result of processing
- *                  the device's associated ACPI _STA.
- *
- * RETURN:
- *    The acpi_status value indicates success AE_OK or failure of the function
- *
- * DESCRIPTION: Evaluates the device's ACPI _STA, if it is present.
- *
- ****************************************************************************/
-
-acpi_status
-bm_get_device_status (
-	BM_HANDLE               device_handle,
-	BM_DEVICE_STATUS        *device_status)
-{
-	acpi_status           status = AE_OK;
-	BM_NODE			*node = NULL;
-
-	FUNCTION_TRACE("bm_get_device_status");
-
-	if (!device_status) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	*device_status = BM_STATUS_UNKNOWN;
-
-	/*
-	 * Resolve device handle to node.
-	 */
-	status = bm_get_node(device_handle, 0, &node);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Parent Present?
-	 * ---------------
-	 * If the parent isn't present we can't evalute _STA on the child.
-	 * Return an unknown status.
-	 */
-	if (!BM_NODE_PRESENT(node->parent)) {
-		return_ACPI_STATUS(AE_OK);
-	}
-	
-	/*
-	 * Dynamic Status?
-	 * ---------------
-	 * If _STA isn't present we just return the default status.
-	 */
-	if (!(node->device.flags & BM_FLAGS_DYNAMIC_STATUS)) {
-		*device_status = BM_STATUS_DEFAULT;
-		return_ACPI_STATUS(AE_OK);
-	}
-
-	/*
-	 * Evaluate _STA:
-	 * --------------
-	 */
-	status = bm_evaluate_simple_integer(node->device.acpi_handle, "_STA",
-		&(node->device.status));
-	if (ACPI_SUCCESS(status)) {
-		*device_status = node->device.status;
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_get_device_info
- *
- * PARAMETERS:
- *    device_handle An index used to retrieve the associated BM_DEVICE info.
- *    device        A pointer to a BM_DEVICE structure instance pointer.
- *                  This pointed to BM_DEVICE structure will contain the
- *                  this device's information.
- *
- * RETURN:
- *    The acpi_status value indicates success AE_OK or failure of the function
- *
- * DESCRIPTION:
- *    Using the device_handle this function retrieves this device's
- *    BM_DEVICE structure instance and save's it in device.
- *
- ****************************************************************************/
-
-acpi_status
-bm_get_device_info (
-	BM_HANDLE               device_handle,
-	BM_DEVICE               **device)
-{
-	acpi_status           status = AE_OK;
-	BM_NODE			*node = NULL;
-
-	FUNCTION_TRACE("bm_get_device_info");
-
-	if (!device) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * Resolve device handle to internal device.
-	 */
-	status = bm_get_node(device_handle, 0, &node);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	*device = &(node->device);
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_get_device_context
- *
- *    device_handle An index used to retrieve the associated BM_DEVICE info.
- *    context       A pointer to a BM_DRIVER_CONTEXT structure instance.
- *
- * RETURN:
- *    The acpi_status value indicates success AE_OK or failure of the function
- *
- * DESCRIPTION:
- *    Using the device_handle this function retrieves this device's
- *    BM_DRIVER_CONTEXT structure instance and save's it in context.
- *
- ****************************************************************************/
-
-acpi_status
-bm_get_device_context (
-	BM_HANDLE               device_handle,
-	BM_DRIVER_CONTEXT	*context)
-{
-	acpi_status           status = AE_OK;
-	BM_NODE			*node = NULL;
-
-	FUNCTION_TRACE("bm_get_device_context");
-
-	if (!context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	*context = NULL;
-
-	/*
-	 * Resolve device handle to internal device.
-	 */
-	status = bm_get_node(device_handle, 0, &node);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	if (!node->driver.context) {
-		return_ACPI_STATUS(AE_NULL_ENTRY);
-	}
-
-	*context = node->driver.context;
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_register_driver
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_register_driver (
-	BM_DEVICE_ID		*criteria,
-	BM_DRIVER		*driver)
-{
-	acpi_status           status = AE_NOT_FOUND;
-	BM_HANDLE_LIST          device_list;
-	BM_NODE			*node = NULL;
-	BM_DEVICE		*device = NULL;
-	u32                     i = 0;
-
-	FUNCTION_TRACE("bm_register_driver");
-
-	if (!criteria || !driver || !driver->notify || !driver->request) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	MEMSET(&device_list, 0, sizeof(BM_HANDLE_LIST));
-
-	/*
-	 * Find Matches:
-	 * -------------
-	 * Search through the entire device hierarchy for matches against
-	 * the given device criteria.
-	 */
-	status = bm_search(BM_HANDLE_ROOT, criteria, &device_list);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Install driver:
-	 * ----------------
-	 * For each match, record the driver information and execute the
-	 * driver's Notify() funciton (if present) to notify the driver
-	 * of the device's presence.
-	 */
-	for (i = 0; i < device_list.count; i++) {
-
-		/* Resolve the device handle. */
-		status = bm_get_node(device_list.handles[i], 0, &node);
-		if (ACPI_FAILURE(status)) {
-			continue;
-		}
-
-		device = &(node->device);
-
-		/*
-		 * Make sure another driver hasn't already registered for
-		 * this device.
-		 */
-		if (BM_IS_DRIVER_CONTROL(device)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Another driver has already registered for device [%02x].\n", device->handle));
-			continue;
-		}
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Registering driver for device [%02x].\n", device->handle));
-
-		/* Notify driver of new device. */
-		status = driver->notify(BM_NOTIFY_DEVICE_ADDED,
-			node->device.handle, &(node->driver.context));
-		if (ACPI_SUCCESS(status)) {
-			node->driver.notify = driver->notify;
-			node->driver.request = driver->request;
-			node->device.flags |= BM_FLAGS_DRIVER_CONTROL;
-		}
-	}
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_unregister_driver
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_unregister_driver (
-	BM_DEVICE_ID		*criteria,
-	BM_DRIVER		*driver)
-{
-	acpi_status           status = AE_NOT_FOUND;
-	BM_HANDLE_LIST          device_list;
-	BM_NODE			*node = NULL;
-	BM_DEVICE		*device = NULL;
-	u32                     i = 0;
-
-	FUNCTION_TRACE("bm_unregister_driver");
-
-	if (!criteria || !driver || !driver->notify || !driver->request) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	MEMSET(&device_list, 0, sizeof(BM_HANDLE_LIST));
-
-	/*
-	 * Find Matches:
-	 * -------------
-	 * Search through the entire device hierarchy for matches against
-	 * the given device criteria.
-	 */
-	status = bm_search(BM_HANDLE_ROOT, criteria, &device_list);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Remove driver:
-	 * ---------------
-	 * For each match, execute the driver's Notify() function to allow
-	 * the driver to cleanup each device instance.
-	 */
-	for (i = 0; i < device_list.count; i++) {
-
-		/* Resolve the device handle. */
-		status = bm_get_node(device_list.handles[i], 0, &node);
-		if (ACPI_FAILURE(status)) {
-			continue;
-		}
-
-		device = &(node->device);
-
-		/*
-		 * Make sure driver has really registered for this device.
-		 */
-		if (!BM_IS_DRIVER_CONTROL(device)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Driver hasn't registered for device [%02x].\n", device->handle));
-			continue;
-		}
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Unregistering driver for device [%02x].\n", device->handle));
-
-		/* Notify driver of device removal. */
-		status = node->driver.notify(BM_NOTIFY_DEVICE_REMOVED,
-			node->device.handle, &(node->driver.context));
-		if (ACPI_SUCCESS(status)) {
-			node->driver.notify = NULL;
-			node->driver.request = NULL;
-			node->driver.context = NULL;
-			node->device.flags &= ~BM_FLAGS_DRIVER_CONTROL;
-		}
-	}
-
-	return_ACPI_STATUS(AE_OK);
-}
diff -urNp linux-5400/drivers/acpi/ospm/busmgr/bmnotify.c linux-5410/drivers/acpi/ospm/busmgr/bmnotify.c
--- linux-5400/drivers/acpi/ospm/busmgr/bmnotify.c
+++ linux-5410/drivers/acpi/ospm/busmgr/bmnotify.c
@@ -1,312 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: bmnotify.c
- *   $Revision: 21 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include <acpi.h>
-#include "bm.h"
-
-
-#define _COMPONENT		ACPI_BUS
-	 MODULE_NAME		("bmnotify")
-
-
-/****************************************************************************
- *                            Internal Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:    bm_generate_notify
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_generate_notify (
-	BM_NODE			*node,
-	u32			notify_type)
-{
-	acpi_status		status = AE_OK;
-	BM_DEVICE		*device = NULL;
-
-	FUNCTION_TRACE("bm_generate_notify");
-
-	if (!node) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	device = &(node->device);
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Sending notify [%02x] to device [%02x].\n", notify_type, node->device.handle));
-
-	if (!BM_IS_DRIVER_CONTROL(device)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "No driver installed for device [%02x].\n", device->handle));
-		return_ACPI_STATUS(AE_NOT_EXIST);
-	}
-
-	status = node->driver.notify(notify_type, node->device.handle,
-		&(node->driver.context));
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_device_check
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_device_check (
-	BM_NODE			*node,
-	u32			*status_change)
-{
-	acpi_status             status = AE_OK;
-	BM_DEVICE		*device = NULL;
-	BM_DEVICE_STATUS	old_status = BM_STATUS_UNKNOWN;
-
-	FUNCTION_TRACE("bm_device_check");
-
-	if (!node) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	device = &(node->device);
-
-	if (status_change) {
-		*status_change = FALSE;
-	}
-
-	old_status = device->status;
-
-	/*
-	 * Parent Present?
-	 * ---------------
-	 * Only check this device if its parent is present (which implies
-	 * this device MAY be present).
-	 */
-	if (!BM_NODE_PRESENT(node->parent)) {
-		return_ACPI_STATUS(AE_OK);
-	}
-
-	/*
-	 * Get Status:
-	 * -----------
-	 * And see if the status has changed.
-	 */
-	status = bm_get_status(device);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-	
-	if (old_status == node->device.status) {
-		return_ACPI_STATUS(AE_OK);
-	}
-
-	if (status_change) {
-		*status_change = TRUE;
-	}
-	
-	/*
-	 * Device Insertion?
-	 * -----------------
-	 */
-	if ((device->status & BM_STATUS_PRESENT) &&
-		!(old_status & BM_STATUS_PRESENT)) {
-		/* TBD: Make sure driver is loaded, and if not, load. */
-		status = bm_generate_notify(node, BM_NOTIFY_DEVICE_ADDED);
-	}
-
-	/*
-	 * Device Removal?
-	 * ---------------
-	 */
-	else if (!(device->status & BM_STATUS_PRESENT) &&
-		(old_status & BM_STATUS_PRESENT)) {
-		/* TBD: Unload driver if last device instance. */
-		status = bm_generate_notify(node, BM_NOTIFY_DEVICE_REMOVED);
-	}
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_bus_check
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_bus_check (
-	BM_NODE			*parent_node)
-{
-	acpi_status             status = AE_OK;
-	u32			status_change = FALSE;
-
-	FUNCTION_TRACE("bm_bus_check");
-
-	if (!parent_node) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * Status Change?
-	 * --------------
-	 */
-	status = bm_device_check(parent_node, &status_change);
-	if (ACPI_FAILURE(status) || !status_change) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Enumerate Scope:
-	 * ----------------
-	 * TBD: Enumerate child devices within this device's scope and
-	 *       run bm_device_check()'s on them...
-	 */
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/****************************************************************************
- *                            External Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:    bm_notify
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-void
-bm_notify (
-	acpi_handle             acpi_handle,
-	u32                     notify_value,
-	void                    *context)
-{
-	acpi_status             status = AE_OK;
-	BM_NODE			*node = NULL;
-
-	FUNCTION_TRACE("bm_notify");
-
-	/*
-	 * Resolve the ACPI handle.
-	 */
-	status = bm_get_node(0, acpi_handle, &node);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Recieved notify [%02x] for unknown device [%p].\n", notify_value, acpi_handle));
-		return_VOID;
-	}
-
-	/*
-	 * Device-Specific or Standard?
-	 * ----------------------------
-	 * Device-specific notifies are forwarded to the control module's
-	 * notify() function for processing.  Standard notifies are handled
-	 * internally.
-	 */
-	if (notify_value > 0x7F) {
-		status = bm_generate_notify(node, notify_value);
-	}
-	else {
-		switch (notify_value) {
-
-		case BM_NOTIFY_BUS_CHECK:
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Received BUS CHECK notification for device [%02x].\n", node->device.handle));
-			status = bm_bus_check(node);
-			break;
-
-		case BM_NOTIFY_DEVICE_CHECK:
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Received DEVICE CHECK notification for device [%02x].\n", node->device.handle));
-			status = bm_device_check(node, NULL);
-			break;
-
-		case BM_NOTIFY_DEVICE_WAKE:
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Received DEVICE WAKE notification for device [%02x].\n", node->device.handle));
-			/* TBD */
-			break;
-
-		case BM_NOTIFY_EJECT_REQUEST:
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Received EJECT REQUEST notification for device [%02x].\n", node->device.handle));
-			/* TBD */
-			break;
-
-		case BM_NOTIFY_DEVICE_CHECK_LIGHT:
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Received DEVICE CHECK LIGHT notification for device [%02x].\n", node->device.handle));
-			/* TBD: Exactly what does the 'light' mean? */
-			status = bm_device_check(node, NULL);
-			break;
-
-		case BM_NOTIFY_FREQUENCY_MISMATCH:
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Received FREQUENCY MISMATCH notification for device [%02x].\n", node->device.handle));
-			/* TBD */
-			break;
-
-		case BM_NOTIFY_BUS_MODE_MISMATCH:
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Received BUS MODE MISMATCH notification for device [%02x].\n", node->device.handle));
-			/* TBD */
-			break;
-
-		case BM_NOTIFY_POWER_FAULT:
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Received POWER FAULT notification.\n"));
-			/* TBD */
-			break;
-
-		default:
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Received unknown/unsupported notification.\n"));
-			break;
-		}
-	}
-
-	return_VOID;
-}
-
-
diff -urNp linux-5400/drivers/acpi/ospm/busmgr/bmpm.c linux-5410/drivers/acpi/ospm/busmgr/bmpm.c
--- linux-5400/drivers/acpi/ospm/busmgr/bmpm.c
+++ linux-5410/drivers/acpi/ospm/busmgr/bmpm.c
@@ -1,442 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: bmpm.c
- *   $Revision: 14 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include <acpi.h>
-#include "bm.h"
-#include "bmpower.h"
-
-
-#define _COMPONENT		ACPI_BUS
-	MODULE_NAME		("bmpm")
-
-
-/****************************************************************************
- *                             Internal Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:    bm_get_inferred_power_state
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_get_inferred_power_state (
-	BM_DEVICE               *device)
-{
-	acpi_status             status = AE_OK;
-	BM_HANDLE_LIST          pr_list;
-	BM_POWER_STATE          list_state = ACPI_STATE_UNKNOWN;
-	char                    object_name[5] = {'_','P','R','0','\0'};
-	u32                     i = 0;
-
-	FUNCTION_TRACE("bm_get_inferred_power_state");
-
-	if (!device) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	MEMSET(&pr_list, 0, sizeof(BM_HANDLE_LIST));
-
-	device->power.state = ACPI_STATE_D3;
-
-	/*
-	 * Calculate Power State:
-	 * ----------------------
-	 * Try to infer the devices's power state by checking the state of
-	 * the devices's power resources.  We start by evaluating _PR0
-	 * (resource requirements at D0) and work through _PR1 and _PR2.
-	 * We know the current devices power state when all resources (for
-	 * a give Dx state) are ON.  If no power resources are on then the
-	 * device is assumed to be off (D3).
-	 */
-	for (i=ACPI_STATE_D0; i<ACPI_STATE_D3; i++) {
-
-		object_name[3] = '0' + i;
-
-		status = bm_evaluate_reference_list(device->acpi_handle,
-			object_name, &pr_list);
-
-		if (ACPI_SUCCESS(status)) {
-
-			status = bm_pr_list_get_state(&pr_list, &list_state);
-
-			if (ACPI_SUCCESS(status)) {
-
-				if (list_state == ACPI_STATE_D0) {
-					device->power.state = i;
-					break;
-				}
-			}
-		}
-	}
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/****************************************************************************
- *                             External Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:    bm_get_power_state
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_get_power_state (
-	BM_NODE			*node)
-{
-	acpi_status             status = AE_OK;
-	BM_DEVICE               *device = NULL;
-
-	FUNCTION_TRACE("bm_get_power_state");
-
-	if (!node || !node->parent) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	device = &(node->device);
-
-	device->power.state = ACPI_STATE_UNKNOWN;
-
-	/*
-	 * Power Control?
-	 * --------------
-	 * If this device isn't directly power manageable (e.g. doesn't
-	 * include _PR0/_PS0) then there's nothing to do (state is static).
-	 */
-	if (!BM_IS_POWER_CONTROL(device)) {
-		return_ACPI_STATUS(AE_OK);
-	}
-
-	/*
-	 * Parent Present?
-	 * ---------------
-	 * Make sure the parent is present before mucking with the child.
-	 */
-	if (!BM_NODE_PRESENT(node->parent)) {
-		return_ACPI_STATUS(AE_NOT_EXIST);
-	}
-	
-	/*
-	 * Get Power State:
-	 * ----------------
-	 * Either directly (via _PSC) or inferred (via power resource
-	 * dependencies).
-	 */
-	if (BM_IS_POWER_STATE(device)) {
-		status = bm_evaluate_simple_integer(device->acpi_handle,
-			"_PSC", &(device->power.state));
-	}
-	else {
-		status = bm_get_inferred_power_state(device);
-	}
-
-	if (ACPI_SUCCESS(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Device [%02x] is at power state [D%d].\n", device->handle, device->power.state));
-	}
-	else {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Error getting power state for device [%02x]\n", device->handle));
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_set_power_state
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_set_power_state (
-	BM_NODE			*node,
-	BM_POWER_STATE          state)
-{
-	acpi_status             status = AE_OK;
-	BM_DEVICE		*device = NULL;
-	BM_DEVICE		*parent_device = NULL;
-	BM_HANDLE_LIST          current_list;
-	BM_HANDLE_LIST          target_list;
-	char                    object_name[5] = {'_','P','R','0','\0'};
-
-	FUNCTION_TRACE("bm_set_power_state");
-
-	if (!node || !node->parent || (state > ACPI_STATE_D3)) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	MEMSET(&current_list, 0, sizeof(BM_HANDLE_LIST));
-	MEMSET(&target_list, 0, sizeof(BM_HANDLE_LIST));
-
-	device = &(node->device);
-	parent_device = &(node->parent->device);
-
-	/*
-	 * Power Control?
-	 * --------------
-	 * If this device isn't directly power manageable (e.g. doesn't
-	 * include _PR0/_PS0) then return an error (can't set state).
-	 */
-	if (!BM_IS_POWER_CONTROL(device)) {
-		return_ACPI_STATUS(AE_ERROR);
-	}
-
-	/*
-	 * Parent Present?
-	 * ---------------
-	 * Make sure the parent is present before mucking with the child.
-	 */
-	if (!BM_NODE_PRESENT(node->parent)) {
-		return_ACPI_STATUS(AE_NOT_EXIST);
-	}
-	
-	/*
-	 * Check Parent's Power State:
-	 * ---------------------------
-	 * Can't be in a higher power state (lower Dx value) than parent.
-	 */
-	if (state < parent_device->power.state) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Cannot set device [%02x] to a higher-powered state than parent_device.\n", device->handle));
-		return_ACPI_STATUS(AE_ERROR);
-	}
-
-	/*
-	 * Get Resources:
-	 * --------------
-	 * Get the power resources associated with the device's current
-	 * and target power states.
-	 */
-	if (device->power.state != ACPI_STATE_UNKNOWN) {
-		object_name[3] = '0' + device->power.state;
-		bm_evaluate_reference_list(device->acpi_handle,
-			object_name, &current_list);
-	}
-
-	object_name[3] = '0' + state;
-	bm_evaluate_reference_list(device->acpi_handle, object_name,
-		&target_list);
-
-	/*
-	 * Transition Resources:
-	 * ---------------------
-	 * Transition all power resources referenced by this device to
-	 * the correct power state (taking into consideration sequencing
-	 * and dependencies to other devices).
-	 */
-	if (current_list.count || target_list.count) {
-		status = bm_pr_list_transition(&current_list, &target_list);
-	}
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Execute _PSx:
-	 * -------------
-	 * Execute the _PSx method corresponding to the target Dx state,
-	 * if it exists.
-	 */
-	object_name[2] = 'S';
-	object_name[3] = '0' + state;
-	bm_evaluate_object(device->acpi_handle, object_name, NULL, NULL);
-
-	if (ACPI_SUCCESS(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Device [%02x] is now at [D%d].\n", device->handle, state));
-		device->power.state = state;
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_get_pm_capabilities
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_get_pm_capabilities (
-	BM_NODE			*node)
-{
-	acpi_status             status = AE_OK;
-	BM_DEVICE		*device = NULL;
-	BM_DEVICE		*parent_device = NULL;
-	acpi_handle             acpi_handle = NULL;
-	BM_POWER_STATE          dx_supported = ACPI_STATE_UNKNOWN;
-	char                    object_name[5] = {'_','S','0','D','\0'};
-	u32                     i = 0;
-
-	FUNCTION_TRACE("bm_get_pm_capabilities");
-
-	if (!node || !node->parent) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	device = &(node->device);
-	parent_device = &(node->parent->device);
-
-	/*
-	 * Power Management Flags:
-	 * -----------------------
-	 */
-	if (ACPI_SUCCESS(acpi_get_handle(device->acpi_handle, "_PSC",
-		&acpi_handle))) {
-		device->power.flags |= BM_FLAGS_POWER_STATE;
-	}
-
-	if (ACPI_SUCCESS(acpi_get_handle(device->acpi_handle, "_IRC",
-		&acpi_handle))) {
-		device->power.flags |= BM_FLAGS_INRUSH_CURRENT;
-	}
-
-	if (ACPI_SUCCESS(acpi_get_handle(device->acpi_handle, "_PRW",
-		&acpi_handle))) {
-		device->power.flags |= BM_FLAGS_WAKE_CAPABLE;
-	}
-
-	/*
-	 * Device Power State:
-	 * -------------------
-	 * Note that we can't get the device's power state until we've
-	 * initialized all power resources, so for now we just set to
-	 * unknown.
-	 */
-	device->power.state = ACPI_STATE_UNKNOWN;
-
-	/*
-	 * Dx Supported in S0:
-	 * -------------------
-	 * Figure out which Dx states are supported by this device for the
-	 * S0 (working) state.  Note that D0 and D3 are required (assumed).
-	 */
-	device->power.dx_supported[ACPI_STATE_S0] = BM_FLAGS_D0_SUPPORT |
-		BM_FLAGS_D3_SUPPORT;
-
-	if ((ACPI_SUCCESS(acpi_get_handle(device->acpi_handle, "_PR1",
-		&acpi_handle))) ||
-		(ACPI_SUCCESS(acpi_get_handle(device->acpi_handle, "_PS1",
-		&acpi_handle)))) {
-		device->power.dx_supported[ACPI_STATE_S0] |=
-			BM_FLAGS_D1_SUPPORT;
-	}
-
-	if ((ACPI_SUCCESS(acpi_get_handle(device->acpi_handle, "_PR2",
-		&acpi_handle))) ||
-		(ACPI_SUCCESS(acpi_get_handle(device->acpi_handle, "_PS2",
-		&acpi_handle)))) {
-		device->power.dx_supported[ACPI_STATE_S0] |=
-			BM_FLAGS_D2_SUPPORT;
-	}
-
-	/*
-	 * Dx Supported in S1-S5:
-	 * ----------------------
-	 * Figure out which Dx states are supported by this device for
-	 * all other Sx states.
-	 */
-	for (i = ACPI_STATE_S1; i <= ACPI_STATE_S5; i++) {
-
-		/*
-		 * D3 support is assumed (off is always possible!).
-		 */
-		device->power.dx_supported[i] = BM_FLAGS_D3_SUPPORT;
-
-		/*
-		 * Evalute _Sx_d:
-		 * -------------
-		 * Which returns the highest (power) Dx state supported in
-		 * this system (Sx) state.  We convert this value to a bit
-		 * mask of supported states (conceptually simpler).
-		 */
-		status = bm_evaluate_simple_integer(device->acpi_handle,
-			object_name, &dx_supported);
-		if (ACPI_SUCCESS(status)) {
-			switch (dx_supported) {
-			case 0:
-				device->power.dx_supported[i] |=
-					BM_FLAGS_D0_SUPPORT;
-				/* fall through */
-			case 1:
-				device->power.dx_supported[i] |=
-					BM_FLAGS_D1_SUPPORT;
-				/* fall through */
-			case 2:
-				device->power.dx_supported[i] |=
-					BM_FLAGS_D2_SUPPORT;
-				/* fall through */
-			case 3:
-				device->power.dx_supported[i] |=
-					BM_FLAGS_D3_SUPPORT;
-				break;
-			}
-
-			/*
-			 * Validate:
-			 * ---------
-			 * Mask of any states that _Sx_d falsely advertises
-			 * (e.g.claims D1 support but neither _PR2 or _PS2
-			 * exist).  In other words, S1-S5 can't offer a Dx
-			 * state that isn't supported by S0.
-			 */
-			device->power.dx_supported[i] &=
-				device->power.dx_supported[ACPI_STATE_S0];
-		}
-
-		object_name[2]++;
-	}
-
-	return_ACPI_STATUS(AE_OK);
-}
diff -urNp linux-5400/drivers/acpi/ospm/busmgr/bmpower.c linux-5410/drivers/acpi/ospm/busmgr/bmpower.c
--- linux-5400/drivers/acpi/ospm/busmgr/bmpower.c
+++ linux-5410/drivers/acpi/ospm/busmgr/bmpower.c
@@ -1,664 +0,0 @@
-/****************************************************************************
- *
- * Module Name: bmpower.c - Driver for ACPI Power Resource 'devices'
- *   $Revision: 20 $
- *
- ****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-/*
- * TBD: 1. Sequencing of power resource list transitions.
- *	2. Global serialization of power resource transtions (see ACPI
- *         spec section 7.1.2/7.1.3).
- *      3. Better error handling.
- */
-
-
-#include <acpi.h>
-#include "bm.h"
-#include "bmpower.h"
-
-
-#define _COMPONENT		ACPI_BUS
-	MODULE_NAME		("bmpower")
-
-
-/****************************************************************************
- *                             Function Prototypes
- ****************************************************************************/
-
-acpi_status
-bm_pr_notify (
-	BM_NOTIFY               notify_type,
-	BM_HANDLE               device_handle,
-	void                    **context);
-	
-acpi_status
-bm_pr_request (
-	BM_REQUEST		*request,
-	void                    *context);
-
-	
-/****************************************************************************
- *                             Internal Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:    bm_pr_print
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_pr_print (
-	BM_POWER_RESOURCE	*pr)
-{
-	acpi_buffer             buffer;
-
-	PROC_NAME("bm_pr_print");
-
-	if (!pr) {
-		return(AE_BAD_PARAMETER);
-	}
-
-	buffer.length = 256;
-	buffer.pointer = acpi_os_callocate(buffer.length);
-	if (!buffer.pointer) {
-		return(AE_NO_MEMORY);
-	}
-
-	acpi_get_name(pr->acpi_handle, ACPI_FULL_PATHNAME, &buffer);
-
-	acpi_os_printf("Power Resource: found\n");
-
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "+------------------------------------------------------------\n"));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "| Power_resource[%02x]:[%p] %s\n", pr->device_handle, pr->acpi_handle, (char*)buffer.pointer));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "|   system_level[S%d] resource_order[%d]\n", pr->system_level, pr->resource_order));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "|   state[D%d] reference_count[%d]\n", pr->state, pr->reference_count));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "+------------------------------------------------------------\n"));
-
-	acpi_os_free(buffer.pointer);
-
-	return(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_pr_get_state
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_pr_get_state (
-	BM_POWER_RESOURCE	*pr)
-{
-	acpi_status             status = AE_OK;
-	BM_DEVICE_STATUS        device_status = BM_STATUS_UNKNOWN;
-
-	FUNCTION_TRACE("bm_pr_get_state");
-
-	if (!pr) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	pr->state = ACPI_STATE_UNKNOWN;
-
-	/*
-	 * Evaluate _STA:
-	 * --------------
-	 * Evalute _STA to determine whether the power resource is ON or OFF.
-	 * Note that if the power resource isn't present we'll get AE_OK but
-	 * an unknown status.
-	 */
-	status = bm_get_device_status(pr->device_handle, &device_status);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Error reading status for power resource [%02x].\n", pr->device_handle));
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Mask off all bits but the first as some systems return non-standard
-	 * values (e.g. 0x51).
-	 */
-	switch (device_status & 0x01) {
-	case 0:
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Power resource [%02x] is OFF.\n", pr->device_handle));
-		pr->state = ACPI_STATE_D3;
-		break;
-	case 1:
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Power resource [%02x] is ON.\n", pr->device_handle));
-		pr->state = ACPI_STATE_D0;
-		break;
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_pr_set_state
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_pr_set_state (
-	BM_POWER_RESOURCE	*pr,
-	BM_POWER_STATE          target_state)
-{
-	acpi_status             status = AE_OK;
-
-	FUNCTION_TRACE("bm_pr_set_state");
-
-	if (!pr) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	status = bm_pr_get_state(pr);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	if (target_state == pr->state) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Power resource [%02x] already at target power state [D%d].\n", pr->device_handle, pr->state));
-		return_ACPI_STATUS(AE_OK);
-	}
-
-	switch (target_state) {
-
-	case ACPI_STATE_D0:
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Turning power resource [%02x] ON.\n", pr->device_handle));
-		status = bm_evaluate_object(pr->acpi_handle, "_ON", NULL, NULL);
-		break;
-
-	case ACPI_STATE_D3:
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Turning power resource [%02x] OFF.\n", pr->device_handle));
-		status = bm_evaluate_object(pr->acpi_handle, "_OFF", NULL, NULL);
-		break;
-
-	default:
-		status = AE_BAD_PARAMETER;
-		break;
-	}
-
-	status = bm_pr_get_state(pr);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_pr_list_get_state
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_pr_list_get_state (
-	BM_HANDLE_LIST          *pr_list,
-	BM_POWER_STATE          *power_state)
-{
-	acpi_status             status = AE_OK;
-	BM_POWER_RESOURCE	*pr = NULL;
-	u32                     i = 0;
-
-	FUNCTION_TRACE("bm_pr_list_get_state");
-
-	if (!pr_list || !power_state) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	if (pr_list->count < 1) {
-		pr->state = ACPI_STATE_UNKNOWN;
-		return_ACPI_STATUS(AE_ERROR);
-	}
-
-	(*power_state) = ACPI_STATE_D0;
-
-	/*
-	 * Calculate Current power_state:
-	 * -----------------------------
-	 * The current state of a list of power resources is ON if all
-	 * power resources are currently in the ON state.  In other words,
-	 * if any power resource in the list is OFF then the collection
-	 * isn't fully ON.
-	 */
-	for (i = 0; i < pr_list->count; i++) {
-
-		status = bm_get_device_context(pr_list->handles[i],
-			(BM_DRIVER_CONTEXT*)(&pr));
-		if (ACPI_FAILURE(status)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Invalid reference to power resource [%02x].\n", pr_list->handles[i]));
-			(*power_state) = ACPI_STATE_UNKNOWN;
-			break;
-		}
-
-		status = bm_pr_get_state(pr);
-		if (ACPI_FAILURE(status)) {
-			(*power_state) = ACPI_STATE_UNKNOWN;
-			break;
-		}
-
-		if (pr->state != ACPI_STATE_D0) {
-			(*power_state) = pr->state;
-			break;
-		}
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_pr_list_transition
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_pr_list_transition (
-	BM_HANDLE_LIST          *current_list,
-	BM_HANDLE_LIST          *target_list)
-{
-	acpi_status             status = AE_OK;
-	BM_POWER_RESOURCE	*pr = NULL;
-	u32                     i = 0;
-
-	FUNCTION_TRACE("bm_pr_list_transition");
-
-	if (!current_list || !target_list) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * Reference Target:
-	 * -----------------
-	 * Reference all resources for the target power state first (so
-	 * the device doesn't get turned off while transitioning).  Power
-	 * resources that aren't on (new reference count of 1) are turned on.
-	 */
-	for (i = 0; i < target_list->count; i++) {
-
-		status = bm_get_device_context(target_list->handles[i],
-			(BM_DRIVER_CONTEXT*)(&pr));
-		if (ACPI_FAILURE(status)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Invalid reference to power resource [%02x].\n", target_list->handles[i]));
-			continue;
-		}
-
-		if (++pr->reference_count == 1) {
-			/* TBD: Need ordering based upon resource_order */
-			status = bm_pr_set_state(pr, ACPI_STATE_D0);
-			if (ACPI_FAILURE(status)) {
-				/* TBD: How do we handle this? */
-				ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Unable to change power state for power resource [%02x].\n", target_list->handles[i]));
-			}
-		}
-	}
-
-	/*
-	 * Dereference Current:
-	 * --------------------
-	 * Dereference all resources for the current power state.  Power
-	 * resources no longer referenced (new reference count of 0) are
-	 * turned off.
-	 */
-	for (i = 0; i < current_list->count; i++) {
-
-		status = bm_get_device_context(current_list->handles[i],
-			(BM_DRIVER_CONTEXT*)(&pr));
-		if (ACPI_FAILURE(status)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Invalid reference to power resource [%02x].\n", target_list->handles[i]));
-			continue;
-		}
-
-		if (--pr->reference_count == 0) {
-			/* TBD: Need ordering based upon resource_order */
-			status = bm_pr_set_state(pr, ACPI_STATE_D3);
-			if (ACPI_FAILURE(status)) {
-				/* TBD: How do we handle this? */
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unable to change power state for power resource [%02x].\n", current_list->handles[i]));
-			}
-		}
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_pr_add_device
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_pr_add_device (
-	BM_HANDLE               device_handle,
-	void                    **context)
-{
-	acpi_status             status = AE_OK;
-	BM_POWER_RESOURCE	*pr = NULL;
-	BM_DEVICE		*device = NULL;
-	acpi_buffer		buffer;
-	acpi_object		acpi_object;
-
-	FUNCTION_TRACE("bm_pr_add_device");
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Adding power resource [%02x].\n", device_handle));
-
-	if (!context || *context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	buffer.length = sizeof(acpi_object);
-	buffer.pointer = &acpi_object;
-
-	/*
-	 * Get information on this device.
-	 */
-	status = bm_get_device_info(device_handle, &device);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Allocate a new BM_POWER_RESOURCE structure.
-	 */
-	pr = acpi_os_callocate(sizeof(BM_POWER_RESOURCE));
-	if (!pr) {
-		return_ACPI_STATUS(AE_NO_MEMORY);
-	}
-
-	pr->device_handle = device->handle;
-	pr->acpi_handle = device->acpi_handle;
-
-	/*
-	 * Get information on this power resource.
-	 */
-	status = acpi_evaluate_object(pr->acpi_handle, NULL, NULL, &buffer);
-	if (ACPI_FAILURE(status)) {
-		goto end;
-	}
-
-	pr->system_level = acpi_object.power_resource.system_level;
-	pr->resource_order = acpi_object.power_resource.resource_order;
-	pr->state = ACPI_STATE_UNKNOWN;
-	pr->reference_count = 0;
-
-	/*
-	 * Get the power resource's current state (ON|OFF).
-	 */
-	status = bm_pr_get_state(pr);
-
-end:
-	if (ACPI_FAILURE(status)) {
-		acpi_os_free(pr);
-	}
-	else {
-		*context = pr;
-		bm_pr_print(pr);
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_pr_remove_device
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_pr_remove_device (
-	void                    **context)
-{
-	acpi_status             status = AE_OK;
-	BM_POWER_RESOURCE	*pr = NULL;
-
-	FUNCTION_TRACE("bm_pr_remove_device");
-
-	if (!context || !*context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	pr = (BM_POWER_RESOURCE*)*context;
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Removing power resource [%02x].\n", pr->device_handle));
-
-	acpi_os_free(pr);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *                             External Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:    bm_pr_initialize
- *
- * PARAMETERS:  <none>
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_pr_initialize (void)
-{
-	acpi_status             status = AE_OK;
-	BM_DEVICE_ID		criteria;
-	BM_DRIVER		driver;
-
-	FUNCTION_TRACE("bm_pr_initialize");
-
-	MEMSET(&criteria, 0, sizeof(BM_DEVICE_ID));
-	MEMSET(&driver, 0, sizeof(BM_DRIVER));
-
-	criteria.type = BM_TYPE_POWER_RESOURCE;
-
-	driver.notify = &bm_pr_notify;
-	driver.request = &bm_pr_request;
-
-	status = bm_register_driver(&criteria, &driver);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_pr_terminate
- *
- * PARAMETERS:
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_pr_terminate (void)
-{
-	acpi_status             status = AE_OK;
-	BM_DEVICE_ID		criteria;
-	BM_DRIVER		driver;
-
-	FUNCTION_TRACE("bm_pr_terminate");
-
-	MEMSET(&criteria, 0, sizeof(BM_DEVICE_ID));
-	MEMSET(&driver, 0, sizeof(BM_DRIVER));
-
-	criteria.type = BM_TYPE_POWER_RESOURCE;
-
-	driver.notify = &bm_pr_notify;
-	driver.request = &bm_pr_request;
-
-	status = bm_unregister_driver(&criteria, &driver);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_pr_notify
- *
- * PARAMETERS:
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_pr_notify (
-	BM_NOTIFY               notify_type,
-	BM_HANDLE               device_handle,
-	void                    **context)
-{
-	acpi_status             status = AE_OK;
-
-	FUNCTION_TRACE("bm_pr_notify");
-
-	switch (notify_type) {
-
-	case BM_NOTIFY_DEVICE_ADDED:
-		status = bm_pr_add_device(device_handle, context);
-		break;
-
-	case BM_NOTIFY_DEVICE_REMOVED:
-		status = bm_pr_remove_device(context);
-		break;
-
-	default:
-		status = AE_SUPPORT;
-		break;
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_pr_request
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_pr_request (
-	BM_REQUEST		*request,
-	void                    *context)
-{
-	acpi_status             status = AE_OK;
-	BM_POWER_RESOURCE	*pr = NULL;
-
-	FUNCTION_TRACE("bm_pr_request");
-
-	/*
-	 * Must have a valid request structure and context.
-	 */
-	if (!request || !context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * context contains information specific to this power resource.
-	 */
-	pr = (BM_POWER_RESOURCE*)context;
-
-	/*
-	 * Handle request:
-	 * ---------------
-	 */
-	switch (request->command) {
-
-	default:
-		status = AE_SUPPORT;
-		break;
-	}
-
-	request->status = status;
-
-	return_ACPI_STATUS(status);
-}
-
-
diff -urNp linux-5400/drivers/acpi/ospm/busmgr/bmrequest.c linux-5410/drivers/acpi/ospm/busmgr/bmrequest.c
--- linux-5400/drivers/acpi/ospm/busmgr/bmrequest.c
+++ linux-5410/drivers/acpi/ospm/busmgr/bmrequest.c
@@ -1,164 +0,0 @@
-/******************************************************************************
- *
- * Module Name: bmrequest.c
- *   $Revision: 16 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include <acpi.h>
-#include "bm.h"
-
-#define _COMPONENT		ACPI_BUS
-	MODULE_NAME		("bmrequest")
-
-
-/****************************************************************************
- *                            External Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:    bm_generate_request
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_generate_request (
-	BM_NODE			*node,
-	BM_REQUEST		*request)
-{
-	acpi_status             status = AE_OK;
-	BM_DEVICE		*device = NULL;
-
-	FUNCTION_TRACE("bm_generate_request");
-
-	if (!node || !request) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	device = &(node->device);
-
-	if (!BM_IS_DRIVER_CONTROL(device)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "No driver installed for device [%02x].\n", device->handle));
-		return_ACPI_STATUS(AE_NOT_EXIST);
-	}
-
-	status = node->driver.request(request, node->driver.context);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_request
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_request (
-	BM_REQUEST              *request)
-{
-	acpi_status             status = AE_OK;
-	BM_NODE			*node = NULL;
-	BM_DEVICE		*device = NULL;
-
-	FUNCTION_TRACE("bm_request");
-
-	/*
-	 * Must have a valid request structure.
-	 */
-	if (!request) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Received request for device [%02x] command [%02x].\n", request->handle, request->command));
-
-	/*
-	 * Resolve the node.
-	 */
-	status = bm_get_node(request->handle, 0, &node);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	device = &(node->device);
-
-	/*
-	 * Device-Specific Request?
-	 * ------------------------
-	 * If a device-specific command (>=0x80) forward this request to
-	 * the appropriate driver.
-	 */
-	if (request->command & BM_COMMAND_DEVICE_SPECIFIC) {
-		status = bm_generate_request(node, request);
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Bus-Specific Requests:
-	 * ----------------------
-	 */
-	switch (request->command) {
-
-	case BM_COMMAND_GET_POWER_STATE:
-		status = bm_get_power_state(node);
-		if (ACPI_FAILURE(status)) {
-			break;
-		}
-		status = bm_copy_to_buffer(&(request->buffer),
-			&(device->power.state), sizeof(BM_POWER_STATE));
-		break;
-
-	case BM_COMMAND_SET_POWER_STATE:
-	 {
-		BM_POWER_STATE *power_state = NULL;
-
-		status = bm_cast_buffer(&(request->buffer),
-			(void**)&power_state, sizeof(BM_POWER_STATE));
-		if (ACPI_FAILURE(status)) {
-			break;
-		}
-		status = bm_set_power_state(node, *power_state);
-	}
-		break;
-
-	default:
-		status = AE_SUPPORT;
-		request->status = AE_SUPPORT;
-		break;
-	}
-
-	return_ACPI_STATUS(status);
-}
diff -urNp linux-5400/drivers/acpi/ospm/busmgr/bmsearch.c linux-5410/drivers/acpi/ospm/busmgr/bmsearch.c
--- linux-5400/drivers/acpi/ospm/busmgr/bmsearch.c
+++ linux-5410/drivers/acpi/ospm/busmgr/bmsearch.c
@@ -1,192 +0,0 @@
-/******************************************************************************
- *
- * Module Name: bmsearch.c
- *   $Revision: 16 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include <acpi.h>
-#include "bm.h"
-
-
-#define _COMPONENT		ACPI_BUS
-	MODULE_NAME		("bmsearch")
-
-
-/****************************************************************************
- *                            External Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:    bm_compare
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_compare (
-	BM_DEVICE               *device,
-	BM_DEVICE_ID            *criteria)
-{
-	if (!device || !criteria) {
-		return AE_BAD_PARAMETER;
-	}
-
-	/*
-	 * Present?
-	 * --------
-	 * We're only going to match on devices that are present.
-	 * TBD: Optimize in bm_search (don't have to call here).
-	 */
-	if (!BM_DEVICE_PRESENT(device)) {
-		return AE_NOT_FOUND;
-	}
-
-	/*
-	 * Type?
-	 */
-	if (criteria->type && (criteria->type != device->id.type)) {
-		return AE_NOT_FOUND;
-	}
-
-	/*
-	 * HID?
-	 */
-	if ((criteria->hid[0]) && (0 != STRNCMP(criteria->hid,
-		device->id.hid, sizeof(BM_DEVICE_HID)))) {
-		return AE_NOT_FOUND;
-	}
-
-	/*
-	 * ADR?
-	 */
-	if ((criteria->adr) && (criteria->adr != device->id.adr)) {
-		return AE_NOT_FOUND;
-	}
-
-	return AE_OK;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_search
- *
- * PARAMETERS:
- *
- * RETURN:      AE_BAD_PARAMETER- invalid input parameter
- *              AE_NOT_EXIST    - start_device_handle doesn't exist
- *              AE_NOT_FOUND    - no matches to Search_info.criteria found
- *              AE_OK           - success
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_search(
-	BM_HANDLE               device_handle,
-	BM_DEVICE_ID            *criteria,
-	BM_HANDLE_LIST          *results)
-{
-	acpi_status             status = AE_OK;
-	BM_NODE			*node = NULL;
-
-	FUNCTION_TRACE("bm_search");
-
-	if (!criteria || !results) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	results->count = 0;
-
-	/*
-	 * Locate Starting Point:
-	 * ----------------------
-	 * Locate the node in the hierarchy where we'll begin our search.
-	 */
-	status = bm_get_node(device_handle, 0, &node);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Parse Hierarchy:
-	 * ----------------
-	 * Parse through the node hierarchy looking for matches.
-	 */
-	while (node && (results->count<=BM_HANDLES_MAX)) {
-		/*
-		 * Depth-first:
-		 * ------------
-		 * Searches are always performed depth-first.
-		 */
-		if (node->scope.head) {
-			status = bm_compare(&(node->device), criteria);
-			if (ACPI_SUCCESS(status)) {
-				results->handles[results->count++] =
-					node->device.handle;
-			}
-			node = node->scope.head;
-		}
-
-		/*
-		 * Now Breadth:
-		 * ------------
-		 * Search all peers until scope is exhausted.
-		 */
-		else {
-			status = bm_compare(&(node->device), criteria);
-			if (ACPI_SUCCESS(status)) {
-				results->handles[results->count++] =
-					node->device.handle;
-			}
-
-			/*
-			 * Locate Next Device:
-			 * -------------------
-			 * The next node is either a peer at this level
-			 * (node->next is valid), or we work are way back
-			 * up the tree until we either find a non-parsed
-			 * peer or hit the top (node->parent is NULL).
-			 */
-			while (!node->next && node->parent) {
-				node = node->parent;
-			}
-			node = node->next;
-		}
-	}
-
-	if (results->count == 0) {
-		return_ACPI_STATUS(AE_NOT_FOUND);
-	}
-	else {
-		return_ACPI_STATUS(AE_OK);
-	}
-}
-
diff -urNp linux-5400/drivers/acpi/ospm/busmgr/bmutils.c linux-5410/drivers/acpi/ospm/busmgr/bmutils.c
--- linux-5400/drivers/acpi/ospm/busmgr/bmutils.c
+++ linux-5410/drivers/acpi/ospm/busmgr/bmutils.c
@@ -1,611 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: bmutils.c
- *   $Revision: 43 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include <acpi.h>
-#include "bm.h"
-
-
-#define _COMPONENT		ACPI_BUS
-	MODULE_NAME		("bmutils")
-
-
-#ifdef ACPI_DEBUG
-#define DEBUG_EVAL_ERROR(l,h,p,s)    bm_print_eval_error(l,h,p,s)
-#else
-#define DEBUG_EVAL_ERROR(l,h,p,s)
-#endif
-
-
-/****************************************************************************
- *                            External Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:    bm_print_eval_error
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-void
-bm_print_eval_error (
-	u32                     debug_level,
-	acpi_handle             handle,
-	acpi_string             pathname,
-	acpi_status             status)
-{
-	acpi_buffer		buffer;
-	acpi_status		local_status;
-
-	PROC_NAME("bm_print_eval_error");
-
-	buffer.length = 256;
-	buffer.pointer = acpi_os_callocate(buffer.length);
-	if (!buffer.pointer) {
-		return;
-	}
-
-	local_status = acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
-	if (ACPI_FAILURE(local_status)) {
-		ACPI_DEBUG_PRINT((ACPI_DEBUG_LEVEL(debug_level), "Evaluate object [%p], %s\n", handle,
-			acpi_format_exception(status)));
-		return;
-	}
-
-	if (pathname) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Evaluate object [%s.%s], %s\n", (char*)buffer.pointer, pathname,
-			acpi_format_exception(status)));
-	}
-	else {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Evaluate object [%s], %s\n", (char*)buffer.pointer,
-			acpi_format_exception(status)));
-	}
-
-	acpi_os_free(buffer.pointer);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_copy_to_buffer
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_copy_to_buffer (
-	acpi_buffer             *buffer,
-	void                    *data,
-	u32                     length)
-{
-	FUNCTION_TRACE("bm_copy_to_buffer");
-
-	if (!buffer || (!buffer->pointer) || !data || (length == 0)) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	if (length > buffer->length) {
-		buffer->length = length;
-		return_ACPI_STATUS(AE_BUFFER_OVERFLOW);
-	}
-
-	buffer->length = length;
-	MEMCPY(buffer->pointer, data, length);
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_cast_buffer
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_cast_buffer (
-	acpi_buffer             *buffer,
-	void                    **pointer,
-	u32                     length)
-{
-	FUNCTION_TRACE("bm_cast_buffer");
-
-	if (!buffer || !buffer->pointer || !pointer || length == 0) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	if (length > buffer->length) {
-		return_ACPI_STATUS(AE_BAD_DATA);
-	}
-
-	*pointer = buffer->pointer;
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_extract_package_data
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_extract_package_data (
-	acpi_object             *package,
-	acpi_buffer             *format,
-	acpi_buffer             *buffer)
-{
-	u32                     tail_offset = 0;
-	u32                     size_required = 0;
-	char			*format_string = NULL;
-	u32                     format_count = 0;
-	u32                     i = 0;
-	u8                      *head = NULL;
-	u8                      *tail = NULL;
-
-	FUNCTION_TRACE("bm_extract_package_data");
-
-	if (!package || (package->type != ACPI_TYPE_PACKAGE) || (package->package.count < 1)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid 'package' argument\n"));
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	if (!format || !format->pointer || (format->length < 1)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid 'format' argument\n"));
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	if (!buffer) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid 'buffer' argument\n"));
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	format_count = (format->length/sizeof(char)) - 1;
-	if (format_count > package->package.count) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Format specifies more objects [%d] than exist in package [%d].", format_count, package->package.count));
-		return_ACPI_STATUS(AE_BAD_DATA);
-	}
-
-	format_string = (char*)format->pointer;
-
-	/*
-	 * Calculate size_required.
-	 */
-	for (i=0; i<format_count; i++) {
-
-		acpi_object *element = &(package->package.elements[i]);
-
-		if (!element) {
-			return_ACPI_STATUS(AE_BAD_DATA);
-		}
-
-		switch (element->type) {
-
-		case ACPI_TYPE_INTEGER:
-			switch (format_string[i]) {
-			case 'N':
-				size_required += sizeof(acpi_integer);
-				tail_offset += sizeof(acpi_integer);
-				break;
-			case 'S':
-				size_required += sizeof(char*) + sizeof(acpi_integer) + sizeof(char);
-				tail_offset += sizeof(char*);
-				break;
-			default:
-				ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid package element [%d]: got number, expecing [%c].\n", i, format_string[i]));
-				return_ACPI_STATUS(AE_BAD_DATA);
-				break;
-			}
-			break;
-
-		case ACPI_TYPE_STRING:
-		case ACPI_TYPE_BUFFER:
-			switch (format_string[i]) {
-			case 'S':
-				size_required += sizeof(char*) + (element->string.length * sizeof(char)) + sizeof(char);
-				tail_offset += sizeof(char*);
-				break;
-			case 'B':
-				size_required += sizeof(u8*) + (element->buffer.length * sizeof(u8));
-				tail_offset += sizeof(u8*);
-				break;
-			default:
-				ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid package element [%d] got string/buffer, expecing [%c].\n", i, format_string[i]));
-				return_ACPI_STATUS(AE_BAD_DATA);
-				break;
-			}
-			break;
-
-		case ACPI_TYPE_PACKAGE:
-		default:
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found unsupported element at index=%d\n", i));
-			/* TBD: handle nested packages... */
-			return_ACPI_STATUS(AE_SUPPORT);
-			break;
-		}
-	}
-
-	/* 
-	 * Validate output buffer. 
-	 */
-	if (buffer->length < size_required) {
-		buffer->length = size_required;
-		return_ACPI_STATUS(AE_BUFFER_OVERFLOW);
-	}
-	else if (buffer->length != size_required || !buffer->pointer) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	head = buffer->pointer;
-	tail = buffer->pointer + tail_offset;
-
-	/* 
-	 * Extract package data.
-	 */
-	for (i=0; i<format_count; i++) {
-
-		u8 **pointer = NULL;
-		acpi_object *element = &(package->package.elements[i]);
-
-		switch (element->type) {
-
-		case ACPI_TYPE_INTEGER:
-			switch (format_string[i]) {
-			case 'N':
-				*((acpi_integer*)head) = element->integer.value;
-				head += sizeof(acpi_integer);
-				break;
-			case 'S':
-				pointer = (u8**)head;
-				*pointer = tail;
-				*((acpi_integer*)tail) = element->integer.value;
-				head += sizeof(acpi_integer*);
-				tail += sizeof(acpi_integer);
-				/* NULL terminate string */
-				*tail = (char)0;
-				tail += sizeof(char);
-				break;
-			default:
-				/* Should never get here */
-				break;
-			}
-			break;
-
-		case ACPI_TYPE_STRING:
-		case ACPI_TYPE_BUFFER:
-			switch (format_string[i]) {
-			case 'S':
-				pointer = (u8**)head;
-				*pointer = tail;
-				memcpy(tail, element->string.pointer, element->string.length);
-				head += sizeof(char*);
-				tail += element->string.length * sizeof(char);
-				/* NULL terminate string */
-				*tail = (char)0;
-				tail += sizeof(char);
-				break;
-			case 'B':
-				pointer = (u8**)head;
-				*pointer = tail;
-				memcpy(tail, element->buffer.pointer, element->buffer.length);
-				head += sizeof(u8*);
-				tail += element->buffer.length * sizeof(u8);
-				break;
-			default:
-				/* Should never get here */
-				break;
-			}
-			break;
-
-		case ACPI_TYPE_PACKAGE:
-			/* TBD: handle nested packages... */
-		default:
-			/* Should never get here */
-			break;
-		}
-	}
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_evaluate_object
- *
- * PARAMETERS:
- *
- * RETURN:      AE_OK
- *              AE_BUFFER_OVERFLOW  Evaluated object returned data, but
- *                                  caller did not provide buffer.
- *
- * DESCRIPTION: Helper for acpi_evaluate_object that handles buffer
- *              allocation.  Note that the caller is responsible for
- *              freeing buffer->pointer!
- *
- ****************************************************************************/
-
-acpi_status
-bm_evaluate_object (
-	acpi_handle             handle,
-	acpi_string             pathname,
-	acpi_object_list        *arguments,
-	acpi_buffer             *buffer)
-{
-	acpi_status             status = AE_OK;
-
-	FUNCTION_TRACE("bm_evaluate_object");
-
-	/* If caller provided a buffer it must be unallocated/zero'd. */
-	if ((buffer) && (buffer->length != 0 || buffer->pointer)) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * Evalute Object:
-	 * ---------------
-	 * The first attempt is just to get the size of the object data
-	 * (that is unless there's no return data, e.g. _INI); the second
-	 * gets the data.
-	 */
-	status = acpi_evaluate_object(handle, pathname, arguments, buffer);
-	if (ACPI_SUCCESS(status)) {
-		return_ACPI_STATUS(status);
-	}
-	else if ((buffer) && (status == AE_BUFFER_OVERFLOW)) {
-
-		/* Gotta allocate -- CALLER MUST FREE! */
-		buffer->pointer = acpi_os_callocate(buffer->length);
-		if (!buffer->pointer) {
-			return_ACPI_STATUS(AE_NO_MEMORY);
-		}
-
-		/* Re-evaluate -- this time it should work */
-		status = acpi_evaluate_object(handle, pathname,
-			arguments, buffer);
-	}
-
-	if (ACPI_FAILURE(status)) {
-		if (status != AE_NOT_FOUND) {
-			DEBUG_EVAL_ERROR(ACPI_LV_WARN, handle, pathname,
-				status);
-		}
-		if (buffer && buffer->pointer) {
-			acpi_os_free(buffer->pointer);
-			buffer->pointer = NULL;
-			buffer->length = 0;
-		}
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_evaluate_simple_integer
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bm_evaluate_simple_integer (
-	acpi_handle             handle,
-	acpi_string             pathname,
-	u32                     *data)
-{
-	acpi_status             status = AE_OK;
-	acpi_object             *element = NULL;
-	acpi_buffer             buffer;
-
-	FUNCTION_TRACE("bm_evaluate_simple_integer");
-
-	if (!data) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	MEMSET(&buffer, 0, sizeof(acpi_buffer));
-
-	/*
-	 * Evaluate Object:
-	 * ----------------
-	 */
-	status = bm_evaluate_object(handle, pathname, NULL, &buffer);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "failed to evaluate object (%s)\n",
-			acpi_format_exception(status)));
-		goto end;
-	}
-
-	/*
-	 * Validate Data:
-	 * --------------
-	 */
-	status = bm_cast_buffer(&buffer, (void**)&element,
-		sizeof(acpi_object));
-	if (ACPI_FAILURE(status)) {
-		DEBUG_EVAL_ERROR(ACPI_LV_WARN, handle, pathname, status);
-		goto end;
-	}
-
-	if (element->type != ACPI_TYPE_INTEGER) {
-		status = AE_BAD_DATA;
-		DEBUG_EVAL_ERROR(ACPI_LV_WARN, handle, pathname, status);
-		goto end;
-	}
-
-	*data = element->integer.value;
-
-end:
-	acpi_os_free(buffer.pointer);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bm_evaluate_reference_list
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status  
-bm_evaluate_reference_list (
-	acpi_handle             handle,
-	acpi_string             pathname,
-	BM_HANDLE_LIST          *reference_list)
-{
-	acpi_status             status = AE_OK;
-	acpi_object             *package = NULL;
-	acpi_object             *element = NULL;
-	acpi_handle  		reference_handle = NULL;
-	acpi_buffer             buffer;
-	u32                     i = 0;
-
-	FUNCTION_TRACE("bm_evaluate_reference_list");
-
-	if (!reference_list) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	MEMSET(&buffer, 0, sizeof(acpi_buffer));
-
-	/*
-	 * Evaluate Object:
-	 * ----------------
-	 */
-	status = bm_evaluate_object(handle, pathname, NULL, &buffer);
-	if (ACPI_FAILURE(status)) {
-		goto end;
-	}
-
-	/*
-	 * Validate Package:
-	 * -----------------
-	 */
-	status = bm_cast_buffer(&buffer, (void**)&package,
-		sizeof(acpi_object));
-	if (ACPI_FAILURE(status)) {
-		DEBUG_EVAL_ERROR(ACPI_LV_WARN, handle, pathname, status);
-		goto end;
-	}
-
-	if (package->type != ACPI_TYPE_PACKAGE) {
-		status = AE_BAD_DATA;
-		DEBUG_EVAL_ERROR(ACPI_LV_WARN, handle, pathname, status);
-		goto end;
-	}
-
-	if (package->package.count > BM_HANDLES_MAX) {
-		package->package.count = BM_HANDLES_MAX;
-	}
-
-	/*
-	 * Parse Package Data:
-	 * -------------------
-	 */
-	for (i = 0; i < package->package.count; i++) {
-
-		element = &(package->package.elements[i]);
-
-		if (!element || (element->type != ACPI_TYPE_STRING)) {
-			status = AE_BAD_DATA;
-			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid element in package (not a device reference).\n"));
-			DEBUG_EVAL_ERROR (ACPI_LV_WARN, handle, pathname, status);
-			break;
-		}
-
-		/*
-		 * Resolve reference string (e.g. "\_PR_.CPU_") to an
-		 * acpi_handle.
-		 */
-		status = acpi_get_handle(handle,
-			element->string.pointer, &reference_handle);
-		if (ACPI_FAILURE(status)) {
-			status = AE_BAD_DATA;
-			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Unable to resolve device reference [%s].\n", element->string.pointer));
-			DEBUG_EVAL_ERROR (ACPI_LV_WARN, handle, pathname, status);
-			break;
-		}
-
-		/*
-		 * Resolve acpi_handle to BM_HANDLE.
-		 */
-		status = bm_get_handle(reference_handle,
-			&(reference_list->handles[i]));
-		if (ACPI_FAILURE(status)) {
-			status = AE_BAD_DATA;
-			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Unable to resolve device reference for [%p].\n", reference_handle));
-			DEBUG_EVAL_ERROR (ACPI_LV_WARN, handle, pathname, status);
-			break;
-		}
-
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resolved reference [%s]->[%p]->[%02x]\n", element->string.pointer, reference_handle, reference_list->handles[i]));
-
-		(reference_list->count)++;
-	}
-
-end:
-	acpi_os_free(buffer.pointer);
-
-	return_ACPI_STATUS(status);
-}
-
-
diff -urNp linux-5400/drivers/acpi/ospm/button/Makefile linux-5410/drivers/acpi/ospm/button/Makefile
--- linux-5400/drivers/acpi/ospm/button/Makefile
+++ linux-5410/drivers/acpi/ospm/button/Makefile
@@ -1,6 +0,0 @@
-O_TARGET	:= ospm_$(notdir $(CURDIR)).o
-obj-m		:= $(O_TARGET)
-EXTRA_CFLAGS	+= $(ACPI_CFLAGS)
-obj-y		:= $(patsubst %.c,%.o,$(wildcard *.c))
-
-include $(TOPDIR)/Rules.make
diff -urNp linux-5400/drivers/acpi/ospm/button/bn.c linux-5410/drivers/acpi/ospm/button/bn.c
--- linux-5400/drivers/acpi/ospm/button/bn.c
+++ linux-5410/drivers/acpi/ospm/button/bn.c
@@ -1,507 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: bn.c
- *   $Revision: 27 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Plxxe, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include <acpi.h>
-#include "bn.h"
-
-
-#define _COMPONENT		ACPI_BUTTON
-	MODULE_NAME		("bn")
-
-
-/*****************************************************************************
- *                            Internal Functions
- *****************************************************************************/
-
-/*****************************************************************************
- *
- * FUNCTION:	bn_print
- *
- * PARAMETERS:	
- *
- * RETURN:	
- *
- * DESCRIPTION: Prints out information on a specific button.
- *
- ****************************************************************************/
-
-void
-bn_print (
-	BN_CONTEXT		*button)
-{
-#ifdef ACPI_DEBUG
-	acpi_buffer		buffer;
-
-	PROC_NAME("bn_print");
-
-	if (!button) {
-		return;
-	}
-
-	buffer.length = 256;
-	buffer.pointer = acpi_os_callocate(buffer.length);
-	if (!buffer.pointer) {
-		return;
-	}
-
-	/*
-	 * Get the full pathname for this ACPI object.
-	 */
-	acpi_get_name(button->acpi_handle, ACPI_FULL_PATHNAME, &buffer);
-
-	/*
-	 * Print out basic button information.
-	 */
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "+------------------------------------------------------------\n"));
-
-	switch (button->type) {
-
-	case BN_TYPE_POWER_BUTTON:
-	case BN_TYPE_POWER_BUTTON_FIXED:
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "| Power_button[%02x]:[%p] %s\n", button->device_handle, button->acpi_handle, (char*)buffer.pointer));
-		break;
-
-	case BN_TYPE_SLEEP_BUTTON:
-	case BN_TYPE_SLEEP_BUTTON_FIXED:
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "| Sleep_button[%02x]:[%p] %s\n", button->device_handle, button->acpi_handle, (char*)buffer.pointer));
-		break;
-
-	case BN_TYPE_LID_SWITCH:
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "| Lid_switch[%02x]:[%p] %s\n", button->device_handle, button->acpi_handle, (char*)buffer.pointer));
-		break;
-	}
-
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "+------------------------------------------------------------\n"));
-
-	acpi_os_free(buffer.pointer);
-#endif /*ACPI_DEBUG*/
-
-	return;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	bn_add_device
- *
- * PARAMETERS:	
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bn_add_device(
-	BM_HANDLE		device_handle,
-	void			**context)
-{
-	acpi_status		status = AE_OK;
-	BM_DEVICE		*device = NULL;
-	BN_CONTEXT		*button = NULL;
-
-	FUNCTION_TRACE("bn_add_device");
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Adding button device [%02x].\n", device_handle));
-
-	if (!context || *context) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid context.\n"));
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * Get information on this device.
-	 */
-	status = bm_get_device_info( device_handle, &device );
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Allocate a new BN_CONTEXT structure.
-	 */
-	button = acpi_os_callocate(sizeof(BN_CONTEXT));
-	if (!button) {
-		return_ACPI_STATUS(AE_NO_MEMORY);
-	}
-
-	button->device_handle = device->handle;
-	button->acpi_handle = device->acpi_handle;
-
-	/*
-	 * Power Button?
-	 * -------------
-	 * Either fixed-feature or generic (namespace) types.
-	 */
-	if (strncmp(device->id.hid, BN_HID_POWER_BUTTON,
-		sizeof(BM_DEVICE_HID)) == 0) {
-
-		if (device->id.type == BM_TYPE_FIXED_BUTTON) {
-
-			button->type = BN_TYPE_POWER_BUTTON_FIXED;
-
-			/* Register for fixed-feature events. */
-			status = acpi_install_fixed_event_handler(
-				ACPI_EVENT_POWER_BUTTON, bn_notify_fixed,
-				(void*)button);
-		}
-		else {
-			button->type = BN_TYPE_POWER_BUTTON;
-		}
-
-	}
-
-	/*
-	 * Sleep Button?
-	 * -------------
-	 * Either fixed-feature or generic (namespace) types.
-	 */
-	else if (strncmp( device->id.hid, BN_HID_SLEEP_BUTTON,
-		sizeof(BM_DEVICE_HID)) == 0) {
-
-		if (device->id.type == BM_TYPE_FIXED_BUTTON) {
-
-			button->type = BN_TYPE_SLEEP_BUTTON_FIXED;
-
-			/* Register for fixed-feature events. */
-			status = acpi_install_fixed_event_handler(
-				ACPI_EVENT_SLEEP_BUTTON, bn_notify_fixed,
-				(void*)button);
-		}
-		else {
-			button->type = BN_TYPE_SLEEP_BUTTON;
-		}
-	}
-
-	/*
-	 * LID Switch?
-	 * -----------
-	 */
-	else if (strncmp( device->id.hid, BN_HID_LID_SWITCH,
-		sizeof(BM_DEVICE_HID)) == 0) {
-		button->type = BN_TYPE_LID_SWITCH;
-	}
-
-	status = bn_osl_add_device(button);
-	if (ACPI_FAILURE(status)) {
-		goto end;
-	}
-
-	*context = button;
-
-	bn_print(button);
-
-end:
-	if (ACPI_FAILURE(status)) {
-		acpi_os_free(button);
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	bn_remove_device
- *
- * PARAMETERS:	
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bn_remove_device(
-	void			**context)
-{
-	acpi_status		status = AE_OK;
-	BN_CONTEXT		*button = NULL;
-
-	FUNCTION_TRACE("bn_remove_device");
-
-	if (!context || !*context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	button = (BN_CONTEXT*)*context;
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Removing button device [%02x].\n", button->device_handle));
-
-	/*
-	 * Unregister for fixed-feature events.
-	 */
-	switch (button->type) {
-	case BN_TYPE_POWER_BUTTON_FIXED:
-		status = acpi_remove_fixed_event_handler(
-			ACPI_EVENT_POWER_BUTTON, bn_notify_fixed);
-		break;
-	case BN_TYPE_SLEEP_BUTTON_FIXED:
-		status = acpi_remove_fixed_event_handler(
-			ACPI_EVENT_SLEEP_BUTTON, bn_notify_fixed);
-		break;
-	}
-
-	bn_osl_remove_device(button);
-
-	acpi_os_free(button);
-
-	*context = NULL;
-
-	return_ACPI_STATUS(status);
-}
-
-
-/*****************************************************************************
- *			      External Functions
- *****************************************************************************/
-
-/*****************************************************************************
- *
- * FUNCTION:	bn_initialize
- *
- * PARAMETERS:	<none>
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
-
- ****************************************************************************/
-
-acpi_status
-bn_initialize (void)
-{
-	BM_DEVICE_ID		criteria;
-	BM_DRIVER		driver;
-
-	FUNCTION_TRACE("bn_initialize");
-
-	MEMSET(&criteria, 0, sizeof(BM_DEVICE_ID));
-	MEMSET(&driver, 0, sizeof(BM_DRIVER));
-
-	driver.notify = &bn_notify;
-	driver.request = &bn_request;
-
-	/*
-	 * Register for power buttons.
-	 */
-	MEMCPY(criteria.hid, BN_HID_POWER_BUTTON, sizeof(BN_HID_POWER_BUTTON));
-	bm_register_driver(&criteria, &driver);
-
-	/*
-	 * Register for sleep buttons.
-	 */
-	MEMCPY(criteria.hid, BN_HID_SLEEP_BUTTON, sizeof(BN_HID_SLEEP_BUTTON));
-	bm_register_driver(&criteria, &driver);
-
-	/*
-	 * Register for LID switches.
-	 */
-	MEMCPY(criteria.hid, BN_HID_LID_SWITCH, sizeof(BN_HID_LID_SWITCH));
-	bm_register_driver(&criteria, &driver);
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	bn_terminate
- *
- * PARAMETERS:	<none>
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bn_terminate (void)
-{
-	acpi_status		status = AE_OK;
-	BM_DEVICE_ID		criteria;
-	BM_DRIVER		driver;
-
-	FUNCTION_TRACE("bn_terminate");
-
-	MEMSET(&criteria, 0, sizeof(BM_DEVICE_ID));
-	MEMSET(&driver, 0, sizeof(BM_DRIVER));
-
-	driver.notify = &bn_notify;
-	driver.request = &bn_request;
-
-	/*
-	 * Unregister for power buttons.
-	 */
-	MEMCPY(criteria.hid, BN_HID_POWER_BUTTON, sizeof(BN_HID_POWER_BUTTON));
-	status = bm_unregister_driver(&criteria, &driver);
-
-	/*
-	 * Unregister for sleep buttons.
-	 */
-	MEMCPY(criteria.hid, BN_HID_SLEEP_BUTTON, sizeof(BN_HID_SLEEP_BUTTON));
-	status = bm_unregister_driver(&criteria, &driver);
-
-	/*
-	 * Unregister for LID switches.
-	 */
-	MEMCPY(criteria.hid, BN_HID_LID_SWITCH, sizeof(BN_HID_LID_SWITCH));
-	status = bm_unregister_driver(&criteria, &driver);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	bn_notify_fixed
- *
- * PARAMETERS:	<none>
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bn_notify_fixed (
-	void			*context)
-{
-	acpi_status		status = AE_OK;
-
-	FUNCTION_TRACE("bn_notify_fixed");
-
-	if (!context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Status change event detected.\n"));
-
-	status = bn_osl_generate_event(BN_NOTIFY_STATUS_CHANGE,
-		((BN_CONTEXT*)context));
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	bn_notify
- *
- * PARAMETERS:	<none>
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bn_notify (
-	BM_NOTIFY		notify_type,
-	BM_HANDLE		device_handle,
-	void			**context)
-{
-	acpi_status		status = AE_OK;
-
-	FUNCTION_TRACE("bn_notify");
-
-	if (!context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	switch (notify_type) {
-	case BM_NOTIFY_DEVICE_ADDED:
-		status = bn_add_device(device_handle, context);
-		break;
-		
-	case BM_NOTIFY_DEVICE_REMOVED:
-		status = bn_remove_device(context);
-		break;
-		
-	case BN_NOTIFY_STATUS_CHANGE:
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Status change event detected.\n"));
-		status = bn_osl_generate_event(BN_NOTIFY_STATUS_CHANGE,
-			((BN_CONTEXT*)*context));
-		break;
-
-	default:
-		status = AE_SUPPORT;
-		break;
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	bn_request
- *
- * PARAMETERS:	
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-bn_request (
-	BM_REQUEST		*request,
-	void			*context)
-{
-	acpi_status		status = AE_OK;
-
-	FUNCTION_TRACE("bn_request");
-
-	/*
-	 * Must have a valid request structure and context.
-	 */
-	if (!request || !context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * Handle Request:
-	 * ---------------
-	 */
-	switch (request->command) {
-
-	default:
-		status = AE_SUPPORT;
-		break;
-	}
-
-	request->status = status;
-
-	return_ACPI_STATUS(status);
-}
diff -urNp linux-5400/drivers/acpi/ospm/button/bn_osl.c linux-5410/drivers/acpi/ospm/button/bn_osl.c
--- linux-5400/drivers/acpi/ospm/button/bn_osl.c
+++ linux-5410/drivers/acpi/ospm/button/bn_osl.c
@@ -1,311 +0,0 @@
-/******************************************************************************
- *
- * Module Name: bn_osl.c
- *   $Revision: 16 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/proc_fs.h>
-#include <acpi.h>
-#include "bn.h"
-
-
-MODULE_AUTHOR("Andrew Grover");
-MODULE_DESCRIPTION("ACPI Component Architecture (CA) - Button Driver");
-MODULE_LICENSE("GPL");
-
-
-#define BN_PROC_ROOT		"button"
-#define BN_PROC_POWER_BUTTON	"power"
-#define BN_PROC_SLEEP_BUTTON	"sleep"
-#define BN_PROC_LID_SWITCH	"lid"
-
-extern struct proc_dir_entry	*bm_proc_root;
-static struct proc_dir_entry	*bn_proc_root = NULL;
-
-
-#define BN_TYPE_UNKNOWN		0
-#define BN_TYPE_FIXED		1
-#define BN_TYPE_GENERIC		2
-
-static int bn_power_button = BN_TYPE_UNKNOWN;
-static int bn_sleep_button = BN_TYPE_UNKNOWN;
-static int bn_lid_switch = BN_TYPE_UNKNOWN;
-
-
-/****************************************************************************
- *
- * FUNCTION:	bn_osl_add_device
- *
- ****************************************************************************/
-
-acpi_status
-bn_osl_add_device(
-	BN_CONTEXT		*button)
-{
-	acpi_status		status = AE_OK;
-
-	if (!button) {
-		return(AE_BAD_PARAMETER);
-	}
-
-	switch (button->type) {
-
-	case BN_TYPE_POWER_BUTTON_FIXED:
-		bn_power_button = BN_TYPE_FIXED;
-		printk(KERN_INFO "ACPI: Power Button (FF) found\n");
-		if (!proc_mkdir(BN_PROC_POWER_BUTTON, bn_proc_root)) {
-			status = AE_ERROR;
-		}
-		break;
-
-	case BN_TYPE_POWER_BUTTON:
-		/* 
-		 * Avoid creating multiple /proc entries when (buggy) ACPI
-		 * BIOS tables erroneously list both fixed- and generic-
-		 * feature buttons.  Note that fixed-feature buttons are 
-		 * always enumerated first (and there can only be one) so
-		 * we only need to check here.
-		 */
-		switch (bn_power_button) {
-		case BN_TYPE_GENERIC:
-			printk(KERN_WARNING "ACPI: Multiple generic-space power buttons detected, using first\n");
-			break;
-		case BN_TYPE_FIXED:
-			printk(KERN_WARNING "ACPI: Multiple power buttons detected, ignoring fixed-feature\n");
-		default:
-			printk(KERN_INFO "ACPI: Power Button (CM) found\n");
-			bn_power_button = BN_TYPE_GENERIC;
-			if (!proc_mkdir(BN_PROC_POWER_BUTTON, bn_proc_root)) {
-				status = AE_ERROR;
-			}
-			break;
-		}
-		break;
-
-	case BN_TYPE_SLEEP_BUTTON_FIXED:
-		bn_sleep_button = BN_TYPE_FIXED;
-		printk(KERN_INFO "ACPI: Sleep Button (FF) found\n");
-		if (!proc_mkdir(BN_PROC_SLEEP_BUTTON, bn_proc_root)) {
-			status = AE_ERROR;
-		}
-		break;
-
-	case BN_TYPE_SLEEP_BUTTON:
-		/* 
-		 * Avoid creating multiple /proc entries when (buggy) ACPI
-		 * BIOS tables erroneously list both fixed- and generic-
-		 * feature buttons.  Note that fixed-feature buttons are 
-		 * always enumerated first (and there can only be one) so
-		 * we only need to check here.
-		 */
-		switch (bn_sleep_button) {
-		case BN_TYPE_GENERIC:
-			printk(KERN_WARNING "ACPI: Multiple generic-space sleep buttons detected, using first\n");
-			break;
-		case BN_TYPE_FIXED:
-			printk(KERN_WARNING "ACPI: Multiple sleep buttons detected, ignoring fixed-feature\n");
-		default:
-			bn_sleep_button = BN_TYPE_GENERIC;
-			printk(KERN_INFO "ACPI: Sleep Button (CM) found\n");
-			if (!proc_mkdir(BN_PROC_SLEEP_BUTTON, bn_proc_root)) {
-				status = AE_ERROR;
-			}
-			break;
-		}
-		break;
-
-	case BN_TYPE_LID_SWITCH:
-		if (bn_lid_switch) {
-			printk(KERN_WARNING "ACPI: Multiple generic-space lid switches detected, using first\n");
-			break;
-		}
-		bn_lid_switch = BN_TYPE_GENERIC;
-		printk(KERN_INFO "ACPI: Lid Switch (CM) found\n");
-		if (!proc_mkdir(BN_PROC_LID_SWITCH, bn_proc_root)) {
-			status = AE_ERROR;
-		}
-		break;
-	}
-
-	return(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	bn_osl_remove_device
- *
- ****************************************************************************/
-
-acpi_status
-bn_osl_remove_device (
-	BN_CONTEXT		*button)
-{
-	if (!button) {
-		return(AE_BAD_PARAMETER);
-	}
-
-	switch (button->type) {
-
-	case BN_TYPE_POWER_BUTTON:
-	case BN_TYPE_POWER_BUTTON_FIXED:
-		remove_proc_entry(BN_PROC_POWER_BUTTON, bn_proc_root);
-		break;
-
-	case BN_TYPE_SLEEP_BUTTON:
-	case BN_TYPE_SLEEP_BUTTON_FIXED:
-		remove_proc_entry(BN_PROC_SLEEP_BUTTON, bn_proc_root);
-		break;
-
-	case BN_TYPE_LID_SWITCH:
-		remove_proc_entry(BN_PROC_LID_SWITCH, bn_proc_root);
-		break;
-	}
-
-	return(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	bn_osl_generate_event
- *
- ****************************************************************************/
-
-acpi_status
-bn_osl_generate_event (
-	u32			event,
-	BN_CONTEXT		*button)
-{
-	acpi_status		status = AE_OK;
-
-	if (!button) {
-		return(AE_BAD_PARAMETER);
-	}
-
-	switch (event) {
-
-	case BN_NOTIFY_STATUS_CHANGE:
-
-		switch(button->type) {
-
-		case BN_TYPE_POWER_BUTTON:
-		case BN_TYPE_POWER_BUTTON_FIXED:
-			status = bm_osl_generate_event(button->device_handle,
-				BN_PROC_ROOT, BN_PROC_POWER_BUTTON, event, 0);
-			break;
-
-		case BN_TYPE_SLEEP_BUTTON:
-		case BN_TYPE_SLEEP_BUTTON_FIXED:
-			status = bm_osl_generate_event(button->device_handle,
-				BN_PROC_ROOT, BN_PROC_SLEEP_BUTTON, event, 0);
-			break;
-
-		case BN_TYPE_LID_SWITCH:
-			status = bm_osl_generate_event(button->device_handle,
-				BN_PROC_ROOT, BN_PROC_LID_SWITCH, event, 0);
-			break;
-
-		default:
-			status = AE_SUPPORT;
-			break;
-		}
-
-		break;
-
-	default:
-		return(AE_BAD_PARAMETER);
-		break;
-	}
-
-	return(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bn_osl_init
- *
- * PARAMETERS:	<none>
- *
- * RETURN:	0: Success
- *
- * DESCRIPTION: Module initialization.
- *
- ****************************************************************************/
-
-static int __init
-bn_osl_init (void)
-{
-	acpi_status		status = AE_OK;
-
-	/* abort if no busmgr */
-	if (!bm_proc_root)
-		return -ENODEV;
-
-	bn_proc_root = proc_mkdir(BN_PROC_ROOT, bm_proc_root);
-	if (!bn_proc_root) {
-		status = AE_ERROR;
-	}
-	else {
-		status = bn_initialize();
-		if (ACPI_FAILURE(status)) {
-			remove_proc_entry(BN_PROC_ROOT, bm_proc_root);
-		}
-	}
-
-	return (ACPI_SUCCESS(status)) ? 0 : -ENODEV;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    bn_osl_cleanup
- *
- * PARAMETERS:	<none>
- *
- * RETURN:	<none>
- *
- * DESCRIPTION: Module cleanup.
- *
- ****************************************************************************/
-
-static void __exit
-bn_osl_cleanup (void)
-{
-	bn_terminate();
-
-	if (bn_proc_root) {
-		remove_proc_entry(BN_PROC_ROOT, bm_proc_root);
-	}
-
-	return;
-}
-
-
-module_init(bn_osl_init);
-module_exit(bn_osl_cleanup);
diff -urNp linux-5400/drivers/acpi/ospm/ec/Makefile linux-5410/drivers/acpi/ospm/ec/Makefile
--- linux-5400/drivers/acpi/ospm/ec/Makefile
+++ linux-5410/drivers/acpi/ospm/ec/Makefile
@@ -1,6 +0,0 @@
-O_TARGET	:= ospm_$(notdir $(CURDIR)).o
-obj-m		:= $(O_TARGET)
-EXTRA_CFLAGS	+= $(ACPI_CFLAGS)
-obj-y		:= $(patsubst %.c,%.o,$(wildcard *.c))
-
-include $(TOPDIR)/Rules.make
diff -urNp linux-5400/drivers/acpi/ospm/ec/ec_osl.c linux-5410/drivers/acpi/ospm/ec/ec_osl.c
--- linux-5400/drivers/acpi/ospm/ec/ec_osl.c
+++ linux-5410/drivers/acpi/ospm/ec/ec_osl.c
@@ -1,91 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: ec_osl.c
- *   $Revision: 11 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/proc_fs.h>
-#include <acpi.h>
-#include <bm.h>
-#include "ec.h"
-
-
-MODULE_AUTHOR("Andrew Grover");
-MODULE_DESCRIPTION("ACPI Component Architecture (CA) - Embedded Controller Driver");
-MODULE_LICENSE("GPL");
-
-extern struct proc_dir_entry	*bm_proc_root;
-
-
-/****************************************************************************
- *
- * FUNCTION:    ec_osl_init
- *
- * PARAMETERS:	<none>
- *
- * RETURN:	0: Success
- *
- * DESCRIPTION: Module initialization.
- *
- ****************************************************************************/
-
-static int __init
-ec_osl_init (void)
-{
-	acpi_status		status = AE_OK;
-
-	/* abort if no busmgr */
-	if (!bm_proc_root)
-		return -ENODEV;
-
-	status = ec_initialize();
-
-	return (ACPI_SUCCESS(status)) ? 0 : -ENODEV;
-}
-
-/****************************************************************************
- *
- * FUNCTION:    ec_osl_cleanup
- *
- * PARAMETERS:	<none>
- *
- * RETURN:	<none>
- *
- * DESCRIPTION: Module cleanup.
- *
- ****************************************************************************/
-
-static void __exit
-ec_osl_cleanup(void)
-{
-	ec_terminate();
-
-	return;
-}
-
-module_init(ec_osl_init);
-module_exit(ec_osl_cleanup);
diff -urNp linux-5400/drivers/acpi/ospm/ec/ecgpe.c linux-5410/drivers/acpi/ospm/ec/ecgpe.c
--- linux-5400/drivers/acpi/ospm/ec/ecgpe.c
+++ linux-5410/drivers/acpi/ospm/ec/ecgpe.c
@@ -1,249 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: ecgpe.c
- *   $Revision: 28 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include <acpi.h>
-#include "ec.h"
-
-#define _COMPONENT		ACPI_EC
-	MODULE_NAME		("ecgpe")
-
-
-/****************************************************************************
- *
- * FUNCTION:    ec_query_handler
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-void
-ec_query_handler (
-	void                    *context)
-{
-	EC_CONTEXT		*ec = (EC_CONTEXT*)context;
-	static char		object_name[5] = {'_','Q','0','0','\0'};
-	const char		hex[] = {'0','1','2','3','4','5','6','7','8',
-					'9','A','B','C','D','E','F'};
-
-	FUNCTION_TRACE("ec_query_handler");
-
-	if (!ec) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid (NULL) context.\n"));
-		return_VOID;
-	}
-
-	/*
-	 * Evaluate _Qxx:
-	 * --------------
-	 * Evaluate corresponding _Qxx method.  Note that a zero query value
-	 * indicates a spurious EC_SCI (no such thing as _Q00).
-	 */
-	object_name[2] = hex[((ec->query_data >> 4) & 0x0F)];
-	object_name[3] = hex[(ec->query_data & 0x0F)];
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Evaluating [%s] for ec [%02x].\n", object_name, ec->device_handle));
-
-	bm_evaluate_object(ec->acpi_handle, object_name, NULL, NULL);
-
-	return_VOID;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    ec_gpe_handler
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-void
-ec_gpe_handler (
-	void                    *context)
-{
-	acpi_status             status = AE_OK;
-	EC_CONTEXT              *ec = (EC_CONTEXT*)context;
-	EC_STATUS               ec_status = 0;
-
-	FUNCTION_TRACE("ec_gpe_handler");
-
-	if (!ec) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid (NULL) context.\n"));
-		return_VOID;
-	}
-
-	/* TBD: synchronize w/ transaction (ectransx). */
-
-	/*
-	 * EC_SCI?
-	 * -------
-	 * Check the EC_SCI bit to see if this is an EC_SCI event.  If not (e.g.
-	 * OBF/IBE) just return, as we already poll to detect these events.
-	 */
-	acpi_os_read_port(ec->status_port, &ec_status, 8);
-	if (!(ec_status & EC_FLAG_SCI)) {
-		return_VOID;
-	}
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "EC_SCI event detected on ec [%02x] - running query.\n", ec->device_handle));
-
-	/*
-	 * Run Query:
-	 * ----------
-	 * Query the EC to find out which _Qxx method we need to evaluate.
-	 * Note that successful completion of the query causes the EC_SCI
-	 * bit to be cleared (and thus clearing the interrupt source).
-	 */
-	status = ec_io_write(ec, ec->command_port, EC_COMMAND_QUERY,
-		EC_EVENT_OUTPUT_BUFFER_FULL);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Unable to send 'query command' to EC.\n"));
-		return_VOID;
-	}
-
-	status = ec_io_read(ec, ec->data_port, &(ec->query_data),
-		EC_EVENT_NONE);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Error reading query data.\n"));
-		return_VOID;
-	}
-
-	/* TBD: un-synchronize w/ transaction (ectransx). */
-
-	/*
-	 * Spurious EC_SCI?
-	 * ----------------
-	 */
-	if (!ec->query_data) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Spurious EC SCI detected.\n"));
-		return_VOID;
-	}
-
-	/*
-	 * Defer _Qxx Execution:
-	 * ---------------------
-	 * Can't evaluate this method now 'cause we're at interrupt-level.
-	 */
-	status = acpi_os_queue_for_execution(OSD_PRIORITY_GPE,
-		ec_query_handler, ec);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Unable to defer _Qxx method evaluation.\n"));
-		return_VOID;
-	}
-
-	return_VOID;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    ec_install_gpe_handler
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-ec_install_gpe_handler (
-	EC_CONTEXT              *ec)
-{
-	acpi_status             status = AE_OK;
-
-	FUNCTION_TRACE("ec_install_gpe_handler");
-
-	if (!ec) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * Evaluate _GPE:
-	 * --------------
-	 * Evaluate the "_GPE" object (required) to find out which GPE bit
-	 * is used by this EC to signal events (SCIs).
-	 */
-	status = bm_evaluate_simple_integer(ec->acpi_handle,
-		"_GPE", &(ec->gpe_bit));
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Install GPE Handler:
-	 * --------------------
-	 * Install a handler for this EC's GPE bit.
-	 */
-	status = acpi_install_gpe_handler(ec->gpe_bit, ACPI_EVENT_EDGE_TRIGGERED,
-		&ec_gpe_handler, ec);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "acpi_install_gpe_handler() failed for GPE bit [%02x] with status [%08x].\n", ec->gpe_bit, status));
-		ec->gpe_bit = EC_GPE_UNKNOWN;
-		return_ACPI_STATUS(status);
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    ec_remove_gpe_handler
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-ec_remove_gpe_handler (
-	EC_CONTEXT              *ec)
-{
-	acpi_status             status = AE_OK;
-
-	FUNCTION_TRACE("ec_remove_gpe_handler");
-
-	if (!ec) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	status = acpi_remove_gpe_handler(ec->gpe_bit, &ec_gpe_handler);
-
-	return_ACPI_STATUS(status);
-}
diff -urNp linux-5400/drivers/acpi/ospm/ec/ecmain.c linux-5410/drivers/acpi/ospm/ec/ecmain.c
--- linux-5400/drivers/acpi/ospm/ec/ecmain.c
+++ linux-5410/drivers/acpi/ospm/ec/ecmain.c
@@ -1,498 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: ecmain.c
- *   $Revision: 29 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include <acpi.h>
-#include "ec.h"
-
-#define _COMPONENT		ACPI_EC
-	MODULE_NAME		("ecmain")
-
-
-/****************************************************************************
- *                            Internal Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:    ec_print
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION: Prints out information on a specific ec.
- *
- ****************************************************************************/
-
-void
-ec_print (
-	EC_CONTEXT              *ec)
-{
-#ifdef ACPI_DEBUG
-	acpi_buffer             buffer;
-#endif /*ACPI_DEBUG*/
-
-	PROC_NAME("ec_print");
-
-	if (!ec) {
-		return;
-	}
-
-	acpi_os_printf("EC: found, GPE %d\n", ec->gpe_bit);
-
-#ifdef ACPI_DEBUG
-	buffer.length = 256;
-	buffer.pointer = acpi_os_callocate(buffer.length);
-	if (!buffer.pointer) {
-		return;
-	}
-
-	/*
-	 * Get the full pathname for this ACPI object.
-	 */
-	acpi_get_name(ec->acpi_handle, ACPI_FULL_PATHNAME, &buffer);
-
-	/*
-	 * Print out basic thermal zone information.
-	 */
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "+------------------------------------------------------------\n"));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "| Embedded_controller[%02x]:[%p] %s\n", ec->device_handle, ec->acpi_handle, (char*)buffer.pointer));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "|   gpe_bit[%02x] status/command_port[%02x] data_port[%02x]\n", ec->gpe_bit, ec->status_port, ec->data_port));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "+------------------------------------------------------------\n"));
-
-	acpi_os_free(buffer.pointer);
-#endif /*ACPI_DEBUG*/
-
-	return;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    ec_get_port_values
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION: Evaluate _CRS to get the current resources (I/O port
- *              addresses) for this EC.
- *
- ****************************************************************************/
-
-acpi_status
-ec_get_port_values(
-	EC_CONTEXT              *ec)
-{
-	acpi_status             status = AE_OK;
-	acpi_buffer             buffer;
-	acpi_resource           *resource = NULL;
-
-	FUNCTION_TRACE("ec_get_port_values");
-
-	if (!ec) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	buffer.length = 0;
-	buffer.pointer = NULL;
-
-	status = acpi_get_current_resources(ec->acpi_handle, &buffer);
-	if (status != AE_BUFFER_OVERFLOW) {
-		return_ACPI_STATUS(status);
-	}
-
-	buffer.pointer = acpi_os_callocate(buffer.length);
-	if (!buffer.pointer) {
-		return_ACPI_STATUS(AE_NO_MEMORY);
-	}
-
-	status = acpi_get_current_resources(ec->acpi_handle, &buffer);
-	if (ACPI_FAILURE(status)) {
-		goto end;
-	}
-
-	resource = (acpi_resource *) buffer.pointer;
-	ec->data_port = resource->data.io.min_base_address;
-
-	resource = NEXT_RESOURCE(resource);
-
-	ec->status_port = ec->command_port =
-		resource->data.io.min_base_address;
-end:
-	acpi_os_free(buffer.pointer);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    ec_add_device
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-ec_add_device(
-	BM_HANDLE               device_handle,
-	void                    **context)
-{
-	acpi_status             status = AE_OK;
-	BM_DEVICE		*device = NULL;
-	EC_CONTEXT              *ec = NULL;
-	u8                      gpe_handler = FALSE;
-	u8                      space_handler = FALSE;
-
-	FUNCTION_TRACE("ec_add_device");
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Adding EC device [%02x].\n", device_handle));
-
-	if (!context || *context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * Get information on this device.
-	 */
-	status = bm_get_device_info(device_handle, &device);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Allocate a new EC_CONTEXT structure.
-	 */
-	ec = acpi_os_callocate(sizeof(EC_CONTEXT));
-	if (!ec) {
-		return_ACPI_STATUS(AE_NO_MEMORY);
-	}
-
-	ec->device_handle = device->handle;
-	ec->acpi_handle = device->acpi_handle;
-
-	/*
-	 * Get the I/O port addresses for the command/status and data ports.
-	 */
-	status = ec_get_port_values(ec);
-	if (ACPI_FAILURE(status)) {
-		goto end;
-	}
-
-	/*
-	 * See if we need to obtain the global lock for EC transactions.
-	 */
-	status = bm_evaluate_simple_integer(ec->acpi_handle, "_GLK",
-		&ec->use_global_lock);
-	if (status == AE_NOT_FOUND) {
-		ec->use_global_lock = 0;
-	}
-	else if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "EC _GLK failed\n"));
-		goto end;
-	}
-
-	/*
-	 * Install a handler for servicing this EC's GPE.
-	 */
-	status = ec_install_gpe_handler(ec);
-	if (ACPI_FAILURE(status)) {
-		goto end;
-	}
-	else {
-		gpe_handler = TRUE;
-	}
-
-	/*
-	 * Install a handler for servicing this EC's address space.
-	 */
-	status = ec_install_space_handler(ec);
-	if (ACPI_FAILURE(status)) {
-		goto end;
-	}
-	else {
-		space_handler = TRUE;
-	}
-
-	/*
-	 * Create a semaphore to serialize EC transactions.
-	 */
-	status = acpi_os_create_semaphore(1,1, &(ec->mutex));
-	if (ACPI_FAILURE(status)) {
-		goto end;
-	}
-
-	/*
-	 * Context now contains information specific to this EC.  Note
-	 * that we'll get this pointer back on every ec_request() and
-	 * ec_notify().
-	 */
-	*context = ec;
-
-	ec_print(ec);
-
-end:
-	if (ACPI_FAILURE(status)) {
-
-		if (gpe_handler) {
-			ec_remove_gpe_handler(ec);
-		}
-
-		if (space_handler) {
-			ec_remove_space_handler(ec);
-		}
-
-		if (ec->mutex) {
-			acpi_os_delete_semaphore(ec->mutex);
-		}
-
-		acpi_os_free(ec);
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    ec_remove_device
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-ec_remove_device(
-	void                    **context)
-{
-	acpi_status             status = AE_OK;
-	EC_CONTEXT              *ec = NULL;
-
-	FUNCTION_TRACE("ec_remove_device");
-
-	if (!context || !*context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	ec = (EC_CONTEXT*)*context;
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Removing EC device [%02x].\n", ec->device_handle));
-
-	ec_remove_space_handler(ec);
-
-	ec_remove_gpe_handler(ec);
-
-	if (ec->mutex) {
-		acpi_os_delete_semaphore(ec->mutex);
-	}
-
-	acpi_os_free(ec);
-
-	*context = NULL;
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *                             External Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:    ec_initialize
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-ec_initialize (void)
-{
-	acpi_status             status = AE_OK;
-	BM_DEVICE_ID		criteria;
-	BM_DRIVER		driver;
-
-	FUNCTION_TRACE("ec_initialize");
-
-	MEMSET(&criteria, 0, sizeof(BM_DEVICE_ID));
-	MEMSET(&driver, 0, sizeof(BM_DRIVER));
-
-	/*
-	 * Register driver for AC Adapter devices.
-	 */
-	MEMCPY(criteria.hid, EC_HID_EC, sizeof(EC_HID_EC));
-
-	driver.notify = &ec_notify;
-	driver.request = &ec_request;
-
-	status = bm_register_driver(&criteria, &driver);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    ec_terminate
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-ec_terminate(void)
-{
-	acpi_status             status = AE_OK;
-	BM_DEVICE_ID		criteria;
-	BM_DRIVER		driver;
-
-	FUNCTION_TRACE("ec_terminate");
-
-	MEMSET(&criteria, 0, sizeof(BM_DEVICE_ID));
-	MEMSET(&driver, 0, sizeof(BM_DRIVER));
-
-	/*
-	 * Unregister driver for AC Adapter devices.
-	 */
-	MEMCPY(criteria.hid, EC_HID_EC, sizeof(EC_HID_EC));
-
-	driver.notify = &ec_notify;
-	driver.request = &ec_request;
-
-	status = bm_unregister_driver(&criteria, &driver);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    ec_notify
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-ec_notify (
-	BM_NOTIFY               notify,
-	BM_HANDLE               device_handle,
-	void                    **context)
-{
-	acpi_status             status = AE_OK;
-
-	FUNCTION_TRACE("ec_notify");
-
-	switch (notify) {
-
-	case BM_NOTIFY_DEVICE_ADDED:
-		status = ec_add_device(device_handle, context);
-		break;
-
-	case BM_NOTIFY_DEVICE_REMOVED:
-		status = ec_remove_device(context);
-		break;
-
-	default:
-		status = AE_SUPPORT;
-		break;
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    ec_request
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-ec_request (
-	BM_REQUEST              *request,
-	void                    *context)
-{
-	acpi_status             status = AE_OK;
-	EC_REQUEST              *ec_request = NULL;
-	EC_CONTEXT              *ec = NULL;
-
-	FUNCTION_TRACE("ec_request");
-
-	/*
-	 * Must have a valid request structure and context.
-	 */
-	if (!request || !context)
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-
-	/*
-	 * buffer must contain a valid EC_REQUEST structure.
-	 */
-	status = bm_cast_buffer(&(request->buffer), (void**)&ec_request,
-		sizeof(EC_REQUEST));
-	if (ACPI_FAILURE(status))
-		return_ACPI_STATUS(status);
-
-	/*
-	 * context contains information specific to this EC.
-	 */
-	ec = (EC_CONTEXT*)context;
-
-	/*
-	 * Perform the Transaction.
-	 */
-	status = ec_transaction(ec, ec_request);
-
-	return_ACPI_STATUS(status);
-}
diff -urNp linux-5400/drivers/acpi/ospm/ec/ecspace.c linux-5410/drivers/acpi/ospm/ec/ecspace.c
--- linux-5400/drivers/acpi/ospm/ec/ecspace.c
+++ linux-5410/drivers/acpi/ospm/ec/ecspace.c
@@ -1,192 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: ecspace.c
- *   $Revision: 23 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include <acpi.h>
-#include "ec.h"
-
-#define _COMPONENT		ACPI_EC
-	MODULE_NAME		("ecspace")
-
-
-/****************************************************************************
- *
- * FUNCTION:    ec_space_setup
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-ec_space_setup (
-	acpi_handle		region_handle,
-	u32			function,
-	void			*handler_context,
-	void			**return_context)
-{
-	/*
-	 * The EC object is in the handler context and is needed
-	 * when calling the ec_space_handler.
-	 */
-	*return_context = handler_context;
-
-	return AE_OK;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    ec_space_handler
- *
- * PARAMETERS:  function            - Read or Write operation
- *              address             - Where in the space to read or write
- *              bit_width           - Field width in bits (should be 8)
- *              value               - Pointer to in or out value
- *              context             - context pointer
- *
- * RETURN:
- *
- * DESCRIPTION: Handler for the Embedded Controller (EC) address space
- *              (Op Region)
- *
- ****************************************************************************/
-
-acpi_status
-ec_space_handler (
-	u32                     function,
-	ACPI_PHYSICAL_ADDRESS   address,
-	u32                     bit_width,
-	u32                     *value,
-	void                    *handler_context,
-	void                    *region_context)
-{
-	acpi_status             status = AE_OK;
-	EC_CONTEXT              *ec = NULL;
-	EC_REQUEST              ec_request;
-
-	FUNCTION_TRACE("ec_space_handler");
-
-	if (address > 0xFF || bit_width != 8 || !value || !handler_context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	ec = (EC_CONTEXT*)handler_context;
-
-	switch (function) {
-
-	case ACPI_READ_ADR_SPACE:
-		ec_request.command = EC_COMMAND_READ;
-		ec_request.address = address;
-		ec_request.data = 0;
-		break;
-
-	case ACPI_WRITE_ADR_SPACE:
-		ec_request.command = EC_COMMAND_WRITE;
-		ec_request.address = address;
-		ec_request.data = (u8)(*value);
-		break;
-
-	default:
-		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Received request with invalid function [%X].\n", function));
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-		break;
-	}
-
-	/*
-	 * Perform the Transaction.
-	 */
-	status = ec_transaction(ec, &ec_request);
-	if (ACPI_SUCCESS(status)) {
-		(*value) = (u32)ec_request.data;
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    ec_install_space_handler
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-ec_install_space_handler (
-	EC_CONTEXT              *ec)
-{
-	acpi_status             status = AE_OK;
-
-	FUNCTION_TRACE("ec_install_space_handler");
-
-	if (!ec) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	status = acpi_install_address_space_handler (ec->acpi_handle,
-		ACPI_ADR_SPACE_EC, &ec_space_handler, &ec_space_setup, ec);
-	
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    ec_remove_space_handler
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-ec_remove_space_handler (
-	EC_CONTEXT              *ec)
-{
-	acpi_status             status = AE_OK;
-
-	FUNCTION_TRACE("ec_remove_space_handler");
-
-	if (!ec) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	status = acpi_remove_address_space_handler(ec->acpi_handle,
-		ACPI_ADR_SPACE_EC, &ec_space_handler);
-
-	return_ACPI_STATUS(status);
-}
diff -urNp linux-5400/drivers/acpi/ospm/ec/ectransx.c linux-5410/drivers/acpi/ospm/ec/ectransx.c
--- linux-5400/drivers/acpi/ospm/ec/ectransx.c
+++ linux-5410/drivers/acpi/ospm/ec/ectransx.c
@@ -1,343 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: ectransx.c
- *   $Revision: 24 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include <acpi.h>
-#include "ec.h"
-
-#define _COMPONENT		ACPI_EC
-	MODULE_NAME             ("ectransx")
-
-
-/****************************************************************************
- *
- * FUNCTION:    ec_io_wait
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-ec_io_wait (
-	EC_CONTEXT              *ec,
-	EC_EVENT                wait_event)
-{
-	EC_STATUS               ec_status = 0;
-	u32                     i = 100;
-
-	if (!ec || ((wait_event != EC_EVENT_OUTPUT_BUFFER_FULL)
-		&& (wait_event != EC_EVENT_INPUT_BUFFER_EMPTY))) {
-		return(AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * Wait for Event:
-	 * ---------------
-	 * Poll the EC status register waiting for the event to occur.
-	 * Note that we'll wait a maximum of 1ms in 10us chunks.
-	 */
-	switch (wait_event) {
-
-	case EC_EVENT_OUTPUT_BUFFER_FULL:
-		do {
-			acpi_os_read_port(ec->status_port, &ec_status, 8);
-			if (ec_status & EC_FLAG_OUTPUT_BUFFER) {
-				return(AE_OK);
-			}
-			acpi_os_stall(10);
-		} while (--i>0);
-		break;
-
-	case EC_EVENT_INPUT_BUFFER_EMPTY:
-		do {
-			acpi_os_read_port(ec->status_port, &ec_status, 8);
-			if (!(ec_status & EC_FLAG_INPUT_BUFFER)) {
-				return(AE_OK);
-			}
-			acpi_os_stall(10);
-		} while (--i>0);
-		break;
-	}
-
-	return(AE_TIME);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    ec_io_read
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-ec_io_read (
-	EC_CONTEXT              *ec,
-	u32		        io_port,
-	u8                      *data,
-	EC_EVENT                wait_event)
-{
-	acpi_status             status = AE_OK;
-
-	if (!ec || !data) {
-		return(AE_BAD_PARAMETER);
-	}
-
-	acpi_os_read_port(io_port, (u32*) data, 8);
-
-	if (wait_event) {
-		status = ec_io_wait(ec, wait_event);
-	}
-
-	return(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    ec_io_write
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-ec_io_write (
-	EC_CONTEXT              *ec,
-	u32		       io_port,
-	u8                      data,
-	EC_EVENT                wait_event)
-{
-	acpi_status             status = AE_OK;
-
-	if (!ec) {
-		return(AE_BAD_PARAMETER);
-	}
-
-	acpi_os_write_port(io_port, data, 8);
-
-	if (wait_event) {
-		status = ec_io_wait(ec, wait_event);
-	}
-
-	return(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    ec_read
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-ec_read (
-	EC_CONTEXT              *ec,
-	u8                      address,
-	u8                      *data)
-{
-	acpi_status             status = AE_OK;
-
-	FUNCTION_TRACE("ec_read");
-
-	if (!ec || !data) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	if (ec->use_global_lock) {
-		status = acpi_acquire_global_lock();
-		if (ACPI_FAILURE(status)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Could not acquire Global Lock\n"));
-			return_ACPI_STATUS(status);
-		}
-	}
-
-	status = ec_io_write(ec, ec->command_port, EC_COMMAND_READ,
-		EC_EVENT_INPUT_BUFFER_EMPTY);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Unable to send 'read command' to EC.\n"));
-		return_ACPI_STATUS(status);
-	}
-
-	status = ec_io_write(ec, ec->data_port, address,
-		EC_EVENT_OUTPUT_BUFFER_FULL);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Unable to send 'read address' to EC.\n"));
-		return_ACPI_STATUS(status);
-	}
-
-	status = ec_io_read(ec, ec->data_port, data, EC_EVENT_NONE);
-
-	if (ec->use_global_lock) {
-		acpi_release_global_lock();
-	}
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Read data [%02x] from address [%02x] on ec [%02x].\n", (*data), address, ec->device_handle));
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    ec_write
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-ec_write (
-	EC_CONTEXT              *ec,
-	u8                      address,
-	u8                      data)
-{
-	acpi_status             status = AE_OK;
-
-	FUNCTION_TRACE("ec_write");
-
-	if (!ec)
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-
-	if (ec->use_global_lock) {
-		status = acpi_acquire_global_lock();
-		if (ACPI_FAILURE(status)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Could not acquire Global Lock\n"));
-			return_ACPI_STATUS(status);
-		}
-	}
-
-	status = ec_io_write(ec, ec->command_port, EC_COMMAND_WRITE,
-		EC_EVENT_INPUT_BUFFER_EMPTY);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Unable to send 'write command' to EC.\n"));
-		return_ACPI_STATUS(status);
-	}
-
-	status = ec_io_write(ec, ec->data_port, address,
-		EC_EVENT_INPUT_BUFFER_EMPTY);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Unable to send 'write address' to EC.\n"));
-		return_ACPI_STATUS(status);
-	}
-
-	status = ec_io_write(ec, ec->data_port, data,
-		EC_EVENT_INPUT_BUFFER_EMPTY);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Unable to send 'write data' to EC.\n"));
-		return_ACPI_STATUS(status);
-	}
-
-	if (ec->use_global_lock) {
-		acpi_release_global_lock();
-	}
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Wrote data [%02x] to address [%02x] on ec [%02x].\n", data, address, ec->device_handle));
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    ec_transaction
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-ec_transaction (
-	EC_CONTEXT              *ec,
-	EC_REQUEST              *request)
-{
-	acpi_status             status = AE_OK;
-
-	FUNCTION_TRACE("ec_transaction");
-
-	if (!ec || !request) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * Obtain mutex to serialize all EC transactions.
-	 */
-	status = acpi_os_wait_semaphore(ec->mutex, 1, EC_DEFAULT_TIMEOUT);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Perform the transaction.
-	 */
-	switch (request->command) {
-
-	case EC_COMMAND_READ:
-		status = ec_read(ec, request->address, &(request->data));
-		break;
-
-	case EC_COMMAND_WRITE:
-		status = ec_write(ec, request->address, request->data);
-		break;
-
-	default:
-		status = AE_SUPPORT;
-		break;
-	}
-
-	/*
-	 * Signal the mutex to indicate transaction completion.
-	 */
-	acpi_os_signal_semaphore(ec->mutex, 1);
-
-	return_ACPI_STATUS(status);
-}
diff -urNp linux-5400/drivers/acpi/ospm/include/ac.h linux-5410/drivers/acpi/ospm/include/ac.h
--- linux-5400/drivers/acpi/ospm/include/ac.h
+++ linux-5410/drivers/acpi/ospm/include/ac.h
@@ -1,102 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: ac.h
- *   $Revision: 6 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#ifndef __AC_H__
-#define __AC_H__
-
-#include <actypes.h>
-#include <acexcep.h>
-#include <bm.h>
-
-
-/*****************************************************************************
- *                            Types & Other Defines
- *****************************************************************************/
-
-/*
- * Notifications:
- * --------------
- */
-#define AC_NOTIFY_STATUS_CHANGE	((BM_NOTIFY) 0x80)
-
-/*
- * Hardware IDs:
- * -------------
- */
-#define AC_HID_AC_ADAPTER	"ACPI0003"
-
-
-/*
- * Device Context:
- * ---------------
- */
-typedef struct
-{
-	BM_HANDLE		device_handle;
-	acpi_handle		acpi_handle;
-	char			uid[9];
-	u32 			is_online;
-} AC_CONTEXT;
-
-
-/*****************************************************************************
- *                              Function Prototypes
- *****************************************************************************/
-
-acpi_status
-ac_initialize (void);
-
-acpi_status
-ac_terminate (void);
-
-acpi_status
-ac_notify (
-	u32			notify_type,
-	u32 			device,
-	void			**context);
-
-acpi_status
-ac_request(
-	BM_REQUEST		*request_info,
-	void			*context);
-
-/* AC Adapter Driver OSL */
-
-acpi_status
-ac_osl_add_device (
-	AC_CONTEXT		*ac_adapter);
-
-acpi_status
-ac_osl_remove_device (
-	AC_CONTEXT		*ac_adapter);
-
-acpi_status
-ac_osl_generate_event (
-	u32			event,
-	AC_CONTEXT		*ac_adapter);
-
-
-#endif	/* __AC_H__ */
diff -urNp linux-5400/drivers/acpi/ospm/include/bm.h linux-5410/drivers/acpi/ospm/include/bm.h
--- linux-5400/drivers/acpi/ospm/include/bm.h
+++ linux-5410/drivers/acpi/ospm/include/bm.h
@@ -1,583 +0,0 @@
-/*****************************************************************************
- *
- * Module name: bm.h
- *   $Revision: 41 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __BM_H__
-#define __BM_H__
-
-#include <actypes.h>
-#include <acexcep.h>
-
-
-/*****************************************************************************
- *                               Types & Defines
- *****************************************************************************/
-
-/*
- * Output Flags (Debug):
- * ---------------------
- */
-#define BM_PRINT_ALL		(0x00000000)
-#define BM_PRINT_GROUP		(0x00000001)
-#define BM_PRINT_LINKAGE	(0x00000002)
-#define BM_PRINT_IDENTIFICATION	(0x00000004)
-#define BM_PRINT_POWER		(0x00000008)
-#define BM_PRINT_PRESENT	(0x00000010)
-
-
-/*
- * BM_COMMAND:
- * -----------
- */
-typedef u32			BM_COMMAND;
-
-#define BM_COMMAND_UNKNOWN	((BM_COMMAND) 0x00)
-
-#define BM_COMMAND_GET_POWER_STATE ((BM_COMMAND) 0x01)
-#define BM_COMMAND_SET_POWER_STATE ((BM_COMMAND) 0x02)
-
-#define BM_COMMAND_DEVICE_SPECIFIC ((BM_COMMAND) 0x80)
-
-/*
- * BM_NOTIFY:
- * ----------
- * Standard ACPI notification values, from section 5.6.3 of the ACPI 2.0
- * specification.  Note that the Bus Manager internally handles all
- * standard ACPI notifications -- driver modules are never sent these
- * values (see "Bus Manager Notifications", below).
- */
-typedef u32			BM_NOTIFY;
-
-#define BM_NOTIFY_BUS_CHECK	((BM_NOTIFY) 0x00)
-#define BM_NOTIFY_DEVICE_CHECK	((BM_NOTIFY) 0x01)
-#define BM_NOTIFY_DEVICE_WAKE	((BM_NOTIFY) 0x02)
-#define BM_NOTIFY_EJECT_REQUEST	((BM_NOTIFY) 0x03)
-#define BM_NOTIFY_DEVICE_CHECK_LIGHT ((BM_NOTIFY) 0x04)
-#define BM_NOTIFY_FREQUENCY_MISMATCH ((BM_NOTIFY) 0x05)
-#define BM_NOTIFY_BUS_MODE_MISMATCH ((BM_NOTIFY) 0x06)
-#define BM_NOTIFY_POWER_FAULT	((BM_NOTIFY) 0x07)
-
-/*
- * These are a higher-level abstraction of ACPI notifications, intended
- * for consumption by driver modules to facilitate Pn_p.
- */
-#define BM_NOTIFY_UNKNOWN	((BM_NOTIFY) 0x00)
-#define BM_NOTIFY_DEVICE_ADDED	((BM_NOTIFY) 0x01)
-#define BM_NOTIFY_DEVICE_REMOVED ((BM_NOTIFY) 0x02)
-
-
-/*
- * BM_HANDLE:
- * ----------
- */
-typedef u32			BM_HANDLE;
-
-#define BM_HANDLE_ROOT		((BM_HANDLE) 0x00000000)
-#define BM_HANDLE_UNKNOWN	((BM_HANDLE) 0xFFFFFFFF)
-#define BM_HANDLES_MAX		100
-
-
-/*
- * BM_HANDLE_LIST:
- * ---------------
- */
-typedef struct
-{
-	u32			count;
-	BM_HANDLE		handles[BM_HANDLES_MAX];
-} BM_HANDLE_LIST;
-
-
-/*
- * BM_DEVICE_TYPE:
- * ---------------
- */
-typedef u32			BM_DEVICE_TYPE;
-
-#define BM_TYPE_UNKNOWN		((BM_DEVICE_TYPE) 0x00000000)
-
-#define BM_TYPE_SYSTEM		((BM_DEVICE_TYPE) 0x00000001)
-#define BM_TYPE_SCOPE		((BM_DEVICE_TYPE) 0x00000002)
-#define BM_TYPE_PROCESSOR	((BM_DEVICE_TYPE) 0x00000003)
-#define BM_TYPE_THERMAL_ZONE	((BM_DEVICE_TYPE) 0x00000004)
-#define BM_TYPE_POWER_RESOURCE	((BM_DEVICE_TYPE) 0x00000005)
-#define BM_TYPE_DEVICE		((BM_DEVICE_TYPE) 0x00000006)
-#define BM_TYPE_FIXED_BUTTON	((BM_DEVICE_TYPE) 0x00000007)
-
-
-/*
- * BM_DEVICE_UID:
- * --------------
- */
-typedef char			BM_DEVICE_UID[9];
-
-#define BM_UID_UNKNOWN		'0'
-
-
-/*
- * BM_DEVICE_HID:
- * --------------
- */
-typedef char			BM_DEVICE_HID[9];
-
-#define BM_HID_UNKNOWN		'\0'
-#define BM_HID_POWER_BUTTON	"PNP0C0C"
-#define BM_HID_SLEEP_BUTTON	"PNP0C0E"
-
-/*
- * BM_DEVICE_ADR:
- * --------------
- */
-typedef u32			BM_DEVICE_ADR;
-
-#define BM_ADDRESS_UNKNOWN	0
-
-
-/*
- * BM_DEVICE_FLAGS:
- * ----------------
- * The encoding of BM_DEVICE_FLAGS is illustrated below.
- * Note that a set bit (1) indicates the property is TRUE
- * (e.g. if bit 0 is set then the device has dynamic status).
- * +--+------------+-+-+-+-+-+-+-+
- * |31| Bits 30:7  |6|5|4|3|2|1|0|
- * +--+------------+-+-+-+-+-+-+-+
- *   |       |      | | | | | | |
- *   |       |      | | | | | | +- Dynamic status?
- *   |       |      | | | | | +--- Identifiable?
- *   |       |      | | | | +----- Configurable?
- *   |       |      | | | +------- Power Control?
- *   |       |      | | +--------- Ejectable?
- *   |       |      | +----------- Docking Station?
- *   |       |      +------------- Fixed-Feature?
- *   |       +-------------------- <Reserved>
- *   +---------------------------- Driver Control?
- *
- * Dynamic status:  Device has a _STA object.
- * Identifiable:    Device has a _HID and/or _ADR and possibly other
- *                  identification objects defined.
- * Configurable:    Device has a _CRS and possibly other configuration
- *                  objects defined.
- * Power Control:   Device has a _PR0 and/or _PS0 and possibly other
- *                  power management objects defined.
- * Ejectable:       Device has an _EJD and/or _EJx and possibly other
- *                  dynamic insertion/removal objects defined.
- * Docking Station: Device has a _DCK object defined.
- * Fixed-Feature:   Device does not exist in the namespace; was
- *                  enumerated as a fixed-feature (e.g. power button).
- * Driver Control:  A driver has been installed for this device.
- */
-typedef u32			BM_DEVICE_FLAGS;
-
-#define BM_FLAGS_UNKNOWN	((BM_DEVICE_FLAGS) 0x00000000)
-
-#define BM_FLAGS_DYNAMIC_STATUS	((BM_DEVICE_FLAGS) 0x00000001)
-#define BM_FLAGS_IDENTIFIABLE	((BM_DEVICE_FLAGS) 0x00000002)
-#define BM_FLAGS_CONFIGURABLE	((BM_DEVICE_FLAGS) 0x00000004)
-#define BM_FLAGS_POWER_CONTROL	((BM_DEVICE_FLAGS) 0x00000008)
-#define BM_FLAGS_EJECTABLE	((BM_DEVICE_FLAGS) 0x00000010)
-#define BM_FLAGS_DOCKING_STATION ((BM_DEVICE_FLAGS) 0x00000020)
-#define BM_FLAGS_FIXED_FEATURE	((BM_DEVICE_FLAGS) 0x00000040)
-#define BM_FLAGS_DRIVER_CONTROL	((BM_DEVICE_FLAGS) 0x80000000)
-
-
-/*
- * Device PM Flags:
- * ----------------
- * +-----------+-+-+-+-+-+-+-+
- * | Bits 31:7 |6|5|4|3|2|1|0|
- * +-----------+-+-+-+-+-+-+-+
- *       |      | | | | | | |
- *       |      | | | | | | +- D0 Support?
- *       |      | | | | | +--- D1 Support?
- *       |      | | | | +----- D2 Support?
- *       |      | | | +------- D3 Support?
- *       |      | | +--------- Power State Queriable?
- *       |      | +----------- Inrush Current?
- *       |      +------------- Wake Capable?
- *       +-------------------- <Reserved>
- *
- * D0-D3 Support:   Device supports corresponding Dx state.
- * Power State:     Device has a _PSC (current power state) object defined.
- * Inrush Current:  Device has an _IRC (inrush current) object defined.
- * Wake Capable:    Device has a _PRW (wake-capable) object defined.
- */
-#define BM_FLAGS_D0_SUPPORT	((BM_DEVICE_FLAGS) 0x00000001)
-#define BM_FLAGS_D1_SUPPORT	((BM_DEVICE_FLAGS) 0x00000002)
-#define BM_FLAGS_D2_SUPPORT	((BM_DEVICE_FLAGS) 0x00000004)
-#define BM_FLAGS_D3_SUPPORT	((BM_DEVICE_FLAGS) 0x00000008)
-#define BM_FLAGS_POWER_STATE	((BM_DEVICE_FLAGS) 0x00000010)
-#define BM_FLAGS_INRUSH_CURRENT	((BM_DEVICE_FLAGS) 0x00000020)
-#define BM_FLAGS_WAKE_CAPABLE	((BM_DEVICE_FLAGS) 0x00000040)
-
-
-/*
- * BM_DEVICE_STATUS:
- * -----------------
- * The encoding of BM_DEVICE_STATUS is illustrated below.
- * Note that a set bit (1) indicates the property is TRUE
- * (e.g. if bit 0 is set then the device is present).
- * +-----------+-+-+-+-+-+
- * | Bits 31:4 |4|3|2|1|0|
- * +-----------+-+-+-+-+-+
- *       |      | | | | |
- *       |      | | | | +- Present?
- *       |      | | | +--- Enabled?
- *       |      | | +----- Show in UI?
- *       |      | +------- Functioning?
- *       |      +--------- Battery Present?
- *       +---------------- <Reserved>
- */
-typedef u32			BM_DEVICE_STATUS;
-
-#define BM_STATUS_UNKNOWN	((BM_DEVICE_STATUS) 0x00000000)
-#define BM_STATUS_PRESENT	((BM_DEVICE_STATUS) 0x00000001)
-#define BM_STATUS_ENABLED	((BM_DEVICE_STATUS) 0x00000002)
-#define BM_STATUS_SHOW_UI	((BM_DEVICE_STATUS) 0x00000004)
-#define BM_STATUS_FUNCTIONING	((BM_DEVICE_STATUS) 0x00000008)
-#define BM_STATUS_BATTERY_PRESENT ((BM_DEVICE_STATUS) 0x00000010)
-#define BM_STATUS_DEFAULT	((BM_DEVICE_STATUS) 0x0000000F)
-
-
-/*
- * BM_POWER_STATE:
- * ---------------
- */
-typedef u32			BM_POWER_STATE;
-
-
-/*
- * BM_DEVICE_ID:
- * -------------
- */
-typedef struct
-{
-	BM_DEVICE_TYPE		type;
-	BM_DEVICE_UID		uid;
-	BM_DEVICE_HID		hid;
-	BM_DEVICE_ADR		adr;
-} BM_DEVICE_ID;
-
-
-/*
- * BM_DEVICE_POWER:
- * ----------------
- * Structure containing basic device power management information.
- */
-typedef struct
-{
-	BM_DEVICE_FLAGS		flags;
-	BM_POWER_STATE		state;
-	BM_DEVICE_FLAGS		dx_supported[ACPI_S_STATE_COUNT];
-} BM_DEVICE_POWER;
-
-
-/*
- * BM_DEVICE:
- * ----------
- */
-typedef struct
-{
-	BM_HANDLE		handle;
-	acpi_handle  		acpi_handle;
-	BM_DEVICE_FLAGS		flags;
-	BM_DEVICE_STATUS	status;
-	BM_DEVICE_ID		id;
-	BM_DEVICE_POWER		power;
-} BM_DEVICE;
-
-
-/*
- * BM_SEARCH:
- * ----------
- * Structure used for searching the ACPI Bus Manager's device hierarchy.
- */
-typedef struct
-{
-	BM_DEVICE_ID		criteria;
-	BM_HANDLE_LIST		results;
-} BM_SEARCH;
-
-
-/*
- * BM_REQUEST:
- * -----------
- * Structure used for sending requests to/through the ACPI Bus Manager.
- */
-typedef struct
-{
-	acpi_status		status;
-	BM_COMMAND		command;
-	BM_HANDLE		handle;
-	acpi_buffer		buffer;
-} BM_REQUEST;
-
-
-/*
- * Driver Registration:
- * --------------------
- */
-
-/* Driver Context */
-typedef void *			BM_DRIVER_CONTEXT;
-
-/* Notification Callback Function */
-typedef
-acpi_status (*BM_DRIVER_NOTIFY) (
-	BM_NOTIFY		notify_type,
-	BM_HANDLE		device_handle,
-	BM_DRIVER_CONTEXT	*context);
-
-/* Request Callback Function */
-typedef
-acpi_status (*BM_DRIVER_REQUEST) (
-	BM_REQUEST		*request,
-	BM_DRIVER_CONTEXT	context);
-
-/* Driver Registration */
-typedef struct
-{
-	BM_DRIVER_NOTIFY	notify;
-	BM_DRIVER_REQUEST	request;
-	BM_DRIVER_CONTEXT	context;
-} BM_DRIVER;
-
-
-/*
- * BM_NODE:
- * --------
- * Structure used to maintain the device hierarchy.
- */
-typedef struct _BM_NODE
-{
-	BM_DEVICE		device;
-	BM_DRIVER		driver;
-	struct _BM_NODE		*parent;
-	struct _BM_NODE		*next;
-	struct
-	{
-		struct _BM_NODE		*head;
-		struct _BM_NODE		*tail;
-	}			scope;
-} BM_NODE;
-
-
-/*
- * BM_NODE_LIST:
- * -------------
- * Structure used to maintain an array of node pointers.
- */
-typedef struct
-{
-	u32			count;
-	BM_NODE			*nodes[BM_HANDLES_MAX];
-} BM_NODE_LIST;
-
-
-/*****************************************************************************
- *                                  Macros
- *****************************************************************************/
-
-/*
- * Device Presence:
- * ----------------
- * Note that status (_STA) means something different for power resources
- * (they're assumed to always be present).
- */
-#define BM_DEVICE_PRESENT(d)	((d->id.type!=BM_TYPE_POWER_RESOURCE)?(d->status & BM_STATUS_PRESENT):TRUE)
-#define BM_NODE_PRESENT(n)	((n->device.id.type!=BM_TYPE_POWER_RESOURCE)?(n->device.status & BM_STATUS_PRESENT):TRUE)
-
-/*
- * Device Flags:
- * -------------
- */
-#define BM_IS_DRIVER_CONTROL(d)	(d->flags & BM_FLAGS_DRIVER_CONTROL)
-#define BM_IS_POWER_CONTROL(d)	(d->flags & BM_FLAGS_POWER_CONTROL)
-
- /*
- * Device Power Flags:
- * -------------------
- */
-#define BM_IS_POWER_STATE(d)	(d->power.flags & BM_FLAGS_POWER_STATE)
-
-/*****************************************************************************
- *                             Function Prototypes
- *****************************************************************************/
-
-/* bm.c */
-
-acpi_status
-bm_initialize (void);
-
-acpi_status
-bm_terminate (void);
-
-acpi_status
-bm_get_status (
-	BM_DEVICE		*device);
-
-acpi_status
-bm_get_handle (
-	acpi_handle             acpi_handle,
-	BM_HANDLE               *device_handle);
-
-acpi_status
-bm_get_node (
-	BM_HANDLE               device_handle,
-	acpi_handle             acpi_handle,
-	BM_NODE			**node);
-
-/* bmsearch.c */
-
-acpi_status
-bm_search(
-	BM_HANDLE               device_handle,
-	BM_DEVICE_ID            *criteria,
-	BM_HANDLE_LIST          *results);
-
-/* bmnotify.c */
-
-void
-bm_notify (
-	acpi_handle             acpi_handle,
-	u32                     notify_value,
-	void                    *context);
-
-/* bm_request.c */
-
-acpi_status
-bm_request (
-	BM_REQUEST		*request_info);
-
-/* bmdriver.c */
-
-acpi_status
-bm_get_device_power_state (
-	BM_HANDLE               device_handle,
-	BM_POWER_STATE		*state);
-
-acpi_status
-bm_set_device_power_state (
-	BM_HANDLE               device_handle,
-	BM_POWER_STATE		state);
-
-acpi_status
-bm_get_device_status (
-	BM_HANDLE               device_handle,
-	BM_DEVICE_STATUS        *device_status);
-
-acpi_status
-bm_get_device_info (
-	BM_HANDLE               device_handle,
-	BM_DEVICE		**device_info);
-
-acpi_status
-bm_get_device_context (
-	BM_HANDLE               device_handle,
-	BM_DRIVER_CONTEXT	*context);
-
-acpi_status
-bm_register_driver (
-	BM_DEVICE_ID		*criteria,
-	BM_DRIVER		*driver);
-
-acpi_status
-bm_unregister_driver (
-	BM_DEVICE_ID		*criteria,
-	BM_DRIVER		*driver);
-
-/* bmpm.c */
-
-acpi_status
-bm_get_pm_capabilities (
-	BM_NODE			*node);
-
-acpi_status
-bm_get_power_state (
-	BM_NODE			*node);
-
-acpi_status
-bm_set_power_state (
-	BM_NODE			*node,
-	BM_POWER_STATE          target_state);
-
-/* bmpower.c */
-
-acpi_status
-bm_pr_initialize (void);
-
-acpi_status
-bm_pr_terminate (void);
-	
-/* bmutils.c */
-
-acpi_status
-bm_cast_buffer (
-	acpi_buffer             *buffer,
-	void                    **pointer,
-	u32                     length);
-
-acpi_status
-bm_copy_to_buffer (
-	acpi_buffer             *buffer,
-	void                    *data,
-	u32                     length);
-
-acpi_status
-bm_extract_package_data (
-	acpi_object             *package,
-	acpi_buffer             *format,
-	acpi_buffer             *buffer);
-
-acpi_status
-bm_evaluate_object (
-	acpi_handle             acpi_handle,
-	acpi_string             pathname,
-	acpi_object_list        *arguments,
-	acpi_buffer             *buffer);
-
-acpi_status
-bm_evaluate_simple_integer (
-	acpi_handle             acpi_handle,
-	acpi_string             pathname,
-	u32                     *data);
-
-acpi_status
-bm_evaluate_reference_list (
-	acpi_handle             acpi_handle,
-	acpi_string             pathname,
-	BM_HANDLE_LIST          *reference_list);
-
-/* ACPI Bus Driver OSL */
-
-acpi_status
-bm_osl_generate_event (
-	BM_HANDLE		device_handle,
-	char			*device_type,
-	char			*device_instance,
-	u32			event_type,
-	u32			event_data);
-
-
-#endif  /* __BM_H__ */
diff -urNp linux-5400/drivers/acpi/ospm/include/bmpower.h linux-5410/drivers/acpi/ospm/include/bmpower.h
--- linux-5400/drivers/acpi/ospm/include/bmpower.h
+++ linux-5410/drivers/acpi/ospm/include/bmpower.h
@@ -1,75 +0,0 @@
-/*****************************************************************************
- *
- * Module name: bmpower.h
- *   $Revision: 9 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __BMPOWER_H__
-#define __BMPOWER_H__
-
-#include "bm.h"
-
-
-/*****************************************************************************
- *                               Types & Defines
- *****************************************************************************/
-
-
-/*
- * BM_POWER_RESOURCE:
- * ------------------
- */
-typedef struct
-{
-	BM_HANDLE           device_handle;
-	acpi_handle         acpi_handle;
-	BM_POWER_STATE      system_level;
-	u32                 resource_order;
-	BM_POWER_STATE      state;
-	u32                 reference_count;
-} BM_POWER_RESOURCE;
-
-
-/*****************************************************************************
- *                             Function Prototypes
- *****************************************************************************/
-
-/* bmpower.c */
-
-acpi_status
-bm_pr_initialize (void);
-
-acpi_status
-bm_pr_terminate (void);
-
-acpi_status
-bm_pr_list_get_state (
-	BM_HANDLE_LIST          *resource_list,
-	BM_POWER_STATE          *power_state);
-
-acpi_status
-bm_pr_list_transition (
-	BM_HANDLE_LIST          *current_list,
-	BM_HANDLE_LIST          *target_list);
-
-
-#endif  /* __BMPOWER_H__ */
diff -urNp linux-5400/drivers/acpi/ospm/include/bn.h linux-5410/drivers/acpi/ospm/include/bn.h
--- linux-5400/drivers/acpi/ospm/include/bn.h
+++ linux-5410/drivers/acpi/ospm/include/bn.h
@@ -1,122 +0,0 @@
-/******************************************************************************
- *
- * Module Name: bn.h
- *   $Revision: 12 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#ifndef __BN_H__
-#define __BN_H__
-
-#include <actypes.h>
-#include <acexcep.h>
-#include <bm.h>
-
-
-/*****************************************************************************
- *                            Types & Other Defines
- *****************************************************************************/
-
-/*
- * Notifications:
- * ---------------------
- */
-#define BN_NOTIFY_STATUS_CHANGE	((BM_NOTIFY) 0x80)
-
-
-/*
- * Types:
- * ------
- */
-#define BN_TYPE_POWER_BUTTON	0x01
-#define BN_TYPE_POWER_BUTTON_FIXED 0x02
-#define BN_TYPE_SLEEP_BUTTON	0x03
-#define BN_TYPE_SLEEP_BUTTON_FIXED 0x04
-#define BN_TYPE_LID_SWITCH	0x05
-
-
-/*
- * Hardware IDs:
- * -------------
- * TBD: Power and Sleep button HIDs also exist in <bm.h>.  Should all
- *      HIDs (ACPI well-known devices) exist in one place (e.g.
- *      acpi_hid.h)?
- */
-#define BN_HID_POWER_BUTTON	"PNP0C0C"
-#define BN_HID_SLEEP_BUTTON	"PNP0C0E"
-#define BN_HID_LID_SWITCH	"PNP0C0D"
-
-
-/*
- * Device Context:
- * ---------------
- */
-typedef struct
-{
-	BM_HANDLE		device_handle;
-	acpi_handle		acpi_handle;
-	u32			type;
-} BN_CONTEXT;
-
-
-/******************************************************************************
- *                              Function Prototypes
- *****************************************************************************/
-
-acpi_status
-bn_initialize (void);
-
-acpi_status
-bn_terminate (void);
-
-acpi_status
-bn_notify_fixed (
-	void			*context);
-
-acpi_status
-bn_notify (
-	u32			notify_type,
-	u32			device,
-	void			**context);
-
-acpi_status
-bn_request(
-	BM_REQUEST		*request_info,
-	void			*context);
-
-/* Button OSL */
-
-acpi_status
-bn_osl_add_device (
-	BN_CONTEXT		*button);
-
-acpi_status
-bn_osl_remove_device (
-	BN_CONTEXT		*button);
-
-acpi_status
-bn_osl_generate_event (
-	u32			event,
-	BN_CONTEXT		*button);
-
-
-#endif	/* __BN_H__ */
diff -urNp linux-5400/drivers/acpi/ospm/include/bt.h linux-5410/drivers/acpi/ospm/include/bt.h
--- linux-5400/drivers/acpi/ospm/include/bt.h
+++ linux-5410/drivers/acpi/ospm/include/bt.h
@@ -1,164 +0,0 @@
-/******************************************************************************
- *
- * Module Name: bt.h
- *   $Revision: 18 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#ifndef __BT_H__
-#define __BT_H__
-
-#include <actypes.h>
-#include <acexcep.h>
-#include <bm.h>
-
-
-/*****************************************************************************
- *                Types & Other Defines
- *****************************************************************************/
-
-/*! [Begin] no source code translation */
-
-#define BT_UNKNOWN		0xFFFFFFFF
-#define BT_POWER_UNITS_DEFAULT  "?"
-#define BT_POWER_UNITS_WATTS    "mW"
-#define BT_POWER_UNITS_AMPS	"mA"
-
-/*! [End] no source code translation !*/
-
-/*
- * Battery Notifications:
- * ----------------------
- */
-#define BT_NOTIFY_STATUS_CHANGE ((BM_NOTIFY) 0x80)
-#define BT_NOTIFY_INFORMATION_CHANGE ((BM_NOTIFY) 0x81)
-
-
-/*
- * Hardware IDs:
- * -------------
- */
-#define BT_HID_CM_BATTERY   "PNP0C0A"
-
-
-/*
- * BT_CM_BATTERY_INFO:
- * -------------------
- */
-typedef struct
-{
-	acpi_integer    power_unit;
-	acpi_integer    design_capacity;
-	acpi_integer    last_full_capacity;
-	acpi_integer    battery_technology;
-	acpi_integer    design_voltage;
-	acpi_integer    design_capacity_warning;
-	acpi_integer    design_capacity_low;
-	acpi_integer    battery_capacity_granularity_1;
-	acpi_integer    battery_capacity_granularity_2;
-	acpi_string     model_number;
-	acpi_string     serial_number;
-	acpi_string     battery_type;
-	acpi_string     oem_info;
-
-} BT_BATTERY_INFO;
-
-
-/*
- * BT_CM_BATTERY_STATUS:
- * ---------------------
- */
-typedef struct
-{
-	acpi_integer    state;
-	acpi_integer    present_rate;
-	acpi_integer    remaining_capacity;
-	acpi_integer    present_voltage;
-
-} BT_BATTERY_STATUS;
-
-
-/*
- * BT_CONTEXT:
- * -----------
- */
-typedef struct
-{
-	BM_HANDLE       device_handle;
-	acpi_handle     acpi_handle;
-	char            uid[9];
-	acpi_string     power_units;
-	u8              is_present;
-
-} BT_CONTEXT;
-
-
-/*****************************************************************************
- *              Function Prototypes
- *****************************************************************************/
-
-/* bt.c */
-
-acpi_status
-bt_initialize (void);
-
-acpi_status
-bt_terminate (void);
-
-acpi_status
-bt_notify (
-	u32         notify_type,
-	u32         device,
-	void        **context);
-
-acpi_status
-bt_request(
-	BM_REQUEST  *request_info,
-	void        *context);
-
-acpi_status
-bt_get_status (
-	BT_CONTEXT		*battery,
-	BT_BATTERY_STATUS   **battery_status);
-
-acpi_status
-bt_get_info (
-	BT_CONTEXT      *battery,
-	BT_BATTERY_INFO **battery_info);
-
-/* Battery OSL */
-
-acpi_status
-bt_osl_add_device (
-	BT_CONTEXT      *battery);
-
-acpi_status
-bt_osl_remove_device (
-	BT_CONTEXT      *battery);
-
-acpi_status
-bt_osl_generate_event (
-	u32         event,
-	BT_CONTEXT      *battery);
-
-
-#endif  /* __BT_H__ */
diff -urNp linux-5400/drivers/acpi/ospm/include/ec.h linux-5410/drivers/acpi/ospm/include/ec.h
--- linux-5400/drivers/acpi/ospm/include/ec.h
+++ linux-5410/drivers/acpi/ospm/include/ec.h
@@ -1,202 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: ec.h
- *   $Revision: 19 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#ifndef __EC_H__
-#define __EC_H__
-
-#include <linux/spinlock.h>
-#include <asm/semaphore.h>
-#include <actypes.h>
-#include <acexcep.h>
-#include <bm.h>
-
-
-/*****************************************************************************
- *                            Types & Other Defines
- *****************************************************************************/
-
-#define EC_DEFAULT_TIMEOUT	1000		/* 1 second */
-#define EC_GPE_UNKNOWN		0xFFFFFFFF
-#define EC_PORT_UNKNOWN		0x00000000
-#define EC_BURST_ENABLE_ACKNOWLEDGE 0x90
-
-
-/*
- * Commands:
- * ---------
- */
-typedef u8			EC_COMMAND;
-
-#define EC_COMMAND_UNKNOWN	((EC_COMMAND) 0x00)
-#define EC_COMMAND_READ		((EC_COMMAND) 0x80)
-#define EC_COMMAND_WRITE	((EC_COMMAND) 0x81)
-#define EC_COMMAND_QUERY	((EC_COMMAND) 0x84)
-
-
-/*
- * EC_STATUS:
- * ----------
- * The encoding of the EC status register is illustrated below.
- * Note that a set bit (1) indicates the property is TRUE
- * (e.g. if bit 0 is set then the output buffer is full).
- * +-+-+-+-+-+-+-+-+
- * |7|6|5|4|3|2|1|0|
- * +-+-+-+-+-+-+-+-+
- *  | | | | | | | |
- *  | | | | | | | +- Output Buffer Full (OBF)?
- *  | | | | | | +--- Input Buffer Full (IBF)?
- *  | | | | | +----- <reserved>
- *  | | | | +------- data Register is command Byte?
- *  | | | +--------- Burst Mode Enabled?
- *  | | +----------- SCI event?
- *  | +------------- SMI event?
- *  +--------------- <Reserved>
- *
- */
-typedef u32			EC_STATUS;
-
-#define EC_FLAG_OUTPUT_BUFFER	((EC_STATUS) 0x01)
-#define EC_FLAG_INPUT_BUFFER	((EC_STATUS) 0x02)
-#define EC_FLAG_BURST_MODE	((EC_STATUS) 0x10)
-#define EC_FLAG_SCI		((EC_STATUS) 0x20)
-
-
-/*
- * EC_EVENT:
- * ---------
- */
-typedef u32			EC_EVENT;
-
-#define EC_EVENT_UNKNOWN	((EC_EVENT) 0x00)
-#define EC_EVENT_NONE		((EC_EVENT) 0x00)
-#define EC_EVENT_OUTPUT_BUFFER_FULL ((EC_EVENT) 0x01)
-#define EC_EVENT_INPUT_BUFFER_EMPTY ((EC_EVENT) 0x02)
-#define EC_EVENT_SCI		((EC_EVENT) 0x03)
-
-
-/*
- * Hardware IDs:
- * -------------
- */
-#define EC_HID_EC		"PNP0C09"
-
-
-/*
- * EC_REQUEST:
- * -----------
- */
-typedef struct
-{
-	EC_COMMAND              command;
-	u8                      address;
-	u8                      data;
-} EC_REQUEST;
-
-
-/*
- * Device Context:
- * ---------------
- */
-typedef struct
-{
-	BM_HANDLE               device_handle;
-	acpi_handle             acpi_handle;
-	u32                     gpe_bit;
-	u32			status_port;
-	u32			command_port;
-	u32			data_port;
-	u32			use_global_lock;
-	u8                      query_data;
-	acpi_handle             mutex;
-} EC_CONTEXT;
-
-
-/*****************************************************************************
- *                             Function Prototypes
- *****************************************************************************/
-
-/* ec.c */
-
-acpi_status
-ec_initialize(void);
-
-acpi_status
-ec_terminate(void);
-
-acpi_status
-ec_notify (
-	u32                     notify_type,
-	u32                     device,
-	void                    **context);
-
-acpi_status
-ec_request(
-	BM_REQUEST              *request_info,
-	void                    *context);
-
-/* ectransx.c */
-
-acpi_status
-ec_transaction (
-	EC_CONTEXT              *ec,
-	EC_REQUEST              *ec_request);
-
-acpi_status
-ec_io_read (
-	EC_CONTEXT              *ec,
-	u32         		io_port,
-	u8                      *data,
-	EC_EVENT                wait_event);
-
-acpi_status
-ec_io_write (
-	EC_CONTEXT              *ec,
-	u32         		io_port,
-	u8                      data,
-	EC_EVENT                wait_event);
-
-/* ecgpe.c */
-
-acpi_status
-ec_install_gpe_handler (
-	EC_CONTEXT              *ec);
-
-acpi_status
-ec_remove_gpe_handler (
-	EC_CONTEXT              *ec);
-
-/* ecspace.c */
-
-acpi_status
-ec_install_space_handler (
-	EC_CONTEXT              *ec);
-
-acpi_status
-ec_remove_space_handler (
-	EC_CONTEXT              *ec);
-
-
-#endif  /* __EC_H__ */
diff -urNp linux-5400/drivers/acpi/ospm/include/pr.h linux-5410/drivers/acpi/ospm/include/pr.h
--- linux-5400/drivers/acpi/ospm/include/pr.h
+++ linux-5410/drivers/acpi/ospm/include/pr.h
@@ -1,265 +0,0 @@
-/******************************************************************************
- *
- * Module Name: processor.h
- *              $Revision: 13 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __PR_H__
-#define __PR_H__
-
-#include <bm.h>
-
-
-/*****************************************************************************
- *                             Types & Other Defines
- *****************************************************************************/
-
-
-#define PR_MAX_POWER_STATES	4
-#define PR_MAX_THROTTLE_STATES  8
-#define PR_MAX_PERF_STATES	32
-#define PR_MAX_C2_LATENCY	100
-#define PR_MAX_C3_LATENCY	1000
-
-
-/*
- * Commands:
- * ---------
- */
-#define PR_COMMAND_GET_POWER_INFO ((BM_COMMAND) 0x80)
-#define PR_COMMAND_SET_POWER_INFO ((BM_COMMAND) 0x81)
-#define PR_COMMAND_GET_PERF_INFO ((BM_COMMAND) 0x82)
-#define PR_COMMAND_GET_PERF_STATE ((BM_COMMAND) 0x83)
-#define PR_COMMAND_SET_PERF_LIMIT ((BM_COMMAND) 0x84)
-
-
-/*
- * Notifications:
- * --------------
- */
-#define PR_NOTIFY_PERF_STATES	((BM_NOTIFY) 0x80)
-#define PR_NOTIFY_POWER_STATES	((BM_NOTIFY) 0x81)
-
-
-/*
- * Performance Control:
- * --------------------
- */
-#define PR_PERF_DEC		0x00
-#define PR_PERF_INC		0x01
-#define PR_PERF_MAX		0xFF
-
-
-/*
- * Power States:
- * -------------
- */
-#define PR_C0			0x00
-#define PR_C1			0x01
-#define PR_C2			0x02
-#define PR_C3			0x03
-
-#define PR_C1_FLAG		0x01;
-#define PR_C2_FLAG		0x02;
-#define PR_C3_FLAG		0x04;
-
-
-/*
- * PR_CX_POLICY_VALUES:
- * --------------------
- */
-typedef struct
-{
-	u32			time_threshold;
-	u32			count_threshold;
-	u32                     bm_threshold;
-	u32         		target_state;
-	u32			count;
-} PR_CX_POLICY_VALUES;
-
-
-/*
- * PR_CX:
- * ------
- */
-typedef struct
-{
-	u32                     latency;
-	u32                     utilization;
-	u8                      is_valid;
-	PR_CX_POLICY_VALUES     promotion;
-	PR_CX_POLICY_VALUES     demotion;
-} PR_CX;
-
-
-/*
- * PR_POWER:
- * ---------
- */
-typedef struct
-{
-	ACPI_PHYSICAL_ADDRESS   p_lvl2;
-	ACPI_PHYSICAL_ADDRESS   p_lvl3;
-	u32                     bm_activity;
-	u32                     active_state;
-	u32			default_state;
-	u32			busy_metric;
-	u32                     state_count;
-	PR_CX                   state[PR_MAX_POWER_STATES];
-} PR_POWER;
-
-
-/*
- * PR_PERFORMANCE_STATE:
- * ---------------------
- */
-typedef struct
-{
-	u32                     performance;
-	u32                     power;
-} PR_PERFORMANCE_STATE;
-
-
-/*
- * PR_PERFORMANCE:
- * ---------------
- */
-typedef struct
-{
-	u32                     active_state;
-	u32			thermal_limit;
-	u32			power_limit;
-	u32                     state_count;
-	PR_PERFORMANCE_STATE    state[PR_MAX_PERF_STATES];
-} PR_PERFORMANCE;
-
-
-/*
- * PR_PBLOCK:
- * ----------
- */
-typedef struct
-{
-	u32                     length;
-	ACPI_PHYSICAL_ADDRESS   address;
-} PR_PBLOCK;
-
-
-/*
- * PR_CONTEXT:
- * -----------
- */
-typedef struct
-{
-	BM_HANDLE               device_handle;
-	acpi_handle             acpi_handle;
-	u32                     uid;
-	PR_PBLOCK               pblk;
-	PR_POWER		power;
-	PR_PERFORMANCE		performance;
-} PR_CONTEXT;
-
-
-/******************************************************************************
- *                             Function Prototypes
- *****************************************************************************/
-
-/* processor.c */
-
-acpi_status
-pr_initialize(void);
-
-acpi_status
-pr_terminate(void);
-
-acpi_status
-pr_notify (
-	BM_NOTIFY               notify_type,
-	BM_HANDLE               device_handle,
-	void                    **context);
-
-acpi_status
-pr_request(
-	BM_REQUEST		*request,
-	void                    *context);
-
-/* prpower.c */
-
-void
-pr_power_idle (void);
-
-acpi_status
-pr_power_add_device (
-	PR_CONTEXT              *processor);
-
-acpi_status
-pr_power_remove_device (
-	PR_CONTEXT              *processor);
-
-acpi_status
-pr_power_initialize (void);
-
-acpi_status
-pr_power_terminate (void);
-
-/* prperf.c */
-
-acpi_status
-pr_perf_get_state (
-	PR_CONTEXT              *processor,
-	u32                     *state);
-
-acpi_status
-pr_perf_set_state (
-	PR_CONTEXT              *processor,
-	u32                     state);
-
-acpi_status
-pr_perf_set_limit (
-	PR_CONTEXT              *processor,
-	u32                     limit);
-
-acpi_status
-pr_perf_add_device (
-	PR_CONTEXT              *processor);
-
-acpi_status
-pr_perf_remove_device (
-	PR_CONTEXT              *processor);
-
-/* Processor Driver OSL */
-
-acpi_status
-pr_osl_add_device (
-	PR_CONTEXT		*processor);
-
-acpi_status
-pr_osl_remove_device (
-	PR_CONTEXT		*processor);
-
-acpi_status
-pr_osl_generate_event (
-	u32			event,
-	PR_CONTEXT		*processor);
-
-
-#endif  /* __PR_H__ */
diff -urNp linux-5400/drivers/acpi/ospm/include/sm.h linux-5410/drivers/acpi/ospm/include/sm.h
--- linux-5400/drivers/acpi/ospm/include/sm.h
+++ linux-5410/drivers/acpi/ospm/include/sm.h
@@ -1,91 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: sm.h
- *   $Revision: 3 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#ifndef __SM_H__
-#define __SM_H__
-
-#include <actypes.h>
-#include <acexcep.h>
-#include <bm.h>
-
-
-/*****************************************************************************
- *                            Types & Other Defines
- *****************************************************************************/
-
-#define SM_MAX_SYSTEM_STATES	6	/* S0-S5 */
-
-
- /*
- * Device Context:
- * ---------------
- */
-typedef struct
-{
-	BM_HANDLE		device_handle;
-	acpi_handle 		acpi_handle;
-	u8			states[SM_MAX_SYSTEM_STATES];
-} SM_CONTEXT;
-
-
-/*****************************************************************************
- *                              Function Prototypes
- *****************************************************************************/
-
-acpi_status
-sm_initialize (void);
-
-acpi_status
-sm_terminate (void);
-
-acpi_status
-sm_notify (
-	u32			notify_type,
-	u32 			device,
-	void			**context);
-
-acpi_status
-sm_request(
-	BM_REQUEST		*request_info,
-	void			*context);
-
-/* System Driver OSL */
-
-acpi_status
-sm_osl_add_device (
-	SM_CONTEXT		*system);
-
-acpi_status
-sm_osl_remove_device (
-	SM_CONTEXT		*system);
-
-acpi_status
-sm_osl_generate_event (
-	u32			event,
-	SM_CONTEXT		*system);
-
-
-#endif	/* __SM_H__ */
diff -urNp linux-5400/drivers/acpi/ospm/include/tz.h linux-5410/drivers/acpi/ospm/include/tz.h
--- linux-5400/drivers/acpi/ospm/include/tz.h
+++ linux-5410/drivers/acpi/ospm/include/tz.h
@@ -1,252 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: tz.h
- *   $Revision: 24 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __TZ_H__
-#define __TZ_H__
-
-/* TBD: Linux-specific */
-#include <linux/module.h>
-#include <linux/timer.h>
-
-#include <bm.h>
-#include <pr.h>
-
-
-/*****************************************************************************
- *                             Types & Other Defines
- *****************************************************************************/
-
-#define TZ_MAX_THRESHOLDS	12	/* _AC0 through _AC9 + _CRT + _PSV */
-#define TZ_MAX_ACTIVE_THRESHOLDS 10	/* _AC0 through _AC9 */
-#define TZ_MAX_COOLING_DEVICES	10	/* TBD: Make size dynamic */
-
-
-/*
- * Notifications:
- * --------------
- */
-#define TZ_NOTIFY_TEMPERATURE_CHANGE ((BM_NOTIFY) 0x80)
-#define TZ_NOTIFY_THRESHOLD_CHANGE ((BM_NOTIFY) 0x81)
-#define TZ_NOTIFY_DEVICE_LISTS_CHANGE ((BM_NOTIFY) 0x82)
-
-
-/*
- * TZ_THRESHOLD_TYPE:
- * ------------------
- */
-typedef u32			TZ_THRESHOLD_TYPE;
-
-#define TZ_THRESHOLD_UNKNOWN	((TZ_THRESHOLD_TYPE) 0x00)
-#define TZ_THRESHOLD_CRITICAL	((TZ_THRESHOLD_TYPE) 0x01)
-
-#define TZ_THRESHOLD_PASSIVE	((TZ_THRESHOLD_TYPE) 0x02)
-#define TZ_THRESHOLD_ACTIVE	((TZ_THRESHOLD_TYPE) 0x03)
-
-
-/*
- * TZ_COOLING_STATE:
- * -----------------
- */
-typedef u32			TZ_COOLING_STATE;
-
-#define TZ_COOLING_UNKNOWN	((TZ_COOLING_STATE) 0x00)
-#define TZ_COOLING_ENABLED	((TZ_COOLING_STATE) 0x01)
-#define TZ_COOLING_DISABLED	((TZ_COOLING_STATE) 0x02)
-
-
-/*
- * TZ_COOLING_MODE:
- * ----------------
- */
-typedef u32			TZ_COOLING_MODE;
-
-#define TZ_COOLING_MODE_ACTIVE	((TZ_COOLING_MODE) 0x00)
-#define TZ_COOLING_MODE_PASSIVE	((TZ_COOLING_MODE) 0x01)
-
-
-/*
- * Thermal State:
- * --------------
- * The encoding of TZ_STATE is illustrated below.
- * Note that a set bit (1) indicates the property is TRUE
- * (e.g. if bit 0 is set then the device has dynamic status).
- * No bits set indicates an OK cooling state.
- * +--+--+--+-----------+----------+
- * |31|30|29| Bits 27:4 | Bits 3:0 |
- * +--+--+--+-----------+----------+
- *  |  |  |       |          |
- *  |  |  |       |          +------ Active Index
- *  |  |  |       +----------------- <reserved>
- *  |  |  +------------------------- Active
- *  |  +---------------------------- Passive
- *  +------------------------------- Critical
- *
- * Active Index:    Value representing the level of active cooling
- *                  presently applied (e.g. 0=_AL0, 9=_AL9).  Only
- *                  valid when 'Active' is set.
- * Active:          If set, indicates that the system temperature
- *                  has crossed at least one active threshold (_ALx).
- * Passive:         If set, indicates that the system temperature
- *                  has crossed the passive threshold (_PSL).
- * Passive:         If set, indicates that the system temperature
- *                  has crossed the critical threshold (_CRT).
- */
-typedef u32			TZ_STATE;
-
-#define TZ_STATE_OK		((TZ_STATE) 0x00000000)
-#define TZ_STATE_HOT		((TZ_STATE) 0x10000000)
-#define TZ_STATE_ACTIVE		((TZ_STATE) 0x20000000)
-#define TZ_STATE_PASSIVE	((TZ_STATE) 0x40000000)
-#define TZ_STATE_CRITICAL	((TZ_STATE) 0x80000000)
-
-typedef struct {
-	u32			temperature;
-} TZ_CRITICAL_THRESHOLD;
-
-typedef struct {
-	u8			is_valid;
-	u32			temperature;
-} TZ_HOT_THRESHOLD;
-
-typedef struct {
-	u8			is_valid;
-	u32			temperature;
-	u32			tc1;
-	u32			tc2;
-	u32			tsp;
-	BM_HANDLE_LIST		devices;
-} TZ_PASSIVE_THRESHOLD;
-
-typedef struct {
-	u8			is_valid;
-	u32			temperature;
-	TZ_COOLING_STATE	cooling_state;
-	BM_HANDLE_LIST		devices;
-} TZ_ACTIVE_THRESHOLD;
-
-typedef struct {
-	TZ_CRITICAL_THRESHOLD	critical;
-	TZ_HOT_THRESHOLD	hot;
-	TZ_PASSIVE_THRESHOLD	passive;
-	TZ_ACTIVE_THRESHOLD	active[TZ_MAX_ACTIVE_THRESHOLDS];
-} TZ_THRESHOLDS;
-
-/*
- * TZ_POLICY:
- * ---------
- */
-typedef struct {
-	u32			temperature;
-	TZ_STATE		state;
-	TZ_COOLING_MODE		cooling_mode;
-	u32			polling_freq;
-	TZ_THRESHOLDS		thresholds;
-	struct timer_list	timer;
-} TZ_POLICY;
-
-
-/*
- * TZ_CONTEXT:
- * -----------
- */
-typedef struct {
-	BM_HANDLE		device_handle;
-	acpi_handle		acpi_handle;
-	char			uid[9];
-	TZ_POLICY		policy;
-} TZ_CONTEXT;
-
-
-/*****************************************************************************
- *                             Function Prototypes
- *****************************************************************************/
-
-/* tz.c */
-
-acpi_status
-tz_initialize (void);
-
-acpi_status
-tz_terminate (void);
-
-acpi_status
-tz_notify (
-	BM_NOTIFY               notify_type,
-	BM_HANDLE               device_handle,
-	BM_DRIVER_CONTEXT	*context);
-
-acpi_status
-tz_request (
-	BM_REQUEST              *request,
-	BM_DRIVER_CONTEXT	context);
-
-acpi_status
-tz_get_temperature (
-	TZ_CONTEXT		*tz);
-
-acpi_status
-tz_get_thresholds (
-	TZ_CONTEXT		*tz);
-
-acpi_status
-tz_set_cooling_preference (
-	TZ_CONTEXT              *tz,
-	TZ_COOLING_MODE         cooling_mode);
-
-void
-tz_print (
-	TZ_CONTEXT              *tz);
-
-/* tzpolicy.c */
-
-acpi_status
-tz_policy_add_device (
-	TZ_CONTEXT              *tz);
-
-acpi_status
-tz_policy_remove_device (
-	TZ_CONTEXT              *tz);
-
-void
-tz_policy_check (
-	void                    *context);
-
-/* tz_osl.c */
-
-acpi_status
-tz_osl_add_device (
-	TZ_CONTEXT		*tz);
-
-acpi_status
-tz_osl_remove_device (
-	TZ_CONTEXT		*tz);
-
-acpi_status
-tz_osl_generate_event (
-	u32			event,
-	TZ_CONTEXT		*tz);
-
-
-#endif  /* __TZ_H__ */
diff -urNp linux-5400/drivers/acpi/ospm/processor/Makefile linux-5410/drivers/acpi/ospm/processor/Makefile
--- linux-5400/drivers/acpi/ospm/processor/Makefile
+++ linux-5410/drivers/acpi/ospm/processor/Makefile
@@ -1,6 +0,0 @@
-O_TARGET	:= ospm_$(notdir $(CURDIR)).o
-obj-m		:= $(O_TARGET)
-EXTRA_CFLAGS	+= $(ACPI_CFLAGS)
-obj-y		:= $(patsubst %.c,%.o,$(wildcard *.c))
-
-include $(TOPDIR)/Rules.make
diff -urNp linux-5400/drivers/acpi/ospm/processor/pr.c linux-5410/drivers/acpi/ospm/processor/pr.c
--- linux-5400/drivers/acpi/ospm/processor/pr.c
+++ linux-5410/drivers/acpi/ospm/processor/pr.c
@@ -1,497 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: pr.c
- *   $Revision: 34 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include <acpi.h>
-#include <bm.h>
-#include "pr.h"
-
-
-#define _COMPONENT		ACPI_PROCESSOR
-	MODULE_NAME		("pr")
-
-
-/****************************************************************************
- *                                  Globals
- ****************************************************************************/
-
-extern fadt_descriptor_rev2	acpi_fadt;
-
-
-/****************************************************************************
- *                             Internal Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:    pr_print
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION: Prints out information on a specific thermal zone.
- *
- ****************************************************************************/
-
-void
-pr_print (
-	PR_CONTEXT              *processor)
-{
-#ifdef ACPI_DEBUG
-	acpi_buffer             buffer;
-
-	FUNCTION_TRACE("pr_print");
-
-	buffer.length = 256;
-	buffer.pointer = acpi_os_callocate(buffer.length);
-	if (!buffer.pointer) {
-		return;
-	}
-
-	/*
-	 * Get the full pathname for this ACPI object.
-	 */
-	acpi_get_name(processor->acpi_handle, ACPI_FULL_PATHNAME, &buffer);
-
-	/*
-	 * Print out basic processor information.
-	 */
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "+------------------------------------------------------------\n"));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "| Processor[%02x]:[%p] uid[%02x] %s\n", processor->device_handle, processor->acpi_handle, processor->uid, (char*)buffer.pointer));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "|   power: %cC0 %cC1 %cC2[%d] %cC3[%d]\n", (processor->power.state[0].is_valid?'+':'-'), (processor->power.state[1].is_valid?'+':'-'), (processor->power.state[2].is_valid?'+':'-'), processor->power.state[2].latency, (processor->power.state[3].is_valid?'+':'-'), processor->power.state[3].latency));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "|   performance: states[%d]\n", processor->performance.state_count));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "+------------------------------------------------------------\n"));
-
-	acpi_os_free(buffer.pointer);
-#endif /* ACPI_DEBUG */
-
-	return;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    pr_add_device
- *
- * PARAMETERS:  <none>
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-pr_add_device(
-	BM_HANDLE		device_handle,
-	void			**context)
-{
-	acpi_status		status = AE_OK;
-	PR_CONTEXT		*processor = NULL;
-	BM_DEVICE		*device = NULL;
-	acpi_buffer		buffer;
-	acpi_object		acpi_object;
-	static u32		processor_count = 0;
-
-
-	FUNCTION_TRACE("pr_add_device");
-
-	if (!context || *context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	status = bm_get_device_info(device_handle, &device);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	processor = acpi_os_callocate(sizeof(PR_CONTEXT));
-	if (!processor) {
-		return AE_NO_MEMORY;
-	}
-
-	processor->device_handle = device->handle;
-	processor->acpi_handle = device->acpi_handle;
-
-	/*
-	 * Processor Block:
-	 * ----------------
-	 */
-	memset(&acpi_object, 0, sizeof(acpi_object));
-
-	buffer.length = sizeof(acpi_object);
-	buffer.pointer = &acpi_object;
-
-	status = acpi_evaluate_object(processor->acpi_handle, NULL, NULL, &buffer);
-	if (ACPI_FAILURE(status)) {
-		goto end;
-	}
-
-	/*
-	 * Processor ID:
-	 * -------------
-	 * TBD:  We need to synchronize the processor ID values in ACPI
-	 *       with those of the APIC.  For example, an IBM T20 has a
-	 *       proc_id value of '1', where the Linux value for the
-	 *       first CPU on this system is '0'.  Since x86 CPUs are
-	 *       mapped 1:1 we can simply use a zero-based counter.  Note
-	 *       that this assumes that processor objects are enumerated
-	 *       in the proper order.
-	 */
-	/* processor->uid = acpi_object.processor.proc_id; */
-	processor->uid = processor_count++;
-
-	processor->pblk.length = acpi_object.processor.pblk_length;
-	processor->pblk.address = acpi_object.processor.pblk_address;
-
-	status = pr_power_add_device(processor);
-	if (ACPI_FAILURE(status)) {
-		goto end;
-	}
-
-	status = pr_perf_add_device(processor);
-	if (ACPI_FAILURE(status)) {
-		goto end;
-	}
-
-	status = pr_osl_add_device(processor);
-	if (ACPI_FAILURE(status)) {
-		goto end;
-	}
-
-	*context = processor;
-
-	pr_print(processor);
-
-end:
-	if (ACPI_FAILURE(status)) {
-		acpi_os_free(processor);
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    pr_remove_device
- *
- * PARAMETERS:  <none>
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-pr_remove_device (
-	void			**context)
-{
-	acpi_status		status = AE_OK;
-	PR_CONTEXT		*processor= NULL;
-
-	FUNCTION_TRACE("pr_remove_device");
-
-	if (!context || !*context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	processor = (PR_CONTEXT*)(*context);
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Removing processor device [%02x].\n", processor->device_handle));
-
-	pr_osl_remove_device(processor);
-
-	pr_perf_remove_device(processor);
-
-	pr_power_remove_device(processor);
-
-	acpi_os_free(processor);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *                            External Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:    pr_initialize
- *
- * PARAMETERS:  <none>
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-pr_initialize (void)
-{
-	acpi_status		status = AE_OK;
-	BM_DEVICE_ID		criteria;
-	BM_DRIVER		driver;
-
-	FUNCTION_TRACE("pr_initialize");
-
-	memset(&criteria, 0, sizeof(BM_DEVICE_ID));
-	memset(&driver, 0, sizeof(BM_DRIVER));
-
-	/*
-	 * Initialize power (Cx state) policy.
-	 */
-	status = pr_power_initialize();
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Register driver for processor devices.
-	 */
-	criteria.type = BM_TYPE_PROCESSOR;
-
-	driver.notify = &pr_notify;
-	driver.request = &pr_request;
-
-	status = bm_register_driver(&criteria, &driver);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    pr_terminate
- *
- * PARAMETERS:  <none>
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-pr_terminate (void)
-{
-	acpi_status             status = AE_OK;
-	BM_DEVICE_ID		criteria;
-	BM_DRIVER		driver;
-
-	FUNCTION_TRACE("pr_terminate");
-
-	memset(&criteria, 0, sizeof(BM_DEVICE_ID));
-	memset(&driver, 0, sizeof(BM_DRIVER));
-
-	/*
-	 * Terminate power (Cx state) policy.
-	 */
-	status = pr_power_terminate();
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Unegister driver for processor devices.
-	 */
-	criteria.type = BM_TYPE_PROCESSOR;
-
-	driver.notify = &pr_notify;
-	driver.request = &pr_request;
-
-	status = bm_unregister_driver(&criteria, &driver);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    pr_notify
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-pr_notify (
-	BM_NOTIFY		notify_type,
-	BM_HANDLE		device_handle,
-	void			**context)
-{
-	acpi_status		status = AE_OK;
-	PR_CONTEXT		*processor = NULL;
-
-	FUNCTION_TRACE("pr_notify");
-
-	processor = (PR_CONTEXT*)*context;
-
-	switch (notify_type) {
-
-	case BM_NOTIFY_DEVICE_ADDED:
-		status = pr_add_device(device_handle, context);
-		break;
-
-	case BM_NOTIFY_DEVICE_REMOVED:
-		status = pr_remove_device(context);
-		break;
-
-	case PR_NOTIFY_PERF_STATES:
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Performance states change event detected on processor [%02x].\n", device_handle));
-		/* TBD: Streamline (this is simple but overkill). */
-		status = pr_perf_remove_device(processor);
-		if (ACPI_SUCCESS(status)) {
-			status = pr_perf_add_device(processor);
-		}
-		if (ACPI_SUCCESS(status)) {
-			status = pr_osl_generate_event(notify_type,
-				(processor));
-		}
-		break;
-
-	case PR_NOTIFY_POWER_STATES:
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Power states change event detected on processor [%02x].\n", device_handle));
-		/* TBD: Streamline (this is simple but overkill). */
-		status = pr_power_remove_device(processor);
-		if (ACPI_SUCCESS(status)) {
-			status = pr_power_add_device(processor);
-		}
-		if (ACPI_SUCCESS(status)) {
-			status = pr_osl_generate_event(notify_type,
-				(processor));
-		}
-		break;
-
-	default:
-		status = AE_SUPPORT;
-		break;
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    pr_request
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-pr_request (
-	BM_REQUEST		*request,
-	void			*context)
-{
-	acpi_status		status = AE_OK;
-	PR_CONTEXT		*processor = NULL;
-
-	FUNCTION_TRACE("pr_request");
-
-	/*
-	 * Must have a valid request structure and context.
-	 */
-	if (!request || !context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	processor = (PR_CONTEXT*)context;
-
-	/*
-	 * Handle request:
-	 * ---------------
-	 */
-	switch (request->command) {
-
-	case PR_COMMAND_GET_POWER_INFO:
-		status = bm_copy_to_buffer(&(request->buffer),
-			&(processor->power), sizeof(PR_POWER));
-		break;
-
-	case PR_COMMAND_SET_POWER_INFO:
-	 {
-		PR_POWER *power_info = NULL;
-		u32 i = 0;
-
-		status = bm_cast_buffer(&(request->buffer),
-			(void**)&power_info, sizeof(PR_POWER));
-		if (ACPI_SUCCESS(status)) {
-			for (i=0; i<processor->power.state_count; i++) {
-				MEMCPY(&(processor->power.state[i].promotion),
-					&(power_info->state[i].promotion),
-					sizeof(PR_CX_POLICY_VALUES));
-				MEMCPY(&(processor->power.state[i].demotion),
-					&(power_info->state[i].demotion),
-					sizeof(PR_CX_POLICY_VALUES));
-			}
-		}
-	}
-		break;
-
-	case PR_COMMAND_GET_PERF_INFO:
-		status = bm_copy_to_buffer(&(request->buffer),
-			&(processor->performance), sizeof(PR_PERFORMANCE));
-		break;
-
-	case PR_COMMAND_GET_PERF_STATE:
-		status = bm_copy_to_buffer(&(request->buffer),
-			&(processor->performance.active_state), sizeof(u32));
-		break;
-
-	case PR_COMMAND_SET_PERF_LIMIT:
-	 {
-		u32 *limit = NULL;
-
-		status = bm_cast_buffer(&(request->buffer),
-			(void**)&limit, sizeof(u32));
-		if (ACPI_SUCCESS(status)) {
-			status = pr_perf_set_limit(processor, *limit);
-		}
-	}
-		break;
-
-	default:
-		status = AE_SUPPORT;
-		break;
-	}
-
-	request->status = status;
-
-	return_ACPI_STATUS(status);
-}
diff -urNp linux-5400/drivers/acpi/ospm/processor/pr_osl.c linux-5410/drivers/acpi/ospm/processor/pr_osl.c
--- linux-5400/drivers/acpi/ospm/processor/pr_osl.c
+++ linux-5410/drivers/acpi/ospm/processor/pr_osl.c
@@ -1,344 +0,0 @@
-/******************************************************************************
- *
- * Module Name: pr_osl.c
- *   $Revision: 21 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/proc_fs.h>
-#include <linux/pci.h>
-#include <acpi.h>
-#include <bm.h>
-#include "pr.h"
-
-
-MODULE_AUTHOR("Andrew Grover");
-MODULE_DESCRIPTION("ACPI Component Architecture (CA) - IA32 Processor Driver");
-MODULE_LICENSE("GPL");
-
-
-#define PR_PROC_ROOT		"processor"
-#define PR_PROC_STATUS		"status"
-#define PR_PROC_INFO		"info"
-
-extern struct proc_dir_entry	*bm_proc_root;
-static struct proc_dir_entry	*pr_proc_root = NULL;
-extern unsigned short		acpi_piix4_bmisx;
-
-
-/****************************************************************************
- *
- * FUNCTION:	pr_osl_proc_read_status
- *
- ****************************************************************************/
-
-static int
-pr_osl_proc_read_status (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*context)
-{
-	PR_CONTEXT		*processor = NULL;
-	char			*p = page;
-	int 			len = 0;
-
-	if (!context || (off != 0)) {
-		goto end;
-	}
-
-	processor = (PR_CONTEXT*)context;
-
-	p += sprintf(p, "Bus Mastering Activity:  %08x\n",
-		processor->power.bm_activity);
-
-	p += sprintf(p, "C-State Utilization:     C1[%d] C2[%d] C3[%d]\n",
-		processor->power.state[PR_C1].utilization,
-		processor->power.state[PR_C2].utilization,
-		processor->power.state[PR_C3].utilization);
-
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return(len);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	pr_osl_proc_read_info
- *
- ****************************************************************************/
-
-static int
-pr_osl_proc_read_info (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*context)
-{
-	PR_CONTEXT		*processor = NULL;
-	char			*p = page;
-	int 			len = 0;
-
-	if (!context || (off != 0)) {
-		goto end;
-	}
-
-	processor = (PR_CONTEXT*)context;
-
-	p += sprintf(p, "<TBD>\n");
-
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return(len);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	pr_osl_add_device
- *
- ****************************************************************************/
-
-acpi_status
-pr_osl_add_device(
-	PR_CONTEXT		*processor)
-{
-	u32			i = 0;
-	struct proc_dir_entry	*proc_entry = NULL, *proc;
-	char			processor_uid[16];
-
-	if (!processor) {
-		return(AE_BAD_PARAMETER);
-	}
-
-	printk("Processor[%x]:", processor->uid);
-	for (i=0; i<processor->power.state_count; i++) {
-		if (processor->power.state[i].is_valid) {
-			printk(" C%d", i);
-		}
-	}
-	if (processor->performance.state_count > 1)
-		printk(", %d throttling states", processor->performance.state_count);
-	if (acpi_piix4_bmisx && processor->power.state[3].is_valid)
-		printk(" (PIIX errata enabled)");
-	printk("\n");
-
-	sprintf(processor_uid, "%d", processor->uid);
-
-	proc_entry = proc_mkdir(processor_uid, pr_proc_root);
-	if (!proc_entry)
-		return(AE_ERROR);
-
-	proc = create_proc_read_entry(PR_PROC_STATUS, S_IFREG | S_IRUGO, 
-				      proc_entry, pr_osl_proc_read_status, (void*)processor);
-	if (!proc_entry)
-		return(AE_ERROR);
-
-	proc = create_proc_read_entry(PR_PROC_INFO, S_IFREG | S_IRUGO, 
-				      proc_entry, pr_osl_proc_read_info, (void*)processor);
-	if (!proc_entry)
-		return(AE_ERROR);
-
-	return(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	pr_osl_remove_device
- *
- ****************************************************************************/
-
-acpi_status
-pr_osl_remove_device (
-	PR_CONTEXT		*processor)
-{
-	char			proc_entry[64];
-
-	if (!processor) {
-		return(AE_BAD_PARAMETER);
-	}
-
-	sprintf(proc_entry, "%d/%s", processor->uid, PR_PROC_INFO);
-	remove_proc_entry(proc_entry, pr_proc_root);
-
-	sprintf(proc_entry, "%d/%s", processor->uid, PR_PROC_STATUS);
-	remove_proc_entry(proc_entry, pr_proc_root);
-
-	sprintf(proc_entry, "%d", processor->uid);
-	remove_proc_entry(proc_entry, pr_proc_root);
-
-	return(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	pr_osl_generate_event
- *
- ****************************************************************************/
-
-acpi_status
-pr_osl_generate_event (
-	u32			event,
-	PR_CONTEXT		*processor)
-{
-	acpi_status		status = AE_OK;
-	char			processor_uid[16];
-
-	if (!processor) {
-		return(AE_BAD_PARAMETER);
-	}
-
-	switch (event) {
-
-	case PR_NOTIFY_PERF_STATES:
-	case PR_NOTIFY_POWER_STATES:
-		sprintf(processor_uid, "%d", processor->uid);
-		status = bm_osl_generate_event(processor->device_handle,
-			PR_PROC_ROOT, processor_uid, event, 0);
-		break;
-
-	default:
-		return(AE_BAD_PARAMETER);
-		break;
-	}
-
-	return(status);
-}
-
-
-/****************************************************************************
- *                              Errata Handling
- ****************************************************************************/
-
-void acpi_pr_errata (void)
-{
-	struct pci_dev		*dev = NULL;
-
-	while ((dev = pci_find_subsys(PCI_VENDOR_ID_INTEL, PCI_ANY_ID, 
-		PCI_ANY_ID, PCI_ANY_ID, dev))) {
-		switch (dev->device) {
-		case PCI_DEVICE_ID_INTEL_82801BA_8:	/* PIIX4U4 */
-		case PCI_DEVICE_ID_INTEL_82801BA_9:	/* PIIX4U3 */
-		case PCI_DEVICE_ID_INTEL_82451NX:	/* PIIX4NX */
-		case PCI_DEVICE_ID_INTEL_82372FB_1:	/* PIIX4U2 */
-		case PCI_DEVICE_ID_INTEL_82801AA_1:	/* PIIX4U */
-		case PCI_DEVICE_ID_INTEL_82443MX_1:	/* PIIX4E2 */
-		case PCI_DEVICE_ID_INTEL_82801AB_1:	/* PIIX4E */
-		case PCI_DEVICE_ID_INTEL_82371AB:	/* PIIX4 */
-			acpi_piix4_bmisx = pci_resource_start(dev, 4);
-			return;
-		}
-	}
-
-	return;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	pr_osl_init
- *
- * PARAMETERS:	<none>
- *
- * RETURN:	0: Success
- *
- * DESCRIPTION: Module initialization.
- *
- ****************************************************************************/
-
-static int __init
-pr_osl_init (void)
-{
-	acpi_status		status = AE_OK;
-
-	/* abort if no busmgr */
-	if (!bm_proc_root)
-		return -ENODEV;
-
-	acpi_pr_errata();
-
-	pr_proc_root = proc_mkdir(PR_PROC_ROOT, bm_proc_root);
-	if (!pr_proc_root) {
-		status = AE_ERROR;
-	}
-	else {
-		status = pr_initialize();
-		if (ACPI_FAILURE(status)) {
-			remove_proc_entry(PR_PROC_ROOT, bm_proc_root);
-		}
-
-	}
-
-	return (ACPI_SUCCESS(status)) ? 0 : -ENODEV;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    pr_osl_cleanup
- *
- * PARAMETERS:	<none>
- *
- * RETURN:	<none>
- *
- * DESCRIPTION: Module cleanup.
- *
- ****************************************************************************/
-
-static void __exit
-pr_osl_cleanup (void)
-{
-	pr_terminate();
-
-	if (pr_proc_root) {
-		remove_proc_entry(PR_PROC_ROOT, bm_proc_root);
-	}
-
-	return;
-}
-
-
-module_init(pr_osl_init);
-module_exit(pr_osl_cleanup);
diff -urNp linux-5400/drivers/acpi/ospm/processor/prperf.c linux-5410/drivers/acpi/ospm/processor/prperf.c
--- linux-5400/drivers/acpi/ospm/processor/prperf.c
+++ linux-5410/drivers/acpi/ospm/processor/prperf.c
@@ -1,456 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: prperf.c
- *              $Revision: 21 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-/*
- * TBD: 1. Support ACPI 2.0 processor performance states (not just throttling).
- *      2. Fully implement thermal -vs- power management limit control.
- */
-
-
-#include <acpi.h>
-#include <bm.h>
-#include "pr.h"
-
-#define _COMPONENT		ACPI_PROCESSOR
-	MODULE_NAME		("prperf")
-
-
-/****************************************************************************
- *                                  Globals
- ****************************************************************************/
-
-extern fadt_descriptor_rev2	acpi_fadt;
-const u32			POWER_OF_2[] = {1,2,4,8,16,32,64,128,256,512};
-
-
-/****************************************************************************
- *
- * FUNCTION:    pr_perf_get_frequency
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-pr_perf_get_frequency (
-	PR_CONTEXT		*processor,
-	u32			*frequency) {
-	acpi_status		status = AE_OK;
-
-	FUNCTION_TRACE("pr_perf_get_frequency");
-
-	if (!processor || !frequency) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/* TBD: Generic method to calculate processor frequency. */
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    pr_perf_get_state
- *
- * PARAMETERS:
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-/* TBD:	Include support for _real_ performance states (not just throttling). */
-
-acpi_status
-pr_perf_get_state (
-	PR_CONTEXT              *processor,
-	u32                     *state)
-{
-	u32                     pblk_value = 0;
-	u32                     duty_mask = 0;
-	u32                     duty_cycle = 0;
-
-	FUNCTION_TRACE("pr_perf_get_state");
-
-	if (!processor || !state) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	if (processor->performance.state_count == 1) {
-		*state = 0;
-		return_ACPI_STATUS(AE_OK);
-	}
-
-	acpi_os_read_port(processor->pblk.address, &pblk_value, 32);
-
-	/*
-	 * Throttling Enabled?
-	 * -------------------
-	 * If so, calculate the current throttling state, otherwise return
-	 * '100% performance' (state 0).
-	 */
-	if (pblk_value & 0x00000010) {
-
-		duty_mask = processor->performance.state_count - 1;
-		duty_mask <<= acpi_fadt.duty_offset;
-
-		duty_cycle = pblk_value & duty_mask;
-		duty_cycle >>= acpi_fadt.duty_offset;
-
-		if (duty_cycle == 0) {
-			*state = 0;
-		}
-		else {
-			*state = processor->performance.state_count -
-				duty_cycle;
-		}
-	}
-	else {
-		*state = 0;
-	}
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Processor [%02x] is at performance state [%d%%].\n", processor->device_handle, processor->performance.state[*state].performance));
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    pr_perf_set_state
- *
- * PARAMETERS:
- *
- * RETURN:      AE_OK
- *              AE_BAD_PARAMETER
- *              AE_BAD_DATA         Invalid target throttling state.
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-/* TBD: Includes support for _real_ performance states (not just throttling). */
-
-acpi_status
-pr_perf_set_state (
-	PR_CONTEXT              *processor,
-	u32                     state)
-{
-	u32                     pblk_value = 0;
-	u32                     duty_mask = 0;
-	u32                     duty_cycle = 0;
-	u32                     i = 0;
-
-	FUNCTION_TRACE ("pr_perf_set_state");
-
-	if (!processor) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	if (state > (processor->performance.state_count - 1)) {
-		return_ACPI_STATUS(AE_BAD_DATA);
-	}
-
-	if ((state == processor->performance.active_state) ||
-		(processor->performance.state_count == 1)) {
-		return_ACPI_STATUS(AE_OK);
-	}
-
-	/*
-	 * Calculate Duty Cycle/Mask:
-	 * --------------------------
-	 * Note that we don't support duty_cycle values that span bit 4.
-	 */
-	if (state) {
-		duty_cycle = processor->performance.state_count - state;
-		duty_cycle <<= acpi_fadt.duty_offset;
-	}
-	else {
-		duty_cycle = 0;
-	}
-
-	duty_mask = ~((u32)(processor->performance.state_count - 1));
-	for (i=0; i<acpi_fadt.duty_offset; i++) {
-		duty_mask <<= acpi_fadt.duty_offset;
-		duty_mask += 1;
-	}
-
-	/*
-	 * Disable Throttling:
-	 * -------------------
-	 * Got to turn it off before you can change the duty_cycle value.
-	 * Throttling is disabled by writing a 0 to bit 4.
-	 */
-	acpi_os_read_port(processor->pblk.address, &pblk_value, 32);
-	if (pblk_value & 0x00000010) {
-		pblk_value &= 0xFFFFFFEF;
-		acpi_os_write_port(processor->pblk.address, pblk_value, 32);
-	}
-
-	/*
-	 * Set Duty Cycle:
-	 * ---------------
-	 * Mask off the old duty_cycle value, mask in the new.
-	 */
-	pblk_value &= duty_mask;
-	pblk_value |= duty_cycle;
-	acpi_os_write_port(processor->pblk.address, pblk_value, 32);
-
-	/*
-	 * Enable Throttling:
-	 * ------------------
-	 * But only for non-zero (non-100% performance) states.
-	 */
-	if (state) {
-		pblk_value |= 0x00000010;
-		acpi_os_write_port(processor->pblk.address, pblk_value, 32);
-	}
-
-	processor->performance.active_state = state;
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Processor [%02x] set to performance state [%d%%].\n", processor->device_handle, processor->performance.state[state].performance));
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    pr_perf_set_limit
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-pr_perf_set_limit (
-	PR_CONTEXT              *processor,
-	u32                     limit)
-{
-	acpi_status		status = AE_OK;
-	PR_PERFORMANCE		*performance = NULL;
-
-	FUNCTION_TRACE ("pr_perf_set_limit");
-
-	if (!processor) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	performance = &(processor->performance);
-
-	/*
-	 * Set Limit:
-	 * ----------
-	 * TBD:  Properly manage thermal and power limits (only set
-	 *	 performance state iff...).
-	 */
-	switch (limit) {
-
-	case PR_PERF_DEC:
-		if (performance->active_state <
-			(performance->state_count-1)) {
-			status = pr_perf_set_state(processor,
-				(performance->active_state+1));
-		}
-		break;
-
-	case PR_PERF_INC:
-		if (performance->active_state > 0) {
-			status = pr_perf_set_state(processor,
-				(performance->active_state-1));
-		}
-		break;
-
-	case PR_PERF_MAX:
-		if (performance->active_state != 0) {
-			status = pr_perf_set_state(processor, 0);
-		}
-		break;
-
-	default:
-		return_ACPI_STATUS(AE_BAD_DATA);
-		break;
-	}
-
-	if (ACPI_SUCCESS(status)) {
-		performance->thermal_limit = performance->active_state;
-	}
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Processor [%02x] thermal performance limit set to [%d%%].\n", processor->device_handle, processor->performance.state[performance->active_state].performance));
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *                             External Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:    pr_perf_add_device
- *
- * PARAMETERS:  processor		Our processor-specific context.
- *
- * RETURN:      AE_OK
- *              AE_BAD_PARAMETER
- *
- * DESCRIPTION: Calculates the number of throttling states and the state
- *              performance/power values.
- *
- ****************************************************************************/
-
-/* TBD: Support duty_cycle values that span bit 4. */
-
-acpi_status
-pr_perf_add_device (
-	PR_CONTEXT              *processor)
-{
-	acpi_status             status = AE_OK;
-	u32                     i = 0;
-	u32                     performance_step = 0;
-	u32                     percentage = 0;
-
-	FUNCTION_TRACE("pr_perf_add_device");
-
-	if (!processor) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * Valid PBLK?
-	 * -----------
-	 * For SMP it is common to have the first (boot) processor have a
-	 * valid PBLK while all others do not -- which implies that
-	 * throttling has system-wide effects (duty_cycle programmed into
-	 * the chipset effects all processors).
-	 */
-	if ((processor->pblk.length < 6) || !processor->pblk.address) {
-		processor->performance.state_count = 1;
-	}
-
-	/*
-	 * Valid Duty Offset/Width?
-	 * ------------------------
-	 * We currently only support duty_cycle values that fall within
-	 * bits 0-3, as things get complicated when this value spans bit 4
-	 * (the throttling enable/disable bit).
-	 */
-	else if ((acpi_fadt.duty_offset + acpi_fadt.duty_width) > 4) {
-		processor->performance.state_count = 1;
-	}
-
-	/*
-	 * Compute State Count:
-	 * --------------------
-	 * The number of throttling states is computed as 2^duty_width,
-	 * but limited by PR_MAX_THROTTLE_STATES.  Note that a duty_width
-	 * of zero results is one throttling state (100%).
-	 */
-	else {
-		processor->performance.state_count =
-			POWER_OF_2[acpi_fadt.duty_width];
-	}
-
-	if (processor->performance.state_count > PR_MAX_THROTTLE_STATES) {
-		processor->performance.state_count = PR_MAX_THROTTLE_STATES;
-	}
-
-	/*
-	 * Compute State Values:
-	 * ---------------------
-	 * Note that clock throttling displays a linear power/performance
-	 * relationship (at 50% performance the CPU will consume 50% power).
-	 */
-	performance_step = (1000 / processor->performance.state_count);
-
-	for (i=0; i<processor->performance.state_count; i++) {
-		percentage = (1000 - (performance_step * i))/10;
-		processor->performance.state[i].performance = percentage;
-		processor->performance.state[i].power = percentage;
-	}
-
-	/*
-	 * Get Current State:
-	 * ------------------
-	 */
-	status = pr_perf_get_state(processor, &(processor->performance.active_state));
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Set to Maximum Performance:
-	 * ---------------------------
-	 * We'll let subsequent policy (e.g. thermal/power) decide to lower
-	 * performance if it so chooses, but for now crank up the speed.
-	 */
-	if (0 != processor->performance.active_state) {
-		status = pr_perf_set_state(processor, 0);
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    pr_perf_remove_device
- *
- * PARAMETERS:
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-pr_perf_remove_device (
-	PR_CONTEXT              *processor)
-{
-	acpi_status             status = AE_OK;
-
-	FUNCTION_TRACE("pr_perf_remove_device");
-
-	if (!processor) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	MEMSET(&(processor->performance), 0, sizeof(PR_PERFORMANCE));
-
-	return_ACPI_STATUS(status);
-}
-
diff -urNp linux-5400/drivers/acpi/ospm/processor/prpower.c linux-5410/drivers/acpi/ospm/processor/prpower.c
--- linux-5400/drivers/acpi/ospm/processor/prpower.c
+++ linux-5410/drivers/acpi/ospm/processor/prpower.c
@@ -1,665 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: prpower.c
- *   $Revision: 32 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-/* TBD: Linux specific */
-#include <linux/sched.h>
-#include <linux/pm.h>
-#include <asm/io.h>
-
-#include <acpi.h>
-#include <bm.h>
-#include "pr.h"
-
-#define _COMPONENT		ACPI_PROCESSOR
-	MODULE_NAME		("prpower")
-
-
-/****************************************************************************
- *                                  Globals
- ****************************************************************************/
-
-extern FADT_DESCRIPTOR		acpi_fadt;
-static u32			last_idle_jiffies = 0;
-static PR_CONTEXT		*processor_list[NR_CPUS];
-static void			(*pr_pm_idle_save)(void) = NULL;
-static u8			bm_control = 0;
-
-
-/* Used for PIIX4 errata handling. */
-unsigned short			acpi_piix4_bmisx = 0;
-
-
-/****************************************************************************
- *                             External Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:    pr_power_activate_state
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-void
-pr_power_activate_state (
-	PR_CONTEXT		*processor,
-	u32			next_state)
-{
-
-	PROC_NAME("pr_power_activate_state");
-
-	if (!processor) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid (NULL) context.\n"));
-		return;
-	}
-
-	processor->power.state[processor->power.active_state].promotion.count = 0;
-	processor->power.state[processor->power.active_state].demotion.count = 0;
-
-	/*
-	 * Cleanup from old state.
-	 */
-	switch (processor->power.active_state) {
-
-	case PR_C3:
-		/* Disable bus master reload */
-		acpi_hw_register_bit_access(ACPI_WRITE, ACPI_MTX_DO_NOT_LOCK,
-			BM_RLD, 0);
-		break;
-	}
-
-	/*
-	 * Prepare to use new state.
-	 */
-	switch (next_state) {
-
-	case PR_C3:
-		/* Enable bus master reload */
-		acpi_hw_register_bit_access(ACPI_WRITE, ACPI_MTX_DO_NOT_LOCK,
-			BM_RLD, 1);
-		break;
-	}
-
-	processor->power.active_state = next_state;
-	
-	return;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    pr_power_idle
- *
- * PARAMETERS:  <none>
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-void
-pr_power_idle (void)
-{
-	PR_CX			*c_state = NULL;
-	u32			next_state = 0;
-	u32			start_ticks, end_ticks, time_elapsed;
-	PR_CONTEXT		*processor = NULL;
-
-	PROC_NAME("pr_power_idle");
-
-	processor = processor_list[smp_processor_id()];
-
-	if (!processor || processor->power.active_state == PR_C0) {
-		return;
-	}
-
-	next_state = processor->power.active_state;
-
-	/*
-	 * Check OS Idleness:
-	 * ------------------
-	 * If the OS has been busy (hasn't called the idle handler in a while)
-	 * then automatically demote to the default power state (e.g. C1).
-	 *
-	 * TBD: Optimize by having scheduler determine business instead
-	 *      of having us try to calculate it.
-	 */
-	if (processor->power.active_state != processor->power.default_state) {
-		if ((jiffies - last_idle_jiffies) >= processor->power.busy_metric) {
-			next_state = processor->power.default_state;
-			if (next_state != processor->power.active_state) {
-				pr_power_activate_state(processor, next_state);
-			}
-		}
-	}
-
-	disable();
-
-	/*
-	 * Log BM Activity:
-	 * ----------------
-	 * Read BM_STS and record its value for later use by C3 policy.
-	 * (Note that we save the BM_STS values for the last 32 cycles).
-	 */
-	if (bm_control) {
-		processor->power.bm_activity <<= 1;
-		if (acpi_hw_register_bit_access(ACPI_READ, ACPI_MTX_DO_NOT_LOCK, BM_STS)) {
-			processor->power.bm_activity |= 1;
-			acpi_hw_register_bit_access(ACPI_WRITE, ACPI_MTX_DO_NOT_LOCK,
-				BM_STS, 1);
-		}
-		else if (acpi_piix4_bmisx) {
-			/*
-			 * PIIX4 Errata:
-			 * -------------
-			 * This code is a workaround for errata #18 "C3 Power State/
-			 * BMIDE and Type-F DMA Livelock" from the July '01 PIIX4
-			 * specification update.  Note that BM_STS doesn't always
-			 * reflect the true state of bus mastering activity; forcing
-			 * us to manually check the BMIDEA bit of each IDE channel.
-			 */
-			if ((inb_p(acpi_piix4_bmisx + 0x02) & 0x01) ||
-				(inb_p(acpi_piix4_bmisx + 0x0A) & 0x01))
-				processor->power.bm_activity |= 1;
-		}
-	}
-
-	c_state = &(processor->power.state[processor->power.active_state]);
-
-	c_state->utilization++;
-
-	/*
-	 * Sleep:
-	 * ------
-	 * Invoke the current Cx state to put the processor to sleep.
-	 */
-	switch (processor->power.active_state) {
-
-	case PR_C1:
-		/* Invoke C1 */
-		enable(); halt();
-		/*
-	 * TBD: Can't get time duration while in C1, as resumes
-		 *      go to an ISR rather than here.
-		 */
-		time_elapsed = 0xFFFFFFFF;
-		break;
-
-	case PR_C2:
-		/* See how long we're asleep for */
-		acpi_get_timer(&start_ticks);
-		/* Invoke C2 */
-		acpi_os_read_port(processor->power.p_lvl2, NULL, 8);
-		/* Dummy op - must do something useless after P_LVL2 read */
-		acpi_hw_register_bit_access(ACPI_READ, ACPI_MTX_DO_NOT_LOCK, BM_STS);
-		/* Compute time elapsed */
-		acpi_get_timer(&end_ticks);
-		/* Re-enable interrupts */
-		enable();
-		acpi_get_timer_duration(start_ticks, end_ticks, &time_elapsed);
-		break;
-
-	case PR_C3:
-		/* Disable bus master arbitration */
-		acpi_hw_register_bit_access(ACPI_WRITE, ACPI_MTX_DO_NOT_LOCK, ARB_DIS, 1);
-		/* See how long we're asleep for */
-		acpi_get_timer(&start_ticks);
-		/* Invoke C3 */
-		acpi_os_read_port(processor->power.p_lvl3, NULL, 8);
-		/* Dummy op - must do something useless after P_LVL3 read */
-		acpi_hw_register_bit_access(ACPI_READ, ACPI_MTX_DO_NOT_LOCK, BM_STS);
-		/* Compute time elapsed */
-		acpi_get_timer(&end_ticks);
-		/* Enable bus master arbitration */
-		acpi_hw_register_bit_access(ACPI_WRITE, ACPI_MTX_DO_NOT_LOCK,
-			ARB_DIS, 0);
-		/* Re-enable interrupts */
-		enable();
-		acpi_get_timer_duration(start_ticks, end_ticks, &time_elapsed);
-		break;
-
-	default:
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Attempt to use unsupported power state C%d.\n", processor->power.active_state));
-		enable();
-		break;
-	}
-
-	/*
-	 * Promotion?
-	 * ----------
-	 * Track the number of successful sleeps (time asleep is greater
-	 * than time_threshold) and promote when count_threshold is
-	 * reached.
-	 */
-	if ((c_state->promotion.target_state) && 	
-		(time_elapsed >= c_state->promotion.time_threshold)) {
-
-		c_state->promotion.count++;
- 		c_state->demotion.count = 0;
-
-		if (c_state->promotion.count >= c_state->promotion.count_threshold) {
-			/*
-			 * Bus Mastering Activity, if active and used
-			 * by this state's promotion policy, prevents
-			 * promotions from occuring.
-			 */
-			if (!bm_control || !(processor->power.bm_activity & c_state->promotion.bm_threshold))
-				next_state = c_state->promotion.target_state;
-		}
-	}
-
-	/*
-	 * Demotion?
-	 * ---------
-	 * Track the number of shorts (time asleep is less than
-	 * time_threshold) and demote when count_threshold is reached.
-	 */
-	if (c_state->demotion.target_state) {
-			
-		if (time_elapsed < c_state->demotion.time_threshold) {
-
-			c_state->demotion.count++;
-			c_state->promotion.count = 0;
-
-			if (c_state->demotion.count >=
-				c_state->demotion.count_threshold) {
-				next_state = c_state->demotion.target_state;
-			}
-		}
-
-		/*
-		 * Bus Mastering Activity, if active and used by this
-		 * state's promotion policy, causes an immediate demotion
-		 * to occur.
-		 */
-		if (bm_control && (processor->power.bm_activity & c_state->demotion.bm_threshold))
-			next_state = c_state->demotion.target_state;
-	}
-
-	/*
-	 * New Cx State?
-	 * -------------
-	 * If we're going to start using a new Cx state we must clean up
-	 * from the previous and prepare to use the new.
-	 */
-	if (next_state != processor->power.active_state) {
-		pr_power_activate_state(processor, next_state);
-		processor->power.active_state = processor->power.active_state;
-	}
-
-	/*
-	 * Track OS Idleness:
-	 * ------------------
-	 * Record a jiffies timestamp to compute time elapsed between calls
-	 * to the idle handler.
-	 */
-	last_idle_jiffies = jiffies;
-
-	return;
-}
-
-
-/*****************************************************************************
- *
- * FUNCTION:    pr_power_set_default_policy
- *
- * PARAMETERS:
- *
- * RETURN:	
- *
- * DESCRIPTION: Sets the default Cx state policy (OS idle handler).  Our
- *              scheme is to promote quickly to C2 but more conservatively
- *              to C3.  We're favoring C2 for its characteristics of low
- *              latency (quick response), good power savings, and ability
- *              to allow bus mastering activity.
- *
- *              Note that Cx state policy is completely customizable, with
- *              the goal of having heuristics to alter policy dynamically.
- *
- ****************************************************************************/
-
-acpi_status
-pr_power_set_default_policy (
-	PR_CONTEXT                 *processor)
-{
-	FUNCTION_TRACE("pr_power_set_default_policy");
-
-	if (!processor) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * Busy Metric:
-	 * ------------
-	 * Used to determine when the OS has been busy and thus when
-	 * policy should return to using the default Cx state (e.g. C1).
-	 * On Linux we use the number of jiffies (scheduler quantums)
-	 * that transpire between calls to the idle handler.
-	 *
-	 * TBD: Linux-specific.
-	 */
-	processor->power.busy_metric = 2;
-
-	/*
-	 * C1:
-	 * ---
-	 * C1 serves as our default state.  It must be valid.
-	 */
-	if (processor->power.state[PR_C1].is_valid) {
-		processor->power.active_state =
-			processor->power.default_state = PR_C1;
-	}
-	else {
-		processor->power.active_state =
-			processor->power.default_state = PR_C0;
-		return_ACPI_STATUS(AE_OK);
-	}
-
-	/*
-	 * C2:
-	 * ---
-	 * Set default C1 promotion and C2 demotion policies.
-	 */
-	if (processor->power.state[PR_C2].is_valid) {
-		/*
-		 * Promote from C1 to C2 anytime we're asleep in C1 for
-		 * longer than two times the C2 latency (to amortize cost
-		 * of transition).  Demote from C2 to C1 anytime we're
-		 * asleep in C2 for less than this time.
-		 */
-		processor->power.state[PR_C1].promotion.count_threshold = 10;
-		processor->power.state[PR_C1].promotion.time_threshold =
-			2 * processor->power.state[PR_C2].latency;
-		processor->power.state[PR_C1].promotion.target_state = PR_C2;
-
-		processor->power.state[PR_C2].demotion.count_threshold = 1;
-		processor->power.state[PR_C2].demotion.time_threshold =
-			2 * processor->power.state[PR_C2].latency;
-		processor->power.state[PR_C2].demotion.target_state = PR_C1;
-	}
-
-	/*
-	 * C3:
-	 * ---
-	 * Set default C2 promotion and C3 demotion policies.
-	 */
-	if ((processor->power.state[PR_C2].is_valid) &&
-		(processor->power.state[PR_C3].is_valid)) {
-		/*
-		 * Promote from C2 to C3 after 4 cycles of no bus
-		 * mastering activity (while maintaining sleep time
-		 * criteria).  Demote immediately on a short or
-		 * whenever bus mastering activity occurs.
-		 */
-		processor->power.state[PR_C2].promotion.count_threshold = 1;
-		processor->power.state[PR_C2].promotion.time_threshold =
-			2 * processor->power.state[PR_C3].latency;
-		processor->power.state[PR_C2].promotion.bm_threshold =
-			0x0000000F;
-		processor->power.state[PR_C2].promotion.target_state =
-			PR_C3;
-
-		processor->power.state[PR_C3].demotion.count_threshold = 1;
-		processor->power.state[PR_C3].demotion.time_threshold =
-			2 * processor->power.state[PR_C3].latency;
-		processor->power.state[PR_C3].demotion.bm_threshold =
-			0x0000000F;
-		processor->power.state[PR_C3].demotion.target_state =
-			PR_C2;
-	}
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-/*****************************************************************************
- *
- * FUNCTION:    pr_power_add_device
- *
- * PARAMETERS:  <none>
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-/*
- * TBD: 1. PROC_C1 support.
- *      2. Symmetric Cx state support (different Cx states supported
- *         by different CPUs results in lowest common denominator).
- */
-
-acpi_status
-pr_power_add_device (
-	PR_CONTEXT                 *processor)
-{
-	FUNCTION_TRACE("pr_power_add_device");
-
-	if (!processor) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * State Count:
-	 * ------------
-	 * Fixed at four (C0-C3).  We use is_valid to determine whether or
-	 * not a state actually gets used.
-	 */
-	processor->power.state_count = PR_MAX_POWER_STATES;
-
-	/*
-	 * C0:
-	 * ---
-	 * C0 exists only as filler in our array. (Let's assume its valid!)
-	 */
-	processor->power.state[PR_C0].is_valid = TRUE;
-
-	/*
-	 * C1:
-	 * ---
-	 * ACPI states that C1 must be supported by all processors
-	 * with a latency so small that it can be ignored.
-	 *
-	 * TBD: What about PROC_C1 support?
-	 */
-	processor->power.state[PR_C1].is_valid = TRUE;
-
-	/*
-	 * C2:
-	 * ---
-	 * We're only supporting C2 on UP systems with latencies <= 100us.
-	 *
-	 * TBD: Support for C2 on MP (P_LVL2_UP) -- I'm taking the
-	 *      conservative approach for now.
-	 */
-	processor->power.state[PR_C2].latency = acpi_fadt.plvl2_lat;
-
-#ifdef CONFIG_SMP
-	if (smp_num_cpus == 1) {
-#endif /*CONFIG_SMP*/
-		if (acpi_fadt.plvl2_lat <= PR_MAX_C2_LATENCY) {
-			processor->power.state[PR_C2].is_valid = TRUE;
-			processor->power.p_lvl2 = processor->pblk.address + 4;
-		}
-#ifdef CONFIG_SMP
-	}
-#endif /*CONFIG_SMP*/
-
-
-	/*
-	 * C3:
-	 * ---
-	 * We're only supporting C3 on UP systems with latencies <= 1000us,
-	 * and that include the ability to disable bus mastering while in
-	 * C3 (ARB_DIS) but allows bus mastering requests to wake the system
-	 * from C3 (BM_RLD).  Note his method of maintaining cache coherency
-	 * (disabling of bus mastering) cannot be used on SMP systems, and
-	 * flushing caches (e.g. WBINVD) is simply too costly at this time.
-	 *
-	 * TBD: Support for C3 on MP -- I'm taking the conservative
-	 *      approach for now.
-	 */
-	processor->power.state[PR_C3].latency = acpi_fadt.plvl3_lat;
-
-#ifdef CONFIG_SMP
-	if (smp_num_cpus == 1) {
-#endif /*CONFIG_SMP*/
-		if ((acpi_fadt.plvl3_lat <= PR_MAX_C3_LATENCY) && bm_control) {
-			processor->power.state[PR_C3].is_valid = TRUE;
-			processor->power.p_lvl3 = processor->pblk.address + 5;
-		}
-#ifdef CONFIG_SMP
-	}
-#endif /*CONFIG_SMP*/
-
-	/*
-	 * Set Default Policy:
-	 * -------------------
-	 * Now that we know which state are supported, set the default
-	 * policy.  Note that this policy can be changed dynamically
-	 * (e.g. encourage deeper sleeps to conserve battery life when
-	 * not on AC).
-	 */
-	pr_power_set_default_policy(processor);
-
-	/*
-	 * Save Processor Context:
-	 * -----------------------
-	 * TBD: Enhance Linux idle handler to take processor context
-	 *      parameter.
-	 */
-	processor_list[processor->uid] = processor;
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    pr_power_remove_device
- *
- * PARAMETERS:
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-pr_power_remove_device (
-	PR_CONTEXT              *processor)
-{
-	acpi_status             status = AE_OK;
-
-	FUNCTION_TRACE("pr_power_remove_device");
-
-	if (!processor) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	MEMSET(&(processor->power), 0, sizeof(PR_POWER));
-
-	processor_list[processor->uid] = NULL;
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    pr_power_initialize
- *
- * PARAMETERS:  <none>
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-pr_power_initialize (void)
-{
-	u32			i = 0;
-
-	FUNCTION_TRACE("pr_power_initialize");
-
-	/* TBD: Linux-specific. */
-	for (i=0; i<NR_CPUS; i++) {
-		processor_list[i] = NULL;
-	}
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Max CPUs[%d], this CPU[%d].\n", NR_CPUS, smp_processor_id()));
-
-	/* Only use C3 if we can control bus mastering. */
-	if (acpi_fadt.V1_pm2_cnt_blk && acpi_fadt.pm2_cnt_len)
-		bm_control = 1;
-
-	/*
-	 * Install idle handler.
-	 *
-	 * TBD: Linux-specific (need OSL function).
-	 */
-	pr_pm_idle_save = pm_idle;
-	pm_idle = pr_power_idle;
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    pr_power_terminate
- *
- * PARAMETERS:  <none>
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-pr_power_terminate (void)
-{
-	FUNCTION_TRACE("pr_power_terminate");
-
-	/*
-	 * Remove idle handler.
-	 *
-	 * TBD: Linux-specific (need OSL function).
-	 */
-	pm_idle = pr_pm_idle_save;
-
-	return_ACPI_STATUS(AE_OK);
-}
diff -urNp linux-5400/drivers/acpi/ospm/system/Makefile linux-5410/drivers/acpi/ospm/system/Makefile
--- linux-5400/drivers/acpi/ospm/system/Makefile
+++ linux-5410/drivers/acpi/ospm/system/Makefile
@@ -1,6 +0,0 @@
-O_TARGET	:= ospm_$(notdir $(CURDIR)).o
-obj-m		:= $(O_TARGET)
-EXTRA_CFLAGS	+= $(ACPI_CFLAGS)
-obj-y		:= $(patsubst %.c,%.o,$(wildcard *.c))
-
-include $(TOPDIR)/Rules.make
diff -urNp linux-5400/drivers/acpi/ospm/system/sm.c linux-5410/drivers/acpi/ospm/system/sm.c
--- linux-5400/drivers/acpi/ospm/system/sm.c
+++ linux-5410/drivers/acpi/ospm/system/sm.c
@@ -1,373 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: sm.c
- *   $Revision: 20 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include <acpi.h>
-#include "sm.h"
-
-
-#define _COMPONENT		ACPI_SYSTEM
-	MODULE_NAME 		("sm")
-
-
-/****************************************************************************
- *                            Internal Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:	sm_print
- *
- * PARAMETERS:	
- *
- * RETURN:	
- *
- * DESCRIPTION: Prints out information on a specific system.
- *
- ****************************************************************************/
-
-void
-sm_print (
-	SM_CONTEXT		*system)
-{
-#ifdef ACPI_DEBUG
-	acpi_buffer		buffer;
-
-	PROC_NAME("sm_print");
-
-	buffer.length = 256;
-	buffer.pointer = acpi_os_callocate(buffer.length);
-	if (!buffer.pointer) {
-		return;
-	}
-
-	/*
-	 * Get the full pathname for this ACPI object.
-	 */
-	acpi_get_name(system->acpi_handle, ACPI_FULL_PATHNAME, &buffer);
-
-	/*
-	 * Print out basic system information.
-	 */
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "+------------------------------------------------------------\n"));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "| System[%02x]:[%p] %s\n", system->device_handle, system->acpi_handle, (char*)buffer.pointer));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "|   states: %cS0 %cS1 %cS2 %cS3 %cS4 %cS5\n", (system->states[0]?'+':'-'), (system->states[1]?'+':'-'), (system->states[2]?'+':'-'), (system->states[3]?'+':'-'), (system->states[4]?'+':'-'), (system->states[5]?'+':'-')));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "+------------------------------------------------------------\n"));
-
-	acpi_os_free(buffer.pointer);
-#endif /*ACPI_DEBUG*/
-
-	return;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	sm_add_device
- *
- * PARAMETERS:	
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-sm_add_device(
-	BM_HANDLE		device_handle,
-	void			**context)
-{
-	acpi_status 		status = AE_OK;
-	BM_DEVICE		*device = NULL;
-	SM_CONTEXT		*system = NULL;
-	u8			i, type_a, type_b;
-
-
-	FUNCTION_TRACE("sm_add_device");
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Adding system device [%02x].\n", device_handle));
-
-	if (!context || *context) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid (NULL) context."));
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * Allocate a new SM_CONTEXT structure.
-	 */
-	system = acpi_os_callocate(sizeof(SM_CONTEXT));
-	if (!system) {
-		return_ACPI_STATUS(AE_NO_MEMORY);
-	}
-
-	/*
-	 * Get information on this device.
-	 */
-	status = bm_get_device_info(device_handle, &device);
-	if (ACPI_FAILURE(status)) {
-		goto end;
-	}
-
-	system->device_handle = device->handle;
-	system->acpi_handle = device->acpi_handle;
-
-	/*
-	 * Sx States:
-	 * ----------
-	 * Figure out which Sx states are supported.
-	 */
-	for (i=0; i<SM_MAX_SYSTEM_STATES; i++) {
-		if (ACPI_SUCCESS(acpi_hw_obtain_sleep_type_register_data(
-			i,
-			&type_a,
-			&type_b))) {
-			system->states[i] = TRUE;
-		}
-	}
-
-	status = sm_osl_add_device(system);
-	if (ACPI_FAILURE(status)) {
-		goto end;
-	}
-
-	*context = system;
-
-	sm_print(system);
-
-end:
-	if (ACPI_FAILURE(status)) {
-		acpi_os_free(system);
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	sm_remove_device
- *
- * PARAMETERS:	
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-sm_remove_device (
-	void			**context)
-{
-	acpi_status 		status = AE_OK;
-	SM_CONTEXT		*system = NULL;
-
-	FUNCTION_TRACE("sm_remove_device");
-
-	if (!context || !*context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	system = (SM_CONTEXT*)*context;
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Removing system device [%02x].\n", system->device_handle));
-
-	status = sm_osl_remove_device(system);
-
-	acpi_os_free(system);
-
-	*context = NULL;
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *                             External Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:	sm_initialize
- *
- * PARAMETERS:	<none>
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-sm_initialize (void)
-{
-	acpi_status		status = AE_OK;
-	BM_DEVICE_ID		criteria;
-	BM_DRIVER		driver;
-
-	FUNCTION_TRACE("sm_initialize");
-
-	MEMSET(&criteria, 0, sizeof(BM_DEVICE_ID));
-	MEMSET(&driver, 0, sizeof(BM_DRIVER));
-
-	/*
-	 * Register driver for the System device.
-	 */
-	criteria.type = BM_TYPE_SYSTEM;
-
-	driver.notify = &sm_notify;
-	driver.request = &sm_request;
-
-	status = bm_register_driver(&criteria, &driver);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	sm_terminate
- *
- * PARAMETERS:	<none>
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-sm_terminate (void)
-{
-	acpi_status 		status = AE_OK;
-	BM_DEVICE_ID		criteria;
-	BM_DRIVER		driver;
-
-	FUNCTION_TRACE("sm_terminate");
-
-	MEMSET(&criteria, 0, sizeof(BM_DEVICE_ID));
-	MEMSET(&driver, 0, sizeof(BM_DRIVER));
-
-	/*
-	 * Unregister driver for System devices.
-	 */
-	criteria.type = BM_TYPE_SYSTEM;
-
-	driver.notify = &sm_notify;
-	driver.request = &sm_request;
-
-	status = bm_unregister_driver(&criteria, &driver);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/*****************************************************************************
- *
- * FUNCTION:	sm_notify
- *
- * PARAMETERS:	<none>
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-acpi_status
-sm_notify (
-	BM_NOTIFY		notify_type,
-	BM_HANDLE		device_handle,
-	void			**context)
-{
-	acpi_status 		status = AE_OK;
-
-	FUNCTION_TRACE("sm_notify");
-
-	if (!context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	switch (notify_type) {
-
-	case BM_NOTIFY_DEVICE_ADDED:
-		status = sm_add_device(device_handle, context);
-		break;
-
-	case BM_NOTIFY_DEVICE_REMOVED:
-		status = sm_remove_device(context);
-		break;
-
-	default:
-		status = AE_SUPPORT;
-		break;
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	sm_request
- *
- * PARAMETERS:	
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-sm_request (
-	BM_REQUEST		*request,
-	void			*context)
-{
-	acpi_status 		status = AE_OK;
-
-	FUNCTION_TRACE("sm_request");
-
-	/*
-	 * Must have a valid request structure and context.
-	 */
-	if (!request || !context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * Handle Request:
-	 * ---------------
-	 */
-	switch (request->command) {
-
-	default:
-		status = AE_SUPPORT;
-		break;
-	}
-
-	request->status = status;
-
-	return_ACPI_STATUS(status);
-}
diff -urNp linux-5400/drivers/acpi/ospm/system/sm_osl.c linux-5410/drivers/acpi/ospm/system/sm_osl.c
--- linux-5400/drivers/acpi/ospm/system/sm_osl.c
+++ linux-5410/drivers/acpi/ospm/system/sm_osl.c
@@ -1,922 +0,0 @@
-/******************************************************************************
- *
- * Module Name: sm_osl.c
- *   $Revision: 16 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/proc_fs.h>
-#include <linux/pm.h>
-#include <asm/uaccess.h>
-#include <linux/acpi.h>
-#include <asm/io.h>
-#include <linux/mc146818rtc.h>
-#include <linux/delay.h>
-
-#include <acpi.h>
-#include "sm.h"
-
-
-MODULE_AUTHOR("Andrew Grover");
-MODULE_DESCRIPTION("ACPI Component Architecture (CA) - ACPI System Driver");
-MODULE_LICENSE("GPL");
-
-
-#define SM_PROC_INFO		"info"
-#define SM_PROC_DSDT		"dsdt"
-
-extern struct proc_dir_entry	*bm_proc_root;
-struct proc_dir_entry		*sm_proc_root = NULL;
-static void 			(*sm_pm_power_off)(void) = NULL;
-
-static ssize_t sm_osl_read_dsdt(struct file *, char *, size_t, loff_t *);
-
-static struct file_operations proc_dsdt_operations = {
-	read:		sm_osl_read_dsdt,
-};
-
-static acpi_status sm_osl_suspend(u32 state);
-
-struct proc_dir_entry *bm_proc_sleep;
-struct proc_dir_entry *bm_proc_alarm;
-struct proc_dir_entry *bm_proc_gpe;
-
-static int
-sm_osl_proc_read_sleep (
-        char                    *page,
-        char                    **start,
-        off_t                   off,
-        int                     count,
-        int                     *eof,
-        void                    *context)
-{
-	SM_CONTEXT    *system = (SM_CONTEXT*) context;
-	char          *str = page;
-	int           len;
-	int           i;
-
-	if (!system)
-               goto end;
-
-	if (off != 0)
-               goto end;
-
-	for (i = 0; i <= ACPI_S5; i++) {
-		if (system->states[i])
-			str += sprintf(str,"S%d ", i);
-	}
-
-	str += sprintf(str, "\n");
-
-end:
-
-	len = (str - page);
-	if (len < (off + count))
-		*eof = 1;
-
-	*start = page + off;
-	len -= off;
-
-	if (len > count)
-		len = count;
-
-	if (len < 0)
-		len = 0;
-
-	return (len);
-}
-
-int sm_osl_proc_write_sleep (struct file *file,
-			     const char *buffer,
-			     unsigned long count,
-			     void *data)
-{
-	SM_CONTEXT    *system = (SM_CONTEXT*) data;
-	char          str[10];
-	char          *strend;
-	unsigned long value;
-	
-	if (count > (sizeof(str) - 1))
-		return -EINVAL;
-	
-	if (copy_from_user(str,buffer,count))
-		return -EFAULT;
-	
-	str[count] = '\0';
-	
-	value = simple_strtoul(str,&strend,0);
-	if (str == strend)
-		return -EINVAL;
-	
-	if (value == 0 || value >= ACPI_S5)
-		return -EINVAL;
-	
-	/*
-	 * make sure that the sleep state is supported
-	 */
-	if (system->states[value] != TRUE)
-		return -EINVAL;
-	
-	sm_osl_suspend(value);
-	
-	return (count);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	sm_osl_proc_read_info
- *
- ****************************************************************************/
-
-static int
-sm_osl_proc_read_info (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*context)
-{
-	acpi_status		status = AE_OK;
-	SM_CONTEXT		*system = NULL;
-	char			*p = page;
-	int			len;
-	acpi_system_info	system_info;
-	acpi_buffer		buffer;
-	u32			i = 0;
-
-	if (!context) {
-		goto end;
-	}
-
-	system = (SM_CONTEXT*) context;
-
-	/* don't get status more than once for a single proc read */
-	if (off != 0) {
-		goto end;
-	}
-
-	/*
-	 * Get ACPI CA Information.
-	 */
-	buffer.length  = sizeof(system_info);
-	buffer.pointer = &system_info;
-
-	status = acpi_get_system_info(&buffer);
-	if (ACPI_FAILURE(status)) {
-		p += sprintf(p, "ACPI-CA Version:         unknown\n");
-	}
-	else {
-		p += sprintf(p, "ACPI-CA Version:         %x\n",
-			system_info.acpi_ca_version);
-	}
-
-	p += sprintf(p, "Sx States Supported:     ");
-	for (i=0; i<SM_MAX_SYSTEM_STATES; i++) {
-		if (system->states[i]) {
-			p += sprintf(p, "S%d ", i);
-		}
-	}
-	p += sprintf(p, "\n");
-
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return(len);
-}
-
-/****************************************************************************
- *
- * FUNCTION:	sm_osl_read_dsdt
- *
- ****************************************************************************/
-
-static ssize_t
-sm_osl_read_dsdt(
-	struct file		*file,
-	char			*buf,
-	size_t			count,
-	loff_t			*ppos)
-{
-	acpi_buffer		acpi_buf;
-	void			*data;
-	size_t			size = 0;
-
-	acpi_buf.length = 0;
-	acpi_buf.pointer = NULL;
-
-
-	/* determine what buffer size we will need */
-	if (acpi_get_table(ACPI_TABLE_DSDT, 1, &acpi_buf) != AE_BUFFER_OVERFLOW) {
-		return 0;
-	}
-
-	acpi_buf.pointer = kmalloc(acpi_buf.length, GFP_KERNEL);
-	if (!acpi_buf.pointer) {
-		return -ENOMEM;
-	}
-
-	/* get the table for real */
-	if (!ACPI_SUCCESS(acpi_get_table(ACPI_TABLE_DSDT, 1, &acpi_buf))) {
-		kfree(acpi_buf.pointer);
-		return 0;
-	}
-
-	if (*ppos < acpi_buf.length) {
-		data = acpi_buf.pointer + file->f_pos;
-		size = acpi_buf.length - file->f_pos;
-		if (size > count)
-			size = count;
-		if (copy_to_user(buf, data, size)) {
-			kfree(acpi_buf.pointer);
-			return -EFAULT;
-		}
-	}
-
-	kfree(acpi_buf.pointer);
-
-	*ppos += size;
-
-	return size;
-}
-
-static int
-sm_osl_proc_read_alarm (
-	char                    *page,
-	char                    **start,
-	off_t                   off,
-	int                     count,
-	int                     *eof,
-	void                    *context)
-{
-	char *str = page;
-	int len;
-	u32 sec,min,hr;
-	u32 day,mo,yr;
-
-	if (off != 0) goto out;
-
-	spin_lock(&rtc_lock);
-	sec = CMOS_READ(RTC_SECONDS_ALARM);
-	min = CMOS_READ(RTC_MINUTES_ALARM);
-	hr = CMOS_READ(RTC_HOURS_ALARM);
-
-#if 0
-	/* if I ever get an FACP with proper values, maybe I'll enable this code */
-	if (acpi_gbl_FADT->day_alrm)
-		day = CMOS_READ(acpi_gbl_FADT->day_alrm);
-	else
-		day =  CMOS_READ(RTC_DAY_OF_MONTH);
-	if (acpi_gbl_FADT->mon_alrm)
-		mo = CMOS_READ(acpi_gbl_FADT->mon_alrm);
-	else
-		mo = CMOS_READ(RTC_MONTH);;
-	if (acpi_gbl_FADT->century)
-		yr = CMOS_READ(acpi_gbl_FADT->century) * 100 + CMOS_READ(RTC_YEAR);
-	else
-		yr = CMOS_READ(RTC_YEAR);
-#else
-	day = CMOS_READ(RTC_DAY_OF_MONTH);
-	mo = CMOS_READ(RTC_MONTH);
-	yr = CMOS_READ(RTC_YEAR);
-#endif
-	spin_unlock(&rtc_lock);
-
-	BCD_TO_BIN(sec);
-	BCD_TO_BIN(min);
-	BCD_TO_BIN(hr);
-	BCD_TO_BIN(day);
-	BCD_TO_BIN(mo);
-	BCD_TO_BIN(yr);
-
-	str += sprintf(str,"%4.4u-",yr);
-
-	str += (mo > 12) ?
-		sprintf(str,"**-") :
-		sprintf(str,"%2.2u-",mo);
-
-	str += (day > 31) ?
-		sprintf(str,"** ") :
-		sprintf(str,"%2.2u ",day);
-
-	str += (hr > 23) ?
-		sprintf(str,"**:") :
-		sprintf(str,"%2.2u:",hr);
-
-	str += (min > 59) ?
-		sprintf(str,"**:") :
-		sprintf(str,"%2.2u:",min);
-
-	str += (sec > 59) ?
-		sprintf(str,"**\n") :
-		sprintf(str,"%2.2u\n",sec);
-
- out:
-	len = str - page;
-
-	if (len < count) *eof = 1;
-	else if (len > count) len = count;
-
-	if (len < 0) len = 0;
-
-	*start = page;
-
-	return len;
-}
-
-static int get_date_field(char **str, u32 *value)
-{
-	char *next,*strend;
-	int error = -EINVAL;
-
-	/* try to find delimeter, only to insert null;
-	 *  the end of string won't have one, but is still valid
-	 */
-	next = strpbrk(*str,"- :");
-	if (next) *next++ = '\0';
-
-	*value = simple_strtoul(*str,&strend,10);
-
-	/* signal success if we got a good digit */
-	if (strend != *str) error = 0;
-
-	if (next) *str = next;
-	return error;
-}
-
-
-
-int sm_osl_proc_write_alarm (
-	struct file *file,
-	const char *buffer,
-	unsigned long count,
-	void *data)
-{
-	char buf[30];
-	char *str = buf;
-	u32 sec,min,hr;
-	u32 day,mo,yr;
-	int adjust = 0;
-	unsigned char rtc_control;
-	int error = -EINVAL;
-
-	if (count > sizeof(buf) - 1) return -EINVAL;
-	
-	if (copy_from_user(str,buffer,count)) return -EFAULT;
-
-	str[count] = '\0';
-	/* check for time adjustment */
-	if (str[0] == '+') {
-		str++;
-		adjust = 1;
-	}
-
-	if ((error = get_date_field(&str,&yr)))  goto out;
-	if ((error = get_date_field(&str,&mo)))  goto out;
-	if ((error = get_date_field(&str,&day))) goto out;
-	if ((error = get_date_field(&str,&hr)))  goto out;
-	if ((error = get_date_field(&str,&min))) goto out;
-	if ((error = get_date_field(&str,&sec))) goto out;
-
-
-	if (sec > 59) {
-		min += 1;
-		sec -= 60;
-	}
-	if (min > 59) {
-		hr += 1;
-		min -= 60;
-	} 
-	if (hr > 23) {
-		day += 1;
-		hr -= 24;
-	}
-	if (day > 31) { 
-		mo += 1;
-		day -= 31;
-	}
-	if (mo > 12) {
-		yr += 1;
-		mo -= 12;
-	}
-
-	spin_lock_irq(&rtc_lock);
-	rtc_control = CMOS_READ(RTC_CONTROL);
-	if (!(rtc_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
-		BIN_TO_BCD(yr);
-		BIN_TO_BCD(mo);
-		BIN_TO_BCD(day);
-		BIN_TO_BCD(hr);
-		BIN_TO_BCD(min);
-		BIN_TO_BCD(sec);
-	}
-
-	if (adjust) {
-		yr  += CMOS_READ(RTC_YEAR);
-		mo  += CMOS_READ(RTC_MONTH);
-		day += CMOS_READ(RTC_DAY_OF_MONTH);
-		hr  += CMOS_READ(RTC_HOURS);
-		min += CMOS_READ(RTC_MINUTES);
-		sec += CMOS_READ(RTC_SECONDS);
-	}
-	spin_unlock_irq(&rtc_lock);
-
-	if (!(rtc_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
-		BCD_TO_BIN(yr);
-		BCD_TO_BIN(mo);
-		BCD_TO_BIN(day);
-		BCD_TO_BIN(hr);
-		BCD_TO_BIN(min);
-		BCD_TO_BIN(sec);
-	}
-
-	if (sec > 59) {
-		min++;
-		sec -= 60;
-	}
-	if (min > 59) {
-		hr++;
-		min -= 60;
-	}
-	if (hr > 23) {
-		day++;
-		hr -= 24;
-	}
-	if (day > 31) {
-		mo++;
-		day -= 31;
-	}
-	if (mo > 12) {
-		yr++;
-		mo -= 12;
-	}
-	if (!(rtc_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
-		BIN_TO_BCD(yr);
-		BIN_TO_BCD(mo);
-		BIN_TO_BCD(day);
-		BIN_TO_BCD(hr);
-		BIN_TO_BCD(min);
-		BIN_TO_BCD(sec);
-	}
-
-	spin_lock_irq(&rtc_lock);
-	/* write the fields the rtc knows about */
-	CMOS_WRITE(hr,RTC_HOURS_ALARM);
-	CMOS_WRITE(min,RTC_MINUTES_ALARM);
-	CMOS_WRITE(sec,RTC_SECONDS_ALARM);
-
-	/* If the system supports an enhanced alarm, it will have non-zero
-	 * offsets into the CMOS RAM here.
-	 * Which for some reason are pointing to the RTC area of memory.
-	 */
-#if 0
-	if (acpi_gbl_FADT->day_alrm) CMOS_WRITE(day,acpi_gbl_FADT->day_alrm);
-	if (acpi_gbl_FADT->mon_alrm) CMOS_WRITE(mo,acpi_gbl_FADT->mon_alrm);
-	if (acpi_gbl_FADT->century)  CMOS_WRITE(yr / 100,acpi_gbl_FADT->century);
-#endif
-	/* enable the rtc alarm interrupt */
-	if (!(rtc_control & RTC_AIE)) {
-		rtc_control |= RTC_AIE;
-		CMOS_WRITE(rtc_control,RTC_CONTROL);
-		CMOS_READ(RTC_INTR_FLAGS);
-	}
-
-	/* unlock the lock on the rtc now that we're done with it */
-	spin_unlock_irq(&rtc_lock);
-
-	acpi_hw_register_bit_access(ACPI_WRITE,ACPI_MTX_LOCK, RTC_EN, 1);
-
-	file->f_pos += count;
-
-	error = 0;
- out:
-	return error ? error : count;
-}
-
-static int 
-sm_osl_proc_read_gpe(
-	char                    *page,
-	char                    **start,
-	off_t                   off,
-	int                     count,
-	int                     *eof,
-	void                    *context)
-{
-	char *str = page;
-	int size;
-	int length;
-	int i;
-	u32 addr,data;
-	
-	if (off) goto out;
-
-	if (acpi_gbl_FADT->V1_gpe0blk) {
-		length = acpi_gbl_FADT->gpe0blk_len / 2;
-
-		str += sprintf(str,"GPE0: ");
-
-		for (i = length; i > 0; i--) {
-			addr = GPE0_EN_BLOCK | (i - 1);
-			data = acpi_hw_register_read(ACPI_MTX_LOCK,addr);
-			str += sprintf(str,"%2.2x ",data);
-		}
-		str += sprintf(str,"\n");
-
-		str += sprintf(str,"Status: ");
-		for (i = length; i > 0; i--) {
-			addr = GPE0_STS_BLOCK | (i - 1);
-			data = acpi_hw_register_read(ACPI_MTX_LOCK,addr);
-			str += sprintf(str,"%2.2x ",data);
-		}
-		str += sprintf(str,"\n");
-	}
-
-	if (acpi_gbl_FADT->V1_gpe1_blk) {
-		length = acpi_gbl_FADT->gpe1_blk_len / 2;
-
-
-		str += sprintf(str,"GPE1: ");
-		for (i = length; i > 0; i--) {
-			addr = GPE1_EN_BLOCK | (i - 1);
-			data = acpi_hw_register_read(ACPI_MTX_LOCK,addr);
-			str += sprintf(str,"%2.2x",data);
-		}
-		str += sprintf(str,"\n");
-
-		str += sprintf(str,"Status: ");
-		for (i = length; i > 0; i--) {
-			addr = GPE1_STS_BLOCK | (i - 1);
-			data = acpi_hw_register_read(ACPI_MTX_LOCK,addr);
-			str += sprintf(str,"%2.2x",data);
-		}
-		str += sprintf(str,"\n");
-	}
- out:
-	size = str - page;
-	if (size < count) *eof = 1;
-	else if (size > count) size = count;
-
-	if (size < 0) size = 0;
-	*start = page;
-
-	return size;
-}
-
-static int
-sm_osl_proc_write_gpe (
-	struct file *file,
-	const char *buffer,
-	unsigned long count,
-	void *data)
-{
-	char buf[256];
-	char *str = buf;
-	char *next;
-	int error = -EINVAL;
-	u32 addr,value = 0;
-
-	if (count > sizeof(buf) + 1) return -EINVAL;
-	
-	if (copy_from_user(str,buffer,count)) return -EFAULT;
-
-	str[count] = '\0';
-
-	/* set addr to which block to refer to */
-	if (!strncmp(str,"GPE0 ",5))      addr = GPE0_EN_BLOCK;
-	else if (!strncmp(str,"GPE1 ",5)) addr = GPE1_EN_BLOCK;
-	else goto out;
-
-	str += 5;
-
-	/* set low order bits to index of bit to set */
-	addr |= simple_strtoul(str,&next,0);
-	if (next == str) goto out;
-
-	if (next) {
-		str = ++next;
-		value = simple_strtoul(str,&next,0);
-		if (next == str) value = 1;
-	}
-
-	value = acpi_hw_register_bit_access(ACPI_WRITE,ACPI_MTX_LOCK,addr,(value ? 1 : 0));
-
-	error = 0;
- out:
-	return error ? error : count;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    sm_osl_suspend
- *
- * PARAMETERS:  %state: Sleep state to enter. Assumed that caller has filtered
- *              out bogus values, so it's one of S1, S2, S3 or S4
- *
- * RETURN:      ACPI_STATUS, whether or not we successfully entered and
- *              exited sleep.
- *
- * DESCRIPTION:
- * This function is the meat of the sleep routine, as far as the ACPI-CA is
- * concerned.
- *
- * See Chapter 9 of the ACPI 2.0 spec for details concerning the methodology here.
- *
- * It will do the following things:
- * - Call arch-specific routines to save the processor and kernel state
- * - Call acpi_enter_sleep_state to actually go to sleep
- * ....
- * When we wake back up, we will:
- * - Restore the processor and kernel state
- * - Return to the user
- *
- * By having this routine in here, it hides it from every part of the CA,
- * so it can remain OS-independent. The only function that calls this is
- * sm_proc_write_sleep, which gets the sleep state to enter from the user.
- *
- ****************************************************************************/
-static acpi_status
-sm_osl_suspend(u32 state)
-{
-	acpi_status status = AE_ERROR;
-	unsigned long wakeup_address;
-
-	/* get out if state is invalid */
-	if (state < ACPI_S1 || state > ACPI_S5) 
-		goto acpi_sleep_done;
-
-	/* make sure we don't get any suprises */
-	disable();
-
-	/* TODO: save device state and suspend them */
-	
-	/* save the processor state to memory if going into S2 or S3;
-	 * save it to disk if going into S4.
-	 * Also, set the FWV if going into an STR state
-	 */
-	if (state == ACPI_S2 || state == ACPI_S3) {
-#ifdef DONT_USE_UNTIL_LOWLEVEL_CODE_EXISTS
-		/* That && trick is *not going to work*. Read gcc
-		   specs. That explicitely says: jumping from other
-		   function is *not allowed*. */ 
-		wakeup_address = acpi_save_state_mem((unsigned long)&&acpi_sleep_done);
-
-		if (!wakeup_address) goto acpi_sleep_done;
-
-		acpi_set_firmware_waking_vector(
-			(ACPI_PHYSICAL_ADDRESS)wakeup_address);
-#endif
-	} else if (state == ACPI_S4)
-#ifdef DONT_USE_UNTIL_LOWLEVEL_CODE_EXISTS
-		if (acpi_save_state_disk((unsigned long)&&acpi_sleep_done)) 
-			goto acpi_sleep_done;
-#endif
-
-	/* set status, since acpi_enter_sleep_state won't return unless something
-	 * goes wrong, or it's just S1.
-	 */
-	status = AE_OK;
-
-	mdelay(10);
-	status = acpi_enter_sleep_state(state);
-
- acpi_sleep_done:
-
-	/* pause for a bit to allow devices to come back on */
-	mdelay(10);
-
-	/* make sure that the firmware waking vector is reset */
-	acpi_set_firmware_waking_vector((ACPI_PHYSICAL_ADDRESS)0);
-
-	acpi_leave_sleep_state(state);
-
-	/* TODO: resume devices and restore their state */
-
-	enable();
-	return status;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	sm_osl_power_down
- *
- ****************************************************************************/
-
-void
-sm_osl_power_down (void)
-{
-	/* Power down the system (S5 = soft off). */
-	sm_osl_suspend(ACPI_S5);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	sm_osl_add_device
- *
- ****************************************************************************/
-
-acpi_status
-sm_osl_add_device(
-	SM_CONTEXT		*system)
-{
-	u32			i = 0;
-	struct proc_dir_entry	*bm_proc_dsdt;
-
-	if (!system) {
-		return(AE_BAD_PARAMETER);
-	}
-
-	printk("ACPI: System firmware supports");
-	for (i=0; i<SM_MAX_SYSTEM_STATES; i++) {
-		if (system->states[i]) {
-			printk(" S%d", i);
-		}
-	}
-	printk("\n");
-
-	if (system->states[ACPI_STATE_S5]) {
-		sm_pm_power_off = pm_power_off;
-		pm_power_off = sm_osl_power_down;
-	}
-
-	create_proc_read_entry(SM_PROC_INFO, S_IRUGO,
-		sm_proc_root, sm_osl_proc_read_info, (void*)system);
-
-	bm_proc_sleep = create_proc_read_entry("sleep", S_IFREG | S_IRUGO | S_IWUSR,
-					    sm_proc_root, sm_osl_proc_read_sleep, (void*)system);
-	if (bm_proc_sleep)
-		bm_proc_sleep->write_proc = sm_osl_proc_write_sleep;
-
-	bm_proc_alarm = create_proc_read_entry("alarm", S_IFREG | S_IRUGO | S_IWUSR,
-					       sm_proc_root,sm_osl_proc_read_alarm, NULL);
-	if (bm_proc_alarm)
-		bm_proc_alarm->write_proc = sm_osl_proc_write_alarm;
-
-	bm_proc_gpe = create_proc_read_entry("gpe", S_IFREG | S_IRUGO | S_IWUSR,
-					     sm_proc_root,sm_osl_proc_read_gpe,NULL);
-	if (bm_proc_gpe)
-		bm_proc_gpe->write_proc = sm_osl_proc_write_gpe;
-	
-	/*
-	 * Get a wakeup address for use when we come back from sleep.
-	 * At least on IA-32, this needs to be in low memory.
-	 * When sleep is supported on other arch's, then we may want
-	 * to move this out to another place, but GFP_LOW should suffice
-	 * for now.
-	 */
-#if 0
-	if (system->states[ACPI_S3] || system->states[ACPI_S4]) {
-		acpi_wakeup_address = (unsigned long)virt_to_phys(get_free_page(GFP_LOWMEM));
-		printk(KERN_INFO "ACPI: Have wakeup address 0x%8.8x\n",acpi_wakeup_address);
-	}
-#endif
-
-	/*
-	 * This returns more than a page, so we need to use our own file ops,
-	 * not proc's generic ones
-	 */
-	bm_proc_dsdt = create_proc_entry(SM_PROC_DSDT, S_IRUSR, sm_proc_root);
-	if (bm_proc_dsdt) {
-		bm_proc_dsdt->proc_fops = &proc_dsdt_operations;
-	}
-
-	return(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	sm_osl_remove_device
- *
- ****************************************************************************/
-
-acpi_status
-sm_osl_remove_device (
-	SM_CONTEXT		*system)
-{
-	if (!system) {
-		return(AE_BAD_PARAMETER);
-	}
-
-	remove_proc_entry(SM_PROC_INFO, sm_proc_root);
-	remove_proc_entry(SM_PROC_DSDT, sm_proc_root);
-
-	return(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	sm_osl_generate_event
- *
- ****************************************************************************/
-
-acpi_status
-sm_osl_generate_event (
-	u32			event,
-	SM_CONTEXT		*system)
-{
-	acpi_status		status = AE_OK;
-
-	if (!system) {
-		return(AE_BAD_PARAMETER);
-	}
-
-	switch (event) {
-
-	default:
-		return(AE_BAD_PARAMETER);
-		break;
-	}
-
-	return(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	sm_osl_init
- *
- * PARAMETERS:	<none>
- *
- * RETURN:	0: Success
- *
- * DESCRIPTION: Module initialization.
- *
- ****************************************************************************/
-
-static int __init
-sm_osl_init (void)
-{
-	acpi_status		status = AE_OK;
-
-	/* abort if no busmgr */
-	if (!bm_proc_root)
-		return -ENODEV;
-
-	sm_proc_root = bm_proc_root;
-	if (!sm_proc_root) {
-		status = AE_ERROR;
-	}
-	else {
-		status = sm_initialize();
-	}
-
-	return (ACPI_SUCCESS(status)) ? 0 : -ENODEV;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	sm_osl_cleanup
- *
- * PARAMETERS:	<none>
- *
- * RETURN:	<none>
- *
- * DESCRIPTION: Module cleanup.
- *
- ****************************************************************************/
-
-static void __exit
-sm_osl_cleanup (void)
-{
-	sm_terminate();
-
-	return;
-}
-
-
-module_init(sm_osl_init);
-module_exit(sm_osl_cleanup);
diff -urNp linux-5400/drivers/acpi/ospm/thermal/Makefile linux-5410/drivers/acpi/ospm/thermal/Makefile
--- linux-5400/drivers/acpi/ospm/thermal/Makefile
+++ linux-5410/drivers/acpi/ospm/thermal/Makefile
@@ -1,6 +0,0 @@
-O_TARGET	:= ospm_$(notdir $(CURDIR)).o
-obj-m		:= $(O_TARGET)
-EXTRA_CFLAGS	+= $(ACPI_CFLAGS)
-obj-y		:= $(patsubst %.c,%.o,$(wildcard *.c))
-
-include $(TOPDIR)/Rules.make
diff -urNp linux-5400/drivers/acpi/ospm/thermal/tz.c linux-5410/drivers/acpi/ospm/thermal/tz.c
--- linux-5400/drivers/acpi/ospm/thermal/tz.c
+++ linux-5410/drivers/acpi/ospm/thermal/tz.c
@@ -1,642 +0,0 @@
-/*****************************************************************************
- *
- * Module Name: tz.c
- *   $Revision: 44 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include <acpi.h>
-#include <bm.h>
-#include "tz.h"
-
-
-#define _COMPONENT		ACPI_THERMAL
-	MODULE_NAME		("tz")
-
-
-/****************************************************************************
- *                                  Globals
- ****************************************************************************/
-
-extern int TZP;
-
-
-/****************************************************************************
- *                            Internal Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:    tz_print
- *
- ****************************************************************************/
-
-void
-tz_print (
-	TZ_CONTEXT		*tz)
-{
-#ifdef ACPI_DEBUG
-	acpi_buffer		buffer;
-	u32			i,j = 0;
-	TZ_THRESHOLDS		*thresholds = NULL;
-
-	FUNCTION_TRACE("tz_print");
-
-	if (!tz)
-		return;
-
-	thresholds = &(tz->policy.thresholds);
-
-	buffer.length = 256;
-	buffer.pointer = acpi_os_callocate(buffer.length);
-	if (!buffer.pointer)
-		return;
-
-	/*
-	 * Get the full pathname for this ACPI object.
-	 */
-	acpi_get_name(tz->acpi_handle, ACPI_FULL_PATHNAME, &buffer);
-
-	/*
-	 * Print out basic thermal zone information.
-	 */
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "+------------------------------------------------------------\n"));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "| Thermal_zone[%02x]:[%p] %s\n", tz->device_handle, tz->acpi_handle, (char*)buffer.pointer));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "|   temperature[%d] state[%08x]\n", tz->policy.temperature, tz->policy.state));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "|   cooling_mode[%08x] polling_freq[%d]\n", tz->policy.cooling_mode, tz->policy.polling_freq));
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "|   critical[%d]\n", thresholds->critical.temperature));
-	if (thresholds->hot.is_valid)
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "|   hot[%d]\n", thresholds->hot.temperature));
-	if (thresholds->passive.is_valid) {
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "|   passive[%d]: tc1[%d] tc2[%d] tsp[%d]\n", thresholds->passive.temperature, thresholds->passive.tc1, thresholds->passive.tc2, thresholds->passive.tsp));
-		if (thresholds->passive.devices.count > 0) {
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "|     devices"));
-			for (j=0; (j<thresholds->passive.devices.count && j<10); j++) {
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "[%02x]", thresholds->passive.devices.handles[j]));
-			}
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "\n"));
-		}
-	}
-	for (i=0; i<TZ_MAX_ACTIVE_THRESHOLDS; i++) {
-		if (!thresholds->active[i].is_valid)
-			break;
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "|   active[%d]: index[%d]\n", thresholds->active[i].temperature, i));
-		if (thresholds->active[i].devices.count > 0) {
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "|     devices"));
-			for (j=0; (j<thresholds->active[i].devices.count && j<10); j++) {
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "[%02x]", thresholds->active[i].devices.handles[j]));
-			}
-			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "\n"));
-		}
-	}
-
-	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INFO, "+------------------------------------------------------------\n"));
-
-	acpi_os_free(buffer.pointer);
-#endif /*ACPI_DEBUG*/
-
-	return;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    tz_get_temperaturee
- *
- ****************************************************************************/
-
-acpi_status
-tz_get_temperature (
-	TZ_CONTEXT		*tz)
-{
-	acpi_status             status = AE_OK;
-
-	FUNCTION_TRACE("tz_get_temperature");
-
-	if (!tz) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * Evaluate the _TMP method to get the current temperature.
-	 */
-	status = bm_evaluate_simple_integer(tz->acpi_handle, "_TMP", &(tz->policy.temperature));
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Temperature is %d d_k\n", tz->policy.temperature));
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    tz_set_cooling_preference
- *
- ****************************************************************************/
-
-acpi_status
-tz_set_cooling_preference (
-	TZ_CONTEXT              *tz,
-	TZ_COOLING_MODE         cooling_mode)
-{
-	acpi_status             status = AE_OK;
-	acpi_object_list        arg_list;
-	acpi_object             arg0;
-
-	FUNCTION_TRACE("tz_set_cooling_preference");
-
-	if (!tz || ((cooling_mode != TZ_COOLING_MODE_ACTIVE) && (cooling_mode != TZ_COOLING_MODE_PASSIVE))) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * Build the argument list, which simply consists of the current
-	 * cooling preference.
-	 */
-	memset(&arg_list, 0, sizeof(acpi_object));
-	arg_list.count = 1;
-	arg_list.pointer = &arg0;
-
-	memset(&arg0, 0, sizeof(acpi_object));
-	arg0.type = ACPI_TYPE_INTEGER;
-	arg0.integer.value = cooling_mode;
-
-	/*
-	 * Evaluate "_SCP" - setting the new cooling preference.
-	 */
-	status = acpi_evaluate_object(tz->acpi_handle, "_SCP", &arg_list, NULL);
-	if (ACPI_FAILURE(status)) {
-		tz->policy.cooling_mode = -1;
-		return_ACPI_STATUS(status);
-	}
-
-	tz->policy.cooling_mode = cooling_mode;
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    tz_get_thresholds
- *
- ****************************************************************************/
-
-acpi_status
-tz_get_thresholds (
-	TZ_CONTEXT		*tz)
-{
-	acpi_status		status = AE_OK;
-	TZ_THRESHOLDS		*thresholds = NULL;
-	u32			value = 0;
-	u32                     i = 0;
-
-	FUNCTION_TRACE("acpi_tz_get_thresholds");
-
-	if (!tz) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	thresholds = &(tz->policy.thresholds);
-
-	/* Critical Shutdown (required) */
-
-	status = bm_evaluate_simple_integer(tz->acpi_handle, "_CRT", &value);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "No critical threshold\n"));
-		return_ACPI_STATUS(status);
-	}
-	else {
-		thresholds->critical.temperature = value;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found critical threshold [%d]\n", thresholds->critical.temperature));
-
-	}
-
-	/* Critical Sleep (optional) */
-
-	status = bm_evaluate_simple_integer(tz->acpi_handle, "_HOT", &value);
-	if (ACPI_FAILURE(status)) {
-		thresholds->hot.is_valid = 0;
-		thresholds->hot.temperature = 0;
-	}
-	else {
-		thresholds->hot.is_valid = 1;
-		thresholds->hot.temperature = value;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found hot threshold [%d]\n", thresholds->hot.temperature));
-	}
-
-	/* Passive: Processors (optional) */
-
-	status = bm_evaluate_simple_integer(tz->acpi_handle, "_PSV", &value);
-	if (ACPI_FAILURE(status)) {
-		thresholds->passive.is_valid = 0;
-		thresholds->passive.temperature = 0;
-	}
-	else {
-		thresholds->passive.is_valid = 1;
-		thresholds->passive.temperature = value;
-
-		status = bm_evaluate_simple_integer(tz->acpi_handle, "_TC1", &value);
-		if (ACPI_FAILURE(status)) {
-			thresholds->passive.is_valid = 0;
-		}
-		thresholds->passive.tc1 = value;
-
-		status = bm_evaluate_simple_integer(tz->acpi_handle, "_TC2", &value);
-		if (ACPI_FAILURE(status)) {
-			thresholds->passive.is_valid = 0;
-		}
-		thresholds->passive.tc2 = value;
-
-		status = bm_evaluate_simple_integer(tz->acpi_handle, "_TSP", &value);
-		if (ACPI_FAILURE(status)) {
-			thresholds->passive.is_valid = 0;
-		}
-		thresholds->passive.tsp = value;
-
-		status = bm_evaluate_reference_list(tz->acpi_handle, "_PSL", &(thresholds->passive.devices));
-		if (ACPI_FAILURE(status)) {
-			thresholds->passive.is_valid = 0;
-		}
-
-		if (thresholds->passive.is_valid) {
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found passive threshold [%d]\n", thresholds->passive.temperature));
-		}
-		else {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid passive threshold\n"));
-		}
-	}
-
-	/* Active: Fans, etc. (optional) */
-
-	for (i=0; i<TZ_MAX_ACTIVE_THRESHOLDS; i++) {
-
-		char name[5] = {'_','A','C',('0'+i),'\0'};
-
-		status = bm_evaluate_simple_integer(tz->acpi_handle, name, &value);
-		if (ACPI_FAILURE(status)) {
-			thresholds->active[i].is_valid = 0;
-			thresholds->active[i].temperature = 0;
-			break;
-		}
-
-		thresholds->active[i].temperature = value;
-		name[2] = 'L';
-
-		status = bm_evaluate_reference_list(tz->acpi_handle, name, &(thresholds->active[i].devices));
-		if (ACPI_SUCCESS(status)) {
-			thresholds->active[i].is_valid = 1;
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found active threshold [%d]:[%d]\n", i, thresholds->active[i].temperature));
-		}
-		else {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid active threshold [%d]\n", i));
-		}
-	}
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    tz_add_device
- *
- ****************************************************************************/
-
-acpi_status
-tz_add_device (
-	BM_HANDLE               device_handle,
-	void                    **context)
-{
-	acpi_status             status = AE_OK;
-	TZ_CONTEXT              *tz = NULL;
-	BM_DEVICE		*device = NULL;
-	acpi_handle             tmp_handle = NULL;
-	static u32		zone_count = 0;
-
-	FUNCTION_TRACE("tz_add_device");
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Adding thermal zone [%02x].\n", device_handle));
-
-	if (!context || *context) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Invalid context for device [%02x].\n", device_handle));
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/*
-	 * Get information on this device.
-	 */
-	status = bm_get_device_info(device_handle, &device);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Allocate a new Thermal Zone device.
-	 */
-	tz = acpi_os_callocate(sizeof(TZ_CONTEXT));
-	if (!tz) {
-		return_ACPI_STATUS(AE_NO_MEMORY);
-	}
-
-	tz->device_handle = device->handle;
-	tz->acpi_handle = device->acpi_handle;
-
-	/* TBD: How to manage 'uid' when zones are Pn_p? */
-	sprintf(tz->uid, "%d", zone_count++);
-
-	/*
-	 * Temperature:
-	 * ------------
-	 * Make sure we can read the zone's current temperature (_TMP).
-	 * If we can't, there's no use in doing any policy (abort).
-	 */
-	status = tz_get_temperature(tz);
-	if (ACPI_FAILURE(status))
-		goto end;
-
-	/*
-	 * Polling Frequency:
-	 * ------------------
-	 * If _TZP doesn't exist use the OS default polling frequency.
-	 */
-	status = bm_evaluate_simple_integer(tz->acpi_handle, "_TZP", &(tz->policy.polling_freq));
-	if (ACPI_FAILURE(status)) {
-		tz->policy.polling_freq = TZP;
-	}
-	status = AE_OK;
-
-	/*
-	 * Cooling Preference:
-	 * -------------------
-	 * Default to ACTIVE (noisy) cooling until policy decides otherwise.
-	 * Note that _SCP is optional.
-	 */
-	tz_set_cooling_preference(tz, TZ_COOLING_MODE_ACTIVE);
-
-	/*
-	 * Start Policy:
-	 * -------------
-	 * Thermal policy is included in the kernel (this driver) because
-	 * of the critical role it plays in avoiding nuclear meltdown. =O
-	 */
-	status = tz_policy_add_device(tz);
-	if (ACPI_FAILURE(status))
-		goto end;
-
-	status = tz_osl_add_device(tz);
-	if (ACPI_FAILURE(status))
-		goto end;
-
-	*context = tz;
-
-	tz_print(tz);
-
-end:
-	if (ACPI_FAILURE(status))
-		acpi_os_free(tz);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    tz_remove_device
- *
- ****************************************************************************/
-
-acpi_status
-tz_remove_device (
-	void			**context)
-{
-	acpi_status		status = AE_OK;
-	TZ_CONTEXT		*tz = NULL;
-
-	FUNCTION_TRACE("tz_remove_device");
-
-	if (!context || !*context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	tz = (TZ_CONTEXT*)(*context);
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Removing thermal zone [%02x].\n", tz->device_handle));
-
-	status = tz_osl_remove_device(tz);
-
-	/*
-	 * Remove Policy:
-	 * --------------
-	 * TBD: Move all thermal zone policy to user-mode daemon...
-	 */
-	status = tz_policy_remove_device(tz);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	acpi_os_free(tz);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *                            External Functions
- ****************************************************************************/
-
-/****************************************************************************
- *
- * FUNCTION:    tz_initialize
- *
- ****************************************************************************/
-
-acpi_status
-tz_initialize (void)
-{
-	acpi_status             status = AE_OK;
-	BM_DEVICE_ID		criteria;
-	BM_DRIVER		driver;
-
-	FUNCTION_TRACE("tz_initialize");
-
-	memset(&criteria, 0, sizeof(BM_DEVICE_ID));
-	memset(&driver, 0, sizeof(BM_DRIVER));
-
-	/*
-	 * Register driver for thermal zone devices.
-	 */
-	criteria.type = BM_TYPE_THERMAL_ZONE;
-
-	driver.notify = &tz_notify;
-	driver.request = &tz_request;
-
-	status = bm_register_driver(&criteria, &driver);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    tz_terminate
- *
- ****************************************************************************/
-
-acpi_status
-tz_terminate (void)
-{
-	acpi_status             status = AE_OK;
-	BM_DEVICE_ID		criteria;
-	BM_DRIVER		driver;
-
-	FUNCTION_TRACE("tz_terminate");
-
-	memset(&criteria, 0, sizeof(BM_DEVICE_ID));
-	memset(&driver, 0, sizeof(BM_DRIVER));
-
-	/*
-	 * Unregister driver for thermal zone devices.
-	 */
-	criteria.type = BM_TYPE_THERMAL_ZONE;
-
-	driver.notify = &tz_notify;
-	driver.request = &tz_request;
-
-	status = bm_unregister_driver(&criteria, &driver);
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    tz_notify
- *
- ****************************************************************************/
-
-acpi_status
-tz_notify (
-	BM_NOTIFY               notify_type,
-	BM_HANDLE               device_handle,
-	void                    **context)
-{
-	acpi_status             status = AE_OK;
-	TZ_CONTEXT		*tz = NULL;
-
-	FUNCTION_TRACE("tz_notify");
-
-	if (!context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	tz = (TZ_CONTEXT*)*context;
-
-	switch (notify_type) {
-
-	case BM_NOTIFY_DEVICE_ADDED:
-		status = tz_add_device(device_handle, context);
-		break;
-
-	case BM_NOTIFY_DEVICE_REMOVED:
-		status = tz_remove_device(context);
-		break;
-
-	case TZ_NOTIFY_TEMPERATURE_CHANGE:
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Temperature (_TMP) change event detected.\n"));
-		tz_policy_check(*context);
-		status = tz_get_temperature(tz);
-		if (ACPI_SUCCESS(status)) {
-			status = tz_osl_generate_event(notify_type, tz);
-		}
-		break;
-
-	case TZ_NOTIFY_THRESHOLD_CHANGE:
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Threshold (_SCP) change event detected.\n"));
-		status = tz_policy_remove_device(tz);
-		if (ACPI_SUCCESS(status)) {
-			status = tz_policy_add_device(tz);
-		}
-		status = tz_osl_generate_event(notify_type, tz);
-		break;
-
-	case TZ_NOTIFY_DEVICE_LISTS_CHANGE:
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Device lists (_ALx, _PSL, _TZD) change event detected.\n"));
-		status = tz_policy_remove_device(tz);
-		if (ACPI_SUCCESS(status)) {
-			status = tz_policy_add_device(tz);
-		}
-		status = tz_osl_generate_event(notify_type, tz);
-		break;
-
-	default:
-		status = AE_SUPPORT;
-		break;
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    tz_request
- *
- ****************************************************************************/
-
-acpi_status
-tz_request (
-	BM_REQUEST		*request,
-	void                    *context)
-{
-	acpi_status             status = AE_OK;
-	TZ_CONTEXT              *tz = NULL;
-
-	FUNCTION_TRACE("tz_request");
-
-	/*
-	 * Must have a valid request structure and context.
-	 */
-	if (!request || !context) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	tz = (TZ_CONTEXT*)context;
-
-	/*
-	 * Handle request:
-	 * ---------------
-	 */
-	switch (request->command) {
-
-	default:
-		status = AE_SUPPORT;
-		break;
-	}
-
-	request->status = status;
-
-	return_ACPI_STATUS(status);
-}
diff -urNp linux-5400/drivers/acpi/ospm/thermal/tz_osl.c linux-5410/drivers/acpi/ospm/thermal/tz_osl.c
--- linux-5400/drivers/acpi/ospm/thermal/tz_osl.c
+++ linux-5410/drivers/acpi/ospm/thermal/tz_osl.c
@@ -1,398 +0,0 @@
-/******************************************************************************
- *
- * Module Name: tz_osl.c
- *   $Revision: 25 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/proc_fs.h>
-#include <acpi.h>
-#include "tz.h"
-
-
-MODULE_AUTHOR("Andrew Grover");
-MODULE_DESCRIPTION("ACPI Component Architecture (CA) - Thermal Zone Driver");
-MODULE_LICENSE("GPL");
-
-int TZP = 0;
-MODULE_PARM(TZP, "i");
-MODULE_PARM_DESC(TZP, "Thermal zone polling frequency, in 1/10 seconds.\n");
-
-
-#define TZ_PROC_ROOT		"thermal"
-#define TZ_PROC_STATUS		"status"
-#define TZ_PROC_INFO		"info"
-
-extern struct proc_dir_entry	*bm_proc_root;
-static struct proc_dir_entry	*tz_proc_root = NULL;
-
-
-/****************************************************************************
- *
- * FUNCTION:	tz_osl_proc_read_info
- *
- ****************************************************************************/
-
-static int
-tz_osl_proc_read_info (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*context)
-{
-	acpi_status		status = AE_OK;
-	char			name[5];
-	acpi_buffer		buffer = {sizeof(name), &name};
-	TZ_CONTEXT		*tz = NULL;
-	TZ_THRESHOLDS		*thresholds = NULL;
-	char			*p = page;
-	int 			len = 0;
-	u32			i,j;
-	u32			t = 0;
-
-	if (!context || (off != 0))
-		goto end;
-
-	tz = (TZ_CONTEXT*)context;
-
-	thresholds = &(tz->policy.thresholds);
-
-	p += sprintf(p, "critical (S5): trip=%d\n", thresholds->critical.temperature);
-	
-	if (thresholds->hot.is_valid)
-		p += sprintf(p, "critical (S4): trip=%d\n", thresholds->hot.temperature);
-
-	if (thresholds->passive.is_valid) {
-		p += sprintf(p, "passive:       trip=%d tc1=%d tc2=%d tsp=%d devices=", thresholds->passive.temperature, thresholds->passive.tc1, thresholds->passive.tc2, thresholds->passive.tsp);
-		for (j=0; j<thresholds->passive.devices.count; j++)
-			p += sprintf(p, "%08x%c", thresholds->passive.devices.handles[j], (j==thresholds->passive.devices.count-1)?'\n':',');
-	}
-
-	for (i=0; i<TZ_MAX_ACTIVE_THRESHOLDS; i++) {
-		if (!(thresholds->active[i].is_valid))
-			break;
-		p += sprintf(p, "active[%d]:     trip=%d devices=", i, thresholds->active[i].temperature);
-		for (j=0; j<thresholds->active[i].devices.count; j++)
-			p += sprintf(p, "%08x%c", thresholds->active[i].devices.handles[j], (j==thresholds->passive.devices.count-1)?'\n':',');
-	}
-
-	p += sprintf(p, "cooling mode:  ");
-	switch (tz->policy.cooling_mode) {
-	case TZ_COOLING_MODE_ACTIVE:
-		p += sprintf(p, "active (noisy)\n");
-		break;
-	case TZ_COOLING_MODE_PASSIVE:
-		p += sprintf(p, "passive (quiet)\n");
-		break;
-	default:
-		p += sprintf(p, "unknown\n");
-		break;
-	}
-
-	p += sprintf(p, "polling:       ");
-	switch (tz->policy.polling_freq) {
-	case 0:
-		p += sprintf(p, "disabled\n");
-		break;
-	default:
-		p += sprintf(p, "%d dS\n", tz->policy.polling_freq);
-		break;
-	}
-
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return len;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	tz_osl_proc_write_info
- *
- ****************************************************************************/
-
-static int tz_osl_proc_write_info (
-        struct file		*file, 
-        const char		*buffer, 
-        unsigned long		count, 
-        void			*data)
-{
-	TZ_CONTEXT		*tz = NULL;
-	u32			state = 0;
-	u32			size = 0;
-
-	if (!buffer || (count==0) || !data) {
-		goto end;
-	}
-
-	tz = (TZ_CONTEXT*)data;
-
-	size = strlen(buffer);
-	if (size < 4)
-		goto end;
-	
-	/* Cooling preference: "scp=0" (active) or "scp=1" (passive) */
-	if (0 == strncmp(buffer, "scp=", 4)) {
-		tz_set_cooling_preference(tz, (buffer[4] - '0'));
-	}
-
-	/* Polling frequency: "tzp=X" (poll every X [0-9] seconds) */
-	else if (0 == strncmp(buffer, "tzp=", 4)) {
-		tz->policy.polling_freq = (buffer[4] - '0') * 10;
-		tz_policy_check(tz);
-	}
-
-end:
-        return count;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	tz_osl_proc_read_status
- *
- ****************************************************************************/
-
-static int
-tz_osl_proc_read_status (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*context)
-{
-	TZ_CONTEXT		*tz = NULL;
-	char			*p = page;
-	int 			len = 0;
-
-	if (!context || (off != 0)) {
-		goto end;
-	}
-
-	tz = (TZ_CONTEXT*)context;
-
-	/* Temperature */
-
-	tz_get_temperature(tz);
-
-	p += sprintf(p, "temperature:   %d dK\n", tz->policy.temperature);
-
-	p += sprintf(p, "state:         ");
-	if (tz->policy.state == 0)
-		p += sprintf(p, "ok\n");
-	else if (tz->policy.state & TZ_STATE_CRITICAL)
-		p += sprintf(p, "critical\n");
-	else if (tz->policy.state & TZ_STATE_HOT)
-		p += sprintf(p, "hot\n");
-	else {
-		if (tz->policy.state & TZ_STATE_ACTIVE)
-			p += sprintf(p, "active[%d] ", tz->policy.state & 0x07);
-		if (tz->policy.state & TZ_STATE_PASSIVE)
-			p += sprintf(p, "passive ");
-		p += sprintf(p, "\n");
-	}
-
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return(len);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	tz_osl_add_device
- *
- ****************************************************************************/
-
-acpi_status
-tz_osl_add_device(
-	TZ_CONTEXT		*tz)
-{
-	struct proc_dir_entry	*proc_entry = NULL;
-	struct proc_dir_entry	*proc_child_entry = NULL;
-
-	if (!tz) {
-		return(AE_BAD_PARAMETER);
-	}
-
-	printk("ACPI: Thermal Zone found\n");
-
-	proc_entry = proc_mkdir(tz->uid, tz_proc_root);
-	if (!proc_entry) 
-		return(AE_ERROR);
-
-	proc_child_entry = create_proc_read_entry(TZ_PROC_STATUS, S_IFREG | S_IRUGO, proc_entry, tz_osl_proc_read_status, (void*)tz);
-	if (!proc_child_entry) 
-		return(AE_ERROR);
-
-	proc_child_entry = create_proc_entry(TZ_PROC_INFO, S_IFREG | 0644, proc_entry);
-	if (!proc_child_entry)
-		return(AE_ERROR);
-
-	proc_child_entry->read_proc = tz_osl_proc_read_info;
-	proc_child_entry->write_proc = tz_osl_proc_write_info;
-	proc_child_entry->data = (void*)tz;
-
-	return(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	tz_osl_remove_device
- *
- ****************************************************************************/
-
-acpi_status
-tz_osl_remove_device (
-	TZ_CONTEXT		*tz)
-{
-	char			proc_entry[64];
-
-	if (!tz) {
-		return(AE_BAD_PARAMETER);
-	}
-
-	sprintf(proc_entry, "%s/%s", tz->uid, TZ_PROC_INFO);
-	remove_proc_entry(proc_entry, tz_proc_root);
-
-	sprintf(proc_entry, "%s/%s", tz->uid, TZ_PROC_STATUS);
-	remove_proc_entry(proc_entry, tz_proc_root);
-
-	sprintf(proc_entry, "%s", tz->uid);
-	remove_proc_entry(proc_entry, tz_proc_root);
-
-	return(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	tz_osl_generate_event
- *
- ****************************************************************************/
-
-acpi_status
-tz_osl_generate_event (
-	u32			event,
-	TZ_CONTEXT		*tz)
-{
-	acpi_status		status = AE_OK;
-
-	if (!tz) {
-		return(AE_BAD_PARAMETER);
-	}
-
-	switch (event) {
-
-	case TZ_NOTIFY_TEMPERATURE_CHANGE:
-		status = bm_osl_generate_event(tz->device_handle,
-			TZ_PROC_ROOT, tz->uid, event,
-			tz->policy.temperature);
-		break;
-
-	case TZ_NOTIFY_THRESHOLD_CHANGE:
-	case TZ_NOTIFY_DEVICE_LISTS_CHANGE:
-		status = bm_osl_generate_event(tz->device_handle,
-			TZ_PROC_ROOT, tz->uid, event, 0);
-		break;
-
-	default:
-		return(AE_BAD_PARAMETER);
-		break;
-	}
-
-	return(status);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	tz_osl_init
- *
- ****************************************************************************/
-
-static int __init
-tz_osl_init (void)
-{
-	acpi_status		status = AE_OK;
-
-	/* abort if no busmgr */
-	if (!bm_proc_root)
-		return -ENODEV;
-
-	tz_proc_root = proc_mkdir(TZ_PROC_ROOT, bm_proc_root);
-	if (!tz_proc_root) {
-		status = AE_ERROR;
-	}
-	else {
-		status = tz_initialize();
-		if (ACPI_FAILURE(status)) {
-			remove_proc_entry(TZ_PROC_ROOT, bm_proc_root);
-		}
-
-	}
-
-	return (ACPI_SUCCESS(status)) ? 0 : -ENODEV;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:	tz_osl_cleanup
- *
- ****************************************************************************/
-
-static void __exit
-tz_osl_cleanup (void)
-{
-	tz_terminate();
-
-	if (tz_proc_root) {
-		remove_proc_entry(TZ_PROC_ROOT, bm_proc_root);
-	}
-
-	return;
-}
-
-
-module_init(tz_osl_init);
-module_exit(tz_osl_cleanup);
diff -urNp linux-5400/drivers/acpi/ospm/thermal/tzpolicy.c linux-5410/drivers/acpi/ospm/thermal/tzpolicy.c
--- linux-5400/drivers/acpi/ospm/thermal/tzpolicy.c
+++ linux-5410/drivers/acpi/ospm/thermal/tzpolicy.c
@@ -1,578 +0,0 @@
-/****************************************************************************
- *
- * Module Name: tzpolicy.c -
- *   $Revision: 30 $
- *
- ****************************************************************************/
-
-/*
- *  Copyright (C) 2000, 2001 Andrew Grover
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-/*
- * TBD: 1. Support performance-limit control for non-processor devices
- *         (those listed in _TZD, e.g. graphics).
- */
-
-#include <linux/proc_fs.h>
-#include <linux/sysctl.h>
-#include <linux/pm.h>
-
-#include <acpi.h>
-#include <bm.h>
-#include "tz.h"
-
-
-#define _COMPONENT		ACPI_THERMAL
-	MODULE_NAME		("tzpolicy")
-
-
-/****************************************************************************
- *                                  Globals
- ****************************************************************************/
-
-void
-tz_policy_run (
-	unsigned long           data);
-
-
-/****************************************************************************
- *                              Internal Functions
- ****************************************************************************/
-
-acpi_status
-set_performance_limit (
-	BM_HANDLE               device_handle,
-	u32			flag)
-{
-	acpi_status             status;
-	BM_REQUEST              request;
-
-	request.status = AE_OK;
-	request.handle = device_handle;
-	request.command = PR_COMMAND_SET_PERF_LIMIT;
-	request.buffer.length = sizeof(u32);
-	request.buffer.pointer = &flag;
-
-	status = bm_request(&request);
-
-	if (ACPI_FAILURE(status))
-		return status;
-	else
-		return request.status;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    tz_policy_critical
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-tz_policy_critical(
-	TZ_CONTEXT		*tz)
-{
-	FUNCTION_TRACE("tz_policy_critical");
-
-	if (!tz) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	if (tz->policy.temperature >= tz->policy.thresholds.critical.temperature) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Critical (S5) threshold reached.\n"));
-		/* TBD:	Need method for shutting down system. */
-	}
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    tz_policy_hot
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-tz_policy_hot(
-	TZ_CONTEXT		*tz)
-{
-	FUNCTION_TRACE("tz_policy_hot");
-
-	if (!tz || !tz->policy.thresholds.hot.is_valid) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	if (tz->policy.temperature >= tz->policy.thresholds.hot.temperature) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Critical (S4) threshold reached.\n"));
-		/* TBD:	Need method for invoking OS-level critical suspend. */
-	}
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    tz_policy_passive
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-tz_policy_passive(
-	TZ_CONTEXT		*tz)
-{
-	TZ_PASSIVE_THRESHOLD	*passive = NULL;
-	static u32		last_temperature = 0;
-	s32			trend = 0;
-	u32			i = 0;
-
-	FUNCTION_TRACE("tz_policy_passive");
-
-	if (!tz || !tz->policy.thresholds.passive.is_valid) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	passive = &(tz->policy.thresholds.passive);
-
-	if (tz->policy.temperature >= passive->temperature) {
-		/*
-		 * Thermal trend?
-		 * --------------
-		 * Using the passive cooling equation (see the ACPI
-		 * Specification), calculate the current thermal trend
-		 * (a.k.a. performance delta).
-		 */
-		trend = passive->tc1 * (tz->policy.temperature - last_temperature) + passive->tc2 * (tz->policy.temperature - passive->temperature);
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "trend[%d] = TC1[%d]*(temp[%d]-last[%d]) + TC2[%d]*(temp[%d]-passive[%d])\n", trend, passive->tc1, tz->policy.temperature, last_temperature, passive->tc2, tz->policy.temperature, passive->temperature));
-
-		last_temperature = tz->policy.temperature;
-
-		/*
-		 * Heating Up?
-		 * -----------
-		 * Decrease thermal performance limit on all passive
-		 * cooling devices (processors).
-		 */
-		if (trend > 0) {
-			for (i=0; i<passive->devices.count; i++)
-				set_performance_limit(passive->devices.handles[i], PR_PERF_DEC);
-		}
-		/*
-		 * Cooling Off?
-		 * ------------
-		 * Increase thermal performance limit on all passive
-		 * cooling devices (processors).
-		 */
-		else if (trend < 0) {
-			for (i=0; i<passive->devices.count; i++)
-				set_performance_limit(passive->devices.handles[i], PR_PERF_INC);
-		}
-	}
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    tz_policy_active
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-tz_policy_active(
-	TZ_CONTEXT              *tz)
-{
-	acpi_status             status = AE_OK;
-	TZ_ACTIVE_THRESHOLD	*active = NULL;
-	u32                     i,j = 0;
-
-	FUNCTION_TRACE("tz_policy_active");
-
-	if (!tz || !tz->policy.thresholds.active[0].is_valid) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	for (i=0; i<TZ_MAX_ACTIVE_THRESHOLDS; i++) {
-
-		active = &(tz->policy.thresholds.active[i]);
-		if (!active || !active->is_valid)
-			break;
-
-		/*
-		 * Above Threshold?
-		 * ----------------
-		 * If not already enabled, turn ON all cooling devices
-		 * associated with this active threshold.
-		 */
-		if ((tz->policy.temperature >= active->temperature) && (active->cooling_state != TZ_COOLING_ENABLED)) {
-			for (j = 0; j < active->devices.count; j++) {
-				status = bm_set_device_power_state(active->devices.handles[j], ACPI_STATE_D0);
-				if (ACPI_SUCCESS(status)) {
-					ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Cooling device [%02x] now ON.\n", active->devices.handles[j]));
-				}
-				else {
-					ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Unable to turn ON cooling device [%02x].\n", active->devices.handles[j]));
-				}
-			}
-  			active->cooling_state = TZ_COOLING_ENABLED;
-		}
-		/*
-		 * Below Threshold?
-		 * ----------------
-		 * Turn OFF all cooling devices associated with this
-		 * threshold.  Note that by checking "if not disabled" we
-		 * turn off all cooling devices for thresholds in the
-		 * TZ_COOLING_STATE_UNKNOWN state, useful as a level-set
-		 * during the first pass.
-		 */
-		else if (active->cooling_state != TZ_COOLING_DISABLED) {
-			for (j = 0; j < active->devices.count; j++) {
-				status = bm_set_device_power_state(active->devices.handles[j], ACPI_STATE_D3);
-				if (ACPI_SUCCESS(status)) {
-					ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Cooling device [%02x] now OFF.\n", active->devices.handles[j]));
-				}
-				else {
-					ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Unable to turn OFF cooling device [%02x].\n", active->devices.handles[j]));
-				}
-			}
-			active->cooling_state = TZ_COOLING_DISABLED;
-		}
-	}
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    tz_policy_check
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION: Note that this function will get called whenever:
- *                1. A thermal event occurs.
- *                2. The polling/sampling time period expires.
- *
- ****************************************************************************/
-
-void
-tz_policy_check (
-	void                    *context)
-{
-	acpi_status             status = AE_OK;
-	TZ_CONTEXT              *tz = NULL;
-	TZ_POLICY		*policy = NULL;
-	TZ_THRESHOLDS		*thresholds = NULL;
-	u32                     previous_temperature = 0;
-	u32                     previous_state = 0;
-	u32                     active_index = 0;
-	u32                     i = 0;
-	u32                     sleep_time = 0;
-
-	FUNCTION_TRACE("tz_policy_check");
-
-	if (!context) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid (NULL) context.\n"));
-		return_VOID;
-	}
-
-	tz = (TZ_CONTEXT*)context;
-	policy = &(tz->policy);
-	thresholds = &(tz->policy.thresholds);
-
-	/*
-	 * Preserve Previous State:
-	 * ------------------------
-	 */
-	previous_temperature = tz->policy.temperature;
-	previous_state = tz->policy.state;
-
-	/*
-	 * Get Temperature:
-	 * ----------------
-	 */
-	status = tz_get_temperature(tz);
-	if (ACPI_FAILURE(status)) {
-		return_VOID;
-	}
-
-	/*
-	 * Calculate State:
-	 * ----------------
-	 */
-	policy->state = TZ_STATE_OK;
-
-	/* Critical? */
-	if (policy->temperature >= thresholds->critical.temperature)
-		policy->state |= TZ_STATE_CRITICAL;
-
-	/* Hot? */
-	if ((thresholds->hot.is_valid) &&  (policy->temperature >= thresholds->hot.temperature))
-		policy->state |= TZ_STATE_CRITICAL;
-
-	/* Passive? */
-	if ((thresholds->passive.is_valid) && (policy->temperature >= thresholds->passive.temperature))
-		policy->state |= TZ_STATE_PASSIVE;
-
-	/* Active? */
-	if (thresholds->active[0].is_valid) {
-		for (i=0; i<TZ_MAX_ACTIVE_THRESHOLDS; i++) {
-			if ((thresholds->active[i].is_valid) && (policy->temperature >= thresholds->active[i].temperature)) {
-				policy->state |= TZ_STATE_ACTIVE;
-				if (i > active_index)
-					active_index = i;
-			}
-		}
-		policy->state |= active_index;
-	}
-
-	/*
-	 * Invoke Policy:
-	 * --------------
-	 * Note that policy must be invoked both when 'going into' a
-	 * policy state (e.g. to allow fans to be turned on) and 'going
-	 * out of' a policy state (e.g. to allow fans to be turned off);
-	 * thus we must preserve the previous state.
-	 */
-	if (policy->state & TZ_STATE_CRITICAL)
-		tz_policy_critical(tz);
-	if (policy->state & TZ_STATE_HOT)
-		tz_policy_hot(tz);
-	if ((policy->state & TZ_STATE_PASSIVE) || (previous_state & TZ_STATE_PASSIVE))
-		tz_policy_passive(tz);
-	if ((policy->state & TZ_STATE_ACTIVE) || (previous_state & TZ_STATE_ACTIVE))
-		tz_policy_active(tz);
-
-	/*
-	 * Calculate Sleep Time:
-	 * ---------------------
-	 * If we're in the passive state, use _TSP's value.  Otherwise
-	 * use _TZP or the OS's default polling frequency.  If no polling
-	 * frequency is specified then we'll wait forever (that is, until
-	 * a thermal event occurs -- e.g. never poll).  Note that _TSP
-	 * and _TZD values are given in 1/10th seconds.
-	 */
-	if (policy->state & TZ_STATE_PASSIVE)
-		sleep_time = thresholds->passive.tsp * 100;
-	else if (policy->polling_freq > 0)
-		sleep_time = policy->polling_freq * 100;
-	else
-		sleep_time = WAIT_FOREVER;
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Thermal_zone[%02x]: temperature[%d] state[%08x]\n", tz->device_handle, policy->temperature, policy->state));
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Scheduling next poll in [%d]ms.\n", sleep_time));
-
-	/*
-	 * Schedule Next Poll:
-	 * -------------------
-	 */
-	if (sleep_time < WAIT_FOREVER) {
-		if (timer_pending(&(policy->timer)))
-			mod_timer(&(policy->timer), (HZ*sleep_time)/1000);
-		else {
-			policy->timer.data = (unsigned long)tz;
-			policy->timer.function = tz_policy_run;
-			policy->timer.expires = jiffies + (HZ*sleep_time)/1000;
-			add_timer(&(policy->timer));
-		}
-	}
-	else {
-		if (timer_pending(&(policy->timer)))
-			del_timer(&(policy->timer));
-	}
-
-	return_VOID;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    tz_policy_run
- *
- * PARAMETERS:
- *
- * RETURN:
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-
-void
-tz_policy_run (
-	unsigned long           data)
-{
-	acpi_status             status = AE_OK;
-
-	FUNCTION_TRACE("tz_policy_run");
-
-	if (!data) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid (NULL) context.\n"));
-		return_VOID;
-	}
-
-	/*
-	 * Defer to Non-Interrupt Level:
-	 * -----------------------------
-	 * Note that all Linux kernel timers run at interrupt-level (ack!).
-	 */
-	status = acpi_os_queue_for_execution(OSD_PRIORITY_GPE,  tz_policy_check, (void*)data);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Error invoking thermal policy.\n"));
-	}
-
-	return_VOID;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    tz_policy_add_device
- *
- * PARAMETERS:
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-tz_policy_add_device (
-	TZ_CONTEXT		*tz)
-{
-	acpi_status             status = AE_OK;
-	TZ_THRESHOLDS           *thresholds = NULL;
-	u32                     i,j = 0;
-
-	FUNCTION_TRACE("tz_policy_add_device");
-
-	if (!tz) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Adding policy for thermal zone [%02x].\n", tz->device_handle));
-
-	/*
-	 * Get Thresholds:
-	 * ---------------
-	 */
-	status = tz_get_thresholds(tz);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Initialize Policies:
-	 * --------------------
-	 */
-	if (tz->policy.thresholds.passive.is_valid) {
-		for (i=0; i<tz->policy.thresholds.passive.devices.count; i++)
-			set_performance_limit(tz->policy.thresholds.passive.devices.handles[i], PR_PERF_MAX);
-		tz_policy_passive(tz);
-	}
-	if (tz->policy.thresholds.active[0].is_valid)
-		tz_policy_active(tz);
-
-	/*
-	 * Initialize Policy Timer:
-	 * ------------------------
-	 */
-	init_timer(&(tz->policy.timer));
-
-	/*
-	 * Start Policy:
-	 * -------------
-	 * Run an initial check using this zone's policy.
-	 */
-	tz_policy_check(tz);
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-/*****************************************************************************
- *
- * FUNCTION:    tz_policy_remove_device
- *
- * PARAMETERS:
- *
- * RETURN:	
- *
- * DESCRIPTION:
- *
- ****************************************************************************/
-
-acpi_status
-tz_policy_remove_device(
-	TZ_CONTEXT		*tz)
-{
-	u32			i = 0;
-
-	FUNCTION_TRACE("tz_remove_device");
-
-	if (!tz) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Removing policy for thermal zone [%02x].\n", tz->device_handle));
-
-	/*
-	 * Delete the thermal zone policy timer entry, if exists.
-	 */
-	if (timer_pending(&(tz->policy.timer)))
-		del_timer(&(tz->policy.timer));
-
-	/*
-	 * Reset thermal performance limit on all processors back to max.
-	 */
-	if (tz->policy.thresholds.passive.is_valid) {
-		for (i=0; i<tz->policy.thresholds.passive.devices.count; i++)
-			set_performance_limit(tz->policy.thresholds.passive.devices.handles[i], PR_PERF_MAX);
-	}
-
-	return_ACPI_STATUS(AE_OK);
-}
diff -urNp linux-5400/drivers/acpi/parser/Makefile linux-5410/drivers/acpi/parser/Makefile
--- linux-5400/drivers/acpi/parser/Makefile
+++ linux-5410/drivers/acpi/parser/Makefile
@@ -1,11 +1,10 @@
 #
 # Makefile for all Linux ACPI interpreter subdirectories
-# EXCEPT for the ospm directory
 #
 
 O_TARGET := $(notdir $(CURDIR)).o
 
-obj-$(CONFIG_ACPI) := $(patsubst %.c,%.o,$(wildcard *.c))
+obj-$(CONFIG_ACPI_INTERPRETER) := $(patsubst %.c,%.o,$(wildcard *.c))
 
 EXTRA_CFLAGS += $(ACPI_CFLAGS)
 
diff -urNp linux-5400/drivers/acpi/parser/psargs.c linux-5410/drivers/acpi/parser/psargs.c
--- linux-5400/drivers/acpi/parser/psargs.c
+++ linux-5410/drivers/acpi/parser/psargs.c
@@ -1,43 +1,61 @@
 /******************************************************************************
  *
  * Module Name: psargs - Parse AML opcode arguments
- *              $Revision: 52 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
-#include "amlcode.h"
-#include "acnamesp.h"
+#include <acpi/acpi.h>
+#include <acpi/acparser.h>
+#include <acpi/amlcode.h>
+#include <acpi/acnamesp.h>
 
 #define _COMPONENT          ACPI_PARSER
-	 MODULE_NAME         ("psargs")
+	 ACPI_MODULE_NAME    ("psargs")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_get_next_package_length
+ * FUNCTION:    acpi_ps_get_next_package_length
  *
- * PARAMETERS:  Parser_state        - Current parser state object
+ * PARAMETERS:  parser_state        - Current parser state object
  *
  * RETURN:      Decoded package length.  On completion, the AML pointer points
  *              past the length byte or bytes.
@@ -48,16 +66,16 @@
 
 u32
 acpi_ps_get_next_package_length (
-	acpi_parse_state        *parser_state)
+	struct acpi_parse_state         *parser_state)
 {
-	u32                     encoded_length;
-	u32                     length = 0;
+	u32                             encoded_length;
+	u32                             length = 0;
 
 
-	FUNCTION_TRACE ("Ps_get_next_package_length");
+	ACPI_FUNCTION_TRACE ("ps_get_next_package_length");
 
 
-	encoded_length = (u32) GET8 (parser_state->aml);
+	encoded_length = (u32) ACPI_GET8 (parser_state->aml);
 	parser_state->aml++;
 
 
@@ -70,7 +88,7 @@ acpi_ps_get_next_package_length (
 
 	case 1: /* 2-byte encoding (next byte + bits 0-3) */
 
-		length = ((GET8 (parser_state->aml) << 04) |
+		length = ((ACPI_GET8 (parser_state->aml) << 04) |
 				 (encoded_length & 0x0F));
 		parser_state->aml++;
 		break;
@@ -78,8 +96,8 @@ acpi_ps_get_next_package_length (
 
 	case 2: /* 3-byte encoding (next 2 bytes + bits 0-3) */
 
-		length = ((GET8 (parser_state->aml + 1) << 12) |
-				  (GET8 (parser_state->aml)    << 04) |
+		length = ((ACPI_GET8 (parser_state->aml + 1) << 12) |
+				  (ACPI_GET8 (parser_state->aml)    << 04) |
 				  (encoded_length & 0x0F));
 		parser_state->aml += 2;
 		break;
@@ -87,12 +105,17 @@ acpi_ps_get_next_package_length (
 
 	case 3: /* 4-byte encoding (next 3 bytes + bits 0-3) */
 
-		length = ((GET8 (parser_state->aml + 2) << 20) |
-				  (GET8 (parser_state->aml + 1) << 12) |
-				  (GET8 (parser_state->aml)    << 04) |
+		length = ((ACPI_GET8 (parser_state->aml + 2) << 20) |
+				  (ACPI_GET8 (parser_state->aml + 1) << 12) |
+				  (ACPI_GET8 (parser_state->aml)    << 04) |
 				  (encoded_length & 0x0F));
 		parser_state->aml += 3;
 		break;
+
+	default:
+
+		/* Can't get here, only 2 bits / 4 cases */
+		break;
 	}
 
 	return_VALUE (length);
@@ -101,9 +124,9 @@ acpi_ps_get_next_package_length (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_get_next_package_end
+ * FUNCTION:    acpi_ps_get_next_package_end
  *
- * PARAMETERS:  Parser_state        - Current parser state object
+ * PARAMETERS:  parser_state        - Current parser state object
  *
  * RETURN:      Pointer to end-of-package +1
  *
@@ -114,16 +137,18 @@ acpi_ps_get_next_package_length (
 
 u8 *
 acpi_ps_get_next_package_end (
-	acpi_parse_state        *parser_state)
+	struct acpi_parse_state         *parser_state)
 {
-	u8                      *start = parser_state->aml;
-	NATIVE_UINT             length;
+	u8                              *start = parser_state->aml;
+	acpi_native_uint                length;
 
 
-	FUNCTION_TRACE ("Ps_get_next_package_end");
+	ACPI_FUNCTION_TRACE ("ps_get_next_package_end");
 
 
-	length = (NATIVE_UINT) acpi_ps_get_next_package_length (parser_state);
+	/* Function below changes parser_state->Aml */
+
+	length = (acpi_native_uint) acpi_ps_get_next_package_length (parser_state);
 
 	return_PTR (start + length); /* end of package */
 }
@@ -131,9 +156,9 @@ acpi_ps_get_next_package_end (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_get_next_namestring
+ * FUNCTION:    acpi_ps_get_next_namestring
  *
- * PARAMETERS:  Parser_state        - Current parser state object
+ * PARAMETERS:  parser_state        - Current parser state object
  *
  * RETURN:      Pointer to the start of the name string (pointer points into
  *              the AML.
@@ -144,32 +169,31 @@ acpi_ps_get_next_package_end (
  *
  ******************************************************************************/
 
-NATIVE_CHAR *
+char *
 acpi_ps_get_next_namestring (
-	acpi_parse_state        *parser_state)
+	struct acpi_parse_state         *parser_state)
 {
-	u8                       *start = parser_state->aml;
-	u8                       *end = parser_state->aml;
-	u32                     length;
+	u8                              *start = parser_state->aml;
+	u8                              *end = parser_state->aml;
 
 
-	FUNCTION_TRACE ("Ps_get_next_namestring");
+	ACPI_FUNCTION_TRACE ("ps_get_next_namestring");
 
 
 	/* Handle multiple prefix characters */
 
-	while (acpi_ps_is_prefix_char (GET8 (end))) {
-		/* include prefix '\\' or '^' */
+	while (acpi_ps_is_prefix_char (ACPI_GET8 (end))) {
+		/* Include prefix '\\' or '^' */
 
 		end++;
 	}
 
 	/* Decode the path */
 
-	switch (GET8 (end)) {
+	switch (ACPI_GET8 (end)) {
 	case 0:
 
-		/* Null_name */
+		/* null_name */
 
 		if (end == start) {
 			start = NULL;
@@ -177,183 +201,77 @@ acpi_ps_get_next_namestring (
 		end++;
 		break;
 
-
 	case AML_DUAL_NAME_PREFIX:
 
-		/* two name segments */
+		/* Two name segments */
 
-		end += 9;
+		end += 1 + (2 * ACPI_NAME_SIZE);
 		break;
 
-
 	case AML_MULTI_NAME_PREFIX_OP:
 
-		/* multiple name segments */
+		/* Multiple name segments, 4 chars each */
 
-		length = (u32) GET8 (end + 1) * 4;
-		end += 2 + length;
+		end += 2 + ((acpi_size) ACPI_GET8 (end + 1) * ACPI_NAME_SIZE);
 		break;
 
-
 	default:
 
-		/* single name segment */
-		/* assert (Acpi_ps_is_lead (GET8 (End))); */
+		/* Single name segment */
 
-		end += 4;
+		end += ACPI_NAME_SIZE;
 		break;
 	}
 
 	parser_state->aml = (u8*) end;
-
-	return_PTR ((NATIVE_CHAR *) start);
+	return_PTR ((char *) start);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_get_next_namepath
+ * FUNCTION:    acpi_ps_get_next_namepath
  *
- * PARAMETERS:  Parser_state        - Current parser state object
+ * PARAMETERS:  parser_state        - Current parser state object
  *              Arg                 - Where the namepath will be stored
- *              Arg_count           - If the namepath points to a control method
+ *              arg_count           - If the namepath points to a control method
  *                                    the method's argument is returned here.
- *              Method_call         - Whether the namepath can be the start
- *                                    of a method call
+ *              method_call         - Whether the namepath can possibly be the
+ *                                    start of a method call
  *
- * RETURN:      None
+ * RETURN:      Status
  *
- * DESCRIPTION: Get next name (if method call, push appropriate # args).  Names
- *              are looked up in either the parsed or internal namespace to
- *              determine if the name represents a control method.  If a method
+ * DESCRIPTION: Get next name (if method call, return # of required args).
+ *              Names are looked up in the internal namespace to determine
+ *              if the name represents a control method.  If a method
  *              is found, the number of arguments to the method is returned.
  *              This information is critical for parsing to continue correctly.
  *
  ******************************************************************************/
 
-
-#ifdef PARSER_ONLY
-
-void
-acpi_ps_get_next_namepath (
-	acpi_parse_state        *parser_state,
-	acpi_parse_object       *arg,
-	u32                     *arg_count,
-	u8                      method_call)
-{
-	NATIVE_CHAR             *path;
-	acpi_parse_object       *name_op;
-	acpi_parse_object       *op;
-	acpi_parse_object       *count;
-
-
-	FUNCTION_TRACE ("Ps_get_next_namepath");
-
-
-	path = acpi_ps_get_next_namestring (parser_state);
-	if (!path || !method_call) {
-		/* Null name case, create a null namepath object */
-
-		acpi_ps_init_op (arg, AML_INT_NAMEPATH_OP);
-		arg->value.name = path;
-		return_VOID;
-	}
-
-
-	if (acpi_gbl_parsed_namespace_root) {
-		/*
-		 * Lookup the name in the parsed namespace
-		 */
-		op = NULL;
-		if (method_call) {
-			op = acpi_ps_find (acpi_ps_get_parent_scope (parser_state),
-					   path, AML_METHOD_OP, 0);
-		}
-
-		if (op) {
-			if (op->opcode == AML_METHOD_OP) {
-				/*
-				 * The name refers to a control method, so this namepath is a
-				 * method invocation.  We need to 1) Get the number of arguments
-				 * associated with this method, and 2) Change the NAMEPATH
-				 * object into a METHODCALL object.
-				 */
-				count = acpi_ps_get_arg (op, 0);
-				if (count && count->opcode == AML_BYTE_OP) {
-					name_op = acpi_ps_alloc_op (AML_INT_NAMEPATH_OP);
-					if (name_op) {
-						/* Change arg into a METHOD CALL and attach the name */
-
-						acpi_ps_init_op (arg, AML_INT_METHODCALL_OP);
-
-						name_op->value.name = path;
-
-						/* Point METHODCALL/NAME to the METHOD Node */
-
-						name_op->node = (acpi_namespace_node *) op;
-						acpi_ps_append_arg (arg, name_op);
-
-						*arg_count = (u32) count->value.integer &
-								 METHOD_FLAGS_ARG_COUNT;
-					}
-				}
-
-				return_VOID;
-			}
-
-			/*
-			 * Else this is normal named object reference.
-			 * Just init the NAMEPATH object with the pathname.
-			 * (See code below)
-			 */
-		}
-	}
-
-	/*
-	 * Either we didn't find the object in the namespace, or the object is
-	 * something other than a control method.  Just initialize the Op with the
-	 * pathname
-	 */
-	acpi_ps_init_op (arg, AML_INT_NAMEPATH_OP);
-	arg->value.name = path;
-
-
-	return_VOID;
-}
-
-
-#else
-
-
-void
+acpi_status
 acpi_ps_get_next_namepath (
-	acpi_parse_state        *parser_state,
-	acpi_parse_object       *arg,
-	u32                     *arg_count,
-	u8                      method_call)
+	struct acpi_walk_state          *walk_state,
+	struct acpi_parse_state         *parser_state,
+	union acpi_parse_object         *arg,
+	u8                              method_call)
 {
-	NATIVE_CHAR             *path;
-	acpi_parse_object       *name_op;
-	acpi_status             status;
-	acpi_namespace_node     *method_node = NULL;
-	acpi_namespace_node     *node;
-	acpi_generic_state      scope_info;
+	char                            *path;
+	union acpi_parse_object         *name_op;
+	acpi_status                     status = AE_OK;
+	union acpi_operand_object       *method_desc;
+	struct acpi_namespace_node      *node;
+	union acpi_generic_state        scope_info;
 
 
-	FUNCTION_TRACE ("Ps_get_next_namepath");
+	ACPI_FUNCTION_TRACE ("ps_get_next_namepath");
 
 
 	path = acpi_ps_get_next_namestring (parser_state);
-	if (!path || !method_call) {
-		/* Null name case, create a null namepath object */
 
-		acpi_ps_init_op (arg, AML_INT_NAMEPATH_OP);
-		arg->value.name = path;
-		return_VOID;
-	}
+	/* Null path case is allowed */
 
-
-	if (method_call) {
+	if (path) {
 		/*
 		 * Lookup the name in the internal namespace
 		 */
@@ -369,36 +287,48 @@ acpi_ps_get_next_namepath (
 		 * parent tree, but don't open a new scope -- we just want to lookup the
 		 * object  (MUST BE mode EXECUTE to perform upsearch)
 		 */
-		status = acpi_ns_lookup (&scope_info, path, ACPI_TYPE_ANY, IMODE_EXECUTE,
-				 NS_SEARCH_PARENT | NS_DONT_OPEN_SCOPE, NULL,
-				 &node);
-		if (ACPI_SUCCESS (status)) {
+		status = acpi_ns_lookup (&scope_info, path, ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
+				 ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE, NULL, &node);
+		if (ACPI_SUCCESS (status) && method_call) {
 			if (node->type == ACPI_TYPE_METHOD) {
-				method_node = node;
-				ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "method - %p Path=%p\n",
-					method_node, path));
+				/*
+				 * This name is actually a control method invocation
+				 */
+				method_desc = acpi_ns_get_attached_object (node);
+				ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
+					"Control Method - %p Desc %p Path=%p\n",
+					node, method_desc, path));
 
 				name_op = acpi_ps_alloc_op (AML_INT_NAMEPATH_OP);
-				if (name_op) {
-					/* Change arg into a METHOD CALL and attach name to it */
-
-					acpi_ps_init_op (arg, AML_INT_METHODCALL_OP);
+				if (!name_op) {
+					return_ACPI_STATUS (AE_NO_MEMORY);
+				}
 
-					name_op->value.name = path;
+				/* Change arg into a METHOD CALL and attach name to it */
 
-					/* Point METHODCALL/NAME to the METHOD Node */
+				acpi_ps_init_op (arg, AML_INT_METHODCALL_OP);
+				name_op->common.value.name = path;
 
-					name_op->node = method_node;
-					acpi_ps_append_arg (arg, name_op);
+				/* Point METHODCALL/NAME to the METHOD Node */
 
-					if (!method_node->object) {
-						return_VOID;
-					}
+				name_op->common.node = node;
+				acpi_ps_append_arg (arg, name_op);
 
-					*arg_count = (method_node->object)->method.param_count;
+				if (!method_desc) {
+					ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
+						"Control Method - %p has no attached object\n",
+						node));
+					return_ACPI_STATUS (AE_AML_INTERNAL);
 				}
 
-				return_VOID;
+				ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
+					"Control Method - %p Args %X\n",
+					node, method_desc->method.param_count));
+
+				/* Get the number of arguments to expect */
+
+				walk_state->arg_count = method_desc->method.param_count;
+				return_ACPI_STATUS (AE_OK);
 			}
 
 			/*
@@ -407,28 +337,53 @@ acpi_ps_get_next_namepath (
 			 * (See code below)
 			 */
 		}
+
+		if (ACPI_FAILURE (status)) {
+			/*
+			 * 1) Any error other than NOT_FOUND is always severe
+			 * 2) NOT_FOUND is only important if we are executing a method.
+			 * 3) If executing a cond_ref_of opcode, NOT_FOUND is ok.
+			 */
+			if ((((walk_state->parse_flags & ACPI_PARSE_MODE_MASK) == ACPI_PARSE_EXECUTE) &&
+				(status == AE_NOT_FOUND)                                                &&
+				(walk_state->op->common.aml_opcode != AML_COND_REF_OF_OP)) ||
+
+				(status != AE_NOT_FOUND)) {
+				ACPI_REPORT_NSERROR (path, status);
+
+				acpi_os_printf ("search_node %p start_node %p return_node %p\n",
+					scope_info.scope.node, parser_state->start_node, node);
+
+
+			}
+			else {
+				/*
+				 * We got a NOT_FOUND during table load or we encountered
+				 * a cond_ref_of(x) where the target does not exist.
+				 * -- either case is ok
+				 */
+				status = AE_OK;
+			}
+		}
 	}
 
 	/*
-	 * Either we didn't find the object in the namespace, or the object is
-	 * something other than a control method.  Just initialize the Op with the
-	 * pathname.
+	 * Regardless of success/failure above,
+	 * Just initialize the Op with the pathname.
 	 */
 	acpi_ps_init_op (arg, AML_INT_NAMEPATH_OP);
-	arg->value.name = path;
-
+	arg->common.value.name = path;
 
-	return_VOID;
+	return_ACPI_STATUS (status);
 }
 
-#endif
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_get_next_simple_arg
+ * FUNCTION:    acpi_ps_get_next_simple_arg
  *
- * PARAMETERS:  Parser_state        - Current parser state object
- *              Arg_type            - The argument type (AML_*_ARG)
+ * PARAMETERS:  parser_state        - Current parser state object
+ *              arg_type            - The argument type (AML_*_ARG)
  *              Arg                 - Where the argument is returned
  *
  * RETURN:      None
@@ -439,20 +394,19 @@ acpi_ps_get_next_namepath (
 
 void
 acpi_ps_get_next_simple_arg (
-	acpi_parse_state        *parser_state,
-	u32                     arg_type,
-	acpi_parse_object       *arg)
+	struct acpi_parse_state         *parser_state,
+	u32                             arg_type,
+	union acpi_parse_object         *arg)
 {
 
-	FUNCTION_TRACE_U32 ("Ps_get_next_simple_arg", arg_type);
+	ACPI_FUNCTION_TRACE_U32 ("ps_get_next_simple_arg", arg_type);
 
 
 	switch (arg_type) {
-
 	case ARGP_BYTEDATA:
 
 		acpi_ps_init_op (arg, AML_BYTE_OP);
-		arg->value.integer = (u32) GET8 (parser_state->aml);
+		arg->common.value.integer = (u32) ACPI_GET8 (parser_state->aml);
 		parser_state->aml++;
 		break;
 
@@ -463,7 +417,7 @@ acpi_ps_get_next_simple_arg (
 
 		/* Get 2 bytes from the AML stream */
 
-		MOVE_UNALIGNED16_TO_32 (&arg->value.integer, parser_state->aml);
+		ACPI_MOVE_16_TO_32 (&arg->common.value.integer, parser_state->aml);
 		parser_state->aml += 2;
 		break;
 
@@ -474,7 +428,7 @@ acpi_ps_get_next_simple_arg (
 
 		/* Get 4 bytes from the AML stream */
 
-		MOVE_UNALIGNED32_TO_32 (&arg->value.integer, parser_state->aml);
+		ACPI_MOVE_32_TO_32 (&arg->common.value.integer, parser_state->aml);
 		parser_state->aml += 4;
 		break;
 
@@ -485,7 +439,7 @@ acpi_ps_get_next_simple_arg (
 
 		/* Get 8 bytes from the AML stream */
 
-		MOVE_UNALIGNED64_TO_64 (&arg->value.integer, parser_state->aml);
+		ACPI_MOVE_64_TO_64 (&arg->common.value.integer, parser_state->aml);
 		parser_state->aml += 8;
 		break;
 
@@ -493,9 +447,9 @@ acpi_ps_get_next_simple_arg (
 	case ARGP_CHARLIST:
 
 		acpi_ps_init_op (arg, AML_STRING_OP);
-		arg->value.string = (char*) parser_state->aml;
+		arg->common.value.string = (char *) parser_state->aml;
 
-		while (GET8 (parser_state->aml) != '\0') {
+		while (ACPI_GET8 (parser_state->aml) != '\0') {
 			parser_state->aml++;
 		}
 		parser_state->aml++;
@@ -506,7 +460,13 @@ acpi_ps_get_next_simple_arg (
 	case ARGP_NAMESTRING:
 
 		acpi_ps_init_op (arg, AML_INT_NAMEPATH_OP);
-		arg->value.name = acpi_ps_get_next_namestring (parser_state);
+		arg->common.value.name = acpi_ps_get_next_namestring (parser_state);
+		break;
+
+
+	default:
+
+		ACPI_REPORT_ERROR (("Invalid arg_type %X\n", arg_type));
 		break;
 	}
 
@@ -516,47 +476,44 @@ acpi_ps_get_next_simple_arg (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_get_next_field
+ * FUNCTION:    acpi_ps_get_next_field
  *
- * PARAMETERS:  Parser_state        - Current parser state object
+ * PARAMETERS:  parser_state        - Current parser state object
  *
  * RETURN:      A newly allocated FIELD op
  *
- * DESCRIPTION: Get next field (Named_field, Reserved_field, or Access_field)
+ * DESCRIPTION: Get next field (named_field, reserved_field, or access_field)
  *
  ******************************************************************************/
 
-acpi_parse_object *
+union acpi_parse_object *
 acpi_ps_get_next_field (
-	acpi_parse_state        *parser_state)
+	struct acpi_parse_state         *parser_state)
 {
-	u32                     aml_offset = parser_state->aml -
-			 parser_state->aml_start;
-	acpi_parse_object       *field;
-	u16                     opcode;
-	u32                     name;
+	u32                             aml_offset = ACPI_PTR_DIFF (parser_state->aml,
+			 parser_state->aml_start);
+	union acpi_parse_object         *field;
+	u16                             opcode;
+	u32                             name;
 
 
-	FUNCTION_TRACE ("Ps_get_next_field");
+	ACPI_FUNCTION_TRACE ("ps_get_next_field");
 
 
 	/* determine field type */
 
-	switch (GET8 (parser_state->aml)) {
-
+	switch (ACPI_GET8 (parser_state->aml)) {
 	default:
 
 		opcode = AML_INT_NAMEDFIELD_OP;
 		break;
 
-
 	case 0x00:
 
 		opcode = AML_INT_RESERVEDFIELD_OP;
 		parser_state->aml++;
 		break;
 
-
 	case 0x01:
 
 		opcode = AML_INT_ACCESSFIELD_OP;
@@ -568,43 +525,53 @@ acpi_ps_get_next_field (
 	/* Allocate a new field op */
 
 	field = acpi_ps_alloc_op (opcode);
-	if (field) {
-		field->aml_offset = aml_offset;
+	if (!field) {
+		return_PTR (NULL);
+	}
 
-		/* Decode the field type */
+	field->common.aml_offset = aml_offset;
 
-		switch (opcode) {
-		case AML_INT_NAMEDFIELD_OP:
+	/* Decode the field type */
 
-			/* Get the 4-character name */
+	switch (opcode) {
+	case AML_INT_NAMEDFIELD_OP:
 
-			MOVE_UNALIGNED32_TO_32 (&name, parser_state->aml);
-			acpi_ps_set_name (field, name);
-			parser_state->aml += 4;
+		/* Get the 4-character name */
 
-			/* Get the length which is encoded as a package length */
+		ACPI_MOVE_32_TO_32 (&name, parser_state->aml);
+		acpi_ps_set_name (field, name);
+		parser_state->aml += ACPI_NAME_SIZE;
 
-			field->value.size = acpi_ps_get_next_package_length (parser_state);
-			break;
+		/* Get the length which is encoded as a package length */
 
+		field->common.value.size = acpi_ps_get_next_package_length (parser_state);
+		break;
 
-		case AML_INT_RESERVEDFIELD_OP:
 
-			/* Get the length which is encoded as a package length */
+	case AML_INT_RESERVEDFIELD_OP:
 
-			field->value.size = acpi_ps_get_next_package_length (parser_state);
-			break;
+		/* Get the length which is encoded as a package length */
 
+		field->common.value.size = acpi_ps_get_next_package_length (parser_state);
+		break;
 
-		case AML_INT_ACCESSFIELD_OP:
 
-			/* Get Access_type and Access_atrib and merge into the field Op */
+	case AML_INT_ACCESSFIELD_OP:
 
-			field->value.integer = ((GET8 (parser_state->aml) << 8) |
-					  GET8 (parser_state->aml));
-			parser_state->aml += 2;
-			break;
-		}
+		/*
+		 * Get access_type and access_attrib and merge into the field Op
+		 * access_type is first operand, access_attribute is second
+		 */
+		field->common.value.integer = (ACPI_GET8 (parser_state->aml) << 8);
+		parser_state->aml++;
+		field->common.value.integer |= ACPI_GET8 (parser_state->aml);
+		parser_state->aml++;
+		break;
+
+	default:
+
+		/* Opcode was set in previous switch */
+		break;
 	}
 
 	return_PTR (field);
@@ -613,33 +580,35 @@ acpi_ps_get_next_field (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_get_next_arg
+ * FUNCTION:    acpi_ps_get_next_arg
  *
- * PARAMETERS:  Parser_state        - Current parser state object
- *              Arg_type            - The argument type (AML_*_ARG)
- *              Arg_count           - If the argument points to a control method
+ * PARAMETERS:  parser_state        - Current parser state object
+ *              arg_type            - The argument type (AML_*_ARG)
+ *              arg_count           - If the argument points to a control method
  *                                    the method's argument is returned here.
  *
- * RETURN:      An op object containing the next argument.
+ * RETURN:      Status, and an op object containing the next argument.
  *
  * DESCRIPTION: Get next argument (including complex list arguments that require
  *              pushing the parser stack)
  *
  ******************************************************************************/
 
-acpi_parse_object *
+acpi_status
 acpi_ps_get_next_arg (
-	acpi_parse_state        *parser_state,
-	u32                     arg_type,
-	u32                     *arg_count)
+	struct acpi_walk_state          *walk_state,
+	struct acpi_parse_state         *parser_state,
+	u32                             arg_type,
+	union acpi_parse_object         **return_arg)
 {
-	acpi_parse_object       *arg = NULL;
-	acpi_parse_object       *prev = NULL;
-	acpi_parse_object       *field;
-	u32                     subop;
+	union acpi_parse_object         *arg = NULL;
+	union acpi_parse_object         *prev = NULL;
+	union acpi_parse_object         *field;
+	u32                             subop;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE_PTR ("Ps_get_next_arg", parser_state);
+	ACPI_FUNCTION_TRACE_PTR ("ps_get_next_arg", parser_state);
 
 
 	switch (arg_type) {
@@ -653,15 +622,16 @@ acpi_ps_get_next_arg (
 		/* constants, strings, and namestrings are all the same size */
 
 		arg = acpi_ps_alloc_op (AML_BYTE_OP);
-		if (arg) {
-			acpi_ps_get_next_simple_arg (parser_state, arg_type, arg);
+		if (!arg) {
+			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
+		acpi_ps_get_next_simple_arg (parser_state, arg_type, arg);
 		break;
 
 
 	case ARGP_PKGLENGTH:
 
-		/* package length, nothing returned */
+		/* Package length, nothing returned */
 
 		parser_state->pkg_end = acpi_ps_get_next_package_end (parser_state);
 		break;
@@ -670,18 +640,17 @@ acpi_ps_get_next_arg (
 	case ARGP_FIELDLIST:
 
 		if (parser_state->aml < parser_state->pkg_end) {
-			/* non-empty list */
+			/* Non-empty list */
 
 			while (parser_state->aml < parser_state->pkg_end) {
 				field = acpi_ps_get_next_field (parser_state);
 				if (!field) {
-					break;
+					return_ACPI_STATUS (AE_NO_MEMORY);
 				}
 
 				if (prev) {
-					prev->next = field;
+					prev->common.next = field;
 				}
-
 				else {
 					arg = field;
 				}
@@ -689,7 +658,7 @@ acpi_ps_get_next_arg (
 				prev = field;
 			}
 
-			/* skip to End of byte data */
+			/* Skip to End of byte data */
 
 			parser_state->aml = parser_state->pkg_end;
 		}
@@ -699,17 +668,20 @@ acpi_ps_get_next_arg (
 	case ARGP_BYTELIST:
 
 		if (parser_state->aml < parser_state->pkg_end) {
-			/* non-empty list */
+			/* Non-empty list */
 
 			arg = acpi_ps_alloc_op (AML_INT_BYTELIST_OP);
-			if (arg) {
-				/* fill in bytelist data */
-
-				arg->value.size = (parser_state->pkg_end - parser_state->aml);
-				((acpi_parse2_object *) arg)->data = parser_state->aml;
+			if (!arg) {
+				return_ACPI_STATUS (AE_NO_MEMORY);
 			}
 
-			/* skip to End of byte data */
+			/* Fill in bytelist data */
+
+			arg->common.value.size = ACPI_PTR_DIFF (parser_state->pkg_end,
+					  parser_state->aml);
+			arg->named.data = parser_state->aml;
+
+			/* Skip to End of byte data */
 
 			parser_state->aml = parser_state->pkg_end;
 		}
@@ -717,24 +689,26 @@ acpi_ps_get_next_arg (
 
 
 	case ARGP_TARGET:
-	case ARGP_SUPERNAME: {
-			subop = acpi_ps_peek_opcode (parser_state);
-			if (subop == 0              ||
-				acpi_ps_is_leading_char (subop) ||
-				acpi_ps_is_prefix_char (subop)) {
-				/* Null_name or Name_string */
-
-				arg = acpi_ps_alloc_op (AML_INT_NAMEPATH_OP);
-				if (arg) {
-					acpi_ps_get_next_namepath (parser_state, arg, arg_count, 0);
-				}
+	case ARGP_SUPERNAME:
+	case ARGP_SIMPLENAME:
+
+		subop = acpi_ps_peek_opcode (parser_state);
+		if (subop == 0                  ||
+			acpi_ps_is_leading_char (subop) ||
+			acpi_ps_is_prefix_char (subop)) {
+			/* null_name or name_string */
+
+			arg = acpi_ps_alloc_op (AML_INT_NAMEPATH_OP);
+			if (!arg) {
+				return_ACPI_STATUS (AE_NO_MEMORY);
 			}
 
-			else {
-				/* single complex argument, nothing returned */
+			status = acpi_ps_get_next_namepath (walk_state, parser_state, arg, 0);
+		}
+		else {
+			/* single complex argument, nothing returned */
 
-				*arg_count = 1;
-			}
+			walk_state->arg_count = 1;
 		}
 		break;
 
@@ -744,7 +718,7 @@ acpi_ps_get_next_arg (
 
 		/* single complex argument, nothing returned */
 
-		*arg_count = 1;
+		walk_state->arg_count = 1;
 		break;
 
 
@@ -755,10 +729,18 @@ acpi_ps_get_next_arg (
 		if (parser_state->aml < parser_state->pkg_end) {
 			/* non-empty list of variable arguments, nothing returned */
 
-			*arg_count = ACPI_VAR_ARGS;
+			walk_state->arg_count = ACPI_VAR_ARGS;
 		}
 		break;
+
+
+	default:
+
+		ACPI_REPORT_ERROR (("Invalid arg_type: %X\n", arg_type));
+		status = AE_AML_OPERAND_TYPE;
+		break;
 	}
 
-	return_PTR (arg);
+	*return_arg = arg;
+	return_ACPI_STATUS (status);
 }
diff -urNp linux-5400/drivers/acpi/parser/psopcode.c linux-5410/drivers/acpi/parser/psopcode.c
--- linux-5400/drivers/acpi/parser/psopcode.c
+++ linux-5410/drivers/acpi/parser/psopcode.c
@@ -1,36 +1,54 @@
 /******************************************************************************
  *
  * Module Name: psopcode - Parser/Interpreter opcode information table
- *              $Revision: 49 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
-#include "amlcode.h"
+#include <acpi/acpi.h>
+#include <acpi/acparser.h>
+#include <acpi/amlcode.h>
 
 
 #define _COMPONENT          ACPI_PARSER
-	 MODULE_NAME         ("psopcode")
+	 ACPI_MODULE_NAME    ("psopcode")
 
 
 #define _UNK                        0x6B
@@ -45,14 +63,14 @@
 #define _UNKNOWN_OPCODE             0x02    /* An example unknown opcode */
 
 #define MAX_EXTENDED_OPCODE         0x88
-#define NUM_EXTENDED_OPCODE         MAX_EXTENDED_OPCODE + 1
+#define NUM_EXTENDED_OPCODE         (MAX_EXTENDED_OPCODE + 1)
 #define MAX_INTERNAL_OPCODE
-#define NUM_INTERNAL_OPCODE         MAX_INTERNAL_OPCODE + 1
+#define NUM_INTERNAL_OPCODE         (MAX_INTERNAL_OPCODE + 1)
 
 
 /*******************************************************************************
  *
- * NAME:        Acpi_gbl_Aml_op_info
+ * NAME:        acpi_gbl_aml_op_info
  *
  * DESCRIPTION: Opcode table. Each entry contains <opcode, type, name, operands>
  *              The name is a simple ascii string, the operand specifier is an
@@ -184,7 +202,7 @@
 #define ARGP_TO_STRING_OP               ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
 #define ARGP_TYPE_OP                    ARGP_LIST1 (ARGP_SUPERNAME)
 #define ARGP_UNLOAD_OP                  ARGP_LIST1 (ARGP_SUPERNAME)
-#define ARGP_VAR_PACKAGE_OP             ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_BYTEDATA,      ARGP_DATAOBJLIST)
+#define ARGP_VAR_PACKAGE_OP             ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_DATAOBJLIST)
 #define ARGP_WAIT_OP                    ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_TERMARG)
 #define ARGP_WHILE_OP                   ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_TERMLIST)
 #define ARGP_WORD_OP                    ARGP_LIST1 (ARGP_WORDDATA)
@@ -195,7 +213,7 @@
  * All AML opcodes and the runtime arguments for each.  Used by the AML interpreter  Each list is compressed
  * into a 32-bit number and stored in the master opcode table at the end of this file.
  *
- * (Used by Prep_operands procedure and the ASL Compiler)
+ * (Used by prep_operands procedure and the ASL Compiler)
  */
 
 
@@ -219,7 +237,7 @@
 #define ARGI_BIT_XOR_OP                 ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
 #define ARGI_BREAK_OP                   ARG_NONE
 #define ARGI_BREAK_POINT_OP             ARG_NONE
-#define ARGI_BUFFER_OP                  ARGI_INVALID_OPCODE
+#define ARGI_BUFFER_OP                  ARGI_LIST1 (ARGI_INTEGER)
 #define ARGI_BYTE_OP                    ARGI_INVALID_OPCODE
 #define ARGI_BYTELIST_OP                ARGI_INVALID_OPCODE
 #define ARGI_CONCAT_OP                  ARGI_LIST3 (ARGI_COMPUTEDATA,ARGI_COMPUTEDATA,   ARGI_TARGETREF)
@@ -236,7 +254,7 @@
 #define ARGI_DATA_REGION_OP             ARGI_LIST3 (ARGI_STRING,     ARGI_STRING,       ARGI_STRING)
 #define ARGI_DEBUG_OP                   ARG_NONE
 #define ARGI_DECREMENT_OP               ARGI_LIST1 (ARGI_INTEGER_REF)
-#define ARGI_DEREF_OF_OP                ARGI_LIST1 (ARGI_REFERENCE)
+#define ARGI_DEREF_OF_OP                ARGI_LIST1 (ARGI_REF_OR_STRING)
 #define ARGI_DEVICE_OP                  ARGI_INVALID_OPCODE
 #define ARGI_DIVIDE_OP                  ARGI_LIST4 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF,    ARGI_TARGETREF)
 #define ARGI_DWORD_OP                   ARGI_INVALID_OPCODE
@@ -259,8 +277,8 @@
 #define ARGI_LLESSEQUAL_OP              ARGI_INVALID_OPCODE
 #define ARGI_LNOT_OP                    ARGI_LIST1 (ARGI_INTEGER)
 #define ARGI_LNOTEQUAL_OP               ARGI_INVALID_OPCODE
-#define ARGI_LOAD_OP                    ARGI_LIST2 (ARGI_REGION,     ARGI_TARGETREF)
-#define ARGI_LOAD_TABLE_OP              ARGI_LIST6 (ARGI_STRING,     ARGI_STRING,        ARGI_STRING,       ARGI_STRING,    ARGI_STRING, ARGI_TARGETREF)
+#define ARGI_LOAD_OP                    ARGI_LIST2 (ARGI_REGION_OR_FIELD,ARGI_TARGETREF)
+#define ARGI_LOAD_TABLE_OP              ARGI_LIST6 (ARGI_STRING,     ARGI_STRING,        ARGI_STRING,       ARGI_STRING,    ARGI_STRING, ARGI_ANYTYPE)
 #define ARGI_LOCAL0                     ARG_NONE
 #define ARGI_LOCAL1                     ARG_NONE
 #define ARGI_LOCAL2                     ARG_NONE
@@ -273,7 +291,7 @@
 #define ARGI_MATCH_OP                   ARGI_LIST6 (ARGI_PACKAGE,    ARGI_INTEGER,       ARGI_INTEGER,      ARGI_INTEGER,   ARGI_INTEGER,   ARGI_INTEGER)
 #define ARGI_METHOD_OP                  ARGI_INVALID_OPCODE
 #define ARGI_METHODCALL_OP              ARGI_INVALID_OPCODE
-#define ARGI_MID_OP                     ARGI_LIST4 (ARGI_BUFFERSTRING,ARGI_INTEGER,      ARGI_INTEGER,      ARGI_TARGETREF)
+#define ARGI_MID_OP                     ARGI_LIST4 (ARGI_BUFFER_OR_STRING,ARGI_INTEGER,  ARGI_INTEGER,      ARGI_TARGETREF)
 #define ARGI_MOD_OP                     ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
 #define ARGI_MULTIPLY_OP                ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
 #define ARGI_MUTEX_OP                   ARGI_INVALID_OPCODE
@@ -284,7 +302,7 @@
 #define ARGI_NOTIFY_OP                  ARGI_LIST2 (ARGI_DEVICE_REF, ARGI_INTEGER)
 #define ARGI_ONE_OP                     ARG_NONE
 #define ARGI_ONES_OP                    ARG_NONE
-#define ARGI_PACKAGE_OP                 ARGI_INVALID_OPCODE
+#define ARGI_PACKAGE_OP                 ARGI_LIST1 (ARGI_INTEGER)
 #define ARGI_POWER_RES_OP               ARGI_INVALID_OPCODE
 #define ARGI_PROCESSOR_OP               ARGI_INVALID_OPCODE
 #define ARGI_QWORD_OP                   ARGI_INVALID_OPCODE
@@ -315,7 +333,7 @@
 #define ARGI_TO_STRING_OP               ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_FIXED_TARGET)
 #define ARGI_TYPE_OP                    ARGI_LIST1 (ARGI_ANYTYPE)
 #define ARGI_UNLOAD_OP                  ARGI_LIST1 (ARGI_DDBHANDLE)
-#define ARGI_VAR_PACKAGE_OP             ARGI_INVALID_OPCODE
+#define ARGI_VAR_PACKAGE_OP             ARGI_LIST1 (ARGI_INTEGER)
 #define ARGI_WAIT_OP                    ARGI_LIST2 (ARGI_EVENT,      ARGI_INTEGER)
 #define ARGI_WHILE_OP                   ARGI_INVALID_OPCODE
 #define ARGI_WORD_OP                    ARGI_INVALID_OPCODE
@@ -328,7 +346,7 @@
 
 /******************************************************************************
 
- Opcodes that have associated namespace objects
+ Opcodes that have associated namespace objects (AML_NSOBJECT flag)
 
 	AML_SCOPE_OP
 	AML_DEVICE_OP
@@ -354,7 +372,7 @@
 	AML_INT_METHODCALL_OP
 	AML_INT_NAMEPATH_OP
 
-  Opcodes that are "namespace" opcodes
+  Opcodes that are "namespace" opcodes (AML_NSOPCODE flag)
 
 	AML_SCOPE_OP
 	AML_DEVICE_OP
@@ -372,7 +390,7 @@
 	AML_REGION_OP
 	AML_INT_NAMEDFIELD_OP
 
-  Opcodes that have an associated namespace node
+  Opcodes that have an associated namespace node (AML_NSNODE flag)
 
 	AML_SCOPE_OP
 	AML_DEVICE_OP
@@ -395,7 +413,7 @@
 	AML_INT_METHODCALL_OP
 	AML_INT_NAMEPATH_OP
 
-  Opcodes that define named ACPI objects
+  Opcodes that define named ACPI objects (AML_NAMED flag)
 
 	AML_SCOPE_OP
 	AML_DEVICE_OP
@@ -410,8 +428,8 @@
 	AML_REGION_OP
 	AML_INT_NAMEDFIELD_OP
 
-	Opcodes that contain executable AML as part of the definition that
-	must be deferred until needed
+  Opcodes that contain executable AML as part of the definition that
+  must be deferred until needed
 
 	AML_METHOD_OP
 	AML_VAR_PACKAGE_OP
@@ -422,6 +440,7 @@
 	AML_CREATE_DWORD_FIELD_OP
 	AML_CREATE_QWORD_FIELD_OP
 	AML_REGION_OP
+	AML_BUFFER_OP
 
   Field opcodes
 
@@ -447,146 +466,149 @@
  */
 
 
-static const acpi_opcode_info    aml_op_info[] =
+const struct acpi_opcode_info     acpi_gbl_aml_op_info[AML_NUM_OPCODES] =
 {
-/* Index           Name                 Parser Args               Interpreter Args                 Class                      Type                  Flags */
+/*! [Begin] no source code translation */
+/* Index           Name                 Parser Args               Interpreter Args                ObjectType                    Class                      Type                  Flags */
 
-/* 00 */ ACPI_OP ("Zero",               ARGP_ZERO_OP,              ARGI_ZERO_OP,               AML_CLASS_ARGUMENT,        AML_TYPE_CONSTANT,        0),
-/* 01 */ ACPI_OP ("One",                ARGP_ONE_OP,               ARGI_ONE_OP,                AML_CLASS_ARGUMENT,        AML_TYPE_CONSTANT,        0),
-/* 02 */ ACPI_OP ("Alias",              ARGP_ALIAS_OP,             ARGI_ALIAS_OP,              AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_SIMPLE,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
-/* 03 */ ACPI_OP ("Name",               ARGP_NAME_OP,              ARGI_NAME_OP,               AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_COMPLEX,   AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
-/* 04 */ ACPI_OP ("Byte_const",         ARGP_BYTE_OP,              ARGI_BYTE_OP,               AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         0),
-/* 05 */ ACPI_OP ("Word_const",         ARGP_WORD_OP,              ARGI_WORD_OP,               AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         0),
-/* 06 */ ACPI_OP ("Dword_const",        ARGP_DWORD_OP,             ARGI_DWORD_OP,              AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         0),
-/* 07 */ ACPI_OP ("String",             ARGP_STRING_OP,            ARGI_STRING_OP,             AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         0),
-/* 08 */ ACPI_OP ("Scope",              ARGP_SCOPE_OP,             ARGI_SCOPE_OP,              AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_NO_OBJ,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
-/* 09 */ ACPI_OP ("Buffer",             ARGP_BUFFER_OP,            ARGI_BUFFER_OP,             AML_CLASS_ARGUMENT,        AML_TYPE_DATA_TERM,       AML_HAS_ARGS),
-/* 0A */ ACPI_OP ("Package",            ARGP_PACKAGE_OP,           ARGI_PACKAGE_OP,            AML_CLASS_ARGUMENT,        AML_TYPE_DATA_TERM,       AML_HAS_ARGS),
-/* 0B */ ACPI_OP ("Method",             ARGP_METHOD_OP,            ARGI_METHOD_OP,             AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_COMPLEX,   AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED | AML_DEFER),
-/* 0C */ ACPI_OP ("Local0",             ARGP_LOCAL0,               ARGI_LOCAL0,                AML_CLASS_ARGUMENT,        AML_TYPE_LOCAL_VARIABLE,  0),
-/* 0D */ ACPI_OP ("Local1",             ARGP_LOCAL1,               ARGI_LOCAL1,                AML_CLASS_ARGUMENT,        AML_TYPE_LOCAL_VARIABLE,  0),
-/* 0E */ ACPI_OP ("Local2",             ARGP_LOCAL2,               ARGI_LOCAL2,                AML_CLASS_ARGUMENT,        AML_TYPE_LOCAL_VARIABLE,  0),
-/* 0F */ ACPI_OP ("Local3",             ARGP_LOCAL3,               ARGI_LOCAL3,                AML_CLASS_ARGUMENT,        AML_TYPE_LOCAL_VARIABLE,  0),
-/* 10 */ ACPI_OP ("Local4",             ARGP_LOCAL4,               ARGI_LOCAL4,                AML_CLASS_ARGUMENT,        AML_TYPE_LOCAL_VARIABLE,  0),
-/* 11 */ ACPI_OP ("Local5",             ARGP_LOCAL5,               ARGI_LOCAL5,                AML_CLASS_ARGUMENT,        AML_TYPE_LOCAL_VARIABLE,  0),
-/* 12 */ ACPI_OP ("Local6",             ARGP_LOCAL6,               ARGI_LOCAL6,                AML_CLASS_ARGUMENT,        AML_TYPE_LOCAL_VARIABLE,  0),
-/* 13 */ ACPI_OP ("Local7",             ARGP_LOCAL7,               ARGI_LOCAL7,                AML_CLASS_ARGUMENT,        AML_TYPE_LOCAL_VARIABLE,  0),
-/* 14 */ ACPI_OP ("Arg0",               ARGP_ARG0,                 ARGI_ARG0,                  AML_CLASS_ARGUMENT,        AML_TYPE_METHOD_ARGUMENT, 0),
-/* 15 */ ACPI_OP ("Arg1",               ARGP_ARG1,                 ARGI_ARG1,                  AML_CLASS_ARGUMENT,        AML_TYPE_METHOD_ARGUMENT, 0),
-/* 16 */ ACPI_OP ("Arg2",               ARGP_ARG2,                 ARGI_ARG2,                  AML_CLASS_ARGUMENT,        AML_TYPE_METHOD_ARGUMENT, 0),
-/* 17 */ ACPI_OP ("Arg3",               ARGP_ARG3,                 ARGI_ARG3,                  AML_CLASS_ARGUMENT,        AML_TYPE_METHOD_ARGUMENT, 0),
-/* 18 */ ACPI_OP ("Arg4",               ARGP_ARG4,                 ARGI_ARG4,                  AML_CLASS_ARGUMENT,        AML_TYPE_METHOD_ARGUMENT, 0),
-/* 19 */ ACPI_OP ("Arg5",               ARGP_ARG5,                 ARGI_ARG5,                  AML_CLASS_ARGUMENT,        AML_TYPE_METHOD_ARGUMENT, 0),
-/* 1_a */ ACPI_OP ("Arg6",              ARGP_ARG6,                 ARGI_ARG6,                  AML_CLASS_ARGUMENT,        AML_TYPE_METHOD_ARGUMENT, 0),
-/* 1_b */ ACPI_OP ("Store",             ARGP_STORE_OP,             ARGI_STORE_OP,              AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
-/* 1_c */ ACPI_OP ("Ref_of",            ARGP_REF_OF_OP,            ARGI_REF_OF_OP,             AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R),
-/* 1_d */ ACPI_OP ("Add",               ARGP_ADD_OP,               ARGI_ADD_OP,                AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH),
-/* 1_e */ ACPI_OP ("Concatenate",       ARGP_CONCAT_OP,            ARGI_CONCAT_OP,             AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R),
-/* 1_f */ ACPI_OP ("Subtract",          ARGP_SUBTRACT_OP,          ARGI_SUBTRACT_OP,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH),
-/* 20 */ ACPI_OP ("Increment",          ARGP_INCREMENT_OP,         ARGI_INCREMENT_OP,          AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R),
-/* 21 */ ACPI_OP ("Decrement",          ARGP_DECREMENT_OP,         ARGI_DECREMENT_OP,          AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R),
-/* 22 */ ACPI_OP ("Multiply",           ARGP_MULTIPLY_OP,          ARGI_MULTIPLY_OP,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH),
-/* 23 */ ACPI_OP ("Divide",             ARGP_DIVIDE_OP,            ARGI_DIVIDE_OP,             AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_2T_1R,   AML_FLAGS_EXEC_2A_2T_1R),
-/* 24 */ ACPI_OP ("Shift_left",         ARGP_SHIFT_LEFT_OP,        ARGI_SHIFT_LEFT_OP,         AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH),
-/* 25 */ ACPI_OP ("Shift_right",        ARGP_SHIFT_RIGHT_OP,       ARGI_SHIFT_RIGHT_OP,        AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH),
-/* 26 */ ACPI_OP ("And",                ARGP_BIT_AND_OP,           ARGI_BIT_AND_OP,            AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH),
-/* 27 */ ACPI_OP ("NAnd",               ARGP_BIT_NAND_OP,          ARGI_BIT_NAND_OP,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH),
-/* 28 */ ACPI_OP ("Or",                 ARGP_BIT_OR_OP,            ARGI_BIT_OR_OP,             AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH),
-/* 29 */ ACPI_OP ("NOr",                ARGP_BIT_NOR_OP,           ARGI_BIT_NOR_OP,            AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH),
-/* 2_a */ ACPI_OP ("XOr",               ARGP_BIT_XOR_OP,           ARGI_BIT_XOR_OP,            AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH),
-/* 2_b */ ACPI_OP ("Not",               ARGP_BIT_NOT_OP,           ARGI_BIT_NOT_OP,            AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
-/* 2_c */ ACPI_OP ("Find_set_left_bit", ARGP_FIND_SET_LEFT_BIT_OP, ARGI_FIND_SET_LEFT_BIT_OP,  AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
-/* 2_d */ ACPI_OP ("Find_set_right_bit", ARGP_FIND_SET_RIGHT_BIT_OP,ARGI_FIND_SET_RIGHT_BIT_OP, AML_CLASS_EXECUTE,        AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
-/* 2_e */ ACPI_OP ("Deref_of",          ARGP_DEREF_OF_OP,          ARGI_DEREF_OF_OP,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R),
-/* 2_f */ ACPI_OP ("Notify",            ARGP_NOTIFY_OP,            ARGI_NOTIFY_OP,             AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_0R,   AML_FLAGS_EXEC_2A_0T_0R),
-/* 30 */ ACPI_OP ("Size_of",            ARGP_SIZE_OF_OP,           ARGI_SIZE_OF_OP,            AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R),
-/* 31 */ ACPI_OP ("Index",              ARGP_INDEX_OP,             ARGI_INDEX_OP,              AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R),
-/* 32 */ ACPI_OP ("Match",              ARGP_MATCH_OP,             ARGI_MATCH_OP,              AML_CLASS_EXECUTE,         AML_TYPE_EXEC_6A_0T_1R,   AML_FLAGS_EXEC_6A_0T_1R),
-/* 33 */ ACPI_OP ("Create_dWord_field", ARGP_CREATE_DWORD_FIELD_OP,ARGI_CREATE_DWORD_FIELD_OP, AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
-/* 34 */ ACPI_OP ("Create_word_field",  ARGP_CREATE_WORD_FIELD_OP, ARGI_CREATE_WORD_FIELD_OP,  AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
-/* 35 */ ACPI_OP ("Create_byte_field",  ARGP_CREATE_BYTE_FIELD_OP, ARGI_CREATE_BYTE_FIELD_OP,  AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
-/* 36 */ ACPI_OP ("Create_bit_field",   ARGP_CREATE_BIT_FIELD_OP,  ARGI_CREATE_BIT_FIELD_OP,   AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
-/* 37 */ ACPI_OP ("Object_type",        ARGP_TYPE_OP,              ARGI_TYPE_OP,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R),
-/* 38 */ ACPI_OP ("LAnd",               ARGP_LAND_OP,              ARGI_LAND_OP,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL),
-/* 39 */ ACPI_OP ("LOr",                ARGP_LOR_OP,               ARGI_LOR_OP,                AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL),
-/* 3_a */ ACPI_OP ("LNot",              ARGP_LNOT_OP,              ARGI_LNOT_OP,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R),
-/* 3_b */ ACPI_OP ("LEqual",            ARGP_LEQUAL_OP,            ARGI_LEQUAL_OP,             AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL),
-/* 3_c */ ACPI_OP ("LGreater",          ARGP_LGREATER_OP,          ARGI_LGREATER_OP,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL),
-/* 3_d */ ACPI_OP ("LLess",             ARGP_LLESS_OP,             ARGI_LLESS_OP,              AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL),
-/* 3_e */ ACPI_OP ("If",                ARGP_IF_OP,                ARGI_IF_OP,                 AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         AML_HAS_ARGS),
-/* 3_f */ ACPI_OP ("Else",              ARGP_ELSE_OP,              ARGI_ELSE_OP,               AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         AML_HAS_ARGS),
-/* 40 */ ACPI_OP ("While",              ARGP_WHILE_OP,             ARGI_WHILE_OP,              AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         AML_HAS_ARGS),
-/* 41 */ ACPI_OP ("Noop",               ARGP_NOOP_OP,              ARGI_NOOP_OP,               AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         0),
-/* 42 */ ACPI_OP ("Return",             ARGP_RETURN_OP,            ARGI_RETURN_OP,             AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         AML_HAS_ARGS),
-/* 43 */ ACPI_OP ("Break",              ARGP_BREAK_OP,             ARGI_BREAK_OP,              AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         0),
-/* 44 */ ACPI_OP ("Break_point",        ARGP_BREAK_POINT_OP,       ARGI_BREAK_POINT_OP,        AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         0),
-/* 45 */ ACPI_OP ("Ones",               ARGP_ONES_OP,              ARGI_ONES_OP,               AML_CLASS_ARGUMENT,        AML_TYPE_CONSTANT,        0),
+/* 00 */ ACPI_OP ("Zero",               ARGP_ZERO_OP,              ARGI_ZERO_OP,               ACPI_TYPE_INTEGER,           AML_CLASS_ARGUMENT,        AML_TYPE_CONSTANT,        AML_CONSTANT),
+/* 01 */ ACPI_OP ("One",                ARGP_ONE_OP,               ARGI_ONE_OP,                ACPI_TYPE_INTEGER,           AML_CLASS_ARGUMENT,        AML_TYPE_CONSTANT,        AML_CONSTANT),
+/* 02 */ ACPI_OP ("Alias",              ARGP_ALIAS_OP,             ARGI_ALIAS_OP,              ACPI_TYPE_LOCAL_ALIAS,       AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_SIMPLE,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
+/* 03 */ ACPI_OP ("Name",               ARGP_NAME_OP,              ARGI_NAME_OP,               ACPI_TYPE_ANY,               AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_COMPLEX,   AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
+/* 04 */ ACPI_OP ("ByteConst",          ARGP_BYTE_OP,              ARGI_BYTE_OP,               ACPI_TYPE_INTEGER,           AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         AML_CONSTANT),
+/* 05 */ ACPI_OP ("WordConst",          ARGP_WORD_OP,              ARGI_WORD_OP,               ACPI_TYPE_INTEGER,           AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         AML_CONSTANT),
+/* 06 */ ACPI_OP ("DwordConst",         ARGP_DWORD_OP,             ARGI_DWORD_OP,              ACPI_TYPE_INTEGER,           AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         AML_CONSTANT),
+/* 07 */ ACPI_OP ("String",             ARGP_STRING_OP,            ARGI_STRING_OP,             ACPI_TYPE_STRING,            AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         AML_CONSTANT),
+/* 08 */ ACPI_OP ("Scope",              ARGP_SCOPE_OP,             ARGI_SCOPE_OP,              ACPI_TYPE_LOCAL_SCOPE,       AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_NO_OBJ,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
+/* 09 */ ACPI_OP ("Buffer",             ARGP_BUFFER_OP,            ARGI_BUFFER_OP,             ACPI_TYPE_BUFFER,            AML_CLASS_CREATE,          AML_TYPE_CREATE_OBJECT,   AML_HAS_ARGS | AML_DEFER | AML_CONSTANT),
+/* 0A */ ACPI_OP ("Package",            ARGP_PACKAGE_OP,           ARGI_PACKAGE_OP,            ACPI_TYPE_PACKAGE,           AML_CLASS_CREATE,          AML_TYPE_CREATE_OBJECT,   AML_HAS_ARGS | AML_DEFER | AML_CONSTANT),
+/* 0B */ ACPI_OP ("Method",             ARGP_METHOD_OP,            ARGI_METHOD_OP,             ACPI_TYPE_METHOD,            AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_COMPLEX,   AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED | AML_DEFER),
+/* 0C */ ACPI_OP ("Local0",             ARGP_LOCAL0,               ARGI_LOCAL0,                ACPI_TYPE_LOCAL_REFERENCE,   AML_CLASS_ARGUMENT,        AML_TYPE_LOCAL_VARIABLE,  0),
+/* 0D */ ACPI_OP ("Local1",             ARGP_LOCAL1,               ARGI_LOCAL1,                ACPI_TYPE_LOCAL_REFERENCE,   AML_CLASS_ARGUMENT,        AML_TYPE_LOCAL_VARIABLE,  0),
+/* 0E */ ACPI_OP ("Local2",             ARGP_LOCAL2,               ARGI_LOCAL2,                ACPI_TYPE_LOCAL_REFERENCE,   AML_CLASS_ARGUMENT,        AML_TYPE_LOCAL_VARIABLE,  0),
+/* 0F */ ACPI_OP ("Local3",             ARGP_LOCAL3,               ARGI_LOCAL3,                ACPI_TYPE_LOCAL_REFERENCE,   AML_CLASS_ARGUMENT,        AML_TYPE_LOCAL_VARIABLE,  0),
+/* 10 */ ACPI_OP ("Local4",             ARGP_LOCAL4,               ARGI_LOCAL4,                ACPI_TYPE_LOCAL_REFERENCE,   AML_CLASS_ARGUMENT,        AML_TYPE_LOCAL_VARIABLE,  0),
+/* 11 */ ACPI_OP ("Local5",             ARGP_LOCAL5,               ARGI_LOCAL5,                ACPI_TYPE_LOCAL_REFERENCE,   AML_CLASS_ARGUMENT,        AML_TYPE_LOCAL_VARIABLE,  0),
+/* 12 */ ACPI_OP ("Local6",             ARGP_LOCAL6,               ARGI_LOCAL6,                ACPI_TYPE_LOCAL_REFERENCE,   AML_CLASS_ARGUMENT,        AML_TYPE_LOCAL_VARIABLE,  0),
+/* 13 */ ACPI_OP ("Local7",             ARGP_LOCAL7,               ARGI_LOCAL7,                ACPI_TYPE_LOCAL_REFERENCE,   AML_CLASS_ARGUMENT,        AML_TYPE_LOCAL_VARIABLE,  0),
+/* 14 */ ACPI_OP ("Arg0",               ARGP_ARG0,                 ARGI_ARG0,                  ACPI_TYPE_LOCAL_REFERENCE,   AML_CLASS_ARGUMENT,        AML_TYPE_METHOD_ARGUMENT, 0),
+/* 15 */ ACPI_OP ("Arg1",               ARGP_ARG1,                 ARGI_ARG1,                  ACPI_TYPE_LOCAL_REFERENCE,   AML_CLASS_ARGUMENT,        AML_TYPE_METHOD_ARGUMENT, 0),
+/* 16 */ ACPI_OP ("Arg2",               ARGP_ARG2,                 ARGI_ARG2,                  ACPI_TYPE_LOCAL_REFERENCE,   AML_CLASS_ARGUMENT,        AML_TYPE_METHOD_ARGUMENT, 0),
+/* 17 */ ACPI_OP ("Arg3",               ARGP_ARG3,                 ARGI_ARG3,                  ACPI_TYPE_LOCAL_REFERENCE,   AML_CLASS_ARGUMENT,        AML_TYPE_METHOD_ARGUMENT, 0),
+/* 18 */ ACPI_OP ("Arg4",               ARGP_ARG4,                 ARGI_ARG4,                  ACPI_TYPE_LOCAL_REFERENCE,   AML_CLASS_ARGUMENT,        AML_TYPE_METHOD_ARGUMENT, 0),
+/* 19 */ ACPI_OP ("Arg5",               ARGP_ARG5,                 ARGI_ARG5,                  ACPI_TYPE_LOCAL_REFERENCE,   AML_CLASS_ARGUMENT,        AML_TYPE_METHOD_ARGUMENT, 0),
+/* 1A */ ACPI_OP ("Arg6",               ARGP_ARG6,                 ARGI_ARG6,                  ACPI_TYPE_LOCAL_REFERENCE,   AML_CLASS_ARGUMENT,        AML_TYPE_METHOD_ARGUMENT, 0),
+/* 1B */ ACPI_OP ("Store",              ARGP_STORE_OP,             ARGI_STORE_OP,              ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
+/* 1C */ ACPI_OP ("RefOf",              ARGP_REF_OF_OP,            ARGI_REF_OF_OP,             ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R),
+/* 1D */ ACPI_OP ("Add",                ARGP_ADD_OP,               ARGI_ADD_OP,                ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 1E */ ACPI_OP ("Concatenate",        ARGP_CONCAT_OP,            ARGI_CONCAT_OP,             ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_CONSTANT),
+/* 1F */ ACPI_OP ("Subtract",           ARGP_SUBTRACT_OP,          ARGI_SUBTRACT_OP,           ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 20 */ ACPI_OP ("Increment",          ARGP_INCREMENT_OP,         ARGI_INCREMENT_OP,          ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R | AML_CONSTANT),
+/* 21 */ ACPI_OP ("Decrement",          ARGP_DECREMENT_OP,         ARGI_DECREMENT_OP,          ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R | AML_CONSTANT),
+/* 22 */ ACPI_OP ("Multiply",           ARGP_MULTIPLY_OP,          ARGI_MULTIPLY_OP,           ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 23 */ ACPI_OP ("Divide",             ARGP_DIVIDE_OP,            ARGI_DIVIDE_OP,             ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_2T_1R,   AML_FLAGS_EXEC_2A_2T_1R | AML_CONSTANT),
+/* 24 */ ACPI_OP ("ShiftLeft",          ARGP_SHIFT_LEFT_OP,        ARGI_SHIFT_LEFT_OP,         ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 25 */ ACPI_OP ("ShiftRight",         ARGP_SHIFT_RIGHT_OP,       ARGI_SHIFT_RIGHT_OP,        ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 26 */ ACPI_OP ("And",                ARGP_BIT_AND_OP,           ARGI_BIT_AND_OP,            ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 27 */ ACPI_OP ("NAnd",               ARGP_BIT_NAND_OP,          ARGI_BIT_NAND_OP,           ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 28 */ ACPI_OP ("Or",                 ARGP_BIT_OR_OP,            ARGI_BIT_OR_OP,             ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 29 */ ACPI_OP ("NOr",                ARGP_BIT_NOR_OP,           ARGI_BIT_NOR_OP,            ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 2A */ ACPI_OP ("XOr",                ARGP_BIT_XOR_OP,           ARGI_BIT_XOR_OP,            ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 2B */ ACPI_OP ("Not",                ARGP_BIT_NOT_OP,           ARGI_BIT_NOT_OP,            ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 2C */ ACPI_OP ("FindSetLeftBit",     ARGP_FIND_SET_LEFT_BIT_OP, ARGI_FIND_SET_LEFT_BIT_OP,  ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 2D */ ACPI_OP ("FindSetRightBit",    ARGP_FIND_SET_RIGHT_BIT_OP,ARGI_FIND_SET_RIGHT_BIT_OP, ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 2E */ ACPI_OP ("DerefOf",            ARGP_DEREF_OF_OP,          ARGI_DEREF_OF_OP,           ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R),
+/* 2F */ ACPI_OP ("Notify",             ARGP_NOTIFY_OP,            ARGI_NOTIFY_OP,             ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_0R,   AML_FLAGS_EXEC_2A_0T_0R),
+/* 30 */ ACPI_OP ("SizeOf",             ARGP_SIZE_OF_OP,           ARGI_SIZE_OF_OP,            ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R),
+/* 31 */ ACPI_OP ("Index",              ARGP_INDEX_OP,             ARGI_INDEX_OP,              ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_CONSTANT),
+/* 32 */ ACPI_OP ("Match",              ARGP_MATCH_OP,             ARGI_MATCH_OP,              ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_6A_0T_1R,   AML_FLAGS_EXEC_6A_0T_1R | AML_CONSTANT),
+/* 33 */ ACPI_OP ("CreateDWordField",   ARGP_CREATE_DWORD_FIELD_OP,ARGI_CREATE_DWORD_FIELD_OP, ACPI_TYPE_BUFFER_FIELD,      AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
+/* 34 */ ACPI_OP ("CreateWordField",    ARGP_CREATE_WORD_FIELD_OP, ARGI_CREATE_WORD_FIELD_OP,  ACPI_TYPE_BUFFER_FIELD,      AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
+/* 35 */ ACPI_OP ("CreateByteField",    ARGP_CREATE_BYTE_FIELD_OP, ARGI_CREATE_BYTE_FIELD_OP,  ACPI_TYPE_BUFFER_FIELD,      AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
+/* 36 */ ACPI_OP ("CreateBitField",     ARGP_CREATE_BIT_FIELD_OP,  ARGI_CREATE_BIT_FIELD_OP,   ACPI_TYPE_BUFFER_FIELD,      AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
+/* 37 */ ACPI_OP ("ObjectType",         ARGP_TYPE_OP,              ARGI_TYPE_OP,               ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R),
+/* 38 */ ACPI_OP ("LAnd",               ARGP_LAND_OP,              ARGI_LAND_OP,               ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL | AML_CONSTANT),
+/* 39 */ ACPI_OP ("LOr",                ARGP_LOR_OP,               ARGI_LOR_OP,                ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL | AML_CONSTANT),
+/* 3A */ ACPI_OP ("LNot",               ARGP_LNOT_OP,              ARGI_LNOT_OP,               ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R | AML_CONSTANT),
+/* 3B */ ACPI_OP ("LEqual",             ARGP_LEQUAL_OP,            ARGI_LEQUAL_OP,             ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL | AML_CONSTANT),
+/* 3C */ ACPI_OP ("LGreater",           ARGP_LGREATER_OP,          ARGI_LGREATER_OP,           ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL | AML_CONSTANT),
+/* 3D */ ACPI_OP ("LLess",              ARGP_LLESS_OP,             ARGI_LLESS_OP,              ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL | AML_CONSTANT),
+/* 3E */ ACPI_OP ("If",                 ARGP_IF_OP,                ARGI_IF_OP,                 ACPI_TYPE_ANY,               AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         AML_HAS_ARGS),
+/* 3F */ ACPI_OP ("Else",               ARGP_ELSE_OP,              ARGI_ELSE_OP,               ACPI_TYPE_ANY,               AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         AML_HAS_ARGS),
+/* 40 */ ACPI_OP ("While",              ARGP_WHILE_OP,             ARGI_WHILE_OP,              ACPI_TYPE_ANY,               AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         AML_HAS_ARGS),
+/* 41 */ ACPI_OP ("Noop",               ARGP_NOOP_OP,              ARGI_NOOP_OP,               ACPI_TYPE_ANY,               AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         0),
+/* 42 */ ACPI_OP ("Return",             ARGP_RETURN_OP,            ARGI_RETURN_OP,             ACPI_TYPE_ANY,               AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         AML_HAS_ARGS),
+/* 43 */ ACPI_OP ("Break",              ARGP_BREAK_OP,             ARGI_BREAK_OP,              ACPI_TYPE_ANY,               AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         0),
+/* 44 */ ACPI_OP ("BreakPoint",         ARGP_BREAK_POINT_OP,       ARGI_BREAK_POINT_OP,        ACPI_TYPE_ANY,               AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         0),
+/* 45 */ ACPI_OP ("Ones",               ARGP_ONES_OP,              ARGI_ONES_OP,               ACPI_TYPE_INTEGER,           AML_CLASS_ARGUMENT,        AML_TYPE_CONSTANT,        AML_CONSTANT),
 
 /* Prefixed opcodes (Two-byte opcodes with a prefix op) */
 
-/* 46 */ ACPI_OP ("Mutex",              ARGP_MUTEX_OP,             ARGI_MUTEX_OP,              AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_SIMPLE,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
-/* 47 */ ACPI_OP ("Event",              ARGP_EVENT_OP,             ARGI_EVENT_OP,              AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_SIMPLE,    AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED ),
-/* 48 */ ACPI_OP ("Cond_ref_of",        ARGP_COND_REF_OF_OP,       ARGI_COND_REF_OF_OP,        AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
-/* 49 */ ACPI_OP ("Create_field",       ARGP_CREATE_FIELD_OP,      ARGI_CREATE_FIELD_OP,       AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_FIELD | AML_CREATE),
-/* 4_a */ ACPI_OP ("Load",              ARGP_LOAD_OP,              ARGI_LOAD_OP,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_0R,   AML_FLAGS_EXEC_1A_1T_0R),
-/* 4_b */ ACPI_OP ("Stall",             ARGP_STALL_OP,             ARGI_STALL_OP,              AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_0R,   AML_FLAGS_EXEC_1A_0T_0R),
-/* 4_c */ ACPI_OP ("Sleep",             ARGP_SLEEP_OP,             ARGI_SLEEP_OP,              AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_0R,   AML_FLAGS_EXEC_1A_0T_0R),
-/* 4_d */ ACPI_OP ("Acquire",           ARGP_ACQUIRE_OP,           ARGI_ACQUIRE_OP,            AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R),
-/* 4_e */ ACPI_OP ("Signal",            ARGP_SIGNAL_OP,            ARGI_SIGNAL_OP,             AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_0R,   AML_FLAGS_EXEC_1A_0T_0R),
-/* 4_f */ ACPI_OP ("Wait",              ARGP_WAIT_OP,              ARGI_WAIT_OP,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R),
-/* 50 */ ACPI_OP ("Reset",              ARGP_RESET_OP,             ARGI_RESET_OP,              AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_0R,   AML_FLAGS_EXEC_1A_0T_0R),
-/* 51 */ ACPI_OP ("Release",            ARGP_RELEASE_OP,           ARGI_RELEASE_OP,            AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_0R,   AML_FLAGS_EXEC_1A_0T_0R),
-/* 52 */ ACPI_OP ("From_bCD",           ARGP_FROM_BCD_OP,          ARGI_FROM_BCD_OP,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
-/* 53 */ ACPI_OP ("To_bCD",             ARGP_TO_BCD_OP,            ARGI_TO_BCD_OP,             AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
-/* 54 */ ACPI_OP ("Unload",             ARGP_UNLOAD_OP,            ARGI_UNLOAD_OP,             AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_0R,   AML_FLAGS_EXEC_1A_0T_0R),
-/* 55 */ ACPI_OP ("Revision",           ARGP_REVISION_OP,          ARGI_REVISION_OP,           AML_CLASS_ARGUMENT,        AML_TYPE_CONSTANT,        0),
-/* 56 */ ACPI_OP ("Debug",              ARGP_DEBUG_OP,             ARGI_DEBUG_OP,              AML_CLASS_ARGUMENT,        AML_TYPE_CONSTANT,        0),
-/* 57 */ ACPI_OP ("Fatal",              ARGP_FATAL_OP,             ARGI_FATAL_OP,              AML_CLASS_EXECUTE,         AML_TYPE_EXEC_3A_0T_0R,   AML_FLAGS_EXEC_3A_0T_0R),
-/* 58 */ ACPI_OP ("Op_region",          ARGP_REGION_OP,            ARGI_REGION_OP,             AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_COMPLEX,   AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED | AML_DEFER),
-/* 59 */ ACPI_OP ("Field",              ARGP_FIELD_OP,             ARGI_FIELD_OP,              AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_FIELD,     AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_FIELD),
-/* 5_a */ ACPI_OP ("Device",            ARGP_DEVICE_OP,            ARGI_DEVICE_OP,             AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_NO_OBJ,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
-/* 5_b */ ACPI_OP ("Processor",         ARGP_PROCESSOR_OP,         ARGI_PROCESSOR_OP,          AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_SIMPLE,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
-/* 5_c */ ACPI_OP ("Power_resource",    ARGP_POWER_RES_OP,         ARGI_POWER_RES_OP,          AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_SIMPLE,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
-/* 5_d */ ACPI_OP ("Thermal_zone",      ARGP_THERMAL_ZONE_OP,      ARGI_THERMAL_ZONE_OP,       AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_NO_OBJ,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
-/* 5_e */ ACPI_OP ("Index_field",       ARGP_INDEX_FIELD_OP,       ARGI_INDEX_FIELD_OP,        AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_FIELD,     AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_FIELD),
-/* 5_f */ ACPI_OP ("Bank_field",        ARGP_BANK_FIELD_OP,        ARGI_BANK_FIELD_OP,         AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_FIELD,     AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_FIELD),
+/* 46 */ ACPI_OP ("Mutex",              ARGP_MUTEX_OP,             ARGI_MUTEX_OP,              ACPI_TYPE_MUTEX,             AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_SIMPLE,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
+/* 47 */ ACPI_OP ("Event",              ARGP_EVENT_OP,             ARGI_EVENT_OP,              ACPI_TYPE_EVENT,             AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_SIMPLE,    AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED ),
+/* 48 */ ACPI_OP ("CondRefOf",          ARGP_COND_REF_OF_OP,       ARGI_COND_REF_OF_OP,        ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
+/* 49 */ ACPI_OP ("CreateField",        ARGP_CREATE_FIELD_OP,      ARGI_CREATE_FIELD_OP,       ACPI_TYPE_BUFFER_FIELD,      AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_FIELD | AML_CREATE),
+/* 4A */ ACPI_OP ("Load",               ARGP_LOAD_OP,              ARGI_LOAD_OP,               ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_0R,   AML_FLAGS_EXEC_1A_1T_0R),
+/* 4B */ ACPI_OP ("Stall",              ARGP_STALL_OP,             ARGI_STALL_OP,              ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_0R,   AML_FLAGS_EXEC_1A_0T_0R),
+/* 4C */ ACPI_OP ("Sleep",              ARGP_SLEEP_OP,             ARGI_SLEEP_OP,              ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_0R,   AML_FLAGS_EXEC_1A_0T_0R),
+/* 4D */ ACPI_OP ("Acquire",            ARGP_ACQUIRE_OP,           ARGI_ACQUIRE_OP,            ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R),
+/* 4E */ ACPI_OP ("Signal",             ARGP_SIGNAL_OP,            ARGI_SIGNAL_OP,             ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_0R,   AML_FLAGS_EXEC_1A_0T_0R),
+/* 4F */ ACPI_OP ("Wait",               ARGP_WAIT_OP,              ARGI_WAIT_OP,               ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R),
+/* 50 */ ACPI_OP ("Reset",              ARGP_RESET_OP,             ARGI_RESET_OP,              ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_0R,   AML_FLAGS_EXEC_1A_0T_0R),
+/* 51 */ ACPI_OP ("Release",            ARGP_RELEASE_OP,           ARGI_RELEASE_OP,            ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_0R,   AML_FLAGS_EXEC_1A_0T_0R),
+/* 52 */ ACPI_OP ("FromBCD",            ARGP_FROM_BCD_OP,          ARGI_FROM_BCD_OP,           ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 53 */ ACPI_OP ("ToBCD",              ARGP_TO_BCD_OP,            ARGI_TO_BCD_OP,             ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 54 */ ACPI_OP ("Unload",             ARGP_UNLOAD_OP,            ARGI_UNLOAD_OP,             ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_0R,   AML_FLAGS_EXEC_1A_0T_0R),
+/* 55 */ ACPI_OP ("Revision",           ARGP_REVISION_OP,          ARGI_REVISION_OP,           ACPI_TYPE_INTEGER,           AML_CLASS_ARGUMENT,        AML_TYPE_CONSTANT,        0),
+/* 56 */ ACPI_OP ("Debug",              ARGP_DEBUG_OP,             ARGI_DEBUG_OP,              ACPI_TYPE_LOCAL_REFERENCE,   AML_CLASS_ARGUMENT,        AML_TYPE_CONSTANT,        0),
+/* 57 */ ACPI_OP ("Fatal",              ARGP_FATAL_OP,             ARGI_FATAL_OP,              ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_3A_0T_0R,   AML_FLAGS_EXEC_3A_0T_0R),
+/* 58 */ ACPI_OP ("OperationRegion",    ARGP_REGION_OP,            ARGI_REGION_OP,             ACPI_TYPE_REGION,            AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_COMPLEX,   AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED | AML_DEFER),
+/* 59 */ ACPI_OP ("Field",              ARGP_FIELD_OP,             ARGI_FIELD_OP,              ACPI_TYPE_ANY,               AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_FIELD,     AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_FIELD),
+/* 5A */ ACPI_OP ("Device",             ARGP_DEVICE_OP,            ARGI_DEVICE_OP,             ACPI_TYPE_DEVICE,            AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_NO_OBJ,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
+/* 5B */ ACPI_OP ("Processor",          ARGP_PROCESSOR_OP,         ARGI_PROCESSOR_OP,          ACPI_TYPE_PROCESSOR,         AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_SIMPLE,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
+/* 5C */ ACPI_OP ("PowerResource",      ARGP_POWER_RES_OP,         ARGI_POWER_RES_OP,          ACPI_TYPE_POWER,             AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_SIMPLE,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
+/* 5D */ ACPI_OP ("ThermalZone",        ARGP_THERMAL_ZONE_OP,      ARGI_THERMAL_ZONE_OP,       ACPI_TYPE_THERMAL,           AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_NO_OBJ,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
+/* 5E */ ACPI_OP ("IndexField",         ARGP_INDEX_FIELD_OP,       ARGI_INDEX_FIELD_OP,        ACPI_TYPE_ANY,               AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_FIELD,     AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_FIELD),
+/* 5F */ ACPI_OP ("BankField",          ARGP_BANK_FIELD_OP,        ARGI_BANK_FIELD_OP,         ACPI_TYPE_ANY,               AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_FIELD,     AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_FIELD),
 
 /* Internal opcodes that map to invalid AML opcodes */
 
-/* 60 */ ACPI_OP ("LNot_equal",         ARGP_LNOTEQUAL_OP,         ARGI_LNOTEQUAL_OP,          AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           AML_HAS_ARGS),
-/* 61 */ ACPI_OP ("LLess_equal",        ARGP_LLESSEQUAL_OP,        ARGI_LLESSEQUAL_OP,         AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           AML_HAS_ARGS),
-/* 62 */ ACPI_OP ("LGreater_equal",     ARGP_LGREATEREQUAL_OP,     ARGI_LGREATEREQUAL_OP,      AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           AML_HAS_ARGS),
-/* 63 */ ACPI_OP ("[Name_path]",        ARGP_NAMEPATH_OP,          ARGI_NAMEPATH_OP,           AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         AML_NSOBJECT | AML_NSNODE ),
-/* 64 */ ACPI_OP ("[Method_call]",      ARGP_METHODCALL_OP,        ARGI_METHODCALL_OP,         AML_CLASS_METHOD_CALL,     AML_TYPE_METHOD_CALL,     AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE),
-/* 65 */ ACPI_OP ("[Byte_list]",        ARGP_BYTELIST_OP,          ARGI_BYTELIST_OP,           AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         0),
-/* 66 */ ACPI_OP ("[Reserved_field]",   ARGP_RESERVEDFIELD_OP,     ARGI_RESERVEDFIELD_OP,      AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           0),
-/* 67 */ ACPI_OP ("[Named_field]",      ARGP_NAMEDFIELD_OP,        ARGI_NAMEDFIELD_OP,         AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED ),
-/* 68 */ ACPI_OP ("[Access_field]",     ARGP_ACCESSFIELD_OP,       ARGI_ACCESSFIELD_OP,        AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           0),
-/* 69 */ ACPI_OP ("[Static_string",     ARGP_STATICSTRING_OP,      ARGI_STATICSTRING_OP,       AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           0),
-/* 6_a */ ACPI_OP ("[Return Value]",    ARG_NONE,                  ARG_NONE,                   AML_CLASS_RETURN_VALUE,    AML_TYPE_RETURN,          AML_HAS_ARGS | AML_HAS_RETVAL),
-/* 6_b */ ACPI_OP ("UNKNOWN_OP!",       ARG_NONE,                  ARG_NONE,                   AML_CLASS_UNKNOWN,         AML_TYPE_BOGUS,           AML_HAS_ARGS),
-/* 6_c */ ACPI_OP ("ASCII_ONLY!",       ARG_NONE,                  ARG_NONE,                   AML_CLASS_ASCII,           AML_TYPE_BOGUS,           AML_HAS_ARGS),
-/* 6_d */ ACPI_OP ("PREFIX_ONLY!",      ARG_NONE,                  ARG_NONE,                   AML_CLASS_PREFIX,          AML_TYPE_BOGUS,           AML_HAS_ARGS),
+/* 60 */ ACPI_OP ("LNotEqual",          ARGP_LNOTEQUAL_OP,         ARGI_LNOTEQUAL_OP,          ACPI_TYPE_ANY,               AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           AML_HAS_ARGS | AML_CONSTANT),
+/* 61 */ ACPI_OP ("LLessEqual",         ARGP_LLESSEQUAL_OP,        ARGI_LLESSEQUAL_OP,         ACPI_TYPE_ANY,               AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           AML_HAS_ARGS | AML_CONSTANT),
+/* 62 */ ACPI_OP ("LGreaterEqual",      ARGP_LGREATEREQUAL_OP,     ARGI_LGREATEREQUAL_OP,      ACPI_TYPE_ANY,               AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           AML_HAS_ARGS | AML_CONSTANT),
+/* 63 */ ACPI_OP ("-NamePath-",         ARGP_NAMEPATH_OP,          ARGI_NAMEPATH_OP,           ACPI_TYPE_LOCAL_REFERENCE,   AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         AML_NSOBJECT | AML_NSNODE ),
+/* 64 */ ACPI_OP ("-MethodCall-",       ARGP_METHODCALL_OP,        ARGI_METHODCALL_OP,         ACPI_TYPE_METHOD,            AML_CLASS_METHOD_CALL,     AML_TYPE_METHOD_CALL,     AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE),
+/* 65 */ ACPI_OP ("-ByteList-",         ARGP_BYTELIST_OP,          ARGI_BYTELIST_OP,           ACPI_TYPE_ANY,               AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         0),
+/* 66 */ ACPI_OP ("-ReservedField-",    ARGP_RESERVEDFIELD_OP,     ARGI_RESERVEDFIELD_OP,      ACPI_TYPE_ANY,               AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           0),
+/* 67 */ ACPI_OP ("-NamedField-",       ARGP_NAMEDFIELD_OP,        ARGI_NAMEDFIELD_OP,         ACPI_TYPE_ANY,               AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED ),
+/* 68 */ ACPI_OP ("-AccessField-",      ARGP_ACCESSFIELD_OP,       ARGI_ACCESSFIELD_OP,        ACPI_TYPE_ANY,               AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           0),
+/* 69 */ ACPI_OP ("-StaticString",      ARGP_STATICSTRING_OP,      ARGI_STATICSTRING_OP,       ACPI_TYPE_ANY,               AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           0),
+/* 6A */ ACPI_OP ("-Return Value-",     ARG_NONE,                  ARG_NONE,                   ACPI_TYPE_ANY,               AML_CLASS_RETURN_VALUE,    AML_TYPE_RETURN,          AML_HAS_ARGS | AML_HAS_RETVAL),
+/* 6B */ ACPI_OP ("-UNKNOWN_OP-",       ARG_NONE,                  ARG_NONE,                   ACPI_TYPE_INVALID,           AML_CLASS_UNKNOWN,         AML_TYPE_BOGUS,           AML_HAS_ARGS),
+/* 6C */ ACPI_OP ("-ASCII_ONLY-",       ARG_NONE,                  ARG_NONE,                   ACPI_TYPE_ANY,               AML_CLASS_ASCII,           AML_TYPE_BOGUS,           AML_HAS_ARGS),
+/* 6D */ ACPI_OP ("-PREFIX_ONLY-",      ARG_NONE,                  ARG_NONE,                   ACPI_TYPE_ANY,               AML_CLASS_PREFIX,          AML_TYPE_BOGUS,           AML_HAS_ARGS),
 
 
 /* ACPI 2.0 opcodes */
 
-/* 6_e */ ACPI_OP ("Qword_const",       ARGP_QWORD_OP,             ARGI_QWORD_OP,              AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         0),
-/* 6_f */ ACPI_OP ("Var_package",       ARGP_VAR_PACKAGE_OP,       ARGI_VAR_PACKAGE_OP,        AML_CLASS_ARGUMENT,        AML_TYPE_DATA_TERM,       AML_HAS_ARGS | AML_DEFER),
-/* 70 */ ACPI_OP ("Concat_res",         ARGP_CONCAT_RES_OP,        ARGI_CONCAT_RES_OP,         AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R),
-/* 71 */ ACPI_OP ("Mod",                ARGP_MOD_OP,               ARGI_MOD_OP,                AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R),
-/* 72 */ ACPI_OP ("Create_qWord_field", ARGP_CREATE_QWORD_FIELD_OP,ARGI_CREATE_QWORD_FIELD_OP, AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
-/* 73 */ ACPI_OP ("To_buffer",          ARGP_TO_BUFFER_OP,         ARGI_TO_BUFFER_OP,          AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
-/* 74 */ ACPI_OP ("To_decimal_string",  ARGP_TO_DEC_STR_OP,        ARGI_TO_DEC_STR_OP,         AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
-/* 75 */ ACPI_OP ("To_hex_string",      ARGP_TO_HEX_STR_OP,        ARGI_TO_HEX_STR_OP,         AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
-/* 76 */ ACPI_OP ("To_integer",         ARGP_TO_INTEGER_OP,        ARGI_TO_INTEGER_OP,         AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
-/* 77 */ ACPI_OP ("To_string",          ARGP_TO_STRING_OP,         ARGI_TO_STRING_OP,          AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R),
-/* 78 */ ACPI_OP ("Copy_object",        ARGP_COPY_OP,              ARGI_COPY_OP,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
-/* 79 */ ACPI_OP ("Mid",                ARGP_MID_OP,               ARGI_MID_OP,                AML_CLASS_EXECUTE,         AML_TYPE_EXEC_3A_1T_1R,   AML_FLAGS_EXEC_3A_1T_1R),
-/* 7_a */ ACPI_OP ("Continue",          ARGP_CONTINUE_OP,          ARGI_CONTINUE_OP,           AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         0),
-/* 7_b */ ACPI_OP ("Load_table",        ARGP_LOAD_TABLE_OP,        ARGI_LOAD_TABLE_OP,         AML_CLASS_EXECUTE,         AML_TYPE_EXEC_6A_0T_1R,   AML_FLAGS_EXEC_6A_0T_1R),
-/* 7_c */ ACPI_OP ("Data_op_region",    ARGP_DATA_REGION_OP,       ARGI_DATA_REGION_OP,        AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
+/* 6E */ ACPI_OP ("QwordConst",         ARGP_QWORD_OP,             ARGI_QWORD_OP,              ACPI_TYPE_INTEGER,           AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         AML_CONSTANT),
+/* 6F */ ACPI_OP ("Package /*Var*/",    ARGP_VAR_PACKAGE_OP,       ARGI_VAR_PACKAGE_OP,        ACPI_TYPE_PACKAGE,           AML_CLASS_CREATE,          AML_TYPE_CREATE_OBJECT,   AML_HAS_ARGS | AML_DEFER),
+/* 70 */ ACPI_OP ("ConcatenateResTemplate", ARGP_CONCAT_RES_OP,    ARGI_CONCAT_RES_OP,         ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_CONSTANT),
+/* 71 */ ACPI_OP ("Mod",                ARGP_MOD_OP,               ARGI_MOD_OP,                ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_CONSTANT),
+/* 72 */ ACPI_OP ("CreateQWordField",   ARGP_CREATE_QWORD_FIELD_OP,ARGI_CREATE_QWORD_FIELD_OP, ACPI_TYPE_BUFFER_FIELD,      AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
+/* 73 */ ACPI_OP ("ToBuffer",           ARGP_TO_BUFFER_OP,         ARGI_TO_BUFFER_OP,          ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 74 */ ACPI_OP ("ToDecimalString",    ARGP_TO_DEC_STR_OP,        ARGI_TO_DEC_STR_OP,         ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 75 */ ACPI_OP ("ToHexString",        ARGP_TO_HEX_STR_OP,        ARGI_TO_HEX_STR_OP,         ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 76 */ ACPI_OP ("ToInteger",          ARGP_TO_INTEGER_OP,        ARGI_TO_INTEGER_OP,         ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 77 */ ACPI_OP ("ToString",           ARGP_TO_STRING_OP,         ARGI_TO_STRING_OP,          ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_CONSTANT),
+/* 78 */ ACPI_OP ("CopyObject",         ARGP_COPY_OP,              ARGI_COPY_OP,               ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
+/* 79 */ ACPI_OP ("Mid",                ARGP_MID_OP,               ARGI_MID_OP,                ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_3A_1T_1R,   AML_FLAGS_EXEC_3A_1T_1R | AML_CONSTANT),
+/* 7A */ ACPI_OP ("Continue",           ARGP_CONTINUE_OP,          ARGI_CONTINUE_OP,           ACPI_TYPE_ANY,               AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         0),
+/* 7B */ ACPI_OP ("LoadTable",          ARGP_LOAD_TABLE_OP,        ARGI_LOAD_TABLE_OP,         ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_6A_0T_1R,   AML_FLAGS_EXEC_6A_0T_1R),
+/* 7C */ ACPI_OP ("DataTableRegion",    ARGP_DATA_REGION_OP,       ARGI_DATA_REGION_OP,        ACPI_TYPE_REGION,            AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_SIMPLE,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
+/* 7D */ ACPI_OP ("[EvalSubTree]",      ARGP_SCOPE_OP,             ARGI_SCOPE_OP,              ACPI_TYPE_ANY,               AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_NO_OBJ,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE)
 
+/*! [End] no source code translation !*/
 };
 
 /*
@@ -594,7 +616,7 @@ static const acpi_opcode_info    aml_op_
  * index into the table above
  */
 
-static const u8 aml_short_op_info_index[256] =
+static const u8 acpi_gbl_short_op_index[256] =
 {
 /*              0     1     2     3     4     5     6     7  */
 /*              8     9     A     B     C     D     E     F  */
@@ -604,7 +626,7 @@ static const u8 aml_short_op_info_index[
 /* 0x18 */	_UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
 /* 0x20 */	_UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
 /* 0x28 */	_UNK, _UNK, _UNK, _UNK, _UNK, 0x63, _PFX, _PFX,
-/* 0x30 */	0x67, 0x66, 0x68, 0x65, 0x69, 0x64, 0x6A, _UNK,
+/* 0x30 */	0x67, 0x66, 0x68, 0x65, 0x69, 0x64, 0x6A, 0x7D,
 /* 0x38 */	_UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
 /* 0x40 */	_UNK, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC,
 /* 0x48 */	_ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC,
@@ -633,7 +655,7 @@ static const u8 aml_short_op_info_index[
 };
 
 
-static const u8 aml_long_op_info_index[NUM_EXTENDED_OPCODE] =
+static const u8 acpi_gbl_long_op_index[NUM_EXTENDED_OPCODE] =
 {
 /*              0     1     2     3     4     5     6     7  */
 /*              8     9     A     B     C     D     E     F  */
@@ -660,7 +682,7 @@ static const u8 aml_long_op_info_index[N
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_get_opcode_info
+ * FUNCTION:    acpi_ps_get_opcode_info
  *
  * PARAMETERS:  Opcode              - The AML opcode
  *
@@ -672,67 +694,50 @@ static const u8 aml_long_op_info_index[N
  *
  ******************************************************************************/
 
-const acpi_opcode_info *
+const struct acpi_opcode_info *
 acpi_ps_get_opcode_info (
-	u16                     opcode)
+	u16                             opcode)
 {
-	const acpi_opcode_info  *op_info;
-	u8                      upper_opcode;
-	u8                      lower_opcode;
-
-
-	PROC_NAME ("Ps_get_opcode_info");
-
-
-	/* Split the 16-bit opcode into separate bytes */
-
-	upper_opcode = (u8) (opcode >> 8);
-	lower_opcode = (u8) opcode;
-
-	/* Default is "unknown opcode" */
-
-	op_info = &aml_op_info [_UNK];
+	ACPI_FUNCTION_NAME ("ps_get_opcode_info");
 
 
 	/*
 	 * Detect normal 8-bit opcode or extended 16-bit opcode
 	 */
-
-	switch (upper_opcode) {
+	switch ((u8) (opcode >> 8)) {
 	case 0:
 
 		/* Simple (8-bit) opcode: 0-255, can't index beyond table  */
 
-		op_info = &aml_op_info [aml_short_op_info_index [lower_opcode]];
-		break;
-
+		return (&acpi_gbl_aml_op_info [acpi_gbl_short_op_index [(u8) opcode]]);
 
 	case AML_EXTOP:
 
 		/* Extended (16-bit, prefix+opcode) opcode */
 
-		if (lower_opcode <= MAX_EXTENDED_OPCODE) {
-			op_info = &aml_op_info [aml_long_op_info_index [lower_opcode]];
+		if (((u8) opcode) <= MAX_EXTENDED_OPCODE) {
+			return (&acpi_gbl_aml_op_info [acpi_gbl_long_op_index [(u8) opcode]]);
 		}
-		break;
 
+		/* Else fall through to error case below */
+		/*lint -fallthrough */
 
 	default:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown extended opcode=%X\n", opcode));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown extended opcode [%X]\n", opcode));
 		break;
 	}
 
 
-	/* Get the Op info pointer for this opcode */
+	/* Default is "unknown opcode" */
 
-	return (op_info);
+	return (&acpi_gbl_aml_op_info [_UNK]);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_get_opcode_name
+ * FUNCTION:    acpi_ps_get_opcode_name
  *
  * PARAMETERS:  Opcode              - The AML opcode
  *
@@ -743,22 +748,24 @@ acpi_ps_get_opcode_info (
  *
  ******************************************************************************/
 
-NATIVE_CHAR *
+char *
 acpi_ps_get_opcode_name (
-	u16                     opcode)
+	u16                             opcode)
 {
-	const acpi_opcode_info  *op;
+#if defined(ACPI_DISASSEMBLER) || defined (ACPI_DEBUG_OUTPUT)
+
+	const struct acpi_opcode_info   *op;
 
 
 	op = acpi_ps_get_opcode_info (opcode);
 
 	/* Always guaranteed to return a valid pointer */
 
-#ifdef ACPI_DEBUG
 	return (op->name);
+
 #else
 	return ("AE_NOT_CONFIGURED");
+
 #endif
 }
 
-
diff -urNp linux-5400/drivers/acpi/parser/psparse.c linux-5410/drivers/acpi/parser/psparse.c
--- linux-5400/drivers/acpi/parser/psparse.c
+++ linux-5410/drivers/acpi/parser/psparse.c
@@ -1,26 +1,44 @@
 /******************************************************************************
  *
  * Module Name: psparse - Parser top level AML parse routines
- *              $Revision: 104 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
@@ -30,28 +48,26 @@
  * generated parser to tightly constrain stack and dynamic memory
  * usage.  At the same time, parsing is kept flexible and the code
  * fairly compact by parsing based on a list of AML opcode
- * templates in Aml_op_info[]
+ * templates in aml_op_info[]
  */
 
-#include "acpi.h"
-#include "acparser.h"
-#include "acdispat.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "acdebug.h"
-#include "acinterp.h"
+#include <acpi/acpi.h>
+#include <acpi/acparser.h>
+#include <acpi/acdispat.h>
+#include <acpi/amlcode.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acinterp.h>
 
 #define _COMPONENT          ACPI_PARSER
-	 MODULE_NAME         ("psparse")
+	 ACPI_MODULE_NAME    ("psparse")
 
 
-u32                         acpi_gbl_depth = 0;
-extern u32                  acpi_gbl_scope_depth;
+static u32                          acpi_gbl_depth = 0;
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_get_opcode_size
+ * FUNCTION:    acpi_ps_get_opcode_size
  *
  * PARAMETERS:  Opcode          - An AML opcode
  *
@@ -61,9 +77,9 @@ extern u32                  acpi_gbl_sco
  *
  ******************************************************************************/
 
-static u32
+u32
 acpi_ps_get_opcode_size (
-	u32                     opcode)
+	u32                             opcode)
 {
 
 	/* Extended (2-byte) opcode if > 255 */
@@ -80,9 +96,9 @@ acpi_ps_get_opcode_size (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_peek_opcode
+ * FUNCTION:    acpi_ps_peek_opcode
  *
- * PARAMETERS:  Parser_state        - A parser state object
+ * PARAMETERS:  parser_state        - A parser state object
  *
  * RETURN:      Status
  *
@@ -92,122 +108,59 @@ acpi_ps_get_opcode_size (
 
 u16
 acpi_ps_peek_opcode (
-	acpi_parse_state        *parser_state)
+	struct acpi_parse_state         *parser_state)
 {
-	u8                      *aml;
-	u16                     opcode;
+	u8                              *aml;
+	u16                             opcode;
 
 
 	aml = parser_state->aml;
-	opcode = (u16) GET8 (aml);
+	opcode = (u16) ACPI_GET8 (aml);
 
-	aml++;
 
-
-	/*
-	 * Original code special cased LNOTEQUAL, LLESSEQUAL, LGREATEREQUAL.
-	 * These opcodes are no longer recognized. Instead, they are broken into
-	 * two opcodes.
-	 *
-	 *
-	 *    if (Opcode == AML_EXTOP
-	 *       || (Opcode == AML_LNOT
-	 *          && (GET8 (Aml) == AML_LEQUAL
-	 *               || GET8 (Aml) == AML_LGREATER
-	 *               || GET8 (Aml) == AML_LLESS)))
-	 *
-	 *     extended Opcode, !=, <=, or >=
-	 */
 	if (opcode == AML_EXTOP) {
 		/* Extended opcode */
 
-		opcode = (u16) ((opcode << 8) | GET8 (aml));
+		aml++;
+		opcode = (u16) ((opcode << 8) | ACPI_GET8 (aml));
 	}
 
-
 	return (opcode);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_find_object
- *
- * PARAMETERS:  Opcode          - Current opcode
- *              Parser_state    - Current state
- *              Walk_state      - Current state
- *              *Op             - Where found/new op is returned
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Find a named object.  Two versions - one to search the parse
- *              tree (for parser-only applications such as acpidump), another
- *              to search the ACPI internal namespace (the parse tree may no
- *              longer exist)
- *
- ******************************************************************************/
-
-#ifdef PARSER_ONLY
-
-acpi_status
-acpi_ps_find_object (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       **out_op)
-{
-	NATIVE_CHAR             *path;
-
-
-	/* We are only interested in opcodes that have an associated name */
-
-	if (!(walk_state->op_info->flags & AML_NAMED)) {
-		*out_op = walk_state->op;
-		return (AE_OK);
-	}
-
-	/* Find the name in the parse tree */
-
-	path = acpi_ps_get_next_namestring (&walk_state->parser_state);
-
-	*out_op = acpi_ps_find (acpi_ps_get_parent_scope (&walk_state->parser_state),
-			  path, walk_state->opcode, 1);
-
-	if (!(*out_op)) {
-		return (AE_NOT_FOUND);
-	}
-
-	return (AE_OK);
-}
-
-#endif
-
-
-/*******************************************************************************
+ * FUNCTION:    acpi_ps_complete_this_op
  *
- * FUNCTION:    Acpi_ps_complete_this_op
- *
- * PARAMETERS:  Walk_state      - Current State
+ * PARAMETERS:  walk_state      - Current State
  *              Op              - Op to complete
  *
- * RETURN:      TRUE if Op and subtree was deleted
+ * RETURN:      None.
  *
  * DESCRIPTION: Perform any cleanup at the completion of an Op.
  *
  ******************************************************************************/
 
-static u8
+void
 acpi_ps_complete_this_op (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op)
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op)
 {
-#ifndef PARSER_ONLY
-	acpi_parse_object       *prev;
-	acpi_parse_object       *next;
-	const acpi_opcode_info  *parent_info;
-	acpi_parse_object       *replacement_op = NULL;
+	union acpi_parse_object         *prev;
+	union acpi_parse_object         *next;
+	const struct acpi_opcode_info   *parent_info;
+	union acpi_parse_object         *replacement_op = NULL;
+
 
+	ACPI_FUNCTION_TRACE_PTR ("ps_complete_this_op", op);
 
-	FUNCTION_TRACE_PTR ("Ps_complete_this_op", op);
 
+	/* Check for null Op, can happen if AML code is corrupt */
+
+	if (!op) {
+		return_VOID;
+	}
 
 	/* Delete this op and the subtree below it if asked to */
 
@@ -215,60 +168,84 @@ acpi_ps_complete_this_op (
 		(walk_state->op_info->class != AML_CLASS_ARGUMENT)) {
 		/* Make sure that we only delete this subtree */
 
-		if (op->parent) {
+		if (op->common.parent) {
 			/*
 			 * Check if we need to replace the operator and its subtree
 			 * with a return value op (placeholder op)
 			 */
-			parent_info = acpi_ps_get_opcode_info (op->parent->opcode);
+			parent_info = acpi_ps_get_opcode_info (op->common.parent->common.aml_opcode);
 
 			switch (parent_info->class) {
-			case AML_CLASS_CONTROL:        /* IF, ELSE, WHILE only */
+			case AML_CLASS_CONTROL:
 				break;
 
-			case AML_CLASS_NAMED_OBJECT:   /* Scope, method, etc. */
 			case AML_CLASS_CREATE:
 
 				/*
-				 * These opcodes contain Term_arg operands. The current
-				 * op must be replace by a placeholder return op
+				 * These opcodes contain term_arg operands. The current
+				 * op must be replaced by a placeholder return op
 				 */
-				if ((op->parent->opcode == AML_REGION_OP)               ||
-					(op->parent->opcode == AML_CREATE_FIELD_OP)         ||
-					(op->parent->opcode == AML_CREATE_BIT_FIELD_OP)     ||
-					(op->parent->opcode == AML_CREATE_BYTE_FIELD_OP)    ||
-					(op->parent->opcode == AML_CREATE_WORD_FIELD_OP)    ||
-					(op->parent->opcode == AML_CREATE_DWORD_FIELD_OP)   ||
-					(op->parent->opcode == AML_CREATE_QWORD_FIELD_OP)) {
+				replacement_op = acpi_ps_alloc_op (AML_INT_RETURN_VALUE_OP);
+				if (!replacement_op) {
+					return_VOID;
+				}
+				break;
+
+			case AML_CLASS_NAMED_OBJECT:
+
+				/*
+				 * These opcodes contain term_arg operands. The current
+				 * op must be replaced by a placeholder return op
+				 */
+				if ((op->common.parent->common.aml_opcode == AML_REGION_OP)      ||
+					(op->common.parent->common.aml_opcode == AML_DATA_REGION_OP) ||
+					(op->common.parent->common.aml_opcode == AML_BUFFER_OP)      ||
+					(op->common.parent->common.aml_opcode == AML_PACKAGE_OP)     ||
+					(op->common.parent->common.aml_opcode == AML_VAR_PACKAGE_OP)) {
 					replacement_op = acpi_ps_alloc_op (AML_INT_RETURN_VALUE_OP);
 					if (!replacement_op) {
-						return_VALUE (FALSE);
+						return_VOID;
 					}
 				}
 
+				if ((op->common.parent->common.aml_opcode == AML_NAME_OP) &&
+					(walk_state->descending_callback != acpi_ds_exec_begin_op)) {
+					if ((op->common.aml_opcode == AML_BUFFER_OP) ||
+						(op->common.aml_opcode == AML_PACKAGE_OP) ||
+						(op->common.aml_opcode == AML_VAR_PACKAGE_OP)) {
+						replacement_op = acpi_ps_alloc_op (op->common.aml_opcode);
+						if (!replacement_op) {
+							return_VOID;
+						}
+
+						replacement_op->named.data = op->named.data;
+						replacement_op->named.length = op->named.length;
+					}
+				}
 				break;
 
 			default:
 				replacement_op = acpi_ps_alloc_op (AML_INT_RETURN_VALUE_OP);
 				if (!replacement_op) {
-					return_VALUE (FALSE);
+					return_VOID;
 				}
 			}
 
 			/* We must unlink this op from the parent tree */
 
-			prev = op->parent->value.arg;
+			prev = op->common.parent->common.value.arg;
 			if (prev == op) {
 				/* This op is the first in the list */
 
 				if (replacement_op) {
-					replacement_op->parent   = op->parent;
-					replacement_op->value.arg = NULL;
-					op->parent->value.arg    = replacement_op;
-					replacement_op->next     = op->next;
+					replacement_op->common.parent       = op->common.parent;
+					replacement_op->common.value.arg    = NULL;
+					replacement_op->common.node         = op->common.node;
+					op->common.parent->common.value.arg = replacement_op;
+					replacement_op->common.next         = op->common.next;
 				}
 				else {
-					op->parent->value.arg    = op->next;
+					op->common.parent->common.value.arg    = op->common.next;
 				}
 			}
 
@@ -277,66 +254,61 @@ acpi_ps_complete_this_op (
 			else while (prev) {
 				/* Traverse all siblings in the parent's argument list */
 
-				next = prev->next;
+				next = prev->common.next;
 				if (next == op) {
 					if (replacement_op) {
-						replacement_op->parent = op->parent;
-						replacement_op->value.arg = NULL;
-						prev->next = replacement_op;
-						replacement_op->next = op->next;
+						replacement_op->common.parent   = op->common.parent;
+						replacement_op->common.value.arg = NULL;
+						replacement_op->common.node     = op->common.node;
+						prev->common.next               = replacement_op;
+						replacement_op->common.next     = op->common.next;
 						next = NULL;
 					}
 					else {
-						prev->next = op->next;
+						prev->common.next = op->common.next;
 						next = NULL;
 					}
 				}
 
 				prev = next;
 			}
-
 		}
 
 		/* Now we can actually delete the subtree rooted at op */
 
 		acpi_ps_delete_parse_tree (op);
 
-		return_VALUE (TRUE);
+		return_VOID;
 	}
 
-	return_VALUE (FALSE);
-
-#else
-	return (FALSE);
-#endif
+	return_VOID;
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_next_parse_state
+ * FUNCTION:    acpi_ps_next_parse_state
  *
- * PARAMETERS:  Parser_state        - Current parser state object
+ * PARAMETERS:  parser_state        - Current parser state object
  *
- * RETURN:
+ * RETURN:      Status
  *
- * DESCRIPTION:
+ * DESCRIPTION: Update the parser state based upon the return exception from
+ *              the parser callback.
  *
  ******************************************************************************/
 
-static acpi_status
+acpi_status
 acpi_ps_next_parse_state (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op,
-	acpi_status             callback_status)
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op,
+	acpi_status                     callback_status)
 {
-	acpi_parse_state        *parser_state = &walk_state->parser_state;
-	acpi_status             status = AE_CTRL_PENDING;
-	u8                      *start;
-	u32                     package_length;
+	struct acpi_parse_state         *parser_state = &walk_state->parser_state;
+	acpi_status                     status = AE_CTRL_PENDING;
 
 
-	FUNCTION_TRACE_PTR ("Ps_next_parse_state", op);
+	ACPI_FUNCTION_TRACE_PTR ("ps_next_parse_state", op);
 
 
 	switch (callback_status) {
@@ -351,32 +323,40 @@ acpi_ps_next_parse_state (
 		break;
 
 
-	case AE_CTRL_PENDING:
+	case AE_CTRL_BREAK:
+
+		parser_state->aml = walk_state->aml_last_while;
+		walk_state->control_state->common.value = FALSE;
+		status = AE_CTRL_BREAK;
+		break;
+
+	case AE_CTRL_CONTINUE:
 
-		/*
-		 * Predicate of a WHILE was true and the loop just completed an
-		 * execution.  Go back to the start of the loop and reevaluate the
-		 * predicate.
-		 */
 
-		/* TBD: How to handle a break within a while. */
-		/* This code attempts it */
+		parser_state->aml = walk_state->aml_last_while;
+		status = AE_CTRL_CONTINUE;
+		break;
+
+	case AE_CTRL_PENDING:
 
 		parser_state->aml = walk_state->aml_last_while;
 		break;
 
+#if 0
+	case AE_CTRL_SKIP:
+
+		parser_state->aml = parser_state->scope->parse_scope.pkg_end;
+		status = AE_OK;
+		break;
+#endif
 
 	case AE_CTRL_TRUE:
+
 		/*
 		 * Predicate of an IF was true, and we are at the matching ELSE.
 		 * Just close out this package
-		 *
-		 * Note: Parser_state->Aml is modified by the package length procedure
-		 * TBD: [Investigate] perhaps it shouldn't, too much trouble
 		 */
-		start = parser_state->aml;
-		package_length = acpi_ps_get_next_package_length (parser_state);
-		parser_state->aml = start + package_length;
+		parser_state->aml = acpi_ps_get_next_package_end (parser_state);
 		break;
 
 
@@ -406,7 +386,7 @@ acpi_ps_next_parse_state (
 		status = AE_CTRL_TRANSFER;
 		walk_state->prev_op = op;
 		walk_state->method_call_op = op;
-		walk_state->method_call_node = (op->value.arg)->node;
+		walk_state->method_call_node = (op->common.value.arg)->common.node;
 
 		/* Will return value (if any) be used by the caller? */
 
@@ -428,9 +408,9 @@ acpi_ps_next_parse_state (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_parse_loop
+ * FUNCTION:    acpi_ps_parse_loop
  *
- * PARAMETERS:  Parser_state        - Current parser state object
+ * PARAMETERS:  parser_state        - Current parser state object
  *
  * RETURN:      Status
  *
@@ -441,24 +421,28 @@ acpi_ps_next_parse_state (
 
 acpi_status
 acpi_ps_parse_loop (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status = AE_OK;
-	acpi_parse_object       *op = NULL;     /* current op */
-	acpi_parse_object       *arg = NULL;
-	acpi_parse_object       pre_op;
-	acpi_parse_state        *parser_state;
-	u8                      *aml_op_start;
+	acpi_status                     status = AE_OK;
+	union acpi_parse_object         *op = NULL;     /* current op */
+	union acpi_parse_object         *arg = NULL;
+	union acpi_parse_object         pre_op;
+	struct acpi_parse_state         *parser_state;
+	u8                              *aml_op_start = NULL;
+
 
+	ACPI_FUNCTION_TRACE_PTR ("ps_parse_loop", walk_state);
 
-	FUNCTION_TRACE_PTR ("Ps_parse_loop", walk_state);
+	if (walk_state->descending_callback == NULL) {
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
 
 
 	parser_state = &walk_state->parser_state;
 	walk_state->arg_types = 0;
 
-#ifndef PARSER_ONLY
-	if (walk_state->walk_type & WALK_METHOD_RESTART) {
+#if (!defined (ACPI_NO_METHOD_EXECUTION) && !defined (ACPI_CONSTANT_EVAL_ONLY))
+	if (walk_state->walk_type & ACPI_WALK_METHOD_RESTART) {
 		/* We are restarting a preempted control method */
 
 		if (acpi_ps_has_completed_scope (parser_state)) {
@@ -467,18 +451,17 @@ acpi_ps_parse_loop (
 			 * was just completed
 			 */
 			if ((parser_state->scope->parse_scope.op) &&
-			   ((parser_state->scope->parse_scope.op->opcode == AML_IF_OP) ||
-				(parser_state->scope->parse_scope.op->opcode == AML_WHILE_OP)) &&
+			   ((parser_state->scope->parse_scope.op->common.aml_opcode == AML_IF_OP) ||
+				(parser_state->scope->parse_scope.op->common.aml_opcode == AML_WHILE_OP)) &&
 				(walk_state->control_state) &&
 				(walk_state->control_state->common.state ==
-					CONTROL_PREDICATE_EXECUTING)) {
-
+					ACPI_CONTROL_PREDICATE_EXECUTING)) {
 				/*
 				 * A predicate was just completed, get the value of the
 				 * predicate and branch based on that value
 				 */
 				walk_state->op = NULL;
-				status = acpi_ds_get_predicate_value (walk_state, TRUE);
+				status = acpi_ds_get_predicate_value (walk_state, ACPI_TO_POINTER (TRUE));
 				if (ACPI_FAILURE (status) &&
 					((status & AE_CODE_MASK) != AE_CODE_CONTROL)) {
 					if (status == AE_AML_NO_RETURN_VALUE) {
@@ -487,7 +470,7 @@ acpi_ps_parse_loop (
 							acpi_format_exception (status)));
 
 					}
-					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Get_predicate Failed, %s\n",
+					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "get_predicate Failed, %s\n",
 						acpi_format_exception (status)));
 					return_ACPI_STATUS (status);
 				}
@@ -495,10 +478,10 @@ acpi_ps_parse_loop (
 				status = acpi_ps_next_parse_state (walk_state, op, status);
 			}
 
-			acpi_ps_pop_scope (parser_state, &op, &walk_state->arg_types, &walk_state->arg_count);
+			acpi_ps_pop_scope (parser_state, &op,
+				&walk_state->arg_types, &walk_state->arg_count);
 			ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Popped scope, Op=%p\n", op));
 		}
-
 		else if (walk_state->prev_op) {
 			/* We were in the middle of an op */
 
@@ -512,12 +495,13 @@ acpi_ps_parse_loop (
 	 * Iterative parsing loop, while there is more aml to process:
 	 */
 	while ((parser_state->aml < parser_state->aml_end) || (op)) {
+		aml_op_start = parser_state->aml;
 		if (!op) {
 			/* Get the next opcode from the AML stream */
 
-			aml_op_start = parser_state->aml;
-			walk_state->aml_offset = parser_state->aml - parser_state->aml_start;
-			walk_state->opcode    = acpi_ps_peek_opcode (parser_state);
+			walk_state->aml_offset = ACPI_PTR_DIFF (parser_state->aml,
+					   parser_state->aml_start);
+			walk_state->opcode   = acpi_ps_peek_opcode (parser_state);
 
 			/*
 			 * First cut to determine what we have found:
@@ -542,10 +526,10 @@ acpi_ps_parse_loop (
 				/* The opcode is unrecognized.  Just skip unknown opcodes */
 
 				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-					"Found unknown opcode %X at AML offset %X, ignoring\n",
-					walk_state->opcode, walk_state->aml_offset));
+					"Found unknown opcode %X at AML address %p offset %X, ignoring\n",
+					walk_state->opcode, parser_state->aml, walk_state->aml_offset));
 
-				DUMP_BUFFER (parser_state->aml, 128);
+				ACPI_DUMP_BUFFER (parser_state->aml, 128);
 
 				/* Assume one-byte bad opcode */
 
@@ -559,70 +543,76 @@ acpi_ps_parse_loop (
 				parser_state->aml += acpi_ps_get_opcode_size (walk_state->opcode);
 				walk_state->arg_types = walk_state->op_info->parse_args;
 				break;
-
 			}
 
-
 			/* Create Op structure and append to parent's argument list */
 
 			if (walk_state->op_info->flags & AML_NAMED) {
-				pre_op.value.arg = NULL;
-				pre_op.opcode = walk_state->opcode;
+				pre_op.common.value.arg = NULL;
+				pre_op.common.aml_opcode = walk_state->opcode;
+
+				/*
+				 * Get and append arguments until we find the node that contains
+				 * the name (the type ARGP_NAME).
+				 */
+				while (GET_CURRENT_ARG_TYPE (walk_state->arg_types) &&
+					  (GET_CURRENT_ARG_TYPE (walk_state->arg_types) != ARGP_NAME)) {
+					status = acpi_ps_get_next_arg (walk_state, parser_state,
+							 GET_CURRENT_ARG_TYPE (walk_state->arg_types), &arg);
+					if (ACPI_FAILURE (status)) {
+						goto close_this_op;
+					}
 
-				while (GET_CURRENT_ARG_TYPE (walk_state->arg_types) != ARGP_NAME) {
-					arg = acpi_ps_get_next_arg (parser_state,
-							 GET_CURRENT_ARG_TYPE (walk_state->arg_types),
-							 &walk_state->arg_count);
 					acpi_ps_append_arg (&pre_op, arg);
 					INCREMENT_ARG_LIST (walk_state->arg_types);
 				}
 
+				/* Make sure that we found a NAME and didn't run out of arguments */
+
+				if (!GET_CURRENT_ARG_TYPE (walk_state->arg_types)) {
+					return_ACPI_STATUS (AE_AML_NO_OPERAND);
+				}
 
 				/* We know that this arg is a name, move to next arg */
 
 				INCREMENT_ARG_LIST (walk_state->arg_types);
 
-				if (walk_state->descending_callback != NULL) {
-					/*
-					 * Find the object.  This will either insert the object into
-					 * the namespace or simply look it up
-					 */
-					walk_state->op = NULL;
-
-					status = walk_state->descending_callback (walk_state, &op);
+				/*
+				 * Find the object.  This will either insert the object into
+				 * the namespace or simply look it up
+				 */
+				walk_state->op = NULL;
 
-					/* TBD: check status here? */
+				status = walk_state->descending_callback (walk_state, &op);
+				if (ACPI_FAILURE (status)) {
+					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "During name lookup/catalog, %s\n",
+							acpi_format_exception (status)));
+					goto close_this_op;
+				}
 
-					if (ACPI_FAILURE (status)) {
-						ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "During name lookup/catalog, %s\n",
-								acpi_format_exception (status)));
-						goto close_this_op;
-					}
+				if (op == NULL) {
+					continue;
+				}
 
-					if (op == NULL) {
-						continue;
-					}
-					status = acpi_ps_next_parse_state (walk_state, op, status);
-					if (status == AE_CTRL_PENDING) {
-						status = AE_OK;
-						goto close_this_op;
-					}
+				status = acpi_ps_next_parse_state (walk_state, op, status);
+				if (status == AE_CTRL_PENDING) {
+					status = AE_OK;
+					goto close_this_op;
+				}
 
-					if (ACPI_FAILURE (status)) {
-						goto close_this_op;
-					}
+				if (ACPI_FAILURE (status)) {
+					goto close_this_op;
 				}
 
-				acpi_ps_append_arg (op, pre_op.value.arg);
+				acpi_ps_append_arg (op, pre_op.common.value.arg);
 				acpi_gbl_depth++;
 
-
-				if (op->opcode == AML_REGION_OP) {
+				if (op->common.aml_opcode == AML_REGION_OP) {
 					/*
-					 * Defer final parsing of an Operation_region body,
+					 * Defer final parsing of an operation_region body,
 					 * because we don't have enough info in the first pass
 					 * to parse it correctly (i.e., there may be method
-					 * calls within the Term_arg elements of the body.
+					 * calls within the term_arg elements of the body.)
 					 *
 					 * However, we must continue parsing because
 					 * the opregion is not a standalone package --
@@ -630,12 +620,10 @@ acpi_ps_parse_loop (
 					 *
 					 * (Length is unknown until parse of the body complete)
 					 */
-					((acpi_parse2_object * ) op)->data    = aml_op_start;
-					((acpi_parse2_object * ) op)->length  = 0;
+					op->named.data    = aml_op_start;
+					op->named.length  = 0;
 				}
 			}
-
-
 			else {
 				/* Not a named opcode, just allocate Op and append to parent */
 
@@ -645,14 +633,13 @@ acpi_ps_parse_loop (
 					return_ACPI_STATUS (AE_NO_MEMORY);
 				}
 
-
 				if (walk_state->op_info->flags & AML_CREATE) {
 					/*
-					 * Backup to beginning of Create_xXXfield declaration
-					 * Body_length is unknown until we parse the body
+					 * Backup to beginning of create_xXXfield declaration
+					 * body_length is unknown until we parse the body
 					 */
-					((acpi_parse2_object * ) op)->data    = aml_op_start;
-					((acpi_parse2_object * ) op)->length  = 0;
+					op->named.data    = aml_op_start;
+					op->named.length  = 0;
 				}
 
 				acpi_ps_append_arg (acpi_ps_get_parent_scope (parser_state), op);
@@ -662,7 +649,7 @@ acpi_ps_parse_loop (
 					 * Find the object.  This will either insert the object into
 					 * the namespace or simply look it up
 					 */
-					walk_state->op    = op;
+					walk_state->op = op;
 
 					status = walk_state->descending_callback (walk_state, &op);
 					status = acpi_ps_next_parse_state (walk_state, op, status);
@@ -677,40 +664,44 @@ acpi_ps_parse_loop (
 				}
 			}
 
-			op->aml_offset = walk_state->aml_offset;
+			op->common.aml_offset = walk_state->aml_offset;
 
 			if (walk_state->op_info) {
 				ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
-					"Op=%p Opcode=%4.4X Aml %p Oft=%5.5X\n",
-					 op, op->opcode, parser_state->aml, op->aml_offset));
+					"Opcode %4.4X [%s] Op %p Aml %p aml_offset %5.5X\n",
+					 (u32) op->common.aml_opcode, walk_state->op_info->name,
+					 op, parser_state->aml, op->common.aml_offset));
 			}
 		}
 
 
-		/* Start Arg_count at zero because we don't know if there are any args yet */
+		/* Start arg_count at zero because we don't know if there are any args yet */
 
 		walk_state->arg_count = 0;
 
-
 		if (walk_state->arg_types) /* Are there any arguments that must be processed? */ {
-			/* get arguments */
+			/* Get arguments */
 
-			switch (op->opcode) {
+			switch (op->common.aml_opcode) {
 			case AML_BYTE_OP:       /* AML_BYTEDATA_ARG */
 			case AML_WORD_OP:       /* AML_WORDDATA_ARG */
 			case AML_DWORD_OP:      /* AML_DWORDATA_ARG */
 			case AML_QWORD_OP:      /* AML_QWORDATA_ARG */
 			case AML_STRING_OP:     /* AML_ASCIICHARLIST_ARG */
 
-				/* fill in constant or string argument directly */
+				/* Fill in constant or string argument directly */
 
 				acpi_ps_get_next_simple_arg (parser_state,
-						 GET_CURRENT_ARG_TYPE (walk_state->arg_types), op);
+					GET_CURRENT_ARG_TYPE (walk_state->arg_types), op);
 				break;
 
 			case AML_INT_NAMEPATH_OP:   /* AML_NAMESTRING_ARG */
 
-				acpi_ps_get_next_namepath (parser_state, op, &walk_state->arg_count, 1);
+				status = acpi_ps_get_next_namepath (walk_state, parser_state, op, 1);
+				if (ACPI_FAILURE (status)) {
+					goto close_this_op;
+				}
+
 				walk_state->arg_types = 0;
 				break;
 
@@ -719,202 +710,268 @@ acpi_ps_parse_loop (
 
 				/* Op is not a constant or string, append each argument */
 
-				while (GET_CURRENT_ARG_TYPE (walk_state->arg_types) && !walk_state->arg_count) {
-					walk_state->aml_offset = parser_state->aml - parser_state->aml_start;
-					arg = acpi_ps_get_next_arg (parser_state,
-							 GET_CURRENT_ARG_TYPE (walk_state->arg_types),
-							 &walk_state->arg_count);
+				while (GET_CURRENT_ARG_TYPE (walk_state->arg_types) &&
+						!walk_state->arg_count) {
+					walk_state->aml_offset = ACPI_PTR_DIFF (parser_state->aml,
+							   parser_state->aml_start);
+					status = acpi_ps_get_next_arg (walk_state, parser_state,
+							 GET_CURRENT_ARG_TYPE (walk_state->arg_types), &arg);
+					if (ACPI_FAILURE (status)) {
+						goto close_this_op;
+					}
+
 					if (arg) {
-						arg->aml_offset = walk_state->aml_offset;
+						arg->common.aml_offset = walk_state->aml_offset;
 						acpi_ps_append_arg (op, arg);
 					}
-
 					INCREMENT_ARG_LIST (walk_state->arg_types);
 				}
 
+				switch (op->common.aml_opcode) {
+				case AML_METHOD_OP:
 
-				/* For a method, save the length and address of the body */
+					/* For a method, save the length and address of the body */
 
-				if (op->opcode == AML_METHOD_OP) {
 					/*
 					 * Skip parsing of control method or opregion body,
 					 * because we don't have enough info in the first pass
 					 * to parse them correctly.
 					 */
-					((acpi_parse2_object * ) op)->data    = parser_state->aml;
-					((acpi_parse2_object * ) op)->length  = (u32) (parser_state->pkg_end -
-							   parser_state->aml);
-
+					op->named.data   = parser_state->aml;
+					op->named.length = (u32) (parser_state->pkg_end - parser_state->aml);
 					/*
-					 * Skip body of method.  For Op_regions, we must continue
+					 * Skip body of method.  For op_regions, we must continue
 					 * parsing because the opregion is not a standalone
 					 * package (We don't know where the end is).
 					 */
 					parser_state->aml   = parser_state->pkg_end;
-					walk_state->arg_count          = 0;
-				}
+					walk_state->arg_count = 0;
+					break;
+
+				case AML_BUFFER_OP:
+				case AML_PACKAGE_OP:
+				case AML_VAR_PACKAGE_OP:
+
+					if ((op->common.parent) &&
+						(op->common.parent->common.aml_opcode == AML_NAME_OP) &&
+						(walk_state->descending_callback != acpi_ds_exec_begin_op)) {
+						/*
+						 * Skip parsing of
+						 * because we don't have enough info in the first pass
+						 * to parse them correctly.
+						 */
+						op->named.data   = aml_op_start;
+						op->named.length = (u32) (parser_state->pkg_end - aml_op_start);
+						/*
+						 * Skip body
+						 */
+						parser_state->aml   = parser_state->pkg_end;
+						walk_state->arg_count = 0;
+					}
+					break;
+
+				case AML_WHILE_OP:
+
+					if (walk_state->control_state) {
+						walk_state->control_state->control.package_end = parser_state->pkg_end;
+					}
+					break;
 
+				default:
+					/* No action for all other opcodes */
+					break;
+				}
 				break;
 			}
 		}
 
+		/* Check for arguments that need to be processed */
 
-		/*
-		 * Zero Arg_count means that all arguments for this op have been processed
-		 */
-		if (!walk_state->arg_count) {
-			/* completed Op, prepare for next */
+		if (walk_state->arg_count) {
+			/* There are arguments (complex ones), push Op and prepare for argument */
 
-			walk_state->op_info = acpi_ps_get_opcode_info (op->opcode);
-			if (walk_state->op_info->flags & AML_NAMED) {
-				if (acpi_gbl_depth) {
-					acpi_gbl_depth--;
-				}
+			status = acpi_ps_push_scope (parser_state, op,
+					 walk_state->arg_types, walk_state->arg_count);
+			if (ACPI_FAILURE (status)) {
+				return_ACPI_STATUS (status);
+			}
+			op = NULL;
+			continue;
+		}
 
-				if (op->opcode == AML_REGION_OP) {
-					/*
-					 * Skip parsing of control method or opregion body,
-					 * because we don't have enough info in the first pass
-					 * to parse them correctly.
-					 *
-					 * Completed parsing an Op_region declaration, we now
-					 * know the length.
-					 */
-					((acpi_parse2_object * ) op)->length = (u32) (parser_state->aml -
-							   ((acpi_parse2_object * ) op)->data);
-				}
+		/* All arguments have been processed -- Op is complete, prepare for next */
+
+		walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
+		if (walk_state->op_info->flags & AML_NAMED) {
+			if (acpi_gbl_depth) {
+				acpi_gbl_depth--;
 			}
 
-			if (walk_state->op_info->flags & AML_CREATE) {
+			if (op->common.aml_opcode == AML_REGION_OP) {
 				/*
-				 * Backup to beginning of Create_xXXfield declaration (1 for
-				 * Opcode)
+				 * Skip parsing of control method or opregion body,
+				 * because we don't have enough info in the first pass
+				 * to parse them correctly.
 				 *
-				 * Body_length is unknown until we parse the body
+				 * Completed parsing an op_region declaration, we now
+				 * know the length.
 				 */
-				((acpi_parse2_object * ) op)->length = (u32) (parser_state->aml -
-						   ((acpi_parse2_object * ) op)->data);
+				op->named.length = (u32) (parser_state->aml - op->named.data);
 			}
+		}
 
-			/* This op complete, notify the dispatcher */
+		if (walk_state->op_info->flags & AML_CREATE) {
+			/*
+			 * Backup to beginning of create_xXXfield declaration (1 for
+			 * Opcode)
+			 *
+			 * body_length is unknown until we parse the body
+			 */
+			op->named.length = (u32) (parser_state->aml - op->named.data);
+		}
 
-			if (walk_state->ascending_callback != NULL) {
-				walk_state->op    = op;
-				walk_state->opcode = op->opcode;
+		/* This op complete, notify the dispatcher */
 
-				status = walk_state->ascending_callback (walk_state);
-				status = acpi_ps_next_parse_state (walk_state, op, status);
-				if (status == AE_CTRL_PENDING) {
-					status = AE_OK;
-					goto close_this_op;
-				}
+		if (walk_state->ascending_callback != NULL) {
+			walk_state->op    = op;
+			walk_state->opcode = op->common.aml_opcode;
+
+			status = walk_state->ascending_callback (walk_state);
+			status = acpi_ps_next_parse_state (walk_state, op, status);
+			if (status == AE_CTRL_PENDING) {
+				status = AE_OK;
+				goto close_this_op;
 			}
+		}
 
 
 close_this_op:
+		/*
+		 * Finished one argument of the containing scope
+		 */
+		parser_state->scope->parse_scope.arg_count--;
 
-			/*
-			 * Finished one argument of the containing scope
-			 */
-			parser_state->scope->parse_scope.arg_count--;
-
-			/* Close this Op (may result in parse subtree deletion) */
-
-			if (acpi_ps_complete_this_op (walk_state, op)) {
-				op = NULL;
-			}
+		/* Close this Op (will result in parse subtree deletion) */
 
+		acpi_ps_complete_this_op (walk_state, op);
+		op = NULL;
 
-			switch (status) {
-			case AE_OK:
-				break;
+		switch (status) {
+		case AE_OK:
+			break;
 
 
-			case AE_CTRL_TRANSFER:
+		case AE_CTRL_TRANSFER:
 
-				/*
-				 * We are about to transfer to a called method.
-				 */
-				walk_state->prev_op = op;
-				walk_state->prev_arg_types = walk_state->arg_types;
-				return_ACPI_STATUS (status);
-				break;
+			/*
+			 * We are about to transfer to a called method.
+			 */
+			walk_state->prev_op = op;
+			walk_state->prev_arg_types = walk_state->arg_types;
+			return_ACPI_STATUS (status);
 
 
-			case AE_CTRL_END:
+		case AE_CTRL_END:
 
-				acpi_ps_pop_scope (parser_state, &op, &walk_state->arg_types, &walk_state->arg_count);
+			acpi_ps_pop_scope (parser_state, &op,
+				&walk_state->arg_types, &walk_state->arg_count);
 
+			if (op) {
 				walk_state->op    = op;
-				walk_state->op_info = acpi_ps_get_opcode_info (op->opcode);
-				walk_state->opcode = op->opcode;
+				walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
+				walk_state->opcode = op->common.aml_opcode;
 
 				status = walk_state->ascending_callback (walk_state);
 				status = acpi_ps_next_parse_state (walk_state, op, status);
 
 				acpi_ps_complete_this_op (walk_state, op);
 				op = NULL;
-				status = AE_OK;
-				break;
+			}
+			status = AE_OK;
+			break;
 
 
-			case AE_CTRL_TERMINATE:
+		case AE_CTRL_BREAK:
+		case AE_CTRL_CONTINUE:
 
-				status = AE_OK;
+			/* Pop off scopes until we find the While */
 
-				/* Clean up */
-				do {
-					if (op) {
-						acpi_ps_complete_this_op (walk_state, op);
-					}
+			while (!op || (op->common.aml_opcode != AML_WHILE_OP)) {
+				acpi_ps_pop_scope (parser_state, &op,
+					&walk_state->arg_types, &walk_state->arg_count);
+			}
 
-					acpi_ps_pop_scope (parser_state, &op, &walk_state->arg_types, &walk_state->arg_count);
-				} while (op);
+			/* Close this iteration of the While loop */
 
-				return_ACPI_STATUS (status);
-				break;
+			walk_state->op    = op;
+			walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
+			walk_state->opcode = op->common.aml_opcode;
+
+			status = walk_state->ascending_callback (walk_state);
+			status = acpi_ps_next_parse_state (walk_state, op, status);
+
+			acpi_ps_complete_this_op (walk_state, op);
+			op = NULL;
 
+			status = AE_OK;
+			break;
 
-			default:  /* All other non-AE_OK status */
 
-				if (op == NULL) {
-					acpi_ps_pop_scope (parser_state, &op, &walk_state->arg_types, &walk_state->arg_count);
+		case AE_CTRL_TERMINATE:
+
+			status = AE_OK;
+
+			/* Clean up */
+			do {
+				if (op) {
+					acpi_ps_complete_this_op (walk_state, op);
 				}
-				walk_state->prev_op = op;
-				walk_state->prev_arg_types = walk_state->arg_types;
+				acpi_ps_pop_scope (parser_state, &op,
+					&walk_state->arg_types, &walk_state->arg_count);
 
-				/*
-				 * TEMP:
-				 */
+			} while (op);
 
-				return_ACPI_STATUS (status);
-				break;
-			}
+			return_ACPI_STATUS (status);
 
-			/* This scope complete? */
 
-			if (acpi_ps_has_completed_scope (parser_state)) {
-				acpi_ps_pop_scope (parser_state, &op, &walk_state->arg_types, &walk_state->arg_count);
-				ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Popped scope, Op=%p\n", op));
-			}
+		default:  /* All other non-AE_OK status */
 
-			else {
-				op = NULL;
-			}
+			do {
+				if (op) {
+					acpi_ps_complete_this_op (walk_state, op);
+				}
+				acpi_ps_pop_scope (parser_state, &op,
+					&walk_state->arg_types, &walk_state->arg_count);
 
-		}
+			} while (op);
 
 
-		/* Arg_count is non-zero */
+			/*
+			 * TBD: Cleanup parse ops on error
+			 */
+#if 0
+			if (op == NULL) {
+				acpi_ps_pop_scope (parser_state, &op,
+					&walk_state->arg_types, &walk_state->arg_count);
+			}
+#endif
+			walk_state->prev_op = op;
+			walk_state->prev_arg_types = walk_state->arg_types;
+			return_ACPI_STATUS (status);
+		}
 
-		else {
-			/* complex argument, push Op and prepare for argument */
+		/* This scope complete? */
 
-			acpi_ps_push_scope (parser_state, op, walk_state->arg_types, walk_state->arg_count);
+		if (acpi_ps_has_completed_scope (parser_state)) {
+			acpi_ps_pop_scope (parser_state, &op,
+				&walk_state->arg_types, &walk_state->arg_count);
+			ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Popped scope, Op=%p\n", op));
+		}
+		else {
 			op = NULL;
 		}
 
-	} /* while Parser_state->Aml */
+	} /* while parser_state->Aml */
 
 
 	/*
@@ -928,8 +985,8 @@ close_this_op:
 		if (op) {
 			if (walk_state->ascending_callback != NULL) {
 				walk_state->op    = op;
-				walk_state->op_info = acpi_ps_get_opcode_info (op->opcode);
-				walk_state->opcode = op->opcode;
+				walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
+				walk_state->opcode = op->common.aml_opcode;
 
 				status = walk_state->ascending_callback (walk_state);
 				status = acpi_ps_next_parse_state (walk_state, op, status);
@@ -947,7 +1004,8 @@ close_this_op:
 							acpi_ps_complete_this_op (walk_state, op);
 						}
 
-						acpi_ps_pop_scope (parser_state, &op, &walk_state->arg_types, &walk_state->arg_count);
+						acpi_ps_pop_scope (parser_state, &op,
+							&walk_state->arg_types, &walk_state->arg_count);
 
 					} while (op);
 
@@ -963,7 +1021,8 @@ close_this_op:
 			acpi_ps_complete_this_op (walk_state, op);
 		}
 
-		acpi_ps_pop_scope (parser_state, &op, &walk_state->arg_types, &walk_state->arg_count);
+		acpi_ps_pop_scope (parser_state, &op, &walk_state->arg_types,
+			&walk_state->arg_count);
 
 	} while (op);
 
@@ -973,12 +1032,12 @@ close_this_op:
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_parse_aml
+ * FUNCTION:    acpi_ps_parse_aml
  *
- * PARAMETERS:  Start_scope     - The starting point of the parse.  Becomes the
+ * PARAMETERS:  start_scope     - The starting point of the parse.  Becomes the
  *                                root of the parsed op tree.
  *              Aml             - Pointer to the raw AML code to parse
- *              Aml_size        - Length of the AML to parse
+ *              aml_size        - Length of the AML to parse
  *
  *
  * RETURN:      Status
@@ -989,33 +1048,36 @@ close_this_op:
 
 acpi_status
 acpi_ps_parse_aml (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status;
-	acpi_walk_list          walk_list;
-	acpi_walk_list          *prev_walk_list = acpi_gbl_current_walk_list;
-	acpi_walk_state         *previous_walk_state;
+	acpi_status                     status;
+	acpi_status                     terminate_status;
+	struct acpi_thread_state        *thread;
+	struct acpi_thread_state        *prev_walk_list = acpi_gbl_current_walk_list;
+	struct acpi_walk_state          *previous_walk_state;
 
 
-	FUNCTION_TRACE ("Ps_parse_aml");
+	ACPI_FUNCTION_TRACE ("ps_parse_aml");
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Entered with Walk_state=%p Aml=%p size=%X\n",
+	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Entered with walk_state=%p Aml=%p size=%X\n",
 		walk_state, walk_state->parser_state.aml, walk_state->parser_state.aml_size));
 
 
-	/* Create and initialize a new walk list */
+	/* Create and initialize a new thread state */
 
-	walk_list.walk_state            = NULL;
-	walk_list.acquired_mutex_list.prev = NULL;
-	walk_list.acquired_mutex_list.next = NULL;
-
-	walk_state->walk_list = &walk_list;
-	acpi_ds_push_walk_state (walk_state, &walk_list);
+	thread = acpi_ut_create_thread_state ();
+	if (!thread) {
+		return_ACPI_STATUS (AE_NO_MEMORY);
+	}
 
+	walk_state->thread = thread;
+	acpi_ds_push_walk_state (walk_state, thread);
 
-	/* TBD: [Restructure] TEMP until we pass Walk_state to the interpreter
+	/*
+	 * This global allows the AML debugger to get a handle to the currently
+	 * executing control method.
 	 */
-	acpi_gbl_current_walk_list = &walk_list;
+	acpi_gbl_current_walk_list = thread;
 
 	/*
 	 * Execute the walk loop as long as there is a valid Walk State.  This
@@ -1027,37 +1089,41 @@ acpi_ps_parse_aml (
 	while (walk_state) {
 		if (ACPI_SUCCESS (status)) {
 			/*
-			 * The Parse_loop executes AML until the method terminates
+			 * The parse_loop executes AML until the method terminates
 			 * or calls another method.
 			 */
 			status = acpi_ps_parse_loop (walk_state);
 		}
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
-			"Completed one call to walk loop, State=%p\n", walk_state));
+			"Completed one call to walk loop, %s State=%p\n",
+			acpi_format_exception (status), walk_state));
 
 		if (status == AE_CTRL_TRANSFER) {
 			/*
 			 * A method call was detected.
 			 * Transfer control to the called control method
 			 */
-			status = acpi_ds_call_control_method (&walk_list, walk_state, NULL);
+			status = acpi_ds_call_control_method (thread, walk_state, NULL);
 
 			/*
 			 * If the transfer to the new method method call worked, a new walk
 			 * state was created -- get it
 			 */
-			walk_state = acpi_ds_get_current_walk_state (&walk_list);
+			walk_state = acpi_ds_get_current_walk_state (thread);
 			continue;
 		}
-
 		else if (status == AE_CTRL_TERMINATE) {
 			status = AE_OK;
 		}
+		else if (status != AE_OK) {
+			ACPI_REPORT_METHOD_ERROR ("Method execution failed",
+				walk_state->method_node, NULL, status);
+		}
 
 		/* We are done with this walk, move on to the parent if any */
 
-		walk_state = acpi_ds_pop_walk_state (&walk_list);
+		walk_state = acpi_ds_pop_walk_state (thread);
 
 		/* Reset the current scope to the beginning of scope stack */
 
@@ -1068,7 +1134,13 @@ acpi_ps_parse_aml (
 		 * there's lots of cleanup to do
 		 */
 		if ((walk_state->parse_flags & ACPI_PARSE_MODE_MASK) == ACPI_PARSE_EXECUTE) {
-			acpi_ds_terminate_control_method (walk_state);
+			terminate_status = acpi_ds_terminate_control_method (walk_state);
+			if (ACPI_FAILURE (terminate_status)) {
+				ACPI_REPORT_ERROR ((
+					"Could not terminate control method properly\n"));
+
+				/* Ignore error and continue */
+			}
 		}
 
 		/* Delete this walk state and all linked control states */
@@ -1077,22 +1149,29 @@ acpi_ps_parse_aml (
 
 		previous_walk_state = walk_state;
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Return_value=%p, State=%p\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "return_value=%p, State=%p\n",
 			walk_state->return_desc, walk_state));
 
 		/* Check if we have restarted a preempted walk */
 
-		walk_state = acpi_ds_get_current_walk_state (&walk_list);
+		walk_state = acpi_ds_get_current_walk_state (thread);
 		if (walk_state) {
 			if (ACPI_SUCCESS (status)) {
-				/* There is another walk state, restart it */
-
 				/*
-				 * If the method returned value is not used by the parent,
+				 * There is another walk state, restart it.
+				 * If the method return value is not used by the parent,
 				 * The object is deleted
 				 */
-				acpi_ds_restart_control_method (walk_state, previous_walk_state->return_desc);
-				walk_state->walk_type |= WALK_METHOD_RESTART;
+				status = acpi_ds_restart_control_method (walk_state,
+						 previous_walk_state->return_desc);
+				if (ACPI_SUCCESS (status)) {
+					walk_state->walk_type |= ACPI_WALK_METHOD_RESTART;
+				}
+			}
+			else {
+				/* On error, delete any return object */
+
+				acpi_ut_remove_reference (previous_walk_state->return_desc);
 			}
 		}
 
@@ -1103,7 +1182,6 @@ acpi_ps_parse_aml (
 		else if (previous_walk_state->caller_return_desc) {
 			*(previous_walk_state->caller_return_desc) = previous_walk_state->return_desc; /* NULL if no return value */
 		}
-
 		else if (previous_walk_state->return_desc) {
 			/* Caller doesn't want it, must delete it */
 
@@ -1113,10 +1191,10 @@ acpi_ps_parse_aml (
 		acpi_ds_delete_walk_state (previous_walk_state);
 	}
 
-
 	/* Normal exit */
 
-	acpi_ex_release_all_mutexes ((acpi_operand_object *) &walk_list.acquired_mutex_list);
+	acpi_ex_release_all_mutexes (thread);
+	acpi_ut_delete_generic_state (ACPI_CAST_PTR (union acpi_generic_state, thread));
 	acpi_gbl_current_walk_list = prev_walk_list;
 	return_ACPI_STATUS (status);
 }
diff -urNp linux-5400/drivers/acpi/parser/psscope.c linux-5410/drivers/acpi/parser/psscope.c
--- linux-5400/drivers/acpi/parser/psscope.c
+++ linux-5410/drivers/acpi/parser/psscope.c
@@ -1,41 +1,59 @@
 /******************************************************************************
  *
  * Module Name: psscope - Parser scope stack management routines
- *              $Revision: 30 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
+#include <acpi/acpi.h>
+#include <acpi/acparser.h>
 
 #define _COMPONENT          ACPI_PARSER
-	 MODULE_NAME         ("psscope")
+	 ACPI_MODULE_NAME    ("psscope")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_get_parent_scope
+ * FUNCTION:    acpi_ps_get_parent_scope
  *
- * PARAMETERS:  Parser_state        - Current parser state object
+ * PARAMETERS:  parser_state        - Current parser state object
  *
  * RETURN:      Pointer to an Op object
  *
@@ -43,9 +61,9 @@
  *
  ******************************************************************************/
 
-acpi_parse_object *
+union acpi_parse_object *
 acpi_ps_get_parent_scope (
-	acpi_parse_state        *parser_state)
+	struct acpi_parse_state         *parser_state)
 {
 	return (parser_state->scope->parse_scope.op);
 }
@@ -53,9 +71,9 @@ acpi_ps_get_parent_scope (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_has_completed_scope
+ * FUNCTION:    acpi_ps_has_completed_scope
  *
- * PARAMETERS:  Parser_state        - Current parser state object
+ * PARAMETERS:  parser_state        - Current parser state object
  *
  * RETURN:      Boolean, TRUE = scope completed.
  *
@@ -67,7 +85,7 @@ acpi_ps_get_parent_scope (
 
 u8
 acpi_ps_has_completed_scope (
-	acpi_parse_state        *parser_state)
+	struct acpi_parse_state         *parser_state)
 {
 	return ((u8) ((parser_state->aml >= parser_state->scope->parse_scope.arg_end ||
 			   !parser_state->scope->parse_scope.arg_count)));
@@ -76,9 +94,9 @@ acpi_ps_has_completed_scope (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_init_scope
+ * FUNCTION:    acpi_ps_init_scope
  *
- * PARAMETERS:  Parser_state        - Current parser state object
+ * PARAMETERS:  parser_state        - Current parser state object
  *              Root                - the Root Node of this new scope
  *
  * RETURN:      Status
@@ -89,13 +107,13 @@ acpi_ps_has_completed_scope (
 
 acpi_status
 acpi_ps_init_scope (
-	acpi_parse_state        *parser_state,
-	acpi_parse_object       *root_op)
+	struct acpi_parse_state         *parser_state,
+	union acpi_parse_object         *root_op)
 {
-	acpi_generic_state      *scope;
+	union acpi_generic_state        *scope;
 
 
-	FUNCTION_TRACE_PTR ("Ps_init_scope", root_op);
+	ACPI_FUNCTION_TRACE_PTR ("ps_init_scope", root_op);
 
 
 	scope = acpi_ut_create_generic_state ();
@@ -118,12 +136,12 @@ acpi_ps_init_scope (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_push_scope
+ * FUNCTION:    acpi_ps_push_scope
  *
- * PARAMETERS:  Parser_state        - Current parser state object
+ * PARAMETERS:  parser_state        - Current parser state object
  *              Op                  - Current op to be pushed
- *              Remaining_args      - List of args remaining
- *              Arg_count           - Fixed or variable number of args
+ *              remaining_args      - List of args remaining
+ *              arg_count           - Fixed or variable number of args
  *
  * RETURN:      Status
  *
@@ -133,20 +151,20 @@ acpi_ps_init_scope (
 
 acpi_status
 acpi_ps_push_scope (
-	acpi_parse_state        *parser_state,
-	acpi_parse_object       *op,
-	u32                     remaining_args,
-	u32                     arg_count)
+	struct acpi_parse_state         *parser_state,
+	union acpi_parse_object         *op,
+	u32                             remaining_args,
+	u32                             arg_count)
 {
-	acpi_generic_state      *scope;
+	union acpi_generic_state        *scope;
 
 
-	FUNCTION_TRACE_PTR ("Ps_push_scope", op);
+	ACPI_FUNCTION_TRACE_PTR ("ps_push_scope", op);
 
 
 	scope = acpi_ut_create_generic_state ();
 	if (!scope) {
-		return (AE_NO_MEMORY);
+		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
 
@@ -170,7 +188,7 @@ acpi_ps_push_scope (
 	else {
 		/* single argument */
 
-		scope->parse_scope.arg_end = ACPI_MAX_AML;
+		scope->parse_scope.arg_end = ACPI_TO_POINTER (ACPI_MAX_PTR);
 	}
 
 	return_ACPI_STATUS (AE_OK);
@@ -179,13 +197,13 @@ acpi_ps_push_scope (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_pop_scope
+ * FUNCTION:    acpi_ps_pop_scope
  *
- * PARAMETERS:  Parser_state        - Current parser state object
+ * PARAMETERS:  parser_state        - Current parser state object
  *              Op                  - Where the popped op is returned
- *              Arg_list            - Where the popped "next argument" is
+ *              arg_list            - Where the popped "next argument" is
  *                                    returned
- *              Arg_count           - Count of objects in Arg_list
+ *              arg_count           - Count of objects in arg_list
  *
  * RETURN:      Status
  *
@@ -195,15 +213,15 @@ acpi_ps_push_scope (
 
 void
 acpi_ps_pop_scope (
-	acpi_parse_state        *parser_state,
-	acpi_parse_object       **op,
-	u32                     *arg_list,
-	u32                     *arg_count)
+	struct acpi_parse_state         *parser_state,
+	union acpi_parse_object         **op,
+	u32                             *arg_list,
+	u32                             *arg_count)
 {
-	acpi_generic_state      *scope = parser_state->scope;
+	union acpi_generic_state        *scope = parser_state->scope;
 
 
-	FUNCTION_TRACE ("Ps_pop_scope");
+	ACPI_FUNCTION_TRACE ("ps_pop_scope");
 
 
 	/*
@@ -240,9 +258,9 @@ acpi_ps_pop_scope (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_cleanup_scope
+ * FUNCTION:    acpi_ps_cleanup_scope
  *
- * PARAMETERS:  Parser_state        - Current parser state object
+ * PARAMETERS:  parser_state        - Current parser state object
  *
  * RETURN:      Status
  *
@@ -253,11 +271,11 @@ acpi_ps_pop_scope (
 
 void
 acpi_ps_cleanup_scope (
-	acpi_parse_state        *parser_state)
+	struct acpi_parse_state         *parser_state)
 {
-	acpi_generic_state      *scope;
+	union acpi_generic_state        *scope;
 
-	FUNCTION_TRACE_PTR ("Ps_cleanup_scope", parser_state);
+	ACPI_FUNCTION_TRACE_PTR ("ps_cleanup_scope", parser_state);
 
 
 	if (!parser_state) {
diff -urNp linux-5400/drivers/acpi/parser/pstree.c linux-5410/drivers/acpi/parser/pstree.c
--- linux-5400/drivers/acpi/parser/pstree.c
+++ linux-5410/drivers/acpi/parser/pstree.c
@@ -1,40 +1,58 @@
 /******************************************************************************
  *
  * Module Name: pstree - Parser op tree manipulation/traversal/search
- *              $Revision: 35 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
-#include "amlcode.h"
+#include <acpi/acpi.h>
+#include <acpi/acparser.h>
+#include <acpi/amlcode.h>
 
 #define _COMPONENT          ACPI_PARSER
-	 MODULE_NAME         ("pstree")
+	 ACPI_MODULE_NAME    ("pstree")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_get_arg
+ * FUNCTION:    acpi_ps_get_arg
  *
  * PARAMETERS:  Op              - Get an argument for this op
  *              Argn            - Nth argument to get
@@ -45,21 +63,21 @@
  *
  ******************************************************************************/
 
-acpi_parse_object *
+union acpi_parse_object *
 acpi_ps_get_arg (
-	acpi_parse_object       *op,
-	u32                     argn)
+	union acpi_parse_object         *op,
+	u32                             argn)
 {
-	acpi_parse_object       *arg = NULL;
-	const acpi_opcode_info  *op_info;
+	union acpi_parse_object         *arg = NULL;
+	const struct acpi_opcode_info   *op_info;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	/* Get the info structure for this opcode */
 
-	op_info = acpi_ps_get_opcode_info (op->opcode);
+	op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
 	if (op_info->class == AML_CLASS_UNKNOWN) {
 		/* Invalid opcode or ASCII character */
 
@@ -76,10 +94,10 @@ acpi_ps_get_arg (
 
 	/* Get the requested argument object */
 
-	arg = op->value.arg;
+	arg = op->common.value.arg;
 	while (arg && argn) {
 		argn--;
-		arg = arg->next;
+		arg = arg->common.next;
 	}
 
 	return (arg);
@@ -88,7 +106,7 @@ acpi_ps_get_arg (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_append_arg
+ * FUNCTION:    acpi_ps_append_arg
  *
  * PARAMETERS:  Op              - Append an argument to this Op.
  *              Arg             - Argument Op to append
@@ -101,14 +119,14 @@ acpi_ps_get_arg (
 
 void
 acpi_ps_append_arg (
-	acpi_parse_object       *op,
-	acpi_parse_object       *arg)
+	union acpi_parse_object         *op,
+	union acpi_parse_object         *arg)
 {
-	acpi_parse_object       *prev_arg;
-	const acpi_opcode_info  *op_info;
+	union acpi_parse_object         *prev_arg;
+	const struct acpi_opcode_info   *op_info;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	if (!op) {
@@ -117,11 +135,12 @@ acpi_ps_append_arg (
 
 	/* Get the info structure for this opcode */
 
-	op_info = acpi_ps_get_opcode_info (op->opcode);
+	op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
 	if (op_info->class == AML_CLASS_UNKNOWN) {
 		/* Invalid opcode */
 
-		REPORT_ERROR (("Ps_append_arg: Invalid AML Opcode: 0x%2.2X\n", op->opcode));
+		ACPI_REPORT_ERROR (("ps_append_arg: Invalid AML Opcode: 0x%2.2X\n",
+			op->common.aml_opcode));
 		return;
 	}
 
@@ -136,35 +155,35 @@ acpi_ps_append_arg (
 
 	/* Append the argument to the linked argument list */
 
-	if (op->value.arg) {
+	if (op->common.value.arg) {
 		/* Append to existing argument list */
 
-		prev_arg = op->value.arg;
-		while (prev_arg->next) {
-			prev_arg = prev_arg->next;
+		prev_arg = op->common.value.arg;
+		while (prev_arg->common.next) {
+			prev_arg = prev_arg->common.next;
 		}
-		prev_arg->next = arg;
+		prev_arg->common.next = arg;
 	}
 
 	else {
 		/* No argument list, this will be the first argument */
 
-		op->value.arg = arg;
+		op->common.value.arg = arg;
 	}
 
 
 	/* Set the parent in this arg and any args linked after it */
 
 	while (arg) {
-		arg->parent = op;
-		arg = arg->next;
+		arg->common.parent = op;
+		arg = arg->common.next;
 	}
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_get_child
+ * FUNCTION:    acpi_ps_get_child
  *
  * PARAMETERS:  Op              - Get the child of this Op
  *
@@ -174,17 +193,17 @@ acpi_ps_append_arg (
  *
  ******************************************************************************/
 
-acpi_parse_object *
+union acpi_parse_object *
 acpi_ps_get_child (
-	acpi_parse_object       *op)
+	union acpi_parse_object         *op)
 {
-	acpi_parse_object       *child = NULL;
+	union acpi_parse_object         *child = NULL;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
-	switch (op->opcode) {
+	switch (op->common.aml_opcode) {
 	case AML_SCOPE_OP:
 	case AML_ELSE_OP:
 	case AML_DEVICE_OP:
@@ -219,6 +238,10 @@ acpi_ps_get_child (
 		child = acpi_ps_get_arg (op, 3);
 		break;
 
+
+	default:
+		/* All others have no children */
+		break;
 	}
 
 	return (child);
@@ -227,7 +250,7 @@ acpi_ps_get_child (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_get_depth_next
+ * FUNCTION:    acpi_ps_get_depth_next
  *
  * PARAMETERS:  Origin          - Root of subtree to search
  *              Op              - Last (previous) Op that was found
@@ -239,17 +262,17 @@ acpi_ps_get_child (
  *
  ******************************************************************************/
 
-acpi_parse_object *
+union acpi_parse_object *
 acpi_ps_get_depth_next (
-	acpi_parse_object       *origin,
-	acpi_parse_object       *op)
+	union acpi_parse_object         *origin,
+	union acpi_parse_object         *op)
 {
-	acpi_parse_object       *next = NULL;
-	acpi_parse_object       *parent;
-	acpi_parse_object       *arg;
+	union acpi_parse_object         *next = NULL;
+	union acpi_parse_object         *parent;
+	union acpi_parse_object         *arg;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	if (!op) {
@@ -265,19 +288,19 @@ acpi_ps_get_depth_next (
 
 	/* look for a sibling */
 
-	next = op->next;
+	next = op->common.next;
 	if (next) {
 		return (next);
 	}
 
 	/* look for a sibling of parent */
 
-	parent = op->parent;
+	parent = op->common.parent;
 
 	while (parent) {
 		arg = acpi_ps_get_arg (parent, 0);
 		while (arg && (arg != origin) && (arg != op)) {
-			arg = arg->next;
+			arg = arg->common.next;
 		}
 
 		if (arg == origin) {
@@ -286,13 +309,14 @@ acpi_ps_get_depth_next (
 			return (NULL);
 		}
 
-		if (parent->next) {
+		if (parent->common.next) {
 			/* found sibling of parent */
-			return (parent->next);
+
+			return (parent->common.next);
 		}
 
 		op = parent;
-		parent = parent->parent;
+		parent = parent->common.parent;
 	}
 
 	return (next);
diff -urNp linux-5400/drivers/acpi/parser/psutils.c linux-5410/drivers/acpi/parser/psutils.c
--- linux-5400/drivers/acpi/parser/psutils.c
+++ linux-5410/drivers/acpi/parser/psutils.c
@@ -1,47 +1,89 @@
 /******************************************************************************
  *
  * Module Name: psutils - Parser miscellaneous utilities (Parser only)
- *              $Revision: 44 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
-#include "amlcode.h"
+#include <acpi/acpi.h>
+#include <acpi/acparser.h>
+#include <acpi/amlcode.h>
+#include <acpi/acnamesp.h>
 
 #define _COMPONENT          ACPI_PARSER
-	 MODULE_NAME         ("psutils")
+	 ACPI_MODULE_NAME    ("psutils")
 
 
-#define PARSEOP_GENERIC     0x01
-#define PARSEOP_NAMED       0x02
-#define PARSEOP_DEFERRED    0x04
-#define PARSEOP_BYTELIST    0x08
-#define PARSEOP_IN_CACHE    0x80
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ps_create_scope_op
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      scope_op
+ *
+ * DESCRIPTION: Create a Scope and associated namepath op with the root name
+ *
+ ******************************************************************************/
+
+union acpi_parse_object *
+acpi_ps_create_scope_op (
+	void)
+{
+	union acpi_parse_object         *scope_op;
+
+
+	scope_op = acpi_ps_alloc_op (AML_SCOPE_OP);
+	if (!scope_op) {
+		return (NULL);
+	}
+
+
+	scope_op->named.name = ACPI_ROOT_NAME;
+	return (scope_op);
+}
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_init_op
+ * FUNCTION:    acpi_ps_init_op
  *
  * PARAMETERS:  Op              - A newly allocated Op object
  *              Opcode          - Opcode to store in the Op
@@ -55,28 +97,23 @@
 
 void
 acpi_ps_init_op (
-	acpi_parse_object       *op,
-	u16                     opcode)
+	union acpi_parse_object         *op,
+	u16                             opcode)
 {
-	const acpi_opcode_info  *aml_op;
-
-
-	FUNCTION_ENTRY ();
-
+	ACPI_FUNCTION_ENTRY ();
 
-	op->data_type = ACPI_DESC_TYPE_PARSER;
-	op->opcode = opcode;
 
-	aml_op = acpi_ps_get_opcode_info (opcode);
+	op->common.data_type = ACPI_DESC_TYPE_PARSER;
+	op->common.aml_opcode = opcode;
 
-	DEBUG_ONLY_MEMBERS (STRNCPY (op->op_name, aml_op->name,
-			   sizeof (op->op_name)));
+	ACPI_DISASM_ONLY_MEMBERS (ACPI_STRNCPY (op->common.aml_op_name,
+			(acpi_ps_get_opcode_info (opcode))->name, sizeof (op->common.aml_op_name)));
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_alloc_op
+ * FUNCTION:    acpi_ps_alloc_op
  *
  * PARAMETERS:  Opcode          - Opcode that will be stored in the new Op
  *
@@ -88,17 +125,17 @@ acpi_ps_init_op (
  *
  ******************************************************************************/
 
-acpi_parse_object*
+union acpi_parse_object*
 acpi_ps_alloc_op (
-	u16                     opcode)
+	u16                             opcode)
 {
-	acpi_parse_object       *op = NULL;
-	u32                     size;
-	u8                      flags;
-	const acpi_opcode_info  *op_info;
+	union acpi_parse_object         *op = NULL;
+	u32                             size;
+	u8                              flags;
+	const struct acpi_opcode_info   *op_info;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	op_info = acpi_ps_get_opcode_info (opcode);
@@ -106,33 +143,28 @@ acpi_ps_alloc_op (
 	/* Allocate the minimum required size object */
 
 	if (op_info->flags & AML_DEFER) {
-		size = sizeof (acpi_parse2_object);
-		flags = PARSEOP_DEFERRED;
+		size = sizeof (struct acpi_parse_obj_named);
+		flags = ACPI_PARSEOP_DEFERRED;
 	}
-
 	else if (op_info->flags & AML_NAMED) {
-		size = sizeof (acpi_parse2_object);
-		flags = PARSEOP_NAMED;
+		size = sizeof (struct acpi_parse_obj_named);
+		flags = ACPI_PARSEOP_NAMED;
 	}
-
 	else if (opcode == AML_INT_BYTELIST_OP) {
-		size = sizeof (acpi_parse2_object);
-		flags = PARSEOP_BYTELIST;
+		size = sizeof (struct acpi_parse_obj_named);
+		flags = ACPI_PARSEOP_BYTELIST;
 	}
-
 	else {
-		size = sizeof (acpi_parse_object);
-		flags = PARSEOP_GENERIC;
+		size = sizeof (struct acpi_parse_obj_common);
+		flags = ACPI_PARSEOP_GENERIC;
 	}
 
-
-	if (size == sizeof (acpi_parse_object)) {
+	if (size == sizeof (struct acpi_parse_obj_common)) {
 		/*
 		 * The generic op is by far the most common (16 to 1)
 		 */
 		op = acpi_ut_acquire_from_cache (ACPI_MEM_LIST_PSNODE);
 	}
-
 	else {
 		op = acpi_ut_acquire_from_cache (ACPI_MEM_LIST_PSNODE_EXT);
 	}
@@ -141,7 +173,7 @@ acpi_ps_alloc_op (
 
 	if (op) {
 		acpi_ps_init_op (op, opcode);
-		op->flags = flags;
+		op->common.flags = flags;
 	}
 
 	return (op);
@@ -150,7 +182,7 @@ acpi_ps_alloc_op (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_free_op
+ * FUNCTION:    acpi_ps_free_op
  *
  * PARAMETERS:  Op              - Op to be freed
  *
@@ -163,19 +195,18 @@ acpi_ps_alloc_op (
 
 void
 acpi_ps_free_op (
-	acpi_parse_object       *op)
+	union acpi_parse_object         *op)
 {
-	PROC_NAME ("Ps_free_op");
+	ACPI_FUNCTION_NAME ("ps_free_op");
 
 
-	if (op->opcode == AML_INT_RETURN_VALUE_OP) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Free retval op: %p\n", op));
+	if (op->common.aml_opcode == AML_INT_RETURN_VALUE_OP) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Free retval op: %p\n", op));
 	}
 
-	if (op->flags == PARSEOP_GENERIC) {
+	if (op->common.flags & ACPI_PARSEOP_GENERIC) {
 		acpi_ut_release_to_cache (ACPI_MEM_LIST_PSNODE, op);
 	}
-
 	else {
 		acpi_ut_release_to_cache (ACPI_MEM_LIST_PSNODE_EXT, op);
 	}
@@ -184,7 +215,7 @@ acpi_ps_free_op (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_delete_parse_cache
+ * FUNCTION:    acpi_ps_delete_parse_cache
  *
  * PARAMETERS:  None
  *
@@ -198,7 +229,7 @@ void
 acpi_ps_delete_parse_cache (
 	void)
 {
-	FUNCTION_TRACE ("Ps_delete_parse_cache");
+	ACPI_FUNCTION_TRACE ("ps_delete_parse_cache");
 
 
 	acpi_ut_delete_generic_cache (ACPI_MEM_LIST_PSNODE);
@@ -221,7 +252,7 @@ acpi_ps_delete_parse_cache (
  */
 u8
 acpi_ps_is_leading_char (
-	u32                     c)
+	u32                             c)
 {
 	return ((u8) (c == '_' || (c >= 'A' && c <= 'Z')));
 }
@@ -232,7 +263,7 @@ acpi_ps_is_leading_char (
  */
 u8
 acpi_ps_is_prefix_char (
-	u32                     c)
+	u32                             c)
 {
 	return ((u8) (c == '\\' || c == '^'));
 }
@@ -243,19 +274,19 @@ acpi_ps_is_prefix_char (
  */
 u32
 acpi_ps_get_name (
-	acpi_parse_object       *op)
+	union acpi_parse_object         *op)
 {
 
 
 	/* The "generic" object has no name associated with it */
 
-	if (op->flags & PARSEOP_GENERIC) {
+	if (op->common.flags & ACPI_PARSEOP_GENERIC) {
 		return (0);
 	}
 
 	/* Only the "Extended" parse objects have a name */
 
-	return (((acpi_parse2_object *) op)->name);
+	return (op->named.name);
 }
 
 
@@ -264,16 +295,16 @@ acpi_ps_get_name (
  */
 void
 acpi_ps_set_name (
-	acpi_parse_object       *op,
-	u32                     name)
+	union acpi_parse_object         *op,
+	u32                             name)
 {
 
 	/* The "generic" object has no name associated with it */
 
-	if (op->flags & PARSEOP_GENERIC) {
+	if (op->common.flags & ACPI_PARSEOP_GENERIC) {
 		return;
 	}
 
-	((acpi_parse2_object *) op)->name = name;
+	op->named.name = name;
 }
 
diff -urNp linux-5400/drivers/acpi/parser/pswalk.c linux-5410/drivers/acpi/parser/pswalk.c
--- linux-5400/drivers/acpi/parser/pswalk.c
+++ linux-5410/drivers/acpi/parser/pswalk.c
@@ -1,47 +1,62 @@
 /******************************************************************************
  *
  * Module Name: pswalk - Parser routines to walk parsed op tree(s)
- *              $Revision: 58 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "amlcode.h"
-#include "acparser.h"
-#include "acdispat.h"
-#include "acnamesp.h"
-#include "acinterp.h"
+#include <acpi/acpi.h>
+#include <acpi/acparser.h>
+#include <acpi/acdispat.h>
 
 #define _COMPONENT          ACPI_PARSER
-	 MODULE_NAME         ("pswalk")
+	 ACPI_MODULE_NAME    ("pswalk")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_get_next_walk_op
+ * FUNCTION:    acpi_ps_get_next_walk_op
  *
- * PARAMETERS:  Walk_state          - Current state of the walk
+ * PARAMETERS:  walk_state          - Current state of the walk
  *              Op                  - Current Op to be walked
- *              Ascending_callback  - Procedure called when Op is complete
+ *              ascending_callback  - Procedure called when Op is complete
  *
  * RETURN:      Status
  *
@@ -51,22 +66,22 @@
 
 acpi_status
 acpi_ps_get_next_walk_op (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op,
-	acpi_parse_upwards      ascending_callback)
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op,
+	acpi_parse_upwards              ascending_callback)
 {
-	acpi_parse_object       *next;
-	acpi_parse_object       *parent;
-	acpi_parse_object       *grand_parent;
-	acpi_status             status;
+	union acpi_parse_object         *next;
+	union acpi_parse_object         *parent;
+	union acpi_parse_object         *grand_parent;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE_PTR ("Ps_get_next_walk_op", op);
+	ACPI_FUNCTION_TRACE_PTR ("ps_get_next_walk_op", op);
 
 
 	/* Check for a argument only if we are descending in the tree */
 
-	if (walk_state->next_op_info != NEXT_OP_UPWARD) {
+	if (walk_state->next_op_info != ACPI_NEXT_OP_UPWARD) {
 		/* Look for an argument or child of the current op */
 
 		next = acpi_ps_get_arg (op, 0);
@@ -75,22 +90,21 @@ acpi_ps_get_next_walk_op (
 
 			walk_state->prev_op     = op;
 			walk_state->next_op     = next;
-			walk_state->next_op_info = NEXT_OP_DOWNWARD;
+			walk_state->next_op_info = ACPI_NEXT_OP_DOWNWARD;
 
 			return_ACPI_STATUS (AE_OK);
 		}
 
-
 		/*
 		 * No more children, this Op is complete.  Save Next and Parent
 		 * in case the Op object gets deleted by the callback routine
 		 */
-		next    = op->next;
-		parent  = op->parent;
+		next    = op->common.next;
+		parent  = op->common.parent;
 
 		walk_state->op    = op;
-		walk_state->op_info = acpi_ps_get_opcode_info (op->opcode);
-		walk_state->opcode = op->opcode;
+		walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
+		walk_state->opcode = op->common.aml_opcode;
 
 		status = ascending_callback (walk_state);
 
@@ -115,7 +129,7 @@ acpi_ps_get_next_walk_op (
 
 			walk_state->prev_op     = op;
 			walk_state->next_op     = next;
-			walk_state->next_op_info = NEXT_OP_DOWNWARD;
+			walk_state->next_op_info = ACPI_NEXT_OP_DOWNWARD;
 
 			/* Continue downward */
 
@@ -127,7 +141,6 @@ acpi_ps_get_next_walk_op (
 		 * the tree
 		 */
 	}
-
 	else {
 		/*
 		 * We are resuming a walk, and we were (are) going upward in the tree.
@@ -136,7 +149,6 @@ acpi_ps_get_next_walk_op (
 		parent = op;
 	}
 
-
 	/*
 	 * Look for a sibling of the current Op's parent
 	 * Continue moving up the tree until we find a node that has not been
@@ -145,12 +157,12 @@ acpi_ps_get_next_walk_op (
 	while (parent) {
 		/* We are moving up the tree, therefore this parent Op is complete */
 
-		grand_parent = parent->parent;
-		next        = parent->next;
+		grand_parent = parent->common.parent;
+		next        = parent->common.next;
 
 		walk_state->op    = parent;
-		walk_state->op_info = acpi_ps_get_opcode_info (parent->opcode);
-		walk_state->opcode = parent->opcode;
+		walk_state->op_info = acpi_ps_get_opcode_info (parent->common.aml_opcode);
+		walk_state->opcode = parent->common.aml_opcode;
 
 		status = ascending_callback (walk_state);
 
@@ -175,7 +187,7 @@ acpi_ps_get_next_walk_op (
 
 			walk_state->prev_op     = parent;
 			walk_state->next_op     = next;
-			walk_state->next_op_info = NEXT_OP_DOWNWARD;
+			walk_state->next_op_info = ACPI_NEXT_OP_DOWNWARD;
 
 			return_ACPI_STATUS (status);
 		}
@@ -188,9 +200,10 @@ acpi_ps_get_next_walk_op (
 	}
 
 
-	/* Got all the way to the top of the tree, we must be done! */
-	/* However, the code should have terminated in the loop above */
-
+	/*
+	 * Got all the way to the top of the tree, we must be done!
+	 * However, the code should have terminated in the loop above
+	 */
 	walk_state->next_op     = NULL;
 
 	return_ACPI_STATUS (AE_OK);
@@ -199,22 +212,22 @@ acpi_ps_get_next_walk_op (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_delete_completed_op
+ * FUNCTION:    acpi_ps_delete_completed_op
  *
  * PARAMETERS:  State           - Walk state
  *              Op              - Completed op
  *
  * RETURN:      AE_OK
  *
- * DESCRIPTION: Callback function for Acpi_ps_get_next_walk_op(). Used during
- *              Acpi_ps_delete_parse tree to delete Op objects when all sub-objects
+ * DESCRIPTION: Callback function for acpi_ps_get_next_walk_op(). Used during
+ *              acpi_ps_delete_parse tree to delete Op objects when all sub-objects
  *              have been visited (and deleted.)
  *
  ******************************************************************************/
 
-static acpi_status
+acpi_status
 acpi_ps_delete_completed_op (
-	acpi_walk_state         *walk_state)
+	struct acpi_walk_state          *walk_state)
 {
 
 	acpi_ps_free_op (walk_state->op);
@@ -224,9 +237,9 @@ acpi_ps_delete_completed_op (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ps_delete_parse_tree
+ * FUNCTION:    acpi_ps_delete_parse_tree
  *
- * PARAMETERS:  Subtree_root        - Root of tree (or subtree) to delete
+ * PARAMETERS:  subtree_root        - Root of tree (or subtree) to delete
  *
  * RETURN:      None
  *
@@ -236,13 +249,14 @@ acpi_ps_delete_completed_op (
 
 void
 acpi_ps_delete_parse_tree (
-	acpi_parse_object       *subtree_root)
+	union acpi_parse_object         *subtree_root)
 {
-	acpi_walk_state         *walk_state;
-	acpi_walk_list          walk_list;
+	struct acpi_walk_state          *walk_state;
+	struct acpi_thread_state        *thread;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE_PTR ("Ps_delete_parse_tree", subtree_root);
+	ACPI_FUNCTION_TRACE_PTR ("ps_delete_parse_tree", subtree_root);
 
 
 	if (!subtree_root) {
@@ -251,11 +265,12 @@ acpi_ps_delete_parse_tree (
 
 	/* Create and initialize a new walk list */
 
-	walk_list.walk_state = NULL;
-	walk_list.acquired_mutex_list.prev = NULL;
-	walk_list.acquired_mutex_list.next = NULL;
+	thread = acpi_ut_create_thread_state ();
+	if (!thread) {
+		return_VOID;
+	}
 
-	walk_state = acpi_ds_create_walk_state (TABLE_ID_DSDT, NULL, NULL, &walk_list);
+	walk_state = acpi_ds_create_walk_state (0, NULL, NULL, thread);
 	if (!walk_state) {
 		return_VOID;
 	}
@@ -264,25 +279,26 @@ acpi_ps_delete_parse_tree (
 	walk_state->descending_callback = NULL;
 	walk_state->ascending_callback  = NULL;
 
-
 	walk_state->origin = subtree_root;
 	walk_state->next_op = subtree_root;
 
-
 	/* Head downward in the tree */
 
-	walk_state->next_op_info = NEXT_OP_DOWNWARD;
+	walk_state->next_op_info = ACPI_NEXT_OP_DOWNWARD;
 
 	/* Visit all nodes in the subtree */
 
 	while (walk_state->next_op) {
-		acpi_ps_get_next_walk_op (walk_state, walk_state->next_op,
+		status = acpi_ps_get_next_walk_op (walk_state, walk_state->next_op,
 				 acpi_ps_delete_completed_op);
+		if (ACPI_FAILURE (status)) {
+			break;
+		}
 	}
 
 	/* We are done with this walk */
 
-	acpi_ex_release_all_mutexes ((acpi_operand_object *) &walk_list.acquired_mutex_list);
+	acpi_ut_delete_generic_state (ACPI_CAST_PTR (union acpi_generic_state, thread));
 	acpi_ds_delete_walk_state (walk_state);
 
 	return_VOID;
diff -urNp linux-5400/drivers/acpi/parser/psxface.c linux-5410/drivers/acpi/parser/psxface.c
--- linux-5400/drivers/acpi/parser/psxface.c
+++ linux-5410/drivers/acpi/parser/psxface.c
@@ -1,51 +1,68 @@
 /******************************************************************************
  *
  * Module Name: psxface - Parser external interfaces
- *              $Revision: 52 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
-#include "acdispat.h"
-#include "acinterp.h"
-#include "amlcode.h"
-#include "acnamesp.h"
+#include <acpi/acpi.h>
+#include <acpi/acparser.h>
+#include <acpi/acdispat.h>
+#include <acpi/acinterp.h>
+#include <acpi/acnamesp.h>
 
 
 #define _COMPONENT          ACPI_PARSER
-	 MODULE_NAME         ("psxface")
+	 ACPI_MODULE_NAME    ("psxface")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_psx_execute
+ * FUNCTION:    acpi_psx_execute
  *
- * PARAMETERS:  Method_node         - A method object containing both the AML
+ * PARAMETERS:  method_node         - A method object containing both the AML
  *                                    address and length.
  *              **Params            - List of parameters to pass to method,
  *                                    terminated by NULL. Params itself may be
  *                                    NULL if no parameters are being passed.
- *              **Return_obj_desc   - Return object from execution of the
+ *              **return_obj_desc   - Return object from execution of the
  *                                    method.
  *
  * RETURN:      Status
@@ -56,18 +73,18 @@
 
 acpi_status
 acpi_psx_execute (
-	acpi_namespace_node     *method_node,
-	acpi_operand_object     **params,
-	acpi_operand_object     **return_obj_desc)
+	struct acpi_namespace_node      *method_node,
+	union acpi_operand_object       **params,
+	union acpi_operand_object       **return_obj_desc)
 {
-	acpi_status             status;
-	acpi_operand_object     *obj_desc;
-	u32                     i;
-	acpi_parse_object       *op;
-	acpi_walk_state         *walk_state;
+	acpi_status                     status;
+	union acpi_operand_object       *obj_desc;
+	u32                             i;
+	union acpi_parse_object         *op;
+	struct acpi_walk_state          *walk_state;
 
 
-	FUNCTION_TRACE ("Psx_execute");
+	ACPI_FUNCTION_TRACE ("psx_execute");
 
 
 	/* Validate the Node and get the attached object */
@@ -102,20 +119,27 @@ acpi_psx_execute (
 	 * 1) Perform the first pass parse of the method to enter any
 	 * named objects that it creates into the namespace
 	 */
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
 		"**** Begin Method Parse **** Entry=%p obj=%p\n",
 		method_node, obj_desc));
 
 	/* Create and init a Root Node */
 
-	op = acpi_ps_alloc_op (AML_SCOPE_OP);
+	op = acpi_ps_create_scope_op ();
 	if (!op) {
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
+	/*
+	 * Get a new owner_id for objects created by this method. Namespace
+	 * objects (such as Operation Regions) can be created during the
+	 * first pass parse.
+	 */
+	obj_desc->method.owning_id = acpi_ut_allocate_owner_id (ACPI_OWNER_TYPE_METHOD);
+
 	/* Create and initialize a new walk state */
 
-	walk_state = acpi_ds_create_walk_state (TABLE_ID_DSDT,
+	walk_state = acpi_ds_create_walk_state (obj_desc->method.owning_id,
 			   NULL, NULL, NULL);
 	if (!walk_state) {
 		return_ACPI_STATUS (AE_NO_MEMORY);
@@ -124,7 +148,7 @@ acpi_psx_execute (
 	status = acpi_ds_init_aml_walk (walk_state, op, method_node, obj_desc->method.aml_start,
 			  obj_desc->method.aml_length, NULL, NULL, 1);
 	if (ACPI_FAILURE (status)) {
-		/* TBD: delete walk state */
+		acpi_ds_delete_walk_state (walk_state);
 		return_ACPI_STATUS (status);
 	}
 
@@ -133,30 +157,28 @@ acpi_psx_execute (
 	status = acpi_ps_parse_aml (walk_state);
 	acpi_ps_delete_parse_tree (op);
 
-
 	/*
 	 * 2) Execute the method.  Performs second pass parse simultaneously
 	 */
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
 		"**** Begin Method Execution **** Entry=%p obj=%p\n",
 		method_node, obj_desc));
 
 	/* Create and init a Root Node */
 
-	op = acpi_ps_alloc_op (AML_SCOPE_OP);
+	op = acpi_ps_create_scope_op ();
 	if (!op) {
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
 	/* Init new op with the method name and pointer back to the NS node */
 
-	acpi_ps_set_name (op, method_node->name);
-	op->node = method_node;
+	acpi_ps_set_name (op, method_node->name.integer);
+	op->common.node = method_node;
 
 	/* Create and initialize a new walk state */
 
-	walk_state = acpi_ds_create_walk_state (TABLE_ID_DSDT,
-			   NULL, NULL, NULL);
+	walk_state = acpi_ds_create_walk_state (0, NULL, NULL, NULL);
 	if (!walk_state) {
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
@@ -164,7 +186,7 @@ acpi_psx_execute (
 	status = acpi_ds_init_aml_walk (walk_state, op, method_node, obj_desc->method.aml_start,
 			  obj_desc->method.aml_length, params, return_obj_desc, 3);
 	if (ACPI_FAILURE (status)) {
-		/* TBD: delete walk state */
+		acpi_ds_delete_walk_state (walk_state);
 		return_ACPI_STATUS (status);
 	}
 
@@ -178,30 +200,24 @@ acpi_psx_execute (
 		/* Take away the extra reference that we gave the parameters above */
 
 		for (i = 0; params[i]; i++) {
-			acpi_ut_update_object_reference (params[i], REF_DECREMENT);
-		}
-	}
-
+			/* Ignore errors, just do them all */
 
-	if (ACPI_FAILURE (status)) {
-		DUMP_PATHNAME (method_node, "Ps_execute: method failed -",
-			ACPI_LV_ERROR, _COMPONENT);
+			(void) acpi_ut_update_object_reference (params[i], REF_DECREMENT);
+		}
 	}
 
-
 	/*
 	 * If the method has returned an object, signal this to the caller with
 	 * a control exception code
 	 */
 	if (*return_obj_desc) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Method returned Obj_desc=%p\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Method returned obj_desc=%p\n",
 			*return_obj_desc));
-		DUMP_STACK_ENTRY (*return_obj_desc);
+		ACPI_DUMP_STACK_ENTRY (*return_obj_desc);
 
 		status = AE_CTRL_RETURN_VALUE;
 	}
 
-
 	return_ACPI_STATUS (status);
 }
 
diff -urNp linux-5400/drivers/acpi/pci_bind.c linux-5410/drivers/acpi/pci_bind.c
--- linux-5400/drivers/acpi/pci_bind.c
+++ linux-5410/drivers/acpi/pci_bind.c
@@ -0,0 +1,309 @@
+/*
+ *  pci_bind.c - ACPI PCI Device Binding ($Revision: 3 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/pm.h>
+#include <linux/pci.h>
+#include <linux/acpi.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+
+#define _COMPONENT		ACPI_PCI_COMPONENT
+ACPI_MODULE_NAME		("pci_bind")
+
+#define PREFIX			"ACPI: "
+
+
+struct acpi_pci_data {
+	struct acpi_pci_id	id;
+	struct pci_bus		*bus;
+	struct pci_dev		*dev;
+};
+
+
+void
+acpi_pci_data_handler (
+	acpi_handle		handle,
+	u32			function,
+	void			*context)
+{
+	ACPI_FUNCTION_TRACE("acpi_pci_data_handler");
+
+	/* TBD: Anything we need to do here? */
+
+	return_VOID;
+}
+
+
+/**
+ * acpi_os_get_pci_id
+ * ------------------
+ * This function is used by the ACPI Interpreter (a.k.a. Core Subsystem)
+ * to resolve PCI information for ACPI-PCI devices defined in the namespace.
+ * This typically occurs when resolving PCI operation region information.
+ */
+acpi_status
+acpi_os_get_pci_id (
+	acpi_handle		handle,
+	struct acpi_pci_id	*id)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_device	*device = NULL;
+	struct acpi_pci_data	*data = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_os_get_pci_id");
+
+	if (!id)
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+
+	result = acpi_bus_get_device(handle, &device);
+	if (result) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Invalid ACPI Bus context for device %s\n",
+			acpi_device_bid(device)));
+		return_ACPI_STATUS(AE_NOT_EXIST);
+	}
+
+	status = acpi_get_data(handle, acpi_pci_data_handler, (void**) &data);
+	if (ACPI_FAILURE(status) || !data || !data->dev) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Invalid ACPI-PCI context for device %s\n",
+			acpi_device_bid(device)));
+		return_ACPI_STATUS(status);
+	}
+
+	*id = data->id;
+	
+	/*
+	id->segment = data->id.segment;
+	id->bus = data->id.bus;
+	id->device = data->id.device;
+	id->function = data->id.function;
+	*/
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+		"Device %s has PCI address %02x:%02x:%02x.%02x\n", 
+		acpi_device_bid(device), id->segment, id->bus, 
+		id->device, id->function));
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+	
+int
+acpi_pci_bind (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_pci_data	*data = NULL;
+	struct acpi_pci_data	*pdata = NULL;
+	char			pathname[ACPI_PATHNAME_MAX] = {0};
+	struct acpi_buffer	buffer = {ACPI_PATHNAME_MAX, pathname};
+	acpi_handle		handle = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_bind");
+
+	if (!device || !device->parent)
+		return_VALUE(-EINVAL);
+
+	data = kmalloc(sizeof(struct acpi_pci_data), GFP_KERNEL);
+	if (!data)
+		return_VALUE(-ENOMEM);
+	memset(data, 0, sizeof(struct acpi_pci_data));
+
+	acpi_get_name(device->handle, ACPI_FULL_PATHNAME, &buffer);
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Binding PCI device [%s]...\n", 
+		pathname));
+
+	/* 
+	 * Segment & Bus
+	 * -------------
+	 * These are obtained via the parent device's ACPI-PCI context.
+	 */
+	status = acpi_get_data(device->parent->handle, acpi_pci_data_handler, 
+		(void**) &pdata);
+	if (ACPI_FAILURE(status) || !pdata || !pdata->bus) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Invalid ACPI-PCI context for parent device %s\n",
+			acpi_device_bid(device->parent)));
+		result = -ENODEV;
+		goto end;
+	}
+	data->id.segment = pdata->id.segment;
+	data->id.bus = pdata->bus->number;
+
+	/*
+	 * Device & Function
+	 * -----------------
+	 * These are simply obtained from the device's _ADR method.  Note
+	 * that a value of zero is valid.
+	 */
+	data->id.device = device->pnp.bus_address >> 16;
+	data->id.function = device->pnp.bus_address & 0xFFFF;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "...to %02x:%02x:%02x.%02x\n",
+		data->id.segment, data->id.bus, data->id.device, 
+		data->id.function));
+
+	/*
+	 * TBD: Support slot devices (e.g. function=0xFFFF).
+	 */
+
+	/* 
+	 * Locate PCI Device
+	 * -----------------
+	 * Locate matching device in PCI namespace.  If it doesn't exist
+	 * this typically means that the device isn't currently inserted
+	 * (e.g. docking station, port replicator, etc.).
+	 */
+	data->dev = pci_find_slot(data->id.bus, PCI_DEVFN(data->id.device, data->id.function));
+	if (!data->dev) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Device %02x:%02x:%02x.%02x not present in PCI namespace\n",
+			data->id.segment, data->id.bus, 
+			data->id.device, data->id.function));
+		result = -ENODEV;
+		goto end;
+	}
+	if (!data->dev->bus) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Device %02x:%02x:%02x.%02x has invalid 'bus' field\n",
+			data->id.segment, data->id.bus, 
+			data->id.device, data->id.function));
+		result = -ENODEV;
+		goto end;
+	}
+
+	/*
+	 * PCI Bridge?
+	 * -----------
+	 * If so, set the 'bus' field and install the 'bind' function to 
+	 * facilitate callbacks for all of its children.
+	 */
+	if (data->dev->subordinate) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"Device %02x:%02x:%02x.%02x is a PCI bridge\n",
+			data->id.segment, data->id.bus, 
+			data->id.device, data->id.function));
+		data->bus = data->dev->subordinate;
+		device->ops.bind = acpi_pci_bind;
+	}
+
+	/*
+	 * Attach ACPI-PCI Context
+	 * -----------------------
+	 * Thus binding the ACPI and PCI devices.
+	 */
+	status = acpi_attach_data(device->handle, acpi_pci_data_handler, data);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to attach ACPI-PCI context to device %s\n",
+			acpi_device_bid(device)));
+		result = -ENODEV;
+		goto end;
+	}
+
+	/*
+	 * PCI Routing Table
+	 * -----------------
+	 * Evaluate and parse _PRT, if exists.  This code is independent of 
+	 * PCI bridges (above) to allow parsing of _PRT objects within the
+	 * scope of non-bridge devices.  Note that _PRTs within the scope of
+	 * a PCI bridge assume the bridge's subordinate bus number.
+	 *
+	 * TBD: Can _PRTs exist within the scope of non-bridge PCI devices?
+	 */
+	status = acpi_get_handle(device->handle, METHOD_NAME__PRT, &handle);
+	if (ACPI_SUCCESS(status)) {
+		if (data->bus)				    /* PCI-PCI bridge */
+			acpi_pci_irq_add_prt(device->handle, data->id.segment, 
+				data->bus->number);
+		else				     /* non-bridge PCI device */
+			acpi_pci_irq_add_prt(device->handle, data->id.segment,
+				data->id.bus);
+	}
+
+end:
+	if (result)
+		kfree(data);
+
+	return_VALUE(result);
+}
+
+
+int 
+acpi_pci_bind_root (
+	struct acpi_device	*device,
+	struct acpi_pci_id	*id,
+	struct pci_bus		*bus) 
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_pci_data	*data = NULL;
+	char			pathname[ACPI_PATHNAME_MAX] = {0};
+	struct acpi_buffer	buffer = {ACPI_PATHNAME_MAX, pathname};
+
+	ACPI_FUNCTION_TRACE("acpi_pci_bind_root");
+
+	if (!device || !id || !bus)
+		return_VALUE(-EINVAL);
+
+	data = kmalloc(sizeof(struct acpi_pci_data), GFP_KERNEL);
+	if (!data)
+		return_VALUE(-ENOMEM);
+	memset(data, 0, sizeof(struct acpi_pci_data));
+
+	data->id = *id;
+	data->bus = bus;
+	device->ops.bind = acpi_pci_bind;
+
+	acpi_get_name(device->handle, ACPI_FULL_PATHNAME, &buffer);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Binding PCI root bridge [%s] to "
+		"%02x:%02x\n", pathname, id->segment, id->bus));
+
+	status = acpi_attach_data(device->handle, acpi_pci_data_handler, data);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to attach ACPI-PCI context to device %s\n",
+			pathname));
+		result = -ENODEV;
+		goto end;
+	}
+
+end:
+	if (result != 0)
+		kfree(data);
+
+	return_VALUE(result);
+}
diff -urNp linux-5400/drivers/acpi/pci_irq.c linux-5410/drivers/acpi/pci_irq.c
--- linux-5400/drivers/acpi/pci_irq.c
+++ linux-5410/drivers/acpi/pci_irq.c
@@ -0,0 +1,411 @@
+/*
+ *  pci_irq.c - ACPI PCI Interrupt Routing ($Revision: 11 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *  Copyright (C) 2002       Dominik Brodowski <devel@brodo.de>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/pm.h>
+#include <linux/pci.h>
+#include <linux/acpi.h>
+#ifdef CONFIG_X86_IO_APIC
+#include <asm/mpspec.h>
+#endif
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+
+#define _COMPONENT		ACPI_PCI_COMPONENT
+ACPI_MODULE_NAME		("pci_irq")
+
+#define PREFIX			"PCI: "
+
+struct acpi_prt_list		acpi_prt;
+
+#ifdef CONFIG_X86
+extern void eisa_set_level_irq(unsigned int irq);
+#endif
+
+
+/* --------------------------------------------------------------------------
+                         PCI IRQ Routing Table (PRT) Support
+   -------------------------------------------------------------------------- */
+
+static struct acpi_prt_entry *
+acpi_pci_irq_find_prt_entry (
+	int			segment,
+	int			bus,
+	int			device,
+	int			pin)
+{
+	struct list_head	*node = NULL;
+	struct acpi_prt_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_irq_find_prt_entry");
+
+	/*
+	 * Parse through all PRT entries looking for a match on the specified
+	 * PCI device's segment, bus, device, and pin (don't care about func).
+	 *
+	 * TBD: Acquire/release lock
+	 */
+	list_for_each(node, &acpi_prt.entries) {
+		entry = list_entry(node, struct acpi_prt_entry, node);
+		if ((segment == entry->id.segment) 
+			&& (bus == entry->id.bus) 
+			&& (device == entry->id.device)
+			&& (pin == entry->pin)) {
+			return_PTR(entry);
+		}
+	}
+
+	return_PTR(NULL);
+}
+
+
+static int
+acpi_pci_irq_add_entry (
+	acpi_handle			handle,
+	int				segment,
+	int				bus,
+	struct acpi_pci_routing_table	*prt)
+{
+	struct acpi_prt_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_irq_add_entry");
+
+	if (!prt)
+		return_VALUE(-EINVAL);
+
+	entry = kmalloc(sizeof(struct acpi_prt_entry), GFP_KERNEL);
+	if (!entry)
+		return_VALUE(-ENOMEM);
+	memset(entry, 0, sizeof(struct acpi_prt_entry));
+
+	entry->id.segment = segment;
+	entry->id.bus = bus;
+	entry->id.device = (prt->address >> 16) & 0xFFFF;
+	entry->id.function = prt->address & 0xFFFF;
+	entry->pin = prt->pin;
+
+	/*
+	 * Type 1: Dynamic
+	 * ---------------
+	 * The 'source' field specifies the PCI interrupt link device used to
+	 * configure the IRQ assigned to this slot|dev|pin.  The 'source_index'
+	 * indicates which resource descriptor in the resource template (of
+	 * the link device) this interrupt is allocated from.
+	 * 
+	 * NOTE: Don't query the Link Device for IRQ information at this time
+	 *       because Link Device enumeration may not have occurred yet
+	 *       (e.g. exists somewhere 'below' this _PRT entry in the ACPI
+	 *       namespace).
+	 */
+	if (prt->source[0]) {
+		acpi_get_handle(handle, prt->source, &entry->link.handle);
+		entry->link.index = prt->source_index;
+	}
+	/*
+	 * Type 2: Static
+	 * --------------
+	 * The 'source' field is NULL, and the 'source_index' field specifies
+	 * the IRQ value, which is hardwired to specific interrupt inputs on
+	 * the interrupt controller.
+	 */
+	else
+		entry->link.index = prt->source_index;
+
+	ACPI_DEBUG_PRINT_RAW((ACPI_DB_INFO,
+		"      %02X:%02X:%02X[%c] -> %s[%d]\n", 
+		entry->id.segment, entry->id.bus, entry->id.device, 
+		('A' + entry->pin), prt->source, entry->link.index));
+
+	/* TBD: Acquire/release lock */
+	list_add_tail(&entry->node, &acpi_prt.entries);
+	acpi_prt.count++;
+
+	return_VALUE(0);
+}
+
+
+int
+acpi_pci_irq_add_prt (
+	acpi_handle		handle,
+	int			segment,
+	int			bus)
+{
+	acpi_status			status = AE_OK;
+	char				pathname[ACPI_PATHNAME_MAX] = {0};
+	struct acpi_buffer		buffer = {0, NULL};
+	struct acpi_pci_routing_table	*prt = NULL;
+	struct acpi_pci_routing_table	*entry = NULL;
+	static int			first_time = 1;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_irq_add_prt");
+
+	if (first_time) {
+		acpi_prt.count = 0;
+		INIT_LIST_HEAD(&acpi_prt.entries);
+		first_time = 0;
+	}
+
+	/* 
+	 * NOTE: We're given a 'handle' to the _PRT object's parent device
+	 *       (either a PCI root bridge or PCI-PCI bridge).
+	 */
+
+	buffer.length = sizeof(pathname);
+	buffer.pointer = pathname;
+	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
+
+	printk(KERN_DEBUG "ACPI: PCI Interrupt Routing Table [%s._PRT]\n",
+		pathname);
+
+	/* 
+	 * Evaluate this _PRT and add its entries to our global list (acpi_prt).
+	 */
+
+	buffer.length = 0;
+	buffer.pointer = NULL;
+	status = acpi_get_irq_routing_table(handle, &buffer);
+	if (status != AE_BUFFER_OVERFLOW) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PRT [%s]\n",
+			acpi_format_exception(status)));
+		return_VALUE(-ENODEV);
+	}
+
+	prt = kmalloc(buffer.length, GFP_KERNEL);
+	if (!prt)
+		return_VALUE(-ENOMEM);
+	memset(prt, 0, buffer.length);
+	buffer.pointer = prt;
+
+	status = acpi_get_irq_routing_table(handle, &buffer);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PRT [%s]\n",
+			acpi_format_exception(status)));
+		kfree(buffer.pointer);
+		return_VALUE(-ENODEV);
+	}
+
+	entry = prt;
+
+	while (entry && (entry->length > 0)) {
+		acpi_pci_irq_add_entry(handle, segment, bus, entry);
+		entry = (struct acpi_pci_routing_table *)
+			((unsigned long) entry + entry->length);
+	}
+
+	kfree(prt);
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                          PCI Interrupt Routing Support
+   -------------------------------------------------------------------------- */
+
+int
+acpi_pci_irq_lookup (
+	int			segment,
+	int			bus,
+	int			device,
+	int			pin)
+{
+	struct acpi_prt_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_irq_lookup");
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+		"Searching for PRT entry for %02x:%02x:%02x[%c]\n", 
+		segment, bus, device, ('A' + pin)));
+
+	entry = acpi_pci_irq_find_prt_entry(segment, bus, device, pin); 
+	if (!entry) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "PRT entry not found\n"));
+		return_VALUE(0);
+	}
+
+	if (!entry->irq && entry->link.handle) {
+		entry->irq = acpi_pci_link_get_irq(entry->link.handle, entry->link.index, NULL, NULL);
+		if (!entry->irq) {
+			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid IRQ link routing entry\n"));
+			return_VALUE(0);
+		}
+	}
+	else if (!entry->irq) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Invalid static routing entry (IRQ 0)\n"));
+		return_VALUE(0);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found IRQ %d\n", entry->irq));
+
+	return_VALUE(entry->irq);
+}
+
+
+static int
+acpi_pci_irq_derive (
+	struct pci_dev		*dev,
+	int			pin)
+{
+	struct pci_dev		*bridge = dev;
+	int			irq = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_irq_derive");
+
+	if (!dev)
+		return_VALUE(-EINVAL);
+
+	/* 
+	 * Attempt to derive an IRQ for this device from a parent bridge's
+	 * PCI interrupt routing entry (a.k.a. the "bridge swizzle").
+	 */
+	while (!irq && bridge->bus->self) {
+		pin = (pin + PCI_SLOT(bridge->devfn)) % 4;
+		bridge = bridge->bus->self;
+		irq = acpi_pci_irq_lookup(0, bridge->bus->number, PCI_SLOT(bridge->devfn), pin);
+	}
+
+	if (!irq) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Unable to derive IRQ for device %s\n", dev->slot_name));
+		return_VALUE(0);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Derived IRQ %d\n", irq));
+
+	return_VALUE(irq);
+}
+
+
+int
+acpi_pci_irq_enable (
+	struct pci_dev		*dev)
+{
+	int			irq = 0;
+	u8			pin = 0;
+	static u16		irq_mask = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_irq_enable");
+
+	if (!dev)
+		return_VALUE(-EINVAL);
+	
+	pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
+	if (!pin) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No interrupt pin configured for device %s\n", dev->slot_name));
+		return_VALUE(0);
+	}
+	pin--;
+
+	if (!dev->bus) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid (NULL) 'bus' field\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	/* 
+	 * First we check the PCI IRQ routing table (PRT) for an IRQ.  PRT
+	 * values override any BIOS-assigned IRQs set during boot.
+	 */
+ 	irq = acpi_pci_irq_lookup(0, dev->bus->number, PCI_SLOT(dev->devfn), pin);
+ 
+	/*
+	 * If no PRT entry was found, we'll try to derive an IRQ from the
+	 * device's parent bridge.
+	 */
+	if (!irq)
+ 		irq = acpi_pci_irq_derive(dev, pin);
+ 
+	/*
+	 * No IRQ known to the ACPI subsystem - maybe the BIOS / 
+	 * driver reported one, then use it. Exit in any case.
+	 */
+	if (!irq) {
+		printk(KERN_WARNING PREFIX "No IRQ known for interrupt pin %c of device %s", ('A' + pin), dev->slot_name);
+		/* Interrupt Line values above 0xF are forbidden */
+		if (dev->irq && dev->irq >= 0xF) {
+			printk(" - using IRQ %d\n", dev->irq);
+			return_VALUE(dev->irq);
+		}
+		else {
+			printk("\n");
+			return_VALUE(0);
+		}
+ 	}
+
+	dev->irq = irq;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device %s using IRQ %d\n", dev->slot_name, dev->irq));
+
+	/* 
+	 * Make sure all (legacy) PCI IRQs are set as level-triggered.
+	 */
+#ifdef CONFIG_X86
+	if ((dev->irq < 16) &&  !((1 << dev->irq) & irq_mask)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Setting IRQ %d as level-triggered\n", dev->irq));
+		irq_mask |= (1 << dev->irq);
+		eisa_set_level_irq(dev->irq);
+	}
+#endif
+
+	return_VALUE(dev->irq);
+}
+
+
+int __init
+acpi_pci_irq_init (void)
+{
+	struct pci_dev          *dev = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_irq_init");
+
+	if (!acpi_prt.count) {
+		printk(KERN_WARNING PREFIX "ACPI tables contain no PCI IRQ "
+			"routing entries\n");
+		return_VALUE(-ENODEV);
+	}
+
+	/* Make sure all link devices have a valid IRQ. */
+	acpi_pci_link_check();
+
+#ifdef CONFIG_X86_IO_APIC
+	/* Program IOAPICs using data from PRT entries. */
+	if (acpi_irq_model == ACPI_IRQ_MODEL_IOAPIC)
+		mp_parse_prt();
+#endif
+#ifdef CONFIG_IOSAPIC
+	if (acpi_irq_model == ACPI_IRQ_MODEL_IOSAPIC)
+		iosapic_parse_prt();
+#endif
+
+	pci_for_each_dev(dev)
+		acpi_pci_irq_enable(dev);
+
+	return_VALUE(0);
+}
diff -urNp linux-5400/drivers/acpi/pci_link.c linux-5410/drivers/acpi/pci_link.c
--- linux-5400/drivers/acpi/pci_link.c
+++ linux-5410/drivers/acpi/pci_link.c
@@ -0,0 +1,647 @@
+/*
+ *  pci_link.c - ACPI PCI Interrupt Link Device Driver ($Revision: 35 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *  Copyright (C) 2002       Dominik Brodowski <devel@brodo.de>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * TBD: 
+ *      1. Support more than one IRQ resource entry per link device (index).
+ *	2. Implement start/stop mechanism and use ACPI Bus Driver facilities
+ *	   for IRQ management (e.g. start()->_SRS).
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/pm.h>
+#include <linux/pci.h>
+
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+
+#define _COMPONENT		ACPI_PCI_COMPONENT
+ACPI_MODULE_NAME		("pci_link")
+
+#define PREFIX			"ACPI: "
+
+
+#define ACPI_PCI_LINK_MAX_POSSIBLE 16
+
+static int acpi_pci_link_add (struct acpi_device *device);
+static int acpi_pci_link_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_pci_link_driver = {
+	.name =		ACPI_PCI_LINK_DRIVER_NAME,
+	.class =	ACPI_PCI_LINK_CLASS,
+	.ids =		ACPI_PCI_LINK_HID,
+	.ops =		{
+				.add =    acpi_pci_link_add,
+				.remove = acpi_pci_link_remove,
+			},
+};
+
+struct acpi_pci_link_irq {
+	u8			active;			/* Current IRQ */
+	u8			edge_level;
+	u8			active_high_low;
+	u8			setonboot;
+	u8			possible_count;
+	u8			possible[ACPI_PCI_LINK_MAX_POSSIBLE];
+};
+
+struct acpi_pci_link {
+	struct list_head	node;
+	struct acpi_device	*device;
+	acpi_handle		handle;
+	struct acpi_pci_link_irq irq;
+};
+
+static struct {
+	int			count;
+	struct list_head	entries;
+}				acpi_link;
+
+
+/* --------------------------------------------------------------------------
+                            PCI Link Device Management
+   -------------------------------------------------------------------------- */
+
+static acpi_status
+acpi_pci_link_check_possible (
+	struct acpi_resource	*resource,
+	void			*context)
+{
+	struct acpi_pci_link	*link = (struct acpi_pci_link *) context;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_check_possible");
+
+	switch (resource->id) {
+	case ACPI_RSTYPE_START_DPF:
+		return AE_OK;
+	case ACPI_RSTYPE_IRQ:
+	{
+		struct acpi_resource_irq *p = &resource->data.irq;
+		if (!p || !p->number_of_interrupts) {
+			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Blank IRQ resource\n"));
+			return AE_OK;
+		}
+		for (i = 0; (i<p->number_of_interrupts && i<ACPI_PCI_LINK_MAX_POSSIBLE); i++) {
+			if (!p->interrupts[i]) {
+				ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid IRQ %d\n", p->interrupts[i]));
+				continue;
+			}
+			link->irq.possible[i] = p->interrupts[i];
+			link->irq.possible_count++;
+		}
+		link->irq.edge_level = p->edge_level;
+		link->irq.active_high_low = p->active_high_low;
+		break;
+	}
+	case ACPI_RSTYPE_EXT_IRQ:
+	{
+		struct acpi_resource_ext_irq *p = &resource->data.extended_irq;
+		if (!p || !p->number_of_interrupts) {
+			ACPI_DEBUG_PRINT((ACPI_DB_WARN, 
+				"Blank IRQ resource\n"));
+			return AE_OK;
+		}
+		for (i = 0; (i<p->number_of_interrupts && i<ACPI_PCI_LINK_MAX_POSSIBLE); i++) {
+			if (!p->interrupts[i]) {
+				ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid IRQ %d\n", p->interrupts[i]));
+				continue;
+			}
+			link->irq.possible[i] = p->interrupts[i];
+			link->irq.possible_count++;
+		}
+		link->irq.edge_level = p->edge_level;
+		link->irq.active_high_low = p->active_high_low;
+		break;
+	}
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Resource is not an IRQ entry\n"));
+		return AE_OK;
+	}
+
+	return AE_CTRL_TERMINATE;
+}
+
+
+static int
+acpi_pci_link_get_possible (
+	struct acpi_pci_link	*link)
+{
+	acpi_status		status;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_get_possible");
+
+	if (!link)
+		return_VALUE(-EINVAL);
+
+	status = acpi_walk_resources(link->handle, METHOD_NAME__PRS,
+			acpi_pci_link_check_possible, link);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PRS\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+		"Found %d possible IRQs\n", link->irq.possible_count));
+
+	return_VALUE(0);
+}
+
+
+static acpi_status
+acpi_pci_link_check_current (
+	struct acpi_resource	*resource,
+	void			*context)
+{
+	int			*irq = (int *) context;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_check_current");
+
+	switch (resource->id) {
+	case ACPI_RSTYPE_IRQ:
+	{
+		struct acpi_resource_irq *p = &resource->data.irq;
+		if (!p || !p->number_of_interrupts) {
+			ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+				"Blank IRQ resource\n"));
+			return AE_OK;
+		}
+		*irq = p->interrupts[0];
+		break;
+	}
+	case ACPI_RSTYPE_EXT_IRQ:
+	{
+		struct acpi_resource_ext_irq *p = &resource->data.extended_irq;
+		if (!p || !p->number_of_interrupts) {
+			ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+				"Blank IRQ resource\n"));
+			return AE_OK;
+		}
+		*irq = p->interrupts[0];
+		break;
+	}
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Resource isn't an IRQ\n"));
+		return AE_OK;
+	}
+	return AE_CTRL_TERMINATE;
+}
+
+
+static int
+acpi_pci_link_get_current (
+	struct acpi_pci_link	*link)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	int			irq = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_get_current");
+
+	if (!link || !link->handle)
+		return_VALUE(-EINVAL);
+
+	link->irq.active = 0;
+
+	/* Make sure the link is enabled (no use querying if it isn't). */
+	result = acpi_bus_get_status(link->device);
+	if (result) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unable to read status\n"));
+		goto end;
+	}
+	if (!link->device->status.enabled) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Link disabled\n"));
+		return_VALUE(0);
+	}
+
+	/* 
+	 * Query and parse _CRS to get the current IRQ assignment. 
+	 */
+
+	status = acpi_walk_resources(link->handle, METHOD_NAME__CRS,
+			acpi_pci_link_check_current, &irq);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _CRS\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	if (!irq) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "No IRQ resource found\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	/*
+	 * Note that we don't validate that the current IRQ (_CRS) exists
+	 * within the possible IRQs (_PRS): we blindly assume that whatever
+	 * IRQ a boot-enabled Link device is set to is the correct one.
+	 * (Required to support systems such as the Toshiba 5005-S504.)
+	 */
+
+	link->irq.active = irq;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Link at IRQ %d \n", link->irq.active));
+
+end:
+	return_VALUE(result);
+}
+
+
+static int
+acpi_pci_link_set (
+	struct acpi_pci_link	*link,
+	int			irq)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct {
+		struct acpi_resource	res;
+		struct acpi_resource	end;
+	}                       resource;
+	struct acpi_buffer	buffer = {sizeof(resource)+1, &resource};
+	int			i = 0;
+	int			valid = 0;
+	int			resource_type = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_set");
+
+	if (!link || !irq)
+		return_VALUE(-EINVAL);
+
+	/* We don't check irqs the first time around */
+	if (link->irq.setonboot) {
+		/* See if we're already at the target IRQ. */
+		if (irq == link->irq.active)
+			return_VALUE(0);
+
+		/* Make sure the target IRQ in the list of possible IRQs. */
+		for (i=0; i<link->irq.possible_count; i++) {
+			if (irq == link->irq.possible[i])
+				valid = 1;
+		}
+		if (!valid) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Target IRQ %d invalid\n", irq));
+			return_VALUE(-EINVAL);
+		}
+	}
+
+	/* If IRQ <= 15, first try with a "normal" IRQ descriptor.  If that
+	 * fails, try with an extended one
+	 */
+
+	if (irq <= 15) {
+		resource_type = ACPI_RSTYPE_IRQ;
+	}
+	else {
+		resource_type = ACPI_RSTYPE_EXT_IRQ;
+	}
+
+retry_programming:
+
+	memset(&resource, 0, sizeof(resource));
+
+	/* NOTE: PCI interrupts are always level / active_low / shared. 
+	 * But not all interrupts > 15 are PCI interrupts.  Rely on the
+	 * APCI IRQ definition for parameters
+	 */
+	switch(resource_type) {
+	case ACPI_RSTYPE_IRQ:
+		resource.res.id = ACPI_RSTYPE_IRQ;
+		resource.res.length = sizeof(struct acpi_resource);
+		resource.res.data.irq.edge_level = link->irq.edge_level;
+		resource.res.data.irq.active_high_low = link->irq.active_high_low;
+		resource.res.data.irq.shared_exclusive = ACPI_SHARED;
+		resource.res.data.irq.number_of_interrupts = 1;
+		resource.res.data.irq.interrupts[0] = irq;
+		break;
+	
+	case ACPI_RSTYPE_EXT_IRQ:
+		resource.res.id = ACPI_RSTYPE_EXT_IRQ;
+		resource.res.length = sizeof(struct acpi_resource);
+		resource.res.data.extended_irq.producer_consumer = ACPI_CONSUMER;
+		resource.res.data.extended_irq.edge_level = link->irq.edge_level;
+		resource.res.data.extended_irq.active_high_low = link->irq.active_high_low;
+		resource.res.data.extended_irq.shared_exclusive = ACPI_SHARED;
+		resource.res.data.extended_irq.number_of_interrupts = 1;
+		resource.res.data.extended_irq.interrupts[0] = irq;
+		/* ignore resource_source, it's optional */
+		break;
+	}
+	resource.end.id = ACPI_RSTYPE_END_TAG;
+
+	status = acpi_set_current_resources(link->handle, &buffer);
+
+	/* if we failed and IRQ <= 15, try again with an extended descriptor */
+	if (ACPI_FAILURE(status) && (resource_type == ACPI_RSTYPE_IRQ)) {
+		resource_type = ACPI_RSTYPE_EXT_IRQ;
+		printk(PREFIX "Retrying with extended IRQ descriptor\n");
+		goto retry_programming;
+	}
+
+	/* check for total failure */
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _SRS\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	/* Make sure the device is enabled. */
+	result = acpi_bus_get_status(link->device);
+	if (result) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unable to read status\n"));
+		return_VALUE(result);
+	}
+	if (!link->device->status.enabled) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Link disabled\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	/* Make sure the active IRQ is the one we requested. */
+	result = acpi_pci_link_get_current(link);
+	if (result) {
+		return_VALUE(result);
+	}
+	if (link->irq.active != irq) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Attempt to enable at IRQ %d resulted in IRQ %d\n", 
+			irq, link->irq.active));
+		link->irq.active = 0;
+		acpi_ut_evaluate_object (link->handle, "_DIS", 0, NULL);
+		return_VALUE(-ENODEV);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Set IRQ %d\n", link->irq.active));
+	
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                            PCI Link IRQ Management
+   -------------------------------------------------------------------------- */
+
+#define ACPI_MAX_IRQS		256
+#define ACPI_MAX_ISA_IRQ	16
+
+/*
+ * IRQ penalties are used to promote PCI IRQ balancing.  We set each ISA-
+ * possible IRQ (0-15) with a default penalty relative to its feasibility
+ * for PCI's use:
+ *
+ *   Never use:		0, 1, 2 (timer, keyboard, and cascade)
+ *   Avoid using:	13, 14, and 15 (FP error and IDE)
+ *   Penalize:		3, 4, 6, 7, 12 (known ISA uses)
+ *
+ * Thus we're left with IRQs 5, 9, 10, 11, and everything above 15 (IO[S]APIC)
+ * as 'best bets' for PCI use.
+ */
+
+static int acpi_irq_penalty[ACPI_MAX_IRQS] = {
+	1000000,  1000000,  1000000,    10000, 
+	  10000,        0,    10000,    10000,
+	  10000,        0,        0,        0, 
+	  10000,   100000,   100000,   100000,
+};
+
+
+int
+acpi_pci_link_check (void)
+{
+	struct list_head	*node = NULL;
+	struct acpi_pci_link    *link = NULL;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_check");
+
+	/*
+	 * Pass #1: Update penalties to facilitate IRQ balancing.
+	 */
+	list_for_each(node, &acpi_link.entries) {
+
+		link = list_entry(node, struct acpi_pci_link, node);
+		if (!link) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link context\n"));
+			continue;
+		}
+
+		if (link->irq.active)
+			acpi_irq_penalty[link->irq.active] += 100;
+		else if (link->irq.possible_count) {
+			int penalty = 100 / link->irq.possible_count;
+			for (i=0; i<link->irq.possible_count; i++) {
+				if (link->irq.possible[i] < ACPI_MAX_ISA_IRQ)
+					acpi_irq_penalty[link->irq.possible[i]] += penalty;
+			}
+		}
+	}
+
+	/*
+	 * Pass #2: Enable boot-disabled Links at 'best' IRQ.
+	 */
+	list_for_each(node, &acpi_link.entries) {
+		int		irq = 0;
+		int		i = 0;
+
+		link = list_entry(node, struct acpi_pci_link, node);
+		if (!link || !link->irq.possible_count) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link context\n"));
+			continue;
+		}
+
+		if (link->irq.active)
+			continue;
+
+		irq = link->irq.possible[0];
+
+		/* 
+		 * Select the best IRQ.  This is done in reverse to promote 
+		 * the use of IRQs 9, 10, 11, and >15.
+		 */
+		for (i=(link->irq.possible_count-1); i>0; i--) {
+			if (acpi_irq_penalty[irq] > acpi_irq_penalty[link->irq.possible[i]])
+				irq = link->irq.possible[i];
+		}
+
+		/* Enable the link device at this IRQ. */
+		acpi_pci_link_set(link, irq);
+
+		acpi_irq_penalty[link->irq.active] += 100;
+
+		printk(PREFIX "%s [%s] enabled at IRQ %d\n", 
+			acpi_device_name(link->device),
+			acpi_device_bid(link->device), link->irq.active);
+	}
+
+	return_VALUE(0);
+}
+
+
+int
+acpi_pci_link_get_irq (
+	acpi_handle		handle,
+	int			index,
+	int*			edge_level,
+	int*			active_high_low)
+{
+	int                     result = 0;
+	struct acpi_device	*device = NULL;
+	struct acpi_pci_link	*link = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_get_irq");
+
+	result = acpi_bus_get_device(handle, &device);
+	if (result) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link device\n"));
+		return_VALUE(0);
+	}
+
+	link = (struct acpi_pci_link *) acpi_driver_data(device);
+	if (!link) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link context\n"));
+		return_VALUE(0);
+	}
+
+	/* TBD: Support multiple index (IRQ) entries per Link Device */
+	if (index) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid index %d\n", index));
+		return_VALUE(0);
+	}
+
+	if (!link->irq.active) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Link disabled\n"));
+		return_VALUE(0);
+	}
+
+	if(edge_level) *edge_level = link->irq.edge_level;
+	if(active_high_low) *active_high_low = link->irq.active_high_low;
+	return_VALUE(link->irq.active);
+}
+
+
+/* --------------------------------------------------------------------------
+                                 Driver Interface
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_pci_link_add (
+	struct acpi_device *device)
+{
+	int			result = 0;
+	struct acpi_pci_link	*link = NULL;
+	int			i = 0;
+	int			found = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	link = kmalloc(sizeof(struct acpi_pci_link), GFP_KERNEL);
+	if (!link)
+		return_VALUE(-ENOMEM);
+	memset(link, 0, sizeof(struct acpi_pci_link));
+
+	link->device = device;
+	link->handle = device->handle;
+	sprintf(acpi_device_name(device), "%s", ACPI_PCI_LINK_DEVICE_NAME);
+	sprintf(acpi_device_class(device), "%s", ACPI_PCI_LINK_CLASS);
+	acpi_driver_data(device) = link;
+
+	result = acpi_pci_link_get_possible(link);
+	if (result)
+		goto end;
+
+	acpi_pci_link_get_current(link);
+
+	printk(PREFIX "%s [%s] (IRQs", acpi_device_name(device), acpi_device_bid(device));
+	for (i = 0; i < link->irq.possible_count; i++) {
+		if (link->irq.active == link->irq.possible[i]) {
+			printk(" *%d", link->irq.possible[i]);
+			found = 1;
+		}
+		else
+			printk(" %d", link->irq.possible[i]);
+	}
+	if (!link->irq.active)
+		printk(", disabled");
+	else if (!found)
+		printk(", enabled at IRQ %d", link->irq.active);
+	printk(")\n");
+
+	/* TBD: Acquire/release lock */
+	list_add_tail(&link->node, &acpi_link.entries);
+	acpi_link.count++;
+
+end:
+	if (result)
+		kfree(link);
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_pci_link_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	struct acpi_pci_link *link = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	link = (struct acpi_pci_link *) acpi_driver_data(device);
+
+	/* TBD: Acquire/release lock */
+	list_del(&link->node);
+
+	kfree(link);
+
+	return_VALUE(0);
+}
+
+
+int __init
+acpi_pci_link_init (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_pci_link_init");
+
+	acpi_link.count = 0;
+	INIT_LIST_HEAD(&acpi_link.entries);
+
+	if (acpi_bus_register_driver(&acpi_pci_link_driver) < 0)
+		return_VALUE(-ENODEV);
+
+	return_VALUE(0);
+}
diff -urNp linux-5400/drivers/acpi/pci_root.c linux-5410/drivers/acpi/pci_root.c
--- linux-5400/drivers/acpi/pci_root.c
+++ linux-5410/drivers/acpi/pci_root.c
@@ -0,0 +1,396 @@
+/*
+ *  pci_root.c - ACPI PCI Root Bridge Driver ($Revision: 41 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/pm.h>
+#include <linux/pci.h>
+#include <linux/acpi.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+
+#define _COMPONENT		ACPI_PCI_COMPONENT
+ACPI_MODULE_NAME		("pci_root")
+
+extern struct pci_ops *pci_root_ops;
+
+#define PREFIX			"ACPI: "
+
+static int acpi_pci_root_add (struct acpi_device *device);
+static int acpi_pci_root_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_pci_root_driver = {
+	.name =		ACPI_PCI_ROOT_DRIVER_NAME,
+	.class =	ACPI_PCI_ROOT_CLASS,
+	.ids =		ACPI_PCI_ROOT_HID,
+	.ops =		{
+				.add =    acpi_pci_root_add,
+				.remove = acpi_pci_root_remove,
+			},
+};
+
+struct acpi_pci_root {
+	struct list_head	node;
+	acpi_handle		handle;
+	struct acpi_pci_id	id;
+	struct pci_bus		*bus;
+	u64			mem_tra;
+	u64			io_tra;
+};
+
+struct list_head		acpi_pci_roots;
+
+static struct acpi_pci_driver *sub_driver;
+
+int acpi_pci_register_driver(struct acpi_pci_driver *driver)
+{
+	int n = 0;
+	struct list_head *entry;
+
+	struct acpi_pci_driver **pptr = &sub_driver;
+	while (*pptr)
+		pptr = &(*pptr)->next;
+	*pptr = driver;
+
+	if (!driver->add)
+		return 0;
+
+	list_for_each(entry, &acpi_pci_roots) {
+		struct acpi_pci_root *root;
+		root = list_entry(entry, struct acpi_pci_root, node);
+		driver->add(root->handle);
+		n++;
+	}
+
+	return n;
+}
+
+void acpi_pci_unregister_driver(struct acpi_pci_driver *driver)
+{
+	struct list_head *entry;
+
+	struct acpi_pci_driver **pptr = &sub_driver;
+	while (*pptr) {
+		if (*pptr != driver)
+			continue;
+		*pptr = (*pptr)->next;
+		break;
+	}
+
+	if (!driver->remove)
+		return;
+
+	list_for_each(entry, &acpi_pci_roots) {
+		struct acpi_pci_root *root;
+		root = list_entry(entry, struct acpi_pci_root, node);
+		driver->remove(root->handle);
+	}
+}
+
+void
+acpi_pci_get_translations (
+	struct acpi_pci_id	*id,
+	u64			*mem_tra,
+	u64			*io_tra)
+{
+	struct list_head	*node = NULL;
+	struct acpi_pci_root	*entry;
+
+	/* TBD: Locking */
+	list_for_each(node, &acpi_pci_roots) {
+		entry = list_entry(node, struct acpi_pci_root, node);
+		if ((id->segment == entry->id.segment)
+			&& (id->bus == entry->id.bus)) {
+			*mem_tra = entry->mem_tra;
+			*io_tra = entry->io_tra;
+			return;
+		}
+	}
+
+	*mem_tra = 0;
+	*io_tra = 0;
+}
+
+
+static u64
+acpi_pci_root_bus_tra (
+       struct acpi_resource	*resource,
+       int			type)
+{
+	struct acpi_resource_address16 *address16;
+	struct acpi_resource_address32 *address32;
+	struct acpi_resource_address64 *address64;
+
+	while (1) {
+		switch (resource->id) {
+		case ACPI_RSTYPE_END_TAG:
+			return 0;
+
+		case ACPI_RSTYPE_ADDRESS16:
+			address16 = (struct acpi_resource_address16 *) &resource->data;
+			if (type == address16->resource_type) {
+				return address16->address_translation_offset;
+			}
+			break;
+
+		case ACPI_RSTYPE_ADDRESS32:
+			address32 = (struct acpi_resource_address32 *) &resource->data;
+			if (type == address32->resource_type) {
+				return address32->address_translation_offset;
+			}
+			break;
+
+		case ACPI_RSTYPE_ADDRESS64:
+			address64 = (struct acpi_resource_address64 *) &resource->data;
+			if (type == address64->resource_type) {
+				return address64->address_translation_offset;
+			}
+			break;
+		}
+		resource = ACPI_PTR_ADD (struct acpi_resource,
+				resource, resource->length);
+	}
+
+	return 0;
+}
+
+
+static int
+acpi_pci_evaluate_crs (
+	struct acpi_pci_root	*root)
+{
+	acpi_status		status;
+	struct acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+
+	ACPI_FUNCTION_TRACE("acpi_pci_evaluate_crs");
+
+	status = acpi_get_current_resources (root->handle, &buffer);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	root->io_tra = acpi_pci_root_bus_tra ((struct acpi_resource *)
+			buffer.pointer, ACPI_IO_RANGE);
+	root->mem_tra = acpi_pci_root_bus_tra ((struct acpi_resource *)
+			buffer.pointer, ACPI_MEMORY_RANGE);
+
+	acpi_os_free(buffer.pointer);
+	return_VALUE(0);
+}
+
+
+static int
+acpi_pci_root_add (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	struct acpi_pci_root	*root = NULL;
+	acpi_status		status = AE_OK;
+	unsigned long		value = 0;
+	acpi_handle		handle = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_root_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	root = kmalloc(sizeof(struct acpi_pci_root), GFP_KERNEL);
+	if (!root)
+		return_VALUE(-ENOMEM);
+	memset(root, 0, sizeof(struct acpi_pci_root));
+
+	root->handle = device->handle;
+	sprintf(acpi_device_name(device), "%s", ACPI_PCI_ROOT_DEVICE_NAME);
+	sprintf(acpi_device_class(device), "%s", ACPI_PCI_ROOT_CLASS);
+	acpi_driver_data(device) = root;
+
+	/*
+	 * TBD: Doesn't the bus driver automatically set this?
+	 */
+	device->ops.bind = acpi_pci_bind;
+
+	/* 
+	 * Segment
+	 * -------
+	 * Obtained via _SEG, if exists, otherwise assumed to be zero (0).
+	 */
+	status = acpi_evaluate_integer(root->handle, METHOD_NAME__SEG, NULL, 
+		&value);
+	switch (status) {
+	case AE_OK:
+		root->id.segment = (u16) value;
+		printk("_SEG exists! Unsupported. Abort.\n");
+		break;
+	case AE_NOT_FOUND:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"Assuming segment 0 (no _SEG)\n"));
+		root->id.segment = 0;
+		break;
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _SEG\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	/* 
+	 * Bus
+	 * ---
+	 * Obtained via _BBN, if exists, otherwise assumed to be zero (0).
+	 */
+	status = acpi_evaluate_integer(root->handle, METHOD_NAME__BBN, NULL, 
+		&value);
+	switch (status) {
+	case AE_OK:
+		root->id.bus = (u16) value;
+		break;
+	case AE_NOT_FOUND:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Assuming bus 0 (no _BBN)\n"));
+		root->id.bus = 0;
+		break;
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _BBN\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	/*
+	 * Device & Function
+	 * -----------------
+	 * Obtained from _ADR (which has already been evaluated for us).
+	 */
+	root->id.device = device->pnp.bus_address >> 16;
+	root->id.function = device->pnp.bus_address & 0xFFFF;
+
+	/*
+	 * Evaluate _CRS to get root bridge resources
+	 * TBD: Need PCI interface for enumeration/configuration of roots.
+	 */
+ 	acpi_pci_evaluate_crs(root);
+
+ 	/* TBD: Locking */
+ 	list_add_tail(&root->node, &acpi_pci_roots);
+
+	printk(KERN_INFO PREFIX "%s [%s] (%02x:%02x)\n", 
+		acpi_device_name(device), acpi_device_bid(device),
+		root->id.segment, root->id.bus);
+
+	/*
+	 * Scan the Root Bridge
+	 * --------------------
+	 * Must do this prior to any attempt to bind the root device, as the
+	 * PCI namespace does not get created until this call is made (and 
+	 * thus the root bridge's pci_dev does not exist).
+	 */
+	root->bus = pcibios_scan_root(root->handle, root->id.segment, root->id.bus);
+	if (!root->bus) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Bus %02x:%02x not present in PCI namespace\n", 
+			root->id.segment, root->id.bus));
+		result = -ENODEV;
+		goto end;
+	}
+
+	/*
+	 * Attach ACPI-PCI Context
+	 * -----------------------
+	 * Thus binding the ACPI and PCI devices.
+	 */
+	result = acpi_pci_bind_root(device, &root->id, root->bus);
+	if (result)
+		goto end;
+
+	/*
+	 * PCI Routing Table
+	 * -----------------
+	 * Evaluate and parse _PRT, if exists.
+	 */
+	status = acpi_get_handle(root->handle, METHOD_NAME__PRT, &handle);
+	if (ACPI_SUCCESS(status))
+		result = acpi_pci_irq_add_prt(root->handle, root->id.segment,
+			root->id.bus);
+
+end:
+	if (result) {
+		if (root->node.next && !list_empty(&root->node))
+			list_del(&root->node);
+		kfree(root);
+	}
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_pci_root_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	struct acpi_pci_root	*root = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_root_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	root = (struct acpi_pci_root *) acpi_driver_data(device);
+
+	kfree(root);
+
+	return_VALUE(0);
+}
+
+
+int __init
+acpi_pci_root_init (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_pci_root_init");
+
+	/* DEBUG:
+	acpi_dbg_layer = ACPI_PCI_COMPONENT;
+	acpi_dbg_level = 0xFFFFFFFF;
+	 */
+
+ 	INIT_LIST_HEAD(&acpi_pci_roots);
+
+	if (acpi_bus_register_driver(&acpi_pci_root_driver) < 0)
+		return_VALUE(-ENODEV);
+
+	return_VALUE(0);
+}
+
+
+void __exit
+acpi_pci_root_exit (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_pci_root_exit");
+
+	acpi_bus_unregister_driver(&acpi_pci_root_driver);
+
+	return_VOID;
+}
diff -urNp linux-5400/drivers/acpi/power.c linux-5410/drivers/acpi/power.c
--- linux-5400/drivers/acpi/power.c
+++ linux-5410/drivers/acpi/power.c
@@ -0,0 +1,604 @@
+/*
+ *  acpi_power.c - ACPI Bus Power Management ($Revision: 38 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/compatmac.h>
+#include <linux/proc_fs.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+
+#define _COMPONENT		ACPI_POWER_COMPONENT
+ACPI_MODULE_NAME		("acpi_power")
+
+#define PREFIX			"ACPI: "
+
+
+int acpi_power_add (struct acpi_device *device);
+int acpi_power_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_power_driver = {
+	.name =		ACPI_POWER_DRIVER_NAME,
+	.class =	ACPI_POWER_CLASS,
+	.ids =		ACPI_POWER_HID,
+	.ops =		{
+				.add =		acpi_power_add,
+				.remove =	acpi_power_remove,
+			},
+};
+
+struct acpi_power_resource
+{
+	acpi_handle		handle;
+	acpi_bus_id		name;
+	u32			system_level;
+	u32			order;
+	int			state;
+	int			references;
+};
+
+static struct list_head		acpi_power_resource_list;
+
+
+/* --------------------------------------------------------------------------
+                             Power Resource Management
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_power_get_context (
+	acpi_handle		handle,
+	struct acpi_power_resource **resource)
+{
+	int			result = 0;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_power_get_context");
+
+	if (!resource)
+		return_VALUE(-ENODEV);
+
+	result = acpi_bus_get_device(handle, &device);
+	if (result) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Error getting context [%p]\n",
+			handle));
+		return_VALUE(result);
+	}
+
+	*resource = (struct acpi_power_resource *) acpi_driver_data(device);
+	if (!resource)
+		return_VALUE(-ENODEV);
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_power_get_state (
+	struct acpi_power_resource *resource)
+{
+	acpi_status		status = AE_OK;
+	unsigned long		sta = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_power_get_state");
+
+	if (!resource)
+		return_VALUE(-EINVAL);
+
+	status = acpi_evaluate_integer(resource->handle, "_STA", NULL, &sta);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	if (sta & 0x01)
+		resource->state = ACPI_POWER_RESOURCE_STATE_ON;
+	else
+		resource->state = ACPI_POWER_RESOURCE_STATE_OFF;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] is %s\n",
+		resource->name, resource->state?"on":"off"));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_power_get_list_state (
+	struct acpi_handle_list	*list,
+	int			*state)
+{
+	int			result = 0;
+	struct acpi_power_resource *resource = NULL;
+	u32			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_power_get_list_state");
+
+	if (!list || !state)
+		return_VALUE(-EINVAL);
+
+	/* The state of the list is 'on' IFF all resources are 'on'. */
+
+	for (i=0; i<list->count; i++) {
+		result = acpi_power_get_context(list->handles[i], &resource);
+		if (result)
+			return_VALUE(result);
+		result = acpi_power_get_state(resource);
+		if (result)
+			return_VALUE(result);
+
+		*state = resource->state;
+
+		if (*state != ACPI_POWER_RESOURCE_STATE_ON)
+			break;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource list is %s\n",
+		*state?"on":"off"));
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_power_on (
+	acpi_handle		handle)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_device	*device = NULL;
+	struct acpi_power_resource *resource = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_power_on");
+
+	result = acpi_power_get_context(handle, &resource);
+	if (result)
+		return_VALUE(result);
+
+	resource->references++;
+
+	if ((resource->references > 1) 
+		|| (resource->state == ACPI_POWER_RESOURCE_STATE_ON)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] already on\n",
+			resource->name));
+		return_VALUE(0);
+	}
+
+	status = acpi_evaluate_object(resource->handle, "_ON", NULL, NULL);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	result = acpi_power_get_state(resource);
+	if (result)
+		return_VALUE(result);
+	if (resource->state != ACPI_POWER_RESOURCE_STATE_ON)
+		return_VALUE(-ENOEXEC);
+
+	/* Update the power resource's _device_ power state */
+	result = acpi_bus_get_device(resource->handle, &device);
+	if (result)
+		return_VALUE(result);
+	device->power.state = ACPI_STATE_D0;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] turned on\n",
+		resource->name));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_power_off_device (
+	acpi_handle		handle)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_device	*device = NULL;
+	struct acpi_power_resource *resource = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_power_off_device");
+
+	result = acpi_power_get_context(handle, &resource);
+	if (result)
+		return_VALUE(result);
+
+	if (resource->references)
+		resource->references--;
+
+	if (resource->references) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"Resource [%s] is still in use, dereferencing\n",
+			device->pnp.bus_id));
+		return_VALUE(0);
+	}
+
+	if (resource->state == ACPI_POWER_RESOURCE_STATE_OFF) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] already off\n",
+			device->pnp.bus_id));
+		return_VALUE(0);
+	}
+
+	status = acpi_evaluate_object(resource->handle, "_OFF", NULL, NULL);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	result = acpi_power_get_state(resource);
+	if (result)
+		return_VALUE(result);
+	if (resource->state != ACPI_POWER_RESOURCE_STATE_OFF)
+		return_VALUE(-ENOEXEC);
+
+	/* Update the power resource's _device_ power state */
+	result = acpi_bus_get_device(resource->handle, &device);
+	if (result)
+		return_VALUE(result);
+	device->power.state = ACPI_STATE_D3;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] turned off\n",
+		resource->name));
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                             Device Power Management
+   -------------------------------------------------------------------------- */
+
+int
+acpi_power_get_inferred_state (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	struct acpi_handle_list	*list = NULL;
+	int			list_state = 0;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_power_get_inferred_state");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	device->power.state = ACPI_STATE_UNKNOWN;
+
+	/*
+	 * We know a device's inferred power state when all the resources
+	 * required for a given D-state are 'on'.
+	 */
+	for (i=ACPI_STATE_D0; i<ACPI_STATE_D3; i++) {
+		list = &device->power.states[i].resources;
+		if (list->count < 1)
+			continue;
+
+		result = acpi_power_get_list_state(list, &list_state);
+		if (result)
+			return_VALUE(result);
+
+		if (list_state == ACPI_POWER_RESOURCE_STATE_ON) {
+			device->power.state = i;
+			return_VALUE(0);
+		}
+	}
+
+	device->power.state = ACPI_STATE_D3;
+
+	return_VALUE(0);
+}
+
+
+int
+acpi_power_transition (
+	struct acpi_device	*device,
+	int			state)
+{
+	int			result = 0;
+	struct acpi_handle_list	*cl = NULL;	/* Current Resources */
+	struct acpi_handle_list	*tl = NULL;	/* Target Resources */
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_power_transition");
+
+	if (!device || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3))
+		return_VALUE(-EINVAL);
+
+	cl = &device->power.states[device->power.state].resources;
+	tl = &device->power.states[state].resources;
+
+	device->power.state = ACPI_STATE_UNKNOWN;
+
+	if (!cl->count && !tl->count) {
+		result = -ENODEV;
+		goto end;
+	}
+
+	/* TBD: Resources must be ordered. */
+
+	/*
+	 * First we reference all power resources required in the target list
+	 * (e.g. so the device doesn't loose power while transitioning).
+	 */
+	for (i=0; i<tl->count; i++) {
+		result = acpi_power_on(tl->handles[i]);
+		if (result)
+			goto end;
+	}
+
+	device->power.state = state;
+
+	/*
+	 * Then we dereference all power resources used in the current list.
+	 */
+	for (i=0; i<cl->count; i++) {
+		result = acpi_power_off_device(cl->handles[i]);
+		if (result)
+			goto end;
+	}
+
+end:
+	if (result)
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, 
+			"Error transitioning device [%s] to D%d\n",
+			device->pnp.bus_id, state));
+
+	return_VALUE(result);
+}
+
+
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+struct proc_dir_entry		*acpi_power_dir = NULL;
+
+
+static int
+acpi_power_read_status (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_power_resource *resource = NULL;
+	char			*p = page;
+	int			len;
+
+	ACPI_FUNCTION_TRACE("acpi_power_read_status");
+
+	if (!data || (off != 0))
+		goto end;
+
+	resource = (struct acpi_power_resource *) data;
+
+	p += sprintf(p, "state:                   ");
+	switch (resource->state) {
+	case ACPI_POWER_RESOURCE_STATE_ON:
+		p += sprintf(p, "on\n");
+		break;
+	case ACPI_POWER_RESOURCE_STATE_OFF:
+		p += sprintf(p, "off\n");
+		break;
+	default:
+		p += sprintf(p, "unknown\n");
+		break;
+	}
+
+	p += sprintf(p, "system level:            S%d\n",
+		resource->system_level);
+	p += sprintf(p, "order:                   %d\n",
+		resource->order);
+	p += sprintf(p, "reference count:         %d\n",
+		resource->references);
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_power_add_fs (
+	struct acpi_device	*device)
+{
+	struct proc_dir_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_power_add_fs");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	if (!acpi_device_dir(device)) {
+		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
+			acpi_power_dir);
+		if (!acpi_device_dir(device))
+			return_VALUE(-ENODEV);
+	}
+
+	/* 'status' [R] */
+	entry = create_proc_entry(ACPI_POWER_FILE_STATUS,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_POWER_FILE_STATUS));
+	else {
+		entry->read_proc = acpi_power_read_status;
+		entry->data = acpi_driver_data(device);
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_power_remove_fs (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_power_remove_fs");
+
+	if (acpi_device_dir(device)) {
+		remove_proc_entry(acpi_device_bid(device), acpi_power_dir);
+		acpi_device_dir(device) = NULL;
+	}
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                Driver Interface
+   -------------------------------------------------------------------------- */
+
+int
+acpi_power_add (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_power_resource *resource = NULL;
+	union acpi_object	acpi_object;
+	struct acpi_buffer	buffer = {sizeof(acpi_object), &acpi_object};
+
+	ACPI_FUNCTION_TRACE("acpi_power_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	resource = kmalloc(sizeof(struct acpi_power_resource), GFP_KERNEL);
+	if (!resource)
+		return_VALUE(-ENOMEM);
+	memset(resource, 0, sizeof(struct acpi_power_resource));
+
+	resource->handle = device->handle;
+	sprintf(resource->name, "%s", device->pnp.bus_id);
+	sprintf(acpi_device_name(device), "%s", ACPI_POWER_DEVICE_NAME);
+	sprintf(acpi_device_class(device), "%s", ACPI_POWER_CLASS);
+	acpi_driver_data(device) = resource;
+
+	/* Evalute the object to get the system level and resource order. */
+	status = acpi_evaluate_object(resource->handle, NULL, NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		result = -ENODEV;
+		goto end;
+	}
+	resource->system_level = acpi_object.power_resource.system_level;
+	resource->order = acpi_object.power_resource.resource_order;
+
+	result = acpi_power_get_state(resource);
+	if (result)
+		goto end;
+
+	switch (resource->state) {
+	case ACPI_POWER_RESOURCE_STATE_ON:
+		device->power.state = ACPI_STATE_D0;
+		break;
+	case ACPI_POWER_RESOURCE_STATE_OFF:
+		device->power.state = ACPI_STATE_D3;
+		break;
+	default:
+		device->power.state = ACPI_STATE_UNKNOWN;
+		break;
+	}
+
+	result = acpi_power_add_fs(device);
+	if (result)
+		goto end;
+	
+	printk(KERN_INFO PREFIX "%s [%s] (%s)\n", acpi_device_name(device),
+		acpi_device_bid(device), resource->state?"on":"off");
+
+end:
+	if (result)
+		kfree(resource);
+	
+	return_VALUE(result);
+}
+
+
+int
+acpi_power_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	struct acpi_power_resource *resource = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_power_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	resource = (struct acpi_power_resource *) acpi_driver_data(device);
+
+	acpi_power_remove_fs(device);
+
+	kfree(resource);
+
+	return_VALUE(0);
+}
+
+
+int __init
+acpi_power_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_power_init");
+
+	INIT_LIST_HEAD(&acpi_power_resource_list);
+
+	acpi_power_dir = proc_mkdir(ACPI_POWER_CLASS, acpi_root_dir);
+	if (!acpi_power_dir)
+		return_VALUE(-ENODEV);
+
+	result = acpi_bus_register_driver(&acpi_power_driver);
+	if (result < 0) {
+		remove_proc_entry(ACPI_POWER_CLASS, acpi_root_dir);
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+
+
+void __exit
+acpi_power_exit (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_power_exit");
+
+	/* TBD: Empty acpi_power_resource_list */
+
+	acpi_bus_unregister_driver(&acpi_power_driver);
+
+	remove_proc_entry(ACPI_POWER_CLASS, acpi_root_dir);
+
+	return_VOID;
+}
diff -urNp linux-5400/drivers/acpi/processor.c linux-5410/drivers/acpi/processor.c
--- linux-5400/drivers/acpi/processor.c
+++ linux-5410/drivers/acpi/processor.c
@@ -0,0 +1,2329 @@
+/*
+ * acpi_processor.c - ACPI Processor Driver ($Revision: 69 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *  TBD:
+ *	1. Make # power/performance states dynamic.
+ *	2. Support duty_cycle values that span bit 4.
+ *	3. Optimize by having scheduler determine business instead of
+ *	   having us try to calculate it here.
+ *	4. Need C1 timing -- must modify kernel (IRQ handler) to get this.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/pm.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/delay.h>
+#include <linux/compatmac.h>
+#include <linux/proc_fs.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+
+#define _COMPONENT		ACPI_PROCESSOR_COMPONENT
+ACPI_MODULE_NAME		("acpi_processor")
+
+MODULE_AUTHOR("Paul Diefenbaugh");
+MODULE_DESCRIPTION(ACPI_PROCESSOR_DRIVER_NAME);
+MODULE_LICENSE("GPL");
+
+#define PREFIX				"ACPI: "
+
+#define US_TO_PM_TIMER_TICKS(t)		((t * (PM_TIMER_FREQUENCY/1000)) / 1000)
+#define C2_OVERHEAD			4	/* 1us (3.579 ticks per us) */
+#define C3_OVERHEAD			4	/* 1us (3.579 ticks per us) */
+
+#define ACPI_PROCESSOR_BUSY_METRIC	10
+
+#define ACPI_PROCESSOR_MAX_POWER	ACPI_C_STATE_COUNT
+#define ACPI_PROCESSOR_MAX_C2_LATENCY	100
+#define ACPI_PROCESSOR_MAX_C3_LATENCY	1000
+
+#define ACPI_PROCESSOR_MAX_PERFORMANCE	8
+
+#define ACPI_PROCESSOR_MAX_THROTTLING	16
+#define ACPI_PROCESSOR_MAX_THROTTLE	250	/* 25% */
+#define ACPI_PROCESSOR_MAX_DUTY_WIDTH	4
+
+const u32 POWER_OF_2[] = {1,2,4,8,16,32,64};
+
+#define ACPI_PROCESSOR_LIMIT_USER	0
+#define ACPI_PROCESSOR_LIMIT_THERMAL	1
+
+static int acpi_processor_add (struct acpi_device *device);
+static int acpi_processor_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_processor_driver = {
+	.name =		ACPI_PROCESSOR_DRIVER_NAME,
+	.class =	ACPI_PROCESSOR_CLASS,
+	.ids =		ACPI_PROCESSOR_HID,
+	.ops =		{
+				.add =		acpi_processor_add,
+				.remove =	acpi_processor_remove,
+			},
+};
+
+/* Power Management */
+
+struct acpi_processor_cx_policy {
+	u32			count;
+	int			state;
+	struct {
+		u32			time;
+		u32			ticks;
+		u32			count;
+		u32			bm;
+	}			threshold;
+};
+
+struct acpi_processor_cx {
+	u8			valid;
+	u32			address;
+	u32			latency;
+	u32			latency_ticks;
+	u32			power;
+	u32			usage;
+	struct acpi_processor_cx_policy promotion;
+	struct acpi_processor_cx_policy demotion;
+};
+
+struct acpi_processor_power {
+	int			state;
+	int			default_state;
+	u32			bm_activity;
+	struct acpi_processor_cx states[ACPI_PROCESSOR_MAX_POWER];
+};
+
+/* Performance Management */
+
+struct acpi_pct_register {
+	u8			descriptor;
+	u16			length;
+	u8			space_id;
+	u8			bit_width;
+	u8			bit_offset;
+	u8			reserved;
+	u64			address;
+} __attribute__ ((packed));
+
+struct acpi_processor_px {
+	acpi_integer		core_frequency;		/* megahertz */
+	acpi_integer		power;			/* milliWatts */
+	acpi_integer		transition_latency;	/* microseconds */
+	acpi_integer		bus_master_latency;	/* microseconds */
+	acpi_integer		control;		/* control value */
+	acpi_integer		status;			/* success indicator */
+};
+
+struct acpi_processor_performance {
+	int			state;
+	int			platform_limit;
+	u16			control_register;
+	u16			status_register;
+	int			state_count;
+	struct acpi_processor_px states[ACPI_PROCESSOR_MAX_PERFORMANCE];
+};
+
+
+/* Throttling Control */
+
+struct acpi_processor_tx {
+	u16			power;
+	u16			performance;
+};
+
+struct acpi_processor_throttling {
+	int			state;
+	u32			address;
+	u8			duty_offset;
+	u8			duty_width;
+	int			state_count;
+	struct acpi_processor_tx states[ACPI_PROCESSOR_MAX_THROTTLING];
+};
+
+/* Limit Interface */
+
+struct acpi_processor_lx {
+	int			px;		/* performace state */	
+	int			tx;		/* throttle level */
+};
+
+struct acpi_processor_limit {
+	struct acpi_processor_lx state;		/* current limit */
+	struct acpi_processor_lx thermal;	/* thermal limit */
+	struct acpi_processor_lx user;		/* user limit */
+};
+
+
+struct acpi_processor_flags {
+	u8			power:1;
+	u8			performance:1;
+	u8			throttling:1;
+	u8			limit:1;
+	u8			bm_control:1;
+	u8			bm_check:1;
+	u8			reserved:2;
+};
+
+struct acpi_processor {
+	acpi_handle		handle;
+	u32			acpi_id;
+	u32			id;
+	struct acpi_processor_flags flags;
+	struct acpi_processor_power power;
+	struct acpi_processor_performance performance;
+	struct acpi_processor_throttling throttling;
+	struct acpi_processor_limit limit;
+};
+
+struct acpi_processor_errata {
+	u8			smp;
+	struct {
+		u8			throttle:1;
+		u8			fdma:1;
+		u8			reserved:6;
+		u32			bmisx;
+	}			piix4;
+};
+
+static struct acpi_processor	*processors[NR_CPUS];
+static struct acpi_processor_errata errata;
+static void (*pm_idle_save)(void) = NULL;
+
+
+/* --------------------------------------------------------------------------
+                                Errata Handling
+   -------------------------------------------------------------------------- */
+
+int
+acpi_processor_errata_piix4 (
+	struct pci_dev		*dev)
+{
+	u8			rev = 0;
+	u8			value1 = 0;
+	u8			value2 = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_errata_piix4");
+
+	if (!dev)
+		return_VALUE(-EINVAL);
+
+	/*
+	 * Note that 'dev' references the PIIX4 ACPI Controller.
+	 */
+
+	pci_read_config_byte(dev, PCI_REVISION_ID, &rev);
+
+	switch (rev) {
+	case 0:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4 A-step\n"));
+		break;
+	case 1:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4 B-step\n"));
+		break;
+	case 2:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4E\n"));
+		break;
+	case 3:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4M\n"));
+		break;
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found unknown PIIX4\n"));
+		break;
+	}
+
+	switch (rev) {
+
+	case 0:		/* PIIX4 A-step */
+	case 1:		/* PIIX4 B-step */
+		/*
+		 * See specification changes #13 ("Manual Throttle Duty Cycle")
+		 * and #14 ("Enabling and Disabling Manual Throttle"), plus
+		 * erratum #5 ("STPCLK# Deassertion Time") from the January 
+		 * 2002 PIIX4 specification update.  Applies to only older 
+		 * PIIX4 models.
+		 */
+		errata.piix4.throttle = 1;
+
+	case 2:		/* PIIX4E */
+	case 3:		/* PIIX4M */
+		/*
+		 * See erratum #18 ("C3 Power State/BMIDE and Type-F DMA 
+		 * Livelock") from the January 2002 PIIX4 specification update.
+		 * Applies to all PIIX4 models.
+		 */
+
+		/* 
+		 * BM-IDE
+		 * ------
+		 * Find the PIIX4 IDE Controller and get the Bus Master IDE 
+		 * Status register address.  We'll use this later to read 
+		 * each IDE controller's DMA status to make sure we catch all
+		 * DMA activity.
+		 */
+		dev = pci_find_subsys(PCI_VENDOR_ID_INTEL,
+		           PCI_DEVICE_ID_INTEL_82371AB, 
+                           PCI_ANY_ID, PCI_ANY_ID, NULL);
+		if (dev)
+			errata.piix4.bmisx = pci_resource_start(dev, 4);
+
+		/* 
+		 * Type-F DMA
+		 * ----------
+		 * Find the PIIX4 ISA Controller and read the Motherboard
+		 * DMA controller's status to see if Type-F (Fast) DMA mode
+		 * is enabled (bit 7) on either channel.  Note that we'll 
+		 * disable C3 support if this is enabled, as some legacy 
+		 * devices won't operate well if fast DMA is disabled.
+		 */
+		dev = pci_find_subsys(PCI_VENDOR_ID_INTEL, 
+			PCI_DEVICE_ID_INTEL_82371AB_0, 
+			PCI_ANY_ID, PCI_ANY_ID, NULL);
+		if (dev) {
+			pci_read_config_byte(dev, 0x76, &value1);
+			pci_read_config_byte(dev, 0x77, &value2);
+			if ((value1 & 0x80) || (value2 & 0x80))
+				errata.piix4.fdma = 1;
+		}
+
+		break;
+	}
+
+	if (errata.piix4.bmisx)
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"Bus master activity detection (BM-IDE) erratum enabled\n"));
+	if (errata.piix4.fdma)
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"Type-F DMA livelock erratum (C3 disabled)\n"));
+
+	return_VALUE(0);
+}
+
+
+int
+acpi_processor_errata (
+	struct acpi_processor	*pr)
+{
+	int			result = 0;
+	struct pci_dev		*dev = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_errata");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	/*
+	 * PIIX4
+	 */
+	dev = pci_find_subsys(PCI_VENDOR_ID_INTEL, 
+		PCI_DEVICE_ID_INTEL_82371AB_3, PCI_ANY_ID, PCI_ANY_ID, NULL);
+	if (dev)
+		result = acpi_processor_errata_piix4(dev);
+
+	return_VALUE(result);
+}
+
+
+/* --------------------------------------------------------------------------
+                                Power Management
+   -------------------------------------------------------------------------- */
+
+static inline u32
+ticks_elapsed (
+	u32			t1,
+	u32			t2)
+{
+	if (t2 >= t1)
+		return (t2 - t1);
+	else if (!acpi_fadt.tmr_val_ext)
+		return (((0x00FFFFFF - t1) + t2) & 0x00FFFFFF);
+	else
+		return ((0xFFFFFFFF - t1) + t2);
+}
+
+
+static void
+acpi_processor_power_activate (
+	struct acpi_processor	*pr,
+	int			state)
+{
+	if (!pr)
+		return;
+
+	pr->power.states[pr->power.state].promotion.count = 0;
+	pr->power.states[pr->power.state].demotion.count = 0;
+
+	/* Cleanup from old state. */
+	switch (pr->power.state) {
+	case ACPI_STATE_C3:
+		/* Disable bus master reload */
+		acpi_set_register(ACPI_BITREG_BUS_MASTER_RLD, 0, ACPI_MTX_DO_NOT_LOCK);
+		break;
+	}
+
+	/* Prepare to use new state. */
+	switch (state) {
+	case ACPI_STATE_C3:
+		/* Enable bus master reload */
+		acpi_set_register(ACPI_BITREG_BUS_MASTER_RLD, 1, ACPI_MTX_DO_NOT_LOCK);
+		break;
+	}
+
+	pr->power.state = state;
+
+	return;
+}
+
+
+static void
+acpi_processor_idle (void)
+{
+	struct acpi_processor	*pr = NULL;
+	struct acpi_processor_cx *cx = NULL;
+	int			next_state = 0;
+	int			sleep_ticks = 0;
+	u32			t1, t2 = 0;
+
+	pr = processors[smp_processor_id()];
+	if (!pr)
+		return;
+
+	/*
+	 * Interrupts must be disabled during bus mastering calculations and
+	 * for C2/C3 transitions.
+	 */
+	__cli();
+
+	cx = &(pr->power.states[pr->power.state]);
+
+	/*
+	 * Check BM Activity
+	 * -----------------
+	 * Check for bus mastering activity (if required), record, and check
+	 * for demotion.
+	 */
+	if (pr->flags.bm_check) {
+		u32		bm_status = 0;
+
+		pr->power.bm_activity <<= 1;
+
+		acpi_get_register(ACPI_BITREG_BUS_MASTER_STATUS, 
+			&bm_status, ACPI_MTX_DO_NOT_LOCK);
+		if (bm_status) {
+			pr->power.bm_activity++;
+			acpi_set_register(ACPI_BITREG_BUS_MASTER_STATUS,
+				1, ACPI_MTX_DO_NOT_LOCK);
+		}
+		/*
+		 * PIIX4 Erratum #18: Note that BM_STS doesn't always reflect
+		 * the true state of bus mastering activity; forcing us to 
+		 * manually check the BMIDEA bit of each IDE channel.
+		 */
+		else if (errata.piix4.bmisx) {
+			if ((inb_p(errata.piix4.bmisx + 0x02) & 0x01) 
+				|| (inb_p(errata.piix4.bmisx + 0x0A) & 0x01))
+				pr->power.bm_activity++;
+		}
+		/*
+		 * Apply bus mastering demotion policy.  Automatically demote
+		 * to avoid a faulty transition.  Note that the processor 
+		 * won't enter a low-power state during this call (to this 
+		 * funciton) but should upon the next.
+		 *
+		 * TBD: A better policy might be to fallback to the demotion 
+		 *      state (use it for this quantum only) istead of 
+		 *      demoting -- and rely on duration as our sole demotion
+		 *      qualification.  This may, however, introduce DMA 
+		 *      issues (e.g. floppy DMA transfer overrun/underrun).
+		 */
+		if (pr->power.bm_activity & cx->demotion.threshold.bm) {
+			__sti();
+			next_state = cx->demotion.state;
+			goto end;
+		}
+	}
+
+	cx->usage++;
+
+	/*
+	 * Sleep:
+	 * ------
+	 * Invoke the current Cx state to put the processor to sleep.
+	 */
+	switch (pr->power.state) {
+
+	case ACPI_STATE_C1:
+		/* Invoke C1. */
+		safe_halt();
+		/*
+                 * TBD: Can't get time duration while in C1, as resumes
+		 *      go to an ISR rather than here.  Need to instrument
+		 *      base interrupt handler.
+		 */
+		sleep_ticks = 0xFFFFFFFF;
+		break;
+
+	case ACPI_STATE_C2:
+		/* Get start time (ticks) */
+		t1 = inl(acpi_fadt.xpm_tmr_blk.address);
+		/* Invoke C2 */
+		inb(pr->power.states[ACPI_STATE_C2].address);
+		/* Dummy op - must do something useless after P_LVL2 read */
+		t2 = inl(acpi_fadt.xpm_tmr_blk.address);
+		/* Get end time (ticks) */
+		t2 = inl(acpi_fadt.xpm_tmr_blk.address);
+		/* Re-enable interrupts */
+		__sti();
+		/* Compute time (ticks) that we were actually asleep */
+		sleep_ticks = ticks_elapsed(t1, t2) - cx->latency_ticks - C2_OVERHEAD;
+		break;
+
+	case ACPI_STATE_C3:
+		/* Disable bus master arbitration */
+		acpi_set_register(ACPI_BITREG_ARB_DISABLE, 1, ACPI_MTX_DO_NOT_LOCK);
+		/* Get start time (ticks) */
+		t1 = inl(acpi_fadt.xpm_tmr_blk.address);
+		/* Invoke C3 */
+		inb(pr->power.states[ACPI_STATE_C3].address);
+		/* Dummy op - must do something useless after P_LVL3 read */
+		t2 = inl(acpi_fadt.xpm_tmr_blk.address);
+		/* Get end time (ticks) */
+		t2 = inl(acpi_fadt.xpm_tmr_blk.address);
+		/* Enable bus master arbitration */
+		acpi_set_register(ACPI_BITREG_ARB_DISABLE, 0, ACPI_MTX_DO_NOT_LOCK);
+		/* Re-enable interrupts */
+		__sti();
+		/* Compute time (ticks) that we were actually asleep */
+		sleep_ticks = ticks_elapsed(t1, t2) - cx->latency_ticks - C3_OVERHEAD;
+		break;
+
+	default:
+		__sti();
+		return;
+	}
+
+	next_state = pr->power.state;
+
+	/*
+	 * Promotion?
+	 * ----------
+	 * Track the number of longs (time asleep is greater than threshold)
+	 * and promote when the count threshold is reached.  Note that bus
+	 * mastering activity may prevent promotions.
+	 */
+	if (cx->promotion.state) {
+		if (sleep_ticks > cx->promotion.threshold.ticks) {
+			cx->promotion.count++;
+ 			cx->demotion.count = 0;
+			if (cx->promotion.count >= cx->promotion.threshold.count) {
+				if (pr->flags.bm_check) {
+					if (!(pr->power.bm_activity & cx->promotion.threshold.bm)) {
+						next_state = cx->promotion.state;
+						goto end;
+					}
+				}
+				else {
+					next_state = cx->promotion.state;
+					goto end;
+				}
+			}
+		}
+	}
+
+	/*
+	 * Demotion?
+	 * ---------
+	 * Track the number of shorts (time asleep is less than time threshold)
+	 * and demote when the usage threshold is reached.
+	 */
+	if (cx->demotion.state) {
+		if (sleep_ticks < cx->demotion.threshold.ticks) {
+			cx->demotion.count++;
+			cx->promotion.count = 0;
+			if (cx->demotion.count >= cx->demotion.threshold.count) {
+				next_state = cx->demotion.state;
+				goto end;
+			}
+		}
+	}
+
+end:
+	/*
+	 * New Cx State?
+	 * -------------
+	 * If we're going to start using a new Cx state we must clean up
+	 * from the previous and prepare to use the new.
+	 */
+	if (next_state != pr->power.state)
+		acpi_processor_power_activate(pr, next_state);
+
+	return;
+}
+
+
+static int
+acpi_processor_set_power_policy (
+	struct acpi_processor	*pr)
+{
+	ACPI_FUNCTION_TRACE("acpi_processor_set_power_policy");
+
+	/*
+	 * This function sets the default Cx state policy (OS idle handler).
+	 * Our scheme is to promote quickly to C2 but more conservatively
+	 * to C3.  We're favoring C2  for its characteristics of low latency
+	 * (quick response), good power savings, and ability to allow bus
+	 * mastering activity.  Note that the Cx state policy is completely
+	 * customizable and can be altered dynamically.
+	 */
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	/*
+	 * C0/C1
+	 * -----
+	 */
+	pr->power.state = ACPI_STATE_C1;
+	pr->power.default_state = ACPI_STATE_C1;
+
+	/*
+	 * C1/C2
+	 * -----
+	 * Set the default C1 promotion and C2 demotion policies, where we
+	 * promote from C1 to C2 after several (10) successive C1 transitions,
+	 * as we cannot (currently) measure the time spent in C1. Demote from
+	 * C2 to C1 anytime we experience a 'short' (time spent in C2 is less
+	 * than the C2 transtion latency).  Note the simplifying assumption 
+	 * that the 'cost' of a transition is amortized when we sleep for at
+	 * least as long as the transition's latency (thus the total transition
+	 * time is two times the latency).
+	 *
+	 * TBD: Measure C1 sleep times by instrumenting the core IRQ handler.
+	 * TBD: Demote to default C-State after long periods of activity.
+	 * TBD: Investigate policy's use of CPU utilization -vs- sleep duration.
+	 */
+	if (pr->power.states[ACPI_STATE_C2].valid) {
+		pr->power.states[ACPI_STATE_C1].promotion.threshold.count = 10;
+		pr->power.states[ACPI_STATE_C1].promotion.threshold.ticks =
+			pr->power.states[ACPI_STATE_C2].latency_ticks;
+		pr->power.states[ACPI_STATE_C1].promotion.state = ACPI_STATE_C2;
+
+		pr->power.states[ACPI_STATE_C2].demotion.threshold.count = 1;
+		pr->power.states[ACPI_STATE_C2].demotion.threshold.ticks =
+			pr->power.states[ACPI_STATE_C2].latency_ticks;
+		pr->power.states[ACPI_STATE_C2].demotion.state = ACPI_STATE_C1;
+	}
+
+	/*
+	 * C2/C3
+	 * -----
+	 * Set default C2 promotion and C3 demotion policies, where we promote
+	 * from C2 to C3 after several (4) cycles of no bus mastering activity
+	 * while maintaining sleep time criteria.  Demote immediately on a
+	 * short or whenever bus mastering activity occurs.
+	 */
+	if ((pr->power.states[ACPI_STATE_C2].valid) &&
+		(pr->power.states[ACPI_STATE_C3].valid)) {
+		pr->power.states[ACPI_STATE_C2].promotion.threshold.count = 4;
+		pr->power.states[ACPI_STATE_C2].promotion.threshold.ticks =
+			pr->power.states[ACPI_STATE_C3].latency_ticks;
+		pr->power.states[ACPI_STATE_C2].promotion.threshold.bm = 0x0F;
+		pr->power.states[ACPI_STATE_C2].promotion.state = ACPI_STATE_C3;
+
+		pr->power.states[ACPI_STATE_C3].demotion.threshold.count = 1;
+		pr->power.states[ACPI_STATE_C3].demotion.threshold.ticks =
+			pr->power.states[ACPI_STATE_C3].latency_ticks;
+		pr->power.states[ACPI_STATE_C3].demotion.threshold.bm = 0x0F;
+		pr->power.states[ACPI_STATE_C3].demotion.state = ACPI_STATE_C2;
+	}
+
+	return_VALUE(0);
+}
+
+
+int
+acpi_processor_get_power_info (
+	struct acpi_processor	*pr)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_power_info");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+		"lvl2[0x%08x] lvl3[0x%08x]\n",
+		pr->power.states[ACPI_STATE_C2].address,
+		pr->power.states[ACPI_STATE_C3].address));
+
+	/* TBD: Support ACPI 2.0 objects */
+
+	/*
+	 * C0
+	 * --
+	 * This state exists only as filler in our array.
+	 */
+	pr->power.states[ACPI_STATE_C0].valid = 1;
+
+	/*
+	 * C1
+	 * --
+	 * ACPI requires C1 support for all processors.
+	 *
+	 * TBD: What about PROC_C1?
+	 */
+	pr->power.states[ACPI_STATE_C1].valid = 1;
+
+	/*
+	 * C2
+	 * --
+	 * We're (currently) only supporting C2 on UP systems.
+	 *
+	 * TBD: Support for C2 on MP (P_LVL2_UP).
+	 */
+	if (pr->power.states[ACPI_STATE_C2].address) {
+
+		pr->power.states[ACPI_STATE_C2].latency = acpi_fadt.plvl2_lat;
+
+		/*
+		 * C2 latency must be less than or equal to 100 microseconds.
+		 */
+		if (acpi_fadt.plvl2_lat > ACPI_PROCESSOR_MAX_C2_LATENCY)
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				"C2 latency too large [%d]\n",
+				acpi_fadt.plvl2_lat));
+		/*
+		 * Only support C2 on UP systems (see TBD above).
+		 */
+		else if (errata.smp)
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				"C2 not supported in SMP mode\n"));
+		/*
+		 * Otherwise we've met all of our C2 requirements.
+		 * Normalize the C2 latency to expidite policy.
+		 */
+		else {
+			pr->power.states[ACPI_STATE_C2].valid = 1;
+			pr->power.states[ACPI_STATE_C2].latency_ticks = 
+				US_TO_PM_TIMER_TICKS(acpi_fadt.plvl2_lat);
+		}
+	}
+
+	/*
+	 * C3
+	 * --
+	 * TBD: Investigate use of WBINVD on UP/SMP system in absence of
+	 *	bm_control.
+	 */
+	if (pr->power.states[ACPI_STATE_C3].address) {
+
+		pr->power.states[ACPI_STATE_C3].latency = acpi_fadt.plvl3_lat;
+
+		/*
+		 * C3 latency must be less than or equal to 1000 microseconds.
+		 */
+		if (acpi_fadt.plvl3_lat > ACPI_PROCESSOR_MAX_C3_LATENCY)
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				"C3 latency too large [%d]\n", 
+				acpi_fadt.plvl3_lat));
+		/*
+		 * Only support C3 when bus mastering arbitration control
+		 * is present (able to disable bus mastering to maintain
+		 * cache coherency while in C3).
+		 */
+		else if (!pr->flags.bm_control)
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				"C3 support requires bus mastering control\n"));
+		/*
+		 * Only support C3 on UP systems, as bm_control is only viable
+		 * on a UP system and flushing caches (e.g. WBINVD) is simply 
+		 * too costly (at this time).
+		 */
+		else if (errata.smp)
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				"C3 not supported in SMP mode\n"));
+		/*
+		 * PIIX4 Erratum #18: We don't support C3 when Type-F (fast) 
+		 * DMA transfers are used by any ISA device to avoid livelock.
+		 * Note that we could disable Type-F DMA (as recommended by
+		 * the erratum), but this is known to disrupt certain ISA 
+		 * devices thus we take the conservative approach.
+		 */
+		else if (errata.piix4.fdma) {
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				"C3 not supported on PIIX4 with Type-F DMA\n"));
+		}
+		/*
+		 * Otherwise we've met all of our C3 requirements.  
+		 * Normalize the C2 latency to expidite policy.  Enable
+		 * checking of bus mastering status (bm_check) so we can 
+		 * use this in our C3 policy.
+		 */
+		else {
+			pr->power.states[ACPI_STATE_C3].valid = 1;
+			pr->power.states[ACPI_STATE_C3].latency_ticks = 
+				US_TO_PM_TIMER_TICKS(acpi_fadt.plvl3_lat);
+			pr->flags.bm_check = 1;
+		}
+	}
+
+	/*
+	 * Set Default Policy
+	 * ------------------
+	 * Now that we know which state are supported, set the default
+	 * policy.  Note that this policy can be changed dynamically
+	 * (e.g. encourage deeper sleeps to conserve battery life when
+	 * not on AC).
+	 */
+	result = acpi_processor_set_power_policy(pr);
+	if (result)
+		return_VALUE(result);
+
+	/*
+	 * If this processor supports C2 or C3 we denote it as being 'power
+	 * manageable'.  Note that there's really no policy involved for
+	 * when only C1 is supported.
+	 */
+	if (pr->power.states[ACPI_STATE_C2].valid 
+		|| pr->power.states[ACPI_STATE_C3].valid)
+		pr->flags.power = 1;
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                              Performance Management
+   -------------------------------------------------------------------------- */
+
+static int 
+acpi_processor_get_platform_limit (
+	struct acpi_processor*	pr)
+{
+	acpi_status		status = 0;
+	unsigned long		ppc = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_platform_limit");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	/*
+	 * _PPC indicates the maximum state currently supported by the platform
+	 * (e.g. 0 = states 0..n; 1 = states 1..n; etc.
+	 */
+	status = acpi_evaluate_integer(pr->handle, "_PPC", NULL, &ppc);
+	if(ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PPC\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	pr->performance.platform_limit = (int) ppc;
+
+	return_VALUE(0);
+}
+
+
+static int 
+acpi_processor_get_performance_control (
+	struct acpi_processor	*pr)
+{
+	int			result = 0;
+	acpi_status		status = 0;
+	struct acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	union acpi_object	*pct = NULL;
+	union acpi_object	obj = {0};
+	struct acpi_pct_register *reg = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_performance_control");
+
+	status = acpi_evaluate_object(pr->handle, "_PCT", NULL, &buffer);
+	if(ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PCT\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	pct = (union acpi_object *) buffer.pointer;
+	if (!pct || (pct->type != ACPI_TYPE_PACKAGE) 
+		|| (pct->package.count != 2)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _PCT data\n"));
+		result = -EFAULT;
+		goto end;
+	}
+
+	/*
+	 * control_register
+	 */
+
+	obj = pct->package.elements[0];
+
+	if ((obj.type != ACPI_TYPE_BUFFER) 
+		|| (obj.buffer.length < sizeof(struct acpi_pct_register)) 
+		|| (obj.buffer.pointer == NULL)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Invalid _PCT data (control_register)\n"));
+		result = -EFAULT;
+		goto end;
+	}
+
+	reg = (struct acpi_pct_register *) (obj.buffer.pointer);
+
+	if (reg->space_id != ACPI_ADR_SPACE_SYSTEM_IO) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unsupported address space [%d] (control_register)\n",
+			(u32) reg->space_id));
+		result = -EFAULT;
+		goto end;
+	}
+
+	pr->performance.control_register = (u16) reg->address;
+
+	/*
+	 * status_register
+	 */
+
+	obj = pct->package.elements[1];
+
+	if ((obj.type != ACPI_TYPE_BUFFER) 
+		|| (obj.buffer.length < sizeof(struct acpi_pct_register)) 
+		|| (obj.buffer.pointer == NULL)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Invalid _PCT data (status_register)\n"));
+		result = -EFAULT;
+		goto end;
+	}
+
+	reg = (struct acpi_pct_register *) (obj.buffer.pointer);
+
+	if (reg->space_id != ACPI_ADR_SPACE_SYSTEM_IO) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unsupported address space [%d] (status_register)\n",
+			(u32) reg->space_id));
+		result = -EFAULT;
+		goto end;
+	}
+
+	pr->performance.status_register = (u16) reg->address;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+		"control_register[0x%04x] status_register[0x%04x]\n",
+		pr->performance.control_register,
+		pr->performance.status_register));
+
+end:
+	acpi_os_free(buffer.pointer);
+
+	return_VALUE(result);
+}
+
+
+static int 
+acpi_processor_get_performance_states (
+	struct acpi_processor*	pr)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	struct acpi_buffer	format = {sizeof("NNNNNN"), "NNNNNN"};
+	struct acpi_buffer	state = {0, NULL};
+	union acpi_object 	*pss = NULL;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_performance_states");
+
+	status = acpi_evaluate_object(pr->handle, "_PSS", NULL, &buffer);
+	if(ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PSS\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	pss = (union acpi_object *) buffer.pointer;
+	if (!pss || (pss->type != ACPI_TYPE_PACKAGE)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _PSS data\n"));
+		result = -EFAULT;
+		goto end;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %d performance states\n", 
+		pss->package.count));
+
+	if (pss->package.count > ACPI_PROCESSOR_MAX_PERFORMANCE) {
+		pr->performance.state_count = ACPI_PROCESSOR_MAX_PERFORMANCE;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"Limiting number of states to max (%d)\n", 
+			ACPI_PROCESSOR_MAX_PERFORMANCE));
+	}
+	else
+		pr->performance.state_count = pss->package.count;
+
+	if (pr->performance.state_count > 1)
+		pr->flags.performance = 1;
+
+	for (i = 0; i < pr->performance.state_count; i++) {
+
+		struct acpi_processor_px *px = &(pr->performance.states[i]);
+
+		state.length = sizeof(struct acpi_processor_px);
+		state.pointer = px;
+
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Extracting state %d\n", i));
+
+		status = acpi_extract_package(&(pss->package.elements[i]), 
+			&format, &state);
+		if (ACPI_FAILURE(status)) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _PSS data\n"));
+			result = -EFAULT;
+			goto end;
+		}
+
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"State [%d]: core_frequency[%d] power[%d] transition_latency[%d] bus_master_latency[%d] control[0x%x] status[0x%x]\n",
+			i, 
+			(u32) px->core_frequency, 
+			(u32) px->power, 
+			(u32) px->transition_latency, 
+			(u32) px->bus_master_latency,
+			(u32) px->control, 
+			(u32) px->status));
+	}
+
+end:
+	acpi_os_free(buffer.pointer);
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_processor_set_performance (
+	struct acpi_processor	*pr,
+	int			state)
+{
+	u16			port = 0;
+	u8			value = 0;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_set_performance");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	if (!pr->flags.performance)
+		return_VALUE(-ENODEV);
+
+	if (state >= pr->performance.state_count) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, 
+			"Invalid target state (P%d)\n", state));
+		return_VALUE(-ENODEV);
+	}
+
+	if (state < pr->performance.platform_limit) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, 
+			"Platform limit (P%d) overrides target state (P%d)\n",
+			pr->performance.platform_limit, state));
+		return_VALUE(-ENODEV);
+	}
+
+	if (state == pr->performance.state) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"Already at target state (P%d)\n", state));
+		return_VALUE(0);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Transitioning from P%d to P%d\n",
+		pr->performance.state, state));
+
+	/*
+	 * First we write the target state's 'control' value to the
+	 * control_register.
+	 */
+
+	port = pr->performance.control_register;
+	value = (u16) pr->performance.states[state].control;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+		"Writing 0x%02x to port 0x%04x\n", value, port));
+
+	outb(value, port); 
+
+	/*
+	 * Then we read the 'status_register' and compare the value with the
+	 * target state's 'status' to make sure the transition was successful.
+	 * Note that we'll poll for up to 1ms (100 cycles of 10us) before
+	 * giving up.
+	 */
+
+	port = pr->performance.status_register;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+		"Looking for 0x%02x from port 0x%04x\n",
+		(u8) pr->performance.states[state].status, port));
+
+	for (i=0; i<100; i++) {
+		value = inb(port);
+		if (value == (u8) pr->performance.states[state].status)
+			break;
+		udelay(10);
+	}
+
+	if (value != pr->performance.states[state].status) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Transition failed\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+		"Transition successful after %d microseconds\n",
+		i * 10));
+
+	pr->performance.state = state;
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_processor_get_performance_info (
+	struct acpi_processor	*pr)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	acpi_handle		handle = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_performance_info");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	status = acpi_get_handle(pr->handle, "_PCT", &handle);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"ACPI-based processor performance control unavailable\n"));
+		return_VALUE(0);
+	}
+
+	result = acpi_processor_get_performance_control(pr);
+	if (result)
+		return_VALUE(result);
+
+	result = acpi_processor_get_performance_states(pr);
+	if (result)
+		return_VALUE(result);
+
+	result = acpi_processor_get_platform_limit(pr);
+	if (result)
+		return_VALUE(result);
+
+	/* 
+	 * TBD: Don't trust the latency values we get from BIOS, but rather
+	 *      measure the latencies during run-time (e.g. get_latencies).
+	 */
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                              Throttling Control
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_processor_get_throttling (
+	struct acpi_processor	*pr)
+{
+	int			state = 0;
+	u32			value = 0;
+	u32			duty_mask = 0;
+	u32			duty_value = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_throttling");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	if (!pr->flags.throttling)
+		return_VALUE(-ENODEV);
+
+	pr->throttling.state = 0;
+
+	__cli();
+
+	duty_mask = pr->throttling.state_count - 1;
+
+	duty_mask <<= pr->throttling.duty_offset;
+
+	value = inl(pr->throttling.address);
+
+	/*
+	 * Compute the current throttling state when throttling is enabled
+	 * (bit 4 is on).
+	 */
+	if (value & 0x10) {
+		duty_value = value & duty_mask;
+		duty_value >>= pr->throttling.duty_offset;
+
+		if (duty_value)
+			state = pr->throttling.state_count-duty_value;
+	}
+
+	pr->throttling.state = state;
+
+	__sti();
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+		"Throttling state is T%d (%d%% throttling applied)\n",
+		state, pr->throttling.states[state].performance));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_processor_set_throttling (
+	struct acpi_processor	*pr,
+	int			state)
+{
+	u32                     value = 0;
+	u32                     duty_mask = 0;
+	u32                     duty_value = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_set_throttling");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	if ((state < 0) || (state > (pr->throttling.state_count - 1)))
+		return_VALUE(-EINVAL);
+
+	if (!pr->flags.throttling)
+		return_VALUE(-ENODEV);
+
+	if (state == pr->throttling.state)
+		return_VALUE(0);
+
+	__cli();
+
+	/*
+	 * Calculate the duty_value and duty_mask.
+	 */
+	if (state) {
+		duty_value = pr->throttling.state_count - state;
+
+		duty_value <<= pr->throttling.duty_offset;
+
+		/* Used to clear all duty_value bits */
+		duty_mask = pr->throttling.state_count - 1;
+
+		duty_mask <<= acpi_fadt.duty_offset;
+		duty_mask = ~duty_mask;
+	}
+
+	/*
+	 * Disable throttling by writing a 0 to bit 4.  Note that we must
+	 * turn it off before you can change the duty_value.
+	 */
+	value = inl(pr->throttling.address);
+	if (value & 0x10) {
+		value &= 0xFFFFFFEF;
+		outl(value, pr->throttling.address);
+	}
+
+	/*
+	 * Write the new duty_value and then enable throttling.  Note
+	 * that a state value of 0 leaves throttling disabled.
+	 */
+	if (state) {
+		value &= duty_mask;
+		value |= duty_value;
+		outl(value, pr->throttling.address);
+
+		value |= 0x00000010;
+		outl(value, pr->throttling.address);
+	}
+
+	pr->throttling.state = state;
+
+	__sti();
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+		"Throttling state set to T%d (%d%%)\n", state, 
+		(pr->throttling.states[state].performance?pr->throttling.states[state].performance/10:0)));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_processor_get_throttling_info (
+	struct acpi_processor	*pr)
+{
+	int			result = 0;
+	int			step = 0;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_throttling_info");
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+		"pblk_address[0x%08x] duty_offset[%d] duty_width[%d]\n",
+		pr->throttling.address,
+		pr->throttling.duty_offset,
+		pr->throttling.duty_width));
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	/* TBD: Support ACPI 2.0 objects */
+
+	if (!pr->throttling.address) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No throttling register\n"));
+		return_VALUE(0);
+	}
+	else if (!pr->throttling.duty_width) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No throttling states\n"));
+		return_VALUE(0);
+	}
+	/* TBD: Support duty_cycle values that span bit 4. */
+	else if ((pr->throttling.duty_offset
+		+ pr->throttling.duty_width) > 4) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "duty_cycle spans bit 4\n"));
+		return_VALUE(0);
+	}
+
+	/*
+	 * PIIX4 Errata: We don't support throttling on the original PIIX4.
+	 * This shouldn't be an issue as few (if any) mobile systems ever
+	 * used this part.
+	 */
+	if (errata.piix4.throttle) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"Throttling not supported on PIIX4 A- or B-step\n"));
+		return_VALUE(0);
+	}
+
+	pr->throttling.state_count = POWER_OF_2[acpi_fadt.duty_width];
+
+	/*
+	 * Compute state values. Note that throttling displays a linear power/
+	 * performance relationship (at 50% performance the CPU will consume
+	 * 50% power).  Values are in 1/10th of a percent to preserve accuracy.
+	 */
+
+	step = (1000 / pr->throttling.state_count);
+
+	for (i=0; i<pr->throttling.state_count; i++) {
+		pr->throttling.states[i].performance = step * i;
+		pr->throttling.states[i].power = step * i;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %d throttling states\n", 
+		pr->throttling.state_count));
+
+	pr->flags.throttling = 1;
+
+	/*
+	 * Disable throttling (if enabled).  We'll let subsequent policy (e.g. 
+	 * thermal) decide to lower performance if it so chooses, but for now 
+	 * we'll crank up the speed.
+	 */
+
+	result = acpi_processor_get_throttling(pr);
+	if (result)
+		goto end;
+
+	if (pr->throttling.state) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Disabling throttling (was T%d)\n", 
+			pr->throttling.state));
+		result = acpi_processor_set_throttling(pr, 0);
+		if (result)
+			goto end;
+	}
+
+end:
+	if (result)
+		pr->flags.throttling = 0;
+
+	return_VALUE(result);
+}
+
+
+/* --------------------------------------------------------------------------
+                                 Limit Interface
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_processor_apply_limit (
+	struct acpi_processor* 	pr)
+{
+	int			result = 0;
+	u16			px = 0;
+	u16			tx = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_apply_limit");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	if (!pr->flags.limit)
+		return_VALUE(-ENODEV);
+
+	if (pr->flags.performance) {
+		px = pr->performance.platform_limit;
+		if (pr->limit.user.px > px)
+			px = pr->limit.user.px;
+		if (pr->limit.thermal.px > px)
+			px = pr->limit.thermal.px;
+
+		result = acpi_processor_set_performance(pr, px);
+		if (result)
+			goto end;
+	}
+
+	if (pr->flags.throttling) {
+		if (pr->limit.user.tx > tx)
+			tx = pr->limit.user.tx;
+		if (pr->limit.thermal.tx > tx)
+			tx = pr->limit.thermal.tx;
+
+		result = acpi_processor_set_throttling(pr, tx);
+		if (result)
+			goto end;
+	}
+
+	pr->limit.state.px = px;
+	pr->limit.state.tx = tx;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Processor [%d] limit set to (P%d:T%d)\n",
+		pr->id,
+		pr->limit.state.px,
+		pr->limit.state.tx));
+
+end:
+	if (result)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unable to set limit\n"));
+
+	return_VALUE(result);
+}
+
+
+int
+acpi_processor_set_thermal_limit (
+	acpi_handle		handle,
+	int			type)
+{
+	int			result = 0;
+	struct acpi_processor	*pr = NULL;
+	struct acpi_device	*device = NULL;
+	int			px = 0;
+	int			tx = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_set_thermal_limit");
+
+	if ((type < ACPI_PROCESSOR_LIMIT_NONE) 
+		|| (type > ACPI_PROCESSOR_LIMIT_DECREMENT))
+		return_VALUE(-EINVAL);
+
+	result = acpi_bus_get_device(handle, &device);
+	if (result)
+		return_VALUE(result);
+
+	pr = (struct acpi_processor *) acpi_driver_data(device);
+	if (!pr)
+		return_VALUE(-ENODEV);
+
+	if (!pr->flags.limit)
+		return_VALUE(-ENODEV);
+
+	/* Thermal limits are always relative to the current Px/Tx state. */
+	if (pr->flags.performance)
+		pr->limit.thermal.px = pr->performance.state;
+	if (pr->flags.throttling)
+		pr->limit.thermal.tx = pr->throttling.state;
+
+	/*
+	 * Our default policy is to only use throttling at the lowest
+	 * performance state.
+	 */
+
+	px = pr->limit.thermal.px;
+	tx = pr->limit.thermal.tx;
+
+	switch (type) {
+
+	case ACPI_PROCESSOR_LIMIT_NONE:
+		px = 0;
+		tx = 0;
+		break;
+
+	case ACPI_PROCESSOR_LIMIT_INCREMENT:
+		if (pr->flags.performance) {
+			if (px == (pr->performance.state_count - 1))
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+					"At maximum performance state\n"));
+			else {
+				px++;
+				goto end;
+			}
+		}
+		if (pr->flags.throttling) {
+			if (tx == (pr->throttling.state_count - 1))
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+					"At maximum throttling state\n"));
+			else
+				tx++;
+		}
+		break;
+
+	case ACPI_PROCESSOR_LIMIT_DECREMENT:
+		if (pr->flags.performance) {
+			if (px == pr->performance.platform_limit)
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+					"At minimum performance state\n"));
+			else  {
+				px--;
+				goto end;
+			}
+		}
+		if (pr->flags.throttling) {
+			if (tx == 0)
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+					"At minimum throttling state\n"));
+			else
+				tx--;
+		}
+		break;
+	}
+
+end:
+	pr->limit.thermal.px = px;
+	pr->limit.thermal.tx = tx;
+
+	result = acpi_processor_apply_limit(pr);
+	if (result)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Unable to set thermal limit\n"));
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Thermal limit now (P%d:T%d)\n",
+		pr->limit.thermal.px,
+		pr->limit.thermal.tx));
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_processor_get_limit_info (
+	struct acpi_processor	*pr)
+{
+	ACPI_FUNCTION_TRACE("acpi_processor_get_limit_info");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	if (pr->flags.performance || pr->flags.throttling)
+		pr->flags.limit = 1;
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+struct proc_dir_entry		*acpi_processor_dir = NULL;
+
+static int
+acpi_processor_read_info (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_processor	*pr = (struct acpi_processor *) data;
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_read_info");
+
+	if (!pr || (off != 0))
+		goto end;
+
+	p += sprintf(p, "processor id:            %d\n",
+		pr->id);
+
+	p += sprintf(p, "acpi id:                 %d\n",
+		pr->acpi_id);
+
+	p += sprintf(p, "bus mastering control:   %s\n",
+		pr->flags.bm_control ? "yes" : "no");
+
+	p += sprintf(p, "power management:        %s\n",
+		pr->flags.power ? "yes" : "no");
+
+	p += sprintf(p, "throttling control:      %s\n",
+		pr->flags.throttling ? "yes" : "no");
+
+	p += sprintf(p, "performance management:  %s\n",
+		pr->flags.performance ? "yes" : "no");
+
+	p += sprintf(p, "limit interface:         %s\n",
+		pr->flags.limit ? "yes" : "no");
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_processor_read_power (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_processor	*pr = (struct acpi_processor *) data;
+	char			*p = page;
+	int			len = 0;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_read_power");
+
+	if (!pr || (off != 0))
+		goto end;
+
+	p += sprintf(p, "active state:            C%d\n",
+		pr->power.state);
+
+	p += sprintf(p, "default state:           C%d\n",
+		pr->power.default_state);
+
+	p += sprintf(p, "bus master activity:     %08x\n",
+		pr->power.bm_activity);
+
+	p += sprintf(p, "states:\n");
+
+	for (i=1; i<ACPI_C_STATE_COUNT; i++) {
+
+		p += sprintf(p, "   %cC%d:                  ", 
+			(i == pr->power.state?'*':' '), i);
+
+		if (!pr->power.states[i].valid) {
+			p += sprintf(p, "<not supported>\n");
+			continue;
+		}
+
+		if (pr->power.states[i].promotion.state)
+			p += sprintf(p, "promotion[C%d] ",
+				pr->power.states[i].promotion.state);
+		else
+			p += sprintf(p, "promotion[--] ");
+
+		if (pr->power.states[i].demotion.state)
+			p += sprintf(p, "demotion[C%d] ",
+				pr->power.states[i].demotion.state);
+		else
+			p += sprintf(p, "demotion[--] ");
+
+		p += sprintf(p, "latency[%03d] usage[%08d]\n",
+			pr->power.states[i].latency,
+			pr->power.states[i].usage);
+	}
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_processor_read_performance (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_processor	*pr = (struct acpi_processor *) data;
+	char			*p = page;
+	int			len = 0;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_read_performance");
+
+	if (!pr || (off != 0))
+		goto end;
+
+	if (!pr->flags.performance) {
+		p += sprintf(p, "<not supported>\n");
+		goto end;
+	}
+
+	p += sprintf(p, "state count:             %d\n",
+		pr->performance.state_count);
+
+	p += sprintf(p, "active state:            P%d\n",
+		pr->performance.state);
+
+	p += sprintf(p, "states:\n");
+
+	for (i=0; i<pr->performance.state_count; i++)
+		p += sprintf(p, "   %cP%d:                  %d MHz, %d mW, %d uS\n",
+			(i == pr->performance.state?'*':' '), i,
+			(u32) pr->performance.states[i].core_frequency,
+			(u32) pr->performance.states[i].power,
+			(u32) pr->performance.states[i].transition_latency);
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_processor_write_performance (
+        struct file		*file,
+        const char		*buffer,
+        unsigned long		count,
+        void			*data)
+{
+	int			result = 0;
+	struct acpi_processor	*pr = (struct acpi_processor *) data;
+	char			state_string[12] = {'\0'};
+
+	ACPI_FUNCTION_TRACE("acpi_processor_write_performance");
+
+	if (!pr || (count > sizeof(state_string) - 1))
+		return_VALUE(-EINVAL);
+	
+	if (copy_from_user(state_string, buffer, count))
+		return_VALUE(-EFAULT);
+	
+	state_string[count] = '\0';
+
+	result = acpi_processor_set_performance(pr, 
+		simple_strtoul(state_string, NULL, 0));
+	if (result)
+		return_VALUE(result);
+
+	return_VALUE(count);
+}
+
+
+static int
+acpi_processor_read_throttling (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_processor	*pr = (struct acpi_processor *) data;
+	char			*p = page;
+	int			len = 0;
+	int			i = 0;
+	int                     result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_read_throttling");
+
+	if (!pr || (off != 0))
+		goto end;
+
+	if (!(pr->throttling.state_count > 0)) {
+		p += sprintf(p, "<not supported>\n");
+		goto end;
+	}
+
+	result = acpi_processor_get_throttling(pr);
+
+	if (result) {
+		p += sprintf(p, "Could not determine current throttling state.\n");
+		goto end;
+	}
+
+	p += sprintf(p, "state count:             %d\n",
+		pr->throttling.state_count);
+
+	p += sprintf(p, "active state:            T%d\n",
+		pr->throttling.state);
+
+	p += sprintf(p, "states:\n");
+
+	for (i=0; i<pr->throttling.state_count; i++)
+		p += sprintf(p, "   %cT%d:                  %02d%%\n",
+			(i == pr->throttling.state?'*':' '), i,
+			(pr->throttling.states[i].performance?pr->throttling.states[i].performance/10:0));
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_processor_write_throttling (
+        struct file		*file,
+        const char		*buffer,
+        unsigned long		count,
+        void			*data)
+{
+	int			result = 0;
+	struct acpi_processor	*pr = (struct acpi_processor *) data;
+	char			state_string[12] = {'\0'};
+
+	ACPI_FUNCTION_TRACE("acpi_processor_write_throttling");
+
+	if (!pr || (count > sizeof(state_string) - 1))
+		return_VALUE(-EINVAL);
+	
+	if (copy_from_user(state_string, buffer, count))
+		return_VALUE(-EFAULT);
+	
+	state_string[count] = '\0';
+	
+	result = acpi_processor_set_throttling(pr, 
+		simple_strtoul(state_string, NULL, 0));
+	if (result)
+		return_VALUE(result);
+
+	return_VALUE(count);
+}
+
+
+static int
+acpi_processor_read_limit (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_processor	*pr = (struct acpi_processor *) data;
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_read_limit");
+
+	if (!pr || (off != 0))
+		goto end;
+
+	if (!pr->flags.limit) {
+		p += sprintf(p, "<not supported>\n");
+		goto end;
+	}
+
+	p += sprintf(p, "active limit:            P%d:T%d\n",
+		pr->limit.state.px, pr->limit.state.tx);
+
+	p += sprintf(p, "platform limit:          P%d:T0\n",
+		pr->flags.performance?pr->performance.platform_limit:0);
+
+	p += sprintf(p, "user limit:              P%d:T%d\n",
+		pr->limit.user.px, pr->limit.user.tx);
+
+	p += sprintf(p, "thermal limit:           P%d:T%d\n",
+		pr->limit.thermal.px, pr->limit.thermal.tx);
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_processor_write_limit (
+        struct file		*file,
+        const char		*buffer,
+        unsigned long		count,
+        void			*data)
+{
+	int			result = 0;
+	struct acpi_processor	*pr = (struct acpi_processor *) data;
+	char			limit_string[25] = {'\0'};
+	int			px = 0;
+	int			tx = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_write_limit");
+
+	if (!pr || (count > sizeof(limit_string) - 1)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid argument\n"));
+		return_VALUE(-EINVAL);
+	}
+	
+	if (copy_from_user(limit_string, buffer, count)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data\n"));
+		return_VALUE(-EFAULT);
+	}
+	
+	limit_string[count] = '\0';
+
+	if (sscanf(limit_string, "%d:%d", &px, &tx) != 2) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data format\n"));
+		return_VALUE(-EINVAL);
+	}
+
+	if (pr->flags.performance) {
+		if ((px < pr->performance.platform_limit) 
+			|| (px > (pr->performance.state_count - 1))) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid px\n"));
+			return_VALUE(-EINVAL);
+		}
+		pr->limit.user.px = px;
+	}
+
+	if (pr->flags.throttling) {
+		if ((tx < 0) || (tx > (pr->throttling.state_count - 1))) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid tx\n"));
+			return_VALUE(-EINVAL);
+		}
+		pr->limit.user.tx = tx;
+	}
+
+	result = acpi_processor_apply_limit(pr);
+
+	return_VALUE(count);
+}
+
+
+static int
+acpi_processor_add_fs (
+	struct acpi_device	*device)
+{
+	struct proc_dir_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_add_fs");
+
+	if (!acpi_device_dir(device)) {
+		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
+			acpi_processor_dir);
+		if (!acpi_device_dir(device))
+			return_VALUE(-ENODEV);
+	}
+
+	/* 'info' [R] */
+	entry = create_proc_entry(ACPI_PROCESSOR_FILE_INFO,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_PROCESSOR_FILE_INFO));
+	else {
+		entry->read_proc = acpi_processor_read_info;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'power' [R] */
+	entry = create_proc_entry(ACPI_PROCESSOR_FILE_POWER,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_PROCESSOR_FILE_POWER));
+	else {
+		entry->read_proc = acpi_processor_read_power;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'performance' [R/W] */
+	entry = create_proc_entry(ACPI_PROCESSOR_FILE_PERFORMANCE,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_PROCESSOR_FILE_PERFORMANCE));
+	else {
+		entry->read_proc = acpi_processor_read_performance;
+		entry->write_proc = acpi_processor_write_performance;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'throttling' [R/W] */
+	entry = create_proc_entry(ACPI_PROCESSOR_FILE_THROTTLING,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_PROCESSOR_FILE_THROTTLING));
+	else {
+		entry->read_proc = acpi_processor_read_throttling;
+		entry->write_proc = acpi_processor_write_throttling;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'limit' [R/W] */
+	entry = create_proc_entry(ACPI_PROCESSOR_FILE_LIMIT,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_PROCESSOR_FILE_LIMIT));
+	else {
+		entry->read_proc = acpi_processor_read_limit;
+		entry->write_proc = acpi_processor_write_limit;
+		entry->data = acpi_driver_data(device);
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_processor_remove_fs (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_processor_remove_fs");
+
+	if (acpi_device_dir(device)) {
+		remove_proc_entry(acpi_device_bid(device), acpi_processor_dir);
+		acpi_device_dir(device) = NULL;
+	}
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                 Driver Interface
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_processor_get_info (
+	struct acpi_processor	*pr)
+{
+	acpi_status		status = 0;
+	union acpi_object	object = {0};
+	struct acpi_buffer	buffer = {sizeof(union acpi_object), &object};
+	static int		cpu_index = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_info");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+#ifdef CONFIG_SMP
+	if (smp_num_cpus > 1)
+		errata.smp = smp_num_cpus;
+
+	/*
+	 *  Extra Processor objects may be enumerated on MP systems with
+	 *  less than the max # of CPUs. They should be ignored.
+	 */
+	if ((cpu_index + 1) > smp_num_cpus)
+		return_VALUE(-ENODEV);
+#endif
+
+	acpi_processor_errata(pr);
+
+	/*
+	 * Check to see if we have bus mastering arbitration control.  This
+	 * is required for proper C3 usage (to maintain cache coherency).
+	 */
+	if (acpi_fadt.V1_pm2_cnt_blk && acpi_fadt.pm2_cnt_len) {
+		pr->flags.bm_control = 1;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Bus mastering arbitration control present\n"));
+	}
+	else
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"No bus mastering arbitration control\n"));
+
+	/*
+	 * Evalute the processor object.  Note that it is common on SMP to
+	 * have the first (boot) processor with a valid PBLK address while
+	 * all others have a NULL address.
+	 */
+	status = acpi_evaluate_object(pr->handle, NULL, NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error evaluating processor object\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	/*
+	 * TBD: Synch processor ID (via LAPIC/LSAPIC structures) on SMP.
+	 *	>>> 'acpi_get_processor_id(acpi_id, &id)' in arch/xxx/acpi.c
+	 */
+	pr->id = cpu_index++;
+	pr->acpi_id = object.processor.proc_id;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Processor [%d:%d]\n", pr->id, 
+		pr->acpi_id));
+
+	if (!object.processor.pblk_address)
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No PBLK (NULL address)\n"));
+	else if (object.processor.pblk_length != 6)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid PBLK length [%d]\n",
+			object.processor.pblk_length));
+	else {
+		pr->throttling.address = object.processor.pblk_address;
+		pr->throttling.duty_offset = acpi_fadt.duty_offset;
+		pr->throttling.duty_width = acpi_fadt.duty_width;
+		pr->power.states[ACPI_STATE_C2].address =
+			object.processor.pblk_address + 4;
+		pr->power.states[ACPI_STATE_C3].address =
+			object.processor.pblk_address + 5;
+	}
+
+	acpi_processor_get_power_info(pr);
+	acpi_processor_get_performance_info(pr);
+	acpi_processor_get_throttling_info(pr);
+	acpi_processor_get_limit_info(pr);
+
+	return_VALUE(0);
+}
+
+
+static void
+acpi_processor_notify (
+	acpi_handle		handle,
+	u32			event,
+	void			*data)
+{
+	int			result = 0;
+	struct acpi_processor	*pr = (struct acpi_processor *) data;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_notify");
+
+	if (!pr)
+		return_VOID;
+
+	if (acpi_bus_get_device(pr->handle, &device))
+		return_VOID;
+
+	switch (event) {
+	case ACPI_PROCESSOR_NOTIFY_PERFORMANCE:
+		result = acpi_processor_get_platform_limit(pr);
+		if (!result)
+			acpi_processor_apply_limit(pr);
+
+		acpi_bus_generate_event(device, event, 
+			pr->performance.platform_limit);
+		break;
+	case ACPI_PROCESSOR_NOTIFY_POWER:
+		/* TBD */
+		acpi_bus_generate_event(device, event, 0);
+		break;
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Unsupported event [0x%x]\n", event));
+		break;
+	}
+
+	return_VOID;
+}
+
+
+static int
+acpi_processor_add (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_processor	*pr = NULL;
+	u32			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	pr = kmalloc(sizeof(struct acpi_processor), GFP_KERNEL);
+	if (!pr)
+		return_VALUE(-ENOMEM);
+	memset(pr, 0, sizeof(struct acpi_processor));
+
+	pr->handle = device->handle;
+	sprintf(acpi_device_name(device), "%s", ACPI_PROCESSOR_DEVICE_NAME);
+	sprintf(acpi_device_class(device), "%s", ACPI_PROCESSOR_CLASS);
+	acpi_driver_data(device) = pr;
+
+	result = acpi_processor_get_info(pr);
+	if (result)
+		goto end;
+
+	result = acpi_processor_add_fs(device);
+	if (result)
+		goto end;
+
+	status = acpi_install_notify_handler(pr->handle, ACPI_DEVICE_NOTIFY, 
+		acpi_processor_notify, pr);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Error installing notify handler\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	processors[pr->id] = pr;
+
+	/*
+	 * Install the idle handler if processor power management is supported.
+	 * Note that the default idle handler (default_idle) will be used on 
+	 * platforms that only support C1.
+	 */
+	if ((pr->id == 0) && (pr->flags.power)) {
+		pm_idle_save = pm_idle;
+		pm_idle = acpi_processor_idle;
+	}
+	
+	printk(KERN_INFO PREFIX "%s [%s] (supports",
+		acpi_device_name(device), acpi_device_bid(device));
+	for (i=1; i<ACPI_C_STATE_COUNT; i++)
+		if (pr->power.states[i].valid)
+			printk(" C%d", i);
+	if (pr->flags.performance)
+		printk(", %d performance states", pr->performance.state_count);
+	if (pr->flags.throttling)
+		printk(", %d throttling states", pr->throttling.state_count);
+	printk(")\n");
+
+end:
+	if (result) {
+		acpi_processor_remove_fs(device);
+		kfree(pr);
+	}
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_processor_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_processor	*pr = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	pr = (struct acpi_processor *) acpi_driver_data(device);
+
+	/* Unregister the idle handler when processor #0 is removed. */
+	if (pr->id == 0)
+		pm_idle = pm_idle_save;
+
+	status = acpi_remove_notify_handler(pr->handle, ACPI_DEVICE_NOTIFY, 
+		acpi_processor_notify);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Error removing notify handler\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	acpi_processor_remove_fs(device);
+
+	processors[pr->id] = NULL;
+
+	kfree(pr);
+
+	return_VALUE(0);
+}
+
+
+static int __init
+acpi_processor_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_init");
+
+	memset(&processors, 0, sizeof(processors));
+	memset(&errata, 0, sizeof(errata));
+
+	acpi_processor_dir = proc_mkdir(ACPI_PROCESSOR_CLASS, acpi_root_dir);
+	if (!acpi_processor_dir)
+		return_VALUE(-ENODEV);
+
+	result = acpi_bus_register_driver(&acpi_processor_driver);
+	if (result < 0) {
+		remove_proc_entry(ACPI_PROCESSOR_CLASS, acpi_root_dir);
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+
+
+static void __exit
+acpi_processor_exit (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_processor_exit");
+
+	acpi_bus_unregister_driver(&acpi_processor_driver);
+
+	remove_proc_entry(ACPI_PROCESSOR_CLASS, acpi_root_dir);
+
+	return_VOID;
+}
+
+
+module_init(acpi_processor_init);
+module_exit(acpi_processor_exit);
+
+EXPORT_SYMBOL(acpi_processor_set_thermal_limit);
diff -urNp linux-5400/drivers/acpi/resources/Makefile linux-5410/drivers/acpi/resources/Makefile
--- linux-5400/drivers/acpi/resources/Makefile
+++ linux-5410/drivers/acpi/resources/Makefile
@@ -1,11 +1,10 @@
 #
 # Makefile for all Linux ACPI interpreter subdirectories
-# EXCEPT for the ospm directory
 #
 
 O_TARGET := $(notdir $(CURDIR)).o
 
-obj-$(CONFIG_ACPI) := $(patsubst %.c,%.o,$(wildcard *.c))
+obj-$(CONFIG_ACPI_INTERPRETER) := $(patsubst %.c,%.o,$(wildcard *.c))
 
 EXTRA_CFLAGS += $(ACPI_CFLAGS)
 
diff -urNp linux-5400/drivers/acpi/resources/rsaddr.c linux-5410/drivers/acpi/resources/rsaddr.c
--- linux-5400/drivers/acpi/resources/rsaddr.c
+++ linux-5410/drivers/acpi/resources/rsaddr.c
@@ -1,81 +1,98 @@
 /*******************************************************************************
  *
  * Module Name: rsaddr - Address resource descriptors (16/32/64)
- *              $Revision: 19 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acresrc.h"
+#include <acpi/acpi.h>
+#include <acpi/acresrc.h>
 
 #define _COMPONENT          ACPI_RESOURCES
-	 MODULE_NAME         ("rsaddr")
+	 ACPI_MODULE_NAME    ("rsaddr")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_address16_resource
+ * FUNCTION:    acpi_rs_address16_resource
  *
- * PARAMETERS:  Byte_stream_buffer      - Pointer to the resource input byte
+ * PARAMETERS:  byte_stream_buffer      - Pointer to the resource input byte
  *                                        stream
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes consumed from
- *                                        the Byte_stream_buffer
- *              Output_buffer           - Pointer to the user's return buffer
- *              Structure_size          - u32 pointer that is filled with
- *                                        the number of bytes in the filled
- *                                        in structure
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        consumed the byte_stream_buffer is
+ *                                        returned
+ *              output_buffer           - Pointer to the return data buffer
+ *              structure_size          - Pointer to where the number of bytes
+ *                                        in the return data struct is returned
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Take the resource byte stream and fill out the appropriate
- *              structure pointed to by the Output_buffer. Return the
+ *              structure pointed to by the output_buffer. Return the
  *              number of bytes consumed from the byte stream.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_rs_address16_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size)
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size)
 {
-	u8                      *buffer = byte_stream_buffer;
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
-	NATIVE_CHAR             *temp_ptr;
-	u32                     struct_size = SIZEOF_RESOURCE (acpi_resource_address16);
-	u32                     index;
-	u16                     temp16;
-	u8                      temp8;
+	u8                              *buffer = byte_stream_buffer;
+	struct acpi_resource            *output_struct = (void *) *output_buffer;
+	u8                              *temp_ptr;
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_address16);
+	u32                             index;
+	u16                             temp16;
+	u8                              temp8;
 
 
-	FUNCTION_TRACE ("Rs_address16_resource");
+	ACPI_FUNCTION_TRACE ("rs_address16_resource");
 
 	/*
 	 * Point past the Descriptor to get the number of bytes consumed
 	 */
 	buffer += 1;
-	MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
+	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
 	*bytes_consumed = temp16 + 3;
 	output_struct->id = ACPI_RSTYPE_ADDRESS16;
@@ -87,6 +104,7 @@ acpi_rs_address16_resource (
 	temp8 = *buffer;
 
 	/* Values 0-2 are valid */
+
 	if (temp8 > 2) {
 		return_ACPI_STATUS (AE_AML_INVALID_RESOURCE_TYPE);
 	}
@@ -99,24 +117,20 @@ acpi_rs_address16_resource (
 	buffer += 1;
 	temp8 = *buffer;
 
-	/*
-	 * Producer / Consumer
-	 */
+	/* Producer / Consumer */
+
 	output_struct->data.address16.producer_consumer = temp8 & 0x01;
 
-	/*
-	 * Decode
-	 */
+	/* Decode */
+
 	output_struct->data.address16.decode = (temp8 >> 1) & 0x01;
 
-	/*
-	 * Min Address Fixed
-	 */
+	/* Min Address Fixed */
+
 	output_struct->data.address16.min_address_fixed = (temp8 >> 2) & 0x01;
 
-	/*
-	 * Max Address Fixed
-	 */
+	/* Max Address Fixed */
+
 	output_struct->data.address16.max_address_fixed = (temp8 >> 3) & 0x01;
 
 	/*
@@ -125,21 +139,21 @@ acpi_rs_address16_resource (
 	buffer += 1;
 	temp8 = *buffer;
 
-	if (MEMORY_RANGE == output_struct->data.address16.resource_type) {
+	if (ACPI_MEMORY_RANGE == output_struct->data.address16.resource_type) {
 		output_struct->data.address16.attribute.memory.read_write_attribute =
 				(u16) (temp8 & 0x01);
 		output_struct->data.address16.attribute.memory.cache_attribute =
 				(u16) ((temp8 >> 1) & 0x0F);
 	}
-
 	else {
-		if (IO_RANGE == output_struct->data.address16.resource_type) {
+		if (ACPI_IO_RANGE == output_struct->data.address16.resource_type) {
 			output_struct->data.address16.attribute.io.range_attribute =
 				(u16) (temp8 & 0x03);
+			output_struct->data.address16.attribute.io.translation_attribute =
+				(u16) ((temp8 >> 4) & 0x03);
 		}
-
 		else {
-			/* BUS_NUMBER_RANGE == Address16.Data->Resource_type */
+			/* BUS_NUMBER_RANGE == Address16.Data->resource_type */
 			/* Nothing needs to be filled in */
 		}
 	}
@@ -148,36 +162,31 @@ acpi_rs_address16_resource (
 	 * Get Granularity (Bytes 6-7)
 	 */
 	buffer += 1;
-	MOVE_UNALIGNED16_TO_16 (&output_struct->data.address16.granularity,
-			 buffer);
+	ACPI_MOVE_16_TO_32 (&output_struct->data.address16.granularity, buffer);
 
 	/*
-	 * Get Min_address_range (Bytes 8-9)
+	 * Get min_address_range (Bytes 8-9)
 	 */
 	buffer += 2;
-	MOVE_UNALIGNED16_TO_16 (&output_struct->data.address16.min_address_range,
-			 buffer);
+	ACPI_MOVE_16_TO_32 (&output_struct->data.address16.min_address_range, buffer);
 
 	/*
-	 * Get Max_address_range (Bytes 10-11)
+	 * Get max_address_range (Bytes 10-11)
 	 */
 	buffer += 2;
-	MOVE_UNALIGNED16_TO_16 (&output_struct->data.address16.max_address_range,
-			 buffer);
+	ACPI_MOVE_16_TO_32 (&output_struct->data.address16.max_address_range, buffer);
 
 	/*
-	 * Get Address_translation_offset (Bytes 12-13)
+	 * Get address_translation_offset (Bytes 12-13)
 	 */
 	buffer += 2;
-	MOVE_UNALIGNED16_TO_16 (&output_struct->data.address16.address_translation_offset,
-			 buffer);
+	ACPI_MOVE_16_TO_32 (&output_struct->data.address16.address_translation_offset, buffer);
 
 	/*
-	 * Get Address_length (Bytes 14-15)
+	 * Get address_length (Bytes 14-15)
 	 */
 	buffer += 2;
-	MOVE_UNALIGNED16_TO_16 (&output_struct->data.address16.address_length,
-			 buffer);
+	ACPI_MOVE_16_TO_32 (&output_struct->data.address16.address_length, buffer);
 
 	/*
 	 * Resource Source Index (if present)
@@ -204,9 +213,9 @@ acpi_rs_address16_resource (
 		/* Point the String pointer to the end of this structure */
 
 		output_struct->data.address16.resource_source.string_ptr =
-				(NATIVE_CHAR *)((u8 * )output_struct + struct_size);
+				(char *)((u8 * )output_struct + struct_size);
 
-		temp_ptr = output_struct->data.address16.resource_source.string_ptr;
+		temp_ptr = (u8 *) output_struct->data.address16.resource_source.string_ptr;
 
 		/* Copy the string into the buffer */
 
@@ -228,14 +237,13 @@ acpi_rs_address16_resource (
 		output_struct->data.address16.resource_source.string_length = index + 1;
 
 		/*
-		 * In order for the Struct_size to fall on a 32-bit boundary,
+		 * In order for the struct_size to fall on a 32-bit boundary,
 		 * calculate the length of the string and expand the
-		 * Struct_size to the next 32-bit boundary.
+		 * struct_size to the next 32-bit boundary.
 		 */
 		temp8 = (u8) (index + 1);
-		struct_size += ROUND_UP_TO_32_bITS (temp8);
+		struct_size += ACPI_ROUND_UP_to_32_bITS (temp8);
 	}
-
 	else {
 		output_struct->data.address16.resource_source.index = 0x00;
 		output_struct->data.address16.resource_source.string_length = 0;
@@ -245,7 +253,7 @@ acpi_rs_address16_resource (
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -257,13 +265,12 @@ acpi_rs_address16_resource (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_address16_stream
+ * FUNCTION:    acpi_rs_address16_stream
  *
- * PARAMETERS:  Linked_list             - Pointer to the resource linked list
- *              Output_buffer           - Pointer to the user's return buffer
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes of the
- *                                        Output_buffer used
+ * PARAMETERS:  linked_list             - Pointer to the resource linked list
+ *              output_buffer           - Pointer to the user's return buffer
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        used in the output_buffer is returned
  *
  * RETURN:      Status
  *
@@ -274,18 +281,18 @@ acpi_rs_address16_resource (
 
 acpi_status
 acpi_rs_address16_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed)
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed)
 {
-	u8                      *buffer = *output_buffer;
-	u8                      *length_field;
-	u8                      temp8;
-	NATIVE_CHAR             *temp_pointer = NULL;
-	u32                     actual_bytes;
+	u8                              *buffer = *output_buffer;
+	u8                              *length_field;
+	u8                              temp8;
+	char                            *temp_pointer = NULL;
+	acpi_size                       actual_bytes;
 
 
-	FUNCTION_TRACE ("Rs_address16_stream");
+	ACPI_FUNCTION_TRACE ("rs_address16_stream");
 
 
 	/*
@@ -301,7 +308,7 @@ acpi_rs_address16_stream (
 	buffer += 2;
 
 	/*
-	 * Set the Resource Type (Memory, Io, Bus_number)
+	 * Set the Resource Type (Memory, Io, bus_number)
 	 */
 	temp8 = (u8) (linked_list->data.address16.resource_type & 0x03);
 	*buffer = temp8;
@@ -324,7 +331,7 @@ acpi_rs_address16_stream (
 	 */
 	temp8 = 0;
 
-	if (MEMORY_RANGE == linked_list->data.address16.resource_type) {
+	if (ACPI_MEMORY_RANGE == linked_list->data.address16.resource_type) {
 		temp8 = (u8)
 			(linked_list->data.address16.attribute.memory.read_write_attribute &
 			 0x01);
@@ -333,11 +340,13 @@ acpi_rs_address16_stream (
 			(linked_list->data.address16.attribute.memory.cache_attribute &
 			 0x0F) << 1;
 	}
-
-	else if (IO_RANGE == linked_list->data.address16.resource_type) {
+	else if (ACPI_IO_RANGE == linked_list->data.address16.resource_type) {
 		temp8 = (u8)
 			(linked_list->data.address16.attribute.io.range_attribute &
 			 0x03);
+		temp8 |=
+			(linked_list->data.address16.attribute.io.translation_attribute &
+			 0x03) << 4;
 	}
 
 	*buffer = temp8;
@@ -346,36 +355,31 @@ acpi_rs_address16_stream (
 	/*
 	 * Set the address space granularity
 	 */
-	MOVE_UNALIGNED16_TO_16 (buffer,
-			   &linked_list->data.address16.granularity);
+	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.address16.granularity);
 	buffer += 2;
 
 	/*
 	 * Set the address range minimum
 	 */
-	MOVE_UNALIGNED16_TO_16 (buffer,
-			   &linked_list->data.address16.min_address_range);
+	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.address16.min_address_range);
 	buffer += 2;
 
 	/*
 	 * Set the address range maximum
 	 */
-	MOVE_UNALIGNED16_TO_16 (buffer,
-			   &linked_list->data.address16.max_address_range);
+	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.address16.max_address_range);
 	buffer += 2;
 
 	/*
 	 * Set the address translation offset
 	 */
-	MOVE_UNALIGNED16_TO_16 (buffer,
-			   &linked_list->data.address16.address_translation_offset);
+	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.address16.address_translation_offset);
 	buffer += 2;
 
 	/*
 	 * Set the address length
 	 */
-	MOVE_UNALIGNED16_TO_16 (buffer,
-			   &linked_list->data.address16.address_length);
+	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.address16.address_length);
 	buffer += 2;
 
 	/*
@@ -387,26 +391,25 @@ acpi_rs_address16_stream (
 		*buffer = temp8;
 		buffer += 1;
 
-		temp_pointer = (NATIVE_CHAR *) buffer;
+		temp_pointer = (char *) buffer;
 
 		/*
 		 * Copy the string
 		 */
-		STRCPY (temp_pointer,
+		ACPI_STRCPY (temp_pointer,
 				linked_list->data.address16.resource_source.string_ptr);
 
 		/*
 		 * Buffer needs to be set to the length of the sting + one for the
 		 *  terminating null
 		 */
-		buffer += (STRLEN (linked_list->data.address16.resource_source.string_ptr)
-				 + 1);
+		buffer += (acpi_size)(ACPI_STRLEN (linked_list->data.address16.resource_source.string_ptr) + 1);
 	}
 
 	/*
 	 * Return the number of bytes consumed in this operation
 	 */
-	actual_bytes = POINTER_DIFF (buffer, *output_buffer);
+	actual_bytes = ACPI_PTR_DIFF (buffer, *output_buffer);
 	*bytes_consumed = actual_bytes;
 
 	/*
@@ -414,63 +417,59 @@ acpi_rs_address16_stream (
 	 * minus the header size (3 bytes)
 	 */
 	actual_bytes -= 3;
-	MOVE_UNALIGNED16_TO_16 (length_field, &actual_bytes);
+	ACPI_MOVE_SIZE_TO_16 (length_field, &actual_bytes);
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_address32_resource
+ * FUNCTION:    acpi_rs_address32_resource
  *
- * PARAMETERS:  Byte_stream_buffer      - Pointer to the resource input byte
+ * PARAMETERS:  byte_stream_buffer      - Pointer to the resource input byte
  *                                        stream
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes consumed from
- *                                        the Byte_stream_buffer
- *              Output_buffer           - Pointer to the user's return buffer
- *              Structure_size          - u32 pointer that is filled with
- *                                        the number of bytes in the filled
- *                                        in structure
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        consumed the byte_stream_buffer is
+ *                                        returned
+ *              output_buffer           - Pointer to the return data buffer
+ *              structure_size          - Pointer to where the number of bytes
+ *                                        in the return data struct is returned
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Take the resource byte stream and fill out the appropriate
- *              structure pointed to by the Output_buffer. Return the
+ *              structure pointed to by the output_buffer. Return the
  *              number of bytes consumed from the byte stream.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_rs_address32_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size)
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size)
 {
-	u8                      *buffer;
-	acpi_resource           *output_struct;
-	u16                     temp16;
-	u8                      temp8;
-	NATIVE_CHAR             *temp_ptr;
-	u32                     struct_size;
-	u32                     index;
+	u8                              *buffer;
+	struct acpi_resource            *output_struct= (void *) *output_buffer;
+	u16                             temp16;
+	u8                              temp8;
+	u8                              *temp_ptr;
+	acpi_size                       struct_size;
+	u32                             index;
 
 
-	FUNCTION_TRACE ("Rs_address32_resource");
+	ACPI_FUNCTION_TRACE ("rs_address32_resource");
 
 
 	buffer = byte_stream_buffer;
-	output_struct = (acpi_resource *) *output_buffer;
-
-	struct_size = SIZEOF_RESOURCE (acpi_resource_address32);
+	struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_address32);
 
 	/*
 	 * Point past the Descriptor to get the number of bytes consumed
 	 */
 	buffer += 1;
-	MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
-
+	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 	*bytes_consumed = temp16 + 3;
 
 	output_struct->id = ACPI_RSTYPE_ADDRESS32;
@@ -520,22 +519,22 @@ acpi_rs_address32_resource (
 	buffer += 1;
 	temp8 = *buffer;
 
-	if (MEMORY_RANGE == output_struct->data.address32.resource_type) {
+	if (ACPI_MEMORY_RANGE == output_struct->data.address32.resource_type) {
 		output_struct->data.address32.attribute.memory.read_write_attribute =
 				(u16) (temp8 & 0x01);
 
 		output_struct->data.address32.attribute.memory.cache_attribute =
 				(u16) ((temp8 >> 1) & 0x0F);
 	}
-
 	else {
-		if (IO_RANGE == output_struct->data.address32.resource_type) {
+		if (ACPI_IO_RANGE == output_struct->data.address32.resource_type) {
 			output_struct->data.address32.attribute.io.range_attribute =
 				(u16) (temp8 & 0x03);
+			output_struct->data.address32.attribute.io.translation_attribute =
+				(u16) ((temp8 >> 4) & 0x03);
 		}
-
 		else {
-			/* BUS_NUMBER_RANGE == Output_struct->Data.Address32.Resource_type */
+			/* BUS_NUMBER_RANGE == output_struct->Data.Address32.resource_type */
 			/* Nothing needs to be filled in */
 		}
 	}
@@ -544,36 +543,31 @@ acpi_rs_address32_resource (
 	 * Get Granularity (Bytes 6-9)
 	 */
 	buffer += 1;
-	MOVE_UNALIGNED32_TO_32 (&output_struct->data.address32.granularity,
-			 buffer);
+	ACPI_MOVE_32_TO_32 (&output_struct->data.address32.granularity, buffer);
 
 	/*
-	 * Get Min_address_range (Bytes 10-13)
+	 * Get min_address_range (Bytes 10-13)
 	 */
 	buffer += 4;
-	MOVE_UNALIGNED32_TO_32 (&output_struct->data.address32.min_address_range,
-			 buffer);
+	ACPI_MOVE_32_TO_32 (&output_struct->data.address32.min_address_range, buffer);
 
 	/*
-	 * Get Max_address_range (Bytes 14-17)
+	 * Get max_address_range (Bytes 14-17)
 	 */
 	buffer += 4;
-	MOVE_UNALIGNED32_TO_32 (&output_struct->data.address32.max_address_range,
-			 buffer);
+	ACPI_MOVE_32_TO_32 (&output_struct->data.address32.max_address_range, buffer);
 
 	/*
-	 * Get Address_translation_offset (Bytes 18-21)
+	 * Get address_translation_offset (Bytes 18-21)
 	 */
 	buffer += 4;
-	MOVE_UNALIGNED32_TO_32 (&output_struct->data.address32.address_translation_offset,
-			 buffer);
+	ACPI_MOVE_32_TO_32 (&output_struct->data.address32.address_translation_offset, buffer);
 
 	/*
-	 * Get Address_length (Bytes 22-25)
+	 * Get address_length (Bytes 22-25)
 	 */
 	buffer += 4;
-	MOVE_UNALIGNED32_TO_32 (&output_struct->data.address32.address_length,
-			 buffer);
+	ACPI_MOVE_32_TO_32 (&output_struct->data.address32.address_length, buffer);
 
 	/*
 	 * Resource Source Index (if present)
@@ -599,14 +593,13 @@ acpi_rs_address32_resource (
 		/* Point the String pointer to the end of this structure */
 
 		output_struct->data.address32.resource_source.string_ptr =
-				(NATIVE_CHAR *)((u8 *)output_struct + struct_size);
+				(char *)((u8 *)output_struct + struct_size);
 
-		temp_ptr = output_struct->data.address32.resource_source.string_ptr;
+		temp_ptr = (u8 *) output_struct->data.address32.resource_source.string_ptr;
 
 		/* Copy the string into the buffer */
 
 		index = 0;
-
 		while (0x00 != *buffer) {
 			*temp_ptr = *buffer;
 
@@ -622,14 +615,13 @@ acpi_rs_address32_resource (
 		output_struct->data.address32.resource_source.string_length = index + 1;
 
 		/*
-		 * In order for the Struct_size to fall on a 32-bit boundary,
+		 * In order for the struct_size to fall on a 32-bit boundary,
 		 *  calculate the length of the string and expand the
-		 *  Struct_size to the next 32-bit boundary.
+		 *  struct_size to the next 32-bit boundary.
 		 */
 		temp8 = (u8) (index + 1);
-		struct_size += ROUND_UP_TO_32_bITS (temp8);
+		struct_size += ACPI_ROUND_UP_to_32_bITS (temp8);
 	}
-
 	else {
 		output_struct->data.address32.resource_source.index = 0x00;
 		output_struct->data.address32.resource_source.string_length = 0;
@@ -639,7 +631,7 @@ acpi_rs_address32_resource (
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -651,13 +643,12 @@ acpi_rs_address32_resource (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_address32_stream
+ * FUNCTION:    acpi_rs_address32_stream
  *
- * PARAMETERS:  Linked_list             - Pointer to the resource linked list
- *              Output_buffer           - Pointer to the user's return buffer
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes of the
- *                                        Output_buffer used
+ * PARAMETERS:  linked_list             - Pointer to the resource linked list
+ *              output_buffer           - Pointer to the user's return buffer
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        used in the output_buffer is returned
  *
  * RETURN:      Status
  *
@@ -668,17 +659,17 @@ acpi_rs_address32_resource (
 
 acpi_status
 acpi_rs_address32_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed)
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed)
 {
-	u8                      *buffer;
-	u16                     *length_field;
-	u8                      temp8;
-	NATIVE_CHAR             *temp_pointer;
+	u8                              *buffer;
+	u16                             *length_field;
+	u8                              temp8;
+	char                            *temp_pointer;
 
 
-	FUNCTION_TRACE ("Rs_address32_stream");
+	ACPI_FUNCTION_TRACE ("rs_address32_stream");
 
 
 	buffer = *output_buffer;
@@ -692,12 +683,11 @@ acpi_rs_address32_stream (
 	/*
 	 * Set a pointer to the Length field - to be filled in later
 	 */
-
-	length_field = (u16 *) buffer;
+	length_field = ACPI_CAST_PTR (u16, buffer);
 	buffer += 2;
 
 	/*
-	 * Set the Resource Type (Memory, Io, Bus_number)
+	 * Set the Resource Type (Memory, Io, bus_number)
 	 */
 	temp8 = (u8) (linked_list->data.address32.resource_type & 0x03);
 
@@ -720,7 +710,7 @@ acpi_rs_address32_stream (
 	 */
 	temp8 = 0;
 
-	if(MEMORY_RANGE == linked_list->data.address32.resource_type) {
+	if (ACPI_MEMORY_RANGE == linked_list->data.address32.resource_type) {
 		temp8 = (u8)
 			(linked_list->data.address32.attribute.memory.read_write_attribute &
 			0x01);
@@ -729,11 +719,13 @@ acpi_rs_address32_stream (
 			(linked_list->data.address32.attribute.memory.cache_attribute &
 			 0x0F) << 1;
 	}
-
-	else if (IO_RANGE == linked_list->data.address32.resource_type) {
+	else if (ACPI_IO_RANGE == linked_list->data.address32.resource_type) {
 		temp8 = (u8)
 			(linked_list->data.address32.attribute.io.range_attribute &
 			 0x03);
+		temp8 |=
+			(linked_list->data.address32.attribute.io.translation_attribute &
+			 0x03) << 4;
 	}
 
 	*buffer = temp8;
@@ -742,36 +734,31 @@ acpi_rs_address32_stream (
 	/*
 	 * Set the address space granularity
 	 */
-	MOVE_UNALIGNED32_TO_32 (buffer,
-			  &linked_list->data.address32.granularity);
+	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.address32.granularity);
 	buffer += 4;
 
 	/*
 	 * Set the address range minimum
 	 */
-	MOVE_UNALIGNED32_TO_32 (buffer,
-			  &linked_list->data.address32.min_address_range);
+	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.address32.min_address_range);
 	buffer += 4;
 
 	/*
 	 * Set the address range maximum
 	 */
-	MOVE_UNALIGNED32_TO_32 (buffer,
-			  &linked_list->data.address32.max_address_range);
+	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.address32.max_address_range);
 	buffer += 4;
 
 	/*
 	 * Set the address translation offset
 	 */
-	MOVE_UNALIGNED32_TO_32 (buffer,
-			  &linked_list->data.address32.address_translation_offset);
+	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.address32.address_translation_offset);
 	buffer += 4;
 
 	/*
 	 * Set the address length
 	 */
-	MOVE_UNALIGNED32_TO_32 (buffer,
-			  &linked_list->data.address32.address_length);
+	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.address32.address_length);
 	buffer += 4;
 
 	/*
@@ -783,25 +770,25 @@ acpi_rs_address32_stream (
 		*buffer = temp8;
 		buffer += 1;
 
-		temp_pointer = (NATIVE_CHAR *) buffer;
+		temp_pointer = (char *) buffer;
 
 		/*
 		 * Copy the string
 		 */
-		STRCPY (temp_pointer,
+		ACPI_STRCPY (temp_pointer,
 			linked_list->data.address32.resource_source.string_ptr);
 
 		/*
 		 * Buffer needs to be set to the length of the sting + one for the
 		 *  terminating null
 		 */
-		buffer += (STRLEN (linked_list->data.address32.resource_source.string_ptr) + 1);
+		buffer += (acpi_size)(ACPI_STRLEN (linked_list->data.address32.resource_source.string_ptr) + 1);
 	}
 
 	/*
 	 * Return the number of bytes consumed in this operation
 	 */
-	*bytes_consumed = POINTER_DIFF (buffer, *output_buffer);
+	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 
 	/*
 	 * Set the length field to the number of bytes consumed
@@ -814,55 +801,52 @@ acpi_rs_address32_stream (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_address64_resource
+ * FUNCTION:    acpi_rs_address64_resource
  *
- * PARAMETERS:  Byte_stream_buffer      - Pointer to the resource input byte
+ * PARAMETERS:  byte_stream_buffer      - Pointer to the resource input byte
  *                                        stream
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes consumed from
- *                                        the Byte_stream_buffer
- *              Output_buffer           - Pointer to the user's return buffer
- *              Structure_size          - u32 pointer that is filled with
- *                                        the number of bytes in the filled
- *                                        in structure
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        consumed the byte_stream_buffer is
+ *                                        returned
+ *              output_buffer           - Pointer to the return data buffer
+ *              structure_size          - Pointer to where the number of bytes
+ *                                        in the return data struct is returned
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Take the resource byte stream and fill out the appropriate
- *              structure pointed to by the Output_buffer. Return the
+ *              structure pointed to by the output_buffer. Return the
  *              number of bytes consumed from the byte stream.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_rs_address64_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size)
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size)
 {
-	u8                      *buffer;
-	acpi_resource           *output_struct;
-	u16                     temp16;
-	u8                      temp8;
-	NATIVE_CHAR             *temp_ptr;
-	u32                     struct_size;
-	u32                     index;
+	u8                              *buffer;
+	struct acpi_resource            *output_struct = (void *) *output_buffer;
+	u16                             temp16;
+	u8                              temp8;
+	u8                              *temp_ptr;
+	acpi_size                       struct_size;
+	u32                             index;
 
 
-	FUNCTION_TRACE ("Rs_address64_resource");
+	ACPI_FUNCTION_TRACE ("rs_address64_resource");
 
 
 	buffer = byte_stream_buffer;
-	output_struct = (acpi_resource *) *output_buffer;
-
-	struct_size = SIZEOF_RESOURCE (acpi_resource_address64);
+	struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_address64);
 
 	/*
 	 * Point past the Descriptor to get the number of bytes consumed
 	 */
 	buffer += 1;
-	MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
+	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
 	*bytes_consumed = temp16 + 3;
 	output_struct->id = ACPI_RSTYPE_ADDRESS64;
@@ -874,6 +858,7 @@ acpi_rs_address64_resource (
 	temp8 = *buffer;
 
 	/* Values 0-2 are valid */
+
 	if(temp8 > 2) {
 		return_ACPI_STATUS (AE_AML_INVALID_RESOURCE_TYPE);
 	}
@@ -912,22 +897,22 @@ acpi_rs_address64_resource (
 	buffer += 1;
 	temp8 = *buffer;
 
-	if (MEMORY_RANGE == output_struct->data.address64.resource_type) {
+	if (ACPI_MEMORY_RANGE == output_struct->data.address64.resource_type) {
 		output_struct->data.address64.attribute.memory.read_write_attribute =
 				(u16) (temp8 & 0x01);
 
 		output_struct->data.address64.attribute.memory.cache_attribute =
 				(u16) ((temp8 >> 1) & 0x0F);
 	}
-
 	else {
-		if (IO_RANGE == output_struct->data.address64.resource_type) {
+		if (ACPI_IO_RANGE == output_struct->data.address64.resource_type) {
 			output_struct->data.address64.attribute.io.range_attribute =
 				(u16) (temp8 & 0x03);
+			output_struct->data.address64.attribute.io.translation_attribute =
+				(u16) ((temp8 >> 4) & 0x03);
 		}
-
 		else {
-			/* BUS_NUMBER_RANGE == Output_struct->Data.Address64.Resource_type */
+			/* BUS_NUMBER_RANGE == output_struct->Data.Address64.resource_type */
 			/* Nothing needs to be filled in */
 		}
 	}
@@ -936,36 +921,31 @@ acpi_rs_address64_resource (
 	 * Get Granularity (Bytes 6-13)
 	 */
 	buffer += 1;
-	MOVE_UNALIGNED64_TO_64 (&output_struct->data.address64.granularity,
-			 buffer);
+	ACPI_MOVE_64_TO_64 (&output_struct->data.address64.granularity, buffer);
 
 	/*
-	 * Get Min_address_range (Bytes 14-21)
+	 * Get min_address_range (Bytes 14-21)
 	 */
 	buffer += 8;
-	MOVE_UNALIGNED64_TO_64 (&output_struct->data.address64.min_address_range,
-			 buffer);
+	ACPI_MOVE_64_TO_64 (&output_struct->data.address64.min_address_range, buffer);
 
 	/*
-	 * Get Max_address_range (Bytes 22-29)
+	 * Get max_address_range (Bytes 22-29)
 	 */
 	buffer += 8;
-	MOVE_UNALIGNED64_TO_64 (&output_struct->data.address64.max_address_range,
-			 buffer);
+	ACPI_MOVE_64_TO_64 (&output_struct->data.address64.max_address_range, buffer);
 
 	/*
-	 * Get Address_translation_offset (Bytes 30-37)
+	 * Get address_translation_offset (Bytes 30-37)
 	 */
 	buffer += 8;
-	MOVE_UNALIGNED64_TO_64 (&output_struct->data.address64.address_translation_offset,
-			 buffer);
+	ACPI_MOVE_64_TO_64 (&output_struct->data.address64.address_translation_offset, buffer);
 
 	/*
-	 * Get Address_length (Bytes 38-45)
+	 * Get address_length (Bytes 38-45)
 	 */
 	buffer += 8;
-	MOVE_UNALIGNED64_TO_64 (&output_struct->data.address64.address_length,
-			 buffer);
+	ACPI_MOVE_64_TO_64 (&output_struct->data.address64.address_length, buffer);
 
 	/*
 	 * Resource Source Index (if present)
@@ -993,14 +973,13 @@ acpi_rs_address64_resource (
 		/* Point the String pointer to the end of this structure */
 
 		output_struct->data.address64.resource_source.string_ptr =
-				(NATIVE_CHAR *)((u8 *)output_struct + struct_size);
+				(char *)((u8 *)output_struct + struct_size);
 
-		temp_ptr = output_struct->data.address64.resource_source.string_ptr;
+		temp_ptr = (u8 *) output_struct->data.address64.resource_source.string_ptr;
 
 		/* Copy the string into the buffer */
 
 		index = 0;
-
 		while (0x00 != *buffer) {
 			*temp_ptr = *buffer;
 
@@ -1017,14 +996,13 @@ acpi_rs_address64_resource (
 		output_struct->data.address64.resource_source.string_length = index + 1;
 
 		/*
-		 * In order for the Struct_size to fall on a 32-bit boundary,
+		 * In order for the struct_size to fall on a 32-bit boundary,
 		 * calculate the length of the string and expand the
-		 * Struct_size to the next 32-bit boundary.
+		 * struct_size to the next 32-bit boundary.
 		 */
 		temp8 = (u8) (index + 1);
-		struct_size += ROUND_UP_TO_32_bITS (temp8);
+		struct_size += ACPI_ROUND_UP_to_32_bITS (temp8);
 	}
-
 	else {
 		output_struct->data.address64.resource_source.index = 0x00;
 		output_struct->data.address64.resource_source.string_length = 0;
@@ -1034,7 +1012,7 @@ acpi_rs_address64_resource (
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -1046,13 +1024,12 @@ acpi_rs_address64_resource (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_address64_stream
+ * FUNCTION:    acpi_rs_address64_stream
  *
- * PARAMETERS:  Linked_list             - Pointer to the resource linked list
- *              Output_buffer           - Pointer to the user's return buffer
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes of the
- *                                        Output_buffer used
+ * PARAMETERS:  linked_list             - Pointer to the resource linked list
+ *              output_buffer           - Pointer to the user's return buffer
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        used in the output_buffer is returned
  *
  * RETURN:      Status
  *
@@ -1063,17 +1040,17 @@ acpi_rs_address64_resource (
 
 acpi_status
 acpi_rs_address64_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed)
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed)
 {
-	u8                      *buffer;
-	u16                     *length_field;
-	u8                      temp8;
-	NATIVE_CHAR             *temp_pointer;
+	u8                              *buffer;
+	u16                             *length_field;
+	u8                              temp8;
+	char                            *temp_pointer;
 
 
-	FUNCTION_TRACE ("Rs_address64_stream");
+	ACPI_FUNCTION_TRACE ("rs_address64_stream");
 
 
 	buffer = *output_buffer;
@@ -1088,11 +1065,11 @@ acpi_rs_address64_stream (
 	 * Set a pointer to the Length field - to be filled in later
 	 */
 
-	length_field = (u16 *)buffer;
+	length_field = ACPI_CAST_PTR (u16, buffer);
 	buffer += 2;
 
 	/*
-	 * Set the Resource Type (Memory, Io, Bus_number)
+	 * Set the Resource Type (Memory, Io, bus_number)
 	 */
 	temp8 = (u8) (linked_list->data.address64.resource_type & 0x03);
 
@@ -1115,7 +1092,7 @@ acpi_rs_address64_stream (
 	 */
 	temp8 = 0;
 
-	if(MEMORY_RANGE == linked_list->data.address64.resource_type) {
+	if (ACPI_MEMORY_RANGE == linked_list->data.address64.resource_type) {
 		temp8 = (u8)
 			(linked_list->data.address64.attribute.memory.read_write_attribute &
 			0x01);
@@ -1124,11 +1101,13 @@ acpi_rs_address64_stream (
 			(linked_list->data.address64.attribute.memory.cache_attribute &
 			 0x0F) << 1;
 	}
-
-	else if (IO_RANGE == linked_list->data.address64.resource_type) {
+	else if (ACPI_IO_RANGE == linked_list->data.address64.resource_type) {
 		temp8 = (u8)
 			(linked_list->data.address64.attribute.io.range_attribute &
 			 0x03);
+		temp8 |=
+			(linked_list->data.address64.attribute.io.range_attribute &
+			 0x03) << 4;
 	}
 
 	*buffer = temp8;
@@ -1137,36 +1116,31 @@ acpi_rs_address64_stream (
 	/*
 	 * Set the address space granularity
 	 */
-	MOVE_UNALIGNED64_TO_64 (buffer,
-			   &linked_list->data.address64.granularity);
+	ACPI_MOVE_64_TO_64 (buffer, &linked_list->data.address64.granularity);
 	buffer += 8;
 
 	/*
 	 * Set the address range minimum
 	 */
-	MOVE_UNALIGNED64_TO_64 (buffer,
-			   &linked_list->data.address64.min_address_range);
+	ACPI_MOVE_64_TO_64 (buffer, &linked_list->data.address64.min_address_range);
 	buffer += 8;
 
 	/*
 	 * Set the address range maximum
 	 */
-	MOVE_UNALIGNED64_TO_64 (buffer,
-			   &linked_list->data.address64.max_address_range);
+	ACPI_MOVE_64_TO_64 (buffer, &linked_list->data.address64.max_address_range);
 	buffer += 8;
 
 	/*
 	 * Set the address translation offset
 	 */
-	MOVE_UNALIGNED64_TO_64 (buffer,
-			   &linked_list->data.address64.address_translation_offset);
+	ACPI_MOVE_64_TO_64 (buffer, &linked_list->data.address64.address_translation_offset);
 	buffer += 8;
 
 	/*
 	 * Set the address length
 	 */
-	MOVE_UNALIGNED64_TO_64 (buffer,
-			   &linked_list->data.address64.address_length);
+	ACPI_MOVE_64_TO_64 (buffer, &linked_list->data.address64.address_length);
 	buffer += 8;
 
 	/*
@@ -1178,24 +1152,24 @@ acpi_rs_address64_stream (
 		*buffer = temp8;
 		buffer += 1;
 
-		temp_pointer = (NATIVE_CHAR *) buffer;
+		temp_pointer = (char *) buffer;
 
 		/*
 		 * Copy the string
 		 */
-		STRCPY (temp_pointer, linked_list->data.address64.resource_source.string_ptr);
+		ACPI_STRCPY (temp_pointer, linked_list->data.address64.resource_source.string_ptr);
 
 		/*
 		 * Buffer needs to be set to the length of the sting + one for the
 		 *  terminating null
 		 */
-		buffer += (STRLEN (linked_list->data.address64.resource_source.string_ptr) + 1);
+		buffer += (acpi_size)(ACPI_STRLEN (linked_list->data.address64.resource_source.string_ptr) + 1);
 	}
 
 	/*
 	 * Return the number of bytes consumed in this operation
 	 */
-	*bytes_consumed = POINTER_DIFF (buffer, *output_buffer);
+	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 
 	/*
 	 * Set the length field to the number of bytes consumed
diff -urNp linux-5400/drivers/acpi/resources/rscalc.c linux-5410/drivers/acpi/resources/rscalc.c
--- linux-5400/drivers/acpi/resources/rscalc.c
+++ linux-5410/drivers/acpi/resources/rscalc.c
@@ -1,44 +1,62 @@
 /*******************************************************************************
  *
  * Module Name: rscalc - Calculate stream and list lengths
- *              $Revision: 32 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acresrc.h"
-#include "amlcode.h"
-#include "acnamesp.h"
+#include <acpi/acpi.h>
+#include <acpi/acresrc.h>
+#include <acpi/amlcode.h>
+#include <acpi/acnamesp.h>
 
 #define _COMPONENT          ACPI_RESOURCES
-	 MODULE_NAME         ("rscalc")
+	 ACPI_MODULE_NAME    ("rscalc")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_calculate_byte_stream_length
+ * FUNCTION:    acpi_rs_get_byte_stream_length
  *
- * PARAMETERS:  Linked_list         - Pointer to the resource linked list
- *              Size_needed         - u32 pointer of the size buffer needed
+ * PARAMETERS:  linked_list         - Pointer to the resource linked list
+ *              size_needed         - u32 pointer of the size buffer needed
  *                                    to properly return the parsed data
  *
  * RETURN:      Status
@@ -50,17 +68,17 @@
  ******************************************************************************/
 
 acpi_status
-acpi_rs_calculate_byte_stream_length (
-	acpi_resource           *linked_list,
-	u32                     *size_needed)
+acpi_rs_get_byte_stream_length (
+	struct acpi_resource            *linked_list,
+	acpi_size                       *size_needed)
 {
-	u32                     byte_stream_size_needed = 0;
-	u32                     segment_size;
-	acpi_resource_ext_irq   *ex_irq = NULL;
-	u8                      done = FALSE;
+	acpi_size                       byte_stream_size_needed = 0;
+	acpi_size                       segment_size;
+	struct acpi_resource_ext_irq    *ex_irq = NULL;
+	u8                              done = FALSE;
 
 
-	FUNCTION_TRACE ("Rs_calculate_byte_stream_length");
+	ACPI_FUNCTION_TRACE ("rs_get_byte_stream_length");
 
 
 	while (!done) {
@@ -90,7 +108,7 @@ acpi_rs_calculate_byte_stream_length (
 		case ACPI_RSTYPE_START_DPF:
 			/*
 			 * Start Dependent Functions Resource
-			 * For a Start_dependent_functions Resource, Byte 1,
+			 * For a start_dependent_functions Resource, Byte 1,
 			 * although optional, will always be created.
 			 */
 			segment_size = 2;
@@ -180,9 +198,9 @@ acpi_rs_calculate_byte_stream_length (
 			 */
 			segment_size = 16;
 
-			if (NULL != linked_list->data.address16.resource_source.string_ptr) {
-				segment_size += (1 +
-					linked_list->data.address16.resource_source.string_length);
+			if (linked_list->data.address16.resource_source.string_ptr) {
+				segment_size += linked_list->data.address16.resource_source.string_length;
+				segment_size++;
 			}
 			break;
 
@@ -196,9 +214,9 @@ acpi_rs_calculate_byte_stream_length (
 			 */
 			segment_size = 26;
 
-			if (NULL != linked_list->data.address32.resource_source.string_ptr) {
-				segment_size += (1 +
-					linked_list->data.address32.resource_source.string_length);
+			if (linked_list->data.address32.resource_source.string_ptr) {
+				segment_size += linked_list->data.address32.resource_source.string_length;
+				segment_size++;
 			}
 			break;
 
@@ -212,9 +230,9 @@ acpi_rs_calculate_byte_stream_length (
 			 */
 			segment_size = 46;
 
-			if (NULL != linked_list->data.address64.resource_source.string_ptr) {
-				segment_size += (1 +
-					linked_list->data.address64.resource_source.string_length);
+			if (linked_list->data.address64.resource_source.string_ptr) {
+				segment_size += linked_list->data.address64.resource_source.string_length;
+				segment_size++;
 			}
 			break;
 
@@ -229,11 +247,11 @@ acpi_rs_calculate_byte_stream_length (
 			 * Resource Source + 1 for the null.
 			 */
 			segment_size = 9 +
-				((linked_list->data.extended_irq.number_of_interrupts - 1) * 4);
+				(((acpi_size) linked_list->data.extended_irq.number_of_interrupts - 1) * 4);
 
-			if (NULL != ex_irq->resource_source.string_ptr) {
-				segment_size += (1 +
-					linked_list->data.extended_irq.resource_source.string_length);
+			if (ex_irq && ex_irq->resource_source.string_ptr) {
+				segment_size += linked_list->data.extended_irq.resource_source.string_length;
+				segment_size++;
 			}
 			break;
 
@@ -243,9 +261,8 @@ acpi_rs_calculate_byte_stream_length (
 			 * so exit with an error
 			 */
 			return_ACPI_STATUS (AE_AML_INVALID_RESOURCE_TYPE);
-			break;
 
-		} /* switch (Linked_list->Id) */
+		} /* switch (linked_list->Id) */
 
 		/*
 		 * Update the total
@@ -255,7 +272,7 @@ acpi_rs_calculate_byte_stream_length (
 		/*
 		 * Point to the next object
 		 */
-		linked_list = POINTER_ADD (acpi_resource,
+		linked_list = ACPI_PTR_ADD (struct acpi_resource,
 				  linked_list, linked_list->length);
 	}
 
@@ -269,11 +286,11 @@ acpi_rs_calculate_byte_stream_length (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_calculate_list_length
+ * FUNCTION:    acpi_rs_get_list_length
  *
- * PARAMETERS:  Byte_stream_buffer      - Pointer to the resource byte stream
- *              Byte_stream_buffer_length - Size of Byte_stream_buffer
- *              Size_needed             - u32 pointer of the size buffer
+ * PARAMETERS:  byte_stream_buffer      - Pointer to the resource byte stream
+ *              byte_stream_buffer_length - Size of byte_stream_buffer
+ *              size_needed             - u32 pointer of the size buffer
  *                                        needed to properly return the
  *                                        parsed data
  *
@@ -286,26 +303,26 @@ acpi_rs_calculate_byte_stream_length (
  ******************************************************************************/
 
 acpi_status
-acpi_rs_calculate_list_length (
-	u8                      *byte_stream_buffer,
-	u32                     byte_stream_buffer_length,
-	u32                     *size_needed)
+acpi_rs_get_list_length (
+	u8                              *byte_stream_buffer,
+	u32                             byte_stream_buffer_length,
+	acpi_size                       *size_needed)
 {
-	u32                     buffer_size = 0;
-	u32                     bytes_parsed = 0;
-	u8                      number_of_interrupts = 0;
-	u8                      number_of_channels = 0;
-	u8                      resource_type;
-	u32                     structure_size;
-	u32                     bytes_consumed;
-	u8                      *buffer;
-	u8                      temp8;
-	u16                     temp16;
-	u8                      index;
-	u8                      additional_bytes;
+	u32                             buffer_size = 0;
+	u32                             bytes_parsed = 0;
+	u8                              number_of_interrupts = 0;
+	u8                              number_of_channels = 0;
+	u8                              resource_type;
+	u32                             structure_size;
+	u32                             bytes_consumed;
+	u8                              *buffer;
+	u8                              temp8;
+	u16                             temp16;
+	u8                              index;
+	u8                              additional_bytes;
 
 
-	FUNCTION_TRACE ("Rs_calculate_list_length");
+	ACPI_FUNCTION_TRACE ("rs_get_list_length");
 
 
 	while (bytes_parsed < byte_stream_buffer_length) {
@@ -315,65 +332,65 @@ acpi_rs_calculate_list_length (
 		resource_type = acpi_rs_get_resource_type (*byte_stream_buffer);
 
 		switch (resource_type) {
-		case RESOURCE_DESC_MEMORY_24:
+		case ACPI_RDESC_TYPE_MEMORY_24:
 			/*
 			 * 24-Bit Memory Resource
 			 */
 			bytes_consumed = 12;
 
-			structure_size = SIZEOF_RESOURCE (acpi_resource_mem24);
+			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_mem24);
 			break;
 
 
-		case RESOURCE_DESC_LARGE_VENDOR:
+		case ACPI_RDESC_TYPE_LARGE_VENDOR:
 			/*
 			 * Vendor Defined Resource
 			 */
 			buffer = byte_stream_buffer;
 			++buffer;
 
-			MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
+			ACPI_MOVE_16_TO_16 (&temp16, buffer);
 			bytes_consumed = temp16 + 3;
 
 			/*
 			 * Ensure a 32-bit boundary for the structure
 			 */
-			temp16 = (u16) ROUND_UP_TO_32_bITS (temp16);
+			temp16 = (u16) ACPI_ROUND_UP_to_32_bITS (temp16);
 
-			structure_size = SIZEOF_RESOURCE (acpi_resource_vendor) +
+			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_vendor) +
 					   (temp16 * sizeof (u8));
 			break;
 
 
-		case RESOURCE_DESC_MEMORY_32:
+		case ACPI_RDESC_TYPE_MEMORY_32:
 			/*
 			 * 32-Bit Memory Range Resource
 			 */
 
 			bytes_consumed = 20;
 
-			structure_size = SIZEOF_RESOURCE (acpi_resource_mem32);
+			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_mem32);
 			break;
 
 
-		case RESOURCE_DESC_FIXED_MEMORY_32:
+		case ACPI_RDESC_TYPE_FIXED_MEMORY_32:
 			/*
 			 * 32-Bit Fixed Memory Resource
 			 */
 			bytes_consumed = 12;
 
-			structure_size = SIZEOF_RESOURCE (acpi_resource_fixed_mem32);
+			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_fixed_mem32);
 			break;
 
 
-		case RESOURCE_DESC_QWORD_ADDRESS_SPACE:
+		case ACPI_RDESC_TYPE_QWORD_ADDRESS_SPACE:
 			/*
 			 * 64-Bit Address Resource
 			 */
 			buffer = byte_stream_buffer;
 
 			++buffer;
-			MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
+			ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
 			bytes_consumed = temp16 + 3;
 
@@ -397,21 +414,21 @@ acpi_rs_calculate_list_length (
 			/*
 			 * Ensure a 64-bit boundary for the structure
 			 */
-			temp8 = (u8) ROUND_UP_TO_64_bITS (temp8);
+			temp8 = (u8) ACPI_ROUND_UP_to_64_bITS (temp8);
 
-			structure_size = SIZEOF_RESOURCE (acpi_resource_address64) +
+			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_address64) +
 					   (temp8 * sizeof (u8));
 			break;
 
 
-		case RESOURCE_DESC_DWORD_ADDRESS_SPACE:
+		case ACPI_RDESC_TYPE_DWORD_ADDRESS_SPACE:
 			/*
 			 * 32-Bit Address Resource
 			 */
 			buffer = byte_stream_buffer;
 
 			++buffer;
-			MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
+			ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
 			bytes_consumed = temp16 + 3;
 
@@ -435,21 +452,21 @@ acpi_rs_calculate_list_length (
 			/*
 			 * Ensure a 32-bit boundary for the structure
 			 */
-			temp8 = (u8) ROUND_UP_TO_32_bITS (temp8);
+			temp8 = (u8) ACPI_ROUND_UP_to_32_bITS (temp8);
 
-			structure_size = SIZEOF_RESOURCE (acpi_resource_address32) +
+			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_address32) +
 					   (temp8 * sizeof (u8));
 			break;
 
 
-		case RESOURCE_DESC_WORD_ADDRESS_SPACE:
+		case ACPI_RDESC_TYPE_WORD_ADDRESS_SPACE:
 			/*
 			 * 16-Bit Address Resource
 			 */
 			buffer = byte_stream_buffer;
 
 			++buffer;
-			MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
+			ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
 			bytes_consumed = temp16 + 3;
 
@@ -473,21 +490,21 @@ acpi_rs_calculate_list_length (
 			/*
 			 * Ensure a 32-bit boundary for the structure
 			 */
-			temp8 = (u8) ROUND_UP_TO_32_bITS (temp8);
+			temp8 = (u8) ACPI_ROUND_UP_to_32_bITS (temp8);
 
-			structure_size = SIZEOF_RESOURCE (acpi_resource_address16) +
+			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_address16) +
 					   (temp8 * sizeof (u8));
 			break;
 
 
-		case RESOURCE_DESC_EXTENDED_XRUPT:
+		case ACPI_RDESC_TYPE_EXTENDED_XRUPT:
 			/*
 			 * Extended IRQ
 			 */
 			buffer = byte_stream_buffer;
 
 			++buffer;
-			MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
+			ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
 			bytes_consumed = temp16 + 3;
 
@@ -518,7 +535,6 @@ acpi_rs_calculate_list_length (
 			if (9 + additional_bytes < temp16) {
 				temp8 = (u8) (temp16 - (9 + additional_bytes));
 			}
-
 			else {
 				temp8 = 0;
 			}
@@ -526,15 +542,15 @@ acpi_rs_calculate_list_length (
 			/*
 			 * Ensure a 32-bit boundary for the structure
 			 */
-			temp8 = (u8) ROUND_UP_TO_32_bITS (temp8);
+			temp8 = (u8) ACPI_ROUND_UP_to_32_bITS (temp8);
 
-			structure_size = SIZEOF_RESOURCE (acpi_resource_ext_irq) +
+			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_ext_irq) +
 					   (additional_bytes * sizeof (u8)) +
 					   (temp8 * sizeof (u8));
 			break;
 
 
-		case RESOURCE_DESC_IRQ_FORMAT:
+		case ACPI_RDESC_TYPE_IRQ_FORMAT:
 			/*
 			 * IRQ Resource.
 			 * Determine if it there are two or three trailing bytes
@@ -545,7 +561,6 @@ acpi_rs_calculate_list_length (
 			if(temp8 & 0x01) {
 				bytes_consumed = 4;
 			}
-
 			else {
 				bytes_consumed = 3;
 			}
@@ -558,7 +573,7 @@ acpi_rs_calculate_list_length (
 			/*
 			 * Look at the number of bits set
 			 */
-			MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
+			ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
 			for (index = 0; index < 16; index++) {
 				if (temp16 & 0x1) {
@@ -568,12 +583,12 @@ acpi_rs_calculate_list_length (
 				temp16 >>= 1;
 			}
 
-			structure_size = SIZEOF_RESOURCE (acpi_resource_io) +
+			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_io) +
 					   (number_of_interrupts * sizeof (u32));
 			break;
 
 
-		case RESOURCE_DESC_DMA_FORMAT:
+		case ACPI_RDESC_TYPE_DMA_FORMAT:
 			/*
 			 * DMA Resource
 			 */
@@ -598,12 +613,12 @@ acpi_rs_calculate_list_length (
 				temp8 >>= 1;
 			}
 
-			structure_size = SIZEOF_RESOURCE (acpi_resource_dma) +
+			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_dma) +
 					   (number_of_channels * sizeof (u32));
 			break;
 
 
-		case RESOURCE_DESC_START_DEPENDENT:
+		case ACPI_RDESC_TYPE_START_DEPENDENT:
 			/*
 			 * Start Dependent Functions Resource
 			 * Determine if it there are two or three trailing bytes
@@ -618,11 +633,11 @@ acpi_rs_calculate_list_length (
 				bytes_consumed = 1;
 			}
 
-			structure_size = SIZEOF_RESOURCE (acpi_resource_start_dpf);
+			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_start_dpf);
 			break;
 
 
-		case RESOURCE_DESC_END_DEPENDENT:
+		case ACPI_RDESC_TYPE_END_DEPENDENT:
 			/*
 			 * End Dependent Functions Resource
 			 */
@@ -631,25 +646,25 @@ acpi_rs_calculate_list_length (
 			break;
 
 
-		case RESOURCE_DESC_IO_PORT:
+		case ACPI_RDESC_TYPE_IO_PORT:
 			/*
 			 * IO Port Resource
 			 */
 			bytes_consumed = 8;
-			structure_size = SIZEOF_RESOURCE (acpi_resource_io);
+			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_io);
 			break;
 
 
-		case RESOURCE_DESC_FIXED_IO_PORT:
+		case ACPI_RDESC_TYPE_FIXED_IO_PORT:
 			/*
 			 * Fixed IO Port Resource
 			 */
 			bytes_consumed = 4;
-			structure_size = SIZEOF_RESOURCE (acpi_resource_fixed_io);
+			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_fixed_io);
 			break;
 
 
-		case RESOURCE_DESC_SMALL_VENDOR:
+		case ACPI_RDESC_TYPE_SMALL_VENDOR:
 			/*
 			 * Vendor Specific Resource
 			 */
@@ -662,13 +677,13 @@ acpi_rs_calculate_list_length (
 			/*
 			 * Ensure a 32-bit boundary for the structure
 			 */
-			temp8 = (u8) ROUND_UP_TO_32_bITS (temp8);
-			structure_size = SIZEOF_RESOURCE (acpi_resource_vendor) +
+			temp8 = (u8) ACPI_ROUND_UP_to_32_bITS (temp8);
+			structure_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_vendor) +
 					   (temp8 * sizeof (u8));
 			break;
 
 
-		case RESOURCE_DESC_END_TAG:
+		case ACPI_RDESC_TYPE_END_TAG:
 			/*
 			 * End Tag
 			 */
@@ -684,14 +699,12 @@ acpi_rs_calculate_list_length (
 			 *  so exit with an error
 			 */
 			return_ACPI_STATUS (AE_AML_INVALID_RESOURCE_TYPE);
-			break;
 		}
 
-
 		/*
 		 * Update the return value and counter
 		 */
-		buffer_size += structure_size;
+		buffer_size += ACPI_ALIGN_RESOURCE_SIZE(structure_size);
 		bytes_parsed += bytes_consumed;
 
 		/*
@@ -700,7 +713,6 @@ acpi_rs_calculate_list_length (
 		byte_stream_buffer += bytes_consumed;
 	}
 
-
 	/*
 	 * This is the data the caller needs
 	 */
@@ -711,10 +723,10 @@ acpi_rs_calculate_list_length (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_calculate_pci_routing_table_length
+ * FUNCTION:    acpi_rs_get_pci_routing_table_length
  *
- * PARAMETERS:  Package_object          - Pointer to the package object
- *              Buffer_size_needed      - u32 pointer of the size buffer
+ * PARAMETERS:  package_object          - Pointer to the package object
+ *              buffer_size_needed      - u32 pointer of the size buffer
  *                                        needed to properly return the
  *                                        parsed data
  *
@@ -727,21 +739,21 @@ acpi_rs_calculate_list_length (
  ******************************************************************************/
 
 acpi_status
-acpi_rs_calculate_pci_routing_table_length (
-	acpi_operand_object     *package_object,
-	u32                     *buffer_size_needed)
+acpi_rs_get_pci_routing_table_length (
+	union acpi_operand_object       *package_object,
+	acpi_size                       *buffer_size_needed)
 {
-	u32                     number_of_elements;
-	u32                     temp_size_needed = 0;
-	acpi_operand_object     **top_object_list;
-	u32                     index;
-	acpi_operand_object     *package_element;
-	acpi_operand_object     **sub_object_list;
-	u8                      name_found;
-	u32                     table_index;
+	u32                             number_of_elements;
+	acpi_size                       temp_size_needed = 0;
+	union acpi_operand_object       **top_object_list;
+	u32                             index;
+	union acpi_operand_object       *package_element;
+	union acpi_operand_object       **sub_object_list;
+	u8                              name_found;
+	u32                             table_index;
 
 
-	FUNCTION_TRACE ("Rs_calculate_pci_routing_table_length");
+	ACPI_FUNCTION_TRACE ("rs_get_pci_routing_table_length");
 
 
 	number_of_elements = package_object->package.count;
@@ -765,23 +777,22 @@ acpi_rs_calculate_pci_routing_table_leng
 		package_element = *top_object_list;
 
 		/*
-		 * The Sub_object_list will now point to an array of the
-		 * four IRQ elements: Address, Pin, Source and Source_index
+		 * The sub_object_list will now point to an array of the
+		 * four IRQ elements: Address, Pin, Source and source_index
 		 */
 		sub_object_list = package_element->package.elements;
 
 		/*
-		 * Scan the Irq_table_elements for the Source Name String
+		 * Scan the irq_table_elements for the Source Name String
 		 */
 		name_found = FALSE;
 
 		for (table_index = 0; table_index < 4 && !name_found; table_index++) {
-			if ((ACPI_TYPE_STRING == (*sub_object_list)->common.type) ||
-				((INTERNAL_TYPE_REFERENCE == (*sub_object_list)->common.type) &&
+			if ((ACPI_TYPE_STRING == ACPI_GET_OBJECT_TYPE (*sub_object_list)) ||
+				((ACPI_TYPE_LOCAL_REFERENCE == ACPI_GET_OBJECT_TYPE (*sub_object_list)) &&
 					((*sub_object_list)->reference.opcode == AML_INT_NAMEPATH_OP))) {
 				name_found = TRUE;
 			}
-
 			else {
 				/*
 				 * Look at the next element
@@ -790,26 +801,24 @@ acpi_rs_calculate_pci_routing_table_leng
 			}
 		}
 
-		temp_size_needed += (sizeof (pci_routing_table) - 4);
+		temp_size_needed += (sizeof (struct acpi_pci_routing_table) - 4);
 
 		/*
 		 * Was a String type found?
 		 */
-		if (TRUE == name_found) {
-			if (ACPI_TYPE_STRING == (*sub_object_list)->common.type) {
+		if (name_found) {
+			if (ACPI_GET_OBJECT_TYPE (*sub_object_list) == ACPI_TYPE_STRING) {
 				/*
-				 * The length String.Length field includes the
-				 * terminating NULL
+				 * The length String.Length field does not include the
+				 * terminating NULL, add 1
 				 */
-				temp_size_needed += (*sub_object_list)->string.length;
+				temp_size_needed += ((acpi_size) (*sub_object_list)->string.length + 1);
 			}
-
 			else {
 				temp_size_needed += acpi_ns_get_pathname_length (
 						   (*sub_object_list)->reference.node);
 			}
 		}
-
 		else {
 			/*
 			 * If no name was found, then this is a NULL, which is
@@ -820,18 +829,17 @@ acpi_rs_calculate_pci_routing_table_leng
 
 		/* Round up the size since each element must be aligned */
 
-		temp_size_needed = ROUND_UP_TO_64_bITS (temp_size_needed);
+		temp_size_needed = ACPI_ROUND_UP_to_64_bITS (temp_size_needed);
 
 		/*
-		 * Point to the next acpi_operand_object
+		 * Point to the next union acpi_operand_object
 		 */
 		top_object_list++;
 	}
 
-
 	/*
 	 * Adding an extra element to the end of the list, essentially a NULL terminator
 	 */
-	*buffer_size_needed = temp_size_needed + sizeof (pci_routing_table);
+	*buffer_size_needed = temp_size_needed + sizeof (struct acpi_pci_routing_table);
 	return_ACPI_STATUS (AE_OK);
 }
diff -urNp linux-5400/drivers/acpi/resources/rscreate.c linux-5410/drivers/acpi/resources/rscreate.c
--- linux-5400/drivers/acpi/resources/rscreate.c
+++ linux-5410/drivers/acpi/resources/rscreate.c
@@ -1,50 +1,67 @@
 /*******************************************************************************
  *
  * Module Name: rscreate - Create resource lists/tables
- *              $Revision: 36 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acresrc.h"
-#include "amlcode.h"
-#include "acnamesp.h"
+#include <acpi/acpi.h>
+#include <acpi/acresrc.h>
+#include <acpi/amlcode.h>
+#include <acpi/acnamesp.h>
 
 #define _COMPONENT          ACPI_RESOURCES
-	 MODULE_NAME         ("rscreate")
+	 ACPI_MODULE_NAME    ("rscreate")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_create_resource_list
+ * FUNCTION:    acpi_rs_create_resource_list
  *
- * PARAMETERS:  Byte_stream_buffer      - Pointer to the resource byte stream
- *              Output_buffer           - Pointer to the user's buffer
- *              Output_buffer_length    - Pointer to the size of Output_buffer
+ * PARAMETERS:  byte_stream_buffer      - Pointer to the resource byte stream
+ *              output_buffer           - Pointer to the user's buffer
  *
  * RETURN:      Status  - AE_OK if okay, else a valid acpi_status code
- *              If Output_buffer is not large enough, Output_buffer_length
- *              indicates how large Output_buffer should be, else it
- *              indicates how may u8 elements of Output_buffer are valid.
+ *              If output_buffer is not large enough, output_buffer_length
+ *              indicates how large output_buffer should be, else it
+ *              indicates how may u8 elements of output_buffer are valid.
  *
  * DESCRIPTION: Takes the byte stream returned from a _CRS, _PRS control method
  *              execution and parses the stream to create a linked list
@@ -54,21 +71,21 @@
 
 acpi_status
 acpi_rs_create_resource_list (
-	acpi_operand_object     *byte_stream_buffer,
-	u8                      *output_buffer,
-	u32                     *output_buffer_length)
+	union acpi_operand_object       *byte_stream_buffer,
+	struct acpi_buffer              *output_buffer)
 {
 
-	acpi_status             status;
-	u8                      *byte_stream_start;
-	u32                     list_size_needed = 0;
-	u32                     byte_stream_buffer_length;
+	acpi_status                     status;
+	u8                              *byte_stream_start;
+	acpi_size                       list_size_needed = 0;
+	u32                             byte_stream_buffer_length;
 
 
-	FUNCTION_TRACE ("Rs_create_resource_list");
+	ACPI_FUNCTION_TRACE ("rs_create_resource_list");
 
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Byte_stream_buffer = %p\n", byte_stream_buffer));
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "byte_stream_buffer = %p\n",
+		byte_stream_buffer));
 
 	/*
 	 * Params already validated, so we don't re-validate here
@@ -77,300 +94,280 @@ acpi_rs_create_resource_list (
 	byte_stream_start = byte_stream_buffer->buffer.pointer;
 
 	/*
-	 * Pass the Byte_stream_buffer into a module that can calculate
+	 * Pass the byte_stream_buffer into a module that can calculate
 	 * the buffer size needed for the linked list
 	 */
-	status = acpi_rs_calculate_list_length (byte_stream_start, byte_stream_buffer_length,
+	status = acpi_rs_get_list_length (byte_stream_start, byte_stream_buffer_length,
 			 &list_size_needed);
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Status=%X List_size_needed=%X\n",
-		status, list_size_needed));
-
-	/*
-	 * Exit with the error passed back
-	 */
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Status=%X list_size_needed=%X\n",
+		status, (u32) list_size_needed));
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
-	/*
-	 * If the linked list will fit into the available buffer
-	 * call to fill in the list
-	 */
-	if (list_size_needed <= *output_buffer_length) {
-		/*
-		 * Zero out the return buffer before proceeding
-		 */
-		MEMSET (output_buffer, 0x00, *output_buffer_length);
-
-		status = acpi_rs_byte_stream_to_list (byte_stream_start, byte_stream_buffer_length,
-				 &output_buffer);
+	/* Validate/Allocate/Clear caller buffer */
 
-		/*
-		 * Exit with the error passed back
-		 */
-		if (ACPI_FAILURE (status)) {
-			return_ACPI_STATUS (status);
-		}
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Output_buffer = %p\n", output_buffer));
+	status = acpi_ut_initialize_buffer (output_buffer, list_size_needed);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
 	}
 
-	else {
-		*output_buffer_length = list_size_needed;
-		return_ACPI_STATUS (AE_BUFFER_OVERFLOW);
+	/* Do the conversion */
+
+	status = acpi_rs_byte_stream_to_list (byte_stream_start, byte_stream_buffer_length,
+			  output_buffer->pointer);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
 	}
 
-	*output_buffer_length = list_size_needed;
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "output_buffer %p Length %X\n",
+			output_buffer->pointer, (u32) output_buffer->length));
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_create_pci_routing_table
+ * FUNCTION:    acpi_rs_create_pci_routing_table
  *
- * PARAMETERS:  Package_object          - Pointer to an acpi_operand_object
+ * PARAMETERS:  package_object          - Pointer to an union acpi_operand_object
  *                                        package
- *              Output_buffer           - Pointer to the user's buffer
- *              Output_buffer_length    - Size of Output_buffer
+ *              output_buffer           - Pointer to the user's buffer
  *
  * RETURN:      Status  AE_OK if okay, else a valid acpi_status code.
- *              If the Output_buffer is too small, the error will be
- *              AE_BUFFER_OVERFLOW and Output_buffer_length will point
+ *              If the output_buffer is too small, the error will be
+ *              AE_BUFFER_OVERFLOW and output_buffer->Length will point
  *              to the size buffer needed.
  *
- * DESCRIPTION: Takes the acpi_operand_object  package and creates a
+ * DESCRIPTION: Takes the union acpi_operand_object    package and creates a
  *              linked list of PCI interrupt descriptions
  *
+ * NOTE: It is the caller's responsibility to ensure that the start of the
+ * output buffer is aligned properly (if necessary).
+ *
  ******************************************************************************/
 
 acpi_status
 acpi_rs_create_pci_routing_table (
-	acpi_operand_object     *package_object,
-	u8                      *output_buffer,
-	u32                     *output_buffer_length)
+	union acpi_operand_object       *package_object,
+	struct acpi_buffer              *output_buffer)
 {
-	u8                      *buffer = output_buffer;
-	acpi_operand_object     **top_object_list = NULL;
-	acpi_operand_object     **sub_object_list = NULL;
-	acpi_operand_object     *package_element = NULL;
-	u32                     buffer_size_needed = 0;
-	u32                     number_of_elements = 0;
-	u32                     index = 0;
-	pci_routing_table       *user_prt = NULL;
-	acpi_namespace_node     *node;
-	acpi_status             status;
+	u8                              *buffer;
+	union acpi_operand_object       **top_object_list;
+	union acpi_operand_object       **sub_object_list;
+	union acpi_operand_object       *obj_desc;
+	acpi_size                       buffer_size_needed = 0;
+	u32                             number_of_elements;
+	u32                             index;
+	struct acpi_pci_routing_table   *user_prt;
+	struct acpi_namespace_node      *node;
+	acpi_status                     status;
+	struct acpi_buffer              path_buffer;
 
 
-	FUNCTION_TRACE ("Rs_create_pci_routing_table");
+	ACPI_FUNCTION_TRACE ("rs_create_pci_routing_table");
 
 
+	/* Params already validated, so we don't re-validate here */
+
 	/*
-	 * Params already validated, so we don't re-validate here
+	 * Get the required buffer length
 	 */
-	status = acpi_rs_calculate_pci_routing_table_length (package_object,
+	status = acpi_rs_get_pci_routing_table_length (package_object,
 			 &buffer_size_needed);
-
-	if (!ACPI_SUCCESS(status)) {
+	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Buffer_size_needed = %X\n", buffer_size_needed));
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "buffer_size_needed = %X\n",
+		(u32) buffer_size_needed));
+
+	/* Validate/Allocate/Clear caller buffer */
+
+	status = acpi_ut_initialize_buffer (output_buffer, buffer_size_needed);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	/*
-	 * If the data will fit into the available buffer
-	 * call to fill in the list
+	 * Loop through the ACPI_INTERNAL_OBJECTS - Each object
+	 * should be a package that in turn contains an
+	 * acpi_integer Address, a u8 Pin, a Name and a u8 source_index.
 	 */
-	if (buffer_size_needed <= *output_buffer_length) {
+	top_object_list  = package_object->package.elements;
+	number_of_elements = package_object->package.count;
+	buffer           = output_buffer->pointer;
+	user_prt         = ACPI_CAST_PTR (struct acpi_pci_routing_table, buffer);
+
+	for (index = 0; index < number_of_elements; index++) {
 		/*
-		 * Zero out the return buffer before proceeding
+		 * Point user_prt past this current structure
+		 *
+		 * NOTE: On the first iteration, user_prt->Length will
+		 * be zero because we cleared the return buffer earlier
 		 */
-		MEMSET (output_buffer, 0x00, *output_buffer_length);
+		buffer += user_prt->length;
+		user_prt = ACPI_CAST_PTR (struct acpi_pci_routing_table, buffer);
 
 		/*
-		 * Loop through the ACPI_INTERNAL_OBJECTS - Each object should
-		 * contain a u32 Address, a u8 Pin, a Name and a u8
-		 * Source_index.
+		 * Fill in the Length field with the information we have at this point.
+		 * The minus four is to subtract the size of the u8 Source[4] member
+		 * because it is added below.
 		 */
-		top_object_list     = package_object->package.elements;
-		number_of_elements  = package_object->package.count;
-		user_prt            = (pci_routing_table *) buffer;
-
-
-		buffer = ROUND_PTR_UP_TO_8 (buffer, u8);
-
-		for (index = 0; index < number_of_elements; index++) {
-			/*
-			 * Point User_prt past this current structure
-			 *
-			 * NOTE: On the first iteration, User_prt->Length will
-			 * be zero because we cleared the return buffer earlier
-			 */
-			buffer += user_prt->length;
-			user_prt = (pci_routing_table *) buffer;
+		user_prt->length = (sizeof (struct acpi_pci_routing_table) - 4);
 
+		/*
+		 * Each element of the top-level package must also be a package
+		 */
+		if (ACPI_GET_OBJECT_TYPE (*top_object_list) != ACPI_TYPE_PACKAGE) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"(PRT[%X]) Need sub-package, found %s\n",
+				index, acpi_ut_get_object_type_name (*top_object_list)));
+			return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
+		}
 
-			/*
-			 * Fill in the Length field with the information we
-			 * have at this point.
-			 * The minus four is to subtract the size of the
-			 * u8 Source[4] member because it is added below.
-			 */
-			user_prt->length = (sizeof (pci_routing_table) -4);
-
-			/*
-			 * Dereference the sub-package
-			 */
-			package_element = *top_object_list;
-
-			/*
-			 * The Sub_object_list will now point to an array of
-			 * the four IRQ elements: Address, Pin, Source and
-			 * Source_index
-			 */
-			sub_object_list = package_element->package.elements;
+		/* Each sub-package must be of length 4 */
 
-			/*
-			 * 1) First subobject:  Dereference the Address
-			 */
-			if (ACPI_TYPE_INTEGER == (*sub_object_list)->common.type) {
-				user_prt->address = (*sub_object_list)->integer.value;
-			}
+		if ((*top_object_list)->package.count != 4) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"(PRT[%X]) Need package of length 4, found length %d\n",
+				index, (*top_object_list)->package.count));
+			return_ACPI_STATUS (AE_AML_PACKAGE_LIMIT);
+		}
 
-			else {
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Need Integer, found %s\n",
-					acpi_ut_get_type_name ((*sub_object_list)->common.type)));
-				return_ACPI_STATUS (AE_BAD_DATA);
-			}
+		/*
+		 * Dereference the sub-package.
+		 * The sub_object_list will now point to an array of the four IRQ
+		 * elements: [Address, Pin, Source, source_index]
+		 */
+		sub_object_list = (*top_object_list)->package.elements;
 
-			/*
-			 * 2) Second subobject: Dereference the Pin
-			 */
-			sub_object_list++;
+		/*
+		 * 1) First subobject: Dereference the PRT.Address
+		 */
+		obj_desc = sub_object_list[0];
+		if (ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_INTEGER) {
+			user_prt->address = obj_desc->integer.value;
+		}
+		else {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"(PRT[%X].Address) Need Integer, found %s\n",
+				index, acpi_ut_get_object_type_name (obj_desc)));
+			return_ACPI_STATUS (AE_BAD_DATA);
+		}
 
-			if (ACPI_TYPE_INTEGER == (*sub_object_list)->common.type) {
-				user_prt->pin = (u32) (*sub_object_list)->integer.value;
-			}
+		/*
+		 * 2) Second subobject: Dereference the PRT.Pin
+		 */
+		obj_desc = sub_object_list[1];
+		if (ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_INTEGER) {
+			user_prt->pin = (u32) obj_desc->integer.value;
+		}
+		else {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"(PRT[%X].Pin) Need Integer, found %s\n",
+				index, acpi_ut_get_object_type_name (obj_desc)));
+			return_ACPI_STATUS (AE_BAD_DATA);
+		}
 
-			else {
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Need Integer, found %s\n",
-					acpi_ut_get_type_name ((*sub_object_list)->common.type)));
+		/*
+		 * 3) Third subobject: Dereference the PRT.source_name
+		 */
+		obj_desc = sub_object_list[2];
+		switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
+		case ACPI_TYPE_LOCAL_REFERENCE:
+
+			if (obj_desc->reference.opcode != AML_INT_NAMEPATH_OP) {
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+					"(PRT[%X].Source) Need name, found reference op %X\n",
+					index, obj_desc->reference.opcode));
 				return_ACPI_STATUS (AE_BAD_DATA);
 			}
 
-			/*
-			 * 3) Third subobject: Dereference the Source Name
-			 */
-			sub_object_list++;
+			node = obj_desc->reference.node;
 
-			switch ((*sub_object_list)->common.type) {
-			case INTERNAL_TYPE_REFERENCE:
+			/* Use *remaining* length of the buffer as max for pathname */
 
-				if ((*sub_object_list)->reference.opcode != AML_INT_NAMEPATH_OP) {
-				   ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Need name, found reference op %X\n",
-						(*sub_object_list)->reference.opcode));
-					return_ACPI_STATUS (AE_BAD_DATA);
-				}
+			path_buffer.length = output_buffer->length -
+					   (u32) ((u8 *) user_prt->source -
+					   (u8 *) output_buffer->pointer);
+			path_buffer.pointer = user_prt->source;
 
-				node = (*sub_object_list)->reference.node;
+			status = acpi_ns_handle_to_pathname ((acpi_handle) node, &path_buffer);
 
-				/* TBD: use *remaining* length of the buffer! */
+			user_prt->length += (u32) ACPI_STRLEN (user_prt->source) + 1; /* include null terminator */
+			break;
 
-				status = acpi_ns_handle_to_pathname ((acpi_handle *) node,
-						 output_buffer_length, user_prt->source);
 
-				user_prt->length += STRLEN (user_prt->source) + 1; /* include null terminator */
-				break;
+		case ACPI_TYPE_STRING:
 
+			ACPI_STRCPY (user_prt->source, obj_desc->string.pointer);
 
-			case ACPI_TYPE_STRING:
+			/* Add to the Length field the length of the string (add 1 for terminator) */
 
-				STRCPY (user_prt->source,
-					  (*sub_object_list)->string.pointer);
+			user_prt->length += obj_desc->string.length + 1;
+			break;
 
-				/*
-				 * Add to the Length field the length of the string
-				 */
-				user_prt->length += (*sub_object_list)->string.length;
-				break;
-
-
-			case ACPI_TYPE_INTEGER:
-				/*
-				 * If this is a number, then the Source Name
-				 * is NULL, since the entire buffer was zeroed
-				 * out, we can leave this alone.
-				 */
-				/*
-				 * Add to the Length field the length of
-				 * the u32 NULL
-				 */
-				user_prt->length += sizeof (u32);
-				break;
-
-
-			default:
-
-			   ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Need Integer, found %s\n",
-					acpi_ut_get_type_name ((*sub_object_list)->common.type)));
-			   return_ACPI_STATUS (AE_BAD_DATA);
-			   break;
-			}
-
-			/* Now align the current length */
-
-			user_prt->length = ROUND_UP_TO_64_bITS (user_prt->length);
 
+		case ACPI_TYPE_INTEGER:
 			/*
-			 * 4) Fourth subobject: Dereference the Source Index
+			 * If this is a number, then the Source Name is NULL, since the
+			 * entire buffer was zeroed out, we can leave this alone.
+			 *
+			 * Add to the Length field the length of the u32 NULL
 			 */
-			sub_object_list++;
+			user_prt->length += sizeof (u32);
+			break;
 
-			if (ACPI_TYPE_INTEGER == (*sub_object_list)->common.type) {
-				user_prt->source_index = (u32) (*sub_object_list)->integer.value;
-			}
 
-			else {
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Need Integer, found %s\n",
-					acpi_ut_get_type_name ((*sub_object_list)->common.type)));
-				return_ACPI_STATUS (AE_BAD_DATA);
-			}
+		default:
 
-			/*
-			 * Point to the next acpi_operand_object
-			 */
-			top_object_list++;
+		   ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			   "(PRT[%X].Source) Need Ref/String/Integer, found %s\n",
+				index, acpi_ut_get_object_type_name (obj_desc)));
+		   return_ACPI_STATUS (AE_BAD_DATA);
 		}
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Output_buffer = %p\n", output_buffer));
-	}
+		/* Now align the current length */
+
+		user_prt->length = ACPI_ROUND_UP_to_64_bITS (user_prt->length);
+
+		/*
+		 * 4) Fourth subobject: Dereference the PRT.source_index
+		 */
+		obj_desc = sub_object_list[3];
+		if (ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_INTEGER) {
+			user_prt->source_index = (u32) obj_desc->integer.value;
+		}
+		else {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"(PRT[%X].source_index) Need Integer, found %s\n",
+				index, acpi_ut_get_object_type_name (obj_desc)));
+			return_ACPI_STATUS (AE_BAD_DATA);
+		}
 
-	else {
-		*output_buffer_length = buffer_size_needed;
+		/* Point to the next union acpi_operand_object in the top level package */
 
-		return_ACPI_STATUS (AE_BUFFER_OVERFLOW);
+		top_object_list++;
 	}
 
-	/*
-	 * Report the amount of buffer used
-	 */
-	*output_buffer_length = buffer_size_needed;
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "output_buffer %p Length %X\n",
+			output_buffer->pointer, (u32) output_buffer->length));
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_create_byte_stream
+ * FUNCTION:    acpi_rs_create_byte_stream
  *
- * PARAMETERS:  Linked_list_buffer      - Pointer to the resource linked list
- *              Output_buffer           - Pointer to the user's buffer
- *              Output_buffer_length    - Size of Output_buffer
+ * PARAMETERS:  linked_list_buffer      - Pointer to the resource linked list
+ *              output_buffer           - Pointer to the user's buffer
  *
  * RETURN:      Status  AE_OK if okay, else a valid acpi_status code.
- *              If the Output_buffer is too small, the error will be
- *              AE_BUFFER_OVERFLOW and Output_buffer_length will point
+ *              If the output_buffer is too small, the error will be
+ *              AE_BUFFER_OVERFLOW and output_buffer->Length will point
  *              to the size buffer needed.
  *
  * DESCRIPTION: Takes the linked list of device resources and
@@ -381,66 +378,51 @@ acpi_rs_create_pci_routing_table (
 
 acpi_status
 acpi_rs_create_byte_stream (
-	acpi_resource           *linked_list_buffer,
-	u8                      *output_buffer,
-	u32                     *output_buffer_length)
+	struct acpi_resource            *linked_list_buffer,
+	struct acpi_buffer              *output_buffer)
 {
-	acpi_status             status;
-	u32                     byte_stream_size_needed = 0;
+	acpi_status                     status;
+	acpi_size                       byte_stream_size_needed = 0;
 
 
-	FUNCTION_TRACE ("Rs_create_byte_stream");
+	ACPI_FUNCTION_TRACE ("rs_create_byte_stream");
 
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Linked_list_buffer = %p\n", linked_list_buffer));
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "linked_list_buffer = %p\n",
+		linked_list_buffer));
 
 	/*
 	 * Params already validated, so we don't re-validate here
 	 *
-	 * Pass the Linked_list_buffer into a module that can calculate
+	 * Pass the linked_list_buffer into a module that calculates
 	 * the buffer size needed for the byte stream.
 	 */
-	status = acpi_rs_calculate_byte_stream_length (linked_list_buffer,
+	status = acpi_rs_get_byte_stream_length (linked_list_buffer,
 			 &byte_stream_size_needed);
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Byte_stream_size_needed=%X, %s\n",
-		byte_stream_size_needed, acpi_format_exception (status)));
-
-	/*
-	 * Exit with the error passed back
-	 */
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "byte_stream_size_needed=%X, %s\n",
+		(u32) byte_stream_size_needed, acpi_format_exception (status)));
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
-	/*
-	 * If the linked list will fit into the available buffer
-	 * call to fill in the list
-	 */
-	if (byte_stream_size_needed <= *output_buffer_length) {
-		/*
-		 * Zero out the return buffer before proceeding
-		 */
-		MEMSET (output_buffer, 0x00, *output_buffer_length);
-
-		status = acpi_rs_list_to_byte_stream (linked_list_buffer, byte_stream_size_needed,
-				 &output_buffer);
+	/* Validate/Allocate/Clear caller buffer */
 
-		/*
-		 * Exit with the error passed back
-		 */
-		if (ACPI_FAILURE (status)) {
-			return_ACPI_STATUS (status);
-		}
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Output_buffer = %p\n", output_buffer));
+	status = acpi_ut_initialize_buffer (output_buffer, byte_stream_size_needed);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
 	}
 
-	else {
-		*output_buffer_length = byte_stream_size_needed;
-		return_ACPI_STATUS (AE_BUFFER_OVERFLOW);
+	/* Do the conversion */
+
+	status = acpi_rs_list_to_byte_stream (linked_list_buffer, byte_stream_size_needed,
+			  output_buffer->pointer);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
 	}
 
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "output_buffer %p Length %X\n",
+			output_buffer->pointer, (u32) output_buffer->length));
 	return_ACPI_STATUS (AE_OK);
 }
 
diff -urNp linux-5400/drivers/acpi/resources/rsdump.c linux-5410/drivers/acpi/resources/rsdump.c
--- linux-5400/drivers/acpi/resources/rsdump.c
+++ linux-5410/drivers/acpi/resources/rsdump.c
@@ -1,41 +1,59 @@
 /*******************************************************************************
  *
  * Module Name: rsdump - Functions to display the resource structures.
- *              $Revision: 23 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acresrc.h"
+#include <acpi/acpi.h>
+#include <acpi/acresrc.h>
 
 #define _COMPONENT          ACPI_RESOURCES
-	 MODULE_NAME         ("rsdump")
+	 ACPI_MODULE_NAME    ("rsdump")
 
 
-#ifdef ACPI_DEBUG
+#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_dump_irq
+ * FUNCTION:    acpi_rs_dump_irq
  *
  * PARAMETERS:  Data            - pointer to the resource structure to dump.
  *
@@ -47,25 +65,25 @@
 
 void
 acpi_rs_dump_irq (
-	acpi_resource_data      *data)
+	union acpi_resource_data        *data)
 {
-	acpi_resource_irq       *irq_data = (acpi_resource_irq *) data;
-	u8                      index = 0;
+	struct acpi_resource_irq        *irq_data = (struct acpi_resource_irq *) data;
+	u8                              index = 0;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	acpi_os_printf ("IRQ Resource\n");
 
 	acpi_os_printf ("  %s Triggered\n",
-			 LEVEL_SENSITIVE == irq_data->edge_level ? "Level" : "Edge");
+			 ACPI_LEVEL_SENSITIVE == irq_data->edge_level ? "Level" : "Edge");
 
 	acpi_os_printf ("  Active %s\n",
-			 ACTIVE_LOW == irq_data->active_high_low ? "Low" : "High");
+			 ACPI_ACTIVE_LOW == irq_data->active_high_low ? "Low" : "High");
 
 	acpi_os_printf ("  %s\n",
-			 SHARED == irq_data->shared_exclusive ? "Shared" : "Exclusive");
+			 ACPI_SHARED == irq_data->shared_exclusive ? "Shared" : "Exclusive");
 
 	acpi_os_printf ("  %X Interrupts ( ", irq_data->number_of_interrupts);
 
@@ -80,7 +98,7 @@ acpi_rs_dump_irq (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_dump_dma
+ * FUNCTION:    acpi_rs_dump_dma
  *
  * PARAMETERS:  Data            - pointer to the resource structure to dump.
  *
@@ -92,31 +110,31 @@ acpi_rs_dump_irq (
 
 void
 acpi_rs_dump_dma (
-	acpi_resource_data      *data)
+	union acpi_resource_data        *data)
 {
-	acpi_resource_dma       *dma_data = (acpi_resource_dma *) data;
-	u8                      index = 0;
+	struct acpi_resource_dma        *dma_data = (struct acpi_resource_dma *) data;
+	u8                              index = 0;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	acpi_os_printf ("DMA Resource\n");
 
 	switch (dma_data->type) {
-	case COMPATIBILITY:
+	case ACPI_COMPATIBILITY:
 		acpi_os_printf ("  Compatibility mode\n");
 		break;
 
-	case TYPE_A:
+	case ACPI_TYPE_A:
 		acpi_os_printf ("  Type A\n");
 		break;
 
-	case TYPE_B:
+	case ACPI_TYPE_B:
 		acpi_os_printf ("  Type B\n");
 		break;
 
-	case TYPE_F:
+	case ACPI_TYPE_F:
 		acpi_os_printf ("  Type F\n");
 		break;
 
@@ -126,19 +144,19 @@ acpi_rs_dump_dma (
 	}
 
 	acpi_os_printf ("  %sBus Master\n",
-			 BUS_MASTER == dma_data->bus_master ? "" : "Not a ");
+			 ACPI_BUS_MASTER == dma_data->bus_master ? "" : "Not a ");
 
 
 	switch (dma_data->transfer) {
-	case TRANSFER_8:
+	case ACPI_TRANSFER_8:
 		acpi_os_printf ("  8-bit only transfer\n");
 		break;
 
-	case TRANSFER_8_16:
+	case ACPI_TRANSFER_8_16:
 		acpi_os_printf ("  8 and 16-bit transfer\n");
 		break;
 
-	case TRANSFER_16:
+	case ACPI_TRANSFER_16:
 		acpi_os_printf ("  16 bit only transfer\n");
 		break;
 
@@ -160,7 +178,7 @@ acpi_rs_dump_dma (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_dump_start_dependent_functions
+ * FUNCTION:    acpi_rs_dump_start_depend_fns
  *
  * PARAMETERS:  Data            - pointer to the resource structure to dump.
  *
@@ -171,27 +189,27 @@ acpi_rs_dump_dma (
  ******************************************************************************/
 
 void
-acpi_rs_dump_start_dependent_functions (
-	acpi_resource_data          *data)
+acpi_rs_dump_start_depend_fns (
+	union acpi_resource_data        *data)
 {
-	acpi_resource_start_dpf     *sdf_data = (acpi_resource_start_dpf *) data;
+	struct acpi_resource_start_dpf *sdf_data = (struct acpi_resource_start_dpf *) data;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	acpi_os_printf ("Start Dependent Functions Resource\n");
 
 	switch (sdf_data->compatibility_priority) {
-	case GOOD_CONFIGURATION:
+	case ACPI_GOOD_CONFIGURATION:
 		acpi_os_printf ("  Good configuration\n");
 		break;
 
-	case ACCEPTABLE_CONFIGURATION:
+	case ACPI_ACCEPTABLE_CONFIGURATION:
 		acpi_os_printf ("  Acceptable configuration\n");
 		break;
 
-	case SUB_OPTIMAL_CONFIGURATION:
+	case ACPI_SUB_OPTIMAL_CONFIGURATION:
 		acpi_os_printf ("  Sub-optimal configuration\n");
 		break;
 
@@ -201,15 +219,15 @@ acpi_rs_dump_start_dependent_functions (
 	}
 
 	switch(sdf_data->performance_robustness) {
-	case GOOD_CONFIGURATION:
+	case ACPI_GOOD_CONFIGURATION:
 		acpi_os_printf ("  Good configuration\n");
 		break;
 
-	case ACCEPTABLE_CONFIGURATION:
+	case ACPI_ACCEPTABLE_CONFIGURATION:
 		acpi_os_printf ("  Acceptable configuration\n");
 		break;
 
-	case SUB_OPTIMAL_CONFIGURATION:
+	case ACPI_SUB_OPTIMAL_CONFIGURATION:
 		acpi_os_printf ("  Sub-optimal configuration\n");
 		break;
 
@@ -225,7 +243,7 @@ acpi_rs_dump_start_dependent_functions (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_dump_io
+ * FUNCTION:    acpi_rs_dump_io
  *
  * PARAMETERS:  Data            - pointer to the resource structure to dump.
  *
@@ -237,18 +255,18 @@ acpi_rs_dump_start_dependent_functions (
 
 void
 acpi_rs_dump_io (
-	acpi_resource_data      *data)
+	union acpi_resource_data        *data)
 {
-	acpi_resource_io        *io_data = (acpi_resource_io *) data;
+	struct acpi_resource_io         *io_data = (struct acpi_resource_io *) data;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	acpi_os_printf ("Io Resource\n");
 
 	acpi_os_printf ("  %d bit decode\n",
-			 DECODE_16 == io_data->io_decode ? 16 : 10);
+			 ACPI_DECODE_16 == io_data->io_decode ? 16 : 10);
 
 	acpi_os_printf ("  Range minimum base: %08X\n",
 			 io_data->min_base_address);
@@ -268,7 +286,7 @@ acpi_rs_dump_io (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_dump_fixed_io
+ * FUNCTION:    acpi_rs_dump_fixed_io
  *
  * PARAMETERS:  Data            - pointer to the resource structure to dump.
  *
@@ -280,12 +298,12 @@ acpi_rs_dump_io (
 
 void
 acpi_rs_dump_fixed_io (
-	acpi_resource_data      *data)
+	union acpi_resource_data        *data)
 {
-	acpi_resource_fixed_io  *fixed_io_data = (acpi_resource_fixed_io *) data;
+	struct acpi_resource_fixed_io   *fixed_io_data = (struct acpi_resource_fixed_io *) data;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	acpi_os_printf ("Fixed Io Resource\n");
@@ -301,7 +319,7 @@ acpi_rs_dump_fixed_io (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_dump_vendor_specific
+ * FUNCTION:    acpi_rs_dump_vendor_specific
  *
  * PARAMETERS:  Data            - pointer to the resource structure to dump.
  *
@@ -313,13 +331,13 @@ acpi_rs_dump_fixed_io (
 
 void
 acpi_rs_dump_vendor_specific (
-	acpi_resource_data      *data)
+	union acpi_resource_data        *data)
 {
-	acpi_resource_vendor    *vendor_data = (acpi_resource_vendor *) data;
-	u16                     index = 0;
+	struct acpi_resource_vendor     *vendor_data = (struct acpi_resource_vendor *) data;
+	u16                             index = 0;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	acpi_os_printf ("Vendor Specific Resource\n");
@@ -337,7 +355,7 @@ acpi_rs_dump_vendor_specific (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_dump_memory24
+ * FUNCTION:    acpi_rs_dump_memory24
  *
  * PARAMETERS:  Data            - pointer to the resource structure to dump.
  *
@@ -349,18 +367,18 @@ acpi_rs_dump_vendor_specific (
 
 void
 acpi_rs_dump_memory24 (
-	acpi_resource_data      *data)
+	union acpi_resource_data        *data)
 {
-	acpi_resource_mem24     *memory24_data = (acpi_resource_mem24 *) data;
+	struct acpi_resource_mem24      *memory24_data = (struct acpi_resource_mem24 *) data;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	acpi_os_printf ("24-Bit Memory Range Resource\n");
 
 	acpi_os_printf ("  Read%s\n",
-			 READ_WRITE_MEMORY ==
+			 ACPI_READ_WRITE_MEMORY ==
 			 memory24_data->read_write_attribute ?
 			 "/Write" : " only");
 
@@ -382,7 +400,7 @@ acpi_rs_dump_memory24 (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_dump_memory32
+ * FUNCTION:    acpi_rs_dump_memory32
  *
  * PARAMETERS:  Data            - pointer to the resource structure to dump.
  *
@@ -394,18 +412,18 @@ acpi_rs_dump_memory24 (
 
 void
 acpi_rs_dump_memory32 (
-	acpi_resource_data      *data)
+	union acpi_resource_data        *data)
 {
-	acpi_resource_mem32     *memory32_data = (acpi_resource_mem32 *) data;
+	struct acpi_resource_mem32      *memory32_data = (struct acpi_resource_mem32 *) data;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	acpi_os_printf ("32-Bit Memory Range Resource\n");
 
 	acpi_os_printf ("  Read%s\n",
-			 READ_WRITE_MEMORY ==
+			 ACPI_READ_WRITE_MEMORY ==
 			 memory32_data->read_write_attribute ?
 			 "/Write" : " only");
 
@@ -427,7 +445,7 @@ acpi_rs_dump_memory32 (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_dump_fixed_memory32
+ * FUNCTION:    acpi_rs_dump_fixed_memory32
  *
  * PARAMETERS:  Data            - pointer to the resource structure to dump.
  *
@@ -439,18 +457,18 @@ acpi_rs_dump_memory32 (
 
 void
 acpi_rs_dump_fixed_memory32 (
-	acpi_resource_data          *data)
+	union acpi_resource_data            *data)
 {
-	acpi_resource_fixed_mem32   *fixed_memory32_data = (acpi_resource_fixed_mem32 *) data;
+	struct acpi_resource_fixed_mem32    *fixed_memory32_data = (struct acpi_resource_fixed_mem32 *) data;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	acpi_os_printf ("32-Bit Fixed Location Memory Range Resource\n");
 
 	acpi_os_printf ("  Read%s\n",
-			 READ_WRITE_MEMORY ==
+			 ACPI_READ_WRITE_MEMORY ==
 			 fixed_memory32_data->read_write_attribute ?
 			 "/Write" : " Only");
 
@@ -466,7 +484,7 @@ acpi_rs_dump_fixed_memory32 (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_dump_address16
+ * FUNCTION:    acpi_rs_dump_address16
  *
  * PARAMETERS:  Data            - pointer to the resource structure to dump.
  *
@@ -478,39 +496,39 @@ acpi_rs_dump_fixed_memory32 (
 
 void
 acpi_rs_dump_address16 (
-	acpi_resource_data      *data)
+	union acpi_resource_data        *data)
 {
-	acpi_resource_address16 *address16_data = (acpi_resource_address16 *) data;
+	struct acpi_resource_address16 *address16_data = (struct acpi_resource_address16 *) data;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	acpi_os_printf ("16-Bit Address Space Resource\n");
 	acpi_os_printf ("  Resource Type: ");
 
 	switch (address16_data->resource_type) {
-	case MEMORY_RANGE:
+	case ACPI_MEMORY_RANGE:
 
 		acpi_os_printf ("Memory Range\n");
 
 		switch (address16_data->attribute.memory.cache_attribute) {
-		case NON_CACHEABLE_MEMORY:
+		case ACPI_NON_CACHEABLE_MEMORY:
 			acpi_os_printf ("  Type Specific: "
 					  "Noncacheable memory\n");
 			break;
 
-		case CACHABLE_MEMORY:
+		case ACPI_CACHABLE_MEMORY:
 			acpi_os_printf ("  Type Specific: "
 					  "Cacheable memory\n");
 			break;
 
-		case WRITE_COMBINING_MEMORY:
+		case ACPI_WRITE_COMBINING_MEMORY:
 			acpi_os_printf ("  Type Specific: "
 					  "Write-combining memory\n");
 			break;
 
-		case PREFETCHABLE_MEMORY:
+		case ACPI_PREFETCHABLE_MEMORY:
 			acpi_os_printf ("  Type Specific: "
 					  "Prefetchable memory\n");
 			break;
@@ -522,27 +540,27 @@ acpi_rs_dump_address16 (
 		}
 
 		acpi_os_printf ("  Type Specific: Read%s\n",
-			READ_WRITE_MEMORY ==
+			ACPI_READ_WRITE_MEMORY ==
 			address16_data->attribute.memory.read_write_attribute ?
 			"/Write" : " Only");
 		break;
 
-	case IO_RANGE:
+	case ACPI_IO_RANGE:
 
 		acpi_os_printf ("I/O Range\n");
 
 		switch (address16_data->attribute.io.range_attribute) {
-		case NON_ISA_ONLY_RANGES:
+		case ACPI_NON_ISA_ONLY_RANGES:
 			acpi_os_printf ("  Type Specific: "
 					  "Non-ISA Io Addresses\n");
 			break;
 
-		case ISA_ONLY_RANGES:
+		case ACPI_ISA_ONLY_RANGES:
 			acpi_os_printf ("  Type Specific: "
 					  "ISA Io Addresses\n");
 			break;
 
-		case ENTIRE_RANGE:
+		case ACPI_ENTIRE_RANGE:
 			acpi_os_printf ("  Type Specific: "
 					  "ISA and non-ISA Io Addresses\n");
 			break;
@@ -552,9 +570,14 @@ acpi_rs_dump_address16 (
 					  "Invalid range attribute\n");
 			break;
 		}
+
+		acpi_os_printf (" Type Specific: %s Translation\n",
+			ACPI_SPARSE_TRANSLATION ==
+			address16_data->attribute.io.translation_attribute ?
+			"Sparse" : "Dense");
 		break;
 
-	case BUS_NUMBER_RANGE:
+	case ACPI_BUS_NUMBER_RANGE:
 
 		acpi_os_printf ("Bus Number Range\n");
 		break;
@@ -566,19 +589,19 @@ acpi_rs_dump_address16 (
 	}
 
 	acpi_os_printf ("  Resource %s\n",
-			CONSUMER == address16_data->producer_consumer ?
+			ACPI_CONSUMER == address16_data->producer_consumer ?
 			"Consumer" : "Producer");
 
 	acpi_os_printf ("  %s decode\n",
-			 SUB_DECODE == address16_data->decode ?
+			 ACPI_SUB_DECODE == address16_data->decode ?
 			 "Subtractive" : "Positive");
 
 	acpi_os_printf ("  Min address is %s fixed\n",
-			 ADDRESS_FIXED == address16_data->min_address_fixed ?
+			 ACPI_ADDRESS_FIXED == address16_data->min_address_fixed ?
 			 "" : "not");
 
 	acpi_os_printf ("  Max address is %s fixed\n",
-			 ADDRESS_FIXED == address16_data->max_address_fixed ?
+			 ACPI_ADDRESS_FIXED == address16_data->max_address_fixed ?
 			 "" : "not");
 
 	acpi_os_printf ("  Granularity: %08X\n",
@@ -609,7 +632,7 @@ acpi_rs_dump_address16 (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_dump_address32
+ * FUNCTION:    acpi_rs_dump_address32
  *
  * PARAMETERS:  Data            - pointer to the resource structure to dump.
  *
@@ -621,38 +644,38 @@ acpi_rs_dump_address16 (
 
 void
 acpi_rs_dump_address32 (
-	acpi_resource_data      *data)
+	union acpi_resource_data        *data)
 {
-	acpi_resource_address32 *address32_data = (acpi_resource_address32 *) data;
+	struct acpi_resource_address32 *address32_data = (struct acpi_resource_address32 *) data;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	acpi_os_printf ("32-Bit Address Space Resource\n");
 
 	switch (address32_data->resource_type) {
-	case MEMORY_RANGE:
+	case ACPI_MEMORY_RANGE:
 
 		acpi_os_printf ("  Resource Type: Memory Range\n");
 
 		switch (address32_data->attribute.memory.cache_attribute) {
-		case NON_CACHEABLE_MEMORY:
+		case ACPI_NON_CACHEABLE_MEMORY:
 			acpi_os_printf ("  Type Specific: "
 					  "Noncacheable memory\n");
 			break;
 
-		case CACHABLE_MEMORY:
+		case ACPI_CACHABLE_MEMORY:
 			acpi_os_printf ("  Type Specific: "
 					  "Cacheable memory\n");
 			break;
 
-		case WRITE_COMBINING_MEMORY:
+		case ACPI_WRITE_COMBINING_MEMORY:
 			acpi_os_printf ("  Type Specific: "
 					  "Write-combining memory\n");
 			break;
 
-		case PREFETCHABLE_MEMORY:
+		case ACPI_PREFETCHABLE_MEMORY:
 			acpi_os_printf ("  Type Specific: "
 					  "Prefetchable memory\n");
 			break;
@@ -664,39 +687,44 @@ acpi_rs_dump_address32 (
 		}
 
 		acpi_os_printf ("  Type Specific: Read%s\n",
-			READ_WRITE_MEMORY ==
+			ACPI_READ_WRITE_MEMORY ==
 			address32_data->attribute.memory.read_write_attribute ?
 			"/Write" : " Only");
 		break;
 
-	case IO_RANGE:
+	case ACPI_IO_RANGE:
 
 		acpi_os_printf ("  Resource Type: Io Range\n");
 
 		switch (address32_data->attribute.io.range_attribute) {
-			case NON_ISA_ONLY_RANGES:
-				acpi_os_printf ("  Type Specific: "
-						  "Non-ISA Io Addresses\n");
-				break;
+		case ACPI_NON_ISA_ONLY_RANGES:
+			acpi_os_printf ("  Type Specific: "
+					  "Non-ISA Io Addresses\n");
+			break;
 
-			case ISA_ONLY_RANGES:
-				acpi_os_printf ("  Type Specific: "
-						  "ISA Io Addresses\n");
-				break;
+		case ACPI_ISA_ONLY_RANGES:
+			acpi_os_printf ("  Type Specific: "
+					  "ISA Io Addresses\n");
+			break;
 
-			case ENTIRE_RANGE:
-				acpi_os_printf ("  Type Specific: "
-						  "ISA and non-ISA Io Addresses\n");
-				break;
+		case ACPI_ENTIRE_RANGE:
+			acpi_os_printf ("  Type Specific: "
+					  "ISA and non-ISA Io Addresses\n");
+			break;
 
-			default:
-				acpi_os_printf ("  Type Specific: "
-						  "Invalid Range attribute");
-				break;
-			}
+		default:
+			acpi_os_printf ("  Type Specific: "
+					  "Invalid Range attribute");
+			break;
+		}
+
+		acpi_os_printf (" Type Specific: %s Translation\n",
+			ACPI_SPARSE_TRANSLATION ==
+			address32_data->attribute.io.translation_attribute ?
+			"Sparse" : "Dense");
 		break;
 
-	case BUS_NUMBER_RANGE:
+	case ACPI_BUS_NUMBER_RANGE:
 
 		acpi_os_printf ("  Resource Type: Bus Number Range\n");
 		break;
@@ -708,19 +736,19 @@ acpi_rs_dump_address32 (
 	}
 
 	acpi_os_printf ("  Resource %s\n",
-			 CONSUMER == address32_data->producer_consumer ?
+			 ACPI_CONSUMER == address32_data->producer_consumer ?
 			 "Consumer" : "Producer");
 
 	acpi_os_printf ("  %s decode\n",
-			 SUB_DECODE == address32_data->decode ?
+			 ACPI_SUB_DECODE == address32_data->decode ?
 			 "Subtractive" : "Positive");
 
 	acpi_os_printf ("  Min address is %s fixed\n",
-			 ADDRESS_FIXED == address32_data->min_address_fixed ?
+			 ACPI_ADDRESS_FIXED == address32_data->min_address_fixed ?
 			 "" : "not ");
 
 	acpi_os_printf ("  Max address is %s fixed\n",
-			 ADDRESS_FIXED == address32_data->max_address_fixed ?
+			 ACPI_ADDRESS_FIXED == address32_data->max_address_fixed ?
 			 "" : "not ");
 
 	acpi_os_printf ("  Granularity: %08X\n",
@@ -751,7 +779,7 @@ acpi_rs_dump_address32 (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_dump_address64
+ * FUNCTION:    acpi_rs_dump_address64
  *
  * PARAMETERS:  Data            - pointer to the resource structure to dump.
  *
@@ -763,38 +791,38 @@ acpi_rs_dump_address32 (
 
 void
 acpi_rs_dump_address64 (
-	acpi_resource_data      *data)
+	union acpi_resource_data        *data)
 {
-	acpi_resource_address64 *address64_data = (acpi_resource_address64 *) data;
+	struct acpi_resource_address64 *address64_data = (struct acpi_resource_address64 *) data;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	acpi_os_printf ("64-Bit Address Space Resource\n");
 
 	switch (address64_data->resource_type) {
-	case MEMORY_RANGE:
+	case ACPI_MEMORY_RANGE:
 
 		acpi_os_printf ("  Resource Type: Memory Range\n");
 
 		switch (address64_data->attribute.memory.cache_attribute) {
-		case NON_CACHEABLE_MEMORY:
+		case ACPI_NON_CACHEABLE_MEMORY:
 			acpi_os_printf ("  Type Specific: "
 					  "Noncacheable memory\n");
 			break;
 
-		case CACHABLE_MEMORY:
+		case ACPI_CACHABLE_MEMORY:
 			acpi_os_printf ("  Type Specific: "
 					  "Cacheable memory\n");
 			break;
 
-		case WRITE_COMBINING_MEMORY:
+		case ACPI_WRITE_COMBINING_MEMORY:
 			acpi_os_printf ("  Type Specific: "
 					  "Write-combining memory\n");
 			break;
 
-		case PREFETCHABLE_MEMORY:
+		case ACPI_PREFETCHABLE_MEMORY:
 			acpi_os_printf ("  Type Specific: "
 					  "Prefetchable memory\n");
 			break;
@@ -806,39 +834,44 @@ acpi_rs_dump_address64 (
 		}
 
 		acpi_os_printf ("  Type Specific: Read%s\n",
-			READ_WRITE_MEMORY ==
+			ACPI_READ_WRITE_MEMORY ==
 			address64_data->attribute.memory.read_write_attribute ?
 			"/Write" : " Only");
 		break;
 
-	case IO_RANGE:
+	case ACPI_IO_RANGE:
 
 		acpi_os_printf ("  Resource Type: Io Range\n");
 
 		switch (address64_data->attribute.io.range_attribute) {
-			case NON_ISA_ONLY_RANGES:
-				acpi_os_printf ("  Type Specific: "
-						  "Non-ISA Io Addresses\n");
-				break;
+		case ACPI_NON_ISA_ONLY_RANGES:
+			acpi_os_printf ("  Type Specific: "
+					  "Non-ISA Io Addresses\n");
+			break;
 
-			case ISA_ONLY_RANGES:
-				acpi_os_printf ("  Type Specific: "
-						  "ISA Io Addresses\n");
-				break;
+		case ACPI_ISA_ONLY_RANGES:
+			acpi_os_printf ("  Type Specific: "
+					  "ISA Io Addresses\n");
+			break;
 
-			case ENTIRE_RANGE:
-				acpi_os_printf ("  Type Specific: "
-						  "ISA and non-ISA Io Addresses\n");
-				break;
+		case ACPI_ENTIRE_RANGE:
+			acpi_os_printf ("  Type Specific: "
+					  "ISA and non-ISA Io Addresses\n");
+			break;
 
-			default:
-				acpi_os_printf ("  Type Specific: "
-						  "Invalid Range attribute");
-				break;
-			}
+		default:
+			acpi_os_printf ("  Type Specific: "
+					  "Invalid Range attribute");
+			break;
+		}
+
+		acpi_os_printf (" Type Specific: %s Translation\n",
+			ACPI_SPARSE_TRANSLATION ==
+			address64_data->attribute.io.translation_attribute ?
+			"Sparse" : "Dense");
 		break;
 
-	case BUS_NUMBER_RANGE:
+	case ACPI_BUS_NUMBER_RANGE:
 
 		acpi_os_printf ("  Resource Type: Bus Number Range\n");
 		break;
@@ -850,35 +883,40 @@ acpi_rs_dump_address64 (
 	}
 
 	acpi_os_printf ("  Resource %s\n",
-			 CONSUMER == address64_data->producer_consumer ?
+			 ACPI_CONSUMER == address64_data->producer_consumer ?
 			 "Consumer" : "Producer");
 
 	acpi_os_printf ("  %s decode\n",
-			 SUB_DECODE == address64_data->decode ?
+			 ACPI_SUB_DECODE == address64_data->decode ?
 			 "Subtractive" : "Positive");
 
 	acpi_os_printf ("  Min address is %s fixed\n",
-			 ADDRESS_FIXED == address64_data->min_address_fixed ?
+			 ACPI_ADDRESS_FIXED == address64_data->min_address_fixed ?
 			 "" : "not ");
 
 	acpi_os_printf ("  Max address is %s fixed\n",
-			 ADDRESS_FIXED == address64_data->max_address_fixed ?
+			 ACPI_ADDRESS_FIXED == address64_data->max_address_fixed ?
 			 "" : "not ");
 
-	acpi_os_printf ("  Granularity: %16X\n",
-			 address64_data->granularity);
-
-	acpi_os_printf ("  Address range min: %16X\n",
-			 address64_data->min_address_range);
-
-	acpi_os_printf ("  Address range max: %16X\n",
-			 address64_data->max_address_range);
-
-	acpi_os_printf ("  Address translation offset: %16X\n",
-			 address64_data->address_translation_offset);
-
-	acpi_os_printf ("  Address Length: %16X\n",
-			 address64_data->address_length);
+	acpi_os_printf ("  Granularity: %8.8X%8.8X\n",
+			 ACPI_HIDWORD (address64_data->granularity),
+			 ACPI_LODWORD (address64_data->granularity));
+
+	acpi_os_printf ("  Address range min: %8.8X%8.8X\n",
+			 ACPI_HIDWORD (address64_data->min_address_range),
+			 ACPI_HIDWORD (address64_data->min_address_range));
+
+	acpi_os_printf ("  Address range max: %8.8X%8.8X\n",
+			 ACPI_HIDWORD (address64_data->max_address_range),
+			 ACPI_HIDWORD (address64_data->max_address_range));
+
+	acpi_os_printf ("  Address translation offset: %8.8X%8.8X\n",
+			 ACPI_HIDWORD (address64_data->address_translation_offset),
+			 ACPI_HIDWORD (address64_data->address_translation_offset));
+
+	acpi_os_printf ("  Address Length: %8.8X%8.8X\n",
+			 ACPI_HIDWORD (address64_data->address_length),
+			 ACPI_HIDWORD (address64_data->address_length));
 
 	if(0xFF != address64_data->resource_source.index) {
 		acpi_os_printf ("  Resource Source Index: %X\n",
@@ -893,7 +931,7 @@ acpi_rs_dump_address64 (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_dump_extended_irq
+ * FUNCTION:    acpi_rs_dump_extended_irq
  *
  * PARAMETERS:  Data            - pointer to the resource structure to dump.
  *
@@ -905,31 +943,31 @@ acpi_rs_dump_address64 (
 
 void
 acpi_rs_dump_extended_irq (
-	acpi_resource_data      *data)
+	union acpi_resource_data        *data)
 {
-	acpi_resource_ext_irq   *ext_irq_data = (acpi_resource_ext_irq *) data;
-	u8                      index = 0;
+	struct acpi_resource_ext_irq    *ext_irq_data = (struct acpi_resource_ext_irq *) data;
+	u8                              index = 0;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	acpi_os_printf ("Extended IRQ Resource\n");
 
 	acpi_os_printf ("  Resource %s\n",
-			 CONSUMER == ext_irq_data->producer_consumer ?
+			 ACPI_CONSUMER == ext_irq_data->producer_consumer ?
 			 "Consumer" : "Producer");
 
 	acpi_os_printf ("  %s\n",
-			 LEVEL_SENSITIVE == ext_irq_data->edge_level ?
+			 ACPI_LEVEL_SENSITIVE == ext_irq_data->edge_level ?
 			 "Level" : "Edge");
 
 	acpi_os_printf ("  Active %s\n",
-			 ACTIVE_LOW == ext_irq_data->active_high_low ?
+			 ACPI_ACTIVE_LOW == ext_irq_data->active_high_low ?
 			 "low" : "high");
 
 	acpi_os_printf ("  %s\n",
-			 SHARED == ext_irq_data->shared_exclusive ?
+			 ACPI_SHARED == ext_irq_data->shared_exclusive ?
 			 "Shared" : "Exclusive");
 
 	acpi_os_printf ("  Interrupts : %X ( ",
@@ -954,7 +992,7 @@ acpi_rs_dump_extended_irq (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_dump_resource_list
+ * FUNCTION:    acpi_rs_dump_resource_list
  *
  * PARAMETERS:  Data            - pointer to the resource structure to dump.
  *
@@ -966,18 +1004,18 @@ acpi_rs_dump_extended_irq (
 
 void
 acpi_rs_dump_resource_list (
-	acpi_resource       *resource)
+	struct acpi_resource        *resource)
 {
-	u8                  count = 0;
-	u8                  done = FALSE;
+	u8                          count = 0;
+	u8                          done = FALSE;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	if (acpi_dbg_level & ACPI_LV_RESOURCES && _COMPONENT & acpi_dbg_layer) {
 		while (!done) {
-			acpi_os_printf ("Resource structure %x.\n", count++);
+			acpi_os_printf ("Resource structure %X.\n", count++);
 
 			switch (resource->id) {
 			case ACPI_RSTYPE_IRQ:
@@ -989,12 +1027,12 @@ acpi_rs_dump_resource_list (
 				break;
 
 			case ACPI_RSTYPE_START_DPF:
-				acpi_rs_dump_start_dependent_functions (&resource->data);
+				acpi_rs_dump_start_depend_fns (&resource->data);
 				break;
 
 			case ACPI_RSTYPE_END_DPF:
-				acpi_os_printf ("End_dependent_functions Resource\n");
-				/* Acpi_rs_dump_end_dependent_functions (Resource->Data);*/
+				acpi_os_printf ("end_dependent_functions Resource\n");
+				/* acpi_rs_dump_end_dependent_functions (Resource->Data);*/
 				break;
 
 			case ACPI_RSTYPE_IO:
@@ -1010,8 +1048,8 @@ acpi_rs_dump_resource_list (
 				break;
 
 			case ACPI_RSTYPE_END_TAG:
-				/*Rs_dump_end_tag (Resource->Data);*/
-				acpi_os_printf ("End_tag Resource\n");
+				/*rs_dump_end_tag (Resource->Data);*/
+				acpi_os_printf ("end_tag Resource\n");
 				done = TRUE;
 				break;
 
@@ -1049,7 +1087,7 @@ acpi_rs_dump_resource_list (
 
 			}
 
-			resource = POINTER_ADD (acpi_resource, resource, resource->length);
+			resource = ACPI_PTR_ADD (struct acpi_resource, resource, resource->length);
 		}
 	}
 
@@ -1058,7 +1096,7 @@ acpi_rs_dump_resource_list (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_dump_irq_list
+ * FUNCTION:    acpi_rs_dump_irq_list
  *
  * PARAMETERS:  Data            - pointer to the routing table to dump.
  *
@@ -1070,36 +1108,37 @@ acpi_rs_dump_resource_list (
 
 void
 acpi_rs_dump_irq_list (
-	u8                  *route_table)
+	u8                              *route_table)
 {
-	u8                  *buffer = route_table;
-	u8                  count = 0;
-	u8                  done = FALSE;
-	pci_routing_table   *prt_element;
+	u8                              *buffer = route_table;
+	u8                              count = 0;
+	u8                              done = FALSE;
+	struct acpi_pci_routing_table   *prt_element;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	if (acpi_dbg_level & ACPI_LV_RESOURCES && _COMPONENT & acpi_dbg_layer) {
-		prt_element = (pci_routing_table *) buffer;
+		prt_element = ACPI_CAST_PTR (struct acpi_pci_routing_table, buffer);
 
 		while (!done) {
 			acpi_os_printf ("PCI IRQ Routing Table structure %X.\n", count++);
 
-			acpi_os_printf ("  Address: %X\n",
-					 prt_element->address);
+			acpi_os_printf ("  Address: %8.8X%8.8X\n",
+					 ACPI_HIDWORD (prt_element->address),
+					 ACPI_LODWORD (prt_element->address));
 
 			acpi_os_printf ("  Pin: %X\n", prt_element->pin);
 
 			acpi_os_printf ("  Source: %s\n", prt_element->source);
 
-			acpi_os_printf ("  Source_index: %X\n",
+			acpi_os_printf ("  source_index: %X\n",
 					 prt_element->source_index);
 
 			buffer += prt_element->length;
 
-			prt_element = (pci_routing_table *) buffer;
+			prt_element = ACPI_CAST_PTR (struct acpi_pci_routing_table, buffer);
 
 			if(0 == prt_element->length) {
 				done = TRUE;
diff -urNp linux-5400/drivers/acpi/resources/rsio.c linux-5410/drivers/acpi/resources/rsio.c
--- linux-5400/drivers/acpi/resources/rsio.c
+++ linux-5410/drivers/acpi/resources/rsio.c
@@ -1,73 +1,90 @@
 /*******************************************************************************
  *
  * Module Name: rsio - IO and DMA resource descriptors
- *              $Revision: 14 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acresrc.h"
+#include <acpi/acpi.h>
+#include <acpi/acresrc.h>
 
 #define _COMPONENT          ACPI_RESOURCES
-	 MODULE_NAME         ("rsio")
+	 ACPI_MODULE_NAME    ("rsio")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_io_resource
+ * FUNCTION:    acpi_rs_io_resource
  *
- * PARAMETERS:  Byte_stream_buffer      - Pointer to the resource input byte
+ * PARAMETERS:  byte_stream_buffer      - Pointer to the resource input byte
  *                                        stream
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes consumed from
- *                                        the Byte_stream_buffer
- *              Output_buffer           - Pointer to the user's return buffer
- *              Structure_size          - u32 pointer that is filled with
- *                                        the number of bytes in the filled
- *                                        in structure
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        consumed the byte_stream_buffer is
+ *                                        returned
+ *              output_buffer           - Pointer to the return data buffer
+ *              structure_size          - Pointer to where the number of bytes
+ *                                        in the return data struct is returned
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Take the resource byte stream and fill out the appropriate
- *              structure pointed to by the Output_buffer. Return the
+ *              structure pointed to by the output_buffer. Return the
  *              number of bytes consumed from the byte stream.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_rs_io_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size)
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size)
 {
-	u8                      *buffer = byte_stream_buffer;
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
-	u16                     temp16 = 0;
-	u8                      temp8 = 0;
-	u32                     struct_size = SIZEOF_RESOURCE (acpi_resource_io);
+	u8                              *buffer = byte_stream_buffer;
+	struct acpi_resource            *output_struct = (void *) *output_buffer;
+	u16                             temp16 = 0;
+	u8                              temp8 = 0;
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_io);
 
 
-	FUNCTION_TRACE ("Rs_io_resource");
+	ACPI_FUNCTION_TRACE ("rs_io_resource");
 
 
 	/*
@@ -86,18 +103,18 @@ acpi_rs_io_resource (
 	output_struct->data.io.io_decode = temp8 & 0x01;
 
 	/*
-	 * Check Min_base Address
+	 * Check min_base Address
 	 */
 	buffer += 1;
-	MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
+	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
 	output_struct->data.io.min_base_address = temp16;
 
 	/*
-	 * Check Max_base Address
+	 * Check max_base Address
 	 */
 	buffer += 2;
-	MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
+	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
 	output_struct->data.io.max_base_address = temp16;
 
@@ -110,7 +127,7 @@ acpi_rs_io_resource (
 	output_struct->data.io.alignment = temp8;
 
 	/*
-	 * Check Range_length
+	 * Check range_length
 	 */
 	buffer += 1;
 	temp8 = *buffer;
@@ -120,7 +137,7 @@ acpi_rs_io_resource (
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -132,41 +149,40 @@ acpi_rs_io_resource (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_fixed_io_resource
+ * FUNCTION:    acpi_rs_fixed_io_resource
  *
- * PARAMETERS:  Byte_stream_buffer      - Pointer to the resource input byte
+ * PARAMETERS:  byte_stream_buffer      - Pointer to the resource input byte
  *                                        stream
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes consumed from
- *                                        the Byte_stream_buffer
- *              Output_buffer           - Pointer to the user's return buffer
- *              Structure_size          - u32 pointer that is filled with
- *                                        the number of bytes in the filled
- *                                        in structure
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        consumed the byte_stream_buffer is
+ *                                        returned
+ *              output_buffer           - Pointer to the return data buffer
+ *              structure_size          - Pointer to where the number of bytes
+ *                                        in the return data struct is returned
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Take the resource byte stream and fill out the appropriate
- *              structure pointed to by the Output_buffer. Return the
+ *              structure pointed to by the output_buffer. Return the
  *              number of bytes consumed from the byte stream.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_rs_fixed_io_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size)
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size)
 {
-	u8                      *buffer = byte_stream_buffer;
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
-	u16                     temp16 = 0;
-	u8                      temp8 = 0;
-	u32                     struct_size = SIZEOF_RESOURCE (acpi_resource_fixed_io);
+	u8                              *buffer = byte_stream_buffer;
+	struct acpi_resource            *output_struct = (void *) *output_buffer;
+	u16                             temp16 = 0;
+	u8                              temp8 = 0;
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_fixed_io);
 
 
-	FUNCTION_TRACE ("Rs_fixed_io_resource");
+	ACPI_FUNCTION_TRACE ("rs_fixed_io_resource");
 
 
 	/*
@@ -180,12 +196,12 @@ acpi_rs_fixed_io_resource (
 	 * Check Range Base Address
 	 */
 	buffer += 1;
-	MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
+	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
 	output_struct->data.fixed_io.base_address = temp16;
 
 	/*
-	 * Check Range_length
+	 * Check range_length
 	 */
 	buffer += 2;
 	temp8 = *buffer;
@@ -195,7 +211,7 @@ acpi_rs_fixed_io_resource (
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -207,13 +223,12 @@ acpi_rs_fixed_io_resource (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_io_stream
+ * FUNCTION:    acpi_rs_io_stream
  *
- * PARAMETERS:  Linked_list             - Pointer to the resource linked list
- *              Output_buffer           - Pointer to the user's return buffer
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes of the
- *                                        Output_buffer used
+ * PARAMETERS:  linked_list             - Pointer to the resource linked list
+ *              output_buffer           - Pointer to the user's return buffer
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        used in the output_buffer is returned
  *
  * RETURN:      Status
  *
@@ -224,16 +239,16 @@ acpi_rs_fixed_io_resource (
 
 acpi_status
 acpi_rs_io_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed)
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed)
 {
-	u8                      *buffer = *output_buffer;
-	u16                     temp16 = 0;
-	u8                      temp8 = 0;
+	u8                              *buffer = *output_buffer;
+	u16                             temp16 = 0;
+	u8                              temp8 = 0;
 
 
-	FUNCTION_TRACE ("Rs_io_stream");
+	ACPI_FUNCTION_TRACE ("rs_io_stream");
 
 
 	/*
@@ -255,7 +270,7 @@ acpi_rs_io_stream (
 	 */
 	temp16 = (u16) linked_list->data.io.min_base_address;
 
-	MOVE_UNALIGNED16_TO_16 (buffer, &temp16);
+	ACPI_MOVE_16_TO_16 (buffer, &temp16);
 	buffer += 2;
 
 	/*
@@ -263,7 +278,7 @@ acpi_rs_io_stream (
 	 */
 	temp16 = (u16) linked_list->data.io.max_base_address;
 
-	MOVE_UNALIGNED16_TO_16 (buffer, &temp16);
+	ACPI_MOVE_16_TO_16 (buffer, &temp16);
 	buffer += 2;
 
 	/*
@@ -285,20 +300,19 @@ acpi_rs_io_stream (
 	/*
 	 * Return the number of bytes consumed in this operation
 	 */
-	*bytes_consumed = POINTER_DIFF (buffer, *output_buffer);
+	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_fixed_io_stream
+ * FUNCTION:    acpi_rs_fixed_io_stream
  *
- * PARAMETERS:  Linked_list             - Pointer to the resource linked list
- *              Output_buffer           - Pointer to the user's return buffer
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes of the
- *                                        Output_buffer used
+ * PARAMETERS:  linked_list             - Pointer to the resource linked list
+ *              output_buffer           - Pointer to the user's return buffer
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        used in the output_buffer is returned
  *
  * RETURN:      Status
  *
@@ -309,16 +323,16 @@ acpi_rs_io_stream (
 
 acpi_status
 acpi_rs_fixed_io_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed)
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed)
 {
-	u8                      *buffer = *output_buffer;
-	u16                     temp16 = 0;
-	u8                      temp8 = 0;
+	u8                              *buffer = *output_buffer;
+	u16                             temp16 = 0;
+	u8                              temp8 = 0;
 
 
-	FUNCTION_TRACE ("Rs_fixed_io_stream");
+	ACPI_FUNCTION_TRACE ("rs_fixed_io_stream");
 
 
 	/*
@@ -333,7 +347,7 @@ acpi_rs_fixed_io_stream (
 	 */
 	temp16 = (u16) linked_list->data.fixed_io.base_address;
 
-	MOVE_UNALIGNED16_TO_16 (buffer, &temp16);
+	ACPI_MOVE_16_TO_16 (buffer, &temp16);
 	buffer += 2;
 
 	/*
@@ -347,49 +361,48 @@ acpi_rs_fixed_io_stream (
 	/*
 	 * Return the number of bytes consumed in this operation
 	 */
-	*bytes_consumed = POINTER_DIFF (buffer, *output_buffer);
+	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_dma_resource
+ * FUNCTION:    acpi_rs_dma_resource
  *
- * PARAMETERS:  Byte_stream_buffer      - Pointer to the resource input byte
+ * PARAMETERS:  byte_stream_buffer      - Pointer to the resource input byte
  *                                        stream
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes consumed from
- *                                        the Byte_stream_buffer
- *              Output_buffer           - Pointer to the user's return buffer
- *              Structure_size          - u32 pointer that is filled with
- *                                        the number of bytes in the filled
- *                                        in structure
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        consumed the byte_stream_buffer is
+ *                                        returned
+ *              output_buffer           - Pointer to the return data buffer
+ *              structure_size          - Pointer to where the number of bytes
+ *                                        in the return data struct is returned
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Take the resource byte stream and fill out the appropriate
- *              structure pointed to by the Output_buffer. Return the
+ *              structure pointed to by the output_buffer. Return the
  *              number of bytes consumed from the byte stream.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_rs_dma_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size)
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size)
 {
-	u8                      *buffer = byte_stream_buffer;
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
-	u8                      temp8 = 0;
-	u8                      index;
-	u8                      i;
-	u32                     struct_size = SIZEOF_RESOURCE (acpi_resource_dma);
+	u8                              *buffer = byte_stream_buffer;
+	struct acpi_resource            *output_struct = (void *) *output_buffer;
+	u8                              temp8 = 0;
+	u8                              index;
+	u8                              i;
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_dma);
 
 
-	FUNCTION_TRACE ("Rs_dma_resource");
+	ACPI_FUNCTION_TRACE ("rs_dma_resource");
 
 
 	/*
@@ -404,7 +417,7 @@ acpi_rs_dma_resource (
 	buffer += 1;
 	temp8 = *buffer;
 
-	/* Decode the IRQ bits */
+	/* Decode the DMA channel bits */
 
 	for (i = 0, index = 0; index < 8; index++) {
 		if ((temp8 >> index) & 0x01) {
@@ -412,13 +425,16 @@ acpi_rs_dma_resource (
 			i++;
 		}
 	}
-	output_struct->data.dma.number_of_channels = i;
 
+	/* Zero DMA channels is valid */
 
-	/*
-	 * Calculate the structure size based upon the number of interrupts
-	 */
-	struct_size += (output_struct->data.dma.number_of_channels - 1) * 4;
+	output_struct->data.dma.number_of_channels = i;
+	if (i > 0) {
+		/*
+		 * Calculate the structure size based upon the number of interrupts
+		 */
+		struct_size += ((acpi_size) i - 1) * 4;
+	}
 
 	/*
 	 * Point to Byte 2
@@ -432,6 +448,7 @@ acpi_rs_dma_resource (
 	output_struct->data.dma.transfer = temp8 & 0x03;
 
 	if (0x03 == output_struct->data.dma.transfer) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid DMA.Transfer preference (3)\n"));
 		return_ACPI_STATUS (AE_BAD_DATA);
 	}
 
@@ -448,7 +465,7 @@ acpi_rs_dma_resource (
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -460,13 +477,12 @@ acpi_rs_dma_resource (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_dma_stream
+ * FUNCTION:    acpi_rs_dma_stream
  *
- * PARAMETERS:  Linked_list             - Pointer to the resource linked list
- *              Output_buffer           - Pointer to the user's return buffer
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes of the
- *                                        Output_buffer used
+ * PARAMETERS:  linked_list             - Pointer to the resource linked list
+ *              output_buffer           - Pointer to the user's return buffer
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        used in the output_buffer is returned
  *
  * RETURN:      Status
  *
@@ -477,17 +493,17 @@ acpi_rs_dma_resource (
 
 acpi_status
 acpi_rs_dma_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed)
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed)
 {
-	u8                      *buffer = *output_buffer;
-	u16                     temp16 = 0;
-	u8                      temp8 = 0;
-	u8                      index;
+	u8                              *buffer = *output_buffer;
+	u16                             temp16 = 0;
+	u8                              temp8 = 0;
+	u8                              index;
 
 
-	FUNCTION_TRACE ("Rs_dma_stream");
+	ACPI_FUNCTION_TRACE ("rs_dma_stream");
 
 
 	/*
@@ -523,7 +539,7 @@ acpi_rs_dma_stream (
 	/*
 	 * Return the number of bytes consumed in this operation
 	 */
-	*bytes_consumed = POINTER_DIFF (buffer, *output_buffer);
+	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
 
diff -urNp linux-5400/drivers/acpi/resources/rsirq.c linux-5410/drivers/acpi/resources/rsirq.c
--- linux-5400/drivers/acpi/resources/rsirq.c
+++ linux-5410/drivers/acpi/resources/rsirq.c
@@ -1,75 +1,92 @@
 /*******************************************************************************
  *
  * Module Name: rsirq - IRQ resource descriptors
- *              $Revision: 18 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acresrc.h"
+#include <acpi/acpi.h>
+#include <acpi/acresrc.h>
 
 #define _COMPONENT          ACPI_RESOURCES
-	 MODULE_NAME         ("rsirq")
+	 ACPI_MODULE_NAME    ("rsirq")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_irq_resource
+ * FUNCTION:    acpi_rs_irq_resource
  *
- * PARAMETERS:  Byte_stream_buffer      - Pointer to the resource input byte
+ * PARAMETERS:  byte_stream_buffer      - Pointer to the resource input byte
  *                                        stream
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes consumed from
- *                                        the Byte_stream_buffer
- *              Output_buffer           - Pointer to the user's return buffer
- *              Structure_size          - u32 pointer that is filled with
- *                                        the number of bytes in the filled
- *                                        in structure
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        consumed the byte_stream_buffer is
+ *                                        returned
+ *              output_buffer           - Pointer to the return data buffer
+ *              structure_size          - Pointer to where the number of bytes
+ *                                        in the return data struct is returned
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Take the resource byte stream and fill out the appropriate
- *              structure pointed to by the Output_buffer. Return the
+ *              structure pointed to by the output_buffer. Return the
  *              number of bytes consumed from the byte stream.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_rs_irq_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size)
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size)
 {
-	u8                      *buffer = byte_stream_buffer;
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
-	u16                     temp16 = 0;
-	u8                      temp8 = 0;
-	u8                      index;
-	u8                      i;
-	u32                     struct_size = SIZEOF_RESOURCE (acpi_resource_irq);
+	u8                              *buffer = byte_stream_buffer;
+	struct acpi_resource            *output_struct = (void *) *output_buffer;
+	u16                             temp16 = 0;
+	u8                              temp8 = 0;
+	u8                              index;
+	u8                              i;
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_irq);
 
 
-	FUNCTION_TRACE ("Rs_irq_resource");
+	ACPI_FUNCTION_TRACE ("rs_irq_resource");
 
 
 	/*
@@ -84,24 +101,28 @@ acpi_rs_irq_resource (
 	 * Point to the 16-bits of Bytes 1 and 2
 	 */
 	buffer += 1;
-	MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
+	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
 	output_struct->data.irq.number_of_interrupts = 0;
 
 	/* Decode the IRQ bits */
 
 	for (i = 0, index = 0; index < 16; index++) {
-		if((temp16 >> index) & 0x01) {
+		if ((temp16 >> index) & 0x01) {
 			output_struct->data.irq.interrupts[i] = index;
 			i++;
 		}
 	}
-	output_struct->data.irq.number_of_interrupts = i;
 
-	/*
-	 * Calculate the structure size based upon the number of interrupts
-	 */
-	struct_size += (output_struct->data.irq.number_of_interrupts - 1) * 4;
+	/* Zero interrupts is valid */
+
+	output_struct->data.irq.number_of_interrupts = i;
+	if (i > 0) {
+		/*
+		 * Calculate the structure size based upon the number of interrupts
+		 */
+		struct_size += ((acpi_size) i - 1) * 4;
+	}
 
 	/*
 	 * Point to Byte 3 if it is used
@@ -114,22 +135,21 @@ acpi_rs_irq_resource (
 		 * Check for HE, LL or HL
 		 */
 		if (temp8 & 0x01) {
-			output_struct->data.irq.edge_level = EDGE_SENSITIVE;
-			output_struct->data.irq.active_high_low = ACTIVE_HIGH;
+			output_struct->data.irq.edge_level = ACPI_EDGE_SENSITIVE;
+			output_struct->data.irq.active_high_low = ACPI_ACTIVE_HIGH;
 		}
-
 		else {
 			if (temp8 & 0x8) {
-				output_struct->data.irq.edge_level = LEVEL_SENSITIVE;
-				output_struct->data.irq.active_high_low = ACTIVE_LOW;
+				output_struct->data.irq.edge_level = ACPI_LEVEL_SENSITIVE;
+				output_struct->data.irq.active_high_low = ACPI_ACTIVE_LOW;
 			}
-
 			else {
 				/*
 				 * Only _LL and _HE polarity/trigger interrupts
 				 * are allowed (ACPI spec v1.0b ection 6.4.2.1),
 				 * so an error will occur if we reach this point
 				 */
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid interrupt polarity/trigger in resource list\n"));
 				return_ACPI_STATUS (AE_BAD_DATA);
 			}
 		}
@@ -139,21 +159,20 @@ acpi_rs_irq_resource (
 		 */
 		output_struct->data.irq.shared_exclusive = (temp8 >> 3) & 0x01;
 	}
-
 	else {
 		/*
 		 * Assume Edge Sensitive, Active High, Non-Sharable
 		 * per ACPI Specification
 		 */
-		output_struct->data.irq.edge_level = EDGE_SENSITIVE;
-		output_struct->data.irq.active_high_low = ACTIVE_HIGH;
-		output_struct->data.irq.shared_exclusive = EXCLUSIVE;
+		output_struct->data.irq.edge_level = ACPI_EDGE_SENSITIVE;
+		output_struct->data.irq.active_high_low = ACPI_ACTIVE_HIGH;
+		output_struct->data.irq.shared_exclusive = ACPI_EXCLUSIVE;
 	}
 
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -165,13 +184,12 @@ acpi_rs_irq_resource (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_irq_stream
+ * FUNCTION:    acpi_rs_irq_stream
  *
- * PARAMETERS:  Linked_list             - Pointer to the resource linked list
- *              Output_buffer           - Pointer to the user's return buffer
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes of the
- *                                        Output_buffer used
+ * PARAMETERS:  linked_list             - Pointer to the resource linked list
+ *              output_buffer           - Pointer to the user's return buffer
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        used in the output_buffer is returned
  *
  * RETURN:      Status
  *
@@ -182,34 +200,33 @@ acpi_rs_irq_resource (
 
 acpi_status
 acpi_rs_irq_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed)
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed)
 {
-	u8                      *buffer = *output_buffer;
-	u16                     temp16 = 0;
-	u8                      temp8 = 0;
-	u8                      index;
-	u8                      IRQinfo_byte_needed;
+	u8                              *buffer = *output_buffer;
+	u16                             temp16 = 0;
+	u8                              temp8 = 0;
+	u8                              index;
+	u8                              IRqinfo_byte_needed;
 
 
-	FUNCTION_TRACE ("Rs_irq_stream");
+	ACPI_FUNCTION_TRACE ("rs_irq_stream");
 
 
 	/*
 	 * The descriptor field is set based upon whether a third byte is
 	 * needed to contain the IRQ Information.
 	 */
-	if (EDGE_SENSITIVE == linked_list->data.irq.edge_level &&
-		ACTIVE_HIGH == linked_list->data.irq.active_high_low &&
-		EXCLUSIVE == linked_list->data.irq.shared_exclusive) {
+	if (ACPI_EDGE_SENSITIVE == linked_list->data.irq.edge_level &&
+		ACPI_ACTIVE_HIGH == linked_list->data.irq.active_high_low &&
+		ACPI_EXCLUSIVE == linked_list->data.irq.shared_exclusive) {
 		*buffer = 0x22;
-		IRQinfo_byte_needed = FALSE;
+		IRqinfo_byte_needed = FALSE;
 	}
-
 	else {
 		*buffer = 0x23;
-		IRQinfo_byte_needed = TRUE;
+		IRqinfo_byte_needed = TRUE;
 	}
 
 	buffer += 1;
@@ -225,22 +242,21 @@ acpi_rs_irq_stream (
 		temp16 |= 0x1 << temp8;
 	}
 
-	MOVE_UNALIGNED16_TO_16 (buffer, &temp16);
+	ACPI_MOVE_16_TO_16 (buffer, &temp16);
 	buffer += 2;
 
 	/*
 	 * Set the IRQ Info byte if needed.
 	 */
-	if (IRQinfo_byte_needed) {
+	if (IRqinfo_byte_needed) {
 		temp8 = 0;
 		temp8 = (u8) ((linked_list->data.irq.shared_exclusive &
 				 0x01) << 4);
 
-		if (LEVEL_SENSITIVE == linked_list->data.irq.edge_level &&
-			ACTIVE_LOW == linked_list->data.irq.active_high_low) {
+		if (ACPI_LEVEL_SENSITIVE == linked_list->data.irq.edge_level &&
+			ACPI_ACTIVE_LOW == linked_list->data.irq.active_high_low) {
 			temp8 |= 0x08;
 		}
-
 		else {
 			temp8 |= 0x01;
 		}
@@ -252,57 +268,56 @@ acpi_rs_irq_stream (
 	/*
 	 * Return the number of bytes consumed in this operation
 	 */
-	*bytes_consumed = POINTER_DIFF (buffer, *output_buffer);
+	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_extended_irq_resource
+ * FUNCTION:    acpi_rs_extended_irq_resource
  *
- * PARAMETERS:  Byte_stream_buffer      - Pointer to the resource input byte
+ * PARAMETERS:  byte_stream_buffer      - Pointer to the resource input byte
  *                                        stream
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes consumed from
- *                                        the Byte_stream_buffer
- *              Output_buffer           - Pointer to the user's return buffer
- *              Structure_size          - u32 pointer that is filled with
- *                                        the number of bytes in the filled
- *                                        in structure
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        consumed the byte_stream_buffer is
+ *                                        returned
+ *              output_buffer           - Pointer to the return data buffer
+ *              structure_size          - Pointer to where the number of bytes
+ *                                        in the return data struct is returned
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Take the resource byte stream and fill out the appropriate
- *              structure pointed to by the Output_buffer. Return the
+ *              structure pointed to by the output_buffer. Return the
  *              number of bytes consumed from the byte stream.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_rs_extended_irq_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size)
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size)
 {
-	u8                      *buffer = byte_stream_buffer;
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
-	u16                     temp16 = 0;
-	u8                      temp8 = 0;
-	NATIVE_CHAR             *temp_ptr;
-	u8                      index;
-	u32                     struct_size = SIZEOF_RESOURCE (acpi_resource_ext_irq);
+	u8                              *buffer = byte_stream_buffer;
+	struct acpi_resource            *output_struct = (void *) *output_buffer;
+	u16                             temp16 = 0;
+	u8                              temp8 = 0;
+	u8                              *temp_ptr;
+	u8                              index;
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_ext_irq);
 
 
-	FUNCTION_TRACE ("Rs_extended_irq_resource");
+	ACPI_FUNCTION_TRACE ("rs_extended_irq_resource");
 
 
 	/*
 	 * Point past the Descriptor to get the number of bytes consumed
 	 */
 	buffer += 1;
-	MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
+	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
 	*bytes_consumed = temp16 + 3;
 	output_struct->id = ACPI_RSTYPE_EXT_IRQ;
@@ -316,28 +331,20 @@ acpi_rs_extended_irq_resource (
 	output_struct->data.extended_irq.producer_consumer = temp8 & 0x01;
 
 	/*
-	 * Check for HE, LL or HL
+	 * Check for Interrupt Mode
+	 *
+	 * The definition of an Extended IRQ changed between ACPI spec v1.0b
+	 * and ACPI spec 2.0 (section 6.4.3.6 in both).
+	 *
+	 * - Edge/Level are defined opposite in the table vs the headers
 	 */
-	if(temp8 & 0x02) {
-		output_struct->data.extended_irq.edge_level = EDGE_SENSITIVE;
-		output_struct->data.extended_irq.active_high_low = ACTIVE_HIGH;
-	}
+	output_struct->data.extended_irq.edge_level =
+			   (temp8 & 0x2) ? ACPI_EDGE_SENSITIVE : ACPI_LEVEL_SENSITIVE;
 
-	else {
-		if(temp8 & 0x4) {
-			output_struct->data.extended_irq.edge_level = LEVEL_SENSITIVE;
-			output_struct->data.extended_irq.active_high_low = ACTIVE_LOW;
-		}
-
-		else {
-			/*
-			 * Only _LL and _HE polarity/trigger interrupts
-			 * are allowed (ACPI spec v1.0b ection 6.4.2.1),
-			 * so an error will occur if we reach this point
-			 */
-			return_ACPI_STATUS (AE_BAD_DATA);
-		}
-	}
+	/*
+	 * Check Interrupt Polarity
+	 */
+	output_struct->data.extended_irq.active_high_low = (temp8 >> 2) & 0x1;
 
 	/*
 	 * Check for sharable
@@ -367,8 +374,8 @@ acpi_rs_extended_irq_resource (
 	 * Cycle through every IRQ in the table
 	 */
 	for (index = 0; index < temp8; index++) {
-		output_struct->data.extended_irq.interrupts[index] =
-				(u32)*buffer;
+		ACPI_MOVE_32_TO_32 (
+			&output_struct->data.extended_irq.interrupts[index], buffer);
 
 		/* Point to the next IRQ */
 
@@ -383,7 +390,7 @@ acpi_rs_extended_irq_resource (
 	 * stream that are default.
 	 */
 	if (*bytes_consumed >
-		(u32)(output_struct->data.extended_irq.number_of_interrupts * 4) + 5) {
+		((acpi_size) output_struct->data.extended_irq.number_of_interrupts * 4) + 5) {
 		/* Dereference the Index */
 
 		temp8 = *buffer;
@@ -397,14 +404,13 @@ acpi_rs_extended_irq_resource (
 		 * Point the String pointer to the end of this structure.
 		 */
 		output_struct->data.extended_irq.resource_source.string_ptr =
-				(NATIVE_CHAR *)(output_struct + struct_size);
+				(char *)(output_struct + struct_size);
 
-		temp_ptr = output_struct->data.extended_irq.resource_source.string_ptr;
+		temp_ptr = (u8 *) output_struct->data.extended_irq.resource_source.string_ptr;
 
 		/* Copy the string into the buffer */
 
 		index = 0;
-
 		while (0x00 != *buffer) {
 			*temp_ptr = *buffer;
 
@@ -420,14 +426,13 @@ acpi_rs_extended_irq_resource (
 		output_struct->data.extended_irq.resource_source.string_length = index + 1;
 
 		/*
-		 * In order for the Struct_size to fall on a 32-bit boundary,
+		 * In order for the struct_size to fall on a 32-bit boundary,
 		 * calculate the length of the string and expand the
-		 * Struct_size to the next 32-bit boundary.
+		 * struct_size to the next 32-bit boundary.
 		 */
 		temp8 = (u8) (index + 1);
-		struct_size += ROUND_UP_TO_32_bITS (temp8);
+		struct_size += ACPI_ROUND_UP_to_32_bITS (temp8);
 	}
-
 	else {
 		output_struct->data.extended_irq.resource_source.index = 0x00;
 		output_struct->data.extended_irq.resource_source.string_length = 0;
@@ -437,7 +442,7 @@ acpi_rs_extended_irq_resource (
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -449,13 +454,12 @@ acpi_rs_extended_irq_resource (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_extended_irq_stream
+ * FUNCTION:    acpi_rs_extended_irq_stream
  *
- * PARAMETERS:  Linked_list             - Pointer to the resource linked list
- *              Output_buffer           - Pointer to the user's return buffer
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes of the
- *                                        Output_buffer used
+ * PARAMETERS:  linked_list             - Pointer to the resource linked list
+ *              output_buffer           - Pointer to the user's return buffer
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        used in the output_buffer is returned
  *
  * RETURN:      Status
  *
@@ -466,18 +470,18 @@ acpi_rs_extended_irq_resource (
 
 acpi_status
 acpi_rs_extended_irq_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed)
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed)
 {
-	u8                      *buffer = *output_buffer;
-	u16                     *length_field;
-	u8                      temp8 = 0;
-	u8                      index;
-	NATIVE_CHAR             *temp_pointer = NULL;
+	u8                              *buffer = *output_buffer;
+	u16                             *length_field;
+	u8                              temp8 = 0;
+	u8                              index;
+	char                            *temp_pointer = NULL;
 
 
-	FUNCTION_TRACE ("Rs_extended_irq_stream");
+	ACPI_FUNCTION_TRACE ("rs_extended_irq_stream");
 
 
 	/*
@@ -489,7 +493,7 @@ acpi_rs_extended_irq_stream (
 	/*
 	 * Set a pointer to the Length field - to be filled in later
 	 */
-	length_field = (u16 *)buffer;
+	length_field = ACPI_CAST_PTR (u16, buffer);
 	buffer += 2;
 
 	/*
@@ -498,14 +502,24 @@ acpi_rs_extended_irq_stream (
 	temp8 = (u8)(linked_list->data.extended_irq.producer_consumer & 0x01);
 	temp8 |= ((linked_list->data.extended_irq.shared_exclusive & 0x01) << 3);
 
-	if (LEVEL_SENSITIVE == linked_list->data.extended_irq.edge_level &&
-	   ACTIVE_LOW == linked_list->data.extended_irq.active_high_low) {
-		temp8 |= 0x04;
-	}
-	else {
-		temp8 |= 0x02;
+	/*
+	 * Set the Interrupt Mode
+	 *
+	 * The definition of an Extended IRQ changed between ACPI spec v1.0b
+	 * and ACPI spec 2.0 (section 6.4.3.6 in both).  This code does not
+	 * implement the more restrictive definition of 1.0b
+	 *
+	 * - Edge/Level are defined opposite in the table vs the headers
+	 */
+	if (ACPI_EDGE_SENSITIVE == linked_list->data.extended_irq.edge_level) {
+		temp8 |= 0x2;
 	}
 
+	/*
+	 * Set the Interrupt Polarity
+	 */
+	temp8 |= ((linked_list->data.extended_irq.active_high_low & 0x1) << 2);
+
 	*buffer = temp8;
 	buffer += 1;
 
@@ -519,7 +533,7 @@ acpi_rs_extended_irq_stream (
 
 	for (index = 0; index < linked_list->data.extended_irq.number_of_interrupts;
 		 index++) {
-		MOVE_UNALIGNED32_TO_32 (buffer,
+		ACPI_MOVE_32_TO_32 (buffer,
 				  &linked_list->data.extended_irq.interrupts[index]);
 		buffer += 4;
 	}
@@ -531,25 +545,25 @@ acpi_rs_extended_irq_stream (
 		*buffer = (u8) linked_list->data.extended_irq.resource_source.index;
 		buffer += 1;
 
-		temp_pointer = (NATIVE_CHAR *) buffer;
+		temp_pointer = (char *) buffer;
 
 		/*
 		 * Copy the string
 		 */
-		STRCPY (temp_pointer,
+		ACPI_STRCPY (temp_pointer,
 			linked_list->data.extended_irq.resource_source.string_ptr);
 
 		/*
 		 * Buffer needs to be set to the length of the sting + one for the
 		 * terminating null
 		 */
-		buffer += (STRLEN (linked_list->data.extended_irq.resource_source.string_ptr) + 1);
+		buffer += (acpi_size)(ACPI_STRLEN (linked_list->data.extended_irq.resource_source.string_ptr) + 1);
 	}
 
 	/*
 	 * Return the number of bytes consumed in this operation
 	 */
-	*bytes_consumed = POINTER_DIFF (buffer, *output_buffer);
+	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 
 	/*
 	 * Set the length field to the number of bytes consumed
diff -urNp linux-5400/drivers/acpi/resources/rslist.c linux-5410/drivers/acpi/resources/rslist.c
--- linux-5400/drivers/acpi/resources/rslist.c
+++ linux-5410/drivers/acpi/resources/rslist.c
@@ -1,41 +1,59 @@
 /*******************************************************************************
  *
  * Module Name: rslist - Linked list utilities
- *              $Revision: 19 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acresrc.h"
+#include <acpi/acpi.h>
+#include <acpi/acresrc.h>
 
 #define _COMPONENT          ACPI_RESOURCES
-	 MODULE_NAME         ("rslist")
+	 ACPI_MODULE_NAME    ("rslist")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_get_resource_type
+ * FUNCTION:    acpi_rs_get_resource_type
  *
- * PARAMETERS:  Resource_start_byte     - Byte 0 of a resource descriptor
+ * PARAMETERS:  resource_start_byte     - Byte 0 of a resource descriptor
  *
  * RETURN:      The Resource Type (Name) with no extraneous bits
  *
@@ -46,31 +64,34 @@
 
 u8
 acpi_rs_get_resource_type (
-	u8                      resource_start_byte)
+	u8                              resource_start_byte)
 {
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	/*
 	 * Determine if this is a small or large resource
 	 */
-	switch (resource_start_byte & RESOURCE_DESC_TYPE_MASK) {
-	case RESOURCE_DESC_TYPE_SMALL:
+	switch (resource_start_byte & ACPI_RDESC_TYPE_MASK) {
+	case ACPI_RDESC_TYPE_SMALL:
 
 		/*
 		 * Small Resource Type -- Only bits 6:3 are valid
 		 */
-		return ((u8) (resource_start_byte & RESOURCE_DESC_SMALL_MASK));
-		break;
+		return ((u8) (resource_start_byte & ACPI_RDESC_SMALL_MASK));
 
 
-	case RESOURCE_DESC_TYPE_LARGE:
+	case ACPI_RDESC_TYPE_LARGE:
 
 		/*
 		 * Large Resource Type -- All bits are valid
 		 */
 		return (resource_start_byte);
+
+
+	default:
+		/* No other types of resource descriptor */
 		break;
 	}
 
@@ -80,11 +101,11 @@ acpi_rs_get_resource_type (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_byte_stream_to_list
+ * FUNCTION:    acpi_rs_byte_stream_to_list
  *
- * PARAMETERS:  Byte_stream_buffer      - Pointer to the resource byte stream
- *              Byte_stream_buffer_length - Length of Byte_stream_buffer
- *              Output_buffer           - Pointer to the buffer that will
+ * PARAMETERS:  byte_stream_buffer      - Pointer to the resource byte stream
+ *              byte_stream_buffer_length - Length of byte_stream_buffer
+ *              output_buffer           - Pointer to the buffer that will
  *                                        contain the output structures
  *
  * RETURN:      Status
@@ -96,185 +117,184 @@ acpi_rs_get_resource_type (
 
 acpi_status
 acpi_rs_byte_stream_to_list (
-	u8                      *byte_stream_buffer,
-	u32                     byte_stream_buffer_length,
-	u8                      **output_buffer)
+	u8                              *byte_stream_buffer,
+	u32                             byte_stream_buffer_length,
+	u8                              *output_buffer)
 {
-	acpi_status             status;
-	u32                     bytes_parsed = 0;
-	u8                      resource_type = 0;
-	u32                     bytes_consumed = 0;
-	u8                      **buffer = output_buffer;
-	u32                     structure_size = 0;
-	u8                      end_tag_processed = FALSE;
+	acpi_status                     status;
+	acpi_size                       bytes_parsed = 0;
+	u8                              resource_type = 0;
+	acpi_size                       bytes_consumed = 0;
+	u8                              *buffer = output_buffer;
+	acpi_size                       structure_size = 0;
+	u8                              end_tag_processed = FALSE;
+	struct acpi_resource            *resource;
 
-
-	FUNCTION_TRACE ("Rs_byte_stream_to_list");
+	ACPI_FUNCTION_TRACE ("rs_byte_stream_to_list");
 
 
 	while (bytes_parsed < byte_stream_buffer_length &&
-			FALSE == end_tag_processed) {
+			!end_tag_processed) {
 		/*
 		 * The next byte in the stream is the resource type
 		 */
 		resource_type = acpi_rs_get_resource_type (*byte_stream_buffer);
 
 		switch (resource_type) {
-		case RESOURCE_DESC_MEMORY_24:
+		case ACPI_RDESC_TYPE_MEMORY_24:
 			/*
 			 * 24-Bit Memory Resource
 			 */
 			status = acpi_rs_memory24_resource (byte_stream_buffer,
-					 &bytes_consumed, buffer, &structure_size);
+					 &bytes_consumed, &buffer, &structure_size);
 			break;
 
 
-		case RESOURCE_DESC_LARGE_VENDOR:
+		case ACPI_RDESC_TYPE_LARGE_VENDOR:
 			/*
 			 * Vendor Defined Resource
 			 */
 			status = acpi_rs_vendor_resource (byte_stream_buffer,
-					 &bytes_consumed, buffer, &structure_size);
+					 &bytes_consumed, &buffer, &structure_size);
 			break;
 
 
-		case RESOURCE_DESC_MEMORY_32:
+		case ACPI_RDESC_TYPE_MEMORY_32:
 			/*
 			 * 32-Bit Memory Range Resource
 			 */
 			status = acpi_rs_memory32_range_resource (byte_stream_buffer,
-					 &bytes_consumed, buffer, &structure_size);
+					 &bytes_consumed, &buffer, &structure_size);
 			break;
 
 
-		case RESOURCE_DESC_FIXED_MEMORY_32:
+		case ACPI_RDESC_TYPE_FIXED_MEMORY_32:
 			/*
 			 * 32-Bit Fixed Memory Resource
 			 */
 			status = acpi_rs_fixed_memory32_resource (byte_stream_buffer,
-					 &bytes_consumed, buffer, &structure_size);
+					 &bytes_consumed, &buffer, &structure_size);
 			break;
 
 
-		case RESOURCE_DESC_QWORD_ADDRESS_SPACE:
+		case ACPI_RDESC_TYPE_QWORD_ADDRESS_SPACE:
 			/*
 			 * 64-Bit Address Resource
 			 */
 			status = acpi_rs_address64_resource (byte_stream_buffer,
-					 &bytes_consumed, buffer, &structure_size);
+					 &bytes_consumed, &buffer, &structure_size);
 			break;
 
 
-		case RESOURCE_DESC_DWORD_ADDRESS_SPACE:
+		case ACPI_RDESC_TYPE_DWORD_ADDRESS_SPACE:
 			/*
 			 * 32-Bit Address Resource
 			 */
 			status = acpi_rs_address32_resource (byte_stream_buffer,
-					 &bytes_consumed, buffer, &structure_size);
+					 &bytes_consumed, &buffer, &structure_size);
 			break;
 
 
-		case RESOURCE_DESC_WORD_ADDRESS_SPACE:
+		case ACPI_RDESC_TYPE_WORD_ADDRESS_SPACE:
 			/*
 			 * 16-Bit Address Resource
 			 */
 			status = acpi_rs_address16_resource (byte_stream_buffer,
-					 &bytes_consumed, buffer, &structure_size);
+					 &bytes_consumed, &buffer, &structure_size);
 			break;
 
 
-		case RESOURCE_DESC_EXTENDED_XRUPT:
+		case ACPI_RDESC_TYPE_EXTENDED_XRUPT:
 			/*
 			 * Extended IRQ
 			 */
 			status = acpi_rs_extended_irq_resource (byte_stream_buffer,
-					 &bytes_consumed, buffer, &structure_size);
+					 &bytes_consumed, &buffer, &structure_size);
 			break;
 
 
-		case RESOURCE_DESC_IRQ_FORMAT:
+		case ACPI_RDESC_TYPE_IRQ_FORMAT:
 			/*
 			 * IRQ Resource
 			 */
 			status = acpi_rs_irq_resource (byte_stream_buffer,
-					 &bytes_consumed, buffer, &structure_size);
+					 &bytes_consumed, &buffer, &structure_size);
 			break;
 
 
-		case RESOURCE_DESC_DMA_FORMAT:
+		case ACPI_RDESC_TYPE_DMA_FORMAT:
 			/*
 			 * DMA Resource
 			 */
 			status = acpi_rs_dma_resource (byte_stream_buffer,
-					 &bytes_consumed, buffer, &structure_size);
+					 &bytes_consumed, &buffer, &structure_size);
 			break;
 
 
-		case RESOURCE_DESC_START_DEPENDENT:
+		case ACPI_RDESC_TYPE_START_DEPENDENT:
 			/*
 			 * Start Dependent Functions Resource
 			 */
-			status = acpi_rs_start_dependent_functions_resource (byte_stream_buffer,
-					 &bytes_consumed, buffer, &structure_size);
+			status = acpi_rs_start_depend_fns_resource (byte_stream_buffer,
+					 &bytes_consumed, &buffer, &structure_size);
 			break;
 
 
-		case RESOURCE_DESC_END_DEPENDENT:
+		case ACPI_RDESC_TYPE_END_DEPENDENT:
 			/*
 			 * End Dependent Functions Resource
 			 */
-			status = acpi_rs_end_dependent_functions_resource (byte_stream_buffer,
-					 &bytes_consumed, buffer, &structure_size);
+			status = acpi_rs_end_depend_fns_resource (byte_stream_buffer,
+					 &bytes_consumed, &buffer, &structure_size);
 			break;
 
 
-		case RESOURCE_DESC_IO_PORT:
+		case ACPI_RDESC_TYPE_IO_PORT:
 			/*
 			 * IO Port Resource
 			 */
 			status = acpi_rs_io_resource (byte_stream_buffer,
-					 &bytes_consumed, buffer, &structure_size);
+					 &bytes_consumed, &buffer, &structure_size);
 			break;
 
 
-		case RESOURCE_DESC_FIXED_IO_PORT:
+		case ACPI_RDESC_TYPE_FIXED_IO_PORT:
 			/*
 			 * Fixed IO Port Resource
 			 */
 			status = acpi_rs_fixed_io_resource (byte_stream_buffer,
-					 &bytes_consumed, buffer, &structure_size);
+					 &bytes_consumed, &buffer, &structure_size);
 			break;
 
 
-		case RESOURCE_DESC_SMALL_VENDOR:
+		case ACPI_RDESC_TYPE_SMALL_VENDOR:
 			/*
 			 * Vendor Specific Resource
 			 */
 			status = acpi_rs_vendor_resource (byte_stream_buffer,
-					 &bytes_consumed, buffer, &structure_size);
+					 &bytes_consumed, &buffer, &structure_size);
 			break;
 
 
-		case RESOURCE_DESC_END_TAG:
+		case ACPI_RDESC_TYPE_END_TAG:
 			/*
 			 * End Tag
 			 */
 			end_tag_processed = TRUE;
 			status = acpi_rs_end_tag_resource (byte_stream_buffer,
-					 &bytes_consumed, buffer, &structure_size);
+					 &bytes_consumed, &buffer, &structure_size);
 			break;
 
 
 		default:
 			/*
-			 * Invalid/Unknowns resource type
+			 * Invalid/Unknown resource type
 			 */
-			status = AE_AML_ERROR;
+			status = AE_AML_INVALID_RESOURCE_TYPE;
 			break;
 		}
 
-
-		if (!ACPI_SUCCESS(status)) {
+		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
 
@@ -291,15 +311,17 @@ acpi_rs_byte_stream_to_list (
 		/*
 		 * Set the Buffer to the next structure
 		 */
-		*buffer += structure_size;
+		resource = ACPI_CAST_PTR (struct acpi_resource, buffer);
+		resource->length = ACPI_ALIGN_RESOURCE_SIZE(resource->length);
+		buffer += ACPI_ALIGN_RESOURCE_SIZE(structure_size);
 
 	} /*  end while */
 
 	/*
 	 * Check the reason for exiting the while loop
 	 */
-	if (TRUE != end_tag_processed) {
-		return_ACPI_STATUS (AE_AML_ERROR);
+	if (!end_tag_processed) {
+		return_ACPI_STATUS (AE_AML_NO_RESOURCE_END_TAG);
 	}
 
 	return_ACPI_STATUS (AE_OK);
@@ -308,16 +330,16 @@ acpi_rs_byte_stream_to_list (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_list_to_byte_stream
+ * FUNCTION:    acpi_rs_list_to_byte_stream
  *
- * PARAMETERS:  Linked_list             - Pointer to the resource linked list
- *              Byte_steam_size_needed  - Calculated size of the byte stream
+ * PARAMETERS:  linked_list             - Pointer to the resource linked list
+ *              byte_steam_size_needed  - Calculated size of the byte stream
  *                                        needed from calling
- *                                        Acpi_rs_calculate_byte_stream_length()
- *                                        The size of the Output_buffer is
+ *                                        acpi_rs_get_byte_stream_length()
+ *                                        The size of the output_buffer is
  *                                        guaranteed to be >=
- *                                        Byte_stream_size_needed
- *              Output_buffer           - Pointer to the buffer that will
+ *                                        byte_stream_size_needed
+ *              output_buffer           - Pointer to the buffer that will
  *                                        contain the byte stream
  *
  * RETURN:      Status
@@ -329,17 +351,17 @@ acpi_rs_byte_stream_to_list (
 
 acpi_status
 acpi_rs_list_to_byte_stream (
-	acpi_resource           *linked_list,
-	u32                     byte_stream_size_needed,
-	u8                      **output_buffer)
+	struct acpi_resource            *linked_list,
+	acpi_size                       byte_stream_size_needed,
+	u8                              *output_buffer)
 {
-	acpi_status             status;
-	u8                      *buffer = *output_buffer;
-	u32                     bytes_consumed = 0;
-	u8                      done = FALSE;
+	acpi_status                     status;
+	u8                              *buffer = output_buffer;
+	acpi_size                       bytes_consumed = 0;
+	u8                              done = FALSE;
 
 
-	FUNCTION_TRACE ("Rs_list_to_byte_stream");
+	ACPI_FUNCTION_TRACE ("rs_list_to_byte_stream");
 
 
 	while (!done) {
@@ -362,7 +384,7 @@ acpi_rs_list_to_byte_stream (
 			/*
 			 * Start Dependent Functions Resource
 			 */
-			status = acpi_rs_start_dependent_functions_stream (linked_list,
+			status = acpi_rs_start_depend_fns_stream (linked_list,
 					  &buffer, &bytes_consumed);
 			break;
 
@@ -370,7 +392,7 @@ acpi_rs_list_to_byte_stream (
 			/*
 			 * End Dependent Functions Resource
 			 */
-			status = acpi_rs_end_dependent_functions_stream (linked_list,
+			status = acpi_rs_end_depend_fns_stream (linked_list,
 					  &buffer, &bytes_consumed);
 			break;
 
@@ -467,13 +489,14 @@ acpi_rs_list_to_byte_stream (
 			 * If we get here, everything is out of sync,
 			 *  so exit with an error
 			 */
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid descriptor type (%X) in resource list\n",
+				linked_list->id));
 			status = AE_BAD_DATA;
 			break;
 
-		} /* switch (Linked_list->Id) */
-
+		} /* switch (linked_list->Id) */
 
-		if (!ACPI_SUCCESS(status)) {
+		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
 
@@ -485,7 +508,7 @@ acpi_rs_list_to_byte_stream (
 		/*
 		 * Point to the next object
 		 */
-		linked_list = POINTER_ADD (acpi_resource,
+		linked_list = ACPI_PTR_ADD (struct acpi_resource,
 				  linked_list, linked_list->length);
 	}
 
diff -urNp linux-5400/drivers/acpi/resources/rsmemory.c linux-5410/drivers/acpi/resources/rsmemory.c
--- linux-5400/drivers/acpi/resources/rsmemory.c
+++ linux-5410/drivers/acpi/resources/rsmemory.c
@@ -1,73 +1,90 @@
 /*******************************************************************************
  *
  * Module Name: rsmem24 - Memory resource descriptors
- *              $Revision: 14 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acresrc.h"
+#include <acpi/acpi.h>
+#include <acpi/acresrc.h>
 
 #define _COMPONENT          ACPI_RESOURCES
-	 MODULE_NAME         ("rsmemory")
+	 ACPI_MODULE_NAME    ("rsmemory")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_memory24_resource
+ * FUNCTION:    acpi_rs_memory24_resource
  *
- * PARAMETERS:  Byte_stream_buffer      - Pointer to the resource input byte
+ * PARAMETERS:  byte_stream_buffer      - Pointer to the resource input byte
  *                                        stream
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes consumed from
- *                                        the Byte_stream_buffer
- *              Output_buffer           - Pointer to the user's return buffer
- *              Structure_size          - u32 pointer that is filled with
- *                                        the number of bytes in the filled
- *                                        in structure
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        consumed the byte_stream_buffer is
+ *                                        returned
+ *              output_buffer           - Pointer to the return data buffer
+ *              structure_size          - Pointer to where the number of bytes
+ *                                        in the return data struct is returned
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Take the resource byte stream and fill out the appropriate
- *              structure pointed to by the Output_buffer. Return the
+ *              structure pointed to by the output_buffer. Return the
  *              number of bytes consumed from the byte stream.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_rs_memory24_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size)
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size)
 {
-	u8                      *buffer = byte_stream_buffer;
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
-	u16                     temp16 = 0;
-	u8                      temp8 = 0;
-	u32                     struct_size = SIZEOF_RESOURCE (acpi_resource_mem24);
+	u8                              *buffer = byte_stream_buffer;
+	struct acpi_resource            *output_struct = (void *) *output_buffer;
+	u16                             temp16 = 0;
+	u8                              temp8 = 0;
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_mem24);
 
 
-	FUNCTION_TRACE ("Rs_memory24_resource");
+	ACPI_FUNCTION_TRACE ("rs_memory24_resource");
 
 
 	/*
@@ -75,9 +92,9 @@ acpi_rs_memory24_resource (
 	 */
 	buffer += 1;
 
-	MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
+	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 	buffer += 2;
-	*bytes_consumed = temp16 + 3;
+	*bytes_consumed = (acpi_size) temp16 + 3;
 	output_struct->id = ACPI_RSTYPE_MEM24;
 
 	/*
@@ -88,36 +105,36 @@ acpi_rs_memory24_resource (
 	output_struct->data.memory24.read_write_attribute = temp8 & 0x01;
 
 	/*
-	 * Get Min_base_address (Bytes 4-5)
+	 * Get min_base_address (Bytes 4-5)
 	 */
-	MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
+	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 	buffer += 2;
 	output_struct->data.memory24.min_base_address = temp16;
 
 	/*
-	 * Get Max_base_address (Bytes 6-7)
+	 * Get max_base_address (Bytes 6-7)
 	 */
-	MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
+	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 	buffer += 2;
 	output_struct->data.memory24.max_base_address = temp16;
 
 	/*
 	 * Get Alignment (Bytes 8-9)
 	 */
-	MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
+	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 	buffer += 2;
 	output_struct->data.memory24.alignment = temp16;
 
 	/*
-	 * Get Range_length (Bytes 10-11)
+	 * Get range_length (Bytes 10-11)
 	 */
-	MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
+	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 	output_struct->data.memory24.range_length = temp16;
 
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -129,13 +146,12 @@ acpi_rs_memory24_resource (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_memory24_stream
+ * FUNCTION:    acpi_rs_memory24_stream
  *
- * PARAMETERS:  Linked_list             - Pointer to the resource linked list
- *              Output_buffer           - Pointer to the user's return buffer
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes of the
- *                                        Output_buffer used
+ * PARAMETERS:  linked_list             - Pointer to the resource linked list
+ *              output_buffer           - Pointer to the user's return buffer
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        used in the output_buffer is returned
  *
  * RETURN:      Status
  *
@@ -146,16 +162,16 @@ acpi_rs_memory24_resource (
 
 acpi_status
 acpi_rs_memory24_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed)
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed)
 {
-	u8                      *buffer = *output_buffer;
-	u16                     temp16 = 0;
-	u8                      temp8 = 0;
+	u8                              *buffer = *output_buffer;
+	u16                             temp16 = 0;
+	u8                              temp8 = 0;
 
 
-	FUNCTION_TRACE ("Rs_memory24_stream");
+	ACPI_FUNCTION_TRACE ("rs_memory24_stream");
 
 
 	/*
@@ -168,7 +184,7 @@ acpi_rs_memory24_stream (
 	 * The length field is static
 	 */
 	temp16 = 0x09;
-	MOVE_UNALIGNED16_TO_16 (buffer, &temp16);
+	ACPI_MOVE_16_TO_16 (buffer, &temp16);
 	buffer += 2;
 
 	/*
@@ -181,72 +197,71 @@ acpi_rs_memory24_stream (
 	/*
 	 * Set the Range minimum base address
 	 */
-	MOVE_UNALIGNED16_TO_16 (buffer, &linked_list->data.memory24.min_base_address);
+	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.memory24.min_base_address);
 	buffer += 2;
 
 	/*
 	 * Set the Range maximum base address
 	 */
-	MOVE_UNALIGNED16_TO_16 (buffer, &linked_list->data.memory24.max_base_address);
+	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.memory24.max_base_address);
 	buffer += 2;
 
 	/*
 	 * Set the base alignment
 	 */
-	MOVE_UNALIGNED16_TO_16 (buffer, &linked_list->data.memory24.alignment);
+	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.memory24.alignment);
 	buffer += 2;
 
 	/*
 	 * Set the range length
 	 */
-	MOVE_UNALIGNED16_TO_16 (buffer, &linked_list->data.memory24.range_length);
+	ACPI_MOVE_32_TO_16 (buffer, &linked_list->data.memory24.range_length);
 	buffer += 2;
 
 	/*
 	 * Return the number of bytes consumed in this operation
 	 */
-	*bytes_consumed = POINTER_DIFF (buffer, *output_buffer);
+	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_memory32_range_resource
+ * FUNCTION:    acpi_rs_memory32_range_resource
  *
- * PARAMETERS:  Byte_stream_buffer      - Pointer to the resource input byte
+ * PARAMETERS:  byte_stream_buffer      - Pointer to the resource input byte
  *                                        stream
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes consumed from
- *                                        the Byte_stream_buffer
- *              Output_buffer           - Pointer to the user's return buffer
- *              Structure_size          - u32 pointer that is filled with
- *                                        the number of bytes in the filled
- *                                        in structure
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        consumed the byte_stream_buffer is
+ *                                        returned
+ *              output_buffer           - Pointer to the return data buffer
+ *              structure_size          - Pointer to where the number of bytes
+ *                                        in the return data struct is returned
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Take the resource byte stream and fill out the appropriate
- *              structure pointed to by the Output_buffer. Return the
+ *              structure pointed to by the output_buffer. Return the
  *              number of bytes consumed from the byte stream.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_rs_memory32_range_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size)
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size)
 {
-	u8                      *buffer = byte_stream_buffer;
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
-	u16                     temp16 = 0;
-	u8                      temp8 = 0;
-	u32                     struct_size = SIZEOF_RESOURCE (acpi_resource_mem32);
+	u8                              *buffer = byte_stream_buffer;
+	struct acpi_resource            *output_struct = (void *) *output_buffer;
+	u16                             temp16 = 0;
+	u8                              temp8 = 0;
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_mem32);
 
 
-	FUNCTION_TRACE ("Rs_memory32_range_resource");
+	ACPI_FUNCTION_TRACE ("rs_memory32_range_resource");
 
 
 	/*
@@ -254,19 +269,19 @@ acpi_rs_memory32_range_resource (
 	 */
 	buffer += 1;
 
-	MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
+	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 	buffer += 2;
-	*bytes_consumed = temp16 + 3;
+	*bytes_consumed = (acpi_size) temp16 + 3;
 
 	output_struct->id = ACPI_RSTYPE_MEM32;
 
 	/*
 	 *  Point to the place in the output buffer where the data portion will
 	 *  begin.
-	 *  1. Set the RESOURCE_DATA * Data to point to it's own address, then
+	 *  1. Set the RESOURCE_DATA * Data to point to its own address, then
 	 *  2. Set the pointer to the next address.
 	 *
-	 *  NOTE: Output_struct->Data is cast to u8, otherwise, this addition adds
+	 *  NOTE: output_struct->Data is cast to u8, otherwise, this addition adds
 	 *  4 * sizeof(RESOURCE_DATA) instead of 4 * sizeof(u8)
 	 */
 
@@ -279,34 +294,32 @@ acpi_rs_memory32_range_resource (
 	output_struct->data.memory32.read_write_attribute = temp8 & 0x01;
 
 	/*
-	 * Get Min_base_address (Bytes 4-7)
+	 * Get min_base_address (Bytes 4-7)
 	 */
-	MOVE_UNALIGNED32_TO_32 (&output_struct->data.memory32.min_base_address,
-			 buffer);
+	ACPI_MOVE_32_TO_32 (&output_struct->data.memory32.min_base_address, buffer);
 	buffer += 4;
 
 	/*
-	 * Get Max_base_address (Bytes 8-11)
+	 * Get max_base_address (Bytes 8-11)
 	 */
-	MOVE_UNALIGNED32_TO_32 (&output_struct->data.memory32.max_base_address,
-			 buffer);
+	ACPI_MOVE_32_TO_32 (&output_struct->data.memory32.max_base_address, buffer);
 	buffer += 4;
 
 	/*
 	 * Get Alignment (Bytes 12-15)
 	 */
-	MOVE_UNALIGNED32_TO_32 (&output_struct->data.memory32.alignment, buffer);
+	ACPI_MOVE_32_TO_32 (&output_struct->data.memory32.alignment, buffer);
 	buffer += 4;
 
 	/*
-	 * Get Range_length (Bytes 16-19)
+	 * Get range_length (Bytes 16-19)
 	 */
-	MOVE_UNALIGNED32_TO_32 (&output_struct->data.memory32.range_length, buffer);
+	ACPI_MOVE_32_TO_32 (&output_struct->data.memory32.range_length, buffer);
 
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -318,51 +331,50 @@ acpi_rs_memory32_range_resource (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_fixed_memory32_resource
+ * FUNCTION:    acpi_rs_fixed_memory32_resource
  *
- * PARAMETERS:  Byte_stream_buffer      - Pointer to the resource input byte
+ * PARAMETERS:  byte_stream_buffer      - Pointer to the resource input byte
  *                                        stream
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes consumed from
- *                                        the Byte_stream_buffer
- *              Output_buffer           - Pointer to the user's return buffer
- *              Structure_size          - u32 pointer that is filled with
- *                                        the number of bytes in the filled
- *                                        in structure
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        consumed the byte_stream_buffer is
+ *                                        returned
+ *              output_buffer           - Pointer to the return data buffer
+ *              structure_size          - Pointer to where the number of bytes
+ *                                        in the return data struct is returned
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Take the resource byte stream and fill out the appropriate
- *              structure pointed to by the Output_buffer. Return the
+ *              structure pointed to by the output_buffer. Return the
  *              number of bytes consumed from the byte stream.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_rs_fixed_memory32_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size)
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size)
 {
-	u8                      *buffer = byte_stream_buffer;
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
-	u16                     temp16 = 0;
-	u8                      temp8 = 0;
-	u32                     struct_size = SIZEOF_RESOURCE (acpi_resource_fixed_mem32);
+	u8                              *buffer = byte_stream_buffer;
+	struct acpi_resource            *output_struct = (void *) *output_buffer;
+	u16                             temp16 = 0;
+	u8                              temp8 = 0;
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_fixed_mem32);
 
 
-	FUNCTION_TRACE ("Rs_fixed_memory32_resource");
+	ACPI_FUNCTION_TRACE ("rs_fixed_memory32_resource");
 
 
 	/*
 	 * Point past the Descriptor to get the number of bytes consumed
 	 */
 	buffer += 1;
-	MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
+	ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
 	buffer += 2;
-	*bytes_consumed = temp16 + 3;
+	*bytes_consumed = (acpi_size) temp16 + 3;
 
 	output_struct->id = ACPI_RSTYPE_FIXED_MEM32;
 
@@ -374,22 +386,20 @@ acpi_rs_fixed_memory32_resource (
 	output_struct->data.fixed_memory32.read_write_attribute = temp8 & 0x01;
 
 	/*
-	 * Get Range_base_address (Bytes 4-7)
+	 * Get range_base_address (Bytes 4-7)
 	 */
-	MOVE_UNALIGNED32_TO_32 (&output_struct->data.fixed_memory32.range_base_address,
-			 buffer);
+	ACPI_MOVE_32_TO_32 (&output_struct->data.fixed_memory32.range_base_address, buffer);
 	buffer += 4;
 
 	/*
-	 * Get Range_length (Bytes 8-11)
+	 * Get range_length (Bytes 8-11)
 	 */
-	MOVE_UNALIGNED32_TO_32 (&output_struct->data.fixed_memory32.range_length,
-			 buffer);
+	ACPI_MOVE_32_TO_32 (&output_struct->data.fixed_memory32.range_length, buffer);
 
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -401,13 +411,12 @@ acpi_rs_fixed_memory32_resource (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_memory32_range_stream
+ * FUNCTION:    acpi_rs_memory32_range_stream
  *
- * PARAMETERS:  Linked_list             - Pointer to the resource linked list
- *              Output_buffer           - Pointer to the user's return buffer
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes of the
- *                                        Output_buffer used
+ * PARAMETERS:  linked_list             - Pointer to the resource linked list
+ *              output_buffer           - Pointer to the user's return buffer
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        used in the output_buffer is returned
  *
  * RETURN:      Status
  *
@@ -418,16 +427,16 @@ acpi_rs_fixed_memory32_resource (
 
 acpi_status
 acpi_rs_memory32_range_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed)
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed)
 {
-	u8                      *buffer = *output_buffer;
-	u16                     temp16 = 0;
-	u8                      temp8 = 0;
+	u8                              *buffer = *output_buffer;
+	u16                             temp16 = 0;
+	u8                              temp8 = 0;
 
 
-	FUNCTION_TRACE ("Rs_memory32_range_stream");
+	ACPI_FUNCTION_TRACE ("rs_memory32_range_stream");
 
 
 	/*
@@ -441,7 +450,7 @@ acpi_rs_memory32_range_stream (
 	 */
 	temp16 = 0x11;
 
-	MOVE_UNALIGNED16_TO_16 (buffer, &temp16);
+	ACPI_MOVE_16_TO_16 (buffer, &temp16);
 	buffer += 2;
 
 	/*
@@ -454,44 +463,43 @@ acpi_rs_memory32_range_stream (
 	/*
 	 * Set the Range minimum base address
 	 */
-	MOVE_UNALIGNED32_TO_32 (buffer, &linked_list->data.memory32.min_base_address);
+	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.memory32.min_base_address);
 	buffer += 4;
 
 	/*
 	 * Set the Range maximum base address
 	 */
-	MOVE_UNALIGNED32_TO_32 (buffer, &linked_list->data.memory32.max_base_address);
+	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.memory32.max_base_address);
 	buffer += 4;
 
 	/*
 	 * Set the base alignment
 	 */
-	MOVE_UNALIGNED32_TO_32 (buffer, &linked_list->data.memory32.alignment);
+	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.memory32.alignment);
 	buffer += 4;
 
 	/*
 	 * Set the range length
 	 */
-	MOVE_UNALIGNED32_TO_32 (buffer, &linked_list->data.memory32.range_length);
+	ACPI_MOVE_32_TO_32 (buffer, &linked_list->data.memory32.range_length);
 	buffer += 4;
 
 	/*
 	 * Return the number of bytes consumed in this operation
 	 */
-	*bytes_consumed = POINTER_DIFF (buffer, *output_buffer);
+	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_fixed_memory32_stream
+ * FUNCTION:    acpi_rs_fixed_memory32_stream
  *
- * PARAMETERS:  Linked_list             - Pointer to the resource linked list
- *              Output_buffer           - Pointer to the user's return buffer
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes of the
- *                                        Output_buffer used
+ * PARAMETERS:  linked_list             - Pointer to the resource linked list
+ *              output_buffer           - Pointer to the user's return buffer
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        used in the output_buffer is returned
  *
  * RETURN:      Status
  *
@@ -502,16 +510,16 @@ acpi_rs_memory32_range_stream (
 
 acpi_status
 acpi_rs_fixed_memory32_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed)
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed)
 {
-	u8                      *buffer = *output_buffer;
-	u16                     temp16 = 0;
-	u8                      temp8 = 0;
+	u8                              *buffer = *output_buffer;
+	u16                             temp16 = 0;
+	u8                              temp8 = 0;
 
 
-	FUNCTION_TRACE ("Rs_fixed_memory32_stream");
+	ACPI_FUNCTION_TRACE ("rs_fixed_memory32_stream");
 
 
 	/*
@@ -525,7 +533,7 @@ acpi_rs_fixed_memory32_stream (
 	 */
 	temp16 = 0x09;
 
-	MOVE_UNALIGNED16_TO_16 (buffer, &temp16);
+	ACPI_MOVE_16_TO_16 (buffer, &temp16);
 	buffer += 2;
 
 	/*
@@ -538,21 +546,21 @@ acpi_rs_fixed_memory32_stream (
 	/*
 	 * Set the Range base address
 	 */
-	MOVE_UNALIGNED32_TO_32 (buffer,
+	ACPI_MOVE_32_TO_32 (buffer,
 			 &linked_list->data.fixed_memory32.range_base_address);
 	buffer += 4;
 
 	/*
 	 * Set the range length
 	 */
-	MOVE_UNALIGNED32_TO_32 (buffer,
+	ACPI_MOVE_32_TO_32 (buffer,
 			 &linked_list->data.fixed_memory32.range_length);
 	buffer += 4;
 
 	/*
 	 * Return the number of bytes consumed in this operation
 	 */
-	*bytes_consumed = POINTER_DIFF (buffer, *output_buffer);
+	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
 
diff -urNp linux-5400/drivers/acpi/resources/rsmisc.c linux-5410/drivers/acpi/resources/rsmisc.c
--- linux-5400/drivers/acpi/resources/rsmisc.c
+++ linux-5410/drivers/acpi/resources/rsmisc.c
@@ -1,70 +1,87 @@
 /*******************************************************************************
  *
  * Module Name: rsmisc - Miscellaneous resource descriptors
- *              $Revision: 16 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acresrc.h"
+#include <acpi/acpi.h>
+#include <acpi/acresrc.h>
 
 #define _COMPONENT          ACPI_RESOURCES
-	 MODULE_NAME         ("rsmisc")
+	 ACPI_MODULE_NAME    ("rsmisc")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_end_tag_resource
+ * FUNCTION:    acpi_rs_end_tag_resource
  *
- * PARAMETERS:  Byte_stream_buffer      - Pointer to the resource input byte
+ * PARAMETERS:  byte_stream_buffer      - Pointer to the resource input byte
  *                                        stream
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes consumed from
- *                                        the Byte_stream_buffer
- *              Output_buffer           - Pointer to the user's return buffer
- *              Structure_size          - u32 pointer that is filled with
- *                                        the number of bytes in the filled
- *                                        in structure
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        consumed the byte_stream_buffer is
+ *                                        returned
+ *              output_buffer           - Pointer to the return data buffer
+ *              structure_size          - Pointer to where the number of bytes
+ *                                        in the return data struct is returned
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Take the resource byte stream and fill out the appropriate
- *              structure pointed to by the Output_buffer. Return the
+ *              structure pointed to by the output_buffer. Return the
  *              number of bytes consumed from the byte stream.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_rs_end_tag_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size)
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size)
 {
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
-	u32                     struct_size = ACPI_RESOURCE_LENGTH;
+	struct acpi_resource            *output_struct = (void *) *output_buffer;
+	acpi_size                       struct_size = ACPI_RESOURCE_LENGTH;
 
 
-	FUNCTION_TRACE ("Rs_end_tag_resource");
+	ACPI_FUNCTION_TRACE ("rs_end_tag_resource");
 
 
 	/*
@@ -92,13 +109,12 @@ acpi_rs_end_tag_resource (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_end_tag_stream
+ * FUNCTION:    acpi_rs_end_tag_stream
  *
- * PARAMETERS:  Linked_list             - Pointer to the resource linked list
- *              Output_buffer           - Pointer to the user's return buffer
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes of the
- *                                        Output_buffer used
+ * PARAMETERS:  linked_list             - Pointer to the resource linked list
+ *              output_buffer           - Pointer to the user's return buffer
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        used in the output_buffer is returned
  *
  * RETURN:      Status
  *
@@ -109,15 +125,15 @@ acpi_rs_end_tag_resource (
 
 acpi_status
 acpi_rs_end_tag_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed)
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed)
 {
-	u8                      *buffer = *output_buffer;
-	u8                      temp8 = 0;
+	u8                              *buffer = *output_buffer;
+	u8                              temp8 = 0;
 
 
-	FUNCTION_TRACE ("Rs_end_tag_stream");
+	ACPI_FUNCTION_TRACE ("rs_end_tag_stream");
 
 
 	/*
@@ -138,49 +154,48 @@ acpi_rs_end_tag_stream (
 	/*
 	 * Return the number of bytes consumed in this operation
 	 */
-	*bytes_consumed = POINTER_DIFF (buffer, *output_buffer);
+	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_vendor_resource
+ * FUNCTION:    acpi_rs_vendor_resource
  *
- * PARAMETERS:  Byte_stream_buffer      - Pointer to the resource input byte
+ * PARAMETERS:  byte_stream_buffer      - Pointer to the resource input byte
  *                                        stream
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes consumed from
- *                                        the Byte_stream_buffer
- *              Output_buffer           - Pointer to the user's return buffer
- *              Structure_size          - u32 pointer that is filled with
- *                                        the number of bytes in the filled
- *                                        in structure
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        consumed the byte_stream_buffer is
+ *                                        returned
+ *              output_buffer           - Pointer to the return data buffer
+ *              structure_size          - Pointer to where the number of bytes
+ *                                        in the return data struct is returned
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Take the resource byte stream and fill out the appropriate
- *              structure pointed to by the Output_buffer. Return the
+ *              structure pointed to by the output_buffer. Return the
  *              number of bytes consumed from the byte stream.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_rs_vendor_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size)
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size)
 {
-	u8                      *buffer = byte_stream_buffer;
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
-	u16                     temp16 = 0;
-	u8                      temp8 = 0;
-	u8                      index;
-	u32                     struct_size = SIZEOF_RESOURCE (acpi_resource_vendor);
+	u8                              *buffer = byte_stream_buffer;
+	struct acpi_resource            *output_struct = (void *) *output_buffer;
+	u16                             temp16 = 0;
+	u8                              temp8 = 0;
+	u8                              index;
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_vendor);
 
 
-	FUNCTION_TRACE ("Rs_vendor_resource");
+	ACPI_FUNCTION_TRACE ("rs_vendor_resource");
 
 
 	/*
@@ -190,34 +205,31 @@ acpi_rs_vendor_resource (
 
 	if (temp8 & 0x80) {
 		/*
-		 * Large Item
-		 * Point to the length field
+		 * Large Item, point to the length field
 		 */
 		buffer += 1;
 
 		/* Dereference */
 
-		MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
+		ACPI_MOVE_16_TO_16 (&temp16, buffer);
 
 		/* Calculate bytes consumed */
 
-		*bytes_consumed = temp16 + 3;
+		*bytes_consumed = (acpi_size) temp16 + 3;
 
 		/* Point to the first vendor byte */
 
 		buffer += 2;
 	}
-
 	else {
 		/*
-		 * Small Item
-		 * Dereference the size
+		 * Small Item, dereference the size
 		 */
 		temp16 = (u8)(*buffer & 0x07);
 
 		/* Calculate bytes consumed */
 
-		*bytes_consumed = temp16 + 1;
+		*bytes_consumed = (acpi_size) temp16 + 1;
 
 		/* Point to the first vendor byte */
 
@@ -233,16 +245,16 @@ acpi_rs_vendor_resource (
 	}
 
 	/*
-	 * In order for the Struct_size to fall on a 32-bit boundary,
+	 * In order for the struct_size to fall on a 32-bit boundary,
 	 * calculate the length of the vendor string and expand the
-	 * Struct_size to the next 32-bit boundary.
+	 * struct_size to the next 32-bit boundary.
 	 */
-	struct_size += ROUND_UP_TO_32_bITS (temp16);
+	struct_size += ACPI_ROUND_UP_to_32_bITS (temp16);
 
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -254,13 +266,12 @@ acpi_rs_vendor_resource (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_vendor_stream
+ * FUNCTION:    acpi_rs_vendor_stream
  *
- * PARAMETERS:  Linked_list             - Pointer to the resource linked list
- *              Output_buffer           - Pointer to the user's return buffer
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes of the
- *                                        Output_buffer used
+ * PARAMETERS:  linked_list             - Pointer to the resource linked list
+ *              output_buffer           - Pointer to the user's return buffer
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        used in the output_buffer is returned
  *
  * RETURN:      Status
  *
@@ -271,17 +282,17 @@ acpi_rs_vendor_resource (
 
 acpi_status
 acpi_rs_vendor_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed)
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed)
 {
-	u8                      *buffer = *output_buffer;
-	u16                     temp16 = 0;
-	u8                      temp8 = 0;
-	u8                      index;
+	u8                              *buffer = *output_buffer;
+	u16                             temp16 = 0;
+	u8                              temp8 = 0;
+	u8                              index;
 
 
-	FUNCTION_TRACE ("Rs_vendor_stream");
+	ACPI_FUNCTION_TRACE ("rs_vendor_stream");
 
 
 	/*
@@ -289,25 +300,22 @@ acpi_rs_vendor_stream (
 	 */
 	if(linked_list->data.vendor_specific.length > 7) {
 		/*
-		 * Large Item
-		 * Set the descriptor field and length bytes
+		 * Large Item, Set the descriptor field and length bytes
 		 */
 		*buffer = 0x84;
 		buffer += 1;
 
 		temp16 = (u16) linked_list->data.vendor_specific.length;
 
-		MOVE_UNALIGNED16_TO_16 (buffer, &temp16);
+		ACPI_MOVE_16_TO_16 (buffer, &temp16);
 		buffer += 2;
 	}
-
 	else {
 		/*
-		 * Small Item
-		 * Set the descriptor field
+		 * Small Item, Set the descriptor field
 		 */
 		temp8 = 0x70;
-		temp8 |= linked_list->data.vendor_specific.length;
+		temp8 |= (u8) linked_list->data.vendor_specific.length;
 
 		*buffer = temp8;
 		buffer += 1;
@@ -326,47 +334,46 @@ acpi_rs_vendor_stream (
 	/*
 	 * Return the number of bytes consumed in this operation
 	 */
-	*bytes_consumed = POINTER_DIFF (buffer, *output_buffer);
+	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_start_dependent_functions_resource
+ * FUNCTION:    acpi_rs_start_depend_fns_resource
  *
- * PARAMETERS:  Byte_stream_buffer      - Pointer to the resource input byte
+ * PARAMETERS:  byte_stream_buffer      - Pointer to the resource input byte
  *                                        stream
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes consumed from
- *                                        the Byte_stream_buffer
- *              Output_buffer           - Pointer to the user's return buffer
- *              Structure_size          - u32 pointer that is filled with
- *                                        the number of bytes in the filled
- *                                        in structure
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        consumed the byte_stream_buffer is
+ *                                        returned
+ *              output_buffer           - Pointer to the return data buffer
+ *              structure_size          - Pointer to where the number of bytes
+ *                                        in the return data struct is returned
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Take the resource byte stream and fill out the appropriate
- *              structure pointed to by the Output_buffer. Return the
+ *              structure pointed to by the output_buffer. Return the
  *              number of bytes consumed from the byte stream.
  *
  ******************************************************************************/
 
 acpi_status
-acpi_rs_start_dependent_functions_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size)
+acpi_rs_start_depend_fns_resource (
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size)
 {
-	u8                      *buffer = byte_stream_buffer;
-	acpi_resource          *output_struct = (acpi_resource *) *output_buffer;
-	u8                      temp8 = 0;
-	u32                     struct_size = SIZEOF_RESOURCE (acpi_resource_start_dpf);
+	u8                              *buffer = byte_stream_buffer;
+	struct acpi_resource            *output_struct = (void *) *output_buffer;
+	u8                              temp8 = 0;
+	acpi_size                       struct_size = ACPI_SIZEOF_RESOURCE (struct acpi_resource_start_dpf);
 
 
-	FUNCTION_TRACE ("Rs_start_dependent_functions_resource");
+	ACPI_FUNCTION_TRACE ("rs_start_depend_fns_resource");
 
 
 	/*
@@ -391,7 +398,7 @@ acpi_rs_start_dependent_functions_resour
 		output_struct->data.start_dpf.compatibility_priority = temp8 & 0x03;
 
 		if (3 == output_struct->data.start_dpf.compatibility_priority) {
-			return_ACPI_STATUS (AE_AML_ERROR);
+			return_ACPI_STATUS (AE_AML_BAD_RESOURCE_VALUE);
 		}
 
 		/*
@@ -400,22 +407,21 @@ acpi_rs_start_dependent_functions_resour
 		output_struct->data.start_dpf.performance_robustness = (temp8 >> 2) & 0x03;
 
 		if (3 == output_struct->data.start_dpf.performance_robustness) {
-			return_ACPI_STATUS (AE_AML_ERROR);
+			return_ACPI_STATUS (AE_AML_BAD_RESOURCE_VALUE);
 		}
 	}
-
 	else {
 		output_struct->data.start_dpf.compatibility_priority =
-				ACCEPTABLE_CONFIGURATION;
+				ACPI_ACCEPTABLE_CONFIGURATION;
 
 		output_struct->data.start_dpf.performance_robustness =
-				ACCEPTABLE_CONFIGURATION;
+				ACPI_ACCEPTABLE_CONFIGURATION;
 	}
 
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -427,38 +433,37 @@ acpi_rs_start_dependent_functions_resour
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_end_dependent_functions_resource
+ * FUNCTION:    acpi_rs_end_depend_fns_resource
  *
- * PARAMETERS:  Byte_stream_buffer      - Pointer to the resource input byte
+ * PARAMETERS:  byte_stream_buffer      - Pointer to the resource input byte
  *                                        stream
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes consumed from
- *                                        the Byte_stream_buffer
- *              Output_buffer           - Pointer to the user's return buffer
- *              Structure_size          - u32 pointer that is filled with
- *                                        the number of bytes in the filled
- *                                        in structure
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        consumed the byte_stream_buffer is
+ *                                        returned
+ *              output_buffer           - Pointer to the return data buffer
+ *              structure_size          - Pointer to where the number of bytes
+ *                                        in the return data struct is returned
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Take the resource byte stream and fill out the appropriate
- *              structure pointed to by the Output_buffer. Return the
+ *              structure pointed to by the output_buffer. Return the
  *              number of bytes consumed from the byte stream.
  *
  ******************************************************************************/
 
 acpi_status
-acpi_rs_end_dependent_functions_resource (
-	u8                      *byte_stream_buffer,
-	u32                     *bytes_consumed,
-	u8                      **output_buffer,
-	u32                     *structure_size)
+acpi_rs_end_depend_fns_resource (
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size)
 {
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
-	u32                     struct_size = ACPI_RESOURCE_LENGTH;
+	struct acpi_resource            *output_struct = (void *) *output_buffer;
+	acpi_size                       struct_size = ACPI_RESOURCE_LENGTH;
 
 
-	FUNCTION_TRACE ("Rs_end_dependent_functions_resource");
+	ACPI_FUNCTION_TRACE ("rs_end_depend_fns_resource");
 
 
 	/*
@@ -474,7 +479,7 @@ acpi_rs_end_dependent_functions_resource
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -486,13 +491,13 @@ acpi_rs_end_dependent_functions_resource
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_start_dependent_functions_stream
+ * FUNCTION:    acpi_rs_start_depend_fns_stream
  *
- * PARAMETERS:  Linked_list             - Pointer to the resource linked list
- *              Output_buffer           - Pointer to the user's return buffer
- *              Bytes_consumed          - u32 pointer that is filled with
+ * PARAMETERS:  linked_list             - Pointer to the resource linked list
+ *              output_buffer           - Pointer to the user's return buffer
+ *              bytes_consumed          - u32 pointer that is filled with
  *                                        the number of bytes of the
- *                                        Output_buffer used
+ *                                        output_buffer used
  *
  * RETURN:      Status
  *
@@ -502,25 +507,25 @@ acpi_rs_end_dependent_functions_resource
  ******************************************************************************/
 
 acpi_status
-acpi_rs_start_dependent_functions_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed)
+acpi_rs_start_depend_fns_stream (
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed)
 {
-	u8                      *buffer = *output_buffer;
-	u8                      temp8 = 0;
+	u8                              *buffer = *output_buffer;
+	u8                              temp8 = 0;
 
 
-	FUNCTION_TRACE ("Rs_start_dependent_functions_stream");
+	ACPI_FUNCTION_TRACE ("rs_start_depend_fns_stream");
 
 
 	/*
 	 * The descriptor field is set based upon whether a byte is needed
 	 * to contain Priority data.
 	 */
-	if (ACCEPTABLE_CONFIGURATION ==
+	if (ACPI_ACCEPTABLE_CONFIGURATION ==
 			linked_list->data.start_dpf.compatibility_priority &&
-		ACCEPTABLE_CONFIGURATION ==
+		ACPI_ACCEPTABLE_CONFIGURATION ==
 			linked_list->data.start_dpf.performance_robustness) {
 		*buffer = 0x30;
 	}
@@ -544,20 +549,19 @@ acpi_rs_start_dependent_functions_stream
 	/*
 	 * Return the number of bytes consumed in this operation
 	 */
-	*bytes_consumed = POINTER_DIFF (buffer, *output_buffer);
+	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_end_dependent_functions_stream
+ * FUNCTION:    acpi_rs_end_depend_fns_stream
  *
- * PARAMETERS:  Linked_list             - Pointer to the resource linked list
- *              Output_buffer           - Pointer to the user's return buffer
- *              Bytes_consumed          - u32 pointer that is filled with
- *                                        the number of bytes of the
- *                                        Output_buffer used
+ * PARAMETERS:  linked_list             - Pointer to the resource linked list
+ *              output_buffer           - Pointer to the user's return buffer
+ *              bytes_consumed          - Pointer to where the number of bytes
+ *                                        used in the output_buffer is returned
  *
  * RETURN:      Status
  *
@@ -567,16 +571,15 @@ acpi_rs_start_dependent_functions_stream
  ******************************************************************************/
 
 acpi_status
-acpi_rs_end_dependent_functions_stream (
-	acpi_resource           *linked_list,
-	u8                      **output_buffer,
-	u32                     *bytes_consumed
-	)
+acpi_rs_end_depend_fns_stream (
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed)
 {
-	u8                      *buffer = *output_buffer;
+	u8                              *buffer = *output_buffer;
 
 
-	FUNCTION_TRACE ("Rs_end_dependent_functions_stream");
+	ACPI_FUNCTION_TRACE ("rs_end_depend_fns_stream");
 
 
 	/*
@@ -588,7 +591,7 @@ acpi_rs_end_dependent_functions_stream (
 	/*
 	 * Return the number of bytes consumed in this operation
 	 */
-	*bytes_consumed = POINTER_DIFF (buffer, *output_buffer);
+	*bytes_consumed = ACPI_PTR_DIFF (buffer, *output_buffer);
 	return_ACPI_STATUS (AE_OK);
 }
 
diff -urNp linux-5400/drivers/acpi/resources/rsutils.c linux-5410/drivers/acpi/resources/rsutils.c
--- linux-5400/drivers/acpi/resources/rsutils.c
+++ linux-5410/drivers/acpi/resources/rsutils.c
@@ -1,44 +1,62 @@
 /*******************************************************************************
  *
  * Module Name: rsutils - Utilities for the resource manager
- *              $Revision: 23 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acnamesp.h"
-#include "acresrc.h"
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acresrc.h>
 
 
 #define _COMPONENT          ACPI_RESOURCES
-	 MODULE_NAME         ("rsutils")
+	 ACPI_MODULE_NAME    ("rsutils")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_get_prt_method_data
+ * FUNCTION:    acpi_rs_get_prt_method_data
  *
  * PARAMETERS:  Handle          - a handle to the containing object
- *              Ret_buffer      - a pointer to a buffer structure for the
+ *              ret_buffer      - a pointer to a buffer structure for the
  *                                  results
  *
  * RETURN:      Status
@@ -53,78 +71,45 @@
 
 acpi_status
 acpi_rs_get_prt_method_data (
-	acpi_handle             handle,
-	acpi_buffer             *ret_buffer)
+	acpi_handle                     handle,
+	struct acpi_buffer              *ret_buffer)
 {
-	acpi_operand_object     *ret_obj;
-	acpi_status             status;
-	u32                     buffer_space_needed;
+	union acpi_operand_object       *obj_desc;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Rs_get_prt_method_data");
+	ACPI_FUNCTION_TRACE ("rs_get_prt_method_data");
 
 
-	/* already validated params, so we won't repeat here */
-
-	buffer_space_needed = ret_buffer->length;
+	/* Parameters guaranteed valid by caller */
 
 	/*
-	 *  Execute the method, no parameters
+	 * Execute the method, no parameters
 	 */
-	status = acpi_ns_evaluate_relative (handle, "_PRT", NULL, &ret_obj);
+	status = acpi_ut_evaluate_object (handle, "_PRT", ACPI_BTYPE_PACKAGE, &obj_desc);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
-	if (!ret_obj) {
-		/* Return object is required */
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No object was returned from _PRT\n"));
-		return_ACPI_STATUS (AE_TYPE);
-	}
-
-
-	/*
-	 * The return object will be a package, so check the
-	 *  parameters.  If the return object is not a package,
-	 *  then the underlying AML code is corrupt or improperly
-	 *  written.
-	 */
-	if (ACPI_TYPE_PACKAGE != ret_obj->common.type) {
-		status = AE_AML_OPERAND_TYPE;
-		goto cleanup;
-	}
-
-	/*
-	 * Make the call to create a resource linked list from the
-	 *  byte stream buffer that comes back from the _CRS method
-	 *  execution.
-	 */
-	status = acpi_rs_create_pci_routing_table (ret_obj, ret_buffer->pointer,
-			  &buffer_space_needed);
-
 	/*
-	 * Tell the user how much of the buffer we have used or is needed
-	 *  and return the final status.
+	 * Create a resource linked list from the byte stream buffer that comes
+	 * back from the _CRS method execution.
 	 */
-	ret_buffer->length = buffer_space_needed;
-
+	status = acpi_rs_create_pci_routing_table (obj_desc, ret_buffer);
 
 	/* On exit, we must delete the object returned by evaluate_object */
 
-cleanup:
-
-	acpi_ut_remove_reference (ret_obj);
+	acpi_ut_remove_reference (obj_desc);
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_get_crs_method_data
+ * FUNCTION:    acpi_rs_get_crs_method_data
  *
  * PARAMETERS:  Handle          - a handle to the containing object
- *              Ret_buffer      - a pointer to a buffer structure for the
+ *              ret_buffer      - a pointer to a buffer structure for the
  *                                  results
  *
  * RETURN:      Status
@@ -139,76 +124,46 @@ cleanup:
 
 acpi_status
 acpi_rs_get_crs_method_data (
-	acpi_handle             handle,
-	acpi_buffer             *ret_buffer)
+	acpi_handle                     handle,
+	struct acpi_buffer              *ret_buffer)
 {
-	acpi_operand_object     *ret_obj;
-	acpi_status             status;
-	u32                     buffer_space_needed = ret_buffer->length;
+	union acpi_operand_object       *obj_desc;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Rs_get_crs_method_data");
+	ACPI_FUNCTION_TRACE ("rs_get_crs_method_data");
 
 
-	/* already validated params, so we won't repeat here */
+	/* Parameters guaranteed valid by caller */
 
 	/*
-	 *  Execute the method, no parameters
+	 * Execute the method, no parameters
 	 */
-	status = acpi_ns_evaluate_relative (handle, "_CRS", NULL, &ret_obj);
+	status = acpi_ut_evaluate_object (handle, "_CRS", ACPI_BTYPE_BUFFER, &obj_desc);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
-	if (!ret_obj) {
-		/* Return object is required */
-
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No object was returned from _CRS\n"));
-		return_ACPI_STATUS (AE_TYPE);
-	}
-
-	/*
-	 * The return object will be a buffer, but check the
-	 *  parameters.  If the return object is not a buffer,
-	 *  then the underlying AML code is corrupt or improperly
-	 *  written.
-	 */
-	if (ACPI_TYPE_BUFFER != ret_obj->common.type) {
-		status = AE_AML_OPERAND_TYPE;
-		goto cleanup;
-	}
-
 	/*
 	 * Make the call to create a resource linked list from the
-	 *  byte stream buffer that comes back from the _CRS method
-	 *  execution.
+	 * byte stream buffer that comes back from the _CRS method
+	 * execution.
 	 */
-	status = acpi_rs_create_resource_list (ret_obj, ret_buffer->pointer,
-			 &buffer_space_needed);
+	status = acpi_rs_create_resource_list (obj_desc, ret_buffer);
 
+	/* on exit, we must delete the object returned by evaluate_object */
 
-	/*
-	 * Tell the user how much of the buffer we have used or is needed
-	 *  and return the final status.
-	 */
-	ret_buffer->length = buffer_space_needed;
-
-
-	/* On exit, we must delete the object returned by evaluate_object */
-
-cleanup:
-
-	acpi_ut_remove_reference (ret_obj);
+	acpi_ut_remove_reference (obj_desc);
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_get_prs_method_data
+ * FUNCTION:    acpi_rs_get_prs_method_data
  *
  * PARAMETERS:  Handle          - a handle to the containing object
- *              Ret_buffer      - a pointer to a buffer structure for the
+ *              ret_buffer      - a pointer to a buffer structure for the
  *                                  results
  *
  * RETURN:      Status
@@ -223,75 +178,100 @@ cleanup:
 
 acpi_status
 acpi_rs_get_prs_method_data (
-	acpi_handle             handle,
-	acpi_buffer             *ret_buffer)
+	acpi_handle                     handle,
+	struct acpi_buffer              *ret_buffer)
 {
-	acpi_operand_object     *ret_obj;
-	acpi_status             status;
-	u32                     buffer_space_needed = ret_buffer->length;
+	union acpi_operand_object       *obj_desc;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Rs_get_prs_method_data");
+	ACPI_FUNCTION_TRACE ("rs_get_prs_method_data");
 
 
-	/* already validated params, so we won't repeat here */
+	/* Parameters guaranteed valid by caller */
 
 	/*
-	 *  Execute the method, no parameters
+	 * Execute the method, no parameters
 	 */
-	status = acpi_ns_evaluate_relative (handle, "_PRS", NULL, &ret_obj);
+	status = acpi_ut_evaluate_object (handle, "_PRS", ACPI_BTYPE_BUFFER, &obj_desc);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
-	if (!ret_obj) {
-		/* Return object is required */
+	/*
+	 * Make the call to create a resource linked list from the
+	 * byte stream buffer that comes back from the _CRS method
+	 * execution.
+	 */
+	status = acpi_rs_create_resource_list (obj_desc, ret_buffer);
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No object was returned from _PRS\n"));
-		return_ACPI_STATUS (AE_TYPE);
-	}
+	/* on exit, we must delete the object returned by evaluate_object */
+
+	acpi_ut_remove_reference (obj_desc);
+	return_ACPI_STATUS (status);
+}
 
-	/*
-	 * The return object will be a buffer, but check the
-	 *  parameters.  If the return object is not a buffer,
-	 *  then the underlying AML code is corrupt or improperly
-	 *  written..
-	 */
-	if (ACPI_TYPE_BUFFER != ret_obj->common.type) {
-		status = AE_AML_OPERAND_TYPE;
-		goto cleanup;
-	}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_rs_get_method_data
+ *
+ * PARAMETERS:  Handle          - a handle to the containing object
+ *              ret_buffer      - a pointer to a buffer structure for the
+ *                                  results
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to get the _CRS or _PRS value of an
+ *              object contained in an object specified by the handle passed in
+ *
+ *              If the function fails an appropriate status will be returned
+ *              and the contents of the callers buffer is undefined.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_rs_get_method_data (
+	acpi_handle                     handle,
+	char                            *path,
+	struct acpi_buffer              *ret_buffer)
+{
+	union acpi_operand_object       *obj_desc;
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE ("rs_get_method_data");
+
+
+	/* Parameters guaranteed valid by caller */
 
 	/*
-	 * Make the call to create a resource linked list from the
-	 *  byte stream buffer that comes back from the _CRS method
-	 *  execution.
+	 * Execute the method, no parameters
 	 */
-	status = acpi_rs_create_resource_list (ret_obj, ret_buffer->pointer,
-			 &buffer_space_needed);
+	status = acpi_ut_evaluate_object (handle, path, ACPI_BTYPE_BUFFER, &obj_desc);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	/*
-	 * Tell the user how much of the buffer we have used or is needed
-	 *  and return the final status.
+	 * Make the call to create a resource linked list from the
+	 * byte stream buffer that comes back from the method
+	 * execution.
 	 */
-	ret_buffer->length = buffer_space_needed;
-
+	status = acpi_rs_create_resource_list (obj_desc, ret_buffer);
 
 	/* On exit, we must delete the object returned by evaluate_object */
 
-cleanup:
-
-	acpi_ut_remove_reference (ret_obj);
+	acpi_ut_remove_reference (obj_desc);
 	return_ACPI_STATUS (status);
 }
 
-
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_set_srs_method_data
+ * FUNCTION:    acpi_rs_set_srs_method_data
  *
  * PARAMETERS:  Handle          - a handle to the containing object
- *              In_buffer       - a pointer to a buffer structure of the
+ *              in_buffer       - a pointer to a buffer structure of the
  *                                  parameter
  *
  * RETURN:      Status
@@ -306,55 +286,30 @@ cleanup:
 
 acpi_status
 acpi_rs_set_srs_method_data (
-	acpi_handle             handle,
-	acpi_buffer             *in_buffer)
+	acpi_handle                     handle,
+	struct acpi_buffer              *in_buffer)
 {
-	acpi_operand_object     *params[2];
-	acpi_status             status;
-	u8                      *byte_stream = NULL;
-	u32                     buffer_size_needed = 0;
+	union acpi_operand_object       *params[2];
+	acpi_status                     status;
+	struct acpi_buffer              buffer;
 
 
-	FUNCTION_TRACE ("Rs_set_srs_method_data");
+	ACPI_FUNCTION_TRACE ("rs_set_srs_method_data");
 
 
-	/* already validated params, so we won't repeat here */
+	/* Parameters guaranteed valid by caller */
 
 	/*
-	 * The In_buffer parameter will point to a linked list of
+	 * The in_buffer parameter will point to a linked list of
 	 * resource parameters.  It needs to be formatted into a
-	 * byte stream to be sent in as an input parameter.
-	 */
-	buffer_size_needed = 0;
-
-	/*
-	 * First call is to get the buffer size needed
-	 */
-	status = acpi_rs_create_byte_stream (in_buffer->pointer, byte_stream,
-			 &buffer_size_needed);
-	/*
-	 * We expect a return of AE_BUFFER_OVERFLOW
-	 * if not, exit with the error
-	 */
-	if (AE_BUFFER_OVERFLOW != status) {
-		return_ACPI_STATUS (status);
-	}
-
-	/*
-	 * Allocate the buffer needed
+	 * byte stream to be sent in as an input parameter to _SRS
+	 *
+	 * Convert the linked list into a byte stream
 	 */
-	byte_stream = ACPI_MEM_CALLOCATE (buffer_size_needed);
-	if (NULL == byte_stream) {
-		return_ACPI_STATUS (AE_NO_MEMORY);
-	}
-
-	/*
-	 * Now call to convert the linked list into a byte stream
-	 */
-	status = acpi_rs_create_byte_stream (in_buffer->pointer, byte_stream,
-			 &buffer_size_needed);
+	buffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;
+	status = acpi_rs_create_byte_stream (in_buffer->pointer, &buffer);
 	if (ACPI_FAILURE (status)) {
-		goto cleanup;
+		return_ACPI_STATUS (status);
 	}
 
 	/*
@@ -362,28 +317,27 @@ acpi_rs_set_srs_method_data (
 	 */
 	params[0] = acpi_ut_create_internal_object (ACPI_TYPE_BUFFER);
 	if (!params[0]) {
-		status = AE_NO_MEMORY;
-		goto cleanup;
+		acpi_os_free (buffer.pointer);
+		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
-	params [1] = NULL;
 
 	/*
-	 *  Set up the parameter object
+	 * Set up the parameter object
 	 */
-	params[0]->buffer.length  = buffer_size_needed;
-	params[0]->buffer.pointer = byte_stream;
+	params[0]->buffer.length  = (u32) buffer.length;
+	params[0]->buffer.pointer = buffer.pointer;
+	params[0]->common.flags   = AOPOBJ_DATA_VALID;
+	params[1] = NULL;
 
 	/*
 	 * Execute the method, no return value
 	 */
 	status = acpi_ns_evaluate_relative (handle, "_SRS", params, NULL);
-	acpi_ut_remove_reference (params[0]);
 
 	/*
-	 * Clean up and return the status from Acpi_ns_evaluate_relative
+	 * Clean up and return the status from acpi_ns_evaluate_relative
 	 */
-cleanup:
-
+	acpi_ut_remove_reference (params[0]);
 	return_ACPI_STATUS (status);
 }
 
diff -urNp linux-5400/drivers/acpi/resources/rsxface.c linux-5410/drivers/acpi/resources/rsxface.c
--- linux-5400/drivers/acpi/resources/rsxface.c
+++ linux-5410/drivers/acpi/resources/rsxface.c
@@ -1,44 +1,60 @@
 /*******************************************************************************
  *
  * Module Name: rsxface - Public interfaces to the resource manager
- *              $Revision: 15 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acinterp.h"
-#include "acnamesp.h"
-#include "acresrc.h"
+#include <acpi/acpi.h>
+#include <acpi/acresrc.h>
 
 #define _COMPONENT          ACPI_RESOURCES
-	 MODULE_NAME         ("rsxface")
+	 ACPI_MODULE_NAME    ("rsxface")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_get_irq_routing_table
+ * FUNCTION:    acpi_get_irq_routing_table
  *
- * PARAMETERS:  Device_handle   - a handle to the Bus device we are querying
- *              Ret_buffer      - a pointer to a buffer to receive the
+ * PARAMETERS:  device_handle   - a handle to the Bus device we are querying
+ *              ret_buffer      - a pointer to a buffer to receive the
  *                                current resources for the device
  *
  * RETURN:      Status
@@ -46,25 +62,25 @@
  * DESCRIPTION: This function is called to get the IRQ routing table for a
  *              specific bus.  The caller must first acquire a handle for the
  *              desired bus.  The routine table is placed in the buffer pointed
- *              to by the Ret_buffer variable parameter.
+ *              to by the ret_buffer variable parameter.
  *
  *              If the function fails an appropriate status will be returned
- *              and the value of Ret_buffer is undefined.
+ *              and the value of ret_buffer is undefined.
  *
  *              This function attempts to execute the _PRT method contained in
- *              the object indicated by the passed Device_handle.
+ *              the object indicated by the passed device_handle.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_get_irq_routing_table (
-	acpi_handle             device_handle,
-	acpi_buffer             *ret_buffer)
+	acpi_handle                     device_handle,
+	struct acpi_buffer              *ret_buffer)
 {
-	acpi_status             status;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Acpi_get_irq_routing_table ");
+	ACPI_FUNCTION_TRACE ("acpi_get_irq_routing_table ");
 
 
 	/*
@@ -73,12 +89,15 @@ acpi_get_irq_routing_table (
 	 * we also need a valid pointer in the buffer. If it's a zero buffer length,
 	 * we'll be returning the needed buffer size, so keep going.
 	 */
-	if ((!device_handle)        ||
-		(!ret_buffer)           ||
-		((!ret_buffer->pointer) && (ret_buffer->length))) {
+	if (!device_handle) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
+	status = acpi_ut_validate_buffer (ret_buffer);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
 	status = acpi_rs_get_prt_method_data (device_handle, ret_buffer);
 	return_ACPI_STATUS (status);
 }
@@ -86,11 +105,11 @@ acpi_get_irq_routing_table (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_get_current_resources
+ * FUNCTION:    acpi_get_current_resources
  *
- * PARAMETERS:  Device_handle   - a handle to the device object for the
+ * PARAMETERS:  device_handle   - a handle to the device object for the
  *                                device we are querying
- *              Ret_buffer      - a pointer to a buffer to receive the
+ *              ret_buffer      - a pointer to a buffer to receive the
  *                                current resources for the device
  *
  * RETURN:      Status
@@ -98,25 +117,25 @@ acpi_get_irq_routing_table (
  * DESCRIPTION: This function is called to get the current resources for a
  *              specific device.  The caller must first acquire a handle for
  *              the desired device.  The resource data is placed in the buffer
- *              pointed to by the Ret_buffer variable parameter.
+ *              pointed to by the ret_buffer variable parameter.
  *
  *              If the function fails an appropriate status will be returned
- *              and the value of Ret_buffer is undefined.
+ *              and the value of ret_buffer is undefined.
  *
  *              This function attempts to execute the _CRS method contained in
- *              the object indicated by the passed Device_handle.
+ *              the object indicated by the passed device_handle.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_get_current_resources (
-	acpi_handle             device_handle,
-	acpi_buffer             *ret_buffer)
+	acpi_handle                     device_handle,
+	struct acpi_buffer              *ret_buffer)
 {
-	acpi_status             status;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Acpi_get_current_resources");
+	ACPI_FUNCTION_TRACE ("acpi_get_current_resources");
 
 
 	/*
@@ -125,12 +144,15 @@ acpi_get_current_resources (
 	 * we also need a valid pointer in the buffer. If it's a zero buffer length,
 	 * we'll be returning the needed buffer size, so keep going.
 	 */
-	if ((!device_handle)        ||
-		(!ret_buffer)           ||
-		((ret_buffer->length) && (!ret_buffer->pointer))) {
+	if (!device_handle) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
+	status = acpi_ut_validate_buffer (ret_buffer);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
 	status = acpi_rs_get_crs_method_data (device_handle, ret_buffer);
 	return_ACPI_STATUS (status);
 }
@@ -138,11 +160,11 @@ acpi_get_current_resources (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_get_possible_resources
+ * FUNCTION:    acpi_get_possible_resources
  *
- * PARAMETERS:  Device_handle   - a handle to the device object for the
+ * PARAMETERS:  device_handle   - a handle to the device object for the
  *                                device we are querying
- *              Ret_buffer      - a pointer to a buffer to receive the
+ *              ret_buffer      - a pointer to a buffer to receive the
  *                                resources for the device
  *
  * RETURN:      Status
@@ -150,22 +172,22 @@ acpi_get_current_resources (
  * DESCRIPTION: This function is called to get a list of the possible resources
  *              for a specific device.  The caller must first acquire a handle
  *              for the desired device.  The resource data is placed in the
- *              buffer pointed to by the Ret_buffer variable.
+ *              buffer pointed to by the ret_buffer variable.
  *
  *              If the function fails an appropriate status will be returned
- *              and the value of Ret_buffer is undefined.
+ *              and the value of ret_buffer is undefined.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_get_possible_resources (
-	acpi_handle             device_handle,
-	acpi_buffer             *ret_buffer)
+	acpi_handle                     device_handle,
+	struct acpi_buffer              *ret_buffer)
 {
-	acpi_status             status;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Acpi_get_possible_resources");
+	ACPI_FUNCTION_TRACE ("acpi_get_possible_resources");
 
 
 	/*
@@ -174,12 +196,15 @@ acpi_get_possible_resources (
 	 * we also need a valid pointer in the buffer. If it's a zero buffer length,
 	 * we'll be returning the needed buffer size, so keep going.
 	 */
-	if ((!device_handle)        ||
-		(!ret_buffer)           ||
-		((ret_buffer->length) && (!ret_buffer->pointer))) {
+	if (!device_handle) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
+	status = acpi_ut_validate_buffer (ret_buffer);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
 	status = acpi_rs_get_prs_method_data (device_handle, ret_buffer);
 	return_ACPI_STATUS (status);
 }
@@ -187,11 +212,96 @@ acpi_get_possible_resources (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_set_current_resources
+ * FUNCTION:    acpi_walk_resources
+ *
+ * PARAMETERS:  device_handle   - a handle to the device object for the
+ *                                device we are querying
+ *              Path            - method name of the resources we want
+ *                                (METHOD_NAME__CRS or METHOD_NAME__PRS)
+ *              user_function   - called for each resource
+ *              Context         - passed to user_function
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Retrieves the current or possible resource list for the
+ *              specified device.  The user_function is called once for
+ *              each resource in the list.
  *
- * PARAMETERS:  Device_handle   - a handle to the device object for the
+ ******************************************************************************/
+
+acpi_status
+acpi_walk_resources (
+	acpi_handle                             device_handle,
+	char                                    *path,
+	ACPI_WALK_RESOURCE_CALLBACK     user_function,
+	void                                    *context)
+{
+	acpi_status                         status;
+	struct acpi_buffer                  buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	struct acpi_resource                *resource;
+
+
+	ACPI_FUNCTION_TRACE ("acpi_walk_resources");
+
+
+	if (!device_handle ||
+		(ACPI_STRNCMP (path, METHOD_NAME__CRS, sizeof (METHOD_NAME__CRS)) &&
+		 ACPI_STRNCMP (path, METHOD_NAME__PRS, sizeof (METHOD_NAME__PRS)))) {
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
+
+	status = acpi_rs_get_method_data (device_handle, path, &buffer);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	resource = (struct acpi_resource *) buffer.pointer;
+	for (;;) {
+		if (!resource || resource->id == ACPI_RSTYPE_END_TAG) {
+			break;
+		}
+
+		status = user_function (resource, context);
+
+		switch (status) {
+		case AE_OK:
+		case AE_CTRL_DEPTH:
+
+			/* Just keep going */
+			status = AE_OK;
+			break;
+
+		case AE_CTRL_TERMINATE:
+
+			/* Exit now, with OK stats */
+
+			status = AE_OK;
+			goto cleanup;
+
+		default:
+
+			/* All others are valid exceptions */
+
+			goto cleanup;
+		}
+
+		resource = ACPI_NEXT_RESOURCE (resource);
+	}
+
+cleanup:
+
+	acpi_os_free (buffer.pointer);
+	return_ACPI_STATUS (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_set_current_resources
+ *
+ * PARAMETERS:  device_handle   - a handle to the device object for the
  *                                device we are changing the resources of
- *              In_buffer       - a pointer to a buffer containing the
+ *              in_buffer       - a pointer to a buffer containing the
  *                                resources to be set for the device
  *
  * RETURN:      Status
@@ -199,19 +309,19 @@ acpi_get_possible_resources (
  * DESCRIPTION: This function is called to set the current resources for a
  *              specific device.  The caller must first acquire a handle for
  *              the desired device.  The resource data is passed to the routine
- *              the buffer pointed to by the In_buffer variable.
+ *              the buffer pointed to by the in_buffer variable.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_set_current_resources (
-	acpi_handle             device_handle,
-	acpi_buffer             *in_buffer)
+	acpi_handle                     device_handle,
+	struct acpi_buffer              *in_buffer)
 {
-	acpi_status             status;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Acpi_set_current_resources");
+	ACPI_FUNCTION_TRACE ("acpi_set_current_resources");
 
 
 	/*
@@ -227,3 +337,76 @@ acpi_set_current_resources (
 	status = acpi_rs_set_srs_method_data (device_handle, in_buffer);
 	return_ACPI_STATUS (status);
 }
+
+
+#define ACPI_COPY_FIELD(out, in, field)  ((out)->field = (in)->field)
+#define ACPI_COPY_ADDRESS(out, in)                      \
+	ACPI_COPY_FIELD(out, in, resource_type);             \
+	ACPI_COPY_FIELD(out, in, producer_consumer);         \
+	ACPI_COPY_FIELD(out, in, decode);                    \
+	ACPI_COPY_FIELD(out, in, min_address_fixed);         \
+	ACPI_COPY_FIELD(out, in, max_address_fixed);         \
+	ACPI_COPY_FIELD(out, in, attribute);                 \
+	ACPI_COPY_FIELD(out, in, granularity);               \
+	ACPI_COPY_FIELD(out, in, min_address_range);         \
+	ACPI_COPY_FIELD(out, in, max_address_range);         \
+	ACPI_COPY_FIELD(out, in, address_translation_offset); \
+	ACPI_COPY_FIELD(out, in, address_length);            \
+	ACPI_COPY_FIELD(out, in, resource_source);
+
+/******************************************************************************
+ *
+ * FUNCTION:    acpi_resource_to_address64
+ *
+ * PARAMETERS:  resource                - Pointer to a resource
+ *              out                     - Pointer to the users's return
+ *                                        buffer (a struct
+ *                                        struct acpi_resource_address64)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: If the resource is an address16, address32, or address64,
+ *              copy it to the address64 return buffer.  This saves the
+ *              caller from having to duplicate code for different-sized
+ *              addresses.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_resource_to_address64 (
+	struct acpi_resource                *resource,
+	struct acpi_resource_address64      *out)
+{
+	struct acpi_resource_address16      *address16;
+	struct acpi_resource_address32      *address32;
+
+
+	switch (resource->id) {
+	case ACPI_RSTYPE_ADDRESS16:
+
+		address16 = (struct acpi_resource_address16 *) &resource->data;
+		ACPI_COPY_ADDRESS(out, address16);
+		break;
+
+
+	case ACPI_RSTYPE_ADDRESS32:
+
+		address32 = (struct acpi_resource_address32 *) &resource->data;
+		ACPI_COPY_ADDRESS(out, address32);
+		break;
+
+
+	case ACPI_RSTYPE_ADDRESS64:
+
+		/* Simple copy for 64 bit source */
+
+		ACPI_MEMCPY (out, &resource->data, sizeof (struct acpi_resource_address64));
+		break;
+
+
+	default:
+		return (AE_BAD_PARAMETER);
+	}
+
+	return (AE_OK);
+}
diff -urNp linux-5400/drivers/acpi/system.c linux-5410/drivers/acpi/system.c
--- linux-5400/drivers/acpi/system.c
+++ linux-5410/drivers/acpi/system.c
@@ -0,0 +1,1332 @@
+/*
+ *  acpi_system.c - ACPI System Driver ($Revision: 57 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/sysrq.h>
+#include <linux/compatmac.h>
+#include <linux/proc_fs.h>
+#include <linux/pm.h>
+#include <asm/uaccess.h>
+#include <asm/acpi.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+#ifdef CONFIG_X86
+#ifdef CONFIG_ACPI_SLEEP
+#include <linux/mc146818rtc.h>
+#include <linux/irq.h>
+#include <asm/hw_irq.h>
+#endif
+#endif
+
+
+#define _COMPONENT		ACPI_SYSTEM_COMPONENT
+ACPI_MODULE_NAME		("acpi_system")
+
+#define PREFIX			"ACPI: "
+
+extern FADT_DESCRIPTOR		acpi_fadt;
+
+static int acpi_system_add (struct acpi_device *device);
+static int acpi_system_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_system_driver = {
+	.name =		ACPI_SYSTEM_DRIVER_NAME,
+	.class =	ACPI_SYSTEM_CLASS,
+	.ids =		ACPI_SYSTEM_HID,
+	.ops =		{
+				.add =		acpi_system_add,
+				.remove =	acpi_system_remove
+			},
+};
+
+struct acpi_system
+{
+	acpi_handle		handle;
+	u8			states[ACPI_S_STATE_COUNT];
+};
+
+/* Global vars for handling event proc entry */
+static spinlock_t		acpi_system_event_lock = SPIN_LOCK_UNLOCKED;
+int				event_is_open = 0;
+extern struct list_head		acpi_bus_event_list;
+extern wait_queue_head_t	acpi_bus_event_queue;
+
+/* --------------------------------------------------------------------------
+                                  System Sleep
+   -------------------------------------------------------------------------- */
+
+#ifdef CONFIG_PM
+
+static void
+acpi_power_off (void)
+{
+
+	/* Some SMP machines can only power off on the boot CPU. */
+	set_cpus_allowed(current, 1UL << cpu_logical_map(0));
+	acpi_enter_sleep_state_prep(ACPI_STATE_S5);
+	ACPI_DISABLE_IRQS();
+	acpi_enter_sleep_state(ACPI_STATE_S5);
+
+	printk(KERN_EMERG "ACPI: cannot power off machine\n");
+}
+
+#endif /*CONFIG_PM*/
+
+
+#ifdef CONFIG_ACPI_SLEEP
+
+/**
+ * acpi_system_restore_state - OS-specific restoration of state
+ * @state:	sleep state we're exiting
+ *
+ * Note that if we're coming back from S4, the memory image should have
+ * already been loaded from the disk and is already in place.  (Otherwise how
+ * else would we be here?).
+ */
+acpi_status
+acpi_system_restore_state(
+	u32			state)
+{
+	/* 
+	 * We should only be here if we're coming back from STR or STD.
+	 * And, in the case of the latter, the memory image should have already
+	 * been loaded from disk.
+	 */
+	if (state > ACPI_STATE_S1) {
+		acpi_restore_state_mem();
+
+		/* Do _early_ resume for irqs.  Required by
+		 * ACPI specs.
+		 */
+		/* TBD: call arch dependant reinitialization of the 
+		 * interrupts.
+		 */
+#ifdef CONFIG_X86
+		init_8259A(0);
+#endif
+		/* wait for power to come back */
+		mdelay(1000);
+
+	}
+
+	/* Be really sure that irqs are disabled. */
+	ACPI_DISABLE_IRQS();
+
+	/* Wait a little again, just in case... */
+	mdelay(1000);
+
+	/* enable interrupts once again */
+	ACPI_ENABLE_IRQS();
+
+	/* turn all the devices back on */
+	if (state > ACPI_STATE_S1)
+		pm_send_all(PM_RESUME, (void *)0);
+
+	return AE_OK;
+}
+
+
+/**
+ * acpi_system_save_state - save OS specific state and power down devices
+ * @state:	sleep state we're entering.
+ *
+ * This handles saving all context to memory, and possibly disk.
+ * First, we call to the device driver layer to save device state.
+ * Once we have that, we save whatevery processor and kernel state we
+ * need to memory.
+ * If we're entering S4, we then write the memory image to disk.
+ *
+ * Only then it is safe for us to power down devices, since we may need
+ * the disks and upstream buses to write to.
+ */
+acpi_status
+acpi_system_save_state(
+	u32			state)
+{
+	int			error = 0;
+
+	/* Send notification to devices that they will be suspended.
+	 * If any device or driver cannot make the transition, either up
+	 * or down, we'll get an error back.
+	 */
+	if (state > ACPI_STATE_S1) {
+		error = pm_send_all(PM_SAVE_STATE, (void *)3);
+		if (error)
+			return AE_ERROR;
+	}
+
+	if (state < ACPI_STATE_S5) {
+		/* Tell devices to stop I/O and actually save their state.
+		 * It is theoretically possible that something could fail,
+		 * so handle that gracefully..
+		 */
+		if (state > ACPI_STATE_S1 && state != ACPI_STATE_S5) {
+			error = pm_send_all(PM_SUSPEND, (void *)3);
+			if (error) {
+				/* Tell devices to restore state if they have
+				 * it saved and to start taking I/O requests.
+				 */
+				pm_send_all(PM_RESUME, (void *)0);
+				return error;
+			}
+		}
+		
+		/* flush caches */
+		ACPI_FLUSH_CPU_CACHE();
+
+		/* Do arch specific saving of state. */
+		if (state > ACPI_STATE_S1) {
+			error = acpi_save_state_mem();
+
+			/* TBD: if no s4bios, write codes for
+			 * acpi_save_state_disk()...
+			 */
+#if 0
+			if (!error && (state == ACPI_STATE_S4))
+				error = acpi_save_state_disk();
+#endif
+			if (error) {
+				pm_send_all(PM_RESUME, (void *)0);
+				return error;
+			}
+		}
+	}
+	/* disable interrupts
+	 * Note that acpi_suspend -- our caller -- will do this once we return.
+	 * But, we want it done early, so we don't get any suprises during
+	 * the device suspend sequence.
+	 */
+	ACPI_DISABLE_IRQS();
+
+	/* Unconditionally turn off devices.
+	 * Obvious if we enter a sleep state.
+	 * If entering S5 (soft off), this should put devices in a
+	 * quiescent state.
+	 */
+
+	if (state > ACPI_STATE_S1) {
+		error = pm_send_all(PM_SUSPEND, (void *)3);
+
+		/* We're pretty screwed if we got an error from this.
+		 * We try to recover by simply calling our own restore_state
+		 * function; see above for definition.
+		 *
+		 * If it's S5 though, go through with it anyway..
+		 */
+		if (error && state != ACPI_STATE_S5)
+			acpi_system_restore_state(state);
+	}
+	return error ? AE_ERROR : AE_OK;
+}
+
+
+/****************************************************************************
+ *
+ * FUNCTION:    acpi_system_suspend
+ *
+ * PARAMETERS:  %state: Sleep state to enter.
+ *
+ * RETURN:      acpi_status, whether or not we successfully entered and
+ *              exited sleep.
+ *
+ * DESCRIPTION: Perform OS-specific action to enter sleep state.
+ *              This is the final step in going to sleep, per spec.  If we
+ *              know we're coming back (i.e. not entering S5), we save the
+ *              processor flags. [ We'll have to save and restore them anyway,
+ *              so we use the arch-agnostic save_flags and restore_flags
+ *              here.]  We then set the place to return to in arch-specific
+ *              globals using arch_set_return_point. Finally, we call the
+ *              ACPI function to write the proper values to I/O ports.
+ *
+ ****************************************************************************/
+
+acpi_status
+acpi_system_suspend(
+	u32		state)
+{
+	acpi_status		status = AE_ERROR;
+	unsigned long		flags = 0;
+
+	local_irq_save(flags);
+	/* kernel_fpu_begin(); */
+
+	switch (state) {
+	case ACPI_STATE_S1:
+	case ACPI_STATE_S5:
+		barrier();
+		status = acpi_enter_sleep_state(state);
+		break;
+	case ACPI_STATE_S4:
+		do_suspend_lowlevel_s4bios(0);
+		break;
+	}
+
+	/* kernel_fpu_end(); */
+	local_irq_restore(flags);
+
+	return status;
+}
+
+
+
+/**
+ * acpi_suspend - OS-agnostic system suspend/resume support (S? states)
+ * @state:	state we're entering
+ *
+ */
+acpi_status
+acpi_suspend (
+	u32			state)
+{
+	acpi_status status;
+
+	/* only support S1 and S5 on kernel 2.4 */
+	if (state != ACPI_STATE_S1 && state != ACPI_STATE_S4
+	    && state != ACPI_STATE_S5)
+		return AE_ERROR;
+
+
+	if (ACPI_STATE_S4 == state) {
+		/* For s4bios, we need a wakeup address. */
+		if (1 == acpi_gbl_FACS->S4bios_f &&
+		    0 != acpi_gbl_FADT->smi_cmd) {
+			if (!acpi_wakeup_address)
+				return AE_ERROR;
+			acpi_set_firmware_waking_vector((acpi_physical_address) acpi_wakeup_address);
+		} else
+			/* We don't support S4 under 2.4.  Give up */
+			return AE_ERROR;
+	}
+
+	status = acpi_system_save_state(state);
+	if (!ACPI_SUCCESS(status) && state != ACPI_STATE_S5)
+		return status;
+
+	acpi_enter_sleep_state_prep(state);
+
+	/* disable interrupts and flush caches */
+	ACPI_DISABLE_IRQS();
+	ACPI_FLUSH_CPU_CACHE();
+
+	/* perform OS-specific sleep actions */
+	status = acpi_system_suspend(state);
+
+	/* Even if we failed to go to sleep, all of the devices are in an suspended
+	 * mode. So, we run these unconditionaly to make sure we have a usable system
+	 * no matter what.
+	 */
+	acpi_leave_sleep_state(state);
+	acpi_system_restore_state(state);
+
+	/* make sure interrupts are enabled */
+	ACPI_ENABLE_IRQS();
+
+	/* reset firmware waking vector */
+	acpi_set_firmware_waking_vector((acpi_physical_address) 0);
+
+	return status;
+}
+
+#endif /* CONFIG_ACPI_SLEEP */
+
+
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_system_read_info (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_system	*system = (struct acpi_system *) data;
+	char			*p = page;
+	int			size = 0;
+	u32			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_system_read_info");
+
+	if (!system || (off != 0))
+		goto end;
+
+	p += sprintf(p, "version:                 %x\n", ACPI_CA_VERSION);
+
+	p += sprintf(p, "states:                  ");
+	for (i=0; i<ACPI_S_STATE_COUNT; i++) {
+		if (system->states[i]) {
+			p += sprintf(p, "S%d ", i);
+			if (i == ACPI_STATE_S4 &&
+			    acpi_gbl_FACS->S4bios_f &&
+			    0 != acpi_gbl_FADT->smi_cmd)
+				p += sprintf(p, "S4Bios ");
+		}
+	}
+	p += sprintf(p, "\n");
+
+end:
+	size = (p - page);
+	if (size <= off+count) *eof = 1;
+	*start = page + off;
+	size -= off;
+	if (size>count) size = count;
+	if (size<0) size = 0;
+
+	return_VALUE(size);
+}
+
+static int acpi_system_open_event(struct inode *inode, struct file *file);
+static ssize_t acpi_system_read_event (struct file*, char*, size_t, loff_t*);
+static int acpi_system_close_event(struct inode *inode, struct file *file);
+static unsigned int acpi_system_poll_event(struct file *file, poll_table *wait);
+
+
+static struct file_operations acpi_system_event_ops = {
+	.open =		acpi_system_open_event,
+	.read =		acpi_system_read_event,
+	.release =	acpi_system_close_event,
+	.poll =		acpi_system_poll_event,
+};
+
+static int
+acpi_system_open_event(struct inode *inode, struct file *file)
+{
+	spin_lock_irq (&acpi_system_event_lock);
+
+	if(event_is_open)
+		goto out_busy;
+
+	event_is_open = 1;
+
+	spin_unlock_irq (&acpi_system_event_lock);
+	return 0;
+
+out_busy:
+	spin_unlock_irq (&acpi_system_event_lock);
+	return -EBUSY;
+}
+
+static ssize_t
+acpi_system_read_event (
+	struct file		*file,
+	char			*buffer,
+	size_t			count,
+	loff_t			*ppos)
+{
+	int			result = 0;
+	struct acpi_bus_event	event;
+	static char		str[ACPI_MAX_STRING];
+	static int		chars_remaining = 0;
+	static char		*ptr;
+
+
+	ACPI_FUNCTION_TRACE("acpi_system_read_event");
+
+	if (!chars_remaining) {
+		memset(&event, 0, sizeof(struct acpi_bus_event));
+
+		if ((file->f_flags & O_NONBLOCK)
+		    && (list_empty(&acpi_bus_event_list)))
+			return_VALUE(-EAGAIN);
+
+		result = acpi_bus_receive_event(&event);
+		if (result) {
+			return_VALUE(-EIO);
+		}
+
+		chars_remaining = sprintf(str, "%s %s %08x %08x\n", 
+			event.device_class?event.device_class:"<unknown>",
+			event.bus_id?event.bus_id:"<unknown>", 
+			event.type, event.data);
+		ptr = str;
+	}
+
+	if (chars_remaining < count) {
+		count = chars_remaining;
+	}
+
+	if (copy_to_user(buffer, ptr, count))
+		return_VALUE(-EFAULT);
+
+	*ppos += count;
+	chars_remaining -= count;
+	ptr += count;
+
+	return_VALUE(count);
+}
+
+static int
+acpi_system_close_event(struct inode *inode, struct file *file)
+{
+	spin_lock_irq (&acpi_system_event_lock);
+	event_is_open = 0;
+	spin_unlock_irq (&acpi_system_event_lock);
+	return 0;
+}
+
+static unsigned int
+acpi_system_poll_event(
+	struct file		*file,
+	poll_table		*wait)
+{
+	poll_wait(file, &acpi_bus_event_queue, wait);
+	if (!list_empty(&acpi_bus_event_list))
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+
+static ssize_t acpi_system_read_dsdt (struct file*, char*, size_t, loff_t*);
+
+static struct file_operations acpi_system_dsdt_ops = {
+	.read =			acpi_system_read_dsdt,
+};
+
+static ssize_t
+acpi_system_read_dsdt (
+	struct file		*file,
+	char			*buffer,
+	size_t			count,
+	loff_t			*ppos)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_buffer	dsdt = {ACPI_ALLOCATE_BUFFER, NULL};
+	void			*data = 0;
+	size_t			size = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_system_read_dsdt");
+
+	status = acpi_get_table(ACPI_TABLE_DSDT, 1, &dsdt);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	if (*ppos < dsdt.length) {
+		data = dsdt.pointer + file->f_pos;
+		size = dsdt.length - file->f_pos;
+		if (size > count)
+			size = count;
+		if (copy_to_user(buffer, data, size)) {
+			acpi_os_free(dsdt.pointer);
+			return_VALUE(-EFAULT);
+		}
+	}
+
+	acpi_os_free(dsdt.pointer);
+
+	*ppos += size;
+
+	return_VALUE(size);
+}
+
+
+static ssize_t acpi_system_read_fadt (struct file*, char*, size_t, loff_t*);
+
+static struct file_operations acpi_system_fadt_ops = {
+	.read =			acpi_system_read_fadt,
+};
+
+static ssize_t
+acpi_system_read_fadt (
+	struct file		*file,
+	char			*buffer,
+	size_t			count,
+	loff_t			*ppos)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_buffer	fadt = {ACPI_ALLOCATE_BUFFER, NULL};
+	void			*data = 0;
+	size_t			size = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_system_read_fadt");
+
+	status = acpi_get_table(ACPI_TABLE_FADT, 1, &fadt);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	if (*ppos < fadt.length) {
+		data = fadt.pointer + file->f_pos;
+		size = fadt.length - file->f_pos;
+		if (size > count)
+			size = count;
+		if (copy_to_user(buffer, data, size)) {
+			acpi_os_free(fadt.pointer);
+			return_VALUE(-EFAULT);
+		}
+	}
+
+	acpi_os_free(fadt.pointer);
+
+	*ppos += size;
+
+	return_VALUE(size);
+}
+
+
+#ifdef ACPI_DEBUG_OUTPUT
+
+static int
+acpi_system_read_debug (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	char			*p = page;
+	int 			size = 0;
+
+	if (off != 0)
+		goto end;
+
+	switch ((unsigned long) data) {
+	case 0:
+		p += sprintf(p, "0x%08x\n", acpi_dbg_layer);
+		break;
+	case 1:
+		p += sprintf(p, "0x%08x\n", acpi_dbg_level);
+		break;
+	default:
+		p += sprintf(p, "Invalid debug option\n");
+		break;
+	}
+	
+end:
+	size = (p - page);
+	if (size <= off+count) *eof = 1;
+	*start = page + off;
+	size -= off;
+	if (size>count) size = count;
+	if (size<0) size = 0;
+
+	return size;
+}
+
+
+static int
+acpi_system_write_debug (
+	struct file             *file,
+        const char              *buffer,
+	unsigned long           count,
+        void                    *data)
+{
+	char			debug_string[12] = {'\0'};
+
+	ACPI_FUNCTION_TRACE("acpi_system_write_debug");
+
+	if (count > sizeof(debug_string) - 1)
+		return_VALUE(-EINVAL);
+
+	if (copy_from_user(debug_string, buffer, count))
+		return_VALUE(-EFAULT);
+
+	debug_string[count] = '\0';
+
+	switch ((unsigned long) data) {
+	case 0:
+		acpi_dbg_layer = simple_strtoul(debug_string, NULL, 0);
+		break;
+	case 1:
+		acpi_dbg_level = simple_strtoul(debug_string, NULL, 0);
+		break;
+	default:
+		return_VALUE(-EINVAL);
+	}
+
+	return_VALUE(count);
+}
+
+#endif /* ACPI_DEBUG_OUTPUT */
+
+
+#ifdef CONFIG_ACPI_SLEEP
+
+static int
+acpi_system_read_sleep (
+        char                    *page,
+        char                    **start,
+        off_t                   off,
+        int                     count,
+        int                     *eof,
+        void                    *data)
+{
+	struct acpi_system	*system = (struct acpi_system *) data;
+	char			*p = page;
+	int			size;
+	int			i;
+
+	ACPI_FUNCTION_TRACE("acpi_system_read_sleep");
+
+	if (!system || (off != 0))
+		goto end;
+
+	for (i = 0; i <= ACPI_STATE_S5; i++) {
+		if (system->states[i]) {
+			p += sprintf(p,"S%d ", i);
+			if (i == ACPI_STATE_S4 && acpi_gbl_FACS->S4bios_f &&
+			    acpi_gbl_FADT->smi_cmd != 0)
+				p += sprintf(p, "S4Bios ");
+		}
+	}
+
+	p += sprintf(p, "\n");
+
+end:
+	size = (p - page);
+	if (size <= off+count) *eof = 1;
+	*start = page + off;
+	size -= off;
+	if (size>count) size = count;
+	if (size<0) size = 0;
+
+	return_VALUE(size);
+}
+
+
+static int
+acpi_system_write_sleep (
+	struct file		*file,
+	const char		*buffer,
+	unsigned long		count,
+	void			*data)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_system	*system = (struct acpi_system *) data;
+	char			state_string[12] = {'\0'};
+	u32			state = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_system_write_sleep");
+
+	if (!system || (count > sizeof(state_string) - 1))
+		return_VALUE(-EINVAL);
+
+	if (copy_from_user(state_string, buffer, count))
+		return_VALUE(-EFAULT);
+	
+	state_string[count] = '\0';
+	
+	state = simple_strtoul(state_string, NULL, 0);
+	
+	if (!system->states[state])
+		return_VALUE(-ENODEV);
+
+	/*
+	 * If S4 is supported by the OS, then we should assume that
+	 * echo 4b > /proc/acpi/sleep is for s4bios.
+	 * Since we have only s4bios, we assume that acpi_suspend failed
+	 * if no s4bios support.
+	 */
+	status = acpi_suspend(state);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+	
+	return_VALUE(count);
+}
+
+
+static int
+acpi_system_read_alarm (
+	char                    *page,
+	char                    **start,
+	off_t                   off,
+	int                     count,
+	int                     *eof,
+	void                    *context)
+{
+	char			*p = page;
+	int			size = 0;
+	u32			sec, min, hr;
+	u32			day, mo, yr;
+
+	ACPI_FUNCTION_TRACE("acpi_system_read_alarm");
+
+	if (off != 0)
+		goto end;
+
+	spin_lock(&rtc_lock);
+
+	sec = CMOS_READ(RTC_SECONDS_ALARM);
+	min = CMOS_READ(RTC_MINUTES_ALARM);
+	hr = CMOS_READ(RTC_HOURS_ALARM);
+
+#if 0	/* If we ever get an FACP with proper values... */
+	if (acpi_gbl_FADT->day_alrm)
+		day = CMOS_READ(acpi_gbl_FADT->day_alrm);
+	else
+		day =  CMOS_READ(RTC_DAY_OF_MONTH);
+	if (acpi_gbl_FADT->mon_alrm)
+		mo = CMOS_READ(acpi_gbl_FADT->mon_alrm);
+	else
+		mo = CMOS_READ(RTC_MONTH);;
+	if (acpi_gbl_FADT->century)
+		yr = CMOS_READ(acpi_gbl_FADT->century) * 100 + CMOS_READ(RTC_YEAR);
+	else
+		yr = CMOS_READ(RTC_YEAR);
+#else
+	day = CMOS_READ(RTC_DAY_OF_MONTH);
+	mo = CMOS_READ(RTC_MONTH);
+	yr = CMOS_READ(RTC_YEAR);
+#endif
+
+	spin_unlock(&rtc_lock);
+
+	BCD_TO_BIN(sec);
+	BCD_TO_BIN(min);
+	BCD_TO_BIN(hr);
+	BCD_TO_BIN(day);
+	BCD_TO_BIN(mo);
+	BCD_TO_BIN(yr);
+
+#if 0
+	/* we're trusting the FADT (see above)*/
+#else
+	/* If we're not trusting the FADT, we should at least make it
+	 * right for _this_ century... ehm, what is _this_ century?
+	 *
+	 * TBD:
+	 *  ASAP: find piece of code in the kernel, e.g. star tracker driver,
+	 *        which we can trust to determine the century correctly. Atom
+	 *        watch driver would be nice, too...
+	 *
+	 *  if that has not happened, change for first release in 2050:
+ 	 *        if (yr<50)
+	 *                yr += 2100;
+	 *        else
+	 *                yr += 2000;   // current line of code
+	 *
+	 *  if that has not happened either, please do on 2099/12/31:23:59:59
+	 *        s/2000/2100
+	 *
+	 */
+	yr += 2000;
+#endif
+
+	p += sprintf(p,"%4.4u-", yr);
+	p += (mo > 12)  ? sprintf(p, "**-")  : sprintf(p, "%2.2u-", mo);
+	p += (day > 31) ? sprintf(p, "** ")  : sprintf(p, "%2.2u ", day);
+	p += (hr > 23)  ? sprintf(p, "**:")  : sprintf(p, "%2.2u:", hr);
+	p += (min > 59) ? sprintf(p, "**:")  : sprintf(p, "%2.2u:", min);
+	p += (sec > 59) ? sprintf(p, "**\n") : sprintf(p, "%2.2u\n", sec);
+
+ end:
+	size = p - page;
+	if (size < count) *eof = 1;
+	else if (size > count) size = count;
+	if (size < 0) size = 0;
+	*start = page;
+
+	return_VALUE(size);
+}
+
+
+static int
+get_date_field (
+	char			**p,
+	u32			*value)
+{
+	char			*next = NULL;
+	char			*string_end = NULL;
+	int			result = -EINVAL;
+
+	/*
+	 * Try to find delimeter, only to insert null.  The end of the
+	 * string won't have one, but is still valid.
+	 */
+	next = strpbrk(*p, "- :");
+	if (next)
+		*next++ = '\0';
+
+	*value = simple_strtoul(*p, &string_end, 10);
+
+	/* Signal success if we got a good digit */
+	if (string_end != *p)
+		result = 0;
+
+	if (next)
+		*p = next;
+
+	return result;
+}
+
+
+static int
+acpi_system_write_alarm (
+	struct file		*file,
+	const char		*buffer,
+	unsigned long		count,
+	void			*data)
+{
+	int			result = 0;
+	char			alarm_string[30] = {'\0'};
+	char			*p = alarm_string;
+	u32			sec, min, hr, day, mo, yr;
+	int			adjust = 0;
+	unsigned char		rtc_control = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_system_write_alarm");
+
+	if (count > sizeof(alarm_string) - 1)
+		return_VALUE(-EINVAL);
+	
+	if (copy_from_user(alarm_string, buffer, count))
+		return_VALUE(-EFAULT);
+
+	alarm_string[count] = '\0';
+
+	/* check for time adjustment */
+	if (alarm_string[0] == '+') {
+		p++;
+		adjust = 1;
+	}
+
+	if ((result = get_date_field(&p, &yr)))
+		goto end;
+	if ((result = get_date_field(&p, &mo)))
+		goto end;
+	if ((result = get_date_field(&p, &day)))
+		goto end;
+	if ((result = get_date_field(&p, &hr)))
+		goto end;
+	if ((result = get_date_field(&p, &min)))
+		goto end;
+	if ((result = get_date_field(&p, &sec)))
+		goto end;
+
+	if (sec > 59) {
+		min += 1;
+		sec -= 60;
+	}
+	if (min > 59) {
+		hr += 1;
+		min -= 60;
+	}
+	if (hr > 23) {
+		day += 1;
+		hr -= 24;
+	}
+	if (day > 31) {
+		mo += 1;
+		day -= 31;
+	}
+	if (mo > 12) {
+		yr += 1;
+		mo -= 12;
+	}
+
+	spin_lock_irq(&rtc_lock);
+
+	rtc_control = CMOS_READ(RTC_CONTROL);
+	if (!(rtc_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
+		BIN_TO_BCD(yr);
+		BIN_TO_BCD(mo);
+		BIN_TO_BCD(day);
+		BIN_TO_BCD(hr);
+		BIN_TO_BCD(min);
+		BIN_TO_BCD(sec);
+	}
+
+	if (adjust) {
+		yr  += CMOS_READ(RTC_YEAR);
+		mo  += CMOS_READ(RTC_MONTH);
+		day += CMOS_READ(RTC_DAY_OF_MONTH);
+		hr  += CMOS_READ(RTC_HOURS);
+		min += CMOS_READ(RTC_MINUTES);
+		sec += CMOS_READ(RTC_SECONDS);
+	}
+
+	spin_unlock_irq(&rtc_lock);
+
+	if (!(rtc_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
+		BCD_TO_BIN(yr);
+		BCD_TO_BIN(mo);
+		BCD_TO_BIN(day);
+		BCD_TO_BIN(hr);
+		BCD_TO_BIN(min);
+		BCD_TO_BIN(sec);
+	}
+
+	if (sec > 59) {
+		min++;
+		sec -= 60;
+	}
+	if (min > 59) {
+		hr++;
+		min -= 60;
+	}
+	if (hr > 23) {
+		day++;
+		hr -= 24;
+	}
+	if (day > 31) {
+		mo++;
+		day -= 31;
+	}
+	if (mo > 12) {
+		yr++;
+		mo -= 12;
+	}
+	if (!(rtc_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
+		BIN_TO_BCD(yr);
+		BIN_TO_BCD(mo);
+		BIN_TO_BCD(day);
+		BIN_TO_BCD(hr);
+		BIN_TO_BCD(min);
+		BIN_TO_BCD(sec);
+	}
+
+	spin_lock_irq(&rtc_lock);
+
+	/* write the fields the rtc knows about */
+	CMOS_WRITE(hr, RTC_HOURS_ALARM);
+	CMOS_WRITE(min, RTC_MINUTES_ALARM);
+	CMOS_WRITE(sec, RTC_SECONDS_ALARM);
+
+	/*
+	 * If the system supports an enhanced alarm it will have non-zero
+	 * offsets into the CMOS RAM here -- which for some reason are pointing
+	 * to the RTC area of memory.
+	 */
+#if 0
+	if (acpi_gbl_FADT->day_alrm)
+		CMOS_WRITE(day, acpi_gbl_FADT->day_alrm);
+	if (acpi_gbl_FADT->mon_alrm)
+		CMOS_WRITE(mo, acpi_gbl_FADT->mon_alrm);
+	if (acpi_gbl_FADT->century)
+		CMOS_WRITE(yr/100, acpi_gbl_FADT->century);
+#endif
+	/* enable the rtc alarm interrupt */
+	if (!(rtc_control & RTC_AIE)) {
+		rtc_control |= RTC_AIE;
+		CMOS_WRITE(rtc_control,RTC_CONTROL);
+		CMOS_READ(RTC_INTR_FLAGS);
+	}
+
+	spin_unlock_irq(&rtc_lock);
+
+	acpi_set_register(ACPI_BITREG_RT_CLOCK_ENABLE, 1, ACPI_MTX_LOCK);
+
+	file->f_pos += count;
+
+	result = 0;
+end:
+	return_VALUE(result ? result : count);
+}
+
+#endif /*CONFIG_ACPI_SLEEP*/
+
+
+static int
+acpi_system_add_fs (
+	struct acpi_device	*device)
+{
+	struct proc_dir_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_system_add_fs");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	/* 'info' [R] */
+	entry = create_proc_entry(ACPI_SYSTEM_FILE_INFO,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_SYSTEM_FILE_INFO));
+	else {
+		entry->read_proc = acpi_system_read_info;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'dsdt' [R] */
+	entry = create_proc_entry(ACPI_SYSTEM_FILE_DSDT,
+		S_IRUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_SYSTEM_FILE_DSDT));
+	else
+		entry->proc_fops = &acpi_system_dsdt_ops;
+
+	/* 'fadt' [R] */
+	entry = create_proc_entry(ACPI_SYSTEM_FILE_FADT,
+		S_IRUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_SYSTEM_FILE_FADT));
+	else
+		entry->proc_fops = &acpi_system_fadt_ops;
+
+	/* 'event' [R] */
+	entry = create_proc_entry(ACPI_SYSTEM_FILE_EVENT,
+		S_IRUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_SYSTEM_FILE_EVENT));
+	else
+		entry->proc_fops = &acpi_system_event_ops;
+
+#ifdef CONFIG_ACPI_SLEEP
+
+	/* 'sleep' [R/W]*/
+	entry = create_proc_entry(ACPI_SYSTEM_FILE_SLEEP,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_SYSTEM_FILE_SLEEP));
+	else {
+		entry->read_proc = acpi_system_read_sleep;
+		entry->write_proc = acpi_system_write_sleep;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'alarm' [R/W] */
+	entry = create_proc_entry(ACPI_SYSTEM_FILE_ALARM,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_SYSTEM_FILE_ALARM));
+	else {
+		entry->read_proc = acpi_system_read_alarm;
+		entry->write_proc = acpi_system_write_alarm;
+		entry->data = acpi_driver_data(device);
+	}
+
+#endif /*CONFIG_ACPI_SLEEP*/
+
+#ifdef ACPI_DEBUG_OUTPUT
+
+	/* 'debug_layer' [R/W] */
+	entry = create_proc_entry(ACPI_SYSTEM_FILE_DEBUG_LAYER,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_SYSTEM_FILE_DEBUG_LAYER));
+	else {
+		entry->read_proc  = acpi_system_read_debug;
+		entry->write_proc = acpi_system_write_debug;
+		entry->data = (void *) 0;
+	}
+
+	/* 'debug_level' [R/W] */
+	entry = create_proc_entry(ACPI_SYSTEM_FILE_DEBUG_LEVEL,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_SYSTEM_FILE_DEBUG_LEVEL));
+	else {
+		entry->read_proc  = acpi_system_read_debug;
+		entry->write_proc = acpi_system_write_debug;
+		entry->data = (void *) 1;
+	}
+
+#endif /*ACPI_DEBUG_OUTPUT */
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_system_remove_fs (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_system_remove_fs");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	remove_proc_entry(ACPI_SYSTEM_FILE_INFO, acpi_device_dir(device));
+	remove_proc_entry(ACPI_SYSTEM_FILE_DSDT, acpi_device_dir(device));
+	remove_proc_entry(ACPI_SYSTEM_FILE_EVENT, acpi_device_dir(device));
+#ifdef CONFIG_ACPI_SLEEP
+	remove_proc_entry(ACPI_SYSTEM_FILE_SLEEP, acpi_device_dir(device));
+	remove_proc_entry(ACPI_SYSTEM_FILE_ALARM, acpi_device_dir(device));
+#endif
+#ifdef ACPI_DEBUG_OUTPUT
+	remove_proc_entry(ACPI_SYSTEM_FILE_DEBUG_LAYER,
+		acpi_device_dir(device));
+	remove_proc_entry(ACPI_SYSTEM_FILE_DEBUG_LEVEL,
+		acpi_device_dir(device));
+#endif
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                 Driver Interface
+   -------------------------------------------------------------------------- */
+
+#if defined(CONFIG_MAGIC_SYSRQ) && defined(CONFIG_PM)
+
+/* Simple wrapper calling power down function. */
+static void acpi_sysrq_power_off(int key, struct pt_regs *pt_regs,
+	struct kbd_struct *kbd, struct tty_struct *tty)
+{
+	acpi_power_off();
+}
+
+struct sysrq_key_op sysrq_acpi_poweroff_op = {
+	.handler =	&acpi_sysrq_power_off,
+	.help_msg =	"Off",
+	.action_msg =	"Power Off\n"
+};
+
+#endif  /* CONFIG_MAGIC_SYSRQ */
+
+static int
+acpi_system_add (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_system	*system = NULL;
+	u8			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_system_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	system = kmalloc(sizeof(struct acpi_system), GFP_KERNEL);
+	if (!system)
+		return_VALUE(-ENOMEM);
+	memset(system, 0, sizeof(struct acpi_system));
+
+	system->handle = device->handle;
+	sprintf(acpi_device_name(device), "%s", ACPI_SYSTEM_DEVICE_NAME);
+	sprintf(acpi_device_class(device), "%s", ACPI_SYSTEM_CLASS);
+	acpi_driver_data(device) = system;
+
+	result = acpi_system_add_fs(device);
+	if (result)
+		goto end;
+
+	printk(KERN_INFO PREFIX "%s [%s] (supports", 
+		acpi_device_name(device), acpi_device_bid(device));
+	for (i=0; i<ACPI_S_STATE_COUNT; i++) {
+		u8 type_a, type_b;
+		status = acpi_get_sleep_type_data(i, &type_a, &type_b);
+		switch (i) {
+		case ACPI_STATE_S4:
+			if (acpi_gbl_FACS->S4bios_f &&
+			    0 != acpi_gbl_FADT->smi_cmd) {
+				printk(" S4bios");
+				system->states[i] = 1;
+			}
+			/* no break */
+		default: 
+			if (ACPI_SUCCESS(status)) {
+				system->states[i] = 1;
+				printk(" S%d", i);
+			}
+		}
+	}
+	printk(")\n");
+
+#ifdef CONFIG_PM
+	/* Install the soft-off (S5) handler. */
+	if (system->states[ACPI_STATE_S5]) {
+		pm_power_off = acpi_power_off;
+		register_sysrq_key('o', &sysrq_acpi_poweroff_op);
+	}
+#endif
+
+end:
+	if (result)
+		kfree(system);
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_system_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	struct acpi_system	*system = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_system_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	system = (struct acpi_system *) acpi_driver_data(device);
+
+#ifdef CONFIG_PM
+	/* Remove the soft-off (S5) handler. */
+	if (system->states[ACPI_STATE_S5]) {
+		unregister_sysrq_key('o', &sysrq_acpi_poweroff_op);
+		pm_power_off = NULL;
+	}
+#endif
+
+	acpi_system_remove_fs(device);
+
+	kfree(system);
+
+	return 0;
+}
+
+
+int __init
+acpi_system_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_system_init");
+
+	result = acpi_bus_register_driver(&acpi_system_driver);
+	if (result < 0)
+		return_VALUE(-ENODEV);
+
+	return_VALUE(0);
+}
+
+
+void __exit
+acpi_system_exit (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_system_exit");
+	acpi_bus_unregister_driver(&acpi_system_driver);
+	return_VOID;
+}
diff -urNp linux-5400/drivers/acpi/tables/Makefile linux-5410/drivers/acpi/tables/Makefile
--- linux-5400/drivers/acpi/tables/Makefile
+++ linux-5410/drivers/acpi/tables/Makefile
@@ -1,11 +1,10 @@
 #
 # Makefile for all Linux ACPI interpreter subdirectories
-# EXCEPT for the ospm directory
 #
 
 O_TARGET := $(notdir $(CURDIR)).o
 
-obj-$(CONFIG_ACPI) := $(patsubst %.c,%.o,$(wildcard *.c))
+obj-$(CONFIG_ACPI_INTERPRETER) := $(patsubst %.c,%.o,$(wildcard *.c))
 
 EXTRA_CFLAGS += $(ACPI_CFLAGS)
 
diff -urNp linux-5400/drivers/acpi/tables/tbconvrt.c linux-5410/drivers/acpi/tables/tbconvrt.c
--- linux-5400/drivers/acpi/tables/tbconvrt.c
+++ linux-5410/drivers/acpi/tables/tbconvrt.c
@@ -1,68 +1,85 @@
 /******************************************************************************
  *
  * Module Name: tbconvrt - ACPI Table conversion utilities
- *              $Revision: 28 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "achware.h"
-#include "actables.h"
-#include "actbl.h"
+#include <acpi/acpi.h>
+#include <acpi/actables.h>
 
 
 #define _COMPONENT          ACPI_TABLES
-	 MODULE_NAME         ("tbconvrt")
+	 ACPI_MODULE_NAME    ("tbconvrt")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_tb_get_table_count
+ * FUNCTION:    acpi_tb_get_table_count
  *
- * PARAMETERS:
+ * PARAMETERS:  RSDP            - Pointer to the RSDP
+ *              RSDT            - Pointer to the RSDT/XSDT
  *
- * RETURN:
+ * RETURN:      The number of tables pointed to by the RSDT or XSDT.
  *
- * DESCRIPTION: Calculate the number of tables
+ * DESCRIPTION: Calculate the number of tables.  Automatically handles either
+ *              an RSDT or XSDT.
  *
  ******************************************************************************/
 
 u32
 acpi_tb_get_table_count (
-	RSDP_DESCRIPTOR         *RSDP,
-	acpi_table_header       *RSDT)
+	struct rsdp_descriptor          *RSDP,
+	struct acpi_table_header        *RSDT)
 {
-	u32                     pointer_size;
+	u32                             pointer_size;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
-#ifndef _IA64
+#if ACPI_MACHINE_WIDTH != 64
 
 	if (RSDP->revision < 2) {
 		pointer_size = sizeof (u32);
 	}
-
 	else
 #endif
 	{
@@ -75,17 +92,17 @@ acpi_tb_get_table_count (
 	 * pointers contained within the RSDT/XSDT.  The size of the pointers
 	 * is architecture-dependent.
 	 */
-	return ((RSDT->length - sizeof (acpi_table_header)) / pointer_size);
+	return ((RSDT->length - sizeof (struct acpi_table_header)) / pointer_size);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_tb_convert_to_xsdt
+ * FUNCTION:    acpi_tb_convert_to_xsdt
  *
- * PARAMETERS:
+ * PARAMETERS:  table_info      - Info about the RSDT
  *
- * RETURN:
+ * RETURN:      Status
  *
  * DESCRIPTION: Convert an RSDT to an XSDT (internal common format)
  *
@@ -93,24 +110,20 @@ acpi_tb_get_table_count (
 
 acpi_status
 acpi_tb_convert_to_xsdt (
-	acpi_table_desc         *table_info,
-	u32                     *number_of_tables)
+	struct acpi_table_desc          *table_info)
 {
-	u32                     table_size;
-	u32                     i;
-	xsdt_descriptor         *new_table;
-
-
-	FUNCTION_ENTRY ();
+	acpi_size                       table_size;
+	u32                             i;
+	XSDT_DESCRIPTOR         *new_table;
 
 
-	*number_of_tables = acpi_tb_get_table_count (acpi_gbl_RSDP, table_info->pointer);
+	ACPI_FUNCTION_ENTRY ();
 
 
 	/* Compute size of the converted XSDT */
 
-	table_size = (*number_of_tables * sizeof (u64)) + sizeof (acpi_table_header);
-
+	table_size = ((acpi_size) acpi_gbl_rsdt_table_count * sizeof (u64)) +
+			  sizeof (struct acpi_table_header);
 
 	/* Allocate an XSDT */
 
@@ -121,37 +134,29 @@ acpi_tb_convert_to_xsdt (
 
 	/* Copy the header and set the length */
 
-	MEMCPY (new_table, table_info->pointer, sizeof (acpi_table_header));
-	new_table->header.length = table_size;
+	ACPI_MEMCPY (new_table, table_info->pointer, sizeof (struct acpi_table_header));
+	new_table->header.length = (u32) table_size;
 
 	/* Copy the table pointers */
 
-	for (i = 0; i < *number_of_tables; i++) {
+	for (i = 0; i < acpi_gbl_rsdt_table_count; i++) {
 		if (acpi_gbl_RSDP->revision < 2) {
-#ifdef _IA64
-			new_table->table_offset_entry[i] =
-				((RSDT_DESCRIPTOR_REV071 *) table_info->pointer)->table_offset_entry[i];
-#else
 			ACPI_STORE_ADDRESS (new_table->table_offset_entry[i],
-				((RSDT_DESCRIPTOR_REV1 *) table_info->pointer)->table_offset_entry[i]);
-#endif
+				((struct rsdt_descriptor_rev1 *) table_info->pointer)->table_offset_entry[i]);
 		}
 		else {
 			new_table->table_offset_entry[i] =
-				((xsdt_descriptor *) table_info->pointer)->table_offset_entry[i];
+				((XSDT_DESCRIPTOR *) table_info->pointer)->table_offset_entry[i];
 		}
 	}
 
-
 	/* Delete the original table (either mapped or in a buffer) */
 
 	acpi_tb_delete_single_table (table_info);
 
-
 	/* Point the table descriptor to the new table */
 
-	table_info->pointer     = (acpi_table_header *) new_table;
-	table_info->base_pointer = (acpi_table_header *) new_table;
+	table_info->pointer     = (struct acpi_table_header *) new_table;
 	table_info->length      = table_size;
 	table_info->allocation  = ACPI_MEM_ALLOCATED;
 
@@ -159,327 +164,342 @@ acpi_tb_convert_to_xsdt (
 }
 
 
-/*******************************************************************************
+/******************************************************************************
  *
- * FUNCTION:    Acpi_tb_convert_table_fadt
+ * FUNCTION:    acpi_tb_init_generic_address
  *
- * PARAMETERS:
+ * PARAMETERS:  new_gas_struct      - GAS struct to be initialized
+ *              register_bit_width  - Width of this register
+ *              Address             - Address of the register
  *
- * RETURN:
+ * RETURN:      None
  *
- * DESCRIPTION:
- *    Converts BIOS supplied 1.0 and 0.71 ACPI FADT to an intermediate
- *    ACPI 2.0 FADT. If the BIOS supplied a 2.0 FADT then it is simply
- *    copied to the intermediate FADT.  The ACPI CA software uses this
- *    intermediate FADT. Thus a significant amount of special #ifdef
- *    type codeing is saved. This intermediate FADT will need to be
- *    freed at some point.
+ * DESCRIPTION: Initialize a GAS structure.
  *
  ******************************************************************************/
 
-acpi_status
-acpi_tb_convert_table_fadt (void)
+static void
+acpi_tb_init_generic_address (
+	struct acpi_generic_address     *new_gas_struct,
+	u8                              register_bit_width,
+	acpi_physical_address           address)
 {
 
-#ifdef _IA64
-	fadt_descriptor_rev071 *FADT71;
-	u8                      pm1_address_space;
-	u8                      pm2_address_space;
-	u8                      pm_timer_address_space;
-	u8                      gpe0address_space;
-	u8                      gpe1_address_space;
-#else
-	fadt_descriptor_rev1   *FADT1;
-#endif
+	ACPI_STORE_ADDRESS (new_gas_struct->address, address);
 
-	fadt_descriptor_rev2   *FADT2;
-	acpi_table_desc        *table_desc;
+	new_gas_struct->address_space_id = ACPI_ADR_SPACE_SYSTEM_IO;
+	new_gas_struct->register_bit_width = register_bit_width;
+	new_gas_struct->register_bit_offset = 0;
+	new_gas_struct->reserved        = 0;
+}
 
 
-	FUNCTION_TRACE ("Tb_convert_table_fadt");
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_convert_fadt1
+ *
+ * PARAMETERS:  local_fadt      - Pointer to new FADT
+ *              original_fadt   - Pointer to old FADT
+ *
+ * RETURN:      Populates local_fadt
+ *
+ * DESCRIPTION: Convert an ACPI 1.0 FADT to common internal format
+ *
+ ******************************************************************************/
+
+static void
+acpi_tb_convert_fadt1 (
+	struct fadt_descriptor_rev2    *local_fadt,
+	struct fadt_descriptor_rev1    *original_fadt)
+{
 
 
-	/* Acpi_gbl_FADT is valid */
-	/* Allocate and zero the 2.0 buffer */
+	/* ACPI 1.0 FACS */
+	/* The BIOS stored FADT should agree with Revision 1.0 */
 
-	FADT2 = ACPI_MEM_CALLOCATE (sizeof (fadt_descriptor_rev2));
-	if (FADT2 == NULL) {
-		return_ACPI_STATUS (AE_NO_MEMORY);
-	}
+	/*
+	 * Copy the table header and the common part of the tables.
+	 *
+	 * The 2.0 table is an extension of the 1.0 table, so the entire 1.0
+	 * table can be copied first, then expand some fields to 64 bits.
+	 */
+	ACPI_MEMCPY (local_fadt, original_fadt, sizeof (struct fadt_descriptor_rev1));
 
+	/* Convert table pointers to 64-bit fields */
 
-	/* The ACPI FADT revision number is FADT2_REVISION_ID=3 */
-	/* So, if the current table revision is less than 3 it is type 1.0 or 0.71 */
+	ACPI_STORE_ADDRESS (local_fadt->xfirmware_ctrl, local_fadt->V1_firmware_ctrl);
+	ACPI_STORE_ADDRESS (local_fadt->Xdsdt, local_fadt->V1_dsdt);
 
-	if (acpi_gbl_FADT->header.revision >= FADT2_REVISION_ID) {
-		/* We have an ACPI 2.0 FADT but we must copy it to our local buffer */
+	/*
+	 * System Interrupt Model isn't used in ACPI 2.0 (local_fadt->Reserved1 = 0;)
+	 */
 
-		*FADT2 = *((fadt_descriptor_rev2*) acpi_gbl_FADT);
+	/*
+	 * This field is set by the OEM to convey the preferred power management
+	 * profile to OSPM. It doesn't have any 1.0 equivalence.  Since we don't
+	 * know what kind of 32-bit system this is, we will use "unspecified".
+	 */
+	local_fadt->prefer_PM_profile = PM_UNSPECIFIED;
 
-	}
+	/*
+	 * Processor Performance State Control. This is the value OSPM writes to
+	 * the SMI_CMD register to assume processor performance state control
+	 * responsibility. There isn't any equivalence in 1.0, leave it zeroed.
+	 */
+	local_fadt->pstate_cnt = 0;
 
-	else {
+	/*
+	 * Support for the _CST object and C States change notification.
+	 * This data item hasn't any 1.0 equivalence so leave it zero.
+	 */
+	local_fadt->cst_cnt = 0;
 
-#ifdef _IA64
+	/*
+	 * ACPI system reset mechanism was introduced between Spec revisions 
+	 * 1.0b and 2.0. An interim FADT was introduced that expanded the 
+	 * rev1 FADT to include the reset register fields and flags. This was
+	 * the _only_ change to the structure.Rather than introducing a new 
+	 * data structure for this, just overload the rev2 FADT. The reset
+	 * mechanism is required on legacy free systems.
+	 */
+	if (original_fadt->header.revision == FADT2_INTERIM_REVISION_ID &&
+	    original_fadt->header.length == FADT2_INTERIM_LENGTH) {
 		/*
-		 * For the 64-bit case only, a revision ID less than V2.0 means the
-		 * tables are the 0.71 extensions
+		 * Copy the entire GAS, plus the 1-byte reset value that
+		 * immediately follows.
 		 */
-
-		/* The BIOS stored FADT should agree with Revision 0.71 */
-
-		FADT71 = (fadt_descriptor_rev071 *) acpi_gbl_FADT;
-
-		/* Copy the table header*/
-
-		FADT2->header       = FADT71->header;
-
-		/* Copy the common fields */
-
-		FADT2->sci_int      = FADT71->sci_int;
-		FADT2->acpi_enable  = FADT71->acpi_enable;
-		FADT2->acpi_disable = FADT71->acpi_disable;
-		FADT2->S4bios_req   = FADT71->S4bios_req;
-		FADT2->plvl2_lat    = FADT71->plvl2_lat;
-		FADT2->plvl3_lat    = FADT71->plvl3_lat;
-		FADT2->day_alrm     = FADT71->day_alrm;
-		FADT2->mon_alrm     = FADT71->mon_alrm;
-		FADT2->century      = FADT71->century;
-		FADT2->gpe1_base    = FADT71->gpe1_base;
-
+		ACPI_MEMCPY (&local_fadt->reset_register, &((FADT_DESCRIPTOR *)original_fadt)->reset_register, sizeof(struct acpi_generic_address) + 1);
+	} else {
 		/*
-		 * We still use the block length registers even though
-		 * the GAS structure should obsolete them.  This is because
-		 * these registers are byte lengths versus the GAS which
-		 * contains a bit width
+		 * Otherwise, there isn't any equivalence in 1.0 and it's
+		 * highly likely that a 1.0 system has legacy support.
 		 */
-		FADT2->pm1_evt_len  = FADT71->pm1_evt_len;
-		FADT2->pm1_cnt_len  = FADT71->pm1_cnt_len;
-		FADT2->pm2_cnt_len  = FADT71->pm2_cnt_len;
-		FADT2->pm_tm_len    = FADT71->pm_tm_len;
-		FADT2->gpe0blk_len  = FADT71->gpe0blk_len;
-		FADT2->gpe1_blk_len = FADT71->gpe1_blk_len;
-		FADT2->gpe1_base    = FADT71->gpe1_base;
-
-		/* Copy the existing 0.71 flags to 2.0. The other bits are zero.*/
-
-		FADT2->wb_invd      = FADT71->flush_cash;
-		FADT2->proc_c1      = FADT71->proc_c1;
-		FADT2->plvl2_up     = FADT71->plvl2_up;
-		FADT2->pwr_button   = FADT71->pwr_button;
-		FADT2->sleep_button = FADT71->sleep_button;
-		FADT2->fixed_rTC    = FADT71->fixed_rTC;
-		FADT2->rtcs4        = FADT71->rtcs4;
-		FADT2->tmr_val_ext  = FADT71->tmr_val_ext;
-		FADT2->dock_cap     = FADT71->dock_cap;
-
-
-		/* We should not use these next two addresses */
-		/* Since our buffer is pre-zeroed nothing to do for */
-		/* the next three data items in the structure */
-		/* FADT2->Firmware_ctrl = 0; */
-		/* FADT2->Dsdt = 0; */
-
-		/* System Interrupt Model isn't used in ACPI 2.0*/
-		/* FADT2->Reserved1 = 0; */
-
-		/* This field is set by the OEM to convey the preferred */
-		/* power management profile to OSPM. It doesn't have any*/
-		/* 0.71 equivalence.  Since we don't know what kind of  */
-		/* 64-bit system this is, we will pick unspecified.     */
-
-		FADT2->prefer_PM_profile = PM_UNSPECIFIED;
-
-
-		/* Port address of SMI command port */
-		/* We shouldn't use this port because IA64 doesn't */
-		/* have or use SMI.  It has PMI. */
-
-		FADT2->smi_cmd      = (u32)(FADT71->smi_cmd & 0xFFFFFFFF);
-
-
-		/* processor performance state control*/
-		/* The value OSPM writes to the SMI_CMD register to assume */
-		/* processor performance state control responsibility. */
-		/* There isn't any equivalence in 0.71 */
-		/* Again this should be meaningless for IA64 */
-		/* FADT2->Pstate_cnt = 0; */
-
-		/* The 32-bit Power management and GPE registers are */
-		/* not valid in IA-64 and we are not going to use them */
-		/* so leaving them pre-zeroed. */
-
-		/* Support for the _CST object and C States change notification.*/
-		/* This data item hasn't any 0.71 equivalence so leaving it zero.*/
-		/* FADT2->Cst_cnt = 0; */
-
-		/* number of flush strides that need to be read */
-		/* No 0.71 equivalence. Leave pre-zeroed. */
-		/* FADT2->Flush_size = 0; */
-
-		/* Processor's memory cache line width, in bytes */
-		/* No 0.71 equivalence. Leave pre-zeroed. */
-		/* FADT2->Flush_stride = 0; */
-
-		/* Processor's duty cycle index in processor's P_CNT reg*/
-		/* No 0.71 equivalence. Leave pre-zeroed. */
-		/* FADT2->Duty_offset = 0; */
-
-		/* Processor's duty cycle value bit width in P_CNT register.*/
-		/* No 0.71 equivalence. Leave pre-zeroed. */
-		/* FADT2->Duty_width = 0; */
-
-
-		/* Since there isn't any equivalence in 0.71 */
-		/* and since Big_sur had to support legacy */
-
-		FADT2->iapc_boot_arch = BAF_LEGACY_DEVICES;
-
-		/* Copy to ACPI 2.0 64-BIT Extended Addresses */
+		local_fadt->iapc_boot_arch = BAF_LEGACY_DEVICES;
+	}
 
-		FADT2->Xfirmware_ctrl = FADT71->firmware_ctrl;
-		FADT2->Xdsdt         = FADT71->dsdt;
+	/*
+	 * Convert the V1.0 block addresses to V2.0 GAS structures
+	 */
+	acpi_tb_init_generic_address (&local_fadt->xpm1a_evt_blk, local_fadt->pm1_evt_len,
+			  (acpi_physical_address)   local_fadt->V1_pm1a_evt_blk);
+	acpi_tb_init_generic_address (&local_fadt->xpm1b_evt_blk, local_fadt->pm1_evt_len,
+			  (acpi_physical_address)   local_fadt->V1_pm1b_evt_blk);
+	acpi_tb_init_generic_address (&local_fadt->xpm1a_cnt_blk, local_fadt->pm1_cnt_len,
+			  (acpi_physical_address)   local_fadt->V1_pm1a_cnt_blk);
+	acpi_tb_init_generic_address (&local_fadt->xpm1b_cnt_blk, local_fadt->pm1_cnt_len,
+			  (acpi_physical_address)   local_fadt->V1_pm1b_cnt_blk);
+	acpi_tb_init_generic_address (&local_fadt->xpm2_cnt_blk, local_fadt->pm2_cnt_len,
+			  (acpi_physical_address)   local_fadt->V1_pm2_cnt_blk);
+	acpi_tb_init_generic_address (&local_fadt->xpm_tmr_blk, local_fadt->pm_tm_len,
+			  (acpi_physical_address)   local_fadt->V1_pm_tmr_blk);
+	acpi_tb_init_generic_address (&local_fadt->xgpe0_blk, 0,
+			  (acpi_physical_address)   local_fadt->V1_gpe0_blk);
+	acpi_tb_init_generic_address (&local_fadt->xgpe1_blk, 0,
+			  (acpi_physical_address)   local_fadt->V1_gpe1_blk);
+
+	/* Create separate GAS structs for the PM1 Enable registers */
+
+	acpi_tb_init_generic_address (&acpi_gbl_xpm1a_enable,
+		 (u8) ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len),
+		 (acpi_physical_address) (local_fadt->xpm1a_evt_blk.address +
+			ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len)));
+
+	/* PM1B is optional; leave null if not present */
+
+	if (local_fadt->xpm1b_evt_blk.address) {
+		acpi_tb_init_generic_address (&acpi_gbl_xpm1b_enable,
+			 (u8) ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len),
+			 (acpi_physical_address) (local_fadt->xpm1b_evt_blk.address +
+				ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len)));
+	}
+}
 
 
-		/* Extract the address space IDs */
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_convert_fadt2
+ *
+ * PARAMETERS:  local_fadt      - Pointer to new FADT
+ *              original_fadt   - Pointer to old FADT
+ *
+ * RETURN:      Populates local_fadt
+ *
+ * DESCRIPTION: Convert an ACPI 2.0 FADT to common internal format.
+ *              Handles optional "X" fields.
+ *
+ ******************************************************************************/
 
-		pm1_address_space   = (u8)((FADT71->address_space & PM1_BLK_ADDRESS_SPACE)    >> 1);
-		pm2_address_space   = (u8)((FADT71->address_space & PM2_CNT_BLK_ADDRESS_SPACE) >> 2);
-		pm_timer_address_space = (u8)((FADT71->address_space & PM_TMR_BLK_ADDRESS_SPACE) >> 3);
-		gpe0address_space   = (u8)((FADT71->address_space & GPE0_BLK_ADDRESS_SPACE)   >> 4);
-		gpe1_address_space  = (u8)((FADT71->address_space & GPE1_BLK_ADDRESS_SPACE)   >> 5);
+static void
+acpi_tb_convert_fadt2 (
+	struct fadt_descriptor_rev2    *local_fadt,
+	struct fadt_descriptor_rev2    *original_fadt)
+{
 
-		/*
-		 * Convert the 0.71 (non-GAS style) Block addresses to V2.0 GAS structures,
-		 * in this order:
-		 *
-		 * PM 1_a Events
-		 * PM 1_b Events
-		 * PM 1_a Control
-		 * PM 1_b Control
-		 * PM 2 Control
-		 * PM Timer Control
-		 * GPE Block 0
-		 * GPE Block 1
-		 */
+	/* We have an ACPI 2.0 FADT but we must copy it to our local buffer */
 
-		ASL_BUILD_GAS_FROM_ENTRY (FADT2->Xpm1a_evt_blk, FADT71->pm1_evt_len, FADT71->pm1a_evt_blk, pm1_address_space);
-		ASL_BUILD_GAS_FROM_ENTRY (FADT2->Xpm1b_evt_blk, FADT71->pm1_evt_len, FADT71->pm1b_evt_blk, pm1_address_space);
-		ASL_BUILD_GAS_FROM_ENTRY (FADT2->Xpm1a_cnt_blk, FADT71->pm1_cnt_len, FADT71->pm1a_cnt_blk, pm1_address_space);
-		ASL_BUILD_GAS_FROM_ENTRY (FADT2->Xpm1b_cnt_blk, FADT71->pm1_cnt_len, FADT71->pm1b_cnt_blk, pm1_address_space);
-		ASL_BUILD_GAS_FROM_ENTRY (FADT2->Xpm2_cnt_blk, FADT71->pm2_cnt_len, FADT71->pm2_cnt_blk, pm2_address_space);
-		ASL_BUILD_GAS_FROM_ENTRY (FADT2->Xpm_tmr_blk, FADT71->pm_tm_len,  FADT71->pm_tmr_blk, pm_timer_address_space);
-		ASL_BUILD_GAS_FROM_ENTRY (FADT2->Xgpe0blk,    FADT71->gpe0blk_len, FADT71->gpe0blk,   gpe0address_space);
-		ASL_BUILD_GAS_FROM_ENTRY (FADT2->Xgpe1_blk,   FADT71->gpe1_blk_len, FADT71->gpe1_blk, gpe1_address_space);
+	ACPI_MEMCPY (local_fadt, original_fadt, sizeof (struct fadt_descriptor_rev2));
 
-#else
+	/*
+	 * "X" fields are optional extensions to the original V1.0 fields, so
+	 * we must selectively expand V1.0 fields if the corresponding X field
+	 * is zero.
+	 */
+	if (!(local_fadt->xfirmware_ctrl)) {
+		ACPI_STORE_ADDRESS (local_fadt->xfirmware_ctrl, local_fadt->V1_firmware_ctrl);
+	}
 
-		/* ACPI 1.0 FACS */
+	if (!(local_fadt->Xdsdt)) {
+		ACPI_STORE_ADDRESS (local_fadt->Xdsdt, local_fadt->V1_dsdt);
+	}
 
+	if (!(local_fadt->xpm1a_evt_blk.address)) {
+		acpi_tb_init_generic_address (&local_fadt->xpm1a_evt_blk,
+			local_fadt->pm1_evt_len, (acpi_physical_address) local_fadt->V1_pm1a_evt_blk);
+	}
 
-		/* The BIOS stored FADT should agree with Revision 1.0 */
+	if (!(local_fadt->xpm1b_evt_blk.address)) {
+		acpi_tb_init_generic_address (&local_fadt->xpm1b_evt_blk,
+			local_fadt->pm1_evt_len, (acpi_physical_address) local_fadt->V1_pm1b_evt_blk);
+	}
 
-		FADT1 = (fadt_descriptor_rev1*) acpi_gbl_FADT;
+	if (!(local_fadt->xpm1a_cnt_blk.address)) {
+		acpi_tb_init_generic_address (&local_fadt->xpm1a_cnt_blk,
+			local_fadt->pm1_cnt_len, (acpi_physical_address) local_fadt->V1_pm1a_cnt_blk);
+	}
 
-		/*
-		 * Copy the table header and the common part of the tables
-		 * The 2.0 table is an extension of the 1.0 table, so the
-		 * entire 1.0 table can be copied first, then expand some
-		 * fields to 64 bits.
-		 */
-		MEMCPY (FADT2, FADT1, sizeof (fadt_descriptor_rev1));
+	if (!(local_fadt->xpm1b_cnt_blk.address)) {
+		acpi_tb_init_generic_address (&local_fadt->xpm1b_cnt_blk,
+			local_fadt->pm1_cnt_len, (acpi_physical_address) local_fadt->V1_pm1b_cnt_blk);
+	}
 
+	if (!(local_fadt->xpm2_cnt_blk.address)) {
+		acpi_tb_init_generic_address (&local_fadt->xpm2_cnt_blk,
+			local_fadt->pm2_cnt_len, (acpi_physical_address) local_fadt->V1_pm2_cnt_blk);
+	}
 
-		/* Convert table pointers to 64-bit fields */
+	if (!(local_fadt->xpm_tmr_blk.address)) {
+		acpi_tb_init_generic_address (&local_fadt->xpm_tmr_blk,
+			local_fadt->pm_tm_len, (acpi_physical_address) local_fadt->V1_pm_tmr_blk);
+	}
 
-		ACPI_STORE_ADDRESS (FADT2->Xfirmware_ctrl, FADT1->firmware_ctrl);
-		ACPI_STORE_ADDRESS (FADT2->Xdsdt, FADT1->dsdt);
+	if (!(local_fadt->xgpe0_blk.address)) {
+		acpi_tb_init_generic_address (&local_fadt->xgpe0_blk,
+			0, (acpi_physical_address) local_fadt->V1_gpe0_blk);
+	}
 
-		/* System Interrupt Model isn't used in ACPI 2.0*/
-		/* FADT2->Reserved1 = 0; */
+	if (!(local_fadt->xgpe1_blk.address)) {
+		acpi_tb_init_generic_address (&local_fadt->xgpe1_blk,
+			0, (acpi_physical_address) local_fadt->V1_gpe1_blk);
+	}
 
-		/* This field is set by the OEM to convey the preferred */
-		/* power management profile to OSPM. It doesn't have any*/
-		/* 1.0 equivalence.  Since we don't know what kind of   */
-		/* 32-bit system this is, we will pick unspecified.     */
+	/* Create separate GAS structs for the PM1 Enable registers */
 
-		FADT2->prefer_PM_profile = PM_UNSPECIFIED;
+	acpi_tb_init_generic_address (&acpi_gbl_xpm1a_enable,
+		(u8) ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len),
+		(acpi_physical_address) (local_fadt->xpm1a_evt_blk.address +
+			ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len)));
+	acpi_gbl_xpm1a_enable.address_space_id = local_fadt->xpm1a_evt_blk.address_space_id;
+
+	/* PM1B is optional; leave null if not present */
+
+	if (local_fadt->xpm1b_evt_blk.address) {
+		acpi_tb_init_generic_address (&acpi_gbl_xpm1b_enable,
+			(u8) ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len),
+			(acpi_physical_address) (local_fadt->xpm1b_evt_blk.address +
+				ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len)));
+		acpi_gbl_xpm1b_enable.address_space_id = local_fadt->xpm1b_evt_blk.address_space_id;
+	}
+}
 
 
-		/* Processor Performance State Control. This is the value  */
-		/* OSPM writes to the SMI_CMD register to assume processor */
-		/* performance state control responsibility. There isn't   */
-		/* any equivalence in 1.0.  So leave it zeroed.            */
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_convert_table_fadt
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Converts a BIOS supplied ACPI 1.0 FADT to a local
+ *              ACPI 2.0 FADT. If the BIOS supplied a 2.0 FADT then it is simply
+ *              copied to the local FADT.  The ACPI CA software uses this
+ *              local FADT. Thus a significant amount of special #ifdef
+ *              type codeing is saved.
+ *
+ ******************************************************************************/
 
-		FADT2->pstate_cnt = 0;
+acpi_status
+acpi_tb_convert_table_fadt (void)
+{
+	struct fadt_descriptor_rev2    *local_fadt;
+	struct acpi_table_desc         *table_desc;
 
 
-		/* Support for the _CST object and C States change notification.*/
-		/* This data item hasn't any 1.0 equivalence so leaving it zero.*/
+	ACPI_FUNCTION_TRACE ("tb_convert_table_fadt");
 
-		FADT2->cst_cnt = 0;
 
+	/*
+	 * acpi_gbl_FADT is valid
+	 * Allocate and zero the 2.0 FADT buffer
+	 */
+	local_fadt = ACPI_MEM_CALLOCATE (sizeof (struct fadt_descriptor_rev2));
+	if (local_fadt == NULL) {
+		return_ACPI_STATUS (AE_NO_MEMORY);
+	}
 
-		/* Since there isn't any equivalence in 1.0 and since it   */
-		/* is highly likely that a 1.0 system has legacy  support. */
+	/*
+	 * FADT length and version validation.  The table must be at least as
+	 * long as the version 1.0 FADT
+	 */
+	if (acpi_gbl_FADT->header.length < sizeof (struct fadt_descriptor_rev1)) {
+		ACPI_REPORT_ERROR (("Invalid FADT table length: 0x%X\n", acpi_gbl_FADT->header.length));
+		return_ACPI_STATUS (AE_INVALID_TABLE_LENGTH);
+	}
 
-		FADT2->iapc_boot_arch = BAF_LEGACY_DEVICES;
+	if (acpi_gbl_FADT->header.revision >= FADT2_REVISION_ID) {
+		if (acpi_gbl_FADT->header.length < sizeof (struct fadt_descriptor_rev2)) {
+			/* Length is too short to be a V2.0 table */
 
+			ACPI_REPORT_WARNING (("Inconsistent FADT length (0x%X) and revision (0x%X), using FADT V1.0 portion of table\n",
+					 acpi_gbl_FADT->header.length, acpi_gbl_FADT->header.revision));
 
-		/*
-		 * Convert the V1.0 Block addresses to V2.0 GAS structures
-		 * in this order:
-		 *
-		 * PM 1_a Events
-		 * PM 1_b Events
-		 * PM 1_a Control
-		 * PM 1_b Control
-		 * PM 2 Control
-		 * PM Timer Control
-		 * GPE Block 0
-		 * GPE Block 1
-		 */
+			acpi_tb_convert_fadt1 (local_fadt, (void *) acpi_gbl_FADT);
+		}
+		else {
+			/* Valid V2.0 table */
 
-		ASL_BUILD_GAS_FROM_V1_ENTRY (FADT2->Xpm1a_evt_blk, FADT1->pm1_evt_len, FADT1->pm1a_evt_blk);
-		ASL_BUILD_GAS_FROM_V1_ENTRY (FADT2->Xpm1b_evt_blk, FADT1->pm1_evt_len, FADT1->pm1b_evt_blk);
-		ASL_BUILD_GAS_FROM_V1_ENTRY (FADT2->Xpm1a_cnt_blk, FADT1->pm1_cnt_len, FADT1->pm1a_cnt_blk);
-		ASL_BUILD_GAS_FROM_V1_ENTRY (FADT2->Xpm1b_cnt_blk, FADT1->pm1_cnt_len, FADT1->pm1b_cnt_blk);
-		ASL_BUILD_GAS_FROM_V1_ENTRY (FADT2->Xpm2_cnt_blk, FADT1->pm2_cnt_len, FADT1->pm2_cnt_blk);
-		ASL_BUILD_GAS_FROM_V1_ENTRY (FADT2->Xpm_tmr_blk, FADT1->pm_tm_len,  FADT1->pm_tmr_blk);
-		ASL_BUILD_GAS_FROM_V1_ENTRY (FADT2->Xgpe0blk,    FADT1->gpe0blk_len, FADT1->gpe0blk);
-		ASL_BUILD_GAS_FROM_V1_ENTRY (FADT2->Xgpe1_blk,   FADT1->gpe1_blk_len, FADT1->gpe1_blk);
-#endif
+			acpi_tb_convert_fadt2 (local_fadt, acpi_gbl_FADT);
+		}
 	}
+	else {
+		/* Valid V1.0 table */
 
+		acpi_tb_convert_fadt1 (local_fadt, (void *) acpi_gbl_FADT);
+	}
 
 	/*
-	 * Global FADT pointer will point to the common V2.0 FADT
+	 * Global FADT pointer will point to the new common V2.0 FADT
 	 */
-	acpi_gbl_FADT = FADT2;
+	acpi_gbl_FADT = local_fadt;
 	acpi_gbl_FADT->header.length = sizeof (FADT_DESCRIPTOR);
 
-
 	/* Free the original table */
 
-	table_desc = &acpi_gbl_acpi_tables[ACPI_TABLE_FADT];
+	table_desc = acpi_gbl_table_lists[ACPI_TABLE_FADT].next;
 	acpi_tb_delete_single_table (table_desc);
 
-
 	/* Install the new table */
 
-	table_desc->pointer = (acpi_table_header *) acpi_gbl_FADT;
-	table_desc->base_pointer = acpi_gbl_FADT;
-	table_desc->allocation = ACPI_MEM_ALLOCATED;
-	table_desc->length = sizeof (fadt_descriptor_rev2);
-
+	table_desc->pointer     = (struct acpi_table_header *) acpi_gbl_FADT;
+	table_desc->allocation  = ACPI_MEM_ALLOCATED;
+	table_desc->length      = sizeof (struct fadt_descriptor_rev2);
 
 	/* Dump the entire FADT */
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_TABLES,
 		"Hex dump of common internal FADT, size %d (%X)\n",
 		acpi_gbl_FADT->header.length, acpi_gbl_FADT->header.length));
-	DUMP_BUFFER ((u8 *) (acpi_gbl_FADT), acpi_gbl_FADT->header.length);
-
+	ACPI_DUMP_BUFFER ((u8 *) (acpi_gbl_FADT), acpi_gbl_FADT->header.length);
 
 	return_ACPI_STATUS (AE_OK);
 }
@@ -487,82 +507,57 @@ acpi_tb_convert_table_fadt (void)
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_tb_convert_table_facs
+ * FUNCTION:    acpi_tb_convert_table_facs
  *
- * PARAMETERS:
+ * PARAMETERS:  table_info      - Info for currently installad FACS
  *
- * RETURN:
+ * RETURN:      Status
  *
- * DESCRIPTION:
+ * DESCRIPTION: Convert ACPI 1.0 and ACPI 2.0 FACS to a common internal
+ *              table format.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_tb_build_common_facs (
-	acpi_table_desc         *table_info)
+	struct acpi_table_desc          *table_info)
 {
-	acpi_common_facs        *common_facs;
-
-#ifdef _IA64
-	facs_descriptor_rev071  *FACS71;
-#else
-	facs_descriptor_rev1    *FACS1;
-#endif
 
-	facs_descriptor_rev2    *FACS2;
+	ACPI_FUNCTION_TRACE ("tb_build_common_facs");
 
 
-	FUNCTION_TRACE ("Tb_build_common_facs");
+	/* Absolute minimum length is 24, but the ACPI spec says 64 */
 
-
-	/* Allocate a common FACS */
-
-	common_facs = ACPI_MEM_CALLOCATE (sizeof (acpi_common_facs));
-	if (!common_facs) {
-		return_ACPI_STATUS (AE_NO_MEMORY);
+	if (acpi_gbl_FACS->length < 24) {
+		ACPI_REPORT_ERROR (("Invalid FACS table length: 0x%X\n", acpi_gbl_FACS->length));
+		return_ACPI_STATUS (AE_INVALID_TABLE_LENGTH);
 	}
 
+	if (acpi_gbl_FACS->length < 64) {
+		ACPI_REPORT_WARNING (("FACS is shorter than the ACPI specification allows: 0x%X, using anyway\n",
+			acpi_gbl_FACS->length));
+	}
 
 	/* Copy fields to the new FACS */
 
-	if (acpi_gbl_RSDP->revision < 2) {
-#ifdef _IA64
-		/* 0.71 FACS */
-
-		FACS71 = (facs_descriptor_rev071 *) acpi_gbl_FACS;
-
-		common_facs->global_lock = (u32 *) &(FACS71->global_lock);
-		common_facs->firmware_waking_vector = &FACS71->firmware_waking_vector;
-		common_facs->vector_width = 64;
-#else
-		/* ACPI 1.0 FACS */
-
-		FACS1 = (facs_descriptor_rev1 *) acpi_gbl_FACS;
-
-		common_facs->global_lock = &(FACS1->global_lock);
-		common_facs->firmware_waking_vector = (u64 *) &FACS1->firmware_waking_vector;
-		common_facs->vector_width = 32;
+	acpi_gbl_common_fACS.global_lock = &(acpi_gbl_FACS->global_lock);
 
-#endif
-	}
+	if ((acpi_gbl_RSDP->revision < 2) ||
+		(acpi_gbl_FACS->length < 32) ||
+		(!(acpi_gbl_FACS->xfirmware_waking_vector))) {
+		/* ACPI 1.0 FACS or short table or optional X_ field is zero */
 
+		acpi_gbl_common_fACS.firmware_waking_vector = ACPI_CAST_PTR (u64, &(acpi_gbl_FACS->firmware_waking_vector));
+		acpi_gbl_common_fACS.vector_width = 32;
+	}
 	else {
-		/* ACPI 2.0 FACS */
+		/* ACPI 2.0 FACS with valid X_ field */
 
-		FACS2 = (facs_descriptor_rev2 *) acpi_gbl_FACS;
-
-		common_facs->global_lock = &(FACS2->global_lock);
-		common_facs->firmware_waking_vector = &FACS2->Xfirmware_waking_vector;
-		common_facs->vector_width = 64;
+		acpi_gbl_common_fACS.firmware_waking_vector = &acpi_gbl_FACS->xfirmware_waking_vector;
+		acpi_gbl_common_fACS.vector_width = 64;
 	}
 
-
-	/* Set the global FACS pointer to point to the common FACS */
-
-
-	acpi_gbl_FACS = common_facs;
-
-	return_ACPI_STATUS  (AE_OK);
+	return_ACPI_STATUS (AE_OK);
 }
 
 
diff -urNp linux-5400/drivers/acpi/tables/tbget.c linux-5410/drivers/acpi/tables/tbget.c
--- linux-5400/drivers/acpi/tables/tbget.c
+++ linux-5410/drivers/acpi/tables/tbget.c
@@ -1,754 +1,492 @@
 /******************************************************************************
  *
  * Module Name: tbget - ACPI Table get* routines
- *              $Revision: 56 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "achware.h"
-#include "actables.h"
+#include <acpi/acpi.h>
+#include <acpi/actables.h>
 
 
 #define _COMPONENT          ACPI_TABLES
-	 MODULE_NAME         ("tbget")
-
-#define RSDP_CHECKSUM_LENGTH 20
+	 ACPI_MODULE_NAME    ("tbget")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_tb_get_table_ptr
+ * FUNCTION:    acpi_tb_get_table
  *
- * PARAMETERS:  Table_type      - one of the defined table types
- *              Instance        - Which table of this type
- *              Table_ptr_loc   - pointer to location to place the pointer for
- *                                return
+ * PARAMETERS:  Address             - Address of table to retrieve.  Can be
+ *                                    Logical or Physical
+ *              table_info          - Where table info is returned
  *
- * RETURN:      Status
+ * RETURN:      None
  *
- * DESCRIPTION: This function is called to get the pointer to an ACPI table.
+ * DESCRIPTION: Get entire table of unknown size.
  *
  ******************************************************************************/
 
 acpi_status
-acpi_tb_get_table_ptr (
-	acpi_table_type         table_type,
-	u32                     instance,
-	acpi_table_header       **table_ptr_loc)
+acpi_tb_get_table (
+	struct acpi_pointer             *address,
+	struct acpi_table_desc          *table_info)
 {
-	acpi_table_desc         *table_desc;
-	u32                     i;
-
-
-	FUNCTION_TRACE ("Tb_get_table_ptr");
-
+	acpi_status                     status;
+	struct acpi_table_header        header;
 
-	if (!acpi_gbl_DSDT) {
-		return_ACPI_STATUS (AE_NO_ACPI_TABLES);
-	}
 
-	if (table_type > ACPI_TABLE_MAX) {
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
-	}
+	ACPI_FUNCTION_TRACE ("tb_get_table");
 
 
 	/*
-	 * For all table types (Single/Multiple), the first
-	 * instance is always in the list head.
+	 * Get the header in order to get signature and table size
 	 */
-	if (instance == 1) {
-		/*
-		 * Just pluck the pointer out of the global table!
-		 * Will be null if no table is present
-		 */
-		*table_ptr_loc = acpi_gbl_acpi_tables[table_type].pointer;
-		return_ACPI_STATUS (AE_OK);
+	status = acpi_tb_get_table_header (address, &header);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
 	}
 
+	/* Get the entire table */
 
-	/*
-	 * Check for instance out of range
-	 */
-	if (instance > acpi_gbl_acpi_tables[table_type].count) {
-		return_ACPI_STATUS (AE_NOT_EXIST);
-	}
-
-	/* Walk the list to get the desired table
-	 * Since the if (Instance == 1) check above checked for the
-	 * first table, setting Table_desc equal to the .Next member
-	 * is actually pointing to the second table.  Therefore, we
-	 * need to walk from the 2nd table until we reach the Instance
-	 * that the user is looking for and return its table pointer.
-	 */
-	table_desc = acpi_gbl_acpi_tables[table_type].next;
-	for (i = 2; i < instance; i++) {
-		table_desc = table_desc->next;
+	status = acpi_tb_get_table_body (address, &header, table_info);
+	if (ACPI_FAILURE (status)) {
+		ACPI_REPORT_ERROR (("Could not get ACPI table (size %X), %s\n",
+			header.length, acpi_format_exception (status)));
+		return_ACPI_STATUS (status);
 	}
 
-	/* We are now pointing to the requested table's descriptor */
-
-	*table_ptr_loc = table_desc->pointer;
-
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_tb_get_table
+ * FUNCTION:    acpi_tb_get_table_header
  *
- * PARAMETERS:  Physical_address        - Physical address of table to retrieve
- *              *Buffer_ptr             - If Buffer_ptr is valid, read data from
- *                                         buffer rather than searching memory
- *              *Table_info             - Where the table info is returned
+ * PARAMETERS:  Address             - Address of table to retrieve.  Can be
+ *                                    Logical or Physical
+ *              return_header       - Where the table header is returned
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Maps the physical address of table into a logical address
+ * DESCRIPTION: Get an ACPI table header.  Works in both physical or virtual
+ *              addressing mode.  Works with both physical or logical pointers.
+ *              Table is either copied or mapped, depending on the pointer
+ *              type and mode of the processor.
  *
  ******************************************************************************/
 
 acpi_status
-acpi_tb_get_table (
-	ACPI_PHYSICAL_ADDRESS   physical_address,
-	acpi_table_header       *buffer_ptr,
-	acpi_table_desc         *table_info)
+acpi_tb_get_table_header (
+	struct acpi_pointer             *address,
+	struct acpi_table_header        *return_header)
 {
-	acpi_table_header       *table_header = NULL;
-	acpi_table_header       *full_table = NULL;
-	u32                     size;
-	u8                      allocation;
-	acpi_status             status = AE_OK;
-
-
-	FUNCTION_TRACE ("Tb_get_table");
-
-
-	if (!table_info) {
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
-	}
-
-
-	if (buffer_ptr) {
-		/*
-		 * Getting data from a buffer, not BIOS tables
-		 */
-		table_header = buffer_ptr;
-		status = acpi_tb_validate_table_header (table_header);
-		if (ACPI_FAILURE (status)) {
-			/* Table failed verification, map all errors to BAD_DATA */
+	acpi_status                     status = AE_OK;
+	struct acpi_table_header        *header = NULL;
 
-			return_ACPI_STATUS (AE_BAD_DATA);
-		}
 
-		/* Allocate buffer for the entire table */
+	ACPI_FUNCTION_TRACE ("tb_get_table_header");
 
-		full_table = ACPI_MEM_ALLOCATE (table_header->length);
-		if (!full_table) {
-			return_ACPI_STATUS (AE_NO_MEMORY);
-		}
 
-		/* Copy the entire table (including header) to the local buffer */
+	/*
+	 * Flags contains the current processor mode (Virtual or Physical addressing)
+	 * The pointer_type is either Logical or Physical
+	 */
+	switch (address->pointer_type) {
+	case ACPI_PHYSMODE_PHYSPTR:
+	case ACPI_LOGMODE_LOGPTR:
 
-		size = table_header->length;
-		MEMCPY (full_table, buffer_ptr, size);
+		/* Pointer matches processor mode, copy the header */
 
-		/* Save allocation type */
+		ACPI_MEMCPY (return_header, address->pointer.logical, sizeof (struct acpi_table_header));
+		break;
 
-		allocation = ACPI_MEM_ALLOCATED;
-	}
 
+	case ACPI_LOGMODE_PHYSPTR:
 
-	/*
-	 * Not reading from a buffer, just map the table's physical memory
-	 * into our address space.
-	 */
-	else {
-		size = SIZE_IN_HEADER;
+		/* Create a logical address for the physical pointer*/
 
-		status = acpi_tb_map_acpi_table (physical_address, &size, &full_table);
+		status = acpi_os_map_memory (address->pointer.physical, sizeof (struct acpi_table_header),
+				  (void **) &header);
 		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_ERROR (("Could not map memory at %8.8X%8.8X for length %X\n",
+				ACPI_HIDWORD (address->pointer.physical),
+				ACPI_LODWORD (address->pointer.physical),
+				sizeof (struct acpi_table_header)));
 			return_ACPI_STATUS (status);
 		}
 
-		/* Save allocation type */
+		/* Copy header and delete mapping */
 
-		allocation = ACPI_MEM_MAPPED;
-	}
+		ACPI_MEMCPY (return_header, header, sizeof (struct acpi_table_header));
+		acpi_os_unmap_memory (header, sizeof (struct acpi_table_header));
+		break;
 
 
-	/* Return values */
+	default:
 
-	table_info->pointer     = full_table;
-	table_info->length      = size;
-	table_info->allocation  = allocation;
-	table_info->base_pointer = full_table;
+		ACPI_REPORT_ERROR (("Invalid address flags %X\n",
+			address->pointer_type));
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
 
-	return_ACPI_STATUS (status);
+	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_tb_get_all_tables
+ * FUNCTION:    acpi_tb_get_table_body
  *
- * PARAMETERS:  Number_of_tables    - Number of tables to get
- *              Table_ptr           - Input buffer pointer, optional
+ * PARAMETERS:  Address             - Address of table to retrieve.  Can be
+ *                                    Logical or Physical
+ *              Header              - Header of the table to retrieve
+ *              table_info          - Where the table info is returned
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Load and validate all tables other than the RSDT.  The RSDT must
- *              already be loaded and validated.
+ * DESCRIPTION: Get an entire ACPI table with support to allow the host OS to
+ *              replace the table with a newer version (table override.)
+ *              Works in both physical or virtual
+ *              addressing mode.  Works with both physical or logical pointers.
+ *              Table is either copied or mapped, depending on the pointer
+ *              type and mode of the processor.
  *
  ******************************************************************************/
 
 acpi_status
-acpi_tb_get_all_tables (
-	u32                     number_of_tables,
-	acpi_table_header       *table_ptr)
+acpi_tb_get_table_body (
+	struct acpi_pointer             *address,
+	struct acpi_table_header        *header,
+	struct acpi_table_desc          *table_info)
 {
-	acpi_status             status = AE_OK;
-	u32                     index;
-	acpi_table_desc         table_info;
-
-
-	FUNCTION_TRACE ("Tb_get_all_tables");
+	acpi_status                     status;
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Number of tables: %d\n", number_of_tables));
 
+	ACPI_FUNCTION_TRACE ("tb_get_table_body");
 
-	/*
-	 * Loop through all table pointers found in RSDT.
-	 * This will NOT include the FACS and DSDT - we must get
-	 * them after the loop
-	 */
-	for (index = 0; index < number_of_tables; index++) {
-		/* Clear the Table_info each time */
-
-		MEMSET (&table_info, 0, sizeof (acpi_table_desc));
-
-		/* Get the table via the XSDT */
-
-		status = acpi_tb_get_table ((ACPI_PHYSICAL_ADDRESS)
-				 ACPI_GET_ADDRESS (acpi_gbl_XSDT->table_offset_entry[index]),
-				 table_ptr, &table_info);
-
-		/* Ignore a table that failed verification */
-
-		if (status == AE_BAD_DATA) {
-			continue;
-		}
-
-		/* However, abort on serious errors */
-
-		if (ACPI_FAILURE (status)) {
-			return_ACPI_STATUS (status);
-		}
-
-		/* Recognize and install the table */
-
-		status = acpi_tb_install_table (table_ptr, &table_info);
-		if (ACPI_FAILURE (status)) {
-			/*
-			 * Unrecognized or unsupported table, delete it and ignore the
-			 * error.  Just get as many tables as we can, later we will
-			 * determine if there are enough tables to continue.
-			 */
-			acpi_tb_uninstall_table (&table_info);
-		}
-	}
-
-
-	/*
-	 * Convert the FADT to a common format.  This allows earlier revisions of the
-	 * table to coexist with newer versions, using common access code.
-	 */
-	status = acpi_tb_convert_table_fadt ();
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
-
-
-	/*
-	 * Get the minimum set of ACPI tables, namely:
-	 *
-	 * 1) FADT (via RSDT in loop above)
-	 * 2) FACS
-	 * 3) DSDT
-	 *
-	 */
-
-	/*
-	 * Get the FACS (must have the FADT first, from loop above)
-	 * Acpi_tb_get_table_facs will fail if FADT pointer is not valid
-	 */
-	status = acpi_tb_get_table_facs (table_ptr, &table_info);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
-
-	/* Install the FACS */
-
-	status = acpi_tb_install_table (table_ptr, &table_info);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
 
-	/*
-	 * Create the common FACS pointer table
-	 * (Contains pointers to the original table)
-	 */
-	status = acpi_tb_build_common_facs (&table_info);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
+	if (!table_info || !address) {
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-
 	/*
-	 * Get the DSDT (We know that the FADT is valid now)
+	 * Attempt table override.
 	 */
-	status = acpi_tb_get_table ((ACPI_PHYSICAL_ADDRESS) ACPI_GET_ADDRESS (acpi_gbl_FADT->Xdsdt),
-			  table_ptr, &table_info);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
-
-	/* Install the DSDT */
+	status = acpi_tb_table_override (header, table_info);
+	if (ACPI_SUCCESS (status)) {
+		/* Table was overridden by the host OS */
 
-	status = acpi_tb_install_table (table_ptr, &table_info);
-	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
-	/* Dump the DSDT Header */
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_TABLES, "Hex dump of DSDT Header:\n"));
-	DUMP_BUFFER ((u8 *) acpi_gbl_DSDT, sizeof (acpi_table_header));
-
-	/* Dump the entire DSDT */
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_TABLES,
-		"Hex dump of DSDT (After header), size %d (%x)\n",
-		acpi_gbl_DSDT->length, acpi_gbl_DSDT->length));
-	DUMP_BUFFER ((u8 *) (acpi_gbl_DSDT + 1), acpi_gbl_DSDT->length);
-
-	/*
-	 * Initialize the capabilities flags.
-	 * Assumes that platform supports ACPI_MODE since we have tables!
-	 */
-	acpi_gbl_system_flags |= acpi_hw_get_mode_capabilities ();
-
-
-	/* Always delete the RSDP mapping, we are done with it */
-
-	acpi_tb_delete_acpi_table (ACPI_TABLE_RSDP);
+	/* No override, get the original table */
 
+	status = acpi_tb_get_this_table (address, header, table_info);
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_tb_verify_rsdp
+ * FUNCTION:    acpi_tb_table_override
  *
- * PARAMETERS:  Number_of_tables    - Where the table count is placed
+ * PARAMETERS:  Header              - Pointer to table header
+ *              table_info          - Return info if table is overridden
  *
- * RETURN:      Status
+ * RETURN:      None
  *
- * DESCRIPTION: Load and validate the RSDP (ptr) and RSDT (table)
+ * DESCRIPTION: Attempts override of current table with a new one if provided
+ *              by the host OS.
  *
  ******************************************************************************/
 
 acpi_status
-acpi_tb_verify_rsdp (
-	ACPI_PHYSICAL_ADDRESS   rsdp_physical_address)
+acpi_tb_table_override (
+	struct acpi_table_header        *header,
+	struct acpi_table_desc          *table_info)
 {
-	acpi_table_desc         table_info;
-	acpi_status             status;
-	u8                      *table_ptr;
+	struct acpi_table_header        *new_table;
+	acpi_status                     status;
+	struct acpi_pointer             address;
 
 
-	FUNCTION_TRACE ("Tb_verify_rsdp");
+	ACPI_FUNCTION_TRACE ("tb_table_override");
 
 
 	/*
-	 * Obtain access to the RSDP structure
+	 * The OSL will examine the header and decide whether to override this
+	 * table.  If it decides to override, a table will be returned in new_table,
+	 * which we will then copy.
 	 */
-	status = acpi_os_map_memory (rsdp_physical_address, sizeof (RSDP_DESCRIPTOR),
-			  (void **) &table_ptr);
+	status = acpi_os_table_override (header, &new_table);
 	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
-
-	/*
-	 *  The signature and checksum must both be correct
-	 */
-	if (STRNCMP ((NATIVE_CHAR *) table_ptr, RSDP_SIG, sizeof (RSDP_SIG)-1) != 0) {
-		/* Nope, BAD Signature */
+		/* Some severe error from the OSL, but we basically ignore it */
 
-		status = AE_BAD_SIGNATURE;
-		goto cleanup;
+		ACPI_REPORT_ERROR (("Could not override ACPI table, %s\n",
+			acpi_format_exception (status)));
+		return_ACPI_STATUS (status);
 	}
 
-	if (acpi_tb_checksum (table_ptr, RSDP_CHECKSUM_LENGTH) != 0) {
-		/* Nope, BAD Checksum */
+	if (!new_table) {
+		/* No table override */
 
-		status = AE_BAD_CHECKSUM;
-		goto cleanup;
+		return_ACPI_STATUS (AE_NO_ACPI_TABLES);
 	}
 
-	/* TBD: Check extended checksum if table version >= 2 */
-
-	/* The RSDP supplied is OK */
-
-	table_info.pointer     = (acpi_table_header *) table_ptr;
-	table_info.length      = sizeof (RSDP_DESCRIPTOR);
-	table_info.allocation  = ACPI_MEM_MAPPED;
-	table_info.base_pointer = table_ptr;
-
-	/* Save the table pointers and allocation info */
+	/*
+	 * We have a new table to override the old one.  Get a copy of
+	 * the new one.  We know that the new table has a logical pointer.
+	 */
+	address.pointer_type    = ACPI_LOGICAL_POINTER | ACPI_LOGICAL_ADDRESSING;
+	address.pointer.logical = new_table;
 
-	status = acpi_tb_init_table_descriptor (ACPI_TABLE_RSDP, &table_info);
+	status = acpi_tb_get_this_table (&address, new_table, table_info);
 	if (ACPI_FAILURE (status)) {
-		goto cleanup;
+		ACPI_REPORT_ERROR (("Could not copy override ACPI table, %s\n",
+			acpi_format_exception (status)));
+		return_ACPI_STATUS (status);
 	}
 
+	/* Copy the table info */
 
-	/* Save the RSDP in a global for easy access */
-
-	acpi_gbl_RSDP = (RSDP_DESCRIPTOR *) table_info.pointer;
-	return_ACPI_STATUS (status);
-
-
-	/* Error exit */
-cleanup:
+	ACPI_REPORT_INFO (("Table [%4.4s] replaced by host OS\n",
+		table_info->pointer->signature));
 
-	acpi_os_unmap_memory (table_ptr, sizeof (RSDP_DESCRIPTOR));
-	return_ACPI_STATUS (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_tb_get_rsdt_address
- *
- * PARAMETERS:  None
- *
- * RETURN:      RSDT physical address
- *
- * DESCRIPTION: Extract the address of the RSDT or XSDT, depending on the
- *              version of the RSDP
- *
- ******************************************************************************/
-
-ACPI_PHYSICAL_ADDRESS
-acpi_tb_get_rsdt_address (void)
-{
-	ACPI_PHYSICAL_ADDRESS   physical_address;
-
-
-	FUNCTION_ENTRY ();
-
-
-	/*
-	 * For RSDP revision 0 or 1, we use the RSDT.
-	 * For RSDP revision 2 (and above), we use the XSDT
-	 */
-	if (acpi_gbl_RSDP->revision < 2) {
-#ifdef _IA64
-		/* 0.71 RSDP has 64bit Rsdt address field */
-		physical_address = ((RSDP_DESCRIPTOR_REV071 *)acpi_gbl_RSDP)->rsdt_physical_address;
-#else
-		physical_address = (ACPI_PHYSICAL_ADDRESS) acpi_gbl_RSDP->rsdt_physical_address;
-#endif
-	}
-
-	else {
-		physical_address = (ACPI_PHYSICAL_ADDRESS)
-				   ACPI_GET_ADDRESS (acpi_gbl_RSDP->xsdt_physical_address);
-	}
-
-	return (physical_address);
+	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_tb_validate_rsdt
+ * FUNCTION:    acpi_tb_get_this_table
  *
- * PARAMETERS:  Table_ptr       - Addressable pointer to the RSDT.
+ * PARAMETERS:  Address             - Address of table to retrieve.  Can be
+ *                                    Logical or Physical
+ *              Header              - Header of the table to retrieve
+ *              table_info          - Where the table info is returned
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Validate signature for the RSDT or XSDT
+ * DESCRIPTION: Get an entire ACPI table.  Works in both physical or virtual
+ *              addressing mode.  Works with both physical or logical pointers.
+ *              Table is either copied or mapped, depending on the pointer
+ *              type and mode of the processor.
  *
  ******************************************************************************/
 
 acpi_status
-acpi_tb_validate_rsdt (
-	acpi_table_header       *table_ptr)
+acpi_tb_get_this_table (
+	struct acpi_pointer             *address,
+	struct acpi_table_header        *header,
+	struct acpi_table_desc          *table_info)
 {
-	u32                     no_match;
+	struct acpi_table_header        *full_table = NULL;
+	u8                              allocation;
+	acpi_status                     status = AE_OK;
 
 
-	PROC_NAME ("Tb_validate_rsdt");
+	ACPI_FUNCTION_TRACE ("tb_get_this_table");
 
 
 	/*
-	 * For RSDP revision 0 or 1, we use the RSDT.
-	 * For RSDP revision 2 (and above), we use the XSDT
+	 * Flags contains the current processor mode (Virtual or Physical addressing)
+	 * The pointer_type is either Logical or Physical
 	 */
-	if (acpi_gbl_RSDP->revision < 2) {
-		no_match = STRNCMP ((char *) table_ptr, RSDT_SIG,
-				  sizeof (RSDT_SIG) -1);
-	}
-	else {
-		no_match = STRNCMP ((char *) table_ptr, XSDT_SIG,
-				  sizeof (XSDT_SIG) -1);
-	}
-
-
-	if (no_match) {
-		/* Invalid RSDT or XSDT signature */
-
-		REPORT_ERROR (("Invalid signature where RSDP indicates RSDT/XSDT should be located\n"));
-
-		DUMP_BUFFER (acpi_gbl_RSDP, 20);
-
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_ERROR,
-			"RSDT/XSDT signature at %X is invalid\n",
-			acpi_gbl_RSDP->rsdt_physical_address));
-
-		return (AE_BAD_SIGNATURE);
-	}
-
-	return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_tb_get_table_pointer
- *
- * PARAMETERS:  Physical_address    - Address from RSDT
- *              Flags               - virtual or physical addressing
- *              Table_ptr           - Addressable address (output)
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Create an addressable pointer to an ACPI table
- *
- ******************************************************************************/
-
-acpi_status
-acpi_tb_get_table_pointer (
-	ACPI_PHYSICAL_ADDRESS   physical_address,
-	u32                     flags,
-	u32                     *size,
-	acpi_table_header       **table_ptr)
-{
-	acpi_status             status;
-
-
-	FUNCTION_ENTRY ();
-
-
-	if ((flags & ACPI_MEMORY_MODE) == ACPI_LOGICAL_ADDRESSING) {
-		*size = SIZE_IN_HEADER;
-		status = acpi_tb_map_acpi_table (physical_address, size, table_ptr);
-	}
-
-	else {
-		*size = 0;
-		*table_ptr = (acpi_table_header *) (ACPI_TBLPTR) physical_address;
-
-		status = AE_OK;
-	}
-
-	return (status);
-}
-
+	switch (address->pointer_type) {
+	case ACPI_PHYSMODE_PHYSPTR:
+	case ACPI_LOGMODE_LOGPTR:
 
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_tb_get_table_rsdt
- *
- * PARAMETERS:  Number_of_tables    - Where the table count is placed
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Load and validate the RSDP (ptr) and RSDT (table)
- *
- ******************************************************************************/
+		/* Pointer matches processor mode, copy the table to a new buffer */
 
-acpi_status
-acpi_tb_get_table_rsdt (
-	u32                     *number_of_tables)
-{
-	acpi_table_desc         table_info;
-	acpi_status             status;
-	ACPI_PHYSICAL_ADDRESS   physical_address;
+		full_table = ACPI_MEM_ALLOCATE (header->length);
+		if (!full_table) {
+			ACPI_REPORT_ERROR (("Could not allocate table memory for [%4.4s] length %X\n",
+				header->signature, header->length));
+			return_ACPI_STATUS (AE_NO_MEMORY);
+		}
 
+		/* Copy the entire table (including header) to the local buffer */
 
-	FUNCTION_TRACE ("Tb_get_table_rsdt");
+		ACPI_MEMCPY (full_table, address->pointer.logical, header->length);
 
+		/* Save allocation type */
 
-	/*
-	 * Get the RSDT from the RSDP
-	 */
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-		"RSDP located at %p, RSDT physical=%8.8X%8.8X \n",
-		acpi_gbl_RSDP, HIDWORD(acpi_gbl_RSDP->rsdt_physical_address),
-		LODWORD(acpi_gbl_RSDP->rsdt_physical_address)));
+		allocation = ACPI_MEM_ALLOCATED;
+		break;
 
 
-	physical_address = acpi_tb_get_rsdt_address ();
+	case ACPI_LOGMODE_PHYSPTR:
 
+		/*
+		 * Just map the table's physical memory
+		 * into our address space.
+		 */
+		status = acpi_os_map_memory (address->pointer.physical, (acpi_size) header->length,
+				  (void **) &full_table);
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_ERROR (("Could not map memory for table [%4.4s] at %8.8X%8.8X for length %X\n",
+				header->signature,
+				ACPI_HIDWORD (address->pointer.physical),
+				ACPI_LODWORD (address->pointer.physical), header->length));
+			return (status);
+		}
 
-	/* Get the RSDT/XSDT */
+		/* Save allocation type */
 
-	status = acpi_tb_get_table (physical_address, NULL, &table_info);
-	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not get the RSDT, %s\n",
-			acpi_format_exception (status)));
-		return_ACPI_STATUS (status);
-	}
+		allocation = ACPI_MEM_MAPPED;
+		break;
 
 
-	/* Check the RSDT or XSDT signature */
+	default:
 
-	status = acpi_tb_validate_rsdt (table_info.pointer);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid address flags %X\n",
+			address->pointer_type));
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-
 	/*
-	 * Valid RSDT signature, verify the checksum.  If it fails, just
-	 * print a warning and ignore it.
+	 * Validate checksum for _most_ tables,
+	 * even the ones whose signature we don't recognize
 	 */
-	status = acpi_tb_verify_table_checksum (table_info.pointer);
+	if (table_info->type != ACPI_TABLE_FACS) {
+		status = acpi_tb_verify_table_checksum (full_table);
 
+#if (!ACPI_CHECKSUM_ABORT)
+		if (ACPI_FAILURE (status)) {
+			/* Ignore the error if configuration says so */
 
-	/* Convert and/or copy to an XSDT structure */
-
-	status = acpi_tb_convert_to_xsdt (&table_info, number_of_tables);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
+			status = AE_OK;
+		}
+#endif
 	}
 
-	/* Save the table pointers and allocation info */
-
-	status = acpi_tb_init_table_descriptor (ACPI_TABLE_XSDT, &table_info);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
+	/* Return values */
 
-	acpi_gbl_XSDT = (xsdt_descriptor *) table_info.pointer;
+	table_info->pointer     = full_table;
+	table_info->length      = (acpi_size) header->length;
+	table_info->allocation  = allocation;
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "XSDT located at %p\n", acpi_gbl_XSDT));
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+		"Found table [%4.4s] at %8.8X%8.8X, mapped/copied to %p\n",
+		full_table->signature,
+		ACPI_HIDWORD (address->pointer.physical),
+		ACPI_LODWORD (address->pointer.physical), full_table));
 
 	return_ACPI_STATUS (status);
 }
 
 
-/******************************************************************************
+/*******************************************************************************
  *
- * FUNCTION:    Acpi_tb_get_table_facs
+ * FUNCTION:    acpi_tb_get_table_ptr
  *
- * PARAMETERS:  *Buffer_ptr             - If Buffer_ptr is valid, read data from
- *                                        buffer rather than searching memory
- *              *Table_info             - Where the table info is returned
+ * PARAMETERS:  table_type      - one of the defined table types
+ *              Instance        - Which table of this type
+ *              table_ptr_loc   - pointer to location to place the pointer for
+ *                                return
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Returns a pointer to the FACS as defined in FADT.  This
- *              function assumes the global variable FADT has been
- *              correctly initialized.  The value of FADT->Firmware_ctrl
- *              into a far pointer which is returned.
+ * DESCRIPTION: This function is called to get the pointer to an ACPI table.
  *
- *****************************************************************************/
+ ******************************************************************************/
 
 acpi_status
-acpi_tb_get_table_facs (
-	acpi_table_header       *buffer_ptr,
-	acpi_table_desc         *table_info)
+acpi_tb_get_table_ptr (
+	acpi_table_type                 table_type,
+	u32                             instance,
+	struct acpi_table_header        **table_ptr_loc)
 {
-	acpi_table_header       *table_ptr = NULL;
-	u32                     size;
-	u8                      allocation;
-	acpi_status             status = AE_OK;
+	struct acpi_table_desc          *table_desc;
+	u32                             i;
 
 
-	FUNCTION_TRACE ("Tb_get_table_facs");
+	ACPI_FUNCTION_TRACE ("tb_get_table_ptr");
 
 
-	/* Must have a valid FADT pointer */
-
-	if (!acpi_gbl_FADT) {
+	if (!acpi_gbl_DSDT) {
 		return_ACPI_STATUS (AE_NO_ACPI_TABLES);
 	}
 
-	size = sizeof (FACS_DESCRIPTOR);
-	if (buffer_ptr) {
-		/*
-		 * Getting table from a file -- allocate a buffer and
-		 * read the table.
-		 */
-		table_ptr = ACPI_MEM_ALLOCATE (size);
-		if(!table_ptr) {
-			return_ACPI_STATUS (AE_NO_MEMORY);
-		}
-
-		MEMCPY (table_ptr, buffer_ptr, size);
-
-		/* Save allocation type */
-
-		allocation = ACPI_MEM_ALLOCATED;
+	if (table_type > ACPI_TABLE_MAX) {
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	else {
-		/* Just map the physical memory to our address space */
+	/*
+	 * For all table types (Single/Multiple), the first
+	 * instance is always in the list head.
+	 */
+	if (instance == 1) {
+		/* Get the first */
 
-		status = acpi_tb_map_acpi_table ((ACPI_PHYSICAL_ADDRESS) ACPI_GET_ADDRESS (acpi_gbl_FADT->Xfirmware_ctrl),
-				   &size, &table_ptr);
-		if (ACPI_FAILURE (status)) {
-			return_ACPI_STATUS (status);
+		if (acpi_gbl_table_lists[table_type].next) {
+			*table_ptr_loc = acpi_gbl_table_lists[table_type].next->pointer;
 		}
+		return_ACPI_STATUS (AE_OK);
+	}
 
-		/* Save allocation type */
-
-		allocation = ACPI_MEM_MAPPED;
+	/*
+	 * Check for instance out of range
+	 */
+	if (instance > acpi_gbl_table_lists[table_type].count) {
+		return_ACPI_STATUS (AE_NOT_EXIST);
 	}
 
+	/* Walk the list to get the desired table
+	 * Since the if (Instance == 1) check above checked for the
+	 * first table, setting table_desc equal to the .Next member
+	 * is actually pointing to the second table.  Therefore, we
+	 * need to walk from the 2nd table until we reach the Instance
+	 * that the user is looking for and return its table pointer.
+	 */
+	table_desc = acpi_gbl_table_lists[table_type].next;
+	for (i = 2; i < instance; i++) {
+		table_desc = table_desc->next;
+	}
 
-	/* Return values */
+	/* We are now pointing to the requested table's descriptor */
 
-	table_info->pointer     = table_ptr;
-	table_info->length      = size;
-	table_info->allocation  = allocation;
-	table_info->base_pointer = table_ptr;
+	*table_ptr_loc = table_desc->pointer;
 
-	return_ACPI_STATUS (status);
+	return_ACPI_STATUS (AE_OK);
 }
 
diff -urNp linux-5400/drivers/acpi/tables/tbgetall.c linux-5410/drivers/acpi/tables/tbgetall.c
--- linux-5400/drivers/acpi/tables/tbgetall.c
+++ linux-5410/drivers/acpi/tables/tbgetall.c
@@ -0,0 +1,314 @@
+/******************************************************************************
+ *
+ * Module Name: tbgetall - Get all required ACPI tables
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+
+#include <acpi/acpi.h>
+#include <acpi/actables.h>
+
+
+#define _COMPONENT          ACPI_TABLES
+	 ACPI_MODULE_NAME    ("tbgetall")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_get_primary_table
+ *
+ * PARAMETERS:  Address             - Physical address of table to retrieve
+ *              *table_info         - Where the table info is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Maps the physical address of table into a logical address
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_tb_get_primary_table (
+	struct acpi_pointer             *address,
+	struct acpi_table_desc          *table_info)
+{
+	acpi_status                     status;
+	struct acpi_table_header        header;
+
+
+	ACPI_FUNCTION_TRACE ("tb_get_primary_table");
+
+
+	/* Ignore a NULL address in the RSDT */
+
+	if (!address->pointer.value) {
+		return_ACPI_STATUS (AE_OK);
+	}
+
+	/*
+	 * Get the header in order to get signature and table size
+	 */
+	status = acpi_tb_get_table_header (address, &header);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/* Clear the table_info */
+
+	ACPI_MEMSET (table_info, 0, sizeof (struct acpi_table_desc));
+
+	/*
+	 * Check the table signature and make sure it is recognized.
+	 * Also checks the header checksum
+	 */
+	table_info->pointer = &header;
+	status = acpi_tb_recognize_table (table_info, ACPI_TABLE_PRIMARY);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/* Get the entire table */
+
+	status = acpi_tb_get_table_body (address, &header, table_info);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/* Install the table */
+
+	status = acpi_tb_install_table (table_info);
+	return_ACPI_STATUS (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_get_secondary_table
+ *
+ * PARAMETERS:  Address             - Physical address of table to retrieve
+ *              *table_info         - Where the table info is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Maps the physical address of table into a logical address
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_tb_get_secondary_table (
+	struct acpi_pointer             *address,
+	acpi_string                     signature,
+	struct acpi_table_desc          *table_info)
+{
+	acpi_status                     status;
+	struct acpi_table_header        header;
+
+
+	ACPI_FUNCTION_TRACE_STR ("tb_get_secondary_table", signature);
+
+
+	/* Get the header in order to match the signature */
+
+	status = acpi_tb_get_table_header (address, &header);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/* Signature must match request */
+
+	if (ACPI_STRNCMP (header.signature, signature, ACPI_NAME_SIZE)) {
+		ACPI_REPORT_ERROR (("Incorrect table signature - wanted [%s] found [%4.4s]\n",
+			signature, header.signature));
+		return_ACPI_STATUS (AE_BAD_SIGNATURE);
+	}
+
+	/*
+	 * Check the table signature and make sure it is recognized.
+	 * Also checks the header checksum
+	 */
+	table_info->pointer = &header;
+	status = acpi_tb_recognize_table (table_info, ACPI_TABLE_SECONDARY);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/* Get the entire table */
+
+	status = acpi_tb_get_table_body (address, &header, table_info);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/* Install the table */
+
+	status = acpi_tb_install_table (table_info);
+	return_ACPI_STATUS (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_get_required_tables
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Load and validate tables other than the RSDT.  The RSDT must
+ *              already be loaded and validated.
+ *
+ *              Get the minimum set of ACPI tables, namely:
+ *
+ *              1) FADT (via RSDT in loop below)
+ *              2) FACS (via FADT)
+ *              3) DSDT (via FADT)
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_tb_get_required_tables (
+	void)
+{
+	acpi_status                     status = AE_OK;
+	u32                             i;
+	struct acpi_table_desc          table_info;
+	struct acpi_pointer             address;
+
+
+	ACPI_FUNCTION_TRACE ("tb_get_required_tables");
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "%d ACPI tables in RSDT\n",
+		acpi_gbl_rsdt_table_count));
+
+
+	address.pointer_type  = acpi_gbl_table_flags | ACPI_LOGICAL_ADDRESSING;
+
+	/*
+	 * Loop through all table pointers found in RSDT.
+	 * This will NOT include the FACS and DSDT - we must get
+	 * them after the loop.
+	 *
+	 * The only tables we are interested in getting here is the FADT and
+	 * any SSDTs.
+	 */
+	for (i = 0; i < acpi_gbl_rsdt_table_count; i++) {
+		/* Get the table address from the common internal XSDT */
+
+		address.pointer.value = acpi_gbl_XSDT->table_offset_entry[i];
+
+		/*
+		 * Get the tables needed by this subsystem (FADT and any SSDTs).
+		 * NOTE: All other tables are completely ignored at this time.
+		 */
+		status = acpi_tb_get_primary_table (&address, &table_info);
+		if ((status != AE_OK) && (status != AE_TABLE_NOT_SUPPORTED)) {
+			ACPI_REPORT_WARNING (("%s, while getting table at %8.8X%8.8X\n",
+				acpi_format_exception (status),
+				ACPI_HIDWORD (address.pointer.value),
+				ACPI_LODWORD (address.pointer.value)));
+		}
+	}
+
+	/* We must have a FADT to continue */
+
+	if (!acpi_gbl_FADT) {
+		ACPI_REPORT_ERROR (("No FADT present in RSDT/XSDT\n"));
+		return_ACPI_STATUS (AE_NO_ACPI_TABLES);
+	}
+
+	/*
+	 * Convert the FADT to a common format.  This allows earlier revisions of the
+	 * table to coexist with newer versions, using common access code.
+	 */
+	status = acpi_tb_convert_table_fadt ();
+	if (ACPI_FAILURE (status)) {
+		ACPI_REPORT_ERROR (("Could not convert FADT to internal common format\n"));
+		return_ACPI_STATUS (status);
+	}
+
+	/*
+	 * Get the FACS (Pointed to by the FADT)
+	 */
+	address.pointer.value = acpi_gbl_FADT->xfirmware_ctrl;
+
+	status = acpi_tb_get_secondary_table (&address, FACS_SIG, &table_info);
+	if (ACPI_FAILURE (status)) {
+		ACPI_REPORT_ERROR (("Could not get/install the FACS, %s\n",
+			acpi_format_exception (status)));
+		return_ACPI_STATUS (status);
+	}
+
+	/*
+	 * Create the common FACS pointer table
+	 * (Contains pointers to the original table)
+	 */
+	status = acpi_tb_build_common_facs (&table_info);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/*
+	 * Get/install the DSDT (Pointed to by the FADT)
+	 */
+	address.pointer.value = acpi_gbl_FADT->Xdsdt;
+
+	status = acpi_tb_get_secondary_table (&address, DSDT_SIG, &table_info);
+	if (ACPI_FAILURE (status)) {
+		ACPI_REPORT_ERROR (("Could not get/install the DSDT\n"));
+		return_ACPI_STATUS (status);
+	}
+
+	/* Set Integer Width (32/64) based upon DSDT revision */
+
+	acpi_ut_set_integer_width (acpi_gbl_DSDT->revision);
+
+	/* Dump the entire DSDT */
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_TABLES,
+		"Hex dump of entire DSDT, size %d (0x%X), Integer width = %d\n",
+		acpi_gbl_DSDT->length, acpi_gbl_DSDT->length, acpi_gbl_integer_bit_width));
+	ACPI_DUMP_BUFFER ((u8 *) acpi_gbl_DSDT, acpi_gbl_DSDT->length);
+
+	/* Always delete the RSDP mapping, we are done with it */
+
+	acpi_tb_delete_tables_by_type (ACPI_TABLE_RSDP);
+	return_ACPI_STATUS (status);
+}
+
+
diff -urNp linux-5400/drivers/acpi/tables/tbinstal.c linux-5410/drivers/acpi/tables/tbinstal.c
--- linux-5400/drivers/acpi/tables/tbinstal.c
+++ linux-5410/drivers/acpi/tables/tbinstal.c
@@ -1,44 +1,118 @@
 /******************************************************************************
  *
  * Module Name: tbinstal - ACPI table installation and removal
- *              $Revision: 45 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "achware.h"
-#include "actables.h"
+#include <acpi/acpi.h>
+#include <acpi/actables.h>
 
 
 #define _COMPONENT          ACPI_TABLES
-	 MODULE_NAME         ("tbinstal")
+	 ACPI_MODULE_NAME    ("tbinstal")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_tb_install_table
+ * FUNCTION:    acpi_tb_match_signature
  *
- * PARAMETERS:  Table_ptr           - Input buffer pointer, optional
- *              Table_info          - Return value from Acpi_tb_get_table
+ * PARAMETERS:  Signature           - Table signature to match
+ *              table_info          - Return data
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compare signature against the list of "ACPI-subsystem-owned"
+ *              tables (DSDT/FADT/SSDT, etc.) Returns the table_type_iD on match.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_tb_match_signature (
+	char                            *signature,
+	struct acpi_table_desc          *table_info,
+	u8                              search_type)
+{
+	acpi_native_uint                i;
+
+
+	ACPI_FUNCTION_TRACE ("tb_match_signature");
+
+
+	/*
+	 * Search for a signature match among the known table types
+	 */
+	for (i = 0; i < NUM_ACPI_TABLE_TYPES; i++) {
+		if (!(acpi_gbl_table_data[i].flags & search_type)) {
+			continue;
+		}
+
+		if (!ACPI_STRNCMP (signature, acpi_gbl_table_data[i].signature,
+				   acpi_gbl_table_data[i].sig_length)) {
+			/* Found a signature match, return index if requested */
+
+			if (table_info) {
+				table_info->type = (u8) i;
+			}
+
+			ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+				"Table [%4.4s] is an ACPI table consumed by the core subsystem\n",
+				(char *) acpi_gbl_table_data[i].signature));
+
+			return_ACPI_STATUS (AE_OK);
+		}
+	}
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+		"Table [%4.4s] is not an ACPI table consumed by the core subsystem - ignored\n",
+		(char *) signature));
+
+	return_ACPI_STATUS (AE_TABLE_NOT_SUPPORTED);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_install_table
+ *
+ * PARAMETERS:  table_info          - Return value from acpi_tb_get_table_body
  *
  * RETURN:      Status
  *
@@ -50,45 +124,43 @@
 
 acpi_status
 acpi_tb_install_table (
-	acpi_table_header       *table_ptr,
-	acpi_table_desc         *table_info)
+	struct acpi_table_desc          *table_info)
 {
-	acpi_status             status;
+	acpi_status                     status;
 
-	FUNCTION_TRACE ("Tb_install_table");
+	ACPI_FUNCTION_TRACE ("tb_install_table");
 
 
-	/*
-	 * Check the table signature and make sure it is recognized
-	 * Also checks the header checksum
-	 */
-	status = acpi_tb_recognize_table (table_ptr, table_info);
+	/* Lock tables while installing */
+
+	status = acpi_ut_acquire_mutex (ACPI_MTX_TABLES);
 	if (ACPI_FAILURE (status)) {
+		ACPI_REPORT_ERROR (("Could not acquire table mutex for [%4.4s], %s\n",
+			table_info->pointer->signature, acpi_format_exception (status)));
 		return_ACPI_STATUS (status);
 	}
 
-	/* Lock tables while installing */
-
-	acpi_ut_acquire_mutex (ACPI_MTX_TABLES);
-
 	/* Install the table into the global data structure */
 
 	status = acpi_tb_init_table_descriptor (table_info->type, table_info);
+	if (ACPI_FAILURE (status)) {
+		ACPI_REPORT_ERROR (("Could not install ACPI table [%4.4s], %s\n",
+			table_info->pointer->signature, acpi_format_exception (status)));
+	}
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "%s located at %p\n",
-		acpi_gbl_acpi_table_data[table_info->type].name, table_info->pointer));
+		acpi_gbl_table_data[table_info->type].name, table_info->pointer));
 
-	acpi_ut_release_mutex (ACPI_MTX_TABLES);
+	(void) acpi_ut_release_mutex (ACPI_MTX_TABLES);
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_tb_recognize_table
+ * FUNCTION:    acpi_tb_recognize_table
  *
- * PARAMETERS:  Table_ptr           - Input buffer pointer, optional
- *              Table_info          - Return value from Acpi_tb_get_table
+ * PARAMETERS:  table_info          - Return value from acpi_tb_get_table_body
  *
  * RETURN:      Status
  *
@@ -106,73 +178,44 @@ acpi_tb_install_table (
 
 acpi_status
 acpi_tb_recognize_table (
-	acpi_table_header       *table_ptr,
-	acpi_table_desc         *table_info)
+	struct acpi_table_desc          *table_info,
+	u8                              search_type)
 {
-	acpi_table_header       *table_header;
-	acpi_status             status;
-	acpi_table_type         table_type = 0;
-	u32                     i;
+	struct acpi_table_header        *table_header;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Tb_recognize_table");
+	ACPI_FUNCTION_TRACE ("tb_recognize_table");
 
 
 	/* Ensure that we have a valid table pointer */
 
-	table_header = (acpi_table_header *) table_info->pointer;
+	table_header = (struct acpi_table_header *) table_info->pointer;
 	if (!table_header) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
 	/*
-	 * Search for a signature match among the known table types
-	 * Start at index one -> Skip the RSDP
+	 * We only "recognize" a limited number of ACPI tables -- namely, the
+	 * ones that are used by the subsystem (DSDT, FADT, etc.)
+	 *
+	 * An AE_TABLE_NOT_SUPPORTED means that the table was not recognized.
+	 * This can be any one of many valid ACPI tables, it just isn't one of
+	 * the tables that is consumed by the core subsystem
 	 */
-	status = AE_SUPPORT;
-	for (i = 1; i < NUM_ACPI_TABLES; i++) {
-		if (!STRNCMP (table_header->signature,
-				  acpi_gbl_acpi_table_data[i].signature,
-				  acpi_gbl_acpi_table_data[i].sig_length)) {
-			/*
-			 * Found a signature match, get the pertinent info from the
-			 * Table_data structure
-			 */
-			table_type      = i;
-			status          = acpi_gbl_acpi_table_data[i].status;
-
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Found %4.4s\n",
-				(char*)acpi_gbl_acpi_table_data[i].signature));
-			break;
-		}
+	status = acpi_tb_match_signature (table_header->signature, table_info, search_type);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
 	}
 
-	/* Return the table type and length via the info struct */
-
-	table_info->type    = (u8) table_type;
-	table_info->length  = table_header->length;
-
-
-	/*
-	 * Validate checksum for _most_ tables,
-	 * even the ones whose signature we don't recognize
-	 */
-	if (table_type != ACPI_TABLE_FACS) {
-		/* But don't abort if the checksum is wrong */
-		/* TBD: [Future] make this a configuration option? */
-
-		acpi_tb_verify_table_checksum (table_header);
+	status = acpi_tb_validate_table_header (table_header);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
 	}
 
-	/*
-	 * An AE_SUPPORT means that the table was not recognized.
-	 * We basically ignore this;  just print a debug message
-	 */
-	if (status == AE_SUPPORT) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-			"Unsupported table %s (Type %X) was found and discarded\n",
-			acpi_gbl_acpi_table_data[table_type].name, table_type));
-	}
+	/* Return the table type and length via the info struct */
+
+	table_info->length = (acpi_size) table_header->length;
 
 	return_ACPI_STATUS (status);
 }
@@ -180,10 +223,10 @@ acpi_tb_recognize_table (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_tb_init_table_descriptor
+ * FUNCTION:    acpi_tb_init_table_descriptor
  *
- * PARAMETERS:  Table_type          - The type of the table
- *              Table_info          - A table info struct
+ * PARAMETERS:  table_type          - The type of the table
+ *              table_info          - A table info struct
  *
  * RETURN:      None.
  *
@@ -193,94 +236,78 @@ acpi_tb_recognize_table (
 
 acpi_status
 acpi_tb_init_table_descriptor (
-	acpi_table_type         table_type,
-	acpi_table_desc         *table_info)
+	acpi_table_type                 table_type,
+	struct acpi_table_desc          *table_info)
 {
-	acpi_table_desc         *list_head;
-	acpi_table_desc         *table_desc;
+	struct acpi_table_list          *list_head;
+	struct acpi_table_desc          *table_desc;
+
 
+	ACPI_FUNCTION_TRACE_U32 ("tb_init_table_descriptor", table_type);
 
-	FUNCTION_TRACE_U32 ("Tb_init_table_descriptor", table_type);
+
+	/* Allocate a descriptor for this table */
+
+	table_desc = ACPI_MEM_CALLOCATE (sizeof (struct acpi_table_desc));
+	if (!table_desc) {
+		return_ACPI_STATUS (AE_NO_MEMORY);
+	}
 
 	/*
 	 * Install the table into the global data structure
 	 */
-	list_head   = &acpi_gbl_acpi_tables[table_type];
-	table_desc  = list_head;
-
+	list_head = &acpi_gbl_table_lists[table_type];
 
 	/*
 	 * Two major types of tables:  1) Only one instance is allowed.  This
 	 * includes most ACPI tables such as the DSDT.  2) Multiple instances of
 	 * the table are allowed.  This includes SSDT and PSDTs.
 	 */
-	if (IS_SINGLE_TABLE (acpi_gbl_acpi_table_data[table_type].flags)) {
+	if (ACPI_IS_SINGLE_TABLE (acpi_gbl_table_data[table_type].flags)) {
 		/*
 		 * Only one table allowed, and a table has alread been installed
 		 *  at this location, so return an error.
 		 */
-		if (list_head->pointer) {
-			return_ACPI_STATUS (AE_EXIST);
+		if (list_head->next) {
+			return_ACPI_STATUS (AE_ALREADY_EXISTS);
 		}
-
-		table_desc->count = 1;
 	}
 
+	/*
+	 * Link the new table in to the list of tables of this type.
+	 * Just insert at the start of the list, order unimportant.
+	 *
+	 * table_desc->Prev is already NULL from calloc()
+	 */
+	table_desc->next = list_head->next;
+	list_head->next = table_desc;
 
-	else {
-		/*
-		 * Multiple tables allowed for this table type, we must link
-		 * the new table in to the list of tables of this type.
-		 */
-		if (list_head->pointer) {
-			table_desc = ACPI_MEM_CALLOCATE (sizeof (acpi_table_desc));
-			if (!table_desc) {
-				return_ACPI_STATUS (AE_NO_MEMORY);
-			}
-
-			list_head->count++;
-
-			/* Update the original previous */
-
-			list_head->prev->next = table_desc;
-
-			/* Update new entry */
-
-			table_desc->prev = list_head->prev;
-			table_desc->next = list_head;
-
-			/* Update list head */
-
-			list_head->prev = table_desc;
-		}
-
-		else {
-			table_desc->count = 1;
-		}
+	if (table_desc->next) {
+		table_desc->next->prev = table_desc;
 	}
 
+	list_head->count++;
 
-	/* Common initialization of the table descriptor */
+	/* Finish initialization of the table descriptor */
 
+	table_desc->type                = (u8) table_type;
 	table_desc->pointer             = table_info->pointer;
-	table_desc->base_pointer        = table_info->base_pointer;
 	table_desc->length              = table_info->length;
 	table_desc->allocation          = table_info->allocation;
 	table_desc->aml_start           = (u8 *) (table_desc->pointer + 1),
 	table_desc->aml_length          = (u32) (table_desc->length -
-			 (u32) sizeof (acpi_table_header));
-	table_desc->table_id            = acpi_ut_allocate_owner_id (OWNER_TYPE_TABLE);
+			 (u32) sizeof (struct acpi_table_header));
+	table_desc->table_id            = acpi_ut_allocate_owner_id (ACPI_OWNER_TYPE_TABLE);
 	table_desc->loaded_into_namespace = FALSE;
 
 	/*
 	 * Set the appropriate global pointer (if there is one) to point to the
 	 * newly installed table
 	 */
-	if (acpi_gbl_acpi_table_data[table_type].global_ptr) {
-		*(acpi_gbl_acpi_table_data[table_type].global_ptr) = table_info->pointer;
+	if (acpi_gbl_table_data[table_type].global_ptr) {
+		*(acpi_gbl_table_data[table_type].global_ptr) = table_info->pointer;
 	}
 
-
 	/* Return Data */
 
 	table_info->table_id        = table_desc->table_id;
@@ -292,7 +319,7 @@ acpi_tb_init_table_descriptor (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_tb_delete_acpi_tables
+ * FUNCTION:    acpi_tb_delete_all_tables
  *
  * PARAMETERS:  None.
  *
@@ -303,25 +330,24 @@ acpi_tb_init_table_descriptor (
  ******************************************************************************/
 
 void
-acpi_tb_delete_acpi_tables (void)
+acpi_tb_delete_all_tables (void)
 {
-	acpi_table_type             type;
+	acpi_table_type                     type;
 
 
 	/*
 	 * Free memory allocated for ACPI tables
 	 * Memory can either be mapped or allocated
 	 */
-	for (type = 0; type < NUM_ACPI_TABLES; type++) {
-		acpi_tb_delete_acpi_table (type);
+	for (type = 0; type < NUM_ACPI_TABLE_TYPES; type++) {
+		acpi_tb_delete_tables_by_type (type);
 	}
-
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_tb_delete_acpi_table
+ * FUNCTION:    acpi_tb_delete_tables_by_type
  *
  * PARAMETERS:  Type                - The table type to be deleted
  *
@@ -333,23 +359,24 @@ acpi_tb_delete_acpi_tables (void)
  ******************************************************************************/
 
 void
-acpi_tb_delete_acpi_table (
-	acpi_table_type             type)
+acpi_tb_delete_tables_by_type (
+	acpi_table_type                     type)
 {
-	FUNCTION_TRACE_U32 ("Tb_delete_acpi_table", type);
+	struct acpi_table_desc          *table_desc;
+	u32                             count;
+	u32                             i;
+
+
+	ACPI_FUNCTION_TRACE_U32 ("tb_delete_tables_by_type", type);
 
 
 	if (type > ACPI_TABLE_MAX) {
 		return_VOID;
 	}
 
-
-	acpi_ut_acquire_mutex (ACPI_MTX_TABLES);
-
-	/* Free the table */
-
-	acpi_tb_free_acpi_tables_of_type (&acpi_gbl_acpi_tables[type]);
-
+	if (ACPI_FAILURE (acpi_ut_acquire_mutex (ACPI_MTX_TABLES))) {
+		return;
+	}
 
 	/* Clear the appropriate "typed" global table pointer */
 
@@ -380,41 +407,11 @@ acpi_tb_delete_acpi_table (
 		break;
 	}
 
-	acpi_ut_release_mutex (ACPI_MTX_TABLES);
-
-	return_VOID;
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_tb_free_acpi_tables_of_type
- *
- * PARAMETERS:  Table_info          - A table info struct
- *
- * RETURN:      None.
- *
- * DESCRIPTION: Free the memory associated with an internal ACPI table
- *              Table mutex should be locked.
- *
- ******************************************************************************/
-
-void
-acpi_tb_free_acpi_tables_of_type (
-	acpi_table_desc         *list_head)
-{
-	acpi_table_desc         *table_desc;
-	u32                     count;
-	u32                     i;
-
-
-	FUNCTION_TRACE_PTR ("Tb_free_acpi_tables_of_type", list_head);
-
-
+	/* Free the table */
 	/* Get the head of the list */
 
-	table_desc  = list_head;
-	count       = list_head->count;
+	table_desc = acpi_gbl_table_lists[type].next;
+	count     = acpi_gbl_table_lists[type].count;
 
 	/*
 	 * Walk the entire list, deleting both the allocated tables
@@ -424,15 +421,16 @@ acpi_tb_free_acpi_tables_of_type (
 		table_desc = acpi_tb_uninstall_table (table_desc);
 	}
 
+	(void) acpi_ut_release_mutex (ACPI_MTX_TABLES);
 	return_VOID;
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_tb_delete_single_table
+ * FUNCTION:    acpi_tb_delete_single_table
  *
- * PARAMETERS:  Table_info          - A table info struct
+ * PARAMETERS:  table_info          - A table info struct
  *
  * RETURN:      None.
  *
@@ -443,44 +441,45 @@ acpi_tb_free_acpi_tables_of_type (
 
 void
 acpi_tb_delete_single_table (
-	acpi_table_desc         *table_desc)
+	struct acpi_table_desc          *table_desc)
 {
 
-	if (!table_desc) {
+	/* Must have a valid table descriptor and pointer */
+
+	if ((!table_desc) ||
+		 (!table_desc->pointer)) {
 		return;
 	}
 
-	if (table_desc->pointer) {
-		/* Valid table, determine type of memory allocation */
-
-		switch (table_desc->allocation) {
-
-		case ACPI_MEM_NOT_ALLOCATED:
-			break;
+	/* Valid table, determine type of memory allocation */
 
+	switch (table_desc->allocation) {
+	case ACPI_MEM_NOT_ALLOCATED:
+		break;
 
-		case ACPI_MEM_ALLOCATED:
+	case ACPI_MEM_ALLOCATED:
 
-			ACPI_MEM_FREE (table_desc->base_pointer);
-			break;
+		ACPI_MEM_FREE (table_desc->pointer);
+		break;
 
+	case ACPI_MEM_MAPPED:
 
-		case ACPI_MEM_MAPPED:
+		acpi_os_unmap_memory (table_desc->pointer, table_desc->length);
+		break;
 
-			acpi_os_unmap_memory (table_desc->base_pointer, table_desc->length);
-			break;
-		}
+	default:
+		break;
 	}
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_tb_uninstall_table
+ * FUNCTION:    acpi_tb_uninstall_table
  *
- * PARAMETERS:  Table_info          - A table info struct
+ * PARAMETERS:  table_info          - A table info struct
  *
- * RETURN:      None.
+ * RETURN:      Pointer to the next table in the list (of same type)
  *
  * DESCRIPTION: Free the memory associated with an internal ACPI table that
  *              is either installed or has never been installed.
@@ -488,58 +487,45 @@ acpi_tb_delete_single_table (
  *
  ******************************************************************************/
 
-acpi_table_desc *
+struct acpi_table_desc *
 acpi_tb_uninstall_table (
-	acpi_table_desc         *table_desc)
+	struct acpi_table_desc          *table_desc)
 {
-	acpi_table_desc         *next_desc;
+	struct acpi_table_desc          *next_desc;
 
 
-	FUNCTION_TRACE_PTR ("Tb_delete_single_table", table_desc);
+	ACPI_FUNCTION_TRACE_PTR ("tb_uninstall_table", table_desc);
 
 
 	if (!table_desc) {
 		return_PTR (NULL);
 	}
 
-
-	/* Unlink the descriptor */
+	/* Unlink the descriptor from the doubly linked list */
 
 	if (table_desc->prev) {
 		table_desc->prev->next = table_desc->next;
 	}
+	else {
+		/* Is first on list, update list head */
+
+		acpi_gbl_table_lists[table_desc->type].next = table_desc->next;
+	}
 
 	if (table_desc->next) {
 		table_desc->next->prev = table_desc->prev;
 	}
 
-
 	/* Free the memory allocated for the table itself */
 
 	acpi_tb_delete_single_table (table_desc);
 
+	/* Free the table descriptor */
 
-	/* Free the table descriptor (Don't delete the list head, tho) */
-
-	if ((table_desc->prev) == (table_desc->next)) {
-
-		next_desc = NULL;
-
-		/* Clear the list head */
-
-		table_desc->pointer  = NULL;
-		table_desc->length   = 0;
-		table_desc->count    = 0;
-
-	}
-
-	else {
-		/* Free the table descriptor */
-
-		next_desc = table_desc->next;
-		ACPI_MEM_FREE (table_desc);
-	}
+	next_desc = table_desc->next;
+	ACPI_MEM_FREE (table_desc);
 
+	/* Return pointer to the next descriptor */
 
 	return_PTR (next_desc);
 }
diff -urNp linux-5400/drivers/acpi/tables/tbrsdt.c linux-5410/drivers/acpi/tables/tbrsdt.c
--- linux-5400/drivers/acpi/tables/tbrsdt.c
+++ linux-5410/drivers/acpi/tables/tbrsdt.c
@@ -0,0 +1,315 @@
+/******************************************************************************
+ *
+ * Module Name: tbrsdt - ACPI RSDT table utilities
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+
+#include <acpi/acpi.h>
+#include <acpi/actables.h>
+
+
+#define _COMPONENT          ACPI_TABLES
+	 ACPI_MODULE_NAME    ("tbrsdt")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_verify_rsdp
+ *
+ * PARAMETERS:  Address         - RSDP (Pointer to RSDT)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Load and validate the RSDP (ptr) and RSDT (table)
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_tb_verify_rsdp (
+	struct acpi_pointer             *address)
+{
+	struct acpi_table_desc          table_info;
+	acpi_status                     status;
+	struct rsdp_descriptor          *rsdp;
+
+
+	ACPI_FUNCTION_TRACE ("tb_verify_rsdp");
+
+
+	switch (address->pointer_type) {
+	case ACPI_LOGICAL_POINTER:
+
+		rsdp = address->pointer.logical;
+		break;
+
+	case ACPI_PHYSICAL_POINTER:
+		/*
+		 * Obtain access to the RSDP structure
+		 */
+		status = acpi_os_map_memory (address->pointer.physical, sizeof (struct rsdp_descriptor),
+				  (void **) &rsdp);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
+		break;
+
+	default:
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
+
+	/*
+	 *  The signature and checksum must both be correct
+	 */
+	if (ACPI_STRNCMP ((char *) rsdp, RSDP_SIG, sizeof (RSDP_SIG)-1) != 0) {
+		/* Nope, BAD Signature */
+
+		status = AE_BAD_SIGNATURE;
+		goto cleanup;
+	}
+
+	/* Check the standard checksum */
+
+	if (acpi_tb_checksum (rsdp, ACPI_RSDP_CHECKSUM_LENGTH) != 0) {
+		status = AE_BAD_CHECKSUM;
+		goto cleanup;
+	}
+
+	/* Check extended checksum if table version >= 2 */
+
+	if (rsdp->revision >= 2) {
+		if (acpi_tb_checksum (rsdp, ACPI_RSDP_XCHECKSUM_LENGTH) != 0) {
+			status = AE_BAD_CHECKSUM;
+			goto cleanup;
+		}
+	}
+
+	/* The RSDP supplied is OK */
+
+	table_info.pointer     = ACPI_CAST_PTR (struct acpi_table_header, rsdp);
+	table_info.length      = sizeof (struct rsdp_descriptor);
+	table_info.allocation  = ACPI_MEM_MAPPED;
+
+	/* Save the table pointers and allocation info */
+
+	status = acpi_tb_init_table_descriptor (ACPI_TABLE_RSDP, &table_info);
+	if (ACPI_FAILURE (status)) {
+		goto cleanup;
+	}
+
+	/* Save the RSDP in a global for easy access */
+
+	acpi_gbl_RSDP = ACPI_CAST_PTR (struct rsdp_descriptor, table_info.pointer);
+	return_ACPI_STATUS (status);
+
+
+	/* Error exit */
+cleanup:
+
+	if (acpi_gbl_table_flags & ACPI_PHYSICAL_POINTER) {
+		acpi_os_unmap_memory (rsdp, sizeof (struct rsdp_descriptor));
+	}
+	return_ACPI_STATUS (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_get_rsdt_address
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      RSDT physical address
+ *
+ * DESCRIPTION: Extract the address of the RSDT or XSDT, depending on the
+ *              version of the RSDP
+ *
+ ******************************************************************************/
+
+void
+acpi_tb_get_rsdt_address (
+	struct acpi_pointer             *out_address)
+{
+
+	ACPI_FUNCTION_ENTRY ();
+
+
+	out_address->pointer_type = acpi_gbl_table_flags | ACPI_LOGICAL_ADDRESSING;
+
+	/*
+	 * For RSDP revision 0 or 1, we use the RSDT.
+	 * For RSDP revision 2 (and above), we use the XSDT
+	 */
+	if (acpi_gbl_RSDP->revision < 2) {
+		out_address->pointer.value = acpi_gbl_RSDP->rsdt_physical_address;
+	}
+	else {
+		out_address->pointer.value = acpi_gbl_RSDP->xsdt_physical_address;
+	}
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_validate_rsdt
+ *
+ * PARAMETERS:  table_ptr       - Addressable pointer to the RSDT.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Validate signature for the RSDT or XSDT
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_tb_validate_rsdt (
+	struct acpi_table_header        *table_ptr)
+{
+	int                             no_match;
+
+
+	ACPI_FUNCTION_NAME ("tb_validate_rsdt");
+
+
+	/*
+	 * For RSDP revision 0 or 1, we use the RSDT.
+	 * For RSDP revision 2 and above, we use the XSDT
+	 */
+	if (acpi_gbl_RSDP->revision < 2) {
+		no_match = ACPI_STRNCMP ((char *) table_ptr, RSDT_SIG,
+				  sizeof (RSDT_SIG) -1);
+	}
+	else {
+		no_match = ACPI_STRNCMP ((char *) table_ptr, XSDT_SIG,
+				  sizeof (XSDT_SIG) -1);
+	}
+
+	if (no_match) {
+		/* Invalid RSDT or XSDT signature */
+
+		ACPI_REPORT_ERROR (("Invalid signature where RSDP indicates RSDT/XSDT should be located\n"));
+
+		ACPI_DUMP_BUFFER (acpi_gbl_RSDP, 20);
+
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_ERROR,
+			"RSDT/XSDT signature at %X (%p) is invalid\n",
+			acpi_gbl_RSDP->rsdt_physical_address,
+			(void *) (acpi_native_uint) acpi_gbl_RSDP->rsdt_physical_address));
+
+		return (AE_BAD_SIGNATURE);
+	}
+
+	return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_get_table_rsdt
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Load and validate the RSDP (ptr) and RSDT (table)
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_tb_get_table_rsdt (
+	void)
+{
+	struct acpi_table_desc          table_info;
+	acpi_status                     status;
+	struct acpi_pointer             address;
+
+
+	ACPI_FUNCTION_TRACE ("tb_get_table_rsdt");
+
+
+	/* Get the RSDT/XSDT via the RSDP */
+
+	acpi_tb_get_rsdt_address (&address);
+
+	status = acpi_tb_get_table (&address, &table_info);
+	if (ACPI_FAILURE (status)) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not get the RSDT/XSDT, %s\n",
+			acpi_format_exception (status)));
+		return_ACPI_STATUS (status);
+	}
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+		"RSDP located at %p, points to RSDT physical=%8.8X%8.8X \n",
+		acpi_gbl_RSDP,
+		ACPI_HIDWORD (address.pointer.value),
+		ACPI_LODWORD (address.pointer.value)));
+
+	/* Check the RSDT or XSDT signature */
+
+	status = acpi_tb_validate_rsdt (table_info.pointer);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/* Get the number of tables defined in the RSDT or XSDT */
+
+	acpi_gbl_rsdt_table_count = acpi_tb_get_table_count (acpi_gbl_RSDP, table_info.pointer);
+
+	/* Convert and/or copy to an XSDT structure */
+
+	status = acpi_tb_convert_to_xsdt (&table_info);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/* Save the table pointers and allocation info */
+
+	status = acpi_tb_init_table_descriptor (ACPI_TABLE_XSDT, &table_info);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	acpi_gbl_XSDT = (XSDT_DESCRIPTOR *) table_info.pointer;
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "XSDT located at %p\n", acpi_gbl_XSDT));
+	return_ACPI_STATUS (status);
+}
+
+
diff -urNp linux-5400/drivers/acpi/tables/tbutils.c linux-5410/drivers/acpi/tables/tbutils.c
--- linux-5400/drivers/acpi/tables/tbutils.c
+++ linux-5410/drivers/acpi/tables/tbutils.c
@@ -1,162 +1,102 @@
 /******************************************************************************
  *
  * Module Name: tbutils - Table manipulation utilities
- *              $Revision: 42 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "actables.h"
-#include "acinterp.h"
+#include <acpi/acpi.h>
+#include <acpi/actables.h>
 
 
 #define _COMPONENT          ACPI_TABLES
-	 MODULE_NAME         ("tbutils")
+	 ACPI_MODULE_NAME    ("tbutils")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_tb_handle_to_object
+ * FUNCTION:    acpi_tb_handle_to_object
  *
- * PARAMETERS:  Table_id            - Id for which the function is searching
- *              Table_desc          - Pointer to return the matching table
+ * PARAMETERS:  table_id            - Id for which the function is searching
+ *              table_desc          - Pointer to return the matching table
  *                                      descriptor.
  *
- * RETURN:      Search the tables to find one with a matching Table_id and
+ * RETURN:      Search the tables to find one with a matching table_id and
  *              return a pointer to that table descriptor.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_tb_handle_to_object (
-	u16                     table_id,
-	acpi_table_desc         **table_desc)
+	u16                             table_id,
+	struct acpi_table_desc          **return_table_desc)
 {
-	u32                     i;
-	acpi_table_desc         *list_head;
+	u32                             i;
+	struct acpi_table_desc          *table_desc;
 
 
-	PROC_NAME ("Tb_handle_to_object");
+	ACPI_FUNCTION_NAME ("tb_handle_to_object");
 
 
 	for (i = 0; i < ACPI_TABLE_MAX; i++) {
-		list_head = &acpi_gbl_acpi_tables[i];
-		do {
-			if (list_head->table_id == table_id) {
-				*table_desc = list_head;
+		table_desc = acpi_gbl_table_lists[i].next;
+		while (table_desc) {
+			if (table_desc->table_id == table_id) {
+				*return_table_desc = table_desc;
 				return (AE_OK);
 			}
 
-			list_head = list_head->next;
-
-		} while (list_head != &acpi_gbl_acpi_tables[i]);
-	}
-
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Table_id=%X does not exist\n", table_id));
-	return (AE_BAD_PARAMETER);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_tb_system_table_pointer
- *
- * PARAMETERS:  *Where              - Pointer to be examined
- *
- * RETURN:      TRUE if Where is within the AML stream (in one of the ACPI
- *              system tables such as the DSDT or an SSDT.)
- *              FALSE otherwise
- *
- ******************************************************************************/
-
-u8
-acpi_tb_system_table_pointer (
-	void                    *where)
-{
-	u32                     i;
-	acpi_table_desc         *table_desc;
-	acpi_table_header       *table;
-
-
-	/* No function trace, called too often! */
-
-
-	/* Ignore null pointer */
-
-	if (!where) {
-		return (FALSE);
-	}
-
-
-	/* Check for a pointer within the DSDT */
-
-	if ((acpi_gbl_DSDT) &&
-		(IS_IN_ACPI_TABLE (where, acpi_gbl_DSDT))) {
-		return (TRUE);
-	}
-
-
-	/* Check each of the loaded SSDTs (if any)*/
-
-	table_desc = &acpi_gbl_acpi_tables[ACPI_TABLE_SSDT];
-
-	for (i = 0; i < acpi_gbl_acpi_tables[ACPI_TABLE_SSDT].count; i++) {
-		table = table_desc->pointer;
-
-		if (IS_IN_ACPI_TABLE (where, table)) {
-			return (TRUE);
+			table_desc = table_desc->next;
 		}
-
-		table_desc = table_desc->next;
 	}
 
-
-	/* Check each of the loaded PSDTs (if any)*/
-
-	table_desc = &acpi_gbl_acpi_tables[ACPI_TABLE_PSDT];
-
-	for (i = 0; i < acpi_gbl_acpi_tables[ACPI_TABLE_PSDT].count; i++) {
-		table = table_desc->pointer;
-
-		if (IS_IN_ACPI_TABLE (where, table)) {
-			return (TRUE);
-		}
-
-		table_desc = table_desc->next;
-	}
-
-
-	/* Pointer does not point into any system table */
-
-	return (FALSE);
+	ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "table_id=%X does not exist\n", table_id));
+	return (AE_BAD_PARAMETER);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_tb_validate_table_header
+ * FUNCTION:    acpi_tb_validate_table_header
  *
- * PARAMETERS:  Table_header        - Logical pointer to the table
+ * PARAMETERS:  table_header        - Logical pointer to the table
  *
  * RETURN:      Status
  *
@@ -168,52 +108,52 @@ acpi_tb_system_table_pointer (
  *             name
  *          3) Table must be readable for length specified in the header
  *          4) Table checksum must be valid (with the exception of the FACS
- *              which has no checksum for some odd reason)
+ *              which has no checksum because it contains variable fields)
  *
  ******************************************************************************/
 
 acpi_status
 acpi_tb_validate_table_header (
-	acpi_table_header       *table_header)
+	struct acpi_table_header        *table_header)
 {
-	acpi_name               signature;
+	acpi_name                       signature;
 
 
-	PROC_NAME ("Tb_validate_table_header");
+	ACPI_FUNCTION_NAME ("tb_validate_table_header");
 
 
 	/* Verify that this is a valid address */
 
-	if (!acpi_os_readable (table_header, sizeof (acpi_table_header))) {
+	if (!acpi_os_readable (table_header, sizeof (struct acpi_table_header))) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"Cannot read table header at %p\n", table_header));
 		return (AE_BAD_ADDRESS);
 	}
 
-
 	/* Ensure that the signature is 4 ASCII characters */
 
-	MOVE_UNALIGNED32_TO_32 (&signature, &table_header->signature);
+	ACPI_MOVE_32_TO_32 (&signature, table_header->signature);
 	if (!acpi_ut_valid_acpi_name (signature)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"Table signature at %p [%p] has invalid characters\n",
 			table_header, &signature));
 
-		REPORT_WARNING (("Invalid table signature %4.4s found\n", (char*)&signature));
-		DUMP_BUFFER (table_header, sizeof (acpi_table_header));
+		ACPI_REPORT_WARNING (("Invalid table signature found: [%4.4s]\n",
+			(char *) &signature));
+		ACPI_DUMP_BUFFER (table_header, sizeof (struct acpi_table_header));
 		return (AE_BAD_SIGNATURE);
 	}
 
-
 	/* Validate the table length */
 
-	if (table_header->length < sizeof (acpi_table_header)) {
+	if (table_header->length < sizeof (struct acpi_table_header)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"Invalid length in table header %p name %4.4s\n",
-			table_header, (char*)&signature));
+			table_header, (char *) &signature));
 
-		REPORT_WARNING (("Invalid table header length found\n"));
-		DUMP_BUFFER (table_header, sizeof (acpi_table_header));
+		ACPI_REPORT_WARNING (("Invalid table header length (0x%X) found\n",
+			(u32) table_header->length));
+		ACPI_DUMP_BUFFER (table_header, sizeof (struct acpi_table_header));
 		return (AE_BAD_HEADER);
 	}
 
@@ -223,90 +163,9 @@ acpi_tb_validate_table_header (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_tb_map_acpi_table
- *
- * PARAMETERS:  Physical_address        - Physical address of table to map
- *              *Size                   - Size of the table.  If zero, the size
- *                                        from the table header is used.
- *                                        Actual size is returned here.
- *              **Logical_address       - Logical address of mapped table
- *
- * RETURN:      Logical address of the mapped table.
- *
- * DESCRIPTION: Maps the physical address of table into a logical address
- *
- ******************************************************************************/
-
-acpi_status
-acpi_tb_map_acpi_table (
-	ACPI_PHYSICAL_ADDRESS   physical_address,
-	u32                     *size,
-	acpi_table_header       **logical_address)
-{
-	acpi_table_header       *table;
-	u32                     table_size = *size;
-	acpi_status             status = AE_OK;
-
-
-	PROC_NAME ("Tb_map_acpi_table");
-
-
-	/* If size is zero, look at the table header to get the actual size */
-
-	if ((*size) == 0) {
-		/* Get the table header so we can extract the table length */
-
-		status = acpi_os_map_memory (physical_address, sizeof (acpi_table_header),
-				  (void **) &table);
-		if (ACPI_FAILURE (status)) {
-			return (status);
-		}
-
-		/* Extract the full table length before we delete the mapping */
-
-		table_size = table->length;
-
-		/*
-		 * Validate the header and delete the mapping.
-		 * We will create a mapping for the full table below.
-		 */
-		status = acpi_tb_validate_table_header (table);
-
-		/* Always unmap the memory for the header */
-
-		acpi_os_unmap_memory (table, sizeof (acpi_table_header));
-
-		/* Exit if header invalid */
-
-		if (ACPI_FAILURE (status)) {
-			return (status);
-		}
-	}
-
-
-	/* Map the physical memory for the correct length */
-
-	status = acpi_os_map_memory (physical_address, table_size, (void **) &table);
-	if (ACPI_FAILURE (status)) {
-		return (status);
-	}
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-		"Mapped memory for ACPI table, length=%d(%X) at %p\n",
-		table_size, table_size, table));
-
-	*size = table_size;
-	*logical_address = table;
-
-	return (status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_tb_verify_table_checksum
+ * FUNCTION:    acpi_tb_verify_table_checksum
  *
- * PARAMETERS:  *Table_header           - ACPI table to verify
+ * PARAMETERS:  *table_header           - ACPI table to verify
  *
  * RETURN:      8 bit checksum of table
  *
@@ -317,13 +176,13 @@ acpi_tb_map_acpi_table (
 
 acpi_status
 acpi_tb_verify_table_checksum (
-	acpi_table_header       *table_header)
+	struct acpi_table_header        *table_header)
 {
-	u8                      checksum;
-	acpi_status             status = AE_OK;
+	u8                              checksum;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE ("Tb_verify_table_checksum");
+	ACPI_FUNCTION_TRACE ("tb_verify_table_checksum");
 
 
 	/* Compute the checksum on the table */
@@ -333,20 +192,18 @@ acpi_tb_verify_table_checksum (
 	/* Return the appropriate exception */
 
 	if (checksum) {
-		REPORT_WARNING (("Invalid checksum (%X) in table %4.4s\n",
-			checksum, (char*)&table_header->signature));
+		ACPI_REPORT_WARNING (("Invalid checksum in table [%4.4s] (%02X, sum %02X is not zero)\n",
+			table_header->signature, (u32) table_header->checksum, (u32) checksum));
 
 		status = AE_BAD_CHECKSUM;
 	}
-
-
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_tb_checksum
+ * FUNCTION:    acpi_tb_checksum
  *
  * PARAMETERS:  Buffer              - Buffer to checksum
  *              Length              - Size of the buffer
@@ -359,12 +216,12 @@ acpi_tb_verify_table_checksum (
 
 u8
 acpi_tb_checksum (
-	void                    *buffer,
-	u32                     length)
+	void                            *buffer,
+	u32                             length)
 {
-	u8                      *limit;
-	u8                      *rover;
-	u8                      sum = 0;
+	const u8                        *limit;
+	const u8                        *rover;
+	u8                              sum = 0;
 
 
 	if (buffer && length) {
@@ -376,7 +233,6 @@ acpi_tb_checksum (
 			sum = (u8) (sum + *rover);
 		}
 	}
-
 	return (sum);
 }
 
diff -urNp linux-5400/drivers/acpi/tables/tbxface.c linux-5410/drivers/acpi/tables/tbxface.c
--- linux-5400/drivers/acpi/tables/tbxface.c
+++ linux-5410/drivers/acpi/tables/tbxface.c
@@ -2,42 +2,59 @@
  *
  * Module Name: tbxface - Public interfaces to the ACPI subsystem
  *                         ACPI table oriented interfaces
- *              $Revision: 45 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acnamesp.h"
-#include "acinterp.h"
-#include "actables.h"
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
+#include <acpi/actables.h>
 
 
 #define _COMPONENT          ACPI_TABLES
-	 MODULE_NAME         ("tbxface")
+	 ACPI_MODULE_NAME    ("tbxface")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_load_tables
+ * FUNCTION:    acpi_load_tables
  *
  * PARAMETERS:  None
  *
@@ -51,59 +68,60 @@
 acpi_status
 acpi_load_tables (void)
 {
-	ACPI_PHYSICAL_ADDRESS   rsdp_physical_address;
-	acpi_status             status;
-	u32                     number_of_tables = 0;
+	struct acpi_pointer             rsdp_address;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Acpi_load_tables");
+	ACPI_FUNCTION_TRACE ("acpi_load_tables");
 
 
 	/* Get the RSDP */
 
 	status = acpi_os_get_root_pointer (ACPI_LOGICAL_ADDRESSING,
-			  &rsdp_physical_address);
+			  &rsdp_address);
 	if (ACPI_FAILURE (status)) {
-		REPORT_ERROR (("Acpi_load_tables: Could not get RSDP, %s\n",
+		ACPI_REPORT_ERROR (("acpi_load_tables: Could not get RSDP, %s\n",
 				  acpi_format_exception (status)));
 		goto error_exit;
 	}
 
 	/* Map and validate the RSDP */
 
-	status = acpi_tb_verify_rsdp (rsdp_physical_address);
+	acpi_gbl_table_flags = rsdp_address.pointer_type;
+
+	status = acpi_tb_verify_rsdp (&rsdp_address);
 	if (ACPI_FAILURE (status)) {
-		REPORT_ERROR (("Acpi_load_tables: RSDP Failed validation: %s\n",
+		ACPI_REPORT_ERROR (("acpi_load_tables: RSDP Failed validation: %s\n",
 				  acpi_format_exception (status)));
 		goto error_exit;
 	}
 
 	/* Get the RSDT via the RSDP */
 
-	status = acpi_tb_get_table_rsdt (&number_of_tables);
+	status = acpi_tb_get_table_rsdt ();
 	if (ACPI_FAILURE (status)) {
-		REPORT_ERROR (("Acpi_load_tables: Could not load RSDT: %s\n",
+		ACPI_REPORT_ERROR (("acpi_load_tables: Could not load RSDT: %s\n",
 				  acpi_format_exception (status)));
 		goto error_exit;
 	}
 
-	/* Now get the rest of the tables */
+	/* Now get the tables needed by this subsystem (FADT, DSDT, etc.) */
 
-	status = acpi_tb_get_all_tables (number_of_tables, NULL);
+	status = acpi_tb_get_required_tables ();
 	if (ACPI_FAILURE (status)) {
-		REPORT_ERROR (("Acpi_load_tables: Error getting required tables (DSDT/FADT/FACS): %s\n",
+		ACPI_REPORT_ERROR (("acpi_load_tables: Error getting required tables (DSDT/FADT/FACS): %s\n",
 				  acpi_format_exception (status)));
 		goto error_exit;
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_OK, "ACPI Tables successfully loaded\n"));
+	ACPI_DEBUG_PRINT ((ACPI_DB_INIT, "ACPI Tables successfully acquired\n"));
 
 
 	/* Load the namespace from the tables */
 
 	status = acpi_ns_load_namespace ();
 	if (ACPI_FAILURE (status)) {
-		REPORT_ERROR (("Acpi_load_tables: Could not load namespace: %s\n",
+		ACPI_REPORT_ERROR (("acpi_load_tables: Could not load namespace: %s\n",
 				  acpi_format_exception (status)));
 		goto error_exit;
 	}
@@ -112,7 +130,7 @@ acpi_load_tables (void)
 
 
 error_exit:
-	REPORT_ERROR (("Acpi_load_tables: Could not load tables: %s\n",
+	ACPI_REPORT_ERROR (("acpi_load_tables: Could not load tables: %s\n",
 			  acpi_format_exception (status)));
 
 	return_ACPI_STATUS (status);
@@ -121,9 +139,9 @@ error_exit:
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_load_table
+ * FUNCTION:    acpi_load_table
  *
- * PARAMETERS:  Table_ptr       - pointer to a buffer containing the entire
+ * PARAMETERS:  table_ptr       - pointer to a buffer containing the entire
  *                                table to be loaded
  *
  * RETURN:      Status
@@ -137,13 +155,14 @@ error_exit:
 
 acpi_status
 acpi_load_table (
-	acpi_table_header       *table_ptr)
+	struct acpi_table_header        *table_ptr)
 {
-	acpi_status             status;
-	acpi_table_desc         table_info;
+	acpi_status                     status;
+	struct acpi_table_desc          table_info;
+	struct acpi_pointer             address;
 
 
-	FUNCTION_TRACE ("Acpi_load_table");
+	ACPI_FUNCTION_TRACE ("acpi_load_table");
 
 
 	if (!table_ptr) {
@@ -152,40 +171,59 @@ acpi_load_table (
 
 	/* Copy the table to a local buffer */
 
-	status = acpi_tb_get_table (0, table_ptr, &table_info);
+	address.pointer_type    = ACPI_LOGICAL_POINTER | ACPI_LOGICAL_ADDRESSING;
+	address.pointer.logical = table_ptr;
+
+	status = acpi_tb_get_table_body (&address, table_ptr, &table_info);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
 	/* Install the new table into the local data structures */
 
-	status = acpi_tb_install_table (NULL, &table_info);
+	status = acpi_tb_install_table (&table_info);
 	if (ACPI_FAILURE (status)) {
-		/* Free table allocated by Acpi_tb_get_table */
+		/* Free table allocated by acpi_tb_get_table_body */
 
 		acpi_tb_delete_single_table (&table_info);
 		return_ACPI_STATUS (status);
 	}
 
+	/* Convert the table to common format if necessary */
+
+	switch (table_info.type) {
+	case ACPI_TABLE_FADT:
+
+		status = acpi_tb_convert_table_fadt ();
+		break;
+
+	case ACPI_TABLE_FACS:
+
+		status = acpi_tb_build_common_facs (&table_info);
+		break;
+
+	default:
+		/* Load table into namespace if it contains executable AML */
+
+		status = acpi_ns_load_table (table_info.installed_desc, acpi_gbl_root_node);
+		break;
+	}
 
-	status = acpi_ns_load_table (table_info.installed_desc, acpi_gbl_root_node);
 	if (ACPI_FAILURE (status)) {
 		/* Uninstall table and free the buffer */
 
-		acpi_tb_uninstall_table (table_info.installed_desc);
-		return_ACPI_STATUS (status);
+		(void) acpi_tb_uninstall_table (table_info.installed_desc);
 	}
 
-
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_unload_table
+ * FUNCTION:    acpi_unload_table
  *
- * PARAMETERS:  Table_type    - Type of table to be unloaded
+ * PARAMETERS:  table_type    - Type of table to be unloaded
  *
  * RETURN:      Status
  *
@@ -195,12 +233,12 @@ acpi_load_table (
 
 acpi_status
 acpi_unload_table (
-	acpi_table_type         table_type)
+	acpi_table_type                 table_type)
 {
-	acpi_table_desc         *list_head;
+	struct acpi_table_desc          *table_desc;
 
 
-	FUNCTION_TRACE ("Acpi_unload_table");
+	ACPI_FUNCTION_TRACE ("acpi_unload_table");
 
 
 	/* Parameter validation */
@@ -212,39 +250,39 @@ acpi_unload_table (
 
 	/* Find all tables of the requested type */
 
-	list_head = &acpi_gbl_acpi_tables[table_type];
-	do {
+	table_desc = acpi_gbl_table_lists[table_type].next;
+	while (table_desc); {
 		/*
 		 * Delete all namespace entries owned by this table.  Note that these
 		 * entries can appear anywhere in the namespace by virtue of the AML
 		 * "Scope" operator.  Thus, we need to track ownership by an ID, not
 		 * simply a position within the hierarchy
 		 */
-		acpi_ns_delete_namespace_by_owner (list_head->table_id);
-
-		/* Delete (or unmap) the actual table */
+		acpi_ns_delete_namespace_by_owner (table_desc->table_id);
 
-		acpi_tb_delete_acpi_table (table_type);
+		table_desc = table_desc->next;
+	}
 
-	} while (list_head != &acpi_gbl_acpi_tables[table_type]);
+	/* Delete (or unmap) all tables of this type */
 
+	acpi_tb_delete_tables_by_type (table_type);
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_get_table_header
+ * FUNCTION:    acpi_get_table_header
  *
- * PARAMETERS:  Table_type      - one of the defined table types
+ * PARAMETERS:  table_type      - one of the defined table types
  *              Instance        - the non zero instance of the table, allows
  *                                support for multiple tables of the same type
- *                                see Acpi_gbl_Acpi_table_flag
- *              Out_table_header - pointer to the acpi_table_header if successful
+ *                                see acpi_gbl_acpi_table_flag
+ *              out_table_header - pointer to the struct acpi_table_header if successful
  *
  * DESCRIPTION: This function is called to get an ACPI table header.  The caller
  *              supplies an pointer to a data area sufficient to contain an ACPI
- *              acpi_table_header structure.
+ *              struct acpi_table_header structure.
  *
  *              The header contains a length field that can be used to determine
  *              the size of the buffer needed to contain the entire table.  This
@@ -255,15 +293,15 @@ acpi_unload_table (
 
 acpi_status
 acpi_get_table_header (
-	acpi_table_type         table_type,
-	u32                     instance,
-	acpi_table_header       *out_table_header)
+	acpi_table_type                 table_type,
+	u32                             instance,
+	struct acpi_table_header        *out_table_header)
 {
-	acpi_table_header       *tbl_ptr;
-	acpi_status             status;
+	struct acpi_table_header        *tbl_ptr;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Acpi_get_table_header");
+	ACPI_FUNCTION_TRACE ("acpi_get_table_header");
 
 
 	if ((instance == 0)                 ||
@@ -275,7 +313,7 @@ acpi_get_table_header (
 	/* Check the table type and instance */
 
 	if ((table_type > ACPI_TABLE_MAX)   ||
-		(IS_SINGLE_TABLE (acpi_gbl_acpi_table_data[table_type].flags) &&
+		(ACPI_IS_SINGLE_TABLE (acpi_gbl_table_data[table_type].flags) &&
 		 instance > 1)) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
@@ -298,8 +336,8 @@ acpi_get_table_header (
 	/*
 	 * Copy the header to the caller's buffer
 	 */
-	MEMCPY ((void *) out_table_header, (void *) tbl_ptr,
-			 sizeof (acpi_table_header));
+	ACPI_MEMCPY ((void *) out_table_header, (void *) tbl_ptr,
+			 sizeof (struct acpi_table_header));
 
 	return_ACPI_STATUS (status);
 }
@@ -307,54 +345,56 @@ acpi_get_table_header (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_get_table
+ * FUNCTION:    acpi_get_table
  *
- * PARAMETERS:  Table_type      - one of the defined table types
+ * PARAMETERS:  table_type      - one of the defined table types
  *              Instance        - the non zero instance of the table, allows
  *                                support for multiple tables of the same type
- *                                see Acpi_gbl_Acpi_table_flag
- *              Ret_buffer      - pointer to a structure containing a buffer to
+ *                                see acpi_gbl_acpi_table_flag
+ *              ret_buffer      - pointer to a structure containing a buffer to
  *                                receive the table
  *
  * RETURN:      Status
  *
  * DESCRIPTION: This function is called to get an ACPI table.  The caller
- *              supplies an Out_buffer large enough to contain the entire ACPI
- *              table.  The caller should call the Acpi_get_table_header function
+ *              supplies an out_buffer large enough to contain the entire ACPI
+ *              table.  The caller should call the acpi_get_table_header function
  *              first to determine the buffer size needed.  Upon completion
- *              the Out_buffer->Length field will indicate the number of bytes
- *              copied into the Out_buffer->Buf_ptr buffer. This table will be
+ *              the out_buffer->Length field will indicate the number of bytes
+ *              copied into the out_buffer->buf_ptr buffer. This table will be
  *              a complete table including the header.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_get_table (
-	acpi_table_type         table_type,
-	u32                     instance,
-	acpi_buffer             *ret_buffer)
+	acpi_table_type                 table_type,
+	u32                             instance,
+	struct acpi_buffer              *ret_buffer)
 {
-	acpi_table_header       *tbl_ptr;
-	acpi_status             status;
-	u32                     ret_buf_len;
+	struct acpi_table_header        *tbl_ptr;
+	acpi_status                     status;
+	acpi_size                       table_length;
 
 
-	FUNCTION_TRACE ("Acpi_get_table");
+	ACPI_FUNCTION_TRACE ("acpi_get_table");
 
 
-	/*
-	 *  If we have a buffer, we must have a length too
-	 */
-	if ((instance == 0)                 ||
-		(!ret_buffer)                   ||
-		((!ret_buffer->pointer) && (ret_buffer->length))) {
+	/* Parameter validation */
+
+	if (instance == 0) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
+	status = acpi_ut_validate_buffer (ret_buffer);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
 	/* Check the table type and instance */
 
 	if ((table_type > ACPI_TABLE_MAX)   ||
-		(IS_SINGLE_TABLE (acpi_gbl_acpi_table_data[table_type].flags) &&
+		(ACPI_IS_SINGLE_TABLE (acpi_gbl_table_data[table_type].flags) &&
 		 instance > 1)) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
@@ -368,38 +408,35 @@ acpi_get_table (
 	}
 
 	/*
-	 * Acpi_tb_get_table_ptr will return a NULL pointer if the
+	 * acpi_tb_get_table_ptr will return a NULL pointer if the
 	 * table is not loaded.
 	 */
 	if (tbl_ptr == NULL) {
 		return_ACPI_STATUS (AE_NOT_EXIST);
 	}
 
-	/*
-	 * Got a table ptr, assume it's ok and copy it to the user's buffer
-	 */
+	/* Get the table length */
+
 	if (table_type == ACPI_TABLE_RSDP) {
 		/*
 		 *  RSD PTR is the only "table" without a header
 		 */
-		ret_buf_len = sizeof (RSDP_DESCRIPTOR);
+		table_length = sizeof (struct rsdp_descriptor);
 	}
 	else {
-		ret_buf_len = tbl_ptr->length;
+		table_length = (acpi_size) tbl_ptr->length;
 	}
 
-	/*
-	 * Verify we have space in the caller's buffer for the table
-	 */
-	if (ret_buffer->length < ret_buf_len) {
-		ret_buffer->length = ret_buf_len;
-		return_ACPI_STATUS (AE_BUFFER_OVERFLOW);
-	}
+	/* Validate/Allocate/Clear caller buffer */
 
-	ret_buffer->length = ret_buf_len;
+	status = acpi_ut_initialize_buffer (ret_buffer, table_length);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
-	MEMCPY ((void *) ret_buffer->pointer, (void *) tbl_ptr, ret_buf_len);
+	/* Copy the table to the buffer */
 
+	ACPI_MEMCPY ((void *) ret_buffer->pointer, (void *) tbl_ptr, table_length);
 	return_ACPI_STATUS (AE_OK);
 }
 
diff -urNp linux-5400/drivers/acpi/tables/tbxfroot.c linux-5410/drivers/acpi/tables/tbxfroot.c
--- linux-5400/drivers/acpi/tables/tbxfroot.c
+++ linux-5410/drivers/acpi/tables/tbxfroot.c
@@ -1,46 +1,302 @@
 /******************************************************************************
  *
  * Module Name: tbxfroot - Find the root ACPI table (RSDT)
- *              $Revision: 52 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "achware.h"
-#include "actables.h"
+#include <acpi/acpi.h>
+#include <acpi/actables.h>
 
 
 #define _COMPONENT          ACPI_TABLES
-	 MODULE_NAME         ("tbxfroot")
+	 ACPI_MODULE_NAME    ("tbxfroot")
 
-#define RSDP_CHECKSUM_LENGTH 20
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_tb_find_table
+ *
+ * PARAMETERS:  Signature           - String with ACPI table signature
+ *              oem_id              - String with the table OEM ID
+ *              oem_table_id        - String with the OEM Table ID.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Find an ACPI table (in the RSDT/XSDT) that matches the
+ *              Signature, OEM ID and OEM Table ID.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_tb_find_table (
+	char                            *signature,
+	char                            *oem_id,
+	char                            *oem_table_id,
+	struct acpi_table_header        **table_ptr)
+{
+	acpi_status                     status;
+	struct acpi_table_header        *table;
+
+
+	ACPI_FUNCTION_TRACE ("tb_find_table");
+
+
+	/* Validate string lengths */
+
+	if ((ACPI_STRLEN (signature)  > ACPI_NAME_SIZE) ||
+		(ACPI_STRLEN (oem_id)     > sizeof (table->oem_id)) ||
+		(ACPI_STRLEN (oem_table_id) > sizeof (table->oem_table_id))) {
+		return_ACPI_STATUS (AE_AML_STRING_LIMIT);
+	}
+
+	/* Find the table */
+
+	status = acpi_get_firmware_table (signature, 1,
+			   ACPI_LOGICAL_ADDRESSING, &table);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/* Check oem_id and oem_table_id */
+
+	if ((oem_id[0]     && ACPI_STRCMP (oem_id, table->oem_id)) ||
+		(oem_table_id[0] && ACPI_STRCMP (oem_table_id, table->oem_table_id))) {
+		return_ACPI_STATUS (AE_AML_NAME_NOT_FOUND);
+	}
+
+	*table_ptr = table;
+	return_ACPI_STATUS (AE_OK);
+}
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_find_root_pointer
+ * FUNCTION:    acpi_get_firmware_table
  *
- * PARAMETERS:  **Rsdp_physical_address     - Where to place the RSDP address
- *              Flags                       - Logical/Physical addressing
+ * PARAMETERS:  Signature       - Any ACPI table signature
+ *              Instance        - the non zero instance of the table, allows
+ *                                support for multiple tables of the same type
+ *              Flags           - Physical/Virtual support
+ *              ret_buffer      - pointer to a structure containing a buffer to
+ *                                receive the table
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to get an ACPI table.  The caller
+ *              supplies an out_buffer large enough to contain the entire ACPI
+ *              table.  Upon completion
+ *              the out_buffer->Length field will indicate the number of bytes
+ *              copied into the out_buffer->buf_ptr buffer. This table will be
+ *              a complete table including the header.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_get_firmware_table (
+	acpi_string                     signature,
+	u32                             instance,
+	u32                             flags,
+	struct acpi_table_header        **table_pointer)
+{
+	struct acpi_pointer             rsdp_address;
+	struct acpi_pointer             address;
+	acpi_status                     status;
+	struct acpi_table_header        header;
+	struct acpi_table_desc          table_info;
+	struct acpi_table_desc          rsdt_info;
+	u32                             table_count;
+	u32                             i;
+	u32                             j;
+
+
+	ACPI_FUNCTION_TRACE ("acpi_get_firmware_table");
+
+
+	/*
+	 * Ensure that at least the table manager is initialized.  We don't
+	 * require that the entire ACPI subsystem is up for this interface
+	 */
+
+	/*
+	 *  If we have a buffer, we must have a length too
+	 */
+	if ((instance == 0)                 ||
+		(!signature)                    ||
+		(!table_pointer)) {
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
+
+	rsdt_info.pointer = NULL;
+
+	if (!acpi_gbl_RSDP) {
+		/* Get the RSDP */
+
+		status = acpi_os_get_root_pointer (flags, &rsdp_address);
+		if (ACPI_FAILURE (status)) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "RSDP  not found\n"));
+			return_ACPI_STATUS (AE_NO_ACPI_TABLES);
+		}
+
+		/* Map and validate the RSDP */
+
+		if ((flags & ACPI_MEMORY_MODE) == ACPI_LOGICAL_ADDRESSING) {
+			status = acpi_os_map_memory (rsdp_address.pointer.physical, sizeof (struct rsdp_descriptor),
+					  (void **) &acpi_gbl_RSDP);
+			if (ACPI_FAILURE (status)) {
+				return_ACPI_STATUS (status);
+			}
+		}
+		else {
+			acpi_gbl_RSDP = rsdp_address.pointer.logical;
+		}
+
+		/*
+		 *  The signature and checksum must both be correct
+		 */
+		if (ACPI_STRNCMP ((char *) acpi_gbl_RSDP, RSDP_SIG, sizeof (RSDP_SIG)-1) != 0) {
+			/* Nope, BAD Signature */
+
+			return_ACPI_STATUS (AE_BAD_SIGNATURE);
+		}
+
+		if (acpi_tb_checksum (acpi_gbl_RSDP, ACPI_RSDP_CHECKSUM_LENGTH) != 0) {
+			/* Nope, BAD Checksum */
+
+			return_ACPI_STATUS (AE_BAD_CHECKSUM);
+		}
+	}
+
+	/* Get the RSDT and validate it */
+
+	acpi_tb_get_rsdt_address (&address);
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+		"RSDP located at %p, RSDT physical=%8.8X%8.8X \n",
+		acpi_gbl_RSDP,
+		ACPI_HIDWORD (address.pointer.value),
+		ACPI_LODWORD (address.pointer.value)));
+
+	/* Insert processor_mode flags */
+
+	address.pointer_type |= flags;
+
+	status = acpi_tb_get_table (&address, &rsdt_info);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	status = acpi_tb_validate_rsdt (rsdt_info.pointer);
+	if (ACPI_FAILURE (status)) {
+		goto cleanup;
+	}
+
+	/* Get the number of table pointers within the RSDT */
+
+	table_count = acpi_tb_get_table_count (acpi_gbl_RSDP, rsdt_info.pointer);
+
+	address.pointer_type = acpi_gbl_table_flags | flags;
+
+	/*
+	 * Search the RSDT/XSDT for the correct instance of the
+	 * requested table
+	 */
+	for (i = 0, j = 0; i < table_count; i++) {
+		/* Get the next table pointer, handle RSDT vs. XSDT */
+
+		if (acpi_gbl_RSDP->revision < 2) {
+			address.pointer.value = ((RSDT_DESCRIPTOR *) rsdt_info.pointer)->table_offset_entry[i];
+		}
+		else {
+			address.pointer.value =
+				((XSDT_DESCRIPTOR *) rsdt_info.pointer)->table_offset_entry[i];
+		}
+
+		/* Get the table header */
+
+		status = acpi_tb_get_table_header (&address, &header);
+		if (ACPI_FAILURE (status)) {
+			goto cleanup;
+		}
+
+		/* Compare table signatures and table instance */
+
+		if (!ACPI_STRNCMP (header.signature, signature, ACPI_NAME_SIZE)) {
+			/* An instance of the table was found */
+
+			j++;
+			if (j >= instance) {
+				/* Found the correct instance, get the entire table */
+
+				status = acpi_tb_get_table_body (&address, &header, &table_info);
+				if (ACPI_FAILURE (status)) {
+					goto cleanup;
+				}
+
+				*table_pointer = table_info.pointer;
+				goto cleanup;
+			}
+		}
+	}
+
+	/* Did not find the table */
+
+	status = AE_NOT_EXIST;
+
+
+cleanup:
+	acpi_os_unmap_memory (rsdt_info.pointer, (acpi_size) rsdt_info.pointer->length);
+	return_ACPI_STATUS (status);
+}
+
+
+/* TBD: Move to a new file */
+
+#if ACPI_MACHINE_WIDTH != 16
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_find_root_pointer
+ *
+ * PARAMETERS:  **rsdp_address          - Where to place the RSDP address
+ *              Flags                   - Logical/Physical addressing
  *
  * RETURN:      Status, Physical address of the RSDP
  *
@@ -50,35 +306,36 @@
 
 acpi_status
 acpi_find_root_pointer (
-	u32                     flags,
-	ACPI_PHYSICAL_ADDRESS   *rsdp_physical_address)
+	u32                             flags,
+	struct acpi_pointer             *rsdp_address)
 {
-	acpi_table_desc         table_info;
-	acpi_status             status;
+	struct acpi_table_desc          table_info;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Acpi_find_root_pointer");
+	ACPI_FUNCTION_TRACE ("acpi_find_root_pointer");
 
 
 	/* Get the RSDP */
 
 	status = acpi_tb_find_rsdp (&table_info, flags);
 	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "RSDP structure not found\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "RSDP structure not found, %s Flags=%X\n",
+			acpi_format_exception (status), flags));
 		return_ACPI_STATUS (AE_NO_ACPI_TABLES);
 	}
 
-	*rsdp_physical_address = table_info.physical_address;
-
+	rsdp_address->pointer_type = ACPI_PHYSICAL_POINTER;
+	rsdp_address->pointer.physical = table_info.physical_address;
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_tb_scan_memory_for_rsdp
+ * FUNCTION:    acpi_tb_scan_memory_for_rsdp
  *
- * PARAMETERS:  Start_address       - Starting pointer for search
+ * PARAMETERS:  start_address       - Starting pointer for search
  *              Length              - Maximum length to search
  *
  * RETURN:      Pointer to the RSDP if found, otherwise NULL.
@@ -89,27 +346,27 @@ acpi_find_root_pointer (
 
 u8 *
 acpi_tb_scan_memory_for_rsdp (
-	u8                      *start_address,
-	u32                     length)
+	u8                              *start_address,
+	u32                             length)
 {
-	u32                     offset;
-	u8                      *mem_rover;
+	u32                             offset;
+	u8                              *mem_rover;
 
 
-	FUNCTION_TRACE ("Tb_scan_memory_for_rsdp");
+	ACPI_FUNCTION_TRACE ("tb_scan_memory_for_rsdp");
 
 
 	/* Search from given start addr for the requested length  */
 
 	for (offset = 0, mem_rover = start_address;
 		 offset < length;
-		 offset += RSDP_SCAN_STEP, mem_rover += RSDP_SCAN_STEP) {
+		 offset += ACPI_RSDP_SCAN_STEP, mem_rover += ACPI_RSDP_SCAN_STEP) {
 
 		/* The signature and checksum must both be correct */
 
-		if (STRNCMP ((NATIVE_CHAR *) mem_rover,
+		if (ACPI_STRNCMP ((char *) mem_rover,
 				RSDP_SIG, sizeof (RSDP_SIG)-1) == 0 &&
-			acpi_tb_checksum (mem_rover, RSDP_CHECKSUM_LENGTH) == 0) {
+			acpi_tb_checksum (mem_rover, ACPI_RSDP_CHECKSUM_LENGTH) == 0) {
 			/* If so, we have found the RSDP */
 
 			ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
@@ -121,25 +378,24 @@ acpi_tb_scan_memory_for_rsdp (
 	/* Searched entire block, no RSDP was found */
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,"Searched entire block, no RSDP was found.\n"));
-
 	return_PTR (NULL);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_tb_find_rsdp
+ * FUNCTION:    acpi_tb_find_rsdp
  *
- * PARAMETERS:  *Table_info             - Where the table info is returned
+ * PARAMETERS:  *table_info             - Where the table info is returned
  *              Flags                   - Current memory mode (logical vs.
  *                                        physical addressing)
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Search lower 1_mbyte of memory for the root system descriptor
+ * DESCRIPTION: search lower 1_mbyte of memory for the root system descriptor
  *              pointer structure.  If it is found, set *RSDP to point to it.
  *
- *              NOTE: The RSDP must be either in the first 1_k of the Extended
+ *              NOTE: The RSDp must be either in the first 1_k of the Extended
  *              BIOS Data Area or between E0000 and FFFFF (ACPI 1.0 section
  *              5.2.2; assertion #421).
  *
@@ -147,16 +403,16 @@ acpi_tb_scan_memory_for_rsdp (
 
 acpi_status
 acpi_tb_find_rsdp (
-	acpi_table_desc         *table_info,
-	u32                     flags)
+	struct acpi_table_desc          *table_info,
+	u32                             flags)
 {
-	u8                      *table_ptr;
-	u8                      *mem_rover;
-	u64                     phys_addr;
-	acpi_status             status = AE_OK;
+	u8                              *table_ptr;
+	u8                              *mem_rover;
+	u64                             phys_addr;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE ("Tb_find_rsdp");
+	ACPI_FUNCTION_TRACE ("tb_find_rsdp");
 
 
 	/*
@@ -166,51 +422,52 @@ acpi_tb_find_rsdp (
 		/*
 		 * 1) Search EBDA (low memory) paragraphs
 		 */
-		status = acpi_os_map_memory (LO_RSDP_WINDOW_BASE, LO_RSDP_WINDOW_SIZE,
+		status = acpi_os_map_memory ((u64) ACPI_LO_RSDP_WINDOW_BASE, ACPI_LO_RSDP_WINDOW_SIZE,
 				  (void **) &table_ptr);
 		if (ACPI_FAILURE (status)) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not map memory at %X for length %X\n",
+				ACPI_LO_RSDP_WINDOW_BASE, ACPI_LO_RSDP_WINDOW_SIZE));
 			return_ACPI_STATUS (status);
 		}
 
-		mem_rover = acpi_tb_scan_memory_for_rsdp (table_ptr, LO_RSDP_WINDOW_SIZE);
-		acpi_os_unmap_memory (table_ptr, LO_RSDP_WINDOW_SIZE);
+		mem_rover = acpi_tb_scan_memory_for_rsdp (table_ptr, ACPI_LO_RSDP_WINDOW_SIZE);
+		acpi_os_unmap_memory (table_ptr, ACPI_LO_RSDP_WINDOW_SIZE);
 
 		if (mem_rover) {
 			/* Found it, return the physical address */
 
-			phys_addr = LO_RSDP_WINDOW_BASE;
-			phys_addr += (mem_rover - table_ptr);
+			phys_addr = ACPI_LO_RSDP_WINDOW_BASE;
+			phys_addr += ACPI_PTR_DIFF (mem_rover,table_ptr);
 
 			table_info->physical_address = phys_addr;
-
 			return_ACPI_STATUS (AE_OK);
 		}
 
 		/*
 		 * 2) Search upper memory: 16-byte boundaries in E0000h-F0000h
 		 */
-		status = acpi_os_map_memory (HI_RSDP_WINDOW_BASE, HI_RSDP_WINDOW_SIZE,
+		status = acpi_os_map_memory ((u64) ACPI_HI_RSDP_WINDOW_BASE, ACPI_HI_RSDP_WINDOW_SIZE,
 				  (void **) &table_ptr);
 		if (ACPI_FAILURE (status)) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not map memory at %X for length %X\n",
+				ACPI_HI_RSDP_WINDOW_BASE, ACPI_HI_RSDP_WINDOW_SIZE));
 			return_ACPI_STATUS (status);
 		}
 
-		mem_rover = acpi_tb_scan_memory_for_rsdp (table_ptr, HI_RSDP_WINDOW_SIZE);
-		acpi_os_unmap_memory (table_ptr, HI_RSDP_WINDOW_SIZE);
+		mem_rover = acpi_tb_scan_memory_for_rsdp (table_ptr, ACPI_HI_RSDP_WINDOW_SIZE);
+		acpi_os_unmap_memory (table_ptr, ACPI_HI_RSDP_WINDOW_SIZE);
 
 		if (mem_rover) {
 			/* Found it, return the physical address */
 
-			phys_addr = HI_RSDP_WINDOW_BASE;
-			phys_addr += (mem_rover - table_ptr);
+			phys_addr = ACPI_HI_RSDP_WINDOW_BASE;
+			phys_addr += ACPI_PTR_DIFF (mem_rover, table_ptr);
 
 			table_info->physical_address = phys_addr;
-
 			return_ACPI_STATUS (AE_OK);
 		}
 	}
 
-
 	/*
 	 * Physical addressing
 	 */
@@ -218,212 +475,32 @@ acpi_tb_find_rsdp (
 		/*
 		 * 1) Search EBDA (low memory) paragraphs
 		 */
-		mem_rover = acpi_tb_scan_memory_for_rsdp ((u8 *) LO_RSDP_WINDOW_BASE,
-				  LO_RSDP_WINDOW_SIZE);
+		mem_rover = acpi_tb_scan_memory_for_rsdp (ACPI_PHYSADDR_TO_PTR (ACPI_LO_RSDP_WINDOW_BASE),
+				  ACPI_LO_RSDP_WINDOW_SIZE);
 		if (mem_rover) {
 			/* Found it, return the physical address */
 
-			table_info->physical_address = (ACPI_TBLPTR) mem_rover;
+			table_info->physical_address = ACPI_TO_INTEGER (mem_rover);
 			return_ACPI_STATUS (AE_OK);
 		}
 
 		/*
 		 * 2) Search upper memory: 16-byte boundaries in E0000h-F0000h
 		 */
-		mem_rover = acpi_tb_scan_memory_for_rsdp ((u8 *) HI_RSDP_WINDOW_BASE,
-				  HI_RSDP_WINDOW_SIZE);
+		mem_rover = acpi_tb_scan_memory_for_rsdp (ACPI_PHYSADDR_TO_PTR (ACPI_HI_RSDP_WINDOW_BASE),
+				  ACPI_HI_RSDP_WINDOW_SIZE);
 		if (mem_rover) {
 			/* Found it, return the physical address */
 
-			table_info->physical_address = (ACPI_TBLPTR) mem_rover;
+			table_info->physical_address = ACPI_TO_INTEGER (mem_rover);
 			return_ACPI_STATUS (AE_OK);
 		}
 	}
 
-
 	/* RSDP signature was not found */
 
 	return_ACPI_STATUS (AE_NOT_FOUND);
 }
 
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_get_firmware_table
- *
- * PARAMETERS:  Signature       - Any ACPI table signature
- *              Instance        - the non zero instance of the table, allows
- *                                support for multiple tables of the same type
- *              Flags           - 0: Physical/Virtual support
- *              Ret_buffer      - pointer to a structure containing a buffer to
- *                                receive the table
- *
- * RETURN:      Status
- *
- * DESCRIPTION: This function is called to get an ACPI table.  The caller
- *              supplies an Out_buffer large enough to contain the entire ACPI
- *              table.  Upon completion
- *              the Out_buffer->Length field will indicate the number of bytes
- *              copied into the Out_buffer->Buf_ptr buffer. This table will be
- *              a complete table including the header.
- *
- ******************************************************************************/
-
-acpi_status
-acpi_get_firmware_table (
-	acpi_string             signature,
-	u32                     instance,
-	u32                     flags,
-	acpi_table_header       **table_pointer)
-{
-	ACPI_PHYSICAL_ADDRESS   physical_address;
-	acpi_table_header       *rsdt_ptr = NULL;
-	acpi_table_header       *table_ptr;
-	acpi_status             status;
-	u32                     rsdt_size = 0;
-	u32                     table_size;
-	u32                     table_count;
-	u32                     i;
-	u32                     j;
-
-
-	FUNCTION_TRACE ("Acpi_get_firmware_table");
-
-
-	/*
-	 * Ensure that at least the table manager is initialized.  We don't
-	 * require that the entire ACPI subsystem is up for this interface
-	 */
-
-	/*
-	 *  If we have a buffer, we must have a length too
-	 */
-	if ((instance == 0)                 ||
-		(!signature)                    ||
-		(!table_pointer)) {
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
-	}
-
-	if (!acpi_gbl_RSDP) {
-		/* Get the RSDP */
-
-		status = acpi_os_get_root_pointer (flags, &physical_address);
-		if (ACPI_FAILURE (status)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "RSDP  not found\n"));
-			return_ACPI_STATUS (AE_NO_ACPI_TABLES);
-		}
-
-		/* Map and validate the RSDP */
-
-		if ((flags & ACPI_MEMORY_MODE) == ACPI_LOGICAL_ADDRESSING) {
-			status = acpi_os_map_memory (physical_address, sizeof (RSDP_DESCRIPTOR),
-					  (void **) &acpi_gbl_RSDP);
-			if (ACPI_FAILURE (status)) {
-				return_ACPI_STATUS (status);
-			}
-		}
-		else {
-			acpi_gbl_RSDP = (void *) (NATIVE_UINT) physical_address;
-		}
-
-		/*
-		 *  The signature and checksum must both be correct
-		 */
-		if (STRNCMP ((NATIVE_CHAR *) acpi_gbl_RSDP, RSDP_SIG, sizeof (RSDP_SIG)-1) != 0) {
-			/* Nope, BAD Signature */
-
-			status = AE_BAD_SIGNATURE;
-			goto cleanup;
-		}
-
-		if (acpi_tb_checksum (acpi_gbl_RSDP, RSDP_CHECKSUM_LENGTH) != 0) {
-			/* Nope, BAD Checksum */
-
-			status = AE_BAD_CHECKSUM;
-			goto cleanup;
-		}
-	}
-
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-		"RSDP located at %p, RSDT physical=%8.8X%8.8X \n",
-		acpi_gbl_RSDP, HIDWORD(acpi_gbl_RSDP->rsdt_physical_address),
-		LODWORD(acpi_gbl_RSDP->rsdt_physical_address)));
-
-
-	/* Get the RSDT and validate it */
-
-	physical_address = acpi_tb_get_rsdt_address ();
-	status = acpi_tb_get_table_pointer (physical_address, flags, &rsdt_size, &rsdt_ptr);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
-
-	status = acpi_tb_validate_rsdt (rsdt_ptr);
-	if (ACPI_FAILURE (status)) {
-		goto cleanup;
-	}
-
-
-	/* Get the number of table pointers within the RSDT */
-
-	table_count = acpi_tb_get_table_count (acpi_gbl_RSDP, rsdt_ptr);
-
-
-	/*
-	 * Search the RSDT/XSDT for the correct instance of the
-	 * requested table
-	 */
-	for (i = 0, j = 0; i < table_count; i++) {
-		/* Get the next table pointer */
-
-		if (acpi_gbl_RSDP->revision < 2) {
-			physical_address = ((RSDT_DESCRIPTOR *) rsdt_ptr)->table_offset_entry[i];
-		}
-		else {
-			physical_address = (ACPI_PHYSICAL_ADDRESS)
-				ACPI_GET_ADDRESS (((xsdt_descriptor *) rsdt_ptr)->table_offset_entry[i]);
-		}
-
-		/* Get addressibility if necessary */
-
-		status = acpi_tb_get_table_pointer (physical_address, flags, &table_size, &table_ptr);
-		if (ACPI_FAILURE (status)) {
-			goto cleanup;
-		}
-
-		/* Compare table signatures and table instance */
-
-		if (!STRNCMP ((char *) table_ptr, signature, STRLEN (signature))) {
-			/* An instance of the table was found */
-
-			j++;
-			if (j >= instance) {
-				/* Found the correct instance */
-
-				*table_pointer = table_ptr;
-				goto cleanup;
-			}
-		}
-
-		/* Delete table mapping if using virtual addressing */
-
-		if ((table_size) &&
-			((flags & ACPI_MEMORY_MODE) == ACPI_LOGICAL_ADDRESSING)) {
-			acpi_os_unmap_memory (table_ptr, table_size);
-		}
-	}
-
-	/* Did not find the table */
-
-	status = AE_NOT_EXIST;
-
-
-cleanup:
-	if (rsdt_size) {
-		acpi_os_unmap_memory (rsdt_ptr, rsdt_size);
-	}
-	return_ACPI_STATUS (status);
-}
-
+#endif
 
diff -urNp linux-5400/drivers/acpi/tables.c linux-5410/drivers/acpi/tables.c
--- linux-5400/drivers/acpi/tables.c
+++ linux-5410/drivers/acpi/tables.c
@@ -0,0 +1,564 @@
+/*
+ *  acpi_tables.c - ACPI Boot-Time Table Parsing
+ *
+ *  Copyright (C) 2001 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/smp.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/irq.h>
+#include <linux/errno.h>
+#include <linux/acpi.h>
+
+#define PREFIX			"ACPI: "
+
+#define ACPI_MAX_TABLES		256
+
+static char *acpi_table_signatures[ACPI_TABLE_COUNT] = {
+	[ACPI_TABLE_UNKNOWN]	= "????",
+	[ACPI_APIC]		= "APIC",
+	[ACPI_BOOT]		= "BOOT",
+	[ACPI_DBGP]		= "DBGP",
+	[ACPI_DSDT]		= "DSDT",
+	[ACPI_ECDT]		= "ECDT",
+	[ACPI_ETDT]		= "ETDT",
+	[ACPI_FADT]		= "FACP",
+	[ACPI_FACS]		= "FACS",
+	[ACPI_OEMX]		= "OEM",
+	[ACPI_PSDT]		= "PSDT",
+	[ACPI_SBST]		= "SBST",
+	[ACPI_SLIT]		= "SLIT",
+	[ACPI_SPCR]		= "SPCR",
+	[ACPI_SRAT]		= "SRAT",
+	[ACPI_SSDT]		= "SSDT",
+	[ACPI_SPMI]		= "SPMI",
+	[ACPI_HPET]		= "HPET",
+};
+
+/* System Description Table (RSDT/XSDT) */
+struct acpi_table_sdt {
+	unsigned long		pa;		/* Physical Address */
+	unsigned long		count;		/* Table count */
+	struct {
+		unsigned long		pa;
+		enum acpi_table_id	id;
+		unsigned long		size;
+	}			entry[ACPI_MAX_TABLES];
+} __attribute__ ((packed));
+
+static struct acpi_table_sdt	sdt;
+
+void
+acpi_table_print (
+	struct acpi_table_header *header,
+	unsigned long		phys_addr)
+{
+	char			*name = NULL;
+
+	if (!header)
+		return;
+
+	/* Some table signatures aren't good table names */
+
+	if (!strncmp((char *) &header->signature,
+		acpi_table_signatures[ACPI_APIC],
+		sizeof(header->signature))) {
+		name = "MADT";
+	}
+	else if (!strncmp((char *) &header->signature,
+		acpi_table_signatures[ACPI_FADT],
+		sizeof(header->signature))) {
+		name = "FADT";
+	}
+	else
+		name = header->signature;
+
+	printk(KERN_INFO PREFIX "%.4s (v%3.3d %6.6s %8.8s %5.5d.%5.5d) @ 0x%p\n",
+		name, header->revision, header->oem_id,
+		header->oem_table_id, header->oem_revision >> 16,
+		header->oem_revision & 0xffff, (void *) phys_addr);
+}
+
+
+void
+acpi_table_print_madt_entry (
+	acpi_table_entry_header	*header)
+{
+	if (!header)
+		return;
+
+	switch (header->type) {
+
+	case ACPI_MADT_LAPIC:
+	{
+		struct acpi_table_lapic *p =
+			(struct acpi_table_lapic*) header;
+		printk(KERN_INFO PREFIX "LAPIC (acpi_id[0x%02x] lapic_id[0x%02x] %s)\n",
+			p->acpi_id, p->id, p->flags.enabled?"enabled":"disabled");
+	}
+		break;
+
+	case ACPI_MADT_IOAPIC:
+	{
+		struct acpi_table_ioapic *p =
+			(struct acpi_table_ioapic*) header;
+		printk(KERN_INFO PREFIX "IOAPIC (id[0x%02x] address[0x%08x] global_irq_base[0x%x])\n",
+			p->id, p->address, p->global_irq_base);
+	}
+		break;
+
+	case ACPI_MADT_INT_SRC_OVR:
+	{
+		struct acpi_table_int_src_ovr *p =
+			(struct acpi_table_int_src_ovr*) header;
+		printk(KERN_INFO PREFIX "INT_SRC_OVR (bus[%d] irq[0x%x] global_irq[0x%x] polarity[0x%x] trigger[0x%x])\n",
+			p->bus, p->bus_irq, p->global_irq, p->flags.polarity, p->flags.trigger);
+	}
+		break;
+
+	case ACPI_MADT_NMI_SRC:
+	{
+		struct acpi_table_nmi_src *p =
+			(struct acpi_table_nmi_src*) header;
+		printk(KERN_INFO PREFIX "NMI_SRC (polarity[0x%x] trigger[0x%x] global_irq[0x%x])\n",
+			p->flags.polarity, p->flags.trigger, p->global_irq);
+	}
+		break;
+
+	case ACPI_MADT_LAPIC_NMI:
+	{
+		struct acpi_table_lapic_nmi *p =
+			(struct acpi_table_lapic_nmi*) header;
+		printk(KERN_INFO PREFIX "LAPIC_NMI (acpi_id[0x%02x] polarity[0x%x] trigger[0x%x] lint[0x%x])\n",
+			p->acpi_id, p->flags.polarity, p->flags.trigger, p->lint);
+	}
+		break;
+
+	case ACPI_MADT_LAPIC_ADDR_OVR:
+	{
+		struct acpi_table_lapic_addr_ovr *p =
+			(struct acpi_table_lapic_addr_ovr*) header;
+		printk(KERN_INFO PREFIX "LAPIC_ADDR_OVR (address[%p])\n",
+			(void *) (unsigned long) p->address);
+	}
+		break;
+
+	case ACPI_MADT_IOSAPIC:
+	{
+		struct acpi_table_iosapic *p =
+			(struct acpi_table_iosapic*) header;
+		printk(KERN_INFO PREFIX "IOSAPIC (id[0x%x] global_irq_base[0x%x] address[%p])\n",
+			p->id, p->global_irq_base, (void *) (unsigned long) p->address);
+	}
+		break;
+
+	case ACPI_MADT_LSAPIC:
+	{
+		struct acpi_table_lsapic *p =
+			(struct acpi_table_lsapic*) header;
+		printk(KERN_INFO PREFIX "LSAPIC (acpi_id[0x%02x] lsapic_id[0x%02x] lsapic_eid[0x%02x] %s)\n",
+			p->acpi_id, p->id, p->eid, p->flags.enabled?"enabled":"disabled");
+	}
+		break;
+
+	case ACPI_MADT_PLAT_INT_SRC:
+	{
+		struct acpi_table_plat_int_src *p =
+			(struct acpi_table_plat_int_src*) header;
+		printk(KERN_INFO PREFIX "PLAT_INT_SRC (polarity[0x%x] trigger[0x%x] type[0x%x] id[0x%04x] eid[0x%x] iosapic_vector[0x%x] global_irq[0x%x]\n",
+			p->flags.polarity, p->flags.trigger, p->type, p->id, p->eid, p->iosapic_vector, p->global_irq);
+	}
+		break;
+
+	default:
+		printk(KERN_WARNING PREFIX "Found unsupported MADT entry (type = 0x%x)\n",
+			header->type);
+		break;
+	}
+}
+
+
+static int
+acpi_table_compute_checksum (
+	void			*table_pointer,
+	unsigned long		length)
+{
+	u8			*p = (u8 *) table_pointer;
+	unsigned long		remains = length;
+	unsigned long		sum = 0;
+
+	if (!p || !length)
+		return -EINVAL;
+
+	while (remains--)
+		sum += *p++;
+
+	return (sum & 0xFF);
+}
+
+int __init
+acpi_get_table_header_early (
+	enum acpi_table_id	id,
+	struct acpi_table_header **header)
+{
+	int i;
+	enum acpi_table_id temp_id;
+
+	/* DSDT is different from the rest */
+	if (id == ACPI_DSDT)
+		temp_id = ACPI_FADT;
+	else
+		temp_id = id;
+
+	/* Locate the table. */
+
+	for (i = 0; i < sdt.count; i++) {
+		if (sdt.entry[i].id != temp_id)
+			continue;
+		*header = (void *)
+			__acpi_map_table(sdt.entry[i].pa, sdt.entry[i].size);
+		if (!*header) {
+			printk(KERN_WARNING PREFIX "Unable to map %s\n",
+			       acpi_table_signatures[temp_id]);
+			return -ENODEV;
+		}
+		break;
+	}
+
+	if (!*header) {
+		printk(KERN_WARNING PREFIX "%s not present\n",
+		       acpi_table_signatures[id]);
+		return -ENODEV;
+	}
+
+	/* Map the DSDT header via the pointer in the FADT */
+	if (id == ACPI_DSDT) {
+		struct acpi_table_fadt *fadt = (struct acpi_table_fadt *) *header;
+
+		*header = (void *) __acpi_map_table(fadt->dsdt_addr,
+				sizeof(struct acpi_table_header));
+		if (!*header) {
+			printk(KERN_WARNING PREFIX "Unable to map DSDT\n");
+			return -ENODEV;
+		}
+	}
+
+	return 0;
+}
+	 
+
+int __init
+acpi_table_parse_madt_family (
+	enum acpi_table_id	id,
+	unsigned long		madt_size,
+	int			entry_id,
+	acpi_madt_entry_handler	handler)
+{
+	void			*madt = NULL;
+	acpi_table_entry_header	*entry = NULL;
+	unsigned long		count = 0;
+	unsigned long		madt_end = 0;
+	int			i = 0;
+
+	if (!handler)
+		return -EINVAL;
+
+	/* Locate the MADT (if exists). There should only be one. */
+
+	for (i = 0; i < sdt.count; i++) {
+		if (sdt.entry[i].id != id)
+			continue;
+		madt = (void *)
+			__acpi_map_table(sdt.entry[i].pa, sdt.entry[i].size);
+		if (!madt) {
+			printk(KERN_WARNING PREFIX "Unable to map %s\n",
+			       acpi_table_signatures[id]);
+			return -ENODEV;
+		}
+		break;
+	}
+
+	if (!madt) {
+		printk(KERN_WARNING PREFIX "%s not present\n",
+		       acpi_table_signatures[id]);
+		return -ENODEV;
+	}
+
+	madt_end = (unsigned long) madt + sdt.entry[i].size;
+
+	/* Parse all entries looking for a match. */
+
+	entry = (acpi_table_entry_header *)
+		((unsigned long) madt + madt_size);
+
+	while (((unsigned long) entry) < madt_end) {
+		if (entry->type == entry_id) {
+			count++;
+			handler(entry);
+		}
+		entry = (acpi_table_entry_header *)
+			((unsigned long) entry + entry->length);
+	}
+
+	return count;
+}
+
+
+int __init
+acpi_table_parse_madt (
+	enum acpi_madt_entry_id	id,
+	acpi_madt_entry_handler	handler)
+{
+	return acpi_table_parse_madt_family(ACPI_APIC, sizeof(struct acpi_table_madt),
+					    id, handler);
+}
+
+
+int __init
+acpi_table_parse (
+	enum acpi_table_id	id,
+	acpi_table_handler	handler)
+{
+	int			count = 0;
+	int			i = 0;
+
+	if (!handler)
+		return -EINVAL;
+
+	for (i = 0; i < sdt.count; i++) {
+		if (sdt.entry[i].id != id)
+			continue;
+		handler(sdt.entry[i].pa, sdt.entry[i].size);
+		count++;
+	}
+
+	return count;
+}
+
+
+static int __init
+acpi_table_get_sdt (
+	struct acpi_table_rsdp	*rsdp)
+{
+	struct acpi_table_header *header = NULL;
+	int			i, id = 0;
+
+	if (!rsdp)
+		return -EINVAL;
+
+	/* First check XSDT (but only on ACPI 2.0-compatible systems) */
+
+	if ((rsdp->revision >= 2) &&
+		(((struct acpi20_table_rsdp*)rsdp)->xsdt_address)) {
+			
+		struct acpi_table_xsdt	*mapped_xsdt = NULL;
+
+		sdt.pa = ((struct acpi20_table_rsdp*)rsdp)->xsdt_address;
+
+		/* map in just the header */
+		header = (struct acpi_table_header *)
+			__acpi_map_table(sdt.pa, sizeof(struct acpi_table_header));
+
+		if (!header) {
+			printk(KERN_WARNING PREFIX "Unable to map XSDT header\n");
+			return -ENODEV;
+		}
+
+		/* remap in the entire table before processing */
+		mapped_xsdt = (struct acpi_table_xsdt *)
+			__acpi_map_table(sdt.pa, header->length);
+		if (!mapped_xsdt) {
+			printk(KERN_WARNING PREFIX "Unable to map XSDT\n");
+			return -ENODEV;
+		}
+		header = &mapped_xsdt->header;
+
+		if (strncmp(header->signature, "XSDT", 4)) {
+			printk(KERN_WARNING PREFIX "XSDT signature incorrect\n");
+			return -ENODEV;
+		}
+
+		if (acpi_table_compute_checksum(header, header->length)) {
+			printk(KERN_WARNING PREFIX "Invalid XSDT checksum\n");
+			return -ENODEV;
+		}
+
+		sdt.count = (header->length - sizeof(struct acpi_table_header)) >> 3;
+		if (sdt.count > ACPI_MAX_TABLES) {
+			printk(KERN_WARNING PREFIX "Truncated %lu XSDT entries\n",
+				(sdt.count - ACPI_MAX_TABLES));
+			sdt.count = ACPI_MAX_TABLES;
+		}
+
+		for (i = 0; i < sdt.count; i++)
+			sdt.entry[i].pa = (unsigned long) mapped_xsdt->entry[i];
+	}
+
+	/* Then check RSDT */
+
+	else if (rsdp->rsdt_address) {
+
+		struct acpi_table_rsdt	*mapped_rsdt = NULL;
+
+		sdt.pa = rsdp->rsdt_address;
+
+		/* map in just the header */
+		header = (struct acpi_table_header *)
+			__acpi_map_table(sdt.pa, sizeof(struct acpi_table_header));
+		if (!header) {
+			printk(KERN_WARNING PREFIX "Unable to map RSDT header\n");
+			return -ENODEV;
+		}
+
+		/* remap in the entire table before processing */
+		mapped_rsdt = (struct acpi_table_rsdt *)
+			__acpi_map_table(sdt.pa, header->length);
+		if (!mapped_rsdt) {
+			printk(KERN_WARNING PREFIX "Unable to map RSDT\n");
+			return -ENODEV;
+		}
+		header = &mapped_rsdt->header;
+
+		if (strncmp(header->signature, "RSDT", 4)) {
+			printk(KERN_WARNING PREFIX "RSDT signature incorrect\n");
+			return -ENODEV;
+		}
+
+		if (acpi_table_compute_checksum(header, header->length)) {
+			printk(KERN_WARNING PREFIX "Invalid RSDT checksum\n");
+			return -ENODEV;
+		}
+
+		sdt.count = (header->length - sizeof(struct acpi_table_header)) >> 2;
+		if (sdt.count > ACPI_MAX_TABLES) {
+			printk(KERN_WARNING PREFIX "Truncated %lu RSDT entries\n",
+				(sdt.count - ACPI_TABLE_COUNT));
+			sdt.count = ACPI_MAX_TABLES;
+		}
+
+		for (i = 0; i < sdt.count; i++)
+			sdt.entry[i].pa = (unsigned long) mapped_rsdt->entry[i];
+	}
+
+	else {
+		printk(KERN_WARNING PREFIX "No System Description Table (RSDT/XSDT) specified in RSDP\n");
+		return -ENODEV;
+	}
+
+	acpi_table_print(header, sdt.pa);
+
+	for (i = 0; i < sdt.count; i++) {
+
+		/* map in just the header */
+		header = (struct acpi_table_header *)
+			__acpi_map_table(sdt.entry[i].pa,
+				sizeof(struct acpi_table_header));
+		if (!header)
+			continue;
+
+		/* remap in the entire table before processing */
+		header = (struct acpi_table_header *)
+			__acpi_map_table(sdt.entry[i].pa,
+				header->length);
+		if (!header)
+			continue;
+	               
+		acpi_table_print(header, sdt.entry[i].pa);
+
+		if (acpi_table_compute_checksum(header, header->length)) {
+			printk(KERN_WARNING "  >>> ERROR: Invalid checksum\n");
+			continue;
+		}
+
+		sdt.entry[i].size = header->length;
+
+		for (id = 0; id < ACPI_TABLE_COUNT; id++) {
+			if (!strncmp((char *) &header->signature,
+				acpi_table_signatures[id],
+				sizeof(header->signature))) {
+				sdt.entry[i].id = id;
+			}
+		}
+	}
+
+	/* 
+	 * The DSDT is *not* in the RSDT (why not? no idea.) but we want
+	 * to print its info, because this is what people usually blacklist
+	 * against. Unfortunately, we don't know the phys_addr, so just
+	 * print 0. Maybe no one will notice.
+	 */
+	if(!acpi_get_table_header_early(ACPI_DSDT, &header))
+		acpi_table_print(header, 0);
+
+	return 0;
+}
+
+
+int __init
+acpi_table_init (void)
+{
+	struct acpi_table_rsdp	*rsdp = NULL;
+	unsigned long		rsdp_phys = 0;
+	int			result = 0;
+
+	memset(&sdt, 0, sizeof(struct acpi_table_sdt));
+
+	/* Locate and map the Root System Description Table (RSDP) */
+
+	rsdp_phys = acpi_find_rsdp();
+	if (!rsdp_phys) {
+		printk(KERN_ERR PREFIX "Unable to locate RSDP\n");
+		return -ENODEV;
+	}
+
+	rsdp = (struct acpi_table_rsdp *) __va(rsdp_phys);
+	if (!rsdp) {
+		printk(KERN_WARNING PREFIX "Unable to map RSDP\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO PREFIX "RSDP (v%3.3d %6.6s                     ) @ 0x%p\n",
+		rsdp->revision, rsdp->oem_id, (void *) rsdp_phys);
+
+	if (rsdp->revision < 2)
+		result = acpi_table_compute_checksum(rsdp, sizeof(struct acpi_table_rsdp));
+	else
+		result = acpi_table_compute_checksum(rsdp, ((struct acpi20_table_rsdp *)rsdp)->length);
+
+	if (result) {
+		printk(KERN_WARNING "  >>> ERROR: Invalid checksum\n");
+		return -ENODEV;
+	}
+
+	/* Locate and map the System Description table (RSDT/XSDT) */
+
+	if (acpi_table_get_sdt(rsdp))
+		return -ENODEV;
+
+	return 0;
+}
+
diff -urNp linux-5400/drivers/acpi/thermal.c linux-5410/drivers/acpi/thermal.c
--- linux-5400/drivers/acpi/thermal.c
+++ linux-5410/drivers/acpi/thermal.c
@@ -0,0 +1,1359 @@
+/*
+ *  acpi_thermal.c - ACPI Thermal Zone Driver ($Revision: 40 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This driver fully implements the ACPI thermal policy as described in the
+ *  ACPI 2.0 Specification.
+ *
+ *  TBD: 1. Implement passive cooling hysteresis.
+ *       2. Enhance passive cooling (CPU) states/limit interface to support
+ *          concepts of 'multiple limiters', upper/lower limits, etc.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/compatmac.h>
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include <linux/kmod.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+
+#define _COMPONENT		ACPI_THERMAL_COMPONENT
+ACPI_MODULE_NAME		("acpi_thermal")
+
+MODULE_AUTHOR("Paul Diefenbaugh");
+MODULE_DESCRIPTION(ACPI_THERMAL_DRIVER_NAME);
+MODULE_LICENSE("GPL");
+
+static int tzp = 0;
+MODULE_PARM(tzp, "i");
+MODULE_PARM_DESC(tzp, "Thermal zone polling frequency, in 1/10 seconds.\n");
+
+#define PREFIX			"ACPI: "
+
+
+#define ACPI_THERMAL_MAX_ACTIVE	10
+
+#define KELVIN_TO_CELSIUS(t)    (long)(((long)t-2732>=0) ? ((long)t-2732+5)/10 : ((long)t-2732-5)/10)
+#define CELSIUS_TO_KELVIN(t)	((t+273)*10)
+
+static int acpi_thermal_add (struct acpi_device *device);
+static int acpi_thermal_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_thermal_driver = {
+	.name =		ACPI_THERMAL_DRIVER_NAME,
+	.class =	ACPI_THERMAL_CLASS,
+	.ids =		ACPI_THERMAL_HID,
+	.ops =		{
+				.add =		acpi_thermal_add,
+				.remove =	acpi_thermal_remove,
+			},
+};
+
+struct acpi_thermal_state {
+	u8			critical:1;
+	u8			hot:1;
+	u8			passive:1;
+	u8			active:1;
+	u8			reserved:4;
+	int			active_index;
+};
+
+struct acpi_thermal_state_flags {
+	u8			valid:1;
+	u8			enabled:1;
+	u8			reserved:6;
+};
+
+struct acpi_thermal_critical {
+	struct acpi_thermal_state_flags flags;
+	unsigned long		temperature;
+};
+
+struct acpi_thermal_hot {
+	struct acpi_thermal_state_flags flags;
+	unsigned long		temperature;
+};
+
+struct acpi_thermal_passive {
+	struct acpi_thermal_state_flags flags;
+	unsigned long		temperature;
+	unsigned long		tc1;
+	unsigned long		tc2;
+	unsigned long		tsp;
+	struct acpi_handle_list	devices;
+};
+
+struct acpi_thermal_active {
+	struct acpi_thermal_state_flags flags;
+	unsigned long		temperature;
+	struct acpi_handle_list	devices;
+};
+
+struct acpi_thermal_trips {
+	struct acpi_thermal_critical critical;
+	struct acpi_thermal_hot	hot;
+	struct acpi_thermal_passive passive;
+	struct acpi_thermal_active active[ACPI_THERMAL_MAX_ACTIVE];
+};
+
+struct acpi_thermal_flags {
+	u8			cooling_mode:1;		/* _SCP */
+	u8			devices:1;		/* _TZD */
+	u8			reserved:6;
+};
+
+struct acpi_thermal {
+	acpi_handle		handle;
+	acpi_bus_id		name;
+	unsigned long		temperature;
+	unsigned long		last_temperature;
+	unsigned long		polling_frequency;
+	u8			cooling_mode;
+	struct acpi_thermal_flags flags;
+	struct acpi_thermal_state state;
+	struct acpi_thermal_trips trips;
+	struct acpi_handle_list	devices;
+	struct timer_list	timer;
+};
+
+
+/* --------------------------------------------------------------------------
+                             Thermal Zone Management
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_thermal_get_temperature (
+	struct acpi_thermal *tz)
+{
+	acpi_status		status = AE_OK;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_get_temperature");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	tz->last_temperature = tz->temperature;
+
+	status = acpi_evaluate_integer(tz->handle, "_TMP", NULL, &tz->temperature);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Temperature is %lu dK\n", tz->temperature));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_get_polling_frequency (
+	struct acpi_thermal	*tz)
+{
+	acpi_status		status = AE_OK;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_get_polling_frequency");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	status = acpi_evaluate_integer(tz->handle, "_TZP", NULL, &tz->polling_frequency);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Polling frequency is %lu dS\n", tz->polling_frequency));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_set_polling (
+	struct acpi_thermal	*tz,
+	int			seconds)
+{
+	ACPI_FUNCTION_TRACE("acpi_thermal_set_polling");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	tz->polling_frequency = seconds * 10;	/* Convert value to deci-seconds */
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Polling frequency set to %lu seconds\n", tz->polling_frequency));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_set_cooling_mode (
+	struct acpi_thermal	*tz,
+	int			mode)
+{
+	acpi_status		status = AE_OK;
+	union acpi_object	arg0 = {ACPI_TYPE_INTEGER};
+	struct acpi_object_list	arg_list = {1, &arg0};
+	acpi_handle		handle = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_set_cooling_mode");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	status = acpi_get_handle(tz->handle, "_SCP", &handle);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "_SCP not present\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	arg0.integer.value = mode;
+
+	status = acpi_evaluate_object(handle, NULL, &arg_list, NULL);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	tz->cooling_mode = mode;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Cooling mode [%s]\n", 
+		mode?"passive":"active"));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_get_trip_points (
+	struct acpi_thermal *tz)
+{
+	acpi_status		status = AE_OK;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_get_trip_points");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	/* Critical Shutdown (required) */
+
+	status = acpi_evaluate_integer(tz->handle, "_CRT", NULL, 
+		&tz->trips.critical.temperature);
+	if (ACPI_FAILURE(status)) {
+		tz->trips.critical.flags.valid = 0;
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "No critical threshold\n"));
+		return -ENODEV;
+	}
+	else {
+		tz->trips.critical.flags.valid = 1;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found critical threshold [%lu]\n", tz->trips.critical.temperature));
+	}
+
+	/* Critical Sleep (optional) */
+
+	status = acpi_evaluate_integer(tz->handle, "_HOT", NULL, &tz->trips.hot.temperature);
+	if (ACPI_FAILURE(status)) {
+		tz->trips.hot.flags.valid = 0;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No hot threshold\n"));
+	}
+	else {
+		tz->trips.hot.flags.valid = 1;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found hot threshold [%lu]\n", tz->trips.hot.temperature));
+	}
+
+	/* Passive: Processors (optional) */
+
+	status = acpi_evaluate_integer(tz->handle, "_PSV", NULL, &tz->trips.passive.temperature);
+	if (ACPI_FAILURE(status)) {
+		tz->trips.passive.flags.valid = 0;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No passive threshold\n"));
+	}
+	else {
+		tz->trips.passive.flags.valid = 1;
+
+		status = acpi_evaluate_integer(tz->handle, "_TC1", NULL, &tz->trips.passive.tc1);
+		if (ACPI_FAILURE(status))
+			tz->trips.passive.flags.valid = 0;
+
+		status = acpi_evaluate_integer(tz->handle, "_TC2", NULL, &tz->trips.passive.tc2);
+		if (ACPI_FAILURE(status))
+			tz->trips.passive.flags.valid = 0;
+
+		status = acpi_evaluate_integer(tz->handle, "_TSP", NULL, &tz->trips.passive.tsp);
+		if (ACPI_FAILURE(status))
+			tz->trips.passive.flags.valid = 0;
+
+		status = acpi_evaluate_reference(tz->handle, "_PSL", NULL, &tz->trips.passive.devices);
+		if (ACPI_FAILURE(status))
+			tz->trips.passive.flags.valid = 0;
+
+		if (!tz->trips.passive.flags.valid)
+			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid passive threshold\n"));
+		else
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found passive threshold [%lu]\n", tz->trips.passive.temperature));
+	}
+
+	/* Active: Fans, etc. (optional) */
+
+	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++) {
+
+		char name[5] = {'_','A','C',('0'+i),'\0'};
+
+		status = acpi_evaluate_integer(tz->handle, name, NULL, &tz->trips.active[i].temperature);
+		if (ACPI_FAILURE(status))
+			break;
+
+		name[2] = 'L';
+		status = acpi_evaluate_reference(tz->handle, name, NULL, &tz->trips.active[i].devices);
+		if (ACPI_SUCCESS(status)) {
+			tz->trips.active[i].flags.valid = 1;
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found active threshold [%d]:[%lu]\n", i, tz->trips.active[i].temperature));
+		}
+		else
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid active threshold [%d]\n", i));
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_get_devices (
+	struct acpi_thermal	*tz)
+{
+	acpi_status		status = AE_OK;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_get_devices");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	status = acpi_evaluate_reference(tz->handle, "_TZD", NULL, &tz->devices);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_call_usermode (
+	char			*path)
+{
+	char			*argv[2] = {NULL, NULL};
+	char			*envp[3] = {NULL, NULL, NULL};
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_call_usermode");
+
+	if (!path)
+		return_VALUE(-EINVAL);
+
+	argv[0] = path;
+
+	/* minimal command environment */
+	envp[0] = "HOME=/";
+	envp[1] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+	
+	call_usermodehelper(argv[0], argv, envp);
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_critical (
+	struct acpi_thermal	*tz)
+{
+	int			result = 0;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_critical");
+
+	if (!tz || !tz->trips.critical.flags.valid)
+		return_VALUE(-EINVAL);
+
+	if (tz->temperature >= tz->trips.critical.temperature) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Critical trip point\n"));
+		tz->trips.critical.flags.enabled = 1;
+	}
+	else if (tz->trips.critical.flags.enabled)
+		tz->trips.critical.flags.enabled = 0;
+
+	result = acpi_bus_get_device(tz->handle, &device);
+	if (result)
+		return_VALUE(result);
+
+	acpi_bus_generate_event(device, ACPI_THERMAL_NOTIFY_CRITICAL, tz->trips.critical.flags.enabled);
+
+	acpi_thermal_call_usermode(ACPI_THERMAL_PATH_POWEROFF);
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_hot (
+	struct acpi_thermal	*tz)
+{
+	int			result = 0;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_hot");
+
+	if (!tz || !tz->trips.hot.flags.valid)
+		return_VALUE(-EINVAL);
+
+	if (tz->temperature >= tz->trips.hot.temperature) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Hot trip point\n"));
+		tz->trips.hot.flags.enabled = 1;
+	}
+	else if (tz->trips.hot.flags.enabled)
+		tz->trips.hot.flags.enabled = 0;
+
+	result = acpi_bus_get_device(tz->handle, &device);
+	if (result)
+		return_VALUE(result);
+
+	acpi_bus_generate_event(device, ACPI_THERMAL_NOTIFY_HOT, tz->trips.hot.flags.enabled);
+
+	/* TBD: Call user-mode "sleep(S4)" function */
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_passive (
+	struct acpi_thermal	*tz)
+{
+	int			result = 0;
+	struct acpi_thermal_passive *passive = NULL;
+	int			trend = 0;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_passive");
+
+	if (!tz || !tz->trips.passive.flags.valid)
+		return_VALUE(-EINVAL);
+
+	passive = &(tz->trips.passive);
+
+	/*
+	 * Above Trip?
+	 * -----------
+	 * Calculate the thermal trend (using the passive cooling equation)
+	 * and modify the performance limit for all passive cooling devices
+	 * accordingly.  Note that we assume symmetry.
+	 */
+	if (tz->temperature >= passive->temperature) {
+		trend = (passive->tc1 * (tz->temperature - tz->last_temperature)) + (passive->tc2 * (tz->temperature - passive->temperature));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"trend[%d]=(tc1[%lu]*(tmp[%lu]-last[%lu]))+(tc2[%lu]*(tmp[%lu]-psv[%lu]))\n", 
+			trend, passive->tc1, tz->temperature, 
+			tz->last_temperature, passive->tc2, 
+			tz->temperature, passive->temperature));
+		tz->trips.passive.flags.enabled = 1;
+		/* Heating up? */
+		if (trend > 0)
+			for (i=0; i<passive->devices.count; i++)
+				acpi_processor_set_thermal_limit(
+					passive->devices.handles[i], 
+					ACPI_PROCESSOR_LIMIT_INCREMENT);
+		/* Cooling off? */
+		else if (trend < 0)
+			for (i=0; i<passive->devices.count; i++)
+				acpi_processor_set_thermal_limit(
+					passive->devices.handles[i], 
+					ACPI_PROCESSOR_LIMIT_DECREMENT);
+	}
+
+	/*
+	 * Below Trip?
+	 * -----------
+	 * Implement passive cooling hysteresis to slowly increase performance
+	 * and avoid thrashing around the passive trip point.  Note that we
+	 * assume symmetry.
+	 */
+	else if (tz->trips.passive.flags.enabled) {
+		for (i=0; i<passive->devices.count; i++)
+			result = acpi_processor_set_thermal_limit(
+				passive->devices.handles[i], 
+				ACPI_PROCESSOR_LIMIT_DECREMENT);
+		if (result == 1) {
+			tz->trips.passive.flags.enabled = 0;
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+				"Disabling passive cooling (zone is cool)\n"));
+		}
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_active (
+	struct acpi_thermal	*tz)
+{
+	int			result = 0;
+	struct acpi_thermal_active *active = NULL;
+	int                     i = 0;
+	int			j = 0;
+	unsigned long		maxtemp = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_active");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++) {
+
+		active = &(tz->trips.active[i]);
+		if (!active || !active->flags.valid)
+			break;
+
+		/*
+		 * Above Threshold?
+		 * ----------------
+		 * If not already enabled, turn ON all cooling devices
+		 * associated with this active threshold.
+		 */
+		if (tz->temperature >= active->temperature) {
+			if (active->temperature > maxtemp)
+				tz->state.active_index = i, maxtemp = active->temperature;
+			if (!active->flags.enabled) {
+				for (j = 0; j < active->devices.count; j++) {
+					result = acpi_bus_set_power(active->devices.handles[j], ACPI_STATE_D0);
+					if (result) {
+						ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Unable to turn cooling device [%p] 'on'\n", active->devices.handles[j]));
+						continue;
+					}
+					active->flags.enabled = 1;
+					ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Cooling device [%p] now 'on'\n", active->devices.handles[j]));
+				}
+			}
+		}
+		/*
+		 * Below Threshold?
+		 * ----------------
+		 * Turn OFF all cooling devices associated with this
+		 * threshold.
+		 */
+		else if (active->flags.enabled) {
+			for (j = 0; j < active->devices.count; j++) {
+				result = acpi_bus_set_power(active->devices.handles[j], ACPI_STATE_D3);
+				if (result) {
+					ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Unable to turn cooling device [%p] 'off'\n", active->devices.handles[j]));
+					continue;
+				}
+				active->flags.enabled = 0;
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Cooling device [%p] now 'off'\n", active->devices.handles[j]));
+			}
+		}
+	}
+
+	return_VALUE(0);
+}
+
+
+static void acpi_thermal_check (void *context);
+
+static void
+acpi_thermal_run (
+	unsigned long		data)
+{
+	acpi_os_queue_for_execution(OSD_PRIORITY_GPE,  acpi_thermal_check, (void *) data);
+}
+
+
+static void
+acpi_thermal_check (
+	void                    *data)
+{
+	int			result = 0;
+	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
+	unsigned long		sleep_time = 0;
+	int			i = 0;
+	struct acpi_thermal_state state = tz->state;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_check");
+
+	if (!tz) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid (NULL) context.\n"));
+		return_VOID;
+	}
+
+	result = acpi_thermal_get_temperature(tz);
+	if (result)
+		return_VOID;
+	
+	memset(&tz->state, 0, sizeof(tz->state));
+	
+	/*
+	 * Check Trip Points
+	 * -----------------
+	 * Compare the current temperature to the trip point values to see
+	 * if we've entered one of the thermal policy states.  Note that
+	 * this function determines when a state is entered, but the 
+	 * individual policy decides when it is exited (e.g. hysteresis).
+	 */
+	if (tz->trips.critical.flags.valid)
+		state.critical |= (tz->temperature >= tz->trips.critical.temperature);
+	if (tz->trips.hot.flags.valid)
+		state.hot |= (tz->temperature >= tz->trips.hot.temperature);
+	if (tz->trips.passive.flags.valid)
+		state.passive |= (tz->temperature >= tz->trips.passive.temperature);
+	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++)
+		if (tz->trips.active[i].flags.valid)
+			state.active |= (tz->temperature >= tz->trips.active[i].temperature);
+
+	/*
+	 * Invoke Policy
+	 * -------------
+	 * Separated from the above check to allow individual policy to 
+	 * determine when to exit a given state.
+	 */
+	if (state.critical)
+		acpi_thermal_critical(tz);
+	if (state.hot)
+		acpi_thermal_hot(tz);
+	if (state.passive)
+		acpi_thermal_passive(tz);
+	if (state.active)
+		acpi_thermal_active(tz);
+
+	/*
+	 * Calculate State
+	 * ---------------
+	 * Again, separated from the above two to allow independent policy
+	 * decisions.
+	 */
+	if (tz->trips.critical.flags.enabled)
+		tz->state.critical = 1;
+	if (tz->trips.hot.flags.enabled)
+		tz->state.hot = 1;
+	if (tz->trips.passive.flags.enabled)
+		tz->state.passive = 1;
+	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++)
+		if (tz->trips.active[i].flags.enabled)
+			tz->state.active = 1;
+
+	/*
+	 * Calculate Sleep Time
+	 * --------------------
+	 * If we're in the passive state, use _TSP's value.  Otherwise
+	 * use the default polling frequency (e.g. _TZP).  If no polling
+	 * frequency is specified then we'll wait forever (at least until
+	 * a thermal event occurs).  Note that _TSP and _TZD values are
+	 * given in 1/10th seconds (we must covert to milliseconds).
+	 */
+	if (tz->state.passive)
+		sleep_time = tz->trips.passive.tsp * 100;
+	else if (tz->polling_frequency > 0)
+		sleep_time = tz->polling_frequency * 100;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "%s: temperature[%lu] sleep[%lu]\n", 
+		tz->name, tz->temperature, sleep_time));
+
+	/*
+	 * Schedule Next Poll
+	 * ------------------
+	 */
+	if (!sleep_time) {
+		if (timer_pending(&(tz->timer)))
+			del_timer(&(tz->timer));
+	}
+	else {
+		if (timer_pending(&(tz->timer)))
+			mod_timer(&(tz->timer), (HZ * sleep_time) / 1000);
+		else {
+			tz->timer.data = (unsigned long) tz;
+			tz->timer.function = acpi_thermal_run;
+			tz->timer.expires = jiffies + (HZ * sleep_time) / 1000;
+			add_timer(&(tz->timer));
+		}
+	}
+
+	return_VOID;
+}
+
+
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+struct proc_dir_entry		*acpi_thermal_dir = NULL;
+
+
+static int
+acpi_thermal_read_state (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_read_state");
+
+	if (!tz || (off != 0))
+		goto end;
+
+	p += sprintf(p, "state:                   ");
+
+	if (!tz->state.critical && !tz->state.hot && !tz->state.passive && !tz->state.active)
+		p += sprintf(p, "ok\n");
+	else {
+		if (tz->state.critical)
+			p += sprintf(p, "critical ");
+		if (tz->state.hot)
+			p += sprintf(p, "hot ");
+		if (tz->state.passive)
+			p += sprintf(p, "passive ");
+		if (tz->state.active)
+			p += sprintf(p, "active[%d]", tz->state.active_index);
+		p += sprintf(p, "\n");
+	}
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_thermal_read_temperature (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	int			result = 0;
+	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_read_temperature");
+
+	if (!tz || (off != 0))
+		goto end;
+
+	result = acpi_thermal_get_temperature(tz);
+	if (result)
+		goto end;
+
+	p += sprintf(p, "temperature:             %ld C\n", 
+		KELVIN_TO_CELSIUS(tz->temperature));
+	
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_thermal_read_trip_points (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
+	char			*p = page;
+	int			len = 0;
+	int			i = 0;
+	int			j = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_read_trip_points");
+
+	if (!tz || (off != 0))
+		goto end;
+
+	if (tz->trips.critical.flags.valid)
+		p += sprintf(p, "critical (S5):           %ld C\n",
+			KELVIN_TO_CELSIUS(tz->trips.critical.temperature));
+
+	if (tz->trips.hot.flags.valid)
+		p += sprintf(p, "hot (S4):                %ld C\n",
+			KELVIN_TO_CELSIUS(tz->trips.hot.temperature));
+
+	if (tz->trips.passive.flags.valid) {
+		p += sprintf(p, "passive:                 %ld C: tc1=%lu tc2=%lu tsp=%lu devices=",
+			KELVIN_TO_CELSIUS(tz->trips.passive.temperature),
+			tz->trips.passive.tc1,
+			tz->trips.passive.tc2, 
+			tz->trips.passive.tsp);
+		for (j=0; j<tz->trips.passive.devices.count; j++) {
+
+			p += sprintf(p, "0x%p ", tz->trips.passive.devices.handles[j]);
+		}
+		p += sprintf(p, "\n");
+	}
+
+	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++) {
+		if (!(tz->trips.active[i].flags.valid))
+			break;
+		p += sprintf(p, "active[%d]:               %ld C: devices=",
+			i, KELVIN_TO_CELSIUS(tz->trips.active[i].temperature));
+		for (j=0; j<tz->trips.active[i].devices.count; j++) 
+			p += sprintf(p, "0x%p ",
+				tz->trips.active[i].devices.handles[j]);
+		p += sprintf(p, "\n");
+	}
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_thermal_write_trip_points (
+        struct file		*file,
+        const char		*buffer,
+        unsigned long		count,
+        void			*data)
+{
+	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
+	char			limit_string[25] = {'\0'};
+	int			critical, hot, passive, active0, active1;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_write_trip_points");
+
+	if (!tz || (count > sizeof(limit_string) - 1)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid argument\n"));
+		return_VALUE(-EINVAL);
+	}
+	
+	if (copy_from_user(limit_string, buffer, count)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data\n"));
+		return_VALUE(-EFAULT);
+	}
+	
+	limit_string[count] = '\0';
+
+	if (sscanf(limit_string, "%d:%d:%d:%d:%d", &critical, &hot, &passive, &active0, &active1) != 5) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data format\n"));
+		return_VALUE(-EINVAL);
+	}
+
+	tz->trips.critical.temperature = CELSIUS_TO_KELVIN(critical);
+	tz->trips.hot.temperature = CELSIUS_TO_KELVIN(hot);
+	tz->trips.passive.temperature = CELSIUS_TO_KELVIN(passive);
+	tz->trips.active[0].temperature = CELSIUS_TO_KELVIN(active0);
+	tz->trips.active[1].temperature = CELSIUS_TO_KELVIN(active1);
+	
+	return_VALUE(count);
+}
+
+
+static int
+acpi_thermal_read_cooling_mode (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_read_cooling_mode");
+
+	if (!tz || (off != 0))
+		goto end;
+
+	if (!tz->flags.cooling_mode) {
+		p += sprintf(p, "<not supported>\n");
+		goto end;
+	}
+
+	p += sprintf(p, "cooling mode:            %s\n",
+		tz->cooling_mode?"passive":"active");
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_thermal_write_cooling_mode (
+	struct file		*file,
+	const char		*buffer,
+	unsigned long		count,
+	void			*data)
+{
+	int			result = 0;
+	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
+	char			mode_string[12] = {'\0'};
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_write_cooling_mode");
+
+	if (!tz || (count > sizeof(mode_string) - 1))
+		return_VALUE(-EINVAL);
+
+	if (!tz->flags.cooling_mode)
+		return_VALUE(-ENODEV);
+
+	if (copy_from_user(mode_string, buffer, count))
+		return_VALUE(-EFAULT);
+	
+	mode_string[count] = '\0';
+	
+	result = acpi_thermal_set_cooling_mode(tz, 
+		simple_strtoul(mode_string, NULL, 0));
+	if (result)
+		return_VALUE(result);
+
+	return_VALUE(count);
+}
+
+
+static int
+acpi_thermal_read_polling (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_read_polling");
+
+	if (!tz || (off != 0))
+		goto end;
+
+	if (!tz->polling_frequency) {
+		p += sprintf(p, "<polling disabled>\n");
+		goto end;
+	}
+
+	p += sprintf(p, "polling frequency:       %lu seconds\n",
+		(tz->polling_frequency / 10));
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_thermal_write_polling (
+	struct file		*file,
+	const char		*buffer,
+	unsigned long		count,
+	void			*data)
+{
+	int			result = 0;
+	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
+	char			polling_string[12] = {'\0'};
+	int			seconds = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_write_polling");
+
+	if (!tz || (count > sizeof(polling_string) - 1))
+		return_VALUE(-EINVAL);
+	
+	if (copy_from_user(polling_string, buffer, count))
+		return_VALUE(-EFAULT);
+	
+	polling_string[count] = '\0';
+
+	seconds = simple_strtoul(polling_string, NULL, 0);
+	
+	result = acpi_thermal_set_polling(tz, seconds);
+	if (result)
+		return_VALUE(result);
+
+	acpi_thermal_check(tz);
+
+	return_VALUE(count);
+}
+
+
+static int
+acpi_thermal_add_fs (
+	struct acpi_device	*device)
+{
+	struct proc_dir_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_add_fs");
+
+	if (!acpi_device_dir(device)) {
+		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
+			acpi_thermal_dir);
+		if (!acpi_device_dir(device))
+			return_VALUE(-ENODEV);
+	}
+
+	/* 'state' [R] */
+	entry = create_proc_entry(ACPI_THERMAL_FILE_STATE,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_THERMAL_FILE_STATE));
+	else {
+		entry->read_proc = acpi_thermal_read_state;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'temperature' [R] */
+	entry = create_proc_entry(ACPI_THERMAL_FILE_TEMPERATURE,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_THERMAL_FILE_TEMPERATURE));
+	else {
+		entry->read_proc = acpi_thermal_read_temperature;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'trip_points' [R/W] */
+	entry = create_proc_entry(ACPI_THERMAL_FILE_TRIP_POINTS,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_THERMAL_FILE_POLLING_FREQ));
+	else {
+		entry->read_proc = acpi_thermal_read_trip_points;
+		entry->write_proc = acpi_thermal_write_trip_points;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'cooling_mode' [R/W] */
+	entry = create_proc_entry(ACPI_THERMAL_FILE_COOLING_MODE,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_THERMAL_FILE_COOLING_MODE));
+	else {
+		entry->read_proc = acpi_thermal_read_cooling_mode;
+		entry->write_proc = acpi_thermal_write_cooling_mode;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'polling_frequency' [R/W] */
+	entry = create_proc_entry(ACPI_THERMAL_FILE_POLLING_FREQ,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_THERMAL_FILE_POLLING_FREQ));
+	else {
+		entry->read_proc = acpi_thermal_read_polling;
+		entry->write_proc = acpi_thermal_write_polling;
+		entry->data = acpi_driver_data(device);
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_remove_fs (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_thermal_remove_fs");
+
+	if (acpi_device_dir(device)) {
+		remove_proc_entry(acpi_device_bid(device), acpi_thermal_dir);
+		acpi_device_dir(device) = NULL;
+	}
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                 Driver Interface
+   -------------------------------------------------------------------------- */
+
+static void
+acpi_thermal_notify (
+	acpi_handle 		handle,
+	u32 			event,
+	void 			*data)
+{
+	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_notify");
+
+	if (!tz)
+		return_VOID;
+
+	if (acpi_bus_get_device(tz->handle, &device))
+		return_VOID;
+
+	switch (event) {
+	case ACPI_THERMAL_NOTIFY_TEMPERATURE:
+		acpi_thermal_check(tz);
+		break;
+	case ACPI_THERMAL_NOTIFY_THRESHOLDS:
+		acpi_thermal_get_trip_points(tz);
+		acpi_thermal_check(tz);
+		acpi_bus_generate_event(device, event, 0);
+		break;
+	case ACPI_THERMAL_NOTIFY_DEVICES:
+		if (tz->flags.devices)
+			acpi_thermal_get_devices(tz);
+		acpi_bus_generate_event(device, event, 0);
+		break;
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Unsupported event [0x%x]\n", event));
+		break;
+	}
+
+	return_VOID;
+}
+
+
+static int
+acpi_thermal_get_info (
+	struct acpi_thermal	*tz)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_get_info");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	/* Get temperature [_TMP] (required) */
+	result = acpi_thermal_get_temperature(tz);
+	if (result)
+		return_VALUE(result);
+
+	/* Set the cooling mode [_SCP] to active cooling (default) */
+	result = acpi_thermal_set_cooling_mode(tz, ACPI_THERMAL_MODE_ACTIVE);
+	if (!result)
+		tz->flags.cooling_mode = 1;
+
+	/* Get trip points [_CRT, _PSV, etc.] (required) */
+	result = acpi_thermal_get_trip_points(tz);
+	if (result)
+		return_VALUE(result);
+
+	/* Get default polling frequency [_TZP] (optional) */
+	if (tzp)
+		tz->polling_frequency = tzp;
+	else
+		acpi_thermal_get_polling_frequency(tz);
+
+	/* Get devices in this thermal zone [_TZD] (optional) */
+	result = acpi_thermal_get_devices(tz);
+	if (!result)
+		tz->flags.devices = 1;
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_add (
+	struct acpi_device 		*device)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_thermal	*tz = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	tz = kmalloc(sizeof(struct acpi_thermal), GFP_KERNEL);
+	if (!tz)
+		return_VALUE(-ENOMEM);
+	memset(tz, 0, sizeof(struct acpi_thermal));
+
+	tz->handle = device->handle;
+	sprintf(tz->name, "%s", device->pnp.bus_id);
+	sprintf(acpi_device_name(device), "%s", ACPI_THERMAL_DEVICE_NAME);
+	sprintf(acpi_device_class(device), "%s", ACPI_THERMAL_CLASS);
+	acpi_driver_data(device) = tz;
+
+	result = acpi_thermal_get_info(tz);
+	if (result)
+		goto end;
+
+	result = acpi_thermal_add_fs(device);
+	if (result)
+		return_VALUE(result);
+
+	init_timer(&tz->timer);
+
+	acpi_thermal_check(tz);
+
+	status = acpi_install_notify_handler(tz->handle,
+		ACPI_DEVICE_NOTIFY, acpi_thermal_notify, tz);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error installing notify handler\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	printk(KERN_INFO PREFIX "%s [%s] (%ld C)\n",
+		acpi_device_name(device), acpi_device_bid(device),
+		KELVIN_TO_CELSIUS(tz->temperature));
+
+end:
+	if (result) {
+		acpi_thermal_remove_fs(device);
+		kfree(tz);
+	}
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_thermal_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_thermal	*tz = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	tz = (struct acpi_thermal *) acpi_driver_data(device);
+
+	if (timer_pending(&(tz->timer)))
+		del_timer(&(tz->timer));
+
+	status = acpi_remove_notify_handler(tz->handle,
+		ACPI_DEVICE_NOTIFY, acpi_thermal_notify);
+	if (ACPI_FAILURE(status))
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error removing notify handler\n"));
+
+	/* Terminate policy */
+	if (tz->trips.passive.flags.valid
+		&& tz->trips.passive.flags.enabled) {
+		tz->trips.passive.flags.enabled = 0;
+		acpi_thermal_passive(tz);
+	}
+	if (tz->trips.active[0].flags.valid
+		&& tz->trips.active[0].flags.enabled) {
+		tz->trips.active[0].flags.enabled = 0;
+		acpi_thermal_active(tz);
+	}
+
+	acpi_thermal_remove_fs(device);
+
+	return_VALUE(0);
+}
+
+
+static int __init
+acpi_thermal_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_init");
+
+	acpi_thermal_dir = proc_mkdir(ACPI_THERMAL_CLASS, acpi_root_dir);
+	if (!acpi_thermal_dir)
+		return_VALUE(-ENODEV);
+
+	result = acpi_bus_register_driver(&acpi_thermal_driver);
+	if (result < 0) {
+		remove_proc_entry(ACPI_THERMAL_CLASS, acpi_root_dir);
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+
+
+static void __exit
+acpi_thermal_exit (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_thermal_exit");
+
+	acpi_bus_unregister_driver(&acpi_thermal_driver);
+
+	remove_proc_entry(ACPI_THERMAL_CLASS, acpi_root_dir);
+
+	return_VOID;
+}
+
+
+module_init(acpi_thermal_init);
+module_exit(acpi_thermal_exit);
diff -urNp linux-5400/drivers/acpi/toshiba_acpi.c linux-5410/drivers/acpi/toshiba_acpi.c
--- linux-5400/drivers/acpi/toshiba_acpi.c
+++ linux-5410/drivers/acpi/toshiba_acpi.c
@@ -0,0 +1,540 @@
+/*
+ *  toshiba_acpi.c - Toshiba Laptop ACPI Extras
+ *
+ *
+ *  Copyright (C) 2002-2003 John Belmonte
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ *  The devolpment page for this driver is located at
+ *  http://memebeam.org/toys/ToshibaAcpiDriver.
+ *
+ *  Credits:
+ *	Jonathan A. Buzzard - Toshiba HCI info, and critical tips on reverse
+ *		engineering the Windows drivers
+ *	Yasushi Nagato - changes for linux kernel 2.4 -> 2.5
+ *	Rob Miller - TV out and hotkeys help
+ *
+ *
+ *  TODO
+ *
+ */
+
+#define TOSHIBA_ACPI_VERSION	"0.15"
+#define PROC_INTERFACE_VERSION	1
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/version.h>
+
+#include <acpi/acpi_drivers.h>
+
+MODULE_AUTHOR("John Belmonte");
+MODULE_DESCRIPTION("Toshiba Laptop ACPI Extras Driver");
+MODULE_LICENSE("GPL");
+
+/* Toshiba ACPI method paths */
+#define METHOD_LCD_BRIGHTNESS	"\\_SB_.PCI0.VGA_.LCD_._BCM"
+#define METHOD_HCI		"\\_SB_.VALD.GHCI"
+#define METHOD_VIDEO_OUT	"\\_SB_.VALX.DSSX"
+
+/* Toshiba HCI interface definitions
+ *
+ * HCI is Toshiba's "Hardware Control Interface" which is supposed to
+ * be uniform across all their models.  Ideally we would just call
+ * dedicated ACPI methods instead of using this primitive interface.
+ * However the ACPI methods seem to be incomplete in some areas (for
+ * example they allow setting, but not reading, the LCD brightness value),
+ * so this is still useful.
+ */
+
+#define HCI_WORDS			6
+
+/* operations */
+#define HCI_SET				0xff00
+#define HCI_GET				0xfe00
+
+/* return codes */
+#define HCI_SUCCESS			0x0000
+#define HCI_FAILURE			0x1000
+#define HCI_NOT_SUPPORTED		0x8000
+#define HCI_EMPTY			0x8c00
+
+/* registers */
+#define HCI_FAN				0x0004
+#define HCI_SYSTEM_EVENT		0x0016
+#define HCI_VIDEO_OUT			0x001c
+#define HCI_HOTKEY_EVENT		0x001e
+#define HCI_LCD_BRIGHTNESS		0x002a
+
+/* field definitions */
+#define HCI_LCD_BRIGHTNESS_BITS		3
+#define HCI_LCD_BRIGHTNESS_SHIFT	(16-HCI_LCD_BRIGHTNESS_BITS)
+#define HCI_LCD_BRIGHTNESS_LEVELS	(1 << HCI_LCD_BRIGHTNESS_BITS)
+#define HCI_VIDEO_OUT_LCD		0x1
+#define HCI_VIDEO_OUT_CRT		0x2
+#define HCI_VIDEO_OUT_TV		0x4
+
+/* utility
+ */
+
+static __inline__ void
+_set_bit(u32* word, u32 mask, int value)
+{
+	*word = (*word & ~mask) | (mask * value);
+}
+
+/* an sscanf that takes explicit string length */
+static int
+snscanf(const char* str, int n, const char* format, ...)
+{
+	va_list args;
+	int result;
+	char* str2 = kmalloc(n + 1, GFP_KERNEL);
+	if (str2 == 0) return 0;
+	strncpy(str2, str, n);
+	str2[n] = 0;
+	va_start(args, format);
+	result = vsscanf(str2, format, args);
+	va_end(args);
+	kfree(str2);
+	return result;
+}
+
+/* acpi interface wrappers
+ */
+
+static int
+write_acpi_int(const char* methodName, int val)
+{
+	struct acpi_object_list params;
+	union acpi_object in_objs[1];
+	acpi_status status;
+
+	params.count = sizeof(in_objs)/sizeof(in_objs[0]);
+	params.pointer = in_objs;
+	in_objs[0].type = ACPI_TYPE_INTEGER;
+	in_objs[0].integer.value = val;
+
+	status = acpi_evaluate_object(0, (char*)methodName, &params, 0);
+	return (status == AE_OK);
+}
+
+#if 0
+static int
+read_acpi_int(const char* methodName, int* pVal)
+{
+	struct acpi_buffer results;
+	union acpi_object out_objs[1];
+	acpi_status status;
+
+	results.length = sizeof(out_objs);
+	results.pointer = out_objs;
+
+	status = acpi_evaluate_object(0, (char*)methodName, 0, &results);
+	*pVal = out_objs[0].integer.value;
+
+	return (status == AE_OK) && (out_objs[0].type == ACPI_TYPE_INTEGER);
+}
+#endif
+
+/* Perform a raw HCI call.  Here we don't care about input or output buffer
+ * format.
+ */
+static acpi_status
+hci_raw(const u32 in[HCI_WORDS], u32 out[HCI_WORDS])
+{
+	struct acpi_object_list params;
+	union acpi_object in_objs[HCI_WORDS];
+	struct acpi_buffer results;
+	union acpi_object out_objs[HCI_WORDS+1];
+	acpi_status status;
+	int i;
+
+	params.count = HCI_WORDS;
+	params.pointer = in_objs;
+	for (i = 0; i < HCI_WORDS; ++i) {
+		in_objs[i].type = ACPI_TYPE_INTEGER;
+		in_objs[i].integer.value = in[i];
+	}
+
+	results.length = sizeof(out_objs);
+	results.pointer = out_objs;
+
+	status = acpi_evaluate_object(0, METHOD_HCI, &params,
+		&results);
+	if ((status == AE_OK) && (out_objs->package.count <= HCI_WORDS)) {
+		for (i = 0; i < out_objs->package.count; ++i) {
+			out[i] = out_objs->package.elements[i].integer.value;
+		}
+	}
+
+	return status;
+}
+
+/* common hci tasks (get or set one value)
+ *
+ * In addition to the ACPI status, the HCI system returns a result which
+ * may be useful (such as "not supported").
+ */
+
+static acpi_status
+hci_write1(u32 reg, u32 in1, u32* result)
+{
+	u32 in[HCI_WORDS] = { HCI_SET, reg, in1, 0, 0, 0 };
+	u32 out[HCI_WORDS];
+	acpi_status status = hci_raw(in, out);
+	*result = (status == AE_OK) ? out[0] : HCI_FAILURE;
+	return status;
+}
+
+static acpi_status
+hci_read1(u32 reg, u32* out1, u32* result)
+{
+	u32 in[HCI_WORDS] = { HCI_GET, reg, 0, 0, 0, 0 };
+	u32 out[HCI_WORDS];
+	acpi_status status = hci_raw(in, out);
+	*out1 = out[2];
+	*result = (status == AE_OK) ? out[0] : HCI_FAILURE;
+	return status;
+}
+
+static struct proc_dir_entry*	toshiba_proc_dir = NULL;
+static int			force_fan;
+static int			last_key_event;
+static int			key_event_valid;
+
+typedef struct _ProcItem
+{
+	const char* name;
+	char* (*read_func)(char*);
+	unsigned long (*write_func)(const char*, unsigned long);
+} ProcItem;
+
+/* proc file handlers
+ */
+
+static int
+dispatch_read(char* page, char** start, off_t off, int count, int* eof,
+	ProcItem* item)
+{
+	char* p = page;
+	int len;
+
+	if (off == 0)
+		p = item->read_func(p);
+
+	/* ISSUE: I don't understand this code */
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+	return len;
+}
+
+static int
+dispatch_write(struct file* file, const char* buffer, unsigned long count,
+	ProcItem* item)
+{
+	return item->write_func(buffer, count);
+}
+
+static char*
+read_lcd(char* p)
+{
+	u32 hci_result;
+	u32 value;
+
+	hci_read1(HCI_LCD_BRIGHTNESS, &value, &hci_result);
+	if (hci_result == HCI_SUCCESS) {
+		value = value >> HCI_LCD_BRIGHTNESS_SHIFT;
+		p += sprintf(p, "brightness:              %d\n", value);
+		p += sprintf(p, "brightness_levels:       %d\n",
+			HCI_LCD_BRIGHTNESS_LEVELS);
+	} else {
+		p += sprintf(p, "ERROR\n");
+	}
+
+	return p;
+}
+
+static unsigned long
+write_lcd(const char* buffer, unsigned long count)
+{
+	int value;
+	u32 hci_result;
+
+	if (snscanf(buffer, count, " brightness : %i", &value) == 1 &&
+			value >= 0 && value < HCI_LCD_BRIGHTNESS_LEVELS) {
+		value = value << HCI_LCD_BRIGHTNESS_SHIFT;
+		hci_write1(HCI_LCD_BRIGHTNESS, value, &hci_result);
+		if (hci_result != HCI_SUCCESS)
+			return -EFAULT;
+	} else {
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+static char*
+read_video(char* p)
+{
+	u32 hci_result;
+	u32 value;
+
+	hci_read1(HCI_VIDEO_OUT, &value, &hci_result);
+	if (hci_result == HCI_SUCCESS) {
+		int is_lcd = (value & HCI_VIDEO_OUT_LCD) ? 1 : 0;
+		int is_crt = (value & HCI_VIDEO_OUT_CRT) ? 1 : 0;
+		int is_tv  = (value & HCI_VIDEO_OUT_TV ) ? 1 : 0;
+		p += sprintf(p, "lcd_out:                 %d\n", is_lcd);
+		p += sprintf(p, "crt_out:                 %d\n", is_crt);
+		p += sprintf(p, "tv_out:                  %d\n", is_tv);
+	} else {
+		p += sprintf(p, "ERROR\n");
+	}
+
+	return p;
+}
+
+static unsigned long
+write_video(const char* buffer, unsigned long count)
+{
+	int value;
+	const char* buffer_end = buffer + count;
+	int lcd_out = -1;
+	int crt_out = -1;
+	int tv_out = -1;
+	u32 hci_result;
+	int video_out;
+
+	/* scan expression.  Multiple expressions may be delimited with ; */
+	do {
+		if (snscanf(buffer, count, " lcd_out : %i", &value) == 1)
+			lcd_out = value & 1;
+		else if (snscanf(buffer, count, " crt_out : %i", &value) == 1)
+			crt_out = value & 1;
+		else if (snscanf(buffer, count, " tv_out : %i", &value) == 1)
+			tv_out = value & 1;
+		/* advance to one character past the next ; */
+		do ++buffer;
+		while ((buffer < buffer_end) && (*(buffer-1) != ';'));
+	} while (buffer < buffer_end);
+
+	hci_read1(HCI_VIDEO_OUT, &video_out, &hci_result);
+	if (hci_result == HCI_SUCCESS) {
+		int new_video_out = video_out;
+		if (lcd_out != -1)
+			_set_bit(&new_video_out, HCI_VIDEO_OUT_LCD, lcd_out);
+		if (crt_out != -1)
+			_set_bit(&new_video_out, HCI_VIDEO_OUT_CRT, crt_out);
+		if (tv_out != -1)
+			_set_bit(&new_video_out, HCI_VIDEO_OUT_TV, tv_out);
+		/* To avoid unnecessary video disruption, only write the new
+		 * video setting if something changed. */
+		if (new_video_out != video_out)
+			write_acpi_int(METHOD_VIDEO_OUT, new_video_out);
+	}
+
+	return count;
+}
+
+static char*
+read_fan(char* p)
+{
+	u32 hci_result;
+	u32 value;
+
+	hci_read1(HCI_FAN, &value, &hci_result);
+	if (hci_result == HCI_SUCCESS) {
+		p += sprintf(p, "running:                 %d\n", (value > 0));
+		p += sprintf(p, "force_on:                %d\n", force_fan);
+	} else {
+		p += sprintf(p, "ERROR\n");
+	}
+
+	return p;
+}
+
+static unsigned long
+write_fan(const char* buffer, unsigned long count)
+{
+	int value;
+	u32 hci_result;
+
+	if (snscanf(buffer, count, " force_on : %i", &value) == 1 &&
+			value >= 0 && value <= 1) {
+		hci_write1(HCI_FAN, value, &hci_result);
+		if (hci_result != HCI_SUCCESS)
+			return -EFAULT;
+		else
+			force_fan = value;
+	} else {
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+static char*
+read_keys(char* p)
+{
+	u32 hci_result;
+	u32 value;
+
+	if (!key_event_valid) {
+		hci_read1(HCI_SYSTEM_EVENT, &value, &hci_result);
+		if (hci_result == HCI_SUCCESS) {
+			key_event_valid = 1;
+			last_key_event = value;
+		} else if (hci_result == HCI_EMPTY) {
+			/* better luck next time */
+		} else if (hci_result == HCI_NOT_SUPPORTED) {
+			/* This is a workaround for an unresolved issue on
+			 * some machines where system events sporadically
+			 * become disabled. */
+			hci_write1(HCI_SYSTEM_EVENT, 1, &hci_result);
+		} else {
+			p += sprintf(p, "ERROR\n");
+			goto end;
+		}
+	}
+
+	p += sprintf(p, "hotkey_ready:            %d\n", key_event_valid);
+	p += sprintf(p, "hotkey:                  0x%04x\n", last_key_event);
+
+end:
+	return p;
+}
+
+static unsigned long
+write_keys(const char* buffer, unsigned long count)
+{
+	int value;
+
+	if (snscanf(buffer, count, " hotkey_ready : %i", &value) == 1 &&
+			value == 0) {
+		key_event_valid = 0;
+	} else {
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+static char*
+read_version(char* p)
+{
+	p += sprintf(p, "driver:                  %s\n", TOSHIBA_ACPI_VERSION);
+	p += sprintf(p, "proc_interface:          %d\n",
+		PROC_INTERFACE_VERSION);
+	return p;
+}
+
+/* proc and module init
+ */
+
+#define PROC_TOSHIBA		"toshiba"
+
+ProcItem proc_items[] =
+{
+	{ "lcd"		, read_lcd	, write_lcd	},
+	{ "video"	, read_video	, write_video	},
+	{ "fan"		, read_fan	, write_fan	},
+	{ "keys"	, read_keys	, write_keys	},
+	{ "version"	, read_version	, 0		},
+	{ 0		, 0		, 0		},
+};
+
+static acpi_status
+add_device(void)
+{
+	struct proc_dir_entry* proc;
+	ProcItem* item;
+
+	for (item = proc_items; item->name; ++item)
+	{
+		proc = create_proc_read_entry(item->name,
+			S_IFREG | S_IRUGO | S_IWUSR,
+			toshiba_proc_dir, (read_proc_t*)dispatch_read, item);
+		if (proc && item->write_func)
+			proc->write_proc = (write_proc_t*)dispatch_write;
+	}
+
+	return(AE_OK);
+}
+
+static acpi_status
+remove_device(void)
+{
+	ProcItem* item;
+
+	for (item = proc_items; item->name; ++item)
+		remove_proc_entry(item->name, toshiba_proc_dir);
+	return(AE_OK);
+}
+
+static int __init
+toshiba_acpi_init(void)
+{
+	acpi_status status = AE_OK;
+	int value;
+	u32 hci_result;
+
+	/* simple device detection: try reading an HCI register */
+	hci_read1(HCI_LCD_BRIGHTNESS, &value, &hci_result);
+	if (hci_result != HCI_SUCCESS)
+		return -ENODEV;
+
+	printk("Toshiba Laptop ACPI Extras version %s\n", TOSHIBA_ACPI_VERSION);
+
+	force_fan = 0;
+	key_event_valid = 0;
+
+	/* enable event fifo */
+	hci_write1(HCI_SYSTEM_EVENT, 1, &hci_result);
+
+	toshiba_proc_dir = proc_mkdir(PROC_TOSHIBA, acpi_root_dir);
+	if (!toshiba_proc_dir) {
+		status = AE_ERROR;
+	} else {
+		status = add_device();
+		if (ACPI_FAILURE(status))
+			remove_proc_entry(PROC_TOSHIBA, acpi_root_dir);
+	}
+
+	return (ACPI_SUCCESS(status)) ? 0 : -ENODEV;
+}
+
+static void __exit
+toshiba_acpi_exit(void)
+{
+	remove_device();
+
+	if (toshiba_proc_dir)
+		remove_proc_entry(PROC_TOSHIBA, acpi_root_dir);
+
+	return;
+}
+
+module_init(toshiba_acpi_init);
+module_exit(toshiba_acpi_exit);
diff -urNp linux-5400/drivers/acpi/utilities/Makefile linux-5410/drivers/acpi/utilities/Makefile
--- linux-5400/drivers/acpi/utilities/Makefile
+++ linux-5410/drivers/acpi/utilities/Makefile
@@ -1,11 +1,10 @@
 #
 # Makefile for all Linux ACPI interpreter subdirectories
-# EXCEPT for the ospm directory
 #
 
 O_TARGET := $(notdir $(CURDIR)).o
 
-obj-$(CONFIG_ACPI) := $(patsubst %.c,%.o,$(wildcard *.c))
+obj-$(CONFIG_ACPI_INTERPRETER) := $(patsubst %.c,%.o,$(wildcard *.c))
 
 EXTRA_CFLAGS += $(ACPI_CFLAGS)
 
diff -urNp linux-5400/drivers/acpi/utilities/utalloc.c linux-5410/drivers/acpi/utilities/utalloc.c
--- linux-5400/drivers/acpi/utilities/utalloc.c
+++ linux-5410/drivers/acpi/utilities/utalloc.c
@@ -1,44 +1,58 @@
 /******************************************************************************
  *
  * Module Name: utalloc - local cache and memory allocation routines
- *              $Revision: 106 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acparser.h"
-#include "acinterp.h"
-#include "acnamesp.h"
-#include "acglobal.h"
+#include <acpi/acpi.h>
 
 #define _COMPONENT          ACPI_UTILITIES
-	 MODULE_NAME         ("utalloc")
+	 ACPI_MODULE_NAME    ("utalloc")
 
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_ut_release_to_cache
+ * FUNCTION:    acpi_ut_release_to_cache
  *
- * PARAMETERS:  List_id             - Memory list/cache ID
+ * PARAMETERS:  list_id             - Memory list/cache ID
  *              Object              - The object to be released
  *
  * RETURN:      None
@@ -50,13 +64,13 @@
 
 void
 acpi_ut_release_to_cache (
-	u32                     list_id,
-	void                    *object)
+	u32                             list_id,
+	void                            *object)
 {
-	ACPI_MEMORY_LIST        *cache_info;
+	struct acpi_memory_list         *cache_info;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	/* If walk cache is full, just free this wallkstate object */
@@ -70,29 +84,31 @@ acpi_ut_release_to_cache (
 	/* Otherwise put this object back into the cache */
 
 	else {
-		acpi_ut_acquire_mutex (ACPI_MTX_CACHES);
+		if (ACPI_FAILURE (acpi_ut_acquire_mutex (ACPI_MTX_CACHES))) {
+			return;
+		}
 
 		/* Mark the object as cached */
 
-		MEMSET (object, 0xCA, cache_info->object_size);
-		((acpi_operand_object *) object)->common.data_type = ACPI_CACHED_OBJECT;
+		ACPI_MEMSET (object, 0xCA, cache_info->object_size);
+		ACPI_SET_DESCRIPTOR_TYPE (object, ACPI_DESC_TYPE_CACHED);
 
 		/* Put the object at the head of the cache list */
 
-		* (char **) (((char *) object) + cache_info->link_offset) = cache_info->list_head;
+		* (ACPI_CAST_INDIRECT_PTR (char, &(((char *) object)[cache_info->link_offset]))) = cache_info->list_head;
 		cache_info->list_head = object;
 		cache_info->cache_depth++;
 
-		acpi_ut_release_mutex (ACPI_MTX_CACHES);
+		(void) acpi_ut_release_mutex (ACPI_MTX_CACHES);
 	}
 }
 
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_ut_acquire_from_cache
+ * FUNCTION:    acpi_ut_acquire_from_cache
  *
- * PARAMETERS:  List_id             - Memory list ID
+ * PARAMETERS:  list_id             - Memory list ID
  *
  * RETURN:      A requested object.  NULL if the object could not be
  *              allocated.
@@ -104,17 +120,20 @@ acpi_ut_release_to_cache (
 
 void *
 acpi_ut_acquire_from_cache (
-	u32                     list_id)
+	u32                             list_id)
 {
-	ACPI_MEMORY_LIST        *cache_info;
-	void                    *object;
+	struct acpi_memory_list         *cache_info;
+	void                            *object;
 
 
-	PROC_NAME ("Ut_acquire_from_cache");
+	ACPI_FUNCTION_NAME ("ut_acquire_from_cache");
 
 
 	cache_info = &acpi_gbl_memory_lists[list_id];
-	acpi_ut_acquire_mutex (ACPI_MTX_CACHES);
+	if (ACPI_FAILURE (acpi_ut_acquire_mutex (ACPI_MTX_CACHES))) {
+		return (NULL);
+	}
+
 	ACPI_MEM_TRACKING (cache_info->cache_requests++);
 
 	/* Check the cache first */
@@ -123,7 +142,7 @@ acpi_ut_acquire_from_cache (
 		/* There is an object available, use it */
 
 		object = cache_info->list_head;
-		cache_info->list_head = * (char **) (((char *) object) + cache_info->link_offset);
+		cache_info->list_head = *(ACPI_CAST_INDIRECT_PTR (char, &(((char *) object)[cache_info->link_offset])));
 
 		ACPI_MEM_TRACKING (cache_info->cache_hits++);
 		cache_info->cache_depth--;
@@ -133,11 +152,13 @@ acpi_ut_acquire_from_cache (
 			object, acpi_gbl_memory_lists[list_id].list_name));
 #endif
 
-		acpi_ut_release_mutex (ACPI_MTX_CACHES);
+		if (ACPI_FAILURE (acpi_ut_release_mutex (ACPI_MTX_CACHES))) {
+			return (NULL);
+		}
 
 		/* Clear (zero) the previously used Object */
 
-		MEMSET (object, 0, cache_info->object_size);
+		ACPI_MEMSET (object, 0, cache_info->object_size);
 	}
 
 	else {
@@ -145,7 +166,9 @@ acpi_ut_acquire_from_cache (
 
 		/* Avoid deadlock with ACPI_MEM_CALLOCATE */
 
-		acpi_ut_release_mutex (ACPI_MTX_CACHES);
+		if (ACPI_FAILURE (acpi_ut_release_mutex (ACPI_MTX_CACHES))) {
+			return (NULL);
+		}
 
 		object = ACPI_MEM_CALLOCATE (cache_info->object_size);
 		ACPI_MEM_TRACKING (cache_info->total_allocated++);
@@ -157,9 +180,9 @@ acpi_ut_acquire_from_cache (
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_ut_delete_generic_cache
+ * FUNCTION:    acpi_ut_delete_generic_cache
  *
- * PARAMETERS:  List_id         - Memory list ID
+ * PARAMETERS:  list_id         - Memory list ID
  *
  * RETURN:      None
  *
@@ -169,20 +192,20 @@ acpi_ut_acquire_from_cache (
 
 void
 acpi_ut_delete_generic_cache (
-	u32                     list_id)
+	u32                             list_id)
 {
-	ACPI_MEMORY_LIST        *cache_info;
-	char                    *next;
+	struct acpi_memory_list         *cache_info;
+	char                            *next;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	cache_info = &acpi_gbl_memory_lists[list_id];
 	while (cache_info->list_head) {
 		/* Delete one cached state object */
 
-		next = * (char **) (((char *) cache_info->list_head) + cache_info->link_offset);
+		next = *(ACPI_CAST_INDIRECT_PTR (char, &(((char *) cache_info->list_head)[cache_info->link_offset])));
 		ACPI_MEM_FREE (cache_info->list_head);
 
 		cache_info->list_head = next;
@@ -191,26 +214,396 @@ acpi_ut_delete_generic_cache (
 }
 
 
-#ifdef ACPI_DBG_TRACK_ALLOCATIONS
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_validate_buffer
+ *
+ * PARAMETERS:  Buffer              - Buffer descriptor to be validated
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Perform parameter validation checks on an struct acpi_buffer
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_validate_buffer (
+	struct acpi_buffer              *buffer)
+{
+
+	/* Obviously, the structure pointer must be valid */
+
+	if (!buffer) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	/* Special semantics for the length */
+
+	if ((buffer->length == ACPI_NO_BUFFER)              ||
+		(buffer->length == ACPI_ALLOCATE_BUFFER)        ||
+		(buffer->length == ACPI_ALLOCATE_LOCAL_BUFFER)) {
+		return (AE_OK);
+	}
+
+	/* Length is valid, the buffer pointer must be also */
 
+	if (!buffer->pointer) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_initialize_buffer
+ *
+ * PARAMETERS:  required_length     - Length needed
+ *              Buffer              - Buffer to be validated
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Validate that the buffer is of the required length or
+ *              allocate a new buffer.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_initialize_buffer (
+	struct acpi_buffer              *buffer,
+	acpi_size                       required_length)
+{
+	acpi_status                     status = AE_OK;
+
+
+	switch (buffer->length) {
+	case ACPI_NO_BUFFER:
+
+		/* Set the exception and returned the required length */
+
+		status = AE_BUFFER_OVERFLOW;
+		break;
+
+
+	case ACPI_ALLOCATE_BUFFER:
+
+		/* Allocate a new buffer */
+
+		buffer->pointer = acpi_os_allocate (required_length);
+		if (!buffer->pointer) {
+			return (AE_NO_MEMORY);
+		}
+
+		/* Clear the buffer */
+
+		ACPI_MEMSET (buffer->pointer, 0, required_length);
+		break;
+
+
+	case ACPI_ALLOCATE_LOCAL_BUFFER:
+
+		/* Allocate a new buffer with local interface to allow tracking */
+
+		buffer->pointer = ACPI_MEM_ALLOCATE (required_length);
+		if (!buffer->pointer) {
+			return (AE_NO_MEMORY);
+		}
+
+		/* Clear the buffer */
+
+		ACPI_MEMSET (buffer->pointer, 0, required_length);
+		break;
+
+
+	default:
+
+		/* Validate the size of the buffer */
+
+		if (buffer->length < required_length) {
+			status = AE_BUFFER_OVERFLOW;
+		}
+		break;
+	}
+
+	buffer->length = required_length;
+	return (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_allocate
+ *
+ * PARAMETERS:  Size                - Size of the allocation
+ *              Component           - Component type of caller
+ *              Module              - Source file name of caller
+ *              Line                - Line number of caller
+ *
+ * RETURN:      Address of the allocated memory on success, NULL on failure.
+ *
+ * DESCRIPTION: The subsystem's equivalent of malloc.
+ *
+ ******************************************************************************/
+
+void *
+acpi_ut_allocate (
+	acpi_size                       size,
+	u32                             component,
+	char                            *module,
+	u32                             line)
+{
+	void                            *allocation;
+
+
+	ACPI_FUNCTION_TRACE_U32 ("ut_allocate", size);
+
+
+	/* Check for an inadvertent size of zero bytes */
+
+	if (!size) {
+		_ACPI_REPORT_ERROR (module, line, component,
+				("ut_allocate: Attempt to allocate zero bytes\n"));
+		size = 1;
+	}
+
+	allocation = acpi_os_allocate (size);
+	if (!allocation) {
+		/* Report allocation error */
 
+		_ACPI_REPORT_ERROR (module, line, component,
+				("ut_allocate: Could not allocate size %X\n", (u32) size));
+
+		return_PTR (NULL);
+	}
+
+	return_PTR (allocation);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_callocate
+ *
+ * PARAMETERS:  Size                - Size of the allocation
+ *              Component           - Component type of caller
+ *              Module              - Source file name of caller
+ *              Line                - Line number of caller
+ *
+ * RETURN:      Address of the allocated memory on success, NULL on failure.
+ *
+ * DESCRIPTION: Subsystem equivalent of calloc.
+ *
+ ******************************************************************************/
+
+void *
+acpi_ut_callocate (
+	acpi_size                       size,
+	u32                             component,
+	char                            *module,
+	u32                             line)
+{
+	void                            *allocation;
+
+
+	ACPI_FUNCTION_TRACE_U32 ("ut_callocate", size);
+
+
+	/* Check for an inadvertent size of zero bytes */
+
+	if (!size) {
+		_ACPI_REPORT_ERROR (module, line, component,
+				("ut_callocate: Attempt to allocate zero bytes\n"));
+		return_PTR (NULL);
+	}
+
+	allocation = acpi_os_allocate (size);
+	if (!allocation) {
+		/* Report allocation error */
+
+		_ACPI_REPORT_ERROR (module, line, component,
+				("ut_callocate: Could not allocate size %X\n", (u32) size));
+		return_PTR (NULL);
+	}
+
+	/* Clear the memory block */
+
+	ACPI_MEMSET (allocation, 0, size);
+	return_PTR (allocation);
+}
+
+
+#ifdef ACPI_DBG_TRACK_ALLOCATIONS
 /*
  * These procedures are used for tracking memory leaks in the subsystem, and
  * they get compiled out when the ACPI_DBG_TRACK_ALLOCATIONS is not set.
  *
  * Each memory allocation is tracked via a doubly linked list.  Each
  * element contains the caller's component, module name, function name, and
- * line number.  Acpi_ut_allocate and Acpi_ut_callocate call
- * Acpi_ut_track_allocation to add an element to the list; deletion
- * occurs in the body of Acpi_ut_free.
+ * line number.  acpi_ut_allocate and acpi_ut_callocate call
+ * acpi_ut_track_allocation to add an element to the list; deletion
+ * occurs in the body of acpi_ut_free.
  */
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_find_allocation
+ * FUNCTION:    acpi_ut_allocate_and_track
+ *
+ * PARAMETERS:  Size                - Size of the allocation
+ *              Component           - Component type of caller
+ *              Module              - Source file name of caller
+ *              Line                - Line number of caller
+ *
+ * RETURN:      Address of the allocated memory on success, NULL on failure.
+ *
+ * DESCRIPTION: The subsystem's equivalent of malloc.
+ *
+ ******************************************************************************/
+
+void *
+acpi_ut_allocate_and_track (
+	acpi_size                       size,
+	u32                             component,
+	char                            *module,
+	u32                             line)
+{
+	struct acpi_debug_mem_block     *allocation;
+	acpi_status                     status;
+
+
+	allocation = acpi_ut_allocate (size + sizeof (struct acpi_debug_mem_block), component,
+			  module, line);
+	if (!allocation) {
+		return (NULL);
+	}
+
+	status = acpi_ut_track_allocation (ACPI_MEM_LIST_GLOBAL, allocation, size,
+			  ACPI_MEM_MALLOC, component, module, line);
+	if (ACPI_FAILURE (status)) {
+		acpi_os_free (allocation);
+		return (NULL);
+	}
+
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_GLOBAL].total_allocated++;
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_GLOBAL].current_total_size += (u32) size;
+
+	return ((void *) &allocation->user_space);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_callocate_and_track
+ *
+ * PARAMETERS:  Size                - Size of the allocation
+ *              Component           - Component type of caller
+ *              Module              - Source file name of caller
+ *              Line                - Line number of caller
+ *
+ * RETURN:      Address of the allocated memory on success, NULL on failure.
+ *
+ * DESCRIPTION: Subsystem equivalent of calloc.
+ *
+ ******************************************************************************/
+
+void *
+acpi_ut_callocate_and_track (
+	acpi_size                       size,
+	u32                             component,
+	char                            *module,
+	u32                             line)
+{
+	struct acpi_debug_mem_block     *allocation;
+	acpi_status                     status;
+
+
+	allocation = acpi_ut_callocate (size + sizeof (struct acpi_debug_mem_block), component,
+			  module, line);
+	if (!allocation) {
+		/* Report allocation error */
+
+		_ACPI_REPORT_ERROR (module, line, component,
+				("ut_callocate: Could not allocate size %X\n", (u32) size));
+		return (NULL);
+	}
+
+	status = acpi_ut_track_allocation (ACPI_MEM_LIST_GLOBAL, allocation, size,
+			   ACPI_MEM_CALLOC, component, module, line);
+	if (ACPI_FAILURE (status)) {
+		acpi_os_free (allocation);
+		return (NULL);
+	}
+
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_GLOBAL].total_allocated++;
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_GLOBAL].current_total_size += (u32) size;
+
+	return ((void *) &allocation->user_space);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_free_and_track
+ *
+ * PARAMETERS:  Allocation          - Address of the memory to deallocate
+ *              Component           - Component type of caller
+ *              Module              - Source file name of caller
+ *              Line                - Line number of caller
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Frees the memory at Allocation
+ *
+ ******************************************************************************/
+
+void
+acpi_ut_free_and_track (
+	void                            *allocation,
+	u32                             component,
+	char                            *module,
+	u32                             line)
+{
+	struct acpi_debug_mem_block     *debug_block;
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE_PTR ("ut_free", allocation);
+
+
+	if (NULL == allocation) {
+		_ACPI_REPORT_ERROR (module, line, component,
+			("acpi_ut_free: Attempt to delete a NULL address\n"));
+
+		return_VOID;
+	}
+
+	debug_block = ACPI_CAST_PTR (struct acpi_debug_mem_block,
+			  (((char *) allocation) - sizeof (struct acpi_debug_mem_header)));
+
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_GLOBAL].total_freed++;
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_GLOBAL].current_total_size -= debug_block->size;
+
+	status = acpi_ut_remove_allocation (ACPI_MEM_LIST_GLOBAL, debug_block,
+			  component, module, line);
+	if (ACPI_FAILURE (status)) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not free memory, %s\n",
+			acpi_format_exception (status)));
+	}
+
+	acpi_os_free (debug_block);
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "%p freed\n", allocation));
+
+	return_VOID;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_find_allocation
  *
- * PARAMETERS:  Address             - Address of allocated memory
+ * PARAMETERS:  Allocation             - Address of allocated memory
  *
  * RETURN:      A list element if found; NULL otherwise.
  *
@@ -218,15 +611,15 @@ acpi_ut_delete_generic_cache (
  *
  ******************************************************************************/
 
-acpi_debug_mem_block *
+struct acpi_debug_mem_block *
 acpi_ut_find_allocation (
-	u32                     list_id,
-	void                    *address)
+	u32                             list_id,
+	void                            *allocation)
 {
-	acpi_debug_mem_block    *element;
+	struct acpi_debug_mem_block     *element;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	if (list_id > ACPI_MEM_LIST_MAX) {
@@ -238,7 +631,7 @@ acpi_ut_find_allocation (
 	/* Search for the address. */
 
 	while (element) {
-		if (element == address) {
+		if (element == allocation) {
 			return (element);
 		}
 
@@ -251,11 +644,11 @@ acpi_ut_find_allocation (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_track_allocation
+ * FUNCTION:    acpi_ut_track_allocation
  *
- * PARAMETERS:  Address             - Address of allocated memory
+ * PARAMETERS:  Allocation          - Address of allocated memory
  *              Size                - Size of the allocation
- *              Alloc_type          - MEM_MALLOC or MEM_CALLOC
+ *              alloc_type          - MEM_MALLOC or MEM_CALLOC
  *              Component           - Component type of caller
  *              Module              - Source file name of caller
  *              Line                - Line number of caller
@@ -268,20 +661,20 @@ acpi_ut_find_allocation (
 
 acpi_status
 acpi_ut_track_allocation (
-	u32                     list_id,
-	acpi_debug_mem_block    *address,
-	u32                     size,
-	u8                      alloc_type,
-	u32                     component,
-	NATIVE_CHAR             *module,
-	u32                     line)
-{
-	ACPI_MEMORY_LIST        *mem_list;
-	acpi_debug_mem_block    *element;
-	acpi_status             status = AE_OK;
+	u32                             list_id,
+	struct acpi_debug_mem_block     *allocation,
+	acpi_size                       size,
+	u8                              alloc_type,
+	u32                             component,
+	char                            *module,
+	u32                             line)
+{
+	struct acpi_memory_list         *mem_list;
+	struct acpi_debug_mem_block     *element;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE_PTR ("Ut_track_allocation", address);
+	ACPI_FUNCTION_TRACE_PTR ("ut_track_allocation", allocation);
 
 
 	if (list_id > ACPI_MEM_LIST_MAX) {
@@ -289,55 +682,58 @@ acpi_ut_track_allocation (
 	}
 
 	mem_list = &acpi_gbl_memory_lists[list_id];
-	acpi_ut_acquire_mutex (ACPI_MTX_MEMORY);
+	status = acpi_ut_acquire_mutex (ACPI_MTX_MEMORY);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	/*
 	 * Search list for this address to make sure it is not already on the list.
 	 * This will catch several kinds of problems.
 	 */
 
-	element = acpi_ut_find_allocation (list_id, address);
+	element = acpi_ut_find_allocation (list_id, allocation);
 	if (element) {
-		REPORT_ERROR (("Ut_track_allocation: Address already present in list! (%p)\n",
-			address));
+		ACPI_REPORT_ERROR (("ut_track_allocation: Allocation already present in list! (%p)\n",
+			allocation));
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Element %p Address %p\n", element, address));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Element %p Address %p\n", element, allocation));
 
 		goto unlock_and_exit;
 	}
 
 	/* Fill in the instance data. */
 
-	address->size      = size;
-	address->alloc_type = alloc_type;
-	address->component = component;
-	address->line      = line;
+	allocation->size      = (u32) size;
+	allocation->alloc_type = alloc_type;
+	allocation->component = component;
+	allocation->line      = line;
 
-	STRNCPY (address->module, module, MAX_MODULE_NAME);
+	ACPI_STRNCPY (allocation->module, module, ACPI_MAX_MODULE_NAME);
 
 	/* Insert at list head */
 
 	if (mem_list->list_head) {
-		((acpi_debug_mem_block *)(mem_list->list_head))->previous = address;
+		((struct acpi_debug_mem_block *)(mem_list->list_head))->previous = allocation;
 	}
 
-	address->next = mem_list->list_head;
-	address->previous = NULL;
+	allocation->next = mem_list->list_head;
+	allocation->previous = NULL;
 
-	mem_list->list_head = address;
+	mem_list->list_head = allocation;
 
 
 unlock_and_exit:
-	acpi_ut_release_mutex (ACPI_MTX_MEMORY);
+	status = acpi_ut_release_mutex (ACPI_MTX_MEMORY);
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_remove_allocation
+ * FUNCTION:    acpi_ut_remove_allocation
  *
- * PARAMETERS:  Address             - Address of allocated memory
+ * PARAMETERS:  Allocation          - Address of allocated memory
  *              Component           - Component type of caller
  *              Module              - Source file name of caller
  *              Line                - Line number of caller
@@ -350,16 +746,17 @@ unlock_and_exit:
 
 acpi_status
 acpi_ut_remove_allocation (
-	u32                     list_id,
-	acpi_debug_mem_block    *address,
-	u32                     component,
-	NATIVE_CHAR             *module,
-	u32                     line)
+	u32                             list_id,
+	struct acpi_debug_mem_block     *allocation,
+	u32                             component,
+	char                            *module,
+	u32                             line)
 {
-	ACPI_MEMORY_LIST        *mem_list;
+	struct acpi_memory_list         *mem_list;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Ut_remove_allocation");
+	ACPI_FUNCTION_TRACE ("ut_remove_allocation");
 
 
 	if (list_id > ACPI_MEM_LIST_MAX) {
@@ -370,43 +767,44 @@ acpi_ut_remove_allocation (
 	if (NULL == mem_list->list_head) {
 		/* No allocations! */
 
-		_REPORT_ERROR (module, line, component,
-				("Ut_remove_allocation: Empty allocation list, nothing to free!\n"));
+		_ACPI_REPORT_ERROR (module, line, component,
+				("ut_remove_allocation: Empty allocation list, nothing to free!\n"));
 
 		return_ACPI_STATUS (AE_OK);
 	}
 
-
-	acpi_ut_acquire_mutex (ACPI_MTX_MEMORY);
+	status = acpi_ut_acquire_mutex (ACPI_MTX_MEMORY);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	/* Unlink */
 
-	if (address->previous) {
-		(address->previous)->next = address->next;
+	if (allocation->previous) {
+		(allocation->previous)->next = allocation->next;
 	}
 	else {
-		mem_list->list_head = address->next;
+		mem_list->list_head = allocation->next;
 	}
 
-	if (address->next) {
-		(address->next)->previous = address->previous;
+	if (allocation->next) {
+		(allocation->next)->previous = allocation->previous;
 	}
 
-
 	/* Mark the segment as deleted */
 
-	MEMSET (&address->user_space, 0xEA, address->size);
+	ACPI_MEMSET (&allocation->user_space, 0xEA, allocation->size);
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Freeing size %X\n", address->size));
+	ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Freeing size %X\n", allocation->size));
 
-	acpi_ut_release_mutex (ACPI_MTX_MEMORY);
-	return_ACPI_STATUS (AE_OK);
+	status = acpi_ut_release_mutex (ACPI_MTX_MEMORY);
+	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_dump_allocation_info
+ * FUNCTION:    acpi_ut_dump_allocation_info
  *
  * PARAMETERS:
  *
@@ -421,43 +819,43 @@ acpi_ut_dump_allocation_info (
 	void)
 {
 /*
-	ACPI_MEMORY_LIST        *Mem_list;
+	struct acpi_memory_list         *mem_list;
 */
 
-	FUNCTION_TRACE ("Ut_dump_allocation_info");
+	ACPI_FUNCTION_TRACE ("ut_dump_allocation_info");
 
 /*
 	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
 			  ("%30s: %4d (%3d Kb)\n", "Current allocations",
-			  Mem_list->Current_count,
-			  ROUND_UP_TO_1K (Mem_list->Current_size)));
+			  mem_list->current_count,
+			  ROUND_UP_TO_1K (mem_list->current_size)));
 
 	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
 			  ("%30s: %4d (%3d Kb)\n", "Max concurrent allocations",
-			  Mem_list->Max_concurrent_count,
-			  ROUND_UP_TO_1K (Mem_list->Max_concurrent_size)));
+			  mem_list->max_concurrent_count,
+			  ROUND_UP_TO_1K (mem_list->max_concurrent_size)));
 
 
 	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
 			  ("%30s: %4d (%3d Kb)\n", "Total (all) internal objects",
-			  Running_object_count,
-			  ROUND_UP_TO_1K (Running_object_size)));
+			  running_object_count,
+			  ROUND_UP_TO_1K (running_object_size)));
 
 	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
 			  ("%30s: %4d (%3d Kb)\n", "Total (all) allocations",
-			  Running_alloc_count,
-			  ROUND_UP_TO_1K (Running_alloc_size)));
+			  running_alloc_count,
+			  ROUND_UP_TO_1K (running_alloc_size)));
 
 
 	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
 			  ("%30s: %4d (%3d Kb)\n", "Current Nodes",
-			  Acpi_gbl_Current_node_count,
-			  ROUND_UP_TO_1K (Acpi_gbl_Current_node_size)));
+			  acpi_gbl_current_node_count,
+			  ROUND_UP_TO_1K (acpi_gbl_current_node_size)));
 
 	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
 			  ("%30s: %4d (%3d Kb)\n", "Max Nodes",
-			  Acpi_gbl_Max_concurrent_node_count,
-			  ROUND_UP_TO_1K ((Acpi_gbl_Max_concurrent_node_count * sizeof (acpi_namespace_node)))));
+			  acpi_gbl_max_concurrent_node_count,
+			  ROUND_UP_TO_1K ((acpi_gbl_max_concurrent_node_count * sizeof (struct acpi_namespace_node)))));
 */
 	return_VOID;
 }
@@ -465,7 +863,7 @@ acpi_ut_dump_allocation_info (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_dump_allocations
+ * FUNCTION:    acpi_ut_dump_allocations
  *
  * PARAMETERS:  Component           - Component(s) to dump info for.
  *              Module              - Module to dump info for.  NULL means all.
@@ -478,306 +876,124 @@ acpi_ut_dump_allocation_info (
 
 void
 acpi_ut_dump_allocations (
-	u32                     component,
-	NATIVE_CHAR             *module)
+	u32                             component,
+	char                            *module)
 {
-	acpi_debug_mem_block    *element;
-	u32                     i;
-
+	struct acpi_debug_mem_block     *element;
+	union acpi_descriptor           *descriptor;
+	u32                             num_outstanding = 0;
 
-	FUNCTION_TRACE ("Ut_dump_allocations");
 
-
-	element = acpi_gbl_memory_lists[0].list_head;
-	if (element == NULL) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_OK,
-				"No outstanding allocations.\n"));
-		return_VOID;
-	}
+	ACPI_FUNCTION_TRACE ("ut_dump_allocations");
 
 
 	/*
 	 * Walk the allocation list.
 	 */
-	acpi_ut_acquire_mutex (ACPI_MTX_MEMORY);
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_OK,
-		"Outstanding allocations:\n"));
+	if (ACPI_FAILURE (acpi_ut_acquire_mutex (ACPI_MTX_MEMORY))) {
+		return;
+	}
 
-	for (i = 1; ; i++)  /* Just a counter */ {
+	element = acpi_gbl_memory_lists[0].list_head;
+	while (element) {
 		if ((element->component & component) &&
-			((module == NULL) || (0 == STRCMP (module, element->module)))) {
-			if (((acpi_operand_object  *)(&element->user_space))->common.type != ACPI_CACHED_OBJECT) {
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK,
-						 "%p Len %04X %9.9s-%d",
-						 &element->user_space, element->size, element->module,
-						 element->line));
+			((module == NULL) || (0 == ACPI_STRCMP (module, element->module)))) {
+			/* Ignore allocated objects that are in a cache */
+
+			descriptor = ACPI_CAST_PTR (union acpi_descriptor, &element->user_space);
+			if (descriptor->descriptor_id != ACPI_DESC_TYPE_CACHED) {
+				acpi_os_printf ("%p Len %04X %9.9s-%d ",
+						 descriptor, element->size, element->module,
+						 element->line);
 
 				/* Most of the elements will be internal objects. */
 
-				switch (((acpi_operand_object  *)
-					(&element->user_space))->common.data_type) {
-				case ACPI_DESC_TYPE_INTERNAL:
-					ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK,
-							" Obj_type %12.12s R%d",
-							acpi_ut_get_type_name (((acpi_operand_object *)(&element->user_space))->common.type),
-							((acpi_operand_object *)(&element->user_space))->common.reference_count));
+				switch (ACPI_GET_DESCRIPTOR_TYPE (descriptor)) {
+				case ACPI_DESC_TYPE_OPERAND:
+					acpi_os_printf ("obj_type %12.12s R%hd",
+							acpi_ut_get_type_name (descriptor->object.common.type),
+							descriptor->object.common.reference_count);
 					break;
 
 				case ACPI_DESC_TYPE_PARSER:
-					ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK,
-							" Parse_obj Opcode %04X",
-							((acpi_parse_object *)(&element->user_space))->opcode));
+					acpi_os_printf ("parse_obj aml_opcode %04hX",
+							descriptor->op.asl.aml_opcode);
 					break;
 
 				case ACPI_DESC_TYPE_NAMED:
-					ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK,
-							" Node %4.4s",
-							(char*)&((acpi_namespace_node *)(&element->user_space))->name));
+					acpi_os_printf ("Node %4.4s",
+							descriptor->node.name.ascii);
 					break;
 
 				case ACPI_DESC_TYPE_STATE:
-					ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK,
-							" Untyped State_obj"));
+					acpi_os_printf ("Untyped state_obj");
 					break;
 
 				case ACPI_DESC_TYPE_STATE_UPDATE:
-					ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK,
-							" UPDATE State_obj"));
+					acpi_os_printf ("UPDATE state_obj");
 					break;
 
 				case ACPI_DESC_TYPE_STATE_PACKAGE:
-					ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK,
-							" PACKAGE State_obj"));
+					acpi_os_printf ("PACKAGE state_obj");
 					break;
 
 				case ACPI_DESC_TYPE_STATE_CONTROL:
-					ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK,
-							" CONTROL State_obj"));
+					acpi_os_printf ("CONTROL state_obj");
 					break;
 
 				case ACPI_DESC_TYPE_STATE_RPSCOPE:
-					ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK,
-							" ROOT-PARSE-SCOPE State_obj"));
+					acpi_os_printf ("ROOT-PARSE-SCOPE state_obj");
 					break;
 
 				case ACPI_DESC_TYPE_STATE_PSCOPE:
-					ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK,
-							" PARSE-SCOPE State_obj"));
+					acpi_os_printf ("PARSE-SCOPE state_obj");
 					break;
 
 				case ACPI_DESC_TYPE_STATE_WSCOPE:
-					ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK,
-							" WALK-SCOPE State_obj"));
+					acpi_os_printf ("WALK-SCOPE state_obj");
 					break;
 
 				case ACPI_DESC_TYPE_STATE_RESULT:
-					ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK,
-							" RESULT State_obj"));
+					acpi_os_printf ("RESULT state_obj");
 					break;
 
 				case ACPI_DESC_TYPE_STATE_NOTIFY:
-					ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK,
-							" NOTIFY State_obj"));
+					acpi_os_printf ("NOTIFY state_obj");
+					break;
+
+				case ACPI_DESC_TYPE_STATE_THREAD:
+					acpi_os_printf ("THREAD state_obj");
+					break;
+
+				default:
+					/* All types should appear above */
 					break;
 				}
 
-				ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK, "\n"));
+				acpi_os_printf ( "\n");
+				num_outstanding++;
 			}
 		}
-
-		if (element->next == NULL) {
-			break;
-		}
-
 		element = element->next;
 	}
 
-	acpi_ut_release_mutex (ACPI_MTX_MEMORY);
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_OK,
-		"Total number of unfreed allocations = %d(%X)\n", i,i));
-
-
-	return_VOID;
-
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ut_allocate
- *
- * PARAMETERS:  Size                - Size of the allocation
- *              Component           - Component type of caller
- *              Module              - Source file name of caller
- *              Line                - Line number of caller
- *
- * RETURN:      Address of the allocated memory on success, NULL on failure.
- *
- * DESCRIPTION: The subsystem's equivalent of malloc.
- *
- ******************************************************************************/
-
-void *
-acpi_ut_allocate (
-	u32                     size,
-	u32                     component,
-	NATIVE_CHAR             *module,
-	u32                     line)
-{
-	acpi_debug_mem_block    *address;
-	acpi_status             status;
+	(void) acpi_ut_release_mutex (ACPI_MTX_MEMORY);
 
+	/* Print summary */
 
-	FUNCTION_TRACE_U32 ("Ut_allocate", size);
-
-
-	/* Check for an inadvertent size of zero bytes */
-
-	if (!size) {
-		_REPORT_ERROR (module, line, component,
-				("Ut_allocate: Attempt to allocate zero bytes\n"));
-		size = 1;
-	}
-
-	address = acpi_os_allocate (size + sizeof (acpi_debug_mem_block));
-	if (!address) {
-		/* Report allocation error */
-
-		_REPORT_ERROR (module, line, component,
-				("Ut_allocate: Could not allocate size %X\n", size));
-
-		return_PTR (NULL);
-	}
-
-	status = acpi_ut_track_allocation (ACPI_MEM_LIST_GLOBAL, address, size,
-			  MEM_MALLOC, component, module, line);
-	if (ACPI_FAILURE (status)) {
-		acpi_os_free (address);
-		return_PTR (NULL);
-	}
-
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_GLOBAL].total_allocated++;
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_GLOBAL].current_total_size += size;
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "%p Size %X\n", address, size));
-
-	return_PTR ((void *) &address->user_space);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ut_callocate
- *
- * PARAMETERS:  Size                - Size of the allocation
- *              Component           - Component type of caller
- *              Module              - Source file name of caller
- *              Line                - Line number of caller
- *
- * RETURN:      Address of the allocated memory on success, NULL on failure.
- *
- * DESCRIPTION: Subsystem equivalent of calloc.
- *
- ******************************************************************************/
-
-void *
-acpi_ut_callocate (
-	u32                     size,
-	u32                     component,
-	NATIVE_CHAR             *module,
-	u32                     line)
-{
-	acpi_debug_mem_block    *address;
-	acpi_status             status;
-
-
-	FUNCTION_TRACE_U32 ("Ut_callocate", size);
-
-
-	/* Check for an inadvertent size of zero bytes */
-
-	if (!size) {
-		_REPORT_ERROR (module, line, component,
-				("Ut_callocate: Attempt to allocate zero bytes\n"));
-		return_PTR (NULL);
-	}
-
-
-	address = acpi_os_callocate (size + sizeof (acpi_debug_mem_block));
-	if (!address) {
-		/* Report allocation error */
-
-		_REPORT_ERROR (module, line, component,
-				("Ut_callocate: Could not allocate size %X\n", size));
-		return_PTR (NULL);
-	}
-
-	status = acpi_ut_track_allocation (ACPI_MEM_LIST_GLOBAL, address, size,
-			   MEM_CALLOC, component, module, line);
-	if (ACPI_FAILURE (status)) {
-		acpi_os_free (address);
-		return_PTR (NULL);
+	if (!num_outstanding) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"No outstanding allocations.\n"));
 	}
-
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_GLOBAL].total_allocated++;
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_GLOBAL].current_total_size += size;
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "%p Size %X\n", address, size));
-	return_PTR ((void *) &address->user_space);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ut_free
- *
- * PARAMETERS:  Address             - Address of the memory to deallocate
- *              Component           - Component type of caller
- *              Module              - Source file name of caller
- *              Line                - Line number of caller
- *
- * RETURN:      None
- *
- * DESCRIPTION: Frees the memory at Address
- *
- ******************************************************************************/
-
-void
-acpi_ut_free (
-	void                    *address,
-	u32                     component,
-	NATIVE_CHAR             *module,
-	u32                     line)
-{
-	acpi_debug_mem_block    *debug_block;
-
-
-	FUNCTION_TRACE_PTR ("Ut_free", address);
-
-
-	if (NULL == address) {
-		_REPORT_ERROR (module, line, component,
-			("Acpi_ut_free: Trying to delete a NULL address\n"));
-
-		return_VOID;
+	else {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"%d(%X) Outstanding allocations\n",
+			num_outstanding, num_outstanding));
 	}
 
-	debug_block = (acpi_debug_mem_block *)
-			  (((char *) address) - sizeof (acpi_debug_mem_header));
-
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_GLOBAL].total_freed++;
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_GLOBAL].current_total_size -= debug_block->size;
-
-	acpi_ut_remove_allocation (ACPI_MEM_LIST_GLOBAL, debug_block,
-			component, module, line);
-	acpi_os_free (debug_block);
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "%p freed\n", address));
-
 	return_VOID;
 }
 
+
 #endif  /* #ifdef ACPI_DBG_TRACK_ALLOCATIONS */
 
diff -urNp linux-5400/drivers/acpi/utilities/utcopy.c linux-5410/drivers/acpi/utilities/utcopy.c
--- linux-5400/drivers/acpi/utilities/utcopy.c
+++ linux-5410/drivers/acpi/utilities/utcopy.c
@@ -1,46 +1,62 @@
 /******************************************************************************
  *
  * Module Name: utcopy - Internal to external object translation utilities
- *              $Revision: 83 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acinterp.h"
-#include "acnamesp.h"
-#include "amlcode.h"
+#include <acpi/acpi.h>
+#include <acpi/amlcode.h>
 
 
 #define _COMPONENT          ACPI_UTILITIES
-	 MODULE_NAME         ("utcopy")
+	 ACPI_MODULE_NAME    ("utcopy")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_copy_isimple_to_esimple
+ * FUNCTION:    acpi_ut_copy_isimple_to_esimple
  *
- * PARAMETERS:  *Internal_object    - Pointer to the object we are examining
+ * PARAMETERS:  *internal_object    - Pointer to the object we are examining
  *              *Buffer             - Where the object is returned
- *              *Space_used         - Where the data length is returned
+ *              *space_used         - Where the data length is returned
  *
  * RETURN:      Status
  *
@@ -53,106 +69,77 @@
 
 static acpi_status
 acpi_ut_copy_isimple_to_esimple (
-	acpi_operand_object     *internal_object,
-	acpi_object             *external_object,
-	u8                      *data_space,
-	u32                     *buffer_space_used)
+	union acpi_operand_object       *internal_object,
+	union acpi_object               *external_object,
+	u8                              *data_space,
+	acpi_size                       *buffer_space_used)
 {
-	u32                     length = 0;
-	acpi_status             status = AE_OK;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE ("Ut_copy_isimple_to_esimple");
+	ACPI_FUNCTION_TRACE ("ut_copy_isimple_to_esimple");
 
 
+	*buffer_space_used = 0;
+
 	/*
 	 * Check for NULL object case (could be an uninitialized
-	 * package element
+	 * package element)
 	 */
 	if (!internal_object) {
-		*buffer_space_used = 0;
 		return_ACPI_STATUS (AE_OK);
 	}
 
 	/* Always clear the external object */
 
-	MEMSET (external_object, 0, sizeof (acpi_object));
+	ACPI_MEMSET (external_object, 0, sizeof (union acpi_object));
 
 	/*
 	 * In general, the external object will be the same type as
 	 * the internal object
 	 */
-	external_object->type = internal_object->common.type;
+	external_object->type = ACPI_GET_OBJECT_TYPE (internal_object);
 
 	/* However, only a limited number of external types are supported */
 
-	switch (internal_object->common.type) {
-
+	switch (ACPI_GET_OBJECT_TYPE (internal_object)) {
 	case ACPI_TYPE_STRING:
 
-		length = internal_object->string.length + 1;
+		external_object->string.pointer = (char *) data_space;
 		external_object->string.length = internal_object->string.length;
-		external_object->string.pointer = (NATIVE_CHAR *) data_space;
-		MEMCPY ((void *) data_space, (void *) internal_object->string.pointer, length);
+		*buffer_space_used = ACPI_ROUND_UP_TO_NATIVE_WORD ((acpi_size) internal_object->string.length + 1);
+
+		ACPI_MEMCPY ((void *) data_space, (void *) internal_object->string.pointer,
+				 (acpi_size) internal_object->string.length + 1);
 		break;
 
 
 	case ACPI_TYPE_BUFFER:
 
-		length = internal_object->buffer.length;
-		external_object->buffer.length = internal_object->buffer.length;
 		external_object->buffer.pointer = data_space;
-		MEMCPY ((void *) data_space, (void *) internal_object->buffer.pointer, length);
+		external_object->buffer.length = internal_object->buffer.length;
+		*buffer_space_used = ACPI_ROUND_UP_TO_NATIVE_WORD (internal_object->string.length);
+
+		ACPI_MEMCPY ((void *) data_space, (void *) internal_object->buffer.pointer,
+				 internal_object->buffer.length);
 		break;
 
 
 	case ACPI_TYPE_INTEGER:
 
-		external_object->integer.value= internal_object->integer.value;
+		external_object->integer.value = internal_object->integer.value;
 		break;
 
 
-	case INTERNAL_TYPE_REFERENCE:
+	case ACPI_TYPE_LOCAL_REFERENCE:
 
 		/*
 		 * This is an object reference.  Attempt to dereference it.
 		 */
 		switch (internal_object->reference.opcode) {
-		case AML_ZERO_OP:
-			external_object->type = ACPI_TYPE_INTEGER;
-			external_object->integer.value = 0;
-			break;
-
-		case AML_ONE_OP:
-			external_object->type = ACPI_TYPE_INTEGER;
-			external_object->integer.value = 1;
-			break;
-
-		case AML_ONES_OP:
-			external_object->type = ACPI_TYPE_INTEGER;
-			external_object->integer.value = ACPI_INTEGER_MAX;
-			break;
-
-		case AML_REVISION_OP:
-			external_object->type = ACPI_TYPE_INTEGER;
-			external_object->integer.value = ACPI_CA_SUPPORT_LEVEL;
-			break;
-
 		case AML_INT_NAMEPATH_OP:
-			/*
-			 * This is a named reference, get the string.  We already know that
-			 * we have room for it, use max length
-			 */
-			length = MAX_STRING_LENGTH;
-			external_object->type = ACPI_TYPE_STRING;
-			external_object->string.pointer = (NATIVE_CHAR *) data_space;
-			status = acpi_ns_handle_to_pathname ((acpi_handle *) internal_object->reference.node,
-					 &length, (char *) data_space);
-
-			/* Converted (external) string length is returned from above */
 
-			external_object->string.length = length;
-			break;
+			/* For namepath, return the object handle ("reference") */
 
 		default:
 			/*
@@ -168,7 +155,7 @@ acpi_ut_copy_isimple_to_esimple (
 
 	case ACPI_TYPE_PROCESSOR:
 
-		external_object->processor.proc_id = internal_object->processor.proc_id;
+		external_object->processor.proc_id    = internal_object->processor.proc_id;
 		external_object->processor.pblk_address = internal_object->processor.address;
 		external_object->processor.pblk_length = internal_object->processor.length;
 		break;
@@ -189,21 +176,17 @@ acpi_ut_copy_isimple_to_esimple (
 		 * There is no corresponding external object type
 		 */
 		return_ACPI_STATUS (AE_SUPPORT);
-		break;
 	}
 
-
-	*buffer_space_used = (u32) ROUND_UP_TO_NATIVE_WORD (length);
-
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_copy_ielement_to_eelement
+ * FUNCTION:    acpi_ut_copy_ielement_to_eelement
  *
- * PARAMETERS:  ACPI_PKG_CALLBACK
+ * PARAMETERS:  acpi_pkg_callback
  *
  * RETURN:      Status
  *
@@ -213,39 +196,39 @@ acpi_ut_copy_isimple_to_esimple (
 
 acpi_status
 acpi_ut_copy_ielement_to_eelement (
-	u8                      object_type,
-	acpi_operand_object     *source_object,
-	acpi_generic_state      *state,
-	void                    *context)
-{
-	acpi_status             status = AE_OK;
-	acpi_pkg_info           *info = (acpi_pkg_info *) context;
-	u32                     object_space;
-	u32                     this_index;
-	acpi_object             *target_object;
+	u8                              object_type,
+	union acpi_operand_object       *source_object,
+	union acpi_generic_state        *state,
+	void                            *context)
+{
+	acpi_status                     status = AE_OK;
+	struct acpi_pkg_info            *info = (struct acpi_pkg_info *) context;
+	acpi_size                       object_space;
+	u32                             this_index;
+	union acpi_object               *target_object;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	this_index   = state->pkg.index;
-	target_object = (acpi_object *)
-			  &((acpi_object *)(state->pkg.dest_object))->package.elements[this_index];
+	target_object = (union acpi_object *)
+			  &((union acpi_object *)(state->pkg.dest_object))->package.elements[this_index];
 
 	switch (object_type) {
 	case ACPI_COPY_TYPE_SIMPLE:
 
 		/*
-		 * This is a simple or null object -- get the size
+		 * This is a simple or null object
 		 */
 		status = acpi_ut_copy_isimple_to_esimple (source_object,
 				  target_object, info->free_space, &object_space);
 		if (ACPI_FAILURE (status)) {
 			return (status);
 		}
-
 		break;
 
+
 	case ACPI_COPY_TYPE_PACKAGE:
 
 		/*
@@ -253,7 +236,7 @@ acpi_ut_copy_ielement_to_eelement (
 		 */
 		target_object->type             = ACPI_TYPE_PACKAGE;
 		target_object->package.count    = source_object->package.count;
-		target_object->package.elements = (acpi_object *) info->free_space;
+		target_object->package.elements = ACPI_CAST_PTR (union acpi_object, info->free_space);
 
 		/*
 		 * Pass the new package object back to the package walk routine
@@ -264,29 +247,28 @@ acpi_ut_copy_ielement_to_eelement (
 		 * Save space for the array of objects (Package elements)
 		 * update the buffer length counter
 		 */
-		object_space = (u32) ROUND_UP_TO_NATIVE_WORD (
-				   target_object->package.count * sizeof (acpi_object));
+		object_space = ACPI_ROUND_UP_TO_NATIVE_WORD (
+				   (acpi_size) target_object->package.count * sizeof (union acpi_object));
 		break;
 
+
 	default:
 		return (AE_BAD_PARAMETER);
 	}
 
-
 	info->free_space  += object_space;
 	info->length      += object_space;
-
 	return (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_copy_ipackage_to_epackage
+ * FUNCTION:    acpi_ut_copy_ipackage_to_epackage
  *
- * PARAMETERS:  *Internal_object    - Pointer to the object we are returning
+ * PARAMETERS:  *internal_object    - Pointer to the object we are returning
  *              *Buffer             - Where the object is returned
- *              *Space_used         - Where the object length is returned
+ *              *space_used         - Where the object length is returned
  *
  * RETURN:      Status
  *
@@ -295,66 +277,64 @@ acpi_ut_copy_ielement_to_eelement (
  *
  *              The buffer is assumed to have sufficient space for the object.
  *              The caller must have verified the buffer length needed using the
- *              Acpi_ut_get_object_size function before calling this function.
+ *              acpi_ut_get_object_size function before calling this function.
  *
  ******************************************************************************/
 
 static acpi_status
 acpi_ut_copy_ipackage_to_epackage (
-	acpi_operand_object     *internal_object,
-	u8                      *buffer,
-	u32                     *space_used)
+	union acpi_operand_object       *internal_object,
+	u8                              *buffer,
+	acpi_size                       *space_used)
 {
-	acpi_object             *external_object;
-	acpi_status             status;
-	acpi_pkg_info           info;
+	union acpi_object               *external_object;
+	acpi_status                     status;
+	struct acpi_pkg_info            info;
 
 
-	FUNCTION_TRACE ("Ut_copy_ipackage_to_epackage");
+	ACPI_FUNCTION_TRACE ("ut_copy_ipackage_to_epackage");
 
 
 	/*
 	 * First package at head of the buffer
 	 */
-	external_object = (acpi_object *) buffer;
+	external_object = ACPI_CAST_PTR (union acpi_object, buffer);
 
 	/*
 	 * Free space begins right after the first package
 	 */
-	info.length      = 0;
+	info.length      = ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (union acpi_object));
+	info.free_space  = buffer + ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (union acpi_object));
 	info.object_space = 0;
 	info.num_packages = 1;
-	info.free_space  = buffer + ROUND_UP_TO_NATIVE_WORD (sizeof (acpi_object));
-
-
-	external_object->type              = internal_object->common.type;
-	external_object->package.count     = internal_object->package.count;
-	external_object->package.elements  = (acpi_object *) info.free_space;
 
+	external_object->type            = ACPI_GET_OBJECT_TYPE (internal_object);
+	external_object->package.count   = internal_object->package.count;
+	external_object->package.elements = ACPI_CAST_PTR (union acpi_object, info.free_space);
 
 	/*
-	 * Build an array of ACPI_OBJECTS in the buffer
+	 * Leave room for an array of ACPI_OBJECTS in the buffer
 	 * and move the free space past it
 	 */
+	info.length    += (acpi_size) external_object->package.count *
+			 ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (union acpi_object));
 	info.free_space += external_object->package.count *
-			  ROUND_UP_TO_NATIVE_WORD (sizeof (acpi_object));
-
+			 ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (union acpi_object));
 
 	status = acpi_ut_walk_package_tree (internal_object, external_object,
 			 acpi_ut_copy_ielement_to_eelement, &info);
 
 	*space_used = info.length;
-
 	return_ACPI_STATUS (status);
-
 }
 
+
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_copy_iobject_to_eobject
+ * FUNCTION:    acpi_ut_copy_iobject_to_eobject
  *
- * PARAMETERS:  *Internal_object    - The internal object to be converted
- *              *Buffer_ptr         - Where the object is returned
+ * PARAMETERS:  *internal_object    - The internal object to be converted
+ *              *buffer_ptr         - Where the object is returned
  *
  * RETURN:      Status
  *
@@ -365,16 +345,16 @@ acpi_ut_copy_ipackage_to_epackage (
 
 acpi_status
 acpi_ut_copy_iobject_to_eobject (
-	acpi_operand_object     *internal_object,
-	acpi_buffer             *ret_buffer)
+	union acpi_operand_object       *internal_object,
+	struct acpi_buffer              *ret_buffer)
 {
-	acpi_status             status;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Ut_copy_iobject_to_eobject");
+	ACPI_FUNCTION_TRACE ("ut_copy_iobject_to_eobject");
 
 
-	if (IS_THIS_OBJECT_TYPE (internal_object, ACPI_TYPE_PACKAGE)) {
+	if (ACPI_GET_OBJECT_TYPE (internal_object) == ACPI_TYPE_PACKAGE) {
 		/*
 		 * Package object:  Copy all subobjects (including
 		 * nested packages)
@@ -382,21 +362,20 @@ acpi_ut_copy_iobject_to_eobject (
 		status = acpi_ut_copy_ipackage_to_epackage (internal_object,
 				  ret_buffer->pointer, &ret_buffer->length);
 	}
-
 	else {
 		/*
 		 * Build a simple object (no nested objects)
 		 */
 		status = acpi_ut_copy_isimple_to_esimple (internal_object,
-				  (acpi_object *) ret_buffer->pointer,
+				  (union acpi_object *) ret_buffer->pointer,
 				  ((u8 *) ret_buffer->pointer +
-				  ROUND_UP_TO_NATIVE_WORD (sizeof (acpi_object))),
+				  ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (union acpi_object))),
 				  &ret_buffer->length);
 		/*
 		 * build simple does not include the object size in the length
 		 * so we add it in here
 		 */
-		ret_buffer->length += sizeof (acpi_object);
+		ret_buffer->length += sizeof (union acpi_object);
 	}
 
 	return_ACPI_STATUS (status);
@@ -405,10 +384,10 @@ acpi_ut_copy_iobject_to_eobject (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_copy_esimple_to_isimple
+ * FUNCTION:    acpi_ut_copy_esimple_to_isimple
  *
- * PARAMETERS:  *External_object   - The external object to be converted
- *              *Internal_object   - Where the internal object is returned
+ * PARAMETERS:  *external_object   - The external object to be converted
+ *              *internal_object   - Where the internal object is returned
  *
  * RETURN:      Status
  *
@@ -421,13 +400,13 @@ acpi_ut_copy_iobject_to_eobject (
 
 acpi_status
 acpi_ut_copy_esimple_to_isimple (
-	acpi_object             *external_object,
-	acpi_operand_object     **ret_internal_object)
+	union acpi_object               *external_object,
+	union acpi_operand_object       **ret_internal_object)
 {
-	acpi_operand_object     *internal_object;
+	union acpi_operand_object       *internal_object;
 
 
-	FUNCTION_TRACE ("Ut_copy_esimple_to_isimple");
+	ACPI_FUNCTION_TRACE ("ut_copy_esimple_to_isimple");
 
 
 	/*
@@ -449,7 +428,6 @@ acpi_ut_copy_esimple_to_isimple (
 		 * Whatever other type -- it is not supported
 		 */
 		return_ACPI_STATUS (AE_SUPPORT);
-		break;
 	}
 
 
@@ -459,14 +437,15 @@ acpi_ut_copy_esimple_to_isimple (
 
 	case ACPI_TYPE_STRING:
 
-		internal_object->string.pointer = ACPI_MEM_CALLOCATE (external_object->string.length + 1);
+		internal_object->string.pointer =
+			ACPI_MEM_CALLOCATE ((acpi_size) external_object->string.length + 1);
 		if (!internal_object->string.pointer) {
 			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
 
-		MEMCPY (internal_object->string.pointer,
-				external_object->string.pointer,
-				external_object->string.length);
+		ACPI_MEMCPY (internal_object->string.pointer,
+				  external_object->string.pointer,
+				  external_object->string.length);
 
 		internal_object->string.length = external_object->string.length;
 		break;
@@ -474,14 +453,15 @@ acpi_ut_copy_esimple_to_isimple (
 
 	case ACPI_TYPE_BUFFER:
 
-		internal_object->buffer.pointer = ACPI_MEM_CALLOCATE (external_object->buffer.length);
+		internal_object->buffer.pointer =
+			ACPI_MEM_CALLOCATE (external_object->buffer.length);
 		if (!internal_object->buffer.pointer) {
 			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
 
-		MEMCPY (internal_object->buffer.pointer,
-				external_object->buffer.pointer,
-				external_object->buffer.length);
+		ACPI_MEMCPY (internal_object->buffer.pointer,
+				  external_object->buffer.pointer,
+				  external_object->buffer.length);
 
 		internal_object->buffer.length = external_object->buffer.length;
 		break;
@@ -491,8 +471,11 @@ acpi_ut_copy_esimple_to_isimple (
 
 		internal_object->integer.value  = external_object->integer.value;
 		break;
-	}
 
+	default:
+		/* Other types can't get here */
+		break;
+	}
 
 	*ret_internal_object = internal_object;
 	return_ACPI_STATUS (AE_OK);
@@ -505,65 +488,64 @@ acpi_ut_copy_esimple_to_isimple (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_copy_epackage_to_ipackage
+ * FUNCTION:    acpi_ut_copy_epackage_to_ipackage
  *
- * PARAMETERS:  *Internal_object   - Pointer to the object we are returning
- *              *Buffer         - Where the object is returned
- *              *Space_used     - Where the length of the object is returned
+ * PARAMETERS:  *internal_object   - Pointer to the object we are returning
+ *              *Buffer            - Where the object is returned
+ *              *space_used        - Where the length of the object is returned
  *
- * RETURN:      Status          - the status of the call
+ * RETURN:      Status
  *
  * DESCRIPTION: This function is called to place a package object in a user
  *              buffer.  A package object by definition contains other objects.
  *
  *              The buffer is assumed to have sufficient space for the object.
  *              The caller must have verified the buffer length needed using the
- *              Acpi_ut_get_object_size function before calling this function.
+ *              acpi_ut_get_object_size function before calling this function.
  *
  ******************************************************************************/
 
 static acpi_status
 acpi_ut_copy_epackage_to_ipackage (
-	acpi_operand_object     *internal_object,
-	u8                      *buffer,
-	u32                     *space_used)
-{
-	u8                      *free_space;
-	acpi_object             *external_object;
-	u32                     length = 0;
-	u32                     this_index;
-	u32                     object_space = 0;
-	acpi_operand_object     *this_internal_obj;
-	acpi_object             *this_external_obj;
+	union acpi_operand_object       *internal_object,
+	u8                              *buffer,
+	u32                             *space_used)
+{
+	u8                              *free_space;
+	union acpi_object               *external_object;
+	u32                             length = 0;
+	u32                             this_index;
+	u32                             object_space = 0;
+	union acpi_operand_object       *this_internal_obj;
+	union acpi_object               *this_external_obj;
 
 
-	FUNCTION_TRACE ("Ut_copy_epackage_to_ipackage");
+	ACPI_FUNCTION_TRACE ("ut_copy_epackage_to_ipackage");
 
 
 	/*
 	 * First package at head of the buffer
 	 */
-	external_object = (acpi_object *)buffer;
+	external_object = (union acpi_object *)buffer;
 
 	/*
 	 * Free space begins right after the first package
 	 */
-	free_space = buffer + sizeof(acpi_object);
+	free_space = buffer + sizeof(union acpi_object);
 
 
-	external_object->type              = internal_object->common.type;
+	external_object->type              = ACPI_GET_OBJECT_TYPE (internal_object);
 	external_object->package.count     = internal_object->package.count;
-	external_object->package.elements  = (acpi_object *)free_space;
-
+	external_object->package.elements  = (union acpi_object *)free_space;
 
 	/*
 	 * Build an array of ACPI_OBJECTS in the buffer
 	 * and move the free space past it
 	 */
-	free_space += external_object->package.count * sizeof(acpi_object);
+	free_space += external_object->package.count * sizeof(union acpi_object);
 
 
-	/* Call Walk_package */
+	/* Call walk_package */
 
 }
 
@@ -572,10 +554,10 @@ acpi_ut_copy_epackage_to_ipackage (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_copy_eobject_to_iobject
+ * FUNCTION:    acpi_ut_copy_eobject_to_iobject
  *
- * PARAMETERS:  *Internal_object   - The external object to be converted
- *              *Buffer_ptr     - Where the internal object is returned
+ * PARAMETERS:  *internal_object   - The external object to be converted
+ *              *buffer_ptr     - Where the internal object is returned
  *
  * RETURN:      Status          - the status of the call
  *
@@ -585,29 +567,19 @@ acpi_ut_copy_epackage_to_ipackage (
 
 acpi_status
 acpi_ut_copy_eobject_to_iobject (
-	acpi_object             *external_object,
-	acpi_operand_object     **internal_object)
+	union acpi_object               *external_object,
+	union acpi_operand_object       **internal_object)
 {
-	acpi_status             status;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Ut_copy_eobject_to_iobject");
+	ACPI_FUNCTION_TRACE ("ut_copy_eobject_to_iobject");
 
 
 	if (external_object->type == ACPI_TYPE_PACKAGE) {
 		/*
-		 * Package objects contain other objects (which can be objects)
-		 * buildpackage does it all
-		 *
-		 * TBD: Package conversion must be completed and tested
-		 * NOTE: this code converts packages as input parameters to
-		 * control methods only.  This is a very, very rare case.
+		 * Packages as external input to control methods are not supported,
 		 */
-/*
-		Status = Acpi_ut_copy_epackage_to_ipackage(Internal_object,
-				 Ret_buffer->Pointer,
-				 &Ret_buffer->Length);
-*/
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"Packages as parameters not implemented!\n"));
 
@@ -627,11 +599,112 @@ acpi_ut_copy_eobject_to_iobject (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_copy_ielement_to_ielement
+ * FUNCTION:    acpi_ut_copy_simple_object
  *
- * PARAMETERS:  ACPI_PKG_CALLBACK
+ * PARAMETERS:  source_desc         - The internal object to be copied
+ *              dest_desc           - New target object
  *
- * RETURN:      Status          - the status of the call
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Simple copy of one internal object to another.  Reference count
+ *              of the destination object is preserved.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_copy_simple_object (
+	union acpi_operand_object       *source_desc,
+	union acpi_operand_object       *dest_desc)
+{
+	u16                             reference_count;
+	union acpi_operand_object       *next_object;
+
+
+	/* Save fields from destination that we don't want to overwrite */
+
+	reference_count = dest_desc->common.reference_count;
+	next_object = dest_desc->common.next_object;
+
+	/* Copy the entire source object over the destination object*/
+
+	ACPI_MEMCPY ((char *) dest_desc, (char *) source_desc,
+			  sizeof (union acpi_operand_object));
+
+	/* Restore the saved fields */
+
+	dest_desc->common.reference_count = reference_count;
+	dest_desc->common.next_object = next_object;
+
+	/* Handle the objects with extra data */
+
+	switch (ACPI_GET_OBJECT_TYPE (dest_desc)) {
+	case ACPI_TYPE_BUFFER:
+
+		dest_desc->buffer.node = NULL;
+		dest_desc->common.flags = source_desc->common.flags;
+
+		/*
+		 * Allocate and copy the actual buffer if and only if:
+		 * 1) There is a valid buffer pointer
+		 * 2) The buffer is not static (not in an ACPI table) (in this case,
+		 *    the actual pointer was already copied above)
+		 */
+		if ((source_desc->buffer.pointer) &&
+			(!(source_desc->common.flags & AOPOBJ_STATIC_POINTER))) {
+			dest_desc->buffer.pointer = NULL;
+
+			/* Create an actual buffer only if length > 0 */
+
+			if (source_desc->buffer.length) {
+				dest_desc->buffer.pointer = ACPI_MEM_ALLOCATE (source_desc->buffer.length);
+				if (!dest_desc->buffer.pointer) {
+					return (AE_NO_MEMORY);
+				}
+
+				/* Copy the actual buffer data */
+
+				ACPI_MEMCPY (dest_desc->buffer.pointer, source_desc->buffer.pointer,
+						  source_desc->buffer.length);
+			}
+		}
+		break;
+
+	case ACPI_TYPE_STRING:
+
+		/*
+		 * Allocate and copy the actual string if and only if:
+		 * 1) There is a valid string pointer
+		 * 2) The string is not static (not in an ACPI table) (in this case,
+		 *    the actual pointer was already copied above)
+		 */
+		if ((source_desc->string.pointer) &&
+			(!(source_desc->common.flags & AOPOBJ_STATIC_POINTER))) {
+			dest_desc->string.pointer = ACPI_MEM_ALLOCATE ((acpi_size) source_desc->string.length + 1);
+			if (!dest_desc->string.pointer) {
+				return (AE_NO_MEMORY);
+			}
+
+			ACPI_MEMCPY (dest_desc->string.pointer, source_desc->string.pointer,
+					  (acpi_size) source_desc->string.length + 1);
+		}
+		break;
+
+	default:
+		/* Nothing to do for other simple objects */
+		break;
+	}
+
+	return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_copy_ielement_to_ielement
+ *
+ * PARAMETERS:  acpi_pkg_callback
+ *
+ * RETURN:      Status
  *
  * DESCRIPTION: Copy one package element to another package element
  *
@@ -639,58 +712,78 @@ acpi_ut_copy_eobject_to_iobject (
 
 acpi_status
 acpi_ut_copy_ielement_to_ielement (
-	u8                      object_type,
-	acpi_operand_object     *source_object,
-	acpi_generic_state      *state,
-	void                    *context)
-{
-	acpi_status             status = AE_OK;
-	u32                     this_index;
-	acpi_operand_object     **this_target_ptr;
-	acpi_operand_object     *target_object;
+	u8                              object_type,
+	union acpi_operand_object       *source_object,
+	union acpi_generic_state        *state,
+	void                            *context)
+{
+	acpi_status                     status = AE_OK;
+	u32                             this_index;
+	union acpi_operand_object       **this_target_ptr;
+	union acpi_operand_object       *target_object;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	this_index    = state->pkg.index;
-	this_target_ptr = (acpi_operand_object **)
+	this_target_ptr = (union acpi_operand_object **)
 			   &state->pkg.dest_object->package.elements[this_index];
 
 	switch (object_type) {
-	case 0:
+	case ACPI_COPY_TYPE_SIMPLE:
 
-		/*
-		 * This is a simple object, just copy it
-		 */
-		target_object = acpi_ut_create_internal_object (source_object->common.type);
-		if (!target_object) {
-			return (AE_NO_MEMORY);
-		}
+		/* A null source object indicates a (legal) null package element */
 
-		status = acpi_ex_store_object_to_object (source_object, target_object,
-				  (acpi_walk_state *) context);
-		if (ACPI_FAILURE (status)) {
-			return (status);
+		if (source_object) {
+			/*
+			 * This is a simple object, just copy it
+			 */
+			target_object = acpi_ut_create_internal_object (
+					   ACPI_GET_OBJECT_TYPE (source_object));
+			if (!target_object) {
+				return (AE_NO_MEMORY);
+			}
+
+			status = acpi_ut_copy_simple_object (source_object, target_object);
+			if (ACPI_FAILURE (status)) {
+				return (status);
+			}
+
+			*this_target_ptr = target_object;
 		}
+		else {
+			/* Pass through a null element */
 
-		*this_target_ptr = target_object;
+			*this_target_ptr = NULL;
+		}
 		break;
 
 
-	case 1:
+	case ACPI_COPY_TYPE_PACKAGE:
+
 		/*
 		 * This object is a package - go down another nesting level
 		 * Create and build the package object
 		 */
 		target_object = acpi_ut_create_internal_object (ACPI_TYPE_PACKAGE);
 		if (!target_object) {
-			/* TBD: must delete package created up to this point */
-
 			return (AE_NO_MEMORY);
 		}
 
 		target_object->package.count = source_object->package.count;
+		target_object->common.flags = source_object->common.flags;
+
+		/*
+		 * Create the object array
+		 */
+		target_object->package.elements =
+			ACPI_MEM_CALLOCATE (((acpi_size) source_object->package.count + 1) *
+					 sizeof (void *));
+		if (!target_object->package.elements) {
+			ACPI_MEM_FREE (target_object);
+			return (AE_NO_MEMORY);
+		}
 
 		/*
 		 * Pass the new package object back to the package walk routine
@@ -703,21 +796,21 @@ acpi_ut_copy_ielement_to_ielement (
 		*this_target_ptr = target_object;
 		break;
 
+
 	default:
 		return (AE_BAD_PARAMETER);
 	}
 
-
 	return (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_copy_ipackage_to_ipackage
+ * FUNCTION:    acpi_ut_copy_ipackage_to_ipackage
  *
- * PARAMETERS:  *Source_obj     - Pointer to the source package object
- *              *Dest_obj       - Where the internal object is returned
+ * PARAMETERS:  *source_obj     - Pointer to the source package object
+ *              *dest_obj       - Where the internal object is returned
  *
  * RETURN:      Status          - the status of the call
  *
@@ -728,37 +821,92 @@ acpi_ut_copy_ielement_to_ielement (
 
 acpi_status
 acpi_ut_copy_ipackage_to_ipackage (
-	acpi_operand_object     *source_obj,
-	acpi_operand_object     *dest_obj,
-	acpi_walk_state         *walk_state)
+	union acpi_operand_object       *source_obj,
+	union acpi_operand_object       *dest_obj,
+	struct acpi_walk_state          *walk_state)
 {
-	acpi_status             status = AE_OK;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE ("Ut_copy_ipackage_to_ipackage");
+	ACPI_FUNCTION_TRACE ("ut_copy_ipackage_to_ipackage");
 
 
-	dest_obj->common.type   = source_obj->common.type;
+	dest_obj->common.type   = ACPI_GET_OBJECT_TYPE (source_obj);
+	dest_obj->common.flags  = source_obj->common.flags;
 	dest_obj->package.count = source_obj->package.count;
 
-
 	/*
 	 * Create the object array and walk the source package tree
 	 */
-	dest_obj->package.elements = ACPI_MEM_CALLOCATE ((source_obj->package.count + 1) *
-			 sizeof (void *));
-	dest_obj->package.next_element = dest_obj->package.elements;
-
+	dest_obj->package.elements = ACPI_MEM_CALLOCATE (
+			   ((acpi_size) source_obj->package.count + 1) *
+			   sizeof (void *));
 	if (!dest_obj->package.elements) {
-		REPORT_ERROR (
-			("Aml_build_copy_internal_package_object: Package allocation failure\n"));
+		ACPI_REPORT_ERROR (
+			("aml_build_copy_internal_package_object: Package allocation failure\n"));
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
-
+	/*
+	 * Copy the package element-by-element by walking the package "tree".
+	 * This handles nested packages of arbitrary depth.
+	 */
 	status = acpi_ut_walk_package_tree (source_obj, dest_obj,
 			 acpi_ut_copy_ielement_to_ielement, walk_state);
+	if (ACPI_FAILURE (status)) {
+		/* On failure, delete the destination package object */
+
+		acpi_ut_remove_reference (dest_obj);
+	}
+
+	return_ACPI_STATUS (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_copy_iobject_to_iobject
+ *
+ * PARAMETERS:  walk_state          - Current walk state
+ *              source_desc         - The internal object to be copied
+ *              dest_desc           - Where the copied object is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Copy an internal object to a new internal object
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_copy_iobject_to_iobject (
+	union acpi_operand_object       *source_desc,
+	union acpi_operand_object       **dest_desc,
+	struct acpi_walk_state          *walk_state)
+{
+	acpi_status                     status = AE_OK;
+
+
+	ACPI_FUNCTION_TRACE ("ut_copy_iobject_to_iobject");
+
+
+	/* Create the top level object */
+
+	*dest_desc = acpi_ut_create_internal_object (ACPI_GET_OBJECT_TYPE (source_desc));
+	if (!*dest_desc) {
+		return_ACPI_STATUS (AE_NO_MEMORY);
+	}
+
+	/* Copy the object and possible subobjects */
+
+	if (ACPI_GET_OBJECT_TYPE (source_desc) == ACPI_TYPE_PACKAGE) {
+		status = acpi_ut_copy_ipackage_to_ipackage (source_desc, *dest_desc,
+				  walk_state);
+	}
+	else {
+		status = acpi_ut_copy_simple_object (source_desc, *dest_desc);
+	}
 
 	return_ACPI_STATUS (status);
 }
 
+
diff -urNp linux-5400/drivers/acpi/utilities/utdebug.c linux-5410/drivers/acpi/utilities/utdebug.c
--- linux-5400/drivers/acpi/utilities/utdebug.c
+++ linux-5410/drivers/acpi/utilities/utdebug.c
@@ -1,46 +1,63 @@
 /******************************************************************************
  *
  * Module Name: utdebug - Debug print routines
- *              $Revision: 90 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
+#include <acpi/acpi.h>
 
 #define _COMPONENT          ACPI_UTILITIES
-	 MODULE_NAME         ("utdebug")
+	 ACPI_MODULE_NAME    ("utdebug")
 
 
-u32             acpi_gbl_prev_thread_id = 0xFFFFFFFF;
-char            *acpi_gbl_fn_entry_str = "----Entry";
-char            *acpi_gbl_fn_exit_str = "----Exit-";
+#ifdef ACPI_DEBUG_OUTPUT
 
-
-#ifdef ACPI_DEBUG
+static u32   acpi_gbl_prev_thread_id = 0xFFFFFFFF;
+static char     *acpi_gbl_fn_entry_str = "----Entry";
+static char     *acpi_gbl_fn_exit_str = "----Exit-";
 
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ut_init_stack_ptr_trace
+ * FUNCTION:    acpi_ut_init_stack_ptr_trace
  *
  * PARAMETERS:  None
  *
@@ -54,16 +71,16 @@ void
 acpi_ut_init_stack_ptr_trace (
 	void)
 {
-	u32                 current_sp;
+	u32                         current_sp;
 
 
-	acpi_gbl_entry_stack_pointer = (unsigned long) &current_sp;
+	acpi_gbl_entry_stack_pointer = ACPI_PTR_DIFF (&current_sp, NULL);
 }
 
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ut_track_stack_ptr
+ * FUNCTION:    acpi_ut_track_stack_ptr
  *
  * PARAMETERS:  None
  *
@@ -77,9 +94,10 @@ void
 acpi_ut_track_stack_ptr (
 	void)
 {
-	u32                 current_sp;
+	acpi_size                   current_sp;
+
 
-	current_sp = (u32) &current_sp;
+	current_sp = ACPI_PTR_DIFF (&current_sp, NULL);
 
 	if (current_sp < acpi_gbl_lowest_stack_pointer) {
 		acpi_gbl_lowest_stack_pointer = current_sp;
@@ -93,13 +111,13 @@ acpi_ut_track_stack_ptr (
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ut_debug_print
+ * FUNCTION:    acpi_ut_debug_print
  *
- * PARAMETERS:  Debug_level         - Requested debug print level
- *              Proc_name           - Caller's procedure name
- *              Module_name         - Caller's module name (for error output)
- *              Line_number         - Caller's line number (for error output)
- *              Component_id        - Caller's component ID (for error output)
+ * PARAMETERS:  debug_level         - Requested debug print level
+ *              proc_name           - Caller's procedure name
+ *              module_name         - Caller's module name (for error output)
+ *              line_number         - Caller's line number (for error output)
+ *              component_id        - Caller's component ID (for error output)
  *
  *              Format              - Printf format field
  *              ...                 - Optional printf arguments
@@ -111,15 +129,15 @@ acpi_ut_track_stack_ptr (
  *
  ****************************************************************************/
 
-void
+void  ACPI_INTERNAL_VAR_XFACE
 acpi_ut_debug_print (
-	u32                     requested_debug_level,
-	u32                     line_number,
-	acpi_debug_print_info   *dbg_info,
-	char                    *format,
+	u32                             requested_debug_level,
+	u32                             line_number,
+	struct acpi_debug_print_info    *dbg_info,
+	char                            *format,
 	...)
 {
-	u32                     thread_id;
+	u32                             thread_id;
 	va_list                 args;
 
 
@@ -131,7 +149,6 @@ acpi_ut_debug_print (
 		return;
 	}
 
-
 	/*
 	 * Thread tracking and context switch notification
 	 */
@@ -150,14 +167,13 @@ acpi_ut_debug_print (
 	 * Display the module name, current line number, thread ID (if requested),
 	 * current procedure nesting level, and the current procedure name
 	 */
-	acpi_os_printf ("%8s-%04d ", dbg_info->module_name, line_number);
+	acpi_os_printf ("%8s-%04ld ", dbg_info->module_name, line_number);
 
 	if (ACPI_LV_THREADS & acpi_dbg_level) {
-		acpi_os_printf ("[%04X] ", thread_id, acpi_gbl_nesting_level, dbg_info->proc_name);
+		acpi_os_printf ("[%04lX] ", thread_id);
 	}
 
-	acpi_os_printf ("[%02d] %-22.22s: ", acpi_gbl_nesting_level, dbg_info->proc_name);
-
+	acpi_os_printf ("[%02ld] %-22.22s: ", acpi_gbl_nesting_level, dbg_info->proc_name);
 
 	va_start (args, format);
 	acpi_os_vprintf (format, args);
@@ -166,30 +182,30 @@ acpi_ut_debug_print (
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ut_debug_print_raw
+ * FUNCTION:    acpi_ut_debug_print_raw
  *
- * PARAMETERS:  Requested_debug_level - Requested debug print level
- *              Line_number         - Caller's line number
- *              Dbg_info            - Contains:
- *                  Proc_name           - Caller's procedure name
- *                  Module_name         - Caller's module name
- *                  Component_id        - Caller's component ID
+ * PARAMETERS:  requested_debug_level - Requested debug print level
+ *              line_number         - Caller's line number
+ *              dbg_info            - Contains:
+ *                  proc_name           - Caller's procedure name
+ *                  module_name         - Caller's module name
+ *                  component_id        - Caller's component ID
  *              Format              - Printf format field
  *              ...                 - Optional printf arguments
  *
  * RETURN:      None
  *
  * DESCRIPTION: Print message with no headers.  Has same interface as
- *              Debug_print so that the same macros can be used.
+ *              debug_print so that the same macros can be used.
  *
  ****************************************************************************/
 
-void
+void  ACPI_INTERNAL_VAR_XFACE
 acpi_ut_debug_print_raw (
-	u32                     requested_debug_level,
-	u32                     line_number,
-	acpi_debug_print_info   *dbg_info,
-	char                    *format,
+	u32                             requested_debug_level,
+	u32                             line_number,
+	struct acpi_debug_print_info    *dbg_info,
+	char                            *format,
 	...)
 {
 	va_list                 args;
@@ -201,32 +217,31 @@ acpi_ut_debug_print_raw (
 	}
 
 	va_start (args, format);
-
 	acpi_os_vprintf (format, args);
 }
 
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ut_trace
+ * FUNCTION:    acpi_ut_trace
  *
- * PARAMETERS:  Line_number         - Caller's line number
- *              Dbg_info            - Contains:
- *                  Proc_name           - Caller's procedure name
- *                  Module_name         - Caller's module name
- *                  Component_id        - Caller's component ID
+ * PARAMETERS:  line_number         - Caller's line number
+ *              dbg_info            - Contains:
+ *                  proc_name           - Caller's procedure name
+ *                  module_name         - Caller's module name
+ *                  component_id        - Caller's component ID
  *
  * RETURN:      None
  *
  * DESCRIPTION: Function entry trace.  Prints only if TRACE_FUNCTIONS bit is
- *              set in Debug_level
+ *              set in debug_level
  *
  ****************************************************************************/
 
 void
 acpi_ut_trace (
-	u32                     line_number,
-	acpi_debug_print_info   *dbg_info)
+	u32                             line_number,
+	struct acpi_debug_print_info    *dbg_info)
 {
 
 	acpi_gbl_nesting_level++;
@@ -239,27 +254,27 @@ acpi_ut_trace (
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ut_trace_ptr
+ * FUNCTION:    acpi_ut_trace_ptr
  *
- * PARAMETERS:  Line_number         - Caller's line number
- *              Dbg_info            - Contains:
- *                  Proc_name           - Caller's procedure name
- *                  Module_name         - Caller's module name
- *                  Component_id        - Caller's component ID
+ * PARAMETERS:  line_number         - Caller's line number
+ *              dbg_info            - Contains:
+ *                  proc_name           - Caller's procedure name
+ *                  module_name         - Caller's module name
+ *                  component_id        - Caller's component ID
  *              Pointer             - Pointer to display
  *
  * RETURN:      None
  *
  * DESCRIPTION: Function entry trace.  Prints only if TRACE_FUNCTIONS bit is
- *              set in Debug_level
+ *              set in debug_level
  *
  ****************************************************************************/
 
 void
 acpi_ut_trace_ptr (
-	u32                     line_number,
-	acpi_debug_print_info   *dbg_info,
-	void                    *pointer)
+	u32                             line_number,
+	struct acpi_debug_print_info    *dbg_info,
+	void                            *pointer)
 {
 	acpi_gbl_nesting_level++;
 	acpi_ut_track_stack_ptr ();
@@ -271,27 +286,27 @@ acpi_ut_trace_ptr (
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ut_trace_str
+ * FUNCTION:    acpi_ut_trace_str
  *
- * PARAMETERS:  Line_number         - Caller's line number
- *              Dbg_info            - Contains:
- *                  Proc_name           - Caller's procedure name
- *                  Module_name         - Caller's module name
- *                  Component_id        - Caller's component ID
+ * PARAMETERS:  line_number         - Caller's line number
+ *              dbg_info            - Contains:
+ *                  proc_name           - Caller's procedure name
+ *                  module_name         - Caller's module name
+ *                  component_id        - Caller's component ID
  *              String              - Additional string to display
  *
  * RETURN:      None
  *
  * DESCRIPTION: Function entry trace.  Prints only if TRACE_FUNCTIONS bit is
- *              set in Debug_level
+ *              set in debug_level
  *
  ****************************************************************************/
 
 void
 acpi_ut_trace_str (
-	u32                     line_number,
-	acpi_debug_print_info   *dbg_info,
-	NATIVE_CHAR             *string)
+	u32                             line_number,
+	struct acpi_debug_print_info    *dbg_info,
+	char                            *string)
 {
 
 	acpi_gbl_nesting_level++;
@@ -304,27 +319,27 @@ acpi_ut_trace_str (
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ut_trace_u32
+ * FUNCTION:    acpi_ut_trace_u32
  *
- * PARAMETERS:  Line_number         - Caller's line number
- *              Dbg_info            - Contains:
- *                  Proc_name           - Caller's procedure name
- *                  Module_name         - Caller's module name
- *                  Component_id        - Caller's component ID
+ * PARAMETERS:  line_number         - Caller's line number
+ *              dbg_info            - Contains:
+ *                  proc_name           - Caller's procedure name
+ *                  module_name         - Caller's module name
+ *                  component_id        - Caller's component ID
  *              Integer             - Integer to display
  *
  * RETURN:      None
  *
  * DESCRIPTION: Function entry trace.  Prints only if TRACE_FUNCTIONS bit is
- *              set in Debug_level
+ *              set in debug_level
  *
  ****************************************************************************/
 
 void
 acpi_ut_trace_u32 (
-	u32                     line_number,
-	acpi_debug_print_info   *dbg_info,
-	u32                     integer)
+	u32                             line_number,
+	struct acpi_debug_print_info    *dbg_info,
+	u32                             integer)
 {
 
 	acpi_gbl_nesting_level++;
@@ -337,25 +352,25 @@ acpi_ut_trace_u32 (
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ut_exit
+ * FUNCTION:    acpi_ut_exit
  *
- * PARAMETERS:  Line_number         - Caller's line number
- *              Dbg_info            - Contains:
- *                  Proc_name           - Caller's procedure name
- *                  Module_name         - Caller's module name
- *                  Component_id        - Caller's component ID
+ * PARAMETERS:  line_number         - Caller's line number
+ *              dbg_info            - Contains:
+ *                  proc_name           - Caller's procedure name
+ *                  module_name         - Caller's module name
+ *                  component_id        - Caller's component ID
  *
  * RETURN:      None
  *
  * DESCRIPTION: Function exit trace.  Prints only if TRACE_FUNCTIONS bit is
- *              set in Debug_level
+ *              set in debug_level
  *
  ****************************************************************************/
 
 void
 acpi_ut_exit (
-	u32                     line_number,
-	acpi_debug_print_info   *dbg_info)
+	u32                             line_number,
+	struct acpi_debug_print_info    *dbg_info)
 {
 
 	acpi_ut_debug_print (ACPI_LV_FUNCTIONS, line_number, dbg_info,
@@ -367,27 +382,27 @@ acpi_ut_exit (
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ut_status_exit
+ * FUNCTION:    acpi_ut_status_exit
  *
- * PARAMETERS:  Line_number         - Caller's line number
- *              Dbg_info            - Contains:
- *                  Proc_name           - Caller's procedure name
- *                  Module_name         - Caller's module name
- *                  Component_id        - Caller's component ID
+ * PARAMETERS:  line_number         - Caller's line number
+ *              dbg_info            - Contains:
+ *                  proc_name           - Caller's procedure name
+ *                  module_name         - Caller's module name
+ *                  component_id        - Caller's component ID
  *              Status              - Exit status code
  *
  * RETURN:      None
  *
  * DESCRIPTION: Function exit trace.  Prints only if TRACE_FUNCTIONS bit is
- *              set in Debug_level. Prints exit status also.
+ *              set in debug_level. Prints exit status also.
  *
  ****************************************************************************/
 
 void
 acpi_ut_status_exit (
-	u32                     line_number,
-	acpi_debug_print_info   *dbg_info,
-	acpi_status             status)
+	u32                             line_number,
+	struct acpi_debug_print_info    *dbg_info,
+	acpi_status                     status)
 {
 
 	if (ACPI_SUCCESS (status)) {
@@ -407,31 +422,32 @@ acpi_ut_status_exit (
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ut_value_exit
+ * FUNCTION:    acpi_ut_value_exit
  *
- * PARAMETERS:  Line_number         - Caller's line number
- *              Dbg_info            - Contains:
- *                  Proc_name           - Caller's procedure name
- *                  Module_name         - Caller's module name
- *                  Component_id        - Caller's component ID
+ * PARAMETERS:  line_number         - Caller's line number
+ *              dbg_info            - Contains:
+ *                  proc_name           - Caller's procedure name
+ *                  module_name         - Caller's module name
+ *                  component_id        - Caller's component ID
  *              Value               - Value to be printed with exit msg
  *
  * RETURN:      None
  *
  * DESCRIPTION: Function exit trace.  Prints only if TRACE_FUNCTIONS bit is
- *              set in Debug_level. Prints exit value also.
+ *              set in debug_level. Prints exit value also.
  *
  ****************************************************************************/
 
 void
 acpi_ut_value_exit (
-	u32                     line_number,
-	acpi_debug_print_info   *dbg_info,
-	acpi_integer            value)
+	u32                             line_number,
+	struct acpi_debug_print_info    *dbg_info,
+	acpi_integer                    value)
 {
 
 	acpi_ut_debug_print (ACPI_LV_FUNCTIONS, line_number, dbg_info,
-			"%s %8.8X%8.8X\n", acpi_gbl_fn_exit_str, HIDWORD(value), LODWORD(value));
+			"%s %8.8X%8.8X\n", acpi_gbl_fn_exit_str,
+			ACPI_HIDWORD (value), ACPI_LODWORD (value));
 
 	acpi_gbl_nesting_level--;
 }
@@ -439,27 +455,27 @@ acpi_ut_value_exit (
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ut_ptr_exit
+ * FUNCTION:    acpi_ut_ptr_exit
  *
- * PARAMETERS:  Line_number         - Caller's line number
- *              Dbg_info            - Contains:
- *                  Proc_name           - Caller's procedure name
- *                  Module_name         - Caller's module name
- *                  Component_id        - Caller's component ID
+ * PARAMETERS:  line_number         - Caller's line number
+ *              dbg_info            - Contains:
+ *                  proc_name           - Caller's procedure name
+ *                  module_name         - Caller's module name
+ *                  component_id        - Caller's component ID
  *              Value               - Value to be printed with exit msg
  *
  * RETURN:      None
  *
  * DESCRIPTION: Function exit trace.  Prints only if TRACE_FUNCTIONS bit is
- *              set in Debug_level. Prints exit value also.
+ *              set in debug_level. Prints exit value also.
  *
  ****************************************************************************/
 
 void
 acpi_ut_ptr_exit (
-	u32                     line_number,
-	acpi_debug_print_info   *dbg_info,
-	u8                      *ptr)
+	u32                             line_number,
+	struct acpi_debug_print_info    *dbg_info,
+	u8                              *ptr)
 {
 
 	acpi_ut_debug_print (ACPI_LV_FUNCTIONS, line_number, dbg_info,
@@ -473,12 +489,12 @@ acpi_ut_ptr_exit (
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ut_dump_buffer
+ * FUNCTION:    acpi_ut_dump_buffer
  *
  * PARAMETERS:  Buffer              - Buffer to dump
  *              Count               - Amount to dump, in bytes
  *              Display             - BYTE, WORD, DWORD, or QWORD display
- *              Component_iD        - Caller's component ID
+ *              component_iD        - Caller's component ID
  *
  * RETURN:      None
  *
@@ -488,15 +504,15 @@ acpi_ut_ptr_exit (
 
 void
 acpi_ut_dump_buffer (
-	u8                      *buffer,
-	u32                     count,
-	u32                     display,
-	u32                     component_id)
-{
-	u32                     i = 0;
-	u32                     j;
-	u32                     temp32;
-	u8                      buf_char;
+	u8                              *buffer,
+	u32                             count,
+	u32                             display,
+	u32                             component_id)
+{
+	acpi_native_uint                i = 0;
+	acpi_native_uint                j;
+	u32                             temp32;
+	u8                              buf_char;
 
 
 	/* Only dump the buffer if tracing is enabled */
@@ -506,6 +522,11 @@ acpi_ut_dump_buffer (
 		return;
 	}
 
+	if ((count < 4) || (count & 0x01)) {
+		display = DB_BYTE_DISPLAY;
+	}
+
+	acpi_os_printf ("\nOffset Value\n");
 
 	/*
 	 * Nasty little dump buffer routine!
@@ -513,8 +534,7 @@ acpi_ut_dump_buffer (
 	while (i < count) {
 		/* Print current offset */
 
-		acpi_os_printf ("%05X  ", i);
-
+		acpi_os_printf ("%05X  ", (u32) i);
 
 		/* Print 16 hex chars */
 
@@ -539,8 +559,7 @@ acpi_ut_dump_buffer (
 
 			case DB_WORD_DISPLAY:
 
-				MOVE_UNALIGNED16_TO_32 (&temp32,
-						 &buffer[i + j]);
+				ACPI_MOVE_16_TO_32 (&temp32, &buffer[i + j]);
 				acpi_os_printf ("%04X ", temp32);
 				j += 2;
 				break;
@@ -548,8 +567,7 @@ acpi_ut_dump_buffer (
 
 			case DB_DWORD_DISPLAY:
 
-				MOVE_UNALIGNED32_TO_32 (&temp32,
-						 &buffer[i + j]);
+				ACPI_MOVE_32_TO_32 (&temp32, &buffer[i + j]);
 				acpi_os_printf ("%08X ", temp32);
 				j += 4;
 				break;
@@ -557,24 +575,20 @@ acpi_ut_dump_buffer (
 
 			case DB_QWORD_DISPLAY:
 
-				MOVE_UNALIGNED32_TO_32 (&temp32,
-						 &buffer[i + j]);
+				ACPI_MOVE_32_TO_32 (&temp32, &buffer[i + j]);
 				acpi_os_printf ("%08X", temp32);
 
-				MOVE_UNALIGNED32_TO_32 (&temp32,
-						 &buffer[i + j + 4]);
+				ACPI_MOVE_32_TO_32 (&temp32, &buffer[i + j + 4]);
 				acpi_os_printf ("%08X ", temp32);
 				j += 8;
 				break;
 			}
 		}
 
-
 		/*
 		 * Print the ASCII equivalent characters
 		 * But watch out for the bad unprintable ones...
 		 */
-
 		for (j = 0; j < 16; j++) {
 			if (i + j >= count) {
 				acpi_os_printf ("\n");
diff -urNp linux-5400/drivers/acpi/utilities/utdelete.c linux-5410/drivers/acpi/utilities/utdelete.c
--- linux-5400/drivers/acpi/utilities/utdelete.c
+++ linux-5410/drivers/acpi/utilities/utdelete.c
@@ -1,42 +1,59 @@
 /*******************************************************************************
  *
  * Module Name: utdelete - object deletion and reference count utilities
- *              $Revision: 81 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acinterp.h"
-#include "acnamesp.h"
-#include "actables.h"
-#include "acparser.h"
+#include <acpi/acpi.h>
+#include <acpi/acinterp.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acevents.h>
 
 #define _COMPONENT          ACPI_UTILITIES
-	 MODULE_NAME         ("utdelete")
+	 ACPI_MODULE_NAME    ("utdelete")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_delete_internal_obj
+ * FUNCTION:    acpi_ut_delete_internal_obj
  *
  * PARAMETERS:  *Object        - Pointer to the list to be deleted
  *
@@ -49,13 +66,15 @@
 
 void
 acpi_ut_delete_internal_obj (
-	acpi_operand_object     *object)
+	union acpi_operand_object       *object)
 {
-	void                    *obj_pointer = NULL;
-	acpi_operand_object     *handler_desc;
+	void                            *obj_pointer = NULL;
+	union acpi_operand_object       *handler_desc;
+	union acpi_operand_object       *second_desc;
+	union acpi_operand_object       *next_desc;
 
 
-	FUNCTION_TRACE_PTR ("Ut_delete_internal_obj", object);
+	ACPI_FUNCTION_TRACE_PTR ("ut_delete_internal_obj", object);
 
 
 	if (!object) {
@@ -66,16 +85,17 @@ acpi_ut_delete_internal_obj (
 	 * Must delete or free any pointers within the object that are not
 	 * actual ACPI objects (for example, a raw buffer pointer).
 	 */
-	switch (object->common.type) {
-
+	switch (ACPI_GET_OBJECT_TYPE (object)) {
 	case ACPI_TYPE_STRING:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "**** String %p, ptr %p\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "**** String %p, ptr %p\n",
 			object, object->string.pointer));
 
 		/* Free the actual string buffer */
 
 		if (!(object->common.flags & AOPOBJ_STATIC_POINTER)) {
+			/* But only if it is NOT a pointer into an ACPI table */
+
 			obj_pointer = object->string.pointer;
 		}
 		break;
@@ -83,18 +103,22 @@ acpi_ut_delete_internal_obj (
 
 	case ACPI_TYPE_BUFFER:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "**** Buffer %p, ptr %p\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "**** Buffer %p, ptr %p\n",
 			object, object->buffer.pointer));
 
 		/* Free the actual buffer */
 
-		obj_pointer = object->buffer.pointer;
+		if (!(object->common.flags & AOPOBJ_STATIC_POINTER)) {
+			/* But only if it is NOT a pointer into an ACPI table */
+
+			obj_pointer = object->buffer.pointer;
+		}
 		break;
 
 
 	case ACPI_TYPE_PACKAGE:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, " **** Package of count %X\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, " **** Package of count %X\n",
 			object->package.count));
 
 		/*
@@ -108,124 +132,137 @@ acpi_ut_delete_internal_obj (
 		break;
 
 
+	case ACPI_TYPE_DEVICE:
+
+		if (object->device.gpe_block) {
+			(void) acpi_ev_delete_gpe_block (object->device.gpe_block);
+		}
+
+		/* Walk the handler list for this device */
+
+		handler_desc = object->device.address_space;
+		while (handler_desc) {
+			next_desc = handler_desc->address_space.next;
+			acpi_ut_remove_reference (handler_desc);
+			handler_desc = next_desc;
+		}
+		break;
+
+
 	case ACPI_TYPE_MUTEX:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "***** Mutex %p, Semaphore %p\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "***** Mutex %p, Semaphore %p\n",
 			object, object->mutex.semaphore));
 
 		acpi_ex_unlink_mutex (object);
-		acpi_os_delete_semaphore (object->mutex.semaphore);
+		(void) acpi_os_delete_semaphore (object->mutex.semaphore);
 		break;
 
 
 	case ACPI_TYPE_EVENT:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "***** Event %p, Semaphore %p\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "***** Event %p, Semaphore %p\n",
 			object, object->event.semaphore));
 
-		acpi_os_delete_semaphore (object->event.semaphore);
+		(void) acpi_os_delete_semaphore (object->event.semaphore);
 		object->event.semaphore = NULL;
 		break;
 
 
 	case ACPI_TYPE_METHOD:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "***** Method %p\n", object));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "***** Method %p\n", object));
 
 		/* Delete the method semaphore if it exists */
 
 		if (object->method.semaphore) {
-			acpi_os_delete_semaphore (object->method.semaphore);
+			(void) acpi_os_delete_semaphore (object->method.semaphore);
 			object->method.semaphore = NULL;
 		}
-
 		break;
 
 
 	case ACPI_TYPE_REGION:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "***** Region %p\n", object));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "***** Region %p\n", object));
 
-		if (object->region.extra) {
+		second_desc = acpi_ns_get_secondary_object (object);
+		if (second_desc) {
 			/*
-			 * Free the Region_context if and only if the handler is one of the
+			 * Free the region_context if and only if the handler is one of the
 			 * default handlers -- and therefore, we created the context object
 			 * locally, it was not created by an external caller.
 			 */
-			handler_desc = object->region.addr_handler;
-			if ((handler_desc) &&
-				(handler_desc->addr_handler.hflags == ADDR_HANDLER_DEFAULT_INSTALLED)) {
-				obj_pointer = object->region.extra->extra.region_context;
+			handler_desc = object->region.address_space;
+			if (handler_desc) {
+				if (handler_desc->address_space.hflags & ACPI_ADDR_HANDLER_DEFAULT_INSTALLED) {
+					obj_pointer = second_desc->extra.region_context;
+				}
+
+				acpi_ut_remove_reference (handler_desc);
 			}
 
 			/* Now we can free the Extra object */
 
-			acpi_ut_delete_object_desc (object->region.extra);
+			acpi_ut_delete_object_desc (second_desc);
 		}
 		break;
 
 
 	case ACPI_TYPE_BUFFER_FIELD:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "***** Buffer Field %p\n", object));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "***** Buffer Field %p\n", object));
 
-		if (object->buffer_field.extra) {
-			acpi_ut_delete_object_desc (object->buffer_field.extra);
+		second_desc = acpi_ns_get_secondary_object (object);
+		if (second_desc) {
+			acpi_ut_delete_object_desc (second_desc);
 		}
 		break;
 
+
 	default:
 		break;
 	}
 
+	/* Free any allocated memory (pointer within the object) found above */
 
-	/*
-	 * Delete any allocated memory found above
-	 */
 	if (obj_pointer) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Deleting Obj Ptr %p \n", obj_pointer));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Deleting Object Subptr %p\n",
+				obj_pointer));
 		ACPI_MEM_FREE (obj_pointer);
 	}
 
-	/* Only delete the object if it was dynamically allocated */
-
-	if (object->common.flags & AOPOBJ_STATIC_ALLOCATION) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Object %p [%s] static allocation, no delete\n",
-			object, acpi_ut_get_type_name (object->common.type)));
-	}
-
-	if (!(object->common.flags & AOPOBJ_STATIC_ALLOCATION)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Deleting object %p [%s]\n",
-			object, acpi_ut_get_type_name (object->common.type)));
+	/* Now the object can be safely deleted */
 
-		acpi_ut_delete_object_desc (object);
-	}
+	ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Deleting Object %p [%s]\n",
+			object, acpi_ut_get_object_type_name (object)));
 
+	acpi_ut_delete_object_desc (object);
 	return_VOID;
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_delete_internal_object_list
+ * FUNCTION:    acpi_ut_delete_internal_object_list
  *
- * PARAMETERS:  *Obj_list       - Pointer to the list to be deleted
+ * PARAMETERS:  *obj_list       - Pointer to the list to be deleted
  *
- * RETURN:      Status          - the status of the call
+ * RETURN:      None
  *
  * DESCRIPTION: This function deletes an internal object list, including both
  *              simple objects and package objects
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ut_delete_internal_object_list (
-	acpi_operand_object     **obj_list)
+	union acpi_operand_object       **obj_list)
 {
-	acpi_operand_object     **internal_obj;
+	union acpi_operand_object       **internal_obj;
 
 
-	FUNCTION_TRACE ("Ut_delete_internal_object_list");
+	ACPI_FUNCTION_TRACE ("ut_delete_internal_object_list");
 
 
 	/* Walk the null-terminated internal list */
@@ -237,14 +274,13 @@ acpi_ut_delete_internal_object_list (
 	/* Free the combined parameter pointer list and object array */
 
 	ACPI_MEM_FREE (obj_list);
-
-	return_ACPI_STATUS (AE_OK);
+	return_VOID;
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_update_ref_count
+ * FUNCTION:    acpi_ut_update_ref_count
  *
  * PARAMETERS:  *Object         - Object whose ref count is to be updated
  *              Action          - What to do
@@ -257,25 +293,25 @@ acpi_ut_delete_internal_object_list (
 
 static void
 acpi_ut_update_ref_count (
-	acpi_operand_object     *object,
-	u32                     action)
+	union acpi_operand_object       *object,
+	u32                             action)
 {
-	u16                     count;
-	u16                     new_count;
+	u16                             count;
+	u16                             new_count;
+
 
+	ACPI_FUNCTION_NAME ("ut_update_ref_count");
 
-	PROC_NAME ("Ut_update_ref_count");
 
 	if (!object) {
 		return;
 	}
 
-
 	count = object->common.reference_count;
 	new_count = count;
 
 	/*
-	 * Reference count action (increment, decrement, or force delete)
+	 * Perform the reference count action (increment, decrement, or force delete)
 	 */
 	switch (action) {
 
@@ -284,7 +320,7 @@ acpi_ut_update_ref_count (
 		new_count++;
 		object->common.reference_count = new_count;
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Obj %p Refs=%X, [Incremented]\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Obj %p Refs=%X, [Incremented]\n",
 			object, new_count));
 		break;
 
@@ -292,21 +328,20 @@ acpi_ut_update_ref_count (
 	case REF_DECREMENT:
 
 		if (count < 1) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Obj %p Refs=%X, can't decrement! (Set to 0)\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Obj %p Refs=%X, can't decrement! (Set to 0)\n",
 				object, new_count));
 
 			new_count = 0;
 		}
-
 		else {
 			new_count--;
 
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Obj %p Refs=%X, [Decremented]\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Obj %p Refs=%X, [Decremented]\n",
 				object, new_count));
 		}
 
-		if (object->common.type == ACPI_TYPE_METHOD) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Method Obj %p Refs=%X, [Decremented]\n",
+		if (ACPI_GET_OBJECT_TYPE (object) == ACPI_TYPE_METHOD) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Method Obj %p Refs=%X, [Decremented]\n",
 				object, new_count));
 		}
 
@@ -320,7 +355,7 @@ acpi_ut_update_ref_count (
 
 	case REF_FORCE_DELETE:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Obj %p Refs=%X, Force delete! (Set to 0)\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Obj %p Refs=%X, Force delete! (Set to 0)\n",
 			object, count));
 
 		new_count = 0;
@@ -335,12 +370,11 @@ acpi_ut_update_ref_count (
 		break;
 	}
 
-
 	/*
 	 * Sanity check the reference count, for debug purposes only.
 	 * (A deleted object will have a huge reference count)
 	 */
-	if (count > MAX_REFERENCE_COUNT) {
+	if (count > ACPI_MAX_REFERENCE_COUNT) {
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_WARN,
 			"**** Warning **** Large Reference Count (%X) in object %p\n\n",
@@ -353,7 +387,7 @@ acpi_ut_update_ref_count (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_update_object_reference
+ * FUNCTION:    acpi_ut_update_object_reference
  *
  * PARAMETERS:  *Object             - Increment ref count for this object
  *                                    and all sub-objects
@@ -375,18 +409,16 @@ acpi_ut_update_ref_count (
 
 acpi_status
 acpi_ut_update_object_reference (
-	acpi_operand_object     *object,
-	u16                     action)
+	union acpi_operand_object       *object,
+	u16                             action)
 {
-	acpi_status             status;
-	u32                     i;
-	acpi_operand_object     *next;
-	acpi_operand_object     *new;
-	acpi_generic_state       *state_list = NULL;
-	acpi_generic_state       *state;
+	acpi_status                     status;
+	u32                             i;
+	union acpi_generic_state         *state_list = NULL;
+	union acpi_generic_state         *state;
 
 
-	FUNCTION_TRACE_PTR ("Ut_update_object_reference", object);
+	ACPI_FUNCTION_TRACE_PTR ("ut_update_object_reference", object);
 
 
 	/* Ignore a null object ptr */
@@ -395,16 +427,13 @@ acpi_ut_update_object_reference (
 		return_ACPI_STATUS (AE_OK);
 	}
 
+	/* Make sure that this isn't a namespace handle */
 
-	/*
-	 * Make sure that this isn't a namespace handle or an AML pointer
-	 */
-	if (VALID_DESCRIPTOR_TYPE (object, ACPI_DESC_TYPE_NAMED)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Object %p is NS handle\n", object));
+	if (ACPI_GET_DESCRIPTOR_TYPE (object) == ACPI_DESC_TYPE_NAMED) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Object %p is NS handle\n", object));
 		return_ACPI_STATUS (AE_OK);
 	}
 
-
 	state = acpi_ut_create_update_state (object, action);
 
 	while (state) {
@@ -416,32 +445,11 @@ acpi_ut_update_object_reference (
 		 * All sub-objects must have their reference count incremented also.
 		 * Different object types have different subobjects.
 		 */
-		switch (object->common.type) {
-
+		switch (ACPI_GET_OBJECT_TYPE (object)) {
 		case ACPI_TYPE_DEVICE:
 
-			status = acpi_ut_create_update_state_and_push (object->device.addr_handler,
-					   action, &state_list);
-			if (ACPI_FAILURE (status)) {
-				return_ACPI_STATUS (status);
-			}
-
-			acpi_ut_update_ref_count (object->device.sys_handler, action);
-			acpi_ut_update_ref_count (object->device.drv_handler, action);
-			break;
-
-
-		case INTERNAL_TYPE_ADDRESS_HANDLER:
-
-			/* Must walk list of address handlers */
-
-			next = object->addr_handler.next;
-			while (next) {
-				new = next->addr_handler.next;
-				acpi_ut_update_ref_count (next, action);
-
-				next = new;
-			}
+			acpi_ut_update_ref_count (object->device.system_notify, action);
+			acpi_ut_update_ref_count (object->device.device_notify, action);
 			break;
 
 
@@ -460,7 +468,7 @@ acpi_ut_update_object_reference (
 				status = acpi_ut_create_update_state_and_push (
 						 object->package.elements[i], action, &state_list);
 				if (ACPI_FAILURE (status)) {
-					return_ACPI_STATUS (status);
+					goto error_exit;
 				}
 			}
 			break;
@@ -470,63 +478,62 @@ acpi_ut_update_object_reference (
 
 			status = acpi_ut_create_update_state_and_push (
 					 object->buffer_field.buffer_obj, action, &state_list);
-
 			if (ACPI_FAILURE (status)) {
-				return_ACPI_STATUS (status);
+				goto error_exit;
 			}
 			break;
 
 
-		case INTERNAL_TYPE_REGION_FIELD:
+		case ACPI_TYPE_LOCAL_REGION_FIELD:
 
 			status = acpi_ut_create_update_state_and_push (
 					 object->field.region_obj, action, &state_list);
 			if (ACPI_FAILURE (status)) {
-				return_ACPI_STATUS (status);
+				goto error_exit;
 			}
 		   break;
 
 
-		case INTERNAL_TYPE_BANK_FIELD:
+		case ACPI_TYPE_LOCAL_BANK_FIELD:
 
 			status = acpi_ut_create_update_state_and_push (
-					 object->bank_field.bank_register_obj, action, &state_list);
+					 object->bank_field.bank_obj, action, &state_list);
 			if (ACPI_FAILURE (status)) {
-				return_ACPI_STATUS (status);
+				goto error_exit;
 			}
 
 			status = acpi_ut_create_update_state_and_push (
 					 object->bank_field.region_obj, action, &state_list);
 			if (ACPI_FAILURE (status)) {
-				return_ACPI_STATUS (status);
+				goto error_exit;
 			}
 			break;
 
 
-		case INTERNAL_TYPE_INDEX_FIELD:
+		case ACPI_TYPE_LOCAL_INDEX_FIELD:
 
 			status = acpi_ut_create_update_state_and_push (
 					 object->index_field.index_obj, action, &state_list);
 			if (ACPI_FAILURE (status)) {
-				return_ACPI_STATUS (status);
+				goto error_exit;
 			}
 
 			status = acpi_ut_create_update_state_and_push (
 					 object->index_field.data_obj, action, &state_list);
 			if (ACPI_FAILURE (status)) {
-				return_ACPI_STATUS (status);
+				goto error_exit;
 			}
 			break;
 
 
 		case ACPI_TYPE_REGION:
-		case INTERNAL_TYPE_REFERENCE:
+		case ACPI_TYPE_LOCAL_REFERENCE:
+		default:
 
 			/* No subobjects */
 			break;
 		}
 
-
 		/*
 		 * Now we can update the count in the main object.  This can only
 		 * happen after we update the sub-objects in case this causes the
@@ -534,20 +541,26 @@ acpi_ut_update_object_reference (
 		 */
 		acpi_ut_update_ref_count (object, action);
 
-
 		/* Move on to the next object to be updated */
 
 		state = acpi_ut_pop_generic_state (&state_list);
 	}
 
-
 	return_ACPI_STATUS (AE_OK);
+
+
+error_exit:
+
+	ACPI_REPORT_ERROR (("Could not update object reference count, %s\n",
+		acpi_format_exception (status)));
+
+	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_add_reference
+ * FUNCTION:    acpi_ut_add_reference
  *
  * PARAMETERS:  *Object        - Object whose reference count is to be
  *                                  incremented
@@ -560,31 +573,28 @@ acpi_ut_update_object_reference (
 
 void
 acpi_ut_add_reference (
-	acpi_operand_object     *object)
+	union acpi_operand_object       *object)
 {
 
-	FUNCTION_TRACE_PTR ("Ut_add_reference", object);
+	ACPI_FUNCTION_TRACE_PTR ("ut_add_reference", object);
 
 
-	/*
-	 * Ensure that we have a valid object
-	 */
+	/* Ensure that we have a valid object */
+
 	if (!acpi_ut_valid_internal_object (object)) {
 		return_VOID;
 	}
 
-	/*
-	 * We have a valid ACPI internal object, now increment the reference count
-	 */
-	acpi_ut_update_object_reference (object, REF_INCREMENT);
+	/* Increment the reference count */
 
+	(void) acpi_ut_update_object_reference (object, REF_INCREMENT);
 	return_VOID;
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_remove_reference
+ * FUNCTION:    acpi_ut_remove_reference
  *
  * PARAMETERS:  *Object        - Object whose ref count will be decremented
  *
@@ -596,10 +606,11 @@ acpi_ut_add_reference (
 
 void
 acpi_ut_remove_reference (
-	acpi_operand_object     *object)
+	union acpi_operand_object       *object)
 {
 
-	FUNCTION_TRACE_PTR ("Ut_remove_reference", object);
+	ACPI_FUNCTION_TRACE_PTR ("ut_remove_reference", object);
+
 
 	/*
 	 * Allow a NULL pointer to be passed in, just ignore it.  This saves
@@ -607,18 +618,17 @@ acpi_ut_remove_reference (
 	 *
 	 */
 	if (!object ||
-		(VALID_DESCRIPTOR_TYPE (object, ACPI_DESC_TYPE_NAMED))) {
+		(ACPI_GET_DESCRIPTOR_TYPE (object) == ACPI_DESC_TYPE_NAMED)) {
 		return_VOID;
 	}
 
-	/*
-	 * Ensure that we have a valid object
-	 */
+	/* Ensure that we have a valid object */
+
 	if (!acpi_ut_valid_internal_object (object)) {
 		return_VOID;
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Obj %p Refs=%X\n",
+	ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Obj %p Refs=%X\n",
 			object, object->common.reference_count));
 
 	/*
@@ -626,7 +636,7 @@ acpi_ut_remove_reference (
 	 * if the reference count becomes 0.  (Must also decrement the ref count
 	 * of all subobjects!)
 	 */
-	acpi_ut_update_object_reference (object, REF_DECREMENT);
+	(void) acpi_ut_update_object_reference (object, REF_DECREMENT);
 	return_VOID;
 }
 
diff -urNp linux-5400/drivers/acpi/utilities/uteval.c linux-5410/drivers/acpi/utilities/uteval.c
--- linux-5400/drivers/acpi/utilities/uteval.c
+++ linux-5410/drivers/acpi/utilities/uteval.c
@@ -1,123 +1,258 @@
 /******************************************************************************
  *
  * Module Name: uteval - Object evaluation
- *              $Revision: 31 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acnamesp.h"
-#include "acinterp.h"
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acinterp.h>
 
 
 #define _COMPONENT          ACPI_UTILITIES
-	 MODULE_NAME         ("uteval")
+	 ACPI_MODULE_NAME    ("uteval")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_evaluate_numeric_object
+ * FUNCTION:    acpi_ut_evaluate_object
  *
- * PARAMETERS:  *Object_name        - Object name to be evaluated
- *              Device_node         - Node for the device
- *              *Address            - Where the value is returned
+ * PARAMETERS:  prefix_node         - Starting node
+ *              Path                - Path to object from starting node
+ *              expected_return_types - Bitmap of allowed return types
+ *              return_desc         - Where a return value is stored
  *
  * RETURN:      Status
  *
- * DESCRIPTION: evaluates a numeric namespace object for a selected device
- *              and stores results in *Address.
+ * DESCRIPTION: Evaluates a namespace object and verifies the type of the
+ *              return object.  Common code that simplifies accessing objects
+ *              that have required return objects of fixed types.
  *
  *              NOTE: Internal function, no parameter validation
  *
  ******************************************************************************/
 
 acpi_status
-acpi_ut_evaluate_numeric_object (
-	NATIVE_CHAR             *object_name,
-	acpi_namespace_node     *device_node,
-	acpi_integer            *address)
+acpi_ut_evaluate_object (
+	struct acpi_namespace_node      *prefix_node,
+	char                            *path,
+	u32                             expected_return_btypes,
+	union acpi_operand_object       **return_desc)
 {
-	acpi_operand_object     *obj_desc;
-	acpi_status             status;
+	union acpi_operand_object       *obj_desc;
+	acpi_status                     status;
+	u32                             return_btype;
 
 
-	FUNCTION_TRACE ("Ut_evaluate_numeric_object");
+	ACPI_FUNCTION_TRACE ("ut_evaluate_object");
 
 
-	/* Execute the method */
+	/* Evaluate the object/method */
 
-	status = acpi_ns_evaluate_relative (device_node, object_name, NULL, &obj_desc);
+	status = acpi_ns_evaluate_relative (prefix_node, path, NULL, &obj_desc);
 	if (ACPI_FAILURE (status)) {
 		if (status == AE_NOT_FOUND) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "%s on %4.4s was not found\n",
-				object_name, (char*)&device_node->name));
+			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[%4.4s.%s] was not found\n",
+				prefix_node->name.ascii, path));
 		}
 		else {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "%s on %4.4s failed with status %s\n",
-				object_name, (char*)&device_node->name,
-				acpi_format_exception (status)));
+			ACPI_REPORT_METHOD_ERROR ("Method execution failed",
+				prefix_node, path, status);
 		}
 
 		return_ACPI_STATUS (status);
 	}
 
-
 	/* Did we get a return object? */
 
 	if (!obj_desc) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No object was returned from %s\n",
-			object_name));
-		return_ACPI_STATUS (AE_TYPE);
+		if (expected_return_btypes) {
+			ACPI_REPORT_METHOD_ERROR ("No object was returned from",
+				prefix_node, path, AE_NOT_EXIST);
+
+			return_ACPI_STATUS (AE_NOT_EXIST);
+		}
+
+		return_ACPI_STATUS (AE_OK);
 	}
 
-	/* Is the return object of the correct type? */
+	/* Map the return object type to the bitmapped type */
+
+	switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
+	case ACPI_TYPE_INTEGER:
+		return_btype = ACPI_BTYPE_INTEGER;
+		break;
+
+	case ACPI_TYPE_BUFFER:
+		return_btype = ACPI_BTYPE_BUFFER;
+		break;
+
+	case ACPI_TYPE_STRING:
+		return_btype = ACPI_BTYPE_STRING;
+		break;
+
+	case ACPI_TYPE_PACKAGE:
+		return_btype = ACPI_BTYPE_PACKAGE;
+		break;
+
+	default:
+		return_btype = 0;
+		break;
+	}
+
+	/* Is the return object one of the expected types? */
+
+	if (!(expected_return_btypes & return_btype)) {
+		ACPI_REPORT_METHOD_ERROR ("Return object type is incorrect",
+			prefix_node, path, AE_TYPE);
 
-	if (obj_desc->common.type != ACPI_TYPE_INTEGER) {
-		status = AE_TYPE;
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Type returned from %s was not a number: %X \n",
-			object_name, obj_desc->common.type));
+			"Type returned from %s was incorrect: %X\n",
+			path, ACPI_GET_OBJECT_TYPE (obj_desc)));
+
+		/* On error exit, we must delete the return object */
+
+		acpi_ut_remove_reference (obj_desc);
+		return_ACPI_STATUS (AE_TYPE);
 	}
-	else {
-		/*
-		 * Since the structure is a union, setting any field will set all
-		 * of the variables in the union
-		 */
-		*address = obj_desc->integer.value;
+
+	/* Object type is OK, return it */
+
+	*return_desc = obj_desc;
+	return_ACPI_STATUS (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_evaluate_numeric_object
+ *
+ * PARAMETERS:  *object_name        - Object name to be evaluated
+ *              device_node         - Node for the device
+ *              *Address            - Where the value is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Evaluates a numeric namespace object for a selected device
+ *              and stores result in *Address.
+ *
+ *              NOTE: Internal function, no parameter validation
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_evaluate_numeric_object (
+	char                            *object_name,
+	struct acpi_namespace_node      *device_node,
+	acpi_integer                    *address)
+{
+	union acpi_operand_object       *obj_desc;
+	acpi_status                     status;
+
+
+	ACPI_FUNCTION_TRACE ("ut_evaluate_numeric_object");
+
+
+	status = acpi_ut_evaluate_object (device_node, object_name,
+			 ACPI_BTYPE_INTEGER, &obj_desc);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
 	}
 
+	/* Get the returned Integer */
+
+	*address = obj_desc->integer.value;
+
 	/* On exit, we must delete the return object */
 
 	acpi_ut_remove_reference (obj_desc);
-
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_execute_HID
+ * FUNCTION:    acpi_ut_copy_id_string
  *
- * PARAMETERS:  Device_node         - Node for the device
+ * PARAMETERS:  Destination         - Where to copy the string
+ *              Source              - Source string
+ *              max_length          - Length of the destination buffer
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Copies an ID string for the _HID, _CID, and _UID methods.
+ *              Performs removal of a leading asterisk if present -- workaround
+ *              for a known issue on a bunch of machines.
+ *
+ ******************************************************************************/
+
+static void
+acpi_ut_copy_id_string (
+	char                            *destination,
+	char                            *source,
+	acpi_size                       max_length)
+{
+
+
+	/*
+	 * Workaround for ID strings that have a leading asterisk. This construct
+	 * is not allowed by the ACPI specification  (ID strings must be
+	 * alphanumeric), but enough existing machines have this embedded in their
+	 * ID strings that the following code is useful.
+	 */
+	if (*source == '*') {
+		source++;
+	}
+
+	/* Do the actual copy */
+
+	ACPI_STRNCPY (destination, source, max_length);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_execute_HID
+ *
+ * PARAMETERS:  device_node         - Node for the device
  *              *Hid                - Where the HID is returned
  *
  * RETURN:      Status
@@ -131,239 +266,299 @@ acpi_ut_evaluate_numeric_object (
 
 acpi_status
 acpi_ut_execute_HID (
-	acpi_namespace_node     *device_node,
-	acpi_device_id          *hid)
+	struct acpi_namespace_node      *device_node,
+	struct acpi_device_id           *hid)
 {
-	acpi_operand_object     *obj_desc;
-	acpi_status             status;
-
+	union acpi_operand_object       *obj_desc;
+	acpi_status                     status;
 
-	FUNCTION_TRACE ("Ut_execute_HID");
 
+	ACPI_FUNCTION_TRACE ("ut_execute_HID");
 
-	/* Execute the method */
 
-	status = acpi_ns_evaluate_relative (device_node,
-			 METHOD_NAME__HID, NULL, &obj_desc);
+	status = acpi_ut_evaluate_object (device_node, METHOD_NAME__HID,
+			 ACPI_BTYPE_INTEGER | ACPI_BTYPE_STRING, &obj_desc);
 	if (ACPI_FAILURE (status)) {
-		if (status == AE_NOT_FOUND) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "_HID on %4.4s was not found\n",
-				(char*)&device_node->name));
-		}
-
-		else {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "_HID on %4.4s failed %s\n",
-				(char*)&device_node->name, acpi_format_exception (status)));
-		}
-
 		return_ACPI_STATUS (status);
 	}
 
-	/* Did we get a return object? */
+	if (ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_INTEGER) {
+		/* Convert the Numeric HID to string */
 
-	if (!obj_desc) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No object was returned from _HID\n"));
-		return_ACPI_STATUS (AE_TYPE);
+		acpi_ex_eisa_id_to_string ((u32) obj_desc->integer.value, hid->value);
 	}
+	else {
+		/* Copy the String HID from the returned object */
 
-	/*
-	 *  A _HID can return either a Number (32 bit compressed EISA ID) or
-	 *  a string
-	 */
-	if ((obj_desc->common.type != ACPI_TYPE_INTEGER) &&
-		(obj_desc->common.type != ACPI_TYPE_STRING)) {
-		status = AE_TYPE;
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Type returned from _HID not a number or string: %s(%X) \n",
-			acpi_ut_get_type_name (obj_desc->common.type), obj_desc->common.type));
+		acpi_ut_copy_id_string (hid->value, obj_desc->string.pointer,
+				sizeof (hid->value));
 	}
 
-	else {
-		if (obj_desc->common.type == ACPI_TYPE_INTEGER) {
-			/* Convert the Numeric HID to string */
+	/* On exit, we must delete the return object */
 
-			acpi_ex_eisa_id_to_string ((u32) obj_desc->integer.value, hid->buffer);
-		}
+	acpi_ut_remove_reference (obj_desc);
+	return_ACPI_STATUS (status);
+}
 
-		else {
-			/* Copy the String HID from the returned object */
 
-			STRNCPY(hid->buffer, obj_desc->string.pointer, sizeof(hid->buffer));
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_translate_one_cid
+ *
+ * PARAMETERS:  obj_desc            - _CID object, must be integer or string
+ *              one_cid             - Where the CID string is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Return a numeric or string _CID value as a string.
+ *              (Compatible ID)
+ *
+ *              NOTE:  Assumes a maximum _CID string length of
+ *                     ACPI_MAX_CID_LENGTH.
+ *
+ ******************************************************************************/
+
+static acpi_status
+acpi_ut_translate_one_cid (
+	union acpi_operand_object       *obj_desc,
+	struct acpi_compatible_id       *one_cid)
+{
+
+
+	switch (ACPI_GET_OBJECT_TYPE (obj_desc)) {
+	case ACPI_TYPE_INTEGER:
+
+		/* Convert the Numeric CID to string */
+
+		acpi_ex_eisa_id_to_string ((u32) obj_desc->integer.value, one_cid->value);
+		return (AE_OK);
+
+	case ACPI_TYPE_STRING:
+
+		if (obj_desc->string.length > ACPI_MAX_CID_LENGTH) {
+			return (AE_AML_STRING_LIMIT);
 		}
-	}
 
+		/* Copy the String CID from the returned object */
 
-	/* On exit, we must delete the return object */
+		acpi_ut_copy_id_string (one_cid->value, obj_desc->string.pointer,
+				ACPI_MAX_CID_LENGTH);
+		return (AE_OK);
 
-	acpi_ut_remove_reference (obj_desc);
+	default:
 
-	return_ACPI_STATUS (status);
+		return (AE_TYPE);
+	}
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_execute_UID
+ * FUNCTION:    acpi_ut_execute_CID
  *
- * PARAMETERS:  Device_node         - Node for the device
- *              *Uid                - Where the UID is returned
+ * PARAMETERS:  device_node         - Node for the device
+ *              *Cid                - Where the CID is returned
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Executes the _UID control method that returns the hardware
- *              ID of the device.
+ * DESCRIPTION: Executes the _CID control method that returns one or more
+ *              compatible hardware IDs for the device.
  *
  *              NOTE: Internal function, no parameter validation
  *
  ******************************************************************************/
 
 acpi_status
-acpi_ut_execute_UID (
-	acpi_namespace_node     *device_node,
-	acpi_device_id          *uid)
+acpi_ut_execute_CID (
+	struct acpi_namespace_node      *device_node,
+	struct acpi_compatible_id_list **return_cid_list)
 {
-	acpi_operand_object     *obj_desc;
-	acpi_status             status;
+	union acpi_operand_object       *obj_desc;
+	acpi_status                     status;
+	u32                             count;
+	u32                             size;
+	struct acpi_compatible_id_list *cid_list;
+	acpi_native_uint                i;
 
 
-	PROC_NAME ("Ut_execute_UID");
+	ACPI_FUNCTION_TRACE ("ut_execute_CID");
 
 
-	/* Execute the method */
+	/* Evaluate the _CID method for this device */
 
-	status = acpi_ns_evaluate_relative (device_node,
-			 METHOD_NAME__UID, NULL, &obj_desc);
+	status = acpi_ut_evaluate_object (device_node, METHOD_NAME__CID,
+			 ACPI_BTYPE_INTEGER | ACPI_BTYPE_STRING | ACPI_BTYPE_PACKAGE,
+			 &obj_desc);
 	if (ACPI_FAILURE (status)) {
-		if (status == AE_NOT_FOUND) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "_UID on %4.4s was not found\n",
-				(char*)&device_node->name));
-		}
+		return_ACPI_STATUS (status);
+	}
 
-		else {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"_UID on %4.4s failed %s\n",
-				(char*)&device_node->name, acpi_format_exception (status)));
-		}
+	/* Get the number of _CIDs returned */
 
-		return (status);
+	count = 1;
+	if (ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_PACKAGE) {
+		count = obj_desc->package.count;
 	}
 
-	/* Did we get a return object? */
+	/* Allocate a worst-case buffer for the _CIDs */
 
-	if (!obj_desc) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No object was returned from _UID\n"));
-		return (AE_TYPE);
+	size = (((count - 1) * sizeof (struct acpi_compatible_id)) +
+			   sizeof (struct acpi_compatible_id_list));
+
+	cid_list = ACPI_MEM_CALLOCATE ((acpi_size) size);
+	if (!cid_list) {
+		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
+	/* Init CID list */
+
+	cid_list->count = count;
+	cid_list->size = size;
+
 	/*
-	 *  A _UID can return either a Number (32 bit compressed EISA ID) or
-	 *  a string
+	 *  A _CID can return either a single compatible ID or a package of compatible
+	 *  IDs.  Each compatible ID can be one of the following:
+	 *  -- Number (32 bit compressed EISA ID) or
+	 *  -- String (PCI ID format, e.g. "PCI\VEN_vvvv&DEV_dddd&SUBSYS_ssssssss").
 	 */
-	if ((obj_desc->common.type != ACPI_TYPE_INTEGER) &&
-		(obj_desc->common.type != ACPI_TYPE_STRING)) {
-		status = AE_TYPE;
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Type returned from _UID was not a number or string: %X \n",
-			obj_desc->common.type));
-	}
 
-	else {
-		if (obj_desc->common.type == ACPI_TYPE_INTEGER) {
-			/* Convert the Numeric UID to string */
-
-			acpi_ex_unsigned_integer_to_string (obj_desc->integer.value, uid->buffer);
-		}
+	/* The _CID object can be either a single CID or a package (list) of CIDs */
 
-		else {
-			/* Copy the String UID from the returned object */
+	if (ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_PACKAGE) {
+		/* Translate each package element */
 
-			STRNCPY(uid->buffer, obj_desc->string.pointer, sizeof(uid->buffer));
+		for (i = 0; i < count; i++) {
+			status = acpi_ut_translate_one_cid (obj_desc->package.elements[i],
+					  &cid_list->id[i]);
+			if (ACPI_FAILURE (status)) {
+				break;
+			}
 		}
 	}
+	else {
+		/* Only one CID, translate to a string */
 
+		status = acpi_ut_translate_one_cid (obj_desc, cid_list->id);
+	}
 
-	/* On exit, we must delete the return object */
+	/* Cleanup on error */
 
-	acpi_ut_remove_reference (obj_desc);
+	if (ACPI_FAILURE (status)) {
+		ACPI_MEM_FREE (cid_list);
+	}
+	else {
+		*return_cid_list = cid_list;
+	}
 
-	return (status);
+	/* On exit, we must delete the _CID return object */
+
+	acpi_ut_remove_reference (obj_desc);
+	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_execute_STA
+ * FUNCTION:    acpi_ut_execute_UID
  *
- * PARAMETERS:  Device_node         - Node for the device
- *              *Flags              - Where the status flags are returned
+ * PARAMETERS:  device_node         - Node for the device
+ *              *Uid                - Where the UID is returned
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Executes _STA for selected device and stores results in
- *              *Flags.
+ * DESCRIPTION: Executes the _UID control method that returns the hardware
+ *              ID of the device.
  *
  *              NOTE: Internal function, no parameter validation
  *
  ******************************************************************************/
 
 acpi_status
-acpi_ut_execute_STA (
-	acpi_namespace_node     *device_node,
-	u32                     *flags)
+acpi_ut_execute_UID (
+	struct acpi_namespace_node      *device_node,
+	struct acpi_device_id           *uid)
 {
-	acpi_operand_object     *obj_desc;
-	acpi_status             status;
+	union acpi_operand_object       *obj_desc;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Ut_execute_STA");
+	ACPI_FUNCTION_TRACE ("ut_execute_UID");
 
 
-	/* Execute the method */
+	status = acpi_ut_evaluate_object (device_node, METHOD_NAME__UID,
+			 ACPI_BTYPE_INTEGER | ACPI_BTYPE_STRING, &obj_desc);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
-	status = acpi_ns_evaluate_relative (device_node,
-			 METHOD_NAME__STA, NULL, &obj_desc);
-	if (AE_NOT_FOUND == status) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-			"_STA on %4.4s was not found, assuming present.\n",
-			(char*)&device_node->name));
+	if (ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_INTEGER) {
+		/* Convert the Numeric UID to string */
 
-		*flags = 0x0F;
-		status = AE_OK;
+		acpi_ex_unsigned_integer_to_string (obj_desc->integer.value, uid->value);
 	}
+	else {
+		/* Copy the String UID from the returned object */
 
-	else if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "_STA on %4.4s failed %s\n",
-			(char*)&device_node->name,
-			acpi_format_exception (status)));
+		acpi_ut_copy_id_string (uid->value, obj_desc->string.pointer,
+				sizeof (uid->value));
 	}
 
-	else /* success */ {
-		/* Did we get a return object? */
+	/* On exit, we must delete the return object */
 
-		if (!obj_desc) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No object was returned from _STA\n"));
-			return_ACPI_STATUS (AE_TYPE);
-		}
+	acpi_ut_remove_reference (obj_desc);
+	return_ACPI_STATUS (status);
+}
 
-		/* Is the return object of the correct type? */
 
-		if (obj_desc->common.type != ACPI_TYPE_INTEGER) {
-			status = AE_TYPE;
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Type returned from _STA was not a number: %X \n",
-				obj_desc->common.type));
-		}
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_execute_STA
+ *
+ * PARAMETERS:  device_node         - Node for the device
+ *              *Flags              - Where the status flags are returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Executes _STA for selected device and stores results in
+ *              *Flags.
+ *
+ *              NOTE: Internal function, no parameter validation
+ *
+ ******************************************************************************/
 
-		else {
-			/* Extract the status flags */
+acpi_status
+acpi_ut_execute_STA (
+	struct acpi_namespace_node      *device_node,
+	u32                             *flags)
+{
+	union acpi_operand_object       *obj_desc;
+	acpi_status                     status;
 
-			*flags = (u32) obj_desc->integer.value;
-		}
 
-		/* On exit, we must delete the return object */
+	ACPI_FUNCTION_TRACE ("ut_execute_STA");
 
-		acpi_ut_remove_reference (obj_desc);
+
+	status = acpi_ut_evaluate_object (device_node, METHOD_NAME__STA,
+			 ACPI_BTYPE_INTEGER, &obj_desc);
+	if (ACPI_FAILURE (status)) {
+		if (AE_NOT_FOUND == status) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+				"_STA on %4.4s was not found, assuming device is present\n",
+				device_node->name.ascii));
+
+			*flags = 0x0F;
+			status = AE_OK;
+		}
+
+		return_ACPI_STATUS (status);
 	}
 
+	/* Extract the status flags */
+
+	*flags = (u32) obj_desc->integer.value;
+
+	/* On exit, we must delete the return object */
+
+	acpi_ut_remove_reference (obj_desc);
 	return_ACPI_STATUS (status);
 }
diff -urNp linux-5400/drivers/acpi/utilities/utglobal.c linux-5410/drivers/acpi/utilities/utglobal.c
--- linux-5400/drivers/acpi/utilities/utglobal.c
+++ linux-5410/drivers/acpi/utilities/utglobal.c
@@ -1,44 +1,58 @@
 /******************************************************************************
  *
  * Module Name: utglobal - Global variables for the ACPI subsystem
- *              $Revision: 133 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 #define DEFINE_ACPI_GLOBALS
 
-#include "acpi.h"
-#include "acevents.h"
-#include "acnamesp.h"
-#include "acinterp.h"
-#include "amlcode.h"
-
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
 
 #define _COMPONENT          ACPI_UTILITIES
-	 MODULE_NAME         ("utglobal")
+	 ACPI_MODULE_NAME    ("utglobal")
 
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_format_exception
+ * FUNCTION:    acpi_format_exception
  *
  * PARAMETERS:  Status       - The acpi_status code to be formatted
  *
@@ -50,57 +64,69 @@
 
 const char *
 acpi_format_exception (
-	acpi_status             status)
+	acpi_status                     status)
 {
-	const char              *exception = "UNKNOWN_STATUS_CODE";
-	acpi_status             sub_status;
+	const char                      *exception = "UNKNOWN_STATUS_CODE";
+	acpi_status                     sub_status;
 
 
-	sub_status = (status & ~AE_CODE_MASK);
+	ACPI_FUNCTION_NAME ("format_exception");
 
 
+	sub_status = (status & ~AE_CODE_MASK);
+
 	switch (status & AE_CODE_MASK) {
 	case AE_CODE_ENVIRONMENTAL:
 
 		if (sub_status <= AE_CODE_ENV_MAX) {
 			exception = acpi_gbl_exception_names_env [sub_status];
+			break;
 		}
-		break;
+		goto unknown;
 
 	case AE_CODE_PROGRAMMER:
 
 		if (sub_status <= AE_CODE_PGM_MAX) {
 			exception = acpi_gbl_exception_names_pgm [sub_status -1];
+			break;
 		}
-		break;
+		goto unknown;
 
 	case AE_CODE_ACPI_TABLES:
 
 		if (sub_status <= AE_CODE_TBL_MAX) {
 			exception = acpi_gbl_exception_names_tbl [sub_status -1];
+			break;
 		}
-		break;
+		goto unknown;
 
 	case AE_CODE_AML:
 
 		if (sub_status <= AE_CODE_AML_MAX) {
 			exception = acpi_gbl_exception_names_aml [sub_status -1];
+			break;
 		}
-		break;
+		goto unknown;
 
 	case AE_CODE_CONTROL:
 
 		if (sub_status <= AE_CODE_CTRL_MAX) {
 			exception = acpi_gbl_exception_names_ctrl [sub_status -1];
+			break;
 		}
-		break;
+		goto unknown;
 
 	default:
-		break;
+		goto unknown;
 	}
 
 
 	return ((const char *) exception);
+
+unknown:
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown exception code: 0x%8.8X\n", status));
+	return ((const char *) exception);
 }
 
 
@@ -117,37 +143,41 @@ acpi_format_exception (
 
 /* Debug switch - level and trace mask */
 
-#ifdef ACPI_DEBUG
-u32                         acpi_dbg_level = DEBUG_DEFAULT;
+#ifdef ACPI_DEBUG_OUTPUT
+u32                                 acpi_dbg_level = ACPI_DEBUG_DEFAULT;
 #else
-u32                         acpi_dbg_level = NORMAL_DEFAULT;
+u32                                 acpi_dbg_level = ACPI_NORMAL_DEFAULT;
 #endif
 
 /* Debug switch - layer (component) mask */
 
-u32                         acpi_dbg_layer = ACPI_COMPONENT_DEFAULT;
-u32                         acpi_gbl_nesting_level = 0;
+u32                                 acpi_dbg_layer = ACPI_COMPONENT_DEFAULT;
+u32                                 acpi_gbl_nesting_level = 0;
 
 
 /* Debugger globals */
 
-u8                          acpi_gbl_db_terminate_threads = FALSE;
-u8                          acpi_gbl_method_executing = FALSE;
+u8                                  acpi_gbl_db_terminate_threads = FALSE;
+u8                                  acpi_gbl_abort_method = FALSE;
+u8                                  acpi_gbl_method_executing = FALSE;
 
 /* System flags */
 
-u32                         acpi_gbl_system_flags = 0;
-u32                         acpi_gbl_startup_flags = 0;
+u32                                 acpi_gbl_startup_flags = 0;
 
-/* System starts unitialized! */
+/* System starts uninitialized */
 
-u8                          acpi_gbl_shutdown = TRUE;
+u8                                  acpi_gbl_shutdown = TRUE;
 
-const u8                    acpi_gbl_decode_to8bit [8] = {1,2,4,8,16,32,64,128};
+const u8                            acpi_gbl_decode_to8bit [8] = {1,2,4,8,16,32,64,128};
 
-const NATIVE_CHAR           *acpi_gbl_db_sleep_states[ACPI_NUM_SLEEP_STATES] = {
-			  "\\_S0_","\\_S1_","\\_S2_","\\_S3_",
-			  "\\_S4_","\\_S5_","\\_S4B"};
+const char                          *acpi_gbl_db_sleep_states[ACPI_S_STATE_COUNT] = {
+			  "\\_S0_",
+			  "\\_S1_",
+			  "\\_S2_",
+			  "\\_S3_",
+			  "\\_S4_",
+			  "\\_S5_"};
 
 
 /******************************************************************************
@@ -158,86 +188,82 @@ const NATIVE_CHAR           *acpi_gbl_db
 
 
 /*
- * Names built-in to the interpreter
+ * Predefined ACPI Names (Built-in to the Interpreter)
  *
  * Initial values are currently supported only for types String and Number.
- * To avoid type punning, both are specified as strings in this table.
+ * Both are specified as strings in this table.
  *
  * NOTES:
  * 1) _SB_ is defined to be a device to allow _SB_/_INI to be run
  *    during the initialization sequence.
  */
 
-const predefined_names      acpi_gbl_pre_defined_names[] =
-{ {"_GPE",    INTERNAL_TYPE_DEF_ANY},
-	{"_PR_",    INTERNAL_TYPE_DEF_ANY},
-	{"_SB_",    ACPI_TYPE_DEVICE},
-	{"_SI_",    INTERNAL_TYPE_DEF_ANY},
-	{"_TZ_",    INTERNAL_TYPE_DEF_ANY},
-	{"_REV",    ACPI_TYPE_INTEGER, "2"},
-	{"_OS_",    ACPI_TYPE_STRING, ACPI_OS_NAME},
-	{"_GL_",    ACPI_TYPE_MUTEX, "0"},
-	{NULL,      ACPI_TYPE_ANY}           /* Table terminator */
+const struct acpi_predefined_names      acpi_gbl_pre_defined_names[] =
+{ {"_GPE",    ACPI_TYPE_LOCAL_SCOPE,      NULL},
+	{"_PR_",    ACPI_TYPE_LOCAL_SCOPE,      NULL},
+	{"_SB_",    ACPI_TYPE_DEVICE,           NULL},
+	{"_SI_",    ACPI_TYPE_LOCAL_SCOPE,      NULL},
+	{"_TZ_",    ACPI_TYPE_LOCAL_SCOPE,      NULL},
+	{"_REV",    ACPI_TYPE_INTEGER,          "2"},
+	{"_OS_",    ACPI_TYPE_STRING,           ACPI_OS_NAME},
+	{"_GL_",    ACPI_TYPE_MUTEX,            "0"},
+
+#if defined (ACPI_NO_METHOD_EXECUTION) || defined (ACPI_CONSTANT_EVAL_ONLY)
+	{"_OSI",    ACPI_TYPE_METHOD,           "1"},
+#endif
+	{NULL,      ACPI_TYPE_ANY,              NULL}              /* Table terminator */
 };
 
 
 /*
  * Properties of the ACPI Object Types, both internal and external.
- *
- * Elements of Acpi_ns_properties are bit significant
- * and the table is indexed by values of acpi_object_type
+ * The table is indexed by values of acpi_object_type
  */
 
-const u8                    acpi_gbl_ns_properties[] =
+const u8                                acpi_gbl_ns_properties[] =
 {
-	NSP_NORMAL,                 /* 00 Any              */
-	NSP_NORMAL,                 /* 01 Number           */
-	NSP_NORMAL,                 /* 02 String           */
-	NSP_NORMAL,                 /* 03 Buffer           */
-	NSP_LOCAL,                  /* 04 Package          */
-	NSP_NORMAL,                 /* 05 Field_unit       */
-	NSP_NEWSCOPE | NSP_LOCAL,   /* 06 Device           */
-	NSP_LOCAL,                  /* 07 Acpi_event       */
-	NSP_NEWSCOPE | NSP_LOCAL,   /* 08 Method           */
-	NSP_LOCAL,                  /* 09 Mutex            */
-	NSP_LOCAL,                  /* 10 Region           */
-	NSP_NEWSCOPE | NSP_LOCAL,   /* 11 Power            */
-	NSP_NEWSCOPE | NSP_LOCAL,   /* 12 Processor        */
-	NSP_NEWSCOPE | NSP_LOCAL,   /* 13 Thermal          */
-	NSP_NORMAL,                 /* 14 Buffer_field     */
-	NSP_NORMAL,                 /* 15 Ddb_handle       */
-	NSP_NORMAL,                 /* 16 Debug Object     */
-	NSP_NORMAL,                 /* 17 Def_field        */
-	NSP_NORMAL,                 /* 18 Bank_field       */
-	NSP_NORMAL,                 /* 19 Index_field      */
-	NSP_NORMAL,                 /* 20 Reference        */
-	NSP_NORMAL,                 /* 21 Alias            */
-	NSP_NORMAL,                 /* 22 Notify           */
-	NSP_NORMAL,                 /* 23 Address Handler  */
-	NSP_NEWSCOPE | NSP_LOCAL,   /* 24 Resource Desc    */
-	NSP_NEWSCOPE | NSP_LOCAL,   /* 25 Resource Field   */
-	NSP_NORMAL,                 /* 26 Def_field_defn   */
-	NSP_NORMAL,                 /* 27 Bank_field_defn  */
-	NSP_NORMAL,                 /* 28 Index_field_defn */
-	NSP_NORMAL,                 /* 29 If               */
-	NSP_NORMAL,                 /* 30 Else             */
-	NSP_NORMAL,                 /* 31 While            */
-	NSP_NEWSCOPE,               /* 32 Scope            */
-	NSP_LOCAL,                  /* 33 Def_any          */
-	NSP_NORMAL,                 /* 34 Extra            */
-	NSP_NORMAL                  /* 35 Invalid          */
+	ACPI_NS_NORMAL,                     /* 00 Any              */
+	ACPI_NS_NORMAL,                     /* 01 Number           */
+	ACPI_NS_NORMAL,                     /* 02 String           */
+	ACPI_NS_NORMAL,                     /* 03 Buffer           */
+	ACPI_NS_NORMAL,                     /* 04 Package          */
+	ACPI_NS_NORMAL,                     /* 05 field_unit       */
+	ACPI_NS_NEWSCOPE,                   /* 06 Device           */
+	ACPI_NS_NORMAL,                     /* 07 Event            */
+	ACPI_NS_NEWSCOPE,                   /* 08 Method           */
+	ACPI_NS_NORMAL,                     /* 09 Mutex            */
+	ACPI_NS_NORMAL,                     /* 10 Region           */
+	ACPI_NS_NEWSCOPE,                   /* 11 Power            */
+	ACPI_NS_NEWSCOPE,                   /* 12 Processor        */
+	ACPI_NS_NEWSCOPE,                   /* 13 Thermal          */
+	ACPI_NS_NORMAL,                     /* 14 buffer_field     */
+	ACPI_NS_NORMAL,                     /* 15 ddb_handle       */
+	ACPI_NS_NORMAL,                     /* 16 Debug Object     */
+	ACPI_NS_NORMAL,                     /* 17 def_field        */
+	ACPI_NS_NORMAL,                     /* 18 bank_field       */
+	ACPI_NS_NORMAL,                     /* 19 index_field      */
+	ACPI_NS_NORMAL,                     /* 20 Reference        */
+	ACPI_NS_NORMAL,                     /* 21 Alias            */
+	ACPI_NS_NORMAL,                     /* 22 Notify           */
+	ACPI_NS_NORMAL,                     /* 23 Address Handler  */
+	ACPI_NS_NEWSCOPE | ACPI_NS_LOCAL,   /* 24 Resource Desc    */
+	ACPI_NS_NEWSCOPE | ACPI_NS_LOCAL,   /* 25 Resource Field   */
+	ACPI_NS_NEWSCOPE,                   /* 26 Scope            */
+	ACPI_NS_NORMAL,                     /* 27 Extra            */
+	ACPI_NS_NORMAL,                     /* 28 Data             */
+	ACPI_NS_NORMAL                      /* 29 Invalid          */
 };
 
 
 /* Hex to ASCII conversion table */
 
-const NATIVE_CHAR           acpi_gbl_hex_to_ascii[] =
+static const char                   acpi_gbl_hex_to_ascii[] =
 			  {'0','1','2','3','4','5','6','7',
-			  '8','9','A','B','C','D','E','F'};
+					 '8','9','A','B','C','D','E','F'};
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ut_hex_to_ascii_char
+ * FUNCTION:    acpi_ut_hex_to_ascii_char
  *
  * PARAMETERS:  Integer             - Contains the hex digit
  *              Position            - bit position of the digit within the
@@ -249,10 +275,10 @@ const NATIVE_CHAR           acpi_gbl_hex
  *
  ****************************************************************************/
 
-u8
+char
 acpi_ut_hex_to_ascii_char (
-	acpi_integer            integer,
-	u32                     position)
+	acpi_integer                    integer,
+	u32                             position)
 {
 
 	return (acpi_gbl_hex_to_ascii[(integer >> position) & 0xF]);
@@ -261,68 +287,180 @@ acpi_ut_hex_to_ascii_char (
 
 /******************************************************************************
  *
- * Table globals
+ * Table name globals
  *
  * NOTE: This table includes ONLY the ACPI tables that the subsystem consumes.
  * it is NOT an exhaustive list of all possible ACPI tables.  All ACPI tables
  * that are not used by the subsystem are simply ignored.
  *
+ * Do NOT add any table to this list that is not consumed directly by this
+ * subsystem.
+ *
  ******************************************************************************/
 
 
-acpi_table_desc             acpi_gbl_acpi_tables[NUM_ACPI_TABLES];
+struct acpi_table_list              acpi_gbl_table_lists[NUM_ACPI_TABLE_TYPES];
+
 
+struct acpi_table_support           acpi_gbl_table_data[NUM_ACPI_TABLE_TYPES] =
+{
+	/***********    Name,   Signature, Global typed pointer     Signature size,      Type                  How many allowed?,    Contains valid AML? */
+
+	/* RSDP 0 */ {RSDP_NAME, RSDP_SIG, NULL,                    sizeof (RSDP_SIG)-1, ACPI_TABLE_ROOT     | ACPI_TABLE_SINGLE},
+	/* DSDT 1 */ {DSDT_SIG,  DSDT_SIG, (void **) &acpi_gbl_DSDT, sizeof (DSDT_SIG)-1, ACPI_TABLE_SECONDARY| ACPI_TABLE_SINGLE  | ACPI_TABLE_EXECUTABLE},
+	/* FADT 2 */ {FADT_SIG,  FADT_SIG, (void **) &acpi_gbl_FADT, sizeof (FADT_SIG)-1, ACPI_TABLE_PRIMARY | ACPI_TABLE_SINGLE},
+	/* FACS 3 */ {FACS_SIG,  FACS_SIG, (void **) &acpi_gbl_FACS, sizeof (FACS_SIG)-1, ACPI_TABLE_SECONDARY| ACPI_TABLE_SINGLE},
+	/* PSDT 4 */ {PSDT_SIG,  PSDT_SIG, NULL,                    sizeof (PSDT_SIG)-1, ACPI_TABLE_PRIMARY  | ACPI_TABLE_MULTIPLE | ACPI_TABLE_EXECUTABLE},
+	/* SSDT 5 */ {SSDT_SIG,  SSDT_SIG, NULL,                    sizeof (SSDT_SIG)-1, ACPI_TABLE_PRIMARY  | ACPI_TABLE_MULTIPLE | ACPI_TABLE_EXECUTABLE},
+	/* XSDT 6 */ {XSDT_SIG,  XSDT_SIG, NULL,                    sizeof (RSDT_SIG)-1, ACPI_TABLE_ROOT     | ACPI_TABLE_SINGLE},
+};
+
+
+/******************************************************************************
+ *
+ * Event and Hardware globals
+ *
+ ******************************************************************************/
 
-ACPI_TABLE_SUPPORT          acpi_gbl_acpi_table_data[NUM_ACPI_TABLES] =
+struct acpi_bit_register_info       acpi_gbl_bit_register_info[ACPI_NUM_BITREG] =
 {
-	/***********    Name,    Signature,  Signature size,    How many allowed?,   Supported?  Global typed pointer */
+	/* Name                                     Parent Register             Register Bit Position                   Register Bit Mask       */
+
+	/* ACPI_BITREG_TIMER_STATUS         */   {ACPI_REGISTER_PM1_STATUS,   ACPI_BITPOSITION_TIMER_STATUS,          ACPI_BITMASK_TIMER_STATUS},
+	/* ACPI_BITREG_BUS_MASTER_STATUS    */   {ACPI_REGISTER_PM1_STATUS,   ACPI_BITPOSITION_BUS_MASTER_STATUS,     ACPI_BITMASK_BUS_MASTER_STATUS},
+	/* ACPI_BITREG_GLOBAL_LOCK_STATUS   */   {ACPI_REGISTER_PM1_STATUS,   ACPI_BITPOSITION_GLOBAL_LOCK_STATUS,    ACPI_BITMASK_GLOBAL_LOCK_STATUS},
+	/* ACPI_BITREG_POWER_BUTTON_STATUS  */   {ACPI_REGISTER_PM1_STATUS,   ACPI_BITPOSITION_POWER_BUTTON_STATUS,   ACPI_BITMASK_POWER_BUTTON_STATUS},
+	/* ACPI_BITREG_SLEEP_BUTTON_STATUS  */   {ACPI_REGISTER_PM1_STATUS,   ACPI_BITPOSITION_SLEEP_BUTTON_STATUS,   ACPI_BITMASK_SLEEP_BUTTON_STATUS},
+	/* ACPI_BITREG_RT_CLOCK_STATUS      */   {ACPI_REGISTER_PM1_STATUS,   ACPI_BITPOSITION_RT_CLOCK_STATUS,       ACPI_BITMASK_RT_CLOCK_STATUS},
+	/* ACPI_BITREG_WAKE_STATUS          */   {ACPI_REGISTER_PM1_STATUS,   ACPI_BITPOSITION_WAKE_STATUS,           ACPI_BITMASK_WAKE_STATUS},
+
+	/* ACPI_BITREG_TIMER_ENABLE         */   {ACPI_REGISTER_PM1_ENABLE,   ACPI_BITPOSITION_TIMER_ENABLE,          ACPI_BITMASK_TIMER_ENABLE},
+	/* ACPI_BITREG_GLOBAL_LOCK_ENABLE   */   {ACPI_REGISTER_PM1_ENABLE,   ACPI_BITPOSITION_GLOBAL_LOCK_ENABLE,    ACPI_BITMASK_GLOBAL_LOCK_ENABLE},
+	/* ACPI_BITREG_POWER_BUTTON_ENABLE  */   {ACPI_REGISTER_PM1_ENABLE,   ACPI_BITPOSITION_POWER_BUTTON_ENABLE,   ACPI_BITMASK_POWER_BUTTON_ENABLE},
+	/* ACPI_BITREG_SLEEP_BUTTON_ENABLE  */   {ACPI_REGISTER_PM1_ENABLE,   ACPI_BITPOSITION_SLEEP_BUTTON_ENABLE,   ACPI_BITMASK_SLEEP_BUTTON_ENABLE},
+	/* ACPI_BITREG_RT_CLOCK_ENABLE      */   {ACPI_REGISTER_PM1_ENABLE,   ACPI_BITPOSITION_RT_CLOCK_ENABLE,       ACPI_BITMASK_RT_CLOCK_ENABLE},
+	/* ACPI_BITREG_WAKE_ENABLE          */   {ACPI_REGISTER_PM1_ENABLE,   0,                                      0},
+
+	/* ACPI_BITREG_SCI_ENABLE           */   {ACPI_REGISTER_PM1_CONTROL,  ACPI_BITPOSITION_SCI_ENABLE,            ACPI_BITMASK_SCI_ENABLE},
+	/* ACPI_BITREG_BUS_MASTER_RLD       */   {ACPI_REGISTER_PM1_CONTROL,  ACPI_BITPOSITION_BUS_MASTER_RLD,        ACPI_BITMASK_BUS_MASTER_RLD},
+	/* ACPI_BITREG_GLOBAL_LOCK_RELEASE  */   {ACPI_REGISTER_PM1_CONTROL,  ACPI_BITPOSITION_GLOBAL_LOCK_RELEASE,   ACPI_BITMASK_GLOBAL_LOCK_RELEASE},
+	/* ACPI_BITREG_SLEEP_TYPE_A         */   {ACPI_REGISTER_PM1_CONTROL,  ACPI_BITPOSITION_SLEEP_TYPE_X,          ACPI_BITMASK_SLEEP_TYPE_X},
+	/* ACPI_BITREG_SLEEP_TYPE_B         */   {ACPI_REGISTER_PM1_CONTROL,  ACPI_BITPOSITION_SLEEP_TYPE_X,          ACPI_BITMASK_SLEEP_TYPE_X},
+	/* ACPI_BITREG_SLEEP_ENABLE         */   {ACPI_REGISTER_PM1_CONTROL,  ACPI_BITPOSITION_SLEEP_ENABLE,          ACPI_BITMASK_SLEEP_ENABLE},
 
-	/* RSDP 0 */ {RSDP_NAME, RSDP_SIG, sizeof (RSDP_SIG)-1, ACPI_TABLE_SINGLE,   AE_OK,      NULL},
-	/* DSDT 1 */ {DSDT_SIG,  DSDT_SIG, sizeof (DSDT_SIG)-1, ACPI_TABLE_SINGLE,   AE_OK,      (void **) &acpi_gbl_DSDT},
-	/* FADT 2 */ {FADT_SIG,  FADT_SIG, sizeof (FADT_SIG)-1, ACPI_TABLE_SINGLE,   AE_OK,      (void **) &acpi_gbl_FADT},
-	/* FACS 3 */ {FACS_SIG,  FACS_SIG, sizeof (FACS_SIG)-1, ACPI_TABLE_SINGLE,   AE_OK,      (void **) &acpi_gbl_FACS},
-	/* PSDT 4 */ {PSDT_SIG,  PSDT_SIG, sizeof (PSDT_SIG)-1, ACPI_TABLE_MULTIPLE, AE_OK,      NULL},
-	/* SSDT 5 */ {SSDT_SIG,  SSDT_SIG, sizeof (SSDT_SIG)-1, ACPI_TABLE_MULTIPLE, AE_OK,      NULL},
-	/* XSDT 6 */ {XSDT_SIG,  XSDT_SIG, sizeof (RSDT_SIG)-1, ACPI_TABLE_SINGLE,   AE_OK,      NULL},
+	/* ACPI_BITREG_ARB_DIS              */   {ACPI_REGISTER_PM2_CONTROL,  ACPI_BITPOSITION_ARB_DISABLE,           ACPI_BITMASK_ARB_DISABLE}
 };
 
 
-#ifdef ACPI_DEBUG
+struct acpi_fixed_event_info        acpi_gbl_fixed_event_info[ACPI_NUM_FIXED_EVENTS] =
+{
+	/* ACPI_EVENT_PMTIMER       */  {ACPI_BITREG_TIMER_STATUS,          ACPI_BITREG_TIMER_ENABLE,        ACPI_BITMASK_TIMER_STATUS,          ACPI_BITMASK_TIMER_ENABLE},
+	/* ACPI_EVENT_GLOBAL        */  {ACPI_BITREG_GLOBAL_LOCK_STATUS,    ACPI_BITREG_GLOBAL_LOCK_ENABLE,  ACPI_BITMASK_GLOBAL_LOCK_STATUS,    ACPI_BITMASK_GLOBAL_LOCK_ENABLE},
+	/* ACPI_EVENT_POWER_BUTTON  */  {ACPI_BITREG_POWER_BUTTON_STATUS,   ACPI_BITREG_POWER_BUTTON_ENABLE, ACPI_BITMASK_POWER_BUTTON_STATUS,   ACPI_BITMASK_POWER_BUTTON_ENABLE},
+	/* ACPI_EVENT_SLEEP_BUTTON  */  {ACPI_BITREG_SLEEP_BUTTON_STATUS,   ACPI_BITREG_SLEEP_BUTTON_ENABLE, ACPI_BITMASK_SLEEP_BUTTON_STATUS,   ACPI_BITMASK_SLEEP_BUTTON_ENABLE},
+	/* ACPI_EVENT_RTC           */  {ACPI_BITREG_RT_CLOCK_STATUS,       ACPI_BITREG_RT_CLOCK_ENABLE,     0,                                  0},
+};
 
-/*
- * Strings and procedures used for debug only
+/*****************************************************************************
  *
- */
+ * FUNCTION:    acpi_ut_get_region_name
+ *
+ * PARAMETERS:  None.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Translate a Space ID into a name string (Debug only)
+ *
+ ****************************************************************************/
+
+/* Region type decoding */
+
+const char                *acpi_gbl_region_types[ACPI_NUM_PREDEFINED_REGIONS] =
+{
+/*! [Begin] no source code translation (keep these ASL Keywords as-is) */
+	"SystemMemory",
+	"SystemIO",
+	"PCI_Config",
+	"EmbeddedControl",
+	"SMBus",
+	"CMOS",
+	"PCIBARTarget",
+	"DataTable"
+/*! [End] no source code translation !*/
+};
+
+
+char *
+acpi_ut_get_region_name (
+	u8                              space_id)
+{
+
+	if (space_id >= ACPI_USER_REGION_BEGIN)
+	{
+		return ("user_defined_region");
+	}
+
+	else if (space_id >= ACPI_NUM_PREDEFINED_REGIONS)
+	{
+		return ("invalid_space_id");
+	}
+
+	return ((char *) acpi_gbl_region_types[space_id]);
+}
 
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ut_get_mutex_name
+ * FUNCTION:    acpi_ut_get_event_name
  *
  * PARAMETERS:  None.
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Translate a mutex ID into a name string (Debug only)
+ * DESCRIPTION: Translate a Event ID into a name string (Debug only)
  *
  ****************************************************************************/
 
-NATIVE_CHAR *
-acpi_ut_get_mutex_name (
-	u32                     mutex_id)
+/* Event type decoding */
+
+static const char                *acpi_gbl_event_types[ACPI_NUM_FIXED_EVENTS] =
 {
+	"PM_Timer",
+	"global_lock",
+	"power_button",
+	"sleep_button",
+	"real_time_clock",
+};
+
 
-	if (mutex_id > MAX_MTX)
+char *
+acpi_ut_get_event_name (
+	u32                             event_id)
+{
+
+	if (event_id > ACPI_EVENT_MAX)
 	{
-		return ("Invalid Mutex ID");
+		return ("invalid_event_iD");
 	}
 
-	return (acpi_gbl_mutex_names[mutex_id]);
+	return ((char *) acpi_gbl_event_types[event_id]);
 }
 
 
+/*****************************************************************************
+ *
+ * FUNCTION:    acpi_ut_get_type_name
+ *
+ * PARAMETERS:  None.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Translate a Type ID into a name string (Debug only)
+ *
+ ****************************************************************************/
+
 /*
- * Elements of Acpi_gbl_Ns_type_names below must match
+ * Elements of acpi_gbl_ns_type_names below must match
  * one-to-one with values of acpi_object_type
  *
  * The type ACPI_TYPE_ANY (Untyped) is used as a "don't care" when searching; when
@@ -330,17 +468,17 @@ acpi_ut_get_mutex_name (
  * indicatewhat type is actually going to be stored for this entry.
  */
 
-static const NATIVE_CHAR    acpi_gbl_bad_type[] = "UNDEFINED";
+static const char                   acpi_gbl_bad_type[] = "UNDEFINED";
 #define TYPE_NAME_LENGTH    12                           /* Maximum length of each string */
 
-static const NATIVE_CHAR    *acpi_gbl_ns_type_names[] = /* printable names of ACPI types */
+static const char                   *acpi_gbl_ns_type_names[] = /* printable names of ACPI types */
 {
 	/* 00 */ "Untyped",
 	/* 01 */ "Integer",
 	/* 02 */ "String",
 	/* 03 */ "Buffer",
 	/* 04 */ "Package",
-	/* 05 */ "Field_unit",
+	/* 05 */ "field_unit",
 	/* 06 */ "Device",
 	/* 07 */ "Event",
 	/* 08 */ "Method",
@@ -349,154 +487,91 @@ static const NATIVE_CHAR    *acpi_gbl_ns
 	/* 11 */ "Power",
 	/* 12 */ "Processor",
 	/* 13 */ "Thermal",
-	/* 14 */ "Buffer_field",
-	/* 15 */ "Ddb_handle",
-	/* 16 */ "Debug_object",
-	/* 17 */ "Region_field",
-	/* 18 */ "Bank_field",
-	/* 19 */ "Index_field",
+	/* 14 */ "buffer_field",
+	/* 15 */ "ddb_handle",
+	/* 16 */ "debug_object",
+	/* 17 */ "region_field",
+	/* 18 */ "bank_field",
+	/* 19 */ "index_field",
 	/* 20 */ "Reference",
 	/* 21 */ "Alias",
 	/* 22 */ "Notify",
-	/* 23 */ "Addr_handler",
-	/* 24 */ "Resource_desc",
-	/* 25 */ "Resource_fld",
-	/* 26 */ "Region_fld_dfn",
-	/* 27 */ "Bank_fld_dfn",
-	/* 28 */ "Index_fld_dfn",
-	/* 29 */ "If",
-	/* 30 */ "Else",
-	/* 31 */ "While",
-	/* 32 */ "Scope",
-	/* 33 */ "Def_any",
-	/* 34 */ "Extra",
-	/* 35 */ "Invalid"
+	/* 23 */ "addr_handler",
+	/* 24 */ "resource_desc",
+	/* 25 */ "resource_fld",
+	/* 26 */ "Scope",
+	/* 27 */ "Extra",
+	/* 28 */ "Data",
+	/* 39 */ "Invalid"
 };
 
 
-/*****************************************************************************
- *
- * FUNCTION:    Acpi_ut_get_type_name
- *
- * PARAMETERS:  None.
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Translate a Type ID into a name string (Debug only)
- *
- ****************************************************************************/
-
-NATIVE_CHAR *
+char *
 acpi_ut_get_type_name (
-	u32                     type)
+	acpi_object_type                type)
 {
 
-	if (type > INTERNAL_TYPE_INVALID)
+	if (type > ACPI_TYPE_INVALID)
 	{
-		return ((NATIVE_CHAR *) acpi_gbl_bad_type);
+		return ((char *) acpi_gbl_bad_type);
 	}
 
-	return ((NATIVE_CHAR *) acpi_gbl_ns_type_names[type]);
+	return ((char *) acpi_gbl_ns_type_names[type]);
 }
 
 
-/* Region type decoding */
-
-const NATIVE_CHAR *acpi_gbl_region_types[NUM_REGION_TYPES] =
+char *
+acpi_ut_get_object_type_name (
+	union acpi_operand_object       *obj_desc)
 {
-	"System_memory",
-	"System_iO",
-	"PCIConfig",
-	"Embedded_control",
-	"SMBus",
-	"CMOS",
-	"PCIBar_target",
-};
+
+	if (!obj_desc)
+	{
+		return ("[NULL Object Descriptor]");
+	}
+
+	return (acpi_ut_get_type_name (ACPI_GET_OBJECT_TYPE (obj_desc)));
+}
 
 
+#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
+/*
+ * Strings and procedures used for debug only
+ */
+
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ut_get_region_name
+ * FUNCTION:    acpi_ut_get_mutex_name
  *
  * PARAMETERS:  None.
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Translate a Space ID into a name string (Debug only)
+ * DESCRIPTION: Translate a mutex ID into a name string (Debug only)
  *
  ****************************************************************************/
 
-NATIVE_CHAR *
-acpi_ut_get_region_name (
-	u8                      space_id)
+char *
+acpi_ut_get_mutex_name (
+	u32                             mutex_id)
 {
 
-	if (space_id >= USER_REGION_BEGIN)
-	{
-		return ("User_defined_region");
-	}
-
-	else if (space_id >= NUM_REGION_TYPES)
+	if (mutex_id > MAX_MUTEX)
 	{
-		return ("Invalid_space_iD");
+		return ("Invalid Mutex ID");
 	}
 
-	return ((NATIVE_CHAR *) acpi_gbl_region_types[space_id]);
+	return (acpi_gbl_mutex_names[mutex_id]);
 }
 
-
-/* Data used in keeping track of fields */
-
-const NATIVE_CHAR *acpi_gbl_FEnames[NUM_FIELD_NAMES] =
-{
-	"skip",
-	"?access?"
-};              /* FE = Field Element */
-
-
-const NATIVE_CHAR *acpi_gbl_match_ops[NUM_MATCH_OPS] =
-{
-	"Error",
-	"MTR",
-	"MEQ",
-	"MLE",
-	"MLT",
-	"MGE",
-	"MGT"
-};
-
-
-/* Access type decoding */
-
-const NATIVE_CHAR *acpi_gbl_access_types[NUM_ACCESS_TYPES] =
-{
-	"Any_acc",
-	"Byte_acc",
-	"Word_acc",
-	"DWord_acc",
-	"Block_acc",
-	"SMBSend_recv_acc",
-	"SMBQuick_acc"
-};
-
-
-/* Update rule decoding */
-
-const NATIVE_CHAR *acpi_gbl_update_rules[NUM_UPDATE_RULES] =
-{
-	"Preserve",
-	"Write_as_ones",
-	"Write_as_zeros"
-};
-
 #endif
 
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ut_valid_object_type
+ * FUNCTION:    acpi_ut_valid_object_type
  *
- * PARAMETERS:  None.
+ * PARAMETERS:  Type            - Object type to be validated
  *
  * RETURN:      TRUE if valid object type
  *
@@ -506,16 +581,14 @@ const NATIVE_CHAR *acpi_gbl_update_rules
 
 u8
 acpi_ut_valid_object_type (
-	u32                     type)
+	acpi_object_type                type)
 {
 
-	if (type > ACPI_TYPE_MAX)
+	if (type > ACPI_TYPE_LOCAL_MAX)
 	{
-		if ((type < INTERNAL_TYPE_BEGIN) ||
-			(type > INTERNAL_TYPE_MAX))
-		{
-			return (FALSE);
-		}
+		/* Note: Assumes all TYPEs are contiguous (external/local) */
+
+		return (FALSE);
 	}
 
 	return (TRUE);
@@ -524,9 +597,9 @@ acpi_ut_valid_object_type (
 
 /****************************************************************************
  *
- * FUNCTION:    Acpi_ut_allocate_owner_id
+ * FUNCTION:    acpi_ut_allocate_owner_id
  *
- * PARAMETERS:  Id_type         - Type of ID (method or table)
+ * PARAMETERS:  id_type         - Type of ID (method or table)
  *
  * DESCRIPTION: Allocate a table or method owner id
  *
@@ -534,52 +607,61 @@ acpi_ut_valid_object_type (
 
 acpi_owner_id
 acpi_ut_allocate_owner_id (
-	u32                     id_type)
+	u32                             id_type)
 {
-	acpi_owner_id           owner_id = 0xFFFF;
+	acpi_owner_id                   owner_id = 0xFFFF;
 
 
-	FUNCTION_TRACE ("Ut_allocate_owner_id");
+	ACPI_FUNCTION_TRACE ("ut_allocate_owner_id");
 
 
-	acpi_ut_acquire_mutex (ACPI_MTX_CACHES);
+	if (ACPI_FAILURE (acpi_ut_acquire_mutex (ACPI_MTX_CACHES)))
+	{
+		return (0);
+	}
 
 	switch (id_type)
 	{
-	case OWNER_TYPE_TABLE:
+	case ACPI_OWNER_TYPE_TABLE:
 
 		owner_id = acpi_gbl_next_table_owner_id;
 		acpi_gbl_next_table_owner_id++;
 
-		if (acpi_gbl_next_table_owner_id == FIRST_METHOD_ID)
+		/* Check for wraparound */
+
+		if (acpi_gbl_next_table_owner_id == ACPI_FIRST_METHOD_ID)
 		{
-			acpi_gbl_next_table_owner_id = FIRST_TABLE_ID;
+			acpi_gbl_next_table_owner_id = ACPI_FIRST_TABLE_ID;
+			ACPI_REPORT_WARNING (("Table owner ID wraparound\n"));
 		}
 		break;
 
 
-	case OWNER_TYPE_METHOD:
+	case ACPI_OWNER_TYPE_METHOD:
 
 		owner_id = acpi_gbl_next_method_owner_id;
 		acpi_gbl_next_method_owner_id++;
 
-		if (acpi_gbl_next_method_owner_id == FIRST_TABLE_ID)
+		if (acpi_gbl_next_method_owner_id == ACPI_FIRST_TABLE_ID)
 		{
-			acpi_gbl_next_method_owner_id = FIRST_METHOD_ID;
+			/* Check for wraparound */
+
+			acpi_gbl_next_method_owner_id = ACPI_FIRST_METHOD_ID;
 		}
 		break;
-	}
 
+	default:
+		break;
+	}
 
-	acpi_ut_release_mutex (ACPI_MTX_CACHES);
-
+	(void) acpi_ut_release_mutex (ACPI_MTX_CACHES);
 	return_VALUE (owner_id);
 }
 
 
 /****************************************************************************
  *
- * FUNCTION:    Acpi_ut_init_globals
+ * FUNCTION:    acpi_ut_init_globals
  *
  * PARAMETERS:  none
  *
@@ -592,33 +674,33 @@ void
 acpi_ut_init_globals (
 	void)
 {
-	u32                     i;
+	u32                             i;
 
 
-	FUNCTION_TRACE ("Ut_init_globals");
+	ACPI_FUNCTION_TRACE ("ut_init_globals");
 
 	/* Memory allocation and cache lists */
 
-	MEMSET (acpi_gbl_memory_lists, 0, sizeof (ACPI_MEMORY_LIST) * ACPI_NUM_MEM_LISTS);
+	ACPI_MEMSET (acpi_gbl_memory_lists, 0, sizeof (struct acpi_memory_list) * ACPI_NUM_MEM_LISTS);
 
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_STATE].link_offset      = (u16) (NATIVE_UINT) &(((acpi_generic_state *) NULL)->common.next);
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE].link_offset     = (u16) (NATIVE_UINT) &(((acpi_parse_object *) NULL)->next);
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE_EXT].link_offset = (u16) (NATIVE_UINT) &(((acpi_parse2_object *) NULL)->next);
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_OPERAND].link_offset    = (u16) (NATIVE_UINT) &(((acpi_operand_object *) NULL)->cache.next);
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_WALK].link_offset       = (u16) (NATIVE_UINT) &(((acpi_walk_state *) NULL)->next);
-
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_NSNODE].object_size     = sizeof (acpi_namespace_node);
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_STATE].object_size      = sizeof (acpi_generic_state);
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE].object_size     = sizeof (acpi_parse_object);
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE_EXT].object_size = sizeof (acpi_parse2_object);
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_OPERAND].object_size    = sizeof (acpi_operand_object);
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_WALK].object_size       = sizeof (acpi_walk_state);
-
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_STATE].max_cache_depth  = MAX_STATE_CACHE_DEPTH;
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE].max_cache_depth = MAX_PARSE_CACHE_DEPTH;
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE_EXT].max_cache_depth = MAX_EXTPARSE_CACHE_DEPTH;
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_OPERAND].max_cache_depth = MAX_OBJECT_CACHE_DEPTH;
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_WALK].max_cache_depth   = MAX_WALK_CACHE_DEPTH;
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_STATE].link_offset      = (u16) ACPI_PTR_DIFF (&(((union acpi_generic_state *) NULL)->common.next), NULL);
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE].link_offset     = (u16) ACPI_PTR_DIFF (&(((union acpi_parse_object *) NULL)->common.next), NULL);
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE_EXT].link_offset = (u16) ACPI_PTR_DIFF (&(((union acpi_parse_object *) NULL)->common.next), NULL);
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_OPERAND].link_offset    = (u16) ACPI_PTR_DIFF (&(((union acpi_operand_object *) NULL)->cache.next), NULL);
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_WALK].link_offset       = (u16) ACPI_PTR_DIFF (&(((struct acpi_walk_state *) NULL)->next), NULL);
+
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_NSNODE].object_size     = sizeof (struct acpi_namespace_node);
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_STATE].object_size      = sizeof (union acpi_generic_state);
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE].object_size     = sizeof (struct acpi_parse_obj_common);
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE_EXT].object_size = sizeof (struct acpi_parse_obj_named);
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_OPERAND].object_size    = sizeof (union acpi_operand_object);
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_WALK].object_size       = sizeof (struct acpi_walk_state);
+
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_STATE].max_cache_depth  = ACPI_MAX_STATE_CACHE_DEPTH;
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE].max_cache_depth = ACPI_MAX_PARSE_CACHE_DEPTH;
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE_EXT].max_cache_depth = ACPI_MAX_EXTPARSE_CACHE_DEPTH;
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_OPERAND].max_cache_depth = ACPI_MAX_OBJECT_CACHE_DEPTH;
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_WALK].max_cache_depth   = ACPI_MAX_WALK_CACHE_DEPTH;
 
 	ACPI_MEM_TRACKING (acpi_gbl_memory_lists[ACPI_MEM_LIST_GLOBAL].list_name    = "Global Memory Allocation");
 	ACPI_MEM_TRACKING (acpi_gbl_memory_lists[ACPI_MEM_LIST_NSNODE].list_name    = "Namespace Nodes");
@@ -630,38 +712,32 @@ acpi_ut_init_globals (
 
 	/* ACPI table structure */
 
-	for (i = 0; i < NUM_ACPI_TABLES; i++)
+	for (i = 0; i < NUM_ACPI_TABLE_TYPES; i++)
 	{
-		acpi_gbl_acpi_tables[i].prev        = &acpi_gbl_acpi_tables[i];
-		acpi_gbl_acpi_tables[i].next        = &acpi_gbl_acpi_tables[i];
-		acpi_gbl_acpi_tables[i].pointer     = NULL;
-		acpi_gbl_acpi_tables[i].length      = 0;
-		acpi_gbl_acpi_tables[i].allocation  = ACPI_MEM_NOT_ALLOCATED;
-		acpi_gbl_acpi_tables[i].count       = 0;
+		acpi_gbl_table_lists[i].next        = NULL;
+		acpi_gbl_table_lists[i].count       = 0;
 	}
 
+	/* Mutex locked flags */
 
-	/* Address Space handler array */
-
-	for (i = 0; i < ACPI_NUM_ADDRESS_SPACES; i++)
+	for (i = 0; i < NUM_MUTEX; i++)
 	{
-		acpi_gbl_address_spaces[i].handler  = NULL;
-		acpi_gbl_address_spaces[i].context  = NULL;
+		acpi_gbl_mutex_info[i].mutex        = NULL;
+		acpi_gbl_mutex_info[i].owner_id     = ACPI_MUTEX_NOT_ACQUIRED;
+		acpi_gbl_mutex_info[i].use_count    = 0;
 	}
 
-	/* Mutex locked flags */
+	/* GPE support */
 
-	for (i = 0; i < NUM_MTX; i++)
-	{
-		acpi_gbl_acpi_mutex_info[i].mutex   = NULL;
-		acpi_gbl_acpi_mutex_info[i].owner_id = ACPI_MUTEX_NOT_ACQUIRED;
-		acpi_gbl_acpi_mutex_info[i].use_count = 0;
-	}
+	acpi_gbl_gpe_xrupt_list_head        = NULL;
+	acpi_gbl_gpe_fadt_blocks[0]         = NULL;
+	acpi_gbl_gpe_fadt_blocks[1]         = NULL;
 
 	/* Global notify handlers */
 
-	acpi_gbl_sys_notify.handler         = NULL;
-	acpi_gbl_drv_notify.handler         = NULL;
+	acpi_gbl_system_notify.handler      = NULL;
+	acpi_gbl_device_notify.handler      = NULL;
+	acpi_gbl_init_handler               = NULL;
 
 	/* Global "typed" ACPI table pointers */
 
@@ -675,11 +751,11 @@ acpi_ut_init_globals (
 
 	acpi_gbl_global_lock_acquired       = FALSE;
 	acpi_gbl_global_lock_thread_count   = 0;
+	acpi_gbl_global_lock_handle         = 0;
 
 	/* Miscellaneous variables */
 
-	acpi_gbl_system_flags               = 0;
-	acpi_gbl_startup_flags              = 0;
+	acpi_gbl_table_flags                = ACPI_PHYSICAL_POINTER;
 	acpi_gbl_rsdp_original_location     = 0;
 	acpi_gbl_cm_single_step             = FALSE;
 	acpi_gbl_db_terminate_threads       = FALSE;
@@ -687,33 +763,30 @@ acpi_ut_init_globals (
 	acpi_gbl_ns_lookup_count            = 0;
 	acpi_gbl_ps_find_count              = 0;
 	acpi_gbl_acpi_hardware_present      = TRUE;
-	acpi_gbl_next_table_owner_id        = FIRST_TABLE_ID;
-	acpi_gbl_next_method_owner_id       = FIRST_METHOD_ID;
+	acpi_gbl_next_table_owner_id        = ACPI_FIRST_TABLE_ID;
+	acpi_gbl_next_method_owner_id       = ACPI_FIRST_METHOD_ID;
 	acpi_gbl_debugger_configuration     = DEBUGGER_THREADING;
+	acpi_gbl_db_output_flags            = ACPI_DB_CONSOLE_OUTPUT;
 
 	/* Hardware oriented */
 
-	acpi_gbl_gpe0enable_register_save   = NULL;
-	acpi_gbl_gpe1_enable_register_save  = NULL;
-	acpi_gbl_original_mode              = SYS_MODE_UNKNOWN;   /*  original ACPI/legacy mode   */
-	acpi_gbl_gpe_registers              = NULL;
-	acpi_gbl_gpe_info                   = NULL;
+	acpi_gbl_events_initialized         = FALSE;
 
 	/* Namespace */
 
 	acpi_gbl_root_node                  = NULL;
 
-	acpi_gbl_root_node_struct.name      = ACPI_ROOT_NAME;
-	acpi_gbl_root_node_struct.data_type = ACPI_DESC_TYPE_NAMED;
-	acpi_gbl_root_node_struct.type      = ACPI_TYPE_ANY;
+	acpi_gbl_root_node_struct.name.integer = ACPI_ROOT_NAME;
+	acpi_gbl_root_node_struct.descriptor = ACPI_DESC_TYPE_NAMED;
+	acpi_gbl_root_node_struct.type      = ACPI_TYPE_DEVICE;
 	acpi_gbl_root_node_struct.child     = NULL;
 	acpi_gbl_root_node_struct.peer      = NULL;
 	acpi_gbl_root_node_struct.object    = NULL;
 	acpi_gbl_root_node_struct.flags     = ANOBJ_END_OF_PEER_LIST;
 
 
-#ifdef ACPI_DEBUG
-	acpi_gbl_lowest_stack_pointer       = ACPI_UINT32_MAX;
+#ifdef ACPI_DEBUG_OUTPUT
+	acpi_gbl_lowest_stack_pointer       = ACPI_SIZE_MAX;
 #endif
 
 	return_VOID;
diff -urNp linux-5400/drivers/acpi/utilities/utinit.c linux-5410/drivers/acpi/utilities/utinit.c
--- linux-5400/drivers/acpi/utilities/utinit.c
+++ linux-5410/drivers/acpi/utilities/utinit.c
@@ -1,52 +1,63 @@
 /******************************************************************************
  *
  * Module Name: utinit - Common ACPI subsystem initialization
- *              $Revision: 102 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "achware.h"
-#include "acnamesp.h"
-#include "acevents.h"
-#include "acparser.h"
-#include "acdispat.h"
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acevents.h>
 
 #define _COMPONENT          ACPI_UTILITIES
-	 MODULE_NAME         ("utinit")
-
-
-#define ACPI_OFFSET(d,o)    ((u32) &(((d *)0)->o))
-#define ACPI_FADT_OFFSET(o) ACPI_OFFSET (FADT_DESCRIPTOR, o)
+	 ACPI_MODULE_NAME    ("utinit")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_fadt_register_error
+ * FUNCTION:    acpi_ut_fadt_register_error
  *
- * PARAMETERS:  *Register_name          - Pointer to string identifying register
+ * PARAMETERS:  *register_name          - Pointer to string identifying register
  *              Value                   - Actual register contents value
- *              Acpi_test_spec_section  - TDS section containing assertion
- *              Acpi_assertion          - Assertion number being tested
+ *              acpi_test_spec_section  - TDS section containing assertion
+ *              acpi_assertion          - Assertion number being tested
  *
  * RETURN:      AE_BAD_VALUE
  *
@@ -54,25 +65,22 @@
  *
  ******************************************************************************/
 
-static acpi_status
+static void
 acpi_ut_fadt_register_error (
-	NATIVE_CHAR             *register_name,
-	u32                     value,
-	u32                     offset)
+	char                            *register_name,
+	u32                             value,
+	acpi_size                       offset)
 {
 
-	REPORT_ERROR (
-		("Invalid FADT value %s=%lX at offset %lX FADT=%p\n",
-		register_name, value, offset, acpi_gbl_FADT));
-
-
-	return (AE_BAD_VALUE);
+	ACPI_REPORT_WARNING (
+		("Invalid FADT value %s=%X at offset %X FADT=%p\n",
+		register_name, value, (u32) offset, acpi_gbl_FADT));
 }
 
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_ut_validate_fadt
+ * FUNCTION:    acpi_ut_validate_fadt
  *
  * PARAMETERS:  None
  *
@@ -86,101 +94,114 @@ acpi_status
 acpi_ut_validate_fadt (
 	void)
 {
-	acpi_status                 status = AE_OK;
-
 
 	/*
 	 * Verify Fixed ACPI Description Table fields,
 	 * but don't abort on any problems, just display error
 	 */
 	if (acpi_gbl_FADT->pm1_evt_len < 4) {
-		status = acpi_ut_fadt_register_error ("PM1_EVT_LEN",
+		acpi_ut_fadt_register_error ("PM1_EVT_LEN",
 				  (u32) acpi_gbl_FADT->pm1_evt_len,
 				  ACPI_FADT_OFFSET (pm1_evt_len));
 	}
 
 	if (!acpi_gbl_FADT->pm1_cnt_len) {
-		status = acpi_ut_fadt_register_error ("PM1_CNT_LEN", 0,
+		acpi_ut_fadt_register_error ("PM1_CNT_LEN", 0,
 				  ACPI_FADT_OFFSET (pm1_cnt_len));
 	}
 
-	if (!ACPI_VALID_ADDRESS (acpi_gbl_FADT->Xpm1a_evt_blk.address)) {
-		status = acpi_ut_fadt_register_error ("X_PM1a_EVT_BLK", 0,
-				  ACPI_FADT_OFFSET (Xpm1a_evt_blk.address));
+	if (!acpi_gbl_FADT->xpm1a_evt_blk.address) {
+		acpi_ut_fadt_register_error ("X_PM1a_EVT_BLK", 0,
+				  ACPI_FADT_OFFSET (xpm1a_evt_blk.address));
 	}
 
-	if (!ACPI_VALID_ADDRESS (acpi_gbl_FADT->Xpm1a_cnt_blk.address)) {
-		status = acpi_ut_fadt_register_error ("X_PM1a_CNT_BLK", 0,
-				  ACPI_FADT_OFFSET (Xpm1a_cnt_blk.address));
+	if (!acpi_gbl_FADT->xpm1a_cnt_blk.address) {
+		acpi_ut_fadt_register_error ("X_PM1a_CNT_BLK", 0,
+				  ACPI_FADT_OFFSET (xpm1a_cnt_blk.address));
 	}
 
-	if (!ACPI_VALID_ADDRESS (acpi_gbl_FADT->Xpm_tmr_blk.address)) {
-		status = acpi_ut_fadt_register_error ("X_PM_TMR_BLK", 0,
-				  ACPI_FADT_OFFSET (Xpm_tmr_blk.address));
+	if (!acpi_gbl_FADT->xpm_tmr_blk.address) {
+		acpi_ut_fadt_register_error ("X_PM_TMR_BLK", 0,
+				  ACPI_FADT_OFFSET (xpm_tmr_blk.address));
 	}
 
-	if ((ACPI_VALID_ADDRESS (acpi_gbl_FADT->Xpm2_cnt_blk.address) &&
+	if ((acpi_gbl_FADT->xpm2_cnt_blk.address &&
 		!acpi_gbl_FADT->pm2_cnt_len)) {
-		status = acpi_ut_fadt_register_error ("PM2_CNT_LEN",
+		acpi_ut_fadt_register_error ("PM2_CNT_LEN",
 				  (u32) acpi_gbl_FADT->pm2_cnt_len,
 				  ACPI_FADT_OFFSET (pm2_cnt_len));
 	}
 
 	if (acpi_gbl_FADT->pm_tm_len < 4) {
-		status = acpi_ut_fadt_register_error ("PM_TM_LEN",
+		acpi_ut_fadt_register_error ("PM_TM_LEN",
 				  (u32) acpi_gbl_FADT->pm_tm_len,
 				  ACPI_FADT_OFFSET (pm_tm_len));
 	}
 
-	/* length of GPE blocks must be a multiple of 2 */
+	/* Length of GPE blocks must be a multiple of 2 */
 
-	if (ACPI_VALID_ADDRESS (acpi_gbl_FADT->Xgpe0blk.address) &&
-		(acpi_gbl_FADT->gpe0blk_len & 1)) {
-		status = acpi_ut_fadt_register_error ("(x)GPE0_BLK_LEN",
-				  (u32) acpi_gbl_FADT->gpe0blk_len,
-				  ACPI_FADT_OFFSET (gpe0blk_len));
+	if (acpi_gbl_FADT->xgpe0_blk.address &&
+		(acpi_gbl_FADT->gpe0_blk_len & 1)) {
+		acpi_ut_fadt_register_error ("(x)GPE0_BLK_LEN",
+				  (u32) acpi_gbl_FADT->gpe0_blk_len,
+				  ACPI_FADT_OFFSET (gpe0_blk_len));
 	}
 
-	if (ACPI_VALID_ADDRESS (acpi_gbl_FADT->Xgpe1_blk.address) &&
+	if (acpi_gbl_FADT->xgpe1_blk.address &&
 		(acpi_gbl_FADT->gpe1_blk_len & 1)) {
-		status = acpi_ut_fadt_register_error ("(x)GPE1_BLK_LEN",
+		acpi_ut_fadt_register_error ("(x)GPE1_BLK_LEN",
 				  (u32) acpi_gbl_FADT->gpe1_blk_len,
 				  ACPI_FADT_OFFSET (gpe1_blk_len));
 	}
 
-	return (status);
+	return (AE_OK);
 }
 
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_ut_terminate
+ * FUNCTION:    acpi_ut_terminate
  *
  * PARAMETERS:  none
  *
  * RETURN:      none
  *
- * DESCRIPTION: free memory allocated for table storage.
+ * DESCRIPTION: free global memory
  *
  ******************************************************************************/
 
 void
 acpi_ut_terminate (void)
 {
+	struct acpi_gpe_block_info      *gpe_block;
+	struct acpi_gpe_block_info      *next_gpe_block;
+	struct acpi_gpe_xrupt_info      *gpe_xrupt_info;
+	struct acpi_gpe_xrupt_info      *next_gpe_xrupt_info;
 
-	FUNCTION_TRACE ("Ut_terminate");
+
+	ACPI_FUNCTION_TRACE ("ut_terminate");
 
 
 	/* Free global tables, etc. */
 
-	if (acpi_gbl_gpe0enable_register_save) {
-		ACPI_MEM_FREE (acpi_gbl_gpe0enable_register_save);
-	}
 
-	if (acpi_gbl_gpe1_enable_register_save) {
-		ACPI_MEM_FREE (acpi_gbl_gpe1_enable_register_save);
-	}
+	/* Free global GPE blocks and related info structures */
 
+	gpe_xrupt_info = acpi_gbl_gpe_xrupt_list_head;
+	while (gpe_xrupt_info) {
+		gpe_block = gpe_xrupt_info->gpe_block_list_head;
+		while (gpe_block) {
+			next_gpe_block = gpe_block->next;
+			ACPI_MEM_FREE (gpe_block->event_info);
+			ACPI_MEM_FREE (gpe_block->register_info);
+			ACPI_MEM_FREE (gpe_block);
+
+			gpe_block = next_gpe_block;
+		}
+		next_gpe_xrupt_info = gpe_xrupt_info->next;
+		ACPI_MEM_FREE (gpe_xrupt_info);
+		gpe_xrupt_info = next_gpe_xrupt_info;
+	}
 
 	return_VOID;
 }
@@ -188,7 +209,7 @@ acpi_ut_terminate (void)
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_subsystem_shutdown
+ * FUNCTION:    acpi_ut_subsystem_shutdown
  *
  * PARAMETERS:  none
  *
@@ -199,17 +220,17 @@ acpi_ut_terminate (void)
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ut_subsystem_shutdown (void)
 {
 
-	FUNCTION_TRACE ("Ut_subsystem_shutdown");
+	ACPI_FUNCTION_TRACE ("ut_subsystem_shutdown");
 
 	/* Just exit if subsystem is already shutdown */
 
 	if (acpi_gbl_shutdown) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "ACPI Subsystem is already terminated\n"));
-		return_ACPI_STATUS (AE_OK);
+		return_VOID;
 	}
 
 	/* Subsystem appears active, go ahead and shut it down */
@@ -217,30 +238,21 @@ acpi_ut_subsystem_shutdown (void)
 	acpi_gbl_shutdown = TRUE;
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Shutting down ACPI Subsystem...\n"));
 
+	/* Close the acpi_event Handling */
+
+	acpi_ev_terminate ();
 
 	/* Close the Namespace */
 
 	acpi_ns_terminate ();
 
-	/* Close the Acpi_event Handling */
-
-	acpi_ev_terminate ();
-
 	/* Close the globals */
 
 	acpi_ut_terminate ();
 
-	/* Flush the local cache(s) */
-
-	acpi_ut_delete_generic_state_cache ();
-	acpi_ut_delete_object_cache ();
-	acpi_ds_delete_walk_state_cache ();
-
-	/* Close the Parser */
+	/* Purge the local caches */
 
-	/* TBD: [Restructure] Acpi_ps_terminate () */
-
-	acpi_ps_delete_parse_cache ();
+	(void) acpi_purge_cached_objects ();
 
 	/* Debug only - display leftover memory allocation, if any */
 
@@ -248,7 +260,7 @@ acpi_ut_subsystem_shutdown (void)
 	acpi_ut_dump_allocations (ACPI_UINT32_MAX, NULL);
 #endif
 
-	return_ACPI_STATUS (AE_OK);
+	return_VOID;
 }
 
 
diff -urNp linux-5400/drivers/acpi/utilities/utmath.c linux-5410/drivers/acpi/utilities/utmath.c
--- linux-5400/drivers/acpi/utilities/utmath.c
+++ linux-5410/drivers/acpi/utilities/utmath.c
@@ -1,34 +1,52 @@
 /*******************************************************************************
  *
  * Module Name: utmath - Integer math support routines
- *              $Revision: 7 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
+#include <acpi/acpi.h>
 
 
 #define _COMPONENT          ACPI_UTILITIES
-	 MODULE_NAME         ("utmath")
+	 ACPI_MODULE_NAME    ("utmath")
 
 /*
  * Support for double-precision integer divide.  This code is included here
@@ -39,12 +57,12 @@
 #ifndef ACPI_USE_NATIVE_DIVIDE
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_short_divide
+ * FUNCTION:    acpi_ut_short_divide
  *
- * PARAMETERS:  In_dividend         - Pointer to the dividend
+ * PARAMETERS:  in_dividend         - Pointer to the dividend
  *              Divisor             - 32-bit divisor
- *              Out_quotient        - Pointer to where the quotient is returned
- *              Out_remainder       - Pointer to where the remainder is returned
+ *              out_quotient        - Pointer to where the quotient is returned
+ *              out_remainder       - Pointer to where the remainder is returned
  *
  * RETURN:      Status (Checks for divide-by-zero)
  *
@@ -56,24 +74,24 @@
 
 acpi_status
 acpi_ut_short_divide (
-	acpi_integer            *in_dividend,
-	u32                     divisor,
-	acpi_integer            *out_quotient,
-	u32                     *out_remainder)
+	acpi_integer                    *in_dividend,
+	u32                             divisor,
+	acpi_integer                    *out_quotient,
+	u32                             *out_remainder)
 {
-	uint64_overlay          dividend;
-	uint64_overlay          quotient;
-	u32                     remainder32;
+	union uint64_overlay            dividend;
+	union uint64_overlay            quotient;
+	u32                             remainder32;
 
 
-	FUNCTION_TRACE ("Ut_short_divide");
+	ACPI_FUNCTION_TRACE ("ut_short_divide");
 
 	dividend.full = *in_dividend;
 
 	/* Always check for a zero divisor */
 
 	if (divisor == 0) {
-		REPORT_ERROR (("Acpi_ut_short_divide: Divide by zero\n"));
+		ACPI_REPORT_ERROR (("acpi_ut_short_divide: Divide by zero\n"));
 		return_ACPI_STATUS (AE_AML_DIVIDE_BY_ZERO);
 	}
 
@@ -101,12 +119,12 @@ acpi_ut_short_divide (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_divide
+ * FUNCTION:    acpi_ut_divide
  *
- * PARAMETERS:  In_dividend         - Pointer to the dividend
- *              In_divisor          - Pointer to the divisor
- *              Out_quotient        - Pointer to where the quotient is returned
- *              Out_remainder       - Pointer to where the remainder is returned
+ * PARAMETERS:  in_dividend         - Pointer to the dividend
+ *              in_divisor          - Pointer to the divisor
+ *              out_quotient        - Pointer to where the quotient is returned
+ *              out_remainder       - Pointer to where the remainder is returned
  *
  * RETURN:      Status (Checks for divide-by-zero)
  *
@@ -116,29 +134,29 @@ acpi_ut_short_divide (
 
 acpi_status
 acpi_ut_divide (
-	acpi_integer            *in_dividend,
-	acpi_integer            *in_divisor,
-	acpi_integer            *out_quotient,
-	acpi_integer            *out_remainder)
+	acpi_integer                    *in_dividend,
+	acpi_integer                    *in_divisor,
+	acpi_integer                    *out_quotient,
+	acpi_integer                    *out_remainder)
 {
-	uint64_overlay          dividend;
-	uint64_overlay          divisor;
-	uint64_overlay          quotient;
-	uint64_overlay          remainder;
-	uint64_overlay          normalized_dividend;
-	uint64_overlay          normalized_divisor;
-	u32                     partial1;
-	uint64_overlay          partial2;
-	uint64_overlay          partial3;
+	union uint64_overlay            dividend;
+	union uint64_overlay            divisor;
+	union uint64_overlay            quotient;
+	union uint64_overlay            remainder;
+	union uint64_overlay            normalized_dividend;
+	union uint64_overlay            normalized_divisor;
+	u32                             partial1;
+	union uint64_overlay            partial2;
+	union uint64_overlay            partial3;
 
 
-	FUNCTION_TRACE ("Ut_divide");
+	ACPI_FUNCTION_TRACE ("ut_divide");
 
 
 	/* Always check for a zero divisor */
 
 	if (*in_divisor == 0) {
-		REPORT_ERROR (("Acpi_ut_divide: Divide by zero\n"));
+		ACPI_REPORT_ERROR (("acpi_ut_divide: Divide by zero\n"));
 		return_ACPI_STATUS (AE_AML_DIVIDE_BY_ZERO);
 	}
 
@@ -193,7 +211,7 @@ acpi_ut_divide (
 		 */
 		partial1      = quotient.part.lo * divisor.part.hi;
 		partial2.full = (acpi_integer) quotient.part.lo * divisor.part.lo;
-		partial3.full = partial2.part.hi + partial1;
+		partial3.full = (acpi_integer) partial2.part.hi + partial1;
 
 		remainder.part.hi = partial3.part.lo;
 		remainder.part.lo = partial2.part.lo;
@@ -213,8 +231,8 @@ acpi_ut_divide (
 			}
 
 			remainder.full    = remainder.full - dividend.full;
-			remainder.part.hi = -((s32) remainder.part.hi);
-			remainder.part.lo = -((s32) remainder.part.lo);
+			remainder.part.hi = (u32) -((s32) remainder.part.hi);
+			remainder.part.lo = (u32) -((s32) remainder.part.lo);
 
 			if (remainder.part.lo) {
 				remainder.part.hi--;
@@ -238,9 +256,9 @@ acpi_ut_divide (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_short_divide, Acpi_ut_divide
+ * FUNCTION:    acpi_ut_short_divide, acpi_ut_divide
  *
- * DESCRIPTION: Native versions of the Ut_divide functions. Use these if either
+ * DESCRIPTION: Native versions of the ut_divide functions. Use these if either
  *              1) The target is a 64-bit platform and therefore 64-bit
  *                 integer math is supported directly by the machine.
  *              2) The target is a 32-bit or 16-bit platform, and the
@@ -251,19 +269,19 @@ acpi_ut_divide (
 
 acpi_status
 acpi_ut_short_divide (
-	acpi_integer            *in_dividend,
-	u32                     divisor,
-	acpi_integer            *out_quotient,
-	u32                     *out_remainder)
+	acpi_integer                    *in_dividend,
+	u32                             divisor,
+	acpi_integer                    *out_quotient,
+	u32                             *out_remainder)
 {
 
-	FUNCTION_TRACE ("Ut_short_divide");
+	ACPI_FUNCTION_TRACE ("ut_short_divide");
 
 
 	/* Always check for a zero divisor */
 
 	if (divisor == 0) {
-		REPORT_ERROR (("Acpi_ut_short_divide: Divide by zero\n"));
+		ACPI_REPORT_ERROR (("acpi_ut_short_divide: Divide by zero\n"));
 		return_ACPI_STATUS (AE_AML_DIVIDE_BY_ZERO);
 	}
 
@@ -281,18 +299,18 @@ acpi_ut_short_divide (
 
 acpi_status
 acpi_ut_divide (
-	acpi_integer            *in_dividend,
-	acpi_integer            *in_divisor,
-	acpi_integer            *out_quotient,
-	acpi_integer            *out_remainder)
+	acpi_integer                    *in_dividend,
+	acpi_integer                    *in_divisor,
+	acpi_integer                    *out_quotient,
+	acpi_integer                    *out_remainder)
 {
-	FUNCTION_TRACE ("Ut_divide");
+	ACPI_FUNCTION_TRACE ("ut_divide");
 
 
 	/* Always check for a zero divisor */
 
 	if (*in_divisor == 0) {
-		REPORT_ERROR (("Acpi_ut_divide: Divide by zero\n"));
+		ACPI_REPORT_ERROR (("acpi_ut_divide: Divide by zero\n"));
 		return_ACPI_STATUS (AE_AML_DIVIDE_BY_ZERO);
 	}
 
diff -urNp linux-5400/drivers/acpi/utilities/utmisc.c linux-5410/drivers/acpi/utilities/utmisc.c
--- linux-5400/drivers/acpi/utilities/utmisc.c
+++ linux-5410/drivers/acpi/utilities/utmisc.c
@@ -1,45 +1,292 @@
 /*******************************************************************************
  *
  * Module Name: utmisc - common utility procedures
- *              $Revision: 52 $
  *
  ******************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acevents.h"
-#include "achware.h"
-#include "acnamesp.h"
-#include "acinterp.h"
-#include "amlcode.h"
-#include "acdebug.h"
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
 
 
 #define _COMPONENT          ACPI_UTILITIES
-	 MODULE_NAME         ("utmisc")
+	 ACPI_MODULE_NAME    ("utmisc")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_valid_acpi_name
+ * FUNCTION:    acpi_ut_print_string
+ *
+ * PARAMETERS:  String          - Null terminated ASCII string
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dump an ASCII string with support for ACPI-defined escape
+ *              sequences.
+ *
+ ******************************************************************************/
+
+void
+acpi_ut_print_string (
+	char                            *string,
+	u8                              max_length)
+{
+	u32                             i;
+
+
+	if (!string) {
+		acpi_os_printf ("<\"NULL STRING PTR\">");
+		return;
+	}
+
+	acpi_os_printf ("\"");
+	for (i = 0; string[i] && (i < max_length); i++) {
+		/* Escape sequences */
+
+		switch (string[i]) {
+		case 0x07:
+			acpi_os_printf ("\\a");      /* BELL */
+			break;
+
+		case 0x08:
+			acpi_os_printf ("\\b");     /* BACKSPACE */
+			break;
+
+		case 0x0C:
+			acpi_os_printf ("\\f");     /* FORMFEED */
+			break;
+
+		case 0x0A:
+			acpi_os_printf ("\\n");     /* LINEFEED */
+			break;
+
+		case 0x0D:
+			acpi_os_printf ("\\r");     /* CARRIAGE RETURN*/
+			break;
+
+		case 0x09:
+			acpi_os_printf ("\\t");     /* HORIZONTAL TAB */
+			break;
+
+		case 0x0B:
+			acpi_os_printf ("\\v");     /* VERTICAL TAB */
+			break;
+
+		case '\'':                      /* Single Quote */
+		case '\"':                      /* Double Quote */
+		case '\\':                      /* Backslash */
+			acpi_os_printf ("\\%c", (int) string[i]);
+			break;
+
+		default:
+
+			/* Check for printable character or hex escape */
+
+			if (ACPI_IS_PRINT (string[i]))
+			{
+				/* This is a normal character */
+
+				acpi_os_printf ("%c", (int) string[i]);
+			}
+			else
+			{
+				/* All others will be Hex escapes */
+
+				acpi_os_printf ("\\x%2.2X", (s32) string[i]);
+			}
+			break;
+		}
+	}
+	acpi_os_printf ("\"");
+
+	if (i == max_length && string[i]) {
+		acpi_os_printf ("...");
+	}
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_dword_byte_swap
+ *
+ * PARAMETERS:  Value           - Value to be converted
+ *
+ * DESCRIPTION: Convert a 32-bit value to big-endian (swap the bytes)
+ *
+ ******************************************************************************/
+
+u32
+acpi_ut_dword_byte_swap (
+	u32                             value)
+{
+	union {
+		u32                         value;
+		u8                          bytes[4];
+	} out;
+
+	union {
+		u32                         value;
+		u8                          bytes[4];
+	} in;
+
+
+	ACPI_FUNCTION_ENTRY ();
+
+
+	in.value = value;
+
+	out.bytes[0] = in.bytes[3];
+	out.bytes[1] = in.bytes[2];
+	out.bytes[2] = in.bytes[1];
+	out.bytes[3] = in.bytes[0];
+
+	return (out.value);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_set_integer_width
+ *
+ * PARAMETERS:  Revision            From DSDT header
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Set the global integer bit width based upon the revision
+ *              of the DSDT.  For Revision 1 and 0, Integers are 32 bits.
+ *              For Revision 2 and above, Integers are 64 bits.  Yes, this
+ *              makes a difference.
+ *
+ ******************************************************************************/
+
+void
+acpi_ut_set_integer_width (
+	u8                              revision)
+{
+
+	if (revision <= 1) {
+		acpi_gbl_integer_bit_width = 32;
+		acpi_gbl_integer_nybble_width = 8;
+		acpi_gbl_integer_byte_width = 4;
+	}
+	else {
+		acpi_gbl_integer_bit_width = 64;
+		acpi_gbl_integer_nybble_width = 16;
+		acpi_gbl_integer_byte_width = 8;
+	}
+}
+
+
+#ifdef ACPI_DEBUG_OUTPUT
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_display_init_pathname
+ *
+ * PARAMETERS:  obj_handle          - Handle whose pathname will be displayed
+ *              Path                - Additional path string to be appended.
+ *                                      (NULL if no extra path)
+ *
+ * RETURN:      acpi_status
+ *
+ * DESCRIPTION: Display full pathname of an object, DEBUG ONLY
+ *
+ ******************************************************************************/
+
+void
+acpi_ut_display_init_pathname (
+	u8                              type,
+	struct acpi_namespace_node      *obj_handle,
+	char                            *path)
+{
+	acpi_status                     status;
+	struct acpi_buffer              buffer;
+
+
+	ACPI_FUNCTION_ENTRY ();
+
+
+	/* Only print the path if the appropriate debug level is enabled */
+
+	if (!(acpi_dbg_level & ACPI_LV_INIT_NAMES)) {
+		return;
+	}
+
+	/* Get the full pathname to the node */
+
+	buffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;
+	status = acpi_ns_handle_to_pathname (obj_handle, &buffer);
+	if (ACPI_FAILURE (status)) {
+		return;
+	}
+
+	/* Print what we're doing */
+
+	switch (type) {
+	case ACPI_TYPE_METHOD:
+		acpi_os_printf ("Executing  ");
+		break;
+
+	default:
+		acpi_os_printf ("Initializing ");
+		break;
+	}
+
+	/* Print the object type and pathname */
+
+	acpi_os_printf ("%-12s %s", acpi_ut_get_type_name (type), (char *) buffer.pointer);
+
+	/* Extra path is used to append names like _STA, _INI, etc. */
+
+	if (path) {
+		acpi_os_printf (".%s", path);
+	}
+	acpi_os_printf ("\n");
+
+	ACPI_MEM_FREE (buffer.pointer);
+}
+#endif
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_valid_acpi_name
  *
  * PARAMETERS:  Character           - The character to be examined
  *
@@ -54,13 +301,13 @@
 
 u8
 acpi_ut_valid_acpi_name (
-	u32                     name)
+	u32                             name)
 {
-	NATIVE_CHAR             *name_ptr = (NATIVE_CHAR *) &name;
-	u32                     i;
+	char                            *name_ptr = (char *) &name;
+	u32                             i;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	for (i = 0; i < ACPI_NAME_SIZE; i++) {
@@ -77,7 +324,7 @@ acpi_ut_valid_acpi_name (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_valid_acpi_character
+ * FUNCTION:    acpi_ut_valid_acpi_character
  *
  * PARAMETERS:  Character           - The character to be examined
  *
@@ -89,10 +336,10 @@ acpi_ut_valid_acpi_name (
 
 u8
 acpi_ut_valid_acpi_character (
-	NATIVE_CHAR             character)
+	char                            character)
 {
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 	return ((u8)   ((character == '_') ||
 			   (character >= 'A' && character <= 'Z') ||
@@ -102,40 +349,185 @@ acpi_ut_valid_acpi_character (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_strupr
+ * FUNCTION:    acpi_ut_strtoul64
+ *
+ * PARAMETERS:  String          - Null terminated string
+ *              Terminater      - Where a pointer to the terminating byte is returned
+ *              Base            - Radix of the string
+ *
+ * RETURN:      Converted value
+ *
+ * DESCRIPTION: Convert a string into an unsigned value.
+ *
+ ******************************************************************************/
+#define NEGATIVE    1
+#define POSITIVE    0
+
+acpi_status
+acpi_ut_strtoul64 (
+	char                            *string,
+	u32                             base,
+	acpi_integer                    *ret_integer)
+{
+	u32                             index;
+	acpi_integer                    return_value = 0;
+	acpi_status                     status = AE_OK;
+	acpi_integer                    dividend;
+	acpi_integer                    quotient;
+
+
+	*ret_integer = 0;
+
+	switch (base) {
+	case 0:
+	case 8:
+	case 10:
+	case 16:
+		break;
+
+	default:
+		/*
+		 * The specified Base parameter is not in the domain of
+		 * this function:
+		 */
+		return (AE_BAD_PARAMETER);
+	}
+
+	/*
+	 * skip over any white space in the buffer:
+	 */
+	while (ACPI_IS_SPACE (*string) || *string == '\t') {
+		++string;
+	}
+
+	/*
+	 * If the input parameter Base is zero, then we need to
+	 * determine if it is octal, decimal, or hexadecimal:
+	 */
+	if (base == 0) {
+		if (*string == '0') {
+			if (ACPI_TOLOWER (*(++string)) == 'x') {
+				base = 16;
+				++string;
+			}
+			else {
+				base = 8;
+			}
+		}
+		else {
+			base = 10;
+		}
+	}
+
+	/*
+	 * For octal and hexadecimal bases, skip over the leading
+	 * 0 or 0x, if they are present.
+	 */
+	if (base == 8 && *string == '0') {
+		string++;
+	}
+
+	if (base == 16 &&
+		*string == '0' &&
+		ACPI_TOLOWER (*(++string)) == 'x') {
+		string++;
+	}
+
+	/* Main loop: convert the string to an unsigned long */
+
+	while (*string) {
+		if (ACPI_IS_DIGIT (*string)) {
+			index = ((u8) *string) - '0';
+		}
+		else {
+			index = (u8) ACPI_TOUPPER (*string);
+			if (ACPI_IS_UPPER ((char) index)) {
+				index = index - 'A' + 10;
+			}
+			else {
+				goto error_exit;
+			}
+		}
+
+		if (index >= base) {
+			goto error_exit;
+		}
+
+		/* Check to see if value is out of range: */
+
+		dividend = ACPI_INTEGER_MAX - (acpi_integer) index;
+		(void) acpi_ut_short_divide (&dividend, base, &quotient, NULL);
+		if (return_value > quotient) {
+			goto error_exit;
+		}
+
+		return_value *= base;
+		return_value += index;
+		++string;
+	}
+
+	*ret_integer = return_value;
+	return (status);
+
+
+error_exit:
+	switch (base) {
+	case 8:
+		status = AE_BAD_OCTAL_CONSTANT;
+		break;
+
+	case 10:
+		status = AE_BAD_DECIMAL_CONSTANT;
+		break;
+
+	case 16:
+		status = AE_BAD_HEX_CONSTANT;
+		break;
+
+	default:
+		/* Base validated above */
+		break;
+	}
+
+	return (status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_strupr
  *
- * PARAMETERS:  Src_string      - The source string to convert to
+ * PARAMETERS:  src_string      - The source string to convert to
  *
- * RETURN:      Src_string
+ * RETURN:      src_string
  *
  * DESCRIPTION: Convert string to uppercase
  *
  ******************************************************************************/
 
-NATIVE_CHAR *
+char *
 acpi_ut_strupr (
-	NATIVE_CHAR             *src_string)
+	char                            *src_string)
 {
-	NATIVE_CHAR             *string;
+	char                            *string;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	/* Walk entire string, uppercasing the letters */
 
 	for (string = src_string; *string; ) {
-		*string = (char) TOUPPER (*string);
+		*string = (char) ACPI_TOUPPER (*string);
 		string++;
 	}
 
-
 	return (src_string);
 }
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_mutex_initialize
+ * FUNCTION:    acpi_ut_mutex_initialize
  *
  * PARAMETERS:  None.
  *
@@ -149,30 +541,33 @@ acpi_status
 acpi_ut_mutex_initialize (
 	void)
 {
-	u32                     i;
-	acpi_status             status;
+	u32                             i;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Ut_mutex_initialize");
+	ACPI_FUNCTION_TRACE ("ut_mutex_initialize");
 
 
 	/*
 	 * Create each of the predefined mutex objects
 	 */
-	for (i = 0; i < NUM_MTX; i++) {
+	for (i = 0; i < NUM_MUTEX; i++) {
 		status = acpi_ut_create_mutex (i);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
 	}
 
+
+	status = acpi_os_create_lock (&acpi_gbl_gpe_lock);
+
 	return_ACPI_STATUS (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_mutex_terminate
+ * FUNCTION:    acpi_ut_mutex_terminate
  *
  * PARAMETERS:  None.
  *
@@ -186,28 +581,29 @@ void
 acpi_ut_mutex_terminate (
 	void)
 {
-	u32                     i;
+	u32                             i;
 
 
-	FUNCTION_TRACE ("Ut_mutex_terminate");
+	ACPI_FUNCTION_TRACE ("ut_mutex_terminate");
 
 
 	/*
 	 * Delete each predefined mutex object
 	 */
-	for (i = 0; i < NUM_MTX; i++) {
-		acpi_ut_delete_mutex (i);
+	for (i = 0; i < NUM_MUTEX; i++) {
+		(void) acpi_ut_delete_mutex (i);
 	}
 
+	acpi_os_delete_lock (acpi_gbl_gpe_lock);
 	return_VOID;
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_create_mutex
+ * FUNCTION:    acpi_ut_create_mutex
  *
- * PARAMETERS:  Mutex_iD        - ID of the mutex to be created
+ * PARAMETERS:  mutex_iD        - ID of the mutex to be created
  *
  * RETURN:      Status
  *
@@ -217,24 +613,23 @@ acpi_ut_mutex_terminate (
 
 acpi_status
 acpi_ut_create_mutex (
-	ACPI_MUTEX_HANDLE       mutex_id)
+	acpi_mutex_handle               mutex_id)
 {
-	acpi_status             status = AE_OK;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE_U32 ("Ut_create_mutex", mutex_id);
+	ACPI_FUNCTION_TRACE_U32 ("ut_create_mutex", mutex_id);
 
 
-	if (mutex_id > MAX_MTX) {
+	if (mutex_id > MAX_MUTEX) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-
-	if (!acpi_gbl_acpi_mutex_info[mutex_id].mutex) {
+	if (!acpi_gbl_mutex_info[mutex_id].mutex) {
 		status = acpi_os_create_semaphore (1, 1,
-				  &acpi_gbl_acpi_mutex_info[mutex_id].mutex);
-		acpi_gbl_acpi_mutex_info[mutex_id].owner_id = ACPI_MUTEX_NOT_ACQUIRED;
-		acpi_gbl_acpi_mutex_info[mutex_id].use_count = 0;
+				  &acpi_gbl_mutex_info[mutex_id].mutex);
+		acpi_gbl_mutex_info[mutex_id].owner_id = ACPI_MUTEX_NOT_ACQUIRED;
+		acpi_gbl_mutex_info[mutex_id].use_count = 0;
 	}
 
 	return_ACPI_STATUS (status);
@@ -243,9 +638,9 @@ acpi_ut_create_mutex (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_delete_mutex
+ * FUNCTION:    acpi_ut_delete_mutex
  *
- * PARAMETERS:  Mutex_iD        - ID of the mutex to be deleted
+ * PARAMETERS:  mutex_iD        - ID of the mutex to be deleted
  *
  * RETURN:      Status
  *
@@ -255,23 +650,22 @@ acpi_ut_create_mutex (
 
 acpi_status
 acpi_ut_delete_mutex (
-	ACPI_MUTEX_HANDLE       mutex_id)
+	acpi_mutex_handle               mutex_id)
 {
-	acpi_status             status;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE_U32 ("Ut_delete_mutex", mutex_id);
+	ACPI_FUNCTION_TRACE_U32 ("ut_delete_mutex", mutex_id);
 
 
-	if (mutex_id > MAX_MTX) {
+	if (mutex_id > MAX_MUTEX) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
+	status = acpi_os_delete_semaphore (acpi_gbl_mutex_info[mutex_id].mutex);
 
-	status = acpi_os_delete_semaphore (acpi_gbl_acpi_mutex_info[mutex_id].mutex);
-
-	acpi_gbl_acpi_mutex_info[mutex_id].mutex = NULL;
-	acpi_gbl_acpi_mutex_info[mutex_id].owner_id = ACPI_MUTEX_NOT_ACQUIRED;
+	acpi_gbl_mutex_info[mutex_id].mutex = NULL;
+	acpi_gbl_mutex_info[mutex_id].owner_id = ACPI_MUTEX_NOT_ACQUIRED;
 
 	return_ACPI_STATUS (status);
 }
@@ -279,9 +673,9 @@ acpi_ut_delete_mutex (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_acquire_mutex
+ * FUNCTION:    acpi_ut_acquire_mutex
  *
- * PARAMETERS:  Mutex_iD        - ID of the mutex to be acquired
+ * PARAMETERS:  mutex_iD        - ID of the mutex to be acquired
  *
  * RETURN:      Status
  *
@@ -291,21 +685,20 @@ acpi_ut_delete_mutex (
 
 acpi_status
 acpi_ut_acquire_mutex (
-	ACPI_MUTEX_HANDLE       mutex_id)
+	acpi_mutex_handle               mutex_id)
 {
-	acpi_status             status;
-	u32                     i;
-	u32                     this_thread_id;
+	acpi_status                     status;
+	u32                             i;
+	u32                             this_thread_id;
 
 
-	PROC_NAME ("Ut_acquire_mutex");
+	ACPI_FUNCTION_NAME ("ut_acquire_mutex");
 
 
-	if (mutex_id > MAX_MTX) {
+	if (mutex_id > MAX_MUTEX) {
 		return (AE_BAD_PARAMETER);
 	}
 
-
 	this_thread_id = acpi_os_get_thread_id ();
 
 	/*
@@ -314,8 +707,8 @@ acpi_ut_acquire_mutex (
 	 * the mutex ordering rule.  This indicates a coding error somewhere in
 	 * the ACPI subsystem code.
 	 */
-	for (i = mutex_id; i < MAX_MTX; i++) {
-		if (acpi_gbl_acpi_mutex_info[i].owner_id == this_thread_id) {
+	for (i = mutex_id; i < MAX_MUTEX; i++) {
+		if (acpi_gbl_mutex_info[i].owner_id == this_thread_id) {
 			if (i == mutex_id) {
 				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 						"Mutex [%s] already acquired by this thread [%X]\n",
@@ -333,22 +726,19 @@ acpi_ut_acquire_mutex (
 		}
 	}
 
-
 	ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX,
 			 "Thread %X attempting to acquire Mutex [%s]\n",
 			 this_thread_id, acpi_ut_get_mutex_name (mutex_id)));
 
-	status = acpi_os_wait_semaphore (acpi_gbl_acpi_mutex_info[mutex_id].mutex,
-			   1, WAIT_FOREVER);
-
+	status = acpi_os_wait_semaphore (acpi_gbl_mutex_info[mutex_id].mutex,
+			   1, ACPI_WAIT_FOREVER);
 	if (ACPI_SUCCESS (status)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Thread %X acquired Mutex [%s]\n",
 				 this_thread_id, acpi_ut_get_mutex_name (mutex_id)));
 
-		acpi_gbl_acpi_mutex_info[mutex_id].use_count++;
-		acpi_gbl_acpi_mutex_info[mutex_id].owner_id = this_thread_id;
+		acpi_gbl_mutex_info[mutex_id].use_count++;
+		acpi_gbl_mutex_info[mutex_id].owner_id = this_thread_id;
 	}
-
 	else {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Thread %X could not acquire Mutex [%s] %s\n",
 				 this_thread_id, acpi_ut_get_mutex_name (mutex_id),
@@ -361,9 +751,9 @@ acpi_ut_acquire_mutex (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_release_mutex
+ * FUNCTION:    acpi_ut_release_mutex
  *
- * PARAMETERS:  Mutex_iD        - ID of the mutex to be released
+ * PARAMETERS:  mutex_iD        - ID of the mutex to be released
  *
  * RETURN:      Status
  *
@@ -373,14 +763,14 @@ acpi_ut_acquire_mutex (
 
 acpi_status
 acpi_ut_release_mutex (
-	ACPI_MUTEX_HANDLE       mutex_id)
+	acpi_mutex_handle               mutex_id)
 {
-	acpi_status             status;
-	u32                     i;
-	u32                     this_thread_id;
+	acpi_status                     status;
+	u32                             i;
+	u32                             this_thread_id;
 
 
-	PROC_NAME ("Ut_release_mutex");
+	ACPI_FUNCTION_NAME ("ut_release_mutex");
 
 
 	this_thread_id = acpi_os_get_thread_id ();
@@ -388,15 +778,14 @@ acpi_ut_release_mutex (
 		"Thread %X releasing Mutex [%s]\n", this_thread_id,
 		acpi_ut_get_mutex_name (mutex_id)));
 
-	if (mutex_id > MAX_MTX) {
+	if (mutex_id > MAX_MUTEX) {
 		return (AE_BAD_PARAMETER);
 	}
 
-
 	/*
 	 * Mutex must be acquired in order to release it!
 	 */
-	if (acpi_gbl_acpi_mutex_info[mutex_id].owner_id == ACPI_MUTEX_NOT_ACQUIRED) {
+	if (acpi_gbl_mutex_info[mutex_id].owner_id == ACPI_MUTEX_NOT_ACQUIRED) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 				"Mutex [%s] is not acquired, cannot release\n",
 				acpi_ut_get_mutex_name (mutex_id)));
@@ -404,15 +793,14 @@ acpi_ut_release_mutex (
 		return (AE_NOT_ACQUIRED);
 	}
 
-
 	/*
 	 * Deadlock prevention.  Check if this thread owns any mutexes of value
 	 * greater than this one.  If so, the thread has violated the mutex
 	 * ordering rule.  This indicates a coding error somewhere in
 	 * the ACPI subsystem code.
 	 */
-	for (i = mutex_id; i < MAX_MTX; i++) {
-		if (acpi_gbl_acpi_mutex_info[i].owner_id == this_thread_id) {
+	for (i = mutex_id; i < MAX_MUTEX; i++) {
+		if (acpi_gbl_mutex_info[i].owner_id == this_thread_id) {
 			if (i == mutex_id) {
 				continue;
 			}
@@ -425,12 +813,11 @@ acpi_ut_release_mutex (
 		}
 	}
 
-
 	/* Mark unlocked FIRST */
 
-	acpi_gbl_acpi_mutex_info[mutex_id].owner_id = ACPI_MUTEX_NOT_ACQUIRED;
+	acpi_gbl_mutex_info[mutex_id].owner_id = ACPI_MUTEX_NOT_ACQUIRED;
 
-	status = acpi_os_signal_semaphore (acpi_gbl_acpi_mutex_info[mutex_id].mutex, 1);
+	status = acpi_os_signal_semaphore (acpi_gbl_mutex_info[mutex_id].mutex, 1);
 
 	if (ACPI_FAILURE (status)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Thread %X could not release Mutex [%s] %s\n",
@@ -448,11 +835,11 @@ acpi_ut_release_mutex (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_create_update_state_and_push
+ * FUNCTION:    acpi_ut_create_update_state_and_push
  *
  * PARAMETERS:  *Object         - Object to be added to the new state
  *              Action          - Increment/Decrement
- *              State_list      - List the state will be added to
+ *              state_list      - List the state will be added to
  *
  * RETURN:      None
  *
@@ -462,14 +849,14 @@ acpi_ut_release_mutex (
 
 acpi_status
 acpi_ut_create_update_state_and_push (
-	acpi_operand_object     *object,
-	u16                     action,
-	acpi_generic_state      **state_list)
+	union acpi_operand_object       *object,
+	u16                             action,
+	union acpi_generic_state        **state_list)
 {
-	acpi_generic_state       *state;
+	union acpi_generic_state         *state;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	/* Ignore null objects; these are expected */
@@ -483,7 +870,6 @@ acpi_ut_create_update_state_and_push (
 		return (AE_NO_MEMORY);
 	}
 
-
 	acpi_ut_push_generic_state (state_list, state);
 	return (AE_OK);
 }
@@ -491,11 +877,11 @@ acpi_ut_create_update_state_and_push (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_create_pkg_state_and_push
+ * FUNCTION:    acpi_ut_create_pkg_state_and_push
  *
  * PARAMETERS:  *Object         - Object to be added to the new state
  *              Action          - Increment/Decrement
- *              State_list      - List the state will be added to
+ *              state_list      - List the state will be added to
  *
  * RETURN:      None
  *
@@ -505,15 +891,15 @@ acpi_ut_create_update_state_and_push (
 
 acpi_status
 acpi_ut_create_pkg_state_and_push (
-	void                    *internal_object,
-	void                    *external_object,
-	u16                     index,
-	acpi_generic_state      **state_list)
+	void                            *internal_object,
+	void                            *external_object,
+	u16                             index,
+	union acpi_generic_state        **state_list)
 {
-	acpi_generic_state       *state;
+	union acpi_generic_state         *state;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	state = acpi_ut_create_pkg_state (internal_object, external_object, index);
@@ -521,7 +907,6 @@ acpi_ut_create_pkg_state_and_push (
 		return (AE_NO_MEMORY);
 	}
 
-
 	acpi_ut_push_generic_state (state_list, state);
 	return (AE_OK);
 }
@@ -529,9 +914,9 @@ acpi_ut_create_pkg_state_and_push (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_push_generic_state
+ * FUNCTION:    acpi_ut_push_generic_state
  *
- * PARAMETERS:  List_head           - Head of the state stack
+ * PARAMETERS:  list_head           - Head of the state stack
  *              State               - State object to push
  *
  * RETURN:      Status
@@ -542,10 +927,10 @@ acpi_ut_create_pkg_state_and_push (
 
 void
 acpi_ut_push_generic_state (
-	acpi_generic_state      **list_head,
-	acpi_generic_state      *state)
+	union acpi_generic_state        **list_head,
+	union acpi_generic_state        *state)
 {
-	FUNCTION_TRACE ("Ut_push_generic_state");
+	ACPI_FUNCTION_TRACE ("ut_push_generic_state");
 
 
 	/* Push the state object onto the front of the list (stack) */
@@ -559,9 +944,9 @@ acpi_ut_push_generic_state (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_pop_generic_state
+ * FUNCTION:    acpi_ut_pop_generic_state
  *
- * PARAMETERS:  List_head           - Head of the state stack
+ * PARAMETERS:  list_head           - Head of the state stack
  *
  * RETURN:      Status
  *
@@ -569,14 +954,14 @@ acpi_ut_push_generic_state (
  *
  ******************************************************************************/
 
-acpi_generic_state *
+union acpi_generic_state *
 acpi_ut_pop_generic_state (
-	acpi_generic_state      **list_head)
+	union acpi_generic_state        **list_head)
 {
-	acpi_generic_state      *state;
+	union acpi_generic_state        *state;
 
 
-	FUNCTION_TRACE ("Ut_pop_generic_state");
+	ACPI_FUNCTION_TRACE ("ut_pop_generic_state");
 
 
 	/* Remove the state object at the head of the list (stack) */
@@ -594,7 +979,7 @@ acpi_ut_pop_generic_state (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_create_generic_state
+ * FUNCTION:    acpi_ut_create_generic_state
  *
  * PARAMETERS:  None
  *
@@ -605,13 +990,13 @@ acpi_ut_pop_generic_state (
  *
  ******************************************************************************/
 
-acpi_generic_state *
+union acpi_generic_state *
 acpi_ut_create_generic_state (void)
 {
-	acpi_generic_state      *state;
+	union acpi_generic_state        *state;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
 	state = acpi_ut_acquire_from_cache (ACPI_MEM_LIST_STATE);
@@ -628,7 +1013,46 @@ acpi_ut_create_generic_state (void)
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_create_update_state
+ * FUNCTION:    acpi_ut_create_thread_state
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Thread State
+ *
+ * DESCRIPTION: Create a "Thread State" - a flavor of the generic state used
+ *              to track per-thread info during method execution
+ *
+ ******************************************************************************/
+
+struct acpi_thread_state *
+acpi_ut_create_thread_state (
+	void)
+{
+	union acpi_generic_state        *state;
+
+
+	ACPI_FUNCTION_TRACE ("ut_create_thread_state");
+
+
+	/* Create the generic state object */
+
+	state = acpi_ut_create_generic_state ();
+	if (!state) {
+		return_PTR (NULL);
+	}
+
+	/* Init fields specific to the update struct */
+
+	state->common.data_type = ACPI_DESC_TYPE_STATE_THREAD;
+	state->thread.thread_id = acpi_os_get_thread_id ();
+
+	return_PTR ((struct acpi_thread_state *) state);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_create_update_state
  *
  * PARAMETERS:  Object              - Initial Object to be installed in the
  *                                    state
@@ -642,22 +1066,22 @@ acpi_ut_create_generic_state (void)
  *
  ******************************************************************************/
 
-acpi_generic_state *
+union acpi_generic_state *
 acpi_ut_create_update_state (
-	acpi_operand_object     *object,
-	u16                     action)
+	union acpi_operand_object       *object,
+	u16                             action)
 {
-	acpi_generic_state      *state;
+	union acpi_generic_state        *state;
 
 
-	FUNCTION_TRACE_PTR ("Ut_create_update_state", object);
+	ACPI_FUNCTION_TRACE_PTR ("ut_create_update_state", object);
 
 
 	/* Create the generic state object */
 
 	state = acpi_ut_create_generic_state ();
 	if (!state) {
-		return (NULL);
+		return_PTR (NULL);
 	}
 
 	/* Init fields specific to the update struct */
@@ -672,7 +1096,7 @@ acpi_ut_create_update_state (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_create_pkg_state
+ * FUNCTION:    acpi_ut_create_pkg_state
  *
  * PARAMETERS:  Object              - Initial Object to be installed in the
  *                                    state
@@ -684,29 +1108,29 @@ acpi_ut_create_update_state (
  *
  ******************************************************************************/
 
-acpi_generic_state *
+union acpi_generic_state *
 acpi_ut_create_pkg_state (
-	void                    *internal_object,
-	void                    *external_object,
-	u16                     index)
+	void                            *internal_object,
+	void                            *external_object,
+	u16                             index)
 {
-	acpi_generic_state      *state;
+	union acpi_generic_state        *state;
 
 
-	FUNCTION_TRACE_PTR ("Ut_create_pkg_state", internal_object);
+	ACPI_FUNCTION_TRACE_PTR ("ut_create_pkg_state", internal_object);
 
 
 	/* Create the generic state object */
 
 	state = acpi_ut_create_generic_state ();
 	if (!state) {
-		return (NULL);
+		return_PTR (NULL);
 	}
 
 	/* Init fields specific to the update struct */
 
 	state->common.data_type = ACPI_DESC_TYPE_STATE_PACKAGE;
-	state->pkg.source_object = (acpi_operand_object *) internal_object;
+	state->pkg.source_object = (union acpi_operand_object *) internal_object;
 	state->pkg.dest_object  = external_object;
 	state->pkg.index        = index;
 	state->pkg.num_packages = 1;
@@ -717,7 +1141,7 @@ acpi_ut_create_pkg_state (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_create_control_state
+ * FUNCTION:    acpi_ut_create_control_state
  *
  * PARAMETERS:  None
  *
@@ -728,28 +1152,27 @@ acpi_ut_create_pkg_state (
  *
  ******************************************************************************/
 
-acpi_generic_state *
+union acpi_generic_state *
 acpi_ut_create_control_state (
 	void)
 {
-	acpi_generic_state      *state;
+	union acpi_generic_state        *state;
 
 
-	FUNCTION_TRACE ("Ut_create_control_state");
+	ACPI_FUNCTION_TRACE ("ut_create_control_state");
 
 
 	/* Create the generic state object */
 
 	state = acpi_ut_create_generic_state ();
 	if (!state) {
-		return (NULL);
+		return_PTR (NULL);
 	}
 
-
 	/* Init fields specific to the control struct */
 
 	state->common.data_type = ACPI_DESC_TYPE_STATE_CONTROL;
-	state->common.state     = CONTROL_CONDITIONAL_EXECUTING;
+	state->common.state     = ACPI_CONTROL_CONDITIONAL_EXECUTING;
 
 	return_PTR (state);
 }
@@ -757,7 +1180,7 @@ acpi_ut_create_control_state (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_delete_generic_state
+ * FUNCTION:    acpi_ut_delete_generic_state
  *
  * PARAMETERS:  State               - The state object to be deleted
  *
@@ -770,9 +1193,9 @@ acpi_ut_create_control_state (
 
 void
 acpi_ut_delete_generic_state (
-	acpi_generic_state      *state)
+	union acpi_generic_state        *state)
 {
-	FUNCTION_TRACE ("Ut_delete_generic_state");
+	ACPI_FUNCTION_TRACE ("ut_delete_generic_state");
 
 
 	acpi_ut_release_to_cache (ACPI_MEM_LIST_STATE, state);
@@ -782,7 +1205,7 @@ acpi_ut_delete_generic_state (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_delete_generic_state_cache
+ * FUNCTION:    acpi_ut_delete_generic_state_cache
  *
  * PARAMETERS:  None
  *
@@ -797,7 +1220,7 @@ void
 acpi_ut_delete_generic_state_cache (
 	void)
 {
-	FUNCTION_TRACE ("Ut_delete_generic_state_cache");
+	ACPI_FUNCTION_TRACE ("ut_delete_generic_state_cache");
 
 
 	acpi_ut_delete_generic_cache (ACPI_MEM_LIST_STATE);
@@ -807,106 +1230,9 @@ acpi_ut_delete_generic_state_cache (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_resolve_package_references
- *
- * PARAMETERS:  Obj_desc        - The Package object on which to resolve refs
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Walk through a package and turn internal references into values
- *
- ******************************************************************************/
-
-acpi_status
-acpi_ut_resolve_package_references (
-	acpi_operand_object     *obj_desc)
-{
-	u32                     count;
-	acpi_operand_object     *sub_object;
-
-
-	FUNCTION_TRACE ("Ut_resolve_package_references");
-
-
-	if (obj_desc->common.type != ACPI_TYPE_PACKAGE) {
-		/* The object must be a package */
-
-		REPORT_ERROR (("Must resolve Package Refs on a Package\n"));
-		return_ACPI_STATUS(AE_ERROR);
-	}
-
-	/*
-	 * TBD: what about nested packages? */
-
-	for (count = 0; count < obj_desc->package.count; count++) {
-		sub_object = obj_desc->package.elements[count];
-
-		if (sub_object->common.type == INTERNAL_TYPE_REFERENCE) {
-			if (sub_object->reference.opcode == AML_ZERO_OP) {
-				sub_object->common.type = ACPI_TYPE_INTEGER;
-				sub_object->integer.value = 0;
-			}
-
-			else if (sub_object->reference.opcode == AML_ONE_OP) {
-				sub_object->common.type = ACPI_TYPE_INTEGER;
-				sub_object->integer.value = 1;
-			}
-
-			else if (sub_object->reference.opcode == AML_ONES_OP) {
-				sub_object->common.type = ACPI_TYPE_INTEGER;
-				sub_object->integer.value = ACPI_INTEGER_MAX;
-			}
-		}
-	}
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-#ifdef ACPI_DEBUG
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ut_display_init_pathname
- *
- * PARAMETERS:  Obj_handle          - Handle whose pathname will be displayed
- *              Path                - Additional path string to be appended
- *
- * RETURN:      acpi_status
- *
- * DESCRIPTION: Display full pathnbame of an object, DEBUG ONLY
- *
- ******************************************************************************/
-
-void
-acpi_ut_display_init_pathname (
-	acpi_handle             obj_handle,
-	char                    *path)
-{
-	acpi_status             status;
-	u32                     length = 128;
-	char                    buffer[128];
-
-
-	PROC_NAME ("Ut_display_init_pathname");
-
-
-	status = acpi_ns_handle_to_pathname (obj_handle, &length, buffer);
-	if (ACPI_SUCCESS (status)) {
-		if (path) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_INIT, "%s.%s\n", buffer, path));
-		}
-		else {
-			ACPI_DEBUG_PRINT ((ACPI_DB_INIT, "%s\n", buffer));
-		}
-	}
-}
-#endif
-
-/*******************************************************************************
- *
- * FUNCTION:    Acpi_ut_walk_package_tree
+ * FUNCTION:    acpi_ut_walk_package_tree
  *
- * PARAMETERS:  Obj_desc        - The Package object on which to resolve refs
+ * PARAMETERS:  obj_desc        - The Package object on which to resolve refs
  *
  * RETURN:      Status
  *
@@ -916,19 +1242,19 @@ acpi_ut_display_init_pathname (
 
 acpi_status
 acpi_ut_walk_package_tree (
-	acpi_operand_object     *source_object,
-	void                    *target_object,
-	ACPI_PKG_CALLBACK       walk_callback,
-	void                    *context)
-{
-	acpi_status             status = AE_OK;
-	acpi_generic_state      *state_list = NULL;
-	acpi_generic_state      *state;
-	u32                     this_index;
-	acpi_operand_object     *this_source_obj;
+	union acpi_operand_object       *source_object,
+	void                            *target_object,
+	acpi_pkg_callback               walk_callback,
+	void                            *context)
+{
+	acpi_status                     status = AE_OK;
+	union acpi_generic_state        *state_list = NULL;
+	union acpi_generic_state        *state;
+	u32                             this_index;
+	union acpi_operand_object       *this_source_obj;
 
 
-	FUNCTION_TRACE ("Ut_walk_package_tree");
+	ACPI_FUNCTION_TRACE ("ut_walk_package_tree");
 
 
 	state = acpi_ut_create_pkg_state (source_object, target_object, 0);
@@ -937,29 +1263,26 @@ acpi_ut_walk_package_tree (
 	}
 
 	while (state) {
+		/* Get one element of the package */
+
 		this_index    = state->pkg.index;
-		this_source_obj = (acpi_operand_object *)
+		this_source_obj = (union acpi_operand_object *)
 				  state->pkg.source_object->package.elements[this_index];
 
 		/*
-		 * Check for
+		 * Check for:
 		 * 1) An uninitialized package element.  It is completely
-		 *      legal to declare a package and leave it uninitialized
+		 *    legal to declare a package and leave it uninitialized
 		 * 2) Not an internal object - can be a namespace node instead
 		 * 3) Any type other than a package.  Packages are handled in else
-		 *      case below.
+		 *    case below.
 		 */
 		if ((!this_source_obj) ||
-			(!VALID_DESCRIPTOR_TYPE (
-					this_source_obj, ACPI_DESC_TYPE_INTERNAL)) ||
-			(!IS_THIS_OBJECT_TYPE (
-					this_source_obj, ACPI_TYPE_PACKAGE))) {
-
+			(ACPI_GET_DESCRIPTOR_TYPE (this_source_obj) != ACPI_DESC_TYPE_OPERAND) ||
+			(ACPI_GET_OBJECT_TYPE (this_source_obj) != ACPI_TYPE_PACKAGE)) {
 			status = walk_callback (ACPI_COPY_TYPE_SIMPLE, this_source_obj,
 					 state, context);
 			if (ACPI_FAILURE (status)) {
-				/* TBD: must delete package created up to this point */
-
 				return_ACPI_STATUS (status);
 			}
 
@@ -975,7 +1298,6 @@ acpi_ut_walk_package_tree (
 				acpi_ut_delete_generic_state (state);
 				state = acpi_ut_pop_generic_state (&state_list);
 
-
 				/* Finished when there are no more states */
 
 				if (!state) {
@@ -994,32 +1316,23 @@ acpi_ut_walk_package_tree (
 				state->pkg.index++;
 			}
 		}
-
 		else {
-			/* This is a sub-object of type package */
+			/* This is a subobject of type package */
 
 			status = walk_callback (ACPI_COPY_TYPE_PACKAGE, this_source_obj,
 					  state, context);
 			if (ACPI_FAILURE (status)) {
-				/* TBD: must delete package created up to this point */
-
 				return_ACPI_STATUS (status);
 			}
 
-
-			/*
-			 * The callback above returned a new target package object.
-			 */
-
 			/*
 			 * Push the current state and create a new one
+			 * The callback above returned a new target package object.
 			 */
 			acpi_ut_push_generic_state (&state_list, state);
 			state = acpi_ut_create_pkg_state (this_source_obj,
 					   state->pkg.this_target_obj, 0);
 			if (!state) {
-				/* TBD: must delete package created up to this point */
-
 				return_ACPI_STATUS (AE_NO_MEMORY);
 			}
 		}
@@ -1027,17 +1340,100 @@ acpi_ut_walk_package_tree (
 
 	/* We should never get here */
 
-	return (AE_AML_INTERNAL);
+	return_ACPI_STATUS (AE_AML_INTERNAL);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_generate_checksum
+ *
+ * PARAMETERS:  Buffer          - Buffer to be scanned
+ *              Length          - number of bytes to examine
+ *
+ * RETURN:      checksum
+ *
+ * DESCRIPTION: Generate a checksum on a raw buffer
+ *
+ ******************************************************************************/
+
+u8
+acpi_ut_generate_checksum (
+	u8                              *buffer,
+	u32                             length)
+{
+	u32                             i;
+	signed char                     sum = 0;
+
+
+	for (i = 0; i < length; i++) {
+		sum = (signed char) (sum + buffer[i]);
+	}
+
+	return ((u8) (0 - sum));
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_get_resource_end_tag
+ *
+ * PARAMETERS:  obj_desc        - The resource template buffer object
+ *
+ * RETURN:      Pointer to the end tag
+ *
+ * DESCRIPTION: Find the END_TAG resource descriptor in a resource template
+ *
+ ******************************************************************************/
+
+
+u8 *
+acpi_ut_get_resource_end_tag (
+	union acpi_operand_object       *obj_desc)
+{
+	u8                              buffer_byte;
+	u8                              *buffer;
+	u8                              *end_buffer;
+
+
+	buffer    = obj_desc->buffer.pointer;
+	end_buffer = buffer + obj_desc->buffer.length;
+
+	while (buffer < end_buffer) {
+		buffer_byte = *buffer;
+		if (buffer_byte & ACPI_RDESC_TYPE_MASK) {
+			/* Large Descriptor - Length is next 2 bytes */
+
+			buffer += ((*(buffer+1) | (*(buffer+2) << 8)) + 3);
+		}
+		else {
+			/* Small Descriptor.  End Tag will be found here */
+
+			if ((buffer_byte & ACPI_RDESC_SMALL_MASK) == ACPI_RDESC_TYPE_END_TAG) {
+				/* Found the end tag descriptor, all done. */
+
+				return (buffer);
+			}
+
+			/* Length is in the header */
+
+			buffer += ((buffer_byte & 0x07) + 1);
+		}
+	}
+
+	/* End tag not found */
+
+	return (NULL);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_report_error
+ * FUNCTION:    acpi_ut_report_error
  *
- * PARAMETERS:  Module_name         - Caller's module name (for error output)
- *              Line_number         - Caller's line number (for error output)
- *              Component_id        - Caller's component ID (for error output)
+ * PARAMETERS:  module_name         - Caller's module name (for error output)
+ *              line_number         - Caller's line number (for error output)
+ *              component_id        - Caller's component ID (for error output)
  *              Message             - Error message to use on failure
  *
  * RETURN:      None
@@ -1048,9 +1444,9 @@ acpi_ut_walk_package_tree (
 
 void
 acpi_ut_report_error (
-	NATIVE_CHAR             *module_name,
-	u32                     line_number,
-	u32                     component_id)
+	char                            *module_name,
+	u32                             line_number,
+	u32                             component_id)
 {
 
 
@@ -1060,11 +1456,11 @@ acpi_ut_report_error (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_report_warning
+ * FUNCTION:    acpi_ut_report_warning
  *
- * PARAMETERS:  Module_name         - Caller's module name (for error output)
- *              Line_number         - Caller's line number (for error output)
- *              Component_id        - Caller's component ID (for error output)
+ * PARAMETERS:  module_name         - Caller's module name (for error output)
+ *              line_number         - Caller's line number (for error output)
+ *              component_id        - Caller's component ID (for error output)
  *              Message             - Error message to use on failure
  *
  * RETURN:      None
@@ -1075,9 +1471,9 @@ acpi_ut_report_error (
 
 void
 acpi_ut_report_warning (
-	NATIVE_CHAR             *module_name,
-	u32                     line_number,
-	u32                     component_id)
+	char                            *module_name,
+	u32                             line_number,
+	u32                             component_id)
 {
 
 	acpi_os_printf ("%8s-%04d: *** Warning: ", module_name, line_number);
@@ -1086,11 +1482,11 @@ acpi_ut_report_warning (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_report_info
+ * FUNCTION:    acpi_ut_report_info
  *
- * PARAMETERS:  Module_name         - Caller's module name (for error output)
- *              Line_number         - Caller's line number (for error output)
- *              Component_id        - Caller's component ID (for error output)
+ * PARAMETERS:  module_name         - Caller's module name (for error output)
+ *              line_number         - Caller's line number (for error output)
+ *              component_id        - Caller's component ID (for error output)
  *              Message             - Error message to use on failure
  *
  * RETURN:      None
@@ -1101,9 +1497,9 @@ acpi_ut_report_warning (
 
 void
 acpi_ut_report_info (
-	NATIVE_CHAR             *module_name,
-	u32                     line_number,
-	u32                     component_id)
+	char                            *module_name,
+	u32                             line_number,
+	u32                             component_id)
 {
 
 	acpi_os_printf ("%8s-%04d: *** Info: ", module_name, line_number);
diff -urNp linux-5400/drivers/acpi/utilities/utobject.c linux-5410/drivers/acpi/utilities/utobject.c
--- linux-5400/drivers/acpi/utilities/utobject.c
+++ linux-5410/drivers/acpi/utilities/utobject.c
@@ -1,48 +1,63 @@
 /******************************************************************************
  *
  * Module Name: utobject - ACPI object create/delete/size/cache routines
- *              $Revision: 57 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acinterp.h"
-#include "acnamesp.h"
-#include "actables.h"
-#include "amlcode.h"
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
+#include <acpi/amlcode.h>
 
 
 #define _COMPONENT          ACPI_UTILITIES
-	 MODULE_NAME         ("utobject")
+	 ACPI_MODULE_NAME    ("utobject")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_create_internal_object_dbg
+ * FUNCTION:    acpi_ut_create_internal_object_dbg
  *
- * PARAMETERS:  Address             - Address of the memory to deallocate
- *              Component           - Component type of caller
- *              Module              - Source file name of caller
- *              Line                - Line number of caller
+ * PARAMETERS:  module_name         - Source file name of caller
+ *              line_number         - Line number of caller
+ *              component_id        - Component type of caller
  *              Type                - ACPI Type of the new object
  *
  * RETURN:      Object              - The new object.  Null on failure
@@ -57,31 +72,55 @@
  *
  ******************************************************************************/
 
-acpi_operand_object  *
+union acpi_operand_object    *
 acpi_ut_create_internal_object_dbg (
-	NATIVE_CHAR             *module_name,
-	u32                     line_number,
-	u32                     component_id,
-	acpi_object_type8       type)
+	char                            *module_name,
+	u32                             line_number,
+	u32                             component_id,
+	acpi_object_type                type)
 {
-	acpi_operand_object     *object;
+	union acpi_operand_object       *object;
+	union acpi_operand_object       *second_object;
 
 
-	FUNCTION_TRACE_STR ("Ut_create_internal_object_dbg", acpi_ut_get_type_name (type));
+	ACPI_FUNCTION_TRACE_STR ("ut_create_internal_object_dbg", acpi_ut_get_type_name (type));
 
 
 	/* Allocate the raw object descriptor */
 
 	object = acpi_ut_allocate_object_desc_dbg (module_name, line_number, component_id);
 	if (!object) {
-		/* Allocation failure */
-
 		return_PTR (NULL);
 	}
 
+	switch (type) {
+	case ACPI_TYPE_REGION:
+	case ACPI_TYPE_BUFFER_FIELD:
+
+		/* These types require a secondary object */
+
+		second_object = acpi_ut_allocate_object_desc_dbg (module_name, line_number, component_id);
+		if (!second_object) {
+			acpi_ut_delete_object_desc (object);
+			return_PTR (NULL);
+		}
+
+		second_object->common.type = ACPI_TYPE_LOCAL_EXTRA;
+		second_object->common.reference_count = 1;
+
+		/* Link the second object to the first */
+
+		object->common.next_object = second_object;
+		break;
+
+	default:
+		/* All others have no secondary object */
+		break;
+	}
+
 	/* Save the object type in the object descriptor */
 
-	object->common.type = type;
+	object->common.type = (u8) type;
 
 	/* Init the reference count */
 
@@ -95,68 +134,132 @@ acpi_ut_create_internal_object_dbg (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_valid_internal_object
+ * FUNCTION:    acpi_ut_create_buffer_object
+ *
+ * PARAMETERS:  buffer_size            - Size of buffer to be created
+ *
+ * RETURN:      Pointer to a new Buffer object
+ *
+ * DESCRIPTION: Create a fully initialized buffer object
+ *
+ ******************************************************************************/
+
+union acpi_operand_object *
+acpi_ut_create_buffer_object (
+	acpi_size                       buffer_size)
+{
+	union acpi_operand_object       *buffer_desc;
+	u8                              *buffer = NULL;
+
+
+	ACPI_FUNCTION_TRACE_U32 ("ut_create_buffer_object", buffer_size);
+
+
+	/*
+	 * Create a new Buffer object
+	 */
+	buffer_desc = acpi_ut_create_internal_object (ACPI_TYPE_BUFFER);
+	if (!buffer_desc) {
+		return_PTR (NULL);
+	}
+
+	/* Create an actual buffer only if size > 0 */
+
+	if (buffer_size > 0) {
+		/* Allocate the actual buffer */
+
+		buffer = ACPI_MEM_CALLOCATE (buffer_size);
+		if (!buffer) {
+			ACPI_REPORT_ERROR (("create_buffer: could not allocate size %X\n",
+				(u32) buffer_size));
+			acpi_ut_remove_reference (buffer_desc);
+			return_PTR (NULL);
+		}
+	}
+
+	/* Complete buffer object initialization */
+
+	buffer_desc->buffer.flags |= AOPOBJ_DATA_VALID;
+	buffer_desc->buffer.pointer = buffer;
+	buffer_desc->buffer.length = (u32) buffer_size;
+
+	/* Return the new buffer descriptor */
+
+	return_PTR (buffer_desc);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_valid_internal_object
  *
- * PARAMETERS:  Operand             - Object to be validated
+ * PARAMETERS:  Object              - Object to be validated
  *
- * RETURN:      Validate a pointer to be an acpi_operand_object
+ * RETURN:      Validate a pointer to be an union acpi_operand_object
  *
  ******************************************************************************/
 
 u8
 acpi_ut_valid_internal_object (
-	void                    *object)
+	void                            *object)
 {
 
-	PROC_NAME ("Ut_valid_internal_object");
+	ACPI_FUNCTION_NAME ("ut_valid_internal_object");
 
 
 	/* Check for a null pointer */
 
 	if (!object) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-			"**** Null Object Ptr\n"));
+		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "**** Null Object Ptr\n"));
 		return (FALSE);
 	}
 
 	/* Check the descriptor type field */
 
-	if (!VALID_DESCRIPTOR_TYPE (object, ACPI_DESC_TYPE_INTERNAL)) {
-		/* Not an ACPI internal object, do some further checking */
+	switch (ACPI_GET_DESCRIPTOR_TYPE (object)) {
+	case ACPI_DESC_TYPE_OPERAND:
 
-		if (VALID_DESCRIPTOR_TYPE (object, ACPI_DESC_TYPE_NAMED)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-				"**** Obj %p is a named obj, not ACPI obj\n", object));
-		}
+		/* The object appears to be a valid union acpi_operand_object    */
 
-		else if (VALID_DESCRIPTOR_TYPE (object, ACPI_DESC_TYPE_PARSER)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-				"**** Obj %p is a parser obj, not ACPI obj\n", object));
-		}
+		return (TRUE);
 
-		else {
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-				"**** Obj %p is of unknown type\n", object));
-		}
+	case ACPI_DESC_TYPE_NAMED:
 
-		return (FALSE);
-	}
+		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+			"**** Obj %p is a named obj, not ACPI obj\n", object));
+		break;
+
+	case ACPI_DESC_TYPE_PARSER:
+
+		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+			"**** Obj %p is a parser obj, not ACPI obj\n", object));
+		break;
 
+	case ACPI_DESC_TYPE_CACHED:
 
-	/* The object appears to be a valid acpi_operand_object  */
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"**** Obj %p has already been released to internal cache\n", object));
+		break;
+
+	default:
 
-	return (TRUE);
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"**** Obj %p has unknown descriptor type %X\n", object,
+			ACPI_GET_DESCRIPTOR_TYPE (object)));
+		break;
+	}
+
+	return (FALSE);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_allocate_object_desc_dbg
+ * FUNCTION:    acpi_ut_allocate_object_desc_dbg
  *
- * PARAMETERS:  Module_name         - Caller's module name (for error output)
- *              Line_number         - Caller's line number (for error output)
- *              Component_id        - Caller's component ID (for error output)
- *              Message             - Error message to use on failure
+ * PARAMETERS:  module_name         - Caller's module name (for error output)
+ *              line_number         - Caller's line number (for error output)
+ *              component_id        - Caller's component ID (for error output)
  *
  * RETURN:      Pointer to newly allocated object descriptor.  Null on error
  *
@@ -167,31 +270,30 @@ acpi_ut_valid_internal_object (
 
 void *
 acpi_ut_allocate_object_desc_dbg (
-	NATIVE_CHAR             *module_name,
-	u32                     line_number,
-	u32                     component_id)
+	char                            *module_name,
+	u32                             line_number,
+	u32                             component_id)
 {
-	acpi_operand_object     *object;
+	union acpi_operand_object       *object;
 
 
-	FUNCTION_TRACE ("Ut_allocate_object_desc_dbg");
+	ACPI_FUNCTION_TRACE ("ut_allocate_object_desc_dbg");
 
 
 	object = acpi_ut_acquire_from_cache (ACPI_MEM_LIST_OPERAND);
 	if (!object) {
-		_REPORT_ERROR (module_name, line_number, component_id,
+		_ACPI_REPORT_ERROR (module_name, line_number, component_id,
 				  ("Could not allocate an object descriptor\n"));
 
 		return_PTR (NULL);
 	}
 
-
 	/* Mark the descriptor type */
 
-	object->common.data_type = ACPI_DESC_TYPE_INTERNAL;
+	ACPI_SET_DESCRIPTOR_TYPE (object, ACPI_DESC_TYPE_OPERAND);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "%p Size %X\n",
-			object, sizeof (acpi_operand_object)));
+			object, (u32) sizeof (union acpi_operand_object)));
 
 	return_PTR (object);
 }
@@ -199,9 +301,9 @@ acpi_ut_allocate_object_desc_dbg (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_delete_object_desc
+ * FUNCTION:    acpi_ut_delete_object_desc
  *
- * PARAMETERS:  Object          - Acpi internal object to be deleted
+ * PARAMETERS:  Object          - An Acpi internal object to be deleted
  *
  * RETURN:      None.
  *
@@ -211,14 +313,14 @@ acpi_ut_allocate_object_desc_dbg (
 
 void
 acpi_ut_delete_object_desc (
-	acpi_operand_object     *object)
+	union acpi_operand_object       *object)
 {
-	FUNCTION_TRACE_PTR ("Ut_delete_object_desc", object);
+	ACPI_FUNCTION_TRACE_PTR ("ut_delete_object_desc", object);
 
 
-	/* Object must be an acpi_operand_object  */
+	/* Object must be an union acpi_operand_object    */
 
-	if (object->common.data_type != ACPI_DESC_TYPE_INTERNAL) {
+	if (ACPI_GET_DESCRIPTOR_TYPE (object) != ACPI_DESC_TYPE_OPERAND) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"Obj %p is not an ACPI object\n", object));
 		return_VOID;
@@ -232,11 +334,11 @@ acpi_ut_delete_object_desc (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_delete_object_cache
+ * FUNCTION:    acpi_ut_delete_object_cache
  *
  * PARAMETERS:  None
  *
- * RETURN:      Status
+ * RETURN:      None
  *
  * DESCRIPTION: Purge the global state object cache.  Used during subsystem
  *              termination.
@@ -247,7 +349,7 @@ void
 acpi_ut_delete_object_cache (
 	void)
 {
-	FUNCTION_TRACE ("Ut_delete_object_cache");
+	ACPI_FUNCTION_TRACE ("ut_delete_object_cache");
 
 
 	acpi_ut_delete_generic_cache (ACPI_MEM_LIST_OPERAND);
@@ -257,15 +359,15 @@ acpi_ut_delete_object_cache (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_get_simple_object_size
+ * FUNCTION:    acpi_ut_get_simple_object_size
  *
- * PARAMETERS:  *Internal_object    - Pointer to the object we are examining
- *              *Ret_length         - Where the length is returned
+ * PARAMETERS:  *internal_object    - Pointer to the object we are examining
+ *              *obj_length         - Where the length is returned
  *
  * RETURN:      Status
  *
  * DESCRIPTION: This function is called to determine the space required to
- *              contain a simple object for return to an API user.
+ *              contain a simple object for return to an external user.
  *
  *              The length includes the object structure plus any additional
  *              needed space.
@@ -274,14 +376,14 @@ acpi_ut_delete_object_cache (
 
 acpi_status
 acpi_ut_get_simple_object_size (
-	acpi_operand_object     *internal_object,
-	u32                     *obj_length)
+	union acpi_operand_object       *internal_object,
+	acpi_size                       *obj_length)
 {
-	u32                     length;
-	acpi_status             status = AE_OK;
+	acpi_size                       length;
+	acpi_status                     status = AE_OK;
 
 
-	FUNCTION_TRACE_PTR ("Ut_get_simple_object_size", internal_object);
+	ACPI_FUNCTION_TRACE_PTR ("ut_get_simple_object_size", internal_object);
 
 
 	/* Handle a null object (Could be a uninitialized package element -- which is legal) */
@@ -291,37 +393,33 @@ acpi_ut_get_simple_object_size (
 		return_ACPI_STATUS (AE_OK);
 	}
 
-
 	/* Start with the length of the Acpi object */
 
-	length = sizeof (acpi_object);
+	length = sizeof (union acpi_object);
 
-	if (VALID_DESCRIPTOR_TYPE (internal_object, ACPI_DESC_TYPE_NAMED)) {
+	if (ACPI_GET_DESCRIPTOR_TYPE (internal_object) == ACPI_DESC_TYPE_NAMED) {
 		/* Object is a named object (reference), just return the length */
 
-		*obj_length = (u32) ROUND_UP_TO_NATIVE_WORD (length);
+		*obj_length = ACPI_ROUND_UP_TO_NATIVE_WORD (length);
 		return_ACPI_STATUS (status);
 	}
 
-
 	/*
 	 * The final length depends on the object type
 	 * Strings and Buffers are packed right up against the parent object and
 	 * must be accessed bytewise or there may be alignment problems on
 	 * certain processors
 	 */
-
-	switch (internal_object->common.type) {
-
+	switch (ACPI_GET_OBJECT_TYPE (internal_object)) {
 	case ACPI_TYPE_STRING:
 
-		length += internal_object->string.length + 1;
+		length += (acpi_size) internal_object->string.length + 1;
 		break;
 
 
 	case ACPI_TYPE_BUFFER:
 
-		length += internal_object->buffer.length;
+		length += (acpi_size) internal_object->buffer.length;
 		break;
 
 
@@ -335,25 +433,30 @@ acpi_ut_get_simple_object_size (
 		break;
 
 
-	case INTERNAL_TYPE_REFERENCE:
+	case ACPI_TYPE_LOCAL_REFERENCE:
 
-		/*
-		 * The only type that should be here is internal opcode NAMEPATH_OP -- since
-		 * this means an object reference
-		 */
-		if (internal_object->reference.opcode != AML_INT_NAMEPATH_OP) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Unsupported Reference opcode=%X in object %p\n",
-				internal_object->reference.opcode, internal_object));
-			status = AE_TYPE;
-		}
+		switch (internal_object->reference.opcode) {
+		case AML_INT_NAMEPATH_OP:
 
-		else {
 			/*
 			 * Get the actual length of the full pathname to this object.
 			 * The reference will be converted to the pathname to the object
 			 */
-			length += ROUND_UP_TO_NATIVE_WORD (acpi_ns_get_pathname_length (internal_object->reference.node));
+			length += ACPI_ROUND_UP_TO_NATIVE_WORD (acpi_ns_get_pathname_length (internal_object->reference.node));
+			break;
+
+		default:
+
+			/*
+			 * No other reference opcodes are supported.
+			 * Notably, Locals and Args are not supported, but this may be
+			 * required eventually.
+			 */
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+				"Unsupported Reference opcode=%X in object %p\n",
+				internal_object->reference.opcode, internal_object));
+			status = AE_TYPE;
+			break;
 		}
 		break;
 
@@ -361,31 +464,29 @@ acpi_ut_get_simple_object_size (
 	default:
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unsupported type=%X in object %p\n",
-			internal_object->common.type, internal_object));
+			ACPI_GET_OBJECT_TYPE (internal_object), internal_object));
 		status = AE_TYPE;
 		break;
 	}
 
-
 	/*
 	 * Account for the space required by the object rounded up to the next
 	 * multiple of the machine word size.  This keeps each object aligned
 	 * on a machine word boundary. (preventing alignment faults on some
 	 * machines.)
 	 */
-	*obj_length = (u32) ROUND_UP_TO_NATIVE_WORD (length);
-
+	*obj_length = ACPI_ROUND_UP_TO_NATIVE_WORD (length);
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_get_element_length
+ * FUNCTION:    acpi_ut_get_element_length
  *
- * PARAMETERS:  ACPI_PKG_CALLBACK
+ * PARAMETERS:  acpi_pkg_callback
  *
- * RETURN:      Status          - the status of the call
+ * RETURN:      Status
  *
  * DESCRIPTION: Get the length of one package element.
  *
@@ -393,18 +494,18 @@ acpi_ut_get_simple_object_size (
 
 acpi_status
 acpi_ut_get_element_length (
-	u8                      object_type,
-	acpi_operand_object     *source_object,
-	acpi_generic_state      *state,
-	void                    *context)
+	u8                              object_type,
+	union acpi_operand_object       *source_object,
+	union acpi_generic_state        *state,
+	void                            *context)
 {
-	acpi_status             status = AE_OK;
-	acpi_pkg_info           *info = (acpi_pkg_info *) context;
-	u32                     object_space;
+	acpi_status                     status = AE_OK;
+	struct acpi_pkg_info            *info = (struct acpi_pkg_info *) context;
+	acpi_size                       object_space;
 
 
 	switch (object_type) {
-	case 0:
+	case ACPI_COPY_TYPE_SIMPLE:
 
 		/*
 		 * Simple object - just get the size (Null object/entry is handled
@@ -419,33 +520,37 @@ acpi_ut_get_element_length (
 		break;
 
 
-	case 1:
-		/* Package - nothing much to do here, let the walk handle it */
+	case ACPI_COPY_TYPE_PACKAGE:
+
+		/* Package object - nothing much to do here, let the walk handle it */
 
 		info->num_packages++;
 		state->pkg.this_target_obj = NULL;
 		break;
 
+
 	default:
+
+		/* No other types allowed */
+
 		return (AE_BAD_PARAMETER);
 	}
 
-
 	return (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_get_package_object_size
+ * FUNCTION:    acpi_ut_get_package_object_size
  *
- * PARAMETERS:  *Internal_object    - Pointer to the object we are examining
- *              *Ret_length         - Where the length is returned
+ * PARAMETERS:  *internal_object    - Pointer to the object we are examining
+ *              *obj_length         - Where the length is returned
  *
  * RETURN:      Status
  *
  * DESCRIPTION: This function is called to determine the space required to
- *              contain a package object for return to an API user.
+ *              contain a package object for return to an external user.
  *
  *              This is moderately complex since a package contains other
  *              objects including packages.
@@ -454,14 +559,14 @@ acpi_ut_get_element_length (
 
 acpi_status
 acpi_ut_get_package_object_size (
-	acpi_operand_object     *internal_object,
-	u32                     *obj_length)
+	union acpi_operand_object       *internal_object,
+	acpi_size                       *obj_length)
 {
-	acpi_status             status;
-	acpi_pkg_info           info;
+	acpi_status                     status;
+	struct acpi_pkg_info            info;
 
 
-	FUNCTION_TRACE_PTR ("Ut_get_package_object_size", internal_object);
+	ACPI_FUNCTION_TRACE_PTR ("ut_get_package_object_size", internal_object);
 
 
 	info.length      = 0;
@@ -470,14 +575,17 @@ acpi_ut_get_package_object_size (
 
 	status = acpi_ut_walk_package_tree (internal_object, NULL,
 			 acpi_ut_get_element_length, &info);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	/*
 	 * We have handled all of the objects in all levels of the package.
 	 * just add the length of the package objects themselves.
 	 * Round up to the next machine word.
 	 */
-	info.length += ROUND_UP_TO_NATIVE_WORD (sizeof (acpi_object)) *
-			  info.num_packages;
+	info.length += ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (union acpi_object)) *
+			  (acpi_size) info.num_packages;
 
 	/* Return the total package length */
 
@@ -488,10 +596,10 @@ acpi_ut_get_package_object_size (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ut_get_object_size
+ * FUNCTION:    acpi_ut_get_object_size
  *
- * PARAMETERS:  *Internal_object    - Pointer to the object we are examining
- *              *Ret_length         - Where the length will be returned
+ * PARAMETERS:  *internal_object    - Pointer to the object we are examining
+ *              *obj_length         - Where the length will be returned
  *
  * RETURN:      Status
  *
@@ -502,20 +610,19 @@ acpi_ut_get_package_object_size (
 
 acpi_status
 acpi_ut_get_object_size(
-	acpi_operand_object     *internal_object,
-	u32                     *obj_length)
+	union acpi_operand_object       *internal_object,
+	acpi_size                       *obj_length)
 {
-	acpi_status             status;
+	acpi_status                     status;
 
 
-	FUNCTION_ENTRY ();
+	ACPI_FUNCTION_ENTRY ();
 
 
-	if ((VALID_DESCRIPTOR_TYPE (internal_object, ACPI_DESC_TYPE_INTERNAL)) &&
-		(IS_THIS_OBJECT_TYPE (internal_object, ACPI_TYPE_PACKAGE))) {
+	if ((ACPI_GET_DESCRIPTOR_TYPE (internal_object) == ACPI_DESC_TYPE_OPERAND) &&
+		(ACPI_GET_OBJECT_TYPE (internal_object) == ACPI_TYPE_PACKAGE)) {
 		status = acpi_ut_get_package_object_size (internal_object, obj_length);
 	}
-
 	else {
 		status = acpi_ut_get_simple_object_size (internal_object, obj_length);
 	}
diff -urNp linux-5400/drivers/acpi/utilities/utxface.c linux-5410/drivers/acpi/utilities/utxface.c
--- linux-5400/drivers/acpi/utilities/utxface.c
+++ linux-5410/drivers/acpi/utilities/utxface.c
@@ -1,46 +1,61 @@
 /******************************************************************************
  *
  * Module Name: utxface - External interfaces for "global" ACPI functions
- *              $Revision: 82 $
  *
  *****************************************************************************/
 
 /*
- *  Copyright (C) 2000, 2001 R. Byron Moore
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
  */
 
 
-#include "acpi.h"
-#include "acevents.h"
-#include "achware.h"
-#include "acnamesp.h"
-#include "acinterp.h"
-#include "amlcode.h"
-#include "acdebug.h"
-#include "acexcep.h"
-
+#include <acpi/acpi.h>
+#include <acpi/acevents.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acparser.h>
+#include <acpi/acdispat.h>
+#include <acpi/acdebug.h>
 
 #define _COMPONENT          ACPI_UTILITIES
-	 MODULE_NAME         ("utxface")
+	 ACPI_MODULE_NAME    ("utxface")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_initialize_subsystem
+ * FUNCTION:    acpi_initialize_subsystem
  *
  * PARAMETERS:  None
  *
@@ -55,12 +70,12 @@ acpi_status
 acpi_initialize_subsystem (
 	void)
 {
-	acpi_status             status;
+	acpi_status                     status;
 
-	FUNCTION_TRACE ("Acpi_initialize_subsystem");
+	ACPI_FUNCTION_TRACE ("acpi_initialize_subsystem");
 
 
-	DEBUG_EXEC(acpi_ut_init_stack_ptr_trace ());
+	ACPI_DEBUG_EXEC (acpi_ut_init_stack_ptr_trace ());
 
 
 	/* Initialize all globals used by the subsystem */
@@ -71,7 +86,7 @@ acpi_initialize_subsystem (
 
 	status = acpi_os_initialize ();
 	if (ACPI_FAILURE (status)) {
-		REPORT_ERROR (("OSD failed to initialize, %s\n",
+		ACPI_REPORT_ERROR (("OSD failed to initialize, %s\n",
 			acpi_format_exception (status)));
 		return_ACPI_STATUS (status);
 	}
@@ -80,7 +95,7 @@ acpi_initialize_subsystem (
 
 	status = acpi_ut_mutex_initialize ();
 	if (ACPI_FAILURE (status)) {
-		REPORT_ERROR (("Global mutex creation failure, %s\n",
+		ACPI_REPORT_ERROR (("Global mutex creation failure, %s\n",
 			acpi_format_exception (status)));
 		return_ACPI_STATUS (status);
 	}
@@ -92,7 +107,7 @@ acpi_initialize_subsystem (
 
 	status = acpi_ns_root_initialize ();
 	if (ACPI_FAILURE (status)) {
-		REPORT_ERROR (("Namespace initialization failure, %s\n",
+		ACPI_REPORT_ERROR (("Namespace initialization failure, %s\n",
 			acpi_format_exception (status)));
 		return_ACPI_STATUS (status);
 	}
@@ -100,7 +115,7 @@ acpi_initialize_subsystem (
 
 	/* If configured, initialize the AML debugger */
 
-	DEBUGGER_EXEC (acpi_db_initialize ());
+	ACPI_DEBUGGER_EXEC (status = acpi_db_initialize ());
 
 	return_ACPI_STATUS (status);
 }
@@ -108,7 +123,7 @@ acpi_initialize_subsystem (
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_enable_subsystem
+ * FUNCTION:    acpi_enable_subsystem
  *
  * PARAMETERS:  Flags           - Init/enable Options
  *
@@ -121,37 +136,17 @@ acpi_initialize_subsystem (
 
 acpi_status
 acpi_enable_subsystem (
-	u32                     flags)
+	u32                             flags)
 {
-	acpi_status             status = AE_OK;
-
-
-	FUNCTION_TRACE ("Acpi_enable_subsystem");
-
+	acpi_status                     status = AE_OK;
 
-	/* Sanity check the FADT for valid values */
 
-	status = acpi_ut_validate_fadt ();
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
+	ACPI_FUNCTION_TRACE ("acpi_enable_subsystem");
 
-	/*
-	 * Install the default Op_region handlers. These are
-	 * installed unless other handlers have already been
-	 * installed via the Install_address_space_handler interface
-	 */
-	if (!(flags & ACPI_NO_ADDRESS_SPACE_INIT)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Installing default address space handlers\n"));
-
-		status = acpi_ev_install_default_address_space_handlers ();
-		if (ACPI_FAILURE (status)) {
-			return_ACPI_STATUS (status);
-		}
-	}
 
 	/*
 	 * We must initialize the hardware before we can enable ACPI.
+	 * The values from the FADT are validated here.
 	 */
 	if (!(flags & ACPI_NO_HARDWARE_INIT)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Initializing ACPI hardware\n"));
@@ -163,21 +158,24 @@ acpi_enable_subsystem (
 	}
 
 	/*
-	 * Enable ACPI on this platform
+	 * Enable ACPI mode
 	 */
 	if (!(flags & ACPI_NO_ACPI_ENABLE)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Going into ACPI mode\n"));
 
+		acpi_gbl_original_mode = acpi_hw_get_mode();
+
 		status = acpi_enable ();
 		if (ACPI_FAILURE (status)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Acpi_enable failed.\n"));
+			ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "acpi_enable failed.\n"));
 			return_ACPI_STATUS (status);
 		}
 	}
 
 	/*
-	 * Note:
-	 * We must have the hardware AND events initialized before we can execute
+	 * Initialize ACPI Event handling
+	 *
+	 * NOTE: We must have the hardware AND events initialized before we can execute
 	 * ANY control methods SAFELY.  Any control method can require ACPI hardware
 	 * support, so the hardware MUST be initialized before execution!
 	 */
@@ -190,25 +188,65 @@ acpi_enable_subsystem (
 		}
 	}
 
+	/* Install the SCI handler, Global Lock handler, and GPE handlers */
+
+	if (!(flags & ACPI_NO_HANDLER_INIT)) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Installing SCI/GL/GPE handlers\n"));
+
+		status = acpi_ev_handler_initialize ();
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
+	}
+
+	return_ACPI_STATUS (status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_initialize_objects
+ *
+ * PARAMETERS:  Flags           - Init/enable Options
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Completes namespace initialization by initializing device
+ *              objects and executing AML code for Regions, buffers, etc.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_initialize_objects (
+	u32                             flags)
+{
+	acpi_status                     status = AE_OK;
+
+
+	ACPI_FUNCTION_TRACE ("acpi_initialize_objects");
+
 
 	/*
-	 * Initialize all device objects in the namespace
-	 * This runs the _STA and _INI methods.
+	 * Install the default op_region handlers. These are installed unless
+	 * other handlers have already been installed via the
+	 * install_address_space_handler interface.
+	 *
+	 * NOTE: This will cause _REG methods to be run.  Any objects accessed
+	 * by the _REG methods will be automatically initialized, even if they
+	 * contain executable AML (see call to acpi_ns_initialize_objects below).
 	 */
-	if (!(flags & ACPI_NO_DEVICE_INIT)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Initializing ACPI Devices\n"));
+	if (!(flags & ACPI_NO_ADDRESS_SPACE_INIT)) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Installing default address space handlers\n"));
 
-		status = acpi_ns_initialize_devices ();
+		status = acpi_ev_init_address_spaces ();
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
 	}
 
-
 	/*
 	 * Initialize the objects that remain uninitialized.  This
-	 * runs the executable AML that is part of the declaration of Op_regions
-	 * and Fields.
+	 * runs the executable AML that may be part of the declaration of these
+	 * objects: operation_regions, buffer_fields, Buffers, and Packages.
 	 */
 	if (!(flags & ACPI_NO_OBJECT_INIT)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Initializing ACPI Objects\n"));
@@ -219,15 +257,34 @@ acpi_enable_subsystem (
 		}
 	}
 
-	acpi_gbl_startup_flags |= ACPI_INITIALIZED_OK;
+	/*
+	 * Initialize all device objects in the namespace
+	 * This runs the _STA and _INI methods.
+	 */
+	if (!(flags & ACPI_NO_DEVICE_INIT)) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Initializing ACPI Devices\n"));
 
+		status = acpi_ns_initialize_devices ();
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
+	}
+
+	/*
+	 * Empty the caches (delete the cached objects) on the assumption that
+	 * the table load filled them up more than they will be at runtime --
+	 * thus wasting non-paged memory.
+	 */
+	status = acpi_purge_cached_objects ();
+
+	acpi_gbl_startup_flags |= ACPI_INITIALIZED_OK;
 	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_terminate
+ * FUNCTION:    acpi_terminate
  *
  * PARAMETERS:  None
  *
@@ -240,16 +297,15 @@ acpi_enable_subsystem (
 acpi_status
 acpi_terminate (void)
 {
-	FUNCTION_TRACE ("Acpi_terminate");
+	acpi_status                 status;
 
 
-	/* Terminate the AML Debugger if present */
+	ACPI_FUNCTION_TRACE ("acpi_terminate");
 
-	DEBUGGER_EXEC(acpi_gbl_db_terminate_threads = TRUE);
 
-	/* TBD: [Investigate] This is no longer needed?*/
-/*    Acpi_ut_release_mutex (ACPI_MTX_DEBUG_CMD_READY); */
+	/* Terminate the AML Debugger if present */
 
+	ACPI_DEBUGGER_EXEC(acpi_gbl_db_terminate_threads = TRUE);
 
 	/* Shutdown and free all resources */
 
@@ -261,7 +317,7 @@ acpi_terminate (void)
 	acpi_ut_mutex_terminate ();
 
 
-#ifdef ENABLE_DEBUGGER
+#ifdef ACPI_DEBUGGER
 
 	/* Shut down the debugger */
 
@@ -270,16 +326,14 @@ acpi_terminate (void)
 
 	/* Now we can shutdown the OS-dependent layer */
 
-	acpi_os_terminate ();
-
-
-	return_ACPI_STATUS (AE_OK);
+	status = acpi_os_terminate ();
+	return_ACPI_STATUS (status);
 }
 
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_subsystem_status
+ * FUNCTION:    acpi_subsystem_status
  *
  * PARAMETERS:  None
  *
@@ -305,65 +359,62 @@ acpi_subsystem_status (void)
 
 /******************************************************************************
  *
- * FUNCTION:    Acpi_get_system_info
+ * FUNCTION:    acpi_get_system_info
  *
- * PARAMETERS:  Out_buffer      - a pointer to a buffer to receive the
+ * PARAMETERS:  out_buffer      - a pointer to a buffer to receive the
  *                                resources for the device
- *              Buffer_length   - the number of bytes available in the buffer
+ *              buffer_length   - the number of bytes available in the buffer
  *
  * RETURN:      Status          - the status of the call
  *
  * DESCRIPTION: This function is called to get information about the current
  *              state of the ACPI subsystem.  It will return system information
- *              in the Out_buffer.
+ *              in the out_buffer.
  *
  *              If the function fails an appropriate status will be returned
- *              and the value of Out_buffer is undefined.
+ *              and the value of out_buffer is undefined.
  *
  ******************************************************************************/
 
 acpi_status
 acpi_get_system_info (
-	acpi_buffer             *out_buffer)
+	struct acpi_buffer              *out_buffer)
 {
-	acpi_system_info        *info_ptr;
-	u32                     i;
+	struct acpi_system_info         *info_ptr;
+	u32                             i;
+	acpi_status                     status;
 
 
-	FUNCTION_TRACE ("Acpi_get_system_info");
+	ACPI_FUNCTION_TRACE ("acpi_get_system_info");
 
 
-	/*
-	 *  Must have a valid buffer
-	 */
-	if ((!out_buffer)         ||
-		(!out_buffer->pointer)) {
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	/* Parameter validation */
+
+	status = acpi_ut_validate_buffer (out_buffer);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
 	}
 
-	if (out_buffer->length < sizeof (acpi_system_info)) {
-		/*
-		 *  Caller's buffer is too small
-		 */
-		out_buffer->length = sizeof (acpi_system_info);
+	/* Validate/Allocate/Clear caller buffer */
 
-		return_ACPI_STATUS (AE_BUFFER_OVERFLOW);
+	status = acpi_ut_initialize_buffer (out_buffer, sizeof (struct acpi_system_info));
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
 	}
 
-
 	/*
-	 *  Set return length and get data
+	 * Populate the return buffer
 	 */
-	out_buffer->length = sizeof (acpi_system_info);
-	info_ptr = (acpi_system_info *) out_buffer->pointer;
+	info_ptr = (struct acpi_system_info *) out_buffer->pointer;
 
 	info_ptr->acpi_ca_version   = ACPI_CA_VERSION;
 
 	/* System flags (ACPI capabilities) */
 
-	info_ptr->flags             = acpi_gbl_system_flags;
+	info_ptr->flags             = ACPI_SYS_MODE_ACPI;
 
 	/* Timer resolution - 24 or 32 bits  */
+
 	if (!acpi_gbl_FADT) {
 		info_ptr->timer_resolution = 0;
 	}
@@ -386,12 +437,70 @@ acpi_get_system_info (
 
 	/* Current status of the ACPI tables, per table type */
 
-	info_ptr->num_table_types = NUM_ACPI_TABLES;
-	for (i = 0; i < NUM_ACPI_TABLES; i++) {
-		info_ptr->table_info[i].count = acpi_gbl_acpi_tables[i].count;
+	info_ptr->num_table_types = NUM_ACPI_TABLE_TYPES;
+	for (i = 0; i < NUM_ACPI_TABLE_TYPES; i++) {
+		info_ptr->table_info[i].count = acpi_gbl_table_lists[i].count;
 	}
 
 	return_ACPI_STATUS (AE_OK);
 }
 
 
+/*****************************************************************************
+ *
+ * FUNCTION:    acpi_install_initialization_handler
+ *
+ * PARAMETERS:  Handler             - Callback procedure
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install an initialization handler
+ *
+ * TBD: When a second function is added, must save the Function also.
+ *
+ ****************************************************************************/
+
+acpi_status
+acpi_install_initialization_handler (
+	acpi_init_handler               handler,
+	u32                             function)
+{
+
+	if (!handler) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	if (acpi_gbl_init_handler) {
+		return (AE_ALREADY_EXISTS);
+	}
+
+	acpi_gbl_init_handler = handler;
+	return AE_OK;
+}
+
+
+/*****************************************************************************
+ *
+ * FUNCTION:    acpi_purge_cached_objects
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Empty all caches (delete the cached objects)
+ *
+ ****************************************************************************/
+
+acpi_status
+acpi_purge_cached_objects (void)
+{
+	ACPI_FUNCTION_TRACE ("acpi_purge_cached_objects");
+
+
+	acpi_ut_delete_generic_state_cache ();
+	acpi_ut_delete_object_cache ();
+	acpi_ds_delete_walk_state_cache ();
+	acpi_ps_delete_parse_cache ();
+
+	return_ACPI_STATUS (AE_OK);
+}
diff -urNp linux-5400/drivers/acpi/utils.c linux-5410/drivers/acpi/utils.c
--- linux-5400/drivers/acpi/utils.c
+++ linux-5410/drivers/acpi/utils.c
@@ -0,0 +1,413 @@
+/*
+ *  acpi_utils.c - ACPI Utility Functions ($Revision: 8 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+
+#define _COMPONENT		ACPI_BUS_COMPONENT
+ACPI_MODULE_NAME		("acpi_utils")
+
+
+/* --------------------------------------------------------------------------
+                            Object Evaluation Helpers
+   -------------------------------------------------------------------------- */
+
+#ifdef ACPI_DEBUG_OUTPUT
+#define acpi_util_eval_error(h,p,s) {\
+	char prefix[80] = {'\0'};\
+	struct acpi_buffer buffer = {sizeof(prefix), prefix};\
+	acpi_get_name(h, ACPI_FULL_PATHNAME, &buffer);\
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Evaluate [%s.%s]: %s\n",\
+		(char *) prefix, p, acpi_format_exception(s))); }
+#else
+#define acpi_util_eval_error(h,p,s)
+#endif
+
+
+acpi_status
+acpi_extract_package (
+	union acpi_object	*package,
+	struct acpi_buffer	*format,
+	struct acpi_buffer	*buffer)
+{
+	u32			size_required = 0;
+	u32			tail_offset = 0;
+	char			*format_string = NULL;
+	u32			format_count = 0;
+	u32			i = 0;
+	u8			*head = NULL;
+	u8			*tail = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_extract_package");
+
+	if (!package || (package->type != ACPI_TYPE_PACKAGE) || (package->package.count < 1)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid 'package' argument\n"));
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	if (!format || !format->pointer || (format->length < 1)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid 'format' argument\n"));
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	if (!buffer) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid 'buffer' argument\n"));
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	format_count = (format->length/sizeof(char)) - 1;
+	if (format_count > package->package.count) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Format specifies more objects [%d] than exist in package [%d].", format_count, package->package.count));
+		return_ACPI_STATUS(AE_BAD_DATA);
+	}
+
+	format_string = (char*)format->pointer;
+
+	/*
+	 * Calculate size_required.
+	 */
+	for (i=0; i<format_count; i++) {
+
+		union acpi_object *element = &(package->package.elements[i]);
+
+		if (!element) {
+			return_ACPI_STATUS(AE_BAD_DATA);
+		}
+
+		switch (element->type) {
+
+		case ACPI_TYPE_INTEGER:
+			switch (format_string[i]) {
+			case 'N':
+				size_required += sizeof(acpi_integer);
+				tail_offset += sizeof(acpi_integer);
+				break;
+			case 'S':
+				size_required += sizeof(char*) + sizeof(acpi_integer) + sizeof(char);
+				tail_offset += sizeof(char*);
+				break;
+			default:
+				ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid package element [%d]: got number, expecing [%c].\n", i, format_string[i]));
+				return_ACPI_STATUS(AE_BAD_DATA);
+				break;
+			}
+			break;
+
+		case ACPI_TYPE_STRING:
+		case ACPI_TYPE_BUFFER:
+			switch (format_string[i]) {
+			case 'S':
+				size_required += sizeof(char*) + (element->string.length * sizeof(char)) + sizeof(char);
+				tail_offset += sizeof(char*);
+				break;
+			case 'B':
+				size_required += sizeof(u8*) + (element->buffer.length * sizeof(u8));
+				tail_offset += sizeof(u8*);
+				break;
+			default:
+				ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid package element [%d] got string/buffer, expecing [%c].\n", i, format_string[i]));
+				return_ACPI_STATUS(AE_BAD_DATA);
+				break;
+			}
+			break;
+
+		case ACPI_TYPE_PACKAGE:
+		default:
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found unsupported element at index=%d\n", i));
+			/* TBD: handle nested packages... */
+			return_ACPI_STATUS(AE_SUPPORT);
+			break;
+		}
+	}
+
+	/*
+	 * Validate output buffer.
+	 */
+	if (buffer->length < size_required) {
+		buffer->length = size_required;
+		return_ACPI_STATUS(AE_BUFFER_OVERFLOW);
+	}
+	else if (buffer->length != size_required || !buffer->pointer) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	head = buffer->pointer;
+	tail = buffer->pointer + tail_offset;
+
+	/*
+	 * Extract package data.
+	 */
+	for (i=0; i<format_count; i++) {
+
+		u8 **pointer = NULL;
+		union acpi_object *element = &(package->package.elements[i]);
+
+		if (!element) {
+			return_ACPI_STATUS(AE_BAD_DATA);
+		}
+
+		switch (element->type) {
+
+		case ACPI_TYPE_INTEGER:
+			switch (format_string[i]) {
+			case 'N':
+				*((acpi_integer*)head) = element->integer.value;
+				head += sizeof(acpi_integer);
+				break;
+			case 'S':
+				pointer = (u8**)head;
+				*pointer = tail;
+				*((acpi_integer*)tail) = element->integer.value;
+				head += sizeof(acpi_integer*);
+				tail += sizeof(acpi_integer);
+				/* NULL terminate string */
+				*tail = (char)0;
+				tail += sizeof(char);
+				break;
+			default:
+				/* Should never get here */
+				break;
+			}
+			break;
+
+		case ACPI_TYPE_STRING:
+		case ACPI_TYPE_BUFFER:
+			switch (format_string[i]) {
+			case 'S':
+				pointer = (u8**)head;
+				*pointer = tail;
+				memcpy(tail, element->string.pointer, element->string.length);
+				head += sizeof(char*);
+				tail += element->string.length * sizeof(char);
+				/* NULL terminate string */
+				*tail = (char)0;
+				tail += sizeof(char);
+				break;
+			case 'B':
+				pointer = (u8**)head;
+				*pointer = tail;
+				memcpy(tail, element->buffer.pointer, element->buffer.length);
+				head += sizeof(u8*);
+				tail += element->buffer.length * sizeof(u8);
+				break;
+			default:
+				/* Should never get here */
+				break;
+			}
+			break;
+
+		case ACPI_TYPE_PACKAGE:
+			/* TBD: handle nested packages... */
+		default:
+			/* Should never get here */
+			break;
+		}
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+
+acpi_status
+acpi_evaluate_integer (
+	acpi_handle		handle,
+	acpi_string		pathname,
+	struct acpi_object_list	*arguments,
+	unsigned long		*data)
+{
+	acpi_status             status = AE_OK;
+	union acpi_object	element;
+	struct acpi_buffer	buffer = {sizeof(union acpi_object), &element};
+
+	ACPI_FUNCTION_TRACE("acpi_evaluate_integer");
+
+	if (!data)
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+
+	status = acpi_evaluate_object(handle, pathname, arguments, &buffer);
+	if (ACPI_FAILURE(status)) {
+		acpi_util_eval_error(handle, pathname, status);
+		return_ACPI_STATUS(status);
+	}
+
+	if (element.type != ACPI_TYPE_INTEGER) {
+		acpi_util_eval_error(handle, pathname, AE_BAD_DATA);
+		return_ACPI_STATUS(AE_BAD_DATA);
+	}
+
+	*data = element.integer.value;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Return value [%lu]\n", *data));
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+
+#if 0
+acpi_status
+acpi_evaluate_string (
+	acpi_handle		handle,
+	acpi_string		pathname,
+	acpi_object_list	*arguments,
+	acpi_string		*data)
+{
+	acpi_status             status = AE_OK;
+	acpi_object             *element = NULL;
+	acpi_buffer		buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+
+	ACPI_FUNCTION_TRACE("acpi_evaluate_string");
+
+	if (!data)
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+
+	status = acpi_evaluate_object(handle, pathname, arguments, &buffer);
+	if (ACPI_FAILURE(status)) {
+		acpi_util_eval_error(handle, pathname, status);
+		return_ACPI_STATUS(status);
+	}
+
+	element = (acpi_object *) buffer.pointer;
+
+	if ((element->type != ACPI_TYPE_STRING) 
+		|| (element->type != ACPI_TYPE_BUFFER)
+		|| !element->string.length) {
+		acpi_util_eval_error(handle, pathname, AE_BAD_DATA);
+		return_ACPI_STATUS(AE_BAD_DATA);
+	}
+
+	*data = kmalloc(element->string.length + 1, GFP_KERNEL);
+	if (!data) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Memory allocation error\n"));
+		return_VALUE(-ENOMEM);
+	}
+	memset(*data, 0, element->string.length + 1);
+
+	memcpy(*data, element->string.pointer, element->string.length);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Return value [%s]\n", *data));
+
+	acpi_os_free(buffer.pointer);
+
+	return_ACPI_STATUS(AE_OK);
+}
+#endif
+
+
+acpi_status
+acpi_evaluate_reference (
+	acpi_handle		handle,
+	acpi_string		pathname,
+	struct acpi_object_list	*arguments,
+	struct acpi_handle_list	*list)
+{
+	acpi_status		status = AE_OK;
+	union acpi_object	*package = NULL;
+	union acpi_object	*element = NULL;
+	struct acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	u32			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_evaluate_reference");
+
+	if (!list) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Evaluate object. */
+
+	status = acpi_evaluate_object(handle, pathname, arguments, &buffer);
+	if (ACPI_FAILURE(status))
+		goto end;
+
+	package = (union acpi_object *) buffer.pointer;
+
+	if ((buffer.length == 0) || !package) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"No return object (len %X ptr %p)\n", 
+			buffer.length, package));
+		status = AE_BAD_DATA;
+		acpi_util_eval_error(handle, pathname, status);
+		goto end;
+	}
+	if (package->type != ACPI_TYPE_PACKAGE) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Expecting a [Package], found type %X\n", 
+			package->type));
+		status = AE_BAD_DATA;
+		acpi_util_eval_error(handle, pathname, status);
+		goto end;
+	}
+	if (!package->package.count) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"[Package] has zero elements (%p)\n", 
+			package));
+		status = AE_BAD_DATA;
+		acpi_util_eval_error(handle, pathname, status);
+		goto end;
+	}
+
+	if (package->package.count > ACPI_MAX_HANDLES) {
+		return AE_NO_MEMORY;
+	}
+	list->count = package->package.count;
+
+	/* Extract package data. */
+
+	for (i = 0; i < list->count; i++) {
+
+		element = &(package->package.elements[i]);
+
+		if (element->type != ACPI_TYPE_ANY) {
+			status = AE_BAD_DATA;
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+				"Expecting a [Reference] package element, found type %X\n",
+				element->type));
+			acpi_util_eval_error(handle, pathname, status);
+			break;
+		}
+
+		/* Get the  acpi_handle. */
+
+		list->handles[i] = element->reference.handle;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found reference [%p]\n",
+			list->handles[i]));
+	}
+
+end:
+	if (ACPI_FAILURE(status)) {
+		list->count = 0;
+		//kfree(list->handles);
+	}
+
+	acpi_os_free(buffer.pointer);
+
+	return_ACPI_STATUS(status);
+}
+
+
diff -urNp linux-5400/drivers/hotplug/Makefile linux-5410/drivers/hotplug/Makefile
--- linux-5400/drivers/hotplug/Makefile
+++ linux-5410/drivers/hotplug/Makefile
@@ -27,10 +27,6 @@ ibmphp-objs		:=	ibmphp_core.o	\
 				ibmphp_res.o	\
 				ibmphp_hpc.o
 
-ifdef CONFIG_HOTPLUG_PCI_ACPI
-  EXTRA_CFLAGS	+= -D_LINUX -I$(CURDIR)/../acpi
-endif
-
 acpiphp_objs		:=	acpiphp_core.o	\
 				acpiphp_glue.o	\
 				acpiphp_pci.o	\
diff -urNp linux-5400/drivers/hotplug/acpiphp.h linux-5410/drivers/hotplug/acpiphp.h
--- linux-5400/drivers/hotplug/acpiphp.h
+++ linux-5410/drivers/hotplug/acpiphp.h
@@ -5,8 +5,8 @@
  * Copyright (c) 2001 Greg Kroah-Hartman (greg@kroah.com)
  * Copyright (c) 2001 IBM Corp.
  * Copyright (c) 2002 Hiroshi Aono (h-aono@ap.jp.nec.com)
- * Copyright (c) 2002 Takayoshi Kochi (t-kouchi@cq.jp.nec.com)
- * Copyright (c) 2002 NEC Corporation
+ * Copyright (c) 2002,2003 Takayoshi Kochi (t-kochi@bq.jp.nec.com)
+ * Copyright (c) 2002,2003 NEC Corporation
  *
  * All rights reserved.
  *
@@ -26,15 +26,14 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
  * Send feedback to <gregkh@us.ibm.com>,
- *		    <h-aono@ap.jp.nec.com>,
- *		    <t-kouchi@cq.jp.nec.com>
+ *		    <t-kochi@bq.jp.nec.com>
  *
  */
 
 #ifndef _ACPIPHP_H
 #define _ACPIPHP_H
 
-#include "include/acpi.h"
+#include <linux/acpi.h>
 #include "pci_hotplug.h"
 
 #if ACPI_CA_VERSION < 0x20020201
@@ -71,7 +70,7 @@ acpi_evaluate_integer (
 	return AE_OK;
 }
 #else  /* ACPI_CA_VERSION < 0x20020201 */
-#include "acpi_bus.h"
+#include <acpi/acpi_bus.h>
 #endif
 
 /* compatibility stuff for ACPI CA */
@@ -107,7 +106,7 @@ acpi_evaluate_integer (
 
 #define SLOT_MAGIC	0x67267322
 /* name size which is used for entries in pcihpfs */
-#define SLOT_NAME_SIZE	32		/* ACPI{_SUN}-{BUS}:{DEV} */
+#define SLOT_NAME_SIZE	16		/* {_SUN} */
 
 struct acpiphp_bridge;
 struct acpiphp_slot;
@@ -270,11 +269,7 @@ struct acpiphp_func {
 #define FUNC_HAS_PS2		(0x00000040)
 #define FUNC_HAS_PS3		(0x00000080)
 
-/* not yet */
-#define SLOT_SUPPORT_66MHZ	(0x00010000)
-#define SLOT_SUPPORT_100MHZ	(0x00020000)
-#define SLOT_SUPPORT_133MHZ	(0x00040000)
-#define SLOT_SUPPORT_PCIX	(0x00080000)
+#define FUNC_EXISTS		(0x10000000) /* to make sure we call _EJ0 only for existing funcs */
 
 /* function prototypes */
 
diff -urNp linux-5400/drivers/hotplug/acpiphp_core.c linux-5410/drivers/hotplug/acpiphp_core.c
--- linux-5400/drivers/hotplug/acpiphp_core.c
+++ linux-5410/drivers/hotplug/acpiphp_core.c
@@ -5,8 +5,8 @@
  * Copyright (c) 2001 Greg Kroah-Hartman (greg@kroah.com)
  * Copyright (c) 2001 IBM Corp.
  * Copyright (c) 2002 Hiroshi Aono (h-aono@ap.jp.nec.com)
- * Copyright (c) 2002 Takayoshi Kochi (t-kouchi@cq.jp.nec.com)
- * Copyright (c) 2002 NEC Corporation
+ * Copyright (c) 2002,2003 Takayoshi Kochi (t-kochi@bq.jp.nec.com)
+ * Copyright (c) 2002,2003 NEC Corporation
  *
  * All rights reserved.
  *
@@ -26,8 +26,7 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
  * Send feedback to <gregkh@us.ibm.com>,
- *                  <h-aono@ap.jp.nec.com>,
- *		    <t-kouchi@cq.jp.nec.com>
+ *		    <t-kochi@bq.jp.nec.com>
  *
  */
 
@@ -57,7 +56,7 @@ int acpiphp_debug;
 static int num_slots;
 
 #define DRIVER_VERSION	"0.4"
-#define DRIVER_AUTHOR	"Greg Kroah-Hartman <gregkh@us.ibm.com>, Takayoshi Kochi <t-kouchi@cq.jp.nec.com>"
+#define DRIVER_AUTHOR	"Greg Kroah-Hartman <gregkh@us.ibm.com>, Takayoshi Kochi <t-kochi@bq.jp.nec.com>"
 #define DRIVER_DESC	"ACPI Hot Plug PCI Controller Driver"
 
 MODULE_AUTHOR(DRIVER_AUTHOR);
@@ -376,10 +375,8 @@ static int init_acpi (void)
  */
 static void make_slot_name (struct slot *slot)
 {
-	snprintf(slot->hotplug_slot->name, SLOT_NAME_SIZE, "ACPI%d-%02x:%02x",
-		 slot->acpi_slot->sun,
-		 slot->acpi_slot->bridge->bus,
-		 slot->acpi_slot->device);
+	snprintf(slot->hotplug_slot->name, SLOT_NAME_SIZE, "%u",
+		 slot->acpi_slot->sun);
 }
 
 /**
diff -urNp linux-5400/drivers/hotplug/acpiphp_glue.c linux-5410/drivers/hotplug/acpiphp_glue.c
--- linux-5400/drivers/hotplug/acpiphp_glue.c
+++ linux-5410/drivers/hotplug/acpiphp_glue.c
@@ -1,9 +1,9 @@
 /*
  * ACPI PCI HotPlug glue functions to ACPI CA subsystem
  *
- * Copyright (c) 2002 Takayoshi Kochi (t-kouchi@cq.jp.nec.com)
+ * Copyright (c) 2002,2003 Takayoshi Kochi (t-kochi@bq.jp.nec.com)
  * Copyright (c) 2002 Hiroshi Aono (h-aono@ap.jp.nec.com)
- * Copyright (c) 2002 NEC Corporation
+ * Copyright (c) 2002,2003 NEC Corporation
  *
  * All rights reserved.
  *
@@ -22,7 +22,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * Send feedback to <t-kouchi@cq.jp.nec.com>
+ * Send feedback to <t-kochi@bq.jp.nec.com>
  *
  */
 
@@ -230,11 +230,11 @@ static int detect_ejectable_slots (acpi_
  * TBD: _TRA, etc.
  */
 static void
-decode_acpi_resource (acpi_resource *resource, struct acpiphp_bridge *bridge)
+decode_acpi_resource (struct acpi_resource *resource, struct acpiphp_bridge *bridge)
 {
-	acpi_resource_address16 *address16_data;
-	acpi_resource_address32 *address32_data;
-	acpi_resource_address64 *address64_data;
+	struct acpi_resource_address16 *address16_data;
+	struct acpi_resource_address32 *address32_data;
+	struct acpi_resource_address64 *address64_data;
 	struct pci_resource *res;
 
 	u32 resource_type, producer_consumer, address_length;
@@ -252,7 +252,7 @@ decode_acpi_resource (acpi_resource *res
 
 		switch (resource->id) {
 		case ACPI_RSTYPE_ADDRESS16:
-			address16_data = (acpi_resource_address16 *)&resource->data;
+			address16_data = (struct acpi_resource_address16 *)&resource->data;
 			resource_type = address16_data->resource_type;
 			producer_consumer = address16_data->producer_consumer;
 			min_address_range = address16_data->min_address_range;
@@ -264,7 +264,7 @@ decode_acpi_resource (acpi_resource *res
 			break;
 
 		case ACPI_RSTYPE_ADDRESS32:
-			address32_data = (acpi_resource_address32 *)&resource->data;
+			address32_data = (struct acpi_resource_address32 *)&resource->data;
 			resource_type = address32_data->resource_type;
 			producer_consumer = address32_data->producer_consumer;
 			min_address_range = address32_data->min_address_range;
@@ -276,7 +276,7 @@ decode_acpi_resource (acpi_resource *res
 			break;
 
 		case ACPI_RSTYPE_ADDRESS64:
-			address64_data = (acpi_resource_address64 *)&resource->data;
+			address64_data = (struct acpi_resource_address64 *)&resource->data;
 			resource_type = address64_data->resource_type;
 			producer_consumer = address64_data->producer_consumer;
 			min_address_range = address64_data->min_address_range;
@@ -296,7 +296,7 @@ decode_acpi_resource (acpi_resource *res
 			break;
 		}
 
-		resource = (acpi_resource *)((char*)resource + resource->length);
+		resource = (struct acpi_resource *)((char*)resource + resource->length);
 
 		if (found && producer_consumer == ACPI_PRODUCER && address_length > 0) {
 			switch (resource_type) {
@@ -392,10 +392,10 @@ static void decode_hpp(struct acpiphp_br
 #if ACPI_CA_VERSION < 0x20020201
 	acpi_buffer buffer;
 #else
-	acpi_buffer buffer = { .length = ACPI_ALLOCATE_BUFFER,
-			       .pointer = NULL};
+	struct acpi_buffer buffer = { .length = ACPI_ALLOCATE_BUFFER,
+				      .pointer = NULL};
 #endif
-	acpi_object *package;
+	union acpi_object *package;
 	int i;
 
 	/* default numbers */
@@ -425,7 +425,7 @@ static void decode_hpp(struct acpiphp_br
 		return;
 	}
 
-	package = (acpi_object *) buffer.pointer;
+	package = (union acpi_object *) buffer.pointer;
 
 	if (!package || package->type != ACPI_TYPE_PACKAGE ||
 	    package->package.count != 4 || !package->package.elements) {
@@ -497,8 +497,8 @@ static void add_host_bridge (acpi_handle
 #if ACPI_CA_VERSION < 0x20020201
 	acpi_buffer buffer;
 #else
-	acpi_buffer buffer = { .length = ACPI_ALLOCATE_BUFFER,
-			       .pointer = NULL};
+	struct acpi_buffer buffer = { .length = ACPI_ALLOCATE_BUFFER,
+				      .pointer = NULL};
 #endif
 	struct acpiphp_bridge *bridge;
 
@@ -613,6 +613,7 @@ static void add_p2p_bridge (acpi_handle 
 		bridge->io_head = acpiphp_make_resource((u64)base, limit - base + 1);
 		if (!bridge->io_head) {
 			err("out of memory\n");
+			kfree(bridge);
 			return;
 		}
 		dbg("16bit I/O range: %04x-%04x\n",
@@ -627,6 +628,7 @@ static void add_p2p_bridge (acpi_handle 
 		bridge->io_head = acpiphp_make_resource((u64)base, limit - base + 1);
 		if (!bridge->io_head) {
 			err("out of memory\n");
+			kfree(bridge);
 			return;
 		}
 		dbg("32bit I/O range: %08x-%08x\n",
@@ -648,6 +650,7 @@ static void add_p2p_bridge (acpi_handle 
 	bridge->mem_head = acpiphp_make_resource((u64)base, limit - base + 1);
 	if (!bridge->mem_head) {
 		err("out of memory\n");
+		kfree(bridge);
 		return;
 	}
 	dbg("32bit Memory range: %08x-%08x\n",
@@ -667,6 +670,7 @@ static void add_p2p_bridge (acpi_handle 
 		bridge->p_mem_head = acpiphp_make_resource((u64)base, limit - base + 1);
 		if (!bridge->p_mem_head) {
 			err("out of memory\n");
+			kfree(bridge);
 			return;
 		}
 		dbg("32bit Prefetchable memory range: %08x-%08x\n",
@@ -682,6 +686,7 @@ static void add_p2p_bridge (acpi_handle 
 		bridge->p_mem_head = acpiphp_make_resource(base64, limit64 - base64 + 1);
 		if (!bridge->p_mem_head) {
 			err("out of memory\n");
+			kfree(bridge);
 			return;
 		}
 		dbg("64bit Prefetchable memory range: %08x%08x-%08x%08x\n",
@@ -747,7 +752,7 @@ find_p2p_bridge (acpi_handle handle, u32
 
 
 /* find hot-pluggable slots, and then find P2P bridge */
-static int add_bridges (acpi_handle *handle)
+static int add_bridge (acpi_handle handle)
 {
 	acpi_status status;
 	unsigned long tmp;
@@ -802,36 +807,11 @@ static int add_bridges (acpi_handle *han
 }
 
 
-/* callback routine to enumerate all the bridges in ACPI namespace */
-static acpi_status
-find_host_bridge (acpi_handle handle, u32 lvl, void *context, void **rv)
+static void remove_bridge (acpi_handle handle)
 {
-	acpi_status status;
-	acpi_device_info info;
-	char objname[5];
-	acpi_buffer buffer = { .length = sizeof(objname),
-			       .pointer = objname };
-
-	status = acpi_get_object_info(handle, &info);
-	if (ACPI_FAILURE(status)) {
-		dbg("%s: failed to get bridge information\n", __FUNCTION__);
-		return AE_OK;		/* continue */
-	}
-
-	info.hardware_id[sizeof(info.hardware_id)-1] = '\0';
-
-	/* TBD use acpi_get_devices() API */
-	if (info.current_status &&
-	    (info.valid & ACPI_VALID_HID) &&
-	    strcmp(info.hardware_id, ACPI_PCI_HOST_HID) == 0) {
-		acpi_get_name(handle, ACPI_SINGLE_NAME, &buffer);
-		dbg("checking PCI-hotplug capable bridges under [%s]\n", objname);
-		add_bridges(handle);
-	}
-	return AE_OK;
+	/* No-op for now .. */
 }
 
-
 static int power_on_slot (struct acpiphp_slot *slot)
 {
 	acpi_status status;
@@ -847,14 +827,14 @@ static int power_on_slot (struct acpiphp
 		func = list_entry(l, struct acpiphp_func, sibling);
 
 		if (func->flags & FUNC_HAS_PS0) {
-			dbg("%s: executing _PS0 on %s\n", __FUNCTION__,
-			    func->pci_dev->slot_name);
+			dbg("%s: executing _PS0\n", __FUNCTION__);
 			status = acpi_evaluate_object(func->handle, "_PS0", NULL, NULL);
 			if (ACPI_FAILURE(status)) {
 				warn("%s: _PS0 failed\n", __FUNCTION__);
 				retval = -1;
 				goto err_exit;
-			}
+			} else
+				break;
 		}
 	}
 
@@ -872,8 +852,8 @@ static int power_off_slot (struct acpiph
 	acpi_status status;
 	struct acpiphp_func *func;
 	struct list_head *l;
-	acpi_object_list arg_list;
-	acpi_object arg;
+	struct acpi_object_list arg_list;
+	union acpi_object arg;
 
 	int retval = 0;
 
@@ -884,25 +864,22 @@ static int power_off_slot (struct acpiph
 	list_for_each (l, &slot->funcs) {
 		func = list_entry(l, struct acpiphp_func, sibling);
 
-		if (func->flags & FUNC_HAS_PS3) {
-			dbg("%s: executing _PS3 on %s\n", __FUNCTION__,
-			    func->pci_dev->slot_name);
+		if (func->flags & (FUNC_HAS_PS3 | FUNC_EXISTS)) {
 			status = acpi_evaluate_object(func->handle, "_PS3", NULL, NULL);
 			if (ACPI_FAILURE(status)) {
 				warn("%s: _PS3 failed\n", __FUNCTION__);
 				retval = -1;
 				goto err_exit;
-			}
+			} else
+				break;
 		}
 	}
 
 	list_for_each (l, &slot->funcs) {
 		func = list_entry(l, struct acpiphp_func, sibling);
 
-		if (func->flags & FUNC_HAS_EJ0) {
-			dbg("%s: executing _EJ0 on %s\n", __FUNCTION__,
-			    func->pci_dev->slot_name);
-
+		/* We don't want to call _EJ0 on non-existing functions. */
+		if (func->flags & (FUNC_HAS_EJ0 | FUNC_EXISTS)) {
 			/* _EJ0 method take one argument */
 			arg_list.count = 1;
 			arg_list.pointer = &arg;
@@ -915,6 +892,9 @@ static int power_off_slot (struct acpiph
 				retval = -1;
 				goto err_exit;
 			}
+			else
+				break;
+			func->flags &= (~FUNC_EXISTS);
 		}
 	}
 
@@ -996,6 +976,8 @@ static int enable_device (struct acpiphp
 		retval = acpiphp_configure_function(func);
 		if (retval)
 			goto err_exit;
+
+		func->flags |= FUNC_EXISTS;
 	}
 
 	slot->flags |= SLOT_ENABLED;
@@ -1101,8 +1083,8 @@ static void handle_hotplug_event_bridge 
 {
 	struct acpiphp_bridge *bridge;
 	char objname[64];
-	acpi_buffer buffer = { .length = sizeof(objname),
-			       .pointer = objname };
+	struct acpi_buffer buffer = { .length = sizeof(objname),
+				      .pointer = objname };
 
 	bridge = (struct acpiphp_bridge *)context;
 
@@ -1152,8 +1134,8 @@ static void handle_hotplug_event_func (a
 {
 	struct acpiphp_func *func;
 	char objname[64];
-	acpi_buffer buffer = { .length = sizeof(objname),
-			       .pointer = objname };
+	struct acpi_buffer buffer = { .length = sizeof(objname),
+				      .pointer = objname };
 
 	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
 
@@ -1190,25 +1172,26 @@ static void handle_hotplug_event_func (a
 }
 
 
+static struct acpi_pci_driver acpi_pci_hp_driver = {
+	.add =		add_bridge,
+	.remove =	remove_bridge,
+};
+
 /**
  * acpiphp_glue_init - initializes all PCI hotplug - ACPI glue data structures
  *
  */
 int acpiphp_glue_init (void)
 {
-	acpi_status status;
+	int num;
 
 	if (list_empty(&pci_root_buses))
 		return -1;
 
-	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
-				     ACPI_UINT32_MAX, find_host_bridge,
-				     NULL, NULL);
+	num = acpi_pci_register_driver(&acpi_pci_hp_driver);
 
-	if (ACPI_FAILURE(status)) {
-		err("%s: acpi_walk_namespace() failed\n", __FUNCTION__);
+	if (num <= 0)
 		return -1;
-	}
 
 	return 0;
 }
@@ -1407,22 +1390,22 @@ int acpiphp_check_bridge (struct acpiphp
 			if (sta != ACPI_STA_ALL) {
 				retval = acpiphp_disable_slot(slot);
 				if (retval) {
-					err("Error occured in enabling\n");
+					err("Error occurred in enabling\n");
 					up(&slot->crit_sect);
 					goto err_exit;
 				}
-				enabled++;
+				disabled++;
 			}
 		} else {
 			/* if disabled but present, enable */
 			if (sta == ACPI_STA_ALL) {
 				retval = acpiphp_enable_slot(slot);
 				if (retval) {
-					err("Error occured in enabling\n");
+					err("Error occurred in enabling\n");
 					up(&slot->crit_sect);
 					goto err_exit;
 				}
-				disabled++;
+				enabled++;
 			}
 		}
 	}
@@ -1450,7 +1433,7 @@ u8 acpiphp_get_power_status (struct acpi
 
 /*
  * attention LED ON: 1
- *              OFF: 0
+ *		OFF: 0
  *
  * TBD
  * no direct attention led status information via ACPI
diff -urNp linux-5400/drivers/hotplug/acpiphp_pci.c linux-5410/drivers/hotplug/acpiphp_pci.c
--- linux-5400/drivers/hotplug/acpiphp_pci.c
+++ linux-5410/drivers/hotplug/acpiphp_pci.c
@@ -4,7 +4,7 @@
  * Copyright (c) 1995,2001 Compaq Computer Corporation
  * Copyright (c) 2001 Greg Kroah-Hartman (greg@kroah.com)
  * Copyright (c) 2001,2002 IBM Corp.
- * Copyright (c) 2002 Takayoshi Kochi (t-kouchi@cq.jp.nec.com)
+ * Copyright (c) 2002 Takayoshi Kochi (t-kochi@bq.jp.nec.com)
  * Copyright (c) 2002 Hiroshi Aono (h-aono@ap.jp.nec.com)
  * Copyright (c) 2002 NEC Corporation
  *
@@ -25,7 +25,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * Send feedback to <t-kouchi@cq.jp.nec.com>
+ * Send feedback to <t-kochi@bq.jp.nec.com>
  *
  */
 
@@ -78,8 +78,8 @@ static int init_config_space (struct acp
 		if (bar & PCI_BASE_ADDRESS_SPACE_IO) {
 			/* This is IO */
 
-			len = bar & 0xFFFFFFFC;
-			len = ~len + 1;
+			len = bar & (PCI_BASE_ADDRESS_IO_MASK & 0xFFFF);
+			len = len & ~(len - 1);
 
 			dbg("len in IO %x, BAR %d\n", len, count);
 
@@ -340,8 +340,8 @@ static int detect_used_resource (struct 
 		if (len & PCI_BASE_ADDRESS_SPACE_IO) {
 			/* This is IO */
 			base = bar & 0xFFFFFFFC;
-			len &= 0xFFFFFFFC;
-			len = ~len + 1;
+			len = len & (PCI_BASE_ADDRESS_IO_MASK & 0xFFFF);
+			len = len & ~(len - 1);
 
 			dbg("BAR[%d] %08x - %08x (IO)\n", count, (u32)base, (u32)base + len - 1);
 
@@ -465,8 +465,8 @@ int acpiphp_init_func_resource (struct a
 		if (len & PCI_BASE_ADDRESS_SPACE_IO) {
 			/* This is IO */
 			base = bar & 0xFFFFFFFC;
-			len &= 0xFFFFFFFC;
-			len = ~len + 1;
+			len = len & (PCI_BASE_ADDRESS_IO_MASK & 0xFFFF);
+			len = len & ~(len - 1);
 
 			dbg("BAR[%d] %08x - %08x (IO)\n", count, (u32)base, (u32)base + len - 1);
 
diff -urNp linux-5400/drivers/hotplug/acpiphp_res.c linux-5410/drivers/hotplug/acpiphp_res.c
--- linux-5400/drivers/hotplug/acpiphp_res.c
+++ linux-5410/drivers/hotplug/acpiphp_res.c
@@ -5,7 +5,7 @@
  * Copyright (c) 2001 Greg Kroah-Hartman (greg@kroah.com)
  * Copyright (c) 2001 IBM Corp.
  * Copyright (c) 2002 Hiroshi Aono (h-aono@ap.jp.nec.com)
- * Copyright (c) 2002 Takayoshi Kochi (t-kouchi@cq.jp.nec.com)
+ * Copyright (c) 2002 Takayoshi Kochi (t-kochi@bq.jp.nec.com)
  * Copyright (c) 2002 NEC Corporation
  *
  * All rights reserved.
@@ -25,7 +25,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * Send feedback to <gregkh@us.ibm.com>,<h-aono@ap.jp.nec.com>
+ * Send feedback to <gregkh@us.ibm.com>, <t-kochi@bq.jp.nec.com>
  *
  */
 
@@ -225,7 +225,7 @@ struct pci_resource *acpiphp_get_io_reso
 		}  /* End of too big on top end */
 
 		/* For IO make sure it's not in the ISA aliasing space */
-		if (node->base & 0x300L)
+		if ((node->base & 0x300L) && !(node->base & 0xfffff000))
 			continue;
 
 		/* If we got here, then it is the right size
diff -urNp linux-5400/include/acpi/acconfig.h linux-5410/include/acpi/acconfig.h
--- linux-5400/include/acpi/acconfig.h
+++ linux-5410/include/acpi/acconfig.h
@@ -0,0 +1,202 @@
+/******************************************************************************
+ *
+ * Name: acconfig.h - Global configuration constants
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef _ACCONFIG_H
+#define _ACCONFIG_H
+
+
+/******************************************************************************
+ *
+ * Configuration options
+ *
+ *****************************************************************************/
+
+/*
+ * ACPI_DEBUG_OUTPUT    - This switch enables all the debug facilities of the
+ *                        ACPI subsystem.  This includes the DEBUG_PRINT output
+ *                        statements.  When disabled, all DEBUG_PRINT
+ *                        statements are compiled out.
+ *
+ * ACPI_APPLICATION     - Use this switch if the subsystem is going to be run
+ *                        at the application level.
+ *
+ */
+
+/* Version string */
+
+#define ACPI_CA_VERSION                 0x20030619
+
+/* Maximum objects in the various object caches */
+
+#define ACPI_MAX_STATE_CACHE_DEPTH      64          /* State objects for stacks */
+#define ACPI_MAX_PARSE_CACHE_DEPTH      96          /* Parse tree objects */
+#define ACPI_MAX_EXTPARSE_CACHE_DEPTH   64          /* Parse tree objects */
+#define ACPI_MAX_OBJECT_CACHE_DEPTH     64          /* Interpreter operand objects */
+#define ACPI_MAX_WALK_CACHE_DEPTH       4           /* Objects for parse tree walks */
+
+/*
+ * Should the subystem abort the loading of an ACPI table if the
+ * table checksum is incorrect?
+ */
+#define ACPI_CHECKSUM_ABORT             FALSE
+
+
+/******************************************************************************
+ *
+ * Subsystem Constants
+ *
+ *****************************************************************************/
+
+/* Version of ACPI supported */
+
+#define ACPI_CA_SUPPORT_LEVEL           2
+
+/* String size constants */
+
+#define ACPI_MAX_STRING_LENGTH          512
+#define ACPI_PATHNAME_MAX               256         /* A full namespace pathname */
+
+/* Maximum count for a semaphore object */
+
+#define ACPI_MAX_SEMAPHORE_COUNT        256
+
+/* Max reference count (for debug only) */
+
+#define ACPI_MAX_REFERENCE_COUNT        0x400
+
+/* Size of cached memory mapping for system memory operation region */
+
+#define ACPI_SYSMEM_REGION_WINDOW_SIZE  4096
+
+
+/******************************************************************************
+ *
+ * ACPI Specification constants (Do not change unless the specification changes)
+ *
+ *****************************************************************************/
+
+/* Number of distinct GPE register blocks and register width */
+
+#define ACPI_MAX_GPE_BLOCKS             2
+#define ACPI_GPE_REGISTER_WIDTH         8
+
+/*
+ * Method info (in WALK_STATE), containing local variables and argumetns
+ */
+#define ACPI_METHOD_NUM_LOCALS          8
+#define ACPI_METHOD_MAX_LOCAL           7
+
+#define ACPI_METHOD_NUM_ARGS            7
+#define ACPI_METHOD_MAX_ARG             6
+
+/* Maximum length of resulting string when converting from a buffer */
+
+#define ACPI_MAX_STRING_CONVERSION      200
+
+/* Length of _HID, _UID, and _CID values */
+
+#define ACPI_DEVICE_ID_LENGTH           0x09
+#define ACPI_MAX_CID_LENGTH             48
+
+/*
+ * Operand Stack (in WALK_STATE), Must be large enough to contain METHOD_MAX_ARG
+ */
+#define ACPI_OBJ_NUM_OPERANDS           8
+#define ACPI_OBJ_MAX_OPERAND            7
+
+/* Names within the namespace are 4 bytes long */
+
+#define ACPI_NAME_SIZE                  4
+#define ACPI_PATH_SEGMENT_LENGTH        5           /* 4 chars for name + 1 char for separator */
+#define ACPI_PATH_SEPARATOR             '.'
+
+/* Constants used in searching for the RSDP in low memory */
+
+#define ACPI_LO_RSDP_WINDOW_BASE        0           /* Physical Address */
+#define ACPI_HI_RSDP_WINDOW_BASE        0xE0000     /* Physical Address */
+#define ACPI_LO_RSDP_WINDOW_SIZE        0x400
+#define ACPI_HI_RSDP_WINDOW_SIZE        0x20000
+#define ACPI_RSDP_SCAN_STEP             16
+
+/* Operation regions */
+
+#define ACPI_NUM_PREDEFINED_REGIONS     8
+#define ACPI_USER_REGION_BEGIN          0x80
+
+/* Maximum space_ids for Operation Regions */
+
+#define ACPI_MAX_ADDRESS_SPACE          255
+
+/* Array sizes.  Used for range checking also */
+
+#define ACPI_NUM_ACCESS_TYPES           6
+#define ACPI_NUM_UPDATE_RULES           3
+#define ACPI_NUM_LOCK_RULES             2
+#define ACPI_NUM_MATCH_OPS              6
+#define ACPI_NUM_OPCODES                256
+#define ACPI_NUM_FIELD_NAMES            2
+
+/* RSDP checksums */
+
+#define ACPI_RSDP_CHECKSUM_LENGTH       20
+#define ACPI_RSDP_XCHECKSUM_LENGTH      36
+
+/* SMBus bidirectional buffer size */
+
+#define ACPI_SMBUS_BUFFER_SIZE          34
+
+
+/******************************************************************************
+ *
+ * ACPI AML Debugger
+ *
+ *****************************************************************************/
+
+#define ACPI_DEBUGGER_MAX_ARGS          8  /* Must be max method args + 1 */
+
+#define ACPI_DEBUGGER_COMMAND_PROMPT    '-'
+#define ACPI_DEBUGGER_EXECUTE_PROMPT    '%'
+
+
+#endif /* _ACCONFIG_H */
+
diff -urNp linux-5400/include/acpi/acdebug.h linux-5410/include/acpi/acdebug.h
--- linux-5400/include/acpi/acdebug.h
+++ linux-5410/include/acpi/acdebug.h
@@ -0,0 +1,469 @@
+/******************************************************************************
+ *
+ * Name: acdebug.h - ACPI/AML debugger
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACDEBUG_H__
+#define __ACDEBUG_H__
+
+
+#define ACPI_DEBUG_BUFFER_SIZE  4196
+
+struct command_info
+{
+	char                            *name;          /* Command Name */
+	u8                              min_args;       /* Minimum arguments required */
+};
+
+
+struct argument_info
+{
+	char                            *name;          /* Argument Name */
+};
+
+
+#define PARAM_LIST(pl)                  pl
+
+#define DBTEST_OUTPUT_LEVEL(lvl)        if (acpi_gbl_db_opt_verbose)
+
+#define VERBOSE_PRINT(fp)               DBTEST_OUTPUT_LEVEL(lvl) {\
+			  acpi_os_printf PARAM_LIST(fp);}
+
+#define EX_NO_SINGLE_STEP               1
+#define EX_SINGLE_STEP                  2
+
+
+/* Prototypes */
+
+
+/*
+ * dbxface - external debugger interfaces
+ */
+
+acpi_status
+acpi_db_initialize (
+	void);
+
+void
+acpi_db_terminate (
+	void);
+
+acpi_status
+acpi_db_single_step (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op,
+	u32                             op_type);
+
+acpi_status
+acpi_db_start_command (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op);
+
+void
+acpi_db_method_end (
+	struct acpi_walk_state          *walk_state);
+
+
+/*
+ * dbcmds - debug commands and output routines
+ */
+
+void
+acpi_db_display_table_info (
+	char                            *table_arg);
+
+void
+acpi_db_unload_acpi_table (
+	char                            *table_arg,
+	char                            *instance_arg);
+
+void
+acpi_db_set_method_breakpoint (
+	char                            *location,
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op);
+
+void
+acpi_db_set_method_call_breakpoint (
+	union acpi_parse_object         *op);
+
+void
+acpi_db_disassemble_aml (
+	char                            *statements,
+	union acpi_parse_object         *op);
+
+void
+acpi_db_dump_namespace (
+	char                            *start_arg,
+	char                            *depth_arg);
+
+void
+acpi_db_dump_namespace_by_owner (
+	char                            *owner_arg,
+	char                            *depth_arg);
+
+void
+acpi_db_send_notify (
+	char                            *name,
+	u32                             value);
+
+void
+acpi_db_set_method_data (
+	char                            *type_arg,
+	char                            *index_arg,
+	char                            *value_arg);
+
+acpi_status
+acpi_db_display_objects (
+	char                            *obj_type_arg,
+	char                            *display_count_arg);
+
+acpi_status
+acpi_db_find_name_in_namespace (
+	char                            *name_arg);
+
+void
+acpi_db_set_scope (
+	char                            *name);
+
+void
+acpi_db_find_references (
+	char                            *object_arg);
+
+void
+acpi_db_display_locks (void);
+
+
+void
+acpi_db_display_resources (
+	char                            *object_arg);
+
+void
+acpi_db_display_gpes (void);
+
+void
+acpi_db_check_integrity (
+	void);
+
+acpi_status
+acpi_db_integrity_walk (
+	acpi_handle                     obj_handle,
+	u32                             nesting_level,
+	void                            *context,
+	void                            **return_value);
+
+acpi_status
+acpi_db_walk_and_match_name (
+	acpi_handle                     obj_handle,
+	u32                             nesting_level,
+	void                            *context,
+	void                            **return_value);
+
+acpi_status
+acpi_db_walk_for_references (
+	acpi_handle                     obj_handle,
+	u32                             nesting_level,
+	void                            *context,
+	void                            **return_value);
+
+acpi_status
+acpi_db_walk_for_specific_objects (
+	acpi_handle                     obj_handle,
+	u32                             nesting_level,
+	void                            *context,
+	void                            **return_value);
+
+void
+acpi_db_generate_gpe (
+	char                            *gpe_arg,
+	char                            *block_arg);
+
+/*
+ * dbdisply - debug display commands
+ */
+
+void
+acpi_db_display_method_info (
+	union acpi_parse_object         *op);
+
+void
+acpi_db_decode_and_display_object (
+	char                            *target,
+	char                            *output_type);
+
+void
+acpi_db_display_result_object (
+	union acpi_operand_object       *obj_desc,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_db_display_all_methods (
+	char                            *display_count_arg);
+
+void
+acpi_db_display_arguments (
+	void);
+
+void
+acpi_db_display_locals (
+	void);
+
+void
+acpi_db_display_results (
+	void);
+
+void
+acpi_db_display_calling_tree (
+	void);
+
+void
+acpi_db_display_object_type (
+	char                            *object_arg);
+
+void
+acpi_db_display_argument_object (
+	union acpi_operand_object       *obj_desc,
+	struct acpi_walk_state          *walk_state);
+
+void
+acpi_db_dump_parser_descriptor (
+	union acpi_parse_object         *op);
+
+void *
+acpi_db_get_pointer (
+	void                            *target);
+
+
+/*
+ * dbexec - debugger control method execution
+ */
+
+void
+acpi_db_execute (
+	char                            *name,
+	char                            **args,
+	u32                             flags);
+
+void
+acpi_db_create_execution_threads (
+	char                            *num_threads_arg,
+	char                            *num_loops_arg,
+	char                            *method_name_arg);
+
+acpi_status
+acpi_db_execute_method (
+	struct acpi_db_method_info      *info,
+	struct acpi_buffer              *return_obj);
+
+void
+acpi_db_execute_setup (
+	struct acpi_db_method_info      *info);
+
+u32
+acpi_db_get_outstanding_allocations (
+	void);
+
+void ACPI_SYSTEM_XFACE
+acpi_db_method_thread (
+	void                            *context);
+
+acpi_status
+acpi_db_execution_walk (
+	acpi_handle                     obj_handle,
+	u32                             nesting_level,
+	void                            *context,
+	void                            **return_value);
+
+
+/*
+ * dbfileio - Debugger file I/O commands
+ */
+
+acpi_object_type
+acpi_db_match_argument (
+	char                            *user_argument,
+	struct argument_info            *arguments);
+
+acpi_status
+ae_local_load_table (
+	struct acpi_table_header        *table_ptr);
+
+void
+acpi_db_close_debug_file (
+	void);
+
+void
+acpi_db_open_debug_file (
+	char                            *name);
+
+acpi_status
+acpi_db_load_acpi_table (
+	char                            *filename);
+
+acpi_status
+acpi_db_get_table_from_file (
+	char                            *filename,
+	struct acpi_table_header        **table);
+
+acpi_status
+acpi_db_read_table_from_file (
+	char                            *filename,
+	struct acpi_table_header        **table);
+
+/*
+ * dbhistry - debugger HISTORY command
+ */
+
+void
+acpi_db_add_to_history (
+	char                            *command_line);
+
+void
+acpi_db_display_history (void);
+
+char *
+acpi_db_get_from_history (
+	char                            *command_num_arg);
+
+
+/*
+ * dbinput - user front-end to the AML debugger
+ */
+
+acpi_status
+acpi_db_command_dispatch (
+	char                            *input_buffer,
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op);
+
+void ACPI_SYSTEM_XFACE
+acpi_db_execute_thread (
+	void                            *context);
+
+acpi_status
+acpi_db_user_commands (
+	char                            prompt,
+	union acpi_parse_object         *op);
+
+void
+acpi_db_display_help (
+	char                            *help_type);
+
+char *
+acpi_db_get_next_token (
+	char                            *string,
+	char                            **next);
+
+u32
+acpi_db_get_line (
+	char                            *input_buffer);
+
+u32
+acpi_db_match_command (
+	char                            *user_command);
+
+void
+acpi_db_single_thread (
+	void);
+
+
+/*
+ * dbstats - Generation and display of ACPI table statistics
+ */
+
+void
+acpi_db_generate_statistics (
+	union acpi_parse_object         *root,
+	u8                              is_method);
+
+
+acpi_status
+acpi_db_display_statistics (
+	char                            *type_arg);
+
+acpi_status
+acpi_db_classify_one_object (
+	acpi_handle                     obj_handle,
+	u32                             nesting_level,
+	void                            *context,
+	void                            **return_value);
+
+void
+acpi_db_count_namespace_objects (
+	void);
+
+void
+acpi_db_enumerate_object (
+	union acpi_operand_object       *obj_desc);
+
+
+/*
+ * dbutils - AML debugger utilities
+ */
+
+void
+acpi_db_set_output_destination (
+	u32                             where);
+
+void
+acpi_db_dump_buffer (
+	u32                             address);
+
+void
+acpi_db_dump_object (
+	union acpi_object               *obj_desc,
+	u32                             level);
+
+void
+acpi_db_prep_namestring (
+	char                            *name);
+
+
+acpi_status
+acpi_db_second_pass_parse (
+	union acpi_parse_object         *root);
+
+struct acpi_namespace_node *
+acpi_db_local_ns_lookup (
+	char                            *name);
+
+
+#endif  /* __ACDEBUG_H__ */
diff -urNp linux-5400/include/acpi/acdisasm.h linux-5410/include/acpi/acdisasm.h
--- linux-5400/include/acpi/acdisasm.h
+++ linux-5410/include/acpi/acdisasm.h
@@ -0,0 +1,406 @@
+/******************************************************************************
+ *
+ * Name: acdisasm.h - AML disassembler
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACDISASM_H__
+#define __ACDISASM_H__
+
+#include "amlresrc.h"
+
+
+#define BLOCK_NONE              0
+#define BLOCK_PAREN             1
+#define BLOCK_BRACE             2
+#define BLOCK_COMMA_LIST        4
+
+extern const char                       *acpi_gbl_io_decode[2];
+extern const char                       *acpi_gbl_word_decode[4];
+extern const char                       *acpi_gbl_consume_decode[2];
+extern const char                       *acpi_gbl_min_decode[2];
+extern const char                       *acpi_gbl_max_decode[2];
+extern const char                       *acpi_gbl_DECdecode[2];
+extern const char                       *acpi_gbl_RNGdecode[4];
+extern const char                       *acpi_gbl_MEMdecode[4];
+extern const char                       *acpi_gbl_RWdecode[2];
+extern const char                       *acpi_gbl_irq_decode[2];
+extern const char                       *acpi_gbl_HEdecode[2];
+extern const char                       *acpi_gbl_LLdecode[2];
+extern const char                       *acpi_gbl_SHRdecode[2];
+extern const char                       *acpi_gbl_TYPdecode[4];
+extern const char                       *acpi_gbl_BMdecode[2];
+extern const char                       *acpi_gbl_SIZdecode[4];
+extern const char                       *acpi_gbl_lock_rule[ACPI_NUM_LOCK_RULES];
+extern const char                       *acpi_gbl_access_types[ACPI_NUM_ACCESS_TYPES];
+extern const char                       *acpi_gbl_update_rules[ACPI_NUM_UPDATE_RULES];
+extern const char                       *acpi_gbl_match_ops[ACPI_NUM_MATCH_OPS];
+
+
+struct acpi_op_walk_info
+{
+	u32                             level;
+	u32                             bit_offset;
+};
+
+typedef
+acpi_status (*asl_walk_callback) (
+	union acpi_parse_object             *op,
+	u32                                 level,
+	void                                *context);
+
+
+/*
+ * dmwalk
+ */
+
+void
+acpi_dm_walk_parse_tree (
+	union acpi_parse_object         *op,
+	asl_walk_callback               descending_callback,
+	asl_walk_callback               ascending_callback,
+	void                            *context);
+
+acpi_status
+acpi_dm_descending_op (
+	union acpi_parse_object         *op,
+	u32                             level,
+	void                            *context);
+
+acpi_status
+acpi_dm_ascending_op (
+	union acpi_parse_object         *op,
+	u32                             level,
+	void                            *context);
+
+
+/*
+ * dmopcode
+ */
+
+void
+acpi_dm_validate_name (
+	char                            *name,
+	union acpi_parse_object         *op);
+
+u32
+acpi_dm_dump_name (
+	char                            *name);
+
+void
+acpi_dm_unicode (
+	union acpi_parse_object         *op);
+
+void
+acpi_dm_disassemble (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *origin,
+	u32                             num_opcodes);
+
+void
+acpi_dm_namestring (
+	char                            *name);
+
+void
+acpi_dm_display_path (
+	union acpi_parse_object         *op);
+
+void
+acpi_dm_disassemble_one_op (
+	struct acpi_walk_state          *walk_state,
+	struct acpi_op_walk_info        *info,
+	union acpi_parse_object         *op);
+
+void
+acpi_dm_decode_internal_object (
+	union acpi_operand_object       *obj_desc);
+
+void
+acpi_dm_decode_node (
+	struct acpi_namespace_node      *node);
+
+u32
+acpi_dm_block_type (
+	union acpi_parse_object         *op);
+
+u32
+acpi_dm_list_type (
+	union acpi_parse_object         *op);
+
+acpi_status
+acpi_ps_display_object_pathname (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op);
+
+void
+acpi_dm_method_flags (
+	union acpi_parse_object         *op);
+
+void
+acpi_dm_field_flags (
+	union acpi_parse_object         *op);
+
+void
+acpi_dm_address_space (
+	u8                              space_id);
+
+void
+acpi_dm_region_flags (
+	union acpi_parse_object         *op);
+
+void
+acpi_dm_match_op (
+	union acpi_parse_object         *op);
+
+void
+acpi_dm_match_keyword (
+	union acpi_parse_object         *op);
+
+u8
+acpi_dm_comma_if_list_member (
+	union acpi_parse_object         *op);
+
+void
+acpi_dm_comma_if_field_member (
+	union acpi_parse_object         *op);
+
+
+/*
+ * dmobject
+ */
+
+void
+acpi_dm_decode_node (
+	struct acpi_namespace_node      *node);
+
+void
+acpi_dm_display_internal_object (
+	union acpi_operand_object       *obj_desc,
+	struct acpi_walk_state          *walk_state);
+
+void
+acpi_dm_display_arguments (
+	struct acpi_walk_state          *walk_state);
+
+void
+acpi_dm_display_locals (
+	struct acpi_walk_state          *walk_state);
+
+void
+acpi_dm_dump_method_info (
+	acpi_status                     status,
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op);
+
+
+/*
+ * dmbuffer
+ */
+
+void
+acpi_is_eisa_id (
+	union acpi_parse_object         *op);
+
+void
+acpi_dm_eisa_id (
+	u32                             encoded_id);
+
+u8
+acpi_dm_is_unicode_buffer (
+	union acpi_parse_object         *op);
+
+u8
+acpi_dm_is_string_buffer (
+	union acpi_parse_object         *op);
+
+
+/*
+ * dmresrc
+ */
+
+void
+acpi_dm_disasm_byte_list (
+	u32                             level,
+	u8                              *byte_data,
+	u32                             byte_count);
+
+void
+acpi_dm_byte_list (
+	struct acpi_op_walk_info        *info,
+	union acpi_parse_object         *op);
+
+void
+acpi_dm_resource_descriptor (
+	struct acpi_op_walk_info        *info,
+	u8                              *byte_data,
+	u32                             byte_count);
+
+u8
+acpi_dm_is_resource_descriptor (
+	union acpi_parse_object         *op);
+
+void
+acpi_dm_indent (
+	u32                             level);
+
+void
+acpi_dm_bit_list (
+	u16                             mask);
+
+void
+acpi_dm_decode_attribute (
+	u8                              attribute);
+
+/*
+ * dmresrcl
+ */
+
+void
+acpi_dm_io_flags (
+		u8                          flags);
+
+void
+acpi_dm_memory_flags (
+	u8                              flags,
+	u8                              specific_flags);
+
+void
+acpi_dm_word_descriptor (
+	struct asl_word_address_desc    *resource,
+	u32                             length,
+	u32                             level);
+
+void
+acpi_dm_dword_descriptor (
+	struct asl_dword_address_desc   *resource,
+	u32                             length,
+	u32                             level);
+
+void
+acpi_dm_qword_descriptor (
+	struct asl_qword_address_desc   *resource,
+	u32                             length,
+	u32                             level);
+
+void
+acpi_dm_memory24_descriptor (
+	struct asl_memory_24_desc       *resource,
+	u32                             length,
+	u32                             level);
+
+void
+acpi_dm_memory32_descriptor (
+	struct asl_memory_32_desc       *resource,
+	u32                             length,
+	u32                             level);
+
+void
+acpi_dm_fixed_mem32_descriptor (
+	struct asl_fixed_memory_32_desc *resource,
+	u32                             length,
+	u32                             level);
+
+void
+acpi_dm_generic_register_descriptor (
+	struct asl_general_register_desc *resource,
+	u32                             length,
+	u32                             level);
+
+void
+acpi_dm_interrupt_descriptor (
+	struct asl_extended_xrupt_desc *resource,
+	u32                             length,
+	u32                             level);
+
+void
+acpi_dm_vendor_large_descriptor (
+	struct asl_large_vendor_desc    *resource,
+	u32                             length,
+	u32                             level);
+
+
+/*
+ * dmresrcs
+ */
+
+void
+acpi_dm_irq_descriptor (
+	struct asl_irq_format_desc      *resource,
+	u32                             length,
+	u32                             level);
+
+void
+acpi_dm_dma_descriptor (
+	struct asl_dma_format_desc      *resource,
+	u32                             length,
+	u32                             level);
+
+void
+acpi_dm_io_descriptor (
+	struct asl_io_port_desc         *resource,
+	u32                             length,
+	u32                             level);
+
+void
+acpi_dm_fixed_io_descriptor (
+	struct asl_fixed_io_port_desc   *resource,
+	u32                             length,
+	u32                             level);
+
+void
+acpi_dm_start_dependent_descriptor (
+	struct asl_start_dependent_desc *resource,
+	u32                             length,
+	u32                             level);
+
+void
+acpi_dm_end_dependent_descriptor (
+	struct asl_start_dependent_desc *resource,
+	u32                             length,
+	u32                             level);
+
+void
+acpi_dm_vendor_small_descriptor (
+	struct asl_small_vendor_desc    *resource,
+	u32                             length,
+	u32                             level);
+
+
+#endif  /* __ACDISASM_H__ */
diff -urNp linux-5400/include/acpi/acdispat.h linux-5410/include/acpi/acdispat.h
--- linux-5400/include/acpi/acdispat.h
+++ linux-5410/include/acpi/acdispat.h
@@ -0,0 +1,513 @@
+/******************************************************************************
+ *
+ * Name: acdispat.h - dispatcher (parser to interpreter interface)
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+
+#ifndef _ACDISPAT_H_
+#define _ACDISPAT_H_
+
+
+#define NAMEOF_LOCAL_NTE    "__L0"
+#define NAMEOF_ARG_NTE      "__A0"
+
+
+/* Common interfaces */
+
+acpi_status
+acpi_ds_obj_stack_push (
+	void                            *object,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_obj_stack_pop (
+	u32                             pop_count,
+	struct acpi_walk_state          *walk_state);
+
+void *
+acpi_ds_obj_stack_get_value (
+	u32                             index,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_obj_stack_pop_object (
+	union acpi_operand_object       **object,
+	struct acpi_walk_state          *walk_state);
+
+
+/* dsopcode - support for late evaluation */
+
+acpi_status
+acpi_ds_execute_arguments (
+	struct acpi_namespace_node      *node,
+	struct acpi_namespace_node      *scope_node,
+	u32                             aml_length,
+	u8                              *aml_start);
+
+acpi_status
+acpi_ds_get_buffer_field_arguments (
+	union acpi_operand_object       *obj_desc);
+
+acpi_status
+acpi_ds_get_region_arguments (
+	union acpi_operand_object       *rgn_desc);
+
+acpi_status
+acpi_ds_get_buffer_arguments (
+	union acpi_operand_object       *obj_desc);
+
+acpi_status
+acpi_ds_get_package_arguments (
+	union acpi_operand_object       *obj_desc);
+
+acpi_status
+acpi_ds_init_buffer_field (
+	u16                             aml_opcode,
+	union acpi_operand_object       *obj_desc,
+	union acpi_operand_object       *buffer_desc,
+	union acpi_operand_object       *offset_desc,
+	union acpi_operand_object       *length_desc,
+	union acpi_operand_object       *result_desc);
+
+acpi_status
+acpi_ds_eval_buffer_field_operands (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op);
+
+acpi_status
+acpi_ds_eval_region_operands (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op);
+
+acpi_status
+acpi_ds_eval_data_object_operands (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op,
+	union acpi_operand_object       *obj_desc);
+
+acpi_status
+acpi_ds_initialize_region (
+	acpi_handle                     obj_handle);
+
+
+/* dsctrl - Parser/Interpreter interface, control stack routines */
+
+
+acpi_status
+acpi_ds_exec_begin_control_op (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op);
+
+acpi_status
+acpi_ds_exec_end_control_op (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op);
+
+
+/* dsexec - Parser/Interpreter interface, method execution callbacks */
+
+
+acpi_status
+acpi_ds_get_predicate_value (
+	struct acpi_walk_state          *walk_state,
+	union acpi_operand_object       *result_obj);
+
+acpi_status
+acpi_ds_exec_begin_op (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         **out_op);
+
+acpi_status
+acpi_ds_exec_end_op (
+	struct acpi_walk_state          *state);
+
+
+/* dsfield - Parser/Interpreter interface for AML fields */
+
+acpi_status
+acpi_ds_get_field_names (
+	struct acpi_create_field_info   *info,
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *arg);
+
+acpi_status
+acpi_ds_create_field (
+	union acpi_parse_object         *op,
+	struct acpi_namespace_node      *region_node,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_create_bank_field (
+	union acpi_parse_object         *op,
+	struct acpi_namespace_node      *region_node,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_create_index_field (
+	union acpi_parse_object         *op,
+	struct acpi_namespace_node      *region_node,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_create_buffer_field (
+	union acpi_parse_object         *op,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_init_field_objects (
+	union acpi_parse_object         *op,
+	struct acpi_walk_state          *walk_state);
+
+
+/* dsload - Parser/Interpreter interface, namespace load callbacks */
+
+acpi_status
+acpi_ds_load1_begin_op (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         **out_op);
+
+acpi_status
+acpi_ds_load1_end_op (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_load2_begin_op (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         **out_op);
+
+acpi_status
+acpi_ds_load2_end_op (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_init_callbacks (
+	struct acpi_walk_state          *walk_state,
+	u32                             pass_number);
+
+
+/* dsmthdat - method data (locals/args) */
+
+
+acpi_status
+acpi_ds_store_object_to_local (
+	u16                             opcode,
+	u32                             index,
+	union acpi_operand_object       *src_desc,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_method_data_get_entry (
+	u16                             opcode,
+	u32                             index,
+	struct acpi_walk_state          *walk_state,
+	union acpi_operand_object       ***node);
+
+void
+acpi_ds_method_data_delete_all (
+	struct acpi_walk_state          *walk_state);
+
+u8
+acpi_ds_is_method_value (
+	union acpi_operand_object       *obj_desc);
+
+acpi_object_type
+acpi_ds_method_data_get_type (
+	u16                             opcode,
+	u32                             index,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_method_data_get_value (
+	u16                             opcode,
+	u32                             index,
+	struct acpi_walk_state          *walk_state,
+	union acpi_operand_object       **dest_desc);
+
+void
+acpi_ds_method_data_delete_value (
+	u16                             opcode,
+	u32                             index,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_method_data_init_args (
+	union acpi_operand_object       **params,
+	u32                             max_param_count,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_method_data_get_node (
+	u16                             opcode,
+	u32                             index,
+	struct acpi_walk_state          *walk_state,
+	struct acpi_namespace_node      **node);
+
+void
+acpi_ds_method_data_init (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_method_data_set_value (
+	u16                             opcode,
+	u32                             index,
+	union acpi_operand_object       *object,
+	struct acpi_walk_state          *walk_state);
+
+
+/* dsmethod - Parser/Interpreter interface - control method parsing */
+
+acpi_status
+acpi_ds_parse_method (
+	acpi_handle                     obj_handle);
+
+acpi_status
+acpi_ds_call_control_method (
+	struct acpi_thread_state        *thread,
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op);
+
+acpi_status
+acpi_ds_restart_control_method (
+	struct acpi_walk_state          *walk_state,
+	union acpi_operand_object       *return_desc);
+
+acpi_status
+acpi_ds_terminate_control_method (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_begin_method_execution (
+	struct acpi_namespace_node      *method_node,
+	union acpi_operand_object       *obj_desc,
+	struct acpi_namespace_node      *calling_method_node);
+
+
+/* dsobj - Parser/Interpreter interface - object initialization and conversion */
+
+acpi_status
+acpi_ds_init_one_object (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *context,
+	void                            **return_value);
+
+acpi_status
+acpi_ds_initialize_objects (
+	struct acpi_table_desc          *table_desc,
+	struct acpi_namespace_node      *start_node);
+
+acpi_status
+acpi_ds_build_internal_buffer_obj (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op,
+	u32                             buffer_length,
+	union acpi_operand_object       **obj_desc_ptr);
+
+acpi_status
+acpi_ds_build_internal_package_obj (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op,
+	u32                             package_length,
+	union acpi_operand_object       **obj_desc);
+
+acpi_status
+acpi_ds_build_internal_object (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op,
+	union acpi_operand_object       **obj_desc_ptr);
+
+acpi_status
+acpi_ds_init_object_from_op (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op,
+	u16                             opcode,
+	union acpi_operand_object       **obj_desc);
+
+acpi_status
+acpi_ds_create_node (
+	struct acpi_walk_state          *walk_state,
+	struct acpi_namespace_node      *node,
+	union acpi_parse_object         *op);
+
+
+/* dsutils - Parser/Interpreter interface utility routines */
+
+u8
+acpi_ds_is_result_used (
+	union acpi_parse_object         *op,
+	struct acpi_walk_state          *walk_state);
+
+void
+acpi_ds_delete_result_if_not_used (
+	union acpi_parse_object         *op,
+	union acpi_operand_object       *result_obj,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_create_operand (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *arg,
+	u32                             args_remaining);
+
+acpi_status
+acpi_ds_create_operands (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *first_arg);
+
+acpi_status
+acpi_ds_resolve_operands (
+	struct acpi_walk_state          *walk_state);
+
+void
+acpi_ds_clear_operands (
+	struct acpi_walk_state          *walk_state);
+
+
+/*
+ * dswscope - Scope Stack manipulation
+ */
+
+acpi_status
+acpi_ds_scope_stack_push (
+	struct acpi_namespace_node      *node,
+	acpi_object_type                type,
+	struct acpi_walk_state          *walk_state);
+
+
+acpi_status
+acpi_ds_scope_stack_pop (
+	struct acpi_walk_state          *walk_state);
+
+void
+acpi_ds_scope_stack_clear (
+	struct acpi_walk_state          *walk_state);
+
+
+/* dswstate - parser WALK_STATE management routines */
+
+struct acpi_walk_state *
+acpi_ds_create_walk_state (
+	acpi_owner_id                   owner_id,
+	union acpi_parse_object         *origin,
+	union acpi_operand_object       *mth_desc,
+	struct acpi_thread_state        *thread);
+
+acpi_status
+acpi_ds_init_aml_walk (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op,
+	struct acpi_namespace_node      *method_node,
+	u8                              *aml_start,
+	u32                             aml_length,
+	union acpi_operand_object       **params,
+	union acpi_operand_object       **return_obj_desc,
+	u32                             pass_number);
+
+acpi_status
+acpi_ds_obj_stack_delete_all (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_obj_stack_pop_and_delete (
+	u32                             pop_count,
+	struct acpi_walk_state          *walk_state);
+
+void
+acpi_ds_delete_walk_state (
+	struct acpi_walk_state          *walk_state);
+
+struct acpi_walk_state *
+acpi_ds_pop_walk_state (
+	struct acpi_thread_state        *thread);
+
+void
+acpi_ds_push_walk_state (
+	struct acpi_walk_state          *walk_state,
+	struct acpi_thread_state        *thread);
+
+acpi_status
+acpi_ds_result_stack_pop (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_result_stack_push (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_result_stack_clear (
+	struct acpi_walk_state          *walk_state);
+
+struct acpi_walk_state *
+acpi_ds_get_current_walk_state (
+	struct acpi_thread_state        *thread);
+
+void
+acpi_ds_delete_walk_state_cache (
+	void);
+
+acpi_status
+acpi_ds_result_insert (
+	void                            *object,
+	u32                             index,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_result_remove (
+	union acpi_operand_object       **object,
+	u32                             index,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_result_pop (
+	union acpi_operand_object       **object,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_result_push (
+	union acpi_operand_object       *object,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ds_result_pop_from_bottom (
+	union acpi_operand_object       **object,
+	struct acpi_walk_state          *walk_state);
+
+#endif /* _ACDISPAT_H_ */
diff -urNp linux-5400/include/acpi/acevents.h linux-5410/include/acpi/acevents.h
--- linux-5400/include/acpi/acevents.h
+++ linux-5410/include/acpi/acevents.h
@@ -0,0 +1,263 @@
+/******************************************************************************
+ *
+ * Name: acevents.h - Event subcomponent prototypes and defines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACEVENTS_H__
+#define __ACEVENTS_H__
+
+
+acpi_status
+acpi_ev_initialize (
+	void);
+
+acpi_status
+acpi_ev_handler_initialize (
+	void);
+
+
+/*
+ * Evfixed - Fixed event handling
+ */
+
+acpi_status
+acpi_ev_fixed_event_initialize (
+	void);
+
+u32
+acpi_ev_fixed_event_detect (
+	void);
+
+u32
+acpi_ev_fixed_event_dispatch (
+	u32                             event);
+
+
+/*
+ * Evmisc
+ */
+
+u8
+acpi_ev_is_notify_object (
+	struct acpi_namespace_node      *node);
+
+acpi_status
+acpi_ev_acquire_global_lock(
+	u16                             timeout);
+
+acpi_status
+acpi_ev_release_global_lock(
+	void);
+
+acpi_status
+acpi_ev_init_global_lock_handler (
+	void);
+
+u32
+acpi_ev_get_gpe_number_index (
+	u32                             gpe_number);
+
+acpi_status
+acpi_ev_queue_notify_request (
+	struct acpi_namespace_node      *node,
+	u32                             notify_value);
+
+void ACPI_SYSTEM_XFACE
+acpi_ev_notify_dispatch (
+	void                            *context);
+
+
+/*
+ * Evgpe - GPE handling and dispatch
+ */
+
+acpi_status
+acpi_ev_walk_gpe_list (
+	ACPI_GPE_CALLBACK       gpe_walk_callback);
+
+u8
+acpi_ev_valid_gpe_event (
+	struct acpi_gpe_event_info      *gpe_event_info);
+
+struct acpi_gpe_event_info *
+acpi_ev_get_gpe_event_info (
+	acpi_handle                     gpe_device,
+	u32                             gpe_number);
+
+acpi_status
+acpi_ev_gpe_initialize (
+	void);
+
+acpi_status
+acpi_ev_create_gpe_block (
+	struct acpi_namespace_node      *gpe_device,
+	struct acpi_generic_address     *gpe_block_address,
+	u32                             register_count,
+	u8                              gpe_block_base_number,
+	u32                             interrupt_level,
+	struct acpi_gpe_block_info      **return_gpe_block);
+
+acpi_status
+acpi_ev_delete_gpe_block (
+	struct acpi_gpe_block_info      *gpe_block);
+
+u32
+acpi_ev_gpe_dispatch (
+	struct acpi_gpe_event_info      *gpe_event_info,
+	u32                             gpe_number);
+
+u32
+acpi_ev_gpe_detect (
+	struct acpi_gpe_xrupt_info      *gpe_xrupt_list);
+
+/*
+ * Evregion - Address Space handling
+ */
+
+acpi_status
+acpi_ev_init_address_spaces (
+	void);
+
+acpi_status
+acpi_ev_address_space_dispatch (
+	union acpi_operand_object      *region_obj,
+	u32                             function,
+	acpi_physical_address           address,
+	u32                             bit_width,
+	void                            *value);
+
+acpi_status
+acpi_ev_install_handler (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *context,
+	void                            **return_value);
+
+acpi_status
+acpi_ev_attach_region (
+	union acpi_operand_object       *handler_obj,
+	union acpi_operand_object       *region_obj,
+	u8                              acpi_ns_is_locked);
+
+void
+acpi_ev_detach_region (
+	union acpi_operand_object      *region_obj,
+	u8                              acpi_ns_is_locked);
+
+
+/*
+ * Evregini - Region initialization and setup
+ */
+
+acpi_status
+acpi_ev_system_memory_region_setup (
+	acpi_handle                     handle,
+	u32                             function,
+	void                            *handler_context,
+	void                            **region_context);
+
+acpi_status
+acpi_ev_io_space_region_setup (
+	acpi_handle                     handle,
+	u32                             function,
+	void                            *handler_context,
+	void                            **region_context);
+
+acpi_status
+acpi_ev_pci_config_region_setup (
+	acpi_handle                     handle,
+	u32                             function,
+	void                            *handler_context,
+	void                            **region_context);
+
+acpi_status
+acpi_ev_cmos_region_setup (
+	acpi_handle                     handle,
+	u32                             function,
+	void                            *handler_context,
+	void                            **region_context);
+
+acpi_status
+acpi_ev_pci_bar_region_setup (
+	acpi_handle                     handle,
+	u32                             function,
+	void                            *handler_context,
+	void                            **region_context);
+
+acpi_status
+acpi_ev_default_region_setup (
+	acpi_handle                     handle,
+	u32                             function,
+	void                            *handler_context,
+	void                            **region_context);
+
+acpi_status
+acpi_ev_initialize_region (
+	union acpi_operand_object       *region_obj,
+	u8                              acpi_ns_locked);
+
+
+/*
+ * Evsci - SCI (System Control Interrupt) handling/dispatch
+ */
+
+u32 ACPI_SYSTEM_XFACE
+acpi_ev_gpe_xrupt_handler (
+	void                            *context);
+
+u32
+acpi_ev_install_sci_handler (
+	void);
+
+acpi_status
+acpi_ev_remove_sci_handler (
+	void);
+
+u32
+acpi_ev_initialize_sCI (
+	u32                             program_sCI);
+
+void
+acpi_ev_terminate (
+	void);
+
+
+#endif  /* __ACEVENTS_H__  */
diff -urNp linux-5400/include/acpi/acexcep.h linux-5410/include/acpi/acexcep.h
--- linux-5400/include/acpi/acexcep.h
+++ linux-5410/include/acpi/acexcep.h
@@ -0,0 +1,304 @@
+/******************************************************************************
+ *
+ * Name: acexcep.h - Exception codes returned by the ACPI subsystem
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACEXCEP_H__
+#define __ACEXCEP_H__
+
+
+/*
+ * Exceptions returned by external ACPI interfaces
+ */
+
+#define AE_CODE_ENVIRONMENTAL           0x0000
+#define AE_CODE_PROGRAMMER              0x1000
+#define AE_CODE_ACPI_TABLES             0x2000
+#define AE_CODE_AML                     0x3000
+#define AE_CODE_CONTROL                 0x4000
+#define AE_CODE_MASK                    0xF000
+
+
+#define ACPI_SUCCESS(a)                 (!(a))
+#define ACPI_FAILURE(a)                 (a)
+
+
+#define AE_OK                           (acpi_status) 0x0000
+
+/*
+ * Environmental exceptions
+ */
+#define AE_ERROR                        (acpi_status) (0x0001 | AE_CODE_ENVIRONMENTAL)
+#define AE_NO_ACPI_TABLES               (acpi_status) (0x0002 | AE_CODE_ENVIRONMENTAL)
+#define AE_NO_NAMESPACE                 (acpi_status) (0x0003 | AE_CODE_ENVIRONMENTAL)
+#define AE_NO_MEMORY                    (acpi_status) (0x0004 | AE_CODE_ENVIRONMENTAL)
+#define AE_NOT_FOUND                    (acpi_status) (0x0005 | AE_CODE_ENVIRONMENTAL)
+#define AE_NOT_EXIST                    (acpi_status) (0x0006 | AE_CODE_ENVIRONMENTAL)
+#define AE_ALREADY_EXISTS               (acpi_status) (0x0007 | AE_CODE_ENVIRONMENTAL)
+#define AE_TYPE                         (acpi_status) (0x0008 | AE_CODE_ENVIRONMENTAL)
+#define AE_NULL_OBJECT                  (acpi_status) (0x0009 | AE_CODE_ENVIRONMENTAL)
+#define AE_NULL_ENTRY                   (acpi_status) (0x000A | AE_CODE_ENVIRONMENTAL)
+#define AE_BUFFER_OVERFLOW              (acpi_status) (0x000B | AE_CODE_ENVIRONMENTAL)
+#define AE_STACK_OVERFLOW               (acpi_status) (0x000C | AE_CODE_ENVIRONMENTAL)
+#define AE_STACK_UNDERFLOW              (acpi_status) (0x000D | AE_CODE_ENVIRONMENTAL)
+#define AE_NOT_IMPLEMENTED              (acpi_status) (0x000E | AE_CODE_ENVIRONMENTAL)
+#define AE_VERSION_MISMATCH             (acpi_status) (0x000F | AE_CODE_ENVIRONMENTAL)
+#define AE_SUPPORT                      (acpi_status) (0x0010 | AE_CODE_ENVIRONMENTAL)
+#define AE_SHARE                        (acpi_status) (0x0011 | AE_CODE_ENVIRONMENTAL)
+#define AE_LIMIT                        (acpi_status) (0x0012 | AE_CODE_ENVIRONMENTAL)
+#define AE_TIME                         (acpi_status) (0x0013 | AE_CODE_ENVIRONMENTAL)
+#define AE_UNKNOWN_STATUS               (acpi_status) (0x0014 | AE_CODE_ENVIRONMENTAL)
+#define AE_ACQUIRE_DEADLOCK             (acpi_status) (0x0015 | AE_CODE_ENVIRONMENTAL)
+#define AE_RELEASE_DEADLOCK             (acpi_status) (0x0016 | AE_CODE_ENVIRONMENTAL)
+#define AE_NOT_ACQUIRED                 (acpi_status) (0x0017 | AE_CODE_ENVIRONMENTAL)
+#define AE_ALREADY_ACQUIRED             (acpi_status) (0x0018 | AE_CODE_ENVIRONMENTAL)
+#define AE_NO_HARDWARE_RESPONSE         (acpi_status) (0x0019 | AE_CODE_ENVIRONMENTAL)
+#define AE_NO_GLOBAL_LOCK               (acpi_status) (0x001A | AE_CODE_ENVIRONMENTAL)
+#define AE_LOGICAL_ADDRESS              (acpi_status) (0x001B | AE_CODE_ENVIRONMENTAL)
+#define AE_ABORT_METHOD                 (acpi_status) (0x001C | AE_CODE_ENVIRONMENTAL)
+#define AE_SAME_HANDLER                 (acpi_status) (0x001D | AE_CODE_ENVIRONMENTAL)
+
+#define AE_CODE_ENV_MAX                 0x001D
+
+/*
+ * Programmer exceptions
+ */
+#define AE_BAD_PARAMETER                (acpi_status) (0x0001 | AE_CODE_PROGRAMMER)
+#define AE_BAD_CHARACTER                (acpi_status) (0x0002 | AE_CODE_PROGRAMMER)
+#define AE_BAD_PATHNAME                 (acpi_status) (0x0003 | AE_CODE_PROGRAMMER)
+#define AE_BAD_DATA                     (acpi_status) (0x0004 | AE_CODE_PROGRAMMER)
+#define AE_BAD_ADDRESS                  (acpi_status) (0x0005 | AE_CODE_PROGRAMMER)
+#define AE_ALIGNMENT                    (acpi_status) (0x0006 | AE_CODE_PROGRAMMER)
+#define AE_BAD_HEX_CONSTANT             (acpi_status) (0x0007 | AE_CODE_PROGRAMMER)
+#define AE_BAD_OCTAL_CONSTANT           (acpi_status) (0x0008 | AE_CODE_PROGRAMMER)
+#define AE_BAD_DECIMAL_CONSTANT         (acpi_status) (0x0009 | AE_CODE_PROGRAMMER)
+
+#define AE_CODE_PGM_MAX                 0x0009
+
+
+/*
+ * Acpi table exceptions
+ */
+#define AE_BAD_SIGNATURE                (acpi_status) (0x0001 | AE_CODE_ACPI_TABLES)
+#define AE_BAD_HEADER                   (acpi_status) (0x0002 | AE_CODE_ACPI_TABLES)
+#define AE_BAD_CHECKSUM                 (acpi_status) (0x0003 | AE_CODE_ACPI_TABLES)
+#define AE_BAD_VALUE                    (acpi_status) (0x0004 | AE_CODE_ACPI_TABLES)
+#define AE_TABLE_NOT_SUPPORTED          (acpi_status) (0x0005 | AE_CODE_ACPI_TABLES)
+#define AE_INVALID_TABLE_LENGTH         (acpi_status) (0x0006 | AE_CODE_ACPI_TABLES)
+
+#define AE_CODE_TBL_MAX                 0x0006
+
+
+/*
+ * AML exceptions.  These are caused by problems with
+ * the actual AML byte stream
+ */
+#define AE_AML_ERROR                    (acpi_status) (0x0001 | AE_CODE_AML)
+#define AE_AML_PARSE                    (acpi_status) (0x0002 | AE_CODE_AML)
+#define AE_AML_BAD_OPCODE               (acpi_status) (0x0003 | AE_CODE_AML)
+#define AE_AML_NO_OPERAND               (acpi_status) (0x0004 | AE_CODE_AML)
+#define AE_AML_OPERAND_TYPE             (acpi_status) (0x0005 | AE_CODE_AML)
+#define AE_AML_OPERAND_VALUE            (acpi_status) (0x0006 | AE_CODE_AML)
+#define AE_AML_UNINITIALIZED_LOCAL      (acpi_status) (0x0007 | AE_CODE_AML)
+#define AE_AML_UNINITIALIZED_ARG        (acpi_status) (0x0008 | AE_CODE_AML)
+#define AE_AML_UNINITIALIZED_ELEMENT    (acpi_status) (0x0009 | AE_CODE_AML)
+#define AE_AML_NUMERIC_OVERFLOW         (acpi_status) (0x000A | AE_CODE_AML)
+#define AE_AML_REGION_LIMIT             (acpi_status) (0x000B | AE_CODE_AML)
+#define AE_AML_BUFFER_LIMIT             (acpi_status) (0x000C | AE_CODE_AML)
+#define AE_AML_PACKAGE_LIMIT            (acpi_status) (0x000D | AE_CODE_AML)
+#define AE_AML_DIVIDE_BY_ZERO           (acpi_status) (0x000E | AE_CODE_AML)
+#define AE_AML_BAD_NAME                 (acpi_status) (0x000F | AE_CODE_AML)
+#define AE_AML_NAME_NOT_FOUND           (acpi_status) (0x0010 | AE_CODE_AML)
+#define AE_AML_INTERNAL                 (acpi_status) (0x0011 | AE_CODE_AML)
+#define AE_AML_INVALID_SPACE_ID         (acpi_status) (0x0012 | AE_CODE_AML)
+#define AE_AML_STRING_LIMIT             (acpi_status) (0x0013 | AE_CODE_AML)
+#define AE_AML_NO_RETURN_VALUE          (acpi_status) (0x0014 | AE_CODE_AML)
+#define AE_AML_METHOD_LIMIT             (acpi_status) (0x0015 | AE_CODE_AML)
+#define AE_AML_NOT_OWNER                (acpi_status) (0x0016 | AE_CODE_AML)
+#define AE_AML_MUTEX_ORDER              (acpi_status) (0x0017 | AE_CODE_AML)
+#define AE_AML_MUTEX_NOT_ACQUIRED       (acpi_status) (0x0018 | AE_CODE_AML)
+#define AE_AML_INVALID_RESOURCE_TYPE    (acpi_status) (0x0019 | AE_CODE_AML)
+#define AE_AML_INVALID_INDEX            (acpi_status) (0x001A | AE_CODE_AML)
+#define AE_AML_REGISTER_LIMIT           (acpi_status) (0x001B | AE_CODE_AML)
+#define AE_AML_NO_WHILE                 (acpi_status) (0x001C | AE_CODE_AML)
+#define AE_AML_ALIGNMENT                (acpi_status) (0x001D | AE_CODE_AML)
+#define AE_AML_NO_RESOURCE_END_TAG      (acpi_status) (0x001E | AE_CODE_AML)
+#define AE_AML_BAD_RESOURCE_VALUE       (acpi_status) (0x001F | AE_CODE_AML)
+#define AE_AML_CIRCULAR_REFERENCE       (acpi_status) (0x0020 | AE_CODE_AML)
+
+#define AE_CODE_AML_MAX                 0x0020
+
+/*
+ * Internal exceptions used for control
+ */
+#define AE_CTRL_RETURN_VALUE            (acpi_status) (0x0001 | AE_CODE_CONTROL)
+#define AE_CTRL_PENDING                 (acpi_status) (0x0002 | AE_CODE_CONTROL)
+#define AE_CTRL_TERMINATE               (acpi_status) (0x0003 | AE_CODE_CONTROL)
+#define AE_CTRL_TRUE                    (acpi_status) (0x0004 | AE_CODE_CONTROL)
+#define AE_CTRL_FALSE                   (acpi_status) (0x0005 | AE_CODE_CONTROL)
+#define AE_CTRL_DEPTH                   (acpi_status) (0x0006 | AE_CODE_CONTROL)
+#define AE_CTRL_END                     (acpi_status) (0x0007 | AE_CODE_CONTROL)
+#define AE_CTRL_TRANSFER                (acpi_status) (0x0008 | AE_CODE_CONTROL)
+#define AE_CTRL_BREAK                   (acpi_status) (0x0009 | AE_CODE_CONTROL)
+#define AE_CTRL_CONTINUE                (acpi_status) (0x000A | AE_CODE_CONTROL)
+#define AE_CTRL_SKIP                    (acpi_status) (0x000B | AE_CODE_CONTROL)
+
+#define AE_CODE_CTRL_MAX                0x000B
+
+
+#ifdef DEFINE_ACPI_GLOBALS
+
+/*
+ * String versions of the exception codes above
+ * These strings must match the corresponding defines exactly
+ */
+char const   *acpi_gbl_exception_names_env[] =
+{
+	"AE_OK",
+	"AE_ERROR",
+	"AE_NO_ACPI_TABLES",
+	"AE_NO_NAMESPACE",
+	"AE_NO_MEMORY",
+	"AE_NOT_FOUND",
+	"AE_NOT_EXIST",
+	"AE_ALREADY_EXISTS",
+	"AE_TYPE",
+	"AE_NULL_OBJECT",
+	"AE_NULL_ENTRY",
+	"AE_BUFFER_OVERFLOW",
+	"AE_STACK_OVERFLOW",
+	"AE_STACK_UNDERFLOW",
+	"AE_NOT_IMPLEMENTED",
+	"AE_VERSION_MISMATCH",
+	"AE_SUPPORT",
+	"AE_SHARE",
+	"AE_LIMIT",
+	"AE_TIME",
+	"AE_UNKNOWN_STATUS",
+	"AE_ACQUIRE_DEADLOCK",
+	"AE_RELEASE_DEADLOCK",
+	"AE_NOT_ACQUIRED",
+	"AE_ALREADY_ACQUIRED",
+	"AE_NO_HARDWARE_RESPONSE",
+	"AE_NO_GLOBAL_LOCK",
+	"AE_LOGICAL_ADDRESS",
+	"AE_ABORT_METHOD",
+	"AE_SAME_HANDLER"
+};
+
+char const   *acpi_gbl_exception_names_pgm[] =
+{
+	"AE_BAD_PARAMETER",
+	"AE_BAD_CHARACTER",
+	"AE_BAD_PATHNAME",
+	"AE_BAD_DATA",
+	"AE_BAD_ADDRESS",
+	"AE_ALIGNMENT",
+	"AE_BAD_HEX_CONSTANT",
+	"AE_BAD_OCTAL_CONSTANT",
+	"AE_BAD_DECIMAL_CONSTANT"
+};
+
+char const   *acpi_gbl_exception_names_tbl[] =
+{
+	"AE_BAD_SIGNATURE",
+	"AE_BAD_HEADER",
+	"AE_BAD_CHECKSUM",
+	"AE_BAD_VALUE",
+	"AE_TABLE_NOT_SUPPORTED",
+	"AE_INVALID_TABLE_LENGTH"
+};
+
+char const   *acpi_gbl_exception_names_aml[] =
+{
+	"AE_AML_ERROR",
+	"AE_AML_PARSE",
+	"AE_AML_BAD_OPCODE",
+	"AE_AML_NO_OPERAND",
+	"AE_AML_OPERAND_TYPE",
+	"AE_AML_OPERAND_VALUE",
+	"AE_AML_UNINITIALIZED_LOCAL",
+	"AE_AML_UNINITIALIZED_ARG",
+	"AE_AML_UNINITIALIZED_ELEMENT",
+	"AE_AML_NUMERIC_OVERFLOW",
+	"AE_AML_REGION_LIMIT",
+	"AE_AML_BUFFER_LIMIT",
+	"AE_AML_PACKAGE_LIMIT",
+	"AE_AML_DIVIDE_BY_ZERO",
+	"AE_AML_BAD_NAME",
+	"AE_AML_NAME_NOT_FOUND",
+	"AE_AML_INTERNAL",
+	"AE_AML_INVALID_SPACE_ID",
+	"AE_AML_STRING_LIMIT",
+	"AE_AML_NO_RETURN_VALUE",
+	"AE_AML_METHOD_LIMIT",
+	"AE_AML_NOT_OWNER",
+	"AE_AML_MUTEX_ORDER",
+	"AE_AML_MUTEX_NOT_ACQUIRED",
+	"AE_AML_INVALID_RESOURCE_TYPE",
+	"AE_AML_INVALID_INDEX",
+	"AE_AML_REGISTER_LIMIT",
+	"AE_AML_NO_WHILE",
+	"AE_AML_ALIGNMENT",
+	"AE_AML_NO_RESOURCE_END_TAG",
+	"AE_AML_BAD_RESOURCE_VALUE",
+	"AE_AML_CIRCULAR_REFERENCE"
+};
+
+char const   *acpi_gbl_exception_names_ctrl[] =
+{
+	"AE_CTRL_RETURN_VALUE",
+	"AE_CTRL_PENDING",
+	"AE_CTRL_TERMINATE",
+	"AE_CTRL_TRUE",
+	"AE_CTRL_FALSE",
+	"AE_CTRL_DEPTH",
+	"AE_CTRL_END",
+	"AE_CTRL_TRANSFER",
+	"AE_CTRL_BREAK",
+	"AE_CTRL_CONTINUE",
+	"AE_CTRL_SKIP"
+};
+
+#endif /* ACPI GLOBALS */
+
+
+#endif /* __ACEXCEP_H__ */
diff -urNp linux-5400/include/acpi/acglobal.h linux-5410/include/acpi/acglobal.h
--- linux-5400/include/acpi/acglobal.h
+++ linux-5410/include/acpi/acglobal.h
@@ -0,0 +1,307 @@
+/******************************************************************************
+ *
+ * Name: acglobal.h - Declarations for global variables
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACGLOBAL_H__
+#define __ACGLOBAL_H__
+
+
+/*
+ * Ensure that the globals are actually defined only once.
+ *
+ * The use of these defines allows a single list of globals (here) in order
+ * to simplify maintenance of the code.
+ */
+#ifdef DEFINE_ACPI_GLOBALS
+#define ACPI_EXTERN
+#else
+#define ACPI_EXTERN extern
+#endif
+
+
+/*****************************************************************************
+ *
+ * Debug support
+ *
+ ****************************************************************************/
+
+/* Runtime configuration of debug print levels */
+
+extern      u32                                 acpi_dbg_level;
+extern      u32                                 acpi_dbg_layer;
+
+/* Procedure nesting level for debug output */
+
+extern      u32                                 acpi_gbl_nesting_level;
+
+
+/*****************************************************************************
+ *
+ * ACPI Table globals
+ *
+ ****************************************************************************/
+
+/*
+ * Table pointers.
+ * Although these pointers are somewhat redundant with the global acpi_table,
+ * they are convenient because they are typed pointers.
+ *
+ * These tables are single-table only; meaning that there can be at most one
+ * of each in the system.  Each global points to the actual table.
+ *
+ */
+ACPI_EXTERN u32                                 acpi_gbl_table_flags;
+ACPI_EXTERN u32                                 acpi_gbl_rsdt_table_count;
+ACPI_EXTERN struct rsdp_descriptor             *acpi_gbl_RSDP;
+ACPI_EXTERN XSDT_DESCRIPTOR            *acpi_gbl_XSDT;
+ACPI_EXTERN FADT_DESCRIPTOR            *acpi_gbl_FADT;
+ACPI_EXTERN struct acpi_table_header           *acpi_gbl_DSDT;
+ACPI_EXTERN FACS_DESCRIPTOR            *acpi_gbl_FACS;
+ACPI_EXTERN struct acpi_common_facs             acpi_gbl_common_fACS;
+
+/*
+ * Handle both ACPI 1.0 and ACPI 2.0 Integer widths
+ * If we are running a method that exists in a 32-bit ACPI table.
+ * Use only 32 bits of the Integer for conversion.
+ */
+ACPI_EXTERN u8                                  acpi_gbl_integer_bit_width;
+ACPI_EXTERN u8                                  acpi_gbl_integer_byte_width;
+ACPI_EXTERN u8                                  acpi_gbl_integer_nybble_width;
+ACPI_EXTERN struct acpi_generic_address         acpi_gbl_xpm1a_enable;
+ACPI_EXTERN struct acpi_generic_address         acpi_gbl_xpm1b_enable;
+
+/*
+ * Since there may be multiple SSDTs and PSDTS, a single pointer is not
+ * sufficient; Therefore, there isn't one!
+ */
+
+
+/*
+ * ACPI Table info arrays
+ */
+extern      struct acpi_table_list              acpi_gbl_table_lists[NUM_ACPI_TABLE_TYPES];
+extern      struct acpi_table_support           acpi_gbl_table_data[NUM_ACPI_TABLE_TYPES];
+
+/*
+ * Predefined mutex objects.  This array contains the
+ * actual OS mutex handles, indexed by the local ACPI_MUTEX_HANDLEs.
+ * (The table maps local handles to the real OS handles)
+ */
+ACPI_EXTERN struct acpi_mutex_info              acpi_gbl_mutex_info[NUM_MUTEX];
+
+
+/*****************************************************************************
+ *
+ * Miscellaneous globals
+ *
+ ****************************************************************************/
+
+
+ACPI_EXTERN struct acpi_memory_list             acpi_gbl_memory_lists[ACPI_NUM_MEM_LISTS];
+ACPI_EXTERN struct acpi_object_notify_handler   acpi_gbl_device_notify;
+ACPI_EXTERN struct acpi_object_notify_handler   acpi_gbl_system_notify;
+ACPI_EXTERN acpi_init_handler                   acpi_gbl_init_handler;
+ACPI_EXTERN struct acpi_walk_state             *acpi_gbl_breakpoint_walk;
+ACPI_EXTERN acpi_handle                         acpi_gbl_global_lock_semaphore;
+
+ACPI_EXTERN u32                                 acpi_gbl_global_lock_thread_count;
+ACPI_EXTERN u32                                 acpi_gbl_original_mode;
+ACPI_EXTERN u32                                 acpi_gbl_rsdp_original_location;
+ACPI_EXTERN u32                                 acpi_gbl_ns_lookup_count;
+ACPI_EXTERN u32                                 acpi_gbl_ps_find_count;
+ACPI_EXTERN u16                                 acpi_gbl_pm1_enable_register_save;
+ACPI_EXTERN u16                                 acpi_gbl_next_table_owner_id;
+ACPI_EXTERN u16                                 acpi_gbl_next_method_owner_id;
+ACPI_EXTERN u16                                 acpi_gbl_global_lock_handle;
+ACPI_EXTERN u8                                  acpi_gbl_debugger_configuration;
+ACPI_EXTERN u8                                  acpi_gbl_global_lock_acquired;
+ACPI_EXTERN u8                                  acpi_gbl_step_to_next_call;
+ACPI_EXTERN u8                                  acpi_gbl_acpi_hardware_present;
+ACPI_EXTERN u8                                  acpi_gbl_global_lock_present;
+ACPI_EXTERN u8                                  acpi_gbl_events_initialized;
+
+extern u8                                       acpi_gbl_shutdown;
+extern u32                                      acpi_gbl_startup_flags;
+extern const u8                                 acpi_gbl_decode_to8bit[8];
+extern const char                              *acpi_gbl_db_sleep_states[ACPI_S_STATE_COUNT];
+extern const struct acpi_opcode_info            acpi_gbl_aml_op_info[AML_NUM_OPCODES];
+extern const char                              *acpi_gbl_region_types[ACPI_NUM_PREDEFINED_REGIONS];
+
+
+/*****************************************************************************
+ *
+ * Namespace globals
+ *
+ ****************************************************************************/
+
+#define NUM_NS_TYPES                    ACPI_TYPE_INVALID+1
+
+#if defined (ACPI_NO_METHOD_EXECUTION) || defined (ACPI_CONSTANT_EVAL_ONLY)
+#define NUM_PREDEFINED_NAMES            10
+#else
+#define NUM_PREDEFINED_NAMES            9
+#endif
+
+ACPI_EXTERN struct acpi_namespace_node          acpi_gbl_root_node_struct;
+ACPI_EXTERN struct acpi_namespace_node         *acpi_gbl_root_node;
+
+extern const u8                                 acpi_gbl_ns_properties[NUM_NS_TYPES];
+extern const struct acpi_predefined_names       acpi_gbl_pre_defined_names [NUM_PREDEFINED_NAMES];
+
+#ifdef ACPI_DEBUG_OUTPUT
+ACPI_EXTERN u32                                 acpi_gbl_current_node_count;
+ACPI_EXTERN u32                                 acpi_gbl_current_node_size;
+ACPI_EXTERN u32                                 acpi_gbl_max_concurrent_node_count;
+ACPI_EXTERN acpi_size                           acpi_gbl_entry_stack_pointer;
+ACPI_EXTERN acpi_size                           acpi_gbl_lowest_stack_pointer;
+ACPI_EXTERN u32                                 acpi_gbl_deepest_nesting;
+#endif
+
+/*****************************************************************************
+ *
+ * Interpreter globals
+ *
+ ****************************************************************************/
+
+
+ACPI_EXTERN struct acpi_thread_state           *acpi_gbl_current_walk_list;
+
+/* Control method single step flag */
+
+ACPI_EXTERN u8                                  acpi_gbl_cm_single_step;
+
+
+/*****************************************************************************
+ *
+ * Parser globals
+ *
+ ****************************************************************************/
+
+ACPI_EXTERN union acpi_parse_object            *acpi_gbl_parsed_namespace_root;
+
+/*****************************************************************************
+ *
+ * Hardware globals
+ *
+ ****************************************************************************/
+
+extern      struct acpi_bit_register_info       acpi_gbl_bit_register_info[ACPI_NUM_BITREG];
+ACPI_EXTERN u8                                  acpi_gbl_sleep_type_a;
+ACPI_EXTERN u8                                  acpi_gbl_sleep_type_b;
+
+
+/*****************************************************************************
+ *
+ * Event and GPE globals
+ *
+ ****************************************************************************/
+
+extern      struct acpi_fixed_event_info        acpi_gbl_fixed_event_info[ACPI_NUM_FIXED_EVENTS];
+ACPI_EXTERN struct acpi_fixed_event_handler     acpi_gbl_fixed_event_handlers[ACPI_NUM_FIXED_EVENTS];
+ACPI_EXTERN struct acpi_gpe_xrupt_info         *acpi_gbl_gpe_xrupt_list_head;
+ACPI_EXTERN struct acpi_gpe_block_info         *acpi_gbl_gpe_fadt_blocks[ACPI_MAX_GPE_BLOCKS];
+ACPI_EXTERN acpi_handle                         acpi_gbl_gpe_lock;
+
+
+/*****************************************************************************
+ *
+ * Debugger globals
+ *
+ ****************************************************************************/
+
+
+ACPI_EXTERN u8                                  acpi_gbl_db_output_flags;
+
+#ifdef ACPI_DISASSEMBLER
+
+ACPI_EXTERN u8                                  acpi_gbl_db_opt_disasm;
+ACPI_EXTERN u8                                  acpi_gbl_db_opt_verbose;
+#endif
+
+
+#ifdef ACPI_DEBUGGER
+
+extern      u8                                  acpi_gbl_method_executing;
+extern      u8                                  acpi_gbl_abort_method;
+extern      u8                                  acpi_gbl_db_terminate_threads;
+
+ACPI_EXTERN int                                 optind;
+ACPI_EXTERN char                               *optarg;
+
+ACPI_EXTERN u8                                  acpi_gbl_db_opt_tables;
+ACPI_EXTERN u8                                  acpi_gbl_db_opt_stats;
+ACPI_EXTERN u8                                  acpi_gbl_db_opt_ini_methods;
+
+
+ACPI_EXTERN char                               *acpi_gbl_db_args[ACPI_DEBUGGER_MAX_ARGS];
+ACPI_EXTERN char                                acpi_gbl_db_line_buf[80];
+ACPI_EXTERN char                                acpi_gbl_db_parsed_buf[80];
+ACPI_EXTERN char                                acpi_gbl_db_scope_buf[40];
+ACPI_EXTERN char                                acpi_gbl_db_debug_filename[40];
+ACPI_EXTERN u8                                  acpi_gbl_db_output_to_file;
+ACPI_EXTERN char                               *acpi_gbl_db_buffer;
+ACPI_EXTERN char                               *acpi_gbl_db_filename;
+ACPI_EXTERN u32                                 acpi_gbl_db_debug_level;
+ACPI_EXTERN u32                                 acpi_gbl_db_console_debug_level;
+ACPI_EXTERN struct acpi_table_header           *acpi_gbl_db_table_ptr;
+ACPI_EXTERN struct acpi_namespace_node         *acpi_gbl_db_scope_node;
+
+/*
+ * Statistic globals
+ */
+ACPI_EXTERN u16                                 acpi_gbl_obj_type_count[ACPI_TYPE_NS_NODE_MAX+1];
+ACPI_EXTERN u16                                 acpi_gbl_node_type_count[ACPI_TYPE_NS_NODE_MAX+1];
+ACPI_EXTERN u16                                 acpi_gbl_obj_type_count_misc;
+ACPI_EXTERN u16                                 acpi_gbl_node_type_count_misc;
+ACPI_EXTERN u32                                 acpi_gbl_num_nodes;
+ACPI_EXTERN u32                                 acpi_gbl_num_objects;
+
+
+ACPI_EXTERN u32                                 acpi_gbl_size_of_parse_tree;
+ACPI_EXTERN u32                                 acpi_gbl_size_of_method_trees;
+ACPI_EXTERN u32                                 acpi_gbl_size_of_node_entries;
+ACPI_EXTERN u32                                 acpi_gbl_size_of_acpi_objects;
+
+#endif /* ACPI_DEBUGGER */
+
+
+#endif /* __ACGLOBAL_H__ */
diff -urNp linux-5400/include/acpi/achware.h linux-5410/include/acpi/achware.h
--- linux-5400/include/acpi/achware.h
+++ linux-5410/include/acpi/achware.h
@@ -0,0 +1,177 @@
+/******************************************************************************
+ *
+ * Name: achware.h -- hardware specific interfaces
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACHWARE_H__
+#define __ACHWARE_H__
+
+
+/* PM Timer ticks per second (HZ) */
+#define PM_TIMER_FREQUENCY  3579545
+
+
+/* Prototypes */
+
+
+acpi_status
+acpi_hw_initialize (
+	void);
+
+acpi_status
+acpi_hw_shutdown (
+	void);
+
+acpi_status
+acpi_hw_initialize_system_info (
+	void);
+
+acpi_status
+acpi_hw_set_mode (
+	u32                             mode);
+
+u32
+acpi_hw_get_mode (
+	void);
+
+u32
+acpi_hw_get_mode_capabilities (
+	void);
+
+/* Register I/O Prototypes */
+
+struct acpi_bit_register_info *
+acpi_hw_get_bit_register_info (
+	u32                             register_id);
+
+acpi_status
+acpi_hw_register_read (
+	u8                              use_lock,
+	u32                             register_id,
+	u32                             *return_value);
+
+acpi_status
+acpi_hw_register_write (
+	u8                              use_lock,
+	u32                             register_id,
+	u32                             value);
+
+acpi_status
+acpi_hw_low_level_read (
+	u32                             width,
+	u32                             *value,
+	struct acpi_generic_address     *reg);
+
+acpi_status
+acpi_hw_low_level_write (
+	u32                             width,
+	u32                             value,
+	struct acpi_generic_address     *reg);
+
+acpi_status
+acpi_hw_clear_acpi_status (
+	u32                             flags);
+
+
+/* GPE support */
+
+acpi_status
+acpi_hw_enable_gpe (
+	struct acpi_gpe_event_info      *gpe_event_info);
+
+void
+acpi_hw_enable_gpe_for_wakeup (
+	struct acpi_gpe_event_info      *gpe_event_info);
+
+acpi_status
+acpi_hw_disable_gpe (
+	struct acpi_gpe_event_info      *gpe_event_info);
+
+acpi_status
+acpi_hw_disable_gpe_block (
+	struct acpi_gpe_xrupt_info      *gpe_xrupt_info,
+	struct acpi_gpe_block_info      *gpe_block);
+
+void
+acpi_hw_disable_gpe_for_wakeup (
+	struct acpi_gpe_event_info      *gpe_event_info);
+
+acpi_status
+acpi_hw_clear_gpe (
+	struct acpi_gpe_event_info      *gpe_event_info);
+
+acpi_status
+acpi_hw_clear_gpe_block (
+	struct acpi_gpe_xrupt_info      *gpe_xrupt_info,
+	struct acpi_gpe_block_info      *gpe_block);
+
+acpi_status
+acpi_hw_get_gpe_status (
+	struct acpi_gpe_event_info      *gpe_event_info,
+	acpi_event_status               *event_status);
+
+acpi_status
+acpi_hw_disable_non_wakeup_gpes (
+	void);
+
+acpi_status
+acpi_hw_enable_non_wakeup_gpes (
+	void);
+
+
+/* ACPI Timer prototypes */
+
+acpi_status
+acpi_get_timer_resolution (
+	u32                             *resolution);
+
+acpi_status
+acpi_get_timer (
+	u32                             *ticks);
+
+acpi_status
+acpi_get_timer_duration (
+	u32                             start_ticks,
+	u32                             end_ticks,
+	u32                             *time_elapsed);
+
+
+#endif /* __ACHWARE_H__ */
diff -urNp linux-5400/include/acpi/acinterp.h linux-5410/include/acpi/acinterp.h
--- linux-5400/include/acpi/acinterp.h
+++ linux-5410/include/acpi/acinterp.h
@@ -0,0 +1,738 @@
+/******************************************************************************
+ *
+ * Name: acinterp.h - Interpreter subcomponent prototypes and defines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACINTERP_H__
+#define __ACINTERP_H__
+
+
+#define ACPI_WALK_OPERANDS       (&(walk_state->operands [walk_state->num_operands -1]))
+
+
+acpi_status
+acpi_ex_resolve_operands (
+	u16                             opcode,
+	union acpi_operand_object       **stack_ptr,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_check_object_type (
+	acpi_object_type                type_needed,
+	acpi_object_type                this_type,
+	void                            *object);
+
+/*
+ * exxface - External interpreter interfaces
+ */
+
+acpi_status
+acpi_ex_load_table (
+	acpi_table_type                 table_id);
+
+acpi_status
+acpi_ex_execute_method (
+	struct acpi_namespace_node      *method_node,
+	union acpi_operand_object       **params,
+	union acpi_operand_object       **return_obj_desc);
+
+
+/*
+ * exconvrt - object conversion
+ */
+
+acpi_status
+acpi_ex_convert_to_integer (
+	union acpi_operand_object       *obj_desc,
+	union acpi_operand_object       **result_desc,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_convert_to_buffer (
+	union acpi_operand_object       *obj_desc,
+	union acpi_operand_object       **result_desc,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_convert_to_string (
+	union acpi_operand_object       *obj_desc,
+	union acpi_operand_object       **result_desc,
+	u32                             base,
+	u32                             max_length,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_convert_to_target_type (
+	acpi_object_type                destination_type,
+	union acpi_operand_object       *source_desc,
+	union acpi_operand_object       **result_desc,
+	struct acpi_walk_state          *walk_state);
+
+u32
+acpi_ex_convert_to_ascii (
+	acpi_integer                    integer,
+	u32                             base,
+	u8                              *string,
+	u8                              max_length);
+
+/*
+ * exfield - ACPI AML (p-code) execution - field manipulation
+ */
+
+acpi_status
+acpi_ex_extract_from_field (
+	union acpi_operand_object       *obj_desc,
+	void                            *buffer,
+	u32                             buffer_length);
+
+acpi_status
+acpi_ex_insert_into_field (
+	union acpi_operand_object       *obj_desc,
+	void                            *buffer,
+	u32                             buffer_length);
+
+acpi_status
+acpi_ex_setup_region (
+	union acpi_operand_object       *obj_desc,
+	u32                             field_datum_byte_offset);
+
+acpi_status
+acpi_ex_access_region (
+	union acpi_operand_object       *obj_desc,
+	u32                             field_datum_byte_offset,
+	acpi_integer                    *value,
+	u32                             read_write);
+
+u8
+acpi_ex_register_overflow (
+	union acpi_operand_object       *obj_desc,
+	acpi_integer                    value);
+
+acpi_status
+acpi_ex_field_datum_io (
+	union acpi_operand_object       *obj_desc,
+	u32                             field_datum_byte_offset,
+	acpi_integer                    *value,
+	u32                             read_write);
+
+acpi_status
+acpi_ex_write_with_update_rule (
+	union acpi_operand_object       *obj_desc,
+	acpi_integer                    mask,
+	acpi_integer                    field_value,
+	u32                             field_datum_byte_offset);
+
+void
+acpi_ex_get_buffer_datum(
+	acpi_integer                    *datum,
+	void                            *buffer,
+	u32                             buffer_length,
+	u32                             byte_granularity,
+	u32                             buffer_offset);
+
+void
+acpi_ex_set_buffer_datum (
+	acpi_integer                    merged_datum,
+	void                            *buffer,
+	u32                             buffer_length,
+	u32                             byte_granularity,
+	u32                             buffer_offset);
+
+acpi_status
+acpi_ex_read_data_from_field (
+	struct acpi_walk_state          *walk_state,
+	union acpi_operand_object       *obj_desc,
+	union acpi_operand_object       **ret_buffer_desc);
+
+acpi_status
+acpi_ex_write_data_to_field (
+	union acpi_operand_object       *source_desc,
+	union acpi_operand_object       *obj_desc,
+	union acpi_operand_object       **result_desc);
+
+/*
+ * exmisc - ACPI AML (p-code) execution - specific opcodes
+ */
+
+acpi_status
+acpi_ex_opcode_3A_0T_0R (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_opcode_3A_1T_1R (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_opcode_6A_0T_1R (
+	struct acpi_walk_state          *walk_state);
+
+u8
+acpi_ex_do_match (
+	u32                             match_op,
+	acpi_integer                    package_value,
+	acpi_integer                    match_value);
+
+acpi_status
+acpi_ex_get_object_reference (
+	union acpi_operand_object       *obj_desc,
+	union acpi_operand_object       **return_desc,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_resolve_multiple (
+	struct acpi_walk_state          *walk_state,
+	union acpi_operand_object       *operand,
+	acpi_object_type                *return_type,
+	union acpi_operand_object       **return_desc);
+
+acpi_status
+acpi_ex_concat_template (
+	union acpi_operand_object       *obj_desc,
+	union acpi_operand_object       *obj_desc2,
+	union acpi_operand_object       **actual_return_desc,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_do_concatenate (
+	union acpi_operand_object       *obj_desc,
+	union acpi_operand_object       *obj_desc2,
+	union acpi_operand_object       **actual_return_desc,
+	struct acpi_walk_state          *walk_state);
+
+u8
+acpi_ex_do_logical_op (
+	u16                             opcode,
+	acpi_integer                    operand0,
+	acpi_integer                    operand1);
+
+acpi_integer
+acpi_ex_do_math_op (
+	u16                             opcode,
+	acpi_integer                    operand0,
+	acpi_integer                    operand1);
+
+acpi_status
+acpi_ex_create_mutex (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_create_processor (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_create_power_resource (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_create_region (
+	u8                              *aml_start,
+	u32                             aml_length,
+	u8                              region_space,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_create_table_region (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_create_event (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_create_alias (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_create_method (
+	u8                              *aml_start,
+	u32                             aml_length,
+	struct acpi_walk_state          *walk_state);
+
+
+/*
+ * exconfig - dynamic table load/unload
+ */
+
+acpi_status
+acpi_ex_add_table (
+	struct acpi_table_header        *table,
+	struct acpi_namespace_node      *parent_node,
+	union acpi_operand_object       **ddb_handle);
+
+acpi_status
+acpi_ex_load_op (
+	union acpi_operand_object       *obj_desc,
+	union acpi_operand_object       *target,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_load_table_op (
+	struct acpi_walk_state          *walk_state,
+	union acpi_operand_object       **return_desc);
+
+acpi_status
+acpi_ex_unload_table (
+	union acpi_operand_object       *ddb_handle);
+
+
+/*
+ * exmutex - mutex support
+ */
+
+acpi_status
+acpi_ex_acquire_mutex (
+	union acpi_operand_object       *time_desc,
+	union acpi_operand_object       *obj_desc,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_release_mutex (
+	union acpi_operand_object       *obj_desc,
+	struct acpi_walk_state          *walk_state);
+
+void
+acpi_ex_release_all_mutexes (
+	struct acpi_thread_state        *thread);
+
+void
+acpi_ex_unlink_mutex (
+	union acpi_operand_object       *obj_desc);
+
+void
+acpi_ex_link_mutex (
+	union acpi_operand_object       *obj_desc,
+	struct acpi_thread_state        *thread);
+
+/*
+ * exprep - ACPI AML (p-code) execution - prep utilities
+ */
+
+acpi_status
+acpi_ex_prep_common_field_object (
+	union acpi_operand_object       *obj_desc,
+	u8                              field_flags,
+	u8                              field_attribute,
+	u32                             field_bit_position,
+	u32                             field_bit_length);
+
+acpi_status
+acpi_ex_prep_field_value (
+	struct acpi_create_field_info   *info);
+
+/*
+ * exsystem - Interface to OS services
+ */
+
+acpi_status
+acpi_ex_system_do_notify_op (
+	union acpi_operand_object       *value,
+	union acpi_operand_object       *obj_desc);
+
+acpi_status
+acpi_ex_system_do_suspend(
+	u32                             time);
+
+acpi_status
+acpi_ex_system_do_stall (
+	u32                             time);
+
+acpi_status
+acpi_ex_system_acquire_mutex(
+	union acpi_operand_object       *time,
+	union acpi_operand_object       *obj_desc);
+
+acpi_status
+acpi_ex_system_release_mutex(
+	union acpi_operand_object       *obj_desc);
+
+acpi_status
+acpi_ex_system_signal_event(
+	union acpi_operand_object       *obj_desc);
+
+acpi_status
+acpi_ex_system_wait_event(
+	union acpi_operand_object       *time,
+	union acpi_operand_object       *obj_desc);
+
+acpi_status
+acpi_ex_system_reset_event(
+	union acpi_operand_object       *obj_desc);
+
+acpi_status
+acpi_ex_system_wait_semaphore (
+	acpi_handle                     semaphore,
+	u16                             timeout);
+
+
+/*
+ * exmonadic - ACPI AML (p-code) execution, monadic operators
+ */
+
+acpi_status
+acpi_ex_opcode_1A_0T_0R (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_opcode_1A_0T_1R (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_opcode_1A_1T_1R (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_opcode_1A_1T_0R (
+	struct acpi_walk_state          *walk_state);
+
+/*
+ * exdyadic - ACPI AML (p-code) execution, dyadic operators
+ */
+
+acpi_status
+acpi_ex_opcode_2A_0T_0R (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_opcode_2A_0T_1R (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_opcode_2A_1T_1R (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_opcode_2A_2T_1R (
+	struct acpi_walk_state          *walk_state);
+
+
+/*
+ * exresolv  - Object resolution and get value functions
+ */
+
+acpi_status
+acpi_ex_resolve_to_value (
+	union acpi_operand_object       **stack_ptr,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_resolve_node_to_value (
+	struct acpi_namespace_node      **stack_ptr,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_resolve_object_to_value (
+	union acpi_operand_object       **stack_ptr,
+	struct acpi_walk_state          *walk_state);
+
+
+/*
+ * exdump - Scanner debug output routines
+ */
+
+void
+acpi_ex_dump_operand (
+	union acpi_operand_object       *entry_desc);
+
+void
+acpi_ex_dump_operands (
+	union acpi_operand_object       **operands,
+	acpi_interpreter_mode           interpreter_mode,
+	char                            *ident,
+	u32                             num_levels,
+	char                            *note,
+	char                            *module_name,
+	u32                             line_number);
+
+void
+acpi_ex_dump_object_descriptor (
+	union acpi_operand_object       *object,
+	u32                             flags);
+
+void
+acpi_ex_dump_node (
+	struct acpi_namespace_node      *node,
+	u32                             flags);
+
+void
+acpi_ex_out_string (
+	char                            *title,
+	char                            *value);
+
+void
+acpi_ex_out_pointer (
+	char                            *title,
+	void                            *value);
+
+void
+acpi_ex_out_integer (
+	char                            *title,
+	u32                             value);
+
+void
+acpi_ex_out_address (
+	char                            *title,
+	acpi_physical_address           value);
+
+
+/*
+ * exnames - interpreter/scanner name load/execute
+ */
+
+char *
+acpi_ex_allocate_name_string (
+	u32                             prefix_count,
+	u32                             num_name_segs);
+
+u32
+acpi_ex_good_char (
+	u32                             character);
+
+acpi_status
+acpi_ex_name_segment (
+	u8                              **in_aml_address,
+	char                            *name_string);
+
+acpi_status
+acpi_ex_get_name_string (
+	acpi_object_type                data_type,
+	u8                              *in_aml_address,
+	char                            **out_name_string,
+	u32                             *out_name_length);
+
+acpi_status
+acpi_ex_do_name (
+	acpi_object_type                data_type,
+	acpi_interpreter_mode           load_exec_mode);
+
+
+/*
+ * exstore - Object store support
+ */
+
+acpi_status
+acpi_ex_store (
+	union acpi_operand_object       *val_desc,
+	union acpi_operand_object       *dest_desc,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_store_object_to_index (
+	union acpi_operand_object       *val_desc,
+	union acpi_operand_object       *dest_desc,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_store_object_to_node (
+	union acpi_operand_object       *source_desc,
+	struct acpi_namespace_node      *node,
+	struct acpi_walk_state          *walk_state);
+
+
+/*
+ * exstoren
+ */
+
+acpi_status
+acpi_ex_resolve_object (
+	union acpi_operand_object       **source_desc_ptr,
+	acpi_object_type                target_type,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ex_store_object_to_object (
+	union acpi_operand_object       *source_desc,
+	union acpi_operand_object       *dest_desc,
+	union acpi_operand_object       **new_desc,
+	struct acpi_walk_state          *walk_state);
+
+
+/*
+ * excopy - object copy
+ */
+
+acpi_status
+acpi_ex_store_buffer_to_buffer (
+	union acpi_operand_object       *source_desc,
+	union acpi_operand_object       *target_desc);
+
+acpi_status
+acpi_ex_store_string_to_string (
+	union acpi_operand_object       *source_desc,
+	union acpi_operand_object       *target_desc);
+
+acpi_status
+acpi_ex_copy_integer_to_index_field (
+	union acpi_operand_object       *source_desc,
+	union acpi_operand_object       *target_desc);
+
+acpi_status
+acpi_ex_copy_integer_to_bank_field (
+	union acpi_operand_object       *source_desc,
+	union acpi_operand_object       *target_desc);
+
+acpi_status
+acpi_ex_copy_data_to_named_field (
+	union acpi_operand_object       *source_desc,
+	struct acpi_namespace_node      *node);
+
+acpi_status
+acpi_ex_copy_integer_to_buffer_field (
+	union acpi_operand_object       *source_desc,
+	union acpi_operand_object       *target_desc);
+
+/*
+ * exutils - interpreter/scanner utilities
+ */
+
+acpi_status
+acpi_ex_enter_interpreter (
+	void);
+
+void
+acpi_ex_exit_interpreter (
+	void);
+
+void
+acpi_ex_truncate_for32bit_table (
+	union acpi_operand_object       *obj_desc);
+
+u8
+acpi_ex_acquire_global_lock (
+	u32                             rule);
+
+void
+acpi_ex_release_global_lock (
+	u8                              locked);
+
+u32
+acpi_ex_digits_needed (
+	acpi_integer                    value,
+	u32                             base);
+
+void
+acpi_ex_eisa_id_to_string (
+	u32                             numeric_id,
+	char                            *out_string);
+
+void
+acpi_ex_unsigned_integer_to_string (
+	acpi_integer                    value,
+	char                            *out_string);
+
+
+/*
+ * exregion - default op_region handlers
+ */
+
+acpi_status
+acpi_ex_system_memory_space_handler (
+	u32                             function,
+	acpi_physical_address           address,
+	u32                             bit_width,
+	acpi_integer                    *value,
+	void                            *handler_context,
+	void                            *region_context);
+
+acpi_status
+acpi_ex_system_io_space_handler (
+	u32                             function,
+	acpi_physical_address           address,
+	u32                             bit_width,
+	acpi_integer                    *value,
+	void                            *handler_context,
+	void                            *region_context);
+
+acpi_status
+acpi_ex_pci_config_space_handler (
+	u32                             function,
+	acpi_physical_address           address,
+	u32                             bit_width,
+	acpi_integer                    *value,
+	void                            *handler_context,
+	void                            *region_context);
+
+acpi_status
+acpi_ex_cmos_space_handler (
+	u32                             function,
+	acpi_physical_address           address,
+	u32                             bit_width,
+	acpi_integer                    *value,
+	void                            *handler_context,
+	void                            *region_context);
+
+acpi_status
+acpi_ex_pci_bar_space_handler (
+	u32                             function,
+	acpi_physical_address           address,
+	u32                             bit_width,
+	acpi_integer                    *value,
+	void                            *handler_context,
+	void                            *region_context);
+
+acpi_status
+acpi_ex_embedded_controller_space_handler (
+	u32                             function,
+	acpi_physical_address           address,
+	u32                             bit_width,
+	acpi_integer                    *value,
+	void                            *handler_context,
+	void                            *region_context);
+
+acpi_status
+acpi_ex_sm_bus_space_handler (
+	u32                             function,
+	acpi_physical_address           address,
+	u32                             bit_width,
+	acpi_integer                    *value,
+	void                            *handler_context,
+	void                            *region_context);
+
+
+acpi_status
+acpi_ex_data_table_space_handler (
+	u32                             function,
+	acpi_physical_address           address,
+	u32                             bit_width,
+	acpi_integer                    *value,
+	void                            *handler_context,
+	void                            *region_context);
+
+#endif /* __INTERP_H__ */
diff -urNp linux-5400/include/acpi/aclocal.h linux-5410/include/acpi/aclocal.h
--- linux-5400/include/acpi/aclocal.h
+++ linux-5410/include/acpi/aclocal.h
@@ -0,0 +1,972 @@
+/******************************************************************************
+ *
+ * Name: aclocal.h - Internal data types used across the ACPI subsystem
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACLOCAL_H__
+#define __ACLOCAL_H__
+
+
+#define ACPI_WAIT_FOREVER               0xFFFF  /* u16, as per ACPI spec */
+
+typedef void *                                  acpi_mutex;
+typedef u32                                     acpi_mutex_handle;
+
+
+/* Total number of aml opcodes defined */
+
+#define AML_NUM_OPCODES                 0x7E
+
+
+/*****************************************************************************
+ *
+ * Mutex typedefs and structs
+ *
+ ****************************************************************************/
+
+
+/*
+ * Predefined handles for the mutex objects used within the subsystem
+ * All mutex objects are automatically created by acpi_ut_mutex_initialize.
+ *
+ * The acquire/release ordering protocol is implied via this list.  Mutexes
+ * with a lower value must be acquired before mutexes with a higher value.
+ *
+ * NOTE: any changes here must be reflected in the acpi_gbl_mutex_names table also!
+ */
+
+#define ACPI_MTX_EXECUTE                0
+#define ACPI_MTX_INTERPRETER            1
+#define ACPI_MTX_PARSER                 2
+#define ACPI_MTX_DISPATCHER             3
+#define ACPI_MTX_TABLES                 4
+#define ACPI_MTX_OP_REGIONS             5
+#define ACPI_MTX_NAMESPACE              6
+#define ACPI_MTX_EVENTS                 7
+#define ACPI_MTX_HARDWARE               8
+#define ACPI_MTX_CACHES                 9
+#define ACPI_MTX_MEMORY                 10
+#define ACPI_MTX_DEBUG_CMD_COMPLETE     11
+#define ACPI_MTX_DEBUG_CMD_READY        12
+
+#define MAX_MUTEX                       12
+#define NUM_MUTEX                       MAX_MUTEX+1
+
+
+#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
+#ifdef DEFINE_ACPI_GLOBALS
+
+/* Names for the mutexes used in the subsystem */
+
+static char                         *acpi_gbl_mutex_names[] =
+{
+	"ACPI_MTX_Execute",
+	"ACPI_MTX_Interpreter",
+	"ACPI_MTX_Parser",
+	"ACPI_MTX_Dispatcher",
+	"ACPI_MTX_Tables",
+	"ACPI_MTX_op_regions",
+	"ACPI_MTX_Namespace",
+	"ACPI_MTX_Events",
+	"ACPI_MTX_Hardware",
+	"ACPI_MTX_Caches",
+	"ACPI_MTX_Memory",
+	"ACPI_MTX_debug_cmd_complete",
+	"ACPI_MTX_debug_cmd_ready",
+};
+
+#endif
+#endif
+
+
+/* Table for the global mutexes */
+
+struct acpi_mutex_info
+{
+	acpi_mutex                          mutex;
+	u32                                 use_count;
+	u32                                 owner_id;
+};
+
+/* This owner ID means that the mutex is not in use (unlocked) */
+
+#define ACPI_MUTEX_NOT_ACQUIRED         (u32) (-1)
+
+
+/* Lock flag parameter for various interfaces */
+
+#define ACPI_MTX_DO_NOT_LOCK            0
+#define ACPI_MTX_LOCK                   1
+
+
+typedef u16                                     acpi_owner_id;
+#define ACPI_OWNER_TYPE_TABLE           0x0
+#define ACPI_OWNER_TYPE_METHOD          0x1
+#define ACPI_FIRST_METHOD_ID            0x0001
+#define ACPI_FIRST_TABLE_ID             0xF000
+
+
+/* Field access granularities */
+
+#define ACPI_FIELD_BYTE_GRANULARITY     1
+#define ACPI_FIELD_WORD_GRANULARITY     2
+#define ACPI_FIELD_DWORD_GRANULARITY    4
+#define ACPI_FIELD_QWORD_GRANULARITY    8
+
+/*****************************************************************************
+ *
+ * Namespace typedefs and structs
+ *
+ ****************************************************************************/
+
+
+/* Operational modes of the AML interpreter/scanner */
+
+typedef enum
+{
+	ACPI_IMODE_LOAD_PASS1               = 0x01,
+	ACPI_IMODE_LOAD_PASS2               = 0x02,
+	ACPI_IMODE_EXECUTE                  = 0x0E
+
+} acpi_interpreter_mode;
+
+
+/*
+ * The Node describes a named object that appears in the AML
+ * An acpi_node is used to store Nodes.
+ *
+ * data_type is used to differentiate between internal descriptors, and MUST
+ * be the first byte in this structure.
+ */
+
+union acpi_name_union
+{
+	u32                                 integer;
+	char                                ascii[4];
+};
+
+struct acpi_namespace_node
+{
+	u8                                  descriptor;     /* Used to differentiate object descriptor types */
+	u8                                  type;           /* Type associated with this name */
+	u16                                 owner_id;
+	union acpi_name_union               name;           /* ACPI Name, always 4 chars per ACPI spec */
+
+
+	union acpi_operand_object           *object;        /* Pointer to attached ACPI object (optional) */
+	struct acpi_namespace_node          *child;         /* First child */
+	struct acpi_namespace_node          *peer;          /* Next peer*/
+	u16                                 reference_count; /* Current count of references and children */
+	u8                                  flags;
+};
+
+
+#define ACPI_ENTRY_NOT_FOUND            NULL
+
+
+/* Node flags */
+
+#define ANOBJ_RESERVED                  0x01
+#define ANOBJ_END_OF_PEER_LIST          0x02
+#define ANOBJ_DATA_WIDTH_32             0x04     /* Parent table is 64-bits */
+#define ANOBJ_METHOD_ARG                0x08
+#define ANOBJ_METHOD_LOCAL              0x10
+#define ANOBJ_METHOD_NO_RETVAL          0x20
+#define ANOBJ_METHOD_SOME_NO_RETVAL     0x40
+
+#define ANOBJ_IS_BIT_OFFSET             0x80
+
+
+/*
+ * ACPI Table Descriptor.  One per ACPI table
+ */
+struct acpi_table_desc
+{
+	struct acpi_table_desc          *prev;
+	struct acpi_table_desc          *next;
+	struct acpi_table_desc          *installed_desc;
+	struct acpi_table_header        *pointer;
+	u8                              *aml_start;
+	u64                             physical_address;
+	u32                             aml_length;
+	acpi_size                       length;
+	acpi_owner_id                   table_id;
+	u8                              type;
+	u8                              allocation;
+	u8                              loaded_into_namespace;
+};
+
+struct acpi_table_list
+{
+	struct acpi_table_desc          *next;
+	u32                             count;
+};
+
+
+struct acpi_find_context
+{
+	char                            *search_for;
+	acpi_handle                     *list;
+	u32                             *count;
+};
+
+
+struct acpi_ns_search_data
+{
+	struct acpi_namespace_node      *node;
+};
+
+
+/*
+ * Predefined Namespace items
+ */
+struct acpi_predefined_names
+{
+	char                            *name;
+	u8                              type;
+	char                            *val;
+};
+
+
+/* Object types used during package copies */
+
+
+#define ACPI_COPY_TYPE_SIMPLE           0
+#define ACPI_COPY_TYPE_PACKAGE          1
+
+/* Info structure used to convert external<->internal namestrings */
+
+struct acpi_namestring_info
+{
+	char                            *external_name;
+	char                            *next_external_char;
+	char                            *internal_name;
+	u32                             length;
+	u32                             num_segments;
+	u32                             num_carats;
+	u8                              fully_qualified;
+};
+
+
+/* Field creation info */
+
+struct acpi_create_field_info
+{
+	struct acpi_namespace_node      *region_node;
+	struct acpi_namespace_node      *field_node;
+	struct acpi_namespace_node      *register_node;
+	struct acpi_namespace_node      *data_register_node;
+	u32                             bank_value;
+	u32                             field_bit_position;
+	u32                             field_bit_length;
+	u8                              field_flags;
+	u8                              attribute;
+	u8                              field_type;
+};
+
+
+/*****************************************************************************
+ *
+ * Event typedefs and structs
+ *
+ ****************************************************************************/
+
+/* Information about a GPE, one per each GPE in an array */
+
+struct acpi_gpe_event_info
+{
+	struct acpi_namespace_node              *method_node;   /* Method node for this GPE level */
+	acpi_gpe_handler                        handler;        /* Address of handler, if any */
+	void                                    *context;       /* Context to be passed to handler */
+	struct acpi_gpe_register_info           *register_info; /* Backpointer to register info */
+	u8                                      flags;          /* Level or Edge */
+	u8                                      bit_mask;       /* This GPE within the register */
+};
+
+/* Information about a GPE register pair, one per each status/enable pair in an array */
+
+struct acpi_gpe_register_info
+{
+	struct acpi_generic_address             status_address; /* Address of status reg */
+	struct acpi_generic_address             enable_address; /* Address of enable reg */
+	u8                                      status;         /* Current value of status reg */
+	u8                                      enable;         /* Current value of enable reg */
+	u8                                      wake_enable;    /* Mask of bits to keep enabled when sleeping */
+	u8                                      base_gpe_number; /* Base GPE number for this register */
+};
+
+/*
+ * Information about a GPE register block, one per each installed block --
+ * GPE0, GPE1, and one per each installed GPE Block Device.
+ */
+struct acpi_gpe_block_info
+{
+	struct acpi_gpe_block_info              *previous;
+	struct acpi_gpe_block_info              *next;
+	struct acpi_gpe_xrupt_info              *xrupt_block;   /* Backpointer to interrupt block */
+	struct acpi_gpe_register_info           *register_info; /* One per GPE register pair */
+	struct acpi_gpe_event_info              *event_info;    /* One for each GPE */
+	struct acpi_generic_address             block_address;  /* Base address of the block */
+	u32                                     register_count; /* Number of register pairs in block */
+	u8                                      block_base_number;/* Base GPE number for this block */
+};
+
+/* Information about GPE interrupt handlers, one per each interrupt level used for GPEs */
+
+struct acpi_gpe_xrupt_info
+{
+	struct acpi_gpe_xrupt_info              *previous;
+	struct acpi_gpe_xrupt_info              *next;
+	struct acpi_gpe_block_info              *gpe_block_list_head; /* List of GPE blocks for this xrupt */
+	u32                                     interrupt_level;    /* System interrupt level */
+};
+
+
+typedef acpi_status (*ACPI_GPE_CALLBACK) (
+	struct acpi_gpe_xrupt_info      *gpe_xrupt_info,
+	struct acpi_gpe_block_info      *gpe_block);
+
+
+/* Information about each particular fixed event */
+
+struct acpi_fixed_event_handler
+{
+	acpi_event_handler              handler;        /* Address of handler. */
+	void                            *context;       /* Context to be passed to handler */
+};
+
+struct acpi_fixed_event_info
+{
+	u8                              status_register_id;
+	u8                              enable_register_id;
+	u16                             status_bit_mask;
+	u16                             enable_bit_mask;
+};
+
+/* Information used during field processing */
+
+struct acpi_field_info
+{
+	u8                              skip_field;
+	u8                              field_flag;
+	u32                             pkg_length;
+};
+
+
+/*****************************************************************************
+ *
+ * Generic "state" object for stacks
+ *
+ ****************************************************************************/
+
+
+#define ACPI_CONTROL_NORMAL                  0xC0
+#define ACPI_CONTROL_CONDITIONAL_EXECUTING   0xC1
+#define ACPI_CONTROL_PREDICATE_EXECUTING     0xC2
+#define ACPI_CONTROL_PREDICATE_FALSE         0xC3
+#define ACPI_CONTROL_PREDICATE_TRUE          0xC4
+
+
+/* Forward declarations */
+struct acpi_walk_state        ;
+struct acpi_obj_mutex;
+union acpi_parse_object        ;
+
+
+#define ACPI_STATE_COMMON                  /* Two 32-bit fields and a pointer */\
+	u8                                  data_type;          /* To differentiate various internal objs */\
+	u8                                  flags;      \
+	u16                                 value;      \
+	u16                                 state;      \
+	u16                                 reserved;   \
+	void                                *next;      \
+
+struct acpi_common_state
+{
+	ACPI_STATE_COMMON
+};
+
+
+/*
+ * Update state - used to traverse complex objects such as packages
+ */
+struct acpi_update_state
+{
+	ACPI_STATE_COMMON
+	union acpi_operand_object           *object;
+};
+
+
+/*
+ * Pkg state - used to traverse nested package structures
+ */
+struct acpi_pkg_state
+{
+	ACPI_STATE_COMMON
+	union acpi_operand_object           *source_object;
+	union acpi_operand_object           *dest_object;
+	struct acpi_walk_state              *walk_state;
+	void                                *this_target_obj;
+	u32                                 num_packages;
+	u16                                 index;
+};
+
+
+/*
+ * Control state - one per if/else and while constructs.
+ * Allows nesting of these constructs
+ */
+struct acpi_control_state
+{
+	ACPI_STATE_COMMON
+	union acpi_parse_object             *predicate_op;
+	u8                                  *aml_predicate_start;   /* Start of if/while predicate */
+	u8                                  *package_end;           /* End of if/while block */
+	u16                                 opcode;
+};
+
+
+/*
+ * Scope state - current scope during namespace lookups
+ */
+struct acpi_scope_state
+{
+	ACPI_STATE_COMMON
+	struct acpi_namespace_node          *node;
+};
+
+
+struct acpi_pscope_state
+{
+	ACPI_STATE_COMMON
+	union acpi_parse_object             *op;                    /* Current op being parsed */
+	u8                                  *arg_end;               /* Current argument end */
+	u8                                  *pkg_end;               /* Current package end */
+	u32                                 arg_list;               /* Next argument to parse */
+	u32                                 arg_count;              /* Number of fixed arguments */
+};
+
+
+/*
+ * Thread state - one per thread across multiple walk states.  Multiple walk
+ * states are created when there are nested control methods executing.
+ */
+struct acpi_thread_state
+{
+	ACPI_STATE_COMMON
+	struct acpi_walk_state              *walk_state_list;       /* Head of list of walk_states for this thread */
+	union acpi_operand_object           *acquired_mutex_list;   /* List of all currently acquired mutexes */
+	u32                                 thread_id;              /* Running thread ID */
+	u16                                 current_sync_level;     /* Mutex Sync (nested acquire) level */
+};
+
+
+/*
+ * Result values - used to accumulate the results of nested
+ * AML arguments
+ */
+struct acpi_result_values
+{
+	ACPI_STATE_COMMON
+	union acpi_operand_object           *obj_desc [ACPI_OBJ_NUM_OPERANDS];
+	u8                                  num_results;
+	u8                                  last_insert;
+};
+
+
+typedef
+acpi_status (*acpi_parse_downwards) (
+	struct acpi_walk_state              *walk_state,
+	union acpi_parse_object             **out_op);
+
+typedef
+acpi_status (*acpi_parse_upwards) (
+	struct acpi_walk_state              *walk_state);
+
+
+/*
+ * Notify info - used to pass info to the deferred notify
+ * handler/dispatcher.
+ */
+struct acpi_notify_info
+{
+	ACPI_STATE_COMMON
+	struct acpi_namespace_node          *node;
+	union acpi_operand_object           *handler_obj;
+};
+
+
+/* Generic state is union of structs above */
+
+union acpi_generic_state
+{
+	struct acpi_common_state            common;
+	struct acpi_control_state           control;
+	struct acpi_update_state            update;
+	struct acpi_scope_state             scope;
+	struct acpi_pscope_state            parse_scope;
+	struct acpi_pkg_state               pkg;
+	struct acpi_thread_state            thread;
+	struct acpi_result_values           results;
+	struct acpi_notify_info             notify;
+};
+
+
+/*****************************************************************************
+ *
+ * Interpreter typedefs and structs
+ *
+ ****************************************************************************/
+
+typedef
+acpi_status (*ACPI_EXECUTE_OP) (
+	struct acpi_walk_state              *walk_state);
+
+
+/*****************************************************************************
+ *
+ * Parser typedefs and structs
+ *
+ ****************************************************************************/
+
+/*
+ * AML opcode, name, and argument layout
+ */
+struct acpi_opcode_info
+{
+#if defined(ACPI_DISASSEMBLER) || defined(ACPI_DEBUG_OUTPUT)
+	char                                *name;          /* Opcode name (disassembler/debug only) */
+#endif
+	u32                                 parse_args;     /* Grammar/Parse time arguments */
+	u32                                 runtime_args;   /* Interpret time arguments */
+	u32                                 flags;          /* Misc flags */
+	u8                                  object_type;    /* Corresponding internal object type */
+	u8                                  class;          /* Opcode class */
+	u8                                  type;           /* Opcode type */
+};
+
+
+union acpi_parse_value
+{
+	acpi_integer                        integer;        /* Integer constant (Up to 64 bits) */
+	struct uint64_struct                integer64;      /* Structure overlay for 2 32-bit Dwords */
+	u32                                 size;           /* bytelist or field size */
+	char                                *string;        /* NULL terminated string */
+	u8                                  *buffer;        /* buffer or string */
+	char                                *name;          /* NULL terminated string */
+	union acpi_parse_object             *arg;           /* arguments and contained ops */
+};
+
+
+#define ACPI_PARSE_COMMON \
+	u8                                  data_type;      /* To differentiate various internal objs */\
+	u8                                  flags;          /* Type of Op */\
+	u16                                 aml_opcode;     /* AML opcode */\
+	u32                                 aml_offset;     /* Offset of declaration in AML */\
+	union acpi_parse_object             *parent;        /* Parent op */\
+	union acpi_parse_object             *next;          /* Next op */\
+	ACPI_DISASM_ONLY_MEMBERS (\
+	u8                                  disasm_flags;   /* Used during AML disassembly */\
+	u8                                  disasm_opcode;  /* Subtype used for disassembly */\
+	char                                aml_op_name[16]) /* Op name (debug only) */\
+			   /* NON-DEBUG members below: */\
+	struct acpi_namespace_node          *node;          /* For use by interpreter */\
+	union acpi_parse_value              value;          /* Value or args associated with the opcode */\
+
+
+#define ACPI_DASM_BUFFER        0x00
+#define ACPI_DASM_RESOURCE      0x01
+#define ACPI_DASM_STRING        0x02
+#define ACPI_DASM_UNICODE       0x03
+#define ACPI_DASM_EISAID        0x04
+#define ACPI_DASM_MATCHOP       0x05
+
+/*
+ * generic operation (for example:  If, While, Store)
+ */
+struct acpi_parse_obj_common
+{
+	ACPI_PARSE_COMMON
+};
+
+
+/*
+ * Extended Op for named ops (Scope, Method, etc.), deferred ops (Methods and op_regions),
+ * and bytelists.
+ */
+struct acpi_parse_obj_named
+{
+	ACPI_PARSE_COMMON
+	u8                                  *path;
+	u8                                  *data;          /* AML body or bytelist data */
+	u32                                 length;         /* AML length */
+	u32                                 name;           /* 4-byte name or zero if no name */
+};
+
+
+/* The parse node is the fundamental element of the parse tree */
+
+struct acpi_parse_obj_asl
+{
+	ACPI_PARSE_COMMON
+	union acpi_parse_object             *child;
+	union acpi_parse_object             *parent_method;
+	char                                *filename;
+	char                                *external_name;
+	char                                *namepath;
+	char                                name_seg[4];
+	u32                                 extra_value;
+	u32                                 column;
+	u32                                 line_number;
+	u32                                 logical_line_number;
+	u32                                 logical_byte_offset;
+	u32                                 end_line;
+	u32                                 end_logical_line;
+	u32                                 acpi_btype;
+	u32                                 aml_length;
+	u32                                 aml_subtree_length;
+	u32                                 final_aml_length;
+	u32                                 final_aml_offset;
+	u32                                 compile_flags;
+	u16                                 parse_opcode;
+	u8                                  aml_opcode_length;
+	u8                                  aml_pkg_len_bytes;
+	u8                                  extra;
+	char                                parse_op_name[12];
+};
+
+
+union acpi_parse_object
+{
+	struct acpi_parse_obj_common        common;
+	struct acpi_parse_obj_named         named;
+	struct acpi_parse_obj_asl           asl;
+};
+
+
+/*
+ * Parse state - one state per parser invocation and each control
+ * method.
+ */
+struct acpi_parse_state
+{
+	u32                                 aml_size;
+	u8                                  *aml_start;     /* First AML byte */
+	u8                                  *aml;           /* Next AML byte */
+	u8                                  *aml_end;       /* (last + 1) AML byte */
+	u8                                  *pkg_start;     /* Current package begin */
+	u8                                  *pkg_end;       /* Current package end */
+	union acpi_parse_object             *start_op;      /* Root of parse tree */
+	struct acpi_namespace_node          *start_node;
+	union acpi_generic_state            *scope;         /* Current scope */
+	union acpi_parse_object             *start_scope;
+};
+
+
+/* Parse object flags */
+
+#define ACPI_PARSEOP_GENERIC                    0x01
+#define ACPI_PARSEOP_NAMED                      0x02
+#define ACPI_PARSEOP_DEFERRED                   0x04
+#define ACPI_PARSEOP_BYTELIST                   0x08
+#define ACPI_PARSEOP_IN_CACHE                   0x80
+
+/* Parse object disasm_flags */
+
+#define ACPI_PARSEOP_IGNORE                     0x01
+#define ACPI_PARSEOP_PARAMLIST                  0x02
+#define ACPI_PARSEOP_EMPTY_TERMLIST             0x04
+#define ACPI_PARSEOP_SPECIAL                    0x10
+
+
+/*****************************************************************************
+ *
+ * Hardware (ACPI registers) and PNP
+ *
+ ****************************************************************************/
+
+#define PCI_ROOT_HID_STRING         "PNP0A03"
+
+struct acpi_bit_register_info
+{
+	u8                                  parent_register;
+	u8                                  bit_position;
+	u16                                 access_bit_mask;
+};
+
+
+/*
+ * Register IDs
+ * These are the full ACPI registers
+ */
+#define ACPI_REGISTER_PM1_STATUS                0x01
+#define ACPI_REGISTER_PM1_ENABLE                0x02
+#define ACPI_REGISTER_PM1_CONTROL               0x03
+#define ACPI_REGISTER_PM1A_CONTROL              0x04
+#define ACPI_REGISTER_PM1B_CONTROL              0x05
+#define ACPI_REGISTER_PM2_CONTROL               0x06
+#define ACPI_REGISTER_PM_TIMER                  0x07
+#define ACPI_REGISTER_PROCESSOR_BLOCK           0x08
+#define ACPI_REGISTER_SMI_COMMAND_BLOCK         0x09
+
+
+/* Masks used to access the bit_registers */
+
+#define ACPI_BITMASK_TIMER_STATUS               0x0001
+#define ACPI_BITMASK_BUS_MASTER_STATUS          0x0010
+#define ACPI_BITMASK_GLOBAL_LOCK_STATUS         0x0020
+#define ACPI_BITMASK_POWER_BUTTON_STATUS        0x0100
+#define ACPI_BITMASK_SLEEP_BUTTON_STATUS        0x0200
+#define ACPI_BITMASK_RT_CLOCK_STATUS            0x0400
+#define ACPI_BITMASK_WAKE_STATUS                0x8000
+
+#define ACPI_BITMASK_ALL_FIXED_STATUS           (ACPI_BITMASK_TIMER_STATUS          | \
+			 ACPI_BITMASK_BUS_MASTER_STATUS     | \
+			 ACPI_BITMASK_GLOBAL_LOCK_STATUS    | \
+			 ACPI_BITMASK_POWER_BUTTON_STATUS   | \
+			 ACPI_BITMASK_SLEEP_BUTTON_STATUS   | \
+			 ACPI_BITMASK_RT_CLOCK_STATUS       | \
+			 ACPI_BITMASK_WAKE_STATUS)
+
+#define ACPI_BITMASK_TIMER_ENABLE               0x0001
+#define ACPI_BITMASK_GLOBAL_LOCK_ENABLE         0x0020
+#define ACPI_BITMASK_POWER_BUTTON_ENABLE        0x0100
+#define ACPI_BITMASK_SLEEP_BUTTON_ENABLE        0x0200
+#define ACPI_BITMASK_RT_CLOCK_ENABLE            0x0400
+
+#define ACPI_BITMASK_SCI_ENABLE                 0x0001
+#define ACPI_BITMASK_BUS_MASTER_RLD             0x0002
+#define ACPI_BITMASK_GLOBAL_LOCK_RELEASE        0x0004
+#define ACPI_BITMASK_SLEEP_TYPE_X               0x1C00
+#define ACPI_BITMASK_SLEEP_ENABLE               0x2000
+
+#define ACPI_BITMASK_ARB_DISABLE                0x0001
+
+
+/* Raw bit position of each bit_register */
+
+#define ACPI_BITPOSITION_TIMER_STATUS           0x00
+#define ACPI_BITPOSITION_BUS_MASTER_STATUS      0x04
+#define ACPI_BITPOSITION_GLOBAL_LOCK_STATUS     0x05
+#define ACPI_BITPOSITION_POWER_BUTTON_STATUS    0x08
+#define ACPI_BITPOSITION_SLEEP_BUTTON_STATUS    0x09
+#define ACPI_BITPOSITION_RT_CLOCK_STATUS        0x0A
+#define ACPI_BITPOSITION_WAKE_STATUS            0x0F
+
+#define ACPI_BITPOSITION_TIMER_ENABLE           0x00
+#define ACPI_BITPOSITION_GLOBAL_LOCK_ENABLE     0x05
+#define ACPI_BITPOSITION_POWER_BUTTON_ENABLE    0x08
+#define ACPI_BITPOSITION_SLEEP_BUTTON_ENABLE    0x09
+#define ACPI_BITPOSITION_RT_CLOCK_ENABLE        0x0A
+
+#define ACPI_BITPOSITION_SCI_ENABLE             0x00
+#define ACPI_BITPOSITION_BUS_MASTER_RLD         0x01
+#define ACPI_BITPOSITION_GLOBAL_LOCK_RELEASE    0x02
+#define ACPI_BITPOSITION_SLEEP_TYPE_X           0x0A
+#define ACPI_BITPOSITION_SLEEP_ENABLE           0x0D
+
+#define ACPI_BITPOSITION_ARB_DISABLE            0x00
+
+
+/*****************************************************************************
+ *
+ * Resource descriptors
+ *
+ ****************************************************************************/
+
+
+/* resource_type values */
+
+#define ACPI_RESOURCE_TYPE_MEMORY_RANGE         0
+#define ACPI_RESOURCE_TYPE_IO_RANGE             1
+#define ACPI_RESOURCE_TYPE_BUS_NUMBER_RANGE     2
+
+/* Resource descriptor types and masks */
+
+#define ACPI_RDESC_TYPE_LARGE                   0x80
+#define ACPI_RDESC_TYPE_SMALL                   0x00
+
+#define ACPI_RDESC_TYPE_MASK                    0x80
+#define ACPI_RDESC_SMALL_MASK                   0x78 /* Only bits 6:3 contain the type */
+
+
+/*
+ * Small resource descriptor types
+ * Note: The 3 length bits (2:0) must be zero
+ */
+#define ACPI_RDESC_TYPE_IRQ_FORMAT              0x20
+#define ACPI_RDESC_TYPE_DMA_FORMAT              0x28
+#define ACPI_RDESC_TYPE_START_DEPENDENT         0x30
+#define ACPI_RDESC_TYPE_END_DEPENDENT           0x38
+#define ACPI_RDESC_TYPE_IO_PORT                 0x40
+#define ACPI_RDESC_TYPE_FIXED_IO_PORT           0x48
+#define ACPI_RDESC_TYPE_SMALL_VENDOR            0x70
+#define ACPI_RDESC_TYPE_END_TAG                 0x78
+
+/*
+ * Large resource descriptor types
+ */
+
+#define ACPI_RDESC_TYPE_MEMORY_24               0x81
+#define ACPI_RDESC_TYPE_GENERAL_REGISTER        0x82
+#define ACPI_RDESC_TYPE_LARGE_VENDOR            0x84
+#define ACPI_RDESC_TYPE_MEMORY_32               0x85
+#define ACPI_RDESC_TYPE_FIXED_MEMORY_32         0x86
+#define ACPI_RDESC_TYPE_DWORD_ADDRESS_SPACE     0x87
+#define ACPI_RDESC_TYPE_WORD_ADDRESS_SPACE      0x88
+#define ACPI_RDESC_TYPE_EXTENDED_XRUPT          0x89
+#define ACPI_RDESC_TYPE_QWORD_ADDRESS_SPACE     0x8A
+
+
+/*****************************************************************************
+ *
+ * Miscellaneous
+ *
+ ****************************************************************************/
+
+#define ACPI_ASCII_ZERO                      0x30
+
+
+/*****************************************************************************
+ *
+ * Debugger
+ *
+ ****************************************************************************/
+
+struct acpi_db_method_info
+{
+	acpi_handle                     thread_gate;
+	char                            *name;
+	char                            **args;
+	u32                             flags;
+	u32                             num_loops;
+	char                            pathname[128];
+};
+
+struct acpi_integrity_info
+{
+	u32                         nodes;
+	u32                         objects;
+};
+
+
+#define ACPI_DB_REDIRECTABLE_OUTPUT  0x01
+#define ACPI_DB_CONSOLE_OUTPUT       0x02
+#define ACPI_DB_DUPLICATE_OUTPUT     0x03
+
+
+/*****************************************************************************
+ *
+ * Debug
+ *
+ ****************************************************************************/
+
+struct acpi_debug_print_info
+{
+	u32                             component_id;
+	char                            *proc_name;
+	char                            *module_name;
+};
+
+
+/* Entry for a memory allocation (debug only) */
+
+#define ACPI_MEM_MALLOC                      0
+#define ACPI_MEM_CALLOC                      1
+#define ACPI_MAX_MODULE_NAME                 16
+
+#define ACPI_COMMON_DEBUG_MEM_HEADER \
+	struct acpi_debug_mem_block         *previous; \
+	struct acpi_debug_mem_block         *next; \
+	u32                                 size; \
+	u32                                 component; \
+	u32                                 line; \
+	char                                module[ACPI_MAX_MODULE_NAME]; \
+	u8                                  alloc_type;
+
+struct acpi_debug_mem_header
+{
+	ACPI_COMMON_DEBUG_MEM_HEADER
+};
+
+struct acpi_debug_mem_block
+{
+	ACPI_COMMON_DEBUG_MEM_HEADER
+	u64                                 user_space;
+};
+
+
+#define ACPI_MEM_LIST_GLOBAL            0
+#define ACPI_MEM_LIST_NSNODE            1
+
+#define ACPI_MEM_LIST_FIRST_CACHE_LIST  2
+#define ACPI_MEM_LIST_STATE             2
+#define ACPI_MEM_LIST_PSNODE            3
+#define ACPI_MEM_LIST_PSNODE_EXT        4
+#define ACPI_MEM_LIST_OPERAND           5
+#define ACPI_MEM_LIST_WALK              6
+#define ACPI_MEM_LIST_MAX               6
+#define ACPI_NUM_MEM_LISTS              7
+
+
+struct acpi_memory_list
+{
+	void                                *list_head;
+	u16                                 link_offset;
+	u16                                 max_cache_depth;
+	u16                                 cache_depth;
+	u16                                 object_size;
+
+#ifdef ACPI_DBG_TRACK_ALLOCATIONS
+
+	/* Statistics for debug memory tracking only */
+
+	u32                                 total_allocated;
+	u32                                 total_freed;
+	u32                                 current_total_size;
+	u32                                 cache_requests;
+	u32                                 cache_hits;
+	char                                *list_name;
+#endif
+};
+
+
+#endif /* __ACLOCAL_H__ */
diff -urNp linux-5400/include/acpi/acmacros.h linux-5410/include/acpi/acmacros.h
--- linux-5400/include/acpi/acmacros.h
+++ linux-5410/include/acpi/acmacros.h
@@ -0,0 +1,690 @@
+/******************************************************************************
+ *
+ * Name: acmacros.h - C macros for the entire subsystem.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACMACROS_H__
+#define __ACMACROS_H__
+
+
+/*
+ * Data manipulation macros
+ */
+
+#define ACPI_LOWORD(l)                  ((u16)(u32)(l))
+#define ACPI_HIWORD(l)                  ((u16)((((u32)(l)) >> 16) & 0xFFFF))
+#define ACPI_LOBYTE(l)                  ((u8)(u16)(l))
+#define ACPI_HIBYTE(l)                  ((u8)((((u16)(l)) >> 8) & 0xFF))
+
+
+#if ACPI_MACHINE_WIDTH == 16
+
+/*
+ * For 16-bit addresses, we have to assume that the upper 32 bits
+ * are zero.
+ */
+#define ACPI_LODWORD(l)                 ((u32)(l))
+#define ACPI_HIDWORD(l)                 ((u32)(0))
+
+#define ACPI_GET_ADDRESS(a)             ((a).lo)
+#define ACPI_STORE_ADDRESS(a,b)         {(a).hi=0;(a).lo=(u32)(b);}
+#define ACPI_VALID_ADDRESS(a)           ((a).hi | (a).lo)
+
+#else
+#ifdef ACPI_NO_INTEGER64_SUPPORT
+/*
+ * acpi_integer is 32-bits, no 64-bit support on this platform
+ */
+#define ACPI_LODWORD(l)                 ((u32)(l))
+#define ACPI_HIDWORD(l)                 ((u32)(0))
+
+#define ACPI_GET_ADDRESS(a)             (a)
+#define ACPI_STORE_ADDRESS(a,b)         ((a)=(b))
+#define ACPI_VALID_ADDRESS(a)           (a)
+
+#else
+
+/*
+ * Full 64-bit address/integer on both 32-bit and 64-bit platforms
+ */
+#define ACPI_LODWORD(l)                 ((u32)(u64)(l))
+#define ACPI_HIDWORD(l)                 ((u32)(((*(struct uint64_struct *)(void *)(&l))).hi))
+
+#define ACPI_GET_ADDRESS(a)             (a)
+#define ACPI_STORE_ADDRESS(a,b)         ((a)=(acpi_physical_address)(b))
+#define ACPI_VALID_ADDRESS(a)           (a)
+#endif
+#endif
+
+ /*
+  * Extract a byte of data using a pointer.  Any more than a byte and we
+  * get into potential aligment issues -- see the STORE macros below
+  */
+#define ACPI_GET8(addr)                 (*(u8*)(addr))
+
+/* Pointer arithmetic */
+
+#define ACPI_PTR_ADD(t,a,b)             (t *) (void *)((char *)(a) + (acpi_native_uint)(b))
+#define ACPI_PTR_DIFF(a,b)              (acpi_native_uint) ((char *)(a) - (char *)(b))
+
+/* Pointer/Integer type conversions */
+
+#define ACPI_TO_POINTER(i)              ACPI_PTR_ADD (void, (void *) NULL,(acpi_native_uint)i)
+#define ACPI_TO_INTEGER(p)              ACPI_PTR_DIFF (p,(void *) NULL)
+#define ACPI_OFFSET(d,f)                (acpi_size) ACPI_PTR_DIFF (&(((d *)0)->f),(void *) NULL)
+#define ACPI_FADT_OFFSET(f)             ACPI_OFFSET (FADT_DESCRIPTOR, f)
+
+#define ACPI_CAST_PTR(t, p)             ((t *)(void *)(p))
+#define ACPI_CAST_INDIRECT_PTR(t, p)    ((t **)(void *)(p))
+
+#if ACPI_MACHINE_WIDTH == 16
+#define ACPI_STORE_POINTER(d,s)         ACPI_MOVE_32_TO_32(d,s)
+#define ACPI_PHYSADDR_TO_PTR(i)         (void *)(i)
+#define ACPI_PTR_TO_PHYSADDR(i)         (u32) (char *)(i)
+#else
+#define ACPI_PHYSADDR_TO_PTR(i)         ACPI_TO_POINTER(i)
+#define ACPI_PTR_TO_PHYSADDR(i)         ACPI_TO_INTEGER(i)
+#endif
+
+/*
+ * Macros for moving data around to/from buffers that are possibly unaligned.
+ * If the hardware supports the transfer of unaligned data, just do the store.
+ * Otherwise, we have to move one byte at a time.
+ */
+
+#ifdef ACPI_BIG_ENDIAN
+/*
+ * Macros for big-endian machines
+ */
+
+/* This macro sets a buffer index, starting from the end of the buffer */
+
+#define ACPI_BUFFER_INDEX(buf_len,buf_offset,byte_gran) ((buf_len) - (((buf_offset)+1) * (byte_gran)))
+
+/* These macros reverse the bytes during the move, converting little-endian to big endian */
+
+	 /* Big Endian      <==        Little Endian */
+	 /*  Hi...Lo                     Lo...Hi     */
+/* 16-bit source, 16/32/64 destination */
+
+#define ACPI_MOVE_16_TO_16(d,s)         {((  u8 *)(void *)(d))[0] = ((u8 *)(void *)(s))[1];\
+			  ((  u8 *)(void *)(d))[1] = ((u8 *)(void *)(s))[0];}
+
+#define ACPI_MOVE_16_TO_32(d,s)         {(*(u32 *)(void *)(d))=0;\
+					  ((u8 *)(void *)(d))[2] = ((u8 *)(void *)(s))[1];\
+					  ((u8 *)(void *)(d))[3] = ((u8 *)(void *)(s))[0];}
+
+#define ACPI_MOVE_16_TO_64(d,s)         {(*(u64 *)(void *)(d))=0;\
+							   ((u8 *)(void *)(d))[6] = ((u8 *)(void *)(s))[1];\
+							   ((u8 *)(void *)(d))[7] = ((u8 *)(void *)(s))[0];}
+
+/* 32-bit source, 16/32/64 destination */
+
+#define ACPI_MOVE_32_TO_16(d,s)         ACPI_MOVE_16_TO_16(d,s)    /* Truncate to 16 */
+
+#define ACPI_MOVE_32_TO_32(d,s)         {((  u8 *)(void *)(d))[0] = ((u8 *)(void *)(s))[3];\
+									  ((  u8 *)(void *)(d))[1] = ((u8 *)(void *)(s))[2];\
+									  ((  u8 *)(void *)(d))[2] = ((u8 *)(void *)(s))[1];\
+									  ((  u8 *)(void *)(d))[3] = ((u8 *)(void *)(s))[0];}
+
+#define ACPI_MOVE_32_TO_64(d,s)         {(*(u64 *)(void *)(d))=0;\
+										   ((u8 *)(void *)(d))[4] = ((u8 *)(void *)(s))[3];\
+										   ((u8 *)(void *)(d))[5] = ((u8 *)(void *)(s))[2];\
+										   ((u8 *)(void *)(d))[6] = ((u8 *)(void *)(s))[1];\
+										   ((u8 *)(void *)(d))[7] = ((u8 *)(void *)(s))[0];}
+
+/* 64-bit source, 16/32/64 destination */
+
+#define ACPI_MOVE_64_TO_16(d,s)         ACPI_MOVE_16_TO_16(d,s)    /* Truncate to 16 */
+
+#define ACPI_MOVE_64_TO_32(d,s)         ACPI_MOVE_32_TO_32(d,s)    /* Truncate to 32 */
+
+#define ACPI_MOVE_64_TO_64(d,s)         {((  u8 *)(void *)(d))[0] = ((u8 *)(void *)(s))[7];\
+										 ((  u8 *)(void *)(d))[1] = ((u8 *)(void *)(s))[6];\
+										 ((  u8 *)(void *)(d))[2] = ((u8 *)(void *)(s))[5];\
+										 ((  u8 *)(void *)(d))[3] = ((u8 *)(void *)(s))[4];\
+										 ((  u8 *)(void *)(d))[4] = ((u8 *)(void *)(s))[3];\
+										 ((  u8 *)(void *)(d))[5] = ((u8 *)(void *)(s))[2];\
+										 ((  u8 *)(void *)(d))[6] = ((u8 *)(void *)(s))[1];\
+										 ((  u8 *)(void *)(d))[7] = ((u8 *)(void *)(s))[0];}
+#else
+/*
+ * Macros for little-endian machines
+ */
+
+/* This macro sets a buffer index, starting from the beginning of the buffer */
+
+#define ACPI_BUFFER_INDEX(buf_len,buf_offset,byte_gran) (buf_offset)
+
+#ifdef ACPI_MISALIGNED_TRANSFERS
+
+/* The hardware supports unaligned transfers, just do the little-endian move */
+
+#if ACPI_MACHINE_WIDTH == 16
+
+/* No 64-bit integers */
+/* 16-bit source, 16/32/64 destination */
+
+#define ACPI_MOVE_16_TO_16(d,s)         *(u16 *)(void *)(d) = *(u16 *)(void *)(s)
+#define ACPI_MOVE_16_TO_32(d,s)         *(u32 *)(void *)(d) = *(u16 *)(void *)(s)
+#define ACPI_MOVE_16_TO_64(d,s)         ACPI_MOVE_16_TO_32(d,s)
+
+/* 32-bit source, 16/32/64 destination */
+
+#define ACPI_MOVE_32_TO_16(d,s)         ACPI_MOVE_16_TO_16(d,s)    /* Truncate to 16 */
+#define ACPI_MOVE_32_TO_32(d,s)         *(u32 *)(void *)(d) = *(u32 *)(void *)(s)
+#define ACPI_MOVE_32_TO_64(d,s)         ACPI_MOVE_32_TO_32(d,s)
+
+/* 64-bit source, 16/32/64 destination */
+
+#define ACPI_MOVE_64_TO_16(d,s)         ACPI_MOVE_16_TO_16(d,s)    /* Truncate to 16 */
+#define ACPI_MOVE_64_TO_32(d,s)         ACPI_MOVE_32_TO_32(d,s)    /* Truncate to 32 */
+#define ACPI_MOVE_64_TO_64(d,s)         ACPI_MOVE_32_TO_32(d,s)
+
+#else
+/* 16-bit source, 16/32/64 destination */
+
+#define ACPI_MOVE_16_TO_16(d,s)         *(u16 *)(void *)(d) = *(u16 *)(void *)(s)
+#define ACPI_MOVE_16_TO_32(d,s)         *(u32 *)(void *)(d) = *(u16 *)(void *)(s)
+#define ACPI_MOVE_16_TO_64(d,s)         *(u64 *)(void *)(d) = *(u16 *)(void *)(s)
+
+/* 32-bit source, 16/32/64 destination */
+
+#define ACPI_MOVE_32_TO_16(d,s)         ACPI_MOVE_16_TO_16(d,s)    /* Truncate to 16 */
+#define ACPI_MOVE_32_TO_32(d,s)         *(u32 *)(void *)(d) = *(u32 *)(void *)(s)
+#define ACPI_MOVE_32_TO_64(d,s)         *(u64 *)(void *)(d) = *(u32 *)(void *)(s)
+
+/* 64-bit source, 16/32/64 destination */
+
+#define ACPI_MOVE_64_TO_16(d,s)         ACPI_MOVE_16_TO_16(d,s)    /* Truncate to 16 */
+#define ACPI_MOVE_64_TO_32(d,s)         ACPI_MOVE_32_TO_32(d,s)    /* Truncate to 32 */
+#define ACPI_MOVE_64_TO_64(d,s)         *(u64 *)(void *)(d) = *(u64 *)(void *)(s)
+#endif
+
+#else
+/*
+ * The hardware does not support unaligned transfers.  We must move the
+ * data one byte at a time.  These macros work whether the source or
+ * the destination (or both) is/are unaligned.  (Little-endian move)
+ */
+
+/* 16-bit source, 16/32/64 destination */
+
+#define ACPI_MOVE_16_TO_16(d,s)         {((  u8 *)(void *)(d))[0] = ((u8 *)(void *)(s))[0];\
+										 ((  u8 *)(void *)(d))[1] = ((u8 *)(void *)(s))[1];}
+
+#define ACPI_MOVE_16_TO_32(d,s)         {(*(u32 *)(void *)(d)) = 0; ACPI_MOVE_16_TO_16(d,s);}
+#define ACPI_MOVE_16_TO_64(d,s)         {(*(u64 *)(void *)(d)) = 0; ACPI_MOVE_16_TO_16(d,s);}
+
+/* 32-bit source, 16/32/64 destination */
+
+#define ACPI_MOVE_32_TO_16(d,s)         ACPI_MOVE_16_TO_16(d,s)    /* Truncate to 16 */
+
+#define ACPI_MOVE_32_TO_32(d,s)         {((  u8 *)(void *)(d))[0] = ((u8 *)(void *)(s))[0];\
+										 ((  u8 *)(void *)(d))[1] = ((u8 *)(void *)(s))[1];\
+										 ((  u8 *)(void *)(d))[2] = ((u8 *)(void *)(s))[2];\
+										 ((  u8 *)(void *)(d))[3] = ((u8 *)(void *)(s))[3];}
+
+#define ACPI_MOVE_32_TO_64(d,s)         {(*(u64 *)(void *)(d)) = 0; ACPI_MOVE_32_TO_32(d,s);}
+
+/* 64-bit source, 16/32/64 destination */
+
+#define ACPI_MOVE_64_TO_16(d,s)         ACPI_MOVE_16_TO_16(d,s)    /* Truncate to 16 */
+#define ACPI_MOVE_64_TO_32(d,s)         ACPI_MOVE_32_TO_32(d,s)    /* Truncate to 32 */
+#define ACPI_MOVE_64_TO_64(d,s)         {((  u8 *)(void *)(d))[0] = ((u8 *)(void *)(s))[0];\
+										 ((  u8 *)(void *)(d))[1] = ((u8 *)(void *)(s))[1];\
+										 ((  u8 *)(void *)(d))[2] = ((u8 *)(void *)(s))[2];\
+										 ((  u8 *)(void *)(d))[3] = ((u8 *)(void *)(s))[3];\
+										 ((  u8 *)(void *)(d))[4] = ((u8 *)(void *)(s))[4];\
+										 ((  u8 *)(void *)(d))[5] = ((u8 *)(void *)(s))[5];\
+										 ((  u8 *)(void *)(d))[6] = ((u8 *)(void *)(s))[6];\
+										 ((  u8 *)(void *)(d))[7] = ((u8 *)(void *)(s))[7];}
+#endif
+#endif
+
+/* Macros based on machine integer width */
+
+#if ACPI_MACHINE_WIDTH == 16
+#define ACPI_MOVE_SIZE_TO_16(d,s)       ACPI_MOVE_16_TO_16(d,s)
+
+#elif ACPI_MACHINE_WIDTH == 32
+#define ACPI_MOVE_SIZE_TO_16(d,s)       ACPI_MOVE_32_TO_16(d,s)
+
+#elif ACPI_MACHINE_WIDTH == 64
+#define ACPI_MOVE_SIZE_TO_16(d,s)       ACPI_MOVE_64_TO_16(d,s)
+
+#else
+#error unknown ACPI_MACHINE_WIDTH
+#endif
+
+
+/*
+ * Fast power-of-two math macros for non-optimized compilers
+ */
+
+#define _ACPI_DIV(value,power_of2)      ((u32) ((value) >> (power_of2)))
+#define _ACPI_MUL(value,power_of2)      ((u32) ((value) << (power_of2)))
+#define _ACPI_MOD(value,divisor)        ((u32) ((value) & ((divisor) -1)))
+
+#define ACPI_DIV_2(a)                   _ACPI_DIV(a,1)
+#define ACPI_MUL_2(a)                   _ACPI_MUL(a,1)
+#define ACPI_MOD_2(a)                   _ACPI_MOD(a,2)
+
+#define ACPI_DIV_4(a)                   _ACPI_DIV(a,2)
+#define ACPI_MUL_4(a)                   _ACPI_MUL(a,2)
+#define ACPI_MOD_4(a)                   _ACPI_MOD(a,4)
+
+#define ACPI_DIV_8(a)                   _ACPI_DIV(a,3)
+#define ACPI_MUL_8(a)                   _ACPI_MUL(a,3)
+#define ACPI_MOD_8(a)                   _ACPI_MOD(a,8)
+
+#define ACPI_DIV_16(a)                  _ACPI_DIV(a,4)
+#define ACPI_MUL_16(a)                  _ACPI_MUL(a,4)
+#define ACPI_MOD_16(a)                  _ACPI_MOD(a,16)
+
+
+/*
+ * Rounding macros (Power of two boundaries only)
+ */
+#define ACPI_ROUND_DOWN(value,boundary)      (((acpi_native_uint)(value)) & (~(((acpi_native_uint) boundary)-1)))
+#define ACPI_ROUND_UP(value,boundary)        ((((acpi_native_uint)(value)) + (((acpi_native_uint) boundary)-1)) & (~(((acpi_native_uint) boundary)-1)))
+
+#define ACPI_ROUND_DOWN_TO_32_BITS(a)        ACPI_ROUND_DOWN(a,4)
+#define ACPI_ROUND_DOWN_TO_64_BITS(a)        ACPI_ROUND_DOWN(a,8)
+#define ACPI_ROUND_DOWN_TO_NATIVE_WORD(a)    ACPI_ROUND_DOWN(a,ALIGNED_ADDRESS_BOUNDARY)
+
+#define ACPI_ROUND_UP_to_32_bITS(a)          ACPI_ROUND_UP(a,4)
+#define ACPI_ROUND_UP_to_64_bITS(a)          ACPI_ROUND_UP(a,8)
+#define ACPI_ROUND_UP_TO_NATIVE_WORD(a)      ACPI_ROUND_UP(a,ALIGNED_ADDRESS_BOUNDARY)
+
+
+#define ACPI_ROUND_BITS_UP_TO_BYTES(a)       ACPI_DIV_8((a) + 7)
+#define ACPI_ROUND_BITS_DOWN_TO_BYTES(a)     ACPI_DIV_8((a))
+
+#define ACPI_ROUND_UP_TO_1K(a)               (((a) + 1023) >> 10)
+
+/* Generic (non-power-of-two) rounding */
+
+#define ACPI_ROUND_UP_TO(value,boundary)     (((value) + ((boundary)-1)) / (boundary))
+
+/*
+ * Bitmask creation
+ * Bit positions start at zero.
+ * MASK_BITS_ABOVE creates a mask starting AT the position and above
+ * MASK_BITS_BELOW creates a mask starting one bit BELOW the position
+ */
+#define ACPI_MASK_BITS_ABOVE(position)       (~((ACPI_INTEGER_MAX) << ((u32) (position))))
+#define ACPI_MASK_BITS_BELOW(position)       ((ACPI_INTEGER_MAX) << ((u32) (position)))
+
+#define ACPI_IS_OCTAL_DIGIT(d)               (((char)(d) >= '0') && ((char)(d) <= '7'))
+
+/* Macros for GAS addressing */
+
+#if ACPI_MACHINE_WIDTH != 16
+
+#define ACPI_PCI_DEVICE(a)              (u16) ((ACPI_HIDWORD ((a))) & 0x0000FFFF)
+#define ACPI_PCI_FUNCTION(a)            (u16) ((ACPI_LODWORD ((a))) >> 16)
+#define ACPI_PCI_REGISTER(a)            (u16) ((ACPI_LODWORD ((a))) & 0x0000FFFF)
+
+#else
+
+/* No support for GAS and PCI IDs in 16-bit mode  */
+
+#define ACPI_PCI_FUNCTION(a)            (u16) ((a) & 0xFFFF0000)
+#define ACPI_PCI_DEVICE(a)              (u16) ((a) & 0x0000FFFF)
+#define ACPI_PCI_REGISTER(a)            (u16) ((a) & 0x0000FFFF)
+
+#endif
+
+
+/* Bitfields within ACPI registers */
+
+#define ACPI_REGISTER_PREPARE_BITS(val, pos, mask)      ((val << pos) & mask)
+#define ACPI_REGISTER_INSERT_VALUE(reg, pos, mask, val)  reg = (reg & (~(mask))) | ACPI_REGISTER_PREPARE_BITS(val, pos, mask)
+
+/*
+ * An struct acpi_namespace_node * can appear in some contexts,
+ * where a pointer to an union acpi_operand_object    can also
+ * appear.  This macro is used to distinguish them.
+ *
+ * The "Descriptor" field is the first field in both structures.
+ */
+#define ACPI_GET_DESCRIPTOR_TYPE(d)     (((union acpi_descriptor *)(void *)(d))->descriptor_id)
+#define ACPI_SET_DESCRIPTOR_TYPE(d,t)   (((union acpi_descriptor *)(void *)(d))->descriptor_id = t)
+
+
+/* Macro to test the object type */
+
+#define ACPI_GET_OBJECT_TYPE(d)         (((union acpi_operand_object *)(void *)(d))->common.type)
+
+/* Macro to check the table flags for SINGLE or MULTIPLE tables are allowed */
+
+#define ACPI_IS_SINGLE_TABLE(x)         (((x) & 0x01) == ACPI_TABLE_SINGLE ? 1 : 0)
+
+/*
+ * Macros for the master AML opcode table
+ */
+#if defined(ACPI_DISASSEMBLER) || defined (ACPI_DEBUG_OUTPUT)
+#define ACPI_OP(name,Pargs,Iargs,obj_type,class,type,flags)    {name,(u32)(Pargs),(u32)(Iargs),(u32)(flags),obj_type,class,type}
+#else
+#define ACPI_OP(name,Pargs,Iargs,obj_type,class,type,flags)    {(u32)(Pargs),(u32)(Iargs),(u32)(flags),obj_type,class,type}
+#endif
+
+#ifdef ACPI_DISASSEMBLER
+#define ACPI_DISASM_ONLY_MEMBERS(a)     a;
+#else
+#define ACPI_DISASM_ONLY_MEMBERS(a)
+#endif
+
+#define ARG_TYPE_WIDTH                  5
+#define ARG_1(x)                        ((u32)(x))
+#define ARG_2(x)                        ((u32)(x) << (1 * ARG_TYPE_WIDTH))
+#define ARG_3(x)                        ((u32)(x) << (2 * ARG_TYPE_WIDTH))
+#define ARG_4(x)                        ((u32)(x) << (3 * ARG_TYPE_WIDTH))
+#define ARG_5(x)                        ((u32)(x) << (4 * ARG_TYPE_WIDTH))
+#define ARG_6(x)                        ((u32)(x) << (5 * ARG_TYPE_WIDTH))
+
+#define ARGI_LIST1(a)                   (ARG_1(a))
+#define ARGI_LIST2(a,b)                 (ARG_1(b)|ARG_2(a))
+#define ARGI_LIST3(a,b,c)               (ARG_1(c)|ARG_2(b)|ARG_3(a))
+#define ARGI_LIST4(a,b,c,d)             (ARG_1(d)|ARG_2(c)|ARG_3(b)|ARG_4(a))
+#define ARGI_LIST5(a,b,c,d,e)           (ARG_1(e)|ARG_2(d)|ARG_3(c)|ARG_4(b)|ARG_5(a))
+#define ARGI_LIST6(a,b,c,d,e,f)         (ARG_1(f)|ARG_2(e)|ARG_3(d)|ARG_4(c)|ARG_5(b)|ARG_6(a))
+
+#define ARGP_LIST1(a)                   (ARG_1(a))
+#define ARGP_LIST2(a,b)                 (ARG_1(a)|ARG_2(b))
+#define ARGP_LIST3(a,b,c)               (ARG_1(a)|ARG_2(b)|ARG_3(c))
+#define ARGP_LIST4(a,b,c,d)             (ARG_1(a)|ARG_2(b)|ARG_3(c)|ARG_4(d))
+#define ARGP_LIST5(a,b,c,d,e)           (ARG_1(a)|ARG_2(b)|ARG_3(c)|ARG_4(d)|ARG_5(e))
+#define ARGP_LIST6(a,b,c,d,e,f)         (ARG_1(a)|ARG_2(b)|ARG_3(c)|ARG_4(d)|ARG_5(e)|ARG_6(f))
+
+#define GET_CURRENT_ARG_TYPE(list)      (list & ((u32) 0x1F))
+#define INCREMENT_ARG_LIST(list)        (list >>= ((u32) ARG_TYPE_WIDTH))
+
+
+/*
+ * Reporting macros that are never compiled out
+ */
+
+#define ACPI_PARAM_LIST(pl)                 pl
+
+/*
+ * Error reporting.  These versions add callers module and line#.  Since
+ * _THIS_MODULE gets compiled out when ACPI_DEBUG_OUTPUT isn't defined, only
+ * use it in debug mode.
+ */
+
+#ifdef ACPI_DEBUG_OUTPUT
+
+#define ACPI_REPORT_INFO(fp)                {acpi_ut_report_info(_THIS_MODULE,__LINE__,_COMPONENT); \
+												acpi_os_printf ACPI_PARAM_LIST(fp);}
+#define ACPI_REPORT_ERROR(fp)               {acpi_ut_report_error(_THIS_MODULE,__LINE__,_COMPONENT); \
+												acpi_os_printf ACPI_PARAM_LIST(fp);}
+#define ACPI_REPORT_WARNING(fp)             {acpi_ut_report_warning(_THIS_MODULE,__LINE__,_COMPONENT); \
+												acpi_os_printf ACPI_PARAM_LIST(fp);}
+#define ACPI_REPORT_NSERROR(s,e)            acpi_ns_report_error(_THIS_MODULE,__LINE__,_COMPONENT, s, e);
+
+#define ACPI_REPORT_METHOD_ERROR(s,n,p,e)   acpi_ns_report_method_error(_THIS_MODULE,__LINE__,_COMPONENT, s, n, p, e);
+
+#else
+
+#define ACPI_REPORT_INFO(fp)                {acpi_ut_report_info("ACPI",__LINE__,_COMPONENT); \
+												acpi_os_printf ACPI_PARAM_LIST(fp);}
+#define ACPI_REPORT_ERROR(fp)               {acpi_ut_report_error("ACPI",__LINE__,_COMPONENT); \
+												acpi_os_printf ACPI_PARAM_LIST(fp);}
+#define ACPI_REPORT_WARNING(fp)             {acpi_ut_report_warning("ACPI",__LINE__,_COMPONENT); \
+												acpi_os_printf ACPI_PARAM_LIST(fp);}
+#define ACPI_REPORT_NSERROR(s,e)            acpi_ns_report_error("ACPI",__LINE__,_COMPONENT, s, e);
+
+#define ACPI_REPORT_METHOD_ERROR(s,n,p,e)   acpi_ns_report_method_error("ACPI",__LINE__,_COMPONENT, s, n, p, e);
+
+#endif
+
+/* Error reporting.  These versions pass thru the module and line# */
+
+#define _ACPI_REPORT_INFO(a,b,c,fp)         {acpi_ut_report_info(a,b,c); \
+												acpi_os_printf ACPI_PARAM_LIST(fp);}
+#define _ACPI_REPORT_ERROR(a,b,c,fp)        {acpi_ut_report_error(a,b,c); \
+												acpi_os_printf ACPI_PARAM_LIST(fp);}
+#define _ACPI_REPORT_WARNING(a,b,c,fp)      {acpi_ut_report_warning(a,b,c); \
+												acpi_os_printf ACPI_PARAM_LIST(fp);}
+
+/*
+ * Debug macros that are conditionally compiled
+ */
+
+#ifdef ACPI_DEBUG_OUTPUT
+
+#define ACPI_MODULE_NAME(name)               static char ACPI_UNUSED_VAR *_THIS_MODULE = name;
+
+/*
+ * Function entry tracing.
+ * The first parameter should be the procedure name as a quoted string.  This is declared
+ * as a local string ("_proc_name) so that it can be also used by the function exit macros below.
+ */
+
+#define ACPI_FUNCTION_NAME(a)               struct acpi_debug_print_info _dbg; \
+												_dbg.component_id = _COMPONENT; \
+												_dbg.proc_name   = a; \
+												_dbg.module_name = _THIS_MODULE;
+
+#define ACPI_FUNCTION_TRACE(a)              ACPI_FUNCTION_NAME(a) \
+												acpi_ut_trace(__LINE__,&_dbg)
+#define ACPI_FUNCTION_TRACE_PTR(a,b)        ACPI_FUNCTION_NAME(a) \
+												acpi_ut_trace_ptr(__LINE__,&_dbg,(void *)b)
+#define ACPI_FUNCTION_TRACE_U32(a,b)        ACPI_FUNCTION_NAME(a) \
+												acpi_ut_trace_u32(__LINE__,&_dbg,(u32)b)
+#define ACPI_FUNCTION_TRACE_STR(a,b)        ACPI_FUNCTION_NAME(a) \
+												acpi_ut_trace_str(__LINE__,&_dbg,(char *)b)
+
+#define ACPI_FUNCTION_ENTRY()               acpi_ut_track_stack_ptr()
+
+/*
+ * Function exit tracing.
+ * WARNING: These macros include a return statement.  This is usually considered
+ * bad form, but having a separate exit macro is very ugly and difficult to maintain.
+ * One of the FUNCTION_TRACE macros above must be used in conjunction with these macros
+ * so that "_proc_name" is defined.
+ */
+#ifdef ACPI_USE_DO_WHILE_0
+#define ACPI_DO_WHILE0(a)               do a while(0)
+#else
+#define ACPI_DO_WHILE0(a)               a
+#endif
+
+#define return_VOID                     ACPI_DO_WHILE0 ({acpi_ut_exit(__LINE__,&_dbg);return;})
+#define return_ACPI_STATUS(s)           ACPI_DO_WHILE0 ({acpi_ut_status_exit(__LINE__,&_dbg,(s));return((s));})
+#define return_VALUE(s)                 ACPI_DO_WHILE0 ({acpi_ut_value_exit(__LINE__,&_dbg,(acpi_integer)(s));return((s));})
+#define return_PTR(s)                   ACPI_DO_WHILE0 ({acpi_ut_ptr_exit(__LINE__,&_dbg,(u8 *)(s));return((s));})
+
+/* Conditional execution */
+
+#define ACPI_DEBUG_EXEC(a)              a
+#define ACPI_NORMAL_EXEC(a)
+
+#define ACPI_DEBUG_DEFINE(a)            a;
+#define ACPI_DEBUG_ONLY_MEMBERS(a)      a;
+#define _VERBOSE_STRUCTURES
+
+
+/* Stack and buffer dumping */
+
+#define ACPI_DUMP_STACK_ENTRY(a)        acpi_ex_dump_operand(a)
+#define ACPI_DUMP_OPERANDS(a,b,c,d,e)   acpi_ex_dump_operands(a,b,c,d,e,_THIS_MODULE,__LINE__)
+
+
+#define ACPI_DUMP_ENTRY(a,b)            acpi_ns_dump_entry (a,b)
+#define ACPI_DUMP_TABLES(a,b)           acpi_ns_dump_tables(a,b)
+#define ACPI_DUMP_PATHNAME(a,b,c,d)     acpi_ns_dump_pathname(a,b,c,d)
+#define ACPI_DUMP_RESOURCE_LIST(a)      acpi_rs_dump_resource_list(a)
+#define ACPI_DUMP_BUFFER(a,b)           acpi_ut_dump_buffer((u8 *)a,b,DB_BYTE_DISPLAY,_COMPONENT)
+#define ACPI_BREAK_MSG(a)               acpi_os_signal (ACPI_SIGNAL_BREAKPOINT,(a))
+
+
+/*
+ * Generate INT3 on ACPI_ERROR (Debug only!)
+ */
+
+#define ACPI_ERROR_BREAK
+#ifdef  ACPI_ERROR_BREAK
+#define ACPI_BREAK_ON_ERROR(lvl)        if ((lvl)&ACPI_ERROR) \
+											acpi_os_signal(ACPI_SIGNAL_BREAKPOINT,"Fatal error encountered\n")
+#else
+#define ACPI_BREAK_ON_ERROR(lvl)
+#endif
+
+/*
+ * Master debug print macros
+ * Print iff:
+ *    1) Debug print for the current component is enabled
+ *    2) Debug error level or trace level for the print statement is enabled
+ */
+
+#define ACPI_DEBUG_PRINT(pl)            acpi_ut_debug_print ACPI_PARAM_LIST(pl)
+#define ACPI_DEBUG_PRINT_RAW(pl)        acpi_ut_debug_print_raw ACPI_PARAM_LIST(pl)
+
+
+#else
+/*
+ * This is the non-debug case -- make everything go away,
+ * leaving no executable debug code!
+ */
+
+#define ACPI_MODULE_NAME(name)
+#define _THIS_MODULE ""
+
+#define ACPI_DEBUG_EXEC(a)
+#define ACPI_NORMAL_EXEC(a)             a;
+
+#define ACPI_DEBUG_DEFINE(a)
+#define ACPI_DEBUG_ONLY_MEMBERS(a)
+#define ACPI_FUNCTION_NAME(a)
+#define ACPI_FUNCTION_TRACE(a)
+#define ACPI_FUNCTION_TRACE_PTR(a,b)
+#define ACPI_FUNCTION_TRACE_U32(a,b)
+#define ACPI_FUNCTION_TRACE_STR(a,b)
+#define ACPI_FUNCTION_EXIT
+#define ACPI_FUNCTION_STATUS_EXIT(s)
+#define ACPI_FUNCTION_VALUE_EXIT(s)
+#define ACPI_FUNCTION_ENTRY()
+#define ACPI_DUMP_STACK_ENTRY(a)
+#define ACPI_DUMP_OPERANDS(a,b,c,d,e)
+#define ACPI_DUMP_ENTRY(a,b)
+#define ACPI_DUMP_TABLES(a,b)
+#define ACPI_DUMP_PATHNAME(a,b,c,d)
+#define ACPI_DUMP_RESOURCE_LIST(a)
+#define ACPI_DUMP_BUFFER(a,b)
+#define ACPI_DEBUG_PRINT(pl)
+#define ACPI_DEBUG_PRINT_RAW(pl)
+#define ACPI_BREAK_MSG(a)
+
+#define return_VOID                     return
+#define return_ACPI_STATUS(s)           return(s)
+#define return_VALUE(s)                 return(s)
+#define return_PTR(s)                   return(s)
+
+#endif
+
+/*
+ * Some code only gets executed when the debugger is built in.
+ * Note that this is entirely independent of whether the
+ * DEBUG_PRINT stuff (set by ACPI_DEBUG_OUTPUT) is on, or not.
+ */
+#ifdef ACPI_DEBUGGER
+#define ACPI_DEBUGGER_EXEC(a)           a
+#else
+#define ACPI_DEBUGGER_EXEC(a)
+#endif
+
+
+/*
+ * For 16-bit code, we want to shrink some things even though
+ * we are using ACPI_DEBUG_OUTPUT to get the debug output
+ */
+#if ACPI_MACHINE_WIDTH == 16
+#undef ACPI_DEBUG_ONLY_MEMBERS
+#undef _VERBOSE_STRUCTURES
+#define ACPI_DEBUG_ONLY_MEMBERS(a)
+#endif
+
+
+#ifdef ACPI_DEBUG_OUTPUT
+/*
+ * 1) Set name to blanks
+ * 2) Copy the object name
+ */
+#define ACPI_ADD_OBJECT_NAME(a,b)       ACPI_MEMSET (a->common.name, ' ', sizeof (a->common.name));\
+										ACPI_STRNCPY (a->common.name, acpi_gbl_ns_type_names[b], sizeof (a->common.name))
+#else
+
+#define ACPI_ADD_OBJECT_NAME(a,b)
+#endif
+
+
+/*
+ * Memory allocation tracking (DEBUG ONLY)
+ */
+
+#ifndef ACPI_DBG_TRACK_ALLOCATIONS
+
+/* Memory allocation */
+
+#define ACPI_MEM_ALLOCATE(a)            acpi_ut_allocate((acpi_size)(a),_COMPONENT,_THIS_MODULE,__LINE__)
+#define ACPI_MEM_CALLOCATE(a)           acpi_ut_callocate((acpi_size)(a), _COMPONENT,_THIS_MODULE,__LINE__)
+#define ACPI_MEM_FREE(a)                acpi_os_free(a)
+#define ACPI_MEM_TRACKING(a)
+
+
+#else
+
+/* Memory allocation */
+
+#define ACPI_MEM_ALLOCATE(a)            acpi_ut_allocate_and_track((acpi_size)(a),_COMPONENT,_THIS_MODULE,__LINE__)
+#define ACPI_MEM_CALLOCATE(a)           acpi_ut_callocate_and_track((acpi_size)(a), _COMPONENT,_THIS_MODULE,__LINE__)
+#define ACPI_MEM_FREE(a)                acpi_ut_free_and_track(a,_COMPONENT,_THIS_MODULE,__LINE__)
+#define ACPI_MEM_TRACKING(a)            a
+
+#endif /* ACPI_DBG_TRACK_ALLOCATIONS */
+
+
+#define ACPI_GET_STACK_POINTER          _asm {mov eax, ebx}
+
+#endif /* ACMACROS_H */
diff -urNp linux-5400/include/acpi/acnamesp.h linux-5410/include/acpi/acnamesp.h
--- linux-5400/include/acpi/acnamesp.h
+++ linux-5410/include/acpi/acnamesp.h
@@ -0,0 +1,513 @@
+/******************************************************************************
+ *
+ * Name: acnamesp.h - Namespace subcomponent prototypes and defines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACNAMESP_H__
+#define __ACNAMESP_H__
+
+
+/* To search the entire name space, pass this as search_base */
+
+#define ACPI_NS_ALL                 ((acpi_handle)0)
+
+/*
+ * Elements of acpi_ns_properties are bit significant
+ * and should be one-to-one with values of acpi_object_type
+ */
+#define ACPI_NS_NORMAL              0
+#define ACPI_NS_NEWSCOPE            1   /* a definition of this type opens a name scope */
+#define ACPI_NS_LOCAL               2   /* suppress search of enclosing scopes */
+
+
+/* Definitions of the predefined namespace names  */
+
+#define ACPI_UNKNOWN_NAME           (u32) 0x3F3F3F3F     /* Unknown name is  "????" */
+#define ACPI_ROOT_NAME              (u32) 0x5F5F5F5C     /* Root name is     "\___" */
+#define ACPI_SYS_BUS_NAME           (u32) 0x5F53425F     /* Sys bus name is  "_SB_" */
+
+#define ACPI_NS_ROOT_PATH           "\\"
+#define ACPI_NS_SYSTEM_BUS          "_SB_"
+
+
+/* Flags for acpi_ns_lookup, acpi_ns_search_and_enter */
+
+#define ACPI_NS_NO_UPSEARCH         0
+#define ACPI_NS_SEARCH_PARENT       0x01
+#define ACPI_NS_DONT_OPEN_SCOPE     0x02
+#define ACPI_NS_NO_PEER_SEARCH      0x04
+#define ACPI_NS_ERROR_IF_FOUND      0x08
+
+#define ACPI_NS_WALK_UNLOCK         TRUE
+#define ACPI_NS_WALK_NO_UNLOCK      FALSE
+
+
+acpi_status
+acpi_ns_load_namespace (
+	void);
+
+acpi_status
+acpi_ns_initialize_objects (
+	void);
+
+acpi_status
+acpi_ns_initialize_devices (
+	void);
+
+
+/* Namespace init - nsxfinit */
+
+acpi_status
+acpi_ns_init_one_device (
+	acpi_handle                     obj_handle,
+	u32                             nesting_level,
+	void                            *context,
+	void                            **return_value);
+
+acpi_status
+acpi_ns_init_one_object (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *context,
+	void                            **return_value);
+
+
+acpi_status
+acpi_ns_walk_namespace (
+	acpi_object_type                type,
+	acpi_handle                     start_object,
+	u32                             max_depth,
+	u8                              unlock_before_callback,
+	acpi_walk_callback              user_function,
+	void                            *context,
+	void                            **return_value);
+
+struct acpi_namespace_node *
+acpi_ns_get_next_node (
+	acpi_object_type                type,
+	struct acpi_namespace_node      *parent,
+	struct acpi_namespace_node      *child);
+
+void
+acpi_ns_delete_namespace_by_owner (
+	u16                             table_id);
+
+
+/* Namespace loading - nsload */
+
+acpi_status
+acpi_ns_one_complete_parse (
+	u32                             pass_number,
+	struct acpi_table_desc          *table_desc);
+
+acpi_status
+acpi_ns_parse_table (
+	struct acpi_table_desc          *table_desc,
+	struct acpi_namespace_node      *scope);
+
+acpi_status
+acpi_ns_load_table (
+	struct acpi_table_desc          *table_desc,
+	struct acpi_namespace_node      *node);
+
+acpi_status
+acpi_ns_load_table_by_type (
+	acpi_table_type                 table_type);
+
+
+/*
+ * Top-level namespace access - nsaccess
+ */
+
+acpi_status
+acpi_ns_root_initialize (
+	void);
+
+acpi_status
+acpi_ns_lookup (
+	union acpi_generic_state        *scope_info,
+	char                            *name,
+	acpi_object_type                type,
+	acpi_interpreter_mode           interpreter_mode,
+	u32                             flags,
+	struct acpi_walk_state          *walk_state,
+	struct acpi_namespace_node      **ret_node);
+
+
+/*
+ * Named object allocation/deallocation - nsalloc
+ */
+
+struct acpi_namespace_node *
+acpi_ns_create_node (
+	u32                             name);
+
+void
+acpi_ns_delete_node (
+	struct acpi_namespace_node      *node);
+
+void
+acpi_ns_delete_namespace_subtree (
+	struct acpi_namespace_node      *parent_handle);
+
+void
+acpi_ns_detach_object (
+	struct acpi_namespace_node      *node);
+
+void
+acpi_ns_delete_children (
+	struct acpi_namespace_node      *parent);
+
+int
+acpi_ns_compare_names (
+	char                            *name1,
+	char                            *name2);
+
+void
+acpi_ns_remove_reference (
+	struct acpi_namespace_node      *node);
+
+
+/*
+ * Namespace modification - nsmodify
+ */
+
+acpi_status
+acpi_ns_unload_namespace (
+	acpi_handle                     handle);
+
+acpi_status
+acpi_ns_delete_subtree (
+	acpi_handle                     start_handle);
+
+
+/*
+ * Namespace dump/print utilities - nsdump
+ */
+
+void
+acpi_ns_dump_tables (
+	acpi_handle                     search_base,
+	u32                             max_depth);
+
+void
+acpi_ns_dump_entry (
+	acpi_handle                     handle,
+	u32                             debug_level);
+
+void
+acpi_ns_dump_pathname (
+	acpi_handle                     handle,
+	char                            *msg,
+	u32                             level,
+	u32                             component);
+
+void
+acpi_ns_print_pathname (
+	u32                             num_segments,
+	char                            *pathname);
+
+acpi_status
+acpi_ns_dump_one_device (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *context,
+	void                            **return_value);
+
+void
+acpi_ns_dump_root_devices (
+	void);
+
+acpi_status
+acpi_ns_dump_one_object (
+	acpi_handle                     obj_handle,
+	u32                             level,
+	void                            *context,
+	void                            **return_value);
+
+void
+acpi_ns_dump_objects (
+	acpi_object_type                type,
+	u8                              display_type,
+	u32                             max_depth,
+	u32                             ownder_id,
+	acpi_handle                     start_handle);
+
+
+/*
+ * Namespace evaluation functions - nseval
+ */
+
+acpi_status
+acpi_ns_evaluate_by_handle (
+	struct acpi_namespace_node      *prefix_node,
+	union acpi_operand_object       **params,
+	union acpi_operand_object       **return_object);
+
+acpi_status
+acpi_ns_evaluate_by_name (
+	char                            *pathname,
+	union acpi_operand_object       **params,
+	union acpi_operand_object       **return_object);
+
+acpi_status
+acpi_ns_evaluate_relative (
+	struct acpi_namespace_node      *prefix_node,
+	char                            *pathname,
+	union acpi_operand_object       **params,
+	union acpi_operand_object       **return_object);
+
+acpi_status
+acpi_ns_execute_control_method (
+	struct acpi_namespace_node      *method_node,
+	union acpi_operand_object       **params,
+	union acpi_operand_object       **return_obj_desc);
+
+acpi_status
+acpi_ns_get_object_value (
+	struct acpi_namespace_node      *object_node,
+	union acpi_operand_object       **return_obj_desc);
+
+
+/*
+ * Parent/Child/Peer utility functions
+ */
+
+acpi_name
+acpi_ns_find_parent_name (
+	struct acpi_namespace_node      *node_to_search);
+
+
+/*
+ * Name and Scope manipulation - nsnames
+ */
+
+u32
+acpi_ns_opens_scope (
+	acpi_object_type                type);
+
+void
+acpi_ns_build_external_path (
+	struct acpi_namespace_node      *node,
+	acpi_size                       size,
+	char                            *name_buffer);
+
+char *
+acpi_ns_get_external_pathname (
+	struct acpi_namespace_node      *node);
+
+char *
+acpi_ns_name_of_current_scope (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ns_handle_to_pathname (
+	acpi_handle                     target_handle,
+	struct acpi_buffer              *buffer);
+
+u8
+acpi_ns_pattern_match (
+	struct acpi_namespace_node      *obj_node,
+	char                            *search_for);
+
+acpi_status
+acpi_ns_get_node_by_path (
+	char                            *external_pathname,
+	struct acpi_namespace_node      *in_prefix_node,
+	u32                             flags,
+	struct acpi_namespace_node      **out_node);
+
+acpi_size
+acpi_ns_get_pathname_length (
+	struct acpi_namespace_node      *node);
+
+
+/*
+ * Object management for namespace nodes - nsobject
+ */
+
+acpi_status
+acpi_ns_attach_object (
+	struct acpi_namespace_node      *node,
+	union acpi_operand_object       *object,
+	acpi_object_type                type);
+
+union acpi_operand_object *
+acpi_ns_get_attached_object (
+	struct acpi_namespace_node      *node);
+
+union acpi_operand_object *
+acpi_ns_get_secondary_object (
+	union acpi_operand_object       *obj_desc);
+
+acpi_status
+acpi_ns_attach_data (
+	struct acpi_namespace_node      *node,
+	acpi_object_handler             handler,
+	void                            *data);
+
+acpi_status
+acpi_ns_detach_data (
+	struct acpi_namespace_node      *node,
+	acpi_object_handler             handler);
+
+acpi_status
+acpi_ns_get_attached_data (
+	struct acpi_namespace_node      *node,
+	acpi_object_handler             handler,
+	void                            **data);
+
+
+/*
+ * Namespace searching and entry - nssearch
+ */
+
+acpi_status
+acpi_ns_search_and_enter (
+	u32                             entry_name,
+	struct acpi_walk_state          *walk_state,
+	struct acpi_namespace_node      *node,
+	acpi_interpreter_mode           interpreter_mode,
+	acpi_object_type                type,
+	u32                             flags,
+	struct acpi_namespace_node      **ret_node);
+
+acpi_status
+acpi_ns_search_node (
+	u32                             entry_name,
+	struct acpi_namespace_node      *node,
+	acpi_object_type                type,
+	struct acpi_namespace_node      **ret_node);
+
+void
+acpi_ns_install_node (
+	struct acpi_walk_state          *walk_state,
+	struct acpi_namespace_node      *parent_node,
+	struct acpi_namespace_node      *node,
+	acpi_object_type                type);
+
+
+/*
+ * Utility functions - nsutils
+ */
+
+u8
+acpi_ns_valid_root_prefix (
+	char                            prefix);
+
+u8
+acpi_ns_valid_path_separator (
+	char                            sep);
+
+acpi_object_type
+acpi_ns_get_type (
+	struct acpi_namespace_node      *node);
+
+u32
+acpi_ns_local (
+	acpi_object_type                type);
+
+void
+acpi_ns_report_error (
+	char                            *module_name,
+	u32                             line_number,
+	u32                             component_id,
+	char                            *internal_name,
+	acpi_status                     lookup_status);
+
+void
+acpi_ns_report_method_error (
+	char                            *module_name,
+	u32                             line_number,
+	u32                             component_id,
+	char                            *message,
+	struct acpi_namespace_node      *node,
+	char                            *path,
+	acpi_status                     lookup_status);
+
+void
+acpi_ns_print_node_pathname (
+	struct acpi_namespace_node      *node,
+	char                            *msg);
+
+acpi_status
+acpi_ns_build_internal_name (
+	struct acpi_namestring_info     *info);
+
+void
+acpi_ns_get_internal_name_length (
+	struct acpi_namestring_info     *info);
+
+acpi_status
+acpi_ns_internalize_name (
+	char                            *dotted_name,
+	char                            **converted_name);
+
+acpi_status
+acpi_ns_externalize_name (
+	u32                             internal_name_length,
+	char                            *internal_name,
+	u32                             *converted_name_length,
+	char                            **converted_name);
+
+struct acpi_namespace_node *
+acpi_ns_map_handle_to_node (
+	acpi_handle                     handle);
+
+acpi_handle
+acpi_ns_convert_entry_to_handle(
+	struct acpi_namespace_node      *node);
+
+void
+acpi_ns_terminate (
+	void);
+
+struct acpi_namespace_node *
+acpi_ns_get_parent_node (
+	struct acpi_namespace_node      *node);
+
+
+struct acpi_namespace_node *
+acpi_ns_get_next_valid_node (
+	struct acpi_namespace_node      *node);
+
+
+#endif /* __ACNAMESP_H__ */
diff -urNp linux-5400/include/acpi/acobject.h linux-5410/include/acpi/acobject.h
--- linux-5400/include/acpi/acobject.h
+++ linux-5410/include/acpi/acobject.h
@@ -0,0 +1,493 @@
+
+/******************************************************************************
+ *
+ * Name: acobject.h - Definition of union acpi_operand_object    (Internal object only)
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef _ACOBJECT_H
+#define _ACOBJECT_H
+
+
+/*
+ * The union acpi_operand_object    is used to pass AML operands from the dispatcher
+ * to the interpreter, and to keep track of the various handlers such as
+ * address space handlers and notify handlers.  The object is a constant
+ * size in order to allow it to be cached and reused.
+ */
+
+/*******************************************************************************
+ *
+ * Common Descriptors
+ *
+ ******************************************************************************/
+
+/*
+ * Common area for all objects.
+ *
+ * data_type is used to differentiate between internal descriptors, and MUST
+ * be the first byte in this structure.
+ */
+#define ACPI_OBJECT_COMMON_HEADER   /* SIZE/ALIGNMENT: 32 bits, one ptr plus trailing 8-bit flag */\
+	u8                                      descriptor;         /* To differentiate various internal objs */\
+	u8                                      type;               /* acpi_object_type */\
+	u16                                     reference_count;    /* For object deletion management */\
+	union acpi_operand_object               *next_object;       /* Objects linked to parent NS node */\
+	u8                                      flags; \
+
+/* Values for flag byte above */
+
+#define AOPOBJ_AML_CONSTANT         0x01
+#define AOPOBJ_STATIC_POINTER       0x02
+#define AOPOBJ_DATA_VALID           0x04
+#define AOPOBJ_OBJECT_INITIALIZED   0x08
+#define AOPOBJ_SETUP_COMPLETE       0x10
+#define AOPOBJ_SINGLE_DATUM         0x20
+
+
+/*
+ * Common bitfield for the field objects
+ * "Field Datum"  -- a datum from the actual field object
+ * "Buffer Datum" -- a datum from a user buffer, read from or to be written to the field
+ */
+#define ACPI_COMMON_FIELD_INFO      /* SIZE/ALIGNMENT: 24 bits + three 32-bit values */\
+	u8                                      field_flags;        /* Access, update, and lock bits */\
+	u8                                      attribute;          /* From access_as keyword */\
+	u8                                      access_byte_width;  /* Read/Write size in bytes */\
+	u32                                     bit_length;         /* Length of field in bits */\
+	u32                                     base_byte_offset;   /* Byte offset within containing object */\
+	u8                                      start_field_bit_offset;/* Bit offset within first field datum (0-63) */\
+	u8                                      datum_valid_bits;   /* Valid bit in first "Field datum" */\
+	u8                                      end_field_valid_bits; /* Valid bits in the last "field datum" */\
+	u8                                      end_buffer_valid_bits; /* Valid bits in the last "buffer datum" */\
+	u32                                     value;              /* Value to store into the Bank or Index register */\
+	struct acpi_namespace_node              *node;              /* Link back to parent node */
+
+
+/*
+ * Fields common to both Strings and Buffers
+ */
+#define ACPI_COMMON_BUFFER_INFO \
+	u32                                     length;
+
+
+/*
+ * Common fields for objects that support ASL notifications
+ */
+#define ACPI_COMMON_NOTIFY_INFO \
+	union acpi_operand_object               *system_notify;     /* Handler for system notifies */\
+	union acpi_operand_object               *device_notify;     /* Handler for driver notifies */\
+	union acpi_operand_object               *address_space;     /* Handler for Address space */
+
+
+/******************************************************************************
+ *
+ * Basic data types
+ *
+ *****************************************************************************/
+
+struct acpi_object_common
+{
+	ACPI_OBJECT_COMMON_HEADER
+};
+
+
+struct acpi_object_integer
+{
+	ACPI_OBJECT_COMMON_HEADER
+	acpi_integer                            value;
+};
+
+
+struct acpi_object_string           /* Null terminated, ASCII characters only */
+{
+	ACPI_OBJECT_COMMON_HEADER
+	ACPI_COMMON_BUFFER_INFO
+	char                                    *pointer;           /* String in AML stream or allocated string */
+};
+
+
+struct acpi_object_buffer
+{
+	ACPI_OBJECT_COMMON_HEADER
+	ACPI_COMMON_BUFFER_INFO
+	u8                                      *pointer;           /* Buffer in AML stream or allocated buffer */
+	struct acpi_namespace_node              *node;              /* Link back to parent node */
+	u8                                      *aml_start;
+	u32                                     aml_length;
+};
+
+
+struct acpi_object_package
+{
+	ACPI_OBJECT_COMMON_HEADER
+
+	u32                                     count;              /* # of elements in package */
+	u32                                     aml_length;
+	u8                                      *aml_start;
+	struct acpi_namespace_node              *node;              /* Link back to parent node */
+	union acpi_operand_object               **elements;         /* Array of pointers to acpi_objects */
+};
+
+
+/******************************************************************************
+ *
+ * Complex data types
+ *
+ *****************************************************************************/
+
+struct acpi_object_event
+{
+	ACPI_OBJECT_COMMON_HEADER
+	void                                    *semaphore;
+};
+
+
+#define INFINITE_CONCURRENCY        0xFF
+
+struct acpi_object_method
+{
+	ACPI_OBJECT_COMMON_HEADER
+	u8                                      method_flags;
+	u8                                      param_count;
+	u32                                     aml_length;
+	void                                    *semaphore;
+	u8                                      *aml_start;
+	u8                                      concurrency;
+	u8                                      thread_count;
+	acpi_owner_id                           owning_id;
+};
+
+
+struct acpi_object_mutex
+{
+	ACPI_OBJECT_COMMON_HEADER
+	u16                                     sync_level;
+	u16                                     acquisition_depth;
+	struct acpi_thread_state                *owner_thread;
+	void                                    *semaphore;
+	union acpi_operand_object               *prev;              /* Link for list of acquired mutexes */
+	union acpi_operand_object               *next;              /* Link for list of acquired mutexes */
+	struct acpi_namespace_node              *node;              /* containing object */
+};
+
+
+struct acpi_object_region
+{
+	ACPI_OBJECT_COMMON_HEADER
+
+	u8                                      space_id;
+	union acpi_operand_object               *address_space;     /* Handler for region access */
+	struct acpi_namespace_node              *node;              /* containing object */
+	union acpi_operand_object               *next;
+	u32                                     length;
+	acpi_physical_address                   address;
+};
+
+
+/******************************************************************************
+ *
+ * Objects that can be notified.  All share a common notify_info area.
+ *
+ *****************************************************************************/
+
+struct acpi_object_notify_common            /* COMMON NOTIFY for POWER, PROCESSOR, DEVICE, and THERMAL */
+{
+	ACPI_OBJECT_COMMON_HEADER
+	ACPI_COMMON_NOTIFY_INFO
+};
+
+
+struct acpi_object_device
+{
+	ACPI_OBJECT_COMMON_HEADER
+	ACPI_COMMON_NOTIFY_INFO
+	struct acpi_gpe_block_info              *gpe_block;
+};
+
+
+struct acpi_object_power_resource
+{
+	ACPI_OBJECT_COMMON_HEADER
+	ACPI_COMMON_NOTIFY_INFO
+	u32                                     system_level;
+	u32                                     resource_order;
+};
+
+
+struct acpi_object_processor
+{
+	ACPI_OBJECT_COMMON_HEADER
+	ACPI_COMMON_NOTIFY_INFO
+	u32                                     proc_id;
+	u32                                     length;
+	acpi_io_address                         address;
+};
+
+
+struct acpi_object_thermal_zone
+{
+	ACPI_OBJECT_COMMON_HEADER
+	ACPI_COMMON_NOTIFY_INFO
+};
+
+
+/******************************************************************************
+ *
+ * Fields.  All share a common header/info field.
+ *
+ *****************************************************************************/
+
+struct acpi_object_field_common                         /* COMMON FIELD (for BUFFER, REGION, BANK, and INDEX fields) */
+{
+	ACPI_OBJECT_COMMON_HEADER
+	ACPI_COMMON_FIELD_INFO
+	union acpi_operand_object               *region_obj;        /* Containing Operation Region object */
+			  /* (REGION/BANK fields only) */
+};
+
+
+struct acpi_object_region_field
+{
+	ACPI_OBJECT_COMMON_HEADER
+	ACPI_COMMON_FIELD_INFO
+	union acpi_operand_object               *region_obj;        /* Containing op_region object */
+};
+
+
+struct acpi_object_bank_field
+{
+	ACPI_OBJECT_COMMON_HEADER
+	ACPI_COMMON_FIELD_INFO
+	union acpi_operand_object               *region_obj;        /* Containing op_region object */
+	union acpi_operand_object               *bank_obj;          /* bank_select Register object */
+};
+
+
+struct acpi_object_index_field
+{
+	ACPI_OBJECT_COMMON_HEADER
+	ACPI_COMMON_FIELD_INFO
+
+	/*
+	 * No "region_obj" pointer needed since the Index and Data registers
+	 * are each field definitions unto themselves.
+	 */
+	union acpi_operand_object               *index_obj;         /* Index register */
+	union acpi_operand_object               *data_obj;          /* Data register */
+};
+
+
+/* The buffer_field is different in that it is part of a Buffer, not an op_region */
+
+struct acpi_object_buffer_field
+{
+	ACPI_OBJECT_COMMON_HEADER
+	ACPI_COMMON_FIELD_INFO
+	union acpi_operand_object               *buffer_obj;        /* Containing Buffer object */
+};
+
+
+/******************************************************************************
+ *
+ * Objects for handlers
+ *
+ *****************************************************************************/
+
+struct acpi_object_notify_handler
+{
+	ACPI_OBJECT_COMMON_HEADER
+	struct acpi_namespace_node              *node;              /* Parent device */
+	acpi_notify_handler                     handler;
+	void                                    *context;
+};
+
+
+/* Flags for address handler */
+
+#define ACPI_ADDR_HANDLER_DEFAULT_INSTALLED  0x1
+
+
+struct acpi_object_addr_handler
+{
+	ACPI_OBJECT_COMMON_HEADER
+	u8                                      space_id;
+	u16                                     hflags;
+	acpi_adr_space_handler                  handler;
+	struct acpi_namespace_node              *node;              /* Parent device */
+	void                                    *context;
+	acpi_adr_space_setup                    setup;
+	union acpi_operand_object               *region_list;       /* regions using this handler */
+	union acpi_operand_object               *next;
+};
+
+
+/******************************************************************************
+ *
+ * Special internal objects
+ *
+ *****************************************************************************/
+
+/*
+ * The Reference object type is used for these opcodes:
+ * Arg[0-6], Local[0-7], index_op, name_op, zero_op, one_op, ones_op, debug_op
+ */
+struct acpi_object_reference
+{
+	ACPI_OBJECT_COMMON_HEADER
+	u8                                      target_type;        /* Used for index_op */
+	u16                                     opcode;
+	u32                                     offset;             /* Used for arg_op, local_op, and index_op */
+	void                                    *object;            /* name_op=>HANDLE to obj, index_op=>union acpi_operand_object  */
+	struct acpi_namespace_node              *node;
+	union acpi_operand_object               **where;
+};
+
+
+/*
+ * Extra object is used as additional storage for types that
+ * have AML code in their declarations (term_args) that must be
+ * evaluated at run time.
+ *
+ * Currently: Region and field_unit types
+ */
+struct acpi_object_extra
+{
+	ACPI_OBJECT_COMMON_HEADER
+	u8                                      byte_fill1;
+	u16                                     word_fill1;
+	u32                                     aml_length;
+	u8                                      *aml_start;
+	struct acpi_namespace_node              *method_REG;        /* _REG method for this region (if any) */
+	void                                    *region_context;    /* Region-specific data */
+};
+
+
+/* Additional data that can be attached to namespace nodes */
+
+struct acpi_object_data
+{
+	ACPI_OBJECT_COMMON_HEADER
+	acpi_object_handler                     handler;
+	void                                    *pointer;
+};
+
+
+/* Structure used when objects are cached for reuse */
+
+struct acpi_object_cache_list
+{
+	ACPI_OBJECT_COMMON_HEADER
+	union acpi_operand_object               *next;              /* Link for object cache and internal lists*/
+};
+
+
+/******************************************************************************
+ *
+ * union acpi_operand_object Descriptor - a giant union of all of the above
+ *
+ *****************************************************************************/
+
+union acpi_operand_object
+{
+	struct acpi_object_common               common;
+	struct acpi_object_integer              integer;
+	struct acpi_object_string               string;
+	struct acpi_object_buffer               buffer;
+	struct acpi_object_package              package;
+	struct acpi_object_event                event;
+	struct acpi_object_method               method;
+	struct acpi_object_mutex                mutex;
+	struct acpi_object_region               region;
+	struct acpi_object_notify_common        common_notify;
+	struct acpi_object_device               device;
+	struct acpi_object_power_resource       power_resource;
+	struct acpi_object_processor            processor;
+	struct acpi_object_thermal_zone         thermal_zone;
+	struct acpi_object_field_common         common_field;
+	struct acpi_object_region_field         field;
+	struct acpi_object_buffer_field         buffer_field;
+	struct acpi_object_bank_field           bank_field;
+	struct acpi_object_index_field          index_field;
+	struct acpi_object_notify_handler       notify;
+	struct acpi_object_addr_handler         address_space;
+	struct acpi_object_reference            reference;
+	struct acpi_object_extra                extra;
+	struct acpi_object_data                 data;
+	struct acpi_object_cache_list           cache;
+};
+
+
+/******************************************************************************
+ *
+ * union acpi_descriptor - objects that share a common descriptor identifier
+ *
+ *****************************************************************************/
+
+
+/* Object descriptor types */
+
+#define ACPI_DESC_TYPE_CACHED           0x11        /* Used only when object is cached */
+#define ACPI_DESC_TYPE_STATE            0x20
+#define ACPI_DESC_TYPE_STATE_UPDATE     0x21
+#define ACPI_DESC_TYPE_STATE_PACKAGE    0x22
+#define ACPI_DESC_TYPE_STATE_CONTROL    0x23
+#define ACPI_DESC_TYPE_STATE_RPSCOPE    0x24
+#define ACPI_DESC_TYPE_STATE_PSCOPE     0x25
+#define ACPI_DESC_TYPE_STATE_WSCOPE     0x26
+#define ACPI_DESC_TYPE_STATE_RESULT     0x27
+#define ACPI_DESC_TYPE_STATE_NOTIFY     0x28
+#define ACPI_DESC_TYPE_STATE_THREAD     0x29
+#define ACPI_DESC_TYPE_WALK             0x44
+#define ACPI_DESC_TYPE_PARSER           0x66
+#define ACPI_DESC_TYPE_OPERAND          0x88
+#define ACPI_DESC_TYPE_NAMED            0xAA
+
+
+union acpi_descriptor
+{
+	u8                                      descriptor_id;  /* To differentiate various internal objs */\
+	union acpi_operand_object               object;
+	struct acpi_namespace_node              node;
+	union acpi_parse_object                 op;
+};
+
+
+#endif /* _ACOBJECT_H */
diff -urNp linux-5400/include/acpi/acoutput.h linux-5410/include/acpi/acoutput.h
--- linux-5400/include/acpi/acoutput.h
+++ linux-5410/include/acpi/acoutput.h
@@ -0,0 +1,185 @@
+/******************************************************************************
+ *
+ * Name: acoutput.h -- debug output
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACOUTPUT_H__
+#define __ACOUTPUT_H__
+
+/*
+ * Debug levels and component IDs.  These are used to control the
+ * granularity of the output of the DEBUG_PRINT macro -- on a per-
+ * component basis and a per-exception-type basis.
+ */
+
+/* Component IDs are used in the global "debug_layer" */
+
+#define ACPI_UTILITIES              0x00000001
+#define ACPI_HARDWARE               0x00000002
+#define ACPI_EVENTS                 0x00000004
+#define ACPI_TABLES                 0x00000008
+#define ACPI_NAMESPACE              0x00000010
+#define ACPI_PARSER                 0x00000020
+#define ACPI_DISPATCHER             0x00000040
+#define ACPI_EXECUTER               0x00000080
+#define ACPI_RESOURCES              0x00000100
+#define ACPI_CA_DEBUGGER            0x00000200
+#define ACPI_OS_SERVICES            0x00000400
+#define ACPI_CA_DISASSEMBLER        0x00000800
+
+/* Component IDs for ACPI tools and utilities */
+
+#define ACPI_COMPILER               0x00001000
+#define ACPI_TOOLS                  0x00002000
+
+#define ACPI_ALL_COMPONENTS         0x00003FFF
+#define ACPI_COMPONENT_DEFAULT      (ACPI_ALL_COMPONENTS)
+
+
+/* Component IDs reserved for ACPI drivers */
+
+#define ACPI_ALL_DRIVERS            0xFFFF0000
+
+
+/*
+ * Raw debug output levels, do not use these in the DEBUG_PRINT macros
+ */
+#define ACPI_LV_ERROR               0x00000001
+#define ACPI_LV_WARN                0x00000002
+#define ACPI_LV_INIT                0x00000004
+#define ACPI_LV_DEBUG_OBJECT        0x00000008
+#define ACPI_LV_INFO                0x00000010
+#define ACPI_LV_ALL_EXCEPTIONS      0x0000001F
+
+/* Trace verbosity level 1 [Standard Trace Level] */
+
+#define ACPI_LV_INIT_NAMES          0x00000020
+#define ACPI_LV_PARSE               0x00000040
+#define ACPI_LV_LOAD                0x00000080
+#define ACPI_LV_DISPATCH            0x00000100
+#define ACPI_LV_EXEC                0x00000200
+#define ACPI_LV_NAMES               0x00000400
+#define ACPI_LV_OPREGION            0x00000800
+#define ACPI_LV_BFIELD              0x00001000
+#define ACPI_LV_TABLES              0x00002000
+#define ACPI_LV_VALUES              0x00004000
+#define ACPI_LV_OBJECTS             0x00008000
+#define ACPI_LV_RESOURCES           0x00010000
+#define ACPI_LV_USER_REQUESTS       0x00020000
+#define ACPI_LV_PACKAGE             0x00040000
+#define ACPI_LV_VERBOSITY1          0x0007FF40 | ACPI_LV_ALL_EXCEPTIONS
+
+/* Trace verbosity level 2 [Function tracing and memory allocation] */
+
+#define ACPI_LV_ALLOCATIONS         0x00100000
+#define ACPI_LV_FUNCTIONS           0x00200000
+#define ACPI_LV_OPTIMIZATIONS       0x00400000
+#define ACPI_LV_VERBOSITY2          0x00700000 | ACPI_LV_VERBOSITY1
+#define ACPI_LV_ALL                 ACPI_LV_VERBOSITY2
+
+/* Trace verbosity level 3 [Threading, I/O, and Interrupts] */
+
+#define ACPI_LV_MUTEX               0x01000000
+#define ACPI_LV_THREADS             0x02000000
+#define ACPI_LV_IO                  0x04000000
+#define ACPI_LV_INTERRUPTS          0x08000000
+#define ACPI_LV_VERBOSITY3          0x0F000000 | ACPI_LV_VERBOSITY2
+
+/* Exceptionally verbose output -- also used in the global "debug_level" */
+
+#define ACPI_LV_AML_DISASSEMBLE     0x10000000
+#define ACPI_LV_VERBOSE_INFO        0x20000000
+#define ACPI_LV_FULL_TABLES         0x40000000
+#define ACPI_LV_EVENTS              0x80000000
+
+#define ACPI_LV_VERBOSE             0xF0000000
+
+
+/*
+ * Debug level macros that are used in the DEBUG_PRINT macros
+ */
+#define ACPI_DEBUG_LEVEL(dl)        (u32) dl,__LINE__,&_dbg
+
+/* Exception level -- used in the global "debug_level" */
+
+#define ACPI_DB_ERROR               ACPI_DEBUG_LEVEL (ACPI_LV_ERROR)
+#define ACPI_DB_WARN                ACPI_DEBUG_LEVEL (ACPI_LV_WARN)
+#define ACPI_DB_INIT                ACPI_DEBUG_LEVEL (ACPI_LV_INIT)
+#define ACPI_DB_DEBUG_OBJECT        ACPI_DEBUG_LEVEL (ACPI_LV_DEBUG_OBJECT)
+#define ACPI_DB_INFO                ACPI_DEBUG_LEVEL (ACPI_LV_INFO)
+#define ACPI_DB_ALL_EXCEPTIONS      ACPI_DEBUG_LEVEL (ACPI_LV_ALL_EXCEPTIONS)
+
+
+/* Trace level -- also used in the global "debug_level" */
+
+#define ACPI_DB_INIT_NAMES          ACPI_DEBUG_LEVEL (ACPI_LV_INIT_NAMES)
+#define ACPI_DB_THREADS             ACPI_DEBUG_LEVEL (ACPI_LV_THREADS)
+#define ACPI_DB_PARSE               ACPI_DEBUG_LEVEL (ACPI_LV_PARSE)
+#define ACPI_DB_DISPATCH            ACPI_DEBUG_LEVEL (ACPI_LV_DISPATCH)
+#define ACPI_DB_LOAD                ACPI_DEBUG_LEVEL (ACPI_LV_LOAD)
+#define ACPI_DB_EXEC                ACPI_DEBUG_LEVEL (ACPI_LV_EXEC)
+#define ACPI_DB_NAMES               ACPI_DEBUG_LEVEL (ACPI_LV_NAMES)
+#define ACPI_DB_OPREGION            ACPI_DEBUG_LEVEL (ACPI_LV_OPREGION)
+#define ACPI_DB_BFIELD              ACPI_DEBUG_LEVEL (ACPI_LV_BFIELD)
+#define ACPI_DB_TABLES              ACPI_DEBUG_LEVEL (ACPI_LV_TABLES)
+#define ACPI_DB_FUNCTIONS           ACPI_DEBUG_LEVEL (ACPI_LV_FUNCTIONS)
+#define ACPI_DB_OPTIMIZATIONS       ACPI_DEBUG_LEVEL (ACPI_LV_OPTIMIZATIONS)
+#define ACPI_DB_VALUES              ACPI_DEBUG_LEVEL (ACPI_LV_VALUES)
+#define ACPI_DB_OBJECTS             ACPI_DEBUG_LEVEL (ACPI_LV_OBJECTS)
+#define ACPI_DB_ALLOCATIONS         ACPI_DEBUG_LEVEL (ACPI_LV_ALLOCATIONS)
+#define ACPI_DB_RESOURCES           ACPI_DEBUG_LEVEL (ACPI_LV_RESOURCES)
+#define ACPI_DB_IO                  ACPI_DEBUG_LEVEL (ACPI_LV_IO)
+#define ACPI_DB_INTERRUPTS          ACPI_DEBUG_LEVEL (ACPI_LV_INTERRUPTS)
+#define ACPI_DB_USER_REQUESTS       ACPI_DEBUG_LEVEL (ACPI_LV_USER_REQUESTS)
+#define ACPI_DB_PACKAGE             ACPI_DEBUG_LEVEL (ACPI_LV_PACKAGE)
+#define ACPI_DB_MUTEX               ACPI_DEBUG_LEVEL (ACPI_LV_MUTEX)
+
+#define ACPI_DB_ALL                 ACPI_DEBUG_LEVEL (ACPI_LV_ALL)
+
+
+/* Defaults for debug_level, debug and normal */
+
+#define ACPI_DEBUG_DEFAULT          (ACPI_LV_INIT | ACPI_LV_WARN | ACPI_LV_ERROR | ACPI_LV_DEBUG_OBJECT)
+#define ACPI_NORMAL_DEFAULT         (ACPI_LV_INIT | ACPI_LV_WARN | ACPI_LV_ERROR | ACPI_LV_DEBUG_OBJECT)
+#define ACPI_DEBUG_ALL              (ACPI_LV_AML_DISASSEMBLE | ACPI_LV_ALL_EXCEPTIONS | ACPI_LV_ALL)
+
+
+#endif /* __ACOUTPUT_H__ */
diff -urNp linux-5400/include/acpi/acparser.h linux-5410/include/acpi/acparser.h
--- linux-5400/include/acpi/acparser.h
+++ linux-5410/include/acpi/acparser.h
@@ -0,0 +1,347 @@
+/******************************************************************************
+ *
+ * Module Name: acparser.h - AML Parser subcomponent prototypes and defines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+
+#ifndef __ACPARSER_H__
+#define __ACPARSER_H__
+
+
+#define OP_HAS_RETURN_VALUE             1
+
+/* variable # arguments */
+
+#define ACPI_VAR_ARGS                   ACPI_UINT32_MAX
+
+
+#define ACPI_PARSE_DELETE_TREE          0x0001
+#define ACPI_PARSE_NO_TREE_DELETE       0x0000
+#define ACPI_PARSE_TREE_MASK            0x0001
+
+#define ACPI_PARSE_LOAD_PASS1           0x0010
+#define ACPI_PARSE_LOAD_PASS2           0x0020
+#define ACPI_PARSE_EXECUTE              0x0030
+#define ACPI_PARSE_MODE_MASK            0x0030
+
+#define ACPI_PARSE_DEFERRED_OP          0x0100
+
+/* Parser external interfaces */
+
+acpi_status
+acpi_psx_load_table (
+	u8                              *pcode_addr,
+	u32                             pcode_length);
+
+acpi_status
+acpi_psx_execute (
+	struct acpi_namespace_node      *method_node,
+	union acpi_operand_object       **params,
+	union acpi_operand_object       **return_obj_desc);
+
+
+/******************************************************************************
+ *
+ * Parser interfaces
+ *
+ *****************************************************************************/
+
+
+/* psargs - Parse AML opcode arguments */
+
+u8 *
+acpi_ps_get_next_package_end (
+	struct acpi_parse_state         *parser_state);
+
+u32
+acpi_ps_get_next_package_length (
+	struct acpi_parse_state         *parser_state);
+
+char *
+acpi_ps_get_next_namestring (
+	struct acpi_parse_state         *parser_state);
+
+void
+acpi_ps_get_next_simple_arg (
+	struct acpi_parse_state         *parser_state,
+	u32                             arg_type,
+	union acpi_parse_object         *arg);
+
+acpi_status
+acpi_ps_get_next_namepath (
+	struct acpi_walk_state          *walk_state,
+	struct acpi_parse_state         *parser_state,
+	union acpi_parse_object         *arg,
+	u8                              method_call);
+
+union acpi_parse_object *
+acpi_ps_get_next_field (
+	struct acpi_parse_state         *parser_state);
+
+acpi_status
+acpi_ps_get_next_arg (
+	struct acpi_walk_state          *walk_state,
+	struct acpi_parse_state         *parser_state,
+	u32                             arg_type,
+	union acpi_parse_object         **return_arg);
+
+
+/* psfind */
+
+union acpi_parse_object *
+acpi_ps_find_name (
+	union acpi_parse_object         *scope,
+	u32                             name,
+	u32                             opcode);
+
+union acpi_parse_object*
+acpi_ps_get_parent (
+	union acpi_parse_object         *op);
+
+
+/* psopcode - AML Opcode information */
+
+const struct acpi_opcode_info *
+acpi_ps_get_opcode_info (
+	u16                             opcode);
+
+char *
+acpi_ps_get_opcode_name (
+	u16                             opcode);
+
+
+/* psparse - top level parsing routines */
+
+u32
+acpi_ps_get_opcode_size (
+	u32                             opcode);
+
+void
+acpi_ps_complete_this_op (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op);
+
+acpi_status
+acpi_ps_next_parse_state (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op,
+	acpi_status                     callback_status);
+
+acpi_status
+acpi_ps_find_object (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         **out_op);
+
+void
+acpi_ps_delete_parse_tree (
+	union acpi_parse_object         *root);
+
+acpi_status
+acpi_ps_parse_loop (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ps_parse_aml (
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ps_parse_table (
+	u8                              *aml,
+	u32                             aml_size,
+	acpi_parse_downwards            descending_callback,
+	acpi_parse_upwards              ascending_callback,
+	union acpi_parse_object         **root_object);
+
+u16
+acpi_ps_peek_opcode (
+	struct acpi_parse_state         *state);
+
+
+/* psscope - Scope stack management routines */
+
+
+acpi_status
+acpi_ps_init_scope (
+	struct acpi_parse_state         *parser_state,
+	union acpi_parse_object         *root);
+
+union acpi_parse_object *
+acpi_ps_get_parent_scope (
+	struct acpi_parse_state         *state);
+
+u8
+acpi_ps_has_completed_scope (
+	struct acpi_parse_state         *parser_state);
+
+void
+acpi_ps_pop_scope (
+	struct acpi_parse_state         *parser_state,
+	union acpi_parse_object         **op,
+	u32                             *arg_list,
+	u32                             *arg_count);
+
+acpi_status
+acpi_ps_push_scope (
+	struct acpi_parse_state         *parser_state,
+	union acpi_parse_object         *op,
+	u32                             remaining_args,
+	u32                             arg_count);
+
+void
+acpi_ps_cleanup_scope (
+	struct acpi_parse_state         *state);
+
+
+/* pstree - parse tree manipulation routines */
+
+void
+acpi_ps_append_arg(
+	union acpi_parse_object         *op,
+	union acpi_parse_object         *arg);
+
+union acpi_parse_object*
+acpi_ps_find (
+	union acpi_parse_object         *scope,
+	char                            *path,
+	u16                             opcode,
+	u32                             create);
+
+union acpi_parse_object *
+acpi_ps_get_arg(
+	union acpi_parse_object         *op,
+	u32                              argn);
+
+union acpi_parse_object *
+acpi_ps_get_child (
+	union acpi_parse_object         *op);
+
+union acpi_parse_object *
+acpi_ps_get_depth_next (
+	union acpi_parse_object         *origin,
+	union acpi_parse_object         *op);
+
+
+/* pswalk - parse tree walk routines */
+
+acpi_status
+acpi_ps_walk_parsed_aml (
+	union acpi_parse_object         *start_op,
+	union acpi_parse_object         *end_op,
+	union acpi_operand_object       *mth_desc,
+	struct acpi_namespace_node      *start_node,
+	union acpi_operand_object       **params,
+	union acpi_operand_object       **caller_return_desc,
+	acpi_owner_id                   owner_id,
+	acpi_parse_downwards            descending_callback,
+	acpi_parse_upwards              ascending_callback);
+
+acpi_status
+acpi_ps_get_next_walk_op (
+	struct acpi_walk_state          *walk_state,
+	union acpi_parse_object         *op,
+	acpi_parse_upwards              ascending_callback);
+
+acpi_status
+acpi_ps_delete_completed_op (
+	struct acpi_walk_state          *walk_state);
+
+
+/* psutils - parser utilities */
+
+union acpi_parse_object *
+acpi_ps_create_scope_op (
+	void);
+
+void
+acpi_ps_init_op (
+	union acpi_parse_object         *op,
+	u16                             opcode);
+
+union acpi_parse_object *
+acpi_ps_alloc_op (
+	u16                             opcode);
+
+void
+acpi_ps_free_op (
+	union acpi_parse_object         *op);
+
+void
+acpi_ps_delete_parse_cache (
+	void);
+
+u8
+acpi_ps_is_leading_char (
+	u32                             c);
+
+u8
+acpi_ps_is_prefix_char (
+	u32                             c);
+
+u32
+acpi_ps_get_name(
+	union acpi_parse_object         *op);
+
+void
+acpi_ps_set_name(
+	union acpi_parse_object         *op,
+	u32                             name);
+
+
+/* psdump - display parser tree */
+
+u32
+acpi_ps_sprint_path (
+	char                            *buffer_start,
+	u32                             buffer_size,
+	union acpi_parse_object         *op);
+
+u32
+acpi_ps_sprint_op (
+	char                            *buffer_start,
+	u32                             buffer_size,
+	union acpi_parse_object         *op);
+
+void
+acpi_ps_show (
+	union acpi_parse_object         *op);
+
+
+#endif /* __ACPARSER_H__ */
diff -urNp linux-5400/include/acpi/acpi.h linux-5410/include/acpi/acpi.h
--- linux-5400/include/acpi/acpi.h
+++ linux-5410/include/acpi/acpi.h
@@ -0,0 +1,69 @@
+/******************************************************************************
+ *
+ * Name: acpi.h - Master include file, Publics and external data.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACPI_H__
+#define __ACPI_H__
+
+/*
+ * Common includes for all ACPI driver files
+ * We put them here because we don't want to duplicate them
+ * in the rest of the source code again and again.
+ */
+#include "acconfig.h"           /* Configuration constants */
+#include "platform/acenv.h"     /* Target environment specific items */
+#include "actypes.h"            /* Fundamental common data types */
+#include "acexcep.h"            /* ACPI exception codes */
+#include "acmacros.h"           /* C macros */
+#include "actbl.h"              /* ACPI table definitions */
+#include "aclocal.h"            /* Internal data types */
+#include "acoutput.h"           /* Error output and Debug macros */
+#include "acpiosxf.h"           /* Interfaces to the ACPI-to-OS layer*/
+#include "acpixf.h"             /* ACPI core subsystem external interfaces */
+#include "acobject.h"           /* ACPI internal object */
+#include "acstruct.h"           /* Common structures */
+#include "acglobal.h"           /* All global variables */
+#include "achware.h"            /* Hardware defines and interfaces */
+#include "acutils.h"            /* Utility interfaces */
+
+
+#endif /* __ACPI_H__ */
diff -urNp linux-5400/include/acpi/acpi_bus.h linux-5410/include/acpi/acpi_bus.h
--- linux-5400/include/acpi/acpi_bus.h
+++ linux-5410/include/acpi/acpi_bus.h
@@ -0,0 +1,315 @@
+/*
+ *  acpi_bus.h - ACPI Bus Driver ($Revision: 22 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#ifndef __ACPI_BUS_H__
+#define __ACPI_BUS_H__
+
+#include <linux/version.h>
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,4))
+#include <linux/device.h>
+#define CONFIG_LDM
+#endif
+
+#include <acpi/acpi.h>
+
+
+/* TBD: Make dynamic */
+#define ACPI_MAX_HANDLES	10
+struct acpi_handle_list {
+	u32			count;
+	acpi_handle		handles[ACPI_MAX_HANDLES];
+};
+
+
+/* acpi_utils.h */
+acpi_status
+acpi_extract_package (
+	union acpi_object       *package,
+	struct acpi_buffer      *format,
+	struct acpi_buffer      *buffer);
+acpi_status
+acpi_evaluate_integer (
+	acpi_handle             handle,
+	acpi_string             pathname,
+	struct acpi_object_list *arguments,
+	unsigned long           *data);
+acpi_status
+acpi_evaluate_reference (
+	acpi_handle             handle,
+	acpi_string             pathname,
+	struct acpi_object_list *arguments,
+	struct acpi_handle_list *list);
+
+
+#ifdef CONFIG_ACPI_BUS
+
+#include <linux/proc_fs.h>
+
+#define ACPI_BUS_FILE_ROOT	"acpi"
+extern struct proc_dir_entry	*acpi_root_dir;
+extern FADT_DESCRIPTOR		acpi_fadt;
+
+enum acpi_bus_removal_type {
+	ACPI_BUS_REMOVAL_NORMAL	= 0,
+	ACPI_BUS_REMOVAL_EJECT,
+	ACPI_BUS_REMOVAL_SUPRISE,
+	ACPI_BUS_REMOVAL_TYPE_COUNT
+};
+
+enum acpi_bus_device_type {
+	ACPI_BUS_TYPE_DEVICE	= 0,
+	ACPI_BUS_TYPE_POWER,
+	ACPI_BUS_TYPE_PROCESSOR,
+	ACPI_BUS_TYPE_THERMAL,
+	ACPI_BUS_TYPE_SYSTEM,
+	ACPI_BUS_TYPE_POWER_BUTTON,
+	ACPI_BUS_TYPE_SLEEP_BUTTON,
+	ACPI_BUS_DEVICE_TYPE_COUNT
+};
+
+struct acpi_driver;
+struct acpi_device;
+
+
+/*
+ * ACPI Driver
+ * -----------
+ */
+
+typedef int (*acpi_op_add)	(struct acpi_device *device);
+typedef int (*acpi_op_remove)	(struct acpi_device *device, int type);
+typedef int (*acpi_op_lock)	(struct acpi_device *device, int type);
+typedef int (*acpi_op_start)	(struct acpi_device *device);
+typedef int (*acpi_op_stop)	(struct acpi_device *device, int type);
+typedef int (*acpi_op_suspend)	(struct acpi_device *device, int state);
+typedef int (*acpi_op_resume)	(struct acpi_device *device, int state);
+typedef int (*acpi_op_scan)	(struct acpi_device *device);
+typedef int (*acpi_op_bind)	(struct acpi_device *device);
+
+struct acpi_device_ops {
+	acpi_op_add		add;
+	acpi_op_remove		remove;
+	acpi_op_lock		lock;
+	acpi_op_start		start;
+	acpi_op_stop		stop;
+	acpi_op_suspend		suspend;
+	acpi_op_resume		resume;
+	acpi_op_scan		scan;
+	acpi_op_bind		bind;
+};
+
+struct acpi_driver {
+	struct list_head	node;
+	char			name[80];
+	char			class[80];
+	int			references;
+	char			*ids;		/* Supported Hardware IDs */
+	struct acpi_device_ops	ops;
+};
+
+/*
+ * ACPI Device
+ * -----------
+ */
+
+/* Status (_STA) */
+
+struct acpi_device_status {
+	u32			present:1;
+	u32			enabled:1;
+	u32			show_in_ui:1;
+	u32			functional:1;
+	u32			battery_present:1;
+	u32			reserved:27;
+};
+
+
+/* Flags */
+
+struct acpi_device_flags {
+	u32			dynamic_status:1;
+	u32			hardware_id:1;
+	u32			compatible_ids:1;
+	u32			bus_address:1;
+	u32			unique_id:1;
+	u32			removable:1;
+	u32			ejectable:1;
+	u32			lockable:1;
+	u32			suprise_removal_ok:1;
+	u32			power_manageable:1;
+	u32			performance_manageable:1;
+	u32			reserved:21;
+};
+
+
+/* File System */
+
+struct acpi_device_dir {
+	struct proc_dir_entry	*entry;
+};
+
+#define acpi_device_dir(d)	((d)->dir.entry)
+
+
+/* Plug and Play */
+
+typedef char			acpi_bus_id[5];
+typedef unsigned long		acpi_bus_address;
+typedef char			acpi_hardware_id[9];
+typedef char			acpi_unique_id[9];
+typedef char			acpi_device_name[40];
+typedef char			acpi_device_class[20];
+
+struct acpi_device_pnp {
+	acpi_bus_id		bus_id;		               /* Object name */
+	acpi_bus_address	bus_address;	                      /* _ADR */
+	acpi_hardware_id	hardware_id;	                      /* _HID */
+	struct acpi_compatible_id_list *cid_list;		     /* _CIDs */
+	acpi_unique_id		unique_id;	                      /* _UID */
+	acpi_device_name	device_name;	         /* Driver-determined */
+	acpi_device_class	device_class;	         /*        "          */
+};
+
+#define acpi_device_bid(d)	((d)->pnp.bus_id)
+#define acpi_device_adr(d)	((d)->pnp.bus_address)
+#define acpi_device_hid(d)	((d)->pnp.hardware_id)
+#define acpi_device_uid(d)	((d)->pnp.unique_id)
+#define acpi_device_name(d)	((d)->pnp.device_name)
+#define acpi_device_class(d)	((d)->pnp.device_class)
+
+
+/* Power Management */
+
+struct acpi_device_power_flags {
+	u32			explicit_get:1;		     /* _PSC present? */
+	u32			power_resources:1;	   /* Power resources */
+	u32			inrush_current:1;	  /* Serialize Dx->D0 */
+	u32			wake_capable:1;		 /* Wakeup supported? */
+	u32			wake_enabled:1;		/* Enabled for wakeup */
+	u32			power_removed:1;	   /* Optimize Dx->D0 */
+	u32			reserved:26;
+};
+
+struct acpi_device_power_state {
+	struct {
+		u8			valid:1;	
+		u8			explicit_set:1;	     /* _PSx present? */
+		u8			reserved:6;
+	}			flags;
+	int			power;		  /* % Power (compared to D0) */
+	int			latency;	/* Dx->D0 time (microseconds) */
+	struct acpi_handle_list	resources;	/* Power resources referenced */
+};
+
+struct acpi_device_power {
+	int			state;		             /* Current state */
+	struct acpi_device_power_flags flags;
+	struct acpi_device_power_state states[4];     /* Power states (D0-D3) */
+};
+
+
+/* Performance Management */
+
+struct acpi_device_perf_flags {
+	u8			reserved:8;
+};
+
+struct acpi_device_perf_state {
+	struct {
+		u8			valid:1;	
+		u8			reserved:7;
+	}			flags;
+	u8			power;		  /* % Power (compared to P0) */
+	u8			performance;	  /* % Performance (    "   ) */
+	int			latency;	/* Px->P0 time (microseconds) */
+};
+
+struct acpi_device_perf {
+	int			state;
+	struct acpi_device_perf_flags flags;
+	int			state_count;
+	struct acpi_device_perf_state *states;
+};
+
+
+/* Device */
+
+struct acpi_device {
+	acpi_handle		handle;
+	struct acpi_device	*parent;
+	struct list_head	children;
+	struct list_head	node;
+	struct acpi_device_status status;
+	struct acpi_device_flags flags;
+	struct acpi_device_pnp	pnp;
+	struct acpi_device_power power;
+	struct acpi_device_perf	performance;
+	struct acpi_device_dir	dir;
+	struct acpi_device_ops	ops;
+	struct acpi_driver	*driver;
+	void			*driver_data;
+#ifdef CONFIG_LDM
+	struct device		dev;
+#endif
+};
+
+#define acpi_driver_data(d)	((d)->driver_data)
+
+
+/*
+ * Events
+ * ------
+ */
+
+struct acpi_bus_event {
+	struct list_head	node;
+	acpi_device_class	device_class;
+	acpi_bus_id		bus_id;
+	u32			type;
+	u32			data;
+};
+
+
+/*
+ * External Functions
+ */
+
+int acpi_bus_get_device(acpi_handle, struct acpi_device **device);
+int acpi_bus_get_status (struct acpi_device *device);
+int acpi_bus_get_power (acpi_handle handle, int *state);
+int acpi_bus_set_power (acpi_handle handle, int state);
+int acpi_bus_generate_event (struct acpi_device *device, u8 type, int data);
+int acpi_bus_receive_event (struct acpi_bus_event *event);
+int acpi_bus_register_driver (struct acpi_driver *driver);
+int acpi_bus_unregister_driver (struct acpi_driver *driver);
+int acpi_bus_scan (struct acpi_device *device);
+int acpi_init (void);
+void acpi_exit (void);
+
+
+#endif /*CONFIG_ACPI_BUS*/
+
+#endif /*__ACPI_BUS_H__*/
diff -urNp linux-5400/include/acpi/acpi_drivers.h linux-5410/include/acpi/acpi_drivers.h
--- linux-5400/include/acpi/acpi_drivers.h
+++ linux-5410/include/acpi/acpi_drivers.h
@@ -0,0 +1,348 @@
+/*
+ *  acpi_drivers.h  ($Revision: 32 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#ifndef __ACPI_DRIVERS_H__
+#define __ACPI_DRIVERS_H__
+
+#include <linux/acpi.h>
+#include "acpi_bus.h"
+
+
+#define ACPI_MAX_STRING			80
+
+
+/* --------------------------------------------------------------------------
+                                    ACPI Bus
+   -------------------------------------------------------------------------- */
+
+#define ACPI_BUS_COMPONENT		0x00010000
+#define ACPI_BUS_CLASS			"system_bus"
+#define ACPI_BUS_HID			"ACPI_BUS"
+#define ACPI_BUS_DRIVER_NAME		"ACPI Bus Driver"
+#define ACPI_BUS_DEVICE_NAME		"System Bus"
+
+
+/* --------------------------------------------------------------------------
+                                  AC Adapter
+   -------------------------------------------------------------------------- */
+
+#define ACPI_AC_COMPONENT		0x00020000
+#define ACPI_AC_CLASS			"ac_adapter"
+#define ACPI_AC_HID 			"ACPI0003"
+#define ACPI_AC_DRIVER_NAME		"ACPI AC Adapter Driver"
+#define ACPI_AC_DEVICE_NAME		"AC Adapter"
+#define ACPI_AC_FILE_STATE		"state"
+#define ACPI_AC_NOTIFY_STATUS		0x80
+#define ACPI_AC_STATUS_OFFLINE		0x00
+#define ACPI_AC_STATUS_ONLINE		0x01
+#define ACPI_AC_STATUS_UNKNOWN		0xFF
+
+
+/* --------------------------------------------------------------------------
+                                     Battery
+   -------------------------------------------------------------------------- */
+
+#define ACPI_BATTERY_COMPONENT		0x00040000
+#define ACPI_BATTERY_CLASS		"battery"
+#define ACPI_BATTERY_HID		"PNP0C0A"
+#define ACPI_BATTERY_DRIVER_NAME	"ACPI Battery Driver"
+#define ACPI_BATTERY_DEVICE_NAME	"Battery"
+#define ACPI_BATTERY_FILE_INFO		"info"
+#define ACPI_BATTERY_FILE_STATUS	"state"
+#define ACPI_BATTERY_FILE_ALARM		"alarm"
+#define ACPI_BATTERY_NOTIFY_STATUS	0x80
+#define ACPI_BATTERY_NOTIFY_INFO	0x81
+#define ACPI_BATTERY_UNITS_WATTS	"mW"
+#define ACPI_BATTERY_UNITS_AMPS		"mA"
+
+
+/* --------------------------------------------------------------------------
+                                      Button
+   -------------------------------------------------------------------------- */
+
+#define ACPI_BUTTON_COMPONENT		0x00080000
+#define ACPI_BUTTON_DRIVER_NAME		"ACPI Button Driver"
+#define ACPI_BUTTON_CLASS		"button"
+#define ACPI_BUTTON_FILE_INFO		"info"
+#define ACPI_BUTTON_FILE_STATE		"state"
+#define ACPI_BUTTON_TYPE_UNKNOWN	0x00
+#define ACPI_BUTTON_NOTIFY_STATUS	0x80
+
+#define ACPI_BUTTON_SUBCLASS_POWER	"power"
+#define ACPI_BUTTON_HID_POWER		"PNP0C0C"	
+#define ACPI_BUTTON_HID_POWERF		"ACPI_FPB"
+#define ACPI_BUTTON_DEVICE_NAME_POWER	"Power Button (CM)"
+#define ACPI_BUTTON_DEVICE_NAME_POWERF	"Power Button (FF)"
+#define ACPI_BUTTON_TYPE_POWER		0x01
+#define ACPI_BUTTON_TYPE_POWERF		0x02
+
+#define ACPI_BUTTON_SUBCLASS_SLEEP	"sleep"
+#define ACPI_BUTTON_HID_SLEEP		"PNP0C0E"
+#define ACPI_BUTTON_HID_SLEEPF		"ACPI_FSB"
+#define ACPI_BUTTON_DEVICE_NAME_SLEEP	"Sleep Button (CM)"
+#define ACPI_BUTTON_DEVICE_NAME_SLEEPF	"Sleep Button (FF)"
+#define ACPI_BUTTON_TYPE_SLEEP		0x03
+#define ACPI_BUTTON_TYPE_SLEEPF		0x04
+
+#define ACPI_BUTTON_SUBCLASS_LID	"lid"
+#define ACPI_BUTTON_HID_LID		"PNP0C0D"
+#define ACPI_BUTTON_DEVICE_NAME_LID	"Lid Switch"
+#define ACPI_BUTTON_TYPE_LID		0x05
+
+
+/* --------------------------------------------------------------------------
+                                Embedded Controller
+   -------------------------------------------------------------------------- */
+
+#define ACPI_EC_COMPONENT		0x00100000
+#define ACPI_EC_CLASS			"embedded_controller"
+#define ACPI_EC_HID			"PNP0C09"
+#define ACPI_EC_DRIVER_NAME		"ACPI Embedded Controller Driver"
+#define ACPI_EC_DEVICE_NAME		"Embedded Controller"
+#define ACPI_EC_FILE_INFO		"info"
+
+#ifdef CONFIG_ACPI_EC
+
+int acpi_ec_ecdt_probe (void);
+int acpi_ec_init (void);
+void acpi_ec_exit (void);
+
+#endif
+
+
+/* --------------------------------------------------------------------------
+                                       Fan
+   -------------------------------------------------------------------------- */
+
+#define ACPI_FAN_COMPONENT		0x00200000
+#define ACPI_FAN_CLASS			"fan"
+#define ACPI_FAN_HID			"PNP0C0B"
+#define ACPI_FAN_DRIVER_NAME		"ACPI Fan Driver"
+#define ACPI_FAN_DEVICE_NAME		"Fan"
+#define ACPI_FAN_FILE_STATE		"state"
+#define ACPI_FAN_NOTIFY_STATUS		0x80
+
+
+/* --------------------------------------------------------------------------
+                                       PCI
+   -------------------------------------------------------------------------- */
+
+#ifdef CONFIG_ACPI_PCI
+
+#define ACPI_PCI_COMPONENT		0x00400000
+
+/* ACPI PCI Root Bridge (pci_root.c) */
+
+#define ACPI_PCI_ROOT_CLASS		"pci_bridge"
+#define ACPI_PCI_ROOT_HID		"PNP0A03"
+#define ACPI_PCI_ROOT_DRIVER_NAME	"ACPI PCI Root Bridge Driver"
+#define ACPI_PCI_ROOT_DEVICE_NAME	"PCI Root Bridge"
+
+int acpi_pci_root_init (void);
+void acpi_pci_root_exit (void);
+void acpi_pci_get_translations (struct acpi_pci_id* id, u64* mem_tra, u64* io_tra);
+
+/* ACPI PCI Interrupt Link (pci_link.c) */
+
+#define ACPI_PCI_LINK_CLASS		"pci_irq_routing"
+#define ACPI_PCI_LINK_HID		"PNP0C0F"
+#define ACPI_PCI_LINK_DRIVER_NAME	"ACPI PCI Interrupt Link Driver"
+#define ACPI_PCI_LINK_DEVICE_NAME	"PCI Interrupt Link"
+#define ACPI_PCI_LINK_FILE_INFO		"info"
+#define ACPI_PCI_LINK_FILE_STATUS	"state"
+
+int acpi_pci_link_check (void);
+int acpi_pci_link_get_irq (acpi_handle handle, int index, int* edge_level, int* active_high_low);
+int acpi_pci_link_init (void);
+void acpi_pci_link_exit (void);
+
+/* ACPI PCI Interrupt Routing (pci_irq.c) */
+
+int acpi_pci_irq_add_prt (acpi_handle handle, int segment, int bus);
+
+/* ACPI PCI Device Binding (pci_bind.c) */
+
+struct pci_bus;
+
+int acpi_pci_bind (struct acpi_device *device);
+int acpi_pci_bind_root (struct acpi_device *device, struct acpi_pci_id *id, struct pci_bus *bus);
+
+#endif /*CONFIG_ACPI_PCI*/
+
+
+/* --------------------------------------------------------------------------
+                                  Power Resource
+   -------------------------------------------------------------------------- */
+
+#define ACPI_POWER_COMPONENT		0x00800000
+#define ACPI_POWER_CLASS		"power_resource"
+#define ACPI_POWER_HID			"ACPI_PWR"
+#define ACPI_POWER_DRIVER_NAME		"ACPI Power Resource Driver"
+#define ACPI_POWER_DEVICE_NAME		"Power Resource"
+#define ACPI_POWER_FILE_INFO		"info"
+#define ACPI_POWER_FILE_STATUS		"state"
+#define ACPI_POWER_RESOURCE_STATE_OFF	0x00
+#define ACPI_POWER_RESOURCE_STATE_ON	0x01
+#define ACPI_POWER_RESOURCE_STATE_UNKNOWN 0xFF
+
+#ifdef CONFIG_ACPI_POWER
+
+int acpi_power_get_inferred_state (struct acpi_device *device);
+int acpi_power_transition (struct acpi_device *device, int state);
+int acpi_power_init (void);
+void acpi_power_exit (void);
+
+#endif
+
+
+/* --------------------------------------------------------------------------
+                                    Processor
+   -------------------------------------------------------------------------- */
+
+#define ACPI_PROCESSOR_COMPONENT	0x01000000
+#define ACPI_PROCESSOR_CLASS		"processor"
+#define ACPI_PROCESSOR_HID		"ACPI_CPU"
+#define ACPI_PROCESSOR_DRIVER_NAME	"ACPI Processor Driver"
+#define ACPI_PROCESSOR_DEVICE_NAME	"Processor"
+#define ACPI_PROCESSOR_FILE_INFO	"info"
+#define ACPI_PROCESSOR_FILE_POWER	"power"
+#define ACPI_PROCESSOR_FILE_PERFORMANCE	"performance"
+#define ACPI_PROCESSOR_FILE_THROTTLING	"throttling"
+#define ACPI_PROCESSOR_FILE_LIMIT	"limit"
+#define ACPI_PROCESSOR_NOTIFY_PERFORMANCE 0x80
+#define ACPI_PROCESSOR_NOTIFY_POWER	0x81
+#define ACPI_PROCESSOR_LIMIT_NONE	0x00
+#define ACPI_PROCESSOR_LIMIT_INCREMENT	0x01
+#define ACPI_PROCESSOR_LIMIT_DECREMENT	0x02
+
+int acpi_processor_set_thermal_limit(acpi_handle handle, int type);
+
+
+/* --------------------------------------------------------------------------
+                                     System
+   -------------------------------------------------------------------------- */
+
+#define ACPI_SYSTEM_COMPONENT		0x02000000
+#define ACPI_SYSTEM_CLASS		"system"
+#define ACPI_SYSTEM_HID			"ACPI_SYS"
+#define ACPI_SYSTEM_DRIVER_NAME		"ACPI System Driver"
+#define ACPI_SYSTEM_DEVICE_NAME		"System"
+#define ACPI_SYSTEM_FILE_INFO		"info"
+#define ACPI_SYSTEM_FILE_EVENT		"event"
+#define ACPI_SYSTEM_FILE_ALARM		"alarm"
+#define ACPI_SYSTEM_FILE_DSDT		"dsdt"
+#define ACPI_SYSTEM_FILE_FADT		"fadt"
+#define ACPI_SYSTEM_FILE_SLEEP		"sleep"
+#define ACPI_SYSTEM_FILE_DEBUG_LAYER	"debug_layer"
+#define ACPI_SYSTEM_FILE_DEBUG_LEVEL	"debug_level"
+
+#ifdef CONFIG_ACPI_SYSTEM
+
+int acpi_system_init (void);
+void acpi_system_exit (void);
+
+#endif
+
+
+/* --------------------------------------------------------------------------
+                                 Thermal Zone
+   -------------------------------------------------------------------------- */
+
+#define ACPI_THERMAL_COMPONENT		0x04000000
+#define ACPI_THERMAL_CLASS		"thermal_zone"
+#define ACPI_THERMAL_HID		"ACPI_THM"
+#define ACPI_THERMAL_DRIVER_NAME	"ACPI Thermal Zone Driver"
+#define ACPI_THERMAL_DEVICE_NAME	"Thermal Zone"
+#define ACPI_THERMAL_FILE_STATE		"state"
+#define ACPI_THERMAL_FILE_TEMPERATURE	"temperature"
+#define ACPI_THERMAL_FILE_TRIP_POINTS	"trip_points"
+#define ACPI_THERMAL_FILE_COOLING_MODE	"cooling_mode"
+#define ACPI_THERMAL_FILE_POLLING_FREQ	"polling_frequency"
+#define ACPI_THERMAL_NOTIFY_TEMPERATURE	0x80
+#define ACPI_THERMAL_NOTIFY_THRESHOLDS	0x81
+#define ACPI_THERMAL_NOTIFY_DEVICES	0x82
+#define ACPI_THERMAL_NOTIFY_CRITICAL	0xF0
+#define ACPI_THERMAL_NOTIFY_HOT		0xF1
+#define ACPI_THERMAL_MODE_ACTIVE	0x00
+#define ACPI_THERMAL_MODE_PASSIVE	0x01
+#define ACPI_THERMAL_PATH_POWEROFF	"/sbin/poweroff"
+
+
+/* --------------------------------------------------------------------------
+                                Debug Support
+   -------------------------------------------------------------------------- */
+
+#define ACPI_DEBUG_RESTORE	0
+#define ACPI_DEBUG_LOW		1
+#define ACPI_DEBUG_MEDIUM	2
+#define ACPI_DEBUG_HIGH		3
+#define ACPI_DEBUG_DRIVERS	4
+
+extern u32 acpi_dbg_level;
+extern u32 acpi_dbg_layer;
+
+static inline void
+acpi_set_debug (
+	u32			flag)
+{
+	static u32		layer_save;
+	static u32		level_save;
+
+	switch (flag) {
+	case ACPI_DEBUG_RESTORE:
+		acpi_dbg_layer = layer_save;
+		acpi_dbg_level = level_save;
+		break;
+	case ACPI_DEBUG_LOW:
+	case ACPI_DEBUG_MEDIUM:
+	case ACPI_DEBUG_HIGH:
+	case ACPI_DEBUG_DRIVERS:
+		layer_save = acpi_dbg_layer;
+		level_save = acpi_dbg_level;
+		break;
+	}
+
+	switch (flag) {
+	case ACPI_DEBUG_LOW:
+		acpi_dbg_layer = ACPI_COMPONENT_DEFAULT | ACPI_ALL_DRIVERS;
+		acpi_dbg_level = ACPI_DEBUG_DEFAULT;
+		break;
+	case ACPI_DEBUG_MEDIUM:
+		acpi_dbg_layer = ACPI_COMPONENT_DEFAULT | ACPI_ALL_DRIVERS;
+		acpi_dbg_level = ACPI_LV_FUNCTIONS | ACPI_LV_ALL_EXCEPTIONS;
+		break;
+	case ACPI_DEBUG_HIGH:
+		acpi_dbg_layer = 0xFFFFFFFF;
+		acpi_dbg_level = 0xFFFFFFFF;
+		break;
+	case ACPI_DEBUG_DRIVERS:
+		acpi_dbg_layer = ACPI_ALL_DRIVERS;
+		acpi_dbg_level = 0xFFFFFFFF;
+		break;
+	}
+}
+
+
+#endif /*__ACPI_DRIVERS_H__*/
diff -urNp linux-5400/include/acpi/acpiosxf.h linux-5410/include/acpi/acpiosxf.h
--- linux-5400/include/acpi/acpiosxf.h
+++ linux-5410/include/acpi/acpiosxf.h
@@ -0,0 +1,373 @@
+
+/******************************************************************************
+ *
+ * Name: acpiosxf.h - All interfaces to the OS Services Layer (OSL).  These
+ *                    interfaces must be implemented by OSL to interface the
+ *                    ACPI components to the host operating system.
+ *
+ *****************************************************************************/
+
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACPIOSXF_H__
+#define __ACPIOSXF_H__
+
+#include "platform/acenv.h"
+#include "actypes.h"
+
+
+/* Priorities for acpi_os_queue_for_execution */
+
+#define OSD_PRIORITY_GPE            1
+#define OSD_PRIORITY_HIGH           2
+#define OSD_PRIORITY_MED            3
+#define OSD_PRIORITY_LO             4
+
+#define ACPI_NO_UNIT_LIMIT          ((u32) -1)
+#define ACPI_MUTEX_SEM              1
+
+
+/* Functions for acpi_os_signal */
+
+#define ACPI_SIGNAL_FATAL           0
+#define ACPI_SIGNAL_BREAKPOINT      1
+
+struct acpi_signal_fatal_info
+{
+	u32                             type;
+	u32                             code;
+	u32                             argument;
+};
+
+
+/*
+ * OSL Initialization and shutdown primitives
+ */
+
+acpi_status
+acpi_os_initialize (
+	void);
+
+acpi_status
+acpi_os_terminate (
+	void);
+
+
+/*
+ * ACPI Table interfaces
+ */
+
+acpi_status
+acpi_os_get_root_pointer (
+	u32                             flags,
+	struct acpi_pointer             *address);
+
+acpi_status
+acpi_os_predefined_override (
+	const struct acpi_predefined_names *init_val,
+	acpi_string                         *new_val);
+
+acpi_status
+acpi_os_table_override (
+	struct acpi_table_header        *existing_table,
+	struct acpi_table_header        **new_table);
+
+
+/*
+ * Synchronization primitives
+ */
+
+acpi_status
+acpi_os_create_semaphore (
+	u32                             max_units,
+	u32                             initial_units,
+	acpi_handle                     *out_handle);
+
+acpi_status
+acpi_os_delete_semaphore (
+	acpi_handle                     handle);
+
+acpi_status
+acpi_os_wait_semaphore (
+	acpi_handle                     handle,
+	u32                             units,
+	u16                             timeout);
+
+acpi_status
+acpi_os_signal_semaphore (
+	acpi_handle                     handle,
+	u32                             units);
+
+acpi_status
+acpi_os_create_lock (
+	acpi_handle                     *out_handle);
+
+void
+acpi_os_delete_lock (
+	acpi_handle                     handle);
+
+void
+acpi_os_acquire_lock (
+	acpi_handle                     handle,
+	u32                             flags);
+
+void
+acpi_os_release_lock (
+	acpi_handle                     handle,
+	u32                             flags);
+
+
+/*
+ * Memory allocation and mapping
+ */
+
+void *
+acpi_os_allocate (
+	acpi_size                       size);
+
+void
+acpi_os_free (
+	void *                          memory);
+
+acpi_status
+acpi_os_map_memory (
+	acpi_physical_address           physical_address,
+	acpi_size                       size,
+	void                            **logical_address);
+
+void
+acpi_os_unmap_memory (
+	void                            *logical_address,
+	acpi_size                       size);
+
+acpi_status
+acpi_os_get_physical_address (
+	void                            *logical_address,
+	acpi_physical_address           *physical_address);
+
+
+/*
+ * Interrupt handlers
+ */
+
+acpi_status
+acpi_os_install_interrupt_handler (
+	u32                             interrupt_number,
+	OSD_HANDLER             service_routine,
+	void                            *context);
+
+acpi_status
+acpi_os_remove_interrupt_handler (
+	u32                             interrupt_number,
+	OSD_HANDLER             service_routine);
+
+
+/*
+ * Threads and Scheduling
+ */
+
+u32
+acpi_os_get_thread_id (
+	void);
+
+acpi_status
+acpi_os_queue_for_execution (
+	u32                             priority,
+	OSD_EXECUTION_CALLBACK  function,
+	void                            *context);
+
+void
+acpi_os_sleep (
+	u32                             seconds,
+	u32                             milliseconds);
+
+void
+acpi_os_stall (
+	u32                             microseconds);
+
+
+/*
+ * Platform and hardware-independent I/O interfaces
+ */
+
+acpi_status
+acpi_os_read_port (
+	acpi_io_address                 address,
+	u32                             *value,
+	u32                             width);
+
+acpi_status
+acpi_os_write_port (
+	acpi_io_address                 address,
+	u32                             value,
+	u32                             width);
+
+
+/*
+ * Platform and hardware-independent physical memory interfaces
+ */
+
+acpi_status
+acpi_os_read_memory (
+	acpi_physical_address           address,
+	u32                             *value,
+	u32                             width);
+
+acpi_status
+acpi_os_write_memory (
+	acpi_physical_address           address,
+	u32                             value,
+	u32                             width);
+
+
+/*
+ * Platform and hardware-independent PCI configuration space access
+ */
+
+acpi_status
+acpi_os_read_pci_configuration (
+	struct acpi_pci_id              *pci_id,
+	u32                             register,
+	void                            *value,
+	u32                             width);
+
+acpi_status
+acpi_os_write_pci_configuration (
+	struct acpi_pci_id              *pci_id,
+	u32                             register,
+	acpi_integer                    value,
+	u32                             width);
+
+/*
+ * Interim function needed for PCI IRQ routing
+ */
+void
+acpi_os_derive_pci_id(
+	acpi_handle                     rhandle,
+	acpi_handle                     chandle,
+	struct acpi_pci_id              **pci_id);
+
+/*
+ * Miscellaneous
+ */
+
+BOOLEAN
+acpi_os_readable (
+	void                            *pointer,
+	acpi_size                       length);
+
+BOOLEAN
+acpi_os_writable (
+	void                            *pointer,
+	acpi_size                       length);
+
+u32
+acpi_os_get_timer (
+	void);
+
+acpi_status
+acpi_os_signal (
+	u32                             function,
+	void                            *info);
+
+/*
+ * Debug print routines
+ */
+
+void ACPI_INTERNAL_VAR_XFACE
+acpi_os_printf (
+	const char                      *format,
+	...);
+
+void
+acpi_os_vprintf (
+	const char                      *format,
+	va_list                 args);
+
+void
+acpi_os_redirect_output (
+	void                            *destination);
+
+
+/*
+ * Debug input
+ */
+
+u32
+acpi_os_get_line (
+	char                            *buffer);
+
+
+/*
+ * Directory manipulation
+ */
+
+void *
+acpi_os_open_directory (
+	char                            *pathname,
+	char                            *wildcard_spec,
+	char                            requested_file_type);
+
+/* requeste_file_type values */
+
+#define REQUEST_FILE_ONLY                   0
+#define REQUEST_DIR_ONLY                    1
+
+
+char *
+acpi_os_get_next_filename (
+	void                            *dir_handle);
+
+void
+acpi_os_close_directory (
+	void                            *dir_handle);
+
+/*
+ * Debug
+ */
+
+void
+acpi_os_dbg_assert(
+	void                            *failed_assertion,
+	void                            *file_name,
+	u32                             line_number,
+	char                            *message);
+
+
+#endif /* __ACPIOSXF_H__ */
diff -urNp linux-5400/include/acpi/acpixf.h linux-5410/include/acpi/acpixf.h
--- linux-5400/include/acpi/acpixf.h
+++ linux-5410/include/acpi/acpixf.h
@@ -0,0 +1,462 @@
+
+/******************************************************************************
+ *
+ * Name: acpixf.h - External interfaces to the ACPI subsystem
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+
+#ifndef __ACXFACE_H__
+#define __ACXFACE_H__
+
+#include "actypes.h"
+#include "actbl.h"
+
+
+ /*
+ * Global interfaces
+ */
+
+acpi_status
+acpi_initialize_subsystem (
+	void);
+
+acpi_status
+acpi_enable_subsystem (
+	u32                             flags);
+
+acpi_status
+acpi_initialize_objects (
+	u32                             flags);
+
+acpi_status
+acpi_terminate (
+	void);
+
+acpi_status
+acpi_subsystem_status (
+	void);
+
+acpi_status
+acpi_enable (
+	void);
+
+acpi_status
+acpi_disable (
+	void);
+
+acpi_status
+acpi_get_system_info (
+	struct acpi_buffer              *ret_buffer);
+
+const char *
+acpi_format_exception (
+	acpi_status                     exception);
+
+acpi_status
+acpi_purge_cached_objects (
+	void);
+
+acpi_status
+acpi_install_initialization_handler (
+	acpi_init_handler               handler,
+	u32                             function);
+
+/*
+ * ACPI Memory manager
+ */
+
+void *
+acpi_allocate (
+	u32                             size);
+
+void *
+acpi_callocate (
+	u32                             size);
+
+void
+acpi_free (
+	void                            *address);
+
+
+/*
+ * ACPI table manipulation interfaces
+ */
+
+acpi_status
+acpi_find_root_pointer (
+	u32                             flags,
+	struct acpi_pointer             *rsdp_address);
+
+acpi_status
+acpi_load_tables (
+	void);
+
+acpi_status
+acpi_load_table (
+	struct acpi_table_header        *table_ptr);
+
+acpi_status
+acpi_unload_table (
+	acpi_table_type                 table_type);
+
+acpi_status
+acpi_get_table_header (
+	acpi_table_type                 table_type,
+	u32                             instance,
+	struct acpi_table_header        *out_table_header);
+
+acpi_status
+acpi_get_table (
+	acpi_table_type                 table_type,
+	u32                             instance,
+	struct acpi_buffer              *ret_buffer);
+
+acpi_status
+acpi_get_firmware_table (
+	acpi_string                     signature,
+	u32                             instance,
+	u32                             flags,
+	struct acpi_table_header        **table_pointer);
+
+
+/*
+ * Namespace and name interfaces
+ */
+
+acpi_status
+acpi_walk_namespace (
+	acpi_object_type                type,
+	acpi_handle                     start_object,
+	u32                             max_depth,
+	acpi_walk_callback              user_function,
+	void                            *context,
+	void                            **return_value);
+
+acpi_status
+acpi_get_devices (
+	char                            *HID,
+	acpi_walk_callback              user_function,
+	void                            *context,
+	void                            **return_value);
+
+acpi_status
+acpi_get_name (
+	acpi_handle                     handle,
+	u32                             name_type,
+	struct acpi_buffer              *ret_path_ptr);
+
+acpi_status
+acpi_get_handle (
+	acpi_handle                     parent,
+	acpi_string                     pathname,
+	acpi_handle                     *ret_handle);
+
+acpi_status
+acpi_attach_data (
+	acpi_handle                     obj_handle,
+	acpi_object_handler             handler,
+	void                            *data);
+
+acpi_status
+acpi_detach_data (
+	acpi_handle                     obj_handle,
+	acpi_object_handler             handler);
+
+acpi_status
+acpi_get_data (
+	acpi_handle                     obj_handle,
+	acpi_object_handler             handler,
+	void                            **data);
+
+
+/*
+ * Object manipulation and enumeration
+ */
+
+acpi_status
+acpi_evaluate_object (
+	acpi_handle                     object,
+	acpi_string                     pathname,
+	struct acpi_object_list         *parameter_objects,
+	struct acpi_buffer              *return_object_buffer);
+
+acpi_status
+acpi_evaluate_object_typed (
+	acpi_handle                     object,
+	acpi_string                     pathname,
+	struct acpi_object_list         *external_params,
+	struct acpi_buffer              *return_buffer,
+	acpi_object_type                return_type);
+
+acpi_status
+acpi_get_object_info (
+	acpi_handle                     handle,
+	struct acpi_buffer              *return_buffer);
+
+acpi_status
+acpi_get_next_object (
+	acpi_object_type                type,
+	acpi_handle                     parent,
+	acpi_handle                     child,
+	acpi_handle                     *out_handle);
+
+acpi_status
+acpi_get_type (
+	acpi_handle                     object,
+	acpi_object_type                *out_type);
+
+acpi_status
+acpi_get_parent (
+	acpi_handle                     object,
+	acpi_handle                     *out_handle);
+
+
+/*
+ * Event handler interfaces
+ */
+
+acpi_status
+acpi_install_fixed_event_handler (
+	u32                             acpi_event,
+	acpi_event_handler              handler,
+	void                            *context);
+
+acpi_status
+acpi_remove_fixed_event_handler (
+	u32                             acpi_event,
+	acpi_event_handler              handler);
+
+acpi_status
+acpi_install_notify_handler (
+	acpi_handle                     device,
+	u32                             handler_type,
+	acpi_notify_handler             handler,
+	void                            *context);
+
+acpi_status
+acpi_remove_notify_handler (
+	acpi_handle                     device,
+	u32                             handler_type,
+	acpi_notify_handler             handler);
+
+acpi_status
+acpi_install_address_space_handler (
+	acpi_handle                     device,
+	acpi_adr_space_type             space_id,
+	acpi_adr_space_handler          handler,
+	acpi_adr_space_setup            setup,
+	void                            *context);
+
+acpi_status
+acpi_remove_address_space_handler (
+	acpi_handle                     device,
+	acpi_adr_space_type             space_id,
+	acpi_adr_space_handler          handler);
+
+acpi_status
+acpi_install_gpe_handler (
+	acpi_handle                     gpe_device,
+	u32                             gpe_number,
+	u32                             type,
+	acpi_gpe_handler                handler,
+	void                            *context);
+
+acpi_status
+acpi_acquire_global_lock (
+	u16                             timeout,
+	u32                             *handle);
+
+acpi_status
+acpi_release_global_lock (
+	u32                             handle);
+
+acpi_status
+acpi_remove_gpe_handler (
+	acpi_handle                     gpe_device,
+	u32                             gpe_number,
+	acpi_gpe_handler                handler);
+
+acpi_status
+acpi_enable_event (
+	u32                             event,
+	u32                             flags);
+
+acpi_status
+acpi_disable_event (
+	u32                             event,
+	u32                             flags);
+
+acpi_status
+acpi_clear_event (
+	u32                             event);
+
+acpi_status
+acpi_get_event_status (
+	u32                             event,
+	acpi_event_status               *event_status);
+
+acpi_status
+acpi_enable_gpe (
+	acpi_handle                     gpe_device,
+	u32                             gpe_number,
+	u32                             flags);
+
+acpi_status
+acpi_disable_gpe (
+	acpi_handle                     gpe_device,
+	u32                             gpe_number,
+	u32                             flags);
+
+acpi_status
+acpi_clear_gpe (
+	acpi_handle                     gpe_device,
+	u32                             gpe_number,
+	u32                             flags);
+
+acpi_status
+acpi_get_gpe_status (
+	acpi_handle                     gpe_device,
+	u32                             gpe_number,
+	u32                             flags,
+	acpi_event_status               *event_status);
+
+acpi_status
+acpi_install_gpe_block (
+	acpi_handle                     gpe_device,
+	struct acpi_generic_address     *gpe_block_address,
+	u32                             register_count,
+	u32                             interrupt_level);
+
+acpi_status
+acpi_remove_gpe_block (
+	acpi_handle                     gpe_device);
+
+
+/*
+ * Resource interfaces
+ */
+
+typedef
+acpi_status (*ACPI_WALK_RESOURCE_CALLBACK) (
+	struct acpi_resource            *resource,
+	void                            *context);
+
+
+acpi_status
+acpi_get_current_resources(
+	acpi_handle                     device_handle,
+	struct acpi_buffer              *ret_buffer);
+
+acpi_status
+acpi_get_possible_resources(
+	acpi_handle                     device_handle,
+	struct acpi_buffer              *ret_buffer);
+
+acpi_status
+acpi_walk_resources (
+	acpi_handle                             device_handle,
+	char                                    *path,
+	ACPI_WALK_RESOURCE_CALLBACK     user_function,
+	void                                    *context);
+
+acpi_status
+acpi_set_current_resources (
+	acpi_handle                     device_handle,
+	struct acpi_buffer              *in_buffer);
+
+acpi_status
+acpi_get_irq_routing_table (
+	acpi_handle                     bus_device_handle,
+	struct acpi_buffer              *ret_buffer);
+
+acpi_status
+acpi_resource_to_address64 (
+	struct acpi_resource            *resource,
+	struct acpi_resource_address64 *out);
+
+/*
+ * Hardware (ACPI device) interfaces
+ */
+
+acpi_status
+acpi_get_register (
+	u32                             register_id,
+	u32                             *return_value,
+	u32                             flags);
+
+acpi_status
+acpi_set_register (
+	u32                             register_id,
+	u32                             value,
+	u32                             flags);
+
+acpi_status
+acpi_set_firmware_waking_vector (
+	acpi_physical_address           physical_address);
+
+acpi_status
+acpi_get_firmware_waking_vector (
+	acpi_physical_address           *physical_address);
+
+acpi_status
+acpi_get_sleep_type_data (
+	u8                              sleep_state,
+	u8                              *slp_typ_a,
+	u8                              *slp_typ_b);
+
+acpi_status
+acpi_enter_sleep_state_prep (
+	u8                              sleep_state);
+
+acpi_status
+acpi_enter_sleep_state (
+	u8                              sleep_state);
+
+acpi_status
+acpi_enter_sleep_state_s4bios (
+	void);
+
+acpi_status
+acpi_leave_sleep_state (
+	u8                              sleep_state);
+
+
+#endif /* __ACXFACE_H__ */
diff -urNp linux-5400/include/acpi/acresrc.h linux-5410/include/acpi/acresrc.h
--- linux-5400/include/acpi/acresrc.h
+++ linux-5410/include/acpi/acresrc.h
@@ -0,0 +1,391 @@
+/******************************************************************************
+ *
+ * Name: acresrc.h - Resource Manager function prototypes
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACRESRC_H__
+#define __ACRESRC_H__
+
+
+/*
+ *  Function prototypes called from Acpi* APIs
+ */
+
+acpi_status
+acpi_rs_get_prt_method_data (
+	acpi_handle                     handle,
+	struct acpi_buffer              *ret_buffer);
+
+
+acpi_status
+acpi_rs_get_crs_method_data (
+	acpi_handle                     handle,
+	struct acpi_buffer              *ret_buffer);
+
+acpi_status
+acpi_rs_get_prs_method_data (
+	acpi_handle                     handle,
+	struct acpi_buffer              *ret_buffer);
+
+acpi_status
+acpi_rs_get_method_data (
+	acpi_handle                     handle,
+	char                            *path,
+	struct acpi_buffer              *ret_buffer);
+
+acpi_status
+acpi_rs_set_srs_method_data (
+	acpi_handle                     handle,
+	struct acpi_buffer              *ret_buffer);
+
+acpi_status
+acpi_rs_create_resource_list (
+	union acpi_operand_object       *byte_stream_buffer,
+	struct acpi_buffer              *output_buffer);
+
+acpi_status
+acpi_rs_create_byte_stream (
+	struct acpi_resource            *linked_list_buffer,
+	struct acpi_buffer              *output_buffer);
+
+acpi_status
+acpi_rs_create_pci_routing_table (
+	union acpi_operand_object       *package_object,
+	struct acpi_buffer              *output_buffer);
+
+
+/*
+ * Function prototypes called from acpi_rs_create*
+ */
+void
+acpi_rs_dump_irq (
+	union acpi_resource_data        *data);
+
+void
+acpi_rs_dump_address16 (
+	union acpi_resource_data        *data);
+
+void
+acpi_rs_dump_address32 (
+	union acpi_resource_data        *data);
+
+void
+acpi_rs_dump_address64 (
+	union acpi_resource_data        *data);
+
+void
+acpi_rs_dump_dma (
+	union acpi_resource_data        *data);
+
+void
+acpi_rs_dump_io (
+	union acpi_resource_data        *data);
+
+void
+acpi_rs_dump_extended_irq (
+	union acpi_resource_data        *data);
+
+void
+acpi_rs_dump_fixed_io (
+	union acpi_resource_data        *data);
+
+void
+acpi_rs_dump_fixed_memory32 (
+	union acpi_resource_data        *data);
+
+void
+acpi_rs_dump_memory24 (
+	union acpi_resource_data        *data);
+
+void
+acpi_rs_dump_memory32 (
+	union acpi_resource_data        *data);
+
+void
+acpi_rs_dump_start_depend_fns (
+	union acpi_resource_data        *data);
+
+void
+acpi_rs_dump_vendor_specific (
+	union acpi_resource_data        *data);
+
+void
+acpi_rs_dump_resource_list (
+	struct acpi_resource            *resource);
+
+void
+acpi_rs_dump_irq_list (
+	u8                              *route_table);
+
+acpi_status
+acpi_rs_get_byte_stream_start (
+	u8                              *byte_stream_buffer,
+	u8                              **byte_stream_start,
+	u32                             *size);
+
+acpi_status
+acpi_rs_get_list_length (
+	u8                              *byte_stream_buffer,
+	u32                             byte_stream_buffer_length,
+	acpi_size                       *size_needed);
+
+acpi_status
+acpi_rs_get_byte_stream_length (
+	struct acpi_resource            *linked_list_buffer,
+	acpi_size                       *size_needed);
+
+acpi_status
+acpi_rs_get_pci_routing_table_length (
+	union acpi_operand_object       *package_object,
+	acpi_size                       *buffer_size_needed);
+
+acpi_status
+acpi_rs_byte_stream_to_list (
+	u8                              *byte_stream_buffer,
+	u32                             byte_stream_buffer_length,
+	u8                              *output_buffer);
+
+acpi_status
+acpi_rs_list_to_byte_stream (
+	struct acpi_resource            *linked_list,
+	acpi_size                       byte_stream_size_needed,
+	u8                              *output_buffer);
+
+acpi_status
+acpi_rs_io_resource (
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size);
+
+acpi_status
+acpi_rs_fixed_io_resource (
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size);
+
+acpi_status
+acpi_rs_io_stream (
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed);
+
+acpi_status
+acpi_rs_fixed_io_stream (
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed);
+
+acpi_status
+acpi_rs_irq_resource (
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size);
+
+acpi_status
+acpi_rs_irq_stream (
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed);
+
+acpi_status
+acpi_rs_dma_resource (
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size);
+
+acpi_status
+acpi_rs_dma_stream (
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed);
+
+acpi_status
+acpi_rs_address16_resource (
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size);
+
+acpi_status
+acpi_rs_address16_stream (
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed);
+
+acpi_status
+acpi_rs_address32_resource (
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size);
+
+acpi_status
+acpi_rs_address32_stream (
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed);
+
+acpi_status
+acpi_rs_address64_resource (
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size);
+
+acpi_status
+acpi_rs_address64_stream (
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed);
+
+acpi_status
+acpi_rs_start_depend_fns_resource (
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size);
+
+acpi_status
+acpi_rs_end_depend_fns_resource (
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size);
+
+acpi_status
+acpi_rs_start_depend_fns_stream (
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed);
+
+acpi_status
+acpi_rs_end_depend_fns_stream (
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed);
+
+acpi_status
+acpi_rs_memory24_resource (
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size);
+
+acpi_status
+acpi_rs_memory24_stream (
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed);
+
+acpi_status
+acpi_rs_memory32_range_resource (
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size);
+
+acpi_status
+acpi_rs_fixed_memory32_resource (
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size);
+
+acpi_status
+acpi_rs_memory32_range_stream (
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed);
+
+acpi_status
+acpi_rs_fixed_memory32_stream (
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed);
+
+acpi_status
+acpi_rs_extended_irq_resource (
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size);
+
+acpi_status
+acpi_rs_extended_irq_stream (
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed);
+
+acpi_status
+acpi_rs_end_tag_resource (
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size);
+
+acpi_status
+acpi_rs_end_tag_stream (
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed);
+
+acpi_status
+acpi_rs_vendor_resource (
+	u8                              *byte_stream_buffer,
+	acpi_size                       *bytes_consumed,
+	u8                              **output_buffer,
+	acpi_size                       *structure_size);
+
+acpi_status
+acpi_rs_vendor_stream (
+	struct acpi_resource            *linked_list,
+	u8                              **output_buffer,
+	acpi_size                       *bytes_consumed);
+
+u8
+acpi_rs_get_resource_type (
+	u8                              resource_start_byte);
+
+#endif  /* __ACRESRC_H__ */
diff -urNp linux-5400/include/acpi/acstruct.h linux-5410/include/acpi/acstruct.h
--- linux-5400/include/acpi/acstruct.h
+++ linux-5410/include/acpi/acstruct.h
@@ -0,0 +1,202 @@
+/******************************************************************************
+ *
+ * Name: acstruct.h - Internal structs
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACSTRUCT_H__
+#define __ACSTRUCT_H__
+
+
+/*****************************************************************************
+ *
+ * Tree walking typedefs and structs
+ *
+ ****************************************************************************/
+
+
+/*
+ * Walk state - current state of a parse tree walk.  Used for both a leisurely stroll through
+ * the tree (for whatever reason), and for control method execution.
+ */
+
+#define ACPI_NEXT_OP_DOWNWARD       1
+#define ACPI_NEXT_OP_UPWARD         2
+
+#define ACPI_WALK_NON_METHOD        0
+#define ACPI_WALK_METHOD            1
+#define ACPI_WALK_METHOD_RESTART    2
+#define ACPI_WALK_CONST_REQUIRED    3
+#define ACPI_WALK_CONST_OPTIONAL    4
+
+struct acpi_walk_state
+{
+	u8                                  data_type;                          /* To differentiate various internal objs MUST BE FIRST!*/\
+	acpi_owner_id                       owner_id;                           /* Owner of objects created during the walk */
+	u8                                  last_predicate;                     /* Result of last predicate */
+	u8                                  current_result;                     /* */
+	u8                                  next_op_info;                       /* Info about next_op */
+	u8                                  num_operands;                       /* Stack pointer for Operands[] array */
+	u8                                  return_used;
+	u8                                  walk_type;
+	u16                                 opcode;                             /* Current AML opcode */
+	u8                                  scope_depth;
+	u8                                  reserved1;
+	u32                                 arg_count;                          /* push for fixed or var args */
+	u32                                 aml_offset;
+	u32                                 arg_types;
+	u32                                 method_breakpoint;                  /* For single stepping */
+	u32                                 user_breakpoint;                    /* User AML breakpoint */
+	u32                                 parse_flags;
+	u32                                 prev_arg_types;
+
+	u8                                  *aml_last_while;
+	struct acpi_namespace_node          arguments[ACPI_METHOD_NUM_ARGS];    /* Control method arguments */
+	union acpi_operand_object           **caller_return_desc;
+	union acpi_generic_state            *control_state;                     /* List of control states (nested IFs) */
+	struct acpi_namespace_node          local_variables[ACPI_METHOD_NUM_LOCALS];    /* Control method locals */
+	struct acpi_namespace_node          *method_call_node;                  /* Called method Node*/
+	union acpi_parse_object             *method_call_op;                    /* method_call Op if running a method */
+	union acpi_operand_object           *method_desc;                       /* Method descriptor if running a method */
+	struct acpi_namespace_node          *method_node;                       /* Method Node if running a method */
+	union acpi_parse_object             *op;                                /* Current parser op */
+	union acpi_operand_object           *operands[ACPI_OBJ_NUM_OPERANDS+1]; /* Operands passed to the interpreter (+1 for NULL terminator) */
+	const struct acpi_opcode_info       *op_info;                           /* Info on current opcode */
+	union acpi_parse_object             *origin;                            /* Start of walk [Obsolete] */
+	union acpi_operand_object           **params;
+	struct acpi_parse_state             parser_state;                       /* Current state of parser */
+	union acpi_operand_object           *result_obj;
+	union acpi_generic_state            *results;                           /* Stack of accumulated results */
+	union acpi_operand_object           *return_desc;                       /* Return object, if any */
+	union acpi_generic_state            *scope_info;                        /* Stack of nested scopes */
+
+	union acpi_parse_object             *prev_op;                           /* Last op that was processed */
+	union acpi_parse_object             *next_op;                           /* next op to be processed */
+	acpi_parse_downwards                descending_callback;
+	acpi_parse_upwards                  ascending_callback;
+	struct acpi_thread_state            *thread;
+	struct acpi_walk_state              *next;                              /* Next walk_state in list */
+};
+
+
+/* Info used by acpi_ps_init_objects */
+
+struct acpi_init_walk_info
+{
+	u16                             method_count;
+	u16                             device_count;
+	u16                             op_region_count;
+	u16                             field_count;
+	u16                             buffer_count;
+	u16                             package_count;
+	u16                             op_region_init;
+	u16                             field_init;
+	u16                             buffer_init;
+	u16                             package_init;
+	u16                             object_count;
+	struct acpi_table_desc          *table_desc;
+};
+
+
+/* Info used by acpi_ns_initialize_devices */
+
+struct acpi_device_walk_info
+{
+	u16                             device_count;
+	u16                             num_STA;
+	u16                             num_INI;
+	struct acpi_table_desc          *table_desc;
+};
+
+
+/* TBD: [Restructure] Merge with struct above */
+
+struct acpi_walk_info
+{
+	u32                             debug_level;
+	u32                             owner_id;
+	u8                              display_type;
+};
+
+/* Display Types */
+
+#define ACPI_DISPLAY_SUMMARY    0
+#define ACPI_DISPLAY_OBJECTS    1
+
+struct acpi_get_devices_info
+{
+	acpi_walk_callback              user_function;
+	void                            *context;
+	char                            *hid;
+};
+
+
+union acpi_aml_operands
+{
+	union acpi_operand_object           *operands[7];
+
+	struct
+	{
+		struct acpi_object_integer      *type;
+		struct acpi_object_integer      *code;
+		struct acpi_object_integer      *argument;
+
+	} fatal;
+
+	struct
+	{
+		union acpi_operand_object       *source;
+		struct acpi_object_integer      *index;
+		union acpi_operand_object       *target;
+
+	} index;
+
+	struct
+	{
+		union acpi_operand_object       *source;
+		struct acpi_object_integer      *index;
+		struct acpi_object_integer      *length;
+		union acpi_operand_object       *target;
+
+	} mid;
+};
+
+
+#endif
diff -urNp linux-5400/include/acpi/actables.h linux-5410/include/acpi/actables.h
--- linux-5400/include/acpi/actables.h
+++ linux-5410/include/acpi/actables.h
@@ -0,0 +1,233 @@
+/******************************************************************************
+ *
+ * Name: actables.h - ACPI table management
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACTABLES_H__
+#define __ACTABLES_H__
+
+
+/* Used in acpi_tb_map_acpi_table for size parameter if table header is to be used */
+
+#define SIZE_IN_HEADER          0
+
+
+acpi_status
+acpi_tb_handle_to_object (
+	u16                             table_id,
+	struct acpi_table_desc          **table_desc);
+
+/*
+ * tbconvrt - Table conversion routines
+ */
+
+acpi_status
+acpi_tb_convert_to_xsdt (
+	struct acpi_table_desc          *table_info);
+
+acpi_status
+acpi_tb_convert_table_fadt (
+	void);
+
+acpi_status
+acpi_tb_build_common_facs (
+	struct acpi_table_desc          *table_info);
+
+u32
+acpi_tb_get_table_count (
+	struct rsdp_descriptor          *RSDP,
+	struct acpi_table_header        *RSDT);
+
+/*
+ * tbget - Table "get" routines
+ */
+
+acpi_status
+acpi_tb_get_table (
+	struct acpi_pointer             *address,
+	struct acpi_table_desc          *table_info);
+
+acpi_status
+acpi_tb_get_table_header (
+	struct acpi_pointer             *address,
+	struct acpi_table_header        *return_header);
+
+acpi_status
+acpi_tb_get_table_body (
+	struct acpi_pointer             *address,
+	struct acpi_table_header        *header,
+	struct acpi_table_desc          *table_info);
+
+acpi_status
+acpi_tb_get_this_table (
+	struct acpi_pointer             *address,
+	struct acpi_table_header        *header,
+	struct acpi_table_desc          *table_info);
+
+acpi_status
+acpi_tb_table_override (
+	struct acpi_table_header        *header,
+	struct acpi_table_desc          *table_info);
+
+acpi_status
+acpi_tb_get_table_ptr (
+	acpi_table_type                 table_type,
+	u32                             instance,
+	struct acpi_table_header        **table_ptr_loc);
+
+acpi_status
+acpi_tb_verify_rsdp (
+	struct acpi_pointer             *address);
+
+void
+acpi_tb_get_rsdt_address (
+	struct acpi_pointer             *out_address);
+
+acpi_status
+acpi_tb_validate_rsdt (
+	struct acpi_table_header        *table_ptr);
+
+acpi_status
+acpi_tb_get_required_tables (
+	void);
+
+acpi_status
+acpi_tb_get_primary_table (
+	struct acpi_pointer             *address,
+	struct acpi_table_desc          *table_info);
+
+acpi_status
+acpi_tb_get_secondary_table (
+	struct acpi_pointer             *address,
+	acpi_string                     signature,
+	struct acpi_table_desc          *table_info);
+
+/*
+ * tbinstall - Table installation
+ */
+
+acpi_status
+acpi_tb_install_table (
+	struct acpi_table_desc          *table_info);
+
+acpi_status
+acpi_tb_match_signature (
+	char                            *signature,
+	struct acpi_table_desc          *table_info,
+	u8                              search_type);
+
+acpi_status
+acpi_tb_recognize_table (
+	struct acpi_table_desc          *table_info,
+	u8                              search_type);
+
+acpi_status
+acpi_tb_init_table_descriptor (
+	acpi_table_type                 table_type,
+	struct acpi_table_desc          *table_info);
+
+
+/*
+ * tbremove - Table removal and deletion
+ */
+
+void
+acpi_tb_delete_all_tables (
+	void);
+
+void
+acpi_tb_delete_tables_by_type (
+	acpi_table_type                 type);
+
+void
+acpi_tb_delete_single_table (
+	struct acpi_table_desc          *table_desc);
+
+struct acpi_table_desc *
+acpi_tb_uninstall_table (
+	struct acpi_table_desc          *table_desc);
+
+
+/*
+ * tbrsd - RSDP, RSDT utilities
+ */
+
+acpi_status
+acpi_tb_get_table_rsdt (
+	void);
+
+u8 *
+acpi_tb_scan_memory_for_rsdp (
+	u8                              *start_address,
+	u32                             length);
+
+acpi_status
+acpi_tb_find_rsdp (
+	struct acpi_table_desc          *table_info,
+	u32                             flags);
+
+
+/*
+ * tbutils - common table utilities
+ */
+
+acpi_status
+acpi_tb_find_table (
+	char                            *signature,
+	char                            *oem_id,
+	char                            *oem_table_id,
+	struct acpi_table_header        **table_ptr);
+
+acpi_status
+acpi_tb_verify_table_checksum (
+	struct acpi_table_header        *table_header);
+
+u8
+acpi_tb_checksum (
+	void                            *buffer,
+	u32                             length);
+
+acpi_status
+acpi_tb_validate_table_header (
+	struct acpi_table_header        *table_header);
+
+
+#endif /* __ACTABLES_H__ */
diff -urNp linux-5400/include/acpi/actbl.h linux-5410/include/acpi/actbl.h
--- linux-5400/include/acpi/actbl.h
+++ linux-5410/include/acpi/actbl.h
@@ -0,0 +1,235 @@
+/******************************************************************************
+ *
+ * Name: actbl.h - Table data structures defined in ACPI specification
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACTBL_H__
+#define __ACTBL_H__
+
+
+/*
+ *  Values for description table header signatures
+ */
+#define RSDP_NAME               "RSDP"
+#define RSDP_SIG                "RSD PTR "  /* RSDT Pointer signature */
+#define APIC_SIG                "APIC"      /* Multiple APIC Description Table */
+#define DSDT_SIG                "DSDT"      /* Differentiated System Description Table */
+#define FADT_SIG                "FACP"      /* Fixed ACPI Description Table */
+#define FACS_SIG                "FACS"      /* Firmware ACPI Control Structure */
+#define PSDT_SIG                "PSDT"      /* Persistent System Description Table */
+#define RSDT_SIG                "RSDT"      /* Root System Description Table */
+#define XSDT_SIG                "XSDT"      /* Extended  System Description Table */
+#define SSDT_SIG                "SSDT"      /* Secondary System Description Table */
+#define SBST_SIG                "SBST"      /* Smart Battery Specification Table */
+#define SPIC_SIG                "SPIC"      /* IOSAPIC table */
+#define BOOT_SIG                "BOOT"      /* Boot table */
+
+
+#define GL_OWNED                0x02        /* Ownership of global lock is bit 1 */
+
+/* values of Mapic.Model */
+
+#define DUAL_PIC                0
+#define MULTIPLE_APIC           1
+
+/* values of Type in struct apic_header */
+
+#define APIC_PROC               0
+#define APIC_IO                 1
+
+
+/*
+ * Common table types.  The base code can remain
+ * constant if the underlying tables are changed
+ */
+#define RSDT_DESCRIPTOR         struct rsdt_descriptor_rev2
+#define XSDT_DESCRIPTOR         struct xsdt_descriptor_rev2
+#define FACS_DESCRIPTOR         struct facs_descriptor_rev2
+#define FADT_DESCRIPTOR         struct fadt_descriptor_rev2
+
+
+#pragma pack(1)
+
+/*
+ * Architecture-independent tables
+ * The architecture dependent tables are in separate files
+ */
+struct rsdp_descriptor         /* Root System Descriptor Pointer */
+{
+	char                            signature [8];          /* ACPI signature, contains "RSD PTR " */
+	u8                              checksum;               /* To make sum of struct == 0 */
+	char                            oem_id [6];             /* OEM identification */
+	u8                              revision;               /* Must be 0 for 1.0, 2 for 2.0 */
+	u32                             rsdt_physical_address;  /* 32-bit physical address of RSDT */
+	u32                             length;                 /* XSDT Length in bytes including hdr */
+	u64                             xsdt_physical_address;  /* 64-bit physical address of XSDT */
+	u8                              extended_checksum;      /* Checksum of entire table */
+	char                            reserved [3];           /* Reserved field must be 0 */
+};
+
+
+struct acpi_table_header         /* ACPI common table header */
+{
+	char                            signature [4];          /* ACPI signature (4 ASCII characters) */
+	u32                             length;                 /* Length of table, in bytes, including header */
+	u8                              revision;               /* ACPI Specification minor version # */
+	u8                              checksum;               /* To make sum of entire table == 0 */
+	char                            oem_id [6];             /* OEM identification */
+	char                            oem_table_id [8];       /* OEM table identification */
+	u32                             oem_revision;           /* OEM revision number */
+	char                            asl_compiler_id [4];    /* ASL compiler vendor ID */
+	u32                             asl_compiler_revision;  /* ASL compiler revision number */
+};
+
+
+struct acpi_common_facs          /* Common FACS for internal use */
+{
+	u32                             *global_lock;
+	u64                             *firmware_waking_vector;
+	u8                              vector_width;
+};
+
+
+struct apic_table
+{
+	struct acpi_table_header        header;                 /* ACPI table header */
+	u32                             local_apic_address;     /* Physical address for accessing local APICs */
+	u32                             PCATcompat      : 1;    /* a one indicates system also has dual 8259s */
+	u32                             reserved1       : 31;
+};
+
+
+struct apic_header
+{
+	u8                              type;                   /* APIC type.  Either APIC_PROC or APIC_IO */
+	u8                              length;                 /* Length of APIC structure */
+};
+
+
+struct processor_apic
+{
+	struct apic_header              header;
+	u8                              processor_apic_id;      /* ACPI processor id */
+	u8                              local_apic_id;          /* Processor's local APIC id */
+	u32                             processor_enabled: 1;   /* Processor is usable if set */
+	u32                             reserved1       : 31;
+};
+
+
+struct io_apic
+{
+	struct apic_header              header;
+	u8                              io_apic_id;             /* I/O APIC ID */
+	u8                              reserved;               /* Reserved - must be zero */
+	u32                             io_apic_address;        /* APIC's physical address */
+	u32                             vector;                 /* Interrupt vector index where INTI
+			  * lines start */
+};
+
+
+/*
+ *  IA64 TBD:  Add SAPIC Tables
+ */
+
+/*
+ *  IA64 TBD:   Modify Smart Battery Description to comply with ACPI IA64
+ *              extensions.
+ */
+struct smart_battery_description_table
+{
+	struct acpi_table_header        header;
+	u32                             warning_level;
+	u32                             low_level;
+	u32                             critical_level;
+};
+
+struct hpet_description_table
+{
+	struct acpi_table_header        header;
+	u32                             hardware_id;
+	u32                             base_address[3];
+	u8                              hpet_number;
+	u16                             clock_tick;
+	u8                              attributes;
+};
+#pragma pack()
+
+
+/*
+ * ACPI Table information.  We save the table address, length,
+ * and type of memory allocation (mapped or allocated) for each
+ * table for 1) when we exit, and 2) if a new table is installed
+ */
+#define ACPI_MEM_NOT_ALLOCATED  0
+#define ACPI_MEM_ALLOCATED      1
+#define ACPI_MEM_MAPPED         2
+
+/* Definitions for the Flags bitfield member of struct acpi_table_support */
+
+#define ACPI_TABLE_SINGLE       0x00
+#define ACPI_TABLE_MULTIPLE     0x01
+#define ACPI_TABLE_EXECUTABLE   0x02
+
+#define ACPI_TABLE_ROOT         0x00
+#define ACPI_TABLE_PRIMARY      0x10
+#define ACPI_TABLE_SECONDARY    0x20
+#define ACPI_TABLE_ALL          0x30
+#define ACPI_TABLE_TYPE_MASK    0x30
+
+/* Data about each known table type */
+
+struct acpi_table_support
+{
+	char                            *name;
+	char                            *signature;
+	void                            **global_ptr;
+	u8                              sig_length;
+	u8                              flags;
+};
+
+
+/*
+ * Get the architecture-specific tables
+ */
+#include "actbl1.h"   /* Acpi 1.0 table definitions */
+#include "actbl2.h"   /* Acpi 2.0 table definitions */
+
+#endif /* __ACTBL_H__ */
diff -urNp linux-5400/include/acpi/actbl1.h linux-5410/include/acpi/actbl1.h
--- linux-5400/include/acpi/actbl1.h
+++ linux-5410/include/acpi/actbl1.h
@@ -0,0 +1,136 @@
+/******************************************************************************
+ *
+ * Name: actbl1.h - ACPI 1.0 tables
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACTBL1_H__
+#define __ACTBL1_H__
+
+#pragma pack(1)
+
+/*
+ * ACPI 1.0 Root System Description Table (RSDT)
+ */
+struct rsdt_descriptor_rev1
+{
+	struct acpi_table_header        header;                 /* ACPI Table header */
+	u32                             table_offset_entry [1]; /* Array of pointers to other */
+			 /* ACPI tables */
+};
+
+
+/*
+ * ACPI 1.0 Firmware ACPI Control Structure (FACS)
+ */
+struct facs_descriptor_rev1
+{
+	char                            signature[4];           /* ACPI Signature */
+	u32                             length;                 /* Length of structure, in bytes */
+	u32                             hardware_signature;     /* Hardware configuration signature */
+	u32                             firmware_waking_vector; /* ACPI OS waking vector */
+	u32                             global_lock;            /* Global Lock */
+	u32                             S4bios_f        : 1;    /* Indicates if S4BIOS support is present */
+	u32                             reserved1       : 31;   /* Must be 0 */
+	u8                              resverved3 [40];        /* Reserved - must be zero */
+};
+
+
+/*
+ * ACPI 1.0 Fixed ACPI Description Table (FADT)
+ */
+struct fadt_descriptor_rev1
+{
+	struct acpi_table_header        header;                 /* ACPI Table header */
+	u32                             firmware_ctrl;          /* Physical address of FACS */
+	u32                             dsdt;                   /* Physical address of DSDT */
+	u8                              model;                  /* System Interrupt Model */
+	u8                              reserved1;              /* Reserved */
+	u16                             sci_int;                /* System vector of SCI interrupt */
+	u32                             smi_cmd;                /* Port address of SMI command port */
+	u8                              acpi_enable;            /* Value to write to smi_cmd to enable ACPI */
+	u8                              acpi_disable;           /* Value to write to smi_cmd to disable ACPI */
+	u8                              S4bios_req;             /* Value to write to SMI CMD to enter S4BIOS state */
+	u8                              reserved2;              /* Reserved - must be zero */
+	u32                             pm1a_evt_blk;           /* Port address of Power Mgt 1a acpi_event Reg Blk */
+	u32                             pm1b_evt_blk;           /* Port address of Power Mgt 1b acpi_event Reg Blk */
+	u32                             pm1a_cnt_blk;           /* Port address of Power Mgt 1a Control Reg Blk */
+	u32                             pm1b_cnt_blk;           /* Port address of Power Mgt 1b Control Reg Blk */
+	u32                             pm2_cnt_blk;            /* Port address of Power Mgt 2 Control Reg Blk */
+	u32                             pm_tmr_blk;             /* Port address of Power Mgt Timer Ctrl Reg Blk */
+	u32                             gpe0_blk;               /* Port addr of General Purpose acpi_event 0 Reg Blk */
+	u32                             gpe1_blk;               /* Port addr of General Purpose acpi_event 1 Reg Blk */
+	u8                              pm1_evt_len;            /* Byte length of ports at pm1_x_evt_blk */
+	u8                              pm1_cnt_len;            /* Byte length of ports at pm1_x_cnt_blk */
+	u8                              pm2_cnt_len;            /* Byte Length of ports at pm2_cnt_blk */
+	u8                              pm_tm_len;              /* Byte Length of ports at pm_tm_blk */
+	u8                              gpe0_blk_len;           /* Byte Length of ports at gpe0_blk */
+	u8                              gpe1_blk_len;           /* Byte Length of ports at gpe1_blk */
+	u8                              gpe1_base;              /* Offset in gpe model where gpe1 events start */
+	u8                              reserved3;              /* Reserved */
+	u16                             plvl2_lat;              /* Worst case HW latency to enter/exit C2 state */
+	u16                             plvl3_lat;              /* Worst case HW latency to enter/exit C3 state */
+	u16                             flush_size;             /* Size of area read to flush caches */
+	u16                             flush_stride;           /* Stride used in flushing caches */
+	u8                              duty_offset;            /* Bit location of duty cycle field in p_cnt reg */
+	u8                              duty_width;             /* Bit width of duty cycle field in p_cnt reg */
+	u8                              day_alrm;               /* Index to day-of-month alarm in RTC CMOS RAM */
+	u8                              mon_alrm;               /* Index to month-of-year alarm in RTC CMOS RAM */
+	u8                              century;                /* Index to century in RTC CMOS RAM */
+	u8                              reserved4;              /* Reserved */
+	u8                              reserved4a;             /* Reserved */
+	u8                              reserved4b;             /* Reserved */
+	u32                             wb_invd         : 1;    /* The wbinvd instruction works properly */
+	u32                             wb_invd_flush   : 1;    /* The wbinvd flushes but does not invalidate */
+	u32                             proc_c1         : 1;    /* All processors support C1 state */
+	u32                             plvl2_up        : 1;    /* C2 state works on MP system */
+	u32                             pwr_button      : 1;    /* Power button is handled as a generic feature */
+	u32                             sleep_button    : 1;    /* Sleep button is handled as a generic feature, or not present */
+	u32                             fixed_rTC       : 1;    /* RTC wakeup stat not in fixed register space */
+	u32                             rtcs4           : 1;    /* RTC wakeup stat not possible from S4 */
+	u32                             tmr_val_ext     : 1;    /* The tmr_val width is 32 bits (0 = 24 bits) */
+	u32                             reserved5       : 23;   /* Reserved - must be zero */
+};
+
+#pragma pack()
+
+#endif /* __ACTBL1_H__ */
+
+
diff -urNp linux-5400/include/acpi/actbl2.h linux-5410/include/acpi/actbl2.h
--- linux-5400/include/acpi/actbl2.h
+++ linux-5410/include/acpi/actbl2.h
@@ -0,0 +1,203 @@
+/******************************************************************************
+ *
+ * Name: actbl2.h - ACPI Specification Revision 2.0 Tables
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACTBL2_H__
+#define __ACTBL2_H__
+
+/*
+ * Prefered Power Management Profiles
+ */
+#define PM_UNSPECIFIED                  0
+#define PM_DESKTOP                      1
+#define PM_MOBILE                       2
+#define PM_WORKSTATION                  3
+#define PM_ENTERPRISE_SERVER            4
+#define PM_SOHO_SERVER                  5
+#define PM_APPLIANCE_PC                 6
+
+/*
+ * ACPI Boot Arch Flags
+ */
+#define BAF_LEGACY_DEVICES              0x0001
+#define BAF_8042_KEYBOARD_CONTROLLER    0x0002
+
+#define FADT2_INTERIM_REVISION_ID       2
+#define FADT2_INTERIM_LENGTH            0x84
+#define FADT2_REVISION_ID               3
+
+
+#pragma pack(1)
+
+/*
+ * ACPI 2.0 Root System Description Table (RSDT)
+ */
+struct rsdt_descriptor_rev2
+{
+	struct acpi_table_header        header;                 /* ACPI table header */
+	u32                             table_offset_entry [1]; /* Array of pointers to  */
+			 /* ACPI table headers */
+};
+
+
+/*
+ * ACPI 2.0 Extended System Description Table (XSDT)
+ */
+struct xsdt_descriptor_rev2
+{
+	struct acpi_table_header        header;                 /* ACPI table header */
+	u64                             table_offset_entry [1]; /* Array of pointers to  */
+			 /* ACPI table headers */
+};
+
+
+/*
+ * ACPI 2.0 Firmware ACPI Control Structure (FACS)
+ */
+struct facs_descriptor_rev2
+{
+	char                            signature[4];           /* ACPI signature */
+	u32                             length;                 /* Length of structure, in bytes */
+	u32                             hardware_signature;     /* Hardware configuration signature */
+	u32                             firmware_waking_vector; /* 32bit physical address of the Firmware Waking Vector. */
+	u32                             global_lock;            /* Global Lock used to synchronize access to shared hardware resources */
+	u32                             S4bios_f        : 1;    /* S4Bios_f - Indicates if S4BIOS support is present */
+	u32                             reserved1       : 31;   /* Must be 0 */
+	u64                             xfirmware_waking_vector; /* 64bit physical address of the Firmware Waking Vector. */
+	u8                              version;                /* Version of this table */
+	u8                              reserved3 [31];         /* Reserved - must be zero */
+};
+
+
+/*
+ * ACPI 2.0 Generic Address Structure (GAS)
+ */
+struct acpi_generic_address
+{
+	u8                              address_space_id;       /* Address space where struct or register exists. */
+	u8                              register_bit_width;     /* Size in bits of given register */
+	u8                              register_bit_offset;    /* Bit offset within the register */
+	u8                              reserved;               /* Must be 0 */
+	u64                             address;                /* 64-bit address of struct or register */
+};
+
+
+/*
+ * ACPI 2.0 Fixed ACPI Description Table (FADT)
+ */
+struct fadt_descriptor_rev2
+{
+	struct acpi_table_header        header;             /* ACPI table header */
+	u32                             V1_firmware_ctrl;   /* 32-bit physical address of FACS */
+	u32                             V1_dsdt;            /* 32-bit physical address of DSDT */
+	u8                              reserved1;          /* System Interrupt Model isn't used in ACPI 2.0*/
+	u8                              prefer_PM_profile;  /* Conveys preferred power management profile to OSPM. */
+	u16                             sci_int;            /* System vector of SCI interrupt */
+	u32                             smi_cmd;            /* Port address of SMI command port */
+	u8                              acpi_enable;        /* Value to write to smi_cmd to enable ACPI */
+	u8                              acpi_disable;       /* Value to write to smi_cmd to disable ACPI */
+	u8                              S4bios_req;         /* Value to write to SMI CMD to enter S4BIOS state */
+	u8                              pstate_cnt;         /* Processor performance state control*/
+	u32                             V1_pm1a_evt_blk;    /* Port address of Power Mgt 1a acpi_event Reg Blk */
+	u32                             V1_pm1b_evt_blk;    /* Port address of Power Mgt 1b acpi_event Reg Blk */
+	u32                             V1_pm1a_cnt_blk;    /* Port address of Power Mgt 1a Control Reg Blk */
+	u32                             V1_pm1b_cnt_blk;    /* Port address of Power Mgt 1b Control Reg Blk */
+	u32                             V1_pm2_cnt_blk;     /* Port address of Power Mgt 2 Control Reg Blk */
+	u32                             V1_pm_tmr_blk;      /* Port address of Power Mgt Timer Ctrl Reg Blk */
+	u32                             V1_gpe0_blk;        /* Port addr of General Purpose acpi_event 0 Reg Blk */
+	u32                             V1_gpe1_blk;        /* Port addr of General Purpose acpi_event 1 Reg Blk */
+	u8                              pm1_evt_len;        /* Byte length of ports at pm1_x_evt_blk */
+	u8                              pm1_cnt_len;        /* Byte length of ports at pm1_x_cnt_blk */
+	u8                              pm2_cnt_len;        /* Byte Length of ports at pm2_cnt_blk */
+	u8                              pm_tm_len;          /* Byte Length of ports at pm_tm_blk */
+	u8                              gpe0_blk_len;       /* Byte Length of ports at gpe0_blk */
+	u8                              gpe1_blk_len;       /* Byte Length of ports at gpe1_blk */
+	u8                              gpe1_base;          /* Offset in gpe model where gpe1 events start */
+	u8                              cst_cnt;            /* Support for the _CST object and C States change notification.*/
+	u16                             plvl2_lat;          /* Worst case HW latency to enter/exit C2 state */
+	u16                             plvl3_lat;          /* Worst case HW latency to enter/exit C3 state */
+	u16                             flush_size;         /* Number of flush strides that need to be read */
+	u16                             flush_stride;       /* Processor's memory cache line width, in bytes */
+	u8                              duty_offset;        /* Processor's duty cycle index in processor's P_CNT reg*/
+	u8                              duty_width;         /* Processor's duty cycle value bit width in P_CNT register.*/
+	u8                              day_alrm;           /* Index to day-of-month alarm in RTC CMOS RAM */
+	u8                              mon_alrm;           /* Index to month-of-year alarm in RTC CMOS RAM */
+	u8                              century;            /* Index to century in RTC CMOS RAM */
+	u16                             iapc_boot_arch;     /* IA-PC Boot Architecture Flags. See Table 5-10 for description*/
+	u8                              reserved2;          /* Reserved */
+	u32                             wb_invd     : 1;    /* The wbinvd instruction works properly */
+	u32                             wb_invd_flush : 1;  /* The wbinvd flushes but does not invalidate */
+	u32                             proc_c1     : 1;    /* All processors support C1 state */
+	u32                             plvl2_up    : 1;    /* C2 state works on MP system */
+	u32                             pwr_button  : 1;    /* Power button is handled as a generic feature */
+	u32                             sleep_button : 1;   /* Sleep button is handled as a generic feature, or not present */
+	u32                             fixed_rTC   : 1;    /* RTC wakeup stat not in fixed register space */
+	u32                             rtcs4       : 1;    /* RTC wakeup stat not possible from S4 */
+	u32                             tmr_val_ext : 1;    /* Indicates tmr_val is 32 bits 0=24-bits*/
+	u32                             dock_cap    : 1;    /* Supports Docking */
+	u32                             reset_reg_sup : 1;  /* Indicates system supports system reset via the FADT RESET_REG*/
+	u32                             sealed_case : 1;    /* Indicates system has no internal expansion capabilities and case is sealed. */
+	u32                             headless    : 1;    /* Indicates system does not have local video capabilities or local input devices.*/
+	u32                             cpu_sw_sleep : 1;   /* Indicates to OSPM that a processor native instruction */
+			   /* Must be executed after writing the SLP_TYPx register. */
+	u32                             reserved6   : 18;   /* Reserved - must be zero */
+
+	struct acpi_generic_address     reset_register;     /* Reset register address in GAS format */
+	u8                              reset_value;        /* Value to write to the reset_register port to reset the system. */
+	u8                              reserved7[3];       /* These three bytes must be zero */
+	u64                             xfirmware_ctrl;     /* 64-bit physical address of FACS */
+	u64                             Xdsdt;              /* 64-bit physical address of DSDT */
+	struct acpi_generic_address     xpm1a_evt_blk;      /* Extended Power Mgt 1a acpi_event Reg Blk address */
+	struct acpi_generic_address     xpm1b_evt_blk;      /* Extended Power Mgt 1b acpi_event Reg Blk address */
+	struct acpi_generic_address     xpm1a_cnt_blk;      /* Extended Power Mgt 1a Control Reg Blk address */
+	struct acpi_generic_address     xpm1b_cnt_blk;      /* Extended Power Mgt 1b Control Reg Blk address */
+	struct acpi_generic_address     xpm2_cnt_blk;       /* Extended Power Mgt 2 Control Reg Blk address */
+	struct acpi_generic_address     xpm_tmr_blk;        /* Extended Power Mgt Timer Ctrl Reg Blk address */
+	struct acpi_generic_address     xgpe0_blk;          /* Extended General Purpose acpi_event 0 Reg Blk address */
+	struct acpi_generic_address     xgpe1_blk;          /* Extended General Purpose acpi_event 1 Reg Blk address */
+};
+
+
+#pragma pack()
+
+#endif /* __ACTBL2_H__ */
+
diff -urNp linux-5400/include/acpi/actbl71.h linux-5410/include/acpi/actbl71.h
--- linux-5400/include/acpi/actbl71.h
+++ linux-5410/include/acpi/actbl71.h
@@ -0,0 +1,144 @@
+/******************************************************************************
+ *
+ * Name: actbl71.h - IA-64 Extensions to the ACPI Spec Rev. 0.71
+ *                   This file includes tables specific to this
+ *                   specification revision.
+ *
+ *****************************************************************************/
+
+/*
+ *  Copyright (C) 2000 - 2003, R. Byron Moore
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ACTBL71_H__
+#define __ACTBL71_H__
+
+
+/* 0.71 FADT address_space data item bitmasks defines */
+/* If the associated bit is zero then it is in memory space else in io space */
+
+#define SMI_CMD_ADDRESS_SPACE       0x01
+#define PM1_BLK_ADDRESS_SPACE       0x02
+#define PM2_CNT_BLK_ADDRESS_SPACE   0x04
+#define PM_TMR_BLK_ADDRESS_SPACE    0x08
+#define GPE0_BLK_ADDRESS_SPACE      0x10
+#define GPE1_BLK_ADDRESS_SPACE      0x20
+
+/* Only for clarity in declarations */
+
+typedef u64                         IO_ADDRESS;
+
+
+#pragma pack(1)
+struct  /* Root System Descriptor Pointer */
+{
+	NATIVE_CHAR             signature [8];          /* contains "RSD PTR " */
+	u8                              checksum;               /* to make sum of struct == 0 */
+	NATIVE_CHAR             oem_id [6];             /* OEM identification */
+	u8                              reserved;               /* Must be 0 for 1.0, 2 for 2.0 */
+	u64                             rsdt_physical_address;  /* 64-bit physical address of RSDT */
+};
+
+
+/*****************************************/
+/* IA64 Extensions to ACPI Spec Rev 0.71 */
+/* for the Root System Description Table */
+/*****************************************/
+struct
+{
+	struct acpi_table_header    header;                 /* Table header */
+	u32                         reserved_pad;           /* IA64 alignment, must be 0 */
+	u64                         table_offset_entry [1]; /* Array of pointers to other */
+			   /* tables' headers */
+};
+
+
+/*******************************************/
+/* IA64 Extensions to ACPI Spec Rev 0.71   */
+/* for the Firmware ACPI Control Structure */
+/*******************************************/
+struct
+{
+	NATIVE_CHAR         signature[4];         /* signature "FACS" */
+	u32                         length;               /* length of structure, in bytes */
+	u32                         hardware_signature;   /* hardware configuration signature */
+	u32                         reserved4;            /* must be 0 */
+	u64                         firmware_waking_vector; /* ACPI OS waking vector */
+	u64                         global_lock;          /* Global Lock */
+	u32                         S4bios_f      : 1;    /* Indicates if S4BIOS support is present */
+	u32                         reserved1     : 31;   /* must be 0 */
+	u8                          reserved3 [28];       /* reserved - must be zero */
+};
+
+
+/******************************************/
+/* IA64 Extensions to ACPI Spec Rev 0.71  */
+/* for the Fixed ACPI Description Table   */
+/******************************************/
+struct
+{
+	struct acpi_table_header    header;             /* table header */
+	u32                         reserved_pad;       /* IA64 alignment, must be 0 */
+	u64                         firmware_ctrl;      /* 64-bit Physical address of FACS */
+	u64                         dsdt;               /* 64-bit Physical address of DSDT */
+	u8                          model;              /* System Interrupt Model */
+	u8                          address_space;      /* Address Space Bitmask */
+	u16                         sci_int;            /* System vector of SCI interrupt */
+	u8                          acpi_enable;        /* value to write to smi_cmd to enable ACPI */
+	u8                          acpi_disable;       /* value to write to smi_cmd to disable ACPI */
+	u8                          S4bios_req;         /* Value to write to SMI CMD to enter S4BIOS state */
+	u8                          reserved2;          /* reserved - must be zero */
+	u64                         smi_cmd;            /* Port address of SMI command port */
+	u64                         pm1a_evt_blk;       /* Port address of Power Mgt 1a acpi_event Reg Blk */
+	u64                         pm1b_evt_blk;       /* Port address of Power Mgt 1b acpi_event Reg Blk */
+	u64                         pm1a_cnt_blk;       /* Port address of Power Mgt 1a Control Reg Blk */
+	u64                         pm1b_cnt_blk;       /* Port address of Power Mgt 1b Control Reg Blk */
+	u64                         pm2_cnt_blk;        /* Port address of Power Mgt 2 Control Reg Blk */
+	u64                         pm_tmr_blk;         /* Port address of Power Mgt Timer Ctrl Reg Blk */
+	u64                         gpe0_blk;           /* Port addr of General Purpose acpi_event 0 Reg Blk */
+	u64                         gpe1_blk;           /* Port addr of General Purpose acpi_event 1 Reg Blk */
+	u8                          pm1_evt_len;        /* Byte length of ports at pm1_x_evt_blk */
+	u8                          pm1_cnt_len;        /* Byte length of ports at pm1_x_cnt_blk */
+	u8                          pm2_cnt_len;        /* Byte Length of ports at pm2_cnt_blk */
+	u8                          pm_tm_len;          /* Byte Length of ports at pm_tm_blk */
+	u8                          gpe0_blk_len;       /* Byte Length of ports at gpe0_blk */
+	u8                          gpe1_blk_len;       /* Byte Length of ports at gpe1_blk */
+	u8                          gpe1_base;          /* offset in gpe model where gpe1 events start */
+	u8                          reserved3;          /* reserved */
+	u16                         plvl2_lat;          /* worst case HW latency to enter/exit C2 state */
+	u16                         plvl3_lat;          /* worst case HW latency to enter/exit C3 state */
+	u8                          day_alrm;           /* index to day-of-month alarm in RTC CMOS RAM */
+	u8                          mon_alrm;           /* index to month-of-year alarm in RTC CMOS RAM */
+	u8                          century;            /* index to century in RTC CMOS RAM */
+	u8                          reserved4;          /* reserved */
+	u32                         flush_cash  : 1;    /* PAL_FLUSH_CACHE is correctly supported */
+	u32                         reserved5   : 1;    /* reserved - must be zero */
+	u32                         proc_c1     : 1;    /* all processors support C1 state */
+	u32                         plvl2_up    : 1;    /* C2 state works on MP system */
+	u32                         pwr_button  : 1;    /* Power button is handled as a generic feature */
+	u32                         sleep_button : 1;   /* Sleep button is handled as a generic feature, or not present */
+	u32                         fixed_rTC   : 1;    /* RTC wakeup stat not in fixed register space */
+	u32                         rtcs4       : 1;    /* RTC wakeup stat not possible from S4 */
+	u32                         tmr_val_ext : 1;    /* tmr_val is 32 bits */
+	u32                         dock_cap    : 1;    /* Supports Docking */
+	u32                         reserved6   : 22;    /* reserved - must be zero */
+};
+
+#pragma pack()
+
+#endif /* __ACTBL71_H__ */
+
diff -urNp linux-5400/include/acpi/actypes.h linux-5410/include/acpi/actypes.h
--- linux-5400/include/acpi/actypes.h
+++ linux-5410/include/acpi/actypes.h
@@ -0,0 +1,1247 @@
+/******************************************************************************
+ *
+ * Name: actypes.h - Common data types for the entire ACPI subsystem
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACTYPES_H__
+#define __ACTYPES_H__
+
+/*! [Begin] no source code translation (keep the typedefs) */
+
+
+
+/*
+ * Data type ranges
+ * Note: These macros are designed to be compiler independent as well as
+ * working around problems that some 32-bit compilers have with 64-bit
+ * constants.
+ */
+#define ACPI_UINT8_MAX                  (UINT8) (~((UINT8)  0)) /* 0xFF               */
+#define ACPI_UINT16_MAX                 (UINT16)(~((UINT16) 0)) /* 0xFFFF             */
+#define ACPI_UINT32_MAX                 (UINT32)(~((UINT32) 0)) /* 0xFFFFFFFF         */
+#define ACPI_UINT64_MAX                 (UINT64)(~((UINT64) 0)) /* 0xFFFFFFFFFFFFFFFF */
+#define ACPI_ASCII_MAX                  0x7F
+
+
+#ifdef DEFINE_ALTERNATE_TYPES
+/*
+ * Types used only in translated source, defined here to enable
+ * cross-platform compilation only.
+ */
+typedef int                             s32;
+typedef unsigned char                   u8;
+typedef unsigned short                  u16;
+typedef unsigned int                    u32;
+typedef COMPILER_DEPENDENT_UINT64       u64;
+
+#endif
+
+
+/*
+ * Data types - Fixed across all compilation models (16/32/64)
+ *
+ * BOOLEAN          Logical Boolean.
+ * INT8             8-bit  (1 byte) signed value
+ * UINT8            8-bit  (1 byte) unsigned value
+ * INT16            16-bit (2 byte) signed value
+ * UINT16           16-bit (2 byte) unsigned value
+ * INT32            32-bit (4 byte) signed value
+ * UINT32           32-bit (4 byte) unsigned value
+ * INT64            64-bit (8 byte) signed value
+ * UINT64           64-bit (8 byte) unsigned value
+ * ACPI_NATIVE_INT  32-bit on IA-32, 64-bit on IA-64 signed value
+ * ACPI_NATIVE_UINT 32-bit on IA-32, 64-bit on IA-64 unsigned value
+ */
+
+#ifndef ACPI_MACHINE_WIDTH
+#error ACPI_MACHINE_WIDTH not defined
+#endif
+
+#if ACPI_MACHINE_WIDTH == 64
+
+/*! [Begin] no source code translation (keep the typedefs) */
+
+/*
+ * 64-bit type definitions
+ */
+typedef unsigned char                   UINT8;
+typedef unsigned char                   BOOLEAN;
+typedef unsigned short                  UINT16;
+typedef int                             INT32;
+typedef unsigned int                    UINT32;
+typedef COMPILER_DEPENDENT_INT64        INT64;
+typedef COMPILER_DEPENDENT_UINT64       UINT64;
+
+/*! [End] no source code translation !*/
+
+typedef s64                                     acpi_native_int;
+typedef u64                                     acpi_native_uint;
+
+typedef u64                                     acpi_table_ptr;
+typedef u64                                     acpi_io_address;
+typedef u64                                     acpi_physical_address;
+typedef u64                                     acpi_size;
+
+#define ALIGNED_ADDRESS_BOUNDARY        0x00000008      /* No hardware alignment support in IA64 */
+#define ACPI_USE_NATIVE_DIVIDE                          /* Native 64-bit integer support */
+#define ACPI_MAX_PTR                    ACPI_UINT64_MAX
+#define ACPI_SIZE_MAX                   ACPI_UINT64_MAX
+
+
+#elif ACPI_MACHINE_WIDTH == 16
+
+/*! [Begin] no source code translation (keep the typedefs) */
+
+/*
+ * 16-bit type definitions
+ */
+typedef unsigned char                   UINT8;
+typedef unsigned char                   BOOLEAN;
+typedef unsigned int                    UINT16;
+typedef long                            INT32;
+typedef int                             INT16;
+typedef unsigned long                   UINT32;
+
+struct
+{
+	UINT32                                  Lo;
+	UINT32                                  Hi;
+};
+
+/*! [End] no source code translation !*/
+
+typedef u16                                     acpi_native_uint;
+typedef s16                                     acpi_native_int;
+
+typedef u32                                     acpi_table_ptr;
+typedef u32                                     acpi_io_address;
+typedef char                                    *acpi_physical_address;
+typedef u16                                     acpi_size;
+
+#define ALIGNED_ADDRESS_BOUNDARY        0x00000002
+#define ACPI_MISALIGNED_TRANSFERS
+#define ACPI_USE_NATIVE_DIVIDE                          /* No 64-bit integers, ok to use native divide */
+#define ACPI_MAX_PTR                    ACPI_UINT16_MAX
+#define ACPI_SIZE_MAX                   ACPI_UINT16_MAX
+
+/*
+ * (16-bit only) internal integers must be 32-bits, so
+ * 64-bit integers cannot be supported
+ */
+#define ACPI_NO_INTEGER64_SUPPORT
+
+
+#elif ACPI_MACHINE_WIDTH == 32
+
+/*! [Begin] no source code translation (keep the typedefs) */
+
+/*
+ * 32-bit type definitions (default)
+ */
+typedef unsigned char                   UINT8;
+typedef unsigned char                   BOOLEAN;
+typedef unsigned short                  UINT16;
+typedef int                             INT32;
+typedef unsigned int                    UINT32;
+typedef COMPILER_DEPENDENT_INT64        INT64;
+typedef COMPILER_DEPENDENT_UINT64       UINT64;
+
+/*! [End] no source code translation !*/
+
+typedef s32                                     acpi_native_int;
+typedef u32                                     acpi_native_uint;
+
+typedef u64                                     acpi_table_ptr;
+typedef u32                                     acpi_io_address;
+typedef u64                                     acpi_physical_address;
+typedef u32                                     acpi_size;
+
+#define ALIGNED_ADDRESS_BOUNDARY        0x00000004
+#define ACPI_MISALIGNED_TRANSFERS
+#define ACPI_MAX_PTR                    ACPI_UINT32_MAX
+#define ACPI_SIZE_MAX                   ACPI_UINT32_MAX
+
+#else
+#error unknown ACPI_MACHINE_WIDTH
+#endif
+
+
+/*
+ * Miscellaneous common types
+ */
+typedef u32                                     UINT32_BIT;
+typedef acpi_native_uint                        ACPI_PTRDIFF;
+
+/*
+ * Pointer overlays to avoid lots of typecasting for
+ * code that accepts both physical and logical pointers.
+ */
+union acpi_pointers
+{
+	acpi_physical_address               physical;
+	void                                *logical;
+	acpi_table_ptr                      value;
+};
+
+struct acpi_pointer
+{
+	u32                                 pointer_type;
+	union acpi_pointers                 pointer;
+};
+
+/* pointer_types for above */
+
+#define ACPI_PHYSICAL_POINTER           0x01
+#define ACPI_LOGICAL_POINTER            0x02
+
+/* Processor mode */
+
+#define ACPI_PHYSICAL_ADDRESSING        0x04
+#define ACPI_LOGICAL_ADDRESSING         0x08
+#define ACPI_MEMORY_MODE                0x0C
+
+#define ACPI_PHYSMODE_PHYSPTR           ACPI_PHYSICAL_ADDRESSING | ACPI_PHYSICAL_POINTER
+#define ACPI_LOGMODE_PHYSPTR            ACPI_LOGICAL_ADDRESSING  | ACPI_PHYSICAL_POINTER
+#define ACPI_LOGMODE_LOGPTR             ACPI_LOGICAL_ADDRESSING  | ACPI_LOGICAL_POINTER
+
+
+/*
+ * Useful defines
+ */
+#ifdef FALSE
+#undef FALSE
+#endif
+#define FALSE                           (1 == 0)
+
+#ifdef TRUE
+#undef TRUE
+#endif
+#define TRUE                            (1 == 1)
+
+#ifndef NULL
+#define NULL                            (void *) 0
+#endif
+
+
+/*
+ * Local datatypes
+ */
+typedef u32                                     acpi_status;    /* All ACPI Exceptions */
+typedef u32                                     acpi_name;      /* 4-byte ACPI name */
+typedef char *                                  acpi_string;    /* Null terminated ASCII string */
+typedef void *                                  acpi_handle;    /* Actually a ptr to an Node */
+
+struct uint64_struct
+{
+	u32                                 lo;
+	u32                                 hi;
+};
+
+union uint64_overlay
+{
+	u64                                 full;
+	struct uint64_struct                part;
+};
+
+struct uint32_struct
+{
+	u32                                 lo;
+	u32                                 hi;
+};
+
+
+/*
+ * Acpi integer width. In ACPI version 1, integers are
+ * 32 bits.  In ACPI version 2, integers are 64 bits.
+ * Note that this pertains to the ACPI integer type only, not
+ * other integers used in the implementation of the ACPI CA
+ * subsystem.
+ */
+#ifdef ACPI_NO_INTEGER64_SUPPORT
+
+/* 32-bit integers only, no 64-bit support */
+
+typedef u32                                     acpi_integer;
+#define ACPI_INTEGER_MAX                ACPI_UINT32_MAX
+#define ACPI_INTEGER_BIT_SIZE           32
+#define ACPI_MAX_DECIMAL_DIGITS         10
+
+#define ACPI_USE_NATIVE_DIVIDE          /* Use compiler native 32-bit divide */
+
+
+#else
+
+/* 64-bit integers */
+
+typedef u64                                     acpi_integer;
+#define ACPI_INTEGER_MAX                ACPI_UINT64_MAX
+#define ACPI_INTEGER_BIT_SIZE           64
+#define ACPI_MAX_DECIMAL_DIGITS         19
+
+#if ACPI_MACHINE_WIDTH == 64
+#define ACPI_USE_NATIVE_DIVIDE          /* Use compiler native 64-bit divide */
+#endif
+#endif
+
+
+/*
+ * Constants with special meanings
+ */
+#define ACPI_ROOT_OBJECT                (acpi_handle) ACPI_PTR_ADD (char, NULL, ACPI_MAX_PTR)
+
+
+/*
+ * Initialization sequence
+ */
+#define ACPI_FULL_INITIALIZATION        0x00
+#define ACPI_NO_ADDRESS_SPACE_INIT      0x01
+#define ACPI_NO_HARDWARE_INIT           0x02
+#define ACPI_NO_EVENT_INIT              0x04
+#define ACPI_NO_HANDLER_INIT            0x08
+#define ACPI_NO_ACPI_ENABLE             0x10
+#define ACPI_NO_DEVICE_INIT             0x20
+#define ACPI_NO_OBJECT_INIT             0x40
+
+/*
+ * Initialization state
+ */
+#define ACPI_INITIALIZED_OK             0x01
+
+/*
+ * Power state values
+ */
+
+#define ACPI_STATE_UNKNOWN              (u8) 0xFF
+
+#define ACPI_STATE_S0                   (u8) 0
+#define ACPI_STATE_S1                   (u8) 1
+#define ACPI_STATE_S2                   (u8) 2
+#define ACPI_STATE_S3                   (u8) 3
+#define ACPI_STATE_S4                   (u8) 4
+#define ACPI_STATE_S5                   (u8) 5
+#define ACPI_S_STATES_MAX               ACPI_STATE_S5
+#define ACPI_S_STATE_COUNT              6
+
+#define ACPI_STATE_D0                   (u8) 0
+#define ACPI_STATE_D1                   (u8) 1
+#define ACPI_STATE_D2                   (u8) 2
+#define ACPI_STATE_D3                   (u8) 3
+#define ACPI_D_STATES_MAX               ACPI_STATE_D3
+#define ACPI_D_STATE_COUNT              4
+
+#define ACPI_STATE_C0                   (u8) 0
+#define ACPI_STATE_C1                   (u8) 1
+#define ACPI_STATE_C2                   (u8) 2
+#define ACPI_STATE_C3                   (u8) 3
+#define ACPI_C_STATES_MAX               ACPI_STATE_C3
+#define ACPI_C_STATE_COUNT              4
+
+/*
+ * Sleep type invalid value
+ */
+#define ACPI_SLEEP_TYPE_MAX             0x7
+#define ACPI_SLEEP_TYPE_INVALID         0xFF
+
+/*
+ * Standard notify values
+ */
+#define ACPI_NOTIFY_BUS_CHECK           (u8) 0
+#define ACPI_NOTIFY_DEVICE_CHECK        (u8) 1
+#define ACPI_NOTIFY_DEVICE_WAKE         (u8) 2
+#define ACPI_NOTIFY_EJECT_REQUEST       (u8) 3
+#define ACPI_NOTIFY_DEVICE_CHECK_LIGHT  (u8) 4
+#define ACPI_NOTIFY_FREQUENCY_MISMATCH  (u8) 5
+#define ACPI_NOTIFY_BUS_MODE_MISMATCH   (u8) 6
+#define ACPI_NOTIFY_POWER_FAULT         (u8) 7
+
+
+/*
+ *  Table types.  These values are passed to the table related APIs
+ */
+typedef u32                                     acpi_table_type;
+
+#define ACPI_TABLE_RSDP                 (acpi_table_type) 0
+#define ACPI_TABLE_DSDT                 (acpi_table_type) 1
+#define ACPI_TABLE_FADT                 (acpi_table_type) 2
+#define ACPI_TABLE_FACS                 (acpi_table_type) 3
+#define ACPI_TABLE_PSDT                 (acpi_table_type) 4
+#define ACPI_TABLE_SSDT                 (acpi_table_type) 5
+#define ACPI_TABLE_XSDT                 (acpi_table_type) 6
+#define ACPI_TABLE_MAX                  6
+#define NUM_ACPI_TABLE_TYPES            (ACPI_TABLE_MAX+1)
+
+
+/*
+ * Types associated with ACPI names and objects.  The first group of
+ * values (up to ACPI_TYPE_EXTERNAL_MAX) correspond to the definition
+ * of the ACPI object_type() operator (See the ACPI Spec). Therefore,
+ * only add to the first group if the spec changes.
+ *
+ * Types must be kept in sync with the global acpi_ns_properties
+ * and acpi_ns_type_names arrays.
+ */
+typedef u32                                     acpi_object_type;
+
+#define ACPI_TYPE_ANY                   0x00
+#define ACPI_TYPE_INTEGER               0x01  /* Byte/Word/Dword/Zero/One/Ones */
+#define ACPI_TYPE_STRING                0x02
+#define ACPI_TYPE_BUFFER                0x03
+#define ACPI_TYPE_PACKAGE               0x04  /* byte_const, multiple data_term/Constant/super_name */
+#define ACPI_TYPE_FIELD_UNIT            0x05
+#define ACPI_TYPE_DEVICE                0x06  /* Name, multiple Node */
+#define ACPI_TYPE_EVENT                 0x07
+#define ACPI_TYPE_METHOD                0x08  /* Name, byte_const, multiple Code */
+#define ACPI_TYPE_MUTEX                 0x09
+#define ACPI_TYPE_REGION                0x0A
+#define ACPI_TYPE_POWER                 0x0B  /* Name,byte_const,word_const,multi Node */
+#define ACPI_TYPE_PROCESSOR             0x0C  /* Name,byte_const,Dword_const,byte_const,multi nm_o */
+#define ACPI_TYPE_THERMAL               0x0D  /* Name, multiple Node */
+#define ACPI_TYPE_BUFFER_FIELD          0x0E
+#define ACPI_TYPE_DDB_HANDLE            0x0F
+#define ACPI_TYPE_DEBUG_OBJECT          0x10
+
+#define ACPI_TYPE_EXTERNAL_MAX          0x10
+
+/*
+ * These are object types that do not map directly to the ACPI
+ * object_type() operator. They are used for various internal purposes only.
+ * If new predefined ACPI_TYPEs are added (via the ACPI specification), these
+ * internal types must move upwards. (There is code that depends on these
+ * values being contiguous with the external types above.)
+ */
+#define ACPI_TYPE_LOCAL_REGION_FIELD    0x11
+#define ACPI_TYPE_LOCAL_BANK_FIELD      0x12
+#define ACPI_TYPE_LOCAL_INDEX_FIELD     0x13
+#define ACPI_TYPE_LOCAL_REFERENCE       0x14  /* Arg#, Local#, Name, Debug, ref_of, Index */
+#define ACPI_TYPE_LOCAL_ALIAS           0x15
+#define ACPI_TYPE_LOCAL_NOTIFY          0x16
+#define ACPI_TYPE_LOCAL_ADDRESS_HANDLER 0x17
+#define ACPI_TYPE_LOCAL_RESOURCE        0x18
+#define ACPI_TYPE_LOCAL_RESOURCE_FIELD  0x19
+#define ACPI_TYPE_LOCAL_SCOPE           0x1A  /* 1 Name, multiple object_list Nodes */
+
+#define ACPI_TYPE_NS_NODE_MAX           0x1A  /* Last typecode used within a NS Node */
+
+/*
+ * These are special object types that never appear in
+ * a Namespace node, only in an union acpi_operand_object
+ */
+#define ACPI_TYPE_LOCAL_EXTRA           0x1B
+#define ACPI_TYPE_LOCAL_DATA            0x1C
+
+#define ACPI_TYPE_LOCAL_MAX             0x1C
+
+/* All types above here are invalid */
+
+#define ACPI_TYPE_INVALID               0x1D
+#define ACPI_TYPE_NOT_FOUND             0xFF
+
+
+/*
+ * Bitmapped ACPI types.  Used internally only
+ */
+#define ACPI_BTYPE_ANY                  0x00000000
+#define ACPI_BTYPE_INTEGER              0x00000001
+#define ACPI_BTYPE_STRING               0x00000002
+#define ACPI_BTYPE_BUFFER               0x00000004
+#define ACPI_BTYPE_PACKAGE              0x00000008
+#define ACPI_BTYPE_FIELD_UNIT           0x00000010
+#define ACPI_BTYPE_DEVICE               0x00000020
+#define ACPI_BTYPE_EVENT                0x00000040
+#define ACPI_BTYPE_METHOD               0x00000080
+#define ACPI_BTYPE_MUTEX                0x00000100
+#define ACPI_BTYPE_REGION               0x00000200
+#define ACPI_BTYPE_POWER                0x00000400
+#define ACPI_BTYPE_PROCESSOR            0x00000800
+#define ACPI_BTYPE_THERMAL              0x00001000
+#define ACPI_BTYPE_BUFFER_FIELD         0x00002000
+#define ACPI_BTYPE_DDB_HANDLE           0x00004000
+#define ACPI_BTYPE_DEBUG_OBJECT         0x00008000
+#define ACPI_BTYPE_REFERENCE            0x00010000
+#define ACPI_BTYPE_RESOURCE             0x00020000
+
+#define ACPI_BTYPE_COMPUTE_DATA         (ACPI_BTYPE_INTEGER | ACPI_BTYPE_STRING | ACPI_BTYPE_BUFFER)
+
+#define ACPI_BTYPE_DATA                 (ACPI_BTYPE_COMPUTE_DATA  | ACPI_BTYPE_PACKAGE)
+#define ACPI_BTYPE_DATA_REFERENCE       (ACPI_BTYPE_DATA | ACPI_BTYPE_REFERENCE | ACPI_BTYPE_DDB_HANDLE)
+#define ACPI_BTYPE_DEVICE_OBJECTS       (ACPI_BTYPE_DEVICE | ACPI_BTYPE_THERMAL | ACPI_BTYPE_PROCESSOR)
+#define ACPI_BTYPE_OBJECTS_AND_REFS     0x0001FFFF  /* ARG or LOCAL */
+#define ACPI_BTYPE_ALL_OBJECTS          0x0000FFFF
+
+/*
+ * All I/O
+ */
+#define ACPI_READ                       0
+#define ACPI_WRITE                      1
+#define ACPI_IO_MASK                    1
+
+
+/*
+ * Acpi Event Types: Fixed & General Purpose
+ */
+typedef u32                                     acpi_event_type;
+
+/*
+ * Fixed events
+ */
+#define ACPI_EVENT_PMTIMER              0
+#define ACPI_EVENT_GLOBAL               1
+#define ACPI_EVENT_POWER_BUTTON         2
+#define ACPI_EVENT_SLEEP_BUTTON         3
+#define ACPI_EVENT_RTC                  4
+#define ACPI_EVENT_MAX                  4
+#define ACPI_NUM_FIXED_EVENTS           ACPI_EVENT_MAX + 1
+
+#define ACPI_GPE_INVALID                0xFF
+#define ACPI_GPE_MAX                    0xFF
+#define ACPI_NUM_GPE                    256
+
+#define ACPI_EVENT_LEVEL_TRIGGERED      1
+#define ACPI_EVENT_EDGE_TRIGGERED       2
+
+/*
+ * Flags for GPE and Lock interfaces
+ */
+#define ACPI_EVENT_WAKE_ENABLE          0x2
+#define ACPI_EVENT_WAKE_DISABLE         0x2
+
+#define ACPI_NOT_ISR                    0x1
+#define ACPI_ISR                        0x0
+
+
+/*
+ * acpi_event Status:
+ * -------------
+ * The encoding of acpi_event_status is illustrated below.
+ * Note that a set bit (1) indicates the property is TRUE
+ * (e.g. if bit 0 is set then the event is enabled).
+ * +-------------+-+-+-+
+ * |   Bits 31:3 |2|1|0|
+ * +-------------+-+-+-+
+ *          |     | | |
+ *          |     | | +- Enabled?
+ *          |     | +--- Enabled for wake?
+ *          |     +----- Set?
+ *          +----------- <Reserved>
+ */
+typedef u32                                     acpi_event_status;
+
+#define ACPI_EVENT_FLAG_DISABLED        (acpi_event_status) 0x00
+#define ACPI_EVENT_FLAG_ENABLED         (acpi_event_status) 0x01
+#define ACPI_EVENT_FLAG_WAKE_ENABLED    (acpi_event_status) 0x02
+#define ACPI_EVENT_FLAG_SET             (acpi_event_status) 0x04
+
+
+/* Notify types */
+
+#define ACPI_SYSTEM_NOTIFY              0
+#define ACPI_DEVICE_NOTIFY              1
+#define ACPI_MAX_NOTIFY_HANDLER_TYPE    1
+
+#define ACPI_MAX_SYS_NOTIFY             0x7f
+
+
+/* Address Space (Operation Region) Types */
+
+typedef u8                                      acpi_adr_space_type;
+
+#define ACPI_ADR_SPACE_SYSTEM_MEMORY    (acpi_adr_space_type) 0
+#define ACPI_ADR_SPACE_SYSTEM_IO        (acpi_adr_space_type) 1
+#define ACPI_ADR_SPACE_PCI_CONFIG       (acpi_adr_space_type) 2
+#define ACPI_ADR_SPACE_EC               (acpi_adr_space_type) 3
+#define ACPI_ADR_SPACE_SMBUS            (acpi_adr_space_type) 4
+#define ACPI_ADR_SPACE_CMOS             (acpi_adr_space_type) 5
+#define ACPI_ADR_SPACE_PCI_BAR_TARGET   (acpi_adr_space_type) 6
+#define ACPI_ADR_SPACE_DATA_TABLE       (acpi_adr_space_type) 7
+#define ACPI_ADR_SPACE_FIXED_HARDWARE   (acpi_adr_space_type) 127
+
+
+/*
+ * bit_register IDs
+ * These are bitfields defined within the full ACPI registers
+ */
+#define ACPI_BITREG_TIMER_STATUS                0x00
+#define ACPI_BITREG_BUS_MASTER_STATUS           0x01
+#define ACPI_BITREG_GLOBAL_LOCK_STATUS          0x02
+#define ACPI_BITREG_POWER_BUTTON_STATUS         0x03
+#define ACPI_BITREG_SLEEP_BUTTON_STATUS         0x04
+#define ACPI_BITREG_RT_CLOCK_STATUS             0x05
+#define ACPI_BITREG_WAKE_STATUS                 0x06
+
+#define ACPI_BITREG_TIMER_ENABLE                0x07
+#define ACPI_BITREG_GLOBAL_LOCK_ENABLE          0x08
+#define ACPI_BITREG_POWER_BUTTON_ENABLE         0x09
+#define ACPI_BITREG_SLEEP_BUTTON_ENABLE         0x0A
+#define ACPI_BITREG_RT_CLOCK_ENABLE             0x0B
+#define ACPI_BITREG_WAKE_ENABLE                 0x0C
+
+#define ACPI_BITREG_SCI_ENABLE                  0x0D
+#define ACPI_BITREG_BUS_MASTER_RLD              0x0E
+#define ACPI_BITREG_GLOBAL_LOCK_RELEASE         0x0F
+#define ACPI_BITREG_SLEEP_TYPE_A                0x10
+#define ACPI_BITREG_SLEEP_TYPE_B                0x11
+#define ACPI_BITREG_SLEEP_ENABLE                0x12
+
+#define ACPI_BITREG_ARB_DISABLE                 0x13
+
+#define ACPI_BITREG_MAX                         0x13
+#define ACPI_NUM_BITREG                         ACPI_BITREG_MAX + 1
+
+
+/*
+ * External ACPI object definition
+ */
+union acpi_object
+{
+	acpi_object_type                    type;   /* See definition of acpi_ns_type for values */
+	struct
+	{
+		acpi_object_type                    type;
+		acpi_integer                        value;      /* The actual number */
+	} integer;
+
+	struct
+	{
+		acpi_object_type                    type;
+		u32                                 length;     /* # of bytes in string, excluding trailing null */
+		char                                *pointer;   /* points to the string value */
+	} string;
+
+	struct
+	{
+		acpi_object_type                    type;
+		u32                                 length;     /* # of bytes in buffer */
+		u8                                  *pointer;   /* points to the buffer */
+	} buffer;
+
+	struct
+	{
+		acpi_object_type                    type;
+		u32                                 fill1;
+		acpi_handle                         handle;     /* object reference */
+	} reference;
+
+	struct
+	{
+		acpi_object_type                    type;
+		u32                                 count;      /* # of elements in package */
+		union acpi_object                   *elements;  /* Pointer to an array of ACPI_OBJECTs */
+	} package;
+
+	struct
+	{
+		acpi_object_type                    type;
+		u32                                 proc_id;
+		acpi_io_address                     pblk_address;
+		u32                                 pblk_length;
+	} processor;
+
+	struct
+	{
+		acpi_object_type                    type;
+		u32                                 system_level;
+		u32                                 resource_order;
+	} power_resource;
+};
+
+
+/*
+ * List of objects, used as a parameter list for control method evaluation
+ */
+struct acpi_object_list
+{
+	u32                                 count;
+	union acpi_object                   *pointer;
+};
+
+
+/*
+ * Miscellaneous common Data Structures used by the interfaces
+ */
+#define ACPI_NO_BUFFER              0
+#define ACPI_ALLOCATE_BUFFER        (acpi_size) (-1)
+#define ACPI_ALLOCATE_LOCAL_BUFFER  (acpi_size) (-2)
+
+struct acpi_buffer
+{
+	acpi_size                           length;         /* Length in bytes of the buffer */
+	void                                *pointer;       /* pointer to buffer */
+};
+
+
+/*
+ * name_type for acpi_get_name
+ */
+#define ACPI_FULL_PATHNAME              0
+#define ACPI_SINGLE_NAME                1
+#define ACPI_NAME_TYPE_MAX              1
+
+
+/*
+ * Structure and flags for acpi_get_system_info
+ */
+#define ACPI_SYS_MODE_UNKNOWN           0x0000
+#define ACPI_SYS_MODE_ACPI              0x0001
+#define ACPI_SYS_MODE_LEGACY            0x0002
+#define ACPI_SYS_MODES_MASK             0x0003
+
+
+/*
+ * ACPI Table Info.  One per ACPI table _type_
+ */
+struct acpi_table_info
+{
+	u32                                 count;
+};
+
+
+/*
+ * System info returned by acpi_get_system_info()
+ */
+struct acpi_system_info
+{
+	u32                                 acpi_ca_version;
+	u32                                 flags;
+	u32                                 timer_resolution;
+	u32                                 reserved1;
+	u32                                 reserved2;
+	u32                                 debug_level;
+	u32                                 debug_layer;
+	u32                                 num_table_types;
+	struct acpi_table_info              table_info [NUM_ACPI_TABLE_TYPES];
+};
+
+
+/*
+ * Types specific to the OS service interfaces
+ */
+
+typedef u32
+(ACPI_SYSTEM_XFACE *OSD_HANDLER) (
+	void                            *context);
+
+typedef void
+(ACPI_SYSTEM_XFACE *OSD_EXECUTION_CALLBACK) (
+	void                            *context);
+
+/*
+ * Various handlers and callback procedures
+ */
+typedef
+u32 (*acpi_event_handler) (
+	void                                *context);
+
+typedef
+void (*acpi_gpe_handler) (
+	void                                *context);
+
+typedef
+void (*acpi_notify_handler) (
+	acpi_handle                         device,
+	u32                                 value,
+	void                                *context);
+
+typedef
+void (*acpi_object_handler) (
+	acpi_handle                         object,
+	u32                                 function,
+	void                                *data);
+
+typedef
+acpi_status (*acpi_init_handler) (
+	acpi_handle                         object,
+	u32                                 function);
+
+#define ACPI_INIT_DEVICE_INI        1
+
+
+/* Address Spaces (Operation Regions */
+
+typedef
+acpi_status (*acpi_adr_space_handler) (
+	u32                                 function,
+	acpi_physical_address               address,
+	u32                                 bit_width,
+	acpi_integer                        *value,
+	void                                *handler_context,
+	void                                *region_context);
+
+#define ACPI_DEFAULT_HANDLER        NULL
+
+
+typedef
+acpi_status (*acpi_adr_space_setup) (
+	acpi_handle                         region_handle,
+	u32                                 function,
+	void                                *handler_context,
+	void                                **region_context);
+
+#define ACPI_REGION_ACTIVATE    0
+#define ACPI_REGION_DEACTIVATE  1
+
+typedef
+acpi_status (*acpi_walk_callback) (
+	acpi_handle                         obj_handle,
+	u32                                 nesting_level,
+	void                                *context,
+	void                                **return_value);
+
+
+/* Interrupt handler return values */
+
+#define ACPI_INTERRUPT_NOT_HANDLED      0x00
+#define ACPI_INTERRUPT_HANDLED          0x01
+
+
+/* Common string version of device HIDs and UIDs */
+
+struct acpi_device_id
+{
+	char                            value[ACPI_DEVICE_ID_LENGTH];
+};
+
+/* Common string version of device CIDs */
+
+struct acpi_compatible_id
+{
+	char                            value[ACPI_MAX_CID_LENGTH];
+};
+
+struct acpi_compatible_id_list
+{
+	u32                             count;
+	u32                             size;
+	struct acpi_compatible_id       id[1];
+};
+
+
+/* Structure and flags for acpi_get_object_info */
+
+#define ACPI_VALID_STA                  0x0001
+#define ACPI_VALID_ADR                  0x0002
+#define ACPI_VALID_HID                  0x0004
+#define ACPI_VALID_UID                  0x0008
+#define ACPI_VALID_CID                  0x0010
+
+
+#define ACPI_COMMON_OBJ_INFO \
+	acpi_object_type                    type;           /* ACPI object type */ \
+	acpi_name                           name            /* ACPI object Name */
+
+
+struct acpi_obj_info_header
+{
+	ACPI_COMMON_OBJ_INFO;
+};
+
+
+/* Structure returned from Get Object Info */
+
+struct acpi_device_info
+{
+	ACPI_COMMON_OBJ_INFO;
+
+	u32                                 valid;              /* Indicates which fields are valid */
+	u32                                 current_status;     /* _STA value */
+	acpi_integer                        address;            /* _ADR value if any */
+	struct acpi_device_id               hardware_id;        /* _HID value if any */
+	struct acpi_device_id               unique_id;          /* _UID value if any */
+	struct acpi_compatible_id_list      compatibility_id;   /* List of _CIDs if any */
+};
+
+
+/* Context structs for address space handlers */
+
+struct acpi_pci_id
+{
+	u16                                 segment;
+	u16                                 bus;
+	u16                                 device;
+	u16                                 function;
+};
+
+
+struct acpi_mem_space_context
+{
+	u32                                 length;
+	acpi_physical_address               address;
+	acpi_physical_address               mapped_physical_address;
+	u8                                  *mapped_logical_address;
+	acpi_size                           mapped_length;
+};
+
+
+/*
+ * Definitions for Resource Attributes
+ */
+
+/*
+ *  Memory Attributes
+ */
+#define ACPI_READ_ONLY_MEMORY           (u8) 0x00
+#define ACPI_READ_WRITE_MEMORY          (u8) 0x01
+
+#define ACPI_NON_CACHEABLE_MEMORY       (u8) 0x00
+#define ACPI_CACHABLE_MEMORY            (u8) 0x01
+#define ACPI_WRITE_COMBINING_MEMORY     (u8) 0x02
+#define ACPI_PREFETCHABLE_MEMORY        (u8) 0x03
+
+/*
+ *  IO Attributes
+ *  The ISA Io ranges are:     n000-n0_ffh, n400-n4_ffh, n800-n8_ffh, n_c00-n_cFFh.
+ *  The non-ISA Io ranges are: n100-n3_ffh, n500-n7_ffh, n900-n_bFfh, n_cd0-n_fFFh.
+ */
+#define ACPI_NON_ISA_ONLY_RANGES        (u8) 0x01
+#define ACPI_ISA_ONLY_RANGES            (u8) 0x02
+#define ACPI_ENTIRE_RANGE               (ACPI_NON_ISA_ONLY_RANGES | ACPI_ISA_ONLY_RANGES)
+
+#define ACPI_SPARSE_TRANSLATION         (u8) 0x03
+
+/*
+ *  IO Port Descriptor Decode
+ */
+#define ACPI_DECODE_10                  (u8) 0x00    /* 10-bit IO address decode */
+#define ACPI_DECODE_16                  (u8) 0x01    /* 16-bit IO address decode */
+
+/*
+ *  IRQ Attributes
+ */
+#define ACPI_EDGE_SENSITIVE             (u8) 0x00
+#define ACPI_LEVEL_SENSITIVE            (u8) 0x01
+
+#define ACPI_ACTIVE_HIGH                (u8) 0x00
+#define ACPI_ACTIVE_LOW                 (u8) 0x01
+
+#define ACPI_EXCLUSIVE                  (u8) 0x00
+#define ACPI_SHARED                     (u8) 0x01
+
+/*
+ *  DMA Attributes
+ */
+#define ACPI_COMPATIBILITY              (u8) 0x00
+#define ACPI_TYPE_A                     (u8) 0x01
+#define ACPI_TYPE_B                     (u8) 0x02
+#define ACPI_TYPE_F                     (u8) 0x03
+
+#define ACPI_NOT_BUS_MASTER             (u8) 0x00
+#define ACPI_BUS_MASTER                 (u8) 0x01
+
+#define ACPI_TRANSFER_8                 (u8) 0x00
+#define ACPI_TRANSFER_8_16              (u8) 0x01
+#define ACPI_TRANSFER_16                (u8) 0x02
+
+/*
+ * Start Dependent Functions Priority definitions
+ */
+#define ACPI_GOOD_CONFIGURATION         (u8) 0x00
+#define ACPI_ACCEPTABLE_CONFIGURATION   (u8) 0x01
+#define ACPI_SUB_OPTIMAL_CONFIGURATION  (u8) 0x02
+
+/*
+ *  16, 32 and 64-bit Address Descriptor resource types
+ */
+#define ACPI_MEMORY_RANGE               (u8) 0x00
+#define ACPI_IO_RANGE                   (u8) 0x01
+#define ACPI_BUS_NUMBER_RANGE           (u8) 0x02
+
+#define ACPI_ADDRESS_NOT_FIXED          (u8) 0x00
+#define ACPI_ADDRESS_FIXED              (u8) 0x01
+
+#define ACPI_POS_DECODE                 (u8) 0x00
+#define ACPI_SUB_DECODE                 (u8) 0x01
+
+#define ACPI_PRODUCER                   (u8) 0x00
+#define ACPI_CONSUMER                   (u8) 0x01
+
+
+/*
+ *  Structures used to describe device resources
+ */
+struct acpi_resource_irq
+{
+	u32                                 edge_level;
+	u32                                 active_high_low;
+	u32                                 shared_exclusive;
+	u32                                 number_of_interrupts;
+	u32                                 interrupts[1];
+};
+
+struct acpi_resource_dma
+{
+	u32                                 type;
+	u32                                 bus_master;
+	u32                                 transfer;
+	u32                                 number_of_channels;
+	u32                                 channels[1];
+};
+
+struct acpi_resource_start_dpf
+{
+	u32                                 compatibility_priority;
+	u32                                 performance_robustness;
+};
+
+/*
+ * END_DEPENDENT_FUNCTIONS_RESOURCE struct is not
+ * needed because it has no fields
+ */
+
+struct acpi_resource_io
+{
+	u32                                 io_decode;
+	u32                                 min_base_address;
+	u32                                 max_base_address;
+	u32                                 alignment;
+	u32                                 range_length;
+};
+
+struct acpi_resource_fixed_io
+{
+	u32                                 base_address;
+	u32                                 range_length;
+};
+
+struct acpi_resource_vendor
+{
+	u32                                 length;
+	u8                                  reserved[1];
+};
+
+struct acpi_resource_end_tag
+{
+	u8                                  checksum;
+};
+
+struct acpi_resource_mem24
+{
+	u32                                 read_write_attribute;
+	u32                                 min_base_address;
+	u32                                 max_base_address;
+	u32                                 alignment;
+	u32                                 range_length;
+};
+
+struct acpi_resource_mem32
+{
+	u32                                 read_write_attribute;
+	u32                                 min_base_address;
+	u32                                 max_base_address;
+	u32                                 alignment;
+	u32                                 range_length;
+};
+
+struct acpi_resource_fixed_mem32
+{
+	u32                                 read_write_attribute;
+	u32                                 range_base_address;
+	u32                                 range_length;
+};
+
+struct acpi_memory_attribute
+{
+	u16                                 cache_attribute;
+	u16                                 read_write_attribute;
+};
+
+struct acpi_io_attribute
+{
+	u16                                 range_attribute;
+	u16                                 translation_attribute;
+};
+
+struct acpi_bus_attribute
+{
+	u16                                 reserved1;
+	u16                                 reserved2;
+};
+
+union acpi_resource_attribute
+{
+	struct acpi_memory_attribute        memory;
+	struct acpi_io_attribute            io;
+	struct acpi_bus_attribute           bus;
+};
+
+struct acpi_resource_source
+{
+	u32                                 index;
+	u32                                 string_length;
+	char                                *string_ptr;
+};
+
+struct acpi_resource_address16
+{
+	u32                                 resource_type;
+	u32                                 producer_consumer;
+	u32                                 decode;
+	u32                                 min_address_fixed;
+	u32                                 max_address_fixed;
+	union acpi_resource_attribute       attribute;
+	u32                                 granularity;
+	u32                                 min_address_range;
+	u32                                 max_address_range;
+	u32                                 address_translation_offset;
+	u32                                 address_length;
+	struct acpi_resource_source         resource_source;
+};
+
+struct acpi_resource_address32
+{
+	u32                                 resource_type;
+	u32                                 producer_consumer;
+	u32                                 decode;
+	u32                                 min_address_fixed;
+	u32                                 max_address_fixed;
+	union acpi_resource_attribute       attribute;
+	u32                                 granularity;
+	u32                                 min_address_range;
+	u32                                 max_address_range;
+	u32                                 address_translation_offset;
+	u32                                 address_length;
+	struct acpi_resource_source         resource_source;
+};
+
+struct acpi_resource_address64
+{
+	u32                                 resource_type;
+	u32                                 producer_consumer;
+	u32                                 decode;
+	u32                                 min_address_fixed;
+	u32                                 max_address_fixed;
+	union acpi_resource_attribute       attribute;
+	u64                                 granularity;
+	u64                                 min_address_range;
+	u64                                 max_address_range;
+	u64                                 address_translation_offset;
+	u64                                 address_length;
+	struct acpi_resource_source         resource_source;
+};
+
+struct acpi_resource_ext_irq
+{
+	u32                                 producer_consumer;
+	u32                                 edge_level;
+	u32                                 active_high_low;
+	u32                                 shared_exclusive;
+	u32                                 number_of_interrupts;
+	struct acpi_resource_source         resource_source;
+	u32                                 interrupts[1];
+};
+
+
+/* ACPI_RESOURCE_TYPEs */
+
+#define ACPI_RSTYPE_IRQ                 0
+#define ACPI_RSTYPE_DMA                 1
+#define ACPI_RSTYPE_START_DPF           2
+#define ACPI_RSTYPE_END_DPF             3
+#define ACPI_RSTYPE_IO                  4
+#define ACPI_RSTYPE_FIXED_IO            5
+#define ACPI_RSTYPE_VENDOR              6
+#define ACPI_RSTYPE_END_TAG             7
+#define ACPI_RSTYPE_MEM24               8
+#define ACPI_RSTYPE_MEM32               9
+#define ACPI_RSTYPE_FIXED_MEM32         10
+#define ACPI_RSTYPE_ADDRESS16           11
+#define ACPI_RSTYPE_ADDRESS32           12
+#define ACPI_RSTYPE_ADDRESS64           13
+#define ACPI_RSTYPE_EXT_IRQ             14
+
+typedef u32                                     acpi_resource_type;
+
+union acpi_resource_data
+{
+	struct acpi_resource_irq            irq;
+	struct acpi_resource_dma            dma;
+	struct acpi_resource_start_dpf      start_dpf;
+	struct acpi_resource_io             io;
+	struct acpi_resource_fixed_io       fixed_io;
+	struct acpi_resource_vendor         vendor_specific;
+	struct acpi_resource_end_tag        end_tag;
+	struct acpi_resource_mem24          memory24;
+	struct acpi_resource_mem32          memory32;
+	struct acpi_resource_fixed_mem32    fixed_memory32;
+	struct acpi_resource_address16      address16;
+	struct acpi_resource_address32      address32;
+	struct acpi_resource_address64      address64;
+	struct acpi_resource_ext_irq        extended_irq;
+};
+
+struct acpi_resource
+{
+	acpi_resource_type                  id;
+	u32                                 length;
+	union acpi_resource_data            data;
+};
+
+#define ACPI_RESOURCE_LENGTH                12
+#define ACPI_RESOURCE_LENGTH_NO_DATA        8       /* Id + Length fields */
+
+#define ACPI_SIZEOF_RESOURCE(type)          (ACPI_RESOURCE_LENGTH_NO_DATA + sizeof (type))
+
+#define ACPI_NEXT_RESOURCE(res)             (struct acpi_resource *)((u8 *) res + res->length)
+
+#ifdef ACPI_MISALIGNED_TRANSFERS
+#define ACPI_ALIGN_RESOURCE_SIZE(length)    (length)
+#else
+#define ACPI_ALIGN_RESOURCE_SIZE(length)    ACPI_ROUND_UP_TO_NATIVE_WORD(length)
+#endif
+
+/*
+ * END: of definitions for Resource Attributes
+ */
+
+
+struct acpi_pci_routing_table
+{
+	u32                                 length;
+	u32                                 pin;
+	acpi_integer                        address;        /* here for 64-bit alignment */
+	u32                                 source_index;
+	char                                source[4];      /* pad to 64 bits so sizeof() works in all cases */
+};
+
+/*
+ * END: of definitions for PCI Routing tables
+ */
+
+
+#endif /* __ACTYPES_H__ */
diff -urNp linux-5400/include/acpi/acutils.h linux-5410/include/acpi/acutils.h
--- linux-5400/include/acpi/acutils.h
+++ linux-5410/include/acpi/acutils.h
@@ -0,0 +1,836 @@
+/******************************************************************************
+ *
+ * Name: acutils.h -- prototypes for the common (subsystem-wide) procedures
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef _ACUTILS_H
+#define _ACUTILS_H
+
+
+typedef
+acpi_status (*acpi_pkg_callback) (
+	u8                              object_type,
+	union acpi_operand_object       *source_object,
+	union acpi_generic_state        *state,
+	void                            *context);
+
+
+acpi_status
+acpi_ut_walk_package_tree (
+	union acpi_operand_object       *source_object,
+	void                            *target_object,
+	acpi_pkg_callback               walk_callback,
+	void                            *context);
+
+
+struct acpi_pkg_info
+{
+	u8                              *free_space;
+	acpi_size                       length;
+	u32                             object_space;
+	u32                             num_packages;
+};
+
+#define REF_INCREMENT       (u16) 0
+#define REF_DECREMENT       (u16) 1
+#define REF_FORCE_DELETE    (u16) 2
+
+/* acpi_ut_dump_buffer */
+
+#define DB_BYTE_DISPLAY     1
+#define DB_WORD_DISPLAY     2
+#define DB_DWORD_DISPLAY    4
+#define DB_QWORD_DISPLAY    8
+
+
+/* Global initialization interfaces */
+
+void
+acpi_ut_init_globals (
+	void);
+
+void
+acpi_ut_terminate (
+	void);
+
+
+/*
+ * ut_init - miscellaneous initialization and shutdown
+ */
+
+acpi_status
+acpi_ut_hardware_initialize (
+	void);
+
+void
+acpi_ut_subsystem_shutdown (
+	void);
+
+acpi_status
+acpi_ut_validate_fadt (
+	void);
+
+/*
+ * ut_global - Global data structures and procedures
+ */
+
+#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
+
+char *
+acpi_ut_get_mutex_name (
+	u32                             mutex_id);
+
+#endif
+
+char *
+acpi_ut_get_type_name (
+	acpi_object_type                type);
+
+char *
+acpi_ut_get_object_type_name (
+	union acpi_operand_object       *obj_desc);
+
+char *
+acpi_ut_get_region_name (
+	u8                              space_id);
+
+char *
+acpi_ut_get_event_name (
+	u32                             event_id);
+
+char
+acpi_ut_hex_to_ascii_char (
+	acpi_integer                    integer,
+	u32                             position);
+
+u8
+acpi_ut_valid_object_type (
+	acpi_object_type                type);
+
+acpi_owner_id
+acpi_ut_allocate_owner_id (
+	u32                             id_type);
+
+
+/*
+ * ut_clib - Local implementations of C library functions
+ */
+
+#ifndef ACPI_USE_SYSTEM_CLIBRARY
+
+acpi_size
+acpi_ut_strlen (
+	const char                      *string);
+
+char *
+acpi_ut_strcpy (
+	char                            *dst_string,
+	const char                      *src_string);
+
+char *
+acpi_ut_strncpy (
+	char                            *dst_string,
+	const char                      *src_string,
+	acpi_size                       count);
+
+int
+acpi_ut_strncmp (
+	const char                      *string1,
+	const char                      *string2,
+	acpi_size                       count);
+
+int
+acpi_ut_strcmp (
+	const char                      *string1,
+	const char                      *string2);
+
+char *
+acpi_ut_strcat (
+	char                            *dst_string,
+	const char                      *src_string);
+
+char *
+acpi_ut_strncat (
+	char                            *dst_string,
+	const char                      *src_string,
+	acpi_size                       count);
+
+u32
+acpi_ut_strtoul (
+	const char                      *string,
+	char                            **terminator,
+	u32                             base);
+
+char *
+acpi_ut_strstr (
+	char                            *string1,
+	char                            *string2);
+
+void *
+acpi_ut_memcpy (
+	void                            *dest,
+	const void                      *src,
+	acpi_size                       count);
+
+void *
+acpi_ut_memset (
+	void                            *dest,
+	acpi_native_uint                value,
+	acpi_size                       count);
+
+int
+acpi_ut_to_upper (
+	int                             c);
+
+int
+acpi_ut_to_lower (
+	int                             c);
+
+extern const u8 _acpi_ctype[];
+
+#define _ACPI_XA     0x00    /* extra alphabetic - not supported */
+#define _ACPI_XS     0x40    /* extra space */
+#define _ACPI_BB     0x00    /* BEL, BS, etc. - not supported */
+#define _ACPI_CN     0x20    /* CR, FF, HT, NL, VT */
+#define _ACPI_DI     0x04    /* '0'-'9' */
+#define _ACPI_LO     0x02    /* 'a'-'z' */
+#define _ACPI_PU     0x10    /* punctuation */
+#define _ACPI_SP     0x08    /* space */
+#define _ACPI_UP     0x01    /* 'A'-'Z' */
+#define _ACPI_XD     0x80    /* '0'-'9', 'A'-'F', 'a'-'f' */
+
+#define ACPI_IS_DIGIT(c)  (_acpi_ctype[(unsigned char)(c)] & (_ACPI_DI))
+#define ACPI_IS_SPACE(c)  (_acpi_ctype[(unsigned char)(c)] & (_ACPI_SP))
+#define ACPI_IS_XDIGIT(c) (_acpi_ctype[(unsigned char)(c)] & (_ACPI_XD))
+#define ACPI_IS_UPPER(c)  (_acpi_ctype[(unsigned char)(c)] & (_ACPI_UP))
+#define ACPI_IS_LOWER(c)  (_acpi_ctype[(unsigned char)(c)] & (_ACPI_LO))
+#define ACPI_IS_PRINT(c)  (_acpi_ctype[(unsigned char)(c)] & (_ACPI_LO | _ACPI_UP | _ACPI_DI | _ACPI_SP | _ACPI_PU))
+#define ACPI_IS_ALPHA(c)  (_acpi_ctype[(unsigned char)(c)] & (_ACPI_LO | _ACPI_UP))
+#define ACPI_IS_ASCII(c)  ((c) < 0x80)
+
+#endif /* ACPI_USE_SYSTEM_CLIBRARY */
+
+/*
+ * ut_copy - Object construction and conversion interfaces
+ */
+
+acpi_status
+acpi_ut_build_simple_object(
+	union acpi_operand_object       *obj,
+	union acpi_object               *user_obj,
+	u8                              *data_space,
+	u32                             *buffer_space_used);
+
+acpi_status
+acpi_ut_build_package_object (
+	union acpi_operand_object       *obj,
+	u8                              *buffer,
+	u32                             *space_used);
+
+acpi_status
+acpi_ut_copy_ielement_to_eelement (
+	u8                              object_type,
+	union acpi_operand_object       *source_object,
+	union acpi_generic_state        *state,
+	void                            *context);
+
+acpi_status
+acpi_ut_copy_ielement_to_ielement (
+	u8                              object_type,
+	union acpi_operand_object       *source_object,
+	union acpi_generic_state        *state,
+	void                            *context);
+
+acpi_status
+acpi_ut_copy_iobject_to_eobject (
+	union acpi_operand_object       *obj,
+	struct acpi_buffer              *ret_buffer);
+
+acpi_status
+acpi_ut_copy_esimple_to_isimple(
+	union acpi_object               *user_obj,
+	union acpi_operand_object       **return_obj);
+
+acpi_status
+acpi_ut_copy_eobject_to_iobject (
+	union acpi_object               *obj,
+	union acpi_operand_object       **internal_obj);
+
+acpi_status
+acpi_ut_copy_isimple_to_isimple (
+	union acpi_operand_object       *source_obj,
+	union acpi_operand_object       *dest_obj);
+
+acpi_status
+acpi_ut_copy_ipackage_to_ipackage (
+	union acpi_operand_object       *source_obj,
+	union acpi_operand_object       *dest_obj,
+	struct acpi_walk_state          *walk_state);
+
+acpi_status
+acpi_ut_copy_simple_object (
+	union acpi_operand_object       *source_desc,
+	union acpi_operand_object       *dest_desc);
+
+acpi_status
+acpi_ut_copy_iobject_to_iobject (
+	union acpi_operand_object       *source_desc,
+	union acpi_operand_object       **dest_desc,
+	struct acpi_walk_state          *walk_state);
+
+
+/*
+ * ut_create - Object creation
+ */
+
+acpi_status
+acpi_ut_update_object_reference (
+	union acpi_operand_object       *object,
+	u16                             action);
+
+
+/*
+ * ut_debug - Debug interfaces
+ */
+
+void
+acpi_ut_init_stack_ptr_trace (
+	void);
+
+void
+acpi_ut_track_stack_ptr (
+	void);
+
+void
+acpi_ut_trace (
+	u32                             line_number,
+	struct acpi_debug_print_info    *dbg_info);
+
+void
+acpi_ut_trace_ptr (
+	u32                             line_number,
+	struct acpi_debug_print_info    *dbg_info,
+	void                            *pointer);
+
+void
+acpi_ut_trace_u32 (
+	u32                             line_number,
+	struct acpi_debug_print_info    *dbg_info,
+	u32                             integer);
+
+void
+acpi_ut_trace_str (
+	u32                             line_number,
+	struct acpi_debug_print_info    *dbg_info,
+	char                            *string);
+
+void
+acpi_ut_exit (
+	u32                             line_number,
+	struct acpi_debug_print_info    *dbg_info);
+
+void
+acpi_ut_status_exit (
+	u32                             line_number,
+	struct acpi_debug_print_info    *dbg_info,
+	acpi_status                     status);
+
+void
+acpi_ut_value_exit (
+	u32                             line_number,
+	struct acpi_debug_print_info    *dbg_info,
+	acpi_integer                    value);
+
+void
+acpi_ut_ptr_exit (
+	u32                             line_number,
+	struct acpi_debug_print_info    *dbg_info,
+	u8                              *ptr);
+
+void
+acpi_ut_report_info (
+	char                            *module_name,
+	u32                             line_number,
+	u32                             component_id);
+
+void
+acpi_ut_report_error (
+	char                            *module_name,
+	u32                             line_number,
+	u32                             component_id);
+
+void
+acpi_ut_report_warning (
+	char                            *module_name,
+	u32                             line_number,
+	u32                             component_id);
+
+void
+acpi_ut_dump_buffer (
+	u8                              *buffer,
+	u32                             count,
+	u32                             display,
+	u32                             component_id);
+
+void ACPI_INTERNAL_VAR_XFACE
+acpi_ut_debug_print (
+	u32                             requested_debug_level,
+	u32                             line_number,
+	struct acpi_debug_print_info    *dbg_info,
+	char                            *format,
+	...) ACPI_PRINTF_LIKE_FUNC;
+
+void ACPI_INTERNAL_VAR_XFACE
+acpi_ut_debug_print_raw (
+	u32                             requested_debug_level,
+	u32                             line_number,
+	struct acpi_debug_print_info    *dbg_info,
+	char                            *format,
+	...) ACPI_PRINTF_LIKE_FUNC;
+
+
+/*
+ * ut_delete - Object deletion
+ */
+
+void
+acpi_ut_delete_internal_obj (
+	union acpi_operand_object       *object);
+
+void
+acpi_ut_delete_internal_package_object (
+	union acpi_operand_object       *object);
+
+void
+acpi_ut_delete_internal_simple_object (
+	union acpi_operand_object       *object);
+
+void
+acpi_ut_delete_internal_object_list (
+	union acpi_operand_object       **obj_list);
+
+
+/*
+ * ut_eval - object evaluation
+ */
+
+/* Method name strings */
+
+#define METHOD_NAME__HID        "_HID"
+#define METHOD_NAME__CID        "_CID"
+#define METHOD_NAME__UID        "_UID"
+#define METHOD_NAME__ADR        "_ADR"
+#define METHOD_NAME__STA        "_STA"
+#define METHOD_NAME__REG        "_REG"
+#define METHOD_NAME__SEG        "_SEG"
+#define METHOD_NAME__BBN        "_BBN"
+#define METHOD_NAME__PRT        "_PRT"
+#define METHOD_NAME__CRS        "_CRS"
+#define METHOD_NAME__PRS        "_PRS"
+
+
+acpi_status
+acpi_ut_evaluate_object (
+	struct acpi_namespace_node      *prefix_node,
+	char                            *path,
+	u32                             expected_return_btypes,
+	union acpi_operand_object       **return_desc);
+
+acpi_status
+acpi_ut_evaluate_numeric_object (
+	char                            *object_name,
+	struct acpi_namespace_node      *device_node,
+	acpi_integer                    *address);
+
+acpi_status
+acpi_ut_execute_HID (
+	struct acpi_namespace_node      *device_node,
+	struct acpi_device_id           *hid);
+
+acpi_status
+acpi_ut_execute_CID (
+	struct acpi_namespace_node      *device_node,
+	struct acpi_compatible_id_list **return_cid_list);
+
+acpi_status
+acpi_ut_execute_STA (
+	struct acpi_namespace_node      *device_node,
+	u32                             *status_flags);
+
+acpi_status
+acpi_ut_execute_UID (
+	struct acpi_namespace_node      *device_node,
+	struct acpi_device_id           *uid);
+
+
+/*
+ * ut_mutex - mutual exclusion interfaces
+ */
+
+acpi_status
+acpi_ut_mutex_initialize (
+	void);
+
+void
+acpi_ut_mutex_terminate (
+	void);
+
+acpi_status
+acpi_ut_create_mutex (
+	acpi_mutex_handle               mutex_id);
+
+acpi_status
+acpi_ut_delete_mutex (
+	acpi_mutex_handle               mutex_id);
+
+acpi_status
+acpi_ut_acquire_mutex (
+	acpi_mutex_handle               mutex_id);
+
+acpi_status
+acpi_ut_release_mutex (
+	acpi_mutex_handle               mutex_id);
+
+
+/*
+ * ut_object - internal object create/delete/cache routines
+ */
+
+union acpi_operand_object    *
+acpi_ut_create_internal_object_dbg (
+	char                            *module_name,
+	u32                             line_number,
+	u32                             component_id,
+	acpi_object_type                type);
+
+void *
+acpi_ut_allocate_object_desc_dbg (
+	char                            *module_name,
+	u32                             line_number,
+	u32                             component_id);
+
+#define acpi_ut_create_internal_object(t) acpi_ut_create_internal_object_dbg (_THIS_MODULE,__LINE__,_COMPONENT,t)
+#define acpi_ut_allocate_object_desc()  acpi_ut_allocate_object_desc_dbg (_THIS_MODULE,__LINE__,_COMPONENT)
+
+void
+acpi_ut_delete_object_desc (
+	union acpi_operand_object       *object);
+
+u8
+acpi_ut_valid_internal_object (
+	void                            *object);
+
+union acpi_operand_object *
+acpi_ut_create_buffer_object (
+	acpi_size                       buffer_size);
+
+
+/*
+ * ut_ref_cnt - Object reference count management
+ */
+
+void
+acpi_ut_add_reference (
+	union acpi_operand_object       *object);
+
+void
+acpi_ut_remove_reference (
+	union acpi_operand_object       *object);
+
+/*
+ * ut_size - Object size routines
+ */
+
+acpi_status
+acpi_ut_get_simple_object_size (
+	union acpi_operand_object       *obj,
+	acpi_size                       *obj_length);
+
+acpi_status
+acpi_ut_get_package_object_size (
+	union acpi_operand_object       *obj,
+	acpi_size                       *obj_length);
+
+acpi_status
+acpi_ut_get_object_size(
+	union acpi_operand_object       *obj,
+	acpi_size                       *obj_length);
+
+acpi_status
+acpi_ut_get_element_length (
+	u8                              object_type,
+	union acpi_operand_object       *source_object,
+	union acpi_generic_state        *state,
+	void                            *context);
+
+
+/*
+ * ut_state - Generic state creation/cache routines
+ */
+
+void
+acpi_ut_push_generic_state (
+	union acpi_generic_state        **list_head,
+	union acpi_generic_state        *state);
+
+union acpi_generic_state *
+acpi_ut_pop_generic_state (
+	union acpi_generic_state        **list_head);
+
+
+union acpi_generic_state *
+acpi_ut_create_generic_state (
+	void);
+
+struct acpi_thread_state *
+acpi_ut_create_thread_state (
+	void);
+
+union acpi_generic_state *
+acpi_ut_create_update_state (
+	union acpi_operand_object       *object,
+	u16                             action);
+
+union acpi_generic_state *
+acpi_ut_create_pkg_state (
+	void                            *internal_object,
+	void                            *external_object,
+	u16                             index);
+
+acpi_status
+acpi_ut_create_update_state_and_push (
+	union acpi_operand_object       *object,
+	u16                             action,
+	union acpi_generic_state        **state_list);
+
+acpi_status
+acpi_ut_create_pkg_state_and_push (
+	void                            *internal_object,
+	void                            *external_object,
+	u16                             index,
+	union acpi_generic_state        **state_list);
+
+union acpi_generic_state *
+acpi_ut_create_control_state (
+	void);
+
+void
+acpi_ut_delete_generic_state (
+	union acpi_generic_state        *state);
+
+void
+acpi_ut_delete_generic_state_cache (
+	void);
+
+void
+acpi_ut_delete_object_cache (
+	void);
+
+/*
+ * utmisc
+ */
+
+void
+acpi_ut_print_string (
+	char                            *string,
+	u8                              max_length);
+
+acpi_status
+acpi_ut_divide (
+	acpi_integer                    *in_dividend,
+	acpi_integer                    *in_divisor,
+	acpi_integer                    *out_quotient,
+	acpi_integer                    *out_remainder);
+
+acpi_status
+acpi_ut_short_divide (
+	acpi_integer                    *in_dividend,
+	u32                             divisor,
+	acpi_integer                    *out_quotient,
+	u32                             *out_remainder);
+
+u8
+acpi_ut_valid_acpi_name (
+	u32                             name);
+
+u8
+acpi_ut_valid_acpi_character (
+	char                            character);
+
+acpi_status
+acpi_ut_strtoul64 (
+	char                            *string,
+	u32                             base,
+	acpi_integer                    *ret_integer);
+
+char *
+acpi_ut_strupr (
+	char                            *src_string);
+
+u8 *
+acpi_ut_get_resource_end_tag (
+	union acpi_operand_object       *obj_desc);
+
+u8
+acpi_ut_generate_checksum (
+	u8                              *buffer,
+	u32                             length);
+
+u32
+acpi_ut_dword_byte_swap (
+	u32                             value);
+
+void
+acpi_ut_set_integer_width (
+	u8                              revision);
+
+#ifdef ACPI_DEBUG_OUTPUT
+void
+acpi_ut_display_init_pathname (
+	u8                              type,
+	struct acpi_namespace_node      *obj_handle,
+	char                            *path);
+
+#endif
+
+
+/*
+ * Utalloc - memory allocation and object caching
+ */
+
+void *
+acpi_ut_acquire_from_cache (
+	u32                             list_id);
+
+void
+acpi_ut_release_to_cache (
+	u32                             list_id,
+	void                            *object);
+
+void
+acpi_ut_delete_generic_cache (
+	u32                             list_id);
+
+acpi_status
+acpi_ut_validate_buffer (
+	struct acpi_buffer              *buffer);
+
+acpi_status
+acpi_ut_initialize_buffer (
+	struct acpi_buffer              *buffer,
+	acpi_size                       required_length);
+
+
+/* Memory allocation functions */
+
+void *
+acpi_ut_allocate (
+	acpi_size                       size,
+	u32                             component,
+	char                            *module,
+	u32                             line);
+
+void *
+acpi_ut_callocate (
+	acpi_size                       size,
+	u32                             component,
+	char                            *module,
+	u32                             line);
+
+
+#ifdef ACPI_DBG_TRACK_ALLOCATIONS
+
+void *
+acpi_ut_allocate_and_track (
+	acpi_size                       size,
+	u32                             component,
+	char                            *module,
+	u32                             line);
+
+void *
+acpi_ut_callocate_and_track (
+	acpi_size                       size,
+	u32                             component,
+	char                            *module,
+	u32                             line);
+
+void
+acpi_ut_free_and_track (
+	void                            *address,
+	u32                             component,
+	char                            *module,
+	u32                             line);
+
+struct acpi_debug_mem_block *
+acpi_ut_find_allocation (
+	u32                             list_id,
+	void                            *allocation);
+
+acpi_status
+acpi_ut_track_allocation (
+	u32                             list_id,
+	struct acpi_debug_mem_block     *address,
+	acpi_size                       size,
+	u8                              alloc_type,
+	u32                             component,
+	char                            *module,
+	u32                             line);
+
+acpi_status
+acpi_ut_remove_allocation (
+	u32                             list_id,
+	struct acpi_debug_mem_block     *address,
+	u32                             component,
+	char                            *module,
+	u32                             line);
+
+void
+acpi_ut_dump_allocation_info (
+	void);
+
+void
+acpi_ut_dump_allocations (
+	u32                             component,
+	char                            *module);
+#endif
+
+
+#endif /* _ACUTILS_H */
diff -urNp linux-5400/include/acpi/amlcode.h linux-5410/include/acpi/amlcode.h
--- linux-5400/include/acpi/amlcode.h
+++ linux-5410/include/acpi/amlcode.h
@@ -0,0 +1,506 @@
+/******************************************************************************
+ *
+ * Name: amlcode.h - Definitions for AML, as included in "definition blocks"
+ *                   Declarations and definitions contained herein are derived
+ *                   directly from the ACPI specification.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __AMLCODE_H__
+#define __AMLCODE_H__
+
+/* primary opcodes */
+
+#define AML_NULL_CHAR               (u16) 0x00
+
+#define AML_ZERO_OP                 (u16) 0x00
+#define AML_ONE_OP                  (u16) 0x01
+#define AML_UNASSIGNED              (u16) 0x02
+#define AML_ALIAS_OP                (u16) 0x06
+#define AML_NAME_OP                 (u16) 0x08
+#define AML_BYTE_OP                 (u16) 0x0a
+#define AML_WORD_OP                 (u16) 0x0b
+#define AML_DWORD_OP                (u16) 0x0c
+#define AML_STRING_OP               (u16) 0x0d
+#define AML_QWORD_OP                (u16) 0x0e     /* ACPI 2.0 */
+#define AML_SCOPE_OP                (u16) 0x10
+#define AML_BUFFER_OP               (u16) 0x11
+#define AML_PACKAGE_OP              (u16) 0x12
+#define AML_VAR_PACKAGE_OP          (u16) 0x13     /* ACPI 2.0 */
+#define AML_METHOD_OP               (u16) 0x14
+#define AML_DUAL_NAME_PREFIX        (u16) 0x2e
+#define AML_MULTI_NAME_PREFIX_OP    (u16) 0x2f
+#define AML_NAME_CHAR_SUBSEQ        (u16) 0x30
+#define AML_NAME_CHAR_FIRST         (u16) 0x41
+#define AML_OP_PREFIX               (u16) 0x5b
+#define AML_ROOT_PREFIX             (u16) 0x5c
+#define AML_PARENT_PREFIX           (u16) 0x5e
+#define AML_LOCAL_OP                (u16) 0x60
+#define AML_LOCAL0                  (u16) 0x60
+#define AML_LOCAL1                  (u16) 0x61
+#define AML_LOCAL2                  (u16) 0x62
+#define AML_LOCAL3                  (u16) 0x63
+#define AML_LOCAL4                  (u16) 0x64
+#define AML_LOCAL5                  (u16) 0x65
+#define AML_LOCAL6                  (u16) 0x66
+#define AML_LOCAL7                  (u16) 0x67
+#define AML_ARG_OP                  (u16) 0x68
+#define AML_ARG0                    (u16) 0x68
+#define AML_ARG1                    (u16) 0x69
+#define AML_ARG2                    (u16) 0x6a
+#define AML_ARG3                    (u16) 0x6b
+#define AML_ARG4                    (u16) 0x6c
+#define AML_ARG5                    (u16) 0x6d
+#define AML_ARG6                    (u16) 0x6e
+#define AML_STORE_OP                (u16) 0x70
+#define AML_REF_OF_OP               (u16) 0x71
+#define AML_ADD_OP                  (u16) 0x72
+#define AML_CONCAT_OP               (u16) 0x73
+#define AML_SUBTRACT_OP             (u16) 0x74
+#define AML_INCREMENT_OP            (u16) 0x75
+#define AML_DECREMENT_OP            (u16) 0x76
+#define AML_MULTIPLY_OP             (u16) 0x77
+#define AML_DIVIDE_OP               (u16) 0x78
+#define AML_SHIFT_LEFT_OP           (u16) 0x79
+#define AML_SHIFT_RIGHT_OP          (u16) 0x7a
+#define AML_BIT_AND_OP              (u16) 0x7b
+#define AML_BIT_NAND_OP             (u16) 0x7c
+#define AML_BIT_OR_OP               (u16) 0x7d
+#define AML_BIT_NOR_OP              (u16) 0x7e
+#define AML_BIT_XOR_OP              (u16) 0x7f
+#define AML_BIT_NOT_OP              (u16) 0x80
+#define AML_FIND_SET_LEFT_BIT_OP    (u16) 0x81
+#define AML_FIND_SET_RIGHT_BIT_OP   (u16) 0x82
+#define AML_DEREF_OF_OP             (u16) 0x83
+#define AML_CONCAT_RES_OP           (u16) 0x84     /* ACPI 2.0 */
+#define AML_MOD_OP                  (u16) 0x85     /* ACPI 2.0 */
+#define AML_NOTIFY_OP               (u16) 0x86
+#define AML_SIZE_OF_OP              (u16) 0x87
+#define AML_INDEX_OP                (u16) 0x88
+#define AML_MATCH_OP                (u16) 0x89
+#define AML_CREATE_DWORD_FIELD_OP   (u16) 0x8a
+#define AML_CREATE_WORD_FIELD_OP    (u16) 0x8b
+#define AML_CREATE_BYTE_FIELD_OP    (u16) 0x8c
+#define AML_CREATE_BIT_FIELD_OP     (u16) 0x8d
+#define AML_TYPE_OP                 (u16) 0x8e
+#define AML_CREATE_QWORD_FIELD_OP   (u16) 0x8f     /* ACPI 2.0 */
+#define AML_LAND_OP                 (u16) 0x90
+#define AML_LOR_OP                  (u16) 0x91
+#define AML_LNOT_OP                 (u16) 0x92
+#define AML_LEQUAL_OP               (u16) 0x93
+#define AML_LGREATER_OP             (u16) 0x94
+#define AML_LLESS_OP                (u16) 0x95
+#define AML_TO_BUFFER_OP            (u16) 0x96     /* ACPI 2.0 */
+#define AML_TO_DECSTRING_OP         (u16) 0x97     /* ACPI 2.0 */
+#define AML_TO_HEXSTRING_OP         (u16) 0x98     /* ACPI 2.0 */
+#define AML_TO_INTEGER_OP           (u16) 0x99     /* ACPI 2.0 */
+#define AML_TO_STRING_OP            (u16) 0x9c     /* ACPI 2.0 */
+#define AML_COPY_OP                 (u16) 0x9d     /* ACPI 2.0 */
+#define AML_MID_OP                  (u16) 0x9e     /* ACPI 2.0 */
+#define AML_CONTINUE_OP             (u16) 0x9f     /* ACPI 2.0 */
+#define AML_IF_OP                   (u16) 0xa0
+#define AML_ELSE_OP                 (u16) 0xa1
+#define AML_WHILE_OP                (u16) 0xa2
+#define AML_NOOP_OP                 (u16) 0xa3
+#define AML_RETURN_OP               (u16) 0xa4
+#define AML_BREAK_OP                (u16) 0xa5
+#define AML_BREAK_POINT_OP          (u16) 0xcc
+#define AML_ONES_OP                 (u16) 0xff
+
+/* prefixed opcodes */
+
+#define AML_EXTOP                   (u16) 0x005b
+
+
+#define AML_MUTEX_OP                (u16) 0x5b01
+#define AML_EVENT_OP                (u16) 0x5b02
+#define AML_SHIFT_RIGHT_BIT_OP      (u16) 0x5b10
+#define AML_SHIFT_LEFT_BIT_OP       (u16) 0x5b11
+#define AML_COND_REF_OF_OP          (u16) 0x5b12
+#define AML_CREATE_FIELD_OP         (u16) 0x5b13
+#define AML_LOAD_TABLE_OP           (u16) 0x5b1f     /* ACPI 2.0 */
+#define AML_LOAD_OP                 (u16) 0x5b20
+#define AML_STALL_OP                (u16) 0x5b21
+#define AML_SLEEP_OP                (u16) 0x5b22
+#define AML_ACQUIRE_OP              (u16) 0x5b23
+#define AML_SIGNAL_OP               (u16) 0x5b24
+#define AML_WAIT_OP                 (u16) 0x5b25
+#define AML_RESET_OP                (u16) 0x5b26
+#define AML_RELEASE_OP              (u16) 0x5b27
+#define AML_FROM_BCD_OP             (u16) 0x5b28
+#define AML_TO_BCD_OP               (u16) 0x5b29
+#define AML_UNLOAD_OP               (u16) 0x5b2a
+#define AML_REVISION_OP             (u16) 0x5b30
+#define AML_DEBUG_OP                (u16) 0x5b31
+#define AML_FATAL_OP                (u16) 0x5b32
+#define AML_REGION_OP               (u16) 0x5b80
+#define AML_FIELD_OP                (u16) 0x5b81
+#define AML_DEVICE_OP               (u16) 0x5b82
+#define AML_PROCESSOR_OP            (u16) 0x5b83
+#define AML_POWER_RES_OP            (u16) 0x5b84
+#define AML_THERMAL_ZONE_OP         (u16) 0x5b85
+#define AML_INDEX_FIELD_OP          (u16) 0x5b86
+#define AML_BANK_FIELD_OP           (u16) 0x5b87
+#define AML_DATA_REGION_OP          (u16) 0x5b88     /* ACPI 2.0 */
+
+
+/* Bogus opcodes (they are actually two separate opcodes) */
+
+#define AML_LGREATEREQUAL_OP        (u16) 0x9295
+#define AML_LLESSEQUAL_OP           (u16) 0x9294
+#define AML_LNOTEQUAL_OP            (u16) 0x9293
+
+
+/*
+ * Internal opcodes
+ * Use only "Unknown" AML opcodes, don't attempt to use
+ * any valid ACPI ASCII values (A-Z, 0-9, '-')
+ */
+
+#define AML_INT_NAMEPATH_OP         (u16) 0x002d
+#define AML_INT_NAMEDFIELD_OP       (u16) 0x0030
+#define AML_INT_RESERVEDFIELD_OP    (u16) 0x0031
+#define AML_INT_ACCESSFIELD_OP      (u16) 0x0032
+#define AML_INT_BYTELIST_OP         (u16) 0x0033
+#define AML_INT_STATICSTRING_OP     (u16) 0x0034
+#define AML_INT_METHODCALL_OP       (u16) 0x0035
+#define AML_INT_RETURN_VALUE_OP     (u16) 0x0036
+#define AML_INT_EVAL_SUBTREE_OP     (u16) 0x0037
+
+
+#define ARG_NONE                    0x0
+
+/*
+ * Argument types for the AML Parser
+ * Each field in the arg_types u32 is 5 bits, allowing for a maximum of 6 arguments.
+ * There can be up to 31 unique argument types
+ * Zero is reserved as end-of-list indicator
+ */
+
+#define ARGP_BYTEDATA               0x01
+#define ARGP_BYTELIST               0x02
+#define ARGP_CHARLIST               0x03
+#define ARGP_DATAOBJ                0x04
+#define ARGP_DATAOBJLIST            0x05
+#define ARGP_DWORDDATA              0x06
+#define ARGP_FIELDLIST              0x07
+#define ARGP_NAME                   0x08
+#define ARGP_NAMESTRING             0x09
+#define ARGP_OBJLIST                0x0A
+#define ARGP_PKGLENGTH              0x0B
+#define ARGP_SUPERNAME              0x0C
+#define ARGP_TARGET                 0x0D
+#define ARGP_TERMARG                0x0E
+#define ARGP_TERMLIST               0x0F
+#define ARGP_WORDDATA               0x10
+#define ARGP_QWORDDATA              0x11
+#define ARGP_SIMPLENAME             0x12
+
+/*
+ * Resolved argument types for the AML Interpreter
+ * Each field in the arg_types u32 is 5 bits, allowing for a maximum of 6 arguments.
+ * There can be up to 31 unique argument types (0 is end-of-arg-list indicator)
+ *
+ * Note1: These values are completely independent from the ACPI_TYPEs
+ *        i.e., ARGI_INTEGER != ACPI_TYPE_INTEGER
+ *
+ * Note2: If and when 5 bits becomes insufficient, it would probably be best
+ * to convert to a 6-byte array of argument types, allowing 8 bits per argument.
+ */
+
+/* Single, simple types */
+
+#define ARGI_ANYTYPE                0x01    /* Don't care */
+#define ARGI_PACKAGE                0x02
+#define ARGI_EVENT                  0x03
+#define ARGI_MUTEX                  0x04
+#define ARGI_DDBHANDLE              0x05
+
+/* Interchangeable types (via implicit conversion) */
+
+#define ARGI_INTEGER                0x06
+#define ARGI_STRING                 0x07
+#define ARGI_BUFFER                 0x08
+#define ARGI_BUFFER_OR_STRING       0x09    /* Used by MID op only */
+#define ARGI_COMPUTEDATA            0x0A    /* Buffer, String, or Integer */
+
+/* Reference objects */
+
+#define ARGI_INTEGER_REF            0x0B
+#define ARGI_OBJECT_REF             0x0C
+#define ARGI_DEVICE_REF             0x0D
+#define ARGI_REFERENCE              0x0E
+#define ARGI_TARGETREF              0x0F    /* Target, subject to implicit conversion */
+#define ARGI_FIXED_TARGET           0x10    /* Target, no implicit conversion */
+#define ARGI_SIMPLE_TARGET          0x11    /* Name, Local, Arg -- no implicit conversion */
+
+/* Multiple/complex types */
+
+#define ARGI_DATAOBJECT             0x12    /* Buffer, String, package or reference to a Node - Used only by size_of operator*/
+#define ARGI_COMPLEXOBJ             0x13    /* Buffer, String, or package (Used by INDEX op only) */
+#define ARGI_REF_OR_STRING          0x14    /* Reference or String (Used by DEREFOF op only) */
+#define ARGI_REGION_OR_FIELD        0x15    /* Used by LOAD op only */
+
+/* Note: types above can expand to 0x1F maximum */
+
+#define ARGI_INVALID_OPCODE         0xFFFFFFFF
+
+
+/*
+ * hash offsets
+ */
+#define AML_EXTOP_HASH_OFFSET       22
+#define AML_LNOT_HASH_OFFSET        19
+
+
+/*
+ * opcode groups and types
+ */
+
+#define OPGRP_NAMED                 0x01
+#define OPGRP_FIELD                 0x02
+#define OPGRP_BYTELIST              0x04
+
+
+/*
+ * Opcode information
+ */
+
+/* Opcode flags */
+
+#define AML_HAS_ARGS                0x0800
+#define AML_HAS_TARGET              0x0400
+#define AML_HAS_RETVAL              0x0200
+#define AML_NSOBJECT                0x0100
+#define AML_NSOPCODE                0x0080
+#define AML_NSNODE                  0x0040
+#define AML_NAMED                   0x0020
+#define AML_DEFER                   0x0010
+#define AML_FIELD                   0x0008
+#define AML_CREATE                  0x0004
+#define AML_MATH                    0x0002
+#define AML_LOGICAL                 0x0001
+#define AML_CONSTANT                0x1000
+
+/* Convenient flag groupings */
+
+#define AML_FLAGS_EXEC_1A_0T_0R     AML_HAS_ARGS                                   /* Monadic1  */
+#define AML_FLAGS_EXEC_1A_0T_1R     AML_HAS_ARGS |                  AML_HAS_RETVAL /* Monadic2  */
+#define AML_FLAGS_EXEC_1A_1T_0R     AML_HAS_ARGS | AML_HAS_TARGET
+#define AML_FLAGS_EXEC_1A_1T_1R     AML_HAS_ARGS | AML_HAS_TARGET | AML_HAS_RETVAL /* monadic2_r */
+#define AML_FLAGS_EXEC_2A_0T_0R     AML_HAS_ARGS                                   /* Dyadic1   */
+#define AML_FLAGS_EXEC_2A_0T_1R     AML_HAS_ARGS |                  AML_HAS_RETVAL /* Dyadic2   */
+#define AML_FLAGS_EXEC_2A_1T_1R     AML_HAS_ARGS | AML_HAS_TARGET | AML_HAS_RETVAL /* dyadic2_r  */
+#define AML_FLAGS_EXEC_2A_2T_1R     AML_HAS_ARGS | AML_HAS_TARGET | AML_HAS_RETVAL
+#define AML_FLAGS_EXEC_3A_0T_0R     AML_HAS_ARGS
+#define AML_FLAGS_EXEC_3A_1T_1R     AML_HAS_ARGS | AML_HAS_TARGET | AML_HAS_RETVAL
+#define AML_FLAGS_EXEC_6A_0T_1R     AML_HAS_ARGS |                  AML_HAS_RETVAL
+
+
+/*
+ * The opcode Type is used in a dispatch table, do not change
+ * without updating the table.
+ */
+#define AML_TYPE_EXEC_1A_0T_0R      0x00 /* Monadic1  */
+#define AML_TYPE_EXEC_1A_0T_1R      0x01 /* Monadic2  */
+#define AML_TYPE_EXEC_1A_1T_0R      0x02
+#define AML_TYPE_EXEC_1A_1T_1R      0x03 /* monadic2_r */
+#define AML_TYPE_EXEC_2A_0T_0R      0x04 /* Dyadic1   */
+#define AML_TYPE_EXEC_2A_0T_1R      0x05 /* Dyadic2   */
+#define AML_TYPE_EXEC_2A_1T_1R      0x06 /* dyadic2_r  */
+#define AML_TYPE_EXEC_2A_2T_1R      0x07
+#define AML_TYPE_EXEC_3A_0T_0R      0x08
+#define AML_TYPE_EXEC_3A_1T_1R      0x09
+#define AML_TYPE_EXEC_6A_0T_1R      0x0A
+/* End of types used in dispatch table */
+
+#define AML_TYPE_LITERAL            0x0B
+#define AML_TYPE_CONSTANT           0x0C
+#define AML_TYPE_METHOD_ARGUMENT    0x0D
+#define AML_TYPE_LOCAL_VARIABLE     0x0E
+#define AML_TYPE_DATA_TERM          0x0F
+
+/* Generic for an op that returns a value */
+
+#define AML_TYPE_METHOD_CALL        0x10
+
+/* Misc */
+
+#define AML_TYPE_CREATE_FIELD       0x11
+#define AML_TYPE_CREATE_OBJECT      0x12
+#define AML_TYPE_CONTROL            0x13
+#define AML_TYPE_NAMED_NO_OBJ       0x14
+#define AML_TYPE_NAMED_FIELD        0x15
+#define AML_TYPE_NAMED_SIMPLE       0x16
+#define AML_TYPE_NAMED_COMPLEX      0x17
+#define AML_TYPE_RETURN             0x18
+
+#define AML_TYPE_UNDEFINED          0x19
+#define AML_TYPE_BOGUS              0x1A
+
+
+/*
+ * Opcode classes
+ */
+#define AML_CLASS_EXECUTE           0x00
+#define AML_CLASS_CREATE            0x01
+#define AML_CLASS_ARGUMENT          0x02
+#define AML_CLASS_NAMED_OBJECT      0x03
+#define AML_CLASS_CONTROL           0x04
+#define AML_CLASS_ASCII             0x05
+#define AML_CLASS_PREFIX            0x06
+#define AML_CLASS_INTERNAL          0x07
+#define AML_CLASS_RETURN_VALUE      0x08
+#define AML_CLASS_METHOD_CALL       0x09
+#define AML_CLASS_UNKNOWN           0x0A
+
+
+/* Predefined Operation Region space_iDs */
+
+typedef enum
+{
+	REGION_MEMORY                   = 0,
+	REGION_IO,
+	REGION_PCI_CONFIG,
+	REGION_EC,
+	REGION_SMBUS,
+	REGION_CMOS,
+	REGION_PCI_BAR,
+	REGION_DATA_TABLE,              /* Internal use only */
+	REGION_FIXED_HW                 = 0x7F
+
+} AML_REGION_TYPES;
+
+
+/* Comparison operation codes for match_op operator */
+
+typedef enum
+{
+	MATCH_MTR                       = 0,
+	MATCH_MEQ                       = 1,
+	MATCH_MLE                       = 2,
+	MATCH_MLT                       = 3,
+	MATCH_MGE                       = 4,
+	MATCH_MGT                       = 5
+
+} AML_MATCH_OPERATOR;
+
+#define MAX_MATCH_OPERATOR          5
+
+
+/*
+ * field_flags
+ *
+ * This byte is extracted from the AML and includes three separate
+ * pieces of information about the field:
+ * 1) The field access type
+ * 2) The field update rule
+ * 3) The lock rule for the field
+ *
+ * Bits 00 - 03 : access_type (any_acc, byte_acc, etc.)
+ *      04      : lock_rule (1 == Lock)
+ *      05 - 06 : update_rule
+ */
+#define AML_FIELD_ACCESS_TYPE_MASK  0x0F
+#define AML_FIELD_LOCK_RULE_MASK    0x10
+#define AML_FIELD_UPDATE_RULE_MASK  0x60
+
+
+/* 1) Field Access Types */
+
+typedef enum
+{
+	AML_FIELD_ACCESS_ANY            = 0x00,
+	AML_FIELD_ACCESS_BYTE           = 0x01,
+	AML_FIELD_ACCESS_WORD           = 0x02,
+	AML_FIELD_ACCESS_DWORD          = 0x03,
+	AML_FIELD_ACCESS_QWORD          = 0x04,    /* ACPI 2.0 */
+	AML_FIELD_ACCESS_BUFFER         = 0x05     /* ACPI 2.0 */
+
+} AML_ACCESS_TYPE;
+
+
+/* 2) Field Lock Rules */
+
+typedef enum
+{
+	AML_FIELD_LOCK_NEVER            = 0x00,
+	AML_FIELD_LOCK_ALWAYS           = 0x10
+
+} AML_LOCK_RULE;
+
+
+/* 3) Field Update Rules */
+
+typedef enum
+{
+	AML_FIELD_UPDATE_PRESERVE       = 0x00,
+	AML_FIELD_UPDATE_WRITE_AS_ONES  = 0x20,
+	AML_FIELD_UPDATE_WRITE_AS_ZEROS = 0x40
+
+} AML_UPDATE_RULE;
+
+
+/*
+ * Field Access Attributes.
+ * This byte is extracted from the AML via the
+ * access_as keyword
+ */
+typedef enum
+{
+	AML_FIELD_ATTRIB_SMB_QUICK      = 0x02,
+	AML_FIELD_ATTRIB_SMB_SEND_RCV   = 0x04,
+	AML_FIELD_ATTRIB_SMB_BYTE       = 0x06,
+	AML_FIELD_ATTRIB_SMB_WORD       = 0x08,
+	AML_FIELD_ATTRIB_SMB_BLOCK      = 0x0A,
+	AML_FIELD_ATTRIB_SMB_WORD_CALL  = 0x0C,
+	AML_FIELD_ATTRIB_SMB_BLOCK_CALL = 0x0D
+
+} AML_ACCESS_ATTRIBUTE;
+
+
+/* bit fields in method_flags byte */
+
+#define METHOD_FLAGS_ARG_COUNT      0x07
+#define METHOD_FLAGS_SERIALIZED     0x08
+#define METHOD_FLAGS_SYNCH_LEVEL    0xF0
+
+
+#endif /* __AMLCODE_H__ */
diff -urNp linux-5400/include/acpi/amlresrc.h linux-5410/include/acpi/amlresrc.h
--- linux-5400/include/acpi/amlresrc.h
+++ linux-5410/include/acpi/amlresrc.h
@@ -0,0 +1,329 @@
+
+/******************************************************************************
+ *
+ * Module Name: amlresrc.h - AML resource descriptors
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+
+#ifndef __AMLRESRC_H
+#define __AMLRESRC_H
+
+
+#define ASL_RESNAME_ADDRESS                     "_ADR"
+#define ASL_RESNAME_ALIGNMENT                   "_ALN"
+#define ASL_RESNAME_ADDRESSSPACE                "_ASI"
+#define ASL_RESNAME_BASEADDRESS                 "_BAS"
+#define ASL_RESNAME_BUSMASTER                   "_BM_"  /* Master(1), Slave(0) */
+#define ASL_RESNAME_DECODE                      "_DEC"
+#define ASL_RESNAME_DMA                         "_DMA"
+#define ASL_RESNAME_DMATYPE                     "_TYP"  /* Compatible(0), A(1), B(2), F(3) */
+#define ASL_RESNAME_GRANULARITY                 "_GRA"
+#define ASL_RESNAME_INTERRUPT                   "_INT"
+#define ASL_RESNAME_INTERRUPTLEVEL              "_LL_"  /* active_lo(1), active_hi(0) */
+#define ASL_RESNAME_INTERRUPTSHARE              "_SHR"  /* Shareable(1), no_share(0) */
+#define ASL_RESNAME_INTERRUPTTYPE               "_HE_"  /* Edge(1), Level(0) */
+#define ASL_RESNAME_LENGTH                      "_LEN"
+#define ASL_RESNAME_MEMATTRIBUTES               "_MTP"  /* Memory(0), Reserved(1), ACPI(2), NVS(3) */
+#define ASL_RESNAME_MEMTYPE                     "_MEM"  /* non_cache(0), Cacheable(1) Cache+combine(2), Cache+prefetch(3) */
+#define ASL_RESNAME_MAXADDR                     "_MAX"
+#define ASL_RESNAME_MINADDR                     "_MIN"
+#define ASL_RESNAME_MAXTYPE                     "_MAF"
+#define ASL_RESNAME_MINTYPE                     "_MIF"
+#define ASL_RESNAME_REGISTERBITOFFSET           "_RBO"
+#define ASL_RESNAME_REGISTERBITWIDTH            "_RBW"
+#define ASL_RESNAME_RANGETYPE                   "_RNG"
+#define ASL_RESNAME_READWRITETYPE               "_RW_"  /* read_only(0), Writeable (1) */
+#define ASL_RESNAME_TRANSLATION                 "_TRA"
+#define ASL_RESNAME_TRANSTYPE                   "_TRS"  /* Sparse(1), Dense(0) */
+#define ASL_RESNAME_TYPE                        "_TTP"  /* Translation(1), Static (0) */
+#define ASL_RESNAME_XFERTYPE                    "_SIz"  /* 8(0), 8_and16(1), 16(2) */
+
+
+/* Default sizes for "small" resource descriptors */
+
+#define ASL_RDESC_IRQ_SIZE                      0x02
+#define ASL_RDESC_DMA_SIZE                      0x02
+#define ASL_RDESC_ST_DEPEND_SIZE                0x00
+#define ASL_RDESC_END_DEPEND_SIZE               0x00
+#define ASL_RDESC_IO_SIZE                       0x07
+#define ASL_RDESC_FIXED_IO_SIZE                 0x03
+#define ASL_RDESC_END_TAG_SIZE                  0x01
+
+
+struct asl_resource_node
+{
+	u32                                 buffer_length;
+	void                                *buffer;
+	struct asl_resource_node            *next;
+};
+
+
+/*
+ * Resource descriptors defined in the ACPI specification.
+ *
+ * Alignment must be BYTE because these descriptors
+ * are used to overlay the AML byte stream.
+ */
+#pragma pack(1)
+
+struct asl_irq_format_desc
+{
+	u8                                  descriptor_type;
+	u16                                 irq_mask;
+	u8                                  flags;
+};
+
+
+struct asl_irq_noflags_desc
+{
+	u8                                  descriptor_type;
+	u16                                 irq_mask;
+};
+
+
+struct asl_dma_format_desc
+{
+	u8                                  descriptor_type;
+	u8                                  dma_channel_mask;
+	u8                                  flags;
+};
+
+
+struct asl_start_dependent_desc
+{
+	u8                                  descriptor_type;
+	u8                                  flags;
+};
+
+
+struct asl_start_dependent_noprio_desc
+{
+	u8                                  descriptor_type;
+};
+
+
+struct asl_end_dependent_desc
+{
+	u8                                  descriptor_type;
+};
+
+
+struct asl_io_port_desc
+{
+	u8                                  descriptor_type;
+	u8                                  information;
+	u16                                 address_min;
+	u16                                 address_max;
+	u8                                  alignment;
+	u8                                  length;
+};
+
+
+struct asl_fixed_io_port_desc
+{
+	u8                                  descriptor_type;
+	u16                                 base_address;
+	u8                                  length;
+};
+
+
+struct asl_small_vendor_desc
+{
+	u8                                  descriptor_type;
+	u8                                  vendor_defined[7];
+};
+
+
+struct asl_end_tag_desc
+{
+	u8                                  descriptor_type;
+	u8                                  checksum;
+};
+
+
+/* LARGE descriptors */
+
+struct asl_memory_24_desc
+{
+	u8                                  descriptor_type;
+	u16                                 length;
+	u8                                  information;
+	u16                                 address_min;
+	u16                                 address_max;
+	u16                                 alignment;
+	u16                                 range_length;
+};
+
+
+struct asl_large_vendor_desc
+{
+	u8                                  descriptor_type;
+	u16                                 length;
+	u8                                  vendor_defined[1];
+};
+
+
+struct asl_memory_32_desc
+{
+	u8                                  descriptor_type;
+	u16                                 length;
+	u8                                  information;
+	u32                                 address_min;
+	u32                                 address_max;
+	u32                                 alignment;
+	u32                                 range_length;
+};
+
+
+struct asl_fixed_memory_32_desc
+{
+	u8                                  descriptor_type;
+	u16                                 length;
+	u8                                  information;
+	u32                                 base_address;
+	u32                                 range_length;
+};
+
+
+struct asl_qword_address_desc
+{
+	u8                                  descriptor_type;
+	u16                                 length;
+	u8                                  resource_type;
+	u8                                  flags;
+	u8                                  specific_flags;
+	u64                                 granularity;
+	u64                                 address_min;
+	u64                                 address_max;
+	u64                                 translation_offset;
+	u64                                 address_length;
+	u8                                  optional_fields[2];
+};
+
+
+struct asl_dword_address_desc
+{
+	u8                                  descriptor_type;
+	u16                                 length;
+	u8                                  resource_type;
+	u8                                  flags;
+	u8                                  specific_flags;
+	u32                                 granularity;
+	u32                                 address_min;
+	u32                                 address_max;
+	u32                                 translation_offset;
+	u32                                 address_length;
+	u8                                  optional_fields[2];
+};
+
+
+struct asl_word_address_desc
+{
+	u8                                  descriptor_type;
+	u16                                 length;
+	u8                                  resource_type;
+	u8                                  flags;
+	u8                                  specific_flags;
+	u16                                 granularity;
+	u16                                 address_min;
+	u16                                 address_max;
+	u16                                 translation_offset;
+	u16                                 address_length;
+	u8                                  optional_fields[2];
+};
+
+
+struct asl_extended_xrupt_desc
+{
+	u8                                  descriptor_type;
+	u16                                 length;
+	u8                                  flags;
+	u8                                  table_length;
+	u32                                 interrupt_number[1];
+	/* res_source_index, res_source optional fields follow */
+};
+
+
+struct asl_general_register_desc
+{
+	u8                                  descriptor_type;
+	u16                                 length;
+	u8                                  address_space_id;
+	u8                                  bit_width;
+	u8                                  bit_offset;
+	u8                                  reserved;
+	u64                                 address;
+};
+
+/* restore default alignment */
+
+#pragma pack()
+
+/* Union of all resource descriptors, sow we can allocate the worst case */
+
+union asl_resource_desc
+{
+	struct asl_irq_format_desc          irq;
+	struct asl_dma_format_desc          dma;
+	struct asl_start_dependent_desc     std;
+	struct asl_end_dependent_desc       end;
+	struct asl_io_port_desc             iop;
+	struct asl_fixed_io_port_desc       fio;
+	struct asl_small_vendor_desc        smv;
+	struct asl_end_tag_desc             et;
+
+	struct asl_memory_24_desc           M24;
+	struct asl_large_vendor_desc        lgv;
+	struct asl_memory_32_desc           M32;
+	struct asl_fixed_memory_32_desc     F32;
+	struct asl_qword_address_desc       qas;
+	struct asl_dword_address_desc       das;
+	struct asl_word_address_desc        was;
+	struct asl_extended_xrupt_desc      exx;
+	struct asl_general_register_desc    grg;
+	u32                                 u32_item;
+	u16                                 u16_item;
+	u8                                  U8item;
+};
+
+
+#endif
+
diff -urNp linux-5400/include/acpi/platform/acenv.h linux-5410/include/acpi/platform/acenv.h
--- linux-5400/include/acpi/platform/acenv.h
+++ linux-5410/include/acpi/platform/acenv.h
@@ -0,0 +1,363 @@
+/******************************************************************************
+ *
+ * Name: acenv.h - Generation environment specific items
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACENV_H__
+#define __ACENV_H__
+
+
+/*
+ * Configuration for ACPI tools and utilities
+ */
+
+#ifdef _ACPI_DUMP_APP
+#ifndef MSDOS
+#define ACPI_DEBUG_OUTPUT
+#endif
+#define ACPI_APPLICATION
+#define ACPI_DISASSEMBLER
+#define ACPI_NO_METHOD_EXECUTION
+#define ACPI_USE_SYSTEM_CLIBRARY
+#endif
+
+#ifdef _ACPI_EXEC_APP
+#undef DEBUGGER_THREADING
+#define DEBUGGER_THREADING      DEBUGGER_SINGLE_THREADED
+#define ACPI_DEBUG_OUTPUT
+#define ACPI_APPLICATION
+#define ACPI_DEBUGGER
+#define ACPI_DISASSEMBLER
+#define ACPI_USE_SYSTEM_CLIBRARY
+#endif
+
+#ifdef _ACPI_ASL_COMPILER
+#define ACPI_DEBUG_OUTPUT
+#define ACPI_APPLICATION
+#define ACPI_DISASSEMBLER
+#define ACPI_CONSTANT_EVAL_ONLY
+#define ACPI_USE_SYSTEM_CLIBRARY
+#endif
+
+/*
+ * Environment configuration.  The purpose of this file is to interface to the
+ * local generation environment.
+ *
+ * 1) ACPI_USE_SYSTEM_CLIBRARY - Define this if linking to an actual C library.
+ *      Otherwise, local versions of string/memory functions will be used.
+ * 2) ACPI_USE_STANDARD_HEADERS - Define this if linking to a C library and
+ *      the standard header files may be used.
+ *
+ * The ACPI subsystem only uses low level C library functions that do not call
+ * operating system services and may therefore be inlined in the code.
+ *
+ * It may be necessary to tailor these include files to the target
+ * generation environment.
+ *
+ *
+ * Functions and constants used from each header:
+ *
+ * string.h:    memcpy
+ *              memset
+ *              strcat
+ *              strcmp
+ *              strcpy
+ *              strlen
+ *              strncmp
+ *              strncat
+ *              strncpy
+ *
+ * stdlib.h:    strtoul
+ *
+ * stdarg.h:    va_list
+ *              va_arg
+ *              va_start
+ *              va_end
+ *
+ */
+
+/*! [Begin] no source code translation */
+
+#if defined(__linux__)
+#include "aclinux.h"
+
+#elif defined(_AED_EFI)
+#include "acefi.h"
+
+#elif defined(WIN32)
+#include "acwin.h"
+
+#elif defined(WIN64)
+#include "acwin64.h"
+
+#elif defined(MSDOS)        /* Must appear after WIN32 and WIN64 check */
+#include "acdos16.h"
+
+#elif defined(__FreeBSD__)
+#include "acfreebsd.h"
+
+#elif defined(MODESTO)
+#include "acmodesto.h"
+
+#elif defined(NETWARE)
+#include "acnetware.h"
+
+#else
+
+/* All other environments */
+
+#define ACPI_USE_STANDARD_HEADERS
+
+#define COMPILER_DEPENDENT_INT64   long long
+#define COMPILER_DEPENDENT_UINT64  unsigned long long
+
+
+/* Name of host operating system (returned by the _OS_ namespace object) */
+
+#define ACPI_OS_NAME         "Intel ACPI/CA Core Subsystem"
+
+/* This macro is used to tag functions as "printf-like" because
+ * some compilers can catch printf format string problems. MSVC
+ * doesn't, so this is proprocessed away.
+ */
+#define ACPI_PRINTF_LIKE_FUNC
+
+#endif
+
+/*
+ * Memory allocation tracking.  Used only if
+ * 1) This is the debug version
+ * 2) This is NOT a 16-bit version of the code (not enough real-mode memory)
+ */
+#ifdef ACPI_DEBUG_OUTPUT
+#if ACPI_MACHINE_WIDTH != 16
+#define ACPI_DBG_TRACK_ALLOCATIONS
+#endif
+#endif
+
+/*! [End] no source code translation !*/
+
+
+/*
+ * Debugger threading model
+ * Use single threaded if the entire subsystem is contained in an application
+ * Use multiple threaded when the subsystem is running in the kernel.
+ *
+ * By default the model is single threaded if ACPI_APPLICATION is set,
+ * multi-threaded if ACPI_APPLICATION is not set.
+ */
+#define DEBUGGER_SINGLE_THREADED    0
+#define DEBUGGER_MULTI_THREADED     1
+
+#ifdef ACPI_APPLICATION
+#define DEBUGGER_THREADING          DEBUGGER_SINGLE_THREADED
+
+#else
+#define DEBUGGER_THREADING          DEBUGGER_MULTI_THREADED
+#endif
+
+
+/******************************************************************************
+ *
+ * C library configuration
+ *
+ *****************************************************************************/
+
+#ifdef ACPI_USE_SYSTEM_CLIBRARY
+/*
+ * Use the standard C library headers.
+ * We want to keep these to a minimum.
+ */
+
+#ifdef ACPI_USE_STANDARD_HEADERS
+/*
+ * Use the standard headers from the standard locations
+ */
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+#endif /* ACPI_USE_STANDARD_HEADERS */
+
+/*
+ * We will be linking to the standard Clib functions
+ */
+
+#define ACPI_STRSTR(s1,s2)      strstr((s1), (s2))
+#define ACPI_STRUPR(s)          (void) acpi_ut_strupr ((s))
+#define ACPI_STRLEN(s)          (acpi_size) strlen((s))
+#define ACPI_STRCPY(d,s)        (void) strcpy((d), (s))
+#define ACPI_STRNCPY(d,s,n)     (void) strncpy((d), (s), (acpi_size)(n))
+#define ACPI_STRNCMP(d,s,n)     strncmp((d), (s), (acpi_size)(n))
+#define ACPI_STRCMP(d,s)        strcmp((d), (s))
+#define ACPI_STRCAT(d,s)        (void) strcat((d), (s))
+#define ACPI_STRNCAT(d,s,n)     strncat((d), (s), (acpi_size)(n))
+#define ACPI_STRTOUL(d,s,n)     strtoul((d), (s), (acpi_size)(n))
+#define ACPI_MEMCPY(d,s,n)      (void) memcpy((d), (s), (acpi_size)(n))
+#define ACPI_MEMSET(d,s,n)      (void) memset((d), (s), (acpi_size)(n))
+
+#define ACPI_TOUPPER            toupper
+#define ACPI_TOLOWER            tolower
+#define ACPI_IS_XDIGIT          isxdigit
+#define ACPI_IS_DIGIT           isdigit
+#define ACPI_IS_SPACE           isspace
+#define ACPI_IS_UPPER           isupper
+#define ACPI_IS_PRINT           isprint
+#define ACPI_IS_ALPHA           isalpha
+#define ACPI_IS_ASCII           isascii
+
+/******************************************************************************
+ *
+ * Not using native C library, use local implementations
+ *
+ *****************************************************************************/
+#else
+
+/*
+ * Use local definitions of C library macros and functions
+ * NOTE: The function implementations may not be as efficient
+ * as an inline or assembly code implementation provided by a
+ * native C library.
+ */
+
+#ifndef va_arg
+
+#ifndef _VALIST
+#define _VALIST
+typedef char *va_list;
+#endif /* _VALIST */
+
+/*
+ * Storage alignment properties
+ */
+
+#define  _AUPBND                (sizeof (acpi_native_int) - 1)
+#define  _ADNBND                (sizeof (acpi_native_int) - 1)
+
+/*
+ * Variable argument list macro definitions
+ */
+
+#define _bnd(X, bnd)            (((sizeof (X)) + (bnd)) & (~(bnd)))
+#define va_arg(ap, T)           (*(T *)(((ap) += (_bnd (T, _AUPBND))) - (_bnd (T,_ADNBND))))
+#define va_end(ap)              (void) 0
+#define va_start(ap, A)         (void) ((ap) = (((char *) &(A)) + (_bnd (A,_AUPBND))))
+
+#endif /* va_arg */
+
+
+#define ACPI_STRSTR(s1,s2)      acpi_ut_strstr ((s1), (s2))
+#define ACPI_STRUPR(s)          (void) acpi_ut_strupr ((s))
+#define ACPI_STRLEN(s)          (acpi_size) acpi_ut_strlen ((s))
+#define ACPI_STRCPY(d,s)        (void) acpi_ut_strcpy ((d), (s))
+#define ACPI_STRNCPY(d,s,n)     (void) acpi_ut_strncpy ((d), (s), (acpi_size)(n))
+#define ACPI_STRNCMP(d,s,n)     acpi_ut_strncmp ((d), (s), (acpi_size)(n))
+#define ACPI_STRCMP(d,s)        acpi_ut_strcmp ((d), (s))
+#define ACPI_STRCAT(d,s)        (void) acpi_ut_strcat ((d), (s))
+#define ACPI_STRNCAT(d,s,n)     acpi_ut_strncat ((d), (s), (acpi_size)(n))
+#define ACPI_STRTOUL(d,s,n)     acpi_ut_strtoul ((d), (s), (acpi_size)(n))
+#define ACPI_MEMCPY(d,s,n)      (void) acpi_ut_memcpy ((d), (s), (acpi_size)(n))
+#define ACPI_MEMSET(d,v,n)      (void) acpi_ut_memset ((d), (v), (acpi_size)(n))
+#define ACPI_TOUPPER            acpi_ut_to_upper
+#define ACPI_TOLOWER            acpi_ut_to_lower
+
+#endif /* ACPI_USE_SYSTEM_CLIBRARY */
+
+
+/******************************************************************************
+ *
+ * Assembly code macros
+ *
+ *****************************************************************************/
+
+/*
+ * Handle platform- and compiler-specific assembly language differences.
+ * These should already have been defined by the platform includes above.
+ *
+ * Notes:
+ * 1) Interrupt 3 is used to break into a debugger
+ * 2) Interrupts are turned off during ACPI register setup
+ */
+
+/* Unrecognized compiler, use defaults */
+
+#ifndef ACPI_ASM_MACROS
+
+/*
+ * Calling conventions:
+ *
+ * ACPI_SYSTEM_XFACE        - Interfaces to host OS (handlers, threads)
+ * ACPI_EXTERNAL_XFACE      - External ACPI interfaces
+ * ACPI_INTERNAL_XFACE      - Internal ACPI interfaces
+ * ACPI_INTERNAL_VAR_XFACE  - Internal variable-parameter list interfaces
+ */
+#define ACPI_SYSTEM_XFACE
+#define ACPI_EXTERNAL_XFACE
+#define ACPI_INTERNAL_XFACE
+#define ACPI_INTERNAL_VAR_XFACE
+
+#define ACPI_ASM_MACROS
+#define BREAKPOINT3
+#define ACPI_DISABLE_IRQS()
+#define ACPI_ENABLE_IRQS()
+#define ACPI_ACQUIRE_GLOBAL_LOCK(Glptr, acq)
+#define ACPI_RELEASE_GLOBAL_LOCK(Glptr, acq)
+
+#endif /* ACPI_ASM_MACROS */
+
+
+#ifdef ACPI_APPLICATION
+
+/* Don't want software interrupts within a ring3 application */
+
+#undef BREAKPOINT3
+#define BREAKPOINT3
+#endif
+
+
+/******************************************************************************
+ *
+ * Compiler-specific information is contained in the compiler-specific
+ * headers.
+ *
+ *****************************************************************************/
+#endif /* __ACENV_H__ */
diff -urNp linux-5400/include/acpi/platform/acgcc.h linux-5410/include/acpi/platform/acgcc.h
--- linux-5400/include/acpi/platform/acgcc.h
+++ linux-5410/include/acpi/platform/acgcc.h
@@ -0,0 +1,59 @@
+/******************************************************************************
+ *
+ * Name: acgcc.h - GCC specific defines, etc.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACGCC_H__
+#define __ACGCC_H__
+
+/* This macro is used to tag functions as "printf-like" because
+ * some compilers (like GCC) can catch printf format string problems.
+ */
+#define ACPI_PRINTF_LIKE_FUNC __attribute__ ((__format__ (__printf__, 4, 5)))
+
+/* Some compilers complain about unused variables. Sometimes we don't want to
+ * use all the variables (most specifically for _THIS_MODULE). This allow us
+ * to to tell the compiler warning in a per-variable manner that a variable
+ * is unused.
+ */
+#define ACPI_UNUSED_VAR __attribute__ ((unused))
+
+#endif /* __ACGCC_H__ */
diff -urNp linux-5400/include/acpi/platform/aclinux.h linux-5410/include/acpi/platform/aclinux.h
--- linux-5400/include/acpi/platform/aclinux.h
+++ linux-5410/include/acpi/platform/aclinux.h
@@ -0,0 +1,92 @@
+/******************************************************************************
+ *
+ * Name: aclinux.h - OS specific defines, etc.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2003, R. Byron Moore
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACLINUX_H__
+#define __ACLINUX_H__
+
+#define ACPI_OS_NAME                "Linux"
+
+#define ACPI_USE_SYSTEM_CLIBRARY
+#define ACPI_USE_DO_WHILE_0
+
+#ifdef __KERNEL__
+
+#include <linux/config.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/ctype.h>
+#include <asm/system.h>
+#include <asm/atomic.h>
+#include <asm/div64.h>
+#include <asm/acpi.h>
+
+#define strtoul simple_strtoul
+
+#define ACPI_MACHINE_WIDTH  BITS_PER_LONG
+
+#else /* !__KERNEL__ */
+
+#include <stdarg.h>
+#include <string.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <unistd.h>
+
+#if defined(__ia64__) || defined(__x86_64__)
+#define ACPI_MACHINE_WIDTH          64
+#define COMPILER_DEPENDENT_INT64    long
+#define COMPILER_DEPENDENT_UINT64   unsigned long
+#else
+#define ACPI_MACHINE_WIDTH          32
+#define COMPILER_DEPENDENT_INT64    long long
+#define COMPILER_DEPENDENT_UINT64   unsigned long long
+#define ACPI_USE_NATIVE_DIVIDE
+#endif
+
+#endif /* __KERNEL__ */
+
+/* Linux uses GCC */
+
+#include "acgcc.h"
+
+#endif /* __ACLINUX_H__ */
diff -urNp linux-5400/include/linux/acpi.h linux-5410/include/linux/acpi.h
--- linux-5400/include/linux/acpi.h
+++ linux-5410/include/linux/acpi.h
@@ -1,180 +1,423 @@
 /*
- *  acpi.h - ACPI driver interface
+ * acpi.h - ACPI Interface
  *
- *  Copyright (C) 1999 Andrew Henroid
+ * Copyright (C) 2001 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 
 #ifndef _LINUX_ACPI_H
 #define _LINUX_ACPI_H
 
-#include <linux/types.h>
-#include <linux/ioctl.h>
-#ifdef __KERNEL__
-#include <linux/sched.h>
-#include <linux/wait.h>
-#endif /* __KERNEL__ */
+#ifndef _LINUX
+#define _LINUX
+#endif
 
-/*
- * Device states
- */
-typedef enum {
-	ACPI_D0, /* fully-on */
-	ACPI_D1, /* partial-on */
-	ACPI_D2, /* partial-on */
-	ACPI_D3, /* fully-off */
-} acpi_dstate_t;
-
-typedef enum {
-	ACPI_S0, /* working state */
-	ACPI_S1, /* power-on suspend */
-	ACPI_S2, /* suspend to ram, with devices */
-	ACPI_S3, /* suspend to ram */
-	ACPI_S4, /* suspend to disk */
-	ACPI_S5, /* soft-off */
-} acpi_sstate_t;
-
-/* RSDP location */
-#define ACPI_BIOS_ROM_BASE (0x0e0000)
-#define ACPI_BIOS_ROM_END  (0x100000)
-
-/* Table signatures */
-#define ACPI_RSDP1_SIG 0x20445352 /* 'RSD ' */
-#define ACPI_RSDP2_SIG 0x20525450 /* 'PTR ' */
-#define ACPI_RSDT_SIG  0x54445352 /* 'RSDT' */
-#define ACPI_FADT_SIG  0x50434146 /* 'FACP' */
-#define ACPI_DSDT_SIG  0x54445344 /* 'DSDT' */
-#define ACPI_FACS_SIG  0x53434146 /* 'FACS' */
-
-#define ACPI_SIG_LEN		4
-#define ACPI_FADT_SIGNATURE	"FACP"
-
-/* PM1_STS/EN flags */
-#define ACPI_TMR    0x0001
-#define ACPI_BM	    0x0010
-#define ACPI_GBL    0x0020
-#define ACPI_PWRBTN 0x0100
-#define ACPI_SLPBTN 0x0200
-#define ACPI_RTC    0x0400
-#define ACPI_WAK    0x8000
-
-/* PM1_CNT flags */
-#define ACPI_SCI_EN   0x0001
-#define ACPI_BM_RLD   0x0002
-#define ACPI_GBL_RLS  0x0004
-#define ACPI_SLP_TYP0 0x0400
-#define ACPI_SLP_TYP1 0x0800
-#define ACPI_SLP_TYP2 0x1000
-#define ACPI_SLP_EN   0x2000
-
-#define ACPI_SLP_TYP_MASK  0x1c00
-#define ACPI_SLP_TYP_SHIFT 10
-
-/* PM_TMR masks */
-#define ACPI_TMR_VAL_EXT 0x00000100
-#define ACPI_TMR_MASK	 0x00ffffff
-#define ACPI_TMR_HZ	 3579545 /* 3.58 MHz */
-#define ACPI_TMR_KHZ	 (ACPI_TMR_HZ / 1000)
-
-#define ACPI_MICROSEC_TO_TMR_TICKS(val) \
-  (((val) * (ACPI_TMR_KHZ)) / 1000)
-
-/* PM2_CNT flags */
-#define ACPI_ARB_DIS 0x01
-
-/* FADT flags */
-#define ACPI_WBINVD	  0x00000001
-#define ACPI_WBINVD_FLUSH 0x00000002
-#define ACPI_PROC_C1	  0x00000004
-#define ACPI_P_LVL2_UP	  0x00000008
-#define ACPI_PWR_BUTTON	  0x00000010
-#define ACPI_SLP_BUTTON	  0x00000020
-#define ACPI_FIX_RTC	  0x00000040
-#define ACPI_RTC_64	  0x00000080
-#define ACPI_TMR_VAL_EXT  0x00000100
-#define ACPI_DCK_CAP	  0x00000200
-
-/* FADT BOOT_ARCH flags */
-#define FADT_BOOT_ARCH_LEGACY_DEVICES	0x0001
-#define FADT_BOOT_ARCH_KBD_CONTROLLER	0x0002
-
-/* FACS flags */
-#define ACPI_S4BIOS	  0x00000001
-
-/* processor block offsets */
-#define ACPI_P_CNT	  0x00000000
-#define ACPI_P_LVL2	  0x00000004
-#define ACPI_P_LVL3	  0x00000005
-
-/* C-state latencies (microseconds) */
-#define ACPI_MAX_P_LVL2_LAT 100
-#define ACPI_MAX_P_LVL3_LAT 1000
-#define ACPI_INFINITE_LAT   (~0UL)
+#include <linux/list.h>
+
+#include <acpi/acpi.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+#include <asm/acpi.h>
+
+
+#ifdef CONFIG_ACPI_BOOT
+
+enum acpi_irq_model_id {
+	ACPI_IRQ_MODEL_PIC = 0,
+	ACPI_IRQ_MODEL_IOAPIC,
+	ACPI_IRQ_MODEL_IOSAPIC,
+	ACPI_IRQ_MODEL_COUNT
+};
+
+extern enum acpi_irq_model_id	acpi_irq_model;
+
+
+/* Root System Description Pointer (RSDP) */
+
+struct acpi_table_rsdp {
+	char			signature[8];
+	u8			checksum;
+	char			oem_id[6];
+	u8			revision;
+	u32			rsdt_address;
+} __attribute__ ((packed));
+
+struct acpi20_table_rsdp {
+	char			signature[8];
+	u8			checksum;
+	char			oem_id[6];
+	u8			revision;
+	u32			rsdt_address;
+	u32			length;
+	u64			xsdt_address;
+	u8			ext_checksum;
+	u8			reserved[3];
+} __attribute__ ((packed));
+
+typedef struct {
+	u8			type;
+	u8			length;
+} __attribute__ ((packed)) acpi_table_entry_header;
+
+/* Root System Description Table (RSDT) */
+
+struct acpi_table_rsdt {
+	struct acpi_table_header header;
+	u32			entry[1];
+} __attribute__ ((packed));
+
+/* Extended System Description Table (XSDT) */
+
+struct acpi_table_xsdt {
+	struct acpi_table_header header;
+	u64			entry[1];
+} __attribute__ ((packed));
+
+/* Fixed ACPI Description Table (FADT) */
+
+struct acpi_table_fadt {
+	struct acpi_table_header header;
+	u32 facs_addr;
+	u32 dsdt_addr;
+	/* ... */
+} __attribute__ ((packed));
+
+/* Multiple APIC Description Table (MADT) */
+
+struct acpi_table_madt {
+	struct acpi_table_header header;
+	u32			lapic_address;
+	struct {
+		u32			pcat_compat:1;
+		u32			reserved:31;
+	}			flags;
+} __attribute__ ((packed));
+
+enum acpi_madt_entry_id {
+	ACPI_MADT_LAPIC = 0,
+	ACPI_MADT_IOAPIC,
+	ACPI_MADT_INT_SRC_OVR,
+	ACPI_MADT_NMI_SRC,
+	ACPI_MADT_LAPIC_NMI,
+	ACPI_MADT_LAPIC_ADDR_OVR,
+	ACPI_MADT_IOSAPIC,
+	ACPI_MADT_LSAPIC,
+	ACPI_MADT_PLAT_INT_SRC,
+	ACPI_MADT_ENTRY_COUNT
+};
+
+typedef struct {
+	u16			polarity:2;
+	u16			trigger:2;
+	u16			reserved:12;
+} __attribute__ ((packed)) acpi_interrupt_flags;
+
+struct acpi_table_lapic {
+	acpi_table_entry_header	header;
+	u8			acpi_id;
+	u8			id;
+	struct {
+		u32			enabled:1;
+		u32			reserved:31;
+	}			flags;
+} __attribute__ ((packed));
+
+struct acpi_table_ioapic {
+	acpi_table_entry_header	header;
+	u8			id;
+	u8			reserved;
+	u32			address;
+	u32			global_irq_base;
+} __attribute__ ((packed));
+
+struct acpi_table_int_src_ovr {
+	acpi_table_entry_header	header;
+	u8			bus;
+	u8			bus_irq;
+	u32			global_irq;
+	acpi_interrupt_flags	flags;
+} __attribute__ ((packed));
+
+struct acpi_table_nmi_src {
+	acpi_table_entry_header	header;
+	acpi_interrupt_flags	flags;
+	u32			global_irq;
+} __attribute__ ((packed));
+
+struct acpi_table_lapic_nmi {
+	acpi_table_entry_header	header;
+	u8			acpi_id;
+	acpi_interrupt_flags	flags;
+	u8			lint;
+} __attribute__ ((packed));
+
+struct acpi_table_lapic_addr_ovr {
+	acpi_table_entry_header	header;
+	u8			reserved[2];
+	u64			address;
+} __attribute__ ((packed));
+
+struct acpi_table_iosapic {
+	acpi_table_entry_header	header;
+	u8			id;
+	u8			reserved;
+	u32			global_irq_base;
+	u64			address;
+} __attribute__ ((packed));
+
+struct acpi_table_lsapic {
+	acpi_table_entry_header	header;
+	u8			acpi_id;
+	u8			id;
+	u8			eid;
+	u8			reserved[3];
+	struct {
+		u32			enabled:1;
+		u32			reserved:31;
+	}			flags;
+} __attribute__ ((packed));
+
+struct acpi_table_plat_int_src {
+	acpi_table_entry_header	header;
+	acpi_interrupt_flags	flags;
+	u8			type;	/* See acpi_interrupt_type */
+	u8			id;
+	u8			eid;
+	u8			iosapic_vector;
+	u32			global_irq;
+	u32			reserved;
+} __attribute__ ((packed));
+
+enum acpi_interrupt_id {
+	ACPI_INTERRUPT_PMI	= 1,
+	ACPI_INTERRUPT_INIT,
+	ACPI_INTERRUPT_CPEI,
+	ACPI_INTERRUPT_COUNT
+};
+
+#define	ACPI_SPACE_MEM		0
+
+struct acpi_gen_regaddr {
+	u8  space_id;
+	u8  bit_width;
+	u8  bit_offset;
+	u8  resv;
+	u32 addrl;
+	u32 addrh;
+} __attribute__ ((packed));
+
+struct acpi_table_hpet {
+	struct acpi_table_header header;
+	u32 id;
+	struct acpi_gen_regaddr addr;
+	u8 number;
+	u16 min_tick;
+	u8 page_protect;
+} __attribute__ ((packed));
 
 /*
- * Sysctl declarations
+ * System Resource Affinity Table (SRAT)
+ *   see http://www.microsoft.com/hwdev/design/srat.htm
  */
 
-enum
-{
-	CTL_ACPI = 10
+struct acpi_table_srat {
+	struct acpi_table_header header;
+	u32			table_revision;
+	u64			reserved;
+} __attribute__ ((packed));
+
+enum acpi_srat_entry_id {
+	ACPI_SRAT_PROCESSOR_AFFINITY = 0,
+	ACPI_SRAT_MEMORY_AFFINITY,
+	ACPI_SRAT_ENTRY_COUNT
 };
 
-enum
-{
-	ACPI_FADT = 1,
+struct acpi_table_processor_affinity {
+	acpi_table_entry_header	header;
+	u8			proximity_domain;
+	u8			apic_id;
+	struct {
+		u32			enabled:1;
+		u32			reserved:31;
+	}			flags;
+	u8			lsapic_eid;
+	u8			reserved[7];
+} __attribute__ ((packed));
+
+struct acpi_table_memory_affinity {
+	acpi_table_entry_header	header;
+	u8			proximity_domain;
+	u8			reserved1[5];
+	u32			base_addr_lo;
+	u32			base_addr_hi;
+	u32			length_lo;
+	u32			length_hi;
+	u32			memory_type;	/* See acpi_address_range_id */
+	struct {
+		u32			enabled:1;
+		u32			hot_pluggable:1;
+		u32			reserved:30;
+	}			flags;
+	u64			reserved2;
+} __attribute__ ((packed));
+
+enum acpi_address_range_id {
+	ACPI_ADDRESS_RANGE_MEMORY = 1,
+	ACPI_ADDRESS_RANGE_RESERVED = 2,
+	ACPI_ADDRESS_RANGE_ACPI = 3,
+	ACPI_ADDRESS_RANGE_NVS	= 4,
+	ACPI_ADDRESS_RANGE_COUNT
+};
+
+/*
+ * System Locality Information Table (SLIT)
+ *   see http://devresource.hp.com/devresource/docs/techpapers/ia64/slit.pdf
+ */
+
+struct acpi_table_slit {
+	struct acpi_table_header header;
+	u64			localities;
+	u8			entry[1];	/* real size = localities^2 */
+} __attribute__ ((packed));
+
+/* Smart Battery Description Table (SBST) */
+
+struct acpi_table_sbst {
+	struct acpi_table_header header;
+	u32			warning;	/* Warn user */
+	u32			low;		/* Critical sleep */
+	u32			critical;	/* Critical shutdown */
+} __attribute__ ((packed));
+
+/* Embedded Controller Boot Resources Table (ECDT) */
+
+struct acpi_table_ecdt {
+	struct acpi_table_header	header;
+	struct acpi_generic_address	ec_control;
+	struct acpi_generic_address	ec_data;
+	u32				uid;
+	u8				gpe_bit;
+	char				ec_id[0];
+} __attribute__ ((packed));
+
+/* Table Handlers */
+
+enum acpi_table_id {
+	ACPI_TABLE_UNKNOWN = 0,
+	ACPI_APIC,
+	ACPI_BOOT,
+	ACPI_DBGP,
 	ACPI_DSDT,
-	ACPI_PM1_ENABLE,
-	ACPI_GPE_ENABLE,
-	ACPI_GPE_LEVEL,
-	ACPI_EVENT,
-	ACPI_P_BLK,
-	ACPI_ENTER_LVL2_LAT,
-	ACPI_ENTER_LVL3_LAT,
-	ACPI_P_LVL2_LAT,
-	ACPI_P_LVL3_LAT,
-	ACPI_C1_TIME,
-	ACPI_C2_TIME,
-	ACPI_C3_TIME,
-	ACPI_C1_COUNT,
-	ACPI_C2_COUNT,
-	ACPI_C3_COUNT,
-	ACPI_S0_SLP_TYP,
-	ACPI_S1_SLP_TYP,
-	ACPI_S5_SLP_TYP,
-	ACPI_SLEEP,
+	ACPI_ECDT,
+	ACPI_ETDT,
+	ACPI_FADT,
 	ACPI_FACS,
-	ACPI_XSDT,
-	ACPI_PMTIMER,
-	ACPI_BATT,
+	ACPI_OEMX,
+	ACPI_PSDT,
+	ACPI_SBST,
+	ACPI_SLIT,
+	ACPI_SPCR,
+	ACPI_SRAT,
+	ACPI_SSDT,
+	ACPI_SPMI,
+	ACPI_HPET,
+	ACPI_TABLE_COUNT
 };
 
-#define ACPI_SLP_TYP_DISABLED	(~0UL)
+typedef int (*acpi_table_handler) (unsigned long phys_addr, unsigned long size);
 
-#ifdef __KERNEL__
+extern acpi_table_handler acpi_table_ops[ACPI_TABLE_COUNT];
+
+typedef int (*acpi_madt_entry_handler) (acpi_table_entry_header *header);
+
+char * __acpi_map_table (unsigned long phys_addr, unsigned long size);
+unsigned long acpi_find_rsdp (void);
+int acpi_boot_init (char * cmdline);
+int acpi_numa_init (void);
+
+int acpi_table_init (void);
+int acpi_table_parse (enum acpi_table_id id, acpi_table_handler handler);
+int acpi_get_table_header_early (enum acpi_table_id id, struct acpi_table_header **header);
+int acpi_table_parse_madt (enum acpi_madt_entry_id id, acpi_madt_entry_handler handler);
+int acpi_table_parse_srat (enum acpi_srat_entry_id id, acpi_madt_entry_handler handler);
+void acpi_table_print (struct acpi_table_header *header, unsigned long phys_addr);
+void acpi_table_print_madt_entry (acpi_table_entry_header *madt);
+void acpi_table_print_srat_entry (acpi_table_entry_header *srat);
+
+/* the following four functions are architecture-dependent */
+void acpi_numa_slit_init (struct acpi_table_slit *slit);
+void acpi_numa_processor_affinity_init (struct acpi_table_processor_affinity *pa);
+void acpi_numa_memory_affinity_init (struct acpi_table_memory_affinity *ma);
+void acpi_numa_arch_fixup(void);
+
+#endif /*CONFIG_ACPI_BOOT*/
+
+
+#ifdef CONFIG_ACPI_PCI
+
+struct acpi_prt_entry {
+	struct list_head	node;
+	struct acpi_pci_id	id;
+	u8			pin;
+	struct {
+		acpi_handle		handle;
+		u32			index;
+	}			link;
+	u32			irq;
+};
+
+struct acpi_prt_list {
+	int			count;
+	struct list_head	entries;
+};
 
-/* routines for saving/restoring kernel state */
-FASTCALL(extern unsigned long acpi_save_state_mem(unsigned long return_point));
-FASTCALL(extern int acpi_save_state_disk(unsigned long return_point));
-extern void acpi_restore_state(void);
+extern struct acpi_prt_list	acpi_prt;
 
-extern unsigned long acpi_wakeup_address;
+struct pci_dev;
 
-#endif /* __KERNEL__ */
+int acpi_pci_irq_enable (struct pci_dev *dev);
+int acpi_pci_irq_init (void);
+
+struct acpi_pci_driver {
+	struct acpi_pci_driver *next;
+	int (*add)(acpi_handle handle);
+	void (*remove)(acpi_handle handle);
+};
+
+int acpi_pci_register_driver(struct acpi_pci_driver *driver);
+void acpi_pci_unregister_driver(struct acpi_pci_driver *driver);
+
+#endif /*CONFIG_ACPI_PCI*/
+
+#ifdef CONFIG_ACPI_EC
+
+int ec_read(u8 addr, u8 *val);
+int ec_write(u8 addr, u8 val);
+
+#endif /*CONFIG_ACPI_EC*/
+
+#ifdef CONFIG_ACPI
 
 int acpi_init(void);
+int acpi_blacklisted(void);
+
+#endif /*CONFIG_ACPI*/
 
-#endif /* _LINUX_ACPI_H */
+#endif /*_LINUX_ACPI_H*/
diff -urNp linux-5400/init/main.c linux-5410/init/main.c
--- linux-5400/init/main.c
+++ linux-5410/init/main.c
@@ -37,6 +37,10 @@
 #include <asm/ccwcache.h>
 #endif
 
+#ifdef CONFIG_ACPI
+#include <linux/acpi.h>
+#endif
+
 #ifdef CONFIG_PCI
 #include <linux/pci.h>
 #endif
@@ -492,7 +496,9 @@ static void __init do_basic_setup(void)
 #if defined(CONFIG_ARCH_S390)
 	s390_init_machine_check();
 #endif
-
+#ifdef CONFIG_ACPI_INTERPRETER
+	acpi_init();
+#endif
 #ifdef CONFIG_PCI
 	pci_init();
 #endif
