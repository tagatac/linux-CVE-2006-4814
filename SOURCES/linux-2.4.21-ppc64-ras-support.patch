diff -urNp linux-359/arch/ppc64/kernel/chrp_setup.c linux-360/arch/ppc64/kernel/chrp_setup.c
--- linux-359/arch/ppc64/kernel/chrp_setup.c
+++ linux-360/arch/ppc64/kernel/chrp_setup.c
@@ -91,9 +91,10 @@ extern void iSeries_pcibios_fixup(void);
 extern void pSeries_get_rtc_time(struct rtc_time *rtc_time);
 extern int  pSeries_set_rtc_time(struct rtc_time *rtc_time);
 void pSeries_calibrate_decr(void);
-static void fwnmi_init(void);
+static void machine_check_init(void);
 extern void SystemReset_FWNMI(void), MachineCheck_FWNMI(void);	/* from head.S */
-int fwnmi_active;  /* TRUE if an FWNMI handler is present */
+int fwnmi_active = 0;  /* TRUE if an FWNMI handler is present */
+int check_exception_flag = 0;  /* TRUE if a check-exception handler present */
 
 kdev_t boot_dev;
 unsigned long  virtPython0Facilities = 0;  // python0 facility area (memory mapped io) (64-bit format) VIRTUAL address.
@@ -160,7 +161,7 @@ chrp_setup_arch(void)
 
 	printk("Boot arguments: %s\n", cmd_line);
 
-	fwnmi_init();
+	machine_check_init();
 
 #ifndef CONFIG_PPC_ISERIES
 	/* Find and initialize PCI host bridges */
@@ -202,20 +203,26 @@ chrp_init2(void)
 }
 
 /* Initialize firmware assisted non-maskable interrupts if
- * the firmware supports this feature.
- *
+ * the firmware supports this feature.  If it does not, 
+ * look for the check-exception property.
  */
-static void __init fwnmi_init(void)
+static void __init machine_check_init(void)
 {
 	long ret;
+	int check_ex_token;
 	int ibm_nmi_register = rtas_token("ibm,nmi-register");
-	if (ibm_nmi_register == RTAS_UNKNOWN_SERVICE)
-		return;
-	ret = rtas_call(ibm_nmi_register, 2, 1, NULL,
-			__pa((unsigned long)SystemReset_FWNMI),
-			__pa((unsigned long)MachineCheck_FWNMI));
-	if (ret == 0)
-		fwnmi_active = 1;
+
+	if (ibm_nmi_register != RTAS_UNKNOWN_SERVICE) {
+		ret = rtas_call(ibm_nmi_register, 2, 1, NULL,
+				__pa((unsigned long)SystemReset_FWNMI),
+				__pa((unsigned long)MachineCheck_FWNMI));
+		if (ret == 0)
+			fwnmi_active = 1;
+	} else {
+		check_ex_token = rtas_token("check-exception");
+		if (check_ex_token != RTAS_UNKNOWN_SERVICE)
+			check_exception_flag = 1;
+	}
 }
 
 
@@ -274,9 +281,11 @@ chrp_init(unsigned long r3, unsigned lon
 
  	#ifndef CONFIG_PPC_ISERIES
  		ppc_md.pcibios_fixup = pSeries_pcibios_fixup;
+		ppc_md.log_error     = pSeries_log_error;
  	#else 
  		ppc_md.pcibios_fixup = NULL;
  		// ppc_md.pcibios_fixup = iSeries_pcibios_fixup;
+		ppc_md.log_error     = NULL;
  	#endif
 
 
diff -urNp linux-359/arch/ppc64/kernel/eeh.c linux-360/arch/ppc64/kernel/eeh.c
--- linux-359/arch/ppc64/kernel/eeh.c
+++ linux-360/arch/ppc64/kernel/eeh.c
@@ -22,28 +22,78 @@
  * End Change Activity 
  */
 
+#include <linux/bootmem.h>
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/proc_fs.h>
-#include <linux/bootmem.h>
+#include <linux/rbtree.h>
+#include <asm/io.h>
+#include <asm/machdep.h>
+#include <asm/naca.h>
 #include <asm/paca.h>
 #include <asm/processor.h>
-#include <asm/naca.h>
-#include <asm/io.h>
 #include "pci.h"
 
+#undef DEBUG
+
+/** Overview:
+ *  EEH, or "Extended Error Handling" is a PCI bridge technology for
+ *  dealing with PCI bus errors that can't be dealt with within the
+ *  usual PCI framework, except by check-stopping the CPU.  Systems
+ *  that are designed for high-availability/reliability cannot afford
+ *  to crash due to a "mere" PCI error, thus the need for EEH.
+ *  An EEH-capable bridge operates by converting a detected error
+ *  into a "slot freeze", taking the PCI adapter off-line, making
+ *  the slot behave, from the OS'es point of view, as if the slot
+ *  were "empty": all reads return 0xff's and all writes are silently
+ *  ignored.  EEH slot isolation events can be triggered by parity
+ *  errors on the address or data busses (e.g. during posted writes),
+ *  which in turn might be caused by dust, vibration, humidity,
+ *  radioactivity or plain-old failed hardware.
+ *
+ *  Note, however, that one of the leading causes of EEH slot
+ *  freeze events are buggy device drivers, buggy device microcode,
+ *  or buggy device hardware.  This is because any attempt by the
+ *  device to bus-master data to a memory address that is not
+ *  assigned to the device will trigger a slot freeze.   (The idea
+ *  is to prevent devices-gone-wild from corrupting system memory).
+ *  Buggy hardware/drivers will have a miserable time co-existing
+ *  with EEH.
+ *
+ *  Ideally, a PCI device driver, when suspecting that an isolation
+ *  event has occured (e.g. by reading 0xff's), will then ask EEH
+ *  whether this is the case, and then take appropriate steps to
+ *  reset the PCI slot, the PCI device, and then resume operations.
+ *  However, until that day,  the checking is done here, with the
+ *  eeh_check_failure() routine embedded in the MMIO macros.  If
+ *  the slot is found to be isolated, an "EEH Event" is synthesized
+ *  and sent out for processing.
+ */
+
 #define BUID_HI(buid) ((buid) >> 32)
 #define BUID_LO(buid) ((buid) & 0xffffffff)
 #define CONFIG_ADDR(busno, devfn) (((((busno) & 0xff) << 8) | ((devfn) & 0xf8)) << 8)
 
 unsigned long eeh_total_mmio_ffs;
 unsigned long eeh_false_positives;
+unsigned long eeh_ignored_failures;
+unsigned long eeh_device_not_found;
+unsigned long eeh_node_not_found;
+unsigned long eeh_config_not_found;
+unsigned long eeh_no_check;
+
 /* RTAS tokens */
 static int ibm_set_eeh_option;
 static int ibm_set_slot_reset;
 static int ibm_read_slot_reset_state;
+static int ibm_slot_error_detail;
+
+/* Buffer for reporting slot-error-detail rtas calls */
+static unsigned char slot_errbuf[RTAS_ERROR_LOG_MAX];
+static spinlock_t slot_errbuf_lock = SPIN_LOCK_UNLOCKED;
+static int eeh_error_buf_size;
 
-static int eeh_implemented;
+static int eeh_subsystem_enabled;
 #define EEH_MAX_OPTS 4096
 static char *eeh_opts;
 static int eeh_opts_last;
@@ -53,6 +103,277 @@ static int eeh_check_opts_config(struct 
 				 int class_code, int vendor_id, int device_id,
 				 int default_state);
 
+/* ------------------------------------------------------------- */
+/**
+ * The pci address cache subsystem.  This subsystem places
+ * PCI device address resources into a red-black tree, sorted
+ * according to the address range, so that given only an i/o
+ * address, the corresponding PCI device can be **quickly**
+ * found. It is safe to perform an address lookup in an interrupt
+ * context; this ability is an important feature.
+ *
+ * Currently, the only customer of this code is the EEH subsystem;
+ * thus, this code has been somewhat tailored to suit EEH better.
+ * In particular, the cache does *not* hold the addresses of devices
+ * for which EEH is not enabled.
+ *
+ * (Implementation Note: The RB tree seems to be better/faster
+ * than any hash algo I could think of for this problem, even
+ * with the penalty of slow pointer chases for d-cache misses).
+ */
+struct pci_io_addr_range
+{
+	struct rb_node_s rb_node;
+	unsigned long addr_lo;
+	unsigned long addr_hi;
+	struct pci_dev *pcidev;
+	unsigned int flags;
+};
+
+static struct pci_io_addr_cache
+{
+	struct rb_root_s rb_root;
+	spinlock_t piar_lock;
+} pci_io_addr_cache_root;
+
+static inline struct pci_dev *__pci_get_device_by_addr(unsigned long addr)
+{
+	struct rb_node_s *n = pci_io_addr_cache_root.rb_root.rb_node;
+
+	while (n) {
+		struct pci_io_addr_range *piar;
+		piar = rb_entry(n, struct pci_io_addr_range, rb_node);
+
+		if (addr < piar->addr_lo) {
+			n = n->rb_left;
+		} else {
+			if (addr > piar->addr_hi) {
+				n = n->rb_right;
+			} else {
+				return piar->pcidev;
+			}
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * pci_get_device_by_addr - Get device, given only address
+ * @addr: mmio (PIO) phys address or i/o port number
+ *
+ * Given an mmio phys address, or a port number, find a pci device
+ * that implements this address.  Be sure to pci_dev_put the device
+ * when finished.  I/O port numbers are assumed to be offset
+ * from zero (that is, they do *not* have pci_io_addr added in).
+ * It is safe to call this function within an interrupt.
+ */
+static struct pci_dev *pci_get_device_by_addr(unsigned long addr)
+{
+	struct pci_dev *dev;
+	unsigned long flags;
+
+	spin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);
+	dev = __pci_get_device_by_addr(addr);
+	spin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);
+	return dev;
+}
+
+#ifdef DEBUG
+/*
+ * Handy-dandy debug print routine, does nothing more
+ * than print out the contents of our addr cache.
+ */
+static void pci_addr_cache_print(struct pci_io_addr_cache *cache)
+{
+	struct rb_node_s *n;
+	int cnt = 0;
+
+	n = rb_first(&cache->rb_root);
+	while (n) {
+		struct pci_io_addr_range *piar;
+		piar = rb_entry(n, struct pci_io_addr_range, rb_node);
+		printk(KERN_INFO "PCI: %s addr range %d [%lx-%lx]: %s %s\n",
+		       (piar->flags & IORESOURCE_IO) ? "i/o" : "mem", cnt,
+		       piar->addr_lo, piar->addr_hi, pci_name(piar->pcidev),
+		       piar->pcidev->name);
+		cnt++;
+		n = rb_next(n);
+	}
+}
+#endif
+
+/* Insert address range into the rb tree. */
+static struct pci_io_addr_range *
+pci_addr_cache_insert(struct pci_dev *dev, unsigned long alo,
+		      unsigned long ahi, unsigned int flags)
+{
+	struct rb_node_s **p = &pci_io_addr_cache_root.rb_root.rb_node;
+	struct rb_node_s *parent = NULL;
+	struct pci_io_addr_range *piar;
+
+#ifdef DEBUG
+	printk(KERN_INFO "PCI: add %s %s [%lx:%lx] to addr cache\n",
+		       pci_name(dev), dev->name, alo, ahi);
+#endif
+	/* Walk tree, find a place to insert into tree */
+	while (*p) {
+		parent = *p;
+		piar = rb_entry(parent, struct pci_io_addr_range, rb_node);
+		if (alo < piar->addr_lo) {
+			p = &parent->rb_left;
+		} else if (ahi > piar->addr_hi) {
+			p = &parent->rb_right;
+		} else {
+			if (dev != piar->pcidev ||
+			    alo != piar->addr_lo || ahi != piar->addr_hi) {
+				printk(KERN_WARNING "PIAR: overlapping address range\n");
+			}
+			return piar;
+		}
+	}
+	piar = (struct pci_io_addr_range *)kmalloc(sizeof(struct pci_io_addr_range), GFP_ATOMIC);
+	if (!piar)
+		return NULL;
+
+	piar->addr_lo = alo;
+	piar->addr_hi = ahi;
+	piar->pcidev = dev;
+	piar->flags = flags;
+
+	rb_link_node(&piar->rb_node, parent, p);
+	rb_insert_color(&piar->rb_node, &pci_io_addr_cache_root.rb_root);
+
+	return piar;
+}
+
+static void __pci_addr_cache_insert_device(struct pci_dev *dev)
+{
+	struct device_node *dn;
+	int i;
+
+	dn = pci_device_to_OF_node(dev);
+	if (!dn) {
+		printk(KERN_WARNING "PCI: no pci dn found for dev=%s\n",
+			pci_name(dev));
+		return;
+	}
+#ifdef DEBUG
+	printk(KERN_INFO "PCI: adding %s %s to address cache\n",
+		       pci_name(dev), dev->name);
+#endif
+
+	/* Skip any devices for which EEH is not enabled. */
+	if (!(dn->eeh_mode & EEH_MODE_SUPPORTED) ||
+	    dn->eeh_mode & EEH_MODE_NOCHECK) {
+#ifdef DEBUG
+		printk(KERN_INFO "PCI: skip building address cache for=%s %s\n",
+		       pci_name(dev), dev->name);
+#endif
+		return;
+	}
+
+	/* Walk resources on this device, poke them into the tree */
+	for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
+		unsigned long start = pci_resource_start(dev,i);
+		unsigned long end = pci_resource_end(dev,i);
+		unsigned int flags = pci_resource_flags(dev,i);
+
+		/* We are interested only bus addresses, not dma or other stuff */
+		if (0 == (flags & (IORESOURCE_IO | IORESOURCE_MEM)))
+			continue;
+		if (start == 0 || ~start == 0 || end == 0 || ~end == 0)
+			 continue;
+		pci_addr_cache_insert(dev, start, end, flags);
+	}
+}
+
+/**
+ * pci_addr_cache_insert_device - Add a device to the address cache
+ * @dev: PCI device whose I/O addresses we are interested in.
+ *
+ * In order to support the fast lookup of devices based on addresses,
+ * we maintain a cache of devices that can be quickly searched.
+ * This routine adds a device to that cache.
+ */
+void pci_addr_cache_insert_device(struct pci_dev *dev)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);
+	__pci_addr_cache_insert_device(dev);
+	spin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);
+}
+
+
+static inline void __pci_addr_cache_remove_device(struct pci_dev *dev)
+{
+	struct rb_node_s *n;
+
+restart:
+	n = rb_first(&pci_io_addr_cache_root.rb_root);
+	while (n) {
+		struct pci_io_addr_range *piar;
+		piar = rb_entry(n, struct pci_io_addr_range, rb_node);
+
+		if (piar->pcidev == dev) {
+			rb_erase(n, &pci_io_addr_cache_root.rb_root);
+			kfree(piar);
+			goto restart;
+		}
+		n = rb_next(n);
+	}
+}
+
+/**
+ * pci_addr_cache_remove_device - remove pci device from addr cache
+ * @dev: device to remove
+ *
+ * Remove a device from the addr-cache tree.
+ * This is potentially expensive, since it will walk
+ * the tree multiple times (once per resource).
+ * But so what; device removal doesn't need to be that fast.
+ */
+void pci_addr_cache_remove_device(struct pci_dev *dev)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);
+	__pci_addr_cache_remove_device(dev);
+	spin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);
+}
+
+/**
+ * pci_addr_cache_build - Build a cache of I/O addresses
+ *
+ * Build a cache of pci i/o addresses.  This cache will be used to
+ * find the pci device that corresponds to a given address.
+ * This routine scans all pci busses to build the cache.
+ * Must be run late in boot process, after the pci controllers
+ * have been scaned for devices (after all device resources are known).
+ */
+void __init pci_addr_cache_build(void)
+{
+	struct pci_dev *dev = NULL;
+
+	spin_lock_init(&pci_io_addr_cache_root.piar_lock);
+
+	while ((dev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
+		/* Ignore PCI bridges ( XXX why ??) */
+		if ((dev->class >> 16) == PCI_BASE_CLASS_BRIDGE) {
+			continue;
+		}
+		pci_addr_cache_insert_device(dev);
+	}
+
+#ifdef DEBUG
+	/* Verify tree built up above, echo back the list of addrs. */
+	pci_addr_cache_print(&pci_io_addr_cache_root);
+#endif
+}
+
+/* ------------------------------------------------------------- */
+
 unsigned long eeh_token_to_phys(unsigned long token)
 {
 	if (REGION_ID(token) == EEH_REGION_ID) {
@@ -64,63 +385,161 @@ unsigned long eeh_token_to_phys(unsigned
 		return token;
 }
 
-/* Check for an eeh failure at the given token address.
- * The given value has been read and it should be 1's (0xff, 0xffff or
- * 0xffffffff).
+/**
+ * eeh_panic - call panic() for an eeh event that cannot be handled.
+ * The philosophy of this routine is that it is better to panic and
+ * halt the OS than it is to risk possible data corruption by
+ * oblivious device drivers that don't know better.
  *
- * Probe to determine if an error actually occurred.  If not return val.
- * Otherwise panic.
+ * @dev pci device that had an eeh event
+ * @reset_state current reset state of the device slot
  */
-unsigned long eeh_check_failure(void *token, unsigned long val)
+static void eeh_panic(struct device_node *dn, int reset_state)
 {
-	unsigned long addr;
-	struct pci_dev *dev;
-	struct device_node *dn;
-	unsigned long ret, rets[2];
-
-	/* IO BAR access could get us here...or if we manually force EEH
-	 * operation on even if the hardware won't support it.
+	/*
+	 * XXX We should create a seperate sysctl for this.
+	 *
+	 * Since the panic_on_oops sysctl is used to halt the system
+	 * in light of potential corruption, we can use it here.
 	 */
-	if (!eeh_implemented || ibm_read_slot_reset_state == RTAS_UNKNOWN_SERVICE)
-		return val;
-
-	/* Finding the phys addr + pci device is quite expensive.
-	 * However, the RTAS call is MUCH slower.... :(
-	 */
-	addr = eeh_token_to_phys((unsigned long)token);
-	dev = pci_find_dev_by_addr(addr);
-	if (!dev) {
-		printk("EEH: no pci dev found for addr=0x%lx\n", addr);
-		return val;
+	if (panic_on_oops)
+		panic("EEH: MMIO failure (%d) on device:%s %s\n",
+		      reset_state, dn->name, dn->full_name);
+	else {
+		eeh_ignored_failures++;
+		printk(KERN_INFO "EEH: Ignored MMIO failure (%d) on device:%s %s\n",
+		      reset_state, dn->name, dn->full_name);
 	}
-	dn = pci_device_to_OF_node(dev);
+}
+
+/**
+ * eeh_dn_check_failure - check if all 1's data is due to EEH slot freeze
+ * @dn device node
+ * @dev pci device, if known
+ *
+ * Check for an EEH failure for the given device node.  Call this
+ * routine if the result of a read was all 0xff's and you want to
+ * find out if this is due to an EEH slot freeze event.  This routine
+ * will query firmware for the EEH status.
+ *
+ * Returns 0 if there has not been an EEH error; otherwise returns
+ * an error code.
+ *
+ * Note this routine is safe to call in an interrupt context.
+ */
+int eeh_dn_check_failure(struct device_node *dn, struct pci_dev *dev)
+{
+	int ret;
+	unsigned long rets[2];
+
+	eeh_total_mmio_ffs++;
+
+	if (!eeh_subsystem_enabled)
+		return 0;
+
 	if (!dn) {
-		printk("EEH: no pci dn found for addr=0x%lx\n", addr);
-		return val;
+		eeh_node_not_found++;
+		return 0;
 	}
 
 	/* Access to IO BARs might get this far and still not want checking. */
-	if (!(dn->eeh_mode & EEH_MODE_SUPPORTED) || dn->eeh_mode & EEH_MODE_NOCHECK)
-		return val;
+	if (!(dn->eeh_mode & EEH_MODE_SUPPORTED) ||
+	    dn->eeh_mode & EEH_MODE_NOCHECK) {
+		eeh_no_check++;
+		return 0;
+	}
 
+	if (!dn->eeh_config_addr) {
+		eeh_config_not_found++;
+		return 0;
+	}
 
-	/* Now test for an EEH failure.  This is VERY expensive.
+	/*
+	 * Now test for an EEH failure.  This is VERY expensive.
 	 * Note that the eeh_config_addr may be a parent device
 	 * in the case of a device behind a bridge, or it may be
 	 * function zero of a multi-function device.
 	 * In any case they must share a common PHB.
 	 */
-	if (dn->eeh_config_addr) {
-		ret = rtas_call(ibm_read_slot_reset_state, 3, 3, rets,
-				dn->eeh_config_addr, BUID_HI(dn->phb->buid), BUID_LO(dn->phb->buid));
-		if (ret == 0 && rets[1] == 1 && rets[0] >= 2) {
-			panic("EEH:  MMIO failure (%ld) on device:\n  %s %s\n",
-			      rets[0], dev->slot_name, dev->name);
-		}
+	ret = rtas_call(ibm_read_slot_reset_state, 3, 3, rets,
+			dn->eeh_config_addr, BUID_HI(dn->phb->buid),
+			BUID_LO(dn->phb->buid));
+
+	if (ret == 0 && rets[1] == 1 && rets[0] >= 2) {
+		int reset_state = rets[0];
+		unsigned long flags;
+		int rc;
+
+		spin_lock_irqsave(&slot_errbuf_lock, flags);
+		memset(slot_errbuf, 0, eeh_error_buf_size);
+
+		rc = rtas_call(ibm_slot_error_detail,
+		                      8, 1, NULL, dn->eeh_config_addr,
+		                      BUID_HI(dn->phb->buid),
+		                      BUID_LO(dn->phb->buid), NULL, 0,
+		                      virt_to_phys(slot_errbuf),
+		                      eeh_error_buf_size,
+		                      1 /* Temporary Error */);
+
+		if (rc == 0)
+			log_error(slot_errbuf, ERR_TYPE_RTAS_LOG, 0);
+		spin_unlock_irqrestore(&slot_errbuf_lock, flags);
+
+		/* Prevent repeated reports of this failure */
+		dn->eeh_mode |= EEH_MODE_NOCHECK;
+		
+		/* For non-recoverable errors, we panic now.  This
+		 * prevents the device driver from getting tangled
+		 * in its own shorts.  */
+		eeh_panic(dn, reset_state);
+		return -EIO;
+	} else {
+		eeh_false_positives++;
 	}
-	eeh_false_positives++;
-	return val;	/* good case */
 
+	return 0;
+}
+
+/**
+ * eeh_check_failure - check if all 1's data is due to EEH slot freeze
+ * @token i/o token, should be address in the form 0xA.... (or 0xE.... for
+ *        mappings set up before mem init i.e. PHB I/O space)
+ * @val value, should be all 1's (XXX why do we need this arg??)
+ *
+ * Check for an eeh failure at the given token address.
+ * Check for an EEH failure at the given token address.  Call this
+ * routine if the result of a read was all 0xff's and you want to
+ * find out if this is due to an EEH slot freeze event.  This routine
+ * will query firmware for the EEH status.
+ *
+ * Note this routine is safe to call in an interrupt context.
+ */
+unsigned long eeh_check_failure(void *token, unsigned long val)
+{
+	unsigned long addr;
+	struct pci_dev *dev;
+	struct device_node *dn;
+
+	/* If token is an I/O address, we know it was passed to us
+	 * by a port I/O function (inb, inw, or inl), so subtracting
+	 * pci_io_base gets the physical address for us.
+	 */
+	if (REGION_ID((unsigned long)token) == IO_REGION_ID)
+		addr = (unsigned long)token - pci_io_base;
+	else
+		addr = eeh_token_to_phys((unsigned long)token);
+
+	/* Finding the phys addr + pci device; this is pretty quick. */
+	dev = pci_get_device_by_addr(addr);
+	if (!dev) {
+		eeh_device_not_found++;
+		return val;
+	}
+
+	dn = pci_device_to_OF_node(dev);
+	eeh_dn_check_failure (dn, dev);
+	
+	return val;
 }
 
 struct eeh_early_enable_info {
@@ -141,18 +560,20 @@ static void *early_enable_eeh(struct dev
 	u32 *regs;
 	int enable;
 
+	dn->eeh_mode = 0;
+
 	if (status && strcmp(status, "ok") != 0)
 		return NULL;	/* ignore devices with bad status */
 
-	/* Weed out PHBs or other bad nodes. */
+	/* Ignore bad nodes. */
 	if (!class_code || !vendor_id || !device_id)
 		return NULL;
 
-	/* Ignore known PHBs and EADs bridges */
-	if (*vendor_id == PCI_VENDOR_ID_IBM &&
-	    (*device_id == 0x0102 || *device_id == 0x008b ||
-	     *device_id == 0x0188 || *device_id == 0x0302))
+	/* There is nothing to check on PCI to ISA bridges */
+	if (dn->type && !strcmp(dn->type, "isa")) {
+		dn->eeh_mode |= EEH_MODE_NOCHECK;
 		return NULL;
+	}
 
 	/* Now decide if we are going to "Disable" EEH checking
 	 * for this device.  We still run with the EEH hardware active,
@@ -173,17 +594,10 @@ static void *early_enable_eeh(struct dev
 	}
 
 	if (!enable)
-		dn->eeh_mode = EEH_MODE_NOCHECK;
+		dn->eeh_mode |= EEH_MODE_NOCHECK;
 
-	/* This device may already have an EEH parent. */
-	if (dn->parent && (dn->parent->eeh_mode & EEH_MODE_SUPPORTED)) {
-		/* Parent supports EEH. */
-		dn->eeh_mode |= EEH_MODE_SUPPORTED;
-		dn->eeh_config_addr = dn->parent->eeh_config_addr;
-		return NULL;
-	}
-
-	/* Ok..see if this device supports EEH. */
+	/* Ok..see if this device supports EEH.  Some do, some don't,
+	 * and the only way to find out is to check each and every one. */
 	regs = (u32 *)get_property(dn, "reg", 0);
 	if (regs) {
 		/* First register entry is addr (00BBSS00)  */
@@ -195,7 +609,19 @@ static void *early_enable_eeh(struct dev
 			info->adapters_enabled++;
 			dn->eeh_mode |= EEH_MODE_SUPPORTED;
 			dn->eeh_config_addr = regs[0];
+		} else {
+			/* This device doesn't support EEH, but it may have an
+			 * EEH parent, in which case we mark it as supported. */
+			if (dn->parent && (dn->parent->eeh_mode & EEH_MODE_SUPPORTED)) {
+				/* Parent supports EEH. */
+				dn->eeh_mode |= EEH_MODE_SUPPORTED;
+				dn->eeh_config_addr = dn->parent->eeh_config_addr;
+				return NULL;
+			}
 		}
+	} else {
+		printk(KERN_WARNING "EEH: %s: unable to get reg property.\n",
+		       dn->full_name);
 	}
 	return NULL; 
 }
@@ -226,47 +652,52 @@ void eeh_init(void)
 	ibm_set_eeh_option = rtas_token("ibm,set-eeh-option");
 	ibm_set_slot_reset = rtas_token("ibm,set-slot-reset");
 	ibm_read_slot_reset_state = rtas_token("ibm,read-slot-reset-state");
+	ibm_slot_error_detail = rtas_token("ibm,slot-error-detail");
+
+	eeh_error_buf_size = rtas_token("rtas-error-log-max");
+	if (eeh_error_buf_size == RTAS_UNKNOWN_SERVICE)
+		eeh_error_buf_size = RTAS_ERROR_LOG_MAX;
+	if (eeh_error_buf_size > RTAS_ERROR_LOG_MAX) {
+		printk(KERN_WARNING "EEH: rtas-error-log-max is bigger than "
+		       "allocated buffer! (%d vs %d)", eeh_error_buf_size,
+		       RTAS_ERROR_LOG_MAX);
+		eeh_error_buf_size = RTAS_ERROR_LOG_MAX;
+	}
 
 	/* Allow user to force eeh mode on or off -- even if the hardware
 	 * doesn't exist.  This allows driver writers to at least test use
 	 * of I/O macros even if we can't actually test for EEH failure.
 	 */
 	if (eeh_force_on > eeh_force_off)
-		eeh_implemented = 1;
+		eeh_subsystem_enabled = 1;
 	else if (ibm_set_eeh_option == RTAS_UNKNOWN_SERVICE)
 		return;
 
 	if (eeh_force_off > eeh_force_on) {
 		/* User is forcing EEH off.  Be noisy if it is implemented. */
-		if (eeh_implemented)
+		if (eeh_subsystem_enabled)
 			printk(KERN_WARNING "EEH: WARNING: PCI Enhanced I/O Error Handling is user disabled\n");
-		eeh_implemented = 0;
+		eeh_subsystem_enabled = 0;
 		return;
 	}
 
 
 	/* Enable EEH for all adapters.  Note that eeh requires buid's */
+	init_pci_config_tokens();
 	info.adapters_enabled = 0;
 	for (phb = find_devices("pci"); phb; phb = phb->next) {
-		int len;
-		int *buid_vals = (int *) get_property(phb, "ibm,fw-phb-id", &len);
-		if (!buid_vals)
+		unsigned long buid;
+		buid = get_phb_buid(phb);
+		if (buid == 0)
 			continue;
-		if (len == sizeof(int)) {
-			info.buid_lo = buid_vals[0];
-			info.buid_hi = 0;
-		} else if (len == sizeof(int)*2) {
-			info.buid_hi = buid_vals[0];
-			info.buid_lo = buid_vals[1];
-		} else {
-			printk("EEH: odd ibm,fw-phb-id len returned: %d\n", len);
-			continue;
-		}
+
+		info.buid_lo = BUID_LO(buid);
+		info.buid_hi = BUID_HI(buid);
 		traverse_pci_devices(phb, early_enable_eeh, NULL, &info);
 	}
 	if (info.adapters_enabled) {
 		printk(KERN_INFO "EEH: PCI Enhanced I/O Error Handling Enabled\n");
-		eeh_implemented = 1;
+		eeh_subsystem_enabled = 1;
 	}
 }
 
@@ -276,7 +707,7 @@ int eeh_set_option(struct pci_dev *dev, 
 	struct device_node *dn = pci_device_to_OF_node(dev);
 	struct pci_controller *phb = PCI_GET_PHB_PTR(dev);
 
-	if (dn == NULL || phb == NULL || phb->buid == 0 || !eeh_implemented)
+	if (dn == NULL || phb == NULL || phb->buid == 0 || !eeh_subsystem_enabled)
 		return -2;
 
 	return rtas_call(ibm_set_eeh_option, 4, 1, NULL,
@@ -295,7 +726,7 @@ void *eeh_ioremap(unsigned long addr, vo
 	struct pci_dev *dev;
 	struct device_node *dn;
 
-	if (!eeh_implemented)
+	if (!eeh_subsystem_enabled)
 		return vaddr;
 	dev = pci_find_dev_by_addr(addr);
 	if (!dev)
@@ -313,9 +744,20 @@ static int eeh_proc_falsepositive_read(c
 			 int count, int *eof, void *data)
 {
 	int len;
-	len = sprintf(page, "eeh_false_positives=%ld\n"
-		      "eeh_total_mmio_ffs=%ld\n",
-		      eeh_false_positives, eeh_total_mmio_ffs);
+	len = sprintf(page,
+		      "eeh_device_not_found=%ld\n"
+		      "eeh_node_not_found=%ld\n"
+		      "eeh_config_not_found=%ld\n"
+		      "eeh_no_check=%ld\n"
+		      "eeh_false_positives=%ld\n"
+		      "eeh_total_mmio_ffs=%ld\n"
+		      "eeh_ignored_failures=%ld\n",
+		      eeh_device_not_found,
+		      eeh_node_not_found,
+		      eeh_config_not_found,
+		      eeh_no_check,
+		      eeh_false_positives,
+		      eeh_total_mmio_ffs, eeh_ignored_failures);
 	return len;
 }
 
diff -urNp linux-359/arch/ppc64/kernel/nvram.c linux-360/arch/ppc64/kernel/nvram.c
--- linux-359/arch/ppc64/kernel/nvram.c
+++ linux-360/arch/ppc64/kernel/nvram.c
@@ -20,16 +20,40 @@
 #include <linux/fcntl.h>
 #include <linux/nvram.h>
 #include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
 #include <asm/uaccess.h>
 #include <asm/nvram.h>
 #include <asm/rtas.h>
 #include <asm/prom.h>
 
-static unsigned int rtas_nvram_size;
+#define nDEBUG_NVRAM
+
+static int scan_nvram_partitions(void);
+static int setup_nvram_partition(void);
+static int create_os_nvram_partition(void);
+static int remove_os_nvram_partition(void);
+static unsigned char nvram_checksum(struct nvram_header *p);
+static int write_nvram_header(struct nvram_partition * part);
+
+static unsigned int rtas_nvram_size = 0;
 static unsigned int nvram_fetch, nvram_store;
-static char nvram_buf[4];	/* assume this is in the first 4GB */
+static char nvram_buf[NVRW_CNT];	/* assume this is in the first 4GB */
+static struct nvram_partition * nvram_part;
+static long error_log_nvram_index = -1;
+static long error_log_nvram_size = 0;
+static spinlock_t nvram_lock = SPIN_LOCK_UNLOCKED;
+
+volatile int no_more_logging = 1; 
+
+extern volatile int error_log_cnt;
+
+struct err_log_info {
+	int error_type;
+	unsigned int seq_num;
+};
 
-static loff_t nvram_llseek(struct file *file, loff_t offset, int origin)
+static loff_t dev_ppc64_nvram_llseek(struct file *file, loff_t offset, int origin)
 {
 	switch (origin) {
 	case 1:
@@ -46,53 +70,72 @@ static loff_t nvram_llseek(struct file *
 }
 
 
-static ssize_t read_nvram(struct file *file, char *buf,
+static ssize_t dev_ppc64_read_nvram(struct file *file, char *buf,
 			  size_t count, loff_t *ppos)
 {
-	unsigned int i;
-	unsigned long len;
-	char *p = buf;
+	ssize_t len;
+	char *tmp_buffer;
 
 	if (verify_area(VERIFY_WRITE, buf, count))
 		return -EFAULT;
 	if (*ppos >= rtas_nvram_size)
 		return 0;
-	for (i = *ppos; count > 0 && i < rtas_nvram_size; ++i, ++p, --count) {
-		if ((rtas_call(nvram_fetch, 3, 2, &len, i, __pa(nvram_buf), 1) != 0) ||
-		    len != 1)
-			return -EIO;
-		if (__put_user(nvram_buf[0], p))
-			return -EFAULT;
+	if (count > rtas_nvram_size) 
+		count = rtas_nvram_size;
+
+	tmp_buffer = kmalloc(count, GFP_KERNEL);
+	if (!tmp_buffer) {
+		printk(KERN_ERR "dev_ppc64_read_nvram: kmalloc failed\n");
+		return -ENOMEM;
 	}
-	*ppos = i;
-	return p - buf;
+
+	len = read_nvram(tmp_buffer, count, ppos);
+	if (len <= 0) {
+		kfree(tmp_buffer);
+		return len;
+	}
+
+	if (copy_to_user(buf, tmp_buffer, len)) {
+		kfree(tmp_buffer);
+		return -EFAULT;
+	}
+
+	kfree(tmp_buffer);
+	return len;
+
 }
 
-static ssize_t write_nvram(struct file *file, const char *buf,
+static ssize_t dev_ppc64_write_nvram(struct file *file, const char *buf,
 			   size_t count, loff_t *ppos)
 {
-	unsigned int i;
-	unsigned long len;
-	const char *p = buf;
-	char c;
+	ssize_t len;
+	char * tmp_buffer;
 
 	if (verify_area(VERIFY_READ, buf, count))
 		return -EFAULT;
 	if (*ppos >= rtas_nvram_size)
 		return 0;
-	for (i = *ppos; count > 0 && i < rtas_nvram_size; ++i, ++p, --count) {
-		if (__get_user(c, p))
-			return -EFAULT;
-		nvram_buf[0] = c;
-		if ((rtas_call(nvram_store, 3, 2, &len, i, __pa(nvram_buf), 1) != 0) ||
-		    len != 1)
-			return -EIO;
+	if (count > rtas_nvram_size)
+		count = rtas_nvram_size;
+
+	tmp_buffer = kmalloc(count, GFP_KERNEL);
+	if (!tmp_buffer) {
+		printk(KERN_ERR "dev_ppc64_write_nvram: kmalloc failed\n");
+		return 0;
 	}
-	*ppos = i;
-	return p - buf;
+	
+	if (copy_from_user(tmp_buffer, buf, count)) {
+		kfree(tmp_buffer);
+		return -EFAULT;
+	}
+
+	len = write_nvram(tmp_buffer, count, ppos);
+
+	kfree(tmp_buffer);
+	return len;
 }
 
-static int nvram_ioctl(struct inode *inode, struct file *file,
+static int dev_ppc64_nvram_ioctl(struct inode *inode, struct file *file,
 	unsigned int cmd, unsigned long arg)
 {
 	return -EINVAL;
@@ -100,10 +143,10 @@ static int nvram_ioctl(struct inode *ino
 
 struct file_operations nvram_fops = {
 	.owner =	THIS_MODULE,
-	.llseek =	nvram_llseek,
-	.read =		read_nvram,
-	.write =	write_nvram,
-	.ioctl =	nvram_ioctl,
+	.llseek =	dev_ppc64_nvram_llseek,
+	.read =		dev_ppc64_read_nvram,
+	.write =	dev_ppc64_write_nvram,
+	.ioctl =	dev_ppc64_nvram_ioctl
 };
 
 static struct miscdevice nvram_dev = {
@@ -112,21 +155,177 @@ static struct miscdevice nvram_dev = {
 	&nvram_fops
 };
 
+ssize_t read_nvram(char *buf, size_t count, loff_t *index)
+{
+	unsigned int i;
+	unsigned long len;
+	unsigned long s;
+	unsigned long remainder;
+	char *p = buf;
+	
+	if (((*index + count) > rtas_nvram_size) || (count < 0))
+		return 0;
+
+	if (count <= NVRW_CNT) {
+		remainder = count;
+	} else {
+		remainder = count % NVRW_CNT;
+	}
+
+	spin_lock_irqsave(&nvram_lock, s);
+
+	if (remainder) {
+		if((rtas_call(nvram_fetch, 3, 2, &len, *index, __pa(nvram_buf),
+			      remainder) != 0) || len != remainder) {
+			spin_unlock_irqrestore(&nvram_lock, s);
+			return -EIO;
+		}
+	
+		count -= remainder;
+		memcpy(p, nvram_buf, remainder);
+		p += remainder;
+	}
+	
+	for (i = *index + remainder; count > 0 && i < rtas_nvram_size;
+	     count -= NVRW_CNT) {
+		if ((rtas_call(nvram_fetch, 3, 2, &len, i, __pa(nvram_buf),
+			       NVRW_CNT) != 0) || len != NVRW_CNT) {
+			spin_unlock_irqrestore(&nvram_lock, s);
+			return -EIO;
+		}
+		
+		memcpy(p, nvram_buf, NVRW_CNT);
+
+		p += NVRW_CNT;
+		i += NVRW_CNT;
+	}
+
+	spin_unlock_irqrestore(&nvram_lock, s);
+	
+	*index = i;
+	return p - buf;
+}
+
+ssize_t write_nvram(char *buf, size_t count, loff_t *index)
+{
+	unsigned int i;
+	unsigned long len;
+	unsigned long s;
+	const char *p = buf;
+	unsigned long remainder;
+
+	if (((*index + count) > rtas_nvram_size) || (count < 0))
+		return 0;
+
+	if (count <= NVRW_CNT) {
+		remainder = count;
+	} else {
+		remainder = count % NVRW_CNT;
+	}
+
+	spin_lock_irqsave(&nvram_lock, s);
+
+	if (remainder) {
+		memcpy(nvram_buf, p, remainder);
+		
+		if((rtas_call(nvram_store, 3, 2, &len, *index, __pa(nvram_buf),
+			      remainder) != 0) || len != remainder) {
+			spin_unlock_irqrestore(&nvram_lock, s);
+			return -EIO;
+		}
+	
+		count -= remainder;
+		p += remainder;
+	}
+	
+	for (i = *index + remainder; count > 0 && i < rtas_nvram_size;
+	     count -= NVRW_CNT) {
+
+		memcpy(nvram_buf, p, NVRW_CNT);
+
+		if ((rtas_call(nvram_store, 3, 2, &len, i, __pa(nvram_buf),
+			       NVRW_CNT) != 0) || len != NVRW_CNT) {
+			spin_unlock_irqrestore(&nvram_lock, s);
+			return -EIO;
+		}
+		
+		p += NVRW_CNT;
+		i += NVRW_CNT;
+	}
+	spin_unlock_irqrestore(&nvram_lock, s);
+	
+	*index = i;
+	return p - buf;
+}
+
 int __init nvram_init(void)
 {
 	struct device_node *nvram;
 	unsigned int *nbytes_p, proplen;
+	int error;
+	int rc;
+
 	if ((nvram = find_type_devices("nvram")) != NULL) {
 		nbytes_p = (unsigned int *)get_property(nvram, "#bytes", &proplen);
 		if (nbytes_p && proplen == sizeof(unsigned int)) {
 			rtas_nvram_size = *nbytes_p;
+		} else {
+			return -EIO;
 		}
-	}
+	} else {
+		/* If we don't know how big NVRAM is then we shouldn't touch
+		   the nvram partitions */
+		return -EIO;
+  	}
+		
 	nvram_fetch = rtas_token("nvram-fetch");
+	if (nvram_fetch == RTAS_UNKNOWN_SERVICE) {
+		printk("nvram_init: Does not support nvram-fetch\n");
+		return -EIO;
+	}
+	
 	nvram_store = rtas_token("nvram-store");
+	if (nvram_store == RTAS_UNKNOWN_SERVICE) {
+		printk("nvram_init: Does not support nvram-store\n");
+		return -EIO;
+	}
 	printk(KERN_INFO "PPC64 nvram contains %d bytes\n", rtas_nvram_size);
 
-	return misc_register(&nvram_dev);
+  	rc = misc_register(&nvram_dev);
+	if (rc) {
+		printk(KERN_ERR "nvram_init: Failed misc_register (%d)\n", rc);
+		/* Going to continue to setup nvram for internal
+		 * kernel services */
+	}
+	       
+  
+  	/* initialize our anchor for the nvram partition list */
+  	nvram_part = kmalloc(sizeof(struct nvram_partition), GFP_KERNEL);
+  	if (!nvram_part) {
+  		printk(KERN_ERR "nvram_init: Failed kmalloc\n");
+  		return -ENOMEM;
+  	}
+  	INIT_LIST_HEAD(&nvram_part->partition);
+  
+  	/* Get all the NVRAM partitions */
+  	error = scan_nvram_partitions();
+  	if (error) {
+  		printk(KERN_ERR "nvram_init: Failed scan_nvram_partitions\n");
+  		return error;
+  	}
+
+	error = setup_nvram_partition();
+  	if (error) {
+  		printk(KERN_WARNING "nvram_init: Could not find nvram partition"
+  		       " for nvram buffered error logging.\n");
+		return error;
+	}
+  
+#ifdef DEBUG_NVRAM
+	print_nvram_partitions("NVRAM Partitions");
+#endif
+
+  	return rc;
 }
 
 void __exit nvram_cleanup(void)
@@ -134,6 +333,428 @@ void __exit nvram_cleanup(void)
         misc_deregister( &nvram_dev );
 }
 
+static int scan_nvram_partitions(void)
+{
+	loff_t cur_index = 0;
+	struct nvram_header phead;
+	struct nvram_partition * tmp_part;
+	unsigned char c_sum;
+	long size;
+	
+	while (cur_index < rtas_nvram_size) {
+
+		size = read_nvram((char *)&phead, NVRAM_HEADER_LEN, &cur_index);
+		if (size != NVRAM_HEADER_LEN) {
+			printk(KERN_ERR "scan_nvram_partitions: Error parsing "
+			       "nvram partitions\n");
+			return size;
+		}
+
+		cur_index -= NVRAM_HEADER_LEN; /* read_nvram will advance us */
+
+		c_sum = nvram_checksum(&phead);
+		if (c_sum != phead.checksum)
+			printk(KERN_WARNING "WARNING: nvram partition checksum "
+			       "was %02x, should be %02x!\n", phead.checksum, c_sum);
+		
+		tmp_part = kmalloc(sizeof(struct nvram_partition), GFP_KERNEL);
+		if (!tmp_part) {
+			printk(KERN_ERR "scan_nvram_partitions: kmalloc failed\n");
+			return -ENOMEM;
+		}
+		
+		memcpy(&tmp_part->header, &phead, NVRAM_HEADER_LEN);
+		tmp_part->index = cur_index;
+		list_add_tail(&tmp_part->partition, &nvram_part->partition);
+		
+		cur_index += phead.length * NVRAM_BLOCK_LEN;
+	}
+
+	return 0;
+}
+
+/* setup_nvram_partition
+ *
+ * This will setup the partition we need for buffering the
+ * error logs and cleanup partitions if needed.
+ *
+ * The general strategy is the following:
+ * 1.) If there is ppc64,linux partition large enough then use it.
+ * 2.) If there is not a ppc64,linux partition large enough, search
+ * for a free partition that is large enough.
+ * 3.) If there is not a free partition large enough remove 
+ * _all_ OS partitions and consolidate the space.
+ * 4.) Will first try getting a chunk that will satisfy the maximum
+ * error log size (NVRAM_MAX_REQ).
+ * 5.) If the max chunk cannot be allocated then try finding a chunk
+ * that will satisfy the minum needed (NVRAM_MIN_REQ).
+ */
+static int setup_nvram_partition(void)
+{
+	struct list_head * p;
+	struct nvram_partition * part;
+	int rc;
+
+	/* see if we have an OS partition that meets our needs.
+	   will try getting the max we need.  If not we'll delete
+	   partitions and try again. */
+	list_for_each(p, &nvram_part->partition) {
+		part = list_entry(p, struct nvram_partition, partition);
+		if (part->header.signature != NVRAM_SIG_OS)
+			continue;
+
+		if (strcmp(part->header.name, "ppc64,linux"))
+			continue;
+
+		if (part->header.length >= NVRAM_MIN_REQ) {
+			/* found our partition */
+			error_log_nvram_index = part->index + NVRAM_HEADER_LEN;
+			error_log_nvram_size = (part->header.length * NVRAM_BLOCK_LEN) -
+						NVRAM_HEADER_LEN - sizeof(struct err_log_info);
+			return 0;
+		}
+	}
+	
+	/* try creating a partition with the free space we have */
+	rc = create_os_nvram_partition();
+	if (!rc) {
+		return 0;
+	}
+		
+	/* need to free up some space */
+	rc = remove_os_nvram_partition();
+	if (rc) {
+		return rc;
+	}
+	
+	/* create a partition in this new space */
+	rc = create_os_nvram_partition();
+	if (rc) {
+		printk(KERN_ERR "create_os_nvram_partition: Could not find a "
+		       "NVRAM partition large enough (%d)\n", rc);
+		return rc;
+	}
+	
+	return 0;
+}
+
+static int remove_os_nvram_partition(void)
+{
+	struct list_head *i;
+	struct list_head *j;
+	struct nvram_partition * part;
+	struct nvram_partition * cur_part;
+	int rc;
+
+	list_for_each(i, &nvram_part->partition) {
+		part = list_entry(i, struct nvram_partition, partition);
+		if (part->header.signature != NVRAM_SIG_OS)
+			continue;
+		
+		/* Make os partition a free partition */
+		part->header.signature = NVRAM_SIG_FREE;
+		sprintf(part->header.name, "wwwwwwwwwwww");
+		part->header.checksum = nvram_checksum(&part->header);
+
+		/* Merge contiguous free partitions backwards */
+		list_for_each_prev(j, &part->partition) {
+			cur_part = list_entry(j, struct nvram_partition, partition);
+			if (cur_part == nvram_part || cur_part->header.signature != NVRAM_SIG_FREE) {
+				break;
+			}
+			
+			part->header.length += cur_part->header.length;
+			part->header.checksum = nvram_checksum(&part->header);
+			part->index = cur_part->index;
+
+			list_del(&cur_part->partition);
+			kfree(cur_part);
+			j = &part->partition; /* fixup our loop */
+		}
+		
+		/* Merge contiguous free partitions forwards */
+		list_for_each(j, &part->partition) {
+			cur_part = list_entry(j, struct nvram_partition, partition);
+			if (cur_part == nvram_part || cur_part->header.signature != NVRAM_SIG_FREE) {
+				break;
+			}
+
+			part->header.length += cur_part->header.length;
+			part->header.checksum = nvram_checksum(&part->header);
+
+			list_del(&cur_part->partition);
+			kfree(cur_part);
+			j = &part->partition; /* fixup our loop */
+		}
+		
+		rc = write_nvram_header(part);
+		if (rc <= 0) {
+			printk(KERN_ERR "remove_os_nvram_partition: write_nvram failed (%d)\n", rc);
+			return rc;
+		}
+
+	}
+	
+	return 0;
+}
+
+/* create_os_nvram_partition
+ *
+ * Create a OS linux partition to buffer error logs.
+ * Will create a partition starting at the first free
+ * space found if space has enough room.
+ */
+static int create_os_nvram_partition(void)
+{
+	struct list_head * p;
+	struct nvram_partition * part;
+	struct nvram_partition * new_part = NULL;
+	struct nvram_partition * free_part;
+	struct err_log_info seq_init = { 0, 0 };
+	loff_t tmp_index;
+	long size = 0;
+	int rc;
+	
+	/* Find a free partition that will give us the maximum needed size 
+	   If can't find one that will give us the minimum size needed */
+	list_for_each(p, &nvram_part->partition) {
+		part = list_entry(p, struct nvram_partition, partition);
+		if (part->header.signature != NVRAM_SIG_FREE)
+			continue;
+
+		if (part->header.length >= NVRAM_MAX_REQ) {
+			size = NVRAM_MAX_REQ;
+			free_part = part;
+			break;
+		}
+		if (!size && part->header.length >= NVRAM_MIN_REQ) {
+			size = NVRAM_MIN_REQ;
+			free_part = part;
+		}
+	}
+	if (!size) {
+		return -ENOSPC;
+	}
+	
+	/* Create our OS partition */
+	new_part = kmalloc(sizeof(struct nvram_partition), GFP_KERNEL);
+	if (!new_part) {
+		printk(KERN_ERR "create_os_nvram_partition: kmalloc failed\n");
+		return -ENOMEM;
+	}
+
+	new_part->index = free_part->index;
+	new_part->header.signature = NVRAM_SIG_OS;
+	new_part->header.length = size;
+	sprintf(new_part->header.name, "ppc64,linux");
+	new_part->header.checksum = nvram_checksum(&new_part->header);
+
+	rc = write_nvram_header(new_part);
+	if (rc <= 0) {
+		printk(KERN_ERR "create_os_nvram_partition: write_nvram_header \
+				failed (%d)\n", rc);
+		kfree(new_part);
+		return rc;
+	}
+
+	/* make sure and initialize to zero the sequence number and the error
+	   type logged */
+	tmp_index = new_part->index + NVRAM_HEADER_LEN;
+	rc = write_nvram((char *)&seq_init, sizeof(seq_init), &tmp_index);
+	if (rc <= 0) {
+		printk(KERN_ERR "create_os_nvram_partition: write_nvram failed (%d)\n", rc);
+		kfree(new_part);
+		return rc;
+	}
+	
+	error_log_nvram_index = new_part->index + NVRAM_HEADER_LEN;
+	error_log_nvram_size = (new_part->header.length * NVRAM_BLOCK_LEN) -
+		NVRAM_HEADER_LEN - sizeof(struct err_log_info); 
+	
+	list_add_tail(&new_part->partition, &free_part->partition);
+
+	if (free_part->header.length <= size) {
+		list_del(&free_part->partition);
+		kfree(free_part);
+		return 0;
+	} 
+
+	/* Adjust the partition we stole the space from */
+	free_part->index += size * NVRAM_BLOCK_LEN;
+	free_part->header.length -= size;
+	free_part->header.checksum = nvram_checksum(&free_part->header);
+	
+	rc = write_nvram_header(free_part);
+	if (rc <= 0) {
+		printk(KERN_ERR "create_os_nvram_partition: write_nvram_header "
+		       "failed (%d)\n", rc);
+		error_log_nvram_index = -1;
+		error_log_nvram_size = 0;
+		return rc;
+	}
+
+	return 0;
+}
+
+
+void print_nvram_partitions(char * label)
+{
+	struct list_head * p;
+	struct nvram_partition * tmp_part;
+	
+	printk(KERN_WARNING "--------%s---------\n", label);
+	printk(KERN_WARNING "indx\t\tsig\tchks\tlen\tname\n");
+	list_for_each(p, &nvram_part->partition) {
+		tmp_part = list_entry(p, struct nvram_partition, partition);
+		printk(KERN_WARNING "%d    \t%02x\t%02x\t%d\t%s\n",
+		       tmp_part->index, tmp_part->header.signature,
+		       tmp_part->header.checksum, tmp_part->header.length,
+		       tmp_part->header.name);
+	}
+}
+
+/* write_error_log_nvram
+ * In NVRAM the partition containing the error log buffer will looks like:
+ * Header (in bytes):
+ * +-----------+----------+--------+------------+------------------+
+ * | signature | checksum | length | name       | data             |
+ * |0          |1         |2      3|4         15|16        length-1|
+ * +-----------+----------+--------+------------+------------------+
+ * NOTE: length is in NVRAM_BLOCK_LEN
+ *
+ * The 'data' section would look like (in bytes):
+ * +--------------+------------+-----------------------------------+
+ * | event_logged | sequence # | error log                         |
+ * |0            3|4          7|8            error_log_nvram_size-1|
+ * +--------------+------------+-----------------------------------+
+ *
+ * event_logged: 0 if event has not been logged to syslog, 1 if it has
+ * sequence #: The unique sequence # for each event. (until it wraps)
+ * error log: The error log from event_scan
+ */
+int write_error_log_nvram(char * buff, int num_bytes, unsigned int err_type)
+{
+	int rc;
+	loff_t tmp_index;
+	struct err_log_info info;
+	
+	if (no_more_logging) {
+		return -EPERM;
+	}
+
+	if (error_log_nvram_index == -1) {
+		return -ESPIPE;
+	}
+
+	if (num_bytes > error_log_nvram_size) {
+		num_bytes = error_log_nvram_size;
+	}
+
+	info.error_type = err_type;
+	info.seq_num = error_log_cnt;
+
+	tmp_index = error_log_nvram_index;
+
+	rc = write_nvram((char *)&info, sizeof(struct err_log_info), &tmp_index);
+	if (rc <= 0) {
+		printk(KERN_ERR "write_error_log_nvram: Failed write_nvram (%d)\n", rc);
+		return rc;
+	}
+
+	rc = write_nvram(buff, num_bytes, &tmp_index);
+	if (rc <= 0) {
+		printk(KERN_ERR "write_error_log_nvram: Failed write_nvram (%d)\n", rc);
+		return rc;
+	}
+	
+	return 0;
+}
+
+/* read_error_log_nvram
+ *
+ * Reads nvram for error log for at most 'num_bytes'
+ */
+int read_error_log_nvram(char * buff, int num_bytes, unsigned int * err_type)
+{
+	int rc;
+	loff_t tmp_index;
+	struct err_log_info info;
+	
+	if (error_log_nvram_index == -1)
+		return -1;
+
+	if (num_bytes > error_log_nvram_size)
+		num_bytes = error_log_nvram_size;
+
+	tmp_index = error_log_nvram_index;
+
+	rc = read_nvram((char *)&info, sizeof(struct err_log_info), &tmp_index);
+	if (rc <= 0) {
+		printk(KERN_ERR "read_error_log_nvram: Failed read_nvram (%d)\n", rc);
+		return rc;
+	}
+
+	rc = read_nvram(buff, num_bytes, &tmp_index);
+	if (rc <= 0) {
+		printk(KERN_ERR "read_error_log_nvram: Failed read_nvram (%d)\n", rc);
+		return rc;
+	}
+
+	error_log_cnt = info.seq_num;
+	*err_type = info.error_type;
+
+	return 0;
+}
+
+/* This doesn't actually zero anything, but it sets the event_logged
+ * word to tell that this event is safely in syslog.
+ */
+int clear_error_log_nvram()
+{
+	loff_t tmp_index;
+	int clear_word = ERR_FLAG_ALREADY_LOGGED;
+	int rc;
+
+	if (error_log_nvram_index == -1) {
+		return -ESPIPE;
+	}
+	
+	tmp_index = error_log_nvram_index;
+	
+	rc = write_nvram((char *)&clear_word, sizeof(int), &tmp_index);
+	if (rc <= 0) {
+		printk(KERN_ERR "clear_error_log_nvram: Failed write_nvram (%d)\n", rc);
+		return rc;
+	}
+
+	return 0;
+}
+
+static int write_nvram_header(struct nvram_partition * part)
+{
+	loff_t tmp_index;
+	int rc;
+	
+	tmp_index = part->index;
+	rc = write_nvram((char *)&part->header, NVRAM_HEADER_LEN, &tmp_index); 
+
+	return rc;
+}
+
+static unsigned char nvram_checksum(struct nvram_header *p)
+{
+	unsigned int c_sum, c_sum2;
+	unsigned short *sp = (unsigned short *)p->name; /* assume 6 shorts */
+	c_sum = p->signature + p->length + sp[0] + sp[1] + sp[2] + sp[3] + sp[4] + sp[5];
+
+	/* The sum may have spilled into the 3rd byte.  Fold it back. */
+	c_sum = ((c_sum & 0xffff) + (c_sum >> 16)) & 0xffff;
+	/* The sum cannot exceed 2 bytes.  Fold it into a checksum */
+	c_sum2 = (c_sum >> 8) + (c_sum << 8);
+	c_sum = ((c_sum + c_sum2) >> 8) & 0xff;
+	return c_sum;
+}
+
 module_init(nvram_init);
 module_exit(nvram_cleanup);
 MODULE_LICENSE("GPL");
diff -urNp linux-359/arch/ppc64/kernel/pSeries_pci.c linux-360/arch/ppc64/kernel/pSeries_pci.c
--- linux-359/arch/ppc64/kernel/pSeries_pci.c
+++ linux-360/arch/ppc64/kernel/pSeries_pci.c
@@ -230,6 +230,14 @@ pci_read_irq_line(struct pci_dev *Pci_De
 	return 0;
 }
 
+void __init init_pci_config_tokens (void)
+{
+	read_pci_config = rtas_token("read-pci-config");
+	write_pci_config = rtas_token("write-pci-config");
+	ibm_read_pci_config = rtas_token("ibm,read-pci-config");
+	ibm_write_pci_config = rtas_token("ibm,write-pci-config");
+}
+
 /******************************************************************
  * Find all PHBs in the system and initialize a set of data 
  * structures to represent them.
@@ -250,11 +258,7 @@ find_and_init_phbs(void)
 	int has_isa = 0;
         PPCDBG(PPCDBG_PHBINIT, "find_and_init_phbs\n"); 
 
-	read_pci_config = rtas_token("read-pci-config");
-	write_pci_config = rtas_token("write-pci-config");
-	ibm_read_pci_config = rtas_token("ibm,read-pci-config");
-	ibm_write_pci_config = rtas_token("ibm,write-pci-config");
-
+	init_pci_config_tokens();
 	if (naca->interrupt_controller == IC_OPEN_PIC) {
 		opprop = (unsigned int *)get_property(find_path_device("/"),
 				"platform-open-pic", NULL);
@@ -409,12 +413,42 @@ find_and_init_phbs(void)
 	return 0;	 /*Success */
 }
 
+unsigned long __init get_phb_buid (struct device_node *phb)
+{
+	int addr_cells;
+	unsigned int *buid_vals;
+	unsigned int len;
+	unsigned long buid;
+
+	if (ibm_read_pci_config == -1) return 0;
+
+	/* PHB's will always be children of the root node,
+	 * or so it is promised by the current firmware. */
+	if (phb->parent == NULL) 
+		return 0;
+	if (phb->parent->parent) 
+		return 0;
+
+	buid_vals = (unsigned int *) get_property(phb, "reg", &len);
+	if (buid_vals == NULL) 
+		return 0;
+
+	addr_cells = prom_n_addr_cells(phb);
+	if (addr_cells == 1) {
+		buid = (unsigned long) buid_vals[0];
+	} else {
+		buid = (((unsigned long)buid_vals[0]) << 32UL) |
+			(((unsigned long)buid_vals[1]) & 0xffffffff);
+	}
+	return buid;
+}
+
 /******************************************************************
  *
  * Allocate and partially initialize a structure to represent a PHB.
  *
  ******************************************************************/
-struct pci_controller *
+static struct pci_controller *
 alloc_phb(struct device_node *dev, char *model, unsigned int addr_size_words)
 {
 	struct pci_controller *phb;
@@ -422,7 +456,6 @@ alloc_phb(struct device_node *dev, char 
 	struct reg_property64 reg_struct;
 	struct property *of_prop;
 	int *bus_range;
-	int *buid_vals;
 
 	PPCDBG(PPCDBG_PHBINIT, "alloc_phb: %s\n", dev->full_name); 
 	PPCDBG(PPCDBG_PHBINIT, "\tdev             = 0x%lx\n", dev); 
@@ -564,12 +597,9 @@ alloc_phb(struct device_node *dev, char 
 	phb->arch_data   = dev;
 	phb->ops = &rtas_pci_ops;
 
-	buid_vals = (int *) get_property(dev, "ibm,fw-phb-id", &len);
+	phb->buid = get_phb_buid(dev);
 	
-  if (buid_vals == NULL) {
-		phb->buid = 0;
-	} 
-  else {
+	if (phb->buid != 0) {
 		struct pci_bus check;
 		if (sizeof(check.number) == 1 || sizeof(check.primary) == 1 ||
 		    sizeof(check.secondary) == 1 || sizeof(check.subordinate) == 1) {
@@ -579,14 +609,8 @@ alloc_phb(struct device_node *dev, char 
 			panic("pSeries_pci:  this system has large bus numbers and the kernel was not\n"
 			      "built with the patch that fixes include/linux/pci.h struct pci_bus so\n"
 			      "number, primary, secondary and subordinate are ints.\n");
-    }
+		}
     
-    if (len < 2 * sizeof(int))
-      phb->buid = (unsigned long)buid_vals[0];  // Support for new OF that only has 1 integer for buid.
-    else
-      phb->buid = (((unsigned long)buid_vals[0]) << 32UL) |
-                  (((unsigned long)buid_vals[1]) & 0xffffffff);
-  	
 		phb->first_busno += (phb->global_number << 8);
 		phb->last_busno += (phb->global_number << 8);
 	}
diff -urNp linux-359/arch/ppc64/kernel/pci.c linux-360/arch/ppc64/kernel/pci.c
--- linux-359/arch/ppc64/kernel/pci.c
+++ linux-360/arch/ppc64/kernel/pci.c
@@ -531,6 +531,10 @@ pcibios_init(void)
 	if (ppc64_isabridge_dev != NULL )
 		printk("ISA bridge at %s\n", ppc64_isabridge_dev->slot_name);
 
+#ifdef CONFIG_PPC_PSERIES
+	pci_addr_cache_build();
+#endif
+
 	printk("PCI: Probing PCI hardware done\n");
 	PPCDBG(PPCDBG_BUSWALK,"PCI: Probing PCI hardware done.\n");
 	ppc64_boot_msg(0x41, "PCI Done");
diff -urNp linux-359/arch/ppc64/kernel/pci.h linux-360/arch/ppc64/kernel/pci.h
--- linux-359/arch/ppc64/kernel/pci.h
+++ linux-360/arch/ppc64/kernel/pci.h
@@ -117,4 +117,8 @@ extern void dump_Phb_tree(void);
 extern void dump_Bus_tree(void);
 extern void dump_Dev_tree(void);
 
+/* From pSeries_pci.c */
+void init_pci_config_tokens (void);
+unsigned long get_phb_buid (struct device_node *);
+
 #endif /* __PPC_KERNEL_PCI_H__ */
diff -urNp linux-359/arch/ppc64/kernel/ppc_ksyms.c linux-360/arch/ppc64/kernel/ppc_ksyms.c
--- linux-359/arch/ppc64/kernel/ppc_ksyms.c
+++ linux-360/arch/ppc64/kernel/ppc_ksyms.c
@@ -265,6 +265,7 @@ EXPORT_SYMBOL(rtas_token);
 EXPORT_SYMBOL(rtas_call);
 EXPORT_SYMBOL(rtas_data_buf);
 EXPORT_SYMBOL(rtas_data_buf_lock);
+EXPORT_SYMBOL(rtas_do_extended_delay);
 #endif
 
 #ifndef CONFIG_PPC_ISERIES
diff -urNp linux-359/arch/ppc64/kernel/prom.c linux-360/arch/ppc64/kernel/prom.c
--- linux-359/arch/ppc64/kernel/prom.c
+++ linux-360/arch/ppc64/kernel/prom.c
@@ -686,6 +686,9 @@ prom_instantiate_rtas(void)
 						      _rtas->base) >= 0) {
 				_rtas->entry = (long)_prom->args.rets[1];
 			}
+			RELOC(rtas_rmo_buf)
+				= lmb_alloc_base(RTAS_RMOBUF_MAX, PAGE_SIZE,
+							rtas_region);
 		}
 
 		if (_rtas->entry <= 0) {
diff -urNp linux-359/arch/ppc64/kernel/ras.c linux-360/arch/ppc64/kernel/ras.c
--- linux-359/arch/ppc64/kernel/ras.c
+++ linux-360/arch/ppc64/kernel/ras.c
@@ -116,6 +116,9 @@ ras_epow_interrupt(int irq, void *dev_id
 		    *((unsigned long *)&log_entry), status); 
 	printk(KERN_WARNING 
 	       "EPOW <0x%lx 0x%lx>\n",*((unsigned long *)&log_entry), status);
+
+	/* format and print the extended information */
+	log_error((char *)&log_entry, ERR_TYPE_RTAS_LOG, 0);
 }
 
 /*
@@ -132,6 +135,7 @@ ras_error_interrupt(int irq, void *dev_i
 	struct rtas_error_log log_entry;
 	unsigned int size = sizeof(log_entry);
 	long status = 0xdeadbeef;
+	int fatal;
 
 	status = rtas_call(rtas_token("check-exception"), 6, 1, NULL, 
 			   0x500, irq, 
@@ -139,8 +143,16 @@ ras_error_interrupt(int irq, void *dev_i
 			   1, /* Time Critical */
 			   __pa(&log_entry), size);
 
-	if((status != 1) && 
-	   (log_entry.severity >= SEVERITY_ERROR_SYNC)) {
+	if((status == 0) && 
+	   (log_entry.severity >= SEVERITY_ERROR_SYNC)) 
+		fatal = 1;
+	else
+		fatal = 0;
+
+	/* format and print the extended information */
+	log_error((char *)&log_entry, ERR_TYPE_RTAS_LOG, fatal); 
+
+	if (fatal) {
 		udbg_printf("HW Error <0x%lx 0x%lx>\n",
 			    *((unsigned long *)&log_entry), status);
 		printk(KERN_EMERG 
@@ -150,6 +162,7 @@ ras_error_interrupt(int irq, void *dev_i
 #ifndef DEBUG
 		/* Don't actually power off when debugging so we can test
 		 * without actually failing while injecting errors.
+		 * Error data will not be logged to syslog.
 		 */
 		ppc_md.power_off();
 #endif
diff -urNp linux-359/arch/ppc64/kernel/rtas-proc.c linux-360/arch/ppc64/kernel/rtas-proc.c
--- linux-359/arch/ppc64/kernel/rtas-proc.c
+++ linux-360/arch/ppc64/kernel/rtas-proc.c
@@ -124,6 +124,11 @@ static unsigned long rtas_tone_frequency
 static unsigned long rtas_tone_volume = 0;
 static unsigned int open_token = 0;
 
+static int set_time_for_power_on = RTAS_UNKNOWN_SERVICE;
+static int set_time_of_day = RTAS_UNKNOWN_SERVICE;
+static int get_sensor_state = RTAS_UNKNOWN_SERVICE;
+static int set_indicator = RTAS_UNKNOWN_SERVICE;
+
 extern struct proc_dir_entry *proc_ppc64_root;
 extern struct proc_dir_entry *rtas_proc_dir;
 extern spinlock_t proc_ppc64_lock;
@@ -170,6 +175,8 @@ static ssize_t ppc_rtas_errinjct_write(s
 				   size_t count, loff_t *ppos);
 static ssize_t ppc_rtas_errinjct_read(struct file *file, char *buf,
 				      size_t count, loff_t *ppos);
+static ssize_t ppc_rtas_rmo_buf_read(struct file *file, char *buf,
+				    size_t count, loff_t *ppos);
 
 struct file_operations ppc_rtas_poweron_operations = {
 	.read =		ppc_rtas_poweron_read,
@@ -201,6 +208,10 @@ struct file_operations ppc_rtas_errinjct
     .release = 		ppc_rtas_errinjct_release
 };
 
+static struct file_operations ppc_rtas_rmo_buf_ops = {
+	.read =		ppc_rtas_rmo_buf_read
+};
+
 int ppc_rtas_find_all_sensors (void);
 int ppc_rtas_process_sensor(struct individual_sensor s, int state, 
 		int error, char * buf);
@@ -215,6 +226,8 @@ int check_location (char *c, int idx, ch
 void proc_rtas_init(void)
 {
 	struct proc_dir_entry *entry;
+ 	int display_character;
+ 	int errinjct_token;
 
 	rtas_node = find_devices("rtas");
 	if ((rtas_node == NULL) || (systemcfg->platform == PLATFORM_ISERIES_LPAR)) {
@@ -240,31 +253,55 @@ void proc_rtas_init(void)
 		return;
 	}
 
-	/* /proc/rtas entries */
-
-	entry = create_proc_entry("progress", S_IRUGO|S_IWUSR, rtas_proc_dir);
-	if (entry) entry->proc_fops = &ppc_rtas_progress_operations;
-
-	entry = create_proc_entry("clock", S_IRUGO|S_IWUSR, rtas_proc_dir); 
-	if (entry) entry->proc_fops = &ppc_rtas_clock_operations;
-
-	entry = create_proc_entry("poweron", S_IWUSR|S_IRUGO, rtas_proc_dir); 
-	if (entry) entry->proc_fops = &ppc_rtas_poweron_operations;
-
-	create_proc_read_entry("sensors", S_IRUGO, rtas_proc_dir, 
-			ppc_rtas_sensor_read, NULL);
-	
-	entry = create_proc_entry("frequency", S_IWUSR|S_IRUGO, rtas_proc_dir); 
-	if (entry) entry->proc_fops = &ppc_rtas_tone_freq_operations;
-
-	entry = create_proc_entry("volume", S_IWUSR|S_IRUGO, rtas_proc_dir); 
-	if (entry) entry->proc_fops = &ppc_rtas_tone_volume_operations;
-
+	/* 
+ 	 * /proc/rtas entries 
+ 	 * only create entries if rtas token exists for desired function
+ 	 */
+  
+ 	set_time_of_day = rtas_token("set-time-of-day"); 
+ 	if (set_time_of_day != RTAS_UNKNOWN_SERVICE) {
+ 		entry=create_proc_entry("clock",S_IRUGO|S_IWUSR,rtas_proc_dir); 
+ 		if (entry) entry->proc_fops = &ppc_rtas_clock_operations;
+ 	}
+  
+ 	set_time_for_power_on = rtas_token("set-time-for-power-on");
+ 	if (set_time_for_power_on != RTAS_UNKNOWN_SERVICE) {
+ 		entry=create_proc_entry("poweron",S_IWUSR|S_IRUGO,rtas_proc_dir); 
+ 		if (entry) entry->proc_fops = &ppc_rtas_poweron_operations;
+ 	}
+  
+ 	get_sensor_state = rtas_token("get-sensor-state");
+ 	if (get_sensor_state != RTAS_UNKNOWN_SERVICE) {
+ 		create_proc_read_entry("sensors", S_IRUGO, rtas_proc_dir, 
+ 				       ppc_rtas_sensor_read, NULL);
+ 	}
+  	
+ 	set_indicator = rtas_token("set-indicator");
+ 	if (set_indicator != RTAS_UNKNOWN_SERVICE) {
+ 		entry=create_proc_entry("frequency",S_IWUSR|S_IRUGO,rtas_proc_dir); 
+ 		if (entry) entry->proc_fops = &ppc_rtas_tone_freq_operations;
+ 
+ 		entry=create_proc_entry("volume",S_IWUSR|S_IRUGO,rtas_proc_dir);
+ 		if (entry) entry->proc_fops = &ppc_rtas_tone_volume_operations;
+ 	}
+ 
+ 	display_character = rtas_token("display-character");
+ 	if ((display_character != RTAS_UNKNOWN_SERVICE) || 
+ 	    (set_indicator != RTAS_UNKNOWN_SERVICE)) {
+ 		entry=create_proc_entry("progress",S_IRUGO|S_IWUSR,rtas_proc_dir);
+ 		if (entry) entry->proc_fops = &ppc_rtas_progress_operations;
+ 	}
+ 
 #ifdef CONFIG_RTAS_ERRINJCT
-	entry = create_proc_entry("errinjct", S_IWUSR|S_IRUGO, rtas_proc_dir);
-	if (entry) entry->proc_fops = &ppc_rtas_errinjct_operations;
+ 	errinjct_token = rtas_token("ibm,errinjct");
+ 	if (errinjct_token != RTAS_UNKNOWN_SERVICE) {
+ 		entry=create_proc_entry("errinjct",S_IWUSR|S_IRUGO,rtas_proc_dir);
+ 		if (entry) entry->proc_fops = &ppc_rtas_errinjct_operations;
+	}
 #endif
-
+	
+ 	entry = create_proc_entry("rmo_buffer",S_IRUSR,rtas_proc_dir);
+ 	if (entry) entry->proc_fops = &ppc_rtas_rmo_buf_ops;
 }
 
 /* ****************************************************************** */
@@ -273,44 +310,60 @@ void proc_rtas_init(void)
 static ssize_t ppc_rtas_poweron_write(struct file * file, const char * buf,
 		size_t count, loff_t *ppos)
 {
+	char timebuf[40];  
 	struct rtc_time tm;
 	unsigned long nowtime;
 	char *dest;
 	int error;
 
-	nowtime = simple_strtoul(buf, &dest, 10);
-	if (*dest != '\0' && *dest != '\n') {
-		printk("ppc_rtas_poweron_write: Invalid time\n");
-		return count;
+	if (count > 39) count = 39;
+	if (copy_from_user (timebuf, buf, count)) {
+		return -EFAULT;
 	}
-	power_on_time = nowtime; /* save the time */
+	timebuf[count] = '\0';
 
+	nowtime = simple_strtoul(timebuf, &dest, 10);
+	if (*dest != '\0' && *dest != '\n') {
+		printk(KERN_INFO "ppc_rtas_poweron_write: Invalid time\n");
+		return -EINVAL;
+	}
 	to_tm(nowtime, &tm);
 
-	error = rtas_call(rtas_token("set-time-for-power-on"), 7, 1, NULL, 
+	error = rtas_call(set_time_for_power_on, 7, 1, NULL, 
 			tm.tm_year, tm.tm_mon, tm.tm_mday, 
 			tm.tm_hour, tm.tm_min, tm.tm_sec, 0 /* nano */);
-	if (error != 0)
-		printk(KERN_WARNING "error: setting poweron time returned: %s\n", 
-				ppc_rtas_process_error(error));
+	if (error != 0) {
+		printk(KERN_INFO "ppc_rtas_poweron_write: "
+			"error setting poweron time (%s)\n", 
+			ppc_rtas_process_error(error));
+		return -EIO;
+	}
+	power_on_time = nowtime; /* save the time */
+
 	return count;
 }
 /* ****************************************************************** */
 static ssize_t ppc_rtas_poweron_read(struct file * file, char * buf,
 		size_t count, loff_t *ppos)
 {
+	char timebuf[40];  
 	int n;
+
 	if (power_on_time == 0)
-		n = sprintf(buf, "Power on time not set\n");
+		n = snprintf(timebuf, 40, "Power on time not set\n");
 	else
-		n = sprintf(buf, "%lu\n", power_on_time);
+		n = snprintf(timebuf, 40, "%lu\n", power_on_time);
 
-	if (*ppos >= strlen(buf))
+	if (*ppos >= n)
 		return 0;
-	if (n > strlen(buf) - *ppos)
-		n = strlen(buf) - *ppos;
+	n++;		/* Include the null terminator */
+	if (*ppos)
+		n -= *ppos;
 	if (n > count)
 		n = count;
+	if (copy_to_user (buf, timebuf + (*ppos), n)) {
+		return -EFAULT;
+	}
 	*ppos += n;
 	return n;
 }
@@ -323,11 +376,15 @@ static ssize_t ppc_rtas_progress_write(s
 {
 	unsigned long hex;
 
-	strcpy(progress_led, buf); /* save the string */
-	/* Lets see if the user passed hexdigits */
-	hex = simple_strtoul(buf, NULL, 10);
-	
-	ppc_md.progress ((char *)buf, hex);
+	if (count >= MAX_LINELENGTH) count = MAX_LINELENGTH -1;
+	if (copy_from_user (progress_led, buf, count)) { /* save the string */
+		return -EFAULT;
+	}
+	progress_led[count] = '\0';
+
+	hex = simple_strtoul(progress_led, NULL, 16);
+
+	ppc_md.progress ((char *)progress_led, hex);
 	return count;
 
 	/* clear the line */ /* ppc_md.progress("                   ", 0xffff);*/
@@ -336,15 +393,31 @@ static ssize_t ppc_rtas_progress_write(s
 static ssize_t ppc_rtas_progress_read(struct file * file, char * buf,
 		size_t count, loff_t *ppos)
 {
-	int n = 0;
-	if (progress_led != NULL)
-		n = sprintf (buf, "%s\n", progress_led);
-	if (*ppos >= strlen(buf))
+	int n;
+	char * tmpbuf;
+
+	tmpbuf = kmalloc (MAX_LINELENGTH, GFP_KERNEL);
+	if (!tmpbuf) {
+		printk(KERN_INFO "ppc_rtas_progress_read: kmalloc failed\n");
+		return -ENOMEM;
+	}
+	n = snprintf (tmpbuf, MAX_LINELENGTH, "%s\n", progress_led);
+	if (n > MAX_LINELENGTH) n = MAX_LINELENGTH;
+
+	if (*ppos >= n) {
+		kfree (tmpbuf);
 		return 0;
-	if (n > strlen(buf) - *ppos)
-		n = strlen(buf) - *ppos;
+	}
+	n++;		/* Include the null terminator */
+	if (*ppos)
+		n -= *ppos;
 	if (n > count)
 		n = count;
+	if (copy_to_user (buf, tmpbuf + (*ppos), n)) {
+		kfree (tmpbuf);
+		return -EFAULT;
+	}
+	kfree (tmpbuf);
 	*ppos += n;
 	return n;
 }
@@ -355,24 +428,34 @@ static ssize_t ppc_rtas_progress_read(st
 static ssize_t ppc_rtas_clock_write(struct file * file, const char * buf, 
 		size_t count, loff_t *ppos)
 {
+	char timebuf[40];  
 	struct rtc_time tm;
 	unsigned long nowtime;
 	char *dest;
 	int error;
 
-	nowtime = simple_strtoul(buf, &dest, 10);
+	if (count > 39) count = 39;
+	if (copy_from_user (timebuf, buf, count)) {
+		return -EFAULT;
+	}
+	timebuf[count] = '\0';
+
+	nowtime = simple_strtoul(timebuf, &dest, 10);
 	if (*dest != '\0' && *dest != '\n') {
-		printk("ppc_rtas_clock_write: Invalid time\n");
-		return count;
+		printk(KERN_INFO "ppc_rtas_clock_write: Invalid time\n");
+		return -EINVAL;
 	}
 
 	to_tm(nowtime, &tm);
 	error = rtas_call(rtas_token("set-time-of-day"), 7, 1, NULL, 
 			tm.tm_year, tm.tm_mon, tm.tm_mday, 
 			tm.tm_hour, tm.tm_min, tm.tm_sec, 0);
-	if (error != 0)
-		printk(KERN_WARNING "error: setting the clock returned: %s\n", 
-				ppc_rtas_process_error(error));
+	if (error != 0) {
+		printk(KERN_INFO "ppc_rtas_clock_write: "
+			"error setting the clock (%s)\n", 
+			ppc_rtas_process_error(error));
+		return -EIO;
+	}
 	return count;
 }
 /* ****************************************************************** */
@@ -380,29 +463,35 @@ static ssize_t ppc_rtas_clock_read(struc
 		size_t count, loff_t *ppos)
 {
 	unsigned int year, mon, day, hour, min, sec;
-	unsigned long *ret = kmalloc(4*8, GFP_KERNEL);
+	unsigned long tod[8];
 	int n, error;
+	char timebuf[30];  
 
-	error = rtas_call(rtas_token("get-time-of-day"), 0, 8, ret);
+	error = rtas_call(rtas_token("get-time-of-day"), 0, 8, tod);
 	
-	year = ret[0]; mon  = ret[1]; day  = ret[2];
-	hour = ret[3]; min  = ret[4]; sec  = ret[5];
+	year = tod[0]; mon  = tod[1]; day  = tod[2];
+	hour = tod[3]; min  = tod[4]; sec  = tod[5];
 
-	if (error != 0){
-		printk(KERN_WARNING "error: reading the clock returned: %s\n", 
-				ppc_rtas_process_error(error));
-		n = sprintf (buf, "0");
+	if (error != 0) {
+		printk(KERN_INFO "ppc_rtas_clock_read: "
+			"error reading the clock (%s)\n", 
+			ppc_rtas_process_error(error));
+		n = snprintf (timebuf, 30, "0");
 	} else { 
-		n = sprintf (buf, "%lu\n", mktime(year, mon, day, hour, min, sec));
+		n = snprintf (timebuf, 30, "%lu\n", 
+				mktime(year, mon, day, hour, min, sec));
 	}
-	kfree(ret);
 
-	if (*ppos >= strlen(buf))
+	if (*ppos >= n)
 		return 0;
-	if (n > strlen(buf) - *ppos)
-		n = strlen(buf) - *ppos;
+	n++;		/* Include the null terminator */
+	if (*ppos)
+		n -= *ppos;
 	if (n > count)
 		n = count;
+	if (copy_to_user (buf, timebuf + (*ppos), n)) {
+		return -EFAULT;
+	}
 	*ppos += n;
 	return n;
 }
@@ -417,7 +506,6 @@ static int ppc_rtas_sensor_read(char * b
 	unsigned long ret;
 	int state, error;
 	char *buffer;
-	int get_sensor_state = rtas_token("get-sensor-state");
 
 	if (count < 0)
 		return -EINVAL;
@@ -716,31 +804,14 @@ int check_location_string (char *c, char
 
 int get_location_code(struct individual_sensor s, char * buffer)
 {
-	char rstr[512], tmp[10], tmp2[10];
-	int n=0, i=0, llen, len;
-	/* char *buf = kmalloc(MAX_LINELENGTH, GFP_KERNEL); */
+	char rstr[20];
+	int n=0, llen;
 	char *ret;
 
 	static int pos = 0; /* remember position where buffer was */
 
 	/* construct the sensor number like 0003 */
-	/* fill with zeros */
-	n = sprintf(tmp, "%d", s.token);
-	len = strlen(tmp);
-	while (strlen(tmp) < 4)
-		n += sprintf (tmp+n, "0");
-	
-	/* invert the string */
-	while (tmp[i]) {
-		if (i<len)
-			tmp2[4-len+i] = tmp[i];
-		else
-			tmp2[3-i] = tmp[i];
-		i++;
-	}
-	tmp2[4] = '\0';
-
-	sprintf (rstr, SENSOR_PREFIX"%s", tmp2);
+	snprintf (rstr, 20, SENSOR_PREFIX"%04d", s.token); 
 
 	ret = (char *) get_property(rtas_node, rstr, &llen);
 
@@ -754,7 +825,7 @@ int get_location_code(struct individual_
 		n += check_location_string(ret, buffer + n);
 		n += sprintf ( buffer+n, " ");
 		/* see how many characters we have printed */
-		sprintf ( t, "%s ", ret);
+		snprintf ( t, 50, "%s ", ret);
 
 		pos += strlen(t);
 		if (pos >= llen) pos=0;
@@ -767,21 +838,33 @@ int get_location_code(struct individual_
 static ssize_t ppc_rtas_tone_freq_write(struct file * file, const char * buf,
 		size_t count, loff_t *ppos)
 {
+	char freqbuf[40];  
 	unsigned long freq;
 	char *dest;
 	int error;
-	freq = simple_strtoul(buf, &dest, 10);
+
+	if (count > 39) count = 39;
+	if (copy_from_user (freqbuf, buf, count)) {
+		return -EFAULT;
+	}
+	freqbuf[count] = '\0';
+
+	freq = simple_strtoul(freqbuf, &dest, 10);
 	if (*dest != '\0' && *dest != '\n') {
-		printk("ppc_rtas_tone_freq_write: Invalid tone freqency\n");
-		return count;
+		printk(KERN_INFO "ppc_rtas_tone_freq_write: "
+			"Invalid tone freqency\n");
+		return -EINVAL;
+	}
+	if ((int)freq < 0) freq = 0;
+
+	error = rtas_call(set_indicator, 3, 1, NULL, TONE_FREQUENCY, 0, freq);
+	if (error != 0) {
+		printk(KERN_INFO "ppc_rtas_tone_freq_write: "
+			"error setting tone frequency (%s)\n", 
+			ppc_rtas_process_error(error));
+		return -EIO;
 	}
-	if (freq < 0) freq = 0;
 	rtas_tone_frequency = freq; /* save it for later */
-	error = rtas_call(rtas_token("set-indicator"), 3, 1, NULL,
-			TONE_FREQUENCY, 0, freq);
-	if (error != 0)
-		printk(KERN_WARNING "error: setting tone frequency returned: %s\n", 
-				ppc_rtas_process_error(error));
 	return count;
 }
 /* ****************************************************************** */
@@ -789,14 +872,19 @@ static ssize_t ppc_rtas_tone_freq_read(s
 		size_t count, loff_t *ppos)
 {
 	int n;
-	n = sprintf(buf, "%lu\n", rtas_tone_frequency);
+	char freqbuf[30];  
 
-	if (*ppos >= strlen(buf))
+	n = snprintf(freqbuf, 30, "%lu\n", rtas_tone_frequency);
+	if (*ppos >= n)
 		return 0;
-	if (n > strlen(buf) - *ppos)
-		n = strlen(buf) - *ppos;
+	n++;		/* Include the null terminator */
+	if (*ppos)
+		n -= *ppos;
 	if (n > count)
 		n = count;
+	if (copy_to_user (buf, freqbuf + (*ppos), n)) {
+		return -EFAULT;
+	}
 	*ppos += n;
 	return n;
 }
@@ -806,23 +894,35 @@ static ssize_t ppc_rtas_tone_freq_read(s
 static ssize_t ppc_rtas_tone_volume_write(struct file * file, const char * buf,
 		size_t count, loff_t *ppos)
 {
+	char volbuf[40];  
 	unsigned long volume;
 	char *dest;
 	int error;
-	volume = simple_strtoul(buf, &dest, 10);
+
+	if (count > 39) count = 39;
+	if (copy_from_user (volbuf, buf, count)) {
+		return -EFAULT;
+	}
+	volbuf[count] = '\0';
+
+	volume = simple_strtoul(volbuf, &dest, 10);
 	if (*dest != '\0' && *dest != '\n') {
-		printk("ppc_rtas_tone_volume_write: Invalid tone volume\n");
-		return count;
+		printk(KERN_INFO "ppc_rtas_tone_volume_write: "
+			"Invalid tone volume\n");
+		return -EINVAL;
 	}
-	if (volume < 0) volume = 0;
+	if ((int)volume < 0) volume = 0;
 	if (volume > 100) volume = 100;
 	
+	error = rtas_call(set_indicator, 3, 1, NULL, TONE_VOLUME, 0, volume);
+	if (error != 0) {
+		printk(KERN_INFO "ppc_rtas_tone_volume_write: "
+			"error setting tone volume (%s)\n", 
+			ppc_rtas_process_error(error));
+		return -EIO;
+	}
+
         rtas_tone_volume = volume; /* save it for later */
-	error = rtas_call(rtas_token("set-indicator"), 3, 1, NULL,
-			TONE_VOLUME, 0, volume);
-	if (error != 0)
-		printk(KERN_WARNING "error: setting tone volume returned: %s\n", 
-				ppc_rtas_process_error(error));
 	return count;
 }
 /* ****************************************************************** */
@@ -830,14 +930,19 @@ static ssize_t ppc_rtas_tone_volume_read
 		size_t count, loff_t *ppos)
 {
 	int n;
-	n = sprintf(buf, "%lu\n", rtas_tone_volume);
+	char volbuf[10];  
 
-	if (*ppos >= strlen(buf))
+	n = snprintf(volbuf, 10, "%lu\n", rtas_tone_volume);
+	if (*ppos >= n)
 		return 0;
-	if (n > strlen(buf) - *ppos)
-		n = strlen(buf) - *ppos;
+	n++;		/* Include the null terminator */
+	if (*ppos)
+		n -= *ppos;
 	if (n > count)
 		n = count;
+	if (copy_to_user (buf, volbuf + (*ppos), n)) {
+		return -EFAULT;
+	}
 	*ppos += n;
 	return n;
 }
@@ -867,8 +972,7 @@ static int ppc_rtas_errinjct_open(struct
 static ssize_t ppc_rtas_errinjct_write(struct file * file, const char * buf,
 				       size_t count, loff_t *ppos)
 {
- 
-	char * ei_token;
+	char ei_token[ERRINJCT_TOKEN_LEN];
 	char * workspace = NULL;
 	size_t max_len;
 	int token_len;
@@ -881,16 +985,12 @@ static ssize_t ppc_rtas_errinjct_write(s
 		max_len = ERRINJCT_TOKEN_LEN;
 	}
 
-	token_len = strnlen(buf, max_len);
+	if (copy_from_user (ei_token, buf, max_len)) {
+		return -EFAULT;
+	}
+	token_len = strnlen(ei_token, max_len);
 	token_len++; /* Add one for the null termination */
     
-	ei_token = (char *)kmalloc(token_len, GFP_KERNEL);
-	if (!ei_token) {
-		printk(KERN_WARNING "error: kmalloc failed\n");
-		return -ENOMEM;
-	}
-
-	strncpy(ei_token, buf, token_len);
     
 	if (count > token_len + WORKSPACE_SIZE) {
 		count = token_len + WORKSPACE_SIZE;
@@ -909,20 +1009,21 @@ static ssize_t ppc_rtas_errinjct_write(s
 
 		workspace = (char *)kmalloc(max_len, GFP_KERNEL);
 		if (!workspace) {
-			printk(KERN_WARNING "error: failed kmalloc\n");
-			kfree(ei_token);
+			printk(KERN_INFO "ppc_rtas_errinjct_write: "
+				"failed kmalloc\n");
 			return -ENOMEM;
 		}
 	
-		memcpy(workspace, buf, max_len);
+		if (copy_from_user (workspace, buf, max_len)) {
+			kfree (workspace);
+			return -EFAULT;
+		}
 	}
 
 	rc = rtas_errinjct(open_token, ei_token, workspace);
 
-	if (count > token_len) {
+	if (workspace) 
 		kfree(workspace);
-	}
-	kfree(ei_token);
 
 	return rc < 0 ? rc : count;
 }
@@ -944,34 +1045,63 @@ static ssize_t ppc_rtas_errinjct_read(st
 {
 	char * buffer;
 	int i;
-	int n = 0;
+	int n = 0, cnt;
+	int m = MAX_ERRINJCT_TOKENS * (ERRINJCT_TOKEN_LEN+1);
 
-	buffer = (char *)kmalloc(MAX_ERRINJCT_TOKENS * (ERRINJCT_TOKEN_LEN+1),
-				 GFP_KERNEL);
+	buffer = (char *)kmalloc(m, GFP_KERNEL);
 	if (!buffer) {
-		printk(KERN_ERR "error: kmalloc failed\n");
+		printk(KERN_INFO "ppc_rtas_errinjct_read: kmalloc failed\n");
 		return -ENOMEM;
 	}
 
 	for (i = 0; i < MAX_ERRINJCT_TOKENS && ei_token_list[i].value; i++) {
-		n += sprintf(buffer+n, ei_token_list[i].name);
-		n += sprintf(buffer+n, "\n");
+		cnt = snprintf(buffer+n, m-n, "%s\n", ei_token_list[i].name);
+		if (cnt > m-n) {		/* exceeded buffer space */
+			printk(KERN_INFO "ppc_rtas_errinjct_read: buffer full\n");
+			buffer[n] = '\0';	/* don't include token */	
+			break;	
+		}
+		n += cnt;
 	}
 
-	if (*ppos >= strlen(buffer)) {
+	if (*ppos >= n) {
 		kfree(buffer);
 		return 0;
 	}
-	if (n > strlen(buffer) - *ppos)
-		n = strlen(buffer) - *ppos;
-
+	n++;		/* Include the null terminator */
+	if (*ppos)
+		n -= *ppos;
 	if (n > count)
 		n = count;
-
-	memcpy(buf, buffer + *ppos, n);
+	if (copy_to_user(buf, buffer + *ppos, n)) {
+		kfree (buffer);
+		return -EFAULT;
+	}
 
 	*ppos += n;
 
 	kfree(buffer);
 	return n;
 }
+
+#define RMO_READ_BUF_MAX 30
+
+/* RTAS Userspace access */
+static ssize_t ppc_rtas_rmo_buf_read(struct file *file, char *buf,
+				    size_t count, loff_t *ppos)
+{
+	char kbuf[RMO_READ_BUF_MAX];
+	int n;
+
+	n = sprintf(kbuf, "%016lx %x\n", rtas_rmo_buf, RTAS_RMOBUF_MAX);
+
+	if (*ppos >= n)
+		return 0;
+	n -= *ppos;
+	if (n > count)
+		n = count;
+	if (copy_to_user(buf, kbuf + *ppos, n))
+		return -EFAULT;
+	*ppos += n;
+ 	return n;
+}
diff -urNp linux-359/arch/ppc64/kernel/rtas.c linux-360/arch/ppc64/kernel/rtas.c
--- linux-359/arch/ppc64/kernel/rtas.c
+++ linux-360/arch/ppc64/kernel/rtas.c
@@ -34,6 +34,8 @@ struct proc_dir_entry *rtas_proc_dir;	/*
 struct flash_block_list_header rtas_firmware_flash_list = {0, 0};
 struct errinjct_token ei_token_list[MAX_ERRINJCT_TOKENS];
 
+extern int slabpages; /* from mm/slab.c to see if slab is up & running */
+
 /*
  * prom_init() is called very early on, before the kernel text
  * and data have been mapped to KERNELBASE.  At this point the code
@@ -55,10 +57,12 @@ struct errinjct_token ei_token_list[MAX_
  * are put in the data segment.
  */
 
-struct rtas_t rtas = { 
+struct rtas_t rtas = {
 	.lock = SPIN_LOCK_UNLOCKED
 };
 
+char rtas_err_buf[RTAS_DATA_BUF_SIZE];
+
 extern unsigned long reloc_offset(void);
 
 spinlock_t rtas_data_buf_lock = SPIN_LOCK_UNLOCKED;
@@ -82,7 +86,7 @@ phys_call_rtas(int token, int nargs, int
 	  rtas->args[i] = (rtas_arg_t)LONG_LSW(va_arg(list, ulong));
 	va_end(list);
 
-        enter_rtas(rtas);	
+	enter_rtas(rtas);	
 }
 
 void
@@ -103,15 +107,19 @@ phys_call_rtas_display_status(char c)
 void
 call_rtas_display_status(char c)
 {
-	struct rtas_args *rtas = &(get_paca()->xRtas);
+	struct rtas_args *rargs = &(get_paca()->xRtas);
+	unsigned long flags;
 
-	rtas->token = 10;
-	rtas->nargs = 1;
-	rtas->nret  = 1;
-	rtas->rets  = (rtas_arg_t *)&(rtas->args[1]);
-	rtas->args[0] = (int)c;
+	spin_lock_irqsave(&rtas.lock, flags);
 
-	enter_rtas((void *)__pa((unsigned long)rtas));	
+	rargs->token = 10;
+	rargs->nargs = 1;
+	rargs->nret  = 1;
+	rargs->rets  = (rtas_arg_t *)(&(rargs->args[1]));
+	rargs->args[0] = (int)c;
+
+	enter_rtas((void *)__pa((unsigned long)rargs));
+	spin_unlock_irqrestore(&rtas.lock, flags);
 }
 
 __openfirmware
@@ -127,15 +135,61 @@ rtas_token(const char *service)
 	return tokp ? *tokp : RTAS_UNKNOWN_SERVICE;
 }
 
+/** Return a copy of the detailed error text associated with the
+ *  most recent failed call to rtas.  Because the error text
+ *  might go stale if there are any other intervening rtas calls,
+ *  this routine must be called atomically with whatever produced
+ *  the error (i.e. with rtas.lock still held from the previous call).
+ */
+static int
+__fetch_rtas_last_error(void)
+{
+	struct rtas_args err_args, save_args;
+	u32 bufsz;
+
+	bufsz = rtas_token ("rtas-error-log-max");
+	if ((bufsz == RTAS_UNKNOWN_SERVICE) ||
+	    (bufsz > RTAS_ERROR_LOG_MAX)) {
+		printk (KERN_WARNING "RTAS: bad log buffer size %d\n", bufsz);
+		bufsz = RTAS_ERROR_LOG_MAX;
+	}
+
+	err_args.token = rtas_token("rtas-last-error");
+	err_args.nargs = 2;
+	err_args.nret = 1;
+
+	err_args.args[0] = (rtas_arg_t)__pa(rtas_err_buf);
+	err_args.args[1] = bufsz;
+	err_args.args[2] = 0;
+
+	save_args = rtas.args;
+	rtas.args = err_args;
+	rtas.args.rets = (rtas_arg_t *)&(rtas.args.args[2]);
+
+	PPCDBG(PPCDBG_RTAS, "\tentering rtas with 0x%lx\n",
+	       __pa(&err_args));
+	enter_rtas((void *)__pa((unsigned long)(&rtas.args)));
+	PPCDBG(PPCDBG_RTAS, "\treturned from rtas ...\n");
+
+	err_args = rtas.args;
+	rtas.args = save_args;
+
+	err_args.rets = (rtas_arg_t *)&(err_args.args[2]);
+	return err_args.rets[0];
+}
+
+
 __openfirmware
 long
 rtas_call(int token, int nargs, int nret,
 	  unsigned long *outputs, ...)
 {
 	va_list list;
-	int i;
-	unsigned long s;
-	struct rtas_args *rtas_args = &(get_paca()->xRtas);
+	int i, logit = 0;
+	unsigned long flags;
+	struct rtas_args *rtas_args;
+	char * buff_copy = NULL;
+	unsigned long retval;
 
 	PPCDBG(PPCDBG_RTAS, "Entering rtas_call\n");
 	PPCDBG(PPCDBG_RTAS, "\ttoken    = 0x%x\n", token);
@@ -145,6 +199,9 @@ rtas_call(int token, int nargs, int nret
 	if (token == RTAS_UNKNOWN_SERVICE)
 		return -1;
 
+	spin_lock_irqsave(&rtas.lock, flags);
+	rtas_args = &(get_paca()->xRtas);
+
 	rtas_args->token = token;
 	rtas_args->nargs = nargs;
 	rtas_args->nret  = nret;
@@ -159,20 +216,16 @@ rtas_call(int token, int nargs, int nret
 	for (i = 0; i < nret; ++i)
 	  rtas_args->rets[i] = 0;
 
-#if 0   /* Gotta do something different here, use global lock for now... */
-	spin_lock_irqsave(&rtas_args->lock, s);
-#else
-	spin_lock_irqsave(&rtas.lock, s);
-#endif
 	PPCDBG(PPCDBG_RTAS, "\tentering rtas with 0x%lx\n",
 		(void *)__pa((unsigned long)rtas_args));
 	enter_rtas((void *)__pa((unsigned long)rtas_args));
 	PPCDBG(PPCDBG_RTAS, "\treturned from rtas ...\n");
-#if 0   /* Gotta do something different here, use global lock for now... */
-	spin_unlock_irqrestore(&rtas_args->lock, s);
-#else
-	spin_unlock_irqrestore(&rtas.lock, s);
-#endif
+
+	/* A -1 return code indicates that the last command couldn't
+	 * be completed due to a hardware error. */
+	if (rtas_args->rets[0] == -1)
+		logit = (__fetch_rtas_last_error() == 0);
+
 	ifppcdebug(PPCDBG_RTAS) {
 		for(i=0; i < nret ;i++)
 			udbg_printf("\tnret[%d] = 0x%lx\n", i, (ulong)rtas_args->rets[i]);
@@ -181,7 +234,55 @@ rtas_call(int token, int nargs, int nret
 	if (nret > 1 && outputs != NULL)
 		for (i = 0; i < nret-1; ++i)
 			outputs[i] = rtas_args->rets[i+1];
-	return (ulong)((nret > 0) ? rtas_args->rets[0] : 0);
+	retval = (ulong)((nret > 0) ? rtas_args->rets[0] : 0);
+
+	/* Log the error in the unlikely case that there was one. */
+	if (unlikely(logit)) {
+		/* Can't call kmalloc if VM subsystem is not yet up. */
+		if (slabpages>0) {
+			buff_copy = kmalloc(RTAS_ERROR_LOG_MAX, GFP_ATOMIC);
+			if (buff_copy) {
+				memcpy(buff_copy, rtas_err_buf, RTAS_ERROR_LOG_MAX);
+			}
+		}
+	}
+
+	spin_unlock_irqrestore(&rtas.lock, flags);
+
+	if (buff_copy) {
+		log_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);
+		kfree(buff_copy);
+	}
+	return retval;
+}
+
+/* Given an RTAS status code of 990n perform the hinted delay of 10^n
+ * (last digit) milliseconds.  For now we bound at n=5 (100 secs). 
+ */
+int
+rtas_do_extended_delay(int status)
+{
+	int order = status - 9900;
+	unsigned long ms;
+	unsigned long jiffies;
+
+	if (order < 0)
+		order = 0;	/* RTC depends on this for -2 clock busy */
+	else if (order > 5)
+		order = 5;	/* bound */
+
+	/* Use microseconds for reasonable accuracy */
+	for (ms=1; order > 0; order--)
+		ms *= 10;       
+
+	jiffies = (ms * HZ) / 1000;
+	
+	set_current_state(TASK_INTERRUPTIBLE);
+	schedule_timeout(jiffies);
+	if (signal_pending(current))
+		return RTAS_DELAY_INTR;
+
+	return 0;
 }
 
 #define FLASH_BLOCK_LIST_VERSION (1UL)
@@ -359,6 +460,45 @@ rtas_errinjct_close(unsigned int open_to
 	return 0;
 }
 
+unsigned long rtas_rmo_buf = 0;
+
+asmlinkage int ppc64_rtas(struct rtas_args *uargs)
+{
+	struct rtas_args args;
+	unsigned long flags;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	if (copy_from_user(&args, uargs, 3 * sizeof(u32)) != 0)
+		return -EFAULT;
+
+	if (args.nargs > ARRAY_SIZE(args.args)
+	    || args.nret > ARRAY_SIZE(args.args)
+	    || args.nargs + args.nret > ARRAY_SIZE(args.args))
+		return -EINVAL;
+
+	/* Copy in args. */
+	if (copy_from_user(args.args, uargs->args,
+			   args.nargs * sizeof(rtas_arg_t)) != 0)
+		return -EFAULT;
+
+	spin_lock_irqsave(&rtas.lock, flags);
+	get_paca()->xRtas = args;
+	enter_rtas((void *)__pa((unsigned long)&get_paca()->xRtas));
+	args = get_paca()->xRtas;
+	spin_unlock_irqrestore(&rtas.lock, flags);
+
+	/* Copy out args. */
+	if (copy_to_user(uargs->args + args.nargs,
+			 args.args + args.nargs,
+			 args.nret * sizeof(rtas_arg_t)) != 0)
+		return -EFAULT;
+
+	return 0;
+}
+
+
 #ifdef CONFIG_PPC_PSERIES
 static int __init rtas_errinjct_init(void)
 {
diff -urNp linux-359/arch/ppc64/kernel/rtas_flash.c linux-360/arch/ppc64/kernel/rtas_flash.c
--- linux-359/arch/ppc64/kernel/rtas_flash.c
+++ linux-360/arch/ppc64/kernel/rtas_flash.c
@@ -24,7 +24,53 @@
 #define MODULE_VERSION "1.0"
 #define MODULE_NAME "rtas_flash"
 
-#define FIRMWARE_FLASH_NAME "firmware_flash"
+#define FIRMWARE_FLASH_NAME "firmware_flash"   
+#define FIRMWARE_UPDATE_NAME "firmware_update"
+#define MANAGE_FLASH_NAME "manage_flash"
+#define VALIDATE_FLASH_NAME "validate_flash"
+
+/* General RTAS Status Codes */
+#define RTAS_RC_SUCCESS  0
+#define RTAS_RC_HW_ERR	-1
+#define RTAS_RC_BUSY	-2
+
+/* Flash image status values */
+#define FLASH_AUTH           -9002 /* RTAS Not Service Authority Partition */
+#define FLASH_NO_OP          -1099 /* No operation initiated by user */	
+#define FLASH_IMG_SHORT	     -1005 /* Flash image shorter than expected */
+#define FLASH_IMG_BAD_LEN    -1004 /* Bad length value in flash list block */
+#define FLASH_IMG_NULL_DATA  -1003 /* Bad data value in flash list block */
+#define FLASH_IMG_READY      0     /* Firmware img ready for flash on reboot */
+
+/* Manage image status values */
+#define MANAGE_AUTH          -9002 /* RTAS Not Service Authority Partition */
+#define MANAGE_ACTIVE_ERR    -9001 /* RTAS Cannot Overwrite Active Img */
+#define MANAGE_NO_OP         -1099 /* No operation initiated by user */
+#define MANAGE_PARAM_ERR     -3    /* RTAS Parameter Error */
+#define MANAGE_HW_ERR        -1    /* RTAS Hardware Error */
+
+/* Validate image status values */
+#define VALIDATE_AUTH          -9002 /* RTAS Not Service Authority Partition */
+#define VALIDATE_NO_OP         -1099 /* No operation initiated by the user */
+#define VALIDATE_INCOMPLETE    -1002 /* User copied < VALIDATE_BUF_SIZE */
+#define VALIDATE_READY	       -1001 /* Firmware image ready for validation */
+#define VALIDATE_PARAM_ERR     -3    /* RTAS Parameter Error */
+#define VALIDATE_HW_ERR        -1    /* RTAS Hardware Error */
+#define VALIDATE_TMP_UPDATE    0     /* Validate Return Status */
+#define VALIDATE_FLASH_AUTH    1     /* Validate Return Status */
+#define VALIDATE_INVALID_IMG   2     /* Validate Return Status */
+#define VALIDATE_CUR_UNKNOWN   3     /* Validate Return Status */
+#define VALIDATE_TMP_COMMIT_DL 4     /* Validate Return Status */
+#define VALIDATE_TMP_COMMIT    5     /* Validate Return Status */
+#define VALIDATE_TMP_UPDATE_DL 6     /* Validate Return Status */
+
+/* ibm,manage-flash-image operation tokens */
+#define RTAS_REJECT_TMP_IMG   0
+#define RTAS_COMMIT_TMP_IMG   1
+
+/* Array sizes */
+#define VALIDATE_BUF_SIZE 4096    
+#define RTAS_MSG_MAXLEN   64
 
 /* Local copy of the flash block list.
  * We only allow one open of the flash proc file and create this
@@ -36,21 +82,37 @@
  * is treated as the number of entries currently in the block
  * (i.e. not a byte count).  This is all fixed on release.
  */
-static struct flash_block_list *flist;
-static char *flash_msg;
-static int flash_possible;
-
-static int rtas_flash_open(struct inode *inode, struct file *file)
-{
-	if ((file->f_mode & FMODE_WRITE) && flash_possible) {
-		if (flist)
-			return -EBUSY;
-		flist = (struct flash_block_list *)get_free_page(GFP_KERNEL);
-		if (!flist)
-			return -ENOMEM;
-	}
-	return 0;
-}
+
+/* Status int must be first member of struct */
+struct rtas_update_flash_t
+{
+	int status;			/* Flash update status */
+	struct flash_block_list *flist; /* Local copy of flash block list */
+};
+
+/* Status int must be first member of struct */
+struct rtas_manage_flash_t
+{
+	int status;			/* Returned status */
+	unsigned int op;		/* Reject or commit image */
+};
+
+/* Status int must be first member of struct */
+struct rtas_validate_flash_t
+{
+	int status;		 	/* Returned status */	
+	char buf[VALIDATE_BUF_SIZE]; 	/* Candidate image buffer */
+	unsigned int buf_size;		/* Size of image buf */
+	unsigned int update_results;	/* Update results token */
+};
+
+static spinlock_t flash_file_open_lock = SPIN_LOCK_UNLOCKED;
+static struct proc_dir_entry *firmware_flash_pde = NULL;
+static struct proc_dir_entry *firmware_update_pde = NULL;
+static struct proc_dir_entry *validate_pde = NULL;
+static struct proc_dir_entry *manage_pde = NULL;
+
+DECLARE_MUTEX(rtas_flash_sem);
 
 /* Do simple sanity checks on the flash image. */
 static int flash_list_valid(struct flash_block_list *flist)
@@ -59,32 +121,27 @@ static int flash_list_valid(struct flash
 	int i;
 	unsigned long block_size, image_size;
 
-	flash_msg = NULL;
 	/* Paranoid self test here.  We also collect the image size. */
 	image_size = 0;
 	for (f = flist; f; f = f->next) {
 		for (i = 0; i < f->num_blocks; i++) {
 			if (f->blocks[i].data == NULL) {
-				flash_msg = "error: internal error null data\n";
-				return 0;
+				return FLASH_IMG_NULL_DATA;
 			}
 			block_size = f->blocks[i].length;
 			if (block_size <= 0 || block_size > PAGE_SIZE) {
-				flash_msg = "error: internal error bad length\n";
-				return 0;
+				return FLASH_IMG_BAD_LEN;
 			}
 			image_size += block_size;
 		}
 	}
-	if (image_size < (256 << 10)) {
-		if (image_size < 2)
-			flash_msg = NULL;	/* allow "clear" of image */
-		else
-			flash_msg = "error: flash image short\n";
-		return 0;
-	}
+
+	if (image_size < 2) 
+		return FLASH_NO_OP;
+
 	printk(KERN_INFO "FLASH: flash image with %ld bytes stored for hardware flash on reboot\n", image_size);
-	return 1;
+
+	return FLASH_IMG_READY;
 }
 
 static void free_flash_list(struct flash_block_list *f)
@@ -103,57 +160,101 @@ static void free_flash_list(struct flash
 
 static int rtas_flash_release(struct inode *inode, struct file *file)
 {
-	if (flist) {
-		/* Always clear saved list on a new attempt. */
+	struct proc_dir_entry *dp = file->f_dentry->d_inode->u.generic_ip;
+	struct rtas_update_flash_t *uf;
+	
+	uf = (struct rtas_update_flash_t *) dp->data;
+	if (uf->flist) {    
+		/* File was opened in write mode for a new flash attempt */
+		/* Clear saved list */
 		if (rtas_firmware_flash_list.next) {
 			free_flash_list(rtas_firmware_flash_list.next);
 			rtas_firmware_flash_list.next = NULL;
 		}
 
-		if (flash_list_valid(flist))
-			rtas_firmware_flash_list.next = flist;
+		if (uf->status != FLASH_AUTH)  
+			uf->status = flash_list_valid(uf->flist);
+
+		if (uf->status == FLASH_IMG_READY) 
+			rtas_firmware_flash_list.next = uf->flist;
 		else
-			free_flash_list(flist);
-		flist = NULL;
+			free_flash_list(uf->flist);
+
+		uf->flist = NULL;
 	}
+
+	atomic_dec(&dp->count);
 	return 0;
 }
 
+static int get_flash_status_msg(int status, char *buf, int size)
+{
+	int len;
+
+	switch (status) {
+	case FLASH_AUTH:
+		len = snprintf(buf, size, "error: this partition does not have service authority\n");
+		break;
+	case FLASH_NO_OP:
+		len = snprintf(buf, size, "info: no firmware image for flash\n");
+		break;
+	case FLASH_IMG_SHORT:
+		len = snprintf(buf, size, "error: flash image short\n");
+		break;
+	case FLASH_IMG_BAD_LEN:
+		len = snprintf(buf, size, "error: internal error bad length\n");
+		break;
+	case FLASH_IMG_NULL_DATA:
+		len = snprintf(buf, size, "error: internal error null data\n");
+		break;
+	case FLASH_IMG_READY:
+		len = snprintf(buf, size, "ready: firmware image ready for flash on reboot\n");
+		break;
+	default:
+		len = snprintf(buf, size, "error: unexpected status value %d\n", status);
+		break;
+	}
+
+	return len >= size ? size-1 : len;
+}
+
 /* Reading the proc file will show status (not the firmware contents) */
 static ssize_t rtas_flash_read(struct file *file, char *buf,
 			       size_t count, loff_t *ppos)
 {
-	int error;
-	char *msg;
+	struct proc_dir_entry *dp = file->f_dentry->d_inode->u.generic_ip;
+	struct rtas_update_flash_t *uf;
+	char msg[RTAS_MSG_MAXLEN];
 	int msglen;
+	ssize_t ret;
 
-	if (!flash_possible) {
-		msg = "error: this partition does not have service authority\n";
-	} else if (flist) {
-		msg = "info: this file is busy for write by some process\n";
-	} else if (flash_msg) {
-		msg = flash_msg;	/* message from last flash attempt */
-	} else if (rtas_firmware_flash_list.next) {
-		msg = "ready: firmware image ready for flash on reboot\n";
-	} else {
-		msg = "info: no firmware image for flash\n";
+	if (down_interruptible(&rtas_flash_sem))
+		return -ERESTARTSYS;
+	uf = (struct rtas_update_flash_t *) dp->data;
+
+	if (!strcmp(dp->name, FIRMWARE_FLASH_NAME)) {
+		msglen = get_flash_status_msg(uf->status, msg, RTAS_MSG_MAXLEN);
+	} else {	   /* FIRMWARE_UPDATE_NAME */
+		msglen = sprintf(msg, "%d\n", uf->status);
+	}
+	
+	if (*ppos >= msglen) {
+		ret =  0;
+		goto done;
 	}
-	msglen = strlen(msg);
+	msglen -= *ppos;
 	if (msglen > count)
 		msglen = count;
 
-	if (ppos && *ppos != 0)
-		return 0;	/* be cheap */
-
-	error = verify_area(VERIFY_WRITE, buf, msglen);
-	if (error)
-		return -EINVAL;
-
-	copy_to_user(buf, msg, msglen);
-
-	if (ppos)
-		*ppos = msglen;
-	return msglen;
+	if (copy_to_user(buf, msg + (*ppos), msglen)) {
+		ret = -EFAULT;
+		goto done;
+	}
+	*ppos += msglen;
+	ret = msglen;
+done:
+	up(&rtas_flash_sem);
+	return ret;
 }
 
 /* We could be much more efficient here.  But to keep this function
@@ -164,75 +265,499 @@ static ssize_t rtas_flash_read(struct fi
 static ssize_t rtas_flash_write(struct file *file, const char *buffer,
 				size_t count, loff_t *off)
 {
-	size_t len = count;
+	struct proc_dir_entry *dp = file->f_dentry->d_inode->u.generic_ip;
+	struct rtas_update_flash_t *uf;
 	char *p;
 	int next_free;
-	struct flash_block_list *fl = flist;
+	struct flash_block_list *fl;
+	ssize_t ret;
 
-	if (!flash_possible || len == 0)
-		return len;	/* discard data */
+	if (down_interruptible(&rtas_flash_sem))
+		return -ERESTARTSYS;
+	uf = (struct rtas_update_flash_t *) dp->data;
+
+	if (uf->status == FLASH_AUTH || count == 0) {
+		ret = count;	/* discard data */
+		goto done;
+	}
 
+	/* In the case that the image is not ready for flashing, the memory
+	 * allocated for the block list will be freed upon the release of the 
+	 * proc file
+	 */
+	if (uf->flist == NULL) {
+		uf->flist = (struct flash_block_list *) get_free_page(GFP_KERNEL);
+		if (!uf->flist) {
+			ret = -ENOMEM;
+			goto done;
+		}
+	}
+
+	fl = uf->flist;
 	while (fl->next)
 		fl = fl->next; /* seek to last block_list for append */
 	next_free = fl->num_blocks;
 	if (next_free == FLASH_BLOCKS_PER_NODE) {
 		/* Need to allocate another block_list */
 		fl->next = (struct flash_block_list *)get_free_page(GFP_KERNEL);
-		if (!fl->next)
-			return -ENOMEM;
+		if (!fl->next) {
+			ret = -ENOMEM;
+			goto done;
+		}
 		fl = fl->next;
 		next_free = 0;
 	}
 
-	if (len > PAGE_SIZE)
-		len = PAGE_SIZE;
+	if (count > PAGE_SIZE)
+		count = PAGE_SIZE;
 	p = (char *)get_free_page(GFP_KERNEL);
-	if (!p)
-		return -ENOMEM;
-	if(copy_from_user(p, buffer, len)) {
+	if (!p) {
+		ret = -ENOMEM;
+		goto done;
+	}
+	
+	if(copy_from_user(p, buffer, count)) {
 		free_page((unsigned long)p);
-		return -EFAULT;
+		ret = -EFAULT;
+		goto done;
 	}
 	fl->blocks[next_free].data = p;
-	fl->blocks[next_free].length = len;
+	fl->blocks[next_free].length = count;
 	fl->num_blocks++;
+	ret = count;
+done:
+	up(&rtas_flash_sem);
+	return ret;
+}
+
+static int rtas_excl_open(struct inode *inode, struct file *file)
+{
+	struct proc_dir_entry *dp = file->f_dentry->d_inode->u.generic_ip;
 
-	return len;
+	/* Enforce exclusive open with use count of PDE */
+	spin_lock(&flash_file_open_lock);
+	if (atomic_read(&dp->count) > 1) {
+		spin_unlock(&flash_file_open_lock);
+		return -EBUSY;
+	}
+
+	atomic_inc(&dp->count);
+	spin_unlock(&flash_file_open_lock);
+	
+	return 0;
+}
+
+static int rtas_excl_release(struct inode *inode, struct file *file)
+{
+	struct proc_dir_entry *dp = file->f_dentry->d_inode->u.generic_ip;
+
+	atomic_dec(&dp->count);
+
+	return 0;
+}
+
+static void manage_flash(struct rtas_manage_flash_t *args_buf)
+{
+	s32 delay_rc;
+	s32 rc;
+
+	while (1) {
+		rc = (s32) rtas_call(rtas_token("ibm,manage-flash-image"), 1, 
+				1, NULL, (long) args_buf->op);
+		if (rc == RTAS_RC_BUSY)
+			udelay(1);
+		else if (rtas_is_extended_busy(rc)) {
+			if ((delay_rc = rtas_do_extended_delay(rc))) {
+				/* Delay interrupted */
+				args_buf->status = delay_rc;
+				break;
+			}
+		} else {
+			args_buf->status = rc;
+			break;
+		}
+	}
+}
+
+static ssize_t manage_flash_read(struct file *file, char *buf,
+			       size_t count, loff_t *ppos)
+{
+	struct proc_dir_entry *dp = file->f_dentry->d_inode->u.generic_ip;
+	struct rtas_manage_flash_t *args_buf;
+	char msg[RTAS_MSG_MAXLEN];
+	int msglen;
+	ssize_t ret;
+
+	if (down_interruptible(&rtas_flash_sem))
+		return -ERESTARTSYS;
+	args_buf = (struct rtas_manage_flash_t *) dp->data;
+	if (args_buf == NULL) {
+		ret = 0;
+		goto done;
+	}
+
+	msglen = sprintf(msg, "%d\n", args_buf->status);
+	if (*ppos >= msglen) {
+		ret = 0;
+		goto done;
+	}
+	
+	msglen -= *ppos;
+	if (msglen > count)
+		msglen = count;
+
+	if (copy_to_user(buf, msg + (*ppos), msglen)) {
+		ret = -EFAULT;
+		goto done;
+	}
+	*ppos += msglen;
+	ret = msglen;
+
+done:
+	up(&rtas_flash_sem);
+	return ret;
+}
+
+static ssize_t manage_flash_write(struct file *file, const char *buf,
+				size_t count, loff_t *off)
+{
+	struct proc_dir_entry *dp = file->f_dentry->d_inode->u.generic_ip;
+	struct rtas_manage_flash_t *args_buf;
+	const char reject_str[] = "0";
+	const char commit_str[] = "1";
+	char msg[RTAS_MSG_MAXLEN];
+	int op;
+	ssize_t ret;
+
+	if (down_interruptible(&rtas_flash_sem))
+		return -ERESTARTSYS;
+	args_buf = (struct rtas_manage_flash_t *) dp->data;
+	if ((args_buf->status == MANAGE_AUTH) || (count == 0)) {
+		ret = count;
+		goto done;
+	}
+		
+	if (count > RTAS_MSG_MAXLEN)
+		count = RTAS_MSG_MAXLEN;
+	if (copy_from_user(msg, buf, count)) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+	if (strncmp(buf, reject_str, strlen(reject_str)) == 0) 
+		op = RTAS_REJECT_TMP_IMG;
+	else if (strncmp(buf, commit_str, strlen(commit_str)) == 0) 
+		op = RTAS_COMMIT_TMP_IMG;
+	else {
+		ret = -EINVAL;
+		goto done;
+	}
+
+	args_buf->op = op;
+	manage_flash(args_buf);
+	*off += count;
+	ret = count;
+done:
+	up(&rtas_flash_sem);
+	return ret;
+}
+
+static void validate_flash(struct rtas_validate_flash_t *args_buf)
+{
+	int token = rtas_token("ibm,validate-flash-image");
+	unsigned int wait_time;
+	long update_results;
+	s32 delay_rc;	
+	s32 rc;	
+
+	rc = 0;
+	while(1) {
+		spin_lock(&rtas_data_buf_lock);
+		memcpy(rtas_data_buf, args_buf->buf, VALIDATE_BUF_SIZE);
+		rc = (s32) rtas_call(token, 2, 2, &update_results, 
+				     __pa(rtas_data_buf), args_buf->buf_size);
+		memcpy(args_buf->buf, rtas_data_buf, VALIDATE_BUF_SIZE);
+		spin_unlock(&rtas_data_buf_lock);
+			
+		if (rc == RTAS_RC_BUSY)
+			udelay(1);
+		else if (rtas_is_extended_busy(rc)) {
+			if ((delay_rc = rtas_do_extended_delay(rc))) {
+				/* Delay interrupted */
+				args_buf->status = delay_rc;
+				break;
+			}
+		} else {
+			args_buf->status = rc;
+			args_buf->update_results = (u32) update_results;
+			break;
+		}
+	}
+}
+
+static int get_validate_flash_msg(struct rtas_validate_flash_t *args_buf, 
+		                  char *msg, int size)
+{
+	int n;
+
+	if (args_buf->status >= VALIDATE_TMP_UPDATE) { 
+		n = snprintf(msg, size, "%u\n", args_buf->update_results);
+		if ((args_buf->update_results >= VALIDATE_CUR_UNKNOWN) ||
+		    (args_buf->update_results == VALIDATE_TMP_UPDATE))
+			n += snprintf(msg + n, size - n, "%s\n", args_buf->buf);
+	} else {
+		n = snprintf(msg, size, "%d\n", args_buf->status);
+	}
+	
+	return n >= size ? size - 1 : n;
+}
+
+static ssize_t validate_flash_read(struct file *file, char *buf,
+			       size_t count, loff_t *ppos)
+{
+	struct proc_dir_entry *dp = file->f_dentry->d_inode->u.generic_ip;
+	struct rtas_validate_flash_t *args_buf;
+	char msg[RTAS_MSG_MAXLEN];
+	int msglen;
+	ssize_t ret;
+
+	if (down_interruptible(&rtas_flash_sem))
+		return -ERESTARTSYS;
+	args_buf = (struct rtas_validate_flash_t *) dp->data;
+
+	msglen = get_validate_flash_msg(args_buf, msg, RTAS_MSG_MAXLEN);
+
+	if (*ppos >= msglen) {
+		ret = 0;
+		goto done;
+	}
+
+	msglen -= *ppos;
+	if (msglen > count)
+		msglen = count;
+
+	if (copy_to_user(buf, msg + (*ppos), msglen)) {
+		ret = -EFAULT;
+		goto done;
+	}
+	*ppos += msglen;
+	ret = msglen;
+
+done:
+	up(&rtas_flash_sem);
+	return ret;
+}
+
+static ssize_t validate_flash_write(struct file *file, const char *buf,
+				size_t count, loff_t *off)
+{
+	struct proc_dir_entry *dp = file->f_dentry->d_inode->u.generic_ip;
+	struct rtas_validate_flash_t *args_buf;
+	ssize_t ret;
+
+	if (down_interruptible(&rtas_flash_sem))
+		return -ERESTARTSYS;
+	args_buf = (struct rtas_validate_flash_t *) dp->data;
+
+	if (dp->data == NULL) {
+		dp->data = kmalloc(sizeof(struct rtas_validate_flash_t), 
+				GFP_KERNEL);
+		if (dp->data == NULL) {
+			ret = -ENOMEM;
+			goto done;
+		}
+	}
+
+	/* We are only interested in the first 4K of the
+	 * candidate image */
+	if ((*off >= VALIDATE_BUF_SIZE) || 
+		(args_buf->status == VALIDATE_AUTH)) {
+		*off += count;
+		ret = count;
+		goto done;
+	}
+
+	if (*off + count >= VALIDATE_BUF_SIZE)  {
+		count = VALIDATE_BUF_SIZE - *off;
+		args_buf->status = VALIDATE_READY;	
+	} else {
+		args_buf->status = VALIDATE_INCOMPLETE;
+	}
+
+	if (copy_from_user(args_buf->buf + *off, buf, count))  {
+		ret = -EFAULT;
+		goto done;
+	}
+	*off += count;
+	ret = count;
+
+done:
+	up(&rtas_flash_sem);
+	return ret;
+}
+
+static int validate_flash_release(struct inode *inode, struct file *file)
+{
+	struct proc_dir_entry *dp = file->f_dentry->d_inode->u.generic_ip;
+	struct rtas_validate_flash_t *args_buf;
+
+	args_buf = (struct rtas_validate_flash_t *) dp->data;
+
+	if (args_buf->status == VALIDATE_READY) {
+		args_buf->buf_size = VALIDATE_BUF_SIZE;
+		validate_flash(args_buf);
+	}
+
+	atomic_dec(&dp->count);
+
+	return 0;
+}
+
+static inline void remove_flash_pde(struct proc_dir_entry *dp)
+{
+	if (dp) {
+		if (dp->data != NULL)
+			kfree(dp->data);
+		remove_proc_entry(dp->name, rtas_proc_dir);
+	}
+}
+
+static inline int initialize_flash_pde_data(const char *rtas_call_name, 
+		                            size_t buf_size,
+					    struct proc_dir_entry *dp)
+{
+	int *status;
+	int token;
+
+	dp->data = kmalloc(buf_size, GFP_KERNEL);
+	if (dp->data == NULL)
+		return -ENOMEM;
+
+	memset(dp->data, 0, buf_size);
+
+	/* This code assumes that the status int is the first member of the
+	 * struct 
+	 */
+	status = (int *) dp->data;
+	token = rtas_token(rtas_call_name);
+	if (token == RTAS_UNKNOWN_SERVICE)
+		*status = FLASH_AUTH;
+	else
+		*status = FLASH_NO_OP;
+
+	return 0;
+}
+
+static inline struct proc_dir_entry * create_flash_pde(const char *filename, 
+					struct file_operations *fops)
+{
+	struct proc_dir_entry *ent = NULL;
+
+	ent = create_proc_entry(filename, S_IRUSR | S_IWUSR, rtas_proc_dir);
+	if (ent != NULL) {
+		ent->nlink = 1;
+		ent->proc_fops = fops;
+		ent->owner = THIS_MODULE;
+	}
+
+	return ent;
 }
 
 static struct file_operations rtas_flash_operations = {
 	read:		rtas_flash_read,
 	write:		rtas_flash_write,
-	open:		rtas_flash_open,
+	open:		rtas_excl_open,
 	release:	rtas_flash_release,
 };
 
+static struct file_operations manage_flash_operations = {
+	read:		manage_flash_read,
+	write:		manage_flash_write,
+	open:		rtas_excl_open,
+	release:	rtas_excl_release,
+};
+
+static struct file_operations validate_flash_operations = {
+	read:		validate_flash_read,
+	write:		validate_flash_write,
+	open:		rtas_excl_open,
+	release:	validate_flash_release,
+};
+
+#define CHECK_PDE_CREATE(_pdevar, _rcvar, _label)	\
+	if (!_pdevar) {					\
+		_rcvar = -ENOMEM;			\
+		goto _label;				\
+	}
+
+#define CHECK_RC(_rc, _label)	\
+	if (_rc != 0) 		\
+		goto _label;
 
 int __init rtas_flash_init(void)
 {
-	struct proc_dir_entry *ent = NULL;
+	int rc;
 
 	if (!rtas_proc_dir) {
-		printk(KERN_WARNING "rtas proc dir does not already exist");
+		printk(KERN_WARNING "%s: rtas proc dir does not already exist",
+				__FUNCTION__);
 		return -ENOENT;
 	}
 
-	if (rtas_token("ibm,update-flash-64-and-reboot") != RTAS_UNKNOWN_SERVICE)
-		flash_possible = 1;
-
-	if ((ent = create_proc_entry(FIRMWARE_FLASH_NAME, S_IRUSR | S_IWUSR, rtas_proc_dir)) != NULL) {
-		ent->nlink = 1;
-		ent->proc_fops = &rtas_flash_operations;
-		ent->owner = THIS_MODULE;
+	firmware_flash_pde = create_flash_pde(FIRMWARE_FLASH_NAME, 
+					      &rtas_flash_operations);
+	CHECK_PDE_CREATE(firmware_flash_pde, rc, done);
+		
+	rc = initialize_flash_pde_data("ibm,update-flash-64-and-reboot",
+			 	       sizeof(struct rtas_update_flash_t), 
+				       firmware_flash_pde);
+	CHECK_RC(rc, done);
+	
+	firmware_update_pde = create_flash_pde(FIRMWARE_UPDATE_NAME, 
+					       &rtas_flash_operations);
+	CHECK_PDE_CREATE(firmware_update_pde, rc, done);
+	
+	rc = initialize_flash_pde_data("ibm,update-flash-64-and-reboot",
+			 	       sizeof(struct rtas_update_flash_t), 
+				       firmware_update_pde);
+	CHECK_RC(rc, done);
+	
+	validate_pde = create_flash_pde(VALIDATE_FLASH_NAME, 
+			      		&validate_flash_operations);
+	CHECK_PDE_CREATE(validate_pde, rc, done);
+	
+	rc = initialize_flash_pde_data("ibm,validate-flash-image",
+		                       sizeof(struct rtas_validate_flash_t), 
+				       validate_pde);
+	CHECK_RC(rc, done);
+	
+	manage_pde = create_flash_pde(MANAGE_FLASH_NAME, 
+				      &manage_flash_operations);
+	CHECK_PDE_CREATE(manage_pde, rc, done);
+	
+	rc = initialize_flash_pde_data("ibm,manage-flash-image",
+			               sizeof(struct rtas_manage_flash_t),
+				       manage_pde);
+done:
+	if (rc != 0) {
+		remove_flash_pde(firmware_flash_pde);
+		remove_flash_pde(firmware_update_pde);
+		remove_flash_pde(validate_pde);
+		remove_flash_pde(manage_pde);
 	}
-	return 0;
+	
+	return rc;
 }
 
 void __exit rtas_flash_cleanup(void)
 {
 	if (!rtas_proc_dir)
 		return;
-	remove_proc_entry(FIRMWARE_FLASH_NAME, rtas_proc_dir);
+
+	remove_flash_pde(firmware_flash_pde);
+	remove_flash_pde(firmware_update_pde);
+	remove_flash_pde(validate_pde);
+	remove_flash_pde(manage_pde);
 }
 
 module_init(rtas_flash_init);
diff -urNp linux-359/arch/ppc64/kernel/rtasd.c linux-360/arch/ppc64/kernel/rtasd.c
--- linux-359/arch/ppc64/kernel/rtasd.c
+++ linux-360/arch/ppc64/kernel/rtasd.c
@@ -17,11 +17,14 @@
 #include <linux/proc_fs.h>
 #include <linux/init.h>
 #include <linux/vmalloc.h>
+#include <linux/spinlock.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/rtas.h>
 #include <asm/prom.h>
+#include <asm/nvram.h>
+#include <asm/atomic.h>
 
 #if 0
 #define DEBUG(A...)	printk(KERN_ERR A)
@@ -29,13 +32,10 @@
 #define DEBUG(A...)
 #endif
 
-static spinlock_t rtas_log_lock = SPIN_LOCK_UNLOCKED;
+static spinlock_t log_lock = SPIN_LOCK_UNLOCKED;
 
 DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);
 
-#define LOG_NUMBER		64		/* must be a power of two */
-#define LOG_NUMBER_MASK		(LOG_NUMBER-1)
-
 static char *rtas_log_buf;
 static unsigned long rtas_log_start;
 static unsigned long rtas_log_size;
@@ -43,23 +43,169 @@ static unsigned long rtas_log_size;
 static int surveillance_requested;
 static unsigned int rtas_event_scan_rate;
 static unsigned int rtas_error_log_max;
-
-#define EVENT_SCAN_ALL_EVENTS	0xf0000000
-#define SURVEILLANCE_TOKEN	9000
-#define SURVEILLANCE_TIMEOUT	1
-#define SURVEILLANCE_SCANRATE	1
-
+static unsigned int rtas_error_log_buffer_max;
+ 
 extern struct proc_dir_entry *proc_ppc64_root;
 extern struct proc_dir_entry *rtas_proc_dir;
 extern spinlock_t proc_ppc64_lock;
+extern volatile int no_more_logging;
+  
+volatile int error_log_cnt = 0;
+  
 /*
  * Since we use 32 bit RTAS, the physical address of this must be below
  * 4G or else bad things happen. Allocate this in the kernel data and
  * make it big enough.
  */
-#define RTAS_ERROR_LOG_MAX 1024
 static unsigned char logdata[RTAS_ERROR_LOG_MAX];
 
+/* To see this info, grep RTAS /var/log/messages and each entry
+ * will be collected together with obvious begin/end.  
+ * There will be a unique identifier on the begin and end lines.
+ * This will persist across reboots.
+ *
+ * format of error logs returned from RTAS:
+ * bytes 	(size)	: contents
+ * --------------------------------------------------------
+ * 0-7		(8)	: rtas_error_log
+ * 8-47		(40) 	: extended info
+ * 48-51	(4)	: vendor id
+ * 52-1023 (vendor specific) : location code and debug data 
+ */
+static void printk_log_rtas(char *buf, int len)
+{
+  
+ 	int i,j,n;
+  	int perline = 16;
+  	char buffer[64];
+  	char * str = "RTAS event";
+   
+	printk(RTAS_DEBUG "%d -------- %s begin --------\n", error_log_cnt, str);
+   
+   	/* 
+   	 * Print perline bytes on each line, each line will start
+   	 * with RTAS and a changing number, so syslogd will  
+   	 * print lines that are otherwise the same.  Separate every
+   	 * 4 bytes with a space.
+   	 */
+   	for (i=0; i < len; i++) {
+   		j = i % perline;
+   		if (j == 0) {
+   			memset(buffer, 0, sizeof(buffer));
+   			n = sprintf(buffer, "RTAS %d:", i/perline);
+   		}
+   
+   		if ((i % 4) == 0)
+   			n += sprintf(buffer+n, " ");
+   
+   		n += sprintf(buffer+n, "%02x", (unsigned char)buf[i]); 
+   
+   		if (j == (perline-1))
+			printk(KERN_DEBUG "%s\n", buffer);
+   	}
+   	if ((i % perline) != 0)
+		printk(KERN_DEBUG "%s\n", buffer);
+   
+	printk(RTAS_DEBUG "%d -------- %s end ----------\n", error_log_cnt, str);
+}
+   
+static int log_rtas_len(char * buf)
+{
+   	int len;
+   	struct rtas_error_log *err;
+   
+   	/* rtas fixed header */
+   	len = 8; 
+   	err = (struct rtas_error_log *)buf;
+   	if (err->extended_log_length) {
+   
+   		/* extended header */
+   		len += err->extended_log_length;
+   
+   		if (len > RTAS_ERROR_LOG_MAX)
+   			len = RTAS_ERROR_LOG_MAX;
+   	}		
+   	return len;
+}
+   
+/* 
+ * First write to nvram, if fatal error, that is the only
+ * place we log the info.  The error will be picked up 
+ * on the next reboot by rtasd.  If not fatal, run the 
+ * method for the type of error.  Currently, only RTAS
+ * errors have methods implemented, but in the future
+ * there might be a need to store data in nvram before a 
+ * call to panic().
+*/
+void pSeries_log_error(char *buf, unsigned int err_type, int fatal)
+{
+  	unsigned long offset;
+   	unsigned long s;
+   	int len = 0;
+   
+   	DEBUG("logging event\n");
+ 
+ 	if (buf == NULL)
+ 		return;
+   
+   	spin_lock_irqsave(&log_lock, s);
+   
+   	/* get length and increase count */
+   	switch (err_type & ERR_TYPE_MASK) {
+   	case ERR_TYPE_RTAS_LOG:
+   		len = log_rtas_len(buf);
+		if (!(err_type & ERR_FLAG_BOOT))
+			error_log_cnt++;
+   		break;
+   	case ERR_TYPE_KERNEL_PANIC:
+   	default:
+   		spin_unlock_irqrestore(&log_lock, s);
+   		return;
+   	}
+   
+   	/* Write error to NVRAM */
+  	if (!no_more_logging & !(err_type & ERR_FLAG_BOOT)) {
+   		write_error_log_nvram(buf, len, err_type);
+	}
+   
+   	/* Check to see if we need to or have stopped logging */
+   	if (fatal || no_more_logging) {
+   		no_more_logging = 1;
+   		spin_unlock_irqrestore(&log_lock, s);		
+   		return;
+   	}
+   
+   	/* call type specific method for error */
+   	switch (err_type & ERR_TYPE_MASK) {
+   	case ERR_TYPE_RTAS_LOG:
+   		/* put into syslog and error_log file */
+   		printk_log_rtas(buf, len);
+  
+   		offset = rtas_error_log_buffer_max *
+   			((rtas_log_start+rtas_log_size) & LOG_NUMBER_MASK);
+  
+  		/* First copy over sequence number */
+  		memcpy(&rtas_log_buf[offset], &error_log_cnt, sizeof(int));
+  
+  		/* Second copy over error log data */
+  		offset += sizeof(int);
+   		memcpy(&rtas_log_buf[offset], buf, len);
+   
+   		if (rtas_log_size < LOG_NUMBER)
+   			rtas_log_size += 1;
+   		else
+   			rtas_log_start += 1;
+   
+   		spin_unlock_irqrestore(&log_lock, s);
+   		wake_up_interruptible(&rtas_log_wait);
+   		break;
+   	case ERR_TYPE_KERNEL_PANIC:
+   	default:
+  		spin_unlock_irqrestore(&log_lock, s);
+   		return;
+   	}
+   
+}
 static int rtas_log_open(struct inode * inode, struct file * file)
 {
 	return 0;
@@ -70,36 +216,50 @@ static int rtas_log_release(struct inode
 	return 0;
 }
 
+/* This will check if all events are logged, if they are then, we
+ * know that we can safely clear the events in NVRAM.
+ * Next we'll sit and wait for something else to log.
+ */
 static ssize_t rtas_log_read(struct file * file, char * buf,
 			 size_t count, loff_t *ppos)
 {
 	int error;
 	char *tmp;
+	unsigned long s;
 	unsigned long offset;
 
-	if (!buf || count < rtas_error_log_max)
+	if (!buf || count < rtas_error_log_buffer_max)
 		return -EINVAL;
 
-	count = rtas_error_log_max;
+	count = rtas_error_log_buffer_max;
 
 	error = verify_area(VERIFY_WRITE, buf, count);
 	if (error)
-		return -EINVAL;
+		return -EFAULT;
 
-	tmp = kmalloc(rtas_error_log_max, GFP_KERNEL);
+	tmp = kmalloc(count, GFP_KERNEL);
 	if (!tmp)
 		return -ENOMEM;
 
+
+	spin_lock_irqsave(&log_lock, s);
+	/* if it's 0, then we know we got the last one (the one in NVRAM) */
+	if (rtas_log_size == 0 && !no_more_logging)
+		clear_error_log_nvram();
+	spin_unlock_irqrestore(&log_lock, s);
+
+
 	error = wait_event_interruptible(rtas_log_wait, rtas_log_size);
 	if (error)
 		goto out;
 
-	spin_lock(&rtas_log_lock);
-	offset = rtas_error_log_max * (rtas_log_start & LOG_NUMBER_MASK);
+	spin_lock_irqsave(&log_lock, s);
+	offset = rtas_error_log_buffer_max * (rtas_log_start & LOG_NUMBER_MASK);
 	memcpy(tmp, &rtas_log_buf[offset], count);
+
 	rtas_log_start += 1;
 	rtas_log_size -= 1;
-	spin_unlock(&rtas_log_lock);
+	spin_unlock_irqrestore(&log_lock, s);
 
 	error = copy_to_user(buf, tmp, count) ? -EFAULT : count;
 out:
@@ -122,593 +282,6 @@ struct file_operations proc_rtas_log_ope
 	.release =	rtas_log_release,
 };
 
-
-#define RTAS_ERR KERN_ERR "RTAS: "
-
-/* Extended error log header (12 bytes) */
-struct exthdr {
-	unsigned int valid:1;
-	unsigned int unrecoverable:1;
-	unsigned int recoverable:1;
-	unsigned int unrecoverable_bypassed:1;	/* i.e. degraded performance */
-	unsigned int predictive:1;
-	unsigned int newlog:1;
-	unsigned int bigendian:1;		/* always 1 */
-	unsigned int /* reserved */:1;
-
-	unsigned int platform_specific:1;	/* only in version 3+ */
-	unsigned int /* reserved */:3;
-	unsigned int platform_value:4;		/* valid iff platform_specific */
-
-	unsigned int power_pc:1;		/* always 1 */
-	unsigned int /* reserved */:2;
-	unsigned int addr_invalid:1;		/* failing_address is invalid */
-	unsigned int format_type:4;
-#define EXTLOG_FMT_CPU 1
-#define EXTLOG_FMT_MEMORY 2
-#define EXTLOG_FMT_IO 3
-#define EXTLOG_FMT_POST 4
-#define EXTLOG_FMT_ENV 5
-#define EXTLOG_FMT_POW 6
-#define EXTLOG_FMT_IBMDIAG 12
-#define EXTLOG_FMT_IBMSP 13
-
-	/* This group is in version 3+ only */
-	unsigned int non_hardware:1;		/* Firmware or software is suspect */
-	unsigned int hot_plug:1;		/* Failing component may be hot plugged */
-	unsigned int group_failure:1;		/* Group of components should be replaced */
-	unsigned int /* reserved */:1;
-
-	unsigned int residual:1;		/* Residual error from previous boot (maybe a crash) */
-	unsigned int boot:1;			/* Error during boot */
-	unsigned int config_change:1;		/* Configuration changed since last boot */
-	unsigned int post:1;			/* Error during POST */
-
-	unsigned int bcdtime:32;		/* Time of error in BCD HHMMSS00 */
-	unsigned int bcddate:32;		/* Time of error in BCD YYYYMMDD */
-};
-
-struct cpuhdr {
-	unsigned int internal:1;
-	unsigned int intcache:1;
-	unsigned int extcache_parity:1;	/* or multi-bit ECC */
-	unsigned int extcache_ecc:1;
-	unsigned int sysbus_timeout:1;
-	unsigned int io_timeout:1;
-	unsigned int sysbus_parity:1;
-	unsigned int sysbus_protocol:1;
-	unsigned int cpuid:8;
-	unsigned int element:16;
-	unsigned int failing_address_hi:32;
-	unsigned int failing_address_lo:32;
-
-	/* These are version 4+ */
-	unsigned int try_reboot:1;	/* 1 => fault may be fixed by reboot */
-	unsigned int /* reserved */:7;
-	/* 15 bytes reserved here */
-};
-
-struct memhdr {
-	unsigned int uncorrectable:1;
-	unsigned int ECC:1;
-	unsigned int threshold_exceeded:1;
-	unsigned int control_internal:1;
-	unsigned int bad_address:1;
-	unsigned int bad_data:1;
-	unsigned int bus:1;
-	unsigned int timeout:1;
-	unsigned int sysbus_parity:1;
-	unsigned int sysbus_timeout:1;
-	unsigned int sysbus_protocol:1;
-	unsigned int hostbridge_timeout:1;
-	unsigned int hostbridge_parity:1;
-	unsigned int reserved1:1;
-	unsigned int support:1;
-	unsigned int sysbus_internal:1;
-	unsigned int mem_controller_detected:8;	/* who detected fault? */
-	unsigned int mem_controller_faulted:8;	/* who caused fault? */
-	unsigned int failing_address_hi:32;
-	unsigned int failing_address_lo:32;
-	unsigned int ecc_syndrome:16;
-	unsigned int memory_card:8;
-	unsigned int reserved2:8;
-	unsigned int sub_elements:32;		/* one bit per element */
-	unsigned int element:16;
-};
-
-struct iohdr {
-	unsigned int bus_addr_parity:1;
-	unsigned int bus_data_parity:1;
-	unsigned int bus_timeout:1;
-	unsigned int bridge_internal:1;
-	unsigned int non_pci:1;		/* i.e. secondary bus such as ISA */
-	unsigned int mezzanine_addr_parity:1;
-	unsigned int mezzanine_data_parity:1;
-	unsigned int mezzanine_timeout:1;
-
-	unsigned int bridge_via_sysbus:1;
-	unsigned int bridge_via_mezzanine:1;
-	unsigned int bridge_via_expbus:1;
-	unsigned int detected_by_expbus:1;
-	unsigned int expbus_data_parity:1;
-	unsigned int expbus_timeout:1;
-	unsigned int expbus_connection_failure:1;
-	unsigned int expbus_not_operating:1;
-
-	/* IOA signalling the error */
-	unsigned int pci_sig_busno:8;
-	unsigned int pci_sig_devfn:8;
-	unsigned int pci_sig_deviceid:16;
-	unsigned int pci_sig_vendorid:16;
-	unsigned int pci_sig_revisionid:8;
-	unsigned int pci_sig_slot:8;	/* 00 => system board, ff => multiple */
-
-	/* IOA sending at time of error */
-	unsigned int pci_send_busno:8;
-	unsigned int pci_send_devfn:8;
-	unsigned int pci_send_deviceid:16;
-	unsigned int pci_send_vendorid:16;
-	unsigned int pci_send_revisionid:8;
-	unsigned int pci_send_slot:8;	/* 00 => system board, ff => multiple */
-};
-
-struct posthdr {
-	unsigned int firmware:1;
-	unsigned int config:1;
-	unsigned int cpu:1;
-	unsigned int memory:1;
-	unsigned int io:1;
-	unsigned int keyboard:1;
-	unsigned int mouse:1;
-	unsigned int display:1;
-
-	unsigned int ipl_floppy:1;
-	unsigned int ipl_controller:1;
-	unsigned int ipl_cdrom:1;
-	unsigned int ipl_disk:1;
-	unsigned int ipl_net:1;
-	unsigned int ipl_other:1;
-	unsigned int /* reserved */:1;
-	unsigned int firmware_selftest:1;
-
-	char         devname[12];
-	unsigned int post_code:4;
-	unsigned int firmware_rev:2;
-	unsigned int loc_code:8;	/* currently unused */
-};
-
-struct epowhdr {
-	unsigned int epow_sensor_value:32;
-	unsigned int sensor:1;
-	unsigned int power_fault:1;
-	unsigned int fan:1;
-	unsigned int temp:1;
-	unsigned int redundancy:1;
-	unsigned int CUoD:1;
-	unsigned int /* reserved */:2;
-
-	unsigned int general:1;
-	unsigned int power_loss:1;
-	unsigned int power_supply:1;
-	unsigned int power_switch:1;
-	unsigned int /* reserved */:4;
-
-	unsigned int /* reserved */:16;
-	unsigned int sensor_token:32;
-	unsigned int sensor_index:32;
-	unsigned int sensor_value:32;
-	unsigned int sensor_status:32;
-};
-
-struct pm_eventhdr {
-	unsigned int event_id:32;
-};
-
-struct sphdr {
-	unsigned int ibm:32;	/* "IBM\0" */
-
-	unsigned int timeout:1;
-	unsigned int i2c_bus:1;
-	unsigned int i2c_secondary_bus:1;
-	unsigned int sp_memory:1;
-	unsigned int sp_registers:1;
-	unsigned int sp_communication:1;
-	unsigned int sp_firmware:1;
-	unsigned int sp_hardware:1;
-
-	unsigned int vpd_eeprom:1;
-	unsigned int op_panel:1;
-	unsigned int power_controller:1;
-	unsigned int fan_sensor:1;
-	unsigned int thermal_sensor:1;
-	unsigned int voltage_sensor:1;
-	unsigned int reserved1:2;
-
-	unsigned int serial_port:1;
-	unsigned int nvram:1;
-	unsigned int rtc:1;
-	unsigned int jtag:1;
-	unsigned int tod_battery:1;
-	unsigned int reserved2:1;
-	unsigned int heartbeat:1;
-	unsigned int surveillance:1;
-
-	unsigned int pcn_connection:1;	/* power control network */
-	unsigned int pcn_node:1;
-	unsigned int reserved3:2;
-	unsigned int pcn_access:1;
-	unsigned int reserved:3;
-
-	unsigned int sensor_token:32;	/* zero if undef */
-	unsigned int sensor_index:32;	/* zero if undef */
-};
-
-
-static char *severity_names[] = {
-	"NO ERROR", "EVENT", "WARNING", "ERROR_SYNC", "ERROR", "FATAL", "(6)", "(7)"
-};
-static char *rtas_disposition_names[] = {
-	"FULLY RECOVERED", "LIMITED RECOVERY", "NOT RECOVERED", "(4)"
-};
-static char *entity_names[] = { /* for initiator & targets */
-	"UNKNOWN", "CPU", "PCI", "ISA", "MEMORY", "POWER MANAGEMENT", "HOT PLUG", "(7)", "(8)",
-	"(9)", "(10)", "(11)", "(12)", "(13)", "(14)", "(15)"
-};
-static char *error_type[] = {	/* Not all types covered here so need to bounds check */
-	"UNKNOWN", "RETRY", "TCE_ERR", "INTERN_DEV_FAIL",
-	"TIMEOUT", "DATA_PARITY", "ADDR_PARITY", "CACHE_PARITY",
-	"ADDR_INVALID", "ECC_UNCORR", "ECC_CORR",
-};
-
-static char *rtas_error_type(int type)
-{
-	if (type < 11)
-		return error_type[type];
-	if (type == 64)
-		return "SENSOR";
-	if (type >=96 && type <= 159)
-		return "POWER";
-	return error_type[0];
-}
-
-static void printk_cpu_failure(int version, struct exthdr *exthdr, char *data)
-{
-	struct cpuhdr cpuhdr;
-
-	memcpy(&cpuhdr, data, sizeof(cpuhdr));
-
-	if (cpuhdr.internal) printk(RTAS_ERR "Internal error (not cache)\n");
-	if (cpuhdr.intcache) printk(RTAS_ERR "Internal cache\n");
-	if (cpuhdr.extcache_parity) printk(RTAS_ERR "External cache parity (or multi-bit)\n");
-	if (cpuhdr.extcache_ecc) printk(RTAS_ERR "External cache ECC\n");
-	if (cpuhdr.sysbus_timeout) printk(RTAS_ERR "System bus timeout\n");
-	if (cpuhdr.io_timeout) printk(RTAS_ERR "I/O timeout\n");
-	if (cpuhdr.sysbus_parity) printk(RTAS_ERR "System bus parity\n");
-	if (cpuhdr.sysbus_protocol) printk(RTAS_ERR "System bus protocol/transfer\n");
-	printk(RTAS_ERR "CPU id: %d\n", cpuhdr.cpuid);
-	printk(RTAS_ERR "Failing element: 0x%04x\n", cpuhdr.element);
-	if (!exthdr->addr_invalid)
-		printk(RTAS_ERR "Failing address: %08x%08x\n", cpuhdr.failing_address_hi, cpuhdr.failing_address_lo);
-	if (version >= 4 && cpuhdr.try_reboot)
-		printk(RTAS_ERR "A reboot of the system may correct the problem\n");
-}
-
-static void printk_mem_failure(int version, struct exthdr *exthdr, char *data)
-{
-	struct memhdr memhdr;
-
-	memcpy(&memhdr, data, sizeof(memhdr));
-	if (memhdr.uncorrectable) printk(RTAS_ERR "Uncorrectable Memory error\n");
-	if (memhdr.ECC) printk(RTAS_ERR "ECC Correctable error\n");
-	if (memhdr.threshold_exceeded) printk(RTAS_ERR "Correctable threshold exceeded\n");
-	if (memhdr.control_internal) printk(RTAS_ERR "Memory Controller internal error\n");
-	if (memhdr.bad_address) printk(RTAS_ERR "Memory Address error\n");
-	if (memhdr.bad_data) printk(RTAS_ERR "Memory Data error\n");
-	if (memhdr.bus) printk(RTAS_ERR "Memory bus/switch internal error\n");
-	if (memhdr.timeout) printk(RTAS_ERR "Memory timeout\n");
-	if (memhdr.sysbus_parity) printk(RTAS_ERR "System bus parity\n");
-	if (memhdr.sysbus_timeout) printk(RTAS_ERR "System bus timeout\n");
-	if (memhdr.sysbus_protocol) printk(RTAS_ERR "System bus protocol/transfer\n");
-	if (memhdr.hostbridge_timeout) printk(RTAS_ERR "I/O Host Bridge timeout\n");
-	if (memhdr.hostbridge_parity) printk(RTAS_ERR "I/O Host Bridge parity\n");
-	if (memhdr.support) printk(RTAS_ERR "System support function error\n");
-	if (memhdr.sysbus_internal) printk(RTAS_ERR "System bus internal hardware/switch error\n");
-	printk(RTAS_ERR "Memory Controller that detected failure: %d\n", memhdr.mem_controller_detected);
-	printk(RTAS_ERR "Memory Controller that faulted: %d\n", memhdr.mem_controller_faulted);
-	if (!exthdr->addr_invalid)
-		printk(RTAS_ERR "Failing address: 0x%016x%016x\n", memhdr.failing_address_hi, memhdr.failing_address_lo);
-	printk(RTAS_ERR "ECC syndrome bits: 0x%04x\n", memhdr.ecc_syndrome);
-	printk(RTAS_ERR "Memory Card: %d\n", memhdr.memory_card);
-	printk(RTAS_ERR "Failing element: 0x%04x\n", memhdr.element);
-	printk(RTAS_ERR "Sub element bits: 0x%08x\n", memhdr.sub_elements);
-}
-
-static void printk_io_failure(int version, struct exthdr *exthdr, char *data)
-{
-	struct iohdr iohdr;
-
-	memcpy(&iohdr, data, sizeof(iohdr));
-	if (iohdr.bus_addr_parity) printk(RTAS_ERR "I/O bus address parity\n");
-	if (iohdr.bus_data_parity) printk(RTAS_ERR "I/O bus data parity\n");
-	if (iohdr.bus_timeout) printk(RTAS_ERR "I/O bus timeout, access or other\n");
-	if (iohdr.bridge_internal) printk(RTAS_ERR "I/O bus bridge/device internal\n");
-	if (iohdr.non_pci) printk(RTAS_ERR "Signaling IOA is a PCI to non-PCI bridge (e.g. ISA)\n");
-	if (iohdr.mezzanine_addr_parity) printk(RTAS_ERR "Mezzanine/System bus address parity\n");
-	if (iohdr.mezzanine_data_parity) printk(RTAS_ERR "Mezzanine/System bus data parity\n");
-	if (iohdr.mezzanine_timeout) printk(RTAS_ERR "Mezzanine/System bus timeout, transfer or protocol\n");
-	if (iohdr.bridge_via_sysbus) printk(RTAS_ERR "Bridge is connected to system bus\n");
-	if (iohdr.bridge_via_mezzanine) printk(RTAS_ERR "Bridge is connected to memory controller via mezzanine bus\n");
-	if (iohdr.bridge_via_expbus) printk(RTAS_ERR "Bridge is connected to I/O expansion bus\n");
-	if (iohdr.detected_by_expbus) printk(RTAS_ERR "Error on system bus detected by I/O expansion bus controller\n");
-	if (iohdr.expbus_data_parity) printk(RTAS_ERR "I/O expansion bus data error\n");
-	if (iohdr.expbus_timeout) printk(RTAS_ERR "I/O expansion bus timeout, access or other\n");
-	if (iohdr.expbus_connection_failure) printk(RTAS_ERR "I/O expansion bus connection failure\n");
-	if (iohdr.expbus_not_operating) printk(RTAS_ERR "I/O expansion unit not in an operating state (powered off, off-line)\n");
-
-	printk(RTAS_ERR "IOA Signaling the error: %d:%d.%d vendor:%04x device:%04x rev:%02x slot:%d\n",
-	       iohdr.pci_sig_busno, iohdr.pci_sig_devfn >> 3, iohdr.pci_sig_devfn & 0x7,
-	       iohdr.pci_sig_vendorid, iohdr.pci_sig_deviceid, iohdr.pci_sig_revisionid, iohdr.pci_sig_slot);
-	printk(RTAS_ERR "IOA Sending during the error: %d:%d.%d vendor:%04x device:%04x rev:%02x slot:%d\n",
-	       iohdr.pci_send_busno, iohdr.pci_send_devfn >> 3, iohdr.pci_send_devfn & 0x7,
-	       iohdr.pci_send_vendorid, iohdr.pci_send_deviceid, iohdr.pci_send_revisionid, iohdr.pci_send_slot);
-
-}
-
-static void printk_post_failure(int version, struct exthdr *exthdr, char *data)
-{
-	struct posthdr posthdr;
-
-	memcpy(&posthdr, data, sizeof(posthdr));
-
-	if (posthdr.devname[0]) printk(RTAS_ERR "Failing Device: %s\n", posthdr.devname);
-	if (posthdr.firmware) printk(RTAS_ERR "Firmware Error\n");
-	if (posthdr.config) printk(RTAS_ERR "Configuration Error\n");
-	if (posthdr.cpu) printk(RTAS_ERR "CPU POST Error\n");
-	if (posthdr.memory) printk(RTAS_ERR "Memory POST Error\n");
-	if (posthdr.io) printk(RTAS_ERR "I/O Subsystem POST Error\n");
-	if (posthdr.keyboard) printk(RTAS_ERR "Keyboard POST Error\n");
-	if (posthdr.mouse) printk(RTAS_ERR "Mouse POST Error\n");
-	if (posthdr.display) printk(RTAS_ERR "Display POST Error\n");
-
-	if (posthdr.ipl_floppy) printk(RTAS_ERR "Floppy IPL Error\n");
-	if (posthdr.ipl_controller) printk(RTAS_ERR "Drive Controller Error during IPL\n");
-	if (posthdr.ipl_cdrom) printk(RTAS_ERR "CDROM IPL Error\n");
-	if (posthdr.ipl_disk) printk(RTAS_ERR "Disk IPL Error\n");
-	if (posthdr.ipl_net) printk(RTAS_ERR "Network IPL Error\n");
-	if (posthdr.ipl_other) printk(RTAS_ERR "Other (tape,flash) IPL Error\n");
-	if (posthdr.firmware_selftest) printk(RTAS_ERR "Self-test error in firmware extended diagnostics\n");
-	printk(RTAS_ERR "POST Code: %d\n", posthdr.post_code);
-	printk(RTAS_ERR "Firmware Revision Code: %d\n", posthdr.firmware_rev);
-}
-
-static void printk_epow_warning(int version, struct exthdr *exthdr, char *data)
-{
-	struct epowhdr epowhdr;
-
-	memcpy(&epowhdr, data, sizeof(epowhdr));
-	printk(RTAS_ERR "EPOW Sensor Value:  0x%08x\n", epowhdr.epow_sensor_value); 
-	if (epowhdr.sensor) {
-		printk(RTAS_ERR "EPOW detected by a sensor\n");
-		printk(RTAS_ERR "Sensor Token:  0x%08x\n", epowhdr.sensor_token); 
-		printk(RTAS_ERR "Sensor Index:  0x%08x\n", epowhdr.sensor_index); 
-		printk(RTAS_ERR "Sensor Value:  0x%08x\n", epowhdr.sensor_value); 
-		printk(RTAS_ERR "Sensor Status: 0x%08x\n", epowhdr.sensor_status);
-	}
-	if (epowhdr.power_fault) printk(RTAS_ERR "EPOW caused by a power fault\n");
-	if (epowhdr.fan) printk(RTAS_ERR "EPOW caused by fan failure\n");
-	if (epowhdr.temp) printk(RTAS_ERR "EPOW caused by over-temperature condition\n");
-	if (epowhdr.redundancy) printk(RTAS_ERR "EPOW warning due to loss of redundancy\n");
-	if (epowhdr.CUoD) printk(RTAS_ERR "EPOW warning due to CUoD Entitlement Exceeded\n");
-
-	if (epowhdr.general) printk(RTAS_ERR "EPOW general power fault\n");
-	if (epowhdr.power_loss) printk(RTAS_ERR "EPOW power fault due to loss of power source\n");
-	if (epowhdr.power_supply) printk(RTAS_ERR "EPOW power fault due to internal power supply failure\n");
-	if (epowhdr.power_switch) printk(RTAS_ERR "EPOW power fault due to activation of power switch\n");
-}
-
-static void printk_pm_event(int version, struct exthdr *exthdr, char *data)
-{
-	struct pm_eventhdr pm_eventhdr;
-
-	memcpy(&pm_eventhdr, data, sizeof(pm_eventhdr));
-	printk(RTAS_ERR "Event id: 0x%08x\n", pm_eventhdr.event_id);
-}
-
-static void printk_sp_log_msg(int version, struct exthdr *exthdr, char *data)
-{
-	struct sphdr sphdr;
-	u32 eyecatcher;
-
-	memcpy(&sphdr, data, sizeof(sphdr));
-
-	eyecatcher = sphdr.ibm;
-	if (strcmp((char *)&eyecatcher, "IBM") != 0)
-		printk(RTAS_ERR "This log entry may be corrupt (IBM signature malformed)\n");
-	if (sphdr.timeout) printk(RTAS_ERR "Timeout on communication response from service processor\n");
-	if (sphdr.i2c_bus) printk(RTAS_ERR "I2C general bus error\n");
-	if (sphdr.i2c_secondary_bus) printk(RTAS_ERR "I2C secondary bus error\n");
-	if (sphdr.sp_memory) printk(RTAS_ERR "Internal service processor memory error\n");
-	if (sphdr.sp_registers) printk(RTAS_ERR "Service processor error accessing special registers\n");
-	if (sphdr.sp_communication) printk(RTAS_ERR "Service processor reports unknown communcation error\n");
-	if (sphdr.sp_firmware) printk(RTAS_ERR "Internal service processor firmware error\n");
-	if (sphdr.sp_hardware) printk(RTAS_ERR "Other internal service processor hardware error\n");
-	if (sphdr.vpd_eeprom) printk(RTAS_ERR "Service processor error accessing VPD EEPROM\n");
-	if (sphdr.op_panel) printk(RTAS_ERR "Service processor error accessing Operator Panel\n");
-	if (sphdr.power_controller) printk(RTAS_ERR "Service processor error accessing Power Controller\n");
-	if (sphdr.fan_sensor) printk(RTAS_ERR "Service processor error accessing Fan Sensor\n");
-	if (sphdr.thermal_sensor) printk(RTAS_ERR "Service processor error accessing Thermal Sensor\n");
-	if (sphdr.voltage_sensor) printk(RTAS_ERR "Service processor error accessing Voltage Sensor\n");
-	if (sphdr.serial_port) printk(RTAS_ERR "Service processor error accessing serial port\n");
-	if (sphdr.nvram) printk(RTAS_ERR "Service processor detected NVRAM error\n");
-	if (sphdr.rtc) printk(RTAS_ERR "Service processor error accessing real time clock\n");
-	if (sphdr.jtag) printk(RTAS_ERR "Service processor error accessing JTAG/COP\n");
-	if (sphdr.tod_battery) printk(RTAS_ERR "Service processor or RTAS detects loss of voltage from TOD battery\n");
-	if (sphdr.heartbeat) printk(RTAS_ERR "Loss of heartbeat from Service processor\n");
-	if (sphdr.surveillance) printk(RTAS_ERR "Service processor detected a surveillance timeout\n");
-	if (sphdr.pcn_connection) printk(RTAS_ERR "Power Control Network general connection failure\n");
-	if (sphdr.pcn_node) printk(RTAS_ERR "Power Control Network node failure\n");
-	if (sphdr.pcn_access) printk(RTAS_ERR "Service processor error accessing Power Control Network\n");
-
-	if (sphdr.sensor_token) printk(RTAS_ERR "Sensor Token 0x%08x (%d)\n", sphdr.sensor_token, sphdr.sensor_token);
-	if (sphdr.sensor_index) printk(RTAS_ERR "Sensor Index 0x%08x (%d)\n", sphdr.sensor_index, sphdr.sensor_index);
-}
-
-
-static void printk_ext_raw_data(char *data)
-{
-	int i;
-	printk(RTAS_ERR "raw ext data: ");
-	for (i = 0; i < 40; i++) {
-		printk("%02x", data[i]);
-	}
-	printk("\n");
-}
-
-static void printk_ext_log_data(int version, char *buf)
-{
-	char *data = buf+12;
-	struct exthdr exthdr;
-	memcpy(&exthdr, buf, sizeof(exthdr));	/* copy for alignment */
-	if (!exthdr.valid) {
-		if (exthdr.bigendian && exthdr.power_pc)
-			printk(RTAS_ERR "extended log data is not valid\n");
-		else
-			printk(RTAS_ERR "extended log data can not be decoded\n");
-		return;
-	}
-
-	/* Dump useful stuff in the exthdr */
-	printk(RTAS_ERR "Status:%s%s%s%s%s\n",
-	       exthdr.unrecoverable ? " unrecoverable" : "",
-	       exthdr.recoverable ? " recoverable" : "",
-	       exthdr.unrecoverable_bypassed ? " bypassed" : "",
-	       exthdr.predictive ? " predictive" : "",
-	       exthdr.newlog ? " new" : "");
-	printk(RTAS_ERR "Date/Time: %08x %08x\n", exthdr.bcddate, exthdr.bcdtime);
-	switch (exthdr.format_type) {
-	    case EXTLOG_FMT_CPU:
-		printk(RTAS_ERR "CPU Failure\n");
-		printk_cpu_failure(version, &exthdr, data);
-		break;
-	    case EXTLOG_FMT_MEMORY:
-		printk(RTAS_ERR "Memory Failure\n");
-		printk_mem_failure(version, &exthdr, data);
-		break;
-	    case EXTLOG_FMT_IO:
-		printk(RTAS_ERR "I/O Failure\n");
-		printk_io_failure(version, &exthdr, data);
-		break;
-	    case EXTLOG_FMT_POST:
-		printk(RTAS_ERR "POST Failure\n");
-		printk_post_failure(version, &exthdr, data);
-		break;
-	    case EXTLOG_FMT_ENV:
-		printk(RTAS_ERR "Environment and Power Warning\n");
-		printk_epow_warning(version, &exthdr, data);
-		break;
-	    case EXTLOG_FMT_POW:
-		printk(RTAS_ERR "Power Management Event\n");
-		printk_pm_event(version, &exthdr, data);
-		break;
-	    case EXTLOG_FMT_IBMDIAG:
-		printk(RTAS_ERR "IBM Diagnostic Log\n");
-		printk_ext_raw_data(data);
-		break;
-	    case EXTLOG_FMT_IBMSP:
-		printk(RTAS_ERR "IBM Service Processor Log\n");
-		printk_sp_log_msg(version, &exthdr, data);
-		break;
-	    default:
-		printk(RTAS_ERR "Unknown ext format type %d\n", exthdr.format_type);
-		printk_ext_raw_data(data);
-		break;
-	}
-}
-
-#define MAX_LOG_DEBUG 10
-#define MAX_LOG_DEBUG_LEN 900
-/* Print log debug data.  This appears after the location code.
- * We limit the number of debug logs in case the data is somehow corrupt.
- */
-static void printk_log_debug(char *buf)
-{
-	unsigned char *p = (unsigned char *)_ALIGN((unsigned long)buf, 4);
-	int len, n, logged;
-
-	logged = 0;
-	while ((logged < MAX_LOG_DEBUG) && (len = ((p[0] << 8) | p[1])) >= 4) {
-		if (len > MAX_LOG_DEBUG_LEN)
-			len = MAX_LOG_DEBUG_LEN;	/* bound it */
-		printk("RTAS: Log Debug: %c%c ", p[2], p[3]);
-		for (n=4; n < len; n++)
-			printk("%02x", p[n]);
-		printk("\n");
-		p = (unsigned char *)_ALIGN((unsigned long)p+len, 4);
-		logged++;
-		if (len == MAX_LOG_DEBUG_LEN)
-			return;	/* no point continuing */
-	}
-	if (logged == 0)
-		printk("RTAS: no log debug data present\n");
-}
-
-
-/* Yeah, the output here is ugly, but we want a CE to be
- * able to grep RTAS /var/log/messages and see all the info
- * collected together with obvious begin/end.
- */
-static void printk_log_rtas(char *buf)
-{
-	struct rtas_error_log *err = (struct rtas_error_log *)buf;
-
-	printk(RTAS_ERR "-------- event-scan begin --------\n");
-	if (strcmp(buf+8+40, "IBM") == 0) {
-		/* Location code follows */
-		char *loc = buf+8+40+4;
-		int len = strlen(loc);
-		if (len < 64) {	/* Sanity check */
-			printk(RTAS_ERR "Location Code: %s\n", loc);
-			printk_log_debug(loc+len+1);
-		}
-	}
-
-	printk(RTAS_ERR "%s: (%s) type: %s\n",
-	       severity_names[err->severity],
-	       rtas_disposition_names[err->disposition],
-	       rtas_error_type(err->type));
-	printk(RTAS_ERR "initiator: %s  target: %s\n",
-	       entity_names[err->initiator], entity_names[err->target]);
-	if (err->extended_log_length)
-		printk_ext_log_data(err->version, buf+8);
-	printk(RTAS_ERR "-------- event-scan end ----------\n");
-}
-
-
-static void log_rtas(char *buf)
-{
-	unsigned long offset;
-
-	DEBUG("logging rtas event\n");
-
-	/* Temporary -- perhaps we can do this when nobody has the log open? */
-	printk_log_rtas(buf);
-
-	spin_lock(&rtas_log_lock);
-
-	offset = rtas_error_log_max *
-			((rtas_log_start+rtas_log_size) & LOG_NUMBER_MASK);
-
-	memcpy(&rtas_log_buf[offset], buf, rtas_error_log_max);
-
-	if (rtas_log_size < LOG_NUMBER)
-		rtas_log_size += 1;
-	else
-		rtas_log_start += 1;
-
-	spin_unlock(&rtas_log_lock);
-	wake_up_interruptible(&rtas_log_wait);
-}
-
 static int enable_surveillance(void)
 {
 	int error;
@@ -754,6 +327,9 @@ static int get_eventscan_parms(void)
 		rtas_error_log_max = RTAS_ERROR_LOG_MAX;
 	}
 
+	/* Make room for the sequence number */
+	rtas_error_log_buffer_max = rtas_error_log_max + sizeof(int);
+
 	return 0;
 }
 
@@ -761,20 +337,25 @@ extern long sys_sched_get_priority_max(i
 
 static int rtasd(void *unused)
 {
+	unsigned int err_type;
+	unsigned long s;
 	int cpu = 0;
 	int error;
 	int first_pass = 1;
 	int event_scan = rtas_token("event-scan");
+	int rc;
 
 	if (event_scan == RTAS_UNKNOWN_SERVICE || get_eventscan_parms() == -1)
 		goto error;
 
-	rtas_log_buf = vmalloc(rtas_error_log_max*LOG_NUMBER);
+	rtas_log_buf = vmalloc(rtas_error_log_buffer_max*LOG_NUMBER);
 	if (!rtas_log_buf) {
 		printk(KERN_ERR "rtasd: no memory\n");
 		goto error;
 	}
 
+	no_more_logging = 0;
+
 	DEBUG("will sleep for %d jiffies\n", (HZ*60/rtas_event_scan_rate) / 2);
 
 	daemonize();
@@ -788,7 +369,19 @@ static int rtasd(void *unused)
 	current->cpus_allowed = 1UL << cpu_logical_map(cpu);
 	schedule();
 
+	/* See if we have any error stored in NVRAM */
+	memset(logdata, 0, rtas_error_log_max);
+	
+	rc = read_error_log_nvram(logdata, rtas_error_log_max, &err_type);
+	if (!rc) {
+		if (err_type != ERR_FLAG_ALREADY_LOGGED) {
+			pSeries_log_error(logdata, err_type | ERR_FLAG_BOOT, 0);
+		}
+	}
+
 	while(1) {
+
+
 		do {
 			memset(logdata, 0, rtas_error_log_max);
 			error = rtas_call(event_scan, 4, 1, NULL,
@@ -800,10 +393,10 @@ static int rtasd(void *unused)
 			}
 
 			if (error == 0)
-				log_rtas(logdata);
+				pSeries_log_error(logdata, ERR_TYPE_RTAS_LOG, 0);
 
 		} while(error == 0);
-
+		
 		DEBUG("watchdog scheduled on cpu %d\n", smp_processor_id());
 
 		cpu++;
diff -urNp linux-359/arch/ppc64/kernel/traps.c linux-360/arch/ppc64/kernel/traps.c
--- linux-359/arch/ppc64/kernel/traps.c
+++ linux-360/arch/ppc64/kernel/traps.c
@@ -42,6 +42,7 @@
 #include <asm/io.h>
 #include <asm/processor.h>
 #include <asm/ppcdebug.h>
+#include <asm/rtas.h>
 #include <asm/machdep.h> /* for ppc_attention_msg */
 
 extern int fix_alignment(struct pt_regs *);
@@ -49,6 +50,8 @@ extern void bad_page_fault(struct pt_reg
 
 /* This is true if we are using the firmware NMI handler (typically LPAR) */
 extern int fwnmi_active;
+/* This is true if we are using a check-exception based handler */
+extern int check_exception_flag;
 
 #ifdef CONFIG_XMON
 extern int xmon_enabled;
@@ -92,6 +95,9 @@ void (*debugger_fault_handler)(struct pt
 
 void set_local_DABR(void *valp);
 
+/* do not want to kmalloc or wait on lock during machine check */
+char mce_data_buf[RTAS_ERROR_LOG_MAX]__page_aligned;
+
 /*
  * Trap & Exception support
  */
@@ -136,7 +142,9 @@ static struct rtas_error_log *FWNMI_get_
 	    (errdata >= rtas.base && errdata < rtas.base + rtas.size - 16)) {
 		savep = __va(errdata);
 		regs->gpr[3] = savep[0];	/* restore original r3 */
-		errhdr = (struct rtas_error_log *)(savep + 1);
+		memset(mce_data_buf, 0, RTAS_ERROR_LOG_MAX);
+		memcpy(mce_data_buf, (char *)(savep + 1), RTAS_ERROR_LOG_MAX);
+		errhdr = (struct rtas_error_log *)mce_data_buf;
 	} else {
 		printk("FWNMI: corrupt r3\n");
 	}
@@ -194,17 +202,89 @@ SystemResetException(struct pt_regs *reg
 #endif
 }
 
-
+/* 
+ * See if we can recover from a machine check exception.
+ * This is only called on power4 (or above) and only via
+ * the Firmware Non-Maskable Interrupts (fwnmi) handler
+ * which provides the error analysis for us.
+ *
+ * Return 1 if corrected (or delivered a signal).
+ * Return 0 if there is nothing we can do.
+ */
+static int recover_mce(struct pt_regs *regs, struct rtas_error_log *errp)
+{
+  	siginfo_t info;
+ 	int nonfatal = 0;
+ 	
+  
+  	if (errp->disposition == DISP_FULLY_RECOVERED) {
+  		/* Platform corrected itself */
+ 		nonfatal = 1;
+  	} else if ((regs->msr & MSR_RI) &&
+  		   user_mode(regs) &&
+  		   errp->severity == SEVERITY_ERROR_SYNC &&
+  		   errp->disposition == DISP_NOT_RECOVERED &&
+  		   errp->target == TARGET_MEMORY &&
+  		   errp->type == TYPE_ECC_UNCORR &&
+  		   !(current->pid == 0 || current->pid == 1)) {
+  
+  		/* Kill off a user process with an ECC error */
+  		printk(KERN_ERR "MCE: uncorrectable ecc error killed process %d (%s).\n", current->pid, current->comm);
+  
+  		info.si_signo = SIGBUS;
+  		info.si_errno = 0;
+  		/* XXX better si_code for ECC error? */
+  		info.si_code = BUS_ADRERR;
+  		info.si_addr = (void *)regs->nip;
+  		_exception(SIGBUS, &info, regs);
+  		nonfatal = 1;
+  	}
+ 
+ 	log_error((char *)errp, ERR_TYPE_RTAS_LOG, !nonfatal);
+ 
+  	return nonfatal;
+}
+  
+/*
+ * Handle a machine check.
+ *
+ * Note that on Power 4 and beyond Firmware Non-Maskable Interrupts (fwnmi)
+ * should be present.  If so the handler which called us tells us if the
+ * error was recovered (never true if RI=0).
+ *
+ * On hardware prior to Power 4 these exceptions were asynchronous which
+ * means we can't tell exactly where it occurred and so we can't recover.
+ *
+ * Note that the debugger should test RI=0 and warn the user that system
+ * state has been corrupted.
+ */
 void
 MachineCheckException(struct pt_regs *regs)
 {
+ 	struct rtas_error_log *errp;
+ 	
 	if (fwnmi_active) {
-		struct rtas_error_log *errhdr = FWNMI_get_errinfo(regs);
-		if (errhdr) {
-			/* ToDo: attempt to recover from some errors here */
-		}
-		FWNMI_release_errinfo();
-	}
+ 		errp = FWNMI_get_errinfo(regs);
+  		FWNMI_release_errinfo();	
+  		if (errp && recover_mce(regs, errp))
+  			return;		
+ 	} else if (check_exception_flag) {
+  		int status;
+  		unsigned long long srr1 = regs->msr;
+		int rtas_bufflen = rtas_get_error_log_max();
+  
+  		memset(mce_data_buf, 0, RTAS_ERROR_LOG_MAX);
+  		/* XXX
+  		 * We only pass the low 32 bits of SRR1, this could
+  		 * be changed to 7 input params and the high 32 bits
+  		 * of SRR1 could be passed as the extended info argument.
+  		 */
+  		status = rtas_call(rtas_token("check-exception"), 6, 1, NULL,
+  				   0x200, (uint)srr1, INTERNAL_ERROR, 0,
+  				   __pa(mce_data_buf), rtas_bufflen);
+  		if (status == 0)
+			log_error((char *)mce_data_buf, ERR_TYPE_RTAS_LOG, 1);
+  	}
 
 #if defined(CONFIG_XMON) || defined(CONFIG_KGDB)
 	if (debugger_fault_handler) {
diff -urNp linux-359/include/asm-ppc64/eeh.h linux-360/include/asm-ppc64/eeh.h
--- linux-359/include/asm-ppc64/eeh.h
+++ linux-360/include/asm-ppc64/eeh.h
@@ -79,11 +79,14 @@ extern void *memset(void *,int, unsigned
  * If this macro yields TRUE, the caller relays to eeh_check_failure()
  * which does further tests out of line.
  */
-/* #define EEH_POSSIBLE_IO_ERROR(val) (~(val) == 0) */
-/* #define EEH_POSSIBLE_ERROR(addr, vaddr, val) ((vaddr) != (addr) && EEH_POSSIBLE_IO_ERROR(val) */
-/* This version is rearranged to collect some profiling data */
-#define EEH_POSSIBLE_IO_ERROR(val) (~(val) == 0 && ++eeh_total_mmio_ffs)
-#define EEH_POSSIBLE_ERROR(addr, vaddr, val) (EEH_POSSIBLE_IO_ERROR(val) && (vaddr) != (addr))
+#define EEH_POSSIBLE_IO_ERROR(val, type) ((val) == (type)~0)
+
+/* The vaddr will equal the addr if EEH checking is disabled for
+ * this device.  This is because eeh_ioremap() will not have
+ * remapped to 0xA0, and thus both vaddr and addr will be 0xE0...
+ */
+#define EEH_POSSIBLE_ERROR(addr, vaddr, val, type) \
+	((vaddr) != (addr) && EEH_POSSIBLE_IO_ERROR(val, type))
 
 /* 
  * MMIO read/write operations with EEH support.
@@ -102,7 +105,7 @@ extern void *memset(void *,int, unsigned
 static inline u8 eeh_readb(void *addr) {
 	volatile u8 *vaddr = (volatile u8 *)IO_TOKEN_TO_ADDR(addr);
 	u8 val = in_8(vaddr);
-	if (EEH_POSSIBLE_ERROR(addr, vaddr, val))
+	if (EEH_POSSIBLE_ERROR(addr, vaddr, val, u8))
 		return eeh_check_failure(addr, val);
 	return val;
 }
@@ -113,7 +116,7 @@ static inline void eeh_writeb(u8 val, vo
 static inline u16 eeh_readw(void *addr) {
 	volatile u16 *vaddr = (volatile u16 *)IO_TOKEN_TO_ADDR(addr);
 	u16 val = in_le16(vaddr);
-	if (EEH_POSSIBLE_ERROR(addr, vaddr, val))
+	if (EEH_POSSIBLE_ERROR(addr, vaddr, val, u16))
 		return eeh_check_failure(addr, val);
 	return val;
 }
@@ -124,7 +127,7 @@ static inline void eeh_writew(u16 val, v
 static inline u32 eeh_readl(void *addr) {
 	volatile u32 *vaddr = (volatile u32 *)IO_TOKEN_TO_ADDR(addr);
 	u32 val = in_le32(vaddr);
-	if (EEH_POSSIBLE_ERROR(addr, vaddr, val))
+	if (EEH_POSSIBLE_ERROR(addr, vaddr, val, u32))
 		return eeh_check_failure(addr, val);
 	return val;
 }
@@ -159,7 +162,7 @@ static inline u8 eeh_inb(unsigned long p
 	if (_IO_IS_ISA(port) && !_IO_HAS_ISA_BUS)
 		return ~0;
 	val = in_8((u8 *)(port+pci_io_base));
-	if (!_IO_IS_ISA(port) && EEH_POSSIBLE_IO_ERROR(val))
+	if (!_IO_IS_ISA(port) && EEH_POSSIBLE_IO_ERROR(val, u8))
 		return eeh_check_failure((void*)(port+pci_io_base), val);
 	return val;
 }
@@ -174,7 +177,7 @@ static inline u16 eeh_inw(unsigned long 
 	if (_IO_IS_ISA(port) && !_IO_HAS_ISA_BUS)
 		return ~0;
 	val = in_le16((u16 *)(port+pci_io_base));
-	if (!_IO_IS_ISA(port) && EEH_POSSIBLE_IO_ERROR(val))
+	if (!_IO_IS_ISA(port) && EEH_POSSIBLE_IO_ERROR(val, u16))
 		return eeh_check_failure((void*)(port+pci_io_base), val);
 	return val;
 }
@@ -189,7 +192,7 @@ static inline u32 eeh_inl(unsigned long 
 	if (_IO_IS_ISA(port) && !_IO_HAS_ISA_BUS)
 		return ~0;
 	val = in_le32((u32 *)(port+pci_io_base));
-	if (!_IO_IS_ISA(port) && EEH_POSSIBLE_IO_ERROR(val))
+	if (!_IO_IS_ISA(port) && EEH_POSSIBLE_IO_ERROR(val, u32))
 		return eeh_check_failure((void*)(port+pci_io_base), val);
 	return val;
 }
diff -urNp linux-359/include/asm-ppc64/machdep.h linux-360/include/asm-ppc64/machdep.h
--- linux-359/include/asm-ppc64/machdep.h
+++ linux-360/include/asm-ppc64/machdep.h
@@ -133,6 +133,11 @@ struct machdep_calls {
 
 	/* this is for modules, since _machine can be a define -- Cort */
 	int ppc_machine;
+
+#ifndef __GENKSYMS__ /* preserve KMI/ABI ksyms compatibility for mod linkage */
+	/* Interface for platform error logging */
+	void (*log_error)(char *buf, unsigned int err_type, int fatal);
+#endif
 };
 
 extern struct machdep_calls ppc_md;
@@ -156,6 +161,11 @@ void ppc64_attention_msg(unsigned int sr
 /* Print a dump progress message. */
 void ppc64_dump_msg(unsigned int src, const char *msg);
 
+static inline void log_error(char *buf, unsigned int err_type, int fatal)
+{
+	if (ppc_md.log_error)
+		ppc_md.log_error(buf, err_type, fatal);
+}
 
 #endif /* _PPC_MACHDEP_H */
 #endif /* __KERNEL__ */
diff -urNp linux-359/include/asm-ppc64/nvram.h linux-360/include/asm-ppc64/nvram.h
--- linux-359/include/asm-ppc64/nvram.h
+++ linux-360/include/asm-ppc64/nvram.h
@@ -11,6 +11,12 @@
 #ifndef _PPC64_NVRAM_H
 #define _PPC64_NVRAM_H
 
+#define NVRW_CNT 0x20
+#define NVRAM_HEADER_LEN 16 /* sizeof(struct nvram_header) */
+#define NVRAM_BLOCK_LEN 16
+#define NVRAM_MAX_REQ (2080/NVRAM_BLOCK_LEN)
+#define NVRAM_MIN_REQ (1056/NVRAM_BLOCK_LEN)
+
 #define NVRAM_AS0  0x74
 #define NVRAM_AS1  0x75
 #define NVRAM_DATA 0x77
@@ -36,4 +42,37 @@
 #define BIN_TO_BCD(val) ((val)=(((val)/10)<<4) + (val)%10)
 #endif
 
+#define NVRAM_SIG_SP	0x02	/* support processor */
+#define NVRAM_SIG_OF	0x50	/* open firmware config */
+#define NVRAM_SIG_FW	0x51	/* general firmware */
+#define NVRAM_SIG_HW	0x52	/* hardware (VPD) */
+#define NVRAM_SIG_SYS	0x70	/* system env vars */
+#define NVRAM_SIG_CFG	0x71	/* config data */
+#define NVRAM_SIG_ELOG	0x72	/* error log */
+#define NVRAM_SIG_VEND	0x7e	/* vendor defined */
+#define NVRAM_SIG_FREE	0x7f	/* Free space */
+#define NVRAM_SIG_OS	0xa0	/* OS defined */
+
+/* If change this size, then change the size of NVRAM_HEADER_LEN */
+struct nvram_header {
+	unsigned char signature;
+	unsigned char checksum;
+	unsigned short length;
+	char name[12];
+};
+
+struct nvram_partition {
+	struct list_head partition;
+	struct nvram_header header;
+	unsigned int index;
+};
+
+
+ssize_t read_nvram(char *buf, size_t count, loff_t *index);
+ssize_t write_nvram(char *buf, size_t count, loff_t *index);
+int write_error_log_nvram(char * buff, int length, unsigned int err_type);
+int read_error_log_nvram(char * buff, int length, unsigned int * err_type);
+int clear_error_log_nvram(void);
+void print_nvram_partitions(char * label);
+
 #endif /* _PPC64_NVRAM_H */
diff -urNp linux-359/include/asm-ppc64/rtas.h linux-360/include/asm-ppc64/rtas.h
--- linux-359/include/asm-ppc64/rtas.h
+++ linux-360/include/asm-ppc64/rtas.h
@@ -1,6 +1,7 @@
 #ifndef _PPC64_RTAS_H
 #define _PPC64_RTAS_H
 
+#include <linux/kernel.h>
 #include <linux/spinlock.h>
 #include <asm/page.h>
 
@@ -24,6 +25,12 @@
 #define MAX_ERRINJCT_TOKENS 8 /* Max # tokens. */
 #define WORKSPACE_SIZE 1024 
 
+/* Extended Delay Interrupted by Signal */
+#define RTAS_DELAY_INTR -1098
+
+/* Buffer size for ppc64_rtas system call. */
+#define RTAS_RMOBUF_MAX (64 * 1024)
+
 /*
  * In general to call RTAS use rtas_token("string") to lookup
  * an RTAS token for the given string (e.g. "event-scan").
@@ -46,9 +53,6 @@ struct rtas_args {
 	u32 nargs;
 	u32 nret; 
 	rtas_arg_t args[16];
-#if 0
-	spinlock_t lock;
-#endif
 	rtas_arg_t *rets;     /* Pointer to return values in args[]. */
 };  
 
@@ -57,7 +61,7 @@ struct rtas_t {
 	unsigned long base;		/* physical address pointer */
 	unsigned long size;
 	spinlock_t lock;
-
+	struct rtas_args args;
 	struct device_node *dev;	/* virtual address pointer */
 };
 
@@ -182,6 +186,48 @@ extern int rtas_errinjct_close(unsigned 
 extern struct proc_dir_entry *rtas_proc_dir;
 extern struct errinjct_token ei_token_list[MAX_ERRINJCT_TOKENS];
 
+/* Given an RTAS status code of 9900..9905 compute the hinted delay */
+extern int rtas_do_extended_delay(int status);
+static inline int rtas_is_extended_busy(int status)
+{
+	return status >= 9900 && status <= 9905;
+}
+
+extern void pSeries_log_error(char *buf, unsigned int err_type, int fatal);
+
+/* Error types logged.  */
+#define ERR_FLAG_ALREADY_LOGGED	0x0
+#define ERR_FLAG_BOOT		0x1 	/* log was pulled from NVRAM on boot */
+#define ERR_TYPE_RTAS_LOG	0x2	/* from rtas event-scan */
+#define ERR_TYPE_KERNEL_PANIC	0x4	/* from panic() */
+
+/* All the types and not flags */
+#define ERR_TYPE_MASK	(ERR_TYPE_RTAS_LOG | ERR_TYPE_KERNEL_PANIC)
+
+#define RTAS_DEBUG KERN_DEBUG "RTAS: "
+  
+#define RTAS_ERROR_LOG_MAX 2048
+  
+static inline int rtas_get_error_log_max (void)
+{
+	int buflen;
+	buflen = rtas_token ("rtas-error-log-max");
+	if ((buflen == RTAS_UNKNOWN_SERVICE) ||
+	    (buflen > RTAS_ERROR_LOG_MAX)) {
+		printk (KERN_WARNING "RTAS: bad log buffer size %d\n", buflen);
+		buflen = RTAS_ERROR_LOG_MAX;
+	}
+	return buflen;
+}
+  
+/* Event Scan Parameters */
+#define EVENT_SCAN_ALL_EVENTS	0xf0000000
+#define SURVEILLANCE_TOKEN	9000
+#define SURVEILLANCE_TIMEOUT	1
+#define SURVEILLANCE_SCANRATE	1
+#define LOG_NUMBER		64		/* must be a power of two */
+#define LOG_NUMBER_MASK		(LOG_NUMBER-1)
+
 /* Some RTAS ops require a data buffer and that buffer must be < 4G.
  * Rather than having a memory allocator, just use this buffer
  * (get the lock first), make the RTAS call.  Copy the data instead
@@ -190,5 +236,7 @@ extern struct errinjct_token ei_token_li
 #define RTAS_DATA_BUF_SIZE 4096
 extern spinlock_t rtas_data_buf_lock;
 extern char rtas_data_buf[RTAS_DATA_BUF_SIZE];
+/* RMO buffer reserved for user-space RTAS use */
+extern unsigned long rtas_rmo_buf;
 
 #endif /* _PPC64_RTAS_H */
diff -urNp linux-359/include/linux/rbtree.h linux-360/include/linux/rbtree.h
--- linux-359/include/linux/rbtree.h
+++ linux-360/include/linux/rbtree.h
@@ -120,6 +120,8 @@ rb_root_t;
 
 extern void rb_insert_color(rb_node_t *, rb_root_t *);
 extern void rb_erase(rb_node_t *, rb_root_t *);
+extern struct rb_node_s *rb_first(struct rb_root_s *);
+extern struct rb_node_s *rb_next(struct rb_node_s *);
 
 static inline void rb_link_node(rb_node_t * node, rb_node_t * parent, rb_node_t ** rb_link)
 {
diff -urNp linux-359/kernel/panic.c linux-360/kernel/panic.c
--- linux-359/kernel/panic.c
+++ linux-360/kernel/panic.c
@@ -239,6 +239,17 @@ NORET_TYPE void panic(const char * fmt, 
 		printk("Press L1-A to return to the boot prom\n");
 	}
 #endif
+#ifdef CONFIG_PPC_PSERIES
+	{
+		long status;
+		char *str = "OS panic";
+		status = rtas_call(rtas_token("ibm,os-term"), 1, 1, NULL,
+				   __pa(str));
+		if (status != 0)
+			printk(KERN_EMERG "ibm,os-term call failed %d\n",
+				status);
+	}
+#endif
 #if defined(CONFIG_ARCH_S390)
         disabled_wait(caller);
 #endif
diff -urNp linux-359/lib/rbtree.c linux-360/lib/rbtree.c
--- linux-359/lib/rbtree.c
+++ linux-360/lib/rbtree.c
@@ -294,3 +294,45 @@ void rb_erase(rb_node_t * node, rb_root_
 		__rb_erase_color(child, parent, root);
 }
 EXPORT_SYMBOL(rb_erase);
+
+/*
+ * This function returns the first node (in sort order) of the tree.
+ */
+struct rb_node_s *rb_first(struct rb_root_s *root)
+{
+	struct rb_node_s	*n;
+
+	n = root->rb_node;
+	if (!n)
+		return NULL;
+	while (n->rb_left)
+		n = n->rb_left;
+	return n;
+}
+
+EXPORT_SYMBOL(rb_first);
+
+struct rb_node_s *rb_next(struct rb_node_s *node)
+{
+	/* If we have a right-hand child, go down and then left as far
+	   as we can. */
+	if (node->rb_right) {
+		node = node->rb_right;
+		while (node->rb_left)
+			node=node->rb_left;
+		return node;
+	}
+
+	/* No right-hand children.  Everything down and left is
+	   smaller than us, so any 'next' node must be in the general
+	   direction of our parent. Go up the tree; any time the
+	   ancestor is a right-hand child of its parent, keep going
+	   up. First time it's a left-hand child of its parent, said
+	   parent is our 'next' node. */
+	while (node->rb_parent && node == node->rb_parent->rb_right)
+		node = node->rb_parent;
+
+	return node->rb_parent;
+}
+
+EXPORT_SYMBOL(rb_next);
