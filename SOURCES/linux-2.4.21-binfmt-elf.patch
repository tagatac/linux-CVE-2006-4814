diff -urNp linux-710/arch/ia64/ia32/binfmt_elf32.c linux-720/arch/ia64/ia32/binfmt_elf32.c
--- linux-710/arch/ia64/ia32/binfmt_elf32.c
+++ linux-720/arch/ia64/ia32/binfmt_elf32.c
@@ -46,7 +46,7 @@ extern void put_dirty_page (struct task_
 
 static void elf32_set_personality (void);
 
-#define ELF_PLAT_INIT(_r)		ia64_elf32_init(_r)
+#define ELF_PLAT_INIT(_r, load_addr)		ia64_elf32_init(_r)
 #define setup_arg_pages(bprm)		ia32_setup_arg_pages(bprm)
 #define elf_map				elf32_map
 
diff -urNp linux-710/arch/s390x/kernel/binfmt_elf32.c linux-720/arch/s390x/kernel/binfmt_elf32.c
--- linux-710/arch/s390x/kernel/binfmt_elf32.c
+++ linux-720/arch/s390x/kernel/binfmt_elf32.c
@@ -35,7 +35,7 @@
 
 /* For SVR4/S390 the function pointer to be registered with `atexit` is
    passed in R14. */
-#define ELF_PLAT_INIT(_r) \
+#define ELF_PLAT_INIT(_r, load_addr) \
 	do { \
 	_r->gprs[14] = 0; \
 	} while(0)
diff -urNp linux-710/arch/x86_64/ia32/ia32_binfmt.c linux-720/arch/x86_64/ia32/ia32_binfmt.c
--- linux-710/arch/x86_64/ia32/ia32_binfmt.c
+++ linux-720/arch/x86_64/ia32/ia32_binfmt.c
@@ -217,7 +217,7 @@ do {							\
 # define CONFIG_BINFMT_ELF_MODULE	CONFIG_BINFMT_ELF32_MODULE
 #endif
 
-#define ELF_PLAT_INIT(r)		elf32_init(r)
+#define ELF_PLAT_INIT(r, load_addr)		elf32_init(r)
 #define setup_arg_pages(bprm)		ia32_setup_arg_pages(bprm)
 
 extern void load_gs_index(unsigned);
diff -urNp linux-710/fs/binfmt_aout.c linux-720/fs/binfmt_aout.c
--- linux-710/fs/binfmt_aout.c
+++ linux-720/fs/binfmt_aout.c
@@ -225,6 +225,9 @@ static unsigned long * create_aout_table
 #endif
 	put_user(argc,--sp);
 	current->mm->arg_start = (unsigned long) p;
+	current->mm->arg_end = 0UL;
+	current->mm->env_start = 0UL;
+	current->mm->env_end = 0UL;
 	while (argc-->0) {
 		char c;
 		put_user(p,argv++);
diff -urNp linux-710/fs/binfmt_elf.c linux-720/fs/binfmt_elf.c
--- linux-710/fs/binfmt_elf.c
+++ linux-720/fs/binfmt_elf.c
@@ -78,15 +78,19 @@ static struct linux_binfmt elf_format = 
 	NULL, THIS_MODULE, load_elf_binary, load_elf_library, elf_core_dump, ELF_EXEC_PAGESIZE
 };
 
-#define BAD_ADDR(x)	((unsigned long)(x) > TASK_SIZE)
+#define BAD_ADDR(x)	((unsigned long)(x) >= TASK_SIZE)
 
-static void set_brk(unsigned long start, unsigned long end)
+static int set_brk(unsigned long start, unsigned long end)
 {
 	start = ELF_PAGEALIGN(start);
 	end = ELF_PAGEALIGN(end);
-	if (end <= start)
-		return;
-	do_brk(start, end - start);
+	if (end > start) {
+		unsigned long addr = do_brk(start, end - start);
+		if (BAD_ADDR(addr))
+			return addr;
+	}
+	current->mm->start_brk = current->mm->brk = end;
+	return 0;
 }
 
 
@@ -214,6 +218,9 @@ create_elf_tables(char *p, int argc, int
 
 	__put_user((elf_addr_t)argc,--sp);
 	current->mm->arg_start = (unsigned long) p;
+	current->mm->arg_end = 0UL;
+	current->mm->env_start = 0UL;
+	current->mm->env_end = 0UL;
 	while (argc-->0) {
 		__put_user((elf_caddr_t)(unsigned long)p,argv++);
 		len = strnlen_user(p, PAGE_SIZE*MAX_ARG_PAGES);
@@ -297,9 +304,12 @@ static unsigned long load_elf_interp(str
 		goto out;
 
 	retval = kernel_read(interpreter,interp_elf_ex->e_phoff,(char *)elf_phdata,size);
-	error = retval;
-	if (retval < 0)
+	error = -EIO;
+	if (retval != size) {
+		if (retval < 0)
+			error = retval;
 		goto out_close;
+	}
 
 	eppnt = elf_phdata;
 	for (i=0; i<interp_elf_ex->e_phnum; i++, eppnt++) {
@@ -317,8 +327,10 @@ static unsigned long load_elf_interp(str
 	    	elf_type |= MAP_FIXED;
 
 	    map_addr = elf_map(interpreter, load_addr + vaddr, eppnt, elf_prot, elf_type);
-	    if (BAD_ADDR(map_addr))
+	    if (BAD_ADDR(map_addr)) {
+	        error = map_addr;
 	    	goto out_close;
+	    }
 
 	    if (!load_addr_set && interp_elf_ex->e_type == ET_DYN) {
 		load_addr = map_addr - ELF_PAGESTART(vaddr);
@@ -326,6 +338,18 @@ static unsigned long load_elf_interp(str
 	    }
 
 	    /*
+	     * Check to see if the section's size will overflow the
+	     * allowed task size. Note that p_filesz must always be
+	     * <= p_memsz so it is only necessary to check p_memsz.
+	     */
+	    k = load_addr + eppnt->p_vaddr;
+	    if (BAD_ADDR(k) || eppnt->p_filesz > eppnt->p_memsz ||
+		eppnt->p_memsz > TASK_SIZE || TASK_SIZE - eppnt->p_memsz < k) {
+	        error = -ENOMEM;
+		goto out_close;
+	    }
+
+	    /*
 	     * Find the end of the file mapping for this phdr, and keep
 	     * track of the largest address we see for this.
 	     */
@@ -355,8 +379,11 @@ static unsigned long load_elf_interp(str
 	elf_bss = ELF_PAGESTART(elf_bss + ELF_MIN_ALIGN - 1);	/* What we have mapped so far */
 
 	/* Map the last of the bss segment */
-	if (last_bss > elf_bss)
-		do_brk(elf_bss, last_bss - elf_bss);
+	if (last_bss > elf_bss) {
+		error = do_brk(elf_bss, last_bss - elf_bss);
+		if (BAD_ADDR(error))
+			goto out_close;
+	}
 
 	*interp_load_addr = load_addr;
 	error = ((unsigned long) interp_elf_ex->e_entry) + load_addr;
@@ -435,6 +462,7 @@ static int load_elf_binary(struct linux_
 	unsigned int size;
 	unsigned long elf_entry, interp_load_addr = 0;
 	unsigned long start_code, end_code, start_data, end_data;
+	unsigned long reloc_func_desc = 0;
 	struct elfhdr elf_ex;
 	struct elfhdr interp_elf_ex;
   	struct exec interp_ex;
@@ -468,8 +496,11 @@ static int load_elf_binary(struct linux_
 		goto out;
 
 	retval = kernel_read(bprm->file, elf_ex.e_phoff, (char *) elf_phdata, size);
-	if (retval < 0)
+	if (retval != size) {
+		if (retval >= 0)
+			retval = -EIO;
 		goto out_free_ph;
+	}
 
 	retval = get_unused_fd();
 	if (retval < 0)
@@ -494,7 +525,8 @@ static int load_elf_binary(struct linux_
 			 */
 
 			retval = -ENOMEM;
-			if (elf_ppnt->p_filesz > PATH_MAX)
+			if (elf_ppnt->p_filesz > PATH_MAX ||
+			    elf_ppnt->p_filesz == 0)
 				goto out_free_file;
 			elf_interpreter = (char *) kmalloc(elf_ppnt->p_filesz,
 							   GFP_KERNEL);
@@ -504,8 +536,16 @@ static int load_elf_binary(struct linux_
 			retval = kernel_read(bprm->file, elf_ppnt->p_offset,
 					   elf_interpreter,
 					   elf_ppnt->p_filesz);
-			if (retval < 0)
+			if (retval != elf_ppnt->p_filesz) {
+				if (retval >= 0)
+					retval = -EIO;
+				goto out_free_interp;
+			}
+			/* make sure path is NULL terminated */
+			retval = -EINVAL;
+			if (elf_interpreter[elf_ppnt->p_filesz - 1] != '\0')
 				goto out_free_interp;
+
 			/* If the program interpreter is one of these two,
 			 * then assume an iBCS2 image. Otherwise assume
 			 * a native linux image.
@@ -524,8 +564,11 @@ static int load_elf_binary(struct linux_
 			if (IS_ERR(interpreter))
 				goto out_free_interp;
 			retval = kernel_read(interpreter, 0, bprm->buf, BINPRM_BUF_SIZE);
-			if (retval < 0)
+			if (retval != BINPRM_BUF_SIZE) {
+				if (retval >= 0)
+					retval = -EIO;
 				goto out_free_dentry;
+			}
 
 			/* Get the exec headers */
 			interp_ex = *((struct exec *) bprm->buf);
@@ -559,6 +602,12 @@ static int load_elf_binary(struct linux_
 			// printk(KERN_WARNING "ELF: Ambiguous type, using ELF\n");
 			interpreter_type = INTERPRETER_ELF;
 		}
+
+		/* Verify the interpreter has a valid arch */
+		if (interpreter_type == INTERPRETER_ELF &&
+		    !elf_check_arch(&interp_elf_ex))
+			goto out_free_dentry;
+
 	} else {
 		/* Executables without an interpreter also need a personality  */
 		SET_PERSONALITY(elf_ex, ibcs2_interpreter);
@@ -621,7 +670,12 @@ static int load_elf_binary(struct linux_
 			/* There was a PT_LOAD segment with p_memsz > p_filesz
 			   before this one. Map anonymous pages, if needed,
 			   and clear the area.  */
-			set_brk (elf_bss + load_bias, elf_brk + load_bias);
+			retval = set_brk (elf_bss + load_bias,
+					  elf_brk + load_bias);
+			if (retval) {
+				send_sig(SIGKILL, current, 0);
+				goto out_free_dentry;
+			}
 			nbyte = ELF_PAGEOFFSET(elf_bss);
 			if (nbyte) {
 				nbyte = ELF_MIN_ALIGN - nbyte;
@@ -648,8 +702,10 @@ static int load_elf_binary(struct linux_
 		}
 
 		error = elf_map(bprm->file, load_bias + vaddr, elf_ppnt, elf_prot, elf_flags);
-		if (BAD_ADDR(error))
-			continue;
+		if (BAD_ADDR(error)) {
+			send_sig(SIGKILL, current, 0);
+			goto out_free_dentry;
+		}
 
 		if (!load_addr_set) {
 			load_addr_set = 1;
@@ -658,12 +714,26 @@ static int load_elf_binary(struct linux_
 				load_bias += error -
 				             ELF_PAGESTART(load_bias + vaddr);
 				load_addr += load_bias;
+				reloc_func_desc = load_bias;
 			}
 		}
 		k = elf_ppnt->p_vaddr;
 		if (k < start_code) start_code = k;
 		if (start_data < k) start_data = k;
 
+		/*
+		 * Check to see if the section's size will overflow the
+		 * allowed task size. Note that p_filesz must always be
+		 * <= p_memsz so it is only necessary to check p_memsz.
+		 */
+		if (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||
+		    elf_ppnt->p_memsz > TASK_SIZE ||
+		    TASK_SIZE - elf_ppnt->p_memsz < k) {
+			/* set_brk can never work.  Avoid overflows.  */
+			send_sig(SIGKILL, current, 0);
+			goto out_free_dentry;
+		}
+
 		k = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;
 
 		if (k > elf_bss)
@@ -685,6 +755,18 @@ static int load_elf_binary(struct linux_
 	start_data += load_bias;
 	end_data += load_bias;
 
+	/* Calling set_brk effectively mmaps the pages that we need
+	 * for the bss and break sections.  We must do this before
+	 * mapping in the interpreter, to make sure it doesn't wind
+	 * up getting placed where the bss needs to go.
+	 */
+	retval = set_brk(elf_bss, elf_brk);
+	if (retval) {
+		send_sig(SIGKILL, current, 0);
+		goto out_free_dentry;
+	}
+	padzero(elf_bss);
+
 	if (elf_interpreter) {
 		if (interpreter_type == INTERPRETER_AOUT)
 			elf_entry = load_aout_interp(&interp_ex,
@@ -694,16 +776,22 @@ static int load_elf_binary(struct linux_
 						    interpreter,
 						    &interp_load_addr);
 
+		if (BAD_ADDR(elf_entry)) {
+			force_sig(SIGSEGV, current);
+			retval = IS_ERR((void *)elf_entry) ?
+					(int)elf_entry : -EINVAL;
+			goto out_free_dentry;
+		}
+		reloc_func_desc = interp_load_addr;
+
 		allow_write_access(interpreter);
 		fput(interpreter);
 		kfree(elf_interpreter);
-
+	} else {
 		if (BAD_ADDR(elf_entry)) {
-			printk(KERN_ERR "Unable to load interpreter\n");
-			kfree(elf_phdata);
-			send_sig(SIGSEGV, current, 0);
-			retval = -ENOEXEC; /* Nobody gets to see this, but.. */
-			goto out;
+			force_sig(SIGSEGV, current);
+			retval = -EINVAL;
+			goto out_free_dentry;
 		}
 	}
 
@@ -727,20 +815,12 @@ static int load_elf_binary(struct linux_
 	/* N.B. passed_fileno might not be initialized? */
 	if (interpreter_type == INTERPRETER_AOUT)
 		current->mm->arg_start += strlen(passed_fileno) + 1;
-	current->mm->start_brk = current->mm->brk = elf_brk;
 	current->mm->end_code = end_code;
 	current->mm->start_code = start_code;
 	current->mm->start_data = start_data;
 	current->mm->end_data = end_data;
 	current->mm->start_stack = bprm->p;
 
-	/* Calling set_brk effectively mmaps the pages that we need
-	 * for the bss and break sections
-	 */
-	set_brk(elf_bss, elf_brk);
-
-	padzero(elf_bss);
-
 #if 0
 	printk("(start_brk) %lx\n" , (long) current->mm->start_brk);
 	printk("(end_code) %lx\n" , (long) current->mm->end_code);
@@ -767,10 +847,14 @@ static int load_elf_binary(struct linux_
 	/*
 	 * The ABI may specify that certain registers be set up in special
 	 * ways (on i386 %edx is the address of a DT_FINI function, for
-	 * example.  This macro performs whatever initialization to
-	 * the regs structure is required.
+	 * example.  In addition, it may also specify (eg, PowerPC64 ELF)
+	 * that the e_entry field is the address of the function descriptor
+	 * for the startup routine, rather than the address of the startup
+	 * routine itself.  This macro performs whatever initialization to
+	 * the regs structure is required as well as any relocations to the
+	 * function descriptor entries when executing dynamically links apps.
 	 */
-	ELF_PLAT_INIT(regs);
+	ELF_PLAT_INIT(regs, reloc_func_desc);
 #endif
 
 	start_thread(regs, elf_entry, bprm->p);
@@ -787,7 +871,8 @@ out:
 	/* error cleanup */
 out_free_dentry:
 	allow_write_access(interpreter);
-	fput(interpreter);
+	if (interpreter)
+		fput(interpreter);
 out_free_interp:
 	if (elf_interpreter)
 		kfree(elf_interpreter);
@@ -803,7 +888,7 @@ out_free_ph:
 
 static int load_elf_library(struct file *file)
 {
-	struct elf_phdr *elf_phdata;
+	struct elf_phdr *elf_phdata, *elf_phdata_save;
 	unsigned long elf_bss, bss, len;
 	int retval, error, i, j;
 	struct elfhdr elf_ex;
@@ -831,6 +916,7 @@ static int load_elf_library(struct file 
 	if (!elf_phdata)
 		goto out;
 
+	elf_phdata_save = elf_phdata;
 	error = -ENOEXEC;
 	retval = kernel_read(file, elf_ex.e_phoff, (char *) elf_phdata, j);
 	if (retval != j)
@@ -867,7 +953,7 @@ static int load_elf_library(struct file 
 	error = 0;
 
 out_free_ph:
-	kfree(elf_phdata);
+	kfree(elf_phdata_save);
 out:
 	return error;
 }
@@ -893,7 +979,7 @@ static int dump_write(struct file *file,
 	return file->f_op->write(file, addr, nr, &file->f_pos) == nr;
 }
 
-static int dump_seek(struct file *file, off_t off)
+static int dump_seek(struct file *file, loff_t off)
 {
 	if (file->f_op->llseek) {
 		if (file->f_op->llseek(file, off, 0) != off)
@@ -1000,22 +1086,19 @@ static int writenote(struct memelfnote *
 
 	DUMP_WRITE(&en, sizeof(en));
 	DUMP_WRITE(men->name, en.n_namesz);
-	/* XXX - cast from long long to long to avoid need for libgcc.a */
-	DUMP_SEEK(roundup((unsigned long)file->f_pos, 4));	/* XXX */
+	DUMP_SEEK(roundup(file->f_pos, 4));
 	DUMP_WRITE(men->data, men->datasz);
-	DUMP_SEEK(roundup((unsigned long)file->f_pos, 4));	/* XXX */
+	DUMP_SEEK(roundup(file->f_pos, 4));
 
 	return 1;
 }
 #undef DUMP_WRITE
 #undef DUMP_SEEK
 
-#define DUMP_WRITE(addr, nr)	\
-	if ((size += (nr)) > limit || !dump_write(file, (addr), (nr))) \
-		goto end_coredump;
-#define DUMP_SEEK(off)	\
-	if (!dump_seek(file, (off))) \
-		goto end_coredump;
+#define DUMP_WRITE(addr, nr) \
+	((size += (nr)) > limit || !dump_write(file, (addr), (nr)))
+#define DUMP_SEEK(off) \
+	(!dump_seek(file, (off)))
 
 static inline void fill_elf_header(struct elfhdr *elf, int segs)
 {
@@ -1131,41 +1214,57 @@ static int elf_dump_thread_status(long s
 
 	struct elf_thread_status *t;
 	int sz = 0;
+	int n = 0;
 
 	t = kmalloc(sizeof(*t), GFP_ATOMIC);
 	if (!t)
 		return 0;
 
 	INIT_LIST_HEAD(&t->list);
-	t->num_notes = 0;
 
 	fill_prstatus(&t->prstatus, p, signr);
 	elf_core_copy_task_regs(p, &t->prstatus.pr_reg);	
-	
-	fill_note(&t->notes[0], "CORE", NT_PRSTATUS, sizeof(t->prstatus), &(t->prstatus));
-	t->num_notes++;
-	sz += notesize(&t->notes[0]);
 
-#ifndef __x86_64__
+	fill_note(&t->notes[n], "CORE", NT_PRSTATUS, sizeof(t->prstatus), &(t->prstatus));
+	sz += notesize(&t->notes[n]);
+	n++;
+
 	if ((t->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, &t->fpu))) {
-		fill_note(&t->notes[1], "CORE", NT_PRFPREG, sizeof(t->fpu), &(t->fpu));
-		t->num_notes++;
-		sz += notesize(&t->notes[1]);
+		fill_note(&t->notes[n], "CORE", NT_PRFPREG, sizeof(t->fpu), &(t->fpu));
+		sz += notesize(&t->notes[n]);
+		n++;
 	}
-#endif	
 
 #ifdef ELF_CORE_COPY_XFPREGS
 	if (elf_core_copy_task_xfpregs(p, &t->xfpu)) {
-		fill_note(&t->notes[2], "LINUX", NT_PRXFPREG, sizeof(t->xfpu), &(t->xfpu));
-		t->num_notes++;
-		sz += notesize(&t->notes[2]);
+		fill_note(&t->notes[n], "LINUX", NT_PRXFPREG, sizeof(t->xfpu), &(t->xfpu));
+		sz += notesize(&t->notes[n]);
+		n++;
 	}
 #endif	
+	t->num_notes = n;
 	list_add(&t->list, thread_list);
 	return sz;
 }
 
 /*
+ * If a 32-bit binary generates a core file of >= 4GB, then it's possible
+ * that the 64-bit file offset of a program header defined segment would 
+ * overflow the maximum value that can be contained in its associated 
+ * 32-bit elf_phdr.p_offset field.  Rather than truncating the 64-bit offset
+ * to a misleading, incorrect, 32-bit value, it's preferable to just set
+ * the p_offset to zero.  Having p_offset be zero when p_filesz is nonzero
+ * is a clear indication that something funny happened; tools can easily 
+ * identify that the dump was truncated if it was, or they can try to 
+ * intuit the file position >= 4GB where this segment actually got written.
+ */
+static inline elf_addr_t core_header_offset(loff_t offset)
+{
+	elf_addr_t ofs = offset;
+	return (loff_t)ofs != offset ? 0 : ofs;
+}
+
+/*
  * Actual dumper
  *
  * This is a two-pass process; first we find the offsets of the bits,
@@ -1181,9 +1280,9 @@ static int elf_core_dump(long signr, str
 	int i;
 	struct vm_area_struct *vma;
 	struct elfhdr elf;
-	off_t offset = 0, dataoff;
+	loff_t offset = 0, dataoff;
 	unsigned long limit = current->rlim[RLIMIT_CORE].rlim_cur;
-	int numnote = 5;
+	int numnote = 0;
 	struct memelfnote notes[5];
 	struct elf_prstatus prstatus;	/* NT_PRSTATUS */
 	struct elf_prpsinfo psinfo;	/* NT_PRPSINFO */
@@ -1198,7 +1297,7 @@ static int elf_core_dump(long signr, str
 	
 	/* first copy the parameters from user space */
 	memset(&psinfo, 0, sizeof(psinfo));
-	{
+	if (current->mm->arg_end) {
 		int i, len;
 
 		len = current->mm->arg_end - current->mm->arg_start;
@@ -1290,41 +1389,33 @@ static int elf_core_dump(long signr, str
 	dump_regs("prstatus regs", (elf_greg_t *)&prstatus.pr_reg);
 #endif
 
-	fill_note(&notes[0], "CORE", NT_PRSTATUS, sizeof(prstatus), &prstatus);
+	fill_note(&notes[numnote++], "CORE", NT_PRSTATUS, sizeof(prstatus), &prstatus);
 	
 	/*
 	 * NT_PRPSINFO describes the process as a whole,
 	 * ie. the group leader:
 	 */
 	fill_psinfo(&psinfo, current->group_leader);
-	fill_note(&notes[1], "CORE", NT_PRPSINFO, sizeof(psinfo), &psinfo);
+	fill_note(&notes[numnote++], "CORE", NT_PRPSINFO, sizeof(psinfo), &psinfo);
 	
-	fill_note(&notes[2], "CORE", NT_TASKSTRUCT, sizeof(*current), current);
+	fill_note(&notes[numnote++], "CORE", NT_TASKSTRUCT, sizeof(*current), current);
   
-#ifndef __x86_64__
   	/* Try to dump the FPU. */
 	if ((prstatus.pr_fpvalid = elf_core_copy_task_fpregs(current, &fpu))) {
-		fill_note(&notes[3], "CORE", NT_PRFPREG, sizeof(fpu), &fpu);
-	} else {
-		--numnote;
- 	}
-#else
-	numnote --;
-#endif 	
+		fill_note(&notes[numnote++], "CORE", NT_PRFPREG, sizeof(fpu), &fpu);
+	}
+
 #ifdef ELF_CORE_COPY_XFPREGS
 	if (elf_core_copy_task_xfpregs(current, &xfpu)) {
-		fill_note(&notes[4], "LINUX", NT_PRXFPREG, sizeof(xfpu), &xfpu);
-	} else {
-		--numnote;
+		fill_note(&notes[numnote++], "LINUX", NT_PRXFPREG, sizeof(xfpu), &xfpu);
 	}
-#else
-	numnote --;
 #endif	
   
 	fs = get_fs();
 	set_fs(KERNEL_DS);
 
-	DUMP_WRITE(&elf, sizeof(elf));
+	if (DUMP_WRITE(&elf, sizeof(elf)))
+		goto end_coredump;
 	offset += sizeof(elf);				/* Elf header */
 	offset += (segs+1) * sizeof(struct elf_phdr);	/* Program headers */
 
@@ -1338,9 +1429,10 @@ static int elf_core_dump(long signr, str
 		
 		sz += thread_status_size;
 
-		fill_elf_note_phdr(&phdr, sz, offset);
+		fill_elf_note_phdr(&phdr, sz, core_header_offset(offset));
 		offset += sz;
-		DUMP_WRITE(&phdr, sizeof(phdr));
+		if (DUMP_WRITE(&phdr, sizeof(phdr)))
+			goto end_coredump;
 	}
 
 	/* Page-align dumped data */
@@ -1354,7 +1446,7 @@ static int elf_core_dump(long signr, str
 		sz = vma->vm_end - vma->vm_start;
 
 		phdr.p_type = PT_LOAD;
-		phdr.p_offset = offset;
+		phdr.p_offset = core_header_offset(offset);
 		phdr.p_vaddr = vma->vm_start;
 		phdr.p_paddr = 0;
 		phdr.p_filesz = maydump(vma) ? sz : 0;
@@ -1365,7 +1457,8 @@ static int elf_core_dump(long signr, str
 		if (vma->vm_flags & VM_EXEC) phdr.p_flags |= PF_X;
 		phdr.p_align = ELF_EXEC_PAGESIZE;
 
-		DUMP_WRITE(&phdr, sizeof(phdr));
+		if (DUMP_WRITE(&phdr, sizeof(phdr)))
+			goto end_coredump;
 	}
 
 #ifdef ELF_CORE_WRITE_EXTRA_PHDRS
@@ -1385,7 +1478,8 @@ static int elf_core_dump(long signr, str
 				goto end_coredump;
 	}
  
-	DUMP_SEEK(dataoff);
+	if (DUMP_SEEK(dataoff))
+		goto end_coredump;
 
 	for(vma = current->mm->mmap; vma != NULL; vma = vma->vm_next) {
 		unsigned long addr;
@@ -1405,19 +1499,26 @@ static int elf_core_dump(long signr, str
 
 			if (get_user_pages(current, current->mm, addr, 1, 0, 1,
 						&page, &vma) <= 0) {
-				DUMP_SEEK (file->f_pos + PAGE_SIZE);
+				if (DUMP_SEEK(file->f_pos + PAGE_SIZE))
+					goto end_coredump;
 			} else {
+				int abort_dump = 0;
 				if (page == ZERO_PAGE(addr)) {
-					DUMP_SEEK (file->f_pos + PAGE_SIZE);
+					if (DUMP_SEEK(file->f_pos + PAGE_SIZE))
+						abort_dump = 1;
 				} else {
 					void *kaddr;
 					flush_cache_page(vma, addr);
 					kaddr = kmap(page);
-					DUMP_WRITE(kaddr, PAGE_SIZE);
-					flush_page_to_ram(page);
+					if (DUMP_WRITE(kaddr, PAGE_SIZE))
+						abort_dump = 1;
+					else
+						flush_page_to_ram(page);
 					kunmap(page);
 				}
 				put_page(page);
+				if (abort_dump)
+					goto end_coredump;
 			}
 		}
 	}
@@ -1426,10 +1527,10 @@ static int elf_core_dump(long signr, str
 	ELF_CORE_WRITE_EXTRA_DATA;
 #endif
 
-	if ((off_t) file->f_pos != offset) {
+	if (file->f_pos != offset) {
 		/* Sanity check */
-		printk("elf_core_dump: file->f_pos (%ld) != offset (%ld)\n",
-		       (off_t) file->f_pos, offset);
+		printk("elf_core_dump: file->f_pos (%lld) != offset (%lld)\n",
+		       file->f_pos, offset);
 	}
 
 end_coredump:
diff -urNp linux-710/fs/exec.c linux-720/fs/exec.c
--- linux-710/fs/exec.c
+++ linux-720/fs/exec.c
@@ -1280,7 +1280,7 @@ int do_coredump(long signr, int exit_cod
 		goto fail_unlock;
 
  	format_corename(corename, core_pattern, signr);
-	file = filp_open(corename, O_CREAT | 2 | O_NOFOLLOW, 0600);
+	file = filp_open(corename, O_CREAT | 2 | O_NOFOLLOW | O_LARGEFILE, 0600);
 	if (IS_ERR(file))
 		goto fail_unlock;
 	inode = file->f_dentry->d_inode;
diff -urNp linux-710/include/asm-alpha/elf.h linux-720/include/asm-alpha/elf.h
--- linux-710/include/asm-alpha/elf.h
+++ linux-720/include/asm-alpha/elf.h
@@ -50,7 +50,7 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
    we start programs with a value of 0 to indicate that there is no
    such function.  */
 
-#define ELF_PLAT_INIT(_r)       _r->r0 = 0
+#define ELF_PLAT_INIT(_r, load_addr)       _r->r0 = 0
 
 /* The registers are layed out in pt_regs for PAL and syscall
    convenience.  Re-order them for the linear elf_gregset_t.  */
diff -urNp linux-710/include/asm-arm/elf.h linux-720/include/asm-arm/elf.h
--- linux-710/include/asm-arm/elf.h
+++ linux-720/include/asm-arm/elf.h
@@ -48,7 +48,7 @@ typedef struct { void *null; } elf_fpreg
 /* When the program starts, a1 contains a pointer to a function to be 
    registered with atexit, as per the SVR4 ABI.  A value of 0 means we 
    have no such handler.  */
-#define ELF_PLAT_INIT(_r)	(_r)->ARM_r0 = 0
+#define ELF_PLAT_INIT(_r, load_addr)	(_r)->ARM_r0 = 0
 
 /* This yields a mask that user programs can use to figure out what
    instruction set this cpu supports. */
diff -urNp linux-710/include/asm-cris/elf.h linux-720/include/asm-cris/elf.h
--- linux-710/include/asm-cris/elf.h
+++ linux-720/include/asm-cris/elf.h
@@ -39,7 +39,7 @@ typedef unsigned long elf_fpregset_t;
 	   A value of 0 tells we have no such handler.  */
 	
 	/* Explicitly set registers to 0 to increase determinism.  */
-#define ELF_PLAT_INIT(_r)	do { \
+#define ELF_PLAT_INIT(_r, load_addr)	do { \
 	(_r)->r13 = 0; (_r)->r12 = 0; (_r)->r11 = 0; (_r)->r10 = 0; \
 	(_r)->r9 = 0;  (_r)->r8 = 0;  (_r)->r7 = 0;  (_r)->r6 = 0;  \
 	(_r)->r5 = 0;  (_r)->r4 = 0;  (_r)->r3 = 0;  (_r)->r2 = 0;  \
diff -urNp linux-710/include/asm-i386/elf.h linux-720/include/asm-i386/elf.h
--- linux-710/include/asm-i386/elf.h
+++ linux-720/include/asm-i386/elf.h
@@ -42,7 +42,7 @@ typedef struct user_fxsr_struct elf_fpxr
    We might as well make sure everything else is cleared too (except for %esp),
    just to make things more deterministic.
  */
-#define ELF_PLAT_INIT(_r)	do { \
+#define ELF_PLAT_INIT(_r, load_addr)	do { \
 	_r->ebx = 0; _r->ecx = 0; _r->edx = 0; \
 	_r->esi = 0; _r->edi = 0; _r->ebp = 0; \
 	_r->eax = 0; \
diff -urNp linux-710/include/asm-ia64/elf.h linux-720/include/asm-ia64/elf.h
--- linux-710/include/asm-ia64/elf.h
+++ linux-720/include/asm-ia64/elf.h
@@ -49,7 +49,7 @@
  * talk to him...
  */
 extern void ia64_init_addr_space (void);
-#define ELF_PLAT_INIT(_r)	ia64_init_addr_space()
+#define ELF_PLAT_INIT(_r, load_addr)	ia64_init_addr_space()
 
 /* ELF register definitions.  This is needed for core dump support.  */
 
diff -urNp linux-710/include/asm-ia64/ia32.h linux-720/include/asm-ia64/ia32.h
--- linux-710/include/asm-ia64/ia32.h
+++ linux-720/include/asm-ia64/ia32.h
@@ -389,7 +389,7 @@ struct old_linux32_dirent {
 #define ELF_ET_DYN_BASE		(IA32_PAGE_OFFSET/3 + 0x1000000)
 
 void ia64_elf32_init(struct pt_regs *regs);
-#define ELF_PLAT_INIT(_r)	ia64_elf32_init(_r)
+#define ELF_PLAT_INIT(_r, load_addr)	ia64_elf32_init(_r)
 
 #define elf_addr_t	u32
 #define elf_caddr_t	u32
diff -urNp linux-710/include/asm-m68k/elf.h linux-720/include/asm-m68k/elf.h
--- linux-710/include/asm-m68k/elf.h
+++ linux-720/include/asm-m68k/elf.h
@@ -31,7 +31,7 @@ typedef struct user_m68kfp_struct elf_fp
 /* For SVR4/m68k the function pointer to be registered with `atexit' is
    passed in %a1.  Although my copy of the ABI has no such statement, it
    is actually used on ASV.  */
-#define ELF_PLAT_INIT(_r)	_r->a1 = 0
+#define ELF_PLAT_INIT(_r, load_addr)	_r->a1 = 0
 
 #define USE_ELF_CORE_DUMP
 #ifndef CONFIG_SUN3
diff -urNp linux-710/include/asm-mips/elf.h linux-720/include/asm-mips/elf.h
--- linux-710/include/asm-mips/elf.h
+++ linux-720/include/asm-mips/elf.h
@@ -89,7 +89,7 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
  * See comments in asm-alpha/elf.h, this is the same thing
  * on the MIPS.
  */
-#define ELF_PLAT_INIT(_r)	do { \
+#define ELF_PLAT_INIT(_r, load_addr)	do { \
 	_r->regs[1] = _r->regs[2] = _r->regs[3] = _r->regs[4] = 0;	\
 	_r->regs[5] = _r->regs[6] = _r->regs[7] = _r->regs[8] = 0;	\
 	_r->regs[9] = _r->regs[10] = _r->regs[11] = _r->regs[12] = 0;	\
diff -urNp linux-710/include/asm-mips64/elf.h linux-720/include/asm-mips64/elf.h
--- linux-710/include/asm-mips64/elf.h
+++ linux-720/include/asm-mips64/elf.h
@@ -88,7 +88,7 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
  * See comments in asm-alpha/elf.h, this is the same thing
  * on the MIPS.
  */
-#define ELF_PLAT_INIT(_r)	do { \
+#define ELF_PLAT_INIT(_r, load_addr)	do { \
 	_r->regs[1] = _r->regs[2] = _r->regs[3] = _r->regs[4] = 0;	\
 	_r->regs[5] = _r->regs[6] = _r->regs[7] = _r->regs[8] = 0;	\
 	_r->regs[9] = _r->regs[10] = _r->regs[11] = _r->regs[12] = 0;	\
diff -urNp linux-710/include/asm-parisc/elf.h linux-720/include/asm-parisc/elf.h
--- linux-710/include/asm-parisc/elf.h
+++ linux-720/include/asm-parisc/elf.h
@@ -118,7 +118,7 @@ struct pt_regs;	/* forward declaration..
    So that we can use the same startup file with static executables,
    we start programs with a value of 0 to indicate that there is no
    such function.  */
-#define ELF_PLAT_INIT(_r)       _r->gr[23] = 0
+#define ELF_PLAT_INIT(_r, load_addr)       _r->gr[23] = 0
 
 #define USE_ELF_CORE_DUMP
 #define ELF_EXEC_PAGESIZE	4096
diff -urNp linux-710/include/asm-ppc64/elf.h linux-720/include/asm-ppc64/elf.h
--- linux-710/include/asm-ppc64/elf.h
+++ linux-720/include/asm-ppc64/elf.h
@@ -97,9 +97,10 @@ ppc64_elf_core_copy_regs(elf_gregset_t d
 #define ELF_PLATFORM	(NULL)
 
 
-#define ELF_PLAT_INIT(_r)	do { \
+#define ELF_PLAT_INIT(_r, load_addr)   do { \
 	memset(_r->gpr, 0, sizeof(_r->gpr)); \
 	_r->ctr = _r->link = _r->xer = _r->ccr = 0; \
+	_r->gpr[2] = load_addr; \
 } while (0)
 
 
diff -urNp linux-710/include/asm-s390/elf.h linux-720/include/asm-s390/elf.h
--- linux-710/include/asm-s390/elf.h
+++ linux-720/include/asm-s390/elf.h
@@ -36,7 +36,7 @@ typedef s390_regs elf_gregset_t;
 
 /* For SVR4/S390 the function pointer to be registered with `atexit` is
    passed in R14. */
-#define ELF_PLAT_INIT(_r) \
+#define ELF_PLAT_INIT(_r, load_addr) \
 	_r->gprs[14] = 0
 
 #define USE_ELF_CORE_DUMP
diff -urNp linux-710/include/asm-s390x/elf.h linux-720/include/asm-s390x/elf.h
--- linux-710/include/asm-s390x/elf.h
+++ linux-720/include/asm-s390x/elf.h
@@ -36,7 +36,7 @@ typedef s390_regs elf_gregset_t;
 
 /* For SVR4/S390 the function pointer to be registered with `atexit` is
    passed in R14. */
-#define ELF_PLAT_INIT(_r) \
+#define ELF_PLAT_INIT(_r, load_addr) \
 	do { \
 	_r->gprs[14] = 0; \
 	} while(0)
diff -urNp linux-710/include/asm-sh/elf.h linux-720/include/asm-sh/elf.h
--- linux-710/include/asm-sh/elf.h
+++ linux-720/include/asm-sh/elf.h
@@ -61,7 +61,7 @@ typedef struct user_fpu_struct elf_fpreg
 
 #define ELF_PLATFORM  (NULL)
 
-#define ELF_PLAT_INIT(_r) \
+#define ELF_PLAT_INIT(_r, load_addr) \
   do { _r->regs[0]=0; _r->regs[1]=0; _r->regs[2]=0; _r->regs[3]=0; \
        _r->regs[4]=0; _r->regs[5]=0; _r->regs[6]=0; _r->regs[7]=0; \
        _r->regs[8]=0; _r->regs[9]=0; _r->regs[10]=0; _r->regs[11]=0; \
diff -urNp linux-710/include/asm-x86_64/elf.h linux-720/include/asm-x86_64/elf.h
--- linux-710/include/asm-x86_64/elf.h
+++ linux-720/include/asm-x86_64/elf.h
@@ -39,7 +39,7 @@ typedef struct user_fxsr_struct elf_fpxr
    We might as well make sure everything else is cleared too (except for %esp),
    just to make things more deterministic.
  */
-#define ELF_PLAT_INIT(_r)	do { \
+#define ELF_PLAT_INIT(_r, load_addr)	do { \
 	struct task_struct *cur = current; \
 	(_r)->rbx = 0; (_r)->rcx = 0; (_r)->rdx = 0; \
 	(_r)->rsi = 0; (_r)->rdi = 0; (_r)->rbp = 0; \
