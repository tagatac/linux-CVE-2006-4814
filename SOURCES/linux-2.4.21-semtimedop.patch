diff -urNp linux-790/arch/ia64/ia32/sys_ia32.c linux-800/arch/ia64/ia32/sys_ia32.c
--- linux-790/arch/ia64/ia32/sys_ia32.c	
+++ linux-800/arch/ia64/ia32/sys_ia32.c	
@@ -48,6 +48,7 @@
 #include <linux/personality.h>
 #include <linux/stat.h>
 #include <linux/ipc.h>
+#include <linux/compat.h>
 #include <linux/ptrace.h>
 
 #include <asm/types.h>
@@ -2573,19 +2574,35 @@ shmctl32 (int first, int second, void *u
 	return err;
 }
 
+extern int sem_ctls[];
+#define sc_semopm	(sem_ctls[2])
+
 static long
-semtimedop32(int semid, struct sembuf *tsems, int nsems,
-	     const struct timespec32 *timeout32)
+semtimedop32(int semid, struct sembuf *tsops, int nsops,
+	     struct compat_timespec *timeout32)
 {
 	struct timespec t;
-	if (get_user (t.tv_sec, &timeout32->tv_sec) ||
-	    get_user (t.tv_nsec, &timeout32->tv_nsec))
+	mm_segment_t oldfs;
+	long ret;
+
+	/* parameter checking precedence should mirror sys_semtimedop() */
+	if (nsops < 1 || semid < 0)
+		return -EINVAL;
+	if (nsops > sc_semopm)
+		return -E2BIG;
+	if (!access_ok(VERIFY_READ, tsops, nsops * sizeof(struct sembuf)) ||
+	    get_compat_timespec(&t, timeout32))
 		return -EFAULT;
-	return sys_semtimedop(semid, tsems, nsems, &t);
+
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	ret = sys_semtimedop(semid, tsops, nsops, &t);
+	set_fs(oldfs);
+	return ret;
 }
 
 asmlinkage long
-sys32_ipc (u32 call, int first, int second, int third, u32 ptr, u32 fifth)
+sys32_ipc(u32 call, int first, int second, int third, u32 ptr, u32 fifth)
 {
 	int version;
 
@@ -2593,13 +2610,15 @@ sys32_ipc (u32 call, int first, int seco
 	call &= 0xffff;
 
 	switch (call) {
+	      case SEMTIMEDOP:
+		if (fifth)
+			return semtimedop32(first, (struct sembuf *)AA(ptr),
+				second, (struct compat_timespec *)AA(fifth));
+		/* else fall through for normal semop() */
 	      case SEMOP:
 		/* struct sembuf is the same on 32 and 64bit :)) */
 		return sys_semtimedop(first, (struct sembuf *)AA(ptr), second,
 				      NULL);
-	      case SEMTIMEDOP:
-		return semtimedop32(first, (struct sembuf *)AA(ptr), second, 
-				    (const struct timespec32 *)AA(fifth));
 	      case SEMGET:
 		return sys_semget(first, second, third);
 	      case SEMCTL:
@@ -2625,7 +2644,7 @@ sys32_ipc (u32 call, int first, int seco
 		return shmctl32(first, second, (void *)AA(ptr));
 
 	      default:
-		return -EINVAL;
+		return -ENOSYS;
 	}
 	return -EINVAL;
 }
@@ -3023,7 +3042,7 @@ save_ia32_fpxstate (struct task_struct *
         ptp = ia64_task_regs(tsk);
 	tos = (tsk->thread.fsr >> 11) & 7;
         for (i = 0; i < 8; i++)
-		put_fpreg(i, (struct _fpxreg_ia32 *)&save->st_space[4*i], ptp, swp, tos);
+		put_fpreg(i, (struct _fpreg_ia32 *)&save->st_space[4*i], ptp, swp, tos);
 
 	mxcsr = ((tsk->thread.fcr>>32) & 0xff80) | ((tsk->thread.fsr>>32) & 0x3f);
 	__put_user(mxcsr & 0xffff, &save->mxcsr);
@@ -3067,7 +3086,7 @@ restore_ia32_fpxstate (struct task_struc
 	ptp = ia64_task_regs(tsk);
 	tos = (tsk->thread.fsr >> 11) & 7;
 	for (i = 0; i < 8; i++)
-	get_fpreg(i, (struct _fpxreg_ia32 *)&save->st_space[4*i], ptp, swp, tos);
+	get_fpreg(i, (struct _fpreg_ia32 *)&save->st_space[4*i], ptp, swp, tos);
 
 	__get_user(mxcsr, (unsigned int *)&save->mxcsr);
 	num64 = mxcsr & 0xff10;
diff -urNp linux-790/arch/ppc64/kernel/syscalls.c linux-800/arch/ppc64/kernel/syscalls.c
--- linux-790/arch/ppc64/kernel/syscalls.c	
+++ linux-800/arch/ppc64/kernel/syscalls.c	
@@ -72,10 +72,15 @@ sys_ipc (uint call, int first, int secon
 	version = call >> 16; /* hack for backward compatibility */
 	call &= 0xffff;
 
-	ret = -EINVAL;
+	ret = -ENOSYS;
 	switch (call) {
 	case SEMOP:
-		ret = sys_semop (first, (struct sembuf *)ptr, second);
+		ret = sys_semtimedop(first, (struct sembuf *)ptr, second,
+				     NULL);
+		break;
+	case SEMTIMEDOP:
+		ret = sys_semtimedop(first, (struct sembuf *)ptr, second,
+				     (const struct timespec *)fifth);
 		break;
 	case SEMGET:
 		ret = sys_semget (first, second, third);
diff -urNp linux-790/arch/ppc64/kernel/sys_ppc32.c linux-800/arch/ppc64/kernel/sys_ppc32.c
--- linux-790/arch/ppc64/kernel/sys_ppc32.c	
+++ linux-800/arch/ppc64/kernel/sys_ppc32.c	
@@ -53,6 +53,7 @@
 #include <linux/highuid.h>
 #include <linux/mman.h>
 #include <linux/sysctl.h>
+#include <linux/compat.h>
 
 #include <asm/types.h>
 #include <asm/ipc.h>
@@ -2559,7 +2560,7 @@ static long do_sys32_semctl(int first, i
 	err = -EFAULT;
 	if (get_user(pad, (u32 *)uptr))
 		return err;
-	if (third == SETVAL)
+	if ((third & (~IPC_64)) == SETVAL)
 		fourth.val = (int)pad;
 	else
 		fourth.__pad = (void *)A(pad);
@@ -2982,6 +2983,32 @@ do_sys32_shmctl(int first, int second, v
 	return err;
 }
 
+extern int sem_ctls[];
+#define sc_semopm	(sem_ctls[2])
+
+static long
+semtimedop32(int semid, struct sembuf *tsops, int nsops,
+	     struct compat_timespec *timeout32)
+{
+	struct timespec t;
+	mm_segment_t oldfs;
+	long ret;
+
+	/* parameter checking precedence should mirror sys_semtimedop() */
+	if (nsops < 1 || semid < 0)
+		return -EINVAL;
+	if (nsops > sc_semopm)
+		return -E2BIG;
+	if (!access_ok(VERIFY_READ, tsops, nsops * sizeof(struct sembuf)) ||
+	    get_compat_timespec(&t, timeout32))
+		return -EFAULT;
+
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	ret = sys_semtimedop(semid, tsops, nsops, &t);
+	set_fs(oldfs);
+	return ret;
+}
 /*
  * Note: it is necessary to treat first_parm, second_parm, and
  * third_parm as unsigned ints, with the corresponding cast to a
@@ -3005,10 +3032,17 @@ asmlinkage long sys32_ipc(u32 call, u32 
 
 	switch (call) {
 
+	case SEMTIMEDOP:
+		if (fifth) {
+			err = semtimedop32(first, (struct sembuf *)AA(ptr),
+				second, (struct compat_timespec *)AA(fifth));
+			break;
+		}
+		/* else fall through for normal semop() */
 	case SEMOP:
 		/* struct sembuf is the same on 32 and 64bit :)) */
-		err = sys_semop(first, (struct sembuf *)AA(ptr),
-				second);
+		err = sys_semtimedop(first, (struct sembuf *)AA(ptr),
+				     second, NULL);
 		break;
 	case SEMGET:
 		err = sys_semget(first, second, third);
@@ -3047,7 +3081,7 @@ asmlinkage long sys32_ipc(u32 call, u32 
 		err = do_sys32_shmctl(first, second, (void *)AA(ptr));
 		break;
 	default:
-		err = -EINVAL;
+		err = -ENOSYS;
 		break;
 	}
 
diff -urNp linux-790/arch/s390/kernel/sys_s390.c linux-800/arch/s390/kernel/sys_s390.c
--- linux-790/arch/s390/kernel/sys_s390.c	
+++ linux-800/arch/s390/kernel/sys_s390.c	
@@ -147,7 +147,11 @@ asmlinkage int sys_ipc (uint call, int f
 
         switch (call) {
         case SEMOP:
-                return sys_semop (first, (struct sembuf *)ptr, second);
+                return sys_semtimedop(first, (struct sembuf *)ptr, second,
+				      NULL);
+        case SEMTIMEDOP:
+                return sys_semtimedop(first, (struct sembuf *)ptr, second,
+				      (const struct timespec *)third);
         case SEMGET:
                 return sys_semget (first, second, third);
         case SEMCTL: {
@@ -191,7 +195,7 @@ asmlinkage int sys_ipc (uint call, int f
 		return sys_shmctl (first, second,
                                    (struct shmid_ds *) ptr);
 	default:
-		return -EINVAL;
+		return -ENOSYS;
 
 	}
         
diff -urNp linux-790/arch/s390x/kernel/linux32.c linux-800/arch/s390x/kernel/linux32.c
--- linux-790/arch/s390x/kernel/linux32.c	
+++ linux-800/arch/s390x/kernel/linux32.c	
@@ -56,6 +56,7 @@
 #include <linux/in.h>
 #include <linux/icmpv6.h>
 #include <linux/sysctl.h>
+#include <linux/compat.h>
 
 #include <asm/types.h>
 #include <asm/ipc.h>
@@ -417,7 +418,7 @@ static int do_sys32_semctl(int first, in
 	err = -EFAULT;
 	if (get_user (pad, (u32 *)uptr))
 		goto out;
-	if(third == SETVAL)
+	if ((third & (~IPC_64)) == SETVAL)
 		fourth.val = (int)pad;
 	else
 		fourth.__pad = (void *)A(pad);
@@ -789,7 +790,46 @@ out:
 	return err;
 }
 
-asmlinkage int sys32_ipc (u32 call, int first, int second, int third, u32 ptr, u32 fifth)
+extern int sem_ctls[];
+#define sc_semopm	(sem_ctls[2])
+#define SEMOPM_FAST	64  /* ~ 372 bytes on stack */
+
+static long
+semtimedop32(int semid, struct sembuf *tsops, int nsops,
+	     struct compat_timespec *timeout32)
+{
+	struct sembuf *sops, fast_sops[SEMOPM_FAST];
+	struct timespec t;
+	mm_segment_t oldfs;
+	long ret;
+
+	/* parameter checking precedence should mirror sys_semtimedop() */
+	if (nsops < 1 || semid < 0)
+		return -EINVAL;
+	if (nsops > sc_semopm)
+		return -E2BIG;
+	if (nsops <= SEMOPM_FAST)
+		sops = fast_sops;
+	else {
+		sops = kmalloc(nsops * sizeof(*sops), GFP_KERNEL);
+		if (sops == NULL)
+			return -ENOMEM;
+	}
+	if (copy_from_user(sops, tsops, nsops * sizeof(*tsops)) ||
+	    get_compat_timespec(&t, timeout32))
+		ret = -EFAULT;
+	else {
+		oldfs = get_fs();
+		set_fs(KERNEL_DS);
+		ret = sys_semtimedop(semid, sops, nsops, &t);
+		set_fs(oldfs);
+	}
+	if (sops != fast_sops)
+		kfree(sops);
+	return ret;
+}
+
+asmlinkage int sys32_ipc (u32 call, int first, int second, int third, u32 ptr)
 {
 	int version, err;
 
@@ -799,11 +839,22 @@ asmlinkage int sys32_ipc (u32 call, int 
 	if(version)
 		return -EINVAL;
 
-	if (call <= SEMCTL)
+	if (call <= SEMTIMEDOP)
 		switch (call) {
+		case SEMTIMEDOP:
+			if (third) {
+				err = semtimedop32(first,
+					(struct sembuf *)AA(ptr),
+					second,
+					(struct compat_timespec *)
+						AA((u32)third));
+				goto out;
+			}
+			/* else fall through for normal semop() */
 		case SEMOP:
 			/* struct sembuf is the same on 32 and 64bit :)) */
-			err = sys_semop (first, (struct sembuf *)AA(ptr), second);
+			err = sys_semtimedop(first, (struct sembuf *)AA(ptr),
+					     second, NULL);
 			goto out;
 		case SEMGET:
 			err = sys_semget (first, second, third);
@@ -812,7 +863,7 @@ asmlinkage int sys32_ipc (u32 call, int 
 			err = do_sys32_semctl (first, second, third, (void *)AA(ptr));
 			goto out;
 		default:
-			err = -EINVAL;
+			err = -ENOSYS;
 			goto out;
 		};
 	if (call <= MSGCTL) 
@@ -831,7 +882,7 @@ asmlinkage int sys32_ipc (u32 call, int 
 			err = do_sys32_msgctl (first, second, (void *)AA(ptr));
 			goto out;
 		default:
-			err = -EINVAL;
+			err = -ENOSYS;
 			goto out;
 		}
 	if (call <= SHMCTL) 
@@ -850,11 +901,11 @@ asmlinkage int sys32_ipc (u32 call, int 
 			err = do_sys32_shmctl (first, second, (void *)AA(ptr));
 			goto out;
 		default:
-			err = -EINVAL;
+			err = -ENOSYS;
 			goto out;
 		}
 
-	err = -EINVAL;
+	err = -ENOSYS;
 
 out:
 	return err;
diff -urNp linux-790/arch/s390x/kernel/sys_s390.c linux-800/arch/s390x/kernel/sys_s390.c
--- linux-790/arch/s390x/kernel/sys_s390.c	
+++ linux-800/arch/s390x/kernel/sys_s390.c	
@@ -132,7 +132,11 @@ asmlinkage int sys_ipc (uint call, int f
 
         switch (call) {
         case SEMOP:
-                return sys_semop (first, (struct sembuf *)ptr, second);
+		return sys_semtimedop(first, (struct sembuf *)ptr, second,
+				      NULL);
+	case SEMTIMEDOP:
+		return sys_semtimedop(first, (struct sembuf *)ptr, second,
+				      (const struct timespec *)third);
         case SEMGET:
                 return sys_semget (first, second, third);
         case SEMCTL: {
@@ -176,7 +180,7 @@ asmlinkage int sys_ipc (uint call, int f
 		return sys_shmctl (first, second,
                                    (struct shmid_ds *) ptr);
 	default:
-		return -EINVAL;
+		return -ENOSYS;
 
 	}
         
diff -urNp linux-790/arch/sparc64/kernel/sys_sparc32.c linux-800/arch/sparc64/kernel/sys_sparc32.c
--- linux-790/arch/sparc64/kernel/sys_sparc32.c	
+++ linux-800/arch/sparc64/kernel/sys_sparc32.c	
@@ -426,7 +426,7 @@ static int do_sys32_semctl(int first, in
 	err = -EFAULT;
 	if (get_user (pad, (u32 *)uptr))
 		goto out;
-	if(third == SETVAL)
+	if ((third & (~IPC_64)) == SETVAL)
 		fourth.val = (int)pad;
 	else
 		fourth.__pad = (void *)A(pad);
diff -urNp linux-790/arch/x86_64/ia32/ipc32.c linux-800/arch/x86_64/ia32/ipc32.c
--- linux-790/arch/x86_64/ia32/ipc32.c	
+++ linux-800/arch/x86_64/ia32/ipc32.c	
@@ -8,6 +8,7 @@
 #include <linux/shm.h>
 #include <linux/slab.h>
 #include <linux/ipc.h>
+#include <linux/compat.h>
 #include <asm/mman.h>
 #include <asm/types.h>
 #include <asm/uaccess.h>
@@ -163,6 +164,7 @@ struct ipc_kludge {
 #define SEMOP		 1
 #define SEMGET		 2
 #define SEMCTL		 3
+#define SEMTIMEDOP	 4
 #define MSGSND		11
 #define MSGRCV		12
 #define MSGGET		13
@@ -627,6 +629,33 @@ shmctl32 (int first, int second, void *u
 	return err;
 }
 
+extern int sem_ctls[];
+#define sc_semopm	(sem_ctls[2])
+
+static long
+semtimedop32(int semid, struct sembuf *tsops, int nsops,
+	     struct compat_timespec *timeout32)
+{
+	struct timespec t;
+	mm_segment_t oldfs;
+	long ret;
+
+	/* parameter checking precedence should mirror sys_semtimedop() */
+	if (nsops < 1 || semid < 0)
+		return -EINVAL;
+	if (nsops > sc_semopm)
+		return -E2BIG;
+	if (!access_ok(VERIFY_READ, tsops, nsops * sizeof(struct sembuf)) ||
+	    get_compat_timespec(&t, timeout32))
+		return -EFAULT;
+
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	ret = sys_semtimedop(semid, tsops, nsops, &t);
+	set_fs(oldfs);
+	return ret;
+}
+
 asmlinkage long
 sys32_ipc (u32 call, int first, int second, int third, u32 ptr, u32 fifth)
 {
@@ -636,9 +665,15 @@ sys32_ipc (u32 call, int first, int seco
 	call &= 0xffff;
 
 	switch (call) {
+	      case SEMTIMEDOP:
+		if (fifth)
+			return semtimedop32(first, (struct sembuf *)AA(ptr),
+				second, (struct compat_timespec *)AA(fifth));
+		/* else fall through for normal semop() */
 	      case SEMOP:
 		/* struct sembuf is the same on 32 and 64bit :)) */
-		return sys_semop(first, (struct sembuf *)AA(ptr), second);
+		return sys_semtimedop(first, (struct sembuf *)AA(ptr), second,
+				      NULL);
 	      case SEMGET:
 		return sys_semget(first, second, third);
 	      case SEMCTL:
@@ -664,7 +699,7 @@ sys32_ipc (u32 call, int first, int seco
 		return shmctl32(first, second, (void *)AA(ptr));
 
 	      default:
-		return -EINVAL;
+		return -ENOSYS;
 	}
 	return -EINVAL;
 }
diff -urNp linux-790/include/asm-ppc64/ipc.h linux-800/include/asm-ppc64/ipc.h
--- linux-790/include/asm-ppc64/ipc.h	
+++ linux-800/include/asm-ppc64/ipc.h	
@@ -19,6 +19,7 @@ struct ipc_kludge {
 #define SEMOP		 1
 #define SEMGET		 2
 #define SEMCTL		 3
+#define SEMTIMEDOP	 4
 #define MSGSND		11
 #define MSGRCV		12
 #define MSGGET		13
diff -urNp linux-790/include/asm-s390/ipc.h linux-800/include/asm-s390/ipc.h
--- linux-790/include/asm-s390/ipc.h	2000-05-12 14:41:44.000000000 -0400
+++ linux-800/include/asm-s390/ipc.h	
@@ -22,6 +22,7 @@ struct ipc_kludge {
 #define SEMOP		 1
 #define SEMGET		 2
 #define SEMCTL		 3
+#define SEMTIMEDOP	 4
 #define MSGSND		11
 #define MSGRCV		12
 #define MSGGET		13
diff -urNp linux-790/include/asm-s390x/ipc.h linux-800/include/asm-s390x/ipc.h
--- linux-790/include/asm-s390x/ipc.h	2001-02-13 17:13:44.000000000 -0500
+++ linux-800/include/asm-s390x/ipc.h	
@@ -22,6 +22,7 @@ struct ipc_kludge {
 #define SEMOP		 1
 #define SEMGET		 2
 #define SEMCTL		 3
+#define SEMTIMEDOP	 4
 #define MSGSND		11
 #define MSGRCV		12
 #define MSGGET		13
diff -urNp linux-790/include/asm-x86_64/unistd.h linux-800/include/asm-x86_64/unistd.h
--- linux-790/include/asm-x86_64/unistd.h	
+++ linux-800/include/asm-x86_64/unistd.h	
@@ -497,6 +497,30 @@ __SYSCALL(__NR_remap_file_pages, sys_ni_
 __SYSCALL(__NR_getdents64, sys_getdents64)
 #define __NR_set_tid_address  218
 __SYSCALL(__NR_set_tid_address, sys_set_tid_address)
+#define __NR_restart_syscall  219
+__SYSCALL(__NR_restart_syscall, sys_ni_syscall)
+#define __NR_semtimedop               220
+__SYSCALL(__NR_semtimedop, sys_semtimedop)
+#define __NR_fadvise64                221
+__SYSCALL(__NR_fadvise64, sys_ni_syscall)
+#define __NR_timer_create             222
+__SYSCALL(__NR_timer_create, sys_ni_syscall)
+#define __NR_timer_settime            223
+__SYSCALL(__NR_timer_settime, sys_ni_syscall)
+#define __NR_timer_gettime            224
+__SYSCALL(__NR_timer_gettime, sys_ni_syscall)
+#define __NR_timer_getoverrun         225
+__SYSCALL(__NR_timer_getoverrun, sys_ni_syscall)
+#define __NR_timer_delete     226
+__SYSCALL(__NR_timer_delete, sys_ni_syscall)
+#define __NR_clock_settime    227
+__SYSCALL(__NR_clock_settime, sys_ni_syscall)
+#define __NR_clock_gettime    228
+__SYSCALL(__NR_clock_gettime, sys_ni_syscall)
+#define __NR_clock_getres     229
+__SYSCALL(__NR_clock_getres, sys_ni_syscall)
+#define __NR_clock_nanosleep  230
+__SYSCALL(__NR_clock_nanosleep, sys_ni_syscall)
 #define __NR_exit_group 231
 __SYSCALL(__NR_exit_group, sys_exit_group)
 
