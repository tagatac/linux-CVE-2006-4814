diff -urNp linux-680/arch/i386/kernel/apm.c linux-690/arch/i386/kernel/apm.c
--- linux-680/arch/i386/kernel/apm.c
+++ linux-690/arch/i386/kernel/apm.c
@@ -879,6 +879,8 @@ recalc:
 		idle_percentage *= 100;
 		idle_percentage /= jiffies_since_last_check;
 		use_apm_idle = (idle_percentage > idle_threshold);
+		if (apm_info.forbid_idle)
+			use_apm_idle = 0;
 		last_jiffies = jiffies;
 		last_stime = current->times.tms_stime;
 	}
@@ -1734,7 +1736,7 @@ static int apm(void *unused)
 	 * Method suggested by Ingo Molnar.
 	 */
 	if (cpu_number_map(smp_processor_id()) != 0) {
-		current->cpus_allowed = 1;
+		set_cpus_allowed(current, 1 << cpu_logical_map(0));
 		schedule();
 		if (unlikely(cpu_number_map(smp_processor_id()) != 0))
 			BUG();
diff -urNp linux-680/arch/i386/kernel/dmi_scan.c linux-690/arch/i386/kernel/dmi_scan.c
--- linux-680/arch/i386/kernel/dmi_scan.c
+++ linux-690/arch/i386/kernel/dmi_scan.c
@@ -297,6 +297,32 @@ static __init int apm_is_horked(struct d
 	return 0;
 }
 
+static __init int apm_is_horked_d850md(struct dmi_blacklist *d)
+{
+	if (apm_info.disabled == 0)
+	{
+		apm_info.disabled = 1;
+		printk(KERN_ERR "%s machine detected. Disabling APM.\n", d->ident);
+		printk(KERN_ERR "This bug is fixed in bios P15 which is available for \n");
+		printk(KERN_ERR "download from support.intel.com \n");
+	}
+	return 0;
+}
+
+/* 
+ * Some APM bioses hang on APM idle calls
+ */
+
+static __init int apm_likes_to_melt(struct dmi_blacklist *d)
+{
+	if (apm_info.forbid_idle == 0)
+	{
+		apm_info.forbid_idle = 1;
+		printk(KERN_INFO "%s machine detected. Disabling APM idle calls.\n", d->ident);
+	}
+	return 0;
+}
+
 /*
  * Some machines, usually laptops, can't handle an enabled local APIC.
  * The symptoms include hangs or reboots when suspending or resuming,
@@ -421,10 +447,10 @@ extern unsigned int pci_probe;
 #endif
 static __init int broken_pirq(struct dmi_blacklist *d)
 {
-	printk(KERN_INFO " *** Possibly defective BIOS detected (irqtable)\n");
-	printk(KERN_INFO " *** Many BIOSes matching this signature have incorrect IRQ routing tables.\n");
-	printk(KERN_INFO " *** If you see IRQ problems, in paticular SCSI resets and hangs at boot\n");
-	printk(KERN_INFO " *** contact your hardware vendor and ask about updates.\n");
+	printk(KERN_ERR " *** Possibly defective BIOS detected (irqtable)\n");
+	printk(KERN_ERR " *** Many BIOSes matching this signature have incorrect IRQ routing tables.\n");
+	printk(KERN_ERR " *** If you see IRQ problems, in particular SCSI resets and hangs at boot\n");
+	printk(KERN_ERR " *** contact your hardware vendor and ask about updates.\n");
 	printk(KERN_INFO " *** Building an SMP kernel may evade the bug some of the time.\n");
 #ifdef CONFIG_X86_IO_APIC
 	skip_ioapic_setup = 0;
@@ -507,6 +533,31 @@ static __init int print_if_true(struct d
 }
 
 /*
+ * IBM bladeservers have a USB console switch. The keyboard type is USB
+ * and the hardware does not have a console keyboard. We disable the
+ * console keyboard so the kernel does not try to initialize one and
+ * spew errors. This can be used for all systems without a console
+ * keyboard like systems with just a USB or IrDA keyboard.
+ */
+static __init int disable_console_keyboard(struct dmi_blacklist *d)
+{
+	extern int keyboard_controller_present;
+	printk(KERN_INFO "*** Hardware has no console keyboard controller.\n");
+	printk(KERN_INFO "*** Disabling console keyboard.\n");
+	keyboard_controller_present = 0;
+	return 0;
+}
+
+/* Sun X4100 and X4200 servers need this to prevent PCI-X devices from being scanned twice */
+/* PCI-X cards will not work in this machine otherwise */
+static __init int pci_no_peer_tricks(struct dmi_blacklist *d)
+{
+ 	extern int pcibios_no_peer_tricks;
+	printk(KERN_INFO "Sun X4100/X4200 detected.. disabling pcibios_peer_tricks.\n");
+ 	pcibios_no_peer_tricks = 1;
+ 	return 0;
+}
+/*
  *	Process the DMI blacklists
  */
  
@@ -522,17 +573,47 @@ static __initdata struct dmi_blacklist d
 			MATCH(DMI_PRODUCT_NAME, "KT7-RAID"),
 			NO_MATCH, NO_MATCH, NO_MATCH
 			} },
+	{ disable_ide_dma, "Dell Inspiron 8100", {	/* Kill DMA on Dell Inspiron 8100 laptops */
+			MATCH(DMI_PRODUCT_NAME, "Inspiron 8100"),
+			MATCH(DMI_SYS_VENDOR,"Dell Computer Corporation"), NO_MATCH, NO_MATCH
+			} },
+
 #endif			
+	/* Dell Laptop hall of shame */
 	{ broken_ps2_resume, "Dell Latitude C600", {	/* Handle problems with APM on the C600 */
 		        MATCH(DMI_SYS_VENDOR, "Dell"),
 			MATCH(DMI_PRODUCT_NAME, "Latitude C600"),
 			NO_MATCH, NO_MATCH
 	                } },
+	{ apm_is_horked, "Dell Inspiron 2500", { /* APM crashes */
+			MATCH(DMI_SYS_VENDOR, "Dell Computer Corporation"),
+			MATCH(DMI_PRODUCT_NAME, "Inspiron 2500"),
+			MATCH(DMI_BIOS_VENDOR,"Phoenix Technologies LTD"),
+			MATCH(DMI_BIOS_VERSION,"A11")
+			} },
+	{ apm_is_horked, "Dell Dimension 4100", { /* APM crashes */
+			MATCH(DMI_SYS_VENDOR, "Dell Computer Corporation"),
+			MATCH(DMI_PRODUCT_NAME, "XPS-Z"),
+			MATCH(DMI_BIOS_VENDOR,"Intel Corp."),
+			MATCH(DMI_BIOS_VERSION,"A11")
+			} },
+	{ set_apm_ints, "Dell Inspiron", {	/* Allow interrupts during suspend on Dell Inspiron laptops*/
+			MATCH(DMI_SYS_VENDOR, "Dell Computer Corporation"),
+			MATCH(DMI_PRODUCT_NAME, "Inspiron 4000"),
+			NO_MATCH, NO_MATCH
+			} },
+	{ set_apm_ints, "Dell Latitude", {	/* Allow interrupts during suspend on Dell Latitude laptops*/
+			MATCH(DMI_SYS_VENDOR, "Dell Computer Corporation"),
+			MATCH(DMI_PRODUCT_NAME, "Latitude C510"),
+			NO_MATCH, NO_MATCH
+			} },
 	{ broken_apm_power, "Dell Inspiron 5000e", {	/* Handle problems with APM on Inspiron 5000e */
 			MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies LTD"),
 			MATCH(DMI_BIOS_VERSION, "A04"),
 			MATCH(DMI_BIOS_DATE, "08/24/2000"), NO_MATCH
 			} },
+
+	/* other items */	
 	{ broken_apm_power, "Dell Inspiron 2500", {	/* Handle problems with APM on Inspiron 2500 */
 			MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies LTD"),
 			MATCH(DMI_BIOS_VERSION, "A12"),
@@ -553,14 +634,19 @@ static __initdata struct dmi_blacklist d
 			MATCH(DMI_PRODUCT_NAME, "PowerEdge 300/"),
 			NO_MATCH, NO_MATCH
 			} },
-	{ set_bios_reboot, "Dell PowerEdge 2400", {  /* Handle problems with rebooting on Dell 300/800's */
+	{ set_bios_reboot, "Dell PowerEdge 2400", {  /* Handle problems with rebooting on Dell 2400's */
 			MATCH(DMI_SYS_VENDOR, "Dell Computer Corporation"),
 			MATCH(DMI_PRODUCT_NAME, "PowerEdge 2400"),
 			NO_MATCH, NO_MATCH
 			} },
-	{ set_apm_ints, "Dell Inspiron", {	/* Allow interrupts during suspend on Dell Inspiron laptops*/
+	{ set_bios_reboot, "Dell PowerEdge 6450", {  /* Handle problems with rebooting on Dell 6450's */
 			MATCH(DMI_SYS_VENDOR, "Dell Computer Corporation"),
-			MATCH(DMI_PRODUCT_NAME, "Inspiron 4000"),
+			MATCH(DMI_PRODUCT_NAME, "PowerEdge 6450"),
+			NO_MATCH, NO_MATCH
+			} },
+	{ set_bios_reboot, "Dell PowerEdge 6400", {  /* Handle problems with rebooting on Dell 6400's */
+			MATCH(DMI_SYS_VENDOR, "Dell Computer Corporation"),
+			MATCH(DMI_PRODUCT_NAME, "PowerEdge 6400"),
 			NO_MATCH, NO_MATCH
 			} },
 	{ set_apm_ints, "Compaq 12XL125", {	/* Allow interrupts during suspend on Compaq Laptops*/
@@ -584,7 +670,7 @@ static __initdata struct dmi_blacklist d
 			MATCH(DMI_BIOS_VERSION, "Version1.01"),
 			NO_MATCH, NO_MATCH,
 			} },
-	{ apm_is_horked, "Intel D850MD", { /* APM crashes */
+	{ apm_is_horked_d850md, "Intel D850MD", { /* APM crashes */
 			MATCH(DMI_BIOS_VENDOR, "Intel Corp."),
 			MATCH(DMI_BIOS_VERSION, "MV85010A.86A.0016.P07.0201251536"),
 			NO_MATCH, NO_MATCH,
@@ -612,6 +698,17 @@ static __initdata struct dmi_blacklist d
 			MATCH(DMI_BIOS_VENDOR,"Phoenix Technologies LTD"),
 			MATCH(DMI_BIOS_VERSION,"A11")
 			} },
+	{ apm_likes_to_melt, "Jabil AMD", { /* APM idle hangs */
+			MATCH(DMI_BIOS_VENDOR, "American Megatrends Inc."),
+			MATCH(DMI_BIOS_VERSION, "0AASNP06"),
+			NO_MATCH, NO_MATCH,
+			} },
+	{ apm_likes_to_melt, "AMI Bios", { /* APM idle hangs */
+			MATCH(DMI_BIOS_VENDOR, "American Megatrends Inc."),
+			MATCH(DMI_BIOS_VERSION, "0AASNP05"), 
+			NO_MATCH, NO_MATCH,
+			} },
+
 	{ sony_vaio_laptop, "Sony Vaio", { /* This is a Sony Vaio laptop */
 			MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
 			MATCH(DMI_PRODUCT_NAME, "PCG-"),
@@ -752,11 +849,26 @@ static __initdata struct dmi_blacklist d
 			} },
 	{ broken_pirq, "l44GX Bios", {        		/* Bad $PIR */
 			MATCH(DMI_BIOS_VENDOR, "Intel Corporation"),
+			MATCH(DMI_BIOS_VERSION,"L440GX0.86B.0066.P07"),
+			NO_MATCH, NO_MATCH
+                        } },
+	{ broken_pirq, "IBM xseries 370", {        		/* Bad $PIR */
+			MATCH(DMI_BIOS_VENDOR, "IBM"),
+			MATCH(DMI_BIOS_VERSION,"MMKT33AUS"),
+			NO_MATCH, NO_MATCH
+                        } },
+	{ broken_pirq, "l44GX Bios", {        		/* Bad $PIR */
+			MATCH(DMI_BIOS_VENDOR, "Intel Corporation"),
 			MATCH(DMI_BIOS_VERSION,"L440GX0.86B.0094.P10"),
 			NO_MATCH, NO_MATCH
                         } },
 	{ broken_pirq, "l44GX Bios", {        		/* Bad $PIR */
 			MATCH(DMI_BIOS_VENDOR, "Intel Corporation"),
+			MATCH(DMI_BIOS_VERSION,"L440GX0.86B.0115.P12"),
+			NO_MATCH, NO_MATCH
+                        } },
+	{ broken_pirq, "l44GX Bios", {        		/* Bad $PIR */
+			MATCH(DMI_BIOS_VENDOR, "Intel Corporation"),
 			MATCH(DMI_BIOS_VERSION,"L440GX0.86B.0120.P12"),
 			NO_MATCH, NO_MATCH
                         } },
@@ -765,11 +877,17 @@ static __initdata struct dmi_blacklist d
 			MATCH(DMI_BIOS_VERSION,"L440GX0.86B.0125.P13"),
 			NO_MATCH, NO_MATCH
 			} },
-	{ broken_pirq, "l44GX Bios", {		/* Bad $PIR */
+	{ broken_pirq, "l44GX Bios", {          /* Bad $PIR */
 			MATCH(DMI_BIOS_VENDOR, "Intel Corporation"),
-			MATCH(DMI_BIOS_VERSION,"L440GX0.86B.0066.P07.9906041405"),
+			MATCH(DMI_BIOS_VERSION,"L440GX0"),
 			NO_MATCH, NO_MATCH
 			} },
+	{ broken_pirq, "l44GX Bios", {          /* Bad $PIR */
+			MATCH(DMI_BIOS_VENDOR, "Intel Corporation"),
+			MATCH(DMI_BIOS_VERSION,"C440GX0"),
+			NO_MATCH, NO_MATCH
+			} },
+		
                         
 	/* Intel in disgiuse - In this case they can't hide and they don't run
 	   too well either... */
@@ -777,6 +895,13 @@ static __initdata struct dmi_blacklist d
 			MATCH(DMI_PRODUCT_NAME, "Dell PowerEdge 8450"),
 			NO_MATCH, NO_MATCH, NO_MATCH
 			} },
+
+	/* Possibly another Intel board issue, bz89593 */
+	{ broken_pirq, "Intel NA440BX DP", {
+			MATCH(DMI_BIOS_VENDOR, "Intel Corporation"),
+			MATCH(DMI_BIOS_VERSION, "NIGHTS0.86B.0095.P14.0001211034"),
+			NO_MATCH, NO_MATCH
+			} },
 			
 	{ init_ints_after_s1, "Toshiba Satellite 4030cdt", { /* Reinitialization of 8259 is needed after S1 resume */
 			MATCH(DMI_PRODUCT_NAME, "S4030CDT/4.3"),
@@ -805,6 +930,25 @@ static __initdata struct dmi_blacklist d
 			NO_MATCH, NO_MATCH, NO_MATCH
 			} },
 
+	/* IBM Bladeservers */
+	{ disable_console_keyboard, "IBM Server Blade", {
+			MATCH(DMI_SYS_VENDOR,"IBM"),
+			MATCH(DMI_BOARD_NAME, "Server Blade"),
+			NO_MATCH, NO_MATCH
+			} },
+	/* SUN */
+	/* x4100 */
+	{ pci_no_peer_tricks, "Sun X4100", {
+			MATCH(DMI_SYS_VENDOR,"Sun Microsystems"),
+			MATCH(DMI_PRODUCT_NAME, "Sun Fire X4100 Server"),
+			NO_MATCH, NO_MATCH
+			} },
+	/* x4200 */
+	{ pci_no_peer_tricks, "Sun X4200", {
+			MATCH(DMI_SYS_VENDOR,"Sun Microsystems"),
+			MATCH(DMI_PRODUCT_NAME, "Sun Fire X4200 Server"),
+			NO_MATCH, NO_MATCH
+			} },
 	{ NULL, }
 };
 	
diff -urNp linux-680/arch/x86_64/kernel/Makefile linux-690/arch/x86_64/kernel/Makefile
--- linux-680/arch/x86_64/kernel/Makefile
+++ linux-690/arch/x86_64/kernel/Makefile
@@ -26,7 +26,7 @@ endif
 obj-y	:= process.o semaphore.o signal.o entry.o traps.o irq.o \
 		ptrace.o i8259.o ioport.o ldt.o setup.o time.o sys_x86_64.o \
 		pci-dma.o x8664_ksyms.o i387.o syscall.o vsyscall.o \
-		setup64.o e820.o
+		setup64.o e820.o dmi_scan.o
 
 ifdef CONFIG_PCI
 obj-y			+= pci-x86_64.o
diff -urNp linux-680/arch/x86_64/kernel/dmi_scan.c linux-690/arch/x86_64/kernel/dmi_scan.c
--- linux-680/arch/x86_64/kernel/dmi_scan.c
+++ linux-690/arch/x86_64/kernel/dmi_scan.c
@@ -0,0 +1,391 @@
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+//#include <asm/io.h>
+#include <linux/pm.h>
+#include <asm/keyboard.h>
+#include <asm/system.h>
+#include <asm/smp.h>
+#include <linux/bootmem.h>
+
+#include "pci-x86_64.h"
+
+unsigned long dmi_broken;
+
+struct dmi_header
+{
+	u8	type;
+	u8	length;
+	u16	handle;
+};
+
+//#define dmi_printk(x)
+#define dmi_printk(x) printk x
+
+static char * __init dmi_string(struct dmi_header *dm, u8 s)
+{
+	u8 *bp=(u8 *)dm;
+	bp+=dm->length;
+	if(!s)
+		return "";
+	s--;
+	while(s>0 && *bp)
+	{
+		bp+=strlen(bp);
+		bp++;
+		s--;
+	}
+	return bp;
+}
+
+/*
+ *	We have to be cautious here. We have seen BIOSes with DMI pointers
+ *	pointing to completely the wrong place for example
+ */
+ 
+static int __init dmi_table(u32 base, int len, int num, void (*decode)(struct dmi_header *))
+{
+	u8 *buf;
+	struct dmi_header *dm;
+	u8 *data;
+	int i=0;
+		
+	/* Since pretty much everything is identity-mapped on x86_64,
+	 * we shouldn't need to do an ioremap here.  phys_to_virt
+	 * should suffice.
+	 */
+	buf = phys_to_virt(base);
+
+	data = buf;
+
+	/*
+ 	 *	Stop when we see all the items the table claimed to have
+ 	 *	OR we run off the end of the table (also happens)
+ 	 */
+ 
+	while(i<num && data-buf+sizeof(struct dmi_header)<=len)
+	{
+		dm=(struct dmi_header *)data;
+		/*
+		 *  We want to know the total length (formated area and strings)
+		 *  before decoding to make sure we won't run off the table in
+		 *  dmi_decode or dmi_string
+		 */
+		data+=dm->length;
+		while(data-buf<len-1 && (data[0] || data[1]))
+			data++;
+		if(data-buf<len-1)
+			decode(dm);
+		data+=2;
+		i++;
+	}
+
+
+	return 0;
+}
+
+
+inline static int __init dmi_checksum(u8 *buf)
+{
+	u8 sum=0;
+	int a;
+	
+	for(a=0; a<15; a++)
+		sum+=buf[a];
+	return (sum==0);
+}
+
+static int __init dmi_iterate(void (*decode)(struct dmi_header *))
+{
+	u8 buf[15];
+	u32 fp=0xF0000;
+
+	while( fp < 0xFFFFF)
+	{
+		isa_memcpy_fromio(buf, fp, 15);
+		if(memcmp(buf, "_DMI_", 5)==0 && dmi_checksum(buf))
+		{
+			u16 num=buf[13]<<8|buf[12];
+			u16 len=buf[7]<<8|buf[6];
+			u32 base=buf[11]<<24|buf[10]<<16|buf[9]<<8|buf[8];
+
+			/*
+			 * DMI version 0.0 means that the real version is taken from
+			 * the SMBIOS version, which we don't know at this point.
+			 */
+			if(buf[14]!=0)
+				dmi_printk((KERN_INFO "DMI %d.%d present.\n",
+					buf[14]>>4, buf[14]&0x0F));
+			else
+				dmi_printk((KERN_INFO "DMI present.\n"));
+			dmi_printk((KERN_INFO "%d structures occupying %d bytes.\n",
+				num, len));
+			dmi_printk((KERN_INFO "DMI table at 0x%08X.\n",
+				base));
+			if(dmi_table(base,len, num, decode)==0)
+				return 0;
+		}
+		fp+=16;
+	}
+	return -1;
+}
+
+
+enum
+{
+	DMI_BIOS_VENDOR,
+	DMI_BIOS_VERSION,
+	DMI_BIOS_DATE,
+	DMI_SYS_VENDOR,
+	DMI_PRODUCT_NAME,
+	DMI_PRODUCT_VERSION,
+	DMI_BOARD_VENDOR,
+	DMI_BOARD_NAME,
+	DMI_BOARD_VERSION,
+	DMI_STRING_MAX
+};
+
+static char *dmi_ident[DMI_STRING_MAX];
+
+/*
+ *	Save a DMI string
+ */
+ 
+static void __init dmi_save_ident(struct dmi_header *dm, int slot, int string)
+{
+	char *d = (char*)dm;
+	char *p = dmi_string(dm, d[string]);
+	if(p==NULL || *p == 0)
+		return;
+	if (dmi_ident[slot])
+		return;
+	dmi_ident[slot] = alloc_bootmem(strlen(p)+1);
+	if(dmi_ident[slot])
+		strcpy(dmi_ident[slot], p);
+	else
+		printk(KERN_ERR "dmi_save_ident: out of memory.\n");
+}
+
+/*
+ *	DMI callbacks for problem boards
+ */
+
+struct dmi_strmatch
+{
+	u8 slot;
+	char *substr;
+};
+
+#define NONE	255
+
+struct dmi_blacklist
+{
+	int (*callback)(struct dmi_blacklist *);
+	char *ident;
+	struct dmi_strmatch matches[4];
+};
+
+#define NO_MATCH	{ NONE, NULL}
+#define MATCH(a,b)	{ a, b }
+
+/*
+ *	Simple "print if true" callback
+ */
+ 
+static __init int print_if_true(struct dmi_blacklist *d)
+{
+	printk("%s\n", d->ident);
+	return 0;
+}
+
+/*
+ * IBM bladeservers have a USB console switch. The keyboard type is USB
+ * and the hardware does not have a console keyboard. We disable the
+ * console keyboard so the kernel does not try to initialize one and
+ * spew errors. This can be used for all systems without a console
+ * keyboard like systems with just a USB or IrDA keyboard.
+ */
+static __init int disable_console_keyboard(struct dmi_blacklist *d)
+{
+ 	extern int keyboard_controller_present;
+	printk(KERN_INFO "*** Hardware has no console keyboard controller.\n");
+	printk(KERN_INFO "*** Disabling console keyboard.\n");
+ 	keyboard_controller_present = 0;
+ 	return 0;
+}
+
+
+/*
+ * The RHEL3 IO APIC initialization does not work correctly on IBM eServer
+ * xSeries 260 (also called x3800), 366 (x3850) and 460 (x3950). Therefore
+ * disable it.
+ *
+ * Also, if this is a 64-bit Intel kernel (IA32E) and running on the above
+ * mentioned machines, and nmi_watchdog is set to use IO APIC initialization,
+ * then set the nmi_watchdog to use Local APIC instead. This is required since
+ * the IO APIC intialization is disabled by this function.
+ */
+static __init int force_acpi_noirq_nmi_probing(struct dmi_blacklist *d)
+{
+	extern int acpi_noirq;
+	printk(KERN_INFO "%s detected. Disabling ACPI IO initialization.\n",
+		d->ident);
+	acpi_noirq = 1;
+#ifdef CONFIG_IA32E
+#ifdef CONFIG_X86_LOCAL_APIC
+	if (nmi_watchdog == NMI_IO_APIC)
+		nmi_watchdog = NMI_LOCAL_APIC;
+#endif
+#endif
+	return 0;
+}
+
+/*
+ *	Process the DMI blacklists
+ */
+ 
+
+/*
+ *	This will be expanded over time to force things like the APM 
+ *	interrupt mask settings according to the laptop
+ */
+ 
+static __initdata struct dmi_blacklist dmi_blacklist[] = {
+
+	/* IBM Bladeservers */
+	{ disable_console_keyboard, "IBM Server Blade", {
+			MATCH(DMI_SYS_VENDOR,"IBM"),
+			MATCH(DMI_BOARD_NAME, "Server Blade"),
+			NO_MATCH, NO_MATCH
+			} },
+	/* IBM eSeries xServer 266, 366, and 460 */
+	{ force_acpi_noirq_nmi_probing, "IBM eServer xSeries 260", {
+			MATCH(DMI_SYS_VENDOR,"IBM"),
+			MATCH(DMI_PRODUCT_NAME, "eserver xSeries 260"),
+			NO_MATCH, NO_MATCH
+			} },
+	{ force_acpi_noirq_nmi_probing, "IBM eServer xSeries 366", {
+			MATCH(DMI_SYS_VENDOR,"IBM"),
+			MATCH(DMI_PRODUCT_NAME, "eserver xSeries 366"),
+			NO_MATCH, NO_MATCH
+			} },
+	{ force_acpi_noirq_nmi_probing, "IBM eServer xSeries 460", {
+			MATCH(DMI_SYS_VENDOR,"IBM"),
+			MATCH(DMI_PRODUCT_NAME, "eserver xSeries 460"),
+			NO_MATCH, NO_MATCH
+			} },
+	/* formerly known as x460 */
+	{ force_acpi_noirq_nmi_probing, "IBM x3950", {
+			MATCH(DMI_SYS_VENDOR,"IBM"),
+			MATCH(DMI_PRODUCT_NAME, "IBM x3950"),
+			NO_MATCH, NO_MATCH
+			} },
+	/* formerly known as x366 */
+	{ force_acpi_noirq_nmi_probing, "IBM x3850", {
+			MATCH(DMI_SYS_VENDOR,"IBM"),
+			MATCH(DMI_PRODUCT_NAME, "IBM x3850"),
+			NO_MATCH, NO_MATCH
+			} },
+	/* formerly known as x266 */
+	{ force_acpi_noirq_nmi_probing, "IBM x3800", {
+			MATCH(DMI_SYS_VENDOR,"IBM"),
+			MATCH(DMI_PRODUCT_NAME, "IBM x3800"),
+			NO_MATCH, NO_MATCH
+			} },
+
+	{ NULL, }
+};
+	
+	
+/*
+ *	Walk the blacklist table running matching functions until someone 
+ *	returns 1 or we hit the end.
+ */
+ 
+static __init void dmi_check_blacklist(void)
+{
+	struct dmi_blacklist *d;
+	int i;
+		
+	d=&dmi_blacklist[0];
+	while(d->callback)
+	{
+		for(i=0;i<4;i++)
+		{
+			int s = d->matches[i].slot;
+			if(s==NONE)
+				continue;
+			if(dmi_ident[s] && strstr(dmi_ident[s], d->matches[i].substr))
+				continue;
+			/* No match */
+			goto fail;
+		}
+		if(d->callback(d))
+			return;
+fail:			
+		d++;
+	}
+}
+
+	
+
+/*
+ *	Process a DMI table entry. Right now all we care about are the BIOS
+ *	and machine entries. For 2.5 we should pull the smbus controller info
+ *	out of here.
+ */
+
+static void __init dmi_decode(struct dmi_header *dm)
+{
+	u8 *data = (u8 *)dm;
+	
+	switch(dm->type)
+	{
+		case  0:
+			dmi_printk(("BIOS Vendor: %s\n",
+				dmi_string(dm, data[4])));
+			dmi_save_ident(dm, DMI_BIOS_VENDOR, 4);
+			dmi_printk(("BIOS Version: %s\n", 
+				dmi_string(dm, data[5])));
+			dmi_save_ident(dm, DMI_BIOS_VERSION, 5);
+			dmi_printk(("BIOS Release: %s\n",
+				dmi_string(dm, data[8])));
+			dmi_save_ident(dm, DMI_BIOS_DATE, 8);
+			break;
+		case 1:
+			dmi_printk(("System Vendor: %s\n",
+				dmi_string(dm, data[4])));
+			dmi_save_ident(dm, DMI_SYS_VENDOR, 4);
+			dmi_printk(("Product Name: %s\n",
+				dmi_string(dm, data[5])));
+			dmi_save_ident(dm, DMI_PRODUCT_NAME, 5);
+			dmi_printk(("Version: %s\n",
+				dmi_string(dm, data[6])));
+			dmi_save_ident(dm, DMI_PRODUCT_VERSION, 6);
+			dmi_printk(("Serial Number: %s\n",
+				dmi_string(dm, data[7])));
+			break;
+		case 2:
+			dmi_printk(("Board Vendor: %s\n",
+				dmi_string(dm, data[4])));
+			dmi_save_ident(dm, DMI_BOARD_VENDOR, 4);
+			dmi_printk(("Board Name: %s\n",
+				dmi_string(dm, data[5])));
+			dmi_save_ident(dm, DMI_BOARD_NAME, 5);
+			dmi_printk(("Board Version: %s\n",
+				dmi_string(dm, data[6])));
+			dmi_save_ident(dm, DMI_BOARD_VERSION, 6);
+			break;
+	}
+}
+
+void __init dmi_scan_machine(void)
+{
+	int err = dmi_iterate(dmi_decode);
+	if(err == 0)
+		dmi_check_blacklist();
+}
diff -urNp linux-680/arch/x86_64/kernel/setup.c linux-690/arch/x86_64/kernel/setup.c
--- linux-680/arch/x86_64/kernel/setup.c
+++ linux-690/arch/x86_64/kernel/setup.c
@@ -370,6 +370,7 @@ void __init setup_arch(char **cmdline_p)
 #endif
 
 	paging_init();
+	dmi_scan_machine();
 
 #ifdef CONFIG_X86_IO_APIC
 	check_ioapic();
diff -urNp linux-680/include/asm-x86_64/proto.h linux-690/include/asm-x86_64/proto.h
--- linux-680/include/asm-x86_64/proto.h
+++ linux-690/include/asm-x86_64/proto.h
@@ -11,6 +11,7 @@ extern void pda_init(int); 
 
 extern void mcheck_init(struct cpuinfo_x86 *c);
 extern void init_memory_mapping(void);
+extern void dmi_scan_machine(void);
 
 extern void system_call(void); 
 extern void ia32_cstar_target(void); 
diff -urNp linux-680/include/linux/apm_bios.h linux-690/include/linux/apm_bios.h
--- linux-680/include/linux/apm_bios.h
+++ linux-690/include/linux/apm_bios.h
@@ -53,6 +53,7 @@ struct apm_info {
 	int			get_power_status_broken;
 	int			get_power_status_swabinminutes;
 	int			allow_ints;
+	int			forbid_idle;
 	int			realmode_power_off;
 	int			disabled;
 };
