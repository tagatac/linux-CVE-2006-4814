diff -urNp linux-1040/include/asm-alpha/resource.h linux-1050/include/asm-alpha/resource.h
--- linux-1040/include/asm-alpha/resource.h
+++ linux-1050/include/asm-alpha/resource.h
@@ -39,7 +39,7 @@
     {INR_OPEN, INR_OPEN},			/* RLIMIT_NOFILE */	\
     {LONG_MAX, LONG_MAX},			/* RLIMIT_AS */		\
     {LONG_MAX, LONG_MAX},			/* RLIMIT_NPROC */	\
-    {LONG_MAX, LONG_MAX},			/* RLIMIT_MEMLOCK */	\
+    {PAGE_SIZE,PAGE_SIZE},			/* RLIMIT_MEMLOCK */	\
     {LONG_MAX, LONG_MAX},                       /* RLIMIT_LOCKS */      \
 }
 
diff -urNp linux-1040/include/asm-arm/resource.h linux-1050/include/asm-arm/resource.h
--- linux-1040/include/asm-arm/resource.h
+++ linux-1050/include/asm-arm/resource.h
@@ -37,7 +37,7 @@
 	{ RLIM_INFINITY, RLIM_INFINITY },	\
 	{ 0,             0             },	\
 	{ INR_OPEN,      INR_OPEN      },	\
-	{ RLIM_INFINITY, RLIM_INFINITY },	\
+	{ PAGE_SIZE,     PAGE_SIZE     },	\
 	{ RLIM_INFINITY, RLIM_INFINITY },	\
 	{ RLIM_INFINITY, RLIM_INFINITY },	\
 }
diff -urNp linux-1040/include/asm-cris/resource.h linux-1050/include/asm-cris/resource.h
--- linux-1040/include/asm-cris/resource.h
+++ linux-1050/include/asm-cris/resource.h
@@ -37,7 +37,7 @@
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 	{             0,             0 },		\
 	{      INR_OPEN,     INR_OPEN  },		\
-	{ RLIM_INFINITY, RLIM_INFINITY },               \
+	{     PAGE_SIZE,     PAGE_SIZE },		\
         { RLIM_INFINITY, RLIM_INFINITY },		\
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 }
diff -urNp linux-1040/include/asm-i386/resource.h linux-1050/include/asm-i386/resource.h
--- linux-1040/include/asm-i386/resource.h
+++ linux-1050/include/asm-i386/resource.h
@@ -37,7 +37,7 @@
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 	{             0,             0 },		\
 	{      INR_OPEN,     INR_OPEN  },		\
-	{ RLIM_INFINITY, RLIM_INFINITY },		\
+	{     PAGE_SIZE,     PAGE_SIZE },		\
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
         { RLIM_INFINITY, RLIM_INFINITY },		\
 }
diff -urNp linux-1040/include/asm-ia64/resource.h linux-1050/include/asm-ia64/resource.h
--- linux-1040/include/asm-ia64/resource.h
+++ linux-1050/include/asm-ia64/resource.h
@@ -40,7 +40,7 @@
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 	{             0,             0 },		\
 	{      INR_OPEN,     INR_OPEN  },		\
-	{ RLIM_INFINITY, RLIM_INFINITY },		\
+	{     PAGE_SIZE,     PAGE_SIZE },		\
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 }
diff -urNp linux-1040/include/asm-m68k/resource.h linux-1050/include/asm-m68k/resource.h
--- linux-1040/include/asm-m68k/resource.h
+++ linux-1050/include/asm-m68k/resource.h
@@ -37,7 +37,7 @@
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 	{             0,             0 },		\
 	{      INR_OPEN,     INR_OPEN  },		\
-	{ RLIM_INFINITY, RLIM_INFINITY },		\
+	{     PAGE_SIZE,     PAGE_SIZE },		\
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
         { RLIM_INFINITY, RLIM_INFINITY },		\
 }
diff -urNp linux-1040/include/asm-mips/resource.h linux-1050/include/asm-mips/resource.h
--- linux-1040/include/asm-mips/resource.h
+++ linux-1050/include/asm-mips/resource.h
@@ -44,7 +44,7 @@
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 	{ 0,             0             },		\
-	{ RLIM_INFINITY, RLIM_INFINITY },		\
+	{     PAGE_SIZE,     PAGE_SIZE },		\
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 }
 
diff -urNp linux-1040/include/asm-mips64/resource.h linux-1050/include/asm-mips64/resource.h
--- linux-1040/include/asm-mips64/resource.h
+++ linux-1050/include/asm-mips64/resource.h
@@ -45,7 +45,7 @@
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 	{ 0,             0             },		\
-	{ RLIM_INFINITY, RLIM_INFINITY },		\
+	{ PAGE_SIZE,     PAGE_SIZE     },		\
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 }
 
diff -urNp linux-1040/include/asm-parisc/resource.h linux-1050/include/asm-parisc/resource.h
--- linux-1040/include/asm-parisc/resource.h
+++ linux-1050/include/asm-parisc/resource.h
@@ -37,7 +37,7 @@
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 	{             0,             0 },		\
 	{      INR_OPEN,     INR_OPEN  },		\
-	{ RLIM_INFINITY, RLIM_INFINITY },		\
+	{     PAGE_SIZE,     PAGE_SIZE },		\
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 }
diff -urNp linux-1040/include/asm-ppc/resource.h linux-1050/include/asm-ppc/resource.h
--- linux-1040/include/asm-ppc/resource.h
+++ linux-1050/include/asm-ppc/resource.h
@@ -34,7 +34,7 @@
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 	{             0,             0 },		\
 	{      INR_OPEN,     INR_OPEN  },		\
-	{ RLIM_INFINITY, RLIM_INFINITY },		\
+	{     PAGE_SIZE,     PAGE_SIZE },		\
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 }
diff -urNp linux-1040/include/asm-ppc64/mman.h linux-1050/include/asm-ppc64/mman.h
--- linux-1040/include/asm-ppc64/mman.h
+++ linux-1050/include/asm-ppc64/mman.h
@@ -20,6 +20,7 @@
 #define MAP_ANONYMOUS	0x20		/* don't use a file */
 #define MAP_RENAME      MAP_ANONYMOUS   /* In SunOS terminology */
 #define MAP_NORESERVE   0x40            /* don't reserve swap pages */
+#define MAP_LOCKED	0x80
 
 #define MAP_GROWSDOWN	0x0100		/* stack-like segment */
 #define MAP_DENYWRITE	0x0800		/* ETXTBSY */
diff -urNp linux-1040/include/asm-ppc64/resource.h linux-1050/include/asm-ppc64/resource.h
--- linux-1040/include/asm-ppc64/resource.h
+++ linux-1050/include/asm-ppc64/resource.h
@@ -43,7 +43,7 @@
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 	{             0,             0 },		\
 	{      INR_OPEN,     INR_OPEN  },		\
-	{ RLIM_INFINITY, RLIM_INFINITY },		\
+	{     PAGE_SIZE,     PAGE_SIZE },		\
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 }
diff -urNp linux-1040/include/asm-s390/resource.h linux-1050/include/asm-s390/resource.h
--- linux-1040/include/asm-s390/resource.h
+++ linux-1050/include/asm-s390/resource.h
@@ -45,7 +45,7 @@
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 	{             0,             0 },		\
 	{ INR_OPEN, INR_OPEN },                         \
-	{ RLIM_INFINITY, RLIM_INFINITY },		\
+	{     PAGE_SIZE,     PAGE_SIZE },		\
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 }
diff -urNp linux-1040/include/asm-s390x/resource.h linux-1050/include/asm-s390x/resource.h
--- linux-1040/include/asm-s390x/resource.h
+++ linux-1050/include/asm-s390x/resource.h
@@ -45,7 +45,7 @@
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 	{        0,        0 },                  	\
 	{ INR_OPEN, INR_OPEN },                         \
-	{ RLIM_INFINITY, RLIM_INFINITY },		\
+	{     PAGE_SIZE,     PAGE_SIZE },		\
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 }
diff -urNp linux-1040/include/asm-sh/resource.h linux-1050/include/asm-sh/resource.h
--- linux-1040/include/asm-sh/resource.h
+++ linux-1050/include/asm-sh/resource.h
@@ -37,7 +37,7 @@
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 	{             0,             0 },		\
 	{      INR_OPEN,     INR_OPEN  },		\
-	{ RLIM_INFINITY, RLIM_INFINITY },		\
+	{     PAGE_SIZE,     PAGE_SIZE },		\
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 }
diff -urNp linux-1040/include/asm-sparc/resource.h linux-1050/include/asm-sparc/resource.h
--- linux-1040/include/asm-sparc/resource.h
+++ linux-1050/include/asm-sparc/resource.h
@@ -42,7 +42,7 @@
     {       0, RLIM_INFINITY},		\
     {RLIM_INFINITY, RLIM_INFINITY},	\
     {INR_OPEN, INR_OPEN}, {0, 0},	\
-    {RLIM_INFINITY, RLIM_INFINITY},	\
+    {PAGE_SIZE,     PAGE_SIZE },	\
     {RLIM_INFINITY, RLIM_INFINITY},	\
     {RLIM_INFINITY, RLIM_INFINITY}	\
 }
diff -urNp linux-1040/include/asm-sparc64/resource.h linux-1050/include/asm-sparc64/resource.h
--- linux-1040/include/asm-sparc64/resource.h
+++ linux-1050/include/asm-sparc64/resource.h
@@ -41,7 +41,7 @@
     {       0, RLIM_INFINITY},		\
     {RLIM_INFINITY, RLIM_INFINITY},	\
     {INR_OPEN, INR_OPEN}, {0, 0},	\
-    {RLIM_INFINITY, RLIM_INFINITY},	\
+    {PAGE_SIZE,     PAGE_SIZE },	\
     {RLIM_INFINITY, RLIM_INFINITY},	\
     {RLIM_INFINITY, RLIM_INFINITY}	\
 }
diff -urNp linux-1040/include/asm-x86_64/resource.h linux-1050/include/asm-x86_64/resource.h
--- linux-1040/include/asm-x86_64/resource.h
+++ linux-1050/include/asm-x86_64/resource.h
@@ -37,7 +37,7 @@
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
 	{             0,             0 },		\
 	{      INR_OPEN,     INR_OPEN  },		\
-	{ RLIM_INFINITY, RLIM_INFINITY },		\
+	{     PAGE_SIZE,     PAGE_SIZE },		\
 	{ RLIM_INFINITY, RLIM_INFINITY },		\
         { RLIM_INFINITY, RLIM_INFINITY },		\
 }
diff -urNp linux-1040/include/linux/mm.h linux-1050/include/linux/mm.h
--- linux-1040/include/linux/mm.h
+++ linux-1050/include/linux/mm.h
@@ -601,7 +601,7 @@ extern void clear_page_tables(struct mm_
 extern int fail_writepage(struct page *);
 struct page * shmem_nopage(struct vm_area_struct * vma, unsigned long address, int unused);
 struct file *shmem_file_setup(char * name, loff_t size);
-extern void shmem_lock(struct file * file, int lock);
+extern int shmem_lock(struct file *, int lock, struct mm_struct **, pid_t *);
 extern int shmem_zero_setup(struct vm_area_struct *);
 
 extern void zap_page_range(struct mm_struct *mm, unsigned long address, unsigned long size);
@@ -705,6 +705,17 @@ static inline int can_vma_merge(struct v
 		return 0;
 }
 
+/* mlock can just return an instant EPERM if the caller has no
+   permission to do any memory locking. */
+static inline int can_do_mlock(void)
+{
+	if (current->rlim[RLIMIT_MEMLOCK].rlim_cur != 0)
+		return 1;
+	if (capable(CAP_IPC_LOCK))
+		return 1;
+	return 0;
+}
+
 struct zone_t;
 /* filemap.c */
 extern void remove_inode_page(struct page *);
diff -urNp linux-1040/ipc/shm.c linux-1050/ipc/shm.c
--- linux-1040/ipc/shm.c
+++ linux-1050/ipc/shm.c
@@ -38,6 +38,8 @@ struct shmid_kernel /* private to the ke
 	time_t			shm_ctim;
 	pid_t			shm_cprid;
 	pid_t			shm_lprid;
+	struct mm_struct *	shm_locker_mm;
+	pid_t			shm_locker_pid;
 };
 
 #define shm_flags	shm_perm.mode
@@ -124,7 +126,9 @@ static void shm_destroy (struct shmid_ke
 	shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;
 	shm_rmid (shp->id);
 	shm_unlock_deleted(shp);
-	shmem_lock(shp->shm_file, 0);
+	shmem_lock(shp->shm_file, 0,
+		&shp->shm_locker_mm,
+		&shp->shm_locker_pid);
 	fput (shp->shm_file);
 	kfree (shp);
 }
@@ -458,23 +462,31 @@ asmlinkage long sys_shmctl (int shmid, i
 	case SHM_LOCK:
 	case SHM_UNLOCK:
 	{
-/* Allow superuser to lock segment in memory */
-/* Should the pages be faulted in here or leave it to user? */
-/* need to determine interaction with current->swappable */
-		if (!capable(CAP_IPC_LOCK))
+		/* Allow superuser to lock segment in memory */
+		if (!can_do_mlock())
 			return -EPERM;
-
 		shp = shm_lock(shmid);
 		if(shp==NULL)
 			return -EINVAL;
 		err = shm_checkid(shp,shmid);
 		if(err)
 			goto out_unlock;
+		if (current->euid != shp->shm_perm.uid &&
+		    current->euid != shp->shm_perm.cuid &&
+		    !capable(CAP_IPC_LOCK)) {
+			err = -EPERM;
+			goto out_unlock;
+		}
 		if(cmd==SHM_LOCK) {
-			shmem_lock(shp->shm_file, 1);
-			shp->shm_flags |= SHM_LOCKED;
+			err = shmem_lock(shp->shm_file, 1,
+					&shp->shm_locker_mm,
+					&shp->shm_locker_pid);
+			if (!err)
+				shp->shm_flags |= SHM_LOCKED;
 		} else {
-			shmem_lock(shp->shm_file, 0);
+			shmem_lock(shp->shm_file, 0,
+					&shp->shm_locker_mm,
+					&shp->shm_locker_pid);
 			shp->shm_flags &= ~SHM_LOCKED;
 		}
 		shm_unlock(shmid);
diff -urNp linux-1040/mm/mlock.c linux-1050/mm/mlock.c
--- linux-1040/mm/mlock.c
+++ linux-1050/mm/mlock.c
@@ -151,7 +151,7 @@ static int do_mlock(unsigned long start,
 	struct vm_area_struct * vma, * next;
 	int error;
 
-	if (on && !capable(CAP_IPC_LOCK))
+	if (on && !can_do_mlock())
 		return -EPERM;
 	len = PAGE_ALIGN(len);
 	end = start + len;
@@ -206,16 +206,15 @@ asmlinkage long sys_mlock(unsigned long 
 	locked = len >> PAGE_SHIFT;
 	locked += current->mm->locked_vm;
 
-	lock_limit = current->rlim[RLIMIT_MEMLOCK].rlim_cur;
-	lock_limit >>= PAGE_SHIFT;
-
-	/* check against resource limits */
-	if (locked > lock_limit)
+	/* we may lock at most 90% of physical memory... */
+	/* (this check is pretty bogus, but doesn't hurt) */
+	if (locked > num_physpages/10*9)
 		goto out;
 
-	/* we may lock at most half of physical memory... */
-	/* (this check is pretty bogus, but doesn't hurt) */
-	if (locked > num_physpages/2)
+	/* check against resource limits */
+	lock_limit = current->rlim[RLIMIT_MEMLOCK].rlim_cur;
+	lock_limit >>= PAGE_SHIFT;
+	if (locked > lock_limit && !capable(CAP_IPC_LOCK))
 		goto out;
 
 	error = do_mlock(start, len, 1);
@@ -245,7 +244,7 @@ static int do_mlockall(int flags)
 	unsigned int def_flags;
 	struct vm_area_struct * vma;
 
-	if (!capable(CAP_IPC_LOCK))
+	if (!can_do_mlock())
 		return -EPERM;
 
 	def_flags = 0;
@@ -278,16 +277,17 @@ asmlinkage long sys_mlockall(int flags)
 	if (!flags || (flags & ~(MCL_CURRENT | MCL_FUTURE)))
 		goto out;
 
-	lock_limit = current->rlim[RLIMIT_MEMLOCK].rlim_cur;
-	lock_limit >>= PAGE_SHIFT;
-
 	ret = -ENOMEM;
-	if (current->mm->total_vm > lock_limit)
-		goto out;
 
-	/* we may lock at most half of physical memory... */
+	/* we may lock at most 90% of physical memory... */
 	/* (this check is pretty bogus, but doesn't hurt) */
-	if (current->mm->total_vm > num_physpages/2)
+	if (current->mm->total_vm > num_physpages/10*9)
+		goto out;
+
+	/* check against resource limits */
+	lock_limit = current->rlim[RLIMIT_MEMLOCK].rlim_cur;
+	lock_limit >>= PAGE_SHIFT;
+	if (current->mm->total_vm > lock_limit && !capable(CAP_IPC_LOCK))
 		goto out;
 
 	ret = do_mlockall(flags);
diff -urNp linux-1040/mm/mmap.c linux-1050/mm/mmap.c
--- linux-1040/mm/mmap.c
+++ linux-1050/mm/mmap.c
@@ -518,11 +518,16 @@ unsigned long do_mmap_pgoff(struct file 
 	 */
 	vm_flags = calc_vm_flags(prot,flags) | mm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
 
+	if (flags & MAP_LOCKED)
+		vm_flags |= VM_LOCKED;
+
 	/* mlock MCL_FUTURE? */
 	if (vm_flags & VM_LOCKED) {
-		unsigned long locked = mm->locked_vm << PAGE_SHIFT;
+		unsigned long locked, lock_limit;
+		locked = mm->locked_vm << PAGE_SHIFT;
+		lock_limit = current->rlim[RLIMIT_MEMLOCK].rlim_cur;
 		locked += len;
-		if (locked > current->rlim[RLIMIT_MEMLOCK].rlim_cur)
+		if (locked > lock_limit && !capable(CAP_IPC_LOCK))
 			return -EAGAIN;
 	}
 
@@ -848,50 +853,6 @@ struct vm_area_struct * find_vma_prev(st
 /* vma is the first one with  address < vma->vm_end,
  * and even  address < vma->vm_start. Have to extend vma. */
  
-#ifdef ARCH_STACK_GROWSUP
-static inline int expand_stack(struct vm_area_struct * vma, unsigned long address)
-{
-	unsigned long grow;
-
-	if (!(vma->vm_flags & VM_GROWSUP))
-		return -EFAULT;
-
-	vm_validate_enough("entering expand_stack");
-
-	/*
-	 * vma->vm_start/vm_end cannot change under us because the caller is required
-	 * to hold the mmap_sem in write mode. We need to get the spinlock only
-	 * before relocating the vma range ourself.
-	 */
- 	spin_lock(&vma->vm_mm->page_table_lock);
-
-	address += 4 + PAGE_SIZE - 1;
-	address &= PAGE_MASK;
-	grow = (address - vma->vm_end) >> PAGE_SHIFT;
-	
-	/* Overcommit.. */
-	if(!vm_enough_memory(grow)) {
-		spin_unlock(&vma->vm_mm->page_table_lock);
-		return -ENOMEM;
-	}
-	
-	if (address - vma->vm_start > current->rlim[RLIMIT_STACK].rlim_cur ||
-	    ((vma->vm_mm->total_vm + grow) << PAGE_SHIFT) > current->rlim[RLIMIT_AS].rlim_cur)
-	{
-		spin_unlock(&vma->vm_mm->page_table_lock);
-		vm_unacct_memory(grow);
-		vm_validate_enough("exiting expand_stack - FAIL");
-		return -ENOMEM;
-	}
-	vma->vm_end = address;
-	vma->vm_mm->total_vm += grow;
-	if (vma->vm_flags & VM_LOCKED)
-		vma->vm_mm->locked_vm += grow;
-	vm_validate_enough("exiting expand_stack");
-	return 0;
-}
-#else
-
 int expand_stack(struct vm_area_struct * vma, unsigned long address)
 {
 	unsigned long grow;
@@ -923,6 +884,15 @@ int expand_stack(struct vm_area_struct *
 		vm_validate_enough("exiting expand_stack - FAIL");
 		return -ENOMEM;
 	}
+	if ((vma->vm_flags & VM_LOCKED) &&
+	    ((vma->vm_mm->locked_vm + grow) << PAGE_SHIFT) >
+	     current->rlim[RLIMIT_MEMLOCK].rlim_cur &&
+	    !capable(CAP_IPC_LOCK)) {
+		spin_unlock(&vma->vm_mm->page_table_lock);
+		vm_unacct_memory(grow);
+		vm_validate_enough("exiting expand_stack - FAIL");
+		return -ENOMEM;
+	}
 	vma->vm_start = address;
 	vma->vm_pgoff -= grow;
 	vma->vm_mm->total_vm += grow;
@@ -933,8 +903,6 @@ int expand_stack(struct vm_area_struct *
 	return 0;
 }
 
-#endif
-
 struct vm_area_struct * find_extend_vma(struct mm_struct * mm, unsigned long addr)
 {
 	struct vm_area_struct * vma;
@@ -1257,13 +1225,18 @@ unsigned long do_brk(unsigned long addr,
 	if (!len)
 		return addr;
 
+	if ((addr + len) > TASK_SIZE || (addr + len) < addr)
+		return -EINVAL;
+
 	/*
 	 * mlock MCL_FUTURE?
 	 */
 	if (mm->def_flags & VM_LOCKED) {
-		unsigned long locked = mm->locked_vm << PAGE_SHIFT;
+		unsigned long locked, lock_limit;
+		locked = mm->locked_vm << PAGE_SHIFT;
+		lock_limit = current->rlim[RLIMIT_MEMLOCK].rlim_cur;
 		locked += len;
-		if (locked > current->rlim[RLIMIT_MEMLOCK].rlim_cur)
+		if (locked > lock_limit && !capable(CAP_IPC_LOCK))
 			return -EAGAIN;
 	}
 
diff -urNp linux-1040/mm/mprotect.c linux-1050/mm/mprotect.c
--- linux-1040/mm/mprotect.c
+++ linux-1050/mm/mprotect.c
@@ -313,7 +313,7 @@ asmlinkage long sys_mprotect(unsigned lo
 	len = PAGE_ALIGN(len);
 	end = start + len;
 	if (end < start)
-		return -EINVAL;
+		return -ENOMEM;
 	if (prot & ~(PROT_READ | PROT_WRITE | PROT_EXEC))
 		return -EINVAL;
 	if (end == start)
diff -urNp linux-1040/mm/mremap.c linux-1050/mm/mremap.c
--- linux-1040/mm/mremap.c
+++ linux-1050/mm/mremap.c
@@ -345,10 +345,12 @@ unsigned long do_mremap(unsigned long ad
 			goto out;
 	}
 	if (vma->vm_flags & VM_LOCKED) {
-		unsigned long locked = current->mm->locked_vm << PAGE_SHIFT;
+		unsigned long locked, lock_limit;
+		locked = current->mm->locked_vm << PAGE_SHIFT;
+		lock_limit = current->rlim[RLIMIT_MEMLOCK].rlim_cur;
 		locked += new_len - old_len;
 		ret = -EAGAIN;
-		if (locked > current->rlim[RLIMIT_MEMLOCK].rlim_cur)
+		if (locked > lock_limit && !capable(CAP_IPC_LOCK))
 			goto out;
 	}
 	ret = -ENOMEM;
diff -urNp linux-1040/mm/shmem.c linux-1050/mm/shmem.c
--- linux-1040/mm/shmem.c
+++ linux-1050/mm/shmem.c
@@ -711,14 +711,44 @@ struct page * shmem_nopage(struct vm_are
 	return(page);
 }
 
-void shmem_lock(struct file * file, int lock)
+int shmem_lock(struct file *file, int lock,
+		struct mm_struct **locker_mm_p, pid_t *locker_pid_p)
 {
 	struct inode * inode = file->f_dentry->d_inode;
 	struct shmem_inode_info * info = SHMEM_I(inode);
+	struct mm_struct *mm = current->mm;
+	unsigned long lock_limit, locked;
+	int retval = -ENOMEM;
 
 	spin_lock(&info->lock);
+	if (lock && !info->locked) {
+		locked = inode->i_size >> PAGE_SHIFT;
+		locked += mm->locked_vm;
+		lock_limit = current->rlim[RLIMIT_MEMLOCK].rlim_cur;
+		lock_limit >>= PAGE_SHIFT;
+		if (locked > num_physpages/10*9)
+			goto out_nomem;
+		if (locked > lock_limit && !capable(CAP_IPC_LOCK))
+			goto out_nomem;
+		mm->locked_vm = locked;
+		*locker_mm_p = mm;
+		*locker_pid_p = current->tgid;
+	}
+	if (!lock && info->locked && mm) {
+		locked = inode->i_size >> PAGE_SHIFT;
+		if (mm == *locker_mm_p &&
+		    current->tgid == *locker_pid_p &&
+		    locked <= mm->locked_vm) {
+			mm->locked_vm -= locked;
+			*locker_mm_p = NULL;
+			*locker_pid_p = 0;
+		}
+	}
 	info->locked = lock;
+	retval = 0;
+out_nomem:
 	spin_unlock(&info->lock);
+	return retval;
 }
 
 static int shmem_mmap(struct file * file, struct vm_area_struct * vma)
