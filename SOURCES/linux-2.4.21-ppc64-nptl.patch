diff -urNp linux-342/arch/ppc64/kernel/entry.S linux-343/arch/ppc64/kernel/entry.S
--- linux-342/arch/ppc64/kernel/entry.S
+++ linux-343/arch/ppc64/kernel/entry.S
@@ -102,6 +102,8 @@ _GLOBAL(DoSyscall)
 	clrldi	r4,r4,32
 	clrldi	r5,r5,32
 	clrldi	r6,r6,32
+	clrldi	r7,r7,32
+	clrldi	r8,r8,32
 	b	17f
 15:
 #endif
diff -urNp linux-342/arch/ppc64/kernel/head.S linux-343/arch/ppc64/kernel/head.S
--- linux-342/arch/ppc64/kernel/head.S
+++ linux-343/arch/ppc64/kernel/head.S
@@ -99,7 +99,7 @@ __zero:
 	 * between physical addresses and absolute addresses) and
 	 * to the pidhash table (also used by the debugger) */
 	.llong msChunks-KERNELBASE
-	.llong pidhash-KERNELBASE
+	.llong 0
 
 	/* Offset 0x38 - Pointer to start of embedded System.map */
 	.globl	embedded_sysmap_start
diff -urNp linux-342/arch/ppc64/kernel/misc.S linux-343/arch/ppc64/kernel/misc.S
--- linux-342/arch/ppc64/kernel/misc.S
+++ linux-343/arch/ppc64/kernel/misc.S
@@ -572,26 +572,31 @@ _GLOBAL(call_setup_cpu)
  *   arch_kernel_thread(fn, arg, flags)
  */
 _GLOBAL(arch_kernel_thread)
-	mr	r6,r3		/* function */
-	ori	r3,r5,CLONE_VM	/* flags */
-	li	r0,__NR_clone
-	sc
-	cmpi	0,r3,0		/* parent or child? */
-	bnelr			/* return if parent */
-
-	li	r0,0		/* clear out p->thread.regs */
-	std	r0,THREAD+PT_REGS(r13)	/* since we don't have user ctx */
-	li	r0,RUN_FLAG		/* Run light on */
-	std	r0,THREAD+THREAD_FLAGS(r13)
-
-	ld	r2,8(r6)
-	ld	r6,0(r6)
-	mtlr	r6              /* fn addr in lr */
-	mr	r3,r4	        /* load arg and call fn */
-	blrl
-	li	r0,__NR_exit	/* exit after child exits */
-        li	r3,0
-	sc
+        std     r29,-24(r1)
+        std     r30,-16(r1)
+        stdu    r1,-STACK_FRAME_OVERHEAD(r1)
+        mr      r29,r3
+        mr      r30,r4
+        ori     r3,r5,CLONE_VM  /* flags */
+        li      r4,0            /* new sp (unused) */
+        li      r0,__NR_clone
+        sc      
+        cmpi    0,r3,0          /* parent or child? */
+        bne     1f              /* return if parent */
+        li      r0,0
+        stdu    r0,-STACK_FRAME_OVERHEAD(r1)
+        ld      r2,8(r29)
+        ld      r29,0(r29)
+        mtlr    r29              /* fn addr in lr */
+        mr      r3,r30          /* load arg and call fn */
+        blrl
+        li      r0,__NR_exit    /* exit after child exits */
+        li      r3,0
+        sc
+1:      addi    r1,r1,STACK_FRAME_OVERHEAD
+        ld      r29,-24(r1)
+        ld      r30,-16(r1)
+        blr
 
 #ifdef CONFIG_BINFMT_ELF32
 /* Why isn't this a) automatic, b) written in 'C'? */	
diff -urNp linux-342/arch/ppc64/kernel/process.c linux-343/arch/ppc64/kernel/process.c
--- linux-342/arch/ppc64/kernel/process.c
+++ linux-343/arch/ppc64/kernel/process.c
@@ -49,7 +49,8 @@ int dump_fpu(struct pt_regs *regs, elf_f
 struct task_struct *last_task_used_math = NULL;
 static struct fs_struct init_fs = INIT_FS;
 static struct files_struct init_files = INIT_FILES;
-static struct signal_struct init_signals = INIT_SIGNALS;
+static struct signal_struct init_signals = INIT_SIGNALS(init_signals);
+static struct sighand_struct init_sighand = INIT_SIGHAND(init_sighand);
 struct mm_struct init_mm = INIT_MM(init_mm);
 
 struct mm_struct ioremap_mm = { pgd             : ioremap_dir  
@@ -93,12 +94,11 @@ dump_fpu(struct pt_regs *regs, elf_fpreg
 	return 1;
 }
 
-void
-_switch_to(struct task_struct *prev, struct task_struct *new,
-	  struct task_struct **last)
+struct task_struct *__switch_to(struct task_struct *prev, struct task_struct *new)
 {
 	struct thread_struct *new_thread, *old_thread;
 	unsigned long s;
+	struct task_struct *last;
 	
 	__save_flags(s);
 	__cli();
@@ -127,8 +127,9 @@ _switch_to(struct task_struct *prev, str
 #endif /* CONFIG_SMP */
 	new_thread = &new->thread;
 	old_thread = &current->thread;
-	*last = _switch(old_thread, new_thread);
+	last = _switch(old_thread, new_thread);
 	__restore_flags(s);
+	return last;
 }
 
 void show_regs(struct pt_regs * regs)
@@ -200,6 +201,8 @@ copy_thread(int nr, unsigned long clone_
 	struct pt_regs * childregs, *kregs;
 	extern void ret_from_fork(void);
 
+	p->set_child_tid = p->clear_child_tid = NULL;
+
 	/* Copy registers */
 	childregs = ((struct pt_regs *)
 		     ((unsigned long)p + sizeof(union task_union)
@@ -221,7 +224,7 @@ copy_thread(int nr, unsigned long clone_
 	kregs->gpr[1] = (unsigned long)childregs - STACK_FRAME_OVERHEAD;
 	kregs->gpr[2] = (((unsigned long)&__toc_start) + 0x8000);
 	
-	if (usp >= (unsigned long) regs) {
+	if ((childregs->msr & MSR_PR) == 0) {
 		/* Stack is in kernel space - must adjust */
 		childregs->gpr[1] = (unsigned long)(childregs + 1);
 		*((unsigned long *) childregs->gpr[1]) = 0;
@@ -229,9 +232,25 @@ copy_thread(int nr, unsigned long clone_
 	} else {
 		/* Provided stack is in user space */
 		childregs->gpr[1] = usp;
+		if (clone_flags & CLONE_SETTLS) {
+			if (current->thread.flags & PPC_FLAG_32BIT)
+				childregs->gpr[2] = childregs->gpr[6];
+			else
+				childregs->gpr[13] = childregs->gpr[6];
+		}
 	}
 	p->thread.last_syscall = -1;
 	  
+	if ((childregs->msr & MSR_PR) == 0) {
+		/* no user register state for kernel thread */
+		p->thread.regs = NULL;
+		/* 
+		 * Turn off the 32bit flag, make sure the iSeries
+		 * run light flag is on (no effect on pSeries).
+		 * Those are the only two flags.
+		 */
+		p->thread.flags = PPC_FLAG_RUN_LIGHT;
+	}
 	/*
 	 * copy fpu info - assume lazy fpu switch now always
 	 *  -- Cort
@@ -306,22 +325,43 @@ int get_fpexc_mode(struct task_struct *t
 	return put_user(val, (unsigned int *) adr);
 }
 
-int sys_clone(int p1, int p2, int p3, int p4, int p5, int p6,
-	      struct pt_regs *regs)
-{
-	return do_fork(p1, regs->gpr[1], regs, 0);
+int sys_clone(unsigned long clone_flags, unsigned long p2, unsigned long p3,
+              unsigned long p4, unsigned long p5, unsigned long p6,
+              struct pt_regs *regs)
+{
+        unsigned long parent_tidptr = 0;
+        unsigned long child_tidptr = 0;
+
+        if (p2 == 0)
+                p2 = regs->gpr[1];      /* stack pointer for child */
+
+        if (clone_flags & (CLONE_PARENT_SETTID | CLONE_CHILD_SETTID |
+                           CLONE_CHILD_CLEARTID)) {
+                parent_tidptr = p3;
+                child_tidptr = p5;
+		if (current->thread.flags & PPC_FLAG_32BIT) {
+                        parent_tidptr &= 0xffffffff;
+                        child_tidptr &= 0xffffffff;
+                }
+        }
+
+        if (regs->msr & MSR_FP)
+                giveup_fpu(current);
+
+        return do_fork(clone_flags & ~CLONE_IDLETASK, p2, regs, 0,
+                    (int *)parent_tidptr, (int *)child_tidptr);
 }
 
 int sys_fork(int p1, int p2, int p3, int p4, int p5, int p6,
 	     struct pt_regs *regs)
 {
-	return do_fork(SIGCHLD, regs->gpr[1], regs, 0);
+	return do_fork(SIGCHLD, regs->gpr[1], regs, 0, NULL, NULL);
 }
 
 int sys_vfork(int p1, int p2, int p3, int p4, int p5, int p6,
 			 struct pt_regs *regs)
 {
-	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs->gpr[1], regs, 0);
+	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs->gpr[1], regs, 0, NULL, NULL);
 }
 
 int sys_execve(unsigned long a0, unsigned long a1, unsigned long a2,
diff -urNp linux-342/arch/ppc64/kernel/signal.c linux-343/arch/ppc64/kernel/signal.c
--- linux-342/arch/ppc64/kernel/signal.c
+++ linux-343/arch/ppc64/kernel/signal.c
@@ -128,17 +128,17 @@ sys_sigsuspend(old_sigset_t mask, int p2
 	sigset_t saveset;
 
 	mask &= _BLOCKABLE;
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	saveset = current->blocked;
 	siginitset(&current->blocked, mask);
-	recalc_sigpending(current);
-	spin_unlock_irq(&current->sigmask_lock);
+	recalc_sigpending();
+	__set_current_state(TASK_INTERRUPTIBLE);
+	spin_unlock_irq(&current->sighand->siglock);
 
 	regs->result = -EINTR;
 	regs->gpr[3] = EINTR;
 	regs->ccr |= 0x10000000;
 	while (1) {
-		current->state = TASK_INTERRUPTIBLE;
 		schedule();
 		if (do_signal(&saveset, regs))
 			/*
@@ -150,6 +150,7 @@ sys_sigsuspend(old_sigset_t mask, int p2
 			 * R3, so it's still set to -EINTR (see above).
 			 */
 			return regs->gpr[3];
+		set_current_state(TASK_INTERRUPTIBLE);
 	}
 }
 
@@ -167,20 +168,21 @@ sys_rt_sigsuspend(sigset_t *unewset, siz
 		return -EFAULT;
 	sigdelsetmask(&newset, ~_BLOCKABLE);
 
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	saveset = current->blocked;
 	current->blocked = newset;
-	recalc_sigpending(current);
-	spin_unlock_irq(&current->sigmask_lock);
+	recalc_sigpending();
+	__set_current_state(TASK_INTERRUPTIBLE);
+	spin_unlock_irq(&current->sighand->siglock);
 
 	regs->result = -EINTR;
 	regs->gpr[3] = EINTR;
 	regs->ccr |= 0x10000000;
 	while (1) {
-		current->state = TASK_INTERRUPTIBLE;
 		schedule();
 		if (do_signal(&saveset, regs))
 			return regs->gpr[3];
+		set_current_state(TASK_INTERRUPTIBLE);
 	}
 }
 
@@ -339,10 +341,10 @@ sys_rt_sigreturn(unsigned long r3, unsig
 		goto badframe;
 
 	sigdelsetmask(&set, ~_BLOCKABLE);
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	current->blocked = set;
-	recalc_sigpending(current);
-	spin_unlock_irq(&current->sigmask_lock);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
 
 	if (restore_sigcontext(regs, NULL, &uc->uc_mcontext))
 		goto badframe;
@@ -449,10 +451,10 @@ sys_sigreturn(unsigned long r3, unsigned
 		goto badframe;
 
 	sigdelsetmask(&set, ~_BLOCKABLE);
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	current->blocked = set;
-	recalc_sigpending(current);
-	spin_unlock_irq(&current->sigmask_lock);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
 
 	return regs->result;
 
@@ -518,9 +520,10 @@ badframe:
  * OK, we're invoking a handler
  */
 static void
-handle_signal(unsigned long sig, struct k_sigaction *ka,
-	      siginfo_t *info, sigset_t *oldset, struct pt_regs *regs)
+handle_signal(unsigned long sig, siginfo_t *info, sigset_t *oldset, struct pt_regs *regs)
 {
+	struct k_sigaction *ka = &current->sighand->action[sig-1];
+  
 	/* Set up Signal Frame */
 	if (ka->sa.sa_flags & SA_SIGINFO)
 		setup_rt_frame(sig, ka, info, oldset, regs);
@@ -531,11 +534,11 @@ handle_signal(unsigned long sig, struct 
 		ka->sa.sa_handler = SIG_DFL;
 
 	if (!(ka->sa.sa_flags & SA_NODEFER)) {
-		spin_lock_irq(&current->sigmask_lock);
+		spin_lock_irq(&current->sighand->siglock);
 		sigorsets(&current->blocked,&current->blocked,&ka->sa.sa_mask);
 		sigaddset(&current->blocked,sig);
-		recalc_sigpending(current);
-		spin_unlock_irq(&current->sigmask_lock);
+		recalc_sigpending();
+		spin_unlock_irq(&current->sighand->siglock);
 	}
 }
 
@@ -568,108 +571,6 @@ syscall_restart(struct pt_regs *regs, st
 	}
 }
 
-static int
-get_signal_to_deliver(siginfo_t *info, struct pt_regs *regs)
-{
-	for (;;) {
-		unsigned long signr;
-		struct k_sigaction *ka;
-
-		spin_lock_irq(&current->sigmask_lock);
-		signr = dequeue_signal(&current->blocked, info);
-		spin_unlock_irq(&current->sigmask_lock);
-
-		if (!signr)
-			break;
-
-		if ((current->ptrace & PT_PTRACED) && signr != SIGKILL) {
-			/* Let the debugger run.  */
-			current->exit_code = signr;
-			current->state = TASK_STOPPED;
-			notify_parent(current, SIGCHLD);
-			schedule();
-
-			/* We're back.  Did the debugger cancel the sig?  */
-			signr = current->exit_code;
-			if (signr == 0)
-				continue;
-			current->exit_code = 0;
-
-			/* The debugger continued.  Ignore SIGSTOP.  */
-			if (signr == SIGSTOP)
-				continue;
-
-			/* Update the siginfo structure.  Is this good?  */
-			if (signr != info->si_signo) {
-				info->si_signo = signr;
-				info->si_errno = 0;
-				info->si_code = SI_USER;
-				info->si_pid = current->p_pptr->pid;
-				info->si_uid = current->p_pptr->uid;
-			}
-
-			/* If the (new) signal is now blocked, requeue it.  */
-			if (sigismember(&current->blocked, signr)) {
-				send_sig_info(signr, info, current);
-				continue;
-			}
-		}
-
-		ka = &current->sig->action[signr-1];
-
-		if (ka->sa.sa_handler == SIG_IGN) {
-			if (signr != SIGCHLD)
-				continue;
-			/* Check for SIGCHLD: it's special.  */
-			while (sys_wait4(-1, NULL, WNOHANG, NULL) > 0)
-				/* nothing */;
-			continue;
-		}
-
-		if (ka->sa.sa_handler == SIG_DFL) {
-			int exit_code = signr;
-
-			/* Init gets no signals it doesn't want.  */
-			if (current->pid == 1)
-				continue;
-
-			switch (signr) {
-			case SIGCONT: case SIGCHLD: case SIGWINCH: case SIGURG:
-				continue;
-
-			case SIGTSTP: case SIGTTIN: case SIGTTOU:
-				if (is_orphaned_pgrp(current->pgrp))
-					continue;
-				/* FALLTHRU */
-
-			case SIGSTOP: {
-				struct signal_struct *sig;
-				current->state = TASK_STOPPED;
-				current->exit_code = signr;
-				sig = current->p_pptr->sig;
-				if (sig && !(sig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))
-					notify_parent(current, SIGCHLD);
-				schedule();
-				continue;
-			}
-
-			case SIGQUIT: case SIGILL: case SIGTRAP:
-			case SIGABRT: case SIGFPE: case SIGSEGV:
-			case SIGBUS: case SIGSYS: case SIGXCPU: case SIGXFSZ:
-				if (do_coredump(signr, regs))
-					exit_code |= 0x80;
-				/* FALLTHRU */
-
-			default:
-				sig_exit(signr, exit_code, info);
-				/* NOTREACHED */
-			}
-		}
-		return signr;
-	}
-	return 0;
-}
-
 /*
  * Note that 'init' is a special process: it doesn't get signals it doesn't
  * want to handle. Thus you cannot kill init even with a SIGKILL even by
@@ -677,6 +578,8 @@ get_signal_to_deliver(siginfo_t *info, s
  */
 extern int do_signal32(sigset_t *oldset, struct pt_regs *regs);
 
+int print_fatal_signals;
+
 int
 do_signal(sigset_t *oldset, struct pt_regs *regs)
 {
@@ -695,12 +598,12 @@ do_signal(sigset_t *oldset, struct pt_re
 
 	signr = get_signal_to_deliver(&info, regs);
 	if (signr > 0) {
-		struct k_sigaction *ka = &current->sig->action[signr-1];
+		struct k_sigaction *ka = &current->sighand->action[signr-1];
 
 		/* Whee!  Actually deliver the signal.  */
 		if (regs->trap == 0x0C00)
 			syscall_restart(regs, ka);
-		handle_signal(signr, ka, &info, oldset, regs);
+		handle_signal(signr, &info, oldset, regs);
 		return 1;
 	}
 
diff -urNp linux-342/arch/ppc64/kernel/signal32.c linux-343/arch/ppc64/kernel/signal32.c
--- linux-342/arch/ppc64/kernel/signal32.c
+++ linux-343/arch/ppc64/kernel/signal32.c
@@ -274,10 +274,10 @@ long sys32_sigreturn(unsigned long r3, u
 	 */
 	set.sig[0] = sigctx.oldmask + ((long)(sigctx._unused[3])<< 32);
 	sigdelsetmask(&set, ~_BLOCKABLE);
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	current->blocked = set;
-	recalc_sigpending(current);
-	spin_unlock_irq(&current->sigmask_lock);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
 
 	sc++;			/* Look at next sigcontext */
 	/* If the next sigcontext is actually the sigregs (frame)  */
@@ -509,10 +509,10 @@ long sys32_rt_sigreturn(unsigned long r3
 	 */
 	sigdelsetmask(&signal_set, ~_BLOCKABLE); 
 	/* update the current based on the sigmask found in the rt_stackframe */
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	current->blocked = signal_set;
-	recalc_sigpending(current);
-	spin_unlock_irq(&current->sigmask_lock);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
 
 	/* Set to point to the next rt_sigframe - this is used to determine whether this 
 	 *   is the last signal to process
@@ -761,7 +761,7 @@ siginfo64to32(siginfo_t32 *d, siginfo_t 
 	memset (d, 0, sizeof(siginfo_t32));
 	d->si_signo = s->si_signo;
 	d->si_errno = s->si_errno;
-	d->si_code = s->si_code & 0xffff;
+	d->si_code = (short) s->si_code;
 	if (s->si_signo >= SIGRTMIN) {
 		d->si_pid = s->si_pid;
 		d->si_uid = s->si_uid;
@@ -933,17 +933,17 @@ int sys32_rt_sigsuspend(sigset32_t* unew
 
 	sigdelsetmask(&newset, ~_BLOCKABLE);
 
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	saveset = current->blocked;
 	current->blocked = newset;
-	recalc_sigpending(current);
-	spin_unlock_irq(&current->sigmask_lock);
+	recalc_sigpending();
+	__set_current_state(TASK_INTERRUPTIBLE);
+	spin_unlock_irq(&current->sighand->siglock);
 
 	regs->result = -EINTR;
 	regs->gpr[3] = EINTR;
 	regs->ccr |= 0x10000000;
 	while (1) {
-		current->state = TASK_INTERRUPTIBLE;
 		schedule();
 		if (do_signal(&saveset, regs))
 			/*
@@ -955,6 +955,7 @@ int sys32_rt_sigsuspend(sigset32_t* unew
 			 * R3, so it's still set to -EINTR (see above).
 			 */
 			return regs->gpr[3];
+		set_current_state(TASK_INTERRUPTIBLE);
 	}
 }
 
@@ -1048,10 +1049,10 @@ setup_rt_frame32(struct pt_regs *regs, s
  * OK, we're invoking a handler
  */
 static void
-handle_signal32(unsigned long sig, struct k_sigaction *ka,
-	      siginfo_t *info, sigset_t *oldset, struct pt_regs * regs,
-	      unsigned int *newspp, unsigned int frame)
+handle_signal32(unsigned long sig, siginfo_t *info, sigset_t *oldset,
+		struct pt_regs * regs, unsigned int *newspp, unsigned int frame)
 {
+	struct k_sigaction *ka = &current->sighand->action[sig-1];
 	struct sigcontext32 *sc;
 	struct rt_sigframe_32 *rt_stack_frame;
 	siginfo_t32 siginfo32bit;
@@ -1115,11 +1116,11 @@ handle_signal32(unsigned long sig, struc
 		ka->sa.sa_handler = SIG_DFL;
 
 	if (!(ka->sa.sa_flags & SA_NODEFER)) {
-		spin_lock_irq(&current->sigmask_lock);
+		spin_lock_irq(&current->sighand->siglock);
 		sigorsets(&current->blocked,&current->blocked,&ka->sa.sa_mask);
 		sigaddset(&current->blocked,sig);
-		recalc_sigpending(current);
-		spin_unlock_irq(&current->sigmask_lock);
+		recalc_sigpending();
+		spin_unlock_irq(&current->sighand->siglock);
 	}
 	
 	return;
@@ -1191,148 +1192,50 @@ asmlinkage int sys32_sigaltstack(u32 new
  * want to handle. Thus you cannot kill init even with a SIGKILL even by
  * mistake.
  */
-
 int do_signal32(sigset_t *oldset, struct pt_regs *regs)
 {
 	siginfo_t info;
 	struct k_sigaction *ka;
 	unsigned int frame, newsp;
+	int signr;
 
 	if (!oldset)
 		oldset = &current->blocked;
 
 	newsp = frame = 0;
 
-	for (;;) {
-		unsigned long signr;
-		
-		spin_lock_irq(&current->sigmask_lock);
-		signr = dequeue_signal(&current->blocked, &info);
-		spin_unlock_irq(&current->sigmask_lock);
-		ifppcdebug(PPCDBG_SYS32) {
-			if (signr)
-				udbg_printf("do_signal32 - processing signal=%2lx - pid=%ld, comm=%s \n", signr, current->pid, current->comm);
-		}
-
-		if (!signr)
-			break;
-
-		if ((current->ptrace & PT_PTRACED) && signr != SIGKILL) {
-			/* Let the debugger run.  */
-			current->exit_code = signr;
-			current->state = TASK_STOPPED;
-			notify_parent(current, SIGCHLD);
-			schedule();
-
-			/* We're back.  Did the debugger cancel the sig?  */
-			if (!(signr = current->exit_code))
-				continue;
-			current->exit_code = 0;
-
-			/* The debugger continued.  Ignore SIGSTOP.  */
-			if (signr == SIGSTOP)
-				continue;
-
-			/* Update the siginfo structure.  Is this good?  */
-			if (signr != info.si_signo) {
-				info.si_signo = signr;
-				info.si_errno = 0;
-				info.si_code = SI_USER;
-				info.si_pid = current->p_pptr->pid;
-				info.si_uid = current->p_pptr->uid;
-			}
-
-			/* If the (new) signal is now blocked, requeue it.  */
-			if (sigismember(&current->blocked, signr)) {
-				send_sig_info(signr, &info, current);
-				continue;
-			}
-		}
-
-		ka = &current->sig->action[signr-1];
-
-		if (ka->sa.sa_handler == SIG_IGN) {
-			if (signr != SIGCHLD)
-				continue;
-			/* Check for SIGCHLD: it's special.  */
-			while (sys_wait4(-1, NULL, WNOHANG, NULL) > 0)
-				/* nothing */;
-			continue;
-		}
-
-		if (ka->sa.sa_handler == SIG_DFL) {
-			int exit_code = signr;
-
-			/* Init gets no signals it doesn't want.  */
-			if (current->pid == 1)
-				continue;
-
-			switch (signr) {
-			case SIGCONT: case SIGCHLD: case SIGWINCH: case SIGURG:
-				continue;
-
-			case SIGTSTP: case SIGTTIN: case SIGTTOU:
-				if (is_orphaned_pgrp(current->pgrp))
-					continue;
-				/* FALLTHRU */
-
-			case SIGSTOP:
-				current->state = TASK_STOPPED;
-				current->exit_code = signr;
-				if (!(current->p_pptr->sig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))
-					notify_parent(current, SIGCHLD);
-				schedule();
-				continue;
-
-			case SIGQUIT: case SIGILL: case SIGTRAP:
-			case SIGABRT: case SIGFPE: case SIGSEGV:
-			case SIGBUS: case SIGSYS: case SIGXCPU: case SIGXFSZ:
-				if (do_coredump(signr, regs))
-					exit_code |= 0x80;
-				/* FALLTHRU */
-
-			default:
-				sig_exit(signr, exit_code, &info);
-				/* NOTREACHED */
-			}
-		}
-
-		PPCDBG(PPCDBG_SIGNAL, " do signal :sigaction flags = %lx \n" ,ka->sa.sa_flags);
-		PPCDBG(PPCDBG_SIGNAL, " do signal :on sig stack  = %lx \n" ,on_sig_stack(regs->gpr[1]));
-		PPCDBG(PPCDBG_SIGNAL, " do signal :reg1  = %lx \n" ,regs->gpr[1]);
-		PPCDBG(PPCDBG_SIGNAL, " do signal :alt stack  = %lx \n" ,current->sas_ss_sp);
-		PPCDBG(PPCDBG_SIGNAL, " do signal :alt stack size  = %lx \n" ,current->sas_ss_size);
-
-
-
-		if ( (ka->sa.sa_flags & SA_ONSTACK)
-		     && (! on_sig_stack(regs->gpr[1])))
+	signr = get_signal_to_deliver(&info, regs);
+	if (signr > 0) {
+		ka = &current->sighand->action[signr-1];
+		if ((ka->sa.sa_flags & SA_ONSTACK)
+		     && (!on_sig_stack(regs->gpr[1])))
 			newsp = (current->sas_ss_sp + current->sas_ss_size);
 		else
 			newsp = regs->gpr[1];
 		newsp = frame = newsp - sizeof(struct sigregs32);
 
 		/* Whee!  Actually deliver the signal.  */
-		handle_signal32(signr, ka, &info, oldset, regs, &newsp, frame);
-		break;
+		handle_signal32(signr, &info, oldset, regs, &newsp, frame);
 	}
 
-	if (regs->trap == 0x0C00 /* System Call! */ &&
-	    ((int)regs->result == -ERESTARTNOHAND ||
-	     (int)regs->result == -ERESTARTSYS ||
-	     (int)regs->result == -ERESTARTNOINTR)) {
-		regs->gpr[3] = regs->orig_gpr3;
-		regs->nip -= 4;		/* Back up & retry system call */
-		regs->result = 0;
+	if (regs->trap == 0x0C00) {	/* System Call! */
+		if ((int)regs->result == -ERESTARTNOHAND ||
+		    (int)regs->result == -ERESTARTSYS ||
+		    (int)regs->result == -ERESTARTNOINTR) {
+			regs->gpr[3] = regs->orig_gpr3;
+			regs->nip -= 4; /* Back up & retry system call */
+			regs->result = 0;
+		}
 	}
 
 	if (newsp == frame)
 		return 0;		/* no signals delivered */
 
 	/* Invoke correct stack setup routine */
-	if (ka->sa.sa_flags & SA_SIGINFO) 
+	if (ka->sa.sa_flags & SA_SIGINFO)
 		setup_rt_frame32(regs, (struct sigregs32*)(u64)frame, newsp);
 	else
 		setup_frame32(regs, (struct sigregs32*)(u64)frame, newsp);
 	return 1;
 }
+
diff -urNp linux-342/arch/ppc64/kernel/smp.c linux-343/arch/ppc64/kernel/smp.c
--- linux-342/arch/ppc64/kernel/smp.c
+++ linux-343/arch/ppc64/kernel/smp.c
@@ -675,14 +675,15 @@ void __init smp_boot_cpus(void)
 
 		memset(&regs, 0, sizeof(struct pt_regs));
 
-		if (do_fork(CLONE_VM|CLONE_PID, 0, &regs, 0) < 0)
-			panic("failed fork for CPU %d", i);
-		p = init_task.prev_task;
-		if (!p)
-			panic("No idle task for CPU %d", i);
+ 		p = copy_process(CLONE_VM|CLONE_IDLETASK, 0, &regs, 0, 
+				 NULL, NULL);
+ 		if (IS_ERR(p))
+ 			panic("failed fork for CPU %u: %li", i, PTR_ERR(p));
 
 		PPCDBG(PPCDBG_SMP,"\tProcessor %d, task = 0x%lx\n", i, p);
 
+		wake_up_forked_process(p);
+
 		init_idle(p, i);
 
 		unhash_process(p);
diff -urNp linux-342/arch/ppc64/kernel/syscalls.c linux-343/arch/ppc64/kernel/syscalls.c
--- linux-342/arch/ppc64/kernel/syscalls.c
+++ linux-343/arch/ppc64/kernel/syscalls.c
@@ -208,6 +208,7 @@ out:
 	return ret;
 }
 
+#if 0
 asmlinkage int sys_pause(void)
 {
 	
@@ -218,6 +219,7 @@ asmlinkage int sys_pause(void)
 	PPCDBG(PPCDBG_SYS64X, "sys_pause - exited - pid=%ld current=%lx comm=%s \n", current->pid, current, current->comm);
 	return -ERESTARTNOHAND;
 }
+#endif
 
 static int __init set_fakeppc(char *str)
 {
diff -urNp linux-342/drivers/char/hvc_console.c linux-343/drivers/char/hvc_console.c
--- linux-342/drivers/char/hvc_console.c
+++ linux-343/drivers/char/hvc_console.c
@@ -283,7 +283,7 @@ int __init hvc_init(void)
 		panic("Couldn't register hvc console driver\n");
 
 	if (hvc_driver.num > 0)
-		kernel_thread(khvcd, NULL, CLONE_FS | CLONE_FILES | CLONE_SIGNAL);
+		kernel_thread(khvcd, NULL, CLONE_KERNEL);
 
 	return 0;
 }
diff -urNp linux-342/include/asm-ppc64/elf.h linux-343/include/asm-ppc64/elf.h
--- linux-342/include/asm-ppc64/elf.h
+++ linux-343/include/asm-ppc64/elf.h
@@ -61,9 +61,9 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 #define ELF_ET_DYN_BASE         (0x08000000)
 
 /* Common routine for both 32-bit and 64-bit processes */
-#define ELF_CORE_COPY_REGS(gregs, regs) elf_core_copy_regs(gregs, regs);
+#define ELF_CORE_COPY_REGS(gregs, regs) ppc64_elf_core_copy_regs(gregs, regs);
 static inline void
-elf_core_copy_regs(elf_gregset_t dstRegs, struct pt_regs* srcRegs)
+ppc64_elf_core_copy_regs(elf_gregset_t dstRegs, struct pt_regs* srcRegs)
 {
 	int i;
 
diff -urNp linux-342/include/asm-ppc64/hw_irq.h linux-343/include/asm-ppc64/hw_irq.h
--- linux-342/include/asm-ppc64/hw_irq.h
+++ linux-343/include/asm-ppc64/hw_irq.h
@@ -33,8 +33,12 @@ extern void __no_lpq_restore_flags(unsig
 #define __save_and_cli(flags)	({__save_flags(flags);__cli();})
 #define __save_and_sti(flags)	({__save_flags(flags);__sti();})
 
+#define local_save_flags(flags)	((flags) = __no_use_save_flags())
 #else
 
+#define local_save_flags(flags) ((flags) = mfmsr())
+
+
 #define __save_flags(flags)	((flags) = mfmsr())
 #define __restore_flags(flags) do { \
 	__asm__ __volatile__("": : :"memory"); \
diff -urNp linux-342/include/asm-ppc64/processor.h linux-343/include/asm-ppc64/processor.h
--- linux-342/include/asm-ppc64/processor.h
+++ linux-343/include/asm-ppc64/processor.h
@@ -635,8 +635,8 @@ extern struct task_struct *last_task_use
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
  */
-#define TASK_UNMAPPED_BASE_USER32 (STACK_TOP_USER32 / 4)
-#define TASK_UNMAPPED_BASE_USER64 (STACK_TOP_USER64 / 4)
+#define TASK_UNMAPPED_BASE_USER32 PAGE_ALIGN(STACK_TOP_USER32 / 4)
+#define TASK_UNMAPPED_BASE_USER64 PAGE_ALIGN(STACK_TOP_USER64 / 4)
 
 #define TASK_UNMAPPED_BASE (((current->thread.flags & PPC_FLAG_32BIT)||(ppcdebugset(PPCDBG_BINFMT_32ADDR))) ? \
 		TASK_UNMAPPED_BASE_USER32 : TASK_UNMAPPED_BASE_USER64 )
@@ -731,8 +731,10 @@ static inline unsigned long __pack_fe01(
 #define THREAD_SIZE (4*PAGE_SIZE)
 struct task_struct * alloc_task_struct(void);
         
+#define __alloc_task_struct alloc_task_struct
+
 void free_task_struct(struct task_struct *);
-#define get_task_struct(tsk)	atomic_inc(&virt_to_page(tsk)->count)
+#define __free_task_struct free_task_struct   
 
 #define init_task	(init_task_union.task)
 #define init_stack	(init_task_union.stack)
diff -urNp linux-342/include/asm-ppc64/spinlock.h linux-343/include/asm-ppc64/spinlock.h
--- linux-342/include/asm-ppc64/spinlock.h
+++ linux-343/include/asm-ppc64/spinlock.h
@@ -211,5 +211,8 @@ static __inline__ int is_write_locked(rw
 
 #define rwlock_init(x)         do { *(x) = RW_LOCK_UNLOCKED; } while(0)
 
+#define rwlock_is_locked(x)     ((x)->lock)
+
+
 #endif /* __KERNEL__ */
 #endif /* __ASM_SPINLOCK_H */
diff -urNp linux-342/include/asm-ppc64/system.h linux-343/include/asm-ppc64/system.h
--- linux-342/include/asm-ppc64/system.h
+++ linux-343/include/asm-ppc64/system.h
@@ -72,9 +72,10 @@ struct device_node;
 
 struct task_struct;
 #define prepare_to_switch()	do { } while(0)
-#define switch_to(prev,next,last) _switch_to((prev),(next),&(last))
-extern void _switch_to(struct task_struct *, struct task_struct *,
-		       struct task_struct **);
+
+extern struct task_struct *__switch_to(struct task_struct *, struct task_struct *);
+
+#define switch_to(prev, next, last)     ((last) = __switch_to((prev), (next)))
 
 struct thread_struct;
 extern struct task_struct *_switch(struct thread_struct *prev,
@@ -114,6 +115,14 @@ extern void __global_restore_flags(unsig
 #define local_irq_set(flags)		__save_and_sti(flags)
 #define local_irq_restore(flags)	__restore_flags(flags)
 
+#define irqs_disabled()                         \
+({                                              \
+        unsigned long flags;                    \
+        local_save_flags(flags);                \
+        !(flags & MSR_EE);                      \
+})
+
+
 static __inline__ int __is_processor(unsigned long pv)
 {
       unsigned long pvr;
