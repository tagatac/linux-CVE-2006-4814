--- linux-2.4.21/fs/jbd/journal.c.diff	2003-07-09 05:55:37.000000000 -0400
+++ linux-2.4.21/fs/jbd/journal.c	2003-07-09 11:58:18.000000000 -0400
@@ -48,9 +48,7 @@ EXPORT_SYMBOL(journal_get_create_access)
 EXPORT_SYMBOL(journal_get_undo_access);
 EXPORT_SYMBOL(journal_dirty_data);
 EXPORT_SYMBOL(journal_dirty_metadata);
-#if 0
 EXPORT_SYMBOL(journal_release_buffer);
-#endif
 EXPORT_SYMBOL(journal_forget);
 #if 0
 EXPORT_SYMBOL(journal_sync_buffer);
--- linux-2.4.21/fs/jbd/transaction.c.diff	2003-07-09 05:54:57.000000000 -0400
+++ linux-2.4.21/fs/jbd/transaction.c	2003-07-09 11:36:29.000000000 -0400
@@ -626,6 +626,7 @@ repeat:
 	error = 0;
 
 	spin_lock(&journal_datalist_lock);
+	handle->h_last_buffer_credits = 0;
 
 	/* The buffer is already part of this transaction if
 	 * b_transaction or b_next_transaction points to it. */
@@ -644,6 +645,7 @@ repeat:
 
 		J_ASSERT_JH(jh, handle->h_buffer_credits > 0);
 		handle->h_buffer_credits--;
+		handle->h_last_buffer_credits++;
 		goto done_locked;
 	}
 	
@@ -719,6 +721,7 @@ repeat:
 
 	J_ASSERT(handle->h_buffer_credits > 0);
 	handle->h_buffer_credits--;
+	handle->h_last_buffer_credits++;
 
 	/* Finally, if the buffer is not journaled right now, we need to
 	 * make sure it doesn't get written to disk before the caller
@@ -1174,41 +1177,30 @@ out_unlock:
 	return 0;
 }
 
-#if 0
 /* 
  * journal_release_buffer: undo a get_write_access without any buffer
  * updates, if the update decided in the end that it didn't need access.
  *
  * journal_get_write_access() can block, so it is quite possible for a
  * journaling component to decide after the write access is returned
- * that global state has changed and the update is no longer required.  */
+ * that global state has changed and the update is no longer required.
+ *
+ * We leave the buffer attached to t_reserved_list because even though this
+ * handle doesn't want it, some other concurrent handle may want to journal
+ * this buffer.  If that handle is curently in between get_write_access() and
+ * journal_dirty_metadata() then it expects the buffer to be reserved.  If
+ * we were to rip it off t_reserved_list here, the other handle will explode
+ * when journal_dirty_metadata is presented with a non-reserved buffer.
+ *
+ * If nobody really wants to journal this buffer then it will be thrown
+ * away at the start of commit.
+ */
 
 void journal_release_buffer (handle_t *handle, struct buffer_head *bh)
 {
-	transaction_t *transaction = handle->h_transaction;
-	journal_t *journal = transaction->t_journal;
-	struct journal_head *jh = bh2jh(bh);
-
-	lock_journal(journal);
-	JBUFFER_TRACE(jh, "entry");
-
-	/* If the buffer is reserved but not modified by this
-	 * transaction, then it is safe to release it.  In all other
-	 * cases, just leave the buffer as it is. */
-
-	spin_lock(&journal_datalist_lock);
-	if (jh->b_jlist == BJ_Reserved && jh->b_transaction == transaction &&
-	    !buffer_jdirty(jh2bh(jh))) {
-		JBUFFER_TRACE(jh, "unused: refiling it");
-		handle->h_buffer_credits++;
-		__journal_refile_buffer(jh);
-	}
-	spin_unlock(&journal_datalist_lock);
-
-	JBUFFER_TRACE(jh, "exit");
-	unlock_journal(journal);
+	BUFFER_TRACE(bh, "entry");
+	handle->h_buffer_credits += handle->h_last_buffer_credits;
 }
-#endif
 
 /** 
  * void journal_forget() - bforget() for potentially-journaled buffers.
--- linux-2.4.21/include/linux/jbd.h.diff	2003-07-09 11:34:07.000000000 -0400
+++ linux-2.4.21/include/linux/jbd.h	2003-07-09 11:34:59.000000000 -0400
@@ -359,6 +359,10 @@ struct handle_s 
 	/* Number of remaining buffers we are allowed to dirty: */
 	int			h_buffer_credits;
 
+	/* Number of credits consumed by the last journal_get_write_access
+	   or get_undo_access operation */
+	int			h_last_buffer_credits;
+
 	/* Reference count on this handle */
 	int			h_ref;
 
