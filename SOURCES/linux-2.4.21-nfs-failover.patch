--- linux-2.4.21/fs/nfsd/export.c.orig	2003-07-15 06:29:39.000000000 -0400
+++ linux-2.4.21/fs/nfsd/export.c	2003-07-15 11:26:42.000000000 -0400
@@ -921,6 +921,200 @@ exp_verify_string(char *cp, int max)
 }
 
 /*
+ * When an NFS service is being relocated to another server, drop
+ * residual NFS requests left on the socket after ifdown of ip alias
+ * that would return ESTALE once the filesystem is unexported.  (Clients
+ * retry on the new server.)
+ */
+
+struct fo_dent {
+	struct fo_dent *	fo_next;
+	kdev_t			fo_dev;
+	unsigned long		fo_expire;
+	struct super_block *	fo_sb;		/* never to be dereferenced */
+};
+typedef struct fo_dent fo_dent;
+static fo_dent *failover_devs = NULL;
+static spinlock_t failover_lock = SPIN_LOCK_UNLOCKED;
+
+int
+exp_fodrop(struct nfsctl_fodrop *nfp)
+{
+	struct inode * inode = NULL;
+	struct nameidata nd;
+	struct super_block * sb;
+	fo_dent *fop, *nfo, **fopp;
+	kdev_t dev;
+	int timeout = 600;
+	int retval;
+
+	/* First, consistency check. */
+	retval = -EINVAL;
+	if (!exp_verify_string(nfp->fo_dev, NFS_MAXPATHLEN))
+		goto out;
+	retval = 0;
+	if (path_init(nfp->fo_dev, LOOKUP_FOLLOW|LOOKUP_POSITIVE, &nd))
+		retval = path_walk(nfp->fo_dev, &nd);
+	if (retval)
+		return retval;
+	inode = nd.dentry->d_inode;
+	retval = -ENOTBLK;
+	if (!S_ISBLK(inode->i_mode))
+		goto dput_and_out;
+	retval = -EACCES;
+	if (nd.mnt->mnt_flags & MNT_NODEV)
+		goto dput_and_out;
+	dev = to_kdev_t(inode->i_bdev->bd_dev);
+	retval = -ENXIO;
+	if (MAJOR(dev) >= MAX_BLKDEV)
+		goto dput_and_out;
+	retval = -ENOMEM;
+	if ((nfo = (fo_dent *) kmalloc(sizeof(struct fo_dent),
+					      GFP_KERNEL)) == NULL)
+		goto dput_and_out;
+	memset(nfo, 0, sizeof(struct fo_dent));
+	nfo->fo_dev = dev;
+	if (nfp->fo_timeout > 0 && nfp->fo_timeout < 1200)
+		timeout = nfp->fo_timeout;
+	nfo->fo_expire = jiffies + timeout * HZ;
+	if ((sb = get_super(dev)) == NULL) {
+		/*
+		 * No queued requests if not mounted.
+		 */
+		retval = 0;
+		kfree(nfo);
+		goto dput_and_out;
+	}
+	if (!sb->s_root) {
+		drop_super(sb);
+		retval = 0;
+		kfree(nfo);
+		goto dput_and_out;
+	}
+	drop_super(sb);
+	nfo->fo_sb = sb;
+
+	spin_lock(&failover_lock);
+	/* Get rid of expired entries or other entries for this dev */
+	fopp = &failover_devs;
+	while ((fop = *fopp) != NULL) {
+		if (time_before(fop->fo_expire, jiffies) || fop->fo_dev == dev) {
+			*fopp = fop->fo_next;
+			kfree(fop);
+		} else {
+			fopp = &fop->fo_next;
+		}
+	}
+	nfo->fo_next = failover_devs;
+	failover_devs = nfo;
+	spin_unlock(&failover_lock);
+	retval = 0;
+dput_and_out:
+	path_release(&nd);
+out:
+	return retval;
+}
+
+/*
+ * Remove device from failover drop ESTALE list.
+ */
+int
+exp_stopfodrop(struct nfsctl_fodrop *nfp)
+{
+	struct nameidata nd;
+	struct inode * inode = NULL;
+	fo_dent *fop, **fopp;
+	kdev_t dev;
+	int retval;
+
+	/* First, consistency check. */
+	retval = -EINVAL;
+	if (!exp_verify_string(nfp->fo_dev, NFS_MAXPATHLEN))
+		goto out;
+	retval = 0;
+	if (path_init(nfp->fo_dev, LOOKUP_FOLLOW|LOOKUP_POSITIVE, &nd))
+		retval = path_walk(nfp->fo_dev, &nd);
+	if (retval)
+		return retval;
+	inode = nd.dentry->d_inode;
+	retval = -ENOTBLK;
+	if (!S_ISBLK(inode->i_mode))
+		goto dput_and_out;
+	retval = -EACCES;
+	if (nd.mnt->mnt_flags & MNT_NODEV)
+		goto dput_and_out;
+	dev = to_kdev_t(inode->i_bdev->bd_dev);
+	retval = -ENXIO;
+	if (MAJOR(dev) >= MAX_BLKDEV)
+		goto dput_and_out;
+
+	spin_lock(&failover_lock);
+	/* Get rid of expired entries or the entry for this dev */
+	fopp = &failover_devs;
+	while ((fop = *fopp) != NULL) {
+		if (time_before(fop->fo_expire, jiffies) || fop->fo_dev == dev) {
+			*fopp = fop->fo_next;
+			kfree(fop);
+		} else {
+			fopp = &fop->fo_next;
+		}
+	}
+	spin_unlock(&failover_lock);
+	retval = 0;
+dput_and_out:
+	path_release(&nd);
+out:
+	return retval;
+}
+
+/*
+ * Determine if failover is in progress and ESTALE error should be dropped.
+ * Since ESTALE and failover are rare occurances cleanup list if necessary.
+ */
+int
+exp_should_drop(kdev_t dev)
+{
+	fo_dent *fop, **fopp;
+	struct super_block *sb = get_super(dev);
+
+	spin_lock(&failover_lock);
+	/* Get rid of expired entries until find this dev */
+	fopp = &failover_devs;
+	while ((fop = *fopp) != NULL) {
+		if (time_before(fop->fo_expire, jiffies)) {
+			*fopp = fop->fo_next;
+			kfree(fop);
+		} else if (fop->fo_dev == dev) {
+			break;
+		} else {
+			fopp = &fop->fo_next;
+		}
+	}
+	if (fop == NULL)
+		goto out_nope;
+	/*
+	 * If device remounted get rid of and don't drop.
+	 * XXX What makes you think the value of sb must be unique?
+	 */
+	if (sb && (fop->fo_sb != sb)) {
+		*fopp = fop->fo_next;
+		kfree(fop);
+		goto out_nope;
+	}
+
+	spin_unlock(&failover_lock);
+	if (sb)
+		drop_super(sb);
+	return 1;
+
+out_nope:
+	spin_unlock(&failover_lock);
+	if (sb)
+		drop_super(sb);
+	return 0;
+}
+
+/*
  * Initialize the exports module.
  */
 void
@@ -943,6 +1137,7 @@ void
 nfsd_export_shutdown(void)
 {
 	int	i;
+	fo_dent *fop, *next;
 
 	dprintk("nfsd: shutting down export module.\n");
 
@@ -957,5 +1152,15 @@ nfsd_export_shutdown(void)
 	clients = NULL; /* we may be restarted before the module unloads */
 	
 	exp_unlock();
+
+	spin_lock(&failover_lock);
+	fop = failover_devs;
+	failover_devs = NULL;
+	spin_unlock(&failover_lock);
+	while (fop) {
+		next = fop->fo_next;
+		kfree(fop);
+		fop = next;
+	}
 	dprintk("nfsd: export shutdown complete.\n");
 }
--- linux-2.4.21/fs/nfsd/nfsctl.c.orig	2003-07-15 06:29:58.000000000 -0400
+++ linux-2.4.21/fs/nfsd/nfsctl.c	2003-07-15 11:26:42.000000000 -0400
@@ -13,6 +13,7 @@
 
 #include <linux/linkage.h>
 #include <linux/sched.h>
+#include <linux/stddef.h>
 #include <linux/errno.h>
 #include <linux/fs.h>
 #include <linux/fcntl.h>
@@ -43,6 +44,8 @@ static int	nfsctl_unexport(struct nfsctl
 static int	nfsctl_getfh(struct nfsctl_fhparm *, __u8 *);
 static int	nfsctl_getfd(struct nfsctl_fdparm *, __u8 *);
 static int	nfsctl_getfs(struct nfsctl_fsparm *, struct knfsd_fh *);
+static int	nfsctl_fodrop(struct nfsctl_fodrop *data);
+static int	nfsctl_stopfodrop(struct nfsctl_fodrop *data);
 #ifdef notyet
 static int	nfsctl_ugidupdate(struct nfsctl_ugidmap *data);
 #endif
@@ -194,6 +197,18 @@ nfsctl_getfh(struct nfsctl_fhparm *data,
 	return err;
 }
 
+static inline int
+nfsctl_fodrop(struct nfsctl_fodrop *data)
+{
+	return exp_fodrop(data);
+}
+
+static inline int
+nfsctl_stopfodrop(struct nfsctl_fodrop *data)
+{
+	return exp_stopfodrop(data);
+}
+
 #ifdef CONFIG_NFSD
 #define handle_sys_nfsservctl sys_nfsservctl
 #endif
@@ -230,11 +245,18 @@ asmlinkage handle_sys_nfsservctl(int cmd
 		goto done;
 	}
 	err = -EINVAL;
-	if (cmd<0 || cmd > CMD_MAX)
-		goto done;
+	/* Handle special cases for NFS failover */
+	if ((cmd >= NFSCTL_FO_MIN) && (cmd <= NFSCTL_FO_MAX)) {
+		argsize = sizeof(struct nfsctl_fodrop) +
+		    offsetof(struct nfsctl_arg, u);
+		respsize = 0;
+	} else {
+		if (cmd < 0 || cmd > CMD_MAX)
+			goto done;
+		argsize = sizes[cmd].argsize + offsetof(struct nfsctl_arg, u);
+		respsize = sizes[cmd].respsize;	/* maximum */
+	}
 	err = -EFAULT;
-	argsize = sizes[cmd].argsize + (int)&((struct nfsctl_arg *)0)->u;
-	respsize = sizes[cmd].respsize;	/* maximum */
 	if (!access_ok(VERIFY_READ, argp, argsize)
 	 || (resp && !access_ok(VERIFY_WRITE, resp, respsize))) {
 		goto done;
@@ -283,6 +305,12 @@ asmlinkage handle_sys_nfsservctl(int cmd
 		err = nfsctl_getfs(&arg->ca_getfs, &res->cr_getfs);
 		respsize = res->cr_getfs.fh_size+ (int)&((struct knfsd_fh*)0)->fh_base;
 		break;
+	case NFSCTL_FODROP:
+		err = nfsctl_fodrop(&arg->ca_fodrop);
+		break;
+	case NFSCTL_STOPFODROP:
+		err = nfsctl_stopfodrop(&arg->ca_fodrop);
+		break;
 	default:
 		err = -EINVAL;
 	}
--- linux-2.4.21/fs/nfsd/nfsfh.c.orig	2003-07-15 06:29:28.000000000 -0400
+++ linux-2.4.21/fs/nfsd/nfsfh.c	2003-07-15 11:47:50.000000000 -0400
@@ -590,10 +590,12 @@ fh_verify(struct svc_rqst *rqstp, struct
 		else
 			exp = exp_get(rqstp->rq_client, xdev, xino);
 
-		if (!exp)
+		if (!exp) {
 			/* export entry revoked */
+			if (exp_should_drop(xdev))
+				error = nfserr_dropit;
 			goto out;
-
+		}
 		/* Check if the request originated from a secure port. */
 		error = nfserr_perm;
 		if (!rqstp->rq_secure && EX_SECURE(exp)) {
--- linux-2.4.21/fs/nfsd/nfssvc.c.orig	2003-07-15 06:29:58.000000000 -0400
+++ linux-2.4.21/fs/nfsd/nfssvc.c	2003-07-15 11:26:42.000000000 -0400
@@ -307,6 +307,8 @@ nfsd_dispatch(struct svc_rqst *rqstp, u3
 	if (nfserr == nfserr_dropit) {
 		dprintk("nfsd: Dropping request due to malloc failure!\n");
 		nfsd_cache_update(rqstp, RC_NOCACHE, NULL);
+		if (proc->pc_release)
+			proc->pc_release(rqstp, NULL, rqstp->rq_resp);
 		return 0;
 	}
 		
--- linux-2.4.21/include/linux/nfsd/export.h.orig	2003-07-15 06:55:26.000000000 -0400
+++ linux-2.4.21/include/linux/nfsd/export.h	2003-07-15 11:26:42.000000000 -0400
@@ -115,6 +115,7 @@ int			exp_rootfh(struct svc_client *, kd
 					char *path, struct knfsd_fh *, int maxsize);
 int			nfserrno(int errno);
 void			exp_nlmdetach(void);
+int			exp_should_drop(kdev_t dev);
 
 
 #endif /* __KERNEL__ */
--- linux-2.4.21/include/linux/nfsd/nfsd.h.orig	2003-07-15 06:55:26.000000000 -0400
+++ linux-2.4.21/include/linux/nfsd/nfsd.h	2003-07-15 11:26:42.000000000 -0400
@@ -196,6 +196,7 @@ void		nfsd_lockd_unexport(struct svc_cli
 
 /* error code for internal use - if a request fails due to
  * kmalloc failure, it gets dropped.  Client should resend eventually
+ * P3: not only kmalloc anymore, we use it for NFS failover too.
  */
 #define	nfserr_dropit		__constant_htonl(30000)
 
--- linux-2.4.21/include/linux/nfsd/syscall.h.orig	2003-07-15 06:55:26.000000000 -0400
+++ linux-2.4.21/include/linux/nfsd/syscall.h	2003-07-15 11:26:42.000000000 -0400
@@ -38,6 +38,13 @@
 #define NFSCTL_GETFH		6	/* get an fh by ino (used by mountd) */
 #define NFSCTL_GETFD		7	/* get an fh by path (used by mountd) */
 #define	NFSCTL_GETFS		8	/* get an fh by path with max FH len */
+#define NFSCTL_FODROP		50	/* drop requests during failover */
+#define NFSCTL_STOPFODROP	51	/* stop dropping requests */
+#define NFSCTL_FOLOCKS		52	/* drop locks for failover */
+#define NFSCTL_FOGRACE		53	/* set grace period for failover */
+#define NFSCTL_FOSERV		54	/* remove service mon for failover */
+#define NFSCTL_FO_MIN		NFSCTL_FODROP
+#define NFSCTL_FO_MAX		NFSCTL_FOSERV
 
 /* SVC */
 struct nfsctl_svc {
@@ -99,6 +106,12 @@ struct nfsctl_fsparm {
 	int			gd_maxlen;
 };
 
+/* FODROP/STOPFODROP */
+struct nfsctl_fodrop {
+	char			fo_dev[NFS_MAXPATHLEN+1];
+	__u32			fo_timeout;
+};
+
 /*
  * This is the argument union.
  */
@@ -112,6 +125,7 @@ struct nfsctl_arg {
 		struct nfsctl_fhparm	u_getfh;
 		struct nfsctl_fdparm	u_getfd;
 		struct nfsctl_fsparm	u_getfs;
+		struct nfsctl_fodrop	u_fodrop;
 	} u;
 #define ca_svc		u.u_svc
 #define ca_client	u.u_client
@@ -121,6 +135,7 @@ struct nfsctl_arg {
 #define ca_getfd	u.u_getfd
 #define	ca_getfs	u.u_getfs
 #define ca_authd	u.u_authd
+#define ca_fodrop	u.u_fodrop
 };
 
 union nfsctl_res {
@@ -141,6 +156,8 @@ extern int		exp_addclient(struct nfsctl_
 extern int		exp_delclient(struct nfsctl_client *ncp);
 extern int		exp_export(struct nfsctl_export *nxp);
 extern int		exp_unexport(struct nfsctl_export *nxp);
+extern int		exp_fodrop(struct nfsctl_fodrop *nfp);
+extern int		exp_stopfodrop(struct nfsctl_fodrop *nfp);
 
 #endif /* __KERNEL__ */
 
