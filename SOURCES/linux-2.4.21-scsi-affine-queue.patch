diff -urNp linux-7020/drivers/block/ll_rw_blk.c linux-7030/drivers/block/ll_rw_blk.c
--- linux-7020/drivers/block/ll_rw_blk.c
+++ linux-7030/drivers/block/ll_rw_blk.c
@@ -567,6 +567,10 @@ void blk_init_queue(request_queue_t * q,
 	blk_queue_bounce_limit(q, BLK_BOUNCE_HIGH);
 }
 
+void blk_start_queue_timer(request_queue_t * q)
+{
+}
+
 #define blkdev_free_rq(list) list_entry((list)->next, struct request, queue);
 /*
  * Get a free request. io_request_lock must be held and interrupts
@@ -1795,6 +1799,7 @@ EXPORT_SYMBOL(blk_queue_headactive);
 EXPORT_SYMBOL(blk_queue_superbh);
 EXPORT_SYMBOL(blk_queue_large_superbh);
 EXPORT_SYMBOL(blk_queue_make_request);
+EXPORT_SYMBOL_GPL(blk_start_queue_timer);
 EXPORT_SYMBOL(generic_make_request);
 EXPORT_SYMBOL(blkdev_release_request);
 EXPORT_SYMBOL(generic_unplug_device);
diff -urNp linux-7020/drivers/scsi/hosts.h linux-7030/drivers/scsi/hosts.h
--- linux-7020/drivers/scsi/hosts.h
+++ linux-7030/drivers/scsi/hosts.h
@@ -300,6 +300,11 @@ typedef struct	SHT
      * True for drivers which can handle variable length IO
      */
     unsigned vary_io:1;
+    
+    /*
+     * True for drivers that want the plug starvation timer
+     */
+    unsigned need_plug_timer:1;
 
 #ifndef __GENKSYMS__ /* preserve KMI/ABI ksyms compatibility for mod linkage */
     /*
@@ -446,6 +451,13 @@ struct Scsi_Host
      * we can do BIOS EDD 3.0 mappings
      */
     struct pci_dev *pci_dev;
+    
+    /*
+     * CPU mask, for CPUs that are allowed to submit commands directly.
+     * defaults to 'all CPUs' - the driver is in full control of this
+     * field, and it can set this according to the queueing conditions.
+     */
+    unsigned long can_queue_mask;
 
     /*
      * We should ensure that this is aligned, both for better performance
diff -urNp linux-7020/include/linux/blkdev.h linux-7030/include/linux/blkdev.h
--- linux-7020/include/linux/blkdev.h
+++ linux-7030/include/linux/blkdev.h
@@ -126,6 +126,12 @@ struct request_queue
 	 * not.
 	 */
 	char			head_active;
+	
+	/*
+	 * Boolean that indicates whether the queue wants a periodic
+	 * unplug to avoid starvation issues
+	 */
+	char			need_plug_timer; 
 
 	/*
 	 * max segments
@@ -151,6 +157,11 @@ struct request_queue
 	wait_queue_head_t	wait_for_requests[2];
 	
 	struct request		*last_request;
+	
+	unsigned long		effective_cpu_mask;
+	unsigned long		*prefered_cpu_mask;
+	
+	struct timer_list	plug_timer;
 };
 
 #define blk_queue_plugged(q)	(q)->plugged
@@ -228,6 +239,7 @@ extern void blkdev_release_request(struc
  */
 extern int blk_grow_request_list(request_queue_t *q, int nr_requests);
 extern void blk_init_queue(request_queue_t *, request_fn_proc *);
+extern void blk_start_queue_timer(request_queue_t * q);
 extern void blk_cleanup_queue(request_queue_t *);
 extern void blk_queue_headactive(request_queue_t *, int);
 extern void blk_queue_superbh(request_queue_t *, int);
