diff -urNp linux-7041/drivers/scsi/scsi.c linux-7050/drivers/scsi/scsi.c
--- linux-7041/drivers/scsi/scsi.c
+++ linux-7050/drivers/scsi/scsi.c
@@ -253,14 +253,6 @@ static void scsi_wait_done(Scsi_Cmnd * S
 }
 
 /*
- * This lock protects the freelist for all devices on the system.
- * We could make this finer grained by having a single lock per
- * device if it is ever found that there is excessive contention
- * on this lock.
- */
-static spinlock_t device_request_lock = SPIN_LOCK_UNLOCKED;
-
-/*
  * Function:    scsi_allocate_request
  *
  * Purpose:     Allocate a request descriptor.
@@ -368,7 +360,7 @@ Scsi_Cmnd *scsi_allocate_device(Scsi_Dev
   
   	host = device->host;
   
-	spin_lock_irqsave(&device_request_lock, flags);
+	spin_lock_irqsave(&device->device_request_lock, flags);
  
 	while (1 == 1) {
 		if (!device->device_blocked) {
@@ -447,7 +439,7 @@ busy:
                                 set_current_state(TASK_UNINTERRUPTIBLE);
                         }
 
-                        spin_unlock_irqrestore(&device_request_lock, flags);
+                        spin_unlock_irqrestore(&device->device_request_lock, flags);
 
 			/*
 			 * This should block until a device command block
@@ -455,7 +447,7 @@ busy:
 			 */
                         schedule();
 
-			spin_lock_irqsave(&device_request_lock, flags);
+			spin_lock_irqsave(&device->device_request_lock, flags);
 
                         remove_wait_queue(&device->scpnt_wait, &wait);
                         /*
@@ -472,13 +464,13 @@ busy:
                          */
                         if( interruptable ) {
                                 if (signal_pending(current)) {
-                                        spin_unlock_irqrestore(&device_request_lock, flags);
+                                        spin_unlock_irqrestore(&device->device_request_lock, flags);
                                         return NULL;
                                 }
                         }
 			continue;
 		} else {
-                        spin_unlock_irqrestore(&device_request_lock, flags);
+                        spin_unlock_irqrestore(&device->device_request_lock, flags);
 			return NULL;
 		}
 	}
@@ -517,7 +509,7 @@ found:
 	SCpnt->state = SCSI_STATE_INITIALIZING;
 	SCpnt->owner = SCSI_OWNER_HIGHLEVEL;
 
-	spin_unlock_irqrestore(&device_request_lock, flags);
+	spin_unlock_irqrestore(&device->device_request_lock, flags);
 
 	SCSI_LOG_MLQUEUE(5, printk("Activating command for device %d (%d)\n",
 				   SCpnt->target,
@@ -531,10 +523,11 @@ inline void __scsi_release_command(Scsi_
 	unsigned long flags;
         Scsi_Device * SDpnt;
 
-	spin_lock_irqsave(&device_request_lock, flags);
 
         SDpnt = SCpnt->device;
 
+	spin_lock_irqsave(&SDpnt->device_request_lock, flags);
+
 	/* command is now free - add to list */
 	list_add(&SCpnt->sc_list, &SDpnt->sdev_free_q);
 
@@ -565,7 +558,7 @@ inline void __scsi_release_command(Scsi_
 		up(SCpnt->host->eh_wait);
 	}
 
-	spin_unlock_irqrestore(&device_request_lock, flags);
+	spin_unlock_irqrestore(&SDpnt->device_request_lock, flags);
 
         /*
          * Wake up anyone waiting for this device.  Do this after we
@@ -2698,6 +2691,7 @@ Scsi_Device * scsi_get_host_dev(struct S
         SDpnt->id = SHpnt->this_id;
         SDpnt->type = -1;
         SDpnt->queue_depth = 1;
+	spin_lock_init(&SDpnt->device_request_lock);
         
 	scsi_initialize_queue(SDpnt, SHpnt);
 
diff -urNp linux-7041/drivers/scsi/scsi.h linux-7050/drivers/scsi/scsi.h
--- linux-7041/drivers/scsi/scsi.h
+++ linux-7050/drivers/scsi/scsi.h
@@ -561,6 +561,7 @@ struct scsi_device {
 	Scsi_Cmnd *device_queue;	/* queue of SCSI Command structures */
 	spinlock_t	device_lock;
 	struct list_head sdev_free_q;	/* list of free cmds */
+	spinlock_t device_request_lock; /* protects the list of free cmds */
 
 /* public: */
 	unsigned int id, lun, channel;
diff -urNp linux-7041/drivers/scsi/scsi_scan.c linux-7050/drivers/scsi/scsi_scan.c
--- linux-7041/drivers/scsi/scsi_scan.c
+++ linux-7050/drivers/scsi/scsi_scan.c
@@ -363,6 +363,7 @@ void scan_scsis(struct Scsi_Host *shpnt,
 		 * Register the queue for the device.  All I/O requests will
 		 * come in through here.
 		 */
+		spin_lock_init(&SDpnt->device_request_lock);
 		scsi_initialize_queue(SDpnt, shpnt);
 		/* Make sure we have something that is valid for DMA purposes */
 		scsi_result = ((!shpnt->unchecked_isa_dma)
@@ -862,6 +863,7 @@ static int scan_scsis_single(unsigned in
 	 * the queue actually represents.   We could look it up, but it
 	 * is pointless work.
 	 */
+	spin_lock_init(&SDpnt->device_request_lock);
 	scsi_initialize_queue(SDpnt, shpnt);
 	SDpnt->host = shpnt;
 	initialize_merge_fn(SDpnt);
