diff -urNp linux-432/arch/s390x/config.in linux-437/arch/s390x/config.in
--- linux-432/arch/s390x/config.in
+++ linux-437/arch/s390x/config.in
@@ -25,6 +25,7 @@ bool 'Symmetric multi-processing support
 bool 'Kernel support for 31 bit emulation' CONFIG_S390_SUPPORT
 if [ "$CONFIG_S390_SUPPORT" = "y" ]; then
   tristate 'Kernel support for 31 bit ELF binaries' CONFIG_BINFMT_ELF32 
+  define_bool CONFIG_COMPAT y
 fi
 endmenu
 
diff -urNp linux-432/arch/s390x/kernel/ioctl32.c linux-437/arch/s390x/kernel/ioctl32.c
--- linux-432/arch/s390x/kernel/ioctl32.c
+++ linux-437/arch/s390x/kernel/ioctl32.c
@@ -25,6 +25,7 @@
 #include <linux/ext2_fs.h>
 #include <linux/hdreg.h>
 #include <linux/if_bonding.h>
+#include <linux/auto_fs.h>
 #include <linux/loop.h>
 #include <linux/blkpg.h>
 #include <linux/blk.h>
@@ -35,6 +36,7 @@
 #include <asm/dasd.h>
 #include <asm/tape390.h>
 #include <asm/sockios.h>
+#include <asm/ioctls.h>
 
 #include "linux32.h"
 
@@ -69,11 +71,6 @@ static inline int hd_geometry_ioctl(unsi
 	return ret;
 }
 
-struct timeval32 {
-	int tv_sec;
-	int tv_usec;
-};
-
 #define EXT2_IOC32_GETFLAGS               _IOR('f', 1, int)
 #define EXT2_IOC32_SETFLAGS               _IOW('f', 2, int)
 #define EXT2_IOC32_GETVERSION             _IOR('v', 1, int)
@@ -214,7 +211,7 @@ static int bond_ioctl(unsigned long fd, 
 	
 	if (copy_from_user(&ifr, (struct ifreq32 *)arg, sizeof(struct ifreq32)))
 		return -EFAULT;
-	ifr.ifr_data = (__kernel_caddr_t)get_free_page(GFP_KERNEL);
+	ifr.ifr_data = (__kernel_caddr_t)get_zeroed_page(GFP_KERNEL);
 	if (!ifr.ifr_data)
 		return -EAGAIN;
 
@@ -480,6 +477,332 @@ static int blkpg_ioctl_trans(unsigned in
 }
 
 
+/* Fix sizeof(sizeof()) breakage */
+#define BLKELVGET_32	_IOR(0x12,106,int)
+#define BLKELVSET_32	_IOW(0x12,107,int)
+#define BLKBSZGET_32	_IOR(0x12,112,int)
+#define BLKBSZSET_32	_IOW(0x12,113,int)
+#define BLKGETSIZE64_32	_IOR(0x12,114,int)
+
+static int do_blkelvget(unsigned int fd, unsigned int cmd, unsigned long arg)
+{
+	return sys_ioctl(fd, BLKELVGET, arg);
+}
+
+static int do_blkelvset(unsigned int fd, unsigned int cmd, unsigned long arg)
+{
+	return sys_ioctl(fd, BLKELVSET, arg);
+}
+
+static int do_blkbszget(unsigned int fd, unsigned int cmd, unsigned long arg)
+{
+	return sys_ioctl(fd, BLKBSZGET, arg);
+}
+
+static int do_blkbszset(unsigned int fd, unsigned int cmd, unsigned long arg)
+{
+	return sys_ioctl(fd, BLKBSZSET, arg);
+}
+
+static int do_blkgetsize64(unsigned int fd, unsigned int cmd,
+			   unsigned long arg)
+{
+	return sys_ioctl(fd, BLKGETSIZE64, arg);
+}
+
+
+typedef struct ica_z90_status_t {
+  int totalcount;
+  int leedslitecount;
+  int leeds2count;
+  int requestqWaitCount;
+  int pendingqWaitCount;
+  int totalOpenCount;
+  int cryptoDomain;
+  unsigned char status[64];
+  unsigned char qdepth[64];
+} ica_z90_status;
+
+typedef struct _ica_rsa_modexpo {
+  char         *inputdata;
+  unsigned int  inputdatalength;
+  char         *outputdata;
+  unsigned int  outputdatalength;
+  char         *b_key;
+  char         *n_modulus;
+} ica_rsa_modexpo_t;
+
+typedef struct _ica_rsa_modexpo_32 {
+  u32          inputdata;
+  u32          inputdatalength;
+  u32          outputdata;
+  u32          outputdatalength;
+  u32          b_key;
+  u32          n_modulus;
+} ica_rsa_modexpo_32_t;
+
+typedef struct _ica_rsa_modexpo_crt {
+  char         *inputdata;
+  unsigned int  inputdatalength;
+  char         *outputdata;
+  unsigned int  outputdatalength;
+  char         *bp_key;
+  char         *bq_key;
+  char         *np_prime;
+  char         *nq_prime;
+  char         *u_mult_inv;
+} ica_rsa_modexpo_crt_t;
+
+typedef struct _ica_rsa_modexpo_crt_32 {
+  u32          inputdata;
+  u32          inputdatalength;
+  u32          outputdata;
+  u32          outputdatalength;
+  u32          bp_key;
+  u32          bq_key;
+  u32          np_prime;
+  u32          nq_prime;
+  u32          u_mult_inv;
+} ica_rsa_modexpo_crt_32_t;
+
+#define ICA_IOCTL_MAGIC 'z'
+#define ICARSAMODEXPO   _IOC(_IOC_READ|_IOC_WRITE, ICA_IOCTL_MAGIC, 0x05, 0)
+#define ICARSACRT       _IOC(_IOC_READ|_IOC_WRITE, ICA_IOCTL_MAGIC, 0x06, 0) 
+#define ICARSAMODMULT   _IOC(_IOC_READ|_IOC_WRITE, ICA_IOCTL_MAGIC, 0x07, 0)
+#define ICAZ90STATUS    _IOC(_IOC_READ, ICA_IOCTL_MAGIC, 0x10, sizeof(ica_z90_status))
+#define ICAZ90QUIESCE   _IOC(_IOC_NONE, ICA_IOCTL_MAGIC, 0x11, 0)
+#define ICAZ90HARDRESET _IOC(_IOC_NONE, ICA_IOCTL_MAGIC, 0x12, 0)
+#define ICAZ90HARDERROR _IOC(_IOC_NONE, ICA_IOCTL_MAGIC, 0x13, 0)
+
+static int do_rsa_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)
+{
+	mm_segment_t old_fs = get_fs();
+	int err = 0;
+	ica_rsa_modexpo_t rsa;
+	ica_rsa_modexpo_32_t *rsa32 = (ica_rsa_modexpo_32_t *)arg;
+	u32 inputdata, outputdata, b_key, n_modulus;
+
+	memset (&rsa, 0, sizeof(rsa));
+
+	err |= __get_user (inputdata, &rsa32->inputdata);
+	err |= __get_user (rsa.inputdatalength, &rsa32->inputdatalength);
+	err |= __get_user (outputdata, &rsa32->outputdata);
+	err |= __get_user (rsa.outputdatalength, &rsa32->outputdatalength);
+	err |= __get_user (b_key, &rsa32->b_key);
+	err |= __get_user (n_modulus, &rsa32->n_modulus);
+	if (err)
+		return -EFAULT;
+
+	rsa.inputdata = (char *)kmalloc(rsa.inputdatalength, GFP_KERNEL);
+	if (!rsa.inputdata) {
+		err = -ENOMEM;
+		goto cleanup;
+	}
+	if (copy_from_user(rsa.inputdata, (char *)(u64)(inputdata & 0x7fffffff), 
+			   rsa.inputdatalength)) {
+		err = -EFAULT;
+		goto cleanup;
+	}
+
+	rsa.outputdata = (char *)kmalloc(rsa.outputdatalength, GFP_KERNEL);
+	if (!rsa.outputdata) {
+		err = -ENOMEM;
+		goto cleanup;
+	}
+
+	rsa.b_key = (char *)kmalloc(rsa.inputdatalength, GFP_KERNEL);
+	if (!rsa.b_key) {
+		err = -ENOMEM;
+		goto cleanup;
+	}
+	if (copy_from_user(rsa.b_key, (char *)(u64)(b_key & 0x7fffffff), 
+			   rsa.inputdatalength)) {
+		err = -EFAULT;
+		goto cleanup;
+	}
+
+	rsa.n_modulus = (char *)kmalloc(rsa.inputdatalength, GFP_KERNEL);
+	if (!rsa.n_modulus) {
+		err = -ENOMEM;
+		goto cleanup;
+	}
+	if (copy_from_user(rsa.n_modulus, (char *)(u64)(n_modulus & 0x7fffffff), 
+			   rsa.inputdatalength)) {
+		err = -EFAULT;
+		goto cleanup;
+	}
+
+	set_fs(KERNEL_DS);
+	err = sys_ioctl(fd, cmd, (unsigned long)&rsa);
+	set_fs(old_fs);
+	if (err < 0)
+		goto cleanup;
+
+	if (copy_to_user((char *)(u64)(outputdata & 0x7fffffff), rsa.outputdata,
+			 rsa.outputdatalength))
+		err = -EFAULT;
+
+cleanup:
+	if (rsa.inputdata)
+		kfree(rsa.inputdata);
+	if (rsa.outputdata)
+		kfree(rsa.outputdata);
+	if (rsa.b_key)
+		kfree(rsa.b_key);
+	if (rsa.n_modulus)
+		kfree(rsa.n_modulus);
+	
+	return err;
+}
+
+static int do_rsa_crt_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)
+{
+	mm_segment_t old_fs = get_fs();
+	int err = 0;
+	ica_rsa_modexpo_crt_t rsa;
+	ica_rsa_modexpo_crt_32_t *rsa32 = (ica_rsa_modexpo_crt_32_t *)arg;
+	u32 inputdata, outputdata, bp_key, bq_key, np_prime, nq_prime, u_mult_inv;
+
+	memset (&rsa, 0, sizeof(rsa));
+
+	err |= __get_user (inputdata, &rsa32->inputdata);
+	err |= __get_user (rsa.inputdatalength, &rsa32->inputdatalength);
+	err |= __get_user (outputdata, &rsa32->outputdata);
+	err |= __get_user (rsa.outputdatalength, &rsa32->outputdatalength);
+	err |= __get_user (bp_key, &rsa32->bp_key);
+	err |= __get_user (bq_key, &rsa32->bq_key);
+	err |= __get_user (np_prime, &rsa32->np_prime);
+	err |= __get_user (nq_prime, &rsa32->nq_prime);
+	err |= __get_user (u_mult_inv, &rsa32->u_mult_inv);
+	if (err)
+		return -EFAULT;
+
+	rsa.inputdata = (char *)kmalloc(rsa.inputdatalength, GFP_KERNEL);
+	if (!rsa.inputdata) {
+		err = -ENOMEM;
+		goto cleanup;
+	}
+	if (copy_from_user(rsa.inputdata, (char *)(u64)(inputdata & 0x7fffffff), 
+			   rsa.inputdatalength)) {
+		err = -EFAULT;
+		goto cleanup;
+	}
+
+	rsa.outputdata = (char *)kmalloc(rsa.outputdatalength, GFP_KERNEL);
+	if (!rsa.outputdata) {
+		err = -ENOMEM;
+		goto cleanup;
+	}
+
+	rsa.bp_key = (char *)kmalloc(rsa.inputdatalength/2 + 8, GFP_KERNEL);
+	if (!rsa.bp_key) {
+		err = -ENOMEM;
+		goto cleanup;
+	}
+	if (copy_from_user(rsa.bp_key, (char *)(u64)(bp_key & 0x7fffffff), 
+			   rsa.inputdatalength/2 + 8)) {
+		err = -EFAULT;
+		goto cleanup;
+	}
+
+	rsa.bq_key = (char *)kmalloc(rsa.inputdatalength/2, GFP_KERNEL);
+	if (!rsa.bq_key) {
+		err = -ENOMEM;
+		goto cleanup;
+	}
+	if (copy_from_user(rsa.bq_key, (char *)(u64)(bq_key & 0x7fffffff), 
+			   rsa.inputdatalength/2)) {
+		err = -EFAULT;
+		goto cleanup;
+	}
+
+	rsa.np_prime = (char *)kmalloc(rsa.inputdatalength/2 + 8, GFP_KERNEL);
+	if (!rsa.np_prime) {
+		err = -ENOMEM;
+		goto cleanup;
+	}
+	if (copy_from_user(rsa.np_prime, (char *)(u64)(np_prime & 0x7fffffff), 
+			   rsa.inputdatalength/2 + 8)) {
+		err = -EFAULT;
+		goto cleanup;
+	}
+
+	rsa.nq_prime = (char *)kmalloc(rsa.inputdatalength/2, GFP_KERNEL);
+	if (!rsa.nq_prime) {
+		err = -ENOMEM;
+		goto cleanup;
+	}
+	if (copy_from_user(rsa.nq_prime, (char *)(u64)(nq_prime & 0x7fffffff), 
+			   rsa.inputdatalength/2)) {
+		err = -EFAULT;
+		goto cleanup;
+	}
+
+	rsa.u_mult_inv = (char *)kmalloc(rsa.inputdatalength/2 + 8, GFP_KERNEL);
+	if (!rsa.u_mult_inv) {
+		err = -ENOMEM;
+		goto cleanup;
+	}
+	if (copy_from_user(rsa.u_mult_inv, (char *)(u64)(u_mult_inv & 0x7fffffff), 
+			   rsa.inputdatalength/2 + 8)) {
+		err = -EFAULT;
+		goto cleanup;
+	}
+
+	set_fs(KERNEL_DS);
+	err = sys_ioctl(fd, cmd, (unsigned long)&rsa);
+	set_fs(old_fs);
+	if (err < 0)
+		goto cleanup;
+
+	if (copy_to_user((char *)(u64)(outputdata & 0x7fffffff), rsa.outputdata,
+			 rsa.outputdatalength))
+		err = -EFAULT;
+
+cleanup:
+	if (rsa.inputdata)
+		kfree(rsa.inputdata);
+	if (rsa.outputdata)
+		kfree(rsa.outputdata);
+	if (rsa.bp_key)
+		kfree(rsa.bp_key);
+	if (rsa.bq_key)
+		kfree(rsa.bq_key);
+	if (rsa.np_prime)
+		kfree(rsa.np_prime);
+	if (rsa.nq_prime)
+		kfree(rsa.nq_prime);
+	if (rsa.u_mult_inv)
+		kfree(rsa.u_mult_inv);
+	
+	return err;
+}
+
+
+/*
+ * autofs
+ */
+
+#define AUTOFS_IOC_SETTIMEOUT32 _IOWR(0x93,0x64,unsigned int)
+
+/* This is only called "settimeout", but it gets old timeout too. */
+static int autofs_settimeout(unsigned int fd, unsigned int cmd, unsigned long arg)
+{
+	mm_segment_t old_fs = get_fs();
+	int err;
+	unsigned long val;
+
+	if (get_user((unsigned int) val, (u32 *)arg))
+		return -EFAULT;
+	set_fs (KERNEL_DS);
+	err = sys_ioctl(fd, AUTOFS_IOC_SETTIMEOUT, (unsigned long)&val);
+	set_fs (old_fs);
+	if (!err && put_user((unsigned int) val, (u32 *)arg))
+		return -EFAULT;
+	return err;
+}
+
+
 static int w_long(unsigned int fd, unsigned int cmd, unsigned long arg)
 {
 	mm_segment_t old_fs = get_fs();
@@ -689,8 +1012,28 @@ static struct ioctl32_list ioctl32_handl
 	IOCTL32_HANDLER(BLKGETSIZE, w_long),
 	IOCTL32_HANDLER(BLKFRAGET, w_long),
 	IOCTL32_HANDLER(BLKSECTGET, w_long),
-	IOCTL32_HANDLER(BLKPG, blkpg_ioctl_trans)
+	IOCTL32_HANDLER(BLKPG, blkpg_ioctl_trans),
 
+	IOCTL32_HANDLER(ICARSAMODEXPO, do_rsa_ioctl),
+	IOCTL32_HANDLER(ICARSACRT, do_rsa_crt_ioctl),
+	IOCTL32_HANDLER(ICARSAMODMULT, do_rsa_ioctl),
+	IOCTL32_DEFAULT(ICAZ90STATUS),
+	IOCTL32_DEFAULT(ICAZ90QUIESCE),
+	IOCTL32_DEFAULT(ICAZ90HARDRESET),
+	IOCTL32_DEFAULT(ICAZ90HARDERROR),
+
+	IOCTL32_HANDLER(BLKELVGET_32, do_blkelvget),
+	IOCTL32_HANDLER(BLKELVSET_32, do_blkelvset),
+	IOCTL32_HANDLER(BLKBSZGET_32, do_blkbszget),
+	IOCTL32_HANDLER(BLKBSZSET_32, do_blkbszset),
+	IOCTL32_HANDLER(BLKGETSIZE64_32, do_blkgetsize64),
+
+	IOCTL32_DEFAULT(AUTOFS_IOC_READY),
+	IOCTL32_DEFAULT(AUTOFS_IOC_FAIL),
+	IOCTL32_DEFAULT(AUTOFS_IOC_CATATONIC),
+	IOCTL32_HANDLER(AUTOFS_IOC_PROTOVER, w_long),
+	IOCTL32_HANDLER(AUTOFS_IOC_SETTIMEOUT32, autofs_settimeout),
+	IOCTL32_DEFAULT(AUTOFS_IOC_EXPIRE)
 };
 
 #define NR_IOCTL32_HANDLERS	(sizeof(ioctl32_handler_table) /	\
@@ -731,7 +1074,7 @@ int sys32_ioctl(unsigned int fd, unsigne
 		error = handler(fd, cmd, arg, filp);
 	} else {
 		error = -EINVAL;
-		printk("unknown ioctl: %08x\n", cmd);
+		printk(KERN_DEBUG "unknown ioctl: %08x (%s)\n", cmd, current->comm);
 	}
 out:
 	fput(filp);
diff -urNp linux-432/arch/s390x/kernel/linux32.c linux-437/arch/s390x/kernel/linux32.c
--- linux-432/arch/s390x/kernel/linux32.c
+++ linux-437/arch/s390x/kernel/linux32.c
@@ -901,8 +901,8 @@ asmlinkage long sys32_fcntl(unsigned int
 			ret = sys_fcntl(fd, cmd, (unsigned long)&f);
 			set_fs (old_fs);
 			if (ret) return ret;
-			if (f.l_start >= 0x7fffffffUL ||
-			    f.l_start + f.l_len >= 0x7fffffffUL)
+			if (f.l_start >= 0x7fffffffL ||
+			    f.l_start + f.l_len >= 0x7fffffffL)
 				return -EOVERFLOW;
 			if(put_flock(&f, (struct flock32 *)A(arg)))
 				return -EFAULT;
@@ -1170,7 +1170,11 @@ static long do_readv_writev32(int type, 
 
 		__get_user(len, &vector->iov_len);
 		__get_user(buf, &vector->iov_base);
-		tot_len += len;
+		if ((int)len < 0 || (tot_len += len) >= 0x7fffffff) {
+			if (iov != iovstack)
+				kfree(iov);
+			return -EINVAL;
+		}
 		ivp->iov_base = (void *)A(buf);
 		ivp->iov_len = (__kernel_size_t) len;
 		vector++;
@@ -3121,7 +3125,7 @@ static int do_set_icmpv6_filter(int fd, 
 	return ret;
 }
 
-asmlinkage int sys32_setsockopt(int fd, int level, int optname,
+static int sys32_setsockopt(int fd, int level, int optname,
 				char *optval, int optlen)
 {
 	if (optname == SO_ATTACH_FILTER)
diff -urNp linux-432/include/asm-s390x/siginfo.h linux-437/include/asm-s390x/siginfo.h
--- linux-432/include/asm-s390x/siginfo.h
+++ linux-437/include/asm-s390x/siginfo.h
@@ -19,7 +19,7 @@ typedef union sigval {
 } sigval_t;
 
 #define SI_MAX_SIZE	128
-#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 3)
+#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 4)
 
 typedef struct siginfo {
 	int si_signo;
@@ -231,7 +231,7 @@ static inline void copy_siginfo(siginfo_
 		memcpy(to, from, sizeof(siginfo_t));
 	else
 		/* _sigchld is currently the largest know union member */
-		memcpy(to, from, 3*sizeof(int) + sizeof(from->_sifields._sigchld));
+		memcpy(to, from, 4*sizeof(int) + sizeof(from->_sifields._sigchld));
 }
 
 extern int copy_siginfo_to_user(siginfo_t *to, siginfo_t *from);
