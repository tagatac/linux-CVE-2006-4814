diff -urNp linux-6091/fs/nfs/inode.c linux-6092/fs/nfs/inode.c
--- linux-6091/fs/nfs/inode.c
+++ linux-6092/fs/nfs/inode.c
@@ -1355,7 +1355,8 @@ __nfs_refresh_inode(struct inode *inode,
 /*
  * File system information
  */
-static DECLARE_FSTYPE(nfs_fs_type, "nfs", nfs_read_super, FS_ODD_RENAME);
+static DECLARE_FSTYPE(nfs_fs_type, "nfs", nfs_read_super, 
+	FS_ODD_RENAME|FS_AIO_SYNC);
 
 extern int nfs_init_nfspagecache(void);
 extern void nfs_destroy_nfspagecache(void);
diff -urNp linux-6091/include/linux/fs.h linux-6092/include/linux/fs.h
--- linux-6091/include/linux/fs.h
+++ linux-6092/include/linux/fs.h
@@ -95,6 +95,8 @@ extern int leases_enable, dir_notify_ena
 #define FS_ODD_RENAME	32768	/* Temporary stuff; will go away as soon
 				  * as nfs_rename() will be cleaned up
 				  */
+#define FS_AIO_SYNC	262144 /* Used by NFS */
+
 /*
  * These are the fs-independent mount-flags: up to 32 flags are supported
  */
diff -urNp linux-6091/mm/wtd.c linux-6092/mm/wtd.c
--- linux-6091/mm/wtd.c
+++ linux-6092/mm/wtd.c
@@ -3,6 +3,21 @@
 #include <linux/mm.h>
 #include <linux/pagemap.h>
 
+static inline int fs_aio_sync(struct page *page)
+{
+	if (page->mapping && page->mapping->host && page->mapping->host->i_sb)
+		return (page->mapping->host->i_sb->s_type->fs_flags & FS_AIO_SYNC);
+	return 0;
+}
+
+static inline void __sync_page(struct page *page)
+{
+	struct address_space *mapping = page->mapping;
+
+	if (mapping && mapping->a_ops && mapping->a_ops->sync_page)
+		mapping->a_ops->sync_page(page);
+}
+
 static void __wtd_lock_page_waiter(wait_queue_t *wait)
 {
 	struct worktodo *wtd = (struct worktodo *)wait;
@@ -26,8 +41,14 @@ int wtd_lock_page(struct worktodo *wtd, 
 		 */
 		if (!add_wait_queue_cond(page_waitqueue(page), &wtd->wait,
 					TryLockPage(page))) {
-			/* Page is still locked.  Kick the disk queue... */
-			run_task_queue(&tq_disk);
+			/*
+			 * Page is still locked.  Either kick the disk queue
+			 * or invoke the file system's sync_page handler.
+			 */
+			if (fs_aio_sync(page))
+				__sync_page(page);
+			else
+				run_task_queue(&tq_disk);
 			return 0;
 		}
 	}
