--- linux-2.4.20/include/asm-ppc64/semaphore.h.orig	Mon Apr 14 08:53:32 2003
+++ linux-2.4.20/include/asm-ppc64/semaphore.h	Mon Apr 14 09:54:48 2003
@@ -68,8 +68,10 @@
 	sema_init(sem, 0);
 }
 
+struct worktodo;
 extern void __down(struct semaphore * sem);
 extern int  __down_interruptible(struct semaphore * sem);
+extern void __wtd_down(struct semaphore * sem, struct worktodo * wtd);
 extern void __up(struct semaphore * sem);
 
 static inline void down(struct semaphore * sem)
@@ -128,6 +130,31 @@
 {
 	return atomic_read(&sem->count);
 }
+
+
+static inline int wtd_down(struct worktodo *wtd, struct semaphore *sem)
+{
+        int ret = 0;
+
+#if WAITQUEUE_DEBUG
+        CHECK_MAGIC(sem->__magic);
+#endif
+
+        if (unlikely(atomic_dec_return(&sem->count) < 0)) {
+                __wtd_down(sem, wtd);
+                ret = 1;
+        } else
+                /*
+                 * The reason they're not smp_mb() must be due
+                 * some lowlevel arch detail or it's broken.
+                 */
+                smp_wmb();
+
+        return ret;
+}
+
+
+
 
 #endif /* __KERNEL__ */
 
--- linux-2.4.20/include/asm-ppc64/kmap_types.h.orig	Mon Apr 14 09:01:26 2003
+++ linux-2.4.20/include/asm-ppc64/kmap_types.h	Mon Apr 14 09:01:16 2003
@@ -0,0 +1,23 @@
+#ifdef __KERNEL__
+#ifndef _ASM_KMAP_TYPES_H
+#define _ASM_KMAP_TYPES_H
+
+enum km_type {
+	KM_BOUNCE_READ,
+	KM_SKB_SUNRPC_DATA,
+	KM_SKB_DATA_SOFTIRQ,
+	KM_USER0,
+	KM_USER1,
+	KM_BIO_SRC_IRQ,
+	KM_BIO_DST_IRQ,
+	KM_PTE0,
+	KM_PTE1,
+	KM_IRQ0,
+	KM_IRQ1,
+	KM_SOFTIRQ0,
+	KM_SOFTIRQ1,	
+	KM_TYPE_NR
+};
+
+#endif
+#endif /* __KERNEL__ */
--- linux-2.4.20/arch/ppc64/kernel/semaphore.c.orig	Mon Apr 14 09:08:16 2003
+++ linux-2.4.20/arch/ppc64/kernel/semaphore.c	Mon Apr 14 09:54:04 2003
@@ -17,6 +17,7 @@
  */
 
 #include <linux/sched.h>
+#include <linux/worktodo.h>
 #include <asm/atomic.h>
 #include <asm/semaphore.h>
 #include <asm/errno.h>
@@ -129,3 +130,42 @@
 	wake_up(&sem->wait);
 	return retval;
 }
+
+
+
+extern void __wtd_down(struct semaphore * sem, struct worktodo *wtd);
+        
+static void __wtd_down_action(void *data)
+{       
+        struct worktodo *wtd = data;
+        struct semaphore *sem;
+
+        wtd_pop(wtd);
+        sem = wtd->data;
+
+        __wtd_down(sem, wtd);
+}       
+        
+static void __wtd_down_waiter(wait_queue_t *wait)
+{       
+        struct worktodo *wtd = (struct worktodo *)wait;
+        struct semaphore *sem = wtd->data;
+
+        __remove_wait_queue(&sem->wait, &wtd->wait);
+        wtd_push(wtd, __wtd_down_action, wtd);
+        wtd_queue(wtd); 
+}        
+         
+void __wtd_down(struct semaphore * sem, struct worktodo * wtd)
+{        
+        int gotit;
+         
+        init_waitqueue_func_entry(&wtd->wait, __wtd_down_waiter);
+        wtd->data = sem;
+
+        gotit = add_wait_queue_exclusive_cond(&sem->wait, &wtd->wait, __sem_update_count( sem, -1) <= 0); if (gotit) { 
+                wake_up(&sem->wait);
+                wtd_queue(wtd); 
+        }
+}
+
