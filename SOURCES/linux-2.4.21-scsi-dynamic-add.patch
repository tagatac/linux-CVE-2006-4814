diff -urNp linux-7040/drivers/scsi/hosts.c linux-7045/drivers/scsi/hosts.c
--- linux-7040/drivers/scsi/hosts.c
+++ linux-7045/drivers/scsi/hosts.c
@@ -88,7 +88,27 @@ void
 scsi_unregister(struct Scsi_Host * sh){
     struct Scsi_Host * shpnt;
     Scsi_Host_Name *shn;
-        
+    char name[10];
+
+    /* kill error handling thread */
+    if (sh->hostt->use_new_eh_code
+        && sh->ehandler != NULL) {
+        DECLARE_MUTEX_LOCKED(sem);
+
+        sh->eh_notify = &sem;
+        send_sig(SIGHUP, sh->ehandler, 1);
+        down(&sem);
+        sh->eh_notify = NULL;
+    }
+
+    /* remove proc entry */
+#ifdef CONFIG_PROC_FS
+    sprintf(name, "%d", sh->host_no);
+    remove_proc_entry(name, sh->hostt->proc_dir);
+#endif
+       
+    sh->hostt->present--;
+ 
     if(scsi_hostlist == sh)
 	scsi_hostlist = sh->next;
     else {
@@ -117,11 +137,13 @@ scsi_unregister(struct Scsi_Host * sh){
  * pain to reverse this, so we try to avoid it 
  */
 extern int blk_nohighio;
+extern int scsi_in_detection;
+extern void scsi_setup_host(struct Scsi_Host *);
 struct Scsi_Host * scsi_register(Scsi_Host_Template * tpnt, int j){
     struct Scsi_Host * retval, *shpnt, *o_shp;
     Scsi_Host_Name *shn, *shn2;
     int flag_new = 1;
-    const char * hname;
+    const char * hname, * name;
     size_t hname_len;
     retval = (struct Scsi_Host *)kmalloc(sizeof(struct Scsi_Host) + j,
 					 (tpnt->unchecked_isa_dma && j ? 
@@ -252,6 +274,12 @@ struct Scsi_Host * scsi_register(Scsi_Ho
 		o_shp->next = retval;
         }
     }
+
+    tpnt->present++;
+
+    if (!scsi_in_detection) {
+	scsi_setup_host(retval);
+    }
     
     return retval;
 }
diff -urNp linux-7040/drivers/scsi/hosts.h linux-7045/drivers/scsi/hosts.h
--- linux-7040/drivers/scsi/hosts.h
+++ linux-7045/drivers/scsi/hosts.h
@@ -497,8 +497,6 @@ extern struct Scsi_Device_Template * scs
 
 extern Scsi_Host_Template * scsi_hosts;
 
-extern void build_proc_dir_entries(Scsi_Host_Template  *);
-
 /*
  *  scsi_init initializes the scsi hosts.
  */
@@ -508,6 +506,7 @@ extern int next_scsi_host;
 unsigned int scsi_init(void);
 extern struct Scsi_Host * scsi_register(Scsi_Host_Template *, int j);
 extern void scsi_unregister(struct Scsi_Host * i);
+extern void scsi_scan_host(struct Scsi_Host *);
 
 extern void scsi_register_blocked_host(struct Scsi_Host * SHpnt);
 extern void scsi_deregister_blocked_host(struct Scsi_Host * SHpnt);
diff -urNp linux-7040/drivers/scsi/scsi.c linux-7045/drivers/scsi/scsi.c
--- linux-7040/drivers/scsi/scsi.c
+++ linux-7045/drivers/scsi/scsi.c
@@ -77,6 +77,7 @@
 #undef USE_STATIC_SCSI_MEMORY
 
 struct proc_dir_entry *proc_scsi;
+int scsi_in_detection;
 
 #ifdef CONFIG_PROC_FS
 static int scsi_proc_info(char *buffer, char **start, off_t offset, int length);
@@ -128,8 +129,9 @@ static union scsi_done_queue {
  */
 unsigned int scsi_logging_level;
 
-const char *const scsi_device_types[MAX_SCSI_DEVICE_CODE] =
+static const char *const __scsi_device_types[MAX_SCSI_DEVICE_CODE+1] =
 {
+	"Unprobed         ",
 	"Direct-Access    ",
 	"Sequential-Access",
 	"Printer          ",
@@ -146,6 +148,14 @@ const char *const scsi_device_types[MAX_
 	"Enclosure        ",
 };
 
+#define _SDT_STRINGIFY1(x) #x
+#define _SDT_STRINGIFY2(x) _SDT_STRINGIFY1(x)
+#define SCSI_DEV_TYPES _SDT_STRINGIFY2(scsi_device_types)
+
+__asm__ (".globl " SCSI_DEV_TYPES "\n\t"
+         SCSI_DEV_TYPES " = __scsi_device_types + "
+         _SDT_STRINGIFY2(BITS_PER_LONG) "/8");
+
 /* 
  * Function prototypes.
  */
@@ -1860,6 +1870,121 @@ out:
 }
 #endif
 
+#ifdef CONFIG_PROC_FS
+extern void build_proc_dir(Scsi_Host_Template *);
+extern void build_proc_dir_entry(struct Scsi_Host *);
+#endif
+
+/*
+ * This is called once for every host found during module loading after the
+ * detect routine has completed.  It is also called by scsi_register() when
+ * dynamically adding an adapter to an already loaded and running module.
+ */
+void scsi_setup_host(struct Scsi_Host *shpnt)
+{
+	char * name;
+
+	/* Make an entry for this host in the module's /proc directory */
+#ifdef CONFIG_PROC_FS
+	build_proc_dir_entry(shpnt);
+#endif
+	/* Print out a nice message about this host */
+	if (shpnt->hostt->info)
+		name = (char *)shpnt->hostt->info(shpnt);
+	else
+		name = (char *)shpnt->hostt->name;
+	printk(KERN_INFO "scsi%d : %s\n", shpnt->host_no, name);
+	/* Start any needed error handler threads */
+	if (shpnt->hostt->use_new_eh_code) {
+		DECLARE_MUTEX_LOCKED(sem);
+
+		shpnt->eh_notify = &sem;
+		kernel_thread((int (*)(void *))scsi_error_handler, (void *)shpnt, 0);
+
+		/* Now wait for startup to complete */
+		down(&sem);
+		shpnt->eh_notify = NULL;
+	}
+}
+
+void scsi_scan_host(struct Scsi_Host *shpnt)
+{
+	struct Scsi_Device_Template *sdtpnt;
+	Scsi_Device *SDpnt;
+
+	/* Scan the host for devices */
+	scan_scsis(shpnt, 0, 0, 0, 0);
+	/* Set the queue depth on any found devices */
+	if (shpnt->select_queue_depths != NULL) {
+		(shpnt->select_queue_depths) (shpnt, shpnt->host_queue);
+	}
+	/* See if the upper layer drivers noticed any devices */
+	for (sdtpnt = scsi_devicelist; sdtpnt; sdtpnt = sdtpnt->next) {
+		if (sdtpnt->init && sdtpnt->dev_noticed)
+			(*sdtpnt->init) ();
+	}
+	/*
+	 * Next we attach devices and build commandblocks 
+	 */
+	for (SDpnt = shpnt->host_queue; SDpnt; SDpnt = SDpnt->next) {
+		for (sdtpnt = scsi_devicelist; sdtpnt; sdtpnt = sdtpnt->next)
+			if (sdtpnt->attach)
+				(*sdtpnt->attach) (SDpnt);
+		if (SDpnt->attached) {
+			scsi_build_commandblocks(SDpnt);
+			if (0 == SDpnt->has_cmdblocks) {
+				for (sdtpnt = scsi_devicelist; sdtpnt;
+					sdtpnt = sdtpnt->next)
+					if (sdtpnt->detach)
+						(*sdtpnt->detach) (SDpnt);
+
+				if (SDpnt->attached == 0) {
+					/*
+					 * Nobody is using this device any more.
+					 * Free all of the command structures.
+					 */
+		                        if (shpnt->hostt->revoke)
+                		                shpnt->hostt->revoke(SDpnt);
+					devfs_unregister (SDpnt->de);
+
+					/* Now we can remove the device */
+					if (SDpnt->next != NULL)
+						SDpnt->next->prev = SDpnt->prev;
+
+					if (SDpnt->prev != NULL)
+						SDpnt->prev->next = SDpnt->next;
+
+					if (shpnt->host_queue == SDpnt) {
+						shpnt->host_queue = SDpnt->next;
+					}
+					blk_cleanup_queue(&SDpnt->request_queue);
+					kfree((char *) SDpnt);
+				} else {
+					printk(KERN_WARNING "scsi: unable to free partially initialized device!\n");
+				}
+			}
+		}
+	}
+	/*
+	 * Now that we have all of the devices, resize the DMA pool,
+	 * as required.
+	 */
+	scsi_resize_dma_pool();
+
+	/* This does any final handling that is required. */
+	for (sdtpnt = scsi_devicelist; sdtpnt; sdtpnt = sdtpnt->next) {
+		if (sdtpnt->finish && sdtpnt->nr_dev) {
+			(*sdtpnt->finish) ();
+		}
+	}
+#if defined(USE_STATIC_SCSI_MEMORY)
+	printk("SCSI memory: total %ldKb, used %ldKb, free %ldKb.\n",
+	       (scsi_memory_upper_value - scsi_memory_lower_value) / 1024,
+	       (scsi_init_memory_start - scsi_memory_lower_value) / 1024,
+	       (scsi_memory_upper_value - scsi_init_memory_start) / 1024);
+#endif
+}
+
 /*
  * This entry point should be called by a driver if it is trying
  * to add a low level scsi driver to the system.
@@ -1868,11 +1993,7 @@ static int scsi_register_host(Scsi_Host_
 {
 	int pcount;
 	struct Scsi_Host *shpnt;
-	Scsi_Device *SDpnt;
-	struct Scsi_Device_Template *sdtpnt;
-	const char *name;
 	unsigned long flags;
-	int out_of_space = 0;
 
 	if (tpnt->next || !tpnt->detect)
 		return 1;	/* Must be already loaded, or
@@ -1901,132 +2022,51 @@ static int scsi_register_host(Scsi_Host_
 
 	if (tpnt->use_new_eh_code) {
 		spin_lock_irqsave(&io_request_lock, flags);
-		tpnt->present = tpnt->detect(tpnt);
+		scsi_in_detection = 1;
+		tpnt->detect(tpnt);
+		scsi_in_detection = 0;
 		spin_unlock_irqrestore(&io_request_lock, flags);
-	} else
-		tpnt->present = tpnt->detect(tpnt);
+	} else {
+		scsi_in_detection = 1;
+		tpnt->detect(tpnt);
+		scsi_in_detection = 0;
+	}
 
-	if (tpnt->present) {
-		if (pcount == next_scsi_host) {
-			if (tpnt->present > 1) {
-				printk(KERN_ERR "scsi: Failure to register low-level scsi driver");
-				scsi_unregister_host(tpnt);
-				return 1;
-			}
-			/* 
-			 * The low-level driver failed to register a driver.
-			 * We can do this now.
-			 */
-			if(scsi_register(tpnt, 0)==NULL)
-			{
-				printk(KERN_ERR "scsi: register failed.\n");
-				scsi_unregister_host(tpnt);
-				return 1;
-			}
-		}
-		tpnt->next = scsi_hosts;	/* Add to the linked list */
-		scsi_hosts = tpnt;
+	/*
+	 * If we succeed at registering *any* host adapter, this will be non-0.
+	 * If it's still 0, then we didn't register anything, and we haven't
+	 * linked the template into our template list yet, so backing out and
+	 * exiting is easy, just dec the module count and return non-0.
+	 */
+	if (!tpnt->present) {
+		MOD_DEC_USE_COUNT;
+		return 1;
+	}
 
-		/* Add the new driver to /proc/scsi */
+	/* Add the new driver to /proc/scsi (directory only) */
 #ifdef CONFIG_PROC_FS
-		build_proc_dir_entries(tpnt);
+	build_proc_dir(tpnt);
 #endif
 
+	tpnt->next = scsi_hosts;
+	wmb();
+	scsi_hosts = tpnt;
 
-		/*
-		 * Add the kernel threads for each host adapter that will
-		 * handle error correction.
-		 */
-		for (shpnt = scsi_hostlist; shpnt; shpnt = shpnt->next) {
-			if (shpnt->hostt == tpnt && shpnt->hostt->use_new_eh_code) {
-				DECLARE_MUTEX_LOCKED(sem);
-
-				shpnt->eh_notify = &sem;
-				kernel_thread((int (*)(void *)) scsi_error_handler,
-					      (void *) shpnt, 0);
-
-				/*
-				 * Now wait for the kernel error thread to initialize itself
-				 * as it might be needed when we scan the bus.
-				 */
-				down(&sem);
-				shpnt->eh_notify = NULL;
-			}
-		}
-
-		for (shpnt = scsi_hostlist; shpnt; shpnt = shpnt->next) {
-			if (shpnt->hostt == tpnt) {
-				if (tpnt->info) {
-					name = tpnt->info(shpnt);
-				} else {
-					name = tpnt->name;
-				}
-				printk(KERN_INFO "scsi%d : %s\n",		/* And print a little message */
-				       shpnt->host_no, name);
-			}
-		}
-
-		/* The next step is to call scan_scsis here.  This generates the
-		 * Scsi_Devices entries
-		 */
-		for (shpnt = scsi_hostlist; shpnt; shpnt = shpnt->next) {
-			if (shpnt->hostt == tpnt) {
-				scan_scsis(shpnt, 0, 0, 0, 0);
-				if (shpnt->select_queue_depths != NULL) {
-					(shpnt->select_queue_depths) (shpnt, shpnt->host_queue);
-				}
-			}
-		}
-
-		for (sdtpnt = scsi_devicelist; sdtpnt; sdtpnt = sdtpnt->next) {
-			if (sdtpnt->init && sdtpnt->dev_noticed)
-				(*sdtpnt->init) ();
-		}
-
-		/*
-		 * Next we create the Scsi_Cmnd structures for this host 
-		 */
-		for (shpnt = scsi_hostlist; shpnt; shpnt = shpnt->next) {
-			for (SDpnt = shpnt->host_queue; SDpnt; SDpnt = SDpnt->next)
-				if (SDpnt->host->hostt == tpnt) {
-					for (sdtpnt = scsi_devicelist; sdtpnt; sdtpnt = sdtpnt->next)
-						if (sdtpnt->attach)
-							(*sdtpnt->attach) (SDpnt);
-					if (SDpnt->attached) {
-						scsi_build_commandblocks(SDpnt);
-						if (0 == SDpnt->has_cmdblocks)
-							out_of_space = 1;
-					}
-				}
-		}
-
-		/*
-		 * Now that we have all of the devices, resize the DMA pool,
-		 * as required.  */
-		if (!out_of_space)
-			scsi_resize_dma_pool();
-
-
-		/* This does any final handling that is required. */
-		for (sdtpnt = scsi_devicelist; sdtpnt; sdtpnt = sdtpnt->next) {
-			if (sdtpnt->finish && sdtpnt->nr_dev) {
-				(*sdtpnt->finish) ();
-			}
-		}
-	}
-#if defined(USE_STATIC_SCSI_MEMORY)
-	printk("SCSI memory: total %ldKb, used %ldKb, free %ldKb.\n",
-	       (scsi_memory_upper_value - scsi_memory_lower_value) / 1024,
-	       (scsi_init_memory_start - scsi_memory_lower_value) / 1024,
-	       (scsi_memory_upper_value - scsi_init_memory_start) / 1024);
-#endif
+	/*
+	 * Time to setup whatever SCSI hosts we found.
+	 */
+	for(shpnt = scsi_hostlist; shpnt; shpnt = shpnt->next)
+		if (shpnt->hostt == tpnt)
+			scsi_setup_host(shpnt);
 
+	/*
+	 * Time to scan found hosts
+	 */
+	for(shpnt = scsi_hostlist; shpnt; shpnt = shpnt->next)
+		if (shpnt->hostt == tpnt)
+			scsi_scan_host(shpnt);
 
-	if (out_of_space) {
-		scsi_unregister_host(tpnt);	/* easiest way to clean up?? */
-		return 1;
-	} else
-		return 0;
+	return 0;
 }
 
 /*
@@ -2043,7 +2083,6 @@ static int scsi_unregister_host(Scsi_Hos
 	struct Scsi_Device_Template *sdtpnt;
 	struct Scsi_Host *sh1;
 	struct Scsi_Host *shpnt;
-	char name[10];	/* host_no>=10^9? I don't think so. */
 
 	/* get the big kernel lock, so we don't race with open() */
 	lock_kernel();
@@ -2142,22 +2181,6 @@ static int scsi_unregister_host(Scsi_Hos
 		}
 	}
 
-	/*
-	 * Next, kill the kernel error recovery thread for this host.
-	 */
-	for (shpnt = scsi_hostlist; shpnt; shpnt = shpnt->next) {
-		if (shpnt->hostt == tpnt
-		    && shpnt->hostt->use_new_eh_code
-		    && shpnt->ehandler != NULL) {
-			DECLARE_MUTEX_LOCKED(sem);
-
-			shpnt->eh_notify = &sem;
-			send_sig(SIGHUP, shpnt->ehandler, 1);
-			down(&sem);
-			shpnt->eh_notify = NULL;
-		}
-	}
-
 	/* Next we free up the Scsi_Cmnd structures for this host */
 
 	for (shpnt = scsi_hostlist; shpnt; shpnt = shpnt->next) {
@@ -2185,9 +2208,6 @@ static int scsi_unregister_host(Scsi_Hos
 		if (shpnt->hostt != tpnt)
 			continue;
 		pcount = next_scsi_host;
-		/* Remove the /proc/scsi directory entry */
-		sprintf(name,"%d",shpnt->host_no);
-		remove_proc_entry(name, tpnt->proc_dir);
 		if (tpnt->release)
 			(*tpnt->release) (shpnt);
 		else {
@@ -2204,7 +2224,6 @@ static int scsi_unregister_host(Scsi_Hos
 		}
 		if (pcount == next_scsi_host)
 			scsi_unregister(shpnt);
-		tpnt->present--;
 	}
 
 	/*
@@ -2628,6 +2647,7 @@ static int __init init_scsi(void)
 	 * when commands are completed.
 	 */
 	open_softirq(SCSI_SOFTIRQ, scsi_softirq_handler, NULL);
+	scsi_in_detection = 0;
 
 	return 0;
 }
diff -urNp linux-7040/drivers/scsi/scsi_proc.c linux-7045/drivers/scsi/scsi_proc.c
--- linux-7040/drivers/scsi/scsi_proc.c
+++ linux-7045/drivers/scsi/scsi_proc.c
@@ -120,35 +120,34 @@ static int proc_scsi_write(struct file *
 	return(ret);
 }
 
-void build_proc_dir_entries(Scsi_Host_Template * tpnt)
+void build_proc_dir_entry(struct Scsi_Host *shpnt)
 {
-	struct Scsi_Host *hpnt;
-	char name[10];	/* see scsi_unregister_host() */
+	char name[10]; /* host_no >= 10^9? I don't think so. */
+	struct proc_dir_entry *p;
 
+	if (shpnt->hostt->proc_dir) {
+		sprintf(name, "%d", shpnt->host_no);
+		p = create_proc_read_entry(
+			name,
+			S_IFREG | S_IRUGO | S_IWUSR,
+			shpnt->hostt->proc_dir,
+			proc_scsi_read,
+			(void *)shpnt);
+		if (!p)
+			panic("Not enough memory to register SCSI HBA in /proc/scsi!\n");
+		p->write_proc = proc_scsi_write;
+		p->owner = shpnt->hostt->module;
+	}
+}
+
+void build_proc_dir(Scsi_Host_Template * tpnt)
+{
 	tpnt->proc_dir = proc_mkdir(tpnt->proc_name, proc_scsi);
         if (!tpnt->proc_dir) {
-                printk(KERN_ERR "Unable to proc_mkdir in scsi.c/build_proc_dir_entries");
+                printk(KERN_ERR "Unable to proc_mkdir in scsi_proc.c/build_proc_dir\n");
                 return;
         }
 	tpnt->proc_dir->owner = tpnt->module;
-
-	hpnt = scsi_hostlist;
-	while (hpnt) {
-		if (tpnt == hpnt->hostt) {
-			struct proc_dir_entry *p;
-			sprintf(name,"%d",hpnt->host_no);
-			p = create_proc_read_entry(name,
-					S_IFREG | S_IRUGO | S_IWUSR,
-					tpnt->proc_dir,
-					proc_scsi_read,
-					(void *)hpnt);
-			if (!p)
-				panic("Not enough memory to register SCSI HBA in /proc/scsi !\n");
-			p->write_proc=proc_scsi_write;
-			p->owner = tpnt->module;
-		}
-		hpnt = hpnt->next;
-	}
 }
 
 /*
diff -urNp linux-7040/drivers/scsi/scsi_syms.c linux-7045/drivers/scsi/scsi_syms.c
--- linux-7040/drivers/scsi/scsi_syms.c
+++ linux-7045/drivers/scsi/scsi_syms.c
@@ -37,6 +37,7 @@ EXPORT_SYMBOL(scsi_free);
 EXPORT_SYMBOL(scsi_malloc);
 EXPORT_SYMBOL(scsi_register);
 EXPORT_SYMBOL(scsi_unregister);
+EXPORT_SYMBOL(scsi_scan_host);
 EXPORT_SYMBOL(scsicam_bios_param);
 EXPORT_SYMBOL(scsi_partsize);
 EXPORT_SYMBOL(scsi_allocate_device);
