diff -urNp linux-8180/drivers/char/drm/i810.h linux-8181/drivers/char/drm/i810.h
--- linux-8180/drivers/char/drm/i810.h
+++ linux-8181/drivers/char/drm/i810.h
@@ -114,4 +114,13 @@
 #define DRIVER_AGP_BUFFERS_MAP( dev )					\
 	((drm_i810_private_t *)((dev)->dev_private))->buffer_map
 
+#define LOCK_TEST_WITH_RETURN( dev )					\
+do {									\
+	if (!_DRM_LOCK_IS_HELD((dev)->lock.hw_lock->lock) ||		\
+	    (dev)->lock.pid != current->pid) {				\
+		DRM_ERROR("%s called without lock held\n", __FUNCTION__);\
+		return -EINVAL;						\
+	}								\
+} while (0)
+
 #endif
diff -urNp linux-8180/drivers/char/drm/i810_dma.c linux-8181/drivers/char/drm/i810_dma.c
--- linux-8180/drivers/char/drm/i810_dma.c
+++ linux-8181/drivers/char/drm/i810_dma.c
@@ -948,10 +948,7 @@ int i810_flush_ioctl(struct inode *inode
    	drm_file_t	  *priv	  = filp->private_data;
    	drm_device_t	  *dev	  = priv->dev;
 
-   	if(!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
-		DRM_ERROR("i810_flush_ioctl called without lock held\n");
-		return -EINVAL;
-	}
+	LOCK_TEST_WITH_RETURN(dev);
 
    	i810_flush_queue(dev);
    	return 0;
@@ -973,10 +970,7 @@ int i810_dma_vertex(struct inode *inode,
 	if (copy_from_user(&vertex, (drm_i810_vertex_t *)arg, sizeof(vertex)))
 		return -EFAULT;
 
-   	if(!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
-		DRM_ERROR("i810_dma_vertex called without lock held\n");
-		return -EINVAL;
-	}
+	LOCK_TEST_WITH_RETURN(dev);
 
 	if(vertex.idx < 0 || vertex.idx > dma->buf_count) return -EINVAL;
 
@@ -1004,10 +998,7 @@ int i810_clear_bufs(struct inode *inode,
    	if (copy_from_user(&clear, (drm_i810_clear_t *)arg, sizeof(clear)))
 		return -EFAULT;
 
-   	if(!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
-		DRM_ERROR("i810_clear_bufs called without lock held\n");
-		return -EINVAL;
-	}
+	LOCK_TEST_WITH_RETURN(dev);
 
  	/* GH: Someone's doing nasty things... */
  	if (!dev->dev_private) {
@@ -1026,10 +1017,7 @@ int i810_swap_bufs(struct inode *inode, 
 	drm_file_t *priv = filp->private_data;
 	drm_device_t *dev = priv->dev;
 
-   	if(!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
-		DRM_ERROR("i810_swap_buf called without lock held\n");
-		return -EINVAL;
-	}
+	LOCK_TEST_WITH_RETURN(dev);
 
 	i810_dma_dispatch_swap( dev );
    	return 0;
@@ -1064,10 +1052,7 @@ int i810_getbuf(struct inode *inode, str
    	if (copy_from_user(&d, (drm_i810_dma_t *)arg, sizeof(d)))
 		return -EFAULT;
 
-	if(!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
-		DRM_ERROR("i810_dma called without lock held\n");
-		return -EINVAL;
-	}
+	LOCK_TEST_WITH_RETURN(dev);
 
 	d.granted = 0;
 
@@ -1174,11 +1159,7 @@ int i810_dma_mc(struct inode *inode, str
 	if (copy_from_user(&mc, (drm_i810_mc_t *)arg, sizeof(mc)))
 		return -EFAULT;
 
-
-	if(!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
-		DRM_ERROR("i810_dma_mc called without lock held\n");
-		return -EINVAL;
-	}
+	LOCK_TEST_WITH_RETURN(dev);
 
 	i810_dma_dispatch_mc(dev, dma->buflist[mc.idx], mc.used,
 		mc.last_render );
@@ -1223,10 +1204,7 @@ int i810_fstatus(struct inode *inode, st
 	drm_device_t *dev = priv->dev;
 	drm_i810_private_t *dev_priv = (drm_i810_private_t *)dev->dev_private;
 
-	if(!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
-		DRM_ERROR("i810_fstatus called without lock held\n");
-		return -EINVAL;
-	}
+	LOCK_TEST_WITH_RETURN(dev);
 	return I810_READ(0x30008);
 }
 
@@ -1237,10 +1215,7 @@ int i810_ov0_flip(struct inode *inode, s
 	drm_device_t *dev = priv->dev;
 	drm_i810_private_t *dev_priv = (drm_i810_private_t *)dev->dev_private;
 
-	if(!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
-		DRM_ERROR("i810_ov0_flip called without lock held\n");
-		return -EINVAL;
-	}
+	LOCK_TEST_WITH_RETURN(dev);
 
 	//Tell the overlay to update
 	I810_WRITE(0x30000,dev_priv->overlay_physical | 0x80000000);
diff -urNp linux-8180/drivers/char/drm/i830.h linux-8181/drivers/char/drm/i830.h
--- linux-8180/drivers/char/drm/i830.h
+++ linux-8181/drivers/char/drm/i830.h
@@ -154,4 +154,13 @@
 #define DRIVER_AGP_BUFFERS_MAP( dev )					\
 	((drm_i830_private_t *)((dev)->dev_private))->buffer_map
 
+#define LOCK_TEST_WITH_RETURN( dev )					\
+do {									\
+	if (!_DRM_LOCK_IS_HELD((dev)->lock.hw_lock->lock) ||		\
+	    (dev)->lock.pid != current->pid) {				\
+		DRM_ERROR("%s called without lock held\n", __FUNCTION__);\
+		return -EINVAL;						\
+	}								\
+} while (0)
+
 #endif
diff -urNp linux-8180/drivers/char/drm/i830_dma.c linux-8181/drivers/char/drm/i830_dma.c
--- linux-8180/drivers/char/drm/i830_dma.c
+++ linux-8181/drivers/char/drm/i830_dma.c
@@ -1330,10 +1330,7 @@ int i830_flush_ioctl(struct inode *inode
    	drm_file_t	  *priv	  = filp->private_data;
    	drm_device_t	  *dev	  = priv->dev;
 
-   	if(!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
-		DRM_ERROR("i830_flush_ioctl called without lock held\n");
-		return -EINVAL;
-	}
+	LOCK_TEST_WITH_RETURN(dev);
 
    	i830_flush_queue(dev);
    	return 0;
@@ -1354,10 +1351,7 @@ int i830_dma_vertex(struct inode *inode,
 	if (copy_from_user(&vertex, (drm_i830_vertex_t *)arg, sizeof(vertex)))
 		return -EFAULT;
 
-   	if(!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
-		DRM_ERROR("i830_dma_vertex called without lock held\n");
-		return -EINVAL;
-	}
+	LOCK_TEST_WITH_RETURN(dev);
 
 	DRM_DEBUG("i830 dma vertex, idx %d used %d discard %d\n",
 		  vertex.idx, vertex.used, vertex.discard);
@@ -1384,10 +1378,7 @@ int i830_clear_bufs(struct inode *inode,
    	if (copy_from_user(&clear, (drm_i830_clear_t *)arg, sizeof(clear)))
 		return -EFAULT;
    
-   	if(!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
-		DRM_ERROR("i830_clear_bufs called without lock held\n");
-		return -EINVAL;
-	}
+	LOCK_TEST_WITH_RETURN(dev);
 
 	/* GH: Someone's doing nasty things... */
 	if (!dev->dev_private) {
@@ -1409,10 +1400,7 @@ int i830_swap_bufs(struct inode *inode, 
    
 	DRM_DEBUG("i830_swap_bufs\n");
 
-   	if(!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
-		DRM_ERROR("i830_swap_buf called without lock held\n");
-		return -EINVAL;
-	}
+	LOCK_TEST_WITH_RETURN(dev); 
 
 	i830_dma_dispatch_swap( dev );
    	return 0;
@@ -1453,10 +1441,7 @@ int i830_flip_bufs(struct inode *inode, 
 
 	DRM_DEBUG("%s\n", __FUNCTION__);
 
-   	if(!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
-		DRM_ERROR("i830_flip_buf called without lock held\n");
-		return -EINVAL;
-	}
+	LOCK_TEST_WITH_RETURN(dev);
 
 	if (!dev_priv->page_flipping) 
 		i830_do_init_pageflip( dev );
@@ -1495,10 +1480,7 @@ int i830_getbuf(struct inode *inode, str
    	if (copy_from_user(&d, (drm_i830_dma_t *)arg, sizeof(d)))
 		return -EFAULT;
    
-	if(!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
-		DRM_ERROR("i830_dma called without lock held\n");
-		return -EINVAL;
-	}
+	LOCK_TEST_WITH_RETURN(dev);
 	
 	d.granted = 0;
 
diff -urNp linux-8180/drivers/char/drm/i830_irq.c linux-8181/drivers/char/drm/i830_irq.c
--- linux-8180/drivers/char/drm/i830_irq.c
+++ linux-8181/drivers/char/drm/i830_irq.c
@@ -130,10 +130,7 @@ int i830_irq_emit( struct inode *inode, 
 	drm_i830_irq_emit_t emit;
 	int result;
 
-   	if(!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
-		DRM_ERROR("i830_irq_emit called without lock held\n");
-		return -EINVAL;
-	}
+	LOCK_TEST_WITH_RETURN(dev);
 
 	if ( !dev_priv ) {
 		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
diff -urNp linux-8180/drivers/char/drm/r128_state.c linux-8181/drivers/char/drm/r128_state.c
--- linux-8180/drivers/char/drm/r128_state.c
+++ linux-8181/drivers/char/drm/r128_state.c
@@ -23,8 +23,20 @@
  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
  *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * RED HAT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * THIS SOFTWARE IS NOT INTENDED FOR USE IN SAFETY CRITICAL SYSTEMS
+ *
  * Authors:
  *    Gareth Hughes <gareth@valinux.com>
+ *
+ * Memory allocation size checks added 14/01/2003, Alan Cox <alan@redhat.com>
  */
 
 #include "r128.h"
@@ -33,6 +45,9 @@
 #include "r128_drm.h"
 #include "r128_drv.h"
 
+#ifndef MAX
+#define	MAX(a,b) (((a)>(b))?(a):(b))
+#endif
 
 /* ================================================================
  * CCE hardware state programming functions
@@ -901,6 +916,9 @@ static int r128_cce_dispatch_write_span(
 	DRM_DEBUG( "%s\n", __FUNCTION__ );
 
 	count = depth->n;
+
+	if ( (count < 0) || (count > (INT_MAX / sizeof(u32))) )
+		return -EMSGSIZE;
 	if ( copy_from_user( &x, depth->x, sizeof(x) ) ) {
 		return -EFAULT;
 	}
@@ -995,6 +1013,9 @@ static int r128_cce_dispatch_write_pixel
 
 	count = depth->n;
 
+	if ( (count < 0) || (count > (INT_MAX / MAX(sizeof(u32), sizeof(int)))))
+		return -EMSGSIZE;
+
 	x = kmalloc( count * sizeof(*x), GFP_KERNEL );
 	if ( x == NULL ) {
 		return -ENOMEM;
@@ -1109,6 +1130,9 @@ static int r128_cce_dispatch_read_span( 
 	DRM_DEBUG( "%s\n", __FUNCTION__ );
 
 	count = depth->n;
+
+	if ( (count < 0) || (count > (INT_MAX / sizeof(x))) )
+		return -EMSGSIZE;
 	if ( copy_from_user( &x, depth->x, sizeof(x) ) ) {
 		return -EFAULT;
 	}
@@ -1151,6 +1175,9 @@ static int r128_cce_dispatch_read_pixels
 	DRM_DEBUG( "%s\n", __FUNCTION__ );
 
 	count = depth->n;
+
+	if ( (count < 0) || (count > (INT_MAX / sizeof(*x))) )
+		return -EMSGSIZE;
 	if ( count > dev_priv->depth_pitch ) {
 		count = dev_priv->depth_pitch;
 	}
diff -urNp linux-8180/drivers/char/drm/radeon_cp.c linux-8181/drivers/char/drm/radeon_cp.c
--- linux-8180/drivers/char/drm/radeon_cp.c
+++ linux-8181/drivers/char/drm/radeon_cp.c
@@ -1347,7 +1347,7 @@ int radeon_cp_stop( struct inode *inode,
 
 	LOCK_TEST_WITH_RETURN( dev );
 
-	if ( copy_from_user( &stop, (drm_radeon_init_t *)arg, sizeof(stop) ) )
+	if ( copy_from_user( &stop, (drm_radeon_cp_stop_t *)arg, sizeof(stop) ) )
 		return -EFAULT;
 
 	/* Flush any pending CP commands.  This ensures any outstanding
@@ -1592,7 +1592,7 @@ static int radeon_cp_get_buffers( drm_de
 
 	for ( i = d->granted_count ; i < d->request_count ; i++ ) {
 		buf = radeon_freelist_get( dev );
-		if ( !buf ) return -EAGAIN;
+		if ( !buf ) return -EBUSY;
 
 		buf->pid = current->pid;
 
diff -urNp linux-8180/drivers/char/drm-4.0/r128_state.c linux-8181/drivers/char/drm-4.0/r128_state.c
--- linux-8180/drivers/char/drm-4.0/r128_state.c
+++ linux-8181/drivers/char/drm-4.0/r128_state.c
@@ -23,9 +23,21 @@
  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
  *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * RED HAT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * THIS SOFTWARE IS NOT INTENDED FOR USE IN SAFETY CRITICAL SYSTEMS
+ *
  * Authors:
  *    Gareth Hughes <gareth@valinux.com>
  *
+ * Memory allocation size checks added 14/01/2003, Alan Cox <alan@redhat.com>
+ *
  */
 
 #define __NO_VERSION__
@@ -33,6 +45,9 @@
 #include "r128_drv.h"
 #include "drm.h"
 
+#ifndef MAX
+#define	MAX(a,b) (((a)>(b))?(a):(b))
+#endif
 
 /* ================================================================
  * CCE hardware state programming functions
@@ -938,6 +953,9 @@ static int r128_cce_dispatch_write_span(
 	}
 
 	count = depth->n;
+
+	if ( (count < 0) || (count > (INT_MAX / sizeof(u32))) )
+		return -EMSGSIZE;
 	if ( copy_from_user( &x, depth->x, sizeof(x) ) ) {
 		return -EFAULT;
 	}
@@ -1048,6 +1066,9 @@ static int r128_cce_dispatch_write_pixel
 
 	count = depth->n;
 
+	if ( (count < 0) || (count > (INT_MAX / MAX(sizeof(u32), sizeof(int)))))
+		return -EMSGSIZE;
+
 	x = kmalloc( count * sizeof(*x), 0 );
 	if ( x == NULL ) {
 		return -ENOMEM;
@@ -1178,6 +1199,9 @@ static int r128_cce_dispatch_read_span( 
 	}
 
 	count = depth->n;
+
+	if ( (count < 0) || (count > (INT_MAX / sizeof(x))) )
+		return -EMSGSIZE;
 	if ( copy_from_user( &x, depth->x, sizeof(x) ) ) {
 		return -EFAULT;
 	}
@@ -1235,6 +1259,9 @@ static int r128_cce_dispatch_read_pixels
 	}
 
 	count = depth->n;
+
+	if ( (count < 0) || (count > (INT_MAX / sizeof(*x))) )
+		return -EMSGSIZE;
 	if ( count > dev_priv->depth_pitch ) {
 		count = dev_priv->depth_pitch;
 	}
diff -urNp linux-8180/drivers/char/drm-hp_ia64/r128_state.c linux-8181/drivers/char/drm-hp_ia64/r128_state.c
--- linux-8180/drivers/char/drm-hp_ia64/r128_state.c
+++ linux-8181/drivers/char/drm-hp_ia64/r128_state.c
@@ -23,8 +23,20 @@
  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
  *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * RED HAT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * THIS SOFTWARE IS NOT INTENDED FOR USE IN SAFETY CRITICAL SYSTEMS
+ *
  * Authors:
  *    Gareth Hughes <gareth@valinux.com>
+ *
+ * Memory allocation size checks added 14/01/2003, Alan Cox <alan@redhat.com>
  */
 
 #include "r128.h"
@@ -33,6 +45,9 @@
 #include "r128_drm.h"
 #include "r128_drv.h"
 
+#ifndef MAX
+#define	MAX(a,b) (((a)>(b))?(a):(b))
+#endif
 
 /* ================================================================
  * CCE hardware state programming functions
@@ -901,6 +916,9 @@ static int r128_cce_dispatch_write_span(
 	DRM_DEBUG( "%s\n", __FUNCTION__ );
 
 	count = depth->n;
+
+	if ( (count < 0) || (count > (INT_MAX / sizeof(u32))) )
+		return -EMSGSIZE;
 	if ( copy_from_user( &x, depth->x, sizeof(x) ) ) {
 		return -EFAULT;
 	}
@@ -995,6 +1013,9 @@ static int r128_cce_dispatch_write_pixel
 
 	count = depth->n;
 
+	if ( (count < 0) || (count > (INT_MAX / MAX(sizeof(u32), sizeof(int)))))
+		return -EMSGSIZE;
+
 	x = kmalloc( count * sizeof(*x), GFP_KERNEL );
 	if ( x == NULL ) {
 		return -ENOMEM;
@@ -1109,6 +1130,9 @@ static int r128_cce_dispatch_read_span( 
 	DRM_DEBUG( "%s\n", __FUNCTION__ );
 
 	count = depth->n;
+
+	if ( (count < 0) || (count > (INT_MAX / sizeof(x))) )
+		return -EMSGSIZE;
 	if ( copy_from_user( &x, depth->x, sizeof(x) ) ) {
 		return -EFAULT;
 	}
@@ -1151,6 +1175,9 @@ static int r128_cce_dispatch_read_pixels
 	DRM_DEBUG( "%s\n", __FUNCTION__ );
 
 	count = depth->n;
+
+	if ( (count < 0) || (count > (INT_MAX / sizeof(*x))) )
+		return -EMSGSIZE;
 	if ( count > dev_priv->depth_pitch ) {
 		count = dev_priv->depth_pitch;
 	}
