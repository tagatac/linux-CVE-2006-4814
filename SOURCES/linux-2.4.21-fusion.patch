diff -urNp linux-8145/drivers/message/fusion/Makefile linux-8150/drivers/message/fusion/Makefile
--- linux-8145/drivers/message/fusion/Makefile
+++ linux-8150/drivers/message/fusion/Makefile
@@ -9,7 +9,7 @@
 # parent makefile.
 #
 # Note 3! If you want to turn on various debug defines for an extended period of
-# time but don't want them lingering around in the Makefile when you pass it on 
+# time but don't want them lingering around in the Makefile when you pass it on
 # to someone else, use the MPT_CFLAGS env variable (thanks Steve). -nromer
 
 #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-{ LSI_LOGIC
@@ -21,6 +21,7 @@
 #EXTRA_CFLAGS += -gstabs+
 
 EXTRA_CFLAGS += -I. ${MPT_CFLAGS}
+EXTRA_CFLAGS += -DCPQ_CIM
 
 # Fusion MPT drivers; recognized debug defines...
 #  MPT general:
@@ -36,7 +37,8 @@ EXTRA_CFLAGS += -I. ${MPT_CFLAGS}
 #CFLAGS_mptbase.o += -DMPT_DEBUG_IRQ
 #
 #  For mptscsih:
-#CFLAGS_mptscsih.o += -DMPT_DEBUG_SCANDV
+#CFLAGS_mptscsih.o += -DMPT_DEBUG_DV
+#CFLAGS_mptscsih.o += -DMPT_DEBUG_DV_TINY
 #CFLAGS_mptscsih.o += -DMPT_DEBUG_RESET
 #CFLAGS_mptscsih.o += -DMPT_DEBUG_NEH
 #
diff -urNp linux-8145/drivers/message/fusion/csmisas.c linux-8150/drivers/message/fusion/csmisas.c
--- linux-8145/drivers/message/fusion/csmisas.c
+++ linux-8150/drivers/message/fusion/csmisas.c
@@ -0,0 +1,3538 @@
+
+
+/******************************************************************************/
+
+#if defined(CPQ_CIM) // HP SAS IOCTL's
+
+#ifndef TRUE
+#define TRUE     (1)
+#endif
+#ifndef FALSE
+#define FALSE    (0)
+#endif
+
+static u64 reverse_byte_order64(u64 * data64)
+{
+	int i;
+	u64 rc;
+	u8  * inWord = (u8 *)data64, * outWord = (u8 *)&rc;
+
+	for (i=0;i<8;i++) outWord[i] = inWord[7-i];
+
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Routine for the HP CSMI Sas Get Driver Info command.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int
+mptctl_csmi_sas_get_driver_info(unsigned long arg)
+{
+
+	CSMI_SAS_DRIVER_INFO_BUFFER *uarg = (void *) arg;
+	CSMI_SAS_DRIVER_INFO_BUFFER	karg;
+	MPT_ADAPTER	*ioc = NULL;
+	int		iocnum;
+
+	dctlprintk((": %s called.\n",__FUNCTION__));
+
+	if (copy_from_user(&karg, uarg, sizeof(CSMI_SAS_DRIVER_INFO_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s - "
+	      "Unable to read in csmi_sas_get_driver_info_buffer struct @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
+	    &ioc)) < 0) || (ioc == NULL)) {
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - ioc%d not found!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	if (!mptctl_is_this_sas_cntr(ioc)) {
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - ioc%d not SAS controller!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	/* Fill in the data and return the structure to the calling
+	 * program
+	 */
+	memcpy( karg.Information.szName, MPT_MISCDEV_BASENAME,
+	    sizeof(MPT_MISCDEV_BASENAME));
+	memcpy( karg.Information.szDescription, MPT_CSMI_DESCRIPTION,
+	    sizeof(MPT_CSMI_DESCRIPTION));
+
+	karg.Information.usMajorRevision = MPT_LINUX_MAJOR_VERSION;
+	karg.Information.usMinorRevision = MPT_LINUX_MINOR_VERSION;
+	karg.Information.usBuildRevision = MPT_LINUX_BUILD_VERSION;
+	karg.Information.usReleaseRevision = MPT_LINUX_RELEASE_VERSION;
+
+	karg.Information.usCSMIMajorRevision = CSMI_MAJOR_REVISION;
+	karg.Information.usCSMIMinorRevision = CSMI_MINOR_REVISION;
+
+	karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_SUCCESS;
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+		sizeof(CSMI_SAS_DRIVER_INFO_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s - "
+		   "Unable to write out csmi_sas_get_driver_info_buffer @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Prototype Routine for the HP CSMI_SAS_GET_CNTLR_CONFIG command.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int
+mptctl_csmi_sas_get_cntlr_config(unsigned long arg)
+{
+
+	CSMI_SAS_CNTLR_CONFIG_BUFFER *uarg = (void *) arg;
+	CSMI_SAS_CNTLR_CONFIG_BUFFER	karg;
+	MPT_ADAPTER	*ioc = NULL;
+	int		iocnum;
+	int		ii;
+	unsigned int 	reg;
+	u32      	l;
+
+	dctlprintk((": %s called.\n",__FUNCTION__));
+
+	if (copy_from_user(&karg, uarg, sizeof(CSMI_SAS_CNTLR_CONFIG_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s - "
+	     "Unable to read in csmi_sas_get_cntlr_config_buffer struct @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
+	    &ioc)) < 0) || (ioc == NULL)) {
+		dctlprintk((KERN_ERR
+	      "%s::%s() @%d - ioc%d not found!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_INVALID_PARAMETER;
+		return -ENODEV;
+	}
+
+	if (!mptctl_is_this_sas_cntr(ioc)) {
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - ioc%d not SAS controller!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	/* Clear the struct before filling in data. */
+	memset( &karg.Configuration, 0, sizeof(CSMI_SAS_CNTLR_CONFIG));
+
+	/* Fill in the data and return the structure to the calling
+	 * program
+	 */
+
+	/* Get Base IO and Mem Mapped Addresses. */
+	for(ii=0; ii < DEVICE_COUNT_RESOURCE; ii++) {
+		reg = PCI_BASE_ADDRESS_0 + (ii << 2);
+		pci_read_config_dword(ioc->pcidev, reg, &l);
+
+		if ((l & PCI_BASE_ADDRESS_SPACE) ==
+		    PCI_BASE_ADDRESS_SPACE_MEMORY) {
+			karg.Configuration.BaseMemoryAddress.uLowPart =
+			    l & PCI_BASE_ADDRESS_MEM_MASK;
+		}
+		else {
+			karg.Configuration.uBaseIoAddress =
+			    l & PCI_BASE_ADDRESS_IO_MASK;
+		}
+
+		if ((l & (PCI_BASE_ADDRESS_SPACE |
+		    PCI_BASE_ADDRESS_MEM_TYPE_MASK))
+		    == (PCI_BASE_ADDRESS_SPACE_MEMORY |
+		    PCI_BASE_ADDRESS_MEM_TYPE_64)) {
+			pci_read_config_dword(ioc->pcidev, reg+4, &l);
+			karg.Configuration.BaseMemoryAddress.uHighPart = l;
+		}
+		if ((l & PCI_BASE_ADDRESS_SPACE) ==
+		    PCI_BASE_ADDRESS_SPACE_MEMORY) {
+			break;
+		}
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	karg.Configuration.uBoardID = (ioc->pcidev->subsystem_device << 16) |
+	    (ioc->pcidev->subsystem_vendor);
+#endif
+
+	/* LMP The physical slot is unknown. */
+	karg.Configuration.usSlotNumber = 0;
+	karg.Configuration.bControllerClass = CSMI_SAS_CNTLR_CLASS_HBA;
+	karg.Configuration.bIoBusType = CSMI_SAS_BUS_TYPE_PCI;
+	karg.Configuration.BusAddress.PciAddress.bBusNumber =
+	    ioc->pcidev->bus->number;
+	karg.Configuration.BusAddress.PciAddress.bDeviceNumber =
+	    PCI_SLOT(ioc->pcidev->devfn);
+	karg.Configuration.BusAddress.PciAddress.bFunctionNumber =
+	    PCI_FUNC(ioc->pcidev->devfn);
+	karg.Configuration.BusAddress.PciAddress.bReserved = 0;
+
+	/* LMP  NULL terminated?  */
+	memcpy( &karg.Configuration.szSerialNumber,
+	    ioc->BoardTracerNumber, 16 );
+
+	karg.Configuration.usMajorRevision = ioc->facts.FWVersion.Struct.Major;
+	karg.Configuration.usMinorRevision = ioc->facts.FWVersion.Struct.Minor;
+	karg.Configuration.usBuildRevision = ioc->facts.FWVersion.Struct.Unit;
+	karg.Configuration.usReleaseRevision = ioc->facts.FWVersion.Struct.Dev;
+	karg.Configuration.usBIOSMajorRevision =
+	    (ioc->biosVersion & 0xFF000000) >> 24;
+	karg.Configuration.usBIOSMinorRevision =
+	    (ioc->biosVersion & 0x00FF0000) >> 16;
+	karg.Configuration.usBIOSBuildRevision =
+	    (ioc->biosVersion & 0x0000FF00) >> 8;
+	karg.Configuration.usBIOSReleaseRevision =
+	    (ioc->biosVersion & 0x000000FF);
+	karg.Configuration.uControllerFlags =
+	    CSMI_SAS_CNTLR_SAS_HBA | CSMI_SAS_CNTLR_SAS_RAID | 
+	    CSMI_SAS_CNTLR_FWD_SUPPORT | CSMI_SAS_CNTLR_FWD_ONLINE | 
+	    CSMI_SAS_CNTLR_FWD_SRESET ;
+
+	karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_SUCCESS;
+
+	/* All Rrom entries will be zero. Skip them. */
+	/* bReserved will also be zeros. */
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+		sizeof(CSMI_SAS_DRIVER_INFO_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s - "
+		"Unable to write out csmi_sas_get_driver_info_buffer @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Prototype Routine for the HP CSMI Sas Get Controller Status command.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int
+mptctl_csmi_sas_get_cntlr_status(unsigned long arg)
+{
+
+	CSMI_SAS_CNTLR_STATUS_BUFFER  *uarg = (void *) arg;
+	MPT_ADAPTER		*ioc = NULL;
+	CSMI_SAS_CNTLR_STATUS_BUFFER	karg;
+	int			iocnum;
+	int			rc;
+
+	dctlprintk((": %s called.\n",__FUNCTION__));
+
+	if (copy_from_user(&karg, uarg, sizeof(CSMI_SAS_CNTLR_STATUS_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s - "
+	     "Unable to read in csmi_sas_get_cntlr_status_buffer struct @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
+	    &ioc)) < 0) || (ioc == NULL)) {
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - ioc%d not found!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	if (!mptctl_is_this_sas_cntr(ioc)) {
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - ioc%d not SAS controller!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	/* Fill in the data and return the structure to the calling
+	 * program
+	 */
+
+	rc = mpt_GetIocState(ioc, 1);
+	switch (rc) {
+	case MPI_IOC_STATE_OPERATIONAL:
+		karg.Status.uStatus =  CSMI_SAS_CNTLR_STATUS_GOOD;
+		karg.Status.uOfflineReason = 0;
+		break;
+
+	case MPI_IOC_STATE_FAULT:
+		karg.Status.uStatus = CSMI_SAS_CNTLR_STATUS_FAILED;
+		karg.Status.uOfflineReason = 0;
+		break;
+
+	case MPI_IOC_STATE_RESET:
+	case MPI_IOC_STATE_READY:
+	default:
+		karg.Status.uStatus =  CSMI_SAS_CNTLR_STATUS_OFFLINE;
+		karg.Status.uOfflineReason =
+		    CSMI_SAS_OFFLINE_REASON_INITIALIZING;
+		break;
+	}
+
+	memset(&karg.Status.bReserved, 0, 28);
+
+	karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_SUCCESS;
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+		sizeof(CSMI_SAS_CNTLR_STATUS_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s - "
+		    "Unable to write out csmi_sas_get_cntlr_status @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Prototype Routine for the HP CSMI Sas Get Phy Info command.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int
+mptctl_csmi_sas_get_phy_info(unsigned long arg)
+{
+	CSMI_SAS_PHY_INFO_BUFFER *uarg = (void *) arg;
+	CSMI_SAS_PHY_INFO_BUFFER  karg;
+	MPT_ADAPTER		*ioc = NULL;
+	ConfigExtendedPageHeader_t  hdr;
+	CONFIGPARMS		cfg;
+	SasIOUnitPage0_t	*sasIoUnitPg0;
+	dma_addr_t		sasIoUnitPg0_dma;
+	int			sasIoUnitPg0_data_sz;
+	SasPhyPage0_t		*sasPhyPg0;
+	dma_addr_t		sasPhyPg0_dma;
+	int			sasPhyPg0_data_sz;
+	u16			protocol;
+	int			iocnum;
+	int			rc;
+	int			ii;
+	u64			SASAddress64;
+
+	dctlprintk((": %s called.\n",__FUNCTION__));
+	sasIoUnitPg0=NULL;
+	sasPhyPg0=NULL;
+	sasIoUnitPg0_data_sz=0;
+	sasPhyPg0_data_sz=0;
+
+	if (copy_from_user(&karg, uarg, sizeof(CSMI_SAS_PHY_INFO_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s - "
+		"Unable to read in csmi_sas_get_phy_info_buffer struct @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
+	    &ioc)) < 0) || (ioc == NULL)) {
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - ioc%d not found!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	if (!mptctl_is_this_sas_cntr(ioc)) {
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - ioc%d not SAS controller!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	/* Fill in the data and return the structure to the calling
+	 * program
+	 */
+	memset( &karg.Information, 0, sizeof(CSMI_SAS_PHY_INFO));
+
+	/* Issue a config request to get the number of phys
+	 */
+	hdr.PageVersion = MPI_SASIOUNITPAGE0_PAGEVERSION;
+	hdr.ExtPageLength = 0;
+	hdr.PageNumber = 0;
+	hdr.Reserved1 = 0;
+	hdr.Reserved2 = 0;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;
+	hdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_IO_UNIT;
+
+	cfg.cfghdr.ehdr = &hdr;
+	cfg.physAddr = -1;
+	cfg.pageAddr = 0;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;	/* read */
+	cfg.timeout = 10;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0) {
+		/* Don't check if this failed.  Already in a
+		 * failure case.
+		 */
+		dctlprintk((
+		    ": FAILED: MPI_SASIOUNITPAGE0_PAGEVERSION: HEADER\n"));
+		dctlprintk((": rc=%x\n",rc));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto sas_get_phy_info_exit;
+	}
+
+	if (hdr.ExtPageLength == 0) {
+		/* Don't check if this failed.  Already in a
+		 * failure case.
+		 */
+		dctlprintk((": hdr.ExtPageLength == 0\n"));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto sas_get_phy_info_exit;
+	}
+
+	sasIoUnitPg0_data_sz = hdr.ExtPageLength * 4;
+	rc = -ENOMEM;
+
+	sasIoUnitPg0 = (SasIOUnitPage0_t *) pci_alloc_consistent(ioc->pcidev,
+	    sasIoUnitPg0_data_sz, &sasIoUnitPg0_dma);
+
+	if (!sasIoUnitPg0) {
+		dctlprintk((": pci_alloc_consistent: FAILED\n"));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto sas_get_phy_info_exit;
+	}
+
+	memset((u8 *)sasIoUnitPg0, 0, sasIoUnitPg0_data_sz);
+	cfg.physAddr = sasIoUnitPg0_dma;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0) {
+
+		/* Don't check if this failed.  Already in a
+		 * failure case.
+		 */
+		dctlprintk((
+		    ": FAILED: MPI_SASIOUNITPAGE0_PAGEVERSION: PAGE\n"));
+		dctlprintk((": rc=%x\n",rc));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto sas_get_phy_info_exit;
+	}
+
+
+	/* Number of Phys. */
+	karg.Information.bNumberOfPhys = sasIoUnitPg0->NumPhys;
+
+	/* Fill in information for each phy. */
+	for (ii = 0; ii < karg.Information.bNumberOfPhys; ii++) {
+
+/* EDM : dump IO Unit Page 0 data*/
+		dsasprintk(("---- IO UNIT PAGE 0 ------------\n"));
+		dsasprintk(("Handle=0x%X\n",
+		    le16_to_cpu(sasIoUnitPg0->PhyData[ii].AttachedDeviceHandle)));
+		dsasprintk(("Controller Handle=0x%X\n",
+		    le16_to_cpu(sasIoUnitPg0->PhyData[ii].ControllerDevHandle)));
+		dsasprintk(("Port=0x%X\n",
+		    sasIoUnitPg0->PhyData[ii].Port));
+		dsasprintk(("Port Flags=0x%X\n",
+		    sasIoUnitPg0->PhyData[ii].PortFlags));
+		dsasprintk(("PHY Flags=0x%X\n",
+		    sasIoUnitPg0->PhyData[ii].PhyFlags));
+		dsasprintk(("Negotiated Link Rate=0x%X\n",
+		    sasIoUnitPg0->PhyData[ii].NegotiatedLinkRate));
+		dsasprintk(("Controller PHY Device Info=0x%X\n",
+		    le32_to_cpu(sasIoUnitPg0->PhyData[ii].ControllerPhyDeviceInfo)));
+		dsasprintk(("DiscoveryStatus=0x%X\n",
+		    le32_to_cpu(sasIoUnitPg0->PhyData[ii].DiscoveryStatus)));
+		dsasprintk(("\n"));
+/* EDM : debug data */
+
+		/* PHY stuff. */
+		karg.Information.Phy[ii].bPortIdentifier =
+		    sasIoUnitPg0->PhyData[ii].Port;
+
+		/* Get the negotiated link rate for the phy. */
+		switch (sasIoUnitPg0->PhyData[ii].NegotiatedLinkRate) {
+
+		case MPI_SAS_IOUNIT0_RATE_PHY_DISABLED:
+			karg.Information.Phy[ii].bNegotiatedLinkRate =
+			    CSMI_SAS_PHY_DISABLED;
+			break;
+
+		case MPI_SAS_IOUNIT0_RATE_FAILED_SPEED_NEGOTIATION:
+			karg.Information.Phy[ii].bNegotiatedLinkRate =
+			    CSMI_SAS_LINK_RATE_FAILED;
+			break;
+
+		case MPI_SAS_IOUNIT0_RATE_SATA_OOB_COMPLETE:
+			break;
+
+		case MPI_SAS_IOUNIT0_RATE_1_5:
+			karg.Information.Phy[ii].bNegotiatedLinkRate =
+			    CSMI_SAS_LINK_RATE_1_5_GBPS;
+			break;
+
+		case MPI_SAS_IOUNIT0_RATE_3_0:
+			karg.Information.Phy[ii].bNegotiatedLinkRate =
+			    CSMI_SAS_LINK_RATE_3_0_GBPS;
+			break;
+
+		case MPI_SAS_IOUNIT0_RATE_UNKNOWN:
+		default:
+			karg.Information.Phy[ii].bNegotiatedLinkRate =
+			    CSMI_SAS_LINK_RATE_UNKNOWN;
+			break;
+		}
+
+		if (sasIoUnitPg0->PhyData[ii].PortFlags &
+		    MPI_SAS_IOUNIT0_PORT_FLAGS_DISCOVERY_IN_PROGRESS) {
+			karg.Information.Phy[ii].bAutoDiscover =
+			    CSMI_SAS_DISCOVER_IN_PROGRESS;
+		} else {
+			karg.Information.Phy[ii].bAutoDiscover =
+			    CSMI_SAS_DISCOVER_COMPLETE;
+		}
+
+		/* Issue a config request to get
+		 * phy information.
+		 */
+		hdr.PageVersion = MPI_SASPHY0_PAGEVERSION;
+		hdr.ExtPageLength = 0;
+		hdr.PageNumber = 0;
+		hdr.Reserved1 = 0;
+		hdr.Reserved2 = 0;
+		hdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;
+		hdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_PHY;
+
+		cfg.cfghdr.ehdr = &hdr;
+		cfg.physAddr = -1;
+		cfg.pageAddr = ii;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+		cfg.dir = 0;	/* read */
+		cfg.timeout = 10;
+
+		if ((rc = mpt_config(ioc, &cfg)) != 0) {
+			dctlprintk((
+			    ": FAILED: MPI_SASPHY0_PAGEVERSION: HEADER\n"));
+			dctlprintk((": rc=%x\n",rc));
+			karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+			goto sas_get_phy_info_exit;
+		}
+
+		if (hdr.ExtPageLength == 0) {
+			dctlprintk((": pci_alloc_consistent: FAILED\n"));
+			karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+			goto sas_get_phy_info_exit;
+		}
+
+		sasPhyPg0_data_sz = hdr.ExtPageLength * 4;
+		rc = -ENOMEM;
+
+		sasPhyPg0 = (SasPhyPage0_t *) pci_alloc_consistent(
+		    ioc->pcidev, sasPhyPg0_data_sz, &sasPhyPg0_dma);
+
+		if (! sasPhyPg0) {
+			dctlprintk((": pci_alloc_consistent: FAILED\n"));
+			karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+			goto sas_get_phy_info_exit;
+		}
+
+		memset((u8 *)sasPhyPg0, 0, sasPhyPg0_data_sz);
+		cfg.physAddr = sasPhyPg0_dma;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+		if ((rc = mpt_config(ioc, &cfg)) != 0) {
+			dctlprintk((
+			    ": FAILED: MPI_SASPHY0_PAGEVERSION: PAGE\n"));
+			dctlprintk((": rc=%x\n",rc));
+			karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+			pci_free_consistent(ioc->pcidev, sasPhyPg0_data_sz,
+			    (u8 *) sasPhyPg0, sasPhyPg0_dma);
+			goto sas_get_phy_info_exit;
+		}
+
+		le64_to_cpus((u64 *)&sasPhyPg0->SASAddress);
+		memcpy(&SASAddress64, &sasPhyPg0->SASAddress, sizeof(u64));
+
+/* EDM : dump PHY Page 0 data*/
+		dsasprintk(("---- SAS PHY PAGE 0 ------------\n"));
+		dsasprintk(("Handle=0x%X\n",
+		    le16_to_cpu(sasPhyPg0->AttachedDevHandle)));
+		dsasprintk(("SAS Address=0x%llX\n",SASAddress64));
+		dsasprintk(("Attached PHY Identifier=0x%X\n",
+		    sasPhyPg0->AttachedPhyIdentifier));
+		dsasprintk(("Attached Device Info=0x%X\n",
+		    le32_to_cpu(sasPhyPg0->AttachedDeviceInfo)));
+		dsasprintk(("Programmed Link Rate=0x%X\n",
+		    sasPhyPg0->ProgrammedLinkRate));
+		dsasprintk(("Hardware Link Rate=0x%X\n",
+		    ioc->sasPhyInfo[ii].hwLinkRate));
+		dsasprintk(("Change Count=0x%X\n",
+		    sasPhyPg0->ChangeCount));
+		dsasprintk(("PHY Info=0x%X\n",
+		    le32_to_cpu(sasPhyPg0->PhyInfo)));
+		dsasprintk(("\n"));
+/* EDM : debug data */
+
+		/* save the data */
+
+		/* Set Max hardware link rate.
+		 * This value is hard coded
+		 * because the HW link rate
+		 * is currently being
+		 * overwritten in FW.
+		 */
+
+		/* Set Max hardware link rate. */
+		switch (sasPhyPg0->HwLinkRate &
+		    MPI_SAS_PHY0_PRATE_MAX_RATE_MASK) {
+
+		case MPI_SAS_PHY0_HWRATE_MAX_RATE_1_5:
+			karg.Information.Phy[ii].bMaximumLinkRate =
+			    CSMI_SAS_LINK_RATE_1_5_GBPS;
+			break;
+
+		case MPI_SAS_PHY0_PRATE_MAX_RATE_3_0:
+			karg.Information.Phy[ii].bMaximumLinkRate =
+			    CSMI_SAS_LINK_RATE_3_0_GBPS;
+			break;
+		default:
+			break;
+		}
+
+		/* Set Max programmed link rate. */
+		switch (sasPhyPg0->ProgrammedLinkRate &
+		    MPI_SAS_PHY0_PRATE_MAX_RATE_MASK) {
+
+		case MPI_SAS_PHY0_PRATE_MAX_RATE_1_5:
+			karg.Information.Phy[ii].bMaximumLinkRate |=
+			    (CSMI_SAS_PROGRAMMED_LINK_RATE_1_5_GBPS << 4);
+			break;
+
+		case MPI_SAS_PHY0_PRATE_MAX_RATE_3_0:
+			karg.Information.Phy[ii].bMaximumLinkRate |=
+			    (CSMI_SAS_PROGRAMMED_LINK_RATE_3_0_GBPS << 4);
+			break;
+		default:
+			break;
+		}
+
+		/* Set Min hardware link rate. */
+		switch (sasPhyPg0->HwLinkRate &
+		    MPI_SAS_PHY0_HWRATE_MIN_RATE_MASK) {
+
+		case MPI_SAS_PHY0_HWRATE_MIN_RATE_1_5:
+			karg.Information.Phy[ii].bMinimumLinkRate =
+			    CSMI_SAS_LINK_RATE_1_5_GBPS;
+			break;
+
+		case MPI_SAS_PHY0_PRATE_MIN_RATE_3_0:
+			karg.Information.Phy[ii].bMinimumLinkRate =
+			    CSMI_SAS_LINK_RATE_3_0_GBPS;
+			break;
+		default:
+			break;
+		}
+
+		/* Set Min programmed link rate. */
+		switch (sasPhyPg0->ProgrammedLinkRate &
+		    MPI_SAS_PHY0_PRATE_MIN_RATE_MASK) {
+
+		case MPI_SAS_PHY0_PRATE_MIN_RATE_1_5:
+			karg.Information.Phy[ii].bMinimumLinkRate |=
+			    (CSMI_SAS_PROGRAMMED_LINK_RATE_1_5_GBPS << 4);
+			break;
+
+		case MPI_SAS_PHY0_PRATE_MIN_RATE_3_0:
+			karg.Information.Phy[ii].bMinimumLinkRate |=
+			    (CSMI_SAS_PROGRAMMED_LINK_RATE_3_0_GBPS << 4);
+			break;
+		default:
+			break;
+		}
+
+		/* Fill in Attached Device
+		 * Initiator Port Protocol.
+		 * Bits 6:3
+		 * More than one bit can be set.
+		 */
+		protocol = sasPhyPg0->AttachedDeviceInfo & 0x78;
+		karg.Information.Phy[ii].Attached.bInitiatorPortProtocol = 0;
+		if (protocol & MPI_SAS_DEVICE_INFO_SSP_INITIATOR)
+		      karg.Information.Phy[ii].Attached.bInitiatorPortProtocol =
+			    CSMI_SAS_PROTOCOL_SSP;
+		if (protocol & MPI_SAS_DEVICE_INFO_STP_INITIATOR)
+		     karg.Information.Phy[ii].Attached.bInitiatorPortProtocol |=
+			    CSMI_SAS_PROTOCOL_STP;
+		if (protocol & MPI_SAS_DEVICE_INFO_SMP_INITIATOR)
+		     karg.Information.Phy[ii].Attached.bInitiatorPortProtocol |=
+			    CSMI_SAS_PROTOCOL_SMP;
+		if (protocol & MPI_SAS_DEVICE_INFO_SATA_HOST)
+		     karg.Information.Phy[ii].Attached.bInitiatorPortProtocol |=
+			    CSMI_SAS_PROTOCOL_SATA;
+
+
+		/* Fill in Phy Target Port
+		 * Protocol. Bits 10:7
+		 * More than one bit can be set.
+		 */
+		protocol = sasPhyPg0->AttachedDeviceInfo & 0x780;
+		karg.Information.Phy[ii].Attached.bTargetPortProtocol = 0;
+		if (protocol & MPI_SAS_DEVICE_INFO_SSP_TARGET)
+			karg.Information.Phy[ii].Attached.bTargetPortProtocol |=
+			    CSMI_SAS_PROTOCOL_SSP;
+		if (protocol & MPI_SAS_DEVICE_INFO_STP_TARGET)
+			karg.Information.Phy[ii].Attached.bTargetPortProtocol |=
+			    CSMI_SAS_PROTOCOL_STP;
+		if (protocol & MPI_SAS_DEVICE_INFO_SMP_TARGET)
+			karg.Information.Phy[ii].Attached.bTargetPortProtocol |=
+			    CSMI_SAS_PROTOCOL_SMP;
+		if (protocol & MPI_SAS_DEVICE_INFO_SATA_DEVICE)
+			karg.Information.Phy[ii].Attached.bTargetPortProtocol |=
+			    CSMI_SAS_PROTOCOL_SATA;
+
+
+		/* Fill in Attached device type */
+		switch (sasIoUnitPg0->PhyData[ii].ControllerPhyDeviceInfo &
+		    MPI_SAS_DEVICE_INFO_MASK_DEVICE_TYPE) {
+
+		case MPI_SAS_DEVICE_INFO_NO_DEVICE:
+			karg.Information.Phy[ii].Attached.bDeviceType =
+			    CSMI_SAS_NO_DEVICE_ATTACHED;
+			break;
+
+		case MPI_SAS_DEVICE_INFO_END_DEVICE:
+			karg.Information.Phy[ii].Attached.bDeviceType =
+			    CSMI_SAS_END_DEVICE;
+			break;
+
+		case MPI_SAS_DEVICE_INFO_EDGE_EXPANDER:
+			karg.Information.Phy[ii].Attached.bDeviceType =
+			    CSMI_SAS_EDGE_EXPANDER_DEVICE;
+			break;
+
+		case MPI_SAS_DEVICE_INFO_FANOUT_EXPANDER:
+			karg.Information.Phy[ii].Attached.bDeviceType =
+			    CSMI_SAS_FANOUT_EXPANDER_DEVICE;
+			break;
+		}
+
+		/* Identify Info. */
+		karg.Information.Phy[ii].Identify.bDeviceType =
+		    CSMI_SAS_END_DEVICE;
+
+		/* Fill in Phy Initiator Port Protocol. Bits 6:3
+		 * More than one bit can be set, fall through cases.
+		 */
+		protocol = sasIoUnitPg0->PhyData[ii].ControllerPhyDeviceInfo
+		    & 0x78;
+		karg.Information.Phy[ii].Identify.bInitiatorPortProtocol = 0;
+		if( protocol & MPI_SAS_DEVICE_INFO_SSP_INITIATOR )
+		     karg.Information.Phy[ii].Identify.bInitiatorPortProtocol |=
+			    CSMI_SAS_PROTOCOL_SSP;
+		if( protocol & MPI_SAS_DEVICE_INFO_STP_INITIATOR )
+		     karg.Information.Phy[ii].Identify.bInitiatorPortProtocol |=
+			    CSMI_SAS_PROTOCOL_STP;
+		if( protocol & MPI_SAS_DEVICE_INFO_SMP_INITIATOR )
+		     karg.Information.Phy[ii].Identify.bInitiatorPortProtocol |=
+			    CSMI_SAS_PROTOCOL_SMP;
+		if( protocol & MPI_SAS_DEVICE_INFO_SATA_HOST )
+		     karg.Information.Phy[ii].Identify.bInitiatorPortProtocol |=
+			    CSMI_SAS_PROTOCOL_SATA;
+
+		/* Fill in Phy Target Port Protocol. Bits 10:7
+		 * More than one bit can be set, fall through cases.
+		 */
+		protocol = sasIoUnitPg0->PhyData[ii].ControllerPhyDeviceInfo
+		    & 0x780;
+		karg.Information.Phy[ii].Identify.bTargetPortProtocol = 0;
+		if( protocol & MPI_SAS_DEVICE_INFO_SSP_TARGET )
+			karg.Information.Phy[ii].Identify.bTargetPortProtocol |=
+			    CSMI_SAS_PROTOCOL_SSP;
+		if( protocol & MPI_SAS_DEVICE_INFO_STP_TARGET )
+			karg.Information.Phy[ii].Identify.bTargetPortProtocol |=
+			    CSMI_SAS_PROTOCOL_STP;
+		if( protocol & MPI_SAS_DEVICE_INFO_SMP_TARGET )
+			karg.Information.Phy[ii].Identify.bTargetPortProtocol |=
+			    CSMI_SAS_PROTOCOL_SMP;
+		if( protocol & MPI_SAS_DEVICE_INFO_SATA_DEVICE )
+			karg.Information.Phy[ii].Identify.bTargetPortProtocol |=
+			    CSMI_SAS_PROTOCOL_SATA;
+
+
+		/* Setup Identify SAS Address and Phy Identifier
+		 *
+		 * Get phy Sas address from device list.
+		 * Search the list for the matching
+		 * devHandle.
+		 */
+
+		/* Setup SAS Address for the Phy */
+		SASAddress64 = reverse_byte_order64((u64 *)&ioc->sasPhyInfo[ii].SASAddress);
+		memcpy(karg.Information.Phy[ii].Identify.bSASAddress,&SASAddress64,
+		    sizeof(u64));
+
+		karg.Information.Phy[ii].Identify.bPhyIdentifier = ii;
+
+		/* Setup SAS Address for the attached device */
+		SASAddress64 = reverse_byte_order64((u64 *)&sasPhyPg0->SASAddress);
+		memcpy(karg.Information.Phy[ii].Attached.bSASAddress,&SASAddress64,
+		    sizeof(u64));
+
+		karg.Information.Phy[ii].Attached.bPhyIdentifier =
+		    sasPhyPg0->AttachedPhyIdentifier;
+
+		pci_free_consistent(ioc->pcidev, sasPhyPg0_data_sz,
+		    (u8 *) sasPhyPg0, sasPhyPg0_dma);
+	}
+
+sas_get_phy_info_exit:
+
+	if (sasIoUnitPg0)
+		pci_free_consistent(ioc->pcidev, sasIoUnitPg0_data_sz,
+		    (u8 *) sasIoUnitPg0, sasIoUnitPg0_dma);
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+	    sizeof(CSMI_SAS_PHY_INFO_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s - "
+		    "Unable to write out csmi_sas_get_phy_info_buffer @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Prototype Routine for the HP CSMI SAS Set PHY Info command.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int
+mptctl_csmi_sas_set_phy_info(unsigned long arg)
+{
+	CSMI_SAS_SET_PHY_INFO_BUFFER *uarg = (void *) arg;
+	CSMI_SAS_SET_PHY_INFO_BUFFER	 karg;
+	MPT_ADAPTER			*ioc = NULL;
+	int				iocnum;
+
+	dctlprintk((": %s called.\n",__FUNCTION__));
+
+	if (copy_from_user(&karg, uarg, sizeof(CSMI_SAS_SET_PHY_INFO_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+		    "Unable to read in csmi_sas_set_phy_info struct @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
+	    &ioc)) < 0) || (ioc == NULL)) {
+		dctlprintk((KERN_ERR
+		"%s::%s() @%d - ioc%d not found!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	if (!mptctl_is_this_sas_cntr(ioc)) {
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - ioc%d not SAS controller!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+/* TODO - implement IOCTL here */
+	karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+	dctlprintk((": not implemented\n"));
+
+// cim_set_phy_info_exit:
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+				sizeof(CSMI_SAS_SET_PHY_INFO_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+			"Unable to write out csmi_sas_set_phy_info @ %p\n",
+				__FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Prototype Routine for the HP CSMI Sas Get SCSI Address command.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int
+mptctl_csmi_sas_get_scsi_address(unsigned long arg)
+{
+	CSMI_SAS_GET_SCSI_ADDRESS_BUFFER *uarg = (void *) arg;
+	CSMI_SAS_GET_SCSI_ADDRESS_BUFFER	 karg;
+	MPT_ADAPTER		*ioc = NULL;
+	int			iocnum;
+	sas_device_info_t	*sasDevice;
+	u64			SASAddress64;
+
+	dctlprintk((": %s called.\n",__FUNCTION__));
+
+	if (copy_from_user(&karg, uarg,
+	    sizeof(CSMI_SAS_GET_SCSI_ADDRESS_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+		    "Unable to read in csmi_sas_get_scsi_address struct @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
+	    &ioc)) < 0) || (ioc == NULL)) {
+		dctlprintk((KERN_ERR
+	      "%s::%s() @%d - ioc%d not found!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	if (!mptctl_is_this_sas_cntr(ioc)) {
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - ioc%d not SAS controller!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	/* Fill in the data and return the structure to the calling
+	 * program
+	 */
+
+	/* Copy the SAS address in reverse byte order. */
+	SASAddress64 = reverse_byte_order64((u64 *)&karg.bSASAddress);
+
+	/* Search the list for the matching SAS address. */
+	karg.IoctlHeader.ReturnCode = CSMI_SAS_NO_SCSI_ADDRESS;
+	list_for_each_entry(sasDevice, &ioc->sasDeviceList, list) {
+
+		/* Found the matching device. */
+		if ((memcmp(&sasDevice->SASAddress,
+		    &SASAddress64, sizeof(u64)) != 0))
+			continue;
+
+		karg.bPathId = sasDevice->Bus;
+		karg.bTargetId = sasDevice->TargetId;
+		karg.bLun = karg.bSASLun[0];
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_SUCCESS;
+
+		if (((sasDevice->deviceInfo & 0x00000003) ==
+			MPI_SAS_DEVICE_INFO_FANOUT_EXPANDER) ||
+			((sasDevice->deviceInfo & 0x00000003) ==
+			 MPI_SAS_DEVICE_INFO_EDGE_EXPANDER))
+			karg.IoctlHeader.ReturnCode =
+			    CSMI_SAS_NOT_AN_END_DEVICE;
+		break;
+	}
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+	    sizeof(CSMI_SAS_GET_SCSI_ADDRESS_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+		    "Unable to write out csmi_sas_get_scsi_address @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Prototype Routine for the HP CSMI Sas Get SCSI Address command.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int
+mptctl_csmi_sas_get_sata_signature(unsigned long arg)
+{
+	CSMI_SAS_SATA_SIGNATURE_BUFFER  *uarg = (void *) arg;
+	CSMI_SAS_SATA_SIGNATURE_BUFFER	 karg;
+	MPT_ADAPTER			*ioc = NULL;
+	int				iocnum;
+	int				rc, jj;
+	ConfigExtendedPageHeader_t	hdr;
+	CONFIGPARMS			cfg;
+	SasPhyPage0_t			*sasPhyPg0;
+	dma_addr_t			sasPhyPg0_dma;
+	int				sasPhyPg0_data_sz;
+	SasDevicePage1_t		*sasDevicePg1;
+	dma_addr_t			sasDevicePg1_dma;
+	int				sasDevicePg1_data_sz;
+	u8				phyId;
+
+	dctlprintk((": %s called.\n",__FUNCTION__));
+	sasPhyPg0=NULL;
+	sasPhyPg0_data_sz=0;
+	sasDevicePg1=NULL;
+	sasDevicePg1_data_sz=0;
+
+	if (copy_from_user(&karg, uarg,
+	     sizeof(CSMI_SAS_SATA_SIGNATURE_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+		    "Unable to read in csmi_sas_sata_signature struct @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
+	    &ioc)) < 0) || (ioc == NULL)) {
+		dctlprintk((KERN_ERR
+	    "%s::%s() @%d - ioc%d not found!\n",
+		     __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	if (!mptctl_is_this_sas_cntr(ioc)) {
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - ioc%d not SAS controller!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	phyId = karg.Signature.bPhyIdentifier;
+	if (phyId >= ioc->numPhys) {
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_PHY_DOES_NOT_EXIST;
+		dctlprintk((": phyId >= ioc->numPhys\n"));
+		goto cim_sata_signature_exit;
+	}
+
+	/* Default to success.*/
+	karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_SUCCESS;
+
+	/* Issue a config request to get the devHandle of the attached device
+	 */
+
+	/* Issue a config request to get phy information. */
+	hdr.PageVersion = MPI_SASPHY0_PAGEVERSION;
+	hdr.ExtPageLength = 0;
+	hdr.PageNumber = 0;
+	hdr.Reserved1 = 0;
+	hdr.Reserved2 = 0;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;
+	hdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_PHY;
+
+	cfg.cfghdr.ehdr = &hdr;
+	cfg.physAddr = -1;
+	cfg.pageAddr = phyId;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;	/* read */
+	cfg.timeout = 10;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0) {
+		/* Don't check if this failed.  Already in a
+		 * failure case.
+		 */
+		dctlprintk((": FAILED: MPI_SASPHY0_PAGEVERSION: HEADER\n"));
+		dctlprintk((": rc=%x\n",rc));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_sata_signature_exit;
+	}
+
+	if (hdr.ExtPageLength == 0) {
+		/* Don't check if this failed.  Already in a
+		 * failure case.
+		 */
+		dctlprintk((": hdr.ExtPageLength == 0\n"));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_sata_signature_exit;
+	}
+
+
+	sasPhyPg0_data_sz = hdr.ExtPageLength * 4;
+	rc = -ENOMEM;
+
+	sasPhyPg0 = (SasPhyPage0_t *) pci_alloc_consistent(ioc->pcidev,
+	    sasPhyPg0_data_sz, &sasPhyPg0_dma);
+
+	if (! sasPhyPg0) {
+		dctlprintk((": pci_alloc_consistent: FAILED\n"));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_sata_signature_exit;
+	}
+
+	memset((u8 *)sasPhyPg0, 0, sasPhyPg0_data_sz);
+	cfg.physAddr = sasPhyPg0_dma;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0) {
+		/* Don't check if this failed.  Already in a
+		 * failure case.
+		 */
+		dctlprintk((": FAILED: MPI_SASPHY0_PAGEVERSION: PAGE\n"));
+		dctlprintk((": rc=%x\n",rc));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_sata_signature_exit;
+	}
+
+	/* Make sure a SATA device is attached. */
+	if ((sasPhyPg0->AttachedDeviceInfo &
+	    MPI_SAS_DEVICE_INFO_SATA_DEVICE) == 0) {
+		dctlprintk((": NOT A SATA DEVICE\n"));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_NO_SATA_DEVICE;
+		goto cim_sata_signature_exit;
+	}
+
+	/* Get device page 1 for FIS  signature. */
+	hdr.PageVersion = MPI_SASDEVICE1_PAGEVERSION;
+	hdr.ExtPageLength = 0;
+	hdr.PageNumber = 1 /* page number 1 */;
+	hdr.Reserved1 = 0;
+	hdr.Reserved2 = 0;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;
+	hdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_DEVICE;
+
+	cfg.cfghdr.ehdr = &hdr;
+	cfg.physAddr = -1;
+
+	cfg.pageAddr = ((MPI_SAS_DEVICE_PGAD_FORM_HANDLE <<
+	    MPI_SAS_DEVICE_PGAD_FORM_SHIFT) |
+	    sasPhyPg0->AttachedDevHandle);
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;	/* read */
+	cfg.timeout = 10;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0) {
+		dctlprintk((": FAILED: MPI_SASDEVICE1_PAGEVERSION: HEADER\n"));
+		dctlprintk((": rc=%x\n",rc));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_sata_signature_exit;
+	}
+
+	if (hdr.ExtPageLength == 0) {
+		dctlprintk((": hdr.ExtPageLength == 0\n"));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_sata_signature_exit;
+	}
+
+	sasDevicePg1_data_sz = hdr.ExtPageLength * 4;
+	rc = -ENOMEM;
+
+	sasDevicePg1 = (SasDevicePage1_t *) pci_alloc_consistent
+	    (ioc->pcidev, sasDevicePg1_data_sz, &sasDevicePg1_dma);
+
+	if (! sasDevicePg1) {
+		dctlprintk((": pci_alloc_consistent: FAILED\n"));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_sata_signature_exit;
+	}
+
+	memset((u8 *)sasDevicePg1, 0, sasDevicePg1_data_sz);
+	cfg.physAddr = sasDevicePg1_dma;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0) {
+		dctlprintk((": FAILED: MPI_SASDEVICE1_PAGEVERSION: PAGE\n"));
+		dctlprintk((": rc=%x\n",rc));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_sata_signature_exit;
+	}
+
+/* EDM : dump Device Page 1 data*/
+	dsasprintk(("---- SAS DEVICE PAGE 1 ---------\n"));
+	dsasprintk(("Handle=0x%x\n",sasDevicePg1->DevHandle));
+	dsasprintk(("SAS Address="));
+	for(jj=0;jj<8;jj++)
+		dsasprintk(("%02x ",
+		((u8 *)&sasDevicePg1->SASAddress)[jj]));
+	dsasprintk(("\n"));
+	dsasprintk(("Target ID=0x%x\n",sasDevicePg1->TargetID));
+	dsasprintk(("Bus=0x%x\n",sasDevicePg1->Bus));
+	dsasprintk(("Initial Reg Device FIS="));
+	for(jj=0;jj<20;jj++)
+		dsasprintk(("%02x ",
+		((u8 *)&sasDevicePg1->InitialRegDeviceFIS)[jj]));
+	dsasprintk(("\n\n"));
+/* EDM : debug data */
+
+	memcpy(karg.Signature.bSignatureFIS,
+		sasDevicePg1->InitialRegDeviceFIS,20);
+
+cim_sata_signature_exit:
+
+	if (sasPhyPg0)
+		pci_free_consistent(ioc->pcidev, sasPhyPg0_data_sz,
+		    (u8 *) sasPhyPg0, sasPhyPg0_dma);
+
+	if (sasDevicePg1)
+		pci_free_consistent(ioc->pcidev, sasDevicePg1_data_sz,
+		    (u8 *) sasDevicePg1, sasDevicePg1_dma);
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+	    sizeof(CSMI_SAS_SATA_SIGNATURE_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+		    "Unable to write out csmi_sas_get_device_address @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Prototype Routine for the HP CSMI Sas Get SCSI Address command.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int
+mptctl_csmi_sas_get_device_address(unsigned long arg)
+{
+	CSMI_SAS_GET_DEVICE_ADDRESS_BUFFER *uarg = (void *) arg;
+	CSMI_SAS_GET_DEVICE_ADDRESS_BUFFER	 karg;
+	MPT_ADAPTER		*ioc = NULL;
+	int			iocnum;
+	sas_device_info_t	*sasDevice;
+	u64			SASAddress64;
+
+	dctlprintk((": %s called.\n",__FUNCTION__));
+
+	if (copy_from_user(&karg, uarg,
+	    sizeof(CSMI_SAS_GET_DEVICE_ADDRESS_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+	   "Unable to read in csmi_sas_get_device_address_buffer struct @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
+	    &ioc)) < 0) || (ioc == NULL)) {
+		dctlprintk((KERN_ERR
+	    "%s::%s() @%d - ioc%d not found!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	if (!mptctl_is_this_sas_cntr(ioc)) {
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - ioc%d not SAS controller!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	/* Fill in the data and return the structure to the calling
+	 * program
+	 */
+
+	/* Search the list for the matching SAS address. */
+	karg.IoctlHeader.ReturnCode = CSMI_SAS_NO_DEVICE_ADDRESS;
+	list_for_each_entry(sasDevice, &ioc->sasDeviceList, list) {
+
+		/* Find the matching device. */
+		if ((karg.bPathId == sasDevice->Bus) &&
+			(karg.bTargetId == sasDevice->TargetId)) {
+
+			SASAddress64 = reverse_byte_order64(&sasDevice->SASAddress);
+			memcpy(&karg.bSASAddress,&SASAddress64,sizeof(u64));
+			karg.bSASLun[0] = karg.bLun;
+			memset(karg.bSASLun, 0, sizeof(karg.bSASLun));
+			karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_SUCCESS;
+			break;
+		} else
+			/* Keep looking. */
+			continue;
+	}
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+	    sizeof(CSMI_SAS_GET_DEVICE_ADDRESS_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+		"Unable to write out csmi_sas_get_device_address_buffer @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Prototype Routine for the HP CSMI Sas Get Link Errors command.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int
+mptctl_csmi_sas_get_link_errors(unsigned long arg)
+{
+	CSMI_SAS_LINK_ERRORS_BUFFER *uarg = (void *) arg;
+	CSMI_SAS_LINK_ERRORS_BUFFER	 karg;
+	MPT_ADAPTER			*ioc = NULL;
+	MPT_FRAME_HDR			*mf = NULL;
+	MPIHeader_t			*mpi_hdr;
+	int				iocnum;
+	int				rc;
+	ConfigExtendedPageHeader_t	hdr;
+	CONFIGPARMS			cfg;
+	SasPhyPage1_t			*sasPhyPage1;
+	dma_addr_t			sasPhyPage1_dma;
+	int				sasPhyPage1_data_sz;
+	SasIoUnitControlRequest_t	*sasIoUnitCntrReq;
+	SasIoUnitControlReply_t		*sasIoUnitCntrReply;
+	u8				phyId;
+
+	dctlprintk((": %s called.\n",__FUNCTION__));
+	sasPhyPage1=NULL;
+	sasPhyPage1_data_sz=0;
+
+	if (copy_from_user(&karg, uarg,
+	     sizeof(CSMI_SAS_LINK_ERRORS_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+		    "Unable to read in mptctl_csmi_sas_get_link_errors struct @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
+	    &ioc)) < 0) || (ioc == NULL)) {
+		dctlprintk((KERN_ERR
+	    "%s::%s() @%d - ioc%d not found!\n",
+		     __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	if (!mptctl_is_this_sas_cntr(ioc)) {
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - ioc%d not SAS controller!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	phyId = karg.Information.bPhyIdentifier;
+	if (phyId >= ioc->numPhys) {
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_PHY_DOES_NOT_EXIST;
+		dctlprintk((": phyId >= ioc->numPhys\n"));
+		goto cim_get_link_errors_exit;
+	}
+
+	/* Default to success.*/
+	karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_SUCCESS;
+
+	/* Issue a config request to get the devHandle of the attached device
+	 */
+
+	/* Issue a config request to get phy information. */
+	hdr.PageVersion = MPI_SASPHY1_PAGEVERSION;
+	hdr.ExtPageLength = 0;
+	hdr.PageNumber = 1 /* page number 1*/;
+	hdr.Reserved1 = 0;
+	hdr.Reserved2 = 0;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;
+	hdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_PHY;
+
+	cfg.cfghdr.ehdr = &hdr;
+	cfg.physAddr = -1;
+	cfg.pageAddr = phyId;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;	/* read */
+	cfg.timeout = 10;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0) {
+		/* Don't check if this failed.  Already in a
+		 * failure case.
+		 */
+		dctlprintk((": FAILED: MPI_SASPHY1_PAGEVERSION: HEADER\n"));
+		dctlprintk((": rc=%x\n",rc));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_get_link_errors_exit;
+	}
+
+	if (hdr.ExtPageLength == 0) {
+		/* Don't check if this failed.  Already in a
+		 * failure case.
+		 */
+		dctlprintk((": hdr.ExtPageLength == 0\n"));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_get_link_errors_exit;
+	}
+
+
+	sasPhyPage1_data_sz = hdr.ExtPageLength * 4;
+	rc = -ENOMEM;
+
+	sasPhyPage1 = (SasPhyPage1_t *) pci_alloc_consistent(ioc->pcidev,
+	    sasPhyPage1_data_sz, &sasPhyPage1_dma);
+
+	if (! sasPhyPage1) {
+		dctlprintk((": pci_alloc_consistent: FAILED\n"));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_get_link_errors_exit;
+	}
+
+	memset((u8 *)sasPhyPage1, 0, sasPhyPage1_data_sz);
+	cfg.physAddr = sasPhyPage1_dma;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0) {
+		/* Don't check if this failed.  Already in a
+		 * failure case.
+		 */
+		dctlprintk((": FAILED: MPI_SASPHY1_PAGEVERSION: PAGE\n"));
+		dctlprintk((": rc=%x\n",rc));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_get_link_errors_exit;
+	}
+
+/* EDM : dump PHY Page 1 data*/
+	dsasprintk(("---- SAS PHY PAGE 1 ------------\n"));
+	dsasprintk(("Invalid Dword Count=0x%x\n",
+	    sasPhyPage1->InvalidDwordCount));
+	dsasprintk(("Running Disparity Error Count=0x%x\n",
+	    sasPhyPage1->RunningDisparityErrorCount));
+	dsasprintk(("Loss Dword Synch Count=0x%x\n",
+	    sasPhyPage1->LossDwordSynchCount));
+	dsasprintk(("PHY Reset Problem Count=0x%x\n",
+	    sasPhyPage1->PhyResetProblemCount));
+	dsasprintk(("\n\n"));
+/* EDM : debug data */
+
+	karg.Information.uInvalidDwordCount =
+		sasPhyPage1->InvalidDwordCount;
+	karg.Information.uRunningDisparityErrorCount =
+		sasPhyPage1->RunningDisparityErrorCount;
+	karg.Information.uLossOfDwordSyncCount =
+		sasPhyPage1->LossDwordSynchCount;
+	karg.Information.uPhyResetProblemCount =
+		sasPhyPage1->PhyResetProblemCount;
+
+	if (karg.Information.bResetCounts ==
+	    CSMI_SAS_LINK_ERROR_DONT_RESET_COUNTS ) {
+		goto cim_get_link_errors_exit;
+	}
+
+	/* Clear Error log
+	 *
+	 * Issue IOUNIT Control Reqeust Message
+	 */
+
+	/* Get a MF for this command.
+	 */
+	if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL) {
+		dctlprintk((": no msg frames!\n"));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_get_link_errors_exit;
+        }
+
+	mpi_hdr = (MPIHeader_t *) mf;
+	sasIoUnitCntrReq = (SasIoUnitControlRequest_t *)mf;
+	memset(sasIoUnitCntrReq,0,sizeof(SasIoUnitControlRequest_t));
+	sasIoUnitCntrReq->Function = MPI_FUNCTION_SAS_IO_UNIT_CONTROL;
+	sasIoUnitCntrReq->MsgContext =
+	    cpu_to_le32(le32_to_cpu(mpi_hdr->MsgContext));
+	sasIoUnitCntrReq->PhyNum = phyId;
+	sasIoUnitCntrReq->Operation = MPI_SAS_OP_PHY_CLEAR_ERROR_LOG;
+
+
+	ioc->ioctl->timer.expires =
+	    jiffies + HZ*MPT_IOCTL_DEFAULT_TIMEOUT /* 10 sec */;
+	ioc->ioctl->wait_done = 0;
+	ioc->ioctl->status |= MPT_IOCTL_STATUS_TIMER_ACTIVE;
+	add_timer(&ioc->ioctl->timer);
+	mpt_put_msg_frame(mptctl_id, ioc, mf);
+	wait_event(mptctl_wait, ioc->ioctl->wait_done);
+
+	/* process the completed Reply Message Frame */
+	if (ioc->ioctl->status & MPT_IOCTL_STATUS_RF_VALID) {
+
+		sasIoUnitCntrReply =
+		    (SasIoUnitControlReply_t *)ioc->ioctl->ReplyFrame;
+
+		if ( sasIoUnitCntrReply->IOCStatus != MPI_IOCSTATUS_SUCCESS) {
+			dctlprintk((": SAS IO Unit Control: "));
+			dctlprintk(("IOCStatus=0x%X IOCLogInfo=0x%X\n",
+			    sasIoUnitCntrReply->IOCStatus,
+			    sasIoUnitCntrReply->IOCLogInfo));
+		}
+	}
+
+cim_get_link_errors_exit:
+
+	ioc->ioctl->status &= ~(MPT_IOCTL_STATUS_TM_FAILED |
+	    MPT_IOCTL_STATUS_COMMAND_GOOD | MPT_IOCTL_STATUS_SENSE_VALID |
+	    MPT_IOCTL_STATUS_RF_VALID);
+
+	if (sasPhyPage1)
+		pci_free_consistent(ioc->pcidev, sasPhyPage1_data_sz,
+		    (u8 *) sasPhyPage1, sasPhyPage1_dma);
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+	    sizeof(CSMI_SAS_LINK_ERRORS_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+		    "Unable to write out mptctl_csmi_sas_get_link_errors @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Prototype Routine for the HP CSMI SAS SMP Passthru command.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int
+mptctl_csmi_sas_smp_passthru(unsigned long arg)
+{
+	CSMI_SAS_SMP_PASSTHRU_BUFFER *uarg = (void *) arg;
+	MPT_ADAPTER			*ioc;
+	CSMI_SAS_SMP_PASSTHRU_BUFFER	 karg;
+	pSmpPassthroughRequest_t	smpReq;
+	pSmpPassthroughReply_t		smpReply;
+	MPT_FRAME_HDR			*mf = NULL;
+	MPIHeader_t			*mpi_hdr;
+	char				*psge;
+	int				iocnum, flagsLength;
+	u8				index;
+	void *				request_data;
+	dma_addr_t			request_data_dma;
+	u32				request_data_sz;
+	void *				response_data;
+	dma_addr_t			response_data_dma;
+	u32				response_data_sz;
+	u16				ioc_stat;
+
+	dctlprintk((": %s called.\n",__FUNCTION__));
+
+	if (copy_from_user(&karg, uarg, sizeof(CSMI_SAS_SMP_PASSTHRU_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+		    "Unable to read in csmi_sas_smp_passthru struct @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	request_data = NULL;
+	response_data = NULL;
+	response_data_sz = sizeof(CSMI_SAS_SMP_RESPONSE);
+	request_data_sz  = karg.Parameters.uRequestLength;
+
+	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
+	    &ioc)) < 0) || (ioc == NULL)) {
+		dctlprintk((KERN_ERR
+		"%s::%s() @%d - ioc%d not found!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	if (!mptctl_is_this_sas_cntr(ioc)) {
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - ioc%d not SAS controller!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	/* Make sure the adapter is not being reset. */
+	if (!ioc->ioctl) {
+		printk(KERN_ERR "%s@%d::%s - "
+		    "No memory available during driver init.\n",
+		    __FILE__, __LINE__,__FUNCTION__);
+		return -ENOMEM;
+	} else if (ioc->ioctl->status & MPT_IOCTL_STATUS_DID_IOCRESET) {
+		printk(KERN_ERR "%s@%d::%s - "
+		    "Busy with IOC Reset \n",
+		    __FILE__, __LINE__,__FUNCTION__);
+		return -EBUSY;
+	}
+
+	/* Default to success.*/
+	karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_SUCCESS;
+
+	/* Do some error checking on the request. */
+	if (karg.Parameters.bPortIdentifier == CSMI_SAS_IGNORE_PORT) {
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_SELECT_PHY_OR_PORT;
+		goto cim_smp_passthru_exit;
+	}
+
+	if ((karg.Parameters.uRequestLength > 0xFFFF) ||
+	    (!karg.Parameters.uRequestLength)) {
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_smp_passthru_exit;
+	}
+
+	/* Get a free request frame and save the message context.
+	 */
+	if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL) {
+		dctlprintk((": no msg frames!\n"));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_smp_passthru_exit;
+        }
+
+	mpi_hdr = (MPIHeader_t *) mf;
+	smpReq = (pSmpPassthroughRequest_t ) mf;
+
+	memset(smpReq,0,ioc->req_sz);
+
+	/* Fill in smp request. */
+	smpReq->PhysicalPort = karg.Parameters.bPortIdentifier;
+	smpReq->Function = MPI_FUNCTION_SMP_PASSTHROUGH;
+	smpReq->RequestDataLength =(U16)karg.Parameters.uRequestLength;
+	smpReq->ConnectionRate = karg.Parameters.bConnectionRate;
+	smpReq->MsgContext =
+	    cpu_to_le32(le32_to_cpu(mpi_hdr->MsgContext));
+	for ( index = 0; index < 8; index++ ) {
+		((u8*)&smpReq->SASAddress)[7 - index] =
+		    karg.Parameters.bDestinationSASAddress[index];
+	}
+	smpReq->Reserved2 = 0;
+	smpReq->Reserved3 = 0;
+
+	/*
+	 * Prepare the necessary pointers to run
+	 * through the SGL generation
+	 */
+
+	psge = (char *)&smpReq->SGL;
+
+	/* setup the *Request* payload SGE */
+	flagsLength = MPI_SGE_FLAGS_SIMPLE_ELEMENT |
+		MPI_SGE_FLAGS_SYSTEM_ADDRESS |
+		MPI_SGE_FLAGS_32_BIT_ADDRESSING |
+		MPI_SGE_FLAGS_HOST_TO_IOC |
+		MPI_SGE_FLAGS_END_OF_BUFFER;
+
+	if (sizeof(dma_addr_t) == sizeof(u64)) {
+		flagsLength |= MPI_SGE_FLAGS_64_BIT_ADDRESSING;
+	}
+	flagsLength = flagsLength << MPI_SGE_FLAGS_SHIFT;
+	flagsLength |= request_data_sz;
+
+	request_data = pci_alloc_consistent(
+	    ioc->pcidev, request_data_sz, &request_data_dma);
+
+	if (!request_data) {
+		dctlprintk((": pci_alloc_consistent: FAILED\n"));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		mpt_free_msg_frame(ioc, mf);
+		goto cim_smp_passthru_exit;
+	}
+
+	mpt_add_sge(psge, flagsLength, request_data_dma);
+	psge += (sizeof(u32) + sizeof(dma_addr_t));
+
+	memcpy(request_data,&karg.Parameters.Request,request_data_sz);
+
+	/* setup the *Response* payload SGE */
+	response_data = pci_alloc_consistent(
+	    ioc->pcidev, response_data_sz, &response_data_dma);
+
+	if (!response_data) {
+		dctlprintk((": pci_alloc_consistent: FAILED\n"));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		mpt_free_msg_frame(ioc, mf);
+		goto cim_smp_passthru_exit;
+	}
+
+	flagsLength = MPI_SGE_FLAGS_SIMPLE_ELEMENT |
+		MPI_SGE_FLAGS_SYSTEM_ADDRESS |
+		MPI_SGE_FLAGS_32_BIT_ADDRESSING |
+		MPI_SGE_FLAGS_IOC_TO_HOST |
+		MPI_SGE_FLAGS_END_OF_BUFFER;
+
+	if (sizeof(dma_addr_t) == sizeof(u64)) {
+		flagsLength |= MPI_SGE_FLAGS_64_BIT_ADDRESSING;
+	}
+
+	flagsLength = flagsLength << MPI_SGE_FLAGS_SHIFT;
+	flagsLength |= response_data_sz;
+
+	mpt_add_sge(psge, flagsLength, response_data_dma);
+
+	/* The request is complete. Set the timer parameters
+	 * and issue the request.
+	 */
+	ioc->ioctl->timer.expires = jiffies + HZ*MPT_IOCTL_DEFAULT_TIMEOUT;
+	ioc->ioctl->wait_done = 0;
+	ioc->ioctl->status |= MPT_IOCTL_STATUS_TIMER_ACTIVE;
+	add_timer(&ioc->ioctl->timer);
+	mpt_put_msg_frame(mptctl_id, ioc, mf);
+	wait_event(mptctl_wait, ioc->ioctl->wait_done);
+
+	if ((ioc->ioctl->status & MPT_IOCTL_STATUS_RF_VALID) == 0) {
+		dctlprintk((": SMP Passthru: oh no, there is no reply!!"));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_smp_passthru_exit;
+	}
+
+	/* process the completed Reply Message Frame */
+	smpReply = (pSmpPassthroughReply_t )ioc->ioctl->ReplyFrame;
+	ioc_stat = smpReply->IOCStatus & MPI_IOCSTATUS_MASK;
+
+	if ((ioc_stat != MPI_IOCSTATUS_SUCCESS) &&
+	    (ioc_stat != MPI_IOCSTATUS_SCSI_DATA_UNDERRUN)) {
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		dctlprintk((": SMP Passthru: "));
+		dctlprintk(("IOCStatus=0x%X IOCLogInfo=0x%X SASStatus=0x%X\n",
+		    smpReply->IOCStatus,
+		    smpReply->IOCLogInfo,
+		    smpReply->SASStatus));
+		goto cim_smp_passthru_exit;
+	}
+
+	karg.Parameters.bConnectionStatus =
+	    map_sas_status_to_csmi(smpReply->SASStatus);
+
+
+	if (smpReply->ResponseDataLength) {
+		karg.Parameters.uResponseBytes = smpReply->ResponseDataLength;
+		memcpy(&karg.Parameters.Response,
+		    response_data, smpReply->ResponseDataLength);
+	}
+
+cim_smp_passthru_exit:
+
+	ioc->ioctl->status &= ~( MPT_IOCTL_STATUS_TM_FAILED |
+	    MPT_IOCTL_STATUS_COMMAND_GOOD | MPT_IOCTL_STATUS_SENSE_VALID |
+	    MPT_IOCTL_STATUS_RF_VALID);
+
+	if (request_data)
+		pci_free_consistent(ioc->pcidev, request_data_sz,
+		    (u8 *)request_data, request_data_dma);
+
+	if (response_data)
+		pci_free_consistent(ioc->pcidev, response_data_sz,
+		    (u8 *)response_data, response_data_dma);
+
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+				sizeof(CSMI_SAS_SMP_PASSTHRU_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+			"Unable to write out csmi_sas_smp_passthru @ %p\n",
+				__FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+
+}
+
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Prototype Routine for the HP CSMI SAS SSP Passthru command.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int mptctl_csmi_sas_ssp_passthru(unsigned long arg)
+{
+	CSMI_SAS_SSP_PASSTHRU_BUFFER *uarg = (void *) arg;
+	CSMI_SAS_SSP_PASSTHRU_BUFFER	 karg;
+	MPT_ADAPTER			*ioc = NULL;
+	pSCSIIORequest_t		pScsiRequest;
+	pSCSIIOReply_t			pScsiReply;
+	MPT_FRAME_HDR			*mf = NULL;
+	MPIHeader_t 			*mpi_hdr;
+	int				iocnum,ii;
+	u32				data_sz;
+	u64				SASAddress64;
+	sas_device_info_t		*sasDevice;
+	u16				req_idx;
+	char				*psge;
+	int				flagsLength;
+	void *				request_data;
+	dma_addr_t			request_data_dma;
+	u32				request_data_sz;
+	u8				found;
+	u8				bus=0, target=0;
+	u16				ioc_stat;
+
+
+	dctlprintk((": %s called.\n",__FUNCTION__));
+
+	if (copy_from_user(&karg, uarg, sizeof(CSMI_SAS_SSP_PASSTHRU_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+		    "Unable to read in csmi_sas_ssp_passthru struct @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	request_data=NULL;
+	request_data_sz=0;
+
+	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
+	    &ioc)) < 0) || (ioc == NULL)) {
+		dctlprintk((KERN_ERR
+		"%s::%s() @%d - ioc%d not found!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	if (!mptctl_is_this_sas_cntr(ioc)) {
+		dctlprintk((KERN_ERR
+		    "%s::%s()"
+		    " @%d - ioc%d not SAS controller!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	/* Default to success.
+	 */
+	karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_SUCCESS;
+
+	/* Do some error checking on the request.
+	 */
+	request_data_sz = karg.Parameters.uDataLength;
+
+	/* Neither a phy nor a port has been selected.
+	 */
+	if ((karg.Parameters.bPhyIdentifier == CSMI_SAS_USE_PORT_IDENTIFIER) &&
+		(karg.Parameters.bPortIdentifier == CSMI_SAS_IGNORE_PORT)) {
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_SELECT_PHY_OR_PORT;
+		dctlprintk((KERN_ERR
+		    "%s::%s()"
+		    " @%d - incorrect bPhyIdentifier and bPortIdentifier!\n",
+		    __FILE__, __FUNCTION__, __LINE__));
+		goto cim_ssp_passthru_exit;
+	}
+
+	/* A phy has been selected. Verify that it's valid.
+	 */
+	if (karg.Parameters.bPortIdentifier == CSMI_SAS_IGNORE_PORT) {
+
+		/* Is the phy in range? */
+		if (karg.Parameters.bPhyIdentifier >= ioc->numPhys) {
+			karg.IoctlHeader.ReturnCode =
+			    CSMI_SAS_PHY_DOES_NOT_EXIST;
+			goto cim_ssp_passthru_exit;
+		}
+	}
+
+	/* some checks of the incoming frame
+	 */
+	if (karg.Parameters.uDataLength > 0xFFFF) {
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		dctlprintk((KERN_ERR
+		    "%s::%s()"
+		    " @%d - uDataLength > 0xFFFF!\n",
+		    __FILE__, __FUNCTION__, __LINE__));
+		goto cim_ssp_passthru_exit;
+	}
+
+	data_sz = sizeof(CSMI_SAS_SSP_PASSTHRU_BUFFER) -
+	    sizeof(IOCTL_HEADER) - sizeof(u8*) +
+	    karg.Parameters.uDataLength;
+
+	if ( data_sz > karg.IoctlHeader.Length ) {
+		karg.IoctlHeader.ReturnCode =
+		    CSMI_SAS_STATUS_INVALID_PARAMETER;
+		dctlprintk((KERN_ERR
+		    "%s::%s()"
+		    " @%d - expected datalen incorrect!\n",
+		    __FILE__, __FUNCTION__, __LINE__));
+		goto cim_ssp_passthru_exit;
+	}
+
+	/* we will use SAS address to resolve the scsi adddressing
+	 */
+	memcpy(&SASAddress64,karg.Parameters.bDestinationSASAddress,
+	    sizeof(u64));
+	SASAddress64 = reverse_byte_order64(&SASAddress64);
+
+	/* Search the list for the matching SAS address.
+	 */
+	found = FALSE;
+	list_for_each_entry(sasDevice, &ioc->sasDeviceList, list) {
+
+		/* Find the matching device.
+		 */
+		if (sasDevice->SASAddress != SASAddress64)
+			continue;
+		
+		found = TRUE;
+		bus = sasDevice->Bus;
+		target = sasDevice->TargetId;;
+		break;
+	}
+
+	/* Invalid SAS address
+	 */
+	if (found == FALSE) {
+		karg.IoctlHeader.ReturnCode =
+		    CSMI_SAS_STATUS_INVALID_PARAMETER;
+		dctlprintk((KERN_ERR
+		    "%s::%s()"
+		    " @%d - couldn't find associated SASAddress!\n",
+		    __FILE__, __FUNCTION__, __LINE__));
+		goto cim_ssp_passthru_exit;
+	}
+
+	if(karg.Parameters.bAdditionalCDBLength) {
+	/* TODO - SCSI IO (32) Request Message support
+	 */
+		dctlprintk((": greater than 16-byte cdb is not supported!\n"));
+		karg.IoctlHeader.ReturnCode =
+		    CSMI_SAS_STATUS_INVALID_PARAMETER;
+		goto cim_ssp_passthru_exit;
+	}
+
+	/* Get a free request frame and save the message context.
+	 */
+	if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL) {
+		dctlprintk((": no msg frames!\n"));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_ssp_passthru_exit;
+        }
+
+	mpi_hdr = (MPIHeader_t *) mf;
+	pScsiRequest = (pSCSIIORequest_t) mf;
+	req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
+
+	memset(pScsiRequest,0,sizeof(SCSIIORequest_t));
+
+	/* Fill in SCSI IO (16) request.
+	 */
+	pScsiRequest->TargetID = target;
+	pScsiRequest->Bus = bus;
+	memcpy(pScsiRequest->LUN,karg.Parameters.bLun,8);
+	pScsiRequest->Function = MPI_FUNCTION_SCSI_IO_REQUEST;
+	pScsiRequest->CDBLength = karg.Parameters.bCDBLength;
+	pScsiRequest->DataLength = karg.Parameters.uDataLength;
+	pScsiRequest->MsgContext = mpi_hdr->MsgContext;
+	memcpy(pScsiRequest->CDB,karg.Parameters.bCDB,
+	    pScsiRequest->CDBLength);
+
+	/* direction
+	 */
+	if (karg.Parameters.uFlags & CSMI_SAS_SSP_READ) {
+		pScsiRequest->Control = MPI_SCSIIO_CONTROL_READ;
+	} else if (karg.Parameters.uFlags & CSMI_SAS_SSP_WRITE) {
+		pScsiRequest->Control = MPI_SCSIIO_CONTROL_WRITE;
+	} else if ((karg.Parameters.uFlags & CSMI_SAS_SSP_UNSPECIFIED) &&
+	    (!karg.Parameters.uDataLength)) {
+		/* no data transfer
+		 */
+		pScsiRequest->Control = MPI_SCSIIO_CONTROL_NODATATRANSFER;
+	} else {
+		/* no direction specified
+		 */
+		pScsiRequest->Control = MPI_SCSIIO_CONTROL_READ;
+		pScsiRequest->MsgFlags =
+		    MPI_SCSIIO_MSGFLGS_CMD_DETERMINES_DATA_DIR;
+	}
+
+	/* task attributes
+	 */
+	if((karg.Parameters.uFlags && 0xFF) == 0) {
+		pScsiRequest->Control |= MPI_SCSIIO_CONTROL_SIMPLEQ;
+	} else if (karg.Parameters.uFlags &
+	    CSMI_SAS_SSP_TASK_ATTRIBUTE_HEAD_OF_QUEUE) {
+		pScsiRequest->Control |= MPI_SCSIIO_CONTROL_HEADOFQ;
+	} else if (karg.Parameters.uFlags &
+	    CSMI_SAS_SSP_TASK_ATTRIBUTE_ORDERED) {
+		pScsiRequest->Control |= MPI_SCSIIO_CONTROL_ORDEREDQ;
+	} else if (karg.Parameters.uFlags &
+	    CSMI_SAS_SSP_TASK_ATTRIBUTE_ACA) {
+		pScsiRequest->Control |= MPI_SCSIIO_CONTROL_ACAQ;
+	} else {
+		pScsiRequest->Control |= MPI_SCSIIO_CONTROL_UNTAGGED;
+	}
+
+	/* setup sense
+	 */
+	pScsiRequest->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;
+	pScsiRequest->SenseBufferLowAddr = cpu_to_le32(ioc->sense_buf_low_dma +
+	    (req_idx * MPT_SENSE_BUFFER_ALLOC));
+
+	/* setup databuffer sg, assuming we fit everything one contiguous buffer
+	 */
+	psge = (char *)&pScsiRequest->SGL;
+
+	if (karg.Parameters.uFlags & CSMI_SAS_SSP_WRITE) {
+		flagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE;
+	} else if (karg.Parameters.uFlags & CSMI_SAS_SSP_READ) {
+		flagsLength = MPT_SGE_FLAGS_SSIMPLE_READ;
+	}else {
+		flagsLength = ( MPI_SGE_FLAGS_SIMPLE_ELEMENT |
+				MPI_SGE_FLAGS_DIRECTION |
+				mpt_addr_size() )
+				<< MPI_SGE_FLAGS_SHIFT;
+	}
+	flagsLength |= request_data_sz;
+	request_data = pci_alloc_consistent(
+	    ioc->pcidev, request_data_sz, &request_data_dma);
+
+	if (request_data == NULL) {
+		dctlprintk((": pci_alloc_consistent: FAILED\n"));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		mpt_free_msg_frame(ioc, mf);
+		goto cim_ssp_passthru_exit;
+	}
+
+	mpt_add_sge(psge, flagsLength, request_data_dma);
+
+	if (karg.Parameters.uFlags & CSMI_SAS_SSP_WRITE) {
+
+		if (copy_from_user(request_data,
+		    karg.bDataBuffer,
+		    request_data_sz)) {
+			printk(KERN_ERR
+			"%s@%d::%s - Unable "
+			    "to read user data "
+			    "struct @ %p\n",
+			    __FILE__, __LINE__,__FUNCTION__,
+			    (void*)karg.bDataBuffer);
+			karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+			mpt_free_msg_frame(ioc, mf);
+			goto cim_ssp_passthru_exit;
+		}
+	}
+
+	/* The request is complete. Set the timer parameters
+	 * and issue the request.
+	 */
+	ioc->ioctl->timer.expires = jiffies + HZ*MPT_IOCTL_DEFAULT_TIMEOUT;
+	ioc->ioctl->wait_done = 0;
+	ioc->ioctl->status |= MPT_IOCTL_STATUS_TIMER_ACTIVE;
+	add_timer(&ioc->ioctl->timer);
+	mpt_put_msg_frame(mptctl_id, ioc, mf);
+	wait_event(mptctl_wait, ioc->ioctl->wait_done);
+
+	memset(&karg.Status,0,sizeof(CSMI_SAS_SSP_PASSTHRU_STATUS));
+	karg.Status.bConnectionStatus = CSMI_SAS_OPEN_ACCEPT;
+	karg.Status.bDataPresent = CSMI_SAS_SSP_NO_DATA_PRESENT;
+	karg.Status.bStatus = GOOD;
+	karg.Status.bResponseLength[0] = 0;
+	karg.Status.bResponseLength[1] = 0;
+	karg.Status.uDataBytes = karg.Parameters.uDataLength;
+
+	/* process the completed Reply Message Frame */
+	if (ioc->ioctl->status & MPT_IOCTL_STATUS_RF_VALID) {
+
+		pScsiReply = (pSCSIIOReply_t ) ioc->ioctl->ReplyFrame;
+		karg.Status.bStatus = pScsiReply->SCSIStatus;
+		karg.Status.uDataBytes = pScsiReply->TransferCount;
+		ioc_stat = pScsiReply->IOCStatus & MPI_IOCSTATUS_MASK;
+
+		if (pScsiReply->SCSIState ==
+		    MPI_SCSI_STATE_AUTOSENSE_VALID) {
+			karg.Status.bConnectionStatus =
+			    CSMI_SAS_SSP_SENSE_DATA_PRESENT;
+			karg.Status.bResponseLength[0] =
+				(u8)pScsiReply->SenseCount & 0xFF;
+			memcpy(karg.Status.bResponse,
+			    ioc->ioctl->sense, pScsiReply->SenseCount);
+		} else if(pScsiReply->SCSIState ==
+		    MPI_SCSI_STATE_RESPONSE_INFO_VALID) {
+			karg.Status.bDataPresent =
+			    CSMI_SAS_SSP_RESPONSE_DATA_PRESENT;
+			karg.Status.bResponseLength[0] =
+				sizeof(pScsiReply->ResponseInfo);
+			for (ii=0;ii<sizeof(pScsiReply->ResponseInfo);ii++) {
+				karg.Status.bResponse[ii] =
+				((u8*)&pScsiReply->ResponseInfo)[
+				    (sizeof(pScsiReply->ResponseInfo)-1)-ii];
+			}
+		} else if ((ioc_stat != MPI_IOCSTATUS_SUCCESS) &&
+		    (ioc_stat !=  MPI_IOCSTATUS_SCSI_RECOVERED_ERROR) &&
+		    (ioc_stat != MPI_IOCSTATUS_SCSI_DATA_UNDERRUN)) {
+			karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+			dctlprintk((": SCSI IO : "));
+			dctlprintk(("IOCStatus=0x%X IOCLogInfo=0x%X\n",
+			    pScsiReply->IOCStatus,
+			    pScsiReply->IOCLogInfo));
+		}
+	}
+
+	if ((karg.Status.uDataBytes) && (request_data) &&
+	    (karg.Parameters.uFlags & CSMI_SAS_SSP_READ)) {
+		if (copy_to_user((char *)uarg->bDataBuffer,
+		    request_data, karg.Status.uDataBytes)) {
+			printk(KERN_ERR "%s@%d::%s - "
+			    "Unable to write data to user %p\n",
+			    __FILE__, __LINE__,__FUNCTION__,
+			    (void*)karg.bDataBuffer);
+			karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		}
+	}
+
+cim_ssp_passthru_exit:
+
+	ioc->ioctl->status &= ~(  MPT_IOCTL_STATUS_TM_FAILED |
+	    MPT_IOCTL_STATUS_COMMAND_GOOD | MPT_IOCTL_STATUS_SENSE_VALID |
+	    MPT_IOCTL_STATUS_RF_VALID);
+
+	if (request_data)
+		pci_free_consistent(ioc->pcidev, request_data_sz,
+		    (u8 *)request_data, request_data_dma);
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+	    offsetof(CSMI_SAS_SSP_PASSTHRU_BUFFER,bDataBuffer))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+			"Unable to write out csmi_sas_ssp_passthru @ %p\n",
+				__FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Prototype Routine for the HP CSMI SAS STP Passthru command.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int
+mptctl_csmi_sas_stp_passthru(unsigned long arg)
+{
+	CSMI_SAS_STP_PASSTHRU_BUFFER *uarg = (void *) arg;
+	CSMI_SAS_STP_PASSTHRU_BUFFER	 karg;
+	MPT_ADAPTER			*ioc = NULL;
+	pSataPassthroughRequest_t  	pSataRequest;
+	pSataPassthroughReply_t		pSataReply;
+	MPT_FRAME_HDR			*mf = NULL;
+	MPIHeader_t 			*mpi_hdr;
+	int				iocnum;
+	u32				data_sz;
+	u64				SASAddress64;
+	sas_device_info_t		*sasDevice=NULL;
+	u16				req_idx;
+	char				*psge;
+	int				flagsLength;
+	void *				request_data;
+	dma_addr_t			request_data_dma;
+	u32				request_data_sz;
+	u8				found;
+	u8				bus=0, target=0;
+
+	dctlprintk((": %s called.\n",__FUNCTION__));
+
+	if (copy_from_user(&karg, uarg, sizeof(CSMI_SAS_STP_PASSTHRU_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+		    "Unable to read struct @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	request_data=NULL;
+	request_data_sz=0;
+
+	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
+	    &ioc)) < 0) || (ioc == NULL)) {
+		dctlprintk((KERN_ERR
+		"%s::%s @%d - ioc%d not found!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	if (!mptctl_is_this_sas_cntr(ioc)) {
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - ioc%d not SAS controller!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	/* Default to success.
+	 */
+	karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_SUCCESS;
+
+	/* Do some error checking on the request.
+	 */
+	request_data_sz = karg.Parameters.uDataLength;
+
+	/* Neither a phy nor a port has been selected.
+	 */
+	if ((karg.Parameters.bPhyIdentifier == CSMI_SAS_USE_PORT_IDENTIFIER) &&
+		(karg.Parameters.bPortIdentifier == CSMI_SAS_IGNORE_PORT)) {
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_SELECT_PHY_OR_PORT;
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - incorrect bPhyIdentifier and bPortIdentifier!\n",
+		    __FILE__,__FUNCTION__, __LINE__));
+		goto cim_stp_passthru_exit;
+	}
+
+	/* A phy has been selected. Verify that it's valid.
+	 */
+	if (karg.Parameters.bPortIdentifier == CSMI_SAS_IGNORE_PORT) {
+
+		/* Is the phy in range? */
+		if (karg.Parameters.bPhyIdentifier >= ioc->numPhys) {
+			karg.IoctlHeader.ReturnCode =
+			    CSMI_SAS_PHY_DOES_NOT_EXIST;
+			goto cim_stp_passthru_exit;
+		}
+	}
+
+	/* some checks of the incoming frame
+	 */
+	if (karg.Parameters.uDataLength > 0xFFFF) {
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - uDataLength > 0xFFFF!\n",
+		    __FILE__, __FUNCTION__, __LINE__));
+		goto cim_stp_passthru_exit;
+	}
+
+	data_sz = sizeof(CSMI_SAS_STP_PASSTHRU_BUFFER) -
+	    sizeof(IOCTL_HEADER) - sizeof(u8*) +
+	    karg.Parameters.uDataLength;
+
+	if ( data_sz > karg.IoctlHeader.Length ) {
+		karg.IoctlHeader.ReturnCode =
+		    CSMI_SAS_STATUS_INVALID_PARAMETER;
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - expected datalen incorrect!\n",
+		    __FILE__, __FUNCTION__,__LINE__));
+		goto cim_stp_passthru_exit;
+	}
+
+	/* we will use SAS address to resolve the scsi adddressing
+	 */
+	memcpy(&SASAddress64,karg.Parameters.bDestinationSASAddress,
+	    sizeof(u64));
+	SASAddress64 = reverse_byte_order64(&SASAddress64);
+
+	/* Search the list for the matching SAS address.
+	 */
+	found = FALSE;
+	list_for_each_entry(sasDevice, &ioc->sasDeviceList, list) {
+
+		/* Find the matching device.
+		 */
+		if (sasDevice->SASAddress != SASAddress64)
+			continue;
+
+		found = TRUE;
+		bus = sasDevice->Bus;
+		target = sasDevice->TargetId;;
+		break;
+	}
+
+	/* Invalid SAS address
+	 */
+	if (found == FALSE) {
+		karg.IoctlHeader.ReturnCode =
+		    CSMI_SAS_STATUS_INVALID_PARAMETER;
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - couldn't find associated SASAddress!\n",
+		    __FILE__, __FUNCTION__, __LINE__));
+		goto cim_stp_passthru_exit;
+	}
+
+	/* check that this is an STP or SATA target device
+	 */
+	if ( !(sasDevice->deviceInfo & MPI_SAS_DEVICE_INFO_STP_TARGET ) &&
+	     !(sasDevice->deviceInfo & MPI_SAS_DEVICE_INFO_SATA_DEVICE )) {
+		karg.IoctlHeader.ReturnCode =
+		    CSMI_SAS_STATUS_INVALID_PARAMETER;
+		goto cim_stp_passthru_exit;
+	}
+
+	/* Get a free request frame and save the message context.
+	 */
+	if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL) {
+		dctlprintk((": no msg frames!\n"));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_stp_passthru_exit;
+        }
+
+	mpi_hdr = (MPIHeader_t *) mf;
+	pSataRequest = (pSataPassthroughRequest_t) mf;
+	req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
+
+	memset(pSataRequest,0,sizeof(pSataPassthroughRequest_t));
+
+	pSataRequest->TargetID = target;
+	pSataRequest->Bus = bus;
+	pSataRequest->Function = MPI_FUNCTION_SATA_PASSTHROUGH;
+	pSataRequest->PassthroughFlags = (u16)karg.Parameters.uFlags;
+	pSataRequest->ConnectionRate = karg.Parameters.bConnectionRate;
+	pSataRequest->MsgContext = mpi_hdr->MsgContext;
+	pSataRequest->DataLength = request_data_sz;
+	pSataRequest->MsgFlags = 0;
+	memcpy( pSataRequest->CommandFIS,karg.Parameters.bCommandFIS, 20);
+
+	psge = (char *)&pSataRequest->SGL;
+	if (karg.Parameters.uFlags & CSMI_SAS_STP_WRITE) {
+		flagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE;
+	} else if (karg.Parameters.uFlags & CSMI_SAS_STP_READ) {
+		flagsLength = MPT_SGE_FLAGS_SSIMPLE_READ;
+	}else {
+		flagsLength = ( MPI_SGE_FLAGS_SIMPLE_ELEMENT |
+				MPI_SGE_FLAGS_DIRECTION |
+				mpt_addr_size() )
+				<< MPI_SGE_FLAGS_SHIFT;
+	}
+
+	flagsLength |= request_data_sz;
+	request_data = pci_alloc_consistent(
+	    ioc->pcidev, request_data_sz, &request_data_dma);
+
+	if (request_data == NULL) {
+		dctlprintk((": pci_alloc_consistent: FAILED\n"));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		mpt_free_msg_frame(ioc, mf);
+		goto cim_stp_passthru_exit;
+	}
+
+	mpt_add_sge(psge, flagsLength, request_data_dma);
+
+	if (karg.Parameters.uFlags & CSMI_SAS_STP_WRITE) {
+		if (copy_from_user(request_data,
+		    karg.bDataBuffer,
+		    request_data_sz)) {
+			printk(KERN_ERR
+			    "%s::%s() @%d - Unable to read user data "
+			    "struct @ %p\n",
+			    __FILE__, __FUNCTION__, __LINE__,
+			    (void*)karg.bDataBuffer);
+			karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+			mpt_free_msg_frame(ioc, mf);
+			goto cim_stp_passthru_exit;
+		}
+	}
+
+	/* The request is complete. Set the timer parameters
+	 * and issue the request.
+	 */
+	ioc->ioctl->timer.expires = jiffies + HZ*MPT_IOCTL_DEFAULT_TIMEOUT;
+	ioc->ioctl->wait_done = 0;
+	ioc->ioctl->status |= MPT_IOCTL_STATUS_TIMER_ACTIVE;
+	add_timer(&ioc->ioctl->timer);
+	mpt_put_msg_frame(mptctl_id, ioc, mf);
+	wait_event(mptctl_wait, ioc->ioctl->wait_done);
+
+	memset(&karg.Status,0,sizeof(CSMI_SAS_STP_PASSTHRU_STATUS));
+
+	if ((ioc->ioctl->status & MPT_IOCTL_STATUS_RF_VALID) == 0) {
+		dctlprintk((": STP Passthru: oh no, there is no reply!!"));
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_stp_passthru_exit;
+	}
+
+	/* process the completed Reply Message Frame */
+	pSataReply = (pSataPassthroughReply_t ) ioc->ioctl->ReplyFrame;
+
+	if ((pSataReply->IOCStatus != MPI_IOCSTATUS_SUCCESS) &&
+	    (pSataReply->IOCStatus != MPI_IOCSTATUS_SCSI_DATA_UNDERRUN )) {
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		dctlprintk((": STP Passthru: "));
+		dctlprintk(("IOCStatus=0x%X IOCLogInfo=0x%X SASStatus=0x%X\n",
+		    pSataReply->IOCStatus,
+		    pSataReply->IOCLogInfo,
+		    pSataReply->SASStatus));
+	}
+
+	karg.Status.bConnectionStatus =
+	    map_sas_status_to_csmi(pSataReply->SASStatus);
+
+	memcpy(karg.Status.bStatusFIS,pSataReply->StatusFIS, 20);
+
+	/*
+	 * for now, just zero out uSCR array,
+	 * then copy the one dword returned
+	 * in the reply frame into uSCR[0]
+	 */
+	memset( karg.Status.uSCR, 0, 64);
+	karg.Status.uSCR[0] = pSataReply->StatusControlRegisters;
+
+	if((pSataReply->TransferCount) && (request_data) &&
+	    (karg.Parameters.uFlags & CSMI_SAS_STP_READ)) {
+		karg.Status.uDataBytes = pSataReply->TransferCount;
+		if (copy_to_user((char *)uarg->bDataBuffer,
+		    request_data, karg.Status.uDataBytes)) {
+			printk(KERN_ERR "%s::%s() @%d - "
+			    "Unable to write data to user %p\n",
+			    __FILE__, __FUNCTION__, __LINE__,
+			    (void*)karg.bDataBuffer);
+			karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		}
+	}
+
+cim_stp_passthru_exit:
+
+	ioc->ioctl->status &= ~( MPT_IOCTL_STATUS_TM_FAILED |
+	    MPT_IOCTL_STATUS_COMMAND_GOOD | MPT_IOCTL_STATUS_SENSE_VALID |
+	    MPT_IOCTL_STATUS_RF_VALID );
+
+	if (request_data)
+		pci_free_consistent(ioc->pcidev, request_data_sz,
+		    (u8 *)request_data, request_data_dma);
+
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+	    offsetof(CSMI_SAS_STP_PASSTHRU_BUFFER,bDataBuffer))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+			"Unable to write out csmi_sas_ssp_passthru @ %p\n",
+				__FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Prototype Routine for the HP CSMI SAS Firmware Download command.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int
+mptctl_csmi_sas_firmware_download(unsigned long arg)
+{
+	CSMI_SAS_FIRMWARE_DOWNLOAD_BUFFER *uarg = (void *) arg;
+	CSMI_SAS_FIRMWARE_DOWNLOAD_BUFFER	 karg;
+	MPT_ADAPTER			*ioc = NULL;
+	int				iocnum;
+	pMpiFwHeader_t			pFwHeader=NULL;
+
+	dctlprintk((": %s called.\n",__FUNCTION__));
+
+	if (copy_from_user(&karg, uarg,
+		sizeof(CSMI_SAS_FIRMWARE_DOWNLOAD_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+		    "Unable to read in csmi_sas_firmware_download struct @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
+	    &ioc)) < 0) || (ioc == NULL)) {
+		dctlprintk((KERN_ERR
+		"%s::%s() @%d - ioc%d not found!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	if (!mptctl_is_this_sas_cntr(ioc)) {
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - ioc%d not SAS controller!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	/* Default to success.*/
+	karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_SUCCESS;
+	karg.Information.usStatus = CSMI_SAS_FWD_SUCCESS;
+	karg.Information.usSeverity = CSMI_SAS_FWD_INFORMATION;
+
+	/* some checks of the incoming frame */
+	if ((karg.Information.uBufferLength +
+	    sizeof(CSMI_SAS_FIRMWARE_DOWNLOAD)) >
+	    karg.IoctlHeader.Length) {
+		karg.IoctlHeader.ReturnCode =
+		    CSMI_SAS_STATUS_INVALID_PARAMETER;
+		karg.Information.usStatus = CSMI_SAS_FWD_FAILED;
+		goto cim_firmware_download_exit;
+	}
+
+	if ( karg.Information.uDownloadFlags &
+	    (CSMI_SAS_FWD_SOFT_RESET | CSMI_SAS_FWD_VALIDATE)) {
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		karg.Information.usStatus = CSMI_SAS_FWD_REJECT;
+		karg.Information.usSeverity = CSMI_SAS_FWD_ERROR;
+		goto cim_firmware_download_exit;
+	}
+
+	/* now we need to alloc memory so we can pull in the
+	 * fw image attached to end of incomming packet.
+	 */
+	pFwHeader = kmalloc(karg.Information.uBufferLength, GFP_KERNEL);
+	if(pFwHeader==NULL){
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		karg.Information.usStatus = CSMI_SAS_FWD_REJECT;
+		karg.Information.usSeverity = CSMI_SAS_FWD_ERROR;
+		goto cim_firmware_download_exit;
+	}
+
+	if (copy_from_user(pFwHeader, uarg->bDataBuffer,
+		karg.Information.uBufferLength)) {
+		printk(KERN_ERR "%s@%d::%s() - "
+		    "Unable to read in pFwHeader @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	if ( !((pFwHeader->Signature0 == MPI_FW_HEADER_SIGNATURE_0) &&
+	    (pFwHeader->Signature1 == MPI_FW_HEADER_SIGNATURE_1) &&
+	    (pFwHeader->Signature2 == MPI_FW_HEADER_SIGNATURE_2))) {
+		// the signature check failed
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		karg.Information.usStatus = CSMI_SAS_FWD_REJECT;
+		karg.Information.usSeverity = CSMI_SAS_FWD_ERROR;
+		goto cim_firmware_download_exit;
+	}
+
+	if ( mptctl_do_fw_download(karg.IoctlHeader.IOControllerNumber,
+	    uarg->bDataBuffer, karg.Information.uBufferLength)
+	    != 0) {
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		karg.Information.usStatus = CSMI_SAS_FWD_FAILED;
+		karg.Information.usSeverity = CSMI_SAS_FWD_FATAL;
+		goto cim_firmware_download_exit;
+	}
+
+	if((karg.Information.uDownloadFlags & CSMI_SAS_FWD_SOFT_RESET) ||
+	    (karg.Information.uDownloadFlags & CSMI_SAS_FWD_HARD_RESET)) {
+		if (mpt_HardResetHandler(ioc, CAN_SLEEP) != 0) {
+			karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+			karg.Information.usStatus = CSMI_SAS_FWD_FAILED;
+			karg.Information.usSeverity = CSMI_SAS_FWD_FATAL;
+		}
+	}
+
+cim_firmware_download_exit:
+
+	if(pFwHeader)
+		kfree(pFwHeader);
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+				sizeof(CSMI_SAS_FIRMWARE_DOWNLOAD_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+			"Unable to write out csmi_sas_firmware_download @ %p\n",
+				__FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Prototype Routine for the HP CSMI SAS Get RAID Info command.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int
+mptctl_csmi_sas_get_raid_info(unsigned long arg)
+{
+	CSMI_SAS_RAID_INFO_BUFFER *uarg =  (void *) arg;
+	CSMI_SAS_RAID_INFO_BUFFER	 karg;
+	MPT_ADAPTER			*ioc = NULL;
+	int				iocnum;
+
+	dctlprintk((": %s called.\n",__FUNCTION__));
+
+	if (copy_from_user(&karg, uarg, sizeof(CSMI_SAS_RAID_INFO_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+		    "Unable to read in csmi_sas_get_raid_info struct @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
+	    &ioc)) < 0) || (ioc == NULL)) {
+		dctlprintk((KERN_ERR
+		"%s::%s() @%d - ioc%d not found!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+
+	if (!mptctl_is_this_sas_cntr(ioc)) {
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - ioc%d not SAS controller!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+	if( !mpt_findImVolumes(ioc)) {
+		if ( ioc->spi_data.pIocPg2 ) {
+			karg.Information.uNumRaidSets = ioc->spi_data.pIocPg2->NumActiveVolumes;
+			karg.Information.uMaxDrivesPerSet = ioc->spi_data.pIocPg2->MaxPhysDisks;
+			karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_SUCCESS;
+		}
+	}
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+				sizeof(CSMI_SAS_RAID_INFO_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+			"Unable to write out csmi_sas_get_raid_info @ %p\n",
+				__FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+
+}
+
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*	mptscsih_do_raid - Format and Issue a RAID volume request message.
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@action: What do be done.
+ *	@PhysDiskNum: Logical target id.
+ *	@VolumeBus: Target locations bus.
+ *	@VolumeId: Volume id
+ *
+ *	Returns: < 0 on a fatal error
+ *		0 on success
+ *
+ *	Remark: Wait to return until reply processed by the ISR.
+ */
+static int
+mptctl_do_raid(MPT_ADAPTER *ioc, u8 action, u8 PhysDiskNum, u8 VolumeBus, u8 VolumeId, pMpiRaidActionReply_t reply)
+{
+	MpiRaidActionRequest_t	*pReq;
+	MpiRaidActionReply_t	*pReply;
+	MPT_FRAME_HDR		*mf;
+	
+	/* Get and Populate a free Frame
+	 */
+	if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL) {
+		dctlprintk((": no msg frames!\n"));
+		return -EAGAIN;
+	}
+	pReq = (MpiRaidActionRequest_t *)mf;
+	pReq->Action = action;
+	pReq->Reserved1 = 0;
+	pReq->ChainOffset = 0;
+	pReq->Function = MPI_FUNCTION_RAID_ACTION;
+	pReq->VolumeID = VolumeId;
+	pReq->VolumeBus = VolumeBus;
+	pReq->PhysDiskNum = PhysDiskNum;
+	pReq->MsgFlags = 0;
+	pReq->Reserved2 = 0;
+	pReq->ActionDataWord = 0; /* Reserved for this action */
+	//pReq->ActionDataSGE = 0;
+
+	mpt_add_sge((char *)&pReq->ActionDataSGE,
+		MPT_SGE_FLAGS_SSIMPLE_READ | 0, (dma_addr_t) -1);
+
+	ioc->ioctl->tmPtr = mf;
+	ioc->ioctl->timer.expires = jiffies + HZ*MPT_IOCTL_DEFAULT_TIMEOUT;
+	ioc->ioctl->wait_done = 0;
+	ioc->ioctl->status |= MPT_IOCTL_STATUS_TIMER_ACTIVE;
+	add_timer(&ioc->ioctl->timer);
+	mpt_put_msg_frame(mptctl_id, ioc, mf);
+	wait_event(mptctl_wait, ioc->ioctl->wait_done);
+	
+	if ((ioc->ioctl->status & MPT_IOCTL_STATUS_RF_VALID) && 
+	    (reply != NULL)){
+		pReply = (MpiRaidActionReply_t *)&(ioc->ioctl->ReplyFrame);
+		memcpy(reply, pReply,
+			min(ioc->reply_sz,
+			4*pReply->MsgLength));
+	}
+	
+	ioc->ioctl->status &= ~MPT_IOCTL_STATUS_TIMER_ACTIVE; 
+	ioc->ioctl->tmPtr = NULL;
+	mpt_free_msg_frame(ioc, mf);
+			
+	return 0;
+}
+
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Prototype Routine for the HP CSMI SAS Get RAID Config command.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int
+mptctl_csmi_sas_get_raid_config(unsigned long arg)
+{
+	CSMI_SAS_RAID_CONFIG_BUFFER *uarg = (void *) arg;
+	CSMI_SAS_RAID_CONFIG_BUFFER	 karg,*pKarg=NULL;
+	CONFIGPARMS		 	cfg;
+	ConfigPageHeader_t	 	header;
+	MPT_ADAPTER			*ioc = NULL;
+	int				iocnum;
+	u8				volumeID, VolumeBus, physDiskNum, physDiskNumMax, found;
+	int			 	volumepage0sz = 0, physdiskpage0sz = 0;
+	dma_addr_t			volume0_dma, physdisk0_dma;
+	pRaidVolumePage0_t		pVolume0 = NULL; 
+	pRaidPhysDiskPage0_t		pPhysDisk0 = NULL;
+	pMpiRaidActionReply_t 		pRaidActionReply = NULL;
+	int 				i, csmi_sas_raid_config_buffer_sz;
+	sas_device_info_t		*sasDevice;
+
+	dctlprintk((": %s called.\n",__FUNCTION__));
+
+	if (copy_from_user(&karg, uarg, sizeof(IOCTL_HEADER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+		    "Unable to read in csmi_sas_get_raid_config struct @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	csmi_sas_raid_config_buffer_sz = karg.IoctlHeader.Length;
+	pKarg = kmalloc(csmi_sas_raid_config_buffer_sz, GFP_KERNEL);
+	if(!pKarg){
+		printk(KERN_ERR "%s@%d::%s() - "
+		    "Unable to malloc @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__,pKarg);
+		return -EFAULT;
+	}
+
+	if (copy_from_user(pKarg, uarg, csmi_sas_raid_config_buffer_sz)) {
+		printk(KERN_ERR "%s@%d::%s() - "
+		    "Unable to read in csmi_sas_get_raid_config struct @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		kfree(pKarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(pKarg->IoctlHeader.IOControllerNumber,
+	    &ioc)) < 0) || (ioc == NULL)) {
+		dctlprintk((KERN_ERR
+		"%s::%s() @%d - ioc%d not found!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		kfree(pKarg);
+		return -ENODEV;
+	}
+
+	if (!mptctl_is_this_sas_cntr(ioc)) {
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - ioc%d not SAS controller!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		kfree(pKarg);
+		return -ENODEV;
+	}
+
+	if(( mpt_findImVolumes(ioc) != 0 ) || ( ioc->spi_data.pIocPg2 == NULL)) {
+		pKarg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_get_raid_config_exit;
+	}
+
+	// check to see if the input uRaidSetIndex is greater than the number of RAID sets
+	if(pKarg->Configuration.uRaidSetIndex >
+	    ioc->spi_data.pIocPg2->NumActiveVolumes) {
+		pKarg->IoctlHeader.ReturnCode = CSMI_SAS_RAID_SET_OUT_OF_RANGE;
+		goto cim_get_raid_config_exit;
+	}
+
+	/*
+	 * get RAID Volume Page 0
+	 */
+	volumeID = ioc->spi_data.pIocPg2->RaidVolume[pKarg->Configuration.uRaidSetIndex-1].VolumeID;
+	VolumeBus = ioc->spi_data.pIocPg2->RaidVolume[pKarg->Configuration.uRaidSetIndex-1].VolumeBus;
+
+	header.PageVersion = 0;
+	header.PageLength = 0;
+	header.PageNumber = 0;
+	header.PageType = MPI_CONFIG_PAGETYPE_RAID_VOLUME;
+	cfg.cfghdr.hdr = &header;
+	cfg.physAddr = -1;
+	cfg.pageAddr = volumeID;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	cfg.timeout = 0;
+	if (mpt_config(ioc, &cfg) != 0) {
+		pKarg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_get_raid_config_exit;
+	}
+
+	if (header.PageLength == 0) {
+		pKarg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_get_raid_config_exit;
+	}
+
+	volumepage0sz = header.PageLength * 4;
+	pVolume0 = pci_alloc_consistent(ioc->pcidev, volumepage0sz,
+	    &volume0_dma);
+	if (!pVolume0) {
+		pKarg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_get_raid_config_exit;
+	}
+
+	cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+	cfg.physAddr = volume0_dma;
+	if (mpt_config(ioc, &cfg) != 0){
+		pKarg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_get_raid_config_exit;
+	}
+
+	pKarg->Configuration.uCapacity = 
+		(le32_to_cpu(pVolume0->MaxLBA)+1)/2048;
+	pKarg->Configuration.uStripeSize = 
+		le32_to_cpu(pVolume0->StripeSize/2);
+
+	switch(pVolume0->VolumeType) {
+	case MPI_RAID_VOL_TYPE_IS:
+		pKarg->Configuration.bRaidType = CSMI_SAS_RAID_TYPE_0;
+		break;
+	case MPI_RAID_VOL_TYPE_IME:
+		pKarg->Configuration.bRaidType = CSMI_SAS_RAID_TYPE_10;
+		break;
+	case MPI_RAID_VOL_TYPE_IM:
+		pKarg->Configuration.bRaidType = CSMI_SAS_RAID_TYPE_1;
+		break;
+	default:
+		pKarg->Configuration.bRaidType = CSMI_SAS_RAID_TYPE_OTHER;
+		break;
+	}
+
+	pKarg->Configuration.bInformation = 0;
+	switch (pVolume0->VolumeStatus.State) {
+	case MPI_RAIDVOL0_STATUS_STATE_OPTIMAL:
+		pKarg->Configuration.bStatus = CSMI_SAS_RAID_SET_STATUS_OK;
+		break;
+	case MPI_RAIDVOL0_STATUS_STATE_DEGRADED:
+		pKarg->Configuration.bStatus = CSMI_SAS_RAID_SET_STATUS_DEGRADED;
+		break;
+	case MPI_RAIDVOL0_STATUS_STATE_FAILED:
+		pKarg->Configuration.bStatus = CSMI_SAS_RAID_SET_STATUS_FAILED;
+		break;
+	}
+
+	if(pVolume0->VolumeStatus.Flags &
+	    MPI_RAIDVOL0_STATUS_FLAG_RESYNC_IN_PROGRESS ) {
+
+		uint64_t 	* ptrUint64;
+		uint64_t	totalBlocks64, blocksRemaining64;
+		uint32_t	totalBlocks32, blocksRemaining32;
+
+		pKarg->Configuration.bStatus =
+		    CSMI_SAS_RAID_SET_STATUS_REBUILDING;
+
+		/* get percentage complete */
+		pRaidActionReply = kmalloc( sizeof(MPI_RAID_VOL_INDICATOR) +
+		    offsetof(MSG_RAID_ACTION_REPLY,ActionData),
+		    GFP_KERNEL);
+
+		if(pRaidActionReply == NULL){
+			printk(KERN_ERR "%s@%d::%s() - "
+			    "Unable to malloc @ %p\n",
+			    __FILE__, __LINE__, __FUNCTION__,pKarg);
+			goto cim_get_raid_config_exit;
+		}
+
+		mptctl_do_raid(ioc,
+		    MPI_RAID_ACTION_INDICATOR_STRUCT,
+		    0, VolumeBus, volumeID, pRaidActionReply);
+
+		ptrUint64       = (uint64_t *)&pRaidActionReply->ActionData;
+		totalBlocks64     = *ptrUint64;
+		ptrUint64++;
+		blocksRemaining64 = *ptrUint64;
+		while(totalBlocks64 > 0xFFFFFFFFUL){
+			totalBlocks64 = totalBlocks64 >> 1;
+			blocksRemaining64 = blocksRemaining64 >> 1;
+		}
+		totalBlocks32 = (uint32_t)totalBlocks64;
+		blocksRemaining32 = (uint32_t)blocksRemaining64;
+		pKarg->Configuration.bInformation =
+		    (totalBlocks32 - blocksRemaining32) / (totalBlocks32 / 100);
+
+		kfree(pRaidActionReply);
+    
+	}
+
+	pKarg->Configuration.bDriveCount = pVolume0->NumPhysDisks;
+
+	/*
+	 * get RAID Physical Disk Page 0
+	 */
+	header.PageVersion = 0;
+	header.PageLength = 0;
+	header.PageNumber = 0;
+	header.PageType = MPI_CONFIG_PAGETYPE_RAID_PHYSDISK;
+	cfg.cfghdr.hdr = &header;
+	cfg.physAddr = -1;
+	cfg.pageAddr = 0;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	cfg.timeout = 0;
+	if (mpt_config(ioc, &cfg) != 0) {
+		pKarg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_get_raid_config_exit;
+	}
+
+	if (header.PageLength == 0) {
+		pKarg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_get_raid_config_exit;
+	}
+
+	physdiskpage0sz = header.PageLength * 4;
+	pPhysDisk0 = pci_alloc_consistent(ioc->pcidev, physdiskpage0sz,
+	    &physdisk0_dma);
+	if (!pPhysDisk0) {
+		pKarg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		goto cim_get_raid_config_exit;
+	}
+	cfg.physAddr = physdisk0_dma;
+
+	physDiskNumMax = (csmi_sas_raid_config_buffer_sz -
+	    sizeof(CSMI_SAS_RAID_CONFIG_BUFFER)) / sizeof(CSMI_SAS_RAID_DRIVES);
+
+	for (i=0; i< min(pVolume0->NumPhysDisks, physDiskNumMax); i++) {
+
+		physDiskNum = pVolume0->PhysDisk[i].PhysDiskNum;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+		cfg.pageAddr = physDiskNum;
+		if (mpt_config(ioc, &cfg) != 0){
+			pKarg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+			goto cim_get_raid_config_exit;
+		}
+
+		memset(&pKarg->Configuration.Drives[i],0,
+		    sizeof(CSMI_SAS_RAID_DRIVES));
+
+		memcpy(pKarg->Configuration.Drives[i].bModel,
+		    pPhysDisk0->InquiryData.VendorID,
+		    offsetof(RAID_PHYS_DISK0_INQUIRY_DATA,ProductRevLevel));
+
+		memcpy(pKarg->Configuration.Drives[i].bFirmware,
+			pPhysDisk0->InquiryData.ProductRevLevel,
+			sizeof(pPhysDisk0->InquiryData.ProductRevLevel));
+
+		memcpy(pKarg->Configuration.Drives[i].bSerialNumber,
+			pPhysDisk0->DiskIdentifier,
+			sizeof(pPhysDisk0->DiskIdentifier));
+
+		switch(pPhysDisk0->PhysDiskStatus.State) {
+		case MPI_PHYSDISK0_STATUS_ONLINE:
+			pKarg->Configuration.Drives[i].bDriveStatus =
+			    CSMI_SAS_DRIVE_STATUS_OK;
+			pKarg->Configuration.Drives[i].bDriveUsage =
+			    CSMI_SAS_DRIVE_CONFIG_MEMBER;
+			break;
+		case MPI_PHYSDISK0_STATUS_FAILED:
+		case MPI_PHYSDISK0_STATUS_FAILED_REQUESTED:
+			pKarg->Configuration.Drives[i].bDriveStatus =
+			    CSMI_SAS_DRIVE_STATUS_FAILED;
+			pKarg->Configuration.Drives[i].bDriveUsage =
+			    CSMI_SAS_DRIVE_CONFIG_MEMBER;
+			pKarg->Configuration.bInformation = i;
+			break;
+		case MPI_PHYSDISK0_STATUS_INITIALIZING:
+			pKarg->Configuration.Drives[i].bDriveStatus =
+			    CSMI_SAS_DRIVE_STATUS_REBUILDING;
+			pKarg->Configuration.Drives[i].bDriveUsage =
+			    CSMI_SAS_DRIVE_CONFIG_MEMBER;
+			break;
+		case MPI_PHYSDISK0_STATUS_OTHER_OFFLINE:
+		case MPI_PHYSDISK0_STATUS_MISSING:
+		case MPI_PHYSDISK0_STATUS_NOT_COMPATIBLE:
+		case MPI_PHYSDISK0_STATUS_OFFLINE_REQUESTED:
+		default:
+			pKarg->Configuration.Drives[i].bDriveStatus =
+			    CSMI_SAS_DRIVE_STATUS_FAILED;
+			pKarg->Configuration.Drives[i].bDriveUsage =
+			    CSMI_SAS_DRIVE_CONFIG_NOT_USED;
+			break;
+		}
+
+		/* Search the list for the matching SAS address. */
+		found = FALSE;
+		list_for_each_entry(sasDevice, &ioc->sasDeviceList, list) {
+
+			/* Found the matching device. */
+			if ((pPhysDisk0->PhysDiskIOC == sasDevice->Bus) &&
+				(pPhysDisk0->PhysDiskID == sasDevice->TargetId)) {
+				u64 SASAddress64;
+				found = TRUE;
+
+				SASAddress64 = reverse_byte_order64(&sasDevice->SASAddress);
+				memcpy(pKarg->Configuration.Drives[i].bSASAddress,
+				   &SASAddress64,sizeof(u64));
+				memset(pKarg->Configuration.Drives[i].bSASLun, 0,
+				     sizeof(pKarg->Configuration.Drives[i].bSASLun));
+				break;
+			} else
+				/* Keep looking. */
+				continue;
+		}
+	}
+
+	pKarg->IoctlHeader.ReturnCode = CSMI_SAS_STATUS_SUCCESS;
+
+cim_get_raid_config_exit:
+
+	if (pVolume0 != NULL)
+		pci_free_consistent(ioc->pcidev, volumepage0sz, pVolume0,
+		    volume0_dma);
+
+	if(pPhysDisk0 != NULL)
+		pci_free_consistent(ioc->pcidev, physdiskpage0sz, pPhysDisk0,
+		    physdisk0_dma);
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, pKarg,
+				csmi_sas_raid_config_buffer_sz)) {
+		printk(KERN_ERR "%s@%d::%s() - "
+			"Unable to write out csmi_sas_get_raid_config @ %p\n",
+				__FILE__, __LINE__, __FUNCTION__, uarg);
+		kfree(pKarg);
+		return -EFAULT;
+	}
+
+	kfree(pKarg);
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Prototype Routine for the HP CSMI SAS Task Managment Config command.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int
+mptctl_csmi_sas_task_managment(unsigned long arg)
+{
+	CSMI_SAS_SSP_TASK_IU_BUFFER *uarg = (void *) arg;
+	CSMI_SAS_SSP_TASK_IU_BUFFER	 karg;
+	pSCSITaskMgmt_t			pScsiTm;
+	pSCSITaskMgmtReply_t		pScsiTmReply;
+	MPT_ADAPTER			*ioc = NULL;
+	MPT_SCSI_HOST			*hd;
+	MPT_FRAME_HDR			*mf = NULL;
+	MPIHeader_t			*mpi_hdr;
+	int				iocnum;
+	u8				taskType;
+	u8				path;
+	u8				target;
+	u8				lun;
+	u8				queueTag;
+	u32				msgContext = 0;
+	int				retval;
+	int				i;
+	u8 				found_qtag;
+
+	dctlprintk((": %s called.\n",__FUNCTION__));
+
+	if (copy_from_user(&karg, uarg, sizeof(CSMI_SAS_SSP_TASK_IU_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+		    "Unable to read in csmi_sas_task_managment struct @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
+	    &ioc)) < 0) || (ioc == NULL)) {
+		dctlprintk((KERN_ERR
+		"%s::%s() @%d - ioc%d not found!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	if (!mptctl_is_this_sas_cntr(ioc)) {
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - ioc%d not SAS controller!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	/* try to catch an error
+	 */
+	if ((karg.Parameters.uFlags & CSMI_SAS_TASK_IU) &&
+	    (karg.Parameters.uFlags & CSMI_SAS_HARD_RESET_SEQUENCE)) {
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_INVALID_PARAMETER;
+		goto cim_get_task_managment_exit;
+	}
+
+	if (karg.Parameters.uFlags & CSMI_SAS_TASK_IU) {
+		switch (karg.Parameters.bTaskManagementFunction) {
+
+		case CSMI_SAS_SSP_ABORT_TASK:
+			taskType = MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK;
+			break;
+		case CSMI_SAS_SSP_ABORT_TASK_SET:
+			taskType = MPI_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET;
+			break;
+		case CSMI_SAS_SSP_CLEAR_TASK_SET:
+			taskType = MPI_SCSITASKMGMT_TASKTYPE_CLEAR_TASK_SET;
+			break;
+		case CSMI_SAS_SSP_LOGICAL_UNIT_RESET:
+			taskType = MPI_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET;
+			break;
+		case CSMI_SAS_SSP_CLEAR_ACA:
+		case CSMI_SAS_SSP_QUERY_TASK:
+		default:
+			karg.IoctlHeader.ReturnCode =
+			    CSMI_SAS_STATUS_INVALID_PARAMETER;
+			goto cim_get_task_managment_exit;
+		}
+	}else if (karg.Parameters.uFlags & CSMI_SAS_HARD_RESET_SEQUENCE) {
+		/* set the code up to do a hard reset
+		 */
+		taskType = MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET;
+	}else {
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_INVALID_PARAMETER;
+		goto cim_get_task_managment_exit;
+	}
+
+	path = karg.Parameters.bPathId;
+	target = karg.Parameters.bTargetId;
+	lun = karg.Parameters.bLun;
+	queueTag = (u8)karg.Parameters.uQueueTag & 0xFF;
+
+	if ((ioc->sh == NULL) || (ioc->sh->hostdata == NULL)) {
+		karg.IoctlHeader.ReturnCode =
+		    CSMI_SAS_STATUS_INVALID_PARAMETER;
+		goto cim_get_task_managment_exit;
+	}
+	else
+		hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
+
+	switch ( karg.Parameters.uInformation ) {
+		case CSMI_SAS_SSP_TEST:
+			dsasprintk(("TM request for test purposes\n"));
+			break;
+		case CSMI_SAS_SSP_EXCEEDED:
+			dsasprintk(("TM request due to timeout\n"));
+			break;
+		case CSMI_SAS_SSP_DEMAND:
+			dsasprintk(("TM request demanded by app\n"));
+			break;
+		case CSMI_SAS_SSP_TRIGGER:
+			dsasprintk(("TM request sent to trigger event\n"));
+			break;
+	}
+
+	karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_SUCCESS;
+
+	switch (taskType) {
+
+	case MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK:
+	/*
+	 * look up qtag in the ScsiLookup[] table
+	 */
+		for (i=0,found_qtag=0;i<hd->ioc->req_depth;i++) {
+			if ((hd->ScsiLookup[i]) &&
+			    (hd->ScsiLookup[i]->tag == queueTag)) {
+				mf = MPT_INDEX_2_MFPTR(hd->ioc, i);
+				msgContext =
+				    mf->u.frame.hwhdr.msgctxu.MsgContext;
+				found_qtag=1;
+				break;
+			}
+		}
+
+		if(!found_qtag) {
+			karg.IoctlHeader.ReturnCode =
+			    CSMI_SAS_STATUS_INVALID_PARAMETER;
+			goto cim_get_task_managment_exit;
+		}
+
+	case MPI_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET:
+	case MPI_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET:
+	case MPI_SCSITASKMGMT_TASKTYPE_CLEAR_TASK_SET:
+	/* for now, this should work
+	 */
+	case MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET:
+
+		/* Single threading ....
+		 */
+		if (mptctl_set_tm_flags(hd) != 0) {
+			karg.IoctlHeader.ReturnCode =
+			    CSMI_SAS_STATUS_FAILED;
+			goto cim_get_task_managment_exit;
+		}
+
+		/* Send request
+		 */
+		if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL) {
+			dctlprintk((": no msg frames!\n"));
+			mptctl_free_tm_flags(ioc);
+			karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+			goto cim_get_task_managment_exit;
+		}
+
+		mpi_hdr = (MPIHeader_t *) mf;
+		pScsiTm = (pSCSITaskMgmt_t ) mf;
+
+		memset(pScsiTm,0,sizeof(SCSITaskMgmt_t));
+		pScsiTm->TaskType = taskType;
+		pScsiTm->Bus = path;
+		pScsiTm->TargetID = target;
+		pScsiTm->LUN[1] = lun;
+		pScsiTm->MsgContext = mpi_hdr->MsgContext;
+		pScsiTm->TaskMsgContext = msgContext;
+		pScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;
+
+		ioc->ioctl->wait_done = 0;
+		ioc->ioctl->tmPtr = mf;
+		ioc->ioctl->TMtimer.expires = jiffies + HZ*MPT_IOCTL_DEFAULT_TIMEOUT;
+		ioc->ioctl->status |= MPT_IOCTL_STATUS_TMTIMER_ACTIVE;
+		add_timer(&ioc->ioctl->TMtimer);
+
+		DBG_DUMP_TM_REQUEST_FRAME((u32 *)mf);
+		
+		if ((retval = mpt_send_handshake_request(mptctl_id, ioc->ioctl->ioc,
+		     sizeof(SCSITaskMgmt_t), (u32*)pScsiTm, CAN_SLEEP)) != 0) {
+			dfailprintk((MYIOC_s_ERR_FMT "_send_handshake FAILED!"
+				" (hd %p, ioc %p, mf %p) \n", hd->ioc->name, hd,
+				hd->ioc, mf));
+			goto cim_get_task_managment_exit;
+		}
+
+		if (retval == 0) {
+			wait_event(mptctl_wait, ioc->ioctl->wait_done);
+		} else {
+			mptctl_free_tm_flags(ioc);
+			del_timer(&ioc->ioctl->TMtimer);
+			mpt_free_msg_frame(ioc, mf);
+			ioc->ioctl->tmPtr = NULL;
+			karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+			ioc->ioctl->status &= ~MPT_IOCTL_STATUS_TMTIMER_ACTIVE;
+			goto cim_get_task_managment_exit;
+		}
+
+		if (ioc->ioctl->status & MPT_IOCTL_STATUS_RF_VALID) {
+			pScsiTmReply =
+			    (pSCSITaskMgmtReply_t ) ioc->ioctl->ReplyFrame;
+
+			memset(&karg.Status,0,
+			    sizeof(CSMI_SAS_SSP_PASSTHRU_STATUS));
+
+			if(pScsiTmReply->IOCStatus == MPI_IOCSTATUS_SUCCESS) {
+				karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_SUCCESS;
+				karg.Status.bSSPStatus = CSMI_SAS_SSP_STATUS_COMPLETED;
+			}else if(pScsiTmReply->IOCStatus == MPI_IOCSTATUS_INSUFFICIENT_RESOURCES) {
+				karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_SUCCESS;
+				karg.Status.bSSPStatus = CSMI_SAS_SSP_STATUS_RETRY;
+			}else {
+				karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+				karg.Status.bSSPStatus = CSMI_SAS_SSP_STATUS_FATAL_ERROR;
+			}
+		}else{
+			karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+		}
+
+		break;
+
+	default:
+		karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_INVALID_PARAMETER;
+		break;
+	}
+
+cim_get_task_managment_exit:
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+				sizeof(CSMI_SAS_SSP_TASK_IU_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+			"Unable to write out csmi_sas_task_managment @ %p\n",
+				__FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	map_sas_status_to_csmi - Conversion  for HP Connection Status
+ *	@mpi_sas_status: Sas status returned by the firmware
+ *
+ *	Returns converted connection status
+ *
+ */
+static u8
+map_sas_status_to_csmi(u8 mpi_sas_status)
+{
+	u8  csmi_connect_status;
+
+	switch (mpi_sas_status) {
+
+	case MPI_SASSTATUS_SUCCESS:
+		csmi_connect_status = CSMI_SAS_OPEN_ACCEPT;
+		break;
+
+	case MPI_SASSTATUS_UTC_BAD_DEST:
+		csmi_connect_status = CSMI_SAS_OPEN_REJECT_BAD_DESTINATION;
+		break;
+
+	case MPI_SASSTATUS_UTC_CONNECT_RATE_NOT_SUPPORTED:
+		csmi_connect_status = CSMI_SAS_OPEN_REJECT_RATE_NOT_SUPPORTED;
+		break;
+
+	case MPI_SASSTATUS_UTC_PROTOCOL_NOT_SUPPORTED:
+		csmi_connect_status = CSMI_SAS_OPEN_REJECT_PROTOCOL_NOT_SUPPORTED;
+		break;
+
+	case MPI_SASSTATUS_UTC_STP_RESOURCES_BUSY:
+		csmi_connect_status = CSMI_SAS_OPEN_REJECT_STP_RESOURCES_BUSY;
+		break;
+
+	case MPI_SASSTATUS_UTC_WRONG_DESTINATION:
+		csmi_connect_status = CSMI_SAS_OPEN_REJECT_WRONG_DESTINATION;
+		break;
+
+	case MPI_SASSTATUS_SDSF_NAK_RECEIVED:
+		csmi_connect_status = CSMI_SAS_OPEN_REJECT_RETRY;
+		break;
+
+	case MPI_SASSTATUS_SDSF_CONNECTION_FAILED:
+		csmi_connect_status = CSMI_SAS_OPEN_REJECT_PATHWAY_BLOCKED;
+		break;
+
+	case MPI_SASSTATUS_INITIATOR_RESPONSE_TIMEOUT:
+		csmi_connect_status =  CSMI_SAS_OPEN_REJECT_NO_DESTINATION;
+		break;
+
+	case MPI_SASSTATUS_UNKNOWN_ERROR:
+	case MPI_SASSTATUS_INVALID_FRAME:
+	case MPI_SASSTATUS_UTC_BREAK_RECEIVED:
+	case MPI_SASSTATUS_UTC_PORT_LAYER_REQUEST:
+	case MPI_SASSTATUS_SHORT_INFORMATION_UNIT:
+	case MPI_SASSTATUS_LONG_INFORMATION_UNIT:
+	case MPI_SASSTATUS_XFER_RDY_INCORRECT_WRITE_DATA:
+	case MPI_SASSTATUS_XFER_RDY_REQUEST_OFFSET_ERROR:
+	case MPI_SASSTATUS_XFER_RDY_NOT_EXPECTED:
+	case MPI_SASSTATUS_DATA_INCORRECT_DATA_LENGTH:
+	case MPI_SASSTATUS_DATA_TOO_MUCH_READ_DATA:
+	case MPI_SASSTATUS_DATA_OFFSET_ERROR:
+		csmi_connect_status = CSMI_SAS_OPEN_REJECT_RESERVE_STOP;
+		break;
+
+	default:
+		csmi_connect_status = CSMI_SAS_OPEN_REJECT_RESERVE_STOP;
+		break;
+	}
+
+	return csmi_connect_status;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Prototype Routine for the HP CSMI SAS Phy Control command.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int
+mptctl_csmi_sas_phy_control(unsigned long arg)
+{
+	CSMI_SAS_PHY_CONTROL_BUFFER *uarg = (void *) arg;
+	CSMI_SAS_PHY_CONTROL_BUFFER	 karg;
+	MPT_ADAPTER			*ioc = NULL;
+	int				iocnum;
+
+	dctlprintk((": %s called.\n",__FUNCTION__));
+
+	if (copy_from_user(&karg, uarg, sizeof(CSMI_SAS_PHY_CONTROL_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+		    "Unable to read in csmi_sas_phy_control_buffer struct @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
+	    &ioc)) < 0) || (ioc == NULL)) {
+		dctlprintk((KERN_ERR
+		"%s::%s() @%d - ioc%d not found!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	if (!mptctl_is_this_sas_cntr(ioc)) {
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - ioc%d not SAS controller!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+/* TODO - implement IOCTL here */
+	karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+	dctlprintk((": not implemented\n"));
+
+// cim_sas_phy_control_exit:
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+				sizeof(CSMI_SAS_PHY_CONTROL_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+			"Unable to write out csmi_sas_phy_control_buffer @ %p\n",
+				__FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Prototype Routine for the HP CSMI SAS Get Connector info command.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int
+mptctl_csmi_sas_get_connector_info(unsigned long arg)
+{
+	CSMI_SAS_CONNECTOR_INFO_BUFFER *uarg = (void *) arg;
+	CSMI_SAS_CONNECTOR_INFO_BUFFER	 karg;
+	MPT_ADAPTER			*ioc = NULL;
+	int				iocnum;
+
+	dctlprintk((": %s called.\n",__FUNCTION__));
+
+	if (copy_from_user(&karg, uarg, sizeof(CSMI_SAS_CONNECTOR_INFO_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+		    "Unable to read in csmi_sas_connector_info_buffer struct @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
+	    &ioc)) < 0) || (ioc == NULL)) {
+		dctlprintk((KERN_ERR
+		"%s::%s() @%d - ioc%d not found!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	if (!mptctl_is_this_sas_cntr(ioc)) {
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - ioc%d not SAS controller!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+/* TODO - implement IOCTL here */
+	karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+	dctlprintk((": not implemented\n"));
+
+// cim_sas_get_connector_info_exit:
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+				sizeof(CSMI_SAS_CONNECTOR_INFO_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+			"Unable to write out csmi_sas_connector_info_buffer @ %p\n",
+				__FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Prototype Routine for the HP CSMI SAS Get location command.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int
+mptctl_csmi_sas_get_location(unsigned long arg)
+{
+	CSMI_SAS_CONNECTOR_INFO_BUFFER *uarg = (void *) arg;
+	CSMI_SAS_CONNECTOR_INFO_BUFFER	 karg;
+	MPT_ADAPTER			*ioc = NULL;
+	int				iocnum;
+
+	dctlprintk((": %s called.\n",__FUNCTION__));
+
+	if (copy_from_user(&karg, uarg, sizeof(CSMI_SAS_GET_LOCATION_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+		    "Unable to read in csmi_sas_get_location_buffer struct @ %p\n",
+		    __FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.IoctlHeader.IOControllerNumber,
+	    &ioc)) < 0) || (ioc == NULL)) {
+		dctlprintk((KERN_ERR
+		"%s::%s() @%d - ioc%d not found!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+	if (!mptctl_is_this_sas_cntr(ioc)) {
+		dctlprintk((KERN_ERR
+		    "%s::%s() @%d - ioc%d not SAS controller!\n",
+		    __FILE__, __FUNCTION__, __LINE__, iocnum));
+		return -ENODEV;
+	}
+
+/* TODO - implement IOCTL here */
+	karg.IoctlHeader.ReturnCode = CSMI_SAS_STATUS_FAILED;
+	dctlprintk((": not implemented\n"));
+
+// cim_sas_get_location_exit:
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+				sizeof(CSMI_SAS_GET_LOCATION_BUFFER))) {
+		printk(KERN_ERR "%s@%d::%s() - "
+			"Unable to write out csmi_sas_get_location_buffer @ %p\n",
+				__FILE__, __LINE__, __FUNCTION__, uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+
+}
+#endif // CPQ_CIM
diff -urNp linux-8145/drivers/message/fusion/csmisas.h linux-8150/drivers/message/fusion/csmisas.h
--- linux-8145/drivers/message/fusion/csmisas.h
+++ linux-8150/drivers/message/fusion/csmisas.h
@@ -0,0 +1,1221 @@
+/**************************************************************************
+
+Module Name:
+
+   CSMISAS.H
+
+
+Abstract:
+
+   This file contains constants and data structure definitions used by drivers
+   that support the Common Storage Management Interface specification for
+   SAS or SATA in either the Windows or Linux.
+
+   This should be considered as a reference implementation only.  Changes may 
+   be necessary to accommodate a specific build environment or target OS.
+
+Revision History:
+
+   001  SEF   8/12/03  Initial release.
+   002  SEF   8/20/03  Cleanup to match documentation.
+   003  SEF   9/12/03  Additional cleanup, created combined header
+   004  SEF   9/23/03  Changed base types to match linux defaults
+                       Added RAID signature
+                       Added bControllerFlags to CSMI_SAS_CNTLR_CONFIG
+                       Changed CSMI_SAS_BEGIN_PACK to 8 for common structures
+                       Fixed other typos identified in first compilation test
+   005  SEF  10/03/03  Additions to match first version of CSMI document
+   006  SEF  10/14/03  Fixed typedef struct _CSMI_SAS_SMP_PASSTHRU_BUFFER
+                       Added defines for bConnectionRate
+   007  SEF  10/15/03  Added Firmware Download Control Code and support
+                       Added CSMI revision support
+   008  SEF  10/30/03  No functional change, just updated version to track
+                       spec changes
+   009  SEF  12/09/03  No functional change, just updated version to track
+                       spec changes
+   010  SEF   3/11/04  Fixed typedef struct CSMI_SAS_RAID_DRIVES to include the
+                       bFirmware member that is defined in the spec, but
+                       was missing in this file,
+                       added CC_CSMI_SAS_TASK_MANAGEMENT
+   011  SEF   4/02/04  No functional change, added comment line before
+                       CC_CSMI_SAS_TASK_MANAGEMENT
+   012  SEF   4/16/04  Added IOControllerNumber to linux header,
+                       Modified linux control codes to have upper word of
+                       0xCC77.... to indicate CSMI version 77
+                       Added bSignalClass to CC_CSMI_SET_PHY_INFO
+                       Added CC_CSMI_SAS_PHY_CONTROL support
+   013  SEF   5/14/04  Added CC_CSMI_SAS_GET_CONNECTOR_INFO support
+   014  SEF   5/24/04  No functional change, just updated version to track spec
+                       changes
+   015  SEF   6/16/04  changed bPinout to uPinout to reflect proper size,
+                       changed width of bLocation defines to reflect size
+   016  SEF   6/17/04  changed bLengthOfControls in CSMI_SAS_PHY_CONTROL
+                       to be proper size
+   017  SEF   9/17/04  added CSMI_SAS_SATA_PORT_SELECTOR,
+                       CSMI_SAS_LINK_VIRTUAL, CSMI_SAS_CON_NOT_PRESENT, and
+                       CSMI_SAS_CON_NOT_CONNECTED
+   018  SEF   9/20/04  added CSMI_SAS_PHY_USER_PATTERN, 
+                       changed definition of CSMI_SAS_PHY_FIXED_PATTERN to not
+                       conflict with activate definition
+   019  SEF  12/06/04  added CSMI_SAS_GET_LOCATION
+                       added bSSPStatus to CSMI_SAS_SSP_PASSTHRU_STATUS 
+                       structure
+
+**************************************************************************/
+
+#ifndef _CSMI_SAS_H_
+#define _CSMI_SAS_H_
+
+// CSMI Specification Revision, the intent is that all versions of the
+// specification will be backward compatible after the 1.00 release.
+// Major revision number, corresponds to xxxx. of CSMI specification
+// Minor revision number, corresponds to .xxxx of CSMI specification
+#define CSMI_MAJOR_REVISION   0
+#define CSMI_MINOR_REVISION   83
+
+/*************************************************************************/
+/* TARGET OS LINUX SPECIFIC CODE                                         */
+/*************************************************************************/
+
+// EDM #ifdef _linux
+#ifdef __KERNEL__
+
+
+// Linux base types
+
+#include <linux/types.h>
+
+// pack definition
+
+// EDM #define CSMI_SAS_BEGIN_PACK(x)    pack(x)
+// EDM #define CSMI_SAS_END_PACK         pack()
+
+// IOCTL Control Codes
+// (IoctlHeader.ControlCode)
+
+// Control Codes prior to 0.77
+
+// Control Codes requiring CSMI_ALL_SIGNATURE
+
+// #define CC_CSMI_SAS_GET_DRIVER_INFO    0x12345678
+// #define CC_CSMI_SAS_GET_CNTLR_CONFIG   0x23456781
+// #define CC_CSMI_SAS_GET_CNTLR_STATUS   0x34567812
+// #define CC_CSMI_SAS_FIRMWARE_DOWNLOAD  0x92345678
+
+// Control Codes requiring CSMI_RAID_SIGNATURE
+
+// #define CC_CSMI_SAS_GET_RAID_INFO      0x45678123
+// #define CC_CSMI_SAS_GET_RAID_CONFIG    0x56781234
+
+// Control Codes requiring CSMI_SAS_SIGNATURE
+
+// #define CC_CSMI_SAS_GET_PHY_INFO       0x67812345
+// #define CC_CSMI_SAS_SET_PHY_INFO       0x78123456
+// #define CC_CSMI_SAS_GET_LINK_ERRORS    0x81234567
+// #define CC_CSMI_SAS_SMP_PASSTHRU       0xA1234567
+// #define CC_CSMI_SAS_SSP_PASSTHRU       0xB1234567
+// #define CC_CSMI_SAS_STP_PASSTHRU       0xC1234567
+// #define CC_CSMI_SAS_GET_SATA_SIGNATURE 0xD1234567
+// #define CC_CSMI_SAS_GET_SCSI_ADDRESS   0xE1234567
+// #define CC_CSMI_SAS_GET_DEVICE_ADDRESS 0xF1234567
+// #define CC_CSMI_SAS_TASK_MANAGEMENT    0xA2345678
+
+// Control Codes for 0.77 and later
+
+// Control Codes requiring CSMI_ALL_SIGNATURE
+
+#define CC_CSMI_SAS_GET_DRIVER_INFO    0xCC770001
+#define CC_CSMI_SAS_GET_CNTLR_CONFIG   0xCC770002
+#define CC_CSMI_SAS_GET_CNTLR_STATUS   0xCC770003
+#define CC_CSMI_SAS_FIRMWARE_DOWNLOAD  0xCC770004
+
+// Control Codes requiring CSMI_RAID_SIGNATURE
+
+#define CC_CSMI_SAS_GET_RAID_INFO      0xCC77000A
+#define CC_CSMI_SAS_GET_RAID_CONFIG    0xCC77000B
+
+// Control Codes requiring CSMI_SAS_SIGNATURE
+
+#define CC_CSMI_SAS_GET_PHY_INFO       0xCC770014
+#define CC_CSMI_SAS_SET_PHY_INFO       0xCC770015
+#define CC_CSMI_SAS_GET_LINK_ERRORS    0xCC770016
+#define CC_CSMI_SAS_SMP_PASSTHRU       0xCC770017
+#define CC_CSMI_SAS_SSP_PASSTHRU       0xCC770018
+#define CC_CSMI_SAS_STP_PASSTHRU       0xCC770019
+#define CC_CSMI_SAS_GET_SATA_SIGNATURE 0xCC770020
+#define CC_CSMI_SAS_GET_SCSI_ADDRESS   0xCC770021
+#define CC_CSMI_SAS_GET_DEVICE_ADDRESS 0xCC770022
+#define CC_CSMI_SAS_TASK_MANAGEMENT    0xCC770023
+#define CC_CSMI_SAS_GET_CONNECTOR_INFO 0xCC770024
+#define CC_CSMI_SAS_GET_LOCATION       0xCC770025
+
+// Control Codes requiring CSMI_PHY_SIGNATURE
+
+#define CC_CSMI_SAS_PHY_CONTROL        0xCC77003C
+
+// EDM #pragma CSMI_SAS_BEGIN_PACK(8)
+#pragma pack(8)
+
+// IOCTL_HEADER
+typedef struct _IOCTL_HEADER {
+   __u32 IOControllerNumber;
+	__u32 Length;
+	__u32 ReturnCode;
+	__u32 Timeout;
+	__u16 Direction;
+} IOCTL_HEADER, *PIOCTL_HEADER;
+
+// EDM #pragma CSMI_SAS_END_PACK
+#pragma pack()
+
+#endif
+
+#define __i8    char
+
+/*************************************************************************/
+/* TARGET OS WINDOWS SPECIFIC CODE                                       */
+/*************************************************************************/
+
+#ifdef _WIN32
+
+// windows IOCTL definitions
+
+#ifndef _NTDDSCSIH_
+#include <ntddscsi.h>
+#endif
+
+// pack definition
+
+#if defined _MSC_VER
+   #define CSMI_SAS_BEGIN_PACK(x)    pack(push,x)
+   #define CSMI_SAS_END_PACK         pack(pop)
+#elif defined __BORLANDC__
+   #define CSMI_SAS_BEGIN_PACK(x)    option -a##x
+   #define CSMI_SAS_END_PACK         option -a.
+#else
+   #error "CSMISAS.H - Must externally define a pack compiler designator."
+#endif
+
+// base types
+
+#define __u8    unsigned char
+#define __u32   unsigned long
+#define __u16   unsigned short
+
+#define __i8    char
+
+// IOCTL Control Codes
+// (IoctlHeader.ControlCode)
+
+// Control Codes requiring CSMI_ALL_SIGNATURE
+
+#define CC_CSMI_SAS_GET_DRIVER_INFO    1
+#define CC_CSMI_SAS_GET_CNTLR_CONFIG   2
+#define CC_CSMI_SAS_GET_CNTLR_STATUS   3
+#define CC_CSMI_SAS_FIRMWARE_DOWNLOAD  4
+
+// Control Codes requiring CSMI_RAID_SIGNATURE
+
+#define CC_CSMI_SAS_GET_RAID_INFO      10
+#define CC_CSMI_SAS_GET_RAID_CONFIG    11
+
+// Control Codes requiring CSMI_SAS_SIGNATURE
+
+#define CC_CSMI_SAS_GET_PHY_INFO       20
+#define CC_CSMI_SAS_SET_PHY_INFO       21
+#define CC_CSMI_SAS_GET_LINK_ERRORS    22
+#define CC_CSMI_SAS_SMP_PASSTHRU       23
+#define CC_CSMI_SAS_SSP_PASSTHRU       24
+#define CC_CSMI_SAS_STP_PASSTHRU       25
+#define CC_CSMI_SAS_GET_SATA_SIGNATURE 26
+#define CC_CSMI_SAS_GET_SCSI_ADDRESS   27
+#define CC_CSMI_SAS_GET_DEVICE_ADDRESS 28
+#define CC_CSMI_SAS_TASK_MANAGEMENT    29
+#define CC_CSMI_SAS_GET_CONNECTOR_INFO 30
+#define CC_CSMI_SAS_GET_LOCATION       31
+
+// Control Codes requiring CSMI_PHY_SIGNATURE
+
+#define CC_CSMI_SAS_PHY_CONTROL        60
+
+#define IOCTL_HEADER SRB_IO_CONTROL
+#define PIOCTL_HEADER PSRB_IO_CONTROL
+
+#endif
+
+/*************************************************************************/
+/* TARGET OS NOT DEFINED ERROR                                           */
+/*************************************************************************/
+
+// EDM #if (!_WIN32 && !_linux)
+#if (!_WIN32 && !__KERNEL__)
+   #error "Unknown target OS."
+#endif
+
+/*************************************************************************/
+/* OS INDEPENDENT CODE                                                   */
+/*************************************************************************/
+
+/* * * * * * * * * * Class Independent IOCTL Constants * * * * * * * * * */
+
+// Return codes for all IOCTL's regardless of class
+// (IoctlHeader.ReturnCode)
+
+#define CSMI_SAS_STATUS_SUCCESS              0
+#define CSMI_SAS_STATUS_FAILED               1
+#define CSMI_SAS_STATUS_BAD_CNTL_CODE        2
+#define CSMI_SAS_STATUS_INVALID_PARAMETER    3
+#define CSMI_SAS_STATUS_WRITE_ATTEMPTED      4
+
+// Signature value
+// (IoctlHeader.Signature)
+
+#define CSMI_ALL_SIGNATURE    "CSMIALL"
+
+// Timeout value default of 60 seconds
+// (IoctlHeader.Timeout)
+
+#define CSMI_ALL_TIMEOUT      60
+
+//  Direction values for data flow on this IOCTL
+// (IoctlHeader.Direction, Linux only)
+#define CSMI_SAS_DATA_READ    0
+#define CSMI_SAS_DATA_WRITE   1
+
+// I/O Bus Types
+// ISA and EISA bus types are not supported
+// (bIoBusType)
+
+#define CSMI_SAS_BUS_TYPE_PCI       3
+#define CSMI_SAS_BUS_TYPE_PCMCIA    4
+
+// Controller Status
+// (uStatus)
+
+#define CSMI_SAS_CNTLR_STATUS_GOOD     1
+#define CSMI_SAS_CNTLR_STATUS_FAILED   2
+#define CSMI_SAS_CNTLR_STATUS_OFFLINE  3
+#define CSMI_SAS_CNTLR_STATUS_POWEROFF 4
+
+// Offline Status Reason
+// (uOfflineReason)
+
+#define CSMI_SAS_OFFLINE_REASON_NO_REASON             0
+#define CSMI_SAS_OFFLINE_REASON_INITIALIZING          1
+#define CSMI_SAS_OFFLINE_REASON_BACKSIDE_BUS_DEGRADED 2
+#define CSMI_SAS_OFFLINE_REASON_BACKSIDE_BUS_FAILURE  3
+
+// Controller Class
+// (bControllerClass)
+
+#define CSMI_SAS_CNTLR_CLASS_HBA    5
+
+// Controller Flag bits
+// (uControllerFlags)
+
+#define CSMI_SAS_CNTLR_SAS_HBA   0x00000001
+#define CSMI_SAS_CNTLR_SAS_RAID  0x00000002
+#define CSMI_SAS_CNTLR_SATA_HBA  0x00000004
+#define CSMI_SAS_CNTLR_SATA_RAID 0x00000008
+
+// for firmware download
+#define CSMI_SAS_CNTLR_FWD_SUPPORT  0x00010000
+#define CSMI_SAS_CNTLR_FWD_ONLINE   0x00020000
+#define CSMI_SAS_CNTLR_FWD_SRESET   0x00040000
+#define CSMI_SAS_CNTLR_FWD_HRESET   0x00080000
+#define CSMI_SAS_CNTLR_FWD_RROM     0x00100000
+
+// Download Flag bits
+// (uDownloadFlags)
+#define CSMI_SAS_FWD_VALIDATE       0x00000001
+#define CSMI_SAS_FWD_SOFT_RESET     0x00000002
+#define CSMI_SAS_FWD_HARD_RESET     0x00000004
+
+// Firmware Download Status
+// (usStatus)
+#define CSMI_SAS_FWD_SUCCESS        0
+#define CSMI_SAS_FWD_FAILED         1
+#define CSMI_SAS_FWD_USING_RROM     2
+#define CSMI_SAS_FWD_REJECT         3
+#define CSMI_SAS_FWD_DOWNREV        4
+
+// Firmware Download Severity
+// (usSeverity>
+#define CSMI_SAS_FWD_INFORMATION    0
+#define CSMI_SAS_FWD_WARNING        1
+#define CSMI_SAS_FWD_ERROR          2
+#define CSMI_SAS_FWD_FATAL          3
+
+/* * * * * * * * * * SAS RAID Class IOCTL Constants  * * * * * * * * */
+
+// Return codes for the RAID IOCTL's regardless of class
+// (IoctlHeader.ControlCode)
+
+#define CSMI_SAS_RAID_SET_OUT_OF_RANGE       1000
+
+// Signature value
+// (IoctlHeader.Signature)
+
+#define CSMI_RAID_SIGNATURE    "CSMIARY"
+
+// Timeout value default of 60 seconds
+// (IoctlHeader.Timeout)
+
+#define CSMI_RAID_TIMEOUT      60
+
+// RAID Types
+// (bRaidType)
+#define CSMI_SAS_RAID_TYPE_NONE     0
+#define CSMI_SAS_RAID_TYPE_0        1
+#define CSMI_SAS_RAID_TYPE_1        2
+#define CSMI_SAS_RAID_TYPE_10       3
+#define CSMI_SAS_RAID_TYPE_5        4
+#define CSMI_SAS_RAID_TYPE_15       5
+#define CSMI_SAS_RAID_TYPE_OTHER    255
+
+// RAID Status
+// (bStatus)
+#define CSMI_SAS_RAID_SET_STATUS_OK          0
+#define CSMI_SAS_RAID_SET_STATUS_DEGRADED    1
+#define CSMI_SAS_RAID_SET_STATUS_REBUILDING  2
+#define CSMI_SAS_RAID_SET_STATUS_FAILED      3
+
+// RAID Drive Status
+// (bDriveStatus)
+#define CSMI_SAS_DRIVE_STATUS_OK          0
+#define CSMI_SAS_DRIVE_STATUS_REBUILDING  1
+#define CSMI_SAS_DRIVE_STATUS_FAILED      2
+#define CSMI_SAS_DRIVE_STATUS_DEGRADED    3
+
+// RAID Drive Usage
+// (bDriveUsage)
+#define CSMI_SAS_DRIVE_CONFIG_NOT_USED 0
+#define CSMI_SAS_DRIVE_CONFIG_MEMBER   1
+#define CSMI_SAS_DRIVE_CONFIG_SPARE    2
+
+/* * * * * * * * * * SAS HBA Class IOCTL Constants * * * * * * * * * */
+
+// Return codes for SAS IOCTL's
+// (IoctlHeader.ReturnCode)
+
+#define CSMI_SAS_PHY_INFO_CHANGED            CSMI_SAS_STATUS_SUCCESS
+#define CSMI_SAS_PHY_INFO_NOT_CHANGEABLE     2000
+#define CSMI_SAS_LINK_RATE_OUT_OF_RANGE      2001
+
+#define CSMI_SAS_PHY_DOES_NOT_EXIST          2002
+#define CSMI_SAS_PHY_DOES_NOT_MATCH_PORT     2003
+#define CSMI_SAS_PHY_CANNOT_BE_SELECTED      2004
+#define CSMI_SAS_SELECT_PHY_OR_PORT          2005
+#define CSMI_SAS_PORT_DOES_NOT_EXIST         2006
+#define CSMI_SAS_PORT_CANNOT_BE_SELECTED     2007
+#define CSMI_SAS_CONNECTION_FAILED           2008
+
+#define CSMI_SAS_NO_SATA_DEVICE              2009
+#define CSMI_SAS_NO_SATA_SIGNATURE           2010
+#define CSMI_SAS_SCSI_EMULATION              2011
+#define CSMI_SAS_NOT_AN_END_DEVICE           2012
+#define CSMI_SAS_NO_SCSI_ADDRESS             2013
+#define CSMI_SAS_NO_DEVICE_ADDRESS           2014
+
+// Signature value
+// (IoctlHeader.Signature)
+
+#define CSMI_SAS_SIGNATURE    "CSMISAS"
+
+// Timeout value default of 60 seconds
+// (IoctlHeader.Timeout)
+
+#define CSMI_SAS_TIMEOUT      60
+
+// Device types
+// (bDeviceType)
+
+#define CSMI_SAS_PHY_UNUSED               0x00
+#define CSMI_SAS_NO_DEVICE_ATTACHED       0x00
+#define CSMI_SAS_END_DEVICE               0x10
+#define CSMI_SAS_EDGE_EXPANDER_DEVICE     0x20
+#define CSMI_SAS_FANOUT_EXPANDER_DEVICE   0x30
+
+// Protocol options
+// (bInitiatorPortProtocol, bTargetPortProtocol)
+
+#define CSMI_SAS_PROTOCOL_SATA   0x01
+#define CSMI_SAS_PROTOCOL_SMP    0x02
+#define CSMI_SAS_PROTOCOL_STP    0x04
+#define CSMI_SAS_PROTOCOL_SSP    0x08
+
+// Negotiated and hardware link rates
+// (bNegotiatedLinkRate, bMinimumLinkRate, bMaximumLinkRate)
+
+#define CSMI_SAS_LINK_RATE_UNKNOWN  0x00
+#define CSMI_SAS_PHY_DISABLED       0x01
+#define CSMI_SAS_LINK_RATE_FAILED   0x02
+#define CSMI_SAS_SATA_SPINUP_HOLD   0x03
+#define CSMI_SAS_SATA_PORT_SELECTOR 0x04
+#define CSMI_SAS_LINK_RATE_1_5_GBPS 0x08
+#define CSMI_SAS_LINK_RATE_3_0_GBPS 0x09
+#define CSMI_SAS_LINK_VIRTUAL       0x10
+
+// Discover state
+// (bAutoDiscover)
+
+#define CSMI_SAS_DISCOVER_NOT_SUPPORTED   0x00
+#define CSMI_SAS_DISCOVER_NOT_STARTED     0x01
+#define CSMI_SAS_DISCOVER_IN_PROGRESS     0x02
+#define CSMI_SAS_DISCOVER_COMPLETE        0x03
+#define CSMI_SAS_DISCOVER_ERROR           0x04
+
+// Programmed link rates
+// (bMinimumLinkRate, bMaximumLinkRate)
+// (bProgrammedMinimumLinkRate, bProgrammedMaximumLinkRate)
+
+#define CSMI_SAS_PROGRAMMED_LINK_RATE_UNCHANGED 0x00
+#define CSMI_SAS_PROGRAMMED_LINK_RATE_1_5_GBPS  0x08
+#define CSMI_SAS_PROGRAMMED_LINK_RATE_3_0_GBPS  0x09
+
+// Link rate
+// (bNegotiatedLinkRate in CSMI_SAS_SET_PHY_INFO)
+
+#define CSMI_SAS_LINK_RATE_NEGOTIATE      0x00
+#define CSMI_SAS_LINK_RATE_PHY_DISABLED   0x01
+
+// Signal class
+// (bSignalClass in CSMI_SAS_SET_PHY_INFO)
+
+#define CSMI_SAS_SIGNAL_CLASS_UNKNOWN     0x00
+#define CSMI_SAS_SIGNAL_CLASS_DIRECT      0x01
+#define CSMI_SAS_SIGNAL_CLASS_SERVER      0x02
+#define CSMI_SAS_SIGNAL_CLASS_ENCLOSURE   0x03
+
+// Link error reset
+// (bResetCounts)
+
+#define CSMI_SAS_LINK_ERROR_DONT_RESET_COUNTS   0x00
+#define CSMI_SAS_LINK_ERROR_RESET_COUNTS        0x01
+
+// Phy identifier
+// (bPhyIdentifier)
+
+#define CSMI_SAS_USE_PORT_IDENTIFIER   0xFF
+
+// Port identifier
+// (bPortIdentifier)
+
+#define CSMI_SAS_IGNORE_PORT           0xFF
+
+// Programmed link rates
+// (bConnectionRate)
+
+#define CSMI_SAS_LINK_RATE_NEGOTIATED  0x00
+#define CSMI_SAS_LINK_RATE_1_5_GBPS    0x08
+#define CSMI_SAS_LINK_RATE_3_0_GBPS    0x09
+
+// Connection status
+// (bConnectionStatus)
+
+#define CSMI_SAS_OPEN_ACCEPT                          0
+#define CSMI_SAS_OPEN_REJECT_BAD_DESTINATION          1
+#define CSMI_SAS_OPEN_REJECT_RATE_NOT_SUPPORTED       2
+#define CSMI_SAS_OPEN_REJECT_NO_DESTINATION           3
+#define CSMI_SAS_OPEN_REJECT_PATHWAY_BLOCKED          4
+#define CSMI_SAS_OPEN_REJECT_PROTOCOL_NOT_SUPPORTED   5
+#define CSMI_SAS_OPEN_REJECT_RESERVE_ABANDON          6
+#define CSMI_SAS_OPEN_REJECT_RESERVE_CONTINUE         7
+#define CSMI_SAS_OPEN_REJECT_RESERVE_INITIALIZE       8
+#define CSMI_SAS_OPEN_REJECT_RESERVE_STOP             9
+#define CSMI_SAS_OPEN_REJECT_RETRY                    10
+#define CSMI_SAS_OPEN_REJECT_STP_RESOURCES_BUSY       11
+#define CSMI_SAS_OPEN_REJECT_WRONG_DESTINATION        12
+
+// SSP Status
+// (bSSPStatus)
+
+#define CSMI_SAS_SSP_STATUS_UNKNOWN     0x00
+#define CSMI_SAS_SSP_STATUS_WAITING     0x01
+#define CSMI_SAS_SSP_STATUS_COMPLETED   0x02
+#define CSMI_SAS_SSP_STATUS_FATAL_ERROR 0x03
+#define CSMI_SAS_SSP_STATUS_RETRY       0x04
+#define CSMI_SAS_SSP_STATUS_NO_TAG      0x05
+
+// SSP Flags
+// (uFlags)
+
+#define CSMI_SAS_SSP_READ           0x00000001
+#define CSMI_SAS_SSP_WRITE          0x00000002
+#define CSMI_SAS_SSP_UNSPECIFIED    0x00000004
+
+#define CSMI_SAS_SSP_TASK_ATTRIBUTE_SIMPLE         0x00000000
+#define CSMI_SAS_SSP_TASK_ATTRIBUTE_HEAD_OF_QUEUE  0x00000010
+#define CSMI_SAS_SSP_TASK_ATTRIBUTE_ORDERED        0x00000020
+#define CSMI_SAS_SSP_TASK_ATTRIBUTE_ACA            0x00000040
+
+// SSP Data present
+// (bDataPresent)
+
+#define CSMI_SAS_SSP_NO_DATA_PRESENT         0x00
+#define CSMI_SAS_SSP_RESPONSE_DATA_PRESENT   0x01
+#define CSMI_SAS_SSP_SENSE_DATA_PRESENT      0x02
+
+// STP Flags
+// (uFlags)
+
+#define CSMI_SAS_STP_READ           0x00000001
+#define CSMI_SAS_STP_WRITE          0x00000002
+#define CSMI_SAS_STP_UNSPECIFIED    0x00000004
+#define CSMI_SAS_STP_PIO            0x00000010
+#define CSMI_SAS_STP_DMA            0x00000020
+#define CSMI_SAS_STP_PACKET         0x00000040
+#define CSMI_SAS_STP_DMA_QUEUED     0x00000080
+#define CSMI_SAS_STP_EXECUTE_DIAG   0x00000100
+#define CSMI_SAS_STP_RESET_DEVICE   0x00000200
+
+// Task Management Flags
+// (uFlags)
+
+#define CSMI_SAS_TASK_IU               0x00000001
+#define CSMI_SAS_HARD_RESET_SEQUENCE   0x00000002
+#define CSMI_SAS_SUPPRESS_RESULT       0x00000004
+
+// Task Management Functions
+// (bTaskManagement)
+
+#define CSMI_SAS_SSP_ABORT_TASK           0x01
+#define CSMI_SAS_SSP_ABORT_TASK_SET       0x02
+#define CSMI_SAS_SSP_CLEAR_TASK_SET       0x04
+#define CSMI_SAS_SSP_LOGICAL_UNIT_RESET   0x08
+#define CSMI_SAS_SSP_CLEAR_ACA            0x40
+#define CSMI_SAS_SSP_QUERY_TASK           0x80
+
+// Task Management Information
+// (uInformation)
+
+#define CSMI_SAS_SSP_TEST           1
+#define CSMI_SAS_SSP_EXCEEDED       2
+#define CSMI_SAS_SSP_DEMAND         3
+#define CSMI_SAS_SSP_TRIGGER        4
+
+// Connector Pinout Information
+// (uPinout)
+
+#define CSMI_SAS_CON_UNKNOWN              0x00000001
+#define CSMI_SAS_CON_SFF_8482             0x00000002
+#define CSMI_SAS_CON_SFF_8470_LANE_1      0x00000100
+#define CSMI_SAS_CON_SFF_8470_LANE_2      0x00000200
+#define CSMI_SAS_CON_SFF_8470_LANE_3      0x00000400
+#define CSMI_SAS_CON_SFF_8470_LANE_4      0x00000800
+#define CSMI_SAS_CON_SFF_8484_LANE_1      0x00010000
+#define CSMI_SAS_CON_SFF_8484_LANE_2      0x00020000
+#define CSMI_SAS_CON_SFF_8484_LANE_3      0x00040000
+#define CSMI_SAS_CON_SFF_8484_LANE_4      0x00080000
+
+// Connector Location Information
+// (bLocation)
+
+// same as uPinout above...
+// #define CSMI_SAS_CON_UNKNOWN              0x01
+#define CSMI_SAS_CON_INTERNAL             0x02
+#define CSMI_SAS_CON_EXTERNAL             0x04
+#define CSMI_SAS_CON_SWITCHABLE           0x08
+#define CSMI_SAS_CON_AUTO                 0x10
+#define CSMI_SAS_CON_NOT_PRESENT          0x20
+#define CSMI_SAS_CON_NOT_CONNECTED        0x80
+
+// Device location identification
+// (bIdentify)
+
+#define CSMI_SAS_LOCATE_UNKNOWN           0x00
+#define CSMI_SAS_LOCATE_FORCE_OFF         0x01
+#define CSMI_SAS_LOCATE_FORCE_ON          0x02
+
+// Location Valid flags
+// (uLocationFlags)
+
+#define CSMI_SAS_LOCATE_SAS_ADDRESS_VALID           0x00000001
+#define CSMI_SAS_LOCATE_SAS_LUN_VALID               0x00000002
+#define CSMI_SAS_LOCATE_ENCLOSURE_IDENTIFIER_VALID  0x00000004
+#define CSMI_SAS_LOCATE_ENCLOSURE_NAME_VALID        0x00000008
+#define CSMI_SAS_LOCATE_BAY_PREFIX_VALID            0x00000010
+#define CSMI_SAS_LOCATE_BAY_IDENTIFIER_VALID        0x00000020
+#define CSMI_SAS_LOCATE_LOCATION_STATE_VALID        0x00000040
+
+/* * * * * * * * SAS Phy Control Class IOCTL Constants * * * * * * * * */
+
+// Return codes for SAS Phy Control IOCTL's
+// (IoctlHeader.ReturnCode)
+
+// Signature value
+// (IoctlHeader.Signature)
+
+#define CSMI_PHY_SIGNATURE    "CSMIPHY"
+
+// Phy Control Functions
+// (bFunction)
+
+// values 0x00 to 0xFF are consistent in definition with the SMP PHY CONTROL 
+// function defined in the SAS spec
+#define CSMI_SAS_PC_NOP                   0x00000000
+#define CSMI_SAS_PC_LINK_RESET            0x00000001
+#define CSMI_SAS_PC_HARD_RESET            0x00000002
+#define CSMI_SAS_PC_PHY_DISABLE           0x00000003
+// 0x04 to 0xFF reserved...
+#define CSMI_SAS_PC_GET_PHY_SETTINGS      0x00000100
+
+// Link Flags
+#define CSMI_SAS_PHY_ACTIVATE_CONTROL     0x00000001
+#define CSMI_SAS_PHY_UPDATE_SPINUP_RATE   0x00000002
+#define CSMI_SAS_PHY_AUTO_COMWAKE         0x00000004
+
+// Device Types for Phy Settings
+// (bType)
+#define CSMI_SAS_UNDEFINED 0x00
+#define CSMI_SAS_SATA      0x01
+#define CSMI_SAS_SAS       0x02
+
+// Transmitter Flags
+// (uTransmitterFlags)
+#define CSMI_SAS_PHY_PREEMPHASIS_DISABLED    0x00000001
+
+// Receiver Flags
+// (uReceiverFlags)
+#define CSMI_SAS_PHY_EQUALIZATION_DISABLED   0x00000001
+
+// Pattern Flags
+// (uPatternFlags)
+// #define CSMI_SAS_PHY_ACTIVATE_CONTROL     0x00000001
+#define CSMI_SAS_PHY_DISABLE_SCRAMBLING      0x00000002
+#define CSMI_SAS_PHY_DISABLE_ALIGN           0x00000004
+#define CSMI_SAS_PHY_DISABLE_SSC             0x00000008
+
+#define CSMI_SAS_PHY_FIXED_PATTERN           0x00000010
+#define CSMI_SAS_PHY_USER_PATTERN            0x00000020
+
+// Fixed Patterns
+// (bFixedPattern)
+#define CSMI_SAS_PHY_CJPAT                   0x00000001
+#define CSMI_SAS_PHY_ALIGN                   0x00000002
+
+// Type Flags
+// (bTypeFlags)
+#define CSMI_SAS_PHY_POSITIVE_DISPARITY      0x01
+#define CSMI_SAS_PHY_NEGATIVE_DISPARITY      0x02
+#define CSMI_SAS_PHY_CONTROL_CHARACTER       0x04
+
+// Miscellaneous
+#define SLOT_NUMBER_UNKNOWN   0xFFFF
+
+/*************************************************************************/
+/* DATA STRUCTURES                                                       */
+/*************************************************************************/
+
+/* * * * * * * * * * Class Independent Structures * * * * * * * * * */
+
+// EDM #pragma CSMI_SAS_BEGIN_PACK(8)
+#pragma pack(8)
+
+// CC_CSMI_SAS_DRIVER_INFO
+
+typedef struct _CSMI_SAS_DRIVER_INFO {
+   __u8  szName[81];
+   __u8  szDescription[81];
+   __u16 usMajorRevision;
+   __u16 usMinorRevision;
+   __u16 usBuildRevision;
+   __u16 usReleaseRevision;
+   __u16 usCSMIMajorRevision;
+   __u16 usCSMIMinorRevision;
+} CSMI_SAS_DRIVER_INFO,
+  *PCSMI_SAS_DRIVER_INFO;
+
+typedef struct _CSMI_SAS_DRIVER_INFO_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_DRIVER_INFO Information;
+} CSMI_SAS_DRIVER_INFO_BUFFER,
+  *PCSMI_SAS_DRIVER_INFO_BUFFER;
+
+// CC_CSMI_SAS_CNTLR_CONFIGURATION
+
+typedef struct _CSMI_SAS_PCI_BUS_ADDRESS {
+   __u8  bBusNumber;
+   __u8  bDeviceNumber;
+   __u8  bFunctionNumber;
+   __u8  bReserved;
+} CSMI_SAS_PCI_BUS_ADDRESS,
+  *PCSMI_SAS_PCI_BUS_ADDRESS;
+
+typedef union _CSMI_SAS_IO_BUS_ADDRESS {
+   CSMI_SAS_PCI_BUS_ADDRESS PciAddress;
+   __u8  bReserved[32];
+} CSMI_SAS_IO_BUS_ADDRESS,
+  *PCSMI_SAS_IO_BUS_ADDRESS;
+
+typedef struct _CSMI_SAS_CNTLR_CONFIG {
+   __u32 uBaseIoAddress;
+   struct {
+      __u32 uLowPart;
+      __u32 uHighPart;
+   } BaseMemoryAddress;
+   __u32 uBoardID;
+   __u16 usSlotNumber;
+   __u8  bControllerClass;
+   __u8  bIoBusType;
+   CSMI_SAS_IO_BUS_ADDRESS BusAddress;
+   __u8  szSerialNumber[81];
+   __u16 usMajorRevision;
+   __u16 usMinorRevision;
+   __u16 usBuildRevision;
+   __u16 usReleaseRevision;
+   __u16 usBIOSMajorRevision;
+   __u16 usBIOSMinorRevision;
+   __u16 usBIOSBuildRevision;
+   __u16 usBIOSReleaseRevision;
+   __u32 uControllerFlags;
+   __u16 usRromMajorRevision;
+   __u16 usRromMinorRevision;
+   __u16 usRromBuildRevision;
+   __u16 usRromReleaseRevision;
+   __u16 usRromBIOSMajorRevision;
+   __u16 usRromBIOSMinorRevision;
+   __u16 usRromBIOSBuildRevision;
+   __u16 usRromBIOSReleaseRevision;
+   __u8  bReserved[7];
+} CSMI_SAS_CNTLR_CONFIG,
+  *PCSMI_SAS_CNTLR_CONFIG;
+
+typedef struct _CSMI_SAS_CNTLR_CONFIG_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_CNTLR_CONFIG Configuration;
+} CSMI_SAS_CNTLR_CONFIG_BUFFER,
+  *PCSMI_SAS_CNTLR_CONFIG_BUFFER;
+
+// CC_CSMI_SAS_CNTLR_STATUS
+
+typedef struct _CSMI_SAS_CNTLR_STATUS {
+   __u32 uStatus;
+   __u32 uOfflineReason;
+   __u8  bReserved[28];
+} CSMI_SAS_CNTLR_STATUS,
+  *PCSMI_SAS_CNTLR_STATUS;
+
+typedef struct _CSMI_SAS_CNTLR_STATUS_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_CNTLR_STATUS Status;
+} CSMI_SAS_CNTLR_STATUS_BUFFER,
+  *PCSMI_SAS_CNTLR_STATUS_BUFFER;
+
+// CC_CSMI_SAS_FIRMWARE_DOWNLOAD
+
+typedef struct _CSMI_SAS_FIRMWARE_DOWNLOAD {
+   __u32 uBufferLength;
+   __u32 uDownloadFlags;
+   __u8  bReserved[32];
+   __u16 usStatus;
+   __u16 usSeverity;
+} CSMI_SAS_FIRMWARE_DOWNLOAD,
+  *PCSMI_SAS_FIRMWARE_DOWNLOAD;
+
+typedef struct _CSMI_SAS_FIRMWARE_DOWNLOAD_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_FIRMWARE_DOWNLOAD Information;
+   __u8  bDataBuffer[1];
+} CSMI_SAS_FIRMWARE_DOWNLOAD_BUFFER,
+  *PCSMI_SAS_FIRMWARE_DOWNLOAD_BUFFER;
+
+// CC_CSMI_SAS_RAID_INFO
+
+typedef struct _CSMI_SAS_RAID_INFO {
+   __u32 uNumRaidSets;
+   __u32 uMaxDrivesPerSet;
+   __u8  bReserved[92];
+} CSMI_SAS_RAID_INFO,
+  *PCSMI_SAS_RAID_INFO;
+
+typedef struct _CSMI_SAS_RAID_INFO_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_RAID_INFO Information;
+} CSMI_SAS_RAID_INFO_BUFFER,
+  *PCSMI_SAS_RAID_INFO_BUFFER;
+
+// CC_CSMI_SAS_GET_RAID_CONFIG
+
+typedef struct _CSMI_SAS_RAID_DRIVES {
+   __u8  bModel[40];
+   __u8  bFirmware[8];
+   __u8  bSerialNumber[40];
+   __u8  bSASAddress[8];
+   __u8  bSASLun[8];
+   __u8  bDriveStatus;
+   __u8  bDriveUsage;
+   __u8  bReserved[30];
+} CSMI_SAS_RAID_DRIVES,
+   *PCSMI_SAS_RAID_DRIVES;
+
+typedef struct _CSMI_SAS_RAID_CONFIG {
+   __u32 uRaidSetIndex;
+   __u32 uCapacity;
+   __u32 uStripeSize;
+   __u8  bRaidType;
+   __u8  bStatus;
+   __u8  bInformation;
+   __u8  bDriveCount;
+   __u8  bReserved[20];
+   CSMI_SAS_RAID_DRIVES Drives[1];
+} CSMI_SAS_RAID_CONFIG,
+   *PCSMI_SAS_RAID_CONFIG;
+
+typedef struct _CSMI_SAS_RAID_CONFIG_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_RAID_CONFIG Configuration;
+} CSMI_SAS_RAID_CONFIG_BUFFER,
+  *PCSMI_SAS_RAID_CONFIG_BUFFER;
+
+
+/* * * * * * * * * * SAS HBA Class Structures * * * * * * * * * */
+
+// CC_CSMI_SAS_GET_PHY_INFO
+
+typedef struct _CSMI_SAS_IDENTIFY {
+   __u8  bDeviceType;
+   __u8  bRestricted;
+   __u8  bInitiatorPortProtocol;
+   __u8  bTargetPortProtocol;
+   __u8  bRestricted2[8];
+   __u8  bSASAddress[8];
+   __u8  bPhyIdentifier;
+   __u8  bSignalClass;
+   __u8  bReserved[6];
+} CSMI_SAS_IDENTIFY,
+  *PCSMI_SAS_IDENTIFY;
+
+typedef struct _CSMI_SAS_PHY_ENTITY {
+   CSMI_SAS_IDENTIFY Identify;
+   __u8  bPortIdentifier;
+   __u8  bNegotiatedLinkRate;
+   __u8  bMinimumLinkRate;
+   __u8  bMaximumLinkRate;
+   __u8  bPhyChangeCount;
+   __u8  bAutoDiscover;
+   __u8  bReserved[2];
+   CSMI_SAS_IDENTIFY Attached;
+} CSMI_SAS_PHY_ENTITY,
+  *PCSMI_SAS_PHY_ENTITY;
+
+typedef struct _CSMI_SAS_PHY_INFO {
+   __u8  bNumberOfPhys;
+   __u8  bReserved[3];
+   CSMI_SAS_PHY_ENTITY Phy[32];
+} CSMI_SAS_PHY_INFO,
+  *PCSMI_SAS_PHY_INFO;
+
+typedef struct _CSMI_SAS_PHY_INFO_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_PHY_INFO Information;
+} CSMI_SAS_PHY_INFO_BUFFER,
+  *PCSMI_SAS_PHY_INFO_BUFFER;
+
+// CC_CSMI_SAS_SET_PHY_INFO
+
+typedef struct _CSMI_SAS_SET_PHY_INFO {
+   __u8  bPhyIdentifier;
+   __u8  bNegotiatedLinkRate;
+   __u8  bProgrammedMinimumLinkRate;
+   __u8  bProgrammedMaximumLinkRate;
+   __u8  bSignalClass;
+   __u8  bReserved[3];
+} CSMI_SAS_SET_PHY_INFO,
+  *PCSMI_SAS_SET_PHY_INFO;
+
+typedef struct _CSMI_SAS_SET_PHY_INFO_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_SET_PHY_INFO Information;
+} CSMI_SAS_SET_PHY_INFO_BUFFER,
+  *PCSMI_SAS_SET_PHY_INFO_BUFFER;
+
+// CC_CSMI_SAS_GET_LINK_ERRORS
+
+typedef struct _CSMI_SAS_LINK_ERRORS {
+   __u8  bPhyIdentifier;
+   __u8  bResetCounts;
+   __u8  bReserved[2];
+   __u32 uInvalidDwordCount;
+   __u32 uRunningDisparityErrorCount;
+   __u32 uLossOfDwordSyncCount;
+   __u32 uPhyResetProblemCount;
+} CSMI_SAS_LINK_ERRORS,
+  *PCSMI_SAS_LINK_ERRORS;
+
+typedef struct _CSMI_SAS_LINK_ERRORS_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_LINK_ERRORS Information;
+} CSMI_SAS_LINK_ERRORS_BUFFER,
+  *PCSMI_SAS_LINK_ERRORS_BUFFER;
+
+// CC_CSMI_SAS_SMP_PASSTHRU
+
+typedef struct _CSMI_SAS_SMP_REQUEST {
+   __u8  bFrameType;
+   __u8  bFunction;
+   __u8  bReserved[2];
+   __u8  bAdditionalRequestBytes[1016];
+} CSMI_SAS_SMP_REQUEST,
+  *PCSMI_SAS_SMP_REQUEST;
+
+typedef struct _CSMI_SAS_SMP_RESPONSE {
+   __u8  bFrameType;
+   __u8  bFunction;
+   __u8  bFunctionResult;
+   __u8  bReserved;
+   __u8  bAdditionalResponseBytes[1016];
+} CSMI_SAS_SMP_RESPONSE,
+  *PCSMI_SAS_SMP_RESPONSE;
+
+typedef struct _CSMI_SAS_SMP_PASSTHRU {
+   __u8  bPhyIdentifier;
+   __u8  bPortIdentifier;
+   __u8  bConnectionRate;
+   __u8  bReserved;
+   __u8  bDestinationSASAddress[8];
+   __u32 uRequestLength;
+   CSMI_SAS_SMP_REQUEST Request;
+   __u8  bConnectionStatus;
+   __u8  bReserved2[3];
+   __u32 uResponseBytes;
+   CSMI_SAS_SMP_RESPONSE Response;
+} CSMI_SAS_SMP_PASSTHRU,
+  *PCSMI_SAS_SMP_PASSTHRU;
+
+typedef struct _CSMI_SAS_SMP_PASSTHRU_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_SMP_PASSTHRU Parameters;
+} CSMI_SAS_SMP_PASSTHRU_BUFFER,
+  *PCSMI_SAS_SMP_PASSTHRU_BUFFER;
+
+// CC_CSMI_SAS_SSP_PASSTHRU
+
+typedef struct _CSMI_SAS_SSP_PASSTHRU {
+   __u8  bPhyIdentifier;
+   __u8  bPortIdentifier;
+   __u8  bConnectionRate;
+   __u8  bReserved;
+   __u8  bDestinationSASAddress[8];
+   __u8  bLun[8];
+   __u8  bCDBLength;
+   __u8  bAdditionalCDBLength;
+   __u8  bReserved2[2];
+   __u8  bCDB[16];
+   __u32 uFlags;
+   __u8  bAdditionalCDB[24];
+   __u32 uDataLength;
+} CSMI_SAS_SSP_PASSTHRU,
+  *PCSMI_SAS_SSP_PASSTHRU;
+
+typedef struct _CSMI_SAS_SSP_PASSTHRU_STATUS {
+   __u8  bConnectionStatus;
+   __u8  bSSPStatus;
+   __u8  bReserved[2];
+   __u8  bDataPresent;
+   __u8  bStatus;
+   __u8  bResponseLength[2];
+   __u8  bResponse[256];
+   __u32 uDataBytes;
+} CSMI_SAS_SSP_PASSTHRU_STATUS,
+  *PCSMI_SAS_SSP_PASSTHRU_STATUS;
+
+typedef struct _CSMI_SAS_SSP_PASSTHRU_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_SSP_PASSTHRU Parameters;
+   CSMI_SAS_SSP_PASSTHRU_STATUS Status;
+   __u8  bDataBuffer[1];
+} CSMI_SAS_SSP_PASSTHRU_BUFFER,
+  *PCSMI_SAS_SSP_PASSTHRU_BUFFER;
+
+// CC_CSMI_SAS_STP_PASSTHRU
+
+typedef struct _CSMI_SAS_STP_PASSTHRU {
+   __u8  bPhyIdentifier;
+   __u8  bPortIdentifier;
+   __u8  bConnectionRate;
+   __u8  bReserved;
+   __u8  bDestinationSASAddress[8];
+   __u8  bReserved2[4];
+   __u8  bCommandFIS[20];
+   __u32 uFlags;
+   __u32 uDataLength;
+} CSMI_SAS_STP_PASSTHRU,
+  *PCSMI_SAS_STP_PASSTHRU;
+
+typedef struct _CSMI_SAS_STP_PASSTHRU_STATUS {
+   __u8  bConnectionStatus;
+   __u8  bReserved[3];
+   __u8  bStatusFIS[20];
+   __u32 uSCR[16];
+   __u32 uDataBytes;
+} CSMI_SAS_STP_PASSTHRU_STATUS,
+  *PCSMI_SAS_STP_PASSTHRU_STATUS;
+
+typedef struct _CSMI_SAS_STP_PASSTHRU_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_STP_PASSTHRU Parameters;
+   CSMI_SAS_STP_PASSTHRU_STATUS Status;
+   __u8  bDataBuffer[1];
+} CSMI_SAS_STP_PASSTHRU_BUFFER,
+  *PCSMI_SAS_STP_PASSTHRU_BUFFER;
+
+// CC_CSMI_SAS_GET_SATA_SIGNATURE
+
+typedef struct _CSMI_SAS_SATA_SIGNATURE {
+   __u8  bPhyIdentifier;
+   __u8  bReserved[3];
+   __u8  bSignatureFIS[20];
+} CSMI_SAS_SATA_SIGNATURE,
+  *PCSMI_SAS_SATA_SIGNATURE;
+
+typedef struct _CSMI_SAS_SATA_SIGNATURE_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_SATA_SIGNATURE Signature;
+} CSMI_SAS_SATA_SIGNATURE_BUFFER,
+  *PCSMI_SAS_SATA_SIGNATURE_BUFFER;
+
+// CC_CSMI_SAS_GET_SCSI_ADDRESS
+
+typedef struct _CSMI_SAS_GET_SCSI_ADDRESS_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   __u8  bSASAddress[8];
+   __u8  bSASLun[8];
+   __u8  bHostIndex;
+   __u8  bPathId;
+   __u8  bTargetId;
+   __u8  bLun;
+} CSMI_SAS_GET_SCSI_ADDRESS_BUFFER,
+   *PCSMI_SAS_GET_SCSI_ADDRESS_BUFFER;
+
+// CC_CSMI_SAS_GET_DEVICE_ADDRESS
+
+typedef struct _CSMI_SAS_GET_DEVICE_ADDRESS_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   __u8  bHostIndex;
+   __u8  bPathId;
+   __u8  bTargetId;
+   __u8  bLun;
+   __u8  bSASAddress[8];
+   __u8  bSASLun[8];
+} CSMI_SAS_GET_DEVICE_ADDRESS_BUFFER,
+  *PCSMI_SAS_GET_DEVICE_ADDRESS_BUFFER;
+
+// CC_CSMI_SAS_TASK_MANAGEMENT
+
+typedef struct _CSMI_SAS_SSP_TASK_IU {
+   __u8  bHostIndex;
+   __u8  bPathId;
+   __u8  bTargetId;
+   __u8  bLun;
+   __u32 uFlags;
+   __u32 uQueueTag;
+   __u32 uReserved;
+   __u8  bTaskManagementFunction;
+   __u8  bReserved[7];
+   __u32 uInformation;
+} CSMI_SAS_SSP_TASK_IU,
+  *PCSMI_SAS_SSP_TASK_IU;
+
+typedef struct _CSMI_SAS_SSP_TASK_IU_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_SSP_TASK_IU Parameters;
+   CSMI_SAS_SSP_PASSTHRU_STATUS Status;
+} CSMI_SAS_SSP_TASK_IU_BUFFER,
+  *PCSMI_SAS_SSP_TASK_IU_BUFFER;
+
+// CC_CSMI_SAS_GET_CONNECTOR_INFO
+
+typedef struct _CSMI_SAS_GET_CONNECTOR_INFO {
+   __u32 uPinout;
+   __u8  bConnector[16];
+   __u8  bLocation;
+   __u8  bReserved[15];
+} CSMI_SAS_CONNECTOR_INFO,
+  *PCSMI_SAS_CONNECTOR_INFO;
+
+typedef struct _CSMI_SAS_CONNECTOR_INFO_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_CONNECTOR_INFO Reference[32];
+} CSMI_SAS_CONNECTOR_INFO_BUFFER,
+  *PCSMI_SAS_CONNECTOR_INFO_BUFFER;
+
+// CC_CSMI_SAS_GET_LOCATION
+
+typedef struct _CSMI_SAS_LOCATION_IDENTIFIER {
+   __u32 bLocationFlags;
+   __u8  bSASAddress[8];
+   __u8  bSASLun[8];
+   __u8  bEnclosureIdentifier[8];
+   __u8  bEnclosureName[32];
+   __u8  bBayPrefix[32];
+   __u8  bBayIdentifier;
+   __u8  bLocationState;
+   __u8  bReserved[2];
+} CSMI_SAS_LOCATION_IDENTIFIER,
+  *PCSMI_SAS_LOCATION_IDENTIFIER;
+
+typedef struct _CSMI_SAS_GET_LOCATION_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   __u8  bHostIndex;
+   __u8  bPathId;
+   __u8  bTargetId;
+   __u8  bLun;
+   __u8  bIdentify;
+   __u8  bNumberOfLocationIdentifiers;
+   __u8  bLengthOfLocationIdentifier;
+   CSMI_SAS_LOCATION_IDENTIFIER Location[1];
+} CSMI_SAS_GET_LOCATION_BUFFER,
+  *PCSMI_SAS_GET_LOCATION_BUFFER;
+
+// CC_CSMI_SAS_PHY_CONTROL
+
+typedef struct _CSMI_SAS_CHARACTER {
+   __u8  bTypeFlags;
+   __u8  bValue;
+} CSMI_SAS_CHARACTER,
+  *PCSMI_SAS_CHARACTER;
+
+typedef struct _CSMI_SAS_PHY_CONTROL {
+   __u8  bType;
+   __u8  bRate;
+   __u8  bReserved[6];
+   __u32 uVendorUnique[8];
+   __u32 uTransmitterFlags;
+   __i8  bTransmitAmplitude;
+   __i8  bTransmitterPreemphasis;
+   __i8  bTransmitterSlewRate;
+   __i8  bTransmitterReserved[13];
+   __u8  bTransmitterVendorUnique[64];
+   __u32 uReceiverFlags;
+   __i8  bReceiverThreshold;
+   __i8  bReceiverEqualizationGain;
+   __i8  bReceiverReserved[14];
+   __u8  bReceiverVendorUnique[64];
+   __u32 uPatternFlags;
+   __u8  bFixedPattern;
+   __u8  bUserPatternLength;
+   __u8  bPatternReserved[6];
+   CSMI_SAS_CHARACTER UserPatternBuffer[16];
+} CSMI_SAS_PHY_CONTROL,
+  *PCSMI_SAS_PHY_CONTROL;
+
+typedef struct _CSMI_SAS_PHY_CONTROL_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   __u32 uFunction;
+   __u8  bPhyIdentifier;
+   __u16 usLengthOfControl;
+   __u8  bNumberOfControls;
+   __u8  bReserved[4];
+   __u32 uLinkFlags;
+   __u8  bSpinupRate;
+   __u8  bLinkReserved[7];
+   __u32 uVendorUnique[8];
+   CSMI_SAS_PHY_CONTROL Control[1];
+} CSMI_SAS_PHY_CONTROL_BUFFER,
+  *PCSMI_SAS_PHY_CONTROL_BUFFER;
+
+// EDM #pragma CSMI_SAS_END_PACK
+#pragma pack()
+
+#endif // _CSMI_SAS_H_
diff -urNp linux-8145/drivers/message/fusion/isense.c linux-8150/drivers/message/fusion/isense.c
--- linux-8145/drivers/message/fusion/isense.c
+++ linux-8150/drivers/message/fusion/isense.c
@@ -9,9 +9,9 @@
  *  Written By: Steven J. Ralston
  *  (yes I wrote some of the orig. code back in 1991!)
  *  (mailto:sjralston1@netscape.net)
- *  (mailto:lstephen@lsil.com)
+ *  (mailto:mpt_linux_developer@lsil.com)
  *
- *  $Id: isense.c,v 1.33 2002/02/27 18:44:19 sralston Exp $
+ *  $Id: isense.c,v 1.34 2003/03/18 22:49:48 pdelaney Exp $
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -66,7 +66,7 @@
 #endif
 
 #define MODULEAUTHOR "Steven J. Ralston"
-#define COPYRIGHT "Copyright (c) 2001-2002 " MODULEAUTHOR
+#define COPYRIGHT "Copyright (c) 2001-2004 " MODULEAUTHOR
 #include "mptbase.h"
 
 #include "isense.h"
@@ -89,7 +89,9 @@
 #define my_VERSION	MPT_LINUX_VERSION_COMMON
 #define MYNAM		"isense"
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,62)
 EXPORT_NO_SYMBOLS;
+#endif
 MODULE_AUTHOR(MODULEAUTHOR);
 MODULE_DESCRIPTION(my_NAME);
 MODULE_LICENSE("GPL");
diff -urNp linux-8145/drivers/message/fusion/linux_compat.h linux-8150/drivers/message/fusion/linux_compat.h
--- linux-8145/drivers/message/fusion/linux_compat.h
+++ linux-8150/drivers/message/fusion/linux_compat.h
@@ -11,6 +11,40 @@
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
+#ifndef PCI_SEGMENT
+static inline int PCI_SEGMENT(struct pci_bus *bus) { return 0; }
+#endif
+
+#ifndef min
+#define min(x,y) ({ \
+         const typeof(x) _x = (x);       \
+         const typeof(y) _y = (y);       \
+         (void) (&_x == &_y);            \
+         _x < _y ? _x : _y; })
+#endif
+
+#ifndef min_t
+#define min_t(type,x,y) \
+         ({ type __x = (x); type __y = (y); __x < __y ? __x: __y; })
+#endif
+
+#ifndef max
+#define max(x,y) ({ \
+         const typeof(x) _x = (x);       \
+         const typeof(y) _y = (y);       \
+         (void) (&_x == &_y);            \
+         _x > _y ? _x : _y; })
+#endif
+
+#ifndef max_t
+#define max_t(type,x,y) \
+         ({ type __x = (x); type __y = (y); __x > __y ? __x: __y; })
+#endif
+
+#if (defined(__sparc__) && defined(__sparc_v9__)) || defined(__x86_64__)
+#define MPT_CONFIG_COMPAT
+#endif
+
 #ifndef rwlock_init
 #define rwlock_init(x) do { *(x) = RW_LOCK_UNLOCKED; } while(0)
 #endif
@@ -75,11 +109,11 @@ typedef int (*__init_module_func_t)(void
 typedef void (*__cleanup_module_func_t)(void);
 #define module_init(x) \
 	int init_module(void) __attribute__((alias(#x))); \
-	extern inline __init_module_func_t __init_module_inline(void) \
+	static inline __init_module_func_t __init_module_inline(void) \
 	{ return x; }
 #define module_exit(x) \
 	void cleanup_module(void) __attribute__((alias(#x))); \
-	extern inline __cleanup_module_func_t __cleanup_module_inline(void) \
+	static inline __cleanup_module_func_t __cleanup_module_inline(void) \
 	{ return x; }
 
 #else
@@ -93,7 +127,7 @@ typedef void (*__cleanup_module_func_t)(
  * Used prior to schedule_timeout calls..
  */
 #define __set_current_state(state_value)	do { current->state = state_value; } while (0)
-#ifdef __SMP__
+#ifdef CONFIG_SMP
 #define set_current_state(state_value)		do { __set_current_state(state_value); mb(); } while (0)
 #else
 #define set_current_state(state_value)		__set_current_state(state_value)
@@ -153,6 +187,7 @@ typedef void (*__cleanup_module_func_t)(
 #define DEVICE_COUNT_RESOURCE           6
 #define PCI_BASEADDR_FLAGS(idx)         base_address[idx]
 #define PCI_BASEADDR_START(idx)         base_address[idx] & ~0xFUL
+#define PCI_BASEADDR_END(idx)           base_address[idx+1]
 /*
  * We have to keep track of the original value using
  * a temporary, and not by just sticking pdev->base_address[x]
@@ -173,6 +208,7 @@ typedef void (*__cleanup_module_func_t)(
 #define PCI_BASEADDR_FLAGS(idx)         resource[idx].flags
 #define PCI_BASEADDR_START(idx)         resource[idx].start
 #define PCI_BASEADDR_SIZE(dev,idx)      (dev)->resource[idx].end - (dev)->resource[idx].start + 1
+#define PCI_BASEADDR_END(idx)           resource[idx].end
 #endif		/* } ifndef pci_for_each_dev */
 
 
@@ -247,6 +283,8 @@ static __inline__ int __get_order(unsign
 
 /*
  *  We use our new error handling code if the kernel version is 2.4.18 or newer.
+ *  Remark: 5/5/03 use old EH code with 2.4 kernels as it runs in a background thread
+ *  2.4 kernels choke on a call to schedule via eh thread.
  */
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,1)
         #define MPT_SCSI_USE_NEW_EH
@@ -265,11 +303,18 @@ static __inline__ int __get_order(unsign
 #endif
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,28)
-#define mptscsih_sync_irq(_irq) synchronize_irq(_irq)
+#define mpt_sync_irq(_irq) synchronize_irq(_irq)
 #else
-#define mptscsih_sync_irq(_irq) synchronize_irq()
+#define mpt_sync_irq(_irq) synchronize_irq()
 #endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,58)
+#define mpt_inc_use_count()
+#define mpt_dec_use_count()
+#else
+#define mpt_inc_use_count() MOD_INC_USE_COUNT
+#define mpt_dec_use_count() MOD_DEC_USE_COUNT
+#endif
 
 
 /*}-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
diff -urNp linux-8145/drivers/message/fusion/lsi/mpi.h linux-8150/drivers/message/fusion/lsi/mpi.h
--- linux-8145/drivers/message/fusion/lsi/mpi.h
+++ linux-8150/drivers/message/fusion/lsi/mpi.h
@@ -1,12 +1,12 @@
 /*
- *  Copyright (c) 2000-2002 LSI Logic Corporation.
+ *  Copyright (c) 2000-2005 LSI Logic Corporation.
  *
  *
- *           Name:  MPI.H
+ *           Name:  mpi.h
  *          Title:  MPI Message independent structures and definitions
  *  Creation Date:  July 27, 2000
  *
- *    MPI.H Version:  01.02.07
+ *    mpi.h Version:  01.05.07
  *
  *  Version History
  *  ---------------
@@ -48,6 +48,29 @@
  *  05-31-02  01.02.05  Bumped MPI_HEADER_VERSION_UNIT.
  *  07-12-02  01.02.06  Added define for MPI_FUNCTION_MAILBOX.
  *  09-16-02  01.02.07  Bumped value for MPI_HEADER_VERSION_UNIT.
+ *  11-15-02  01.02.08  Added define MPI_IOCSTATUS_TARGET_INVALID_IO_INDEX and
+ *                      obsoleted define MPI_IOCSTATUS_TARGET_INVALID_IOCINDEX.
+ *  04-01-03  01.02.09  New IOCStatus code: MPI_IOCSTATUS_FC_EXCHANGE_CANCELED
+ *  06-26-03  01.02.10  Bumped MPI_HEADER_VERSION_UNIT value.
+ *  01-16-04  01.02.11  Added define for MPI_IOCLOGINFO_TYPE_SHIFT.
+ *  04-29-04  01.02.12  Added function codes for MPI_FUNCTION_DIAG_BUFFER_POST
+ *                      and MPI_FUNCTION_DIAG_RELEASE.
+ *                      Added MPI_IOCSTATUS_DIAGNOSTIC_RELEASED define.
+ *                      Bumped MPI_HEADER_VERSION_UNIT value.
+ *  05-11-04  01.03.01  Bumped MPI_VERSION_MINOR for MPI v1.3.
+ *                      Added codes for Inband.
+ *  08-19-04  01.05.01  Added defines for Host Buffer Access Control doorbell.
+ *                      Added define for offset of High Priority Request Queue.
+ *                      Added new function codes and new IOCStatus codes.
+ *                      Added a IOCLogInfo type of SAS.
+ *  12-07-04  01.05.02  Bumped MPI_HEADER_VERSION_UNIT.
+ *  12-09-04  01.05.03  Bumped MPI_HEADER_VERSION_UNIT.
+ *  01-15-05  01.05.04  Bumped MPI_HEADER_VERSION_UNIT.
+ *  02-09-05  01.05.05  Bumped MPI_HEADER_VERSION_UNIT.
+ *  02-22-05  01.05.06  Bumped MPI_HEADER_VERSION_UNIT.
+ *  03-11-05  01.05.07  Removed function codes for SCSI IO 32 and
+ *                      TargetAssistExtended requests.
+ *                      Removed EEDP IOCStatus codes.
  *  --------------------------------------------------------------------------
  */
 
@@ -62,7 +85,7 @@
 *****************************************************************************/
 
 #define MPI_VERSION_MAJOR                   (0x01)
-#define MPI_VERSION_MINOR                   (0x02)
+#define MPI_VERSION_MINOR                   (0x05)
 #define MPI_VERSION_MAJOR_MASK              (0xFF00)
 #define MPI_VERSION_MAJOR_SHIFT             (8)
 #define MPI_VERSION_MINOR_MASK              (0x00FF)
@@ -73,6 +96,8 @@
 #define MPI_VERSION_01_00                   (0x0100)
 #define MPI_VERSION_01_01                   (0x0101)
 #define MPI_VERSION_01_02                   (0x0102)
+#define MPI_VERSION_01_03                   (0x0103)
+#define MPI_VERSION_01_05                   (0x0105)
 /* Note: The major versions of 0xe0 through 0xff are reserved */
 
 /* versioning for this MPI header set */
@@ -116,7 +141,11 @@
 *
 *****************************************************************************/
 
-/* S y s t e m    D o o r b e l l */
+/*
+ * Defines for working with the System Doorbell register.
+ * Values for doorbell function codes are included in the section that defines
+ * all the function codes (further on in this file).
+ */
 #define MPI_DOORBELL_OFFSET                 (0x00000000)
 #define MPI_DOORBELL_ACTIVE                 (0x08000000) /* DoorbellUsed */
 #define MPI_DOORBELL_USED                   (MPI_DOORBELL_ACTIVE)
@@ -128,6 +157,13 @@
 #define MPI_DOORBELL_ADD_DWORDS_MASK        (0x00FF0000)
 #define MPI_DOORBELL_ADD_DWORDS_SHIFT       (16)
 #define MPI_DOORBELL_DATA_MASK              (0x0000FFFF)
+#define MPI_DOORBELL_FUNCTION_SPECIFIC_MASK (0x0000FFFF)
+
+/* values for Host Buffer Access Control doorbell function */
+#define MPI_DB_HPBAC_VALUE_MASK             (0x0000F000)
+#define MPI_DB_HPBAC_ENABLE_ACCESS          (0x01)
+#define MPI_DB_HPBAC_DISABLE_ACCESS         (0x02)
+#define MPI_DB_HPBAC_FREE_BUFFER            (0x03)
 
 
 #define MPI_WRITE_SEQUENCE_OFFSET           (0x00000004)
@@ -171,6 +207,8 @@
 #define MPI_REPLY_POST_FIFO_OFFSET          (0x00000044)
 #define MPI_REPLY_FREE_FIFO_OFFSET          (0x00000044)
 
+#define MPI_HI_PRI_REQUEST_QUEUE_OFFSET     (0x00000048)
+
 
 
 /*****************************************************************************
@@ -230,10 +268,6 @@
 #define MPI_FUNCTION_TARGET_ASSIST                  (0x0B)
 #define MPI_FUNCTION_TARGET_STATUS_SEND             (0x0C)
 #define MPI_FUNCTION_TARGET_MODE_ABORT              (0x0D)
-#define MPI_FUNCTION_TARGET_FC_BUF_POST_LINK_SRVC   (0x0E) /* obsolete name */
-#define MPI_FUNCTION_TARGET_FC_RSP_LINK_SRVC        (0x0F) /* obsolete name */
-#define MPI_FUNCTION_TARGET_FC_EX_SEND_LINK_SRVC    (0x10) /* obsolete name */
-#define MPI_FUNCTION_TARGET_FC_ABORT                (0x11) /* obsolete name */
 #define MPI_FUNCTION_FC_LINK_SRVC_BUF_POST          (0x0E)
 #define MPI_FUNCTION_FC_LINK_SRVC_RSP               (0x0F)
 #define MPI_FUNCTION_FC_EX_LINK_SRVC_SEND           (0x10)
@@ -251,15 +285,48 @@
 
 #define MPI_FUNCTION_MAILBOX                        (0x19)
 
+#define MPI_FUNCTION_SMP_PASSTHROUGH                (0x1A)
+#define MPI_FUNCTION_SAS_IO_UNIT_CONTROL            (0x1B)
+#define MPI_FUNCTION_SATA_PASSTHROUGH               (0x1C)
+
+#define MPI_FUNCTION_DIAG_BUFFER_POST               (0x1D)
+#define MPI_FUNCTION_DIAG_RELEASE                   (0x1E)
+
 #define MPI_FUNCTION_LAN_SEND                       (0x20)
 #define MPI_FUNCTION_LAN_RECEIVE                    (0x21)
 #define MPI_FUNCTION_LAN_RESET                      (0x22)
 
+#define MPI_FUNCTION_TARGET_CMD_BUF_BASE_POST       (0x24)
+#define MPI_FUNCTION_TARGET_CMD_BUF_LIST_POST       (0x25)
+
+#define MPI_FUNCTION_INBAND_BUFFER_POST             (0x28)
+#define MPI_FUNCTION_INBAND_SEND                    (0x29)
+#define MPI_FUNCTION_INBAND_RSP                     (0x2A)
+#define MPI_FUNCTION_INBAND_ABORT                   (0x2B)
+
 #define MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET         (0x40)
 #define MPI_FUNCTION_IO_UNIT_RESET                  (0x41)
 #define MPI_FUNCTION_HANDSHAKE                      (0x42)
 #define MPI_FUNCTION_REPLY_FRAME_REMOVAL            (0x43)
+#define MPI_FUNCTION_HOST_PAGEBUF_ACCESS_CONTROL    (0x44)
+
 
+/* standard version format */
+typedef struct _MPI_VERSION_STRUCT
+{
+    U8                      Dev;                        /* 00h */
+    U8                      Unit;                       /* 01h */
+    U8                      Minor;                      /* 02h */
+    U8                      Major;                      /* 03h */
+} MPI_VERSION_STRUCT, MPI_POINTER PTR_MPI_VERSION_STRUCT,
+  MpiVersionStruct_t, MPI_POINTER pMpiVersionStruct;
+
+typedef union _MPI_VERSION_FORMAT
+{
+    MPI_VERSION_STRUCT      Struct;
+    U32                     Word;
+} MPI_VERSION_FORMAT, MPI_POINTER PTR_MPI_VERSION_FORMAT,
+  MpiVersionFormat_t, MPI_POINTER pMpiVersionFormat_t;
 
 
 /*****************************************************************************
@@ -294,8 +361,8 @@ typedef struct _SGE_SIMPLE_UNION
         U32                 Address32;
         U64                 Address64;
     }u;
-} SGESimpleUnion_t, MPI_POINTER pSGESimpleUnion_t,
-  SGE_SIMPLE_UNION, MPI_POINTER PTR_SGE_SIMPLE_UNION;
+} SGE_SIMPLE_UNION, MPI_POINTER PTR_SGE_SIMPLE_UNION,
+  SGESimpleUnion_t, MPI_POINTER pSGESimpleUnion_t;
 
 /****************************************************************************/
 /*  Chain element structures                                                */
@@ -573,60 +640,65 @@ typedef struct _MSG_DEFAULT_REPLY
 /*  Common IOCStatus values for all replies                                 */
 /****************************************************************************/
 
-#define MPI_IOCSTATUS_SUCCESS                  (0x0000)
-#define MPI_IOCSTATUS_INVALID_FUNCTION         (0x0001)
-#define MPI_IOCSTATUS_BUSY                     (0x0002)
-#define MPI_IOCSTATUS_INVALID_SGL              (0x0003)
-#define MPI_IOCSTATUS_INTERNAL_ERROR           (0x0004)
-#define MPI_IOCSTATUS_RESERVED                 (0x0005)
-#define MPI_IOCSTATUS_INSUFFICIENT_RESOURCES   (0x0006)
-#define MPI_IOCSTATUS_INVALID_FIELD            (0x0007)
-#define MPI_IOCSTATUS_INVALID_STATE            (0x0008)
+#define MPI_IOCSTATUS_SUCCESS                   (0x0000)
+#define MPI_IOCSTATUS_INVALID_FUNCTION          (0x0001)
+#define MPI_IOCSTATUS_BUSY                      (0x0002)
+#define MPI_IOCSTATUS_INVALID_SGL               (0x0003)
+#define MPI_IOCSTATUS_INTERNAL_ERROR            (0x0004)
+#define MPI_IOCSTATUS_RESERVED                  (0x0005)
+#define MPI_IOCSTATUS_INSUFFICIENT_RESOURCES    (0x0006)
+#define MPI_IOCSTATUS_INVALID_FIELD             (0x0007)
+#define MPI_IOCSTATUS_INVALID_STATE             (0x0008)
+#define MPI_IOCSTATUS_OP_STATE_NOT_SUPPORTED    (0x0009)
 
 /****************************************************************************/
 /*  Config IOCStatus values                                                 */
 /****************************************************************************/
 
-#define MPI_IOCSTATUS_CONFIG_INVALID_ACTION    (0x0020)
-#define MPI_IOCSTATUS_CONFIG_INVALID_TYPE      (0x0021)
-#define MPI_IOCSTATUS_CONFIG_INVALID_PAGE      (0x0022)
-#define MPI_IOCSTATUS_CONFIG_INVALID_DATA      (0x0023)
-#define MPI_IOCSTATUS_CONFIG_NO_DEFAULTS       (0x0024)
-#define MPI_IOCSTATUS_CONFIG_CANT_COMMIT       (0x0025)
+#define MPI_IOCSTATUS_CONFIG_INVALID_ACTION     (0x0020)
+#define MPI_IOCSTATUS_CONFIG_INVALID_TYPE       (0x0021)
+#define MPI_IOCSTATUS_CONFIG_INVALID_PAGE       (0x0022)
+#define MPI_IOCSTATUS_CONFIG_INVALID_DATA       (0x0023)
+#define MPI_IOCSTATUS_CONFIG_NO_DEFAULTS        (0x0024)
+#define MPI_IOCSTATUS_CONFIG_CANT_COMMIT        (0x0025)
 
 /****************************************************************************/
 /*  SCSIIO Reply (SPI & FCP) initiator values                               */
 /****************************************************************************/
 
-#define MPI_IOCSTATUS_SCSI_RECOVERED_ERROR     (0x0040)
-#define MPI_IOCSTATUS_SCSI_INVALID_BUS         (0x0041)
-#define MPI_IOCSTATUS_SCSI_INVALID_TARGETID    (0x0042)
-#define MPI_IOCSTATUS_SCSI_DEVICE_NOT_THERE    (0x0043)
-#define MPI_IOCSTATUS_SCSI_DATA_OVERRUN        (0x0044)
-#define MPI_IOCSTATUS_SCSI_DATA_UNDERRUN       (0x0045)
-#define MPI_IOCSTATUS_SCSI_IO_DATA_ERROR       (0x0046)
-#define MPI_IOCSTATUS_SCSI_PROTOCOL_ERROR      (0x0047)
-#define MPI_IOCSTATUS_SCSI_TASK_TERMINATED     (0x0048)
-#define MPI_IOCSTATUS_SCSI_RESIDUAL_MISMATCH   (0x0049)
-#define MPI_IOCSTATUS_SCSI_TASK_MGMT_FAILED    (0x004A)
-#define MPI_IOCSTATUS_SCSI_IOC_TERMINATED      (0x004B)
-#define MPI_IOCSTATUS_SCSI_EXT_TERMINATED      (0x004C)
+#define MPI_IOCSTATUS_SCSI_RECOVERED_ERROR      (0x0040)
+#define MPI_IOCSTATUS_SCSI_INVALID_BUS          (0x0041)
+#define MPI_IOCSTATUS_SCSI_INVALID_TARGETID     (0x0042)
+#define MPI_IOCSTATUS_SCSI_DEVICE_NOT_THERE     (0x0043)
+#define MPI_IOCSTATUS_SCSI_DATA_OVERRUN         (0x0044)
+#define MPI_IOCSTATUS_SCSI_DATA_UNDERRUN        (0x0045)
+#define MPI_IOCSTATUS_SCSI_IO_DATA_ERROR        (0x0046)
+#define MPI_IOCSTATUS_SCSI_PROTOCOL_ERROR       (0x0047)
+#define MPI_IOCSTATUS_SCSI_TASK_TERMINATED      (0x0048)
+#define MPI_IOCSTATUS_SCSI_RESIDUAL_MISMATCH    (0x0049)
+#define MPI_IOCSTATUS_SCSI_TASK_MGMT_FAILED     (0x004A)
+#define MPI_IOCSTATUS_SCSI_IOC_TERMINATED       (0x004B)
+#define MPI_IOCSTATUS_SCSI_EXT_TERMINATED       (0x004C)
 
 /****************************************************************************/
-/*  SCSI (SPI & FCP) target values                                          */
+/*  SCSI Target values                                                      */
 /****************************************************************************/
 
 #define MPI_IOCSTATUS_TARGET_PRIORITY_IO         (0x0060)
 #define MPI_IOCSTATUS_TARGET_INVALID_PORT        (0x0061)
-#define MPI_IOCSTATUS_TARGET_INVALID_IOCINDEX    (0x0062)
+#define MPI_IOCSTATUS_TARGET_INVALID_IOCINDEX    (0x0062)   /* obsolete name */
+#define MPI_IOCSTATUS_TARGET_INVALID_IO_INDEX    (0x0062)
 #define MPI_IOCSTATUS_TARGET_ABORTED             (0x0063)
 #define MPI_IOCSTATUS_TARGET_NO_CONN_RETRYABLE   (0x0064)
 #define MPI_IOCSTATUS_TARGET_NO_CONNECTION       (0x0065)
 #define MPI_IOCSTATUS_TARGET_XFER_COUNT_MISMATCH (0x006A)
 #define MPI_IOCSTATUS_TARGET_STS_DATA_NOT_SENT   (0x006B)
+#define MPI_IOCSTATUS_TARGET_DATA_OFFSET_ERROR   (0x006D)
+#define MPI_IOCSTATUS_TARGET_TOO_MUCH_WRITE_DATA (0x006E)
+#define MPI_IOCSTATUS_TARGET_IU_TOO_SHORT        (0x006F)
 
 /****************************************************************************/
-/*  Additional FCP target values                                            */
+/*  Additional FCP target values (obsolete)                                 */
 /****************************************************************************/
 
 #define MPI_IOCSTATUS_TARGET_FC_ABORTED         (0x0066)    /* obsolete */
@@ -642,6 +714,7 @@ typedef struct _MSG_DEFAULT_REPLY
 #define MPI_IOCSTATUS_FC_RX_ID_INVALID          (0x0067)
 #define MPI_IOCSTATUS_FC_DID_INVALID            (0x0068)
 #define MPI_IOCSTATUS_FC_NODE_LOGGED_OUT        (0x0069)
+#define MPI_IOCSTATUS_FC_EXCHANGE_CANCELED      (0x006C)
 
 /****************************************************************************/
 /*  LAN values                                                              */
@@ -656,6 +729,26 @@ typedef struct _MSG_DEFAULT_REPLY
 #define MPI_IOCSTATUS_LAN_PARTIAL_PACKET        (0x0086)
 #define MPI_IOCSTATUS_LAN_CANCELED              (0x0087)
 
+/****************************************************************************/
+/*  Serial Attached SCSI values                                                              */
+/****************************************************************************/
+
+#define MPI_IOCSTATUS_SAS_SMP_REQUEST_FAILED    (0x0090)
+#define MPI_IOCSTATUS_SAS_SMP_DATA_OVERRUN      (0x0091)
+
+/****************************************************************************/
+/*  Inband values                                                           */
+/****************************************************************************/
+
+#define MPI_IOCSTATUS_INBAND_ABORTED            (0x0098)
+#define MPI_IOCSTATUS_INBAND_NO_CONNECTION      (0x0099)
+
+/****************************************************************************/
+/*  Diagnostic Tools values                                                 */
+/****************************************************************************/
+
+#define MPI_IOCSTATUS_DIAGNOSTIC_RELEASED       (0x00A0)
+
 
 /****************************************************************************/
 /*  IOCStatus flag to indicate that log info is available                   */
@@ -669,9 +762,12 @@ typedef struct _MSG_DEFAULT_REPLY
 /****************************************************************************/
 
 #define MPI_IOCLOGINFO_TYPE_MASK                (0xF0000000)
+#define MPI_IOCLOGINFO_TYPE_SHIFT               (28)
 #define MPI_IOCLOGINFO_TYPE_NONE                (0x0)
 #define MPI_IOCLOGINFO_TYPE_SCSI                (0x1)
 #define MPI_IOCLOGINFO_TYPE_FC                  (0x2)
+#define MPI_IOCLOGINFO_TYPE_SAS                 (0x3)
+#define MPI_IOCLOGINFO_TYPE_ISCSI               (0x4)
 #define MPI_IOCLOGINFO_LOG_DATA_MASK            (0x0FFFFFFF)
 
 
diff -urNp linux-8145/drivers/message/fusion/lsi/mpi_cnfg.h linux-8150/drivers/message/fusion/lsi/mpi_cnfg.h
--- linux-8145/drivers/message/fusion/lsi/mpi_cnfg.h
+++ linux-8150/drivers/message/fusion/lsi/mpi_cnfg.h
@@ -1,12 +1,12 @@
 /*
- *  Copyright (c) 2000-2002 LSI Logic Corporation.
+ *  Copyright (c) 2000-2005 LSI Logic Corporation.
  *
  *
- *           Name:  MPI_CNFG.H
+ *           Name:  mpi_cnfg.h
  *          Title:  MPI Config message, structures, and Pages
  *  Creation Date:  July 27, 2000
  *
- *    MPI_CNFG.H Version:  01.02.09
+ *    mpi_cnfg.h Version:  01.05.08
  *
  *  Version History
  *  ---------------
@@ -127,7 +127,111 @@
  *                      MPI_SCSIDEVPAGE1_CONF_EXTENDED_PARAMS_ENABLE.
  *                      Added new config page: CONFIG_PAGE_SCSI_DEVICE_3.
  *                      Modified MPI_FCPORTPAGE5_FLAGS_ defines.
- *  09-16-02 01.02.09   Added more MPI_SCSIDEVPAGE1_CONF_FORCE_PPR_MSG define.
+ *  09-16-02 01.02.09   Added MPI_SCSIDEVPAGE1_CONF_FORCE_PPR_MSG define.
+ *  11-15-02 01.02.10   Added ConnectedID defines for CONFIG_PAGE_SCSI_PORT_0.
+ *                      Added more Flags defines for CONFIG_PAGE_FC_PORT_1.
+ *                      Added more Flags defines for CONFIG_PAGE_FC_DEVICE_0.
+ *  04-01-03 01.02.11   Added RR_TOV field and additional Flags defines for
+ *                      CONFIG_PAGE_FC_PORT_1.
+ *                      Added define MPI_FCPORTPAGE5_FLAGS_DISABLE to disable
+ *                      an alias.
+ *                      Added more device id defines.
+ *  06-26-03 01.02.12   Added MPI_IOUNITPAGE1_IR_USE_STATIC_VOLUME_ID define.
+ *                      Added TargetConfig and IDConfig fields to
+ *                      CONFIG_PAGE_SCSI_PORT_1.
+ *                      Added more PortFlags defines for CONFIG_PAGE_SCSI_PORT_2
+ *                      to control DV.
+ *                      Added more Flags defines for CONFIG_PAGE_FC_PORT_1.
+ *                      In CONFIG_PAGE_FC_DEVICE_0, replaced Reserved1 field
+ *                      with ADISCHardALPA.
+ *                      Added MPI_FC_DEVICE_PAGE0_PROT_FCP_RETRY define.
+ *  01-16-04 01.02.13   Added InitiatorDeviceTimeout and InitiatorIoPendTimeout
+ *                      fields and related defines to CONFIG_PAGE_FC_PORT_1.
+ *                      Added define for
+ *                      MPI_FCPORTPAGE1_FLAGS_SOFT_ALPA_FALLBACK.
+ *                      Added new fields to the substructures of
+ *                      CONFIG_PAGE_FC_PORT_10.
+ *  04-29-04 01.02.14   Added define for IDP bit for CONFIG_PAGE_SCSI_PORT_0,
+ *                      CONFIG_PAGE_SCSI_DEVICE_0, and
+ *                      CONFIG_PAGE_SCSI_DEVICE_1. Also bumped Page Version for
+ *                      these pages.
+ *  05-11-04 01.03.01   Added structure for CONFIG_PAGE_INBAND_0.
+ *  08-19-04 01.05.01   Modified MSG_CONFIG request to support extended config
+ *                      pages.
+ *                      Added a new structure for extended config page header.
+ *                      Added new extended config pages types and structures for
+ *                      SAS IO Unit, SAS Expander, SAS Device, and SAS PHY.
+ *                      Replaced a reserved byte in CONFIG_PAGE_MANUFACTURING_4
+ *                      to add a Flags field.
+ *                      Two new Manufacturing config pages (5 and 6).
+ *                      Two new bits defined for IO Unit Page 1 Flags field.
+ *                      Modified CONFIG_PAGE_IO_UNIT_2 to add three new fields
+ *                      to specify the BIOS boot device.
+ *                      Four new Flags bits defined for IO Unit Page 2.
+ *                      Added IO Unit Page 4.
+ *                      Added EEDP Flags settings to IOC Page 1.
+ *                      Added new BIOS Page 1 config page.
+ *  10-05-04 01.05.02   Added define for
+ *                      MPI_IOCPAGE1_INITIATOR_CONTEXT_REPLY_DISABLE.
+ *                      Added new Flags field to CONFIG_PAGE_MANUFACTURING_5 and
+ *                      associated defines.
+ *                      Added more defines for SAS IO Unit Page 0
+ *                      DiscoveryStatus field.
+ *                      Added define for MPI_SAS_IOUNIT0_DS_SUBTRACTIVE_LINK
+ *                      and MPI_SAS_IOUNIT0_DS_TABLE_LINK.
+ *                      Added defines for Physical Mapping Modes to SAS IO Unit
+ *                      Page 2.
+ *                      Added define for
+ *                      MPI_SAS_DEVICE0_FLAGS_PORT_SELECTOR_ATTACH.
+ *  10-27-04 01.05.03   Added defines for new SAS PHY page addressing mode.
+ *                      Added defines for MaxTargetSpinUp to BIOS Page 1.
+ *                      Added 5 new ControlFlags defines for SAS IO Unit
+ *                      Page 1.
+ *                      Added MaxNumPhysicalMappedIDs field to SAS IO Unit
+ *                      Page 2.
+ *                      Added AccessStatus field to SAS Device Page 0 and added
+ *                      new Flags bits for supported SATA features.
+ *  12-07-04  01.05.04  Added config page structures for BIOS Page 2, RAID
+ *                      Volume Page 1, and RAID Physical Disk Page 1.
+ *                      Replaced IO Unit Page 1 BootTargetID,BootBus, and
+ *                      BootAdapterNum with reserved field.
+ *                      Added DataScrubRate and ResyncRate to RAID Volume
+ *                      Page 0.
+ *                      Added MPI_SAS_IOUNIT2_FLAGS_RESERVE_ID_0_FOR_BOOT
+ *                      define.
+ *  12-09-04  01.05.05  Added Target Mode Large CDB Enable to FC Port Page 1
+ *                      Flags field.
+ *                      Added Auto Port Config flag define for SAS IOUNIT
+ *                      Page 1 ControlFlags.
+ *                      Added Disabled bad Phy define to Expander Page 1
+ *                      Discovery Info field.
+ *                      Added SAS/SATA device support to SAS IOUnit Page 1
+ *                      ControlFlags.
+ *                      Added Unsupported device to SAS Dev Page 0 Flags field
+ *                      Added disable use SATA Hash Address for SAS IOUNIT
+ *                      page 1 in ControlFields.
+ *  01-15-05  01.05.06  Added defaults for data scrub rate and resync rate to
+ *                      Manufacturing Page 4.
+ *                      Added new defines for BIOS Page 1 IOCSettings field.
+ *                      Added ExtDiskIdentifier field to RAID Physical Disk
+ *                      Page 0.
+ *                      Added new defines for SAS IO Unit Page 1 ControlFlags
+ *                      and to SAS Device Page 0 Flags to control SATA devices.
+ *                      Added defines and structures for the new Log Page 0, a
+ *                      new type of configuration page.
+ *  02-09-05  01.05.07  Added InactiveStatus field to RAID Volume Page 0.
+ *                      Added WWID field to RAID Volume Page 1.
+ *                      Added PhysicalPort field to SAS Expander pages 0 and 1.
+ *  03-11-05  01.05.08  Removed the EEDP flags from IOC Page 1.
+ *                      Added Enclosure/Slot boot device format to BIOS Page 2.
+ *                      New status value for RAID Volume Page 0 VolumeStatus
+ *                      (VolumeState subfield).
+ *                      New value for RAID Physical Page 0 InactiveStatus.
+ *                      Added Inactive Volume Member flag RAID Physical Disk
+ *                      Page 0 PhysDiskStatus field.
+ *                      New physical mapping mode in SAS IO Unit Page 2.
+ *                      Added CONFIG_PAGE_SAS_ENCLOSURE_0.
+ *                      Added Slot and Enclosure fields to SAS Device Page 0.
  *  --------------------------------------------------------------------------
  */
 
@@ -147,7 +251,7 @@ typedef struct _CONFIG_PAGE_HEADER
     U8                      PageLength;                 /* 01h */
     U8                      PageNumber;                 /* 02h */
     U8                      PageType;                   /* 03h */
-} fCONFIG_PAGE_HEADER, MPI_POINTER PTR_CONFIG_PAGE_HEADER,
+} CONFIG_PAGE_HEADER, MPI_POINTER PTR_CONFIG_PAGE_HEADER,
   ConfigPageHeader_t, MPI_POINTER pConfigPageHeader_t;
 
 typedef union _CONFIG_PAGE_HEADER_UNION
@@ -157,7 +261,20 @@ typedef union _CONFIG_PAGE_HEADER_UNION
    U16                 Word16[2];
    U32                 Word32;
 } ConfigPageHeaderUnion, MPI_POINTER pConfigPageHeaderUnion,
-  fCONFIG_PAGE_HEADER_UNION, MPI_POINTER PTR_CONFIG_PAGE_HEADER_UNION;
+  CONFIG_PAGE_HEADER_UNION, MPI_POINTER PTR_CONFIG_PAGE_HEADER_UNION;
+
+typedef struct _CONFIG_EXTENDED_PAGE_HEADER
+{
+    U8                  PageVersion;                /* 00h */
+    U8                  Reserved1;                  /* 01h */
+    U8                  PageNumber;                 /* 02h */
+    U8                  PageType;                   /* 03h */
+    U16                 ExtPageLength;              /* 04h */
+    U8                  ExtPageType;                /* 06h */
+    U8                  Reserved2;                  /* 07h */
+} CONFIG_EXTENDED_PAGE_HEADER, MPI_POINTER PTR_CONFIG_EXTENDED_PAGE_HEADER,
+  ConfigExtendedPageHeader_t, MPI_POINTER pConfigExtendedPageHeader_t;
+
 
 
 /****************************************************************************
@@ -180,20 +297,42 @@ typedef union _CONFIG_PAGE_HEADER_UNION
 #define MPI_CONFIG_PAGETYPE_RAID_VOLUME             (0x08)
 #define MPI_CONFIG_PAGETYPE_MANUFACTURING           (0x09)
 #define MPI_CONFIG_PAGETYPE_RAID_PHYSDISK           (0x0A)
+#define MPI_CONFIG_PAGETYPE_INBAND                  (0x0B)
+#define MPI_CONFIG_PAGETYPE_EXTENDED                (0x0F)
 #define MPI_CONFIG_PAGETYPE_MASK                    (0x0F)
 
 #define MPI_CONFIG_TYPENUM_MASK                     (0x0FFF)
 
 
 /****************************************************************************
+*   ExtPageType field values
+****************************************************************************/
+#define MPI_CONFIG_EXTPAGETYPE_SAS_IO_UNIT          (0x10)
+#define MPI_CONFIG_EXTPAGETYPE_SAS_EXPANDER         (0x11)
+#define MPI_CONFIG_EXTPAGETYPE_SAS_DEVICE           (0x12)
+#define MPI_CONFIG_EXTPAGETYPE_SAS_PHY              (0x13)
+#define MPI_CONFIG_EXTPAGETYPE_LOG                  (0x14)
+#define MPI_CONFIG_EXTPAGETYPE_ENCLOSURE            (0x15)
+
+
+/****************************************************************************
 *   PageAddress field values
 ****************************************************************************/
 #define MPI_SCSI_PORT_PGAD_PORT_MASK                (0x000000FF)
 
+#define MPI_SCSI_DEVICE_FORM_MASK                   (0xF0000000)
+#define MPI_SCSI_DEVICE_FORM_BUS_TID                (0x00000000)
 #define MPI_SCSI_DEVICE_TARGET_ID_MASK              (0x000000FF)
 #define MPI_SCSI_DEVICE_TARGET_ID_SHIFT             (0)
 #define MPI_SCSI_DEVICE_BUS_MASK                    (0x0000FF00)
 #define MPI_SCSI_DEVICE_BUS_SHIFT                   (8)
+#define MPI_SCSI_DEVICE_FORM_TARGET_MODE            (0x10000000)
+#define MPI_SCSI_DEVICE_TM_RESPOND_ID_MASK          (0x000000FF)
+#define MPI_SCSI_DEVICE_TM_RESPOND_ID_SHIFT         (0)
+#define MPI_SCSI_DEVICE_TM_BUS_MASK                 (0x0000FF00)
+#define MPI_SCSI_DEVICE_TM_BUS_SHIFT                (8)
+#define MPI_SCSI_DEVICE_TM_INIT_ID_MASK             (0x00FF0000)
+#define MPI_SCSI_DEVICE_TM_INIT_ID_SHIFT            (16)
 
 #define MPI_FC_PORT_PGAD_PORT_MASK                  (0xF0000000)
 #define MPI_FC_PORT_PGAD_PORT_SHIFT                 (28)
@@ -219,6 +358,52 @@ typedef union _CONFIG_PAGE_HEADER_UNION
 #define MPI_PHYSDISK_PGAD_PHYSDISKNUM_MASK          (0x000000FF)
 #define MPI_PHYSDISK_PGAD_PHYSDISKNUM_SHIFT         (0)
 
+#define MPI_SAS_EXPAND_PGAD_FORM_MASK             (0xF0000000)
+#define MPI_SAS_EXPAND_PGAD_FORM_SHIFT            (28)
+#define MPI_SAS_EXPAND_PGAD_FORM_GET_NEXT_HANDLE  (0x00000000)
+#define MPI_SAS_EXPAND_PGAD_FORM_HANDLE_PHY_NUM   (0x00000001)
+#define MPI_SAS_EXPAND_PGAD_FORM_HANDLE           (0x00000002)
+#define MPI_SAS_EXPAND_PGAD_GNH_MASK_HANDLE       (0x0000FFFF)
+#define MPI_SAS_EXPAND_PGAD_GNH_SHIFT_HANDLE      (0)
+#define MPI_SAS_EXPAND_PGAD_HPN_MASK_PHY          (0x00FF0000)
+#define MPI_SAS_EXPAND_PGAD_HPN_SHIFT_PHY         (16)
+#define MPI_SAS_EXPAND_PGAD_HPN_MASK_HANDLE       (0x0000FFFF)
+#define MPI_SAS_EXPAND_PGAD_HPN_SHIFT_HANDLE      (0)
+#define MPI_SAS_EXPAND_PGAD_H_MASK_HANDLE         (0x0000FFFF)
+#define MPI_SAS_EXPAND_PGAD_H_SHIFT_HANDLE        (0)
+
+#define MPI_SAS_DEVICE_PGAD_FORM_MASK               (0xF0000000)
+#define MPI_SAS_DEVICE_PGAD_FORM_SHIFT              (28)
+#define MPI_SAS_DEVICE_PGAD_FORM_GET_NEXT_HANDLE    (0x00000000)
+#define MPI_SAS_DEVICE_PGAD_FORM_BUS_TARGET_ID      (0x00000001)
+#define MPI_SAS_DEVICE_PGAD_FORM_HANDLE             (0x00000002)
+#define MPI_SAS_DEVICE_PGAD_GNH_HANDLE_MASK         (0x0000FFFF)
+#define MPI_SAS_DEVICE_PGAD_GNH_HANDLE_SHIFT        (0)
+#define MPI_SAS_DEVICE_PGAD_BT_BUS_MASK             (0x0000FF00)
+#define MPI_SAS_DEVICE_PGAD_BT_BUS_SHIFT            (8)
+#define MPI_SAS_DEVICE_PGAD_BT_TID_MASK             (0x000000FF)
+#define MPI_SAS_DEVICE_PGAD_BT_TID_SHIFT            (0)
+#define MPI_SAS_DEVICE_PGAD_H_HANDLE_MASK           (0x0000FFFF)
+#define MPI_SAS_DEVICE_PGAD_H_HANDLE_SHIFT          (0)
+
+#define MPI_SAS_PHY_PGAD_FORM_MASK                  (0xF0000000)
+#define MPI_SAS_PHY_PGAD_FORM_SHIFT                 (28)
+#define MPI_SAS_PHY_PGAD_FORM_PHY_NUMBER            (0x0)
+#define MPI_SAS_PHY_PGAD_FORM_PHY_TBL_INDEX         (0x1)
+#define MPI_SAS_PHY_PGAD_PHY_NUMBER_MASK            (0x000000FF)
+#define MPI_SAS_PHY_PGAD_PHY_NUMBER_SHIFT           (0)
+#define MPI_SAS_PHY_PGAD_PHY_TBL_INDEX_MASK         (0x0000FFFF)
+#define MPI_SAS_PHY_PGAD_PHY_TBL_INDEX_SHIFT        (0)
+
+#define MPI_SAS_ENCLOS_PGAD_FORM_MASK               (0xF0000000)
+#define MPI_SAS_ENCLOS_PGAD_FORM_SHIFT              (28)
+#define MPI_SAS_ENCLOS_PGAD_FORM_GET_NEXT_HANDLE    (0x00000000)
+#define MPI_SAS_ENCLOS_PGAD_FORM_HANDLE             (0x00000001)
+#define MPI_SAS_ENCLOS_PGAD_GNH_HANDLE_MASK         (0x0000FFFF)
+#define MPI_SAS_ENCLOS_PGAD_GNH_HANDLE_SHIFT        (0)
+#define MPI_SAS_ENCLOS_PGAD_H_HANDLE_MASK           (0x0000FFFF)
+#define MPI_SAS_ENCLOS_PGAD_H_HANDLE_SHIFT          (0)
+
 
 
 /****************************************************************************
@@ -230,11 +415,12 @@ typedef struct _MSG_CONFIG
     U8                      Reserved;                   /* 01h */
     U8                      ChainOffset;                /* 02h */
     U8                      Function;                   /* 03h */
-    U8                      Reserved1[3];               /* 04h */
+    U16                     ExtPageLength;              /* 04h */
+    U8                      ExtPageType;                /* 06h */
     U8                      MsgFlags;                   /* 07h */
     U32                     MsgContext;                 /* 08h */
     U8                      Reserved2[8];               /* 0Ch */
-    fCONFIG_PAGE_HEADER      Header;                     /* 14h */
+    CONFIG_PAGE_HEADER      Header;                     /* 14h */
     U32                     PageAddress;                /* 18h */
     SGE_IO_UNION            PageBufferSGE;              /* 1Ch */
 } MSG_CONFIG, MPI_POINTER PTR_MSG_CONFIG,
@@ -260,13 +446,14 @@ typedef struct _MSG_CONFIG_REPLY
     U8                      Reserved;                   /* 01h */
     U8                      MsgLength;                  /* 02h */
     U8                      Function;                   /* 03h */
-    U8                      Reserved1[3];               /* 04h */
+    U16                     ExtPageLength;              /* 04h */
+    U8                      ExtPageType;                /* 06h */
     U8                      MsgFlags;                   /* 07h */
     U32                     MsgContext;                 /* 08h */
     U8                      Reserved2[2];               /* 0Ch */
     U16                     IOCStatus;                  /* 0Eh */
     U32                     IOCLogInfo;                 /* 10h */
-    fCONFIG_PAGE_HEADER      Header;                     /* 14h */
+    CONFIG_PAGE_HEADER      Header;                     /* 14h */
 } MSG_CONFIG_REPLY, MPI_POINTER PTR_MSG_CONFIG_REPLY,
   ConfigReply_t, MPI_POINTER pConfigReply_t;
 
@@ -281,35 +468,43 @@ typedef struct _MSG_CONFIG_REPLY
 /****************************************************************************
 *   Manufacturing Config pages
 ****************************************************************************/
+#define MPI_MANUFACTPAGE_VENDORID_LSILOGIC          (0x1000)
+/* Fibre Channel */
 #define MPI_MANUFACTPAGE_DEVICEID_FC909             (0x0621)
 #define MPI_MANUFACTPAGE_DEVICEID_FC919             (0x0624)
 #define MPI_MANUFACTPAGE_DEVICEID_FC929             (0x0622)
 #define MPI_MANUFACTPAGE_DEVICEID_FC919X            (0x0628)
 #define MPI_MANUFACTPAGE_DEVICEID_FC929X            (0x0626)
-
+#define MPI_MANUFACTPAGE_DEVICEID_FC939X            (0x0642)
+#define MPI_MANUFACTPAGE_DEVICEID_FC949X            (0x0640)
+/* SCSI */
 #define MPI_MANUFACTPAGE_DEVID_53C1030              (0x0030)
 #define MPI_MANUFACTPAGE_DEVID_53C1030ZC            (0x0031)
 #define MPI_MANUFACTPAGE_DEVID_1030_53C1035         (0x0032)
 #define MPI_MANUFACTPAGE_DEVID_1030ZC_53C1035       (0x0033)
 #define MPI_MANUFACTPAGE_DEVID_53C1035              (0x0040)
 #define MPI_MANUFACTPAGE_DEVID_53C1035ZC            (0x0041)
-
-#define MPI_MANUFACTPAGE_DEVID_SA2010               (0x0804)
-#define MPI_MANUFACTPAGE_DEVID_SA2010ZC             (0x0805)
-#define MPI_MANUFACTPAGE_DEVID_SA2020               (0x0806)
-#define MPI_MANUFACTPAGE_DEVID_SA2020ZC             (0x0807)
+/* SAS */
+#define MPI_MANUFACTPAGE_DEVID_SAS1064              (0x0050)
+#define MPI_MANUFACTPAGE_DEVID_SAS1064A             (0x005C)
+#define MPI_MANUFACTPAGE_DEVID_SAS1064E             (0x0056)
+#define MPI_MANUFACTPAGE_DEVID_SAS1066              (0x005E)
+#define MPI_MANUFACTPAGE_DEVID_SAS1066E             (0x005A)
+#define MPI_MANUFACTPAGE_DEVID_SAS1068              (0x0054)
+#define MPI_MANUFACTPAGE_DEVID_SAS1068E             (0x0058)
+#define MPI_MANUFACTPAGE_DEVID_SAS1078              (0x0060)
 
 
 typedef struct _CONFIG_PAGE_MANUFACTURING_0
 {
-    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U8                      ChipName[16];               /* 04h */
     U8                      ChipRevision[8];            /* 14h */
     U8                      BoardName[16];              /* 1Ch */
     U8                      BoardAssembly[16];          /* 2Ch */
     U8                      BoardTracerNumber[16];      /* 3Ch */
 
-} fCONFIG_PAGE_MANUFACTURING_0, MPI_POINTER PTR_CONFIG_PAGE_MANUFACTURING_0,
+} CONFIG_PAGE_MANUFACTURING_0, MPI_POINTER PTR_CONFIG_PAGE_MANUFACTURING_0,
   ManufacturingPage0_t, MPI_POINTER pManufacturingPage0_t;
 
 #define MPI_MANUFACTURING0_PAGEVERSION                 (0x00)
@@ -317,9 +512,9 @@ typedef struct _CONFIG_PAGE_MANUFACTURIN
 
 typedef struct _CONFIG_PAGE_MANUFACTURING_1
 {
-    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U8                      VPD[256];                   /* 04h */
-} fCONFIG_PAGE_MANUFACTURING_1, MPI_POINTER PTR_CONFIG_PAGE_MANUFACTURING_1,
+} CONFIG_PAGE_MANUFACTURING_1, MPI_POINTER PTR_CONFIG_PAGE_MANUFACTURING_1,
   ManufacturingPage1_t, MPI_POINTER pManufacturingPage1_t;
 
 #define MPI_MANUFACTURING1_PAGEVERSION                 (0x00)
@@ -344,10 +539,10 @@ typedef struct _MPI_CHIP_REVISION_ID
 
 typedef struct _CONFIG_PAGE_MANUFACTURING_2
 {
-    fCONFIG_PAGE_HEADER      Header;                                 /* 00h */
+    CONFIG_PAGE_HEADER      Header;                                 /* 00h */
     MPI_CHIP_REVISION_ID    ChipId;                                 /* 04h */
     U32                     HwSettings[MPI_MAN_PAGE_2_HW_SETTINGS_WORDS];/* 08h */
-} fCONFIG_PAGE_MANUFACTURING_2, MPI_POINTER PTR_CONFIG_PAGE_MANUFACTURING_2,
+} CONFIG_PAGE_MANUFACTURING_2, MPI_POINTER PTR_CONFIG_PAGE_MANUFACTURING_2,
   ManufacturingPage2_t, MPI_POINTER pManufacturingPage2_t;
 
 #define MPI_MANUFACTURING2_PAGEVERSION                  (0x00)
@@ -363,10 +558,10 @@ typedef struct _CONFIG_PAGE_MANUFACTURIN
 
 typedef struct _CONFIG_PAGE_MANUFACTURING_3
 {
-    fCONFIG_PAGE_HEADER                  Header;                     /* 00h */
+    CONFIG_PAGE_HEADER                  Header;                     /* 00h */
     MPI_CHIP_REVISION_ID                ChipId;                     /* 04h */
     U32                                 Info[MPI_MAN_PAGE_3_INFO_WORDS];/* 08h */
-} fCONFIG_PAGE_MANUFACTURING_3, MPI_POINTER PTR_CONFIG_PAGE_MANUFACTURING_3,
+} CONFIG_PAGE_MANUFACTURING_3, MPI_POINTER PTR_CONFIG_PAGE_MANUFACTURING_3,
   ManufacturingPage3_t, MPI_POINTER pManufacturingPage3_t;
 
 #define MPI_MANUFACTURING3_PAGEVERSION                  (0x00)
@@ -374,23 +569,65 @@ typedef struct _CONFIG_PAGE_MANUFACTURIN
 
 typedef struct _CONFIG_PAGE_MANUFACTURING_4
 {
-    fCONFIG_PAGE_HEADER              Header;             /* 00h */
+    CONFIG_PAGE_HEADER              Header;             /* 00h */
     U32                             Reserved1;          /* 04h */
     U8                              InfoOffset0;        /* 08h */
     U8                              InfoSize0;          /* 09h */
     U8                              InfoOffset1;        /* 0Ah */
     U8                              InfoSize1;          /* 0Bh */
     U8                              InquirySize;        /* 0Ch */
-    U8                              Reserved2;          /* 0Dh */
-    U16                             Reserved3;          /* 0Eh */
+    U8                              Flags;              /* 0Dh */
+    U16                             Reserved2;          /* 0Eh */
     U8                              InquiryData[56];    /* 10h */
     U32                             ISVolumeSettings;   /* 48h */
     U32                             IMEVolumeSettings;  /* 4Ch */
     U32                             IMVolumeSettings;   /* 50h */
-} fCONFIG_PAGE_MANUFACTURING_4, MPI_POINTER PTR_CONFIG_PAGE_MANUFACTURING_4,
+    U32                             Reserved3;          /* 54h */
+    U32                             Reserved4;          /* 58h */
+    U8                              ISDataScrubRate;    /* 5Ch */
+    U8                              ISResyncRate;       /* 5Dh */
+    U16                             Reserved5;          /* 5Eh */
+    U8                              IMEDataScrubRate;   /* 60h */
+    U8                              IMEResyncRate;      /* 61h */
+    U16                             Reserved6;          /* 62h */
+    U8                              IMDataScrubRate;    /* 64h */
+    U8                              IMResyncRate;       /* 65h */
+    U16                             Reserved7;          /* 66h */
+    U32                             Reserved8;          /* 68h */
+    U32                             Reserved9;          /* 6Ch */
+} CONFIG_PAGE_MANUFACTURING_4, MPI_POINTER PTR_CONFIG_PAGE_MANUFACTURING_4,
   ManufacturingPage4_t, MPI_POINTER pManufacturingPage4_t;
 
-#define MPI_MANUFACTURING4_PAGEVERSION                  (0x00)
+#define MPI_MANUFACTURING4_PAGEVERSION                  (0x02)
+
+/* defines for the Flags field */
+#define MPI_MANPAGE4_IR_NO_MIX_SAS_SATA                 (0x01)
+
+
+typedef struct _CONFIG_PAGE_MANUFACTURING_5
+{
+    CONFIG_PAGE_HEADER              Header;             /* 00h */
+    U64                             BaseWWID;           /* 04h */
+    U8                              Flags;              /* 0Ch */
+    U8                              Reserved1;          /* 0Dh */
+    U16                             Reserved2;          /* 0Eh */
+} CONFIG_PAGE_MANUFACTURING_5, MPI_POINTER PTR_CONFIG_PAGE_MANUFACTURING_5,
+  ManufacturingPage5_t, MPI_POINTER pManufacturingPage5_t;
+
+#define MPI_MANUFACTURING5_PAGEVERSION                  (0x01)
+
+/* defines for the Flags field */
+#define MPI_MANPAGE5_TWO_WWID_PER_PHY                   (0x01)
+
+
+typedef struct _CONFIG_PAGE_MANUFACTURING_6
+{
+    CONFIG_PAGE_HEADER              Header;             /* 00h */
+    U32                             ProductSpecificInfo;/* 04h */
+} CONFIG_PAGE_MANUFACTURING_6, MPI_POINTER PTR_CONFIG_PAGE_MANUFACTURING_6,
+  ManufacturingPage6_t, MPI_POINTER pManufacturingPage6_t;
+
+#define MPI_MANUFACTURING6_PAGEVERSION                  (0x00)
 
 
 /****************************************************************************
@@ -399,9 +636,9 @@ typedef struct _CONFIG_PAGE_MANUFACTURIN
 
 typedef struct _CONFIG_PAGE_IO_UNIT_0
 {
-    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U64                     UniqueValue;                /* 04h */
-} fCONFIG_PAGE_IO_UNIT_0, MPI_POINTER PTR_CONFIG_PAGE_IO_UNIT_0,
+} CONFIG_PAGE_IO_UNIT_0, MPI_POINTER PTR_CONFIG_PAGE_IO_UNIT_0,
   IOUnitPage0_t, MPI_POINTER pIOUnitPage0_t;
 
 #define MPI_IOUNITPAGE0_PAGEVERSION                     (0x00)
@@ -409,21 +646,23 @@ typedef struct _CONFIG_PAGE_IO_UNIT_0
 
 typedef struct _CONFIG_PAGE_IO_UNIT_1
 {
-    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Flags;                      /* 04h */
-} fCONFIG_PAGE_IO_UNIT_1, MPI_POINTER PTR_CONFIG_PAGE_IO_UNIT_1,
+} CONFIG_PAGE_IO_UNIT_1, MPI_POINTER PTR_CONFIG_PAGE_IO_UNIT_1,
   IOUnitPage1_t, MPI_POINTER pIOUnitPage1_t;
 
-#define MPI_IOUNITPAGE1_PAGEVERSION                     (0x00)
+#define MPI_IOUNITPAGE1_PAGEVERSION                     (0x01)
 
 /* IO Unit Page 1 Flags defines */
-
 #define MPI_IOUNITPAGE1_MULTI_FUNCTION                  (0x00000000)
 #define MPI_IOUNITPAGE1_SINGLE_FUNCTION                 (0x00000001)
 #define MPI_IOUNITPAGE1_MULTI_PATHING                   (0x00000002)
 #define MPI_IOUNITPAGE1_SINGLE_PATHING                  (0x00000000)
+#define MPI_IOUNITPAGE1_IR_USE_STATIC_VOLUME_ID         (0x00000004)
+#define MPI_IOUNITPAGE1_DISABLE_QUEUE_FULL_HANDLING     (0x00000020)
 #define MPI_IOUNITPAGE1_DISABLE_IR                      (0x00000040)
 #define MPI_IOUNITPAGE1_FORCE_32                        (0x00000080)
+#define MPI_IOUNITPAGE1_NATIVE_COMMAND_Q_DISABLE        (0x00000100)
 
 
 typedef struct _MPI_ADAPTER_INFO
@@ -439,20 +678,26 @@ typedef struct _MPI_ADAPTER_INFO
 
 typedef struct _CONFIG_PAGE_IO_UNIT_2
 {
-    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Flags;                      /* 04h */
     U32                     BiosVersion;                /* 08h */
     MPI_ADAPTER_INFO        AdapterOrder[4];            /* 0Ch */
-} fCONFIG_PAGE_IO_UNIT_2, MPI_POINTER PTR_CONFIG_PAGE_IO_UNIT_2,
+    U32                     Reserved1;                  /* 1Ch */
+} CONFIG_PAGE_IO_UNIT_2, MPI_POINTER PTR_CONFIG_PAGE_IO_UNIT_2,
   IOUnitPage2_t, MPI_POINTER pIOUnitPage2_t;
 
-#define MPI_IOUNITPAGE2_PAGEVERSION                     (0x00)
+#define MPI_IOUNITPAGE2_PAGEVERSION                     (0x02)
 
 #define MPI_IOUNITPAGE2_FLAGS_PAUSE_ON_ERROR            (0x00000002)
 #define MPI_IOUNITPAGE2_FLAGS_VERBOSE_ENABLE            (0x00000004)
 #define MPI_IOUNITPAGE2_FLAGS_COLOR_VIDEO_DISABLE       (0x00000008)
 #define MPI_IOUNITPAGE2_FLAGS_DONT_HOOK_INT_40          (0x00000010)
 
+#define MPI_IOUNITPAGE2_FLAGS_DEV_LIST_DISPLAY_MASK     (0x000000E0)
+#define MPI_IOUNITPAGE2_FLAGS_INSTALLED_DEV_DISPLAY     (0x00000000)
+#define MPI_IOUNITPAGE2_FLAGS_ADAPTER_DISPLAY           (0x00000020)
+#define MPI_IOUNITPAGE2_FLAGS_ADAPTER_DEV_DISPLAY       (0x00000040)
+
 
 /*
  * Host code (drivers, BIOS, utilities, etc.) should leave this define set to
@@ -464,12 +709,12 @@ typedef struct _CONFIG_PAGE_IO_UNIT_2
 
 typedef struct _CONFIG_PAGE_IO_UNIT_3
 {
-    fCONFIG_PAGE_HEADER      Header;                                   /* 00h */
+    CONFIG_PAGE_HEADER      Header;                                   /* 00h */
     U8                      GPIOCount;                                /* 04h */
     U8                      Reserved1;                                /* 05h */
     U16                     Reserved2;                                /* 06h */
     U16                     GPIOVal[MPI_IO_UNIT_PAGE_3_GPIO_VAL_MAX]; /* 08h */
-} fCONFIG_PAGE_IO_UNIT_3, MPI_POINTER PTR_CONFIG_PAGE_IO_UNIT_3,
+} CONFIG_PAGE_IO_UNIT_3, MPI_POINTER PTR_CONFIG_PAGE_IO_UNIT_3,
   IOUnitPage3_t, MPI_POINTER pIOUnitPage3_t;
 
 #define MPI_IOUNITPAGE3_PAGEVERSION                     (0x01)
@@ -480,13 +725,24 @@ typedef struct _CONFIG_PAGE_IO_UNIT_3
 #define MPI_IOUNITPAGE3_GPIO_SETTING_ON                 (0x01)
 
 
+typedef struct _CONFIG_PAGE_IO_UNIT_4
+{
+    CONFIG_PAGE_HEADER      Header;                                   /* 00h */
+    U32                     Reserved1;                                /* 04h */
+    SGE_SIMPLE_UNION        FWImageSGE;                               /* 08h */
+} CONFIG_PAGE_IO_UNIT_4, MPI_POINTER PTR_CONFIG_PAGE_IO_UNIT_4,
+  IOUnitPage4_t, MPI_POINTER pIOUnitPage4_t;
+
+#define MPI_IOUNITPAGE4_PAGEVERSION                     (0x00)
+
+
 /****************************************************************************
 *   IOC Config Pages
 ****************************************************************************/
 
 typedef struct _CONFIG_PAGE_IOC_0
 {
-    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     TotalNVStore;               /* 04h */
     U32                     FreeNVStore;                /* 08h */
     U16                     VendorID;                   /* 0Ch */
@@ -496,7 +752,7 @@ typedef struct _CONFIG_PAGE_IOC_0
     U32                     ClassCode;                  /* 14h */
     U16                     SubsystemVendorID;          /* 18h */
     U16                     SubsystemID;                /* 1Ah */
-} fCONFIG_PAGE_IOC_0, MPI_POINTER PTR_CONFIG_PAGE_IOC_0,
+} CONFIG_PAGE_IOC_0, MPI_POINTER PTR_CONFIG_PAGE_IOC_0,
   IOCPage0_t, MPI_POINTER pIOCPage0_t;
 
 #define MPI_IOCPAGE0_PAGEVERSION                        (0x01)
@@ -504,17 +760,19 @@ typedef struct _CONFIG_PAGE_IOC_0
 
 typedef struct _CONFIG_PAGE_IOC_1
 {
-    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Flags;                      /* 04h */
     U32                     CoalescingTimeout;          /* 08h */
     U8                      CoalescingDepth;            /* 0Ch */
     U8                      PCISlotNum;                 /* 0Dh */
     U8                      Reserved[2];                /* 0Eh */
-} fCONFIG_PAGE_IOC_1, MPI_POINTER PTR_CONFIG_PAGE_IOC_1,
+} CONFIG_PAGE_IOC_1, MPI_POINTER PTR_CONFIG_PAGE_IOC_1,
   IOCPage1_t, MPI_POINTER pIOCPage1_t;
 
-#define MPI_IOCPAGE1_PAGEVERSION                        (0x01)
+#define MPI_IOCPAGE1_PAGEVERSION                        (0x02)
 
+/* defines for the Flags field */
+#define MPI_IOCPAGE1_INITIATOR_CONTEXT_REPLY_DISABLE    (0x00000010)
 #define MPI_IOCPAGE1_REPLY_COALESCING                   (0x00000001)
 
 #define MPI_IOCPAGE1_PCISLOTNUM_UNKNOWN                 (0xFF)
@@ -529,7 +787,7 @@ typedef struct _CONFIG_PAGE_IOC_2_RAID_V
     U8                          VolumeType;             /* 04h */
     U8                          Flags;                  /* 05h */
     U16                         Reserved3;              /* 06h */
-} fCONFIG_PAGE_IOC_2_RAID_VOL, MPI_POINTER PTR_CONFIG_PAGE_IOC_2_RAID_VOL,
+} CONFIG_PAGE_IOC_2_RAID_VOL, MPI_POINTER PTR_CONFIG_PAGE_IOC_2_RAID_VOL,
   ConfigPageIoc2RaidVol_t, MPI_POINTER pConfigPageIoc2RaidVol_t;
 
 /* IOC Page 2 Volume RAID Type values, also used in RAID Volume pages */
@@ -552,14 +810,14 @@ typedef struct _CONFIG_PAGE_IOC_2_RAID_V
 
 typedef struct _CONFIG_PAGE_IOC_2
 {
-    fCONFIG_PAGE_HEADER          Header;                              /* 00h */
+    CONFIG_PAGE_HEADER          Header;                              /* 00h */
     U32                         CapabilitiesFlags;                   /* 04h */
     U8                          NumActiveVolumes;                    /* 08h */
     U8                          MaxVolumes;                          /* 09h */
     U8                          NumActivePhysDisks;                  /* 0Ah */
     U8                          MaxPhysDisks;                        /* 0Bh */
-    fCONFIG_PAGE_IOC_2_RAID_VOL  RaidVolume[MPI_IOC_PAGE_2_RAID_VOLUME_MAX];/* 0Ch */
-} fCONFIG_PAGE_IOC_2, MPI_POINTER PTR_CONFIG_PAGE_IOC_2,
+    CONFIG_PAGE_IOC_2_RAID_VOL  RaidVolume[MPI_IOC_PAGE_2_RAID_VOLUME_MAX];/* 0Ch */
+} CONFIG_PAGE_IOC_2, MPI_POINTER PTR_CONFIG_PAGE_IOC_2,
   IOCPage2_t, MPI_POINTER pIOCPage2_t;
 
 #define MPI_IOCPAGE2_PAGEVERSION                        (0x02)
@@ -593,12 +851,12 @@ typedef struct _IOC_3_PHYS_DISK
 
 typedef struct _CONFIG_PAGE_IOC_3
 {
-    fCONFIG_PAGE_HEADER          Header;                                /* 00h */
+    CONFIG_PAGE_HEADER          Header;                                /* 00h */
     U8                          NumPhysDisks;                          /* 04h */
     U8                          Reserved1;                             /* 05h */
     U16                         Reserved2;                             /* 06h */
     IOC_3_PHYS_DISK             PhysDisk[MPI_IOC_PAGE_3_PHYSDISK_MAX]; /* 08h */
-} fCONFIG_PAGE_IOC_3, MPI_POINTER PTR_CONFIG_PAGE_IOC_3,
+} CONFIG_PAGE_IOC_3, MPI_POINTER PTR_CONFIG_PAGE_IOC_3,
   IOCPage3_t, MPI_POINTER pIOCPage3_t;
 
 #define MPI_IOCPAGE3_PAGEVERSION                        (0x00)
@@ -622,12 +880,12 @@ typedef struct _IOC_4_SEP
 
 typedef struct _CONFIG_PAGE_IOC_4
 {
-    fCONFIG_PAGE_HEADER          Header;                         /* 00h */
+    CONFIG_PAGE_HEADER          Header;                         /* 00h */
     U8                          ActiveSEP;                      /* 04h */
     U8                          MaxSEP;                         /* 05h */
     U16                         Reserved1;                      /* 06h */
     IOC_4_SEP                   SEP[MPI_IOC_PAGE_4_SEP_MAX];    /* 08h */
-} fCONFIG_PAGE_IOC_4, MPI_POINTER PTR_CONFIG_PAGE_IOC_4,
+} CONFIG_PAGE_IOC_4, MPI_POINTER PTR_CONFIG_PAGE_IOC_4,
   IOCPage4_t, MPI_POINTER pIOCPage4_t;
 
 #define MPI_IOCPAGE4_PAGEVERSION                        (0x00)
@@ -655,18 +913,261 @@ typedef struct _IOC_5_HOT_SPARE
 
 typedef struct _CONFIG_PAGE_IOC_5
 {
-    fCONFIG_PAGE_HEADER         Header;                         /* 00h */
+    CONFIG_PAGE_HEADER          Header;                         /* 00h */
     U32                         Reserved1;                      /* 04h */
     U8                          NumHotSpares;                   /* 08h */
     U8                          Reserved2;                      /* 09h */
     U16                         Reserved3;                      /* 0Ah */
     IOC_5_HOT_SPARE             HotSpare[MPI_IOC_PAGE_5_HOT_SPARE_MAX]; /* 0Ch */
-} fCONFIG_PAGE_IOC_5, MPI_POINTER PTR_CONFIG_PAGE_IOC_5,
+} CONFIG_PAGE_IOC_5, MPI_POINTER PTR_CONFIG_PAGE_IOC_5,
   IOCPage5_t, MPI_POINTER pIOCPage5_t;
 
 #define MPI_IOCPAGE5_PAGEVERSION                        (0x00)
 
 
+/****************************************************************************
+*   BIOS Config Pages
+****************************************************************************/
+
+typedef struct _CONFIG_PAGE_BIOS_1
+{
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
+    U32                     BiosOptions;                /* 04h */
+    U32                     IOCSettings;                /* 08h */
+    U32                     Reserved1;                  /* 0Ch */
+    U32                     DeviceSettings;             /* 10h */
+    U16                     NumberOfDevices;            /* 14h */
+    U16                     Reserved2;                  /* 16h */
+    U16                     IOTimeoutBlockDevicesNonRM; /* 18h */
+    U16                     IOTimeoutSequential;        /* 1Ah */
+    U16                     IOTimeoutOther;             /* 1Ch */
+    U16                     IOTimeoutBlockDevicesRM;    /* 1Eh */
+} CONFIG_PAGE_BIOS_1, MPI_POINTER PTR_CONFIG_PAGE_BIOS_1,
+  BIOSPage1_t, MPI_POINTER pBIOSPage1_t;
+
+#define MPI_BIOSPAGE1_PAGEVERSION                       (0x01)
+
+/* values for the BiosOptions field */
+#define MPI_BIOSPAGE1_OPTIONS_SPI_ENABLE                (0x00000400)
+#define MPI_BIOSPAGE1_OPTIONS_FC_ENABLE                 (0x00000200)
+#define MPI_BIOSPAGE1_OPTIONS_SAS_ENABLE                (0x00000100)
+#define MPI_BIOSPAGE1_OPTIONS_DISABLE_BIOS              (0x00000001)
+
+/* values for the IOCSettings field */
+#define MPI_BIOSPAGE1_IOCSET_MASK_BOOT_PREFERENCE       (0x00030000)
+#define MPI_BIOSPAGE1_IOCSET_ENCLOSURE_SLOT_BOOT        (0x00000000)
+#define MPI_BIOSPAGE1_IOCSET_SAS_ADDRESS_BOOT           (0x00010000)
+
+#define MPI_BIOSPAGE1_IOCSET_MASK_MAX_TARGET_SPIN_UP    (0x0000F000)
+#define MPI_BIOSPAGE1_IOCSET_SHIFT_MAX_TARGET_SPIN_UP   (12)
+
+#define MPI_BIOSPAGE1_IOCSET_MASK_SPINUP_DELAY          (0x00000F00)
+#define MPI_BIOSPAGE1_IOCSET_SHIFT_SPINUP_DELAY         (8)
+
+#define MPI_BIOSPAGE1_IOCSET_MASK_RM_SETTING            (0x000000C0)
+#define MPI_BIOSPAGE1_IOCSET_NONE_RM_SETTING            (0x00000000)
+#define MPI_BIOSPAGE1_IOCSET_BOOT_RM_SETTING            (0x00000040)
+#define MPI_BIOSPAGE1_IOCSET_MEDIA_RM_SETTING           (0x00000080)
+
+#define MPI_BIOSPAGE1_IOCSET_MASK_ADAPTER_SUPPORT       (0x00000030)
+#define MPI_BIOSPAGE1_IOCSET_NO_SUPPORT                 (0x00000000)
+#define MPI_BIOSPAGE1_IOCSET_BIOS_SUPPORT               (0x00000010)
+#define MPI_BIOSPAGE1_IOCSET_OS_SUPPORT                 (0x00000020)
+#define MPI_BIOSPAGE1_IOCSET_ALL_SUPPORT                (0x00000030)
+
+#define MPI_BIOSPAGE1_IOCSET_ALTERNATE_CHS              (0x00000008)
+
+/* values for the DeviceSettings field */
+#define MPI_BIOSPAGE1_DEVSET_DISABLE_SEQ_LUN            (0x00000008)
+#define MPI_BIOSPAGE1_DEVSET_DISABLE_RM_LUN             (0x00000004)
+#define MPI_BIOSPAGE1_DEVSET_DISABLE_NON_RM_LUN         (0x00000002)
+#define MPI_BIOSPAGE1_DEVSET_DISABLE_OTHER_LUN          (0x00000001)
+
+typedef struct _MPI_BOOT_DEVICE_ADAPTER_ORDER
+{
+    U32         Reserved1;                              /* 00h */
+    U32         Reserved2;                              /* 04h */
+    U32         Reserved3;                              /* 08h */
+    U32         Reserved4;                              /* 0Ch */
+    U32         Reserved5;                              /* 10h */
+    U32         Reserved6;                              /* 14h */
+    U32         Reserved7;                              /* 18h */
+    U32         Reserved8;                              /* 1Ch */
+    U32         Reserved9;                              /* 20h */
+    U32         Reserved10;                             /* 24h */
+    U32         Reserved11;                             /* 28h */
+    U32         Reserved12;                             /* 2Ch */
+    U32         Reserved13;                             /* 30h */
+    U32         Reserved14;                             /* 34h */
+    U32         Reserved15;                             /* 38h */
+    U32         Reserved16;                             /* 3Ch */
+    U32         Reserved17;                             /* 40h */
+} MPI_BOOT_DEVICE_ADAPTER_ORDER, MPI_POINTER PTR_MPI_BOOT_DEVICE_ADAPTER_ORDER;
+
+typedef struct _MPI_BOOT_DEVICE_ADAPTER_NUMBER
+{
+    U8          TargetID;                               /* 00h */
+    U8          Bus;                                    /* 01h */
+    U8          AdapterNumber;                          /* 02h */
+    U8          Reserved1;                              /* 03h */
+    U32         Reserved2;                              /* 04h */
+    U32         Reserved3;                              /* 08h */
+    U32         Reserved4;                              /* 0Ch */
+    U8          LUN[8];                                 /* 10h */
+    U32         Reserved5;                              /* 18h */
+    U32         Reserved6;                              /* 1Ch */
+    U32         Reserved7;                              /* 20h */
+    U32         Reserved8;                              /* 24h */
+    U32         Reserved9;                              /* 28h */
+    U32         Reserved10;                             /* 2Ch */
+    U32         Reserved11;                             /* 30h */
+    U32         Reserved12;                             /* 34h */
+    U32         Reserved13;                             /* 38h */
+    U32         Reserved14;                             /* 3Ch */
+    U32         Reserved15;                             /* 40h */
+} MPI_BOOT_DEVICE_ADAPTER_NUMBER, MPI_POINTER PTR_MPI_BOOT_DEVICE_ADAPTER_NUMBER;
+
+typedef struct _MPI_BOOT_DEVICE_PCI_ADDRESS
+{
+    U8          TargetID;                               /* 00h */
+    U8          Bus;                                    /* 01h */
+    U16         PCIAddress;                             /* 02h */
+    U32         Reserved1;                              /* 04h */
+    U32         Reserved2;                              /* 08h */
+    U32         Reserved3;                              /* 0Ch */
+    U8          LUN[8];                                 /* 10h */
+    U32         Reserved4;                              /* 18h */
+    U32         Reserved5;                              /* 1Ch */
+    U32         Reserved6;                              /* 20h */
+    U32         Reserved7;                              /* 24h */
+    U32         Reserved8;                              /* 28h */
+    U32         Reserved9;                              /* 2Ch */
+    U32         Reserved10;                             /* 30h */
+    U32         Reserved11;                             /* 34h */
+    U32         Reserved12;                             /* 38h */
+    U32         Reserved13;                             /* 3Ch */
+    U32         Reserved14;                             /* 40h */
+} MPI_BOOT_DEVICE_PCI_ADDRESS, MPI_POINTER PTR_MPI_BOOT_DEVICE_PCI_ADDRESS;
+
+typedef struct _MPI_BOOT_DEVICE_SLOT_NUMBER
+{
+    U8          TargetID;                               /* 00h */
+    U8          Bus;                                    /* 01h */
+    U8          PCISlotNumber;                          /* 02h */
+    U8          Reserved1;                              /* 03h */
+    U32         Reserved2;                              /* 04h */
+    U32         Reserved3;                              /* 08h */
+    U32         Reserved4;                              /* 0Ch */
+    U8          LUN[8];                                 /* 10h */
+    U32         Reserved5;                              /* 18h */
+    U32         Reserved6;                              /* 1Ch */
+    U32         Reserved7;                              /* 20h */
+    U32         Reserved8;                              /* 24h */
+    U32         Reserved9;                              /* 28h */
+    U32         Reserved10;                             /* 2Ch */
+    U32         Reserved11;                             /* 30h */
+    U32         Reserved12;                             /* 34h */
+    U32         Reserved13;                             /* 38h */
+    U32         Reserved14;                             /* 3Ch */
+    U32         Reserved15;                             /* 40h */
+} MPI_BOOT_DEVICE_PCI_SLOT_NUMBER, MPI_POINTER PTR_MPI_BOOT_DEVICE_PCI_SLOT_NUMBER;
+
+typedef struct _MPI_BOOT_DEVICE_FC_WWN
+{
+    U64         WWPN;                                   /* 00h */
+    U32         Reserved1;                              /* 08h */
+    U32         Reserved2;                              /* 0Ch */
+    U8          LUN[8];                                 /* 10h */
+    U32         Reserved3;                              /* 18h */
+    U32         Reserved4;                              /* 1Ch */
+    U32         Reserved5;                              /* 20h */
+    U32         Reserved6;                              /* 24h */
+    U32         Reserved7;                              /* 28h */
+    U32         Reserved8;                              /* 2Ch */
+    U32         Reserved9;                              /* 30h */
+    U32         Reserved10;                             /* 34h */
+    U32         Reserved11;                             /* 38h */
+    U32         Reserved12;                             /* 3Ch */
+    U32         Reserved13;                             /* 40h */
+} MPI_BOOT_DEVICE_FC_WWN, MPI_POINTER PTR_MPI_BOOT_DEVICE_FC_WWN;
+
+typedef struct _MPI_BOOT_DEVICE_SAS_WWN
+{
+    U64         SASAddress;                             /* 00h */
+    U32         Reserved1;                              /* 08h */
+    U32         Reserved2;                              /* 0Ch */
+    U8          LUN[8];                                 /* 10h */
+    U32         Reserved3;                              /* 18h */
+    U32         Reserved4;                              /* 1Ch */
+    U32         Reserved5;                              /* 20h */
+    U32         Reserved6;                              /* 24h */
+    U32         Reserved7;                              /* 28h */
+    U32         Reserved8;                              /* 2Ch */
+    U32         Reserved9;                              /* 30h */
+    U32         Reserved10;                             /* 34h */
+    U32         Reserved11;                             /* 38h */
+    U32         Reserved12;                             /* 3Ch */
+    U32         Reserved13;                             /* 40h */
+} MPI_BOOT_DEVICE_SAS_WWN, MPI_POINTER PTR_MPI_BOOT_DEVICE_SAS_WWN;
+
+typedef struct _MPI_BOOT_DEVICE_ENCLOSURE_SLOT
+{
+    U64         EnclosureLogicalID;                     /* 00h */
+    U32         Reserved1;                              /* 08h */
+    U32         Reserved2;                              /* 0Ch */
+    U8          LUN[8];                                 /* 10h */
+    U16         SlotNumber;                             /* 18h */
+    U16         Reserved3;                              /* 1Ah */
+    U32         Reserved4;                              /* 1Ch */
+    U32         Reserved5;                              /* 20h */
+    U32         Reserved6;                              /* 24h */
+    U32         Reserved7;                              /* 28h */
+    U32         Reserved8;                              /* 2Ch */
+    U32         Reserved9;                              /* 30h */
+    U32         Reserved10;                             /* 34h */
+    U32         Reserved11;                             /* 38h */
+    U32         Reserved12;                             /* 3Ch */
+    U32         Reserved13;                             /* 40h */
+} MPI_BOOT_DEVICE_ENCLOSURE_SLOT,
+  MPI_POINTER PTR_MPI_BOOT_DEVICE_ENCLOSURE_SLOT;
+
+typedef union _MPI_BIOSPAGE2_BOOT_DEVICE
+{
+    MPI_BOOT_DEVICE_ADAPTER_ORDER   AdapterOrder;
+    MPI_BOOT_DEVICE_ADAPTER_NUMBER  AdapterNumber;
+    MPI_BOOT_DEVICE_PCI_ADDRESS     PCIAddress;
+    MPI_BOOT_DEVICE_PCI_SLOT_NUMBER PCISlotNumber;
+    MPI_BOOT_DEVICE_FC_WWN          FcWwn;
+    MPI_BOOT_DEVICE_SAS_WWN         SasWwn;
+    MPI_BOOT_DEVICE_ENCLOSURE_SLOT  EnclosureSlot;
+} MPI_BIOSPAGE2_BOOT_DEVICE, MPI_POINTER PTR_MPI_BIOSPAGE2_BOOT_DEVICE;
+
+typedef struct _CONFIG_PAGE_BIOS_2
+{
+    CONFIG_PAGE_HEADER          Header;                 /* 00h */
+    U32                         Reserved1;              /* 04h */
+    U32                         Reserved2;              /* 08h */
+    U32                         Reserved3;              /* 0Ch */
+    U32                         Reserved4;              /* 10h */
+    U32                         Reserved5;              /* 14h */
+    U32                         Reserved6;              /* 18h */
+    U8                          BootDeviceForm;         /* 1Ch */
+    U8                          Reserved7;              /* 1Dh */
+    U16                         Reserved8;              /* 1Eh */
+    MPI_BIOSPAGE2_BOOT_DEVICE   BootDevice;             /* 20h */
+} CONFIG_PAGE_BIOS_2, MPI_POINTER PTR_CONFIG_PAGE_BIOS_2,
+  BIOSPage2_t, MPI_POINTER pBIOSPage2_t;
+
+#define MPI_BIOSPAGE2_PAGEVERSION                       (0x01)
+
+#define MPI_BIOSPAGE2_FORM_MASK                         (0x0F)
+#define MPI_BIOSPAGE2_FORM_ADAPTER_ORDER                (0x00)
+#define MPI_BIOSPAGE2_FORM_ADAPTER_NUMBER               (0x01)
+#define MPI_BIOSPAGE2_FORM_PCI_ADDRESS                  (0x02)
+#define MPI_BIOSPAGE2_FORM_PCI_SLOT_NUMBER              (0x03)
+#define MPI_BIOSPAGE2_FORM_FC_WWN                       (0x04)
+#define MPI_BIOSPAGE2_FORM_SAS_WWN                      (0x05)
+
 
 /****************************************************************************
 *   SCSI Port Config Pages
@@ -674,19 +1175,40 @@ typedef struct _CONFIG_PAGE_IOC_5
 
 typedef struct _CONFIG_PAGE_SCSI_PORT_0
 {
-    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Capabilities;               /* 04h */
     U32                     PhysicalInterface;          /* 08h */
-} fCONFIG_PAGE_SCSI_PORT_0, MPI_POINTER PTR_CONFIG_PAGE_SCSI_PORT_0,
+} CONFIG_PAGE_SCSI_PORT_0, MPI_POINTER PTR_CONFIG_PAGE_SCSI_PORT_0,
   SCSIPortPage0_t, MPI_POINTER pSCSIPortPage0_t;
 
-#define MPI_SCSIPORTPAGE0_PAGEVERSION                   (0x01)
+#define MPI_SCSIPORTPAGE0_PAGEVERSION                   (0x02)
 
 #define MPI_SCSIPORTPAGE0_CAP_IU                        (0x00000001)
 #define MPI_SCSIPORTPAGE0_CAP_DT                        (0x00000002)
 #define MPI_SCSIPORTPAGE0_CAP_QAS                       (0x00000004)
 #define MPI_SCSIPORTPAGE0_CAP_MIN_SYNC_PERIOD_MASK      (0x0000FF00)
+#define MPI_SCSIPORTPAGE0_SYNC_ASYNC                    (0x00)
+#define MPI_SCSIPORTPAGE0_SYNC_5                        (0x32)
+#define MPI_SCSIPORTPAGE0_SYNC_10                       (0x19)
+#define MPI_SCSIPORTPAGE0_SYNC_20                       (0x0C)
+#define MPI_SCSIPORTPAGE0_SYNC_33_33                    (0x0B)
+#define MPI_SCSIPORTPAGE0_SYNC_40                       (0x0A)
+#define MPI_SCSIPORTPAGE0_SYNC_80                       (0x09)
+#define MPI_SCSIPORTPAGE0_SYNC_160                      (0x08)
+#define MPI_SCSIPORTPAGE0_SYNC_UNKNOWN                  (0xFF)
+
+#define MPI_SCSIPORTPAGE0_CAP_SHIFT_MIN_SYNC_PERIOD     (8)
+#define MPI_SCSIPORTPAGE0_CAP_GET_MIN_SYNC_PERIOD(Cap)      \
+    (  ((Cap) & MPI_SCSIPORTPAGE0_CAP_MASK_MIN_SYNC_PERIOD) \
+    >> MPI_SCSIPORTPAGE0_CAP_SHIFT_MIN_SYNC_PERIOD          \
+    )
 #define MPI_SCSIPORTPAGE0_CAP_MAX_SYNC_OFFSET_MASK      (0x00FF0000)
+#define MPI_SCSIPORTPAGE0_CAP_SHIFT_MAX_SYNC_OFFSET     (16)
+#define MPI_SCSIPORTPAGE0_CAP_GET_MAX_SYNC_OFFSET(Cap)      \
+    (  ((Cap) & MPI_SCSIPORTPAGE0_CAP_MASK_MAX_SYNC_OFFSET) \
+    >> MPI_SCSIPORTPAGE0_CAP_SHIFT_MAX_SYNC_OFFSET          \
+    )
+#define MPI_SCSIPORTPAGE0_CAP_IDP                       (0x08000000)
 #define MPI_SCSIPORTPAGE0_CAP_WIDE                      (0x20000000)
 #define MPI_SCSIPORTPAGE0_CAP_AIP                       (0x80000000)
 
@@ -694,20 +1216,33 @@ typedef struct _CONFIG_PAGE_SCSI_PORT_0
 #define MPI_SCSIPORTPAGE0_PHY_SIGNAL_HVD                (0x01)
 #define MPI_SCSIPORTPAGE0_PHY_SIGNAL_SE                 (0x02)
 #define MPI_SCSIPORTPAGE0_PHY_SIGNAL_LVD                (0x03)
+#define MPI_SCSIPORTPAGE0_PHY_MASK_CONNECTED_ID         (0xFF000000)
+#define MPI_SCSIPORTPAGE0_PHY_SHIFT_CONNECTED_ID        (24)
+#define MPI_SCSIPORTPAGE0_PHY_BUS_FREE_CONNECTED_ID     (0xFE)
+#define MPI_SCSIPORTPAGE0_PHY_UNKNOWN_CONNECTED_ID      (0xFF)
 
 
 typedef struct _CONFIG_PAGE_SCSI_PORT_1
 {
-    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Configuration;              /* 04h */
     U32                     OnBusTimerValue;            /* 08h */
-} fCONFIG_PAGE_SCSI_PORT_1, MPI_POINTER PTR_CONFIG_PAGE_SCSI_PORT_1,
+    U8                      TargetConfig;               /* 0Ch */
+    U8                      Reserved1;                  /* 0Dh */
+    U16                     IDConfig;                   /* 0Eh */
+} CONFIG_PAGE_SCSI_PORT_1, MPI_POINTER PTR_CONFIG_PAGE_SCSI_PORT_1,
   SCSIPortPage1_t, MPI_POINTER pSCSIPortPage1_t;
 
-#define MPI_SCSIPORTPAGE1_PAGEVERSION                   (0x02)
+#define MPI_SCSIPORTPAGE1_PAGEVERSION                   (0x03)
 
+/* Configuration values */
 #define MPI_SCSIPORTPAGE1_CFG_PORT_SCSI_ID_MASK         (0x000000FF)
 #define MPI_SCSIPORTPAGE1_CFG_PORT_RESPONSE_ID_MASK     (0xFFFF0000)
+#define MPI_SCSIPORTPAGE1_CFG_SHIFT_PORT_RESPONSE_ID    (16)
+
+/* TargetConfig values */
+#define MPI_SCSIPORTPAGE1_TARGCONFIG_TARG_ONLY        (0x01)
+#define MPI_SCSIPORTPAGE1_TARGCONFIG_INIT_TARG        (0x02)
 
 
 typedef struct _MPI_DEVICE_INFO
@@ -720,20 +1255,28 @@ typedef struct _MPI_DEVICE_INFO
 
 typedef struct _CONFIG_PAGE_SCSI_PORT_2
 {
-    fCONFIG_PAGE_HEADER  Header;                         /* 00h */
+    CONFIG_PAGE_HEADER  Header;                         /* 00h */
     U32                 PortFlags;                      /* 04h */
     U32                 PortSettings;                   /* 08h */
     MPI_DEVICE_INFO     DeviceSettings[16];             /* 0Ch */
-} fCONFIG_PAGE_SCSI_PORT_2, MPI_POINTER PTR_CONFIG_PAGE_SCSI_PORT_2,
+} CONFIG_PAGE_SCSI_PORT_2, MPI_POINTER PTR_CONFIG_PAGE_SCSI_PORT_2,
   SCSIPortPage2_t, MPI_POINTER pSCSIPortPage2_t;
 
-#define MPI_SCSIPORTPAGE2_PAGEVERSION                       (0x01)
+#define MPI_SCSIPORTPAGE2_PAGEVERSION                       (0x02)
 
+/* PortFlags values */
 #define MPI_SCSIPORTPAGE2_PORT_FLAGS_SCAN_HIGH_TO_LOW       (0x00000001)
 #define MPI_SCSIPORTPAGE2_PORT_FLAGS_AVOID_SCSI_RESET       (0x00000004)
 #define MPI_SCSIPORTPAGE2_PORT_FLAGS_ALTERNATE_CHS          (0x00000008)
 #define MPI_SCSIPORTPAGE2_PORT_FLAGS_TERMINATION_DISABLE    (0x00000010)
 
+#define MPI_SCSIPORTPAGE2_PORT_FLAGS_DV_MASK                (0x00000060)
+#define MPI_SCSIPORTPAGE2_PORT_FLAGS_FULL_DV                (0x00000000)
+#define MPI_SCSIPORTPAGE2_PORT_FLAGS_BASIC_DV_ONLY          (0x00000020)
+#define MPI_SCSIPORTPAGE2_PORT_FLAGS_OFF_DV                 (0x00000060)
+
+
+/* PortSettings values */
 #define MPI_SCSIPORTPAGE2_PORT_HOST_ID_MASK                 (0x0000000F)
 #define MPI_SCSIPORTPAGE2_PORT_MASK_INIT_HBA                (0x00000030)
 #define MPI_SCSIPORTPAGE2_PORT_DISABLE_INIT_HBA             (0x00000000)
@@ -741,7 +1284,11 @@ typedef struct _CONFIG_PAGE_SCSI_PORT_2
 #define MPI_SCSIPORTPAGE2_PORT_OS_INIT_HBA                  (0x00000020)
 #define MPI_SCSIPORTPAGE2_PORT_BIOS_OS_INIT_HBA             (0x00000030)
 #define MPI_SCSIPORTPAGE2_PORT_REMOVABLE_MEDIA              (0x000000C0)
+#define MPI_SCSIPORTPAGE2_PORT_RM_NONE                      (0x00000000)
+#define MPI_SCSIPORTPAGE2_PORT_RM_BOOT_ONLY                 (0x00000040)
+#define MPI_SCSIPORTPAGE2_PORT_RM_WITH_MEDIA                (0x00000080)
 #define MPI_SCSIPORTPAGE2_PORT_SPINUP_DELAY_MASK            (0x00000F00)
+#define MPI_SCSIPORTPAGE2_PORT_SHIFT_SPINUP_DELAY           (8)
 #define MPI_SCSIPORTPAGE2_PORT_MASK_NEGO_MASTER_SETTINGS    (0x00003000)
 #define MPI_SCSIPORTPAGE2_PORT_NEGO_MASTER_SETTINGS         (0x00000000)
 #define MPI_SCSIPORTPAGE2_PORT_NONE_MASTER_SETTINGS         (0x00001000)
@@ -761,13 +1308,13 @@ typedef struct _CONFIG_PAGE_SCSI_PORT_2
 
 typedef struct _CONFIG_PAGE_SCSI_DEVICE_0
 {
-    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     NegotiatedParameters;       /* 04h */
     U32                     Information;                /* 08h */
-} fCONFIG_PAGE_SCSI_DEVICE_0, MPI_POINTER PTR_CONFIG_PAGE_SCSI_DEVICE_0,
+} CONFIG_PAGE_SCSI_DEVICE_0, MPI_POINTER PTR_CONFIG_PAGE_SCSI_DEVICE_0,
   SCSIDevicePage0_t, MPI_POINTER pSCSIDevicePage0_t;
 
-#define MPI_SCSIDEVPAGE0_PAGEVERSION                    (0x03)
+#define MPI_SCSIDEVPAGE0_PAGEVERSION                    (0x04)
 
 #define MPI_SCSIDEVPAGE0_NP_IU                          (0x00000001)
 #define MPI_SCSIDEVPAGE0_NP_DT                          (0x00000002)
@@ -778,7 +1325,10 @@ typedef struct _CONFIG_PAGE_SCSI_DEVICE_
 #define MPI_SCSIDEVPAGE0_NP_RTI                         (0x00000040)
 #define MPI_SCSIDEVPAGE0_NP_PCOMP_EN                    (0x00000080)
 #define MPI_SCSIDEVPAGE0_NP_NEG_SYNC_PERIOD_MASK        (0x0000FF00)
+#define MPI_SCSIDEVPAGE0_NP_SHIFT_SYNC_PERIOD           (8)
 #define MPI_SCSIDEVPAGE0_NP_NEG_SYNC_OFFSET_MASK        (0x00FF0000)
+#define MPI_SCSIDEVPAGE0_NP_SHIFT_SYNC_OFFSET           (16)
+#define MPI_SCSIDEVPAGE0_NP_IDP                         (0x08000000)
 #define MPI_SCSIDEVPAGE0_NP_WIDE                        (0x20000000)
 #define MPI_SCSIDEVPAGE0_NP_AIP                         (0x80000000)
 
@@ -790,14 +1340,14 @@ typedef struct _CONFIG_PAGE_SCSI_DEVICE_
 
 typedef struct _CONFIG_PAGE_SCSI_DEVICE_1
 {
-    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     RequestedParameters;        /* 04h */
     U32                     Reserved;                   /* 08h */
     U32                     Configuration;              /* 0Ch */
-} fCONFIG_PAGE_SCSI_DEVICE_1, MPI_POINTER PTR_CONFIG_PAGE_SCSI_DEVICE_1,
+} CONFIG_PAGE_SCSI_DEVICE_1, MPI_POINTER PTR_CONFIG_PAGE_SCSI_DEVICE_1,
   SCSIDevicePage1_t, MPI_POINTER pSCSIDevicePage1_t;
 
-#define MPI_SCSIDEVPAGE1_PAGEVERSION                    (0x04)
+#define MPI_SCSIDEVPAGE1_PAGEVERSION                    (0x05)
 
 #define MPI_SCSIDEVPAGE1_RP_IU                          (0x00000001)
 #define MPI_SCSIDEVPAGE1_RP_DT                          (0x00000002)
@@ -808,7 +1358,10 @@ typedef struct _CONFIG_PAGE_SCSI_DEVICE_
 #define MPI_SCSIDEVPAGE1_RP_RTI                         (0x00000040)
 #define MPI_SCSIDEVPAGE1_RP_PCOMP_EN                    (0x00000080)
 #define MPI_SCSIDEVPAGE1_RP_MIN_SYNC_PERIOD_MASK        (0x0000FF00)
+#define MPI_SCSIDEVPAGE1_RP_SHIFT_MIN_SYNC_PERIOD       (8)
 #define MPI_SCSIDEVPAGE1_RP_MAX_SYNC_OFFSET_MASK        (0x00FF0000)
+#define MPI_SCSIDEVPAGE1_RP_SHIFT_MAX_SYNC_OFFSET       (16)
+#define MPI_SCSIDEVPAGE1_RP_IDP                         (0x08000000)
 #define MPI_SCSIDEVPAGE1_RP_WIDE                        (0x20000000)
 #define MPI_SCSIDEVPAGE1_RP_AIP                         (0x80000000)
 
@@ -820,11 +1373,11 @@ typedef struct _CONFIG_PAGE_SCSI_DEVICE_
 
 typedef struct _CONFIG_PAGE_SCSI_DEVICE_2
 {
-    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     DomainValidation;           /* 04h */
     U32                     ParityPipeSelect;           /* 08h */
     U32                     DataPipeSelect;             /* 0Ch */
-} fCONFIG_PAGE_SCSI_DEVICE_2, MPI_POINTER PTR_CONFIG_PAGE_SCSI_DEVICE_2,
+} CONFIG_PAGE_SCSI_DEVICE_2, MPI_POINTER PTR_CONFIG_PAGE_SCSI_DEVICE_2,
   SCSIDevicePage2_t, MPI_POINTER pSCSIDevicePage2_t;
 
 #define MPI_SCSIDEVPAGE2_PAGEVERSION                    (0x01)
@@ -861,12 +1414,12 @@ typedef struct _CONFIG_PAGE_SCSI_DEVICE_
 
 typedef struct _CONFIG_PAGE_SCSI_DEVICE_3
 {
-    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U16                     MsgRejectCount;             /* 04h */
     U16                     PhaseErrorCount;            /* 06h */
     U16                     ParityErrorCount;           /* 08h */
     U16                     Reserved;                   /* 0Ah */
-} fCONFIG_PAGE_SCSI_DEVICE_3, MPI_POINTER PTR_CONFIG_PAGE_SCSI_DEVICE_3,
+} CONFIG_PAGE_SCSI_DEVICE_3, MPI_POINTER PTR_CONFIG_PAGE_SCSI_DEVICE_3,
   SCSIDevicePage3_t, MPI_POINTER pSCSIDevicePage3_t;
 
 #define MPI_SCSIDEVPAGE3_PAGEVERSION                    (0x00)
@@ -881,7 +1434,7 @@ typedef struct _CONFIG_PAGE_SCSI_DEVICE_
 
 typedef struct _CONFIG_PAGE_FC_PORT_0
 {
-    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Flags;                      /* 04h */
     U8                      MPIPortNumber;              /* 08h */
     U8                      LinkType;                   /* 09h */
@@ -902,7 +1455,7 @@ typedef struct _CONFIG_PAGE_FC_PORT_0
     U8                      MaxHardAliasesSupported;    /* 49h */
     U8                      NumCurrentAliases;          /* 4Ah */
     U8                      Reserved1;                  /* 4Bh */
-} fCONFIG_PAGE_FC_PORT_0, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_0,
+} CONFIG_PAGE_FC_PORT_0, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_0,
   FCPortPage0_t, MPI_POINTER pFCPortPage0_t;
 
 #define MPI_FCPORTPAGE0_PAGEVERSION                     (0x02)
@@ -915,7 +1468,7 @@ typedef struct _CONFIG_PAGE_FC_PORT_0
 
 #define MPI_FCPORTPAGE0_FLAGS_ALIAS_ALPA_SUPPORTED      (0x00000010)
 #define MPI_FCPORTPAGE0_FLAGS_ALIAS_WWN_SUPPORTED       (0x00000020)
-#define MPI_FCPORTPAGE0_FLAGS_FABRIC_WWN_VALID          (0x00000030)
+#define MPI_FCPORTPAGE0_FLAGS_FABRIC_WWN_VALID          (0x00000040)
 
 #define MPI_FCPORTPAGE0_FLAGS_ATTACH_TYPE_MASK          (0x00000F00)
 #define MPI_FCPORTPAGE0_FLAGS_ATTACH_NO_INIT            (0x00000000)
@@ -954,18 +1507,23 @@ typedef struct _CONFIG_PAGE_FC_PORT_0
 #define MPI_FCPORTPAGE0_SUPPORT_CLASS_2                 (0x00000002)
 #define MPI_FCPORTPAGE0_SUPPORT_CLASS_3                 (0x00000004)
 
-#define MPI_FCPORTPAGE0_SUPPORT_1GBIT_SPEED             (0x00000001) /* (SNIA)HBA_PORTSPEED_1GBIT 1  1 GBit/sec  */
-#define MPI_FCPORTPAGE0_SUPPORT_2GBIT_SPEED             (0x00000002) /* (SNIA)HBA_PORTSPEED_2GBIT 2  2 GBit/sec  */
-#define MPI_FCPORTPAGE0_SUPPORT_10GBIT_SPEED            (0x00000004) /* (SNIA)HBA_PORTSPEED_10GBIT 4 10 GBit/sec */
+#define MPI_FCPORTPAGE0_SUPPORT_SPEED_UKNOWN            (0x00000000) /* (SNIA)HBA_PORTSPEED_UNKNOWN 0   Unknown - transceiver incapable of reporting */
+#define MPI_FCPORTPAGE0_SUPPORT_1GBIT_SPEED             (0x00000001) /* (SNIA)HBA_PORTSPEED_1GBIT   1   1 GBit/sec */
+#define MPI_FCPORTPAGE0_SUPPORT_2GBIT_SPEED             (0x00000002) /* (SNIA)HBA_PORTSPEED_2GBIT   2   2 GBit/sec */
+#define MPI_FCPORTPAGE0_SUPPORT_10GBIT_SPEED            (0x00000004) /* (SNIA)HBA_PORTSPEED_10GBIT  4  10 GBit/sec */
+#define MPI_FCPORTPAGE0_SUPPORT_4GBIT_SPEED             (0x00000008) /* (SNIA)HBA_PORTSPEED_4GBIT   8   4 GBit/sec */
 
+#define MPI_FCPORTPAGE0_CURRENT_SPEED_UKNOWN            MPI_FCPORTPAGE0_SUPPORT_SPEED_UKNOWN
 #define MPI_FCPORTPAGE0_CURRENT_SPEED_1GBIT             MPI_FCPORTPAGE0_SUPPORT_1GBIT_SPEED
 #define MPI_FCPORTPAGE0_CURRENT_SPEED_2GBIT             MPI_FCPORTPAGE0_SUPPORT_2GBIT_SPEED
 #define MPI_FCPORTPAGE0_CURRENT_SPEED_10GBIT            MPI_FCPORTPAGE0_SUPPORT_10GBIT_SPEED
+#define MPI_FCPORTPAGE0_CURRENT_SPEED_4GBIT             MPI_FCPORTPAGE0_SUPPORT_4GBIT_SPEED
+#define MPI_FCPORTPAGE0_CURRENT_SPEED_NOT_NEGOTIATED    (0x00008000)        /* (SNIA)HBA_PORTSPEED_NOT_NEGOTIATED (1<<15) Speed not established */
 
 
 typedef struct _CONFIG_PAGE_FC_PORT_1
 {
-    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Flags;                      /* 04h */
     U64                     NoSEEPROMWWNN;              /* 08h */
     U64                     NoSEEPROMWWPN;              /* 10h */
@@ -974,15 +1532,26 @@ typedef struct _CONFIG_PAGE_FC_PORT_1
     U8                      TopologyConfig;             /* 1Ah */
     U8                      AltConnector;               /* 1Bh */
     U8                      NumRequestedAliases;        /* 1Ch */
-    U8                      Reserved1;                  /* 1Dh */
-    U16                     Reserved2;                  /* 1Eh */
-} fCONFIG_PAGE_FC_PORT_1, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_1,
+    U8                      RR_TOV;                     /* 1Dh */
+    U8                      InitiatorDeviceTimeout;     /* 1Eh */
+    U8                      InitiatorIoPendTimeout;     /* 1Fh */
+} CONFIG_PAGE_FC_PORT_1, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_1,
   FCPortPage1_t, MPI_POINTER pFCPortPage1_t;
 
-#define MPI_FCPORTPAGE1_PAGEVERSION                     (0x04)
+#define MPI_FCPORTPAGE1_PAGEVERSION                     (0x06)
 
 #define MPI_FCPORTPAGE1_FLAGS_EXT_FCP_STATUS_EN         (0x08000000)
 #define MPI_FCPORTPAGE1_FLAGS_IMMEDIATE_ERROR_REPLY     (0x04000000)
+#define MPI_FCPORTPAGE1_FLAGS_FORCE_USE_NOSEEPROM_WWNS  (0x02000000)
+#define MPI_FCPORTPAGE1_FLAGS_VERBOSE_RESCAN_EVENTS     (0x01000000)
+#define MPI_FCPORTPAGE1_FLAGS_TARGET_MODE_OXID          (0x00800000)
+#define MPI_FCPORTPAGE1_FLAGS_PORT_OFFLINE              (0x00400000)
+#define MPI_FCPORTPAGE1_FLAGS_SOFT_ALPA_FALLBACK        (0x00200000)
+#define MPI_FCPORTPAGE1_FLAGS_TARGET_LARGE_CDB_ENABLE   (0x00000080)
+#define MPI_FCPORTPAGE1_FLAGS_MASK_RR_TOV_UNITS         (0x00000070)
+#define MPI_FCPORTPAGE1_FLAGS_SUPPRESS_PROT_REG         (0x00000008)
+#define MPI_FCPORTPAGE1_FLAGS_PLOGI_ON_LOGO             (0x00000004)
+#define MPI_FCPORTPAGE1_FLAGS_MAINTAIN_LOGINS           (0x00000002)
 #define MPI_FCPORTPAGE1_FLAGS_SORT_BY_DID               (0x00000001)
 #define MPI_FCPORTPAGE1_FLAGS_SORT_BY_WWN               (0x00000000)
 
@@ -993,6 +1562,11 @@ typedef struct _CONFIG_PAGE_FC_PORT_1
 #define MPI_FCPORTPAGE1_FLAGS_PROT_LAN                  ((U32)MPI_PORTFACTS_PROTOCOL_LAN << MPI_FCPORTPAGE1_FLAGS_PROT_SHIFT)
 #define MPI_FCPORTPAGE1_FLAGS_PROT_LOGBUSADDR           ((U32)MPI_PORTFACTS_PROTOCOL_LOGBUSADDR << MPI_FCPORTPAGE1_FLAGS_PROT_SHIFT)
 
+#define MPI_FCPORTPAGE1_FLAGS_NONE_RR_TOV_UNITS         (0x00000000)
+#define MPI_FCPORTPAGE1_FLAGS_THOUSANDTH_RR_TOV_UNITS   (0x00000010)
+#define MPI_FCPORTPAGE1_FLAGS_TENTH_RR_TOV_UNITS        (0x00000030)
+#define MPI_FCPORTPAGE1_FLAGS_TEN_RR_TOV_UNITS          (0x00000050)
+
 #define MPI_FCPORTPAGE1_HARD_ALPA_NOT_USED              (0xFF)
 
 #define MPI_FCPORTPAGE1_LCONFIG_SPEED_MASK              (0x0F)
@@ -1009,13 +1583,16 @@ typedef struct _CONFIG_PAGE_FC_PORT_1
 
 #define MPI_FCPORTPAGE1_ALT_CONN_UNKNOWN                (0x00)
 
+#define MPI_FCPORTPAGE1_INITIATOR_DEV_TIMEOUT_MASK      (0x7F)
+#define MPI_FCPORTPAGE1_INITIATOR_DEV_UNIT_16           (0x80)
+
 
 typedef struct _CONFIG_PAGE_FC_PORT_2
 {
-    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U8                      NumberActive;               /* 04h */
     U8                      ALPA[127];                  /* 05h */
-} fCONFIG_PAGE_FC_PORT_2, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_2,
+} CONFIG_PAGE_FC_PORT_2, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_2,
   FCPortPage2_t, MPI_POINTER pFCPortPage2_t;
 
 #define MPI_FCPORTPAGE2_PAGEVERSION                     (0x01)
@@ -1061,9 +1638,9 @@ typedef struct _FC_PORT_PERSISTENT
 
 typedef struct _CONFIG_PAGE_FC_PORT_3
 {
-    fCONFIG_PAGE_HEADER      Header;                                 /* 00h */
+    CONFIG_PAGE_HEADER      Header;                                 /* 00h */
     FC_PORT_PERSISTENT      Entry[MPI_FC_PORT_PAGE_3_ENTRY_MAX];    /* 04h */
-} fCONFIG_PAGE_FC_PORT_3, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_3,
+} CONFIG_PAGE_FC_PORT_3, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_3,
   FCPortPage3_t, MPI_POINTER pFCPortPage3_t;
 
 #define MPI_FCPORTPAGE3_PAGEVERSION                     (0x01)
@@ -1071,10 +1648,10 @@ typedef struct _CONFIG_PAGE_FC_PORT_3
 
 typedef struct _CONFIG_PAGE_FC_PORT_4
 {
-    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     PortFlags;                  /* 04h */
     U32                     PortSettings;               /* 08h */
-} fCONFIG_PAGE_FC_PORT_4, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_4,
+} CONFIG_PAGE_FC_PORT_4, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_4,
   FCPortPage4_t, MPI_POINTER pFCPortPage4_t;
 
 #define MPI_FCPORTPAGE4_PAGEVERSION                     (0x00)
@@ -1097,27 +1674,28 @@ typedef struct _CONFIG_PAGE_FC_PORT_5_AL
     U16     Reserved;                                   /* 02h */
     U64     AliasWWNN;                                  /* 04h */
     U64     AliasWWPN;                                  /* 0Ch */
-} fCONFIG_PAGE_FC_PORT_5_ALIAS_INFO,
+} CONFIG_PAGE_FC_PORT_5_ALIAS_INFO,
   MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_5_ALIAS_INFO,
   FcPortPage5AliasInfo_t, MPI_POINTER pFcPortPage5AliasInfo_t;
 
 typedef struct _CONFIG_PAGE_FC_PORT_5
 {
-    fCONFIG_PAGE_HEADER                  Header;         /* 00h */
-    fCONFIG_PAGE_FC_PORT_5_ALIAS_INFO    AliasInfo;      /* 04h */
-} fCONFIG_PAGE_FC_PORT_5, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_5,
+    CONFIG_PAGE_HEADER                  Header;         /* 00h */
+    CONFIG_PAGE_FC_PORT_5_ALIAS_INFO    AliasInfo;      /* 04h */
+} CONFIG_PAGE_FC_PORT_5, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_5,
   FCPortPage5_t, MPI_POINTER pFCPortPage5_t;
 
-#define MPI_FCPORTPAGE5_PAGEVERSION                     (0x01)
+#define MPI_FCPORTPAGE5_PAGEVERSION                     (0x02)
 
 #define MPI_FCPORTPAGE5_FLAGS_ALPA_ACQUIRED             (0x01)
 #define MPI_FCPORTPAGE5_FLAGS_HARD_ALPA                 (0x02)
 #define MPI_FCPORTPAGE5_FLAGS_HARD_WWNN                 (0x04)
 #define MPI_FCPORTPAGE5_FLAGS_HARD_WWPN                 (0x08)
+#define MPI_FCPORTPAGE5_FLAGS_DISABLE                   (0x10)
 
 typedef struct _CONFIG_PAGE_FC_PORT_6
 {
-    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Reserved;                   /* 04h */
     U64                     TimeSinceReset;             /* 08h */
     U64                     TxFrames;                   /* 10h */
@@ -1135,7 +1713,7 @@ typedef struct _CONFIG_PAGE_FC_PORT_6
     U64                     InvalidTxWordCount;         /* 70h */
     U64                     InvalidCrcCount;            /* 78h */
     U64                     FcpInitiatorIoCount;        /* 80h */
-} fCONFIG_PAGE_FC_PORT_6, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_6,
+} CONFIG_PAGE_FC_PORT_6, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_6,
   FCPortPage6_t, MPI_POINTER pFCPortPage6_t;
 
 #define MPI_FCPORTPAGE6_PAGEVERSION                     (0x00)
@@ -1143,10 +1721,10 @@ typedef struct _CONFIG_PAGE_FC_PORT_6
 
 typedef struct _CONFIG_PAGE_FC_PORT_7
 {
-    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Reserved;                   /* 04h */
     U8                      PortSymbolicName[256];      /* 08h */
-} fCONFIG_PAGE_FC_PORT_7, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_7,
+} CONFIG_PAGE_FC_PORT_7, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_7,
   FCPortPage7_t, MPI_POINTER pFCPortPage7_t;
 
 #define MPI_FCPORTPAGE7_PAGEVERSION                     (0x00)
@@ -1154,9 +1732,9 @@ typedef struct _CONFIG_PAGE_FC_PORT_7
 
 typedef struct _CONFIG_PAGE_FC_PORT_8
 {
-    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     BitVector[8];               /* 04h */
-} fCONFIG_PAGE_FC_PORT_8, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_8,
+} CONFIG_PAGE_FC_PORT_8, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_8,
   FCPortPage8_t, MPI_POINTER pFCPortPage8_t;
 
 #define MPI_FCPORTPAGE8_PAGEVERSION                     (0x00)
@@ -1164,7 +1742,7 @@ typedef struct _CONFIG_PAGE_FC_PORT_8
 
 typedef struct _CONFIG_PAGE_FC_PORT_9
 {
-    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Reserved;                   /* 04h */
     U64                     GlobalWWPN;                 /* 08h */
     U64                     GlobalWWNN;                 /* 10h */
@@ -1176,7 +1754,7 @@ typedef struct _CONFIG_PAGE_FC_PORT_9
     U8                      IPAddress[16];              /* 28h */
     U16                     Reserved1;                  /* 38h */
     U16                     TopologyDiscoveryFlags;     /* 3Ah */
-} fCONFIG_PAGE_FC_PORT_9, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_9,
+} CONFIG_PAGE_FC_PORT_9, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_9,
   FCPortPage9_t, MPI_POINTER pFCPortPage9_t;
 
 #define MPI_FCPORTPAGE9_PAGEVERSION                     (0x00)
@@ -1202,10 +1780,10 @@ typedef struct _CONFIG_PAGE_FC_PORT_10_B
     U8                      VendorOUI[3];               /* 35h */
     U8                      VendorPN[16];               /* 38h */
     U8                      VendorRev[4];               /* 48h */
-    U16                     Reserved4;                  /* 4Ch */
-    U8                      Reserved5;                  /* 4Eh */
+    U16                     Wavelength;                 /* 4Ch */
+    U8                      Reserved4;                  /* 4Eh */
     U8                      CC_BASE;                    /* 4Fh */
-} fCONFIG_PAGE_FC_PORT_10_BASE_SFP_DATA,
+} CONFIG_PAGE_FC_PORT_10_BASE_SFP_DATA,
   MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_10_BASE_SFP_DATA,
   FCPortPage10BaseSfpData_t, MPI_POINTER pFCPortPage10BaseSfpData_t;
 
@@ -1261,9 +1839,11 @@ typedef struct _CONFIG_PAGE_FC_PORT_10_E
     U8                      BitRateMin;                 /* 53h */
     U8                      VendorSN[16];               /* 54h */
     U8                      DateCode[8];                /* 64h */
-    U8                      Reserved5[3];               /* 6Ch */
+    U8                      DiagMonitoringType;         /* 6Ch */
+    U8                      EnhancedOptions;            /* 6Dh */
+    U8                      SFF8472Compliance;          /* 6Eh */
     U8                      CC_EXT;                     /* 6Fh */
-} fCONFIG_PAGE_FC_PORT_10_EXTENDED_SFP_DATA,
+} CONFIG_PAGE_FC_PORT_10_EXTENDED_SFP_DATA,
   MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_10_EXTENDED_SFP_DATA,
   FCPortPage10ExtendedSfpData_t, MPI_POINTER pFCPortPage10ExtendedSfpData_t;
 
@@ -1276,19 +1856,19 @@ typedef struct _CONFIG_PAGE_FC_PORT_10_E
 
 typedef struct _CONFIG_PAGE_FC_PORT_10
 {
-    fCONFIG_PAGE_HEADER                          Header;             /* 00h */
+    CONFIG_PAGE_HEADER                          Header;             /* 00h */
     U8                                          Flags;              /* 04h */
     U8                                          Reserved1;          /* 05h */
     U16                                         Reserved2;          /* 06h */
     U32                                         HwConfig1;          /* 08h */
     U32                                         HwConfig2;          /* 0Ch */
-    fCONFIG_PAGE_FC_PORT_10_BASE_SFP_DATA        Base;               /* 10h */
-    fCONFIG_PAGE_FC_PORT_10_EXTENDED_SFP_DATA    Extended;           /* 50h */
+    CONFIG_PAGE_FC_PORT_10_BASE_SFP_DATA        Base;               /* 10h */
+    CONFIG_PAGE_FC_PORT_10_EXTENDED_SFP_DATA    Extended;           /* 50h */
     U8                                          VendorSpecific[32]; /* 70h */
-} fCONFIG_PAGE_FC_PORT_10, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_10,
+} CONFIG_PAGE_FC_PORT_10, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_10,
   FCPortPage10_t, MPI_POINTER pFCPortPage10_t;
 
-#define MPI_FCPORTPAGE10_PAGEVERSION                    (0x00)
+#define MPI_FCPORTPAGE10_PAGEVERSION                    (0x01)
 
 /* standard MODDEF pin definitions (from GBIC spec.) */
 #define MPI_FCPORTPAGE10_FLAGS_MODDEF_MASK              (0x00000007)
@@ -1314,7 +1894,7 @@ typedef struct _CONFIG_PAGE_FC_PORT_10
 
 typedef struct _CONFIG_PAGE_FC_DEVICE_0
 {
-    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
     U64                     WWNN;                       /* 04h */
     U64                     WWPN;                       /* 0Ch */
     U32                     PortIdentifier;             /* 14h */
@@ -1322,22 +1902,25 @@ typedef struct _CONFIG_PAGE_FC_DEVICE_0
     U8                      Flags;                      /* 19h */
     U16                     BBCredit;                   /* 1Ah */
     U16                     MaxRxFrameSize;             /* 1Ch */
-    U8                      Reserved1;                  /* 1Eh */
+    U8                      ADISCHardALPA;              /* 1Eh */
     U8                      PortNumber;                 /* 1Fh */
     U8                      FcPhLowestVersion;          /* 20h */
     U8                      FcPhHighestVersion;         /* 21h */
     U8                      CurrentTargetID;            /* 22h */
     U8                      CurrentBus;                 /* 23h */
-} fCONFIG_PAGE_FC_DEVICE_0, MPI_POINTER PTR_CONFIG_PAGE_FC_DEVICE_0,
+} CONFIG_PAGE_FC_DEVICE_0, MPI_POINTER PTR_CONFIG_PAGE_FC_DEVICE_0,
   FCDevicePage0_t, MPI_POINTER pFCDevicePage0_t;
 
-#define MPI_FC_DEVICE_PAGE0_PAGEVERSION                 (0x02)
+#define MPI_FC_DEVICE_PAGE0_PAGEVERSION                 (0x03)
 
 #define MPI_FC_DEVICE_PAGE0_FLAGS_TARGETID_BUS_VALID    (0x01)
+#define MPI_FC_DEVICE_PAGE0_FLAGS_PLOGI_INVALID         (0x02)
+#define MPI_FC_DEVICE_PAGE0_FLAGS_PRLI_INVALID          (0x04)
 
 #define MPI_FC_DEVICE_PAGE0_PROT_IP                     (0x01)
 #define MPI_FC_DEVICE_PAGE0_PROT_FCP_TARGET             (0x02)
 #define MPI_FC_DEVICE_PAGE0_PROT_FCP_INITIATOR          (0x04)
+#define MPI_FC_DEVICE_PAGE0_PROT_FCP_RETRY              (0x08)
 
 #define MPI_FC_DEVICE_PAGE0_PGAD_PORT_MASK      (MPI_FC_DEVICE_PGAD_PORT_MASK)
 #define MPI_FC_DEVICE_PAGE0_PGAD_FORM_MASK      (MPI_FC_DEVICE_PGAD_FORM_MASK)
@@ -1348,6 +1931,7 @@ typedef struct _CONFIG_PAGE_FC_DEVICE_0
 #define MPI_FC_DEVICE_PAGE0_PGAD_BUS_SHIFT      (MPI_FC_DEVICE_PGAD_BT_BUS_SHIFT)
 #define MPI_FC_DEVICE_PAGE0_PGAD_TID_MASK       (MPI_FC_DEVICE_PGAD_BT_TID_MASK)
 
+#define MPI_FC_DEVICE_PAGE0_HARD_ALPA_UNKNOWN   (0xFF)
 
 /****************************************************************************
 *   RAID Volume Config Pages
@@ -1382,6 +1966,7 @@ typedef struct _RAID_VOL0_STATUS
 #define MPI_RAIDVOL0_STATUS_STATE_OPTIMAL               (0x00)
 #define MPI_RAIDVOL0_STATUS_STATE_DEGRADED              (0x01)
 #define MPI_RAIDVOL0_STATUS_STATE_FAILED                (0x02)
+#define MPI_RAIDVOL0_STATUS_STATE_MISSING               (0x03)
 
 typedef struct _RAID_VOL0_SETTINGS
 {
@@ -1392,11 +1977,11 @@ typedef struct _RAID_VOL0_SETTINGS
   RaidVol0Settings, MPI_POINTER pRaidVol0Settings;
 
 /* RAID Volume Page 0 VolumeSettings defines */
-
 #define MPI_RAIDVOL0_SETTING_WRITE_CACHING_ENABLE       (0x0001)
 #define MPI_RAIDVOL0_SETTING_OFFLINE_ON_SMART           (0x0002)
 #define MPI_RAIDVOL0_SETTING_AUTO_CONFIGURE             (0x0004)
 #define MPI_RAIDVOL0_SETTING_PRIORITY_RESYNC            (0x0008)
+#define MPI_RAIDVOL0_SETTING_FAST_DATA_SCRUBBING_0102   (0x0020) /* obsolete */
 #define MPI_RAIDVOL0_SETTING_USE_PRODUCT_ID_SUFFIX      (0x0010)
 #define MPI_RAIDVOL0_SETTING_USE_DEFAULTS               (0x8000)
 
@@ -1420,7 +2005,7 @@ typedef struct _RAID_VOL0_SETTINGS
 
 typedef struct _CONFIG_PAGE_RAID_VOL_0
 {
-    fCONFIG_PAGE_HEADER      Header;         /* 00h */
+    CONFIG_PAGE_HEADER      Header;         /* 00h */
     U8                      VolumeID;       /* 04h */
     U8                      VolumeBus;      /* 05h */
     U8                      VolumeIOC;      /* 06h */
@@ -1433,13 +2018,41 @@ typedef struct _CONFIG_PAGE_RAID_VOL_0
     U32                     Reserved2;      /* 1Ch */
     U32                     Reserved3;      /* 20h */
     U8                      NumPhysDisks;   /* 24h */
-    U8                      Reserved4;      /* 25h */
-    U16                     Reserved5;      /* 26h */
+    U8                      DataScrubRate;  /* 25h */
+    U8                      ResyncRate;     /* 26h */
+    U8                      InactiveStatus; /* 27h */
     RAID_VOL0_PHYS_DISK     PhysDisk[MPI_RAID_VOL_PAGE_0_PHYSDISK_MAX];/* 28h */
-} fCONFIG_PAGE_RAID_VOL_0, MPI_POINTER PTR_CONFIG_PAGE_RAID_VOL_0,
+} CONFIG_PAGE_RAID_VOL_0, MPI_POINTER PTR_CONFIG_PAGE_RAID_VOL_0,
   RaidVolumePage0_t, MPI_POINTER pRaidVolumePage0_t;
 
-#define MPI_RAIDVOLPAGE0_PAGEVERSION                    (0x01)
+#define MPI_RAIDVOLPAGE0_PAGEVERSION                    (0x04)
+
+/* values for RAID Volume Page 0 InactiveStatus field */
+#define MPI_RAIDVOLPAGE0_UNKNOWN_INACTIVE               (0x00)
+#define MPI_RAIDVOLPAGE0_STALE_METADATA_INACTIVE        (0x01)
+#define MPI_RAIDVOLPAGE0_FOREIGN_VOLUME_INACTIVE        (0x02)
+#define MPI_RAIDVOLPAGE0_INSUFFICIENT_RESOURCE_INACTIVE (0x03)
+#define MPI_RAIDVOLPAGE0_CLONE_VOLUME_INACTIVE          (0x04)
+#define MPI_RAIDVOLPAGE0_INSUFFICIENT_METADATA_INACTIVE (0x05)
+#define MPI_RAIDVOLPAGE0_PREVIOUSLY_DELETED             (0x06)
+
+
+typedef struct _CONFIG_PAGE_RAID_VOL_1
+{
+    CONFIG_PAGE_HEADER      Header;         /* 00h */
+    U8                      VolumeID;       /* 01h */
+    U8                      VolumeBus;      /* 02h */
+    U8                      VolumeIOC;      /* 03h */
+    U8                      Reserved0;      /* 04h */
+    U8                      GUID[24];       /* 05h */
+    U8                      Name[32];       /* 20h */
+    U64                     WWID;           /* 40h */
+    U32                     Reserved1;      /* 48h */
+    U32                     Reserved2;      /* 4Ch */
+} CONFIG_PAGE_RAID_VOL_1, MPI_POINTER PTR_CONFIG_PAGE_RAID_VOL_1,
+  RaidVolumePage1_t, MPI_POINTER pRaidVolumePage1_t;
+
+#define MPI_RAIDVOLPAGE1_PAGEVERSION                    (0x01)
 
 
 /****************************************************************************
@@ -1490,6 +2103,7 @@ typedef struct _RAID_PHYS_DISK0_STATUS
 
 #define MPI_PHYSDISK0_STATUS_FLAG_OUT_OF_SYNC           (0x01)
 #define MPI_PHYSDISK0_STATUS_FLAG_QUIESCED              (0x02)
+#define MPI_PHYSDISK0_STATUS_FLAG_INACTIVE_VOLUME       (0x04)
 
 #define MPI_PHYSDISK0_STATUS_ONLINE                     (0x00)
 #define MPI_PHYSDISK0_STATUS_MISSING                    (0x01)
@@ -1502,24 +2116,54 @@ typedef struct _RAID_PHYS_DISK0_STATUS
 
 typedef struct _CONFIG_PAGE_RAID_PHYS_DISK_0
 {
-    fCONFIG_PAGE_HEADER              Header;             /* 00h */
+    CONFIG_PAGE_HEADER              Header;             /* 00h */
     U8                              PhysDiskID;         /* 04h */
     U8                              PhysDiskBus;        /* 05h */
     U8                              PhysDiskIOC;        /* 06h */
     U8                              PhysDiskNum;        /* 07h */
     RAID_PHYS_DISK0_SETTINGS        PhysDiskSettings;   /* 08h */
     U32                             Reserved1;          /* 0Ch */
-    U32                             Reserved2;          /* 10h */
-    U32                             Reserved3;          /* 14h */
+    U8                              ExtDiskIdentifier[8]; /* 10h */
     U8                              DiskIdentifier[16]; /* 18h */
     RAID_PHYS_DISK0_INQUIRY_DATA    InquiryData;        /* 28h */
     RAID_PHYS_DISK0_STATUS          PhysDiskStatus;     /* 64h */
     U32                             MaxLBA;             /* 68h */
     RAID_PHYS_DISK0_ERROR_DATA      ErrorData;          /* 6Ch */
-} fCONFIG_PAGE_RAID_PHYS_DISK_0, MPI_POINTER PTR_CONFIG_PAGE_RAID_PHYS_DISK_0,
+} CONFIG_PAGE_RAID_PHYS_DISK_0, MPI_POINTER PTR_CONFIG_PAGE_RAID_PHYS_DISK_0,
   RaidPhysDiskPage0_t, MPI_POINTER pRaidPhysDiskPage0_t;
 
-#define MPI_RAIDPHYSDISKPAGE0_PAGEVERSION           (0x00)
+#define MPI_RAIDPHYSDISKPAGE0_PAGEVERSION           (0x01)
+
+
+typedef struct _RAID_PHYS_DISK1_PATH
+{
+    U8                              PhysDiskID;         /* 00h */
+    U8                              PhysDiskBus;        /* 01h */
+    U16                             Reserved1;          /* 02h */
+    U64                             WWID;               /* 04h */
+    U64                             OwnerWWID;          /* 0Ch */
+    U8                              OwnerIdentifier;    /* 14h */
+    U8                              Reserved2;          /* 15h */
+    U16                             Flags;              /* 16h */
+} RAID_PHYS_DISK1_PATH, MPI_POINTER PTR_RAID_PHYS_DISK1_PATH,
+  RaidPhysDisk1Path_t, MPI_POINTER pRaidPhysDisk1Path_t;
+
+/* RAID Physical Disk Page 1 Flags field defines */
+#define MPI_RAID_PHYSDISK1_FLAG_BROKEN          (0x0002)
+#define MPI_RAID_PHYSDISK1_FLAG_INVALID         (0x0001)
+
+typedef struct _CONFIG_PAGE_RAID_PHYS_DISK_1
+{
+    CONFIG_PAGE_HEADER              Header;             /* 00h */
+    U8                              NumPhysDiskPaths;   /* 04h */
+    U8                              PhysDiskNum;        /* 05h */
+    U16                             Reserved2;          /* 06h */
+    U32                             Reserved1;          /* 08h */
+    RAID_PHYS_DISK1_PATH            Path[1];            /* 0Ch */
+} CONFIG_PAGE_RAID_PHYS_DISK_1, MPI_POINTER PTR_CONFIG_PAGE_RAID_PHYS_DISK_1,
+  RaidPhysDiskPage1_t, MPI_POINTER pRaidPhysDiskPage1_t;
+
+#define MPI_RAIDPHYSDISKPAGE1_PAGEVERSION       (0x00)
 
 
 /****************************************************************************
@@ -1532,7 +2176,7 @@ typedef struct _CONFIG_PAGE_LAN_0
     U16                     TxRxModes;                  /* 04h */
     U16                     Reserved;                   /* 06h */
     U32                     PacketPrePad;               /* 08h */
-} fCONFIG_PAGE_LAN_0, MPI_POINTER PTR_CONFIG_PAGE_LAN_0,
+} CONFIG_PAGE_LAN_0, MPI_POINTER PTR_CONFIG_PAGE_LAN_0,
   LANPage0_t, MPI_POINTER pLANPage0_t;
 
 #define MPI_LAN_PAGE0_PAGEVERSION                       (0x01)
@@ -1557,7 +2201,7 @@ typedef struct _CONFIG_PAGE_LAN_1
     U32                     MaxReplySize;               /* 24h */
     U32                     NegWireSpeedLow;            /* 28h */
     U32                     NegWireSpeedHigh;           /* 2Ch */
-} fCONFIG_PAGE_LAN_1, MPI_POINTER PTR_CONFIG_PAGE_LAN_1,
+} CONFIG_PAGE_LAN_1, MPI_POINTER PTR_CONFIG_PAGE_LAN_1,
   LANPage1_t, MPI_POINTER pLANPage1_t;
 
 #define MPI_LAN_PAGE1_PAGEVERSION                       (0x03)
@@ -1565,5 +2209,542 @@ typedef struct _CONFIG_PAGE_LAN_1
 #define MPI_LAN_PAGE1_DEV_STATE_RESET                   (0x00)
 #define MPI_LAN_PAGE1_DEV_STATE_OPERATIONAL             (0x01)
 
+
+/****************************************************************************
+*   Inband Config Pages
+****************************************************************************/
+
+typedef struct _CONFIG_PAGE_INBAND_0
+{
+    CONFIG_PAGE_HEADER      Header;                     /* 00h */
+    MPI_VERSION_FORMAT      InbandVersion;              /* 04h */
+    U16                     MaximumBuffers;             /* 08h */
+    U16                     Reserved1;                  /* 0Ah */
+} CONFIG_PAGE_INBAND_0, MPI_POINTER PTR_CONFIG_PAGE_INBAND_0,
+  InbandPage0_t, MPI_POINTER pInbandPage0_t;
+
+#define MPI_INBAND_PAGEVERSION          (0x00)
+
+
+
+/****************************************************************************
+*   SAS IO Unit Config Pages
+****************************************************************************/
+
+typedef struct _MPI_SAS_IO_UNIT0_PHY_DATA
+{
+    U8          Port;                   /* 00h */
+    U8          PortFlags;              /* 01h */
+    U8          PhyFlags;               /* 02h */
+    U8          NegotiatedLinkRate;     /* 03h */
+    U32         ControllerPhyDeviceInfo;/* 04h */
+    U16         AttachedDeviceHandle;   /* 08h */
+    U16         ControllerDevHandle;    /* 0Ah */
+    U32         DiscoveryStatus;        /* 0Ch */
+} MPI_SAS_IO_UNIT0_PHY_DATA, MPI_POINTER PTR_MPI_SAS_IO_UNIT0_PHY_DATA,
+  SasIOUnit0PhyData, MPI_POINTER pSasIOUnit0PhyData;
+
+/*
+ * Host code (drivers, BIOS, utilities, etc.) should leave this define set to
+ * one and check Header.PageLength at runtime.
+ */
+#ifndef MPI_SAS_IOUNIT0_PHY_MAX
+#define MPI_SAS_IOUNIT0_PHY_MAX         (1)
+#endif
+
+typedef struct _CONFIG_PAGE_SAS_IO_UNIT_0
+{
+    CONFIG_EXTENDED_PAGE_HEADER     Header;                             /* 00h */
+    U32                             Reserved1;                          /* 08h */
+    U8                              NumPhys;                            /* 0Ch */
+    U8                              Reserved2;                          /* 0Dh */
+    U16                             Reserved3;                          /* 0Eh */
+    MPI_SAS_IO_UNIT0_PHY_DATA       PhyData[MPI_SAS_IOUNIT0_PHY_MAX];   /* 10h */
+} CONFIG_PAGE_SAS_IO_UNIT_0, MPI_POINTER PTR_CONFIG_PAGE_SAS_IO_UNIT_0,
+  SasIOUnitPage0_t, MPI_POINTER pSasIOUnitPage0_t;
+
+#define MPI_SASIOUNITPAGE0_PAGEVERSION      (0x02)
+
+/* values for SAS IO Unit Page 0 PortFlags */
+#define MPI_SAS_IOUNIT0_PORT_FLAGS_DISCOVERY_IN_PROGRESS    (0x08)
+#define MPI_SAS_IOUNIT0_PORT_FLAGS_0_TARGET_IOC_NUM         (0x00)
+#define MPI_SAS_IOUNIT0_PORT_FLAGS_1_TARGET_IOC_NUM         (0x04)
+#define MPI_SAS_IOUNIT0_PORT_FLAGS_AUTO_PORT_CONFIG         (0x01)
+
+/* values for SAS IO Unit Page 0 PhyFlags */
+#define MPI_SAS_IOUNIT0_PHY_FLAGS_PHY_DISABLED              (0x04)
+#define MPI_SAS_IOUNIT0_PHY_FLAGS_TX_INVERT                 (0x02)
+#define MPI_SAS_IOUNIT0_PHY_FLAGS_RX_INVERT                 (0x01)
+
+/* values for SAS IO Unit Page 0 NegotiatedLinkRate */
+#define MPI_SAS_IOUNIT0_RATE_UNKNOWN                        (0x00)
+#define MPI_SAS_IOUNIT0_RATE_PHY_DISABLED                   (0x01)
+#define MPI_SAS_IOUNIT0_RATE_FAILED_SPEED_NEGOTIATION       (0x02)
+#define MPI_SAS_IOUNIT0_RATE_SATA_OOB_COMPLETE              (0x03)
+#define MPI_SAS_IOUNIT0_RATE_1_5                            (0x08)
+#define MPI_SAS_IOUNIT0_RATE_3_0                            (0x09)
+
+/* see mpi_sas.h for values for SAS IO Unit Page 0 ControllerPhyDeviceInfo values */
+
+/* values for SAS IO Unit Page 0 DiscoveryStatus */
+#define MPI_SAS_IOUNIT0_DS_LOOP_DETECTED                    (0x00000001)
+#define MPI_SAS_IOUNIT0_DS_UNADDRESSABLE_DEVICE             (0x00000002)
+#define MPI_SAS_IOUNIT0_DS_MULTIPLE_PORTS                   (0x00000004)
+#define MPI_SAS_IOUNIT0_DS_EXPANDER_ERR                     (0x00000008)
+#define MPI_SAS_IOUNIT0_DS_SMP_TIMEOUT                      (0x00000010)
+#define MPI_SAS_IOUNIT0_DS_OUT_ROUTE_ENTRIES                (0x00000020)
+#define MPI_SAS_IOUNIT0_DS_INDEX_NOT_EXIST                  (0x00000040)
+#define MPI_SAS_IOUNIT0_DS_SMP_FUNCTION_FAILED              (0x00000080)
+#define MPI_SAS_IOUNIT0_DS_SMP_CRC_ERROR                    (0x00000100)
+#define MPI_SAS_IOUNIT0_DS_SUBTRACTIVE_LINK                 (0x00000200)
+#define MPI_SAS_IOUNIT0_DS_TABLE_LINK                       (0x00000400)
+#define MPI_SAS_IOUNIT0_DS_UNSUPPORTED_DEVICE               (0x00000800)
+
+
+typedef struct _MPI_SAS_IO_UNIT1_PHY_DATA
+{
+    U8          Port;                   /* 00h */
+    U8          PortFlags;              /* 01h */
+    U8          PhyFlags;               /* 02h */
+    U8          MaxMinLinkRate;         /* 03h */
+    U32         ControllerPhyDeviceInfo;/* 04h */
+    U32         Reserved1;              /* 08h */
+} MPI_SAS_IO_UNIT1_PHY_DATA, MPI_POINTER PTR_MPI_SAS_IO_UNIT1_PHY_DATA,
+  SasIOUnit1PhyData, MPI_POINTER pSasIOUnit1PhyData;
+
+/*
+ * Host code (drivers, BIOS, utilities, etc.) should leave this define set to
+ * one and check Header.PageLength at runtime.
+ */
+#ifndef MPI_SAS_IOUNIT1_PHY_MAX
+#define MPI_SAS_IOUNIT1_PHY_MAX         (1)
+#endif
+
+typedef struct _CONFIG_PAGE_SAS_IO_UNIT_1
+{
+    CONFIG_EXTENDED_PAGE_HEADER Header;                             /* 00h */
+    U16                         ControlFlags;                       /* 08h */
+    U16                         MaxNumSATATargets;                  /* 0Ah */
+    U32                         Reserved1;                          /* 0Ch */
+    U8                          NumPhys;                            /* 10h */
+    U8                          SATAMaxQDepth;                      /* 11h */
+    U16                         Reserved2;                          /* 12h */
+    MPI_SAS_IO_UNIT1_PHY_DATA   PhyData[MPI_SAS_IOUNIT1_PHY_MAX];   /* 14h */
+} CONFIG_PAGE_SAS_IO_UNIT_1, MPI_POINTER PTR_CONFIG_PAGE_SAS_IO_UNIT_1,
+  SasIOUnitPage1_t, MPI_POINTER pSasIOUnitPage1_t;
+
+#define MPI_SASIOUNITPAGE1_PAGEVERSION      (0x04)
+
+/* values for SAS IO Unit Page 1 ControlFlags */
+#define MPI_SAS_IOUNIT1_CONTROL_SATA_3_0_MAX            (0x4000)
+#define MPI_SAS_IOUNIT1_CONTROL_SATA_1_5_MAX            (0x2000)
+#define MPI_SAS_IOUNIT1_CONTROL_SATA_SW_PRESERVE        (0x1000)
+#define MPI_SAS_IOUNIT1_CONTROL_DISABLE_SAS_HASH        (0x0800)
+
+#define MPI_SAS_IOUNIT1_CONTROL_MASK_DEV_SUPPORT        (0x0600)
+#define MPI_SAS_IOUNIT1_CONTROL_SHIFT_DEV_SUPPORT       (9)
+#define MPI_SAS_IOUNIT1_CONTROL_DEV_SUPPORT_BOTH        (0x00)
+#define MPI_SAS_IOUNIT1_CONTROL_DEV_SAS_SUPPORT         (0x01)
+#define MPI_SAS_IOUNIT1_CONTROL_DEV_SATA_SUPPORT        (0x10)
+
+#define MPI_SAS_IOUNIT1_CONTROL_AUTO_PORT_SAME_SAS_ADDR (0x0100)
+#define MPI_SAS_IOUNIT1_CONTROL_SATA_48BIT_LBA_REQUIRED (0x0080)
+#define MPI_SAS_IOUNIT1_CONTROL_SATA_SMART_REQUIRED     (0x0040)
+#define MPI_SAS_IOUNIT1_CONTROL_SATA_NCQ_REQUIRED       (0x0020)
+#define MPI_SAS_IOUNIT1_CONTROL_SATA_FUA_REQUIRED       (0x0010)
+#define MPI_SAS_IOUNIT1_CONTROL_PHY_ENABLE_ORDER_HIGH   (0x0008)
+#define MPI_SAS_IOUNIT1_CONTROL_SUBTRACTIVE_ILLEGAL     (0x0004)
+#define MPI_SAS_IOUNIT1_CONTROL_FIRST_LVL_DISC_ONLY     (0x0002)
+#define MPI_SAS_IOUNIT1_CONTROL_CLEAR_AFFILIATION       (0x0001)
+
+/* values for SAS IO Unit Page 1 PortFlags */
+#define MPI_SAS_IOUNIT1_PORT_FLAGS_0_TARGET_IOC_NUM     (0x00)
+#define MPI_SAS_IOUNIT1_PORT_FLAGS_1_TARGET_IOC_NUM     (0x04)
+#define MPI_SAS_IOUNIT1_PORT_FLAGS_AUTO_PORT_CONFIG     (0x01)
+
+/* values for SAS IO Unit Page 0 PhyFlags */
+#define MPI_SAS_IOUNIT1_PHY_FLAGS_PHY_DISABLE           (0x04)
+#define MPI_SAS_IOUNIT1_PHY_FLAGS_TX_INVERT             (0x02)
+#define MPI_SAS_IOUNIT1_PHY_FLAGS_RX_INVERT             (0x01)
+
+/* values for SAS IO Unit Page 0 MaxMinLinkRate */
+#define MPI_SAS_IOUNIT1_MAX_RATE_MASK                   (0xF0)
+#define MPI_SAS_IOUNIT1_MAX_RATE_1_5                    (0x80)
+#define MPI_SAS_IOUNIT1_MAX_RATE_3_0                    (0x90)
+#define MPI_SAS_IOUNIT1_MIN_RATE_MASK                   (0x0F)
+#define MPI_SAS_IOUNIT1_MIN_RATE_1_5                    (0x08)
+#define MPI_SAS_IOUNIT1_MIN_RATE_3_0                    (0x09)
+
+/* see mpi_sas.h for values for SAS IO Unit Page 1 ControllerPhyDeviceInfo values */
+
+
+typedef struct _CONFIG_PAGE_SAS_IO_UNIT_2
+{
+    CONFIG_EXTENDED_PAGE_HEADER         Header;                 /* 00h */
+    U32                                 Reserved1;              /* 08h */
+    U16                                 MaxPersistentIDs;       /* 0Ch */
+    U16                                 NumPersistentIDsUsed;   /* 0Eh */
+    U8                                  Status;                 /* 10h */
+    U8                                  Flags;                  /* 11h */
+    U16                                 MaxNumPhysicalMappedIDs;/* 12h */              /* 12h */
+} CONFIG_PAGE_SAS_IO_UNIT_2, MPI_POINTER PTR_CONFIG_PAGE_SAS_IO_UNIT_2,
+  SasIOUnitPage2_t, MPI_POINTER pSasIOUnitPage2_t;
+
+#define MPI_SASIOUNITPAGE2_PAGEVERSION      (0x03)
+
+/* values for SAS IO Unit Page 2 Status field */
+#define MPI_SAS_IOUNIT2_STATUS_DISABLED_PERSISTENT_MAPPINGS (0x02)
+#define MPI_SAS_IOUNIT2_STATUS_FULL_PERSISTENT_MAPPINGS     (0x01)
+
+/* values for SAS IO Unit Page 2 Flags field */
+#define MPI_SAS_IOUNIT2_FLAGS_DISABLE_PERSISTENT_MAPPINGS   (0x01)
+/* Physical Mapping Modes */
+#define MPI_SAS_IOUNIT2_FLAGS_MASK_PHYS_MAP_MODE            (0x0E)
+#define MPI_SAS_IOUNIT2_FLAGS_SHIFT_PHYS_MAP_MODE           (1)
+#define MPI_SAS_IOUNIT2_FLAGS_NO_PHYS_MAP                   (0x00)
+#define MPI_SAS_IOUNIT2_FLAGS_DIRECT_ATTACH_PHYS_MAP        (0x01)
+#define MPI_SAS_IOUNIT2_FLAGS_ENCLOSURE_SLOT_PHYS_MAP       (0x02)
+
+#define MPI_SAS_IOUNIT2_FLAGS_RESERVE_ID_0_FOR_BOOT         (0x10)
+
+
+typedef struct _CONFIG_PAGE_SAS_IO_UNIT_3
+{
+    CONFIG_EXTENDED_PAGE_HEADER Header;                         /* 00h */
+    U32                         Reserved1;                      /* 08h */
+    U32                         MaxInvalidDwordCount;           /* 0Ch */
+    U32                         InvalidDwordCountTime;          /* 10h */
+    U32                         MaxRunningDisparityErrorCount;  /* 14h */
+    U32                         RunningDisparityErrorTime;      /* 18h */
+    U32                         MaxLossDwordSynchCount;         /* 1Ch */
+    U32                         LossDwordSynchCountTime;        /* 20h */
+    U32                         MaxPhyResetProblemCount;        /* 24h */
+    U32                         PhyResetProblemTime;            /* 28h */
+} CONFIG_PAGE_SAS_IO_UNIT_3, MPI_POINTER PTR_CONFIG_PAGE_SAS_IO_UNIT_3,
+  SasIOUnitPage3_t, MPI_POINTER pSasIOUnitPage3_t;
+
+#define MPI_SASIOUNITPAGE3_PAGEVERSION      (0x00)
+
+
+/****************************************************************************
+*   SAS Expander Config Pages
+****************************************************************************/
+
+typedef struct _CONFIG_PAGE_SAS_EXPANDER_0
+{
+    CONFIG_EXTENDED_PAGE_HEADER         Header;                 /* 00h */
+    U8                                  PhysicalPort;           /* 08h */
+    U8                                  Reserved1;              /* 09h */
+    U16                                 Reserved2;              /* 0Ah */
+    U64                                 SASAddress;             /* 0Ch */
+    U32                                 DiscoveryStatus;        /* 14h */
+    U16                                 DevHandle;              /* 18h */
+    U16                                 ParentDevHandle;        /* 1Ah */
+    U16                                 ExpanderChangeCount;    /* 1Ch */
+    U16                                 ExpanderRouteIndexes;   /* 1Eh */
+    U8                                  NumPhys;                /* 20h */
+    U8                                  SASLevel;               /* 21h */
+    U8                                  Flags;                  /* 22h */
+    U8                                  Reserved3;              /* 23h */
+} CONFIG_PAGE_SAS_EXPANDER_0, MPI_POINTER PTR_CONFIG_PAGE_SAS_EXPANDER_0,
+  SasExpanderPage0_t, MPI_POINTER pSasExpanderPage0_t;
+
+#define MPI_SASEXPANDER0_PAGEVERSION        (0x02)
+
+/* values for SAS Expander Page 0 DiscoveryStatus field */
+#define MPI_SAS_EXPANDER0_DS_LOOP_DETECTED              (0x00000001)
+#define MPI_SAS_EXPANDER0_DS_UNADDRESSABLE_DEVICE       (0x00000002)
+#define MPI_SAS_EXPANDER0_DS_MULTIPLE_PORTS             (0x00000004)
+#define MPI_SAS_EXPANDER0_DS_EXPANDER_ERR               (0x00000008)
+#define MPI_SAS_EXPANDER0_DS_SMP_TIMEOUT                (0x00000010)
+#define MPI_SAS_EXPANDER0_DS_OUT_ROUTE_ENTRIES          (0x00000020)
+#define MPI_SAS_EXPANDER0_DS_INDEX_NOT_EXIST            (0x00000040)
+#define MPI_SAS_EXPANDER0_DS_SMP_FUNCTION_FAILED        (0x00000080)
+#define MPI_SAS_EXPANDER0_DS_SMP_CRC_ERROR              (0x00000100)
+#define MPI_SAS_EXPANDER0_DS_SUBTRACTIVE_LINK           (0x00000200)
+#define MPI_SAS_EXPANDER0_DS_TABLE_LINK                 (0x00000400)
+#define MPI_SAS_EXPANDER0_DS_UNSUPPORTED_DEVICE         (0x00000800)
+
+/* values for SAS Expander Page 0 Flags field */
+#define MPI_SAS_EXPANDER0_FLAGS_ROUTE_TABLE_CONFIG      (0x02)
+#define MPI_SAS_EXPANDER0_FLAGS_CONFIG_IN_PROGRESS      (0x01)
+
+
+typedef struct _CONFIG_PAGE_SAS_EXPANDER_1
+{
+    CONFIG_EXTENDED_PAGE_HEADER Header;                 /* 00h */
+    U8                          PhysicalPort;           /* 08h */
+    U8                          Reserved1;              /* 09h */
+    U16                         Reserved2;              /* 0Ah */
+    U8                          NumPhys;                /* 0Ch */
+    U8                          Phy;                    /* 0Dh */
+    U16                         NumTableEntriesProgrammed; /* 0Eh */
+    U8                          ProgrammedLinkRate;     /* 10h */
+    U8                          HwLinkRate;             /* 11h */
+    U16                         AttachedDevHandle;      /* 12h */
+    U32                         PhyInfo;                /* 14h */
+    U32                         AttachedDeviceInfo;     /* 18h */
+    U16                         OwnerDevHandle;         /* 1Ch */
+    U8                          ChangeCount;            /* 1Eh */
+    U8                          NegotiatedLinkRate;     /* 1Fh */
+    U8                          PhyIdentifier;          /* 20h */
+    U8                          AttachedPhyIdentifier;  /* 21h */
+    U8                          NumTableEntriesProg;    /* 22h */
+    U8                          DiscoveryInfo;          /* 23h */
+    U32                         Reserved3;              /* 24h */
+} CONFIG_PAGE_SAS_EXPANDER_1, MPI_POINTER PTR_CONFIG_PAGE_SAS_EXPANDER_1,
+  SasExpanderPage1_t, MPI_POINTER pSasExpanderPage1_t;
+
+#define MPI_SASEXPANDER1_PAGEVERSION        (0x01)
+
+/* use MPI_SAS_PHY0_PRATE_ defines for ProgrammedLinkRate */
+
+/* use MPI_SAS_PHY0_HWRATE_ defines for HwLinkRate */
+
+/* use MPI_SAS_PHY0_PHYINFO_ defines for PhyInfo */
+
+/* see mpi_sas.h for values for SAS Expander Page 1 AttachedDeviceInfo values */
+
+/* values for SAS Expander Page 1 DiscoveryInfo field */
+#define MPI_SAS_EXPANDER1_DISCINFO_BAD_PHY DISABLED     (0x04)
+#define MPI_SAS_EXPANDER1_DISCINFO_LINK_STATUS_CHANGE   (0x02)
+#define MPI_SAS_EXPANDER1_DISCINFO_NO_ROUTING_ENTRIES   (0x01)
+
+/* values for SAS Expander Page 1 NegotiatedLinkRate field */
+#define MPI_SAS_EXPANDER1_NEG_RATE_UNKNOWN              (0x00)
+#define MPI_SAS_EXPANDER1_NEG_RATE_PHY_DISABLED         (0x01)
+#define MPI_SAS_EXPANDER1_NEG_RATE_FAILED_NEGOTIATION   (0x02)
+#define MPI_SAS_EXPANDER1_NEG_RATE_SATA_OOB_COMPLETE    (0x03)
+#define MPI_SAS_EXPANDER1_NEG_RATE_1_5                  (0x08)
+#define MPI_SAS_EXPANDER1_NEG_RATE_3_0                  (0x09)
+
+
+/****************************************************************************
+*   SAS Device Config Pages
+****************************************************************************/
+
+typedef struct _CONFIG_PAGE_SAS_DEVICE_0
+{
+    CONFIG_EXTENDED_PAGE_HEADER         Header;                 /* 00h */
+    U16                                 Slot;                   /* 08h */
+    U16                                 EnclosureHandle;        /* 0Ah */
+    U64                                 SASAddress;             /* 0Ch */
+    U16                                 ParentDevHandle;        /* 14h */
+    U8                                  PhyNum;                 /* 16h */
+    U8                                  AccessStatus;           /* 17h */
+    U16                                 DevHandle;              /* 18h */
+    U8                                  TargetID;               /* 1Ah */
+    U8                                  Bus;                    /* 1Bh */
+    U32                                 DeviceInfo;             /* 1Ch */
+    U16                                 Flags;                  /* 20h */
+    U8                                  PhysicalPort;           /* 22h */
+    U8                                  Reserved2;              /* 23h */
+} CONFIG_PAGE_SAS_DEVICE_0, MPI_POINTER PTR_CONFIG_PAGE_SAS_DEVICE_0,
+  SasDevicePage0_t, MPI_POINTER pSasDevicePage0_t;
+
+#define MPI_SASDEVICE0_PAGEVERSION          (0x04)
+
+/* values for SAS Device Page 0 AccessStatus field */
+#define MPI_SAS_DEVICE0_ASTATUS_NO_ERRORS               (0x00)
+#define MPI_SAS_DEVICE0_ASTATUS_SATA_INIT_FAILED        (0x01)
+#define MPI_SAS_DEVICE0_ASTATUS_SATA_CAPABILITY_FAILED  (0x02)
+
+/* values for SAS Device Page 0 Flags field */
+#define MPI_SAS_DEVICE0_FLAGS_SATA_SW_PRESERVE          (0x0200)
+#define MPI_SAS_DEVICE0_FLAGS_UNSUPPORTED_DEVICE        (0x0100)
+#define MPI_SAS_DEVICE0_FLAGS_SATA_48BIT_LBA_SUPPORTED  (0x0080)
+#define MPI_SAS_DEVICE0_FLAGS_SATA_SMART_SUPPORTED      (0x0040)
+#define MPI_SAS_DEVICE0_FLAGS_SATA_NCQ_SUPPORTED        (0x0020)
+#define MPI_SAS_DEVICE0_FLAGS_SATA_FUA_SUPPORTED        (0x0010)
+#define MPI_SAS_DEVICE0_FLAGS_PORT_SELECTOR_ATTACH      (0x0008)
+#define MPI_SAS_DEVICE0_FLAGS_MAPPING_PERSISTENT        (0x0004)
+#define MPI_SAS_DEVICE0_FLAGS_DEVICE_MAPPED             (0x0002)
+#define MPI_SAS_DEVICE0_FLAGS_DEVICE_PRESENT            (0x0001)
+
+/* see mpi_sas.h for values for SAS Device Page 0 DeviceInfo values */
+
+
+typedef struct _CONFIG_PAGE_SAS_DEVICE_1
+{
+    CONFIG_EXTENDED_PAGE_HEADER         Header;                 /* 00h */
+    U32                                 Reserved1;              /* 08h */
+    U64                                 SASAddress;             /* 0Ch */
+    U32                                 Reserved2;              /* 14h */
+    U16                                 DevHandle;              /* 18h */
+    U8                                  TargetID;               /* 1Ah */
+    U8                                  Bus;                    /* 1Bh */
+    U8                                  InitialRegDeviceFIS[20];/* 1Ch */
+} CONFIG_PAGE_SAS_DEVICE_1, MPI_POINTER PTR_CONFIG_PAGE_SAS_DEVICE_1,
+  SasDevicePage1_t, MPI_POINTER pSasDevicePage1_t;
+
+#define MPI_SASDEVICE1_PAGEVERSION          (0x00)
+
+
+typedef struct _CONFIG_PAGE_SAS_DEVICE_2
+{
+    CONFIG_EXTENDED_PAGE_HEADER         Header;                 /* 00h */
+    U64                                 PhysicalIdentifier;     /* 08h */
+    U32                                 Reserved1;              /* 10h */
+} CONFIG_PAGE_SAS_DEVICE_2, MPI_POINTER PTR_CONFIG_PAGE_SAS_DEVICE_2,
+  SasDevicePage2_t, MPI_POINTER pSasDevicePage2_t;
+
+#define MPI_SASDEVICE2_PAGEVERSION          (0x00)
+
+
+/****************************************************************************
+*   SAS PHY Config Pages
+****************************************************************************/
+
+typedef struct _CONFIG_PAGE_SAS_PHY_0
+{
+    CONFIG_EXTENDED_PAGE_HEADER         Header;                 /* 00h */
+    U32                                 Reserved1;              /* 08h */
+    U64                                 SASAddress;             /* 0Ch */
+    U16                                 AttachedDevHandle;      /* 14h */
+    U8                                  AttachedPhyIdentifier;  /* 16h */
+    U8                                  Reserved2;              /* 17h */
+    U32                                 AttachedDeviceInfo;     /* 18h */
+    U8                                  ProgrammedLinkRate;     /* 20h */
+    U8                                  HwLinkRate;             /* 21h */
+    U8                                  ChangeCount;            /* 22h */
+    U8                                  Reserved3;              /* 23h */
+    U32                                 PhyInfo;                /* 24h */
+} CONFIG_PAGE_SAS_PHY_0, MPI_POINTER PTR_CONFIG_PAGE_SAS_PHY_0,
+  SasPhyPage0_t, MPI_POINTER pSasPhyPage0_t;
+
+#define MPI_SASPHY0_PAGEVERSION             (0x00)
+
+/* values for SAS PHY Page 0 ProgrammedLinkRate field */
+#define MPI_SAS_PHY0_PRATE_MAX_RATE_MASK                        (0xF0)
+#define MPI_SAS_PHY0_PRATE_MAX_RATE_NOT_PROGRAMMABLE            (0x00)
+#define MPI_SAS_PHY0_PRATE_MAX_RATE_1_5                         (0x80)
+#define MPI_SAS_PHY0_PRATE_MAX_RATE_3_0                         (0x90)
+#define MPI_SAS_PHY0_PRATE_MIN_RATE_MASK                        (0x0F)
+#define MPI_SAS_PHY0_PRATE_MIN_RATE_NOT_PROGRAMMABLE            (0x00)
+#define MPI_SAS_PHY0_PRATE_MIN_RATE_1_5                         (0x08)
+#define MPI_SAS_PHY0_PRATE_MIN_RATE_3_0                         (0x09)
+
+/* values for SAS PHY Page 0 HwLinkRate field */
+#define MPI_SAS_PHY0_HWRATE_MAX_RATE_MASK                       (0xF0)
+#define MPI_SAS_PHY0_HWRATE_MAX_RATE_1_5                        (0x80)
+#define MPI_SAS_PHY0_HWRATE_MAX_RATE_3_0                        (0x90)
+#define MPI_SAS_PHY0_HWRATE_MIN_RATE_MASK                       (0x0F)
+#define MPI_SAS_PHY0_HWRATE_MIN_RATE_1_5                        (0x08)
+#define MPI_SAS_PHY0_HWRATE_MIN_RATE_3_0                        (0x09)
+
+/* values for SAS PHY Page 0 PhyInfo field */
+#define MPI_SAS_PHY0_PHYINFO_SATA_PORT_ACTIVE                   (0x00004000)
+#define MPI_SAS_PHY0_PHYINFO_SATA_PORT_SELECTOR                 (0x00002000)
+#define MPI_SAS_PHY0_PHYINFO_VIRTUAL_PHY                        (0x00001000)
+
+#define MPI_SAS_PHY0_PHYINFO_MASK_PARTIAL_PATHWAY_TIME          (0x00000F00)
+#define MPI_SAS_PHY0_PHYINFO_SHIFT_PARTIAL_PATHWAY_TIME         (8)
+
+#define MPI_SAS_PHY0_PHYINFO_MASK_ROUTING_ATTRIBUTE             (0x000000F0)
+#define MPI_SAS_PHY0_PHYINFO_DIRECT_ROUTING                     (0x00000000)
+#define MPI_SAS_PHY0_PHYINFO_SUBTRACTIVE_ROUTING                (0x00000010)
+#define MPI_SAS_PHY0_PHYINFO_TABLE_ROUTING                      (0x00000020)
+
+#define MPI_SAS_PHY0_PHYINFO_MASK_LINK_RATE                     (0x0000000F)
+#define MPI_SAS_PHY0_PHYINFO_UNKNOWN_LINK_RATE                  (0x00000000)
+#define MPI_SAS_PHY0_PHYINFO_PHY_DISABLED                       (0x00000001)
+#define MPI_SAS_PHY0_PHYINFO_NEGOTIATION_FAILED                 (0x00000002)
+#define MPI_SAS_PHY0_PHYINFO_SATA_OOB_COMPLETE                  (0x00000003)
+#define MPI_SAS_PHY0_PHYINFO_RATE_1_5                           (0x00000008)
+#define MPI_SAS_PHY0_PHYINFO_RATE_3_0                           (0x00000009)
+
+
+typedef struct _CONFIG_PAGE_SAS_PHY_1
+{
+    CONFIG_EXTENDED_PAGE_HEADER Header;                     /* 00h */
+    U32                         Reserved1;                  /* 08h */
+    U32                         InvalidDwordCount;          /* 0Ch */
+    U32                         RunningDisparityErrorCount; /* 10h */
+    U32                         LossDwordSynchCount;        /* 14h */
+    U32                         PhyResetProblemCount;       /* 18h */
+} CONFIG_PAGE_SAS_PHY_1, MPI_POINTER PTR_CONFIG_PAGE_SAS_PHY_1,
+  SasPhyPage1_t, MPI_POINTER pSasPhyPage1_t;
+
+#define MPI_SASPHY1_PAGEVERSION             (0x00)
+
+
+/****************************************************************************
+*   SAS Enclosure Config Pages
+****************************************************************************/
+
+typedef struct _CONFIG_PAGE_SAS_ENCLOSURE_0
+{
+    CONFIG_EXTENDED_PAGE_HEADER         Header;                 /* 00h */
+    U32                                 Reserved1;              /* 08h */
+    U64                                 EnclosureLogicalID;     /* 0Ch */
+    U16                                 Flags;                  /* 14h */
+    U16                                 EnclosureHandle;        /* 16h */
+    U16                                 NumSlots;               /* 18h */
+    U16                                 StartSlot;              /* 1Ah */
+    U8                                  StartTargetID;          /* 1Ch */
+    U8                                  StartBus;               /* 1Dh */
+    U8                                  SEPTargetID;            /* 1Eh */
+    U8                                  SEPBus;                 /* 1Fh */
+    U32                                 Reserved2;              /* 20h */
+    U32                                 Reserved3;              /* 24h */
+} CONFIG_PAGE_SAS_ENCLOSURE_0, MPI_POINTER PTR_CONFIG_PAGE_SAS_ENCLOSURE_0,
+  SasEnclosurePage0_t, MPI_POINTER pSasEnclosurePage0_t;
+
+#define MPI_SASENCLOSURE0_PAGEVERSION       (0x00)
+
+/* values for SAS Enclosure Page 0 Flags field */
+#define MPI_SAS_ENCLS0_FLAGS_SEP_BUS_ID_VALID       (0x0020)
+#define MPI_SAS_ENCLS0_FLAGS_START_BUS_ID_VALID     (0x0010)
+
+#define MPI_SAS_ENCLS0_FLAGS_MNG_MASK               (0x000F)
+#define MPI_SAS_ENCLS0_FLAGS_MNG_UNKNOWN            (0x0000)
+#define MPI_SAS_ENCLS0_FLAGS_MNG_IOC_SES            (0x0001)
+#define MPI_SAS_ENCLS0_FLAGS_MNG_IOC_SGPIO          (0x0002)
+#define MPI_SAS_ENCLS0_FLAGS_MNG_EXP_SGPIO          (0x0003)
+#define MPI_SAS_ENCLS0_FLAGS_MNG_SES_ENCLOSURE      (0x0004)
+
+
+/****************************************************************************
+*   Log Config Pages
+****************************************************************************/
+/*
+ * Host code (drivers, BIOS, utilities, etc.) should leave this define set to
+ * one and check NumLogEntries at runtime.
+ */
+#ifndef MPI_LOG_0_NUM_LOG_ENTRIES
+#define MPI_LOG_0_NUM_LOG_ENTRIES        (1)
+#endif
+
+#define MPI_LOG_0_LOG_DATA_LENGTH        (20)
+
+typedef struct _MPI_LOG_0_ENTRY
+{
+    U64         WWID;                               /* 00h */
+    U32         TimeStamp;                          /* 08h */
+    U32         Reserved1;                          /* 0Ch */
+    U16         LogSequence;                        /* 10h */
+    U16         LogEntryQualifier;                  /* 12h */
+    U8          LogData[MPI_LOG_0_LOG_DATA_LENGTH]; /* 14h */
+} MPI_LOG_0_ENTRY, MPI_POINTER PTR_MPI_LOG_0_ENTRY,
+  MpiLog0Entry_t, MPI_POINTER pMpiLog0Entry_t;
+
+/* values for Log Page 0 LogEntry LogEntryQualifier field */
+#define MPI_LOG_0_ENTRY_QUAL_ENTRY_UNUSED           (0x0000)
+#define MPI_LOG_0_ENTRY_QUAL_POWER_ON_RESET         (0x0001)
+
+typedef struct _CONFIG_PAGE_LOG_0
+{
+    CONFIG_EXTENDED_PAGE_HEADER Header;                     /* 00h */
+    U32                         Reserved1;                  /* 08h */
+    U32                         Reserved2;                  /* 0Ch */
+    U16                         NumLogEntries;              /* 10h */
+    U16                         Reserved3;                  /* 12h */
+    MPI_LOG_0_ENTRY             LogEntry[MPI_LOG_0_NUM_LOG_ENTRIES]; /* 14h */
+} CONFIG_PAGE_LOG_0, MPI_POINTER PTR_CONFIG_PAGE_LOG_0,
+  LogPage0_t, MPI_POINTER pLogPage0_t;
+
+#define MPI_LOG_0_PAGEVERSION               (0x00)
+
+
 #endif
 
diff -urNp linux-8145/drivers/message/fusion/lsi/mpi_fc.h linux-8150/drivers/message/fusion/lsi/mpi_fc.h
--- linux-8145/drivers/message/fusion/lsi/mpi_fc.h
+++ linux-8150/drivers/message/fusion/lsi/mpi_fc.h
@@ -1,12 +1,12 @@
 /*
- *  Copyright (c) 2000-2002 LSI Logic Corporation.
+ *  Copyright (c) 2000-2004 LSI Logic Corporation.
  *
  *
- *           Name:  MPI_FC.H
+ *           Name:  mpi_fc.h
  *          Title:  MPI Fibre Channel messages and structures
  *  Creation Date:  June 12, 2000
  *
- *    MPI_FC.H Version:  01.02.03
+ *    mpi_fc.h Version:  01.05.01
  *
  *  Version History
  *  ---------------
@@ -36,6 +36,9 @@
  *  09-28-01  01.02.02  Change name of reserved field in
  *                      MSG_LINK_SERVICE_RSP_REPLY.
  *  05-31-02  01.02.03  Adding AliasIndex to FC Direct Access requests.
+ *  01-16-04  01.02.04  Added define for MPI_FC_PRIM_SEND_FLAGS_ML_RESET_LINK.
+ *  05-11-04  01.03.01  Original release for MPI v1.3.
+ *  08-19-04  01.05.01  Original release for MPI v1.5.
  *  --------------------------------------------------------------------------
  */
 
@@ -45,7 +48,7 @@
 
 /*****************************************************************************
 *
-*        F C    T a r g e t    M o d e    M e s s a g e s
+*        F C    D i r e c t    A c c e s s     M e s s a g e s
 *
 *****************************************************************************/
 
@@ -334,6 +337,7 @@ typedef struct _MSG_FC_PRIMITIVE_SEND_RE
   FcPrimitiveSendRequest_t, MPI_POINTER pFcPrimitiveSendRequest_t;
 
 #define MPI_FC_PRIM_SEND_FLAGS_PORT_MASK       (0x01)
+#define MPI_FC_PRIM_SEND_FLAGS_ML_RESET_LINK   (0x02)
 #define MPI_FC_PRIM_SEND_FLAGS_RESET_LINK      (0x04)
 #define MPI_FC_PRIM_SEND_FLAGS_STOP_SEND       (0x08)
 #define MPI_FC_PRIM_SEND_FLAGS_SEND_ONCE       (0x10)
diff -urNp linux-8145/drivers/message/fusion/lsi/mpi_inb.h linux-8150/drivers/message/fusion/lsi/mpi_inb.h
--- linux-8145/drivers/message/fusion/lsi/mpi_inb.h
+++ linux-8150/drivers/message/fusion/lsi/mpi_inb.h
@@ -0,0 +1,221 @@
+/*
+ *  Copyright (c) 2003-2004 LSI Logic Corporation.
+ *
+ *
+ *           Name:  mpi_inb.h
+ *          Title:  MPI Inband structures and definitions
+ *  Creation Date:  September 30, 2003
+ *
+ *    mpi_inb.h Version:  01.05.01
+ *
+ *  Version History
+ *  ---------------
+ *
+ *  Date      Version   Description
+ *  --------  --------  ------------------------------------------------------
+ *  05-11-04  01.03.01  Original release.
+ *  08-19-04  01.05.01  Original release for MPI v1.5.
+ *  --------------------------------------------------------------------------
+ */
+
+#ifndef MPI_INB_H
+#define MPI_INB_H
+
+/******************************************************************************
+*
+*        I n b a n d    M e s s a g e s
+*
+*******************************************************************************/
+
+
+/****************************************************************************/
+/* Inband Buffer Post Request                                               */
+/****************************************************************************/
+
+typedef struct _MSG_INBAND_BUFFER_POST_REQUEST
+{
+    U8                      Reserved1;          /* 00h */
+    U8                      BufferCount;        /* 01h */
+    U8                      ChainOffset;        /* 02h */
+    U8                      Function;           /* 03h */
+    U16                     Reserved2;          /* 04h */
+    U8                      Reserved3;          /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U32                     Reserved4;          /* 0Ch */
+    SGE_TRANS_SIMPLE_UNION  SGL;                /* 10h */
+} MSG_INBAND_BUFFER_POST_REQUEST, MPI_POINTER PTR_MSG_INBAND_BUFFER_POST_REQUEST,
+  MpiInbandBufferPostRequest_t , MPI_POINTER pMpiInbandBufferPostRequest_t;
+
+
+typedef struct _WWN_FC_FORMAT
+{
+    U64                     NodeName;           /* 00h */
+    U64                     PortName;           /* 08h */
+} WWN_FC_FORMAT, MPI_POINTER PTR_WWN_FC_FORMAT,
+  WwnFcFormat_t, MPI_POINTER pWwnFcFormat_t;
+
+typedef struct _WWN_SAS_FORMAT
+{
+    U64                     WorldWideID;        /* 00h */
+    U32                     Reserved1;          /* 08h */
+    U32                     Reserved2;          /* 0Ch */
+} WWN_SAS_FORMAT, MPI_POINTER PTR_WWN_SAS_FORMAT,
+  WwnSasFormat_t, MPI_POINTER pWwnSasFormat_t;
+
+typedef union _WWN_INBAND_FORMAT
+{
+    WWN_FC_FORMAT           Fc;
+    WWN_SAS_FORMAT          Sas;
+} WWN_INBAND_FORMAT, MPI_POINTER PTR_WWN_INBAND_FORMAT,
+  WwnInbandFormat, MPI_POINTER pWwnInbandFormat;
+
+
+/* Inband Buffer Post reply message */
+
+typedef struct _MSG_INBAND_BUFFER_POST_REPLY
+{
+    U16                     Reserved1;          /* 00h */
+    U8                      MsgLength;          /* 02h */
+    U8                      Function;           /* 03h */
+    U16                     Reserved2;          /* 04h */
+    U8                      Reserved3;          /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U16                     Reserved4;          /* 0Ch */
+    U16                     IOCStatus;          /* 0Eh */
+    U32                     IOCLogInfo;         /* 10h */
+    U32                     TransferLength;     /* 14h */
+    U32                     TransactionContext; /* 18h */
+    WWN_INBAND_FORMAT       Wwn;                /* 1Ch */
+    U32                     IOCIdentifier[4];   /* 2Ch */
+} MSG_INBAND_BUFFER_POST_REPLY, MPI_POINTER PTR_MSG_INBAND_BUFFER_POST_REPLY,
+  MpiInbandBufferPostReply_t, MPI_POINTER pMpiInbandBufferPostReply_t;
+
+
+/****************************************************************************/
+/* Inband Send Request                                                      */
+/****************************************************************************/
+
+typedef struct _MSG_INBAND_SEND_REQUEST
+{
+    U16                     Reserved1;          /* 00h */
+    U8                      ChainOffset;        /* 02h */
+    U8                      Function;           /* 03h */
+    U16                     Reserved2;          /* 04h */
+    U8                      Reserved3;          /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U32                     Reserved4;          /* 0Ch */
+    WWN_INBAND_FORMAT       Wwn;                /* 10h */
+    U32                     Reserved5;          /* 20h */
+    SGE_IO_UNION            SGL;                /* 24h */
+} MSG_INBAND_SEND_REQUEST, MPI_POINTER PTR_MSG_INBAND_SEND_REQUEST,
+  MpiInbandSendRequest_t , MPI_POINTER pMpiInbandSendRequest_t;
+
+
+/* Inband Send reply message */
+
+typedef struct _MSG_INBAND_SEND_REPLY
+{
+    U16                     Reserved1;          /* 00h */
+    U8                      MsgLength;          /* 02h */
+    U8                      Function;           /* 03h */
+    U16                     Reserved2;          /* 04h */
+    U8                      Reserved3;          /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U16                     Reserved4;          /* 0Ch */
+    U16                     IOCStatus;          /* 0Eh */
+    U32                     IOCLogInfo;         /* 10h */
+    U32                     ResponseLength;     /* 14h */
+} MSG_INBAND_SEND_REPLY, MPI_POINTER PTR_MSG_INBAND_SEND_REPLY,
+  MpiInbandSendReply_t, MPI_POINTER pMpiInbandSendReply_t;
+
+
+/****************************************************************************/
+/* Inband Response Request                                                  */
+/****************************************************************************/
+
+typedef struct _MSG_INBAND_RSP_REQUEST
+{
+    U16                     Reserved1;          /* 00h */
+    U8                      ChainOffset;        /* 02h */
+    U8                      Function;           /* 03h */
+    U16                     Reserved2;          /* 04h */
+    U8                      Reserved3;          /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U32                     Reserved4;          /* 0Ch */
+    WWN_INBAND_FORMAT       Wwn;                /* 10h */
+    U32                     IOCIdentifier[4];   /* 20h */
+    U32                     ResponseLength;     /* 30h */
+    SGE_IO_UNION            SGL;                /* 34h */
+} MSG_INBAND_RSP_REQUEST, MPI_POINTER PTR_MSG_INBAND_RSP_REQUEST,
+  MpiInbandRspRequest_t , MPI_POINTER pMpiInbandRspRequest_t;
+
+
+/* Inband Response reply message */
+
+typedef struct _MSG_INBAND_RSP_REPLY
+{
+    U16                     Reserved1;          /* 00h */
+    U8                      MsgLength;          /* 02h */
+    U8                      Function;           /* 03h */
+    U16                     Reserved2;          /* 04h */
+    U8                      Reserved3;          /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U16                     Reserved4;          /* 0Ch */
+    U16                     IOCStatus;          /* 0Eh */
+    U32                     IOCLogInfo;         /* 10h */
+} MSG_INBAND_RSP_REPLY, MPI_POINTER PTR_MSG_INBAND_RSP_REPLY,
+  MpiInbandRspReply_t, MPI_POINTER pMpiInbandRspReply_t;
+
+
+/****************************************************************************/
+/* Inband Abort Request                                                     */
+/****************************************************************************/
+
+typedef struct _MSG_INBAND_ABORT_REQUEST
+{
+    U8                      Reserved1;          /* 00h */
+    U8                      AbortType;          /* 01h */
+    U8                      ChainOffset;        /* 02h */
+    U8                      Function;           /* 03h */
+    U16                     Reserved2;          /* 04h */
+    U8                      Reserved3;          /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U32                     Reserved4;          /* 0Ch */
+    U32                     ContextToAbort;     /* 10h */
+} MSG_INBAND_ABORT_REQUEST, MPI_POINTER PTR_MSG_INBAND_ABORT_REQUEST,
+  MpiInbandAbortRequest_t , MPI_POINTER pMpiInbandAbortRequest_t;
+
+#define MPI_INBAND_ABORT_TYPE_ALL_BUFFERS       (0x00)
+#define MPI_INBAND_ABORT_TYPE_EXACT_BUFFER      (0x01)
+#define MPI_INBAND_ABORT_TYPE_SEND_REQUEST      (0x02)
+#define MPI_INBAND_ABORT_TYPE_RESPONSE_REQUEST  (0x03)
+
+
+/* Inband Abort reply message */
+
+typedef struct _MSG_INBAND_ABORT_REPLY
+{
+    U8                      Reserved1;          /* 00h */
+    U8                      AbortType;          /* 01h */
+    U8                      MsgLength;          /* 02h */
+    U8                      Function;           /* 03h */
+    U16                     Reserved2;          /* 04h */
+    U8                      Reserved3;          /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U16                     Reserved4;          /* 0Ch */
+    U16                     IOCStatus;          /* 0Eh */
+    U32                     IOCLogInfo;         /* 10h */
+} MSG_INBAND_ABORT_REPLY, MPI_POINTER PTR_MSG_INBAND_ABORT_REPLY,
+  MpiInbandAbortReply_t, MPI_POINTER pMpiInbandAbortReply_t;
+
+
+#endif
+
diff -urNp linux-8145/drivers/message/fusion/lsi/mpi_init.h linux-8150/drivers/message/fusion/lsi/mpi_init.h
--- linux-8145/drivers/message/fusion/lsi/mpi_init.h
+++ linux-8150/drivers/message/fusion/lsi/mpi_init.h
@@ -1,12 +1,12 @@
 /*
- *  Copyright (c) 2000-2002 LSI Logic Corporation.
+ *  Copyright (c) 2000-2005 LSI Logic Corporation.
  *
  *
- *           Name:  MPI_INIT.H
+ *           Name:  mpi_init.h
  *          Title:  MPI initiator mode messages and structures
  *  Creation Date:  June 8, 2000
  *
- *    MPI_INIT.H Version:  01.02.05
+ *    mpi_init.h Version:  01.05.04
  *
  *  Version History
  *  ---------------
@@ -31,6 +31,23 @@
  *  10-04-01  01.02.04  Added defines for SEP request Action field.
  *  05-31-02  01.02.05  Added MPI_SCSIIO_MSGFLGS_CMD_DETERMINES_DATA_DIR define
  *                      for SCSI IO requests.
+ *  11-15-02  01.02.06  Added special extended SCSI Status defines for FCP.
+ *  06-26-03  01.02.07  Added MPI_SCSI_STATUS_FCPEXT_UNASSIGNED define.
+ *  05-11-04  01.03.01  Original release for MPI v1.3.
+ *  08-19-04  01.05.01  Added MsgFlags defines for EEDP to SCSI IO request.
+ *                      Added new word to MSG_SCSI_IO_REPLY to add TaskTag field
+ *                      and a reserved U16.
+ *                      Added new MSG_SCSI_IO32_REQUEST structure.
+ *                      Added a TaskType of Clear Task Set to SCSI
+ *                      Task Management request.
+ *  12-07-04  01.05.02  Added support for Task Management Query Task.
+ *  01-15-05  01.05.03  Modified SCSI Enclosure Processor Request to support
+ *                      WWID addressing.
+ *  03-11-05  01.05.04  Removed EEDP flags from SCSI IO Request.
+ *                      Removed SCSI IO 32 Request.
+ *                      Modified SCSI Enclosure Processor Request and Reply to
+ *                      support Enclosure/Slot addressing rather than WWID
+ *                      addressing.
  *  --------------------------------------------------------------------------
  */
 
@@ -45,7 +62,7 @@
 *****************************************************************************/
 
 /****************************************************************************/
-/*  SCSI IO messages and assocaited structures                              */
+/*  SCSI IO messages and associated structures                              */
 /****************************************************************************/
 
 typedef struct _MSG_SCSI_IO_REQUEST
@@ -74,9 +91,11 @@ typedef struct _MSG_SCSI_IO_REQUEST
 #define MPI_SCSIIO_MSGFLGS_SENSE_WIDTH              (0x01)
 #define MPI_SCSIIO_MSGFLGS_SENSE_WIDTH_32           (0x00)
 #define MPI_SCSIIO_MSGFLGS_SENSE_WIDTH_64           (0x01)
+
 #define MPI_SCSIIO_MSGFLGS_SENSE_LOCATION           (0x02)
 #define MPI_SCSIIO_MSGFLGS_SENSE_LOC_HOST           (0x00)
 #define MPI_SCSIIO_MSGFLGS_SENSE_LOC_IOC            (0x02)
+
 #define MPI_SCSIIO_MSGFLGS_CMD_DETERMINES_DATA_DIR  (0x04)
 
 /* SCSI IO LUN fields */
@@ -136,6 +155,8 @@ typedef struct _MSG_SCSI_IO_REPLY
     U32                     TransferCount;      /* 14h */
     U32                     SenseCount;         /* 18h */
     U32                     ResponseInfo;       /* 1Ch */
+    U16                     TaskTag;            /* 20h */
+    U16                     Reserved1;          /* 22h */
 } MSG_SCSI_IO_REPLY, MPI_POINTER PTR_MSG_SCSI_IO_REPLY,
   SCSIIOReply_t, MPI_POINTER pSCSIIOReply_t;
 
@@ -153,6 +174,10 @@ typedef struct _MSG_SCSI_IO_REPLY
 #define MPI_SCSI_STATUS_TASK_SET_FULL           (0x28)
 #define MPI_SCSI_STATUS_ACA_ACTIVE              (0x30)
 
+#define MPI_SCSI_STATUS_FCPEXT_DEVICE_LOGGED_OUT    (0x80)
+#define MPI_SCSI_STATUS_FCPEXT_NO_LINK              (0x81)
+#define MPI_SCSI_STATUS_FCPEXT_UNASSIGNED           (0x82)
+
 
 /* SCSI IO Reply SCSIState values */
 
@@ -174,6 +199,8 @@ typedef struct _MSG_SCSI_IO_REPLY
 #define MPI_SCSI_RSP_INFO_TASK_MGMT_FAILED      (0x05000000)
 #define MPI_SCSI_RSP_INFO_SPI_LQ_INVALID_TYPE   (0x06000000)
 
+#define MPI_SCSI_TASKTAG_UNKNOWN                (0xFFFF)
+
 
 /****************************************************************************/
 /*  SCSI Task Management messages                                           */
@@ -203,6 +230,8 @@ typedef struct _MSG_SCSI_TASK_MGMT
 #define MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET          (0x03)
 #define MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS             (0x04)
 #define MPI_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET    (0x05)
+#define MPI_SCSITASKMGMT_TASKTYPE_CLEAR_TASK_SET        (0x06)
+#define MPI_SCSITASKMGMT_TASKTYPE_QUERY_TASK            (0x07)
 
 /* MsgFlags bits */
 #define MPI_SCSITASKMGMT_MSGFLAGS_TARGET_RESET_OPTION   (0x00)
@@ -216,7 +245,7 @@ typedef struct _MSG_SCSI_TASK_MGMT_REPLY
     U8                      Bus;                /* 01h */
     U8                      MsgLength;          /* 02h */
     U8                      Function;           /* 03h */
-    U8                      Reserved;           /* 04h */
+    U8                      ResponseCode;       /* 04h */
     U8                      TaskType;           /* 05h */
     U8                      Reserved1;          /* 06h */
     U8                      MsgFlags;           /* 07h */
@@ -228,6 +257,15 @@ typedef struct _MSG_SCSI_TASK_MGMT_REPLY
 } MSG_SCSI_TASK_MGMT_REPLY, MPI_POINTER PTR_MSG_SCSI_TASK_MGMT_REPLY,
   SCSITaskMgmtReply_t, MPI_POINTER pSCSITaskMgmtReply_t;
 
+/* ResponseCode values */
+#define MPI_SCSITASKMGMT_RSP_TM_COMPLETE                (0x00)
+#define MPI_SCSITASKMGMT_RSP_INVALID_FRAME              (0x02)
+#define MPI_SCSITASKMGMT_RSP_TM_NOT_SUPPORTED           (0x04)
+#define MPI_SCSITASKMGMT_RSP_TM_FAILED                  (0x05)
+#define MPI_SCSITASKMGMT_RSP_TM_SUCCEEDED               (0x08)
+#define MPI_SCSITASKMGMT_RSP_TM_INVALID_LUN             (0x09)
+#define MPI_SCSITASKMGMT_RSP_IO_QUEUED_ON_IOC           (0x80)
+
 
 /****************************************************************************/
 /*  SCSI Enclosure Processor messages                                       */
@@ -240,11 +278,16 @@ typedef struct _MSG_SEP_REQUEST
     U8                      ChainOffset;        /* 02h */
     U8                      Function;           /* 03h */
     U8                      Action;             /* 04h */
-    U8                      Reserved1;          /* 05h */
-    U8                      Reserved2;          /* 06h */
+    U8                      Flags;              /* 05h */
+    U8                      Reserved1;          /* 06h */
     U8                      MsgFlags;           /* 07h */
     U32                     MsgContext;         /* 08h */
     U32                     SlotStatus;         /* 0Ch */
+    U32                     Reserved2;          /* 10h */
+    U32                     Reserved3;          /* 14h */
+    U32                     Reserved4;          /* 18h */
+    U16                     Slot;               /* 1Ch */
+    U16                     EnclosureHandle;    /* 1Eh */
 } MSG_SEP_REQUEST, MPI_POINTER PTR_MSG_SEP_REQUEST,
   SEPRequest_t, MPI_POINTER pSEPRequest_t;
 
@@ -252,6 +295,10 @@ typedef struct _MSG_SEP_REQUEST
 #define MPI_SEP_REQ_ACTION_WRITE_STATUS                 (0x00)
 #define MPI_SEP_REQ_ACTION_READ_STATUS                  (0x01)
 
+/* Flags defines */
+#define MPI_SEP_REQ_FLAGS_ENCLOSURE_SLOT_ADDRESS        (0x01)
+#define MPI_SEP_REQ_FLAGS_BUS_TARGETID_ADDRESS          (0x00)
+
 /* SlotStatus bits for MSG_SEP_REQUEST */
 #define MPI_SEP_REQ_SLOTSTATUS_NO_ERROR                 (0x00000001)
 #define MPI_SEP_REQ_SLOTSTATUS_DEV_FAULTY               (0x00000002)
@@ -288,6 +335,9 @@ typedef struct _MSG_SEP_REPLY
     U16                     IOCStatus;          /* 0Eh */
     U32                     IOCLogInfo;         /* 10h */
     U32                     SlotStatus;         /* 14h */
+    U32                     Reserved4;          /* 18h */
+    U16                     Slot;               /* 1Ch */
+    U16                     EnclosureHandle;    /* 1Eh */
 } MSG_SEP_REPLY, MPI_POINTER PTR_MSG_SEP_REPLY,
   SEPReply_t, MPI_POINTER pSEPReply_t;
 
diff -urNp linux-8145/drivers/message/fusion/lsi/mpi_ioc.h linux-8150/drivers/message/fusion/lsi/mpi_ioc.h
--- linux-8145/drivers/message/fusion/lsi/mpi_ioc.h
+++ linux-8150/drivers/message/fusion/lsi/mpi_ioc.h
@@ -1,12 +1,12 @@
 /*
- *  Copyright (c) 2000-2002 LSI Logic Corporation.
+ *  Copyright (c) 2000-2005 LSI Logic Corporation.
  *
  *
- *           Name:  MPI_IOC.H
+ *           Name:  mpi_ioc.h
  *          Title:  MPI IOC, Port, Event, FW Download, and FW Upload messages
  *  Creation Date:  August 11, 2000
  *
- *    MPI_IOC.H Version:  01.02.06
+ *    mpi_ioc.h Version:  01.05.08
  *
  *  Version History
  *  ---------------
@@ -55,6 +55,32 @@
  *  05-31-02  01.02.06  Added define for
  *                      MPI_IOCFACTS_EXCEPT_RAID_CONFIG_INVALID.
  *                      Added AliasIndex to EVENT_DATA_LOGOUT structure.
+ *  04-01-03  01.02.07  Added defines for MPI_FW_HEADER_SIGNATURE_.
+ *  06-26-03  01.02.08  Added new values to the product family defines.
+ *  04-29-04  01.02.09  Added IOCCapabilities field to MSG_IOC_FACTS_REPLY and
+ *                      added related defines.
+ *  05-11-04  01.03.01  Original release for MPI v1.3.
+ *  08-19-04  01.05.01  Added four new fields to MSG_IOC_INIT.
+ *                      Added three new fields to MSG_IOC_FACTS_REPLY.
+ *                      Defined four new bits for the IOCCapabilities field of
+ *                      the IOCFacts reply.
+ *                      Added two new PortTypes for the PortFacts reply.
+ *                      Added six new events along with their EventData
+ *                      structures.
+ *                      Added a new MsgFlag to the FwDownload request to
+ *                      indicate last segment.
+ *                      Defined a new image type of boot loader.
+ *                      Added FW family codes for SAS product families.
+ *  10-05-04  01.05.02  Added ReplyFifoHostSignalingAddr field to
+ *                      MSG_IOC_FACTS_REPLY.
+ *  12-07-04  01.05.03  Added more defines for SAS Discovery Error event.
+ *  12-09-04  01.05.04  Added Unsupported device to SAS Device event.
+ *  01-15-05  01.05.05  Added event data for SAS SES Event.
+ *  02-09-05  01.05.06  Added MPI_FW_UPLOAD_ITYPE_FW_BACKUP define.
+ *  02-22-05  01.05.07  Added Host Page Buffer Persistent flag to IOC Facts
+ *                      Reply and IOC Init Request.
+ *  03-11-05  01.05.08  Added family code for 1068E family.
+ *                      Removed IOCFacts Reply EEDP Capability bit.
  *  --------------------------------------------------------------------------
  */
 
@@ -87,19 +113,38 @@ typedef struct _MSG_IOC_INIT
     U8                      Reserved1[2];               /* 0Eh */
     U32                     HostMfaHighAddr;            /* 10h */
     U32                     SenseBufferHighAddr;        /* 14h */
+    U32                     ReplyFifoHostSignalingAddr; /* 18h */
+    SGE_SIMPLE_UNION        HostPageBufferSGE;          /* 1Ch */
+    U16                     MsgVersion;                 /* 28h */
+    U16                     HeaderVersion;              /* 2Ah */
 } MSG_IOC_INIT, MPI_POINTER PTR_MSG_IOC_INIT,
   IOCInit_t, MPI_POINTER pIOCInit_t;
 
 /* WhoInit values */
-#define MPI_WHOINIT_NO_ONE                      (0x00)
-#define MPI_WHOINIT_SYSTEM_BIOS                 (0x01)
-#define MPI_WHOINIT_ROM_BIOS                    (0x02)
-#define MPI_WHOINIT_PCI_PEER                    (0x03)
-#define MPI_WHOINIT_HOST_DRIVER                 (0x04)
-#define MPI_WHOINIT_MANUFACTURER                (0x05)
+#define MPI_WHOINIT_NO_ONE                              (0x00)
+#define MPI_WHOINIT_SYSTEM_BIOS                         (0x01)
+#define MPI_WHOINIT_ROM_BIOS                            (0x02)
+#define MPI_WHOINIT_PCI_PEER                            (0x03)
+#define MPI_WHOINIT_HOST_DRIVER                         (0x04)
+#define MPI_WHOINIT_MANUFACTURER                        (0x05)
 
 /* Flags values */
-#define MPI_IOCINIT_FLAGS_DISCARD_FW_IMAGE      (0x01)
+#define MPI_IOCINIT_FLAGS_HOST_PAGE_BUFFER_PERSISTENT   (0x04)
+#define MPI_IOCINIT_FLAGS_REPLY_FIFO_HOST_SIGNAL        (0x02)
+#define MPI_IOCINIT_FLAGS_DISCARD_FW_IMAGE              (0x01)
+
+/* MsgVersion */
+#define MPI_IOCINIT_MSGVERSION_MAJOR_MASK               (0xFF00)
+#define MPI_IOCINIT_MSGVERSION_MAJOR_SHIFT              (8)
+#define MPI_IOCINIT_MSGVERSION_MINOR_MASK               (0x00FF)
+#define MPI_IOCINIT_MSGVERSION_MINOR_SHIFT              (0)
+
+/* HeaderVersion */
+#define MPI_IOCINIT_HEADERVERSION_UNIT_MASK             (0xFF00)
+#define MPI_IOCINIT_HEADERVERSION_UNIT_SHIFT            (8)
+#define MPI_IOCINIT_HEADERVERSION_DEV_MASK              (0x00FF)
+#define MPI_IOCINIT_HEADERVERSION_DEV_SHIFT             (0)
+
 
 typedef struct _MSG_IOC_INIT_REPLY
 {
@@ -179,24 +224,43 @@ typedef struct _MSG_IOC_FACTS_REPLY
     U8                      MaxDevices;                 /* 2Eh */
     U8                      MaxBuses;                   /* 2Fh */
     U32                     FWImageSize;                /* 30h */
-    U32                     Reserved4;                  /* 34h */
+    U32                     IOCCapabilities;            /* 34h */
     MPI_FW_VERSION          FWVersion;                  /* 38h */
+    U16                     HighPriorityQueueDepth;     /* 3Ch */
+    U16                     Reserved2;                  /* 3Eh */
+    SGE_SIMPLE_UNION        HostPageBufferSGE;          /* 40h */
+    U32                     ReplyFifoHostSignalingAddr; /* 4Ch */
 } MSG_IOC_FACTS_REPLY, MPI_POINTER PTR_MSG_IOC_FACTS_REPLY,
   IOCFactsReply_t, MPI_POINTER pIOCFactsReply_t;
 
-#define MPI_IOCFACTS_MSGVERSION_MAJOR_MASK          (0xFF00)
-#define MPI_IOCFACTS_MSGVERSION_MINOR_MASK          (0x00FF)
-
-#define MPI_IOCFACTS_HEADERVERSION_UNIT_MASK        (0xFF00)
-#define MPI_IOCFACTS_HEADERVERSION_DEV_MASK         (0x00FF)
-
-#define MPI_IOCFACTS_EXCEPT_CONFIG_CHECKSUM_FAIL    (0x0001)
-#define MPI_IOCFACTS_EXCEPT_RAID_CONFIG_INVALID     (0x0002)
-
-#define MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT         (0x01)
-
-#define MPI_IOCFACTS_EVENTSTATE_DISABLED            (0x00)
-#define MPI_IOCFACTS_EVENTSTATE_ENABLED             (0x01)
+#define MPI_IOCFACTS_MSGVERSION_MAJOR_MASK              (0xFF00)
+#define MPI_IOCFACTS_MSGVERSION_MAJOR_SHIFT             (8)
+#define MPI_IOCFACTS_MSGVERSION_MINOR_MASK              (0x00FF)
+#define MPI_IOCFACTS_MSGVERSION_MINOR_SHIFT             (0)
+
+#define MPI_IOCFACTS_HDRVERSION_UNIT_MASK               (0xFF00)
+#define MPI_IOCFACTS_HDRVERSION_UNIT_SHIFT              (8)
+#define MPI_IOCFACTS_HDRVERSION_DEV_MASK                (0x00FF)
+#define MPI_IOCFACTS_HDRVERSION_DEV_SHIFT               (0)
+
+#define MPI_IOCFACTS_EXCEPT_CONFIG_CHECKSUM_FAIL        (0x0001)
+#define MPI_IOCFACTS_EXCEPT_RAID_CONFIG_INVALID         (0x0002)
+#define MPI_IOCFACTS_EXCEPT_FW_CHECKSUM_FAIL            (0x0004)
+#define MPI_IOCFACTS_EXCEPT_PERSISTENT_TABLE_FULL       (0x0008)
+
+#define MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT             (0x01)
+#define MPI_IOCFACTS_FLAGS_REPLY_FIFO_HOST_SIGNAL       (0x02)
+#define MPI_IOCFACTS_FLAGS_HOST_PAGE_BUFFER_PERSISTENT  (0x04)
+
+#define MPI_IOCFACTS_EVENTSTATE_DISABLED                (0x00)
+#define MPI_IOCFACTS_EVENTSTATE_ENABLED                 (0x01)
+
+#define MPI_IOCFACTS_CAPABILITY_HIGH_PRI_Q              (0x00000001)
+#define MPI_IOCFACTS_CAPABILITY_REPLY_HOST_SIGNAL       (0x00000002)
+#define MPI_IOCFACTS_CAPABILITY_QUEUE_FULL_HANDLING     (0x00000004)
+#define MPI_IOCFACTS_CAPABILITY_DIAG_TRACE_BUFFER       (0x00000008)
+#define MPI_IOCFACTS_CAPABILITY_SNAPSHOT_BUFFER         (0x00000010)
+#define MPI_IOCFACTS_CAPABILITY_EXTENDED_BUFFER         (0x00000020)
 
 
 
@@ -253,6 +317,8 @@ typedef struct _MSG_PORT_FACTS_REPLY
 #define MPI_PORTFACTS_PORTTYPE_INACTIVE         (0x00)
 #define MPI_PORTFACTS_PORTTYPE_SCSI             (0x01)
 #define MPI_PORTFACTS_PORTTYPE_FC               (0x10)
+#define MPI_PORTFACTS_PORTTYPE_ISCSI            (0x20)
+#define MPI_PORTFACTS_PORTTYPE_SAS              (0x30)
 
 /* ProtocolFlags values */
 
@@ -386,6 +452,12 @@ typedef struct _MSG_EVENT_ACK_REPLY
 #define MPI_EVENT_INTEGRATED_RAID           (0x0000000B)
 #define MPI_EVENT_SCSI_DEVICE_STATUS_CHANGE (0x0000000C)
 #define MPI_EVENT_ON_BUS_TIMER_EXPIRED      (0x0000000D)
+#define MPI_EVENT_QUEUE_FULL                (0x0000000E)
+#define MPI_EVENT_SAS_DEVICE_STATUS_CHANGE  (0x0000000F)
+#define MPI_EVENT_SAS_SES                   (0x00000010)
+#define MPI_EVENT_PERSISTENT_TABLE_FULL     (0x00000011)
+#define MPI_EVENT_SAS_PHY_LINK_STATUS       (0x00000012)
+#define MPI_EVENT_SAS_DISCOVERY_ERROR       (0x00000013)
 
 /* AckRequired field values */
 
@@ -433,6 +505,74 @@ typedef struct _EVENT_DATA_SCSI_DEVICE_S
 #define MPI_EVENT_SCSI_DEV_STAT_RC_NOT_RESPONDING       (0x04)
 #define MPI_EVENT_SCSI_DEV_STAT_RC_SMART_DATA           (0x05)
 
+/* SAS Device Status Change Event data */
+
+typedef struct _EVENT_DATA_SAS_DEVICE_STATUS_CHANGE
+{
+    U8                      TargetID;                   /* 00h */
+    U8                      Bus;                        /* 01h */
+    U8                      ReasonCode;                 /* 02h */
+    U8                      Reserved;                   /* 03h */
+    U8                      ASC;                        /* 04h */
+    U8                      ASCQ;                       /* 05h */
+    U16                     DevHandle;                  /* 06h */
+    U32                     DeviceInfo;                 /* 08h */
+    U16                     ParentDevHandle;            /* 0Ch */
+    U8                      PhyNum;                     /* 0Eh */
+    U8                      Reserved1;                  /* 0Fh */
+    U64                     SASAddress;                 /* 10h */
+} EVENT_DATA_SAS_DEVICE_STATUS_CHANGE,
+  MPI_POINTER PTR_EVENT_DATA_SAS_DEVICE_STATUS_CHANGE,
+  MpiEventDataSasDeviceStatusChange_t,
+  MPI_POINTER pMpiEventDataSasDeviceStatusChange_t;
+
+/* MPI SAS Device Status Change Event data ReasonCode values */
+#define MPI_EVENT_SAS_DEV_STAT_RC_ADDED                 (0x03)
+#define MPI_EVENT_SAS_DEV_STAT_RC_NOT_RESPONDING        (0x04)
+#define MPI_EVENT_SAS_DEV_STAT_RC_SMART_DATA            (0x05)
+#define MPI_EVENT_SAS_DEV_STAT_RC_NO_PERSIST_ADDED      (0x06)
+#define MPI_EVENT_SAS_DEV_STAT_RC_UNSUPPORTED           (0x07)
+
+
+/* SCSI Event data for Queue Full event */
+
+typedef struct _EVENT_DATA_QUEUE_FULL
+{
+    U8                      TargetID;                   /* 00h */
+    U8                      Bus;                        /* 01h */
+    U16                     CurrentDepth;               /* 02h */
+} EVENT_DATA_QUEUE_FULL, MPI_POINTER PTR_EVENT_DATA_QUEUE_FULL,
+  EventDataQueueFull_t, MPI_POINTER pEventDataQueueFull_t;
+
+/* MPI Integrated RAID Event data */
+
+typedef struct _EVENT_DATA_RAID
+{
+    U8                      VolumeID;                   /* 00h */
+    U8                      VolumeBus;                  /* 01h */
+    U8                      ReasonCode;                 /* 02h */
+    U8                      PhysDiskNum;                /* 03h */
+    U8                      ASC;                        /* 04h */
+    U8                      ASCQ;                       /* 05h */
+    U16                     Reserved;                   /* 06h */
+    U32                     SettingsStatus;             /* 08h */
+} EVENT_DATA_RAID, MPI_POINTER PTR_EVENT_DATA_RAID,
+  MpiEventDataRaid_t, MPI_POINTER pMpiEventDataRaid_t;
+
+/* MPI Integrated RAID Event data ReasonCode values */
+#define MPI_EVENT_RAID_RC_VOLUME_CREATED                (0x00)
+#define MPI_EVENT_RAID_RC_VOLUME_DELETED                (0x01)
+#define MPI_EVENT_RAID_RC_VOLUME_SETTINGS_CHANGED       (0x02)
+#define MPI_EVENT_RAID_RC_VOLUME_STATUS_CHANGED         (0x03)
+#define MPI_EVENT_RAID_RC_VOLUME_PHYSDISK_CHANGED       (0x04)
+#define MPI_EVENT_RAID_RC_PHYSDISK_CREATED              (0x05)
+#define MPI_EVENT_RAID_RC_PHYSDISK_DELETED              (0x06)
+#define MPI_EVENT_RAID_RC_PHYSDISK_SETTINGS_CHANGED     (0x07)
+#define MPI_EVENT_RAID_RC_PHYSDISK_STATUS_CHANGED       (0x08)
+#define MPI_EVENT_RAID_RC_DOMAIN_VAL_NEEDED             (0x09)
+#define MPI_EVENT_RAID_RC_SMART_DATA                    (0x0A)
+#define MPI_EVENT_RAID_RC_REPLACE_ACTION_STARTED        (0x0B)
+
 /* MPI Link Status Change Event data */
 
 typedef struct _EVENT_DATA_LINK_STATUS
@@ -480,35 +620,63 @@ typedef struct _EVENT_DATA_LOGOUT
 
 #define MPI_EVENT_LOGOUT_ALL_ALIASES        (0xFF)
 
+/* SAS SES Event data */
 
-/* MPI Integrated RAID Event data */
+typedef struct _EVENT_DATA_SAS_SES
+{
+    U8                      PhyNum;                     /* 00h */
+    U8                      Port;                       /* 01h */
+    U8                      PortWidth;                  /* 02h */
+    U8                      Reserved1;                  /* 04h */
+} EVENT_DATA_SAS_SES, MPI_POINTER PTR_EVENT_DATA_SAS_SES,
+  MpiEventDataSasSes_t, MPI_POINTER pMpiEventDataSasSes_t;
 
-typedef struct _EVENT_DATA_RAID
+/* SAS Phy Link Status Event data */
+
+typedef struct _EVENT_DATA_SAS_PHY_LINK_STATUS
 {
-    U8                      VolumeID;                   /* 00h */
-    U8                      VolumeBus;                  /* 01h */
-    U8                      ReasonCode;                 /* 02h */
-    U8                      PhysDiskNum;                /* 03h */
-    U8                      ASC;                        /* 04h */
-    U8                      ASCQ;                       /* 05h */
-    U16                     Reserved;                   /* 06h */
-    U32                     SettingsStatus;             /* 08h */
-} EVENT_DATA_RAID, MPI_POINTER PTR_EVENT_DATA_RAID,
-  MpiEventDataRaid_t, MPI_POINTER pMpiEventDataRaid_t;
+    U8                      PhyNum;                     /* 00h */
+    U8                      LinkRates;                  /* 01h */
+    U16                     DevHandle;                  /* 02h */
+    U64                     SASAddress;                 /* 04h */
+} EVENT_DATA_SAS_PHY_LINK_STATUS, MPI_POINTER PTR_EVENT_DATA_SAS_PHY_LINK_STATUS,
+  MpiEventDataSasPhyLinkStatus_t, MPI_POINTER pMpiEventDataSasPhyLinkStatus_t;
+
+/* defines for the LinkRates field of the SAS PHY Link Status event */
+#define MPI_EVENT_SAS_PLS_LR_CURRENT_MASK                   (0xF0)
+#define MPI_EVENT_SAS_PLS_LR_CURRENT_SHIFT                  (4)
+#define MPI_EVENT_SAS_PLS_LR_PREVIOUS_MASK                  (0x0F)
+#define MPI_EVENT_SAS_PLS_LR_PREVIOUS_SHIFT                 (0)
+#define MPI_EVENT_SAS_PLS_LR_RATE_UNKNOWN                   (0x00)
+#define MPI_EVENT_SAS_PLS_LR_RATE_PHY_DISABLED              (0x01)
+#define MPI_EVENT_SAS_PLS_LR_RATE_FAILED_SPEED_NEGOTIATION  (0x02)
+#define MPI_EVENT_SAS_PLS_LR_RATE_SATA_OOB_COMPLETE         (0x03)
+#define MPI_EVENT_SAS_PLS_LR_RATE_1_5                       (0x08)
+#define MPI_EVENT_SAS_PLS_LR_RATE_3_0                       (0x09)
+
+/* SAS Discovery Errror Event data */
+
+typedef struct _EVENT_DATA_DISCOVERY_ERROR
+{
+    U32                     DiscoveryStatus;            /* 00h */
+    U8                      Port;                       /* 04h */
+    U8                      Reserved1;                  /* 05h */
+    U16                     Reserved2;                  /* 06h */
+} EVENT_DATA_DISCOVERY_ERROR, MPI_POINTER PTR_EVENT_DATA_DISCOVERY_ERROR,
+  EventDataDiscoveryError_t, MPI_POINTER pEventDataDiscoveryError_t;
 
-/* MPI Integrated RAID Event data ReasonCode values */
-#define MPI_EVENT_RAID_RC_VOLUME_CREATED                (0x00)
-#define MPI_EVENT_RAID_RC_VOLUME_DELETED                (0x01)
-#define MPI_EVENT_RAID_RC_VOLUME_SETTINGS_CHANGED       (0x02)
-#define MPI_EVENT_RAID_RC_VOLUME_STATUS_CHANGED         (0x03)
-#define MPI_EVENT_RAID_RC_VOLUME_PHYSDISK_CHANGED       (0x04)
-#define MPI_EVENT_RAID_RC_PHYSDISK_CREATED              (0x05)
-#define MPI_EVENT_RAID_RC_PHYSDISK_DELETED              (0x06)
-#define MPI_EVENT_RAID_RC_PHYSDISK_SETTINGS_CHANGED     (0x07)
-#define MPI_EVENT_RAID_RC_PHYSDISK_STATUS_CHANGED       (0x08)
-#define MPI_EVENT_RAID_RC_DOMAIN_VAL_NEEDED             (0x09)
-#define MPI_EVENT_RAID_RC_SMART_DATA                    (0x0A)
-#define MPI_EVENT_RAID_RC_REPLACE_ACTION_STARTED        (0x0B)
+#define MPI_EVENT_DSCVRY_ERR_DS_LOOP_DETECTED               (0x00000001)
+#define MPI_EVENT_DSCVRY_ERR_DS_UNADDRESSABLE_DEVICE        (0x00000002)
+#define MPI_EVENT_DSCVRY_ERR_DS_MULTIPLE_PORTS              (0x00000004)
+#define MPI_EVENT_DSCVRY_ERR_DS_EXPANDER_ERR                (0x00000008)
+#define MPI_EVENT_DSCVRY_ERR_DS_SMP_TIMEOUT                 (0x00000010)
+#define MPI_EVENT_DSCVRY_ERR_DS_OUT_ROUTE_ENTRIES           (0x00000020)
+#define MPI_EVENT_DSCVRY_ERR_DS_INDEX_NOT_EXIST             (0x00000040)
+#define MPI_EVENT_DSCVRY_ERR_DS_SMP_FUNCTION_FAILED         (0x00000080)
+#define MPI_EVENT_DSCVRY_ERR_DS_SMP_CRC_ERROR               (0x00000100)
+#define MPI_EVENT_DSCVRY_ERR_DS_MULTPL_SUBTRACTIVE          (0x00000200)
+#define MPI_EVENT_DSCVRY_ERR_DS_TABLE_TO_TABLE              (0x00000400)
+#define MPI_EVENT_DSCVRY_ERR_DS_MULTPL_PATHS                (0x00000800)
 
 
 /*****************************************************************************
@@ -534,10 +702,13 @@ typedef struct _MSG_FW_DOWNLOAD
 } MSG_FW_DOWNLOAD, MPI_POINTER PTR_MSG_FW_DOWNLOAD,
   FWDownload_t, MPI_POINTER pFWDownload_t;
 
-#define MPI_FW_DOWNLOAD_ITYPE_RESERVED      (0x00)
-#define MPI_FW_DOWNLOAD_ITYPE_FW            (0x01)
-#define MPI_FW_DOWNLOAD_ITYPE_BIOS          (0x02)
-#define MPI_FW_DOWNLOAD_ITYPE_NVDATA        (0x03)
+#define MPI_FW_DOWNLOAD_MSGFLGS_LAST_SEGMENT    (0x01)
+
+#define MPI_FW_DOWNLOAD_ITYPE_RESERVED          (0x00)
+#define MPI_FW_DOWNLOAD_ITYPE_FW                (0x01)
+#define MPI_FW_DOWNLOAD_ITYPE_BIOS              (0x02)
+#define MPI_FW_DOWNLOAD_ITYPE_NVDATA            (0x03)
+#define MPI_FW_DOWNLOAD_ITYPE_BOOTLOADER        (0x04)
 
 
 typedef struct _FWDownloadTCSGE
@@ -590,6 +761,8 @@ typedef struct _MSG_FW_UPLOAD
 #define MPI_FW_UPLOAD_ITYPE_FW_FLASH        (0x01)
 #define MPI_FW_UPLOAD_ITYPE_BIOS_FLASH      (0x02)
 #define MPI_FW_UPLOAD_ITYPE_NVDATA          (0x03)
+#define MPI_FW_UPLOAD_ITYPE_BOOTLOADER      (0x04)
+#define MPI_FW_UPLOAD_ITYPE_FW_BACKUP       (0x05)
 
 typedef struct _FWUploadTCSGE
 {
@@ -653,6 +826,11 @@ typedef struct _MPI_FW_HEADER
 #define MPI_FW_HEADER_PID_TYPE_MASK             (0xF000)
 #define MPI_FW_HEADER_PID_TYPE_SCSI             (0x0000)
 #define MPI_FW_HEADER_PID_TYPE_FC               (0x1000)
+#define MPI_FW_HEADER_PID_TYPE_SAS              (0x2000)
+
+#define MPI_FW_HEADER_SIGNATURE_0               (0x5AEAA55A)
+#define MPI_FW_HEADER_SIGNATURE_1               (0xA55AEAA5)
+#define MPI_FW_HEADER_SIGNATURE_2               (0x5AA55AEA)
 
 #define MPI_FW_HEADER_PID_PROD_MASK                     (0x0F00)
 #define MPI_FW_HEADER_PID_PROD_INITIATOR_SCSI           (0x0100)
@@ -661,8 +839,10 @@ typedef struct _MPI_FW_HEADER
 #define MPI_FW_HEADER_PID_PROD_IM_SCSI                  (0x0400)
 #define MPI_FW_HEADER_PID_PROD_IS_SCSI                  (0x0500)
 #define MPI_FW_HEADER_PID_PROD_CTX_SCSI                 (0x0600)
+#define MPI_FW_HEADER_PID_PROD_IR_SCSI                  (0x0700)
 
 #define MPI_FW_HEADER_PID_FAMILY_MASK           (0x00FF)
+/* SCSI */
 #define MPI_FW_HEADER_PID_FAMILY_1030A0_SCSI    (0x0001)
 #define MPI_FW_HEADER_PID_FAMILY_1030B0_SCSI    (0x0002)
 #define MPI_FW_HEADER_PID_FAMILY_1030B1_SCSI    (0x0003)
@@ -673,9 +853,20 @@ typedef struct _MPI_FW_HEADER
 #define MPI_FW_HEADER_PID_FAMILY_1020C0_SCSI    (0x0008)
 #define MPI_FW_HEADER_PID_FAMILY_1035A0_SCSI    (0x0009)
 #define MPI_FW_HEADER_PID_FAMILY_1035B0_SCSI    (0x000A)
+#define MPI_FW_HEADER_PID_FAMILY_1030TA0_SCSI   (0x000B)
+#define MPI_FW_HEADER_PID_FAMILY_1020TA0_SCSI   (0x000C)
+/* Fibre Channel */
 #define MPI_FW_HEADER_PID_FAMILY_909_FC         (0x0000)
-#define MPI_FW_HEADER_PID_FAMILY_919_FC         (0x0001)
-#define MPI_FW_HEADER_PID_FAMILY_919X_FC        (0x0002)
+#define MPI_FW_HEADER_PID_FAMILY_919_FC         (0x0001) /* 919 and 929     */
+#define MPI_FW_HEADER_PID_FAMILY_919X_FC        (0x0002) /* 919X and 929X   */
+#define MPI_FW_HEADER_PID_FAMILY_919XL_FC       (0x0003) /* 919XL and 929XL */
+#define MPI_FW_HEADER_PID_FAMILY_939X_FC        (0x0004) /* 939X and 949X   */
+#define MPI_FW_HEADER_PID_FAMILY_959_FC         (0x0005)
+/* SAS */
+#define MPI_FW_HEADER_PID_FAMILY_1064_SAS       (0x0001)
+#define MPI_FW_HEADER_PID_FAMILY_1068_SAS       (0x0002)
+#define MPI_FW_HEADER_PID_FAMILY_1078_SAS       (0x0003)
+#define MPI_FW_HEADER_PID_FAMILY_106xE_SAS      (0x0004) /* 1068E, 1066E, and 1064E */
 
 typedef struct _MPI_EXT_IMAGE_HEADER
 {
@@ -694,5 +885,6 @@ typedef struct _MPI_EXT_IMAGE_HEADER
 #define MPI_EXT_IMAGE_TYPE_UNSPECIFIED          (0x00)
 #define MPI_EXT_IMAGE_TYPE_FW                   (0x01)
 #define MPI_EXT_IMAGE_TYPE_NVDATA               (0x03)
+#define MPI_EXT_IMAGE_TYPE_BOOTLOADER           (0x04)
 
 #endif
diff -urNp linux-8145/drivers/message/fusion/lsi/mpi_lan.h linux-8150/drivers/message/fusion/lsi/mpi_lan.h
--- linux-8145/drivers/message/fusion/lsi/mpi_lan.h
+++ linux-8150/drivers/message/fusion/lsi/mpi_lan.h
@@ -1,12 +1,12 @@
 /*
- *  Copyright (c) 2000-2002 LSI Logic Corporation.
+ *  Copyright (c) 2000-2004 LSI Logic Corporation.
  *
  *
- *           Name:  MPI_LAN.H
+ *           Name:  mpi_lan.h
  *          Title:  MPI LAN messages and structures
  *  Creation Date:  June 30, 2000
  *
- *    MPI_LAN.H Version:  01.02.01
+ *    mpi_lan.h Version:  01.05.01
  *
  *  Version History
  *  ---------------
@@ -28,6 +28,8 @@
  *  02-20-01  01.01.02  Started using MPI_POINTER.
  *  03-27-01  01.01.03  Added structure offset comments.
  *  08-08-01  01.02.01  Original release for v1.2 work.
+ *  05-11-04  01.03.01  Original release for MPI v1.3.
+ *  08-19-04  01.05.01  Original release for MPI v1.5.
  *  --------------------------------------------------------------------------
  */
 
diff -urNp linux-8145/drivers/message/fusion/lsi/mpi_raid.h linux-8150/drivers/message/fusion/lsi/mpi_raid.h
--- linux-8145/drivers/message/fusion/lsi/mpi_raid.h
+++ linux-8150/drivers/message/fusion/lsi/mpi_raid.h
@@ -1,12 +1,12 @@
 /*
- *  Copyright (c) 2001-2002 LSI Logic Corporation.
+ *  Copyright (c) 2001-2005 LSI Logic Corporation.
  *
  *
- *           Name:  MPI_RAID.H
+ *           Name:  mpi_raid.h
  *          Title:  MPI RAID message and structures
  *  Creation Date:  February 27, 2001
  *
- *    MPI_RAID.H Version:  01.02.07
+ *    mpi_raid.h Version:  01.05.02
  *
  *  Version History
  *  ---------------
@@ -25,6 +25,13 @@
  *                      MPI_RAID_ACTION_INACTIVATE_VOLUME, and
  *                      MPI_RAID_ACTION_ADATA_INACTIVATE_ALL.
  *  07-12-02  01.02.07  Added structures for Mailbox request and reply.
+ *  11-15-02  01.02.08  Added missing MsgContext field to MSG_MAILBOX_REQUEST.
+ *  04-01-03  01.02.09  New action data option flag for
+ *                      MPI_RAID_ACTION_DELETE_VOLUME.
+ *  05-11-04  01.03.01  Original release for MPI v1.3.
+ *  08-19-04  01.05.01  Original release for MPI v1.5.
+ *  01-15-05  01.05.02  Added defines for the two new RAID Actions for
+ *                      _SET_RESYNC_RATE and _SET_DATA_SCRUB_RATE.
  *  --------------------------------------------------------------------------
  */
 
@@ -40,7 +47,7 @@
 
 
 /****************************************************************************/
-/* RAID Volume Request                                                      */
+/* RAID Action Request                                                      */
 /****************************************************************************/
 
 typedef struct _MSG_RAID_ACTION
@@ -81,6 +88,8 @@ typedef struct _MSG_RAID_ACTION
 #define MPI_RAID_ACTION_REPLACE_PHYSDISK            (0x10)
 #define MPI_RAID_ACTION_ACTIVATE_VOLUME             (0x11)
 #define MPI_RAID_ACTION_INACTIVATE_VOLUME           (0x12)
+#define MPI_RAID_ACTION_SET_RESYNC_RATE             (0x13)
+#define MPI_RAID_ACTION_SET_DATA_SCRUB_RATE         (0x14)
 
 /* ActionDataWord defines for use with MPI_RAID_ACTION_CREATE_VOLUME action */
 #define MPI_RAID_ACTION_ADATA_DO_NOT_SYNC           (0x00000001)
@@ -90,9 +99,19 @@ typedef struct _MSG_RAID_ACTION
 #define MPI_RAID_ACTION_ADATA_KEEP_PHYS_DISKS       (0x00000000)
 #define MPI_RAID_ACTION_ADATA_DEL_PHYS_DISKS        (0x00000001)
 
+#define MPI_RAID_ACTION_ADATA_KEEP_LBA0             (0x00000000)
+#define MPI_RAID_ACTION_ADATA_ZERO_LBA0             (0x00000002)
+
 /* ActionDataWord defines for use with MPI_RAID_ACTION_ACTIVATE_VOLUME action */
 #define MPI_RAID_ACTION_ADATA_INACTIVATE_ALL        (0x00000001)
 
+/* ActionDataWord defines for use with MPI_RAID_ACTION_SET_RESYNC_RATE action */
+#define MPI_RAID_ACTION_ADATA_RESYNC_RATE_MASK      (0x000000FF)
+
+/* ActionDataWord defines for use with MPI_RAID_ACTION_SET_DATA_SCRUB_RATE action */
+#define MPI_RAID_ACTION_ADATA_DATA_SCRUB_RATE_MASK  (0x000000FF)
+
+
 
 /* RAID Action reply message */
 
@@ -195,6 +214,7 @@ typedef struct _MSG_MAILBOX_REQUEST
     U16                     Reserved2;
     U8                      Reserved3;
     U8                      MsgFlags;
+    U32                     MsgContext;
     U8                      Command[10];
     U16                     Reserved4;
     SGE_IO_UNION            SGL;
diff -urNp linux-8145/drivers/message/fusion/lsi/mpi_sas.h linux-8150/drivers/message/fusion/lsi/mpi_sas.h
--- linux-8145/drivers/message/fusion/lsi/mpi_sas.h
+++ linux-8150/drivers/message/fusion/lsi/mpi_sas.h
@@ -0,0 +1,250 @@
+/*
+ *  Copyright (c) 2004 LSI Logic Corporation.
+ *
+ *
+ *           Name:  mpi_sas.h
+ *          Title:  MPI Serial Attached SCSI structures and definitions
+ *  Creation Date:  August 19, 2004
+ *
+ *    mpi_sas.h Version:  01.05.01
+ *
+ *  Version History
+ *  ---------------
+ *
+ *  Date      Version   Description
+ *  --------  --------  ------------------------------------------------------
+ *  08-19-04  01.05.01  Original release.
+ *  --------------------------------------------------------------------------
+ */
+
+#ifndef MPI_SAS_H
+#define MPI_SAS_H
+
+
+/*
+ * Values for SASStatus.
+ */
+#define MPI_SASSTATUS_SUCCESS                           (0x00)
+#define MPI_SASSTATUS_UNKNOWN_ERROR                     (0x01)
+#define MPI_SASSTATUS_INVALID_FRAME                     (0x02)
+#define MPI_SASSTATUS_UTC_BAD_DEST                      (0x03)
+#define MPI_SASSTATUS_UTC_BREAK_RECEIVED                (0x04)
+#define MPI_SASSTATUS_UTC_CONNECT_RATE_NOT_SUPPORTED    (0x05)
+#define MPI_SASSTATUS_UTC_PORT_LAYER_REQUEST            (0x06)
+#define MPI_SASSTATUS_UTC_PROTOCOL_NOT_SUPPORTED        (0x07)
+#define MPI_SASSTATUS_UTC_STP_RESOURCES_BUSY            (0x08)
+#define MPI_SASSTATUS_UTC_WRONG_DESTINATION             (0x09)
+#define MPI_SASSTATUS_SHORT_INFORMATION_UNIT            (0x0A)
+#define MPI_SASSTATUS_LONG_INFORMATION_UNIT             (0x0B)
+#define MPI_SASSTATUS_XFER_RDY_INCORRECT_WRITE_DATA     (0x0C)
+#define MPI_SASSTATUS_XFER_RDY_REQUEST_OFFSET_ERROR     (0x0D)
+#define MPI_SASSTATUS_XFER_RDY_NOT_EXPECTED             (0x0E)
+#define MPI_SASSTATUS_DATA_INCORRECT_DATA_LENGTH        (0x0F)
+#define MPI_SASSTATUS_DATA_TOO_MUCH_READ_DATA           (0x10)
+#define MPI_SASSTATUS_DATA_OFFSET_ERROR                 (0x11)
+#define MPI_SASSTATUS_SDSF_NAK_RECEIVED                 (0x12)
+#define MPI_SASSTATUS_SDSF_CONNECTION_FAILED            (0x13)
+#define MPI_SASSTATUS_INITIATOR_RESPONSE_TIMEOUT        (0x14)
+
+
+/*
+ * Values for the SAS DeviceInfo field used in SAS Device Status Change Event
+ * data and SAS IO Unit Configuration pages.
+ */
+#define MPI_SAS_DEVICE_INFO_ATAPI_DEVICE        (0x00002000)
+#define MPI_SAS_DEVICE_INFO_LSI_DEVICE          (0x00001000)
+#define MPI_SAS_DEVICE_INFO_DIRECT_ATTACH       (0x00000800)
+#define MPI_SAS_DEVICE_INFO_SSP_TARGET          (0x00000400)
+#define MPI_SAS_DEVICE_INFO_STP_TARGET          (0x00000200)
+#define MPI_SAS_DEVICE_INFO_SMP_TARGET          (0x00000100)
+#define MPI_SAS_DEVICE_INFO_SATA_DEVICE         (0x00000080)
+#define MPI_SAS_DEVICE_INFO_SSP_INITIATOR       (0x00000040)
+#define MPI_SAS_DEVICE_INFO_STP_INITIATOR       (0x00000020)
+#define MPI_SAS_DEVICE_INFO_SMP_INITIATOR       (0x00000010)
+#define MPI_SAS_DEVICE_INFO_SATA_HOST           (0x00000008)
+
+#define MPI_SAS_DEVICE_INFO_MASK_DEVICE_TYPE    (0x00000007)
+#define MPI_SAS_DEVICE_INFO_NO_DEVICE           (0x00000000)
+#define MPI_SAS_DEVICE_INFO_END_DEVICE          (0x00000001)
+#define MPI_SAS_DEVICE_INFO_EDGE_EXPANDER       (0x00000002)
+#define MPI_SAS_DEVICE_INFO_FANOUT_EXPANDER     (0x00000003)
+
+
+
+/*****************************************************************************
+*
+*        S e r i a l    A t t a c h e d    S C S I     M e s s a g e s
+*
+*****************************************************************************/
+
+/****************************************************************************/
+/* Serial Management Protocol Passthrough Request                           */
+/****************************************************************************/
+
+typedef struct _MSG_SMP_PASSTHROUGH_REQUEST
+{
+    U8                      PassthroughFlags;   /* 00h */
+    U8                      PhysicalPort;       /* 01h */
+    U8                      ChainOffset;        /* 02h */
+    U8                      Function;           /* 03h */
+    U16                     RequestDataLength;  /* 04h */
+    U8                      ConnectionRate;     /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U32                     Reserved1;          /* 0Ch */
+    U64                     SASAddress;         /* 10h */
+    U32                     Reserved2;          /* 18h */
+    U32                     Reserved3;          /* 1Ch */
+    SGE_SIMPLE_UNION        SGL;                /* 20h */
+} MSG_SMP_PASSTHROUGH_REQUEST, MPI_POINTER PTR_MSG_SMP_PASSTHROUGH_REQUEST,
+  SmpPassthroughRequest_t, MPI_POINTER pSmpPassthroughRequest_t;
+
+/* values for PassthroughFlags field */
+#define MPI_SMP_PT_REQ_PT_FLAGS_IMMEDIATE       (0x80)
+
+/* values for ConnectionRate field */
+#define MPI_SMP_PT_REQ_CONNECT_RATE_NEGOTIATED  (0x00)
+#define MPI_SMP_PT_REQ_CONNECT_RATE_1_5         (0x08)
+#define MPI_SMP_PT_REQ_CONNECT_RATE_3_0         (0x09)
+
+
+/* Serial Management Protocol Passthrough Reply */
+typedef struct _MSG_SMP_PASSTHROUGH_REPLY
+{
+    U8                      PassthroughFlags;   /* 00h */
+    U8                      PhysicalPort;       /* 01h */
+    U8                      MsgLength;          /* 02h */
+    U8                      Function;           /* 03h */
+    U16                     ResponseDataLength; /* 04h */
+    U8                      Reserved1;          /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U8                      Reserved2;          /* 0Ch */
+    U8                      SASStatus;          /* 0Dh */
+    U16                     IOCStatus;          /* 0Eh */
+    U32                     IOCLogInfo;         /* 10h */
+    U32                     Reserved3;          /* 14h */
+    U8                      ResponseData[4];    /* 18h */
+} MSG_SMP_PASSTHROUGH_REPLY, MPI_POINTER PTR_MSG_SMP_PASSTHROUGH_REPLY,
+  SmpPassthroughReply_t, MPI_POINTER pSmpPassthroughReply_t;
+
+#define MPI_SMP_PT_REPLY_PT_FLAGS_IMMEDIATE     (0x80)
+
+
+/****************************************************************************/
+/* SATA Passthrough Request                                                 */
+/****************************************************************************/
+
+typedef struct _MSG_SATA_PASSTHROUGH_REQUEST
+{
+    U8                      TargetID;           /* 00h */
+    U8                      Bus;                /* 01h */
+    U8                      ChainOffset;        /* 02h */
+    U8                      Function;           /* 03h */
+    U16                     PassthroughFlags;   /* 04h */
+    U8                      ConnectionRate;     /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U32                     Reserved1;          /* 0Ch */
+    U32                     Reserved2;          /* 10h */
+    U32                     Reserved3;          /* 14h */
+    U32                     DataLength;         /* 18h */
+    U8                      CommandFIS[20];     /* 1Ch */
+    SGE_SIMPLE_UNION        SGL;                /* 30h */
+} MSG_SATA_PASSTHROUGH_REQUEST, MPI_POINTER PTR_MSG_SATA_PASSTHROUGH_REQUEST,
+  SataPassthroughRequest_t, MPI_POINTER pSataPassthroughRequest_t;
+
+/* values for PassthroughFlags field */
+#define MPI_SATA_PT_REQ_PT_FLAGS_RESET_DEVICE   (0x0200)
+#define MPI_SATA_PT_REQ_PT_FLAGS_EXECUTE_DIAG   (0x0100)
+#define MPI_SATA_PT_REQ_PT_FLAGS_DMA_QUEUED     (0x0080)
+#define MPI_SATA_PT_REQ_PT_FLAGS_PACKET_COMMAND (0x0040)
+#define MPI_SATA_PT_REQ_PT_FLAGS_DMA            (0x0020)
+#define MPI_SATA_PT_REQ_PT_FLAGS_PIO            (0x0010)
+#define MPI_SATA_PT_REQ_PT_FLAGS_UNSPECIFIED_VU (0x0004)
+#define MPI_SATA_PT_REQ_PT_FLAGS_WRITE          (0x0002)
+#define MPI_SATA_PT_REQ_PT_FLAGS_READ           (0x0001)
+
+/* values for ConnectionRate field */
+#define MPI_SATA_PT_REQ_CONNECT_RATE_NEGOTIATED (0x00)
+#define MPI_SATA_PT_REQ_CONNECT_RATE_1_5        (0x08)
+#define MPI_SATA_PT_REQ_CONNECT_RATE_3_0        (0x09)
+
+
+/* SATA Passthrough Reply */
+typedef struct _MSG_SATA_PASSTHROUGH_REPLY
+{
+    U8                      TargetID;           /* 00h */
+    U8                      Bus;                /* 01h */
+    U8                      MsgLength;          /* 02h */
+    U8                      Function;           /* 03h */
+    U16                     PassthroughFlags;   /* 04h */
+    U8                      Reserved1;          /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U8                      Reserved2;          /* 0Ch */
+    U8                      SASStatus;          /* 0Dh */
+    U16                     IOCStatus;          /* 0Eh */
+    U32                     IOCLogInfo;         /* 10h */
+    U8                      StatusFIS[20];      /* 14h */
+    U32                     StatusControlRegisters; /* 28h */
+    U32                     TransferCount;      /* 2Ch */
+} MSG_SATA_PASSTHROUGH_REPLY, MPI_POINTER PTR_MSG_SATA_PASSTHROUGH_REPLY,
+  SataPassthroughReply_t, MPI_POINTER pSataPassthroughReply_t;
+
+
+
+
+/****************************************************************************/
+/* SAS IO Unit Control Request                                              */
+/****************************************************************************/
+
+typedef struct _MSG_SAS_IOUNIT_CONTROL_REQUEST
+{
+    U8                      Operation;          /* 00h */
+    U8                      Reserved1;          /* 01h */
+    U8                      ChainOffset;        /* 02h */
+    U8                      Function;           /* 03h */
+    U16                     Reserved2;          /* 04h */
+    U8                      Reserved3;          /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U8                      TargetID;           /* 0Ch */
+    U8                      Bus;                /* 0Dh */
+    U8                      PhyNum;             /* 0Eh */
+    U8                      Reserved4;          /* 0Fh */
+    U32                     Reserved5;          /* 10h */
+    U64                     SASAddress;         /* 14h */
+    U32                     Reserved6;          /* 1Ch */
+} MSG_SAS_IOUNIT_CONTROL_REQUEST, MPI_POINTER PTR_MSG_SAS_IOUNIT_CONTROL_REQUEST,
+  SasIoUnitControlRequest_t, MPI_POINTER pSasIoUnitControlRequest_t;
+
+/* values for the Operation field */
+#define MPI_SAS_OP_CLEAR_NOT_PRESENT             (0x01)
+#define MPI_SAS_OP_CLEAR_ALL_PERSISTENT          (0x02)
+#define MPI_SAS_OP_PHY_LINK_RESET                (0x06)
+#define MPI_SAS_OP_PHY_HARD_RESET                (0x07)
+#define MPI_SAS_OP_PHY_CLEAR_ERROR_LOG           (0x08)
+#define MPI_SAS_OP_MAP_CURRENT                   (0x09)
+
+
+/* SAS IO Unit Control Reply */
+typedef struct _MSG_SAS_IOUNIT_CONTROL_REPLY
+{
+    U8                      Operation;          /* 00h */
+    U8                      Reserved1;          /* 01h */
+    U8                      MsgLength;          /* 02h */
+    U8                      Function;           /* 03h */
+    U16                     Reserved2;          /* 04h */
+    U8                      Reserved3;          /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U16                     Reserved4;          /* 0Ch */
+    U16                     IOCStatus;          /* 0Eh */
+    U32                     IOCLogInfo;         /* 10h */
+} MSG_SAS_IOUNIT_CONTROL_REPLY, MPI_POINTER PTR_MSG_SAS_IOUNIT_CONTROL_REPLY,
+  SasIoUnitControlReply_t, MPI_POINTER pSasIoUnitControlReply_t;
+
+#endif
+
+
diff -urNp linux-8145/drivers/message/fusion/lsi/mpi_targ.h linux-8150/drivers/message/fusion/lsi/mpi_targ.h
--- linux-8145/drivers/message/fusion/lsi/mpi_targ.h
+++ linux-8150/drivers/message/fusion/lsi/mpi_targ.h
@@ -1,12 +1,12 @@
 /*
- *  Copyright (c) 2000-2002 LSI Logic Corporation.
+ *  Copyright (c) 2000-2004 LSI Logic Corporation.
  *
  *
- *           Name:  MPI_TARG.H
+ *           Name:  mpi_targ.h
  *          Title:  MPI Target mode messages and structures
  *  Creation Date:  June 22, 2000
  *
- *    MPI_TARG.H Version:  01.02.07
+ *    mpi_targ.h Version:  01.05.04
  *
  *  Version History
  *  ---------------
@@ -41,6 +41,18 @@
  *                      Added AliasIndex field to MPI_TARGET_FCP_CMD_BUFFER.
  *  09-16-02  01.02.07  Added flags for confirmed completion.
  *                      Added PRIORITY_REASON_TARGET_BUSY.
+ *  11-15-02  01.02.08  Added AliasID field to MPI_TARGET_SCSI_SPI_CMD_BUFFER.
+ *  04-01-03  01.02.09  Added OptionalOxid field to MPI_TARGET_FCP_CMD_BUFFER.
+ *  05-11-04  01.03.01  Original release for MPI v1.3.
+ *  08-19-04  01.05.01  Added new request message structures for
+ *                      MSG_TARGET_CMD_BUF_POST_BASE_REQUEST,
+ *                      MSG_TARGET_CMD_BUF_POST_LIST_REQUEST, and
+ *                      MSG_TARGET_ASSIST_EXT_REQUEST.
+ *                      Added new structures for SAS SSP Command buffer, SSP
+ *                      Task buffer, and SSP Status IU.
+ *  10-05-04  01.05.02  MSG_TARGET_CMD_BUFFER_POST_BASE_LIST_REPLY added.
+ *  02-22-05  01.05.03  Changed a comment.
+ *  03-11-05  01.05.04  Removed TargetAssistExtended Request.
  *  --------------------------------------------------------------------------
  */
 
@@ -131,6 +143,25 @@ typedef struct _MSG_PRIORITY_CMD_RECEIVE
 } MSG_PRIORITY_CMD_RECEIVED_REPLY, MPI_POINTER PTR_MSG_PRIORITY_CMD_RECEIVED_REPLY,
   PriorityCommandReceivedReply_t, MPI_POINTER pPriorityCommandReceivedReply_t;
 
+
+typedef struct _MSG_TARGET_CMD_BUFFER_POST_ERROR_REPLY
+{
+    U16                     Reserved;                   /* 00h */
+    U8                      MsgLength;                  /* 02h */
+    U8                      Function;                   /* 03h */
+    U16                     Reserved1;                  /* 04h */
+    U8                      Reserved2;                  /* 06h */
+    U8                      MsgFlags;                   /* 07h */
+    U32                     MsgContext;                 /* 08h */
+    U8                      PriorityReason;             /* 0Ch */
+    U8                      Reserved3;                  /* 0Dh */
+    U16                     IOCStatus;                  /* 0Eh */
+    U32                     IOCLogInfo;                 /* 10h */
+    U32                     ReplyWord;                  /* 14h */
+} MSG_TARGET_CMD_BUFFER_POST_ERROR_REPLY,
+  MPI_POINTER PTR_MSG_TARGET_CMD_BUFFER_POST_ERROR_REPLY,
+  TargetCmdBufferPostErrorReply_t, MPI_POINTER pTargetCmdBufferPostErrorReply_t;
+
 #define PRIORITY_REASON_NO_DISCONNECT           (0x00)
 #define PRIORITY_REASON_SCSI_TASK_MANAGEMENT    (0x01)
 #define PRIORITY_REASON_CMD_PARITY_ERR          (0x02)
@@ -144,7 +175,34 @@ typedef struct _MSG_PRIORITY_CMD_RECEIVE
 #define PRIORITY_REASON_UNKNOWN                 (0xFF)
 
 
-typedef struct _MSG_TARGET_CMD_BUFFER_POST_ERROR_REPLY
+/****************************************************************************/
+/* Target Command Buffer Post Base Request                                  */
+/****************************************************************************/
+
+typedef struct _MSG_TARGET_CMD_BUF_POST_BASE_REQUEST
+{
+    U8                      BufferPostFlags;            /* 00h */
+    U8                      PortNumber;                 /* 01h */
+    U8                      ChainOffset;                /* 02h */
+    U8                      Function;                   /* 03h */
+    U16                     TotalCmdBuffers;            /* 04h */
+    U8                      Reserved;                   /* 06h */
+    U8                      MsgFlags;                   /* 07h */
+    U32                     MsgContext;                 /* 08h */
+    U32                     Reserved1;                  /* 0Ch */
+    U16                     CmdBufferLength;            /* 10h */
+    U16                     NextCmdBufferOffset;        /* 12h */
+    U32                     BaseAddressLow;             /* 14h */
+    U32                     BaseAddressHigh;            /* 18h */
+} MSG_TARGET_CMD_BUF_POST_BASE_REQUEST,
+  MPI_POINTER PTR__MSG_TARGET_CMD_BUF_POST_BASE_REQUEST,
+  TargetCmdBufferPostBaseRequest_t,
+  MPI_POINTER pTargetCmdBufferPostBaseRequest_t;
+
+#define CMD_BUFFER_POST_BASE_FLAGS_AUTO_POST_ALL    (0x01)
+
+
+typedef struct _MSG_TARGET_CMD_BUFFER_POST_BASE_LIST_REPLY
 {
     U16                     Reserved;                   /* 00h */
     U8                      MsgLength;                  /* 02h */
@@ -153,16 +211,41 @@ typedef struct _MSG_TARGET_CMD_BUFFER_PO
     U8                      Reserved2;                  /* 06h */
     U8                      MsgFlags;                   /* 07h */
     U32                     MsgContext;                 /* 08h */
-    U8                      PriorityReason;             /* 0Ch */
-    U8                      Reserved3;                  /* 0Dh */
+    U16                     Reserved3;                  /* 0Ch */
     U16                     IOCStatus;                  /* 0Eh */
     U32                     IOCLogInfo;                 /* 10h */
-    U32                     ReplyWord;                  /* 14h */
-} MSG_TARGET_CMD_BUFFER_POST_ERROR_REPLY,
-  MPI_POINTER PTR_MSG_TARGET_CMD_BUFFER_POST_ERROR_REPLY,
-  TargetCmdBufferPostErrorReply_t, MPI_POINTER pTargetCmdBufferPostErrorReply_t;
+} MSG_TARGET_CMD_BUFFER_POST_BASE_LIST_REPLY,
+  MPI_POINTER PTR_MSG_TARGET_CMD_BUFFER_POST_BASE_LIST_REPLY,
+  TargetCmdBufferPostBaseListReply_t,
+  MPI_POINTER pTargetCmdBufferPostBaseListReply_t;
+
+
+/****************************************************************************/
+/* Target Command Buffer Post List Request                                  */
+/****************************************************************************/
+
+typedef struct _MSG_TARGET_CMD_BUF_POST_LIST_REQUEST
+{
+    U8                      Reserved;                   /* 00h */
+    U8                      PortNumber;                 /* 01h */
+    U8                      ChainOffset;                /* 02h */
+    U8                      Function;                   /* 03h */
+    U16                     CmdBufferCount;             /* 04h */
+    U8                      Reserved1;                  /* 06h */
+    U8                      MsgFlags;                   /* 07h */
+    U32                     MsgContext;                 /* 08h */
+    U32                     Reserved2;                  /* 0Ch */
+    U16                     IoIndex[2];                 /* 10h */
+} MSG_TARGET_CMD_BUF_POST_LIST_REQUEST,
+  MPI_POINTER PTR_MSG_TARGET_CMD_BUF_POST_LIST_REQUEST,
+  TargetCmdBufferPostListRequest_t,
+  MPI_POINTER pTargetCmdBufferPostListRequest_t;
 
 
+/****************************************************************************/
+/* Command Buffer Formats (with 16 byte CDB)                                */
+/****************************************************************************/
+
 typedef struct _MPI_TARGET_FCP_CMD_BUFFER
 {
     U8      FcpLun[8];                                  /* 00h */
@@ -171,7 +254,7 @@ typedef struct _MPI_TARGET_FCP_CMD_BUFFE
     U32     FcpDl;                                      /* 1Ch */
     U8      AliasIndex;                                 /* 20h */
     U8      Reserved1;                                  /* 21h */
-    U16     Reserved2;                                  /* 22h */
+    U16     OptionalOxid;                               /* 22h */
 } MPI_TARGET_FCP_CMD_BUFFER, MPI_POINTER PTR_MPI_TARGET_FCP_CMD_BUFFER,
   MpiTargetFcpCmdBuffer, MPI_POINTER pMpiTargetFcpCmdBuffer;
 
@@ -190,11 +273,55 @@ typedef struct _MPI_TARGET_SCSI_SPI_CMD_
     U8      TaskManagementFlags;                        /* 12h */
     U8      AdditionalCDBLength;                        /* 13h */
     U8      CDB[16];                                    /* 14h */
+    /* Alias ID */
+    U8      AliasID;                                    /* 24h */
+    U8      Reserved1;                                  /* 25h */
+    U16     Reserved2;                                  /* 26h */
 } MPI_TARGET_SCSI_SPI_CMD_BUFFER,
   MPI_POINTER PTR_MPI_TARGET_SCSI_SPI_CMD_BUFFER,
   MpiTargetScsiSpiCmdBuffer, MPI_POINTER pMpiTargetScsiSpiCmdBuffer;
 
 
+typedef struct _MPI_TARGET_SSP_CMD_BUFFER
+{
+    U8      FrameType;                                  /* 00h */
+    U8      Reserved1;                                  /* 01h */
+    U16     Reserved2;                                  /* 02h */
+    U16     InitiatorTag;                               /* 04h */
+    U16     DevHandle;                                  /* 06h */
+    /* COMMAND information unit starts here */
+    U8      LogicalUnitNumber[8];                       /* 08h */
+    U8      Reserved3;                                  /* 10h */
+    U8      TaskAttribute; /* lower 3 bits */           /* 11h */
+    U8      Reserved4;                                  /* 12h */
+    U8      AdditionalCDBLength; /* upper 5 bits */     /* 13h */
+    U8      CDB[16];                                    /* 14h */
+    /* Additional CDB bytes extend past the CDB field */
+} MPI_TARGET_SSP_CMD_BUFFER, MPI_POINTER PTR_MPI_TARGET_SSP_CMD_BUFFER,
+  MpiTargetSspCmdBuffer, MPI_POINTER pMpiTargetSspCmdBuffer;
+
+typedef struct _MPI_TARGET_SSP_TASK_BUFFER
+{
+    U8      FrameType;                                  /* 00h */
+    U8      Reserved1;                                  /* 01h */
+    U16     Reserved2;                                  /* 02h */
+    U16     InitiatorTag;                               /* 04h */
+    U16     DevHandle;                                  /* 06h */
+    /* TASK information unit starts here */
+    U8      LogicalUnitNumber[8];                       /* 08h */
+    U8      Reserved3;                                  /* 10h */
+    U8      Reserved4;                                  /* 11h */
+    U8      TaskManagementFunction;                     /* 12h */
+    U8      Reserved5;                                  /* 13h */
+    U16     ManagedTaskTag;                             /* 14h */
+    U16     Reserved6;                                  /* 16h */
+    U32     Reserved7;                                  /* 18h */
+    U32     Reserved8;                                  /* 1Ch */
+    U32     Reserved9;                                  /* 20h */
+} MPI_TARGET_SSP_TASK_BUFFER, MPI_POINTER PTR_MPI_TARGET_SSP_TASK_BUFFER,
+  MpiTargetSspTaskBuffer, MPI_POINTER pMpiTargetSspTaskBuffer;
+
+
 /****************************************************************************/
 /* Target Assist Request                                                    */
 /****************************************************************************/
@@ -302,6 +429,27 @@ typedef struct _MPI_TARGET_SCSI_SPI_STAT
 } MPI_TARGET_SCSI_SPI_STATUS_IU, MPI_POINTER PTR_MPI_TARGET_SCSI_SPI_STATUS_IU,
   TargetScsiSpiStatusIU_t, MPI_POINTER pTargetScsiSpiStatusIU_t;
 
+/*
+ * NOTE: The SSP status IU is big-endian. When used on a little-endian system,
+ * this structure properly orders the bytes.
+ */
+typedef struct _MPI_TARGET_SSP_RSP_IU
+{
+    U32     Reserved0[6]; /* reserved for SSP header */ /* 00h */
+    /* start of RESPONSE information unit */
+    U32     Reserved1;                                  /* 18h */
+    U32     Reserved2;                                  /* 1Ch */
+    U16     Reserved3;                                  /* 20h */
+    U8      DataPres; /* lower 2 bits */                /* 22h */
+    U8      Status;                                     /* 23h */
+    U32     Reserved4;                                  /* 24h */
+    U32     SenseDataLength;                            /* 28h */
+    U32     ResponseDataLength;                         /* 2Ch */
+    U8      ResponseSenseData[4];                       /* 30h */
+} MPI_TARGET_SSP_RSP_IU, MPI_POINTER PTR_MPI_TARGET_SSP_RSP_IU,
+  MpiTargetSspRspIu_t, MPI_POINTER pMpiTargetSspRspIu_t;
+
+
 /****************************************************************************/
 /* Target Mode Abort Request                                                */
 /****************************************************************************/
diff -urNp linux-8145/drivers/message/fusion/lsi/mpi_tool.h linux-8150/drivers/message/fusion/lsi/mpi_tool.h
--- linux-8145/drivers/message/fusion/lsi/mpi_tool.h
+++ linux-8150/drivers/message/fusion/lsi/mpi_tool.h
@@ -1,12 +1,12 @@
 /*
- *  Copyright (c) 2001 LSI Logic Corporation.
+ *  Copyright (c) 2001-2005 LSI Logic Corporation.
  *
  *
- *           Name:  MPI_TOOL.H
+ *           Name:  mpi_tool.h
  *          Title:  MPI Toolbox structures and definitions
  *  Creation Date:  July 30, 2001
  *
- *    MPI Version:  01.02.02
+ *    mpi_tool.h Version:  01.05.03
  *
  *  Version History
  *  ---------------
@@ -15,6 +15,16 @@
  *  --------  --------  ------------------------------------------------------
  *  08-08-01  01.02.01  Original release.
  *  08-29-01  01.02.02  Added DIAG_DATA_UPLOAD_HEADER and related defines.
+ *  01-16-04  01.02.03  Added defines and structures for new tools
+ *.                     MPI_TOOLBOX_ISTWI_READ_WRITE_TOOL and
+ *                      MPI_TOOLBOX_FC_MANAGEMENT_TOOL.
+ *  04-29-04  01.02.04  Added message structures for Diagnostic Buffer Post and
+ *                      Diagnostic Release requests and replies.
+ *  05-11-04  01.03.01  Original release for MPI v1.3.
+ *  08-19-04  01.05.01  Original release for MPI v1.5.
+ *  10-06-04  01.05.02  Added define for MPI_DIAG_BUF_TYPE_COUNT.
+ *  02-09-05  01.05.03  Added frame size option to FC management tool.
+ *                      Added Beacon tool to the Toolbox.
  *  --------------------------------------------------------------------------
  */
 
@@ -24,6 +34,9 @@
 #define MPI_TOOLBOX_CLEAN_TOOL                      (0x00)
 #define MPI_TOOLBOX_MEMORY_MOVE_TOOL                (0x01)
 #define MPI_TOOLBOX_DIAG_DATA_UPLOAD_TOOL           (0x02)
+#define MPI_TOOLBOX_ISTWI_READ_WRITE_TOOL           (0x03)
+#define MPI_TOOLBOX_FC_MANAGEMENT_TOOL              (0x04)
+#define MPI_TOOLBOX_BEACON_TOOL                     (0x05)
 
 
 /****************************************************************************/
@@ -68,6 +81,12 @@ typedef struct _MSG_TOOLBOX_CLEAN_REQUES
 #define MPI_TOOLBOX_CLEAN_NVSRAM                    (0x00000001)
 #define MPI_TOOLBOX_CLEAN_SEEPROM                   (0x00000002)
 #define MPI_TOOLBOX_CLEAN_FLASH                     (0x00000004)
+#define MPI_TOOLBOX_CLEAN_BOOTLOADER                (0x04000000)
+#define MPI_TOOLBOX_CLEAN_FW_BACKUP                 (0x08000000)
+#define MPI_TOOLBOX_CLEAN_FW_CURRENT                (0x10000000)
+#define MPI_TOOLBOX_CLEAN_OTHER_PERSIST_PAGES       (0x20000000)
+#define MPI_TOOLBOX_CLEAN_PERSIST_MANUFACT_PAGES    (0x40000000)
+#define MPI_TOOLBOX_CLEAN_BOOT_SERVICES             (0x80000000)
 
 
 /****************************************************************************/
@@ -124,6 +143,212 @@ typedef struct _DIAG_DATA_UPLOAD_HEADER
 #define MPI_TB_DIAG_FORMAT_FC_TRACE_1               (0x04)
 
 
+/****************************************************************************/
+/* Toolbox ISTWI Read Write request                                         */
+/****************************************************************************/
+
+typedef struct _MSG_TOOLBOX_ISTWI_READ_WRITE_REQUEST
+{
+    U8                      Tool;                       /* 00h */
+    U8                      Reserved;                   /* 01h */
+    U8                      ChainOffset;                /* 02h */
+    U8                      Function;                   /* 03h */
+    U16                     Reserved1;                  /* 04h */
+    U8                      Reserved2;                  /* 06h */
+    U8                      MsgFlags;                   /* 07h */
+    U32                     MsgContext;                 /* 08h */
+    U8                      Flags;                      /* 0Ch */
+    U8                      BusNum;                     /* 0Dh */
+    U16                     Reserved3;                  /* 0Eh */
+    U8                      NumAddressBytes;            /* 10h */
+    U8                      Reserved4;                  /* 11h */
+    U16                     DataLength;                 /* 12h */
+    U8                      DeviceAddr;                 /* 14h */
+    U8                      Addr1;                      /* 15h */
+    U8                      Addr2;                      /* 16h */
+    U8                      Addr3;                      /* 17h */
+    U32                     Reserved5;                  /* 18h */
+    SGE_SIMPLE_UNION        SGL;                        /* 1Ch */
+} MSG_TOOLBOX_ISTWI_READ_WRITE_REQUEST, MPI_POINTER PTR_MSG_TOOLBOX_ISTWI_READ_WRITE_REQUEST,
+  ToolboxIstwiReadWriteRequest_t, MPI_POINTER pToolboxIstwiReadWriteRequest_t;
+
+#define MPI_TB_ISTWI_FLAGS_WRITE                    (0x00)
+#define MPI_TB_ISTWI_FLAGS_READ                     (0x01)
+
+
+/****************************************************************************/
+/* Toolbox FC Management request                                            */
+/****************************************************************************/
+
+/* ActionInfo for Bus and TargetId */
+typedef struct _MPI_TB_FC_MANAGE_BUS_TID_AI
+{
+    U16                     Reserved;                   /* 00h */
+    U8                      Bus;                        /* 02h */
+    U8                      TargetId;                   /* 03h */
+} MPI_TB_FC_MANAGE_BUS_TID_AI, MPI_POINTER PTR_MPI_TB_FC_MANAGE_BUS_TID_AI,
+  MpiTbFcManageBusTidAi_t, MPI_POINTER pMpiTbFcManageBusTidAi_t;
+
+/* ActionInfo for port identifier */
+typedef struct _MPI_TB_FC_MANAGE_PID_AI
+{
+    U32                     PortIdentifier;             /* 00h */
+} MPI_TB_FC_MANAGE_PID_AI, MPI_POINTER PTR_MPI_TB_FC_MANAGE_PID_AI,
+  MpiTbFcManagePidAi_t, MPI_POINTER pMpiTbFcManagePidAi_t;
+
+/* ActionInfo for set max frame size */
+typedef struct _MPI_TB_FC_MANAGE_FRAME_SIZE_AI
+{
+    U16                     FrameSize;                  /* 00h */
+    U8                      PortNum;                    /* 02h */
+    U8                      Reserved1;                  /* 03h */
+} MPI_TB_FC_MANAGE_FRAME_SIZE_AI, MPI_POINTER PTR_MPI_TB_FC_MANAGE_FRAME_SIZE_AI,
+  MpiTbFcManageFrameSizeAi_t, MPI_POINTER pMpiTbFcManageFrameSizeAi_t;
+
+/* union of ActionInfo */
+typedef union _MPI_TB_FC_MANAGE_AI_UNION
+{
+    MPI_TB_FC_MANAGE_BUS_TID_AI     BusTid;
+    MPI_TB_FC_MANAGE_PID_AI         Port;
+    MPI_TB_FC_MANAGE_FRAME_SIZE_AI  FrameSize;
+} MPI_TB_FC_MANAGE_AI_UNION, MPI_POINTER PTR_MPI_TB_FC_MANAGE_AI_UNION,
+  MpiTbFcManageAiUnion_t, MPI_POINTER pMpiTbFcManageAiUnion_t;
+
+typedef struct _MSG_TOOLBOX_FC_MANAGE_REQUEST
+{
+    U8                          Tool;                   /* 00h */
+    U8                          Reserved;               /* 01h */
+    U8                          ChainOffset;            /* 02h */
+    U8                          Function;               /* 03h */
+    U16                         Reserved1;              /* 04h */
+    U8                          Reserved2;              /* 06h */
+    U8                          MsgFlags;               /* 07h */
+    U32                         MsgContext;             /* 08h */
+    U8                          Action;                 /* 0Ch */
+    U8                          Reserved3;              /* 0Dh */
+    U16                         Reserved4;              /* 0Eh */
+    MPI_TB_FC_MANAGE_AI_UNION   ActionInfo;             /* 10h */
+} MSG_TOOLBOX_FC_MANAGE_REQUEST, MPI_POINTER PTR_MSG_TOOLBOX_FC_MANAGE_REQUEST,
+  ToolboxFcManageRequest_t, MPI_POINTER pToolboxFcManageRequest_t;
+
+/* defines for the Action field */
+#define MPI_TB_FC_MANAGE_ACTION_DISC_ALL            (0x00)
+#define MPI_TB_FC_MANAGE_ACTION_DISC_PID            (0x01)
+#define MPI_TB_FC_MANAGE_ACTION_DISC_BUS_TID        (0x02)
+#define MPI_TB_FC_MANAGE_ACTION_SET_MAX_FRAME_SIZE  (0x03)
+
+
+/****************************************************************************/
+/* Toolbox Beacon Tool request                                               */
+/****************************************************************************/
+
+typedef struct _MSG_TOOLBOX_BEACON_REQUEST
+{
+    U8                      Tool;                       /* 00h */
+    U8                      Reserved;                   /* 01h */
+    U8                      ChainOffset;                /* 02h */
+    U8                      Function;                   /* 03h */
+    U16                     Reserved1;                  /* 04h */
+    U8                      Reserved2;                  /* 06h */
+    U8                      MsgFlags;                   /* 07h */
+    U32                     MsgContext;                 /* 08h */
+    U8                      ConnectNum;                 /* 0Ch */
+    U8                      PortNum;                    /* 0Dh */
+    U8                      Reserved3;                  /* 0Eh */
+    U8                      Flags;                      /* 0Fh */
+} MSG_TOOLBOX_BEACON_REQUEST, MPI_POINTER PTR_MSG_TOOLBOX_BEACON_REQUEST,
+  ToolboxBeaconRequest_t, MPI_POINTER pToolboxBeaconRequest_t;
+
+#define MPI_TOOLBOX_FLAGS_BEACON_MODE_OFF       (0x00)
+#define MPI_TOOLBOX_FLAGS_BEACON_MODE_ON        (0x01)
+
+
+/****************************************************************************/
+/* Diagnostic Buffer Post request                                           */
+/****************************************************************************/
+
+typedef struct _MSG_DIAG_BUFFER_POST_REQUEST
+{
+    U8                      TraceLevel;                 /* 00h */
+    U8                      BufferType;                 /* 01h */
+    U8                      ChainOffset;                /* 02h */
+    U8                      Function;                   /* 03h */
+    U16                     Reserved1;                  /* 04h */
+    U8                      Reserved2;                  /* 06h */
+    U8                      MsgFlags;                   /* 07h */
+    U32                     MsgContext;                 /* 08h */
+    U32                     ExtendedType;               /* 0Ch */
+    U32                     BufferLength;               /* 10h */
+    U32                     ProductSpecific[4];         /* 14h */
+    U32                     Reserved3;                  /* 24h */
+    U64                     BufferAddress;              /* 28h */
+} MSG_DIAG_BUFFER_POST_REQUEST, MPI_POINTER PTR_MSG_DIAG_BUFFER_POST_REQUEST,
+  DiagBufferPostRequest_t, MPI_POINTER pDiagBufferPostRequest_t;
+
+#define MPI_DIAG_BUF_TYPE_TRACE                     (0x00)
+#define MPI_DIAG_BUF_TYPE_SNAPSHOT                  (0x01)
+#define MPI_DIAG_BUF_TYPE_EXTENDED                  (0x02)
+/* count of the number of buffer types */
+#define MPI_DIAG_BUF_TYPE_COUNT                     (0x03)
+
+#define MPI_DIAG_EXTENDED_QTAG                      (0x00000001)
+
+
+/* Diagnostic Buffer Post reply */
+typedef struct _MSG_DIAG_BUFFER_POST_REPLY
+{
+    U8                      Reserved1;                  /* 00h */
+    U8                      BufferType;                 /* 01h */
+    U8                      MsgLength;                  /* 02h */
+    U8                      Function;                   /* 03h */
+    U16                     Reserved2;                  /* 04h */
+    U8                      Reserved3;                  /* 06h */
+    U8                      MsgFlags;                   /* 07h */
+    U32                     MsgContext;                 /* 08h */
+    U16                     Reserved4;                  /* 0Ch */
+    U16                     IOCStatus;                  /* 0Eh */
+    U32                     IOCLogInfo;                 /* 10h */
+    U32                     TransferLength;             /* 14h */
+} MSG_DIAG_BUFFER_POST_REPLY, MPI_POINTER PTR_MSG_DIAG_BUFFER_POST_REPLY,
+  DiagBufferPostReply_t, MPI_POINTER pDiagBufferPostReply_t;
+
+
+/****************************************************************************/
+/* Diagnostic Release request                                               */
+/****************************************************************************/
+
+typedef struct _MSG_DIAG_RELEASE_REQUEST
+{
+    U8                      Reserved1;                  /* 00h */
+    U8                      BufferType;                 /* 01h */
+    U8                      ChainOffset;                /* 02h */
+    U8                      Function;                   /* 03h */
+    U16                     Reserved2;                  /* 04h */
+    U8                      Reserved3;                  /* 06h */
+    U8                      MsgFlags;                   /* 07h */
+    U32                     MsgContext;                 /* 08h */
+} MSG_DIAG_RELEASE_REQUEST, MPI_POINTER PTR_MSG_DIAG_RELEASE_REQUEST,
+  DiagReleaseRequest_t, MPI_POINTER pDiagReleaseRequest_t;
+
+
+/* Diagnostic Release reply */
+typedef struct _MSG_DIAG_RELEASE_REPLY
+{
+    U8                      Reserved1;                  /* 00h */
+    U8                      BufferType;                 /* 01h */
+    U8                      MsgLength;                  /* 02h */
+    U8                      Function;                   /* 03h */
+    U16                     Reserved2;                  /* 04h */
+    U8                      Reserved3;                  /* 06h */
+    U8                      MsgFlags;                   /* 07h */
+    U32                     MsgContext;                 /* 08h */
+    U16                     Reserved4;                  /* 0Ch */
+    U16                     IOCStatus;                  /* 0Eh */
+    U32                     IOCLogInfo;                 /* 10h */
+} MSG_DIAG_RELEASE_REPLY, MPI_POINTER PTR_MSG_DIAG_RELEASE_REPLY,
+  DiagReleaseReply_t, MPI_POINTER pDiagReleaseReply_t;
+
+
 #endif
 
 
diff -urNp linux-8145/drivers/message/fusion/lsi/mpi_type.h linux-8150/drivers/message/fusion/lsi/mpi_type.h
--- linux-8145/drivers/message/fusion/lsi/mpi_type.h
+++ linux-8150/drivers/message/fusion/lsi/mpi_type.h
@@ -1,12 +1,12 @@
 /*
- *  Copyright (c) 2000-2002 LSI Logic Corporation.
+ *  Copyright (c) 2000-2004 LSI Logic Corporation.
  *
  *
- *           Name:  MPI_TYPE.H
+ *           Name:  mpi_type.h
  *          Title:  MPI Basic type definitions
  *  Creation Date:  June 6, 2000
  *
- *    MPI Version:  01.02.01
+ *    mpi_type.h Version:  01.05.01
  *
  *  Version History
  *  ---------------
@@ -18,6 +18,8 @@
  *  11-02-00  01.01.01  Original release for post 1.0 work
  *  02-20-01  01.01.02  Added define and ifdef for MPI_POINTER.
  *  08-08-01  01.02.01  Original release for v1.2 work.
+ *  05-11-04  01.03.01  Original release for MPI v1.3.
+ *  08-19-04  01.05.01  Original release for MPI v1.5.
  *  --------------------------------------------------------------------------
  */
 
diff -urNp linux-8145/drivers/message/fusion/mptbase.c linux-8150/drivers/message/fusion/mptbase.c
--- linux-8145/drivers/message/fusion/mptbase.c
+++ linux-8150/drivers/message/fusion/mptbase.c
@@ -1,55 +1,15 @@
 /*
  *  linux/drivers/message/fusion/mptbase.c
- *      High performance SCSI + LAN / Fibre Channel device drivers.
  *      This is the Fusion MPT base driver which supports multiple
  *      (SCSI + LAN) specialized protocol drivers.
- *      For use with PCI chip/adapter(s):
- *          LSIFC9xx/LSI409xx Fibre Channel
+ *      For use with LSI Logic PCI chip/adapter(s)
  *      running LSI Logic Fusion MPT (Message Passing Technology) firmware.
  *
- *  Credits:
- *      There are lots of people not mentioned below that deserve credit
- *      and thanks but won't get it here - sorry in advance that you
- *      got overlooked.
- *
- *      This driver would not exist if not for Alan Cox's development
- *      of the linux i2o driver.
- *
- *      A special thanks to Noah Romer (LSI Logic) for tons of work
- *      and tough debugging on the LAN driver, especially early on;-)
- *      And to Roger Hickerson (LSI Logic) for tirelessly supporting
- *      this driver project.
- *
- *      A special thanks to Pamela Delaney (LSI Logic) for tons of work
- *      and countless enhancements while adding support for the 1030
- *      chip family.  Pam has been instrumental in the development of
- *      of the 2.xx.xx series fusion drivers, and her contributions are
- *      far too numerous to hope to list in one place.
- *
- *      All manner of help from Stephen Shirron (LSI Logic):
- *      low-level FC analysis, debug + various fixes in FCxx firmware,
- *      initial port to alpha platform, various driver code optimizations,
- *      being a faithful sounding board on all sorts of issues & ideas,
- *      etc.
- *
- *      A huge debt of gratitude is owed to David S. Miller (DaveM)
- *      for fixing much of the stupid and broken stuff in the early
- *      driver while porting to sparc64 platform.  THANK YOU!
- *
- *      Special thanks goes to the I2O LAN driver people at the
- *      University of Helsinki, who, unbeknownst to them, provided
- *      the inspiration and initial structure for this driver.
- *
- *      A really huge debt of gratitude is owed to Eddie C. Dost
- *      for gobs of hard work fixing and optimizing LAN code.
- *      THANK YOU!
- *
- *  Copyright (c) 1999-2002 LSI Logic Corporation
- *  Originally By: Steven J. Ralston
- *  (mailto:sjralston1@netscape.net)
- *  (mailto:lstephen@lsil.com)
+ *  Copyright (c) 1999-2005 LSI Logic Corporation
+ *  (mailto:mpt_linux_developer@lsil.com)
+ *  For support, send a description of issues to: support@lsil.com.
  *
- *  $Id: mptbase.c,v 1.126 2002/12/16 15:28:45 pdelaney Exp $
+ *  $Id: mptbase.c,v 1.130 2003/05/07 14:08:30 Exp $
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -109,6 +69,7 @@
 #include <asm/irq.h>			/* needed for __irq_itoa() proto */
 #endif
 
+#include "linux_compat.h"	/* linux-2.2.x (vs. -2.4.x) tweaks */
 #include "mptbase.h"
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -123,14 +84,32 @@ MODULE_LICENSE("GPL");
 /*
  *  cmd line parameters
  */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,59)
 MODULE_PARM(PortIo, "0-1i");
 MODULE_PARM_DESC(PortIo, "[0]=Use mmap, 1=Use port io");
+#endif
 static int PortIo = 0;
 
-#ifdef MFCNT
-static int mfcounter = 0;
-#define PRINT_MF_COUNT 20000
-#endif
+/* Get command line arguments */
+	/* Evaluate the command line arguments, if any.
+	 * Example with loadable module:
+insmod mptbase mpt_sg_tablesize=200 mpt_can_queue=1000
+	 * Example with boot:  add an option line in /etc/modules.conf
+options mptbase mpt_sg_tablesize=200 mpt_can_queue=1000
+	 */
+char *mptbase = NULL;
+int mpt_can_queue = 127;
+int mpt_sg_tablesize = 128;
+static int mpt_reply_depth = 64;
+static int mpt_chain_alloc_percent = 100;
+MODULE_PARM(mpt_can_queue, "i");
+MODULE_PARM_DESC(mpt_can_queue, " Max IO depth per controller (default=127)");
+MODULE_PARM(mpt_sg_tablesize, "i");
+MODULE_PARM_DESC(mpt_sg_tablesize, " Max SG count per IO (default=128)");
+MODULE_PARM(mpt_reply_depth, "i");
+MODULE_PARM_DESC(mpt_reply_depth, " Reply buffers per controller (default=64)");
+MODULE_PARM(mpt_chain_alloc_percent,"i");
+MODULE_PARM_DESC(mpt_chain_alloc_percent, " SG Chain buffer allocation percent (default=100)");
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -147,16 +126,14 @@ void *mpt_v_ASCQ_TablePtr;
 const char **mpt_ScsiOpcodesPtr;
 int mpt_ASCQ_TableSz;
 
-
 #define WHOINIT_UNKNOWN		0xAA
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *  Private data...
  */
-					/* Adapter lookup table */
-       MPT_ADAPTER		*mpt_adapters[MPT_MAX_ADAPTERS];
-static MPT_ADAPTER_TRACKER	 MptAdapters;
+					/* Adapter link list */
+struct list_head	  	ioc_list;
 					/* Callback lookup table */
 static MPT_CALLBACK		 MptCallbacks[MPT_MAX_PROTOCOL_DRIVERS];
 					/* Protocol driver class lookup table */
@@ -166,13 +143,12 @@ static MPT_EVHANDLER		 MptEvHandlers[MPT
 					/* Reset handler lookup table */
 static MPT_RESETHANDLER		 MptResetHandlers[MPT_MAX_PROTOCOL_DRIVERS];
 
-static int	FusionInitCalled = 0;
 static int	mpt_base_index = -1;
 static int	last_drv_idx = -1;
 static int	isense_idx = -1;
 
 static DECLARE_WAIT_QUEUE_HEAD(mpt_waitq);
-
+static struct mpt_work_struct   mptbase_sasScanTask;
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *  Forward protos...
@@ -180,12 +156,19 @@ static DECLARE_WAIT_QUEUE_HEAD(mpt_waitq
 static void	mpt_interrupt(int irq, void *bus_id, struct pt_regs *r);
 static int	mpt_base_reply(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req, MPT_FRAME_HDR *reply);
 
+int	mpt_handshake_req_reply_wait(MPT_ADAPTER *ioc, int reqBytes,
+			u32 *req, int replyBytes, u16 *u16reply, int maxwait,
+			int sleepFlag);
+static int	WaitForDoorbellAck(MPT_ADAPTER *ioc, int howlong, int sleepFlag);
 static int	mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u32 reason, int sleepFlag);
 static int	mpt_adapter_install(struct pci_dev *pdev);
-static void	mpt_detect_bound_ports(MPT_ADAPTER *this, struct pci_dev *pdev);
-static void	mpt_adapter_disable(MPT_ADAPTER *ioc, int freeup);
+static void	mpt_detect_bound_ports(MPT_ADAPTER *ioc, struct pci_dev *pdev);
+static void	mpt_adapter_disable(MPT_ADAPTER *ioc);
 static void	mpt_adapter_dispose(MPT_ADAPTER *ioc);
 
+static void	pci_disable_io_access(struct pci_dev *pdev); 
+static void	pci_enable_io_access(struct pci_dev *pdev);
+
 static void	MptDisplayIocCapabilities(MPT_ADAPTER *ioc);
 static int	MakeIocReady(MPT_ADAPTER *ioc, int force, int sleepFlag);
 //static u32	mpt_GetIocState(MPT_ADAPTER *ioc, int cooked);
@@ -194,7 +177,7 @@ static int	GetPortFacts(MPT_ADAPTER *ioc
 static int	SendIocInit(MPT_ADAPTER *ioc, int sleepFlag);
 static int	SendPortEnable(MPT_ADAPTER *ioc, int portnum, int sleepFlag);
 static int	mpt_do_upload(MPT_ADAPTER *ioc, int sleepFlag);
-static int	mpt_downloadboot(MPT_ADAPTER *ioc, int sleepFlag);
+int		mpt_downloadboot(MPT_ADAPTER *ioc, MpiFwHeader_t *pFwHeader, int sleepFlag);
 static int	mpt_diag_reset(MPT_ADAPTER *ioc, int ignore, int sleepFlag);
 static int	KickStart(MPT_ADAPTER *ioc, int ignore, int sleepFlag);
 static int	SendIocReset(MPT_ADAPTER *ioc, u8 reset_type, int sleepFlag);
@@ -205,13 +188,26 @@ static int	WaitForDoorbellReply(MPT_ADAP
 static int	GetLanConfigPages(MPT_ADAPTER *ioc);
 static int	GetFcPortPage0(MPT_ADAPTER *ioc, int portnum);
 static int	GetIoUnitPage2(MPT_ADAPTER *ioc);
+static int	GetManufPage5(MPT_ADAPTER *ioc, int numPorts);
+static int	GetManufPage0(MPT_ADAPTER *ioc);
+static int	GetSasInfo(MPT_ADAPTER *ioc);
+static int	mptbase_sas_get_info(MPT_ADAPTER *ioc);
+static void	mptbase_sas_process_event_data(MPT_ADAPTER *ioc,
+		    MpiEventDataSasDeviceStatusChange_t * pSasEventData);
+static void	mptbase_sas_update_device_list(void * arg);
+int		mptbase_sas_persist_operation(MPT_ADAPTER *ioc, u8 persist_opcode);
+static void	ProcessSasEventData(MPT_ADAPTER *ioc,
+		    MpiEventDataSasDeviceStatusChange_t * pSasEventData);
 static int	mpt_GetScsiPortSettings(MPT_ADAPTER *ioc, int portnum);
 static int	mpt_readScsiDevicePageHeaders(MPT_ADAPTER *ioc, int portnum);
-static int	mpt_findImVolumes(MPT_ADAPTER *ioc);
 static void 	mpt_read_ioc_pg_1(MPT_ADAPTER *ioc);
+static void 	mpt_read_ioc_pg_4(MPT_ADAPTER *ioc);
 static void	mpt_timer_expired(unsigned long data);
 static int	SendEventNotification(MPT_ADAPTER *ioc, u8 EvSwitch);
 static int	SendEventAck(MPT_ADAPTER *ioc, EventNotificationReply_t *evnp);
+static int	mpt_host_page_access_control(MPT_ADAPTER *ioc,
+		    u8 access_control_value, int sleepFlag);
+static int	mpt_host_page_alloc(MPT_ADAPTER *ioc, pIOCInit_t ioc_init);
 
 #ifdef CONFIG_PROC_FS
 static int	procmpt_create(void);
@@ -227,6 +223,8 @@ static void	mpt_get_fw_exp_ver(char *buf
 
 //int		mpt_HardResetHandler(MPT_ADAPTER *ioc, int sleepFlag);
 static int	ProcessEventNotification(MPT_ADAPTER *ioc, EventNotificationReply_t *evReply, int *evHandlers);
+static void	mptbase_sas_update_device_list(void * arg);
+static void	mpt_sp_ioc_info(MPT_ADAPTER *ioc, u32 ioc_status, MPT_FRAME_HDR *mf);
 static void	mpt_fc_log_info(MPT_ADAPTER *ioc, u32 log_info);
 static void	mpt_sp_log_info(MPT_ADAPTER *ioc, u32 log_info);
 
@@ -258,37 +256,29 @@ struct _mpt_ioc_proc_list {
 
 #endif
 
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/* 20000207 -sralston
- *  GRRRRR...  IOSpace (port i/o) register access (for the 909) is back!
- * 20000517 -sralston
- *  Let's trying going back to default mmap register access...
- */
-
-static inline u32 CHIPREG_READ32(volatile u32 *a)
-{
-	if (PortIo)
-		return inl((unsigned long)a);
-	else
-		return readl(a);
-}
+#define CHIPREG_READ32(addr) 		readl(addr)
+#define CHIPREG_WRITE32(addr,val) 	writel(val, addr)
+#define CHIPREG_PIO_WRITE32(addr,val)	outl(val, (unsigned long)addr)
+#define CHIPREG_PIO_READ32(addr) 	inl((unsigned long)addr)
 
-static inline void CHIPREG_WRITE32(volatile u32 *a, u32 v)
+static void
+pci_disable_io_access(struct pci_dev *pdev) 
 {
-	if (PortIo)
-		outl(v, (unsigned long)a);
-	else
-		writel(v, a);
+	u16 command_reg;
+	
+	pci_read_config_word(pdev, PCI_COMMAND, &command_reg);
+	command_reg &= 0xFE;
+	pci_write_config_word(pdev, PCI_COMMAND, command_reg);
 }
 
-static inline void CHIPREG_PIO_WRITE32(volatile u32 *a, u32 v)
+static void
+pci_enable_io_access(struct pci_dev *pdev) 
 {
-	outl(v, (unsigned long)a);
-}
+	u16 command_reg;
 
-static inline u32 CHIPREG_PIO_READ32(volatile u32 *a)
-{
-	return inl((unsigned long)a);
+	pci_read_config_word(pdev, PCI_COMMAND, &command_reg);
+	command_reg |= 1;
+	pci_write_config_word(pdev, PCI_COMMAND, command_reg);
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -303,8 +293,7 @@ static inline u32 CHIPREG_PIO_READ32(vol
  *	(also referred to as a IO Controller or IOC).
  *	This routine must clear the interrupt from the adapter and does
  *	so by reading the reply FIFO.  Multiple replies may be processed
- *	per single call to this routine; up to MPT_MAX_REPLIES_PER_ISR
- *	which is currently set to 32 in mptbase.h.
+ *	per single call to this routine.
  *
  *	This routine handles register-level access of the adapter but
  *	dispatches (calls) a protocol-specific callback routine to handle
@@ -317,49 +306,81 @@ mpt_interrupt(int irq, void *bus_id, str
 	MPT_FRAME_HDR	*mf;
 	MPT_FRAME_HDR	*mr;
 	u32		 pa;
-	int		 req_idx = -1;
+	int		 req_idx;
 	int		 cb_idx;
 	int		 type;
 	int		 freeme;
-	int		 count = 0;
-
-	ioc = bus_id;
-
-	/*
-	 * Verify ioc pointer is ok
-	 */
-	{
-		MPT_ADAPTER	*iocCmp;
-		iocCmp = mpt_adapter_find_first();
-		while ((ioc != iocCmp)  && iocCmp)
-			iocCmp = mpt_adapter_find_next(iocCmp);
 
-		if (!iocCmp) {
-			printk(KERN_WARNING "mpt_interrupt: Invalid ioc!\n");
-			return;
-		}
-	}
+	ioc = (MPT_ADAPTER *)bus_id;
 
 	/*
 	 *  Drain the reply FIFO!
-	 *
-	 * NOTES: I've seen up to 10 replies processed in this loop, so far...
-	 * Update: I've seen up to 9182 replies processed in this loop! ??
-	 * Update: Limit ourselves to processing max of N replies
-	 *	(bottom of loop).
 	 */
 	while (1) {
 
 		if ((pa = CHIPREG_READ32(&ioc->chip->ReplyFifo)) == 0xFFFFFFFF)
 			return;
 
-		cb_idx = 0;
-		freeme = 0;
-
 		/*
 		 *  Check for non-TURBO reply!
 		 */
-		if (pa & MPI_ADDRESS_REPLY_A_BIT) {
+		if ((pa & MPI_ADDRESS_REPLY_A_BIT) == 0) {
+			/*
+			 *  Process turbo (context) reply...
+			 */
+			dmfprintk((MYIOC_s_WARN_FMT "Got TURBO reply req_idx=%08x\n", ioc->name, pa));
+			type = (pa >> MPI_CONTEXT_REPLY_TYPE_SHIFT);
+			if (type == MPI_CONTEXT_REPLY_TYPE_SCSI_INIT) {
+				unsigned long flags;
+#ifdef MPT_DEBUG_FAIL
+				if ( pa == 0 ) {
+					dfailprintk((MYIOC_s_ERR_FMT "Invalid Turbo pa=%08x reply!!\n",
+						ioc->name, pa));
+					continue;
+				}
+#endif
+				req_idx = pa & 0x0000FFFF;
+				cb_idx = (pa & 0x00FF0000) >> 16;
+				mf = MPT_INDEX_2_MFPTR(ioc, req_idx);
+				mr = NULL;
+				/*  Do the callback!  */
+				freeme = (*(MptCallbacks[cb_idx]))(ioc, mf, mr);
+
+				/*  Put Request back on FreeQ!  */
+				mpt_free_msg_frame(ioc, mf);
+				mb();
+				continue;
+			} else if (type == MPI_CONTEXT_REPLY_TYPE_LAN) {
+				cb_idx = mpt_lan_index;
+				/*  Blind set of mf to NULL here was fatal
+				 *  after lan_reply says "freeme"
+				 *  Fix sort of combined with an optimization here;
+				 *  added explicit check for case where lan_reply
+				 *  was just returning 1 and doing nothing else.
+				 *  For this case skip the callback, but set up
+				 *  proper mf value first here:-)
+				 */
+				if ((pa & 0x58000000) == 0x58000000) {
+					req_idx = pa & 0x0000FFFF;
+					mf = MPT_INDEX_2_MFPTR(ioc, req_idx);
+					freeme = 1;
+					/*
+					 *  IMPORTANT!  Invalidate the callback!
+					 */
+					cb_idx = 0;
+				} else {
+					mf = NULL;
+					freeme = 0;
+				}
+				mr = (MPT_FRAME_HDR *) CAST_U32_TO_PTR(pa);
+			} else { /* MPI_CONTEXT_REPLY_TYPE_SCSI_TARGET */
+				cb_idx = mpt_stm_index;
+				mf = NULL;
+				mr = (MPT_FRAME_HDR *) CAST_U32_TO_PTR(pa);
+				freeme = 0;
+			}
+			pa = 0;	/* No reply flush! */
+		} else {
 			u32 reply_dma_low;
 			u16 ioc_stat;
 
@@ -372,6 +393,8 @@ mpt_interrupt(int irq, void *bus_id, str
 			 * pa is 32 bits - but the dma address may be 32 or 64 bits
 			 * get offset based only only the low addresses
 			 */
+			freeme = 0;
+
 			reply_dma_low = (pa = (pa << 1));
 			mr = (MPT_FRAME_HDR *)((u8 *)ioc->reply_frames +
 					 (reply_dma_low - ioc->reply_frames_low_dma));
@@ -380,86 +403,50 @@ mpt_interrupt(int irq, void *bus_id, str
 			cb_idx = mr->u.frame.hwhdr.msgctxu.fld.cb_idx;
 			mf = MPT_INDEX_2_MFPTR(ioc, req_idx);
 
-			dprintk((MYIOC_s_INFO_FMT "Got non-TURBO reply=%p\n",
-					ioc->name, mr));
+			dmfprintk((MYIOC_s_WARN_FMT "Got non-TURBO reply=%p req_idx=%x cb_idx=%x Function=%x\n",
+					ioc->name, mr, req_idx, cb_idx, mr->u.hdr.Function));
 			DBG_DUMP_REPLY_FRAME(mr)
 
-			/* NEW!  20010301 -sralston
-			 *  Check/log IOC log info
+			/*  Check/log IOC log info
 			 */
 			ioc_stat = le16_to_cpu(mr->u.reply.IOCStatus);
 			if (ioc_stat & MPI_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE) {
 				u32	 log_info = le32_to_cpu(mr->u.reply.IOCLogInfo);
-				if ((int)ioc->chip_type <= (int)FC929)
-					mpt_fc_log_info(ioc, log_info);
-				else
+				if (ioc->bus_type == SCSI)
 					mpt_sp_log_info(ioc, log_info);
+				else
+					mpt_fc_log_info(ioc, log_info);
 			}
-		} else {
-			/*
-			 *  Process turbo (context) reply...
-			 */
-			dirqprintk((MYIOC_s_INFO_FMT "Got TURBO reply(=%08x)\n", ioc->name, pa));
-			type = (pa >> MPI_CONTEXT_REPLY_TYPE_SHIFT);
-			if (type == MPI_CONTEXT_REPLY_TYPE_SCSI_TARGET) {
-				cb_idx = mpt_stm_index;
-				mf = NULL;
-				mr = (MPT_FRAME_HDR *) CAST_U32_TO_PTR(pa);
-			} else if (type == MPI_CONTEXT_REPLY_TYPE_LAN) {
-				cb_idx = mpt_lan_index;
-				/*
-				 * BUG FIX!  20001218 -sralston
-				 *  Blind set of mf to NULL here was fatal
-				 *  after lan_reply says "freeme"
-				 *  Fix sort of combined with an optimization here;
-				 *  added explicit check for case where lan_reply
-				 *  was just returning 1 and doing nothing else.
-				 *  For this case skip the callback, but set up
-				 *  proper mf value first here:-)
-				 */
-				if ((pa & 0x58000000) == 0x58000000) {
-					req_idx = pa & 0x0000FFFF;
-					mf = MPT_INDEX_2_MFPTR(ioc, req_idx);
-					freeme = 1;
-					/*
-					 *  IMPORTANT!  Invalidate the callback!
-					 */
-					cb_idx = 0;
-				} else {
-					mf = NULL;
-				}
-				mr = (MPT_FRAME_HDR *) CAST_U32_TO_PTR(pa);
-			} else {
-				req_idx = pa & 0x0000FFFF;
-				cb_idx = (pa & 0x00FF0000) >> 16;
-				mf = MPT_INDEX_2_MFPTR(ioc, req_idx);
-				mr = NULL;
+			if (ioc_stat & MPI_IOCSTATUS_MASK) {
+				if (ioc->bus_type == SCSI &&
+				    cb_idx != mpt_stm_index &&
+				    cb_idx != mpt_lan_index)
+					mpt_sp_ioc_info(ioc, (u32)ioc_stat, mf);
 			}
-			pa = 0;					/* No reply flush! */
 		}
 
 #ifdef MPT_DEBUG_IRQ
-		if ((int)ioc->chip_type > (int)FC929) {
+		if (ioc->bus_type == SCSI) {
 			/* Verify mf, mr are reasonable.
 			 */
 			if ((mf) && ((mf >= MPT_INDEX_2_MFPTR(ioc, ioc->req_depth))
 				|| (mf < ioc->req_frames)) ) {
-				printk(MYIOC_s_WARN_FMT 
-					"mpt_interrupt: Invalid mf (%p) req_idx (%d)!\n", ioc->name, (void *)mf, req_idx);
+				printk(MYIOC_s_WARN_FMT
+					"mpt_interrupt: Invalid mf (%p)!\n", ioc->name, (void *)mf);
 				cb_idx = 0;
 				pa = 0;
 				freeme = 0;
 			}
 			if ((pa) && (mr) && ((mr >= MPT_INDEX_2_RFPTR(ioc, ioc->req_depth))
 				|| (mr < ioc->reply_frames)) ) {
-				printk(MYIOC_s_WARN_FMT 
+				printk(MYIOC_s_WARN_FMT
 					"mpt_interrupt: Invalid rf (%p)!\n", ioc->name, (void *)mr);
 				cb_idx = 0;
 				pa = 0;
 				freeme = 0;
 			}
 			if (cb_idx > (MPT_MAX_PROTOCOL_DRIVERS-1)) {
-				printk(MYIOC_s_WARN_FMT 
+				printk(MYIOC_s_WARN_FMT
 					"mpt_interrupt: Invalid cb_idx (%d)!\n", ioc->name, cb_idx);
 				cb_idx = 0;
 				pa = 0;
@@ -483,25 +470,10 @@ mpt_interrupt(int irq, void *bus_id, str
 			unsigned long flags;
 
 			/*  Put Request back on FreeQ!  */
-			spin_lock_irqsave(&ioc->FreeQlock, flags);
-			Q_ADD_TAIL(&ioc->FreeQ, &mf->u.frame.linkage, MPT_FRAME_HDR);
-#ifdef MFCNT
-			ioc->mfcnt--;
-#endif
-			spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+			mpt_free_msg_frame(ioc, mf);
 		}
 
-		count++;
-		dirqprintk((MYIOC_s_INFO_FMT "ISR processed frame #%d\n", ioc->name, count));
 		mb();
-
-		if (count >= MPT_MAX_REPLIES_PER_ISR) {
-			dirqprintk((MYIOC_s_INFO_FMT "ISR processed %d replies.",
-					ioc->name, count));
-			dirqprintk((" Giving this ISR a break!\n"));
-			return;
-		}
-
 	}	/* drain reply FIFO */
 }
 
@@ -523,28 +495,17 @@ mpt_base_reply(MPT_ADAPTER *ioc, MPT_FRA
 	int freereq = 1;
 	u8 func;
 
-	dprintk((MYIOC_s_INFO_FMT "mpt_base_reply() called\n", ioc->name));
-
-	if ((mf == NULL) ||
-	    (mf >= MPT_INDEX_2_MFPTR(ioc, ioc->req_depth))) {
-		printk(MYIOC_s_ERR_FMT "NULL or BAD request frame ptr! (=%p)\n",
-				ioc->name, (void *)mf);
-		return 1;
-	}
-
-	if (reply == NULL) {
-		dprintk((MYIOC_s_ERR_FMT "Unexpected NULL Event (turbo?) reply!\n",
-				ioc->name));
-		return 1;
-	}
+	dmfprintk((MYIOC_s_WARN_FMT "mpt_base_reply() called\n", ioc->name));
 
+#if defined(MPT_DEBUG_MSG_FRAME)
 	if (!(reply->u.hdr.MsgFlags & MPI_MSGFLAGS_CONTINUATION_REPLY)) {
 		dmfprintk((KERN_INFO MYNAM ": Original request frame (@%p) header\n", mf));
 		DBG_DUMP_REQUEST_FRAME_HDR(mf)
 	}
+#endif
 
 	func = reply->u.hdr.Function;
-	dprintk((MYIOC_s_INFO_FMT "mpt_base_reply, Function=%02Xh\n",
+	dmfprintk((MYIOC_s_WARN_FMT "mpt_base_reply, Function=%02Xh\n",
 			ioc->name, func));
 
 	if (func == MPI_FUNCTION_EVENT_NOTIFICATION) {
@@ -555,29 +516,39 @@ mpt_base_reply(MPT_ADAPTER *ioc, MPT_FRA
 		results = ProcessEventNotification(ioc, pEvReply, &evHandlers);
 		if (results != evHandlers) {
 			/* CHECKME! Any special handling needed here? */
-			dprintk((MYIOC_s_WARN_FMT "Called %d event handlers, sum results = %d\n",
+			devtprintk((MYIOC_s_WARN_FMT "Called %d event handlers, sum results = %d\n",
 					ioc->name, evHandlers, results));
 		}
 
 		/*
-		 *	Hmmm...  It seems that EventNotificationReply is an exception
+		 *	EventNotificationReply is an exception
 		 *	to the rule of one reply per request.
 		 */
-		if (pEvReply->MsgFlags & MPI_MSGFLAGS_CONTINUATION_REPLY)
+		if (pEvReply->MsgFlags & MPI_MSGFLAGS_CONTINUATION_REPLY) {
 			freereq = 0;
+			devtprintk((MYIOC_s_WARN_FMT "EVENT_NOTIFICATION reply %p does not return Request frame\n",
+				ioc->name, pEvReply));
+		} else {
+			devtprintk((MYIOC_s_WARN_FMT "EVENT_NOTIFICATION reply %p returns mf=%p evnp=%p\n",
+				ioc->name, pEvReply, mf, ioc->evnp));
+			if ( (MPT_FRAME_HDR *)ioc->evnp == mf ) {
+				ioc->evnp = NULL;
+			}
+		}
 
 #ifdef CONFIG_PROC_FS
 //		LogEvent(ioc, pEvReply);
 #endif
 
 	} else if (func == MPI_FUNCTION_EVENT_ACK) {
-		dprintk((MYIOC_s_INFO_FMT "mpt_base_reply, EventAck reply received\n",
+		dprintk((MYIOC_s_WARN_FMT "mpt_base_reply, EventAck reply received\n",
 				ioc->name));
-	} else if (func == MPI_FUNCTION_CONFIG) {
+	} else if (func == MPI_FUNCTION_CONFIG ||
+		   func == MPI_FUNCTION_TOOLBOX) {
 		CONFIGPARMS *pCfg;
 		unsigned long flags;
 
-		dprintk((MYIOC_s_INFO_FMT "config_complete (mf=%p,mr=%p)\n",
+		dcprintk((MYIOC_s_WARN_FMT "config_complete (mf=%p,mr=%p)\n",
 				ioc->name, mf, reply));
 
 		pCfg = * ((CONFIGPARMS **)((u8 *) mf + ioc->req_sz - sizeof(void *)));
@@ -600,15 +571,22 @@ mpt_base_reply(MPT_ADAPTER *ioc, MPT_FRA
 				u16		 status;
 
 				status = le16_to_cpu(pReply->IOCStatus) & MPI_IOCSTATUS_MASK;
-				dprintk((KERN_NOTICE "  IOCStatus=%04xh, IOCLogInfo=%08xh\n",
+				dcprintk((KERN_NOTICE "  IOCStatus=%04xh, IOCLogInfo=%08xh\n",
 				     status, le32_to_cpu(pReply->IOCLogInfo)));
 
 				pCfg->status = status;
 				if (status == MPI_IOCSTATUS_SUCCESS) {
-					pCfg->hdr->PageVersion = pReply->Header.PageVersion;
-					pCfg->hdr->PageLength = pReply->Header.PageLength;
-					pCfg->hdr->PageNumber = pReply->Header.PageNumber;
-					pCfg->hdr->PageType = pReply->Header.PageType;
+					if ((pReply->Header.PageType & MPI_CONFIG_PAGETYPE_MASK) == MPI_CONFIG_PAGETYPE_EXTENDED) {
+						pCfg->cfghdr.ehdr->ExtPageLength = le16_to_cpu(pReply->ExtPageLength);
+						pCfg->cfghdr.ehdr->ExtPageType = pReply->ExtPageType;
+					}
+					pCfg->cfghdr.hdr->PageVersion = pReply->Header.PageVersion;
+
+					/* If this is a regular header, save PageLength. */
+					/* LMP Do this better so not using a reserved field! */
+					pCfg->cfghdr.hdr->PageLength = pReply->Header.PageLength;
+					pCfg->cfghdr.hdr->PageNumber = pReply->Header.PageNumber;
+					pCfg->cfghdr.hdr->PageType = pReply->Header.PageType;
 				}
 			}
 
@@ -618,6 +596,14 @@ mpt_base_reply(MPT_ADAPTER *ioc, MPT_FRA
 			pCfg->wait_done = 1;
 			wake_up(&mpt_waitq);
 		}
+	} else if (func == MPI_FUNCTION_SAS_IO_UNIT_CONTROL) {
+		/* we should be always getting a reply frame */
+		memcpy(ioc->persist_reply_frame, reply,
+		    min(MPT_DEFAULT_FRAME_SIZE,
+		    4*reply->u.reply.MsgLength));
+		del_timer(&ioc->persist_timer);
+		ioc->persist_wait_done = 1;
+		wake_up(&mpt_waitq);
 	} else {
 		printk(MYIOC_s_ERR_FMT "Unexpected msg function (=%02Xh) reply received!\n",
 				ioc->name, func);
@@ -657,22 +643,6 @@ mpt_register(MPT_CALLBACK cbfunc, MPT_DR
 
 	last_drv_idx = -1;
 
-#ifndef MODULE
-	/*
-	 *  Handle possibility of the mptscsih_detect() routine getting
-	 *  called *before* fusion_init!
-	 */
-	if (!FusionInitCalled) {
-		dprintk((KERN_INFO MYNAM ": Hmmm, calling fusion_init from mpt_register!\n"));
-		/*
-		 *  NOTE! We'll get recursion here, as fusion_init()
-		 *  calls mpt_register()!
-		 */
-		fusion_init();
-		FusionInitCalled++;
-	}
-#endif
-
 	/*
 	 *  Search for empty callback slot in this order: {N,...,7,6,5,...,1}
 	 *  (slot/handle 0 is reserved!)
@@ -684,7 +654,7 @@ mpt_register(MPT_CALLBACK cbfunc, MPT_DR
 			MptEvHandlers[i] = NULL;
 			last_drv_idx = i;
 			if (cbfunc != mpt_base_reply) {
-				MOD_INC_USE_COUNT;
+				mpt_inc_use_count();
 			}
 			break;
 		}
@@ -704,7 +674,7 @@ mpt_register(MPT_CALLBACK cbfunc, MPT_DR
 void
 mpt_deregister(int cb_idx)
 {
-	if (cb_idx && (cb_idx < MPT_MAX_PROTOCOL_DRIVERS)) {
+	if ((cb_idx >= 0) && (cb_idx < MPT_MAX_PROTOCOL_DRIVERS)) {
 		MptCallbacks[cb_idx] = NULL;
 		MptDriverClass[cb_idx] = MPTUNKNOWN_DRIVER;
 		MptEvHandlers[cb_idx] = NULL;
@@ -714,7 +684,7 @@ mpt_deregister(int cb_idx)
 			isense_idx++;
 
 		if (cb_idx != mpt_base_index) {
-			MOD_DEC_USE_COUNT;
+			mpt_dec_use_count();
 		}
 	}
 }
@@ -778,6 +748,7 @@ mpt_reset_register(int cb_idx, MPT_RESET
 		return -1;
 
 	MptResetHandlers[cb_idx] = reset_func;
+	dinitprintk((KERN_INFO MYNAM ": MptResetHandlers=%p cb_idx=%d\n", reset_func, cb_idx));
 	return 0;
 }
 
@@ -804,58 +775,48 @@ mpt_reset_deregister(int cb_idx)
  *	mpt_get_msg_frame - Obtain a MPT request frame from the pool (of 1024)
  *	allocated per MPT adapter.
  *	@handle: Handle of registered MPT protocol driver
- *	@iocid: IOC unique identifier (integer)
+ *	@ioc: Pointer to MPT adapter structure
  *
  *	Returns pointer to a MPT request frame or %NULL if none are available
  *	or IOC is not active.
  */
 MPT_FRAME_HDR*
-mpt_get_msg_frame(int handle, int iocid)
+mpt_get_msg_frame(int handle, MPT_ADAPTER *ioc)
 {
-	MPT_FRAME_HDR *mf = NULL;
-	MPT_ADAPTER *iocp;
+	MPT_FRAME_HDR *mf;
 	unsigned long flags;
+	u16	 req_idx;	/* Request index */
 
 	/* validate handle and ioc identifier */
-	iocp = mpt_adapters[iocid];
-
-#ifdef MFCNT
-	if (!iocp->active)
-		printk(KERN_WARNING "IOC Not Active! mpt_get_msg_frame returning NULL!\n");
-#endif
 
-	/* If interrupts are not attached, do not return a request frame */
-	if (!iocp->active)
-		return NULL;
-
-	spin_lock_irqsave(&iocp->FreeQlock, flags);
-	if (! Q_IS_EMPTY(&iocp->FreeQ)) {
+	spin_lock_irqsave(&ioc->FreeQlock, flags);
+	if (! Q_IS_EMPTY(&ioc->FreeQ)) {
 		int req_offset;
 
-		mf = iocp->FreeQ.head;
+		mf = ioc->FreeQ.head;
 		Q_DEL_ITEM(&mf->u.frame.linkage);
 		mf->u.frame.hwhdr.msgctxu.fld.cb_idx = handle;	/* byte */
-		req_offset = (u8 *)mf - (u8 *)iocp->req_frames;
+		req_offset = (u8 *)mf - (u8 *)ioc->req_frames;
 								/* u16! */
-		mf->u.frame.hwhdr.msgctxu.fld.req_idx =
-				cpu_to_le16(req_offset / iocp->req_sz);
+		req_idx = req_offset / ioc->req_sz;
+		mf->u.frame.hwhdr.msgctxu.fld.req_idx = cpu_to_le16(req_idx);
 		mf->u.frame.hwhdr.msgctxu.fld.rsvd = 0;
+		ioc->RequestNB[req_idx] = ioc->NB_for_64_byte_frame; /* Default, will be changed if necessary in SG generation */
 #ifdef MFCNT
-		iocp->mfcnt++;
+		ioc->mfcnt++;
 #endif
 	}
-	spin_unlock_irqrestore(&iocp->FreeQlock, flags);
+	else
+		mf = NULL;
+	spin_unlock_irqrestore(&ioc->FreeQlock, flags);
 
 #ifdef MFCNT
 	if (mf == NULL)
-		printk(KERN_WARNING "IOC Active. No free Msg Frames! Count 0x%x Max 0x%x\n", iocp->mfcnt, iocp->req_depth);
-	mfcounter++;
-	if (mfcounter == PRINT_MF_COUNT)
-		printk(KERN_INFO "MF Count 0x%x Max 0x%x \n", iocp->mfcnt, iocp->req_depth);
+		printk(KERN_WARNING "No available Msg Frame! mfcnt=%d req_depth=%d\n", ioc->mfcnt, ioc->req_depth);
 #endif
 
 	dmfprintk((KERN_INFO MYNAM ": %s: mpt_get_msg_frame(%d,%d), got mf=%p\n",
-			iocp->name, handle, iocid, mf));
+			ioc->name, handle, ioc->id, mf));
 	return mf;
 }
 
@@ -864,79 +825,74 @@ mpt_get_msg_frame(int handle, int iocid)
  *	mpt_put_msg_frame - Send a protocol specific MPT request frame
  *	to a IOC.
  *	@handle: Handle of registered MPT protocol driver
- *	@iocid: IOC unique identifier (integer)
+ *	@ioc: Pointer to MPT adapter structure
  *	@mf: Pointer to MPT request frame
  *
  *	This routine posts a MPT request frame to the request post FIFO of a
  *	specific MPT adapter.
  */
 void
-mpt_put_msg_frame(int handle, int iocid, MPT_FRAME_HDR *mf)
+mpt_put_msg_frame(int handle, MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf)
 {
-	MPT_ADAPTER *iocp;
-
-	iocp = mpt_adapters[iocid];
-	if (iocp != NULL) {
-		u32 mf_dma_addr;
-		int req_offset;
-
-		/* ensure values are reset properly! */
-		mf->u.frame.hwhdr.msgctxu.fld.cb_idx = handle;		/* byte */
-		req_offset = (u8 *)mf - (u8 *)iocp->req_frames;
-									/* u16! */
-		mf->u.frame.hwhdr.msgctxu.fld.req_idx = cpu_to_le16(req_offset / iocp->req_sz);
-		mf->u.frame.hwhdr.msgctxu.fld.rsvd = 0;
+	u32 mf_dma_addr;
+	int req_offset;
+	u16	 req_idx;	/* Request index */
+
+	/* ensure values are reset properly! */
+	mf->u.frame.hwhdr.msgctxu.fld.cb_idx = handle;		/* byte */
+	req_offset = (u8 *)mf - (u8 *)ioc->req_frames;
+								/* u16! */
+	req_idx = req_offset / ioc->req_sz;
+	mf->u.frame.hwhdr.msgctxu.fld.req_idx = cpu_to_le16(req_idx);
+	mf->u.frame.hwhdr.msgctxu.fld.rsvd = 0;
 
 #ifdef MPT_DEBUG_MSG_FRAME
-		{
-			u32	*m = mf->u.frame.hwhdr.__hdr;
-			int	 ii, n;
+	{
+		u32	*m = mf->u.frame.hwhdr.__hdr;
+		int	 ii, n;
 
-			printk(KERN_INFO MYNAM ": %s: About to Put msg frame @ %p:\n" KERN_INFO " ",
-					iocp->name, m);
-			n = iocp->req_sz/4 - 1;
-			while (m[n] == 0)
-				n--;
-			for (ii=0; ii<=n; ii++) {
-				if (ii && ((ii%8)==0))
-					printk("\n" KERN_INFO " ");
-				printk(" %08x", le32_to_cpu(m[ii]));
-			}
-			printk("\n");
+		printk(KERN_INFO MYNAM ": %s: About to Put msg frame @ %p:\n" KERN_INFO " ",
+				ioc->name, m);
+		n = ioc->req_sz/4 - 1;
+		while (m[n] == 0)
+			n--;
+		for (ii=0; ii<=n; ii++) {
+			if (ii && ((ii%8)==0))
+				printk("\n" KERN_INFO " ");
+			printk(" %08x", le32_to_cpu(m[ii]));
 		}
+		printk("\n");
+	}
 #endif
 
-		mf_dma_addr = iocp->req_frames_low_dma + req_offset;
-		CHIPREG_WRITE32(&iocp->chip->RequestFifo, mf_dma_addr);
-	}
+	mf_dma_addr = (ioc->req_frames_low_dma + req_offset) | ioc->RequestNB[req_idx];  
+	dsgprintk((MYIOC_s_WARN_FMT "mf_dma_addr=%x req_idx=%d RequestNB=%x\n", ioc->name, mf_dma_addr, req_idx, ioc->RequestNB[req_idx]));
+	CHIPREG_WRITE32(&ioc->chip->RequestFifo, mf_dma_addr);
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mpt_free_msg_frame - Place MPT request frame back on FreeQ.
  *	@handle: Handle of registered MPT protocol driver
- *	@iocid: IOC unique identifier (integer)
+ *	@ioc: Pointer to MPT adapter structure
  *	@mf: Pointer to MPT request frame
  *
  *	This routine places a MPT request frame back on the MPT adapter's
  *	FreeQ.
  */
 void
-mpt_free_msg_frame(int handle, int iocid, MPT_FRAME_HDR *mf)
+mpt_free_msg_frame(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf)
 {
-	MPT_ADAPTER *iocp;
 	unsigned long flags;
 
-	iocp = mpt_adapters[iocid];
-	if (iocp != NULL) {
-		/*  Put Request back on FreeQ!  */
-		spin_lock_irqsave(&iocp->FreeQlock, flags);
-		Q_ADD_TAIL(&iocp->FreeQ, &mf->u.frame.linkage, MPT_FRAME_HDR);
+	/*  Put Request back on FreeQ!  */
+	spin_lock_irqsave(&ioc->FreeQlock, flags);
+	mf->u.frame.linkage.arg1 = 0xdeadbeaf; /* signature to know if this mf is freed */
+	Q_ADD_TAIL(&ioc->FreeQ, &mf->u.frame.linkage, MPT_FRAME_HDR);
 #ifdef MFCNT
-		iocp->mfcnt--;
+	ioc->mfcnt--;
 #endif
-		spin_unlock_irqrestore(&iocp->FreeQlock, flags);
-	}
+	spin_unlock_irqrestore(&ioc->FreeQlock, flags);
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -944,10 +900,8 @@ mpt_free_msg_frame(int handle, int iocid
  *	mpt_add_sge - Place a simple SGE at address pAddr.
  *	@pAddr: virtual address for SGE
  *	@flagslength: SGE flags and data transfer length
- *	@dma_addr: Physical address 
+ *	@dma_addr: Physical address
  *
- *	This routine places a MPT request frame back on the MPT adapter's
- *	FreeQ.
  */
 void
 mpt_add_sge(char *pAddr, u32 flagslength, dma_addr_t dma_addr)
@@ -970,45 +924,10 @@ mpt_add_sge(char *pAddr, u32 flagslength
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
- *	mpt_add_chain - Place a chain SGE at address pAddr.
- *	@pAddr: virtual address for SGE
- *	@next: nextChainOffset value (u32's)
- *	@length: length of next SGL segment
- *	@dma_addr: Physical address 
- *
- *	This routine places a MPT request frame back on the MPT adapter's
- *	FreeQ.
- */
-void
-mpt_add_chain(char *pAddr, u8 next, u16 length, dma_addr_t dma_addr)
-{
-	if (sizeof(dma_addr_t) == sizeof(u64)) {
-		SGEChain64_t *pChain = (SGEChain64_t *) pAddr;
-		u32 tmp = dma_addr & 0xFFFFFFFF;
-
-		pChain->Length = cpu_to_le16(length);
-		pChain->Flags = MPI_SGE_FLAGS_CHAIN_ELEMENT | mpt_addr_size(); 
-
-		pChain->NextChainOffset = next;
-
-		pChain->Address.Low = cpu_to_le32(tmp);
-		tmp = (u32) ((u64)dma_addr >> 32);
-		pChain->Address.High = cpu_to_le32(tmp);
-	} else {
-		SGEChain32_t *pChain = (SGEChain32_t *) pAddr;
-		pChain->Length = cpu_to_le16(length);
-		pChain->Flags = MPI_SGE_FLAGS_CHAIN_ELEMENT | mpt_addr_size();
-		pChain->NextChainOffset = next;
-		pChain->Address = cpu_to_le32(dma_addr);
-	}
-}
-
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
  *	mpt_send_handshake_request - Send MPT request via doorbell
  *	handshake method.
  *	@handle: Handle of registered MPT protocol driver
- *	@iocid: IOC unique identifier (integer)
+ *	@ioc: Pointer to MPT adapter structure
  *	@reqBytes: Size of the request in bytes
  *	@req: Pointer to MPT request frame
  *	@sleepFlag: Use schedule if CAN_SLEEP else use udelay.
@@ -1022,122 +941,195 @@ mpt_add_chain(char *pAddr, u8 next, u16 
  *	Returns 0 for success, non-zero for failure.
  */
 int
-mpt_send_handshake_request(int handle, int iocid, int reqBytes, u32 *req, int sleepFlag)
+mpt_send_handshake_request(int handle, MPT_ADAPTER *ioc, int reqBytes, u32 *req, int sleepFlag)
 {
-	MPT_ADAPTER	*iocp;
 	int		 r = 0;
 
-	iocp = mpt_adapters[iocid];
-	if (iocp != NULL) {
-		u8	*req_as_bytes;
-		int	 ii;
+	u8	*req_as_bytes;
+	int	 ii;
 
-		/* State is known to be good upon entering
-		 * this function so issue the bus reset
-		 * request.
-		 */
 
-		/*
-		 * Emulate what mpt_put_msg_frame() does /wrt to sanity
-		 * setting cb_idx/req_idx.  But ONLY if this request
-		 * is in proper (pre-alloc'd) request buffer range...
-		 */
-		ii = MFPTR_2_MPT_INDEX(iocp,(MPT_FRAME_HDR*)req);
-		if (reqBytes >= 12 && ii >= 0 && ii < iocp->req_depth) {
-			MPT_FRAME_HDR *mf = (MPT_FRAME_HDR*)req;
-			mf->u.frame.hwhdr.msgctxu.fld.req_idx = cpu_to_le16(ii);
-			mf->u.frame.hwhdr.msgctxu.fld.cb_idx = handle;
-		}
+	dhsprintk((KERN_WARNING MYNAM ": %s: mpt_send_handshake_request reqBytes=%d\n",
+		ioc->name, reqBytes));
+	/*
+	 * Emulate what mpt_put_msg_frame() does /wrt to sanity
+	 * setting cb_idx/req_idx.  But ONLY if this request
+	 * is in proper (pre-alloc'd) request buffer range...
+	 */
+	ii = MFPTR_2_MPT_INDEX(ioc,(MPT_FRAME_HDR*)req);
+	if (reqBytes >= 12 && ii >= 0 && ii < ioc->req_depth) {
+		MPT_FRAME_HDR *mf = (MPT_FRAME_HDR*)req;
+		mf->u.frame.hwhdr.msgctxu.fld.req_idx = cpu_to_le16(ii);
+		mf->u.frame.hwhdr.msgctxu.fld.cb_idx = handle;
+	}
 
-		/* Make sure there are no doorbells */
-		CHIPREG_WRITE32(&iocp->chip->IntStatus, 0);
+	/* Make sure there are no doorbells */
+	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
 
-		CHIPREG_WRITE32(&iocp->chip->Doorbell,
-				((MPI_FUNCTION_HANDSHAKE<<MPI_DOORBELL_FUNCTION_SHIFT) |
-				 ((reqBytes/4)<<MPI_DOORBELL_ADD_DWORDS_SHIFT)));
+	CHIPREG_WRITE32(&ioc->chip->Doorbell,
+			((MPI_FUNCTION_HANDSHAKE<<MPI_DOORBELL_FUNCTION_SHIFT) |
+			 ((reqBytes/4)<<MPI_DOORBELL_ADD_DWORDS_SHIFT)));
 
-		/* Wait for IOC doorbell int */
-		if ((ii = WaitForDoorbellInt(iocp, 2, sleepFlag)) < 0) {
-			return ii;
-		}
+	/* Wait for IOC doorbell int */
+	if ((ii = WaitForDoorbellInt(ioc, 5, sleepFlag)) < 0) {
+		return ii;
+	}
 
-		/* Read doorbell and check for active bit */
-		if (!(CHIPREG_READ32(&iocp->chip->Doorbell) & MPI_DOORBELL_ACTIVE))
-				return -5;
+	/* Read doorbell and check for active bit */
+	if (!(CHIPREG_READ32(&ioc->chip->Doorbell) & MPI_DOORBELL_ACTIVE))
+		return -5;
 
-		dhsprintk((KERN_INFO MYNAM ": %s: mpt_send_handshake_request start, WaitCnt=%d\n",
-				iocp->name, ii));
+	dhsprintk((KERN_WARNING MYNAM ": %s: mpt_send_handshake_request start, WaitCnt=%d\n",
+		ioc->name, ii));
 
-		CHIPREG_WRITE32(&iocp->chip->IntStatus, 0);
+	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
 
-		if ((r = WaitForDoorbellAck(iocp, 1, sleepFlag)) < 0) {
-			return -2;
-		}
+	if ((r = WaitForDoorbellAck(ioc, 5, sleepFlag)) < 0) {
+		return -2;
+	}
 
-		/* Send request via doorbell handshake */
-		req_as_bytes = (u8 *) req;
-		for (ii = 0; ii < reqBytes/4; ii++) {
-			u32 word;
-
-			word = ((req_as_bytes[(ii*4) + 0] <<  0) |
-				(req_as_bytes[(ii*4) + 1] <<  8) |
-				(req_as_bytes[(ii*4) + 2] << 16) |
-				(req_as_bytes[(ii*4) + 3] << 24));
-			CHIPREG_WRITE32(&iocp->chip->Doorbell, word);
-			if ((r = WaitForDoorbellAck(iocp, 1, sleepFlag)) < 0) {
-				r = -3;
-				break;
-			}
+	/* Send request via doorbell handshake */
+	req_as_bytes = (u8 *) req;
+	for (ii = 0; ii < reqBytes/4; ii++) {
+		u32 word;
+
+		word = ((req_as_bytes[(ii*4) + 0] <<  0) |
+			(req_as_bytes[(ii*4) + 1] <<  8) |
+			(req_as_bytes[(ii*4) + 2] << 16) |
+			(req_as_bytes[(ii*4) + 3] << 24));
+			dhsprintk((KERN_WARNING MYNAM ": %s: mpt_send_handshake_request word=%x ii=%d\n",
+		ioc->name, word, ii));
+		CHIPREG_WRITE32(&ioc->chip->Doorbell, word);
+		if ((r = WaitForDoorbellAck(ioc, 5, sleepFlag)) < 0) {
+			r = -3;
+			break;
 		}
+	}
 
-		if (r >= 0 && WaitForDoorbellInt(iocp, 10, sleepFlag) >= 0)
-			r = 0;
-		else
-			r = -4;
+	dhsprintk((KERN_WARNING MYNAM ": %s: mpt_send_handshake_request reqBytes=%d sent, WaitForDoorbellInt\n",
+		ioc->name, reqBytes));
+	if (r >= 0 && WaitForDoorbellInt(ioc, 10, sleepFlag) >= 0)
+		r = 0;
+	else
+		r = -4;
 
-		/* Make sure there are no doorbells */
-		CHIPREG_WRITE32(&iocp->chip->IntStatus, 0);
-	}
+	/* Make sure there are no doorbells */
+	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
 
 	return r;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
- *	mpt_adapter_find_first - Find first MPT adapter pointer.
+ * mpt_host_page_access_control - provides mechanism for the host
+ * driver to control the IOC's Host Page Buffer access.
+ * @ioc: Pointer to MPT adapter structure
+ * @access_control_value: define bits below
+ *
+ * Access Control Value - bits[15:12]
+ * 0h Reserved
+ * 1h Enable Access { MPI_DB_HPBAC_ENABLE_ACCESS }
+ * 2h Disable Access { MPI_DB_HPBAC_DISABLE_ACCESS }
+ * 3h Free Buffer { MPI_DB_HPBAC_FREE_BUFFER }
  *
- *	Returns first MPT adapter pointer or %NULL if no MPT adapters
- *	are present.
+ * Returns 0 for success, non-zero for failure.
  */
-MPT_ADAPTER *
-mpt_adapter_find_first(void)
+
+int
+mpt_host_page_access_control(MPT_ADAPTER *ioc, u8 access_control_value, int sleepFlag)
 {
-	MPT_ADAPTER *this = NULL;
+	int	 r = 0;
+
+	/* return if in use */
+	if (CHIPREG_READ32(&ioc->chip->Doorbell)
+	    & MPI_DOORBELL_ACTIVE)
+	    return -1;
+
+	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
 
-	if (! Q_IS_EMPTY(&MptAdapters))
-		this = MptAdapters.head;
+	CHIPREG_WRITE32(&ioc->chip->Doorbell,
+		((MPI_FUNCTION_HOST_PAGEBUF_ACCESS_CONTROL
+		 <<MPI_DOORBELL_FUNCTION_SHIFT) |
+		 (access_control_value<<12)));
 
-	return this;
+	/* Wait for IOC to clear Doorbell Status bit */
+	if ((r = WaitForDoorbellAck(ioc, 5, sleepFlag)) < 0) {
+		return -2;
+	}
+	return r;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
- *	mpt_adapter_find_next - Find next MPT adapter pointer.
- *	@prev: Pointer to previous MPT adapter
+ *	mpt_host_page_alloc - allocate system memory for the fw
+ *	If we already allocated memory in past, then resend the same pointer.
+ *	ioc@: Pointer to pointer to IOC adapter
+ *	ioc_init@: Pointer to ioc init config page
  *
- *	Returns next MPT adapter pointer or %NULL if there are no more.
+ *	Returns 0 for success, non-zero for failure.
  */
-MPT_ADAPTER *
-mpt_adapter_find_next(MPT_ADAPTER *prev)
+static int
+mpt_host_page_alloc(MPT_ADAPTER *ioc, pIOCInit_t ioc_init)
 {
-	MPT_ADAPTER *next = NULL;
+	char	*psge;
+	int	flags_length;
+	u32	host_page_buffer_sz=0;
+
+	if(!ioc->HostPageBuffer) {
+
+		host_page_buffer_sz =
+		    (ioc->facts.HostPageBufferSGE.FlagsLength & 0xFFFFFF);
+
+		if(!host_page_buffer_sz) 
+			return 0; /* fw doesn't need any host buffers */
+			
+		/* spin till we get enough memory */
+		while(host_page_buffer_sz > 0) {
+		
+			if((ioc->HostPageBuffer = pci_alloc_consistent(
+			    ioc->pcidev, 
+			    host_page_buffer_sz,
+			    &ioc->HostPageBuffer_dma)) != NULL) {
+		
+				dinitprintk((MYIOC_s_WARN_FMT
+				    "host_page_buffer=%p allocated_size=%d \n",
+				    ioc->name, ioc->HostPageBuffer,
+				    host_page_buffer_sz));
+				ioc->alloc_total += host_page_buffer_sz;
+				ioc->HostPageBuffer_sz = host_page_buffer_sz;
+				break;
+			}
+			
+			host_page_buffer_sz -= (4*1024);	
+		}
+	}
+
+	if(!ioc->HostPageBuffer) {
+		printk(MYIOC_s_ERR_FMT
+		    "Failed to alloc memory for host_page_buffer!\n",
+		    ioc->name);
+		return -999;
+	}
 
-	if (prev && (prev->forw != (MPT_ADAPTER*)&MptAdapters.head))
-		next = prev->forw;
+	psge = (char *)&ioc_init->HostPageBufferSGE;
+	flags_length = MPI_SGE_FLAGS_SIMPLE_ELEMENT |
+	    MPI_SGE_FLAGS_SYSTEM_ADDRESS |
+	    MPI_SGE_FLAGS_32_BIT_ADDRESSING |
+	    MPI_SGE_FLAGS_HOST_TO_IOC |
+	    MPI_SGE_FLAGS_END_OF_BUFFER;
+	if (sizeof(dma_addr_t) == sizeof(u64)) {
+	    flags_length |= MPI_SGE_FLAGS_64_BIT_ADDRESSING;
+	}
+	flags_length = flags_length << MPI_SGE_FLAGS_SHIFT;
+	flags_length |= ioc->HostPageBuffer_sz;
+	mpt_add_sge(psge, flags_length, ioc->HostPageBuffer_dma);
+	ioc->facts.HostPageBufferSGE = 
+	    ioc_init->HostPageBufferSGE;
 
-	return next;
+	return 0;
 }
 
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *	mpt_pci_scan - Scan PCI devices for MPT adapters.
@@ -1154,29 +1146,17 @@ mpt_pci_scan(void)
 	int count = 0;
 	int r;
 
-	dprintk((KERN_INFO MYNAM ": Checking for MPT adapters...\n"));
+	dinitprintk((KERN_INFO MYNAM ": Checking for MPT adapters...\n"));
 
 	/*
-	 *  NOTE: The 929, 929X, 1030 and 1035 will appear as 2 separate PCI devices,
-	 *  one for each channel.
+	 *  NOTE: The 929, 929X, 1030 and 1035 will appear as 2 separate PCI 
+	 *  devices, one for each channel.
 	 */
 	pci_for_each_dev(pdev) {
 		pdev2 = NULL;
 		if (pdev->vendor != 0x1000)
 			continue;
 
-		if ((pdev->device != MPI_MANUFACTPAGE_DEVICEID_FC909) &&
-		    (pdev->device != MPI_MANUFACTPAGE_DEVICEID_FC929) &&
-		    (pdev->device != MPI_MANUFACTPAGE_DEVICEID_FC919) &&
-		    (pdev->device != MPI_MANUFACTPAGE_DEVICEID_FC929X) &&
-		    (pdev->device != MPI_MANUFACTPAGE_DEVICEID_FC919X) &&
-		    (pdev->device != MPI_MANUFACTPAGE_DEVID_53C1030) &&
-		    (pdev->device != MPI_MANUFACTPAGE_DEVID_1030_53C1035) &&
-		    1) {
-			dprintk((KERN_INFO MYNAM ": Skipping LSI device=%04xh\n", pdev->device));
-			continue;
-		}
-
 		/* GRRRRR
 		 * dual function devices (929, 929X, 1030, 1035) may be presented in Func 1,0 order,
 		 * but we'd really really rather have them in Func 0,1 order.
@@ -1189,21 +1169,23 @@ mpt_pci_scan(void)
 			    (pdev2->device == pdev->device) &&
 			    (pdev2->bus->number == pdev->bus->number) &&
 			    !(pdev2->devfn & 1)) {
-				dprintk((KERN_INFO MYNAM ": MPT adapter found: PCI bus/dfn=%02x/%02xh, class=%08x, id=%xh\n",
-					pdev2->bus->number, pdev2->devfn, pdev2->class, pdev2->device));
-				found++;
-				if ((r = mpt_adapter_install(pdev2)) == 0)
+				if ((r = mpt_adapter_install(pdev2)) == 0) {
 					count++;
+					found++;
+				} else if (r < 0) {
+					found++;
+				}
 			} else {
 				pdev2 = NULL;
 			}
 		}
 
-		dprintk((KERN_INFO MYNAM ": MPT adapter found: PCI bus/dfn=%02x/%02xh, class=%08x, id=%xh\n",
-			 pdev->bus->number, pdev->devfn, pdev->class, pdev->device));
-		found++;
-		if ((r = mpt_adapter_install(pdev)) == 0)
+		if ((r = mpt_adapter_install(pdev)) == 0) {
 			count++;
+			found++;
+		} else if (r < 0) {
+			found++;
+		}
 
 		if (pdev2)
 			pdev = pdev2;
@@ -1236,18 +1218,17 @@ mpt_pci_scan(void)
 int
 mpt_verify_adapter(int iocid, MPT_ADAPTER **iocpp)
 {
-	MPT_ADAPTER *p;
+	MPT_ADAPTER *ioc;
 
+	list_for_each_entry(ioc,&ioc_list,list) {
+		if (iocid == ioc->id) {
+			*iocpp = ioc;
+			return iocid;
+		}
+	}
 	*iocpp = NULL;
-	if (iocid >= MPT_MAX_ADAPTERS)
-		return -1;
-
-	p = mpt_adapters[iocid];
-	if (p == NULL)
-		return -1;
+	return -1;
 
-	*iocpp = p;
-	return iocid;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -1263,7 +1244,7 @@ mpt_verify_adapter(int iocid, MPT_ADAPTE
  *	This routine also pre-fetches the LAN MAC address of a Fibre Channel
  *	MPT adapter.
  *
- *	Returns 0 for success, non-zero for failure.
+ *	Returns 0 for success, 1 for a LSI non-mpt adapter, <  0 for failure.
  *
  *	TODO: Add support for polled controllers
  */
@@ -1272,23 +1253,140 @@ mpt_adapter_install(struct pci_dev *pdev
 {
 	MPT_ADAPTER	*ioc;
 	u8		*mem;
+	char		*prod_name;
 	unsigned long	 mem_phys;
 	unsigned long	 port;
 	u32		 msize;
 	u32		 psize;
 	int		 ii;
 	int		 r = -ENODEV;
-	u64		 mask = 0xffffffffffffffff;
+	u64		 mask = 0xffffffffffffffffULL;
+	static int	 mpt_ids = 0;
+	u8		 pcixcmd;
+	u8		 revision;
+	u8		 bus_type, errata_flag=0;
 
-	if (pci_enable_device(pdev))
-		return r;
+	pci_read_config_byte(pdev, PCI_CLASS_REVISION, &revision);
 
-	if (!pci_set_dma_mask(pdev, mask)) {
-		dprintk((KERN_INFO MYNAM 
-			": 64 BIT PCI BUS DMA ADDRESSING SUPPORTED\n"));
-	} else if (pci_set_dma_mask(pdev, (u64) 0xffffffff)) {
-		printk(KERN_WARNING MYNAM ": 32 BIT PCI BUS DMA ADDRESSING NOT SUPPORTED\n");
-		return r;
+	if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_FC909) {
+		prod_name = "LSIFC909";
+		bus_type = FC;
+	}
+	else if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_FC929) {
+		prod_name = "LSIFC929";
+		bus_type = FC;
+	}
+	else if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_FC919) {
+		prod_name = "LSIFC919";
+		bus_type = FC;
+	}
+	else if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_FC929X) {
+		bus_type = FC;
+		if (revision < XL_929) {
+			prod_name = "LSIFC929X";
+			/* 929X Chip Fix. Set Split transactions level
+	 		* for PCIX. Set MOST bits to zero.
+		 	*/
+			pci_read_config_byte(pdev, 0x6a, &pcixcmd);
+			pcixcmd &= 0x8F;
+			pci_write_config_byte(pdev, 0x6a, pcixcmd);
+		} else {
+			prod_name = "LSIFC929XL";
+			/* 929XL Chip Fix. Set MMRBC to 0x08.
+		 	*/
+/*			Commented out per Jeff Rogers e-mail 4/7/2005
+			pci_read_config_byte(pdev, 0x6a, &pcixcmd);
+			pcixcmd |= 0x08;
+			pci_write_config_byte(pdev, 0x6a, pcixcmd); */
+		}
+	}
+	else if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_FC919X) {
+		prod_name = "LSIFC919X";
+		bus_type = FC;
+		/* 919X Chip Fix. Set Split transactions level
+		 * for PCIX. Set MOST bits to zero.
+		 */
+		pci_read_config_byte(pdev, 0x6a, &pcixcmd);
+		pcixcmd &= 0x8F;
+		pci_write_config_byte(pdev, 0x6a, pcixcmd);
+	}
+	else if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_FC939X) {
+		prod_name = "LSIFC939X";
+		bus_type = FC;
+		errata_flag = 1;
+	}
+	else if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_FC949X) {
+		prod_name = "LSIFC949X";
+		bus_type = FC;
+		errata_flag = 1;
+	}
+	else if (pdev->device == MPI_MANUFACTPAGE_DEVID_53C1030) {
+		prod_name = "LSI53C1030";
+		bus_type = SCSI;
+		/* 1030 Chip Fix. Disable Split transactions
+		 * for PCIX. Set MOST bits to zero if Rev < C0( = 8).
+		 */
+		if (revision < C0_1030) {
+			pci_read_config_byte(pdev, 0x6a, &pcixcmd);
+			pcixcmd &= 0x8F;
+			pci_write_config_byte(pdev, 0x6a, pcixcmd);
+		}
+	}
+	else if (pdev->device == MPI_MANUFACTPAGE_DEVID_1030_53C1035) {
+		prod_name = "LSI53C1035";
+		bus_type = SCSI;
+	}
+	else if (pdev->device == MPI_MANUFACTPAGE_DEVID_SAS1064) {
+		prod_name = "LSISAS1064";
+		bus_type = SAS;
+		errata_flag = 1;
+	}
+	else if (pdev->device == MPI_MANUFACTPAGE_DEVID_SAS1066) {
+		prod_name = "LSISAS1066";
+		bus_type = SAS;
+		errata_flag = 1;
+	}
+	else if (pdev->device == MPI_MANUFACTPAGE_DEVID_SAS1068) {
+		prod_name = "LSISAS1068";
+		bus_type = SAS;
+		errata_flag = 1;
+	}
+	else if (pdev->device == MPI_MANUFACTPAGE_DEVID_SAS1064E) {
+		prod_name = "LSISAS1064E";
+		bus_type = SAS;
+	}
+	else if (pdev->device == MPI_MANUFACTPAGE_DEVID_SAS1066E) {
+		prod_name = "LSISAS1066E";
+		bus_type = SAS;
+	}
+	else if (pdev->device == MPI_MANUFACTPAGE_DEVID_SAS1068E) {
+		prod_name = "LSISAS1068E";
+		bus_type = SAS;
+	} else {
+		dinitprintk((KERN_INFO MYNAM ": Skipping LSI device=%04xh\n", pdev->device));
+		return 1;
+	}
+
+	dinitprintk((KERN_INFO MYNAM ": MPT adapter found PCI bus/dfn=%02x/%02xh, class=%08x, id=%xh\n",
+		 pdev->bus->number, pdev->devfn, pdev->class, pdev->device));
+
+	if (pci_enable_device(pdev))
+		return r;
+
+	dinitprintk((KERN_INFO MYNAM ": mpt_adapter_install\n"));
+
+	/* For some kernels, broken kernel limits memory allocation for target mode
+	 * driver. Shirron. Fixed in 2.4.20-8
+	 * if ((sizeof(dma_addr_t) == sizeof(u64)) && (!pci_set_dma_mask(pdev, mask)))
+	 */
+	if ((!pci_set_dma_mask(pdev, mask))) {
+		dprintk((KERN_INFO MYNAM ": 64 BIT PCI BUS DMA ADDRESSING SUPPORTED\n"));
+	} else {
+		if (pci_set_dma_mask(pdev, (u64) 0xffffffff)) {
+			printk(KERN_WARNING MYNAM
+				": 32 BIT PCI BUS DMA ADDRESSING NOT SUPPORTED\n");
+			return r;
+		}
 	}
 
 	ioc = kmalloc(sizeof(MPT_ADAPTER), GFP_ATOMIC);
@@ -1296,10 +1394,14 @@ mpt_adapter_install(struct pci_dev *pdev
 		printk(KERN_ERR MYNAM ": ERROR - Insufficient memory to add adapter!\n");
 		return -ENOMEM;
 	}
-	memset(ioc, 0, sizeof(*ioc));
+	memset(ioc, 0, sizeof(MPT_ADAPTER));
+
+	ioc->prod_name = prod_name;
+	ioc->bus_type = bus_type;
+	ioc->errata_flag_1064 = errata_flag;
 	ioc->alloc_total = sizeof(MPT_ADAPTER);
 	ioc->req_sz = MPT_DEFAULT_FRAME_SIZE;		/* avoid div by zero! */
-	ioc->reply_sz = ioc->req_sz;
+	ioc->reply_sz = MPT_REPLY_FRAME_SIZE;
 
 	ioc->pcidev = pdev;
 	ioc->diagPending = 0;
@@ -1318,6 +1420,15 @@ mpt_adapter_install(struct pci_dev *pdev
 
 	ioc->cached_fw = NULL;
 
+	for ( ii = 0; ii < MPI_DIAG_BUF_TYPE_COUNT; ii++) {
+		ioc->DiagBuffer[ii] = NULL;
+		ioc->DiagBuffer_Status[ii] = 0;
+	}
+
+	/* initialize the SAS device list */
+
+	INIT_LIST_HEAD(&ioc->sasDeviceList);
+
 	/* Initilize SCSI Config Data structure
 	 */
 	memset(&ioc->spi_data, 0, sizeof(ScsiCfgData));
@@ -1325,19 +1436,16 @@ mpt_adapter_install(struct pci_dev *pdev
 	/* Initialize the running configQ head.
 	 */
 	Q_INIT(&ioc->configQ, Q_ITEM);
+	/* Initialize the free Message Frame Q.
+	*/
+	Q_INIT(&ioc->FreeQ, MPT_FRAME_HDR);
+	/* Initialize the free chain Q.
+	*/
+	Q_INIT(&ioc->FreeChainQ, MPT_FRAME_HDR);
 
 	/* Find lookup slot. */
-	for (ii=0; ii < MPT_MAX_ADAPTERS; ii++) {
-		if (mpt_adapters[ii] == NULL) {
-			ioc->id = ii;		/* Assign adapter unique id (lookup) */
-			break;
-		}
-	}
-	if (ii == MPT_MAX_ADAPTERS) {
-		printk(KERN_ERR MYNAM ": ERROR - mpt_adapters[%d] table overflow!\n", ii);
-		kfree(ioc);
-		return -ENFILE;
-	}
+	INIT_LIST_HEAD(&ioc->list);
+	ioc->id = mpt_ids++;
 
 	mem_phys = msize = 0;
 	port = psize = 0;
@@ -1354,16 +1462,22 @@ mpt_adapter_install(struct pci_dev *pdev
 		}
 	}
 	ioc->mem_size = msize;
+	ioc->deviceID = pdev->device;
+	ioc->vendorID = pdev->vendor;
+	ioc->subSystemVendorID = pdev->subsystem_vendor;
+	ioc->subSystemID = pdev->subsystem_device;
+	ioc->revisionID = revision;
 
 	if (ii == DEVICE_COUNT_RESOURCE) {
 		printk(KERN_ERR MYNAM ": ERROR - MPT adapter has no memory regions defined!\n");
-		kfree(ioc);
+//		kfree(ioc);
 		return -EINVAL;
 	}
 
-	dprintk((KERN_INFO MYNAM ": MPT adapter @ %lx, msize=%dd bytes\n", mem_phys, msize));
-	dprintk((KERN_INFO MYNAM ": (port i/o @ %lx, psize=%dd bytes)\n", port, psize));
-	dprintk((KERN_INFO MYNAM ": Using %s register access method\n", PortIo ? "PortIo" : "MemMap"));
+	dinitprintk((KERN_INFO MYNAM ": MPT adapter @ %lx, msize=%dd bytes\n", mem_phys, msize));
+//	dinitprintk((KERN_ERR MYNAM ": MPT adapter @ %lx, msize=%dd bytes\n", mem_phys, msize));
+	dinitprintk((KERN_INFO MYNAM ": (port i/o @ %lx, psize=%dd bytes)\n", port, psize));
+	dinitprintk((KERN_INFO MYNAM ": Using %s register access method\n", PortIo ? "PortIo" : "MemMap"));
 
 	mem = NULL;
 	if (! PortIo) {
@@ -1377,9 +1491,9 @@ mpt_adapter_install(struct pci_dev *pdev
 		}
 		ioc->memmap = mem;
 	}
-	dprintk((KERN_INFO MYNAM ": mem = %p, mem_phys = %lx\n", mem, mem_phys));
+	dinitprintk((KERN_INFO MYNAM ": mem = %p, mem_phys = %lx\n", mem, mem_phys));
 
-	dprintk((KERN_INFO MYNAM ": facts @ %p, pfacts[0] @ %p\n",
+	dinitprintk((KERN_INFO MYNAM ": facts @ %p, pfacts[0] @ %p\n",
 			&ioc->facts, &ioc->pfacts[0]));
 	if (PortIo) {
 		u8 *pmem = (u8*)port;
@@ -1390,92 +1504,28 @@ mpt_adapter_install(struct pci_dev *pdev
 		ioc->chip = (SYSIF_REGS*)mem;
 	}
 
-	/* Save Port IO values incase we need to do downloadboot */
+	/* Save Port IO values in case we need to do downloadboot */
 	{
 		u8 *pmem = (u8*)port;
 		ioc->pio_mem_phys = port;
 		ioc->pio_chip = (SYSIF_REGS*)pmem;
 	}
 
-	ioc->chip_type = FCUNK;
-	if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_FC909) {
-		ioc->chip_type = FC909;
-		ioc->prod_name = "LSIFC909";
-	}
-	else if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_FC929) {
-		ioc->chip_type = FC929;
-		ioc->prod_name = "LSIFC929";
-	}
-	else if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_FC919) {
-		ioc->chip_type = FC919;
-		ioc->prod_name = "LSIFC919";
-	}
-	else if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_FC929X) {
-		ioc->chip_type = FC929X;
-		ioc->prod_name = "LSIFC929X";
-		{
-			/* 929X Chip Fix. Set Split transactions level
-			 * for PCIX. Set bits 5 - 6 to zero, turn on bit 4.
-			 */
-			u16 pcixcmd = 0;
-			pci_read_config_word(pdev, 0x6a, &pcixcmd);
-			pcixcmd &= 0xFF9F;
-			pcixcmd |= 0x0010;
-			pci_write_config_word(pdev, 0x6a, pcixcmd);
-		}
-	}
-	else if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_FC919X) {
-		ioc->chip_type = FC919X;
-		ioc->prod_name = "LSIFC919X";
-		{
-			/* 919X Chip Fix. Set Split transactions level
-			 * for PCIX. Set bits 5 - 6 to zero, turn on bit 4.
-			 */
-			u16 pcixcmd = 0;
-			pci_read_config_word(pdev, 0x6a, &pcixcmd);
-			pcixcmd &= 0xFF9F;
-			pcixcmd |= 0x0010;
-			pci_write_config_word(pdev, 0x6a, pcixcmd);
-		}
-	}
-	else if (pdev->device == MPI_MANUFACTPAGE_DEVID_53C1030) {
-		ioc->chip_type = C1030;
-		ioc->prod_name = "LSI53C1030";
-		{
-			u8 revision;
-
-			/* 1030 Chip Fix. Disable Split transactions
-			 * for PCIX. Set bits 4 - 6 to zero if Rev < C0( = 8)
-			 */
-			pci_read_config_byte(pdev, PCI_CLASS_REVISION, &revision);
-			if (revision < 0x08) {
-				u16 pcixcmd = 0;
-				pci_read_config_word(pdev, 0x6a, &pcixcmd);
-				pcixcmd &= 0xFF8F;
-				pci_write_config_word(pdev, 0x6a, pcixcmd);
-			}
-		}
-	}
-	else if (pdev->device == MPI_MANUFACTPAGE_DEVID_1030_53C1035) {
-		ioc->chip_type = C1035;
-		ioc->prod_name = "LSI53C1035";
-	}
-
 	sprintf(ioc->name, "ioc%d", ioc->id);
 
-	Q_INIT(&ioc->FreeQ, MPT_FRAME_HDR);
 	spin_lock_init(&ioc->FreeQlock);
 
+	if(ioc->errata_flag_1064) {
+		pci_disable_io_access(pdev);
+	}
+	
 	/* Disable all! */
 	CHIPREG_WRITE32(&ioc->chip->IntMask, 0xFFFFFFFF);
 	ioc->active = 0;
 	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
 
-	/* tack onto tail of our MPT adapter list */
-	Q_ADD_TAIL(&MptAdapters, ioc, MPT_ADAPTER);
-
 	/* Set lookup ptr. */
-	mpt_adapters[ioc->id] = ioc;
+	list_add_tail(&ioc->list, &ioc_list);
 
 	ioc->pci_irq = -1;
 	if (pdev->irq) {
@@ -1489,8 +1539,7 @@ mpt_adapter_install(struct pci_dev *pdev
 			printk(MYIOC_s_ERR_FMT "Unable to allocate interrupt %s!\n",
 					ioc->name, __irq_itoa(pdev->irq));
 #endif
-			Q_DEL_ITEM(ioc);
-			mpt_adapters[ioc->id] = NULL;
+			list_del(&ioc->list);
 			iounmap(mem);
 			kfree(ioc);
 			return -EBUSY;
@@ -1507,19 +1556,16 @@ mpt_adapter_install(struct pci_dev *pdev
 #endif
 	}
 
-	/* NEW!  20010220 -sralston
-	 * Check for "bound ports" (929, 929X, 1030, 1035) to reduce redundant resets.
+	/* Check for "bound ports" (929, 929X, 1030, 1035) to reduce redundant resets.
 	 */
-	if ((ioc->chip_type == FC929) || (ioc->chip_type == C1030) 
-			|| (ioc->chip_type == C1035) || (ioc->chip_type == FC929X))
-		mpt_detect_bound_ports(ioc, pdev);
+	mpt_detect_bound_ports(ioc, pdev);
 
 	if ((r = mpt_do_ioc_recovery(ioc, MPT_HOSTEVENT_IOC_BRINGUP, CAN_SLEEP)) != 0) {
 		printk(KERN_WARNING MYNAM ": WARNING - %s did not initialize properly! (%d)\n",
 				ioc->name, r);
 	}
 
-	return r;
+	return 0;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -1548,23 +1594,43 @@ mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u3
 	int	 hard_reset_done = 0;
 	int	 alt_ioc_ready = 0;
 	int	 hard;
-	int	 r;
+	int	 rc = 0;
 	int	 ii;
-	int	 handlers;
+	int	 ret = 0;
+	int	 reset_alt_ioc_active = 0;
 
-	printk(KERN_INFO MYNAM ": Initiating %s %s\n",
+	printk(KERN_WARNING MYNAM ": Initiating %s %s\n",
 			ioc->name, reason==MPT_HOSTEVENT_IOC_BRINGUP ? "bringup" : "recovery");
 
-	/* Disable reply interrupts */
+	/* Disable reply interrupts (also blocks FreeQ) */
 	CHIPREG_WRITE32(&ioc->chip->IntMask, 0xFFFFFFFF);
 	ioc->active = 0;
-	/* NOTE: Access to IOC's request FreeQ is now blocked! */
 
 	if (ioc->alt_ioc) {
-		/* Disable alt-IOC's reply interrupts for a bit ... */
+		if (ioc->alt_ioc->active)
+			reset_alt_ioc_active = 1;
+
+		/* Disable alt-IOC's reply interrupts (and FreeQ) for a bit ... */
 		CHIPREG_WRITE32(&ioc->alt_ioc->chip->IntMask, 0xFFFFFFFF);
 		ioc->alt_ioc->active = 0;
-		/* NOTE: Access to alt-IOC's request FreeQ is now blocked! */
+	}
+
+	/* If an event notification has not returned
+	 * its request frame,
+	 * free resources associated with this request.
+	 */
+	if (ioc->evnp) {
+		drsprintk((MYIOC_s_WARN_FMT "do_ioc_recovery evnp=%p\n", 
+			ioc->name, ioc->evnp));
+		mpt_free_msg_frame(ioc, (MPT_FRAME_HDR *)ioc->evnp);
+		ioc->evnp = NULL;
+	}
+
+	if (ioc->alt_ioc && ioc->alt_ioc->evnp) {
+		drsprintk((MYIOC_s_WARN_FMT "altioc evnp=%p\n", 
+			ioc->alt_ioc->name, ioc->alt_ioc->evnp));
+		mpt_free_msg_frame(ioc->alt_ioc, (MPT_FRAME_HDR *)ioc->alt_ioc->evnp);
+		ioc->alt_ioc->evnp = NULL;
 	}
 
 	hard = 1;
@@ -1572,118 +1638,180 @@ mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u3
 		hard = 0;
 
 	if ((hard_reset_done = MakeIocReady(ioc, hard, sleepFlag)) < 0) {
-		printk(KERN_WARNING MYNAM ": %s NOT READY WARNING!\n",
-				ioc->name);
+		if (hard_reset_done == -4) {
+			printk(KERN_WARNING MYNAM ": %s Owned by PEER..skipping!\n",
+					ioc->name);
+
+			if (reset_alt_ioc_active && ioc->alt_ioc) {
+				/* (re)Enable alt-IOC! (reply interrupt, FreeQ) */
+				dprintk((KERN_INFO MYNAM ": alt-%s reply irq re-enabled\n",
+						ioc->alt_ioc->name));
+				CHIPREG_WRITE32(&ioc->alt_ioc->chip->IntMask, MPI_HIM_DIM);
+				ioc->alt_ioc->active = 1;
+			}
+
+		} else {
+			printk(KERN_WARNING MYNAM ": %s NOT READY WARNING!\n",
+					ioc->name);
+		}
 		return -1;
 	}
 
 	/* hard_reset_done = 0 if a soft reset was performed
 	 * and 1 if a hard reset was performed.
 	 */
-	if (hard_reset_done && ioc->alt_ioc) {
-		if ((r = MakeIocReady(ioc->alt_ioc, 0, sleepFlag)) == 0)
+	if (hard_reset_done && reset_alt_ioc_active && ioc->alt_ioc) {
+		if ((rc = MakeIocReady(ioc->alt_ioc, 0, sleepFlag)) == 0)
 			alt_ioc_ready = 1;
 		else
 			printk(KERN_WARNING MYNAM
-					": alt-%s: (%d) Not ready WARNING!\n",
-					ioc->alt_ioc->name, r);
+					": alt-%s: Not ready WARNING!\n",
+					ioc->alt_ioc->name);
 	}
 
-	/* Get IOC facts! */
-	if ((r = GetIocFacts(ioc, sleepFlag, reason)) != 0)
-		return -2;
-	if (reason == MPT_HOSTEVENT_IOC_BRINGUP) {
+	for (ii=0; ii<5; ii++) {
+		/* Get IOC facts! Allow 5 retries */
+		if ((rc = GetIocFacts(ioc, sleepFlag, reason)) == 0)
+			break;
+	}
+	
+
+	if (ii == 5) {
+		dinitprintk((MYIOC_s_WARN_FMT "Retry IocFacts failed rc=%x\n", ioc->name, rc));
+		ret = -2;
+	} else if (reason == MPT_HOSTEVENT_IOC_BRINGUP) {
 		MptDisplayIocCapabilities(ioc);
 	}
 
 	if (alt_ioc_ready) {
-		if ((r = GetIocFacts(ioc->alt_ioc, sleepFlag, reason)) != 0)
-			return -2;
-		if (reason == MPT_HOSTEVENT_IOC_BRINGUP) {
+		if ((rc = GetIocFacts(ioc->alt_ioc, sleepFlag, reason)) != 0) {
+			dinitprintk((MYIOC_s_WARN_FMT "Initial Alt IocFacts failed rc=%x\n", ioc->name, rc));
+			/* Retry - alt IOC was initialized once
+			 */
+			rc = GetIocFacts(ioc->alt_ioc, sleepFlag, reason);
+		}
+		if (rc) {
+			dinitprintk((MYIOC_s_WARN_FMT "Retry Alt IocFacts failed rc=%x\n", ioc->name, rc));
+			alt_ioc_ready = 0;
+			reset_alt_ioc_active = 0;
+		} else if (reason == MPT_HOSTEVENT_IOC_BRINGUP) {
 			MptDisplayIocCapabilities(ioc->alt_ioc);
 		}
 	}
 
-	/*
-	 * Prime reply & request queues!
+	/* Prime reply & request queues!
 	 * (mucho alloc's) Must be done prior to
 	 * init as upper addresses are needed for init.
+	 * If fails, continue with alt-ioc processing
 	 */
-	if ((r = PrimeIocFifos(ioc)) != 0)
-		return -3;
+	if ((ret == 0) && ((rc = PrimeIocFifos(ioc)) != 0))
+		ret = -3;
 
-	// May need to check/upload firmware & data here!
-	if ((r = SendIocInit(ioc, sleepFlag)) != 0)
-		return -4;
+	/* May need to check/upload firmware & data here!
+	 * If fails, continue with alt-ioc processing
+	 */
+	if ((ret == 0) && ((rc = SendIocInit(ioc, sleepFlag)) != 0))
+		ret = -4;
 // NEW!
-	if (alt_ioc_ready && ((r = PrimeIocFifos(ioc->alt_ioc)) != 0)) {
+	if (alt_ioc_ready && ((rc = PrimeIocFifos(ioc->alt_ioc)) != 0)) {
 		printk(KERN_WARNING MYNAM ": alt-%s: (%d) FIFO mgmt alloc WARNING!\n",
-				ioc->alt_ioc->name, r);
+				ioc->alt_ioc->name, rc);
 		alt_ioc_ready = 0;
+		reset_alt_ioc_active = 0;
 	}
 
 	if (alt_ioc_ready) {
-		if ((r = SendIocInit(ioc->alt_ioc, sleepFlag)) != 0) {
+		if ((rc = SendIocInit(ioc->alt_ioc, sleepFlag)) != 0) {
 			alt_ioc_ready = 0;
+			reset_alt_ioc_active = 0;
 			printk(KERN_WARNING MYNAM
 				": alt-%s: (%d) init failure WARNING!\n",
-					ioc->alt_ioc->name, r);
+					ioc->alt_ioc->name, rc);
 		}
 	}
 
 	if (reason == MPT_HOSTEVENT_IOC_BRINGUP){
 		if (ioc->upload_fw) {
-			ddlprintk((MYIOC_s_INFO_FMT
+			ddlprintk((MYIOC_s_WARN_FMT
 				"firmware upload required!\n", ioc->name));
 
-			r = mpt_do_upload(ioc, sleepFlag);
-			if (r != 0)
-				printk(KERN_WARNING MYNAM ": firmware upload failure!\n");
-			/* Handle the alt IOC too */
-			if ((alt_ioc_ready) && (ioc->alt_ioc->upload_fw)){
-				ddlprintk((MYIOC_s_INFO_FMT
-					"Alt-ioc firmware upload required!\n", 
-					ioc->name));
-				r = mpt_do_upload(ioc->alt_ioc, sleepFlag);
-				if (r != 0)
+			/* If ioc is not operational, cannot do upload
+			 */
+			if (ret == 0) {
+				rc = mpt_do_upload(ioc, sleepFlag);
+				if (rc == 0) {
+					if (ioc->alt_ioc && ioc->alt_ioc->cached_fw) {
+						ioc->cached_fw = NULL; /* Maintain only one pointer to FW memory so there will not be two attempt to downloadboot onboard dual function chips (mpt_adapter_disable, mpt_diag_reset) */
+						ddlprintk((MYIOC_s_WARN_FMT ": mpt_upload:  alt_%s has cached_fw=%p \n",
+							ioc->name, ioc->alt_ioc->name, ioc->alt_ioc->cached_fw));
+					}
+				} else {
 					printk(KERN_WARNING MYNAM ": firmware upload failure!\n");
+					ret = -5;
+				}
 			}
 		}
 	}
 
+	if (ret == 0) {
+		/* Enable! (reply interrupt) */
+		CHIPREG_WRITE32(&ioc->chip->IntMask, MPI_HIM_DIM);
+		ioc->active = 1;
+	}
 
-	/* Enable! (reply interrupt) */
-	CHIPREG_WRITE32(&ioc->chip->IntMask, ~(MPI_HIM_RIM));
-	ioc->active = 1;
-
-	if (ioc->alt_ioc) {
+	if (reset_alt_ioc_active && ioc->alt_ioc) {
 		/* (re)Enable alt-IOC! (reply interrupt) */
-		dprintk((KERN_INFO MYNAM ": alt-%s reply irq re-enabled\n",
+		dinitprintk((KERN_INFO MYNAM ": alt-%s reply irq re-enabled\n",
 				ioc->alt_ioc->name));
-		CHIPREG_WRITE32(&ioc->alt_ioc->chip->IntMask, ~(MPI_HIM_RIM));
+		CHIPREG_WRITE32(&ioc->alt_ioc->chip->IntMask, MPI_HIM_DIM);
 		ioc->alt_ioc->active = 1;
 	}
 
-	/* NEW!  20010120 -sralston
-	 *  Enable MPT base driver management of EventNotification
+	/*  Enable MPT base driver management of EventNotification
 	 *  and EventAck handling.
 	 */
-	if (!ioc->facts.EventState)
+	if ((ret == 0) && (!ioc->facts.EventState))
 		(void) SendEventNotification(ioc, 1);	/* 1=Enable EventNotification */
 
 	if (ioc->alt_ioc && alt_ioc_ready && !ioc->alt_ioc->facts.EventState)
 		(void) SendEventNotification(ioc->alt_ioc, 1);	/* 1=Enable EventNotification */
 
-	/* (Bugzilla:fibrebugs, #513)
-	 * Bug fix (part 2)!  20010905 -sralston
-	 *	Add additional "reason" check before call to GetLanConfigPages
+	/*	Add additional "reason" check before call to GetLanConfigPages
 	 *	(combined with GetIoUnitPage2 call).  This prevents a somewhat
 	 *	recursive scenario; GetLanConfigPages times out, timer expired
 	 *	routine calls HardResetHandler, which calls into here again,
 	 *	and we try GetLanConfigPages again...
 	 */
-	if (reason == MPT_HOSTEVENT_IOC_BRINGUP) {
-		if ((int)ioc->chip_type <= (int)FC929) {
+	if ((ret == 0) && (reason == MPT_HOSTEVENT_IOC_BRINGUP)) {
+		if(ioc->bus_type == SAS) {
+			mpt_findImVolumes(ioc);
+			/*
+			 * Pre-fetch SAS Address for each port
+			 */
+			GetManufPage5(ioc, ioc->facts.NumberOfPorts);
+
+			/*
+			 * Pre-fetch Serial number for the board.
+			 */
+			GetManufPage0(ioc);
+
+			/*
+			 * Pre-fetch Hw Link Rates. (These may get
+			 * overwritten so need to save them.)
+			 * Save other SAS data needed for Ioctls.
+			 */
+			mptbase_sas_get_info(ioc);
+
+			/* emoore@lsil.com - clear persistency table */
+			if(ioc->facts.IOCExceptions &
+			    MPI_IOCFACTS_EXCEPT_PERSISTENT_TABLE_FULL) {
+				ret = mptbase_sas_persist_operation(ioc,
+				    MPI_SAS_OP_CLEAR_NOT_PRESENT);
+				if(ret != 0)
+					return -1;
+			}
+
+		} else if(ioc->bus_type == FC) {
 			/*
 			 *  Pre-fetch FC port WWN and stuff...
 			 *  (FCPortPage0_t stuff)
@@ -1702,7 +1830,7 @@ mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u3
 #ifdef MPT_DEBUG
 				{
 					u8 *a = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;
-					dprintk((MYIOC_s_INFO_FMT "LanAddr = %02X:%02X:%02X:%02X:%02X:%02X\n",
+					dprintk((MYIOC_s_WARN_FMT "LanAddr = %02X:%02X:%02X:%02X:%02X:%02X\n",
 							ioc->name, a[5], a[4], a[3], a[2], a[1], a[0] ));
 				}
 #endif
@@ -1712,18 +1840,20 @@ mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u3
 			 */
 			mpt_GetScsiPortSettings(ioc, 0);
 
-			/* Get version and length of SDP 1 
+			/* Get version and length of SDP 1
 			 */
 			mpt_readScsiDevicePageHeaders(ioc, 0);
 
-			/* Find IM volumes 
+			/* Find IM volumes
 			 */
-			if (ioc->facts.MsgVersion >= 0x0102)
+			if (ioc->facts.MsgVersion >= MPI_VERSION_01_02)
 				mpt_findImVolumes(ioc);
 
 			/* Check, and possibly reset, the coalescing value
 			 */
 			mpt_read_ioc_pg_1(ioc);
+
+			mpt_read_ioc_pg_4(ioc);
 		}
 
 		GetIoUnitPage2(ioc);
@@ -1735,34 +1865,34 @@ mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u3
 	 * NOTE: If we're doing _IOC_BRINGUP, there can be no
 	 * MptResetHandlers[] registered yet.
 	 */
-	if (hard_reset_done) {
-		r = handlers = 0;
+	if (hard_reset_done && (ret == 0)) {
+		rc = 0;
 		for (ii=MPT_MAX_PROTOCOL_DRIVERS-1; ii; ii--) {
 			if (MptResetHandlers[ii]) {
-				dprintk((MYIOC_s_INFO_FMT "Calling IOC post_reset handler #%d\n",
-						ioc->name, ii));
-				r += (*(MptResetHandlers[ii]))(ioc, MPT_IOC_POST_RESET);
-				handlers++;
-
-				if (alt_ioc_ready) {
-					dprintk((MYIOC_s_INFO_FMT "Calling alt-%s post_reset handler #%d\n",
-							ioc->name, ioc->alt_ioc->name, ii));
-					r += (*(MptResetHandlers[ii]))(ioc->alt_ioc, MPT_IOC_POST_RESET);
-					handlers++;
-				}
+				rc += (*(MptResetHandlers[ii]))(ioc, MPT_IOC_POST_RESET);
+				drsprintk((MYIOC_s_WARN_FMT "Called MptResetHandlers=%p ii=%d for MPT_IOC_POST_RESET rc=%x\n",
+						ioc->name, 
+						MptResetHandlers[ii], ii, rc));
+			}
+
+			if (alt_ioc_ready && MptResetHandlers[ii]) {
+				rc += (*(MptResetHandlers[ii]))(ioc->alt_ioc, MPT_IOC_POST_RESET);
+				drsprintk((MYIOC_s_WARN_FMT "Called alt-%s MptResetHandlers=%p ii=%d for MPT_IOC_POST_RESET rc=%x\n",
+						ioc->name, ioc->alt_ioc->name,
+						MptResetHandlers[ii], ii, rc));
 			}
 		}
-		/* FIXME?  Examine results here? */
+		drsprintk((MYIOC_s_WARN_FMT "hard_reset_done: rc=%x for MPT_IOC_POST_RESET\n",
+			ioc->name, rc));
 	}
 
-	return 0;
+	return ret;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *	mpt_detect_bound_ports - Search for PCI bus/dev_function
- *	which matches PCI bus/dev_function (+/-1) for newly discovered 929,
- *	929X, 1030 or 1035.
+ *	which matches PCI bus/dev_function (+/-1): dual function HBAs.
  *	@ioc: Pointer to MPT adapter structure
  *	@pdev: Pointer to (struct pci_dev) structure
  *
@@ -1772,15 +1902,15 @@ mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u3
 static void
 mpt_detect_bound_ports(MPT_ADAPTER *ioc, struct pci_dev *pdev)
 {
-	MPT_ADAPTER *ioc_srch = mpt_adapter_find_first();
+	MPT_ADAPTER *ioc_srch;
 	unsigned int match_lo, match_hi;
 
 	match_lo = pdev->devfn-1;
 	match_hi = pdev->devfn+1;
-	dprintk((MYIOC_s_INFO_FMT "PCI bus/devfn=%x/%x, searching for devfn match on %x or %x\n",
+	dprintk((MYIOC_s_WARN_FMT "PCI bus/devfn=%x/%x, searching for devfn match on %x or %x\n",
 			ioc->name, pdev->bus->number, pdev->devfn, match_lo, match_hi));
 
-	while (ioc_srch != NULL) {
+	list_for_each_entry(ioc_srch, &ioc_list, list) {
 		struct pci_dev *_pcidev = ioc_srch->pcidev;
 
 		if ((_pcidev->device == pdev->device) &&
@@ -1788,178 +1918,229 @@ mpt_detect_bound_ports(MPT_ADAPTER *ioc,
 		    (_pcidev->devfn == match_lo || _pcidev->devfn == match_hi) ) {
 			/* Paranoia checks */
 			if (ioc->alt_ioc != NULL) {
-				printk(KERN_WARNING MYNAM ": Oops, already bound (%s <==> %s)!\n",
-						ioc->name, ioc->alt_ioc->name);
+				dinitprintk((KERN_INFO MYNAM ": Oops, already bound (%s <==> %s)!\n",
+						ioc->name, ioc->alt_ioc->name));
 				break;
 			} else if (ioc_srch->alt_ioc != NULL) {
-				printk(KERN_WARNING MYNAM ": Oops, already bound (%s <==> %s)!\n",
-						ioc_srch->name, ioc_srch->alt_ioc->name);
+				dinitprintk((KERN_INFO MYNAM ": Oops, already bound (%s <==> %s)!\n",
+						ioc_srch->name, ioc_srch->alt_ioc->name));
 				break;
 			}
-			dprintk((KERN_INFO MYNAM ": FOUND! binding %s <==> %s\n",
+			dinitprintk((KERN_INFO MYNAM ": FOUND! binding %s <==> %s\n",
 					ioc->name, ioc_srch->name));
 			ioc_srch->alt_ioc = ioc;
 			ioc->alt_ioc = ioc_srch;
 			break;
 		}
-		ioc_srch = mpt_adapter_find_next(ioc_srch);
 	}
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *	mpt_adapter_disable - Disable misbehaving MPT adapter.
- *	@this: Pointer to MPT adapter structure
- *	@free: Free up alloc'd reply, request, etc.
+ *	@ioc: Pointer to MPT adapter structure
  */
 static void
-mpt_adapter_disable(MPT_ADAPTER *this, int freeup)
+mpt_adapter_disable(MPT_ADAPTER *ioc)
 {
-	if (this != NULL) {
-		int sz;
-		u32 state;
-		int ret;
-
-		/* Disable the FW */
-		state = mpt_GetIocState(this, 1);
-		if (state == MPI_IOC_STATE_OPERATIONAL) {
-			SendIocReset(this, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET, NO_SLEEP);
-		}
-
-		if (this->cached_fw != NULL) {
-			ddlprintk((KERN_INFO MYNAM ": Pushing FW onto adapter\n"));
-
-			if ((ret = mpt_downloadboot(this, NO_SLEEP)) < 0) {
-				printk(KERN_WARNING MYNAM 
-					": firmware downloadboot failure (%d)!\n", ret);
-			}
+	sas_device_info_t *sasDevice, * pNext;
+	int sz;
+	int ret, ii;
+	void *			request_data;
+	dma_addr_t		request_data_dma;
+	u32			request_data_sz;
+
+	if (ioc->cached_fw != NULL) {
+		ddlprintk((KERN_INFO MYNAM ": mpt_adapter_disable: Pushing FW onto adapter\n"));
+		if ((ret = mpt_downloadboot(ioc, (MpiFwHeader_t *)ioc->cached_fw, NO_SLEEP)) < 0) {
+			printk(KERN_WARNING MYNAM
+				": firmware downloadboot failure (%d)!\n", ret);
 		}
+	}
 
-		/* Disable adapter interrupts! */
-		CHIPREG_WRITE32(&this->chip->IntMask, 0xFFFFFFFF);
-		this->active = 0;
-		/* Clear any lingering interrupt */
-		CHIPREG_WRITE32(&this->chip->IntStatus, 0);
-
-		if (freeup && this->reply_alloc != NULL) {
-			sz = (this->reply_sz * this->reply_depth) + 128;
-			pci_free_consistent(this->pcidev, sz,
-					this->reply_alloc, this->reply_alloc_dma);
-			this->reply_frames = NULL;
-			this->reply_alloc = NULL;
-			this->alloc_total -= sz;
-		}
+	/* Disable adapter interrupts! */
+	CHIPREG_WRITE32(&ioc->chip->IntMask, 0xFFFFFFFF);
+	ioc->active = 0;
+	/* Clear any lingering interrupt */
+	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
 
-		if (freeup && this->req_alloc != NULL) {
-			sz = (this->req_sz * this->req_depth) + 128;
-			/*
-			 *  Rounding UP to nearest 4-kB boundary here...
-			 */
-			sz = ((sz + 0x1000UL - 1UL) / 0x1000) * 0x1000;
-			pci_free_consistent(this->pcidev, sz,
-					this->req_alloc, this->req_alloc_dma);
-			this->req_frames = NULL;
-			this->req_alloc = NULL;
-			this->alloc_total -= sz;
-		}
+	for ( ii = 0; ii < MPI_DIAG_BUF_TYPE_COUNT; ii++) {
+		request_data = ioc->DiagBuffer[ii];
 
-		if (freeup && this->sense_buf_pool != NULL) {
-			sz = (this->req_depth * MPT_SENSE_BUFFER_ALLOC);
-			pci_free_consistent(this->pcidev, sz,
-					this->sense_buf_pool, this->sense_buf_pool_dma);
-			this->sense_buf_pool = NULL;
-			this->alloc_total -= sz;
+		if ( request_data ) {
+			request_data_sz = ioc->DiagBuffer_sz[ii];
+			request_data_dma = ioc->DiagBuffer_dma[ii];
+			dexitprintk((KERN_INFO MYNAM ": %s free DiagBuffer[%d] @ %p, sz=%d bytes\n",
+		 		ioc->name, ii, request_data, request_data_sz));
+			pci_free_consistent(ioc->pcidev, request_data_sz,
+				request_data,
+				request_data_dma);
+
+			ioc->DiagBuffer[ii] = NULL;
 		}
+	}
 
-		if (freeup && this->events != NULL){
-			sz = MPTCTL_EVENT_LOG_SIZE * sizeof(MPT_IOCTL_EVENTS);
-			kfree(this->events);
-			this->events = NULL;
-			this->alloc_total -= sz;
-		}
+	if (ioc->alloc != NULL) {
+		sz = ioc->alloc_sz;
+		dexitprintk((KERN_INFO MYNAM ": %s free alloc @ %p, sz=%d bytes\n",
+		 	ioc->name, ioc->alloc, ioc->alloc_sz));
+		pci_free_consistent(ioc->pcidev, sz,
+				ioc->alloc, ioc->alloc_dma);
+		ioc->reply_frames = NULL;
+		ioc->req_frames = NULL;
+		ioc->alloc = NULL;
+		ioc->alloc_total -= sz;
+	}
 
-		if (freeup && this->cached_fw != NULL) {
-			int ii = 0;
+	if (ioc->sense_buf_pool != NULL) {
+		sz = (ioc->req_depth * MPT_SENSE_BUFFER_ALLOC);
+		dexitprintk((KERN_INFO MYNAM ": %s free sense_buf_pool @ %p, sz=%d bytes\n",
+		 	ioc->name, ioc->sense_buf_pool, sz));
+		pci_free_consistent(ioc->pcidev, sz,
+				ioc->sense_buf_pool, ioc->sense_buf_pool_dma);
+		ioc->sense_buf_pool = NULL;
+		ioc->alloc_total -= sz;
+	}
 
-			while ((ii < this->num_fw_frags) && (this->cached_fw[ii]!= NULL)) {
-				sz = this->cached_fw[ii]->size;
-				pci_free_consistent(this->pcidev, sz,
-					this->cached_fw[ii]->fw, this->cached_fw[ii]->fw_dma);
-				this->cached_fw[ii]->fw = NULL;
-				this->alloc_total -= sz;
+	if (ioc->events != NULL){
+		sz = MPTCTL_EVENT_LOG_SIZE * sizeof(MPT_IOCTL_EVENTS);
+		dexitprintk((KERN_INFO MYNAM ": %s free events @ %p, sz=%d bytes\n",
+		 	ioc->name, ioc->events, sz));
+		kfree(ioc->events);
+		ioc->events = NULL;
+		ioc->alloc_total -= sz;
+	}
 
-				kfree(this->cached_fw[ii]);
-				this->cached_fw[ii] = NULL;
-				this->alloc_total -= sizeof(fw_image_t);
+	if (ioc->cached_fw != NULL) {
+		sz = ioc->facts.FWImageSize;
+		dexitprintk((KERN_INFO MYNAM ": %s free cached_fw @ %p, sz=%d bytes\n",
+		 	ioc->name, ioc->cached_fw, sz));
+		pci_free_consistent(ioc->pcidev, sz,
+			ioc->cached_fw, ioc->cached_fw_dma);
+		ioc->cached_fw = NULL;
+		ioc->alloc_total -= sz;
+	}
 
-				ii++;
-			}
+	if (ioc->spi_data.nvram != NULL) {
+		dexitprintk((KERN_INFO MYNAM ": %s free spi_data.nvram @ %p\n",
+		 	ioc->name, ioc->spi_data.nvram));
+		kfree(ioc->spi_data.nvram);
+		ioc->spi_data.nvram = NULL;
+	}
 
-			kfree(this->cached_fw);
-			this->cached_fw = NULL;
-			sz = this->num_fw_frags * sizeof(void *);
-			this->alloc_total -= sz;
-		}
+	if (ioc->spi_data.pIocPg3 != NULL) {
+		dexitprintk((KERN_INFO MYNAM ": %s free spi_data.pIocPg3 @ %p\n",
+		 	ioc->name, ioc->spi_data.pIocPg3));
+		kfree(ioc->spi_data.pIocPg3);
+		ioc->spi_data.pIocPg3 = NULL;
+	}
 
-		if (freeup && this->spi_data.nvram != NULL) {
-			kfree(this->spi_data.nvram);
-			this->spi_data.nvram = NULL;
-		}
+	if (ioc->spi_data.pIocPg4 != NULL) {
+		sz = ioc->spi_data.IocPg4Sz;
+		dexitprintk((KERN_INFO MYNAM ": %s free spi_data.pIocPg4 @ %p size=%d\n",
+		 	ioc->name, ioc->spi_data.pIocPg4, sz));
+		pci_free_consistent(ioc->pcidev, sz,
+			ioc->spi_data.pIocPg4,
+			ioc->spi_data.IocPg4_dma);
+		ioc->spi_data.pIocPg4 = NULL;
+		ioc->alloc_total -= sz;
+	}
 
-		if (freeup && this->spi_data.pIocPg3 != NULL) {
-			kfree(this->spi_data.pIocPg3);
-			this->spi_data.pIocPg3 = NULL;
-		}
+	if (ioc->ReqToChain != NULL) {
+		dexitprintk((KERN_INFO MYNAM ": %s free ReqToChain @ %p\n",
+		 	ioc->name, ioc->ReqToChain));
+		kfree(ioc->ReqToChain);
+		ioc->ReqToChain = NULL;
+	}
+
+	if (ioc->RequestNB != NULL) {
+		dexitprintk((KERN_INFO MYNAM ": %s free RequestNB @ %p\n",
+		 	ioc->name, ioc->RequestNB));
+		kfree(ioc->RequestNB);
+		ioc->RequestNB = NULL;
+	}
+
+	if (ioc->ChainToChain != NULL) {
+		dexitprintk((KERN_INFO MYNAM ": %s free ChainToChain @ %p\n",
+		 	ioc->name, ioc->ChainToChain));
+		kfree(ioc->ChainToChain);
+		ioc->ChainToChain = NULL;
+	}
+
+	if (ioc->sasPhyInfo != NULL) {
+		dexitprintk((KERN_INFO MYNAM ": %s free sasPhyInfo @ %p\n",
+		 	ioc->name, ioc->sasPhyInfo));
+		kfree(ioc->sasPhyInfo);
+		ioc->sasPhyInfo = NULL;
+	}
+
+	list_for_each_entry_safe(sasDevice, pNext, &ioc->sasDeviceList, list) {
+		list_del(&sasDevice->list);
+		dexitprintk((KERN_INFO MYNAM ": %s free sasDevice @ %p\n",
+		 	ioc->name, sasDevice));
+		kfree(sasDevice);
+	}
+
+/* emoore@lsil.com : Host Page Buffer Support, start */
+	if (ioc->HostPageBuffer != NULL) {
+		if((ret = mpt_host_page_access_control(ioc,
+		    MPI_DB_HPBAC_FREE_BUFFER, NO_SLEEP)) != 0) {
+			printk(KERN_ERR MYNAM
+			   ": %s: host page buffers free failed (%d)!\n",
+			    __FUNCTION__, ret);
+		}
+		dexitprintk((KERN_INFO MYNAM ": %s HostPageBuffer free  @ %p, sz=%d bytes\n",
+		 	ioc->name, ioc->HostPageBuffer, ioc->HostPageBuffer_sz));
+		pci_free_consistent(ioc->pcidev, ioc->HostPageBuffer_sz,
+				ioc->HostPageBuffer,
+				ioc->HostPageBuffer_dma);
+		ioc->HostPageBuffer = NULL;
+		ioc->HostPageBuffer_sz = 0;
+		ioc->alloc_total -= ioc->HostPageBuffer_sz;
 	}
+/* emoore@lsil.com : Host Page Buffer Support, end */
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *	mpt_adapter_dispose - Free all resources associated with a MPT
  *	adapter.
- *	@this: Pointer to MPT adapter structure
+ *	@ioc: Pointer to MPT adapter structure
  *
  *	This routine unregisters h/w resources and frees all alloc'd memory
  *	associated with a MPT adapter structure.
  */
 static void
-mpt_adapter_dispose(MPT_ADAPTER *this)
+mpt_adapter_dispose(MPT_ADAPTER *ioc)
 {
-	if (this != NULL) {
-		int sz_first, sz_last;
+	int sz_first, sz_last;
 
-		sz_first = this->alloc_total;
+	sz_first = ioc->alloc_total;
 
-		if (this->alt_ioc != NULL) {
-			this->alt_ioc->alt_ioc = NULL;
-			this->alt_ioc = NULL;
-		}
-
-		mpt_adapter_disable(this, 1);
+	mpt_adapter_disable(ioc);
 
-		if (this->pci_irq != -1) {
-			free_irq(this->pci_irq, this);
-			this->pci_irq = -1;
-		}
+	if (ioc->pci_irq != -1) {
+		free_irq(ioc->pci_irq, ioc);
+		ioc->pci_irq = -1;
+	}
 
-		if (this->memmap != NULL)
-			iounmap((u8 *) this->memmap);
+	if (ioc->memmap != NULL) {
+		iounmap((u8 *) ioc->memmap);
+		ioc->memmap = NULL;
+	}
 
 #if defined(CONFIG_MTRR) && 0
-		if (this->mtrr_reg > 0) {
-			mtrr_del(this->mtrr_reg, 0, 0);
-			dprintk((KERN_INFO MYNAM ": %s: MTRR region de-registered\n", this->name));
-		}
+	if (ioc->mtrr_reg > 0) {
+		mtrr_del(ioc->mtrr_reg, 0, 0);
+		dprintk((KERN_INFO MYNAM ": %s: MTRR region de-registered\n", ioc->name));
+	}
 #endif
 
-		/*  Zap the adapter lookup ptr!  */
-		mpt_adapters[this->id] = NULL;
+	sz_last = ioc->alloc_total;
+	dexitprintk((KERN_INFO MYNAM ": %s: free'd %d of %d bytes\n",
+			ioc->name, sz_first-sz_last+(int)sizeof(*ioc), sz_first));
+	kfree(ioc);
 
-		sz_last = this->alloc_total;
-		dprintk((KERN_INFO MYNAM ": %s: free'd %d of %d bytes\n",
-				this->name, sz_first-sz_last+(int)sizeof(*this), sz_first));
-		kfree(this);
-	}
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -2014,8 +2195,8 @@ MptDisplayIocCapabilities(MPT_ADAPTER *i
  *
  *	Returns:
  *		 1 - DIAG reset and READY
- *		 0 - READY initially OR soft reset and READY 
- *		-1 - Any failure on KickStart 
+ *		 0 - READY initially OR soft reset and READY
+ *		-1 - Any failure on KickStart
  *		-2 - Msg Unit Reset Failed
  *		-3 - IO Unit Reset Failed
  *		-4 - IOC owned by a PEER
@@ -2033,7 +2214,13 @@ MakeIocReady(MPT_ADAPTER *ioc, int force
 
 	/* Get current [raw] IOC state  */
 	ioc_state = mpt_GetIocState(ioc, 0);
-	dhsprintk((KERN_INFO MYNAM "::MakeIocReady, %s [raw] state=%08x\n", ioc->name, ioc_state));
+	dhsprintk((KERN_WARNING MYNAM "::MakeIocReady, %s [raw] state=%08x\n", ioc->name, ioc_state));
+
+
+	for ( ii = 0; ii < MPI_DIAG_BUF_TYPE_COUNT; ii++) {
+		ioc->DiagBuffer[ii] = NULL;
+		ioc->DiagBuffer_Status[ii] = 0;
+	}
 
 	/*
 	 *	Check to see if IOC got left/stuck in doorbell handshake
@@ -2047,18 +2234,9 @@ MakeIocReady(MPT_ADAPTER *ioc, int force
 
 	/* Is it already READY? */
 	if (!statefault && (ioc_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_READY) {
-		if ((int)ioc->chip_type <= (int)FC929)
+		if (ioc->bus_type != SAS)
 			return 0;
-		else {
-			/* Workaround from broken 1030 FW.
-			 * Force a diagnostic reset if fails.
-			 */
-			if ((r = SendIocReset(ioc, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET, sleepFlag)) == 0)
-				return 0;
-			else
-				statefault = 4;
-		}
-	} 
+	}
 
 	/*
 	 *	Check to see if IOC is in FAULT state.
@@ -2075,7 +2253,7 @@ MakeIocReady(MPT_ADAPTER *ioc, int force
 	 *	Hmmm...  Did it get left operational?
 	 */
 	if ((ioc_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_OPERATIONAL) {
-		dprintk((MYIOC_s_WARN_FMT "IOC operational unexpected\n",
+		dinitprintk((MYIOC_s_WARN_FMT "IOC operational unexpected\n",
 				ioc->name));
 
 		/* Check WhoInit.
@@ -2084,8 +2262,8 @@ MakeIocReady(MPT_ADAPTER *ioc, int force
 		 * Else, fall through to KickStart case
 		 */
 		whoinit = (ioc_state & MPI_DOORBELL_WHO_INIT_MASK) >> MPI_DOORBELL_WHO_INIT_SHIFT;
-		dprintk((KERN_WARNING MYNAM
-			": whoinit 0x%x\n statefault %d force %d\n",
+		dinitprintk((KERN_INFO MYNAM
+			": whoinit 0x%x statefault %d force %d\n",
 			whoinit, statefault, force));
 		if (whoinit == MPI_WHOINIT_PCI_PEER)
 			return -4;
@@ -2106,9 +2284,7 @@ MakeIocReady(MPT_ADAPTER *ioc, int force
 	 *  Loop here waiting for IOC to come READY.
 	 */
 	ii = 0;
-	cntdn = HZ * 15;
-	if (sleepFlag != CAN_SLEEP)
-		cntdn *= 10;	/* 1500 iterations @ 1msec per */
+	cntdn = ((sleepFlag == CAN_SLEEP) ? HZ : 1000) * 5;	/* 5 seconds */
 
 	while ((ioc_state = mpt_GetIocState(ioc, 1)) != MPI_IOC_STATE_READY) {
 		if (ioc_state == MPI_IOC_STATE_OPERATIONAL) {
@@ -2134,13 +2310,13 @@ MakeIocReady(MPT_ADAPTER *ioc, int force
 		ii++; cntdn--;
 		if (!cntdn) {
 			printk(MYIOC_s_ERR_FMT "Wait IOC_READY state timeout(%d)!\n",
-					ioc->name, (ii+5)/HZ);
+					ioc->name, (int)((ii+5)/HZ));
 			return -ETIME;
 		}
 
 		if (sleepFlag == CAN_SLEEP) {
 			set_current_state(TASK_INTERRUPTIBLE);
-			schedule_timeout(1);
+			schedule_timeout(1 * HZ / 1000);
 		} else {
 			mdelay (1);	/* 1 msec delay */
 		}
@@ -2148,9 +2324,9 @@ MakeIocReady(MPT_ADAPTER *ioc, int force
 	}
 
 	if (statefault < 3) {
-		printk(MYIOC_s_INFO_FMT "Recovered from %s\n",
+		dinitprintk((MYIOC_s_WARN_FMT "Recovered from %s\n",
 				ioc->name,
-				statefault==1 ? "stuck handshake" : "IOC FAULT");
+				statefault==1 ? "stuck handshake" : "IOC FAULT"));
 	}
 
 	return hard_reset_done;
@@ -2172,7 +2348,7 @@ mpt_GetIocState(MPT_ADAPTER *ioc, int co
 
 	/*  Get!  */
 	s = CHIPREG_READ32(&ioc->chip->Doorbell);
-//	dprintk((MYIOC_s_INFO_FMT "raw state = %08x\n", ioc->name, s));
+//	dprintk((MYIOC_s_WARN_FMT "raw state = %08x\n", ioc->name, s));
 	sc = s & MPI_IOC_STATE_MASK;
 
 	/*  Save!  */
@@ -2198,9 +2374,12 @@ GetIocFacts(MPT_ADAPTER *ioc, int sleepF
 	int			 r;
 	int			 req_sz;
 	int			 reply_sz;
-	u32			 status;
-
+	int			 sz;
+	u32			 status, vv;
+	u8			 shiftFactor=1;
+	
 	/* IOC *must* NOT be in RESET state! */
+	mpt_GetIocState(ioc, 1);
 	if (ioc->last_state == MPI_IOC_STATE_RESET) {
 		printk(KERN_ERR MYNAM ": ERROR - Can't get IOCFacts, %s NOT READY! (%08x)\n",
 				ioc->name,
@@ -2211,7 +2390,7 @@ GetIocFacts(MPT_ADAPTER *ioc, int sleepF
 	facts = &ioc->facts;
 
 	/* Destination (reply area)... */
-	reply_sz = sizeof(*facts);
+	reply_sz = sizeof(IOCFactsReply_t);
 	memset(facts, 0, reply_sz);
 
 	/* Request area (get_facts on the stack right now!) */
@@ -2221,15 +2400,17 @@ GetIocFacts(MPT_ADAPTER *ioc, int sleepF
 	get_facts.Function = MPI_FUNCTION_IOC_FACTS;
 	/* Assert: All other get_facts fields are zero! */
 
-	dprintk((MYIOC_s_INFO_FMT "Sending get IocFacts request\n", ioc->name));
+	dinitprintk((MYIOC_s_WARN_FMT "Sending get IocFacts request req_sz=%d reply_sz=%d\n", ioc->name, req_sz, reply_sz));
 
 	/* No non-zero fields in the get_facts request are greater than
 	 * 1 byte in size, so we can just fire it off as is.
 	 */
 	r = mpt_handshake_req_reply_wait(ioc, req_sz, (u32*)&get_facts,
-			reply_sz, (u16*)facts, 3 /*seconds*/, sleepFlag);
-	if (r != 0)
+			reply_sz, (u16*)facts, 5 /*seconds*/, sleepFlag);
+	if (r != 0) {
+		dinitprintk((MYIOC_s_WARN_FMT "IocFacts request failed with r=%x\n", ioc->name, r));
 		return r;
+	}
 
 	/*
 	 * Now byte swap (GRRR) the necessary fields before any further
@@ -2260,7 +2441,7 @@ GetIocFacts(MPT_ADAPTER *ioc, int sleepF
 		facts->RequestFrameSize = le16_to_cpu(facts->RequestFrameSize);
 
 		/*
-		 * FC f/w version changed between 1.1 and 1.2 
+		 * FC f/w version changed between 1.1 and 1.2
 		 *	Old: u16{Major(4),Minor(4),SubMinor(8)}
 		 *	New: u32{Major(8),Minor(8),Unit(8),Dev(8)}
 		 */
@@ -2283,6 +2464,7 @@ GetIocFacts(MPT_ADAPTER *ioc, int sleepF
 				le32_to_cpu(facts->CurrentSenseBufferHighAddr);
 		facts->CurReplyFrameSize =
 				le16_to_cpu(facts->CurReplyFrameSize);
+		facts->IOCCapabilities = le32_to_cpu(facts->IOCCapabilities);
 
 		/*
 		 * Handle NEW (!) IOCFactsReply fields in MPI-1.01.xx
@@ -2294,6 +2476,13 @@ GetIocFacts(MPT_ADAPTER *ioc, int sleepF
 			facts->FWImageSize = le32_to_cpu(facts->FWImageSize);
 		}
 
+		sz = facts->FWImageSize;
+		if ( sz & 0x01 )
+			sz += 1;
+		if ( sz & 0x02 )
+			sz += 2;
+		facts->FWImageSize = sz;
+
 		if (!facts->RequestFrameSize) {
 			/*  Something is wrong!  */
 			printk(MYIOC_s_ERR_FMT "IOC reported invalid 0 request size!\n",
@@ -2301,28 +2490,47 @@ GetIocFacts(MPT_ADAPTER *ioc, int sleepF
 			return -55;
 		}
 
-		if (reason == MPT_HOSTEVENT_IOC_BRINGUP) {
-			/*
-			 * Set values for this IOC's request & reply frame sizes,
-			 * and request & reply queue depths...
-			 */
-			ioc->req_sz = MIN(MPT_DEFAULT_FRAME_SIZE, facts->RequestFrameSize * 4);
-			ioc->req_depth = MIN(MPT_MAX_REQ_DEPTH, facts->GlobalCredits);
-			ioc->reply_sz = ioc->req_sz;
-			ioc->reply_depth = MIN(MPT_DEFAULT_REPLY_DEPTH, facts->ReplyQueueDepth);
-
-			dprintk((MYIOC_s_INFO_FMT "reply_sz=%3d, reply_depth=%4d\n",
-				ioc->name, ioc->reply_sz, ioc->reply_depth));
-			dprintk((MYIOC_s_INFO_FMT "req_sz  =%3d, req_depth  =%4d\n",
-				ioc->name, ioc->req_sz, ioc->req_depth));
-
-			/* Get port facts! */
-			if ( (r = GetPortFacts(ioc, 0, sleepFlag)) != 0 )
-				return r;
+		r = sz = facts->BlockSize;
+		vv = ((63 / (sz * 4)) + 1) & 0x03;
+		ioc->NB_for_64_byte_frame = vv;
+		while ( sz )
+		{
+			shiftFactor++;
+			sz = sz >> 1;
+		}
+		ioc->NBShiftFactor  = shiftFactor;
+		dinitprintk((MYIOC_s_WARN_FMT "NB_for_64_byte_frame=%x NBShiftFactor=%x BlockSize=%x\n",
+					ioc->name, vv, shiftFactor, r));
+
+		/*
+		 * Set values for this IOC's request & reply frame sizes,
+		 * and request & reply queue depths...
+		 */
+		ioc->reply_sz = MPT_REPLY_FRAME_SIZE;
+		if (mpt_reply_depth < facts->ReplyQueueDepth)
+			ioc->reply_depth = mpt_reply_depth;
+		else
+			ioc->reply_depth = facts->ReplyQueueDepth;
+
+		dinitprintk((MYIOC_s_WARN_FMT "reply_sz=%d mpt_reply_depth=%d ReplyQueueDepth=%d reply_depth=%d\n",
+			ioc->name, ioc->reply_sz, mpt_reply_depth, facts->ReplyQueueDepth, ioc->reply_depth));
+
+		ioc->req_sz = min(MPT_DEFAULT_FRAME_SIZE, facts->RequestFrameSize * 4);
+		if (mpt_can_queue+ioc->reply_depth+12 < facts->GlobalCredits)
+			ioc->req_depth = mpt_can_queue + ioc->reply_depth + 12;
+		else
+			ioc->req_depth = facts->GlobalCredits;
+		dinitprintk((MYIOC_s_WARN_FMT "req_sz=%d mpt_can_queue=%d GlobalCredits=%d req_depth=%d\n",
+			ioc->name, ioc->req_sz, mpt_can_queue, facts->GlobalCredits, ioc->req_depth));
+
+		/* Get port facts! */
+		if ( (r = GetPortFacts(ioc, 0, sleepFlag)) != 0 ) {
+			dinitprintk((MYIOC_s_WARN_FMT "GetPortFacts failed r=%x\n", ioc->name, r));
+			return r;
 		}
 	} else {
-		printk(MYIOC_s_ERR_FMT "Invalid IOC facts reply!\n",
-				ioc->name);
+		printk(MYIOC_s_ERR_FMT "Invalid IOC facts reply, msgLength=%d offsetof=%d!\n",
+				ioc->name, facts->MsgLength,(int)((offsetof(IOCFactsReply_t, RequestFrameSize)/sizeof(u32))));
 		return -66;
 	}
 
@@ -2369,14 +2577,14 @@ GetPortFacts(MPT_ADAPTER *ioc, int portn
 	get_pfacts.PortNumber = portnum;
 	/* Assert: All other get_pfacts fields are zero! */
 
-	dprintk((MYIOC_s_INFO_FMT "Sending get PortFacts(%d) request\n",
+	dinitprintk((MYIOC_s_WARN_FMT "Sending get PortFacts(%d) request\n",
 			ioc->name, portnum));
 
 	/* No non-zero fields in the get_pfacts request are greater than
 	 * 1 byte in size, so we can just fire it off as is.
 	 */
 	ii = mpt_handshake_req_reply_wait(ioc, req_sz, (u32*)&get_pfacts,
-				reply_sz, (u16*)pfacts, 3 /*seconds*/, sleepFlag);
+				reply_sz, (u16*)pfacts, 5 /*seconds*/, sleepFlag);
 	if (ii != 0)
 		return ii;
 
@@ -2420,41 +2628,49 @@ SendIocInit(MPT_ADAPTER *ioc, int sleepF
 	memset(&init_reply, 0, sizeof(init_reply));
 
 	ioc_init.WhoInit = MPI_WHOINIT_HOST_DRIVER;
-/*	ioc_init.ChainOffset = 0;			*/
 	ioc_init.Function = MPI_FUNCTION_IOC_INIT;
-/*	ioc_init.Flags = 0;				*/
 
 	/* If we are in a recovery mode and we uploaded the FW image,
 	 * then this pointer is not NULL. Skip the upload a second time.
 	 * Set this flag if cached_fw set for either IOC.
 	 */
-	ioc->upload_fw = 0;
-	ioc_init.Flags = 0;
-	if (ioc->facts.Flags & MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT) {
-		if ((ioc->cached_fw) || (ioc->alt_ioc && ioc->alt_ioc->cached_fw))
-			ioc_init.Flags = MPI_IOCINIT_FLAGS_DISCARD_FW_IMAGE;
-		else 
-			ioc->upload_fw = 1;
-	}
-	ddlprintk((MYIOC_s_INFO_FMT "flags %d, upload_fw %d \n", 
-		   ioc->name, ioc_init.Flags, ioc->upload_fw));
+	if (ioc->facts.Flags & MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT)
+		ioc->upload_fw = 1;
+	else
+		ioc->upload_fw = 0;
+	dinitprintk((MYIOC_s_WARN_FMT "upload_fw %d facts.Flags=%x\n",
+		   ioc->name, ioc->upload_fw, ioc->facts.Flags));
 
-	if ((int)ioc->chip_type <= (int)FC929) {
+	if(ioc->bus_type == SAS)
+		ioc_init.MaxDevices = ioc->facts.MaxDevices;
+	else if(ioc->bus_type == FC)
 		ioc_init.MaxDevices = MPT_MAX_FC_DEVICES;
-	} else {
+	else
 		ioc_init.MaxDevices = MPT_MAX_SCSI_DEVICES;
-	}
 	ioc_init.MaxBuses = MPT_MAX_BUS;
+	dinitprintk((MYIOC_s_WARN_FMT "facts.MsgVersion=%x\n",
+		   ioc->name, ioc->facts.MsgVersion));
+/* emoore@lsil.com : Host Page Buffer Support, start */
+	if (ioc->facts.MsgVersion >= MPI_VERSION_01_05) {
+		// set MsgVersion and HeaderVersion host driver was built with
+		ioc_init.MsgVersion = cpu_to_le16(MPI_VERSION);
+	        ioc_init.HeaderVersion = cpu_to_le16(MPI_HEADER_VERSION);
+		if (ioc->facts.Flags & MPI_IOCFACTS_FLAGS_HOST_PAGE_BUFFER_PERSISTENT) {
+			ioc_init.HostPageBufferSGE = ioc->facts.HostPageBufferSGE;
+		} else {
+			if(mpt_host_page_alloc(ioc, &ioc_init))
+				return -99;
+		}
+	}
+/* emoore@lsil.com : Host Page Buffer Support, end */
 
-/*	ioc_init.MsgFlags = 0;				*/
-/*	ioc_init.MsgContext = cpu_to_le32(0x00000000);	*/
 	ioc_init.ReplyFrameSize = cpu_to_le16(ioc->reply_sz);	/* in BYTES */
 
 	if (sizeof(dma_addr_t) == sizeof(u64)) {
 		/* Save the upper 32-bits of the request
 		 * (reply) and sense buffers.
 		 */
-		ioc_init.HostMfaHighAddr = cpu_to_le32((u32)((u64)ioc->req_frames_dma >> 32));
+		ioc_init.HostMfaHighAddr = cpu_to_le32((u32)((u64)ioc->alloc_dma >> 32));
 		ioc_init.SenseBufferHighAddr = cpu_to_le32((u32)((u64)ioc->sense_buf_pool_dma >> 32));
 	} else {
 		/* Force 32-bit addressing */
@@ -2462,7 +2678,12 @@ SendIocInit(MPT_ADAPTER *ioc, int sleepF
 		ioc_init.SenseBufferHighAddr = cpu_to_le32(0);
 	}
 
-	dprintk((MYIOC_s_INFO_FMT "Sending IOCInit (req @ %p)\n",
+	ioc->facts.CurrentHostMfaHighAddr = ioc_init.HostMfaHighAddr;
+	ioc->facts.CurrentSenseBufferHighAddr = ioc_init.SenseBufferHighAddr;
+	ioc->facts.MaxDevices = ioc_init.MaxDevices;
+	ioc->facts.MaxBuses = ioc_init.MaxBuses;
+
+	dhsprintk((MYIOC_s_WARN_FMT "Sending IOCInit (req @ %p)\n",
 			ioc->name, &ioc_init));
 
 	r = mpt_handshake_req_reply_wait(ioc, sizeof(IOCInit_t), (u32*)&ioc_init,
@@ -2474,6 +2695,9 @@ SendIocInit(MPT_ADAPTER *ioc, int sleepF
 	 * since we don't even look at it's contents.
 	 */
 
+	dhsprintk((MYIOC_s_WARN_FMT "Sending PortEnable (req @ %p)\n",
+			ioc->name, &ioc_init));
+
 	if ((r = SendPortEnable(ioc, 0, sleepFlag)) != 0)
 		return r;
 
@@ -2482,28 +2706,26 @@ SendIocInit(MPT_ADAPTER *ioc, int sleepF
 	 *  LoopInit and TargetDiscovery!
 	 */
 	count = 0;
-	cntdn = HZ * 60;					/* chg'd from 30 to 60 seconds */
-	if (sleepFlag != CAN_SLEEP)
-		cntdn *= 10;					/* scale for 1msec delays */
+	cntdn = ((sleepFlag == CAN_SLEEP) ? HZ : 1000) * 60;	/* 60 seconds */
 	state = mpt_GetIocState(ioc, 1);
 	while (state != MPI_IOC_STATE_OPERATIONAL && --cntdn) {
 		if (sleepFlag == CAN_SLEEP) {
 			set_current_state(TASK_INTERRUPTIBLE);
-			schedule_timeout(1);
+			schedule_timeout(1 * HZ / 1000);
 		} else {
 			mdelay(1);
 		}
 
 		if (!cntdn) {
 			printk(MYIOC_s_ERR_FMT "Wait IOC_OP state timeout(%d)!\n",
-					ioc->name, (count+5)/HZ);
+					ioc->name, (int)((count+5)/HZ));
 			return -9;
 		}
 
 		state = mpt_GetIocState(ioc, 1);
 		count++;
 	}
-	dhsprintk((MYIOC_s_INFO_FMT "INFO - Wait IOC_OPERATIONAL state (cnt=%d)\n",
+	dhsprintk((MYIOC_s_WARN_FMT "INFO - Wait IOC_OPERATIONAL state (cnt=%d)\n",
 			ioc->name, count));
 
 	return r;
@@ -2525,7 +2747,7 @@ SendPortEnable(MPT_ADAPTER *ioc, int por
 {
 	PortEnable_t		 port_enable;
 	MPIDefaultReply_t	 reply_buf;
-	int	 ii;
+	int	 rc;
 	int	 req_sz;
 	int	 reply_sz;
 
@@ -2542,163 +2764,58 @@ SendPortEnable(MPT_ADAPTER *ioc, int por
 /*	port_enable.MsgFlags = 0;		*/
 /*	port_enable.MsgContext = 0;		*/
 
-	dprintk((MYIOC_s_INFO_FMT "Sending Port(%d)Enable (req @ %p)\n",
+	dinitprintk((MYIOC_s_WARN_FMT "Sending Port(%d)Enable (req @ %p)\n",
 			ioc->name, portnum, &port_enable));
 
 	/* RAID FW may take a long time to enable
 	 */
-	if ((int)ioc->chip_type <= (int)FC929) {
-		ii = mpt_handshake_req_reply_wait(ioc, req_sz, (u32*)&port_enable,
-				reply_sz, (u16*)&reply_buf, 65 /*seconds*/, sleepFlag);
-	} else {
-		ii = mpt_handshake_req_reply_wait(ioc, req_sz, (u32*)&port_enable,
+	if ( (ioc->facts.ProductID & MPI_FW_HEADER_PID_PROD_MASK)
+			> MPI_FW_HEADER_PID_PROD_TARGET_SCSI ) {
+		rc = mpt_handshake_req_reply_wait(ioc, req_sz, (u32*)&port_enable,
 				reply_sz, (u16*)&reply_buf, 300 /*seconds*/, sleepFlag);
+	} else {
+		rc = mpt_handshake_req_reply_wait(ioc, req_sz, (u32*)&port_enable,
+				reply_sz, (u16*)&reply_buf, 30 /*seconds*/, sleepFlag);
 	}
-
-	if (ii != 0)
-		return ii;
-
-	/* We do not even look at the reply, so we need not
-	 * swap the multi-byte fields.
-	 */
-
-	return 0;
+	return rc;
 }
 
 /*
- * Inputs: size - total FW bytes
- * Outputs: frags - number of fragments needed
- * Return NULL if failed.
- */
-void * 
-mpt_alloc_fw_memory(MPT_ADAPTER *ioc, int size, int *frags, int *alloc_sz) 
-{
-	fw_image_t	**cached_fw = NULL;
-	u8		*mem = NULL;
-	dma_addr_t	fw_dma;
-	int		alloc_total = 0;
-	int		bytes_left, bytes, num_frags;
-	int		sz, ii;
-
-	/* cached_fw 
-	 */
-	sz = ioc->num_fw_frags * sizeof(void *);
-	mem = kmalloc(sz, GFP_ATOMIC);
-	if (mem == NULL)
-		return NULL;
-
-	memset(mem, 0, sz);
-	cached_fw = (fw_image_t **)mem;
-	alloc_total += sz;
+ *	ioc: Pointer to MPT_ADAPTER structure
+ *      size - total FW bytes
+ */
+void
+mpt_alloc_fw_memory(MPT_ADAPTER *ioc, int size)
+{
+	if (ioc->cached_fw)
+		return;  /* use already allocated memory */
+	if (ioc->alt_ioc && ioc->alt_ioc->cached_fw) {
+		ioc->cached_fw = ioc->alt_ioc->cached_fw;  /* use alt_ioc's memory */
+		ioc->cached_fw_dma = ioc->alt_ioc->cached_fw_dma;
+	} else {
+		if ( (ioc->cached_fw = pci_alloc_consistent(ioc->pcidev, size, &ioc->cached_fw_dma) ) )
+			ioc->alloc_total += size;
+	}
+}
 
-	/* malloc fragment memory
-	 * fw_image_t struct and dma for fw data
-	 */
-	bytes_left = size;
-	ii = 0;
-	num_frags = 0;
-	bytes = bytes_left;
-	while((bytes_left) && (num_frags < ioc->num_fw_frags)) {
-		if (cached_fw[ii] == NULL) {
-			mem = kmalloc(sizeof(fw_image_t), GFP_ATOMIC);
-			if (mem == NULL)
-				break;
+/*
+ * If alt_img is NULL, delete from ioc structure.
+ * Else, delete a secondary image in same format.
+ */
+void
+mpt_free_fw_memory(MPT_ADAPTER *ioc)
+{
+	int sz;
 
-			memset(mem, 0, sizeof(fw_image_t));
-			cached_fw[ii] = (fw_image_t *)mem;
-			alloc_total += sizeof(fw_image_t);
-		}
+	sz = ioc->facts.FWImageSize;
+	dinitprintk((KERN_INFO MYNAM "free_fw_memory: FW Image  @ %p[%p], sz=%d[%x] bytes\n",
+		 ioc->cached_fw, (void *)(ulong)ioc->cached_fw_dma, sz, sz));
+	pci_free_consistent(ioc->pcidev, sz,
+			ioc->cached_fw, ioc->cached_fw_dma);
+	ioc->cached_fw = NULL;
 
-		mem = pci_alloc_consistent(ioc->pcidev, bytes, &fw_dma);
-		if (mem == NULL) {
-			if (bytes > 0x10000)
-				bytes = 0x10000;
-			else if (bytes > 0x8000)
-				bytes = 0x8000;
-			else if (bytes > 0x4000)
-				bytes = 0x4000;
-			else if (bytes > 0x2000)
-				bytes = 0x2000;
-			else if (bytes > 0x1000)
-				bytes = 0x1000;
-			else
-				break;
-
-			continue;
-		}
-
-		cached_fw[ii]->fw = mem;
-		cached_fw[ii]->fw_dma = fw_dma;
-		cached_fw[ii]->size = bytes;
-		memset(mem, 0, bytes);
-		alloc_total += bytes;
-
-		bytes_left -= bytes;
-
-		num_frags++;
-		ii++;
-	}
-
-	if (bytes_left ) {
-		/* Major Failure.
-		 */
-		mpt_free_fw_memory(ioc, cached_fw);
-		return NULL;
-	}
-
-	*frags = num_frags;
-	*alloc_sz = alloc_total;
-
-	return (void *) cached_fw;
-}
-
-/*
- * If alt_img is NULL, delete from ioc structure.
- * Else, delete a secondary image in same format.
- */
-void
-mpt_free_fw_memory(MPT_ADAPTER *ioc, fw_image_t **alt_img)
-{
-	fw_image_t **cached_fw;
-	int ii;
-	int sz;
-	int alloc_freed = 0;
-
-	if (alt_img != NULL)
-		cached_fw = alt_img;
-	else
-		cached_fw = ioc->cached_fw;
-
-	if (cached_fw == NULL)
-		return;
-
-	ii = 0;
-	while ((ii < ioc->num_fw_frags) && (cached_fw[ii]!= NULL)) {
-		sz = cached_fw[ii]->size;
-		if (sz > 0) {
-			pci_free_consistent(ioc->pcidev, sz,
-						cached_fw[ii]->fw, cached_fw[ii]->fw_dma);
-		}
-		cached_fw[ii]->fw = NULL;
-		alloc_freed += sz;
-
-		kfree(cached_fw[ii]);
-		cached_fw[ii] = NULL;
-		alloc_freed += sizeof(fw_image_t);
-
-		ii++;
-	}
-
-	kfree(cached_fw);
-	cached_fw = NULL;
-	sz = ioc->num_fw_frags * sizeof(void *);
-	alloc_freed += sz;
-
-	if (alt_img == NULL)
-		ioc->alloc_total -= alloc_freed;
-
-	return;
-}
+	return;
+}
 
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -2722,36 +2839,27 @@ mpt_do_upload(MPT_ADAPTER *ioc, int slee
 	u8			 reply[sizeof(FWUploadReply_t)];
 	FWUpload_t		*prequest;
 	FWUploadReply_t		*preply;
-	FWUploadTCSGE_t		*ptcsge = NULL;
+	FWUploadTCSGE_t		*ptcsge;
 	int			 sgeoffset;
+	u32			 flagsLength;
 	int			 ii, sz, reply_sz;
-	int			 cmdStatus, freeMem = 0;
-	int			 num_frags, alloc_sz;
+	int			 cmdStatus;
 
-	/* If the image size is 0 or if the pointer is
-	 * not NULL (error), we are done.
+	/* If the image size is 0, we are done.
 	 */
-	if (((sz = ioc->facts.FWImageSize) == 0) || ioc->cached_fw)
+	if ((sz = ioc->facts.FWImageSize) == 0)
 		return 0;
 
-	ioc->num_fw_frags = ioc->req_sz - sizeof(FWUpload_t) + sizeof(dma_addr_t) + sizeof(u32) -1;
-	ioc->num_fw_frags /= sizeof(dma_addr_t) + sizeof(u32);
+	mpt_alloc_fw_memory(ioc, sz);
 
-	ioc->cached_fw = (fw_image_t **) mpt_alloc_fw_memory(ioc, 
-			ioc->facts.FWImageSize, &num_frags, &alloc_sz); 
+	dinitprintk((KERN_INFO MYNAM ": FW Image  @ %p[%p], sz=%d[%x] bytes\n",
+		 ioc->cached_fw, (void *)(ulong)ioc->cached_fw_dma, sz, sz));
 
 	if (ioc->cached_fw == NULL) {
 		/* Major Failure.
 		 */
-		mpt_free_fw_memory(ioc, NULL);
-		ioc->cached_fw = NULL;
-		
 		return -ENOMEM;
 	}
-	ioc->alloc_total += alloc_sz;
-
-	ddlprintk((KERN_INFO MYNAM ": FW Image  @ %p, sz=%d bytes\n",
-		 (void *)(ulong)ioc->cached_fw, ioc->facts.FWImageSize));
 
 	prequest = (FWUpload_t *)&request;
 	preply = (FWUploadReply_t *)&reply;
@@ -2764,39 +2872,27 @@ mpt_do_upload(MPT_ADAPTER *ioc, int slee
 
 	prequest->ImageType = MPI_FW_UPLOAD_ITYPE_FW_IOC_MEM;
 	prequest->Function = MPI_FUNCTION_FW_UPLOAD;
-	prequest->MsgContext = 0;		/* anything */
 
 	ptcsge = (FWUploadTCSGE_t *) &prequest->SGL;
-	ptcsge->Reserved = 0;
-	ptcsge->ContextSize = 0;
 	ptcsge->DetailsLength = 12;
 	ptcsge->Flags = MPI_SGE_FLAGS_TRANSACTION_ELEMENT;
-	ptcsge->Reserved1 = 0;
-	ptcsge->ImageOffset = 0;
 	ptcsge->ImageSize = cpu_to_le32(sz);
 
 	sgeoffset = sizeof(FWUpload_t) - sizeof(SGE_MPI_UNION) + sizeof(FWUploadTCSGE_t);
 
-	for (ii = 0; ii < (num_frags-1); ii++) {
-		mpt_add_sge(&request[sgeoffset], MPT_SGE_FLAGS_SIMPLE_ELEMENT |	
-			MPT_SGE_FLAGS_ADDRESSING | MPT_TRANSFER_IOC_TO_HOST |
-			(u32) ioc->cached_fw[ii]->size, ioc->cached_fw[ii]->fw_dma);
-
-		sgeoffset += sizeof(u32) + sizeof(dma_addr_t);
-	}
-
-	mpt_add_sge(&request[sgeoffset], 
-			MPT_SGE_FLAGS_SSIMPLE_READ |(u32) ioc->cached_fw[ii]->size, 
-			ioc->cached_fw[ii]->fw_dma);
+	flagsLength = MPT_SGE_FLAGS_SSIMPLE_READ | sz;
+	mpt_add_sge(&request[sgeoffset], flagsLength, ioc->cached_fw_dma);
 
 	sgeoffset += sizeof(u32) + sizeof(dma_addr_t);
-
-	dprintk((MYIOC_s_INFO_FMT "Sending FW Upload (req @ %p) size %d \n",
-			ioc->name, prequest, sgeoffset));
+	dinitprintk((KERN_INFO MYNAM ": Sending FW Upload (req @ %p) sgeoffset=%d \n",
+			prequest, sgeoffset));
+	DBG_DUMP_FW_REQUEST_FRAME(prequest)
 
 	ii = mpt_handshake_req_reply_wait(ioc, sgeoffset, (u32*)prequest,
 				reply_sz, (u16*)preply, 65 /*seconds*/, sleepFlag);
 
+	dinitprintk((KERN_INFO MYNAM ": FW Upload completed rc=%x \n", ii));
+
 	cmdStatus = -EFAULT;
 	if (ii == 0) {
 		/* Handshake transfer was complete and successful.
@@ -2810,28 +2906,15 @@ mpt_do_upload(MPT_ADAPTER *ioc, int slee
 				cmdStatus = 0;
 		}
 	}
-	ddlprintk((MYIOC_s_INFO_FMT ": do_upload status %d \n",
+	dinitprintk((MYIOC_s_WARN_FMT ": do_upload cmdStatus=%d \n",
 			ioc->name, cmdStatus));
 
-	/* Check to see if we have a copy of this image in
-	 * host memory already.
-	 */
-	if (cmdStatus == 0) {
-		ioc->upload_fw = 0;
-		if (ioc->alt_ioc && ioc->alt_ioc->cached_fw)
-			freeMem = 1;
-	}
 
-	/* We already have a copy of this image or
-	 * we had some type of an error  - either the handshake
-	 * failed (i != 0) or the command did not complete successfully.
-	 */
-	if (cmdStatus || freeMem) {
+	if (cmdStatus) {
 
-		ddlprintk((MYIOC_s_INFO_FMT ": do_upload freeing %s image \n",
-			ioc->name, cmdStatus ? "incomplete" : "duplicate"));
-		mpt_free_fw_memory(ioc, NULL);
-		ioc->cached_fw = NULL;
+		ddlprintk((MYIOC_s_WARN_FMT ": fw upload failed, freeing image \n",
+			ioc->name));
+		mpt_free_fw_memory(ioc);
 	}
 
 	return cmdStatus;
@@ -2851,265 +2934,241 @@ mpt_do_upload(MPT_ADAPTER *ioc, int slee
  *		-2 No valid cached_fw Pointer
  *		<0 for fw upload failure.
  */
-static int
-mpt_downloadboot(MPT_ADAPTER *ioc, int sleepFlag)
+int
+mpt_downloadboot(MPT_ADAPTER *ioc, MpiFwHeader_t *pFwHeader, int sleepFlag)
 {
-	MpiFwHeader_t		*FwHdr = NULL;
-	MpiExtImageHeader_t 	*ExtHdr;
-	fw_image_t		**pCached = NULL;
-	int			 fw_sz;
+	MpiExtImageHeader_t	*pExtImage;
+	u32			 fwSize;
 	u32			 diag0val;
-#ifdef MPT_DEBUG
-	u32			 diag1val = 0;
-#endif
-	int			 count = 0;
-	u32			*ptru32 = NULL;
-	u32			 diagRwData;
+	int			 count;
+	u32			*ptrFw;
+	u32			 diagRwData, doorbell;
 	u32			 nextImage;
-	u32			 ext_offset;
 	u32			 load_addr;
-	int			 max_idx, fw_idx, ext_idx;
-	int			 left_u32s;
+	u32 			 ioc_state=0;
 
-	ddlprintk((MYIOC_s_INFO_FMT "DbGb0: downloadboot entered.\n",
-				ioc->name));
-#ifdef MPT_DEBUG
-	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
-	if (ioc->alt_ioc)
-		diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
-	ddlprintk((MYIOC_s_INFO_FMT "DbGb1: diag0=%08x, diag1=%08x\n",
-				ioc->name, diag0val, diag1val));
-#endif
+	nextImage = pFwHeader->NextImageHeaderOffset;
+	if (ioc->bus_type == SAS) {
+		while (nextImage) {
+			pExtImage = (MpiExtImageHeader_t *) ((char *)pFwHeader + nextImage);
+			ddlprintk((MYIOC_s_WARN_FMT "downloadboot: SAS nextImage=%x pExtImage=%p ImageType=%x\n",
+				ioc->name, nextImage, pExtImage, 
+				pExtImage->ImageType));
+
+			if ( pExtImage->ImageType == MPI_EXT_IMAGE_TYPE_BOOTLOADER ) {
+				fwSize = (pExtImage->ImageSize + 3)/4;
+				ptrFw = (u32 *) pExtImage;
+				load_addr = pExtImage->LoadStartAddress;
+				goto imageFound;
+			}
+			nextImage = pExtImage->NextImageHeaderOffset;
+		}
+		ddlprintk((MYIOC_s_WARN_FMT "downloadboot: SAS BOOTLOADER not found nextImage=%d\n",
+				ioc->name, nextImage));
+		return -2;
+	} else {
+		fwSize = (pFwHeader->ImageSize + 3)/4;
+		ptrFw = (u32 *) pFwHeader;
+		load_addr = pFwHeader->LoadStartAddress;
+	}
+imageFound:
+	ddlprintk((MYIOC_s_WARN_FMT "downloadboot: fw size 0x%x (%d), FW Ptr %po load_addr=%x\n",
+		ioc->name, fwSize, fwSize, ptrFw, load_addr));
 
-	ddlprintk((MYIOC_s_INFO_FMT "fw size 0x%x, ioc FW Ptr %p\n",
-				ioc->name, ioc->facts.FWImageSize, ioc->cached_fw));
-	if (ioc->alt_ioc)
-		ddlprintk((MYIOC_s_INFO_FMT "alt ioc FW Ptr %p\n",
-				ioc->name, ioc->alt_ioc->cached_fw));
+	CHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);
+	CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);
+	CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);
+	CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);
+	CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);
+	CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);
 
-	/* Get dma_addr and data transfer size.
-	 */
-	if ((fw_sz = ioc->facts.FWImageSize) == 0)
-		return -1;
+	CHIPREG_WRITE32(&ioc->chip->Diagnostic, (MPI_DIAG_PREVENT_IOC_BOOT | MPI_DIAG_DISABLE_ARM));
 
-	/* Get the DMA from ioc or ioc->alt_ioc */
-	if (ioc->cached_fw != NULL)
-		pCached = (fw_image_t **)ioc->cached_fw;
-	else if (ioc->alt_ioc && (ioc->alt_ioc->cached_fw != NULL))
-		pCached = (fw_image_t **)ioc->alt_ioc->cached_fw;
-
-	ddlprintk((MYIOC_s_INFO_FMT "DbGb2: FW Image @ %p\n",
-			ioc->name, pCached));
-	if (!pCached)
-		return -2;
+	/* wait 1 msec */
+	if (sleepFlag == CAN_SLEEP) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(1 * HZ / 1000);
+	} else {
+		mdelay (1);
+	}
 
-	/* Write magic sequence to WriteSequence register
-	 * until enter diagnostic mode
-	 */
 	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
-	while ((diag0val & MPI_DIAG_DRWE) == 0) {
-		CHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);
-		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);
-		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);
-		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);
-		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);
-		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);
+	CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val | MPI_DIAG_RESET_ADAPTER);
 
-		/* wait 100 msec */
+	for (count = 0; count < 30; count ++) {
+		diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+		if (!(diag0val & MPI_DIAG_RESET_ADAPTER)) {
+			ddlprintk((MYIOC_s_WARN_FMT "RESET_ADAPTER cleared, count=%d\n",
+				ioc->name, count));
+			break;
+		}
+		/* wait .1 sec */
 		if (sleepFlag == CAN_SLEEP) {
 			set_current_state(TASK_INTERRUPTIBLE);
 			schedule_timeout(100 * HZ / 1000);
 		} else {
 			mdelay (100);
 		}
-
-		count++;
-		if (count > 20) {
-			printk(MYIOC_s_ERR_FMT "Enable Diagnostic mode FAILED! (%02xh)\n",
-					ioc->name, diag0val);
-			return -EFAULT;
-
-		}
-
-		diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
-#ifdef MPT_DEBUG
-		if (ioc->alt_ioc)
-			diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
-		ddlprintk((MYIOC_s_INFO_FMT "DbGb3: diag0=%08x, diag1=%08x\n",
-				ioc->name, diag0val, diag1val));
-#endif
-		ddlprintk((MYIOC_s_INFO_FMT "Wrote magic DiagWriteEn sequence (%x)\n",
-				ioc->name, diag0val));
 	}
 
-	/* Set the DiagRwEn and Disable ARM bits */
-	diag0val |= (MPI_DIAG_RW_ENABLE | MPI_DIAG_DISABLE_ARM);
-	CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val);
-
-#ifdef MPT_DEBUG
-	if (ioc->alt_ioc)
-		diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
+	if ( count == 30 ) {
+		ddlprintk((MYIOC_s_WARN_FMT "downloadboot failed! Unable to get MPI_DIAG_DRWE mode, diag0val=%x\n",
+		ioc->name, diag0val));
+		return -3;
+	}
 
-	ddlprintk((MYIOC_s_INFO_FMT "DbGb3: diag0=%08x, diag1=%08x\n",
-			ioc->name, diag0val, diag1val));
-#endif
+	CHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);
+	CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);
+	CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);
+	CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);
+	CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);
+	CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);
 
-	/* max_idx = 1 + maximum valid buffer index
-	 */
-	max_idx = 0;
-	while (pCached[max_idx])
-		max_idx++;
-
-	fw_idx = 0;
-	FwHdr = (MpiFwHeader_t *) pCached[fw_idx]->fw;
-	ptru32 = (u32 *) FwHdr;
-	count = (FwHdr->ImageSize + 3)/4;
-	nextImage = FwHdr->NextImageHeaderOffset;
+	/* Set the DiagRwEn and Disable ARM bits */
+	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+	CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val | (MPI_DIAG_RW_ENABLE | MPI_DIAG_DISABLE_ARM));
 
 	/* Write the LoadStartAddress to the DiagRw Address Register
 	 * using Programmed IO
 	 */
-	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, FwHdr->LoadStartAddress);
-	ddlprintk((MYIOC_s_INFO_FMT "LoadStart addr written 0x%x \n",
-		ioc->name, FwHdr->LoadStartAddress));
-
-	ddlprintk((MYIOC_s_INFO_FMT "Write FW Image: 0x%x u32's @ %p\n",
-				ioc->name, count, ptru32));
-	left_u32s = pCached[fw_idx]->size/4;
-	while (count--) {
-		if (left_u32s == 0) {
-			fw_idx++;
-			if (fw_idx >= max_idx) {
-				/* FIXME
-				ERROR CASE
-				*/
-				;
-			}
-			ptru32 = (u32 *) pCached[fw_idx]->fw;
-			left_u32s = pCached[fw_idx]->size / 4;
-		}
-		left_u32s--;
-		CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, *ptru32);
-		ptru32++;
-	}
-
-	/* left_u32s, fw_idx and ptru32 are all valid
-	 */
-	while (nextImage) {
-		ext_idx = 0;
-		ext_offset = nextImage;
-		while (ext_offset > pCached[ext_idx]->size) {
-			ext_idx++;
-			if (ext_idx >= max_idx) {
-				/* FIXME
-				ERROR CASE
-				*/
-				;
-			}
-			ext_offset -= pCached[ext_idx]->size;
-		}
-		ptru32 = (u32 *) ((char *)pCached[ext_idx]->fw + ext_offset);
-		left_u32s = pCached[ext_idx]->size - ext_offset;
-
-		if ((left_u32s * 4) >= sizeof(MpiExtImageHeader_t)) {
-			ExtHdr = (MpiExtImageHeader_t *) ptru32;
-			count = (ExtHdr->ImageSize + 3 )/4;
-			nextImage = ExtHdr->NextImageHeaderOffset;
-			load_addr = ExtHdr->LoadStartAddress;
-		} else {
-			u32 * ptmp = (u32 *)pCached[ext_idx+1]->fw;
+	if(ioc->errata_flag_1064) {
+		pci_enable_io_access(ioc->pcidev);
+	}
+	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, load_addr);
+	ddlprintk((MYIOC_s_WARN_FMT "LoadStart addr written 0x%x \n",
+		ioc->name, load_addr));
 
-			switch (left_u32s) {
-			case 5:
-				count = *(ptru32 + 2);
-				nextImage = *(ptru32 + 3);
-				load_addr = *(ptru32 + 4);
-				break;
-			case 4:
-				count = *(ptru32 + 2);
-				nextImage = *(ptru32 + 3);
-				load_addr = *ptmp;
-				break;
-			case 3:
-				count = *(ptru32 + 2);
-				nextImage = *ptmp;
-				load_addr = *(ptmp + 1);
-				break;
-			case 2:
-				count = *ptmp;
-				nextImage = *(ptmp + 1);
-				load_addr = *(ptmp + 2);
-				break;
+	ddlprintk((MYIOC_s_WARN_FMT "Write FW Image: 0x%x (%d) bytes @ %p\n",
+				ioc->name, fwSize*4, fwSize*4, ptrFw));
+	while (fwSize--) {
+		CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, *ptrFw++);
+	}
 
-			case 1:
-				count = *(ptmp + 1);
-				nextImage = *(ptmp + 2);
-				load_addr = *(ptmp + 3);
-				break;
+	if (ioc->bus_type == SAS) {
+		pFwHeader->IopResetVectorValue = load_addr + 0x18;
+	} else {
 
-			default:
-				count = 0;
-				nextImage = 0;
-				load_addr = 0;
-				/* FIXME
-				ERROR CASE
-				*/
-				;
-
-			}
-			count = (count +3)/4;
-		}
-
-		ddlprintk((MYIOC_s_INFO_FMT "Write Ext Image: 0x%x u32's @ %p\n",
-						ioc->name, count, ptru32));
-		CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, load_addr);
-
-		while (count--) {
-			if (left_u32s == 0) {
-				fw_idx++;
-				if (fw_idx >= max_idx) {
-					/* FIXME
-					ERROR CASE
-					*/
-					;
-				}
-				ptru32 = (u32 *) pCached[fw_idx]->fw;
-				left_u32s = pCached[fw_idx]->size / 4;
+		while (nextImage) {
+			pExtImage = (MpiExtImageHeader_t *) ((char *)pFwHeader + nextImage);
+
+			load_addr = pExtImage->LoadStartAddress;
+
+			fwSize = (pExtImage->ImageSize + 3) >> 2;
+			ptrFw = (u32 *)pExtImage;
+
+			ddlprintk((MYIOC_s_WARN_FMT "Write Ext Image: 0x%x (%d) bytes @ %p load_addr=%x\n",
+				ioc->name, fwSize*4, fwSize*4, ptrFw, load_addr));
+			CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, load_addr);
+
+			while (fwSize--) {
+				CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, *ptrFw++);
 			}
-			left_u32s--;
-			CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, *ptru32);
-			ptru32++;
+			nextImage = pExtImage->NextImageHeaderOffset;
 		}
 	}
 
 	/* Write the IopResetVectorRegAddr */
-	ddlprintk((MYIOC_s_INFO_FMT "Write IopResetVector Addr! \n", ioc->name));
-	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, FwHdr->IopResetRegAddr);
+	ddlprintk((MYIOC_s_WARN_FMT "Write IopResetVector Addr=%x! \n", 			ioc->name, pFwHeader->IopResetRegAddr));
+	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, pFwHeader->IopResetRegAddr);
 
 	/* Write the IopResetVectorValue */
-	ddlprintk((MYIOC_s_INFO_FMT "Write IopResetVector Value! \n", ioc->name));
-	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, FwHdr->IopResetVectorValue);
+	ddlprintk((MYIOC_s_WARN_FMT "Write IopResetVector Value=%x! \n", 
+		ioc->name, pFwHeader->IopResetVectorValue));
+	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, pFwHeader->IopResetVectorValue);
 
-	/* Clear the internal flash bad bit - autoincrementing register,
-	 * so must do two writes.
-	 */
-	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, 0x3F000000);
-	diagRwData = CHIPREG_PIO_READ32(&ioc->pio_chip->DiagRwData);
-	diagRwData |= 0x4000000;
-	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, 0x3F000000);
-	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, diagRwData);
+	if (ioc->bus_type == SCSI) {
+		/*
+		 * 1030 and 1035 H/W errata, workaround to access
+		 * the ClearFlashBadSignatureBit
+		 */
+		CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, 0x3F000000);
+		diagRwData = CHIPREG_PIO_READ32(&ioc->pio_chip->DiagRwData);
+		diagRwData |= 0x40000000;
+		CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, 0x3F000000);
+		CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, diagRwData);
+
+	}
 
-	/* clear the RW enable and DISARM bits */
+	if(ioc->errata_flag_1064) {
+		pci_disable_io_access(ioc->pcidev);
+	}
+	
 	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
-	diag0val &= ~(MPI_DIAG_DISABLE_ARM | MPI_DIAG_RW_ENABLE | MPI_DIAG_FLASH_BAD_SIG);
+	ddlprintk((MYIOC_s_WARN_FMT "downloadboot: diag0val=%x, turning off PREVENT_IOC_BOOT, DISABLE_ARM\n",
+		ioc->name, diag0val));
+	diag0val &= ~(MPI_DIAG_PREVENT_IOC_BOOT | MPI_DIAG_DISABLE_ARM);
+	ddlprintk((MYIOC_s_WARN_FMT "downloadboot: now diag0val=%x\n",
+		ioc->name, diag0val));
 	CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val);
+	if (ioc->bus_type == SAS ) {
+		/* wait 1 millisec */
+		if (sleepFlag == CAN_SLEEP) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1 * HZ / 1000);
+		} else {
+			mdelay (1);
+		}
+		diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+		ddlprintk((MYIOC_s_WARN_FMT "downloadboot: diag0val=%x, turning off RW_ENABLE\n",
+			ioc->name, diag0val));
+		diag0val &= ~(MPI_DIAG_RW_ENABLE);
+		ddlprintk((MYIOC_s_WARN_FMT "downloadboot: now diag0val=%x\n",
+			ioc->name, diag0val));
+		CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val);
 
+		diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+		if (diag0val & MPI_DIAG_FLASH_BAD_SIG) {
+			diag0val |= MPI_DIAG_CLEAR_FLASH_BAD_SIG;
+			CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val);
+			diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+		}
+		diag0val &= ~(MPI_DIAG_DISABLE_ARM);
+		CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val);
+		diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+		CHIPREG_WRITE32(&ioc->chip->DiagRwAddress, 0x3f000004);
+	}
 	/* Write 0xFF to reset the sequencer */
 	CHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);
 
-	return 0;
+	for (count = 0; count < 30; count ++) {
+		doorbell = CHIPREG_READ32(&ioc->chip->Doorbell);
+		doorbell &= MPI_IOC_STATE_MASK;
+
+		if (doorbell == MPI_IOC_STATE_READY) {
+			if (ioc->bus_type == SAS) {
+/*				if ( (GetIocFacts(ioc, sleepFlag, 
+					MPT_HOSTEVENT_IOC_BRINGUP)) != 0 ) {
+					ddlprintk((MYIOC_s_WARN_FMT "downloadboot: GetIocFacts failed: IocState=%x\n",
+						ioc->name, ioc_state));
+					return -EFAULT;
+				} */
+				return 0;
+			}
+			if ((SendIocInit(ioc, sleepFlag)) != 0) {
+				ddlprintk((MYIOC_s_WARN_FMT "downloadboot: SendIocInit failed\n",
+					ioc->name));
+				return -EFAULT;
+			}
+			ddlprintk((MYIOC_s_WARN_FMT "downloadboot: SendIocInit successful\n",
+				ioc->name));
+			return 0;
+		}
+		ddlprintk((MYIOC_s_WARN_FMT "downloadboot: looking for READY STATE: doorbell=%x count=%d\n", 
+			ioc->name, doorbell, count));
+		/* wait 1 sec */
+		if (sleepFlag == CAN_SLEEP) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1000 * HZ / 1000);
+		} else {
+			mdelay (1000);
+		}
+	}
+	ddlprintk((MYIOC_s_WARN_FMT "downloadboot failed! IocState=%x count=%d\n",
+		ioc->name, ioc_state, count));
+	return -EFAULT;
 }
 
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *	KickStart - Perform hard reset of MPT adapter.
@@ -3129,29 +3188,30 @@ mpt_downloadboot(MPT_ADAPTER *ioc, int s
  *			  0 else
  *
  *	Returns:
- *		 1 - hard reset, READY	
- *		 0 - no reset due to History bit, READY	
- *		-1 - no reset due to History bit but not READY	
+ *		 1 - hard reset, READY
+ *		 0 - no reset due to History bit, READY
+ *		-1 - no reset due to History bit but not READY
  *		     OR reset but failed to come READY
- *		-2 - no reset, could not enter DIAG mode 
- *		-3 - reset but bad FW bit 
+ *		-2 - no reset, could not enter DIAG mode
+ *		-3 - reset but bad FW bit
  */
 static int
 KickStart(MPT_ADAPTER *ioc, int force, int sleepFlag)
 {
 	int hard_reset_done = 0;
-	u32 ioc_state;
-	int cnt = 0;
+	u32 ioc_state=0;
+	int cnt;
 
-	dprintk((KERN_WARNING MYNAM ": KickStarting %s!\n", ioc->name));
-	if ((int)ioc->chip_type > (int)FC929) {
+	dinitprintk((KERN_INFO MYNAM ": KickStarting %s!\n", ioc->name));
+	if (ioc->bus_type == SCSI) {
 		/* Always issue a Msg Unit Reset first. This will clear some
 		 * SCSI bus hang conditions.
 		 */
 		SendIocReset(ioc, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET, sleepFlag);
 
 		if (sleepFlag == CAN_SLEEP) {
-			schedule_timeout(HZ);
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1000 * HZ / 1000);
 		} else {
 			mdelay (1000);
 		}
@@ -3161,25 +3221,26 @@ KickStart(MPT_ADAPTER *ioc, int force, i
 	if (hard_reset_done < 0)
 		return hard_reset_done;
 
-	dprintk((MYIOC_s_INFO_FMT "Diagnostic reset successful!\n",
+	dinitprintk((MYIOC_s_WARN_FMT "Diagnostic reset successful!\n",
 			ioc->name));
 
-	for (cnt=0; cnt<HZ*20; cnt++) {
-		if ((ioc_state = mpt_GetIocState(ioc, 1)) == MPI_IOC_STATE_READY) {
-			dprintk((MYIOC_s_INFO_FMT "KickStart successful! (cnt=%d)\n",
+	for (cnt=0; cnt<HZ*2; cnt++) {
+		ioc_state = mpt_GetIocState(ioc, 1);
+		if ((ioc_state == MPI_IOC_STATE_READY) || (ioc_state == MPI_IOC_STATE_OPERATIONAL)) {
+			dinitprintk((MYIOC_s_WARN_FMT "KickStart successful! (cnt=%d)\n",
 					ioc->name, cnt));
 			return hard_reset_done;
 		}
 		if (sleepFlag == CAN_SLEEP) {
 			set_current_state(TASK_INTERRUPTIBLE);
-			schedule_timeout(1);
+			schedule_timeout(10 * HZ / 1000);
 		} else {
 			mdelay (10);
 		}
 	}
 
-	printk(MYIOC_s_ERR_FMT "Failed to come READY after reset!\n",
-			ioc->name);
+	printk(MYIOC_s_ERR_FMT "Failed to come READY after reset! IocState=%x\n",
+			ioc->name, ioc_state);
 	return -1;
 }
 
@@ -3209,7 +3270,7 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
 	u32 doorbell;
 	int hard_reset_done = 0;
 	int count = 0;
-#ifdef MPT_DEBUG
+#ifdef MPT_DEBUG_RESET
 	u32 diag1val = 0;
 #endif
 
@@ -3219,10 +3280,10 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
 	/* Use "Diagnostic reset" method! (only thing available!) */
 	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
 
-#ifdef MPT_DEBUG
+#ifdef MPT_DEBUG_RESET
 	if (ioc->alt_ioc)
 		diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
-	dprintk((MYIOC_s_INFO_FMT "DbG1: diag0=%08x, diag1=%08x\n",
+	drsprintk((MYIOC_s_WARN_FMT "DbG1: diag0=%08x, diag1=%08x\n",
 			ioc->name, diag0val, diag1val));
 #endif
 
@@ -3259,36 +3320,58 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
 
 			diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
 
-			dprintk((MYIOC_s_INFO_FMT "Wrote magic DiagWriteEn sequence (%x)\n",
+			drsprintk((MYIOC_s_WARN_FMT "Wrote magic DiagWriteEn sequence (%x)\n",
 					ioc->name, diag0val));
 		}
 
-#ifdef MPT_DEBUG
+#ifdef MPT_DEBUG_RESET
 		if (ioc->alt_ioc)
 			diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
-		dprintk((MYIOC_s_INFO_FMT "DbG2: diag0=%08x, diag1=%08x\n",
+		drsprintk((MYIOC_s_WARN_FMT "DbG2: diag0=%08x, diag1=%08x\n",
 				ioc->name, diag0val, diag1val));
 #endif
-		/* Write the PreventIocBoot bit */
-		if ((ioc->cached_fw) || (ioc->alt_ioc && ioc->alt_ioc->cached_fw)) {
-			diag0val |= MPI_DIAG_PREVENT_IOC_BOOT;
-			CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val);
+		if (ioc->bus_type != SAS) {
+			/*
+			 * Disable the ARM (Bug fix)
+			 *
+			 */
+			CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val | MPI_DIAG_DISABLE_ARM);
+			mdelay (1);
 		}
 
 		/*
-		 * Disable the ARM (Bug fix)
-		 * 
-		 */
-		CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val | MPI_DIAG_DISABLE_ARM);
-		mdelay (1);
-
-		/*
 		 * Now hit the reset bit in the Diagnostic register
 		 * (THE BIG HAMMER!) (Clears DRWE bit).
 		 */
 		CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val | MPI_DIAG_RESET_ADAPTER);
+		if (ioc->bus_type == SAS) {
+			CHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);
+		
+			count = 0;
+			diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+			while (diag0val & MPI_DIAG_RESET_ADAPTER) {
+				/* wait 100 msec */
+				if (sleepFlag == CAN_SLEEP) {
+					set_current_state(TASK_INTERRUPTIBLE);
+					schedule_timeout(100 * HZ / 1000);
+				} else {
+					mdelay (100);
+				}
+
+				count++;
+				if (count > 20) {
+					printk(MYIOC_s_ERR_FMT "RESET_ADAPTER FAILED! (%02xh)\n",
+							ioc->name, diag0val);
+					return -2;
+
+				}
+
+				diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+			}
+		}
+
 		hard_reset_done = 1;
-		dprintk((MYIOC_s_INFO_FMT "Diagnostic reset performed\n",
+		drsprintk((MYIOC_s_WARN_FMT "Diagnostic reset performed\n",
 				ioc->name));
 
 		/*
@@ -3299,51 +3382,49 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
 		 */
 		{
 			int	 ii;
-			int	 r = 0;
+			int	 rc = 0;
 
 			for (ii=MPT_MAX_PROTOCOL_DRIVERS-1; ii; ii--) {
 				if (MptResetHandlers[ii]) {
-					dprintk((MYIOC_s_INFO_FMT "Calling IOC pre_reset handler #%d\n",
-							ioc->name, ii));
-					r += (*(MptResetHandlers[ii]))(ioc, MPT_IOC_PRE_RESET);
+					rc += (*(MptResetHandlers[ii]))(ioc, MPT_IOC_PRE_RESET);
+					drsprintk((MYIOC_s_WARN_FMT "Called MptResetHandlers=%p ii=%d for MPT_IOC_PRE_RESET rc=%x\n",
+						ioc->name, 
+						MptResetHandlers[ii], ii, rc));
 					if (ioc->alt_ioc) {
-						dprintk((MYIOC_s_INFO_FMT "Calling alt-%s pre_reset handler #%d\n",
-								ioc->name, ioc->alt_ioc->name, ii));
-						r += (*(MptResetHandlers[ii]))(ioc->alt_ioc, MPT_IOC_PRE_RESET);
+						rc += (*(MptResetHandlers[ii]))(ioc->alt_ioc, MPT_IOC_PRE_RESET);
+						drsprintk((MYIOC_s_WARN_FMT "Called alt-%s MptResetHandlers=%p ii=%d for MPT_IOC_PRE_RESET rc=%x\n",
+						ioc->name, ioc->alt_ioc->name,
+						MptResetHandlers[ii], ii, rc));
 					}
 				}
 			}
-			/* FIXME?  Examine results here? */
+			drsprintk((MYIOC_s_WARN_FMT "hard_reset_done: rc=%x for MPT_IOC_PRE_RESET\n",
+				ioc->name, rc));
 		}
 
-		if ((ioc->cached_fw) || (ioc->alt_ioc && ioc->alt_ioc->cached_fw)) {
+		if (ioc->cached_fw) {
 			/* If the DownloadBoot operation fails, the
 			 * IOC will be left unusable. This is a fatal error
 			 * case.  _diag_reset will return < 0
 			 */
 			for (count = 0; count < 30; count ++) {
 				diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
-#ifdef MPT_DEBUG
-				if (ioc->alt_ioc)
-					diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
-				dprintk((MYIOC_s_INFO_FMT 
-					"DbG2b: diag0=%08x, diag1=%08x\n",
-					ioc->name, diag0val, diag1val));
-#endif
 				if (!(diag0val & MPI_DIAG_RESET_ADAPTER)) {
 					break;
 				}
 
+				drsprintk((MYIOC_s_WARN_FMT "cached_fw: diag0val=%x count=%d\n", 
+					ioc->name, diag0val, count));
 				/* wait 1 sec */
 				if (sleepFlag == CAN_SLEEP) {
 					set_current_state(TASK_INTERRUPTIBLE);
-					schedule_timeout(HZ);
+					schedule_timeout(1000 * HZ / 1000);
 				} else {
 					mdelay (1000);
 				}
 			}
-			if ((count = mpt_downloadboot(ioc, sleepFlag)) < 0) {
-				printk(KERN_WARNING MYNAM 
+			if ((count = mpt_downloadboot(ioc, (MpiFwHeader_t *)ioc->cached_fw, sleepFlag)) < 0) {
+				printk(KERN_WARNING MYNAM
 					": firmware downloadboot failure (%d)!\n", count);
 			}
 
@@ -3354,7 +3435,7 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
 			 * If fail, no error will check again
 			 * with calling program.
 			 */
-			for (count = 0; count < 30; count ++) {
+			for (count = 0; count < 60; count ++) {
 				doorbell = CHIPREG_READ32(&ioc->chip->Doorbell);
 				doorbell &= MPI_IOC_STATE_MASK;
 
@@ -3362,10 +3443,12 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
 					break;
 				}
 
+				drsprintk((MYIOC_s_WARN_FMT "looking for READY STATE: doorbell=%x count=%d\n", 
+					ioc->name, doorbell, count));
 				/* wait 1 sec */
 				if (sleepFlag == CAN_SLEEP) {
 					set_current_state(TASK_INTERRUPTIBLE);
-					schedule_timeout(HZ);
+					schedule_timeout(1000 * HZ / 1000);
 				} else {
 					mdelay (1000);
 				}
@@ -3374,10 +3457,10 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
 	}
 
 	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
-#ifdef MPT_DEBUG
+#ifdef MPT_DEBUG_RESET
 	if (ioc->alt_ioc)
 		diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
-	dprintk((MYIOC_s_INFO_FMT "DbG3: diag0=%08x, diag1=%08x\n",
+	drsprintk((MYIOC_s_WARN_FMT "DbG3: diag0=%08x, diag1=%08x\n",
 		ioc->name, diag0val, diag1val));
 #endif
 
@@ -3390,6 +3473,7 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
 		/* Write magic sequence to WriteSequence register
 		 * Loop until in diagnostic mode
 		 */
+		CHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);
 		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);
 		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);
 		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);
@@ -3433,10 +3517,10 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
 		return -3;
 	}
 
-#ifdef MPT_DEBUG
+#ifdef MPT_DEBUG_RESET
 	if (ioc->alt_ioc)
 		diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
-	dprintk((MYIOC_s_INFO_FMT "DbG4: diag0=%08x, diag1=%08x\n",
+	drsprintk((MYIOC_s_WARN_FMT "DbG4: diag0=%08x, diag1=%08x\n",
 			ioc->name, diag0val, diag1val));
 #endif
 
@@ -3453,65 +3537,269 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
- *	SendIocReset - Send IOCReset request to MPT adapter.
+ *	mpt_do_diag_reset - Perform hard reset of the adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
- *	@reset_type: reset type, expected values are
- *	%MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET or %MPI_FUNCTION_IO_UNIT_RESET
+ *	@sleepflag: CAN_SLEEP if called in a non-interrupt thread,
+ *		else set to NO_SLEEP (use mdelay instead)
  *
- *	Send IOCReset request to the MPT adapter.
+ *	This routine places the adapter in diagnostic mode via the
+ *	WriteSequence register and then performs a hard reset of adapter
+ *	via the Diagnostic register. Adapter should be in ready state
+ *	upon successful completion.
  *
- *	Returns 0 for success, non-zero for failure.
+ *	Returns:  1  hard reset successful
+ *		  0  no reset performed because reset history bit set
+ *		 -2  enabling diagnostic mode failed
+ *		 -3  diagnostic reset failed
  */
-static int
-SendIocReset(MPT_ADAPTER *ioc, u8 reset_type, int sleepFlag)
+int
+mpt_do_diag_reset(MPT_ADAPTER *ioc, int sleepFlag)
 {
-	int r;
-	u32 state;
-	int cntdn, count;
-
-	dprintk((KERN_WARNING MYNAM ": %s: Sending IOC reset(0x%02x)!\n",
-			ioc->name, reset_type));
-	CHIPREG_WRITE32(&ioc->chip->Doorbell, reset_type<<MPI_DOORBELL_FUNCTION_SHIFT);
-	if ((r = WaitForDoorbellAck(ioc, 2, sleepFlag)) < 0)
-		return r;
+	u32 diag0val, doorbell=0;
+	int count = 0;
 
-	/* FW ACK'd request, wait for READY state 
-	 */
-	cntdn = HZ * 15;
-	count = 0;
-	if (sleepFlag != CAN_SLEEP)
-		cntdn *= 10;	/* 1500 iterations @ 1msec per */
+	/* Clear any existing interrupts */
+//	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
 
-	while ((state = mpt_GetIocState(ioc, 1)) != MPI_IOC_STATE_READY) {
-		cntdn--;
-		count++;
-		if (!cntdn) {
-			if (sleepFlag != CAN_SLEEP)
-				count *= 10;
+	/* Use "Diagnostic reset" method! (only thing available!) */
+//	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
 
-			printk(KERN_ERR MYNAM ": %s: ERROR - Wait IOC_READY state timeout(%d)!\n",
-					ioc->name, (count+5)/HZ);
-			return -ETIME;
-		}
+	do {
+		/* Write magic sequence to WriteSequence register
+		 * Loop until in diagnostic mode
+		 */
+		CHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);
+		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);
+		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);
+		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);
+		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);
+		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);
 
+		/* wait 100 msec */
 		if (sleepFlag == CAN_SLEEP) {
 			set_current_state(TASK_INTERRUPTIBLE);
-			schedule_timeout(1);
+			schedule_timeout(100 * HZ / 1000);
 		} else {
-			mdelay (1);	/* 1 msec delay */
+			mdelay (100);
 		}
-	}
 
-	/* TODO!
-	 *  Cleanup all event stuff for this IOC; re-issue EventNotification
-	 *  request if needed.
-	 */
+		diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+
+		count++;
+		if (count > 20) {
+			printk(MYIOC_s_ERR_FMT "Enable Diagnostic mode FAILED! (%02xh)\n",
+					ioc->name, diag0val);
+			return -2;
+
+		}
+
+		drsprintk((MYIOC_s_WARN_FMT "Wrote magic DiagWriteEn sequence (%x)\n",
+			ioc->name, diag0val));
+	} while ((diag0val & MPI_DIAG_DRWE) == 0);
+
+	if (ioc->bus_type != SAS) {
+		/*
+		 * Disable the ARM (Bug fix)
+		 *
+		 */
+		CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val | MPI_DIAG_DISABLE_ARM);
+		mdelay (1);
+	}
+
+	/*
+	 * Now hit the reset bit in the Diagnostic register
+	 * (THE BIG HAMMER!) (Clears DRWE bit).
+	 */
+	CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val | MPI_DIAG_RESET_ADAPTER);
+	if (ioc->bus_type == SAS) {
+//		CHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);
+		
+		count = 0;
+		diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+		while (diag0val & MPI_DIAG_RESET_ADAPTER) {
+			/* wait 100 msec */
+			if (sleepFlag == CAN_SLEEP) {
+				set_current_state(TASK_INTERRUPTIBLE);
+				schedule_timeout(100 * HZ / 1000);
+			} else {
+				mdelay (100);
+			}
+
+			count++;
+			if (count > 20) {
+				printk(MYIOC_s_ERR_FMT "RESET_ADAPTER FAILED! (%02xh)\n",
+					ioc->name, diag0val);
+				return -2;
+			}
+
+			diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+		}
+		/* Wait for FW to reload and for board
+		 * to go to the READY state.
+		 * Maximum wait is 30 seconds.
+		 * If fail, no error will check again
+		 * with calling program.
+		 */
+		for (count = 0; count < 60; count ++) {
+			doorbell = CHIPREG_READ32(&ioc->chip->Doorbell);
+			doorbell &= MPI_IOC_STATE_MASK;
+
+			if (doorbell == MPI_IOC_STATE_READY) {
+				break;
+			}
+
+			drsprintk((MYIOC_s_WARN_FMT "looking for READY STATE: doorbell=%x count=%d\n", 
+				ioc->name, doorbell, count));
+			/* wait 1 sec */
+			if (sleepFlag == CAN_SLEEP) {
+				set_current_state(TASK_INTERRUPTIBLE);
+				schedule_timeout(1000 * HZ / 1000);
+			} else {
+				mdelay (1000);
+			}
+		}
+	}
+
+	drsprintk((MYIOC_s_WARN_FMT "Diagnostic reset performed, doorbell=%08x count=%d\n",
+			ioc->name, doorbell, count));
+
+	/*
+	 * Reset flag that says we've enabled event notification
+	 */
+	ioc->facts.EventState = 0;
+
+	if (ioc->alt_ioc)
+		ioc->alt_ioc->facts.EventState = 0;
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	SendIocReset - Send IOCReset request to MPT adapter.
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@reset_type: reset type, expected values are
+ *	%MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET or %MPI_FUNCTION_IO_UNIT_RESET
+ *
+ *	Send IOCReset request to the MPT adapter.
+ *
+ *	Returns 0 for success, non-zero for failure.
+ */
+static int
+SendIocReset(MPT_ADAPTER *ioc, u8 reset_type, int sleepFlag)
+{
+	int r;
+	u32 state;
+	int cntdn, count;
+
+	drsprintk((KERN_WARNING MYNAM ": %s: Sending IOC reset(0x%02x)!\n",
+			ioc->name, reset_type));
+	CHIPREG_WRITE32(&ioc->chip->Doorbell, reset_type<<MPI_DOORBELL_FUNCTION_SHIFT);
+	if ((r = WaitForDoorbellAck(ioc, 5, sleepFlag)) < 0)
+		return r;
+
+	/* FW ACK'd request, wait for READY state
+	 */
+	count = 0;
+	cntdn = ((sleepFlag == CAN_SLEEP) ? HZ : 1000) * 15;	/* 15 seconds */
+
+	while ((state = mpt_GetIocState(ioc, 1)) != MPI_IOC_STATE_READY) {
+		cntdn--;
+		count++;
+		if (!cntdn) {
+			if (sleepFlag != CAN_SLEEP)
+				count *= 10;
+
+			printk(KERN_ERR MYNAM ": %s: ERROR - Wait IOC_READY state timeout(%d)!\n",
+					ioc->name, (int)((count+5)/HZ));
+			return -ETIME;
+		}
+
+		if (sleepFlag == CAN_SLEEP) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1 * HZ / 1000);
+		} else {
+			mdelay (1);	/* 1 msec delay */
+		}
+	}
+
+	/* TODO!
+	 *  Cleanup all event stuff for this IOC; re-issue EventNotification
+	 *  request if needed.
+	 */
 	if (ioc->facts.Function)
 		ioc->facts.EventState = 0;
 
 	return 0;
 }
 
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mpt_initChainBuffers - Allocate memory for and initialize
+ *	chain buffer control arrays and spinlock.
+ *	@hd: Pointer to MPT_SCSI_HOST structure
+ */
+static int
+mpt_initChainBuffers (MPT_ADAPTER *ioc)
+{
+	u8		*mem;
+	int		sz, ii;
+
+	/* ReqToChain size must equal the req_depth
+	 */
+	if (ioc->ReqToChain == NULL) {
+		sz = ioc->req_depth * sizeof(int);
+		mem = kmalloc(sz, GFP_ATOMIC);
+		if (mem == NULL) {
+			dinitprintk((KERN_INFO MYNAM ": %s ReqToChain %d alloc failed\n",
+			 	ioc->name, sz));
+			return -1;
+		}
+
+		ioc->ReqToChain = (int *) mem;
+		dinitprintk((KERN_INFO MYNAM ": %s ReqToChain alloc  @ %p, sz=%d bytes\n",
+			 	ioc->name, mem, sz));
+
+		mem = kmalloc(sz, GFP_ATOMIC);
+		if (mem == NULL) {
+			dinitprintk((KERN_INFO MYNAM ": %s RequestNB %d alloc failed\n",
+			 	ioc->name, sz));
+			kfree (ioc->ReqToChain);
+			ioc->ReqToChain = NULL;
+			return -1;
+		}
+		ioc->RequestNB = (int *) mem;
+		dinitprintk((KERN_INFO MYNAM ": %s RequestNB alloc  @ %p, sz=%d bytes\n",
+			 	ioc->name, mem, sz));
+	}
+	for (ii = 0; ii < ioc->req_depth; ii++) {
+		ioc->ReqToChain[ii] = MPT_HOST_NO_CHAIN;
+	}
+
+	sz = ioc->num_chain * sizeof(int);
+	if (ioc->ChainToChain == NULL) {
+		mem = kmalloc(sz, GFP_ATOMIC);
+		if (mem == NULL) {
+			dinitprintk((KERN_INFO MYNAM ": %s ChainToChain %d alloc failed\n",
+			 	ioc->name, sz));
+			kfree (ioc->ReqToChain);
+			ioc->ReqToChain = NULL;
+			kfree (ioc->RequestNB);
+			ioc->RequestNB = NULL;
+			return -1;
+		}
+
+		ioc->ChainToChain = (int *) mem;
+		dinitprintk((KERN_INFO MYNAM ": %s ChainToChain alloc @ %p, sz=%d bytes\n",
+			 	ioc->name, mem, sz));
+	} else {
+		mem = (u8 *) ioc->ChainToChain;
+	}
+	memset(mem, 0xFF, sz);
+	return 0;
+}
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *	PrimeIocFifos - Initialize IOC request and reply FIFOs.
@@ -3527,85 +3815,124 @@ static int
 PrimeIocFifos(MPT_ADAPTER *ioc)
 {
 	MPT_FRAME_HDR *mf;
-	unsigned long b;
 	unsigned long flags;
-	dma_addr_t aligned_mem_dma;
-	u8 *mem, *aligned_mem;
-	int i, sz;
+	dma_addr_t alloc_dma;
+	u8 *mem;
+	int i, reply_sz, sz, total_size, num_chain, total_num_chain;
+	int scale, scale1, num_sge, numSGE, maxSGEs, SGE_size;
 
 	/*  Prime reply FIFO...  */
 
 	if (ioc->reply_frames == NULL) {
-		sz = (ioc->reply_sz * ioc->reply_depth) + 128;
-		mem = pci_alloc_consistent(ioc->pcidev, sz, &ioc->reply_alloc_dma);
-		if (mem == NULL)
-			goto out_fail;
+		/* Calculate the number of chain buffers needed per I/O
+		 * then multiply by the maximum number of simultaneous cmds
+		 *
+		 * scale = num sge per chain buffer if no chain element
+		 * scale1 = num sge in intermediate chain buffers
+		 * num_sge = num sge in request frame + last chain buffer
+		 * numSGE = total num sge in intermediate chain buffers
+		 * maxSGEs = maximum number of SGE's per IO
+		 */
+		SGE_size = sizeof(dma_addr_t) + sizeof(u32);
+		scale = ioc->req_sz/SGE_size;
+		scale1 = scale - 1;
+		dinitprintk((KERN_INFO MYNAM ": %s dma_addr_t size=%d u64 size=%d\n",
+			ioc->name, (int)sizeof(dma_addr_t), (int)sizeof(u64)));
+		num_sge =  scale + (ioc->req_sz - 48 - SGE_size) / (SGE_size);
+
+		numSGE = scale1 * (ioc->facts.MaxChainDepth-1);
+		maxSGEs = num_sge + numSGE;
+		dinitprintk((KERN_INFO MYNAM ": %s req_sz=%d SGE_size=%d scale=%d num_sge=%d numSGE=%d MaxChainDepth=%d maxSGEs=%d mpt_sg_tablesize=%d\n",
+			ioc->name, ioc->req_sz, SGE_size, scale, num_sge, numSGE, ioc->facts.MaxChainDepth, maxSGEs, mpt_sg_tablesize));
+		if (mpt_sg_tablesize > maxSGEs) {
+			mpt_sg_tablesize = maxSGEs;
+			dinitprintk((KERN_INFO MYNAM ": %s mpt_sg_tablesize=%d now\n",
+				ioc->name, mpt_sg_tablesize));
+		} else if (mpt_sg_tablesize < maxSGEs) {
+			numSGE = mpt_sg_tablesize - num_sge;
+			dinitprintk((KERN_INFO MYNAM ": %s numSGE=%d now\n",
+				ioc->name, numSGE));
+		}
+
+		num_chain = 1;
+		while (numSGE > 0) {
+			num_chain++;
+			numSGE -= scale1;
+		}
+
+		dinitprintk((KERN_INFO MYNAM ": %s Now num_chain=%d\n",
+			ioc->name, num_chain));
+
+		num_chain *= ioc->req_depth;
+
+		total_num_chain = num_chain * mpt_chain_alloc_percent / 100;
+
+		numSGE = scale1 * (total_num_chain-1);
+		maxSGEs = num_sge + numSGE;
+		if (mpt_sg_tablesize > maxSGEs) {
+			mpt_sg_tablesize = maxSGEs;
+			dinitprintk((KERN_INFO MYNAM ": %s mpt_sg_tablesize=%d now, maxSGEs=%d numSGE=%d\n",
+				ioc->name, mpt_sg_tablesize, maxSGEs, numSGE));
+		}
+
+		dinitprintk((KERN_INFO MYNAM ": %s req_depth=%d max num_chain=%d mpt_chain_alloc_percent=%d total_num_chain=%d\n",
+			ioc->name, ioc->req_depth, num_chain, mpt_chain_alloc_percent, total_num_chain));
+		ioc->num_chain = total_num_chain;
+
+		total_size = reply_sz = (ioc->reply_sz * ioc->reply_depth);
+		dinitprintk((KERN_INFO MYNAM ": %s ReplyBuffer sz=%d bytes, ReplyDepth=%d\n",
+			 	ioc->name, ioc->reply_sz, ioc->reply_depth));
+		dinitprintk((KERN_INFO MYNAM ": %s Total ReplyBuffer sz=%d[%x] bytes\n",
+			 	ioc->name, reply_sz, reply_sz));
+
+		sz = (ioc->req_sz * ioc->req_depth);
+		dinitprintk((KERN_INFO MYNAM ": %s RequestBuffer sz=%d bytes, RequestDepth=%d\n",
+			 	ioc->name, ioc->req_sz, ioc->req_depth));
+		dinitprintk((KERN_INFO MYNAM ": %s Total RequestBuffer sz=%d[%x] bytes\n",
+			 	ioc->name, sz, sz));
+		total_size += sz;
+
+		sz = total_num_chain * ioc->req_sz; /* chain buffer pool size */
+		dinitprintk((KERN_INFO MYNAM ": %s Total ChainBuffer sz=%d[%x] bytes total_num_chain=%d\n",
+			 	ioc->name, sz, sz, total_num_chain));
+
+		total_size += sz;
+		dinitprintk((KERN_INFO MYNAM ": %s Total ioc alloc size=%d[%x] bytes\n",
+			 	ioc->name, total_size, total_size));
 
-		memset(mem, 0, sz);
-		ioc->alloc_total += sz;
-		ioc->reply_alloc = mem;
-		dprintk((KERN_INFO MYNAM ": %s.reply_alloc  @ %p[%p], sz=%d bytes\n",
-			 	ioc->name, mem, (void *)(ulong)ioc->reply_alloc_dma, sz));
-
-		b = (unsigned long) mem;
-		b = (b + (0x80UL - 1UL)) & ~(0x80UL - 1UL); /* round up to 128-byte boundary */
-		aligned_mem = (u8 *) b;
-		ioc->reply_frames = (MPT_FRAME_HDR *) aligned_mem;
-		ioc->reply_frames_dma =
-			(ioc->reply_alloc_dma + (aligned_mem - mem));
+		mem = pci_alloc_consistent(ioc->pcidev, total_size, &alloc_dma);
+		if (mem == NULL) {
+			printk(MYIOC_s_ERR_FMT "Unable to allocate Reply, Request, Chain Buffers for size=%d[%x] bytes!\n",
+				ioc->name, total_size, total_size);
+			goto out_fail;
+		}
 
-		ioc->reply_frames_low_dma = (u32) (ioc->reply_frames_dma & 0xFFFFFFFF);
-	}
+		dinitprintk((KERN_INFO MYNAM ": %s Total ioc alloc @ %p[%p]\n",
+			 	ioc->name, mem, (void *)(ulong)alloc_dma));
 
-	/* Post Reply frames to FIFO
-	 */
-	aligned_mem_dma = ioc->reply_frames_dma;
-	dprintk((KERN_INFO MYNAM ": %s.reply_frames @ %p[%p]\n",
-		 	ioc->name, ioc->reply_frames, (void *)(ulong)aligned_mem_dma));
+		memset(mem, 0, total_size);
+		ioc->alloc_total += total_size;
+		ioc->alloc = mem;
+		ioc->alloc_dma = alloc_dma;
+		ioc->alloc_sz = total_size;
+		ioc->reply_frames = (MPT_FRAME_HDR *) mem;
+		ioc->reply_frames_low_dma = (u32) (alloc_dma & 0xFFFFFFFF);
 
-	for (i = 0; i < ioc->reply_depth; i++) {
-		/*  Write each address to the IOC!  */
-		CHIPREG_WRITE32(&ioc->chip->ReplyFifo, aligned_mem_dma);
-		aligned_mem_dma += ioc->reply_sz;
-	}
+		dinitprintk((KERN_INFO MYNAM ": %s ReplyBuffers @ %p[%p]\n",
+	 		ioc->name, ioc->reply_frames, (void *)(ulong)alloc_dma));
 
+		alloc_dma += reply_sz;
+		mem += reply_sz;
 
-	/*  Request FIFO - WE manage this!  */
+		/*  Request FIFO - WE manage this!  */
 
-	if (ioc->req_frames == NULL) {
-		sz = (ioc->req_sz * ioc->req_depth) + 128;
-		/*
-		 *  Rounding UP to nearest 4-kB boundary here...
-		 */
-		sz = ((sz + 0x1000UL - 1UL) / 0x1000) * 0x1000;
+		ioc->req_frames = (MPT_FRAME_HDR *) mem;
+		ioc->req_frames_dma = alloc_dma;
 
-		mem = pci_alloc_consistent(ioc->pcidev, sz, &ioc->req_alloc_dma);
-		if (mem == NULL)
-			goto out_fail;
+		dinitprintk((KERN_INFO MYNAM ": %s RequestBuffers @ %p[%p]\n",
+			 	ioc->name, mem, (void *)(ulong)alloc_dma));
 
-		memset(mem, 0, sz);
-		ioc->alloc_total += sz;
-		ioc->req_alloc = mem;
-		dprintk((KERN_INFO MYNAM ": %s.req_alloc    @ %p[%p], sz=%d bytes\n",
-			 	ioc->name, mem, (void *)(ulong)ioc->req_alloc_dma, sz));
-
-		b = (unsigned long) mem;
-		b = (b + (0x80UL - 1UL)) & ~(0x80UL - 1UL); /* round up to 128-byte boundary */
-		aligned_mem = (u8 *) b;
-		ioc->req_frames = (MPT_FRAME_HDR *) aligned_mem;
-		ioc->req_frames_dma =
-			(ioc->req_alloc_dma + (aligned_mem - mem));
-
-		ioc->req_frames_low_dma = (u32) (ioc->req_frames_dma & 0xFFFFFFFF);
-
-		if (sizeof(dma_addr_t) == sizeof(u64)) {
-			/* Check: upper 32-bits of the request and reply frame
-			 * physical addresses must be the same.
-			 */
-			if (((u64)ioc->req_frames_dma >> 32) != ((u64)ioc->reply_frames_dma >> 32)){
-				goto out_fail;
-			}
-		}
+		ioc->req_frames_low_dma = (u32) (alloc_dma & 0xFFFFFFFF);
 
 #if defined(CONFIG_MTRR) && 0
 		/*
@@ -3613,74 +3940,90 @@ PrimeIocFifos(MPT_ADAPTER *ioc)
 		 *  (at least as much as we can; "size and base must be
 		 *  multiples of 4 kiB"
 		 */
-		ioc->mtrr_reg = mtrr_add(ioc->req_alloc_dma,
+		ioc->mtrr_reg = mtrr_add(ioc->req_frames_dma,
 					 sz,
 					 MTRR_TYPE_WRCOMB, 1);
-		dprintk((MYIOC_s_INFO_FMT "MTRR region registered (base:size=%08x:%x)\n",
-				ioc->name, ioc->req_alloc_dma, sz));
+		dprintk((MYIOC_s_WARN_FMT "MTRR region registered (base:size=%08x:%x)\n",
+				ioc->name, ioc->req_frames_dma, sz));
 #endif
-	}
 
-	/* Initialize Request frames linked list
-	 */
-	aligned_mem_dma = ioc->req_frames_dma;
-	aligned_mem = (u8 *) ioc->req_frames;
-	dprintk((KERN_INFO MYNAM ": %s.req_frames   @ %p[%p]\n",
-		 	ioc->name, aligned_mem, (void *)(ulong)aligned_mem_dma));
+		for (i = 0; i < ioc->req_depth; i++) {
+			alloc_dma += ioc->req_sz;
+			mem += ioc->req_sz;
+		}
 
-	spin_lock_irqsave(&ioc->FreeQlock, flags);
-	Q_INIT(&ioc->FreeQ, MPT_FRAME_HDR);
-	for (i = 0; i < ioc->req_depth; i++) {
-		mf = (MPT_FRAME_HDR *) aligned_mem;
+		ioc->ChainBuffer = mem;
+		ioc->ChainBufferDMA = alloc_dma;
 
-		/*  Queue REQUESTs *internally*!  */
-		Q_ADD_TAIL(&ioc->FreeQ.head, &mf->u.frame.linkage, MPT_FRAME_HDR);
-		aligned_mem += ioc->req_sz;
-	}
-	spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+		dinitprintk((KERN_INFO MYNAM " :%s ChainBuffers @ %p(%p)\n",
+			ioc->name, ioc->ChainBuffer, (void *)(ulong)ioc->ChainBufferDMA));
+
+
+		/* Post the chain buffers to the FreeChainQ.
+	 	*/
+		mem = (u8 *)ioc->ChainBuffer;
+		for (i=0; i < total_num_chain; i++) {
+			mf = (MPT_FRAME_HDR *) mem;
+			Q_ADD_TAIL(&ioc->FreeChainQ.head, &mf->u.frame.linkage, MPT_FRAME_HDR);
+/*			dinitprintk((MYIOC_s_WARN_FMT "Adding %p to FreeChainQ at %d\n",
+ 				ioc->name, mf, i)); */
+			mem += ioc->req_sz;
+		}
+
+		/* Initialize Request frames linked list
+		 */
+		alloc_dma = ioc->req_frames_dma;
+		mem = (u8 *) ioc->req_frames;
+
+		spin_lock_irqsave(&ioc->FreeQlock, flags);
+		for (i = 0; i < ioc->req_depth; i++) {
+			mf = (MPT_FRAME_HDR *) mem;
 
+			/*  Queue REQUESTs *internally*!  */
+			Q_ADD_TAIL(&ioc->FreeQ.head, &mf->u.frame.linkage, MPT_FRAME_HDR);
+/*			dinitprintk((MYIOC_s_WARN_FMT "Adding %p to FreeQ at %d\n",
+ 				ioc->name, mf, i)); */
+			mem += ioc->req_sz;
+		}
+		spin_unlock_irqrestore(&ioc->FreeQlock, flags);
 
-	if (ioc->sense_buf_pool == NULL) {
 		sz = (ioc->req_depth * MPT_SENSE_BUFFER_ALLOC);
 		ioc->sense_buf_pool =
-				pci_alloc_consistent(ioc->pcidev, sz, &ioc->sense_buf_pool_dma);
-		if (ioc->sense_buf_pool == NULL)
+			pci_alloc_consistent(ioc->pcidev, sz, &ioc->sense_buf_pool_dma);
+		if (ioc->sense_buf_pool == NULL) {
+			printk(MYIOC_s_ERR_FMT "Unable to allocate Sense Buffers req_depth=%d sz=%d!\n",
+				ioc->name, ioc->req_depth, sz);
 			goto out_fail;
+		}
 
 		ioc->sense_buf_low_dma = (u32) (ioc->sense_buf_pool_dma & 0xFFFFFFFF);
 		ioc->alloc_total += sz;
+		dinitprintk((KERN_INFO MYNAM ": %s SenseBuffers @ %p[%p]\n",
+ 			ioc->name, ioc->sense_buf_pool, (void *)(ulong)ioc->sense_buf_pool_dma));
+
+		if ( mpt_initChainBuffers(ioc) < 0)
+			goto out_fail;
+	}
+
+	/* Post Reply frames to FIFO
+	 */
+	alloc_dma = ioc->alloc_dma;
+	for (i = 0; i < ioc->reply_depth; i++) {
+		/*  Write each address to the IOC!  */
+		CHIPREG_WRITE32(&ioc->chip->ReplyFifo, alloc_dma);
+		alloc_dma += ioc->reply_sz;
 	}
 
 	return 0;
 
 out_fail:
-	if (ioc->reply_alloc != NULL) {
-		sz = (ioc->reply_sz * ioc->reply_depth) + 128;
+	if (ioc->alloc != NULL) {
+		sz = ioc->alloc_sz;
 		pci_free_consistent(ioc->pcidev,
 				sz,
-				ioc->reply_alloc, ioc->reply_alloc_dma);
+				ioc->alloc, ioc->alloc_dma);
 		ioc->reply_frames = NULL;
-		ioc->reply_alloc = NULL;
-		ioc->alloc_total -= sz;
-	}
-	if (ioc->req_alloc != NULL) {
-		sz = (ioc->req_sz * ioc->req_depth) + 128;
-		/*
-		 *  Rounding UP to nearest 4-kB boundary here...
-		 */
-		sz = ((sz + 0x1000UL - 1UL) / 0x1000) * 0x1000;
-		pci_free_consistent(ioc->pcidev,
-				sz,
-				ioc->req_alloc, ioc->req_alloc_dma);
-#if defined(CONFIG_MTRR) && 0
-		if (ioc->mtrr_reg > 0) {
-			mtrr_del(ioc->mtrr_reg, 0, 0);
-			dprintk((MYIOC_s_INFO_FMT "MTRR region de-registered\n",
-					ioc->name));
-		}
-#endif
 		ioc->req_frames = NULL;
-		ioc->req_alloc = NULL;
 		ioc->alloc_total -= sz;
 	}
 	if (ioc->sense_buf_pool != NULL) {
@@ -3695,8 +4038,8 @@ out_fail:
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
- *	mpt_handshake_req_reply_wait - Send MPT request to and receive reply from
- *	IOC via doorbell handshake method.
+ *	mpt_handshake_req_reply_wait - Send MPT request to and receive reply
+ *	from IOC via doorbell handshake method.
  *	@ioc: Pointer to MPT_ADAPTER structure
  *	@reqBytes: Size of the request in bytes
  *	@req: Pointer to MPT request frame
@@ -3714,7 +4057,7 @@ out_fail:
  */
 int
 mpt_handshake_req_reply_wait(MPT_ADAPTER *ioc, int reqBytes, u32 *req,
-				int replyBytes, u16 *u16reply, int maxwait, int sleepFlag)
+		int replyBytes, u16 *u16reply, int maxwait, int sleepFlag)
 {
 	MPIDefaultReply_t *mptReply;
 	int failcnt = 0;
@@ -3743,8 +4086,8 @@ mpt_handshake_req_reply_wait(MPT_ADAPTER
 	if ((t = WaitForDoorbellInt(ioc, 5, sleepFlag)) < 0)
 		failcnt++;
 
-	dhsprintk((MYIOC_s_INFO_FMT "HandShake request start, WaitCnt=%d%s\n",
-			ioc->name, t, failcnt ? " - MISSING DOORBELL HANDSHAKE!" : ""));
+	dhsprintk((MYIOC_s_WARN_FMT "HandShake request start reqBytes=%d, WaitCnt=%d%s\n",
+			ioc->name, reqBytes, t, failcnt ? " - MISSING DOORBELL HANDSHAKE!" : ""));
 
 	/* Read doorbell and check for active bit */
 	if (!(CHIPREG_READ32(&ioc->chip->Doorbell) & MPI_DOORBELL_ACTIVE))
@@ -3756,7 +4099,7 @@ mpt_handshake_req_reply_wait(MPT_ADAPTER
 	 * our handshake request.
 	 */
 	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
-	if (!failcnt && (t = WaitForDoorbellAck(ioc, 2, sleepFlag)) < 0)
+	if (!failcnt && (t = WaitForDoorbellAck(ioc, 5, sleepFlag)) < 0)
 		failcnt++;
 
 	if (!failcnt) {
@@ -3772,17 +4115,16 @@ mpt_handshake_req_reply_wait(MPT_ADAPTER
 				    (req_as_bytes[(ii*4) + 1] <<  8) |
 				    (req_as_bytes[(ii*4) + 2] << 16) |
 				    (req_as_bytes[(ii*4) + 3] << 24));
+			dhsprintk((MYIOC_s_WARN_FMT "mpt_handshake_req_reply_wait word=%08x ii=%d\n",
+				ioc->name, word, ii));
 
 			CHIPREG_WRITE32(&ioc->chip->Doorbell, word);
-			if ((t = WaitForDoorbellAck(ioc, 2, sleepFlag)) < 0)
+			if ((t = WaitForDoorbellAck(ioc, 5, sleepFlag)) < 0)
 				failcnt++;
 		}
 
-		dmfprintk((KERN_INFO MYNAM ": Handshake request frame (@%p) header\n", req));
-		DBG_DUMP_REQUEST_FRAME_HDR(req)
-
-		dhsprintk((MYIOC_s_INFO_FMT "HandShake request post done, WaitCnt=%d%s\n",
-				ioc->name, t, failcnt ? " - MISSING DOORBELL ACK!" : ""));
+		dhsprintk((MYIOC_s_WARN_FMT "HandShake request post done, WaitCnt=%d%s\n",
+			ioc->name, t, failcnt ? " - MISSING DOORBELL ACK!" : ""));
 
 		/*
 		 * Wait for completion of doorbell handshake reply from the IOC
@@ -3790,11 +4132,17 @@ mpt_handshake_req_reply_wait(MPT_ADAPTER
 		if (!failcnt && (t = WaitForDoorbellReply(ioc, maxwait, sleepFlag)) < 0)
 			failcnt++;
 
+		dhsprintk((MYIOC_s_WARN_FMT "HandShake reply count=%d%s\n",
+			ioc->name, t, failcnt ? " - MISSING DOORBELL REPLY!" : ""));
+
 		/*
 		 * Copy out the cached reply...
 		 */
-		for (ii=0; ii < MIN(replyBytes/2,mptReply->MsgLength*2); ii++)
+		for (ii=0; ii < min(replyBytes/2,mptReply->MsgLength*2); ii++) {
 			u16reply[ii] = ioc->hs_reply[ii];
+			dhsprintk((MYIOC_s_WARN_FMT "mpt_handshake_req_reply_wait reply=%08x ii=%d\n",
+				ioc->name, u16reply[ii], ii));
+		}
 	} else {
 		return -99;
 	}
@@ -3818,9 +4166,11 @@ mpt_handshake_req_reply_wait(MPT_ADAPTER
 static int
 WaitForDoorbellAck(MPT_ADAPTER *ioc, int howlong, int sleepFlag)
 {
-	int cntdn = HZ * howlong;
+	int cntdn;
 	int count = 0;
-	u32 intstat;
+	u32 intstat=0;
+
+	cntdn = ((sleepFlag == CAN_SLEEP) ? HZ : 1000) * howlong;
 
 	if (sleepFlag == CAN_SLEEP) {
 		while (--cntdn) {
@@ -3828,11 +4178,10 @@ WaitForDoorbellAck(MPT_ADAPTER *ioc, int
 			if (! (intstat & MPI_HIS_IOP_DOORBELL_STATUS))
 				break;
 			set_current_state(TASK_INTERRUPTIBLE);
-			schedule_timeout(1);
+			schedule_timeout(1 * HZ / 1000);
 			count++;
 		}
 	} else {
-		cntdn *= 10; /* convert to msec */
 		while (--cntdn) {
 			intstat = CHIPREG_READ32(&ioc->chip->IntStatus);
 			if (! (intstat & MPI_HIS_IOP_DOORBELL_STATUS))
@@ -3840,17 +4189,16 @@ WaitForDoorbellAck(MPT_ADAPTER *ioc, int
 			mdelay (1);
 			count++;
 		}
-		count /= 10;
 	}
 
 	if (cntdn) {
-		dhsprintk((MYIOC_s_INFO_FMT "WaitForDoorbell ACK (cnt=%d)\n",
+		dprintk((MYIOC_s_WARN_FMT "WaitForDoorbell ACK (count=%d)\n",
 				ioc->name, count));
 		return count;
 	}
 
-	printk(MYIOC_s_ERR_FMT "Doorbell ACK timeout(%d)!\n",
-			ioc->name, (count+5)/HZ);
+	printk(MYIOC_s_ERR_FMT "Doorbell ACK timeout (count=%d), IntStatus=%x!\n",
+			ioc->name, count, intstat);
 	return -1;
 }
 
@@ -3869,21 +4217,23 @@ WaitForDoorbellAck(MPT_ADAPTER *ioc, int
 static int
 WaitForDoorbellInt(MPT_ADAPTER *ioc, int howlong, int sleepFlag)
 {
-	int cntdn = HZ * howlong;
+	int cntdn;
 	int count = 0;
-	u32 intstat;
+	u32 intstat=0;
 
+	cntdn = ((sleepFlag == CAN_SLEEP) ? HZ : 1000) * howlong;
+	dhsprintk((MYIOC_s_WARN_FMT "WaitForDoorbell INT howlong=%d cntdn=%d\n",
+				ioc->name, howlong, cntdn));
 	if (sleepFlag == CAN_SLEEP) {
 		while (--cntdn) {
 			intstat = CHIPREG_READ32(&ioc->chip->IntStatus);
 			if (intstat & MPI_HIS_DOORBELL_INTERRUPT)
 				break;
 			set_current_state(TASK_INTERRUPTIBLE);
-			schedule_timeout(1);
+			schedule_timeout(1 * HZ / 1000);
 			count++;
 		}
 	} else {
-		cntdn *= 10; /* convert to msec */
 		while (--cntdn) {
 			intstat = CHIPREG_READ32(&ioc->chip->IntStatus);
 			if (intstat & MPI_HIS_DOORBELL_INTERRUPT)
@@ -3891,17 +4241,16 @@ WaitForDoorbellInt(MPT_ADAPTER *ioc, int
 			mdelay(1);
 			count++;
 		}
-		count /= 10;
 	}
 
 	if (cntdn) {
-		dhsprintk((MYIOC_s_INFO_FMT "WaitForDoorbell INT (cnt=%d)\n",
-				ioc->name, count));
+		dhsprintk((MYIOC_s_WARN_FMT "WaitForDoorbell INT count=%d howlong=%d\n",
+			ioc->name, count, howlong));
 		return count;
 	}
 
-	printk(MYIOC_s_ERR_FMT "Doorbell INT timeout(%d)!\n",
-			ioc->name, (count+5)/HZ);
+	printk(MYIOC_s_ERR_FMT "Doorbell INT timeout howlong=%d (count=%d), IntStatus=%x!\n",
+			ioc->name, howlong, count, intstat);
 	return -1;
 }
 
@@ -3930,6 +4279,8 @@ WaitForDoorbellReply(MPT_ADAPTER *ioc, i
 
 	hs_reply[0] = hs_reply[1] = hs_reply[7] = 0;
 
+	dhsprintk((MYIOC_s_WARN_FMT "WaitForDoorbellReply howlong=%d\n",
+			ioc->name, howlong)); 
 	/*
 	 * Get first two u16's so we can look at IOC's intended reply MsgLength
 	 */
@@ -3938,17 +4289,19 @@ WaitForDoorbellReply(MPT_ADAPTER *ioc, i
 		failcnt++;
 	} else {
 		hs_reply[u16cnt++] = le16_to_cpu(CHIPREG_READ32(&ioc->chip->Doorbell) & 0x0000FFFF);
-		CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
-		if ((t = WaitForDoorbellInt(ioc, 2, sleepFlag)) < 0)
+//		CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
+		CHIPREG_WRITE32(&ioc->chip->IntStatus, 0xFFFFFFFF);
+		if ((t = WaitForDoorbellInt(ioc, 5, sleepFlag)) < 0)
 			failcnt++;
 		else {
 			hs_reply[u16cnt++] = le16_to_cpu(CHIPREG_READ32(&ioc->chip->Doorbell) & 0x0000FFFF);
-			CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
+//			CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
+			CHIPREG_WRITE32(&ioc->chip->IntStatus, 0xFFFFFFFF);
 		}
 	}
 
-	dhsprintk((MYIOC_s_INFO_FMT "First handshake reply word=%08x%s\n",
-			ioc->name, le32_to_cpu(*(u32 *)hs_reply),
+	dhsprintk((MYIOC_s_WARN_FMT "WaitCnt=%d First handshake reply word=%08x%s\n",
+			ioc->name, t, le32_to_cpu(*(u32 *)hs_reply), 
 			failcnt ? " - MISSING DOORBELL HANDSHAKE!" : ""));
 
 	/*
@@ -3956,235 +4309,971 @@ WaitForDoorbellReply(MPT_ADAPTER *ioc, i
 	 * reply 16 bits at a time.
 	 */
 	for (u16cnt=2; !failcnt && u16cnt < (2 * mptReply->MsgLength); u16cnt++) {
-		if ((t = WaitForDoorbellInt(ioc, 2, sleepFlag)) < 0)
+		if ((t = WaitForDoorbellInt(ioc, 5, sleepFlag)) < 0)
 			failcnt++;
 		hword = le16_to_cpu(CHIPREG_READ32(&ioc->chip->Doorbell) & 0x0000FFFF);
 		/* don't overflow our IOC hs_reply[] buffer! */
 		if (u16cnt < sizeof(ioc->hs_reply) / sizeof(ioc->hs_reply[0]))
 			hs_reply[u16cnt] = hword;
-		CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
+//		CHIPREG_WRITE32(&ioc->chip->IntStatus, 0x0);
+		CHIPREG_WRITE32(&ioc->chip->IntStatus, 0xFFFFFFFF);
+	}
+
+	if (!failcnt && (t = WaitForDoorbellInt(ioc, 5, sleepFlag)) < 0)
+		failcnt++;
+//	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
+	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0xFFFFFFFF);
+
+	if (failcnt) {
+		printk(MYIOC_s_ERR_FMT "Handshake reply failure!\n",
+				ioc->name);
+		return -failcnt;
+	}
+//#if 0
+	else if (u16cnt != (2 * mptReply->MsgLength)) {
+		dhsprintk((MYIOC_s_WARN_FMT "Handshake u16cnt=%d != 2*MsgLength=%d\n", ioc->name, u16cnt, mptReply->MsgLength));
+		return -101;
+	}
+	else if ((mptReply->IOCStatus & MPI_IOCSTATUS_MASK) != MPI_IOCSTATUS_SUCCESS) {
+		dhsprintk((MYIOC_s_WARN_FMT "Handshake reply IOCStatus=%08x\n", ioc->name, mptReply->IOCStatus));
+		return -102;
 	}
+//#endif
+
+	dhsprintk((MYIOC_s_WARN_FMT "Got Handshake reply:\n", ioc->name));
+	DBG_DUMP_REPLY_FRAME(mptReply)
+
+	dhsprintk((MYIOC_s_WARN_FMT "WaitForDoorbell REPLY WaitCnt=%d (sz=%d)\n",
+			ioc->name, t, u16cnt/2));
+	return u16cnt/2;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	GetLanConfigPages - Fetch LANConfig pages.
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *
+ *	Return: 0 for success
+ *	-ENOMEM if no memory available
+ *		-EPERM if not allowed due to ISR context
+ *		-EAGAIN if no msg frames currently available
+ *		-EFAULT for non-successful reply or no reply (timeout)
+ */
+static int
+GetLanConfigPages(MPT_ADAPTER *ioc)
+{
+	ConfigPageHeader_t	 hdr;
+	CONFIGPARMS		 cfg;
+	LANPage0_t		*ppage0_alloc;
+	dma_addr_t		 page0_dma;
+	LANPage1_t		*ppage1_alloc;
+	dma_addr_t		 page1_dma;
+	int			 rc = 0;
+	int			 data_sz;
+	int			 copy_sz;
+
+	/* Get LAN Page 0 header */
+	hdr.PageVersion = 0;
+	hdr.PageLength = 0;
+	hdr.PageNumber = 0;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_LAN;
+	cfg.cfghdr.hdr = &hdr;
+	cfg.physAddr = -1;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	cfg.pageAddr = 0;
+	cfg.timeout = 0;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0)
+		return rc;
+
+	if (hdr.PageLength > 0) {
+		data_sz = hdr.PageLength * 4;
+		ppage0_alloc = (LANPage0_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page0_dma);
+		rc = -ENOMEM;
+		if (ppage0_alloc) {
+			memset((u8 *)ppage0_alloc, 0, data_sz);
+			cfg.physAddr = page0_dma;
+			cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+			if ((rc = mpt_config(ioc, &cfg)) == 0) {
+				/* save the data */
+				copy_sz = min_t(int, sizeof(LANPage0_t), data_sz);
+				memcpy(&ioc->lan_cnfg_page0, ppage0_alloc, copy_sz);
+
+			}
+
+			pci_free_consistent(ioc->pcidev, data_sz, (u8 *) ppage0_alloc, page0_dma);
+
+			/* FIXME!
+			 *	Normalize endianness of structure data,
+			 *	by byte-swapping all > 1 byte fields!
+			 */
+
+		}
+
+		if (rc)
+			return rc;
+	}
+
+	/* Get LAN Page 1 header */
+	hdr.PageVersion = 0;
+	hdr.PageLength = 0;
+	hdr.PageNumber = 1;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_LAN;
+	cfg.cfghdr.hdr = &hdr;
+	cfg.physAddr = -1;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	cfg.pageAddr = 0;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0)
+		return rc;
+
+	if (hdr.PageLength == 0)
+		return 0;
+
+	data_sz = hdr.PageLength * 4;
+	rc = -ENOMEM;
+	ppage1_alloc = (LANPage1_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page1_dma);
+	if (ppage1_alloc) {
+		memset((u8 *)ppage1_alloc, 0, data_sz);
+		cfg.physAddr = page1_dma;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+		if ((rc = mpt_config(ioc, &cfg)) == 0) {
+			/* save the data */
+			copy_sz = min_t(int, sizeof(LANPage1_t), data_sz);
+			memcpy(&ioc->lan_cnfg_page1, ppage1_alloc, copy_sz);
+		}
+
+		pci_free_consistent(ioc->pcidev, data_sz, (u8 *) ppage1_alloc, page1_dma);
+
+		/* FIXME!
+		 *	Normalize endianness of structure data,
+		 *	by byte-swapping all > 1 byte fields!
+		 */
+
+	}
+
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	GetFcPortPage0 - Fetch FCPort config Page0.
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@portnum: IOC Port number
+ *
+ *	Return: 0 for success
+ *	-ENOMEM if no memory available
+ *		-EPERM if not allowed due to ISR context
+ *		-EAGAIN if no msg frames currently available
+ *		-EFAULT for non-successful reply or no reply (timeout)
+ */
+static int
+GetFcPortPage0(MPT_ADAPTER *ioc, int portnum)
+{
+	ConfigPageHeader_t	 hdr;
+	CONFIGPARMS		 cfg;
+	FCPortPage0_t		*ppage0_alloc;
+	FCPortPage0_t		*pp0dest;
+	dma_addr_t		 page0_dma;
+	int			 data_sz;
+	int			 copy_sz;
+	int			 rc;
+
+	/* Get FCPort Page 0 header */
+	hdr.PageVersion = 0;
+	hdr.PageLength = 0;
+	hdr.PageNumber = 0;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_FC_PORT;
+	cfg.cfghdr.hdr = &hdr;
+	cfg.physAddr = -1;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	cfg.pageAddr = portnum;
+	cfg.timeout = 0;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0)
+		return rc;
+
+	if (hdr.PageLength == 0)
+		return 0;
+
+	data_sz = hdr.PageLength * 4;
+	rc = -ENOMEM;
+	ppage0_alloc = (FCPortPage0_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page0_dma);
+	if (ppage0_alloc) {
+		memset((u8 *)ppage0_alloc, 0, data_sz);
+		cfg.physAddr = page0_dma;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+		if ((rc = mpt_config(ioc, &cfg)) == 0) {
+			/* save the data */
+			pp0dest = &ioc->fc_port_page0[portnum];
+			copy_sz = min_t(int, sizeof(FCPortPage0_t), data_sz);
+			memcpy(pp0dest, ppage0_alloc, copy_sz);
+
+			/*
+			 *	Normalize endianness of structure data,
+			 *	by byte-swapping all > 1 byte fields!
+			 */
+			pp0dest->Flags = le32_to_cpu(pp0dest->Flags);
+			pp0dest->PortIdentifier = le32_to_cpu(pp0dest->PortIdentifier);
+			pp0dest->WWNN.Low = le32_to_cpu(pp0dest->WWNN.Low);
+			pp0dest->WWNN.High = le32_to_cpu(pp0dest->WWNN.High);
+			pp0dest->WWPN.Low = le32_to_cpu(pp0dest->WWPN.Low);
+			pp0dest->WWPN.High = le32_to_cpu(pp0dest->WWPN.High);
+			pp0dest->SupportedServiceClass = le32_to_cpu(pp0dest->SupportedServiceClass);
+			pp0dest->SupportedSpeeds = le32_to_cpu(pp0dest->SupportedSpeeds);
+			pp0dest->CurrentSpeed = le32_to_cpu(pp0dest->CurrentSpeed);
+			pp0dest->MaxFrameSize = le32_to_cpu(pp0dest->MaxFrameSize);
+			pp0dest->FabricWWNN.Low = le32_to_cpu(pp0dest->FabricWWNN.Low);
+			pp0dest->FabricWWNN.High = le32_to_cpu(pp0dest->FabricWWNN.High);
+			pp0dest->FabricWWPN.Low = le32_to_cpu(pp0dest->FabricWWPN.Low);
+			pp0dest->FabricWWPN.High = le32_to_cpu(pp0dest->FabricWWPN.High);
+			pp0dest->DiscoveredPortsCount = le32_to_cpu(pp0dest->DiscoveredPortsCount);
+			pp0dest->MaxInitiators = le32_to_cpu(pp0dest->MaxInitiators);
+
+		}
+
+		pci_free_consistent(ioc->pcidev, data_sz, (u8 *) ppage0_alloc, page0_dma);
+	}
+
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	GetManufPage5 - Fetch Manufacturing config Page5.
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@numPorts: number of ports for this IOC
+ *
+ *	Return: 0 for success
+ *	-ENOMEM if no memory available
+ *		-EPERM if not allowed due to ISR context
+ *		-EAGAIN if no msg frames currently available
+ *		-EFAULT for non-successful reply or no reply (timeout)
+ */
+static int
+GetManufPage5(MPT_ADAPTER *ioc, int numPorts)
+{
+	ConfigPageHeader_t	hdr;
+	CONFIGPARMS		cfg;
+	ManufacturingPage5_t	*mfgPage5=NULL;
+	dma_addr_t		mfgPage5_dma;
+	int			data_sz=0;
+	int			rc;
+	int			ii;
+
+	/* Get Manufacturing Page 5 header */
+	hdr.PageVersion = MPI_MANUFACTURING5_PAGEVERSION;
+	hdr.PageLength = 0;
+	hdr.PageNumber = 5;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_MANUFACTURING;
+	cfg.cfghdr.hdr = &hdr;
+	cfg.physAddr = -1;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	cfg.pageAddr = 0;
+	cfg.timeout = 0;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0) {
+		goto GetManufPage5_exit;
+	}
+
+	if (hdr.PageLength == 0) {
+		rc = -EFAULT;
+		goto GetManufPage5_exit;
+	}
+
+	data_sz = hdr.PageLength * 4;
+	mfgPage5 = (ManufacturingPage5_t *) pci_alloc_consistent(ioc->pcidev,
+	    data_sz, &mfgPage5_dma);
+	if (!mfgPage5) {
+		rc = -ENOMEM;
+		goto GetManufPage5_exit;
+	}
+
+	memset((u8 *)mfgPage5, 0, data_sz);
+	cfg.physAddr = mfgPage5_dma;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0) {
+		goto GetManufPage5_exit;
+	}
+
+	/*
+	 * Normalize endianness of structure data,
+	 * by byte-swapping all > 1 byte fields!
+	 */
+
+	ioc->sas_port_WWID[0].Low =
+	    le32_to_cpu(mfgPage5->BaseWWID.Low);
+	ioc->sas_port_WWID[0].High =
+	    le32_to_cpu(mfgPage5->BaseWWID.High);
+
+	/* The rest of the ports are numbered by
+	 * incrementing the base WWID.
+	 */
+	for (ii = 1; ii < numPorts; ii++) {
+		if (ioc->sas_port_WWID[ii-1].Low != 0xFFFFFFFF){
+			ioc->sas_port_WWID[ii].Low =
+			    ioc->sas_port_WWID[ii -1].Low + 1;
+			ioc->sas_port_WWID[ii].High =
+			    ioc->sas_port_WWID[ii-1].High;
+		} else {
+			ioc->sas_port_WWID[ii].Low = 0;
+			ioc->sas_port_WWID[ii].High =
+			    ioc->sas_port_WWID[ii-1].High + 1;
+		}
+
+	}
+
+GetManufPage5_exit:
+
+	if (mfgPage5)
+		pci_free_consistent(ioc->pcidev, data_sz,
+		    (u8 *) mfgPage5, mfgPage5_dma);
+
+	return rc;
+}
+
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	GetManufPage0 - Fetch Manufacturing config Page0.
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@numPorts: number of ports for this IOC
+ *
+ *	Return: 0 for success
+ *	-ENOMEM if no memory available
+ *		-EPERM if not allowed due to ISR context
+ *		-EAGAIN if no msg frames currently available
+ *		-EFAULT for non-successful reply or no reply (timeout)
+ */
+static int
+GetManufPage0(MPT_ADAPTER *ioc)
+{
+
+	ConfigPageHeader_t	 hdr;
+	CONFIGPARMS		 cfg;
+	ManufacturingPage0_t	*mfgPage0=NULL;
+	dma_addr_t		 mfgPage0_dma;
+	int			 data_sz=0;
+	int			 rc;
+
+	/* Get Manufacturing Page 0 header */
+	hdr.PageVersion = MPI_MANUFACTURING0_PAGEVERSION;
+	hdr.PageLength = 0;
+	hdr.PageNumber = 0;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_MANUFACTURING;
+	cfg.cfghdr.hdr = &hdr;
+	cfg.physAddr = -1;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	cfg.pageAddr = 0;
+	cfg.timeout = 0;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0) {
+		return rc;
+		goto GetManufPage0_exit;
+	}
+
+	if (hdr.PageLength == 0) {
+		rc = -EFAULT;
+		goto GetManufPage0_exit;
+	}
+
+	data_sz = hdr.PageLength * 4;
+	mfgPage0 = (ManufacturingPage0_t *) pci_alloc_consistent(ioc->pcidev,
+		data_sz, &mfgPage0_dma);
+	if (!mfgPage0) {
+		rc = -ENOMEM;
+		goto GetManufPage0_exit;
+	}
+
+	memset((u8 *)mfgPage0, 0, data_sz);
+	cfg.physAddr = mfgPage0_dma;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0) {
+		return rc;
+		goto GetManufPage0_exit;
+	}
+
+	/*
+	 *	Normalize endianness of structure data,
+	 *	by byte-swapping all > 1 byte fields!
+	 */
+	memcpy( ioc->BoardTracerNumber,
+	    mfgPage0->BoardTracerNumber, 16 );
+
+
+GetManufPage0_exit:
+
+	if (mfgPage0)
+		pci_free_consistent(ioc->pcidev, data_sz,
+		    (u8 *) mfgPage0, mfgPage0_dma);
+
+
+	return rc;
+}
+
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptbase_sas_get_info - Fetch Hw Max and Min Link Rates.  These values
+ *               get overwritten, so must be saved at init time.
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@numPorts: number of ports for this IOC
+ *
+ *	Return: 0 for success
+ *	-ENOMEM if no memory available
+ *		-EPERM if not allowed due to ISR context
+ *		-EAGAIN if no msg frames currently available
+ *		-EFAULT for non-successful reply or no reply (timeout)
+ */
+static int
+mptbase_sas_get_info(MPT_ADAPTER *ioc)
+{
+	ConfigExtendedPageHeader_t hdr;
+	CONFIGPARMS		cfg;
+	SasIOUnitPage0_t	*sasIoUnitPg0=NULL;
+	dma_addr_t		sasIoUnitPg0_dma;
+	SasPhyPage0_t		*sasPhyPg0=NULL;
+	dma_addr_t		sasPhyPg0_dma;
+	SasDevicePage0_t	*sasDevicePg0=NULL;
+	dma_addr_t		sasDevicePg0_dma;
+	sas_device_info_t	*sasDevice;
+	u32			devHandle;
+	int			sasIoUnitPg0_data_sz=0;
+	int			sasPhyPg0_data_sz=0;
+	int			sasDevicePg0_data_sz=0;
+	int			sz;
+	int		        rc;
+	int			ii;
+	int			phyCounter;
+	u8			*mem;
+	u64			SASAddress64;
+	char 			*ds = NULL;
+
+	/* Issue a config request to get the number of phys
+	 */
+	ioc->sasPhyInfo=NULL;
+
+	hdr.PageVersion = MPI_SASIOUNITPAGE0_PAGEVERSION;
+	hdr.ExtPageLength = 0;
+	hdr.PageNumber = 0;
+	hdr.Reserved1 = 0;
+	hdr.Reserved2 = 0;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;
+	hdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_IO_UNIT;
+
+	cfg.cfghdr.ehdr = &hdr;
+	cfg.physAddr = -1;
+	cfg.pageAddr = 0;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;	/* read */
+	cfg.timeout = 10;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0) {
+		goto mptbase_sas_get_info_exit;
+	}
+
+	if (hdr.ExtPageLength == 0) {
+		rc = -EFAULT;
+		goto mptbase_sas_get_info_exit;
+	}
+
+	sasIoUnitPg0_data_sz = hdr.ExtPageLength * 4;
+	sasIoUnitPg0 = (SasIOUnitPage0_t *) pci_alloc_consistent(ioc->pcidev,
+	    sasIoUnitPg0_data_sz, &sasIoUnitPg0_dma);
+	if (!sasIoUnitPg0) {
+		rc = -ENOMEM;
+		goto mptbase_sas_get_info_exit;
+	}
+
+	memset((u8 *)sasIoUnitPg0, 0, sasIoUnitPg0_data_sz);
+	cfg.physAddr = sasIoUnitPg0_dma;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0) {
+		goto mptbase_sas_get_info_exit;
+	}
+
+	/* save the data */
+	ioc->numPhys = sasIoUnitPg0->NumPhys;
+
+	dsasprintk((MYIOC_s_WARN_FMT "Number of PHYS=%d\n",
+	    ioc->name, sasIoUnitPg0->NumPhys));
+
+	sz = ioc->numPhys * sizeof (sas_phy_info_t);
+
+	if ((mem = kmalloc(sz, GFP_ATOMIC)) == NULL) {
+		rc = -ENOMEM;
+		goto mptbase_sas_get_info_exit;
+	}
+
+	memset(mem, 0, sz);
+	ioc->alloc_total += sz;
+	ioc->sasPhyInfo = (sas_phy_info_t *) mem;
+
+	/* Issue a config request to get phy information. */
+	hdr.PageVersion = MPI_SASPHY0_PAGEVERSION;
+	hdr.ExtPageLength = 0;
+	hdr.PageNumber = 0;
+	hdr.Reserved1 = 0;
+	hdr.Reserved2 = 0;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;
+	hdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_PHY;
+
+	cfg.cfghdr.ehdr = &hdr;
+	cfg.dir = 0;	/* read */
+	cfg.timeout = 10;
+
+	/* Fill in information for each phy. */
+	for (ii = 0; ii < ioc->numPhys; ii++) {
+
+		/* Get Phy Pg 0 for each Phy. */
+		cfg.pageAddr = ii;
+		cfg.physAddr = -1;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+
+		if ((rc = mpt_config(ioc, &cfg)) != 0) {
+			goto mptbase_sas_get_info_exit;
+		}
+
+		if (hdr.ExtPageLength == 0) {
+			rc = -EFAULT;
+			goto mptbase_sas_get_info_exit;
+		}
+
+		sasPhyPg0_data_sz = hdr.ExtPageLength * 4;
+		sasPhyPg0 = (SasPhyPage0_t *) pci_alloc_consistent(
+		    ioc->pcidev, sasPhyPg0_data_sz, &sasPhyPg0_dma);
+		if (!sasPhyPg0) {
+			rc = -ENOMEM;
+			goto mptbase_sas_get_info_exit;
+		}
+
+		memset((u8 *)sasPhyPg0, 0, sasPhyPg0_data_sz);
+		cfg.physAddr = sasPhyPg0_dma;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+		/* Save HwLinkRate.
+		 * It may be modified accidently via FW
+		 */
+		if ((rc = mpt_config(ioc, &cfg)) != 0) {
+			goto mptbase_sas_get_info_exit;
+		}
+
+		ioc->sasPhyInfo[ii].hwLinkRate = sasPhyPg0->HwLinkRate;
+		ioc->sasPhyInfo[ii].phyId = ii;
+		ioc->sasPhyInfo[ii].port = sasIoUnitPg0->PhyData[ii].Port;
+		ioc->sasPhyInfo[ii].ControllerDevHandle =
+		    le16_to_cpu(sasIoUnitPg0->PhyData[ii].ControllerDevHandle);
+		ioc->sasPhyInfo[ii].PortFlags =
+		    sasIoUnitPg0->PhyData[ii].PortFlags;
+		ioc->sasPhyInfo[ii].PhyFlags =
+		    sasIoUnitPg0->PhyData[ii].PhyFlags;
+		ioc->sasPhyInfo[ii].NegotiatedLinkRate =
+		    sasIoUnitPg0->PhyData[ii].NegotiatedLinkRate;
+		ioc->sasPhyInfo[ii].ControllerPhyDeviceInfo =
+		    le32_to_cpu(sasIoUnitPg0->PhyData[ii].ControllerPhyDeviceInfo);
+
+		memcpy(&SASAddress64,&sasPhyPg0->SASAddress,sizeof(sasPhyPg0->SASAddress));
+		le64_to_cpus(&SASAddress64);
+		if (SASAddress64) {
+			dsasprintk(("---- SAS PHY PAGE 0 ------------\n"));
+			dsasprintk(("Handle=0x%X\n",
+			    le16_to_cpu(sasPhyPg0->AttachedDevHandle)));
+			dsasprintk(("SAS Address=0x%llX\n",SASAddress64));
+			dsasprintk(("Attached PHY Identifier=0x%X\n",
+			    sasPhyPg0->AttachedPhyIdentifier));
+			dsasprintk(("Attached Device Info=0x%X\n",
+			    le32_to_cpu(sasPhyPg0->AttachedDeviceInfo)));
+			dsasprintk(("Programmed Link Rate=0x%X\n",
+			    sasPhyPg0->ProgrammedLinkRate));
+			dsasprintk(("Hardware Link Rate=0x%X\n",
+			    ioc->sasPhyInfo[ii].hwLinkRate));
+			dsasprintk(("Change Count=0x%X\n",
+			    sasPhyPg0->ChangeCount));
+			dsasprintk(("PHY Info=0x%X\n",
+			    le32_to_cpu(sasPhyPg0->PhyInfo)));
+			dsasprintk(("\n"));
+		}
+
+		pci_free_consistent(ioc->pcidev, sasPhyPg0_data_sz,
+		    (u8 *) sasPhyPg0, sasPhyPg0_dma);
+
+		sasPhyPg0=NULL;
+	}
+
+
+	/* Get all Device info and store in linked list. */
+	devHandle = 0xFFFF;
+	phyCounter=0;
+	while(1) {
+		/* Get SAS device page 0 */
+
+		hdr.PageVersion = MPI_SASDEVICE0_PAGEVERSION;
+		hdr.ExtPageLength = 0;
+		hdr.PageNumber = 0;
+		hdr.Reserved1 = 0;
+		hdr.Reserved2 = 0;
+		hdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;
+		hdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_DEVICE;
+
+		cfg.cfghdr.ehdr = &hdr;
+		cfg.physAddr = -1;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+		cfg.dir = 0;	/* read */
+		cfg.timeout = 10;
+
+		if ((rc = mpt_config(ioc, &cfg)) != 0) {
+			goto mptbase_sas_get_info_exit;
+		}
+
+		if (hdr.ExtPageLength == 0) {
+			rc = -EFAULT;
+			goto mptbase_sas_get_info_exit;
+		}
+
+		sasDevicePg0_data_sz = hdr.ExtPageLength * 4;
+		sasDevicePg0 = (SasDevicePage0_t *) pci_alloc_consistent(
+		    ioc->pcidev, sasDevicePg0_data_sz, &sasDevicePg0_dma);
+		if (!sasDevicePg0) {
+			rc = -ENOMEM;
+			goto mptbase_sas_get_info_exit;
+		}
+
+		memset((u8 *)sasDevicePg0, 0, sasDevicePg0_data_sz);
+		cfg.physAddr = sasDevicePg0_dma;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+		cfg.pageAddr = devHandle;
+
+		if ((rc = mpt_config(ioc, &cfg)) != 0) {
+
+		/*
+		 * break from the while loop when this fails
+		 * which means we have discovered all devices
+		 */
+			rc=0;
+			goto mptbase_sas_get_info_exit;
+		}
+
+		dsasprintk(("---- SAS DEVICE PAGE 0 ---------\n"));
+		dsasprintk(("Handle=0x%X\n",le16_to_cpu(sasDevicePg0->DevHandle)));
+		memcpy(&SASAddress64,&sasDevicePg0->SASAddress,sizeof(sasDevicePg0->SASAddress));
+		le64_to_cpus(&SASAddress64);
+		dsasprintk(("SAS Address=0x%llX\n",SASAddress64));
+		dsasprintk(("Target ID=0x%X\n",sasDevicePg0->TargetID));
+		dsasprintk(("Bus=0x%X\n",sasDevicePg0->Bus));
+		dsasprintk(("PhyNum=0x%X\n",sasDevicePg0->PhyNum));
+		dsasprintk(("AccessStatus=0x%X\n",le16_to_cpu(sasDevicePg0->AccessStatus)));
+		dsasprintk(("Device Info=0x%X\n",le32_to_cpu(sasDevicePg0->DeviceInfo)));
+		dsasprintk(("Flags=0x%X\n",le16_to_cpu(sasDevicePg0->Flags)));
+		dsasprintk(("Physical Port=0x%X\n",sasDevicePg0->PhysicalPort));
+		dsasprintk(("\n"));
+
+		if(phyCounter < ioc->numPhys) {
+			ioc->sasPhyInfo[phyCounter].SASAddress = SASAddress64;
+			ioc->sasPhyInfo[phyCounter].devHandle =
+				le16_to_cpu(sasDevicePg0->DevHandle);
+			phyCounter++;
+		}else {
+			if (sasDevicePg0->DeviceInfo &
+			    (MPI_SAS_DEVICE_INFO_SSP_TARGET |
+			     MPI_SAS_DEVICE_INFO_STP_TARGET |
+			     MPI_SAS_DEVICE_INFO_SATA_DEVICE )) {
+
+				if ((sasDevice = kmalloc(sizeof (sas_device_info_t),
+				    GFP_ATOMIC)) == NULL) {
+					rc = -ENOMEM;
+					goto mptbase_sas_get_info_exit;
+				}
+
+				memset(sasDevice, 0, sizeof (sas_device_info_t));
+				ioc->alloc_total += sizeof (sas_device_info_t);
+				list_add_tail(&sasDevice->list, &ioc->sasDeviceList);
+				sasDevice->SASAddress = SASAddress64;
+				sasDevice->TargetId = sasDevicePg0->TargetID;
+				sasDevice->Bus = sasDevicePg0->Bus;
+				sasDevice->deviceInfo =
+				  le32_to_cpu(sasDevicePg0->DeviceInfo);
+				sasDevice->devHandle =
+				   le16_to_cpu(sasDevicePg0->DevHandle);
+				sasDevice->flags =
+				    le16_to_cpu(sasDevicePg0->Flags);
+				sasDevice->phyNum = sasDevicePg0->PhyNum;
+				sasDevice->physicalPort =
+				    sasDevicePg0->PhysicalPort;
+				if(sasDevice->deviceInfo &
+				    MPI_SAS_DEVICE_INFO_SSP_TARGET)
+					ds = "sas";
+				if(sasDevice->deviceInfo &
+				    MPI_SAS_DEVICE_INFO_STP_TARGET)
+					ds = "stp";
+				if(sasDevice->deviceInfo &
+				    MPI_SAS_DEVICE_INFO_SATA_DEVICE)
+					ds = "sata";
+				dsasprintk(( 
+					"Inserting %s device, channel %d, id %d, phy %d\n\n",
+					ds,sasDevice->Bus,
+					sasDevice->TargetId,
+					sasDevicePg0->PhyNum));
+			}
+		}
+
+		devHandle = (MPI_SAS_DEVICE_PGAD_FORM_GET_NEXT_HANDLE
+			<< MPI_SAS_DEVICE_PGAD_FORM_SHIFT) |
+			sasDevicePg0->DevHandle;
+
+		pci_free_consistent(ioc->pcidev, sasDevicePg0_data_sz,
+			    (u8 *) sasDevicePg0, sasDevicePg0_dma);
 
-	if (!failcnt && (t = WaitForDoorbellInt(ioc, 2, sleepFlag)) < 0)
-		failcnt++;
-	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
+		sasDevicePg0=NULL;
 
-	if (failcnt) {
-		printk(MYIOC_s_ERR_FMT "Handshake reply failure!\n",
-				ioc->name);
-		return -failcnt;
-	}
-#if 0
-	else if (u16cnt != (2 * mptReply->MsgLength)) {
-		return -101;
-	}
-	else if ((mptReply->IOCStatus & MPI_IOCSTATUS_MASK) != MPI_IOCSTATUS_SUCCESS) {
-		return -102;
-	}
-#endif
+	};
 
-	dmfprintk((MYIOC_s_INFO_FMT "Got Handshake reply:\n", ioc->name));
-	DBG_DUMP_REPLY_FRAME(mptReply)
+mptbase_sas_get_info_exit:
 
-	dhsprintk((MYIOC_s_INFO_FMT "WaitForDoorbell REPLY (sz=%d)\n",
-			ioc->name, u16cnt/2));
-	return u16cnt/2;
-}
 
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/*
- *	GetLanConfigPages - Fetch LANConfig pages.
- *	@ioc: Pointer to MPT_ADAPTER structure
- *
- *	Return: 0 for success
- *	-ENOMEM if no memory available
- *		-EPERM if not allowed due to ISR context
- *		-EAGAIN if no msg frames currently available
- *		-EFAULT for non-successful reply or no reply (timeout)
- */
-static int
-GetLanConfigPages(MPT_ADAPTER *ioc)
-{
-	ConfigPageHeader_t	 hdr;
-	CONFIGPARMS		 cfg;
-	LANPage0_t		*ppage0_alloc;
-	dma_addr_t		 page0_dma;
-	LANPage1_t		*ppage1_alloc;
-	dma_addr_t		 page1_dma;
-	int			 rc = 0;
-	int			 data_sz;
-	int			 copy_sz;
+	if (sasPhyPg0)
+		pci_free_consistent(ioc->pcidev, sasPhyPg0_data_sz,
+		    (u8 *) sasPhyPg0, sasPhyPg0_dma);
 
-	/* Get LAN Page 0 header */
-	hdr.PageVersion = 0;
-	hdr.PageLength = 0;
-	hdr.PageNumber = 0;
-	hdr.PageType = MPI_CONFIG_PAGETYPE_LAN;
-	cfg.hdr = &hdr;
-	cfg.physAddr = -1;
-	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
-	cfg.dir = 0;
-	cfg.pageAddr = 0;
-	cfg.timeout = 0;
+	if (sasIoUnitPg0)
+		pci_free_consistent(ioc->pcidev, sasIoUnitPg0_data_sz,
+		    (u8 *) sasIoUnitPg0, sasIoUnitPg0_dma);
 
-	if ((rc = mpt_config(ioc, &cfg)) != 0)
-		return rc;
+	if (sasDevicePg0)
+		pci_free_consistent(ioc->pcidev, sasDevicePg0_data_sz,
+			    (u8 *) sasDevicePg0, sasDevicePg0_dma);
 
-	if (hdr.PageLength > 0) {
-		data_sz = hdr.PageLength * 4;
-		ppage0_alloc = (LANPage0_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page0_dma);
-		rc = -ENOMEM;
-		if (ppage0_alloc) {
-			memset((u8 *)ppage0_alloc, 0, data_sz);
-			cfg.physAddr = page0_dma;
-			cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+	return rc;
+}
 
-			if ((rc = mpt_config(ioc, &cfg)) == 0) {
-				/* save the data */
-				copy_sz = MIN(sizeof(LANPage0_t), data_sz);
-				memcpy(&ioc->lan_cnfg_page0, ppage0_alloc, copy_sz);
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+
+static void
+mptbase_sas_process_event_data(MPT_ADAPTER *ioc,
+    MpiEventDataSasDeviceStatusChange_t * pSasEventData)
+{
+	sas_device_info_t	*sasDevice;
+	int 			ii;
+	char			*ds=NULL;
+
+	switch(pSasEventData->ReasonCode) {
+	case MPI_EVENT_SAS_DEV_STAT_RC_ADDED:
+
+		// sanity check so we are not adding a target that is already in the list.
+		list_for_each_entry(sasDevice, &ioc->sasDeviceList, list) {
+			if (pSasEventData->TargetID ==
+			    sasDevice->TargetId)
+				return;
+				break; 
+		}
+
+		if ((pSasEventData->DeviceInfo &
+		    (MPI_SAS_DEVICE_INFO_SSP_TARGET |
+		     MPI_SAS_DEVICE_INFO_STP_TARGET |
+		     MPI_SAS_DEVICE_INFO_SATA_DEVICE )) == 0) {
+			break;
+		}
+		
+		if ((sasDevice = kmalloc(sizeof (sas_device_info_t),
+		    GFP_ATOMIC)) == NULL) {
+			break;
+		}
 
+		memset(sasDevice, 0, sizeof (sas_device_info_t));
+		list_add_tail(&sasDevice->list, &ioc->sasDeviceList);
+		ioc->alloc_total += sizeof (sas_device_info_t);
+		
+		memcpy(&sasDevice->SASAddress,&pSasEventData->SASAddress,sizeof(u64));
+		le64_to_cpus(&sasDevice->SASAddress);
+		sasDevice->TargetId = pSasEventData->TargetID;
+		sasDevice->Bus = pSasEventData->Bus;
+		sasDevice->deviceInfo =
+		    le32_to_cpu(pSasEventData->DeviceInfo);
+		sasDevice->devHandle =
+		    le16_to_cpu(pSasEventData->DevHandle);
+		sasDevice->phyNum = pSasEventData->PhyNum;
+		pSasEventData->ParentDevHandle =
+		    le16_to_cpu(pSasEventData->ParentDevHandle);
+
+		for(ii=0;ii<ioc->numPhys;ii++) {
+			if(pSasEventData->ParentDevHandle ==
+			    ioc->sasPhyInfo[ii].ControllerDevHandle) {
+				sasDevice->physicalPort =
+				    ioc->sasPhyInfo[ii].port;
 			}
+		}
 
-			pci_free_consistent(ioc->pcidev, data_sz, (u8 *) ppage0_alloc, page0_dma);
+		if(pSasEventData->DeviceInfo &
+		    MPI_SAS_DEVICE_INFO_SSP_TARGET)
+			ds = "sas";
+		if(pSasEventData->DeviceInfo &
+		    MPI_SAS_DEVICE_INFO_STP_TARGET)
+			ds = "stp";
+		if(pSasEventData->DeviceInfo &
+		    MPI_SAS_DEVICE_INFO_SATA_DEVICE)
+			ds = "sata";
+		dsasprintk(( 
+			"Inserting %s device, channel %d, id %d, phy %d\n\n",
+			ds,sasDevice->Bus,
+			sasDevice->TargetId,
+			pSasEventData->PhyNum));
+		dsasprintk(("SAS Address=0x%llX\n",sasDevice->SASAddress));
+		dsasprintk(("Device Info=0x%X\n",sasDevice->deviceInfo));
+		dsasprintk(("Physical Port=0x%X\n",sasDevice->physicalPort));
+		dsasprintk(("\n"));
 
-			/* FIXME!
-			 *	Normalize endianness of structure data,
-			 *	by byte-swapping all > 1 byte fields!
-			 */
+		break;
+	
+	case MPI_EVENT_SAS_DEV_STAT_RC_NOT_RESPONDING:
+		
+		list_for_each_entry(sasDevice, &ioc->sasDeviceList, list) {
 
+			if (pSasEventData->DevHandle ==
+			    sasDevice->devHandle) {
+		
+				dsasprintk(("Removing device from link list!!!\n\n"));
+				list_del(&sasDevice->list);
+				kfree(sasDevice);
+				ioc->alloc_total -= sizeof (sas_device_info_t);
+				break;
+			}
 		}
-
-		if (rc)
-			return rc;
+		break;
+	
+	case MPI_EVENT_SAS_DEV_STAT_RC_SMART_DATA:
+	case MPI_EVENT_SAS_DEV_STAT_RC_NO_PERSIST_ADDED:
+	case MPI_EVENT_SAS_DEV_STAT_RC_UNSUPPORTED:
+	default:
+		break;
 	}
 
-	/* Get LAN Page 1 header */
-	hdr.PageVersion = 0;
-	hdr.PageLength = 0;
-	hdr.PageNumber = 1;
-	hdr.PageType = MPI_CONFIG_PAGETYPE_LAN;
-	cfg.hdr = &hdr;
-	cfg.physAddr = -1;
-	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
-	cfg.dir = 0;
-	cfg.pageAddr = 0;
-
-	if ((rc = mpt_config(ioc, &cfg)) != 0)
-		return rc;
 
-	if (hdr.PageLength == 0)
-		return 0;
+}
 
-	data_sz = hdr.PageLength * 4;
-	rc = -ENOMEM;
-	ppage1_alloc = (LANPage1_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page1_dma);
-	if (ppage1_alloc) {
-		memset((u8 *)ppage1_alloc, 0, data_sz);
-		cfg.physAddr = page1_dma;
-		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
-		if ((rc = mpt_config(ioc, &cfg)) == 0) {
-			/* save the data */
-			copy_sz = MIN(sizeof(LANPage1_t), data_sz);
-			memcpy(&ioc->lan_cnfg_page1, ppage1_alloc, copy_sz);
-		}
+/* mptbase_sas_update_device_list - This is called from the work queue.
+ * Purpose is to called when a logical volume has been created or deleted.
+ * Since in SAS the phydisk can be moved to different location, we will need 
+ * to refresh the device list by recreating it.
+ */
+ 
+static void
+mptbase_sas_update_device_list(void * arg)
+{
 
-		pci_free_consistent(ioc->pcidev, data_sz, (u8 *) ppage1_alloc, page1_dma);
+	MPT_ADAPTER *ioc = (MPT_ADAPTER *)arg;
+	sas_device_info_t *sasDevice, *pNext;
 
-		/* FIXME!
-		 *	Normalize endianness of structure data,
-		 *	by byte-swapping all > 1 byte fields!
-		 */
+	// kill everything in the device list, then rediscover
+	list_for_each_entry_safe(sasDevice, pNext, &ioc->sasDeviceList, list) {
+		list_del(&sasDevice->list);
+		kfree(sasDevice);
+		ioc->alloc_total -= sizeof (sas_device_info_t);
+	}
 
+	if (ioc->sasPhyInfo != NULL) {
+		kfree(ioc->sasPhyInfo);
+		ioc->sasPhyInfo = NULL;
+		ioc->alloc_total -= 
+		    ioc->numPhys * sizeof (sas_phy_info_t);
 	}
+	
+	ioc->numPhys = 0;
+
+	// rescsan list
+	mptbase_sas_get_info(ioc);
 
-	return rc;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
- *	GetFcPortPage0 - Fetch FCPort config Page0.
+ *	mptbase_sas_persist_operation - Perform operation on SAS Persitent Table
  *	@ioc: Pointer to MPT_ADAPTER structure
- *	@portnum: IOC Port number
+ *	@sas_address: 64bit SAS Address for operation.
+ *	@target_id: specified target for operation
+ *	@bus: specified bus for operation
+ *	@persist_opcode: see below
+ *
+ *	MPI_SAS_OP_CLEAR_NOT_PRESENT - Free all persist TargetID mappings for
+ *		devices not currently present.
+ *	MPI_SAS_OP_CLEAR_ALL_PERSISTENT - Clear al persist TargetID mappings
  *
- *	Return: 0 for success
- *	-ENOMEM if no memory available
- *		-EPERM if not allowed due to ISR context
- *		-EAGAIN if no msg frames currently available
- *		-EFAULT for non-successful reply or no reply (timeout)
+ *	NOTE: Don't use not this function during interrupt time.
+ *
+ *	Returns: 0 for success, non-zero error
  */
-static int
-GetFcPortPage0(MPT_ADAPTER *ioc, int portnum)
-{
-	ConfigPageHeader_t	 hdr;
-	CONFIGPARMS		 cfg;
-	FCPortPage0_t		*ppage0_alloc;
-	FCPortPage0_t		*pp0dest;
-	dma_addr_t		 page0_dma;
-	int			 data_sz;
-	int			 copy_sz;
-	int			 rc;
 
-	/* Get FCPort Page 0 header */
-	hdr.PageVersion = 0;
-	hdr.PageLength = 0;
-	hdr.PageNumber = 0;
-	hdr.PageType = MPI_CONFIG_PAGETYPE_FC_PORT;
-	cfg.hdr = &hdr;
-	cfg.physAddr = -1;
-	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
-	cfg.dir = 0;
-	cfg.pageAddr = portnum;
-	cfg.timeout = 0;
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+int
+mptbase_sas_persist_operation(MPT_ADAPTER *ioc, u8 persist_opcode)
+{
+	SasIoUnitControlRequest_t	*sasIoUnitCntrReq;
+	SasIoUnitControlReply_t		*sasIoUnitCntrReply;
+	MPT_FRAME_HDR			*mf = NULL;
+	MPIHeader_t			*mpi_hdr;
 
-	if ((rc = mpt_config(ioc, &cfg)) != 0)
-		return rc;
 
-	if (hdr.PageLength == 0)
-		return 0;
+	/* insure garbage is not sent to fw */
+	switch(persist_opcode) {
 
-	data_sz = hdr.PageLength * 4;
-	rc = -ENOMEM;
-	ppage0_alloc = (FCPortPage0_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page0_dma);
-	if (ppage0_alloc) {
-		memset((u8 *)ppage0_alloc, 0, data_sz);
-		cfg.physAddr = page0_dma;
-		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+	case MPI_SAS_OP_CLEAR_NOT_PRESENT:
+	case MPI_SAS_OP_CLEAR_ALL_PERSISTENT:
+		break;
 
-		if ((rc = mpt_config(ioc, &cfg)) == 0) {
-			/* save the data */
-			pp0dest = &ioc->fc_port_page0[portnum];
-			copy_sz = MIN(sizeof(FCPortPage0_t), data_sz);
-			memcpy(pp0dest, ppage0_alloc, copy_sz);
+	default:
+		return -1;
+		break;
+	}
 
-			/*
-			 *	Normalize endianness of structure data,
-			 *	by byte-swapping all > 1 byte fields!
-			 */
-			pp0dest->Flags = le32_to_cpu(pp0dest->Flags);
-			pp0dest->PortIdentifier = le32_to_cpu(pp0dest->PortIdentifier);
-			pp0dest->WWNN.Low = le32_to_cpu(pp0dest->WWNN.Low);
-			pp0dest->WWNN.High = le32_to_cpu(pp0dest->WWNN.High);
-			pp0dest->WWPN.Low = le32_to_cpu(pp0dest->WWPN.Low);
-			pp0dest->WWPN.High = le32_to_cpu(pp0dest->WWPN.High);
-			pp0dest->SupportedServiceClass = le32_to_cpu(pp0dest->SupportedServiceClass);
-			pp0dest->SupportedSpeeds = le32_to_cpu(pp0dest->SupportedSpeeds);
-			pp0dest->CurrentSpeed = le32_to_cpu(pp0dest->CurrentSpeed);
-			pp0dest->MaxFrameSize = le32_to_cpu(pp0dest->MaxFrameSize);
-			pp0dest->FabricWWNN.Low = le32_to_cpu(pp0dest->FabricWWNN.Low);
-			pp0dest->FabricWWNN.High = le32_to_cpu(pp0dest->FabricWWNN.High);
-			pp0dest->FabricWWPN.Low = le32_to_cpu(pp0dest->FabricWWPN.Low);
-			pp0dest->FabricWWPN.High = le32_to_cpu(pp0dest->FabricWWPN.High);
-			pp0dest->DiscoveredPortsCount = le32_to_cpu(pp0dest->DiscoveredPortsCount);
-			pp0dest->MaxInitiators = le32_to_cpu(pp0dest->MaxInitiators);
+	printk("%s: persist_opcode=%x\n",__FUNCTION__, persist_opcode);
 
-		}
+	/* Get a MF for this command.
+	 */
+	if ((mf = mpt_get_msg_frame(mpt_base_index, ioc)) == NULL) {
+		printk("%s: no msg frames!\n",__FUNCTION__);
+		return -1;
+        }
 
-		pci_free_consistent(ioc->pcidev, data_sz, (u8 *) ppage0_alloc, page0_dma);
+	mpi_hdr = (MPIHeader_t *) mf;
+	sasIoUnitCntrReq = (SasIoUnitControlRequest_t *)mf;
+	memset(sasIoUnitCntrReq,0,sizeof(SasIoUnitControlRequest_t));
+	sasIoUnitCntrReq->Function = MPI_FUNCTION_SAS_IO_UNIT_CONTROL;
+	sasIoUnitCntrReq->MsgContext = mpi_hdr->MsgContext;
+	sasIoUnitCntrReq->Operation = persist_opcode;
+
+	init_timer(&ioc->persist_timer);
+	ioc->persist_timer.data = (unsigned long) ioc;
+	ioc->persist_timer.function = mpt_timer_expired;
+	ioc->persist_timer.expires = jiffies + HZ*10 /* 10 sec */;
+	ioc->persist_wait_done=0;
+	add_timer(&ioc->persist_timer);
+	mpt_put_msg_frame(mpt_base_index, ioc, mf);
+	wait_event(mpt_waitq, ioc->persist_wait_done);
+	mpt_free_msg_frame(ioc, mf);
+
+	sasIoUnitCntrReply =
+	    (SasIoUnitControlReply_t *)ioc->persist_reply_frame;
+	if ( sasIoUnitCntrReply->IOCStatus != MPI_IOCSTATUS_SUCCESS) {
+		printk("%s: IOCStatus=0x%X IOCLogInfo=0x%X\n",
+		    __FUNCTION__,
+		    sasIoUnitCntrReply->IOCStatus,
+		    sasIoUnitCntrReply->IOCLogInfo);
+		return -1;
 	}
 
-	return rc;
+	printk("%s: success\n",__FUNCTION__);
+	return 0;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -4213,7 +5302,7 @@ GetIoUnitPage2(MPT_ADAPTER *ioc)
 	hdr.PageLength = 0;
 	hdr.PageNumber = 2;
 	hdr.PageType = MPI_CONFIG_PAGETYPE_IO_UNIT;
-	cfg.hdr = &hdr;
+	cfg.cfghdr.hdr = &hdr;
 	cfg.physAddr = -1;
 	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
 	cfg.dir = 0;
@@ -4268,14 +5357,14 @@ GetIoUnitPage2(MPT_ADAPTER *ioc)
 static int
 mpt_GetScsiPortSettings(MPT_ADAPTER *ioc, int portnum)
 {
-	u8			*pbuf = NULL;
+	u8			*pbuf;
 	dma_addr_t		 buf_dma;
 	CONFIGPARMS		 cfg;
 	ConfigPageHeader_t	 header;
 	int			 ii;
 	int			 data, rc = 0;
 
-	/* Allocate memory 
+	/* Allocate memory
 	 */
 	if (!ioc->spi_data.nvram) {
 		int	 sz;
@@ -4287,7 +5376,7 @@ mpt_GetScsiPortSettings(MPT_ADAPTER *ioc
 
 		ioc->spi_data.nvram = (int *) mem;
 
-		dprintk((MYIOC_s_INFO_FMT "SCSI device NVRAM settings @ %p, sz=%d\n",
+		dprintk((MYIOC_s_WARN_FMT "SCSI device NVRAM settings @ %p, sz=%d\n",
 			ioc->name, ioc->spi_data.nvram, sz));
 	}
 
@@ -4303,7 +5392,7 @@ mpt_GetScsiPortSettings(MPT_ADAPTER *ioc
 	header.PageLength = 0;
 	header.PageNumber = 0;
 	header.PageType = MPI_CONFIG_PAGETYPE_SCSI_PORT;
-	cfg.hdr = &header;
+	cfg.cfghdr.hdr = &header;
 	cfg.physAddr = -1;
 	cfg.pageAddr = portnum;
 	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
@@ -4323,6 +5412,8 @@ mpt_GetScsiPortSettings(MPT_ADAPTER *ioc
 				ioc->spi_data.minSyncFactor = MPT_ASYNC;
 				ioc->spi_data.busType = MPT_HOST_BUS_UNKNOWN;
 				rc = 1;
+ 				ddvprintk((MYIOC_s_WARN_FMT "Unable to read PortPage0 minSyncFactor=%x\n",
+ 					ioc->name, ioc->spi_data.minSyncFactor));
 			} else {
 				/* Save the Port Page 0 data
 				 */
@@ -4330,12 +5421,19 @@ mpt_GetScsiPortSettings(MPT_ADAPTER *ioc
 				pPP0->Capabilities = le32_to_cpu(pPP0->Capabilities);
 				pPP0->PhysicalInterface = le32_to_cpu(pPP0->PhysicalInterface);
 
+				if ( (pPP0->Capabilities & MPI_SCSIPORTPAGE0_CAP_QAS) == 0 ) {
+					ioc->spi_data.noQas |= MPT_TARGET_NO_NEGO_QAS;
+					ddvprintk((KERN_INFO MYNAM " :%s noQas due to Capabilities=%x\n",
+						ioc->name, pPP0->Capabilities));
+				}
 				ioc->spi_data.maxBusWidth = pPP0->Capabilities & MPI_SCSIPORTPAGE0_CAP_WIDE ? 1 : 0;
 				data = pPP0->Capabilities & MPI_SCSIPORTPAGE0_CAP_MAX_SYNC_OFFSET_MASK;
 				if (data) {
 					ioc->spi_data.maxSyncOffset = (u8) (data >> 16);
 					data = pPP0->Capabilities & MPI_SCSIPORTPAGE0_CAP_MIN_SYNC_PERIOD_MASK;
 					ioc->spi_data.minSyncFactor = (u8) (data >> 8);
+ 					ddvprintk((MYIOC_s_WARN_FMT "PortPage0 minSyncFactor=%x\n",
+ 						ioc->name, ioc->spi_data.minSyncFactor));
 				} else {
 					ioc->spi_data.maxSyncOffset = 0;
 					ioc->spi_data.minSyncFactor = MPT_ASYNC;
@@ -4348,13 +5446,15 @@ mpt_GetScsiPortSettings(MPT_ADAPTER *ioc
 				if ((ioc->spi_data.busType == MPI_SCSIPORTPAGE0_PHY_SIGNAL_HVD) ||
 					(ioc->spi_data.busType == MPI_SCSIPORTPAGE0_PHY_SIGNAL_SE))  {
 
-					if (ioc->spi_data.minSyncFactor < MPT_ULTRA)
+					if (ioc->spi_data.minSyncFactor < MPT_ULTRA) {
 						ioc->spi_data.minSyncFactor = MPT_ULTRA;
+ 						ddvprintk((MYIOC_s_WARN_FMT "HVD or SE detected, minSyncFactor=%x\n",
+ 							ioc->name, ioc->spi_data.minSyncFactor));
+ 					}
 				}
 			}
 			if (pbuf) {
 				pci_free_consistent(ioc->pcidev, header.PageLength * 4, pbuf, buf_dma);
-				pbuf = NULL;
 			}
 		}
 	}
@@ -4365,7 +5465,7 @@ mpt_GetScsiPortSettings(MPT_ADAPTER *ioc
 	header.PageLength = 0;
 	header.PageNumber = 2;
 	header.PageType = MPI_CONFIG_PAGETYPE_SCSI_PORT;
-	cfg.hdr = &header;
+	cfg.cfghdr.hdr = &header;
 	cfg.physAddr = -1;
 	cfg.pageAddr = portnum;
 	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
@@ -4391,16 +5491,21 @@ mpt_GetScsiPortSettings(MPT_ADAPTER *ioc
 				/* Save the Port Page 2 data
 				 * (reformat into a 32bit quantity)
 				 */
+				data = le32_to_cpu(pPP2->PortFlags) & MPI_SCSIPORTPAGE2_PORT_FLAGS_DV_MASK;
+				ioc->spi_data.PortFlags = data;
+				ddvprintk((MYIOC_s_NOTE_FMT "DV PortFlags=%x\n",
+					ioc->name, ioc->spi_data.PortFlags));
 				for (ii=0; ii < MPT_MAX_SCSI_DEVICES; ii++) {
 					pdevice = &pPP2->DeviceSettings[ii];
 					data = (le16_to_cpu(pdevice->DeviceFlags) << 16) |
 						(pdevice->SyncFactor << 8) | pdevice->Timeout;
 					ioc->spi_data.nvram[ii] = data;
+ 					ddvprintk((MYIOC_s_WARN_FMT "PortPage2 nvram=%x for id=%d\n",
+ 						ioc->name, data, ii));
 				}
 			}
 
 			pci_free_consistent(ioc->pcidev, header.PageLength * 4, pbuf, buf_dma);
-			pbuf = NULL;
 		}
 	}
 
@@ -4432,7 +5537,7 @@ mpt_readScsiDevicePageHeaders(MPT_ADAPTE
 	header.PageLength = 0;
 	header.PageNumber = 1;
 	header.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;
-	cfg.hdr = &header;
+	cfg.cfghdr.hdr = &header;
 	cfg.physAddr = -1;
 	cfg.pageAddr = portnum;
 	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
@@ -4441,8 +5546,8 @@ mpt_readScsiDevicePageHeaders(MPT_ADAPTE
 	if (mpt_config(ioc, &cfg) != 0)
 		 return -EFAULT;
 
-	ioc->spi_data.sdp1version = cfg.hdr->PageVersion;
-	ioc->spi_data.sdp1length = cfg.hdr->PageLength;
+	ioc->spi_data.sdp1version = cfg.cfghdr.hdr->PageVersion;
+	ioc->spi_data.sdp1length = cfg.cfghdr.hdr->PageLength;
 
 	header.PageVersion = 0;
 	header.PageLength = 0;
@@ -4451,15 +5556,20 @@ mpt_readScsiDevicePageHeaders(MPT_ADAPTE
 	if (mpt_config(ioc, &cfg) != 0)
 		 return -EFAULT;
 
-	ioc->spi_data.sdp0version = cfg.hdr->PageVersion;
-	ioc->spi_data.sdp0length = cfg.hdr->PageLength;
+	ioc->spi_data.sdp0version = cfg.cfghdr.hdr->PageVersion;
+	ioc->spi_data.sdp0length = cfg.cfghdr.hdr->PageLength;
 
+	dcprintk((MYIOC_s_WARN_FMT "Headers: 0: version %d length %d\n",
+			ioc->name, ioc->spi_data.sdp0version, ioc->spi_data.sdp0length));
+
+	dcprintk((MYIOC_s_WARN_FMT "Headers: 1: version %d length %d\n",
+			ioc->name, ioc->spi_data.sdp1version, ioc->spi_data.sdp1length));
 	return 0;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
- *	mpt_findImVolumes - Identify IDs of hidden disks and RAID Volumes 
+ *	mpt_findImVolumes - Identify IDs of hidden disks and RAID Volumes
  *	@ioc: Pointer to a Adapter Strucutre
  *	@portnum: IOC port number
  *
@@ -4468,11 +5578,12 @@ mpt_readScsiDevicePageHeaders(MPT_ADAPTE
  *	-EFAULT if read of config page header fails or data pointer not NULL
  *	-ENOMEM if pci_alloc failed
  */
-static int
+int
 mpt_findImVolumes(MPT_ADAPTER *ioc)
 {
-	IOCPage2_t		*pIoc2 = NULL;
-	ConfigPageIoc2RaidVol_t	*pIocRv = NULL;
+	IOCPage2_t		*pIoc2;
+	u8			*mem;
+	ConfigPageIoc2RaidVol_t	*pIocRv;
 	dma_addr_t		 ioc2_dma;
 	CONFIGPARMS		 cfg;
 	ConfigPageHeader_t	 header;
@@ -4482,16 +5593,13 @@ mpt_findImVolumes(MPT_ADAPTER *ioc)
 	u8			 nVols, nPhys;
 	u8			 vid, vbus, vioc;
 
-	if (ioc->spi_data.pIocPg3)
-		return -EFAULT;	
-
 	/* Read IOCP2 header then the page.
 	 */
 	header.PageVersion = 0;
 	header.PageLength = 0;
 	header.PageNumber = 2;
 	header.PageType = MPI_CONFIG_PAGETYPE_IOC;
-	cfg.hdr = &header;
+	cfg.cfghdr.hdr = &header;
 	cfg.physAddr = -1;
 	cfg.pageAddr = 0;
 	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
@@ -4513,11 +5621,22 @@ mpt_findImVolumes(MPT_ADAPTER *ioc)
 	if (mpt_config(ioc, &cfg) != 0)
 		goto done_and_free;
 
+	if ( (mem = (u8 *)ioc->spi_data.pIocPg2) == NULL ) {
+		mem = kmalloc(iocpage2sz, GFP_ATOMIC);
+		if (mem) {
+			ioc->spi_data.pIocPg2 = (IOCPage2_t *) mem;
+		} else {
+			goto done_and_free;
+		}
+	}
+	memcpy(mem, (u8 *)pIoc2, iocpage2sz);
+
 	/* Identify RAID Volume Id's */
 	nVols = pIoc2->NumActiveVolumes;
 	if ( nVols == 0) {
-		/* No RAID Volumes.  Done.
+		/* No RAID Volume.
 		 */
+		goto done_and_free;
 	} else {
 		/* At least 1 RAID Volume
 		 */
@@ -4542,17 +5661,14 @@ mpt_findImVolumes(MPT_ADAPTER *ioc)
 	/* Identify Hidden Physical Disk Id's */
 	nPhys = pIoc2->NumActivePhysDisks;
 	if (nPhys == 0) {
-		/* No physical disks. Done.
+		/* No physical disks.
 		 */
 	} else {
 		mpt_read_ioc_pg_3(ioc);
 	}
 
 done_and_free:
-	if (pIoc2) {
-		pci_free_consistent(ioc->pcidev, iocpage2sz, pIoc2, ioc2_dma);
-		pIoc2 = NULL;
-	}
+	pci_free_consistent(ioc->pcidev, iocpage2sz, pIoc2, ioc2_dma);
 
 	return rc;
 }
@@ -4560,7 +5676,7 @@ done_and_free:
 int
 mpt_read_ioc_pg_3(MPT_ADAPTER *ioc)
 {
-	IOCPage3_t		*pIoc3 = NULL;
+	IOCPage3_t		*pIoc3;
 	u8			*mem;
 	CONFIGPARMS		 cfg;
 	ConfigPageHeader_t	 header;
@@ -4581,7 +5697,7 @@ mpt_read_ioc_pg_3(MPT_ADAPTER *ioc)
 	header.PageLength = 0;
 	header.PageNumber = 3;
 	header.PageType = MPI_CONFIG_PAGETYPE_IOC;
-	cfg.hdr = &header;
+	cfg.cfghdr.hdr = &header;
 	cfg.physAddr = -1;
 	cfg.pageAddr = 0;
 	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
@@ -4613,18 +5729,66 @@ mpt_read_ioc_pg_3(MPT_ADAPTER *ioc)
 		}
 	}
 
-	if (pIoc3) {
-		pci_free_consistent(ioc->pcidev, iocpage3sz, pIoc3, ioc3_dma);
-		pIoc3 = NULL;
+	pci_free_consistent(ioc->pcidev, iocpage3sz, pIoc3, ioc3_dma);
+
+	return 0;
+}
+
+static void
+mpt_read_ioc_pg_4(MPT_ADAPTER *ioc)
+{
+	IOCPage4_t		*pIoc4;
+	CONFIGPARMS		 cfg;
+	ConfigPageHeader_t	 header;
+	dma_addr_t		 ioc4_dma;
+	int			 iocpage4sz;
+
+	/* Read and save IOC Page 4
+	 */
+	header.PageVersion = 0;
+	header.PageLength = 0;
+	header.PageNumber = 4;
+	header.PageType = MPI_CONFIG_PAGETYPE_IOC;
+	cfg.cfghdr.hdr = &header;
+	cfg.physAddr = -1;
+	cfg.pageAddr = 0;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	cfg.timeout = 0;
+	if (mpt_config(ioc, &cfg) != 0)
+		return;
+
+	if (header.PageLength == 0)
+		return;
+
+	if ( (pIoc4 = ioc->spi_data.pIocPg4) == NULL ) {
+		iocpage4sz = (header.PageLength + 4) * 4; /* Allow 4 additional SEP's */
+		pIoc4 = pci_alloc_consistent(ioc->pcidev, iocpage4sz, &ioc4_dma);
+		if (!pIoc4)
+			return;
+	} else {
+		ioc4_dma = ioc->spi_data.IocPg4_dma;
+		iocpage4sz = ioc->spi_data.IocPg4Sz;
+	}
+
+	/* Read the Page into dma memory.
+	 */
+	cfg.physAddr = ioc4_dma;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+	if (mpt_config(ioc, &cfg) == 0) {
+		ioc->spi_data.pIocPg4 = (IOCPage4_t *) pIoc4;
+		ioc->spi_data.IocPg4_dma = ioc4_dma;
+		ioc->spi_data.IocPg4Sz = iocpage4sz;
+	} else {
+		pci_free_consistent(ioc->pcidev, iocpage4sz, pIoc4, ioc4_dma);
+		ioc->spi_data.pIocPg4 = NULL;
 	}
-
-	return 0;
 }
 
 static void
 mpt_read_ioc_pg_1(MPT_ADAPTER *ioc)
 {
-	IOCPage1_t		*pIoc1 = NULL;
+	IOCPage1_t		*pIoc1;
 	CONFIGPARMS		 cfg;
 	ConfigPageHeader_t	 header;
 	dma_addr_t		 ioc1_dma;
@@ -4637,7 +5801,7 @@ mpt_read_ioc_pg_1(MPT_ADAPTER *ioc)
 	header.PageLength = 0;
 	header.PageNumber = 1;
 	header.PageType = MPI_CONFIG_PAGETYPE_IOC;
-	cfg.hdr = &header;
+	cfg.cfghdr.hdr = &header;
 	cfg.physAddr = -1;
 	cfg.pageAddr = 0;
 	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
@@ -4666,7 +5830,7 @@ mpt_read_ioc_pg_1(MPT_ADAPTER *ioc)
 		if (tmp == MPI_IOCPAGE1_REPLY_COALESCING) {
 			tmp = le32_to_cpu(pIoc1->CoalescingTimeout);
 
-			dprintk((MYIOC_s_INFO_FMT "Coalescing Enabled Timeout = %d\n",
+			dprintk((MYIOC_s_WARN_FMT "Coalescing Enabled Timeout = %d\n",
 					ioc->name, tmp));
 
 			if (tmp > MPT_COALESCING_TIMEOUT) {
@@ -4677,15 +5841,15 @@ mpt_read_ioc_pg_1(MPT_ADAPTER *ioc)
 				cfg.dir = 1;
 				cfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;
 				if (mpt_config(ioc, &cfg) == 0) {
-					dprintk((MYIOC_s_INFO_FMT "Reset Current Coalescing Timeout to = %d\n",
+					dprintk((MYIOC_s_WARN_FMT "Reset Current Coalescing Timeout to = %d\n",
 							ioc->name, MPT_COALESCING_TIMEOUT));
 
 					cfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_NVRAM;
 					if (mpt_config(ioc, &cfg) == 0) {
-						dprintk((MYIOC_s_INFO_FMT "Reset NVRAM Coalescing Timeout to = %d\n",
+						dprintk((MYIOC_s_WARN_FMT "Reset NVRAM Coalescing Timeout to = %d\n",
 								ioc->name, MPT_COALESCING_TIMEOUT));
 					} else {
-						dprintk((MYIOC_s_INFO_FMT "Reset NVRAM Coalescing Timeout Failed\n",
+						dprintk((MYIOC_s_WARN_FMT "Reset NVRAM Coalescing Timeout Failed\n",
 									ioc->name));
 					}
 
@@ -4700,10 +5864,7 @@ mpt_read_ioc_pg_1(MPT_ADAPTER *ioc)
 		}
 	}
 
-	if (pIoc1) {
-		pci_free_consistent(ioc->pcidev, iocpage1sz, pIoc1, ioc1_dma);
-		pIoc1 = NULL;
-	}
+	pci_free_consistent(ioc->pcidev, iocpage1sz, pIoc1, ioc1_dma);
 
 	return;
 }
@@ -4720,22 +5881,23 @@ SendEventNotification(MPT_ADAPTER *ioc, 
 {
 	EventNotification_t	*evnp;
 
-	evnp = (EventNotification_t *) mpt_get_msg_frame(mpt_base_index, ioc->id);
+	evnp = (EventNotification_t *) mpt_get_msg_frame(mpt_base_index, ioc);
 	if (evnp == NULL) {
-		dprintk((MYIOC_s_WARN_FMT "Unable to allocate event request frame!\n",
+		dfailprintk((MYIOC_s_WARN_FMT "Unable to allocate event request frame!\n",
 				ioc->name));
 		return 0;
 	}
+	ioc->evnp = evnp;
 	memset(evnp, 0, sizeof(*evnp));
 
-	dprintk((MYIOC_s_INFO_FMT "Sending EventNotification(%d)\n", ioc->name, EvSwitch));
+	devtprintk((MYIOC_s_WARN_FMT "Sending EventNotification (%d) request %p\n", ioc->name, EvSwitch, evnp));
 
 	evnp->Function = MPI_FUNCTION_EVENT_NOTIFICATION;
 	evnp->ChainOffset = 0;
 	evnp->MsgFlags = 0;
 	evnp->Switch = EvSwitch;
 
-	mpt_put_msg_frame(mpt_base_index, ioc->id, (MPT_FRAME_HDR *)evnp);
+	mpt_put_msg_frame(mpt_base_index, ioc, (MPT_FRAME_HDR *)evnp);
 
 	return 0;
 }
@@ -4751,14 +5913,15 @@ SendEventAck(MPT_ADAPTER *ioc, EventNoti
 {
 	EventAck_t	*pAck;
 
-	if ((pAck = (EventAck_t *) mpt_get_msg_frame(mpt_base_index, ioc->id)) == NULL) {
-		printk(MYIOC_s_WARN_FMT "Unable to allocate event ACK request frame!\n",
-				ioc->name);
+	if ((pAck = (EventAck_t *) mpt_get_msg_frame(mpt_base_index, ioc)) == NULL) {
+		printk(MYIOC_s_WARN_FMT "Unable to allocate event ACK request frame for Event=%x EventContext=%x EventData=%x!\n",
+				ioc->name, evnp->Event, evnp->EventContext, 
+				evnp->Data[0]);
 		return -1;
 	}
 	memset(pAck, 0, sizeof(*pAck));
 
-	dprintk((MYIOC_s_INFO_FMT "Sending EventAck\n", ioc->name));
+	dprintk((MYIOC_s_WARN_FMT "Sending EventAck\n", ioc->name));
 
 	pAck->Function     = MPI_FUNCTION_EVENT_ACK;
 	pAck->ChainOffset  = 0;
@@ -4766,7 +5929,7 @@ SendEventAck(MPT_ADAPTER *ioc, EventNoti
 	pAck->Event        = evnp->Event;
 	pAck->EventContext = evnp->EventContext;
 
-	mpt_put_msg_frame(mpt_base_index, ioc->id, (MPT_FRAME_HDR *)pAck);
+	mpt_put_msg_frame(mpt_base_index, ioc, (MPT_FRAME_HDR *)pAck);
 
 	return 0;
 }
@@ -4789,28 +5952,27 @@ int
 mpt_config(MPT_ADAPTER *ioc, CONFIGPARMS *pCfg)
 {
 	Config_t	*pReq;
+	ConfigExtendedPageHeader_t  *pExtHdr = NULL;
 	MPT_FRAME_HDR	*mf;
 	unsigned long	 flags;
 	int		 ii, rc;
 	int		 flagsLength;
 	int		 in_isr;
 
-	/* (Bugzilla:fibrebugs, #513)
-	 * Bug fix (part 1)!  20010905 -sralston
-	 *	Prevent calling wait_event() (below), if caller happens
+	/*	Prevent calling wait_event() (below), if caller happens
 	 *	to be in ISR context, because that is fatal!
 	 */
 	in_isr = in_interrupt();
 	if (in_isr) {
-		dprintk((MYIOC_s_WARN_FMT "Config request not allowed in ISR context!\n",
+		dcprintk((MYIOC_s_WARN_FMT "Config request not allowed in ISR context!\n",
 				ioc->name));
 		return -EPERM;
 	}
 
 	/* Get and Populate a free Frame
 	 */
-	if ((mf = mpt_get_msg_frame(mpt_base_index, ioc->id)) == NULL) {
-		dprintk((MYIOC_s_WARN_FMT "mpt_config: no msg frames!\n",
+	if ((mf = mpt_get_msg_frame(mpt_base_index, ioc)) == NULL) {
+		dfailprintk((MYIOC_s_WARN_FMT "mpt_config: no msg frames!\n",
 				ioc->name));
 		return -EAGAIN;
 	}
@@ -4819,17 +5981,30 @@ mpt_config(MPT_ADAPTER *ioc, CONFIGPARMS
 	pReq->Reserved = 0;
 	pReq->ChainOffset = 0;
 	pReq->Function = MPI_FUNCTION_CONFIG;
-	pReq->Reserved1[0] = 0;
-	pReq->Reserved1[1] = 0;
-	pReq->Reserved1[2] = 0;
+
+	/* Assume page type is not extended and clear "reserved" fields. */
+	pReq->ExtPageLength = 0;
+	pReq->ExtPageType = 0;
 	pReq->MsgFlags = 0;
+
 	for (ii=0; ii < 8; ii++)
 		pReq->Reserved2[ii] = 0;
 
-	pReq->Header.PageVersion = pCfg->hdr->PageVersion;
-	pReq->Header.PageLength = pCfg->hdr->PageLength;
-	pReq->Header.PageNumber = pCfg->hdr->PageNumber;
-	pReq->Header.PageType = (pCfg->hdr->PageType & MPI_CONFIG_PAGETYPE_MASK);
+	pReq->Header.PageVersion = pCfg->cfghdr.hdr->PageVersion;
+	pReq->Header.PageLength = pCfg->cfghdr.hdr->PageLength;
+	pReq->Header.PageNumber = pCfg->cfghdr.hdr->PageNumber;
+	pReq->Header.PageType = (pCfg->cfghdr.hdr->PageType & MPI_CONFIG_PAGETYPE_MASK);
+
+	if ((pCfg->cfghdr.hdr->PageType & MPI_CONFIG_PAGETYPE_MASK) == MPI_CONFIG_PAGETYPE_EXTENDED) {
+		pExtHdr = (ConfigExtendedPageHeader_t *)pCfg->cfghdr.ehdr;
+		pReq->ExtPageLength = cpu_to_le16(pExtHdr->ExtPageLength);
+		pReq->ExtPageType = pExtHdr->ExtPageType;
+		pReq->Header.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;
+
+		/* Page Length must be treated as a reserved field for the extended header. */
+		pReq->Header.PageLength = 0;
+	}
+
 	pReq->PageAddress = cpu_to_le32(pCfg->pageAddr);
 
 	/* Add a SGE to the config request.
@@ -4839,12 +6014,135 @@ mpt_config(MPT_ADAPTER *ioc, CONFIGPARMS
 	else
 		flagsLength = MPT_SGE_FLAGS_SSIMPLE_READ;
 
-	flagsLength |= pCfg->hdr->PageLength * 4;
+	if ((pCfg->cfghdr.hdr->PageType & MPI_CONFIG_PAGETYPE_MASK) == MPI_CONFIG_PAGETYPE_EXTENDED) {
+		flagsLength |= pExtHdr->ExtPageLength * 4;
+
+		dcprintk((MYIOC_s_WARN_FMT "Sending Config request type %d, page %d and action %d\n",
+			ioc->name, pReq->ExtPageType, pReq->Header.PageNumber, pReq->Action));
+	}
+	else {
+		flagsLength |= pCfg->cfghdr.hdr->PageLength * 4;
+
+		dcprintk((MYIOC_s_WARN_FMT "Sending Config request type %d, page %d and action %d\n",
+			ioc->name, pReq->Header.PageType, pReq->Header.PageNumber, pReq->Action));
+	}
 
 	mpt_add_sge((char *)&pReq->PageBufferSGE, flagsLength, pCfg->physAddr);
 
-	dprintk((MYIOC_s_INFO_FMT "Sending Config request type %d, page %d and action %d\n",
-		ioc->name, pReq->Header.PageType, pReq->Header.PageNumber, pReq->Action));
+	/* Append pCfg pointer to end of mf
+	 */
+	*((void **) (((u8 *) mf) + (ioc->req_sz - sizeof(void *)))) =  (void *) pCfg;
+
+	/* Initalize the timer
+	 */
+	init_timer(&pCfg->timer);
+	pCfg->timer.data = (unsigned long) ioc;
+	pCfg->timer.function = mpt_timer_expired;
+	pCfg->wait_done = 0;
+
+	/* Set the timer; ensure 10 second minimum */
+	if (pCfg->timeout < 10)
+		pCfg->timer.expires = jiffies + HZ*10;
+	else
+		pCfg->timer.expires = jiffies + HZ*pCfg->timeout;
+
+	/* Add to end of Q, set timer and then issue this command */
+	spin_lock_irqsave(&ioc->FreeQlock, flags);
+	Q_ADD_TAIL(&ioc->configQ.head, &pCfg->linkage, Q_ITEM);
+	spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+
+#ifdef MFCNT
+	dcprintk(("config send mfcnt=%d\n", ioc->mfcnt));
+#endif
+	add_timer(&pCfg->timer);
+	mpt_put_msg_frame(mpt_base_index, ioc, mf);
+	wait_event(mpt_waitq, pCfg->wait_done);
+
+	/* mf has been freed - do not access */
+#ifdef MFCNT
+	dcprintk(("config done mfcnt=%d\n", ioc->mfcnt));
+#endif
+
+	rc = pCfg->status;
+
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/**
+ *	mpt_toolbox - Generic function to issue toolbox message
+ *	@ioc - Pointer to an adapter structure
+ *	@cfg - Pointer to a toolbox structure. Struct contains
+ *		action, page address, direction, physical address
+ *		and pointer to a configuration page header
+ *		Page header is updated.
+ *
+ *	Returns 0 for success
+ *	-EPERM if not allowed due to ISR context
+ *	-EAGAIN if no msg frames currently available
+ *	-EFAULT for non-successful reply or no reply (timeout)
+ */
+int
+mpt_toolbox(MPT_ADAPTER *ioc, CONFIGPARMS *pCfg)
+{
+	ToolboxIstwiReadWriteRequest_t	*pReq;
+	MPT_FRAME_HDR	*mf;
+	struct pci_dev	*pdev;
+	unsigned long	 flags;
+	int		 rc;
+	u32		 flagsLength;
+	int		 in_isr;
+
+	/*	Prevent calling wait_event() (below), if caller happens
+	 *	to be in ISR context, because that is fatal!
+	 */
+	in_isr = in_interrupt();
+	if (in_isr) {
+		dcprintk((MYIOC_s_WARN_FMT "toobox request not allowed in ISR context!\n",
+				ioc->name));
+		return -EPERM;
+	}
+
+	/* Get and Populate a free Frame
+	 */
+	if ((mf = mpt_get_msg_frame(mpt_base_index, ioc)) == NULL) {
+		dfailprintk((MYIOC_s_WARN_FMT "mpt_toolbox: no msg frames!\n",
+				ioc->name));
+		return -EAGAIN;
+	}
+	pReq = (ToolboxIstwiReadWriteRequest_t	*)mf;
+	pReq->Tool = pCfg->action;
+	pReq->Reserved = 0;
+	pReq->ChainOffset = 0;
+	pReq->Function = MPI_FUNCTION_TOOLBOX;
+	pReq->Reserved1 = 0;
+	pReq->Reserved2 = 0;
+	pReq->MsgFlags = 0;
+	pReq->Flags = pCfg->dir;
+	pReq->BusNum = 0;
+	pReq->Reserved3 = 0;
+	pReq->NumAddressBytes = 0x01;
+	pReq->Reserved4 = 0;
+	pReq->DataLength = 0x04;
+	pdev = ioc->pcidev;
+	if (pdev->devfn & 1)
+		pReq->DeviceAddr = 0xB2;
+	else
+		pReq->DeviceAddr = 0xB0;
+	pReq->Addr1 = 0;
+	pReq->Addr2 = 0;
+	pReq->Addr3 = 0;
+	pReq->Reserved5 = 0;
+
+	/* Add a SGE to the config request.
+	 */
+
+	flagsLength = MPT_SGE_FLAGS_SSIMPLE_READ | 4;
+
+	mpt_add_sge((char *)&pReq->SGL, flagsLength, pCfg->physAddr);
+
+	dcprintk((MYIOC_s_WARN_FMT "Sending Toolbox request, Tool=%x\n",
+		ioc->name, pReq->Tool));
 
 	/* Append pCfg pointer to end of mf
 	 */
@@ -4869,7 +6167,7 @@ mpt_config(MPT_ADAPTER *ioc, CONFIGPARMS
 	spin_unlock_irqrestore(&ioc->FreeQlock, flags);
 
 	add_timer(&pCfg->timer);
-	mpt_put_msg_frame(mpt_base_index, ioc->id, mf);
+	mpt_put_msg_frame(mpt_base_index, ioc, mf);
 	wait_event(mpt_waitq, pCfg->wait_done);
 
 	/* mf has been freed - do not access */
@@ -4890,7 +6188,7 @@ mpt_timer_expired(unsigned long data)
 {
 	MPT_ADAPTER *ioc = (MPT_ADAPTER *) data;
 
-	dprintk((MYIOC_s_WARN_FMT "mpt_timer_expired! \n", ioc->name));
+	dcprintk((MYIOC_s_WARN_FMT "mpt_timer_expired! \n", ioc->name));
 
 	/* Perform a FW reload */
 	if (mpt_HardResetHandler(ioc, NO_SLEEP) < 0)
@@ -4900,7 +6198,7 @@ mpt_timer_expired(unsigned long data)
 	 * Hard reset clean-up will wake up
 	 * process and free all resources.
 	 */
-	dprintk((MYIOC_s_WARN_FMT "mpt_timer_expired complete!\n", ioc->name));
+	dcprintk((MYIOC_s_WARN_FMT "mpt_timer_expired complete!\n", ioc->name));
 
 	return;
 }
@@ -4919,11 +6217,14 @@ mpt_ioc_reset(MPT_ADAPTER *ioc, int rese
 	CONFIGPARMS *pCfg;
 	unsigned long flags;
 
-	dprintk((KERN_WARNING MYNAM
+	drsprintk((KERN_WARNING MYNAM
 			": IOC %s_reset routed to MPT base driver!\n",
-			reset_phase==MPT_IOC_PRE_RESET ? "pre" : "post"));
+			reset_phase==MPT_IOC_SETUP_RESET ? "setup" : (
+			reset_phase==MPT_IOC_PRE_RESET ? "pre" : "post")));
 
-	if (reset_phase == MPT_IOC_PRE_RESET) {
+	if (reset_phase == MPT_IOC_SETUP_RESET) {
+		;
+	} else if (reset_phase == MPT_IOC_PRE_RESET) {
 		/* If the internal config Q is not empty -
 		 * delete timer. MF resources will be freed when
 		 * the FIFO's are primed.
@@ -4941,10 +6242,9 @@ mpt_ioc_reset(MPT_ADAPTER *ioc, int rese
 	} else {
 		CONFIGPARMS *pNext;
 
-		/* Search the configQ for internal commands. 
+		/* Search the configQ for internal commands.
 		 * Flush the Q, and wake up all suspended threads.
 		 */
-#if 1
 		spin_lock_irqsave(&ioc->FreeQlock, flags);
 		if (! Q_IS_EMPTY(&ioc->configQ)){
 			pCfg = (CONFIGPARMS *)ioc->configQ.head;
@@ -4961,23 +6261,6 @@ mpt_ioc_reset(MPT_ADAPTER *ioc, int rese
 			} while (pCfg != (CONFIGPARMS *)&ioc->configQ);
 		}
 		spin_unlock_irqrestore(&ioc->FreeQlock, flags);
-#else
-		while (1) {
-			spin_lock_irqsave(&ioc->FreeQlock, flags);
-			if (! Q_IS_EMPTY(&ioc->configQ)){
-				spin_unlock_irqrestore(&ioc->FreeQlock, flags);
-				break;
-			}
-			pCfg = (CONFIGPARMS *)ioc->configQ.head;
-
-			Q_DEL_ITEM(&pCfg->linkage);
-			spin_unlock_irqrestore(&ioc->FreeQlock, flags);
-
-			pCfg->status = MPT_CONFIG_ERROR;
-			pCfg->wait_done = 1;
-			wake_up(&mpt_waitq);
-		}
-#endif
 	}
 
 	return 1;		/* currently means nothing really */
@@ -5005,7 +6288,7 @@ procmpt_create(void)
 	/*
 	 *	BEWARE: If/when MPT_PROCFS_MPTBASEDIR changes from "mpt"
 	 *	(single level) to multi level (e.g. "driver/message/fusion")
-	 *	something here needs to change.  -sralston
+	 *	something here needs to change.
 	 */
 	mpt_proc_root_dir = proc_mkdir(MPT_PROCFS_MPTBASEDIR, NULL);
 	if (mpt_proc_root_dir == NULL)
@@ -5024,8 +6307,7 @@ procmpt_create(void)
 		ent->data      = NULL;
 	}
 
-	ioc = mpt_adapter_find_first();
-	while (ioc != NULL) {
+	list_for_each_entry(ioc, &ioc_list, list) {
 		struct proc_dir_entry	*dent;
 		/*
 		 *  Create "/proc/mpt/iocN" subdirectory entry for each MPT adapter.
@@ -5051,7 +6333,6 @@ procmpt_create(void)
 			printk(MYIOC_s_WARN_FMT "Could not create /proc/mpt/%s subdir entry!\n",
 					ioc->name, mpt_ioc_proc_list[ii].name);
 		}
-		ioc = mpt_adapter_find_next(ioc);
 	}
 
 	return 0;
@@ -5075,11 +6356,10 @@ procmpt_destroy(void)
 	/*
 	 *	BEWARE: If/when MPT_PROCFS_MPTBASEDIR changes from "mpt"
 	 *	(single level) to multi level (e.g. "driver/message/fusion")
-	 *	something here needs to change.  -sralston
+	 *	something here needs to change. 
 	 */
 
-	ioc = mpt_adapter_find_first();
-	while (ioc != NULL) {
+	list_for_each_entry(ioc, &ioc_list, list) {
 		char pname[32];
 		int namelen;
 
@@ -5094,8 +6374,6 @@ procmpt_destroy(void)
 		}
 
 		remove_proc_entry(ioc->name, mpt_proc_root_dir);
-
-		ioc = mpt_adapter_find_next(ioc);
 	}
 
 	for (ii=0; ii < MPT_PROC_ENTRIES; ii++)
@@ -5130,25 +6408,23 @@ procmpt_summary_read(char *buf, char **s
 	char *out = buf;
 	int len;
 
-	if (data == NULL)
-		ioc = mpt_adapter_find_first();
-	else
-		ioc = data;
-
-	while (ioc) {
-		int	more = 0;
+	if (data) {
+		int more = 0;
 
+		ioc = data;
 		mpt_print_ioc_summary(ioc, out, &more, 0, 1);
 
 		out += more;
-		if ((out-buf) >= request) {
-			break;
-		}
+	} else {
+		list_for_each_entry(ioc, &ioc_list, list) {
+			int	more = 0;
 
-		if (data == NULL)
-			ioc = mpt_adapter_find_next(ioc);
-		else
-			ioc = NULL;		/* force exit for iocN */
+			mpt_print_ioc_summary(ioc, out, &more, 0, 1);
+
+			out += more;
+			if ((out-buf) >= request)
+				break;
+		}
 	}
 	len = out - buf;
 
@@ -5195,9 +6471,6 @@ procmpt_version_read(char *buf, char **s
 			case MPTCTL_DRIVER:
 				if (!ctl++) drvname = "ioctl";
 				break;
-			case MPTDMP_DRIVER:
-				if (!dmp++) drvname = "DMP";
-				break;
 			}
 
 			if (drvname)
@@ -5262,7 +6535,7 @@ procmpt_iocinfo_read(char *buf, char **s
 	len += sprintf(buf+len, "  MinBlockSize = 0x%02x bytes\n", 4*ioc->facts.BlockSize);
 
 	len += sprintf(buf+len, "  RequestFrames @ 0x%p (Dma @ 0x%p)\n",
-					(void *)ioc->req_alloc, (void *)(ulong)ioc->req_alloc_dma);
+					(void *)ioc->req_frames, (void *)(ulong)ioc->req_frames_dma);
 	/*
 	 *  Rounding UP to nearest 4-kB boundary here...
 	 */
@@ -5274,8 +6547,8 @@ procmpt_iocinfo_read(char *buf, char **s
 					4*ioc->facts.RequestFrameSize,
 					ioc->facts.GlobalCredits);
 
-	len += sprintf(buf+len, "  ReplyFrames   @ 0x%p (Dma @ 0x%p)\n",
-					(void *)ioc->reply_alloc, (void *)(ulong)ioc->reply_alloc_dma);
+	len += sprintf(buf+len, "  Frames   @ 0x%p (Dma @ 0x%p)\n",
+					(void *)ioc->alloc, (void *)(ulong)ioc->alloc_dma);
 	sz = (ioc->reply_sz * ioc->reply_depth) + 128;
 	len += sprintf(buf+len, "    {CurRepSz=%d} x {CurRepDepth=%d} = %d bytes ^= 0x%x\n",
 					ioc->reply_sz, ioc->reply_depth, ioc->reply_sz*ioc->reply_depth, sz);
@@ -5292,7 +6565,12 @@ procmpt_iocinfo_read(char *buf, char **s
 		len += sprintf(buf+len, "  PortNumber = %d (of %d)\n",
 				p+1,
 				ioc->facts.NumberOfPorts);
-		if ((int)ioc->chip_type <= (int)FC929) {
+	    if(ioc->bus_type == SAS) {
+			len += sprintf(buf+len, "    WWN = %08X%08X\n",
+				ioc->sas_port_WWID[p].High,
+				ioc->sas_port_WWID[p].Low);
+		}
+		else if(ioc->bus_type == FC) {
 			if (ioc->pfacts[p].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN) {
 				u8 *a = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;
 				len += sprintf(buf+len, "    LanAddr = %02X:%02X:%02X:%02X:%02X:%02X\n",
@@ -5405,10 +6683,11 @@ mpt_HardResetHandler(MPT_ADAPTER *ioc, i
 	int		 rc;
 	unsigned long	 flags;
 
-	dprintk((MYIOC_s_INFO_FMT "HardResetHandler Entered!\n", ioc->name));
+	dtmprintk((MYIOC_s_WARN_FMT "HardResetHandler Entered!\n", ioc->name));
 #ifdef MFCNT
-	printk(MYIOC_s_INFO_FMT "HardResetHandler Entered!\n", ioc->name);
-	printk("MF count 0x%x !\n", ioc->mfcnt);
+	printk(MYIOC_s_WARN_FMT "HardResetHandler Entered mfcnt=%d!\n", ioc->name, ioc->mfcnt);
+	if (ioc->alt_ioc)
+		printk(MYIOC_s_WARN_FMT "alt_ioc mfcnt=%d!\n", ioc->alt_ioc->name, ioc->alt_ioc->mfcnt);
 #endif
 
 	/* Reset the adapter. Prevent more than 1 call to
@@ -5425,6 +6704,33 @@ mpt_HardResetHandler(MPT_ADAPTER *ioc, i
 
 	/* FIXME: If do_ioc_recovery fails, repeat....
 	 */
+	
+	/* The SCSI driver needs to adjust timeouts on all current
+	 * commands prior to the diagnostic reset being issued.
+	 * Prevents timeouts occuring during a diagnostic reset...very bad.
+	 * For all other protocol drivers, this is a no-op.
+	 */
+	{
+		int	 ii;
+		int	 rc = 0;
+
+		for (ii=MPT_MAX_PROTOCOL_DRIVERS-1; ii; ii--) {
+			if (MptResetHandlers[ii]) {
+				rc += (*(MptResetHandlers[ii]))(ioc, MPT_IOC_SETUP_RESET);
+				drsprintk((MYIOC_s_WARN_FMT "Called MptResetHandlers=%p ii=%d for MPT_IOC_SETUP_RESET rc=%x\n",
+					ioc->name, 
+					MptResetHandlers[ii], ii, rc));
+				if (ioc->alt_ioc) {
+					rc += (*(MptResetHandlers[ii]))(ioc->alt_ioc, MPT_IOC_SETUP_RESET);
+					drsprintk((MYIOC_s_WARN_FMT "Called alt-%s MptResetHandlers=%p ii=%d for MPT_IOC_SETUP_RESET rc=%x\n",
+						ioc->name, ioc->alt_ioc->name,
+						MptResetHandlers[ii], ii, rc));
+				}
+			}
+		}
+		drsprintk((MYIOC_s_WARN_FMT "hard_reset_done: rc=%x for MPT_IOC_SETUP_RESET\n",
+			ioc->name, rc));
+	}
 
 	if ((rc = mpt_do_ioc_recovery(ioc, MPT_HOSTEVENT_IOC_RECOVER, sleepFlag)) != 0) {
 		printk(KERN_WARNING MYNAM ": WARNING - (%d) Cannot recover %s\n",
@@ -5440,7 +6746,7 @@ mpt_HardResetHandler(MPT_ADAPTER *ioc, i
 		ioc->alt_ioc->diagPending = 0;
 	spin_unlock_irqrestore(&ioc->diagLock, flags);
 
-	dprintk((MYIOC_s_INFO_FMT "HardResetHandler rc = %d!\n", ioc->name, rc));
+	dtmprintk((MYIOC_s_WARN_FMT "HardResetHandler rc = %d!\n", ioc->name, rc));
 
 	return rc;
 }
@@ -5449,7 +6755,7 @@ mpt_HardResetHandler(MPT_ADAPTER *ioc, i
 static char *
 EventDescriptionStr(u8 event, u32 evData0)
 {
-	char *ds = NULL;
+	char *ds;
 
 	switch(event) {
 	case MPI_EVENT_NONE:
@@ -5502,6 +6808,30 @@ EventDescriptionStr(u8 event, u32 evData
 	case MPI_EVENT_INTEGRATED_RAID:
 		ds = "Integrated Raid";
 		break;
+	case MPI_EVENT_SAS_DEVICE_STATUS_CHANGE:
+	{
+		u8 ReasonCode = (u8)(evData0 >> 16);
+		if(ReasonCode == MPI_EVENT_SAS_DEV_STAT_RC_ADDED)
+			ds = "SAS Status Change: Device Added";
+		else if (ReasonCode == MPI_EVENT_SAS_DEV_STAT_RC_NOT_RESPONDING)
+			ds = "SAS Status Change: Device Not Responding";
+		else if (ReasonCode == MPI_EVENT_SAS_DEV_STAT_RC_SMART_DATA)
+			ds = "SAS Status Change: SMART Data";
+		else if (ReasonCode ==
+		    MPI_EVENT_SAS_DEV_STAT_RC_NO_PERSIST_ADDED)
+			ds = "SAS Status Change: No Persist Added";
+		else
+			ds = "SAS Status Change: Unknown";
+	}
+	case MPI_EVENT_SAS_SES:
+		ds = "SAS SES Event";
+		break;
+	case MPI_EVENT_PERSISTENT_TABLE_FULL:
+		ds = "Persistent Table Full";
+		break;
+	case MPI_EVENT_SAS_PHY_LINK_STATUS:
+		ds = "SAS PHY Link Status";
+		break;
 	/*
 	 *  MPT base "custom" events may be added here...
 	 */
@@ -5515,7 +6845,7 @@ EventDescriptionStr(u8 event, u32 evData
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *	ProcessEventNotification - Route a received EventNotificationReply to
- *	all currently regeistered event handlers.
+ *	all currently registered event handlers.
  *	@ioc: Pointer to MPT_ADAPTER structure
  *	@pEventReply: Pointer to EventNotification reply frame
  *	@evHandlers: Pointer to integer, number of event handlers
@@ -5545,7 +6875,7 @@ ProcessEventNotification(MPT_ADAPTER *io
 	}
 
 	evStr = EventDescriptionStr(event, evData0);
-	dprintk((MYIOC_s_INFO_FMT "MPT event (%s=%02Xh) detected!\n",
+	devtprintk((MYIOC_s_WARN_FMT "MPT event (%s=%02Xh) detected!\n",
 			ioc->name,
 			evStr,
 			event));
@@ -5561,19 +6891,24 @@ ProcessEventNotification(MPT_ADAPTER *io
 	 *  Do general / base driver event processing
 	 */
 	switch(event) {
-	case MPI_EVENT_NONE:			/* 00 */
-	case MPI_EVENT_LOG_DATA:		/* 01 */
-	case MPI_EVENT_STATE_CHANGE:		/* 02 */
-	case MPI_EVENT_UNIT_ATTENTION:		/* 03 */
-	case MPI_EVENT_IOC_BUS_RESET:		/* 04 */
-	case MPI_EVENT_EXT_BUS_RESET:		/* 05 */
-	case MPI_EVENT_RESCAN:			/* 06 */
-	case MPI_EVENT_LINK_STATUS_CHANGE:	/* 07 */
-	case MPI_EVENT_LOOP_STATE_CHANGE:	/* 08 */
-	case MPI_EVENT_LOGOUT:			/* 09 */
-	case MPI_EVENT_INTEGRATED_RAID:		/* 0B */
-	case MPI_EVENT_SCSI_DEVICE_STATUS_CHANGE:	/* 0C */
-	default:
+	case MPI_EVENT_INTEGRATED_RAID:
+	{
+		u8 ReasonCode = (u8)(evData0 >> 16);
+	
+		if( ioc->bus_type == SAS && 
+		    (ReasonCode == MPI_EVENT_RAID_RC_VOLUME_CREATED ||
+		     ReasonCode == MPI_EVENT_RAID_RC_VOLUME_DELETED)) {
+		
+			MPT_INIT_WORK(&mptbase_sasScanTask,
+			    mptbase_sas_update_device_list,(void *)ioc);
+			SCHEDULE_TASK(&mptbase_sasScanTask);
+		}
+		
+		break;
+	}
+	case MPI_EVENT_SAS_DEVICE_STATUS_CHANGE: /* 0F */
+		mptbase_sas_process_event_data(ioc,
+		    (MpiEventDataSasDeviceStatusChange_t *)pEventReply->Data);
 		break;
 	case MPI_EVENT_EVENT_CHANGE:		/* 0A */
 		if (evDataLen) {
@@ -5587,6 +6922,8 @@ ProcessEventNotification(MPT_ADAPTER *io
 			}
 		}
 		break;
+	default:
+		break;
 	}
 
 	/*
@@ -5617,7 +6954,7 @@ ProcessEventNotification(MPT_ADAPTER *io
 	 */
 	for (ii=MPT_MAX_PROTOCOL_DRIVERS-1; ii; ii--) {
 		if (MptEvHandlers[ii]) {
-			dprintk((MYIOC_s_INFO_FMT "Routing Event to event handler #%d\n",
+			devtprintk((MYIOC_s_WARN_FMT "Routing Event to event handler #%d\n",
 					ioc->name, ii));
 			r += (*(MptEvHandlers[ii]))(ioc, pEventReply);
 			handlers++;
@@ -5629,9 +6966,11 @@ ProcessEventNotification(MPT_ADAPTER *io
 	 *  If needed, send (a single) EventAck.
 	 */
 	if (pEventReply->AckRequired == MPI_EVENT_NOTIFICATION_ACK_REQUIRED) {
+		devtprintk((MYIOC_s_WARN_FMT
+			"EventAck required\n",ioc->name));
 		if ((ii = SendEventAck(ioc, pEventReply)) != 0) {
-			printk(MYIOC_s_WARN_FMT "SendEventAck returned %d\n",
-					ioc->name, ii);
+			devtprintk((MYIOC_s_WARN_FMT
+				"SendEventAck returned %d\n",ioc->name, ii));
 		}
 	}
 
@@ -5654,109 +6993,10 @@ mpt_fc_log_info(MPT_ADAPTER *ioc, u32 lo
 		"FCP Initiator", "FCP Target", "LAN", "MPI Message Layer",
 		"FC Link", "Context Manager", "Invalid Field Offset", "State Change Info"
 	};
-	char *desc = "unknown";
 	u8 subcl = (log_info >> 24) & 0x7;
-	u32 SubCl = log_info & 0x27000000;
-
-	switch(log_info) {
-/* FCP Initiator */
-	case MPI_IOCLOGINFO_FC_INIT_ERROR_OUT_OF_ORDER_FRAME:
-		desc = "Received an out of order frame - unsupported";
-		break;
-	case MPI_IOCLOGINFO_FC_INIT_ERROR_BAD_START_OF_FRAME:
-		desc = "Bad start of frame primative";
-		break;
-	case MPI_IOCLOGINFO_FC_INIT_ERROR_BAD_END_OF_FRAME:
-		desc = "Bad end of frame primative";
-		break;
-	case MPI_IOCLOGINFO_FC_INIT_ERROR_OVER_RUN:
-		desc = "Receiver hardware detected overrun";
-		break;
-	case MPI_IOCLOGINFO_FC_INIT_ERROR_RX_OTHER:
-		desc = "Other errors caught by IOC which require retries";
-		break;
-	case MPI_IOCLOGINFO_FC_INIT_ERROR_SUBPROC_DEAD:
-		desc = "Main processor could not initialize sub-processor";
-		break;
-/* FC Target */
-	case MPI_IOCLOGINFO_FC_TARGET_NO_PDISC:
-		desc = "Not sent because we are waiting for a PDISC from the initiator";
-		break;
-	case MPI_IOCLOGINFO_FC_TARGET_NO_LOGIN:
-		desc = "Not sent because we are not logged in to the remote node";
-		break;
-	case MPI_IOCLOGINFO_FC_TARGET_DOAR_KILLED_BY_LIP:
-		desc = "Data Out, Auto Response, not sent due to a LIP";
-		break;
-	case MPI_IOCLOGINFO_FC_TARGET_DIAR_KILLED_BY_LIP:
-		desc = "Data In, Auto Response, not sent due to a LIP";
-		break;
-	case MPI_IOCLOGINFO_FC_TARGET_DIAR_MISSING_DATA:
-		desc = "Data In, Auto Response, missing data frames";
-		break;
-	case MPI_IOCLOGINFO_FC_TARGET_DONR_KILLED_BY_LIP:
-		desc = "Data Out, No Response, not sent due to a LIP";
-		break;
-	case MPI_IOCLOGINFO_FC_TARGET_WRSP_KILLED_BY_LIP:
-		desc = "Auto-response after a write not sent due to a LIP";
-		break;
-	case MPI_IOCLOGINFO_FC_TARGET_DINR_KILLED_BY_LIP:
-		desc = "Data In, No Response, not completed due to a LIP";
-		break;
-	case MPI_IOCLOGINFO_FC_TARGET_DINR_MISSING_DATA:
-		desc = "Data In, No Response, missing data frames";
-		break;
-	case MPI_IOCLOGINFO_FC_TARGET_MRSP_KILLED_BY_LIP:
-		desc = "Manual Response not sent due to a LIP";
-		break;
-	case MPI_IOCLOGINFO_FC_TARGET_NO_CLASS_3:
-		desc = "Not sent because remote node does not support Class 3";
-		break;
-	case MPI_IOCLOGINFO_FC_TARGET_LOGIN_NOT_VALID:
-		desc = "Not sent because login to remote node not validated";
-		break;
-	case MPI_IOCLOGINFO_FC_TARGET_FROM_OUTBOUND:
-		desc = "Cleared from the outbound queue after a logout";
-		break;
-	case MPI_IOCLOGINFO_FC_TARGET_WAITING_FOR_DATA_IN:
-		desc = "Cleared waiting for data after a logout";
-		break;
-/* LAN */
-	case MPI_IOCLOGINFO_FC_LAN_TRANS_SGL_MISSING:
-		desc = "Transaction Context Sgl Missing";
-		break;
-	case MPI_IOCLOGINFO_FC_LAN_TRANS_WRONG_PLACE:
-		desc = "Transaction Context found before an EOB";
-		break;
-	case MPI_IOCLOGINFO_FC_LAN_TRANS_RES_BITS_SET:
-		desc = "Transaction Context value has reserved bits set";
-		break;
-	case MPI_IOCLOGINFO_FC_LAN_WRONG_SGL_FLAG:
-		desc = "Invalid SGL Flags";
-		break;
-/* FC Link */
-	case MPI_IOCLOGINFO_FC_LINK_LOOP_INIT_TIMEOUT:
-		desc = "Loop initialization timed out";
-		break;
-	case MPI_IOCLOGINFO_FC_LINK_ALREADY_INITIALIZED:
-		desc = "Another system controller already initialized the loop";
-		break;
-	case MPI_IOCLOGINFO_FC_LINK_LINK_NOT_ESTABLISHED:
-		desc = "Not synchronized to signal or still negotiating (possible cable problem)";
-		break;
-	case MPI_IOCLOGINFO_FC_LINK_CRC_ERROR:
-		desc = "CRC check detected error on received frame";
-		break;
-	}
 
-	printk(MYIOC_s_INFO_FMT "LogInfo(0x%08x): SubCl={%s}",
+	printk(MYIOC_s_WARN_FMT "LogInfo(0x%08x): SubCl={%s}\n",
 			ioc->name, log_info, subcl_str[subcl]);
-	if (SubCl == MPI_IOCLOGINFO_FC_INVALID_FIELD_BYTE_OFFSET)
-		printk(", byte_offset=%d\n", log_info & MPI_IOCLOGINFO_FC_INVALID_FIELD_MAX_OFFSET);
-	else if (SubCl == MPI_IOCLOGINFO_FC_STATE_CHANGE)
-		printk("\n");		/* StateChg in LogInfo & 0x00FFFFFF, above */
-	else
-		printk("\n" KERN_INFO " %s\n", desc);
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -5808,9 +7048,153 @@ mpt_sp_log_info(MPT_ADAPTER *ioc, u32 lo
 	case 0x00080000:
 		desc = "Outbound DMA Overrun";
 		break;
+
+	case 0x00090000:
+		desc = "Task Management";
+		break;
+
+	case 0x000A0000:
+		desc = "Device Problem";
+		break;
+
+	case 0x000B0000:
+		desc = "Invalid Phase Change";
+		break;
+
+	case 0x000C0000:
+		desc = "Untagged Table Size";
+		break;
+
 	}
 
-	printk(MYIOC_s_INFO_FMT "LogInfo(0x%08x): F/W: %s\n", ioc->name, log_info, desc);
+	printk(MYIOC_s_WARN_FMT "LogInfo(0x%08x): F/W: %s\n", ioc->name, log_info, desc);
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mpt_sp_ioc_info - IOC information returned from SCSI Parallel IOC.
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@ioc_status: U32 IOCStatus word from IOC
+ *	@mf: Pointer to MPT request frame
+ *
+ *	Refer to lsi/mpi.h.
+ */
+static void
+mpt_sp_ioc_info(MPT_ADAPTER *ioc, u32 ioc_status, MPT_FRAME_HDR *mf)
+{
+	u32 status = ioc_status & MPI_IOCSTATUS_MASK;
+	char *desc = "";
+
+	switch (status) {
+	case MPI_IOCSTATUS_INVALID_FUNCTION: /* 0x0001 */
+		desc = "Invalid Function";
+		break;
+
+	case MPI_IOCSTATUS_BUSY: /* 0x0002 */
+		desc = "Busy";
+		break;
+
+	case MPI_IOCSTATUS_INVALID_SGL: /* 0x0003 */
+		desc = "Invalid SGL";
+		break;
+
+	case MPI_IOCSTATUS_INTERNAL_ERROR: /* 0x0004 */
+		desc = "Internal Error";
+		break;
+
+	case MPI_IOCSTATUS_RESERVED: /* 0x0005 */
+		desc = "Reserved";
+		break;
+
+	case MPI_IOCSTATUS_INSUFFICIENT_RESOURCES: /* 0x0006 */
+		desc = "Insufficient Resources";
+		break;
+
+	case MPI_IOCSTATUS_INVALID_FIELD: /* 0x0007 */
+		desc = "Invalid Field";
+		break;
+
+	case MPI_IOCSTATUS_INVALID_STATE: /* 0x0008 */
+		desc = "Invalid State";
+		break;
+
+	case MPI_IOCSTATUS_CONFIG_INVALID_ACTION: /* 0x0020 */
+	case MPI_IOCSTATUS_CONFIG_INVALID_TYPE:   /* 0x0021 */
+	case MPI_IOCSTATUS_CONFIG_INVALID_PAGE:   /* 0x0022 */
+	case MPI_IOCSTATUS_CONFIG_INVALID_DATA:   /* 0x0023 */
+	case MPI_IOCSTATUS_CONFIG_NO_DEFAULTS:    /* 0x0024 */
+	case MPI_IOCSTATUS_CONFIG_CANT_COMMIT:    /* 0x0025 */
+		/* No message for Config IOCStatus values */
+		break;
+
+	case MPI_IOCSTATUS_SCSI_RECOVERED_ERROR: /* 0x0040 */
+		/* No message for recovered error
+		desc = "SCSI Recovered Error";
+		*/
+		break;
+
+	case MPI_IOCSTATUS_SCSI_INVALID_BUS: /* 0x0041 */
+		desc = "SCSI Invalid Bus";
+		break;
+
+	case MPI_IOCSTATUS_SCSI_INVALID_TARGETID: /* 0x0042 */
+		desc = "SCSI Invalid TargetID";
+		break;
+
+	case MPI_IOCSTATUS_SCSI_DEVICE_NOT_THERE: /* 0x0043 */
+	  {
+		SCSIIORequest_t *pScsiReq = (SCSIIORequest_t *) mf;
+		U8 cdb = pScsiReq->CDB[0];
+		if (cdb != 0x12) { /* Inquiry is issued for device scanning */
+			desc = "SCSI Device Not There";
+		}
+		break;
+	  }
+
+	case MPI_IOCSTATUS_SCSI_DATA_OVERRUN: /* 0x0044 */
+		desc = "SCSI Data Overrun";
+		break;
+
+	case MPI_IOCSTATUS_SCSI_DATA_UNDERRUN: /* 0x0045 */
+		/* This error is checked in scsi_io_done(). Skip. 
+		desc = "SCSI Data Underrun";
+		*/
+		break;
+
+	case MPI_IOCSTATUS_SCSI_IO_DATA_ERROR: /* 0x0046 */
+		desc = "SCSI I/O Data Error";
+		break;
+
+	case MPI_IOCSTATUS_SCSI_PROTOCOL_ERROR: /* 0x0047 */
+		desc = "SCSI Protocol Error";
+		break;
+
+	case MPI_IOCSTATUS_SCSI_TASK_TERMINATED: /* 0x0048 */
+		desc = "SCSI Task Terminated";
+		break;
+
+	case MPI_IOCSTATUS_SCSI_RESIDUAL_MISMATCH: /* 0x0049 */
+		desc = "SCSI Residual Mismatch";
+		break;
+
+	case MPI_IOCSTATUS_SCSI_TASK_MGMT_FAILED: /* 0x004A */
+		desc = "SCSI Task Management Failed";
+		break;
+
+	case MPI_IOCSTATUS_SCSI_IOC_TERMINATED: /* 0x004B */
+		desc = "SCSI IOC Terminated";
+		break;
+
+	case MPI_IOCSTATUS_SCSI_EXT_TERMINATED: /* 0x004C */
+		desc = "SCSI Ext Terminated";
+		break;
+
+	default:
+		desc = "Others";
+		break;
+	}
+	if (desc != "")
+		printk(MYIOC_s_WARN_FMT "IOCStatus(0x%04x): %s\n", ioc->name, status, desc);
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -5836,7 +7220,7 @@ mpt_register_ascqops_strings(void *ascqT
 		isense_idx = last_drv_idx;
 		r = 1;
 	}
-	MOD_INC_USE_COUNT;
+	mpt_inc_use_count();
 	return r;
 }
 
@@ -5855,39 +7239,42 @@ mpt_deregister_ascqops_strings(void)
 	mpt_ScsiOpcodesPtr = NULL;
 	printk(KERN_INFO MYNAM ": English readable SCSI-3 strings disabled)-:\n");
 	isense_idx = -1;
-	MOD_DEC_USE_COUNT;
+	mpt_dec_use_count();
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
-EXPORT_SYMBOL(mpt_adapters);
+EXPORT_SYMBOL(ioc_list);
+EXPORT_SYMBOL(mpt_can_queue);
+EXPORT_SYMBOL(mpt_sg_tablesize);
 EXPORT_SYMBOL(mpt_proc_root_dir);
-EXPORT_SYMBOL(DmpService);
 EXPORT_SYMBOL(mpt_register);
 EXPORT_SYMBOL(mpt_deregister);
 EXPORT_SYMBOL(mpt_event_register);
 EXPORT_SYMBOL(mpt_event_deregister);
 EXPORT_SYMBOL(mpt_reset_register);
 EXPORT_SYMBOL(mpt_reset_deregister);
+EXPORT_SYMBOL(mpt_downloadboot);
 EXPORT_SYMBOL(mpt_get_msg_frame);
 EXPORT_SYMBOL(mpt_put_msg_frame);
 EXPORT_SYMBOL(mpt_free_msg_frame);
 EXPORT_SYMBOL(mpt_add_sge);
-EXPORT_SYMBOL(mpt_add_chain);
 EXPORT_SYMBOL(mpt_send_handshake_request);
 EXPORT_SYMBOL(mpt_handshake_req_reply_wait);
-EXPORT_SYMBOL(mpt_adapter_find_first);
-EXPORT_SYMBOL(mpt_adapter_find_next);
 EXPORT_SYMBOL(mpt_verify_adapter);
 EXPORT_SYMBOL(mpt_GetIocState);
 EXPORT_SYMBOL(mpt_print_ioc_summary);
 EXPORT_SYMBOL(mpt_lan_index);
 EXPORT_SYMBOL(mpt_stm_index);
 EXPORT_SYMBOL(mpt_HardResetHandler);
+EXPORT_SYMBOL(mpt_do_diag_reset);
 EXPORT_SYMBOL(mpt_config);
+EXPORT_SYMBOL(mpt_toolbox);
+EXPORT_SYMBOL(mpt_findImVolumes);
 EXPORT_SYMBOL(mpt_read_ioc_pg_3);
 EXPORT_SYMBOL(mpt_alloc_fw_memory);
 EXPORT_SYMBOL(mpt_free_fw_memory);
+EXPORT_SYMBOL(mptbase_sas_persist_operation);
 
 EXPORT_SYMBOL(mpt_register_ascqops_strings);
 EXPORT_SYMBOL(mpt_deregister_ascqops_strings);
@@ -5906,15 +7293,11 @@ fusion_init(void)
 {
 	int i;
 
-	if (FusionInitCalled++) {
-		dprintk((KERN_INFO MYNAM ": INFO - Driver late-init entry point called\n"));
-		return 0;
-	}
-
 	show_mptmod_ver(my_NAME, my_VERSION);
 	printk(KERN_INFO COPYRIGHT "\n");
 
-	Q_INIT(&MptAdapters, MPT_ADAPTER);			/* set to empty */
+	INIT_LIST_HEAD(&ioc_list);
+
 	for (i = 0; i < MPT_MAX_PROTOCOL_DRIVERS; i++) {
 		MptCallbacks[i] = NULL;
 		MptDriverClass[i] = MPTUNKNOWN_DRIVER;
@@ -5922,10 +7305,7 @@ fusion_init(void)
 		MptResetHandlers[i] = NULL;
 	}
 
-	DmpService = NULL;
-
-	/* NEW!  20010120 -sralston
-	 *  Register ourselves (mptbase) in order to facilitate
+	/*  Register ourselves (mptbase) in order to facilitate
 	 *  EventNotification handling.
 	 */
 	mpt_base_index = mpt_register(mpt_base_reply, MPTBASE_DRIVER);
@@ -5933,9 +7313,9 @@ fusion_init(void)
 	/* Register for hard reset handling callbacks.
 	 */
 	if (mpt_reset_register(mpt_base_index, mpt_ioc_reset) == 0) {
-		dprintk((KERN_INFO MYNAM ": Register for IOC reset notification\n"));
+		dinitprintk((KERN_INFO MYNAM ": Registered mpt_ioc_reset notification mpt_base_index=%d\n", mpt_base_index));
 	} else {
-		/* FIXME! */
+		dinitprintk((KERN_INFO MYNAM ": Register of mpt_ioc_reset notification mpt_base_index=%d FAILED\n", mpt_base_index));
 	}
 
 	if ((i = mpt_pci_scan()) < 0)
@@ -5954,36 +7334,26 @@ fusion_init(void)
 static void
 fusion_exit(void)
 {
-	MPT_ADAPTER *this;
-	struct pci_dev *pdev = NULL;
+	MPT_ADAPTER *ioc, *next_ioc;
+	struct pci_dev *pdev;
+	int id;
 
-	dprintk((KERN_INFO MYNAM ": fusion_exit() called!\n"));
+	dexitprintk((KERN_INFO MYNAM ": fusion_exit() called!\n"));
 
-	/* Whups?  20010120 -sralston
-	 *  Moved this *above* removal of all MptAdapters!
+	/*  Moved this *above* removal of all MptAdapters!
 	 */
 #ifdef CONFIG_PROC_FS
 	(void) procmpt_destroy();
 #endif
 
-	while (! Q_IS_EMPTY(&MptAdapters)) {
-		this = MptAdapters.head;
-
-		/* Disable interrupts! */
-		CHIPREG_WRITE32(&this->chip->IntMask, 0xFFFFFFFF);
-
-		this->active = 0;
-
-		pdev = (struct pci_dev *)this->pcidev;
-		mptscsih_sync_irq(pdev->irq);
-
-		/* Clear any lingering interrupt */
-		CHIPREG_WRITE32(&this->chip->IntStatus, 0);
+	list_for_each_entry_safe(ioc, next_ioc, &ioc_list, list) {
+		ioc->active = 0;
 
-		CHIPREG_READ32(&this->chip->IntStatus);
+		pdev = ioc->pcidev;
+		mpt_sync_irq(pdev->irq);
 
-		Q_DEL_ITEM(this);
-		mpt_adapter_dispose(this);
+		dexitprintk((KERN_INFO MYNAM ": %s Calling mpt_adapter_dispose\n", ioc->name));
+		mpt_adapter_dispose(ioc);
 	}
 
 	mpt_reset_deregister(mpt_base_index);
diff -urNp linux-8145/drivers/message/fusion/mptbase.h linux-8150/drivers/message/fusion/mptbase.h
--- linux-8145/drivers/message/fusion/mptbase.h
+++ linux-8150/drivers/message/fusion/mptbase.h
@@ -5,15 +5,10 @@
  *          LSIFC9xx/LSI409xx Fibre Channel
  *      running LSI Logic Fusion MPT (Message Passing Technology) firmware.
  *
- *  Credits:
- *     (see mptbase.c)
+ *  Copyright (c) 1999-2005 LSI Logic Corporation
+ *  (mailto:mpt_linux_developer@lsil.com)
  *
- *  Copyright (c) 1999-2002 LSI Logic Corporation
- *  Originally By: Steven J. Ralston
- *  (mailto:sjralston1@netscape.net)
- *  (mailto:lstephen@lsil.com)
- *
- *  $Id: mptbase.h,v 1.144 2003/01/28 21:31:56 pdelaney Exp $
+ *  $Id: mptbase.h,v 1.149 2003/05/07 14:08:31 Exp $
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -55,7 +50,6 @@
 #define MPTBASE_H_INCLUDED
 /*{-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
-#include "linux_compat.h"	/* linux-2.2.x (vs. -2.4.x) tweaks */
 #include "scsi3.h"		/* SCSI defines */
 
 #include "lsi/mpi_type.h"
@@ -68,35 +62,110 @@
 
 #include "lsi/mpi_fc.h"		/* Fibre Channel (lowlevel) support */
 #include "lsi/mpi_targ.h"	/* SCSI/FCP Target protcol support */
-#include "lsi/fc_log.h"
+#include "lsi/mpi_tool.h"	/* Tools support */
+#include "lsi/mpi_sas.h"	/* SAS support */
+
+#include <linux/version.h>
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
 #ifndef MODULEAUTHOR
-#define MODULEAUTHOR	"LSI Logic Corporation"
+#define MODULEAUTHOR	"LSI Logic"
 #endif
 
 #ifndef COPYRIGHT
-#define COPYRIGHT	"Copyright (c) 1999-2002 " MODULEAUTHOR
+#define COPYRIGHT	"Copyright (c) 1999-2005 " MODULEAUTHOR
 #endif
 
-#define MPT_LINUX_VERSION_COMMON	"2.05.00fix"
-#define MPT_LINUX_PACKAGE_NAME		"@(#)mptlinux-2.05.00fix"
+#define MPT_LINUX_VERSION_COMMON	"2.06.16.02"
+#define MPT_LINUX_PACKAGE_NAME		"@(#)mptlinux-2.06.16.02"
+#define MPT_LINUX_MAJOR_VERSION		2
+#define MPT_LINUX_MINOR_VERSION		6
+#define MPT_LINUX_BUILD_VERSION		16
+#define MPT_LINUX_RELEASE_VERSION	02
 #define WHAT_MAGIC_STRING		"@" "(" "#" ")"
 
 #define show_mptmod_ver(s,ver)  \
 	printk(KERN_INFO "%s %s\n", s, ver);
 
+/*
+ *	tq_scheduler disappeared @ lk-2.4.0-test12
+ *	(right when <linux/sched.h> newly defined TQ_ACTIVE)
+ *	tq_struct reworked in 2.5.41. Include workqueue.h.
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,41)
+#	include <linux/sched.h>
+#	include <linux/workqueue.h>
+#define SCHEDULE_TASK(x)		\
+	if (schedule_work(x) == 0) {	\
+		/*MOD_DEC_USE_COUNT*/;	\
+	}
+#else
+#define HAVE_TQ_SCHED	1
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+#	include <linux/sched.h>
+#	ifdef TQ_ACTIVE
+#		undef HAVE_TQ_SCHED
+#	endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,40)
+#		undef HAVE_TQ_SCHED
+#endif
+#endif
+#ifdef HAVE_TQ_SCHED
+#define SCHEDULE_TASK(x)		\
+	/*MOD_INC_USE_COUNT*/;		\
+	(x)->next = NULL;		\
+	queue_task(x, &tq_scheduler)
+#else
+#define SCHEDULE_TASK(x)		\
+	/*MOD_INC_USE_COUNT*/;		\
+	if (schedule_task(x) == 0) {	\
+		/*MOD_DEC_USE_COUNT*/;	\
+	}
+#endif
+#endif
+
+/* Some 2.4 kernels do not have list_for_entry defined in include file 
+   list.h.   So we define it here.  */
+/**
+ * list_for_each_entry	-	iterate over list of given type
+ * @pos:	the type * to use as a loop counter.
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_for_each_entry(pos, head, member)				\
+	for (pos = list_entry((head)->next, typeof(*pos), member),	\
+		     prefetch(pos->member.next);			\
+	     &pos->member != (head); 					\
+	     pos = list_entry(pos->member.next, typeof(*pos), member),	\
+		     prefetch(pos->member.next))
+
+#define list_first(head)      (((head)->next != (head)) ? (head)->next: (struct list_head *) 0)
+/* Some 2.4 kernels do not have list_for_entry_safe defined in include file 
+   list.h.   So we define it here.  */
+/**
+ * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry
+ * @pos:	the type * to use as a loop counter.
+ * @n:		another type * to use as temporary storage
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_for_each_entry_safe(pos, n, head, member)			\
+	for (pos = list_entry((head)->next, typeof(*pos), member),	\
+		n = list_entry(pos->member.next, typeof(*pos), member);	\
+	     &pos->member != (head); 					\
+	     pos = n, n = list_entry(n->member.next, typeof(*n), member))
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *  Fusion MPT(linux) driver configurable stuff...
  */
-#define MPT_MAX_ADAPTERS		18
 #define MPT_MAX_PROTOCOL_DRIVERS	16
-#define MPT_MAX_BUS			1
+#define MPT_MAX_BUS			1	/* Do not change */
 #define MPT_MAX_FC_DEVICES		255
 #define MPT_MAX_SCSI_DEVICES		16
-#define MPT_LAST_LUN			31
+#define MPT_LAST_LUN			255
+#define MPT_NON_IU_LAST_LUN		63
 #define MPT_SENSE_BUFFER_ALLOC		64
 	/* allow for 256 max sense alloc, but only 255 max request */
 #if MPT_SENSE_BUFFER_ALLOC >= 256
@@ -107,6 +176,13 @@
 #	define MPT_SENSE_BUFFER_SIZE	MPT_SENSE_BUFFER_ALLOC
 #endif
 
+#define MPT_FC_CAN_QUEUE	127
+#if defined MPT_SCSI_USE_NEW_EH
+	#define MPT_SCSI_CAN_QUEUE	127
+#else
+	#define MPT_SCSI_CAN_QUEUE	63
+#endif
+
 #define MPT_NAME_LENGTH			32
 
 #define MPT_PROCFS_MPTBASEDIR		"mpt"
@@ -115,22 +191,25 @@
 #define MPT_PROCFS_SUMMARY_ALL_PATHNAME		"/proc/" MPT_PROCFS_SUMMARY_ALL_NODE
 #define MPT_FW_REV_MAGIC_ID_STRING		"FwRev="
 
-#define  MPT_MAX_REQ_DEPTH		1023
-#define  MPT_DEFAULT_REQ_DEPTH		256
-#define  MPT_MIN_REQ_DEPTH		128
-
-#define  MPT_MAX_REPLY_DEPTH		MPT_MAX_REQ_DEPTH
 #define  MPT_DEFAULT_REPLY_DEPTH	128
-#define  MPT_MIN_REPLY_DEPTH		8
-#define  MPT_MAX_REPLIES_PER_ISR	32
 
 #define  MPT_MAX_FRAME_SIZE		128
 #define  MPT_DEFAULT_FRAME_SIZE		128
 
+#define  MPT_REPLY_FRAME_SIZE		0x50  /* Must be a multiple of 8 */
+
 #define  MPT_SG_REQ_128_SCALE		1
 #define  MPT_SG_REQ_96_SCALE		2
 #define  MPT_SG_REQ_64_SCALE		4
 
+#define MPT_DIAG_BUFFER_IS_REGISTERED 	1
+#define MPT_DIAG_BUFFER_IS_RELEASED 	2
+
+/*
+ * Default MAX_SGE value.  Can be changed by using mptbase sg_count parameter.
+ */
+#define MPT_SCSI_SG_DEPTH		128
+
 #define	 CAN_SLEEP			1
 #define  NO_SLEEP			0
 
@@ -150,6 +229,9 @@
 #define MPT_NARROW			0
 #define MPT_WIDE			1
 
+#define C0_1030				0x08
+#define XL_929				0x01
+
 #ifdef __KERNEL__	/* { */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
@@ -161,6 +243,16 @@
  * MPT drivers.  NOTE: Users of these macro defs must
  * themselves define their own MYNAM.
  */
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+
+#include <linux/proc_fs.h>
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ * Attempt semi-consistent error & warning msgs across
+ * MPT drivers.  NOTE: Users of these macro defs must
+ * themselves define their own MYNAM.
+ */
 #define MYIOC_s_INFO_FMT		KERN_INFO MYNAM ": %s: "
 #define MYIOC_s_NOTE_FMT		KERN_NOTICE MYNAM ": %s: "
 #define MYIOC_s_WARN_FMT		KERN_WARNING MYNAM ": %s: WARNING - "
@@ -176,7 +268,6 @@ typedef enum {
 	MPTSCSIH_DRIVER,	/* MPT SCSI host (initiator) class */
 	MPTLAN_DRIVER,		/* MPT LAN class */
 	MPTSTM_DRIVER,		/* MPT SCSI target mode class */
-	MPTDMP_DRIVER,		/* MPT Dynamic Multi-pathing class */
 	MPTUNKNOWN_DRIVER
 } MPT_DRIVER_CLASS;
 
@@ -239,28 +330,27 @@ typedef union _MPT_FRAME_TRACKER {
  *    3) SCSIIOReply
  *    4) MPIDefaultReply
  *    5) frame tracker
+ *    6) SASSMPRequest
  */
 typedef struct _MPT_FRAME_HDR {
 	union {
 		MPIHeader_t		hdr;
 		SCSIIORequest_t		scsireq;
 		SCSIIOReply_t		sreply;
+		ConfigReply_t		configreply;
 		MPIDefaultReply_t	reply;
 		MPT_FRAME_TRACKER	frame;
+		SmpPassthroughRequest_t	smpreq;
 	} u;
 } MPT_FRAME_HDR;
 
 #define MPT_REQ_MSGFLAGS_DROPME		0x80
 
-/* Used for tracking the free request frames
- * and free reply frames.
- */
 typedef struct _MPT_Q_TRACKER {
 	MPT_FRAME_HDR	*head;
 	MPT_FRAME_HDR	*tail;
 } MPT_Q_TRACKER;
 
-
 typedef struct _MPT_SGL_HDR {
 	SGESimple32_t	 sge[1];
 } MPT_SGL_HDR;
@@ -280,32 +370,16 @@ typedef struct _Q_TRACKER {
 	struct _Q_ITEM	*tail;
 } Q_TRACKER;
 
-typedef struct _MPT_DONE_Q {
-	struct _MPT_DONE_Q	*forw;
-	struct _MPT_DONE_Q	*back;
+typedef struct _MPT_REQUEST_Q {
+	struct _MPT_REQUEST_Q	*forw;
+	struct _MPT_REQUEST_Q	*back;
 	void			*argp;
-} MPT_DONE_Q;
-
-typedef struct _DONE_Q_TRACKER {
-	MPT_DONE_Q	*head;
-	MPT_DONE_Q	*tail;
-} DONE_Q_TRACKER;
+} MPT_REQUEST_Q;
 
-/*
- *  Chip-specific stuff... FC929 delineates break between
- *  FC and Parallel SCSI parts. Do NOT re-order.
- */
-
-typedef enum {
-	FC919X = 0x0819,
-	FC929X = 0x0829,
-	FC909 = 0x0909,
-	FC919 = 0x0919,
-	FC929 = 0x0929,
-	C1030 = 0x1030,
-	C1035 = 0x1035,
-	FCUNK = 0xFBAD
-} CHIP_TYPE;
+typedef struct _REQUEST_Q_TRACKER {
+	MPT_REQUEST_Q	*head;
+	MPT_REQUEST_Q	*tail;
+} REQUEST_Q_TRACKER;
 
 /*
  *  System interface register set
@@ -337,79 +411,37 @@ typedef struct _SYSIF_REGS
  * in conjunction with SYSIF_REGS accesses!
  */
 
-
-/*
- *	Dynamic Multi-Pathing specific stuff...
- */
-#define DMP_MAX_PATHS	8
-
-typedef struct _PathInfo {
-	u8		 ioc;
-	u8		 target;
-	u8		 pad;
-	u8		 pflags;
-} PathInfo;
-
-#define PATHINFO_FLAGS_OWNED		0x01
-#define PATHINFO_FLAGS_EXISTS		0x02
-#define PATHINFO_FLAGS_AVAILABLE	0x04
-#define PATHINFO_FLAGS_SECONDARY	0x08
-
-#define PFLAGS_EXISTS_AND_AVAIL		(PATHINFO_FLAGS_EXISTS|PATHINFO_FLAGS_AVAILABLE)
-#define PFLAGS_AVAIL_AND_OWNED		(PATHINFO_FLAGS_AVAILABLE|PATHINFO_FLAGS_OWNED)
-
-typedef struct _ScsiCmndTracker {
-	void			*head;
-	void			*tail;
-} ScsiCmndTracker;
-
+/* VirtDevice negoFlags field */
+#define MPT_TARGET_NO_NEGO_WIDE		0x01
+#define MPT_TARGET_NO_NEGO_SYNC		0x02
+#define MPT_TARGET_NO_NEGO_QAS		0x04
+#define MPT_TAPE_NEGO_IDP     		0x08
 
 /*
  *	VirtDevice - FC LUN device or SCSI target device
- *	(used to be FCSCSI_TARGET)
  */
 typedef struct _VirtDevice {
 	struct _VirtDevice	*forw;
 	struct _VirtDevice	*back;
 	struct scsi_device	*device;
-	rwlock_t		 VdevLock;
-	int			 ref_cnt;
 	u8			 tflags;
 	u8			 ioc_id;
 	u8			 target_id;
 	u8			 bus_id;
 	u8			 minSyncFactor;	/* 0xFF is async */
 	u8			 maxOffset;	/* 0 if async */
-	u8			 maxWidth;	/* 0 if narrow, 1 if wide*/
-	u8			 negoFlags;	/* bit field, 0 if WDTR/SDTR/QAS allowed */
+	u8			 maxWidth;	/* 0 if narrow, 1 if wide */
+	u8			 negoFlags;	/* bit field, see above */
 	u8			 raidVolume;	/* set, if RAID Volume */
-#ifdef ABORT_FIX
-	u8			 numAborts;
-#else
-	u8			 rsvd;
-#endif
-	u16			 rsvd1raid;
-	int			 npaths;
+	u8			 type;		/* byte 0 of Inquiry data */
+	u8			 cflags;	/* controller flags */
+	u8			 rsvd1raid;
 	u16			 fc_phys_lun;
 	u16			 fc_xlat_lun;
-	int			 stall_detected;
-	PathInfo		 path[DMP_MAX_PATHS];
-	struct timer_list	 stall_timer;
-	struct timer_list	 retry_timer;
-	struct timer_list	 gone_timer;
-	ScsiCmndTracker		 WaitQ;
-	ScsiCmndTracker		 SentQ;
-	ScsiCmndTracker		 DoneQ;
-//--- LUN split here?
-#ifdef MPT_SAVE_AUTOSENSE
-	u8			 sense[SCSI_STD_SENSE_BYTES];		/* 18 */
-	u8			 rsvd2[2];	/* alignment */
-#endif
-	u32			 luns;		/* Max LUNs is 32 */
-	u8			 inq_data[SCSI_STD_INQUIRY_BYTES];	/* 36 */
-	u8			 pad0[4];
-	u8			 inq00_data[20];
-	u8			 pad1[4];
+	u32			 last_lun;
+	u32			 luns[8];		/* Max LUNs is 256 */
+	u8			 pad[4];
+	u8			 inq_data[8];
 		/* IEEE Registered Extended Identifier
 		   obtained via INQUIRY VPD page 0x83 */
 		/* NOTE: Do not separate uniq_prepad and uniq_data
@@ -417,28 +449,24 @@ typedef struct _VirtDevice {
 	u8			 uniq_prepad[8];
 	u8			 uniq_data[20];
 	u8			 pad2[4];
-	u8			 inqC3_data[12];
-	u8			 pad3[4];
-	u8			 inqC9_data[12];
-	u8			 pad4[4];
-	u8			 dev_vol_name[64];
+	U64			 WWPN;
+	U64			 WWNN;
 } VirtDevice;
 
 /*
  *  Fibre Channel (SCSI) target device and associated defines...
  */
 #define MPT_TARGET_DEFAULT_DV_STATUS	0
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,55)
+#define MPT_TARGET_FLAGS_CONFIGURED	0x02
+#define MPT_TARGET_FLAGS_Q_YES		0x08
+#else
 #define MPT_TARGET_FLAGS_VALID_NEGO	0x01
 #define MPT_TARGET_FLAGS_VALID_INQUIRY	0x02
-#ifdef MPT_SAVE_AUTOSENSE
-#define MPT_TARGET_FLAGS_VALID_SENSE	0x04
-#endif
 #define MPT_TARGET_FLAGS_Q_YES		0x08
 #define MPT_TARGET_FLAGS_VALID_56	0x10
-
-#define MPT_TARGET_NO_NEGO_WIDE		0x01
-#define MPT_TARGET_NO_NEGO_SYNC		0x02
-#define MPT_TARGET_NO_NEGO_QAS		0x04
+#define MPT_TARGET_FLAGS_SAF_TE_ISSUED	0x20
+#endif
 
 typedef struct _VirtDevTracker {
 	struct _VirtDevice	*head;
@@ -447,7 +475,6 @@ typedef struct _VirtDevTracker {
 	int			 pad;
 } VirtDevTracker;
 
-
 /*
  *	/proc/mpt interface
  */
@@ -504,7 +531,7 @@ typedef struct _MPT_IOCTL {
 /*
  *  Event Structure and define
  */
-#define MPTCTL_EVENT_LOG_SIZE		(0x0000000A)
+#define MPTCTL_EVENT_LOG_SIZE		(0x00000032)
 typedef struct _mpt_ioctl_events {
 	u32	event;		/* Specified by define above */
 	u32	eventContext;	/* Index or counter */
@@ -533,8 +560,13 @@ typedef struct _mpt_ioctl_events {
 /* #define MPT_SCSICFG_BLK_NEGO		0x10	   WriteSDP1 with WDTR and SDTR disabled */
 
 typedef	struct _ScsiCfgData {
+	u32		 PortFlags;
 	int		*nvram;			/* table of device NVRAM values */
+	IOCPage2_t	*pIocPg2;		/* table of Raid Volumes */
 	IOCPage3_t	*pIocPg3;		/* table of physical disks */
+	IOCPage4_t	*pIocPg4;		/* SEP devices addressing */
+	dma_addr_t	 IocPg4_dma;		/* Phys Addr of IOCPage4 data */
+	int		 IocPg4Sz;		/* IOCPage4 size */
 	u8		 dvStatus[MPT_MAX_SCSI_DEVICES];
 	int		 isRaid;		/* bit field, 1 if RAID */
 	u8		 minSyncFactor;		/* 0xFF if async */
@@ -548,50 +580,99 @@ typedef	struct _ScsiCfgData {
 	u8		 dvScheduled;		/* 1 if scheduled */
 	u8		 forceDv;		/* 1 to force DV scheduling */
 	u8		 noQas;			/* Disable QAS for this adapter */
-	u8		 rsvd[2];
+	u8		 Saf_Te;		/* 1 to force all Processors as
+						 * SAF-TE if Inquiry data length
+						 * is too short to check for SAF-TE
+						 */
+	u8		 ptClear;		/* 1 to automatically clear the
+						 * persistent table.
+						 * 0 to disable
+						 * automatic clearing.
+						 */
+	u8		 rsvd[1];
 } ScsiCfgData;
 
-typedef struct _fw_image {
-	char		*fw;
-	dma_addr_t	 fw_dma;
-	u32		 size;
-	u32		 rsvd;
-} fw_image_t;
+typedef struct _sas_device_info {
+	struct list_head list;
+	u64	SASAddress;
+	u8	TargetId;
+	u8	Bus;
+	u8	physicalPort;
+	u8	phyNum;
+	u32	deviceInfo;
+	u16	devHandle;
+	u16	flags;
+} sas_device_info_t;
+
+/*
+ * hba phy info array
+ */
+typedef struct _sas_phy_info {
+	u64	SASAddress;
+	u8	port;
+	u8	PortFlags;
+	u8	PhyFlags;
+	u8	NegotiatedLinkRate;
+	u16	ControllerDevHandle;
+	u16	devHandle;
+	u32	ControllerPhyDeviceInfo;
+	u8	phyId;
+	u8	hwLinkRate;
+	u8	reserved;
+} sas_phy_info_t;
 
 /*
- *  Adapter Structure - pci_dev specific. Maximum: MPT_MAX_ADAPTERS
+ *  mpt Adapter Structure. 
  */
 typedef struct _MPT_ADAPTER
 {
-	struct _MPT_ADAPTER	*forw;
-	struct _MPT_ADAPTER	*back;
+	struct _MPT_ADAPTER	*next;
 	int			 id;		/* Unique adapter id N {0,1,2,...} */
 	int			 pci_irq;	/* This irq           */
 	char			 name[MPT_NAME_LENGTH];	/* "iocN"             */
 	char			*prod_name;	/* "LSIFC9x9"         */
 	volatile SYSIF_REGS	*chip;		/* == c8817000 (mmap) */
 	volatile SYSIF_REGS	*pio_chip;	/* Programmed IO (downloadboot) */
+	u8			 bus_type;	/* Parallel SCSI i/f */
+	u8			 revisionID;
+	u16			 vendorID;
+	u16			 deviceID;
+	u16			 subSystemVendorID;
+	u16			 subSystemID;
 	u32			 mem_phys;	/* == f4020000 (mmap) */
 	u32			 pio_mem_phys;	/* Programmed IO (downloadboot) */
 	int			 mem_size;	/* mmap memory size */
 	int			 alloc_total;
 	u32			 last_state;
 	int			 active;
-	u8			*reply_alloc;	/* Reply frames alloc ptr */
-	dma_addr_t		 reply_alloc_dma;
+	u8			*alloc;		/* frames alloc ptr */
+	dma_addr_t		 alloc_dma;
+	u32			 alloc_sz;
 	MPT_FRAME_HDR		*reply_frames;	/* Reply msg frames - rounded up! */
-	dma_addr_t		 reply_frames_dma;
 	u32			 reply_frames_low_dma;
 	int			 reply_depth;	/* Num Allocated reply frames */
 	int			 reply_sz;	/* Reply frame size */
-	CHIP_TYPE		 chip_type;
+	int			 num_chain;	/* Number of chain buffers */
+		/* Pool of buffers for chaining. ReqToChain
+		 * and ChainToChain track index of chain buffers.
+		 * ChainBuffer (DMA) virt/phys addresses.
+		 * FreeChainQ (lock) locking mechanisms.
+		 */
+	int			 *ReqToChain;
+	int			 *RequestNB;
+	int			 *ChainToChain;
+	u8			 *ChainBuffer;
+	dma_addr_t		  ChainBufferDMA;
+	MPT_Q_TRACKER		  FreeChainQ;
+	spinlock_t		  FreeChainQlock;
 		/* We (host driver) get to manage our own RequestQueue! */
-	u8			*req_alloc;	/* Request frames alloc ptr */
-	dma_addr_t		 req_alloc_dma;
-	MPT_FRAME_HDR		*req_frames;	/* Request msg frames - rounded up! */
 	dma_addr_t		 req_frames_dma;
+	MPT_FRAME_HDR		*req_frames;	/* Request msg frames - rounded up! */
 	u32			 req_frames_low_dma;
 	int			 req_depth;	/* Number of request frames */
+#ifdef MPT_DEBUG_QCMD_DEPTH
+	int			 qcmd_depth;	/* Number of outstanding requests */
+#endif
 	int			 req_sz;	/* Request frame size (bytes) */
 	spinlock_t		 FreeQlock;
 	MPT_Q_TRACKER		 FreeQ;
@@ -602,8 +683,21 @@ typedef struct _MPT_ADAPTER
 	u8			*sense_buf_pool;
 	dma_addr_t		 sense_buf_pool_dma;
 	u32			 sense_buf_low_dma;
+	u8			*HostPageBuffer; /* SAS - host page buffer support */
+	u32			HostPageBuffer_sz;
+	dma_addr_t		HostPageBuffer_dma;
+	u8			*DiagBuffer[MPI_DIAG_BUF_TYPE_COUNT];
+	u32			DataSize[MPI_DIAG_BUF_TYPE_COUNT];
+	u32			DiagBuffer_sz[MPI_DIAG_BUF_TYPE_COUNT];
+	dma_addr_t		DiagBuffer_dma[MPI_DIAG_BUF_TYPE_COUNT];
+	u8                  	TraceLevel[MPI_DIAG_BUF_TYPE_COUNT];
+	u8                  	DiagBuffer_Status[MPI_DIAG_BUF_TYPE_COUNT];
+	u32                 	UniqueId[MPI_DIAG_BUF_TYPE_COUNT];
+	u32                 	ExtendedType[MPI_DIAG_BUF_TYPE_COUNT];
+	u32                 	ProductSpecific[MPI_DIAG_BUF_TYPE_COUNT][4];
+
 	int			 mtrr_reg;
-	void			*pcidev;	/* struct pci_dev pointer */
+	struct pci_dev		*pcidev;	/* struct pci_dev pointer */
 	u8			*memmap;	/* mmap address */
 	struct Scsi_Host	*sh;		/* Scsi Host pointer */
 	ScsiCfgData		spi_data;	/* Scsi config. data */
@@ -617,34 +711,51 @@ typedef struct _MPT_ADAPTER
 	int			 eventContext;	/* Next event context */
 	int			 eventLogSize;	/* Max number of cached events */
 	struct _mpt_ioctl_events *events;	/* pointer to event log */
-	fw_image_t		**cached_fw;	/* Pointer to FW SG List */
+	EventNotification_t	*evnp;		/* event message frame pointer */
+	u8			*cached_fw;	/* Pointer to FW */
+	dma_addr_t	 	cached_fw_dma;
 	Q_TRACKER		 configQ;	/* linked list of config. requests */
-	int			 num_fw_frags;	/* Number of SGE in FW SG List */
 	int			 hs_reply_idx;
 #ifndef MFCNT
 	u32			 pad0;
 #else
 	u32			 mfcnt;
 #endif
+	u32			 NB_for_64_byte_frame;
 	u32			 hs_req[MPT_MAX_FRAME_SIZE/sizeof(u32)];
 	u16			 hs_reply[MPT_MAX_FRAME_SIZE/sizeof(u16)];
 	IOCFactsReply_t		 facts;
 	PortFactsReply_t	 pfacts[2];
 	FCPortPage0_t		 fc_port_page0[2];
+	U64			 sas_port_WWID[4];
+	u8			 BoardTracerNumber[16];
+	u8			 numPhys;
+/* emoore@lsil.com - sas support - start */
+	sas_phy_info_t		 *sasPhyInfo;
+	struct list_head	 sasDeviceList;
+	struct timer_list	 persist_timer;	/* persist table timer */
+	int			 persist_wait_done; /* persist completion flag */
+	u8			 persist_reply_frame[MPT_DEFAULT_FRAME_SIZE]; /* persist reply */
+/* emoore@lsil.com - sas support - end */
 	LANPage0_t		 lan_cnfg_page0;
 	LANPage1_t		 lan_cnfg_page1;
+	struct semaphore 	 mptctl_syscall_sem_ioc;
+	struct net_device 	*mpt_landev;
+	/*  
+	 * Description: errata_flag_1064
+	 * If a PCIX read occurs within 1 or 2 cycles after the chip receives
+	 * a split completion for a read data, an internal address pointer
+	 * incorrectly increments by 32 bytes
+	 */
+	u8			 errata_flag_1064;	
 	u8			 FirstWhoInit;
 	u8			 upload_fw;	/* If set, do a fw upload */
 	u8			 reload_fw;	/* Force a FW Reload on next reset */
-	u8			 pad1[5];
+	u8			 NBShiftFactor;  /* NB Shift Factor based on Block Size (Facts)  */
+	u8			 pad1[3];
+	struct list_head	 list;
 } MPT_ADAPTER;
 
-
-typedef struct _MPT_ADAPTER_TRACKER {
-	MPT_ADAPTER	*head;
-	MPT_ADAPTER	*tail;
-} MPT_ADAPTER_TRACKER;
-
 /*
  *  New return value convention:
  *    1 = Ok to free associated request frame
@@ -656,6 +767,7 @@ typedef int (*MPT_RESETHANDLER)(MPT_ADAP
 /* reset_phase defs */
 #define MPT_IOC_PRE_RESET		0
 #define MPT_IOC_POST_RESET		1
+#define MPT_IOC_SETUP_RESET		2
 
 /*
  * Invent MPT host event (super-set of MPI Events)
@@ -696,23 +808,84 @@ typedef struct _mpt_sge {
 #define dprintk(x)
 #endif
 
+#ifdef MPT_DEBUG_INIT
+#define dinitprintk(x)  printk x
+#define DBG_DUMP_FW_REQUEST_FRAME(mfp) \
+	{	int  i, n = 10;						\
+		u32 *m = (u32 *)(mfp);					\
+		printk(KERN_INFO " ");					\
+		for (i=0; i<n; i++)					\
+			printk(" %08x", le32_to_cpu(m[i]));		\
+		printk("\n");						\
+	}
+#else
+#define dinitprintk(x)
+#define DBG_DUMP_FW_REQUEST_FRAME(mfp)
+#endif
+
+#ifdef MPT_DEBUG_EXIT
+#define dexitprintk(x)  printk x
+#else
+#define dexitprintk(x)
+#endif
+
+#if defined MPT_DEBUG_FAIL || defined (MPT_DEBUG_SG)
+#define dfailprintk(x) printk x
+#else
+#define dfailprintk(x)
+#endif
+
 #ifdef MPT_DEBUG_HANDSHAKE
 #define dhsprintk(x)  printk x
 #else
 #define dhsprintk(x)
 #endif
 
+#ifdef MPT_DEBUG_EVENTS
+#define devtprintk(x)  printk x
+#else
+#define devtprintk(x)
+#endif
+
+#ifdef MPT_DEBUG_PEND
+#define dpendprintk(x)  printk x
+#else
+#define dpendprintk(x)
+#endif
+
+#ifdef MPT_DEBUG_RESET
+#define drsprintk(x)  printk x
+#define DBG_DUMP_TIMER_REQUEST_FRAME(mfp) \
+	{	int  i, n = 24;						\
+		u32 *m = (u32 *)(mfp);					\
+		for (i=0; i<n; i++) {					\
+			if (i && ((i%8)==0))				\
+				printk("\n");				\
+			printk("%08x ", le32_to_cpu(m[i]));		\
+		}							\
+		printk("\n");						\
+	}
+#else
+#define drsprintk(x)
+#define DBG_DUMP_TIMER_REQUEST_FRAME(mfp)
+#endif
+
 //#if defined(MPT_DEBUG) || defined(MPT_DEBUG_MSG_FRAME)
 #if defined(MPT_DEBUG_MSG_FRAME)
 #define dmfprintk(x)  printk x
+#define DBG_DUMP_REQUEST_FRAME(mfp) \
+	{	int  i, n = 24;						\
+		u32 *m = (u32 *)(mfp);					\
+		for (i=0; i<n; i++) {					\
+			if (i && ((i%8)==0))				\
+				printk("\n");				\
+			printk("%08x ", le32_to_cpu(m[i]));		\
+		}							\
+		printk("\n");						\
+	}
 #else
 #define dmfprintk(x)
-#endif
-
-#ifdef MPT_DEBUG_IRQ
-#define dirqprintk(x)  printk x
-#else
-#define dirqprintk(x)
+#define DBG_DUMP_REQUEST_FRAME(mfp)
 #endif
 
 #ifdef MPT_DEBUG_SG
@@ -734,6 +907,12 @@ typedef struct _mpt_sge {
 #define ddvprintk(x)
 #endif
 
+#ifdef MPT_DEBUG_NEGO
+#define dnegoprintk(x)  printk x
+#else
+#define dnegoprintk(x)
+#endif
+
 #if defined(MPT_DEBUG_DV) || defined(MPT_DEBUG_DV_TINY)
 #define ddvtprintk(x)  printk x
 #else
@@ -746,10 +925,46 @@ typedef struct _mpt_sge {
 #define dctlprintk(x)
 #endif
 
-#ifdef MPT_DEBUG_RESET
+#ifdef MPT_DEBUG_REPLY
+#define dreplyprintk(x) printk x
+#else
+#define dreplyprintk(x)
+#endif
+
+#ifdef MPT_DEBUG_SAS
+#define dsasprintk(x) printk x
+#else
+#define dsasprintk(x)
+#endif
+
+#ifdef MPT_DEBUG_TM
 #define dtmprintk(x) printk x
+#define DBG_DUMP_TM_REQUEST_FRAME(mfp) \
+	{	u32 *m = (u32 *)(mfp);					\
+		int  i, n = 13;						\
+		printk("TM_REQUEST:\n");				\
+		for (i=0; i<n; i++) {					\
+			if (i && ((i%8)==0))				\
+				printk("\n");				\
+			printk("%08x ", le32_to_cpu(m[i]));		\
+		}							\
+		printk("\n");						\
+	}
+#define DBG_DUMP_TM_REPLY_FRAME(mfp) \
+	{	u32 *m = (u32 *)(mfp);					\
+		int  i, n = (le32_to_cpu(m[0]) & 0x00FF0000) >> 16;	\
+		printk("TM_REPLY MessageLength=%d:\n", n);		\
+		for (i=0; i<n; i++) {					\
+			if (i && ((i%8)==0))				\
+				printk("\n");				\
+			printk(" %08x", le32_to_cpu(m[i]));		\
+		}							\
+		printk("\n");						\
+	}
 #else
 #define dtmprintk(x)
+#define DBG_DUMP_TM_REQUEST_FRAME(mfp)
+#define DBG_DUMP_TM_REPLY_FRAME(mfp)
 #endif
 
 #ifdef MPT_DEBUG_NEH
@@ -758,6 +973,19 @@ typedef struct _mpt_sge {
 #define nehprintk(x)
 #endif
 
+#if defined(MPT_DEBUG_CONFIG) || defined(MPT_DEBUG)
+#define dcprintk(x) printk x
+#else
+#define dcprintk(x)
+#endif
+
+#if defined(MPT_DEBUG_SCSI) || defined(MPT_DEBUG) || defined(MPT_DEBUG_MSG_FRAME)
+#define dsprintk(x) printk x
+#else
+#define dsprintk(x)
+#endif
+
+
 #define MPT_INDEX_2_MFPTR(ioc,idx) \
 	(MPT_FRAME_HDR*)( (u8*)(ioc)->req_frames + (ioc)->req_sz * (idx) )
 
@@ -795,14 +1023,7 @@ typedef struct _mpt_sge {
 	_forw->back = _back; \
 }
 
-#define SWAB4(value) \
-	(u32)(   (((value) & 0x000000ff) << 24) \
-	       | (((value) & 0x0000ff00) << 8)  \
-	       | (((value) & 0x00ff0000) >> 8)  \
-	       | (((value) & 0xff000000) >> 24) )
-
-
-#if defined(MPT_DEBUG) || defined(MPT_DEBUG_MSG_FRAME)
+#if defined(MPT_DEBUG) || defined(MPT_DEBUG_MSG_FRAME) || defined(MPT_DEBUG_HANDSHAKE)
 #define DBG_DUMP_REPLY_FRAME(mfp) \
 	{	u32 *m = (u32 *)(mfp);					\
 		int  i, n = (le32_to_cpu(m[0]) & 0x00FF0000) >> 16;	\
@@ -867,22 +1088,18 @@ typedef struct _MPT_LOCAL_REPLY {
 #define	TM_STATE_ERROR	       (2)
 #endif
 
+typedef enum {
+	FC,
+	SCSI,
+	SAS
+} BUS_TYPE;
+
 typedef struct _MPT_SCSI_HOST {
 	MPT_ADAPTER		 *ioc;
 	int			  port;
 	u32			  pad0;
 	struct scsi_cmnd	**ScsiLookup;
-		/* Pool of buffers for chaining. ReqToChain
-		 * and ChainToChain track index of chain buffers.
-		 * ChainBuffer (DMA) virt/phys addresses.
-		 * FreeChainQ (lock) locking mechanisms.
-		 */
-	int			 *ReqToChain;
-	int			 *ChainToChain;
-	u8			 *ChainBuffer;
-	dma_addr_t		  ChainBufferDMA;
-	MPT_Q_TRACKER		  FreeChainQ;
-	spinlock_t		  FreeChainQlock;
+	struct scsi_cmnd	**PendingScsi;
 	u32			  qtag_tick;
 	VirtDevice		**Targets;
 	MPT_LOCAL_REPLY		 *pLocal;		/* used for internal commands */
@@ -892,20 +1109,15 @@ typedef struct _MPT_SCSI_HOST {
 		 * OS callbacks. freeQ is the free pool.
 		 */
 	u8			 *memQ;
-	DONE_Q_TRACKER		  freeQ;
-	DONE_Q_TRACKER		  doneQ;		/* Holds Linux formmatted requests */
-	DONE_Q_TRACKER		  pendingQ;		/* Holds MPI formmatted requests */
+	REQUEST_Q_TRACKER	  freeQ;
+	REQUEST_Q_TRACKER	  pendingQ;		/* Holds MPI formmatted requests */
 	MPT_Q_TRACKER		  taskQ;		/* TM request Q */
-	spinlock_t		  freedoneQlock;
+	spinlock_t		  freeQlock;
 	int			  taskQcnt;
-	int			  num_chain;		/* Number of chain buffers */
-	int			  max_sge;		/* Max No of SGE*/
-	u8			  numTMrequests;
 	u8			  tmPending;
 	u8			  resetPending;
-	u8			  is_spi;		/* Parallel SCSI i/f */
 	u8			  negoNvram;		/* DV disabled, nego NVRAM */
-	u8			  is_multipath;		/* Multi-path compatible */
+	u8			  pad1;
 #ifdef MPT_SCSI_USE_NEW_EH
 	u8                        tmState;
 	u8			  rsvd[1];
@@ -970,7 +1182,10 @@ typedef struct _DmpServices {
 typedef struct _x_config_parms {
 	Q_ITEM			 linkage;	/* linked list */
 	struct timer_list	 timer;		/* timer function for this request  */
-	ConfigPageHeader_t	*hdr;
+	union {
+		ConfigExtendedPageHeader_t	*ehdr;
+		ConfigPageHeader_t	*hdr;
+	} cfghdr;
 	dma_addr_t		 physAddr;
 	int			 wait_done;	/* wait for this request */
 	u32			 pageAddr;	/* properly formatted */
@@ -994,35 +1209,37 @@ extern int	 mpt_reset_register(int cb_id
 extern void	 mpt_reset_deregister(int cb_idx);
 extern int	 mpt_register_ascqops_strings(void *ascqTable, int ascqtbl_sz, const char **opsTable);
 extern void	 mpt_deregister_ascqops_strings(void);
-extern MPT_FRAME_HDR	*mpt_get_msg_frame(int handle, int iocid);
-extern void	 mpt_free_msg_frame(int handle, int iocid, MPT_FRAME_HDR *mf);
-extern void	 mpt_put_msg_frame(int handle, int iocid, MPT_FRAME_HDR *mf);
+extern MPT_FRAME_HDR	*mpt_get_msg_frame(int handle, MPT_ADAPTER *ioc);
+extern void	 mpt_free_msg_frame(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf);
+extern void	 mpt_put_msg_frame(int handle, MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf);
 extern void	 mpt_add_sge(char *pAddr, u32 flagslength, dma_addr_t dma_addr);
 extern void	 mpt_add_chain(char *pAddr, u8 next, u16 length, dma_addr_t dma_addr);
 
-extern int	 mpt_send_handshake_request(int handle, int iocid, int reqBytes, u32 *req, int sleepFlag);
-extern int	 mpt_handshake_req_reply_wait(MPT_ADAPTER *ioc, int reqBytes, u32 *req, int replyBytes, u16 *u16reply, int maxwait, int sleepFlag);
+extern int	 mpt_send_handshake_request(int handle, MPT_ADAPTER *ioc, int reqBytes, u32 *req, int sleepFlag);
+extern int	mpt_handshake_req_reply_wait(MPT_ADAPTER *ioc, int reqBytes, u32 *req, int replyBytes, u16 *u16reply, int maxwait, int sleepFlag);
 extern int	 mpt_verify_adapter(int iocid, MPT_ADAPTER **iocpp);
-extern MPT_ADAPTER	*mpt_adapter_find_first(void);
-extern MPT_ADAPTER	*mpt_adapter_find_next(MPT_ADAPTER *prev);
 extern u32	 mpt_GetIocState(MPT_ADAPTER *ioc, int cooked);
 extern void	 mpt_print_ioc_summary(MPT_ADAPTER *ioc, char *buf, int *size, int len, int showlan);
 extern int	 mpt_HardResetHandler(MPT_ADAPTER *ioc, int sleepFlag);
+extern int	 mpt_do_diag_reset(MPT_ADAPTER *ioc, int sleepFlag);
 extern int	 mpt_config(MPT_ADAPTER *ioc, CONFIGPARMS *cfg);
-extern void	*mpt_alloc_fw_memory(MPT_ADAPTER *ioc, int size, int *frags, int *alloc_sz);
-extern void	 mpt_free_fw_memory(MPT_ADAPTER *ioc, fw_image_t **alt_img);
+extern int	 mpt_toolbox(MPT_ADAPTER *ioc, CONFIGPARMS *cfg);
+extern void	 mpt_alloc_fw_memory(MPT_ADAPTER *ioc, int size);
+extern void	 mpt_free_fw_memory(MPT_ADAPTER *ioc);
+extern int	 mpt_findImVolumes(MPT_ADAPTER *ioc);
 extern int	 mpt_read_ioc_pg_3(MPT_ADAPTER *ioc);
+extern int	 mptbase_sas_persist_operation(MPT_ADAPTER *ioc, u8 persist_opcode);
 
 /*
  *  Public data decl's...
  */
-extern MPT_ADAPTER	 	*mpt_adapters[MPT_MAX_ADAPTERS];
+extern struct list_head	  	ioc_list;
 extern struct proc_dir_entry	*mpt_proc_root_dir;
-extern DmpServices_t		*DmpService;
 
 extern int		  mpt_lan_index;	/* needed by mptlan.c */
 extern int		  mpt_stm_index;	/* needed by mptstm.c */
 
+
 extern void		 *mpt_v_ASCQ_TablePtr;
 extern const char	**mpt_ScsiOpcodesPtr;
 extern int		  mpt_ASCQ_TableSz;
@@ -1030,20 +1247,6 @@ extern int		  mpt_ASCQ_TableSz;
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 #endif		/* } __KERNEL__ */
 
-/*
- *  More (public) macros...
- */
-#ifndef MIN
-#define MIN(a, b)   (((a) < (b)) ? (a) : (b))
-#endif
-#ifndef MAX
-#define MAX(a, b)   (((a) > (b)) ? (a) : (b))
-#endif
-
-#ifndef offsetof
-#define offsetof(t, m)	((size_t) (&((t *)0)->m))
-#endif
-
 #if defined(__alpha__) || defined(__sparc_v9__) || defined(__ia64__) || defined(__x86_64__)
 #define CAST_U32_TO_PTR(x)	((void *)(u64)x)
 #define CAST_PTR_TO_U32(x)	((u32)(u64)x)
diff -urNp linux-8145/drivers/message/fusion/mptctl.c linux-8150/drivers/message/fusion/mptctl.c
--- linux-8145/drivers/message/fusion/mptctl.c
+++ linux-8150/drivers/message/fusion/mptctl.c
@@ -1,40 +1,14 @@
 /*
  *  linux/drivers/message/fusion/mptctl.c
- *      Fusion MPT misc device (ioctl) driver.
- *      For use with PCI chip/adapter(s):
- *          LSIFC9xx/LSI409xx Fibre Channel
+ *      mpt Ioctl driver.
+ *      For use with LSI Logic PCI chip/adapters
  *      running LSI Logic Fusion MPT (Message Passing Technology) firmware.
  *
- *  Credits:
- *      This driver would not exist if not for Alan Cox's development
- *      of the linux i2o driver.
- *
- *      A special thanks to Pamela Delaney (LSI Logic) for tons of work
- *      and countless enhancements while adding support for the 1030
- *      chip family.  Pam has been instrumental in the development of
- *      of the 2.xx.xx series fusion drivers, and her contributions are
- *      far too numerous to hope to list in one place.
- *
- *      A huge debt of gratitude is owed to David S. Miller (DaveM)
- *      for fixing much of the stupid and broken stuff in the early
- *      driver while porting to sparc64 platform.  THANK YOU!
- *
- *      A big THANKS to Eddie C. Dost for fixing the ioctl path
- *      and most importantly f/w download on sparc64 platform!
- *      (plus Eddie's other helpful hints and insights)
- *
- *      Thanks to Arnaldo Carvalho de Melo for finding and patching
- *      a potential memory leak in mptctl_do_fw_download(),
- *      and for some kmalloc insight:-)
- *
- *      (see also mptbase.c)
- *
- *  Copyright (c) 1999-2002 LSI Logic Corporation
- *  Originally By: Steven J. Ralston, Noah Romer
- *  (mailto:sjralston1@netscape.net)
- *  (mailto:lstephen@lsil.com)
+ *  Copyright (c) 1999-2005 LSI Logic Corporation
+ *  (mailto:mpt_linux_developer@lsil.com)
+ *  For support, send a description of issues to: support@lsil.com.
  *
- *  $Id: mptctl.c,v 1.63 2002/12/03 21:26:33 pdelaney Exp $
+ *  $Id: mptctl.c,v 1.66 2003/05/07 14:08:32 Exp $
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -82,6 +56,7 @@
 #include <linux/types.h>
 #include <linux/pci.h>
 #include <linux/miscdevice.h>
+#include <linux/smp_lock.h>
 
 #include <asm/io.h>
 #include <asm/uaccess.h>
@@ -92,25 +67,34 @@
 #include "../../scsi/scsi.h"
 #include "../../scsi/hosts.h"
 
-#define COPYRIGHT	"Copyright (c) 1999-2001 LSI Logic Corporation"
-#define MODULEAUTHOR	"Steven J. Ralston, Noah Romer, Pamela Delaney"
+#include <linux/delay.h>
+
+#define COPYRIGHT	"Copyright (c) 1999-2005 LSI Logic Corporation"
+#define MODULEAUTHOR	"LSI Logic"
+#include "linux_compat.h"	/* linux-2.2.x (vs. -2.4.x) tweaks */
 #include "mptbase.h"
 #include "mptctl.h"
+#if defined(CPQ_CIM)
+#include "csmisas.h"
+#endif // CPQ_CIM
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 #define my_NAME		"Fusion MPT misc device (ioctl) driver"
 #define my_VERSION	MPT_LINUX_VERSION_COMMON
 #define MYNAM		"mptctl"
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,62)
 EXPORT_NO_SYMBOLS;
+#endif
 MODULE_AUTHOR(MODULEAUTHOR);
 MODULE_DESCRIPTION(my_NAME);
 MODULE_LICENSE("GPL");
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
+extern	int mpt_downloadboot(MPT_ADAPTER *ioc, MpiFwHeader_t *pFwHeader, int sleepFlag);
+
 static int mptctl_id = -1;
-static struct semaphore mptctl_syscall_sem_ioc[MPT_MAX_ADAPTERS];
 
 static DECLARE_WAIT_QUEUE_HEAD ( mptctl_wait );
 
@@ -126,6 +110,7 @@ struct buflist {
  * arg contents specific to function.
  */
 static int mptctl_fw_download(unsigned long arg);
+static int mptctl_fw_downloadboot(unsigned long arg);
 static int mptctl_getiocinfo (unsigned long arg, unsigned int cmd);
 static int mptctl_gettargetinfo (unsigned long arg);
 static int mptctl_readtest (unsigned long arg);
@@ -134,18 +119,49 @@ static int mptctl_eventquery (unsigned l
 static int mptctl_eventenable (unsigned long arg);
 static int mptctl_eventreport (unsigned long arg);
 static int mptctl_replace_fw (unsigned long arg);
+static int mptctl_hba_pciinfo(unsigned long arg);
 
 static int mptctl_do_reset(unsigned long arg);
-static int mptctl_hp_hostinfo(unsigned long arg);
+static int mptctl_do_diag_reset(unsigned long arg);
+static int mptctl_hp_hostinfo(unsigned long arg, unsigned int cmd);
 static int mptctl_hp_targetinfo(unsigned long arg);
 
+static int mptctl_register_diag_buffer(unsigned long arg);
+static int mptctl_release_diag_buffer(unsigned long arg);
+static int mptctl_unregister_diag_buffer(unsigned long arg);
+static int mptctl_query_diag_buffer(unsigned long arg);
+static int mptctl_read_diag_buffer(unsigned long arg);
+#if defined(CPQ_CIM)
+static int mptctl_csmi_sas_get_driver_info(unsigned long arg);
+static int mptctl_csmi_sas_get_cntlr_status(unsigned long arg);
+static int mptctl_csmi_sas_get_cntlr_config(unsigned long arg);
+static int mptctl_csmi_sas_get_phy_info(unsigned long arg);
+static int mptctl_csmi_sas_get_scsi_address(unsigned long arg);
+static int mptctl_csmi_sas_get_link_errors(unsigned long arg);
+static int mptctl_csmi_sas_smp_passthru(unsigned long arg);
+static int mptctl_csmi_sas_firmware_download(unsigned long arg);
+static int mptctl_csmi_sas_get_raid_info(unsigned long arg);
+static int mptctl_csmi_sas_get_raid_config(unsigned long arg);
+static int mptctl_csmi_sas_set_phy_info(unsigned long arg);
+static int mptctl_csmi_sas_ssp_passthru(unsigned long arg);
+static int mptctl_csmi_sas_stp_passthru(unsigned long arg);
+static int mptctl_csmi_sas_get_sata_signature(unsigned long arg);
+static int mptctl_csmi_sas_get_device_address(unsigned long arg);
+static int mptctl_csmi_sas_task_managment(unsigned long arg);
+static u8  map_sas_status_to_csmi(u8 mpi_sas_status);
+static int mptctl_csmi_sas_phy_control(unsigned long arg);
+static int mptctl_csmi_sas_get_connector_info(unsigned long arg);
+static int mptctl_csmi_sas_get_location(unsigned long arg);
+#endif // CPQ_CIM
 /*
  * Private function calls.
  */
-static int mptctl_do_mpt_command (struct mpt_ioctl_command karg, char *mfPtr, int local);
+static int mptctl_do_mpt_command (struct mpt_ioctl_command karg, char *mfPtr);
 static int mptctl_do_fw_download(int ioc, char *ufwbuf, size_t fwlen);
-static MptSge_t *kbuf_alloc_2_sgl( int bytes, u32 dir, int sge_offset, int *frags,
-		struct buflist **blp, dma_addr_t *sglbuf_dma, MPT_ADAPTER *ioc);
+static int mptctl_do_fw_downloadboot(int ioc, char *ufwbuf, size_t fwlen);
+static MptSge_t *kbuf_alloc_2_sgl( int bytes, u32 dir, int sge_offset, 
+	int *frags, struct buflist **blp, dma_addr_t *sglbuf_dma, 
+	MPT_ADAPTER *ioc);
 static void kfree_sgl( MptSge_t *sgl, dma_addr_t sgl_dma,
 		struct buflist *buflist, MPT_ADAPTER *ioc);
 static void mptctl_timer_expired (unsigned long data);
@@ -158,6 +174,12 @@ static void mptctl_free_tm_flags(MPT_ADA
  */
 static int  mptctl_ioc_reset(MPT_ADAPTER *ioc, int reset_phase);
 
+/*
+ * Event Handler function
+ */
+static int mptctl_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply);
+struct fasync_struct *async_queue=NULL;
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  * Scatter gather list (SGL) sizes and limits...
@@ -180,6 +202,7 @@ static int  mptctl_ioc_reset(MPT_ADAPTER
 #define MAX_KMALLOC_SZ		(128*1024)
 
 #define MPT_IOCTL_DEFAULT_TIMEOUT 10	/* Default timeout value (seconds) */
+#define mptctl_is_this_sas_cntr(ioc) (ioc->bus_type == SAS) ? 1 : 0
 
 static u32 fwReplyBuffer[16];
 static pMPIDefaultReply_t ReplyMsg = NULL;
@@ -202,26 +225,17 @@ mptctl_syscall_down(MPT_ADAPTER *ioc, in
 	dctlprintk((KERN_INFO MYNAM "::mptctl_syscall_down(%p,%d) called\n", ioc, nonblock));
 
 	if (ioc->ioctl->tmPtr != NULL) {
-		dctlprintk((KERN_INFO MYNAM "::mptctl_syscall_down BUSY\n"));
+		dctlprintk((MYIOC_s_WARN_FMT "::mptctl_syscall_down returns -EBUSY tmPtr=%p\n", ioc->name, ioc->ioctl->tmPtr));
 		return -EBUSY;
 	}
 
-#if defined(__sparc__) && defined(__sparc_v9__)		/*{*/
-	if (!nonblock) {
-		if (down_interruptible(&mptctl_syscall_sem_ioc[ioc->id]))
-			rc = -ERESTARTSYS;
-	} else {
-		rc = -EPERM;
-	}
-#else
 	if (nonblock) {
-		if (down_trylock(&mptctl_syscall_sem_ioc[ioc->id]))
+		if (down_trylock(&ioc->mptctl_syscall_sem_ioc))
 			rc = -EAGAIN;
 	} else {
-		if (down_interruptible(&mptctl_syscall_sem_ioc[ioc->id]))
+		if (down_interruptible(&ioc->mptctl_syscall_sem_ioc))
 			rc = -ERESTARTSYS;
 	}
-#endif
 	dctlprintk((KERN_INFO MYNAM "::mptctl_syscall_down return %d\n", rc));
 	return rc;
 }
@@ -241,11 +255,31 @@ mptctl_reply(MPT_ADAPTER *ioc, MPT_FRAME
 	u16 iocStatus;
 	u8 cmd;
 
-	dctlprintk((MYIOC_s_INFO_FMT ": mptctl_reply()!\n", ioc->name));
-	if (req)
-		 cmd = req->u.hdr.Function;
-	else
+	if (reply) {
+		cmd = reply->u.hdr.Function;
+		iocStatus = reply->u.reply.IOCStatus & MPI_IOCSTATUS_MASK;
+		dctlprintk(("mptctl_reply() with req=%p reply=%p Function=%x iocStatus=%x!\n", req, reply, cmd, iocStatus));
+	} else {
+		if (ioc->ioctl) {
+			dctlprintk(("mptctl_reply() NULL Reply Function=%x!\n", req->u.hdr.Function));
+			ioc->ioctl->status |= MPT_IOCTL_STATUS_COMMAND_GOOD;
+			ioc->ioctl->reset &= ~MPTCTL_RESET_OK;
+
+			if (ioc->ioctl->status & MPT_IOCTL_STATUS_TIMER_ACTIVE) {
+				/* Delete this timer
+			 	*/
+				del_timer (&ioc->ioctl->timer);
+				ioc->ioctl->status &= ~MPT_IOCTL_STATUS_TIMER_ACTIVE;
+				/* We are done, issue wake up
+		 		*/
+				ioc->ioctl->wait_done = 1;
+				wake_up (&mptctl_wait);
+			}
+		} else {
+			dctlprintk(("mptctl_reply() NULL ioctl\n"));
+		}
 		return 1;
+	}
 
 	if (ioc->ioctl) {
 		/* If timer is not running, then an error occurred.
@@ -253,10 +287,16 @@ mptctl_reply(MPT_ADAPTER *ioc, MPT_FRAME
 		 * queues.
 		 * Main callback will free message and reply frames.
 		 */
-		if (reply && (cmd == MPI_FUNCTION_SCSI_TASK_MGMT) &&
+		if ((cmd == MPI_FUNCTION_SCSI_TASK_MGMT) &&
 		    (ioc->ioctl->status & MPT_IOCTL_STATUS_TMTIMER_ACTIVE)) {
 			/* This is internally generated TM
 			 */
+			dctlprintk(("Copying Reply Frame @%p to ioc%d!\n",
+				reply, ioc->id));
+			memcpy(ioc->ioctl->ReplyFrame, reply,
+				min(ioc->reply_sz, 4*reply->u.reply.MsgLength));
+			ioc->ioctl->status |= MPT_IOCTL_STATUS_RF_VALID;
+
 			del_timer (&ioc->ioctl->TMtimer);
 			ioc->ioctl->status &= ~MPT_IOCTL_STATUS_TMTIMER_ACTIVE;
 
@@ -265,12 +305,19 @@ mptctl_reply(MPT_ADAPTER *ioc, MPT_FRAME
 			/* If TM failed, reset the timer on the existing command,
 			 * will trigger an adapter reset.
 			 */
-			iocStatus = reply->u.reply.IOCStatus & MPI_IOCSTATUS_MASK;
 			if (iocStatus == MPI_IOCSTATUS_SCSI_TASK_MGMT_FAILED) {
-				if (ioc->ioctl->status & MPT_IOCTL_STATUS_TIMER_ACTIVE)
-					mod_timer(&ioc->ioctl->timer, jiffies + HZ);
+				if (ioc->ioctl->status & MPT_IOCTL_STATUS_TIMER_ACTIVE) {
+					ioc->ioctl->reset &= ~MPTCTL_RESET_OK;
+					del_timer (&ioc->ioctl->timer);
+					ioc->ioctl->timer.expires = jiffies + HZ;
+					add_timer(&ioc->ioctl->timer);
+				}
 			}
-			ioc->ioctl->tmPtr = NULL;
+
+			/* We are done, issue wake up
+			 */
+			ioc->ioctl->wait_done = 1;
+			wake_up (&mptctl_wait);
 
 		} else if (ioc->ioctl->status & MPT_IOCTL_STATUS_TIMER_ACTIVE) {
 			/* Delete this timer
@@ -281,66 +328,82 @@ mptctl_reply(MPT_ADAPTER *ioc, MPT_FRAME
 			/* Set the overall status byte.  Good if:
 			 * IOC status is good OR if no reply and a SCSI IO request
 			 */
-			if (reply) {
-				/* Copy the reply frame (which much exist
-				 * for non-SCSI I/O) to the IOC structure.
-				 */
-				dctlprintk((MYIOC_s_INFO_FMT ": Copying Reply Frame @%p to IOC!\n",
-						ioc->name, reply));
-				memcpy(ioc->ioctl->ReplyFrame, reply,
-					MIN(ioc->reply_sz, 4*reply->u.reply.MsgLength));
-				ioc->ioctl->status |= MPT_IOCTL_STATUS_RF_VALID;
+			/* Copy the reply frame (which must exist
+			 * for non-SCSI I/O) to the IOC structure.
+			 */
+			dctlprintk(("Copying Reply Frame @%p to ioc%d!\n",
+					reply, ioc->id));
+			memcpy(ioc->ioctl->ReplyFrame, reply,
+				min(ioc->reply_sz, 4*reply->u.reply.MsgLength));
+			ioc->ioctl->status |= MPT_IOCTL_STATUS_RF_VALID;
 
-				/* Set the command status to GOOD if IOC Status is GOOD
-				 * OR if SCSI I/O cmd and data underrun or recovered error.
-				 */
-				iocStatus = reply->u.reply.IOCStatus & MPI_IOCSTATUS_MASK;
-				if (iocStatus  == MPI_IOCSTATUS_SUCCESS)
-					ioc->ioctl->status |= MPT_IOCTL_STATUS_COMMAND_GOOD;
+			/* Set the command status to GOOD if IOC Status is GOOD
+			 * OR if SCSI I/O cmd and data underrun or recovered error.
+			 */
+			if (iocStatus  == MPI_IOCSTATUS_SUCCESS)
+				ioc->ioctl->status |= MPT_IOCTL_STATUS_COMMAND_GOOD;
 
-				if ((cmd == MPI_FUNCTION_SCSI_IO_REQUEST) ||
-					(cmd == MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)) {
-					ioc->ioctl->reset &= ~MPTCTL_RESET_OK;
+			if ((cmd == MPI_FUNCTION_SCSI_IO_REQUEST) ||
+				(cmd == MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)) {
+				ioc->ioctl->reset &= ~MPTCTL_RESET_OK;
 
-					if ((iocStatus == MPI_IOCSTATUS_SCSI_DATA_UNDERRUN) ||
-						(iocStatus == MPI_IOCSTATUS_SCSI_RECOVERED_ERROR)) {
-						ioc->ioctl->status |= MPT_IOCTL_STATUS_COMMAND_GOOD;
-					}
+				if ((iocStatus == MPI_IOCSTATUS_SCSI_DATA_UNDERRUN) ||
+					(iocStatus == MPI_IOCSTATUS_SCSI_RECOVERED_ERROR)) {
+					ioc->ioctl->status |= MPT_IOCTL_STATUS_COMMAND_GOOD;
 				}
+			}
 
-				/* Copy the sense data - if present
-				 */
-				if ((cmd == MPI_FUNCTION_SCSI_IO_REQUEST) &&
+			/* Copy the sense data - if present
+			 */
+			if ((cmd == MPI_FUNCTION_SCSI_IO_REQUEST) &&
 					(reply->u.sreply.SCSIState & MPI_SCSI_STATE_AUTOSENSE_VALID)){
 
-					sz = req->u.scsireq.SenseBufferLength;
-					req_index = le16_to_cpu(req->u.frame.hwhdr.msgctxu.fld.req_idx);
-					sense_data = ((u8 *)ioc->sense_buf_pool + (req_index * MPT_SENSE_BUFFER_ALLOC));
-					memcpy(ioc->ioctl->sense, sense_data, sz);
-					ioc->ioctl->status |= MPT_IOCTL_STATUS_SENSE_VALID;
-				}
-
-				if (cmd == MPI_FUNCTION_SCSI_TASK_MGMT)
-					mptctl_free_tm_flags(ioc);
+				sz = req->u.scsireq.SenseBufferLength;
+				req_index = le16_to_cpu(req->u.frame.hwhdr.msgctxu.fld.req_idx);
+				sense_data = ((u8 *)ioc->sense_buf_pool + (req_index * MPT_SENSE_BUFFER_ALLOC));
+				memcpy(ioc->ioctl->sense, sense_data, sz);
+				ioc->ioctl->status |= MPT_IOCTL_STATUS_SENSE_VALID;
+			}
 
+			if (cmd == MPI_FUNCTION_SCSI_TASK_MGMT)
+				mptctl_free_tm_flags(ioc);
 
-			} else if ((cmd == MPI_FUNCTION_SCSI_IO_REQUEST) ||
-					(cmd == MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)) {
-				ioc->ioctl->status |= MPT_IOCTL_STATUS_COMMAND_GOOD;
-				ioc->ioctl->reset &= ~MPTCTL_RESET_OK;
-			}
 
 			/* We are done, issue wake up
 			 */
 			ioc->ioctl->wait_done = 1;
 			wake_up (&mptctl_wait);
-		} else if (reply && cmd == MPI_FUNCTION_FW_DOWNLOAD) {
-			/* Two paths to FW DOWNLOAD! */
-			// NOTE: Expects/requires non-Turbo reply!
-			dctlprintk((MYIOC_s_INFO_FMT ":Caching MPI_FUNCTION_FW_DOWNLOAD reply!\n",
-				ioc->name));
-			memcpy(fwReplyBuffer, reply, MIN(sizeof(fwReplyBuffer), 4*reply->u.reply.MsgLength));
-			ReplyMsg = (pMPIDefaultReply_t) fwReplyBuffer;
+
+		} else {
+			if (cmd == MPI_FUNCTION_FW_DOWNLOAD) {
+				/* Two paths to FW DOWNLOAD! */
+				// NOTE: Expects/requires non-Turbo reply!
+				dctlprintk(("ioc%d Caching MPI_FUNCTION_FW_DOWNLOAD reply!\n",
+					ioc->id));
+				memcpy(fwReplyBuffer, reply, min_t(int, sizeof(fwReplyBuffer), 4*reply->u.reply.MsgLength));
+				ReplyMsg = (pMPIDefaultReply_t) fwReplyBuffer;
+			} else if (cmd == MPI_FUNCTION_DIAG_BUFFER_POST) {
+				DiagBufferPostReply_t *DiagBufferPostReply =
+	    				(DiagBufferPostReply_t *)reply;
+				u8	buffType = DiagBufferPostReply->BufferType;
+
+				if ( DiagBufferPostReply->IOCStatus == 
+					MPI_IOCSTATUS_DIAGNOSTIC_RELEASED) {
+					ioc->DiagBuffer_Status[buffType] |= 
+						MPT_DIAG_BUFFER_IS_RELEASED;
+				}
+				if ( reply->u.reply.MsgLength > 5) {
+					ioc->DataSize[buffType] = 
+						DiagBufferPostReply->TransferLength;
+				}
+				dctlprintk((MYIOC_s_WARN_FMT "DIAG_BUFFER_POST reply status=%x MsgLength=%d\n",
+					ioc->name, DiagBufferPostReply->IOCStatus, 
+					reply->u.reply.MsgLength));
+			} else {
+				cmd = reply->u.reply.Function;
+				dctlprintk(("mptctl_reply: ioc%d Unknown cmd=%x reply received req=%p reply=%p\n",
+					ioc->id, cmd, req, reply));
+			}
 		}
 	}
 	return 1;
@@ -357,10 +420,13 @@ static void mptctl_timer_expired (unsign
 	MPT_IOCTL *ioctl = (MPT_IOCTL *) data;
 	int rc = 1;
 
-	dctlprintk((KERN_NOTICE MYNAM ": Timer Expired! Host %d\n",
-				ioctl->ioc->id));
-	if (ioctl == NULL)
+	if (ioctl == NULL) {
+		printk("mptctl_timer_expired: NULL ioctl pointer!!\n");
 		return;
+	}
+
+	dctlprintk(("Timer Expired! ioc%d\n",
+				ioctl->ioc->id));
 
 	if (ioctl->reset & MPTCTL_RESET_OK)
 		rc = mptctl_bus_reset(ioctl);
@@ -383,6 +449,7 @@ static void mptctl_timer_expired (unsign
 static int mptctl_bus_reset(MPT_IOCTL *ioctl)
 {
 	MPT_FRAME_HDR	*mf;
+	MPT_ADAPTER	*iocp=ioctl->ioc;
 	SCSITaskMgmt_t	*pScsiTm;
 	MPT_SCSI_HOST	*hd;
 	int		 ii;
@@ -391,10 +458,10 @@ static int mptctl_bus_reset(MPT_IOCTL *i
 
 	ioctl->reset &= ~MPTCTL_RESET_OK;
 
-	if (ioctl->ioc->sh == NULL)
+	if (iocp->sh == NULL)
 		return -EPERM;
-	
-	hd = (MPT_SCSI_HOST *) ioctl->ioc->sh->hostdata;
+
+	hd = (MPT_SCSI_HOST *) iocp->sh->hostdata;
 	if (hd == NULL)
 		return -EPERM;
 
@@ -405,16 +472,16 @@ static int mptctl_bus_reset(MPT_IOCTL *i
 
 	/* Send request
 	 */
-	if ((mf = mpt_get_msg_frame(mptctl_id, ioctl->ioc->id)) == NULL) {
-		dctlprintk((MYIOC_s_WARN_FMT "IssueTaskMgmt, no msg frames!!\n",
-				ioctl->ioc->name));
+	if ((mf = mpt_get_msg_frame(mptctl_id, iocp)) == NULL) {
+		dfailprintk(("%s: mptctl_bus_reset, no msg frames!!\n",
+			iocp->name));
 
-		mptctl_free_tm_flags(ioctl->ioc);
+		mptctl_free_tm_flags(iocp);
 		return -ENOMEM;
 	}
 
-	dtmprintk((MYIOC_s_INFO_FMT "IssueTaskMgmt request @ %p\n",
-			ioctl->ioc->name, mf));
+	dtmprintk((MYIOC_s_WARN_FMT "IssueTaskMgmt request @ %p\n",
+			iocp->name, mf));
 
 	pScsiTm = (SCSITaskMgmt_t *) mf;
 	pScsiTm->TargetID = ioctl->target;
@@ -433,23 +500,23 @@ static int mptctl_bus_reset(MPT_IOCTL *i
 		pScsiTm->Reserved2[ii] = 0;
 
 	pScsiTm->TaskMsgContext = 0;
-	dtmprintk((MYIOC_s_INFO_FMT "mptctl_bus_reset: issued.\n", ioctl->ioc->name));
+	dtmprintk((MYIOC_s_WARN_FMT "mptctl_bus_reset: issued mf=%x\n", iocp->name, mf));
 
 	ioctl->tmPtr = mf;
 	ioctl->TMtimer.expires = jiffies + HZ * 20;	/* 20 seconds */
 	ioctl->status |= MPT_IOCTL_STATUS_TMTIMER_ACTIVE;
 	add_timer(&ioctl->TMtimer);
 
-	retval = mpt_send_handshake_request(mptctl_id, ioctl->ioc->id,
+	retval = mpt_send_handshake_request(mptctl_id, iocp,
 			sizeof(SCSITaskMgmt_t), (u32*)pScsiTm, NO_SLEEP);
 
 	if (retval != 0) {
 		dtmprintk((MYIOC_s_WARN_FMT "_send_handshake FAILED!"
-			" (hd %p, ioc %p, mf %p) \n", ioctl->ioc->name, hd, hd->ioc, mf));
+			" (mf=%p) \n", iocp->name, mf));
 
-		mptctl_free_tm_flags(ioctl->ioc);
+		mptctl_free_tm_flags(iocp);
 		del_timer(&ioctl->TMtimer);
-		mpt_free_msg_frame(mptctl_id, ioctl->ioc->id, mf);
+		mpt_free_msg_frame(iocp, mf);
 		ioctl->tmPtr = NULL;
 	}
 
@@ -494,7 +561,7 @@ mptctl_free_tm_flags(MPT_ADAPTER *ioc)
 
 	spin_lock_irqsave(&ioc->FreeQlock, flags);
 #ifdef MPT_SCSI_USE_NEW_EH
-	hd->tmState = TM_STATE_ERROR;
+	hd->tmState = TM_STATE_NONE;
 	hd->tmPending = 0;
 	spin_unlock_irqrestore(&ioc->FreeQlock, flags);
 #else
@@ -517,10 +584,14 @@ static int
 mptctl_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)
 {
 	MPT_IOCTL *ioctl = ioc->ioctl;
-	dctlprintk((KERN_INFO MYNAM ": IOC %s_reset routed to IOCTL driver!\n",
-			reset_phase==MPT_IOC_PRE_RESET ? "pre" : "post"));
-
-	if (reset_phase == MPT_IOC_PRE_RESET){
+	dctlprintk(("ioc%d %s_reset routed to IOCTL driver!\n",
+			ioc->id,
+			reset_phase==MPT_IOC_SETUP_RESET ? "setup" : (
+			reset_phase==MPT_IOC_PRE_RESET ? "pre" : "post")));
+
+	if (reset_phase == MPT_IOC_SETUP_RESET){
+		;
+	} else if (reset_phase == MPT_IOC_PRE_RESET){
 
 		/* Someone has called the reset handler to
 		 * do a hard reset. No more replies from the FW.
@@ -533,17 +604,20 @@ mptctl_ioc_reset(MPT_ADAPTER *ioc, int r
 		if (ioctl && (ioctl->status & MPT_IOCTL_STATUS_TMTIMER_ACTIVE)){
 			ioctl->status &= ~MPT_IOCTL_STATUS_TMTIMER_ACTIVE;
 			del_timer(&ioctl->TMtimer);
-			mpt_free_msg_frame(mptctl_id, ioc->id, ioctl->tmPtr);
+			if (ioctl->tmPtr != NULL) {
+				mpt_free_msg_frame(ioc, ioctl->tmPtr);
+				ioctl->tmPtr = NULL;
+			}
 		}
-
 	} else {
+
 		/* Set the status and continue IOCTL
 		 * processing. All memory will be free'd
 		 * by originating thread after wake_up is
 		 * called.
 		 */
 		if (ioctl && (ioctl->status & MPT_IOCTL_STATUS_TIMER_ACTIVE)){
-			ioctl->status = MPT_IOCTL_STATUS_DID_IOCRESET;
+			ioctl->status |= MPT_IOCTL_STATUS_DID_IOCRESET;
 
 			/* Wake up the calling process
 			 */
@@ -551,40 +625,45 @@ mptctl_ioc_reset(MPT_ADAPTER *ioc, int r
 			wake_up(&mptctl_wait);
 		}
 	}
-
 	return 1;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/*
- *  struct file_operations functionality.
- *  Members:
- *	llseek, write, read, ioctl, open, release
- */
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,9)
-static loff_t
-mptctl_llseek(struct file *file, loff_t offset, int origin)
+/* ASYNC Event Notification Support */
+static int
+mptctl_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply)
 {
-	return -ESPIPE;
+	u8 event;
+
+	event = le32_to_cpu(pEvReply->Event) & 0xFF;
+
+	dctlprintk(("%s() called\n", __FUNCTION__));
+	if(async_queue == NULL)
+		return 1;
+
+	/* Signal only for the events that are
+	 * requested for by the application
+	 */
+	if (ioc->events && (ioc->eventTypes & ( 1 << event))) {
+		dctlprintk(("Raised SIGIO to application\n"));
+		devtprintk(("Raised SIGIO to application\n"));
+		kill_fasync(&async_queue, SIGIO, POLL_IN);
+	}
+	return 1;
 }
-#define no_llseek mptctl_llseek
-#endif
 
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-static ssize_t
-mptctl_write(struct file *file, const char *buf, size_t count, loff_t *ppos)
+static int
+mptctl_fasync(int fd, struct file *filep, int mode)
 {
-	printk(KERN_ERR MYNAM ": ioctl WRITE not yet supported\n");
-	return 0;
+	dctlprintk(("%s() called\n", __FUNCTION__));
+	return fasync_helper(fd, filep, mode, &async_queue);
 }
 
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-static ssize_t
-mptctl_read(struct file *file, char *buf, size_t count, loff_t *ptr)
+static int
+mptctl_release(struct inode *inode, struct file *filep)
 {
-	printk(KERN_ERR MYNAM ": ioctl READ not yet supported\n");
-	return 0;
+	dctlprintk(("%s() called\n", __FUNCTION__));
+	return fasync_helper(-1, filep, 0, &async_queue);
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -604,14 +683,15 @@ mptctl_ioctl(struct inode *inode, struct
 	int ret;
 	MPT_ADAPTER *iocp = NULL;
 
-	dctlprintk(("mptctl_ioctl() called\n"));
-
 	if (copy_from_user(&khdr, uhdr, sizeof(khdr))) {
 		printk(KERN_ERR "%s::mptctl_ioctl() @%d - "
 				"Unable to copy mpt_ioctl_header data @ %p\n",
 				__FILE__, __LINE__, (void*)uhdr);
 		return -EFAULT;
 	}
+
+	dctlprintk(("mptctl_ioctl() called with cmd=%x\n", cmd));
+
 	ret = -ENXIO;				/* (-6) No such device or address */
 
 	/* Verify intended MPT adapter - set iocnum and the adapter
@@ -620,12 +700,16 @@ mptctl_ioctl(struct inode *inode, struct
 	iocnumX = khdr.iocnum & 0xFF;
 	if (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||
 	    (iocp == NULL)) {
-		dctlprintk((KERN_ERR "%s::mptctl_ioctl() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnumX));
+		dctlprintk(("mptctl_ioctl: ioc%d not found!\n",
+				iocnumX));
 		return -ENODEV;
 	}
 
-
+/*	if (!iocp->active) {
+		printk(KERN_ERR "%s::mptctl_ioctl() @%d - Controller disabled.\n",
+				__FILE__, __LINE__);
+		return -EFAULT;
+	} */
 
 	/* Handle those commands that are just returning
 	 * information stored in the driver.
@@ -646,7 +730,26 @@ mptctl_ioctl(struct inode *inode, struct
 		return mptctl_eventreport(arg);
 	} else if (cmd == MPTFWREPLACE) {
 		return mptctl_replace_fw(arg);
+	} else if (cmd == MPTDIAGQUERY) {
+		return mptctl_query_diag_buffer(arg);
+	} else if (cmd == MPTDIAGUNREGISTER) {
+		return mptctl_unregister_diag_buffer(arg);
+	} else if (cmd == MPTHBAPCIINFO) {
+		return mptctl_hba_pciinfo(arg);
+	}
+#if defined(CPQ_CIM)
+	else if (cmd == CC_CSMI_SAS_GET_DRIVER_INFO) {
+		return mptctl_csmi_sas_get_driver_info(arg);
+	} else if (cmd == CC_CSMI_SAS_GET_CNTLR_CONFIG) {
+		return mptctl_csmi_sas_get_cntlr_config(arg);
+	} else if (cmd == CC_CSMI_SAS_GET_CNTLR_STATUS) {
+		return mptctl_csmi_sas_get_cntlr_status(arg);
+	} else if (cmd == CC_CSMI_SAS_GET_SCSI_ADDRESS) {
+		return mptctl_csmi_sas_get_scsi_address(arg);
+	} else if (cmd == CC_CSMI_SAS_GET_DEVICE_ADDRESS){
+		return mptctl_csmi_sas_get_device_address(arg);
 	}
+#endif // CPQ_CIM
 
 	/* All of these commands require an interrupt or
 	 * are unknown/illegal.
@@ -654,29 +757,63 @@ mptctl_ioctl(struct inode *inode, struct
 	if ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)
 		return ret;
 
-	dctlprintk((MYIOC_s_INFO_FMT ": mptctl_ioctl()\n", iocp->name));
-
-	switch(cmd) {
-	case MPTFWDOWNLOAD:
+	if (cmd == MPTFWDOWNLOAD)
 		ret = mptctl_fw_download(arg);
-		break;
-	case MPTCOMMAND:
+	else if (cmd == MPTFWDOWNLOADBOOT)
+		ret = mptctl_fw_downloadboot(arg);
+	else if (cmd == MPTCOMMAND)
 		ret = mptctl_mpt_command(arg);
-		break;
-	case MPTHARDRESET:
+	else if (cmd == MPTHARDRESET)
 		ret = mptctl_do_reset(arg);
-		break;
-	case HP_GETHOSTINFO:
-		ret = mptctl_hp_hostinfo(arg);
-		break;
-	case HP_GETTARGETINFO:
+	else if (cmd == MPTDIAGRESET)
+		ret = mptctl_do_diag_reset(arg);
+	else if ((cmd & ~IOCSIZE_MASK) == (HP_GETHOSTINFO & ~IOCSIZE_MASK))
+		ret = mptctl_hp_hostinfo(arg, _IOC_SIZE(cmd));
+	else if (cmd == HP_GETTARGETINFO)
 		ret = mptctl_hp_targetinfo(arg);
-		break;
-	default:
+	else if (cmd == MPTDIAGREGISTER)
+		ret = mptctl_register_diag_buffer(arg);
+	else if (cmd == MPTDIAGRELEASE)
+		ret = mptctl_release_diag_buffer(arg);
+	else if (cmd == MPTDIAGREADBUFFER)
+		ret = mptctl_read_diag_buffer(arg);
+#if defined(CPQ_CIM)
+	else if (cmd == CC_CSMI_SAS_GET_PHY_INFO)
+		ret = mptctl_csmi_sas_get_phy_info(arg);
+	else if (cmd == CC_CSMI_SAS_GET_SATA_SIGNATURE)
+		ret = mptctl_csmi_sas_get_sata_signature(arg);
+	else if (cmd == CC_CSMI_SAS_GET_LINK_ERRORS)
+		ret = mptctl_csmi_sas_get_link_errors(arg);
+	else if (cmd == CC_CSMI_SAS_SMP_PASSTHRU)
+		ret = mptctl_csmi_sas_smp_passthru(arg);
+	else if (cmd == CC_CSMI_SAS_SSP_PASSTHRU)
+		ret = mptctl_csmi_sas_ssp_passthru(arg);
+	else if (cmd == CC_CSMI_SAS_FIRMWARE_DOWNLOAD)
+		ret = mptctl_csmi_sas_firmware_download(arg);
+	else if (cmd == CC_CSMI_SAS_GET_RAID_INFO)
+		ret = mptctl_csmi_sas_get_raid_info(arg);
+	else if (cmd == CC_CSMI_SAS_GET_RAID_CONFIG)
+		ret = mptctl_csmi_sas_get_raid_config(arg);
+	else if (cmd == CC_CSMI_SAS_SET_PHY_INFO)
+		ret = mptctl_csmi_sas_set_phy_info(arg);
+	else if (cmd == CC_CSMI_SAS_STP_PASSTHRU)
+		ret = mptctl_csmi_sas_stp_passthru(arg);
+	else if (cmd == CC_CSMI_SAS_TASK_MANAGEMENT)
+		ret = mptctl_csmi_sas_task_managment(arg);
+	else if (cmd == CC_CSMI_SAS_PHY_CONTROL)
+		ret = mptctl_csmi_sas_phy_control(arg);
+	else if (cmd == CC_CSMI_SAS_GET_CONNECTOR_INFO)
+		ret = mptctl_csmi_sas_get_connector_info(arg);
+	else if (cmd == CC_CSMI_SAS_GET_LOCATION)
+		ret = mptctl_csmi_sas_get_location(arg);
+#endif // CPQ_CIM
+	else {
+		dctlprintk(("mptctl_ioctl() cmd=%x not found\n", cmd));
 		ret = -EINVAL;
 	}
 
-	up(&mptctl_syscall_sem_ioc[iocp->id]);
+
+	up(&iocp->mptctl_syscall_sem_ioc);
 
 	return ret;
 }
@@ -687,7 +824,7 @@ static int mptctl_do_reset(unsigned long
 	struct mpt_ioctl_diag_reset krinfo;
 	MPT_ADAPTER		*iocp;
 
-	dctlprintk((KERN_INFO "mptctl_do_reset called.\n"));
+	dctlprintk(("mptctl_do_reset called.\n"));
 
 	if (copy_from_user(&krinfo, urinfo, sizeof(struct mpt_ioctl_diag_reset))) {
 		printk(KERN_ERR "%s@%d::mptctl_do_reset - "
@@ -697,32 +834,45 @@ static int mptctl_do_reset(unsigned long
 	}
 
 	if (mpt_verify_adapter(krinfo.hdr.iocnum, &iocp) < 0) {
-		dctlprintk((KERN_ERR "%s@%d::mptctl_do_reset - ioc%d not found!\n",
-				__FILE__, __LINE__, krinfo.hdr.iocnum));
+		dctlprintk(("mptctl_do_reset: ioc%d not found!\n",
+				krinfo.hdr.iocnum));
 		return -ENODEV; /* (-6) No such device or address */
 	}
 
 	if (mpt_HardResetHandler(iocp, NO_SLEEP) != 0) {
-		printk (KERN_ERR "%s@%d::mptctl_do_reset - reset failed.\n",
-			__FILE__, __LINE__);
+		dctlprintk(("mptctl_do_reset: reset failed.\n"));
 		return -1;
 	}
 
 	return 0;
 }
 
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-static int mptctl_open(struct inode *inode, struct file *file)
+static int mptctl_do_diag_reset(unsigned long arg)
 {
-	/*
-	 * Should support multiple management users
-	 */
-	return 0;
-}
+	struct mpt_ioctl_diag_reset *urinfo = (struct mpt_ioctl_diag_reset *) arg;
+	struct mpt_ioctl_diag_reset krinfo;
+	MPT_ADAPTER		*iocp;
+
+	dctlprintk(("mptctl_do_diag_reset called.\n"));
+
+	if (copy_from_user(&krinfo, urinfo, sizeof(struct mpt_ioctl_diag_reset))) {
+		printk(KERN_ERR "%s@%d::mptctl_do_diag_reset - "
+				"Unable to copy mpt_ioctl_diag_reset struct @ %p\n",
+				__FILE__, __LINE__, (void*)urinfo);
+		return -EFAULT;
+	}
+
+	if (mpt_verify_adapter(krinfo.hdr.iocnum, &iocp) < 0) {
+		dctlprintk(("mptctl_do_diag_reset: ioc%d not found!\n",
+				krinfo.hdr.iocnum));
+		return -ENODEV; /* (-6) No such device or address */
+	}
+
+	if (mpt_do_diag_reset(iocp, NO_SLEEP) != 0) {
+		dctlprintk(("mptctl_do_diag_reset: reset failed.\n"));
+		return -1;
+	}
 
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-static int mptctl_release(struct inode *inode, struct file *file)
-{
 	return 0;
 }
 
@@ -749,7 +899,7 @@ mptctl_fw_download(unsigned long arg)
 	struct mpt_fw_xfer	*ufwdl = (struct mpt_fw_xfer *) arg;
 	struct mpt_fw_xfer	 kfwdl;
 
-	dctlprintk((KERN_INFO "mptctl_fwdl called. mptctl_id = %xh\n", mptctl_id)); //tc
+	dctlprintk(("mptctl_fwdl called. mptctl_id = %xh\n", mptctl_id)); //tc
 	if (copy_from_user(&kfwdl, ufwdl, sizeof(struct mpt_fw_xfer))) {
 		printk(KERN_ERR "%s@%d::_ioctl_fwdl - "
 				"Unable to copy mpt_fw_xfer struct @ %p\n",
@@ -798,22 +948,26 @@ mptctl_do_fw_download(int ioc, char *ufw
 	int			 sge_offset = 0;
 	u16			 iocstat;
 
-	dctlprintk((KERN_INFO "mptctl_do_fwdl called. mptctl_id = %xh.\n", mptctl_id));
+	dctlprintk(("mptctl_do_fwdl called. mptctl_id = %xh.\n", mptctl_id));
 
-	dctlprintk((KERN_INFO "DbG: kfwdl.bufp  = %p\n", ufwbuf));
-	dctlprintk((KERN_INFO "DbG: kfwdl.fwlen = %d\n", (int)fwlen));
-	dctlprintk((KERN_INFO "DbG: kfwdl.ioc   = %04xh\n", ioc));
-
-	if ((ioc = mpt_verify_adapter(ioc, &iocp)) < 0) {
-		dctlprintk(("%s@%d::_ioctl_fwdl - ioc%d not found!\n",
-				__FILE__, __LINE__, ioc));
+	dctlprintk(("DbG: kfwdl.bufp  = %p\n", ufwbuf));
+	dctlprintk(("DbG: kfwdl.fwlen = %d\n", (int)fwlen));
+	dctlprintk(("DbG: kfwdl.ioc   = %04xh\n", ioc));
+
+	if (mpt_verify_adapter(ioc, &iocp) < 0) {
+		dctlprintk(("ioctl_fwdl - ioc%d not found!\n",
+				 ioc));
 		return -ENODEV; /* (-6) No such device or address */
-	}
+	} else {
 
-	/*  Valid device. Get a message frame and construct the FW download message.
-	 */
-	if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL)
-		return -EAGAIN;
+		/*  Valid device. Get a message frame and construct the FW download message.
+	 	*/
+		if ((mf = mpt_get_msg_frame(mptctl_id, iocp)) == NULL) {
+			dfailprintk(("%s: mptctl_do_fwdl, no msg frames!!\n",
+				iocp->name));
+			return -EAGAIN;
+		}
+	}
 	dlmsg = (FWDownload_t*) mf;
 	ptsge = (FWDownloadTCSGE_t *) &dlmsg->SGL;
 	sgOut = (char *) (ptsge + 1);
@@ -826,7 +980,12 @@ mptctl_do_fw_download(int ioc, char *ufw
 	dlmsg->ChainOffset = 0;
 	dlmsg->Function = MPI_FUNCTION_FW_DOWNLOAD;
 	dlmsg->Reserved1[0] = dlmsg->Reserved1[1] = dlmsg->Reserved1[2] = 0;
-	dlmsg->MsgFlags = 0;
+//	if (iocp->facts.MsgVersion >= MPI_VERSION_01_05) {
+		dlmsg->MsgFlags = MPI_FW_DOWNLOAD_MSGFLGS_LAST_SEGMENT;
+//	} else {
+//		dlmsg->MsgFlags = 0;
+//	}
+	dctlprintk(("mptctl_do_fwdl MsgVersion=%x MsgFlags=%x\n", iocp->facts.MsgVersion, dlmsg->MsgFlags));
 
 	/* Set up the Transaction SGE.
 	 */
@@ -871,14 +1030,14 @@ mptctl_do_fw_download(int ioc, char *ufw
 	 *	96		8
 	 *	64		4
 	 */
-	maxfrags = (iocp->req_sz - sizeof(MPIHeader_t) - sizeof(FWDownloadTCSGE_t)) 
+	maxfrags = (iocp->req_sz - sizeof(MPIHeader_t) - sizeof(FWDownloadTCSGE_t))
 			/ (sizeof(dma_addr_t) + sizeof(u32));
 	if (numfrags > maxfrags) {
 		ret = -EMLINK;
 		goto fwdl_out;
 	}
 
-	dctlprintk((KERN_INFO "DbG: sgl buffer  = %p, sgfrags = %d\n", sgl, numfrags));
+	dctlprintk(("DbG: sgl buffer  = %p, sgfrags = %d\n", sgl, numfrags));
 
 	/*
 	 * Parse SG list, copying sgl itself,
@@ -928,7 +1087,7 @@ mptctl_do_fw_download(int ioc, char *ufw
 	 * Finally, perform firmware download.
 	 */
 	ReplyMsg = NULL;
-	mpt_put_msg_frame(mptctl_id, ioc, mf);
+	mpt_put_msg_frame(mptctl_id, iocp, mf);
 
 	/*
 	 *  Wait until the reply has been received
@@ -940,7 +1099,7 @@ mptctl_do_fw_download(int ioc, char *ufw
 		}
 
 		if (!(i%HZ)) {
-			dctlprintk((KERN_INFO "DbG::_do_fwdl: "
+			dctlprintk(("DbG::_do_fwdl: "
 				   "In ReplyMsg loop - iteration %d\n",
 				   i));
 		}
@@ -980,6 +1139,107 @@ fwdl_out:
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
+ * MPT FW downloadboot function.  Cast the arg into the mpt_fw_xfer structure.
+ * This structure contains: iocnum, firmware length (bytes),
+ *      pointer to user space memory where the fw image is stored.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENXIO  if no such device
+ *		-EAGAIN if resource problem
+ *		-ENOMEM if no memory for SGE
+ *		-EMLINK if too many chain buffers required
+ *		-EBADRQC if adapter does not support FW downloadboot
+ *		-EBUSY if adapter is busy
+ *		-ENOMSG if FW upload returned bad status
+ */
+static int
+mptctl_fw_downloadboot(unsigned long arg)
+{
+	struct mpt_fw_xfer	*ufwdl = (struct mpt_fw_xfer *) arg;
+	struct mpt_fw_xfer	 kfwdl;
+
+	dctlprintk(("mptctl_fwdlboot called. mptctl_id = %xh\n", mptctl_id)); //tc
+	if (copy_from_user(&kfwdl, ufwdl, sizeof(struct mpt_fw_xfer))) {
+		printk(KERN_ERR "%s@%d::_ioctl_fwdl - "
+				"Unable to copy mpt_fw_xfer struct @ %p\n",
+				__FILE__, __LINE__, (void*)ufwdl);
+		return -EFAULT;
+	}
+
+	dctlprintk(("mptctl_fwdlboot fwlen = 0x%x (%d) bufp=%p\n", kfwdl.fwlen, kfwdl.fwlen, kfwdl.bufp)); //tc
+	return mptctl_do_fw_downloadboot(kfwdl.iocnum, kfwdl.bufp, kfwdl.fwlen);
+}
+
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptctl_do_fw_downloadboot - DownloadBoot code
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@flag: Specify which part of IOC memory is to be uploaded.
+ *	@sleepFlag: Specifies whether the process can sleep
+ *
+ *	FwDownloadBoot requires Programmed IO access.
+ *
+ *	Returns 0 for success
+ *		-1 FW Image size is 0
+ *		-2 No valid cached_fw Pointer
+ *		<0 for fw upload failure.
+ */
+static int
+mptctl_do_fw_downloadboot(int ioc_num, char *ufwbuf, size_t fwlen)
+{
+	MPT_ADAPTER		*ioc;
+	char			*pbuf;
+	int			rc;
+
+	if (mpt_verify_adapter(ioc_num, &ioc) < 0) {
+		dctlprintk(("ioctl_fwdl - ioc%d not found!\n",
+				 ioc_num));
+		return -ENODEV; /* (-6) No such device or address */
+	}
+
+	pbuf = kmalloc(fwlen, GFP_KERNEL);
+	if (copy_from_user(pbuf, ufwbuf, fwlen)) {
+		printk(KERN_ERR "%s@%d::_ioctl_fwdlboot - "
+				"Unable to copy mpt_fw @ %p\n",
+				__FILE__, __LINE__, (void*)ufwbuf);
+		return -EFAULT;
+	}
+
+	ddlprintk((MYIOC_s_WARN_FMT "mptctl_do_fw_downloadboot fwlen=%d pbuf=%p\n",
+				ioc->name, (int)fwlen, pbuf));
+
+	rc = mpt_downloadboot(ioc, (MpiFwHeader_t *)pbuf, CAN_SLEEP);
+	ddlprintk((MYIOC_s_WARN_FMT "mptctl_do_fw_downloadboot rc=%x\n",
+				ioc->name, rc));
+/*	if ( (rc == 0) && (ioc->bus_type == SAS) ) {
+		if ((rc = mptctl_syscall_down(ioc, nonblock)) != 0)
+			return rc;
+
+		rc = mptctl_do_fw_download(ioc_num, ufwbuf, fwlen);
+
+		up(&ioc->mptctl_syscall_sem_ioc);
+
+		ddlprintk((MYIOC_s_WARN_FMT "SAS mptctl_do_fw_download rc=%x\n",
+				ioc->name, rc));
+
+		if ( (rc = mpt_diag_reset(ioc, 1, sleepFlag)) < 0) {
+			ddlprintk((MYIOC_s_WARN_FMT "SAS Diagnostic reset after downloadboot failed!\n",
+				ioc->name));
+		} else {
+		ddlprintk((MYIOC_s_WARN_FMT "SAS Diagnostic reset after downloadboot successful!\n",
+			ioc->name));
+		}
+	} */
+	kfree(pbuf);
+	return rc;
+}
+
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
  * SGE Allocation routine
  *
  * Inputs:	bytes - number of bytes to be transferred
@@ -1003,7 +1263,7 @@ kbuf_alloc_2_sgl(int bytes, u32 sgdir, i
 	MptSge_t	*sgl;
 	int		 numfrags = 0;
 	int		 fragcnt = 0;
-	int		 alloc_sz = MIN(bytes,MAX_KMALLOC_SZ);	// avoid kernel warning msg!
+	int		 alloc_sz = min(bytes,MAX_KMALLOC_SZ);	// avoid kernel warning msg!
 	int		 bytes_allocd = 0;
 	int		 this_alloc;
 	dma_addr_t	 pa;					// phys addr
@@ -1048,7 +1308,7 @@ kbuf_alloc_2_sgl(int bytes, u32 sgdir, i
 	sgl = sglbuf;
 	sg_spill = ((ioc->req_sz - sge_offset)/(sizeof(dma_addr_t) + sizeof(u32))) - 1;
 	while (bytes_allocd < bytes) {
-		this_alloc = MIN(alloc_sz, bytes-bytes_allocd);
+		this_alloc = min(alloc_sz, bytes-bytes_allocd);
 		buflist[buflist_ent].len = this_alloc;
 		buflist[buflist_ent].kptr = pci_alloc_consistent(ioc->pcidev,
 								 this_alloc,
@@ -1104,11 +1364,11 @@ kbuf_alloc_2_sgl(int bytes, u32 sgdir, i
 	*frags = numfrags;
 	*blp = buflist;
 
-	dctlprintk((KERN_INFO MYNAM "-SG: kbuf_alloc_2_sgl() - "
+	dctlprintk(("-SG: kbuf_alloc_2_sgl() - "
 			   "%d SG frags generated!\n",
 			   numfrags));
 
-	dctlprintk((KERN_INFO MYNAM "-SG: kbuf_alloc_2_sgl() - "
+	dctlprintk(("-SG: kbuf_alloc_2_sgl() - "
 			   "last (big) alloc_sz=%d\n",
 			   alloc_sz));
 
@@ -1194,7 +1454,7 @@ kfree_sgl(MptSge_t *sgl, dma_addr_t sgl_
 
 	pci_free_consistent(ioc->pcidev, MAX_SGL_BYTES, sgl, sgl_dma);
 	kfree(buflist);
-	dctlprintk((KERN_INFO MYNAM "-SG: Free'd 1 SGL buf + %d kbufs!\n", n));
+	dctlprintk(("-SG: Free'd 1 SGL buf + %d kbufs!\n", n));
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -1211,7 +1471,7 @@ static int
 mptctl_getiocinfo (unsigned long arg, unsigned int data_size)
 {
 	struct mpt_ioctl_iocinfo *uarg = (struct mpt_ioctl_iocinfo *) arg;
-	struct mpt_ioctl_iocinfo karg;
+	struct mpt_ioctl_iocinfo *karg;
 	MPT_ADAPTER		*ioc;
 	struct pci_dev		*pdev;
 	struct Scsi_Host	*sh;
@@ -1222,67 +1482,98 @@ mptctl_getiocinfo (unsigned long arg, un
 	int			ii;
 	int			port;
 	int			cim_rev;
-	u8			revision;
 
-	dctlprintk((": mptctl_getiocinfo called.\n"));
-	if (data_size == sizeof(struct mpt_ioctl_iocinfo))
-		cim_rev = 1;
-	else if (data_size == (sizeof(struct mpt_ioctl_iocinfo) - sizeof(struct mpt_ioctl_pci_info)))
+	dctlprintk(("mptctl_getiocinfo called.\n"));
+	/* Add of PCI INFO results in unaligned access for
+	 * IA64 and Sparc. Reset long to int. Return no PCI
+	 * data for obsolete format.
+	 */
+	if (data_size == sizeof(struct mpt_ioctl_iocinfo_rev0))
 		cim_rev = 0;
-	else
+	else if (data_size == sizeof(struct mpt_ioctl_iocinfo_rev1))
+		cim_rev = 1;
+	else if (data_size == sizeof(struct mpt_ioctl_iocinfo))
+		cim_rev = 2;
+	else if (data_size == (sizeof(struct mpt_ioctl_iocinfo_rev0)+12))
+		cim_rev = 0;	/* obsolete */
+	else {
+		dctlprintk(("mptctl_getiocinfo(): incorrect data_size=%d\n",
+				data_size));
 		return -EFAULT;
+	}
+
+	karg = kmalloc(data_size, GFP_KERNEL);
+	if (karg == NULL) {
+		printk(KERN_ERR "%s::mpt_ioctl_iocinfo() @%d - no memory available!\n",
+				__FILE__, __LINE__);
+		return -ENOMEM;
+	}
 
-	if (copy_from_user(&karg, uarg, data_size)) {
+	if (copy_from_user(karg, uarg, data_size)) {
 		printk(KERN_ERR "%s@%d::mptctl_getiocinfo - "
 			"Unable to read in mpt_ioctl_iocinfo struct @ %p\n",
 				__FILE__, __LINE__, (void*)uarg);
+		kfree(karg);
 		return -EFAULT;
 	}
 
-	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+	if (((iocnum = mpt_verify_adapter(karg->hdr.iocnum, &ioc)) < 0) ||
 	    (ioc == NULL)) {
-		dctlprintk((KERN_ERR "%s::mptctl_getiocinfo() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnum));
+		dctlprintk(("mptctl_getiocinfo(): ioc%d not found!\n",
+				iocnum));
+		kfree(karg);
 		return -ENODEV;
 	}
 
+	dctlprintk(("mptctl_getiocinfo(): ioc%d found!\n",
+				iocnum));
+
 	/* Verify the data transfer size is correct.
 	 * Ignore the port setting.
 	 */
-	if (karg.hdr.maxDataSize != data_size) {
+	if (karg->hdr.maxDataSize != data_size) {
 		printk(KERN_ERR "%s@%d::mptctl_getiocinfo - "
 			"Structure size mismatch. Command not completed.\n",
 				__FILE__, __LINE__);
+		kfree(karg);
 		return -EFAULT;
 	}
 
 	/* Fill in the data and return the structure to the calling
 	 * program
 	 */
-	if (ioc->chip_type == C1030)
-		karg.adapterType = MPT_IOCTL_INTERFACE_SCSI;
+	if (ioc->bus_type == SAS)
+		karg->adapterType = MPT_IOCTL_INTERFACE_SAS;
+	else if (ioc->bus_type == FC)
+		karg->adapterType = MPT_IOCTL_INTERFACE_FC;
 	else
-		karg.adapterType = MPT_IOCTL_INTERFACE_FC;
+		karg->adapterType = MPT_IOCTL_INTERFACE_SCSI;
 
-	port = karg.hdr.port;
+	port = karg->hdr.port & 0x0000ffff;
 
-	karg.port = port;
-	pdev = (struct pci_dev *) ioc->pcidev;
+	karg->port = port;
+	pdev = ioc->pcidev;
 
-	karg.pciId = pdev->device;
-	pci_read_config_byte(pdev, PCI_CLASS_REVISION, &revision);
-	karg.hwRev = revision;
+	karg->pciId = pdev->device;
+	karg->hwRev = ioc->revisionID;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	karg.subSystemDevice = pdev->subsystem_device;
-	karg.subSystemVendor = pdev->subsystem_vendor;
+	karg->subSystemDevice = pdev->subsystem_device;
+	karg->subSystemVendor = pdev->subsystem_vendor;
 #endif
 
 	if (cim_rev == 1) {
 		/* Get the PCI bus, device, and function numbers for the IOC
 		 */
-		karg.pciInfo.u.bits.busNumber = pdev->bus->number;
-		karg.pciInfo.u.bits.deviceNumber = PCI_SLOT( pdev->devfn );
-		karg.pciInfo.u.bits.functionNumber = PCI_FUNC( pdev->devfn );
+		karg->pciInfo.u.bits.busNumber = pdev->bus->number;
+		karg->pciInfo.u.bits.deviceNumber = PCI_SLOT( pdev->devfn );
+		karg->pciInfo.u.bits.functionNumber = PCI_FUNC( pdev->devfn );
+	} else if (cim_rev == 2) {
+		/* Get the PCI bus, device, function and segment ID numbers
+		   for the IOC */
+		karg->pciInfo.u.bits.busNumber = pdev->bus->number;
+		karg->pciInfo.u.bits.deviceNumber = PCI_SLOT( pdev->devfn );
+		karg->pciInfo.u.bits.functionNumber = PCI_FUNC( pdev->devfn );
+		karg->pciInfo.segmentID = PCI_SEGMENT(pdev->bus);
 	}
 
 	/* Get number of devices
@@ -1303,30 +1594,33 @@ mptctl_getiocinfo (unsigned long arg, un
 			}
 		}
 	}
-	karg.numDevices = numDevices;
+	karg->numDevices = numDevices;
 
 	/* Set the BIOS and FW Version
 	 */
-	karg.FWVersion = ioc->facts.FWVersion.Word;
-	karg.BIOSVersion = ioc->biosVersion;
+	karg->FWVersion = ioc->facts.FWVersion.Word;
+	karg->BIOSVersion = ioc->biosVersion;
 
 	/* Set the Version Strings.
 	 */
-	strncpy (karg.driverVersion, MPT_LINUX_PACKAGE_NAME, MPT_IOCTL_VERSION_LENGTH);
+	strncpy (karg->driverVersion, MPT_LINUX_PACKAGE_NAME, MPT_IOCTL_VERSION_LENGTH);
+	karg->driverVersion[MPT_IOCTL_VERSION_LENGTH-1]='\0';
 
-	karg.busChangeEvent = 0;
-	karg.hostId = ioc->pfacts[port].PortSCSIID;
-	karg.rsvd[0] = karg.rsvd[1] = 0;
+	karg->busChangeEvent = 0;
+	karg->hostId = ioc->pfacts[port].PortSCSIID;
+	karg->rsvd[0] = karg->rsvd[1] = 0;
 
 	/* Copy the data from kernel memory to user memory
 	 */
-	if (copy_to_user((char *)arg, &karg, data_size)) {
+	if (copy_to_user((char *)arg, karg, data_size)) {
 		printk(KERN_ERR "%s@%d::mptctl_getiocinfo - "
 			"Unable to write out mpt_ioctl_iocinfo struct @ %p\n",
 				__FILE__, __LINE__, (void*)uarg);
+		kfree(karg);
 		return -EFAULT;
 	}
 
+	kfree(karg);
 	return 0;
 }
 
@@ -1348,15 +1642,19 @@ mptctl_gettargetinfo (unsigned long arg)
 	MPT_ADAPTER		*ioc;
 	struct Scsi_Host	*sh;
 	MPT_SCSI_HOST		*hd;
+	VirtDevice		*vdev;
 	char			*pmem;
 	int			*pdata;
+	IOCPage2_t		*pIoc2;
+	IOCPage3_t		*pIoc3;
 	int			iocnum;
 	int			numDevices = 0;
 	unsigned int		max_id;
-	int			ii, jj, lun;
+	int			id, jj, indexed_lun, lun_index;
+	u32			lun;
 	int			maxWordsLeft;
 	int			numBytes;
-	u8			port;
+	u8			port, devType, bus_id;
 
 	dctlprintk(("mptctl_gettargetinfo called.\n"));
 	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_targetinfo))) {
@@ -1368,8 +1666,8 @@ mptctl_gettargetinfo (unsigned long arg)
 
 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
 	    (ioc == NULL)) {
-		dctlprintk((KERN_ERR "%s::mptctl_gettargetinfo() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnum));
+		dctlprintk(("mptctl_gettargetinfo: ioc%d not found!\n",
+				iocnum));
 		return -ENODEV;
 	}
 
@@ -1379,7 +1677,7 @@ mptctl_gettargetinfo (unsigned long arg)
 	 */
 	numBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);
 	maxWordsLeft = numBytes/sizeof(int);
-	port = karg.hdr.port;
+	port = karg.hdr.port & 0x0000ffff;
 
 	if (maxWordsLeft <= 0) {
 		printk(KERN_ERR "%s::mptctl_gettargetinfo() @%d - no memory available!\n",
@@ -1412,7 +1710,7 @@ mptctl_gettargetinfo (unsigned long arg)
 
 	/* Get number of devices
          */
-	if ( (sh = ioc->sh) != NULL) {
+	if ((sh = ioc->sh) != NULL) {
 
 		max_id = sh->max_id - 1;
 		hd = (MPT_SCSI_HOST *) sh->hostdata;
@@ -1423,28 +1721,63 @@ mptctl_gettargetinfo (unsigned long arg)
 		 * sh->max_id = maximum target ID + 1
 		 */
 		if (hd && hd->Targets) {
-			ii = 0;
-			while (ii <= max_id) {
-				if (hd->Targets[ii]) {
+			mpt_findImVolumes(ioc);
+			pIoc2 = ioc->spi_data.pIocPg2;
+			for ( id = 0; id <= max_id; ) {
+				if ( pIoc2 && pIoc2->NumActiveVolumes ) {
+					if ( id == pIoc2->RaidVolume[0].VolumeID ) {
+						if (maxWordsLeft <= 0) {
+							printk(KERN_ERR "mptctl_gettargetinfo - "
+			"buffer is full but volume is available on ioc %d\n, numDevices=%d", iocnum, numDevices);
+							goto data_space_full;
+						}
+						if ( ( pIoc2->RaidVolume[0].Flags & MPI_IOCPAGE2_FLAG_VOLUME_INACTIVE ) == 0 )
+                        				devType = 0x80;
+                    				else
+                        				devType = 0xC0;
+						bus_id = pIoc2->RaidVolume[0].VolumeBus;
+	            				numDevices++;
+                    				*pdata = ( (devType << 24) | (bus_id << 8) | id );
+						dctlprintk(("mptctl_gettargetinfo - "
+		"volume ioc=%d target=%x numDevices=%d pdata=%p\n", iocnum, *pdata, numDevices, pdata));
+                    				pdata++;
+						--maxWordsLeft;
+						goto next_id;
+					} else {
+						pIoc3 = ioc->spi_data.pIocPg3;
+            					for ( jj = 0; jj < pIoc3->NumPhysDisks; jj++ ) {
+                    					if ( pIoc3->PhysDisk[jj].PhysDiskID == id )
+								goto next_id;
+						}
+					}
+				}
+				if ( (vdev = hd->Targets[id]) ) {
 					for (jj = 0; jj <= MPT_LAST_LUN; jj++) {
-						lun = (1 << jj);
-						if (hd->Targets[ii]->luns & lun) {
-							numDevices++;
-							*pdata = (jj << 16) | ii;
-							--maxWordsLeft;
-
-							pdata++;
-
+						lun_index = (jj >> 5);
+						indexed_lun = (jj % 32);
+						lun = (1 << indexed_lun);
+						if (vdev->luns[lun_index] & lun) {
 							if (maxWordsLeft <= 0) {
-								break;
+								printk(KERN_ERR "mptctl_gettargetinfo - "
+			"buffer is full but more targets are available on ioc %d numDevices=%d\n", iocnum, numDevices);
+								goto data_space_full;
 							}
+							bus_id = vdev->bus_id;
+							numDevices++;
+                            				*pdata = ( (jj << 16) | (bus_id << 8) | id );
+							dctlprintk(("mptctl_gettargetinfo - "
+		"target ioc=%d target=%x numDevices=%d pdata=%p\n", iocnum, *pdata, numDevices, pdata));
+							pdata++;
+							--maxWordsLeft;
 						}
 					}
 				}
-				ii++;
+next_id:
+				id++;
 			}
 		}
 	}
+data_space_full:
 	karg.numDevices = numDevices;
 
 	/* Copy part of the data from kernel memory to user memory
@@ -1473,6 +1806,64 @@ mptctl_gettargetinfo (unsigned long arg)
 	return 0;
 }
 
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptctl_hba_pciinfo - Obtain all mpt HBAs pci (Config Space) information.
+ *	@arg: User space argument
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ */
+static int
+mptctl_hba_pciinfo (unsigned long arg)
+{
+	struct mpt_ioctl_hbapciinfo *uarg = (struct mpt_ioctl_hbapciinfo *) arg;
+	struct mpt_ioctl_hbapciinfo karg;
+
+	MPT_ADAPTER	*ioc;
+	int		ioc_num=0, data_size;
+
+	data_size = sizeof(mpt_ioctl_header)+4;
+	/* Clear the struct before filling in data. */
+	memset( &karg, 0, (uarg->hdr.maxDataSize + data_size) );
+
+	dctlprintk((KERN_INFO MYNAM ": Checking for MPT adapters...maxDataSize=%d\n data_size=%d", uarg->hdr.maxDataSize, data_size));
+
+	list_for_each_entry(ioc,&ioc_list,list) {
+		data_size += sizeof (struct mpt_ioctl_mptpciinfo);
+		if ( data_size >= uarg->hdr.maxDataSize ) {
+			dctlprintk((KERN_INFO MYNAM ": data_size=%d >= maxDataSize=%d\n", data_size, uarg->hdr.maxDataSize));
+			break;
+		}
+		karg.hbapciinfo[ioc_num].iocNumber = ioc_num;
+		karg.hbapciinfo[ioc_num].deviceID = ioc->deviceID;
+		karg.hbapciinfo[ioc_num].vendorID = ioc->vendorID;
+		karg.hbapciinfo[ioc_num].subSystemVendorID = ioc->subSystemVendorID;
+		karg.hbapciinfo[ioc_num].subSystemID = ioc->subSystemID;
+		karg.hbapciinfo[ioc_num].revisionID = ioc->revisionID;
+		mpt_GetIocState(ioc, 1);
+		karg.hbapciinfo[ioc_num++].iocState = (ioc->last_state >> MPI_IOC_STATE_SHIFT);
+	}
+
+	karg.totalIOC = ioc_num;
+
+	dctlprintk((KERN_INFO MYNAM ": %d MPT adapters found, arg=%p karg=%p size=%d\n",
+		 karg.totalIOC, (char *)arg, &karg, sizeof(struct mpt_ioctl_hbapciinfo)));
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg, sizeof(struct mpt_ioctl_hbapciinfo))) {
+		printk(KERN_ERR "%s@%d::mptctl_eventquery - "
+			"Unable to write out mpt_ioctl_eventquery struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+	return 0;
+}
+
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /* MPT IOCTL Test function.
  *
@@ -1499,8 +1890,8 @@ mptctl_readtest (unsigned long arg)
 
 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
 	    (ioc == NULL)) {
-		dctlprintk((KERN_ERR "%s::mptctl_readtest() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnum));
+		dctlprintk(("mptctl_readtest: ioc%d not found!\n",
+				iocnum));
 		return -ENODEV;
 	}
 
@@ -1511,10 +1902,12 @@ mptctl_readtest (unsigned long arg)
 #ifdef MFCNT
 	karg.chip_type = ioc->mfcnt;
 #else
-	karg.chip_type = ioc->chip_type;
+	karg.chip_type = ioc->deviceID;
 #endif
 	strncpy (karg.name, ioc->name, MPT_MAX_NAME);
+	karg.name[MPT_MAX_NAME-1]='\0';
 	strncpy (karg.product, ioc->prod_name, MPT_PRODUCT_LENGTH);
+	karg.product[MPT_PRODUCT_LENGTH-1]='\0';
 
 	/* Copy the data from kernel memory to user memory
 	 */
@@ -1557,8 +1950,8 @@ mptctl_eventquery (unsigned long arg)
 
 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
 	    (ioc == NULL)) {
-		dctlprintk((KERN_ERR "%s::mptctl_eventquery() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnum));
+		dctlprintk(("mptctl_eventquery: ioc%d not found!\n",
+				iocnum));
 		return -ENODEV;
 	}
 
@@ -1595,8 +1988,8 @@ mptctl_eventenable (unsigned long arg)
 
 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
 	    (ioc == NULL)) {
-		dctlprintk((KERN_ERR "%s::mptctl_eventenable() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnum));
+		dctlprintk(("mptctl_eventenable: ioc%d not found!\n",
+				iocnum));
 		return -ENODEV;
 	}
 
@@ -1643,8 +2036,8 @@ mptctl_eventreport (unsigned long arg)
 
 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
 	    (ioc == NULL)) {
-		dctlprintk((KERN_ERR "%s::mptctl_eventreport() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnum));
+		dctlprintk(("mptctl_eventreport: ioc%d not found!\n",
+				iocnum));
 		return -ENODEV;
 	}
 
@@ -1680,12 +2073,8 @@ mptctl_replace_fw (unsigned long arg)
 	struct mpt_ioctl_replace_fw	*uarg = (struct mpt_ioctl_replace_fw *) arg;
 	struct mpt_ioctl_replace_fw	 karg;
 	MPT_ADAPTER		 *ioc;
-	fw_image_t		 **fwmem = NULL;
 	int			 iocnum;
 	int			 newFwSize;
-	int			 num_frags, alloc_sz;
-	int			 ii;
-	u32			 offset;
 
 	dctlprintk(("mptctl_replace_fw called.\n"));
 	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_replace_fw))) {
@@ -1697,56 +2086,44 @@ mptctl_replace_fw (unsigned long arg)
 
 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
 	    (ioc == NULL)) {
-		dctlprintk((KERN_ERR "%s::mptctl_replace_fw() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnum));
+		dctlprintk(("mptctl_replace_fw: ioc%d not found!\n",
+				iocnum));
 		return -ENODEV;
 	}
 
-	/* If not caching FW, return 0
+	/* If caching FW, Free the old FW image
 	 */
-	if ((ioc->cached_fw == NULL) && (ioc->alt_ioc) && (ioc->alt_ioc->cached_fw == NULL))
+	if (ioc->cached_fw == NULL)
 		return 0;
 
+	mpt_free_fw_memory(ioc);
+
 	/* Allocate memory for the new FW image
 	 */
 	newFwSize = karg.newImageSize;
-	fwmem = mpt_alloc_fw_memory(ioc, newFwSize, &num_frags, &alloc_sz); 
-	if (fwmem == NULL)
-		return -ENOMEM;
-
-	offset = 0;
-	for (ii = 0; ii < num_frags; ii++) {
-		/* Copy the data from user memory to kernel space
-		 */
-		if (copy_from_user(fwmem[ii]->fw, uarg->newImage + offset, fwmem[ii]->size)) {
-			printk(KERN_ERR "%s@%d::mptctl_replace_fw - "
-				"Unable to read in mpt_ioctl_replace_fw image @ %p\n",
-					__FILE__, __LINE__, (void*)uarg);
-
-			mpt_free_fw_memory(ioc, fwmem);
-			return -EFAULT;
-		}
-		offset += fwmem[ii]->size;
-	}
+	if (newFwSize & 0x01)
+		newFwSize += 1;
+	if (newFwSize & 0x02)
+		newFwSize += 2;
 
+	mpt_alloc_fw_memory(ioc, newFwSize);
+	if (ioc->cached_fw == NULL)
+		return -ENOMEM;
 
-	/* Free the old FW image 
+	/* Copy the data from user memory to kernel space
 	 */
-	if (ioc->cached_fw) {
-		mpt_free_fw_memory(ioc, 0);
-		ioc->cached_fw = fwmem;
-		ioc->alloc_total += alloc_sz;
-	} else if ((ioc->alt_ioc) && (ioc->alt_ioc->cached_fw)) {
-		mpt_free_fw_memory(ioc->alt_ioc, 0);
-		ioc->alt_ioc->cached_fw = fwmem;
-		ioc->alt_ioc->alloc_total += alloc_sz;
+	if (copy_from_user(ioc->cached_fw, uarg->newImage, newFwSize)) {
+		printk(KERN_ERR "%s@%d::mptctl_replace_fw - "
+			"Unable to read in mpt_ioctl_replace_fw image @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+
+		mpt_free_fw_memory(ioc);
+		return -EFAULT;
 	}
 
 	/* Update IOCFactsReply
 	 */
 	ioc->facts.FWImageSize = newFwSize;
-	if (ioc->alt_ioc)
-		ioc->alt_ioc->facts.FWImageSize = newFwSize;
 
 	return 0;
 }
@@ -1783,12 +2160,12 @@ mptctl_mpt_command (unsigned long arg)
 
 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
 	    (ioc == NULL)) {
-		dctlprintk((KERN_ERR "%s::mptctl_mpt_command() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnum));
+		dctlprintk(("mptctl_mpt_command: ioc%d not found!\n",
+				iocnum));
 		return -ENODEV;
 	}
 
-	rc = mptctl_do_mpt_command (karg, (char *) &uarg->MF, 0);
+	rc = mptctl_do_mpt_command (karg, (char *) &uarg->MF);
 
 	return rc;
 }
@@ -1806,35 +2183,35 @@ mptctl_mpt_command (unsigned long arg)
  *		-EPERM if SCSI I/O and target is untagged
  */
 static int
-mptctl_do_mpt_command (struct mpt_ioctl_command karg, char *mfPtr, int local)
+mptctl_do_mpt_command (struct mpt_ioctl_command karg, char *mfPtr)
 {
 	MPT_ADAPTER	*ioc;
-	MPT_FRAME_HDR	*mf = NULL;
+	MPT_FRAME_HDR	*mf=NULL;
+	MPT_FRAME_HDR	*SAS_handshake_mf=NULL;
+	char		*SAS_handshake_reply=NULL;
 	MPIHeader_t	*hdr;
 	char		*psge;
-	MptSge_t	*this_sge = NULL;
-	MptSge_t	*sglbuf = NULL;
 	struct buflist	bufIn;	/* data In buffer */
 	struct buflist	bufOut; /* data Out buffer */
-	dma_addr_t	sglbuf_dma;
-	dma_addr_t	dma_addr;
-	int		dir;	/* PCI data direction */
+	dma_addr_t	dma_addr_in;
+	dma_addr_t	dma_addr_out;
 	int		sgSize = 0;	/* Num SG elements */
-	int		this_alloc;
-	int		 iocnum, flagsLength;
-	int		 sz, rc = 0;
-	int		 msgContext;
+	int		iocnum, flagsLength;
+	int		sz, rc = 0;
+	int		msgContext;
 	int		tm_flags_set = 0;
-	u16		req_idx;
+	u16		req_idx=0, msgSize=0;
+  	FWDownloadReply_t FWDownloadReply;
 
-	dctlprintk(("mptctl_do_mpt_command called.\n"));
+	bufIn.kptr = bufOut.kptr = NULL;
 
 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
 	    (ioc == NULL)) {
-		dctlprintk((KERN_ERR "%s::mptctl_do_mpt_command() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnum));
+		dctlprintk(("mptctl_do_mpt_command: ioc%d not found!\n",
+				iocnum));
 		return -ENODEV;
 	}
+	dctlprintk((KERN_WARNING "mptctl_do_mpt_command called iocnum=%d ioc=%p.\n", karg.hdr.iocnum, ioc));
 	if (!ioc->ioctl) {
 		printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
 			"No memory available during driver init.\n",
@@ -1854,7 +2231,7 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 	if (karg.dataOutSize > 0)
 		sz += sizeof(dma_addr_t) + sizeof(u32);
 
-	if ( sz > ioc->req_sz) {
+	if (sz > ioc->req_sz) {
 		printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
 			"Request frame too large (%d) maximum (%d)\n",
 				__FILE__, __LINE__, sz, ioc->req_sz);
@@ -1863,46 +2240,58 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 
 	/* Get a free request frame and save the message context.
 	 */
-        if ((mf = mpt_get_msg_frame(mptctl_id, ioc->id)) == NULL)
-                return -EAGAIN;
-
-	hdr = (MPIHeader_t *) mf;
-	msgContext = le32_to_cpu(hdr->MsgContext);
-	req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
-
-	/* Copy the request frame
+        if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL) {
+		if (((MPIHeader_t *)(mfPtr))->MsgContext == 0x02012020) {
+			msgSize = karg.hdr.port >> 16;
+			SAS_handshake_mf = mf = 
+				(MPT_FRAME_HDR *)kmalloc(msgSize, GFP_KERNEL);
+			if (karg.maxReplyBytes)
+				SAS_handshake_reply = (char *)kmalloc(karg.maxReplyBytes, GFP_KERNEL);
+			hdr = (MPIHeader_t *) mf;
+			msgContext = le32_to_cpu(0x02012020);
+			karg.hdr.port &= 0x0000ffff;
+		} else {
+			dfailprintk(("%s: mptctl_do_mpt_command, no msg frames!!\n",
+				ioc->name));
+                	return -EAGAIN;
+		}
+	} else {
+		hdr = (MPIHeader_t *) mf;
+		msgContext = le32_to_cpu(hdr->MsgContext);
+		req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
+	}
+
+	/* Copy the request frame
 	 * Reset the saved message context.
 	 */
-        if (local) {
-		/* Request frame in kernel space
-		 */
-		memcpy((char *)mf, (char *) mfPtr, karg.dataSgeOffset * 4);
-        } else {
-		/* Request frame in user space
-		 */
-		if (copy_from_user((char *)mf, (char *) mfPtr,
-					karg.dataSgeOffset * 4)){
-			printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
-				"Unable to read MF from mpt_ioctl_command struct @ %p\n",
-				__FILE__, __LINE__, (void*)mfPtr);
-			rc = -EFAULT;
-			goto done_free_mem;
-		}
-        }
+	if (copy_from_user(mf, mfPtr, karg.dataSgeOffset * 4)) {
+		printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+			"Unable to read MF from mpt_ioctl_command struct @ %p\n",
+			__FILE__, __LINE__, mfPtr);
+		rc = -EFAULT;
+		goto done_free_mem;
+	}
 	hdr->MsgContext = cpu_to_le32(msgContext);
 
+	dctlprintk(("mptctl_do_mpt_command Function=%x\n", hdr->Function));
 
 	/* Verify that this request is allowed.
 	 */
 	switch (hdr->Function) {
 	case MPI_FUNCTION_IOC_FACTS:
 	case MPI_FUNCTION_PORT_FACTS:
+		karg.dataOutSize  = karg.dataInSize = 0;
+		break;
+
 	case MPI_FUNCTION_CONFIG:
 	case MPI_FUNCTION_FC_COMMON_TRANSPORT_SEND:
 	case MPI_FUNCTION_FC_EX_LINK_SRVC_SEND:
 	case MPI_FUNCTION_FW_UPLOAD:
 	case MPI_FUNCTION_SCSI_ENCLOSURE_PROCESSOR:
 	case MPI_FUNCTION_FW_DOWNLOAD:
+	case MPI_FUNCTION_FC_PRIMITIVE_SEND:
+	case MPI_FUNCTION_TOOLBOX:
+	case MPI_FUNCTION_SAS_IO_UNIT_CONTROL:
 		break;
 
 	case MPI_FUNCTION_SCSI_IO_REQUEST:
@@ -1923,22 +2312,25 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 				goto done_free_mem;
 			}
 
-			pScsiReq->MsgFlags = mpt_msg_flags();
+			pScsiReq->MsgFlags &= ~MPI_SCSIIO_MSGFLGS_SENSE_WIDTH;
+			pScsiReq->MsgFlags |= mpt_msg_flags();
 
 			/* verify that app has not requested
-			 *	more sense data than driver
-			 *	can provide, if so, reset this parameter
+			 * more sense data than driver
+			 * can provide, if so, reset this parameter
 			 * set the sense buffer pointer low address
 			 * update the control field to specify Q type
 			 */
 			if (karg.maxSenseBytes > MPT_SENSE_BUFFER_SIZE)
 				pScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;
+			else
+				pScsiReq->SenseBufferLength = karg.maxSenseBytes;
 
 			pScsiReq->SenseBufferLowAddr =
 				cpu_to_le32(ioc->sense_buf_low_dma
 				   + (req_idx * MPT_SENSE_BUFFER_ALLOC));
 
-			if ( (hd = (MPT_SCSI_HOST *) ioc->sh->hostdata)) {
+			if ((hd = (MPT_SCSI_HOST *) ioc->sh->hostdata)) {
 				if (hd->Targets)
 					pTarget = hd->Targets[target];
 			}
@@ -1949,11 +2341,10 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 			/* Have the IOCTL driver set the direction based
 			 * on the dataOutSize (ordering issue with Sparc).
 			 */
-			if (karg.dataOutSize > 0 ) {
+			if (karg.dataOutSize > 0) {
 				scsidir = MPI_SCSIIO_CONTROL_WRITE;
 				dataSize = karg.dataOutSize;
-			}
-			else {
+			} else {
 				scsidir = MPI_SCSIIO_CONTROL_READ;
 				dataSize = karg.dataInSize;
 			}
@@ -1973,6 +2364,25 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 		}
 		break;
 
+	case MPI_FUNCTION_SMP_PASSTHROUGH:
+		/* Check mf->PassthruFlags to determine if
+		 * transfer is ImmediateMode or not.
+		 * Immediate mode returns data in the ReplyFrame.
+		 * Else, we are sending request and response data
+		 * in two SGLs at the end of the mf.
+		 */
+		break;
+
+	case MPI_FUNCTION_SATA_PASSTHROUGH:
+		if (!ioc->sh) {
+			printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+				"SCSI driver is not loaded. \n",
+					__FILE__, __LINE__);
+			rc = -EFAULT;
+			goto done_free_mem;
+		}
+		break;
+
 	case MPI_FUNCTION_RAID_ACTION:
 		/* Just add a SGE
 		 */
@@ -1984,8 +2394,9 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 			int qtag = MPI_SCSIIO_CONTROL_SIMPLEQ;
 			int scsidir = MPI_SCSIIO_CONTROL_READ;
 			int dataSize;
-
-			pScsiReq->MsgFlags = mpt_msg_flags();
+			
+			pScsiReq->MsgFlags &= ~MPI_SCSIIO_MSGFLGS_SENSE_WIDTH;
+			pScsiReq->MsgFlags |= mpt_msg_flags();
 
 			/* verify that app has not requested
 			 *	more sense data than driver
@@ -1995,6 +2406,8 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 			 */
 			if (karg.maxSenseBytes > MPT_SENSE_BUFFER_SIZE)
 				pScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;
+			else
+				pScsiReq->SenseBufferLength = karg.maxSenseBytes;
 
 			pScsiReq->SenseBufferLowAddr =
 				cpu_to_le32(ioc->sense_buf_low_dma
@@ -2006,11 +2419,10 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 			/* Have the IOCTL driver set the direction based
 			 * on the dataOutSize (ordering issue with Sparc).
 			 */
-			if (karg.dataOutSize > 0 ) {
+			if (karg.dataOutSize > 0) {
 				scsidir = MPI_SCSIIO_CONTROL_WRITE;
 				dataSize = karg.dataOutSize;
-			}
-			else {
+			} else {
 				scsidir = MPI_SCSIIO_CONTROL_READ;
 				dataSize = karg.dataInSize;
 			}
@@ -2030,7 +2442,7 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 		break;
 
 	case MPI_FUNCTION_SCSI_TASK_MGMT:
-		{ 
+		{
 			MPT_SCSI_HOST *hd = NULL;
 			if ((ioc->sh == NULL) || ((hd = (MPT_SCSI_HOST *)ioc->sh->hostdata) == NULL)) {
 				printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
@@ -2038,7 +2450,7 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 					__FILE__, __LINE__);
 				rc = -EFAULT;
 				goto done_free_mem;
-			}  else if (mptctl_set_tm_flags(hd) != 0) {
+			} else if (mptctl_set_tm_flags(hd) != 0) {
 				rc = -EPERM;
 				goto done_free_mem;
 			}
@@ -2062,17 +2474,24 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 				sense_high= 0;
 			}
 
-			if ((pInit->Flags != 0) || (pInit->MaxDevices != ioc->facts.MaxDevices) ||
-				(pInit->MaxBuses != ioc->facts.MaxBuses) || 
+/*			if ((pInit->Flags != 0) || (pInit->MaxDevices != ioc->facts.MaxDevices) ||
+				(pInit->MaxBuses != ioc->facts.MaxBuses) ||
 				(pInit->ReplyFrameSize != cpu_to_le16(ioc->reply_sz)) ||
 				(pInit->HostMfaHighAddr != high_addr) ||
 				(pInit->SenseBufferHighAddr != sense_high)) {
 				printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
 					"IOC_INIT issued with 1 or more incorrect parameters. Rejected.\n",
 					__FILE__, __LINE__);
+				printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+					"pInit Flags=%x MaxDevices=%d MaxBuses=%d ReplyFrameSize=%x HostMfaHighAddr=%x SenseBufferHighAddr=%x\n",
+					__FILE__, __LINE__, pInit->Flags, pInit->MaxDevices, pInit->MaxBuses, pInit->ReplyFrameSize, pInit->HostMfaHighAddr, pInit->SenseBufferHighAddr);
+				printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+					"ioc MaxDevices=%d MaxBuses=%d reply_sz=%x high_addr=%x sense_high=%x\n",
+					__FILE__, __LINE__, 
+ioc->facts.MaxDevices, ioc->facts.MaxBuses, ioc->reply_sz, high_addr, sense_high);
 				rc = -EFAULT;
 				goto done_free_mem;
-			}
+			} */
 		}
 		break;
 	default:
@@ -2095,7 +2514,6 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 			MPI_FUNCTION_FC_LINK_SRVC_BUF_POST
 			MPI_FUNCTION_FC_LINK_SRVC_RSP
 			MPI_FUNCTION_FC_ABORT
-			MPI_FUNCTION_FC_PRIMITIVE_SEND
 			MPI_FUNCTION_LAN_SEND
 			MPI_FUNCTION_LAN_RECEIVE
 		 	MPI_FUNCTION_LAN_RESET
@@ -2113,7 +2531,8 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 	 * preceede the data in (read) SGE. psgList is used to free the
 	 * allocated memory.
 	 */
-	psge = (char *) ( ((int *) mf) + karg.dataSgeOffset);
+	psge = (char *) (((int *) mf) + karg.dataSgeOffset);
+	dctlprintk(("mptctl_do_mpt_command mf=%p psge=%p\n", mf, psge));
 	flagsLength = 0;
 
 	/* bufIn and bufOut are used for user to kernel space transfers
@@ -2121,31 +2540,19 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 	bufIn.kptr = bufOut.kptr = NULL;
 	bufIn.len = bufOut.len = 0;
 
-	if (karg.dataOutSize > 0 )
+	if (karg.dataOutSize > 0)
 		sgSize ++;
 
-	if (karg.dataInSize > 0 )
+	if (karg.dataInSize > 0)
 		sgSize ++;
 
 	if (sgSize > 0) {
 
-		/* Allocate memory for the SGL.
-		 * Used to free kernel memory once
-		 * the MF is freed.
-		 */
-		sglbuf = pci_alloc_consistent (ioc->pcidev,
-			sgSize*sizeof(MptSge_t), &sglbuf_dma);
-		if (sglbuf == NULL) {
-			rc = -ENOMEM;
-			goto done_free_mem;
-		}
-		this_sge = sglbuf;
-
 		/* Set up the dataOut memory allocation */
 		if (karg.dataOutSize > 0) {
-			dir = PCI_DMA_TODEVICE;
-			if (karg.dataInSize > 0 ) {
+			if (karg.dataInSize > 0) {
 				flagsLength = ( MPI_SGE_FLAGS_SIMPLE_ELEMENT |
+						MPI_SGE_FLAGS_END_OF_BUFFER |
 						MPI_SGE_FLAGS_DIRECTION |
 						mpt_addr_size() )
 						<< MPI_SGE_FLAGS_SHIFT;
@@ -2153,22 +2560,25 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 				flagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE;
 			}
 			flagsLength |= karg.dataOutSize;
-
-			this_alloc = karg.dataOutSize;
-			bufOut.len = this_alloc;
+			bufOut.len = karg.dataOutSize;
 			bufOut.kptr = pci_alloc_consistent(
-					ioc->pcidev, this_alloc, &dma_addr);
+					ioc->pcidev, bufOut.len, &dma_addr_out);
 
 			if (bufOut.kptr == NULL) {
 				rc = -ENOMEM;
 				goto done_free_mem;
 			} else {
+				/* Set up this SGE.
+				 * Copy to MF and to sglbuf
+				 */
+				mpt_add_sge(psge, flagsLength, dma_addr_out);
+				psge += (sizeof(u32) + sizeof(dma_addr_t));
+
 				/* Copy user data to kernel space.
 				 */
 				if (copy_from_user(bufOut.kptr,
 						karg.dataOutBufPtr,
 						bufOut.len)) {
-
 					printk(KERN_ERR
 						"%s@%d::mptctl_do_mpt_command - Unable "
 						"to read user data "
@@ -2177,28 +2587,26 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 					rc =  -EFAULT;
 					goto done_free_mem;
 				}
-
-				/* Set up this SGE.
-				 * Copy to MF and to sglbuf
-				 */
-				mpt_add_sge(psge, flagsLength, dma_addr);
-				psge += (sizeof(u32) + sizeof(dma_addr_t));
-
-				this_sge->FlagsLength = flagsLength;
-				this_sge->Address = dma_addr;
-				this_sge++;
 			}
 		}
 
 		if (karg.dataInSize > 0) {
-			dir = PCI_DMA_FROMDEVICE;
-			flagsLength = MPT_SGE_FLAGS_SSIMPLE_READ;
+			if ((karg.dataOutSize > 0) &&
+			    (hdr->Function == MPI_FUNCTION_SMP_PASSTHROUGH)){
+				flagsLength = ( MPI_SGE_FLAGS_SIMPLE_ELEMENT |
+						MPI_SGE_FLAGS_END_OF_BUFFER |
+						MPI_SGE_FLAGS_DIRECTION |
+						mpt_addr_size() )
+						<< MPI_SGE_FLAGS_SHIFT;
+			} else {
+				flagsLength = MPT_SGE_FLAGS_SSIMPLE_READ;
+			}
 			flagsLength |= karg.dataInSize;
 
-			this_alloc = karg.dataInSize;
-			bufIn.len = this_alloc;
+			bufIn.len = karg.dataInSize;
 			bufIn.kptr = pci_alloc_consistent(ioc->pcidev,
-							this_alloc, &dma_addr);
+					bufIn.len, &dma_addr_in);
+
 			if (bufIn.kptr == NULL) {
 				rc = -ENOMEM;
 				goto done_free_mem;
@@ -2206,11 +2614,7 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 				/* Set up this SGE
 				 * Copy to MF and to sglbuf
 				 */
-				mpt_add_sge(psge, flagsLength, dma_addr);
-
-				this_sge->FlagsLength = flagsLength;
-				this_sge->Address = dma_addr;
-				this_sge++;
+				mpt_add_sge(psge, flagsLength, dma_addr_in);
 			}
 		}
 	} else  {
@@ -2233,8 +2637,9 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 	add_timer(&ioc->ioctl->timer);
 
 	if (hdr->Function == MPI_FUNCTION_SCSI_TASK_MGMT) {
-		rc = mpt_send_handshake_request(mptctl_id, ioc->id,
-				sizeof(SCSITaskMgmt_t), (u32*)mf, NO_SLEEP);
+		DBG_DUMP_TM_REQUEST_FRAME((u32*)mf);
+		rc = mpt_send_handshake_request(mptctl_id, ioc,
+				sizeof(SCSITaskMgmt_t), (u32*)mf, CAN_SLEEP);
 		if (rc == 0) {
 			wait_event(mptctl_wait, ioc->ioctl->wait_done);
 		} else {
@@ -2242,53 +2647,84 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 			tm_flags_set= 0;
 			del_timer(&ioc->ioctl->timer);
 			ioc->ioctl->status &= ~MPT_IOCTL_STATUS_TIMER_ACTIVE;
-			ioc->ioctl->status = MPT_IOCTL_STATUS_TM_FAILED;
+			ioc->ioctl->status |= MPT_IOCTL_STATUS_TM_FAILED;
+			mpt_free_msg_frame(ioc, mf);
 		}
 	} else {
-		mpt_put_msg_frame(mptctl_id, ioc->id, mf);
-		wait_event(mptctl_wait, ioc->ioctl->wait_done);
+		if ( SAS_handshake_mf ) {
+			dctlprintk(("SAS_handshake_message Function=%x\n",
+				hdr->Function));
+			rc = mpt_handshake_req_reply_wait(ioc,
+				msgSize, 
+				(u32*)SAS_handshake_mf,
+				karg.maxReplyBytes, 
+				(u16*)SAS_handshake_reply, 30 /*seconds*/, 
+				CAN_SLEEP);
+			kfree(SAS_handshake_mf);
+			SAS_handshake_mf = NULL;
+			if (rc == 0) {
+				dctlprintk(("SAS_handshake_message completed\n"));
+				sz = karg.maxReplyBytes;
+
+				if (sz > 0) {
+					if (copy_to_user((char *)karg.replyFrameBufPtr,
+						 SAS_handshake_reply, sz)){
+
+					 	printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+					 	"Unable to write out reply frame %p\n",
+					 	__FILE__, __LINE__, (void*)karg.replyFrameBufPtr);
+						rc =  -ENODATA;
+					}
+					kfree(SAS_handshake_reply);
+					SAS_handshake_reply = NULL;
+				} else {
+					dctlprintk(("SAS_handshake_message failed\n"));
+				}
+				del_timer(&ioc->ioctl->timer);
+				ioc->ioctl->status &= ~MPT_IOCTL_STATUS_TIMER_ACTIVE;
+				return rc;
+			}
+		} else {
+			mpt_put_msg_frame(mptctl_id, ioc, mf);
+			wait_event(mptctl_wait, ioc->ioctl->wait_done);
+		}
 	}
 
-	/* The command is complete.  * Return data to the user.
+	mf = NULL;
+
+	/* MF Cleanup:
+	 * If command failed and failure triggered a diagnostic reset
+	 * OR a diagnostic reset happens during command processing,
+	 * no data, messaging queues are reset (mf cannot be accessed),
+	 * and status is DID_IOCRESET
 	 *
-	 * If command completed,  mf has been freed so cannot
-	 * use this memory.
+	 * If a user-requested bus reset fails to be handshaked, then
+	 * mf is returned to free queue and status is TM_FAILED.
 	 *
-	 * If timeout, a recovery  mechanism has been called.
-	 * Need to free the mf.
+	 * Otherise, the command completed and the mf was freed
+	 # by ISR (mf cannot be touched).
 	 */
 	if (ioc->ioctl->status & MPT_IOCTL_STATUS_DID_IOCRESET) {
-
-		/* A timeout - there is no data to return to the
-		 * the user other than an error.
-		 * The timer callback deleted the
+		/* The timer callback deleted the
 		 * timer and reset the adapter queues.
 		 */
 		printk(KERN_WARNING "%s@%d::mptctl_do_mpt_command - "
 			"Timeout Occurred on IOCTL! Reset IOC.\n", __FILE__, __LINE__);
 		tm_flags_set= 0;
 		rc = -ETIME;
-
-		/* Free memory and return to the calling function
-		 */
-		goto done_free_mem;
 	} else if (ioc->ioctl->status & MPT_IOCTL_STATUS_TM_FAILED) {
-		/* User TM request failed!
+		/* User TM request failed! mf has not been freed.
 		 */
 		rc = -ENODATA;
 	} else {
-		/* Callback freed request frame.
-		 */
-		mf = NULL;
-
 		/* If a valid reply frame, copy to the user.
 		 * Offset 2: reply length in U32's
 		 */
 		if (ioc->ioctl->status & MPT_IOCTL_STATUS_RF_VALID) {
 			if (karg.maxReplyBytes < ioc->reply_sz) {
-				 sz = MIN(karg.maxReplyBytes, 4*ioc->ioctl->ReplyFrame[2]);
+				 sz = min(karg.maxReplyBytes, 4*ioc->ioctl->ReplyFrame[2]);
 			} else {
-				 sz = MIN(ioc->reply_sz, 4*ioc->ioctl->ReplyFrame[2]);
+				 sz = min(ioc->reply_sz, 4*ioc->ioctl->ReplyFrame[2]);
 			}
 
 			if (sz > 0) {
@@ -2307,7 +2743,7 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 		/* If valid sense data, copy to user.
 		 */
 		if (ioc->ioctl->status & MPT_IOCTL_STATUS_SENSE_VALID) {
-			sz = MIN(karg.maxSenseBytes, MPT_SENSE_BUFFER_SIZE);
+			sz = min(karg.maxSenseBytes, MPT_SENSE_BUFFER_SIZE);
 			if (sz > 0) {
 				if (copy_to_user((char *)karg.senseDataPtr, ioc->ioctl->sense, sz)) {
 					printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
@@ -2338,45 +2774,41 @@ mptctl_do_mpt_command (struct mpt_ioctl_
 	}
 
 done_free_mem:
-	/* Clear status bits.
-	 */
-	ioc->ioctl->status = 0;
+	/* Clear all status bits except TMTIMER_ACTIVE, this bit is cleared
+	 * upon completion of the TM command.
+	 * ioc->ioctl->status = 0;
+	 */
+	ioc->ioctl->status &= ~(MPT_IOCTL_STATUS_TIMER_ACTIVE | MPT_IOCTL_STATUS_TM_FAILED |
+			MPT_IOCTL_STATUS_COMMAND_GOOD | MPT_IOCTL_STATUS_SENSE_VALID |
+			MPT_IOCTL_STATUS_RF_VALID | MPT_IOCTL_STATUS_DID_IOCRESET);
 
 	if (tm_flags_set)
 		mptctl_free_tm_flags(ioc);
 
-	if (sglbuf) {
-		this_sge = sglbuf;
-
-		/* Free the allocated memory.
-		 */
-		 if (bufOut.kptr != NULL ) {
-			dma_addr = this_sge->Address;
-			this_sge++;	/* go to next structure */
-			this_alloc = bufOut.len;
-			pci_free_consistent(ioc->pcidev,
-				this_alloc, (void *) bufOut.kptr, dma_addr);
-		}
-
-		if (bufIn.kptr != NULL ) {
-			dma_addr = this_sge->Address;
-			this_alloc = bufIn.len;
-
-			pci_free_consistent(ioc->pcidev,
-					this_alloc, (void *) bufIn.kptr, dma_addr);
-		}
+	/* Free the allocated memory.
+	 */
+	 if (bufOut.kptr != NULL) {
+		pci_free_consistent(ioc->pcidev,
+			bufOut.len, (void *) bufOut.kptr, dma_addr_out);
+	}
 
-		this_alloc = sgSize * sizeof(MptSge_t);
+	if (bufIn.kptr != NULL) {
 		pci_free_consistent(ioc->pcidev,
-				this_alloc, (void *) sglbuf, sglbuf_dma);
+			bufIn.len, (void *) bufIn.kptr, dma_addr_in);
+	}
 
+	if (SAS_handshake_mf) {
+		kfree(SAS_handshake_mf);
+		mf=NULL;
 	}
+	if (SAS_handshake_reply)
+		kfree(SAS_handshake_reply);
 
-	/* mf will be null if allocation failed OR
-	 * if command completed OK (callback freed)
+	/* mf is null if command issued successfully
+	 * otherwise, failure occured after mf acquired.
 	 */
 	if (mf)
-		mpt_free_msg_frame(mptctl_id, ioc->id, mf);
+		mpt_free_msg_frame(ioc, mf);
 
 	return rc;
 }
@@ -2393,7 +2825,7 @@ done_free_mem:
  *		-ENOMEM if memory allocation error
  */
 static int
-mptctl_hp_hostinfo(unsigned long arg)
+mptctl_hp_hostinfo(unsigned long arg, unsigned int data_size)
 {
 	hp_host_info_t	*uarg = (hp_host_info_t *) arg;
 	MPT_ADAPTER		*ioc;
@@ -2404,9 +2836,18 @@ mptctl_hp_hostinfo(unsigned long arg)
 	CONFIGPARMS		cfg;
 	ConfigPageHeader_t	hdr;
 	int			iocnum;
-	int			rc;
+	int			rc, cim_rev;
+
+	dctlprintk(("mptctl_hp_hostinfo called.\n"));
+	/* Reset long to int. Should affect IA64 and SPARC only
+	 */
+	if (data_size == sizeof(hp_host_info_t))
+		cim_rev = 1;
+	else if (data_size == sizeof(hp_host_info_rev0_t))
+		cim_rev = 0; /* obsolete */
+	else
+		return -EFAULT;
 
-	dctlprintk((": mptctl_hp_hostinfo called.\n"));
 	if (copy_from_user(&karg, uarg, sizeof(hp_host_info_t))) {
 		printk(KERN_ERR "%s@%d::mptctl_hp_host_info - "
 			"Unable to read in hp_host_info struct @ %p\n",
@@ -2416,15 +2857,15 @@ mptctl_hp_hostinfo(unsigned long arg)
 
 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
 	    (ioc == NULL)) {
-		dctlprintk((KERN_ERR "%s::mptctl_hp_hostinfo() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnum));
+		dctlprintk(("mptctl_hp_hostinfo: ioc%d not found!\n",
+				iocnum));
 		return -ENODEV;
 	}
 
 	/* Fill in the data and return the structure to the calling
 	 * program
 	 */
-	pdev = (struct pci_dev *) ioc->pcidev;
+	pdev = ioc->pcidev;
 
 	karg.vendor = pdev->vendor;
 	karg.device = pdev->device;
@@ -2436,7 +2877,7 @@ mptctl_hp_hostinfo(unsigned long arg)
 	karg.bus = pdev->bus->number;
 
 	/* Save the SCSI host no. if
-	 * SCSI driver loaded 
+	 * SCSI driver loaded
 	 */
 	if (ioc->sh != NULL)
 		karg.host_no = ioc->sh->host_no;
@@ -2468,7 +2909,7 @@ mptctl_hp_hostinfo(unsigned long arg)
 	hdr.PageLength = 0;
 	hdr.PageNumber = 0;
 	hdr.PageType = MPI_CONFIG_PAGETYPE_MANUFACTURING;
-	cfg.hdr = &hdr;
+	cfg.cfghdr.hdr = &hdr;
 	cfg.physAddr = -1;
 	cfg.pageAddr = 0;
 	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
@@ -2477,7 +2918,7 @@ mptctl_hp_hostinfo(unsigned long arg)
 
 	strncpy(karg.serial_number, " ", 24);
 	if (mpt_config(ioc, &cfg) == 0) {
-		if (cfg.hdr->PageLength > 0) {
+		if (cfg.cfghdr.hdr->PageLength > 0) {
 			/* Issue the second config page request */
 			cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
 
@@ -2486,8 +2927,10 @@ mptctl_hp_hostinfo(unsigned long arg)
 				cfg.physAddr = buf_dma;
 				if (mpt_config(ioc, &cfg) == 0) {
 					ManufacturingPage0_t *pdata = (ManufacturingPage0_t *) pbuf;
-					if (strlen(pdata->BoardTracerNumber) > 1)
+					if (strlen(pdata->BoardTracerNumber) > 1) {
 						strncpy(karg.serial_number, pdata->BoardTracerNumber, 24);
+						karg.serial_number[24-1]='\0';
+					}
 				}
 				pci_free_consistent(ioc->pcidev, hdr.PageLength * 4, pbuf, buf_dma);
 				pbuf = NULL;
@@ -2513,10 +2956,10 @@ mptctl_hp_hostinfo(unsigned long arg)
 
 	karg.base_io_addr = pdev->PCI_BASEADDR_START(0);
 
-	if ((int)ioc->chip_type <= (int) FC929)
-		karg.bus_phys_width = HP_BUS_WIDTH_UNK;
-	else
+	if (ioc->bus_type == SCSI)
 		karg.bus_phys_width = HP_BUS_WIDTH_16;
+	else
+		karg.bus_phys_width = HP_BUS_WIDTH_UNK;
 
 	karg.hard_resets = 0;
 	karg.soft_resets = 0;
@@ -2524,13 +2967,27 @@ mptctl_hp_hostinfo(unsigned long arg)
 	if (ioc->sh != NULL) {
 		MPT_SCSI_HOST *hd =  (MPT_SCSI_HOST *)ioc->sh->hostdata;
 
-		if (hd) {
+		if (hd && (cim_rev == 1)) {
 			karg.hard_resets = hd->hard_resets;
 			karg.soft_resets = hd->soft_resets;
 			karg.timeouts = hd->timeouts;
 		}
 	}
 
+	cfg.pageAddr = 0;
+	cfg.action = MPI_TOOLBOX_ISTWI_READ_WRITE_TOOL;
+	cfg.dir = MPI_TB_ISTWI_FLAGS_READ;
+	cfg.timeout = 10;
+	pbuf = pci_alloc_consistent(ioc->pcidev, 4, &buf_dma);
+	if (pbuf) {
+		cfg.physAddr = buf_dma;
+		if ((mpt_toolbox(ioc, &cfg)) == 0) {
+			karg.rsvd = *(u32 *)pbuf;
+		}
+		pci_free_consistent(ioc->pcidev, 4, pbuf, buf_dma);
+		pbuf = NULL;
+	}
+
 	/* Copy the data from kernel memory to user memory
 	 */
 	if (copy_to_user((char *)arg, &karg,
@@ -2572,24 +3029,24 @@ mptctl_hp_targetinfo(unsigned long arg)
 	ConfigPageHeader_t	hdr;
 	int			tmp, np, rc = 0;
 
-	dctlprintk((": mptctl_hp_targetinfo called.\n"));
+	dctlprintk(("mptctl_hp_targetinfo called.\n"));
 	if (copy_from_user(&karg, uarg, sizeof(hp_target_info_t))) {
 		printk(KERN_ERR "%s@%d::mptctl_hp_targetinfo - "
 			"Unable to read in hp_host_targetinfo struct @ %p\n",
 				__FILE__, __LINE__, (void*)uarg);
 		return -EFAULT;
 	}
-	
+
 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
 		(ioc == NULL)) {
-		dctlprintk((KERN_ERR "%s::mptctl_hp_targetinfo() @%d - ioc%d not found!\n",
-				__FILE__, __LINE__, iocnum));
+		dctlprintk(("mptctl_hp_targetinfo - ioc%d not found!\n",
+				iocnum));
 		return -ENODEV;
 	}
 
-	/*  There is nothing to do for FCP parts.
+	/*  There is nothing to do for FC or SAS parts.
 	 */
-	if ((int) ioc->chip_type <= (int) FC929)
+	if (ioc->bus_type != SCSI)
 		return 0;
 
 	if ((ioc->spi_data.sdp0length == 0) || (ioc->sh == NULL))
@@ -2597,7 +3054,7 @@ mptctl_hp_targetinfo(unsigned long arg)
 
 	if (ioc->sh->host_no != karg.hdr.host)
 		return -ENODEV;
-		
+
        /* Get the data transfer speeds
         */
 	data_sz = ioc->spi_data.sdp0length * 4;
@@ -2608,7 +3065,7 @@ mptctl_hp_targetinfo(unsigned long arg)
 		hdr.PageNumber = 0;
 		hdr.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;
 
-		cfg.hdr = &hdr;
+		cfg.cfghdr.hdr = &hdr;
 		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
 		cfg.dir = 0;
 		cfg.timeout = 0;
@@ -2618,7 +3075,7 @@ mptctl_hp_targetinfo(unsigned long arg)
 
 		if ((rc = mpt_config(ioc, &cfg)) == 0) {
 			np = le32_to_cpu(pg0_alloc->NegotiatedParameters);
-			karg.negotiated_width = np & MPI_SCSIDEVPAGE0_NP_WIDE ? 
+			karg.negotiated_width = np & MPI_SCSIDEVPAGE0_NP_WIDE ?
 					HP_BUS_WIDTH_16 : HP_BUS_WIDTH_8;
 
 			if (np & MPI_SCSIDEVPAGE0_NP_NEG_SYNC_OFFSET_MASK) {
@@ -2656,15 +3113,15 @@ mptctl_hp_targetinfo(unsigned long arg)
 	hdr.PageNumber = 3;
 	hdr.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;
 
-	cfg.hdr = &hdr;
+	cfg.cfghdr.hdr = &hdr;
 	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
 	cfg.dir = 0;
 	cfg.timeout = 0;
 	cfg.physAddr = -1;
-	if ((mpt_config(ioc, &cfg) == 0) && (cfg.hdr->PageLength > 0)) {
+	if ((mpt_config(ioc, &cfg) == 0) && (cfg.cfghdr.hdr->PageLength > 0)) {
 		/* Issue the second config page request */
 		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
-		data_sz = (int) cfg.hdr->PageLength * 4;
+		data_sz = (int) cfg.cfghdr.hdr->PageLength * 4;
 		pg3_alloc = (SCSIDevicePage3_t *) pci_alloc_consistent(
 							ioc->pcidev, data_sz, &page_dma);
 		if (pg3_alloc) {
@@ -2695,21 +3152,653 @@ mptctl_hp_targetinfo(unsigned long arg)
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* REGISTER DIAG BUFFER Routine.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-ENODEV if no such device/adapter
+ *		-ETIME	if timer expires
+ *		-ENOMEM if memory allocation error
+ */
+static int
+mptctl_register_diag_buffer (unsigned long arg)
+{
+	mpt_diag_register_t	*uarg = (mpt_diag_register_t *) arg;
+	mpt_diag_register_t	karg;
+	MPT_ADAPTER		*ioc;
+	int			iocnum, rc=0, ii;
+	void *			request_data;
+	dma_addr_t		request_data_dma;
+	u32			request_data_sz;
+	MPT_FRAME_HDR		*mf;
+  	DiagBufferPostRequest_t *DiagBufferPostRequest;
+  	DiagBufferPostReply_t	*DiagBufferPostReply;
+	u32 			tmp;
+	u8			buffType;
+
+	dctlprintk(("mptctl_register_diag_buffer called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(mpt_diag_register_t))) {
+		printk(KERN_ERR "mptctl_register_diag_buffer: "
+			"Unable to read mpt_diag_register_t data @ %p\n",
+				(void*)uarg);
+		return -EFAULT;
+	}
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,51)
-#define	owner_THIS_MODULE  owner:		THIS_MODULE,
-#else
-#define	owner_THIS_MODULE
-#endif
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+		(ioc == NULL)) {
+		dctlprintk(("mptctl_register_diag_buffer: ioc%d not found!\n",
+				iocnum));
+		return -ENODEV;
+	}
+
+	buffType = karg.data.BufferType;
+	if ( !(ioc->facts.IOCCapabilities & 
+		MPT_DIAG_CAPABILITY(buffType)) ) {
+		printk("mptctl_register_diag_buffer: ioc%d does not have Capability for BufferType=%x\n",
+				iocnum, buffType);
+		return -ENODEV;
+	}
+
+	if ( ioc->DiagBuffer_Status[buffType] & MPT_DIAG_BUFFER_IS_REGISTERED ) {
+		printk("mptctl_register_diag_buffer: ioc%d already has a Registered buffer for BufferType=%x\n",
+			iocnum, buffType);
+		return -EFAULT;
+	}
+
+	/* Get a free request frame and save the message context.
+	 */
+        if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL) {
+		dfailprintk(("%s: mptctl_register_diag_buffer: no msg frames!!\n",
+			ioc->name));
+                return -EAGAIN;
+	}
+
+	request_data = ioc->DiagBuffer[buffType];
+	request_data_sz = karg.data.RequestedBufferSize;
+
+	if ( request_data == NULL ) {
+allocDiagBuffer:
+		request_data = pci_alloc_consistent(
+	    		ioc->pcidev, request_data_sz, &request_data_dma);
+
+		if (request_data == NULL) {
+			printk("mptctl_register_diag_buffer: pci_alloc_consistent FAILED\n");
+			mpt_free_msg_frame(ioc, mf);
+                	return -EAGAIN;
+		}
+		ioc->DiagBuffer[buffType] = request_data;
+		ioc->DiagBuffer_sz[buffType] = request_data_sz;
+		ioc->DiagBuffer_dma[buffType] = request_data_dma;
+		ioc->DataSize[buffType] = 0;
+	} else {
+		request_data_dma = ioc->DiagBuffer_dma[buffType];
+		if ( request_data_sz != ioc->DiagBuffer_sz[buffType] ) {
+			pci_free_consistent(ioc->pcidev, ioc->DiagBuffer_sz[buffType],
+				request_data,
+				request_data_dma);
+			goto allocDiagBuffer;
+		}
+	}
+	ioc->DiagBuffer_Status[buffType] = 0;
+
+  	DiagBufferPostRequest = (DiagBufferPostRequest_t *)mf;
+	DiagBufferPostRequest->Function = MPI_FUNCTION_DIAG_BUFFER_POST;
+	DiagBufferPostRequest->ChainOffset = 0;
+	DiagBufferPostRequest->BufferType = karg.data.BufferType;
+	DiagBufferPostRequest->TraceLevel = 
+		ioc->TraceLevel[buffType] =
+		karg.data.TraceLevel;
+	DiagBufferPostRequest->MsgFlags = 0;
+	DiagBufferPostRequest->Reserved1 = 0;
+	DiagBufferPostRequest->Reserved2 = 0;
+	DiagBufferPostRequest->Reserved3 = 0;
+	if ( buffType == MPI_DIAG_BUF_TYPE_EXTENDED ) {
+		DiagBufferPostRequest->ExtendedType = 
+			ioc->ExtendedType[buffType] =
+			karg.data.ExtendedType;
+	} else {
+		DiagBufferPostRequest->ExtendedType =
+			ioc->ExtendedType[buffType] =
+			(u32)0;
+	}
+	ioc->UniqueId[buffType] = karg.data.UniqueId;
+	DiagBufferPostRequest->BufferLength = request_data_sz;
+	for ( ii = 0; ii < 4; ii++ ) {
+		DiagBufferPostRequest->ProductSpecific[ii] =
+			ioc->ProductSpecific[buffType][ii] = 
+			karg.data.ProductSpecific[ii];
+	}
+	if (sizeof(dma_addr_t) == sizeof(u64)) {
+		tmp = (u32) ((u64)request_data_dma >> 32);
+		DiagBufferPostRequest->BufferAddress.High = cpu_to_le32(tmp);
+	} else {
+		DiagBufferPostRequest->BufferAddress.High = (u32)0;
+	}
+	tmp = request_data_dma & 0xFFFFFFFF;
+	DiagBufferPostRequest->BufferAddress.Low = cpu_to_le32(tmp);
+
+	ioc->ioctl->timer.expires =
+	    jiffies + HZ*MPT_IOCTL_DEFAULT_TIMEOUT /* 10 sec */;
+	ioc->ioctl->wait_done = 0;
+	ioc->ioctl->status |= MPT_IOCTL_STATUS_TIMER_ACTIVE;
+	add_timer(&ioc->ioctl->timer);
+	mpt_put_msg_frame(mptctl_id, ioc, mf);
+	wait_event(mptctl_wait, ioc->ioctl->wait_done);
+
+	/* process the completed Reply Message Frame */
+	if (ioc->ioctl->status & MPT_IOCTL_STATUS_RF_VALID) {
+
+		DiagBufferPostReply =
+		    (DiagBufferPostReply_t *)ioc->ioctl->ReplyFrame;
+
+		if ( DiagBufferPostReply->IOCStatus == MPI_IOCSTATUS_SUCCESS) {
+			if ( DiagBufferPostReply->MsgLength > 5 ) {
+				ioc->DataSize[buffType] = 
+					DiagBufferPostReply->TransferLength;
+			}
+			ioc->DiagBuffer_Status[buffType] |= 
+				MPT_DIAG_BUFFER_IS_REGISTERED;
+		} else {
+			dctlprintk(("DiagBufferPostReply: IOCStatus=%x IOCLogInfo=%x\n",
+			    DiagBufferPostReply->IOCStatus,
+			    DiagBufferPostReply->IOCLogInfo));
+			rc = -EFAULT;
+		}
+	} else {
+		dctlprintk(("DiagBufferPostReply: status=%x\n", 
+			ioc->ioctl->status));
+		rc = -EFAULT;
+	}
+
+	ioc->ioctl->status &= ~(MPT_IOCTL_STATUS_TIMER_ACTIVE |
+	    MPT_IOCTL_STATUS_TM_FAILED | MPT_IOCTL_STATUS_COMMAND_GOOD |
+	    MPT_IOCTL_STATUS_SENSE_VALID | MPT_IOCTL_STATUS_RF_VALID |
+	    MPT_IOCTL_STATUS_DID_IOCRESET);
+	mpt_free_msg_frame(ioc, mf);
+
+	if ( rc ) {
+		pci_free_consistent(ioc->pcidev, request_data_sz,
+			request_data,
+			request_data_dma);
+	}
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* RELEASE DIAG BUFFER Routine.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-ENODEV if no such device/adapter
+ *		-ETIME	if timer expires
+ *		-ENOMEM if memory allocation error
+ */
+static int
+mptctl_release_diag_buffer (unsigned long arg)
+{
+	mpt_diag_release_t	*uarg = (mpt_diag_release_t *) arg;
+	mpt_diag_release_t	karg;
+	MPT_ADAPTER		*ioc;
+	void *			request_data;
+	int			iocnum, rc=0;
+	MPT_FRAME_HDR		*mf;
+  	DiagReleaseRequest_t 	*DiagRelease;
+  	DiagReleaseReply_t	*DiagReleaseReply;
+	u8			buffType;
+
+	dctlprintk(("mptctl_release_diag_buffer called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(mpt_diag_release_t))) {
+		printk(KERN_ERR "mptctl_release_diag_buffer: "
+			"Unable to read mpt_diag_release_t data @ %p\n",
+				(void*)uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+		(ioc == NULL)) {
+		dctlprintk(("mptctl_release_diag_buffer: ioc%d not found!\n",
+				iocnum));
+		return -ENODEV;
+	}
+
+	buffType = karg.data.UniqueId & 0x000000ff;
+	if ( !(ioc->facts.IOCCapabilities & 
+		MPT_DIAG_CAPABILITY(buffType)) ) {
+		printk("mptctl_release_diag_buffer: ioc%d does not have Capability for BufferType=%x\n",
+				iocnum, buffType);
+		return -ENODEV;
+	}
+
+	if ( (ioc->DiagBuffer_Status[buffType] & MPT_DIAG_BUFFER_IS_REGISTERED) == 0 ) {
+		printk("mptctl_release_diag_buffer: ioc%d BufferType=%x is not registered\n",
+				iocnum, buffType);
+		return -EFAULT;
+	}
+
+	if (karg.data.UniqueId != ioc->UniqueId[buffType]) {
+		printk("mptctl_release_diag_buffer: UniqueId=%x is not registered\n",
+			karg.data.UniqueId);
+		return -EFAULT;
+	}
+
+	if ( ioc->DiagBuffer_Status[buffType] & MPT_DIAG_BUFFER_IS_RELEASED) {
+		dctlprintk(("mptctl_release_diag_buffer: ioc%d BufferType=%x is already released\n",
+			iocnum, buffType));
+		return rc;
+	}
+
+	request_data = ioc->DiagBuffer[buffType];
+
+	if ( request_data == NULL ) {
+		printk("mptctl_release_diag_buffer: ioc%d does not have buffer for BufferType=%x\n",
+				iocnum, buffType);
+		return -ENODEV;
+	}
+
+	/* Get a free request frame and save the message context.
+	 */
+        if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL) {
+		dfailprintk(("%s: mptctl_release_diag_buffer, no msg frames!!\n",
+			ioc->name));
+                return -EAGAIN;
+	}
+
+  	DiagRelease = (DiagReleaseRequest_t *)mf;
+	DiagRelease->Function = MPI_FUNCTION_DIAG_RELEASE;
+	DiagRelease->BufferType = buffType;
+	DiagRelease->ChainOffset = 0;
+	DiagRelease->Reserved1 = 0;
+	DiagRelease->Reserved2 = 0;
+	DiagRelease->Reserved3 = 0;
+	DiagRelease->MsgFlags = 0;
+
+	ioc->ioctl->timer.expires =
+	    jiffies + HZ*MPT_IOCTL_DEFAULT_TIMEOUT /* 10 sec */;
+	ioc->ioctl->wait_done = 0;
+	ioc->ioctl->status |= MPT_IOCTL_STATUS_TIMER_ACTIVE;
+	add_timer(&ioc->ioctl->timer);
+	mpt_put_msg_frame(mptctl_id, ioc, mf);
+	wait_event(mptctl_wait, ioc->ioctl->wait_done);
+
+	/* process the completed Reply Message Frame */
+	if (ioc->ioctl->status & MPT_IOCTL_STATUS_RF_VALID) {
+		DiagReleaseReply =
+		    (DiagReleaseReply_t *)ioc->ioctl->ReplyFrame;
+
+		if ( DiagReleaseReply->IOCStatus != MPI_IOCSTATUS_DIAGNOSTIC_RELEASED) {
+			dctlprintk(("DiagReleaseReply: IOCStatus=%x IOCLogInfo=%x\n",
+			    DiagReleaseReply->IOCStatus,
+			    DiagReleaseReply->IOCLogInfo));
+			rc = -EFAULT;
+		} else {
+			ioc->DiagBuffer_Status[buffType] |= 
+				MPT_DIAG_BUFFER_IS_RELEASED;
+		}
+	} else {
+		dctlprintk(("DiagReleaseReply: status=%x\n", 
+			ioc->ioctl->status));
+		rc = -EFAULT;
+	}
+
+	ioc->ioctl->status &= ~(MPT_IOCTL_STATUS_TIMER_ACTIVE |
+	    MPT_IOCTL_STATUS_TM_FAILED | MPT_IOCTL_STATUS_COMMAND_GOOD |
+	    MPT_IOCTL_STATUS_SENSE_VALID | MPT_IOCTL_STATUS_RF_VALID |
+	    MPT_IOCTL_STATUS_DID_IOCRESET);
+	mpt_free_msg_frame(ioc, mf);
+
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* UNREGISTER DIAG BUFFER Routine.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-ENODEV if no such device/adapter
+ *		-ETIME	if timer expires
+ *		-ENOMEM if memory allocation error
+ */
+static int
+mptctl_unregister_diag_buffer (unsigned long arg)
+{
+	mpt_diag_unregister_t	*uarg = (mpt_diag_unregister_t *) arg;
+	mpt_diag_unregister_t	karg;
+	MPT_ADAPTER		*ioc;
+	int			iocnum;
+	void *			request_data;
+	dma_addr_t		request_data_dma;
+	u32			request_data_sz;
+	u8			buffType;
+
+	dctlprintk(("mptctl_unregister_diag_buffer called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(mpt_diag_unregister_t))) {
+		printk(KERN_ERR "mptctl_unregister_diag_buffer: "
+			"Unable to read pt_diag_unregister_t data @ %p\n",
+				(void*)uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+		(ioc == NULL)) {
+		dctlprintk(("mptctl_unregister_diag_buffer: ioc%d not found!\n",
+				iocnum));
+		return -ENODEV;
+	}
+
+	buffType = karg.data.UniqueId & 0x000000ff;
+	if ( !(ioc->facts.IOCCapabilities & 
+		MPT_DIAG_CAPABILITY(buffType)) ) {
+		printk("mptctl_unregister_diag_buffer: ioc%d does not have Capability for BufferType=%x\n",
+				iocnum, buffType);
+		return -ENODEV;
+	}
+
+	if ( (ioc->DiagBuffer_Status[buffType] & MPT_DIAG_BUFFER_IS_REGISTERED) == 0 ) {
+		printk("mptctl_unregister_diag_buffer: ioc%d BufferType=%x is not registered\n",
+				iocnum, buffType);
+		return -EFAULT;
+	}
+	if ( (ioc->DiagBuffer_Status[buffType] & MPT_DIAG_BUFFER_IS_RELEASED) == 0 ) {
+		printk("mptctl_unregister_diag_buffer: ioc%d BufferType=%x has not been released\n",
+			iocnum, buffType);
+		return -EFAULT;
+	}
+
+	if (karg.data.UniqueId != ioc->UniqueId[buffType]) {
+		printk("mptctl_unregister_diag_buffer: UniqueId=%x is not registered\n",
+			karg.data.UniqueId);
+		return -EFAULT;
+	}
+		
+	request_data = ioc->DiagBuffer[buffType];
+
+	if ( request_data ) {
+		request_data_sz = ioc->DiagBuffer_sz[buffType];
+		request_data_dma = ioc->DiagBuffer_dma[buffType];
+		pci_free_consistent(ioc->pcidev, request_data_sz,
+			request_data,
+			request_data_dma);
+
+		ioc->DiagBuffer[buffType] = NULL;
+		ioc->DiagBuffer_Status[buffType] = 0;
+		return 0;
+	} else {
+		printk("mptctl_unregister_diag_buffer: ioc%d does not have buffer for BufferType=%x\n",
+				iocnum, buffType);
+		return -ENODEV;
+	}
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* QUERY DIAG BUFFER Routine.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-ENODEV if no such device/adapter
+ *		-ETIME	if timer expires
+ *		-ENOMEM if memory allocation error
+ */
+static int
+mptctl_query_diag_buffer (unsigned long arg)
+{
+	mpt_diag_query_t	*uarg = (mpt_diag_query_t *) arg;
+	mpt_diag_query_t	karg;
+	MPT_ADAPTER		*ioc;
+	void *			request_data;
+	int			iocnum, ii, rc=-EFAULT;
+	u8			buffType;
+
+	dctlprintk(("mptctl_query_diag_buffer called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(mpt_diag_query_t))) {
+		printk(KERN_ERR "mptctl_query_diag_buffer: "
+			"Unable to read mpt_diag_query_t data @ %p\n",
+				(void*)uarg);
+		return -EFAULT;
+	}
+
+	karg.data.Flags = 0;
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+		(ioc == NULL)) {
+		dctlprintk(("mptctl_query_diag_buffer: ioc%d not found!\n",
+			iocnum));
+		goto copy_back;
+	}
+
+	buffType = karg.data.BufferType;
+	if ( !(ioc->facts.IOCCapabilities & 
+		MPT_DIAG_CAPABILITY(buffType)) ) {
+		printk("mptctl_query_diag_buffer: ioc%d does not have Capability for BufferType=%x\n",
+			iocnum, buffType);
+		goto copy_back;
+	}
+
+	if ( (ioc->DiagBuffer_Status[buffType] & MPT_DIAG_BUFFER_IS_REGISTERED) == 0 ) {
+		printk("mptctl_query_diag_buffer: ioc%d BufferType=%x is not registered\n",
+			iocnum, buffType);
+		goto copy_back;
+	}
+
+	if (karg.data.UniqueId & 0xffffff00) {
+		if (karg.data.UniqueId != ioc->UniqueId[buffType]) {
+			printk("mptctl_query_diag_buffer: UniqueId=%x is not registered\n",
+				karg.data.UniqueId);
+			goto copy_back;
+		}
+	}
+
+	request_data = ioc->DiagBuffer[buffType];
+
+	if ( request_data ) {
+		if ( buffType == MPI_DIAG_BUF_TYPE_EXTENDED ) {
+			if (karg.data.ExtendedType != ioc->ExtendedType[buffType])
+				goto copy_back;
+		} else 
+			karg.data.ExtendedType = 0;
+
+		if ( ioc->DiagBuffer_Status[buffType] & MPT_DIAG_BUFFER_IS_RELEASED )
+			karg.data.Flags = 3;
+		else
+			karg.data.Flags = 7;
+		karg.data.TraceLevel = ioc->TraceLevel[buffType];
+		for ( ii = 0; ii < 4; ii++ ) {
+			karg.data.ProductSpecific[ii] =
+				ioc->ProductSpecific[buffType][ii];
+		}
+		karg.data.DataSize = ioc->DataSize[buffType];
+		karg.data.DriverAddedBufferSize = 0;
+		karg.data.UniqueId = ioc->UniqueId[buffType];
+		rc = 0;
+	} else {
+		printk( "mptctl_query_diag_buffer: ioc%d does not have buffer for BufferType=%x\n",
+			iocnum, buffType);
+	}
+copy_back:
+	if (copy_to_user((char *)arg, &karg, sizeof(mpt_diag_query_t))) {
+		printk(KERN_ERR "mptctl_query_diag_buffer: "
+			"Unable to write mpt_diag_query_t data @ %p\n",
+			(void*)uarg);
+		return -EFAULT;
+	}
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* READ DIAG BUFFER Routine.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-ENODEV if no such device/adapter
+ *		-ETIME	if timer expires
+ *		-ENOMEM if memory allocation error
+ */
+static int
+mptctl_read_diag_buffer (unsigned long arg)
+{
+	mpt_diag_read_buffer_t	*uarg = (mpt_diag_read_buffer_t *) arg;
+	mpt_diag_read_buffer_t	karg;
+	MPT_ADAPTER		*ioc;
+	void			*request_data, *diagData;
+	dma_addr_t		request_data_dma;
+  	DiagBufferPostRequest_t *DiagBufferPostRequest;
+  	DiagBufferPostReply_t	*DiagBufferPostReply;
+	MPT_FRAME_HDR		*mf;
+	int			iocnum, rc=0, ii;
+	u8			buffType;
+	u32 			tmp;
+
+	dctlprintk(("mptctl_read_diag_buffer called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(mpt_diag_read_buffer_t))) {
+		printk(KERN_ERR "mptctl_read_diag_buffer: "
+			"Unable to read mpt_diag_read_buffer_t data @ %p\n",
+				(void*)uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+		(ioc == NULL)) {
+		dctlprintk((KERN_INFO "mptctl_read_diag_buffer: ioc%d not found!\n",
+				iocnum));
+		return -ENODEV;
+	}
+
+	buffType = karg.data.UniqueId & 0x000000ff;
+	if ( !(ioc->facts.IOCCapabilities & 
+		MPT_DIAG_CAPABILITY(buffType)) ) {
+		printk("mptctl_read_diag_buffer: ioc%d does not have Capability for BufferType=%x\n",
+				iocnum, buffType);
+		return -EFAULT;
+	}
+
+	if (karg.data.UniqueId != ioc->UniqueId[buffType]) {
+		printk("mptctl_read_diag_buffer: UniqueId=%x is not registered\n",
+			karg.data.UniqueId);
+		return -EFAULT;
+	}
+
+	request_data = ioc->DiagBuffer[buffType];
+
+	if ( request_data ) {
+		diagData = (void *)(request_data + karg.data.StartingOffset);
+		dctlprintk(("mptctl_read_diag_buffer: ioc%d diagData=%p request_data=%p StartingOffset=%x\n",
+				iocnum, diagData, request_data, karg.data.StartingOffset));
+		if (copy_to_user((char *)&uarg->data.DiagnosticData[0],
+				diagData, karg.data.BytesToRead)) {
+			printk(KERN_ERR "mptctl_read_diag_buffer: "
+			"Unable to write mpt_diag_read_buffer_t data @ %p\n",
+				(void*)diagData);
+			return -EFAULT;
+		}
+	} else {
+		printk("mptctl_read_diag_buffer: ioc%d does not have buffer for BufferType=%x\n",
+			iocnum, buffType);
+		return -EFAULT;
+	}
+
+	if ( karg.data.Flags & MPI_FW_DIAG_FLAG_REREGISTER ) {
+		dctlprintk(("mptctl_read_diag_buffer: ioc%d Reregister BufferType=%x\n",
+			iocnum, buffType));
+		if ( (ioc->DiagBuffer_Status[buffType] & MPT_DIAG_BUFFER_IS_RELEASED) == 0 ) {
+			dctlprintk(("mptctl_read_diag_buffer: ioc%d BufferType=%x is still registered\n",
+				iocnum, buffType));
+			return rc;
+		}
+		/* Get a free request frame and save the message context.
+	 	*/
+        	if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL) {
+			dfailprintk(("%s: mptctl_read_diag_buffer, no msg frames!!\n",
+				ioc->name));
+                	return -EAGAIN;
+		}
+
+  		DiagBufferPostRequest = (DiagBufferPostRequest_t *)mf;
+		DiagBufferPostRequest->Function = MPI_FUNCTION_DIAG_BUFFER_POST;
+		DiagBufferPostRequest->ChainOffset = 0;
+		DiagBufferPostRequest->BufferType = buffType;
+		DiagBufferPostRequest->TraceLevel = 
+			ioc->TraceLevel[buffType];
+		DiagBufferPostRequest->MsgFlags = 0;
+		DiagBufferPostRequest->Reserved1 = 0;
+		DiagBufferPostRequest->Reserved2 = 0;
+		DiagBufferPostRequest->Reserved3 = 0;
+		if ( buffType == MPI_DIAG_BUF_TYPE_EXTENDED ) {
+			DiagBufferPostRequest->ExtendedType = 
+				ioc->ExtendedType[buffType];
+		}
+		DiagBufferPostRequest->BufferLength = ioc->DiagBuffer_sz[buffType];
+		for ( ii = 0; ii < 4; ii++ ) {
+			DiagBufferPostRequest->ProductSpecific[ii] =
+				ioc->ProductSpecific[buffType][ii];
+		}
+		request_data_dma = ioc->DiagBuffer_dma[buffType];
+		if (sizeof(dma_addr_t) == sizeof(u64)) {
+			tmp = (u32) ((u64)request_data_dma >> 32);
+			DiagBufferPostRequest->BufferAddress.High = cpu_to_le32(tmp);
+		} else {
+			DiagBufferPostRequest->BufferAddress.High = (u32)0;
+		}
+		tmp = request_data_dma & 0xFFFFFFFF;
+		DiagBufferPostRequest->BufferAddress.Low = cpu_to_le32(tmp);
+
+		ioc->ioctl->timer.expires =
+		    jiffies + HZ*MPT_IOCTL_DEFAULT_TIMEOUT /* 10 sec */;
+		ioc->ioctl->wait_done = 0;
+		ioc->ioctl->status |= MPT_IOCTL_STATUS_TIMER_ACTIVE;
+		add_timer(&ioc->ioctl->timer);
+		mpt_put_msg_frame(mptctl_id, ioc, mf);
+		wait_event(mptctl_wait, ioc->ioctl->wait_done);
+
+		/* process the completed Reply Message Frame */
+		if (ioc->ioctl->status & MPT_IOCTL_STATUS_RF_VALID) {
+			DiagBufferPostReply =
+			    (DiagBufferPostReply_t *)ioc->ioctl->ReplyFrame;
+
+			if ( DiagBufferPostReply->IOCStatus == MPI_IOCSTATUS_SUCCESS) {
+				if ( DiagBufferPostReply->MsgLength > 5 ) {
+					ioc->DataSize[buffType] = 
+						DiagBufferPostReply->TransferLength;
+				}
+				ioc->DiagBuffer_Status[buffType] |= 
+					MPT_DIAG_BUFFER_IS_REGISTERED;
+			} else {
+				dctlprintk(("DiagBufferPostReply: IOCStatus=%x IOCLogInfo=%x\n",
+			    		DiagBufferPostReply->IOCStatus,
+			    		DiagBufferPostReply->IOCLogInfo));
+				rc = -EFAULT;
+			}
+		} else {
+			dctlprintk(("DiagBufferPostReply: status=%x\n", 
+				ioc->ioctl->status));
+			rc = -EFAULT;
+		}
+
+		ioc->ioctl->status &= ~(MPT_IOCTL_STATUS_TIMER_ACTIVE |
+		    MPT_IOCTL_STATUS_TM_FAILED | MPT_IOCTL_STATUS_COMMAND_GOOD |
+		    MPT_IOCTL_STATUS_SENSE_VALID | MPT_IOCTL_STATUS_RF_VALID |
+		    MPT_IOCTL_STATUS_DID_IOCRESET);
+		mpt_free_msg_frame(ioc, mf);
+
+	}
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
 static struct file_operations mptctl_fops = {
-	owner_THIS_MODULE
+	.owner =	THIS_MODULE,
 	.llseek =	no_llseek,
-	.read =		mptctl_read,
-	.write =	mptctl_write,
-	.ioctl =	mptctl_ioctl,
-	.open =		mptctl_open,
 	.release =	mptctl_release,
+	.fasync = 	mptctl_fasync,
+	.ioctl =	mptctl_ioctl,
 };
 
 static struct miscdevice mptctl_miscdev = {
@@ -2720,27 +3809,36 @@ static struct miscdevice mptctl_miscdev 
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
-#if defined(__sparc__) && defined(__sparc_v9__)		/*{*/
-
-/* The dynamic ioctl32 compat. registry only exists in >2.3.x sparc64 kernels */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)		/*{*/
+#ifdef MPT_CONFIG_COMPAT
 extern int register_ioctl32_conversion(unsigned int cmd,
 				       int (*handler)(unsigned int,
 						      unsigned int,
 						      unsigned long,
 						      struct file *));
 int unregister_ioctl32_conversion(unsigned int cmd);
-extern asmlinkage int sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg);
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/* sparc32_XXX functions are used to provide a conversion between
+/* compat_XXX functions are used to provide a conversion between
  * pointers and u32's. If the arg does not contain any pointers, then
- * a specialized function (sparc32_XXX) is not needed. If the arg
+ * a specialized function (compat_XXX) is not needed. If the arg
  * does contain pointer(s), then the specialized function is used
  * to ensure the structure contents is properly processed by mptctl.
  */
 static int
-sparc32_mptfwxfer_ioctl(unsigned int fd, unsigned int cmd,
+compat_mptctl_ioctl(unsigned int fd, unsigned int cmd,
+			unsigned long arg, struct file *filp)
+{
+	int ret;
+
+	lock_kernel();
+	dctlprintk((KERN_INFO MYNAM "::compat_mptctl_ioctl() called\n"));
+	ret = mptctl_ioctl(filp->f_dentry->d_inode, filp, cmd, arg);
+	unlock_kernel();
+	return ret;
+}
+
+static int
+compat_mptfwxfer_ioctl(unsigned int fd, unsigned int cmd,
 			unsigned long arg, struct file *filp)
 {
 	struct mpt_fw_xfer32 kfw32;
@@ -2750,7 +3848,7 @@ sparc32_mptfwxfer_ioctl(unsigned int fd,
 	int nonblock = (filp->f_flags & O_NONBLOCK);
 	int ret;
 
-	dctlprintk((KERN_INFO MYNAM "::sparc32_mptfwxfer_ioctl() called\n"));
+	dctlprintk((KERN_INFO MYNAM "::compat_mptfwxfer_ioctl() called\n"));
 
 	if (copy_from_user(&kfw32, (char *)arg, sizeof(kfw32)))
 		return -EFAULT;
@@ -2759,7 +3857,7 @@ sparc32_mptfwxfer_ioctl(unsigned int fd,
 	iocnumX = kfw32.iocnum & 0xFF;
 	if (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||
 	    (iocp == NULL)) {
-		dctlprintk((KERN_ERR MYNAM "::sparc32_mptfwxfer_ioctl @%d - ioc%d not found!\n",
+		dctlprintk((KERN_INFO MYNAM "::compat_mptfwxfer_ioctl @%d - ioc%d not found!\n",
 				__LINE__, iocnumX));
 		return -ENODEV;
 	}
@@ -2773,13 +3871,13 @@ sparc32_mptfwxfer_ioctl(unsigned int fd,
 
 	ret = mptctl_do_fw_download(kfw.iocnum, kfw.bufp, kfw.fwlen);
 
-	up(&mptctl_syscall_sem_ioc[iocp->id]);
+	up(&iocp->mptctl_syscall_sem_ioc);
 
 	return ret;
 }
 
 static int
-sparc32_mpt_command(unsigned int fd, unsigned int cmd,
+compat_mpt_command(unsigned int fd, unsigned int cmd,
 			unsigned long arg, struct file *filp)
 {
 	struct mpt_ioctl_command32 karg32;
@@ -2790,7 +3888,7 @@ sparc32_mpt_command(unsigned int fd, uns
 	int nonblock = (filp->f_flags & O_NONBLOCK);
 	int ret;
 
-	dctlprintk((KERN_INFO MYNAM "::sparc32_mpt_command() called\n"));
+	dctlprintk((KERN_INFO MYNAM "::compat_mpt_command() called\n"));
 
 	if (copy_from_user(&karg32, (char *)arg, sizeof(karg32)))
 		return -EFAULT;
@@ -2799,7 +3897,7 @@ sparc32_mpt_command(unsigned int fd, uns
 	iocnumX = karg32.hdr.iocnum & 0xFF;
 	if (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||
 	    (iocp == NULL)) {
-		dctlprintk((KERN_ERR MYNAM "::sparc32_mpt_command @%d - ioc%d not found!\n",
+		dctlprintk((KERN_INFO MYNAM "::compat_mpt_command @%d - ioc%d not found!\n",
 				__LINE__, iocnumX));
 		return -ENODEV;
 	}
@@ -2825,87 +3923,137 @@ sparc32_mpt_command(unsigned int fd, uns
 
 	/* Pass new structure to do_mpt_command
 	 */
-	ret = mptctl_do_mpt_command (karg, (char *) &uarg->MF, 0);
+	ret = mptctl_do_mpt_command (karg, (char *) &uarg->MF);
 
-	up(&mptctl_syscall_sem_ioc[iocp->id]);
+	up(&iocp->mptctl_syscall_sem_ioc);
 
 	return ret;
 }
 
-#endif		/*} linux >= 2.3.x */
-#endif		/*} sparc */
+#endif
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-int __init mptctl_init(void)
+static int __init mptctl_init(void)
 {
 	int err;
 	int i;
 	int where = 1;
 	int sz;
 	u8 *mem;
-	MPT_ADAPTER *ioc = NULL;
+	MPT_ADAPTER *ioc;
 	int iocnum;
 
 	show_mptmod_ver(my_NAME, my_VERSION);
 
-	for (i=0; i<MPT_MAX_ADAPTERS; i++) {
-		sema_init(&mptctl_syscall_sem_ioc[i], 1);
+	list_for_each_entry(ioc,&ioc_list,list) {
+		sema_init(&ioc->mptctl_syscall_sem_ioc, 1);
 
-		ioc = NULL;
-		if (((iocnum = mpt_verify_adapter(i, &ioc)) < 0) ||
-		    (ioc == NULL)) {
-			continue;
+		sz = sizeof (MPT_IOCTL);
+		mem = kmalloc(sz, GFP_KERNEL);
+		if (mem == NULL) {
+			err = -ENOMEM;
+			goto out_fail;
 		}
-		else {
-			/* This adapter instance is found.
-			 * Allocate and inite a MPT_IOCTL structure
-			 */
-			sz = sizeof (MPT_IOCTL);
-			mem = kmalloc(sz, GFP_KERNEL);
-			if (mem == NULL) {
-				err = -ENOMEM;
-				goto out_fail;
-			}
 
-			memset(mem, 0, sz);
-			ioc->ioctl = (MPT_IOCTL *) mem;
-			ioc->ioctl->ioc = ioc;
-			init_timer (&ioc->ioctl->timer);
-			ioc->ioctl->timer.data = (unsigned long) ioc->ioctl;
-			ioc->ioctl->timer.function = mptctl_timer_expired;
-			init_timer (&ioc->ioctl->TMtimer);
-			ioc->ioctl->TMtimer.data = (unsigned long) ioc->ioctl;
-			ioc->ioctl->TMtimer.function = mptctl_timer_expired;
-		}
+		memset(mem, 0, sz);
+		ioc->ioctl = (MPT_IOCTL *) mem;
+		ioc->ioctl->ioc = ioc;
+		init_timer (&ioc->ioctl->timer);
+		ioc->ioctl->timer.data = (unsigned long) ioc->ioctl;
+		ioc->ioctl->timer.function = mptctl_timer_expired;
+		init_timer (&ioc->ioctl->TMtimer);
+		ioc->ioctl->TMtimer.data = (unsigned long) ioc->ioctl;
+		ioc->ioctl->TMtimer.function = mptctl_timer_expired;
 	}
 
-#if defined(__sparc__) && defined(__sparc_v9__)		/*{*/
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)		/*{*/
-	err = register_ioctl32_conversion(MPTIOCINFO, NULL);
+#ifdef MPT_CONFIG_COMPAT
+	err = register_ioctl32_conversion(MPTIOCINFO, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(MPTIOCINFO1, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(MPTIOCINFO2, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(MPTTARGETINFO, compat_mptctl_ioctl);
 	if (++where && err) goto out_fail;
-	err = register_ioctl32_conversion(MPTTARGETINFO, NULL);
+	err = register_ioctl32_conversion(MPTTEST, compat_mptctl_ioctl);
 	if (++where && err) goto out_fail;
-	err = register_ioctl32_conversion(MPTTEST, NULL);
+	err = register_ioctl32_conversion(MPTEVENTQUERY, compat_mptctl_ioctl);
 	if (++where && err) goto out_fail;
-	err = register_ioctl32_conversion(MPTEVENTQUERY, NULL);
+	err = register_ioctl32_conversion(MPTEVENTENABLE, compat_mptctl_ioctl);
 	if (++where && err) goto out_fail;
-	err = register_ioctl32_conversion(MPTEVENTENABLE, NULL);
+	err = register_ioctl32_conversion(MPTEVENTREPORT, compat_mptctl_ioctl);
 	if (++where && err) goto out_fail;
-	err = register_ioctl32_conversion(MPTEVENTREPORT, NULL);
+	err = register_ioctl32_conversion(MPTHARDRESET, compat_mptctl_ioctl);
 	if (++where && err) goto out_fail;
-	err = register_ioctl32_conversion(MPTHARDRESET, NULL);
+	err = register_ioctl32_conversion(MPTDIAGRESET, compat_mptctl_ioctl);
 	if (++where && err) goto out_fail;
-	err = register_ioctl32_conversion(MPTCOMMAND32, sparc32_mpt_command);
+	err = register_ioctl32_conversion(MPTCOMMAND32, compat_mpt_command);
 	if (++where && err) goto out_fail;
 	err = register_ioctl32_conversion(MPTFWDOWNLOAD32,
-					  sparc32_mptfwxfer_ioctl);
+					  compat_mptfwxfer_ioctl);
 	if (++where && err) goto out_fail;
-	err = register_ioctl32_conversion(HP_GETHOSTINFO, NULL);
+	err = register_ioctl32_conversion(MPTFWDOWNLOADBOOT, 
+			compat_mptctl_ioctl);
 	if (++where && err) goto out_fail;
-	err = register_ioctl32_conversion(HP_GETTARGETINFO, NULL);
+	err = register_ioctl32_conversion(HP_GETHOSTINFO, compat_mptctl_ioctl);
 	if (++where && err) goto out_fail;
-#endif		/*} linux >= 2.3.x */
-#endif		/*} sparc */
+	err = register_ioctl32_conversion(HP_GETTARGETINFO, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+
+	err = register_ioctl32_conversion(MPTDIAGREGISTER, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(MPTDIAGRELEASE, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(MPTDIAGUNREGISTER, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(MPTDIAGQUERY, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(MPTDIAGREADBUFFER, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(MPTHBAPCIINFO, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+#if defined(CPQ_CIM)
+	err = register_ioctl32_conversion(CC_CSMI_SAS_GET_DRIVER_INFO, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CC_CSMI_SAS_GET_CNTLR_CONFIG, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CC_CSMI_SAS_GET_CNTLR_STATUS, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CC_CSMI_SAS_GET_SCSI_ADDRESS, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CC_CSMI_SAS_GET_DEVICE_ADDRESS, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CC_CSMI_SAS_GET_PHY_INFO, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CC_CSMI_SAS_GET_SATA_SIGNATURE, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CC_CSMI_SAS_GET_LINK_ERRORS, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CC_CSMI_SAS_SMP_PASSTHRU, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CC_CSMI_SAS_SSP_PASSTHRU, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CC_CSMI_SAS_FIRMWARE_DOWNLOAD, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CC_CSMI_SAS_GET_RAID_INFO, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CC_CSMI_SAS_GET_RAID_CONFIG, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CC_CSMI_SAS_SET_PHY_INFO, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CC_CSMI_SAS_STP_PASSTHRU, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CC_CSMI_SAS_TASK_MANAGEMENT, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CC_CSMI_SAS_PHY_CONTROL, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CC_CSMI_SAS_GET_CONNECTOR_INFO, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CC_CSMI_SAS_GET_LOCATION, compat_mptctl_ioctl);
+	if (++where && err) goto out_fail;
+#endif // CPQ_CIM
+
+#endif
 
 	/* Register this device */
 	err = misc_register(&mptctl_miscdev);
@@ -2929,51 +4077,79 @@ int __init mptctl_init(void)
 	}
 
 	if (mpt_reset_register(mptctl_id, mptctl_ioc_reset) == 0) {
-		dprintk((KERN_INFO MYNAM ": Registered for IOC reset notifications\n"));
+		dinitprintk((KERN_INFO MYNAM ": Registered mptctl_ioc_reset notification mptctl_id=%d\n", mptctl_id));
 	} else {
-		/* FIXME! */
+		dinitprintk((KERN_INFO MYNAM ": Register of mptctl_ioc_reset notification mptctl_id=%d FAILED\n", mptctl_id));
+	}
+
+	if (mpt_event_register(mptctl_id, mptctl_event_process) == 0) {
+		devtprintk((KERN_INFO MYNAM
+		  ": Registered for IOC event notifications\n"));
 	}
 
 	return 0;
 
 out_fail:
 
-#if defined(__sparc__) && defined(__sparc_v9__)		/*{*/
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)		/*{*/
+#ifdef MPT_CONFIG_COMPAT
 	printk(KERN_ERR MYNAM ": ERROR: Failed to register ioctl32_conversion!"
 			" (%d:err=%d)\n", where, err);
 	unregister_ioctl32_conversion(MPTIOCINFO);
+	unregister_ioctl32_conversion(MPTIOCINFO1);
+	unregister_ioctl32_conversion(MPTIOCINFO2);
 	unregister_ioctl32_conversion(MPTTARGETINFO);
 	unregister_ioctl32_conversion(MPTTEST);
 	unregister_ioctl32_conversion(MPTEVENTQUERY);
 	unregister_ioctl32_conversion(MPTEVENTENABLE);
 	unregister_ioctl32_conversion(MPTEVENTREPORT);
 	unregister_ioctl32_conversion(MPTHARDRESET);
+	unregister_ioctl32_conversion(MPTDIAGRESET);
 	unregister_ioctl32_conversion(MPTCOMMAND32);
 	unregister_ioctl32_conversion(MPTFWDOWNLOAD32);
+	unregister_ioctl32_conversion(MPTFWDOWNLOADBOOT);
 	unregister_ioctl32_conversion(HP_GETHOSTINFO);
 	unregister_ioctl32_conversion(HP_GETTARGETINFO);
-#endif		/*} linux >= 2.3.x */
-#endif		/*} sparc */
 
-	for (i=0; i<MPT_MAX_ADAPTERS; i++) {
-		ioc = NULL;
-		if (((iocnum = mpt_verify_adapter(i, &ioc)) < 0) ||
-		    (ioc == NULL)) {
-			continue;
-		}
-		else {
-			if (ioc->ioctl) {
-				kfree ( ioc->ioctl );
-				ioc->ioctl = NULL;
-			}
+	unregister_ioctl32_conversion(MPTDIAGREGISTER);
+	unregister_ioctl32_conversion(MPTDIAGRELEASE);
+	unregister_ioctl32_conversion(MPTDIAGUNREGISTER);
+	unregister_ioctl32_conversion(MPTDIAGQUERY);
+	unregister_ioctl32_conversion(MPTDIAGREADBUFFER);
+	unregister_ioctl32_conversion(MPTHBAPCIINFO);
+#if defined(CPQ_CIM)
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_DRIVER_INFO);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_CNTLR_CONFIG);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_CNTLR_STATUS);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_SCSI_ADDRESS);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_DEVICE_ADDRESS);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_PHY_INFO);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_SATA_SIGNATURE);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_LINK_ERRORS);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_SMP_PASSTHRU);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_SSP_PASSTHRU);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_FIRMWARE_DOWNLOAD);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_RAID_INFO);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_RAID_CONFIG);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_SET_PHY_INFO);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_STP_PASSTHRU);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_TASK_MANAGEMENT);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_PHY_CONTROL);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_CONNECTOR_INFO);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_LOCATION);
+#endif // CPQ_CIM
+#endif
+
+	list_for_each_entry(ioc,&ioc_list,list) {
+		if (ioc->ioctl) {
+			kfree ( ioc->ioctl );
+			ioc->ioctl = NULL;
 		}
 	}
 	return err;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-void mptctl_exit(void)
+static void mptctl_exit(void)
 {
 	int i;
 	MPT_ADAPTER *ioc;
@@ -2987,26 +4163,72 @@ void mptctl_exit(void)
 	mpt_reset_deregister(mptctl_id);
 	dprintk((KERN_INFO MYNAM ": Deregistered for IOC reset notifications\n"));
 
+	mpt_event_deregister(mptctl_id);
+	dprintk((KERN_INFO MYNAM ": Deregistered for IOC event notifications\n"));
+
 	/* De-register callback handler from base module */
 	mpt_deregister(mptctl_id);
 	printk(KERN_INFO MYNAM ": Deregistered from Fusion MPT base driver\n");
 
+#ifdef MPT_CONFIG_COMPAT
+	unregister_ioctl32_conversion(MPTIOCINFO);
+	unregister_ioctl32_conversion(MPTIOCINFO1);
+	unregister_ioctl32_conversion(MPTIOCINFO2);
+	unregister_ioctl32_conversion(MPTTARGETINFO);
+	unregister_ioctl32_conversion(MPTTEST);
+	unregister_ioctl32_conversion(MPTEVENTQUERY);
+	unregister_ioctl32_conversion(MPTEVENTENABLE);
+	unregister_ioctl32_conversion(MPTEVENTREPORT);
+	unregister_ioctl32_conversion(MPTHARDRESET);
+	unregister_ioctl32_conversion(MPTDIAGRESET);
+	unregister_ioctl32_conversion(MPTCOMMAND32);
+	unregister_ioctl32_conversion(MPTFWDOWNLOAD32);
+	unregister_ioctl32_conversion(MPTFWDOWNLOADBOOT);
+	unregister_ioctl32_conversion(HP_GETHOSTINFO);
+	unregister_ioctl32_conversion(HP_GETTARGETINFO);
+
+	unregister_ioctl32_conversion(MPTDIAGREGISTER);
+	unregister_ioctl32_conversion(MPTDIAGRELEASE);
+	unregister_ioctl32_conversion(MPTDIAGUNREGISTER);
+	unregister_ioctl32_conversion(MPTDIAGQUERY);
+	unregister_ioctl32_conversion(MPTDIAGREADBUFFER);
+	unregister_ioctl32_conversion(MPTHBAPCIINFO);
+#if defined(CPQ_CIM)
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_DRIVER_INFO);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_CNTLR_CONFIG);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_CNTLR_STATUS);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_SCSI_ADDRESS);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_DEVICE_ADDRESS);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_PHY_INFO);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_SATA_SIGNATURE);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_LINK_ERRORS);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_SMP_PASSTHRU);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_SSP_PASSTHRU);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_FIRMWARE_DOWNLOAD);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_RAID_INFO);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_RAID_CONFIG);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_SET_PHY_INFO);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_STP_PASSTHRU);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_TASK_MANAGEMENT);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_PHY_CONTROL);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_CONNECTOR_INFO);
+	unregister_ioctl32_conversion(CC_CSMI_SAS_GET_LOCATION);
+#endif // CPQ_CIM
+#endif
+
 	/* Free allocated memory */
-	for (i=0; i<MPT_MAX_ADAPTERS; i++) {
-		ioc = NULL;
-		if (((iocnum = mpt_verify_adapter(i, &ioc)) < 0) ||
-		    (ioc == NULL)) {
-			continue;
-		}
-		else {
-			if (ioc->ioctl) {
-				kfree ( ioc->ioctl );
-				ioc->ioctl = NULL;
-			}
+	list_for_each_entry(ioc,&ioc_list,list) {
+		if (ioc->ioctl) {
+			kfree ( ioc->ioctl );
+			ioc->ioctl = NULL;
 		}
 	}
 }
 
+#if defined(CPQ_CIM)
+#include "csmisas.c"
+#endif // CPQ_CIM
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
 module_init(mptctl_init);
diff -urNp linux-8145/drivers/message/fusion/mptctl.h linux-8150/drivers/message/fusion/mptctl.h
--- linux-8145/drivers/message/fusion/mptctl.h
+++ linux-8150/drivers/message/fusion/mptctl.h
@@ -5,22 +5,10 @@
  *          LSIFC9xx/LSI409xx Fibre Channel
  *      running LSI Logic Fusion MPT (Message Passing Technology) firmware.
  *
- *  Credits:
- *      This driver would not exist if not for Alan Cox's development
- *      of the linux i2o driver.
+ *  Copyright (c) 1999-2005 LSI Logic Corporation
+ *  (mailto:mpt_linux_developer@lsil.com)
  *
- *      A huge debt of gratitude is owed to David S. Miller (DaveM)
- *      for fixing much of the stupid and broken stuff in the early
- *      driver while porting to sparc64 platform.  THANK YOU!
- *
- *      (see also mptbase.c)
- *
- *  Copyright (c) 1999-2002 LSI Logic Corporation
- *  Originally By: Steven J. Ralston
- *  (mailto:sjralston1@netscape.net)
- *  (mailto:lstephen@lsil.com)
- *
- *  $Id: mptctl.h,v 1.13 2002/12/03 21:26:33 pdelaney Exp $
+ *  $Id: mptctl.h,v 1.14 2003/03/18 22:49:51 Exp $
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -63,6 +51,7 @@
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
 #include "linux/version.h"
+#include "lsi/mpi_ioc.h"
 
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -71,6 +60,7 @@
  */
 #define MPT_MISCDEV_BASENAME            "mptctl"
 #define MPT_MISCDEV_PATHNAME            "/dev/" MPT_MISCDEV_BASENAME
+#define MPT_CSMI_DESCRIPTION	        "LSI Logic Corporation: Fusion MPT Driver " MPT_LINUX_VERSION_COMMON
 
 #define MPT_PRODUCT_LENGTH              12
 
@@ -82,14 +72,17 @@
 #define MPTRWPERF		_IOWR(MPT_MAGIC_NUMBER,0,struct mpt_raw_r_w)
 
 #define MPTFWDOWNLOAD		_IOWR(MPT_MAGIC_NUMBER,15,struct mpt_fw_xfer)
+#define MPTFWDOWNLOADBOOT	_IOWR(MPT_MAGIC_NUMBER,16,struct mpt_fw_xfer)
 #define MPTCOMMAND		_IOWR(MPT_MAGIC_NUMBER,20,struct mpt_ioctl_command)
 
-#if defined(__KERNEL__) && defined(__sparc__) && defined(__sparc_v9__)		/*{*/
+#if defined(__KERNEL__) && defined(MPT_CONFIG_COMPAT)
 #define MPTFWDOWNLOAD32		_IOWR(MPT_MAGIC_NUMBER,15,struct mpt_fw_xfer32)
 #define MPTCOMMAND32		_IOWR(MPT_MAGIC_NUMBER,20,struct mpt_ioctl_command32)
-#endif	/*}*/
+#endif
 
 #define MPTIOCINFO		_IOWR(MPT_MAGIC_NUMBER,17,struct mpt_ioctl_iocinfo)
+#define MPTIOCINFO1		_IOWR(MPT_MAGIC_NUMBER,17,struct mpt_ioctl_iocinfo_rev0)
+#define MPTIOCINFO2		_IOWR(MPT_MAGIC_NUMBER,17,struct mpt_ioctl_iocinfo_rev1)
 #define MPTTARGETINFO		_IOWR(MPT_MAGIC_NUMBER,18,struct mpt_ioctl_targetinfo)
 #define MPTTEST			_IOWR(MPT_MAGIC_NUMBER,19,struct mpt_ioctl_test)
 #define MPTEVENTQUERY		_IOWR(MPT_MAGIC_NUMBER,21,struct mpt_ioctl_eventquery)
@@ -97,9 +90,16 @@
 #define MPTEVENTREPORT		_IOWR(MPT_MAGIC_NUMBER,23,struct mpt_ioctl_eventreport)
 #define MPTHARDRESET		_IOWR(MPT_MAGIC_NUMBER,24,struct mpt_ioctl_diag_reset)
 #define MPTFWREPLACE		_IOWR(MPT_MAGIC_NUMBER,25,struct mpt_ioctl_replace_fw)
+#define MPTDIAGREGISTER		_IOWR(MPT_MAGIC_NUMBER,26,mpt_diag_register_t)
+#define MPTDIAGRELEASE		_IOWR(MPT_MAGIC_NUMBER,27,mpt_diag_release_t)
+#define MPTDIAGUNREGISTER	_IOWR(MPT_MAGIC_NUMBER,28,mpt_diag_unregister_t)
+#define MPTDIAGQUERY		_IOWR(MPT_MAGIC_NUMBER,29,mpt_diag_query_t)
+#define MPTDIAGREADBUFFER	_IOWR(MPT_MAGIC_NUMBER,30,mpt_diag_read_buffer_t)
+#define MPTHBAPCIINFO		_IOWR(MPT_MAGIC_NUMBER,31,struct mpt_ioctl_hbapciinfo)
+#define MPTDIAGRESET		_IOWR(MPT_MAGIC_NUMBER,32,struct mpt_ioctl_diag_reset)
 
 /*
- * SPARC PLATFORM REMARK:
+ * SPARC PLATFORM REMARKS:
  * IOCTL data structures that contain pointers
  * will have different sizes in the driver and applications
  * (as the app. will not use 8-byte pointers).
@@ -107,6 +107,8 @@
  * The driver will convert data from
  * mpt_fw_xfer32 (mpt_ioctl_command32) to mpt_fw_xfer (mpt_ioctl_command)
  * internally.
+ *
+ * If data structures change size, must handle as in IOCGETINFO.
  */
 struct mpt_fw_xfer {
 	unsigned int	 iocnum;	/* IOC unit number */
@@ -114,11 +116,11 @@ struct mpt_fw_xfer {
 	void		*bufp;		/* Pointer to firmware buffer */
 };
 
-#if defined(__KERNEL__) && defined(__sparc__) && defined(__sparc_v9__)		/*{*/
+#if defined(__KERNEL__) && defined(MPT_CONFIG_COMPAT)
 struct mpt_fw_xfer32 {
 	unsigned int iocnum;
 	unsigned int fwlen;
-	u32 bufp;
+	U32 bufp;
 };
 #endif	/*}*/
 
@@ -154,12 +156,24 @@ struct mpt_ioctl_diag_reset {
 struct mpt_ioctl_pci_info {
 	union {
 		struct {
-			unsigned long  deviceNumber   :  5;
-			unsigned long  functionNumber :  3;
-			unsigned long  busNumber      : 24;
+			unsigned int  deviceNumber   :  5;
+			unsigned int  functionNumber :  3;
+			unsigned int  busNumber      : 24;
+		} bits;
+		unsigned int  asUlong;
+	} u;
+};
+
+struct mpt_ioctl_pci_info2 {
+	union {
+		struct {
+			unsigned int  deviceNumber   :  5;
+			unsigned int  functionNumber :  3;
+			unsigned int  busNumber      : 24;
 		} bits;
-		unsigned long  asUlong;
+		unsigned int  asUlong;
 	} u;
+  int segmentID;
 };
 
 /*
@@ -167,8 +181,9 @@ struct mpt_ioctl_pci_info {
  *  Read only.
  *  Data starts at offset 0xC
  */
-#define MPT_IOCTL_INTERFACE_FC		(0x01)
 #define MPT_IOCTL_INTERFACE_SCSI	(0x00)
+#define MPT_IOCTL_INTERFACE_FC		(0x01)
+#define MPT_IOCTL_INTERFACE_SAS		(0x02)
 #define MPT_IOCTL_VERSION_LENGTH	(32)
 
 struct mpt_ioctl_iocinfo {
@@ -186,9 +201,48 @@ struct mpt_ioctl_iocinfo {
 	char		 busChangeEvent;
 	char		 hostId;
 	char		 rsvd[2];
+	struct mpt_ioctl_pci_info2  pciInfo; /* Added Rev 2 */
+};
+
+struct mpt_ioctl_iocinfo_rev1 {
+	mpt_ioctl_header hdr;
+	int		 adapterType;	/* SCSI or FCP */
+	int		 port;		/* port number */
+	int		 pciId;		/* PCI Id. */
+	int		 hwRev;		/* hardware revision */
+	int		 subSystemDevice;	/* PCI subsystem Device ID */
+	int		 subSystemVendor;	/* PCI subsystem Vendor ID */
+	int		 numDevices;		/* number of devices */
+	int		 FWVersion;		/* FW Version (integer) */
+	int		 BIOSVersion;		/* BIOS Version (integer) */
+	char		 driverVersion[MPT_IOCTL_VERSION_LENGTH];	/* Driver Version (string) */
+	char		 busChangeEvent;
+	char		 hostId;
+	char		 rsvd[2];
 	struct mpt_ioctl_pci_info  pciInfo; /* Added Rev 1 */
 };
 
+/* Original structure, must always accept these
+ * IOCTLs. 4 byte pads can occur based on arch with
+ * above structure. Wish to re-align, but cannot.
+ */
+struct mpt_ioctl_iocinfo_rev0 {
+	mpt_ioctl_header hdr;
+	int		 adapterType;	/* SCSI or FCP */
+	int		 port;		/* port number */
+	int		 pciId;		/* PCI Id. */
+	int		 hwRev;		/* hardware revision */
+	int		 subSystemDevice;	/* PCI subsystem Device ID */
+	int		 subSystemVendor;	/* PCI subsystem Vendor ID */
+	int		 numDevices;		/* number of devices */
+	int		 FWVersion;		/* FW Version (integer) */
+	int		 BIOSVersion;		/* BIOS Version (integer) */
+	char		 driverVersion[MPT_IOCTL_VERSION_LENGTH];	/* Driver Version (string) */
+	char		 busChangeEvent;
+	char		 hostId;
+	char		 rsvd[2];
+};
+
 /*
  * Device Information Page
  * Report the number of, and ids of, all targets
@@ -238,9 +292,9 @@ struct mpt_ioctl_eventreport {
 #define MPT_MAX_NAME	32
 struct mpt_ioctl_test {
 	mpt_ioctl_header hdr;
-	u8		 name[MPT_MAX_NAME];
+	U8		 name[MPT_MAX_NAME];
 	int		 chip_type;
-	u8		 product [MPT_PRODUCT_LENGTH];
+	U8		 product [MPT_PRODUCT_LENGTH];
 };
 
 /* Replace the FW image cached in host driver memory
@@ -250,10 +304,31 @@ struct mpt_ioctl_test {
 typedef struct mpt_ioctl_replace_fw {
 	mpt_ioctl_header hdr;
 	int		 newImageSize;
-	u8		 newImage[1];
+	U8		 newImage[1];
 } mpt_ioctl_replace_fw_t;
 
-/* General MPT Pass through data strucutre
+
+struct mpt_ioctl_mptpciinfo {
+    U8  iocNumber;
+    U8  iocState;
+    U8  revisionID;
+    U8  reserved1;
+    U16 vendorID; 
+    U16 deviceID;
+    U16 subSystemVendorID;
+    U16 subSystemID;
+};
+
+
+struct mpt_ioctl_hbapciinfo {
+	mpt_ioctl_header     hdr;
+    U8                   totalIOC;
+    U8                   reserved[3];
+    struct mpt_ioctl_mptpciinfo hbapciinfo[18];
+};
+
+
+/* General MPT Pass through data structure
  *
  * iocnum
  * timeout - in seconds, command timeout. If 0, set by driver to
@@ -292,14 +367,14 @@ struct mpt_ioctl_command {
 /*
  * SPARC PLATFORM: See earlier remark.
  */
-#if defined(__KERNEL__) && defined(__sparc__) && defined(__sparc_v9__)		/*{*/
+#if defined(__KERNEL__) && defined(MPT_CONFIG_COMPAT)
 struct mpt_ioctl_command32 {
 	mpt_ioctl_header hdr;
 	int	timeout;
-	u32	replyFrameBufPtr;
-	u32	dataInBufPtr;
-	u32	dataOutBufPtr;
-	u32	senseDataPtr;
+	U32	replyFrameBufPtr;
+	U32	dataInBufPtr;
+	U32	dataOutBufPtr;
+	U32	senseDataPtr;
 	int	maxReplyBytes;
 	int	dataInSize;
 	int	dataOutSize;
@@ -318,6 +393,7 @@ struct mpt_ioctl_command32 {
 #define CPQFCTS_IOC_MAGIC 'Z'
 #define HP_IOC_MAGIC 'Z'
 #define HP_GETHOSTINFO		_IOR(HP_IOC_MAGIC, 20, hp_host_info_t)
+#define HP_GETHOSTINFO1		_IOR(HP_IOC_MAGIC, 20, hp_host_info_rev0_t)
 #define HP_GETTARGETINFO	_IOR(HP_IOC_MAGIC, 21, hp_target_info_t)
 
 /* All HP IOCTLs must include this header
@@ -330,38 +406,61 @@ typedef struct _hp_header {
 	unsigned int lun;
 } hp_header_t;
 
-/*  
+/*
  *  Header:
  *  iocnum 	required (input)
- *  host 	ignored	
+ *  host 	ignored
  *  channe	ignored
  *  id		ignored
  *  lun		ignored
  */
 typedef struct _hp_host_info {
 	hp_header_t	 hdr;
-	u16		 vendor;
-	u16		 device;
-	u16		 subsystem_vendor;
-	u16		 subsystem_id;
-	u8		 devfn;
-	u8		 bus;
+	U16		 vendor;
+	U16		 device;
+	U16		 subsystem_vendor;
+	U16		 subsystem_id;
+	U8		 devfn;
+	U8		 bus;
+	ushort		 host_no;		/* SCSI Host number, if scsi driver not loaded*/
+	U8		 fw_version[16];	/* string */
+	U8		 serial_number[24];	/* string */
+	U32		 ioc_status;
+	U32		 bus_phys_width;
+	U32		 base_io_addr;
+	U32		 rsvd;
+	unsigned int	 hard_resets;		/* driver initiated resets */
+	unsigned int	 soft_resets;		/* ioc, external resets */
+	unsigned int	 timeouts;		/* num timeouts */
+} hp_host_info_t;
+
+/* replace ulongs with uints, need to preserve backwards
+ * compatibility.
+ */
+typedef struct _hp_host_info_rev0 {
+	hp_header_t	 hdr;
+	U16		 vendor;
+	U16		 device;
+	U16		 subsystem_vendor;
+	U16		 subsystem_id;
+	U8		 devfn;
+	U8		 bus;
 	ushort		 host_no;		/* SCSI Host number, if scsi driver not loaded*/
-	u8		 fw_version[16];	/* string */	
-	u8		 serial_number[24];	/* string */
-	u32		 ioc_status;	
-	u32		 bus_phys_width;
-	u32		 base_io_addr;
-	u32		 rsvd;
+	U8		 fw_version[16];	/* string */
+	U8		 serial_number[24];	/* string */
+	U32		 ioc_status;
+	U32		 bus_phys_width;
+	U32		 base_io_addr;
+	U32		 rsvd;
 	unsigned long	 hard_resets;		/* driver initiated resets */
 	unsigned long	 soft_resets;		/* ioc, external resets */
 	unsigned long	 timeouts;		/* num timeouts */
-} hp_host_info_t;
+} hp_host_info_rev0_t;
 
-/*  
+/*
  *  Header:
  *  iocnum 	required (input)
- *  host 	required	
+ *  host 	required
  *  channel	required	(bus number)
  *  id		required
  *  lun		ignored
@@ -370,13 +469,13 @@ typedef struct _hp_host_info {
  */
 typedef struct _hp_target_info {
 	hp_header_t	 hdr;
-	u32 parity_errors;
-	u32 phase_errors;
-	u32 select_timeouts;
-	u32 message_rejects;
-	u32 negotiated_speed;
-	u8  negotiated_width;
-	u8  rsvd[7];				/* 8 byte alignment */
+	U32 parity_errors;
+	U32 phase_errors;
+	U32 select_timeouts;
+	U32 message_rejects;
+	U32 negotiated_speed;
+	U8  negotiated_width;
+	U8  rsvd[7];				/* 8 byte alignment */
 } hp_target_info_t;
 
 #define HP_STATUS_OTHER		1
@@ -398,8 +497,106 @@ typedef struct _hp_target_info {
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
+#define MPI_FW_DIAG_IOCTL               (0x80646961)    // dia
+#define MPI_FW_DIAG_TYPE_REGISTER       (0x00000001)
+#define MPI_FW_DIAG_TYPE_UNREGISTER     (0x00000002)
+#define MPI_FW_DIAG_TYPE_QUERY          (0x00000003)
+#define MPI_FW_DIAG_TYPE_READ_BUFFER    (0x00000004)
+#define MPI_FW_DIAG_TYPE_RELEASE        (0x00000005)
+
+#define MPI_FW_DIAG_INVALID_UID         (0x00000000)
+#define FW_DIAGNOSTIC_BUFFER_COUNT      (3)
+#define FW_DIAGNOSTIC_UID_NOT_FOUND     (0xFF)
+
+#define MPI_FW_DIAG_ERROR_SUCCESS           (0x00000000)
+#define MPI_FW_DIAG_ERROR_FAILURE           (0x00000001)
+#define MPI_FW_DIAG_ERROR_INVALID_PARAMETER (0x00000002)
+#define MPI_FW_DIAG_ERROR_POST_FAILED       (0x00000010)
+#define MPI_FW_DIAG_ERROR_INVALID_UID       (0x00000011)
+#define MPI_FW_DIAG_ERROR_RELEASE_FAILED    (0x00000012)
+#define MPI_FW_DIAG_ERROR_NO_BUFFER         (0x00000013)
+#define MPI_FW_DIAG_ERROR_ALREADY_RELEASED  (0x00000014)
+
+#define MPT_DIAG_CAPABILITY(bufftype) (MPI_IOCFACTS_CAPABILITY_DIAG_TRACE_BUFFER << bufftype)
+
+typedef struct _MPI_FW_DIAG_REGISTER
+{
+    U8                  TraceLevel;
+    U8                  BufferType;
+    U16                 Flags;
+    U32                 ExtendedType;
+    U32                 ProductSpecific[4];
+    U32                 RequestedBufferSize;
+    U32                 UniqueId;
+} MPI_FW_DIAG_REGISTER, *PTR_MPI_FW_DIAG_REGISTER;
 
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+typedef struct _mpt_diag_register {
+	mpt_ioctl_header hdr;
+	MPI_FW_DIAG_REGISTER data;
+} mpt_diag_register_t;
 
-#endif
+typedef struct _MPI_FW_DIAG_UNREGISTER
+{
+    U32                 UniqueId;
+} MPI_FW_DIAG_UNREGISTER, *PTR_MPI_FW_DIAG_UNREGISTER;
+
+typedef struct _mpt_diag_unregister {
+	mpt_ioctl_header hdr;
+	MPI_FW_DIAG_UNREGISTER data;
+} mpt_diag_unregister_t;
+
+#define MPI_FW_DIAG_FLAG_APP_OWNED          (0x0001)
+#define MPI_FW_DIAG_FLAG_BUFFER_VALID       (0x0002)
+#define MPI_FW_DIAG_FLAG_FW_BUFFER_ACCESS   (0x0004)
+
+typedef struct _MPI_FW_DIAG_QUERY
+{
+    U8                  TraceLevel;
+    U8                  BufferType;
+    U16                 Flags;
+    U32                 ExtendedType;
+    U32                 ProductSpecific[4];
+    U32                 DataSize;
+    U32                 DriverAddedBufferSize;
+    U32                 UniqueId;
+} MPI_FW_DIAG_QUERY, *PTR_MPI_FW_DIAG_QUERY;
+
+typedef struct _mpt_diag_query {
+	mpt_ioctl_header hdr;
+	MPI_FW_DIAG_QUERY data;
+} mpt_diag_query_t;
 
+typedef struct _MPI_FW_DIAG_RELEASE
+{
+    U32                 UniqueId;
+} MPI_FW_DIAG_RELEASE, *PTR_MPI_FW_DIAG_RELEASE;
+
+typedef struct _mpt_diag_release {
+	mpt_ioctl_header hdr;
+	MPI_FW_DIAG_RELEASE data;
+} mpt_diag_release_t;
+
+#define MPI_FW_DIAG_FLAG_REREGISTER         (0x0001)
+
+typedef struct _MPI_FW_DIAG_READ_BUFFER
+{
+    U8                  Status;
+    U8                  Reserved;
+    U16                 Flags;
+    U32                 StartingOffset;
+    U32                 BytesToRead;
+    U32                 UniqueId;
+    U32                 DiagnosticData[1];
+} MPI_FW_DIAG_READ_BUFFER, *PTR_MPI_FW_DIAG_READ_BUFFER;
+
+typedef struct _mpt_diag_read_buffer {
+	mpt_ioctl_header hdr;
+	MPI_FW_DIAG_READ_BUFFER data;
+} mpt_diag_read_buffer_t;
+
+typedef struct _mpt_FWDownload_MF {
+	FWDownload_t	FWMessage;
+	U32		SGL_Word;
+} mpt_FWDownload_MF_t;
+
+#endif
diff -urNp linux-8145/drivers/message/fusion/mptlan.c linux-8150/drivers/message/fusion/mptlan.c
--- linux-8145/drivers/message/fusion/mptlan.c
+++ linux-8150/drivers/message/fusion/mptlan.c
@@ -1,32 +1,12 @@
 /*
  *  linux/drivers/message/fusion/mptlan.c
  *      IP Over Fibre Channel device driver.
- *      For use with PCI chip/adapter(s):
- *          LSIFC9xx/LSI409xx Fibre Channel
+ *      For use with LSI Logic Fibre Channel PCI chip/adapters
  *      running LSI Logic Fusion MPT (Message Passing Technology) firmware.
  *
- *  Credits:
- *      This driver would not exist if not for Alan Cox's development
- *      of the linux i2o driver.
+ *  Copyright (c) 2000-2005 LSI Logic Corporation
  *
- *      Special thanks goes to the I2O LAN driver people at the
- *      University of Helsinki, who, unbeknownst to them, provided
- *      the inspiration and initial structure for this driver.
- *
- *      A huge debt of gratitude is owed to David S. Miller (DaveM)
- *      for fixing much of the stupid and broken stuff in the early
- *      driver while porting to sparc64 platform.  THANK YOU!
- *
- *      A really huge debt of gratitude is owed to Eddie C. Dost
- *      for gobs of hard work fixing and optimizing LAN code.
- *      THANK YOU!
- *
- *      (see also mptbase.c)
- *
- *  Copyright (c) 2000-2002 LSI Logic Corporation
- *  Originally By: Noah Romer
- *
- *  $Id: mptlan.c,v 1.53 2002/10/17 20:15:58 pdelaney Exp $
+ *  $Id: mptlan.c,v 1.55 2003/05/07 14:08:32 Exp $
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -154,7 +134,7 @@ static int  mpt_lan_open(struct net_devi
 static int  mpt_lan_reset(struct net_device *dev);
 static int  mpt_lan_close(struct net_device *dev);
 static void mpt_lan_post_receive_buckets(void *dev_id);
-static void mpt_lan_wake_post_buckets_task(struct net_device *dev, 
+static void mpt_lan_wake_post_buckets_task(struct net_device *dev,
 					   int priority);
 static int  mpt_lan_receive_post_turbo(struct net_device *dev, u32 tmsg);
 static int  mpt_lan_receive_post_reply(struct net_device *dev,
@@ -176,11 +156,9 @@ static int LanCtx = -1;
 static u32 max_buckets_out = 127;
 static u32 tx_max_out_p = 127 - 16;
 
-static struct net_device *mpt_landev[MPT_MAX_ADAPTERS+1];
-
 #ifdef QLOGIC_NAA_WORKAROUND
 static struct NAA_Hosed *mpt_bad_naa = NULL;
-rwlock_t bad_naa_lock;
+rwlock_t bad_naa_lock = RW_LOCK_UNLOCKED;
 #endif
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -202,7 +180,7 @@ extern int mpt_lan_index;
 static int
 lan_reply (MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *reply)
 {
-	struct net_device *dev = mpt_landev[ioc->id];
+	struct net_device *dev = ioc->mpt_landev;
 	int FreeReqFrame = 0;
 
 	dioprintk((KERN_INFO MYNAM ": %s/%s: Got reply.\n",
@@ -222,7 +200,7 @@ lan_reply (MPT_ADAPTER *ioc, MPT_FRAME_H
 
 		// NOTE!  (Optimization) First case here is now caught in
 		//  mptbase.c::mpt_interrupt() routine and callcack here
-		//  is now skipped for this case!  20001218 -sralston
+		//  is now skipped for this case!
 #if 0
 		case LAN_REPLY_FORM_MESSAGE_CONTEXT:
 //			dioprintk((KERN_INFO MYNAM "/lan_reply: "
@@ -235,14 +213,14 @@ lan_reply (MPT_ADAPTER *ioc, MPT_FRAME_H
 //			dioprintk((MYNAM "/lan_reply: "
 //				  "calling mpt_lan_send_reply (turbo)\n"));
 
-			// Potential BUG here?  -sralston
+			// Potential BUG here?
 			//	FreeReqFrame = mpt_lan_send_turbo(dev, tmsg);
 			//  If/when mpt_lan_send_turbo would return 1 here,
 			//  calling routine (mptbase.c|mpt_interrupt)
 			//  would Oops because mf has already been set
 			//  to NULL.  So after return from this func,
 			//  mpt_interrupt() will attempt to put (NULL) mf ptr
-			//  item back onto it's adapter FreeQ - Oops!:-(
+			//  item back onto its adapter FreeQ - Oops!:-(
 			//  It's Ok, since mpt_lan_send_turbo() *currently*
 			//  always returns 0, but..., just in case:
 
@@ -311,8 +289,7 @@ lan_reply (MPT_ADAPTER *ioc, MPT_FRAME_H
 
 	case MPI_FUNCTION_EVENT_NOTIFICATION:
 	case MPI_FUNCTION_EVENT_ACK:
-		/* UPDATE!  20010120 -sralston
-		 *  _EVENT_NOTIFICATION should NOT come down this path any more.
+		/*  _EVENT_NOTIFICATION should NOT come down this path any more.
 		 *  Should be routed to mpt_lan_event_process(), but just in case...
 		 */
 		FreeReqFrame = 1;
@@ -328,6 +305,12 @@ lan_reply (MPT_ADAPTER *ioc, MPT_FRAME_H
 		break;
 	}
 
+#ifdef MPT_LAN_IO_DEBUG
+	if (FreeReqFrame == 0) {
+		dioprintk((MYIOC_s_WARN_FMT "lan_reply: does not return Request frame %p\n",
+			ioc->name, reply));
+	}
+#endif
 	return FreeReqFrame;
 }
 
@@ -335,16 +318,19 @@ lan_reply (MPT_ADAPTER *ioc, MPT_FRAME_H
 static int
 mpt_lan_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)
 {
-	struct net_device *dev = mpt_landev[ioc->id];
+	struct net_device *dev = ioc->mpt_landev;
 	struct mpt_lan_priv *priv = (struct mpt_lan_priv *) dev->priv;
 
 	dlprintk((KERN_INFO MYNAM ": IOC %s_reset routed to LAN driver!\n",
-			reset_phase==MPT_IOC_PRE_RESET ? "pre" : "post"));
+			reset_phase==MPT_IOC_SETUP_RESET ? "setup" : (
+			reset_phase==MPT_IOC_PRE_RESET ? "pre" : "post")));
 
 	if (priv->mpt_rxfidx == NULL)
 		return (1);
 
-	if (reset_phase == MPT_IOC_PRE_RESET) {
+	if (reset_phase == MPT_IOC_SETUP_RESET) {
+		;
+	} else if (reset_phase == MPT_IOC_PRE_RESET) {
 		int i;
 		unsigned long flags;
 
@@ -498,7 +484,7 @@ mpt_lan_reset(struct net_device *dev)
 	LANResetRequest_t *pResetReq;
 	struct mpt_lan_priv *priv = (struct mpt_lan_priv *)dev->priv;
 
-	mf = mpt_get_msg_frame(LanCtx, priv->mpt_dev->id);
+	mf = mpt_get_msg_frame(LanCtx, priv->mpt_dev);
 
 	if (mf == NULL) {
 /*		dlprintk((KERN_ERR MYNAM "/reset: Evil funkiness abounds! "
@@ -516,7 +502,7 @@ mpt_lan_reset(struct net_device *dev)
 	pResetReq->MsgFlags	= 0;
 	pResetReq->Reserved2	= 0;
 
-	mpt_put_msg_frame(LanCtx, priv->mpt_dev->id, mf);
+	mpt_put_msg_frame(LanCtx, priv->mpt_dev, mf);
 
 	return 0;
 }
@@ -719,6 +705,12 @@ out:
 		FreeReqFrame = 1;
 
 	netif_wake_queue(dev);
+#ifdef MPT_LAN_IO_DEBUG
+	if (FreeReqFrame == 0) {
+		dioprintk((MYIOC_s_WARN_FMT "mpt_lan_send_reply: does not return Request frame %p\n",
+			mpt_dev->name, pSendRep));
+	}
+#endif
 	return FreeReqFrame;
 }
 
@@ -750,7 +742,7 @@ mpt_lan_sdu_send (struct sk_buff *skb, s
 		return 1;
 	}
 
-	mf = mpt_get_msg_frame(LanCtx, mpt_dev->id);
+	mf = mpt_get_msg_frame(LanCtx, mpt_dev);
 	if (mf == NULL) {
 		netif_stop_queue(dev);
 		spin_unlock_irqrestore(&priv->txfidx_lock, flags);
@@ -855,7 +847,7 @@ mpt_lan_sdu_send (struct sk_buff *skb, s
 	else
 		pSimple->Address.High = 0;
 
-	mpt_put_msg_frame (LanCtx, mpt_dev->id, mf);
+	mpt_put_msg_frame (LanCtx, mpt_dev, mf);
 	dev->trans_start = jiffies;
 
 	dioprintk((KERN_INFO MYNAM ": %s/%s: Sending packet. FlagsLength = %08x.\n",
@@ -868,7 +860,7 @@ mpt_lan_sdu_send (struct sk_buff *skb, s
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 static inline void
 mpt_lan_wake_post_buckets_task(struct net_device *dev, int priority)
-/* 
+/*
  * @priority: 0 = put it on the timer queue, 1 = put it on the immediate queue
  */
 {
@@ -878,8 +870,6 @@ mpt_lan_wake_post_buckets_task(struct ne
 		if (priority) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,41)
 			schedule_work(&priv->post_buckets_task);
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,40)
-			schedule_task(&priv->post_buckets_task);
 #else
 			queue_task(&priv->post_buckets_task, &tq_immediate);
 			mark_bh(IMMEDIATE_BH);
@@ -887,8 +877,6 @@ mpt_lan_wake_post_buckets_task(struct ne
 		} else {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,41)
 			schedule_delayed_work(&priv->post_buckets_task, 1);
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,40)
-			schedule_task(&priv->post_buckets_task);
 #else
 			queue_task(&priv->post_buckets_task, &tq_timer);
 #endif
@@ -1191,7 +1179,7 @@ mpt_lan_receive_post_reply(struct net_de
 			remaining, atomic_read(&priv->buckets_out));
 	
 	if ((remaining < priv->bucketthresh) &&
-	    ((atomic_read(&priv->buckets_out) - remaining) > 
+	    ((atomic_read(&priv->buckets_out) - remaining) >
 	     MPT_LAN_BUCKETS_REMAIN_MISMATCH_THRESH)) {
 		
 		printk (KERN_WARNING MYNAM " Mismatch between driver's "
@@ -1239,7 +1227,7 @@ mpt_lan_post_receive_buckets(void *dev_i
 			(MPT_LAN_TRANSACTION32_SIZE + sizeof(SGESimple64_t));
 
 	while (buckets) {
-		mf = mpt_get_msg_frame(LanCtx, mpt_dev->id);
+		mf = mpt_get_msg_frame(LanCtx, mpt_dev);
 		if (mf == NULL) {
 			printk (KERN_ERR "%s: Unable to alloc request frame\n",
 				__FUNCTION__);
@@ -1249,6 +1237,9 @@ mpt_lan_post_receive_buckets(void *dev_i
 		}
 		pRecvReq = (LANReceivePostRequest_t *) mf;
 
+		i = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
+		mpt_dev->RequestNB[i] = 0;
+
 		count = buckets;
 		if (count > max)
 			count = max;
@@ -1329,7 +1320,7 @@ mpt_lan_post_receive_buckets(void *dev_i
 		if (pSimple == NULL) {
 /**/			printk (KERN_WARNING MYNAM "/%s: No buckets posted\n",
 /**/				__FUNCTION__);
-			mpt_free_msg_frame(LanCtx, mpt_dev->id, mf);
+			mpt_free_msg_frame(mpt_dev, mf);
 			goto out;
 		}
 
@@ -1343,7 +1334,7 @@ mpt_lan_post_receive_buckets(void *dev_i
  *	printk ("\n");
  */
 
-		mpt_put_msg_frame(LanCtx, mpt_dev->id, mf);
+		mpt_put_msg_frame(LanCtx, mpt_dev, mf);
 
 		priv->total_posted += i;
 		buckets -= i;
@@ -1447,7 +1438,7 @@ int __init
 mpt_lan_init (void)
 {
 	struct net_device *dev;
-	MPT_ADAPTER *curadapter;
+	MPT_ADAPTER *ioc;
 	int i, j;
 
 	show_mptmod_ver(LANAME, LANVER);
@@ -1471,30 +1462,24 @@ mpt_lan_init (void)
 	if (mpt_reset_register(LanCtx, mpt_lan_ioc_reset) == 0) {
 		dlprintk((KERN_INFO MYNAM ": Registered for IOC reset notifications\n"));
 	} else {
-		printk(KERN_ERR MYNAM ": Eieee! unable to register a reset "
-		       "handler with mptbase! The world is at an end! "
-		       "Everything is fading to black! Goodbye.\n");
+		printk(KERN_ERR MYNAM ": Unable to register a reset "
+		       "handler with mptbase!\n");
 		return -EBUSY;
 	}
 
-	for (j = 0; j < MPT_MAX_ADAPTERS; j++) {
-		mpt_landev[j] = NULL;
-	}
-
-	curadapter = mpt_adapter_find_first();
-	while (curadapter != NULL) {
-		for (i = 0; i < curadapter->facts.NumberOfPorts; i++) {
+	list_for_each_entry(ioc,&ioc_list,list) {
+		for (i = 0; i < ioc->facts.NumberOfPorts; i++) {
 			printk (KERN_INFO MYNAM ": %s: PortNum=%x, ProtocolFlags=%02Xh (%c%c%c%c)\n",
-					curadapter->name,
-					curadapter->pfacts[i].PortNumber,
-					curadapter->pfacts[i].ProtocolFlags,
-					MPT_PROTOCOL_FLAGS_c_c_c_c(curadapter->pfacts[i].ProtocolFlags));
+					ioc->name,
+					ioc->pfacts[i].PortNumber,
+					ioc->pfacts[i].ProtocolFlags,
+					MPT_PROTOCOL_FLAGS_c_c_c_c(ioc->pfacts[i].ProtocolFlags));
 
-			if (curadapter->pfacts[i].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN) {
-				dev = mpt_register_lan_device (curadapter, i);
+			if (ioc->pfacts[i].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN) {
+				dev = mpt_register_lan_device (ioc, i);
 				if (dev != NULL) {
 					printk (KERN_INFO MYNAM ": %s: Fusion MPT LAN device registered as '%s'\n",
-							curadapter->name, dev->name);
+							ioc->name, dev->name);
 					printk (KERN_INFO MYNAM ": %s/%s: LanAddr = %02X:%02X:%02X:%02X:%02X:%02X\n",
 							IOC_AND_NETDEV_NAMES_s_s(dev),
 							dev->dev_addr[0], dev->dev_addr[1],
@@ -1503,41 +1488,40 @@ mpt_lan_init (void)
 //					printk (KERN_INFO MYNAM ": %s/%s: Max_TX_outstanding = %d\n",
 //							IOC_AND_NETDEV_NAMES_s_s(dev),
 //							NETDEV_TO_LANPRIV_PTR(dev)->tx_max_out);
-					j = curadapter->id;
-					mpt_landev[j] = dev;
+					ioc->mpt_landev = dev;
 					dlprintk((KERN_INFO MYNAM "/init: dev_addr=%p, mpt_landev[%d]=%p\n",
-							dev, j,  mpt_landev[j]));
+						dev, ioc->id, ioc->mpt_landev));
 
 				} else {
 					printk (KERN_ERR MYNAM ": %s: Unable to register port%d as a LAN device\n",
-							curadapter->name,
-							curadapter->pfacts[i].PortNumber);
+							ioc->name,
+							ioc->pfacts[i].PortNumber);
 				}
 			} else {
 				printk (KERN_INFO MYNAM ": %s: Hmmm... LAN protocol seems to be disabled on this adapter port!\n",
-						curadapter->name);
+						ioc->name);
 			}
 		}
-		curadapter = mpt_adapter_find_next(curadapter);
 	}
 
 	return 0;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-void __init mpt_lan_exit(void)
+static void mpt_lan_exit(void)
 {
-	int i;
+	MPT_ADAPTER *ioc;
 
 	mpt_reset_deregister(LanCtx);
 
-	for (i = 0; mpt_landev[i] != NULL; i++) {
-		struct net_device *dev = mpt_landev[i];
+	list_for_each_entry(ioc,&ioc_list,list) {
+		struct net_device *dev = ioc->mpt_landev;
 
-		printk (KERN_INFO MYNAM ": %s/%s: Fusion MPT LAN device unregistered\n",
+		if ( dev ) {
+			printk (KERN_INFO ": %s/%s: Fusion MPT LAN device unregistered\n",
 			       IOC_AND_NETDEV_NAMES_s_s(dev));
-		unregister_fcdev(dev);
-		mpt_landev[i] = (struct net_device *) 0xdeadbeef; /* Debug */
+			unregister_fcdev(dev);
+		}
 	}
 
 	if (LanCtx >= 0) {
@@ -1550,9 +1534,10 @@ void __init mpt_lan_exit(void)
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,59)
 MODULE_PARM(tx_max_out_p, "i");
 MODULE_PARM(max_buckets_out, "i"); // Debug stuff. FIXME!
+#endif
 
 module_init(mpt_lan_init);
 module_exit(mpt_lan_exit);
diff -urNp linux-8145/drivers/message/fusion/mptlan.h linux-8150/drivers/message/fusion/mptlan.h
--- linux-8145/drivers/message/fusion/mptlan.h
+++ linux-8150/drivers/message/fusion/mptlan.h
@@ -29,8 +29,9 @@
 #include <asm/io.h>
 
     /* Override mptbase.h by pre-defining these! */
-    #define MODULEAUTHOR "Noah Romer, Eddie C. Dost"
+    #define MODULEAUTHOR "LSI Logic"
 
+#include "linux_compat.h"	/* linux-2.2.x (vs. -2.4.x) tweaks */
 #include "mptbase.h"
 
 /*****************************************************************************/
diff -urNp linux-8145/drivers/message/fusion/mptscsih.c linux-8150/drivers/message/fusion/mptscsih.c
--- linux-8145/drivers/message/fusion/mptscsih.c
+++ linux-8150/drivers/message/fusion/mptscsih.c
@@ -1,32 +1,13 @@
 /*
  *  linux/drivers/message/fusion/mptscsih.c
- *      High performance SCSI / Fibre Channel SCSI Host device driver.
- *      For use with PCI chip/adapter(s):
- *          LSIFC9xx/LSI409xx Fibre Channel
+ *      For use with LSI Logic PCI chip/adapter(s)
  *      running LSI Logic Fusion MPT (Message Passing Technology) firmware.
  *
- *  Credits:
- *      This driver would not exist if not for Alan Cox's development
- *      of the linux i2o driver.
- *
- *      A special thanks to Pamela Delaney (LSI Logic) for tons of work
- *      and countless enhancements while adding support for the 1030
- *      chip family.  Pam has been instrumental in the development of
- *      of the 2.xx.xx series fusion drivers, and her contributions are
- *      far too numerous to hope to list in one place.
- *
- *      A huge debt of gratitude is owed to David S. Miller (DaveM)
- *      for fixing much of the stupid and broken stuff in the early
- *      driver while porting to sparc64 platform.  THANK YOU!
- *
- *      (see mptbase.c)
- *
- *  Copyright (c) 1999-2002 LSI Logic Corporation
- *  Original author: Steven J. Ralston
- *  (mailto:sjralston1@netscape.net)
- *  (mailto:lstephen@lsil.com)
+ *  Copyright (c) 1999-2005 LSI Logic Corporation
+ *  (mailto:mpt_linux_developer@lsil.com)
+ *  For support, send a description of issues to: support@lsil.com.
  *
- *  $Id: mptscsih.c,v 1.106 2003/01/28 21:31:57 pdelaney Exp $
+ *  $Id: mptscsih.c,v 1.1.2.4 2003/05/07 14:08:34 Exp $
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -82,6 +63,7 @@
 #include "../../scsi/sd.h"
 #endif
 
+#include "linux_compat.h"	/* linux-2.2.x (vs. -2.4.x) tweaks */
 #include "mptbase.h"
 #include "mptscsih.h"
 #include "isense.h"
@@ -95,11 +77,29 @@ MODULE_AUTHOR(MODULEAUTHOR);
 MODULE_DESCRIPTION(my_NAME);
 MODULE_LICENSE("GPL");
 
+extern int mpt_can_queue;
+extern int mpt_sg_tablesize;
+
 /* Set string for command line args from insmod */
-#ifdef MODULE
-char *mptscsih = 0;
-MODULE_PARM(mptscsih, "s");
-#endif
+char *mptscsih = NULL;
+static int mpt_dv = 1;
+static int mpt_width = 1;
+static int mpt_factor = 0x08;
+static int mpt_saf_te = 0;
+static int mpt_pt_clear = 0;
+static int mpt_pq_filter = 0;
+MODULE_PARM(mpt_dv, "i");
+MODULE_PARM_DESC(mpt_dv, " DV Algorithm: enhanced = 1, basic = 0 (default=1)");
+MODULE_PARM(mpt_width, "i");
+MODULE_PARM_DESC(mpt_width, " Max Bus Width: wide = 1, narrow = 0 (default=1)");
+MODULE_PARM(mpt_factor, "h");
+MODULE_PARM_DESC(mpt_factor, " Sync Factor (default=0x08)");
+MODULE_PARM(mpt_saf_te, "i");
+MODULE_PARM_DESC(mpt_saf_te, " Force enabling SEP Processor: enable=1 (default=0)");
+MODULE_PARM(mpt_pt_clear, "i");
+MODULE_PARM_DESC(mpt_pt_clear, " Clear persistency table: enable=1 (default=0)");
+MODULE_PARM(mpt_pq_filter, "i");
+MODULE_PARM_DESC(mpt_pq_filter, " Enable peripheral qualifier filter: enable=1 (default=0)");
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
@@ -113,14 +113,16 @@ typedef struct _BIG_SENSE_BUF {
 #define MPT_SCANDV_SOME_ERROR		(0x00000004)
 #define MPT_SCANDV_SELECTION_TIMEOUT	(0x00000008)
 #define MPT_SCANDV_ISSUE_SENSE		(0x00000010)
+#define MPT_SCANDV_FALLBACK		(0x00000020)
 
 #define MPT_SCANDV_MAX_RETRIES		(10)
 
 #define MPT_ICFLAG_BUF_CAP	0x01	/* ReadBuffer Read Capacity format */
 #define MPT_ICFLAG_ECHO		0x02	/* ReadBuffer Echo buffer format */
-#define MPT_ICFLAG_PHYS_DISK	0x04	/* Any SCSI IO but do Phys Disk Format */
-#define MPT_ICFLAG_TAGGED_CMD	0x08	/* Do tagged IO */
-#define MPT_ICFLAG_DID_RESET	0x20	/* Bus Reset occured with this command */
+#define MPT_ICFLAG_EBOS		0x04	/* ReadBuffer Echo buffer has EBOS */
+#define MPT_ICFLAG_PHYS_DISK	0x08	/* Any SCSI IO but do Phys Disk Format */
+#define MPT_ICFLAG_TAGGED_CMD	0x10	/* Do tagged IO */
+#define MPT_ICFLAG_DID_RESET	0x20	/* Bus Reset occurred with this command */
 #define MPT_ICFLAG_RESERVED	0x40	/* Reserved has been issued */
 
 typedef struct _internal_cmd {
@@ -156,14 +158,16 @@ typedef struct _dv_parameters {
 /*
  *  Other private/forward protos...
  */
+#ifdef MPT_DEBUG_QCMD_DEPTH
+static void mptscsih_scsi_done(MPT_ADAPTER *ioc, Scsi_Cmnd *SCpnt);
+#endif
 static int	mptscsih_io_done(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *r);
 static void	mptscsih_report_queue_full(Scsi_Cmnd *sc, SCSIIOReply_t *pScsiReply, SCSIIORequest_t *pScsiReq);
 static int	mptscsih_taskmgmt_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *r);
 
-static int	mptscsih_AddSGE(MPT_SCSI_HOST *hd, Scsi_Cmnd *SCpnt,
+static int	mptscsih_AddSGE(MPT_ADAPTER *ioc, Scsi_Cmnd *SCpnt,
 				 SCSIIORequest_t *pReq, int req_idx);
-static void	mptscsih_freeChainBuffers(MPT_SCSI_HOST *hd, int req_idx);
-static int	mptscsih_initChainBuffers (MPT_SCSI_HOST *hd, int init);
+static void	mptscsih_freeChainBuffers(MPT_ADAPTER *ioc, int req_idx);
 static void	copy_sense_data(Scsi_Cmnd *sc, MPT_SCSI_HOST *hd, MPT_FRAME_HDR *mf, SCSIIOReply_t *pScsiReply);
 #ifndef MPT_SCSI_USE_NEW_EH
 static void	search_taskQ_for_cmd(Scsi_Cmnd *sc, MPT_SCSI_HOST *hd);
@@ -174,38 +178,41 @@ static u32	SCPNT_TO_LOOKUP_IDX(Scsi_Cmnd
 static MPT_FRAME_HDR *mptscsih_search_pendingQ(MPT_SCSI_HOST *hd, int scpnt_idx);
 static void	post_pendingQ_commands(MPT_SCSI_HOST *hd);
 
-static int	mptscsih_TMHandler(MPT_SCSI_HOST *hd, u8 type, u8 target, u8 lun, int ctx2abort, int sleepFlag);
-static int	mptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd, u8 type, u8 target, u8 lun, int ctx2abort, int sleepFlag);
+static int	mptscsih_TMHandler(MPT_SCSI_HOST *hd, u8 type, u8 channel, u8 target, u8 lun, int ctx2abort, int sleepFlag);
+static int	mptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd, u8 type, u8 channel, u8 target, u8 lun, int ctx2abort, int sleepFlag);
 
 static int	mptscsih_ioc_reset(MPT_ADAPTER *ioc, int post_reset);
 static int	mptscsih_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply);
 
-static VirtDevice	*mptscsih_initTarget(MPT_SCSI_HOST *hd, int bus_id, int target_id, u8 lun, char *data, int dlen);
-void		mptscsih_setTargetNegoParms(MPT_SCSI_HOST *hd, VirtDevice *target, char byte56);
-#ifdef MPT_SAVE_AUTOSENSE
-static void	clear_sense_flag(MPT_SCSI_HOST *hd, SCSIIORequest_t *pReq);
-#endif
+static void	mptscsih_initTarget(MPT_SCSI_HOST *hd, int bus_id, int target_id, u8 lun, char *data, int dlen);
+static void		mptscsih_setTargetNegoParms(MPT_SCSI_HOST *hd, VirtDevice *target, char byte56);
 static void	mptscsih_set_dvflags(MPT_SCSI_HOST *hd, SCSIIORequest_t *pReq);
 static void	mptscsih_setDevicePage1Flags (u8 width, u8 factor, u8 offset, int *requestedPtr, int *configurationPtr, u8 flags);
 static void	mptscsih_no_negotiate(MPT_SCSI_HOST *hd, int target_id);
 static int	mptscsih_writeSDP1(MPT_SCSI_HOST *hd, int portnum, int target, int flags);
+static int	mptscsih_writeIOCPage4(MPT_SCSI_HOST *hd, int target_id, int bus);
+static int	mptscsih_readFCDevicePage0(MPT_SCSI_HOST *hd, int target_id);
+static int	mptscsih_writeFCPortPage3(MPT_SCSI_HOST *hd, int target_id);
+static int	mptscsih_sendIOCInit(MPT_SCSI_HOST *hd);
 static int	mptscsih_scandv_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *r);
 static void	mptscsih_timer_expired(unsigned long data);
 static void	mptscsih_taskmgmt_timeout(unsigned long data);
 static int	mptscsih_do_cmd(MPT_SCSI_HOST *hd, INTERNAL_CMD *iocmd);
 static int	mptscsih_synchronize_cache(MPT_SCSI_HOST *hd, int portnum);
 
-#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+static struct mpt_work_struct	mptscsih_persistTask;
+
+#ifdef MPTSCSIH_ENABLE_DOMAIN_VALIDATION
 static int	mptscsih_do_raid(MPT_SCSI_HOST *hd, u8 action, INTERNAL_CMD *io);
 static void	mptscsih_domainValidation(void *hd);
 static int	mptscsih_is_phys_disk(MPT_ADAPTER *ioc, int id);
 static void	mptscsih_qas_check(MPT_SCSI_HOST *hd, int id);
-static int	mptscsih_doDv(MPT_SCSI_HOST *hd, int portnum, int target);
+static int	mptscsih_doDv(MPT_SCSI_HOST *hd, int channel, int target);
 static void	mptscsih_dv_parms(MPT_SCSI_HOST *hd, DVPARAMETERS *dv,void *pPage);
 static void	mptscsih_fillbuf(char *buffer, int size, int index, int width);
 #endif
-static int	mptscsih_setup(char *str);
 static int	mptscsih_halt(struct notifier_block *nb, ulong event, void *buf);
+static void	mptscsih_sas_persist_clear_table(void *arg);
 
 /*
  *	Reboot Notification
@@ -219,7 +226,6 @@ static struct notifier_block mptscsih_no
  */
 
 static int	mpt_scsi_hosts = 0;
-static atomic_t	queue_depth;
 
 static int	ScsiDoneCtx = -1;
 static int	ScsiTaskCtx = -1;
@@ -249,7 +255,7 @@ static struct mpt_work_struct	mptscsih_p
 static atomic_t	mpt_taskQdepth;
 #endif
 
-#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+#ifdef MPTSCSIH_ENABLE_DOMAIN_VALIDATION
 /*
  * Domain Validation task structure
  */
@@ -265,23 +271,17 @@ static struct mpt_work_struct	mptscsih_d
 static DECLARE_WAIT_QUEUE_HEAD (scandv_waitq);
 static int scandv_wait_done = 1;
 
-/* Driver default setup
- */
-static struct mptscsih_driver_setup
-	driver_setup = MPTSCSIH_DRIVER_SETUP;
-
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *  Private inline routines...
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/* 19991030 -sralston
- *  Return absolute SCSI data direction:
+/*  Return absolute SCSI data direction:
  *     1 = _DATA_OUT
  *     0 = _DIR_NONE
  *    -1 = _DATA_IN
  *
- * Changed: 3-20-2002 pdelaney to use the default data
+ * Changed to use the default data
  * direction and the defines set up in the
  * 2.4 kernel series
  *     1 = _DATA_OUT	changed to SCSI_DATA_WRITE (1)
@@ -299,10 +299,12 @@ mptscsih_io_direction(Scsi_Cmnd *cmd)
 	switch (cmd->cmnd[0]) {
 	case WRITE_6:		
 	case WRITE_10:		
+	case 0x88:		/* READ_16 */
 		return SCSI_DATA_WRITE;
 		break;
 	case READ_6:		
 	case READ_10:		
+	case 0x8A:		/* WRITE_16 */
 		return SCSI_DATA_READ;
 		break;
 	}
@@ -361,6 +363,7 @@ mptscsih_io_direction(Scsi_Cmnd *cmd)
 	}
 } /* mptscsih_io_direction() */
 
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mptscsih_add_sge - Place a simple SGE at address pAddr.
@@ -427,40 +430,44 @@ mptscsih_add_chain(char *pAddr, u8 next,
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
- *	mptscsih_getFreeChainBuffes - Function to get a free chain
+ *	mptscsih_getFreeChainBuffer - Function to get a free chain
  *	from the MPT_SCSI_HOST FreeChainQ.
- *	@hd: Pointer to the MPT_SCSI_HOST instance
+ *	@ioc: Pointer to MPT_ADAPTER structure
  *	@req_idx: Index of the SCSI IO request frame. (output)
  *
  *	return SUCCESS or FAILED
  */
 static inline int
-mptscsih_getFreeChainBuffer(MPT_SCSI_HOST *hd, int *retIndex)
+mptscsih_getFreeChainBuffer(MPT_ADAPTER *ioc, int *retIndex)
 {
-	MPT_FRAME_HDR *chainBuf = NULL;
+	MPT_FRAME_HDR *chainBuf;
 	unsigned long flags;
-	int rc = FAILED;
-	int chain_idx = MPT_HOST_NO_CHAIN;
-
-	spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
-	if (!Q_IS_EMPTY(&hd->FreeChainQ)) {
+	int rc;
+	int chain_idx;
 
+	dsgprintk((MYIOC_s_WARN_FMT "getFreeChainBuffer called\n",
+			ioc->name));
+	spin_lock_irqsave(&ioc->FreeQlock, flags);
+	if (!Q_IS_EMPTY(&ioc->FreeChainQ)) {
 		int offset;
 
-		chainBuf = hd->FreeChainQ.head;
+		chainBuf = ioc->FreeChainQ.head;
 		Q_DEL_ITEM(&chainBuf->u.frame.linkage);
-		offset = (u8 *)chainBuf - (u8 *)hd->ChainBuffer;
-		chain_idx = offset / hd->ioc->req_sz;
+		offset = (u8 *)chainBuf - (u8 *)ioc->ChainBuffer;
+		chain_idx = offset / ioc->req_sz;
 		rc = SUCCESS;
+		dsgprintk((MYIOC_s_ERR_FMT "getFreeChainBuffer chainBuf=%p ChainBuffer=%p offset=%d chain_idx=%d\n",
+			ioc->name, chainBuf, ioc->ChainBuffer, offset, chain_idx));
+	} else {
+		rc = FAILED;
+		chain_idx = MPT_HOST_NO_CHAIN;
+		dfailprintk((MYIOC_s_WARN_FMT "getFreeChainBuffer failed\n",
+			ioc->name));
 	}
-	spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
-
+	spin_unlock_irqrestore(&ioc->FreeQlock, flags);
 
 	*retIndex = chain_idx;
 
-	dsgprintk((MYIOC_s_INFO_FMT "getFreeChainBuffer (index %d), got buf=%p\n",
-			hd->ioc->name, *retIndex, chainBuf));
-
 	return rc;
 } /* mptscsih_getFreeChainBuffer() */
 
@@ -468,14 +475,14 @@ mptscsih_getFreeChainBuffer(MPT_SCSI_HOS
 /*
  *	mptscsih_AddSGE - Add a SGE (plus chain buffers) to the
  *	SCSIIORequest_t Message Frame.
- *	@hd: Pointer to MPT_SCSI_HOST structure
+ *	@ioc: Pointer to MPT_ADAPTER structure
  *	@SCpnt: Pointer to Scsi_Cmnd structure
  *	@pReq: Pointer to SCSIIORequest_t structure
  *
  *	Returns ...
  */
 static int
-mptscsih_AddSGE(MPT_SCSI_HOST *hd, Scsi_Cmnd *SCpnt,
+mptscsih_AddSGE(MPT_ADAPTER *ioc, Scsi_Cmnd *SCpnt,
 		SCSIIORequest_t *pReq, int req_idx)
 {
 	char 	*psge;
@@ -491,6 +498,7 @@ mptscsih_AddSGE(MPT_SCSI_HOST *hd, Scsi_
 	int	 newIndex;
 	int	 ii;
 	dma_addr_t v2;
+	u32	RequestNB;
 
 	sgdir = le32_to_cpu(pReq->Control) & MPI_SCSIIO_CONTROL_DATADIRECTION_MASK;
 	if (sgdir == MPI_SCSIIO_CONTROL_WRITE)  {
@@ -500,36 +508,28 @@ mptscsih_AddSGE(MPT_SCSI_HOST *hd, Scsi_
 	}
 
 	psge = (char *) &pReq->SGL;
-	frm_sz = hd->ioc->req_sz;
+	frm_sz = ioc->req_sz;
 
 	/* Map the data portion, if any.
 	 * sges_left  = 0 if no data transfer.
 	 */
-	sges_left = SCpnt->use_sg;
-	if (SCpnt->use_sg) {
-		sges_left = pci_map_sg(hd->ioc->pcidev,
+	if ( (sges_left = SCpnt->use_sg) ) {
+		sges_left = pci_map_sg(ioc->pcidev,
 			       (struct scatterlist *) SCpnt->request_buffer,
-			       SCpnt->use_sg,
-			       scsi_to_pci_dma_dir(SCpnt->sc_data_direction));
+ 			       SCpnt->use_sg,
+			       SCpnt->sc_data_direction);
+		if (sges_left == 0)
+			return FAILED;
 	} else if (SCpnt->request_bufflen) {
-		dma_addr_t	 buf_dma_addr;
-		scPrivate	*my_priv;
-
-		buf_dma_addr = pci_map_single(hd->ioc->pcidev,
+		SCpnt->SCp.dma_handle = pci_map_single(ioc->pcidev,
 				      SCpnt->request_buffer,
 				      SCpnt->request_bufflen,
-				      scsi_to_pci_dma_dir(SCpnt->sc_data_direction));
-
-		/* We hide it here for later unmap. */
-		my_priv = (scPrivate *) &SCpnt->SCp;
-		my_priv->p1 = (void *)(ulong) buf_dma_addr;
-
-		dsgprintk((MYIOC_s_INFO_FMT "SG: non-SG for %p, len=%d\n",
-				hd->ioc->name, SCpnt, SCpnt->request_bufflen));
-
+				      SCpnt->sc_data_direction);
+		dsgprintk((MYIOC_s_WARN_FMT "SG: non-SG for %p, len=%d\n",
+				ioc->name, SCpnt, SCpnt->request_bufflen));
 		mptscsih_add_sge((char *) &pReq->SGL,
 			0xD1000000|MPT_SGE_FLAGS_ADDRESSING|sgdir|SCpnt->request_bufflen,
-			buf_dma_addr);
+			SCpnt->SCp.dma_handle);
 
 		return SUCCESS;
 	}
@@ -601,12 +601,15 @@ nextSGEset:
 			 * Update the chain element
 			 * Offset and Length fields.
 			 */
-			mptscsih_add_chain((char *)chainSge, 0, sgeOffset, hd->ChainBufferDMA + chain_dma_off);
+			mptscsih_add_chain((char *)chainSge, 0, sgeOffset, ioc->ChainBufferDMA + chain_dma_off);
 		} else {
 			/* The current buffer is the original MF
 			 * and there is no Chain buffer.
 			 */
 			pReq->ChainOffset = 0;
+			RequestNB = (((sgeOffset - 1) >> ioc->NBShiftFactor)  + 1) & 0x03;
+			dsgprintk((MYIOC_s_WARN_FMT "Single Buffer RequestNB=%x, sgeOffset=%d\n", ioc->name, RequestNB, sgeOffset));
+			ioc->RequestNB[req_idx] = RequestNB;
 		}
 	} else {
 		/* At least one chain buffer is needed.
@@ -620,8 +623,8 @@ nextSGEset:
 		 * Loop until done.
 		 */
 
-		dsgprintk((MYIOC_s_INFO_FMT "SG: Chain Required! sg done %d\n",
-				hd->ioc->name, sg_done));
+		dsgprintk((MYIOC_s_WARN_FMT "SG: Chain Required! sg done %d\n",
+				ioc->name, sg_done));
 
 		/* Set LAST_ELEMENT flag for last non-chain element
 		 * in the buffer. Since psge points at the NEXT
@@ -645,13 +648,16 @@ nextSGEset:
 			 */
 			u8 nextChain = (u8) (sgeOffset >> 2);
 			sgeOffset += (sizeof(u32) + sizeof(dma_addr_t));
-			mptscsih_add_chain((char *)chainSge, nextChain, sgeOffset, hd->ChainBufferDMA + chain_dma_off);
+			mptscsih_add_chain((char *)chainSge, nextChain, sgeOffset, ioc->ChainBufferDMA + chain_dma_off);
 		} else {
 			/* The original MF buffer requires a chain buffer -
 			 * set the offset.
 			 * Last element in this MF is a chain element.
 			 */
 			pReq->ChainOffset = (u8) (sgeOffset >> 2);
+			RequestNB = (((sgeOffset - 1) >> ioc->NBShiftFactor)  + 1) & 0x03;
+			dsgprintk((MYIOC_s_ERR_FMT "Chain Buffer Needed, RequestNB=%x sgeOffset=%d\n", ioc->name, RequestNB, sgeOffset));
+			ioc->RequestNB[req_idx] = RequestNB;
 		}
 
 		sges_left -= sg_done;
@@ -660,19 +666,22 @@ nextSGEset:
 		/* NOTE: psge points to the beginning of the chain element
 		 * in current buffer. Get a chain buffer.
 		 */
-		if ((mptscsih_getFreeChainBuffer(hd, &newIndex)) == FAILED)
+		if ((mptscsih_getFreeChainBuffer(ioc, &newIndex)) == FAILED) {
+			dfailprintk((MYIOC_s_WARN_FMT "getFreeChainBuffer FAILED SCSI cmd=%02x (%p)\n",
+ 			ioc->name, pReq->CDB[0], SCpnt));
 			return FAILED;
+		}
 
 		/* Update the tracking arrays.
 		 * If chainSge == NULL, update ReqToChain, else ChainToChain
 		 */
 		if (chainSge) {
-			hd->ChainToChain[chain_idx] = newIndex;
+			ioc->ChainToChain[chain_idx] = newIndex;
 		} else {
-			hd->ReqToChain[req_idx] = newIndex;
+			ioc->ReqToChain[req_idx] = newIndex;
 		}
 		chain_idx = newIndex;
-		chain_dma_off = hd->ioc->req_sz * chain_idx;
+		chain_dma_off = ioc->req_sz * chain_idx;
 
 		/* Populate the chainSGE for the current buffer.
 		 * - Set chain buffer pointer to psge and fill
@@ -684,7 +693,7 @@ nextSGEset:
 
 		/* Start the SGE for the next buffer
 		 */
-		psge = (char *) (hd->ChainBuffer + chain_dma_off);
+		psge = (char *) (ioc->ChainBuffer + chain_dma_off);
 		sgeOffset = 0;
 		sg_done = 0;
 
@@ -725,80 +734,124 @@ mptscsih_io_done(MPT_ADAPTER *ioc, MPT_F
 #if LINUX_VERSION_CODE <= KERNEL_VERSION(2,5,0)
 	unsigned long	 flags;
 #endif
-	u16		 req_idx;
+	u16		 req_idx, req_idx_MR;
 
 	hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
 
-	if ((mf == NULL) ||
-	    (mf >= MPT_INDEX_2_MFPTR(ioc, ioc->req_depth))) {
-		printk(MYIOC_s_ERR_FMT "%s req frame ptr! (=%p)!\n",
-				ioc->name, mf?"BAD":"NULL", (void *) mf);
+	req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
+	req_idx_MR = (mr != NULL) ?
+	    le16_to_cpu(mr->u.frame.hwhdr.msgctxu.fld.req_idx) : req_idx;
+	if ((req_idx != req_idx_MR) ||
+	    (mf->u.frame.linkage.arg1 == 0xdeadbeaf)) {
+		printk(MYIOC_s_ERR_FMT "Received a mf that was already freed\n",
+		    ioc->name);
+		printk (MYIOC_s_ERR_FMT
+		    "req_idx=%x req_idx_MR=%x mf=%p mr=%p sc=%p\n",
+		    ioc->name, req_idx, req_idx_MR, mf, mr, 
+		    hd->ScsiLookup[req_idx_MR]);
 		return 0;
 	}
 
-	req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
 	sc = hd->ScsiLookup[req_idx];
 	if (sc == NULL) {
 		MPIHeader_t *hdr = (MPIHeader_t *)mf;
 
-		atomic_dec(&queue_depth);
-
-		/* writeSDP1 will use the ScsiDoneCtx
-		 * There is no processing for the reply.
-		 * Just return to the calling function.
+		/* Remark: writeSDP1 will use the ScsiDoneCtx
+		 * If a SCSI I/O cmd, device disabled by OS and
+		 * completion done. Cannot touch sc struct. Just free mem.
 		 */
 		if (hdr->Function == MPI_FUNCTION_SCSI_IO_REQUEST)
 			printk(MYIOC_s_ERR_FMT "NULL ScsiCmd ptr!\n", ioc->name);
 
-		mptscsih_freeChainBuffers(hd, req_idx);
+		if (hdr->Function == MPI_FUNCTION_CONFIG) {
+			Config_t		*pReq = (Config_t *)mf;
+			ConfigReply_t	    	*pRep = (ConfigReply_t *)mr;
+			FCDevicePage0_t		*pFCDevice0;
+			VirtDevice		*pTarget;
+			int			 target;
+
+			dcprintk((MYIOC_s_INFO_FMT
+				"config request for %08x/%08x done with status %04x!\n",
+				ioc->name,
+				le32_to_cpu(*(U32 *)&pReq->Header),
+				le32_to_cpu(pReq->PageAddress),
+				le16_to_cpu(pRep->IOCStatus)));
+			if (le16_to_cpu(pRep->IOCStatus) == MPI_IOCSTATUS_SUCCESS &&
+			    pReq->Header.PageType == MPI_CONFIG_PAGETYPE_FC_DEVICE &&
+			    pReq->Header.PageNumber == 0) {
+				pFCDevice0 = (FCDevicePage0_t *)(pReq + 1);
+				target = le32_to_cpu(pReq->PageAddress) &
+					MPI_FC_DEVICE_PGAD_BT_TID_MASK;
+				pTarget = hd->Targets[target];
+				dcprintk((MYIOC_s_INFO_FMT
+					"  target %d is WWPN = %08x%08x, WWNN = %08x%08x\n",
+					ioc->name, target,
+					le32_to_cpu(pFCDevice0->WWPN.High),
+					le32_to_cpu(pFCDevice0->WWPN.Low),
+					le32_to_cpu(pFCDevice0->WWNN.High),
+					le32_to_cpu(pFCDevice0->WWNN.Low)));
+				if (pTarget) {
+					pTarget->WWPN = pFCDevice0->WWPN;
+					pTarget->WWNN = pFCDevice0->WWNN;
+				}
+			}
+		}
+
+		mptscsih_freeChainBuffers(ioc, req_idx);
 		return 1;
 	}
 
-	dmfprintk((MYIOC_s_INFO_FMT "ScsiDone (mf=%p,mr=%p,sc=%p,idx=%d)\n",
-			ioc->name, mf, mr, sc, req_idx));
-
-	atomic_dec(&queue_depth);
-
 	sc->result = DID_OK << 16;		/* Set default reply as OK */
 	pScsiReq = (SCSIIORequest_t *) mf;
 	pScsiReply = (SCSIIOReply_t *) mr;
 
+#ifdef MPT_DEBUG_MSG_FRAME
+	if((ioc->facts.MsgVersion >= MPI_VERSION_01_05) && pScsiReply){
+		dmfprintk((MYIOC_s_WARN_FMT
+			"ScsiDone (mf=%p,mr=%p,sc=%p,idx=%d,task-tag=%d)\n",
+			ioc->name, mf, mr, sc, req_idx, pScsiReply->TaskTag));
+	}else{
+		dmfprintk((MYIOC_s_WARN_FMT
+			"ScsiDone (mf=%p,mr=%p,sc=%p,idx=%d)\n",
+			ioc->name, mf, mr, sc, req_idx));
+	}
+#endif
+
 	if (pScsiReply == NULL) {
 		/* special context reply handling */
 
 		/* If regular Inquiry cmd - save inquiry data
 		 */
-		if (pScsiReq->CDB[0] == INQUIRY && !(pScsiReq->CDB[1] & 0x3)) {
+		if (pScsiReq->CDB[0] == INQUIRY) {
 			int	 dlen;
 
 			dlen = le32_to_cpu(pScsiReq->DataLength);
-			if (dlen >= SCSI_STD_INQUIRY_BYTES) {
-				mptscsih_initTarget(hd,
-						hd->port,
-						sc->target,
-						pScsiReq->LUN[1],
-						sc->buffer,
-						dlen);
-			}
+			mptscsih_initTarget(hd,
+					sc->channel,
+					sc->target,
+					pScsiReq->LUN[1],
+					sc->buffer,
+					dlen);
 		}
-#ifdef MPT_SAVE_AUTOSENSE
-		clear_sense_flag(hd, pScsiReq);
-#endif
 	} else {
 		u32	 xfer_cnt;
 		u16	 status;
-		u8	 scsi_state;
+		u8	 scsi_state, scsi_status;
+		VirtDevice		*pTarget;
+		int	 target;
 
 		status = le16_to_cpu(pScsiReply->IOCStatus) & MPI_IOCSTATUS_MASK;
 		scsi_state = pScsiReply->SCSIState;
-
-		dprintk((KERN_NOTICE "  Uh-Oh! (%d:%d:%d) mf=%p, mr=%p, sc=%p\n",
-				ioc->id, pScsiReq->TargetID, pScsiReq->LUN[1],
-				mf, mr, sc));
-		dprintk((KERN_NOTICE "  IOCStatus=%04xh, SCSIState=%02xh"
-				", SCSIStatus=%02xh, IOCLogInfo=%08xh\n",
-				status, scsi_state, pScsiReply->SCSIStatus,
-				le32_to_cpu(pScsiReply->IOCLogInfo)));
+		scsi_status = pScsiReply->SCSIStatus;
+		xfer_cnt = le32_to_cpu(pScsiReply->TransferCount);
+		sc->resid = sc->request_bufflen - xfer_cnt;
+
+		dreplyprintk((KERN_NOTICE "Reply ha=%d id=%d lun=%d:\n"
+			"IOCStatus=%04xh SCSIState=%02xh SCSIStatus=%02xh\n"
+			"resid=%d bufflen=%d xfer_cnt=%d\n",
+			ioc->id, pScsiReq->TargetID, pScsiReq->LUN[1],
+			status, scsi_state, scsi_status, sc->resid, 
+			sc->request_bufflen, xfer_cnt));
 
 		if (scsi_state & MPI_SCSI_STATE_AUTOSENSE_VALID)
 			copy_sense_data(sc, hd, mf, pScsiReply);
@@ -807,8 +860,8 @@ mptscsih_io_done(MPT_ADAPTER *ioc, MPT_F
 		 *  Look for + dump FCP ResponseInfo[]!
 		 */
 		if (scsi_state & MPI_SCSI_STATE_RESPONSE_INFO_VALID) {
-			dprintk((KERN_NOTICE "  FCP_ResponseInfo=%08xh\n",
-					     le32_to_cpu(pScsiReply->ResponseInfo)));
+			printk(KERN_NOTICE "  FCP_ResponseInfo=%08xh\n",
+			le32_to_cpu(pScsiReply->ResponseInfo));
 		}
 
 		switch(status) {
@@ -830,92 +883,90 @@ mptscsih_io_done(MPT_ADAPTER *ioc, MPT_F
 			/* Spoof to SCSI Selection Timeout! */
 			sc->result = DID_NO_CONNECT << 16;
 
-			if (hd->sel_timeout[pScsiReq->TargetID] < 0xFFFF)
+			target = pScsiReq->TargetID;
+			if (hd->sel_timeout[target] < 0xFFFF)
 				hd->sel_timeout[pScsiReq->TargetID]++;
-			break;
 
-		case MPI_IOCSTATUS_SCSI_TASK_TERMINATED:	/* 0x0048 */
-#ifndef MPT_SCSI_USE_NEW_EH
-			search_taskQ_for_cmd(sc, hd);
-#endif
-			/* Linux handles an unsolicited DID_RESET better
-			 * than an unsolicited DID_ABORT.
-			 */
-			sc->result = DID_RESET << 16;
+			pTarget = hd->Targets[target];
 
-			/* GEM Workaround. */
-			if (hd->is_spi)
-				mptscsih_no_negotiate(hd, sc->target);
+			if ( pTarget && ioc->bus_type != FC ) {
+				dinitprintk((KERN_INFO "Target structure (id %d) @ %p Removed due to NOT_THERE\n",
+			target, pTarget));
+				kfree(pTarget);
+				hd->Targets[target] = NULL;
+			}
 			break;
 
+		case MPI_IOCSTATUS_SCSI_TASK_TERMINATED:	/* 0x0048 */
 		case MPI_IOCSTATUS_SCSI_IOC_TERMINATED:		/* 0x004B */
 		case MPI_IOCSTATUS_SCSI_EXT_TERMINATED:		/* 0x004C */
+			/* Linux handles an unsolicited DID_RESET better
+			 * than an unsolicited DID_ABORT.
+			 */
 #ifndef MPT_SCSI_USE_NEW_EH
 			search_taskQ_for_cmd(sc, hd);
 #endif
 			sc->result = DID_RESET << 16;
 
 			/* GEM Workaround. */
-			if (hd->is_spi)
+			if (ioc->bus_type == SCSI)
 				mptscsih_no_negotiate(hd, sc->target);
 			break;
 
 		case MPI_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:	/* 0x0049 */
+			if ( xfer_cnt >= sc->underflow ) {
+				/* Sufficient data transfer occurred */
+				sc->result = (DID_OK << 16) | scsi_status;
+			} else if ( xfer_cnt == 0 ) {
+				/* A CRC Error causes this condition; retry */
+				sc->result = (DRIVER_SENSE << 24) | (DID_OK << 16) | 
+					(CHECK_CONDITION << 1);
+				sc->sense_buffer[0] = 0x70;
+				sc->sense_buffer[2] = NO_SENSE;
+				sc->sense_buffer[12] = 0;
+				sc->sense_buffer[13] = 0;
+			} else {
+				sc->result = DID_SOFT_ERROR << 16;
+			}
+			dreplyprintk((KERN_NOTICE "RESIDUAL_MISMATCH: result=%x on id=%d\n", sc->result, sc->target));
+			break;
+
 		case MPI_IOCSTATUS_SCSI_DATA_UNDERRUN:		/* 0x0045 */
 			/*
-			 *  YIKES!  I just discovered that SCSI IO which
-			 *  returns check condition, SenseKey=05 (ILLEGAL REQUEST)
-			 *  and ASC/ASCQ=94/01 (LSI Logic RAID vendor specific),
-			 *  comes down this path!
 			 *  Do upfront check for valid SenseData and give it
 			 *  precedence!
 			 */
-			sc->result = (DID_OK << 16) | pScsiReply->SCSIStatus;
-#ifdef MPT_SAVE_AUTOSENSE
-			clear_sense_flag(hd, pScsiReq);
-#endif
-			if (scsi_state == 0) {
-				;
-			} else if (scsi_state & MPI_SCSI_STATE_AUTOSENSE_VALID) {
+			sc->result = (DID_OK << 16) | scsi_status;
+			if (scsi_state & MPI_SCSI_STATE_AUTOSENSE_VALID) {
 				/* Have already saved the status and sense data
 				 */
 				;
-			} else if (scsi_state & (MPI_SCSI_STATE_AUTOSENSE_FAILED | MPI_SCSI_STATE_NO_SCSI_STATUS)) {
-				/* What to do?
-				 */
-				sc->result = DID_SOFT_ERROR << 16;
-			}
-			else if (scsi_state & MPI_SCSI_STATE_TERMINATED) {
-				/*  Not real sure here either...  */
-				sc->result = DID_RESET << 16;
+			} else {
+				if (xfer_cnt < sc->underflow) {
+					sc->result = DID_SOFT_ERROR << 16;
+				}
+				if (scsi_state & (MPI_SCSI_STATE_AUTOSENSE_FAILED | MPI_SCSI_STATE_NO_SCSI_STATUS)) {
+					/* What to do?
+				 	*/
+					sc->result = DID_SOFT_ERROR << 16;
+				}
+				else if (scsi_state & MPI_SCSI_STATE_TERMINATED) {
+					/*  Not real sure here either...  */
+					sc->result = DID_RESET << 16;
+				}
 			}
 
-			/* Give report and update residual count.
-			 */
-			xfer_cnt = le32_to_cpu(pScsiReply->TransferCount);
-			dprintk((KERN_NOTICE "  sc->underflow={report ERR if < %02xh bytes xfer'd}\n",
+			dreplyprintk((KERN_NOTICE "  sc->underflow={report ERR if < %02xh bytes xfer'd}\n",
 					sc->underflow));
-			dprintk((KERN_NOTICE "  ActBytesXferd=%02xh\n", xfer_cnt));
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-			sc->resid = sc->request_bufflen - xfer_cnt;
-			dprintk((KERN_NOTICE "  SET sc->resid=%02xh\n", sc->resid));
-#endif
-
+			dreplyprintk((KERN_NOTICE "  ActBytesXferd=%02xh\n", xfer_cnt));
 			/* Report Queue Full
 			 */
-			if (sc->result == MPI_SCSI_STATUS_TASK_SET_FULL)
+			if (scsi_status == MPI_SCSI_STATUS_TASK_SET_FULL)
 				mptscsih_report_queue_full(sc, pScsiReply, pScsiReq);
 
-			/* If regular Inquiry cmd and some data was transferred,
-			 * save inquiry data
-			 */
-			if (    pScsiReq->CDB[0] == INQUIRY
-			     && !(pScsiReq->CDB[1] & 0x3)
-			     && xfer_cnt >= SCSI_STD_INQUIRY_BYTES
-			   ) {
+			if ( (pScsiReq->CDB[0] == INQUIRY) && xfer_cnt ) {
 				mptscsih_initTarget(hd,
-						hd->port,
+						sc->channel,
 						sc->target,
 						pScsiReq->LUN[1],
 						sc->buffer,
@@ -925,10 +976,8 @@ mptscsih_io_done(MPT_ADAPTER *ioc, MPT_F
 
 		case MPI_IOCSTATUS_SCSI_RECOVERED_ERROR:	/* 0x0040 */
 		case MPI_IOCSTATUS_SUCCESS:			/* 0x0000 */
-			sc->result = (DID_OK << 16) | pScsiReply->SCSIStatus;
-#ifdef MPT_SAVE_AUTOSENSE
-			clear_sense_flag(hd, pScsiReq);
-#endif
+			scsi_status = pScsiReply->SCSIStatus;
+			sc->result = (DID_OK << 16) | scsi_status;
 			if (scsi_state == 0) {
 				;
 			} else if (scsi_state & MPI_SCSI_STATE_AUTOSENSE_VALID) {
@@ -942,17 +991,13 @@ mptscsih_io_done(MPT_ADAPTER *ioc, MPT_F
 					mptscsih_report_queue_full(sc, pScsiReply, pScsiReq);
 
 #ifndef MPT_SCSI_USE_NEW_EH
-				/* ADDED 20011120 -sralston
-				 * Scsi mid-layer (old_eh) doesn't seem to like it
+				/* Scsi mid-layer (old_eh) doesn't seem to like it
 				 * when RAID returns SCSIStatus=02 (CHECK CONDITION),
 				 * SenseKey=01 (RECOVERED ERROR), ASC/ASCQ=95/01.
 				 * Seems to be * treating this as a IO error:-(
 				 *
 				 * So just lie about it altogether here.
 				 *
-				 * NOTE: It still gets reported to syslog via
-				 * mpt_ScsiHost_ErrorReport from copy_sense_data
-				 * call far above.
 				 */
 				if (    pScsiReply->SCSIStatus == STS_CHECK_CONDITION
 				     && SD_Sense_Key(sc->sense_buffer) == SK_RECOVERED_ERROR
@@ -992,14 +1037,11 @@ mptscsih_io_done(MPT_ADAPTER *ioc, MPT_F
 
 			/* If regular Inquiry cmd - save inquiry data
 			 */
-			xfer_cnt = le32_to_cpu(pScsiReply->TransferCount);
-			if (    sc->result == (DID_OK << 16)
-			     && pScsiReq->CDB[0] == INQUIRY
-			     && !(pScsiReq->CDB[1] & 0x3)
-			     && xfer_cnt >= SCSI_STD_INQUIRY_BYTES
-			   ) {
+			if ( (sc->result == (DID_OK << 16))
+			     && xfer_cnt
+			     && pScsiReq->CDB[0] == INQUIRY ) {
 				mptscsih_initTarget(hd,
-						hd->port,
+						sc->channel,
 						sc->target,
 						pScsiReq->LUN[1],
 						sc->buffer,
@@ -1008,11 +1050,7 @@ mptscsih_io_done(MPT_ADAPTER *ioc, MPT_F
 			break;
 
 		case MPI_IOCSTATUS_SCSI_PROTOCOL_ERROR:		/* 0x0047 */
-			if (pScsiReply->SCSIState & MPI_SCSI_STATE_TERMINATED) {
-				/*  Not real sure here either...  */
-				sc->result = DID_RESET << 16;
-			} else
-				sc->result = DID_SOFT_ERROR << 16;
+			sc->result = DID_SOFT_ERROR << 16;
 			break;
 
 		case MPI_IOCSTATUS_INVALID_FUNCTION:		/* 0x0001 */
@@ -1034,22 +1072,21 @@ mptscsih_io_done(MPT_ADAPTER *ioc, MPT_F
 
 		}	/* switch(status) */
 
-		dprintk((KERN_NOTICE "  sc->result set to %08xh\n", sc->result));
+		dreplyprintk((KERN_NOTICE "  sc->result is %08xh\n", sc->result));
 	} /* end of address reply case */
 
 	/* Unmap the DMA buffers, if any. */
 	if (sc->use_sg) {
 		pci_unmap_sg(ioc->pcidev, (struct scatterlist *) sc->request_buffer,
-			    sc->use_sg, scsi_to_pci_dma_dir(sc->sc_data_direction));
+			    sc->use_sg, sc->sc_data_direction);
 	} else if (sc->request_bufflen) {
-		scPrivate	*my_priv;
-
-		my_priv = (scPrivate *) &sc->SCp;
-		pci_unmap_single(ioc->pcidev, (dma_addr_t)(ulong)my_priv->p1,
-			   sc->request_bufflen,
-			   scsi_to_pci_dma_dir(sc->sc_data_direction));
+		pci_unmap_single(ioc->pcidev, sc->SCp.dma_handle,
+				sc->request_bufflen, sc->sc_data_direction);
 	}
 
+	/* Free Chain buffers */
+	mptscsih_freeChainBuffers(ioc, req_idx);
+
 	hd->ScsiLookup[req_idx] = NULL;
 
 #ifndef MPT_SCSI_USE_NEW_EH
@@ -1057,11 +1094,13 @@ mptscsih_io_done(MPT_ADAPTER *ioc, MPT_F
 #endif
 
         MPT_HOST_LOCK(flags);
+#ifdef MPT_DEBUG_QCMD_DEPTH
+	mptscsih_scsi_done(ioc,sc);
+#else
 	sc->scsi_done(sc);		/* Issue the command callback */
+#endif
         MPT_HOST_UNLOCK(flags);
 
-	/* Free Chain buffers */
-	mptscsih_freeChainBuffers(hd, req_idx);
 	return 1;
 }
 
@@ -1093,8 +1132,9 @@ search_taskQ(int remove, Scsi_Cmnd *sc, 
 		mf = hd->taskQ.head;
 		do {
 			count++;
-			if (mf->u.frame.linkage.argp1 == sc &&
-			    mf->u.frame.linkage.arg1 == task_type) {
+			if (mf->u.frame.linkage.arg1 == task_type) {
+			    if (mf->u.frame.linkage.argp1 == sc ||
+				task_type == MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS) {
 				if (remove) {
 					Q_DEL_ITEM(&mf->u.frame.linkage);
 					hd->taskQcnt--;
@@ -1104,15 +1144,10 @@ search_taskQ(int remove, Scsi_Cmnd *sc, 
 					 * exit after command has been deleted.
 					 */
 
-					/* Place the MF back on the FreeQ */
-					Q_ADD_TAIL(&hd->ioc->FreeQ,
-						&mf->u.frame.linkage,
-						MPT_FRAME_HDR);
-#ifdef MFCNT
-					hd->ioc->mfcnt--;
-#endif
+					mpt_free_msg_frame(hd->ioc, mf);
 				}
 				break;
+			    }
 			}
 		} while ((mf = mf->u.frame.linkage.forw) != (MPT_FRAME_HDR*)&hd->taskQ);
 		if (mf == (MPT_FRAME_HDR*)&hd->taskQ) {
@@ -1144,8 +1179,8 @@ search_taskQ(int remove, Scsi_Cmnd *sc, 
 static void
 clean_taskQ(MPT_SCSI_HOST *hd)
 {
-	MPT_FRAME_HDR *mf = NULL;
-	MPT_FRAME_HDR *nextmf = NULL;
+	MPT_FRAME_HDR *mf;
+	MPT_FRAME_HDR *nextmf;
 	MPT_ADAPTER *ioc = hd->ioc;
 	unsigned long flags;
 
@@ -1184,7 +1219,7 @@ clean_taskQ(MPT_SCSI_HOST *hd)
 static void
 search_taskQ_for_cmd(Scsi_Cmnd *sc, MPT_SCSI_HOST *hd)
 {
-	MPT_FRAME_HDR *mf = NULL;
+	MPT_FRAME_HDR *mf;
 	unsigned long flags;
 	int count = 0;
 
@@ -1224,85 +1259,27 @@ search_taskQ_for_cmd(Scsi_Cmnd *sc, MPT_
 #endif		/* } MPT_SCSI_USE_NEW_EH */
 
 
-/*
- * Flush all commands on the doneQ.
- * Lock Q when deleting/adding members
- * Lock io_request_lock for OS callback.
- */
 static void
-flush_doneQ(MPT_SCSI_HOST *hd)
+mptscsih_reset_timeouts (MPT_SCSI_HOST *hd)
 {
-	MPT_DONE_Q	*buffer;
 	Scsi_Cmnd	*SCpnt;
-	unsigned long	 flags;
+	int		 ii;
+	int		 max = hd->ioc->req_depth;
 
-	/* Flush the doneQ.
-	 */
-	dprintk((KERN_INFO MYNAM ": flush_doneQ called\n"));
-	while (1) {
-		spin_lock_irqsave(&hd->freedoneQlock, flags);
-		if (Q_IS_EMPTY(&hd->doneQ)) {
-			spin_unlock_irqrestore(&hd->freedoneQlock, flags);
-			break;
+//	for (ii= 0; ii < max; ii++) {
+	for (ii= max; ii < 0; ii--) {
+		if ((SCpnt = hd->ScsiLookup[ii]) != NULL) {
+#ifdef MPT_DEBUG_RESET
+			MPT_FRAME_HDR	*mf;
+			mf = MPT_INDEX_2_MFPTR(hd->ioc, ii);
+			drsprintk((MYIOC_s_WARN_FMT "resetting SCpnt=%p mf=%p ii=%d timeout + 60HZ\n",
+				(hd && hd->ioc) ? hd->ioc->name : "ioc?", 
+				SCpnt, mf, ii));
+			DBG_DUMP_TIMER_REQUEST_FRAME(mf)
+#endif
+			mod_timer(&SCpnt->eh_timeout, jiffies + (HZ * 60));
 		}
-
-		buffer = hd->doneQ.head;
-		/* Delete from Q
-		 */
-		Q_DEL_ITEM(buffer);
-
-		/* Set the Scsi_Cmnd pointer
-		 */
-		SCpnt = (Scsi_Cmnd *) buffer->argp;
-		buffer->argp = NULL;
-
-		/* Add to the freeQ
-		 */
-		Q_ADD_TAIL(&hd->freeQ.head, buffer, MPT_DONE_Q);
-		spin_unlock_irqrestore(&hd->freedoneQlock, flags);
-
-		/* Do the OS callback.
-		 */
-                MPT_HOST_LOCK(flags);
-		SCpnt->scsi_done(SCpnt);
-                MPT_HOST_UNLOCK(flags);
-	}
-
-	return;
-}
-
-/*
- * Search the doneQ for a specific command. If found, delete from Q.
- * Calling function will finish processing.
- */
-static void
-search_doneQ_for_cmd(MPT_SCSI_HOST *hd, Scsi_Cmnd *SCpnt)
-{
-	unsigned long	 flags;
-	MPT_DONE_Q	*buffer;
-
-	spin_lock_irqsave(&hd->freedoneQlock, flags);
-	if (!Q_IS_EMPTY(&hd->doneQ)) {
-		buffer = hd->doneQ.head;
-		do {
-			Scsi_Cmnd *sc = (Scsi_Cmnd *) buffer->argp;
-			if (SCpnt == sc) {
-				Q_DEL_ITEM(buffer);
-				SCpnt->result = sc->result;
-
-				/* Set the Scsi_Cmnd pointer
-				 */
-				buffer->argp = NULL;
-
-				/* Add to the freeQ
-				 */
-				Q_ADD_TAIL(&hd->freeQ.head, buffer, MPT_DONE_Q);
-				break;
-			}
-		} while ((buffer = buffer->forw) != (MPT_DONE_Q *) &hd->doneQ);
 	}
-	spin_unlock_irqrestore(&hd->freedoneQlock, flags);
-	return;
 }
 
 /*
@@ -1318,22 +1295,23 @@ search_doneQ_for_cmd(MPT_SCSI_HOST *hd, 
 static void
 mptscsih_flush_running_cmds(MPT_SCSI_HOST *hd)
 {
-	Scsi_Cmnd	*SCpnt = NULL;
-	MPT_FRAME_HDR	*mf = NULL;
+	MPT_ADAPTER *ioc = hd->ioc;
+	Scsi_Cmnd	*SCpnt;
+	MPT_FRAME_HDR	*mf;
+	MPT_REQUEST_Q	*buffer;
 	int		 ii;
-	int		 max = hd->ioc->req_depth;
+	int		 max = ioc->req_depth;
 
 #if LINUX_VERSION_CODE <= KERNEL_VERSION(2,5,0)
 	unsigned long	 flags;
 #endif
 
-	dprintk((KERN_INFO MYNAM ": flush_ScsiLookup called\n"));
+	drsprintk((KERN_INFO MYNAM ": flush_ScsiLookup called\n"));
 	for (ii= 0; ii < max; ii++) {
 		if ((SCpnt = hd->ScsiLookup[ii]) != NULL) {
 
 			/* Command found.
 			 */
-
 #ifndef MPT_SCSI_USE_NEW_EH
 			/* Search taskQ, if found, delete.
 			 */
@@ -1341,230 +1319,55 @@ mptscsih_flush_running_cmds(MPT_SCSI_HOS
 #endif
 
 			/* Search pendingQ, if found,
-			 * delete from Q. If found, do not decrement
-			 * queue_depth, command never posted.
+			 * delete from Q.
 			 */
-			if (mptscsih_search_pendingQ(hd, ii) == NULL)
-				atomic_dec(&queue_depth);
+//			mptscsih_search_pendingQ(hd, ii);
 
 			/* Null ScsiLookup index
 			 */
 			hd->ScsiLookup[ii] = NULL;
 
-			mf = MPT_INDEX_2_MFPTR(hd->ioc, ii);
-			dmfprintk(( "flush: ScsiDone (mf=%p,sc=%p)\n",
-					mf, SCpnt));
+			mf = MPT_INDEX_2_MFPTR(ioc, ii);
 
 			/* Set status, free OS resources (SG DMA buffers)
-			 * Do OS callback
 			 * Free driver resources (chain, msg buffers)
 			 */
 			if (SCpnt->use_sg) {
-				pci_unmap_sg(hd->ioc->pcidev, (struct scatterlist *) SCpnt->request_buffer,
-					    SCpnt->use_sg, scsi_to_pci_dma_dir(SCpnt->sc_data_direction));
+				pci_unmap_sg(ioc->pcidev,
+					(struct scatterlist *) SCpnt->request_buffer,
+					SCpnt->use_sg,
+					SCpnt->sc_data_direction);
 			} else if (SCpnt->request_bufflen) {
-				scPrivate	*my_priv;
-		
-				my_priv = (scPrivate *) &SCpnt->SCp;
-				pci_unmap_single(hd->ioc->pcidev, (dma_addr_t)(ulong)my_priv->p1,
-					   SCpnt->request_bufflen,
-					   scsi_to_pci_dma_dir(SCpnt->sc_data_direction));
+				pci_unmap_single(ioc->pcidev,
+					SCpnt->SCp.dma_handle,
+					SCpnt->request_bufflen,
+					SCpnt->sc_data_direction);
 			}
-			SCpnt->result = DID_RESET << 16;
-			SCpnt->host_scribble = NULL;
-                        MPT_HOST_LOCK(flags);
-			SCpnt->scsi_done(SCpnt);	/* Issue the command callback */
-                        MPT_HOST_UNLOCK(flags);
-
-			/* Free Chain buffers */
-			mptscsih_freeChainBuffers(hd, ii);
 
-			/* Free Message frames */
-			mpt_free_msg_frame(ScsiDoneCtx, hd->ioc->id, mf);
-		}
-	}
 
-	return;
-}
+			SCpnt->result = DID_RESET << 16;
+			SCpnt->host_scribble = NULL;
 
-#ifdef DROP_TEST
-/* 	mptscsih_flush_drop_test - Free resources and do callback if
- *		DROP_TEST enabled.
- *
- *	@hd: Pointer to a SCSI HOST structure
- *
- *	Returns: None.
- *
- *	Must be called while new I/Os are being queued.
- */
-static void
-mptscsih_flush_drop_test (MPT_SCSI_HOST *hd)
-{
-	Scsi_Cmnd	*sc;
-	unsigned long	 flags;
-	u16		 req_idx;
+			drsprintk((MYIOC_s_WARN_FMT "flush SCpnt=%p mf=%p ii=%d result=%x\n",
+				ioc->name, SCpnt, mf, ii, SCpnt->result));
 
-	/* Free resources for the drop test MF
-	 * and chain buffers.
-	 */
-	if (dropMfPtr) {
-		req_idx = le16_to_cpu(dropMfPtr->u.frame.hwhdr.msgctxu.fld.req_idx);
-		sc = hd->ScsiLookup[req_idx];
-		if (sc == NULL) {
-			printk(MYIOC_s_ERR_FMT "Drop Test: NULL ScsiCmd ptr!\n",
-					ioc->name);
-		} else {
-			/* unmap OS resources, set status, do callback
-			 * free driver resources
-			 */
-			if (sc->use_sg) {
-				pci_unmap_sg(ioc->pcidev, (struct scatterlist *) sc->request_buffer,
-					    sc->use_sg, scsi_to_pci_dma_dir(sc->sc_data_direction));
-			} else if (sc->request_bufflen) {
-				scPrivate	*my_priv;
-
-				my_priv = (scPrivate *) &sc->SCp;
-				pci_unmap_single(ioc->pcidev, (dma_addr_t)(ulong)my_priv->p1,
-					   sc->request_bufflen,
-					   scsi_to_pci_dma_dir(sc->sc_data_direction));
-			}
+			/* Free Chain buffers */
+			mptscsih_freeChainBuffers(ioc, ii);
 
-			sc->host_scribble = NULL;
-			sc->result = DID_RESET << 16;
-			hd->ScsiLookup[req_idx] = NULL;
-			atomic_dec(&queue_depth);
-			MPT_HOST_LOCK(flags);
-			sc->scsi_done(sc);	/* Issue callback */
-			MPT_HOST_UNLOCK(flags);
-		}
-
-		mptscsih_freeChainBuffers(hd, req_idx);
-		mpt_free_msg_frame(ScsiDoneCtx, ioc->id, dropMfPtr);
-		printk(MYIOC_s_INFO_FMT "Free'd Dropped cmd (%p)\n",
-					hd->ioc->name, sc);
-		printk(MYIOC_s_INFO_FMT "mf (%p) reqidx (%4x)\n",
-					hd->ioc->name, dropMfPtr, req_idx);
-		printk(MYIOC_s_INFO_FMT "Num Tot (%d) Good (%d) Bad (%d) \n",
-				hd->ioc->name, dropTestNum,
-				dropTestOK, dropTestBad);
-	}
-	dropMfPtr = NULL;
+			/* Free Message frame */
+			mpt_free_msg_frame(ioc, mf);
 
-	return;
-}
+                        MPT_HOST_LOCK(flags);
+#ifdef MPT_DEBUG_QCMD_DEPTH
+			mptscsih_scsi_done(ioc,SCpnt);
+#else
+			SCpnt->scsi_done(SCpnt);	/* Issue the command callback */
 #endif
-
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/*
- *	mptscsih_initChainBuffers - Allocate memory for and initialize
- *	chain buffers, chain buffer control arrays and spinlock.
- *	@hd: Pointer to MPT_SCSI_HOST structure
- *	@init: If set, initialize the spin lock.
- */
-static int
-mptscsih_initChainBuffers (MPT_SCSI_HOST *hd, int init)
-{
-	MPT_FRAME_HDR	*chain;
-	u8		*mem;
-	unsigned long	flags;
-	int		sz, ii, num_chain;
-	int 		scale, num_sge;
-
-	/* ReqToChain size must equal the req_depth
-	 * index = req_idx
-	 */
-	sz = hd->ioc->req_depth * sizeof(int);
-	if (hd->ReqToChain == NULL) {
-		mem = kmalloc(sz, GFP_ATOMIC);
-		if (mem == NULL)
-			return -1;
-
-		hd->ReqToChain = (int *) mem;
-	} else {
-		mem = (u8 *) hd->ReqToChain;
-	}
-	memset(mem, 0xFF, sz);
-
-
-	/* ChainToChain size must equal the total number
-	 * of chain buffers to be allocated.
-	 * index = chain_idx
-	 *
-	 * Calculate the number of chain buffers needed(plus 1) per I/O
-	 * then multiply the the maximum number of simultaneous cmds
-	 *
-	 * num_sge = num sge in request frame + last chain buffer
-	 * scale = num sge per chain buffer if no chain element
-	 */
-	scale = hd->ioc->req_sz/(sizeof(dma_addr_t) + sizeof(u32));
-	if (sizeof(dma_addr_t) == sizeof(u64))
-		num_sge =  scale + (hd->ioc->req_sz - 60) / (sizeof(dma_addr_t) + sizeof(u32));
-	else
-		num_sge =  1+ scale + (hd->ioc->req_sz - 64) / (sizeof(dma_addr_t) + sizeof(u32));
-
-	num_chain = 1;
-	while (hd->max_sge - num_sge > 0) {
-		num_chain++;
-		num_sge += (scale - 1);
-	}
-	num_chain++;
-
-	if ((int) hd->ioc->chip_type > (int) FC929)
-		num_chain *= MPT_SCSI_CAN_QUEUE;
-	else
-		num_chain *= MPT_FC_CAN_QUEUE;
-
-	hd->num_chain = num_chain;
-
-	sz = num_chain * sizeof(int);
-	if (hd->ChainToChain == NULL) {
-		mem = kmalloc(sz, GFP_ATOMIC);
-		if (mem == NULL)
-			return -1;
-
-		hd->ChainToChain = (int *) mem;
-	} else {
-		mem = (u8 *) hd->ChainToChain;
-	}
-	memset(mem, 0xFF, sz);
-
-	sz = num_chain * hd->ioc->req_sz;
-	if (hd->ChainBuffer == NULL) {
-		/* Allocate free chain buffer pool
-		 */
-		mem = pci_alloc_consistent(hd->ioc->pcidev, sz, &hd->ChainBufferDMA);
-		if (mem == NULL)
-			return -1;
-
-		hd->ChainBuffer = (u8*)mem;
-	} else {
-		mem = (u8 *) hd->ChainBuffer;
-	}
-	memset(mem, 0, sz);
-
-	dprintk((KERN_INFO "  ChainBuffer    @ %p(%p), sz=%d\n",
-		 hd->ChainBuffer, (void *)(ulong)hd->ChainBufferDMA, sz));
-
-	/* Initialize the free chain Q.
-	 */
-	if (init) {
-		spin_lock_init(&hd->FreeChainQlock);
-	}
-
-	spin_lock_irqsave (&hd->FreeChainQlock, flags);
-	Q_INIT(&hd->FreeChainQ, MPT_FRAME_HDR);
-
-	/* Post the chain buffers to the FreeChainQ.
-	 */
-	mem = (u8 *)hd->ChainBuffer;
-	for (ii=0; ii < num_chain; ii++) {
-		chain = (MPT_FRAME_HDR *) mem;
-		Q_ADD_TAIL(&hd->FreeChainQ.head, &chain->u.frame.linkage, MPT_FRAME_HDR);
-		mem += hd->ioc->req_sz;
+                        MPT_HOST_UNLOCK(flags);
+		}
 	}
-	spin_unlock_irqrestore(&hd->FreeChainQlock, flags);
 
-	return 0;
+	return;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -1596,8 +1399,8 @@ mptscsih_report_queue_full(Scsi_Cmnd *sc
 
 		if (sc->host != NULL && sc->host->hostdata != NULL)
 			ioc_str = ((MPT_SCSI_HOST *)sc->host->hostdata)->ioc->name;
-		printk(MYIOC_s_WARN_FMT "Device (%d:%d:%d) reported QUEUE_FULL!\n",
-				ioc_str, 0, sc->target, sc->lun);
+		dprintk((MYIOC_s_WARN_FMT "Device (%d:%d:%d) reported QUEUE_FULL!\n",
+				ioc_str, 0, sc->target, sc->lun));
 		last_queue_full = time;
 	}
 }
@@ -1622,14 +1425,13 @@ static char *info_kbuf = NULL;
 int
 mptscsih_detect(Scsi_Host_Template *tpnt)
 {
-	struct Scsi_Host	*sh = NULL;
-	MPT_SCSI_HOST		*hd = NULL;
-	MPT_ADAPTER		*this;
-	MPT_DONE_Q		*freedoneQ;
+	struct Scsi_Host	*sh;
+	MPT_SCSI_HOST		*hd;
+	MPT_ADAPTER		*ioc;
+	MPT_REQUEST_Q		*freeQ;
 	unsigned long		 flags;
 	int			 sz, ii;
-	int			 numSGE = 0;
-	int			 scale;
+	int			 ioc_cap;
 	u8			*mem;
 
 	if (! BeenHereDoneThat++) {
@@ -1644,291 +1446,293 @@ mptscsih_detect(Scsi_Host_Template *tpnt
 #endif
 
 		if (mpt_event_register(ScsiDoneCtx, mptscsih_event_process) == 0) {
-			dprintk((KERN_INFO MYNAM ": Registered for IOC event notifications\n"));
+			devtprintk((KERN_INFO MYNAM ": Registered for IOC event notifications\n"));
 		} else {
 			/* FIXME! */
 		}
 
 		if (mpt_reset_register(ScsiDoneCtx, mptscsih_ioc_reset) == 0) {
-			dprintk((KERN_INFO MYNAM ": Registered for IOC reset notifications\n"));
+			dinitprintk((KERN_INFO MYNAM ": Registered mptscsih_ioc_reset notification ScsiDoneCtx=%d\n", ScsiDoneCtx));
 		} else {
-			/* FIXME! */
+			dinitprintk((KERN_INFO MYNAM ": Register of mptscsih_ioc_reset notification ScsiDoneCtx=%d FAILED\n", ScsiDoneCtx));
 		}
 	}
-	dprintk((KERN_INFO MYNAM ": mpt_scsih_detect()\n"));
+	dinitprintk((KERN_INFO MYNAM ": mpt_scsih_detect()\n"));
 
-#ifdef MODULE
-	/* Evaluate the command line arguments, if any */
-	if (mptscsih)
-		mptscsih_setup(mptscsih);
-#endif
 #ifndef MPT_SCSI_USE_NEW_EH
 	atomic_set(&mpt_taskQdepth, 0);
 #endif
 
-	this = mpt_adapter_find_first();
-	while (this != NULL) {
-		int	 portnum;
-		for (portnum=0; portnum < this->facts.NumberOfPorts; portnum++) {
-
-			/* 20010215 -sralston
-			 *  Added sanity check on SCSI Initiator-mode enabled
-			 *  for this MPT adapter.
-			 */
-			if (!(this->pfacts[portnum].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_INITIATOR)) {
-				printk(MYIOC_s_WARN_FMT "Skipping because SCSI Initiator mode is NOT enabled!\n",
-						this->name);
-				continue;
-			}
-
-			/* 20010202 -sralston
-			 *  Added sanity check on readiness of the MPT adapter.
-			 */
-			if (this->last_state != MPI_IOC_STATE_OPERATIONAL) {
-				printk(MYIOC_s_WARN_FMT "Skipping because it's not operational!\n",
-						this->name);
-				continue;
-			}
+	list_for_each_entry(ioc, &ioc_list, list) {
+		/*  Added sanity check on readiness of the MPT adapter.
+		 */
+		if (ioc->last_state != MPI_IOC_STATE_OPERATIONAL) {
+			printk(MYIOC_s_WARN_FMT "Skipping because it's not operational!\n",
+					ioc->name);
+			continue;
+		}
+
+		if (!ioc->active) {
+			printk(MYIOC_s_WARN_FMT "Skipping because it's disabled!\n",
+					ioc->name);
+			continue;
+		}
+
+
+		/*  Sanity check - ensure at least 1 port is INITIATOR capable
+		 */
+		ioc_cap = 0;
+		for (ii=0; ii < ioc->facts.NumberOfPorts; ii++) {
+			if (ioc->pfacts[ii].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_INITIATOR)
+				ioc_cap ++;
+		}
+
+		if (!ioc_cap) {
+			printk(MYIOC_s_WARN_FMT "Skipping ioc=%p because SCSI Initiator mode is NOT enabled!\n",
+					ioc->name, ioc);
+			continue;
+		}
+
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
-			tpnt->proc_dir = &proc_mpt_scsihost;
+		tpnt->proc_dir = &proc_mpt_scsihost;
 #endif
-			tpnt->proc_info = mptscsih_proc_info;
-			sh = scsi_register(tpnt, sizeof(MPT_SCSI_HOST));
-			if (sh != NULL) {
-				spin_lock_irqsave(&this->FreeQlock, flags);
-				sh->io_port = 0;
-				sh->n_io_port = 0;
-				sh->irq = 0;
-
-				/* Yikes!  This is important!
-				 * Otherwise, by default, linux
-				 * only scans target IDs 0-7!
-				 * pfactsN->MaxDevices unreliable
-				 * (not supported in early
-				 *	versions of the FW).
-				 * max_id = 1 + actual max id,
-				 * max_lun = 1 + actual last lun,
-				 *	see hosts.h :o(
-				 */
-				if ((int)this->chip_type > (int)FC929)
-					sh->max_id = MPT_MAX_SCSI_DEVICES;
-				else {
-					/* For FC, increase the queue depth
-					 * from MPT_SCSI_CAN_QUEUE (31)
-					 * to MPT_FC_CAN_QUEUE (63).
-					 */
-					sh->can_queue = MPT_FC_CAN_QUEUE;
-					sh->max_id = MPT_MAX_FC_DEVICES<256 ? MPT_MAX_FC_DEVICES : 255;
-				}
-				sh->max_lun = MPT_LAST_LUN + 1;
+		tpnt->proc_info = mptscsih_proc_info;
+		sh = scsi_register(tpnt, sizeof(MPT_SCSI_HOST));
+		if (sh != NULL) {
+			spin_lock_irqsave(&ioc->FreeQlock, flags);
+			sh->io_port = 0;
+			sh->n_io_port = 0;
+			sh->irq = 0;
+
+			/* Yikes!  This is important!
+			 * Otherwise, by default, linux
+			 * only scans target IDs 0-7!
+			 * pfactsN->MaxDevices unreliable
+			 * (not supported in early
+			 *	versions of the FW).
+			 * max_id = 1 + actual max id,
+			 * max_lun = 1 + actual last lun,
+			 *	see hosts.h :o(
+			 */
+			if ( mpt_can_queue < ioc->req_depth )
+				sh->can_queue = mpt_can_queue;
+			else
+				sh->can_queue = ioc->req_depth;
+			dinitprintk((MYIOC_s_WARN_FMT
+				"mpt_can_queue=%d req_depth=%d can_queue=%d\n",
+				ioc->name, mpt_can_queue, ioc->req_depth, 
+				sh->can_queue));
+			if (ioc->bus_type == SCSI)
+				sh->max_id = MPT_MAX_SCSI_DEVICES;
+			else if (ioc->bus_type == SAS)
+				sh->max_id = ioc->pfacts->MaxDevices + 1;
+			else {
+				sh->max_id = MPT_MAX_FC_DEVICES<256 ? MPT_MAX_FC_DEVICES : 255;
+			}
+			sh->max_lun = MPT_LAST_LUN + 1;
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,7)
-				sh->max_sectors = MPT_SCSI_MAX_SECTORS;
+			sh->max_sectors = MPT_SCSI_MAX_SECTORS;
 #endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,1) || defined CONFIG_HIGHIO
-				sh->highmem_io = 1;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,20) || defined CONFIG_HIGHIO
+			sh->highmem_io = 1;
 #endif
-				sh->this_id = this->pfacts[portnum].PortSCSIID;
+			/* MPI uses {port, bus, id, lun}, but logically maps
+			 * devices on different ports to different buses, i.e.,
+			 * bus 1 may be the 2nd bus on port 0 or the 1st bus on port 1.
+			 * Map bus to channel, ignore port number in SCSI....
+			 *	hd->port = 0;
+			 * If max_channel > 0, need to adjust mem alloc, free, DV
+			 * and all access to VirtDev
+			 */
+			sh->max_channel = 0;
+			sh->this_id = ioc->pfacts[0].PortSCSIID;
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,44)
-				/* OS entry to allow host drivers to force
-				 * a queue depth on a per device basis.
-				 */
-				sh->select_queue_depths = mptscsih_select_queue_depths;
+			/* OS entry to allow host drivers to force
+			 * a queue depth on a per device basis.
+			 */
+			sh->select_queue_depths = mptscsih_select_queue_depths;
 #endif
-				/* Required entry.
-				 */
-				sh->unique_id = this->id;
-
-				/* Verify that we won't exceed the maximum
-				 * number of chain buffers
-				 * We can optimize:  ZZ = req_sz/sizeof(SGE)
-				 * For 32bit SGE's:
-				 *  numSGE = 1 + (ZZ-1)*(maxChain -1) + ZZ
-				 *               + (req_sz - 64)/sizeof(SGE)
-				 * A slightly different algorithm is required for
-				 * 64bit SGEs.
-				 */
-				scale = this->req_sz/(sizeof(dma_addr_t) + sizeof(u32));
-				if (sizeof(dma_addr_t) == sizeof(u64)) {
-					numSGE = (scale - 1) * (this->facts.MaxChainDepth-1) + scale +
-						(this->req_sz - 60) / (sizeof(dma_addr_t) + sizeof(u32));
-				} else {
-					numSGE = 1 + (scale - 1) * (this->facts.MaxChainDepth-1) + scale +
-						(this->req_sz - 64) / (sizeof(dma_addr_t) + sizeof(u32));
-				}
-
-				if (numSGE < sh->sg_tablesize) {
-					/* Reset this value */
-					dprintk((MYIOC_s_INFO_FMT
-						 "Resetting sg_tablesize to %d from %d\n",
-						 this->name, numSGE, sh->sg_tablesize));
-					sh->sg_tablesize = numSGE;
-				}
+			/* Required entry.
+			 */
+			sh->unique_id = ioc->id;
 
-				/* Set the pci device pointer in Scsi_Host structure.
-				 */
-				scsi_set_pci_device(sh, this->pcidev);
+			sh->sg_tablesize = mpt_sg_tablesize;
 
-				spin_unlock_irqrestore(&this->FreeQlock, flags);
+			/* Set the pci device pointer in Scsi_Host structure.
+			 */
+			scsi_set_pci_device(sh, ioc->pcidev);
 
-				hd = (MPT_SCSI_HOST *) sh->hostdata;
-				hd->ioc = this;
-				hd->max_sge = sh->sg_tablesize;
+			spin_unlock_irqrestore(&ioc->FreeQlock, flags);
 
-				if ((int)this->chip_type > (int)FC929)
-					hd->is_spi = 1;
+			hd = (MPT_SCSI_HOST *) sh->hostdata;
+			hd->ioc = ioc;
 
-				if (DmpService &&
-				    (this->chip_type == FC919 || this->chip_type == FC929))
-					hd->is_multipath = 1;
+			/* SCSI needs Scsi_Cmnd lookup table!
+			 * (with size equal to req_depth*PtrSz!)
+			 */
+			sz = ioc->req_depth * sizeof(void *);
+			mem = kmalloc(sz, GFP_ATOMIC);
+			if (mem == NULL) {
+				dinitprintk((MYIOC_s_WARN_FMT "ScsiLookup allocation failed\n",
+					ioc->name));
+				goto done;
+			}
 
-				hd->port = 0;		/* FIXME! */
+			memset(mem, 0, sz);
+			hd->ScsiLookup = (struct scsi_cmnd **) mem;
 
-				/* SCSI needs Scsi_Cmnd lookup table!
-				 * (with size equal to req_depth*PtrSz!)
-				 */
-				sz = hd->ioc->req_depth * sizeof(void *);
-				mem = kmalloc(sz, GFP_ATOMIC);
-				if (mem == NULL)
-					goto done;
+			dinitprintk((MYIOC_s_WARN_FMT "ScsiLookup @ %p, sz=%d\n",
+				 ioc->name, hd->ScsiLookup, sz));
 
-				memset(mem, 0, sz);
-				hd->ScsiLookup = (struct scsi_cmnd **) mem;
+			mem = kmalloc(sz, GFP_ATOMIC);
+			if (mem == NULL) {
+				dinitprintk((MYIOC_s_WARN_FMT "PendingScsi allocation failed\n",
+					ioc->name));
+				goto done;
+			}
 
-				dprintk((MYIOC_s_INFO_FMT "ScsiLookup @ %p, sz=%d\n",
-					 this->name, hd->ScsiLookup, sz));
+			memset(mem, 0, sz);
+			hd->PendingScsi = (struct scsi_cmnd **) mem;
 
-				if (mptscsih_initChainBuffers(hd, 1) < 0)
-					goto done;
+			dinitprintk((MYIOC_s_WARN_FMT "PendingScsi @ %p, sz=%d\n",
+				 ioc->name, hd->PendingScsi, sz));
 
-				/* Allocate memory for free and doneQ's
-				 */
-				sz = sh->can_queue * sizeof(MPT_DONE_Q);
-				mem = kmalloc(sz, GFP_ATOMIC);
-				if (mem == NULL)
-					goto done;
+			/* Allocate memory for free and doneQ's
+			 */
+			sz = sh->can_queue * sizeof(MPT_REQUEST_Q);
+			mem = kmalloc(sz, GFP_ATOMIC);
+			if (mem == NULL) {
+				dinitprintk((MYIOC_s_WARN_FMT "memQ allocation failed\n",
+					ioc->name));
+				goto done;
+			}
 
-				memset(mem, 0xFF, sz);
-				hd->memQ = mem;
+			memset(mem, 0xFF, sz);
+			hd->memQ = mem;
 
-				/* Initialize the free, done and pending Qs.
-				 */
-				Q_INIT(&hd->freeQ, MPT_DONE_Q);
-				Q_INIT(&hd->doneQ, MPT_DONE_Q);
-				Q_INIT(&hd->pendingQ, MPT_DONE_Q);
-				spin_lock_init(&hd->freedoneQlock);
-
-				mem = hd->memQ;
-				for (ii=0; ii < sh->can_queue; ii++) {
-					freedoneQ = (MPT_DONE_Q *) mem;
-					Q_ADD_TAIL(&hd->freeQ.head, freedoneQ, MPT_DONE_Q);
-					mem += sizeof(MPT_DONE_Q);
-				}
+			/* Initialize the free and pending Qs.
+			 */
+			Q_INIT(&hd->freeQ, MPT_REQUEST_Q);
+			Q_INIT(&hd->pendingQ, MPT_REQUEST_Q);
+			spin_lock_init(&hd->freeQlock);
+
+			for (ii=0; ii < sh->can_queue; ii++) {
+				freeQ = (MPT_REQUEST_Q *) mem;
+				Q_ADD_TAIL(&hd->freeQ.head, freeQ, MPT_REQUEST_Q);
+				mem += sizeof(MPT_REQUEST_Q);
+			}
 
-				/* Initialize this Scsi_Host
-				 * internal task Q.
-				 */
-				Q_INIT(&hd->taskQ, MPT_FRAME_HDR);
-				hd->taskQcnt = 0;
+			/* Initialize this Scsi_Host
+			 * internal task Q.
+			 */
+			Q_INIT(&hd->taskQ, MPT_FRAME_HDR);
+			hd->taskQcnt = 0;
 
-				/* Allocate memory for the device structures.
-				 * A non-Null pointer at an offset
-				 * indicates a device exists.
-				 * max_id = 1 + maximum id (hosts.h)
-				 */
-				sz = sh->max_id * sizeof(void *);
-				mem = kmalloc(sz, GFP_ATOMIC);
-				if (mem == NULL)
-					goto done;
+			/* Allocate memory for the device structures.
+			 * A non-Null pointer at an offset
+			 * indicates a device exists.
+			 * max_id = 1 + maximum id (hosts.h)
+			 */
+			sz = sh->max_id * sizeof(void *);
+			mem = kmalloc(sz, GFP_ATOMIC);
+			if (mem == NULL)
+				goto done;
 
-				memset(mem, 0, sz);
-				hd->Targets = (VirtDevice **) mem;
+			memset(mem, 0, sz);
+			hd->Targets = (VirtDevice **) mem;
 
-				dprintk((KERN_INFO "  Targets @ %p, sz=%d\n", hd->Targets, sz));
+			dinitprintk((KERN_INFO "  Targets @ %p, sz=%d\n", hd->Targets, sz));
 
 
-				/* Clear the TM flags
-				 */
-				hd->tmPending = 0;
+			/* Clear the TM flags
+			 */
+			hd->tmPending = 0;
 #ifdef MPT_SCSI_USE_NEW_EH
-				hd->tmState = TM_STATE_NONE;
+			hd->tmState = TM_STATE_NONE;
 #endif
-				hd->resetPending = 0;
-				hd->abortSCpnt = NULL;
-				hd->tmPtr = NULL;
-				hd->numTMrequests = 0;
+			hd->resetPending = 0;
+			hd->abortSCpnt = NULL;
+			hd->tmPtr = NULL;
 
-				/* Clear the pointer used to store
-				 * single-threaded commands, i.e., those
-				 * issued during a bus scan, dv and
-				 * configuration pages.
-				 */
-				hd->cmdPtr = NULL;
+			/* Clear the pointer used to store
+			 * single-threaded commands, i.e., those
+			 * issued during a bus scan, dv and
+			 * configuration pages.
+			 */
+			hd->cmdPtr = NULL;
+
+			/* Attach the SCSI Host to the IOC structure
+			 */
+			ioc->sh = sh;
+
+			/* Initialize this SCSI Hosts' timers
+			 * To use, set the timer expires field
+			 * and add_timer
+			 */
+			init_timer(&hd->timer);
+			hd->timer.data = (unsigned long) hd;
+			hd->timer.function = mptscsih_timer_expired;
+
+			init_timer(&hd->TMtimer);
+			hd->TMtimer.data = (unsigned long) hd;
+			hd->TMtimer.function = mptscsih_taskmgmt_timeout;
+			hd->qtag_tick = jiffies;
 
-				/* Attach the SCSI Host to the IOC structure
+			if (ioc->bus_type == SAS) {
+				/* Update with the driver setup
+				 * values.
 				 */
-				this->sh = sh;
+				ioc->spi_data.ptClear =
+				    mpt_pt_clear;
+
+				if(ioc->spi_data.ptClear==1) {
+					mptbase_sas_persist_operation(
+					    ioc, MPI_SAS_OP_CLEAR_ALL_PERSISTENT);
+				}
+			}
 
-				/* Initialize this SCSI Hosts' timers
-				 * To use, set the timer expires field
-				 * and add_timer
+			if (ioc->bus_type == SCSI) {
+				/* Update with the driver setup
+				 * values.
 				 */
-				init_timer(&hd->timer);
-				hd->timer.data = (unsigned long) hd;
-				hd->timer.function = mptscsih_timer_expired;
-
-				init_timer(&hd->TMtimer);
-				hd->TMtimer.data = (unsigned long) hd;
-				hd->TMtimer.function = mptscsih_taskmgmt_timeout;
-				hd->qtag_tick = jiffies;
-
-				/* Moved Earlier Pam D */
-				/* this->sh = sh;	*/
-
-				if (hd->is_spi) {
-					/* Update with the driver setup
-					 * values.
-					 */
-					if (hd->ioc->spi_data.maxBusWidth > driver_setup.max_width)
-						hd->ioc->spi_data.maxBusWidth = driver_setup.max_width;
-					if (hd->ioc->spi_data.minSyncFactor < driver_setup.min_sync_fac)
-						hd->ioc->spi_data.minSyncFactor = driver_setup.min_sync_fac;
-
-					if (hd->ioc->spi_data.minSyncFactor == MPT_ASYNC)
-						hd->ioc->spi_data.maxSyncOffset = 0;
-
-					hd->negoNvram = 0;
-#ifdef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
-					hd->negoNvram = MPT_SCSICFG_USE_NVRAM;
-#endif
-					if (driver_setup.dv == 0)
-						hd->negoNvram = MPT_SCSICFG_USE_NVRAM;
+				if (ioc->spi_data.maxBusWidth > mpt_width)
+					ioc->spi_data.maxBusWidth = mpt_width;
+				if (ioc->spi_data.minSyncFactor < mpt_factor)
+					ioc->spi_data.minSyncFactor = mpt_factor;
 
-					hd->ioc->spi_data.forceDv = 0;
-					for (ii=0; ii < MPT_MAX_SCSI_DEVICES; ii++)
-						hd->ioc->spi_data.dvStatus[ii] = MPT_SCSICFG_NEGOTIATE;
-	
-					if (hd->negoNvram == 0) {
-						for (ii=0; ii < MPT_MAX_SCSI_DEVICES; ii++)
-							hd->ioc->spi_data.dvStatus[ii] |= MPT_SCSICFG_DV_NOT_DONE;
-					}
+				if (ioc->spi_data.minSyncFactor == MPT_ASYNC)
+					ioc->spi_data.maxSyncOffset = 0;
 
-					ddvprintk((MYIOC_s_INFO_FMT
-						"dv %x width %x factor %x \n",
-						hd->ioc->name, driver_setup.dv,
-						driver_setup.max_width,
-						driver_setup.min_sync_fac));
+				ioc->spi_data.Saf_Te = mpt_saf_te;
 
-				}
+				hd->negoNvram = 0;
+#ifndef MPTSCSIH_ENABLE_DOMAIN_VALIDATION
+				hd->negoNvram = MPT_SCSICFG_USE_NVRAM;
+#endif
+				ioc->spi_data.forceDv = 0;
+				ioc->spi_data.noQas = 0;
+				for (ii=0; ii < MPT_MAX_SCSI_DEVICES; ii++)
+					ioc->spi_data.dvStatus[ii] = MPT_SCSICFG_NEGOTIATE;
 
-				mpt_scsi_hosts++;
-			}
+//				if (hd->negoNvram == 0) {
+					for (ii=0; ii < MPT_MAX_SCSI_DEVICES; ii++)
+						ioc->spi_data.dvStatus[ii] |= MPT_SCSICFG_DV_NOT_DONE;
+//				}
 
-		}	/* for each adapter port */
+				dinitprintk((MYIOC_s_WARN_FMT
+					"dv %x width %x factor %x saf_te %x pt_clear %x\n",
+					ioc->name, mpt_dv,
+					mpt_width,
+					mpt_factor,
+					mpt_saf_te,
+					mpt_pt_clear));
+			}
 
-		this = mpt_adapter_find_next(this);
+			mpt_scsi_hosts++;
+		}
 	}
 
 done:
@@ -1967,6 +1771,7 @@ done:
 int
 mptscsih_release(struct Scsi_Host *host)
 {
+	MPT_ADAPTER	*ioc;
 	MPT_SCSI_HOST	*hd;
 	int 		 count;
 	unsigned long	 flags;
@@ -1974,7 +1779,7 @@ mptscsih_release(struct Scsi_Host *host)
 	hd = (MPT_SCSI_HOST *) host->hostdata;
 
 #ifndef MPT_SCSI_USE_NEW_EH
-#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+#ifdef MPTSCSIH_ENABLE_DOMAIN_VALIDATION
 	spin_lock_irqsave(&dvtaskQ_lock, flags);
 	dvtaskQ_release = 1;
 	spin_unlock_irqrestore(&dvtaskQ_lock, flags);
@@ -1984,7 +1789,7 @@ mptscsih_release(struct Scsi_Host *host)
 	spin_lock_irqsave(&mytaskQ_lock, flags);
 	if (mytaskQ_bh_active) {
 		spin_unlock_irqrestore(&mytaskQ_lock, flags);
-		dprintk((KERN_INFO MYNAM ": Info: Zapping TaskMgmt thread!\n"));
+		dexitprintk((KERN_INFO MYNAM ": Info: Zapping TaskMgmt thread!\n"));
 		clean_taskQ(hd);
 
 		while(mytaskQ_bh_active && --count) {
@@ -1999,7 +1804,7 @@ mptscsih_release(struct Scsi_Host *host)
 
 #endif
 
-#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+#ifdef MPTSCSIH_ENABLE_DOMAIN_VALIDATION
 	/* Check DV thread active */
 	count = 10 * HZ;
 	spin_lock_irqsave(&dvtaskQ_lock, flags);
@@ -2016,54 +1821,35 @@ mptscsih_release(struct Scsi_Host *host)
 		printk(KERN_ERR MYNAM ": ERROR - DV thread still active!\n");
 #if defined(MPT_DEBUG_DV) || defined(MPT_DEBUG_DV_TINY)
 	else
-		printk(KERN_ERR MYNAM ": DV thread orig %d, count %d\n", 10 * HZ, count);
+		printk(KERN_ERR MYNAM ": DV thread orig %d, count %d\n", (int)(10 * HZ), count);
 #endif
 #endif
 
 	unregister_reboot_notifier(&mptscsih_notifier);
 
 	if (hd != NULL) {
-		int sz1, sz2, sz3, sztarget=0;
-		int szr2chain = 0;
-		int szc2chain = 0;
-		int szchain = 0;
+		int sz1, sz3, sztarget=0;
 		int szQ = 0;
 
+		ioc = hd->ioc;
 		/* Synchronize disk caches
 		 */
 		(void) mptscsih_synchronize_cache(hd, 0);
 
-		sz1 = sz2 = sz3 = 0;
+		sz1 = sz3 = 0;
 
 		if (hd->ScsiLookup != NULL) {
 			sz1 = hd->ioc->req_depth * sizeof(void *);
 			kfree(hd->ScsiLookup);
 			hd->ScsiLookup = NULL;
-		}
-
-		if (hd->ReqToChain != NULL) {
-			szr2chain = hd->ioc->req_depth * sizeof(int);
-			kfree(hd->ReqToChain);
-			hd->ReqToChain = NULL;
-		}
-
-		if (hd->ChainToChain != NULL) {
-			szc2chain = hd->num_chain * sizeof(int);
-			kfree(hd->ChainToChain);
-			hd->ChainToChain = NULL;
-		}
-
-		if (hd->ChainBuffer != NULL) {
-			sz2 = hd->num_chain * hd->ioc->req_sz;
-			szchain = szr2chain + szc2chain + sz2;
-
-			pci_free_consistent(hd->ioc->pcidev, sz2,
-				    hd->ChainBuffer, hd->ChainBufferDMA);
-			hd->ChainBuffer = NULL;
+			kfree(hd->PendingScsi);
+			hd->PendingScsi = NULL;
+			dexitprintk((MYIOC_s_WARN_FMT "Free'd ScsiLookup, PendingScsi (%d) memory\n",
+				hd->ioc->name, sz1));
 		}
 
 		if (hd->memQ != NULL) {
-			szQ = host->can_queue * sizeof(MPT_DONE_Q);
+			szQ = host->can_queue * sizeof(MPT_REQUEST_Q);
 			kfree(hd->memQ);
 			hd->memQ = NULL;
 		}
@@ -2074,11 +1860,12 @@ mptscsih_release(struct Scsi_Host *host)
 			/*
 			 * Free any target structures that were allocated.
 			 */
-			if (hd->is_spi) {
+			if (hd->ioc->bus_type == SCSI)
 				max = MPT_MAX_SCSI_DEVICES;
-			} else {
+			else if (hd->ioc->bus_type == SAS)
+				max = hd->ioc->sh->max_id;
+			else
 				max = MPT_MAX_FC_DEVICES<256 ? MPT_MAX_FC_DEVICES : 255;
-			}
 			for (ii=0; ii < max; ii++) {
 				if (hd->Targets[ii]) {
 					kfree(hd->Targets[ii]);
@@ -2095,9 +1882,9 @@ mptscsih_release(struct Scsi_Host *host)
 			hd->Targets = NULL;
 		}
 
-		dprintk((MYIOC_s_INFO_FMT "Free'd ScsiLookup (%d), chain (%d) and Target (%d+%d) memory\n",
-				hd->ioc->name, sz1, szchain, sz3, sztarget));
-		dprintk(("Free'd done and free Q (%d) memory\n", szQ));
+		dexitprintk((MYIOC_s_WARN_FMT "Free'd Target (%d+%d) memory\n",
+				hd->ioc->name, sz3, sztarget));
+		dexitprintk(("Free'd done and free Q (%d) memory\n", szQ));
 	}
 	/* NULL the Scsi_Host pointer
 	 */
@@ -2107,10 +1894,10 @@ mptscsih_release(struct Scsi_Host *host)
 	if (mpt_scsi_hosts) {
 		if (--mpt_scsi_hosts == 0) {
 			mpt_reset_deregister(ScsiDoneCtx);
-			dprintk((KERN_INFO MYNAM ": Deregistered for IOC reset notifications\n"));
+			dexitprintk((KERN_INFO MYNAM ": Deregistered for IOC reset notifications\n"));
 
 			mpt_event_deregister(ScsiDoneCtx);
-			dprintk((KERN_INFO MYNAM ": Deregistered for IOC event notifications\n"));
+			dexitprintk((KERN_INFO MYNAM ": Deregistered for IOC event notifications\n"));
 
 			mpt_deregister(ScsiScanDvCtx);
 			mpt_deregister(ScsiTaskCtx);
@@ -2139,8 +1926,8 @@ mptscsih_release(struct Scsi_Host *host)
 static int
 mptscsih_halt(struct notifier_block *nb, ulong event, void *buf)
 {
-	MPT_ADAPTER *ioc = NULL;
-	MPT_SCSI_HOST *hd = NULL;
+	MPT_ADAPTER *ioc;
+	MPT_SCSI_HOST *hd;
 
 	/* Ignore all messages other than reboot message
 	 */
@@ -2148,7 +1935,7 @@ mptscsih_halt(struct notifier_block *nb,
 		&& (event != SYS_POWER_OFF))
 		return (NOTIFY_DONE);
 
-	for (ioc = mpt_adapter_find_first(); ioc != NULL; ioc =	mpt_adapter_find_next(ioc)) {
+	list_for_each_entry(ioc, &ioc_list, list) {
 		/* Flush the cache of this adapter
 		 */
 		if (ioc->sh) {
@@ -2175,7 +1962,7 @@ mptscsih_halt(struct notifier_block *nb,
 const char *
 mptscsih_info(struct Scsi_Host *SChost)
 {
-	MPT_SCSI_HOST *h = NULL;
+	MPT_SCSI_HOST *h;
 	int size = 0;
 
 	if (info_kbuf == NULL)
@@ -2251,11 +2038,6 @@ static int mptscsih_host_info(MPT_ADAPTE
 	return ((info.pos > info.offset) ? info.pos - info.offset : 0);
 }
 
-static int mptscsih_user_command(MPT_ADAPTER *ioc, char *pbuf, int len)
-{
-	/* Not yet implemented */
-	return len;
-}
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
@@ -2270,10 +2052,11 @@ static int mptscsih_user_command(MPT_ADA
  * 	hostno: scsi host number
  *	func:   if write = 1; if read = 0
  */
-int mptscsih_proc_info(char *buffer, char **start, off_t offset,
+int
+mptscsih_proc_info(char *buffer, char **start, off_t offset,
 			int length, int hostno, int func)
 {
-	MPT_ADAPTER	*ioc = NULL;
+	MPT_ADAPTER	*ioc;
 	MPT_SCSI_HOST	*hd = NULL;
 	int size = 0;
 
@@ -2281,7 +2064,7 @@ int mptscsih_proc_info(char *buffer, cha
 	dprintk(("buffer %p, start=%p (%p) offset=%ld length = %d\n",
 			buffer, start, *start, offset, length));
 
-	for (ioc = mpt_adapter_find_first(); ioc != NULL; ioc = mpt_adapter_find_next(ioc)) {
+	list_for_each_entry(ioc, &ioc_list, list) {
 		if ((ioc->sh) && (ioc->sh->host_no == hostno)) {
 			hd = (MPT_SCSI_HOST *)ioc->sh->hostdata;
 			break;
@@ -2291,7 +2074,7 @@ int mptscsih_proc_info(char *buffer, cha
 		return 0;
 
 	if (func) {
-		size = mptscsih_user_command(ioc, buffer, length);
+//		size = mptscsih_user_command(ioc, buffer, length);
 	} else {
 		if (start)
 			*start = buffer;
@@ -2304,60 +2087,14 @@ int mptscsih_proc_info(char *buffer, cha
 
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-	static int max_qd = 1;
-#if 0
-static int index_log[128];
-static int index_ent = 0;
-static __inline__ void ADD_INDEX_LOG(int req_ent)
+#ifdef MPT_DEBUG_QCMD_DEPTH
+static void mptscsih_scsi_done(MPT_ADAPTER *ioc, Scsi_Cmnd *SCpnt)
 {
-	int i = index_ent++;
-
-	index_log[i & (128 - 1)] = req_ent;
+	ioc->qcmd_depth--;
+	SCpnt->scsi_done(SCpnt);
 }
-#else
-#define ADD_INDEX_LOG(req_ent)	do { } while(0)
 #endif
 
-#ifdef	DROP_TEST
-#define DROP_IOC	1	/* IOC to force failures */
-#define DROP_TARGET	3	/* Target ID to force failures */
-#define	DROP_THIS_CMD	10000	/* iteration to drop command */
-static int dropCounter = 0;
-static int dropTestOK = 0;	/* num did good */
-static int dropTestBad = 0;	/* num did bad */
-static int dropTestNum = 0;	/* total = good + bad + incomplete */
-static int numTotCmds = 0;
-static MPT_FRAME_HDR *dropMfPtr = NULL;
-static int numTMrequested = 0;
-#endif
-
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/*
- *	mptscsih_put_msgframe - Wrapper routine to post message frame to F/W.
- *	@context: Call back context (ScsiDoneCtx, ScsiScanDvCtx)
- *	@id: IOC id number
- *	@mf: Pointer to message frame
- *
- *	Handles the call to mptbase for posting request and queue depth
- *	tracking.
- *
- *	Returns none.
- */
-static inline void
-mptscsih_put_msgframe(int context, int id, MPT_FRAME_HDR *mf)
-{
-	/* Main banana... */
-	atomic_inc(&queue_depth);
-	if (atomic_read(&queue_depth) > max_qd) {
-		max_qd = atomic_read(&queue_depth);
-		dprintk((KERN_INFO MYNAM ": Queue depth now %d.\n", max_qd));
-	}
-
-	mpt_put_msg_frame(context, id, mf);
-
-	return;
-}
-
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mptscsih_qcmd - Primary Fusion MPT SCSI initiator IO start routine.
@@ -2374,88 +2111,78 @@ int
 mptscsih_qcmd(Scsi_Cmnd *SCpnt, void (*done)(Scsi_Cmnd *))
 {
 	MPT_SCSI_HOST		*hd;
+	MPT_ADAPTER		*ioc;
 	MPT_FRAME_HDR		*mf;
 	SCSIIORequest_t		*pScsiReq;
 	VirtDevice		*pTarget;
-	MPT_DONE_Q		*buffer = NULL;
+	MPT_REQUEST_Q		*buffer;
 	unsigned long		 flags;
 	int	 target;
 	int	 lun;
 	int	 datadir;
 	u32	 datalen;
 	u32	 scsictl;
-	u32	 scsidir;
 	u32	 cmd_len;
 	int	 my_idx;
 	int	 ii;
-	int	 rc;
-	int	 did_errcode;
-	int	 issueCmd;
 
-	did_errcode = 0;
 	hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata;
+	ioc = hd->ioc;
 	target = SCpnt->target;
 	lun = SCpnt->lun;
 	SCpnt->scsi_done = done;
 
 	pTarget = hd->Targets[target];
 
-	dmfprintk((MYIOC_s_INFO_FMT "qcmd: SCpnt=%p, done()=%p\n",
-			(hd && hd->ioc) ? hd->ioc->name : "ioc?", SCpnt, done));
-
-#ifdef MPT_SAVE_AUTOSENSE
-	/* 20000617 -sralston
-	 *  GRRRRR...  Shouldn't have to do this but...
-	 *  Do explicit check for REQUEST_SENSE and cached SenseData.
-	 *  If yes, return cached SenseData.
-	 */
-	if (SCpnt->cmnd[0] == REQUEST_SENSE) {
-		u8 *dest = NULL;
-		int sz;
-
-		if (pTarget && (pTarget->tflags & MPT_TARGET_FLAGS_VALID_SENSE)) {
-			pTarget->tflags &= ~MPT_TARGET_FLAGS_VALID_SENSE;	//sjr-moved-here
-			if (!SCpnt->use_sg) {
-				dest = SCpnt->request_buffer;
-			} else {
-				struct scatterlist *sg = (struct scatterlist *) SCpnt->request_buffer;
-				if (sg)
-					dest = (u8 *)(ulong)sg_dma_address(sg);
-			}
-
-			if (dest) {
-				sz = MIN (SCSI_STD_SENSE_BYTES, SCpnt->request_bufflen);
-				memcpy(dest, pTarget->sense, sz);
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-				SCpnt->resid = SCpnt->request_bufflen - sz;
+#ifdef MPT_DEBUG_QCMD_DEPTH
+	ioc->qcmd_depth++;
+	if(ioc->qcmd_depth > ioc->sh->can_queue-5 )
+		printk("qcmd_depth=%d on %s\n",ioc->qcmd_depth, ioc->name);
 #endif
-				SCpnt->result = 0;
-				SCpnt->scsi_done(SCpnt);
-
-				//sjr-moved-up//pTarget->tflags &= ~MPT_TARGET_FLAGS_VALID_SENSE;
 
-				return 0;
-			}
-		}
-	}
+	if ( pTarget ) {
+		if ( lun > pTarget->last_lun ) {
+			dsprintk((MYIOC_s_WARN_FMT
+				"qcmd: lun=%d > last_lun=%d on id=%d\n",
+				ioc->name, lun, pTarget->last_lun, target));
+			SCpnt->result = DID_BAD_TARGET << 16;
+#ifdef MPT_DEBUG_QCMD_DEPTH
+			mptscsih_scsi_done(ioc,SCpnt);
+#else
+			SCpnt->scsi_done(SCpnt);
 #endif
+			return FAILED;
+		}
+		/* Default to untagged. Once a target structure has been
+		 * allocated, use the Inquiry data to determine if device
+		 * supports tagged.
+	 	*/
+		if ( (pTarget->tflags & MPT_TARGET_FLAGS_Q_YES)
+		    && (SCpnt->device->tagged_supported)) {
+			scsictl = MPI_SCSIIO_CONTROL_SIMPLEQ;
+		} else {
+			scsictl = MPI_SCSIIO_CONTROL_UNTAGGED;
+		}
 
-	if (hd->resetPending) {
-		/* Prevent new commands from being issued
-		 * while reloading the FW.
-		 */
-		did_errcode = 1;
-		goto did_error;
-	}
+	} else
+		scsictl = MPI_SCSIIO_CONTROL_UNTAGGED;
+	dmfprintk((MYIOC_s_WARN_FMT "qcmd: SCpnt=%p, done()=%p\n",
+		ioc->name, SCpnt, done));
 
 	/*
 	 *  Put together a MPT SCSI request...
 	 */
-	if ((mf = mpt_get_msg_frame(ScsiDoneCtx, hd->ioc->id)) == NULL) {
-		dprintk((MYIOC_s_WARN_FMT "QueueCmd, no msg frames!!\n",
-				hd->ioc->name));
-		did_errcode = 2;
+	if ((mf = mpt_get_msg_frame(ScsiDoneCtx, ioc)) == NULL) {
+		dfailprintk((MYIOC_s_WARN_FMT "QueueCmd, SCpnt=%p no msg frames!!\n",
+				ioc->name, SCpnt));
+#ifdef MPT_DEBUG_QCMD_DEPTH
+		dfailprintk((MYIOC_s_WARN_FMT "QueueCmd: qcmd_depth=%d\n",
+				ioc->name, ioc->qcmd_depth));
+#endif
+#ifdef MFCNT
+		dfailprintk((MYIOC_s_WARN_FMT "QueueCmd mfcnt=%d!!\n",
+				ioc->name, ioc->mfcnt));
+#endif
 		goto did_error;
 	}
 
@@ -2463,45 +2190,31 @@ mptscsih_qcmd(Scsi_Cmnd *SCpnt, void (*d
 
 	my_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
 
-	ADD_INDEX_LOG(my_idx);
-
 	/*
 	 *  The scsi layer should be handling this stuff
 	 *  (In 2.3.x it does -DaveM)
 	 */
 
-	/*  BUG FIX!  19991030 -sralston
-	 *    TUR's being issued with scsictl=0x02000000 (DATA_IN)!
+	/*    TUR's being issued with scsictl=0x02000000 (DATA_IN)!
 	 *    Seems we may receive a buffer (datalen>0) even when there
 	 *    will be no data transfer!  GRRRRR...
 	 */
 	datadir = mptscsih_io_direction(SCpnt);
 	if (datadir == SCSI_DATA_READ) {
 		datalen = SCpnt->request_bufflen;
-		scsidir = MPI_SCSIIO_CONTROL_READ;	/* DATA IN  (host<--ioc<--dev) */
+		scsictl |= MPI_SCSIIO_CONTROL_READ;	/* DATA IN  (host<--ioc<--dev) */
 	} else if (datadir == SCSI_DATA_WRITE) {
 		datalen = SCpnt->request_bufflen;
-		scsidir = MPI_SCSIIO_CONTROL_WRITE;	/* DATA OUT (host-->ioc-->dev) */
+		scsictl |= MPI_SCSIIO_CONTROL_WRITE;	/* DATA OUT (host-->ioc-->dev) */
 	} else {
 		datalen = 0;
-		scsidir = MPI_SCSIIO_CONTROL_NODATATRANSFER;
-	}
-
-	/* Default to untagged. Once a target structure has been allocated,
-	 * use the Inquiry data to determine if device supports tagged.
-	 */
-	if (   pTarget
-	    && (pTarget->tflags & MPT_TARGET_FLAGS_Q_YES)
-	    && (SCpnt->device->tagged_supported)) {
-		scsictl = scsidir | MPI_SCSIIO_CONTROL_SIMPLEQ;
-	} else {
-		scsictl = scsidir | MPI_SCSIIO_CONTROL_UNTAGGED;
+		scsictl |= MPI_SCSIIO_CONTROL_NODATATRANSFER;
 	}
 
 	/* Use the above information to set up the message frame
 	 */
-	pScsiReq->TargetID = target;
-	pScsiReq->Bus = hd->port;
+	pScsiReq->TargetID = (u8) target;
+	pScsiReq->Bus = (u8) SCpnt->channel;
 	pScsiReq->ChainOffset = 0;
 	pScsiReq->Function = MPI_FUNCTION_SCSI_IO_REQUEST;
 	pScsiReq->CDBLength = SCpnt->cmd_len;
@@ -2520,7 +2233,6 @@ mptscsih_qcmd(Scsi_Cmnd *SCpnt, void (*d
 
 	/*
 	 *  Write SCSI CDB into the message
-	 *  Should write from cmd_len up to 16, but skip for performance reasons.
 	 */
 	cmd_len = SCpnt->cmd_len;
 	for (ii=0; ii < cmd_len; ii++)
@@ -2533,172 +2245,128 @@ mptscsih_qcmd(Scsi_Cmnd *SCpnt, void (*d
 	pScsiReq->DataLength = cpu_to_le32(datalen);
 
 	/* SenseBuffer low address */
-	pScsiReq->SenseBufferLowAddr = cpu_to_le32(hd->ioc->sense_buf_low_dma
+	pScsiReq->SenseBufferLowAddr = cpu_to_le32(ioc->sense_buf_low_dma
 					   + (my_idx * MPT_SENSE_BUFFER_ALLOC));
 
 	/* Now add the SG list
 	 * Always have a SGE even if null length.
 	 */
-	rc = SUCCESS;
 	if (datalen == 0) {
 		/* Add a NULL SGE */
 		mptscsih_add_sge((char *)&pScsiReq->SGL, MPT_SGE_FLAGS_SSIMPLE_READ | 0,
 			(dma_addr_t) -1);
 	} else {
 		/* Add a 32 or 64 bit SGE */
-		rc = mptscsih_AddSGE(hd, SCpnt, pScsiReq, my_idx);
+		if ( mptscsih_AddSGE(ioc, SCpnt, pScsiReq, my_idx) != SUCCESS ) {
+			dfailprintk((MYIOC_s_WARN_FMT "QueueCmd, SCpnt=%p insufficient Chain Buffers!!\n",
+					ioc->name, SCpnt));
+			mptscsih_freeChainBuffers(ioc, my_idx);
+			mpt_free_msg_frame(ioc, mf);
+			goto did_error;
+		}
 	}
 
+	/* SCSI specific processing */
+	if (ioc->bus_type == SCSI) {
+		int dvStatus = ioc->spi_data.dvStatus[target];
+
+		if (dvStatus || ioc->spi_data.forceDv) {
+
+#ifdef MPTSCSIH_ENABLE_DOMAIN_VALIDATION
+			if ((dvStatus & MPT_SCSICFG_NEED_DV) ||
+				(ioc->spi_data.forceDv & MPT_SCSICFG_NEED_DV)) {
+				unsigned long lflags;
+				/* Schedule DV if necessary */
+				spin_lock_irqsave(&dvtaskQ_lock, lflags);
+				if (!dvtaskQ_active) {
+					dvtaskQ_active = 1;
+					spin_unlock_irqrestore(&dvtaskQ_lock, lflags);
+					MPT_INIT_WORK(&mptscsih_dvTask, mptscsih_domainValidation, (void *) hd);
 
-	if (rc == SUCCESS) {
-		hd->ScsiLookup[my_idx] = SCpnt;
-		SCpnt->host_scribble = NULL;
-
-#ifdef	DROP_TEST
-		numTotCmds++;
-		/* If the IOC number and target match, increment
-		 * counter. If counter matches DROP_THIS, do not
-		 * issue command to FW to force a reset.
-		 * Save the MF pointer so we can free resources
-		 * when task mgmt completes.
-		 */
-		if ((hd->ioc->id == DROP_IOC) && (target == DROP_TARGET)) {
-			dropCounter++;
-
-			if (dropCounter == DROP_THIS_CMD) {
-				dropCounter = 0;
-
-				/* If global is set, then we are already
-				 * doing something - so keep issuing commands.
-				 */
-				if (dropMfPtr == NULL) {
-					dropTestNum++;
-					dropMfPtr = mf;
-					atomic_inc(&queue_depth);
-					printk(MYIOC_s_INFO_FMT
-						"Dropped SCSI cmd (%p)\n",
-						hd->ioc->name, SCpnt);
-					printk("mf (%p) req (%4x) tot cmds (%d)\n",
-						mf, my_idx, numTotCmds);
-
-					return 0;
+					SCHEDULE_TASK(&mptscsih_dvTask);
+				} else {
+					spin_unlock_irqrestore(&dvtaskQ_lock, lflags);
 				}
+				ioc->spi_data.forceDv &= ~MPT_SCSICFG_NEED_DV;
 			}
-		}
-#endif
-
-		/* SCSI specific processing */
-		issueCmd = 1;
-		if (hd->is_spi) {
-			int dvStatus = hd->ioc->spi_data.dvStatus[target];
-
-			if (dvStatus || hd->ioc->spi_data.forceDv) {
-
-				/* Write SDP1 on this I/O to this target */
-				if (dvStatus & MPT_SCSICFG_NEGOTIATE) {
-					mptscsih_writeSDP1(hd, 0, target, hd->negoNvram);
-					dvStatus &= ~MPT_SCSICFG_NEGOTIATE;
-					hd->ioc->spi_data.dvStatus[target] =  dvStatus;
-				} else if (dvStatus & MPT_SCSICFG_BLK_NEGO) {
-					mptscsih_writeSDP1(hd, 0, target, MPT_SCSICFG_BLK_NEGO);
-					dvStatus &= ~MPT_SCSICFG_BLK_NEGO;
-					hd->ioc->spi_data.dvStatus[target] =  dvStatus;
-				}
-
-#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
-				if ((dvStatus & MPT_SCSICFG_NEED_DV) ||
-					(hd->ioc->spi_data.forceDv & MPT_SCSICFG_NEED_DV)) {
-					unsigned long lflags;
-					/* Schedule DV if necessary */
-					spin_lock_irqsave(&dvtaskQ_lock, lflags);
-					if (!dvtaskQ_active) {
-						dvtaskQ_active = 1;
-						spin_unlock_irqrestore(&dvtaskQ_lock, lflags);
-						MPT_INIT_WORK(&mptscsih_dvTask, mptscsih_domainValidation, (void *) hd);
-
-						SCHEDULE_TASK(&mptscsih_dvTask);
-					} else {
-						spin_unlock_irqrestore(&dvtaskQ_lock, lflags);
-					}
-					hd->ioc->spi_data.forceDv &= ~MPT_SCSICFG_NEED_DV;
-				}
 
-				/* Trying to do DV to this target, extend timeout.
-				 * Wait to issue intil flag is clear
-				 */
-				if (dvStatus & MPT_SCSICFG_DV_PENDING) {
-					mod_timer(&SCpnt->eh_timeout, jiffies + 40 * HZ);
-					issueCmd = 0;
-				}
+			/* Set the DV flags.
+			 */
+			if (dvStatus & MPT_SCSICFG_DV_NOT_DONE)
+				mptscsih_set_dvflags(hd, pScsiReq);
 
-				/* Set the DV flags.
-				 */
-				if (dvStatus & MPT_SCSICFG_DV_NOT_DONE)
-					mptscsih_set_dvflags(hd, pScsiReq);
-#endif
+			/* Trying to do DV to this target, extend timeout.
+			 * Wait to issue until flag is clear
+			 */
+			if (dvStatus & MPT_SCSICFG_DV_PENDING) {
+				mod_timer(&SCpnt->eh_timeout, jiffies + 40 * HZ);
+				dfailprintk((MYIOC_s_WARN_FMT "QueueCmd, SCpnt=%p DV_PENDING!!\n",
+					ioc->name, SCpnt));
+				goto queueCmd;
 			}
+#endif
 		}
+	}
 
-		if (issueCmd) {
-			mptscsih_put_msgframe(ScsiDoneCtx, hd->ioc->id, mf);
-			dmfprintk((MYIOC_s_INFO_FMT "Issued SCSI cmd (%p) mf=%p idx=%d\n",
-					hd->ioc->name, SCpnt, mf, my_idx));
-		} else {
-			ddvtprintk((MYIOC_s_INFO_FMT "Pending cmd=%p idx %d\n",
-					hd->ioc->name, SCpnt, my_idx));
-			/* Place this command on the pendingQ if possible */
-			spin_lock_irqsave(&hd->freedoneQlock, flags);
-			if (!Q_IS_EMPTY(&hd->freeQ)) {
-				buffer = hd->freeQ.head;
-				Q_DEL_ITEM(buffer);
+	if (hd->resetPending) {
+		/* Prevent new commands from being issued.
+		 */
+		dpendprintk((MYIOC_s_WARN_FMT "QueueCmd, SCpnt=%p resetPending!!\n",
+			ioc->name, SCpnt));
+		goto queueCmd;
+	}
 
-				/* Save the mf pointer
-				 */
-				buffer->argp = (void *)mf;
+	hd->ScsiLookup[my_idx] = SCpnt;
+	SCpnt->host_scribble = NULL;
 
-				/* Add to the pendingQ
-				 */
-				Q_ADD_TAIL(&hd->pendingQ.head, buffer, MPT_DONE_Q);
-				spin_unlock_irqrestore(&hd->freedoneQlock, flags);
-			} else {
-				spin_unlock_irqrestore(&hd->freedoneQlock, flags);
-				SCpnt->result = (DID_BUS_BUSY << 16);
-				SCpnt->scsi_done(SCpnt);
-			}
-		}
-	} else {
-		mptscsih_freeChainBuffers(hd, my_idx);
-		mpt_free_msg_frame(ScsiDoneCtx, hd->ioc->id, mf);
-		did_errcode = 3;
-		goto did_error;
-	}
+	mpt_put_msg_frame(ScsiDoneCtx, ioc, mf);
+	dmfprintk((MYIOC_s_WARN_FMT "Issued SCSI cmd (%p) mf=%p idx=%d\n",
+			ioc->name, SCpnt, mf, my_idx));
+	DBG_DUMP_REQUEST_FRAME(mf)
 
 	return 0;
 
 did_error:
-	dprintk((MYIOC_s_WARN_FMT "_qcmd did_errcode=%d (sc=%p)\n",
-			hd->ioc->name, did_errcode, SCpnt));
 	/* Just wish OS to issue a retry */
 	SCpnt->result = (DID_BUS_BUSY << 16);
-	spin_lock_irqsave(&hd->freedoneQlock, flags);
+#ifdef MPT_DEBUG_QCMD_DEPTH
+	mptscsih_scsi_done(ioc,SCpnt);
+#else
+	SCpnt->scsi_done(SCpnt);
+#endif
+	return FAILED;
+
+queueCmd:
+	dpendprintk((MYIOC_s_WARN_FMT "Pending cmd=%p idx %d\n",
+		ioc->name, SCpnt, my_idx));
+	/* Place this command on the pendingQ if possible */
+	spin_lock_irqsave(&hd->freeQlock, flags);
+	hd->PendingScsi[my_idx] = SCpnt;
 	if (!Q_IS_EMPTY(&hd->freeQ)) {
 		buffer = hd->freeQ.head;
 		Q_DEL_ITEM(buffer);
 
-		/* Set the Scsi_Cmnd pointer
+		/* Save the mf pointer
 		 */
-		buffer->argp = (void *)SCpnt;
+		buffer->argp = (void *)mf;
 
-		/* Add to the doneQ
+		/* Add to the pendingQ
 		 */
-		Q_ADD_TAIL(&hd->doneQ.head, buffer, MPT_DONE_Q);
-		spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+		Q_ADD_TAIL(&hd->pendingQ.head, buffer, MPT_REQUEST_Q);
+		spin_unlock_irqrestore(&hd->freeQlock, flags);
+		return 0;
 	} else {
-		spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+		dpendprintk((MYIOC_s_WARN_FMT "Pending cmd=%p idx %d freeQ is EMPTY!!!\n",
+			ioc->name, SCpnt, my_idx));
+		spin_unlock_irqrestore(&hd->freeQlock, flags);
+		SCpnt->result = (DID_BUS_BUSY << 16);
+#ifdef MPT_DEBUG_QCMD_DEPTH
+		mptscsih_scsi_done(ioc,SCpnt);
+#else
 		SCpnt->scsi_done(SCpnt);
+#endif
+		return FAILED;
 	}
-
-	return 0;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -2712,9 +2380,9 @@ did_error:
  *	No return.
  */
 static void
-mptscsih_freeChainBuffers(MPT_SCSI_HOST *hd, int req_idx)
+mptscsih_freeChainBuffers(MPT_ADAPTER *ioc, int req_idx)
 {
-	MPT_FRAME_HDR *chain = NULL;
+	MPT_FRAME_HDR *chain;
 	unsigned long flags;
 	int chain_idx;
 	int next;
@@ -2722,28 +2390,28 @@ mptscsih_freeChainBuffers(MPT_SCSI_HOST 
 	/* Get the first chain index and reset
 	 * tracker state.
 	 */
-	chain_idx = hd->ReqToChain[req_idx];
-	hd->ReqToChain[req_idx] = MPT_HOST_NO_CHAIN;
+	chain_idx = ioc->ReqToChain[req_idx];
+	ioc->ReqToChain[req_idx] = MPT_HOST_NO_CHAIN;
 
 	while (chain_idx != MPT_HOST_NO_CHAIN) {
 
 		/* Save the next chain buffer index */
-		next = hd->ChainToChain[chain_idx];
+		next = ioc->ChainToChain[chain_idx];
 
 		/* Free this chain buffer and reset
 		 * tracker
 		 */
-		hd->ChainToChain[chain_idx] = MPT_HOST_NO_CHAIN;
+		ioc->ChainToChain[chain_idx] = MPT_HOST_NO_CHAIN;
 
-		chain = (MPT_FRAME_HDR *) (hd->ChainBuffer
-					+ (chain_idx * hd->ioc->req_sz));
-		spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
-		Q_ADD_TAIL(&hd->FreeChainQ.head,
+		chain = (MPT_FRAME_HDR *) (ioc->ChainBuffer
+					+ (chain_idx * ioc->req_sz));
+		spin_lock_irqsave(&ioc->FreeQlock, flags);
+		Q_ADD_TAIL(&ioc->FreeChainQ.head,
 					&chain->u.frame.linkage, MPT_FRAME_HDR);
-		spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+		spin_unlock_irqrestore(&ioc->FreeQlock, flags);
 
-		dmfprintk((MYIOC_s_INFO_FMT "FreeChainBuffers (index %d)\n",
-				hd->ioc->name, chain_idx));
+		dsgprintk((MYIOC_s_WARN_FMT "FreeChainBuffers (index %d)\n",
+				ioc->name, chain_idx));
 
 		/* handle next */
 		chain_idx = next;
@@ -2777,9 +2445,9 @@ mptscsih_freeChainBuffers(MPT_SCSI_HOST 
  *	Returns 0 for SUCCESS or -1 if FAILED.
  */
 static int
-mptscsih_TMHandler(MPT_SCSI_HOST *hd, u8 type, u8 target, u8 lun, int ctx2abort, int sleepFlag)
+mptscsih_TMHandler(MPT_SCSI_HOST *hd, u8 type, u8 channel, u8 target, u8 lun, int ctx2abort, int sleepFlag)
 {
-	MPT_ADAPTER	*ioc = NULL;
+	MPT_ADAPTER	*ioc;
 	int		 rc = -1;
 	int		 doTask = 1;
 	u32		 ioc_raw_state;
@@ -2792,27 +2460,53 @@ mptscsih_TMHandler(MPT_SCSI_HOST *hd, u8
 		return 0;
 
 	ioc = hd->ioc;
-	dtmprintk((MYIOC_s_INFO_FMT "TMHandler Entered!\n", ioc->name));
-
 	if (ioc == NULL) {
 		printk(KERN_ERR MYNAM " TMHandler" " NULL ioc!\n");
-		return 0;
+		return FAILED;
 	}
+	dtmprintk((MYIOC_s_WARN_FMT "TMHandler Entered!\n", ioc->name));
 
 	// SJR - CHECKME - Can we avoid this here?
 	// (mpt_HardResetHandler has this check...)
 	spin_lock_irqsave(&ioc->diagLock, flags);
 	if ((ioc->diagPending) || (ioc->alt_ioc && ioc->alt_ioc->diagPending)) {
 		spin_unlock_irqrestore(&ioc->diagLock, flags);
-		return 0;
+		return FAILED;
 	}
 	spin_unlock_irqrestore(&ioc->diagLock, flags);
 
-	/* Do not do a Task Management if there are
-	 * too many failed TMs on this adapter.
+#ifdef MPT_SCSI_USE_NEW_EH
+	/*  Wait a fixed amount of time for the TM pending flag to be cleared.
+	 *  If we time out and not bus reset, then we return a FAILED status to the caller.
+	 *  The call to mptscsih_tm_pending_wait() will set the pending flag if we are
+	 *  successful. Otherwise, reload the FW.
 	 */
-	if (hd->numTMrequests > MPT_HOST_TOO_MANY_TM)
-		doTask = 0;
+	if (mptscsih_tm_pending_wait(hd) == FAILED) {
+		if (type == MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK) {
+			nehprintk((KERN_INFO MYNAM ": %s: TMHandler abort: "
+			   "Timed out waiting for last TM (%d) to complete! \n",
+			   hd->ioc->name, hd->tmPending));
+			return FAILED;
+		} else if (type == MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET) {
+			nehprintk((KERN_INFO MYNAM ": %s: TMHandler target reset: "
+			   "Timed out waiting for last TM (%d) to complete! \n",
+			   hd->ioc->name, hd->tmPending));
+			return FAILED;
+		} else if (type == MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS) {
+			nehprintk((KERN_INFO MYNAM ": %s: TMHandler bus reset: "
+			   "Timed out waiting for last TM (%d) to complete! \n",
+			   hd->ioc->name, hd->tmPending));
+			if (hd->tmPending & (1 << MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS))
+				return FAILED;
+				
+			doTask = 0;
+		}
+	} else {
+		spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+		hd->tmPending |=  (1 << type);
+		spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+	}
+#endif
 
 	/* Is operational?
 	 */
@@ -2821,7 +2515,7 @@ mptscsih_TMHandler(MPT_SCSI_HOST *hd, u8
 #ifdef MPT_DEBUG_RESET
 	if ((ioc_raw_state & MPI_IOC_STATE_MASK) != MPI_IOC_STATE_OPERATIONAL) {
 		printk(MYIOC_s_WARN_FMT
-			"TM Handler: IOC Not operational! state 0x%x Calling HardResetHandler\n",
+			"TM Handler: IOC Not operational(0x%x)!\n",
 			hd->ioc->name, ioc_raw_state);
 	}
 #endif
@@ -2833,37 +2527,32 @@ mptscsih_TMHandler(MPT_SCSI_HOST *hd, u8
 		 */
 		if (hd->hard_resets < -1)
 			hd->hard_resets++;
-		rc = mptscsih_IssueTaskMgmt(hd, type, target, lun, ctx2abort, sleepFlag);
+		rc = mptscsih_IssueTaskMgmt(hd, type, channel, target, lun, ctx2abort, sleepFlag);
 		if (rc) {
-			printk(MYIOC_s_INFO_FMT "Issue of TaskMgmt failed!\n", hd->ioc->name);
+			printk(MYIOC_s_WARN_FMT "Issue of TaskMgmt failed!\n", hd->ioc->name);
 		} else {
-			dtmprintk((MYIOC_s_INFO_FMT "Issue of TaskMgmt Successful!\n", hd->ioc->name));
+			dtmprintk((MYIOC_s_WARN_FMT "Issue of TaskMgmt Successful!\n", hd->ioc->name));
 		}
 	}
-#ifdef DROP_TEST
-	numTMrequested++;
-	if (numTMrequested > 5) {
-		rc = 0;		/* set to 1 to force a hard reset */
-		numTMrequested = 0;
-	}
-#endif
 
-	if (rc || ioc->reload_fw || (ioc->alt_ioc && ioc->alt_ioc->reload_fw)) {
-		dtmprintk((MYIOC_s_INFO_FMT "Falling through to HardReset! \n",
+	/* Only fall through to the HRH if this is a bus reset
+	 */
+	if ((type == MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS) && (rc ||
+		ioc->reload_fw || (ioc->alt_ioc && ioc->alt_ioc->reload_fw))) {
+		dtmprintk((MYIOC_s_WARN_FMT "Calling HardReset! \n",
 			 hd->ioc->name));
 		rc = mpt_HardResetHandler(hd->ioc, sleepFlag);
 	}
 
-	dtmprintk((MYIOC_s_INFO_FMT "TMHandler rc = %d!\n", hd->ioc->name, rc));
+	dtmprintk((MYIOC_s_WARN_FMT "TMHandler rc = %d!\n", hd->ioc->name, rc));
 #ifndef MPT_SCSI_USE_NEW_EH
-	dtmprintk((MYIOC_s_INFO_FMT "TMHandler: _bh_handler state (%d) taskQ count (%d)\n",
+	dtmprintk((MYIOC_s_WARN_FMT "TMHandler: _bh_handler state (%d) taskQ count (%d)\n",
 		ioc->name, mytaskQ_bh_active, hd->taskQcnt));
 #endif
 
 	return rc;
 }
 
-
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *	mptscsih_IssueTaskMgmt - Generic send Task Management function.
@@ -2883,7 +2572,7 @@ mptscsih_TMHandler(MPT_SCSI_HOST *hd, u8
  *	else other non-zero value returned.
  */
 static int
-mptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd, u8 type, u8 target, u8 lun, int ctx2abort, int sleepFlag)
+mptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd, u8 type, u8 channel, u8 target, u8 lun, int ctx2abort, int sleepFlag)
 {
 	MPT_FRAME_HDR	*mf;
 	SCSITaskMgmt_t	*pScsiTm;
@@ -2892,20 +2581,20 @@ mptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd
 
 	/* Return Fail to calling function if no message frames available.
 	 */
-	if ((mf = mpt_get_msg_frame(ScsiTaskCtx, hd->ioc->id)) == NULL) {
-		dtmprintk((MYIOC_s_WARN_FMT "IssueTaskMgmt, no msg frames!!\n",
+	if ((mf = mpt_get_msg_frame(ScsiTaskCtx, hd->ioc)) == NULL) {
+		dfailprintk((MYIOC_s_ERR_FMT "IssueTaskMgmt, no msg frames!!\n",
 				hd->ioc->name));
 		//return FAILED;
 		return -999;
 	}
-	dtmprintk((MYIOC_s_INFO_FMT "IssueTaskMgmt request @ %p\n",
+	dtmprintk((MYIOC_s_WARN_FMT "IssueTaskMgmt request @ %p\n",
 			hd->ioc->name, mf));
 
 	/* Format the Request
 	 */
 	pScsiTm = (SCSITaskMgmt_t *) mf;
 	pScsiTm->TargetID = target;
-	pScsiTm->Bus = hd->port;
+	pScsiTm->Bus = channel;
 	pScsiTm->ChainOffset = 0;
 	pScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;
 
@@ -2924,27 +2613,27 @@ mptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd
 		pScsiTm->Reserved2[ii] = 0;
 
 	pScsiTm->TaskMsgContext = ctx2abort;
-	dtmprintk((MYIOC_s_INFO_FMT "IssueTaskMgmt, ctx2abort (0x%08x), type (%d)\n",
-			hd->ioc->name, ctx2abort, type));
 
 	/* MPI v0.10 requires SCSITaskMgmt requests be sent via Doorbell/handshake
-		mpt_put_msg_frame(hd->ioc->id, mf);
 	* Save the MF pointer in case the request times out.
 	*/
 	hd->tmPtr = mf;
-	hd->numTMrequests++;
 	hd->TMtimer.expires = jiffies + HZ*20;  /* 20 seconds */
 	add_timer(&hd->TMtimer);
 
-	if ((retval = mpt_send_handshake_request(ScsiTaskCtx, hd->ioc->id,
+	dtmprintk((MYIOC_s_WARN_FMT "IssueTaskMgmt: ctx2abort (0x%08x) type=%d\n",
+			hd->ioc->name, ctx2abort, type));
+
+	DBG_DUMP_TM_REQUEST_FRAME((u32 *)pScsiTm);
+
+	if ((retval = mpt_send_handshake_request(ScsiTaskCtx, hd->ioc,
 				sizeof(SCSITaskMgmt_t), (u32*)pScsiTm, sleepFlag))
 	!= 0) {
-		dtmprintk((MYIOC_s_WARN_FMT "_send_handshake FAILED!"
+		dfailprintk((MYIOC_s_ERR_FMT "_send_handshake FAILED!"
 			" (hd %p, ioc %p, mf %p) \n", hd->ioc->name, hd, hd->ioc, mf));
-		hd->numTMrequests--;
 		hd->tmPtr = NULL;
 		del_timer(&hd->TMtimer);
-		mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
+		mpt_free_msg_frame(hd->ioc, mf);
 	}
 
 	return retval;
@@ -2960,7 +2649,7 @@ mptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd
  *
  *	Returns SUCCESS or FAILED.
  */
-int
+static int
 mptscsih_abort(Scsi_Cmnd * SCpnt)
 {
 	MPT_SCSI_HOST	*hd;
@@ -2972,15 +2661,22 @@ mptscsih_abort(Scsi_Cmnd * SCpnt)
 	 */
 	if ((hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata) == NULL) {
 		SCpnt->result = DID_RESET << 16;
+#ifdef MPT_DEBUG_QCMD_DEPTH
+		mptscsih_scsi_done(ioc,SCpnt);
+#else
 		SCpnt->scsi_done(SCpnt);
-		nehprintk((KERN_WARNING MYNAM ": mptscsih_abort: "
+#endif
+		dfailprintk((KERN_INFO MYNAM ": mptscsih_abort: "
 			   "Can't locate host! (sc=%p)\n",
 			   SCpnt));
 		return FAILED;
 	}
 
-	printk(KERN_WARNING MYNAM ": %s: >> Attempting task abort! (sc=%p, numIOs=%d)\n",
-	       hd->ioc->name, SCpnt, atomic_read(&queue_depth));
+	if (hd->resetPending)
+		return FAILED;
+
+	printk(KERN_WARNING MYNAM ": %s: Attempting task abort! (sc=%p)\n",
+	       hd->ioc->name, SCpnt);
 
 	if (hd->timeouts < -1)
 		hd->timeouts++;
@@ -2988,41 +2684,24 @@ mptscsih_abort(Scsi_Cmnd * SCpnt)
 	/* Find this command
 	 */
 	if ((scpnt_idx = SCPNT_TO_LOOKUP_IDX(SCpnt)) < 0) {
-		/* Cmd not found in ScsiLookup. If found in
-		 * doneQ, delete from Q. Do OS callback.
+		/* Cmd not found in ScsiLookup.
 		 */
-		search_doneQ_for_cmd(hd, SCpnt);
-
 		SCpnt->result = DID_RESET << 16;
-		SCpnt->scsi_done(SCpnt);
-		nehprintk((KERN_WARNING MYNAM ": %s: mptscsih_abort: "
+		nehprintk((KERN_INFO MYNAM ": %s: mptscsih_abort: "
 			   "Command not in the active list! (sc=%p)\n",
 			   hd->ioc->name, SCpnt));
 		return SUCCESS;
 	}
 
-	/*  Wait a fixed amount of time for the TM pending flag to be cleared.
-	 *  If we time out, then we return a FAILED status to the caller.  This
-	 *  call to mptscsih_tm_pending_wait() will set the pending flag if we are
-	 *  successful.
-	 */
-	if (mptscsih_tm_pending_wait(hd) == FAILED){
-		nehprintk((KERN_WARNING MYNAM ": %s: mptscsih_abort: "
-			   "Timed out waiting for previous TM to complete! "
-			   "(sc = %p)\n",
-			   hd->ioc->name, SCpnt));
-		return FAILED;
-	}
-
 	/* If this command is pended, then timeout/hang occurred
 	 * during DV. Post command and flush pending Q
 	 * and then following up with the reset request.
 	 */
 	if ((mf = mptscsih_search_pendingQ(hd, scpnt_idx)) != NULL) {
-		mptscsih_put_msgframe(ScsiDoneCtx, hd->ioc->id, mf);
+		mpt_put_msg_frame(ScsiDoneCtx, hd->ioc, mf);
 		post_pendingQ_commands(hd);
-		nehprintk((KERN_WARNING MYNAM ": %s: mptscsih_abort: "
-			   "Found command in pending queue! (sc=%p)\n",
+		nehprintk((KERN_INFO MYNAM ": %s: mptscsih_abort: "
+			   "Posting pended cmd! (sc=%p)\n",
 			   hd->ioc->name, SCpnt));
 	}
 
@@ -3038,7 +2717,7 @@ mptscsih_abort(Scsi_Cmnd * SCpnt)
 
 	hd->abortSCpnt = SCpnt;
 	if (mptscsih_TMHandler(hd, MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK,
-	                       SCpnt->target, SCpnt->lun, ctx2abort, NO_SLEEP)
+	                       SCpnt->channel, SCpnt->target, SCpnt->lun, ctx2abort, NO_SLEEP)
 		< 0) {
 
 		/* The TM request failed and the subsequent FW-reload failed!
@@ -3067,7 +2746,7 @@ mptscsih_abort(Scsi_Cmnd * SCpnt)
  *
  *	Returns SUCCESS or FAILED.
  */
-int
+static int
 mptscsih_dev_reset(Scsi_Cmnd * SCpnt)
 {
 	MPT_SCSI_HOST	*hd;
@@ -3075,35 +2754,20 @@ mptscsih_dev_reset(Scsi_Cmnd * SCpnt)
 	/* If we can't locate our host adapter structure, return FAILED status.
 	 */
 	if ((hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata) == NULL){
-		nehprintk((KERN_WARNING MYNAM ": mptscsih_dev_reset: "
+		nehprintk((KERN_INFO MYNAM ": mptscsih_dev_reset: "
 			   "Can't locate host! (sc=%p)\n",
 			   SCpnt));
 		return FAILED;
 	}
 
-	printk(KERN_WARNING MYNAM ": %s: >> Attempting target reset! (sc=%p, numIOs=%d)\n",
-	       hd->ioc->name, SCpnt, atomic_read(&queue_depth));
-
-	/* Unsupported for SCSI. Suppored for FCP
-	 */
-	if (hd->is_spi)
+	if (hd->resetPending)
 		return FAILED;
 
-	/*  Wait a fixed amount of time for the TM pending flag to be cleared.
-	 *  If we time out, then we return a FAILED status to the caller.  This
-	 *  call to mptscsih_tm_pending_wait() will set the pending flag if we are
-	 *  successful.
-	 */
-	if (mptscsih_tm_pending_wait(hd) == FAILED) {
-		nehprintk((KERN_WARNING MYNAM ": %s: mptscsih_dev_reset: "
-			   "Timed out waiting for previous TM to complete! "
-			   "(sc = %p)\n",
-			   hd->ioc->name, SCpnt));
-		return FAILED;
-	}
+	printk(KERN_WARNING MYNAM ": %s: >> Attempting target reset! (sc=%p)\n",
+	       hd->ioc->name, SCpnt);
 
 	if (mptscsih_TMHandler(hd, MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET,
-	                       SCpnt->target, 0, 0, NO_SLEEP)
+	                       SCpnt->channel, SCpnt->target, 0, 0, NO_SLEEP)
 		< 0){
 		/* The TM request failed and the subsequent FW-reload failed!
 		 * Fatal error case.
@@ -3127,7 +2791,7 @@ mptscsih_dev_reset(Scsi_Cmnd * SCpnt)
  *
  *	Returns SUCCESS or FAILED.
  */
-int
+static int
 mptscsih_bus_reset(Scsi_Cmnd * SCpnt)
 {
 	MPT_SCSI_HOST	*hd;
@@ -3135,34 +2799,21 @@ mptscsih_bus_reset(Scsi_Cmnd * SCpnt)
 	/* If we can't locate our host adapter structure, return FAILED status.
 	 */
 	if ((hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata) == NULL){
-		nehprintk((KERN_WARNING MYNAM ": mptscsih_bus_reset: "
+		nehprintk((KERN_INFO MYNAM ": mptscsih_bus_reset: "
 			   "Can't locate host! (sc=%p)\n",
 			   SCpnt ) );
 		return FAILED;
 	}
 
-	printk(KERN_WARNING MYNAM ": %s: >> Attempting bus reset! (sc=%p, numIOs=%d)\n",
-	       hd->ioc->name, SCpnt, atomic_read(&queue_depth));
+	printk(KERN_WARNING MYNAM ": %s: >> Attempting bus reset! (sc=%p)\n",
+	       hd->ioc->name, SCpnt);
 
 	if (hd->timeouts < -1)
 		hd->timeouts++;
 
-	/*  Wait a fixed amount of time for the TM pending flag to be cleared.
-	 *  If we time out, then we return a FAILED status to the caller.  This
-	 *  call to mptscsih_tm_pending_wait() will set the pending flag if we are
-	 *  successful.
-	 */
-	if (mptscsih_tm_pending_wait(hd) == FAILED) {
-		nehprintk((KERN_WARNING MYNAM ": %s: mptscsih_bus_reset: "
-			   "Timed out waiting for previous TM to complete! "
-			   "(sc = %p)\n",
-			   hd->ioc->name, SCpnt));
-		return FAILED;
-	}
-
 	/* We are now ready to execute the task management request. */
 	if (mptscsih_TMHandler(hd, MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS,
-	                       0, 0, 0, NO_SLEEP)
+	                       SCpnt->channel, 0, 0, 0, NO_SLEEP)
 	    < 0){
 
 		/* The TM request failed and the subsequent FW-reload failed!
@@ -3189,7 +2840,7 @@ mptscsih_bus_reset(Scsi_Cmnd * SCpnt)
  *
  *	Returns SUCCESS or FAILED.
  */
-int
+static int
 mptscsih_host_reset(Scsi_Cmnd *SCpnt)
 {
 	MPT_SCSI_HOST *  hd;
@@ -3197,7 +2848,7 @@ mptscsih_host_reset(Scsi_Cmnd *SCpnt)
 
 	/*  If we can't locate the host to reset, then we failed. */
 	if ((hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata) == NULL){
-		nehprintk( ( KERN_WARNING MYNAM ": mptscsih_host_reset: "
+		nehprintk( ( KERN_INFO MYNAM ": mptscsih_host_reset: "
 			     "Can't locate host! (sc=%p)\n",
 			     SCpnt ) );
 		return FAILED;
@@ -3205,8 +2856,6 @@ mptscsih_host_reset(Scsi_Cmnd *SCpnt)
 
 	printk(KERN_WARNING MYNAM ": %s: >> Attempting host reset! (sc=%p)\n",
 	       hd->ioc->name, SCpnt);
-	printk(KERN_WARNING MYNAM ": %s: IOs outstanding = %d\n",
-	       hd->ioc->name, atomic_read(&queue_depth));
 
 	/*  If our attempts to reset the host failed, then return a failed
 	 *  status.  The host will be taken off line by the SCSI mid-layer.
@@ -3222,7 +2871,7 @@ mptscsih_host_reset(Scsi_Cmnd *SCpnt)
 	}
 
 
-	nehprintk( ( KERN_WARNING MYNAM ": mptscsih_host_reset: "
+	nehprintk( ( KERN_INFO MYNAM ": mptscsih_host_reset: "
 		     "Status = %s\n",
 		     (status == SUCCESS) ? "SUCCESS" : "FAILED" ) );
 
@@ -3241,7 +2890,7 @@ static int
 mptscsih_tm_pending_wait(MPT_SCSI_HOST * hd)
 {
 	unsigned long  flags;
-	int            loop_count = 60 * 4;  /* Wait 60 seconds */
+	int            loop_count = 2 * 10 * 4;  /* Wait 2 seconds */
 	int            status = FAILED;
 
 	do {
@@ -3254,6 +2903,8 @@ mptscsih_tm_pending_wait(MPT_SCSI_HOST *
 			break;
 		}
 		spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+		//set_current_state(TASK_INTERRUPTIBLE);
+		//schedule_timeout(HZ/4);
 		mdelay(250);
 	} while (--loop_count);
 
@@ -3275,41 +2926,42 @@ mptscsih_old_abort(Scsi_Cmnd *SCpnt)
 {
 	MPT_SCSI_HOST		*hd;
 	MPT_FRAME_HDR		*mf;
+	VirtDevice		*pTarget;
 	struct mpt_work_struct	*ptaskfoo;
 	unsigned long		 flags;
 	int			 scpnt_idx;
-
-	printk(KERN_WARNING MYNAM ": OldAbort scheduling ABORT SCSI IO (sc=%p)\n", (void *) SCpnt);
-	printk(KERN_WARNING "  IOs outstanding = %d\n", atomic_read(&queue_depth));
+	int	 	 	 target;
 
 	if ((hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata) == NULL) {
-		printk(KERN_WARNING "  WARNING - OldAbort, NULL hostdata ptr!!\n");
+		printk(KERN_WARNING " OldAbort: NULL hostdata ptr!!\n");
 		SCpnt->result = DID_ERROR << 16;
-		SCpnt->scsi_done(SCpnt);
 		return SCSI_ABORT_NOT_RUNNING;
 	}
 
+	target = SCpnt->target;
+	if (hd->Targets[target] == NULL) {
+		printk(KERN_WARNING MYNAM ": %s: id=%d OldAbort: unknown target (sc=%p)\n", hd->ioc->name, target, (void *) SCpnt);
+		SCpnt->result = DID_BAD_TARGET << 16;
+		return SCSI_ABORT_ERROR;
+	}
+
 	if (hd->timeouts < -1)
 		hd->timeouts++;
 
 	if ((scpnt_idx = SCPNT_TO_LOOKUP_IDX(SCpnt)) < 0) {
 		/* Cmd not found in ScsiLookup.
-		 * If found in doneQ, delete from Q.
-		 * Do OS callback.
 		 */
-		search_doneQ_for_cmd(hd, SCpnt);
+		dtmprintk((MYIOC_s_WARN_FMT "OldAbort: cmd (%p) was not found \n",
+			hd->ioc->name, SCpnt));
 
-		SCpnt->result = DID_RESET << 16;
-		SCpnt->scsi_done(SCpnt);
 		return SCSI_ABORT_SUCCESS;
 	} else {
-		/* If this command is pended, then timeout/hang occurred
-		 * during DV. Force bus reset by posting command to F/W
-		 * and then following up with the reset request.
-		 */
 		if ((mf = mptscsih_search_pendingQ(hd, scpnt_idx)) != NULL) {
-			mptscsih_put_msgframe(ScsiDoneCtx, hd->ioc->id, mf);
-			post_pendingQ_commands(hd);
+			dtmprintk((MYIOC_s_WARN_FMT "OldAbort: cmd (%p) was found in pendingQ\n",
+				hd->ioc->name, SCpnt));
+			mptscsih_freeChainBuffers(hd->ioc, scpnt_idx);
+			mpt_free_msg_frame(hd->ioc, mf);
+			return SCSI_ABORT_SUCCESS;
 		}
 	}
 
@@ -3318,17 +2970,21 @@ mptscsih_old_abort(Scsi_Cmnd *SCpnt)
 	 */
 	mf = search_taskQ(0, SCpnt, hd, MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK);
 	if (mf != NULL) {
-		dtmprintk((MYIOC_s_INFO_FMT "OldAbort:Abort Task PENDING cmd (%p) taskQ depth (%d)\n",
+		dtmprintk((MYIOC_s_WARN_FMT "OldAbort:Abort Task PENDING cmd (%p) taskQ depth (%d)\n",
 			hd->ioc->name, SCpnt, hd->taskQcnt));
 		return SCSI_ABORT_PENDING;
 	}
 
+	printk(KERN_WARNING MYNAM ": %s: id=%d OldAbort: scheduling ABORT SCSI IO (sc=%p)\n", hd->ioc->name, target, (void *) SCpnt);
+
 	// SJR - CHECKME - Can we avoid this here?
 	// (mpt_HardResetHandler has this check...)
 	/* If IOC is reloading FW, return PENDING.
 	 */
 	spin_lock_irqsave(&hd->ioc->diagLock, flags);
 	if (hd->ioc->diagPending) {
+		dtmprintk((MYIOC_s_WARN_FMT "OldAbort: cmd=%p diagPending \n",
+			hd->ioc->name, SCpnt));
 		spin_unlock_irqrestore(&hd->ioc->diagLock, flags);
 		return SCSI_ABORT_PENDING;
 	}
@@ -3336,15 +2992,15 @@ mptscsih_old_abort(Scsi_Cmnd *SCpnt)
 
 	/* If there are no message frames what should we do?
 	 */
-	if ((mf = mpt_get_msg_frame(ScsiTaskCtx, hd->ioc->id)) == NULL) {
-		printk((KERN_WARNING "  WARNING - OldAbort, no msg frames!!\n"));
+	if ((mf = mpt_get_msg_frame(ScsiTaskCtx, hd->ioc)) == NULL) {
+		printk(KERN_WARNING MYNAM ": %s OldAbort: cmd=%p no Msg Frame is available!!\n", hd->ioc->name, SCpnt);
 		/* We are out of message frames!
 		 * Call the reset handler to do a FW reload.
 		 */
-		printk((KERN_WARNING " Reloading Firmware!!\n"));
+/*		printk(KERN_WARNING " Reloading Firmware!!\n");
 		if (mpt_HardResetHandler(hd->ioc, NO_SLEEP) < 0) {
 			printk((KERN_WARNING " Firmware Reload FAILED!!\n"));
-		}
+		} */
 		return SCSI_ABORT_PENDING;
 	}
 
@@ -3367,25 +3023,23 @@ mptscsih_old_abort(Scsi_Cmnd *SCpnt)
 	/* For the time being, force bus reset on any abort
 	 * requests for the 1030/1035 FW.
 	 */
-	if (hd->is_spi)
+	if ((hd->ioc->bus_type == SCSI))
 		mf->u.frame.linkage.arg1 = MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS;
+	else if ((hd->ioc->bus_type == SAS))
+		mf->u.frame.linkage.arg1 = MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK;
 	else
 		mf->u.frame.linkage.arg1 = MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK;
 
 	mf->u.frame.linkage.argp1 = SCpnt;
 	mf->u.frame.linkage.argp2 = (void *) hd;
 
-	dtmprintk((MYIOC_s_INFO_FMT "OldAbort:_bh_handler state (%d) taskQ count (%d)\n",
+	dtmprintk((MYIOC_s_WARN_FMT "OldAbort:_bh_handler state (%d) taskQ count (%d)\n",
 		hd->ioc->name, mytaskQ_bh_active, hd->taskQcnt));
 
 	if (! mytaskQ_bh_active) {
 		mytaskQ_bh_active = 1;
 		spin_unlock_irqrestore(&mytaskQ_lock, flags);
 
-		/*
-		 *  Oh how cute, no alloc/free/mgmt needed if we use
-		 *  (bottom/unused portion of) MPT request frame.
-		 */
 		ptaskfoo = (struct mpt_work_struct *) &mptscsih_ptaskfoo;
 		MPT_INIT_WORK(&mptscsih_ptaskfoo, mptscsih_taskmgmt_bh, (void *) SCpnt);
 
@@ -3412,40 +3066,39 @@ mptscsih_old_reset(Scsi_Cmnd *SCpnt, uns
 {
 	MPT_SCSI_HOST		*hd;
 	MPT_FRAME_HDR		*mf;
+	VirtDevice		*pTarget;
 	struct mpt_work_struct	*ptaskfoo;
 	unsigned long		 flags;
 	int			 scpnt_idx;
-
-	printk(KERN_WARNING MYNAM ": OldReset scheduling BUS_RESET (sc=%p)\n", (void *) SCpnt);
-	printk(KERN_WARNING "  IOs outstanding = %d\n", atomic_read(&queue_depth));
+	int	 	 	 target;
 
 	if ((hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata) == NULL) {
-		SCpnt->result = DID_RESET << 16;
-		SCpnt->scsi_done(SCpnt);
-		return SCSI_RESET_SUCCESS;
+		printk(KERN_WARNING " OldReset: NULL hostdata ptr!!\n");
+		SCpnt->result = DID_ERROR << 16;
+		return SCSI_RESET_ERROR;
 	}
 
+	target = SCpnt->target;
+
 	if (hd->timeouts < -1)
 		hd->timeouts++;
 
 	if ((scpnt_idx = SCPNT_TO_LOOKUP_IDX(SCpnt)) < 0) {
 		/* Cmd not found in ScsiLookup.
-		 * If found in doneQ, delete from Q.
-		 * Do OS callback.
 		 */
-		search_doneQ_for_cmd(hd, SCpnt);
+		drsprintk((MYIOC_s_WARN_FMT "OldReset: cmd (%p) was not found in SCPNT_TO_LOOKUP_IDX\n",
+			hd->ioc->name, SCpnt));
 
 		SCpnt->result = DID_RESET << 16;
-		SCpnt->scsi_done(SCpnt);
 		return SCSI_RESET_SUCCESS;
 	} else {
-		/* If this command is pended, then timeout/hang occurred
-		 * during DV. Force bus reset by posting command to F/W
-		 * and then following up with the reset request.
-		 */
 		if ((mf = mptscsih_search_pendingQ(hd, scpnt_idx)) != NULL) {
-			mptscsih_put_msgframe(ScsiDoneCtx, hd->ioc->id, mf);
-			post_pendingQ_commands(hd);
+			drsprintk((MYIOC_s_WARN_FMT "OldReset: cmd (%p) was found in pendingQ\n",
+				hd->ioc->name, SCpnt));
+			mptscsih_freeChainBuffers(hd->ioc, scpnt_idx);
+			mpt_free_msg_frame(hd->ioc, mf);
+			SCpnt->result = DID_RESET << 16;
+			return SCSI_RESET_SUCCESS;
 		}
 	}
 
@@ -3456,11 +3109,11 @@ mptscsih_old_reset(Scsi_Cmnd *SCpnt, uns
 	search_taskQ(1, SCpnt, hd, MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK);
 
 	/*
-	 *  Check to see if there's already a BUS_RESET queued for this guy.
+	 *  Check to see if there's already a BUS_RESET queued.
 	 */
 	mf = search_taskQ(0, SCpnt, hd, MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS);
 	if (mf != NULL) {
-		dtmprintk((MYIOC_s_INFO_FMT "OldReset:Reset Task PENDING cmd (%p) taskQ depth (%d)\n",
+		drsprintk((MYIOC_s_WARN_FMT "OldReset:Reset Task PENDING cmd (%p) taskQ depth (%d)\n",
 			hd->ioc->name, SCpnt, hd->taskQcnt));
 		return SCSI_RESET_PENDING;
 	}
@@ -3476,14 +3129,17 @@ mptscsih_old_reset(Scsi_Cmnd *SCpnt, uns
 	}
 	spin_unlock_irqrestore(&hd->ioc->diagLock, flags);
 
-	if ((mf = mpt_get_msg_frame(ScsiTaskCtx, hd->ioc->id)) == NULL) {
+	printk(KERN_WARNING MYNAM ": %s: id=%d OldReset: scheduling BUS_RESET SCSI IO (sc=%p)\n", hd->ioc->name, target, (void *) SCpnt);
+
+	if ((mf = mpt_get_msg_frame(ScsiTaskCtx, hd->ioc)) == NULL) {
+		printk(KERN_WARNING MYNAM ": %s OldReset: cmd=%p no Msg Frame is available!!\n", hd->ioc->name, SCpnt);
 		/* We are out of message frames!
 		 * Call the reset handler to do a FW reload.
 		 */
-		printk((KERN_WARNING " Reloading Firmware!!\n"));
+/*		printk((KERN_WARNING " Reloading Firmware!!\n"));
 		if (mpt_HardResetHandler(hd->ioc, NO_SLEEP) < 0) {
 			printk((KERN_WARNING " Firmware Reload FAILED!!\n"));
-		}
+		} */
 		return SCSI_RESET_PENDING;
 	}
 
@@ -3498,7 +3154,7 @@ mptscsih_old_reset(Scsi_Cmnd *SCpnt, uns
 	spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
 
 
-	dtmprintk((MYIOC_s_INFO_FMT "OldReset: _bh_handler state (%d) taskQ count (%d)\n",
+	dtmprintk((MYIOC_s_WARN_FMT "OldReset: _bh_handler state (%d) taskQ count (%d)\n",
 		hd->ioc->name, mytaskQ_bh_active, hd->taskQcnt));
 
 	spin_lock_irqsave(&mytaskQ_lock, flags);
@@ -3542,6 +3198,7 @@ mptscsih_taskmgmt_bh(void *sc)
 {
 	MPT_ADAPTER	*ioc;
 	Scsi_Cmnd	*SCpnt;
+	Scsi_Cmnd	*LookupSCpnt;
 	MPT_FRAME_HDR	*mf = NULL;
 	MPT_SCSI_HOST	*hd;
 	u32		 ctx2abort = 0;
@@ -3559,7 +3216,7 @@ mptscsih_taskmgmt_bh(void *sc)
 		schedule_timeout(HZ/4);
 		did = 0;
 
-		for (ioc = mpt_adapter_find_first(); ioc != NULL; ioc = mpt_adapter_find_next(ioc)) {
+		list_for_each_entry(ioc, &ioc_list, list) {
 			if (ioc->sh) {
 				hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
 				if (hd == NULL) {
@@ -3600,7 +3257,7 @@ mptscsih_taskmgmt_bh(void *sc)
 				if (SCpnt == NULL) {
 					printk(KERN_ERR MYNAM ": ERROR - TaskMgmt has NULL SCpnt! (mf=%p:sc=%p)\n",
 							(void *) mf, (void *) SCpnt);
-					mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
+					mpt_free_msg_frame(hd->ioc, mf);
 					spin_lock_irqsave(&ioc->FreeQlock, flags);
 					hd->tmPending = 0;
 					spin_unlock_irqrestore(&ioc->FreeQlock, flags);
@@ -3617,7 +3274,7 @@ mptscsih_taskmgmt_bh(void *sc)
 					 * request. We are done.
 					 * Free the current MF and continue.
 					 */
-					mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
+					mpt_free_msg_frame(hd->ioc, mf);
 					spin_lock_irqsave(&ioc->FreeQlock, flags);
 					hd->tmPending = 0;
 					spin_unlock_irqrestore(&ioc->FreeQlock, flags);
@@ -3628,7 +3285,7 @@ mptscsih_taskmgmt_bh(void *sc)
 				if (scpnt_idx != SCPNT_TO_LOOKUP_IDX(SCpnt)) {
 					/* Error! this should never happen!!
 					 */
-					mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
+					mpt_free_msg_frame(hd->ioc, mf);
 					spin_lock_irqsave(&ioc->FreeQlock, flags);
 					hd->tmPending = 0;
 					spin_unlock_irqrestore(&ioc->FreeQlock, flags);
@@ -3659,10 +3316,11 @@ mptscsih_taskmgmt_bh(void *sc)
 				/* The TM handler will allocate a new mf,
 				 * so free the current mf.
 				 */
-				mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
-				mf = NULL;
+				mpt_free_msg_frame(hd->ioc, mf);
 
-				if (mptscsih_TMHandler(hd, task_type, SCpnt->target, SCpnt->lun, ctx2abort, NO_SLEEP) < 0) {
+				if (mptscsih_TMHandler(hd, task_type, SCpnt->channel,
+						      SCpnt->target, SCpnt->lun,
+						       ctx2abort, CAN_SLEEP) < 0) {
 
 					/* The TM request failed and the subsequent FW-reload failed!
 					 * Fatal error case.
@@ -3670,13 +3328,21 @@ mptscsih_taskmgmt_bh(void *sc)
 					printk(KERN_WARNING MYNAM
 						": WARNING[1] - IOC error processing TaskMgmt request (sc=%p)\n", (void *) SCpnt);
 
-					if (hd->ScsiLookup[scpnt_idx] != NULL) {
-						atomic_dec(&queue_depth);
+					if ( (LookupSCpnt = hd->ScsiLookup[scpnt_idx]) == SCpnt) {
+						dtmprintk((MYIOC_s_WARN_FMT "LookupSCpnt=%p == SCpnt=%p for scpnt_idx=%x\n",
+							ioc->name, LookupSCpnt, SCpnt, scpnt_idx));
+						hd->ScsiLookup[scpnt_idx] = NULL;
 						SCpnt->result = DID_SOFT_ERROR << 16;
                                                 MPT_HOST_LOCK(flags);
+#ifdef MPT_DEBUG_QCMD_DEPTH
+						mptscsih_scsi_done(ioc,SCpnt);
+#else
 						SCpnt->scsi_done(SCpnt);
+#endif
                                                 MPT_HOST_UNLOCK(flags);
-						mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
+					} else {
+						dtmprintk((MYIOC_s_WARN_FMT "LookupSCpnt=%p != SCpnt=%p for scpnt_idx=%x\n",
+							ioc->name, LookupSCpnt, SCpnt, scpnt_idx));
 					}
 					spin_lock_irqsave(&ioc->FreeQlock, flags);
 					hd->tmPending = 0;
@@ -3717,11 +3383,12 @@ mptscsih_taskmgmt_complete(MPT_ADAPTER *
 {
 	SCSITaskMgmtReply_t	*pScsiTmReply;
 	SCSITaskMgmt_t		*pScsiTmReq;
-	MPT_SCSI_HOST		*hd = NULL;
+	MPT_SCSI_HOST		*hd;
 	unsigned long		 flags;
-	u8			 tmType = 0;
+	u16			 iocstatus;
+	u8			 tmType;
 
-	dtmprintk((MYIOC_s_INFO_FMT "SCSI TaskMgmt completed (mf=%p,r=%p)\n",
+	dtmprintk((MYIOC_s_WARN_FMT "TaskMgmt completed (mf=%p,r=%p)\n",
 			ioc->name, mf, mr));
 	if (ioc->sh) {
 		/* Depending on the thread, a timer is activated for
@@ -3732,7 +3399,7 @@ mptscsih_taskmgmt_complete(MPT_ADAPTER *
 		if (hd->tmPtr) {
 			del_timer(&hd->TMtimer);
 		}
-		dtmprintk((MYIOC_s_INFO_FMT "taskQcnt (%d)\n",
+		dtmprintk((MYIOC_s_WARN_FMT "taskQcnt (%d)\n",
 			ioc->name, hd->taskQcnt));
 	} else {
 		dtmprintk((MYIOC_s_WARN_FMT "TaskMgmt Complete: NULL Scsi Host Ptr\n",
@@ -3753,25 +3420,18 @@ mptscsih_taskmgmt_complete(MPT_ADAPTER *
 
 		dtmprintk((KERN_INFO "  TaskType = %d, TerminationCount=%d\n",
 				tmType, le32_to_cpu(pScsiTmReply->TerminationCount)));
+		DBG_DUMP_TM_REPLY_FRAME((u32 *)pScsiTmReply);
 
+		iocstatus = le16_to_cpu(pScsiTmReply->IOCStatus) & MPI_IOCSTATUS_MASK;
+		dtmprintk((MYIOC_s_WARN_FMT "  SCSI TaskMgmt (%d) IOCStatus=%04x IOCLogInfo=%08x\n", 
+			ioc->name, tmType, iocstatus, le32_to_cpu(pScsiTmReply->IOCLogInfo))); 
 		/* Error?  (anything non-zero?) */
-		if (*(u32 *)&pScsiTmReply->Reserved2[0]) {
-			u16	 iocstatus;
-
-			iocstatus = le16_to_cpu(pScsiTmReply->IOCStatus) & MPI_IOCSTATUS_MASK;
-			dtmprintk((KERN_INFO "  SCSI TaskMgmt (%d) - Oops!\n", tmType));
-			dtmprintk((KERN_INFO "  IOCStatus = %04xh\n", iocstatus));
-			dtmprintk((KERN_INFO "  IOCLogInfo = %08xh\n",
-				 le32_to_cpu(pScsiTmReply->IOCLogInfo)));
-
+		if (iocstatus) {
 			/* clear flags and continue.
 			 */
 			if (tmType == MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK)
 				hd->abortSCpnt = NULL;
-#ifdef	DROP_TEST
-			if (dropMfPtr)
-				dropTestBad++;
-#endif
+
 			/* If an internal command is present
 			 * or the TM failed - reload the FW.
 			 * FC FW may respond FAILED to an ABORT
@@ -3786,8 +3446,7 @@ mptscsih_taskmgmt_complete(MPT_ADAPTER *
 				}
 			}
 		} else {
-			dtmprintk((KERN_INFO "  SCSI TaskMgmt SUCCESS!\n"));
-
+			dtmprintk((MYIOC_s_WARN_FMT " TaskMgmt SUCCESS\n", ioc->name));
 #ifndef MPT_SCSI_USE_NEW_EH
 			if (tmType == MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS) {
 				/* clean taskQ - remove tasks associated with
@@ -3801,28 +3460,18 @@ mptscsih_taskmgmt_complete(MPT_ADAPTER *
 				search_taskQ_for_cmd(hd->abortSCpnt, hd);
 			}
 #endif
-			hd->numTMrequests--;
 			hd->abortSCpnt = NULL;
-			flush_doneQ(hd);
 
-#ifdef	DROP_TEST
-			if (dropMfPtr)
-				dropTestOK++;
-#endif
 		}
 	}
 
-#ifdef	DROP_TEST
-	mptscsih_flush_drop_test(hd);
-#endif
-
 #ifndef MPT_SCSI_USE_NEW_EH
 	/*
 	 *  Signal to _bh thread that we finished.
 	 *  This IOC can now process another TM command.
 	 */
-	dtmprintk((MYIOC_s_INFO_FMT "taskmgmt_complete: (=%p) done! Num Failed(%d) Task Count (%d)\n",
-			ioc->name, mf, hd->numTMrequests, hd->taskQcnt));
+	dtmprintk((MYIOC_s_WARN_FMT "taskmgmt_complete: (=%p) done! Task Count (%d)\n",
+			ioc->name, mf, hd->taskQcnt));
 #endif
 	hd->tmPtr = NULL;
 	spin_lock_irqsave(&ioc->FreeQlock, flags);
@@ -3840,19 +3489,9 @@ mptscsih_taskmgmt_complete(MPT_ADAPTER *
  *	This is anyones guess quite frankly.
  */
 int
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,45)
-mptscsih_bios_param(struct scsi_device * sdev, struct block_device *bdev,
-		sector_t capacity, int *ip)
-{
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,28)
-mptscsih_bios_param(Disk * disk, struct block_device *bdev, int *ip)
-{
-	sector_t capacity = disk->capacity;
-#else
 mptscsih_bios_param(Disk * disk, kdev_t dev, int *ip)
 {
 	unsigned capacity = disk->capacity;
-#endif
 	int size;
 
 	size = capacity;
@@ -3872,43 +3511,6 @@ mptscsih_bios_param(Disk * disk, kdev_t 
  *	Called once per device the bus scan. Use it to force the queue_depth
  *	member to 1 if a device does not support Q tags.
  */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,44)
-int
-mptscsih_slave_attach(Scsi_Device *device)
-{
-	struct Scsi_Host	*host = device->host;
-	VirtDevice		*pTarget;
-	MPT_SCSI_HOST		*hd;
-
-	hd = (MPT_SCSI_HOST *)host->hostdata;
-	if (hd && (hd->Targets != NULL)) {
-		pTarget = hd->Targets[device->id];
-		if (pTarget) {
-			if (!device->tagged_supported ||
-			    !(pTarget->tflags & MPT_TARGET_FLAGS_Q_YES)) {
-				scsi_adjust_queue_depth(device, 0, 1);
-
-			} else if ((pTarget->tflags & MPT_TARGET_FLAGS_VALID_INQUIRY)
-				   && (pTarget->inq_data[0] & 0x1f) == 0x00
-				   && (pTarget->minSyncFactor <= MPT_ULTRA160 || !hd->is_spi)) {
-				scsi_adjust_queue_depth(device, MSG_SIMPLE_TAG,
-							MPT_SCSI_CMD_PER_DEV_HIGH);
-			} else {
-				scsi_adjust_queue_depth(device, MSG_SIMPLE_TAG,
-							MPT_SCSI_CMD_PER_DEV_LOW);
-			}
-#if 0
-			/* Original Code for 2.5 */
-			} else {
-				scsi_adjust_queue_depth(device, MSG_SIMPLE_TAG,
-						device->host->can_queue >> 1);
-			}
-#endif
-		}
-	}
-	return 0;
-}
-#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,44) */
 void
 mptscsih_select_queue_depths(struct Scsi_Host *sh, Scsi_Device *sdList)
 {
@@ -3926,39 +3528,59 @@ mptscsih_select_queue_depths(struct Scsi
 			continue;
 
 		if (hd->Targets != NULL) {
-			pTarget = NULL;
 			if (device->id > sh->max_id) {
 				/* error case, should never happen */
 				device->queue_depth = 1;
+				dinitprintk((MYIOC_s_WARN_FMT
+					 "max_id=%d: scsi%d: Lun=%d: queue_depth=%d\n",
+					 hd->ioc->name, sh->max_id, device->id,  device->lun, device->queue_depth));
 				continue;
 			} else {
 				pTarget = hd->Targets[device->id];
 			}
 
-			if (pTarget == NULL) {
-				/* error case - don't know about this device */
-				device->queue_depth = 1;
-			} else if (pTarget->tflags & MPT_TARGET_FLAGS_VALID_INQUIRY) {
-				if (!(pTarget->tflags & MPT_TARGET_FLAGS_Q_YES))
-					device->queue_depth = 1;
-				else if (((pTarget->inq_data[0] & 0x1f) == 0x00)
-					 && (pTarget->minSyncFactor <= MPT_ULTRA160 || !hd->is_spi)){
-					device->queue_depth = MPT_SCSI_CMD_PER_DEV_HIGH;
-				} else
-					device->queue_depth = MPT_SCSI_CMD_PER_DEV_LOW;
-
+			if (pTarget) {
+				device->queue_depth = MPT_SCSI_CMD_PER_DEV_HIGH;
+				if ( hd->ioc->bus_type == SCSI ) {
+					if (pTarget->tflags & MPT_TARGET_FLAGS_VALID_INQUIRY) {
+						if (!(pTarget->tflags & MPT_TARGET_FLAGS_Q_YES)) {
+
+							device->queue_depth = 1;
+							dinitprintk((MYIOC_s_WARN_FMT
+					 			"no Q: scsi%d: Id=%d Lun=%d: queue_depth=%d tflags=%x\n",
+					 			hd->ioc->name, device->id, pTarget->target_id, device->lun, device->queue_depth, pTarget->tflags));
+						} else if (((pTarget->inq_data[0] & 0x1f) == 0x00) && (pTarget->minSyncFactor <= MPT_ULTRA160 )){
+							device->queue_depth = MPT_SCSI_CMD_PER_DEV_HIGH;
+						} else
+							device->queue_depth = MPT_SCSI_CMD_PER_DEV_LOW;
+					} else {
+						/* error case - No Inq. Data */
+						device->queue_depth = 1;
+						dinitprintk((MYIOC_s_WARN_FMT
+					 		"no Inq Data: scsi%d: Id=%d Lun=%d: queue_depth=%d tflags=%x\n",
+					 		hd->ioc->name, device->id, pTarget->target_id, device->lun, device->queue_depth, pTarget->tflags));
+					}
+				}
+				dinitprintk((MYIOC_s_WARN_FMT
+					 "scsi%d: Id=%d Lun=%d: queue_depth=%d sync factor=%x tflags=%x\n",
+					 hd->ioc->name, device->id, pTarget->target_id, device->lun, device->queue_depth, pTarget->minSyncFactor, pTarget->tflags));
 			} else {
-				/* error case - No Inq. Data */
-				device->queue_depth = 1;
+				/* Driver doesn't know about this device.
+				 * Kernel may generate a "Dummy Lun 0" which
+				 * may become a real Lun if a
+				 * "scsi add-single-device" command is executed
+				 * while the driver is active (hot-plug a
+				 * device).  LSI Raid controllers need
+				 * queue_depth set to DEV_HIGH for this reason.
+				 */
+				device->queue_depth = MPT_SCSI_CMD_PER_DEV_HIGH;
+				dinitprintk((MYIOC_s_WARN_FMT
+					 "No Driver Device: scsi%d: Lun=%d: queue_depth=%d\n",
+					 hd->ioc->name, device->id, device->lun, device->queue_depth));
 			}
-			dprintk((MYIOC_s_INFO_FMT
-				 "target = %d, sync factor = %x, queue depth = %d\n",
-				 hd->ioc->name, pTarget->target_id,
-				 pTarget->minSyncFactor, device->queue_depth));
 		}
 	}
 }
-#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,44) */
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -3977,16 +3599,12 @@ copy_sense_data(Scsi_Cmnd *sc, MPT_SCSI_
 	SCSIIORequest_t	*pReq;
 	u32		 sense_count = le32_to_cpu(pScsiReply->SenseCount);
 	int		 index;
-	char		 devFoo[96];
-	IO_Info_t	 thisIo;
 
 	/* Get target structure
 	 */
 	pReq = (SCSIIORequest_t *) mf;
 	index = (int) pReq->TargetID;
 	target = hd->Targets[index];
-	if (hd->is_multipath && sc->device->hostdata)
-		target = (VirtDevice *) sc->device->hostdata;
 
 	if (sense_count) {
 		u8 *sense_data;
@@ -3997,34 +3615,6 @@ copy_sense_data(Scsi_Cmnd *sc, MPT_SCSI_
 		sense_data = ((u8 *)hd->ioc->sense_buf_pool + (req_index * MPT_SENSE_BUFFER_ALLOC));
 		memcpy(sc->sense_buffer, sense_data, SNS_LEN(sc));
 
-		/* save sense data to the target device
-		 */
-		if (hd->is_spi && target) {
-#ifdef MPT_SAVE_AUTOSENSE
-			int sz;
-
-			sz = MIN(pReq->SenseBufferLength, sense_count);
-			if (sz > SCSI_STD_SENSE_BYTES)
-				sz =  SCSI_STD_SENSE_BYTES;
-			memcpy(target->sense, sense_data, sz);
-			target->tflags |= MPT_TARGET_FLAGS_VALID_SENSE;
-#endif
-
-#ifdef ABORT_FIX
-			if (sz >= SCSI_STD_SENSE_BYTES) {
-				if ((sense_data[02] == ABORTED_COMMAND) &&
-					(sense_data[12] == 0x47) && (sense_data[13] == 0x00)){
-					target->numAborts++;
-					if ((target->raidVolume == 0) && (target->numAborts > 5)) {
-						target->numAborts = 0;
-						target->minSyncFactor++;
-						hd->ioc->spi_data.dvStatus[index] |= MPT_SCSICFG_NEGOTIATE;
-					}
-				}
-			}
-#endif
-		}
-
 		/* Log SMART data (asc = 0x5D, non-IM case only) if required.
 		 */
 		if ((hd->ioc->events) && (hd->ioc->eventTypes & (1 << MPI_EVENT_SCSI_DEVICE_STATUS_CHANGE))) {
@@ -4045,36 +3635,11 @@ copy_sense_data(Scsi_Cmnd *sc, MPT_SCSI_
 				ioc->eventContext++;
 			}
 		}
-
-		/* Print an error report for the user.
-		 */
-		thisIo.cdbPtr = sc->cmnd;
-		thisIo.sensePtr = sc->sense_buffer;
-		thisIo.SCSIStatus = pScsiReply->SCSIStatus;
-		thisIo.DoDisplay = 1;
-		if (hd->is_multipath)
-			sprintf(devFoo, "%d:%d:%d \"%s\"",
-					hd->ioc->id,
-					pReq->TargetID,
-					pReq->LUN[1],
-					target->dev_vol_name);
-		else
-			sprintf(devFoo, "%d:%d:%d", hd->ioc->id, sc->target, sc->lun);
-		thisIo.DevIDStr = devFoo;
-/* fubar */
-		thisIo.dataPtr = NULL;
-		thisIo.inqPtr = NULL;
-		if (sc->device) {
-			thisIo.inqPtr = sc->device->vendor-8;	/* FIXME!!! */
-		}
-		(void) mpt_ScsiHost_ErrorReport(&thisIo);
-
 	} else {
-		dprintk((MYIOC_s_INFO_FMT "Hmmm... SenseData len=0! (?)\n",
+		dprintk((MYIOC_s_WARN_FMT "Hmmm... SenseData len=0! (?)\n",
 				hd->ioc->name));
 	}
 
-	return;
 }
 
 static u32
@@ -4112,13 +3677,12 @@ static MPT_FRAME_HDR *
 mptscsih_search_pendingQ(MPT_SCSI_HOST *hd, int scpnt_idx)
 {
 	unsigned long	 flags;
-	MPT_DONE_Q	*buffer;
+	MPT_REQUEST_Q	*buffer;
 	MPT_FRAME_HDR	*mf = NULL;
-	MPT_FRAME_HDR	*cmdMfPtr = NULL;
+	MPT_FRAME_HDR	*cmdMfPtr;
 
-	ddvtprintk((MYIOC_s_INFO_FMT ": search_pendingQ ...", hd->ioc->name));
 	cmdMfPtr = MPT_INDEX_2_MFPTR(hd->ioc, scpnt_idx);
-	spin_lock_irqsave(&hd->freedoneQlock, flags);
+	spin_lock_irqsave(&hd->freeQlock, flags);
 	if (!Q_IS_EMPTY(&hd->pendingQ)) {
 		buffer = hd->pendingQ.head;
 		do {
@@ -4132,14 +3696,14 @@ mptscsih_search_pendingQ(MPT_SCSI_HOST *
 
 				/* Add to the freeQ
 				 */
-				Q_ADD_TAIL(&hd->freeQ.head, buffer, MPT_DONE_Q);
+				Q_ADD_TAIL(&hd->freeQ.head, buffer, MPT_REQUEST_Q);
 				break;
 			}
 			mf = NULL;
-		} while ((buffer = buffer->forw) != (MPT_DONE_Q *) &hd->pendingQ);
+		} while ((buffer = buffer->forw) != (MPT_REQUEST_Q *) &hd->pendingQ);
 	}
-	spin_unlock_irqrestore(&hd->freedoneQlock, flags);
-	ddvtprintk((" ...return %p\n", mf));
+	spin_unlock_irqrestore(&hd->freeQlock, flags);
+	dpendprintk((MYIOC_s_WARN_FMT ": search_pendingQ mf=%x", hd->ioc->name, mf));
 	return mf;
 }
 
@@ -4150,17 +3714,20 @@ mptscsih_search_pendingQ(MPT_SCSI_HOST *
 static void
 post_pendingQ_commands(MPT_SCSI_HOST *hd)
 {
+	MPT_ADAPTER *ioc = hd->ioc;
 	MPT_FRAME_HDR	*mf;
-	MPT_DONE_Q	*buffer;
+	Scsi_Cmnd	*sc;
+	MPT_REQUEST_Q	*buffer;
+	u16		 req_idx;
 	unsigned long	 flags;
 
 	/* Flush the pendingQ.
 	 */
-	ddvtprintk((MYIOC_s_INFO_FMT ": post_pendingQ_commands\n", hd->ioc->name));
+	dpendprintk((MYIOC_s_WARN_FMT "post_pendingQ_commands\n", ioc->name));
 	while (1) {
-		spin_lock_irqsave(&hd->freedoneQlock, flags);
+		spin_lock_irqsave(&hd->freeQlock, flags);
 		if (Q_IS_EMPTY(&hd->pendingQ)) {
-			spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+			spin_unlock_irqrestore(&hd->freeQlock, flags);
 			break;
 		}
 
@@ -4174,25 +3741,19 @@ post_pendingQ_commands(MPT_SCSI_HOST *hd
 
 		/* Add to the freeQ
 		 */
-		Q_ADD_TAIL(&hd->freeQ.head, buffer, MPT_DONE_Q);
-		spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+		Q_ADD_TAIL(&hd->freeQ.head, buffer, MPT_REQUEST_Q);
 
-		if (!mf) {
-			/* This should never happen */
-			printk(MYIOC_s_WARN_FMT "post_pendingQ_commands: mf %p\n", hd->ioc->name, (void *) mf);
-			continue;
-		}
+		req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
+		sc = hd->PendingScsi[req_idx];
+		hd->ScsiLookup[req_idx] = sc;
+		hd->PendingScsi[req_idx] = NULL;
+		sc->host_scribble = NULL;
+		spin_unlock_irqrestore(&hd->freeQlock, flags);
 
-		mptscsih_put_msgframe(ScsiDoneCtx, hd->ioc->id, mf);
+		dpendprintk((MYIOC_s_WARN_FMT "post_pendingQ_commands: mf=%p sc=%p\n", 
+			ioc->name, mf, sc));
 
-#if defined(MPT_DEBUG_DV) || defined(MPT_DEBUG_DV_TINY)
-		{
-			u16		 req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
-			Scsi_Cmnd	*sc = hd->ScsiLookup[req_idx];
-			printk(MYIOC_s_INFO_FMT "Issued SCSI cmd (sc=%p) idx=%d (mf=%p)\n",
-					hd->ioc->name, sc, req_idx, mf);
-		}
-#endif
+		mpt_put_msg_frame(ScsiDoneCtx, ioc, mf);
 	}
 
 	return;
@@ -4202,12 +3763,15 @@ post_pendingQ_commands(MPT_SCSI_HOST *hd
 static int
 mptscsih_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)
 {
-	MPT_SCSI_HOST	*hd = NULL;
+	MPT_SCSI_HOST	*hd;
 	unsigned long	 flags;
+	int		 ii;
+	int		 n;
 
-	dtmprintk((KERN_WARNING MYNAM
+	drsprintk((KERN_INFO MYNAM
 			": IOC %s_reset routed to SCSI host driver!\n",
-			reset_phase==MPT_IOC_PRE_RESET ? "pre" : "post"));
+			reset_phase==MPT_IOC_SETUP_RESET ? "setup" : (
+			reset_phase==MPT_IOC_PRE_RESET ? "pre" : "post")));
 
 	/* If a FW reload request arrives after base installed but
 	 * before all scsi hosts have been attached, then an alt_ioc
@@ -4218,28 +3782,25 @@ mptscsih_ioc_reset(MPT_ADAPTER *ioc, int
 	else
 		hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
 
-	if (reset_phase == MPT_IOC_PRE_RESET) {
-		dtmprintk((MYIOC_s_WARN_FMT "Do Pre-Diag Reset handling\n",
-			ioc->name));
-
+	if (reset_phase == MPT_IOC_SETUP_RESET) {
+		drsprintk((MYIOC_s_WARN_FMT "Setup-Diag Reset\n", ioc->name));
 		/* Clean Up:
 		 * 1. Set Hard Reset Pending Flag
-		 * All new commands go to doneQ
 		 */
 		hd->resetPending = 1;
 
+		/* 2. Reset timeouts on all running commands
+		 */
+		mptscsih_reset_timeouts (hd);
+
+	} else if (reset_phase == MPT_IOC_PRE_RESET) {
+		drsprintk((MYIOC_s_WARN_FMT "Pre-Diag Reset\n", ioc->name));
+
 		/* 2. Flush running commands
-		 *	Clean drop test code - if compiled
 		 *	Clean ScsiLookup (and associated memory)
 		 *	AND clean mytaskQ
 		 */
 
-		/* 2a. Drop Test Command.
-		 */
-#ifdef	DROP_TEST
-		mptscsih_flush_drop_test(hd);
-#endif
-
 		/* 2b. Reply to OS all known outstanding I/O commands.
 		 */
 		mptscsih_flush_running_cmds(hd);
@@ -4250,8 +3811,7 @@ mptscsih_ioc_reset(MPT_ADAPTER *ioc, int
 		 */
 		if (hd->cmdPtr) {
 			del_timer(&hd->timer);
-			mpt_free_msg_frame(ScsiScanDvCtx, ioc->id, hd->cmdPtr);
-			atomic_dec(&queue_depth);
+			mpt_free_msg_frame(ioc, hd->cmdPtr);
 		}
 
 		/* 2d. If a task management has not completed,
@@ -4259,7 +3819,7 @@ mptscsih_ioc_reset(MPT_ADAPTER *ioc, int
 		 */
 		if (hd->tmPtr) {
 			del_timer(&hd->TMtimer);
-			mpt_free_msg_frame(ScsiTaskCtx, ioc->id, hd->tmPtr);
+			mpt_free_msg_frame(ioc, hd->tmPtr);
 		}
 
 #ifndef MPT_SCSI_USE_NEW_EH
@@ -4269,55 +3829,65 @@ mptscsih_ioc_reset(MPT_ADAPTER *ioc, int
 		 */
 		clean_taskQ(hd);
 #endif
-		dtmprintk((MYIOC_s_WARN_FMT "Pre-Reset handling complete.\n",
-			ioc->name));
 
+		drsprintk((MYIOC_s_WARN_FMT "Pre-Reset complete.\n", ioc->name));
 	} else {
-		ScsiCfgData	*pSpi = NULL;
+		drsprintk((MYIOC_s_WARN_FMT "Post-Diag Reset\n", ioc->name));
 
-		dtmprintk((MYIOC_s_WARN_FMT "Do Post-Diag Reset handling\n",
-			ioc->name));
+		if (ioc->bus_type == FC) {
+			n = 0;
+			for (ii=0; ii < ioc->sh->max_id; ii++) {
+				if (hd->Targets && hd->Targets[ii]) {
+					drsprintk((MYIOC_s_INFO_FMT
+						"target %d is known to be WWPN %08x%08x, WWNN %08x%08x\n",
+						ioc->name, ii,
+						le32_to_cpu(hd->Targets[ii]->WWPN.High),
+						le32_to_cpu(hd->Targets[ii]->WWPN.Low),
+						le32_to_cpu(hd->Targets[ii]->WWNN.High),
+						le32_to_cpu(hd->Targets[ii]->WWNN.Low)));
+					mptscsih_writeFCPortPage3(hd, ii);
+					n++;
+				}
+			}
 
-		/* Once a FW reload begins, all new OS commands are
-		 * redirected to the doneQ w/ a reset status.
-		 * Init all control structures.
-		 */
+			if (n) {
+				mptscsih_sendIOCInit(hd);
+			}
+		}
 
-		/* ScsiLookup initialization
+		 /* Init all control structures.
 		 */
-		{
-			int ii;
-			for (ii=0; ii < hd->ioc->req_depth; ii++)
-				hd->ScsiLookup[ii] = NULL;
-		}
 
-		/* 2. Chain Buffer initialization
+		/* ScsiLookup initialization
 		 */
-		mptscsih_initChainBuffers(hd, 0);
+		for (ii=0; ii < hd->ioc->req_depth; ii++)
+			hd->ScsiLookup[ii] = NULL;
 
-		/* 3. tmPtr clear
+		/* 2. tmPtr clear
 		 */
 		if (hd->tmPtr) {
 			hd->tmPtr = NULL;
 		}
 
-		/* 4. Renegotiate to all devices, if SCSI
+		/* 3. Renegotiate to all devices, if SCSI
 		 */
-		if (hd->is_spi)
+
+		if (ioc->bus_type == SCSI) {
+			dnegoprintk(("writeSDP1: ALL_IDS USE_NVRAM\n"));
 			mptscsih_writeSDP1(hd, 0, 0, MPT_SCSICFG_ALL_IDS | MPT_SCSICFG_USE_NVRAM);
+		}
 
-		/* 5. Enable new commands to be posted
+		/* 4. Enable new commands to be posted
 		 */
 		spin_lock_irqsave(&ioc->FreeQlock, flags);
 		hd->tmPending = 0;
 		spin_unlock_irqrestore(&ioc->FreeQlock, flags);
 		hd->resetPending = 0;
-		hd->numTMrequests = 0;
 #ifdef MPT_SCSI_USE_NEW_EH
 		hd->tmState = TM_STATE_NONE;
 #endif
 
-		/* 6. If there was an internal command,
+		/* 5. If there was an internal command,
 		 * wake this process up.
 		 */
 		if (hd->cmdPtr) {
@@ -4331,33 +3901,44 @@ mptscsih_ioc_reset(MPT_ADAPTER *ioc, int
 			hd->cmdPtr = NULL;
 		}
 
-		/* 7. Flush doneQ
+		/* 6. Set flag to force DV and re-read IOC Page 3
 		 */
-		flush_doneQ(hd);
-
-		dtmprintk((MYIOC_s_WARN_FMT "Post-Reset handling complete.\n",
-			ioc->name));
-
+		if (ioc->bus_type == SCSI) {
+			ioc->spi_data.forceDv = MPT_SCSICFG_NEED_DV |
+			    MPT_SCSICFG_RELOAD_IOC_PG3;
+			drsprintk(("Set reload IOC Pg3 Flag\n"));
+		}
 
-		/* 8. Set then flag to force DV and re-read IOC Page 3
-		 */
-		pSpi = &ioc->spi_data;
-		pSpi->forceDv = MPT_SCSICFG_NEED_DV | MPT_SCSICFG_RELOAD_IOC_PG3;
-		ddvtprintk(("Set reload IOC Pg3 Flag\n"));
+		post_pendingQ_commands(hd);
 
+		drsprintk((MYIOC_s_WARN_FMT "Post-Reset complete.\n", ioc->name));
 	}
 
 	return 1;		/* currently means nothing really */
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+static void
+mptscsih_sas_persist_clear_table(void * arg)
+{
+	MPT_ADAPTER *ioc = (MPT_ADAPTER *)arg;
+	/* clear persistency table of all mappings
+	 * for devices which are not present
+	 */
+	mptbase_sas_persist_operation(ioc, MPI_SAS_OP_CLEAR_NOT_PRESENT);
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 static int
 mptscsih_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply)
 {
 	MPT_SCSI_HOST *hd;
 	u8 event = le32_to_cpu(pEvReply->Event) & 0xFF;
+	MpiEventDataSasDeviceStatusChange_t * pSasDeviceData;
+	VirtDevice		*pTarget;
+	int	 target;
 
-	dprintk((MYIOC_s_INFO_FMT "MPT event (=%02Xh) routed to SCSI host driver!\n",
+	devtprintk((MYIOC_s_WARN_FMT "MPT event (=%02Xh) routed to SCSI host driver!\n",
 			ioc->name, event));
 
 	switch (event) {
@@ -4369,7 +3950,7 @@ mptscsih_event_process(MPT_ADAPTER *ioc,
 		hd = NULL;
 		if (ioc->sh) {
 			hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
-			if (hd && (hd->is_spi) && (hd->soft_resets < -1))
+			if (hd && (ioc->bus_type == SCSI) && (hd->soft_resets < -1))
 				hd->soft_resets++;
 		}
 		break;
@@ -4390,7 +3971,7 @@ mptscsih_event_process(MPT_ADAPTER *ioc,
 		break;
 
 	case MPI_EVENT_INTEGRATED_RAID:			/* 0B */
-#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+#ifdef MPTSCSIH_ENABLE_DOMAIN_VALIDATION
 		/* negoNvram set to 0 if DV enabled and to USE_NVRAM if
 		 * if DV disabled. Need to check for target mode.
 		 */
@@ -4398,13 +3979,13 @@ mptscsih_event_process(MPT_ADAPTER *ioc,
 		if (ioc->sh)
 			hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
 
-		if (hd && (hd->is_spi) && (hd->negoNvram == 0)) {
+		if (hd && (ioc->bus_type == SCSI) && (hd->negoNvram == 0)) {
 			ScsiCfgData	*pSpi;
 			Ioc3PhysDisk_t	*pPDisk;
 			int		 numPDisk;
 			u8		 reason;
 			u8		 physDiskNum;
-			
+
 			reason = (le32_to_cpu(pEvReply->Data[0]) & 0x00FF0000) >> 16;
 			if (reason == MPI_EVENT_RAID_RC_DOMAIN_VAL_NEEDED) {
 				/* New or replaced disk.
@@ -4455,6 +4036,78 @@ mptscsih_event_process(MPT_ADAPTER *ioc,
 #endif
 		break;
 
+	case MPI_EVENT_SAS_DEVICE_STATUS_CHANGE:  /* 0F */
+		pSasDeviceData =
+		    (MpiEventDataSasDeviceStatusChange_t *) pEvReply->Data;
+		hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
+		target = pSasDeviceData->TargetID;
+
+		if (pSasDeviceData->ReasonCode ==
+			MPI_EVENT_SAS_DEV_STAT_RC_ADDED) {
+			/* Add device */
+			mptscsih_initTarget(hd,
+				pSasDeviceData->Bus,
+				target,
+				0,
+				NULL,
+				0);
+			pTarget = hd->Targets[target];
+			dinitprintk((KERN_INFO "Target  (id %d) @ %p Added due to EVENT_SAS_DEV_STAT_RC_ADDED\n",
+					target, pTarget));
+			printk(MYIOC_s_WARN_FMT "Target=%d Bus=%d added event\n",
+				ioc->name,target,
+				pSasDeviceData->Bus);
+		}
+
+		else if (pSasDeviceData->ReasonCode ==
+			 MPI_EVENT_SAS_DEV_STAT_RC_NOT_RESPONDING) {
+
+			/* Remove device */
+			pTarget = hd->Targets[target];
+			if ( pTarget ) {
+				dinitprintk((KERN_INFO "Target  (id %d) @ %p Removed due to EVENT_SAS_DEV_STAT_RC_NOT_RESPONDING\n",
+					target, pTarget));
+				hd->Targets[target] = NULL;
+			}
+
+			printk(MYIOC_s_WARN_FMT "Target=%d Bus=%d not responding event\n",
+				ioc->name, target,
+				pSasDeviceData->Bus);
+		}
+
+		/* Log SMART data */
+		else if ((pSasDeviceData->ReasonCode ==
+			MPI_EVENT_SAS_DEV_STAT_RC_SMART_DATA) &&
+			 ((ioc->events) &&
+			 (ioc->eventTypes &
+			  (1 << MPI_EVENT_SAS_DEVICE_STATUS_CHANGE)))) {
+			int idx;
+
+			idx = ioc->eventContext % ioc->eventLogSize;
+			ioc->events[idx].event =
+			    MPI_EVENT_SAS_DEVICE_STATUS_CHANGE;
+			ioc->events[idx].eventContext =
+			    pEvReply->EventContext;
+			ioc->events[idx].data[0] =
+			    (MPI_EVENT_SAS_DEV_STAT_RC_SMART_DATA << 16) ||
+			    (pSasDeviceData->Bus << 8) ||
+			    pSasDeviceData->TargetID;
+			ioc->events[idx].data[1] =
+			    (pSasDeviceData->ASCQ << 8) || pSasDeviceData->ASC;
+			ioc->eventContext++;
+		}
+
+		/* Persistent table is full. */
+		else if (pSasDeviceData->ReasonCode ==
+		    MPI_EVENT_SAS_DEV_STAT_RC_NO_PERSIST_ADDED) {
+
+			MPT_INIT_WORK(&mptscsih_persistTask,
+			    mptscsih_sas_persist_clear_table,(void *)ioc);
+			SCHEDULE_TASK(&mptscsih_persistTask);
+		}
+
+		break;
+
 	case MPI_EVENT_NONE:				/* 00 */
 	case MPI_EVENT_LOG_DATA:			/* 01 */
 	case MPI_EVENT_STATE_CHANGE:			/* 02 */
@@ -4475,9 +4128,9 @@ mptscsih_event_process(MPT_ADAPTER *ioc,
  *	drivers/message/fusion/scsiherr.c
  */
 
-//extern const char	**mpt_ScsiOpcodesPtr;	/* needed by mptscsih.c */
-//extern ASCQ_Table_t	 *mpt_ASCQ_TablePtr;
-//extern int		  mpt_ASCQ_TableSz;
+extern const char	**mpt_ScsiOpcodesPtr;	/* needed by mptscsih.c */
+extern ASCQ_Table_t	 *mpt_ASCQ_TablePtr;
+extern int		  mpt_ASCQ_TableSz;
 
 #define MYNAM	"mptscsih"
 
@@ -4800,7 +4453,7 @@ static const char * ascq_set_strings_4ma
 	/*
 	 * Need to check ASC here; if it is "special," then
 	 * the ASCQ is variable, and indicates failed component number.
-	 * We must treat the ASCQ as a "dont care" while searching the
+	 * We must treat the ASCQ as a "don't care" while searching the
 	 * mptscsih_ASCQ_Table[] by masking it off, and then restoring it later
 	 * on when we actually need to identify the failed component.
 	 */
@@ -4965,6 +4618,7 @@ int mpt_ScsiHost_ErrorReport(IO_Info_t *
 	return l;
 }
 
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -4983,84 +4637,137 @@ int mpt_ScsiHost_ErrorReport(IO_Info_t *
  *	Allocate and initialize memory for this target.
  *	Save inquiry data.
  *
- *	Returns pointer to VirtDevice structure.
  */
-static VirtDevice *
+static void
 mptscsih_initTarget(MPT_SCSI_HOST *hd, int bus_id, int target_id, u8 lun, char *data, int dlen)
 {
+	int		indexed_lun, lun_index;
 	VirtDevice	*vdev;
-	int		 sz;
+	ScsiCfgData	*pSpi;
+	char		data_56;
 
-	dprintk((MYIOC_s_INFO_FMT "initTarget (%d,%d,%d) called, hd=%p\n",
+	dinitprintk((MYIOC_s_WARN_FMT "initTarget bus=%d id=%d lun=%d hd=%p\n",
 			hd->ioc->name, bus_id, target_id, lun, hd));
 
+	/*
+	 * If the peripheral qualifier filter is enabled and the target 
+	 * reports a Peripheral Qualifier (upper 3 bits of byte 0) of 0x1
+	 * (Target is capable of supporting the specified peripheral 
+	 * device type on this logical unit; however, the physical device is 
+	 * not currently connected to this logical unit), the Peripherial 
+	 * Qualifier will be forced to 0x3 (Target is not capable of 
+	 * supporting a physical device on this logical unit).  This is to 
+	 * work around a bug in the mid-layer in some distributions in which 
+	 * the mid-layer will continue to try to communicate to the LUN and 
+	 * eventually create a dummy LUN.
+	 */
+	if (mpt_pq_filter && dlen && (data[0] & 0x20))
+		data[0] |= 0x40;
+
+	/* Is LUN supported? If so, upper 2 bits will be 0
+	* in first byte of inquiry data.
+	*/
+	if (dlen && (data[0] & 0xe0))
+		return;
+
 	if ((vdev = hd->Targets[target_id]) == NULL) {
 		if ((vdev = kmalloc(sizeof(VirtDevice), GFP_ATOMIC)) == NULL) {
 			printk(MYIOC_s_ERR_FMT "initTarget kmalloc(%d) FAILED!\n",
 					hd->ioc->name, (int)sizeof(VirtDevice));
+			return;
+		}
+		memset(vdev, 0, sizeof(VirtDevice));
+		vdev->tflags = MPT_TARGET_FLAGS_Q_YES;
+		vdev->ioc_id = hd->ioc->id;
+		vdev->target_id = target_id;
+		vdev->bus_id = bus_id;
+		vdev->last_lun = MPT_LAST_LUN;
+		vdev->raidVolume = 0;
+		hd->Targets[target_id] = vdev;
+		if (hd->ioc->bus_type == SCSI) {
+			if (hd->ioc->spi_data.isRaid & (1 << target_id)) {
+				vdev->raidVolume = 1;
+				ddvtprintk((KERN_INFO "RAID Volume @ id %d\n", target_id));
+			}
+			if ( (data[0] == SCSI_TYPE_PROC) && (hd->ioc->spi_data.Saf_Te) ) {
+		       		/* Treat all Processors as SAF-TE if
+			 	 * command line option is set */
+				vdev->tflags |= MPT_TARGET_FLAGS_SAF_TE_ISSUED;
+				mptscsih_writeIOCPage4(hd, target_id, bus_id);
+			}
+		} else if (hd->ioc->bus_type == FC) {
+			mptscsih_readFCDevicePage0(hd, target_id);
 		} else {
-			memset(vdev, 0, sizeof(VirtDevice));
-			rwlock_init(&vdev->VdevLock);
-			Q_INIT(&vdev->WaitQ, void);
-			Q_INIT(&vdev->SentQ, void);
-			Q_INIT(&vdev->DoneQ, void);
-			vdev->tflags = 0;
-			vdev->ioc_id = hd->ioc->id;
-			vdev->target_id = target_id;
-			vdev->bus_id = bus_id;
-
-			hd->Targets[target_id] = vdev;
-			dprintk((KERN_INFO "  *NEW* Target structure (id %d) @ %p\n",
-					target_id, vdev));
+			vdev->tflags |= MPT_TARGET_FLAGS_VALID_INQUIRY;
 		}
-	}
 
-	vdev->raidVolume = 0;
-	if (vdev && hd->is_spi) {
-		if (hd->ioc->spi_data.isRaid & (1 << target_id)) {
-			vdev->raidVolume = 1;
-			ddvtprintk((KERN_INFO "RAID Volume @ id %d\n", target_id));
-		}
+		dinitprintk((KERN_INFO "  *NEW* Target structure (id %d) @ %p\n",
+			target_id, vdev));
 	}
 
-	if (vdev && data) {
-		if ((!(vdev->tflags & MPT_TARGET_FLAGS_VALID_INQUIRY)) ||
-		((dlen > 56) && (!(vdev->tflags & MPT_TARGET_FLAGS_VALID_56)))) {
-
-			/* Copy the inquiry data  - if we haven't yet.
-			*/
-			sz = MIN(dlen, SCSI_STD_INQUIRY_BYTES);
-
-			memcpy (vdev->inq_data, data, sz);
-			vdev->tflags |= MPT_TARGET_FLAGS_VALID_INQUIRY;
-
-			/* Update the target capabilities
-			 */
-			if (dlen > 56) {
-				mptscsih_setTargetNegoParms(hd, vdev, data[56]);
-				vdev->tflags |= MPT_TARGET_FLAGS_VALID_56;
-			} else
-				mptscsih_setTargetNegoParms(hd, vdev, 0);
+	lun_index = (lun >> 5);  /* 32 luns per lun_index */
+	indexed_lun = (lun % 32);
+	vdev->luns[lun_index] |= (1 << indexed_lun);
+
+	if (hd->ioc->bus_type == SCSI) {
+		if ( (data[0] == SCSI_TYPE_PROC) &&
+			!(vdev->tflags & MPT_TARGET_FLAGS_SAF_TE_ISSUED )) {
+			if ( dlen > 49 ) {
+				vdev->tflags |= MPT_TARGET_FLAGS_VALID_INQUIRY;
+				if ( data[44] == 'S' &&
+				     data[45] == 'A' &&
+				     data[46] == 'F' &&
+				     data[47] == '-' &&
+				     data[48] == 'T' &&
+				     data[49] == 'E' ) {
+					vdev->tflags |= MPT_TARGET_FLAGS_SAF_TE_ISSUED;
+					mptscsih_writeIOCPage4(hd, target_id, bus_id);
+				}
+			}
+		}
+		if (!(vdev->tflags & MPT_TARGET_FLAGS_VALID_INQUIRY)) {
+			if ( dlen > 8 ) {
+				memcpy (vdev->inq_data, data, 8);
+			} else {
+				memcpy (vdev->inq_data, data, dlen);
+			}
 
-			/* If LUN 0, tape and have not done DV, set the DV flag.
+			/* If have not done DV, set the DV flag.
 			 */
-			if (hd->is_spi && (lun == 0) && ((data[0] & 0x1F) == 0x01)) {
-				ScsiCfgData *pSpi = &hd->ioc->spi_data;
+			pSpi = &hd->ioc->spi_data;
+			if ((data[0] == SCSI_TYPE_TAPE) || (data[0] == SCSI_TYPE_PROC)) {
 				if (pSpi->dvStatus[target_id] & MPT_SCSICFG_DV_NOT_DONE)
 					pSpi->dvStatus[target_id] |= MPT_SCSICFG_NEED_DV;
 			}
-		}
 
-		/* Is LUN supported? If so, upper 3 bits will be 0
-		 * in first byte of inquiry data.
-		 */
-		if ((*data & 0xe0) == 0)
-			vdev->luns |= (1 << lun);
-	}
+			vdev->tflags |= MPT_TARGET_FLAGS_VALID_INQUIRY;
 
 
-	dprintk((KERN_INFO "  target = %p\n", vdev));
-	return vdev;
+			data_56 = 0x0F;  /* Default to full capabilities if Inq data length is < 57 */
+			if (dlen > 56) {
+				if ( (!(vdev->tflags & MPT_TARGET_FLAGS_VALID_56))) {
+				/* Update the target capabilities
+				 */
+					data_56 = data[56];
+					vdev->tflags |= MPT_TARGET_FLAGS_VALID_56;
+				}
+			}
+			mptscsih_setTargetNegoParms(hd, vdev, data_56);
+		} else {
+			/* Initial Inquiry may not request enough data bytes to
+			 * obtain byte 57.  DV will; if target doesn't return 
+			 * at least 57 bytes, data[56] will be zero. */
+			if (dlen > 56) {
+				if ( (!(vdev->tflags & MPT_TARGET_FLAGS_VALID_56))) {
+				/* Update the target capabilities
+				 */
+					data_56 = data[56];
+					vdev->tflags |= MPT_TARGET_FLAGS_VALID_56;
+					mptscsih_setTargetNegoParms(hd, vdev, data_56);
+				}
+			}
+		}
+	}
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -5069,172 +4776,176 @@ mptscsih_initTarget(MPT_SCSI_HOST *hd, i
  *  the Inquiry data, adapter capabilities, and NVRAM settings.
  *
  */
-void mptscsih_setTargetNegoParms(MPT_SCSI_HOST *hd, VirtDevice *target, char byte56)
+static void 
+mptscsih_setTargetNegoParms(MPT_SCSI_HOST *hd, VirtDevice *target, char byte56)
 {
 	ScsiCfgData *pspi_data = &hd->ioc->spi_data;
 	int  id = (int) target->target_id;
 	int  nvram;
-	char canQ = 0;
+	VirtDevice	*vdev;
+	int ii;
 	u8 width = MPT_NARROW;
 	u8 factor = MPT_ASYNC;
 	u8 offset = 0;
 	u8 version, nfactor;
 	u8 noQas = 1;
 
-	ddvtprintk((KERN_INFO "set Target: (id %d) byte56 0x%x\n", id, byte56));
+	target->negoFlags = pspi_data->noQas;
+
+	/* noQas == 0 => device supports QAS. Need byte 56 of Inq to determine
+	 * support. If available, default QAS to off and allow enabling.
+	 * If not available, default QAS to on, turn off for non-disks.
+	 */
 
-	if (!hd->is_spi) {
-		if (target->tflags & MPT_TARGET_FLAGS_VALID_INQUIRY) {
-			if (target->inq_data[7] & 0x02)
-				target->tflags |= MPT_TARGET_FLAGS_Q_YES;
-		}
-		return;
-	}
 	/* Set flags based on Inquiry data
 	 */
-	if (target->tflags & MPT_TARGET_FLAGS_VALID_INQUIRY) {
-		version = target->inq_data[2] & 0x07;
-		if (version < 2) {
-			width = 0;
-			factor = MPT_ULTRA2;
-			offset = pspi_data->maxSyncOffset;
-		} else {
-			if (target->inq_data[7] & 0x20) {
-				width = 1;
-			}
+	version = target->inq_data[2] & 0x07;
+	if (version < 2) {
+		width = 0;
+		factor = MPT_ULTRA2;
+		offset = pspi_data->maxSyncOffset;
+		target->tflags &= ~MPT_TARGET_FLAGS_Q_YES;
+	} else {
+		if (target->inq_data[7] & 0x20) {
+			width = 1;
+		}
 
-			if (target->inq_data[7] & 0x10) {
-				/* bits 2 & 3 show DT support
-				 */
-				if ((byte56 & 0x04) == 0)
+		if (target->inq_data[7] & 0x10) {
+			factor = pspi_data->minSyncFactor;
+			if (target->tflags & MPT_TARGET_FLAGS_VALID_56) {
+				/* bits 2 & 3 show Clocking support */
+				if ((byte56 & 0x0C) == 0)
 					factor = MPT_ULTRA2;
-				else if ((byte56 & 0x03) == 0)
-					factor = MPT_ULTRA160;
-				else
-					factor = MPT_ULTRA320;
-
-				/* If RAID, never disable QAS
-				 * else if non RAID, do not disable
-				 *   QAS if bit 1 is set
-				 * bit 1 QAS support, non-raid only
-				 * bit 0 IU support
-				 */
-				if ((target->raidVolume == 1) || ((byte56 & 0x02) != 0))
-					noQas = 0;
-
-				offset = pspi_data->maxSyncOffset;
+				else {
+					if ((byte56 & 0x03) == 0)
+						factor = MPT_ULTRA160;
+					else {
+						factor = MPT_ULTRA320;
+						if (byte56 & 0x02)
+						{
+							ddvtprintk((KERN_INFO "Enabling QAS due to byte56=%02x on id=%d!\n", byte56, id));
+							noQas = 0;
+						}
+						if (target->inq_data[0] == SCSI_TYPE_TAPE) {
+							if (byte56 & 0x01)
+								target->negoFlags |= MPT_TAPE_NEGO_IDP;
+						}
+					}
+				}
 			} else {
-				factor = MPT_ASYNC;
-				offset = 0;
+				ddvtprintk((KERN_INFO "Enabling QAS on id=%d due to ~TARGET_FLAGS_VALID_56!\n", id));
+				noQas = 0;
 			}
-		}
+				
+			offset = pspi_data->maxSyncOffset;
 
-		if (target->inq_data[7] & 0x02) {
-			canQ = 1;
+			/* If RAID, never disable QAS
+			 * else if non RAID, do not disable
+			 *   QAS if bit 1 is set
+			 * bit 1 QAS support, non-raid only
+			 * bit 0 IU support
+			 */
+			if (target->raidVolume == 1) {
+				noQas = 0;
+			}
+		} else {
+			factor = MPT_ASYNC;
+			offset = 0;
 		}
+	}
 
-		/* Update tflags based on NVRAM settings. (SCSI only)
-		 */
-		if (pspi_data->nvram && (pspi_data->nvram[id] != MPT_HOST_NVRAM_INVALID)) {
-			nvram = pspi_data->nvram[id];
-			nfactor = (nvram & MPT_NVRAM_SYNC_MASK) >> 8;
+	if ( (target->inq_data[7] & 0x02) == 0) {
+		target->tflags &= ~MPT_TARGET_FLAGS_Q_YES;
+	}
 
-			if (width)
-				width = nvram & MPT_NVRAM_WIDE_DISABLE ? 0 : 1;
+	/* Update tflags based on NVRAM settings. (SCSI only)
+	 */
+	if (pspi_data->nvram && (pspi_data->nvram[id] != MPT_HOST_NVRAM_INVALID)) {
+		nvram = pspi_data->nvram[id];
+		nfactor = (nvram & MPT_NVRAM_SYNC_MASK) >> 8;
 
-			if (offset > 0) {
-				/* Ensure factor is set to the
-				 * maximum of: adapter, nvram, inquiry
-				 */
-				if (nfactor) {
-					if (nfactor < pspi_data->minSyncFactor )
-						nfactor = pspi_data->minSyncFactor;
+		if (width)
+			width = nvram & MPT_NVRAM_WIDE_DISABLE ? 0 : 1;
 
-					factor = MAX (factor, nfactor);
-					if (factor == MPT_ASYNC)
-						offset = 0;
-				} else {
+		if (offset > 0) {
+			/* Ensure factor is set to the
+			 * maximum of: adapter, nvram, inquiry
+			 */
+			if (nfactor) {
+				if (nfactor < pspi_data->minSyncFactor )
+					nfactor = pspi_data->minSyncFactor;
+
+				factor = max(factor, nfactor);
+				if (factor == MPT_ASYNC)
 					offset = 0;
-					factor = MPT_ASYNC;
-				}
 			} else {
+				offset = 0;
 				factor = MPT_ASYNC;
-			}
 		}
-
-		/* Make sure data is consistent
-		 */
-		if ((!width) && (factor < MPT_ULTRA2)) {
-			factor = MPT_ULTRA2;
+		} else {
+			factor = MPT_ASYNC;
 		}
+	}
 
-		/* Save the data to the target structure.
-		 */
-		target->minSyncFactor = factor;
-		target->maxOffset = offset;
-		target->maxWidth = width;
-		if (canQ) {
-			target->tflags |= MPT_TARGET_FLAGS_Q_YES;
-		}
+	/* Make sure data is consistent
+	 */
+	if ((!width) && (factor < MPT_ULTRA2)) {
+		factor = MPT_ULTRA2;
+	}
 
-		target->tflags |= MPT_TARGET_FLAGS_VALID_NEGO;
+	/* Save the data to the target structure.
+	 */
+	target->minSyncFactor = factor;
+	target->maxOffset = offset;
+	target->maxWidth = width;
 
-		/* Disable unused features.
-		 */
-		target->negoFlags = pspi_data->noQas;
-		if (!width)
-			target->negoFlags |= MPT_TARGET_NO_NEGO_WIDE;
+	target->tflags |= MPT_TARGET_FLAGS_VALID_NEGO;
 
-		if (!offset)
-			target->negoFlags |= MPT_TARGET_NO_NEGO_SYNC;
+	/* Disable unused features.
+	 */
+	if (!width)
+		target->negoFlags |= MPT_TARGET_NO_NEGO_WIDE;
 
-		if (noQas)
-			target->negoFlags |= MPT_TARGET_NO_NEGO_QAS;
+	if (!offset)
+		target->negoFlags |= MPT_TARGET_NO_NEGO_SYNC;
 
-		/* GEM, processor WORKAROUND
-		 */
-		if (((target->inq_data[0] & 0x1F) == 0x03) || ((target->inq_data[0] & 0x1F) > 0x08)){
-			target->negoFlags |= (MPT_TARGET_NO_NEGO_WIDE | MPT_TARGET_NO_NEGO_SYNC);
-			pspi_data->dvStatus[id] |= MPT_SCSICFG_BLK_NEGO;
-		}
+	if ( factor > MPT_ULTRA320 )
+		noQas = 0;
 
-		/* Disable QAS if mixed configuration case
-		 */
-		if ((noQas) && (!pspi_data->noQas) && ((target->inq_data[0] & 0x1F) == 0x00)){
-			VirtDevice	*vdev;
-			int ii;
+	/* GEM, processor WORKAROUND
+	 */
+	if ((target->inq_data[0] == SCSI_TYPE_PROC) || (target->inq_data[0] > 0x08)) {
+		target->negoFlags |= (MPT_TARGET_NO_NEGO_WIDE | MPT_TARGET_NO_NEGO_SYNC);
+		pspi_data->dvStatus[id] |= MPT_SCSICFG_BLK_NEGO;
+	} else {
+		if (noQas && (pspi_data->noQas == 0)) {
+			pspi_data->noQas |= MPT_TARGET_NO_NEGO_QAS;
+			target->negoFlags |= MPT_TARGET_NO_NEGO_QAS;
 
-			ddvtprintk((KERN_INFO "Disabling QAS!\n"));
-			pspi_data->noQas = MPT_TARGET_NO_NEGO_QAS;
+			/* Disable QAS in a mixed configuration case
+	 		*/
+
+			ddvtprintk((KERN_INFO "Disabling QAS due to noQas=%02x on id=%d!\n", noQas, id));
 			for (ii = 0; ii < id; ii++) {
-				vdev = hd->Targets[id];
-				if (vdev != NULL)
+				if ( (vdev = hd->Targets[ii]) ) {
 					vdev->negoFlags |= MPT_TARGET_NO_NEGO_QAS;
+					mptscsih_writeSDP1(hd, 0, ii, vdev->negoFlags);
+				}	
 			}
 		}
-
 	}
 
-	return;
-}
-
-#ifdef MPT_SAVE_AUTOSENSE
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/*
- *  Clear sense valid flag.
- */
-static void clear_sense_flag(MPT_SCSI_HOST *hd, SCSIIORequest_t *pReq)
-{
-	VirtDevice	*target;
-	int		 index = (int) pReq->TargetID;
-
-	if ((target = hd->Targets[index])) {
-		target->tflags &= ~MPT_TARGET_FLAGS_VALID_SENSE;
+	/* Write SDP1 on this I/O to this target */
+	if (pspi_data->dvStatus[id] & MPT_SCSICFG_NEGOTIATE) {
+		ddvtprintk((KERN_INFO "MPT_SCSICFG_NEGOTIATE on id=%d!\n", id));
+		mptscsih_writeSDP1(hd, 0, id, hd->negoNvram);
+		pspi_data->dvStatus[id] &= ~MPT_SCSICFG_NEGOTIATE;
+	} else if (pspi_data->dvStatus[id] & MPT_SCSICFG_BLK_NEGO) {
+		ddvtprintk((KERN_INFO "MPT_SCSICFG_BLK_NEGO on id=%d!\n", id));
+		mptscsih_writeSDP1(hd, 0, id, MPT_SCSICFG_BLK_NEGO);
+		pspi_data->dvStatus[id] &= ~MPT_SCSICFG_BLK_NEGO;
 	}
-
-	return;
 }
-#endif
 
 /* If DV disabled (negoNvram set to USE_NVARM) or if not LUN 0, return.
  * Else set the NEED_DV flag after Read Capacity Issued (disks)
@@ -5246,14 +4957,19 @@ static void clear_sense_flag(MPT_SCSI_HO
 static void mptscsih_set_dvflags(MPT_SCSI_HOST *hd, SCSIIORequest_t *pReq)
 {
 	u8 cmd;
-	
+	ScsiCfgData *pSpi;
+
+	ddvtprintk((MYIOC_s_NOTE_FMT
+		" set_dvflags: id=%d lun=%d negoNvram=%x cmd=%x\n",
+		hd->ioc->name, pReq->TargetID, pReq->LUN[1], hd->negoNvram, pReq->CDB[0]));
+
 	if ((pReq->LUN[1] != 0) || (hd->negoNvram != 0))
 		return;
 
 	cmd = pReq->CDB[0];
 
 	if ((cmd == READ_CAPACITY) || (cmd == MODE_SENSE)) {
-		ScsiCfgData *pSpi = &hd->ioc->spi_data;
+		pSpi = &hd->ioc->spi_data;
 		if ((pSpi->isRaid & (1 << pReq->TargetID)) && pSpi->pIocPg3) {
 			/* Set NEED_DV for all hidden disks
 			 */
@@ -5316,9 +5032,11 @@ mptscsih_setDevicePage1Flags (u8 width, 
 
 	if (width && offset && !nowide && !nosync) {
 		if (factor < MPT_ULTRA160) {
-			*requestedPtr |= (MPI_SCSIDEVPAGE1_RP_IU + MPI_SCSIDEVPAGE1_RP_DT);
+			*requestedPtr |= (MPI_SCSIDEVPAGE1_RP_IU | MPI_SCSIDEVPAGE1_RP_DT);
 			if ((flags & MPT_TARGET_NO_NEGO_QAS) == 0)
 				*requestedPtr |= MPI_SCSIDEVPAGE1_RP_QAS;
+			if (flags & MPT_TAPE_NEGO_IDP)
+				*requestedPtr |= 0x08000000;
 		} else if (factor < MPT_ULTRA2) {
 			*requestedPtr |= MPI_SCSIDEVPAGE1_RP_DT;
 		}
@@ -5354,9 +5072,9 @@ static int
 mptscsih_writeSDP1(MPT_SCSI_HOST *hd, int portnum, int target_id, int flags)
 {
 	MPT_ADAPTER		*ioc = hd->ioc;
-	Config_t		*pReq = NULL;
-	SCSIDevicePage1_t	*pData = NULL;
-	VirtDevice		*pTarget = NULL;
+	Config_t		*pReq;
+	SCSIDevicePage1_t	*pData;
+	VirtDevice		*pTarget=NULL;
 	MPT_FRAME_HDR		*mf;
 	dma_addr_t		 dataDma;
 	u16			 req_idx;
@@ -5379,7 +5097,7 @@ mptscsih_writeSDP1(MPT_SCSI_HOST *hd, in
 		maxid = ioc->sh->max_id - 1;
 	} else if (ioc->sh) {
 		id = target_id;
-		maxid = MIN(id, ioc->sh->max_id - 1);
+		maxid = min_t(int, id, ioc->sh->max_id - 1);
 	}
 
 	for (; id <= maxid; id++) {
@@ -5412,124 +5130,432 @@ mptscsih_writeSDP1(MPT_SCSI_HOST *hd, in
 				maxfactor = MPT_ASYNC;
 		}
 
-		/* Set the negotiation flags.
-		 */
-		negoFlags = ioc->spi_data.noQas;
-		if (!maxwidth)
-			negoFlags |= MPT_TARGET_NO_NEGO_WIDE;
+		/* Set the negotiation flags.
+		 */
+		negoFlags = ioc->spi_data.noQas;
+		if (!maxwidth)
+			negoFlags |= MPT_TARGET_NO_NEGO_WIDE;
+
+		if (!maxoffset)
+			negoFlags |= MPT_TARGET_NO_NEGO_SYNC;
+
+		if (flags & MPT_SCSICFG_USE_NVRAM) {
+			width = maxwidth;
+			factor = maxfactor;
+			offset = maxoffset;
+		} else {
+			width = 0;
+			factor = MPT_ASYNC;
+			offset = 0;
+			//negoFlags = 0;
+			//negoFlags = MPT_TARGET_NO_NEGO_SYNC;
+		}
+
+		/* If id is not a raid volume, get the updated
+		 * transmission settings from the target structure.
+		 */
+		if (hd->Targets && (pTarget = hd->Targets[id]) && !pTarget->raidVolume) {
+			width = pTarget->maxWidth;
+			factor = pTarget->minSyncFactor;
+			offset = pTarget->maxOffset;
+			negoFlags |= pTarget->negoFlags;
+		}
+
+#ifdef MPTSCSIH_ENABLE_DOMAIN_VALIDATION
+		/* Force to async and narrow if DV has not been executed
+		 * for this ID
+		 */
+		if ((hd->ioc->spi_data.dvStatus[id] & MPT_SCSICFG_DV_NOT_DONE) != 0) {
+			width = 0;
+			factor = MPT_ASYNC;
+			offset = 0;
+		}
+#endif
+
+		if (flags & MPT_SCSICFG_BLK_NEGO)
+			negoFlags |= MPT_TARGET_NO_NEGO_WIDE | MPT_TARGET_NO_NEGO_SYNC;
+
+		mptscsih_setDevicePage1Flags(width, factor, offset,
+					&requested, &configuration, negoFlags);
+		dnegoprintk(("writeSDP1: id=%d width=%d factor=%x offset=%x negoFlags=%x request=%x config=%x\n",
+			target_id, width, factor, offset, negoFlags, requested, configuration));
+
+		/* Get a MF for this command.
+		 */
+		if ((mf = mpt_get_msg_frame(ScsiDoneCtx, ioc)) == NULL) {
+			dfailprintk((MYIOC_s_WARN_FMT "write SDP1: no msg frames!\n",
+				ioc->name));
+			return -EAGAIN;
+		}
+
+		ddvprintk((MYIOC_s_WARN_FMT "WriteSDP1 (mf=%p, id=%d, req=0x%x, cfg=0x%x)\n",
+			hd->ioc->name, mf, id, requested, configuration));
+
+
+		/* Set the request and the data pointers.
+		 * Request takes: 36 bytes (32 bit SGE)
+		 * SCSI Device Page 1 requires 16 bytes
+		 * 40 + 16 <= size of SCSI IO Request = 56 bytes
+		 * and MF size >= 64 bytes.
+		 * Place data at end of MF.
+		 */
+		pReq = (Config_t *)mf;
+
+		req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
+		frameOffset = ioc->req_sz - sizeof(SCSIDevicePage1_t);
+
+		pData = (SCSIDevicePage1_t *)((u8 *) mf + frameOffset);
+		dataDma = ioc->req_frames_dma + (req_idx * ioc->req_sz) + frameOffset;
+
+		/* Complete the request frame (same for all requests).
+		 */
+		pReq->Action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;
+		pReq->Reserved = 0;
+		pReq->ChainOffset = 0;
+		pReq->Function = MPI_FUNCTION_CONFIG;
+		pReq->ExtPageLength = 0;
+		pReq->ExtPageType = 0;
+		pReq->MsgFlags = 0;
+		for (ii=0; ii < 8; ii++) {
+			pReq->Reserved2[ii] = 0;
+		}
+		pReq->Header.PageVersion = ioc->spi_data.sdp1version;
+		pReq->Header.PageLength = ioc->spi_data.sdp1length;
+		pReq->Header.PageNumber = 1;
+		pReq->Header.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;
+		pReq->PageAddress = cpu_to_le32(id | (bus << 8 ));
+
+		/* Add a SGE to the config request.
+		 */
+		flagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE | ioc->spi_data.sdp1length * 4;
+
+		mpt_add_sge((char *)&pReq->PageBufferSGE, flagsLength, dataDma);
+
+		/* Set up the common data portion
+		 */
+		pData->Header.PageVersion = pReq->Header.PageVersion;
+		pData->Header.PageLength = pReq->Header.PageLength;
+		pData->Header.PageNumber = pReq->Header.PageNumber;
+		pData->Header.PageType = pReq->Header.PageType;
+		pData->RequestedParameters = cpu_to_le32(requested);
+		pData->Reserved = 0;
+		pData->Configuration = cpu_to_le32(configuration);
+
+		if ( pTarget ) {
+			if ( requested & MPI_SCSIDEVPAGE1_RP_IU ) {
+				pTarget->last_lun = MPT_LAST_LUN;
+			} else {
+				pTarget->last_lun = MPT_NON_IU_LAST_LUN;
+			}
+			dsprintk((MYIOC_s_WARN_FMT
+				"writeSDP1: last_lun=%d on id=%d\n",
+				ioc->name, pTarget->last_lun, id));
+		}
+
+		dprintk((MYIOC_s_WARN_FMT
+			"write SDP1: id %d pgaddr 0x%x req 0x%x config 0x%x\n",
+				ioc->name, id, (id | (bus<<8)),
+				requested, configuration));
+
+		mpt_put_msg_frame(ScsiDoneCtx, ioc, mf);
+	}
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*	mptscsih_writeIOCPage4  - write IOC Page 4
+ *	@hd: Pointer to a SCSI Host Structure
+ *	@target_id: write IOC Page4 for this ID & Bus
+ *
+ *	Return: -EAGAIN if unable to obtain a Message Frame
+ *		or 0 if success.
+ *
+ *	Remark: We do not wait for a return, write pages sequentially.
+ */
+static int
+mptscsih_writeIOCPage4(MPT_SCSI_HOST *hd, int target_id, int bus)
+{
+	MPT_ADAPTER		*ioc = hd->ioc;
+	Config_t		*pReq;
+	IOCPage4_t		*IOCPage4Ptr;
+	MPT_FRAME_HDR		*mf;
+	dma_addr_t		 dataDma;
+	u16			 req_idx;
+	u32			 frameOffset;
+	u32			 flagsLength;
+	int			 ii;
+
+	/* Get a MF for this command.
+	 */
+	if ((mf = mpt_get_msg_frame(ScsiDoneCtx, ioc)) == NULL) {
+		dfailprintk((MYIOC_s_WARN_FMT "writeIOCPage4 : no msg frames!\n",
+					ioc->name));
+		return -EAGAIN;
+	}
+
+	/* Set the request and the data pointers.
+	 * Place data at end of MF.
+	 */
+	pReq = (Config_t *)mf;
+
+	req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
+	frameOffset = ioc->req_sz - sizeof(IOCPage4_t);
+
+	/* Complete the request frame (same for all requests).
+	 */
+	pReq->Action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;
+	pReq->Reserved = 0;
+	pReq->ChainOffset = 0;
+	pReq->Function = MPI_FUNCTION_CONFIG;
+	pReq->ExtPageLength = 0;
+	pReq->ExtPageType = 0;
+	pReq->MsgFlags = 0;
+	for (ii=0; ii < 8; ii++) {
+		pReq->Reserved2[ii] = 0;
+	}
+
+       	IOCPage4Ptr = ioc->spi_data.pIocPg4;
+       	dataDma = ioc->spi_data.IocPg4_dma;
+       	ii = IOCPage4Ptr->ActiveSEP++;
+       	IOCPage4Ptr->SEP[ii].SEPTargetID = target_id;
+       	IOCPage4Ptr->SEP[ii].SEPBus = bus;
+       	pReq->Header = IOCPage4Ptr->Header;
+	pReq->PageAddress = cpu_to_le32(target_id | (bus << 8 ));
+
+	/* Add a SGE to the config request.
+	 */
+	flagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE | 
+		(IOCPage4Ptr->Header.PageLength + ii) * 4;
+
+	mpt_add_sge((char *)&pReq->PageBufferSGE, flagsLength, dataDma);
+
+	dinitprintk((MYIOC_s_WARN_FMT
+		"writeIOCPage4: MaxSEP=%d ActiveSEP=%d id=%d bus=%d\n",
+			ioc->name, IOCPage4Ptr->MaxSEP, IOCPage4Ptr->ActiveSEP, target_id, bus));
+
+	mpt_put_msg_frame(ScsiDoneCtx, ioc, mf);
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*	mptscsih_readFCDevicePage0  - read FC Device Page 0
+ *	@hd: Pointer to a SCSI Host Structure
+ *	@target_id: read FC Device Page 0 for this target ID
+ *
+ *	Return: -EAGAIN if unable to obtain a Message Frame
+ *		or 0 if success.
+ *
+ *	Remark: We do not wait for a return, read pages sequentially.
+ */
+static int
+mptscsih_readFCDevicePage0(MPT_SCSI_HOST *hd, int target_id)
+{
+	MPT_ADAPTER		*ioc = hd->ioc;
+	Config_t		*pReq;
+	MPT_FRAME_HDR		*mf;
+	dma_addr_t		 dataDma;
+	u16			 req_idx;
+	u32			 frameOffset;
+	u32			 flagsLength;
+	int			 ii;
+
+	/* Get a MF for this command.
+	 */
+	if ((mf = mpt_get_msg_frame(ScsiDoneCtx, ioc)) == NULL) {
+		dprintk((MYIOC_s_WARN_FMT "readFCDevicePage0 : no msg frames!\n",
+					ioc->name));
+		return -EAGAIN;
+	}
+
+	/* Set the request and the data pointers.
+	 * Place data at end of MF.
+	 */
+	pReq = (Config_t *)mf;
+
+	req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
+	frameOffset = sizeof(Config_t);
+
+	dataDma = ioc->req_frames_dma + (req_idx * ioc->req_sz) + frameOffset;
+
+	/* Complete the request frame (same for all requests).
+	 */
+	pReq->Action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+	pReq->Reserved = 0;
+	pReq->ChainOffset = 0;
+	pReq->Function = MPI_FUNCTION_CONFIG;
+	pReq->ExtPageLength = 0;
+	pReq->ExtPageType = 0;
+	pReq->MsgFlags = 0;
+	for (ii=0; ii < 8; ii++) {
+		pReq->Reserved2[ii] = 0;
+	}
+	pReq->Header.PageVersion = MPI_FC_DEVICE_PAGE0_PAGEVERSION;
+	pReq->Header.PageLength = sizeof(FCDevicePage0_t) / 4;
+	pReq->Header.PageNumber = 0;
+       	pReq->Header.PageType = MPI_CONFIG_PAGETYPE_FC_DEVICE;
+	pReq->PageAddress = cpu_to_le32(MPI_FC_DEVICE_PGAD_FORM_BUS_TID |
+					target_id);
+
+	/* Add a SGE to the config request.
+	 */
+	flagsLength = MPT_SGE_FLAGS_SSIMPLE_READ | sizeof(FCDevicePage0_t);
+	mpt_add_sge((char *)&pReq->PageBufferSGE, flagsLength, dataDma);
+
+	drsprintk((MYIOC_s_INFO_FMT "readFCDevicePage0: target=%d\n", ioc->name, target_id));
+
+	mpt_put_msg_frame(ScsiDoneCtx, ioc, mf);
 
-		if (!maxoffset)
-			negoFlags |= MPT_TARGET_NO_NEGO_SYNC;
+	return 0;
+}
 
-		if (flags & MPT_SCSICFG_USE_NVRAM) {
-			width = maxwidth;
-			factor = maxfactor;
-			offset = maxoffset;
-		} else {
-			width = 0;
-			factor = MPT_ASYNC;
-			offset = 0;
-			//negoFlags = 0;
-			//negoFlags = MPT_TARGET_NO_NEGO_SYNC;
-		}
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*	mptscsih_writeFCPortPage3  - write FC Port Page 3
+ *	@hd: Pointer to a SCSI Host Structure
+ *	@target_id: write FC Port Page 3 for this target ID
+ *
+ *	Return: -EAGAIN if unable to obtain a Message Frame
+ *		or 0 if success.
+ *
+ *	Remark: We do not wait for a return, write pages sequentially.
+ */
+static int
+mptscsih_writeFCPortPage3(MPT_SCSI_HOST *hd, int target_id)
+{
+	MPT_ADAPTER		*ioc = hd->ioc;
+	Config_t		*pReq;
+	FCPortPage3_t		*FCPort3;
+	MPT_FRAME_HDR		*mf;
+	dma_addr_t		 dataDma;
+	u16			 req_idx;
+	u32			 frameOffset;
+	u32			 flagsLength;
+	int			 ii;
+	VirtDevice		*pTarget;
 
-#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
-		/* Force to async and narrow if DV has not been executed
-		 * for this ID
-		 */
-		if ((hd->ioc->spi_data.dvStatus[id] & MPT_SCSICFG_DV_NOT_DONE) != 0) {
-			width = 0;
-			factor = MPT_ASYNC;
-			offset = 0;
-		}
-#endif
+	/* Get a MF for this command.
+	 */
+	if ((mf = mpt_get_msg_frame(ScsiDoneCtx, ioc)) == NULL) {
+		dprintk((MYIOC_s_WARN_FMT "writeFCPortPage3 : no msg frames!\n",
+					ioc->name));
+		return -EAGAIN;
+	}
 
-		/* If id is not a raid volume, get the updated
-		 * transmission settings from the target structure.
-		 */
-		if (hd->Targets && (pTarget = hd->Targets[id]) && !pTarget->raidVolume) {
-			width = pTarget->maxWidth;
-			factor = pTarget->minSyncFactor;
-			offset = pTarget->maxOffset;
-			negoFlags = pTarget->negoFlags;
-			pTarget = NULL;
-		}
+	/* Set the request and the data pointers.
+	 * Place data at end of MF.
+	 */
+	pReq = (Config_t *)mf;
 
-		if (flags & MPT_SCSICFG_BLK_NEGO)
-			negoFlags = MPT_TARGET_NO_NEGO_WIDE | MPT_TARGET_NO_NEGO_SYNC;
+	req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
+	frameOffset = sizeof(Config_t);
 
-		mptscsih_setDevicePage1Flags(width, factor, offset,
-					&requested, &configuration, negoFlags);
+	FCPort3 = (FCPortPage3_t *)((u8 *)mf + frameOffset);
+	dataDma = ioc->req_frames_dma + (req_idx * ioc->req_sz) + frameOffset;
 
-		/* Get a MF for this command.
-		 */
-		if ((mf = mpt_get_msg_frame(ScsiDoneCtx, ioc->id)) == NULL) {
-			dprintk((MYIOC_s_WARN_FMT "write SDP1: no msg frames!\n",
-						ioc->name));
-			return -EAGAIN;
-		}
+	/* Complete the request frame (same for all requests).
+	 */
+	pReq->Action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;
+	pReq->Reserved = 0;
+	pReq->ChainOffset = 0;
+	pReq->Function = MPI_FUNCTION_CONFIG;
+	pReq->ExtPageLength = 0;
+	pReq->ExtPageType = 0;
+	pReq->MsgFlags = 0;
+	for (ii=0; ii < 8; ii++) {
+		pReq->Reserved2[ii] = 0;
+	}
+	pReq->Header.PageVersion = MPI_FCPORTPAGE3_PAGEVERSION;
+	pReq->Header.PageLength = sizeof(FCPortPage3_t) / 4;
+	pReq->Header.PageNumber = 3;
+       	pReq->Header.PageType = MPI_CONFIG_PAGETYPE_FC_PORT |
+				MPI_CONFIG_PAGEATTR_PERSISTENT;
+	pReq->PageAddress = cpu_to_le32(MPI_FC_PORT_PGAD_FORM_INDEX |
+					target_id);
+
+	pTarget = hd->Targets[target_id];
+
+	FCPort3->Header.PageVersion = MPI_FCPORTPAGE3_PAGEVERSION;
+	FCPort3->Header.PageLength = sizeof(FCPortPage3_t) / 4;
+	FCPort3->Header.PageNumber = 3;
+       	FCPort3->Header.PageType = MPI_CONFIG_PAGETYPE_FC_PORT |
+				   MPI_CONFIG_PAGEATTR_PERSISTENT;
+       	FCPort3->Entry[0].PhysicalIdentifier.WWN.WWPN = pTarget->WWPN;
+       	FCPort3->Entry[0].PhysicalIdentifier.WWN.WWNN = pTarget->WWNN;
+       	FCPort3->Entry[0].TargetID = pTarget->target_id;
+       	FCPort3->Entry[0].Bus = pTarget->bus_id;
+	FCPort3->Entry[0].Flags = MPI_PERSISTENT_FLAGS_ENTRY_VALID;
 
-		ddvprintk((MYIOC_s_INFO_FMT "WriteSDP1 (mf=%p, id=%d, req=0x%x, cfg=0x%x)\n",
-			hd->ioc->name, mf, id, requested, configuration));
+	/* Add a SGE to the config request.
+	 */
+	flagsLength = MPT_SGE_FLAGS_SSIMPLE_READ | sizeof(FCPortPage3_t);
+	mpt_add_sge((char *)&pReq->PageBufferSGE, flagsLength, dataDma);
 
+	drsprintk((MYIOC_s_INFO_FMT "writeFCPortPage3: target=%d\n", ioc->name, target_id));
 
-		/* Set the request and the data pointers.
-		 * Request takes: 36 bytes (32 bit SGE)
-		 * SCSI Device Page 1 requires 16 bytes
-		 * 40 + 16 <= size of SCSI IO Request = 56 bytes
-		 * and MF size >= 64 bytes.
-		 * Place data at end of MF.
-		 */
-		pReq = (Config_t *)mf;
+	mpt_put_msg_frame(ScsiDoneCtx, ioc, mf);
 
-		req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
-		frameOffset = ioc->req_sz - sizeof(SCSIDevicePage1_t);
+	return 0;
+}
 
-		pData = (SCSIDevicePage1_t *)((u8 *) mf + frameOffset);
-		dataDma = ioc->req_frames_dma + (req_idx * ioc->req_sz) + frameOffset;
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*	mptscsih_sendIOCInit  - send IOC Init
+ *	@hd: Pointer to a SCSI Host Structure
+ *
+ *	Return: -EAGAIN if unable to obtain a Message Frame
+ *		or 0 if success.
+ *
+ *	Remark: We do not wait for a return, just dump and run.
+ */
+static int
+mptscsih_sendIOCInit(MPT_SCSI_HOST *hd)
+{
+	MPT_ADAPTER		*ioc = hd->ioc;
+	IOCInit_t		*pReq;
+	MPT_FRAME_HDR		*mf;
+	u16			 req_idx;
 
-		/* Complete the request frame (same for all requests).
-		 */
-		pReq->Action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;
-		pReq->Reserved = 0;
-		pReq->ChainOffset = 0;
-		pReq->Function = MPI_FUNCTION_CONFIG;
-		pReq->Reserved1[0] = 0;
-		pReq->Reserved1[1] = 0;
-		pReq->Reserved1[2] = 0;
-		pReq->MsgFlags = 0;
-		for (ii=0; ii < 8; ii++) {
-			pReq->Reserved2[ii] = 0;
-		}
-		pReq->Header.PageVersion = ioc->spi_data.sdp1version;
-		pReq->Header.PageLength = ioc->spi_data.sdp1length;
-		pReq->Header.PageNumber = 1;
-		pReq->Header.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;
-		pReq->PageAddress = cpu_to_le32(id | (bus << 8 ));
+	/* Get a MF for this command.
+	 */
+	if ((mf = mpt_get_msg_frame(ScsiDoneCtx, ioc)) == NULL) {
+		dprintk((MYIOC_s_WARN_FMT "sendIOCInit : no msg frames!\n",
+					ioc->name));
+		return -EAGAIN;
+	}
 
-		/* Add a SGE to the config request.
-		 */
-		flagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE | ioc->spi_data.sdp1length * 4;
+	/* Set the request pointer.
+	 */
+	pReq = (IOCInit_t *)mf;
 
-		mpt_add_sge((char *)&pReq->PageBufferSGE, flagsLength, dataDma);
+	req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
+	ioc->RequestNB[req_idx] = 0;
 
-		/* Set up the common data portion
-		 */
-		pData->Header.PageVersion = pReq->Header.PageVersion;
-		pData->Header.PageLength = pReq->Header.PageLength;
-		pData->Header.PageNumber = pReq->Header.PageNumber;
-		pData->Header.PageType = pReq->Header.PageType;
-		pData->RequestedParameters = cpu_to_le32(requested);
-		pData->Reserved = 0;
-		pData->Configuration = cpu_to_le32(configuration);
+	/* Complete the request frame (same for all requests).
+	 */
+	pReq->WhoInit = MPI_WHOINIT_HOST_DRIVER;
+	pReq->Reserved = 0;
+	pReq->ChainOffset = 0;
+	pReq->Function = MPI_FUNCTION_IOC_INIT;
+	pReq->Flags = 0;
+	pReq->MaxDevices = ioc->facts.MaxDevices;
+	pReq->MaxBuses = ioc->facts.MaxBuses;
+	pReq->MsgFlags = 0;
+	pReq->ReplyFrameSize = cpu_to_le16(ioc->reply_sz);
+	pReq->Reserved1[0] = 0;
+	pReq->Reserved1[1] = 0;
+	pReq->HostMfaHighAddr = ioc->facts.CurrentHostMfaHighAddr;
+	pReq->SenseBufferHighAddr = ioc->facts.CurrentSenseBufferHighAddr;
+	pReq->ReplyFifoHostSignalingAddr = ioc->facts.ReplyFifoHostSignalingAddr;
+	if (ioc->facts.Flags & MPI_IOCFACTS_FLAGS_REPLY_FIFO_HOST_SIGNAL) {
+		pReq->Flags |= MPI_IOCINIT_FLAGS_REPLY_FIFO_HOST_SIGNAL;
+	}
+	pReq->HostPageBufferSGE = ioc->facts.HostPageBufferSGE;
+	pReq->MsgVersion = cpu_to_le16(MPI_VERSION);
+	pReq->HeaderVersion = cpu_to_le16(MPI_HEADER_VERSION);
 
-		dprintk((MYIOC_s_INFO_FMT
-			"write SDP1: id %d pgaddr 0x%x req 0x%x config 0x%x\n",
-				ioc->name, id, (id | (bus<<8)),
-				requested, configuration));
+	drsprintk((MYIOC_s_INFO_FMT "sendIOCInit\n", ioc->name));
 
-		mptscsih_put_msgframe(ScsiDoneCtx, ioc->id, mf);
-	}
+	mpt_put_msg_frame(ScsiDoneCtx, ioc, mf);
 
 	return 0;
 }
@@ -5544,7 +5570,7 @@ static void mptscsih_taskmgmt_timeout(un
 {
 	MPT_SCSI_HOST *hd = (MPT_SCSI_HOST *) data;
 
-	dtmprintk((KERN_WARNING MYNAM ": %s: mptscsih_taskmgmt_timeout: "
+	dtmprintk((KERN_INFO MYNAM ": %s: mptscsih_taskmgmt_timeout: "
 		   "TM request timed out!\n", hd->ioc->name));
 
 	/* Delete the timer that triggered this callback.
@@ -5564,7 +5590,7 @@ static void mptscsih_taskmgmt_timeout(un
 		/* Because we have reset the IOC, no TM requests can be
 		 * pending.  So let's make sure the tmPending flag is reset.
 		 */
-		nehprintk((KERN_WARNING MYNAM
+		nehprintk((KERN_INFO MYNAM
 			   ": %s: mptscsih_taskmgmt_timeout\n",
 			   hd->ioc->name));
 		hd->tmPending = 0;
@@ -5627,32 +5653,28 @@ mptscsih_scandv_complete(MPT_ADAPTER *io
 	}
 	hd->cmdPtr = NULL;
 
-	ddvprintk((MYIOC_s_INFO_FMT "ScanDvComplete (mf=%p,mr=%p,idx=%d)\n",
+	ddvprintk((MYIOC_s_WARN_FMT "ScanDvComplete (mf=%p,mr=%p,idx=%d)\n",
 			hd->ioc->name, mf, mr, req_idx));
 
-	atomic_dec(&queue_depth);
-
 	hd->pLocal = &hd->localReply;
 	hd->pLocal->scsiStatus = 0;
 
 	/* If target struct exists, clear sense valid flag.
 	 */
-#ifdef MPT_SAVE_AUTOSENSE
-	clear_sense_flag(hd, pReq);
-#endif
-
 	if (mr == NULL) {
 		completionCode = MPT_SCANDV_GOOD;
 	} else {
 		SCSIIOReply_t	*pReply;
 		u16		 status;
+		u8		 scsi_status;
 
 		pReply = (SCSIIOReply_t *) mr;
 
 		status = le16_to_cpu(pReply->IOCStatus) & MPI_IOCSTATUS_MASK;
+		scsi_status = pReply->SCSIStatus;
 
 		ddvtprintk((KERN_NOTICE "  IOCStatus=%04xh, SCSIState=%02xh, SCSIStatus=%02xh, IOCLogInfo=%08xh\n",
-			     status, pReply->SCSIState, pReply->SCSIStatus,
+			     status, pReply->SCSIState, scsi_status,
 			     le32_to_cpu(pReply->IOCLogInfo)));
 
 		switch(status) {
@@ -5691,32 +5713,20 @@ mptscsih_scandv_complete(MPT_ADAPTER *io
 					completionCode = MPT_SCANDV_SOME_ERROR;
 
 			} else if (pReply->SCSIState & MPI_SCSI_STATE_AUTOSENSE_VALID) {
-#ifdef MPT_SAVE_AUTOSENSE
-				VirtDevice	*target;
-#endif
 				u8		*sense_data;
 				int		 sz;
 
-				/* save sense data in global & target structure
+				/* save sense data in global structure
 				 */
 				completionCode = MPT_SCANDV_SENSE;
-				hd->pLocal->scsiStatus = pReply->SCSIStatus;
+				hd->pLocal->scsiStatus = scsi_status;
 				sense_data = ((u8 *)hd->ioc->sense_buf_pool +
 					(req_idx * MPT_SENSE_BUFFER_ALLOC));
 
-				sz = MIN (pReq->SenseBufferLength,
+				sz = min_t(int, pReq->SenseBufferLength,
 							SCSI_STD_SENSE_BYTES);
 				memcpy(hd->pLocal->sense, sense_data, sz);
 
-#ifdef MPT_SAVE_AUTOSENSE
-				target = hd->Targets[pReq->TargetID];
-				if (target) {
-					memcpy(target->sense, sense_data, sz);
-					target->tflags
-						|= MPT_TARGET_FLAGS_VALID_SENSE;
-				}
-#endif
-
 				ddvprintk((KERN_NOTICE "  Check Condition, sense ptr %p\n",
 						sense_data));
 			} else if (pReply->SCSIState & MPI_SCSI_STATE_AUTOSENSE_FAILED) {
@@ -5730,11 +5740,8 @@ mptscsih_scandv_complete(MPT_ADAPTER *io
 			else if (pReply->SCSIState & MPI_SCSI_STATE_TERMINATED)
 				completionCode = MPT_SCANDV_DID_RESET;
 			else {
-				/* If no error, this will be equivalent
-				 * to MPT_SCANDV_GOOD
-				 */
+				hd->pLocal->scsiStatus = scsi_status;
 				completionCode = MPT_SCANDV_GOOD;
-				hd->pLocal->scsiStatus = pReply->SCSIStatus;
 			}
 			break;
 
@@ -5761,7 +5768,7 @@ mptscsih_scandv_complete(MPT_ADAPTER *io
 	 */
 wakeup:
 	/* Free Chain buffers (will never chain) in scan or dv */
-	//mptscsih_freeChainBuffers(hd, req_idx);
+	//mptscsih_freeChainBuffers(ioc, req_idx);
 
 	/*
 	 * Wake up the original calling thread
@@ -5799,6 +5806,8 @@ static void mptscsih_timer_expired(unsig
 			 *	for bus reset.
 			 */
 #ifndef MPT_SCSI_USE_NEW_EH
+			SCSIIORequest_t	*pReq = (SCSIIORequest_t *) hd->cmdPtr;
+
 			spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
 			if (hd->tmPending) {
 				spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
@@ -5806,9 +5815,8 @@ static void mptscsih_timer_expired(unsig
 			} else
 				hd->tmPending = 1;
 			spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
-
 			if (mptscsih_TMHandler(hd, MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS,
-							0, 0, 0, NO_SLEEP) < 0) {
+							pReq->Bus, 0, 0, 0, NO_SLEEP) < 0) {
 				printk(MYIOC_s_WARN_FMT "TM FAILED!\n", hd->ioc->name);
 			}
 #else
@@ -5835,7 +5843,7 @@ static void mptscsih_timer_expired(unsig
 	return;
 }
 
-#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+#ifdef MPTSCSIH_ENABLE_DOMAIN_VALIDATION
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*	mptscsih_do_raid - Format and Issue a RAID volume request message.
  *	@hd: Pointer to scsi host structure
@@ -5864,7 +5872,7 @@ mptscsih_do_raid(MPT_SCSI_HOST *hd, u8 a
 
 	/* Get and Populate a free Frame
 	 */
-	if ((mf = mpt_get_msg_frame(ScsiScanDvCtx, hd->ioc->id)) == NULL) {
+	if ((mf = mpt_get_msg_frame(ScsiScanDvCtx, hd->ioc)) == NULL) {
 		ddvprintk((MYIOC_s_WARN_FMT "_do_raid: no msg frames!\n",
 					hd->ioc->name));
 		return -EAGAIN;
@@ -5885,11 +5893,11 @@ mptscsih_do_raid(MPT_SCSI_HOST *hd, u8 a
 	mpt_add_sge((char *)&pReq->ActionDataSGE,
 		MPT_SGE_FLAGS_SSIMPLE_READ | 0, (dma_addr_t) -1);
 
-	ddvprintk((MYIOC_s_INFO_FMT "RAID Volume action %x id %d\n",
+	ddvprintk((MYIOC_s_WARN_FMT "RAID Volume action %x id %d\n",
 			hd->ioc->name, action, io->id));
 
 	hd->pLocal = NULL;
-	hd->timer.expires = jiffies + HZ*2; /* 2 second timeout */
+	hd->timer.expires = jiffies + HZ*10; /* 10 second timeout */
 	scandv_wait_done = 0;
 
 	/* Save cmd pointer, for resource free if timeout or
@@ -5898,7 +5906,7 @@ mptscsih_do_raid(MPT_SCSI_HOST *hd, u8 a
 	hd->cmdPtr = mf;
 
 	add_timer(&hd->timer);
-	mptscsih_put_msgframe(ScsiScanDvCtx, hd->ioc->id, mf);
+	mpt_put_msg_frame(ScsiScanDvCtx, hd->ioc, mf);
 	wait_event(scandv_waitq, scandv_wait_done);
 
 	if ((hd->pLocal == NULL) || (hd->pLocal->completion != MPT_SCANDV_GOOD))
@@ -5906,7 +5914,7 @@ mptscsih_do_raid(MPT_SCSI_HOST *hd, u8 a
 
 	return 0;
 }
-#endif /* ~MPTSCSIH_DISABLE_DOMAIN_VALIDATION */
+#endif /* ~MPTSCSIH_ENABLE_DOMAIN_VALIDATION */
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
@@ -5962,13 +5970,13 @@ mptscsih_do_cmd(MPT_SCSI_HOST *hd, INTER
 
 	case CMD_TestUnitReady:
 		cmdLen = 6;
-		dir = MPI_SCSIIO_CONTROL_READ;
+		dir = MPI_SCSIIO_CONTROL_NODATATRANSFER;
 		cmdTimeout = 10;
 		break;
 
 	case CMD_StartStopUnit:
 		cmdLen = 6;
-		dir = MPI_SCSIIO_CONTROL_READ;
+		dir = MPI_SCSIIO_CONTROL_NODATATRANSFER;
 		CDB[0] = cmd;
 		CDB[4] = 1;	/*Spin up the disk */
 		cmdTimeout = 15;
@@ -6018,21 +6026,21 @@ mptscsih_do_cmd(MPT_SCSI_HOST *hd, INTER
 
 	case CMD_Reserve6:
 		cmdLen = 6;
-		dir = MPI_SCSIIO_CONTROL_READ;
+		dir = MPI_SCSIIO_CONTROL_NODATATRANSFER;
 		CDB[0] = cmd;
 		cmdTimeout = 10;
 		break;
 
 	case CMD_Release6:
 		cmdLen = 6;
-		dir = MPI_SCSIIO_CONTROL_READ;
+		dir = MPI_SCSIIO_CONTROL_NODATATRANSFER;
 		CDB[0] = cmd;
 		cmdTimeout = 10;
 		break;
 
 	case CMD_SynchronizeCache:
 		cmdLen = 10;
-		dir = MPI_SCSIIO_CONTROL_READ;
+		dir = MPI_SCSIIO_CONTROL_NODATATRANSFER;
 		CDB[0] = cmd;
 //		CDB[1] = 0x02;	/* set immediate bit */
 		cmdTimeout = 10;
@@ -6045,8 +6053,8 @@ mptscsih_do_cmd(MPT_SCSI_HOST *hd, INTER
 
 	/* Get and Populate a free Frame
 	 */
-	if ((mf = mpt_get_msg_frame(ScsiScanDvCtx, hd->ioc->id)) == NULL) {
-		ddvprintk((MYIOC_s_WARN_FMT "No msg frames!\n",
+	if ((mf = mpt_get_msg_frame(ScsiScanDvCtx, hd->ioc)) == NULL) {
+		dfailprintk((MYIOC_s_WARN_FMT "mptscsih_do_command: No msg frames!\n",
 					hd->ioc->name));
 		return -EBUSY;
 	}
@@ -6055,7 +6063,6 @@ mptscsih_do_cmd(MPT_SCSI_HOST *hd, INTER
 
 	/* Get the request index */
 	my_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
-	ADD_INDEX_LOG(my_idx); /* for debug */
 
 	if (io->flags & MPT_ICFLAG_PHYS_DISK) {
 		pScsiReq->TargetID = io->physDiskNum;
@@ -6088,7 +6095,7 @@ mptscsih_do_cmd(MPT_SCSI_HOST *hd, INTER
 
 	if (cmd == CMD_RequestSense) {
 		pScsiReq->Control = cpu_to_le32(dir | MPI_SCSIIO_CONTROL_UNTAGGED);
-		ddvprintk((MYIOC_s_INFO_FMT "Untagged! 0x%2x\n",
+		ddvprintk((MYIOC_s_WARN_FMT "Untagged! 0x%2x\n",
 			hd->ioc->name, cmd));
 	}
 
@@ -6099,17 +6106,22 @@ mptscsih_do_cmd(MPT_SCSI_HOST *hd, INTER
 	pScsiReq->SenseBufferLowAddr = cpu_to_le32(hd->ioc->sense_buf_low_dma
 					   + (my_idx * MPT_SENSE_BUFFER_ALLOC));
 
-	ddvprintk((MYIOC_s_INFO_FMT "Sending Command 0x%x for (%d:%d:%d)\n",
+	ddvprintk((MYIOC_s_WARN_FMT "Sending Command 0x%x for (%d:%d:%d)\n",
 			hd->ioc->name, cmd, io->bus, io->id, io->lun));
 
 	if (dir == MPI_SCSIIO_CONTROL_READ) {
 		mpt_add_sge((char *) &pScsiReq->SGL,
 			MPT_SGE_FLAGS_SSIMPLE_READ | io->size,
 			io->data_dma);
-	} else {
+	} else if (dir == MPI_SCSIIO_CONTROL_WRITE) {
 		mpt_add_sge((char *) &pScsiReq->SGL,
 			MPT_SGE_FLAGS_SSIMPLE_WRITE | io->size,
 			io->data_dma);
+	} else {
+		/* Add a NULL SGE */
+		mptscsih_add_sge((char *)&pScsiReq->SGL, 
+			MPT_SGE_FLAGS_SSIMPLE_READ,
+			(dma_addr_t) -1);
 	}
 
 	/* The ISR will free the request frame, but we need
@@ -6135,7 +6147,7 @@ mptscsih_do_cmd(MPT_SCSI_HOST *hd, INTER
 	hd->cmdPtr = mf;
 
 	add_timer(&hd->timer);
-	mptscsih_put_msgframe(ScsiScanDvCtx, hd->ioc->id, mf);
+	mpt_put_msg_frame(ScsiScanDvCtx, hd->ioc, mf);
 	wait_event(scandv_waitq, scandv_wait_done);
 
 	if (hd->pLocal) {
@@ -6151,7 +6163,7 @@ mptscsih_do_cmd(MPT_SCSI_HOST *hd, INTER
 	} else {
 		rc = -EFAULT;
 		/* This should never happen. */
-		ddvprintk((MYIOC_s_INFO_FMT "_do_cmd: Null pLocal!!!\n",
+		ddvprintk((MYIOC_s_WARN_FMT "_do_cmd: Null pLocal!!!\n",
 				hd->ioc->name));
 	}
 
@@ -6173,7 +6185,7 @@ static int
 mptscsih_synchronize_cache(MPT_SCSI_HOST *hd, int portnum)
 {
 	MPT_ADAPTER		*ioc= hd->ioc;
-	VirtDevice		*pTarget = NULL;
+	VirtDevice		*pTarget;
 	SCSIDevicePage1_t	*pcfg1Data = NULL;
 	INTERNAL_CMD		 iocmd;
 	CONFIGPARMS		 cfg;
@@ -6181,7 +6193,8 @@ mptscsih_synchronize_cache(MPT_SCSI_HOST
 	ConfigPageHeader_t	 header1;
 	int			 bus = 0;
 	int			 id = 0;
-	int			 lun = 0;
+	int			 lun;
+	int			 indexed_lun, lun_index;
 	int			 hostId = ioc->pfacts[portnum].PortSCSIID;
 	int			 max_id;
 	int			 requested, configuration, data;
@@ -6214,18 +6227,18 @@ mptscsih_synchronize_cache(MPT_SCSI_HOST
 	/* Write SDP1 for all SCSI devices
 	 * Alloc memory and set up config buffer
 	 */
-	if (hd->is_spi) {
+	if (ioc->bus_type == SCSI) {
 		if (ioc->spi_data.sdp1length > 0) {
 			pcfg1Data = (SCSIDevicePage1_t *)pci_alloc_consistent(ioc->pcidev,
 					 ioc->spi_data.sdp1length * 4, &cfg1_dma_addr);
-	
+
 			if (pcfg1Data != NULL) {
 				doConfig = 1;
 				header1.PageVersion = ioc->spi_data.sdp1version;
 				header1.PageLength = ioc->spi_data.sdp1length;
 				header1.PageNumber = 1;
 				header1.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;
-				cfg.hdr = &header1;
+				cfg.cfghdr.hdr = &header1;
 				cfg.physAddr = cfg1_dma_addr;
 				cfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;
 				cfg.dir = 1;
@@ -6263,6 +6276,8 @@ mptscsih_synchronize_cache(MPT_SCSI_HOST
 			/* Force to async, narrow */
 			mptscsih_setDevicePage1Flags(0, MPT_ASYNC, 0, &requested,
 					&configuration, flags);
+			dnegoprintk(("syncronize cache: id=%d width=0 factor=MPT_ASYNC offset=0 negoFlags=%x request=%x config=%x\n",
+				id, flags, requested, configuration));
 			pcfg1Data->RequestedParameters = le32_to_cpu(requested);
 			pcfg1Data->Reserved = 0;
 			pcfg1Data->Configuration = le32_to_cpu(configuration);
@@ -6272,16 +6287,21 @@ mptscsih_synchronize_cache(MPT_SCSI_HOST
 
 		/* If target Ptr NULL or if this target is NOT a disk, skip.
 		 */
-	//	if (pTarget && ((pTarget->inq_data[0] & 0x1F) == 0)) {
-		if ((pTarget) && (pTarget->tflags & MPT_TARGET_FLAGS_Q_YES)){
+		if ((pTarget) && (pTarget->tflags & MPT_TARGET_FLAGS_Q_YES)) {
+		    if (pTarget->inq_data[0] == SCSI_TYPE_DAD ||
+		        pTarget->inq_data[0] == SCSI_TYPE_WORM ||
+		        pTarget->inq_data[0] == SCSI_TYPE_OPTICAL) {
 			for (lun=0; lun <= MPT_LAST_LUN; lun++) {
 				/* If LUN present, issue the command
 				 */
-				if (pTarget->luns & (1<<lun)) {
+				lun_index = (lun >> 5);  /* 32 luns per lun_index */
+				indexed_lun = (lun % 32);
+				if (pTarget->luns[lun_index] & (1<<indexed_lun)) {
 					iocmd.lun = lun;
 					(void) mptscsih_do_cmd(hd, &iocmd);
 				}
 			}
+		    }
 		}
 
 		/* get next relevant device */
@@ -6303,7 +6323,7 @@ mptscsih_synchronize_cache(MPT_SCSI_HOST
 	return 0;
 }
 
-#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+#ifdef MPTSCSIH_ENABLE_DOMAIN_VALIDATION
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
  *	mptscsih_domainValidation - Top level handler for domain validation.
@@ -6318,8 +6338,8 @@ mptscsih_synchronize_cache(MPT_SCSI_HOST
 static void
 mptscsih_domainValidation(void *arg)
 {
-	MPT_SCSI_HOST		*hd = NULL;
-	MPT_ADAPTER		*ioc = NULL;
+	MPT_SCSI_HOST		*hd;
+	MPT_ADAPTER		*ioc;
 	unsigned long		 flags;
 	int 			 id, maxid, dvStatus, did;
 	int			 ii, isPhysDisk;
@@ -6341,7 +6361,7 @@ mptscsih_domainValidation(void *arg)
 	did = 1;
 	while (did) {
 		did = 0;
-		for (ioc = mpt_adapter_find_first(); ioc != NULL; ioc = mpt_adapter_find_next(ioc)) {
+		list_for_each_entry(ioc, &ioc_list, list) {
 			spin_lock_irqsave(&dvtaskQ_lock, flags);
 			if (dvtaskQ_release) {
 				dvtaskQ_active = 0;
@@ -6354,7 +6374,7 @@ mptscsih_domainValidation(void *arg)
 			schedule_timeout(HZ/4);
 
 			/* DV only to SCSI adapters */
-			if ((int)ioc->chip_type <= (int)FC929)
+			if (ioc->bus_type != SCSI)
 				continue;
 			
 			/* Make sure everything looks ok */
@@ -6382,7 +6402,7 @@ mptscsih_domainValidation(void *arg)
 				ioc->spi_data.forceDv &= ~MPT_SCSICFG_RELOAD_IOC_PG3;
 			}
 
-			maxid = MIN (ioc->sh->max_id, MPT_MAX_SCSI_DEVICES);
+			maxid = min_t(int, ioc->sh->max_id, MPT_MAX_SCSI_DEVICES);
 
 			for (id = 0; id < maxid; id++) {
 				spin_lock_irqsave(&dvtaskQ_lock, flags);
@@ -6476,7 +6496,7 @@ static int mptscsih_is_phys_disk(MPT_ADA
  */
 static void mptscsih_qas_check(MPT_SCSI_HOST *hd, int id)
 {
-	VirtDevice *pTarget = NULL;
+	VirtDevice *pTarget;
 	int ii;
 
 	if (hd->Targets == NULL)
@@ -6494,11 +6514,14 @@ static void mptscsih_qas_check(MPT_SCSI_
 		if ((pTarget != NULL) && (!pTarget->raidVolume)) {
 			if ((pTarget->negoFlags & hd->ioc->spi_data.noQas) == 0) {
 				pTarget->negoFlags |= hd->ioc->spi_data.noQas;
+				dnegoprintk(("writeSDP1: id=%d negoFlags=%x\n", id, pTarget->negoFlags));
 				mptscsih_writeSDP1(hd, 0, ii, 0);
 			}
 		} else {
-			if (mptscsih_is_phys_disk(hd->ioc, ii) == 1)
+			if (mptscsih_is_phys_disk(hd->ioc, ii) == 1) {
+				dnegoprintk(("writeSDP1: id=%d SCSICFG_USE_NVRAM\n", id));
 				mptscsih_writeSDP1(hd, 0, ii, MPT_SCSICFG_USE_NVRAM);
+			}
 		}
 	}
 	return;
@@ -6527,15 +6550,15 @@ static void mptscsih_qas_check(MPT_SCSI_
  *	Return: None.
  */
 static int
-mptscsih_doDv(MPT_SCSI_HOST *hd, int portnum, int id)
+mptscsih_doDv(MPT_SCSI_HOST *hd, int bus_number, int id)
 {
 	MPT_ADAPTER		*ioc = hd->ioc;
-	VirtDevice		*pTarget = NULL;
-	SCSIDevicePage1_t	*pcfg1Data = NULL;
-	SCSIDevicePage0_t	*pcfg0Data = NULL;
-	u8			*pbuf1 = NULL;
-	u8			*pbuf2 = NULL;
-	u8			*pDvBuf = NULL;
+	VirtDevice		*pTarget;
+	SCSIDevicePage1_t	*pcfg1Data;
+	SCSIDevicePage0_t	*pcfg0Data;
+	u8			*pbuf1;
+	u8			*pbuf2;
+	u8			*pDvBuf;
 	dma_addr_t		 dvbuf_dma = -1;
 	dma_addr_t		 buf1_dma = -1;
 	dma_addr_t		 buf2_dma = -1;
@@ -6555,6 +6578,7 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 	int			 patt;
 	int			 repeat;
 	int			 retcode = 0;
+	int			 nfactor =  MPT_ULTRA320;
 	char			 firstPass = 1;
 	char			 doFallback = 0;
 	char			 readPage0;
@@ -6567,14 +6591,17 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 	if (ioc->spi_data.sdp0length == 0)
 		return 0;
 
-	if (id == ioc->pfacts[portnum].PortSCSIID)
+	/* If multiple buses are used, require that the initiator
+	 * id be the same on all buses.
+	 */
+	if (id == ioc->pfacts[0].PortSCSIID)
 		return 0;
 
 	lun = 0;
-	bus = 0;
+	bus = (u8) bus_number;
 	ddvtprintk((MYIOC_s_NOTE_FMT
-			"DV started: numIOs %d bus=%d, id %d dv @ %p\n",
-			ioc->name, atomic_read(&queue_depth), bus, id, &dv));
+			"DV Started: bus=%d id=%d dv @ %p\n",
+			ioc->name, bus, id, &dv));
 
 	/* Prep DV structure
 	 */
@@ -6587,8 +6614,6 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 	 */
 	dv.cmd = MPT_GET_NVRAM_VALS;
 	mptscsih_dv_parms(hd, &dv, NULL);
-	if ((!dv.max.width) && (!dv.max.offset))
-		return 0;
 
 	/* Prep SCSI IO structure
 	 */
@@ -6600,15 +6625,6 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 	iocmd.rsvd = iocmd.rsvd2 = 0;
 
 	pTarget = hd->Targets[id];
-	if (pTarget && (pTarget->tflags & MPT_TARGET_FLAGS_VALID_INQUIRY)) {
-		/* Another GEM workaround. Check peripheral device type,
-		 * if PROCESSOR, quit DV.
-		 */
-		if (((pTarget->inq_data[0] & 0x1F) == 0x03) || ((pTarget->inq_data[0] & 0x1F) > 0x08)) {
-			pTarget->negoFlags |= (MPT_TARGET_NO_NEGO_WIDE | MPT_TARGET_NO_NEGO_SYNC);
-			return 0;
-		}
-	}
 
 	/* Use tagged commands if possible.
 	 */
@@ -6628,7 +6644,7 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 	/* Prep cfg structure
 	 */
 	cfg.pageAddr = (bus<<8) | id;
-	cfg.hdr = NULL;
+	cfg.cfghdr.hdr = NULL;
 
 	/* Prep SDP0 header
 	 */
@@ -6674,23 +6690,41 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 	pcfg1Data = (SCSIDevicePage1_t *) (pDvBuf + sz);
 	cfg1_dma_addr = dvbuf_dma + sz;
 
-	/* Skip this ID? Set cfg.hdr to force config page write
+	/* Skip this ID? Set cfg.cfghdr.hdr to force config page write
 	 */
-	if ((ioc->spi_data.nvram[id] != MPT_HOST_NVRAM_INVALID) &&
-			(!(ioc->spi_data.nvram[id] & MPT_NVRAM_ID_SCAN_ENABLE))) {
-
-		ddvprintk((MYIOC_s_NOTE_FMT "DV Skipped: bus, id, lun (%d, %d, %d)\n",
-			ioc->name, bus, id, lun));
+	{
+		ScsiCfgData *pspi_data = &hd->ioc->spi_data;
+		if (pspi_data->nvram && (pspi_data->nvram[id] != MPT_HOST_NVRAM_INVALID)) {
+			/* Set the factor from nvram */
+			nfactor = (pspi_data->nvram[id] & MPT_NVRAM_SYNC_MASK) >> 8;
+			if (nfactor < pspi_data->minSyncFactor )
+				nfactor = pspi_data->minSyncFactor;
+	
+			if (!(pspi_data->nvram[id] & MPT_NVRAM_ID_SCAN_ENABLE) ||
+				(pspi_data->PortFlags == MPI_SCSIPORTPAGE2_PORT_FLAGS_OFF_DV) ) {
+	
+				ddvprintk((MYIOC_s_NOTE_FMT "DV Skipped: bus, id, lun (%d, %d, %d)\n",
+					ioc->name, bus, id, lun));
+	
+				dv.cmd = MPT_SET_MAX;
+				mptscsih_dv_parms(hd, &dv, (void *)pcfg1Data);
+				cfg.cfghdr.hdr = &header1;
 
-		dv.cmd = MPT_SET_MAX;
-		mptscsih_dv_parms(hd, &dv, (void *)pcfg1Data);
-		cfg.hdr = &header1;
-		goto target_done;
+				/* Save the final negotiated settings to
+				 * SCSI device page 1.
+				 */
+				cfg.physAddr = cfg1_dma_addr;
+				cfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;
+				cfg.dir = 1;
+				mpt_config(hd->ioc, &cfg);
+				goto target_done;
+			}
+		}
 	}
 
 	/* Finish iocmd inititialization - hidden or visible disk? */
 	if (ioc->spi_data.pIocPg3) {
-		/* Searc IOC page 3 for matching id
+		/* Search IOC page 3 for matching id
 		 */
 		Ioc3PhysDisk_t *pPDisk =  ioc->spi_data.pIocPg3->PhysDisk;
 		int		numPDisk = ioc->spi_data.pIocPg3->NumPhysDisks;
@@ -6732,15 +6766,15 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 	 */
 	hd->pLocal = NULL;
 	readPage0 = 0;
-	sz = SCSI_STD_INQUIRY_BYTES;
+	sz = SCSI_MAX_INQUIRY_BYTES;
 	rc = MPT_SCANDV_GOOD;
 	while (1) {
-		ddvprintk((MYIOC_s_NOTE_FMT "DV: Start Basic test.\n", ioc->name));
+		ddvprintk((MYIOC_s_NOTE_FMT "DV: Start Basic test on id=%d\n", ioc->name, id));
 		retcode = 0;
 		dv.cmd = MPT_SET_MIN;
 		mptscsih_dv_parms(hd, &dv, (void *)pcfg1Data);
 
-		cfg.hdr = &header1;
+		cfg.cfghdr.hdr = &header1;
 		cfg.physAddr = cfg1_dma_addr;
 		cfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;
 		cfg.dir = 1;
@@ -6781,6 +6815,7 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 		iocmd.data_dma = buf1_dma;
 		iocmd.data = pbuf1;
 		iocmd.size = sz;
+		memset(pbuf1, 0x00, sz);
 		if (mptscsih_do_cmd(hd, &iocmd) < 0)
 			goto target_done;
 		else {
@@ -6807,15 +6842,54 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 			}
 		}
 
+		/* Reset the size for disks
+		 */
+		inq0 = (*pbuf1) & 0x1F;
+		if ((inq0 == 0) && pTarget && !pTarget->raidVolume) {
+			sz = 0x40;
+			iocmd.size = sz;
+		}
+
 		/* Another GEM workaround. Check peripheral device type,
 		 * if PROCESSOR, quit DV.
 		 */
-		if (((pbuf1[0] & 0x1F) == 0x03) || ((pbuf1[0] & 0x1F) > 0x08))
+		if (inq0 == SCSI_TYPE_PROC) { 
+			mptscsih_initTarget(hd,
+				bus,
+				id,
+				lun,
+				pbuf1,
+				sz);
+			goto target_done;
+		}
+
+		if (inq0 > 0x08)
 			goto target_done;
 
 		if (mptscsih_do_cmd(hd, &iocmd) < 0)
 			goto target_done;
 
+		if (sz == 0x40) {
+			if ((pTarget->maxWidth == 1) && (pTarget->maxOffset) && (nfactor < 0x0A)
+				&& (pTarget->minSyncFactor > 0x09)) {
+				if ((pbuf1[56] & 0x04) == 0)
+					;
+				else if ((pbuf1[56] & 0x01) == 1) {
+					pTarget->minSyncFactor = nfactor > MPT_ULTRA320 ? nfactor : MPT_ULTRA320;
+				} else {
+					pTarget->minSyncFactor = nfactor > MPT_ULTRA160 ? nfactor : MPT_ULTRA160;
+				}
+
+				dv.max.factor = pTarget->minSyncFactor;
+
+				if ((pbuf1[56] & 0x02) == 0) {
+					pTarget->negoFlags |= MPT_TARGET_NO_NEGO_QAS;
+					hd->ioc->spi_data.noQas = MPT_TARGET_NO_NEGO_QAS;
+					ddvprintk((MYIOC_s_NOTE_FMT "DV: Start Basic noQas on id=%d due to pbuf1[56]=%x\n", ioc->name, id, pbuf1[56]));
+				}
+			}
+		}
+
 		if (doFallback)
 			dv.cmd = MPT_FALLBACK;
 		else
@@ -6832,6 +6906,7 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 		iocmd.data_dma = buf2_dma;
 		iocmd.data = pbuf2;
 		iocmd.size = sz;
+		memset(pbuf2, 0x00, sz);
 		if (mptscsih_do_cmd(hd, &iocmd) < 0)
 			goto target_done;
 		else if (hd->pLocal == NULL)
@@ -6849,7 +6924,7 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 					u32 sdp0_info;
 					u32 sdp0_nego;
 
-					cfg.hdr = &header0;
+					cfg.cfghdr.hdr = &header0;
 					cfg.physAddr = cfg0_dma_addr;
 					cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
 					cfg.dir = 0;
@@ -6884,14 +6959,25 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 					if (memcmp(pbuf1, pbuf2, sz) != 0) {
 						if (!firstPass)
 							doFallback = 1;
-					} else
+					} else {
+						ddvprintk((MYIOC_s_NOTE_FMT "DV:Inquiry compared id=%d, calling initTarget\n", ioc->name, id));
+						hd->ioc->spi_data.dvStatus[id] &= ~MPT_SCSICFG_DV_NOT_DONE;
+						mptscsih_initTarget(hd,
+							bus,
+							id,
+							lun,
+							pbuf1,
+							sz);
 						break;	/* test complete */
+					}
 				}
 
 
 			} else if (rc == MPT_SCANDV_ISSUE_SENSE)
 				doFallback = 1;	/* set fallback flag */
-			else if ((rc == MPT_SCANDV_DID_RESET) || (rc == MPT_SCANDV_SENSE))
+			else if ((rc == MPT_SCANDV_DID_RESET) ||
+				 (rc == MPT_SCANDV_SENSE) || 
+				 (rc == MPT_SCANDV_FALLBACK))
 				doFallback = 1;	/* set fallback flag */
 			else
 				goto target_done;
@@ -6899,7 +6985,11 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 			firstPass = 0;
 		}
 	}
-	ddvprintk((MYIOC_s_NOTE_FMT "DV: Basic test completed OK.\n", ioc->name));
+	ddvprintk((MYIOC_s_NOTE_FMT "DV: Basic test on id=%d completed OK.\n", ioc->name, id));
+
+	if (mpt_dv == 0)
+		goto target_done;
+
 	inq0 = (*pbuf1) & 0x1F;
 
 	/* Continue only for disks
@@ -6907,6 +6997,14 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 	if (inq0 != 0)
 		goto target_done;
 
+	ddvprintk((MYIOC_s_NOTE_FMT "DV: bus, id, lun (%d, %d, %d) PortFlags=%x\n",
+			ioc->name, bus, id, lun, ioc->spi_data.PortFlags));
+	if ( ioc->spi_data.PortFlags == MPI_SCSIPORTPAGE2_PORT_FLAGS_BASIC_DV_ONLY ) {
+		ddvprintk((MYIOC_s_NOTE_FMT "DV Basic Only: bus, id, lun (%d, %d, %d) PortFlags=%x\n",
+			ioc->name, bus, id, lun, ioc->spi_data.PortFlags));
+		goto target_done;
+	}
+
 	/* Start the Enhanced Test.
 	 * 0) issue TUR to clear out check conditions
 	 * 1) read capacity of echo (regular) buffer
@@ -6915,7 +7013,7 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 	 * 4) release
 	 * 5) update nego parms to target struct
 	 */
-	cfg.hdr = &header1;
+	cfg.cfghdr.hdr = &header1;
 	cfg.physAddr = cfg1_dma_addr;
 	cfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;
 	cfg.dir = 1;
@@ -6939,7 +7037,7 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 			u8 skey = hd->pLocal->sense[2] & 0x0F;
 			u8 asc = hd->pLocal->sense[12];
 			u8 ascq = hd->pLocal->sense[13];
-			ddvprintk((MYIOC_s_INFO_FMT
+			ddvprintk((MYIOC_s_WARN_FMT
 				"SenseKey:ASC:ASCQ = (%x:%02x:%02x)\n",
 				ioc->name, skey, asc, ascq));
 
@@ -6956,7 +7054,7 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 			} else {
 				/* All other errors are fatal.
 				 */
-				ddvprintk((MYIOC_s_INFO_FMT "DV: fatal error.",
+				ddvprintk((MYIOC_s_WARN_FMT "DV: fatal error.",
 						ioc->name));
 				goto target_done;
 			}
@@ -7002,6 +7100,8 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 					notDone = 0;
 					if (iocmd.flags & MPT_ICFLAG_ECHO) {
 						bufsize =  ((pbuf1[2] & 0x1F) <<8) | pbuf1[3];
+						if (pbuf1[0] & 0x01)
+							iocmd.flags |= MPT_ICFLAG_EBOS;
 					} else {
 						bufsize =  pbuf1[1]<<16 | pbuf1[2]<<8 | pbuf1[3];
 					}
@@ -7009,7 +7109,7 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 					u8 skey = hd->pLocal->sense[2] & 0x0F;
 					u8 asc = hd->pLocal->sense[12];
 					u8 ascq = hd->pLocal->sense[13];
-					ddvprintk((MYIOC_s_INFO_FMT
+					ddvprintk((MYIOC_s_WARN_FMT
 						"SenseKey:ASC:ASCQ = (%x:%02x:%02x)\n",
 						ioc->name, skey, asc, ascq));
 					if (skey == SK_ILLEGAL_REQUEST) {
@@ -7024,7 +7124,7 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 					} else {
 						/* All other errors are fatal.
 						 */
-						ddvprintk((MYIOC_s_INFO_FMT "DV: fatal error.",
+						ddvprintk((MYIOC_s_WARN_FMT "DV: fatal error.",
 							ioc->name));
 						goto target_done;
 					}
@@ -7050,18 +7150,18 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 	if (echoBufSize > 0) {
 		iocmd.flags |= MPT_ICFLAG_ECHO;
 		if (dataBufSize > 0)
-			bufsize = MIN(echoBufSize, dataBufSize);
+			bufsize = min(echoBufSize, dataBufSize);
 		else
 			bufsize = echoBufSize;
 	} else if (dataBufSize == 0)
 		goto target_done;
 
-	ddvprintk((MYIOC_s_INFO_FMT "%s Buffer Capacity %d\n", ioc->name,
+	ddvprintk((MYIOC_s_WARN_FMT "%s Buffer Capacity %d\n", ioc->name,
 		(iocmd.flags & MPT_ICFLAG_ECHO) ? "Echo" : " ", bufsize));
 
 	/* Data buffers for write-read-compare test max 1K.
 	 */
-	sz = MIN(bufsize, 1024);
+	sz = min(bufsize, 1024);
 
 	/* --- loop ----
 	 * On first pass, always issue a reserve.
@@ -7098,6 +7198,9 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 		}
 		iocmd.flags &= ~MPT_ICFLAG_DID_RESET;
 
+		if (iocmd.flags & MPT_ICFLAG_EBOS)
+			goto skip_Reserve;
+
 		repeat = 5;
 		while (repeat && (!(iocmd.flags & MPT_ICFLAG_RESERVED))) {
 			iocmd.cmd = CMD_Reserve6;
@@ -7118,7 +7221,7 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 					u8 skey = hd->pLocal->sense[2] & 0x0F;
 					u8 asc = hd->pLocal->sense[12];
 					u8 ascq = hd->pLocal->sense[13];
-					ddvprintk((MYIOC_s_INFO_FMT
+					ddvprintk((MYIOC_s_WARN_FMT
 						"DV: Reserve Failed: ", ioc->name));
 					ddvprintk(("SenseKey:ASC:ASCQ = (%x:%02x:%02x)\n",
 							skey, asc, ascq));
@@ -7129,18 +7232,19 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 						mdelay (2000);
 						notDone++;
 					} else {
-						ddvprintk((MYIOC_s_INFO_FMT
+						ddvprintk((MYIOC_s_WARN_FMT
 							"DV: Reserved Failed.", ioc->name));
 						goto target_done;
 					}
 				} else {
-					ddvprintk((MYIOC_s_INFO_FMT "DV: Reserved Failed.",
+					ddvprintk((MYIOC_s_WARN_FMT "DV: Reserved Failed.",
 							 ioc->name));
 					goto target_done;
 				}
 			}
 		}
 
+skip_Reserve:
 		mptscsih_fillbuf(pbuf1, sz, patt, 1);
 		iocmd.cmd = CMD_WriteBuffer;
 		iocmd.data_dma = buf1_dma;
@@ -7180,7 +7284,7 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 				/* Restart data test if UA, else quit.
 				 */
 				u8 skey = hd->pLocal->sense[2] & 0x0F;
-				ddvprintk((MYIOC_s_INFO_FMT
+				ddvprintk((MYIOC_s_WARN_FMT
 					"SenseKey:ASC:ASCQ = (%x:%02x:%02x)\n", ioc->name, skey,
 					hd->pLocal->sense[12], hd->pLocal->sense[13]));
 				if (skey == SK_UNIT_ATTENTION) {
@@ -7276,7 +7380,7 @@ mptscsih_doDv(MPT_SCSI_HOST *hd, int por
 				/* Restart data test if UA, else quit.
 				 */
 				u8 skey = hd->pLocal->sense[2] & 0x0F;
-				ddvprintk((MYIOC_s_INFO_FMT
+				ddvprintk((MYIOC_s_WARN_FMT
 					"SenseKey:ASC:ASCQ = (%x:%02x:%02x)\n", ioc->name, skey,
 					hd->pLocal->sense[12], hd->pLocal->sense[13]));
 				if (skey == SK_UNIT_ATTENTION) {
@@ -7300,13 +7404,13 @@ target_done:
 		iocmd.data = NULL;
 		iocmd.size = 0;
 		if (mptscsih_do_cmd(hd, &iocmd) < 0)
-			printk(MYIOC_s_INFO_FMT "DV: Release failed. id %d",
+			printk(MYIOC_s_WARN_FMT "DV: Release failed. id %d",
 					ioc->name, id);
 		else if (hd->pLocal) {
 			if (hd->pLocal->completion == MPT_SCANDV_GOOD)
 				iocmd.flags &= ~MPT_ICFLAG_RESERVED;
 		} else {
-			printk(MYIOC_s_INFO_FMT "DV: Release failed. id %d",
+			printk(MYIOC_s_WARN_FMT "DV: Release failed. id %d",
 						ioc->name, id);
 		}
 	}
@@ -7314,28 +7418,27 @@ target_done:
 
 	/* Set if cfg1_dma_addr contents is valid
 	 */
-	if ((cfg.hdr != NULL) && (retcode == 0)){
+	if ((cfg.cfghdr.hdr != NULL) && (retcode == 0)){
 		/* If disk, not U320, disable QAS
 		 */
-		if ((inq0 == 0) && (dv.now.factor > MPT_ULTRA320))
+		if ((inq0 == 0) && (dv.now.factor > MPT_ULTRA320)) {
 			hd->ioc->spi_data.noQas = MPT_TARGET_NO_NEGO_QAS;
+			ddvprintk((MYIOC_s_NOTE_FMT "noQas set due to id=%d has factor=%x\n", ioc->name, id, dv.now.factor));
+		}
 
 		dv.cmd = MPT_SAVE;
 		mptscsih_dv_parms(hd, &dv, (void *)pcfg1Data);
 
-#if 0	
-	/* Double writes to SDP1 can cause problems,
-	 * skip here since unnecessary
-	 */
-		/* Save the final negotiated settings to
+		/* Double writes to SDP1 can cause problems,
+		 * skip save of the final negotiated settings to
 		 * SCSI device page 1.
-		 */
-		cfg.hdr = &header1;
+		 *
+		cfg.cfghdr.hdr = &header1;
 		cfg.physAddr = cfg1_dma_addr;
 		cfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;
 		cfg.dir = 1;
 		mpt_config(hd->ioc, &cfg);
-#endif
+		 */
 	}
 
 	/* If this is a RAID Passthrough, enable internal IOs
@@ -7350,8 +7453,8 @@ target_done:
 	if (pDvBuf)
 		pci_free_consistent(ioc->pcidev, dv_alloc, pDvBuf, dvbuf_dma);
 
-	ddvtprintk((MYIOC_s_INFO_FMT "DV Done. IOs outstanding = %d\n",
-			ioc->name, atomic_read(&queue_depth)));
+	ddvtprintk((MYIOC_s_WARN_FMT "DV Done id=%d\n",
+			ioc->name, id));
 
 	return retcode;
 }
@@ -7366,9 +7469,9 @@ target_done:
 static void
 mptscsih_dv_parms(MPT_SCSI_HOST *hd, DVPARAMETERS *dv,void *pPage)
 {
-	VirtDevice		*pTarget = NULL;
-	SCSIDevicePage0_t	*pPage0 = NULL;
-	SCSIDevicePage1_t	*pPage1 = NULL;
+	VirtDevice		*pTarget;
+	SCSIDevicePage0_t	*pPage0;
+	SCSIDevicePage1_t	*pPage1;
 	int			val = 0, data, configuration;
 	u8			width = 0;
 	u8			offset = 0;
@@ -7385,11 +7488,12 @@ mptscsih_dv_parms(MPT_SCSI_HOST *hd, DVP
 		 * If not an LVD bus, the adapter minSyncFactor has been
 		 * already throttled back.
 		 */
+		negoFlags = hd->ioc->spi_data.noQas;
 		if ((hd->Targets)&&((pTarget = hd->Targets[(int)id]) != NULL) && !pTarget->raidVolume) {
 			width = pTarget->maxWidth;
 			offset = pTarget->maxOffset;
 			factor = pTarget->minSyncFactor;
-			negoFlags = pTarget->negoFlags;
+			negoFlags |= pTarget->negoFlags;
 		} else {
 			if (hd->ioc->spi_data.nvram && (hd->ioc->spi_data.nvram[id] != MPT_HOST_NVRAM_INVALID)) {
 				data = hd->ioc->spi_data.nvram[id];
@@ -7410,7 +7514,6 @@ mptscsih_dv_parms(MPT_SCSI_HOST *hd, DVP
 			}
 
 			/* Set the negotiation flags */
-			negoFlags = hd->ioc->spi_data.noQas;
 			if (!width)
 				negoFlags |= MPT_TARGET_NO_NEGO_WIDE;
 
@@ -7419,9 +7522,9 @@ mptscsih_dv_parms(MPT_SCSI_HOST *hd, DVP
 		}
 
 		/* limit by adapter capabilities */
-		width = MIN(width, hd->ioc->spi_data.maxBusWidth);
-		offset = MIN(offset, hd->ioc->spi_data.maxSyncOffset);
-		factor = MAX(factor, hd->ioc->spi_data.minSyncFactor);
+		width = min(width, hd->ioc->spi_data.maxBusWidth);
+		offset = min(offset, hd->ioc->spi_data.maxSyncOffset);
+		factor = max(factor, hd->ioc->spi_data.minSyncFactor);
 
 		/* Check Consistency */
 		if (offset && (factor < MPT_ULTRA2) && !width)
@@ -7431,8 +7534,8 @@ mptscsih_dv_parms(MPT_SCSI_HOST *hd, DVP
 		dv->max.offset = offset;
 		dv->max.factor = factor;
 		dv->max.flags = negoFlags;
-		ddvprintk((" width %d, factor %x, offset %x flags %x\n",
-				width, factor, offset, negoFlags));
+		ddvprintk((" id=%d width=%d factor=%x offset=%x negoFlags=%x\n",
+				id, width, factor, offset, negoFlags));
 		break;
 
 	case MPT_UPDATE_MAX:
@@ -7450,8 +7553,8 @@ mptscsih_dv_parms(MPT_SCSI_HOST *hd, DVP
 		dv->now.width = dv->max.width;
 		dv->now.offset = dv->max.offset;
 		dv->now.factor = dv->max.factor;
-		ddvprintk(("width %d, factor %x, offset %x, flags %x\n",
-				dv->now.width, dv->now.factor, dv->now.offset, dv->now.flags));
+		ddvprintk(("id=%d width=%d factor=%x offset=%x negoFlags=%x\n",
+				id, dv->now.width, dv->now.factor, dv->now.offset, dv->now.flags));
 		break;
 
 	case MPT_SET_MAX:
@@ -7467,14 +7570,15 @@ mptscsih_dv_parms(MPT_SCSI_HOST *hd, DVP
 		if (pPage1) {
 			mptscsih_setDevicePage1Flags (dv->now.width, dv->now.factor,
 				dv->now.offset, &val, &configuration, dv->now.flags);
+			dnegoprintk(("Setting Max: id=%d width=%d factor=%x offset=%x negoFlags=%x request=%x config=%x\n",
+				id, dv->now.width, dv->now.factor, dv->now.offset, dv->now.flags, val, configuration));
 			pPage1->RequestedParameters = le32_to_cpu(val);
 			pPage1->Reserved = 0;
 			pPage1->Configuration = le32_to_cpu(configuration);
-
 		}
 
-		ddvprintk(("width %d, factor %x, offset %x request %x, config %x\n",
-				dv->now.width, dv->now.factor, dv->now.offset, val, configuration));
+		ddvprintk(("id=%d width=%d factor=%x offset=%x negoFlags=%x request=%x configuration=%x\n",
+				id, dv->now.width, dv->now.factor, dv->now.offset, dv->now.flags, val, configuration));
 		break;
 
 	case MPT_SET_MIN:
@@ -7491,12 +7595,14 @@ mptscsih_dv_parms(MPT_SCSI_HOST *hd, DVP
 		if (pPage1) {
 			mptscsih_setDevicePage1Flags (width, factor,
 				offset, &val, &configuration, negoFlags);
+			dnegoprintk(("Setting Min: id=%d width=%d factor=%x offset=%x negoFlags=%x request=%x config=%x\n",
+				id, width, factor, offset, negoFlags, val, configuration));
 			pPage1->RequestedParameters = le32_to_cpu(val);
 			pPage1->Reserved = 0;
 			pPage1->Configuration = le32_to_cpu(configuration);
 		}
-		ddvprintk(("width %d, factor %x, offset %x request %x config %x\n",
-				width, factor, offset, val, configuration));
+		ddvprintk(("id=%d width=%d factor=%x offset=%x request=%x config=%x negoFlags=%x\n",
+				id, width, factor, offset, val, configuration, negoFlags));
 		break;
 
 	case MPT_FALLBACK:
@@ -7514,25 +7620,21 @@ mptscsih_dv_parms(MPT_SCSI_HOST *hd, DVP
 				factor = MPT_ULTRA2;
 				width = MPT_WIDE;
 			} else if ((factor == MPT_ULTRA2) && width) {
-				factor = MPT_ULTRA2;
 				width = MPT_NARROW;
 			} else if (factor < MPT_ULTRA) {
 				factor = MPT_ULTRA;
 				width = MPT_WIDE;
 			} else if ((factor == MPT_ULTRA) && width) {
-				factor = MPT_ULTRA;
 				width = MPT_NARROW;
 			} else if (factor < MPT_FAST) {
 				factor = MPT_FAST;
 				width = MPT_WIDE;
 			} else if ((factor == MPT_FAST) && width) {
-				factor = MPT_FAST;
 				width = MPT_NARROW;
 			} else if (factor < MPT_SCSI) {
 				factor = MPT_SCSI;
 				width = MPT_WIDE;
 			} else if ((factor == MPT_SCSI) && width) {
-				factor = MPT_SCSI;
 				width = MPT_NARROW;
 			} else {
 				factor = MPT_ASYNC;
@@ -7557,6 +7659,7 @@ mptscsih_dv_parms(MPT_SCSI_HOST *hd, DVP
 			factor = MPT_ASYNC;
 		}
 		dv->max.flags |= MPT_TARGET_NO_NEGO_QAS;
+		dv->max.flags &= ~MPT_TAPE_NEGO_IDP;
 
 		dv->now.width = width;
 		dv->now.offset = offset;
@@ -7567,21 +7670,23 @@ mptscsih_dv_parms(MPT_SCSI_HOST *hd, DVP
 		if (pPage1) {
 			mptscsih_setDevicePage1Flags (width, factor, offset, &val,
 						&configuration, dv->now.flags);
+			dnegoprintk(("Finish: id=%d width=%d offset=%d factor=%x negoFlags=%x request=%x config=%x\n",
+			     id, width, offset, factor, dv->now.flags, val, configuration));
 
 			pPage1->RequestedParameters = le32_to_cpu(val);
 			pPage1->Reserved = 0;
 			pPage1->Configuration = le32_to_cpu(configuration);
 		}
 
-		ddvprintk(("Finish: offset %d, factor %x, width %d, request %x config %x\n",
-			     dv->now.offset, dv->now.factor, dv->now.width, val, configuration));
+		ddvprintk(("Finish: id=%d offset=%d factor=%x width=%d request=%x config=%x\n",
+			     id, dv->now.offset, dv->now.factor, dv->now.width, val, configuration));
 		break;
 
 	case MPT_SAVE:
 		ddvprintk((MYIOC_s_NOTE_FMT
 			"Saving to Target structure: ", hd->ioc->name));
-		ddvprintk(("offset %d, factor %x, width %d \n",
-			     dv->now.offset, dv->now.factor, dv->now.width));
+		ddvprintk(("id=%d width=%x factor=%x offset=%d negoFlags=%x\n",
+			     id, dv->now.width, dv->now.factor, dv->now.offset, dv->now.flags));
 
 		/* Save these values to target structures
 		 * or overwrite nvram (phys disks only).
@@ -7745,98 +7850,4 @@ mptscsih_fillbuf(char *buffer, int size,
 		break;
 	}
 }
-#endif /* ~MPTSCSIH_DISABLE_DOMAIN_VALIDATION */
-
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/* Commandline Parsing routines and defines.
- *
- * insmod format:
- *	insmod mptscsih mptscsih="width:1 dv:n factor:0x09"
- *  boot format:
- *	mptscsih=width:1,dv:n,factor:0x8
- *
- */
-#ifdef MODULE
-#define	ARG_SEP	' '
-#else
-#define	ARG_SEP	','
-#endif
-
-static char setup_token[] __initdata =
-	"dv:"
-	"width:"
-	"factor:"
-       ;	/* DONNOT REMOVE THIS ';' */
-
-#define OPT_DV			1
-#define OPT_MAX_WIDTH		2
-#define OPT_MIN_SYNC_FACTOR	3
-
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-static int
-__init get_setup_token(char *p)
-{
-	char *cur = setup_token;
-	char *pc;
-	int i = 0;
-
-	while (cur != NULL && (pc = strchr(cur, ':')) != NULL) {
-		++pc;
-		++i;
-		if (!strncmp(p, cur, pc - cur))
-			return i;
-		cur = pc;
-	}
-	return 0;
-}
-
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-static int
-__init mptscsih_setup(char *str)
-{
-	char *cur = str;
-	char *pc, *pv;
-	unsigned long val;
-	int  c;
-
-	while (cur != NULL && (pc = strchr(cur, ':')) != NULL) {
-		char *pe;
-
-		val = 0;
-		pv = pc;
-		c = *++pv;
-
-		if	(c == 'n')
-			val = 0;
-		else if	(c == 'y')
-			val = 1;
-		else
-			val = (int) simple_strtoul(pv, &pe, 0);
-
-		printk("Found Token: %s, value %x\n", cur, (int)val);
-		switch (get_setup_token(cur)) {
-		case OPT_DV:
-			driver_setup.dv = val;
-			break;
-
-		case OPT_MAX_WIDTH:
-			driver_setup.max_width = val;
-			break;
-
-		case OPT_MIN_SYNC_FACTOR:
-			driver_setup.min_sync_fac = val;
-			break;
-
-		default:
-			printk("mptscsih_setup: unexpected boot option '%.*s' ignored\n", (int)(pc-cur+1), cur);
-			break;
-		}
-
-		if ((cur = strchr(cur, ARG_SEP)) != NULL)
-			++cur;
-	}
-	return 1;
-}
-
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-
+#endif /* ~MPTSCSIH_ENABLE_DOMAIN_VALIDATION */
diff -urNp linux-8145/drivers/message/fusion/mptscsih.h linux-8150/drivers/message/fusion/mptscsih.h
--- linux-8145/drivers/message/fusion/mptscsih.h
+++ linux-8150/drivers/message/fusion/mptscsih.h
@@ -5,22 +5,10 @@
  *          LSIFC9xx/LSI409xx Fibre Channel
  *      running LSI Logic Fusion MPT (Message Passing Technology) firmware.
  *
- *  Credits:
- *      This driver would not exist if not for Alan Cox's development
- *      of the linux i2o driver.
+ *  Copyright (c) 1999-2005 LSI Logic Corporation
+ *  (mailto:mpt_linux_developer@lsil.com)
  *
- *      A huge debt of gratitude is owed to David S. Miller (DaveM)
- *      for fixing much of the stupid and broken stuff in the early
- *      driver while porting to sparc64 platform.  THANK YOU!
- *
- *      (see also mptbase.c)
- *
- *  Copyright (c) 1999-2002 LSI Logic Corporation
- *  Originally By: Steven J. Ralston
- *  (mailto:sjralston1@netscape.net)
- *  (mailto:lstephen@lsil.com)
- *
- *  $Id: mptscsih.h,v 1.22 2002/12/16 15:28:48 pdelaney Exp $
+ *  $Id: mptscsih.h,v 1.1.2.2 2003/05/07 14:08:35 Exp $
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -72,66 +60,28 @@
 /*
  *	Try to keep these at 2^N-1
  */
-#define MPT_FC_CAN_QUEUE	63
+#define MPT_FC_CAN_QUEUE	127
 #if defined MPT_SCSI_USE_NEW_EH
 	#define MPT_SCSI_CAN_QUEUE	127
 #else
 	#define MPT_SCSI_CAN_QUEUE	63
 #endif
 
-#define MPT_SCSI_CMD_PER_DEV_HIGH	31
-#define MPT_SCSI_CMD_PER_DEV_LOW	7
+#define MPT_SCSI_CMD_PER_DEV_HIGH	64
+#define MPT_SCSI_CMD_PER_DEV_LOW	32
 
 #define MPT_SCSI_CMD_PER_LUN		7
 
 #define MPT_SCSI_MAX_SECTORS    8192
 
-/*
- * Set the MAX_SGE value based on user input.
- */
-#ifdef  CONFIG_FUSION_MAX_SGE
-#if     CONFIG_FUSION_MAX_SGE  < 16
-#define MPT_SCSI_SG_DEPTH	16
-#elif   CONFIG_FUSION_MAX_SGE  > 128
-#define MPT_SCSI_SG_DEPTH	128
-#else
-#define MPT_SCSI_SG_DEPTH	CONFIG_FUSION_MAX_SGE
-#endif
-#else
-#define MPT_SCSI_SG_DEPTH	40
-#endif
-
-/* To disable domain validation, uncomment the
+/* To disable domain validation, comment the
  * following line. No effect for FC devices.
  * For SCSI devices, driver will negotiate to
  * NVRAM settings (if available) or to maximum adapter
  * capabilities.
  */
-/* #define MPTSCSIH_DISABLE_DOMAIN_VALIDATION */
-
-
-/* SCSI driver setup structure. Settings can be overridden
- * by command line options.
- */
-#define MPTSCSIH_DOMAIN_VALIDATION      1
-#define MPTSCSIH_MAX_WIDTH              1
-#define MPTSCSIH_MIN_SYNC               0x08
-
-struct mptscsih_driver_setup
-{
-        u8      dv;
-        u8      max_width;
-        u8      min_sync_fac;
-};
-
-
-#define MPTSCSIH_DRIVER_SETUP                   \
-{                                               \
-        MPTSCSIH_DOMAIN_VALIDATION,             \
-        MPTSCSIH_MAX_WIDTH,                     \
-        MPTSCSIH_MIN_SYNC,                      \
-}
 
+#define MPTSCSIH_ENABLE_DOMAIN_VALIDATION
 
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -150,10 +100,6 @@ struct mptscsih_driver_setup
 #define MPT_SCSIHOST_NEED_ENTRY_EXIT_HOOKUPS			1
 #if LINUX_VERSION_CODE <= KERNEL_VERSION(2,4,0)
 #	if LINUX_VERSION_CODE == KERNEL_VERSION(2,4,0)
-		/*
-		 *	Super HACK!  -by sralston:-(
-		 *	(good grief; heaven help me!)
-		 */
 #		include <linux/capability.h>
 #		if !defined(CAP_LEASE) && !defined(MODULE)
 #			undef MPT_SCSIHOST_NEED_ENTRY_EXIT_HOOKUPS
@@ -164,44 +110,6 @@ struct mptscsih_driver_setup
 #		endif
 #	endif
 #endif
-
-/*
- *	tq_scheduler disappeared @ lk-2.4.0-test12
- *	(right when <linux/sched.h> newly defined TQ_ACTIVE)
- *	tq_struct reworked in 2.5.41. Include workqueue.h.
- */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,41)
-#	include <linux/sched.h>
-#	include <linux/workqueue.h>
-#define SCHEDULE_TASK(x)		\
-	if (schedule_work(x) == 0) {	\
-		/*MOD_DEC_USE_COUNT*/;	\
-	}
-#else
-#define HAVE_TQ_SCHED	1
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-#	include <linux/sched.h>
-#	ifdef TQ_ACTIVE
-#		undef HAVE_TQ_SCHED
-#	endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,40)
-#		undef HAVE_TQ_SCHED
-#endif
-#endif
-#ifdef HAVE_TQ_SCHED
-#define SCHEDULE_TASK(x)		\
-	/*MOD_INC_USE_COUNT*/;		\
-	(x)->next = NULL;		\
-	queue_task(x, &tq_scheduler)
-#else
-#define SCHEDULE_TASK(x)		\
-	/*MOD_INC_USE_COUNT*/;		\
-	if (schedule_task(x) == 0) {	\
-		/*MOD_DEC_USE_COUNT*/;	\
-	}
-#endif
-#endif
-
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
 #define x_scsi_detect		mptscsih_detect
@@ -217,11 +125,7 @@ struct mptscsih_driver_setup
 #define x_scsi_taskmgmt_bh	mptscsih_taskmgmt_bh
 #define x_scsi_old_abort	mptscsih_old_abort
 #define x_scsi_old_reset	mptscsih_old_reset
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,44)
-#define x_scsi_slave_attach	mptscsih_slave_attach
-#else
 #define x_scsi_select_queue_depths	mptscsih_select_queue_depths
-#endif
 #define x_scsi_proc_info	mptscsih_proc_info
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -241,86 +145,18 @@ extern	int		 x_scsi_host_reset(Scsi_Cmnd
 extern	int		 x_scsi_old_abort(Scsi_Cmnd *);
 extern	int		 x_scsi_old_reset(Scsi_Cmnd *, unsigned int);
 #endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,45)
-extern int		 x_scsi_bios_param(struct scsi_device * sdev, struct block_device *bdev,
-				sector_t capacity, int *ip);
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,28)
-extern	int		 x_scsi_bios_param(Disk *, struct block_device *, int *);
-#else
 extern	int		 x_scsi_bios_param(Disk *, kdev_t, int *);
-#endif
 extern	void		 x_scsi_taskmgmt_bh(void *);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,44)
-extern	int		 x_scsi_slave_attach(Scsi_Device *);
-#else
 extern	void		 x_scsi_select_queue_depths(struct Scsi_Host *, Scsi_Device *);
-#endif
-
 extern	int		 x_scsi_proc_info(char *, char **, off_t, int, int, int);
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
 #define PROC_SCSI_DECL
 #else
-#define PROC_SCSI_DECL  proc_name: "mptscsih",
+#define PROC_SCSI_DECL  .proc_name = "mptscsih",
 #endif
 
 #ifdef MPT_SCSI_USE_NEW_EH
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,44)
-
-#define MPT_SCSIHOST {						\
-	PROC_SCSI_DECL						\
-	.proc_info			= x_scsi_proc_info,	\
-	.name				= "MPT SCSI Host",	\
-	.detect				= x_scsi_detect,	\
-	.release			= x_scsi_release,	\
-	.info				= x_scsi_info,		\
-	.command			= NULL,			\
-	.queuecommand			= x_scsi_queuecommand,	\
-	.slave_attach			= x_scsi_slave_attach,	\
-	.eh_strategy_handler		= NULL,			\
-	.eh_abort_handler		= x_scsi_abort,		\
-	.eh_device_reset_handler	= x_scsi_dev_reset,	\
-	.eh_bus_reset_handler		= x_scsi_bus_reset,	\
-	.eh_host_reset_handler		= x_scsi_host_reset,	\
-	.bios_param			= x_scsi_bios_param,	\
-	.can_queue			= MPT_SCSI_CAN_QUEUE,	\
-	.this_id			= -1,			\
-	.sg_tablesize			= MPT_SCSI_SG_DEPTH,	\
-	.max_sectors			= MPT_SCSI_MAX_SECTORS,	\
-	.cmd_per_lun			= MPT_SCSI_CMD_PER_LUN,	\
-	.unchecked_isa_dma		= 0,			\
-	.use_clustering			= ENABLE_CLUSTERING,	\
-}
-
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,1)
-
-#define MPT_SCSIHOST {						\
-	PROC_SCSI_DECL						\
-	.proc_info			= x_scsi_proc_info,	\
-	.name				= "MPT SCSI Host",	\
-	.detect				= x_scsi_detect,	\
-	.release			= x_scsi_release,	\
-	.info				= x_scsi_info,		\
-	.command			= NULL,			\
-	.queuecommand			= x_scsi_queuecommand,	\
-	.eh_strategy_handler		= NULL,			\
-	.eh_abort_handler		= x_scsi_abort,		\
-	.eh_device_reset_handler	= x_scsi_dev_reset,	\
-	.eh_bus_reset_handler		= x_scsi_bus_reset,	\
-	.eh_host_reset_handler		= x_scsi_host_reset,	\
-	.bios_param			= x_scsi_bios_param,	\
-	.can_queue			= MPT_SCSI_CAN_QUEUE,	\
-	.this_id			= -1,			\
-	.sg_tablesize			= MPT_SCSI_SG_DEPTH,	\
-	.max_sectors			= MPT_SCSI_MAX_SECTORS,	\
-	.cmd_per_lun			= MPT_SCSI_CMD_PER_LUN,	\
-	.unchecked_isa_dma		= 0,			\
-	.use_clustering			= ENABLE_CLUSTERING,	\
-}
-
-#else  /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,1) */
-
 #define MPT_SCSIHOST {						\
 	.next				= NULL,			\
 	PROC_SCSI_DECL						\
@@ -346,8 +182,6 @@ extern	int		 x_scsi_proc_info(char *, ch
 	.use_new_eh_code		= 1			\
 }
 
-#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,1) */
-
 #else /* MPT_SCSI_USE_NEW_EH */
 
 #define MPT_SCSIHOST {						\
diff -urNp linux-8145/drivers/message/fusion/scsi3.h linux-8150/drivers/message/fusion/scsi3.h
--- linux-8145/drivers/message/fusion/scsi3.h
+++ linux-8150/drivers/message/fusion/scsi3.h
@@ -4,12 +4,10 @@
  *      (Ultimately) SCSI-3 definitions; for now, inheriting
  *      SCSI-2 definitions.
  *
- *  Copyright (c) 1996-2002 Steven J. Ralston
- *  Written By: Steven J. Ralston (19960517)
- *  (mailto:sjralston1@netscape.net)
- *  (mailto:lstephen@lsil.com)
+ *  Copyright (c) 1996-2005 LSI Logic
+ *  (mailto:mpt_linux_developer@lsil.com)
  *
- *  $Id: scsi3.h,v 1.9 2002/02/27 18:45:02 sralston Exp $
+ *  $Id: scsi3.h,v 1.9 2002/02/27 18:45:02 Exp $
  */
 
 #ifndef SCSI3_H_INCLUDED
@@ -55,8 +53,8 @@
 #define CMD_Reserve6           0x16
 #define CMD_Release6           0x17
 #define CMD_Erase              0x19
-#define CMD_StartStopUnit      0x1b  /* direct-access devices */
-#define CMD_LoadUnload         0x1b  /* sequential-access devices */
+#define CMD_StartStopUnit      0x1B  /* direct-access devices */
+#define CMD_LoadUnload         0x1B  /* sequential-access devices */
 #define CMD_ReceiveDiagnostic  0x1C
 #define CMD_SendDiagnostic     0x1D
 #define CMD_ReadCapacity       0x25
@@ -69,6 +67,8 @@
 #define CMD_WriteBuffer        0x3B
 #define CMD_ReadBuffer         0x3C
 #define CMD_ReadLong           0x3E
+#define CMD_WriteLong          0x3F
+#define CMD_WriteSame          0x41
 #define CMD_LogSelect          0x4C
 #define CMD_LogSense           0x4D
 #define CMD_ModeSelect10       0x55
@@ -77,7 +77,16 @@
 #define CMD_ModeSense10        0x5A
 #define CMD_PersistReserveIn   0x5E
 #define CMD_PersistReserveOut  0x5F
+#define CMD_Read16             0x88
+#define CMD_Write16            0x8A
+#define CMD_WriteVerify16      0x8E
+#define CMD_WriteSame16        0x93
+#define CMD_ServiceActionIn    0x9E
+#define CMD_ServiceActionOut   0x9F
 #define CMD_ReportLuns         0xA0
+#define CMD_Read12             0xA8
+#define CMD_Write12            0xAA
+#define CMD_WriteVerify12      0xAE
 
 /*
  *    Control byte field
