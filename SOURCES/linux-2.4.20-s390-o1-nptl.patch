diff -urNp linux-420/arch/s390/kernel/entry.S linux-422/arch/s390/kernel/entry.S
--- linux-420/arch/s390/kernel/entry.S
+++ linux-422/arch/s390/kernel/entry.S
@@ -573,7 +573,23 @@ sys_call_table:
 	.long  sys_ni_syscall		 /* 235 - reserved for fremovexattr */
 	.long  sys_gettid
 	.long  sys_tkill
-	.rept  255-237
+	.long  s390_futex
+	.long  sys_sched_setaffinity
+	.long  sys_sched_getaffinity	 /* 240 */
+	.long  sys_tgkill
+	.long  sys_ni_syscall
+	.long  sys_ni_syscall
+	.long  sys_ni_syscall
+	.long  sys_ni_syscall		 /* 245 */
+	.long  sys_ni_syscall
+	.long  sys_ni_syscall
+	.long  sys_exit_group
+	.long  sys_ni_syscall
+	.long  sys_ni_syscall		 /* 250 */
+	.long  sys_ni_syscall
+	.long  sys_set_tid_address
+	.long  sys_ni_syscall
+	.rept  255-253
 	.long  sys_ni_syscall
 	.endr
 
diff -urNp linux-420/arch/s390/kernel/init_task.c linux-422/arch/s390/kernel/init_task.c
--- linux-420/arch/s390/kernel/init_task.c
+++ linux-422/arch/s390/kernel/init_task.c
@@ -14,7 +14,8 @@
 
 static struct fs_struct init_fs = INIT_FS;
 static struct files_struct init_files = INIT_FILES;
-static struct signal_struct init_signals = INIT_SIGNALS;
+static struct signal_struct init_signals = INIT_SIGNALS(init_signals);
+static struct sighand_struct init_sighand = INIT_SIGHAND(init_sighand);
 struct mm_struct init_mm = INIT_MM(init_mm);
 
 /*
diff -urNp linux-420/arch/s390/kernel/process.c linux-422/arch/s390/kernel/process.c
--- linux-420/arch/s390/kernel/process.c
+++ linux-422/arch/s390/kernel/process.c
@@ -90,6 +90,7 @@ void show_regs(struct pt_regs *regs)
 {
 	struct task_struct *tsk = current;
 
+	print_modules();
         printk("CPU:    %d    %s\n", tsk->cpu, print_tainted());
         printk("Process %s (pid: %d, task: %08lx, ksp: %08x)\n",
 	       current->comm, current->pid, (unsigned long) tsk,
@@ -103,7 +104,7 @@ void show_regs(struct pt_regs *regs)
 
 int arch_kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
 {
-        int clone_arg = flags | CLONE_VM;
+        int clone_arg = flags | CLONE_VM | CLONE_UNTRACED;
         int retval;
 
         __asm__ __volatile__(
@@ -165,7 +166,9 @@ int copy_thread(int nr, unsigned long cl
 
         frame = (struct stack_frame *) (2*PAGE_SIZE + (unsigned long) p) -1;
         p->thread.ksp = (unsigned long) frame;
+	p->set_child_tid = p->clear_child_tid = NULL;
         memcpy(&frame->childregs,regs,sizeof(struct pt_regs));
+	frame->childregs.gprs[2] = 0;	/* child returns 0 on fork. */
         frame->childregs.gprs[15] = new_stackp;
         frame->back_chain = frame->eos = 0;
 
@@ -181,24 +184,32 @@ int copy_thread(int nr, unsigned long cl
 	p->thread.ar4 = get_fs().ar4;
         /* Don't copy debug registers */
         memset(&p->thread.per_info,0,sizeof(p->thread.per_info));
+
+	/* Set a new TLS ?  */
+	if (clone_flags & CLONE_SETTLS)
+		frame->childregs.acrs[0] = regs->gprs[6];
         return 0;
 }
 
 asmlinkage int sys_fork(struct pt_regs regs)
 {
-        return do_fork(SIGCHLD, regs.gprs[15], &regs, 0);
+        return do_fork(SIGCHLD, regs.gprs[15], &regs, 0, NULL, NULL);
 }
 
 asmlinkage int sys_clone(struct pt_regs regs)
 {
         unsigned long clone_flags;
         unsigned long newsp;
+	int *parent_tidptr, *child_tidptr;
 
         clone_flags = regs.gprs[3];
         newsp = regs.orig_gpr2;
+	parent_tidptr = (int *) regs.gprs[4];
+	child_tidptr = (int *) regs.gprs[5];
         if (!newsp)
                 newsp = regs.gprs[15];
-        return do_fork(clone_flags, newsp, &regs, 0);
+        return do_fork(clone_flags & ~CLONE_IDLETASK, newsp, &regs, 0,
+		       parent_tidptr, child_tidptr);
 }
 
 /*
@@ -214,7 +225,7 @@ asmlinkage int sys_clone(struct pt_regs 
 asmlinkage int sys_vfork(struct pt_regs regs)
 {
 	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD,
-                       regs.gprs[15], &regs, 0);
+		       regs.gprs[15], &regs, 0, NULL, NULL);
 }
 
 /*
diff -urNp linux-420/arch/s390/kernel/ptrace.c linux-422/arch/s390/kernel/ptrace.c
--- linux-420/arch/s390/kernel/ptrace.c
+++ linux-422/arch/s390/kernel/ptrace.c
@@ -262,7 +262,7 @@ asmlinkage int sys_ptrace(long request, 
 			if (request != PTRACE_KILL)
 				goto out_tsk;
 		}
-		if (child->p_pptr != current)
+		if (child->parent != current)
 			goto out_tsk;
 	}
 	switch (request) 
@@ -349,11 +349,11 @@ asmlinkage int sys_ptrace(long request, 
 		else ret = -EFAULT;
 		break;
 	default:
-		ret = -EIO;
+		ret = ptrace_request(child, request, addr, data);
 		break;
 	}
  out_tsk:
-	free_task_struct(child);
+	put_task_struct(child);
  out:
 	unlock_kernel();
 	return ret;
@@ -378,6 +378,7 @@ asmlinkage void syscall_trace(void)
 		send_sig(current->exit_code, current, 1);
 		current->exit_code = 0;
 	}
+	recalc_sigpending();
  out:
 	unlock_kernel();
 }
diff -urNp linux-420/arch/s390/kernel/signal.c linux-422/arch/s390/kernel/signal.c
--- linux-420/arch/s390/kernel/signal.c
+++ linux-422/arch/s390/kernel/signal.c
@@ -93,11 +93,11 @@ sys_sigsuspend(struct pt_regs * regs,int
 	sigset_t saveset;
 
 	mask &= _BLOCKABLE;
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	saveset = current->blocked;
 	siginitset(&current->blocked, mask);
-	recalc_sigpending(current);
-	spin_unlock_irq(&current->sigmask_lock);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
 	regs->gprs[2] = -EINTR;
 
 	while (1) {
@@ -121,11 +121,11 @@ sys_rt_sigsuspend(struct pt_regs * regs,
 		return -EFAULT;
 	sigdelsetmask(&newset, ~_BLOCKABLE);
 
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	saveset = current->blocked;
 	current->blocked = newset;
-	recalc_sigpending(current);
-	spin_unlock_irq(&current->sigmask_lock);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
 	regs->gprs[2] = -EINTR;
 
 	while (1) {
@@ -223,10 +223,10 @@ asmlinkage long sys_sigreturn(struct pt_
 		goto badframe;
 
 	sigdelsetmask(&set, ~_BLOCKABLE);
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	current->blocked = set;
-	recalc_sigpending(current);
-	spin_unlock_irq(&current->sigmask_lock);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
 
 	if (restore_sigregs(regs, &frame->sregs))
 		goto badframe;
@@ -249,10 +249,10 @@ asmlinkage long sys_rt_sigreturn(struct 
 		goto badframe;
 
 	sigdelsetmask(&set, ~_BLOCKABLE);
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	current->blocked = set;
-	recalc_sigpending(current);
-	spin_unlock_irq(&current->sigmask_lock);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
 
 	if (restore_sigregs(regs, &frame->uc.uc_mcontext))
 		goto badframe;
@@ -417,9 +417,11 @@ give_sigsegv:
  */	
 
 static void
-handle_signal(unsigned long sig, struct k_sigaction *ka,
+handle_signal(unsigned long sig,
 	      siginfo_t *info, sigset_t *oldset, struct pt_regs * regs)
 {
+	struct k_sigaction *ka = &current->sighand->action[sig-1];
+
 	/* Are we from a system call? */
 	if (regs->trap == __LC_SVC_OLD_PSW) {
 		/* If so, check system call restarting.. */
@@ -450,14 +452,16 @@ handle_signal(unsigned long sig, struct 
 		ka->sa.sa_handler = SIG_DFL;
 
 	if (!(ka->sa.sa_flags & SA_NODEFER)) {
-		spin_lock_irq(&current->sigmask_lock);
+		spin_lock_irq(&current->sighand->siglock);
 		sigorsets(&current->blocked,&current->blocked,&ka->sa.sa_mask);
 		sigaddset(&current->blocked,sig);
-		recalc_sigpending(current);
-		spin_unlock_irq(&current->sigmask_lock);
+		recalc_sigpending();
+		spin_unlock_irq(&current->sighand->siglock);
 	}
 }
 
+int print_fatal_signals;
+
 /*
  * Note that 'init' is a special process: it doesn't get signals it doesn't
  * want to handle. Thus you cannot kill init even with a SIGKILL even by
@@ -470,7 +474,7 @@ handle_signal(unsigned long sig, struct 
 int do_signal(struct pt_regs *regs, sigset_t *oldset)
 {
 	siginfo_t info;
-	struct k_sigaction *ka;
+	int signr;
 
 	/*
 	 * We want the common case to go fast, which
@@ -484,100 +488,11 @@ int do_signal(struct pt_regs *regs, sigs
 	if (!oldset)
 		oldset = &current->blocked;
 
-	for (;;) {
-		unsigned long signr;
-
-		spin_lock_irq(&current->sigmask_lock);
-		signr = dequeue_signal(&current->blocked, &info);
-		spin_unlock_irq(&current->sigmask_lock);
-
-		if (!signr)
-			break;
-
-		if ((current->ptrace & PT_PTRACED) && signr != SIGKILL) {
-			/* Let the debugger run.  */
-			current->exit_code = signr;
-			set_current_state(TASK_STOPPED);
-			notify_parent(current, SIGCHLD);
-			schedule();
-
-			/* We're back.  Did the debugger cancel the sig?  */
-			if (!(signr = current->exit_code))
-				continue;
-			current->exit_code = 0;
-
-			/* The debugger continued.  Ignore SIGSTOP.  */
-			if (signr == SIGSTOP)
-				continue;
-
-			/* Update the siginfo structure.  Is this good?  */
-			if (signr != info.si_signo) {
-				info.si_signo = signr;
-				info.si_errno = 0;
-				info.si_code = SI_USER;
-				info.si_pid = current->p_pptr->pid;
-				info.si_uid = current->p_pptr->uid;
-			}
-
-			/* If the (new) signal is now blocked, requeue it.  */
-			if (sigismember(&current->blocked, signr)) {
-				send_sig_info(signr, &info, current);
-				continue;
-			}
-		}
-
-		ka = &current->sig->action[signr-1];
-		if (ka->sa.sa_handler == SIG_IGN) {
-			if (signr != SIGCHLD)
-				continue;
-			/* Check for SIGCHLD: it's special.  */
-			while (sys_wait4(-1, NULL, WNOHANG, NULL) > 0)
-				/* nothing */;
-			continue;
-		}
-
-		if (ka->sa.sa_handler == SIG_DFL) {
-			int exit_code = signr;
-
-			/* Init gets no signals it doesn't want.  */
-			if (current->pid == 1)
-				continue;
-
-			switch (signr) {
-			case SIGCONT: case SIGCHLD: case SIGWINCH: case SIGURG:
-				continue;
-
-			case SIGTSTP: case SIGTTIN: case SIGTTOU:
-				if (is_orphaned_pgrp(current->pgrp))
-					continue;
-				/* FALLTHRU */
-
-			case SIGSTOP: {
-				struct signal_struct *sig;
-				set_current_state(TASK_STOPPED);
-				current->exit_code = signr;
-				sig = current->p_pptr->sig;
-				if (sig && !(sig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))
-					notify_parent(current, SIGCHLD);
-				schedule();
-				continue;
-			}
-
-			case SIGQUIT: case SIGILL: case SIGTRAP:
-			case SIGABRT: case SIGFPE: case SIGSEGV:
-			case SIGBUS: case SIGSYS: case SIGXCPU: case SIGXFSZ:
-                                if (do_coredump(signr, regs))
-                                        exit_code |= 0x80;
-                                /* FALLTHRU */
-
-			default:
-				sig_exit(signr, exit_code, &info);
-				/* NOTREACHED */
-			}
-		}
+	signr = get_signal_to_deliver(&info, regs);
+	if (signr > 0) {
 
 		/* Whee!  Actually deliver the signal.  */
-		handle_signal(signr, ka, &info, oldset, regs);
+		handle_signal(signr, &info, oldset, regs);
 		return 1;
 	}
 
diff -urNp linux-420/arch/s390/kernel/smp.c linux-422/arch/s390/kernel/smp.c
--- linux-420/arch/s390/kernel/smp.c
+++ linux-422/arch/s390/kernel/smp.c
@@ -47,9 +47,8 @@ extern volatile int __cpu_logical_map[];
  * An array with a pointer the lowcore of every CPU.
  */
 static int       max_cpus = NR_CPUS;	  /* Setup configured maximum number of CPUs to activate	*/
-int              smp_num_cpus;
+int              smp_num_cpus = 1;
 struct _lowcore *lowcore_ptr[NR_CPUS];
-cycles_t         cacheflush_time=0;
 int              smp_threads_ready=0;      /* Set when the idlers are all forked. */
 static atomic_t  smp_commenced = ATOMIC_INIT(0);
 
@@ -522,13 +521,13 @@ void __init initialize_secondary(void)
 {
 }
 
-static int __init fork_by_hand(void)
+static struct task_struct * __init fork_by_hand(void)
 {
        struct pt_regs regs;
        /* don't care about the psw and regs settings since we'll never
           reschedule the forked task. */
        memset(&regs,0,sizeof(struct pt_regs));
-       return do_fork(CLONE_VM|CLONE_PID, 0, &regs, 0);
+       return copy_process(CLONE_VM|CLONE_IDLETASK, 0, &regs, 0, NULL, NULL);
 }
 
 static void __init do_boot_cpu(int cpu)
@@ -538,16 +537,12 @@ static void __init do_boot_cpu(int cpu)
 
         /* We can't use kernel_thread since we must _avoid_ to reschedule
            the child. */
-        if (fork_by_hand() < 0)
+        idle = fork_by_hand();
+	if (IS_ERR(idle))
                 panic("failed fork for CPU %d", cpu);
 
-        /*
-         * We remove it from the pidhash and the runqueue
-         * once we got the process:
-         */
-        idle = init_task.prev_task;
-        if (!idle)
-                panic("No idle process for CPU %d",cpu);
+	wake_up_forked_process(idle);
+
 	init_idle(idle, cpu);
 
         unhash_process(idle);
diff -urNp linux-420/arch/s390/kernel/sys_s390.c linux-422/arch/s390/kernel/sys_s390.c
--- linux-420/arch/s390/kernel/sys_s390.c
+++ linux-422/arch/s390/kernel/sys_s390.c
@@ -24,6 +24,7 @@
 #include <linux/mman.h>
 #include <linux/file.h>
 #include <linux/utsname.h>
+#include <linux/futex.h>
 
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
@@ -241,15 +242,16 @@ asmlinkage int sys_olduname(struct oldol
 	return error;
 }
 
-asmlinkage int sys_pause(void)
-{
-	set_current_state(TASK_INTERRUPTIBLE);
-	schedule();
-	return -ERESTARTNOHAND;
-}
-
 asmlinkage int sys_ioperm(unsigned long from, unsigned long num, int on)
 {
   return -ENOSYS;
 }
 
+asmlinkage int s390_futex(u32 *uaddr, int op, int val,
+	struct timespec *utime, u32 *uaddr2)
+{
+	struct pt_regs *regs;
+
+	regs = __KSTK_PTREGS(current);
+	return sys_futex(uaddr, op, val, utime, uaddr2, regs->gprs[7]);
+}
diff -urNp linux-420/arch/s390/kernel/traps.c linux-422/arch/s390/kernel/traps.c
--- linux-420/arch/s390/kernel/traps.c
+++ linux-422/arch/s390/kernel/traps.c
@@ -138,12 +138,14 @@ void show_trace(unsigned long * stack)
 
 void show_trace_task(struct task_struct *tsk)
 {
+#if 0 /* Mingo's scheduler kills task_has_cpu, so we bite the bullet. */
 	/*
 	 * We can't print the backtrace of a running process. It is
 	 * unreliable at best and can cause kernel oopses.
 	 */
 	if (tsk->state == TASK_RUNNING)
 		return;
+#endif
 	show_trace((unsigned long *) tsk->thread.ksp);
 }
 
diff -urNp linux-420/arch/s390x/kernel/entry.S linux-422/arch/s390x/kernel/entry.S
--- linux-420/arch/s390x/kernel/entry.S
+++ linux-422/arch/s390x/kernel/entry.S
@@ -256,6 +256,12 @@ sys_clone_glue: 
         la      %r2,SP_PTREGS(%r15)    # load pt_regs
         jg      sys_clone              # branch to sys_clone
 
+#ifdef CONFIG_S390_SUPPORT
+sys32_clone_glue: 
+        la      %r2,SP_PTREGS(%r15)    # load pt_regs
+        jg      sys32_clone            # branch to sys32_clone
+#endif
+
 sys_fork_glue:  
         la      %r2,SP_PTREGS(%r15)    # load pt_regs
         jg      sys_fork               # branch to sys_fork
@@ -487,7 +493,7 @@ sys_call_table:
         .long  SYSCALL(sys_ipc,sys32_ipc_wrapper)
         .long  SYSCALL(sys_fsync,sys32_fsync_wrapper)
         .long  SYSCALL(sys_sigreturn_glue,sys32_sigreturn_glue)
-        .long  SYSCALL(sys_clone_glue,sys_clone_glue) /* 120 */
+        .long  SYSCALL(sys_clone_glue,sys32_clone_glue) /* 120 */
         .long  SYSCALL(sys_setdomainname,sys32_setdomainname_wrapper)
         .long  SYSCALL(s390x_newuname,sys32_newuname_wrapper)
         .long  SYSCALL(sys_ni_syscall,sys_ni_syscall) /* modify_ldt for i386 */
@@ -605,7 +611,23 @@ sys_call_table:
 	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall) /* 235 - reserved for fremovexattr */
 	.long  SYSCALL(sys_gettid,sys_gettid)
 	.long  SYSCALL(sys_tkill,sys_tkill)
-	.rept  255-237
+	.long  SYSCALL(s390_futex,sys32_futex_wrapper)
+	.long  SYSCALL(sys_sched_setaffinity,sys32_sched_setaffinity_wrapper)
+	.long  SYSCALL(sys_sched_getaffinity,sys32_sched_getaffinity_wrapper) /* 240 */
+	.long  SYSCALL(sys_tgkill,sys32_tgkill_wrapper)
+	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall)
+	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall)
+	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall)
+	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall)	/* 245 */
+	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall)
+	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall)
+	.long  SYSCALL(sys_exit_group,sys32_exit_group_wrapper)
+	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall)
+	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall)	/* 250 */
+	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall)
+	.long  SYSCALL(sys_set_tid_address,sys32_set_tid_address_wrapper)
+	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall)
+	.rept  255-253
 	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall)
 	.endr
 
diff -urNp linux-420/arch/s390x/kernel/init_task.c linux-422/arch/s390x/kernel/init_task.c
--- linux-420/arch/s390x/kernel/init_task.c
+++ linux-422/arch/s390x/kernel/init_task.c
@@ -14,7 +14,8 @@
 
 static struct fs_struct init_fs = INIT_FS;
 static struct files_struct init_files = INIT_FILES;
-static struct signal_struct init_signals = INIT_SIGNALS;
+static struct signal_struct init_signals = INIT_SIGNALS(init_signals);
+static struct sighand_struct init_sighand = INIT_SIGHAND(init_sighand);
 struct mm_struct init_mm = INIT_MM(init_mm);
 
 /*
diff -urNp linux-420/arch/s390x/kernel/linux32.c linux-422/arch/s390x/kernel/linux32.c
--- linux-420/arch/s390x/kernel/linux32.c
+++ linux-422/arch/s390x/kernel/linux32.c
@@ -2118,30 +2118,34 @@ sys32_rt_sigtimedwait(sigset_t32 *uthese
 			return -EINVAL;
 	}
 
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	sig = dequeue_signal(&these, &info);
 	if (!sig) {
-		/* None ready -- temporarily unblock those we're interested
-		   in so that we'll be awakened when they arrive.  */
-		sigset_t oldblocked = current->blocked;
-		sigandsets(&current->blocked, &current->blocked, &these);
-		recalc_sigpending(current);
-		spin_unlock_irq(&current->sigmask_lock);
-
 		timeout = MAX_SCHEDULE_TIMEOUT;
 		if (uts)
 			timeout = (timespec_to_jiffies(&ts)
 				   + (ts.tv_sec || ts.tv_nsec));
 
-		current->state = TASK_INTERRUPTIBLE;
-		timeout = schedule_timeout(timeout);
-
-		spin_lock_irq(&current->sigmask_lock);
-		sig = dequeue_signal(&these, &info);
-		current->blocked = oldblocked;
-		recalc_sigpending(current);
+		if (timeout) {
+			/* None ready -- temporarily unblock those we're
+			 * interested while we are sleeping in so that we'll
+			 * be awakened when they arrive.  */
+			current->real_blocked = current->blocked;
+			sigandsets(&current->blocked, &current->blocked, &these);
+			recalc_sigpending();
+			spin_unlock_irq(&current->sighand->siglock);
+
+			current->state = TASK_INTERRUPTIBLE;
+			timeout = schedule_timeout(timeout);
+
+			spin_lock_irq(&current->sighand->siglock);
+			sig = dequeue_signal(&these, &info);
+			current->blocked = current->real_blocked;
+			siginitset(&current->real_blocked, 0);
+			recalc_sigpending();
+		}
 	}
-	spin_unlock_irq(&current->sigmask_lock);
+	spin_unlock_irq(&current->sighand->siglock);
 
 	if (sig) {
 		ret = sig;
@@ -4693,3 +4697,33 @@ asmlinkage ssize_t32 sys32_write(unsigne
 
 	return sys_write(fd, buf, count);
 }
+asmlinkage ssize_t sys_read(unsigned int fd, char * buf, size_t count);
+asmlinkage ssize_t sys_write(unsigned int fd, const char * buf, size_t count);
+
+asmlinkage int sys32_clone(struct pt_regs regs)
+{
+        unsigned long clone_flags;
+        unsigned long newsp;
+	int *parent_tidptr, *child_tidptr;
+
+        clone_flags = regs.gprs[3] & 0xffffffffUL;
+        newsp = regs.orig_gpr2 & 0x7fffffffUL;
+	parent_tidptr = (int *) (regs.gprs[4] & 0x7fffffffUL);
+	child_tidptr = (int *) (regs.gprs[5] & 0x7fffffffUL);
+        if (!newsp)
+                newsp = regs.gprs[15];
+	return do_fork(clone_flags & ~CLONE_IDLETASK, newsp, &regs, 0,
+	  	       parent_tidptr, child_tidptr);
+}
+
+asmlinkage int compat_sys_futex(u32 *uaddr, int op, int val,
+                struct compat_timespec *utime, u32 *uaddr2, int val3);
+
+asmlinkage long sys32_futex(u32 *uaddr, int op, int val,
+	struct compat_timespec *utime, u32 *uaddr2)
+{
+	struct pt_regs *regs;
+
+	regs = __KSTK_PTREGS(current);
+	return compat_sys_futex(uaddr, op, val, utime, uaddr2, regs->gprs[7]);
+}
diff -urNp linux-420/arch/s390x/kernel/process.c linux-422/arch/s390x/kernel/process.c
--- linux-420/arch/s390x/kernel/process.c
+++ linux-422/arch/s390x/kernel/process.c
@@ -88,9 +88,10 @@ void show_regs(struct pt_regs *regs)
 	struct task_struct *tsk = current;
 
         printk("CPU:    %d    %s\n", tsk->cpu, print_tainted());
-        printk("Process %s (pid: %d, task: %016lx, ksp: %016lx)\n",
+	print_modules();
+        printk("Process %s (pid: %d, task: %016lx, ksp: %016lx, f: %lx)\n",
 	       current->comm, current->pid, (unsigned long) tsk,
-	       tsk->thread.ksp);
+	       tsk->thread.ksp, (long)tsk->thread.flags);
 
 	show_registers(regs);
 	/* Show stack backtrace if pt_regs is from kernel mode */
@@ -100,7 +101,7 @@ void show_regs(struct pt_regs *regs)
 
 int arch_kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
 {
-        int clone_arg = flags | CLONE_VM;
+        int clone_arg = flags | CLONE_VM | CLONE_UNTRACED;
         int retval;
 
         __asm__ __volatile__(
@@ -162,7 +163,9 @@ int copy_thread(int nr, unsigned long cl
 
         frame = (struct stack_frame *) (4*PAGE_SIZE + (unsigned long) p) -1;
         p->thread.ksp = (unsigned long) frame;
+	p->set_child_tid = p->clear_child_tid = NULL;
         frame->childregs = *regs;
+	frame->childregs.gprs[2] = 0;	/* child returns 0 on fork. */
         frame->childregs.gprs[15] = new_stackp;
         frame->back_chain = frame->eos = 0;
 
@@ -178,6 +181,19 @@ int copy_thread(int nr, unsigned long cl
 	p->thread.ar4 = get_fs().ar4;
         /* Don't copy debug registers */
         memset(&p->thread.per_info,0,sizeof(p->thread.per_info));
+
+	/* Set a new TLS ?  */
+	if (clone_flags & CLONE_SETTLS) {
+		if (current->thread.flags & S390_FLAG_31BIT) {
+			frame->childregs.acrs[0] =
+				(unsigned int) regs->gprs[6];
+		} else {
+			frame->childregs.acrs[0] =
+				(unsigned int)(regs->gprs[6] >> 32);
+			frame->childregs.acrs[1] =
+				(unsigned int) regs->gprs[6];
+		}
+	}
         return 0;
 }
 
@@ -189,50 +205,44 @@ int copy_thread(int nr, unsigned long cl
  *       happens we fall back to using vmalloc ...
  */
 
-struct task_struct *alloc_task_struct(void)
+struct task_struct *__alloc_task_struct(void)
 {
-	struct task_struct *tsk = __get_free_pages(GFP_KERNEL, 2);
+	struct task_struct *tsk = (struct task_struct *)__get_free_pages(GFP_KERNEL, 2);
 	if (!tsk)
 		tsk = vmalloc(16384);
 	if (!tsk)
 		return NULL;
 
-        atomic_set((atomic_t *)(tsk + 1), 1);
         return tsk;
 }
 
-void free_task_struct(struct task_struct *tsk)
-{
-	if (atomic_dec_and_test((atomic_t *)(tsk + 1)))
-	{
-		if ((unsigned long)tsk < VMALLOC_START)
-			free_pages((unsigned long)tsk, 2);
-		else
-			vfree(tsk);
-	}
-}
-
-void get_task_struct(struct task_struct *tsk)
+void __free_task_struct(struct task_struct *tsk)
 {
-	atomic_inc((atomic_t *)(tsk + 1));
+	if ((unsigned long)tsk < VMALLOC_START)
+		free_pages((unsigned long)tsk, 2);
+	else
+		vfree(tsk);
 }
 
-
 asmlinkage int sys_fork(struct pt_regs regs)
 {
-        return do_fork(SIGCHLD, regs.gprs[15], &regs, 0);
+        return do_fork(SIGCHLD, regs.gprs[15], &regs, 0, NULL, NULL);
 }
 
 asmlinkage int sys_clone(struct pt_regs regs)
 {
         unsigned long clone_flags;
         unsigned long newsp;
+	int *parent_tidptr, *child_tidptr;
 
         clone_flags = regs.gprs[3];
         newsp = regs.orig_gpr2;
+	parent_tidptr = (int *) regs.gprs[4];
+	child_tidptr = (int *) regs.gprs[5];
         if (!newsp)
                 newsp = regs.gprs[15];
-        return do_fork(clone_flags, newsp, &regs, 0);
+        return do_fork(clone_flags & ~CLONE_IDLETASK, newsp, &regs, 0,
+		       parent_tidptr, child_tidptr);
 }
 
 /*
@@ -248,7 +258,7 @@ asmlinkage int sys_clone(struct pt_regs 
 asmlinkage int sys_vfork(struct pt_regs regs)
 {
 	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD,
-                       regs.gprs[15], &regs, 0);
+	  	       regs.gprs[15], &regs, 0, NULL, NULL);
 }
 
 /*
diff -urNp linux-420/arch/s390x/kernel/ptrace.c linux-422/arch/s390x/kernel/ptrace.c
--- linux-420/arch/s390x/kernel/ptrace.c
+++ linux-422/arch/s390x/kernel/ptrace.c
@@ -471,7 +471,7 @@ asmlinkage int sys_ptrace(long request, 
 			if (request != PTRACE_KILL)
 				goto out_tsk;
 		}
-		if (child->p_pptr != current)
+		if (child->parent != current)
 			goto out_tsk;
 	}
 #ifdef CONFIG_S390_SUPPORT
@@ -584,7 +584,7 @@ asmlinkage int sys_ptrace(long request, 
 		break;
 	}
  out_tsk:
-	free_task_struct(child);
+	put_task_struct(child);
  out:
 	unlock_kernel();
 	return ret;
@@ -611,6 +611,7 @@ asmlinkage void syscall_trace(void)
 		send_sig(current->exit_code, current, 1);
 		current->exit_code = 0;
 	}
+	recalc_sigpending();
  out:
 	unlock_kernel();
 }
diff -urNp linux-420/arch/s390x/kernel/signal.c linux-422/arch/s390x/kernel/signal.c
--- linux-420/arch/s390x/kernel/signal.c
+++ linux-422/arch/s390x/kernel/signal.c
@@ -91,11 +91,11 @@ sys_sigsuspend(struct pt_regs * regs,int
 	sigset_t saveset;
 
 	mask &= _BLOCKABLE;
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	saveset = current->blocked;
 	siginitset(&current->blocked, mask);
-	recalc_sigpending(current);
-	spin_unlock_irq(&current->sigmask_lock);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
 	regs->gprs[2] = -EINTR;
 
 	while (1) {
@@ -119,11 +119,11 @@ sys_rt_sigsuspend(struct pt_regs * regs,
 		return -EFAULT;
 	sigdelsetmask(&newset, ~_BLOCKABLE);
 
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	saveset = current->blocked;
 	current->blocked = newset;
-	recalc_sigpending(current);
-	spin_unlock_irq(&current->sigmask_lock);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
 	regs->gprs[2] = -EINTR;
 
 	while (1) {
@@ -221,10 +221,10 @@ asmlinkage long sys_sigreturn(struct pt_
 		goto badframe;
 
 	sigdelsetmask(&set, ~_BLOCKABLE);
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	current->blocked = set;
-	recalc_sigpending(current);
-	spin_unlock_irq(&current->sigmask_lock);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
 
 	if (restore_sigregs(regs, &frame->sregs))
 		goto badframe;
@@ -247,10 +247,10 @@ asmlinkage long sys_rt_sigreturn(struct 
 		goto badframe;
 
 	sigdelsetmask(&set, ~_BLOCKABLE);
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	current->blocked = set;
-	recalc_sigpending(current);
-	spin_unlock_irq(&current->sigmask_lock);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
 
 	if (restore_sigregs(regs, &frame->uc.uc_mcontext))
 		goto badframe;
@@ -415,9 +415,11 @@ give_sigsegv:
  */	
 
 static void
-handle_signal(unsigned long sig, struct k_sigaction *ka,
+handle_signal(unsigned long sig,
 	      siginfo_t *info, sigset_t *oldset, struct pt_regs * regs)
 {
+	struct k_sigaction *ka = &current->sighand->action[sig-1];
+
 	/* Are we from a system call? */
 	if (regs->trap == __LC_SVC_OLD_PSW) {
 		/* If so, check system call restarting.. */
@@ -448,14 +450,16 @@ handle_signal(unsigned long sig, struct 
 		ka->sa.sa_handler = SIG_DFL;
 
 	if (!(ka->sa.sa_flags & SA_NODEFER)) {
-		spin_lock_irq(&current->sigmask_lock);
+		spin_lock_irq(&current->sighand->siglock);
 		sigorsets(&current->blocked,&current->blocked,&ka->sa.sa_mask);
 		sigaddset(&current->blocked,sig);
-		recalc_sigpending(current);
-		spin_unlock_irq(&current->sigmask_lock);
+		recalc_sigpending();
+		spin_unlock_irq(&current->sighand->siglock);
 	}
 }
 
+int print_fatal_signals;
+
 /*
  * Note that 'init' is a special process: it doesn't get signals it doesn't
  * want to handle. Thus you cannot kill init even with a SIGKILL even by
@@ -468,7 +472,7 @@ handle_signal(unsigned long sig, struct 
 int do_signal(struct pt_regs *regs, sigset_t *oldset)
 {
 	siginfo_t info;
-	struct k_sigaction *ka;
+	int signr;
 
 	/*
 	 * We want the common case to go fast, which
@@ -488,100 +492,10 @@ int do_signal(struct pt_regs *regs, sigs
         }
 #endif 
 
-	for (;;) {
-		unsigned long signr;
-
-		spin_lock_irq(&current->sigmask_lock);
-		signr = dequeue_signal(&current->blocked, &info);
-		spin_unlock_irq(&current->sigmask_lock);
-
-		if (!signr)
-			break;
-
-		if ((current->ptrace & PT_PTRACED) && signr != SIGKILL) {
-			/* Let the debugger run.  */
-			current->exit_code = signr;
-			set_current_state(TASK_STOPPED);
-			notify_parent(current, SIGCHLD);
-			schedule();
-
-			/* We're back.  Did the debugger cancel the sig?  */
-			if (!(signr = current->exit_code))
-				continue;
-			current->exit_code = 0;
-
-			/* The debugger continued.  Ignore SIGSTOP.  */
-			if (signr == SIGSTOP)
-				continue;
-
-			/* Update the siginfo structure.  Is this good?  */
-			if (signr != info.si_signo) {
-				info.si_signo = signr;
-				info.si_errno = 0;
-				info.si_code = SI_USER;
-				info.si_pid = current->p_pptr->pid;
-				info.si_uid = current->p_pptr->uid;
-			}
-
-			/* If the (new) signal is now blocked, requeue it.  */
-			if (sigismember(&current->blocked, signr)) {
-				send_sig_info(signr, &info, current);
-				continue;
-			}
-		}
-
-		ka = &current->sig->action[signr-1];
-		if (ka->sa.sa_handler == SIG_IGN) {
-			if (signr != SIGCHLD)
-				continue;
-			/* Check for SIGCHLD: it's special.  */
-			while (sys_wait4(-1, NULL, WNOHANG, NULL) > 0)
-				/* nothing */;
-			continue;
-		}
-
-		if (ka->sa.sa_handler == SIG_DFL) {
-			int exit_code = signr;
-
-			/* Init gets no signals it doesn't want.  */
-			if (current->pid == 1)
-				continue;
-
-			switch (signr) {
-			case SIGCONT: case SIGCHLD: case SIGWINCH: case SIGURG:
-				continue;
-
-			case SIGTSTP: case SIGTTIN: case SIGTTOU:
-				if (is_orphaned_pgrp(current->pgrp))
-					continue;
-				/* FALLTHRU */
-
-			case SIGSTOP: {
-				struct signal_struct *sig;
-				set_current_state(TASK_STOPPED);
-				current->exit_code = signr;
-				sig = current->p_pptr->sig;
-				if (sig && !(sig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))
-					notify_parent(current, SIGCHLD);
-				schedule();
-				continue;
-			}
-
-			case SIGQUIT: case SIGILL: case SIGTRAP:
-			case SIGABRT: case SIGFPE: case SIGSEGV:
-			case SIGBUS: case SIGSYS: case SIGXCPU: case SIGXFSZ:
-                                if (do_coredump(signr, regs))
-                                        exit_code |= 0x80;
-                                /* FALLTHRU */
-
-			default:
-				sig_exit(signr, exit_code, &info);
-				/* NOTREACHED */
-			}
-		}
-
+	signr = get_signal_to_deliver(&info, regs);
+	if (signr > 0) {
 		/* Whee!  Actually deliver the signal.  */
-		handle_signal(signr, ka, &info, oldset, regs);
+		handle_signal(signr, &info, oldset, regs);
 		return 1;
 	}
 
diff -urNp linux-420/arch/s390x/kernel/signal32.c linux-422/arch/s390x/kernel/signal32.c
--- linux-420/arch/s390x/kernel/signal32.c
+++ linux-422/arch/s390x/kernel/signal32.c
@@ -109,11 +109,11 @@ sys32_sigsuspend(struct pt_regs * regs,i
 	sigset_t saveset;
 
 	mask &= _BLOCKABLE;
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	saveset = current->blocked;
 	siginitset(&current->blocked, mask);
-	recalc_sigpending(current);
-	spin_unlock_irq(&current->sigmask_lock);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
 	regs->gprs[2] = -EINTR;
 
 	while (1) {
@@ -144,11 +144,11 @@ sys32_rt_sigsuspend(struct pt_regs * reg
 	}
         sigdelsetmask(&newset, ~_BLOCKABLE);
 
-        spin_lock_irq(&current->sigmask_lock);
+        spin_lock_irq(&current->sighand->siglock);
         saveset = current->blocked;
         current->blocked = newset;
-        recalc_sigpending(current);
-        spin_unlock_irq(&current->sigmask_lock);
+        recalc_sigpending();
+        spin_unlock_irq(&current->sighand->siglock);
         regs->gprs[2] = -EINTR;
 
         while (1) {
@@ -349,10 +349,10 @@ asmlinkage long sys32_sigreturn(struct p
 		goto badframe;
 
 	sigdelsetmask(&set, ~_BLOCKABLE);
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	current->blocked = set;
-	recalc_sigpending(current);
-	spin_unlock_irq(&current->sigmask_lock);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
 
 	if (restore_sigregs32(regs, &frame->sregs))
 		goto badframe;
@@ -378,10 +378,10 @@ asmlinkage long sys32_rt_sigreturn(struc
 		goto badframe;
 
 	sigdelsetmask(&set, ~_BLOCKABLE);
-	spin_lock_irq(&current->sigmask_lock);
+	spin_lock_irq(&current->sighand->siglock);
 	current->blocked = set;
-	recalc_sigpending(current);
-	spin_unlock_irq(&current->sigmask_lock);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
 
 	if (restore_sigregs32(regs, &frame->uc.uc_mcontext))
 		goto badframe;
@@ -556,9 +556,11 @@ give_sigsegv:
  */	
 
 static void
-handle_signal32(unsigned long sig, struct k_sigaction *ka,
-	      siginfo_t *info, sigset_t *oldset, struct pt_regs * regs)
+handle_signal32(unsigned long sig, siginfo_t *info, sigset_t *oldset,
+	struct pt_regs * regs)
 {
+	struct k_sigaction *ka = &current->sighand->action[sig-1];
+
 	/* Are we from a system call? */
 	if (regs->trap == __LC_SVC_OLD_PSW) {
 		/* If so, check system call restarting.. */
@@ -589,11 +591,11 @@ handle_signal32(unsigned long sig, struc
 		ka->sa.sa_handler = SIG_DFL;
 
 	if (!(ka->sa.sa_flags & SA_NODEFER)) {
-		spin_lock_irq(&current->sigmask_lock);
+		spin_lock_irq(&current->sighand->siglock);
 		sigorsets(&current->blocked,&current->blocked,&ka->sa.sa_mask);
 		sigaddset(&current->blocked,sig);
-		recalc_sigpending(current);
-		spin_unlock_irq(&current->sigmask_lock);
+		recalc_sigpending();
+		spin_unlock_irq(&current->sighand->siglock);
 	}
 }
 
@@ -609,7 +611,7 @@ handle_signal32(unsigned long sig, struc
 int do_signal32(struct pt_regs *regs, sigset_t *oldset)
 {
 	siginfo_t info;
-	struct k_sigaction *ka;
+	int signr;
 
 	/*
 	 * We want the common case to go fast, which
@@ -623,97 +625,10 @@ int do_signal32(struct pt_regs *regs, si
 	if (!oldset)
 		oldset = &current->blocked;
 
-	for (;;) {
-		unsigned long signr;
-
-		spin_lock_irq(&current->sigmask_lock);
-		signr = dequeue_signal(&current->blocked, &info);
-		spin_unlock_irq(&current->sigmask_lock);
-
-		if (!signr)
-			break;
-
-		if ((current->ptrace & PT_PTRACED) && signr != SIGKILL) {
-			/* Let the debugger run.  */
-			current->exit_code = signr;
-			set_current_state(TASK_STOPPED);
-			notify_parent(current, SIGCHLD);
-			schedule();
-
-			/* We're back.  Did the debugger cancel the sig?  */
-			if (!(signr = current->exit_code))
-				continue;
-			current->exit_code = 0;
-
-			/* The debugger continued.  Ignore SIGSTOP.  */
-			if (signr == SIGSTOP)
-				continue;
-
-			/* Update the siginfo structure.  Is this good?  */
-			if (signr != info.si_signo) {
-				info.si_signo = signr;
-				info.si_errno = 0;
-				info.si_code = SI_USER;
-				info.si_pid = current->p_pptr->pid;
-				info.si_uid = current->p_pptr->uid;
-			}
-
-			/* If the (new) signal is now blocked, requeue it.  */
-			if (sigismember(&current->blocked, signr)) {
-				send_sig_info(signr, &info, current);
-				continue;
-			}
-		}
-
-		ka = &current->sig->action[signr-1];
-		if (ka->sa.sa_handler == SIG_IGN) {
-			if (signr != SIGCHLD)
-				continue;
-			/* Check for SIGCHLD: it's special.  */
-			while (sys_wait4(-1, NULL, WNOHANG, NULL) > 0)
-				/* nothing */;
-			continue;
-		}
-
-		if (ka->sa.sa_handler == SIG_DFL) {
-			int exit_code = signr;
-
-			/* Init gets no signals it doesn't want.  */
-			if (current->pid == 1)
-				continue;
-
-			switch (signr) {
-			case SIGCONT: case SIGCHLD: case SIGWINCH: case SIGURG:
-				continue;
-
-			case SIGTSTP: case SIGTTIN: case SIGTTOU:
-				if (is_orphaned_pgrp(current->pgrp))
-					continue;
-				/* FALLTHRU */
-
-			case SIGSTOP:
-				set_current_state(TASK_STOPPED);
-				current->exit_code = signr;
-				if (!(current->p_pptr->sig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))
-					notify_parent(current, SIGCHLD);
-				schedule();
-				continue;
-
-			case SIGQUIT: case SIGILL: case SIGTRAP:
-			case SIGABRT: case SIGFPE: case SIGSEGV:
-			case SIGBUS: case SIGSYS: case SIGXCPU: case SIGXFSZ:
-                                if (do_coredump(signr, regs))
-                                        exit_code |= 0x80;
-                                /* FALLTHRU */
-
-			default:
-				sig_exit(signr, exit_code, &info);
-				/* NOTREACHED */
-			}
-		}
-
+	signr = get_signal_to_deliver(&info, regs);
+	if (signr > 0) {
 		/* Whee!  Actually deliver the signal.  */
-		handle_signal32(signr, ka, &info, oldset, regs);
+		handle_signal32(signr, &info, oldset, regs);
 		return 1;
 	}
 
diff -urNp linux-420/arch/s390x/kernel/smp.c linux-422/arch/s390x/kernel/smp.c
--- linux-420/arch/s390x/kernel/smp.c
+++ linux-422/arch/s390x/kernel/smp.c
@@ -47,9 +47,8 @@ extern volatile int __cpu_logical_map[];
  * An array with a pointer the lowcore of every CPU.
  */
 static int       max_cpus = NR_CPUS;	  /* Setup configured maximum number of CPUs to activate	*/
-int              smp_num_cpus;
+int              smp_num_cpus = 1;
 struct _lowcore *lowcore_ptr[NR_CPUS];
-cycles_t         cacheflush_time=0;
 int              smp_threads_ready=0;      /* Set when the idlers are all forked. */
 static atomic_t  smp_commenced = ATOMIC_INIT(0);
 
@@ -504,13 +503,13 @@ void __init initialize_secondary(void)
 {
 }
 
-static int __init fork_by_hand(void)
+static struct task_struct * __init fork_by_hand(void)
 {
        struct pt_regs regs;
        /* don't care about the psw and regs settings since we'll never
           reschedule the forked task. */
        memset(&regs,0,sizeof(struct pt_regs));
-       return do_fork(CLONE_VM|CLONE_PID, 0, &regs, 0);
+       return copy_process(CLONE_VM|CLONE_IDLETASK, 0, &regs, 0, NULL, NULL);
 }
 
 static void __init do_boot_cpu(int cpu)
@@ -520,16 +519,12 @@ static void __init do_boot_cpu(int cpu)
 
         /* We can't use kernel_thread since we must _avoid_ to reschedule
            the child. */
-        if (fork_by_hand() < 0)
+	idle = fork_by_hand();
+	if (IS_ERR(idle))
                 panic("failed fork for CPU %d", cpu);
 
-        /*
-         * We remove it from the pidhash and the runqueue
-         * once we got the process:
-         */
-        idle = init_task.prev_task;
-        if (!idle)
-                panic("No idle process for CPU %d",cpu);
+	wake_up_forked_process(idle);
+
 	init_idle(idle, cpu);
 
         unhash_process(idle);
@@ -585,6 +580,8 @@ void __init smp_boot_cpus(void)
                 panic("Couldn't request external interrupt 0x1202");
         smp_count_cpus();
         memset(lowcore_ptr,0,sizeof(lowcore_ptr));  
+
+	cache_decay_ticks = (200 * HZ) / 1000;	/* Is 200ms ok? Robust? XXX */
         
 	cache_decay_ticks = (200 * HZ) / 1000;  /* Is 200ms ok? Robus? XXX */
 
diff -urNp linux-420/arch/s390x/kernel/sys_s390.c linux-422/arch/s390x/kernel/sys_s390.c
--- linux-420/arch/s390x/kernel/sys_s390.c
+++ linux-422/arch/s390x/kernel/sys_s390.c
@@ -25,6 +25,7 @@
 #include <linux/file.h>
 #include <linux/utsname.h>
 #include <linux/personality.h>
+#include <linux/futex.h>
 
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
@@ -197,13 +198,6 @@ asmlinkage int sys_uname(struct old_utsn
 	return err?-EFAULT:0;
 }
 
-asmlinkage int sys_pause(void)
-{
-	set_current_state(TASK_INTERRUPTIBLE);
-	schedule();
-	return -ERESTARTNOHAND;
-}
-
 extern asmlinkage int sys_newuname(struct new_utsname * name);
 
 asmlinkage int s390x_newuname(struct new_utsname * name)
@@ -231,3 +225,12 @@ asmlinkage int s390x_personality(unsigne
 
 	return ret;
 }
+
+asmlinkage long s390_futex(u32 *uaddr, int op, int val,
+	struct timespec *utime, u32 *uaddr2)
+{
+	struct pt_regs *regs;
+
+	regs = __KSTK_PTREGS(current);
+	return sys_futex(uaddr, op, val, utime, uaddr2, regs->gprs[7]);
+}
diff -urNp linux-420/arch/s390x/kernel/traps.c linux-422/arch/s390x/kernel/traps.c
--- linux-420/arch/s390x/kernel/traps.c
+++ linux-422/arch/s390x/kernel/traps.c
@@ -140,12 +140,14 @@ void show_trace(unsigned long * stack)
 
 void show_trace_task(struct task_struct *tsk)
 {
+#if 0 /* Mingo's scheduler kills task_has_cpu, so we bite the bullet. */
 	/*
 	 * We can't print the backtrace of a running process. It is
 	 * unreliable at best and can cause kernel oopses.
 	 */
 	if (tsk->state == TASK_RUNNING)
 		return;
+#endif
 	show_trace((unsigned long *) tsk->thread.ksp);
 }
 
diff -urNp linux-420/arch/s390x/kernel/wrapper32.S linux-422/arch/s390x/kernel/wrapper32.S
--- linux-420/arch/s390x/kernel/wrapper32.S
+++ linux-422/arch/s390x/kernel/wrapper32.S
@@ -1107,3 +1107,43 @@ sys32_stime_wrapper:
 sys32_sysctl_wrapper:
 	llgtr   %r2,%r2                 # struct __sysctl_args32 *
 	jg      sys32_sysctl
+
+	.globl  sys32_futex_wrapper
+sys32_futex_wrapper:
+	llgtr	%r2,%r2			# void *
+	lgfr	%r3,%r3			# int
+	lgfr	%r4,%r4			# int
+	llgtr	%r5,%r5			# struct timespec *
+	llgtr	%r6,%r6			# u32 *
+	jg	sys32_futex		# branch to system call
+
+	.globl  sys32_sched_setaffinity_wrapper
+sys32_sched_setaffinity_wrapper:
+	lgfr	%r2,%r2			# int
+	llgfr	%r3,%r3			# unsigned int
+	llgtr	%r4,%r4			# unsigned long *
+	jg	compat_sys_sched_setaffinity
+
+	.globl  sys32_sched_getaffinity_wrapper
+sys32_sched_getaffinity_wrapper:
+	lgfr	%r2,%r2			# int
+	llgfr	%r3,%r3			# unsigned int
+	llgtr	%r4,%r4			# unsigned long *
+	jg	compat_sys_sched_getaffinity
+
+	.globl	sys32_tgkill_wrapper
+sys32_tgkill_wrapper:
+	lgfr	%r2,%r2
+	lgfr	%r3,%r3
+	lgfr	%r4,%r4
+	jg	sys_tgkill
+
+	.globl	sys32_exit_group_wrapper
+sys32_exit_group_wrapper:
+	lgfr	%r2,%r2			# int
+	jg	sys_exit_group		# branch to system call
+
+	.globl	sys32_set_tid_address_wrapper
+sys32_set_tid_address_wrapper:
+	llgtr	%r2,%r2			# int *
+	jg	sys_set_tid_address	# branch to system call
diff -urNp linux-420/include/asm-s390/processor.h linux-422/include/asm-s390/processor.h
--- linux-420/include/asm-s390/processor.h
+++ linux-422/include/asm-s390/processor.h
@@ -144,10 +144,9 @@ unsigned long get_wchan(struct task_stru
 /*
  * NOTE! The task struct and the stack go together
  */
-#define alloc_task_struct() \
+#define __alloc_task_struct() \
         ((struct task_struct *) __get_free_pages(GFP_KERNEL,1))
-#define free_task_struct(p)     free_pages((unsigned long)(p),1)
-#define get_task_struct(tsk)      atomic_inc(&virt_to_page(tsk)->count)
+#define __free_task_struct(p)     free_pages((unsigned long)(p),1)
 
 #define init_task       (init_task_union.task)
 #define init_stack      (init_task_union.stack)
diff -urNp linux-420/include/asm-s390/unistd.h linux-422/include/asm-s390/unistd.h
--- linux-420/include/asm-s390/unistd.h
+++ linux-422/include/asm-s390/unistd.h
@@ -218,6 +218,12 @@
  */
 #define __NR_gettid		236
 #define __NR_tkill		237
+#define __NR_futex		238
+#define __NR_sched_setaffinity	239
+#define __NR_sched_getaffinity	240
+#define __NR_tgkill		241
+#define __NR_exit_group	248
+#define __NR_set_tid_address	252
 
 /* user-visible error numbers are in the range -1 - -122: see <asm-s390/errno.h> */
 
diff -urNp linux-420/include/asm-s390x/processor.h linux-422/include/asm-s390x/processor.h
--- linux-420/include/asm-s390x/processor.h
+++ linux-422/include/asm-s390x/processor.h
@@ -156,9 +156,8 @@ unsigned long get_wchan(struct task_stru
 #define KSTK_ESP(tsk)	(__KSTK_PTREGS(tsk)->gprs[15])
 
 /* Allocation and freeing of basic task resources. */
-extern struct task_struct *alloc_task_struct(void);
-extern void free_task_struct(struct task_struct *tsk);
-extern void get_task_struct(struct task_struct *tsk);
+extern struct task_struct *__alloc_task_struct(void);
+extern void __free_task_struct(struct task_struct *tsk);
 
 #define init_task       (init_task_union.task)
 #define init_stack      (init_task_union.stack)
diff -urNp linux-420/include/asm-s390x/unistd.h linux-422/include/asm-s390x/unistd.h
--- linux-420/include/asm-s390x/unistd.h
+++ linux-422/include/asm-s390x/unistd.h
@@ -186,6 +186,12 @@
  */
 #define __NR_gettid		236
 #define __NR_tkill		237
+#define __NR_futex		238
+#define __NR_sched_setaffinity	239
+#define __NR_sched_getaffinity	240
+#define __NR_tgkill		241
+#define __NR_exit_group	248
+#define __NR_set_tid_address	252
 
 
 /* user-visible error numbers are in the range -1 - -122: see <asm-s390/errno.h> */
