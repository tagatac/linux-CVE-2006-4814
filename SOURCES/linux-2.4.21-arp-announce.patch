diff -urNp linux-2100/Documentation/networking/ip-sysctl.txt linux-2110/Documentation/networking/ip-sysctl.txt
--- linux-2100/Documentation/networking/ip-sysctl.txt
+++ linux-2110/Documentation/networking/ip-sysctl.txt
@@ -481,6 +481,38 @@ arp_filter - BOOLEAN
 	conf/{all,interface}/arp_filter is set to TRUE,
 	it will be disabled otherwise
 
+arp_announce - INTEGER
+	Define different restriction levels for announcing the local
+	source IP address from IP packets in ARP requests sent on
+	interface:
+	0 - (default) Use any local address, configured on any interface
+	1 - Try to avoid local addresses that are not in the target's
+	subnet for this interface. This mode is useful when target
+	hosts reachable via this interface require the source IP
+	address in ARP requests to be part of their logical network
+	configured on the receiving interface. When we generate the
+	request we will check all our subnets that include the
+	target IP and will preserve the source address if it is from
+	such subnet. If there is no such subnet we select source
+	address according to the rules for level 2.
+	2 - Always use the best local address for this target.
+	In this mode we ignore the source address in the IP packet
+	and try to select local address that we prefer for talks with
+	the target host. Such local address is selected by looking
+	for primary IP addresses on all our subnets on the outgoing
+	interface that include the target IP address. If no suitable
+	local address is found we select the first local address
+	we have on the outgoing interface or on all other interfaces,
+	with the hope we will receive reply for our request and
+	even sometimes no matter the source IP address we announce.
+
+	The max value from conf/{all,interface}/arp_announce is used.
+	(NOTE: In RHEL3, only conf/all/arp_announce is available.)
+
+	Increasing the restriction level gives more chance for
+	receiving answer from the resolved target while decreasing
+	the level announces more valid sender's information.
+
 tag - INTEGER
 	Allows you to write a number, which can be used as required.
 	Default value is 0.
diff -urNp linux-2100/include/linux/inetdevice.h linux-2110/include/linux/inetdevice.h
--- linux-2100/include/linux/inetdevice.h
+++ linux-2110/include/linux/inetdevice.h
@@ -26,6 +26,7 @@ struct ipv4_devconf
 };
 
 extern struct ipv4_devconf ipv4_devconf;
+extern int ipv4_devconf_arp_announce;
 
 struct in_device
 {
@@ -71,6 +72,7 @@ struct in_device
 	  (ipv4_devconf.accept_redirects || (in_dev)->cnf.accept_redirects)))
 
 #define IN_DEV_ARPFILTER(in_dev)	(ipv4_devconf.arp_filter || (in_dev)->cnf.arp_filter)
+#define IN_DEV_ARP_ANNOUNCE(in_dev)	(ipv4_devconf_arp_announce)
 
 struct in_ifaddr
 {
diff -urNp linux-2100/include/linux/sysctl.h linux-2110/include/linux/sysctl.h
--- linux-2100/include/linux/sysctl.h
+++ linux-2110/include/linux/sysctl.h
@@ -360,6 +360,7 @@ enum
 	NET_IPV4_CONF_NOXFRM=15,
 	NET_IPV4_CONF_NOPOLICY=16,
 	NET_IPV4_CONF_FORCE_IGMP_VERSION=17,
+	NET_IPV4_CONF_ARP_ANNOUNCE=18,
 };
 
 /* /proc/sys/net/ipv6 */
diff -urNp linux-2100/net/ipv4/arp.c linux-2110/net/ipv4/arp.c
--- linux-2100/net/ipv4/arp.c
+++ linux-2110/net/ipv4/arp.c
@@ -316,15 +316,40 @@ static void arp_error_report(struct neig
 
 static void arp_solicit(struct neighbour *neigh, struct sk_buff *skb)
 {
-	u32 saddr;
+	u32 saddr = 0;
 	u8  *dst_ha = NULL;
 	struct net_device *dev = neigh->dev;
 	u32 target = *(u32*)neigh->primary_key;
 	int probes = atomic_read(&neigh->probes);
+	struct in_device *in_dev = in_dev_get(dev);
+
+	if (!in_dev)
+		return;
 
-	if (skb && inet_addr_type(skb->nh.iph->saddr) == RTN_LOCAL)
+	switch (IN_DEV_ARP_ANNOUNCE(in_dev)) {
+	default:
+	case 0:		/* By default announce any local IP */
+		if (skb && inet_addr_type(skb->nh.iph->saddr) == RTN_LOCAL)
+			saddr = skb->nh.iph->saddr;
+		break;
+	case 1:		/* Restrict announcements of saddr in same subnet */
+		if (!skb)
+			break;
 		saddr = skb->nh.iph->saddr;
-	else
+		if (inet_addr_type(saddr) == RTN_LOCAL) {
+			/* saddr should be known to target */
+			if (inet_addr_onlink(in_dev, target, saddr))
+				break;
+		}
+		saddr = 0;
+		break;
+	case 2:		/* Avoid secondary IPs, get a primary/preferred one */
+		break;
+	}
+
+	if (in_dev)
+		in_dev_put(in_dev);
+	if (!saddr)
 		saddr = inet_select_addr(dev, target, RT_SCOPE_LINK);
 
 	if ((probes -= neigh->parms->ucast_probes) < 0) {
diff -urNp linux-2100/net/ipv4/devinet.c linux-2110/net/ipv4/devinet.c
--- linux-2100/net/ipv4/devinet.c
+++ linux-2110/net/ipv4/devinet.c
@@ -61,6 +61,7 @@
 #include <net/ip_fib.h>
 
 struct ipv4_devconf ipv4_devconf = { 1, 1, 1, 1, 0, };
+int ipv4_devconf_arp_announce = 0;
 static struct ipv4_devconf ipv4_devconf_dflt = { 1, 1, 1, 1, 1, };
 
 static void rtmsg_ifa(int event, struct in_ifaddr *);
@@ -1116,7 +1117,7 @@ int ipv4_doint_and_flush_strategy(ctl_ta
 static struct devinet_sysctl_table
 {
 	struct ctl_table_header *sysctl_header;
-	ctl_table devinet_vars[18];
+	ctl_table devinet_vars[19];
 	ctl_table devinet_dev[2];
 	ctl_table devinet_conf_dir[2];
 	ctl_table devinet_proto_dir[2];
@@ -1174,6 +1175,11 @@ static struct devinet_sysctl_table
 	{NET_IPV4_CONF_FORCE_IGMP_VERSION, "force_igmp_version",
 	 &ipv4_devconf.force_igmp_version, sizeof(int), 0644, NULL,
 	 &ipv4_doint_and_flush, &ipv4_doint_and_flush_strategy},
+#define DEVINET_SYSCTL_NUM_GLOBAL_VARS 1
+#define DEVINET_SYSCTL_GLOBAL_VARS_OFFSET 17
+	{NET_IPV4_CONF_ARP_ANNOUNCE, "arp_announce",
+	 &ipv4_devconf_arp_announce, sizeof(int), 0644, NULL,
+	 &proc_dointvec},
 	 {0}},
 
 	{{NET_PROTO_CONF_ALL, "all", NULL, 0, 0555, devinet_sysctl.devinet_vars},{0}},
@@ -1184,7 +1190,7 @@ static struct devinet_sysctl_table
 
 static void devinet_sysctl_register(struct in_device *in_dev, struct ipv4_devconf *p)
 {
-	int i;
+	int i, global_offset;
 	struct net_device *dev = in_dev ? in_dev->dev : NULL;
 	struct devinet_sysctl_table *t;
 
@@ -1196,6 +1202,11 @@ static void devinet_sysctl_register(stru
 		t->devinet_vars[i].data += (char*)p - (char*)&ipv4_devconf;
 		t->devinet_vars[i].de = NULL;
 	}
+	/* eliminate any global-only sysctl entries */
+	global_offset = DEVINET_SYSCTL_GLOBAL_VARS_OFFSET;
+	for (i=0; i<DEVINET_SYSCTL_NUM_GLOBAL_VARS; i++)
+		memset(&t->devinet_vars[i+global_offset], 0,
+		       sizeof(t->devinet_vars[0]));
 	if (dev) {
 		t->devinet_dev[0].procname = dev->name;
 		t->devinet_dev[0].ctl_name = dev->ifindex;
