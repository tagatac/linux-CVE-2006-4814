diff -urNp linux-910/include/asm-i386/rwsem.h linux-920/include/asm-i386/rwsem.h
--- linux-910/include/asm-i386/rwsem.h
+++ linux-920/include/asm-i386/rwsem.h
@@ -42,6 +42,7 @@
 
 #include <linux/list.h>
 #include <linux/spinlock.h>
+#include <asm/system.h>
 
 struct rwsem_waiter;
 
diff -urNp linux-910/lib/rwsem-spinlock.c linux-920/lib/rwsem-spinlock.c
--- linux-910/lib/rwsem-spinlock.c
+++ linux-920/lib/rwsem-spinlock.c
@@ -52,6 +52,7 @@ void init_rwsem(struct rw_semaphore *sem
 static inline struct rw_semaphore *__rwsem_do_wake(struct rw_semaphore *sem)
 {
 	struct rwsem_waiter *waiter;
+	struct task_struct *tsk;
 	int woken;
 
 	rwsemtrace(sem,"Entering __rwsem_do_wake");
@@ -64,8 +65,11 @@ static inline struct rw_semaphore *__rws
 	if (waiter->flags & RWSEM_WAITING_FOR_WRITE) {
 		sem->activity = -1;
 		list_del(&waiter->list);
-		waiter->flags = 0;
-		wake_up_process(waiter->task);
+		tsk = waiter->task;
+		mb();
+		waiter->task = NULL;
+		wake_up_process(tsk);
+		put_task_struct(tsk);
 		goto out;
 	}
 
@@ -73,8 +77,11 @@ static inline struct rw_semaphore *__rws
 	woken = 0;
 	do {
 		list_del(&waiter->list);
-		waiter->flags = 0;
-		wake_up_process(waiter->task);
+		tsk = waiter->task;
+		mb();
+		waiter->task = NULL;
+		wake_up_process(tsk);
+		put_task_struct(tsk);
 		woken++;
 		if (list_empty(&sem->wait_list))
 			break;
@@ -94,14 +101,18 @@ static inline struct rw_semaphore *__rws
 static inline struct rw_semaphore *__rwsem_wake_one_writer(struct rw_semaphore *sem)
 {
 	struct rwsem_waiter *waiter;
+	struct task_struct *tsk;
 
 	sem->activity = -1;
 
 	waiter = list_entry(sem->wait_list.next,struct rwsem_waiter,list);
 	list_del(&waiter->list);
 
-	waiter->flags = 0;
-	wake_up_process(waiter->task);
+	tsk = waiter->task;
+	mb();
+	waiter->task = NULL;
+	wake_up_process(tsk);
+	put_task_struct(tsk);
 	return sem;
 }
 
@@ -130,6 +141,7 @@ void __down_read(struct rw_semaphore *se
 	/* set up my own style of waitqueue */
 	waiter.task = tsk;
 	waiter.flags = RWSEM_WAITING_FOR_READ;
+	get_task_struct(tsk);
 
 	list_add_tail(&waiter.list,&sem->wait_list);
 
@@ -138,7 +150,7 @@ void __down_read(struct rw_semaphore *se
 
 	/* wait to be given the lock */
 	for (;;) {
-		if (!waiter.flags)
+		if (!waiter.task)
 			break;
 		schedule();
 		set_task_state(tsk, TASK_UNINTERRUPTIBLE);
@@ -198,6 +210,7 @@ void __down_write(struct rw_semaphore *s
 	/* set up my own style of waitqueue */
 	waiter.task = tsk;
 	waiter.flags = RWSEM_WAITING_FOR_WRITE;
+	get_task_struct(tsk);
 
 	list_add_tail(&waiter.list,&sem->wait_list);
 
@@ -206,7 +219,7 @@ void __down_write(struct rw_semaphore *s
 
 	/* wait to be given the lock */
 	for (;;) {
-		if (!waiter.flags)
+		if (!waiter.task)
 			break;
 		schedule();
 		set_task_state(tsk, TASK_UNINTERRUPTIBLE);
@@ -280,6 +293,8 @@ EXPORT_SYMBOL(__down_read);
 EXPORT_SYMBOL(__down_write);
 EXPORT_SYMBOL(__up_read);
 EXPORT_SYMBOL(__up_write);
+EXPORT_SYMBOL(__down_write_trylock);
+EXPORT_SYMBOL(__down_read_trylock);
 #if RWSEM_DEBUG
 EXPORT_SYMBOL(rwsemtrace);
 #endif
diff -urNp linux-910/lib/rwsem.c linux-920/lib/rwsem.c
--- linux-910/lib/rwsem.c
+++ linux-920/lib/rwsem.c
@@ -38,9 +38,9 @@ void rwsemtrace(struct rw_semaphore *sem
 static inline struct rw_semaphore *__rwsem_do_wake(struct rw_semaphore *sem)
 {
 	struct rwsem_waiter *waiter;
+	struct task_struct *tsk;
 	struct list_head *next;
-	signed long oldcount;
-	int woken, loop;
+	signed long oldcount, woken, loop;
 
 	rwsemtrace(sem,"Entering __rwsem_do_wake");
 
@@ -60,8 +60,11 @@ static inline struct rw_semaphore *__rws
 		goto readers_only;
 
 	list_del(&waiter->list);
-	waiter->flags = 0;
-	wake_up_process(waiter->task);
+	tsk = waiter->task;
+	mb();
+	waiter->task = NULL;
+	wake_up_process(tsk);
+	put_task_struct(tsk);
 	goto out;
 
 	/* grant an infinite number of read locks to the readers at the front of the queue
@@ -89,8 +92,11 @@ static inline struct rw_semaphore *__rws
 	for (; loop>0; loop--) {
 		waiter = list_entry(next,struct rwsem_waiter,list);
 		next = waiter->list.next;
-		waiter->flags = 0;
-		wake_up_process(waiter->task);
+		tsk = waiter->task;
+		mb();
+		waiter->task = NULL;
+		wake_up_process(tsk);
+		put_task_struct(tsk);
 	}
 
 	sem->wait_list.next = next;
@@ -122,6 +128,7 @@ static inline struct rw_semaphore *rwsem
 	/* set up my own style of waitqueue */
 	spin_lock(&sem->wait_lock);
 	waiter->task = tsk;
+	get_task_struct(tsk);
 
 	list_add_tail(&waiter->list,&sem->wait_list);
 
@@ -138,7 +145,7 @@ static inline struct rw_semaphore *rwsem
 
 	/* wait to be given the lock */
 	for (;;) {
-		if (!waiter->flags)
+		if (!waiter->task)
 			break;
 		schedule();
 		set_task_state(tsk, TASK_UNINTERRUPTIBLE);
