diff -urNp linux-6120/fs/inode.c linux-6200/fs/inode.c
--- linux-6120/fs/inode.c
+++ linux-6200/fs/inode.c
@@ -790,7 +790,7 @@ int invalidate_device(kdev_t dev, int do
 	 !inode_has_buffers(inode))
 #define INODE(entry)	(list_entry(entry, struct inode, i_list))
 
-void prune_icache(int goal)
+static void __prune_icache(int goal, struct super_block *sb)
 {
 	LIST_HEAD(list);
 	struct list_head *entry, *freeable = &list;
@@ -807,6 +807,8 @@ void prune_icache(int goal)
 
 		entry = entry->prev;
 		inode = INODE(tmp);
+		if (sb && inode->i_sb != sb)
+			continue;
 		if (inode->i_state & (I_FREEING|I_CLEAR|I_LOCK))
 			continue;
 		if (!CAN_UNUSE(inode))
@@ -906,6 +908,19 @@ void prune_icache(int goal)
 #endif /* CONFIG_HIGHMEM */
 }
 
+void prune_icache(int goal)
+{
+	__prune_icache(goal, NULL);
+}
+
+int shrink_icache_sb(int goal, struct super_block *sb)
+{
+	__prune_icache(goal, sb);
+	if (RATE_LIMIT(HZ))
+		return kmem_cache_shrink(inode_cachep);
+	return 0;
+}
+
 int shrink_icache_memory(int priority, int gfp_mask)
 {
 	int count;
diff -urNp linux-6120/fs/locks.c linux-6200/fs/locks.c
--- linux-6120/fs/locks.c
+++ linux-6200/fs/locks.c
@@ -1356,6 +1356,41 @@ out_unlock:
 	return error;
 }
 
+/*
+ * Wrapper function around the file_operations lock routine when called for
+ * flock().  The lock routine is called for both fcntl() and flock(), so
+ * the flock parameters must be translated to an equivalent fcntl()-like
+ * lock.
+ */
+int flock_fs_file(struct file *filp, int type, unsigned int cmd)
+{
+	int error;
+	struct file_lock fl;
+
+	/*
+	 * Don't use locks_alloc_lock() (or flock_make_lock()) here, as
+	 * this is just a temporary lock structure.  We especially don't
+	 * want to fail because we couldn't allocate a lock structure if
+	 * this is an unlock operation.
+	 */
+	fl.fl_owner = NULL;
+	fl.fl_file = filp;
+	fl.fl_pid = current->pid;
+	fl.fl_flags = FL_FLOCK;
+	fl.fl_type = type;
+	fl.fl_start = 0;
+	fl.fl_end = OFFSET_MAX;
+	fl.fl_notify = NULL;
+	fl.fl_insert = NULL;
+	fl.fl_remove = NULL;
+
+	error = filp->f_op->lock(filp,
+				 (((cmd&LOCK_NB)==LOCK_NB)?F_SETLK:F_SETLKW),
+				 &fl);
+
+	return error;
+}
+
 /**
  *	sys_flock: - flock() system call.
  *	@fd: the file descriptor to lock.
@@ -1399,8 +1434,63 @@ asmlinkage long sys_flock(unsigned int f
 		goto out_putf;
 
 	lock_kernel();
+
+	/*
+	 * Execute any filesystem-specific flock routines.  The filesystem may
+	 * maintain supplemental locks.  This code allows the supplemental locks
+	 * to be kept in sync with the vfs flock lock.  If flock() is called on
+	 * a lock already held for the given filp, the current flock lock is
+	 * dropped before obtaining the requested lock.  This unlock operation
+	 * must be completed for the any filesystem specific locks and the vfs
+	 * flock lock before proceeding with obtaining the requested lock.  When
+	 * the filesystem routine drops a lock for such a request, it must
+	 * return -EDEADLK, allowing the vfs lock to be dropped, and the
+	 * filesystem code is then re-executed to obtain the lock.
+	 *
+	 * A non-blocking request that returns EWOULDBLOCK also causes any vfs
+	 * flock lock to be released, but then returns the error to the caller.
+	 */
+	if (filp->f_op && filp->f_op->lock) {
+repeat:
+		error = flock_fs_file(filp, type, cmd);
+
+		if (error < 0) {
+			/*
+			 * We may have dropped a lock.  We need to
+			 * finish unlocking before returning or
+			 * continuing with lock acquisition.
+			 */
+			if (error != -ENOLCK)
+				flock_lock_file(filp, F_UNLCK, 0);
+
+			/*
+			 * We already held the lock in some mode, and
+			 * had to drop filesystem-specific locks before
+			 * proceeding.  We come back through this
+			 * routine to unlock the vfs flock lock.  Now go
+			 * back and try again.  Using EAGAIN as the
+			 * error here would be better, but the one valid
+			 * error value defined for flock(), EWOULDBLOCK,
+			 * is defined as EAGAIN.
+			 */
+			if (error == -EDEADLK)
+				goto repeat;
+
+			goto out_unlock_putf;
+		}
+	}
+
 	error = flock_lock_file(filp, type,
 				(cmd & (LOCK_UN | LOCK_NB)) ? 0 : 1);
+
+	/*
+	 * If we failed to get the vfs flock, we need to clean up any
+	 * filesystem-specific lock state that we previously obtained.
+	 */
+	if (error && filp->f_op && filp->f_op->lock)
+		flock_fs_file(filp, F_UNLCK, 0);	
+
+out_unlock_putf:
 	unlock_kernel();
 
 out_putf:
@@ -1790,6 +1880,7 @@ void locks_remove_flock(struct file *fil
 	struct inode * inode = filp->f_dentry->d_inode; 
 	struct file_lock *fl;
 	struct file_lock **before;
+	struct file_lock file_lock;
 
 	if (!inode->i_flock)
 		return;
@@ -1800,7 +1891,13 @@ void locks_remove_flock(struct file *fil
 	while ((fl = *before) != NULL) {
 		if (fl->fl_file == filp) {
 			if (fl->fl_flags & FL_FLOCK) {
+				if (filp->f_op && filp->f_op->lock) {
+					file_lock = *fl;
+					file_lock.fl_type = F_UNLCK;
+				}
 				locks_delete_lock(before, 0);
+				if (filp->f_op && filp->f_op->lock)
+					filp->f_op->lock(filp, F_SETLK, &file_lock);
 				continue;
 			}
 			if (fl->fl_flags & FL_LEASE) {
diff -urNp linux-6120/fs/nfs/file.c linux-6200/fs/nfs/file.c
--- linux-6120/fs/nfs/file.c
+++ linux-6200/fs/nfs/file.c
@@ -383,6 +383,14 @@ nfs_lock(struct file *filp, int cmd, str
 			fl->fl_type, fl->fl_flags,
 			(long long)fl->fl_start, (long long)fl->fl_end);
 
+	/*
+	 * Return success on attempts to request BSD flocks over NFS.
+	 * This prevents ENOLCK errors from being returned to user space,
+	 * but file locking will be enforced solely on the local client.
+	 */
+	if (fl->fl_flags & FL_FLOCK)
+		return 0;
+
 	if (!inode)
 		return -EINVAL;
 
diff -urNp linux-6120/fs/nfs/inode.c linux-6200/fs/nfs/inode.c
--- linux-6120/fs/nfs/inode.c
+++ linux-6200/fs/nfs/inode.c
@@ -1352,7 +1352,7 @@ __nfs_refresh_inode(struct inode *inode,
 /*
  * File system information
  */
-static DECLARE_FSTYPE(nfs_fs_type, "nfs", nfs_read_super, 
+static DECLARE_FSTYPE(nfs_fs_type, "nfs", nfs_read_super,
 	FS_ODD_RENAME|FS_AIO_SYNC);
 
 extern int nfs_init_nfspagecache(void);
diff -urNp linux-6120/include/linux/dcache.h linux-6200/include/linux/dcache.h
--- linux-6120/include/linux/dcache.h
+++ linux-6200/include/linux/dcache.h
@@ -184,6 +184,7 @@ extern void prune_dcache(int);
 /* icache memory management (defined in linux/fs/inode.c) */
 extern int shrink_icache_memory(int, int);
 extern void prune_icache(int);
+extern int shrink_icache_sb(int, struct super_block *);
 
 /* quota cache memory management (defined in linux/fs/dquot.c) */
 extern int shrink_dqcache_memory(int, unsigned int);
diff -urNp linux-6120/include/linux/fs.h linux-6200/include/linux/fs.h
--- linux-6120/include/linux/fs.h
+++ linux-6200/include/linux/fs.h
@@ -114,6 +114,7 @@ extern int leases_enable, dir_notify_ena
 #define MS_REC		16384
 #define MS_VERBOSE	32768
 #define MS_POSIXACL	65536	/* VFS does not apply the umask */
+#define MS_SENDFILE_FOP (1<<29)
 #define MS_ACTIVE	(1<<30)
 #define MS_NOUSER	(1<<31)
 
@@ -165,6 +166,7 @@ extern int leases_enable, dir_notify_ena
 #define IS_NOATIME(inode)	(__IS_FLG(inode, MS_NOATIME) || ((inode)->i_flags & S_NOATIME))
 #define IS_NODIRATIME(inode)	__IS_FLG(inode, MS_NODIRATIME)
 #define IS_POSIXACL(inode)	__IS_FLG(inode, MS_POSIXACL)
+#define IS_SENDFILE_FOP(inode)	__IS_FLG(inode, MS_SENDFILE_FOP)
 
 #define IS_DEADDIR(inode)	((inode)->i_flags & S_DEAD)
 
@@ -921,6 +923,11 @@ struct file_operations {
 	ssize_t (*aio_fsync)(struct file *, struct kiocb *, struct iocb *);
 };
 
+struct file_operations_ext {
+	struct file_operations f_op_orig;
+	ssize_t (*sendfile)(struct file *, struct file *, size_t, loff_t *);
+};
+
 struct inode_operations {
 	int (*create) (struct inode *,struct dentry *,int);
 	struct dentry * (*lookup) (struct inode *,struct dentry *);
@@ -1586,6 +1593,7 @@ extern int writeout_one_page(struct page
 
 extern int generic_file_mmap(struct file *, struct vm_area_struct *);
 extern int file_read_actor(read_descriptor_t * desc, struct page *page, unsigned long offset, unsigned long size);
+extern int file_send_actor(read_descriptor_t * desc, struct page *page, unsigned long offset, unsigned long size);
 extern ssize_t generic_file_read(struct file *, char *, size_t, loff_t *);
 extern ssize_t generic_file_write(struct file *, const char *, size_t, loff_t *);
 extern void do_generic_file_read(struct file *, loff_t *, read_descriptor_t *, read_actor_t, int);
diff -urNp linux-6120/kernel/ksyms.c linux-6200/kernel/ksyms.c
--- linux-6120/kernel/ksyms.c
+++ linux-6200/kernel/ksyms.c
@@ -263,6 +263,7 @@ EXPORT_SYMBOL(cont_prepare_write);
 EXPORT_SYMBOL(generic_commit_write);
 EXPORT_SYMBOL(block_truncate_page);
 EXPORT_SYMBOL(generic_block_bmap);
+EXPORT_SYMBOL_GPL(file_send_actor);
 EXPORT_SYMBOL(generic_file_read);
 EXPORT_SYMBOL(do_generic_file_read);
 EXPORT_SYMBOL(generic_file_write);
@@ -287,6 +288,7 @@ EXPORT_SYMBOL(d_find_alias);
 EXPORT_SYMBOL(d_prune_aliases);
 EXPORT_SYMBOL(prune_dcache);
 EXPORT_SYMBOL(shrink_dcache_sb);
+EXPORT_SYMBOL_GPL(shrink_icache_sb);
 EXPORT_SYMBOL(shrink_dcache_parent);
 EXPORT_SYMBOL_GPL(flush_dentry_attributes);
 EXPORT_SYMBOL(find_inode_number);
diff -urNp linux-6120/mm/filemap.c linux-6200/mm/filemap.c
--- linux-6120/mm/filemap.c
+++ linux-6200/mm/filemap.c
@@ -1956,7 +1956,7 @@ ssize_t generic_file_read(struct file * 
 	return generic_file_new_read(filp, buf, count, ppos, 0);
 }
 
-static int file_send_actor(read_descriptor_t * desc, struct page *page, unsigned long offset , unsigned long size)
+int file_send_actor(read_descriptor_t * desc, struct page *page, unsigned long offset , unsigned long size)
 {
 	ssize_t written;
 	unsigned long count = desc->count;
@@ -2034,20 +2034,24 @@ static ssize_t common_sendfile(int out_f
 
 	retval = 0;
 	if (count) {
-		read_descriptor_t desc;
-		
 		if (!offset)
 			offset = &in_file->f_pos;
 
-		desc.written = 0;
-		desc.count = count;
-		desc.buf = (char *) out_file;
-		desc.error = 0;
-		do_generic_file_read(in_file, offset, &desc, file_send_actor, 0);
-
-		retval = desc.written;
-		if (!retval)
-			retval = desc.error;
+		if (IS_SENDFILE_FOP(in_inode) && in_file->f_op && ((struct file_operations_ext *)in_file->f_op)->sendfile)
+			retval = ((struct file_operations_ext *)in_file->f_op)->sendfile(in_file, out_file, count, offset);
+		else {
+			read_descriptor_t desc;
+
+			desc.written = 0;
+			desc.count = count;
+			desc.buf = (char *) out_file;
+			desc.error = 0;
+			do_generic_file_read(in_file, offset, &desc, file_send_actor, 0);
+
+			retval = desc.written;
+			if (!retval)
+				retval = desc.error;
+		}
 	}
 
 fput_out:
