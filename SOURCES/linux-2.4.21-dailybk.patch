# This is a BitKeeper generated patch for the following project:
# Project Name: Linux kernel tree
# This patch format is intended for GNU patch command version 2.5 or higher.
# This patch includes the following deltas:
#	           ChangeSet	v2.4.21 -> 1.1211 
#	drivers/message/fusion/mptctl.c	1.10    -> 1.11   
#	drivers/message/fusion/mptctl.h	1.4     -> 1.5    
#	net/sunrpc/svcsock.c	1.19    -> 1.22   
#	            Makefile	1.217   -> 1.218  
#	drivers/message/fusion/mptbase.h	1.9     -> 1.10   
#	  drivers/md/raid5.c	1.14    -> 1.15   
#	drivers/message/fusion/mptbase.c	1.9     -> 1.10   
#	     drivers/md/md.c	1.42    -> 1.44   
#	drivers/message/fusion/linux_compat.h	1.7     -> 1.8    
#	     fs/nfsd/nfsfh.c	1.18    -> 1.19   
#	drivers/message/fusion/mptscsih.c	1.9     -> 1.10   
#	drivers/message/fusion/scsi3.h	1.3     -> 1.4    
#	drivers/message/fusion/isense.c	1.5     -> 1.6    
#	drivers/message/fusion/mptscsih.h	1.5     -> 1.6    
#
# The following is the BitKeeper ChangeSet Log
# --------------------------------------------
# 03/06/17	marcelo@freak.distro.conectiva	1.1203
#   Removed EXTRAVERSION
# --------------------------------------------
# 03/06/17	marcelo@freak.distro.conectiva	1.1204
#   Changed VERSION to .22
# --------------------------------------------
# 03/06/18	neilb@cse.unsw.edu.au	1.1205
# [PATCH] Handle concurrent failure of two drives in raid5
# 
# ### Comments for ChangeSet
# 
# If two drives both fail during a write request, raid5 doesn't
# cope properly and will eventually oops.
# 
# With this patch, blocks that have already been 'written'
# are failed when double drive failure is noticed, as well as
# blocks that are about to be written.
# 
#  ----------- Diffstat output ------------
#  ./drivers/md/raid5.c |   10 +++++++++-
#  1 files changed, 9 insertions(+), 1 deletion(-)
# --------------------------------------------
# 03/06/18	neilb@cse.unsw.edu.au	1.1206
# [PATCH] Fix bug in /proc/mdstat
# 
# [These 3 patches for 2.4.22-pre - thanks]
# 
# If /proc/mdstat is large, or reads are for a small size,
# then the last line of /proc/mdstat is repeated nearly 65536 times.
# 
# This patch will fix it.
# --------------------------------------------
# 03/06/18	neilb@cse.unsw.edu.au	1.1207
# [PATCH] Fix the check for execute permissions of parent directories in NFSd
# 
# [4 patches for nfsd in 2.4.22-pre]
# 
# The previous check fails on directories with uid=0, gid=0, and
# permissions in ACLs.  A similar check to this one is also found in
# the 2.5 kernel in fs/nfsd/nfsfh.c:nfsd_acceptable().
# --------------------------------------------
# 03/06/18	neilb@cse.unsw.edu.au	1.1208
# [PATCH] kNFSd: SVC sockets don't disable Nagle
# 
# I noticed that the Nagle algorithm was disabled just recently on the
# client side, while it still seems to be enabled on the server side. The
# previous patch came from Chuck Lever.
# 
# Below patch disables it on the server side as well. For latency reasons,
# this should be the desired behaviour NFS at both client and server.
# --------------------------------------------
# 03/06/18	neilb@cse.unsw.edu.au	1.1209
# [PATCH] kNFSd: TCP nfsd connection hangs when partial record header is received
# 
# From: Olof Johansson <olof@austin.ibm.com>
# 
# Below patch resolves a hang where a TCP nfsd connection will hang even
# though new data is received on the socket. We've seen this a few times in
# our lab, but it usually happened every few weeks.
# 
# If a short record header is received, the SK_BUSY flag is never cleared,
# and even though new data arrives, it will not be handled. This in turn
# leads to hangs of particular clients (while others will continue to work
# without problem).
# 
# I also changed the return code for that condition to be the same as for a
# (regular) short read.
# --------------------------------------------
# 03/06/18	neilb@cse.unsw.edu.au	1.1210
# [PATCH] kNFSd: Make sure an early close on a nfs/tcp connection is handled properly.
# 
# From: Hirokazu Takahashi <taka@valinux.co.jp>
# 
# In svc_tcp_listen_data_ready we should be waiting for
# TCP_LISTEN, not TCP_ESTABLISHED.  The later only worked
# by accident.
# Also, if a socket is closed as soon as we accept it, we
# must shut it down straight away as we will never get a 'close'
# event.
# --------------------------------------------
# 03/06/18	pdelaney@lsil.com	1.1211
# [PATCH] Critical bug fix for fusion driver
# 
# Hello Marcelo, Alan -
# 
# In our IA64 testing we have discovered a bug that causes a
# critical failure with the fusion driver. To date we have been unable to
# reproduce the failure on 32 bit systems, but given the fix, the failure
# could
# occur on any architecture.  Please accept the attached patch for
# 2.4.21-rc9.
# 
# Changes:
# o critical bug fix: 2 line patch to zero unused CDB bytes in driver qcmd
# function
# o use old eh code instead of new
# o change mailto labels to lstephen.
# --------------------------------------------
#
diff -Nru a/Makefile b/Makefile
--- a/Makefile	Fri Jun 20 09:11:33 2003
+++ b/Makefile	Fri Jun 20 09:11:33 2003
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 4
-SUBLEVEL = 21
-EXTRAVERSION =
+SUBLEVEL = 22
+EXTRAVERSION = pre1
 
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
diff -Nru a/drivers/md/md.c b/drivers/md/md.c
--- a/drivers/md/md.c	Fri Jun 20 09:11:34 2003
+++ b/drivers/md/md.c	Fri Jun 20 09:11:34 2003
@@ -2623,6 +2623,7 @@
 		case BLKRAGET:
 		case BLKRASET:
 		case BLKFLSBUF:
+		case BLKSSZGET:
 		case BLKBSZGET:
 		case BLKBSZSET:
 			err = blk_ioctl (dev, cmd, arg);
@@ -3155,7 +3156,7 @@
 	loff_t l = *pos;
 	mddev_t *mddev;
 
-	if (l > 0x10000)
+	if (l >= 0x10000)
 		return NULL;
 	if (!l--)
 		/* header */
@@ -3166,7 +3167,9 @@
 			mddev = list_entry(tmp, mddev_t, all_mddevs);
 			return mddev;
 		}
-	return (void*)2;/* tail */
+	if (!l--)	
+		return (void*)2;/* tail */
+	return NULL;
 }
 
 static void *md_seq_next(struct seq_file *seq, void *v, loff_t *pos)
diff -Nru a/drivers/md/raid5.c b/drivers/md/raid5.c
--- a/drivers/md/raid5.c	Fri Jun 20 09:11:33 2003
+++ b/drivers/md/raid5.c	Fri Jun 20 09:11:33 2003
@@ -882,7 +882,7 @@
 	/* check if the array has lost two devices and, if so, some requests might
 	 * need to be failed
 	 */
-	if (failed > 1 && to_read+to_write) {
+	if (failed > 1 && to_read+to_write+written) {
 		for (i=disks; i--; ) {
 			/* fail all writes first */
 			if (sh->bh_write[i]) to_write--;
@@ -891,6 +891,14 @@
 				bh->b_reqnext = return_fail;
 				return_fail = bh;
 			}
+			/* and fail all 'written' */
+			if (sh->bh_written[i]) written--;
+			while ((bh = sh->bh_written[i])) {
+				sh->bh_written[i] = bh->b_reqnext;
+				bh->b_reqnext = return_fail;
+				return_fail = bh;
+			}
+
 			/* fail any reads if this device is non-operational */
 			if (!conf->disks[i].operational) {
 				spin_lock_irq(&conf->device_lock);
diff -Nru a/drivers/message/fusion/isense.c b/drivers/message/fusion/isense.c
--- a/drivers/message/fusion/isense.c	Fri Jun 20 09:11:34 2003
+++ b/drivers/message/fusion/isense.c	Fri Jun 20 09:11:34 2003
@@ -9,7 +9,7 @@
  *  Written By: Steven J. Ralston
  *  (yes I wrote some of the orig. code back in 1991!)
  *  (mailto:sjralston1@netscape.net)
- *  (mailto:Pam.Delaney@lsil.com)
+ *  (mailto:lstephen@lsil.com)
  *
  *  $Id: isense.c,v 1.33 2002/02/27 18:44:19 sralston Exp $
  */
diff -Nru a/drivers/message/fusion/linux_compat.h b/drivers/message/fusion/linux_compat.h
--- a/drivers/message/fusion/linux_compat.h	Fri Jun 20 09:11:34 2003
+++ b/drivers/message/fusion/linux_compat.h	Fri Jun 20 09:11:34 2003
@@ -248,7 +248,7 @@
 /*
  *  We use our new error handling code if the kernel version is 2.4.18 or newer.
  */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,18)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,1)
         #define MPT_SCSI_USE_NEW_EH
 #endif
 
diff -Nru a/drivers/message/fusion/mptbase.c b/drivers/message/fusion/mptbase.c
--- a/drivers/message/fusion/mptbase.c	Fri Jun 20 09:11:33 2003
+++ b/drivers/message/fusion/mptbase.c	Fri Jun 20 09:11:34 2003
@@ -47,7 +47,7 @@
  *  Copyright (c) 1999-2002 LSI Logic Corporation
  *  Originally By: Steven J. Ralston
  *  (mailto:sjralston1@netscape.net)
- *  (mailto:Pam.Delaney@lsil.com)
+ *  (mailto:lstephen@lsil.com)
  *
  *  $Id: mptbase.c,v 1.126 2002/12/16 15:28:45 pdelaney Exp $
  */
diff -Nru a/drivers/message/fusion/mptbase.h b/drivers/message/fusion/mptbase.h
--- a/drivers/message/fusion/mptbase.h	Fri Jun 20 09:11:33 2003
+++ b/drivers/message/fusion/mptbase.h	Fri Jun 20 09:11:33 2003
@@ -11,7 +11,7 @@
  *  Copyright (c) 1999-2002 LSI Logic Corporation
  *  Originally By: Steven J. Ralston
  *  (mailto:sjralston1@netscape.net)
- *  (mailto:Pam.Delaney@lsil.com)
+ *  (mailto:lstephen@lsil.com)
  *
  *  $Id: mptbase.h,v 1.144 2003/01/28 21:31:56 pdelaney Exp $
  */
@@ -80,8 +80,8 @@
 #define COPYRIGHT	"Copyright (c) 1999-2002 " MODULEAUTHOR
 #endif
 
-#define MPT_LINUX_VERSION_COMMON	"2.05.00+"
-#define MPT_LINUX_PACKAGE_NAME		"@(#)mptlinux-2.05.00+"
+#define MPT_LINUX_VERSION_COMMON	"2.05.00fix"
+#define MPT_LINUX_PACKAGE_NAME		"@(#)mptlinux-2.05.00fix"
 #define WHAT_MAGIC_STRING		"@" "(" "#" ")"
 
 #define show_mptmod_ver(s,ver)  \
diff -Nru a/drivers/message/fusion/mptctl.c b/drivers/message/fusion/mptctl.c
--- a/drivers/message/fusion/mptctl.c	Fri Jun 20 09:11:33 2003
+++ b/drivers/message/fusion/mptctl.c	Fri Jun 20 09:11:33 2003
@@ -32,7 +32,7 @@
  *  Copyright (c) 1999-2002 LSI Logic Corporation
  *  Originally By: Steven J. Ralston, Noah Romer
  *  (mailto:sjralston1@netscape.net)
- *  (mailto:Pam.Delaney@lsil.com)
+ *  (mailto:lstephen@lsil.com)
  *
  *  $Id: mptctl.c,v 1.63 2002/12/03 21:26:33 pdelaney Exp $
  */
diff -Nru a/drivers/message/fusion/mptctl.h b/drivers/message/fusion/mptctl.h
--- a/drivers/message/fusion/mptctl.h	Fri Jun 20 09:11:33 2003
+++ b/drivers/message/fusion/mptctl.h	Fri Jun 20 09:11:33 2003
@@ -18,7 +18,7 @@
  *  Copyright (c) 1999-2002 LSI Logic Corporation
  *  Originally By: Steven J. Ralston
  *  (mailto:sjralston1@netscape.net)
- *  (mailto:Pam.Delaney@lsil.com)
+ *  (mailto:lstephen@lsil.com)
  *
  *  $Id: mptctl.h,v 1.13 2002/12/03 21:26:33 pdelaney Exp $
  */
diff -Nru a/drivers/message/fusion/mptscsih.c b/drivers/message/fusion/mptscsih.c
--- a/drivers/message/fusion/mptscsih.c	Fri Jun 20 09:11:34 2003
+++ b/drivers/message/fusion/mptscsih.c	Fri Jun 20 09:11:34 2003
@@ -24,7 +24,7 @@
  *  Copyright (c) 1999-2002 LSI Logic Corporation
  *  Original author: Steven J. Ralston
  *  (mailto:sjralston1@netscape.net)
- *  (mailto:Pam.Delaney@lsil.com)
+ *  (mailto:lstephen@lsil.com)
  *
  *  $Id: mptscsih.c,v 1.106 2003/01/28 21:31:57 pdelaney Exp $
  */
@@ -2525,6 +2525,9 @@
 	cmd_len = SCpnt->cmd_len;
 	for (ii=0; ii < cmd_len; ii++)
 		pScsiReq->CDB[ii] = SCpnt->cmnd[ii];
+
+	for (ii=cmd_len; ii < 16; ii++)
+		pScsiReq->CDB[ii] = 0;
 
 	/* DataLength */
 	pScsiReq->DataLength = cpu_to_le32(datalen);
diff -Nru a/drivers/message/fusion/mptscsih.h b/drivers/message/fusion/mptscsih.h
--- a/drivers/message/fusion/mptscsih.h	Fri Jun 20 09:11:34 2003
+++ b/drivers/message/fusion/mptscsih.h	Fri Jun 20 09:11:34 2003
@@ -17,8 +17,8 @@
  *
  *  Copyright (c) 1999-2002 LSI Logic Corporation
  *  Originally By: Steven J. Ralston
- *  (mailto:netscape.net)
- *  (mailto:Pam.Delaney@lsil.com)
+ *  (mailto:sjralston1@netscape.net)
+ *  (mailto:lstephen@lsil.com)
  *
  *  $Id: mptscsih.h,v 1.22 2002/12/16 15:28:48 pdelaney Exp $
  */
diff -Nru a/drivers/message/fusion/scsi3.h b/drivers/message/fusion/scsi3.h
--- a/drivers/message/fusion/scsi3.h	Fri Jun 20 09:11:34 2003
+++ b/drivers/message/fusion/scsi3.h	Fri Jun 20 09:11:34 2003
@@ -7,7 +7,7 @@
  *  Copyright (c) 1996-2002 Steven J. Ralston
  *  Written By: Steven J. Ralston (19960517)
  *  (mailto:sjralston1@netscape.net)
- *  (mailto:Pam.Delaney@lsil.com)
+ *  (mailto:lstephen@lsil.com)
  *
  *  $Id: scsi3.h,v 1.9 2002/02/27 18:45:02 sralston Exp $
  */
diff -Nru a/fs/nfsd/nfsfh.c b/fs/nfsd/nfsfh.c
--- a/fs/nfsd/nfsfh.c	Fri Jun 20 09:11:34 2003
+++ b/fs/nfsd/nfsfh.c	Fri Jun 20 09:11:34 2003
@@ -697,33 +697,23 @@
 	error = 0;
 
 	if (!(exp->ex_flags & NFSEXP_NOSUBTREECHECK)) {
-		if (exp->ex_dentry != dentry) {
-			struct dentry *tdentry = dentry;
+		struct dentry *tdentry = dentry;
 
-			do {
-				tdentry = tdentry->d_parent;
-				if (exp->ex_dentry == tdentry)
-					break;
-				/* executable only by root and we can't be root */
-				if (current->fsuid
-				    && (exp->ex_flags & NFSEXP_ROOTSQUASH)
-				    && !(tdentry->d_inode->i_uid
-					 && (tdentry->d_inode->i_mode & S_IXUSR))
-				    && !(tdentry->d_inode->i_gid
-					 && (tdentry->d_inode->i_mode & S_IXGRP))
-				    && !(tdentry->d_inode->i_mode & S_IXOTH)
-					) {
-					error = nfserr_stale;
-					dprintk("fh_verify: no root_squashed access.\n");
-				}
-			} while ((tdentry != tdentry->d_parent));
-			if (exp->ex_dentry != tdentry) {
-				error = nfserr_stale;
-				printk("nfsd Security: %s/%s bad export.\n",
-				       dentry->d_parent->d_name.name,
-				       dentry->d_name.name);
-				goto out;
-			}
+		while (tdentry != exp->ex_dentry && !IS_ROOT(tdentry)) {
+			struct dentry *parent = tdentry->d_parent;
+
+			/* make sure parents give x permission to user */
+			error = permission(parent->d_inode, MAY_EXEC);
+			if (error)
+				break;
+			tdentry = parent;
+		}
+		if (exp->ex_dentry != tdentry) {
+			error = nfserr_stale;
+			printk("fh_verify: no root_squashed access at %s/%s.\n",
+			       dentry->d_parent->d_name.name,
+			       dentry->d_name.name);
+			goto out;
 		}
 	}
 
diff -Nru a/net/sunrpc/svcsock.c b/net/sunrpc/svcsock.c
--- a/net/sunrpc/svcsock.c	Fri Jun 20 09:11:33 2003
+++ b/net/sunrpc/svcsock.c	Fri Jun 20 09:11:33 2003
@@ -595,8 +595,17 @@
 	dprintk("svc: socket %p TCP (listen) state change %d\n",
 			sk, sk->state);
 
-	if  (sk->state != TCP_ESTABLISHED) {
-		/* Aborted connection, SYN_RECV or whatever... */
+	if  (sk->state != TCP_LISTEN) {
+		/*
+		 * This callback may called twice when a new connection
+		 * is established as a child socket inherits everything
+		 * from a parent LISTEN socket.
+		 * 1) data_ready method of the parent socket will be called
+		 *    when one of child sockets become ESTABLISHED.
+		 * 2) data_ready method of the child socket may be called
+		 *    when it receives data before the socket is accepted.
+		 * In case of 2, we should ignore it silently.
+		 */
 		goto out;
 	}
 	if (!(svsk = (struct svc_sock *) sk->user_data)) {
@@ -816,8 +825,12 @@
 		if ((len = svc_recvfrom(rqstp, &iov, 1, want)) < 0)
 			goto error;
 		svsk->sk_tcplen += len;
-		if (len < want)
-			return 0;
+		if (len < want) {
+			dprintk("svc: short recvfrom while reading record length (%d of %d)\n",
+			        len, want);
+			svc_sock_received(svsk);
+			return -EAGAIN; /* record header not complete */
+		}
 
 		svsk->sk_reclen = ntohl(svsk->sk_reclen);
 		if (!(svsk->sk_reclen & 0x80000000)) {
@@ -932,6 +945,7 @@
 svc_tcp_init(struct svc_sock *svsk)
 {
 	struct sock	*sk = svsk->sk_sk;
+	struct tcp_opt  *tp = &(sk->tp_pinfo.af_tcp);
 
 	svsk->sk_recvfrom = svc_tcp_recvfrom;
 	svsk->sk_sendto = svc_tcp_sendto;
@@ -948,6 +962,8 @@
 		svsk->sk_reclen = 0;
 		svsk->sk_tcplen = 0;
 
+		tp->nonagle = 1;        /* disable Nagle's algorithm */
+
 		/* initialise setting must have enough space to
 		 * receive and respond to one request.  
 		 * svc_tcp_recvfrom will re-adjust if necessary
@@ -957,6 +973,8 @@
 				    3 * svsk->sk_server->sv_bufsz);
 
 		set_bit(SK_CHNGBUF, &svsk->sk_flags);
+		if (sk->sk_state != TCP_ESTABLISHED) 
+			set_bit(SK_CLOSE, &svsk->sk_flags);
 	}
 
 	return 0;
