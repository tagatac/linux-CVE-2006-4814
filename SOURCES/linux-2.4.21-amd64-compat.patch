diff -urNp linux-190/arch/x86_64/config.in linux-200/arch/x86_64/config.in
--- linux-190/arch/x86_64/config.in
+++ linux-200/arch/x86_64/config.in
@@ -10,7 +10,7 @@ define_bool CONFIG_X86 y
 define_bool CONFIG_ISA n
 define_bool CONFIG_SBUS n
 
-define_bool CONFIG_UID16 y
+define_bool CONFIG_UID16 n
 define_bool CONFIG_RWSEM_GENERIC_SPINLOCK y
 define_bool CONFIG_RWSEM_XCHGADD_ALGORITHM n
 define_bool CONFIG_X86_CMPXCHG y
@@ -111,6 +111,9 @@ tristate 'Kernel support for MISC binari
 bool 'Power Management support' CONFIG_PM
 
 bool 'IA32 Emulation' CONFIG_IA32_EMULATION
+if [ "$CONFIG_IA32_EMULATION" = "y" ]; then
+  define_bool CONFIG_COMPAT y
+fi
 
 if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
    dep_bool '  ACPI support' CONFIG_ACPI $CONFIG_PM
diff -urNp linux-190/arch/x86_64/ia32/ia32_binfmt.c linux-200/arch/x86_64/ia32/ia32_binfmt.c
--- linux-190/arch/x86_64/ia32/ia32_binfmt.c
+++ linux-200/arch/x86_64/ia32/ia32_binfmt.c
@@ -1,7 +1,7 @@
 /* 
  * Written 2000,2002 by Andi Kleen. 
  * 
- * Losely based on the sparc64 and IA64 32bit emulation loaders.
+ * Loosely based on the sparc64 and IA64 32bit emulation loaders.
  * This tricks binfmt_elf.c into loading 32bit binaries using lots 
  * of ugly preprocessor tricks. Talk about very very poor man's inheritance.
  */ 
@@ -19,6 +19,8 @@
 #include <asm/sigcontext32.h>
 #include <asm/fpu32.h>
 #include <asm/i387.h>
+#include <asm/uaccess.h>
+#include <asm/ia32.h>
 
 struct file;
 struct elf_phdr; 
@@ -27,7 +29,6 @@ struct elf_phdr; 
 
 #define ELF_NAME "elf/i386"
 
-#define IA32_PAGE_OFFSET 0xFFFFe000
 #define IA32_STACK_TOP IA32_PAGE_OFFSET
 #define ELF_ET_DYN_BASE		(IA32_PAGE_OFFSET/3 + 0x1000000)
 
@@ -96,27 +97,6 @@ struct elf_prpsinfo
 	char	pr_psargs[ELF_PRARGSZ];	/* initial part of arg list */
 };
 
-static inline void elf_core_copy_regs(elf_gregset_t *elfregs, struct pt_regs *regs)
-{
-#ifdef ELF_CORE_COPY_REGS
-       ELF_CORE_COPY_REGS((*elfregs), regs)
-#else
-       BUG_ON(sizeof(*elfregs) != sizeof(*regs));
-       *(struct pt_regs *)elfregs = *regs;
-#endif
-}
-
-static inline int elf_core_copy_task_regs(struct task_struct *t, elf_gregset_t* elfregs)
-{
-#ifdef ELF_CORE_COPY_TASK_REGS
-
-       return ELF_CORE_COPY_TASK_REGS(t, elfregs);
-#endif
-       return 0;
-}
-
-
-
 #define __STR(x) #x
 #define STR(x) __STR(x)
 
@@ -145,15 +125,68 @@ static inline int elf_core_copy_task_reg
 
 #define user user32
 
-#define dump_fpu dump_fpu_ia32
-
 #define __ASM_X86_64_ELF_H 1
-#include <asm/ia32.h>
+//#include <asm/ia32.h>
 #include <linux/elf.h>
 
 typedef struct user_i387_ia32_struct elf_fpregset_t;
 typedef struct user32_fxsr_struct elf_fpxregset_t;
 
+
+static inline void elf_core_copy_regs(elf_gregset_t *elfregs, struct pt_regs *regs)
+{
+	ELF_CORE_COPY_REGS((*elfregs), regs)
+}
+
+static inline int elf_core_copy_task_regs(struct task_struct *t, elf_gregset_t* elfregs)
+{
+	struct pt_regs *pp = (struct pt_regs *)(t->thread.rsp0);
+	ELF_CORE_COPY_REGS((*elfregs), pp);
+	/* fix wrong segments */
+	(*elfregs)[7] = t->thread.ds;
+	(*elfregs)[9] = t->thread.fsindex;
+	(*elfregs)[10] = t->thread.gsindex;
+	(*elfregs)[8] = t->thread.es;
+	return 1;
+}
+
+static inline int
+elf_core_copy_task_fpregs(struct task_struct *tsk, elf_fpregset_t *fpu)
+{
+	struct _fpstate_ia32 *fpstate = (void*)fpu;
+	struct pt_regs *regs = (struct pt_regs *)(tsk->thread.rsp0);
+	mm_segment_t oldfs = get_fs();
+	int ret;
+
+	if (!tsk->used_math)
+		return 0;
+	--regs;
+	if (tsk == current)
+		unlazy_fpu(tsk);
+	set_fs(KERNEL_DS);
+	ret = save_i387_ia32(tsk, fpstate, regs, 1);
+	/* Correct for i386 bug. It puts the fop into the upper 16bits of
+	   the tag word (like FXSAVE), not into the fcs*/
+	fpstate->cssel |= fpstate->tag & 0xffff0000;
+	set_fs(oldfs);
+	return ret;
+}
+
+#define ELF_CORE_COPY_XFPREGS 1
+static inline int
+elf_core_copy_task_xfpregs(struct task_struct *t, elf_fpxregset_t *xfpu)
+{
+	struct pt_regs *regs = ((struct pt_regs *)(t->thread.rsp0))-1;
+	if (!t->used_math)
+		return 0;
+	if (t == current)
+		unlazy_fpu(t);
+	memcpy(xfpu, &t->thread.i387.fxsave, sizeof(elf_fpxregset_t));
+	xfpu->fcs = regs->cs;
+	xfpu->fos = t->thread.ds; /* right? */
+	return 1;
+}
+
 #undef elf_check_arch
 #define elf_check_arch(x) \
 	((x)->e_machine == EM_386)
@@ -192,8 +225,8 @@ extern void load_gs_index(unsigned);
 #undef start_thread
 #define start_thread(regs,new_rip,new_rsp) do { \
 	asm volatile("movl %0,%%fs": :"r" (0)); \
-	load_gs_index(0);	\
 	asm volatile("movl %0,%%es; movl %0,%%ds": :"r" (__USER32_DS)); \
+	load_gs_index(0);	\
 	(regs)->rip = (new_rip); \
 	(regs)->rsp = (new_rsp); \
 	(regs)->eflags = 0x200; \
@@ -307,23 +340,3 @@ elf32_map (struct file *filep, unsigned 
 	return(map_addr);
 }
 
-int dump_fpu_ia32(struct pt_regs *regs, elf_fpregset_t *fp)
-{
-	struct _fpstate_ia32 *fpu = (void*)fp; 
-	struct task_struct *tsk = current;
-	mm_segment_t oldfs = get_fs();
-	int ret;
-
-	if (!tsk->used_math) 
-		return 0;
-	if (!(tsk->thread.flags & THREAD_IA32))
-		BUG(); 
-	unlazy_fpu(tsk);
-	set_fs(KERNEL_DS); 
-	ret = save_i387_ia32(current, fpu, regs, 1);
-	/* Correct for i386 bug. It puts the fop into the upper 16bits of 
-	   the tag word (like FXSAVE), not into the fcs*/ 
-	fpu->cssel |= fpu->tag & 0xffff0000; 
-	set_fs(oldfs); 
-	return ret; 
-}
diff -urNp linux-190/arch/x86_64/ia32/ia32_ioctl.c linux-200/arch/x86_64/ia32/ia32_ioctl.c
--- linux-190/arch/x86_64/ia32/ia32_ioctl.c
+++ linux-200/arch/x86_64/ia32/ia32_ioctl.c
@@ -63,8 +63,6 @@
 #include <net/bluetooth/rfcomm.h>
 #if defined(CONFIG_BLK_DEV_LVM) || defined(CONFIG_BLK_DEV_LVM_MODULE)
 /* Ugh. This header really is not clean */
-#define min min
-#define max max
 #include <linux/lvm.h>
 #endif /* LVM */
 
@@ -2740,19 +2738,21 @@ static int ioc_settimeout(unsigned int f
 #endif
 static int tiocgdev(unsigned fd, unsigned cmd,  unsigned int *ptr) 
 { 
-
 	struct file *file = fget(fd);
 	struct tty_struct *real_tty;
+	int err;
 
-	if (!fd)
+	if (!file)
 		return -EBADF;
-	if (file->f_op->ioctl != tty_ioctl)
-		return -EINVAL; 
-	real_tty = (struct tty_struct *)file->private_data;
-	if (!real_tty) 	
-		return -EINVAL; 
-	return put_user(kdev_t_to_nr(real_tty->device), ptr); 
-} 
+
+	if (file->f_op->ioctl != tty_ioctl ||
+	    !(real_tty = (struct tty_struct *)file->private_data))
+		err = -EINVAL;
+	else
+		err = put_user(kdev_t_to_nr(real_tty->device), ptr);
+	fput(file);
+	return err;
+}
 
 
 struct raw32_config_request 
diff -urNp linux-190/arch/x86_64/ia32/ia32_signal.c linux-200/arch/x86_64/ia32/ia32_signal.c
--- linux-190/arch/x86_64/ia32/ia32_signal.c
+++ linux-200/arch/x86_64/ia32/ia32_signal.c
@@ -288,16 +288,8 @@ asmlinkage long sys32_rt_sigreturn(struc
 	if (ia32_restore_sigcontext(&regs, &frame->uc.uc_mcontext, &eax))
 		goto badframe;
 
-	if (__copy_from_user(&st, &frame->uc.uc_stack, sizeof(st)))
+	if (sys32_sigaltstack(&frame->uc.uc_stack, NULL, regs) == -EFAULT)
 		goto badframe;
-	/* It is more difficult to avoid calling this function than to
-	   call it and ignore errors.  */
-	{
-		mm_segment_t oldds = get_fs(); 
-		set_fs(KERNEL_DS); 
-		do_sigaltstack(&st, NULL, regs.rsp);
-		set_fs(oldds);  
-	}
 
 	return eax;
 
@@ -372,7 +364,7 @@ get_sigframe(struct k_sigaction *ka, str
 
 	/* This is the X/Open sanctioned signal stack switching.  */
 	if (ka->sa.sa_flags & SA_ONSTACK) {
-		if (! on_sig_stack(rsp))
+		if (sas_ss_flags(rsp) == 0)
 			rsp = current->sas_ss_sp + current->sas_ss_size;
 	}
 
diff -urNp linux-190/arch/x86_64/ia32/ia32entry.S linux-200/arch/x86_64/ia32/ia32entry.S
--- linux-190/arch/x86_64/ia32/ia32entry.S
+++ linux-200/arch/x86_64/ia32/ia32entry.S
@@ -72,7 +72,7 @@ ia32_tracesys:			 
 	movq %rsp,%rdi        /* &pt_regs -> arg1 */
 	call syscall_trace
 	LOAD_ARGS ARGOFFSET  /* reload args from stack in case ptrace changed it */
-	addq $ARGOFFSET,%rsp	
+	RESTORE_REST
 	cmpl $(IA32_NR_syscalls),%eax
 	jae  1f
 	IA32_ARG_FIXUP
@@ -82,7 +82,7 @@ ia32_tracesys_end:	
 1:	SAVE_REST
 	movq %rsp,%rdi		/* &pt_regs -> arg1 */ 
 	call syscall_trace
-	addq $ARGOFFSET,%rsp
+	RESTORE_REST
 	jmp int_ret_from_sys_call
 		
 ia32_badsys:
@@ -221,7 +221,7 @@ ia32_sys_call_table:
 	.quad sys_reboot
 	.quad sys32_oldreaddir
 	.quad sys32_mmap		/* 90 */
-	.quad sys_munmap
+	.quad sys32_munmap
 	.quad sys_truncate
 	.quad sys_ftruncate
 	.quad sys_fchmod
@@ -291,7 +291,7 @@ ia32_sys_call_table:
 	.quad sys_sched_yield
 	.quad sys_sched_get_priority_max
 	.quad sys_sched_get_priority_min  /* 160 */
-	.quad sys_sched_rr_get_interval
+	.quad sys32_sched_rr_get_interval
 	.quad sys32_nanosleep
 	.quad sys_mremap
 	.quad sys_setresuid16
@@ -323,8 +323,8 @@ ia32_sys_call_table:
 	.quad stub32_vfork            /* 190 */
 	.quad sys32_getrlimit
 	.quad sys32_mmap2
-	.quad sys_truncate
-	.quad sys_ftruncate
+	.quad sys32_truncate64
+	.quad sys32_ftruncate64
 	.quad sys32_stat64		/* 195 */
 	.quad sys32_lstat64
 	.quad sys32_fstat64
@@ -370,11 +370,11 @@ ia32_sys_call_table:
 	.quad sys_fremovexattr
 	.quad sys_tkill
 	.quad sys_sendfile64
-	.quad quiet_ni_syscall  /* 240 futex */
-	.quad quiet_ni_syscall  /* sched_setaffinity */
-	.quad quiet_ni_syscall  /* sched_getaffinity */	
-	.quad sys_ni_syscall
-	.quad sys_ni_syscall
+	.quad compat_sys_futex	/* 240 */
+	.quad compat_sys_sched_setaffinity
+	.quad compat_sys_sched_getaffinity
+	.quad sys32_set_thread_area
+	.quad sys32_get_thread_area
 	.quad sys_ni_syscall	/* 245 */
 	.quad sys_ni_syscall
 	.quad sys_ni_syscall
@@ -382,10 +382,25 @@ ia32_sys_call_table:
 	.quad sys_ni_syscall
 	.quad sys_ni_syscall	/* 250 */
 	.quad sys_ni_syscall /* free_huge_pages */
-	.quad sys_ni_syscall /* exit_group */
+	.quad sys_exit_group /* exit_group */
 	.quad sys_lookup_dcookie
 	.quad sys_ni_syscall
 	.quad sys_ni_syscall	/* 255 */
+	.quad sys_ni_syscall
+	.quad sys_ni_syscall
+	.quad sys_set_tid_address
+	.quad sys_ni_syscall
+	.quad sys_ni_syscall	/* 260 */
+	.quad sys_ni_syscall
+	.quad sys_ni_syscall
+	.quad sys_ni_syscall
+	.quad sys_ni_syscall
+	.quad sys_ni_syscall	/* 265 */
+	.quad sys_ni_syscall
+	.quad sys_ni_syscall
+	.quad sys_ni_syscall
+	.quad sys_ni_syscall
+	.quad sys_tgkill	/* 270 */
 
 ia32_syscall_end:		
 	.rept IA32_NR_syscalls-(ia32_syscall_end-ia32_sys_call_table)/8
diff -urNp linux-190/arch/x86_64/ia32/ptrace32.c linux-200/arch/x86_64/ia32/ptrace32.c
--- linux-190/arch/x86_64/ia32/ptrace32.c
+++ linux-200/arch/x86_64/ia32/ptrace32.c
@@ -15,7 +15,7 @@
 #include <linux/stddef.h>
 #include <linux/sched.h>
 #include <linux/mm.h>
-#include <asm/ptrace.h>
+#include <linux/ptrace.h>
 #include <asm/uaccess.h>
 #include <asm/user32.h>
 #include <asm/user.h>
@@ -25,6 +25,10 @@
 #include <asm/fpu32.h>
 #include <linux/mm.h>
 
+/* determines which flags the user has access to. */
+/* 1 = access 0 = no access */
+#define FLAG_MASK 0x44dd5UL
+
 #define R32(l,q) \
 	case offsetof(struct user32, regs.l): stack[offsetof(struct pt_regs, q)/8] = val; break
 
@@ -69,9 +73,12 @@ static int putreg32(struct task_struct *
 	R32(eip, rip);
 	R32(esp, rsp);
 
-	case offsetof(struct user32, regs.eflags): 
-		stack[offsetof(struct pt_regs, eflags)/8] = val & 0x44dd5; 
+	case offsetof(struct user32, regs.eflags): {
+		__u64 *flags = &stack[offsetof(struct pt_regs, eflags)/8];
+		val &= FLAG_MASK;
+		*flags = val | (*flags & ~FLAG_MASK);
 		break;
+	}
 
 	case offsetof(struct user32, u_debugreg[4]): 
 	case offsetof(struct user32, u_debugreg[5]):
@@ -178,14 +185,12 @@ static struct task_struct *find_target(i
 			goto out;
 		*err = ptrace_check_attach(child, request == PTRACE_KILL); 
 		if (*err < 0) 
-				goto out;
-		return child; 
-	} 
-
- out:
-	put_task_struct(child);
-	return NULL; 
-	
+			goto out;
+		return child;
+out:
+		put_task_struct(child);
+	}
+	return NULL;
 } 
 
 extern asmlinkage long sys_ptrace(long request, long pid, unsigned long addr, unsigned long data);
@@ -221,6 +226,7 @@ asmlinkage long sys32_ptrace(long reques
 	case PTRACE_GETFPREGS:
 	case PTRACE_SETFPXREGS:
 	case PTRACE_GETFPXREGS:
+	case PTRACE_GETEVENTMSG:
 		break;
 		
 	default:
@@ -337,6 +343,10 @@ asmlinkage long sys32_ptrace(long reques
 		break; 
 	} 
 
+	case PTRACE_GETEVENTMSG:
+		ret = put_user(child->ptrace_message,(unsigned int *)(u64)data);
+		break;
+
 	default:
 		ret = -EINVAL;
 		break;
diff -urNp linux-190/arch/x86_64/ia32/sys_ia32.c linux-200/arch/x86_64/ia32/sys_ia32.c
--- linux-190/arch/x86_64/ia32/sys_ia32.c
+++ linux-200/arch/x86_64/ia32/sys_ia32.c
@@ -93,8 +93,8 @@ putstat(struct stat32 *ubuf, struct stat
 	    __put_user (kbuf->st_ino, &ubuf->st_ino) ||
 	    __put_user (kbuf->st_mode, &ubuf->st_mode) ||
 	    __put_user (kbuf->st_nlink, &ubuf->st_nlink) ||
-	    __put_user (kbuf->st_uid, &ubuf->st_uid) ||
-	    __put_user (kbuf->st_gid, &ubuf->st_gid) ||
+	    __put_user (high2lowuid(kbuf->st_uid), &ubuf->st_uid) ||
+	    __put_user (high2lowgid(kbuf->st_gid), &ubuf->st_gid) ||
 	    __put_user (kbuf->st_rdev, &ubuf->st_rdev) ||
 	    __put_user (kbuf->st_size, &ubuf->st_size) ||
 	    __put_user (kbuf->st_atime, &ubuf->st_atime) ||
@@ -157,6 +157,19 @@ sys32_newfstat(unsigned int fd, struct s
 	return ret;
 }
 
+asmlinkage long
+sys32_truncate64(char * filename, unsigned long offset_low, unsigned long offset_high)
+{
+       return sys_truncate(filename, ((loff_t) offset_high << 32) | offset_low);
+}
+
+
+asmlinkage long
+sys32_ftruncate64(unsigned int fd, unsigned long offset_low, unsigned long offset_high)
+{
+       return sys_ftruncate(fd, ((loff_t) offset_high << 32) | offset_low);
+}
+
 /* Another set for IA32/LFS -- x86_64 struct stat is different due to 
    support for 64bit inode numbers. */
 
@@ -1225,9 +1238,14 @@ sys32_wait4(__kernel_pid_t32 pid, unsign
 		set_fs (KERNEL_DS);
 		ret = sys_wait4(pid, stat_addr ? &status : NULL, options, &r);
 		set_fs (old_fs);
-		if (put_rusage (ru, &r)) return -EFAULT;
-		if (stat_addr && put_user (status, stat_addr))
-			return -EFAULT;
+
+		if (!ret)
+		{
+			if (put_rusage (ru, &r))
+				return -EFAULT;
+			if (stat_addr && put_user (status, stat_addr))
+				return -EFAULT;
+		}
 		return ret;
 	}
 }
@@ -1731,7 +1749,8 @@ sys32_rt_sigtimedwait(sigset32_t *uthese
 			return -EFAULT;
 	}
 	set_fs (KERNEL_DS);
-	ret = sys_rt_sigtimedwait(&s, &info, &t, sigsetsize);
+	ret = sys_rt_sigtimedwait(&s, uinfo ? &info : NULL, uts ? &t : NULL,
+			sigsetsize);
 	set_fs (old_fs);
 	if (ret >= 0 && uinfo) {
 		if (copy_to_user (uinfo, siginfo64to32(&info32, &info),
@@ -2055,6 +2074,14 @@ asmlinkage long sys32_mmap2(unsigned lon
 	return error;
 }
 
+asmlinkage long sys32_munmap(unsigned long addr, size_t len)
+{
+	if (addr > TASK_SIZE_32 || len > TASK_SIZE_32 - addr)
+		return -EINVAL;
+
+	return sys_munmap(addr, len);
+}
+
 asmlinkage long sys32_olduname(struct oldold_utsname * name)
 {
 	int error;
@@ -2122,7 +2149,7 @@ asmlinkage long sys32_ustat(dev_t dev, s
 	return ret;
 } 
 
-static int nargs(u32 src, char **dst) 
+static int nargs(u32 src, char **dst, int max)
 { 
 	int cnt;
 	u32 val; 
@@ -2132,12 +2159,12 @@ static int nargs(u32 src, char **dst) 
 		int ret = get_user(val, (__u32 *)(u64)src); 
 		if (ret)
 			return ret;
+		if (cnt > max)
+			return -E2BIG;
 		if (dst)
 			dst[cnt] = (char *)(u64)val; 
 		cnt++;
 		src += 4;
-		if (cnt >= (MAX_ARG_PAGES*PAGE_SIZE)/sizeof(void*))
-			return -E2BIG; 
 	} while(val); 
 	if (dst)
 		dst[cnt-1] = 0; 
@@ -2152,15 +2179,16 @@ asmlinkage long sys32_execve(char *name,
 	int ret;
 	unsigned sz = 0; 
 	
+	/* can actually allocate up to 2*MAX_ARG_PAGES */
 	if (argv) {
-	na = nargs(argv, NULL); 
+	na = nargs(argv, NULL, (MAX_ARG_PAGES*PAGE_SIZE) / sizeof(char *) - 1);
 	if (na < 0) 
-		return -EFAULT; 
+		return na;
 	} 	
 	if (envp) { 
-	ne = nargs(envp, NULL); 
+	ne = nargs(envp, NULL, (MAX_ARG_PAGES*PAGE_SIZE) / sizeof(char *) - 1);
 	if (ne < 0) 
-		return -EFAULT; 
+		return ne;
 	}
 
 	if (argv || envp) { 
@@ -2174,13 +2202,13 @@ asmlinkage long sys32_execve(char *name,
 	} 
 	
 	if (argv) { 
-	ret = nargs(argv, buf);
+	ret = nargs(argv, buf, na - 1);
 	if (ret < 0)
 		goto free;
 	}
 
 	if (envp) { 
-	ret = nargs(envp, buf + na); 
+	ret = nargs(envp, buf + na, ne - 1);
 	if (ret < 0)
 		goto free; 
 	}
@@ -2215,11 +2243,15 @@ asmlinkage long sys32_fork(struct pt_reg
 	return do_fork(SIGCHLD, regs.rsp, &regs, 0, NULL, NULL);
 }
 
-asmlinkage long sys32_clone(unsigned int clone_flags, unsigned int newsp, struct pt_regs regs)
+asmlinkage long sys32_clone(struct pt_regs regs)
 {
+	unsigned int newsp = regs.rcx;
+	void *parent_tid = (void *)regs.rdx;
+	void *child_tid = (void *)regs.rdi;
 	if (!newsp)
 		newsp = regs.rsp;
-	return do_fork(clone_flags, newsp, &regs, 0, NULL, NULL);
+	return do_fork(regs.rbx & ~CLONE_IDLETASK, newsp, &regs, 0,
+		       parent_tid, child_tid);
 }
 
 /*
@@ -2234,7 +2266,8 @@ asmlinkage long sys32_clone(unsigned int
  */
 asmlinkage long sys32_vfork(struct pt_regs regs)
 {
-	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs.rsp, &regs, 0, NULL, NULL);
+	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs.rsp, &regs, 0, 
+		       NULL, NULL);
 }
 
 /*
@@ -2557,6 +2590,161 @@ long sys32_vm86_warning(void)
 	return -ENOSYS ;
 } 
 
+
+#ifndef CONFIG_UID16
+/* If the main kernel doesn't have UID16 support, then we define our
+ * own versions of the 16-bit UID compatibility functions here...
+ */
+
+extern asmlinkage long sys_chown(const char *, uid_t,gid_t);
+extern asmlinkage long sys_lchown(const char *, uid_t,gid_t);
+extern asmlinkage long sys_fchown(unsigned int, uid_t,gid_t);
+extern asmlinkage long sys_setregid(gid_t, gid_t);
+extern asmlinkage long sys_setgid(gid_t);
+extern asmlinkage long sys_setreuid(uid_t, uid_t);
+extern asmlinkage long sys_setuid(uid_t);
+extern asmlinkage long sys_setresuid(uid_t, uid_t, uid_t);
+extern asmlinkage long sys_setresgid(gid_t, gid_t, gid_t);
+extern asmlinkage long sys_setfsuid(uid_t);
+extern asmlinkage long sys_setfsgid(gid_t);
+ 
+asmlinkage long sys_chown16(const char * filename, u16 user, u16 group)
+{
+	return sys_chown(filename, low2highuid(user), low2highgid(group));
+}
+
+asmlinkage long sys_lchown16(const char * filename, u16 user, u16 group)
+{
+	return sys_lchown(filename, low2highuid(user), low2highgid(group));
+}
+
+asmlinkage long sys_fchown16(unsigned int fd, u16 user, u16 group)
+{
+	return sys_fchown(fd, low2highuid(user), low2highgid(group));
+}
+
+asmlinkage long sys_setregid16(u16 rgid, u16 egid)
+{
+	return sys_setregid(low2highgid(rgid), low2highgid(egid));
+}
+
+asmlinkage long sys_setgid16(u16 gid)
+{
+	return sys_setgid((gid_t)gid);
+}
+
+asmlinkage long sys_setreuid16(u16 ruid, u16 euid)
+{
+	return sys_setreuid(low2highuid(ruid), low2highuid(euid));
+}
+
+asmlinkage long sys_setuid16(u16 uid)
+{
+	return sys_setuid((uid_t)uid);
+}
+
+asmlinkage long sys_setresuid16(u16 ruid, u16 euid, u16 suid)
+{
+	return sys_setresuid(low2highuid(ruid), low2highuid(euid),
+		low2highuid(suid));
+}
+
+asmlinkage long sys_getresuid16(u16 *ruid, u16 *euid, u16 *suid)
+{
+	int retval;
+
+	if (!(retval = put_user(high2lowuid(current->uid), ruid)) &&
+	    !(retval = put_user(high2lowuid(current->euid), euid)))
+		retval = put_user(high2lowuid(current->suid), suid);
+
+	return retval;
+}
+
+asmlinkage long sys_setresgid16(u16 rgid, u16 egid, u16 sgid)
+{
+	return sys_setresgid(low2highgid(rgid), low2highgid(egid),
+		low2highgid(sgid));
+}
+
+asmlinkage long sys_getresgid16(u16 *rgid, u16 *egid, u16 *sgid)
+{
+	int retval;
+
+	if (!(retval = put_user(high2lowgid(current->gid), rgid)) &&
+	    !(retval = put_user(high2lowgid(current->egid), egid)))
+		retval = put_user(high2lowgid(current->sgid), sgid);
+
+	return retval;
+}
+
+asmlinkage long sys_setfsuid16(u16 uid)
+{
+	return sys_setfsuid((uid_t)uid);
+}
+
+asmlinkage long sys_setfsgid16(u16 gid)
+{
+	return sys_setfsgid((gid_t)gid);
+}
+
+asmlinkage long sys_getgroups16(int gidsetsize, u16 *grouplist)
+{
+	u16 groups[NGROUPS];
+	int i,j;
+
+	if (gidsetsize < 0)
+		return -EINVAL;
+	i = current->ngroups;
+	if (gidsetsize) {
+		if (i > gidsetsize)
+			return -EINVAL;
+		for(j=0;j<i;j++)
+			groups[j] = current->groups[j];
+		if (copy_to_user(grouplist, groups, sizeof(u16)*i))
+			return -EFAULT;
+	}
+	return i;
+}
+
+asmlinkage long sys_setgroups16(int gidsetsize, u16 *grouplist)
+{
+	u16 groups[NGROUPS];
+	int i;
+
+	if (!capable(CAP_SETGID))
+		return -EPERM;
+	if ((unsigned) gidsetsize > NGROUPS)
+		return -EINVAL;
+	if (copy_from_user(groups, grouplist, gidsetsize * sizeof(u16)))
+		return -EFAULT;
+	for (i = 0 ; i < gidsetsize ; i++)
+		current->groups[i] = (gid_t)groups[i];
+	current->ngroups = gidsetsize;
+	return 0;
+}
+
+asmlinkage long sys_getuid16(void)
+{
+	return high2lowuid(current->uid);
+}
+
+asmlinkage long sys_geteuid16(void)
+{
+	return high2lowuid(current->euid);
+}
+
+asmlinkage long sys_getgid16(void)
+{
+	return high2lowgid(current->gid);
+}
+
+asmlinkage long sys_getegid16(void)
+{
+	return high2lowgid(current->egid);
+}
+
+#endif
+
 /* This only triggers an i686 uname */
 struct exec_domain ia32_exec_domain = { 
 	name: "linux/uname-i686",
diff -urNp linux-190/arch/x86_64/ia32/tls32.c linux-200/arch/x86_64/ia32/tls32.c
--- linux-190/arch/x86_64/ia32/tls32.c
+++ linux-200/arch/x86_64/ia32/tls32.c
@@ -72,7 +72,7 @@ int do_set_thread_area(struct thread_str
 	return 0;
 }
 
-asmlinkage int sys_set_thread_area(struct user_desc *u_info)
+asmlinkage long sys32_set_thread_area(struct user_desc *u_info)
 { 
 	return do_set_thread_area(&current->thread, u_info); 
 } 
@@ -129,7 +129,7 @@ int do_get_thread_area(struct thread_str
 	return 0;
 }
 
-asmlinkage int sys_get_thread_area(struct user_desc *u_info)
+asmlinkage long sys32_get_thread_area(struct user_desc *u_info)
 {
 	return do_get_thread_area(&current->thread, u_info);
 } 
diff -urNp linux-190/arch/x86_64/kernel/x8664_ksyms.c linux-200/arch/x86_64/kernel/x8664_ksyms.c
--- linux-190/arch/x86_64/kernel/x8664_ksyms.c
+++ linux-200/arch/x86_64/kernel/x8664_ksyms.c
@@ -43,7 +43,7 @@ EXPORT_SYMBOL(drive_info);
 
 /* platform dependent support */
 EXPORT_SYMBOL(boot_cpu_data);
-EXPORT_SYMBOL(dump_fpu);
+//EXPORT_SYMBOL(dump_fpu);
 EXPORT_SYMBOL(__ioremap);
 EXPORT_SYMBOL(iounmap);
 EXPORT_SYMBOL(enable_irq);
@@ -212,6 +212,8 @@ EXPORT_SYMBOL(sys_delete_module);
 EXPORT_SYMBOL(sys_sync);
 EXPORT_SYMBOL(sys_pause);
 EXPORT_SYMBOL(sys_setsid);	/* Rather dubious */
+extern long sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg);
+EXPORT_SYMBOL(sys_ioctl);
 
 
 EXPORT_SYMBOL(memcpy_fromio);
diff -urNp linux-190/include/asm-x86_64/i387.h linux-200/include/asm-x86_64/i387.h
--- linux-190/include/asm-x86_64/i387.h
+++ linux-200/include/asm-x86_64/i387.h
@@ -16,6 +16,7 @@
 #include <asm/processor.h>
 #include <asm/sigcontext.h>
 #include <asm/user.h>
+#include <asm/uaccess.h>
 
 extern void init_fpu(struct task_struct *child);
 extern int save_i387(struct _fpstate *buf);
@@ -52,12 +53,6 @@ extern int get_fpregs( struct user_i387_
 extern int set_fpregs( struct task_struct *tsk,
 		       struct user_i387_struct *buf );
 
-/*
- * FPU state for core dumps...
- */
-extern int dump_fpu( struct pt_regs *regs,
-		     struct user_i387_struct *fpu );
-
 /* 
  * i387 state interaction
  */
@@ -85,6 +80,8 @@ static inline int restore_fpu_checking(s
 		     ".previous"
 		     : [err] "=r" (err)
 		     : [fx] "r" (fx), "0" (0)); 
+	if (unlikely(err))
+		init_fpu(current);
 	return err;
 } 
 
@@ -103,6 +100,8 @@ static inline int save_i387_checking(str
 		     ".previous"
 		     : [err] "=r" (err)
 		     : [fx] "r" (fx), "0" (0)); 
+	if (unlikely(err))
+		__clear_user(fx, sizeof(struct i387_fxsave_struct));
 	return err;
 } 
 
diff -urNp linux-190/include/asm-x86_64/ia32_unistd.h linux-200/include/asm-x86_64/ia32_unistd.h
--- linux-190/include/asm-x86_64/ia32_unistd.h
+++ linux-200/include/asm-x86_64/ia32_unistd.h
@@ -249,7 +249,11 @@
 #define __NR_ia32_futex		240
 #define __NR_ia32_sched_setaffinity	241
 #define __NR_ia32_sched_getaffinity	242
+#define __NR_ia32_set_thread_area	243
+#define __NR_ia32_get_thread_area	244
+#define __NR_ia32_exit_group		252
+#define __NR_ia32_set_tid_address	258
 
-#define IA32_NR_syscalls 245
+#define IA32_NR_syscalls 271
 
 #endif /* _ASM_X86_64_IA32_UNISTD_H_ */
diff -urNp linux-190/include/asm-x86_64/processor.h linux-200/include/asm-x86_64/processor.h
--- linux-190/include/asm-x86_64/processor.h
+++ linux-200/include/asm-x86_64/processor.h
@@ -266,10 +266,16 @@ static inline void clear_in_cr4 (unsigne
  */
 #define TASK_SIZE	(0x0000007fc0000000)
 
+/*
+ *  32 bit user space process size - determined by personality
+ */
+#define IA32_PAGE_OFFSET ((current->personality & ADDR_LIMIT_3GB) ? 0xc0000000 : 0xFFFFe000)
+#define TASK_SIZE_32	IA32_PAGE_OFFSET
+
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
  */
-#define TASK_UNMAPPED_32 0xa0000000
+#define TASK_UNMAPPED_32 0x40000000
 #define TASK_UNMAPPED_64 (TASK_SIZE/3) 
 #define TASK_UNMAPPED_BASE	\
 	((current->thread.flags & THREAD_IA32) ? TASK_UNMAPPED_32 : TASK_UNMAPPED_64)  
diff -urNp linux-190/include/asm-x86_64/unistd.h linux-200/include/asm-x86_64/unistd.h
--- linux-190/include/asm-x86_64/unistd.h
+++ linux-200/include/asm-x86_64/unistd.h
@@ -459,16 +459,16 @@ __SYSCALL(__NR_removexattr, sys_ni_sysca
 __SYSCALL(__NR_lremovexattr, sys_ni_syscall) 
 #define __NR_fremovexattr	199
 __SYSCALL(__NR_fremovexattr, sys_ni_syscall) 
-#define __NR_tkill	200	/* 2.5 only */
-__SYSCALL(__NR_tkill, sys_ni_syscall) 
+#define __NR_tkill	200
+__SYSCALL(__NR_tkill, sys_tkill) 
 #define __NR_time		201
 __SYSCALL(__NR_time, sys_time)
-#define __NR_futex		202 /* 2.5 only */
-__SYSCALL(__NR_futex, sys_ni_syscall)
+#define __NR_futex		202
+__SYSCALL(__NR_futex, sys_futex)
 #define __NR_sched_setaffinity    203
-__SYSCALL(__NR_sched_setaffinity, sys_ni_syscall)
+__SYSCALL(__NR_sched_setaffinity, sys_sched_setaffinity)
 #define __NR_sched_getaffinity     204
-__SYSCALL(__NR_sched_getaffinity, sys_ni_syscall)
+__SYSCALL(__NR_sched_getaffinity, sys_sched_getaffinity)
 #define __NR_set_thread_area	205
 __SYSCALL(__NR_set_thread_area, sys_ni_syscall)
 #define __NR_io_setup	206
@@ -495,6 +495,8 @@ __SYSCALL(__NR_epoll_wait, sys_ni_syscal
 __SYSCALL(__NR_remap_file_pages, sys_ni_syscall)
 #define __NR_getdents64 217
 __SYSCALL(__NR_getdents64, sys_getdents64)
+#define __NR_set_tid_address  218
+__SYSCALL(__NR_set_tid_address, sys_set_tid_address)
 #define __NR_exit_group 231
 __SYSCALL(__NR_exit_group, sys_exit_group)
 #define __NR_UNDEF_1 232
diff -urNp linux-190/kernel/ksyms.c linux-200/kernel/ksyms.c
--- linux-190/kernel/ksyms.c
+++ linux-200/kernel/ksyms.c
@@ -553,7 +553,10 @@ EXPORT_SYMBOL(event);
 EXPORT_SYMBOL(brw_page);
 EXPORT_SYMBOL(__inode_dir_notify);
 
-#ifdef CONFIG_UID16
+/* Always export these for x86_64 for compatibility with previous 
+ * RHEL3 kernels 
+ */
+#if defined(CONFIG_UID16) || defined(__x86_64__)
 EXPORT_SYMBOL(overflowuid);
 EXPORT_SYMBOL(overflowgid);
 #endif
