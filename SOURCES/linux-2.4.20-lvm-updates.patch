diff -urNp linux-5110/drivers/md/lvm-snap.c linux-5120/drivers/md/lvm-snap.c
--- linux-5110/drivers/md/lvm-snap.c
+++ linux-5120/drivers/md/lvm-snap.c
@@ -2,7 +2,7 @@
  * kernel/lvm-snap.c
  *
  * Copyright (C) 2000 Andrea Arcangeli <andrea@suse.de> SuSE
- *               2000 - 2002 Heinz Mauelshagen, Sistina Software
+ *               2000 - 2003 Heinz Mauelshagen, Sistina Software
  *
  * LVM snapshot driver is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -42,6 +42,8 @@
  *    15/10/2001 - fix snapshot alignment problem [CM]
  *               - fix snapshot full oops (always check lv_block_exception) [CM]
  *    26/06/2002 - support for new list_move macro [patch@luckynet.dynu.com]
+ *    26/07/2002 - removed conditional list_move macro because we will
+ *                 discontinue LVM1 before 2.6 anyway
  *
  */
 
@@ -111,8 +113,9 @@ lvm_find_exception_table(kdev_t org_dev,
 	unsigned long mask = lv->lv_snapshot_hash_mask;
 	int chunk_size = lv->lv_chunk_size;
 	lv_block_exception_t * ret;
-	int i = 0;
 
+	if (!hash_table)
+		BUG();
 	hash_table = &hash_table[hashfn(org_dev, org_start, mask, chunk_size)];
 	ret = NULL;
 	for (next = hash_table->next; next != hash_table; next = next->next)
@@ -123,20 +126,9 @@ lvm_find_exception_table(kdev_t org_dev,
 		if (exception->rsector_org == org_start &&
 		    exception->rdev_org == org_dev)
 		{
-			if (i)
-			{
-				/* fun, isn't it? :) */
-#ifdef	list_move
-				list_move(next, hash_table);
-#else
-				list_del(next);
-				list_add(next, hash_table);
-#endif
-			}
 			ret = exception;
 			break;
 		}
-		i++;
 	}
 	return ret;
 }
@@ -544,15 +536,14 @@ out:
 
 int lvm_snapshot_alloc(lv_t * lv_snap)
 {
-	int ret, max_sectors;
+	int ret;
 
 	/* allocate kiovec to do chunk io */
 	ret = alloc_kiovec(1, &lv_snap->lv_iobuf);
 	if (ret) goto out;
 
-	max_sectors = KIO_MAX_SECTORS << (PAGE_SHIFT-9);
-
-	ret = lvm_snapshot_alloc_iobuf_pages(lv_snap->lv_iobuf, max_sectors);
+	ret = lvm_snapshot_alloc_iobuf_pages(lv_snap->lv_iobuf,
+					     KIO_MAX_SECTORS);
 	if (ret) goto out_free_kiovec;
 
 	/* allocate kiovec to do exception table io */
diff -urNp linux-5110/drivers/md/lvm.c linux-5120/drivers/md/lvm.c
--- linux-5110/drivers/md/lvm.c
+++ linux-5120/drivers/md/lvm.c
@@ -1,14 +1,15 @@
 /*
  * kernel/lvm.c
  *
- * Copyright (C) 1997 - 2002  Heinz Mauelshagen, Sistina Software
+ * Copyright (C) 1997 - 2003  Heinz Mauelshagen, Sistina Software
  *
  * February-November 1997
  * April-May,July-August,November 1998
  * January-March,May,July,September,October 1999
  * January,February,July,September-November 2000
  * January-May,June,October 2001
- * May-July 2002
+ * May-August 2002
+ * February 2003
  *
  *
  * LVM driver is free software; you can redistribute it and/or modify
@@ -220,6 +221,12 @@
  *               - support HDIO_GETGEO_BIG ioctl
  *    05/07/2002 - fixed OBO error on vg array access [benh@kernel.crashing.org]
  *    22/07/2002 - streamlined blk_ioctl() call
+ *    14/08/2002 - stored fs handle in lvm_do_lv_rename
+ *                 [kaoru@bsd.tnes.nec.co.jp]
+ *    06/02/2003 - fix persistent snapshot extend/reduce bug in
+ *                lvm_do_lv_extend_reduce() [dalestephenson@mac.com]
+ *    04/03/2003 - snapshot extend/reduce memory leak
+ *               - VG PE counter wrong [dalestephenson@mac.com]
  *
  */
 
@@ -397,19 +404,19 @@ static DECLARE_RWSEM(_pe_lock);
 
 
 struct file_operations lvm_chr_fops = {
-	owner:		THIS_MODULE,
-	open:		lvm_chr_open,
-	release:	lvm_chr_close,
-	ioctl:		lvm_chr_ioctl,
+	.owner		= THIS_MODULE,
+	.open		= lvm_chr_open,
+	.release	= lvm_chr_close,
+	.ioctl		= lvm_chr_ioctl,
 };
 
 /* block device operations structure needed for 2.3.38? and above */
 struct block_device_operations lvm_blk_dops =
 {
-	owner:		THIS_MODULE,
-	open:		lvm_blk_open,
-	release:	lvm_blk_close,
-	ioctl:		lvm_blk_ioctl,
+	.owner		= THIS_MODULE,
+	.open		= lvm_blk_open,
+	.release	= lvm_blk_close,
+	.ioctl		= lvm_blk_ioctl,
 };
 
 
@@ -421,13 +428,13 @@ static int lvm_size[MAX_LV];
 
 static struct gendisk lvm_gendisk =
 {
-	major:		MAJOR_NR,
-	major_name:	LVM_NAME,
-	minor_shift:	0,
-	max_p:		1,
-	part:		lvm_hd_struct,
-	sizes:		lvm_size,
-	nr_real:	MAX_LV,
+	.major		= MAJOR_NR,
+	.major_name	= LVM_NAME,
+	.minor_shift	= 0,
+	.max_p		= 1,
+	.part		= lvm_hd_struct,
+	.sizes		= lvm_size,
+	.nr_real	= MAX_LV,
 };
 
 
@@ -1548,8 +1555,10 @@ static int lvm_do_vg_create(void *arg, i
 		minor = vg_ptr->vg_number;
 
 	/* check limits */
-	if (minor >= ABS_MAX_VG)
+	if (minor >= ABS_MAX_VG) {
+		kfree(vg_ptr);
 		return -EFAULT;
+	}
 
 	/* Validate it */
 	if (vg[VG_CHR(minor)] != NULL) {
@@ -1616,8 +1625,7 @@ static int lvm_do_vg_create(void *arg, i
 			if (copy_from_user(&lv, lvp, sizeof(lv_t)) != 0) {
 				P_IOCTL("ERROR: copying LV ptr %p (%d bytes)\n",
 					lvp, sizeof(lv_t));
-				lvm_do_vg_remove(minor);
-				return -EFAULT;
+				goto copy_fault;
 			}
 			if ( lv.lv_access & LV_SNAPSHOT) {
 				snap_lv_ptr[ls] = lvp;
@@ -1627,10 +1635,8 @@ static int lvm_do_vg_create(void *arg, i
 			}
 			vg_ptr->lv[l] = NULL;
 			/* only create original logical volumes for now */
-			if (lvm_do_lv_create(minor, lv.lv_name, &lv) != 0) {
-				lvm_do_vg_remove(minor);
-				return -EFAULT;
-			}
+			if (lvm_do_lv_create(minor, lv.lv_name, &lv) != 0)
+				goto copy_fault;
 		}
 	}
 
@@ -1638,14 +1644,11 @@ static int lvm_do_vg_create(void *arg, i
 	   in place during first path above */
 	for (l = 0; l < ls; l++) {
 		lv_t *lvp = snap_lv_ptr[l];
-		if (copy_from_user(&lv, lvp, sizeof(lv_t)) != 0) {
-			lvm_do_vg_remove(minor);
-			return -EFAULT;
-		}
-		if (lvm_do_lv_create(minor, lv.lv_name, &lv) != 0) {
-			lvm_do_vg_remove(minor);
-			return -EFAULT;
-		}
+		if (copy_from_user(&lv, lvp, sizeof(lv_t)) != 0)
+			goto copy_fault;
+
+		if (lvm_do_lv_create(minor, lv.lv_name, &lv) != 0)
+			goto copy_fault;
 	}
 
 	vfree(snap_lv_ptr);
@@ -1659,6 +1662,11 @@ static int lvm_do_vg_create(void *arg, i
 	vg_ptr->vg_status |= VG_ACTIVE;
 
 	return 0;
+
+copy_fault:
+	lvm_do_vg_remove(minor);
+	vfree(snap_lv_ptr);
+	return -EFAULT;
 } /* lvm_do_vg_create() */
 
 
@@ -2120,9 +2128,6 @@ static int lvm_do_lv_create(int minor, c
 				lv_ptr->lv_stripes = lv_ptr->lv_snapshot_org->lv_stripes;
 				lv_ptr->lv_stripesize = lv_ptr->lv_snapshot_org->lv_stripesize;
 
-				/* Update the VG PE(s) used by snapshot reserve space. */
-				vg_ptr->pe_allocated += lv_ptr->lv_allocated_snapshot_le;
-
 				if ((ret = lvm_snapshot_alloc(lv_ptr)) != 0)
 				{
 					vfree(lv_ptr->lv_block_exception);
@@ -2130,6 +2135,9 @@ static int lvm_do_lv_create(int minor, c
 					vg_ptr->lv[l] = NULL;
 					return ret;
 				}
+				/* Update the VG PE(s) used by snapshot reserve space. */
+				vg_ptr->pe_allocated += lv_ptr->lv_allocated_snapshot_le;
+
 				for ( e = 0; e < lv_ptr->lv_remap_ptr; e++)
 					lvm_hash_link (lv_ptr->lv_block_exception + e,
 						       lv_ptr->lv_block_exception[e].rdev_org,
@@ -2474,7 +2482,7 @@ static int lvm_do_lv_extend_reduce(int m
 	if(r)
 		return r;
 
-	/* copy relevent fields */
+	/* copy relevant fields */
 	down_write(&old_lv->lv_lock);
 
 	if(new_lv->lv_access & LV_SNAPSHOT) {
@@ -2483,6 +2491,8 @@ static int lvm_do_lv_extend_reduce(int m
 		size *= sizeof(lv_block_exception_t);
 		memcpy(new_lv->lv_block_exception,
 		       old_lv->lv_block_exception, size);
+		vfree(old_lv->lv_block_exception);
+		vfree(old_lv->lv_snapshot_hash_table);
 
 		old_lv->lv_remap_end = new_lv->lv_remap_end;
 		old_lv->lv_block_exception = new_lv->lv_block_exception;
@@ -2493,12 +2503,15 @@ static int lvm_do_lv_extend_reduce(int m
 		old_lv->lv_snapshot_hash_mask =
 			new_lv->lv_snapshot_hash_mask;
 
-		for (e = 0; e < new_lv->lv_remap_ptr; e++)
+		for (e = 0; e < old_lv->lv_remap_ptr; e++)
 			lvm_hash_link(new_lv->lv_block_exception + e,
 				      new_lv->lv_block_exception[e].rdev_org,
 				      new_lv->lv_block_exception[e].rsector_org,
 				      new_lv);
 
+		vg_ptr->pe_allocated -= old_lv->lv_allocated_snapshot_le;
+		vg_ptr->pe_allocated += new_lv->lv_allocated_le;
+		old_lv->lv_allocated_snapshot_le = new_lv->lv_allocated_le;
 	} else {
 
 		vfree(old_lv->lv_current_pe);
diff -urNp linux-5110/include/linux/lvm.h linux-5120/include/linux/lvm.h
--- linux-5110/include/linux/lvm.h
+++ linux-5120/include/linux/lvm.h
@@ -80,8 +80,8 @@
 #ifndef _LVM_H_INCLUDE
 #define _LVM_H_INCLUDE
 
-#define LVM_RELEASE_NAME "1.0.5+"
-#define LVM_RELEASE_DATE "22/07/2002"
+#define LVM_RELEASE_NAME "1.0.8-2"
+#define LVM_RELEASE_DATE "26/05/2004"
 
 #define	_LVM_KERNEL_H_VERSION	"LVM "LVM_RELEASE_NAME" ("LVM_RELEASE_DATE")"
 
@@ -260,7 +260,7 @@ struct list_head {
 #define	LVM_LV_SIZE_MAX(a)	( ( long long) LVM_PE_T_MAX * (a)->pe_size > ( long long) 1024*1024/SECTOR_SIZE*1024*1024 ? ( long long) 1024*1024/SECTOR_SIZE*1024*1024 : ( long long) LVM_PE_T_MAX * (a)->pe_size)
 #define	LVM_MIN_PE_SIZE		( 8192L / SECTOR_SIZE) /* 8 KB in sectors */
 #define	LVM_MAX_PE_SIZE		( 16L * 1024L * 1024L / SECTOR_SIZE * 1024)	/* 16GB in sectors */
-#define	LVM_DEFAULT_PE_SIZE	( 4096L * 1024 / SECTOR_SIZE)	/* 4 MB in sectors */
+#define	LVM_DEFAULT_PE_SIZE	( 8 * 4096L * 1024 / SECTOR_SIZE)	/* 32 MB in sectors */
 #define	LVM_DEFAULT_STRIPE_SIZE	16L	/* 16 KB  */
 #define	LVM_MIN_STRIPE_SIZE	( PAGE_SIZE/SECTOR_SIZE)	/* PAGESIZE in sectors */
 #define	LVM_MAX_STRIPE_SIZE	( 512L * 1024 / SECTOR_SIZE)	/* 512 KB in sectors */
