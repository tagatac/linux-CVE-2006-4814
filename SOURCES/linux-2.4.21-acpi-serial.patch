diff -urNp linux-5412/Documentation/Configure.help linux-5413/Documentation/Configure.help
--- linux-5412/Documentation/Configure.help
+++ linux-5413/Documentation/Configure.help
@@ -3646,6 +3646,26 @@ CONFIG_SERIAL_NONSTANDARD
 
   Most people can say N here.
 
+Support for serial console port described by EFI HCDP table
+CONFIG_SERIAL_HCDP
+  If you wish to make the serial console port described by the EFI
+  HCDP table available for use as serial console or general
+  purpose port, say Y here. See
+  <http://www.dig64.org/specifications/DIG64_HCDPv10a_01.pdf>.
+
+Support for serial ports defined in ACPI namespace
+CONFIG_SERIAL_ACPI
+  If you wish to enable serial port discovery via the ACPI
+  namespace, say Y here.  If unsure, say N.
+
+HP (GSP/ECI/MP) Remote Management Console support
+CONFIG_HP_DIVA
+  If you have an HP IA64 or HP PA-RISC server with a remote
+  management console say Y here to use all its serial ports.
+
+  It is always safe to say Y but your kernel will be a tiny
+  bit bigger.
+
 Extended dumb serial driver options
 CONFIG_SERIAL_EXTENDED
   If you wish to use any non-standard features of the standard "dumb"
diff -urNp linux-5412/arch/ia64/kernel/acpi.c linux-5413/arch/ia64/kernel/acpi.c
--- linux-5412/arch/ia64/kernel/acpi.c
+++ linux-5413/arch/ia64/kernel/acpi.c
@@ -805,4 +805,25 @@ acpi_irq_to_vector (u32 irq)
 	return gsi_to_vector(irq);
 }
 
+int
+acpi_register_irq (u32 gsi, u32 polarity, u32 mode)
+{
+	u32 irq_base;
+	char *iosapic_address;
+
+	if (has_8259 && gsi < 16)
+		return isa_irq_to_vector(gsi);
+
+	if (!iosapic_register_intr)
+		return 0;
+
+	if (!acpi_find_iosapic(gsi, &irq_base, &iosapic_address))
+		return iosapic_register_intr(gsi,
+				polarity == ACPI_ACTIVE_HIGH,
+				mode == ACPI_EDGE_SENSITIVE,
+				irq_base, iosapic_address);
+
+	return 0;
+}
+
 #endif /* CONFIG_ACPI_BOOT */
diff -urNp linux-5412/drivers/char/Config.in linux-5413/drivers/char/Config.in
--- linux-5412/drivers/char/Config.in
+++ linux-5413/drivers/char/Config.in
@@ -24,6 +24,12 @@ if [ "$CONFIG_SERIAL" = "y" ]; then
       tristate '   Atomwide serial port support' CONFIG_ATOMWIDE_SERIAL
       tristate '   Dual serial port support' CONFIG_DUALSP_SERIAL
    fi
+   if [ "$CONFIG_ACPI" = "y" ]; then
+      bool '  Support for serial ports defined in ACPI namespace' CONFIG_SERIAL_ACPI
+   fi
+   if [ "$CONFIG_IA64" = "y" -o "$CONFIG_PARISC" = "y" ]; then
+      bool '   HP (GSP/ECI/MP) Remote Management Console support' CONFIG_HP_DIVA
+   fi
 fi
 dep_mbool 'Extended dumb serial driver options' CONFIG_SERIAL_EXTENDED $CONFIG_SERIAL
 if [ "$CONFIG_SERIAL_EXTENDED" = "y" ]; then
diff -urNp linux-5412/drivers/char/serial.c linux-5413/drivers/char/serial.c
--- linux-5412/drivers/char/serial.c
+++ linux-5413/drivers/char/serial.c
@@ -66,6 +66,9 @@
  *        to waiting processes
  *        Sapan Bhatia <sapan@corewars.org>
  *
+ * 05/03: Isolate HP Diva changes with CONFIG_HP_DIVA and work
+ *        around a diva interrupt problem.  Diva only known to be
+ *        in HP PA-RISC and HP IA64 boxes.  Paul Bame <bame@debian.org>
  */
 
 static char *serial_version = "5.05c";
@@ -96,9 +99,8 @@ static char *serial_revdate = "2001-07-0
  * 		ever possible.
  *
  * CONFIG_SERIAL_ACPI
- *		Enable support for serial console port and serial 
- *		debug port as defined by the SPCR and DBGP tables in 
- *		ACPI 2.0.
+ *		Enable support for serial ports found in the ACPI
+ *		namespace.
  */
 
 #include <linux/config.h>
@@ -227,6 +229,9 @@ static char *serial_revdate = "2001-07-0
 #ifdef CONFIG_MAGIC_SYSRQ
 #include <linux/sysrq.h>
 #endif
+#ifdef ENABLE_SERIAL_ACPI
+#include <linux/acpi.h>
+#endif
 
 /*
  * All of the compatibilty code so we can compile serial.c against
@@ -264,6 +269,14 @@ static struct timer_list serial_timer;
 
 extern int sercons_escape_char;
 
+#ifdef CONFIG_HP_DIVA
+#define HP_DIVA_CHECKTIME (1*HZ)
+static struct timer_list hp_diva_timer;
+static int hp_diva_count = 0;
+#define HP_DIVA_IRQS 256
+static int hp_diva_irqs[HP_DIVA_IRQS];
+#endif /* CONFIG_HP_DIVA */
+
 /* serial subtype definitions */
 #ifndef SERIAL_TYPE_NORMAL
 #define SERIAL_TYPE_NORMAL	1
@@ -808,6 +821,44 @@ static _INLINE_ void check_modem_status(
 	}
 }
 
+#ifdef CONFIG_HP_DIVA
+static inline int is_hp_diva_info(struct async_struct *info) 
+{
+    struct pci_dev *dev = info->state->dev;
+    return (dev && dev->vendor == PCI_VENDOR_ID_HP &&
+		dev->device == PCI_DEVICE_ID_HP_SAS);
+}
+
+static inline int is_hp_diva_irq(int irq)
+{
+    struct async_struct *info = IRQ_ports[irq];
+    return (info && is_hp_diva_info(info));
+}
+
+/*
+ * It is possible to "use up" transmit empty interrupts in some
+ * cases with HP Diva cards.  Figure out if there _should_ be a
+ * transmit interrupt and if so, return a suitable iir value so
+ * that we can recover when called from rs_timer().  See also
+ * hp_diva_check()
+ */
+static inline int hp_diva_iir(int irq, struct async_struct *info)
+{
+	int iir = serial_in(info, UART_IIR);
+
+	if (is_hp_diva_info(info) &&
+		(iir & UART_IIR_NO_INT) != 0 &&
+		(info->IER & UART_IER_THRI) != 0 &&
+		(info->xmit.head != info->xmit.tail || info->x_char) &&
+		(serial_in(info, UART_LSR) & UART_LSR_THRE) != 0) {
+		    iir &= ~(UART_IIR_ID | UART_IIR_NO_INT);
+		    iir |= UART_IIR_THRI;
+	}
+
+	return iir;
+}
+#endif /* CONFIG_HP_DIVA */
+
 #ifdef CONFIG_SERIAL_SHARE_IRQ
 /*
  * This is the serial driver's generic interrupt routine
@@ -839,7 +890,11 @@ static void rs_interrupt(int irq, void *
 
 	do {
 		if (!info->tty ||
+#ifdef CONFIG_HP_DIVA
+		    ((iir=hp_diva_iir(irq, info)) & UART_IIR_NO_INT)) {
+#else
 		    ((iir=serial_in(info, UART_IIR)) & UART_IIR_NO_INT)) {
+#endif
 			if (!end_mark)
 				end_mark = info;
 			goto next;
@@ -1108,9 +1163,14 @@ static void rs_timer(unsigned long dummy
 #ifdef CONFIG_SERIAL_SHARE_IRQ
 			if (info->next_port) {
 				do {
-					serial_out(info, UART_IER, 0);
-					info->IER |= UART_IER_THRI;
-					serial_out(info, UART_IER, info->IER);
+#ifdef CONFIG_HP_DIVA
+					if (!is_hp_diva_info(info))
+#endif
+					{
+						serial_out(info, UART_IER, 0);
+						info->IER |= UART_IER_THRI;
+						serial_out(info, UART_IER, info->IER);
+					}
 					info = info->next_port;
 				} while (info);
 #ifdef CONFIG_SERIAL_MULTIPORT
@@ -1141,6 +1201,34 @@ static void rs_timer(unsigned long dummy
 	}
 }
 
+#ifdef CONFIG_HP_DIVA
+/*
+ * This is called when the hp_diva_timer goes off.  In certain
+ * cases (multiple gettys in particular) Diva seems
+ * to issue only a single transmit empty interrupt instead of one each
+ * time THRI is enabled, causing interrupts to be "used up".  This
+ * serves to poll the Diva UARTS more frequently than rs_timer() does.
+ * See also hp_diva_iir()
+ */
+static void hp_diva_check(unsigned long dummy)
+{
+	static unsigned long last_strobe;
+	unsigned long flags;
+	int i;
+
+	if (time_after_eq(jiffies, last_strobe + HP_DIVA_CHECKTIME)) {
+		for (i = 0; i < hp_diva_count; i++) {
+			save_flags(flags); cli();
+			rs_interrupt(hp_diva_irqs[i], NULL, NULL);
+			restore_flags(flags);
+		}
+	}
+	last_strobe = jiffies;
+	mod_timer(&hp_diva_timer, jiffies + HP_DIVA_CHECKTIME);
+}
+#endif /* CONFIG_HP_DIVA */
+
+
 /*
  * ---------------------------------------------------------------
  * Low level utility subroutines for the serial driver:  routines to
@@ -4277,6 +4365,7 @@ pci_timedia_fn(struct pci_dev *dev, stru
 	return 0;
 }
 
+#ifdef CONFIG_HP_DIVA
 /*
  * HP's Remote Management Console.  The Diva chip came in several
  * different versions.  N-class, L2000 and A500 have two Diva chips, each
@@ -4308,8 +4397,20 @@ pci_hp_diva(struct pci_dev *dev, struct 
 		break;
 	}
 
+	if (hp_diva_count < HP_DIVA_IRQS) {
+		hp_diva_irqs[hp_diva_count] = dev->irq;
+	} else {
+		printk(KERN_INFO "Please increase HP_DIVA_IRQS in drivers/char/serial.c\n");
+	}
+	if (hp_diva_count++ == 0) {
+		init_timer(&hp_diva_timer);
+		hp_diva_timer.function = hp_diva_check;
+		mod_timer(&hp_diva_timer, jiffies + HP_DIVA_CHECKTIME);
+	}
+
 	return 0;
 }
+#endif /* CONFIG_HP_DIVA */
 
 static int __devinit
 pci_xircom_fn(struct pci_dev *dev, struct pci_board *board, int enable)
@@ -4378,7 +4479,9 @@ enum pci_board_num_t {
 	pbn_timedia,
 	pbn_intel_i960,
 	pbn_sgi_ioc3,
+#ifdef CONFIG_HP_DIVA
 	pbn_hp_diva,
+#endif
 #ifdef CONFIG_DDB5074
 	pbn_nec_nile4,
 #endif
@@ -4471,7 +4574,9 @@ static struct pci_board pci_boards[] __d
 		8<<2, 2, pci_inteli960ni_fn, 0x10000},
 	{ SPCI_FL_BASE0 | SPCI_FL_IRQRESOURCE,		   /* pbn_sgi_ioc3 */
 		1, 458333, 0, 0, 0, 0x20178 },
+#ifdef CONFIG_HP_DIVA
 	{ SPCI_FL_BASE0, 5, 115200, 8, 0, pci_hp_diva, 0},   /* pbn_hp_diva */
+#endif
 #ifdef CONFIG_DDB5074
 	/*
 	 * NEC Vrc-5074 (Nile 4) builtin UART.
@@ -4567,7 +4672,8 @@ static int __devinit serial_init_one(str
 	if (ent->driver_data == pbn_default &&
 	    serial_pci_guess_board(dev, board))
 		return -ENODEV;
-	else if (serial_pci_guess_board(dev, &tmp) == 0) {
+	else if ((board->num_ports == 1) &&
+			serial_pci_guess_board(dev, &tmp) == 0) {
 		printk(KERN_INFO "Redundant entry in serial pci_table.  "
 		       "Please send the output of\n"
 		       "lspci -vv, this message (%04x,%04x,%04x,%04x)\n"
@@ -4613,6 +4719,89 @@ static void __devexit serial_remove_one(
 	}
 }
 
+#ifdef ENABLE_SERIAL_ACPI
+static acpi_status acpi_serial_resource(struct acpi_resource *resource, void *data)
+{
+	struct serial_struct *serial_req = (struct serial_struct *) data;
+	struct acpi_resource_address64 addr;
+	acpi_status status;
+
+	status = acpi_resource_to_address64(resource, &addr);
+	if (ACPI_SUCCESS(status)) {
+		if (!(serial_req->iomem_base = ioremap(addr.min_address_range,
+			addr.max_address_range - addr.min_address_range + 1)))
+				return AE_NO_MEMORY;
+		serial_req->io_type = SERIAL_IO_MEM;
+		serial_req->port = 0;
+		serial_req->port_high = 0;
+	} else if (resource->id == ACPI_RSTYPE_EXT_IRQ) {
+		struct acpi_resource_ext_irq *ext_irq = &resource->data.extended_irq;
+		if (ext_irq->number_of_interrupts > 0) {
+#ifdef CONFIG_IA64
+			if (!(serial_req->irq = acpi_register_irq(ext_irq->interrupts[0],
+				  ext_irq->active_high_low, ext_irq->edge_level)))
+				return AE_NOT_FOUND;
+#else
+			serial_req->irq = ext_irq->interrupts[0];
+#endif
+		}
+	}
+
+	return AE_OK;
+}
+
+static int acpi_serial_add(struct acpi_device *device)
+{
+	struct serial_struct serial_req;
+	int line;
+	acpi_status	status;
+
+	memset(&serial_req, 0, sizeof(serial_req));
+
+	status = acpi_walk_resources(device->handle, METHOD_NAME__CRS,
+		acpi_serial_resource, &serial_req);
+        
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error in acpi_serial_add"));
+		return -ENODEV;
+	}
+
+	serial_req.baud_base = BASE_BAUD;
+	serial_req.flags = ASYNC_SKIP_TEST|ASYNC_BOOT_AUTOCONF|ASYNC_AUTO_IRQ;
+	serial_req.xmit_fifo_size = serial_req.custom_divisor = 0;
+	serial_req.close_delay = serial_req.hub6 = serial_req.closing_wait = 0;
+	serial_req.iomem_reg_shift = 0;
+
+	line = register_serial(&serial_req);
+	if (line < 0)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int acpi_serial_remove(struct acpi_device *device, int type)
+{
+	return 0;
+}
+
+static struct acpi_driver acpi_serial_driver = {
+	name:	"serial",
+	class:	"",
+	ids:	"PNP0501",
+	ops:	{
+			add:	acpi_serial_add,
+			remove:	acpi_serial_remove,
+		},
+};
+
+/*
+ * Look for serial ports in the ACPI namespace.
+ */
+static void __devinit probe_serial_acpi(void)
+{
+	acpi_bus_register_driver(&acpi_serial_driver);
+}
+#endif /* ENABLE_SERIAL_ACPI */
 
 static struct pci_device_id serial_pci_tbl[] __devinitdata = {
 	{	PCI_VENDOR_ID_V3, PCI_DEVICE_ID_V3_V960,
@@ -4937,6 +5126,7 @@ static struct pci_device_id serial_pci_t
 		0xFF00, 0, 0, 0,
 		pbn_sgi_ioc3 },
 
+#ifdef CONFIG_HP_DIVA
 	/* HP Diva card */
 	{	PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_SAS,
 		PCI_ANY_ID, PCI_ANY_ID, 0, 0,
@@ -4944,7 +5134,7 @@ static struct pci_device_id serial_pci_t
 	{	PCI_VENDOR_ID_HP, 0x1290,
 		PCI_ANY_ID, PCI_ANY_ID, 0, 0,
 		pbn_b2_1_115200 },
-
+#endif
 #ifdef CONFIG_DDB5074
 	/*
 	 * NEC Vrc-5074 (Nile 4) builtin UART.
@@ -5591,6 +5781,9 @@ static int __init rs_init(void)
 #ifdef CONFIG_SUPERIO
 	superio_serial_init();
 #endif
+#ifdef ENABLE_SERIAL_ACPI
+	probe_serial_acpi();
+#endif
 #ifdef ENABLE_SERIAL_PCI
 	probe_serial_pci();
 #endif
@@ -5773,6 +5966,10 @@ static void __exit rs_fini(void) 
 
 	/* printk("Unloading %s: version %s\n", serial_name, serial_version); */
 	del_timer_sync(&serial_timer);
+#ifdef CONFIG_HP_DIVA
+	if (hp_diva_count > 0)
+		del_timer_sync(&hp_diva_timer);
+#endif
 	save_flags(flags); cli();
         remove_bh(SERIAL_BH);
 	if ((e1 = tty_unregister_driver(&serial_driver)))
diff -urNp linux-5412/include/asm-ia64/acpi.h linux-5413/include/asm-ia64/acpi.h
--- linux-5412/include/asm-ia64/acpi.h
+++ linux-5413/include/asm-ia64/acpi.h
@@ -103,6 +103,7 @@ int acpi_get_prt (struct pci_vector_stru
 int acpi_get_pci_link_irq_params (struct pci_dev *dev, unsigned char pin, int *trig, int *pol);
 int acpi_get_interrupt_model (int *type);
 int acpi_irq_to_vector (u32 irq);
+int acpi_register_irq (u32 gsi, u32 polarity, u32 trigger);
 
 #ifdef CONFIG_DISCONTIGMEM
 #define NODE_ARRAY_INDEX(x)	((x) / 8)	/* 8 bits/char */
