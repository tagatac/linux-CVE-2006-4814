diff -urNp linux-201/Documentation/kernel-parameters.txt linux-202/Documentation/kernel-parameters.txt
--- linux-201/Documentation/kernel-parameters.txt
+++ linux-202/Documentation/kernel-parameters.txt
@@ -70,6 +70,9 @@ running once the system is up.
 
 	acpi=		[HW,ACPI] Advanced Configuration and Power Interface 
 
+	acpi_sci=	[HW,ACPI] ACPI System Control Interrupt trigger mode
+			Format: { level | edge |  high | low
+
 	acpismp=force	[IA-32] Early setup parse and use ACPI SMP table.
  
 	ad1816=		[HW,SOUND]
diff -urNp linux-201/arch/x86_64/config.in linux-202/arch/x86_64/config.in
--- linux-201/arch/x86_64/config.in
+++ linux-202/arch/x86_64/config.in
@@ -115,11 +115,9 @@ if [ "$CONFIG_IA32_EMULATION" = "y" ]; t
   define_bool CONFIG_COMPAT y
 fi
 
-if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
-   dep_bool '  ACPI support' CONFIG_ACPI $CONFIG_PM
-   if [ "$CONFIG_ACPI" != "n" ]; then
-      source drivers/acpi/Config.in
-   fi
+dep_bool '  ACPI support' CONFIG_ACPI $CONFIG_PM
+if [ "$CONFIG_ACPI" != "n" ]; then
+   source drivers/acpi/Config.in
 fi
 
 endmenu
diff -urNp linux-201/arch/x86_64/kernel/Makefile linux-202/arch/x86_64/kernel/Makefile
--- linux-201/arch/x86_64/kernel/Makefile
+++ linux-202/arch/x86_64/kernel/Makefile
@@ -20,7 +20,7 @@ export-objs     := mtrr.o msr.o cpuid.o 
 obj-y	:= process.o semaphore.o signal.o entry.o traps.o irq.o \
 		ptrace.o i8259.o ioport.o ldt.o setup.o time.o sys_x86_64.o \
 		pci-dma.o x8664_ksyms.o i387.o syscall.o vsyscall.o \
-		setup64.o acpitable.o e820.o
+		setup64.o e820.o
 
 ifdef CONFIG_PCI
 obj-y			+= pci-x86_64.o
@@ -30,6 +30,7 @@ endif
 obj-$(CONFIG_MTRR)	+= mtrr.o
 obj-$(CONFIG_X86_MSR)	+= msr.o
 obj-$(CONFIG_X86_CPUID)	+= cpuid.o
+obj-$(CONFIG_ACPI)	+= acpi.o
 obj-$(CONFIG_SMP)	+= smp.o smpboot.o trampoline.o
 obj-$(CONFIG_X86_LOCAL_APIC)	+= apic.o  nmi.o
 obj-$(CONFIG_X86_IO_APIC)	+= io_apic.o mpparse.o
diff -urNp linux-201/arch/x86_64/kernel/acpi.c linux-202/arch/x86_64/kernel/acpi.c
--- linux-201/arch/x86_64/kernel/acpi.c
+++ linux-202/arch/x86_64/kernel/acpi.c
@@ -0,0 +1,708 @@
+/*
+ *  acpi.c - Architecture-Specific Low-Level ACPI Support
+ *
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *  Copyright (C) 2001 Jun Nakajima <jun.nakajima@intel.com>
+ *  Copyright (C) 2001 Patrick Mochel <mochel@osdl.org>
+ *  Copyright (C) 2002 Andi Kleen, SuSE Labs (x86-64 port)
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/stddef.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <linux/bootmem.h>
+#include <linux/irq.h>
+#include <linux/acpi.h>
+#include <asm/mpspec.h>
+#include <asm/io.h>
+#include <asm/apic.h>
+#include <asm/apicdef.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/pgalloc.h>
+#include <asm/io_apic.h>
+#include <asm/proto.h>
+
+#define PREFIX			"ACPI: "
+
+#ifdef CONFIG_ACPI_PMTMR
+extern unsigned int acpi_pmtmr_port;
+extern unsigned char acpi_pmtmr_len;
+extern int use_pmtmr;
+#endif
+
+extern int acpi_disabled;
+
+acpi_interrupt_flags acpi_sci_flags __initdata;
+int acpi_sci_override_gsi __initdata;
+
+extern int acpi_blacklisted(void);
+
+static struct acpi_resource *
+acpi_get_crs_next (struct acpi_buffer *buf, int *offset)
+{
+	struct acpi_resource *res;
+
+	if (*offset >= buf->length)
+		return NULL;
+
+	res = (struct acpi_resource *)((char *) buf->pointer + *offset);
+	*offset += res->length;
+	return res;
+}
+
+static union acpi_resource_data *
+acpi_get_crs_type (struct acpi_buffer *buf, int *offset, int type)
+{
+	for (;;) {
+		struct acpi_resource *res = acpi_get_crs_next(buf, offset);
+		if (!res)
+			return NULL;
+		if (res->id == type)
+			return &res->data;
+	}
+}
+
+static void
+acpi_get_crs_addr (struct acpi_buffer *buf, int type, u64 *base, u64 *length, u64 *tra)
+{
+	int offset = 0;
+	struct acpi_resource_address16 *addr16;
+	struct acpi_resource_address32 *addr32;
+	struct acpi_resource_address64 *addr64;
+
+	for (;;) {
+		struct acpi_resource *res = acpi_get_crs_next(buf, &offset);
+		if (!res)
+			return;
+		switch (res->id) {
+			case ACPI_RSTYPE_ADDRESS16:
+				addr16 = (struct acpi_resource_address16 *) &res->data;
+
+				if (type == addr16->resource_type) {
+					*base = addr16->min_address_range;
+					*length = addr16->address_length;
+					*tra = addr16->address_translation_offset;
+					return;
+				}
+				break;
+			case ACPI_RSTYPE_ADDRESS32:
+				addr32 = (struct acpi_resource_address32 *) &res->data;
+				if (type == addr32->resource_type) {
+					*base = addr32->min_address_range;
+					*length = addr32->address_length;
+					*tra = addr32->address_translation_offset;
+					return;
+				}
+				break;
+			case ACPI_RSTYPE_ADDRESS64:
+				addr64 = (struct acpi_resource_address64 *) &res->data;
+				if (type == addr64->resource_type) {
+					*base = addr64->min_address_range;
+					*length = addr64->address_length;
+					*tra = addr64->address_translation_offset;
+					return;
+				}
+				break;
+			case ACPI_RSTYPE_END_TAG:
+				return;
+				break;
+		}
+	}
+}
+
+void
+acpi_get_addr_space(acpi_handle obj, u8 type, u64 *base, u64 *length, u64 *tra)
+{
+	acpi_status status;
+	struct acpi_buffer buf = { .length  = ACPI_ALLOCATE_BUFFER,
+			    .pointer = NULL };
+
+	*base = 0;
+	*length = 0;
+	*tra = 0;
+
+	status = acpi_get_current_resources(obj, &buf);
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX "Unable to get _CRS data on object\n");
+		return status;
+	}
+
+	acpi_get_crs_addr(&buf, type, base, length, tra);
+
+	acpi_os_free(buf.pointer);
+
+	return AE_OK;
+}
+
+
+/* --------------------------------------------------------------------------
+                              Boot-time Configuration
+   -------------------------------------------------------------------------- */
+
+#ifdef CONFIG_ACPI_BOOT
+
+enum acpi_irq_model_id		acpi_irq_model;
+
+/* rely on all ACPI tables being in the direct mapping */
+char *
+__acpi_map_table (
+	unsigned long	phys_addr,
+	unsigned long	size)
+{
+	if (!phys_addr || !size)
+		return NULL;
+
+	if (phys_addr < (end_pfn_map << PAGE_SHIFT)) 
+		return __va(phys_addr); 
+
+	return NULL; 
+} 	      
+
+#ifdef CONFIG_X86_LOCAL_APIC
+
+int acpi_lapic;
+
+static u64 acpi_lapic_addr __initdata = APIC_DEFAULT_PHYS_BASE;
+
+
+static int __init
+acpi_parse_madt (
+	unsigned long		phys_addr,
+	unsigned long		size)
+{
+	struct acpi_table_madt	*madt = NULL;
+
+	if (!phys_addr || !size)
+		return -EINVAL;
+
+	madt = (struct acpi_table_madt *) __acpi_map_table(phys_addr, size);
+	if (!madt) {
+		printk(KERN_WARNING PREFIX "Unable to map MADT\n");
+		return -ENODEV;
+	}
+
+	if (madt->lapic_address)
+		acpi_lapic_addr = (u64) madt->lapic_address;
+
+	printk(KERN_INFO PREFIX "Local APIC address 0x%08x\n",
+		madt->lapic_address);
+
+	return 0;
+}
+
+
+static int __init
+acpi_parse_lapic (
+	acpi_table_entry_header *header)
+{
+	struct acpi_table_lapic	*processor = NULL;
+
+	processor = (struct acpi_table_lapic*) header;
+	if (!processor)
+		return -EINVAL;
+
+	acpi_table_print_madt_entry(header);
+
+	mp_register_lapic (
+		processor->id,					   /* APIC ID */
+		processor->flags.enabled);			  /* Enabled? */
+
+	return 0;
+}
+
+
+static int __init
+acpi_parse_lapic_addr_ovr (
+	acpi_table_entry_header *header)
+{
+	struct acpi_table_lapic_addr_ovr *lapic_addr_ovr = NULL;
+
+	lapic_addr_ovr = (struct acpi_table_lapic_addr_ovr*) header;
+	if (!lapic_addr_ovr)
+		return -EINVAL;
+
+	acpi_lapic_addr = lapic_addr_ovr->address;
+
+	return 0;
+}
+
+
+static int __init
+acpi_parse_lapic_nmi (
+	acpi_table_entry_header *header)
+{
+	struct acpi_table_lapic_nmi *lapic_nmi = NULL;
+
+	lapic_nmi = (struct acpi_table_lapic_nmi*) header;
+	if (!lapic_nmi)
+		return -EINVAL;
+
+	acpi_table_print_madt_entry(header);
+
+	if (lapic_nmi->lint != 1)
+		printk(KERN_WARNING PREFIX "NMI not connected to LINT 1!\n");
+
+	return 0;
+}
+
+#endif /*CONFIG_X86_LOCAL_APIC*/
+
+#ifdef CONFIG_X86_IO_APIC
+
+int acpi_ioapic;
+
+static int __init
+acpi_parse_ioapic (
+	acpi_table_entry_header *header)
+{
+	struct acpi_table_ioapic *ioapic = NULL;
+
+	ioapic = (struct acpi_table_ioapic*) header;
+	if (!ioapic)
+		return -EINVAL;
+ 
+	acpi_table_print_madt_entry(header);
+
+	mp_register_ioapic (
+		ioapic->id,
+		ioapic->address,
+		ioapic->global_irq_base);
+ 
+	return 0;
+}
+
+/*
+ * Parse Interrupt Source Override for the ACPI SCI
+ */
+static void
+acpi_sci_ioapic_setup(u32 gsi, u16 polarity, u16 trigger)
+{
+	if (trigger == 0)	/* compatible SCI trigger is level */
+		trigger = 3;
+
+	if (polarity == 0)	/* compatible SCI polarity is low */
+		polarity = 3;
+
+	/* Command-line over-ride via acpi_sci= */
+	if (acpi_sci_flags.trigger)
+		trigger = acpi_sci_flags.trigger;
+
+	if (acpi_sci_flags.polarity)
+		polarity = acpi_sci_flags.polarity;
+
+	/*
+	 * mp_config_acpi_legacy_irqs() already setup IRQs < 16
+	 * If GSI is < 16, this will update its flags,
+	 * else it will create a new mp_irqs[] entry.
+	 */
+	mp_override_legacy_irq(gsi, polarity, trigger, gsi);
+
+	/*
+	 * stash over-ride to indicate we've been here
+	 * and for later update of acpi_fadt
+	 */
+	acpi_sci_override_gsi = gsi;
+	return;
+}
+
+static int __init
+acpi_parse_fadt(unsigned long phys, unsigned long size)
+{
+	struct fadt_descriptor_rev2 *fadt =0;
+
+	fadt = (struct fadt_descriptor_rev2*) __acpi_map_table(phys,size);
+	if (!fadt) {
+		printk(KERN_WARNING PREFIX "Unable to map FADT\n");
+		return 0;
+	}
+
+#ifdef	CONFIG_ACPI_INTERPRETER
+	/* initialize sci_int early for INT_SRC_OVR MADT parsing */
+	acpi_fadt.sci_int = fadt->sci_int;
+#endif
+#ifdef CONFIG_ACPI_PMTMR
+	if (use_pmtmr) {
+		acpi_pmtmr_port = fadt->V1_pm_tmr_blk;
+		acpi_pmtmr_len = fadt->pm_tm_len;
+		printk(KERN_INFO "ACPI PM tmr found at I/O 0x%x-0x%x\n",
+			acpi_pmtmr_port, acpi_pmtmr_port+acpi_pmtmr_len-1);
+	}
+#endif
+
+	return 0;
+}
+
+
+
+static int __init
+acpi_parse_int_src_ovr (
+	acpi_table_entry_header *header)
+{
+	struct acpi_table_int_src_ovr *intsrc = NULL;
+
+	intsrc = (struct acpi_table_int_src_ovr*) header;
+	if (!intsrc)
+		return -EINVAL;
+
+	acpi_table_print_madt_entry(header);
+
+	if (intsrc->bus_irq == acpi_fadt.sci_int) {
+		acpi_sci_ioapic_setup(intsrc->global_irq,
+			intsrc->flags.polarity, intsrc->flags.trigger);
+		return 0;
+	}
+
+	mp_override_legacy_irq (
+		intsrc->bus_irq,
+		intsrc->flags.polarity,
+		intsrc->flags.trigger,
+		intsrc->global_irq);
+
+	return 0;
+}
+
+
+static int __init
+acpi_parse_nmi_src (
+	acpi_table_entry_header *header)
+{
+	struct acpi_table_nmi_src *nmi_src = NULL;
+
+	nmi_src = (struct acpi_table_nmi_src*) header;
+	if (!nmi_src)
+		return -EINVAL;
+
+	acpi_table_print_madt_entry(header);
+
+	/* TBD: Support nimsrc entries? */
+
+	return 0;
+}
+
+#endif /*CONFIG_X86_IO_APIC*/
+
+#ifdef CONFIG_HPET_TIMER
+static int __init
+acpi_parse_hpet (
+	unsigned long		phys_addr,
+	unsigned long		size)
+{
+	struct acpi_table_hpet *hpet_tbl;
+
+	hpet_tbl = __va(phys_addr);
+
+	if (hpet_tbl->addr.space_id != ACPI_SPACE_MEM) {
+		printk(KERN_WARNING "acpi: HPET timers must be located in memory.\n");
+		return -1;
+	}
+
+	hpet_address = hpet_tbl->addr.addrl | ((long) hpet_tbl->addr.addrh << 32);
+
+	printk(KERN_INFO "acpi: HPET id: %#x base: %#lx\n", hpet_tbl->id, hpet_address);
+
+	return 0;
+} 
+#endif
+
+static unsigned long __init
+acpi_scan_rsdp (
+	unsigned long		start,
+	unsigned long		length)
+{
+	unsigned long		offset = 0;
+	unsigned long		sig_len = sizeof("RSD PTR ") - 1;
+
+	/*
+	 * Scan all 16-byte boundaries of the physical memory region for the
+	 * RSDP signature.
+	 */
+	for (offset = 0; offset < length; offset += 16) {
+		if (strncmp((char *) (start + offset), "RSD PTR ", sig_len))
+			continue;
+		return (start + offset);
+	}
+
+	return 0;
+}
+
+
+unsigned long __init
+acpi_find_rsdp (void)
+{
+	unsigned long		rsdp_phys = 0;
+
+	/*
+	 * Scan memory looking for the RSDP signature. First search EBDA (low
+	 * memory) paragraphs and then search upper memory (E0000-FFFFF).
+	 */
+	rsdp_phys = acpi_scan_rsdp (0, 0x400);
+	if (!rsdp_phys)
+		rsdp_phys = acpi_scan_rsdp (0xE0000, 0xFFFFF);
+
+	return rsdp_phys;
+}
+
+
+int __init
+acpi_boot_init (char * cmdline)
+{
+	int			result = 0;
+
+	/*
+	 * The default interrupt routing model is PIC (8259).  This gets
+	 * overriden if IOAPICs are enumerated (below).
+	 */
+	acpi_irq_model = ACPI_IRQ_MODEL_PIC;
+
+	/* 
+	 * Initialize the ACPI boot-time table parser.
+	 */
+	result = acpi_table_init();
+	if (result)
+		return result;
+
+	result = acpi_blacklisted();
+	if (result) {
+		acpi_disabled = 1;
+		return result;
+	} else
+               printk(KERN_NOTICE PREFIX "BIOS passes blacklist\n");
+
+
+#ifdef CONFIG_X86_LOCAL_APIC
+
+	/* 
+	 * MADT
+	 * ----
+	 * Parse the Multiple APIC Description Table (MADT), if exists.
+	 * Note that this table provides platform SMP configuration 
+	 * information -- the successor to MPS tables.
+	 */
+
+	result = acpi_table_parse(ACPI_APIC, acpi_parse_madt);
+	if (!result) {
+		printk(KERN_WARNING PREFIX "MADT not present\n");
+		return 0;
+	}
+	else if (result < 0) {
+		printk(KERN_ERR PREFIX "Error parsing MADT\n");
+		return result;
+	}
+	else if (result > 1) 
+		printk(KERN_WARNING PREFIX "Multiple MADT tables exist\n");
+
+	/* 
+	 * Local APIC
+	 * ----------
+	 * Note that the LAPIC address is obtained from the MADT (32-bit value)
+	 * and (optionally) overriden by a LAPIC_ADDR_OVR entry (64-bit value).
+	 */
+
+	result = acpi_table_parse_madt(ACPI_MADT_LAPIC_ADDR_OVR, acpi_parse_lapic_addr_ovr);
+	if (result < 0) {
+		printk(KERN_ERR PREFIX "Error parsing LAPIC address override entry\n");
+		return result;
+	}
+
+	mp_register_lapic_address(acpi_lapic_addr);
+
+	result = acpi_table_parse_madt(ACPI_MADT_LAPIC, acpi_parse_lapic);
+	if (!result) { 
+		printk(KERN_ERR PREFIX "No LAPIC entries present\n");
+		/* TBD: Cleanup to allow fallback to MPS */
+		return -ENODEV;
+	}
+	else if (result < 0) {
+		printk(KERN_ERR PREFIX "Error parsing LAPIC entry\n");
+		/* TBD: Cleanup to allow fallback to MPS */
+		return result;
+	}
+
+	result = acpi_table_parse_madt(ACPI_MADT_LAPIC_NMI, acpi_parse_lapic_nmi);
+	if (result < 0) {
+		printk(KERN_ERR PREFIX "Error parsing LAPIC NMI entry\n");
+		/* TBD: Cleanup to allow fallback to MPS */
+		return result;
+	}
+
+	acpi_lapic = 1;
+
+#endif /*CONFIG_X86_LOCAL_APIC*/
+
+#ifdef CONFIG_X86_IO_APIC
+
+	/* 
+	 * I/O APIC 
+	 * --------
+	 */
+
+	result = acpi_table_parse_madt(ACPI_MADT_IOAPIC, acpi_parse_ioapic);
+	if (!result) { 
+		printk(KERN_ERR PREFIX "No IOAPIC entries present\n");
+		return -ENODEV;
+	}
+	else if (result < 0) {
+		printk(KERN_ERR PREFIX "Error parsing IOAPIC entry\n");
+		return result;
+	}
+
+	/* Build a default routing table for legacy (ISA) interrupts. */
+	mp_config_acpi_legacy_irqs();
+
+	/* Record sci_int for use when looking for MADT sci_int override */
+	acpi_table_parse(ACPI_FADT, acpi_parse_fadt);
+
+	result = acpi_table_parse_madt(ACPI_MADT_INT_SRC_OVR, acpi_parse_int_src_ovr);
+	if (result < 0) {
+		printk(KERN_ERR PREFIX "Error parsing interrupt source overrides entry\n");
+		/* TBD: Cleanup to allow fallback to MPS */
+		return result;
+	}
+
+	/*
+	 * If BIOS did not supply an INT_SRC_OVR for the SCI
+	 * pretend we got one so we can set the SCI flags.
+	 */
+	if (!acpi_sci_override_gsi)
+		acpi_sci_ioapic_setup(acpi_fadt.sci_int, 0, 0);
+
+
+	result = acpi_table_parse_madt(ACPI_MADT_NMI_SRC, acpi_parse_nmi_src);
+	if (result < 0) {
+		printk(KERN_ERR PREFIX "Error parsing NMI SRC entry\n");
+		/* TBD: Cleanup to allow fallback to MPS */
+		return result;
+	}
+
+	acpi_irq_model = ACPI_IRQ_MODEL_IOAPIC;
+
+	acpi_ioapic = 1;
+
+#endif /*CONFIG_X86_IO_APIC*/
+
+#ifdef CONFIG_X86_LOCAL_APIC
+	if (acpi_lapic && acpi_ioapic)
+		smp_found_config = 1;
+#endif
+
+#ifdef CONFIG_HPET_TIMER
+	result = acpi_table_parse(ACPI_HPET, acpi_parse_hpet);
+	if (result < 0) 
+		printk("ACPI: no HPET table found (%d).\n", result); 
+#endif
+
+	return 0;
+}
+
+#endif /*CONFIG_ACPI_BOOT*/
+
+
+/* --------------------------------------------------------------------------
+                              Low-Level Sleep Support
+   -------------------------------------------------------------------------- */
+
+#ifdef CONFIG_ACPI_SLEEP
+#if 1
+/* XXX - ACPI sleep not yet working; these are stub routines */
+/* XXX - Some of these routines are defined "for real" in other files */
+unsigned long acpi_wakeup_address = 0;
+int acpi_save_state_mem(void) { return 1; }
+int acpi_save_state_disk(void) { return 1; }
+void acpi_restore_state_mem(void) { return; }
+void acpi_reserve_bootmem(void) { return; }
+void kernel_fpu_begin(void) { return; }
+void kernel_fpu_end(void) { return; }
+void save_register_state(void * p) { return; }
+void restore_register_state(void) { return; }
+void fix_processor_context(void) { return; }
+#else
+
+/* address in low memory of the wakeup routine. */
+unsigned long acpi_wakeup_address = 0;
+extern char wakeup_start, wakeup_end;
+
+extern unsigned long FASTCALL(acpi_copy_wakeup_routine(unsigned long));
+
+static void init_low_mapping(void)
+{
+	cpu_pda[0].level4_pgt[0] = cpu_pda[0].level4_pgt[pml4_index(PAGE_OFFSET)];
+	flush_tlb_all();
+}
+
+/**
+ * acpi_save_state_mem - save kernel state
+ *
+ * Create an identity mapped page table and copy the wakeup routine to
+ * low memory.
+ */
+int acpi_save_state_mem (void)
+{
+	init_low_mapping();
+
+	memcpy((void *) acpi_wakeup_address, &wakeup_start, &wakeup_end - &wakeup_start);
+	acpi_copy_wakeup_routine(acpi_wakeup_address);
+
+	return 0;
+}
+
+/**
+ * acpi_save_state_disk - save kernel state to disk
+ *
+ */
+int acpi_save_state_disk (void)
+{
+	return 1;
+}
+
+/*
+ * acpi_restore_state
+ */
+void acpi_restore_state_mem (void)
+{
+	cpu_pda[0].level4_pgt[0] = 0;
+	flush_tlb_all();
+}
+
+/**
+ * acpi_reserve_bootmem - do _very_ early ACPI initialisation
+ *
+ * We allocate a page in low memory for the wakeup
+ * routine for when we come back from a sleep state. The
+ * runtime allocator allows specification of <16M pages, but not
+ * <1M pages.
+ */
+void __init acpi_reserve_bootmem(void)
+{
+	acpi_wakeup_address = (unsigned long)alloc_bootmem_low(PAGE_SIZE);
+	if ((&wakeup_end - &wakeup_start) > PAGE_SIZE)
+		printk(KERN_CRIT "ACPI: Wakeup code way too big, will crash on attempt to suspend\n");
+	printk(KERN_DEBUG "ACPI: have wakeup address 0x%8.8lx\n", acpi_wakeup_address);
+}
+
+#endif /* 1 */
+#endif /*CONFIG_ACPI_SLEEP*/
+
+void acpi_pci_link_exit(void) {}
diff -urNp linux-201/arch/x86_64/kernel/acpi_wakeup.S linux-202/arch/x86_64/kernel/acpi_wakeup.S
--- linux-201/arch/x86_64/kernel/acpi_wakeup.S
+++ linux-202/arch/x86_64/kernel/acpi_wakeup.S
@@ -0,0 +1,538 @@
+.text
+#include <linux/linkage.h>
+#include <asm/segment.h>
+#include <asm/page.h>
+#include <asm/msr.h>
+
+# Copyright 2003 Pavel Machek <pavel@suse.cz>, distribute under GPLv2
+#
+# wakeup_code runs in real mode, and at unknown address (determined at run-time).
+# Therefore it must only use relative jumps/calls. 
+#
+# Do we need to deal with A20? It is okay: ACPI specs says A20 must be enabled
+#
+# If physical address of wakeup_code is 0x12345, BIOS should call us with
+# cs = 0x1234, eip = 0x05
+#
+
+
+ALIGN
+	.align	16
+ENTRY(wakeup_start)
+wakeup_code:
+	wakeup_code_start = .
+	.code16
+
+# Running in *copy* of this code, somewhere in low 1MB.
+
+	movb	$0xa1, %al	;  outb %al, $0x80
+	cli
+	cld
+	# setup data segment
+	movw	%cs, %ax
+	movw	%ax, %ds					# Make ds:0 point to wakeup_start
+	movw	%ax, %ss
+	mov	$(wakeup_stack - wakeup_code), %sp		# Private stack is needed for ASUS board
+
+	pushl	$0						# Kill any dangerous flags
+	popfl
+
+	movl	real_magic - wakeup_code, %eax
+	cmpl	$0x12345678, %eax
+	jne	bogus_real_magic
+
+	lcall   $0xc000,$3
+
+ 	movw	$0xb800, %ax
+	movw	%ax,%fs
+	movw	$0x0e00 + 'L', %fs:(0x10)
+
+	movb	$0xa2, %al	;  outb %al, $0x80
+	
+	lidt	%ds:idt_48a - wakeup_code
+	xorl	%eax, %eax
+	movw	%ds, %ax			# (Convert %ds:gdt to a linear ptr)
+	shll	$4, %eax
+	addl	$(gdta - wakeup_code), %eax
+	movl	%eax, gdt_48a +2 - wakeup_code
+	lgdt	%ds:gdt_48a - wakeup_code		# load gdt with whatever is
+						# appropriate
+
+	movl	$1, %eax			# protected mode (PE) bit
+	lmsw	%ax				# This is it!
+	jmp	1f
+1:
+
+	.byte 0x66, 0xea			# prefix + jmpi-opcode
+	.long	wakeup_32 - __START_KERNEL_map
+	.word	__KERNEL_CS
+
+	.code32
+wakeup_32:
+# Running in this code, but at low address; paging is not yet turned on.
+	movb	$0xa5, %al	;  outb %al, $0x80
+
+	/* Check if extended functions are implemented */		
+	movl	$0x80000000, %eax
+	cpuid
+	cmpl	$0x80000000, %eax
+	jbe	bogus_cpu
+	wbinvd
+	mov	$0x80000001, %eax
+	cpuid
+	btl	$29, %edx
+	jnc	bogus_cpu
+	movl	%edx,%edi
+	
+	movw	$__KERNEL_DS, %ax
+	movw	%ax, %ds
+	movw	%ax, %es
+	movw	%ax, %fs
+	movw	%ax, %gs
+
+	movw	$__KERNEL_DS, %ax	
+	movw	%ax, %ss
+
+	mov	$(wakeup_stack - __START_KERNEL_map), %esp
+
+	call	1f
+1:	popl	%eax
+	movl	$0xb8040, %ebx
+	call	early_print
+	
+	movl	saved_magic - __START_KERNEL_map, %eax
+	cmpl	$0x9abcdef0, %eax
+	jne	bogus_32_magic
+
+	/*
+	 * Prepare for entering 64bits mode
+	 */
+
+	/* Enable PAE mode and PGE */
+	xorl	%eax, %eax
+	btsl	$5, %eax
+	btsl	$7, %eax
+	movl	%eax, %cr4
+
+	/* Setup early boot stage 4 level pagetables */
+#if 1
+	movl	$(wakeup_level4_pgt - __START_KERNEL_map), %eax
+#else
+	movl    saved_cr3 - __START_KERNEL_map, %eax
+#endif	
+	movl	%eax, %cr3
+
+	/* Setup EFER (Extended Feature Enable Register) */
+	movl	$MSR_EFER, %ecx
+	rdmsr
+	/* Fool rdmsr and reset %eax to avoid dependences */
+	xorl	%eax, %eax
+	/* Enable Long Mode */
+	btsl	$_EFER_LME, %eax
+	/* Enable System Call */
+	btsl	$_EFER_SCE, %eax
+
+	/* No Execute supported? */	
+	btl	$20,%edi
+	jnc     1f
+	btsl	$_EFER_NX, %eax
+1:	
+				
+	/* Make changes effective */
+	wrmsr
+	wbinvd
+
+	xorl	%eax, %eax
+	btsl	$31, %eax			/* Enable paging and in turn activate Long Mode */
+	btsl	$0, %eax			/* Enable protected mode */
+	btsl	$1, %eax			/* Enable MP */
+	btsl	$4, %eax			/* Enable ET */
+	btsl	$5, %eax			/* Enable NE */
+	btsl	$16, %eax			/* Enable WP */
+	btsl	$18, %eax			/* Enable AM */
+
+	/* Make changes effective */
+	movl	%eax, %cr0
+	/* At this point:
+		CR4.PAE must be 1
+		CS.L must be 0
+		CR3 must point to PML4
+		Next instruction must be a branch
+		This must be on identity-mapped page
+	*/
+	jmp	reach_compatibility_mode
+reach_compatibility_mode:
+	movw	$0x0e00 + 'i', %ds:(0xb8012)
+	movb	$0xa8, %al	;  outb %al, $0x80; 	
+		
+	/*
+	 * At this point we're in long mode but in 32bit compatibility mode
+	 * with EFER.LME = 1, CS.L = 0, CS.D = 1 (and in turn
+	 * EFER.LMA = 1). Now we want to jump in 64bit mode, to do that we load
+	 * the new gdt/idt that has __KERNEL_CS with CS.L = 1.
+	 */
+
+	movw	$0x0e00 + 'n', %ds:(0xb8014)
+	movb	$0xa9, %al	;  outb %al, $0x80
+	
+	/* Load new GDT with the 64bit segment using 32bit descriptor */
+	movl	$(pGDT32 - __START_KERNEL_map), %eax
+	lgdt	(%eax)
+
+	movl    $(wakeup_jumpvector - __START_KERNEL_map), %eax
+	/* Finally jump in 64bit mode */
+	ljmp	*(%eax)
+
+wakeup_jumpvector:
+	.long	wakeup_long64 - __START_KERNEL_map
+	.word	__KERNEL_CS
+
+.code64
+
+	/*	Hooray, we are in Long 64-bit mode (but still running in low memory) */
+wakeup_long64:
+	/*
+	 * We must switch to a new descriptor in kernel space for the GDT
+	 * because soon the kernel won't have access anymore to the userspace
+	 * addresses where we're currently running on. We have to do that here
+	 * because in 32bit we couldn't load a 64bit linear address.
+	 */
+	lgdt	cpu_gdt_descr - __START_KERNEL_map
+
+	movw	$0x0e00 + 'u', %ds:(0xb8016)
+	
+	nop
+	nop
+	movw	$__KERNEL_DS, %ax
+	movw	%ax, %ss	
+	movw	%ax, %ds
+	movw	%ax, %es
+	movw	%ax, %fs
+	movw	%ax, %gs
+	movq	saved_esp, %rsp
+
+	movw	$0x0e00 + 'x', %ds:(0xb8018)
+	movq	saved_ebx, %rbx
+	movq	saved_edi, %rdi
+	movq	saved_esi, %rsi
+	movq	saved_ebp, %rbp
+
+	movw	$0x0e00 + '!', %ds:(0xb801a)
+	movq	saved_eip, %rax
+	jmp	%rax
+
+.code32
+
+early_print:
+	movl	$16, %edx
+1:	
+	movl	%eax, %ecx
+	andl	$0xf, %ecx
+	shrl	$4, %eax
+	addw	$0x0e00 + '0', %ecx
+	movw	%ecx, %ds:(%edx, %ebx)
+	decl	%edx
+	decl	%edx
+	jnz	1b
+	ret
+
+	.align	64	
+gdta:
+	.word	0, 0, 0, 0			# dummy
+
+	.word	0, 0, 0, 0			# unused
+
+	.word	0xFFFF				# 4Gb - (0x100000*0x1000 = 4Gb)
+	.word	0				# base address = 0
+	.word	0x9B00				# code read/exec. ??? Why I need 0x9B00 (as opposed to 0x9A00 in order for this to work?)
+	.word	0x00CF				# granularity = 4096, 386
+						#  (+5th nibble of limit)
+
+	.word	0xFFFF				# 4Gb - (0x100000*0x1000 = 4Gb)
+	.word	0				# base address = 0
+	.word	0x9200				# data read/write
+	.word	0x00CF				# granularity = 4096, 386
+						#  (+5th nibble of limit)
+# this is 64bit descriptor for code
+	.word	0xFFFF
+	.word	0
+	.word	0x9A00				# code read/exec
+	.word	0x00AF				# as above, but it is long mode and with D=0
+
+idt_48a:
+	.word	0				# idt limit = 0
+	.word	0, 0				# idt base = 0L
+
+gdt_48a:
+	.word	0x8000				# gdt limit=2048,
+						#  256 GDT entries
+	.word	0, 0				# gdt base (filled in later)
+	
+	
+real_save_gdt:	.word 0
+		.quad 0
+real_magic:	.quad 0
+video_mode:	.quad 0
+
+bogus_real_magic:
+	movb	$0xba,%al	;  outb %al,$0x80		
+	jmp bogus_real_magic
+
+bogus_32_magic:
+	movb	$0xb3,%al	;  outb %al,$0x80
+	jmp bogus_32_magic
+
+bogus_31_magic:
+	movb	$0xb1,%al	;  outb %al,$0x80
+	jmp bogus_31_magic
+
+bogus_cpu:
+	movb	$0xbc,%al	;  outb %al,$0x80
+	jmp bogus_cpu
+
+	
+/* This code uses an extended set of video mode numbers. These include:
+ * Aliases for standard modes
+ *	NORMAL_VGA (-1)
+ *	EXTENDED_VGA (-2)
+ *	ASK_VGA (-3)
+ * Video modes numbered by menu position -- NOT RECOMMENDED because of lack
+ * of compatibility when extending the table. These are between 0x00 and 0xff.
+ */
+#define VIDEO_FIRST_MENU 0x0000
+
+/* Standard BIOS video modes (BIOS number + 0x0100) */
+#define VIDEO_FIRST_BIOS 0x0100
+
+/* VESA BIOS video modes (VESA number + 0x0200) */
+#define VIDEO_FIRST_VESA 0x0200
+
+/* Video7 special modes (BIOS number + 0x0900) */
+#define VIDEO_FIRST_V7 0x0900
+
+# Setting of user mode (AX=mode ID) => CF=success
+mode_seta:
+	movw	%ax, %bx
+#if 0
+	cmpb	$0xff, %ah
+	jz	setalias
+
+	testb	$VIDEO_RECALC>>8, %ah
+	jnz	_setrec
+
+	cmpb	$VIDEO_FIRST_RESOLUTION>>8, %ah
+	jnc	setres
+	
+	cmpb	$VIDEO_FIRST_SPECIAL>>8, %ah
+	jz	setspc
+
+	cmpb	$VIDEO_FIRST_V7>>8, %ah
+	jz	setv7
+#endif
+	
+	cmpb	$VIDEO_FIRST_VESA>>8, %ah
+	jnc	check_vesaa
+#if 0	
+	orb	%ah, %ah
+	jz	setmenu
+#endif
+	
+	decb	%ah
+#	jz	setbios				  Add bios modes later
+
+setbada:	clc
+	ret
+
+check_vesaa:
+	subb	$VIDEO_FIRST_VESA>>8, %bh
+	orw	$0x4000, %bx			# Use linear frame buffer
+	movw	$0x4f02, %ax			# VESA BIOS mode set call
+	int	$0x10
+	cmpw	$0x004f, %ax			# AL=4f if implemented
+	jnz	_setbada				# AH=0 if OK
+
+	stc
+	ret
+
+_setbada: jmp setbada
+
+	.code64
+bogus_magic:
+	movw	$0x0e00 + 'B', %ds:(0xb8018)
+	jmp bogus_magic
+
+bogus_magic2:
+	movw	$0x0e00 + '2', %ds:(0xb8018)
+	jmp bogus_magic2
+	
+
+wakeup_stack_begin:	# Stack grows down
+
+.org	0xff0
+wakeup_stack:		# Just below end of page
+
+ENTRY(wakeup_end)
+	
+##
+# acpi_copy_wakeup_routine
+#
+# Copy the above routine to low memory.
+#
+# Parameters:
+# %rdi:	place to copy wakeup routine to
+#
+# Returned address is location of code in low memory (past data and stack)
+#
+ENTRY(acpi_copy_wakeup_routine)
+	pushq	%rax
+	pushq	%rcx
+	pushq	%rdx
+
+	sgdt	saved_gdt
+	sidt	saved_idt
+	sldt	saved_ldt
+	str	saved_tss
+
+	movq    %cr3, %rdx
+	movq    %rdx, saved_cr3
+	movq    %cr4, %rdx
+	movq    %rdx, saved_cr4
+	movq	%cr0, %rdx
+	movq	%rdx, saved_cr0
+	sgdt    real_save_gdt - wakeup_start (,%rdi)
+	movl	$MSR_EFER, %ecx
+	rdmsr
+	movl	%eax, saved_efer
+	movl	%edx, saved_efer2
+
+#	movq	saved_videomode, %rdx				# FIXME:	 videomode
+	movq	%rdx, video_mode - wakeup_start (,%rdi)
+	movq	$0x12345678, real_magic - wakeup_start (,%rdi)
+	movq	$0x123456789abcdef0, %rdx
+	movq	%rdx, saved_magic
+
+	movl	saved_magic - __START_KERNEL_map, %eax
+	cmpl	$0x9abcdef0, %eax
+	jne	bogus_32_magic
+
+	# make sure %cr4 is set correctly (features, etc)
+	movl	saved_cr4 - __START_KERNEL_map, %eax
+	movq	%rax, %cr4
+
+	movl	saved_cr0 - __START_KERNEL_map, %eax
+	movq	%rax, %cr0
+	jmp	1f		# Flush pipelines
+1:
+	# restore the regs we used
+	popq	%rdx
+	popq	%rcx
+	popq	%rax
+ENTRY(do_suspend_lowlevel_s4bios)
+	ret
+
+	.align 2
+	.p2align 4,,15
+.globl do_suspend_lowlevel
+	.type	do_suspend_lowlevel,@function
+do_suspend_lowlevel:
+.LFB5:
+	subq	$8, %rsp
+.LCFI2:
+	testl	%edi, %edi
+	jne	.L99
+	xorl	%eax, %eax
+	call	save_processor_state
+
+	movq %rsp, saved_context_esp(%rip)
+	movq %rax, saved_context_eax(%rip)
+	movq %rbx, saved_context_ebx(%rip)
+	movq %rcx, saved_context_ecx(%rip)
+	movq %rdx, saved_context_edx(%rip)
+	movq %rbp, saved_context_ebp(%rip)
+	movq %rsi, saved_context_esi(%rip)
+	movq %rdi, saved_context_edi(%rip)
+	movq %r8,  saved_context_r08(%rip)
+	movq %r9,  saved_context_r09(%rip)
+	movq %r10, saved_context_r10(%rip)
+	movq %r11, saved_context_r11(%rip)
+	movq %r12, saved_context_r12(%rip)
+	movq %r13, saved_context_r13(%rip)
+	movq %r14, saved_context_r14(%rip)
+	movq %r15, saved_context_r15(%rip)
+	pushfq ; popq saved_context_eflags(%rip)
+
+	movq	$.L97, saved_eip(%rip)
+
+	movq %rsp,saved_esp
+	movq %rbp,saved_ebp
+	movq %rbx,saved_ebx
+	movq %rdi,saved_edi
+	movq %rsi,saved_esi
+
+	addq	$8, %rsp
+	movl	$3, %edi
+	xorl	%eax, %eax
+	jmp	acpi_enter_sleep_state
+.L97:
+	.p2align 4,,7
+.L99:
+	.align 4
+	movl	$24, %eax
+	movw %ax, %ds
+	movq	saved_context+58(%rip), %rax
+	movq %rax, %cr4
+	movq	saved_context+50(%rip), %rax
+	movq %rax, %cr3
+	movq	saved_context+42(%rip), %rax
+	movq %rax, %cr2
+	movq	saved_context+34(%rip), %rax
+	movq %rax, %cr0
+	pushq saved_context_eflags(%rip) ; popfq
+	movq saved_context_esp(%rip), %rsp
+	movq saved_context_ebp(%rip), %rbp
+	movq saved_context_eax(%rip), %rax
+	movq saved_context_ebx(%rip), %rbx
+	movq saved_context_ecx(%rip), %rcx
+	movq saved_context_edx(%rip), %rdx
+	movq saved_context_esi(%rip), %rsi
+	movq saved_context_edi(%rip), %rdi
+	movq saved_context_r08(%rip), %r8
+	movq saved_context_r09(%rip), %r9
+	movq saved_context_r10(%rip), %r10
+	movq saved_context_r11(%rip), %r11
+	movq saved_context_r12(%rip), %r12
+	movq saved_context_r13(%rip), %r13
+	movq saved_context_r14(%rip), %r14
+	movq saved_context_r15(%rip), %r15
+
+	xorl	%eax, %eax
+	addq	$8, %rsp
+	jmp	restore_processor_state
+.LFE5:
+.Lfe5:
+	.size	do_suspend_lowlevel,.Lfe5-do_suspend_lowlevel
+	
+.data
+ALIGN
+ENTRY(saved_ebp)	.quad	0
+ENTRY(saved_esi)	.quad	0
+ENTRY(saved_edi)	.quad	0
+ENTRY(saved_ebx)	.quad	0
+
+ENTRY(saved_eip)	.quad	0
+ENTRY(saved_esp)	.quad	0
+
+ENTRY(saved_magic)	.quad	0
+
+ALIGN
+# saved registers
+saved_gdt:	.quad	0,0
+saved_idt:	.quad	0,0
+saved_ldt:	.quad	0
+saved_tss:	.quad	0
+
+saved_cr0:	.quad 0
+saved_cr3:	.quad 0
+saved_cr4:	.quad 0
+saved_efer:	.quad 0
+saved_efer2:	.quad 0
diff -urNp linux-201/arch/x86_64/kernel/acpitable.c linux-202/arch/x86_64/kernel/acpitable.c
--- linux-201/arch/x86_64/kernel/acpitable.c
+++ linux-202/arch/x86_64/kernel/acpitable.c
@@ -1,304 +0,0 @@
-/*
- *  acpitable.c - x86-64-specific ACPI (1.0 & 2.0) boot-time initialization
- *
- *  Copyright (C) 1999 Andrew Henroid
- *  Copyright (C) 2001 Richard Schaal
- *  Copyright (C) 2001 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *  Copyright (C) 2001 Jun Nakajima <jun.nakajima@intel.com>
- *  Copyright (C) 2001 Arjan van de Ven <arjanv@redhat.com>
- *  Copyright (C) 2002 Vojtech Pavlik <vojtech@suse.cz>
- */
-
-#include <linux/config.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/stddef.h>
-#include <linux/slab.h>
-#include <linux/pci.h>
-#include <asm/mpspec.h>
-#include <asm/io.h>
-#include <asm/apic.h>
-#include <asm/apicdef.h>
-#include <asm/page.h>
-#include <asm/pgtable.h>
-#include <asm/fixmap.h>
-
-#include "acpitable.h"
-
-static acpi_table_handler acpi_boot_ops[ACPI_TABLE_COUNT];
-
-extern unsigned long end_pfn;
-static inline int bad_ptr(void *p) 
-{ 
-	if ((unsigned long)p  >> PAGE_SHIFT >= end_pfn) 
-		return 1; 
-	return 0; 	
-} 
-
-/*
- * Checksum an ACPI table.
- */
-
-static unsigned char __init acpi_checksum(void *buffer, int length)
-{
-	unsigned char sum = 0;
-	while (length--)
-		sum += *(unsigned char *)buffer++;
-	return sum;
-}
-
-/*
- * Print an ACPI table header for debugging.
- */
-
-static char __init *acpi_kill_spaces(char *t, char *s, int m)
-{
-	int l = strnlen(s, m);
-	strncpy(t, s, m);
-	t[l] = 0;
-	while (l > 0 && (t[l - 1] == ' ' || t[l - 1] == '\t')) t[--l] = 0;
-	while (t[0] == ' ' || t[0] == '\t') t++;
-	return t;
-}
-
-static void __init acpi_print_table_header(struct acpi_table_header * header)
-{
-	char oem[7], id[9];
-
-	printk(KERN_INFO "acpi: %.4s rev: %d oem: %s id: %s build: %d.%d\n",
-		header->signature, header->revision, acpi_kill_spaces(oem, header->oem_id, 6),
-		acpi_kill_spaces(id, header->oem_table_id, 8), header->oem_revision >> 16,
-		header->oem_revision & 0xffff);
-}
-
-/*
- * Search a block of memory for the RSDP signature
- */
-
-static void* __init acpi_tb_scan_memory_for_rsdp(void *address, int length)
-{
-	u32 offset = 0;
-
-	while (offset < length) {
-		if (strncmp(address, "RSD PTR ", 8) == 0 &&
-		    acpi_checksum(address, RSDP_CHECKSUM_LENGTH) == 0) {
-			printk(KERN_INFO "acpi: RSDP found at address %p\n", address);
-			return address;
-		}
-		offset += RSDP_SCAN_STEP;
-		address += RSDP_SCAN_STEP;
-	}
-	return NULL;
-}
-
-/*
- * Search lower 1_mbyte of memory for the root system descriptor
- * pointer structure. If it is found, set *RSDP to point to it.
- */
-
-static struct acpi_table_rsdp* __init acpi_find_root_pointer(void)
-{
-	struct acpi_table_rsdp *rsdp;
-
-	if ((rsdp = acpi_tb_scan_memory_for_rsdp(__va(LO_RSDP_WINDOW_BASE), LO_RSDP_WINDOW_SIZE)))
-		return rsdp;
-
-	if ((rsdp = acpi_tb_scan_memory_for_rsdp(__va(HI_RSDP_WINDOW_BASE), HI_RSDP_WINDOW_SIZE)))
-		return rsdp;
-
-	return NULL;
-}
-
-static int __init acpi_process_table(u64 table)
-{
-	struct acpi_table_header *header;
-	int type;
-
-	header = __va(table);
-
-	acpi_print_table_header(header);
-
-	if (acpi_checksum(header, header->length)) {
-		printk(KERN_WARNING "acpi: ACPI table at %#lx has invalid checksum.\n", table);
-		return -1;
-	}
-
-	for (type = 0; type < ACPI_TABLE_COUNT; type++)
-		if (!strncmp(header->signature, acpi_table_signatures[type], 4))
-			break;
-
-	if (type == ACPI_TABLE_COUNT || !acpi_boot_ops[type])
-		return 0;
-
-	return acpi_boot_ops[type](header, table);
-}
-
-static int __init acpi_tables_init(void)
-{
-	struct acpi_table_rsdp *rsdp;
-	struct acpi_table_xsdt *xsdt = NULL;
-	struct acpi_table_rsdt *rsdt = NULL;
-	char oem[7];
-	int i;
-
-	if (!(rsdp = acpi_find_root_pointer())) {
-		printk(KERN_ERR "acpi: Couldn't find ACPI root pointer!\n");
-		return -1;
-	}
-
-	printk(KERN_INFO "acpi: RSDP rev: %d oem: %s\n",
-		rsdp->revision, acpi_kill_spaces(oem, rsdp->oem_id, 6));
-
-	if (!acpi_checksum(rsdp, RSDP2_CHECKSUM_LENGTH)
-		&& rsdp->length >= RSDP2_CHECKSUM_LENGTH) {	/* ACPI 2.0 might be present */
-		xsdt = __va(rsdp->xsdt_address);
-		if (bad_ptr(xsdt))
-			return -1; 
-		if (!strncmp(xsdt->header.signature, "XSDT", 4)) {
-			acpi_print_table_header(&xsdt->header);
-			for (i = 0; i < (xsdt->header.length - sizeof(struct acpi_table_header)) / sizeof(u64); i++)
-				if (acpi_process_table(xsdt->entry[i]))
-					return -1;
-			return 0;
-		}
-	}
-
-	rsdt = __va(rsdp->rsdt_address);
-	if (bad_ptr(rsdt))
-		return -1;
-	if (!strncmp(rsdt->header.signature, "RSDT", 4)) {
-		acpi_print_table_header(&rsdt->header);
-		for (i = 0; i < (rsdt->header.length - sizeof(struct acpi_table_header)) / sizeof(u32); i++)
-			if (acpi_process_table(rsdt->entry[i]))
-				return -1;
-		return 0;
-	}
-
-	printk(KERN_WARNING "acpi: No ACPI table directory found.\n");
-	return -1;
-}
-
-static void __init acpi_parse_lapic(struct acpi_table_lapic *local_apic)
-{
-	printk(KERN_INFO "acpi: LAPIC acpi_id: %d id: %d enabled: %d\n",
-		local_apic->acpi_id, local_apic->id, local_apic->flags.enabled);
-}
-
-static void __init acpi_parse_ioapic(struct acpi_table_ioapic *ioapic)
-{
-	printk(KERN_INFO "acpi: IOAPIC id: %d address: %#x global_irq_base: %#x\n",
-		ioapic->id, ioapic->address, ioapic->global_irq_base);
-}
-
-static void __init acpi_parse_int_src_ovr(struct acpi_table_int_src_ovr *intsrc)
-{
-	printk(KERN_INFO "acpi: INT_SRC_OVR bus: %d irq: %d global_irq: %d polarity: %d trigger: %d\n",
-		intsrc->bus, intsrc->bus_irq, intsrc->global_irq, intsrc->flags.polarity, intsrc->flags.trigger);
-}
-
-static void __init acpi_parse_nmi_src(struct acpi_table_nmi_src *nmisrc)
-{
-	printk(KERN_INFO "acpi: NMI_SRC polarity: %d trigger: %d global_irq: %d\n",
-		nmisrc->flags.polarity, nmisrc->flags.trigger, nmisrc->global_irq);
-}
-
-static void __init acpi_parse_lapic_nmi(struct acpi_table_lapic_nmi *localnmi)
-{
-	printk(KERN_INFO "acpi: LAPIC_NMI acpi_id: %d polarity: %d trigger: %d lint: %d\n",
-		localnmi->acpi_id, localnmi->flags.polarity, localnmi->flags.trigger, localnmi->lint);
-}
-
-static void __init acpi_parse_lapic_addr_ovr(struct acpi_table_lapic_addr_ovr *lapic_addr_ovr)
-{
-	printk(KERN_INFO "acpi: LAPIC_ADDR_OVR address: %#lx\n",
-		(unsigned long) lapic_addr_ovr->address);
-}
-
-static void __init acpi_parse_plat_int_src(struct acpi_table_plat_int_src *plintsrc)
-{
-	printk(KERN_INFO "acpi: PLAT_INT_SRC polarity: %d trigger: %d type: %d id: %d eid: %d iosapic_vector: %#x global_irq: %d\n",
-		plintsrc->flags.polarity, plintsrc->flags.trigger, plintsrc->type, plintsrc->id, plintsrc->eid,
-		plintsrc->iosapic_vector, plintsrc->global_irq);
-}
-
-static int __init acpi_parse_madt(struct acpi_table_header *header, unsigned long phys)
-{
-
-	struct acpi_table_madt *madt;
-	struct acpi_madt_entry_header *entry_header;
-	int table_size;
-
-	madt = __va(phys);
-	table_size = header->length - sizeof(*madt);
-	entry_header = (void *)madt + sizeof(*madt);
-
-	while (entry_header && table_size > 0) {
-
-		switch (entry_header->type) {
-			case ACPI_MADT_LAPIC:
-				acpi_parse_lapic((void *) entry_header);
-				break;
-			case ACPI_MADT_IOAPIC:
-				acpi_parse_ioapic((void *) entry_header);
-				break;
-			case ACPI_MADT_INT_SRC_OVR:
-				acpi_parse_int_src_ovr((void *) entry_header);
-				break;
-			case ACPI_MADT_NMI_SRC:
-				acpi_parse_nmi_src((void *) entry_header);
-				break;
-			case ACPI_MADT_LAPIC_NMI:
-				acpi_parse_lapic_nmi((void *) entry_header);
-				break;
-			case ACPI_MADT_LAPIC_ADDR_OVR:
-				acpi_parse_lapic_addr_ovr((void *) entry_header);
-				break;
-			case ACPI_MADT_PLAT_INT_SRC:
-				acpi_parse_plat_int_src((void *) entry_header);
-				break;
-			default:
-				printk(KERN_WARNING "acpi: Unsupported MADT entry type 0x%x\n", entry_header->type);
-				break;
-		}
-
-		table_size -= entry_header->length;
-		entry_header = (void *) entry_header + entry_header->length;
-	}
-
-	printk(KERN_INFO "acpi: Local APIC address %#x\n", madt->lapic_address);
-
-	return 0;
-}
-
-static int __init acpi_parse_hpet(struct acpi_table_header *header, unsigned long phys)
-{
-	struct acpi_table_hpet *hpet_tbl;
-
-	hpet_tbl = __va(phys);
-
-	if (hpet_tbl->addr.space_id != ACPI_SPACE_MEM) {
-		printk(KERN_WARNING "acpi: HPET timers must be located in memory.\n");
-		return -1;
-	}
-
-	hpet_address = hpet_tbl->addr.addrl | ((long) hpet_tbl->addr.addrh << 32);
-
-	printk(KERN_INFO "acpi: HPET id: %#x base: %#lx\n", hpet_tbl->id, hpet_address);
-
-	return 0;
-}
-
-/*
- * Configure the processor info using MADT in the ACPI tables. If we fail to
- * configure that, then we use the MPS tables.
- */
-
-void __init config_acpi_tables(void)
-{
-	acpi_boot_ops[ACPI_APIC] = acpi_parse_madt;
-	acpi_boot_ops[ACPI_HPET] = acpi_parse_hpet;
-
-	if (acpi_tables_init())
-		printk(KERN_ERR "acpi: Init failed.\n");
-}
diff -urNp linux-201/arch/x86_64/kernel/acpitable.h linux-202/arch/x86_64/kernel/acpitable.h
--- linux-201/arch/x86_64/kernel/acpitable.h
+++ linux-202/arch/x86_64/kernel/acpitable.h
@@ -1,212 +0,0 @@
-/*
- *  acpitable.h - x86-64-specific ACPI boot-time initialization
- *
- *  Copyright (C) 1999 Andrew Henroid
- *  Copyright (C) 2001 Richard Schaal
- *  Copyright (C) 2001 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *  Copyright (C) 2001 Jun Nakajima <jun.nakajima@intel.com>
- *  Copyright (C) 2001 Arjan van de Ven <arjanv@redhat.com>
- *  Copyright (C) 2002 Vojtech Pavlik <vojtech@suse.cz>
- */
-
-/*
- * The following codes are cut&pasted from drivers/acpi. Part of the code
- * there can be not updated or delivered yet.
- * To avoid conflicts when CONFIG_ACPI is defined, the following codes are
- * modified so that they are self-contained in this file.
- * -- jun
- */
-
-#ifndef _HEADER_ACPITABLE_H_
-#define _HEADER_ACPITABLE_H_
-
-struct acpi_table_header {		/* ACPI common table header */
-	char signature[4];		/* identifies type of table */
-	u32 length;			/* length of table,
-					   in bytes, * including header */
-	u8 revision;			/* specification minor version # */
-	u8 checksum;			/* to make sum of entire table == 0 */
-	char oem_id[6];			/* OEM identification */
-	char oem_table_id[8];		/* OEM table identification */
-	u32 oem_revision;		/* OEM revision number */
-	char asl_compiler_id[4];	/* ASL compiler vendor ID */
-	u32 asl_compiler_revision;	/* ASL compiler revision number */
-} __attribute__ ((packed));;
-
-enum {
-	ACPI_APIC = 0,
-	ACPI_FACP,
-	ACPI_HPET,
-	ACPI_TABLE_COUNT
-};
-
-static char *acpi_table_signatures[ACPI_TABLE_COUNT] = {
-	"APIC",
-	"FACP",
-	"HPET"
-};
-
-struct acpi_table_madt {
-	struct acpi_table_header header;
-	u32 lapic_address;
-	struct {
-		u32 pcat_compat:1;
-		u32 reserved:31;
-	} flags __attribute__ ((packed));
-} __attribute__ ((packed));;
-
-enum {
-	ACPI_MADT_LAPIC = 0,
-	ACPI_MADT_IOAPIC,
-	ACPI_MADT_INT_SRC_OVR,
-	ACPI_MADT_NMI_SRC,
-	ACPI_MADT_LAPIC_NMI,
-	ACPI_MADT_LAPIC_ADDR_OVR,
-	ACPI_MADT_IOSAPIC,
-	ACPI_MADT_LSAPIC,
-	ACPI_MADT_PLAT_INT_SRC,
-
-};
-
-#define LO_RSDP_WINDOW_BASE		0	/* Physical Address */
-#define HI_RSDP_WINDOW_BASE		0xE0000	/* Physical Address */
-#define LO_RSDP_WINDOW_SIZE		0x400
-#define HI_RSDP_WINDOW_SIZE		0x20000
-#define RSDP_SCAN_STEP			16
-#define RSDP_CHECKSUM_LENGTH		20
-#define RSDP2_CHECKSUM_LENGTH		36
-
-typedef int (*acpi_table_handler) (struct acpi_table_header *header, unsigned long);
-
-struct acpi_table_rsdp {
-	char signature[8];
-	u8 checksum;
-	char oem_id[6];
-	u8 revision;
-	u32 rsdt_address;
-	u32 length;
-	u64 xsdt_address;
-	u8 checksum2;
-	u8 reserved[3];
-} __attribute__ ((packed));
-
-struct acpi_table_rsdt {
-	struct acpi_table_header header;
-	u32 entry[0];
-} __attribute__ ((packed));
-
-struct acpi_table_xsdt {
-	struct acpi_table_header header;
-	u64 entry[0];
-} __attribute__ ((packed));
-
-struct acpi_madt_entry_header {
-	u8 type;
-	u8 length;
-}  __attribute__ ((packed));
-
-struct acpi_madt_int_flags {
-	u16 polarity:2;
-	u16 trigger:2;
-	u16 reserved:12;
-} __attribute__ ((packed));
-
-struct acpi_table_lapic {
-	struct acpi_madt_entry_header header;
-	u8 acpi_id;
-	u8 id;
-	struct {
-		u32 enabled:1;
-		u32 reserved:31;
-	} flags __attribute__ ((packed));
-} __attribute__ ((packed));
-
-struct acpi_table_ioapic {
-	struct acpi_madt_entry_header header;
-	u8 id;
-	u8 reserved;
-	u32 address;
-	u32 global_irq_base;
-} __attribute__ ((packed));
-
-struct acpi_table_int_src_ovr {
-	struct acpi_madt_entry_header header;
-	u8 bus;
-	u8 bus_irq;
-	u32 global_irq;
-	struct acpi_madt_int_flags flags;
-} __attribute__ ((packed));
-
-struct acpi_table_nmi_src {
-	struct acpi_madt_entry_header header;
-	struct acpi_madt_int_flags flags;
-	u32 global_irq;
-} __attribute__ ((packed));
-
-struct acpi_table_lapic_nmi {
-	struct acpi_madt_entry_header header;
-	u8 acpi_id;
-	struct acpi_madt_int_flags flags;
-	u8 lint;
-} __attribute__ ((packed));
-
-struct acpi_table_lapic_addr_ovr {
-	struct acpi_madt_entry_header header;
-	u8 reserved[2];
-	u64 address;
-} __attribute__ ((packed));
-
-struct acpi_table_iosapic {
-	struct acpi_madt_entry_header header;
-	u8 id;
-	u8 reserved;
-	u32 global_irq_base;
-	u64 address;
-} __attribute__ ((packed));
-
-struct acpi_table_lsapic {
-	struct acpi_madt_entry_header header;
-	u8 acpi_id;
-	u8 id;
-	u8 eid;
-	u8 reserved[3];
-	struct {
-		u32 enabled:1;
-		u32 reserved:31;
-	} flags;
-} __attribute__ ((packed));
-
-struct acpi_table_plat_int_src {
-	struct acpi_madt_entry_header header;
-	struct acpi_madt_int_flags flags;
-	u8 type;
-	u8 id;
-	u8 eid;
-	u8 iosapic_vector;
-	u32 global_irq;
-	u32 reserved;
-} __attribute__ ((packed));
-
-#define ACPI_SPACE_MEM		0
-#define ACPI_SPACE_IO		1
-#define ACPI_SPACE_PCICONF	2
-
-struct acpi_gen_regaddr {
-	u8  space_id;
-	u8  bit_width;
-	u8  bit_offset;
-	u8  resv;
-	u32 addrl;
-	u32 addrh;
-} __attribute__ ((packed));
-
-struct acpi_table_hpet {
-	struct acpi_table_header header;
-	u32 id;
-	struct acpi_gen_regaddr addr;
-	u8 number;
-	u16 min_tick;
-	u8 page_protect;
-} __attribute__ ((packed));
-
-#endif
diff -urNp linux-201/arch/x86_64/kernel/apic.c linux-202/arch/x86_64/kernel/apic.c
--- linux-201/arch/x86_64/kernel/apic.c
+++ linux-202/arch/x86_64/kernel/apic.c
@@ -31,8 +31,6 @@
 #include <asm/pgalloc.h>
 #include <asm/timex.h>
 
-int apic_disabled;
-
 extern spinlock_t i8253_lock;
 
 /* Using APIC to generate smp_local_timer_interrupt? */
@@ -1058,7 +1056,6 @@ asmlinkage void smp_error_interrupt(void
 int __init APIC_init_uniprocessor (void)
 {
 	if (!smp_found_config && !cpu_has_apic) { 
-		apic_disabled = 1;
 		return -1;
 	} 
 
@@ -1068,7 +1065,6 @@ int __init APIC_init_uniprocessor (void)
 	if (!cpu_has_apic && APIC_INTEGRATED(apic_version[boot_cpu_id])) {
 		printk(KERN_ERR "BIOS bug, local APIC #%d not detected!...\n",
 			boot_cpu_id);
-		apic_disabled = 1;
 		return -1;
 	}
 
@@ -1095,3 +1091,12 @@ int __init APIC_init_uniprocessor (void)
 
 	return 0;
 }
+
+static int __init disableapictimer(char *str)
+{
+	dont_use_local_apic_timer = 1;
+	return 1;
+}
+
+__setup("noapictimer", disableapictimer);
+
diff -urNp linux-201/arch/x86_64/kernel/e820.c linux-202/arch/x86_64/kernel/e820.c
--- linux-201/arch/x86_64/kernel/e820.c
+++ linux-202/arch/x86_64/kernel/e820.c
@@ -7,6 +7,7 @@
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/init.h>
+#include <linux/acpi.h>
 #include <linux/bootmem.h>
 #include <linux/ioport.h>
 #include <asm/page.h>
@@ -17,6 +18,10 @@
 extern unsigned long table_start, table_end;
 extern char _end[];
 
+#ifdef	CONFIG_ACPI_BOOT
+extern acpi_interrupt_flags	acpi_sci_flags;
+#endif
+
 extern struct resource code_resource, data_resource, vram_resource;
 
 /* Check for some hardcoded bad areas that early boot is not allowed to touch */ 
@@ -500,6 +505,7 @@ void __init setup_memory_region(void)
 extern char command_line[], saved_command_line[];
 extern int fallback_aper_order;
 extern int iommu_setup(char *opt);
+extern int acpi_disabled;
 
 void __init parse_mem_cmdline (char ** cmdline_p)
 {
@@ -533,12 +539,33 @@ void __init parse_mem_cmdline (char ** c
 			end_user_pfn = memparse(from+4, &from) + HIGH_MEMORY;
 			end_user_pfn >>= PAGE_SHIFT;
 		}
+#ifdef CONFIG_ACPI_BOOT
+		else if (!memcmp(from, "acpi=off", 8)) {
+			acpi_disabled = 1;
+		}
+#endif
 #ifdef CONFIG_GART_IOMMU 
 		else if (!memcmp(from,"iommu=",6)) { 
 			iommu_setup(from+6); 
 		} 	
 		
 #endif
+#ifdef	CONFIG_ACPI_BOOT
+		else if (!memcmp(from, "acpi_sci=edge", 13))
+			acpi_sci_flags.trigger =  1;
+		else if (!memcmp(from, "acpi_sci=level", 14))
+			acpi_sci_flags.trigger = 3;
+		else if (!memcmp(from, "acpi_sci=high", 13))
+			acpi_sci_flags.polarity = 1;
+		else if (!memcmp(from, "acpi_sci=low", 12))
+			acpi_sci_flags.polarity = 3;
+#endif
+#ifdef CONFIG_ACPI_PMTMR
+		else if (!memcmp(from, "pmtmr", 5)) {
+			extern int use_pmtmr;
+			use_pmtmr = 1;
+		}
+#endif
 	next:
 		c = *(from++);
 		if (!c)
diff -urNp linux-201/arch/x86_64/kernel/head.S linux-202/arch/x86_64/kernel/head.S
--- linux-201/arch/x86_64/kernel/head.S
+++ linux-202/arch/x86_64/kernel/head.S
@@ -199,6 +199,7 @@ ENTRY(no_long_mode)
 	jmp	1b	
 	
 .org 0xf00
+	.globl	pGDT32
 pGDT32:
 	.word	gdt32_end-gdt_table32
 	.long	gdt_table32-__START_KERNEL+0x100000
@@ -312,6 +313,15 @@ ENTRY(level3_physmem_pgt)
 	.quad	0x0000000000105007		/* -> level2_kernel_pgt (so that __va works even before pagetable_init) */
 
 .org 0xb000
+ENTRY(wakeup_level4_pgt)
+	.quad   0x0000000000102007              /* -> level3_ident_pgt */
+	.fill   255,8,0
+	.quad   0x000000000010a007
+	.fill   254,8,0
+	/* (2^48-(2*1024*1024*1024))/(2^39) = 511 */
+	.quad   0x0000000000103007              /* -> level3_kernel_pgt */
+
+.org 0xc000
 .data
 
 	.align 16
diff -urNp linux-201/arch/x86_64/kernel/io_apic.c linux-202/arch/x86_64/kernel/io_apic.c
--- linux-201/arch/x86_64/kernel/io_apic.c
+++ linux-202/arch/x86_64/kernel/io_apic.c
@@ -32,6 +32,7 @@
 #include <asm/io.h>
 #include <asm/smp.h>
 #include <asm/desc.h>
+#include <asm/acpi.h>
 
 #undef APIC_LOCKUP_DEBUG
 
@@ -1046,6 +1047,10 @@ static void __init setup_ioapic_ids_from
 	unsigned char old_id;
 	unsigned long flags;
 
+	if (acpi_ioapic)
+		/* This gets done during IOAPIC enumeration for ACPI. */
+		return;
+
 	/*
 	 * Set the IOAPIC ID to the value stored in the MPC table.
 	 */
@@ -1651,3 +1656,90 @@ void __init setup_IO_APIC(void)
 	check_timer();
 	print_IO_APIC();
 }
+
+
+/* --------------------------------------------------------------------------
+                          ACPI-based IOAPIC Configuration
+   -------------------------------------------------------------------------- */
+
+#ifdef CONFIG_ACPI_BOOT
+
+int __init io_apic_get_version (int ioapic)
+{
+	struct IO_APIC_reg_01	reg_01;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ioapic_lock, flags);
+	*(int *)&reg_01 = io_apic_read(ioapic, 1);
+	spin_unlock_irqrestore(&ioapic_lock, flags);
+
+	return reg_01.version;
+}
+
+
+int __init io_apic_get_redir_entries (int ioapic)
+{
+	struct IO_APIC_reg_01	reg_01;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ioapic_lock, flags);
+	*(int *)&reg_01 = io_apic_read(ioapic, 1);
+	spin_unlock_irqrestore(&ioapic_lock, flags);
+
+	return reg_01.entries;
+}
+
+
+int io_apic_set_pci_routing (int ioapic, int pin, int irq, int edge_level, int active_high_low)
+{
+	struct IO_APIC_route_entry entry;
+	unsigned long flags;
+
+	if (!IO_APIC_IRQ(irq)) {
+		printk(KERN_ERR "IOAPIC[%d]: Invalid reference to IRQ 0/n", 
+			ioapic);
+		return -EINVAL;
+	}
+
+	/*
+	 * Generate a PCI IRQ routing entry and program the IOAPIC accordingly.
+	 * Note that we mask (disable) IRQs now -- these get enabled when the
+	 * corresponding device driver registers for this IRQ.
+	 */
+
+	memset(&entry,0,sizeof(entry));
+
+	entry.delivery_mode = dest_LowestPrio;
+	entry.dest_mode = INT_DELIVERY_MODE;
+	entry.dest.logical.logical_dest = TARGET_CPUS;
+	entry.mask = 1;					 /* Disabled (masked) */
+	entry.trigger = edge_level;
+	entry.polarity = active_high_low;
+
+	add_pin_to_irq(irq, ioapic, pin);
+
+	entry.vector = assign_irq_vector(irq);
+
+	printk(KERN_DEBUG "IOAPIC[%d]: Set PCI routing entry (%d-%d -> 0x%x -> "
+		"IRQ %d) Mode:%i Active:%i\n", ioapic, 
+		mp_ioapics[ioapic].mpc_apicid, pin, entry.vector, irq, edge_level, active_high_low);
+
+	if (edge_level)
+		irq_desc[irq].handler = &ioapic_level_irq_type;
+	else
+		irq_desc[irq].handler = &ioapic_edge_irq_type;
+
+	set_intr_gate(entry.vector, interrupt[irq]);
+
+	if (!ioapic && (irq < 16))
+		disable_8259A_irq(irq);
+
+	spin_lock_irqsave(&ioapic_lock, flags);
+	io_apic_write(ioapic, 0x11+2*pin, *(((int *)&entry)+1));
+	io_apic_write(ioapic, 0x10+2*pin, *(((int *)&entry)+0));
+	spin_unlock_irqrestore(&ioapic_lock, flags);
+
+	return entry.vector;
+}
+
+#endif /*CONFIG_ACPI_BOOT*/
diff -urNp linux-201/arch/x86_64/kernel/mpparse.c linux-202/arch/x86_64/kernel/mpparse.c
--- linux-201/arch/x86_64/kernel/mpparse.c
+++ linux-202/arch/x86_64/kernel/mpparse.c
@@ -1,5 +1,5 @@
 /*
- *	Intel Multiprocessor Specificiation 1.1 and 1.4
+ *	Intel Multiprocessor Specification 1.1 and 1.4
  *	compliant MP-table parsing routines.
  *
  *	(c) 1995 Alan Cox, Building #3 <alan@redhat.com>
@@ -10,6 +10,7 @@
  *		Alan Cox	:	Added EBDA scanning
  *		Ingo Molnar	:	various cleanups and rewrites
  *	Maciej W. Rozycki	:	Bits for default MP configurations
+ *		Paul Diefenbaugh:	Added full ACPI support
  */
 
 #include <linux/mm.h>
@@ -21,16 +22,19 @@
 #include <linux/smp_lock.h>
 #include <linux/kernel_stat.h>
 #include <linux/mc146818rtc.h>
+#include <linux/acpi.h>
 
 #include <asm/smp.h>
 #include <asm/mtrr.h>
 #include <asm/mpspec.h>
 #include <asm/pgalloc.h>
-#include <asm/e820.h>
+#include <asm/io_apic.h>
 #include <asm/proto.h>
 
 /* Have we found an MP table */
-int smp_found_config = 0;
+int smp_found_config;
+
+int acpi_found_madt;
 
 /*
  * Various Linux-internal data structures created from the
@@ -63,6 +67,19 @@ static unsigned int num_processors = 0;
 /* Bitmask of physically existing CPUs */
 unsigned long phys_cpu_present_map = 0;
 
+/* ACPI MADT entry parsing functions */
+#ifdef CONFIG_ACPI_BOOT
+extern struct acpi_boot_flags acpi_boot;
+#ifdef CONFIG_X86_LOCAL_APIC
+extern int acpi_parse_lapic (acpi_table_entry_header *header);
+extern int acpi_parse_lapic_addr_ovr (acpi_table_entry_header *header);
+extern int acpi_parse_lapic_nmi (acpi_table_entry_header *header);
+#endif /*CONFIG_X86_LOCAL_APIC*/
+#ifdef CONFIG_X86_IO_APIC
+extern int acpi_parse_ioapic (acpi_table_entry_header *header);
+#endif /*CONFIG_X86_IO_APIC*/
+#endif /*CONFIG_ACPI_BOOT*/
+
 /*
  * Intel MP BIOS table parsing routines:
  */
@@ -88,21 +105,12 @@ static void __init MP_processor_info (st
 	if (!(m->mpc_cpuflag & CPU_ENABLED))
 		return;
 
-	printk("Processor #%d %d:%d APIC version %d\n",
+	printk(KERN_INFO "Processor #%d %d:%d APIC version %d\n",
 		m->mpc_apicid,
 	       (m->mpc_cpufeature & CPU_FAMILY_MASK)>>8,
 	       (m->mpc_cpufeature & CPU_MODEL_MASK)>>4,
 		m->mpc_apicver);
 
-	if (m->mpc_featureflag&(1<<0))
-		Dprintk("    Floating point unit present.\n");
-	if (m->mpc_featureflag&(1<<7))
-		Dprintk("    Machine Exception supported.\n");
-	if (m->mpc_featureflag&(1<<8))
-		Dprintk("    64 bit compare & exchange supported.\n");
-	if (m->mpc_featureflag&(1<<9))
-		Dprintk("    Internal APIC present.\n");
-
 	if (m->mpc_cpuflag & CPU_BOOTPROCESSOR) {
 		Dprintk("    Bootup CPU\n");
 		boot_cpu_id = m->mpc_apicid;
@@ -110,7 +118,7 @@ static void __init MP_processor_info (st
 	num_processors++;
 
 	if (m->mpc_apicid > MAX_APICS) {
-		printk("Processor #%d INVALID. (Max ID: %d).\n",
+		printk(KERN_ERR "Processor #%d INVALID. (Max ID: %d).\n",
 			m->mpc_apicid, MAX_APICS);
 		return;
 	}
@@ -121,7 +129,7 @@ static void __init MP_processor_info (st
 	 * Validate version
 	 */
 	if (ver == 0x0) {
-		printk("BIOS bug, APIC version is 0 for CPU#%d! fixing up to 0x10. (tell your hw vendor)\n", m->mpc_apicid);
+		printk(KERN_ERR "BIOS bug, APIC version is 0 for CPU#%d! fixing up to 0x10. (tell your hw vendor)\n", m->mpc_apicid);
 		ver = 0x10;
 	}
 	apic_version[m->mpc_apicid] = ver;
@@ -135,9 +143,7 @@ static void __init MP_bus_info (struct m
 	str[6] = 0;
 	Dprintk("Bus #%d is %s\n", m->mpc_busid, str);
 
-	if (m->mpc_busid >= MAX_MP_BUSSES) {
-		printk(KERN_ERR "MAX_MP_BUSSES ERROR mpc_busid %d, max %d\n", m->mpc_busid, MAX_MP_BUSSES);
-	} else if (strncmp(str, "ISA", 3) == 0) {
+	if (strncmp(str, "ISA", 3) == 0) {
 		mp_bus_id_to_type[m->mpc_busid] = MP_BUS_ISA;
 	} else if (strncmp(str, "EISA", 4) == 0) {
 		mp_bus_id_to_type[m->mpc_busid] = MP_BUS_EISA;
@@ -148,8 +154,7 @@ static void __init MP_bus_info (struct m
 	} else if (strncmp(str, "MCA", 3) == 0) {
 		mp_bus_id_to_type[m->mpc_busid] = MP_BUS_MCA;
 	} else {
-		printk("Unknown bustype %s\n", str);
-		panic("cannot handle bus - mail to linux-smp@vger.kernel.org");
+		printk(KERN_ERR "Unknown bustype %s\n", str);
 	}
 }
 
@@ -161,7 +166,7 @@ static void __init MP_ioapic_info (struc
 	printk("I/O APIC #%d Version %d at 0x%X.\n",
 		m->mpc_apicid, m->mpc_apicver, m->mpc_apicaddr);
 	if (nr_ioapics >= MAX_IO_APICS) {
-		printk("Max # of I/O APICs (%d) exceeded (found %d).\n",
+		printk(KERN_ERR "Max # of I/O APICs (%d) exceeded (found %d).\n",
 			MAX_IO_APICS, nr_ioapics);
 		panic("Recompile kernel with bigger MAX_IO_APICS!.\n");
 	}
@@ -241,15 +246,16 @@ static int __init smp_read_mpc(struct mp
 	}
 	memcpy(str,mpc->mpc_oem,8);
 	str[8]=0;
-	printk("OEM ID: %s ",str);
+	printk(KERN_INFO "OEM ID: %s ",str);
 
 	memcpy(str,mpc->mpc_productid,12);
 	str[12]=0;
-	printk("Product ID: %s ",str);
+	printk(KERN_INFO "Product ID: %s ",str);
 
-	printk("APIC at: 0x%X\n",mpc->mpc_lapic);
+	printk(KERN_INFO "APIC at: 0x%X\n",mpc->mpc_lapic);
 
 	/* save the local APIC address, it might be non-default */
+	if (!acpi_lapic)
 	mp_lapic_addr = mpc->mpc_lapic;
 
 	/*
@@ -261,6 +267,7 @@ static int __init smp_read_mpc(struct mp
 			{
 				struct mpc_config_processor *m=
 					(struct mpc_config_processor *)mpt;
+				if (!acpi_lapic)
 				MP_processor_info(m);
 				mpt += sizeof(*m);
 				count += sizeof(*m);
@@ -340,12 +347,12 @@ static void __init construct_default_ioi
 	 *  If it does, we assume it's valid.
 	 */
 	if (mpc_default_type == 5) {
-		printk("ISA/PCI bus type with no IRQ information... falling back to ELCR\n");
+		printk(KERN_INFO "ISA/PCI bus type with no IRQ information... falling back to ELCR\n");
 
 		if (ELCR_trigger(0) || ELCR_trigger(1) || ELCR_trigger(2) || ELCR_trigger(13))
-			printk("ELCR contains invalid data... not using ELCR\n");
+			printk(KERN_ERR "ELCR contains invalid data... not using ELCR\n");
 		else {
-			printk("Using ELCR to identify PCI interrupts\n");
+			printk(KERN_INFO "Using ELCR to identify PCI interrupts\n");
 			ELCR_fallback = 1;
 		}
 	}
@@ -420,7 +427,7 @@ static inline void __init construct_defa
 	bus.mpc_busid = 0;
 	switch (mpc_default_type) {
 		default:
-			printk("???\nUnknown standard configuration %d\n",
+			printk(KERN_ERR "???\nUnknown standard configuration %d\n",
 				mpc_default_type);
 			/* fall through */
 		case 1:
@@ -475,12 +482,26 @@ static struct intel_mp_floating *mpf_fou
 void __init get_smp_config (void)
 {
 	struct intel_mp_floating *mpf = mpf_found;
+
+	/*
+ 	 * ACPI may be used to obtain the entire SMP configuration or just to 
+ 	 * enumerate/configure processors (CONFIG_ACPI_HT_ONLY).  Note that 
+ 	 * ACPI supports both logical (e.g. Hyper-Threading) and physical 
+ 	 * processors, where MPS only supports physical.
+ 	 */
+ 	if (acpi_lapic && acpi_ioapic) {
+ 		printk(KERN_INFO "Using ACPI (MADT) for SMP configuration information\n");
+ 		return;
+	}
+ 	else if (acpi_lapic)
+ 		printk(KERN_INFO "Using ACPI for processor (LAPIC) configuration information\n");
+
 	printk("Intel MultiProcessor Specification v1.%d\n", mpf->mpf_specification);
 	if (mpf->mpf_feature2 & (1<<7)) {
-		printk("    IMCR and PIC compatibility mode.\n");
+		printk(KERN_INFO "    IMCR and PIC compatibility mode.\n");
 		pic_mode = 1;
 	} else {
-		printk("    Virtual Wire compatibility mode.\n");
+		printk(KERN_INFO "    Virtual Wire compatibility mode.\n");
 		pic_mode = 0;
 	}
 
@@ -489,15 +510,16 @@ void __init get_smp_config (void)
 	 */
 	if (mpf->mpf_feature1 != 0) {
 
-		printk("Default MP configuration #%d\n", mpf->mpf_feature1);
+		printk(KERN_INFO "Default MP configuration #%d\n", mpf->mpf_feature1);
 		construct_default_ISA_mptable(mpf->mpf_feature1);
 
 	} else if (mpf->mpf_physptr) {
+
 		/*
 		 * Read the physical hardware table.  Anything here will
 		 * override the defaults.
 		 */
-		if (!smp_read_mpc(__va(mpf->mpf_physptr))) {
+		if (!smp_read_mpc((void *)(unsigned long)mpf->mpf_physptr)) {
 			smp_found_config = 0;
 			printk(KERN_ERR "BIOS bug, MP table errors detected!...\n");
 			printk(KERN_ERR "... disabling SMP support. (tell your hw vendor)\n");
@@ -511,7 +533,7 @@ void __init get_smp_config (void)
 		if (!mp_irq_entries) {
 			struct mpc_config_bus bus;
 
-			printk("BIOS bug, no explicit IRQ entries, using default mptable. (tell your hw vendor)\n");
+			printk(KERN_ERR "BIOS bug, no explicit IRQ entries, using default mptable. (tell your hw vendor)\n");
 
 			bus.mpc_type = MP_BUS;
 			bus.mpc_busid = 0;
@@ -524,7 +546,7 @@ void __init get_smp_config (void)
 	} else
 		BUG();
 
-	printk("Processors: %d\n", num_processors);
+	printk(KERN_INFO "Processors: %d\n", num_processors);
 	/*
 	 * Only use the first configuration found.
 	 */
@@ -532,12 +554,13 @@ void __init get_smp_config (void)
 
 static int __init smp_scan_config (unsigned long base, unsigned long length)
 {
+	extern void __bad_mpf_size(void); 
 	unsigned int *bp = phys_to_virt(base);
 	struct intel_mp_floating *mpf;
 
-	printk("Scan SMP from %p for %ld bytes.\n", bp,length);
+	Dprintk("Scan SMP from %p for %ld bytes.\n", bp,length);
 	if (sizeof(*mpf) != 16)
-		printk("Error: MPF size\n");
+		__bad_mpf_size();
 
 	while (length > 0) {
 		mpf = (struct intel_mp_floating *)bp;
@@ -548,11 +571,11 @@ static int __init smp_scan_config (unsig
 				|| (mpf->mpf_specification == 4)) ) {
 
 			smp_found_config = 1;
-			printk(KERN_INFO "found SMP MP-table at %016lx\n",
+			printk(KERN_INFO "found SMP MP-table at %08lx\n",
 						virt_to_phys(mpf));
-			reserve_bootmem_generic(virt_to_phys(mpf), PAGE_SIZE); 
+			reserve_bootmem_generic(virt_to_phys(mpf), PAGE_SIZE);
 			if (mpf->mpf_physptr)
-				reserve_bootmem_generic(mpf->mpf_physptr, PAGE_SIZE); 
+				reserve_bootmem_generic(mpf->mpf_physptr, PAGE_SIZE);
 			mpf_found = mpf;
 			return 1;
 		}
@@ -564,7 +587,7 @@ static int __init smp_scan_config (unsig
 
 void __init find_intel_smp (void)
 {
-	unsigned long address;
+	unsigned int address;
 
 	/*
 	 * FIXME: Linux assumes you have 640K of base ram..
@@ -578,8 +601,6 @@ void __init find_intel_smp (void)
 		smp_scan_config(639*0x400,0x400) ||
 			smp_scan_config(0xF0000,0x10000))
 		return;
-		printk("ok\n");
-		
 	/*
 	 * If it is an SMP machine we should know now, unless the
 	 * configuration is in an EISA/MCA bus machine with an
@@ -593,15 +614,11 @@ void __init find_intel_smp (void)
 	 * trustworthy, simply because the SMP table may have been
 	 * stomped on during early boot. These loaders are buggy and
 	 * should be fixed.
-	 *
-	 * MP1.4 SPEC states to only scan first 1K of 4K EBDA.
 	 */
 
 	address = *(unsigned short *)phys_to_virt(0x40E);
 	address <<= 4;
-	smp_scan_config(address, 0x400);
-	if (smp_found_config)
-		printk(KERN_WARNING "WARNING: MP table in the EBDA can be UNSAFE, contact linux-smp@vger.kernel.org if you experience SMP problems!\n");
+	smp_scan_config(address, 0x1000);
 }
 
 /*
@@ -614,3 +631,352 @@ void __init find_smp_config (void)
 #endif
 }
 
+
+/* --------------------------------------------------------------------------
+                            ACPI-based MP Configuration
+   -------------------------------------------------------------------------- */
+
+#ifdef CONFIG_ACPI_BOOT
+
+void __init mp_register_lapic_address (
+	u64			address)
+{
+	Dprintk("mp_register_lapic_address(0x%lx)\n", address);
+
+	mp_lapic_addr = (unsigned long) address;
+
+	set_fixmap_nocache(FIX_APIC_BASE, mp_lapic_addr);
+
+	if (boot_cpu_id == -1U)
+		boot_cpu_id = GET_APIC_ID(apic_read(APIC_ID));
+
+	Dprintk("Boot CPU = %d\n", boot_cpu_physical_apicid);
+}
+
+
+void __init mp_register_lapic (
+	u8			id, 
+	u8			enabled)
+{
+	struct mpc_config_processor processor;
+	int			boot_cpu = 0;
+
+	Dprintk("mp_register_lapic(%d, %d)\n", id, enabled);
+	
+	if (id >= MAX_APICS) {
+		printk(KERN_WARNING "Processor #%d invalid (max %d)\n",
+			id, MAX_APICS);
+		return;
+	}
+
+	if (id == boot_cpu_physical_apicid)
+		boot_cpu = 1;
+
+	processor.mpc_type = MP_PROCESSOR;
+	processor.mpc_apicid = id;
+	processor.mpc_apicver = 0x10; /* TBD: lapic version */
+	processor.mpc_cpuflag = (enabled ? CPU_ENABLED : 0);
+	processor.mpc_cpuflag |= (boot_cpu ? CPU_BOOTPROCESSOR : 0);
+	processor.mpc_cpufeature = (boot_cpu_data.x86 << 8) | 
+		(boot_cpu_data.x86_model << 4) | boot_cpu_data.x86_mask;
+	processor.mpc_featureflag = boot_cpu_data.x86_capability[0];
+	processor.mpc_reserved[0] = 0;
+	processor.mpc_reserved[1] = 0;
+
+	MP_processor_info(&processor);
+}
+
+#ifdef CONFIG_X86_IO_APIC
+
+#define MP_ISA_BUS		0
+#define MP_MAX_IOAPIC_PIN	127
+
+struct mp_ioapic_routing {
+	int			apic_id;
+	int			irq_start;
+	int			irq_end;
+	u32			pin_programmed[4];
+} mp_ioapic_routing[MAX_IO_APICS];
+
+
+static int __init mp_find_ioapic (
+	int			irq)
+{
+	int			i = 0;
+
+	Dprintk("mp_find_ioapic(%d)\n", irq);
+
+	/* Find the IOAPIC that manages this IRQ. */
+	for (i = 0; i < nr_ioapics; i++) {
+		if ((irq >= mp_ioapic_routing[i].irq_start)
+			&& (irq <= mp_ioapic_routing[i].irq_end))
+			return i;
+	}
+
+	printk(KERN_ERR "ERROR: Unable to locate IOAPIC for IRQ %d/n", irq);
+
+	return -1;
+}
+	
+
+void __init mp_register_ioapic (
+	u8			id, 
+	u32			address,
+	u32			irq_base)
+{
+	int			idx = 0;
+
+	Dprintk("mp_register_ioapic(%d, 0x%x, 0x%x)\n", id, address, irq_base);
+
+	if (nr_ioapics >= MAX_IO_APICS) {
+		printk(KERN_ERR "ERROR: Max # of I/O APICs (%d) exceeded "
+			"(found %d)\n", MAX_IO_APICS, nr_ioapics);
+		panic("Recompile kernel with bigger MAX_IO_APICS!\n");
+	}
+	if (!address) {
+		printk(KERN_ERR "WARNING: Bogus (zero) I/O APIC address"
+			" found in MADT table, skipping!\n");
+		return;
+	}
+
+	idx = nr_ioapics++;
+
+	mp_ioapics[idx].mpc_type = MP_IOAPIC;
+	mp_ioapics[idx].mpc_flags = MPC_APIC_USABLE;
+	mp_ioapics[idx].mpc_apicaddr = address;
+
+	set_fixmap_nocache(FIX_IO_APIC_BASE_0 + idx, address);
+	mp_ioapics[idx].mpc_apicid = id;
+	mp_ioapics[idx].mpc_apicver = io_apic_get_version(idx);
+	
+	/* 
+	 * Build basic IRQ lookup table to facilitate irq->io_apic lookups
+	 * and to prevent reprogramming of IOAPIC pins (PCI IRQs).
+	 */
+	mp_ioapic_routing[idx].apic_id = mp_ioapics[idx].mpc_apicid;
+	mp_ioapic_routing[idx].irq_start = irq_base;
+	mp_ioapic_routing[idx].irq_end = irq_base + 
+		io_apic_get_redir_entries(idx);
+
+	printk(KERN_INFO "IOAPIC[%d]: apic_id %d, version %d, address 0x%x, "
+		"IRQ %d-%d\n", idx, mp_ioapics[idx].mpc_apicid, 
+		mp_ioapics[idx].mpc_apicver, mp_ioapics[idx].mpc_apicaddr,
+		mp_ioapic_routing[idx].irq_start,
+		mp_ioapic_routing[idx].irq_end);
+
+	return;
+}
+
+
+void __init mp_override_legacy_irq (
+	u8			bus_irq,
+	u8			polarity, 
+	u8			trigger, 
+	u32			global_irq)
+{
+	struct mpc_config_intsrc intsrc;
+	int			i = 0;
+	int			found = 0;
+	int			ioapic = -1;
+	int			pin = -1;
+
+	Dprintk("mp_override_legacy_irq(%d, %d, %d, %d)\n", bus_irq, polarity, trigger, global_irq);
+
+	/* 
+	 * Convert 'global_irq' to 'ioapic.pin'.
+	 */
+	ioapic = mp_find_ioapic(global_irq);
+	if (ioapic < 0)
+		return;
+	pin = global_irq - mp_ioapic_routing[ioapic].irq_start;
+
+	/*
+	 * TBD: This check is for faulty timer entries, where the override
+	 *      erroneously sets the trigger to level, resulting in a HUGE 
+	 *      increase of timer interrupts!
+	 */
+	if ((bus_irq == 0) && (global_irq == 2) && (trigger == 3))
+		trigger = 1;
+
+	intsrc.mpc_type = MP_INTSRC;
+	intsrc.mpc_irqtype = mp_INT;
+	intsrc.mpc_irqflag = (trigger << 2) | polarity;
+	intsrc.mpc_srcbus = MP_ISA_BUS;
+	intsrc.mpc_srcbusirq = bus_irq;				       /* IRQ */
+	intsrc.mpc_dstapic = mp_ioapics[ioapic].mpc_apicid;	   /* APIC ID */
+	intsrc.mpc_dstirq = pin;				    /* INTIN# */
+
+	Dprintk("Int: type %d, pol %d, trig %d, bus %d, irq %d, %d-%d\n", 
+		intsrc.mpc_irqtype, intsrc.mpc_irqflag & 3, 
+		(intsrc.mpc_irqflag >> 2) & 3, intsrc.mpc_srcbus, 
+		intsrc.mpc_srcbusirq, intsrc.mpc_dstapic, intsrc.mpc_dstirq);
+
+	/* 
+	 * If an existing [IOAPIC.PIN -> IRQ] routing entry exists we override it.
+	 * Otherwise create a new entry (e.g. global_irq == 2).
+	 */
+	for (i = 0; i < mp_irq_entries; i++) {
+		if ((mp_irqs[i].mpc_dstapic == intsrc.mpc_dstapic) 
+			&& (mp_irqs[i].mpc_dstirq == intsrc.mpc_dstirq)) {
+			mp_irqs[i] = intsrc;
+			found = 1;
+			break;
+		}
+	}
+	if (!found) {
+		mp_irqs[mp_irq_entries] = intsrc;
+		if (++mp_irq_entries == MAX_IRQ_SOURCES)
+			panic("Max # of irq sources exceeded!\n");
+	}
+
+	return;
+}
+
+
+void __init mp_config_acpi_legacy_irqs (void)
+{
+	struct mpc_config_intsrc intsrc;
+	int			i = 0;
+	int			ioapic = -1;
+
+	Dprintk("mp_config_acpi_legacy_irqs()\n");
+
+	/* 
+	 * Fabricate the legacy ISA bus (bus #31).
+	 */
+	mp_bus_id_to_type[MP_ISA_BUS] = MP_BUS_ISA;
+	Dprintk("Bus #%d is ISA\n", MP_ISA_BUS);
+
+	/* 
+	 * Locate the IOAPIC that manages the ISA IRQs (0-15). 
+	 */
+	ioapic = mp_find_ioapic(0);
+	if (ioapic < 0)
+		return;
+
+	intsrc.mpc_type = MP_INTSRC;
+	intsrc.mpc_irqflag = 0;					/* Conforming */
+	intsrc.mpc_srcbus = MP_ISA_BUS;
+	intsrc.mpc_dstapic = mp_ioapics[ioapic].mpc_apicid;
+
+	/* 
+	 * Use the default configuration for the IRQs 0-15.  These may be
+	 * overridden by (MADT) interrupt source override entries.
+	 */
+	for (i = 0; i < 16; i++) {
+
+		if (i == 2) continue;			/* Don't connect IRQ2 */
+
+		intsrc.mpc_irqtype = i ? mp_INT : mp_ExtINT;   /* 8259A to #0 */
+		intsrc.mpc_srcbusirq = i;		   /* Identity mapped */
+		intsrc.mpc_dstirq = i;
+
+		Dprintk("Int: type %d, pol %d, trig %d, bus %d, irq %d, "
+			"%d-%d\n", intsrc.mpc_irqtype, intsrc.mpc_irqflag & 3, 
+			(intsrc.mpc_irqflag >> 2) & 3, intsrc.mpc_srcbus, 
+			intsrc.mpc_srcbusirq, intsrc.mpc_dstapic, 
+			intsrc.mpc_dstirq);
+
+		mp_irqs[mp_irq_entries] = intsrc;
+		if (++mp_irq_entries == MAX_IRQ_SOURCES)
+			panic("Max # of irq sources exceeded!\n");
+	}
+
+	return;
+}
+
+
+
+#ifndef CONFIG_ACPI_HT_ONLY
+
+extern FADT_DESCRIPTOR acpi_fadt;
+
+#endif /*CONFIG_ACPI_HT_ONLY*/
+
+int acpi_tolerant;
+
+#ifdef CONFIG_ACPI_PCI
+
+void __init mp_parse_prt (void)
+{
+	struct list_head	*node = NULL;
+	struct acpi_prt_entry	*entry = NULL;
+	int			vector = 0;
+	int			ioapic = -1;
+	int			ioapic_pin = 0;
+	int			irq = 0;
+	int			idx, bit = 0;
+	int			edge_level = 0;
+	int			active_high_low = 0;
+
+	/*
+	 * Parsing through the PCI Interrupt Routing Table (PRT) and program
+	 * routing for all static (IOAPIC-direct) entries.
+	 */
+	list_for_each(node, &acpi_prt.entries) {
+		entry = list_entry(node, struct acpi_prt_entry, node);
+
+		/* Need to get irq for dynamic entry */
+		if (entry->link.handle) {
+			irq = acpi_pci_link_get_irq(entry->link.handle, entry->link.index, &edge_level, &active_high_low);
+			if (!irq)
+				continue;
+		} else {
+			edge_level = 1;
+			active_high_low = 1;
+			irq = entry->link.index;
+		}
+
+
+  		/* Don't set up the ACPI SCI because it's already set up */
+                if (acpi_fadt.sci_int == irq) {
+                         entry->irq = irq; /*we still need to set entry's irq*/
+ 			continue;
+                }
+
+		ioapic = mp_find_ioapic(irq);
+		if (ioapic < 0)
+			continue;
+		ioapic_pin = irq - mp_ioapic_routing[ioapic].irq_start;
+
+		/* 
+		 * Avoid pin reprogramming.  PRTs typically include entries  
+		 * with redundant pin->irq mappings (but unique PCI devices);
+		 * we only only program the IOAPIC on the first.
+		 */
+		bit = ioapic_pin % 32;
+		idx = (ioapic_pin < 32) ? 0 : (ioapic_pin / 32);
+		if (idx > 3) {
+			printk(KERN_ERR "Invalid reference to IOAPIC pin "
+				"%d-%d\n", mp_ioapic_routing[ioapic].apic_id, 
+				ioapic_pin);
+			continue;
+		}
+		if ((1<<bit) & mp_ioapic_routing[ioapic].pin_programmed[idx]) {
+			printk(KERN_DEBUG "Pin %d-%d already programmed\n",
+				mp_ioapic_routing[ioapic].apic_id, ioapic_pin);
+			entry->irq = irq;
+			continue;
+		}
+
+		mp_ioapic_routing[ioapic].pin_programmed[idx] |= (1<<bit);
+
+		vector = io_apic_set_pci_routing(ioapic, ioapic_pin, irq, edge_level, active_high_low);
+		if (vector)
+			entry->irq = irq;
+
+		printk(KERN_DEBUG "%02x:%02x:%02x[%c] -> %d-%d -> vector 0x%02x"
+			" -> IRQ %d\n", entry->id.segment, entry->id.bus, 
+			entry->id.device, ('A' + entry->pin), 
+			mp_ioapic_routing[ioapic].apic_id, ioapic_pin, vector, 
+			entry->irq);
+	}
+	
+	return;
+}
+
+#endif /*CONFIG_ACPI_PCI*/
+
+#endif /*CONFIG_X86_IO_APIC*/
+
+#endif /*CONFIG_ACPI_BOOT*/
diff -urNp linux-201/arch/x86_64/kernel/pci-irq.c linux-202/arch/x86_64/kernel/pci-irq.c
--- linux-201/arch/x86_64/kernel/pci-irq.c
+++ linux-202/arch/x86_64/kernel/pci-irq.c
@@ -116,7 +116,7 @@ static void __init pirq_peer_trick(void)
  *  Code for querying and setting of IRQ routes on various interrupt routers.
  */
 
-static void eisa_set_level_irq(unsigned int irq)
+void eisa_set_level_irq(unsigned int irq)
 {
 	unsigned char mask = 1 << (irq & 7);
 	unsigned int port = 0x4d0 + (irq >> 3);
diff -urNp linux-201/arch/x86_64/kernel/pci-pc.c linux-202/arch/x86_64/kernel/pci-pc.c
--- linux-201/arch/x86_64/kernel/pci-pc.c
+++ linux-202/arch/x86_64/kernel/pci-pc.c
@@ -18,6 +18,7 @@
 #include <linux/pci.h>
 #include <linux/init.h>
 #include <linux/ioport.h>
+#include <linux/acpi.h>
 
 #include <asm/segment.h>
 #include <asm/io.h>
@@ -31,6 +32,13 @@ int pcibios_last_bus = -1;
 struct pci_bus *pci_root_bus;
 struct pci_ops *pci_root_ops;
 
+int (*pci_config_read)(int seg, int bus, int dev, int fn, int reg, int len, u32 *value) = NULL;
+int (*pci_config_write)(int seg, int bus, int dev, int fn, int reg, int len, u32 value) = NULL;
+
+static spinlock_t pci_config_lock = SPIN_LOCK_UNLOCKED;
+
+static unsigned int acpi_root_bridges;
+
 /*
  * Direct access to PCI hardware...
  */
@@ -41,48 +49,126 @@ struct pci_ops *pci_root_ops;
  * Functions for accessing PCI configuration space with type 1 accesses
  */
 
+#define PCI_CONF1_ADDRESS(bus, dev, fn, reg) \
+	(0x80000000 | (bus << 16) | (dev << 11) | (fn << 8) | (reg & ~3))
+
+/* These two functions are only used by ACPI code */
+
+static int pci_conf1_read (int seg, int bus, int dev, int fn, int reg, int len, u32 *value) /* !CONFIG_MULTIQUAD */
+{
+	unsigned long flags;
+
+	if (bus > 255 || dev > 31 || fn > 7 || reg > 255)
+		return -EINVAL;
+
+	spin_lock_irqsave(&pci_config_lock, flags);
+
+	outl(PCI_CONF1_ADDRESS(bus, dev, fn, reg), 0xCF8);
+
+	switch (len) {
+	case 1:
+		*value = inb(0xCFC + (reg & 3));
+		break;
+	case 2:
+		*value = inw(0xCFC + (reg & 2));
+		break;
+	case 4:
+		*value = inl(0xCFC);
+		break;
+	}
+
+	spin_unlock_irqrestore(&pci_config_lock, flags);
+
+	return 0;
+}
+
+static int pci_conf1_write (int seg, int bus, int dev, int fn, int reg, int len, u32 value) /* !CONFIG_MULTIQUAD */
+{
+	unsigned long flags;
+
+	if ((bus > 255 || dev > 31 || fn > 7 || reg > 255)) 
+		return -EINVAL;
+
+	spin_lock_irqsave(&pci_config_lock, flags);
+
+	outl(PCI_CONF1_ADDRESS(bus, dev, fn, reg), 0xCF8);
+
+	switch (len) {
+	case 1:
+		outb((u8)value, 0xCFC + (reg & 3));
+		break;
+	case 2:
+		outw((u16)value, 0xCFC + (reg & 2));
+		break;
+	case 4:
+		outl((u32)value, 0xCFC);
+		break;
+	}
+
+	spin_unlock_irqrestore(&pci_config_lock, flags);
+
+	return 0;
+}
+
+#undef PCI_CONF1_ADDRESS
+
 #define CONFIG_CMD(dev, where)   (0x80000000 | (dev->bus->number << 16) | (dev->devfn << 8) | (where & ~3))
 
 static int pci_conf1_read_config_byte(struct pci_dev *dev, int where, u8 *value)
 {
-	outl(CONFIG_CMD(dev,where), 0xCF8);
-	*value = inb(0xCFC + (where&3));
-	return PCIBIOS_SUCCESSFUL;
+	int result;
+	u32 data;
+
+	if (!value)
+		return -EINVAL;
+
+	result = pci_conf1_read(0, dev->bus->number, PCI_SLOT(dev->devfn),
+		 		PCI_FUNC(dev->devfn), where, 1, &data);
+
+	*value = (u8)data;
+
+	return result;
 }
 
 static int pci_conf1_read_config_word(struct pci_dev *dev, int where, u16 *value)
 {
-	outl(CONFIG_CMD(dev,where), 0xCF8);    
-	*value = inw(0xCFC + (where&2));
-	return PCIBIOS_SUCCESSFUL;    
+	int result;
+	u32 data;
+
+	if (!value)
+		return -EINVAL;
+
+	result = pci_conf1_read(0, dev->bus->number, PCI_SLOT(dev->devfn),
+		 		PCI_FUNC(dev->devfn), where, 2, &data);
+
+	*value = (u16)data;
+
+	return result;
 }
 
 static int pci_conf1_read_config_dword(struct pci_dev *dev, int where, u32 *value)
 {
-	outl(CONFIG_CMD(dev,where), 0xCF8);
-	*value = inl(0xCFC);
-	return PCIBIOS_SUCCESSFUL;    
+	return pci_conf1_read(0, dev->bus->number, PCI_SLOT(dev->devfn),
+			      PCI_FUNC(dev->devfn), where, 4, value);
+
 }
 
 static int pci_conf1_write_config_byte(struct pci_dev *dev, int where, u8 value)
 {
-	outl(CONFIG_CMD(dev,where), 0xCF8);    
-	outb(value, 0xCFC + (where&3));
-	return PCIBIOS_SUCCESSFUL;
+	return pci_conf1_write(0, dev->bus->number, PCI_SLOT(dev->devfn),
+			       PCI_FUNC(dev->devfn), where, 1, value);
 }
 
 static int pci_conf1_write_config_word(struct pci_dev *dev, int where, u16 value)
 {
-	outl(CONFIG_CMD(dev,where), 0xCF8);
-	outw(value, 0xCFC + (where&2));
-	return PCIBIOS_SUCCESSFUL;
+	return pci_conf1_write(0, dev->bus->number, PCI_SLOT(dev->devfn),
+			       PCI_FUNC(dev->devfn), where, 2, value);
 }
 
 static int pci_conf1_write_config_dword(struct pci_dev *dev, int where, u32 value)
 {
-	outl(CONFIG_CMD(dev,where), 0xCF8);
-	outl(value, 0xCFC);
-	return PCIBIOS_SUCCESSFUL;
+	return pci_conf1_write(0, dev->bus->number, PCI_SLOT(dev->devfn),
+			       PCI_FUNC(dev->devfn), where, 4, value);
 }
 
 #undef CONFIG_CMD
@@ -100,6 +186,80 @@ static struct pci_ops pci_direct_conf1 =
  * Functions for accessing PCI configuration space with type 2 accesses
  */
 
+#define PCI_CONF2_ADDRESS(dev, reg)	(u16)(0xC000 | (dev << 8) | reg)
+
+/* These two functions are only used by ACPI code */
+
+static int pci_conf2_read (int seg, int bus, int dev, int fn, int reg, int len, u32 *value)
+{
+	unsigned long flags;
+
+	if (bus > 255 || dev > 31 || fn > 7 || reg > 255)
+		return -EINVAL;
+
+	if (dev & 0x10) 
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	spin_lock_irqsave(&pci_config_lock, flags);
+
+	outb((u8)(0xF0 | (fn << 1)), 0xCF8);
+	outb((u8)bus, 0xCFA);
+
+	switch (len) {
+	case 1:
+		*value = inb(PCI_CONF2_ADDRESS(dev, reg));
+		break;
+	case 2:
+		*value = inw(PCI_CONF2_ADDRESS(dev, reg));
+		break;
+	case 4:
+		*value = inl(PCI_CONF2_ADDRESS(dev, reg));
+		break;
+	}
+
+	outb (0, 0xCF8);
+
+	spin_unlock_irqrestore(&pci_config_lock, flags);
+
+	return 0;
+}
+
+static int pci_conf2_write (int seg, int bus, int dev, int fn, int reg, int len, u32 value)
+{
+	unsigned long flags;
+
+	if ((bus > 255 || dev > 31 || fn > 7 || reg > 255)) 
+		return -EINVAL;
+
+	if (dev & 0x10) 
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	spin_lock_irqsave(&pci_config_lock, flags);
+
+	outb((u8)(0xF0 | (fn << 1)), 0xCF8);
+	outb((u8)bus, 0xCFA);
+
+	switch (len) {
+	case 1:
+		outb ((u8)value, PCI_CONF2_ADDRESS(dev, reg));
+		break;
+	case 2:
+		outw ((u16)value, PCI_CONF2_ADDRESS(dev, reg));
+		break;
+	case 4:
+		outl ((u32)value, PCI_CONF2_ADDRESS(dev, reg));
+		break;
+	}
+
+	outb (0, 0xCF8);    
+
+	spin_unlock_irqrestore(&pci_config_lock, flags);
+
+	return 0;
+}
+
+#undef PCI_CONF2_ADDRESS
+
 #define IOADDR(devfn, where)	((0xC000 | ((devfn & 0x78) << 5)) + where)
 #define FUNC(devfn)		(((devfn & 7) << 1) | 0xf0)
 #define SET(dev)		if (dev->devfn & 0x80) return PCIBIOS_DEVICE_NOT_FOUND;		\
@@ -108,50 +268,58 @@ static struct pci_ops pci_direct_conf1 =
 
 static int pci_conf2_read_config_byte(struct pci_dev *dev, int where, u8 *value)
 {
-	SET(dev);
-	*value = inb(IOADDR(dev->devfn,where));
-	outb (0, 0xCF8);
-	return PCIBIOS_SUCCESSFUL;
+	int result;
+	u32 data;
+
+	if (!value)
+		return -EINVAL;
+
+	result = pci_conf2_read(0, dev->bus->number, PCI_SLOT(dev->devfn),
+				PCI_FUNC(dev->devfn), where, 1, &data);
+
+	*value = (u8)data;
+
+	return result;
 }
 
 static int pci_conf2_read_config_word(struct pci_dev *dev, int where, u16 *value)
 {
-	SET(dev);
-	*value = inw(IOADDR(dev->devfn,where));
-	outb (0, 0xCF8);
-	return PCIBIOS_SUCCESSFUL;
+	int result;
+	u32 data;
+
+	if (!value)
+		return -EINVAL;
+
+	result = pci_conf2_read(0, dev->bus->number, PCI_SLOT(dev->devfn),
+				PCI_FUNC(dev->devfn), where, 2, &data);
+
+	*value = (u16)data;
+
+	return result;
 }
 
 static int pci_conf2_read_config_dword(struct pci_dev *dev, int where, u32 *value)
 {
-	SET(dev);
-	*value = inl (IOADDR(dev->devfn,where));    
-	outb (0, 0xCF8);    
-	return PCIBIOS_SUCCESSFUL;
+	return pci_conf2_read(0, dev->bus->number, PCI_SLOT(dev->devfn),
+			      PCI_FUNC(dev->devfn), where, 4, value);
 }
 
 static int pci_conf2_write_config_byte(struct pci_dev *dev, int where, u8 value)
 {
-	SET(dev);
-	outb (value, IOADDR(dev->devfn,where));
-	outb (0, 0xCF8);    
-	return PCIBIOS_SUCCESSFUL;
+	return pci_conf2_write(0, dev->bus->number, PCI_SLOT(dev->devfn),
+			       PCI_FUNC(dev->devfn), where, 1, value);
 }
 
 static int pci_conf2_write_config_word(struct pci_dev *dev, int where, u16 value)
 {
-	SET(dev);
-	outw (value, IOADDR(dev->devfn,where));
-	outb (0, 0xCF8);    
-	return PCIBIOS_SUCCESSFUL;
+	return pci_conf2_write(0, dev->bus->number, PCI_SLOT(dev->devfn),
+			       PCI_FUNC(dev->devfn), where, 2, value);
 }
 
 static int pci_conf2_write_config_dword(struct pci_dev *dev, int where, u32 value)
 {
-	SET(dev);
-	outl (value, IOADDR(dev->devfn,where));    
-	outb (0, 0xCF8);    
-	return PCIBIOS_SUCCESSFUL;
+	return pci_conf2_write(0, dev->bus->number, PCI_SLOT(dev->devfn),
+			       PCI_FUNC(dev->devfn), where, 4, value);
 }
 
 #undef SET
@@ -180,21 +348,40 @@ static struct pci_ops pci_direct_conf2 =
 static int __devinit pci_sanity_check(struct pci_ops *o)
 {
 	u16 x;
-	struct pci_bus bus;		/* Fake bus and device */
-	struct pci_dev dev;
+	struct pci_bus *bus;		/* Fake bus and device */
+	struct pci_dev *dev;
+	int retval = 0;
 
 	if (pci_probe & PCI_NO_CHECKS)
 		return 1;
-	bus.number = 0;
-	dev.bus = &bus;
-	for(dev.devfn=0; dev.devfn < 0x100; dev.devfn++)
-		if ((!o->read_word(&dev, PCI_CLASS_DEVICE, &x) &&
+
+	bus = kmalloc(sizeof(*bus), GFP_ATOMIC);
+	if (!bus)
+		return 0;
+	dev = kmalloc(sizeof(*dev), GFP_ATOMIC);
+	if (!dev) {
+		kfree(bus);
+		return 0;
+	}
+
+	bus->number = 0;
+	dev->bus = bus;
+	for(dev->devfn=0; dev->devfn < 0x100; dev->devfn++)
+		if ((!o->read_word(dev, PCI_CLASS_DEVICE, &x) &&
 		     (x == PCI_CLASS_BRIDGE_HOST || x == PCI_CLASS_DISPLAY_VGA)) ||
-		    (!o->read_word(&dev, PCI_VENDOR_ID, &x) &&
-		     (x == PCI_VENDOR_ID_INTEL || x == PCI_VENDOR_ID_COMPAQ)))
-			return 1;
+		    (!o->read_word(dev, PCI_VENDOR_ID, &x) &&
+		     (x == PCI_VENDOR_ID_INTEL || x == PCI_VENDOR_ID_COMPAQ))) {
+			retval = 1;
+			goto out;
+	}
+
 	DBG("PCI: Sanity check failed\n");
-	return 0;
+	retval = 0;
+
+out:
+	kfree(bus);
+	kfree(dev);
+	return retval;
 }
 
 static struct pci_ops * __devinit pci_check_direct(void)
@@ -399,7 +586,7 @@ void __devinit pcibios_fixup_bus(struct 
 	pci_read_bridge_bases(b);
 }
 
-void __devinit pcibios_init(void)
+void __devinit pcibios_config_init(void)
 {
 	struct pci_ops *dir = NULL;
 
@@ -414,14 +601,83 @@ void __devinit pcibios_init(void)
 		return;
 	}
 
-	printk(KERN_INFO "PCI: Probing PCI hardware\n");
-	pci_root_bus = pci_scan_bus(0, pci_root_ops, NULL);
+	if(pci_root_ops == &pci_direct_conf1) {
+		pci_config_read = pci_conf1_read;
+		pci_config_write = pci_conf1_write;
+	}
+	else if(pci_root_ops == &pci_direct_conf2) {
+		pci_config_read = pci_conf2_read;
+		pci_config_write = pci_conf2_write;
+	}
+}
+
+#ifdef CONFIG_ACPI_PCI
+
+static struct pci_controller *
+alloc_pci_controller(int seg)
+{
+	struct pci_controller *controller;
+
+	controller = kmalloc(sizeof(*controller), GFP_KERNEL);
+	if (!controller)
+		return NULL;
+
+	memset(controller, 0, sizeof(*controller));
+	controller->segment = seg;
+	return controller;
+}
+
+struct pci_bus * 
+pcibios_scan_root(void *handle, int seg, int bus)
+{
+	struct pci_controller *controller;
+	u64 base, size, offset;
+	extern void acpi_get_addr_space(acpi_handle, u8, u64 *, u64 *, u64 *);
+
+	acpi_root_bridges++;
+
+	controller = alloc_pci_controller(seg);
+	if (!controller)
+		return NULL;
+
+	controller->acpi_handle = handle;
+
+	acpi_get_addr_space(handle, ACPI_MEMORY_RANGE, &base, &size, &offset);
+
+	return pci_scan_bus(bus, pci_root_ops, controller);
+
+}
+
+#endif /* CONFIG_ACPI_PCI */
+
+void __devinit pcibios_init(void)
+{
+	struct pci_controller *controller;
+
+	if (!pci_root_ops)
+		pcibios_config_init();
+
+	/* Only probe blindly if ACPI didn't tell us about root bridges */
+	if (acpi_root_bridges) {
+#ifdef CONFIG_ACPI_PCI
+		if (!acpi_pci_irq_init())
+			printk(KERN_INFO "PCI: Using ACPI for IRQ routing\n");
+		else
+			printk(KERN_WARNING "PCI: Invalid ACPI-PCI IRQ routing table\n");
+#else
+		printk(KERN_WARNING "PCI: acpi_root_bridges nonzero but ACPI not configured\n");
+#endif
+	}
+	else {
+		printk(KERN_INFO "PCI: Probing PCI hardware\n");
+		pci_root_bus = pci_scan_bus(0, pci_root_ops, NULL);
 	
-	pcibios_irq_init();
-	pci_scan_mptable(); 
-	pcibios_fixup_peer_bridges();
-	pcibios_fixup_irqs();
-	pcibios_resource_survey();
+		pcibios_irq_init();
+		pci_scan_mptable(); 
+		pcibios_fixup_peer_bridges();
+		pcibios_fixup_irqs();
+		pcibios_resource_survey();
+	}
 
 #ifdef CONFIG_GART_IOMMU
 	pci_iommu_init();
diff -urNp linux-201/arch/x86_64/kernel/setup.c linux-202/arch/x86_64/kernel/setup.c
--- linux-201/arch/x86_64/kernel/setup.c
+++ linux-202/arch/x86_64/kernel/setup.c
@@ -32,6 +32,7 @@
 #include <asm/processor.h>
 #include <linux/console.h>
 #include <linux/seq_file.h>
+#include <linux/acpi.h>
 #include <asm/mtrr.h>
 #include <asm/uaccess.h>
 #include <asm/system.h>
@@ -56,6 +57,16 @@ struct cpuinfo_x86 boot_cpu_data = { 
 
 unsigned long mmu_cr4_features;
 
+int acpi_disabled = 0;
+static int __init acpioff(char *str)
+{
+	acpi_disabled = 1;
+	return 1;
+}
+
+__setup("acpi=off", acpioff);
+
+
 /* For PCI or other memory-mapped resources */
 unsigned long pci_mem_start = 0x10000000;
 
@@ -271,6 +282,12 @@ void __init setup_arch(char **cmdline_p)
 	kernel_end = round_up(__pa_symbol(&_end), PAGE_SIZE);
 	reserve_bootmem_generic(HIGH_MEMORY, kernel_end - HIGH_MEMORY);
 
+#ifdef CONFIG_ACPI_SLEEP
+	/*
+	 * Reserve low memory region for sleep support.
+	 */
+	acpi_reserve_bootmem();
+#endif
 #ifdef CONFIG_X86_LOCAL_APIC
 	/*
 	 * Find and reserve possible boot-time SMP configuration:
@@ -284,6 +301,17 @@ void __init setup_arch(char **cmdline_p)
 #endif
 
 	paging_init();
+#ifdef CONFIG_ACPI_BOOT
+	/*
+	 * Initialize the ACPI boot-time table parser (gets the RSDP and SDT).
+	 * Must do this after paging_init (due to reliance on fixmap, and thus
+	 * the bootmem allocator) but before get_smp_config (to allow parsing
+	 * of MADT).
+	 */
+	if (!acpi_disabled)
+		acpi_boot_init(*cmdline_p);
+#endif
+
 #ifdef CONFIG_X86_LOCAL_APIC
 	/*
 	 * get boot-time SMP configuration:
diff -urNp linux-201/arch/x86_64/kernel/smpboot.c linux-202/arch/x86_64/kernel/smpboot.c
--- linux-201/arch/x86_64/kernel/smpboot.c
+++ linux-202/arch/x86_64/kernel/smpboot.c
@@ -892,7 +892,6 @@ void __init smp_boot_cpus(void)
 		io_apic_irqs = 0;
 		cpu_online_map = phys_cpu_present_map = 1;
 		smp_num_cpus = 1;
-		apic_disabled = 1;
 		goto smp_done;
 	}
 
@@ -907,7 +906,6 @@ void __init smp_boot_cpus(void)
 		io_apic_irqs = 0;
 		cpu_online_map = phys_cpu_present_map = 1;
 		smp_num_cpus = 1;
-		apic_disabled = 1;
 		goto smp_done;
 	}
 
diff -urNp linux-201/arch/x86_64/kernel/time.c linux-202/arch/x86_64/kernel/time.c
--- linux-201/arch/x86_64/kernel/time.c
+++ linux-202/arch/x86_64/kernel/time.c
@@ -40,6 +40,55 @@ unsigned long __wall_jiffies __section_w
 struct timeval __xtime __section_xtime;
 struct timezone __sys_tz __section_sys_tz;
 
+#ifdef CONFIG_ACPI_PMTMR
+
+unsigned int	acpi_pmtmr_port = 0;
+unsigned char	acpi_pmtmr_len = 0;
+int		use_pmtmr = 0;
+
+#define ACPI_PM_MASK 0xffffff	/* 24 bits */
+
+/* Number of PMTMR ticks expected during calibration run */
+#define PMTMR_TICKS_PER_SEC 3579545
+#define PMTMR_TICK (PMTMR_TICKS_PER_SEC/HZ)
+#define PMTMR_EXPECTED_RATE \
+  (((5*LATCH) * (PMTMR_TICKS_PER_SEC >> 10)) / (CLOCK_TICK_RATE>>10))
+
+
+static inline u32 read_pmtmr(void)
+{
+	u32 v1=0,v2=0,v3=0;
+        /* It has been reported that because of various broken
+	 * chipsets (ICH4, PIIX4 and PIIX4E) where the ACPI PM time
+	 * source is not latched, so you must read it multiple
+	 * times to insure a safe value is read.
+	 */
+	do {
+		v1 = inl(acpi_pmtmr_port);
+		v2 = inl(acpi_pmtmr_port);
+		v3 = inl(acpi_pmtmr_port);
+	} while ((v1 > v2 && v1 < v3) || (v2 > v3 && v2 < v1)
+			|| (v3 > v1 && v3 < v2));
+
+	/* mask the output to 24 bits */
+	return v2 & ACPI_PM_MASK;
+}
+
+/* The Power Management Timer ticks at 3.579545 ticks per microsecond.
+ * 1 / PM_TIMER_FREQUENCY == 0.27936511 =~ 286/1024 [error: 0.024%]
+ *
+ * Even with HZ = 100, delta is at maximum 35796 ticks, so it can
+ * easily be multiplied with 286 (=0x11E) without having to fear
+ * u32 overflows.
+ */
+static inline u32 pm_cyc2us(u32 cycles)
+{
+	cycles *= 286;
+	return (cycles >> 10);
+}
+
+#endif
+
 static inline void rdtscll_sync(unsigned long *tsc)
 {
 	sync_core();
@@ -63,6 +112,12 @@ static unsigned int do_gettimeoffset_hpe
 	return ((hpet_readl(HPET_COUNTER) - vxtime.last) * vxtime.quot) >> 32;
 }
 
+#ifdef CONFIG_ACPI_PMTMR
+static unsigned int do_gettimeoffset_pmtmr(void)
+{
+	return pm_cyc2us((read_pmtmr() - vxtime.last_pmtmr) & ACPI_PM_MASK);
+}
+#endif
 static unsigned int do_gettimeoffset_nop(void)
 {
 	return 0;
@@ -242,6 +297,28 @@ static void timer_interrupt(int irq, voi
 
 			vxtime.last = offset;
 
+#ifdef CONFIG_ACPI_PMTMR
+		} else if (vxtime.mode == VXTIME_PMTMR) {
+
+			u32 pmtmr;
+
+			pmtmr = read_pmtmr();
+			offset = ((pmtmr - vxtime.last_pmtmr) & ACPI_PM_MASK) - PMTMR_TICK;
+			if (offset > PMTMR_TICK) {
+				if (report_lost_ticks)
+					printk(KERN_WARNING "time.c: lost %ld tick(s) (rip %016lx)\n",
+						 offset / PMTMR_TICK, regs->rip);
+				jiffies += offset / PMTMR_TICK;
+				offset %= PMTMR_TICK;
+			}
+
+			if (offset < PMTMR_TICK)
+				vxtime.last_pmtmr = (pmtmr - offset) & ACPI_PM_MASK;
+			else
+				vxtime.last_pmtmr = pmtmr;
+
+			vxtime.last_tsc = tsc - vxtime.quot * delay / vxtime.tsc_quot; 
+#endif
 		} else {
 
 			offset = (((tsc - vxtime.last_tsc) * vxtime.tsc_quot) >> 32) - tick;
@@ -406,6 +483,74 @@ static unsigned int __init pit_calibrate
 	return (end - start) / 50;
 }
 
+#ifdef CONFIG_ACPI_PMTMR
+/*
+ * Some boards have the PMTMR running way too fast.  We check
+ * the PMTMR rate against PIT channel 2 to catch these cases.
+ */
+static int verify_pmtmr_rate(void)
+{
+	u32 value1, value2;
+	unsigned long count = 0, delta;
+
+	/* prepare the counter */
+	outb((inb(0x61) & ~0x02) | 0x01, 0x61);
+
+	/* take care of CTC channel 2 */
+	outb(0xb0, 0x43);	/* binary, mode 0, LSB/MSB, ch 2 */
+	outb_p((5*LATCH) & 0xff, 0x42);	/* LSB of count */
+	outb_p((5*LATCH) >> 8, 0x42);	/* MSB of count */
+
+	value1 = read_pmtmr();
+
+	do {
+		count++;
+	} while ((inb_p(0x61) & 0x20) == 0);
+
+	value2 = read_pmtmr();
+	delta = (value2 - value1) & ACPI_PM_MASK;
+
+	/* Check that the PMTMR delta is within 5% of what we expect */
+	if (delta < (PMTMR_EXPECTED_RATE * 19) / 20 ||
+	    delta > (PMTMR_EXPECTED_RATE * 21) / 20) {
+		printk(KERN_INFO "PM-Timer running at invalid rate: %lu%% of normal - aborting.\n", 100UL * delta / PMTMR_EXPECTED_RATE);
+		return -1;
+	}
+	return 0;
+}
+
+static int pmtmr_init(void)
+{
+	u32 value1, value2;
+	int i;
+
+	/* make sure it's here and it's working */
+	if (!acpi_pmtmr_port)
+		return -ENODEV;
+
+	value1 = read_pmtmr();
+	for (i = 0; i < 10000; i++) {
+		value2 = read_pmtmr();
+		if (value2 == value1)
+			continue;
+		if (value2 > value1)
+			goto pm_good;
+		if ((value2 < value1) && (value2 < 0xfff))
+			goto pm_good;
+		printk(KERN_INFO "PM-Timer had inconsistent results: 0x%#x, 0x%#x- aborting.\n", value1, value2);
+		return -EINVAL;
+	}
+	printk(KERN_INFO "PM-Timer had no reasonable result: 0x%#x - aborting\n", value1);
+	return -ENODEV;
+
+pm_good:
+	if (verify_pmtmr_rate() != 0)
+		return -ENODEV;
+
+	return 0;
+}
+#endif
+
 static int hpet_init(void)
 {
 	unsigned int cfg, id;
@@ -474,26 +619,27 @@ static int __init time_setup(char *str)
 }
 
 /* Only used on SMP */
+#ifdef CONFIG_SMP
+static int notsc __initdata = 1; 
+#else
 static int notsc __initdata = 0; 
+#endif
 
-static int __init notsc_setup(char *str)
+static int __init tsc_setup(char *str)
 { 
-#ifdef CONFIG_SMP
-	printk(KERN_INFO "notsc ignored on non SMP kernel\n"); 
+#ifndef CONFIG_SMP
+	printk(KERN_INFO "tsc redundant on non-SMP kernel\n");
 #endif
-	notsc = 1;
+	notsc = 0;
 	return 1;
 } 
 
 static struct irqaction irq0 = { timer_interrupt, SA_INTERRUPT, 0, "timer", NULL, NULL};
 
-extern void __init config_acpi_tables(void);
-
 void __init time_init(void)
 {
 	char *timename;
-
-	config_acpi_tables();
+	unsigned long timer_hz;
 
 #ifdef HPET_HACK_ENABLE_DANGEROUS
         if (!hpet_address) {
@@ -516,10 +662,19 @@ void __init time_init(void)
 	write_unlock(&xtime_lock);
 
 	if (!hpet_init()) {
-                vxtime_hz = (1000000000000000L + hpet_period / 2) / hpet_period;
+                timer_hz = vxtime_hz = (1000000000000000L + hpet_period / 2) / hpet_period;
                 cpu_khz = hpet_calibrate_tsc();
 		timename = "HPET";
+#ifdef CONFIG_ACPI_PMTMR
+	} else if (acpi_pmtmr_port && !pmtmr_init()) {
+		timer_hz = PMTMR_TICKS_PER_SEC;
+		vxtime.last_pmtmr = read_pmtmr();
+		pit_init();
+		cpu_khz = pit_calibrate_tsc();
+		timename = "PMTMR";
+#endif
 	} else {
+		timer_hz = vxtime_hz;
 		pit_init();
 		cpu_khz = pit_calibrate_tsc();
 		timename = "PIT";
@@ -533,7 +688,7 @@ void __init time_init(void)
 	setup_irq(0, &irq0);
 
         printk(KERN_INFO "time.c: Detected %ld.%06ld MHz %s timer.\n",
-		vxtime_hz / 1000000, vxtime_hz % 1000000, timename);
+		timer_hz / 1000000, timer_hz % 1000000, timename);
 	printk(KERN_INFO "time.c: Detected %d.%03d MHz TSC timer.\n",
 			cpu_khz / 1000, cpu_khz % 1000);
 }
@@ -553,6 +708,13 @@ void __init time_init_smp(void)
 			vxtime.mode = VXTIME_TSC;
 			do_gettimeoffset = do_gettimeoffset_tsc;
 		}		
+#ifdef CONFIG_ACPI_PMTMR
+	} else if (acpi_pmtmr_port) {
+		timetype = "PMTMR";
+		vxtime.last_pmtmr = read_pmtmr();
+		vxtime.mode = VXTIME_PMTMR;
+		do_gettimeoffset = do_gettimeoffset_pmtmr;
+#endif
 	} else {
 		if (notsc) {
 			timetype = "PIT";
@@ -566,6 +728,6 @@ void __init time_init_smp(void)
 	printk(KERN_INFO "time.c: Using %s based timekeeping.\n", timetype);
 }
 
-__setup("notsc", notsc_setup);
+__setup("tsc", tsc_setup);
 __setup("report_lost_ticks", time_setup);
 
diff -urNp linux-201/arch/x86_64/kernel/vsyscall.c linux-202/arch/x86_64/kernel/vsyscall.c
--- linux-201/arch/x86_64/kernel/vsyscall.c
+++ linux-202/arch/x86_64/kernel/vsyscall.c
@@ -68,6 +68,7 @@ static force_inline void do_vgettimeofda
 		switch (__vxtime.mode) {
 
 			case VXTIME_TSC:
+			case VXTIME_PMTMR:
 				sync_core();
 				rdtscll(t);
 				usec += (((t  - __vxtime.last_tsc) * __vxtime.tsc_quot) >> 32);
diff -urNp linux-201/drivers/pci/pci.c linux-202/drivers/pci/pci.c
--- linux-201/drivers/pci/pci.c
+++ linux-202/drivers/pci/pci.c
@@ -1560,20 +1560,26 @@ unsigned int __devinit pci_do_scan_bus(s
 {
 	unsigned int devfn, max, pass;
 	struct list_head *ln;
-	struct pci_dev *dev, dev0;
+	struct pci_dev *dev, *dev0;
+
+	dev0 = kmalloc(sizeof(*dev0), GFP_ATOMIC);
+	if (!dev0) {
+		return 0;
+	}
+
 
 	DBG("Scanning bus %02x\n", bus->number);
 	max = bus->secondary;
 
 	/* Create a device template */
-	memset(&dev0, 0, sizeof(dev0));
-	dev0.bus = bus;
-	dev0.sysdata = bus->sysdata;
+	memset(dev0, 0, sizeof(*dev0));
+	dev0->bus = bus;
+	dev0->sysdata = bus->sysdata;
 
 	/* Go find them, Rover! */
 	for (devfn = 0; devfn < 0x100; devfn += 8) {
-		dev0.devfn = devfn;
-		pci_scan_slot(&dev0);
+		dev0->devfn = devfn;
+		pci_scan_slot(dev0);
 	}
 
 	/*
@@ -1597,6 +1603,7 @@ unsigned int __devinit pci_do_scan_bus(s
 	 * Return how far we've got finding sub-buses.
 	 */
 	DBG("Bus scan for %02x returning with max=%02x\n", bus->number, max);
+	kfree(dev0);
 	return max;
 }
 
diff -urNp linux-201/include/asm-x86_64/acpi.h linux-202/include/asm-x86_64/acpi.h
--- linux-201/include/asm-x86_64/acpi.h
+++ linux-202/include/asm-x86_64/acpi.h
@@ -0,0 +1,149 @@
+/*
+ *  asm-x86_64/acpi.h
+ *
+ *  Copyright (C) 2001 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *  Copyright (C) 2001 Patrick Mochel <mochel@osdl.org>
+  *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#ifndef _ASM_ACPI_H
+#define _ASM_ACPI_H
+
+#ifdef __KERNEL__
+
+#define COMPILER_DEPENDENT_INT64   long long
+#define COMPILER_DEPENDENT_UINT64  unsigned long long
+
+/*
+ * Calling conventions:
+ *
+ * ACPI_SYSTEM_XFACE        - Interfaces to host OS (handlers, threads)
+ * ACPI_EXTERNAL_XFACE      - External ACPI interfaces 
+ * ACPI_INTERNAL_XFACE      - Internal ACPI interfaces
+ * ACPI_INTERNAL_VAR_XFACE  - Internal variable-parameter list interfaces
+ */
+#define ACPI_SYSTEM_XFACE
+#define ACPI_EXTERNAL_XFACE
+#define ACPI_INTERNAL_XFACE
+#define ACPI_INTERNAL_VAR_XFACE
+
+/* Asm macros */
+
+#define ACPI_ASM_MACROS
+#define BREAKPOINT3
+#define ACPI_DISABLE_IRQS() local_irq_disable()
+#define ACPI_ENABLE_IRQS()  local_irq_enable()
+#define ACPI_FLUSH_CPU_CACHE()	wbinvd()
+
+/*
+ * A brief explanation as GNU inline assembly is a bit hairy
+ *  %0 is the output parameter in RAX ("=a")
+ *  %1 and %2 are the input parameters in RCX ("c")
+ *  and an immediate value ("i") respectively
+ *  All actual register references are preceded with "%%" as in "%%edx"
+ *  Immediate values in the assembly are preceded by "$" as in "$0x1"
+ *  The final asm parameter are the operation altered non-output registers.
+ */
+#define ACPI_ACQUIRE_GLOBAL_LOCK(GLptr, Acq) \
+	do { \
+		unsigned long dummy; \
+		asm("1:     movl (%2),%%eax;" \
+			"movl   %%eax,%%edx;" \
+			"andq   %2,%%rdx;" \
+			"btsl   $0x1,%%edx;" \
+			"adcl   $0x0,%%edx;" \
+			"lock;  cmpxchgl %%edx,(%1);" \
+			"jnz    1b;" \
+			"cmpb   $0x3,%%dl;" \
+			"sbbl   %%eax,%%eax" \
+			:"=a"(Acq),"=c"(dummy):"c"(GLptr),"i"(~1L):"dx"); \
+	} while(0)
+#define ACPI_RELEASE_GLOBAL_LOCK(GLptr, Acq) \
+	do { \
+		unsigned long dummy; \
+		asm("1:     movl (%2),%%eax;" \
+			"movl   %%eax,%%edx;" \
+			"andq   %2,%%rdx;" \
+			"lock;  cmpxchgl %%edx,(%1);" \
+			"jnz    1b;" \
+			"andl   $0x1,%%eax" \
+			:"=a"(Acq),"=c"(dummy):"c"(GLptr),"i"(~3L):"dx"); \
+	} while(0)
+
+/*
+ * Math helper asm macros
+ */
+#define ACPI_DIV_64_BY_32(n_hi, n_lo, d32, q32, r32) \
+        asm("divl %2;"        \
+        :"=a"(q32), "=d"(r32) \
+        :"r"(d32),            \
+        "0"(n_lo), "1"(n_hi))
+
+
+#define ACPI_SHIFT_RIGHT_64(n_hi, n_lo) \
+    asm("shrl   $1,%2;"             \
+        "rcrl   $1,%3;"             \
+        :"=r"(n_hi), "=r"(n_lo)     \
+        :"0"(n_hi), "1"(n_lo))
+
+
+#ifndef CONFIG_ACPI_BOOT
+#define acpi_lapic 0
+#define acpi_ioapic 0
+#else
+#ifdef CONFIG_X86_LOCAL_APIC
+extern int acpi_lapic;
+#else
+#define acpi_lapic 0
+#endif
+#ifdef CONFIG_X86_IO_APIC
+extern int acpi_ioapic;
+#else
+#define acpi_ioapic 0
+#endif
+
+/* Fixmap pages to reserve for ACPI boot-time tables (see fixmap.h) */
+#define FIX_ACPI_PAGES 4
+
+#endif /*CONFIG_ACPI_BOOT*/
+
+#ifdef CONFIG_ACPI_SLEEP
+
+/* routines for saving/restoring kernel state */
+extern int acpi_save_state_mem(void);
+extern int acpi_save_state_disk(void);
+extern void acpi_restore_state_mem(void);
+
+extern unsigned long acpi_wakeup_address;
+
+/* early initialization routine */
+extern void acpi_reserve_bootmem(void);
+
+#endif /*CONFIG_ACPI_SLEEP*/
+
+#define boot_cpu_physical_apicid boot_cpu_id
+
+#define dmi_broken (0)
+#define BROKEN_ACPI_Sx		0x0001
+#define BROKEN_INIT_AFTER_S1	0x0002
+
+#endif /*__KERNEL__*/
+
+#endif /*_ASM_ACPI_H*/
diff -urNp linux-201/include/asm-x86_64/apicdef.h linux-202/include/asm-x86_64/apicdef.h
--- linux-201/include/asm-x86_64/apicdef.h
+++ linux-202/include/asm-x86_64/apicdef.h
@@ -107,7 +107,7 @@
 
 #define APIC_BASE (fix_to_virt(FIX_APIC_BASE))
 
-#define MAX_IO_APICS 8
+#define MAX_IO_APICS 32
 
 /*
  * the local APIC register structure, memory mapped. Not terribly well
diff -urNp linux-201/include/asm-x86_64/mpspec.h linux-202/include/asm-x86_64/mpspec.h
--- linux-201/include/asm-x86_64/mpspec.h
+++ linux-202/include/asm-x86_64/mpspec.h
@@ -185,6 +185,19 @@ extern int mp_bus_id_to_pci_bus [MAX_MP_
 extern int mp_current_pci_id;
 extern unsigned long mp_lapic_addr;
 extern int pic_mode;
+
+#ifdef CONFIG_ACPI_BOOT
+extern void mp_register_lapic (u8 id, u8 enabled);
+extern void mp_register_lapic_address (u64 address);
+                                                                                
+#ifdef CONFIG_X86_IO_APIC
+extern void mp_register_ioapic (u8 id, u32 address, u32 irq_base);
+extern void mp_override_legacy_irq (u8 bus_irq, u8 polarity, u8 trigger, u32 global_irq);
+extern void mp_config_acpi_legacy_irqs (void);
+extern void mp_parse_prt (void);
+#endif /*CONFIG_X86_IO_APIC*/
+#endif
+                                                                                
 extern int using_apic_timer;
 
 #endif
diff -urNp linux-201/include/asm-x86_64/pci.h linux-202/include/asm-x86_64/pci.h
--- linux-201/include/asm-x86_64/pci.h
+++ linux-202/include/asm-x86_64/pci.h
@@ -25,6 +25,11 @@ extern unsigned long pci_mem_start;
 #define PCIBIOS_MIN_IO		0x1000
 #define PCIBIOS_MIN_MEM		(pci_mem_start)
 
+void pcibios_config_init(void);
+struct pci_bus *pcibios_scan_root(void *acpi_handle, int segment, int bus);
+extern int (*pci_config_read)(int seg, int bus, int dev, int fn, int reg, int len, u32 *value);
+extern int (*pci_config_write)(int seg, int bus, int dev, int fn, int reg, int len, u32 value);
+
 void pcibios_set_master(struct pci_dev *dev);
 void pcibios_penalize_isa_irq(int irq);
 struct irq_routing_table *pcibios_get_irq_routing_table(void);
@@ -283,6 +288,25 @@ static inline int pci_controller_num(str
 extern int pci_mmap_page_range(struct pci_dev *dev, struct vm_area_struct *vma,
 			       enum pci_mmap_state mmap_state, int write_combine);
 
+struct pci_window {
+	struct resource resource;
+	u64 offset;
+};
+
+struct pci_controller {
+	void *acpi_handle;
+	void *iommu;
+	int segment;
+
+	unsigned int windows;
+	struct pci_window *window;
+
+	void *platform_data;
+};
+
+#define PCI_CONTROLLER(dev) ((struct pci_controller *)dev->sysdata)
+#define PCI_SEGMENT(dev)    (PCI_CONTROLLER(dev)->segment)
+
 #endif /* __KERNEL__ */
 
 #endif /* __x8664_PCI_H */
diff -urNp linux-201/include/asm-x86_64/smp.h linux-202/include/asm-x86_64/smp.h
--- linux-201/include/asm-x86_64/smp.h
+++ linux-202/include/asm-x86_64/smp.h
@@ -95,10 +95,8 @@ extern __inline int hard_smp_processor_i
 	return GET_APIC_ID(*(unsigned *)(APIC_BASE+APIC_ID));
 }
 
-extern int apic_disabled;
 extern int slow_smp_processor_id(void);
-#define safe_smp_processor_id() \
-	(!apic_disabled ? hard_smp_processor_id() : slow_smp_processor_id())
+#define safe_smp_processor_id() x86_apicid_to_cpu(hard_smp_processor_id())
 
 #endif /* !ASSEMBLY */
 
diff -urNp linux-201/include/asm-x86_64/vsyscall.h linux-202/include/asm-x86_64/vsyscall.h
--- linux-201/include/asm-x86_64/vsyscall.h
+++ linux-202/include/asm-x86_64/vsyscall.h
@@ -28,11 +28,13 @@ struct vxtime_data {
 	long quot;
 	int last;
 	int mode;
+	long last_pmtmr;
 };
 
 #define VXTIME_STUPID	0
 #define VXTIME_TSC	1
-#define	VXTIME_HPET	2
+#define VXTIME_HPET	2
+#define VXTIME_PMTMR	3
 
 #define hpet_readl(a)           readl(fix_to_virt(FIX_HPET_BASE) + a)
 #define hpet_writel(d,a)        writel(d, fix_to_virt(FIX_HPET_BASE) + a)
