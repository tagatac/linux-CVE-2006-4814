diff -urNp linux-5122/drivers/md/lvm.c linux-5123/drivers/md/lvm.c
--- linux-5122/drivers/md/lvm.c	
+++ linux-5123/drivers/md/lvm.c	
@@ -230,7 +230,7 @@
 #define LOCAL_END_REQUEST
 
 /* lvm_do_lv_create calls fsync_dev_lockfs()/unlockfs() */
-/* #define	LVM_VFS_ENHANCEMENT */
+#define	LVM_VFS_ENHANCEMENT
 
 #include <linux/config.h>
 #include <linux/module.h>
diff -urNp linux-5122/fs/buffer.c linux-5123/fs/buffer.c
--- linux-5122/fs/buffer.c	
+++ linux-5123/fs/buffer.c	
@@ -415,6 +415,34 @@ void sync_dev(kdev_t dev)
 	fsync_dev(dev);
 }
 
+int fsync_dev_lockfs(kdev_t dev)
+{
+	/* you are not allowed to try locking all the filesystems
+	** on the system, your chances of getting through without
+	** total deadlock are slim to none.
+	*/
+	if (!dev)
+		return fsync_dev(dev) ;
+
+	sync_buffers(dev, 0);
+
+	lock_kernel();
+	/* note, the FS might need to start transactions to 
+	** sync the inodes, or the quota, no locking until
+	** after these are done
+	*/
+	sync_inodes(dev);
+	DQUOT_SYNC_DEV(dev);
+	/* if inodes or quotas could be dirtied during the
+	** sync_supers_lockfs call, the FS is responsible for getting
+	** them on disk, without deadlocking against the lock
+	*/
+	sync_supers_lockfs(dev) ;
+	unlock_kernel();
+
+	return sync_buffers(dev, 1) ;
+}
+
 asmlinkage long sys_sync(void)
 {
 	fsync_dev(0);
diff -urNp linux-5122/fs/ext3/super.c linux-5123/fs/ext3/super.c
--- linux-5122/fs/ext3/super.c	
+++ linux-5123/fs/ext3/super.c	
@@ -1618,6 +1618,12 @@ void ext3_write_super_lockfs(struct supe
 		unlock_super(sb);
 		journal_lock_updates(journal);
 		journal_flush(journal);
+		/* Everything under journal control should now be
+		 * barriered and flushed to disk, but data queued for
+		 * normal writeback (data=writeback mode, or certain
+		 * types of deleted data) may still need to be flushed
+		 * manually. */
+		fsync_no_super(sb->s_dev);
 		lock_super(sb);
 
 		/* Journal blocked and flushed, clear needs_recovery flag. */
diff -urNp linux-5122/fs/reiserfs/super.c linux-5123/fs/reiserfs/super.c
--- linux-5122/fs/reiserfs/super.c	
+++ linux-5123/fs/reiserfs/super.c	
@@ -45,7 +45,7 @@ static void reiserfs_write_super_lockfs 
     reiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);
     journal_mark_dirty(&th, s, SB_BUFFER_WITH_SB (s));
     reiserfs_block_writes(&th) ;
-    journal_end(&th, s, 1) ;
+    journal_end_sync(&th, s, 1) ;
   }
   s->s_dirt = dirty;
   unlock_kernel() ;
diff -urNp linux-5122/fs/super.c linux-5123/fs/super.c
--- linux-5122/fs/super.c	
+++ linux-5123/fs/super.c	
@@ -38,6 +38,13 @@
 LIST_HEAD(super_blocks);
 spinlock_t sb_lock = SPIN_LOCK_UNLOCKED;
 
+/* 
+ * lock/unlockfs grab a read lock on s_umount, but you need this lock to 
+ * make sure no lockfs runs are in progress before inserting/removing 
+ * supers from the list.  
+ */
+static DECLARE_MUTEX(lockfs_sem);
+
 /*
  * Handling of filesystem drivers list.
  * Rules:
@@ -451,6 +458,19 @@ void drop_super(struct super_block *sb)
 	put_super(sb);
 }
 
+static void write_super_lockfs(struct super_block *sb)
+{
+	lock_super(sb);
+	if (sb->s_root && sb->s_op) {
+		if (sb->s_dirt && sb->s_op->write_super)
+			sb->s_op->write_super(sb);
+		if (sb->s_op->write_super_lockfs) {
+			sb->s_op->write_super_lockfs(sb);
+		}
+	}
+	unlock_super(sb);
+}
+
 static inline void write_super(struct super_block *sb)
 {
 	lock_super(sb);
@@ -498,6 +518,39 @@ restart:
 	spin_unlock(&sb_lock);
 }
 
+/*
+ * Note: don't check the dirty flag before waiting, we want the lock
+ * to happen every time this is called.  dev must be non-zero
+ */
+void sync_supers_lockfs(kdev_t dev)
+{
+	struct super_block * sb;
+
+	down(&lockfs_sem);
+	if (dev) {
+		sb = get_super(dev);
+		if (sb) {
+			write_super_lockfs(sb);
+			drop_super(sb);
+		}
+	}
+}
+
+void unlockfs(kdev_t dev)
+{
+	struct super_block * sb;
+
+	if (dev) {
+		sb = get_super(dev);
+		if (sb) {
+			if (sb->s_op && sb->s_op->unlockfs)
+				sb->s_op->unlockfs(sb) ;
+			drop_super(sb);
+		}
+	}
+	up(&lockfs_sem);
+}
+
 /**
  *	get_super	-	get the superblock of a device
  *	@dev: device to get the superblock for
@@ -741,6 +794,7 @@ static struct super_block *get_sb_bdev(s
 		goto out1;
 
 	error = -EBUSY;
+	down(&lockfs_sem);
 restart:
 	spin_lock(&sb_lock);
 
@@ -751,11 +805,13 @@ restart:
 		if (old->s_type != fs_type ||
 		    ((flags ^ old->s_flags) & MS_RDONLY)) {
 			spin_unlock(&sb_lock);
+			up(&lockfs_sem);
 			destroy_super(s);
 			goto out1;
 		}
 		if (!grab_super(old))
 			goto restart;
+		up(&lockfs_sem);
 		destroy_super(s);
 		blkdev_put(bdev, BDEV_FS);
 		path_release(&nd);
@@ -765,6 +821,7 @@ restart:
 	s->s_bdev = bdev;
 	s->s_flags = flags;
 	insert_super(s, fs_type);
+	up(&lockfs_sem);
 	if (!fs_type->read_super(s, data, flags & MS_VERBOSE ? 1 : 0))
 		goto Einval;
 	s->s_flags |= MS_ACTIVE;
@@ -872,7 +929,10 @@ void kill_super(struct super_block *sb)
 	if (!deactivate_super(sb))
 		return;
 
+	down(&lockfs_sem); 
 	down_write(&sb->s_umount);
+	up(&lockfs_sem);
+
 	sb->s_root = NULL;
 	/* Need to clean after the sucker */
 	if (fs->fs_flags & FS_LITTER)
diff -urNp linux-5122/include/linux/fs.h linux-5123/include/linux/fs.h
--- linux-5122/include/linux/fs.h	
+++ linux-5123/include/linux/fs.h	
@@ -1299,6 +1299,7 @@ extern void write_inode_now(struct inode
 extern int sync_buffers(kdev_t, int);
 extern void sync_dev(kdev_t);
 extern int fsync_dev(kdev_t);
+extern int fsync_dev_lockfs(kdev_t);
 extern int fsync_super(struct super_block *);
 extern int fsync_no_super(kdev_t);
 extern void sync_inodes_sb(struct super_block *);
@@ -1316,6 +1317,8 @@ extern int do_fdatasync(struct file *);
 extern int filemap_fdatasync(struct address_space *);
 extern int filemap_fdatawait(struct address_space *);
 extern void sync_supers(kdev_t dev, int wait);
+extern void sync_supers_lockfs(kdev_t);
+extern void unlockfs(kdev_t);
 extern int bmap(struct inode *, int);
 extern int notify_change(struct dentry *, struct iattr *);
 extern int permission(struct inode *, int);
diff -urNp linux-5122/kernel/ksyms.c linux-5123/kernel/ksyms.c
--- linux-5122/kernel/ksyms.c	
+++ linux-5123/kernel/ksyms.c	
@@ -219,6 +219,8 @@ EXPORT_SYMBOL(invalidate_device);
 EXPORT_SYMBOL(invalidate_inode_pages);
 EXPORT_SYMBOL(truncate_inode_pages);
 EXPORT_SYMBOL(fsync_dev);
+EXPORT_SYMBOL_GPL(fsync_dev_lockfs);
+EXPORT_SYMBOL_GPL(unlockfs);
 EXPORT_SYMBOL(fsync_no_super);
 EXPORT_SYMBOL(permission);
 EXPORT_SYMBOL(vfs_permission);
