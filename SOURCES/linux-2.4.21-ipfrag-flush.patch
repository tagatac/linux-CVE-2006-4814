diff -urNp linux-2090/include/linux/netfilter_ipv4/ip_conntrack.h linux-2100/include/linux/netfilter_ipv4/ip_conntrack.h
--- linux-2090/include/linux/netfilter_ipv4/ip_conntrack.h
+++ linux-2100/include/linux/netfilter_ipv4/ip_conntrack.h
@@ -252,7 +252,7 @@ extern void (*ip_conntrack_destroyed)(st
 
 /* Returns new sk_buff, or NULL */
 struct sk_buff *
-ip_ct_gather_frags(struct sk_buff *skb);
+ip_ct_gather_frags(struct sk_buff *skb, u_int32_t user);
 
 /* Delete all conntracks which match. */
 extern void
diff -urNp linux-2090/include/net/ip.h linux-2100/include/net/ip.h
--- linux-2090/include/net/ip.h
+++ linux-2100/include/net/ip.h
@@ -222,8 +222,24 @@ extern int	ip_call_ra_chain(struct sk_bu
 /*
  *	Functions provided by ip_fragment.o
  */
- 
-struct sk_buff *ip_defrag(struct sk_buff *skb);
+
+enum ip_defrag_users
+{
+	IP_DEFRAG_LOCAL_DELIVER,
+	IP_DEFRAG_CALL_RA_CHAIN,
+	IP_DEFRAG_CONNTRACK_IN,
+	IP_DEFRAG_CONNTRACK_OUT,
+	IP_DEFRAG_NAT_OUT,
+	IP_DEFRAG_VS_OUT,
+	IP_DEFRAG_VS_FWD,
+	IP_DEFRAG_FW_COMPAT,
+	__IP_DEFRAG_DYNAMIC_FIRST,
+	__IP_DEFRAG_DYNAMIC_LAST = (__IP_DEFRAG_DYNAMIC_FIRST + 32) - 1,
+};
+
+struct sk_buff *ip_defrag(struct sk_buff *skb, u32 user);
+extern int ip_defrag_user_id_alloc(void);
+extern void ip_defrag_user_id_free(int user);
 extern int ip_frag_nqueues;
 extern atomic_t ip_frag_mem;
 
diff -urNp linux-2090/net/ipv4/ip_fragment.c linux-2100/net/ipv4/ip_fragment.c
--- linux-2090/net/ipv4/ip_fragment.c
+++ linux-2100/net/ipv4/ip_fragment.c
@@ -72,6 +72,7 @@ struct ipfrag_skb_cb
 struct ipq {
 	struct ipq	*next;		/* linked list pointers			*/
 	struct list_head lru_list;	/* lru list member 			*/
+	u32		user;
 	u32		saddr;
 	u32		daddr;
 	u16		id;
@@ -240,7 +241,7 @@ static __inline__ void ipq_kill(struct i
 }
 
 /* Memory limiting on fragments.  Evictor trashes the oldest 
- * fragment queue until we are back under the low threshold.
+ * fragment queue until we are back under the threshold.
  */
 static void ip_evictor(void)
 {
@@ -319,7 +320,8 @@ static struct ipq *ip_frag_intern(unsign
 		if(qp->id == qp_in->id		&&
 		   qp->saddr == qp_in->saddr	&&
 		   qp->daddr == qp_in->daddr	&&
-		   qp->protocol == qp_in->protocol) {
+		   qp->protocol == qp_in->protocol &&
+		   qp->user == qp_in->user) {
 			atomic_inc(&qp->refcnt);
 			write_unlock(&ipfrag_lock);
 			qp_in->last_in |= COMPLETE;
@@ -346,7 +348,7 @@ static struct ipq *ip_frag_intern(unsign
 }
 
 /* Add an entry to the 'ipq' queue for a newly received IP datagram. */
-static struct ipq *ip_frag_create(unsigned hash, struct iphdr *iph)
+static struct ipq *ip_frag_create(unsigned hash, struct iphdr *iph, u32 user)
 {
 	struct ipq *qp;
 
@@ -358,6 +360,7 @@ static struct ipq *ip_frag_create(unsign
 	qp->id = iph->id;
 	qp->saddr = iph->saddr;
 	qp->daddr = iph->daddr;
+	qp->user = user;
 	qp->len = 0;
 	qp->meat = 0;
 	qp->fragments = NULL;
@@ -380,7 +383,7 @@ out_nomem:
 /* Find the correct entry in the "incomplete datagrams" queue for
  * this IP datagram, and create new one, if nothing is found.
  */
-static inline struct ipq *ip_find(struct iphdr *iph)
+static inline struct ipq *ip_find(struct iphdr *iph, u32 user)
 {
 	__u16 id = iph->id;
 	__u32 saddr = iph->saddr;
@@ -394,7 +397,8 @@ static inline struct ipq *ip_find(struct
 		if(qp->id == id		&&
 		   qp->saddr == saddr	&&
 		   qp->daddr == daddr	&&
-		   qp->protocol == protocol) {
+		   qp->protocol == protocol &&
+		   qp->user == user) {
 			atomic_inc(&qp->refcnt);
 			read_unlock(&ipfrag_lock);
 			return qp;
@@ -402,7 +406,7 @@ static inline struct ipq *ip_find(struct
 	}
 	read_unlock(&ipfrag_lock);
 
-	return ip_frag_create(hash, iph);
+	return ip_frag_create(hash, iph, user);
 }
 
 /* Add new segment to existing queue. */
@@ -636,7 +640,7 @@ out_fail:
 }
 
 /* Process an incoming IP datagram fragment. */
-struct sk_buff *ip_defrag(struct sk_buff *skb)
+struct sk_buff *ip_defrag(struct sk_buff *skb, u32 user)
 {
 	struct iphdr *iph = skb->nh.iph;
 	struct ipq *qp;
@@ -651,7 +655,7 @@ struct sk_buff *ip_defrag(struct sk_buff
 	dev = skb->dev;
 
 	/* Lookup (or create) queue header */
-	if ((qp = ip_find(iph)) != NULL) {
+	if ((qp = ip_find(iph, user)) != NULL) {
 		struct sk_buff *ret = NULL;
 
 		spin_lock(&qp->lock);
@@ -672,6 +676,27 @@ struct sk_buff *ip_defrag(struct sk_buff
 	return NULL;
 }
 
+static unsigned long ip_defrag_id_bitmap;
+
+int ip_defrag_user_id_alloc(void)
+{
+	int i;
+
+	for (i = 0; i < 32; i++) {
+		if (!test_and_set_bit(i, &ip_defrag_id_bitmap))
+			return i + __IP_DEFRAG_DYNAMIC_FIRST;
+	}
+
+	return -ENFILE;
+}
+
+void ip_defrag_user_id_free(int user)
+{
+	user -= __IP_DEFRAG_DYNAMIC_FIRST;
+	if (user >= 0 && user < 32)
+		clear_bit(user, &ip_defrag_id_bitmap);
+}
+
 void ipfrag_init(void)
 {
 	ipfrag_hash_rnd = (u32) ((num_physpages ^ (num_physpages>>7)) ^
diff -urNp linux-2090/net/ipv4/ip_input.c linux-2100/net/ipv4/ip_input.c
--- linux-2090/net/ipv4/ip_input.c
+++ linux-2100/net/ipv4/ip_input.c
@@ -171,7 +171,7 @@ int ip_call_ra_chain(struct sk_buff *skb
 		    && ((sk->bound_dev_if == 0) 
 			|| (sk->bound_dev_if == skb->dev->ifindex))) {
 			if (skb->nh.iph->frag_off & htons(IP_MF|IP_OFFSET)) {
-				skb = ip_defrag(skb);
+				skb = ip_defrag(skb, IP_DEFRAG_CALL_RA_CHAIN);
 				if (skb == NULL) {
 					read_unlock(&ip_ra_lock);
 					return 1;
@@ -269,7 +269,7 @@ int ip_local_deliver(struct sk_buff *skb
 	 */
 
 	if (skb->nh.iph->frag_off & htons(IP_MF|IP_OFFSET)) {
-		skb = ip_defrag(skb);
+		skb = ip_defrag(skb, IP_DEFRAG_LOCAL_DELIVER);
 		if (!skb)
 			return 0;
 	}
diff -urNp linux-2090/net/ipv4/ipvs/ip_vs_core.c linux-2100/net/ipv4/ipvs/ip_vs_core.c
--- linux-2090/net/ipv4/ipvs/ip_vs_core.c
+++ linux-2100/net/ipv4/ipvs/ip_vs_core.c
@@ -506,7 +506,7 @@ static int ip_vs_out_icmp(struct sk_buff
 
 	/* reassemble IP fragments, but will it happen in ICMP packets?? */
 	if (skb->nh.iph->frag_off & __constant_htons(IP_MF|IP_OFFSET)) {
-		skb = ip_defrag(skb);
+		skb = ip_defrag(skb, IP_DEFRAG_VS_OUT);
 		if (!skb)
 			return NF_STOLEN;
 		*skb_p = skb;
@@ -658,7 +658,7 @@ static unsigned int ip_vs_out(unsigned i
 
 	/* reassemble IP fragments */
 	if (iph->frag_off & __constant_htons(IP_MF|IP_OFFSET)) {
-		skb = ip_defrag(skb);
+		skb = ip_defrag(skb, IP_DEFRAG_VS_OUT);
 		if (!skb)
 			return NF_STOLEN;
 		iph = skb->nh.iph;
@@ -1166,7 +1166,7 @@ static unsigned int ip_vs_forward_icmp(u
 		return NF_ACCEPT;
 
 	if (iph->frag_off & __constant_htons(IP_MF|IP_OFFSET)) {
-		skb = ip_defrag(skb);
+		skb = ip_defrag(skb, IP_DEFRAG_VS_FWD);
 		if (!skb)
 			return NF_STOLEN;
 		*skb_p = skb;
diff -urNp linux-2090/net/ipv4/netfilter/ip_conntrack_core.c linux-2100/net/ipv4/netfilter/ip_conntrack_core.c
--- linux-2090/net/ipv4/netfilter/ip_conntrack_core.c
+++ linux-2100/net/ipv4/netfilter/ip_conntrack_core.c
@@ -831,7 +831,10 @@ unsigned int ip_conntrack_in(unsigned in
 
 	/* Gather fragments. */
 	if ((*pskb)->nh.iph->frag_off & htons(IP_MF|IP_OFFSET)) {
-		*pskb = ip_ct_gather_frags(*pskb);
+		*pskb = ip_ct_gather_frags(*pskb,
+		                           hooknum == NF_IP_PRE_ROUTING ?
+		                           IP_DEFRAG_CONNTRACK_IN :
+		                           IP_DEFRAG_CONNTRACK_OUT);
 		if (!*pskb)
 			return NF_STOLEN;
 	}
@@ -1192,19 +1195,20 @@ void ip_ct_refresh(struct ip_conntrack *
 
 /* Returns new sk_buff, or NULL */
 struct sk_buff *
-ip_ct_gather_frags(struct sk_buff *skb)
+ip_ct_gather_frags(struct sk_buff *skb, u_int32_t user)
 {
 	struct sock *sk = skb->sk;
 #ifdef CONFIG_NETFILTER_DEBUG
 	unsigned int olddebug = skb->nf_debug;
 #endif
+
 	if (sk) {
 		sock_hold(sk);
 		skb_orphan(skb);
 	}
 
 	local_bh_disable(); 
-	skb = ip_defrag(skb);
+	skb = ip_defrag(skb, user);
 	local_bh_enable();
 
 	if (!skb) {
diff -urNp linux-2090/net/ipv4/netfilter/ip_fw_compat.c linux-2100/net/ipv4/netfilter/ip_fw_compat.c
--- linux-2090/net/ipv4/netfilter/ip_fw_compat.c
+++ linux-2100/net/ipv4/netfilter/ip_fw_compat.c
@@ -106,7 +106,7 @@ fw_in(unsigned int hooknum,
 					  (*pskb)->nh.raw, &redirpt, pskb);
 
 		if ((*pskb)->nh.iph->frag_off & htons(IP_MF|IP_OFFSET)) {
-			*pskb = ip_ct_gather_frags(*pskb);
+			*pskb = ip_ct_gather_frags(*pskb, IP_DEFRAG_FW_COMPAT);
 
 			if (!*pskb)
 				return NF_STOLEN;
diff -urNp linux-2090/net/ipv4/netfilter/ip_nat_standalone.c linux-2100/net/ipv4/netfilter/ip_nat_standalone.c
--- linux-2090/net/ipv4/netfilter/ip_nat_standalone.c
+++ linux-2100/net/ipv4/netfilter/ip_nat_standalone.c
@@ -186,7 +186,7 @@ ip_nat_out(unsigned int hooknum,
 	   I'm starting to have nightmares about fragments.  */
 
 	if ((*pskb)->nh.iph->frag_off & htons(IP_MF|IP_OFFSET)) {
-		*pskb = ip_ct_gather_frags(*pskb);
+		*pskb = ip_ct_gather_frags(*pskb, IP_DEFRAG_NAT_OUT);
 
 		if (!*pskb)
 			return NF_STOLEN;
diff -urNp linux-2090/net/netsyms.c linux-2100/net/netsyms.c
--- linux-2090/net/netsyms.c
+++ linux-2100/net/netsyms.c
@@ -282,6 +282,8 @@ EXPORT_SYMBOL(ip_dev_find);
 EXPORT_SYMBOL(inetdev_by_index);
 EXPORT_SYMBOL(in_dev_finish_destroy);
 EXPORT_SYMBOL(ip_defrag);
+EXPORT_SYMBOL(ip_defrag_user_id_alloc);
+EXPORT_SYMBOL(ip_defrag_user_id_free);
 EXPORT_SYMBOL(inet_peer_idlock);
 
 /* Route manipulation */
