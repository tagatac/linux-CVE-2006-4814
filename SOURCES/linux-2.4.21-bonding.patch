diff -urNp linux-8120/Documentation/networking/bonding.txt linux-8121/Documentation/networking/bonding.txt
--- linux-8120/Documentation/networking/bonding.txt
+++ linux-8121/Documentation/networking/bonding.txt
@@ -21,7 +21,7 @@ userspace tools, please follow the links
 
 Table of Contents
 =================
- 
+
 Installation
 Bond Configuration
 Module Parameters
@@ -31,6 +31,7 @@ Verifying Bond Configuration
 Frequently Asked Questions
 High Availability
 Promiscuous Sniffing notes
+8021q VLAN support
 Limitations
 Resources and Links
 
@@ -43,10 +44,10 @@ Installation
 For the latest version of the bonding driver, use kernel 2.4.12 or above
 (otherwise you will need to apply a patch).
 
-Configure kernel with `make menuconfig/xconfig/config', and select
-"Bonding driver support" in the "Network device support" section. It is
-recommended to configure the driver as module since it is currently the only way
-to pass parameters to the driver and configure more than one bonding device.
+Configure kernel with `make menuconfig/xconfig/config', and select "Bonding
+driver support" in the "Network device support" section. It is recommended
+to configure the driver as module since it is currently the only way to
+pass parameters to the driver and configure more than one bonding device.
 
 Build and install the new kernel and modules.
 
@@ -66,7 +67,7 @@ of the -I option on the ifenslave compil
 /usr/include/linux.
 
 To install ifenslave.c, do:
-    # gcc -Wall -Wstrict-prototypes -O -I/usr/src/linux/include ifenslave.c -o ifenslave 
+    # gcc -Wall -Wstrict-prototypes -O -I/usr/src/linux/include ifenslave.c -o ifenslave
     # cp ifenslave /sbin/ifenslave
 
 
@@ -74,10 +75,10 @@ Bond Configuration
 ==================
 
 You will need to add at least the following line to /etc/modules.conf
-so the bonding driver will automatically load when the bond0 interface is 
-configured. Refer to the modules.conf manual page for specific modules.conf 
-syntax details. The Module Parameters section of this document describes each 
-bonding driver parameter. 
+so the bonding driver will automatically load when the bond0 interface is
+configured. Refer to the modules.conf manual page for specific modules.conf
+syntax details. The Module Parameters section of this document describes each
+bonding driver parameter.
 
 	alias bond0 bonding
 
@@ -93,9 +94,16 @@ BROADCAST=192.168.1.255
 ONBOOT=yes
 BOOTPROTO=none
 USERCTL=no
+HOTPLUG=no
 
 (use appropriate values for your network above)
 
+It may be necessary to add the HOTPLUG=no option to your ifcfg-bond0 file
+to avoid problems and hangs that can occur when trying to manually configure
+bonding interfaces.  Without HOTPLUG=no in this file, hotplug will spring
+into action whenever the interface is detected and may cause unexpected and
+undesired results.
+
 All interfaces that are part of a bond should have SLAVE and MASTER
 definitions. For example, in the case of Red Hat, if you wish to make eth0 and
 eth1 a part of the bonding interface bond0, their config files (ifcfg-eth0 and
@@ -108,17 +116,17 @@ MASTER=bond0
 SLAVE=yes
 BOOTPROTO=none
 
-Use DEVICE=eth1 in the ifcfg-eth1 config file. If you configure a second bonding
-interface (bond1), use MASTER=bond1 in the config file to make the network
-interface be a slave of bond1.
+Use DEVICE=eth1 in the ifcfg-eth1 config file. If you configure a second
+bonding interface (bond1), use MASTER=bond1 in the config file to make the
+network interface be a slave of bond1.
 
 Restart the networking subsystem or just bring up the bonding device if your
-administration tools allow it. Otherwise, reboot. On Red Hat distros you can 
+administration tools allow it. Otherwise, reboot. On Red Hat distros you can
 issue `ifup bond0' or `/etc/rc.d/init.d/network restart'.
 
-If the administration tools of your distribution do not support master/slave
-notation in configuring network interfaces, you will need to manually configure 
-the bonding device with the following commands:
+If the administration tools of your distribution do not support
+master/slave notation in configuring network interfaces, you will need to
+manually configure the bonding device with the following commands:
 
     # /sbin/ifconfig bond0 192.168.1.1 netmask 255.255.255.0 \
       broadcast 192.168.1.255 up
@@ -128,30 +136,26 @@ the bonding device with the following co
 
 (use appropriate values for your network above)
 
-You can then create a script containing these commands and place it in the 
+You can then create a script containing these commands and place it in the
 appropriate rc directory.
 
 If you specifically need all network drivers loaded before the bonding driver,
-adding the following line to modules.conf will cause the network driver for 
+adding the following line to modules.conf will cause the network driver for
 eth0 and eth1 to be loaded before the bonding driver.
 
 probeall bond0 eth0 eth1 bonding
 
-Be careful not to reference bond0 itself at the end of the line, or modprobe 
+Be careful not to reference bond0 itself at the end of the line, or modprobe
 will die in an endless recursive loop.
 
-To have device characteristics (such as MTU size) propagate to slave devices, 
-set the bond characteristics before enslaving the device.  The characteristics 
-are propagated during the enslave process.
-
-If running SNMP agents, the bonding driver should be loaded before any network 
-drivers participating in a bond. This requirement is due to the the interface 
-index (ipAdEntIfIndex) being associated to the first interface found with a 
-given IP address. That is, there is only one ipAdEntIfIndex for each IP 
-address. For example, if eth0 and eth1 are slaves of bond0 and the driver for 
-eth0 is loaded before the bonding driver, the interface for the IP address 
-will be associated with the eth0 interface. This configuration is shown below, 
-the IP address 192.168.1.1 has an interface index of 2 which indexes to eth0 
+If running SNMP agents, the bonding driver should be loaded before any network
+drivers participating in a bond. This requirement is due to the the interface
+index (ipAdEntIfIndex) being associated to the first interface found with a
+given IP address. That is, there is only one ipAdEntIfIndex for each IP
+address. For example, if eth0 and eth1 are slaves of bond0 and the driver for
+eth0 is loaded before the bonding driver, the interface for the IP address
+will be associated with the eth0 interface. This configuration is shown below,
+the IP address 192.168.1.1 has an interface index of 2 which indexes to eth0
 in the ifDescr table (ifDescr.2).
 
      interfaces.ifTable.ifEntry.ifDescr.1 = lo
@@ -166,8 +170,9 @@ in the ifDescr table (ifDescr.2).
      ip.ipAddrTable.ipAddrEntry.ipAdEntIfIndex.127.0.0.1 = 1
 
 This problem is avoided by loading the bonding driver before any network
-drivers participating in a bond. Below is an example of loading the bonding 
-driver first, the IP address 192.168.1.1 is correctly associated with ifDescr.2.
+drivers participating in a bond. Below is an example of loading the bonding
+driver first, the IP address 192.168.1.1 is correctly associated with
+ifDescr.2.
 
      interfaces.ifTable.ifEntry.ifDescr.1 = lo
      interfaces.ifTable.ifEntry.ifDescr.2 = bond0
@@ -188,10 +193,10 @@ functions such as Interface_Scan_Next wi
 Module Parameters
 =================
 
-Optional parameters for the bonding driver can be supplied as command line 
-arguments to the insmod command. Typically, these parameters are specified in 
-the file /etc/modules.conf (see the manual page for modules.conf). The 
-available bonding driver parameters are listed below. If a parameter is not 
+Optional parameters for the bonding driver can be supplied as command line
+arguments to the insmod command. Typically, these parameters are specified in
+the file /etc/modules.conf (see the manual page for modules.conf). The
+available bonding driver parameters are listed below. If a parameter is not
 specified the default value is used. When initially configuring a bond, it
 is recommended "tail -f /var/log/messages" be run in a separate window to
 watch for bonding driver error messages.
@@ -200,6 +205,44 @@ It is critical that either the miimon or
 parameters be specified, otherwise serious network degradation will occur
 during link failures.
 
+arp_interval
+
+        Specifies the ARP monitoring frequency in milli-seconds.
+        If ARP monitoring is used in a load-balancing mode (mode 0 or 2), the
+        switch should be configured in a mode that evenly distributes packets
+        across all links - such as round-robin. If the switch is configured to
+        distribute the packets in an XOR fashion, all replies from the ARP
+        targets will be received on the same link which could cause the other
+        team members to fail. ARP monitoring should not be used in conjunction
+        with miimon. A value of 0 disables ARP monitoring. The default value
+        is 0.
+
+arp_ip_target
+
+	Specifies the ip addresses to use when arp_interval is > 0. These
+	are the targets of the ARP request sent to determine the health of
+	the link to the targets. Specify these values in ddd.ddd.ddd.ddd
+	format. Multiple ip adresses must be seperated by a comma. At least
+	one ip address needs to be given for ARP monitoring to work. The
+	maximum number of targets that can be specified is set at 16.
+
+downdelay
+
+        Specifies the delay time in milli-seconds to disable a link after a
+        link failure has been detected. This should be a multiple of miimon
+        value, otherwise the value will be rounded. The default value is 0.
+
+lacp_rate
+
+        Option specifying the rate in which we'll ask our link partner to
+	transmit LACPDU packets in 802.3ad mode.  Possible values are:
+
+	slow or 0
+		Request partner to transmit LACPDUs every 30 seconds (default)
+
+	fast or 1
+		Request partner to transmit LACPDUs every 1 second
+
 max_bonds
 
 	Specifies the number of bonding devices to create for this
@@ -207,26 +250,36 @@ max_bonds
 	the bonding driver is not already loaded, then bond0, bond1
 	and bond2 will be created.  The default value is 1.
 
+miimon
+
+        Specifies the frequency in milli-seconds that MII link monitoring
+        will occur. A value of zero disables MII link monitoring. A value
+        of 100 is a good starting point. See High Availability section for
+        additional information. The default value is 0.
+
 mode
 
-	Specifies one of four bonding policies. The default is
-round-robin (balance-rr).  Possible values are (you can use either the
-text or numeric option):
- 
+	Specifies one of the bonding policies. The default is
+	round-robin (balance-rr).  Possible values are (you can use
+	either the text or numeric option):
+
 	balance-rr or 0
+
 		Round-robin policy: Transmit in a sequential order
 		from the first available slave through the last. This
 		mode provides load balancing and fault tolerance.
 
 	active-backup or 1
+
 		Active-backup policy: Only one slave in the bond is
 		active. A different slave becomes active if, and only
 		if, the active slave fails. The bond's MAC address is
 		externally visible on only one port (network adapter)
 		to avoid confusing the switch.  This mode provides
 		fault tolerance.
- 
-        balance-xor or 2
+
+	balance-xor or 2
+
 		XOR policy: Transmit based on [(source MAC address
 		XOR'd with destination MAC address) modula slave
 		count]. This selects the same slave for each
@@ -234,15 +287,110 @@ text or numeric option):
 		balancing and fault tolerance.
 
 	broadcast or 3
+
 		Broadcast policy: transmits everything on all slave
 		interfaces. This mode provides fault tolerance.
 
-miimon
- 
-        Specifies the frequency in milli-seconds that MII link monitoring will 
-        occur. A value of zero disables MII link monitoring. A value of 
-        100 is a good starting point. See High Availability section for 
-        additional information. The default value is 0.
+	802.3ad or 4
+
+		IEEE 802.3ad Dynamic link aggregation. Creates aggregation
+		groups that share the same speed and duplex settings.
+		Transmits and receives on all slaves in the active
+		aggregator.
+
+		Pre-requisites:
+
+		1. Ethtool support in the base drivers for retrieving the
+		speed and duplex of each slave.
+
+		2. A switch that supports IEEE 802.3ad Dynamic link
+		aggregation.
+
+	balance-tlb or 5
+
+		Adaptive transmit load balancing: channel bonding that does
+		not require any special switch support. The outgoing
+		traffic is distributed according to the current load
+		(computed relative to the speed) on each slave. Incoming
+		traffic is received by the current slave. If the receiving
+		slave fails, another slave takes over the MAC address of
+		the failed receiving slave.
+
+		Prerequisite:
+
+		Ethtool support in the base drivers for retrieving the
+		speed of each slave.
+
+	balance-alb or 6
+
+		Adaptive load balancing: includes balance-tlb + receive
+		load balancing (rlb) for IPV4 traffic and does not require
+		any special switch support. The receive load balancing is
+		achieved by ARP negotiation. The bonding driver intercepts
+		the ARP Replies sent by the server on their way out and
+		overwrites the src hw address with the unique hw address of
+		one of the slaves in the bond such that different clients
+		use different hw addresses for the server.
+
+		Receive traffic from connections created by the server is
+		also balanced. When the server sends an ARP Request the
+		bonding driver copies and saves the client's IP information
+		from the ARP. When the ARP Reply arrives from the client,
+		its hw address is retrieved and the bonding driver
+		initiates an ARP reply to this client assigning it to one
+		of the slaves in the bond. A problematic outcome of using
+		ARP negotiation for balancing is that each time that an ARP
+		request is broadcasted it uses the hw address of the
+		bond. Hence, clients learn the hw address of the bond and
+		the balancing of receive traffic collapses to the current
+		salve. This is handled by sending updates (ARP Replies) to
+		all the clients with their assigned hw address such that
+		the traffic is redistributed. Receive traffic is also
+		redistributed when a new slave is added to the bond and
+		when an inactive slave is re-activated. The receive load is
+		distributed sequentially (round robin) among the group of
+		highest speed slaves in the bond.
+
+		When a link is reconnected or a new slave joins the bond
+		the receive traffic is redistributed among all active
+		slaves in the bond by intiating ARP Replies with the
+		selected mac address to each of the clients. The updelay
+		modeprobe parameter must be set to a value equal or greater
+		than the switch's forwarding delay so that the ARP Replies
+		sent to the clients will not be blocked by the switch.
+
+		Prerequisites:
+
+		1. Ethtool support in the base drivers for retrieving the
+		speed of each slave.
+
+		2. Base driver support for setting the hw address of a
+		device also when it is open. This is required so that there
+		will always be one slave in the team using the bond hw
+		address (the curr_active_slave) while having a unique hw
+		address for each slave in the bond. If the curr_active_slave
+		fails it's hw address is swapped with the new curr_active_slave
+		that was chosen.
+
+primary
+
+        A string (eth0, eth2, etc) to equate to a primary device. If this
+        value is entered, and the device is on-line, it will be used first
+        as the output media. Only when this device is off-line, will
+        alternate devices be used. Otherwise, once a failover is detected
+        and a new default output is chosen, it will remain the output media
+        until it too fails. This is useful when one slave was preferred
+        over another, i.e. when one slave is 1000Mbps and another is
+        100Mbps. If the 1000Mbps slave fails and is later restored, it may
+        be preferred the faster slave gracefully become the active slave -
+        without deliberately failing the 100Mbps slave. Specifying a
+        primary is only valid in active-backup mode.
+
+updelay
+
+        Specifies the delay time in milli-seconds to enable a link after a
+        link up status has been detected. This should be a multiple of miimon
+        value, otherwise the value will be rounded. The default value is 0.
 
 use_carrier
 
@@ -265,89 +413,37 @@ use_carrier
         0 will use the deprecated MII / ETHTOOL ioctls.  The default
         value is 1.
 
-downdelay
- 
-        Specifies the delay time in milli-seconds to disable a link after a 
-        link failure has been detected. This should be a multiple of miimon
-        value, otherwise the value will be rounded. The default value is 0.
-
-updelay
- 
-        Specifies the delay time in milli-seconds to enable a link after a 
-        link up status has been detected. This should be a multiple of miimon
-        value, otherwise the value will be rounded. The default value is 0.
- 
-arp_interval
- 
-        Specifies the ARP monitoring frequency in milli-seconds. 
-        If ARP monitoring is used in a load-balancing mode (mode 0 or 2), the 
-        switch should be configured in a mode that evenly distributes packets 
-        across all links - such as round-robin. If the switch is configured to 
-        distribute the packets in an XOR fashion, all replies from the ARP 
-        targets will be received on the same link which could cause the other 
-        team members to fail. ARP monitoring should not be used in conjunction
-        with miimon. A value of 0 disables ARP monitoring. The default value 
-        is 0.
- 
-arp_ip_target
- 
-        Specifies the ip addresses to use when arp_interval is > 0. These are
-        the targets of the ARP request sent to determine the health of the link
-        to the targets. Specify these values in ddd.ddd.ddd.ddd format.
-        Multiple ip adresses must be seperated by a comma. At least one ip
-        address needs to be given for ARP monitoring to work. The maximum number
-        of targets that can be specified is set at 16.
-
-primary
-
-        A string (eth0, eth2, etc) to equate to a primary device. If this 
-        value is entered, and the device is on-line, it will be used first as 
-        the output media. Only when this device is off-line, will alternate 
-        devices be used. Otherwise, once a failover is detected and a new 
-        default output is chosen, it will remain the output media until it too 
-        fails. This is useful when one slave was preferred over another, i.e. 
-        when one slave is 1000Mbps and another is 100Mbps. If the 1000Mbps 
-        slave fails and is later restored, it may be preferred the faster slave
-        gracefully become the active slave - without deliberately failing the
-        100Mbps slave. Specifying a primary is only valid in active-backup mode.
-
-multicast
-
-        Option specifying the mode of operation for multicast support.
-        Possible values are:
-
-	disabled or 0
-		Disabled (no multicast support)
-
-        active or 1
-		Enabled on active slave only, useful in active-backup mode
-
-	all or 2
-		Enabled on all slaves, this is the default
-
 
 Configuring Multiple Bonds
 ==========================
 
-If several bonding interfaces are required, the driver must be loaded
-multiple times. For example, to configure two bonding interfaces with link 
-monitoring performed every 100 milli-seconds, the /etc/conf.modules should
+If several bonding interfaces are required, either specify the max_bonds
+parameter (described above), or load the driver multiple times.  Using
+the max_bonds parameter is less complicated, but has the limitation that
+all bonding instances created will have the same options.  Loading the
+driver multiple times allows each instance of the driver to have differing
+options.
+
+For example, to configure two bonding interfaces, one with mii link
+monitoring performed every 100 milliseconds, and one with ARP link
+monitoring performed every 200 milliseconds, the /etc/conf.modules should
 resemble the following:
 
 alias bond0 bonding
 alias bond1 bonding
 
 options bond0 miimon=100
-options bond1 -o bonding1 miimon=100
+options bond1 -o bonding1 arp_interval=200 arp_ip_target=10.0.0.1
 
 Configuring Multiple ARP Targets
 ================================
 
-While ARP monitoring can be done with just one target, it can be usefull
+While ARP monitoring can be done with just one target, it can be useful
 in a High Availability setup to have several targets to monitor. In the
 case of just one target,  the target itself may go down or have a problem
 making it unresponsive to ARP requests. Having an additional target (or
-several) would increase the reliability of the ARP monitoring.
+several) increases the reliability of the ARP monitoring.
+
 Multiple ARP targets must be seperated by commas as follows:
 
 # example options for ARP monitoring with three targets
@@ -410,9 +506,10 @@ additions may cause trouble.
 Switch Configuration
 ====================
 
-While the switch does not need to be configured when the active-backup
-policy is used (mode=1), it does need to be configured for the round-robin, 
-XOR, and broadcast policies (mode=0, mode=2, and mode=3). 
+While the switch does not need to be configured when the active-backup,
+balance-tlb or balance-alb policies (mode=1,5,6) are used, it does need to
+be configured for the round-robin, XOR, broadcast, or 802.3ad policies
+(mode=0,2,3,4).
 
 
 Verifying Bond Configuration
@@ -420,22 +517,22 @@ Verifying Bond Configuration
 
 1) Bonding information files
 ----------------------------
-The bonding driver information files reside in the /proc/net/bond* directories. 
+The bonding driver information files reside in the /proc/net/bonding directory.
 
-Sample contents of /proc/net/bond0/info after the driver is loaded with 
+Sample contents of /proc/net/bonding/bond0 after the driver is loaded with
 parameters of mode=0 and miimon=1000 is shown below.
- 
+
         Bonding Mode: load balancing (round-robin)
         Currently Active Slave: eth0
         MII Status: up
         MII Polling Interval (ms): 1000
         Up Delay (ms): 0
         Down Delay (ms): 0
- 
+
         Slave Interface: eth1
         MII Status: up
         Link Failure Count: 1
- 
+
         Slave Interface: eth0
         MII Status: up
         Link Failure Count: 1
@@ -443,33 +540,34 @@ parameters of mode=0 and miimon=1000 is 
 2) Network verification
 -----------------------
 The network configuration can be verified using the ifconfig command. In
-the example below, the bond0 interface is the master (MASTER) while eth0 and 
-eth1 are slaves (SLAVE). Notice all slaves of bond0 have the same MAC address 
-(HWaddr) as bond0.
+the example below, the bond0 interface is the master (MASTER) while eth0 and
+eth1 are slaves (SLAVE). Notice all slaves of bond0 have the same MAC address
+(HWaddr) as bond0 for all modes except TLB and ALB that require a unique MAC
+address for each slave.
 
 [root]# /sbin/ifconfig
-bond0     Link encap:Ethernet  HWaddr 00:C0:F0:1F:37:B4  
+bond0     Link encap:Ethernet  HWaddr 00:C0:F0:1F:37:B4
           inet addr:XXX.XXX.XXX.YYY  Bcast:XXX.XXX.XXX.255  Mask:255.255.252.0
           UP BROADCAST RUNNING MASTER MULTICAST  MTU:1500  Metric:1
           RX packets:7224794 errors:0 dropped:0 overruns:0 frame:0
           TX packets:3286647 errors:1 dropped:0 overruns:1 carrier:0
-          collisions:0 txqueuelen:0 
+          collisions:0 txqueuelen:0
 
-eth0      Link encap:Ethernet  HWaddr 00:C0:F0:1F:37:B4  
+eth0      Link encap:Ethernet  HWaddr 00:C0:F0:1F:37:B4
           inet addr:XXX.XXX.XXX.YYY  Bcast:XXX.XXX.XXX.255  Mask:255.255.252.0
           UP BROADCAST RUNNING SLAVE MULTICAST  MTU:1500  Metric:1
           RX packets:3573025 errors:0 dropped:0 overruns:0 frame:0
           TX packets:1643167 errors:1 dropped:0 overruns:1 carrier:0
-          collisions:0 txqueuelen:100 
-          Interrupt:10 Base address:0x1080 
+          collisions:0 txqueuelen:100
+          Interrupt:10 Base address:0x1080
 
-eth1      Link encap:Ethernet  HWaddr 00:C0:F0:1F:37:B4  
+eth1      Link encap:Ethernet  HWaddr 00:C0:F0:1F:37:B4
           inet addr:XXX.XXX.XXX.YYY  Bcast:XXX.XXX.XXX.255  Mask:255.255.252.0
           UP BROADCAST RUNNING SLAVE MULTICAST  MTU:1500  Metric:1
           RX packets:3651769 errors:0 dropped:0 overruns:0 frame:0
           TX packets:1643480 errors:0 dropped:0 overruns:0 carrier:0
-          collisions:0 txqueuelen:100 
-          Interrupt:9 Base address:0x1400 
+          collisions:0 txqueuelen:100
+          Interrupt:9 Base address:0x1400
 
 
 Frequently Asked Questions
@@ -488,8 +586,7 @@ Frequently Asked Questions
 
 3.  How many bonding devices can I have?
 
-	One for each module you load. See section on Module Parameters for how
-	to accomplish this.
+	There is no limit.
 
 4.  How many slaves can a bonding device have?
 
@@ -498,9 +595,9 @@ Frequently Asked Questions
 
 5.  What happens when a slave link dies?
 
-	If your ethernet cards support MII or ETHTOOL link status monitoring 
-        and the MII monitoring has been enabled in the driver (see description 
-        of module parameters), there will be no adverse consequences. This 
+	If your ethernet cards support MII or ETHTOOL link status monitoring
+        and the MII monitoring has been enabled in the driver (see description
+        of module parameters), there will be no adverse consequences. This
         release of the bonding driver knows how to get the MII information and
 	enables or disables its slaves according to their link status.
 	See section on High Availability for additional information.
@@ -508,37 +605,49 @@ Frequently Asked Questions
 	For ethernet cards not supporting MII status, the arp_interval and
         arp_ip_target parameters must be specified for bonding to work
         correctly. If packets have not been sent or received during the
-        specified arp_interval durration, an ARP request is sent to the targets 
-        to generate send and receive traffic. If after this interval, either 
-        the successful send and/or receive count has not incremented, the next 
-        slave in the sequence will become the active slave.
+        specified arp_interval duration, an ARP request is sent to the
+        targets to generate send and receive traffic. If after this
+        interval, either the successful send and/or receive count has not
+        incremented, the next slave in the sequence will become the active
+        slave.
 
 	If neither mii_monitor and arp_interval is configured, the bonding
-	driver will not handle this situation very well. The driver will 
-	continue to send packets but some packets will be lost. Retransmits 
+	driver will not handle this situation very well. The driver will
+	continue to send packets but some packets will be lost. Retransmits
 	will cause serious degradation of performance (in the case when one
 	of two slave links fails, 50% packets will be lost, which is a serious
 	problem for both TCP and UDP).
 
 6.  Can bonding be used for High Availability?
 
-	Yes, if you use MII monitoring and ALL your cards support MII link
-	status reporting. See section on High Availability for more information.
+        Yes, if you use MII monitoring and ALL your cards support MII link
+        status reporting. See section on High Availability for more
+        information.
 
 7.  Which switches/systems does it work with?
 
-	In round-robin and XOR mode, it works with systems that support 
+	In round-robin and XOR mode, it works with systems that support
 	trunking:
-	
-	* Cisco 5500 series (look for EtherChannel support).
+
+	* Many Cisco switches and routers (look for EtherChannel support).
 	* SunTrunking software.
 	* Alteon AceDirector switches / WebOS (use Trunks).
 	* BayStack Switches (trunks must be explicitly configured). Stackable
 	  models (450) can define trunks between ports on different physical
 	  units.
 	* Linux bonding, of course !
-	
-	In active-backup mode, it should work with any Layer-II switche.
+
+	In 802.3ad mode, it works with with systems that support IEEE 802.3ad
+	Dynamic Link Aggregation:
+
+	* Extreme networks Summit 7i (look for link-aggregation).
+	* Many Cisco switches and routers (look for LACP support; this may
+	  require an upgrade to your IOS software; LACP support was added
+	  by Cisco in late 2002).
+	* Foundry Big Iron 4000
+
+        In active-backup, balance-tlb and balance-alb modes, it should work
+        with any Layer-II switch.
 
 
 8.  Where does a bonding device get its MAC address from?
@@ -548,32 +657,24 @@ Frequently Asked Questions
 	is then passed to all following slaves and remains persistent (even if
 	the the first slave is removed) until the bonding device is brought
 	down or reconfigured.
-	
+
 	If you wish to change the MAC address, you can set it with ifconfig:
 
 	  # ifconfig bond0 hw ether 00:11:22:33:44:55
 
 	The MAC address can be also changed by bringing down/up the device
 	and then changing its slaves (or their order):
-	
+
 	  # ifconfig bond0 down ; modprobe -r bonding
 	  # ifconfig bond0 .... up
 	  # ifenslave bond0 eth...
 
 	This method will automatically take the address from the next slave
 	that will be added.
-	
-	To restore your slaves' MAC addresses, you need to detach them
-	from the bond (`ifenslave -d bond0 eth0'), set them down
-	(`ifconfig eth0 down'), unload the drivers (`rmmod 3c59x', for
-	example) and reload them to get the MAC addresses from their
-	eeproms. If the driver is shared by several devices, you need
-	to turn them all down. Another solution is to look for the MAC
-	address at boot time (dmesg or tail /var/log/messages) and to
-	reset it by hand with ifconfig :
 
-	  # ifconfig eth0 down
-	  # ifconfig eth0 hw ether 00:20:40:60:80:A0
+	To restore your slaves' MAC addresses, you need to detach them
+	from the bond (`ifenslave -d bond0 eth0'). The bonding driver will then
+	restore the MAC addresses that the slaves had before they were enslaved.
 
 9.  Which transmit polices can be used?
 
@@ -591,32 +692,46 @@ Frequently Asked Questions
 
 	Broadcast policy transmits everything on all slave interfaces.
 
+	802.3ad, based on XOR but distributes traffic among all interfaces
+	in the active aggregator.
+
+	Transmit load balancing (balance-tlb) balances the traffic
+	according to the current load on each slave. The balancing is
+	clients based and the least loaded slave is selected for each new
+	client. The load of each slave is calculated relative to its speed
+	and enables load balancing in mixed speed teams.
+
+	Adaptive load balancing (balance-alb) uses the Transmit load
+	balancing for the transmit load. The receive load is balanced only
+	among the group of highest speed active slaves in the bond. The
+	load is distributed with round-robin i.e. next available slave in
+	the high speed group of active slaves.
 
 High Availability
 =================
 
 To implement high availability using the bonding driver, the driver needs to be
-compiled as a module, because currently it is the only way to pass parameters 
+compiled as a module, because currently it is the only way to pass parameters
 to the driver. This may change in the future.
 
-High availability is achieved by using MII or ETHTOOL status reporting. You 
-need to verify that all your interfaces support MII or ETHTOOL link status 
-reporting.  On Linux kernel 2.2.17, all the 100 Mbps capable drivers and 
-yellowfin gigabit driver support MII. To determine if ETHTOOL link reporting 
-is available for interface eth0, type "ethtool eth0" and the "Link detected:" 
-line should contain the correct link status. If your system has an interface 
-that does not support MII or ETHTOOL status reporting, a failure of its link 
-will not be detected! A message indicating MII and ETHTOOL is not supported by 
-a network driver is logged when the bonding driver is loaded with a non-zero 
+High availability is achieved by using MII or ETHTOOL status reporting. You
+need to verify that all your interfaces support MII or ETHTOOL link status
+reporting.  On Linux kernel 2.2.17, all the 100 Mbps capable drivers and
+yellowfin gigabit driver support MII. To determine if ETHTOOL link reporting
+is available for interface eth0, type "ethtool eth0" and the "Link detected:"
+line should contain the correct link status. If your system has an interface
+that does not support MII or ETHTOOL status reporting, a failure of its link
+will not be detected! A message indicating MII and ETHTOOL is not supported by
+a network driver is logged when the bonding driver is loaded with a non-zero
 miimon value.
 
 The bonding driver can regularly check all its slaves links using the ETHTOOL
-IOCTL (ETHTOOL_GLINK command) or by checking the MII status registers. The 
-check interval is specified by the module argument "miimon" (MII monitoring). 
-It takes an integer that represents the checking time in milliseconds. It 
-should not come to close to (1000/HZ) (10 milli-seconds on i386) because it 
-may then reduce the system interactivity. A value of 100 seems to be a good 
-starting point. It means that a dead link will be detected at most 100 
+IOCTL (ETHTOOL_GLINK command) or by checking the MII status registers. The
+check interval is specified by the module argument "miimon" (MII monitoring).
+It takes an integer that represents the checking time in milliseconds. It
+should not come to close to (1000/HZ) (10 milli-seconds on i386) because it
+may then reduce the system interactivity. A value of 100 seems to be a good
+starting point. It means that a dead link will be detected at most 100
 milli-seconds after it goes down.
 
 Example:
@@ -628,7 +743,7 @@ Or, put the following lines in /etc/modu
    alias bond0 bonding
    options bond0 miimon=100
 
-There are currently two policies for high availability. They are dependent on 
+There are currently two policies for high availability. They are dependent on
 whether:
 
    a) hosts are connected to a single host or switch that support trunking
@@ -678,7 +793,7 @@ Example 2 : host to switch at twice the 
      # ifenslave bond0 eth0 eth1
 
 
-2) High Availability on two or more switches (or a single switch without 
+2) High Availability on two or more switches (or a single switch without
    trunking support)
 ---------------------------------------------------------------------------
 This mode is more problematic because it relies on the fact that there
@@ -724,7 +839,7 @@ point of failure" solution.
 
 In this configuration, there is an ISL - Inter Switch Link (could be a trunk),
 several servers (host1, host2 ...) attached to both switches each, and one or
-more ports to the outside world (port3...). One an only one slave on each host
+more ports to the outside world (port3...). One and only one slave on each host
 is active at a time, while all links are still monitored (the system can
 detect a failure of active and backup links).
 
@@ -737,10 +852,10 @@ by another external mechanism, it is goo
 connected to one switch and host2's to the other. Such system will survive
 a failure of a single host, cable, or switch. The worst thing that may happen
 in the case of a switch failure is that half of the hosts will be temporarily
-unreachable until the other switch expires its tables. 
+unreachable until the other switch expires its tables.
 
 Example 2: Using multiple ethernet cards connected to a switch to configure
-           NIC failover (switch is not required to support trunking). 
+           NIC failover (switch is not required to support trunking).
 
 
           +----------+                          +----------+
@@ -814,6 +929,41 @@ capacity aggregating; but it works fine 
 just ignore all the warnings it emits.
 
 
+8021q VLAN support
+==================
+
+It is possible to configure VLAN devices over a bond interface using the 8021q
+driver. However, only packets coming from the 8021q driver and passing through
+bonding will be tagged by default. Self generated packets, like bonding's
+learning packets or ARP packets generated by either ALB mode or the ARP
+monitor mechanism, are tagged internally by bonding itself. As a result,
+bonding has to "learn" what VLAN IDs are configured on top of it, and it uses
+those IDs to tag self generated packets.
+
+For simplicity reasons, and to support the use of adapters that can do VLAN
+hardware acceleration offloding, the bonding interface declares itself as
+fully hardware offloaing capable, it gets the add_vid/kill_vid notifications
+to gather the necessary information, and it propagates those actions to the
+slaves.
+In case of mixed adapter types, hardware accelerated tagged packets that should
+go through an adapter that is not offloading capable are "un-accelerated" by the
+bonding driver so the VLAN tag sits in the regular location.
+
+VLAN interfaces *must* be added on top of a bonding interface only after
+enslaving at least one slave. This is because until the first slave is added the
+bonding interface has a HW address of 00:00:00:00:00:00, which will be copied by
+the VLAN interface when it is created.
+
+Notice that a problem would occur if all slaves are released from a bond that
+still has VLAN interfaces on top of it. When later coming to add new slaves, the
+bonding interface would get a HW address from the first slave, which might not
+match that of the VLAN interfaces. It is recommended that either all VLANs are
+removed and then re-added, or to manually set the bonding interface's HW
+address so it matches the VLAN's. (Note: changing a VLAN interface's HW address
+would set the underlying device -- i.e. the bonding interface -- to promiscouos
+mode, which might not be what you want).
+
+
 Limitations
 ===========
 The main limitations are :
@@ -824,12 +974,8 @@ The main limitations are :
     servers, but may be useful when the front switches send multicast
     information on their links (e.g. VRRP), or even health-check the servers.
     Use the arp_interval/arp_ip_target parameters to count incoming/outgoing
-    frames.  
+    frames.
 
-  - A Transmit Load Balancing policy is not currently available. This mode 
-    allows every slave in the bond to transmit while only one receives. If 
-    the "receiving" slave fails, another slave takes over the MAC address of 
-    the failed receiving slave.
 
 
 Resources and Links
@@ -844,13 +990,12 @@ Donald Becker's Ethernet Drivers and dia
 You will also find a lot of information regarding Ethernet, NWay, MII, etc. at
 www.scyld.com.
 
-For new versions of the driver, patches for older kernels and the updated
-userspace tools, take a look at Willy Tarreau's site :
+Patches for 2.2 kernels are at Willy Tarreau's site :
  - http://wtarreau.free.fr/pub/bonding/
- - http://www-miaif.lip6.fr/willy/pub/bonding/
+ - http://www-miaif.lip6.fr/~tarreau/pub/bonding/
 
 To get latest informations about Linux Kernel development, please consult
 the Linux Kernel Mailing List Archives at :
-   http://boudicca.tux.org/hypermail/linux-kernel/latest/
+   http://www.ussg.iu.edu/hypermail/linux/kernel/
 
 -- END --
diff -urNp linux-8120/Documentation/networking/ifenslave.c linux-8121/Documentation/networking/ifenslave.c
--- linux-8120/Documentation/networking/ifenslave.c
+++ linux-8121/Documentation/networking/ifenslave.c
@@ -27,7 +27,7 @@
  *    - 2001/02/16 Chad N. Tindel <ctindel at ieee dot org> :
  *       - Master is now brought down before setting the MAC address.  In
  *         the 2.4 kernel you can't change the MAC address while the device is
- *         up because you get EBUSY.  
+ *         up because you get EBUSY.
  *
  *    - 2001/09/13 Takao Indoh <indou dot takao at jp dot fujitsu dot com>
  *       - Added the ability to change the active interface on a mode 1 bond
@@ -44,17 +44,60 @@
  *
  *    - 2002/10/31 Tony Cureington <tony.cureington * hp_com> :
  *       - If the master does not have a hardware address when the first slave
- *         is enslaved, the master is assigned the hardware address of that 
- *         slave - there is a comment in bonding.c stating "ifenslave takes 
- *         care of this now." This corrects the problem of slaves having 
- *         different hardware addresses in active-backup mode when 
+ *         is enslaved, the master is assigned the hardware address of that
+ *         slave - there is a comment in bonding.c stating "ifenslave takes
+ *         care of this now." This corrects the problem of slaves having
+ *         different hardware addresses in active-backup mode when
  *         multiple interfaces are specified on a single ifenslave command
  *         (ifenslave bond0 eth0 eth1).
  *
+ *    - 2003/03/18 - Tsippy Mendelson <tsippy.mendelson at intel dot com> and
+ *                   Shmulik Hen <shmulik.hen at intel dot com>
+ *       - Moved setting the slave's mac address and openning it, from
+ *         the application to the driver. This enables support of modes
+ *         that need to use the unique mac address of each slave.
+ *         The driver also takes care of closing the slave and restoring its
+ *         original mac address upon release.
+ *         In addition, block possibility of enslaving before the master is up.
+ *         This prevents putting the system in an undefined state.
+ *
+ *    - 2003/05/01 - Amir Noam <amir.noam at intel dot com>
+ *       - Added ABI version control to restore compatibility between
+ *         new/old ifenslave and new/old bonding.
+ *       - Prevent adding an adapter that is already a slave.
+ *         Fixes the problem of stalling the transmission and leaving
+ *         the slave in a down state.
+ *
+ *    - 2003/05/01 - Shmulik Hen <shmulik.hen at intel dot com>
+ *       - Prevent enslaving if the bond device is down.
+ *         Fixes the problem of leaving the system in unstable state and
+ *         halting when trying to remove the module.
+ *       - Close socket on all abnormal exists.
+ *       - Add versioning scheme that follows that of the bonding driver.
+ *         current version is 1.0.0 as a base line.
+ *
+ *    - 2003/05/22 - Jay Vosburgh <fubar at us dot ibm dot com>
+ *	 - ifenslave -c was broken; it's now fixed
+ *	 - Fixed problem with routes vanishing from master during enslave
+ *	   processing.
+ *
+ *    - 2003/05/27 - Amir Noam <amir.noam at intel dot com>
+ *	 - Fix backward compatibility issues:
+ *	   For drivers not using ABI versions, slave was set down while
+ *	   it should be left up before enslaving.
+ *	   Also, master was not set down and the default set_mac_address()
+ *	   would fail and generate an error message in the system log.
+ * 	 - For opt_c: slave should not be set to the master's setting
+ *	   while it is running. It was already set during enslave. To
+ *	   simplify things, it is now handeled separately.
  */
 
+#define APP_VERSION	"1.0.12"
+#define APP_RELDATE	"June 30, 2003"
+#define APP_NAME	"ifenslave"
+
 static char *version =
-"ifenslave.c:v0.07 9/9/97  Donald Becker (becker@cesdis.gsfc.nasa.gov).\n"
+APP_NAME ".c:v" APP_VERSION " (" APP_RELDATE ") "  "\nDonald Becker (becker@cesdis.gsfc.nasa.gov).\n"
 "detach support added on 2000/10/02 by Willy Tarreau (willy at meta-x.org).\n"
 "2.4 kernel support added on 2001/02/16 by Chad N. Tindel (ctindel at ieee dot org.\n";
 
@@ -103,6 +146,12 @@ static const char *howto_msg =
 #include <linux/if_bonding.h>
 #include <linux/sockios.h>
 
+typedef unsigned long long u64;	/* hack, so we may include kernel's ethtool.h */
+typedef __uint32_t u32;		/* ditto */
+typedef __uint16_t u16;		/* ditto */
+typedef __uint8_t u8;		/* ditto */
+#include <linux/ethtool.h>
+
 struct option longopts[] = {
  /* { name  has_arg  *flag  val } */
     {"all-interfaces", 0, 0, 'a'},	/* Show all interfaces. */
@@ -130,18 +179,19 @@ opt_howto = 0;
 int skfd = -1;					/* AF_INET socket for ioctl() calls.	*/
 
 static void if_print(char *ifname);
+static int get_abi_ver(char *master_ifname);
 
 int
 main(int argc, char **argv)
 {
 	struct ifreq  ifr2, if_hwaddr, if_ipaddr, if_metric, if_mtu, if_dstaddr;
 	struct ifreq  if_netmask, if_brdaddr, if_flags;
-	int goterr = 0;
+	int rv, goterr = 0;
 	int c, errflag = 0;
 	sa_family_t master_family;
 	char **spp, *master_ifname, *slave_ifname;
 	int hwaddr_notset;
-	int master_up;
+	int abi_ver = 0;
 
 	while ((c = getopt_long(argc, argv, "acdfrvV?h", longopts, 0)) != EOF)
 		switch (c) {
@@ -207,6 +257,7 @@ main(int argc, char **argv)
 		char **tempp = spp;
 		if ((master_ifname == NULL)||(slave_ifname == NULL)||(*tempp++ != NULL)) {
 			fprintf(stderr, usage_msg);
+			(void) close(skfd);
 			return 2;
 		}
 	}
@@ -218,6 +269,13 @@ main(int argc, char **argv)
 		exit(0);
 	}
 
+	/* exchange abi version with bonding driver */
+	abi_ver = get_abi_ver(master_ifname);
+	if (abi_ver < 0) {
+		(void) close(skfd);
+		exit(1);
+	}
+
 	/* Get the vitals from the master interface. */
 	{
 		struct ifreq *ifra[7] = { &if_ipaddr, &if_mtu, &if_dstaddr,
@@ -242,6 +300,13 @@ main(int argc, char **argv)
 			}
 		}
 
+		/* check if master is up; if not then fail any operation */
+		if (!(if_flags.ifr_flags & IFF_UP)) {
+			fprintf(stderr, "Illegal operation; the specified master interface '%s' is not up.\n", master_ifname);
+			(void) close(skfd);
+			exit (1);
+		}
+
 		hwaddr_notset = 1; /* assume master's address not set yet */
 		for (i = 0; hwaddr_notset && (i < 6); i++) {
 			hwaddr_notset &= ((unsigned char *)if_hwaddr.ifr_hwaddr.sa_data)[i] == 0;
@@ -254,7 +319,7 @@ main(int argc, char **argv)
 					" with ethernet-like network interfaces.\n"
 					" Use the '-f' option to force the operation.\n",
 					master_ifname);
-
+			(void) close(skfd);
 			exit (1);
 		}
 		master_family = if_hwaddr.ifr_hwaddr.sa_family;
@@ -278,143 +343,153 @@ main(int argc, char **argv)
 					fprintf(stderr,	"SIOCBONDRELEASE: cannot detach %s from %s. errno=%s.\n",
 							slave_ifname, master_ifname, strerror(errno));
 			}
-			else {  /* we'll set the interface down to avoid any conflicts due to
-					   same IP/MAC */
+			else if (abi_ver < 1) {
+			      	/* The driver is using an old ABI, so we'll set the interface
+				 * down to avoid any conflicts due to same IP/MAC
+				 */
 				strncpy(ifr2.ifr_name, slave_ifname, IFNAMSIZ);
 				if (ioctl(skfd, SIOCGIFFLAGS, &ifr2) < 0) {
 					int saved_errno = errno;
 					fprintf(stderr, "SIOCGIFFLAGS on %s failed: %s\n", slave_ifname,
-							strerror(saved_errno));
+						strerror(saved_errno));
 				}
 				else {
 					ifr2.ifr_flags &= ~(IFF_UP | IFF_RUNNING);
 					if (ioctl(skfd, SIOCSIFFLAGS, &ifr2) < 0) {
 						int saved_errno = errno;
 						fprintf(stderr, "Shutting down interface %s failed: %s\n",
-								slave_ifname, strerror(saved_errno));
+							slave_ifname, strerror(saved_errno));
 					}
 				}
 			}
-		}
-		else {  /* attach a slave interface to the master */
-			/* two possibilities :
-			   - if hwaddr_notset, do nothing.  The bond will assign the
-			     hwaddr from it's first slave.
-			   - if !hwaddr_notset, assign the master's hwaddr to each slave
-			*/
+		} else if (opt_c) { /* change primary slave */
+			strncpy(if_flags.ifr_name, master_ifname, IFNAMSIZ);
+			strncpy(if_flags.ifr_slave, slave_ifname, IFNAMSIZ);
+			if ((ioctl(skfd, SIOCBONDCHANGEACTIVE, &if_flags) < 0) &&
+			    (ioctl(skfd, BOND_CHANGE_ACTIVE_OLD, &if_flags) < 0)) {
+				fprintf(stderr,	"SIOCBONDCHANGEACTIVE: %s.\n", strerror(errno));
+			}
+		} else {  /* attach a slave interface to the master */
 
 			strncpy(ifr2.ifr_name, slave_ifname, IFNAMSIZ);
 			if (ioctl(skfd, SIOCGIFFLAGS, &ifr2) < 0) {
 				int saved_errno = errno;
 				fprintf(stderr, "SIOCGIFFLAGS on %s failed: %s\n", slave_ifname,
 						strerror(saved_errno));
+				(void) close(skfd);
 				return 1;
 			}
 
+			if ((ifr2.ifr_flags & IFF_SLAVE) && !opt_r) {
+				fprintf(stderr, "%s is already a slave\n", slave_ifname);
+				(void) close(skfd);
+				return 1;
+			}
+
+			/* if hwaddr_notset, assign the slave hw address to the master */
 			if (hwaddr_notset) {
-				/* assign the slave hw address to the 
-				 * master since it currently does not 
+				/* assign the slave hw address to the
+				 * master since it currently does not
 				 * have one; otherwise, slaves may
-				 * have different hw addresses in 
-				 * active-backup mode as seen when enslaving 
+				 * have different hw addresses in
+				 * active-backup mode as seen when enslaving
 				 * using "ifenslave bond0 eth0 eth1" because
 				 * hwaddr_notset is set outside this loop.
 				 * TODO: put this and the "else" portion in
 				 *       a function.
 				 */
-				goterr = 0;
-				master_up = 0;
-				if (if_flags.ifr_flags & IFF_UP) {
-					if_flags.ifr_flags &= ~IFF_UP;
-					if (ioctl(skfd, SIOCSIFFLAGS, 
-							&if_flags) < 0) {
-						goterr = 1;
-						fprintf(stderr, 
-							"Shutting down "
-							"interface %s failed: "
-							"%s\n",
-							master_ifname, 
-							strerror(errno));
-					} else {
-						/* we took the master down, 
-						 * so we must bring it up 
-						 */
-						master_up = 1; 
-					}
+				/* get the slaves MAC address */
+				strncpy(if_hwaddr.ifr_name, slave_ifname,
+					IFNAMSIZ);
+				rv = ioctl(skfd, SIOCGIFHWADDR, &if_hwaddr);
+				if (-1 == rv) {
+					fprintf(stderr, "Could not get MAC "
+						"address of %s: %s\n",
+						slave_ifname,
+						strerror(errno));
+					strncpy(if_hwaddr.ifr_name,
+						master_ifname, IFNAMSIZ);
+					goterr = 1;
 				}
 
 				if (!goterr) {
-					/* get the slaves MAC address */
-					strncpy(if_hwaddr.ifr_name, 
-							slave_ifname, IFNAMSIZ);
-					if (ioctl(skfd, SIOCGIFHWADDR, 
-							&if_hwaddr) < 0) {
-						fprintf(stderr, 
-							"Could not get MAC "
-							"address of %s: %s\n",
-							slave_ifname, 
-							strerror(errno));
-						strncpy(if_hwaddr.ifr_name, 
-							master_ifname, 
-							IFNAMSIZ);
-						goterr=1;
+					if (abi_ver < 1) {
+						/* In ABI versions older than 1, the
+						 * master's set_mac routine couldn't
+						 * work if it was up, because it
+						 * used the default ethernet set_mac
+						 * function.
+						 */
+						/* bring master down */
+						if_flags.ifr_flags &= ~IFF_UP;
+						if (ioctl(skfd, SIOCSIFFLAGS,
+								&if_flags) < 0) {
+							goterr = 1;
+							fprintf(stderr,
+								"Shutting down "
+								"interface %s failed: "
+								"%s\n",
+								master_ifname,
+								strerror(errno));
+						}
 					}
-				}
 
-				if (!goterr) {
-					strncpy(if_hwaddr.ifr_name, 
+					strncpy(if_hwaddr.ifr_name,
 						master_ifname, IFNAMSIZ);
-					if (ioctl(skfd, SIOCSIFHWADDR, 
+					if (ioctl(skfd, SIOCSIFHWADDR,
 							&if_hwaddr) < 0) {
-						fprintf(stderr, 
+						fprintf(stderr,
 							"Could not set MAC "
 							"address of %s: %s\n",
-							master_ifname, 
+							master_ifname,
 							strerror(errno));
 						goterr=1;
 					} else {
 						hwaddr_notset = 0;
 					}
-				}
 
-				if (master_up) {
-					if_flags.ifr_flags |= IFF_UP;
-					if (ioctl(skfd, SIOCSIFFLAGS, 
-							&if_flags) < 0) {
-						fprintf(stderr, 
-							"Bringing up interface "
-							"%s failed: %s\n",
-							master_ifname, 
-							strerror(errno));
+					if (abi_ver < 1) {
+						/* bring master back up */
+						if_flags.ifr_flags |= IFF_UP;
+						if (ioctl(skfd, SIOCSIFFLAGS,
+							  &if_flags) < 0) {
+							fprintf(stderr,
+								"Bringing up interface "
+								"%s failed: %s\n",
+								master_ifname,
+								strerror(errno));
+						}
 					}
 				}
+			} else if (abi_ver < 1) { /* if (hwaddr_notset) */
 
-			} else {  
-				/* we'll assign master's hwaddr to this slave */
+			      	/* The driver is using an old ABI, so we'll set the interface
+				 * down and assign the master's hwaddr to it
+				 */
 				if (ifr2.ifr_flags & IFF_UP) {
 					ifr2.ifr_flags &= ~IFF_UP;
 					if (ioctl(skfd, SIOCSIFFLAGS, &ifr2) < 0) {
 						int saved_errno = errno;
 						fprintf(stderr, "Shutting down interface %s failed: %s\n",
-								slave_ifname, strerror(saved_errno));
+							slave_ifname, strerror(saved_errno));
 					}
 				}
-	
+
 				strncpy(if_hwaddr.ifr_name, slave_ifname, IFNAMSIZ);
 				if (ioctl(skfd, SIOCSIFHWADDR, &if_hwaddr) < 0) {
 					int saved_errno = errno;
 					fprintf(stderr, "SIOCSIFHWADDR on %s failed: %s\n", if_hwaddr.ifr_name,
-							strerror(saved_errno));
+						strerror(saved_errno));
 					if (saved_errno == EBUSY)
 						fprintf(stderr, "  The slave device %s is busy: it must be"
-								" idle before running this command.\n", slave_ifname);
+							" idle before running this command.\n", slave_ifname);
 					else if (saved_errno == EOPNOTSUPP)
 						fprintf(stderr, "  The slave device you specified does not support"
-								" setting the MAC address.\n  Your kernel likely does not"
-								" support slave devices.\n");
+							" setting the MAC address.\n  Your kernel likely does not"
+							" support slave devices.\n");
 					else if (saved_errno == EINVAL)
 						fprintf(stderr, "  The slave device's address type does not match"
-								" the master's address type.\n");
+							" the master's address type.\n");
 				} else {
 					if (verbose) {
 						unsigned char *hwaddr = if_hwaddr.ifr_hwaddr.sa_data;
@@ -424,10 +499,11 @@ main(int argc, char **argv)
 					}
 				}
 			}
-	
+
 			if (*spp  &&  !strcmp(*spp, "metric")) {
 				if (*++spp == NULL) {
 					fprintf(stderr, usage_msg);
+					(void) close(skfd);
 					exit(2);
 				}
 				if_metric.ifr_metric = atoi(*spp);
@@ -439,7 +515,7 @@ main(int argc, char **argv)
 				}
 				spp++;
 			}
-	
+
 			if (strncpy(if_ipaddr.ifr_name, slave_ifname, IFNAMSIZ) <= 0
 				|| ioctl(skfd, SIOCSIFADDR, &if_ipaddr) < 0) {
 				fprintf(stderr,
@@ -452,16 +528,16 @@ main(int argc, char **argv)
 						   slave_ifname, ipaddr[0], ipaddr[1], ipaddr[2], ipaddr[3]);
 				}
 			}
-	
+
 			if (strncpy(if_mtu.ifr_name, slave_ifname, IFNAMSIZ) <= 0
-				|| ioctl(skfd, SIOCSIFMTU, &if_mtu) < 0) { 
+				|| ioctl(skfd, SIOCSIFMTU, &if_mtu) < 0) {
 				fprintf(stderr, "Something broke setting the slave MTU: %s.\n",
 						strerror(errno));
 			} else {
 				if (verbose)
 					printf("Set the slave's (%s) MTU to %d.\n", slave_ifname, if_mtu.ifr_mtu);
 			}
-	
+
 			if (strncpy(if_dstaddr.ifr_name, slave_ifname, IFNAMSIZ) <= 0
 				|| ioctl(skfd, SIOCSIFDSTADDR, &if_dstaddr) < 0) {
 				fprintf(stderr, "Error setting the slave (%s) with SIOCSIFDSTADDR: %s.\n",
@@ -473,7 +549,7 @@ main(int argc, char **argv)
 						   slave_ifname, ipaddr[0], ipaddr[1], ipaddr[2], ipaddr[3]);
 				}
 			}
-	
+
 			if (strncpy(if_brdaddr.ifr_name, slave_ifname, IFNAMSIZ) <= 0
 				|| ioctl(skfd, SIOCSIFBRDADDR, &if_brdaddr) < 0) {
 				fprintf(stderr,
@@ -486,7 +562,7 @@ main(int argc, char **argv)
 						   slave_ifname, ipaddr[0], ipaddr[1], ipaddr[2], ipaddr[3]);
 				}
 			}
-			
+
 			if (strncpy(if_netmask.ifr_name, slave_ifname, IFNAMSIZ) <= 0
 				|| ioctl(skfd, SIOCSIFNETMASK, &if_netmask) < 0) {
 				fprintf(stderr,
@@ -499,34 +575,45 @@ main(int argc, char **argv)
 						   slave_ifname, ipaddr[0], ipaddr[1], ipaddr[2], ipaddr[3]);
 				}
 			}
-			
-			ifr2.ifr_flags |= IFF_UP; /* the interface will need to be up to be bonded */
-			if ((ifr2.ifr_flags &= ~(IFF_SLAVE | IFF_MASTER)) == 0
-				|| strncpy(ifr2.ifr_name, slave_ifname, IFNAMSIZ) <= 0
-				|| ioctl(skfd, SIOCSIFFLAGS, &ifr2) < 0) {
-				fprintf(stderr,
-						"Something broke setting the slave (%s) flags: %s.\n",
-						slave_ifname, strerror(errno));
+
+			if (abi_ver < 1) {
+
+			      	/* The driver is using an old ABI, so we'll set the interface
+				 * up before enslaving it
+				 */
+				ifr2.ifr_flags |= IFF_UP;
+				if ((ifr2.ifr_flags &= ~(IFF_SLAVE | IFF_MASTER)) == 0
+					|| strncpy(ifr2.ifr_name, slave_ifname, IFNAMSIZ) <= 0
+					|| ioctl(skfd, SIOCSIFFLAGS, &ifr2) < 0) {
+						fprintf(stderr,
+							"Something broke setting the slave (%s) flags: %s.\n",
+							slave_ifname, strerror(errno));
+				} else {
+					if (verbose)
+						printf("Set the slave's (%s) flags %4.4x.\n",
+							slave_ifname, if_flags.ifr_flags);
+				}
 			} else {
-				if (verbose)
-					printf("Set the slave's (%s) flags %4.4x.\n", slave_ifname, if_flags.ifr_flags);
+				/* the bonding module takes care of setting the slave's mac address
+			 	 * and opening its interface
+			 	 */
+				if (ifr2.ifr_flags & IFF_UP) { /* the interface will need to be down */
+					ifr2.ifr_flags &= ~IFF_UP;
+					if (ioctl(skfd, SIOCSIFFLAGS, &ifr2) < 0) {
+						int saved_errno = errno;
+						fprintf(stderr, "Shutting down interface %s failed: %s\n",
+							slave_ifname, strerror(saved_errno));
+					}
+				}
 			}
-	
+
 			/* Do the real thing */
-			if ( ! opt_r) {
+			if (!opt_r) {
 				strncpy(if_flags.ifr_name, master_ifname, IFNAMSIZ);
 				strncpy(if_flags.ifr_slave, slave_ifname, IFNAMSIZ);
-				if (!opt_c) {
-					if ((ioctl(skfd, SIOCBONDENSLAVE, &if_flags) < 0) &&
-					    (ioctl(skfd, BOND_ENSLAVE_OLD, &if_flags) < 0)) {
-						fprintf(stderr,	"SIOCBONDENSLAVE: %s.\n", strerror(errno));
-					}
-				}
-				else {
-					if ((ioctl(skfd, SIOCBONDCHANGEACTIVE, &if_flags) < 0) &&
-					    (ioctl(skfd, BOND_CHANGE_ACTIVE_OLD, &if_flags) < 0)) {
-						fprintf(stderr,	"SIOCBONDCHANGEACTIVE: %s.\n", strerror(errno));
-					}
+				if ((ioctl(skfd, SIOCBONDENSLAVE, &if_flags) < 0) &&
+				    (ioctl(skfd, BOND_ENSLAVE_OLD, &if_flags) < 0)) {
+					fprintf(stderr,	"SIOCBONDENSLAVE: %s.\n", strerror(errno));
 				}
 			}
 		}
@@ -639,7 +726,38 @@ static void if_print(char *ifname)
 	}
 }
 
-
+static int get_abi_ver(char *master_ifname)
+{
+	struct ifreq ifr;
+	struct ethtool_drvinfo info;
+	int abi_ver = 0;
+
+	memset(&ifr, 0, sizeof(ifr));
+	strncpy(ifr.ifr_name, master_ifname, IFNAMSIZ);
+	ifr.ifr_data = (caddr_t)&info;
+
+	info.cmd = ETHTOOL_GDRVINFO;
+	strncpy(info.driver, "ifenslave", 32);
+	snprintf(info.fw_version, 32, "%d", BOND_ABI_VERSION);
+	if (ioctl(skfd, SIOCETHTOOL, &ifr) >= 0) {
+		char *endptr;
+
+		abi_ver = strtoul(info.fw_version, &endptr, 0);
+		if (*endptr) {
+			fprintf(stderr, "Error: got invalid string as an ABI "
+				"version from the bonding module\n");
+			return -1;
+		}
+	}
+
+	if (verbose) {
+        	printf("ABI ver is %d\n", abi_ver);
+	}
+	return abi_ver;
+}
+
+
+
 /*
  * Local variables:
  *  version-control: t
diff -urNp linux-8120/drivers/net/Makefile linux-8121/drivers/net/Makefile
--- linux-8120/drivers/net/Makefile
+++ linux-8121/drivers/net/Makefile
@@ -29,6 +29,10 @@ ifeq ($(CONFIG_E1000),y)
   obj-y += e1000/e1000.o
 endif
 
+ifeq ($(CONFIG_BONDING),y)
+  obj-y += bonding/bonding.o
+endif
+
 ifeq ($(CONFIG_ISDN_PPP),y)
   obj-$(CONFIG_ISDN) += slhc.o
 endif
@@ -46,6 +50,7 @@ subdir-$(CONFIG_SK98LIN) += sk98lin
 subdir-$(CONFIG_SKFP) += skfp
 subdir-$(CONFIG_E100) += e100
 subdir-$(CONFIG_E1000) += e1000
+subdir-$(CONFIG_BONDING) += bonding
 
 #
 # link order important here
@@ -158,7 +163,6 @@ endif
 
 obj-$(CONFIG_STRIP) += strip.o
 obj-$(CONFIG_DUMMY) += dummy.o
-obj-$(CONFIG_BONDING) += bonding.o
 obj-$(CONFIG_DE600) += de600.o
 obj-$(CONFIG_DE620) += de620.o
 obj-$(CONFIG_AT1500) += lance.o
diff -urNp linux-8120/drivers/net/bonding/Makefile linux-8121/drivers/net/bonding/Makefile
--- linux-8120/drivers/net/bonding/Makefile
+++ linux-8121/drivers/net/bonding/Makefile
@@ -0,0 +1,14 @@
+#
+# Makefile for the Ethernet Bonding driver
+#
+
+O_TARGET := bonding.o
+
+obj-y	 := bond_main.o \
+            bond_3ad.o  \
+	    bond_alb.o
+
+obj-m	 := $(O_TARGET)
+
+include $(TOPDIR)/Rules.make
+
diff -urNp linux-8120/drivers/net/bonding/bond_3ad.c linux-8121/drivers/net/bonding/bond_3ad.c
--- linux-8120/drivers/net/bonding/bond_3ad.c
+++ linux-8121/drivers/net/bonding/bond_3ad.c
@@ -0,0 +1,2461 @@
+/*
+ * Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ *
+ * Changes:
+ *
+ * 2003/05/01 - Tsippy Mendelson <tsippy.mendelson at intel dot com> and
+ *		Amir Noam <amir.noam at intel dot com>
+ *	- Added support for lacp_rate module param.
+ *
+ * 2003/05/01 - Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Based on discussion on mailing list, changed locking scheme
+ *	  to use lock/unlock or lock_bh/unlock_bh appropriately instead
+ *	  of lock_irqsave/unlock_irqrestore. The new scheme helps exposing
+ *	  hidden bugs and solves system hangs that occurred due to the fact
+ *	  that holding lock_irqsave doesn't prevent softirqs from running.
+ *	  This also increases total throughput since interrupts are not
+ *	  blocked on each transmitted packets or monitor timeout.
+ *
+ * 2003/05/01 - Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Renamed bond_3ad_link_status_changed() to
+ *	  bond_3ad_handle_link_change() for compatibility with TLB.
+ *
+ * 2003/05/20 - Amir Noam <amir.noam at intel dot com>
+ *	- Fix long fail over time when releasing last slave of an active
+ *	  aggregator - send LACPDU on unbind of slave to tell partner this
+ *	  port is no longer aggregatable.
+ *
+ * 2003/06/25 - Tsippy Mendelson <tsippy.mendelson at intel dot com>
+ *	- Send LACPDU as highest priority packet to further fix the above
+ *	  problem on very high Tx traffic load where packets may get dropped
+ *	  by the slave.
+ *
+ * 2003/12/01 - Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Code cleanup and style changes
+ */
+
+//#define BONDING_DEBUG 1
+
+#include <linux/skbuff.h>
+#include <linux/if_ether.h>
+#include <linux/netdevice.h>
+#include <linux/spinlock.h>
+#include <linux/ethtool.h>
+#include <linux/if_bonding.h>
+#include <linux/pkt_sched.h>
+#include "bonding.h"
+#include "bond_3ad.h"
+
+// General definitions
+#define AD_SHORT_TIMEOUT           1
+#define AD_LONG_TIMEOUT            0
+#define AD_STANDBY                 0x2
+#define AD_MAX_TX_IN_SECOND        3
+#define AD_COLLECTOR_MAX_DELAY     0
+
+// Timer definitions(43.4.4 in the 802.3ad standard)
+#define AD_FAST_PERIODIC_TIME      1
+#define AD_SLOW_PERIODIC_TIME      30
+#define AD_SHORT_TIMEOUT_TIME      (3*AD_FAST_PERIODIC_TIME)
+#define AD_LONG_TIMEOUT_TIME       (3*AD_SLOW_PERIODIC_TIME)
+#define AD_CHURN_DETECTION_TIME    60
+#define AD_AGGREGATE_WAIT_TIME     2
+
+// Port state definitions(43.4.2.2 in the 802.3ad standard)
+#define AD_STATE_LACP_ACTIVITY   0x1
+#define AD_STATE_LACP_TIMEOUT    0x2
+#define AD_STATE_AGGREGATION     0x4
+#define AD_STATE_SYNCHRONIZATION 0x8
+#define AD_STATE_COLLECTING      0x10
+#define AD_STATE_DISTRIBUTING    0x20
+#define AD_STATE_DEFAULTED       0x40
+#define AD_STATE_EXPIRED         0x80
+
+// Port Variables definitions used by the State Machines(43.4.7 in the 802.3ad standard)
+#define AD_PORT_BEGIN           0x1
+#define AD_PORT_LACP_ENABLED    0x2
+#define AD_PORT_ACTOR_CHURN     0x4
+#define AD_PORT_PARTNER_CHURN   0x8
+#define AD_PORT_READY           0x10
+#define AD_PORT_READY_N         0x20
+#define AD_PORT_MATCHED         0x40
+#define AD_PORT_STANDBY         0x80
+#define AD_PORT_SELECTED        0x100
+#define AD_PORT_MOVED           0x200
+
+// Port Key definitions
+// key is determined according to the link speed, duplex and
+// user key(which is yet not supported)
+//              ------------------------------------------------------------
+// Port key :   | User key                       |      Speed       |Duplex|
+//              ------------------------------------------------------------
+//              16                               6               1 0
+#define  AD_DUPLEX_KEY_BITS    0x1
+#define  AD_SPEED_KEY_BITS     0x3E
+#define  AD_USER_KEY_BITS      0xFFC0
+
+//dalloun
+#define     AD_LINK_SPEED_BITMASK_1MBPS       0x1
+#define     AD_LINK_SPEED_BITMASK_10MBPS      0x2
+#define     AD_LINK_SPEED_BITMASK_100MBPS     0x4
+#define     AD_LINK_SPEED_BITMASK_1000MBPS    0x8
+//endalloun
+
+// compare MAC addresses
+#define MAC_ADDRESS_COMPARE(A, B) memcmp(A, B, ETH_ALEN)
+
+static struct mac_addr null_mac_addr = {{0, 0, 0, 0, 0, 0}};
+static u16 ad_ticks_per_sec;
+static const int ad_delta_in_ticks = (AD_TIMER_INTERVAL * HZ) / 1000;
+
+// ================= 3AD api to bonding and kernel code ==================
+static u16 __get_link_speed(struct port *port);
+static u8 __get_duplex(struct port *port);
+static inline void __initialize_port_locks(struct port *port);
+static inline void __deinitialize_port_locks(struct port *port);
+//conversions
+static void __ntohs_lacpdu(struct lacpdu *lacpdu);
+static u16 __ad_timer_to_ticks(u16 timer_type, u16 Par);
+
+
+// ================= ad code helper functions ==================
+//needed by ad_rx_machine(...)
+static void __record_pdu(struct lacpdu *lacpdu, struct port *port);
+static void __record_default(struct port *port);
+static void __update_selected(struct lacpdu *lacpdu, struct port *port);
+static void __update_default_selected(struct port *port);
+static void __choose_matched(struct lacpdu *lacpdu, struct port *port);
+static void __update_ntt(struct lacpdu *lacpdu, struct port *port);
+
+//needed for ad_mux_machine(..)
+static void __attach_bond_to_agg(struct port *port);
+static void __detach_bond_from_agg(struct port *port);
+static int __agg_ports_are_ready(struct aggregator *aggregator);
+static void __set_agg_ports_ready(struct aggregator *aggregator, int val);
+
+//needed for ad_agg_selection_logic(...)
+static u32 __get_agg_bandwidth(struct aggregator *aggregator);
+static struct aggregator *__get_active_agg(struct aggregator *aggregator);
+
+
+// ================= main 802.3ad protocol functions ==================
+static int ad_lacpdu_send(struct port *port);
+static int ad_marker_send(struct port *port, struct marker *marker);
+static void ad_mux_machine(struct port *port);
+static void ad_rx_machine(struct lacpdu *lacpdu, struct port *port);
+static void ad_tx_machine(struct port *port);
+static void ad_periodic_machine(struct port *port);
+static void ad_port_selection_logic(struct port *port);
+static void ad_agg_selection_logic(struct aggregator *aggregator);
+static void ad_clear_agg(struct aggregator *aggregator);
+static void ad_initialize_agg(struct aggregator *aggregator);
+static void ad_initialize_port(struct port *port, int lacp_fast);
+static void ad_initialize_lacpdu(struct lacpdu *Lacpdu);
+static void ad_enable_collecting_distributing(struct port *port);
+static void ad_disable_collecting_distributing(struct port *port);
+static void ad_marker_info_received(struct marker *marker_info, struct port *port);
+static void ad_marker_response_received(struct marker *marker, struct port *port);
+
+
+/////////////////////////////////////////////////////////////////////////////////
+// ================= api to bonding and kernel code ==================
+/////////////////////////////////////////////////////////////////////////////////
+
+/**
+ * __get_bond_by_port - get the port's bonding struct
+ * @port: the port we're looking at
+ *
+ * Return @port's bonding struct, or %NULL if it can't be found.
+ */
+static inline struct bonding *__get_bond_by_port(struct port *port)
+{
+	if (port->slave == NULL) {
+		return NULL;
+	}
+
+	return bond_get_bond_by_slave(port->slave);
+}
+
+/**
+ * __get_first_port - get the first port in the bond
+ * @bond: the bond we're looking at
+ *
+ * Return the port of the first slave in @bond, or %NULL if it can't be found.
+ */
+static inline struct port *__get_first_port(struct bonding *bond)
+{
+	if (bond->slave_cnt == 0) {
+		return NULL;
+	}
+
+	return &(SLAVE_AD_INFO(bond->first_slave).port);
+}
+
+/**
+ * __get_next_port - get the next port in the bond
+ * @port: the port we're looking at
+ *
+ * Return the port of the slave that is next in line of @port's slave in the
+ * bond, or %NULL if it can't be found.
+ */
+static inline struct port *__get_next_port(struct port *port)
+{
+	struct bonding *bond = __get_bond_by_port(port);
+	struct slave *slave = port->slave;
+
+	// If there's no bond for this port, or this is the last slave
+	if ((bond == NULL) || (slave->next == bond->first_slave)) {
+		return NULL;
+	}
+
+	return &(SLAVE_AD_INFO(slave->next).port);
+}
+
+/**
+ * __get_first_agg - get the first aggregator in the bond
+ * @bond: the bond we're looking at
+ *
+ * Return the aggregator of the first slave in @bond, or %NULL if it can't be
+ * found.
+ */
+static inline struct aggregator *__get_first_agg(struct port *port)
+{
+	struct bonding *bond = __get_bond_by_port(port);
+
+	// If there's no bond for this port, or bond has no slaves
+	if ((bond == NULL) || (bond->slave_cnt == 0)) {
+		return NULL;
+	}
+
+	return &(SLAVE_AD_INFO(bond->first_slave).aggregator);
+}
+
+/**
+ * __get_next_agg - get the next aggregator in the bond
+ * @aggregator: the aggregator we're looking at
+ *
+ * Return the aggregator of the slave that is next in line of @aggregator's
+ * slave in the bond, or %NULL if it can't be found.
+ */
+static inline struct aggregator *__get_next_agg(struct aggregator *aggregator)
+{
+	struct slave *slave = aggregator->slave;
+	struct bonding *bond = bond_get_bond_by_slave(slave);
+
+	// If there's no bond for this aggregator, or this is the last slave
+	if ((bond == NULL) || (slave->next == bond->first_slave)) {
+		return NULL;
+	}
+
+	return &(SLAVE_AD_INFO(slave->next).aggregator);
+}
+
+/**
+ * __disable_port - disable the port's slave
+ * @port: the port we're looking at
+ *
+ */
+static inline void __disable_port(struct port *port)
+{
+	bond_set_slave_inactive_flags(port->slave);
+}
+
+/**
+ * __enable_port - enable the port's slave, if it's up
+ * @port: the port we're looking at
+ *
+ */
+static inline void __enable_port(struct port *port)
+{
+	struct slave *slave = port->slave;
+
+	if ((slave->link == BOND_LINK_UP) && IS_UP(slave->dev)) {
+		bond_set_slave_active_flags(slave);
+	}
+}
+
+/**
+ * __port_is_enabled - check if the port's slave is in active state
+ * @port: the port we're looking at
+ *
+ */
+static inline int __port_is_enabled(struct port *port)
+{
+	return(port->slave->state == BOND_STATE_ACTIVE);
+}
+
+/**
+ * __get_agg_selection_mode - get the aggregator selection mode
+ * @port: the port we're looking at
+ *
+ * Get the aggregator selection mode. Can be %BANDWIDTH or %COUNT.
+ */
+static inline u32 __get_agg_selection_mode(struct port *port)
+{
+	struct bonding *bond = __get_bond_by_port(port);
+
+	if (bond == NULL) {
+		return AD_BANDWIDTH;
+	}
+
+	return BOND_AD_INFO(bond).agg_select_mode;
+}
+
+/**
+ * __check_agg_selection_timer - check if the selection timer has expired
+ * @port: the port we're looking at
+ *
+ */
+static inline int __check_agg_selection_timer(struct port *port)
+{
+	struct bonding *bond = __get_bond_by_port(port);
+
+	if (bond == NULL) {
+		return 0;
+	}
+
+	return BOND_AD_INFO(bond).agg_select_timer ? 1 : 0;
+}
+
+/**
+ * __get_rx_machine_lock - lock the port's RX machine
+ * @port: the port we're looking at
+ *
+ */
+static inline void __get_rx_machine_lock(struct port *port)
+{
+	spin_lock(&(SLAVE_AD_INFO(port->slave).rx_machine_lock));
+}
+
+/**
+ * __release_rx_machine_lock - unlock the port's RX machine
+ * @port: the port we're looking at
+ *
+ */
+static inline void __release_rx_machine_lock(struct port *port)
+{
+	spin_unlock(&(SLAVE_AD_INFO(port->slave).rx_machine_lock));
+}
+
+/**
+ * __get_link_speed - get a port's speed
+ * @port: the port we're looking at
+ *
+ * Return @port's speed in 802.3ad bitmask format. i.e. one of:
+ *     0,
+ *     %AD_LINK_SPEED_BITMASK_10MBPS,
+ *     %AD_LINK_SPEED_BITMASK_100MBPS,
+ *     %AD_LINK_SPEED_BITMASK_1000MBPS
+ */
+static u16 __get_link_speed(struct port *port)
+{
+	struct slave *slave = port->slave;
+	u16 speed;
+
+	/* this if covers only a special case: when the configuration starts with
+	 * link down, it sets the speed to 0.
+	 * This is done in spite of the fact that the e100 driver reports 0 to be
+	 * compatible with MVT in the future.*/
+	if (slave->link != BOND_LINK_UP) {
+		speed=0;
+	} else {
+		switch (slave->speed) {
+		case SPEED_10:
+			speed = AD_LINK_SPEED_BITMASK_10MBPS;
+			break;
+
+		case SPEED_100:
+			speed = AD_LINK_SPEED_BITMASK_100MBPS;
+			break;
+
+		case SPEED_1000:
+			speed = AD_LINK_SPEED_BITMASK_1000MBPS;
+			break;
+
+		default:
+			speed = 0; // unknown speed value from ethtool. shouldn't happen
+			break;
+		}
+	}
+
+	dprintk("Port %d Received link speed %d update from adapter\n", port->actor_port_number, speed);
+	return speed;
+}
+
+/**
+ * __get_duplex - get a port's duplex
+ * @port: the port we're looking at
+ *
+ * Return @port's duplex in 802.3ad bitmask format. i.e.:
+ *     0x01 if in full duplex
+ *     0x00 otherwise
+ */
+static u8 __get_duplex(struct port *port)
+{
+	struct slave *slave = port->slave;
+
+	u8 retval;
+
+	//  handling a special case: when the configuration starts with
+	// link down, it sets the duplex to 0.
+	if (slave->link != BOND_LINK_UP) {
+		retval=0x0;
+	} else {
+		switch (slave->duplex) {
+		case DUPLEX_FULL:
+			retval=0x1;
+			dprintk("Port %d Received status full duplex update from adapter\n", port->actor_port_number);
+			break;
+		case DUPLEX_HALF:
+		default:
+			retval=0x0;
+			dprintk("Port %d Received status NOT full duplex update from adapter\n", port->actor_port_number);
+			break;
+		}
+	}
+	return retval;
+}
+
+/**
+ * __initialize_port_locks - initialize a port's RX machine spinlock
+ * @port: the port we're looking at
+ *
+ */
+static inline void __initialize_port_locks(struct port *port)
+{
+	// make sure it isn't called twice
+	spin_lock_init(&(SLAVE_AD_INFO(port->slave).rx_machine_lock));
+}
+
+/**
+ * __deinitialize_port_locks - deinitialize a port's RX machine spinlock
+ * @port: the port we're looking at
+ *
+ */
+static inline void __deinitialize_port_locks(struct port *port)
+{
+}
+
+//conversions
+/**
+ * __ntohs_lacpdu - convert the contents of a LACPDU to host byte order
+ * @lacpdu: the speicifed lacpdu
+ *
+ * For each multi-byte field in the lacpdu, convert its content
+ */
+static void __ntohs_lacpdu(struct lacpdu *lacpdu)
+{
+	if (lacpdu) {
+		lacpdu->actor_system_priority =   ntohs(lacpdu->actor_system_priority);
+		lacpdu->actor_key =               ntohs(lacpdu->actor_key);
+		lacpdu->actor_port_priority =     ntohs(lacpdu->actor_port_priority);
+		lacpdu->actor_port =              ntohs(lacpdu->actor_port);
+		lacpdu->partner_system_priority = ntohs(lacpdu->partner_system_priority);
+		lacpdu->partner_key =             ntohs(lacpdu->partner_key);
+		lacpdu->partner_port_priority =   ntohs(lacpdu->partner_port_priority);
+		lacpdu->partner_port =            ntohs(lacpdu->partner_port);
+		lacpdu->collector_max_delay =     ntohs(lacpdu->collector_max_delay);
+	}
+}
+
+/**
+ * __ad_timer_to_ticks - convert a given timer type to AD module ticks
+ * @timer_type:	which timer to operate
+ * @par: timer parameter. see below
+ *
+ * If @timer_type is %current_while_timer, @par indicates long/short timer.
+ * If @timer_type is %periodic_timer, @par is one of %FAST_PERIODIC_TIME,
+ *						    %SLOW_PERIODIC_TIME.
+ */
+static u16 __ad_timer_to_ticks(u16 timer_type, u16 par)
+{
+	u16 retval=0;	 //to silence the compiler
+
+	switch (timer_type) {
+	case AD_CURRENT_WHILE_TIMER:   // for rx machine usage
+		if (par) {	      // for short or long timeout
+			retval = (AD_SHORT_TIMEOUT_TIME*ad_ticks_per_sec); // short timeout
+		} else {
+			retval = (AD_LONG_TIMEOUT_TIME*ad_ticks_per_sec); // long timeout
+		}
+		break;
+	case AD_ACTOR_CHURN_TIMER:	    // for local churn machine
+		retval = (AD_CHURN_DETECTION_TIME*ad_ticks_per_sec);
+		break;
+	case AD_PERIODIC_TIMER:	    // for periodic machine
+		retval = (par*ad_ticks_per_sec); // long timeout
+		break;
+	case AD_PARTNER_CHURN_TIMER:   // for remote churn machine
+		retval = (AD_CHURN_DETECTION_TIME*ad_ticks_per_sec);
+		break;
+	case AD_WAIT_WHILE_TIMER:	    // for selection machine
+		retval = (AD_AGGREGATE_WAIT_TIME*ad_ticks_per_sec);
+		break;
+	}
+	return retval;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////////
+// ================= ad_rx_machine helper functions ==================
+/////////////////////////////////////////////////////////////////////////////////
+
+/**
+ * __record_pdu - record parameters from a received lacpdu
+ * @lacpdu: the lacpdu we've received
+ * @port: the port we're looking at
+ *
+ * Record the parameter values for the Actor carried in a received lacpdu as
+ * the current partner operational parameter values and sets
+ * actor_oper_port_state.defaulted to FALSE.
+ */
+static void __record_pdu(struct lacpdu *lacpdu, struct port *port)
+{
+	// validate lacpdu and port
+	if (lacpdu && port) {
+		// record the new parameter values for the partner operational
+		port->partner_oper_port_number = lacpdu->actor_port;
+		port->partner_oper_port_priority = lacpdu->actor_port_priority;
+		port->partner_oper_system = lacpdu->actor_system;
+		port->partner_oper_system_priority = lacpdu->actor_system_priority;
+		port->partner_oper_key = lacpdu->actor_key;
+		// zero partener's lase states
+		port->partner_oper_port_state = 0;
+		port->partner_oper_port_state |= (lacpdu->actor_state & AD_STATE_LACP_ACTIVITY);
+		port->partner_oper_port_state |= (lacpdu->actor_state & AD_STATE_LACP_TIMEOUT);
+		port->partner_oper_port_state |= (lacpdu->actor_state & AD_STATE_AGGREGATION);
+		port->partner_oper_port_state |= (lacpdu->actor_state & AD_STATE_SYNCHRONIZATION);
+		port->partner_oper_port_state |= (lacpdu->actor_state & AD_STATE_COLLECTING);
+		port->partner_oper_port_state |= (lacpdu->actor_state & AD_STATE_DISTRIBUTING);
+		port->partner_oper_port_state |= (lacpdu->actor_state & AD_STATE_DEFAULTED);
+		port->partner_oper_port_state |= (lacpdu->actor_state & AD_STATE_EXPIRED);
+
+		// set actor_oper_port_state.defaulted to FALSE
+		port->actor_oper_port_state &= ~AD_STATE_DEFAULTED;
+
+		// set the partner sync. to on if the partner is sync. and the port is matched
+		if ((port->sm_vars & AD_PORT_MATCHED) && (lacpdu->actor_state & AD_STATE_SYNCHRONIZATION)) {
+			port->partner_oper_port_state |= AD_STATE_SYNCHRONIZATION;
+		} else {
+			port->partner_oper_port_state &= ~AD_STATE_SYNCHRONIZATION;
+		}
+	}
+}
+
+/**
+ * __record_default - record default parameters
+ * @port: the port we're looking at
+ *
+ * This function records the default parameter values for the partner carried
+ * in the Partner Admin parameters as the current partner operational parameter
+ * values and sets actor_oper_port_state.defaulted to TRUE.
+ */
+static void __record_default(struct port *port)
+{
+	// validate the port
+	if (port) {
+		// record the partner admin parameters
+		port->partner_oper_port_number = port->partner_admin_port_number;
+		port->partner_oper_port_priority = port->partner_admin_port_priority;
+		port->partner_oper_system = port->partner_admin_system;
+		port->partner_oper_system_priority = port->partner_admin_system_priority;
+		port->partner_oper_key = port->partner_admin_key;
+		port->partner_oper_port_state = port->partner_admin_port_state;
+
+		// set actor_oper_port_state.defaulted to true
+		port->actor_oper_port_state |= AD_STATE_DEFAULTED;
+	}
+}
+
+/**
+ * __update_selected - update a port's Selected variable from a received lacpdu
+ * @lacpdu: the lacpdu we've received
+ * @port: the port we're looking at
+ *
+ * Update the value of the selected variable, using parameter values from a
+ * newly received lacpdu. The parameter values for the Actor carried in the
+ * received PDU are compared with the corresponding operational parameter
+ * values for the ports partner. If one or more of the comparisons shows that
+ * the value(s) received in the PDU differ from the current operational values,
+ * then selected is set to FALSE and actor_oper_port_state.synchronization is
+ * set to out_of_sync. Otherwise, selected remains unchanged.
+ */
+static void __update_selected(struct lacpdu *lacpdu, struct port *port)
+{
+	// validate lacpdu and port
+	if (lacpdu && port) {
+		// check if any parameter is different
+		if ((lacpdu->actor_port != port->partner_oper_port_number) ||
+		    (lacpdu->actor_port_priority != port->partner_oper_port_priority) ||
+		    MAC_ADDRESS_COMPARE(&(lacpdu->actor_system), &(port->partner_oper_system)) ||
+		    (lacpdu->actor_system_priority != port->partner_oper_system_priority) ||
+		    (lacpdu->actor_key != port->partner_oper_key) ||
+		    ((lacpdu->actor_state & AD_STATE_AGGREGATION) != (port->partner_oper_port_state & AD_STATE_AGGREGATION))
+		   ) {
+			// update the state machine Selected variable
+			port->sm_vars &= ~AD_PORT_SELECTED;
+		}
+	}
+}
+
+/**
+ * __update_default_selected - update a port's Selected variable from Partner
+ * @port: the port we're looking at
+ *
+ * This function updates the value of the selected variable, using the partner
+ * administrative parameter values. The administrative values are compared with
+ * the corresponding operational parameter values for the partner. If one or
+ * more of the comparisons shows that the administrative value(s) differ from
+ * the current operational values, then Selected is set to FALSE and
+ * actor_oper_port_state.synchronization is set to OUT_OF_SYNC. Otherwise,
+ * Selected remains unchanged.
+ */
+static void __update_default_selected(struct port *port)
+{
+	// validate the port
+	if (port) {
+		// check if any parameter is different
+		if ((port->partner_admin_port_number != port->partner_oper_port_number) ||
+		    (port->partner_admin_port_priority != port->partner_oper_port_priority) ||
+		    MAC_ADDRESS_COMPARE(&(port->partner_admin_system), &(port->partner_oper_system)) ||
+		    (port->partner_admin_system_priority != port->partner_oper_system_priority) ||
+		    (port->partner_admin_key != port->partner_oper_key) ||
+		    ((port->partner_admin_port_state & AD_STATE_AGGREGATION) != (port->partner_oper_port_state & AD_STATE_AGGREGATION))
+		   ) {
+			// update the state machine Selected variable
+			port->sm_vars &= ~AD_PORT_SELECTED;
+		}
+	}
+}
+
+/**
+ * __choose_matched - update a port's matched variable from a received lacpdu
+ * @lacpdu: the lacpdu we've received
+ * @port: the port we're looking at
+ *
+ * Update the value of the matched variable, using parameter values from a
+ * newly received lacpdu. Parameter values for the partner carried in the
+ * received PDU are compared with the corresponding operational parameter
+ * values for the actor. Matched is set to TRUE if all of these parameters
+ * match and the PDU parameter partner_state.aggregation has the same value as
+ * actor_oper_port_state.aggregation and lacp will actively maintain the link
+ * in the aggregation. Matched is also set to TRUE if the value of
+ * actor_state.aggregation in the received PDU is set to FALSE, i.e., indicates
+ * an individual link and lacp will actively maintain the link. Otherwise,
+ * matched is set to FALSE. LACP is considered to be actively maintaining the
+ * link if either the PDU's actor_state.lacp_activity variable is TRUE or both
+ * the actor's actor_oper_port_state.lacp_activity and the PDU's
+ * partner_state.lacp_activity variables are TRUE.
+ */
+static void __choose_matched(struct lacpdu *lacpdu, struct port *port)
+{
+	// validate lacpdu and port
+	if (lacpdu && port) {
+		// check if all parameters are alike
+		if (((lacpdu->partner_port == port->actor_port_number) &&
+		     (lacpdu->partner_port_priority == port->actor_port_priority) &&
+		     !MAC_ADDRESS_COMPARE(&(lacpdu->partner_system), &(port->actor_system)) &&
+		     (lacpdu->partner_system_priority == port->actor_system_priority) &&
+		     (lacpdu->partner_key == port->actor_oper_port_key) &&
+		     ((lacpdu->partner_state & AD_STATE_AGGREGATION) == (port->actor_oper_port_state & AD_STATE_AGGREGATION))) ||
+		    // or this is individual link(aggregation == FALSE)
+		    ((lacpdu->actor_state & AD_STATE_AGGREGATION) == 0)
+		   ) {
+			// update the state machine Matched variable
+			port->sm_vars |= AD_PORT_MATCHED;
+		} else {
+			port->sm_vars &= ~AD_PORT_MATCHED;
+		}
+	}
+}
+
+/**
+ * __update_ntt - update a port's ntt variable from a received lacpdu
+ * @lacpdu: the lacpdu we've received
+ * @port: the port we're looking at
+ *
+ * Updates the value of the ntt variable, using parameter values from a newly
+ * received lacpdu. The parameter values for the partner carried in the
+ * received PDU are compared with the corresponding operational parameter
+ * values for the Actor. If one or more of the comparisons shows that the
+ * value(s) received in the PDU differ from the current operational values,
+ * then ntt is set to TRUE. Otherwise, ntt remains unchanged.
+ */
+static void __update_ntt(struct lacpdu *lacpdu, struct port *port)
+{
+	// validate lacpdu and port
+	if (lacpdu && port) {
+		// check if any parameter is different
+		if ((lacpdu->partner_port != port->actor_port_number) ||
+		    (lacpdu->partner_port_priority != port->actor_port_priority) ||
+		    MAC_ADDRESS_COMPARE(&(lacpdu->partner_system), &(port->actor_system)) ||
+		    (lacpdu->partner_system_priority != port->actor_system_priority) ||
+		    (lacpdu->partner_key != port->actor_oper_port_key) ||
+		    ((lacpdu->partner_state & AD_STATE_LACP_ACTIVITY) != (port->actor_oper_port_state & AD_STATE_LACP_ACTIVITY)) ||
+		    ((lacpdu->partner_state & AD_STATE_LACP_TIMEOUT) != (port->actor_oper_port_state & AD_STATE_LACP_TIMEOUT)) ||
+		    ((lacpdu->partner_state & AD_STATE_SYNCHRONIZATION) != (port->actor_oper_port_state & AD_STATE_SYNCHRONIZATION)) ||
+		    ((lacpdu->partner_state & AD_STATE_AGGREGATION) != (port->actor_oper_port_state & AD_STATE_AGGREGATION))
+		   ) {
+			// set ntt to be TRUE
+			port->ntt = 1;
+		}
+	}
+}
+
+/**
+ * __attach_bond_to_agg
+ * @port: the port we're looking at
+ *
+ * Handle the attaching of the port's control parser/multiplexer and the
+ * aggregator. This function does nothing since the parser/multiplexer of the
+ * receive and the parser/multiplexer of the aggregator are already combined.
+ */
+static void __attach_bond_to_agg(struct port *port)
+{
+	port=NULL; // just to satisfy the compiler
+	// This function does nothing since the parser/multiplexer of the receive
+	// and the parser/multiplexer of the aggregator are already combined
+}
+
+/**
+ * __detach_bond_from_agg
+ * @port: the port we're looking at
+ *
+ * Handle the detaching of the port's control parser/multiplexer from the
+ * aggregator. This function does nothing since the parser/multiplexer of the
+ * receive and the parser/multiplexer of the aggregator are already combined.
+ */
+static void __detach_bond_from_agg(struct port *port)
+{
+	port=NULL; // just to satisfy the compiler
+	// This function does nothing sience the parser/multiplexer of the receive
+	// and the parser/multiplexer of the aggregator are already combined
+}
+
+/**
+ * __agg_ports_are_ready - check if all ports in an aggregator are ready
+ * @aggregator: the aggregator we're looking at
+ *
+ */
+static int __agg_ports_are_ready(struct aggregator *aggregator)
+{
+	struct port *port;
+	int retval = 1;
+
+	if (aggregator) {
+		// scan all ports in this aggregator to verfy if they are all ready
+		for (port=aggregator->lag_ports; port; port=port->next_port_in_aggregator) {
+			if (!(port->sm_vars & AD_PORT_READY_N)) {
+				retval = 0;
+				break;
+			}
+		}
+	}
+
+	return retval;
+}
+
+/**
+ * __set_agg_ports_ready - set value of Ready bit in all ports of an aggregator
+ * @aggregator: the aggregator we're looking at
+ * @val: Should the ports' ready bit be set on or off
+ *
+ */
+static void __set_agg_ports_ready(struct aggregator *aggregator, int val)
+{
+	struct port *port;
+
+	for (port=aggregator->lag_ports; port; port=port->next_port_in_aggregator) {
+		if (val) {
+			port->sm_vars |= AD_PORT_READY;
+		} else {
+			port->sm_vars &= ~AD_PORT_READY;
+		}
+	}
+}
+
+/**
+ * __get_agg_bandwidth - get the total bandwidth of an aggregator
+ * @aggregator: the aggregator we're looking at
+ *
+ */
+static u32 __get_agg_bandwidth(struct aggregator *aggregator)
+{
+	u32 bandwidth=0;
+	u32 basic_speed;
+
+	if (aggregator->num_of_ports) {
+		basic_speed = __get_link_speed(aggregator->lag_ports);
+		switch (basic_speed) {
+		case AD_LINK_SPEED_BITMASK_1MBPS:
+			bandwidth = aggregator->num_of_ports;
+			break;
+		case AD_LINK_SPEED_BITMASK_10MBPS:
+			bandwidth = aggregator->num_of_ports * 10;
+			break;
+		case AD_LINK_SPEED_BITMASK_100MBPS:
+			bandwidth = aggregator->num_of_ports * 100;
+			break;
+		case AD_LINK_SPEED_BITMASK_1000MBPS:
+			bandwidth = aggregator->num_of_ports * 1000;
+			break;
+		default:
+			bandwidth=0; // to silent the compilor ....
+		}
+	}
+	return bandwidth;
+}
+
+/**
+ * __get_active_agg - get the current active aggregator
+ * @aggregator: the aggregator we're looking at
+ *
+ */
+static struct aggregator *__get_active_agg(struct aggregator *aggregator)
+{
+	struct aggregator *retval = NULL;
+
+	for (; aggregator; aggregator = __get_next_agg(aggregator)) {
+		if (aggregator->is_active) {
+			retval = aggregator;
+			break;
+		}
+	}
+
+	return retval;
+}
+
+/**
+ * __update_lacpdu_from_port - update a port's lacpdu fields
+ * @port: the port we're looking at
+ *
+ */
+static inline void __update_lacpdu_from_port(struct port *port)
+{
+	struct lacpdu *lacpdu = &port->lacpdu;
+
+	/* update current actual Actor parameters */
+	/* lacpdu->subtype                   initialized
+	 * lacpdu->version_number            initialized
+	 * lacpdu->tlv_type_actor_info       initialized
+	 * lacpdu->actor_information_length  initialized
+	 */
+
+	lacpdu->actor_system_priority = port->actor_system_priority;
+	lacpdu->actor_system = port->actor_system;
+	lacpdu->actor_key = port->actor_oper_port_key;
+	lacpdu->actor_port_priority = port->actor_port_priority;
+	lacpdu->actor_port = port->actor_port_number;
+	lacpdu->actor_state = port->actor_oper_port_state;
+
+	/* lacpdu->reserved_3_1              initialized
+	 * lacpdu->tlv_type_partner_info     initialized
+	 * lacpdu->partner_information_length initialized
+	 */
+
+	lacpdu->partner_system_priority = port->partner_oper_system_priority;
+	lacpdu->partner_system = port->partner_oper_system;
+	lacpdu->partner_key = port->partner_oper_key;
+	lacpdu->partner_port_priority = port->partner_oper_port_priority;
+	lacpdu->partner_port = port->partner_oper_port_number;
+	lacpdu->partner_state = port->partner_oper_port_state;
+
+	/* lacpdu->reserved_3_2              initialized
+	 * lacpdu->tlv_type_collector_info   initialized
+	 * lacpdu->collector_information_length initialized
+	 * collector_max_delay                initialized
+	 * reserved_12[12]                   initialized
+	 * tlv_type_terminator               initialized
+	 * terminator_length                 initialized
+	 * reserved_50[50]                   initialized
+	 */
+
+	/* Convert all non u8 parameters to Big Endian for transmit */
+	__ntohs_lacpdu(lacpdu);
+}
+
+//////////////////////////////////////////////////////////////////////////////////////
+// ================= main 802.3ad protocol code ======================================
+//////////////////////////////////////////////////////////////////////////////////////
+
+/**
+ * ad_lacpdu_send - send out a lacpdu packet on a given port
+ * @port: the port we're looking at
+ *
+ * Returns:   0 on success
+ *          < 0 on error
+ */
+static int ad_lacpdu_send(struct port *port)
+{
+	struct slave *slave = port->slave;
+	struct sk_buff *skb;
+	struct lacpdu_header *lacpdu_header;
+	int length = sizeof(struct lacpdu_header);
+	struct mac_addr lacpdu_multicast_address = AD_MULTICAST_LACPDU_ADDR;
+
+	skb = dev_alloc_skb(length);
+	if (!skb) {
+		return -ENOMEM;
+	}
+
+	skb->dev = slave->dev;
+	skb->mac.raw = skb->data;
+	skb->nh.raw = skb->data + ETH_HLEN;
+	skb->protocol = PKT_TYPE_LACPDU;
+	skb->priority = TC_PRIO_CONTROL;
+
+	lacpdu_header = (struct lacpdu_header *)skb_put(skb, length);
+
+	lacpdu_header->ad_header.destination_address = lacpdu_multicast_address;
+	/* Note: source addres is set to be the member's PERMANENT address, because we use it
+	   to identify loopback lacpdus in receive. */
+	lacpdu_header->ad_header.source_address = *((struct mac_addr *)(slave->perm_hwaddr));
+	lacpdu_header->ad_header.length_type = PKT_TYPE_LACPDU;
+
+	lacpdu_header->lacpdu = port->lacpdu; // struct copy
+
+	dev_queue_xmit(skb);
+
+	return 0;
+}
+
+/**
+ * ad_marker_send - send marker information/response on a given port
+ * @port: the port we're looking at
+ * @marker: marker data to send
+ *
+ * Returns:   0 on success
+ *          < 0 on error
+ */
+static int ad_marker_send(struct port *port, struct marker *marker)
+{
+	struct slave *slave = port->slave;
+	struct sk_buff *skb;
+	struct marker_header *marker_header;
+	int length = sizeof(struct marker_header);
+	struct mac_addr lacpdu_multicast_address = AD_MULTICAST_LACPDU_ADDR;
+
+	skb = dev_alloc_skb(length + 16);
+	if (!skb) {
+		return -ENOMEM;
+	}
+
+	skb_reserve(skb, 16);
+
+	skb->dev = slave->dev;
+	skb->mac.raw = skb->data;
+	skb->nh.raw = skb->data + ETH_HLEN;
+	skb->protocol = PKT_TYPE_LACPDU;
+
+	marker_header = (struct marker_header *)skb_put(skb, length);
+
+	marker_header->ad_header.destination_address = lacpdu_multicast_address;
+	/* Note: source addres is set to be the member's PERMANENT address, because we use it
+	   to identify loopback MARKERs in receive. */
+	marker_header->ad_header.source_address = *((struct mac_addr *)(slave->perm_hwaddr));
+	marker_header->ad_header.length_type = PKT_TYPE_LACPDU;
+
+	marker_header->marker = *marker; // struct copy
+
+	dev_queue_xmit(skb);
+
+	return 0;
+}
+
+/**
+ * ad_mux_machine - handle a port's mux state machine
+ * @port: the port we're looking at
+ *
+ */
+static void ad_mux_machine(struct port *port)
+{
+	mux_states_t last_state;
+
+	// keep current State Machine state to compare later if it was changed
+	last_state = port->sm_mux_state;
+
+	if (port->sm_vars & AD_PORT_BEGIN) {
+		port->sm_mux_state = AD_MUX_DETACHED;		 // next state
+	} else {
+		switch (port->sm_mux_state) {
+		case AD_MUX_DETACHED:
+			if ((port->sm_vars & AD_PORT_SELECTED) || (port->sm_vars & AD_PORT_STANDBY)) { // if SELECTED or STANDBY
+				port->sm_mux_state = AD_MUX_WAITING; // next state
+			}
+			break;
+		case AD_MUX_WAITING:
+			// if SELECTED == FALSE return to DETACH state
+			if (!(port->sm_vars & AD_PORT_SELECTED)) { // if UNSELECTED
+				port->sm_vars &= ~AD_PORT_READY_N;
+				// in order to withhold the Selection Logic to check all ports READY_N value
+				// every callback cycle to update ready variable, we check READY_N and update READY here
+				__set_agg_ports_ready(port->aggregator, __agg_ports_are_ready(port->aggregator));
+				port->sm_mux_state = AD_MUX_DETACHED;	 // next state
+				break;
+			}
+
+			// check if the wait_while_timer expired
+			if (port->sm_mux_timer_counter && !(--port->sm_mux_timer_counter)) {
+				port->sm_vars |= AD_PORT_READY_N;
+			}
+
+			// in order to withhold the selection logic to check all ports READY_N value
+			// every callback cycle to update ready variable, we check READY_N and update READY here
+			__set_agg_ports_ready(port->aggregator, __agg_ports_are_ready(port->aggregator));
+
+			// if the wait_while_timer expired, and the port is in READY state, move to ATTACHED state
+			if ((port->sm_vars & AD_PORT_READY) && !port->sm_mux_timer_counter) {
+				port->sm_mux_state = AD_MUX_ATTACHED;	 // next state
+			}
+			break;
+		case AD_MUX_ATTACHED:
+			// check also if agg_select_timer expired(so the edable port will take place only after this timer)
+			if ((port->sm_vars & AD_PORT_SELECTED) && (port->partner_oper_port_state & AD_STATE_SYNCHRONIZATION) && !__check_agg_selection_timer(port)) {
+				port->sm_mux_state = AD_MUX_COLLECTING_DISTRIBUTING;// next state
+			} else if (!(port->sm_vars & AD_PORT_SELECTED) || (port->sm_vars & AD_PORT_STANDBY)) {	  // if UNSELECTED or STANDBY
+				port->sm_vars &= ~AD_PORT_READY_N;
+				// in order to withhold the selection logic to check all ports READY_N value
+				// every callback cycle to update ready variable, we check READY_N and update READY here
+				__set_agg_ports_ready(port->aggregator, __agg_ports_are_ready(port->aggregator));
+				port->sm_mux_state = AD_MUX_DETACHED;// next state
+			}
+			break;
+		case AD_MUX_COLLECTING_DISTRIBUTING:
+			if (!(port->sm_vars & AD_PORT_SELECTED) || (port->sm_vars & AD_PORT_STANDBY) ||
+			    !(port->partner_oper_port_state & AD_STATE_SYNCHRONIZATION)
+			   ) {
+				port->sm_mux_state = AD_MUX_ATTACHED;// next state
+
+			} else {
+				// if port state hasn't changed make
+				// sure that a collecting distributing
+				// port in an active aggregator is enabled
+				if (port->aggregator &&
+				    port->aggregator->is_active &&
+				    !__port_is_enabled(port)) {
+
+					__enable_port(port);
+				}
+			}
+			break;
+		default:    //to silence the compiler
+			break;
+		}
+	}
+
+	// check if the state machine was changed
+	if (port->sm_mux_state != last_state) {
+		dprintk("Mux Machine: Port=%d, Last State=%d, Curr State=%d\n", port->actor_port_number, last_state, port->sm_mux_state);
+		switch (port->sm_mux_state) {
+		case AD_MUX_DETACHED:
+			__detach_bond_from_agg(port);
+			port->actor_oper_port_state &= ~AD_STATE_SYNCHRONIZATION;
+			ad_disable_collecting_distributing(port);
+			port->actor_oper_port_state &= ~AD_STATE_COLLECTING;
+			port->actor_oper_port_state &= ~AD_STATE_DISTRIBUTING;
+			port->ntt = 1;
+			break;
+		case AD_MUX_WAITING:
+			port->sm_mux_timer_counter = __ad_timer_to_ticks(AD_WAIT_WHILE_TIMER, 0);
+			break;
+		case AD_MUX_ATTACHED:
+			__attach_bond_to_agg(port);
+			port->actor_oper_port_state |= AD_STATE_SYNCHRONIZATION;
+			port->actor_oper_port_state &= ~AD_STATE_COLLECTING;
+			port->actor_oper_port_state &= ~AD_STATE_DISTRIBUTING;
+			ad_disable_collecting_distributing(port);
+			port->ntt = 1;
+			break;
+		case AD_MUX_COLLECTING_DISTRIBUTING:
+			port->actor_oper_port_state |= AD_STATE_COLLECTING;
+			port->actor_oper_port_state |= AD_STATE_DISTRIBUTING;
+			ad_enable_collecting_distributing(port);
+			port->ntt = 1;
+			break;
+		default:    //to silence the compiler
+			break;
+		}
+	}
+}
+
+/**
+ * ad_rx_machine - handle a port's rx State Machine
+ * @lacpdu: the lacpdu we've received
+ * @port: the port we're looking at
+ *
+ * If lacpdu arrived, stop previous timer (if exists) and set the next state as
+ * CURRENT. If timer expired set the state machine in the proper state.
+ * In other cases, this function checks if we need to switch to other state.
+ */
+static void ad_rx_machine(struct lacpdu *lacpdu, struct port *port)
+{
+	rx_states_t last_state;
+
+	// Lock to prevent 2 instances of this function to run simultaneously(rx interrupt and periodic machine callback)
+	__get_rx_machine_lock(port);
+
+	// keep current State Machine state to compare later if it was changed
+	last_state = port->sm_rx_state;
+
+	// check if state machine should change state
+	// first, check if port was reinitialized
+	if (port->sm_vars & AD_PORT_BEGIN) {
+		port->sm_rx_state = AD_RX_INITIALIZE;		    // next state
+	}
+	// check if port is not enabled
+	else if (!(port->sm_vars & AD_PORT_BEGIN) && !port->is_enabled && !(port->sm_vars & AD_PORT_MOVED)) {
+		port->sm_rx_state = AD_RX_PORT_DISABLED;	    // next state
+	}
+	// check if new lacpdu arrived
+	else if (lacpdu && ((port->sm_rx_state == AD_RX_EXPIRED) || (port->sm_rx_state == AD_RX_DEFAULTED) || (port->sm_rx_state == AD_RX_CURRENT))) {
+		port->sm_rx_timer_counter = 0; // zero timer
+		port->sm_rx_state = AD_RX_CURRENT;
+	} else {
+		// if timer is on, and if it is expired
+		if (port->sm_rx_timer_counter && !(--port->sm_rx_timer_counter)) {
+			switch (port->sm_rx_state) {
+			case AD_RX_EXPIRED:
+				port->sm_rx_state = AD_RX_DEFAULTED;		// next state
+				break;
+			case AD_RX_CURRENT:
+				port->sm_rx_state = AD_RX_EXPIRED;	    // next state
+				break;
+			default:    //to silence the compiler
+				break;
+			}
+		} else {
+			// if no lacpdu arrived and no timer is on
+			switch (port->sm_rx_state) {
+			case AD_RX_PORT_DISABLED:
+				if (port->sm_vars & AD_PORT_MOVED) {
+					port->sm_rx_state = AD_RX_INITIALIZE;	    // next state
+				} else if (port->is_enabled && (port->sm_vars & AD_PORT_LACP_ENABLED)) {
+					port->sm_rx_state = AD_RX_EXPIRED;	// next state
+				} else if (port->is_enabled && ((port->sm_vars & AD_PORT_LACP_ENABLED) == 0)) {
+					port->sm_rx_state = AD_RX_LACP_DISABLED;    // next state
+				}
+				break;
+			default:    //to silence the compiler
+				break;
+
+			}
+		}
+	}
+
+	// check if the State machine was changed or new lacpdu arrived
+	if ((port->sm_rx_state != last_state) || (lacpdu)) {
+		dprintk("Rx Machine: Port=%d, Last State=%d, Curr State=%d\n", port->actor_port_number, last_state, port->sm_rx_state);
+		switch (port->sm_rx_state) {
+		case AD_RX_INITIALIZE:
+			if (!(port->actor_oper_port_key & AD_DUPLEX_KEY_BITS)) {
+				port->sm_vars &= ~AD_PORT_LACP_ENABLED;
+			} else {
+				port->sm_vars |= AD_PORT_LACP_ENABLED;
+			}
+			port->sm_vars &= ~AD_PORT_SELECTED;
+			__record_default(port);
+			port->actor_oper_port_state &= ~AD_STATE_EXPIRED;
+			port->sm_vars &= ~AD_PORT_MOVED;
+			port->sm_rx_state = AD_RX_PORT_DISABLED;	// next state
+
+			/*- Fall Through -*/
+
+		case AD_RX_PORT_DISABLED:
+			port->sm_vars &= ~AD_PORT_MATCHED;
+			break;
+		case AD_RX_LACP_DISABLED:
+			port->sm_vars &= ~AD_PORT_SELECTED;
+			__record_default(port);
+			port->partner_oper_port_state &= ~AD_STATE_AGGREGATION;
+			port->sm_vars |= AD_PORT_MATCHED;
+			port->actor_oper_port_state &= ~AD_STATE_EXPIRED;
+			break;
+		case AD_RX_EXPIRED:
+			//Reset of the Synchronization flag. (Standard 43.4.12)
+			//This reset cause to disable this port in the COLLECTING_DISTRIBUTING state of the
+			//mux machine in case of EXPIRED even if LINK_DOWN didn't arrive for the port.
+			port->partner_oper_port_state &= ~AD_STATE_SYNCHRONIZATION;
+			port->sm_vars &= ~AD_PORT_MATCHED;
+			port->partner_oper_port_state |= AD_SHORT_TIMEOUT;
+			port->sm_rx_timer_counter = __ad_timer_to_ticks(AD_CURRENT_WHILE_TIMER, (u16)(AD_SHORT_TIMEOUT));
+			port->actor_oper_port_state |= AD_STATE_EXPIRED;
+			break;
+		case AD_RX_DEFAULTED:
+			__update_default_selected(port);
+			__record_default(port);
+			port->sm_vars |= AD_PORT_MATCHED;
+			port->actor_oper_port_state &= ~AD_STATE_EXPIRED;
+			break;
+		case AD_RX_CURRENT:
+			// detect loopback situation
+			if (!MAC_ADDRESS_COMPARE(&(lacpdu->actor_system), &(port->actor_system))) {
+				// INFO_RECEIVED_LOOPBACK_FRAMES
+				printk(KERN_ERR DRV_NAME ": An illegal loopback occurred on adapter (%s)\n",
+						port->slave->dev->name);
+				printk(KERN_ERR "Check the configuration to verify that all Adapters "
+						"are connected to 802.3ad compliant switch ports\n");
+				__release_rx_machine_lock(port);
+				return;
+			}
+			__update_selected(lacpdu, port);
+			__update_ntt(lacpdu, port);
+			__record_pdu(lacpdu, port);
+			__choose_matched(lacpdu, port);
+			port->sm_rx_timer_counter = __ad_timer_to_ticks(AD_CURRENT_WHILE_TIMER, (u16)(port->actor_oper_port_state & AD_STATE_LACP_TIMEOUT));
+			port->actor_oper_port_state &= ~AD_STATE_EXPIRED;
+			// verify that if the aggregator is enabled, the port is enabled too.
+			//(because if the link goes down for a short time, the 802.3ad will not
+			// catch it, and the port will continue to be disabled)
+			if (port->aggregator && port->aggregator->is_active && !__port_is_enabled(port)) {
+				__enable_port(port);
+			}
+			break;
+		default:    //to silence the compiler
+			break;
+		}
+	}
+	__release_rx_machine_lock(port);
+}
+
+/**
+ * ad_tx_machine - handle a port's tx state machine
+ * @port: the port we're looking at
+ *
+ */
+static void ad_tx_machine(struct port *port)
+{
+	// check if tx timer expired, to verify that we do not send more than 3 packets per second
+	if (port->sm_tx_timer_counter && !(--port->sm_tx_timer_counter)) {
+		// check if there is something to send
+		if (port->ntt && (port->sm_vars & AD_PORT_LACP_ENABLED)) {
+			__update_lacpdu_from_port(port);
+			// send the lacpdu
+			if (ad_lacpdu_send(port) >= 0) {
+				dprintk("Sent LACPDU on port %d\n", port->actor_port_number);
+				// mark ntt as false, so it will not be sent again until demanded
+				port->ntt = 0;
+			}
+		}
+		// restart tx timer(to verify that we will not exceed AD_MAX_TX_IN_SECOND
+		port->sm_tx_timer_counter=ad_ticks_per_sec/AD_MAX_TX_IN_SECOND;
+	}
+}
+
+/**
+ * ad_periodic_machine - handle a port's periodic state machine
+ * @port: the port we're looking at
+ *
+ * Turn ntt flag on priodically to perform periodic transmission of lacpdu's.
+ */
+static void ad_periodic_machine(struct port *port)
+{
+	periodic_states_t last_state;
+
+	// keep current state machine state to compare later if it was changed
+	last_state = port->sm_periodic_state;
+
+	// check if port was reinitialized
+	if (((port->sm_vars & AD_PORT_BEGIN) || !(port->sm_vars & AD_PORT_LACP_ENABLED) || !port->is_enabled) ||
+	    (!(port->actor_oper_port_state & AD_STATE_LACP_ACTIVITY) && !(port->partner_oper_port_state & AD_STATE_LACP_ACTIVITY))
+	   ) {
+		port->sm_periodic_state = AD_NO_PERIODIC;	     // next state
+	}
+	// check if state machine should change state
+	else if (port->sm_periodic_timer_counter) {
+		// check if periodic state machine expired
+		if (!(--port->sm_periodic_timer_counter)) {
+			// if expired then do tx
+			port->sm_periodic_state = AD_PERIODIC_TX;    // next state
+		} else {
+			// If not expired, check if there is some new timeout parameter from the partner state
+			switch (port->sm_periodic_state) {
+			case AD_FAST_PERIODIC:
+				if (!(port->partner_oper_port_state & AD_STATE_LACP_TIMEOUT)) {
+					port->sm_periodic_state = AD_SLOW_PERIODIC;  // next state
+				}
+				break;
+			case AD_SLOW_PERIODIC:
+				if ((port->partner_oper_port_state & AD_STATE_LACP_TIMEOUT)) {
+					// stop current timer
+					port->sm_periodic_timer_counter = 0;
+					port->sm_periodic_state = AD_PERIODIC_TX;	 // next state
+				}
+				break;
+			default:    //to silence the compiler
+				break;
+			}
+		}
+	} else {
+		switch (port->sm_periodic_state) {
+		case AD_NO_PERIODIC:
+			port->sm_periodic_state = AD_FAST_PERIODIC;	 // next state
+			break;
+		case AD_PERIODIC_TX:
+			if (!(port->partner_oper_port_state & AD_STATE_LACP_TIMEOUT)) {
+				port->sm_periodic_state = AD_SLOW_PERIODIC;  // next state
+			} else {
+				port->sm_periodic_state = AD_FAST_PERIODIC;  // next state
+			}
+			break;
+		default:    //to silence the compiler
+			break;
+		}
+	}
+
+	// check if the state machine was changed
+	if (port->sm_periodic_state != last_state) {
+		dprintk("Periodic Machine: Port=%d, Last State=%d, Curr State=%d\n", port->actor_port_number, last_state, port->sm_periodic_state);
+		switch (port->sm_periodic_state) {
+		case AD_NO_PERIODIC:
+			port->sm_periodic_timer_counter = 0;	   // zero timer
+			break;
+		case AD_FAST_PERIODIC:
+			port->sm_periodic_timer_counter = __ad_timer_to_ticks(AD_PERIODIC_TIMER, (u16)(AD_FAST_PERIODIC_TIME))-1; // decrement 1 tick we lost in the PERIODIC_TX cycle
+			break;
+		case AD_SLOW_PERIODIC:
+			port->sm_periodic_timer_counter = __ad_timer_to_ticks(AD_PERIODIC_TIMER, (u16)(AD_SLOW_PERIODIC_TIME))-1; // decrement 1 tick we lost in the PERIODIC_TX cycle
+			break;
+		case AD_PERIODIC_TX:
+			port->ntt = 1;
+			break;
+		default:    //to silence the compiler
+			break;
+		}
+	}
+}
+
+/**
+ * ad_port_selection_logic - select aggregation groups
+ * @port: the port we're looking at
+ *
+ * Select aggregation groups, and assign each port for it's aggregetor. The
+ * selection logic is called in the inititalization (after all the handshkes),
+ * and after every lacpdu receive (if selected is off).
+ */
+static void ad_port_selection_logic(struct port *port)
+{
+	struct aggregator *aggregator, *free_aggregator = NULL, *temp_aggregator;
+	struct port *last_port = NULL, *curr_port;
+	int found = 0;
+
+	// if the port is already Selected, do nothing
+	if (port->sm_vars & AD_PORT_SELECTED) {
+		return;
+	}
+
+	// if the port is connected to other aggregator, detach it
+	if (port->aggregator) {
+		// detach the port from its former aggregator
+		temp_aggregator=port->aggregator;
+		for (curr_port=temp_aggregator->lag_ports; curr_port; last_port=curr_port, curr_port=curr_port->next_port_in_aggregator) {
+			if (curr_port == port) {
+				temp_aggregator->num_of_ports--;
+				if (!last_port) {// if it is the first port attached to the aggregator
+					temp_aggregator->lag_ports=port->next_port_in_aggregator;
+				} else {// not the first port attached to the aggregator
+					last_port->next_port_in_aggregator=port->next_port_in_aggregator;
+				}
+
+				// clear the port's relations to this aggregator
+				port->aggregator = NULL;
+				port->next_port_in_aggregator=NULL;
+				port->actor_port_aggregator_identifier=0;
+
+				dprintk("Port %d left LAG %d\n", port->actor_port_number, temp_aggregator->aggregator_identifier);
+				// if the aggregator is empty, clear its parameters, and set it ready to be attached
+				if (!temp_aggregator->lag_ports) {
+					ad_clear_agg(temp_aggregator);
+				}
+				break;
+			}
+		}
+		if (!curr_port) { // meaning: the port was related to an aggregator but was not on the aggregator port list
+			printk(KERN_WARNING DRV_NAME ": Warning: Port %d (on %s) was "
+			       "related to aggregator %d but was not on its port list\n",
+			       port->actor_port_number, port->slave->dev->name,
+			       port->aggregator->aggregator_identifier);
+		}
+	}
+	// search on all aggregators for a suitable aggregator for this port
+	for (aggregator = __get_first_agg(port); aggregator;
+	     aggregator = __get_next_agg(aggregator)) {
+
+		// keep a free aggregator for later use(if needed)
+		if (!aggregator->lag_ports) {
+			if (!free_aggregator) {
+				free_aggregator=aggregator;
+			}
+			continue;
+		}
+		// check if current aggregator suits us
+		if (((aggregator->actor_oper_aggregator_key == port->actor_oper_port_key) && // if all parameters match AND
+		     !MAC_ADDRESS_COMPARE(&(aggregator->partner_system), &(port->partner_oper_system)) &&
+		     (aggregator->partner_system_priority == port->partner_oper_system_priority) &&
+		     (aggregator->partner_oper_aggregator_key == port->partner_oper_key)
+		    ) &&
+		    ((MAC_ADDRESS_COMPARE(&(port->partner_oper_system), &(null_mac_addr)) && // partner answers
+		      !aggregator->is_individual)  // but is not individual OR
+		    )
+		   ) {
+			// attach to the founded aggregator
+			port->aggregator = aggregator;
+			port->actor_port_aggregator_identifier=port->aggregator->aggregator_identifier;
+			port->next_port_in_aggregator=aggregator->lag_ports;
+			port->aggregator->num_of_ports++;
+			aggregator->lag_ports=port;
+			dprintk("Port %d joined LAG %d(existing LAG)\n", port->actor_port_number, port->aggregator->aggregator_identifier);
+
+			// mark this port as selected
+			port->sm_vars |= AD_PORT_SELECTED;
+			found = 1;
+			break;
+		}
+	}
+
+	// the port couldn't find an aggregator - attach it to a new aggregator
+	if (!found) {
+		if (free_aggregator) {
+			// assign port a new aggregator
+			port->aggregator = free_aggregator;
+			port->actor_port_aggregator_identifier=port->aggregator->aggregator_identifier;
+
+			// update the new aggregator's parameters
+			// if port was responsed from the end-user
+			if (port->actor_oper_port_key & AD_DUPLEX_KEY_BITS) {// if port is full duplex
+				port->aggregator->is_individual = 0;
+			} else {
+				port->aggregator->is_individual = 1;
+			}
+
+			port->aggregator->actor_admin_aggregator_key = port->actor_admin_port_key;
+			port->aggregator->actor_oper_aggregator_key = port->actor_oper_port_key;
+			port->aggregator->partner_system=port->partner_oper_system;
+			port->aggregator->partner_system_priority = port->partner_oper_system_priority;
+			port->aggregator->partner_oper_aggregator_key = port->partner_oper_key;
+			port->aggregator->receive_state = 1;
+			port->aggregator->transmit_state = 1;
+			port->aggregator->lag_ports = port;
+			port->aggregator->num_of_ports++;
+
+			// mark this port as selected
+			port->sm_vars |= AD_PORT_SELECTED;
+
+			dprintk("Port %d joined LAG %d(new LAG)\n", port->actor_port_number, port->aggregator->aggregator_identifier);
+		} else {
+			printk(KERN_ERR DRV_NAME ": Port %d (on %s) did not find a suitable aggregator\n",
+			       port->actor_port_number, port->slave->dev->name);
+		}
+	}
+	// if all aggregator's ports are READY_N == TRUE, set ready=TRUE in all aggregator's ports
+	// else set ready=FALSE in all aggregator's ports
+	__set_agg_ports_ready(port->aggregator, __agg_ports_are_ready(port->aggregator));
+
+	if (!__check_agg_selection_timer(port) && (aggregator = __get_first_agg(port))) {
+		ad_agg_selection_logic(aggregator);
+	}
+}
+
+/**
+ * ad_agg_selection_logic - select an aggregation group for a team
+ * @aggregator: the aggregator we're looking at
+ *
+ * It is assumed that only one aggregator may be selected for a team.
+ * The logic of this function is to select (at first time) the aggregator with
+ * the most ports attached to it, and to reselect the active aggregator only if
+ * the previous aggregator has no more ports related to it.
+ *
+ * FIXME: this function MUST be called with the first agg in the bond, or
+ * __get_active_agg() won't work correctly. This function should be better
+ * called with the bond itself, and retrieve the first agg from it.
+ */
+static void ad_agg_selection_logic(struct aggregator *aggregator)
+{
+	struct aggregator *best_aggregator = NULL, *active_aggregator = NULL;
+	struct aggregator *last_active_aggregator = NULL, *origin_aggregator;
+	struct port *port;
+	u16 num_of_aggs=0;
+
+	origin_aggregator = aggregator;
+
+	//get current active aggregator
+	last_active_aggregator = __get_active_agg(aggregator);
+
+	// search for the aggregator with the most ports attached to it.
+	do {
+		// count how many candidate lag's we have
+		if (aggregator->lag_ports) {
+			num_of_aggs++;
+		}
+		if (aggregator->is_active && !aggregator->is_individual &&   // if current aggregator is the active aggregator
+		    MAC_ADDRESS_COMPARE(&(aggregator->partner_system), &(null_mac_addr))) {   // and partner answers to 802.3ad PDUs
+			if (aggregator->num_of_ports) {	// if any ports attached to the current aggregator
+				best_aggregator=NULL;	 // disregard the best aggregator that was chosen by now
+				break;		 // stop the selection of other aggregator if there are any ports attached to this active aggregator
+			} else { // no ports attached to this active aggregator
+				aggregator->is_active = 0; // mark this aggregator as not active anymore
+			}
+		}
+		if (aggregator->num_of_ports) {	// if any ports attached
+			if (best_aggregator) {	// if there is a candidte aggregator
+				//The reasons for choosing new best aggregator:
+				// 1. if current agg is NOT individual and the best agg chosen so far is individual OR
+				// current and best aggs are both individual or both not individual, AND
+				// 2a.  current agg partner reply but best agg partner do not reply OR
+				// 2b.  current agg partner reply OR current agg partner do not reply AND best agg partner also do not reply AND
+				//      current has more ports/bandwidth, or same amount of ports but current has faster ports, THEN
+				//      current agg become best agg so far
+
+				//if current agg is NOT individual and the best agg chosen so far is individual change best_aggregator
+				if (!aggregator->is_individual && best_aggregator->is_individual) {
+					best_aggregator=aggregator;
+				}
+				// current and best aggs are both individual or both not individual
+				else if ((aggregator->is_individual && best_aggregator->is_individual) ||
+					 (!aggregator->is_individual && !best_aggregator->is_individual)) {
+					//  current and best aggs are both individual or both not individual AND
+					//  current agg partner reply but best agg partner do not reply
+					if ((MAC_ADDRESS_COMPARE(&(aggregator->partner_system), &(null_mac_addr)) &&
+					     !MAC_ADDRESS_COMPARE(&(best_aggregator->partner_system), &(null_mac_addr)))) {
+						best_aggregator=aggregator;
+					}
+					//  current agg partner reply OR current agg partner do not reply AND best agg partner also do not reply
+					else if (! (!MAC_ADDRESS_COMPARE(&(aggregator->partner_system), &(null_mac_addr)) &&
+						    MAC_ADDRESS_COMPARE(&(best_aggregator->partner_system), &(null_mac_addr)))) {
+						if ((__get_agg_selection_mode(aggregator->lag_ports) == AD_BANDWIDTH)&&
+						    (__get_agg_bandwidth(aggregator) > __get_agg_bandwidth(best_aggregator))) {
+							best_aggregator=aggregator;
+						} else if (__get_agg_selection_mode(aggregator->lag_ports) == AD_COUNT) {
+							if (((aggregator->num_of_ports > best_aggregator->num_of_ports) &&
+							     (aggregator->actor_oper_aggregator_key & AD_SPEED_KEY_BITS))||
+							    ((aggregator->num_of_ports == best_aggregator->num_of_ports) &&
+							     ((u16)(aggregator->actor_oper_aggregator_key & AD_SPEED_KEY_BITS) >
+							      (u16)(best_aggregator->actor_oper_aggregator_key & AD_SPEED_KEY_BITS)))) {
+								best_aggregator=aggregator;
+							}
+						}
+					}
+				}
+			} else {
+				best_aggregator=aggregator;
+			}
+		}
+		aggregator->is_active = 0; // mark all aggregators as not active anymore
+	} while ((aggregator = __get_next_agg(aggregator)));
+
+	// if we have new aggregator selected, don't replace the old aggregator if it has an answering partner,
+	// or if both old aggregator and new aggregator don't have answering partner
+	if (best_aggregator) {
+		if (last_active_aggregator && last_active_aggregator->lag_ports && last_active_aggregator->lag_ports->is_enabled &&
+		    (MAC_ADDRESS_COMPARE(&(last_active_aggregator->partner_system), &(null_mac_addr)) ||   // partner answers OR
+		     (!MAC_ADDRESS_COMPARE(&(last_active_aggregator->partner_system), &(null_mac_addr)) &&	// both old and new
+		      !MAC_ADDRESS_COMPARE(&(best_aggregator->partner_system), &(null_mac_addr))))     // partner do not answer
+		   ) {
+			// if new aggregator has link, and old aggregator does not, replace old aggregator.(do nothing)
+			// -> don't replace otherwise.
+			if (!(!last_active_aggregator->actor_oper_aggregator_key && best_aggregator->actor_oper_aggregator_key)) {
+				best_aggregator=NULL;
+				last_active_aggregator->is_active = 1; // don't replace good old aggregator
+
+			}
+		}
+	}
+
+	// if there is new best aggregator, activate it
+	if (best_aggregator) {
+		for (aggregator = __get_first_agg(best_aggregator->lag_ports);
+		    aggregator;
+		    aggregator = __get_next_agg(aggregator)) {
+
+			dprintk("Agg=%d; Ports=%d; a key=%d; p key=%d; Indiv=%d; Active=%d\n",
+					aggregator->aggregator_identifier, aggregator->num_of_ports,
+					aggregator->actor_oper_aggregator_key, aggregator->partner_oper_aggregator_key,
+					aggregator->is_individual, aggregator->is_active);
+		}
+
+		// check if any partner replys
+		if (best_aggregator->is_individual) {
+			printk(KERN_WARNING DRV_NAME ": Warning: No 802.3ad response from the link partner "
+					"for any adapters in the bond\n");
+		}
+
+		// check if there are more than one aggregator
+		if (num_of_aggs > 1) {
+			dprintk("Warning: More than one Link Aggregation Group was "
+				"found in the bond. Only one group will function in the bond\n");
+		}
+
+		best_aggregator->is_active = 1;
+		dprintk("LAG %d choosed as the active LAG\n", best_aggregator->aggregator_identifier);
+		dprintk("Agg=%d; Ports=%d; a key=%d; p key=%d; Indiv=%d; Active=%d\n",
+				best_aggregator->aggregator_identifier, best_aggregator->num_of_ports,
+				best_aggregator->actor_oper_aggregator_key, best_aggregator->partner_oper_aggregator_key,
+				best_aggregator->is_individual, best_aggregator->is_active);
+
+		// disable the ports that were related to the former active_aggregator
+		if (last_active_aggregator) {
+			for (port=last_active_aggregator->lag_ports; port; port=port->next_port_in_aggregator) {
+				__disable_port(port);
+			}
+		}
+	}
+
+	// if the selected aggregator is of join individuals(partner_system is NULL), enable their ports
+	active_aggregator = __get_active_agg(origin_aggregator);
+
+	if (active_aggregator) {
+		if (!MAC_ADDRESS_COMPARE(&(active_aggregator->partner_system), &(null_mac_addr))) {
+			for (port=active_aggregator->lag_ports; port; port=port->next_port_in_aggregator) {
+				__enable_port(port);
+			}
+		}
+	}
+}
+
+/**
+ * ad_clear_agg - clear a given aggregator's parameters
+ * @aggregator: the aggregator we're looking at
+ *
+ */
+static void ad_clear_agg(struct aggregator *aggregator)
+{
+	if (aggregator) {
+		aggregator->is_individual = 0;
+		aggregator->actor_admin_aggregator_key = 0;
+		aggregator->actor_oper_aggregator_key = 0;
+		aggregator->partner_system = null_mac_addr;
+		aggregator->partner_system_priority = 0;
+		aggregator->partner_oper_aggregator_key = 0;
+		aggregator->receive_state = 0;
+		aggregator->transmit_state = 0;
+		aggregator->lag_ports = NULL;
+		aggregator->is_active = 0;
+		aggregator->num_of_ports = 0;
+		dprintk("LAG %d was cleared\n", aggregator->aggregator_identifier);
+	}
+}
+
+/**
+ * ad_initialize_agg - initialize a given aggregator's parameters
+ * @aggregator: the aggregator we're looking at
+ *
+ */
+static void ad_initialize_agg(struct aggregator *aggregator)
+{
+	if (aggregator) {
+		ad_clear_agg(aggregator);
+
+		aggregator->aggregator_mac_address = null_mac_addr;
+		aggregator->aggregator_identifier = 0;
+		aggregator->slave = NULL;
+	}
+}
+
+/**
+ * ad_initialize_port - initialize a given port's parameters
+ * @aggregator: the aggregator we're looking at
+ * @lacp_fast: boolean. whether fast periodic should be used
+ *
+ */
+static void ad_initialize_port(struct port *port, int lacp_fast)
+{
+	if (port) {
+		port->actor_port_number = 1;
+		port->actor_port_priority = 0xff;
+		port->actor_system = null_mac_addr;
+		port->actor_system_priority = 0xffff;
+		port->actor_port_aggregator_identifier = 0;
+		port->ntt = 0;
+		port->actor_admin_port_key = 1;
+		port->actor_oper_port_key  = 1;
+		port->actor_admin_port_state = AD_STATE_AGGREGATION | AD_STATE_LACP_ACTIVITY;
+		port->actor_oper_port_state  = AD_STATE_AGGREGATION | AD_STATE_LACP_ACTIVITY;
+
+		if (lacp_fast) {
+			port->actor_oper_port_state |= AD_STATE_LACP_TIMEOUT;
+		}
+
+		port->partner_admin_system = null_mac_addr;
+		port->partner_oper_system  = null_mac_addr;
+		port->partner_admin_system_priority = 0xffff;
+		port->partner_oper_system_priority  = 0xffff;
+		port->partner_admin_key = 1;
+		port->partner_oper_key  = 1;
+		port->partner_admin_port_number = 1;
+		port->partner_oper_port_number  = 1;
+		port->partner_admin_port_priority = 0xff;
+		port->partner_oper_port_priority  = 0xff;
+		port->partner_admin_port_state = 1;
+		port->partner_oper_port_state  = 1;
+		port->is_enabled = 1;
+		// ****** private parameters ******
+		port->sm_vars = 0x3;
+		port->sm_rx_state = 0;
+		port->sm_rx_timer_counter = 0;
+		port->sm_periodic_state = 0;
+		port->sm_periodic_timer_counter = 0;
+		port->sm_mux_state = 0;
+		port->sm_mux_timer_counter = 0;
+		port->sm_tx_state = 0;
+		port->sm_tx_timer_counter = 0;
+		port->slave = NULL;
+		port->aggregator = NULL;
+		port->next_port_in_aggregator = NULL;
+		port->transaction_id = 0;
+
+		ad_initialize_lacpdu(&(port->lacpdu));
+	}
+}
+
+/**
+ * ad_enable_collecting_distributing - enable a port's transmit/receive
+ * @port: the port we're looking at
+ *
+ * Enable @port if it's in an active aggregator
+ */
+static void ad_enable_collecting_distributing(struct port *port)
+{
+	if (port->aggregator->is_active) {
+		dprintk("Enabling port %d(LAG %d)\n", port->actor_port_number, port->aggregator->aggregator_identifier);
+		__enable_port(port);
+	}
+}
+
+/**
+ * ad_disable_collecting_distributing - disable a port's transmit/receive
+ * @port: the port we're looking at
+ *
+ */
+static void ad_disable_collecting_distributing(struct port *port)
+{
+	if (port->aggregator && MAC_ADDRESS_COMPARE(&(port->aggregator->partner_system), &(null_mac_addr))) {
+		dprintk("Disabling port %d(LAG %d)\n", port->actor_port_number, port->aggregator->aggregator_identifier);
+		__disable_port(port);
+	}
+}
+
+#if 0
+/**
+ * ad_marker_info_send - send a marker information frame
+ * @port: the port we're looking at
+ *
+ * This function does nothing since we decided not to implement send and handle
+ * response for marker PDU's, in this stage, but only to respond to marker
+ * information.
+ */
+static void ad_marker_info_send(struct port *port)
+{
+	struct marker marker;
+	u16 index;
+
+	// fill the marker PDU with the appropriate values
+	marker.subtype = 0x02;
+	marker.version_number = 0x01;
+	marker.tlv_type = AD_MARKER_INFORMATION_SUBTYPE;
+	marker.marker_length = 0x16;
+	// convert requester_port to Big Endian
+	marker.requester_port = (((port->actor_port_number & 0xFF) << 8) |((u16)(port->actor_port_number & 0xFF00) >> 8));
+	marker.requester_system = port->actor_system;
+	// convert requester_port(u32) to Big Endian
+	marker.requester_transaction_id = (((++port->transaction_id & 0xFF) << 24) |((port->transaction_id & 0xFF00) << 8) |((port->transaction_id & 0xFF0000) >> 8) |((port->transaction_id & 0xFF000000) >> 24));
+	marker.pad = 0;
+	marker.tlv_type_terminator = 0x00;
+	marker.terminator_length = 0x00;
+	for (index=0; index<90; index++) {
+		marker.reserved_90[index]=0;
+	}
+
+	// send the marker information
+	if (ad_marker_send(port, &marker) >= 0) {
+		dprintk("Sent Marker Information on port %d\n", port->actor_port_number);
+	}
+}
+#endif
+
+/**
+ * ad_marker_info_received - handle receive of a Marker information frame
+ * @marker_info: Marker info received
+ * @port: the port we're looking at
+ *
+ */
+static void ad_marker_info_received(struct marker *marker_info,struct port *port)
+{
+	struct marker marker;
+
+	// copy the received marker data to the response marker
+	//marker = *marker_info;
+	memcpy(&marker, marker_info, sizeof(struct marker));
+	// change the marker subtype to marker response
+	marker.tlv_type=AD_MARKER_RESPONSE_SUBTYPE;
+	// send the marker response
+
+	if (ad_marker_send(port, &marker) >= 0) {
+		dprintk("Sent Marker Response on port %d\n", port->actor_port_number);
+	}
+}
+
+/**
+ * ad_marker_response_received - handle receive of a marker response frame
+ * @marker: marker PDU received
+ * @port: the port we're looking at
+ *
+ * This function does nothing since we decided not to implement send and handle
+ * response for marker PDU's, in this stage, but only to respond to marker
+ * information.
+ */
+static void ad_marker_response_received(struct marker *marker, struct port *port)
+{
+	marker=NULL; // just to satisfy the compiler
+	port=NULL;  // just to satisfy the compiler
+	// DO NOTHING, SINCE WE DECIDED NOT TO IMPLEMENT THIS FEATURE FOR NOW
+}
+
+/**
+ * ad_initialize_lacpdu - initialize a given lacpdu structure
+ * @lacpdu: lacpdu structure to initialize
+ *
+ */
+static void ad_initialize_lacpdu(struct lacpdu *lacpdu)
+{
+	u16 index;
+
+	// initialize lacpdu data
+	lacpdu->subtype = 0x01;
+	lacpdu->version_number = 0x01;
+	lacpdu->tlv_type_actor_info = 0x01;
+	lacpdu->actor_information_length = 0x14;
+	// lacpdu->actor_system_priority    updated on send
+	// lacpdu->actor_system             updated on send
+	// lacpdu->actor_key                updated on send
+	// lacpdu->actor_port_priority      updated on send
+	// lacpdu->actor_port               updated on send
+	// lacpdu->actor_state              updated on send
+	lacpdu->tlv_type_partner_info = 0x02;
+	lacpdu->partner_information_length = 0x14;
+	for (index=0; index<=2; index++) {
+		lacpdu->reserved_3_1[index]=0;
+	}
+	// lacpdu->partner_system_priority  updated on send
+	// lacpdu->partner_system           updated on send
+	// lacpdu->partner_key              updated on send
+	// lacpdu->partner_port_priority    updated on send
+	// lacpdu->partner_port             updated on send
+	// lacpdu->partner_state            updated on send
+	for (index=0; index<=2; index++) {
+		lacpdu->reserved_3_2[index]=0;
+	}
+	lacpdu->tlv_type_collector_info = 0x03;
+	lacpdu->collector_information_length= 0x10;
+	lacpdu->collector_max_delay = AD_COLLECTOR_MAX_DELAY;
+	for (index=0; index<=11; index++) {
+		lacpdu->reserved_12[index]=0;
+	}
+	lacpdu->tlv_type_terminator = 0x00;
+	lacpdu->terminator_length = 0;
+	for (index=0; index<=49; index++) {
+		lacpdu->reserved_50[index]=0;
+	}
+}
+
+//////////////////////////////////////////////////////////////////////////////////////
+// ================= AD exported functions to the main bonding code ==================
+//////////////////////////////////////////////////////////////////////////////////////
+
+// Check aggregators status in team every T seconds
+#define AD_AGGREGATOR_SELECTION_TIMER  8
+
+static u16 aggregator_identifier;
+
+/**
+ * bond_3ad_initialize - initialize a bond's 802.3ad parameters and structures
+ * @bond: bonding struct to work on
+ * @tick_resolution: tick duration (millisecond resolution)
+ * @lacp_fast: boolean. whether fast periodic should be used
+ *
+ * Can be called only after the mac address of the bond is set.
+ */
+void bond_3ad_initialize(struct bonding *bond, u16 tick_resolution, int lacp_fast)
+{                         
+	// check that the bond is not initialized yet
+	if (MAC_ADDRESS_COMPARE(&(BOND_AD_INFO(bond).system.sys_mac_addr), &(bond->dev->dev_addr))) {
+
+		aggregator_identifier = 0;
+
+		BOND_AD_INFO(bond).lacp_fast = lacp_fast;
+		BOND_AD_INFO(bond).system.sys_priority = 0xFFFF;
+		BOND_AD_INFO(bond).system.sys_mac_addr = *((struct mac_addr *)bond->dev->dev_addr);
+
+		// initialize how many times this module is called in one second(should be about every 100ms)
+		ad_ticks_per_sec = tick_resolution;
+
+		// initialize the aggregator selection timer(to activate an aggregation selection after initialize)
+		BOND_AD_INFO(bond).agg_select_timer = (AD_AGGREGATOR_SELECTION_TIMER * ad_ticks_per_sec);
+		BOND_AD_INFO(bond).agg_select_mode = AD_BANDWIDTH;
+	}
+}
+
+/**
+ * bond_3ad_bind_slave - initialize a slave's port
+ * @slave: slave struct to work on
+ *
+ * Returns:   0 on success
+ *          < 0 on error
+ */
+int bond_3ad_bind_slave(struct slave *slave)
+{
+	struct bonding *bond = bond_get_bond_by_slave(slave);
+	struct port *port;
+	struct aggregator *aggregator;
+
+	if (bond == NULL) {
+		printk(KERN_ERR "The slave %s is not attached to its bond\n", slave->dev->name);
+		return -1;
+	}
+
+	//check that the slave has not been intialized yet.
+	if (SLAVE_AD_INFO(slave).port.slave != slave) {
+
+		// port initialization
+		port = &(SLAVE_AD_INFO(slave).port);
+
+		ad_initialize_port(port, BOND_AD_INFO(bond).lacp_fast);
+
+		port->slave = slave;
+		port->actor_port_number = SLAVE_AD_INFO(slave).id;
+		// key is determined according to the link speed, duplex and user key(which is yet not supported)
+		//              ------------------------------------------------------------
+		// Port key :   | User key                       |      Speed       |Duplex|
+		//              ------------------------------------------------------------
+		//              16                               6               1 0
+		port->actor_admin_port_key = 0;	// initialize this parameter
+		port->actor_admin_port_key |= __get_duplex(port);
+		port->actor_admin_port_key |= (__get_link_speed(port) << 1);
+		port->actor_oper_port_key = port->actor_admin_port_key;
+		// if the port is not full duplex, then the port should be not lacp Enabled
+		if (!(port->actor_oper_port_key & AD_DUPLEX_KEY_BITS)) {
+			port->sm_vars &= ~AD_PORT_LACP_ENABLED;
+		}
+		// actor system is the bond's system
+		port->actor_system = BOND_AD_INFO(bond).system.sys_mac_addr;
+		// tx timer(to verify that no more than MAX_TX_IN_SECOND lacpdu's are sent in one second)
+		port->sm_tx_timer_counter = ad_ticks_per_sec/AD_MAX_TX_IN_SECOND;
+		port->aggregator = NULL;
+		port->next_port_in_aggregator = NULL;
+
+		__disable_port(port);
+		__initialize_port_locks(port);
+
+
+		// aggregator initialization
+		aggregator = &(SLAVE_AD_INFO(slave).aggregator);
+
+		ad_initialize_agg(aggregator);
+
+		aggregator->aggregator_mac_address = *((struct mac_addr *)bond->dev->dev_addr);
+		aggregator->aggregator_identifier = (++aggregator_identifier);
+		aggregator->slave = slave;
+		aggregator->is_active = 0;
+		aggregator->num_of_ports = 0;
+	}
+
+	return 0;
+}
+
+/**
+ * bond_3ad_unbind_slave - deinitialize a slave's port
+ * @slave: slave struct to work on
+ *
+ * Search for the aggregator that is related to this port, remove the
+ * aggregator and assign another aggregator for other port related to it
+ * (if any), and remove the port.
+ */
+void bond_3ad_unbind_slave(struct slave *slave)
+{
+	struct port *port, *prev_port, *temp_port;
+	struct aggregator *aggregator, *new_aggregator, *temp_aggregator;
+	int select_new_active_agg = 0;
+	
+	// find the aggregator related to this slave
+	aggregator = &(SLAVE_AD_INFO(slave).aggregator);
+
+	// find the port related to this slave
+	port = &(SLAVE_AD_INFO(slave).port);
+
+	// if slave is null, the whole port is not initialized
+	if (!port->slave) {
+		printk(KERN_WARNING DRV_NAME ": Trying to unbind an uninitialized port on %s\n", slave->dev->name);
+		return;
+	}
+
+	dprintk("Unbinding Link Aggregation Group %d\n", aggregator->aggregator_identifier);
+
+	/* Tell the partner that this port is not suitable for aggregation */
+	port->actor_oper_port_state &= ~AD_STATE_AGGREGATION;
+	__update_lacpdu_from_port(port);
+	ad_lacpdu_send(port);
+
+	// check if this aggregator is occupied
+	if (aggregator->lag_ports) {
+		// check if there are other ports related to this aggregator except
+		// the port related to this slave(thats ensure us that there is a
+		// reason to search for new aggregator, and that we will find one
+		if ((aggregator->lag_ports != port) || (aggregator->lag_ports->next_port_in_aggregator)) {
+			// find new aggregator for the related port(s)
+			new_aggregator = __get_first_agg(port);
+			for (; new_aggregator; new_aggregator = __get_next_agg(new_aggregator)) {
+				// if the new aggregator is empty, or it connected to to our port only
+				if (!new_aggregator->lag_ports || ((new_aggregator->lag_ports == port) && !new_aggregator->lag_ports->next_port_in_aggregator)) {
+					break;
+				}
+			}
+			// if new aggregator found, copy the aggregator's parameters
+			// and connect the related lag_ports to the new aggregator
+			if ((new_aggregator) && ((!new_aggregator->lag_ports) || ((new_aggregator->lag_ports == port) && !new_aggregator->lag_ports->next_port_in_aggregator))) {
+				dprintk("Some port(s) related to LAG %d - replaceing with LAG %d\n", aggregator->aggregator_identifier, new_aggregator->aggregator_identifier);
+
+				if ((new_aggregator->lag_ports == port) && new_aggregator->is_active) {
+					printk(KERN_INFO DRV_NAME ": Removing an active aggregator\n");
+					// select new active aggregator
+					 select_new_active_agg = 1;
+				}
+
+				new_aggregator->is_individual = aggregator->is_individual;
+				new_aggregator->actor_admin_aggregator_key = aggregator->actor_admin_aggregator_key;
+				new_aggregator->actor_oper_aggregator_key = aggregator->actor_oper_aggregator_key;
+				new_aggregator->partner_system = aggregator->partner_system;
+				new_aggregator->partner_system_priority = aggregator->partner_system_priority;
+				new_aggregator->partner_oper_aggregator_key = aggregator->partner_oper_aggregator_key;
+				new_aggregator->receive_state = aggregator->receive_state;
+				new_aggregator->transmit_state = aggregator->transmit_state;
+				new_aggregator->lag_ports = aggregator->lag_ports;
+				new_aggregator->is_active = aggregator->is_active;
+				new_aggregator->num_of_ports = aggregator->num_of_ports;
+
+				// update the information that is written on the ports about the aggregator
+				for (temp_port=aggregator->lag_ports; temp_port; temp_port=temp_port->next_port_in_aggregator) {
+					temp_port->aggregator=new_aggregator;
+					temp_port->actor_port_aggregator_identifier = new_aggregator->aggregator_identifier;
+				}
+
+				// clear the aggregator
+				ad_clear_agg(aggregator);
+				
+				if (select_new_active_agg) {
+					ad_agg_selection_logic(__get_first_agg(port));
+				}
+			} else {
+				printk(KERN_WARNING DRV_NAME ": Warning: unbinding aggregator, "
+				       "and could not find a new aggregator for its ports\n");
+			}
+		} else { // in case that the only port related to this aggregator is the one we want to remove
+			select_new_active_agg = aggregator->is_active;
+			// clear the aggregator
+			ad_clear_agg(aggregator);
+			if (select_new_active_agg) {
+				printk(KERN_INFO "Removing an active aggregator\n");
+				// select new active aggregator
+				ad_agg_selection_logic(__get_first_agg(port));
+			}
+		}
+	}
+
+	dprintk("Unbinding port %d\n", port->actor_port_number);
+	// find the aggregator that this port is connected to
+	temp_aggregator = __get_first_agg(port);
+	for (; temp_aggregator; temp_aggregator = __get_next_agg(temp_aggregator)) {
+		prev_port = NULL;
+		// search the port in the aggregator's related ports
+		for (temp_port=temp_aggregator->lag_ports; temp_port; prev_port=temp_port, temp_port=temp_port->next_port_in_aggregator) {
+			if (temp_port == port) { // the aggregator found - detach the port from this aggregator
+				if (prev_port) {
+					prev_port->next_port_in_aggregator = temp_port->next_port_in_aggregator;
+				} else {
+					temp_aggregator->lag_ports = temp_port->next_port_in_aggregator;
+				}
+				temp_aggregator->num_of_ports--;
+				if (temp_aggregator->num_of_ports==0) {
+					select_new_active_agg = temp_aggregator->is_active;
+					// clear the aggregator
+					ad_clear_agg(temp_aggregator);
+					if (select_new_active_agg) {
+						printk(KERN_INFO "Removing an active aggregator\n");
+						// select new active aggregator
+						ad_agg_selection_logic(__get_first_agg(port));
+					}
+				}
+				break;
+			}
+		}
+	}
+	port->slave=NULL;	
+}
+
+/**
+ * bond_3ad_state_machine_handler - handle state machines timeout
+ * @bond: bonding struct to work on
+ *
+ * The state machine handling concept in this module is to check every tick
+ * which state machine should operate any function. The execution order is
+ * round robin, so when we have an interaction between state machines, the
+ * reply of one to each other might be delayed until next tick.
+ *
+ * This function also complete the initialization when the agg_select_timer
+ * times out, and it selects an aggregator for the ports that are yet not
+ * related to any aggregator, and selects the active aggregator for a bond.
+ */
+void bond_3ad_state_machine_handler(struct bonding *bond)
+{
+	struct port *port;
+	struct aggregator *aggregator;
+
+	read_lock(&bond->lock);
+
+	if (bond->kill_timers) {
+		goto out;
+	}
+
+	//check if there are any slaves
+	if (bond->slave_cnt == 0) {
+		goto re_arm;
+	}
+
+	// check if agg_select_timer timer after initialize is timed out
+	if (BOND_AD_INFO(bond).agg_select_timer && !(--BOND_AD_INFO(bond).agg_select_timer)) {
+		// select the active aggregator for the bond
+		if ((port = __get_first_port(bond))) {
+			if (!port->slave) {
+				printk(KERN_WARNING DRV_NAME ": Warning: bond's first port is uninitialized\n");
+				goto re_arm;
+			}
+
+			aggregator = __get_first_agg(port);
+			ad_agg_selection_logic(aggregator);
+		}
+	}
+
+	// for each port run the state machines
+	for (port = __get_first_port(bond); port; port = __get_next_port(port)) {
+		if (!port->slave) {
+			printk(KERN_WARNING DRV_NAME ": Warning: Found an uninitialized port\n");
+			goto re_arm;
+		}
+
+		ad_rx_machine(NULL, port);
+		ad_periodic_machine(port);
+		ad_port_selection_logic(port);
+		ad_mux_machine(port);
+		ad_tx_machine(port);
+
+		// turn off the BEGIN bit, since we already handled it
+		if (port->sm_vars & AD_PORT_BEGIN) {
+			port->sm_vars &= ~AD_PORT_BEGIN;
+		}
+	}
+
+re_arm:
+	mod_timer(&(BOND_AD_INFO(bond).ad_timer), jiffies + ad_delta_in_ticks);
+out:
+	read_unlock(&bond->lock);
+}
+
+/**
+ * bond_3ad_rx_indication - handle a received frame
+ * @lacpdu: received lacpdu
+ * @slave: slave struct to work on
+ * @length: length of the data received
+ *
+ * It is assumed that frames that were sent on this NIC don't returned as new
+ * received frames (loopback). Since only the payload is given to this
+ * function, it check for loopback.
+ */
+void bond_3ad_rx_indication(struct lacpdu *lacpdu, struct slave *slave, u16 length)
+{
+	struct port *port;
+
+	if (length >= sizeof(struct lacpdu)) {
+
+		port = &(SLAVE_AD_INFO(slave).port);
+
+		if (!port->slave) {
+			printk(KERN_WARNING DRV_NAME ": Warning: port of slave %s is uninitialized\n", slave->dev->name);
+			return;
+		}
+
+		switch (lacpdu->subtype) {
+		case AD_TYPE_LACPDU:
+			__ntohs_lacpdu(lacpdu);
+			dprintk("Received LACPDU on port %d\n", port->actor_port_number);
+			ad_rx_machine(lacpdu, port);
+			break;
+
+		case AD_TYPE_MARKER:
+			// No need to convert fields to Little Endian since we don't use the marker's fields.
+
+			switch (((struct marker *)lacpdu)->tlv_type) {
+			case AD_MARKER_INFORMATION_SUBTYPE:
+				dprintk("Received Marker Information on port %d\n", port->actor_port_number);
+				ad_marker_info_received((struct marker *)lacpdu, port);
+				break;
+
+			case AD_MARKER_RESPONSE_SUBTYPE:
+				dprintk("Received Marker Response on port %d\n", port->actor_port_number);
+				ad_marker_response_received((struct marker *)lacpdu, port);
+				break;
+
+			default:
+				dprintk("Received an unknown Marker subtype on slot %d\n", port->actor_port_number);
+			}
+		}
+	}
+}
+
+/**
+ * bond_3ad_adapter_speed_changed - handle a slave's speed change indication
+ * @slave: slave struct to work on
+ *
+ * Handle reselection of aggregator (if needed) for this port.
+ */
+void bond_3ad_adapter_speed_changed(struct slave *slave)
+{
+	struct port *port;
+
+	port = &(SLAVE_AD_INFO(slave).port);
+
+	// if slave is null, the whole port is not initialized
+	if (!port->slave) {
+		printk(KERN_WARNING DRV_NAME ": Warning: speed changed for uninitialized port on %s\n",
+		       slave->dev->name);
+		return;
+	}
+
+	port->actor_admin_port_key &= ~AD_SPEED_KEY_BITS;
+	port->actor_oper_port_key=port->actor_admin_port_key |= (__get_link_speed(port) << 1);
+	dprintk("Port %d changed speed\n", port->actor_port_number);
+	// there is no need to reselect a new aggregator, just signal the
+	// state machines to reinitialize
+	port->sm_vars |= AD_PORT_BEGIN;
+}
+
+/**
+ * bond_3ad_adapter_duplex_changed - handle a slave's duplex change indication
+ * @slave: slave struct to work on
+ *
+ * Handle reselection of aggregator (if needed) for this port.
+ */
+void bond_3ad_adapter_duplex_changed(struct slave *slave)
+{
+	struct port *port;
+
+	port=&(SLAVE_AD_INFO(slave).port);
+
+	// if slave is null, the whole port is not initialized
+	if (!port->slave) {
+		printk(KERN_WARNING DRV_NAME ": Warning: duplex changed for uninitialized port on %s\n",
+		       slave->dev->name);
+		return;
+	}
+
+	port->actor_admin_port_key &= ~AD_DUPLEX_KEY_BITS;
+	port->actor_oper_port_key=port->actor_admin_port_key |= __get_duplex(port);
+	dprintk("Port %d changed duplex\n", port->actor_port_number);
+	// there is no need to reselect a new aggregator, just signal the
+	// state machines to reinitialize
+	port->sm_vars |= AD_PORT_BEGIN;
+}
+
+/**
+ * bond_3ad_handle_link_change - handle a slave's link status change indication
+ * @slave: slave struct to work on
+ * @status: whether the link is now up or down
+ *
+ * Handle reselection of aggregator (if needed) for this port.
+ */
+void bond_3ad_handle_link_change(struct slave *slave, char link)
+{
+	struct port *port;
+
+	port = &(SLAVE_AD_INFO(slave).port);
+
+	// if slave is null, the whole port is not initialized
+	if (!port->slave) {
+		printk(KERN_WARNING DRV_NAME ": Warning: link status changed for uninitialized port on %s\n",
+			slave->dev->name);
+		return;
+	}
+
+	// on link down we are zeroing duplex and speed since some of the adaptors(ce1000.lan) report full duplex/speed instead of N/A(duplex) / 0(speed)
+	// on link up we are forcing recheck on the duplex and speed since some of he adaptors(ce1000.lan) report
+	if (link == BOND_LINK_UP) {
+		port->is_enabled = 1;
+		port->actor_admin_port_key &= ~AD_DUPLEX_KEY_BITS;
+		port->actor_oper_port_key=port->actor_admin_port_key |= __get_duplex(port);
+		port->actor_admin_port_key &= ~AD_SPEED_KEY_BITS;
+		port->actor_oper_port_key=port->actor_admin_port_key |= (__get_link_speed(port) << 1);
+	} else {
+		/* link has failed */
+		port->is_enabled = 0;
+		port->actor_admin_port_key &= ~AD_DUPLEX_KEY_BITS;
+		port->actor_oper_port_key= (port->actor_admin_port_key &= ~AD_SPEED_KEY_BITS);
+	}
+	//BOND_PRINT_DBG(("Port %d changed link status to %s", port->actor_port_number, ((link == BOND_LINK_UP)?"UP":"DOWN")));
+	// there is no need to reselect a new aggregator, just signal the
+	// state machines to reinitialize
+	port->sm_vars |= AD_PORT_BEGIN;
+}
+
+/**
+ * bond_3ad_get_active_agg_info - get information of the active aggregator
+ * @bond: bonding struct to work on
+ * @ad_info: ad_info struct to fill with the bond's info
+ *
+ * Returns:   0 on success
+ *          < 0 on error
+ */
+int bond_3ad_get_active_agg_info(struct bonding *bond, struct ad_info *ad_info)
+{
+	struct aggregator *aggregator = NULL;
+	struct port *port;
+
+	for (port = __get_first_port(bond); port; port = __get_next_port(port)) {
+		if (port->aggregator && port->aggregator->is_active) {
+			aggregator = port->aggregator;
+			break;
+		}
+	}
+
+	if (aggregator) {
+		ad_info->aggregator_id = aggregator->aggregator_identifier;
+		ad_info->ports = aggregator->num_of_ports;
+		ad_info->actor_key = aggregator->actor_oper_aggregator_key;
+		ad_info->partner_key = aggregator->partner_oper_aggregator_key;
+		memcpy(ad_info->partner_system, aggregator->partner_system.mac_addr_value, ETH_ALEN);
+		return 0;
+	}
+
+	return -1;
+}
+
+int bond_3ad_xmit_xor(struct sk_buff *skb, struct net_device *dev)
+{
+	struct slave *slave, *start_at;
+	struct bonding *bond = dev->priv;
+	struct ethhdr *data = (struct ethhdr *)skb->data;
+	int slave_agg_no;
+	int slaves_in_agg;
+	int agg_id;
+	int i;
+	struct ad_info ad_info;
+	int res = 1;
+
+	/* make sure that the slaves list will
+	 * not change during tx
+	 */
+	read_lock(&bond->lock);
+
+	if (!BOND_IS_OK(bond)) {
+		goto out;
+	}
+
+	if (bond_3ad_get_active_agg_info(bond, &ad_info)) {
+		printk(KERN_DEBUG "ERROR: bond_3ad_get_active_agg_info failed\n");
+		goto out;
+	}
+
+	slaves_in_agg = ad_info.ports;
+	agg_id = ad_info.aggregator_id;
+
+	if (slaves_in_agg == 0) {
+		/*the aggregator is empty*/
+		printk(KERN_DEBUG "ERROR: active aggregator is empty\n");
+		goto out;
+	}
+
+	slave_agg_no = (data->h_dest[5]^bond->dev->dev_addr[5]) % slaves_in_agg;
+
+	bond_for_each_slave(bond, slave, i) {
+		struct aggregator *agg = SLAVE_AD_INFO(slave).port.aggregator;
+
+		if (agg && (agg->aggregator_identifier == agg_id)) {
+			slave_agg_no--;
+			if (slave_agg_no < 0) {
+				break;
+			}
+		}
+	}
+
+	if (slave_agg_no >= 0) {
+		printk(KERN_ERR DRV_NAME ": Error: Couldn't find a slave to tx on for aggregator ID %d\n", agg_id);
+		goto out;
+	}
+
+	start_at = slave;
+
+	bond_for_each_slave_from(bond, slave, i, start_at) {
+		int slave_agg_id = 0;
+		struct aggregator *agg = SLAVE_AD_INFO(slave).port.aggregator;
+
+		if (agg) {
+			slave_agg_id = agg->aggregator_identifier;
+		}
+
+		if (SLAVE_IS_OK(slave) && agg && (slave_agg_id == agg_id)) {
+			res = bond_dev_queue_xmit(bond, skb, slave->dev);
+			break;
+		}
+	}
+
+out:
+	if (res) {
+		/* no suitable interface, frame not sent */
+		dev_kfree_skb(skb);
+	}
+	read_unlock(&bond->lock);
+	return 0;
+}
+
+int bond_3ad_lacpdu_recv(struct sk_buff *skb, struct net_device *dev, struct packet_type* ptype)
+{
+	struct bonding *bond = dev->priv;
+	struct slave *slave = NULL;
+	int ret = NET_RX_DROP;
+
+	if (!(dev->flags & IFF_MASTER)) {
+		goto out;
+	}
+
+	read_lock(&bond->lock);
+	slave = bond_get_slave_by_dev((struct bonding *)dev->priv,
+				      skb->real_dev);
+	if (slave == NULL) {
+		goto out_unlock;
+	}
+
+	bond_3ad_rx_indication((struct lacpdu *) skb->data, slave, skb->len);
+
+	ret = NET_RX_SUCCESS;
+
+out_unlock:
+	read_unlock(&bond->lock);
+out:
+	dev_kfree_skb(skb);
+
+	return ret;
+}
+
diff -urNp linux-8120/drivers/net/bonding/bond_3ad.h linux-8121/drivers/net/bonding/bond_3ad.h
--- linux-8120/drivers/net/bonding/bond_3ad.h
+++ linux-8121/drivers/net/bonding/bond_3ad.h
@@ -0,0 +1,301 @@
+/*
+ * Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ *
+ * Changes:
+ *
+ * 2003/05/01 - Tsippy Mendelson <tsippy.mendelson at intel dot com> and
+ *		Amir Noam <amir.noam at intel dot com>
+ *	- Added support for lacp_rate module param.
+ *
+ * 2003/05/01 - Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Renamed bond_3ad_link_status_changed() to
+ *	  bond_3ad_handle_link_change() for compatibility with TLB.
+ *
+ * 2003/12/01 - Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Code cleanup and style changes
+ */
+
+#ifndef __BOND_3AD_H__
+#define __BOND_3AD_H__
+
+#include <asm/byteorder.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+
+// General definitions
+#define BOND_ETH_P_LACPDU       0x8809
+#define PKT_TYPE_LACPDU         __constant_htons(BOND_ETH_P_LACPDU)
+#define AD_TIMER_INTERVAL       100 /*msec*/
+
+#define MULTICAST_LACPDU_ADDR    {0x01, 0x80, 0xC2, 0x00, 0x00, 0x02}
+#define AD_MULTICAST_LACPDU_ADDR    {MULTICAST_LACPDU_ADDR}
+
+#define AD_LACP_SLOW 0
+#define AD_LACP_FAST 1
+
+typedef struct mac_addr {
+	u8 mac_addr_value[ETH_ALEN];
+} mac_addr_t;
+
+typedef enum {
+	AD_BANDWIDTH = 0,
+	AD_COUNT
+} agg_selection_t;
+
+// rx machine states(43.4.11 in the 802.3ad standard)
+typedef enum {
+	AD_RX_DUMMY,
+	AD_RX_INITIALIZE,     // rx Machine
+	AD_RX_PORT_DISABLED,  // rx Machine
+	AD_RX_LACP_DISABLED,  // rx Machine
+	AD_RX_EXPIRED,	      // rx Machine
+	AD_RX_DEFAULTED,      // rx Machine
+	AD_RX_CURRENT	      // rx Machine
+} rx_states_t;
+
+// periodic machine states(43.4.12 in the 802.3ad standard)
+typedef enum {
+	AD_PERIODIC_DUMMY,
+	AD_NO_PERIODIC,	       // periodic machine
+	AD_FAST_PERIODIC,      // periodic machine
+	AD_SLOW_PERIODIC,      // periodic machine
+	AD_PERIODIC_TX	   // periodic machine
+} periodic_states_t;
+
+// mux machine states(43.4.13 in the 802.3ad standard)
+typedef enum {
+	AD_MUX_DUMMY,
+	AD_MUX_DETACHED,       // mux machine
+	AD_MUX_WAITING,	       // mux machine
+	AD_MUX_ATTACHED,       // mux machine
+	AD_MUX_COLLECTING_DISTRIBUTING // mux machine
+} mux_states_t;
+
+// tx machine states(43.4.15 in the 802.3ad standard)
+typedef enum {
+	AD_TX_DUMMY,
+	AD_TRANSMIT	   // tx Machine
+} tx_states_t;
+
+// rx indication types
+typedef enum {
+	AD_TYPE_LACPDU = 1,    // type lacpdu
+	AD_TYPE_MARKER	   // type marker
+} pdu_type_t;
+
+// rx marker indication types
+typedef enum {
+	AD_MARKER_INFORMATION_SUBTYPE = 1, // marker imformation subtype
+	AD_MARKER_RESPONSE_SUBTYPE     // marker response subtype
+} marker_subtype_t;
+
+// timers types(43.4.9 in the 802.3ad standard)
+typedef enum {
+	AD_CURRENT_WHILE_TIMER,
+	AD_ACTOR_CHURN_TIMER,
+	AD_PERIODIC_TIMER,
+	AD_PARTNER_CHURN_TIMER,
+	AD_WAIT_WHILE_TIMER
+} ad_timers_t;
+
+#pragma pack(1)
+
+typedef struct ad_header {
+	struct mac_addr destination_address;
+	struct mac_addr source_address;
+	u16 length_type;
+} ad_header_t;
+
+// Link Aggregation Control Protocol(LACP) data unit structure(43.4.2.2 in the 802.3ad standard)
+typedef struct lacpdu {
+	u8 subtype;		     // = LACP(= 0x01)
+	u8 version_number;
+	u8 tlv_type_actor_info;	      // = actor information(type/length/value)
+	u8 actor_information_length; // = 20
+	u16 actor_system_priority;
+	struct mac_addr actor_system;
+	u16 actor_key;
+	u16 actor_port_priority;
+	u16 actor_port;
+	u8 actor_state;
+	u8 reserved_3_1[3];	     // = 0
+	u8 tlv_type_partner_info;     // = partner information
+	u8 partner_information_length;	 // = 20
+	u16 partner_system_priority;
+	struct mac_addr partner_system;
+	u16 partner_key;
+	u16 partner_port_priority;
+	u16 partner_port;
+	u8 partner_state;
+	u8 reserved_3_2[3];	     // = 0
+	u8 tlv_type_collector_info;	  // = collector information
+	u8 collector_information_length; // = 16
+	u16 collector_max_delay;
+	u8 reserved_12[12];
+	u8 tlv_type_terminator;	     // = terminator
+	u8 terminator_length;	     // = 0
+	u8 reserved_50[50];	     // = 0
+} lacpdu_t;
+
+typedef struct lacpdu_header {
+	struct ad_header ad_header;
+	struct lacpdu lacpdu;
+} lacpdu_header_t;
+
+// Marker Protocol Data Unit(PDU) structure(43.5.3.2 in the 802.3ad standard)
+typedef struct marker {
+	u8 subtype;		 //  = 0x02  (marker PDU)
+	u8 version_number;	 //  = 0x01
+	u8 tlv_type;		 //  = 0x01  (marker information)
+	//  = 0x02  (marker response information)
+	u8 marker_length;	 //  = 0x16
+	u16 requester_port;	 //   The number assigned to the port by the requester
+	struct mac_addr requester_system;      //   The requester's system id
+	u32 requester_transaction_id;	//   The transaction id allocated by the requester,
+	u16 pad;		 //  = 0
+	u8 tlv_type_terminator;	     //  = 0x00
+	u8 terminator_length;	     //  = 0x00
+	u8 reserved_90[90];	     //  = 0
+} marker_t;
+
+typedef struct marker_header {
+	struct ad_header ad_header;
+	struct marker marker;
+} marker_header_t;
+
+#pragma pack()
+
+struct slave;
+struct bonding;
+struct ad_info;
+struct port;
+
+#ifdef __ia64__
+#pragma pack(8)
+#endif
+
+// aggregator structure(43.4.5 in the 802.3ad standard)
+typedef struct aggregator {
+	struct mac_addr aggregator_mac_address;
+	u16 aggregator_identifier;
+	u16 is_individual;		 // BOOLEAN
+	u16 actor_admin_aggregator_key;
+	u16 actor_oper_aggregator_key;
+	struct mac_addr partner_system;
+	u16 partner_system_priority;
+	u16 partner_oper_aggregator_key;
+	u16 receive_state;		// BOOLEAN
+	u16 transmit_state;		// BOOLEAN
+	struct port *lag_ports;
+	// ****** PRIVATE PARAMETERS ******
+	struct slave *slave;	    // pointer to the bond slave that this aggregator belongs to
+	u16 is_active;	    // BOOLEAN. Indicates if this aggregator is active
+	u16 num_of_ports;
+} aggregator_t;
+
+// port structure(43.4.6 in the 802.3ad standard)
+typedef struct port {
+	u16 actor_port_number;
+	u16 actor_port_priority;
+	struct mac_addr actor_system;	       // This parameter is added here although it is not specified in the standard, just for simplification
+	u16 actor_system_priority;	 // This parameter is added here although it is not specified in the standard, just for simplification
+	u16 actor_port_aggregator_identifier;
+	u16 ntt;			 // BOOLEAN
+	u16 actor_admin_port_key;
+	u16 actor_oper_port_key;
+	u8 actor_admin_port_state;
+	u8 actor_oper_port_state;
+	struct mac_addr partner_admin_system;
+	struct mac_addr partner_oper_system;
+	u16 partner_admin_system_priority;
+	u16 partner_oper_system_priority;
+	u16 partner_admin_key;
+	u16 partner_oper_key;
+	u16 partner_admin_port_number;
+	u16 partner_oper_port_number;
+	u16 partner_admin_port_priority;
+	u16 partner_oper_port_priority;
+	u8 partner_admin_port_state;
+	u8 partner_oper_port_state;
+	u16 is_enabled;	      // BOOLEAN
+	// ****** PRIVATE PARAMETERS ******
+	u16 sm_vars;	      // all state machines variables for this port
+	rx_states_t sm_rx_state;	// state machine rx state
+	u16 sm_rx_timer_counter;    // state machine rx timer counter
+	periodic_states_t sm_periodic_state;// state machine periodic state
+	u16 sm_periodic_timer_counter;	// state machine periodic timer counter
+	mux_states_t sm_mux_state;	// state machine mux state
+	u16 sm_mux_timer_counter;   // state machine mux timer counter
+	tx_states_t sm_tx_state;	// state machine tx state
+	u16 sm_tx_timer_counter;    // state machine tx timer counter(allways on - enter to transmit state 3 time per second)
+	struct slave *slave;	    // pointer to the bond slave that this port belongs to
+	struct aggregator *aggregator;	   // pointer to an aggregator that this port related to
+	struct port *next_port_in_aggregator; // Next port on the linked list of the parent aggregator
+	u32 transaction_id;	    // continuous number for identification of Marker PDU's;
+	struct lacpdu lacpdu;	       // the lacpdu that will be sent for this port
+} port_t;
+
+// system structure
+typedef struct ad_system {
+	u16 sys_priority;
+	struct mac_addr sys_mac_addr;
+} ad_system_t;
+
+#ifdef __ia64__
+#pragma pack()
+#endif
+
+// ================= AD Exported structures to the main bonding code ==================
+#define BOND_AD_INFO(bond)   ((bond)->ad_info)
+#define SLAVE_AD_INFO(slave) ((slave)->ad_info)
+
+struct ad_bond_info {
+	ad_system_t system;	    // 802.3ad system structure
+	u32 agg_select_timer;	    // Timer to select aggregator after all adapter's hand shakes
+	u32 agg_select_mode;	    // Mode of selection of active aggregator(bandwidth/count)
+	int lacp_fast;		/* whether fast periodic tx should be
+				 * requested
+				 */
+	struct timer_list ad_timer;
+	struct packet_type ad_pkt_type;
+};
+
+struct ad_slave_info {
+	struct aggregator aggregator;	    // 802.3ad aggregator structure
+	struct port port;		    // 802.3ad port structure
+	spinlock_t rx_machine_lock; // To avoid race condition between callback and receive interrupt
+	u16 id;
+};
+
+// ================= AD Exported functions to the main bonding code ==================
+void bond_3ad_initialize(struct bonding *bond, u16 tick_resolution, int lacp_fast);
+int  bond_3ad_bind_slave(struct slave *slave);
+void bond_3ad_unbind_slave(struct slave *slave);
+void bond_3ad_state_machine_handler(struct bonding *bond);
+void bond_3ad_rx_indication(struct lacpdu *lacpdu, struct slave *slave, u16 length);
+void bond_3ad_adapter_speed_changed(struct slave *slave);
+void bond_3ad_adapter_duplex_changed(struct slave *slave);
+void bond_3ad_handle_link_change(struct slave *slave, char link);
+int  bond_3ad_get_active_agg_info(struct bonding *bond, struct ad_info *ad_info);
+int bond_3ad_xmit_xor(struct sk_buff *skb, struct net_device *dev);
+int bond_3ad_lacpdu_recv(struct sk_buff *skb, struct net_device *dev, struct packet_type* ptype);
+#endif //__BOND_3AD_H__
+
diff -urNp linux-8120/drivers/net/bonding/bond_alb.c linux-8121/drivers/net/bonding/bond_alb.c
--- linux-8120/drivers/net/bonding/bond_alb.c
+++ linux-8121/drivers/net/bonding/bond_alb.c
@@ -0,0 +1,1689 @@
+/*
+ * Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ *
+ * Changes:
+ *
+ * 2003/06/25 - Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Fixed signed/unsigned calculation errors that caused load sharing
+ *	  to collapse to one slave under very heavy UDP Tx stress.
+ *
+ * 2003/08/06 - Amir Noam <amir.noam at intel dot com>
+ *	- Add support for setting bond's MAC address with special
+ *	  handling required for ALB/TLB.
+ *
+ * 2003/12/01 - Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Code cleanup and style changes
+ *
+ * 2003/12/30 - Amir Noam <amir.noam at intel dot com>
+ *	- Fixed: Cannot remove and re-enslave the original active slave.
+ *
+ * 2004/01/14 - Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Add capability to tag self generated packets in ALB/TLB modes.
+ */
+
+//#define BONDING_DEBUG 1
+
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/pkt_sched.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/if_bonding.h>
+#include <linux/if_vlan.h>
+#include <linux/in.h>
+#include <net/ipx.h>
+#include <net/arp.h>
+#include <asm/byteorder.h>
+#include "bonding.h"
+#include "bond_alb.h"
+
+
+#define ALB_TIMER_TICKS_PER_SEC	    10	/* should be a divisor of HZ */
+#define BOND_TLB_REBALANCE_INTERVAL 10	/* In seconds, periodic re-balancing.
+					 * Used for division - never set
+					 * to zero !!!
+					 */
+#define BOND_ALB_LP_INTERVAL	    1	/* In seconds, periodic send of
+					 * learning packets to the switch
+					 */
+
+#define BOND_TLB_REBALANCE_TICKS (BOND_TLB_REBALANCE_INTERVAL \
+				  * ALB_TIMER_TICKS_PER_SEC)
+
+#define BOND_ALB_LP_TICKS (BOND_ALB_LP_INTERVAL \
+			   * ALB_TIMER_TICKS_PER_SEC)
+
+#define TLB_HASH_TABLE_SIZE 256	/* The size of the clients hash table.
+				 * Note that this value MUST NOT be smaller
+				 * because the key hash table is BYTE wide !
+				 */
+
+
+#define TLB_NULL_INDEX		0xffffffff
+#define MAX_LP_BURST		3
+
+/* rlb defs */
+#define RLB_HASH_TABLE_SIZE	256
+#define RLB_NULL_INDEX		0xffffffff
+#define RLB_UPDATE_DELAY	2*ALB_TIMER_TICKS_PER_SEC /* 2 seconds */
+#define RLB_ARP_BURST_SIZE	2
+#define RLB_UPDATE_RETRY	3	/* 3-ticks - must be smaller than the rlb
+					 * rebalance interval (5 min).
+					 */
+/* RLB_PROMISC_TIMEOUT = 10 sec equals the time that the current slave is
+ * promiscuous after failover
+ */
+#define RLB_PROMISC_TIMEOUT	10*ALB_TIMER_TICKS_PER_SEC
+
+static const u8 mac_bcast[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
+static const int alb_delta_in_ticks = HZ / ALB_TIMER_TICKS_PER_SEC;
+
+#pragma pack(1)
+struct learning_pkt {
+	u8 mac_dst[ETH_ALEN];
+	u8 mac_src[ETH_ALEN];
+	u16 type;
+	u8 padding[ETH_ZLEN - ETH_HLEN];
+};
+
+struct arp_pkt {
+	u16     hw_addr_space;
+	u16     prot_addr_space;
+	u8      hw_addr_len;
+	u8      prot_addr_len;
+	u16     op_code;
+	u8      mac_src[ETH_ALEN];	/* sender hardware address */
+	u32     ip_src;			/* sender IP address */
+	u8      mac_dst[ETH_ALEN];	/* target hardware address */
+	u32     ip_dst;			/* target IP address */
+};
+#pragma pack()
+
+/* Forward declaration */
+static void alb_send_learning_packets(struct slave *slave, u8 mac_addr[]);
+
+static inline u8 _simple_hash(u8 *hash_start, int hash_size)
+{
+	int i;
+	u8 hash = 0;
+
+	for (i = 0; i < hash_size; i++) {
+		hash ^= hash_start[i];
+	}
+
+	return hash;
+}
+
+/*********************** tlb specific functions ***************************/
+
+static inline void _lock_tx_hashtbl(struct bonding *bond)
+{
+	spin_lock(&(BOND_ALB_INFO(bond).tx_hashtbl_lock));
+}
+
+static inline void _unlock_tx_hashtbl(struct bonding *bond)
+{
+	spin_unlock(&(BOND_ALB_INFO(bond).tx_hashtbl_lock));
+}
+
+/* Caller must hold tx_hashtbl lock */
+static inline void tlb_init_table_entry(struct tlb_client_info *entry, int save_load)
+{
+	if (save_load) {
+		entry->load_history = 1 + entry->tx_bytes /
+				      BOND_TLB_REBALANCE_INTERVAL;
+		entry->tx_bytes = 0;
+	}
+
+	entry->tx_slave = NULL;
+	entry->next = TLB_NULL_INDEX;
+	entry->prev = TLB_NULL_INDEX;
+}
+
+static inline void tlb_init_slave(struct slave *slave)
+{
+	SLAVE_TLB_INFO(slave).load = 0;
+	SLAVE_TLB_INFO(slave).head = TLB_NULL_INDEX;
+}
+
+/* Caller must hold bond lock for read */
+static void tlb_clear_slave(struct bonding *bond, struct slave *slave, int save_load)
+{
+	struct tlb_client_info *tx_hash_table;
+	u32 index;
+
+	_lock_tx_hashtbl(bond);
+
+	/* clear slave from tx_hashtbl */
+	tx_hash_table = BOND_ALB_INFO(bond).tx_hashtbl;
+
+	index = SLAVE_TLB_INFO(slave).head;
+	while (index != TLB_NULL_INDEX) {
+		u32 next_index = tx_hash_table[index].next;
+		tlb_init_table_entry(&tx_hash_table[index], save_load);
+		index = next_index;
+	}
+
+	_unlock_tx_hashtbl(bond);
+
+	tlb_init_slave(slave);
+}
+
+/* Must be called before starting the monitor timer */
+static int tlb_initialize(struct bonding *bond)
+{
+	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
+	int size = TLB_HASH_TABLE_SIZE * sizeof(struct tlb_client_info);
+	int i;
+
+	spin_lock_init(&(bond_info->tx_hashtbl_lock));
+
+	_lock_tx_hashtbl(bond);
+
+	bond_info->tx_hashtbl = kmalloc(size, GFP_KERNEL);
+	if (!bond_info->tx_hashtbl) {
+		printk(KERN_ERR DRV_NAME
+		       ": Error: %s: Failed to allocate TLB hash table\n",
+		       bond->dev->name);
+		_unlock_tx_hashtbl(bond);
+		return -1;
+	}
+
+	memset(bond_info->tx_hashtbl, 0, size);
+
+	for (i = 0; i < TLB_HASH_TABLE_SIZE; i++) {
+		tlb_init_table_entry(&bond_info->tx_hashtbl[i], 1);
+	}
+
+	_unlock_tx_hashtbl(bond);
+
+	return 0;
+}
+
+/* Must be called only after all slaves have been released */
+static void tlb_deinitialize(struct bonding *bond)
+{
+	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
+
+	_lock_tx_hashtbl(bond);
+
+	kfree(bond_info->tx_hashtbl);
+	bond_info->tx_hashtbl = NULL;
+
+	_unlock_tx_hashtbl(bond);
+}
+
+/* Caller must hold bond lock for read */
+static struct slave *tlb_get_least_loaded_slave(struct bonding *bond)
+{
+	struct slave *slave, *least_loaded;
+	s64 max_gap;
+	int i, found = 0;
+
+	/* Find the first enabled slave */
+	bond_for_each_slave(bond, slave, i) {
+		if (SLAVE_IS_OK(slave)) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found) {
+		return NULL;
+	}
+
+	least_loaded = slave;
+	max_gap = (s64)(slave->speed << 20) - /* Convert to Megabit per sec */
+			(s64)(SLAVE_TLB_INFO(slave).load << 3); /* Bytes to bits */
+
+	/* Find the slave with the largest gap */
+	bond_for_each_slave_from(bond, slave, i, least_loaded) {
+		if (SLAVE_IS_OK(slave)) {
+			s64 gap = (s64)(slave->speed << 20) -
+					(s64)(SLAVE_TLB_INFO(slave).load << 3);
+			if (max_gap < gap) {
+				least_loaded = slave;
+				max_gap = gap;
+			}
+		}
+	}
+
+	return least_loaded;
+}
+
+/* Caller must hold bond lock for read */
+struct slave *tlb_choose_channel(struct bonding *bond, u32 hash_index, u32 skb_len)
+{
+	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
+	struct tlb_client_info *hash_table;
+	struct slave *assigned_slave;
+
+	_lock_tx_hashtbl(bond);
+
+	hash_table = bond_info->tx_hashtbl;
+	assigned_slave = hash_table[hash_index].tx_slave;
+	if (!assigned_slave) {
+		assigned_slave = tlb_get_least_loaded_slave(bond);
+
+		if (assigned_slave) {
+			struct tlb_slave_info *slave_info =
+				&(SLAVE_TLB_INFO(assigned_slave));
+			u32 next_index = slave_info->head;
+
+			hash_table[hash_index].tx_slave = assigned_slave;
+			hash_table[hash_index].next = next_index;
+			hash_table[hash_index].prev = TLB_NULL_INDEX;
+
+			if (next_index != TLB_NULL_INDEX) {
+				hash_table[next_index].prev = hash_index;
+			}
+
+			slave_info->head = hash_index;
+			slave_info->load +=
+				hash_table[hash_index].load_history;
+		}
+	}
+
+	if (assigned_slave) {
+		hash_table[hash_index].tx_bytes += skb_len;
+	}
+
+	_unlock_tx_hashtbl(bond);
+
+	return assigned_slave;
+}
+
+/*********************** rlb specific functions ***************************/
+static inline void _lock_rx_hashtbl(struct bonding *bond)
+{
+	spin_lock(&(BOND_ALB_INFO(bond).rx_hashtbl_lock));
+}
+
+static inline void _unlock_rx_hashtbl(struct bonding *bond)
+{
+	spin_unlock(&(BOND_ALB_INFO(bond).rx_hashtbl_lock));
+}
+
+/* when an ARP REPLY is received from a client update its info
+ * in the rx_hashtbl
+ */
+static void rlb_update_entry_from_arp(struct bonding *bond, struct arp_pkt *arp)
+{
+	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
+	struct rlb_client_info *client_info;
+	u32 hash_index;
+
+	_lock_rx_hashtbl(bond);
+
+	hash_index = _simple_hash((u8*)&(arp->ip_src), sizeof(arp->ip_src));
+	client_info = &(bond_info->rx_hashtbl[hash_index]);
+
+	if ((client_info->assigned) &&
+	    (client_info->ip_src == arp->ip_dst) &&
+	    (client_info->ip_dst == arp->ip_src)) {
+		/* update the clients MAC address */
+		memcpy(client_info->mac_dst, arp->mac_src, ETH_ALEN);
+		client_info->ntt = 1;
+		bond_info->rx_ntt = 1;
+	}
+
+	_unlock_rx_hashtbl(bond);
+}
+
+static int rlb_arp_recv(struct sk_buff *skb, struct net_device *bond_dev, struct packet_type *ptype)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct arp_pkt *arp = (struct arp_pkt *)skb->data;
+	int res = NET_RX_DROP;
+
+	if (!(bond_dev->flags & IFF_MASTER)) {
+		goto out;
+	}
+
+	if (!arp) {
+		dprintk("Packet has no ARP data\n");
+		goto out;
+	}
+
+	if (skb->len < sizeof(struct arp_pkt)) {
+		dprintk("Packet is too small to be an ARP\n");
+		goto out;
+	}
+
+	if (arp->op_code == htons(ARPOP_REPLY)) {
+		/* update rx hash table for this ARP */
+		rlb_update_entry_from_arp(bond, arp);
+		dprintk("Server received an ARP Reply from client\n");
+	}
+
+	res = NET_RX_SUCCESS;
+
+out:
+	dev_kfree_skb(skb);
+
+	return res;
+}
+
+/* Caller must hold bond lock for read */
+static struct slave *rlb_next_rx_slave(struct bonding *bond)
+{
+	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
+	struct slave *rx_slave, *slave, *start_at;
+	int i = 0;
+
+	if (bond_info->next_rx_slave) {
+		start_at = bond_info->next_rx_slave;
+	} else {
+		start_at = bond->first_slave;
+	}
+
+	rx_slave = NULL;
+
+	bond_for_each_slave_from(bond, slave, i, start_at) {
+		if (SLAVE_IS_OK(slave)) {
+			if (!rx_slave) {
+				rx_slave = slave;
+			} else if (slave->speed > rx_slave->speed) {
+				rx_slave = slave;
+			}
+		}
+	}
+
+	if (rx_slave) {
+		bond_info->next_rx_slave = rx_slave->next;
+	}
+
+	return rx_slave;
+}
+
+/* teach the switch the mac of a disabled slave
+ * on the primary for fault tolerance
+ *
+ * Caller must hold bond->curr_slave_lock for write or bond lock for write
+ */
+static void rlb_teach_disabled_mac_on_primary(struct bonding *bond, u8 addr[])
+{
+	if (!bond->curr_active_slave) {
+		return;
+	}
+
+	if (!bond->alb_info.primary_is_promisc) {
+		bond->alb_info.primary_is_promisc = 1;
+		dev_set_promiscuity(bond->curr_active_slave->dev, 1);
+	}
+
+	bond->alb_info.rlb_promisc_timeout_counter = 0;
+
+	alb_send_learning_packets(bond->curr_active_slave, addr);
+}
+
+/* slave being removed should not be active at this point
+ *
+ * Caller must hold bond lock for read
+ */
+static void rlb_clear_slave(struct bonding *bond, struct slave *slave)
+{
+	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
+	struct rlb_client_info *rx_hash_table;
+	u32 index, next_index;
+
+	/* clear slave from rx_hashtbl */
+	_lock_rx_hashtbl(bond);
+
+	rx_hash_table = bond_info->rx_hashtbl;
+	index = bond_info->rx_hashtbl_head;
+	for (; index != RLB_NULL_INDEX; index = next_index) {
+		next_index = rx_hash_table[index].next;
+		if (rx_hash_table[index].slave == slave) {
+			struct slave *assigned_slave = rlb_next_rx_slave(bond);
+
+			if (assigned_slave) {
+				rx_hash_table[index].slave = assigned_slave;
+				if (memcmp(rx_hash_table[index].mac_dst,
+					   mac_bcast, ETH_ALEN)) {
+					bond_info->rx_hashtbl[index].ntt = 1;
+					bond_info->rx_ntt = 1;
+					/* A slave has been removed from the
+					 * table because it is either disabled
+					 * or being released. We must retry the
+					 * update to avoid clients from not
+					 * being updated & disconnecting when
+					 * there is stress
+					 */
+					bond_info->rlb_update_retry_counter =
+						RLB_UPDATE_RETRY;
+				}
+			} else {  /* there is no active slave */
+				rx_hash_table[index].slave = NULL;
+			}
+		}
+	}
+
+	_unlock_rx_hashtbl(bond);
+
+	write_lock(&bond->curr_slave_lock);
+
+	if (slave != bond->curr_active_slave) {
+		rlb_teach_disabled_mac_on_primary(bond, slave->dev->dev_addr);
+	}
+
+	write_unlock(&bond->curr_slave_lock);
+}
+
+static void rlb_update_client(struct rlb_client_info *client_info)
+{
+	int i;
+
+	if (!client_info->slave) {
+		return;
+	}
+
+	for (i = 0; i < RLB_ARP_BURST_SIZE; i++) {
+		struct sk_buff *skb;
+
+		skb = arp_create(ARPOP_REPLY, ETH_P_ARP,
+				 client_info->ip_dst,
+				 client_info->slave->dev,
+				 client_info->ip_src,
+				 client_info->mac_dst,
+				 client_info->slave->dev->dev_addr,
+				 client_info->mac_dst);
+		if (!skb) {
+			printk(KERN_ERR DRV_NAME
+			       ": Error: failed to create an ARP packet\n");
+			continue;
+		}
+
+		skb->dev = client_info->slave->dev;
+
+		if (client_info->tag) {
+			skb = vlan_put_tag(skb, client_info->vlan_id);
+			if (!skb) {
+				printk(KERN_ERR DRV_NAME
+				       ": Error: failed to insert VLAN tag\n");
+				continue;
+			}
+		}
+
+		arp_xmit(skb);
+	}
+}
+
+/* sends ARP REPLIES that update the clients that need updating */
+static void rlb_update_rx_clients(struct bonding *bond)
+{
+	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
+	struct rlb_client_info *client_info;
+	u32 hash_index;
+
+	_lock_rx_hashtbl(bond);
+
+	hash_index = bond_info->rx_hashtbl_head;
+	for (; hash_index != RLB_NULL_INDEX; hash_index = client_info->next) {
+		client_info = &(bond_info->rx_hashtbl[hash_index]);
+		if (client_info->ntt) {
+			rlb_update_client(client_info);
+			if (bond_info->rlb_update_retry_counter == 0) {
+				client_info->ntt = 0;
+			}
+		}
+	}
+
+	/* do not update the entries again untill this counter is zero so that
+	 * not to confuse the clients.
+	 */
+	bond_info->rlb_update_delay_counter = RLB_UPDATE_DELAY;
+
+	_unlock_rx_hashtbl(bond);
+}
+
+/* The slave was assigned a new mac address - update the clients */
+static void rlb_req_update_slave_clients(struct bonding *bond, struct slave *slave)
+{
+	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
+	struct rlb_client_info *client_info;
+	int ntt = 0;
+	u32 hash_index;
+
+	_lock_rx_hashtbl(bond);
+
+	hash_index = bond_info->rx_hashtbl_head;
+	for (; hash_index != RLB_NULL_INDEX; hash_index = client_info->next) {
+		client_info = &(bond_info->rx_hashtbl[hash_index]);
+
+		if ((client_info->slave == slave) &&
+		    memcmp(client_info->mac_dst, mac_bcast, ETH_ALEN)) {
+			client_info->ntt = 1;
+			ntt = 1;
+		}
+	}
+
+	// update the team's flag only after the whole iteration
+	if (ntt) {
+		bond_info->rx_ntt = 1;
+		//fasten the change
+		bond_info->rlb_update_retry_counter = RLB_UPDATE_RETRY;
+	}
+
+	_unlock_rx_hashtbl(bond);
+}
+
+/* mark all clients using src_ip to be updated */
+static void rlb_req_update_subnet_clients(struct bonding *bond, u32 src_ip)
+{
+	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
+	struct rlb_client_info *client_info;
+	u32 hash_index;
+
+	_lock_rx_hashtbl(bond);
+
+	hash_index = bond_info->rx_hashtbl_head;
+	for (; hash_index != RLB_NULL_INDEX; hash_index = client_info->next) {
+		client_info = &(bond_info->rx_hashtbl[hash_index]);
+
+		if (!client_info->slave) {
+			printk(KERN_ERR DRV_NAME
+			       ": Error: found a client with no channel in "
+			       "the client's hash table\n");
+			continue;
+		}
+		/*update all clients using this src_ip, that are not assigned
+		 * to the team's address (curr_active_slave) and have a known
+		 * unicast mac address.
+		 */
+		if ((client_info->ip_src == src_ip) &&
+		    memcmp(client_info->slave->dev->dev_addr,
+			   bond->dev->dev_addr, ETH_ALEN) &&
+		    memcmp(client_info->mac_dst, mac_bcast, ETH_ALEN)) {
+			client_info->ntt = 1;
+			bond_info->rx_ntt = 1;
+		}
+	}
+
+	_unlock_rx_hashtbl(bond);
+}
+
+/* Caller must hold both bond and ptr locks for read */
+struct slave *rlb_choose_channel(struct sk_buff *skb, struct bonding *bond)
+{
+	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
+	struct arp_pkt *arp = (struct arp_pkt *)skb->nh.raw;
+	struct slave *assigned_slave;
+	struct rlb_client_info *client_info;
+	u32 hash_index = 0;
+
+	_lock_rx_hashtbl(bond);
+
+	hash_index = _simple_hash((u8 *)&arp->ip_dst, sizeof(arp->ip_src));
+	client_info = &(bond_info->rx_hashtbl[hash_index]);
+
+	if (client_info->assigned) {
+		if ((client_info->ip_src == arp->ip_src) &&
+		    (client_info->ip_dst == arp->ip_dst)) {
+			/* the entry is already assigned to this client */
+			if (memcmp(arp->mac_dst, mac_bcast, ETH_ALEN)) {
+				/* update mac address from arp */
+				memcpy(client_info->mac_dst, arp->mac_dst, ETH_ALEN);
+			}
+
+			assigned_slave = client_info->slave;
+			if (assigned_slave) {
+				_unlock_rx_hashtbl(bond);
+				return assigned_slave;
+			}
+		} else {
+			/* the entry is already assigned to some other client,
+			 * move the old client to primary (curr_active_slave) so
+			 * that the new client can be assigned to this entry.
+			 */
+			if (bond->curr_active_slave &&
+			    client_info->slave != bond->curr_active_slave) {
+				client_info->slave = bond->curr_active_slave;
+				rlb_update_client(client_info);
+			}
+		}
+	}
+	/* assign a new slave */
+	assigned_slave = rlb_next_rx_slave(bond);
+
+	if (assigned_slave) {
+		client_info->ip_src = arp->ip_src;
+		client_info->ip_dst = arp->ip_dst;
+		/* arp->mac_dst is broadcast for arp reqeusts.
+		 * will be updated with clients actual unicast mac address
+		 * upon receiving an arp reply.
+		 */
+		memcpy(client_info->mac_dst, arp->mac_dst, ETH_ALEN);
+		client_info->slave = assigned_slave;
+
+		if (memcmp(client_info->mac_dst, mac_bcast, ETH_ALEN)) {
+			client_info->ntt = 1;
+			bond->alb_info.rx_ntt = 1;
+		} else {
+			client_info->ntt = 0;
+		}
+
+		if (!list_empty(&bond->vlan_list)) {
+			unsigned short vlan_id;
+			int res = vlan_get_tag(skb, &vlan_id);
+			if (!res) {
+				client_info->tag = 1;
+				client_info->vlan_id = vlan_id;
+			}
+		}
+
+		if (!client_info->assigned) {
+			u32 prev_tbl_head = bond_info->rx_hashtbl_head;
+			bond_info->rx_hashtbl_head = hash_index;
+			client_info->next = prev_tbl_head;
+			if (prev_tbl_head != RLB_NULL_INDEX) {
+				bond_info->rx_hashtbl[prev_tbl_head].prev =
+					hash_index;
+			}
+			client_info->assigned = 1;
+		}
+	}
+
+	_unlock_rx_hashtbl(bond);
+
+	return assigned_slave;
+}
+
+/* chooses (and returns) transmit channel for arp reply
+ * does not choose channel for other arp types since they are
+ * sent on the curr_active_slave
+ */
+static struct slave *rlb_arp_xmit(struct sk_buff *skb, struct bonding *bond)
+{
+	struct arp_pkt *arp = (struct arp_pkt *)skb->nh.raw;
+	struct slave *tx_slave = NULL;
+
+	if (arp->op_code == __constant_htons(ARPOP_REPLY)) {
+		/* the arp must be sent on the selected
+		* rx channel
+		*/
+		tx_slave = rlb_choose_channel(skb, bond);
+		if (tx_slave) {
+			memcpy(arp->mac_src,tx_slave->dev->dev_addr, ETH_ALEN);
+		}
+		dprintk("Server sent ARP Reply packet\n");
+	} else if (arp->op_code == __constant_htons(ARPOP_REQUEST)) {
+		/* Create an entry in the rx_hashtbl for this client as a
+		 * place holder.
+		 * When the arp reply is received the entry will be updated
+		 * with the correct unicast address of the client.
+		 */
+		rlb_choose_channel(skb, bond);
+
+		/* The ARP relpy packets must be delayed so that
+		 * they can cancel out the influence of the ARP request.
+		 */
+		bond->alb_info.rlb_update_delay_counter = RLB_UPDATE_DELAY;
+
+		/* arp requests are broadcast and are sent on the primary
+		 * the arp request will collapse all clients on the subnet to
+		 * the primary slave. We must register these clients to be
+		 * updated with their assigned mac.
+		 */
+		rlb_req_update_subnet_clients(bond, arp->ip_src);
+		dprintk("Server sent ARP Request packet\n");
+	}
+
+	return tx_slave;
+}
+
+/* Caller must hold bond lock for read */
+static void rlb_rebalance(struct bonding *bond)
+{
+	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
+	struct slave *assigned_slave;
+	struct rlb_client_info *client_info;
+	int ntt;
+	u32 hash_index;
+
+	_lock_rx_hashtbl(bond);
+
+	ntt = 0;
+	hash_index = bond_info->rx_hashtbl_head;
+	for (; hash_index != RLB_NULL_INDEX; hash_index = client_info->next) {
+		client_info = &(bond_info->rx_hashtbl[hash_index]);
+		assigned_slave = rlb_next_rx_slave(bond);
+		if (assigned_slave && (client_info->slave != assigned_slave)) {
+			client_info->slave = assigned_slave;
+			client_info->ntt = 1;
+			ntt = 1;
+		}
+	}
+
+	/* update the team's flag only after the whole iteration */
+	if (ntt) {
+		bond_info->rx_ntt = 1;
+	}
+	_unlock_rx_hashtbl(bond);
+}
+
+/* Caller must hold rx_hashtbl lock */
+static void rlb_init_table_entry(struct rlb_client_info *entry)
+{
+	memset(entry, 0, sizeof(struct rlb_client_info));
+	entry->next = RLB_NULL_INDEX;
+	entry->prev = RLB_NULL_INDEX;
+}
+
+static int rlb_initialize(struct bonding *bond)
+{
+	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
+	struct packet_type *pk_type = &(BOND_ALB_INFO(bond).rlb_pkt_type);
+	int size = RLB_HASH_TABLE_SIZE * sizeof(struct rlb_client_info);
+	int i;
+
+	spin_lock_init(&(bond_info->rx_hashtbl_lock));
+
+	_lock_rx_hashtbl(bond);
+
+	bond_info->rx_hashtbl = kmalloc(size, GFP_KERNEL);
+	if (!bond_info->rx_hashtbl) {
+		printk(KERN_ERR DRV_NAME
+		       ": Error: %s: Failed to allocate RLB hash table\n",
+		       bond->dev->name);
+		_unlock_rx_hashtbl(bond);
+		return -1;
+	}
+
+	bond_info->rx_hashtbl_head = RLB_NULL_INDEX;
+
+	for (i = 0; i < RLB_HASH_TABLE_SIZE; i++) {
+		rlb_init_table_entry(bond_info->rx_hashtbl + i);
+	}
+
+	_unlock_rx_hashtbl(bond);
+
+	/*initialize packet type*/
+	pk_type->type = __constant_htons(ETH_P_ARP);
+	pk_type->dev = bond->dev;
+	pk_type->func = rlb_arp_recv;
+	pk_type->data = (void*)1;  /* understand shared skbs */
+
+	/* register to receive ARPs */
+	dev_add_pack(pk_type);
+
+	return 0;
+}
+
+static void rlb_deinitialize(struct bonding *bond)
+{
+	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
+
+	dev_remove_pack(&(bond_info->rlb_pkt_type));
+
+	_lock_rx_hashtbl(bond);
+
+	kfree(bond_info->rx_hashtbl);
+	bond_info->rx_hashtbl = NULL;
+	bond_info->rx_hashtbl_head = RLB_NULL_INDEX;
+
+	_unlock_rx_hashtbl(bond);
+}
+
+static void rlb_clear_vlan(struct bonding *bond, unsigned short vlan_id)
+{
+	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
+	u32 curr_index;
+
+	_lock_rx_hashtbl(bond);
+
+	curr_index = bond_info->rx_hashtbl_head;
+	while (curr_index != RLB_NULL_INDEX) {
+		struct rlb_client_info *curr = &(bond_info->rx_hashtbl[curr_index]);
+		u32 next_index = bond_info->rx_hashtbl[curr_index].next;
+		u32 prev_index = bond_info->rx_hashtbl[curr_index].prev;
+
+		if (curr->tag && (curr->vlan_id == vlan_id)) {
+			if (curr_index == bond_info->rx_hashtbl_head) {
+				bond_info->rx_hashtbl_head = next_index;
+			}
+			if (prev_index != RLB_NULL_INDEX) {
+				bond_info->rx_hashtbl[prev_index].next = next_index;
+			}
+			if (next_index != RLB_NULL_INDEX) {
+				bond_info->rx_hashtbl[next_index].prev = prev_index;
+			}
+
+			rlb_init_table_entry(curr);
+		}
+
+		curr_index = next_index;
+	}
+
+	_unlock_rx_hashtbl(bond);
+}
+
+/*********************** tlb/rlb shared functions *********************/
+
+static void alb_send_learning_packets(struct slave *slave, u8 mac_addr[])
+{
+	struct bonding *bond = bond_get_bond_by_slave(slave);
+	struct learning_pkt pkt;
+	int size = sizeof(struct learning_pkt);
+	int i;
+
+	memset(&pkt, 0, size);
+	memcpy(pkt.mac_dst, mac_addr, ETH_ALEN);
+	memcpy(pkt.mac_src, mac_addr, ETH_ALEN);
+	pkt.type = __constant_htons(ETH_P_LOOP);
+
+	for (i = 0; i < MAX_LP_BURST; i++) {
+		struct sk_buff *skb;
+		char *data;
+
+		skb = dev_alloc_skb(size);
+		if (!skb) {
+			return;
+		}
+
+		data = skb_put(skb, size);
+		memcpy(data, &pkt, size);
+
+		skb->mac.raw = data;
+		skb->nh.raw = data + ETH_HLEN;
+		skb->protocol = pkt.type;
+		skb->priority = TC_PRIO_CONTROL;
+		skb->dev = slave->dev;
+
+		if (!list_empty(&bond->vlan_list)) {
+			struct vlan_entry *vlan;
+
+			vlan = bond_next_vlan(bond,
+					      bond->alb_info.current_alb_vlan);
+
+			bond->alb_info.current_alb_vlan = vlan;
+			if (!vlan) {
+				kfree_skb(skb);
+				continue;
+			}
+
+			skb = vlan_put_tag(skb, vlan->vlan_id);
+			if (!skb) {
+				printk(KERN_ERR DRV_NAME
+				       ": Error: failed to insert VLAN tag\n");
+				continue;
+			}
+		}
+
+		dev_queue_xmit(skb);
+	}
+}
+
+/* hw is a boolean parameter that determines whether we should try and
+ * set the hw address of the device as well as the hw address of the
+ * net_device
+ */
+static int alb_set_slave_mac_addr(struct slave *slave, u8 addr[], int hw)
+{
+	struct net_device *dev = slave->dev;
+	struct sockaddr s_addr;
+
+	if (!hw) {
+		memcpy(dev->dev_addr, addr, dev->addr_len);
+		return 0;
+	}
+
+	/* for rlb each slave must have a unique hw mac addresses so that */
+	/* each slave will receive packets destined to a different mac */
+	memcpy(s_addr.sa_data, addr, dev->addr_len);
+	s_addr.sa_family = dev->type;
+	if (dev->set_mac_address(dev, &s_addr)) {
+		printk(KERN_ERR DRV_NAME
+		       ": Error: dev->set_mac_address of dev %s failed! ALB "
+		       "mode requires that the base driver support setting "
+		       "the hw address also when the network device's "
+		       "interface is open\n",
+		       dev->name);
+		return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
+/* Caller must hold bond lock for write or curr_slave_lock for write*/
+static void alb_swap_mac_addr(struct bonding *bond, struct slave *slave1, struct slave *slave2)
+{
+	struct slave *disabled_slave = NULL;
+	u8 tmp_mac_addr[ETH_ALEN];
+	int slaves_state_differ;
+
+	slaves_state_differ = (SLAVE_IS_OK(slave1) != SLAVE_IS_OK(slave2));
+
+	memcpy(tmp_mac_addr, slave1->dev->dev_addr, ETH_ALEN);
+	alb_set_slave_mac_addr(slave1, slave2->dev->dev_addr, bond->alb_info.rlb_enabled);
+	alb_set_slave_mac_addr(slave2, tmp_mac_addr, bond->alb_info.rlb_enabled);
+
+	/* fasten the change in the switch */
+	if (SLAVE_IS_OK(slave1)) {
+		alb_send_learning_packets(slave1, slave1->dev->dev_addr);
+		if (bond->alb_info.rlb_enabled) {
+			/* inform the clients that the mac address
+			 * has changed
+			 */
+			rlb_req_update_slave_clients(bond, slave1);
+		}
+	} else {
+		disabled_slave = slave1;
+	}
+
+	if (SLAVE_IS_OK(slave2)) {
+		alb_send_learning_packets(slave2, slave2->dev->dev_addr);
+		if (bond->alb_info.rlb_enabled) {
+			/* inform the clients that the mac address
+			 * has changed
+			 */
+			rlb_req_update_slave_clients(bond, slave2);
+		}
+	} else {
+		disabled_slave = slave2;
+	}
+
+	if (bond->alb_info.rlb_enabled && slaves_state_differ) {
+		/* A disabled slave was assigned an active mac addr */
+		rlb_teach_disabled_mac_on_primary(bond,
+						  disabled_slave->dev->dev_addr);
+	}
+}
+
+/**
+ * alb_change_hw_addr_on_detach
+ * @bond: bonding we're working on
+ * @slave: the slave that was just detached
+ *
+ * We assume that @slave was already detached from the slave list.
+ *
+ * If @slave's permanent hw address is different both from its current
+ * address and from @bond's address, then somewhere in the bond there's
+ * a slave that has @slave's permanet address as its current address.
+ * We'll make sure that that slave no longer uses @slave's permanent address.
+ *
+ * Caller must hold bond lock
+ */
+static void alb_change_hw_addr_on_detach(struct bonding *bond, struct slave *slave)
+{
+	int perm_curr_diff;
+	int perm_bond_diff;
+
+	perm_curr_diff = memcmp(slave->perm_hwaddr,
+				slave->dev->dev_addr,
+				ETH_ALEN);
+	perm_bond_diff = memcmp(slave->perm_hwaddr,
+				bond->dev->dev_addr,
+				ETH_ALEN);
+
+	if (perm_curr_diff && perm_bond_diff) {
+		struct slave *tmp_slave;
+		int i, found = 0;
+
+		bond_for_each_slave(bond, tmp_slave, i) {
+			if (!memcmp(slave->perm_hwaddr,
+				    tmp_slave->dev->dev_addr,
+				    ETH_ALEN)) {
+				found = 1;
+				break;
+			}
+		}
+
+		if (found) {
+			alb_swap_mac_addr(bond, slave, tmp_slave);
+		}
+	}
+}
+
+/**
+ * alb_handle_addr_collision_on_attach
+ * @bond: bonding we're working on
+ * @slave: the slave that was just attached
+ *
+ * checks uniqueness of slave's mac address and handles the case the
+ * new slave uses the bonds mac address.
+ *
+ * If the permanent hw address of @slave is @bond's hw address, we need to
+ * find a different hw address to give @slave, that isn't in use by any other
+ * slave in the bond. This address must be, of course, one of the premanent
+ * addresses of the other slaves.
+ *
+ * We go over the slave list, and for each slave there we compare its
+ * permanent hw address with the current address of all the other slaves.
+ * If no match was found, then we've found a slave with a permanent address
+ * that isn't used by any other slave in the bond, so we can assign it to
+ * @slave.
+ *
+ * assumption: this function is called before @slave is attached to the
+ * 	       bond slave list.
+ *
+ * caller must hold the bond lock for write since the mac addresses are compared
+ * and may be swapped.
+ */
+static int alb_handle_addr_collision_on_attach(struct bonding *bond, struct slave *slave)
+{
+	struct slave *tmp_slave1, *tmp_slave2, *free_mac_slave;
+	struct slave *has_bond_addr = bond->curr_active_slave;
+	int i, j, found = 0;
+
+	if (bond->slave_cnt == 0) {
+		/* this is the first slave */
+		return 0;
+	}
+
+	/* if slave's mac address differs from bond's mac address
+	 * check uniqueness of slave's mac address against the other
+	 * slaves in the bond.
+	 */
+	if (memcmp(slave->perm_hwaddr, bond->dev->dev_addr, ETH_ALEN)) {
+		bond_for_each_slave(bond, tmp_slave1, i) {
+			if (!memcmp(tmp_slave1->dev->dev_addr, slave->dev->dev_addr,
+				    ETH_ALEN)) {
+				found = 1;
+				break;
+			}
+		}
+
+		if (!found)
+			return 0;
+
+		/* Try setting slave mac to bond address and fall-through
+		   to code handling that situation below... */
+		alb_set_slave_mac_addr(slave, bond->dev->dev_addr,
+				       bond->alb_info.rlb_enabled);
+	}
+
+	/* The slave's address is equal to the address of the bond.
+	 * Search for a spare address in the bond for this slave.
+	 */
+	free_mac_slave = NULL;
+
+	bond_for_each_slave(bond, tmp_slave1, i) {
+		found = 0;
+		bond_for_each_slave(bond, tmp_slave2, j) {
+			if (!memcmp(tmp_slave1->perm_hwaddr,
+				    tmp_slave2->dev->dev_addr,
+				    ETH_ALEN)) {
+				found = 1;
+				break;
+			}
+		}
+
+		if (!found) {
+			/* no slave has tmp_slave1's perm addr
+			 * as its curr addr
+			 */
+			free_mac_slave = tmp_slave1;
+			break;
+		}
+
+		if (!has_bond_addr) {
+			if (!memcmp(tmp_slave1->dev->dev_addr,
+				    bond->dev->dev_addr,
+				    ETH_ALEN)) {
+
+				has_bond_addr = tmp_slave1;
+			}
+		}
+	}
+
+	if (free_mac_slave) {
+		alb_set_slave_mac_addr(slave, free_mac_slave->perm_hwaddr,
+				       bond->alb_info.rlb_enabled);
+
+		printk(KERN_WARNING DRV_NAME
+		       ": Warning: the hw address of slave %s is in use by "
+		       "the bond; giving it the hw address of %s\n",
+		       slave->dev->name, free_mac_slave->dev->name);
+
+	} else if (has_bond_addr) {
+		printk(KERN_ERR DRV_NAME
+		       ": Error: the hw address of slave %s is in use by the "
+		       "bond; couldn't find a slave with a free hw address to "
+		       "give it (this should not have happened)\n",
+		       slave->dev->name);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/**
+ * alb_set_mac_address
+ * @bond:
+ * @addr:
+ *
+ * In TLB mode all slaves are configured to the bond's hw address, but set
+ * their dev_addr field to different addresses (based on their permanent hw
+ * addresses).
+ *
+ * For each slave, this function sets the interface to the new address and then
+ * changes its dev_addr field to its previous value.
+ *
+ * Unwinding assumes bond's mac address has not yet changed.
+ */
+static int alb_set_mac_address(struct bonding *bond, void *addr)
+{
+	struct sockaddr sa;
+	struct slave *slave, *stop_at;
+	char tmp_addr[ETH_ALEN];
+	int res;
+	int i;
+
+	if (bond->alb_info.rlb_enabled) {
+		return 0;
+	}
+
+	bond_for_each_slave(bond, slave, i) {
+		if (slave->dev->set_mac_address == NULL) {
+			res = -EOPNOTSUPP;
+			goto unwind;
+		}
+
+		/* save net_device's current hw address */
+		memcpy(tmp_addr, slave->dev->dev_addr, ETH_ALEN);
+
+		res = slave->dev->set_mac_address(slave->dev, addr);
+
+		/* restore net_device's hw address */
+		memcpy(slave->dev->dev_addr, tmp_addr, ETH_ALEN);
+
+		if (res) {
+			goto unwind;
+		}
+	}
+
+	return 0;
+
+unwind:
+	memcpy(sa.sa_data, bond->dev->dev_addr, bond->dev->addr_len);
+	sa.sa_family = bond->dev->type;
+
+	/* unwind from head to the slave that failed */
+	stop_at = slave;
+	bond_for_each_slave_from_to(bond, slave, i, bond->first_slave, stop_at) {
+		memcpy(tmp_addr, slave->dev->dev_addr, ETH_ALEN);
+		slave->dev->set_mac_address(slave->dev, &sa);
+		memcpy(slave->dev->dev_addr, tmp_addr, ETH_ALEN);
+	}
+
+	return res;
+}
+
+/************************ exported alb funcions ************************/
+
+int bond_alb_initialize(struct bonding *bond, int rlb_enabled)
+{
+	int res;
+
+	res = tlb_initialize(bond);
+	if (res) {
+		return res;
+	}
+
+	if (rlb_enabled) {
+		bond->alb_info.rlb_enabled = 1;
+		/* initialize rlb */
+		res = rlb_initialize(bond);
+		if (res) {
+			tlb_deinitialize(bond);
+			return res;
+		}
+	}
+
+	return 0;
+}
+
+void bond_alb_deinitialize(struct bonding *bond)
+{
+	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
+
+	tlb_deinitialize(bond);
+
+	if (bond_info->rlb_enabled) {
+		rlb_deinitialize(bond);
+	}
+}
+
+int bond_alb_xmit(struct sk_buff *skb, struct net_device *bond_dev)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct ethhdr *eth_data = (struct ethhdr *)skb->mac.raw = skb->data;
+	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
+	struct slave *tx_slave = NULL;
+	static u32 ip_bcast = 0xffffffff;
+	int hash_size = 0;
+	int do_tx_balance = 1;
+	u32 hash_index = 0;
+	u8 *hash_start = NULL;
+	int res = 1;
+
+	/* make sure that the curr_active_slave and the slaves list do
+	 * not change during tx
+	 */
+	read_lock(&bond->lock);
+	read_lock(&bond->curr_slave_lock);
+
+	if (!BOND_IS_OK(bond)) {
+		goto out;
+	}
+
+	switch (ntohs(skb->protocol)) {
+	case ETH_P_IP:
+		if ((memcmp(eth_data->h_dest, mac_bcast, ETH_ALEN) == 0) ||
+		    (skb->nh.iph->daddr == ip_bcast) ||
+		    (skb->nh.iph->protocol == IPPROTO_IGMP)) {
+			do_tx_balance = 0;
+			break;
+		}
+		hash_start = (char*)&(skb->nh.iph->daddr);
+		hash_size = sizeof(skb->nh.iph->daddr);
+		break;
+	case ETH_P_IPV6:
+		if (memcmp(eth_data->h_dest, mac_bcast, ETH_ALEN) == 0) {
+			do_tx_balance = 0;
+			break;
+		}
+
+		hash_start = (char*)&(skb->nh.ipv6h->daddr);
+		hash_size = sizeof(skb->nh.ipv6h->daddr);
+		break;
+	case ETH_P_IPX:
+		if (skb->nh.ipxh->ipx_checksum !=
+		    __constant_htons(IPX_NO_CHECKSUM)) {
+			/* something is wrong with this packet */
+			do_tx_balance = 0;
+			break;
+		}
+
+		if (skb->nh.ipxh->ipx_type != IPX_TYPE_NCP) {
+			/* The only protocol worth balancing in
+			 * this family since it has an "ARP" like
+			 * mechanism
+			 */
+			do_tx_balance = 0;
+			break;
+		}
+
+		hash_start = (char*)eth_data->h_dest;
+		hash_size = ETH_ALEN;
+		break;
+	case ETH_P_ARP:
+		do_tx_balance = 0;
+		if (bond_info->rlb_enabled) {
+			tx_slave = rlb_arp_xmit(skb, bond);
+		}
+		break;
+	default:
+		do_tx_balance = 0;
+		break;
+	}
+
+	if (do_tx_balance) {
+		hash_index = _simple_hash(hash_start, hash_size);
+		tx_slave = tlb_choose_channel(bond, hash_index, skb->len);
+	}
+
+	if (!tx_slave) {
+		/* unbalanced or unassigned, send through primary */
+		tx_slave = bond->curr_active_slave;
+		bond_info->unbalanced_load += skb->len;
+	}
+
+	if (tx_slave && SLAVE_IS_OK(tx_slave)) {
+		if (tx_slave != bond->curr_active_slave) {
+			memcpy(eth_data->h_source,
+			       tx_slave->dev->dev_addr,
+			       ETH_ALEN);
+		}
+
+		res = bond_dev_queue_xmit(bond, skb, tx_slave->dev);
+	} else {
+		if (tx_slave) {
+			tlb_clear_slave(bond, tx_slave, 0);
+		}
+	}
+
+out:
+	if (res) {
+		/* no suitable interface, frame not sent */
+		dev_kfree_skb(skb);
+	}
+	read_unlock(&bond->curr_slave_lock);
+	read_unlock(&bond->lock);
+	return 0;
+}
+
+void bond_alb_monitor(struct bonding *bond)
+{
+	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
+	struct slave *slave;
+	int i;
+
+	read_lock(&bond->lock);
+
+	if (bond->kill_timers) {
+		goto out;
+	}
+
+	if (bond->slave_cnt == 0) {
+		bond_info->tx_rebalance_counter = 0;
+		bond_info->lp_counter = 0;
+		goto re_arm;
+	}
+
+	bond_info->tx_rebalance_counter++;
+	bond_info->lp_counter++;
+
+	/* send learning packets */
+	if (bond_info->lp_counter >= BOND_ALB_LP_TICKS) {
+		/* change of curr_active_slave involves swapping of mac addresses.
+		 * in order to avoid this swapping from happening while
+		 * sending the learning packets, the curr_slave_lock must be held for
+		 * read.
+		 */
+		read_lock(&bond->curr_slave_lock);
+
+		bond_for_each_slave(bond, slave, i) {
+			alb_send_learning_packets(slave,slave->dev->dev_addr);
+		}
+
+		read_unlock(&bond->curr_slave_lock);
+
+		bond_info->lp_counter = 0;
+	}
+
+	/* rebalance tx traffic */
+	if (bond_info->tx_rebalance_counter >= BOND_TLB_REBALANCE_TICKS) {
+
+		read_lock(&bond->curr_slave_lock);
+
+		bond_for_each_slave(bond, slave, i) {
+			tlb_clear_slave(bond, slave, 1);
+			if (slave == bond->curr_active_slave) {
+				SLAVE_TLB_INFO(slave).load =
+					bond_info->unbalanced_load /
+						BOND_TLB_REBALANCE_INTERVAL;
+				bond_info->unbalanced_load = 0;
+			}
+		}
+
+		read_unlock(&bond->curr_slave_lock);
+
+		bond_info->tx_rebalance_counter = 0;
+	}
+
+	/* handle rlb stuff */
+	if (bond_info->rlb_enabled) {
+		/* the following code changes the promiscuity of the
+		 * the curr_active_slave. It needs to be locked with a
+		 * write lock to protect from other code that also
+		 * sets the promiscuity.
+		 */
+		write_lock(&bond->curr_slave_lock);
+
+		if (bond_info->primary_is_promisc &&
+		    (++bond_info->rlb_promisc_timeout_counter >= RLB_PROMISC_TIMEOUT)) {
+
+			bond_info->rlb_promisc_timeout_counter = 0;
+
+			/* If the primary was set to promiscuous mode
+			 * because a slave was disabled then
+			 * it can now leave promiscuous mode.
+			 */
+			dev_set_promiscuity(bond->curr_active_slave->dev, -1);
+			bond_info->primary_is_promisc = 0;
+		}
+
+		write_unlock(&bond->curr_slave_lock);
+
+		if (bond_info->rlb_rebalance) {
+			bond_info->rlb_rebalance = 0;
+			rlb_rebalance(bond);
+		}
+
+		/* check if clients need updating */
+		if (bond_info->rx_ntt) {
+			if (bond_info->rlb_update_delay_counter) {
+				--bond_info->rlb_update_delay_counter;
+			} else {
+				rlb_update_rx_clients(bond);
+				if (bond_info->rlb_update_retry_counter) {
+					--bond_info->rlb_update_retry_counter;
+				} else {
+					bond_info->rx_ntt = 0;
+				}
+			}
+		}
+	}
+
+re_arm:
+	mod_timer(&(bond_info->alb_timer), jiffies + alb_delta_in_ticks);
+out:
+	read_unlock(&bond->lock);
+}
+
+/* assumption: called before the slave is attached to the bond
+ * and not locked by the bond lock
+ */
+int bond_alb_init_slave(struct bonding *bond, struct slave *slave)
+{
+	int res;
+
+	res = alb_set_slave_mac_addr(slave, slave->perm_hwaddr,
+				     bond->alb_info.rlb_enabled);
+	if (res) {
+		return res;
+	}
+
+	/* caller must hold the bond lock for write since the mac addresses
+	 * are compared and may be swapped.
+	 */
+	write_lock_bh(&bond->lock);
+
+	res = alb_handle_addr_collision_on_attach(bond, slave);
+
+	write_unlock_bh(&bond->lock);
+
+	if (res) {
+		return res;
+	}
+
+	tlb_init_slave(slave);
+
+	/* order a rebalance ASAP */
+	bond->alb_info.tx_rebalance_counter = BOND_TLB_REBALANCE_TICKS;
+
+	if (bond->alb_info.rlb_enabled) {
+		bond->alb_info.rlb_rebalance = 1;
+	}
+
+	return 0;
+}
+
+/* Caller must hold bond lock for write */
+void bond_alb_deinit_slave(struct bonding *bond, struct slave *slave)
+{
+	if (bond->slave_cnt > 1) {
+		alb_change_hw_addr_on_detach(bond, slave);
+	}
+
+	tlb_clear_slave(bond, slave, 0);
+
+	if (bond->alb_info.rlb_enabled) {
+		bond->alb_info.next_rx_slave = NULL;
+		rlb_clear_slave(bond, slave);
+	}
+}
+
+/* Caller must hold bond lock for read */
+void bond_alb_handle_link_change(struct bonding *bond, struct slave *slave, char link)
+{
+	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
+
+	if (link == BOND_LINK_DOWN) {
+		tlb_clear_slave(bond, slave, 0);
+		if (bond->alb_info.rlb_enabled) {
+			rlb_clear_slave(bond, slave);
+		}
+	} else if (link == BOND_LINK_UP) {
+		/* order a rebalance ASAP */
+		bond_info->tx_rebalance_counter = BOND_TLB_REBALANCE_TICKS;
+		if (bond->alb_info.rlb_enabled) {
+			bond->alb_info.rlb_rebalance = 1;
+			/* If the updelay module parameter is smaller than the
+			 * forwarding delay of the switch the rebalance will
+			 * not work because the rebalance arp replies will
+			 * not be forwarded to the clients..
+			 */
+		}
+	}
+}
+
+/**
+ * bond_alb_handle_active_change - assign new curr_active_slave
+ * @bond: our bonding struct
+ * @new_slave: new slave to assign
+ *
+ * Set the bond->curr_active_slave to @new_slave and handle
+ * mac address swapping and promiscuity changes as needed.
+ *
+ * Caller must hold bond curr_slave_lock for write (or bond lock for write)
+ */
+void bond_alb_handle_active_change(struct bonding *bond, struct slave *new_slave)
+{
+	struct slave *swap_slave;
+	int i;
+
+	if (bond->curr_active_slave == new_slave) {
+		return;
+	}
+
+	if (bond->curr_active_slave && bond->alb_info.primary_is_promisc) {
+		dev_set_promiscuity(bond->curr_active_slave->dev, -1);
+		bond->alb_info.primary_is_promisc = 0;
+		bond->alb_info.rlb_promisc_timeout_counter = 0;
+	}
+
+	swap_slave = bond->curr_active_slave;
+	bond->curr_active_slave = new_slave;
+
+	if (!new_slave || (bond->slave_cnt == 0)) {
+		return;
+	}
+
+	/* set the new curr_active_slave to the bonds mac address
+	 * i.e. swap mac addresses of old curr_active_slave and new curr_active_slave
+	 */
+	if (!swap_slave) {
+		struct slave *tmp_slave;
+		/* find slave that is holding the bond's mac address */
+		bond_for_each_slave(bond, tmp_slave, i) {
+			if (!memcmp(tmp_slave->dev->dev_addr,
+				    bond->dev->dev_addr, ETH_ALEN)) {
+				swap_slave = tmp_slave;
+				break;
+			}
+		}
+	}
+
+	/* curr_active_slave must be set before calling alb_swap_mac_addr */
+	if (swap_slave) {
+		/* swap mac address */
+		alb_swap_mac_addr(bond, swap_slave, new_slave);
+	} else {
+		/* set the new_slave to the bond mac address */
+		alb_set_slave_mac_addr(new_slave, bond->dev->dev_addr,
+				       bond->alb_info.rlb_enabled);
+		/* fasten bond mac on new current slave */
+		alb_send_learning_packets(new_slave, bond->dev->dev_addr);
+	}
+}
+
+int bond_alb_set_mac_address(struct net_device *bond_dev, void *addr)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct sockaddr *sa = addr;
+	struct slave *slave, *swap_slave;
+	int res;
+	int i;
+
+	if (!is_valid_ether_addr(sa->sa_data)) {
+		return -EADDRNOTAVAIL;
+	}
+
+	res = alb_set_mac_address(bond, addr);
+	if (res) {
+		return res;
+	}
+
+	memcpy(bond_dev->dev_addr, sa->sa_data, bond_dev->addr_len);
+
+	/* If there is no curr_active_slave there is nothing else to do.
+	 * Otherwise we'll need to pass the new address to it and handle
+	 * duplications.
+	 */
+	if (!bond->curr_active_slave) {
+		return 0;
+	}
+
+	swap_slave = NULL;
+
+	bond_for_each_slave(bond, slave, i) {
+		if (!memcmp(slave->dev->dev_addr, bond_dev->dev_addr, ETH_ALEN)) {
+			swap_slave = slave;
+			break;
+		}
+	}
+
+	if (swap_slave) {
+		alb_swap_mac_addr(bond, swap_slave, bond->curr_active_slave);
+	} else {
+		alb_set_slave_mac_addr(bond->curr_active_slave, bond_dev->dev_addr,
+				       bond->alb_info.rlb_enabled);
+
+		alb_send_learning_packets(bond->curr_active_slave, bond_dev->dev_addr);
+		if (bond->alb_info.rlb_enabled) {
+			/* inform clients mac address has changed */
+			rlb_req_update_slave_clients(bond, bond->curr_active_slave);
+		}
+	}
+
+	return 0;
+}
+
+void bond_alb_clear_vlan(struct bonding *bond, unsigned short vlan_id)
+{
+	if (bond->alb_info.current_alb_vlan &&
+	    (bond->alb_info.current_alb_vlan->vlan_id == vlan_id)) {
+		bond->alb_info.current_alb_vlan = NULL;
+	}
+
+	if (bond->alb_info.rlb_enabled) {
+		rlb_clear_vlan(bond, vlan_id);
+	}
+}
+
diff -urNp linux-8120/drivers/net/bonding/bond_alb.h linux-8121/drivers/net/bonding/bond_alb.h
--- linux-8120/drivers/net/bonding/bond_alb.h
+++ linux-8121/drivers/net/bonding/bond_alb.h
@@ -0,0 +1,141 @@
+/*
+ * Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ *
+ * Changes:
+ *
+ * 2003/08/06 - Amir Noam <amir.noam at intel dot com>
+ *	- Add support for setting bond's MAC address with special
+ *	  handling required for ALB/TLB.
+ *
+ * 2003/12/01 - Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Code cleanup and style changes
+ */
+
+#ifndef __BOND_ALB_H__
+#define __BOND_ALB_H__
+
+#include <linux/if_ether.h>
+
+struct bonding;
+struct slave;
+
+#define BOND_ALB_INFO(bond)   ((bond)->alb_info)
+#define SLAVE_TLB_INFO(slave) ((slave)->tlb_info)
+
+struct tlb_client_info {
+	struct slave *tx_slave;	/* A pointer to slave used for transmiting
+				 * packets to a Client that the Hash function
+				 * gave this entry index.
+				 */
+	u32 tx_bytes;		/* Each Client acumulates the BytesTx that
+				 * were tranmitted to it, and after each
+				 * CallBack the LoadHistory is devided
+				 * by the balance interval
+				 */
+	u32 load_history;	/* This field contains the amount of Bytes
+				 * that were transmitted to this client by
+				 * the server on the previous balance
+				 * interval in Bps.
+				 */
+	u32 next;		/* The next Hash table entry index, assigned
+				 * to use the same adapter for transmit.
+				 */
+	u32 prev;		/* The previous Hash table entry index,
+				 * assigned to use the same
+				 */
+};
+
+/* -------------------------------------------------------------------------
+ * struct rlb_client_info contains all info related to a specific rx client
+ * connection. This is the Clients Hash Table entry struct
+ * -------------------------------------------------------------------------
+ */
+struct rlb_client_info {
+	u32 ip_src;		/* the server IP address */
+	u32 ip_dst;		/* the client IP address */
+	u8  mac_dst[ETH_ALEN];	/* the client MAC address */
+	u32 next;		/* The next Hash table entry index */
+	u32 prev;		/* The previous Hash table entry index */
+	u8  assigned;		/* checking whether this entry is assigned */
+	u8  ntt;		/* flag - need to transmit client info */
+	struct slave *slave;	/* the slave assigned to this client */
+	u8 tag;			/* flag - need to tag skb */
+	unsigned short vlan_id;	/* VLAN tag associated with IP address */
+};
+
+struct tlb_slave_info {
+	u32 head;	/* Index to the head of the bi-directional clients
+			 * hash table entries list. The entries in the list
+			 * are the entries that were assigned to use this
+			 * slave for transmit.
+			 */
+	u32 load;	/* Each slave sums the loadHistory of all clients
+			 * assigned to it
+			 */
+};
+
+struct alb_bond_info {
+	struct timer_list	alb_timer;
+	struct tlb_client_info	*tx_hashtbl; /* Dynamically allocated */
+	spinlock_t		tx_hashtbl_lock;
+	u32			unbalanced_load;
+	int			tx_rebalance_counter;
+	int			lp_counter;
+	/* -------- rlb parameters -------- */
+	int rlb_enabled;
+	struct packet_type	rlb_pkt_type;
+	struct rlb_client_info	*rx_hashtbl;	/* Receive hash table */
+	spinlock_t		rx_hashtbl_lock;
+	u32			rx_hashtbl_head;
+	u8			rx_ntt;	/* flag - need to transmit
+					 * to all rx clients
+					 */
+	struct slave		*next_rx_slave;/* next slave to be assigned
+						* to a new rx client for
+						*/
+	u32			rlb_interval_counter;
+	u8			primary_is_promisc;	   /* boolean */
+	u32			rlb_promisc_timeout_counter;/* counts primary
+							     * promiscuity time
+							     */
+	u32			rlb_update_delay_counter;
+	u32			rlb_update_retry_counter;/* counter of retries
+							  * of client update
+							  */
+	u8			rlb_rebalance;	/* flag - indicates that the
+						 * rx traffic should be
+						 * rebalanced
+						 */
+	struct vlan_entry	*current_alb_vlan;
+};
+
+int bond_alb_initialize(struct bonding *bond, int rlb_enabled);
+void bond_alb_deinitialize(struct bonding *bond);
+int bond_alb_init_slave(struct bonding *bond, struct slave *slave);
+void bond_alb_deinit_slave(struct bonding *bond, struct slave *slave);
+void bond_alb_handle_link_change(struct bonding *bond, struct slave *slave, char link);
+void bond_alb_handle_active_change(struct bonding *bond, struct slave *new_slave);
+int bond_alb_xmit(struct sk_buff *skb, struct net_device *bond_dev);
+void bond_alb_monitor(struct bonding *bond);
+int bond_alb_set_mac_address(struct net_device *bond_dev, void *addr);
+void bond_alb_clear_vlan(struct bonding *bond, unsigned short vlan_id);
+#endif /* __BOND_ALB_H__ */
+
diff -urNp linux-8120/drivers/net/bonding/bond_main.c linux-8121/drivers/net/bonding/bond_main.c
--- linux-8120/drivers/net/bonding/bond_main.c
+++ linux-8121/drivers/net/bonding/bond_main.c
@@ -0,0 +1,4837 @@
+/*
+ * originally based on the dummy device.
+ *
+ * Copyright 1999, Thomas Davis, tadavis@lbl.gov.
+ * Licensed under the GPL. Based on dummy.c, and eql.c devices.
+ *
+ * bonding.c: an Ethernet Bonding driver
+ *
+ * This is useful to talk to a Cisco EtherChannel compatible equipment:
+ *	Cisco 5500
+ *	Sun Trunking (Solaris)
+ *	Alteon AceDirector Trunks
+ *	Linux Bonding
+ *	and probably many L2 switches ...
+ *
+ * How it works:
+ *    ifconfig bond0 ipaddress netmask up
+ *      will setup a network device, with an ip address.  No mac address
+ *	will be assigned at this time.  The hw mac address will come from
+ *	the first slave bonded to the channel.  All slaves will then use
+ *	this hw mac address.
+ *
+ *    ifconfig bond0 down
+ *         will release all slaves, marking them as down.
+ *
+ *    ifenslave bond0 eth0
+ *	will attach eth0 to bond0 as a slave.  eth0 hw mac address will either
+ *	a: be used as initial mac address
+ *	b: if a hw mac address already is there, eth0's hw mac address
+ *	   will then be set from bond0.
+ *
+ * v0.1 - first working version.
+ * v0.2 - changed stats to be calculated by summing slaves stats.
+ *
+ * Changes:
+ * Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ * - fix leaks on failure at bond_init
+ *
+ * 2000/09/30 - Willy Tarreau <willy at meta-x.org>
+ *     - added trivial code to release a slave device.
+ *     - fixed security bug (CAP_NET_ADMIN not checked)
+ *     - implemented MII link monitoring to disable dead links :
+ *       All MII capable slaves are checked every <miimon> milliseconds
+ *       (100 ms seems good). This value can be changed by passing it to
+ *       insmod. A value of zero disables the monitoring (default).
+ *     - fixed an infinite loop in bond_xmit_roundrobin() when there's no
+ *       good slave.
+ *     - made the code hopefully SMP safe
+ *
+ * 2000/10/03 - Willy Tarreau <willy at meta-x.org>
+ *     - optimized slave lists based on relevant suggestions from Thomas Davis
+ *     - implemented active-backup method to obtain HA with two switches:
+ *       stay as long as possible on the same active interface, while we
+ *       also monitor the backup one (MII link status) because we want to know
+ *       if we are able to switch at any time. ( pass "mode=1" to insmod )
+ *     - lots of stress testings because we need it to be more robust than the
+ *       wires ! :->
+ *
+ * 2000/10/09 - Willy Tarreau <willy at meta-x.org>
+ *     - added up and down delays after link state change.
+ *     - optimized the slaves chaining so that when we run forward, we never
+ *       repass through the bond itself, but we can find it by searching
+ *       backwards. Renders the deletion more difficult, but accelerates the
+ *       scan.
+ *     - smarter enslaving and releasing.
+ *     - finer and more robust SMP locking
+ *
+ * 2000/10/17 - Willy Tarreau <willy at meta-x.org>
+ *     - fixed two potential SMP race conditions
+ *
+ * 2000/10/18 - Willy Tarreau <willy at meta-x.org>
+ *     - small fixes to the monitoring FSM in case of zero delays
+ * 2000/11/01 - Willy Tarreau <willy at meta-x.org>
+ *     - fixed first slave not automatically used in trunk mode.
+ * 2000/11/10 : spelling of "EtherChannel" corrected.
+ * 2000/11/13 : fixed a race condition in case of concurrent accesses to ioctl().
+ * 2000/12/16 : fixed improper usage of rtnl_exlock_nowait().
+ *
+ * 2001/1/3 - Chad N. Tindel <ctindel at ieee dot org>
+ *     - The bonding driver now simulates MII status monitoring, just like
+ *       a normal network device.  It will show that the link is down iff
+ *       every slave in the bond shows that their links are down.  If at least
+ *       one slave is up, the bond's MII status will appear as up.
+ *
+ * 2001/2/7 - Chad N. Tindel <ctindel at ieee dot org>
+ *     - Applications can now query the bond from user space to get
+ *       information which may be useful.  They do this by calling
+ *       the BOND_INFO_QUERY ioctl.  Once the app knows how many slaves
+ *       are in the bond, it can call the BOND_SLAVE_INFO_QUERY ioctl to
+ *       get slave specific information (# link failures, etc).  See
+ *       <linux/if_bonding.h> for more details.  The structs of interest
+ *       are ifbond and ifslave.
+ *
+ * 2001/4/5 - Chad N. Tindel <ctindel at ieee dot org>
+ *     - Ported to 2.4 Kernel
+ *
+ * 2001/5/2 - Jeffrey E. Mast <jeff at mastfamily dot com>
+ *     - When a device is detached from a bond, the slave device is no longer
+ *       left thinking that is has a master.
+ *
+ * 2001/5/16 - Jeffrey E. Mast <jeff at mastfamily dot com>
+ *     - memset did not appropriately initialized the bond rw_locks. Used
+ *       rwlock_init to initialize to unlocked state to prevent deadlock when
+ *       first attempting a lock
+ *     - Called SET_MODULE_OWNER for bond device
+ *
+ * 2001/5/17 - Tim Anderson <tsa at mvista.com>
+ *     - 2 paths for releasing for slave release; 1 through ioctl
+ *       and 2) through close. Both paths need to release the same way.
+ *     - the free slave in bond release is changing slave status before
+ *       the free. The netdev_set_master() is intended to change slave state
+ *       so it should not be done as part of the release process.
+ *     - Simple rule for slave state at release: only the active in A/B and
+ *       only one in the trunked case.
+ *
+ * 2001/6/01 - Tim Anderson <tsa at mvista.com>
+ *     - Now call dev_close when releasing a slave so it doesn't screw up
+ *       out routing table.
+ *
+ * 2001/6/01 - Chad N. Tindel <ctindel at ieee dot org>
+ *     - Added /proc support for getting bond and slave information.
+ *       Information is in /proc/net/<bond device>/info.
+ *     - Changed the locking when calling bond_close to prevent deadlock.
+ *
+ * 2001/8/05 - Janice Girouard <girouard at us.ibm.com>
+ *     - correct problem where refcnt of slave is not incremented in bond_ioctl
+ *       so the system hangs when halting.
+ *     - correct locking problem when unable to malloc in bond_enslave.
+ *     - adding bond_xmit_xor logic.
+ *     - adding multiple bond device support.
+ *
+ * 2001/8/13 - Erik Habbinga <erik_habbinga at hp dot com>
+ *     - correct locking problem with rtnl_exlock_nowait
+ *
+ * 2001/8/23 - Janice Girouard <girouard at us.ibm.com>
+ *     - bzero initial dev_bonds, to correct oops
+ *     - convert SIOCDEVPRIVATE to new MII ioctl calls
+ *
+ * 2001/9/13 - Takao Indoh <indou dot takao at jp dot fujitsu dot com>
+ *     - Add the BOND_CHANGE_ACTIVE ioctl implementation
+ *
+ * 2001/9/14 - Mark Huth <mhuth at mvista dot com>
+ *     - Change MII_LINK_READY to not check for end of auto-negotiation,
+ *       but only for an up link.
+ *
+ * 2001/9/20 - Chad N. Tindel <ctindel at ieee dot org>
+ *     - Add the device field to bonding_t.  Previously the net_device
+ *       corresponding to a bond wasn't available from the bonding_t
+ *       structure.
+ *
+ * 2001/9/25 - Janice Girouard <girouard at us.ibm.com>
+ *     - add arp_monitor for active backup mode
+ *
+ * 2001/10/23 - Takao Indoh <indou dot takao at jp dot fujitsu dot com>
+ *     - Various memory leak fixes
+ *
+ * 2001/11/5 - Mark Huth <mark dot huth at mvista dot com>
+ *     - Don't take rtnl lock in bond_mii_monitor as it deadlocks under
+ *       certain hotswap conditions.
+ *       Note:  this same change may be required in bond_arp_monitor ???
+ *     - Remove possibility of calling bond_sethwaddr with NULL slave_dev ptr
+ *     - Handle hot swap ethernet interface deregistration events to remove
+ *       kernel oops following hot swap of enslaved interface
+ *
+ * 2002/1/2 - Chad N. Tindel <ctindel at ieee dot org>
+ *     - Restore original slave flags at release time.
+ *
+ * 2002/02/18 - Erik Habbinga <erik_habbinga at hp dot com>
+ *     - bond_release(): calling kfree on our_slave after call to
+ *       bond_restore_slave_flags, not before
+ *     - bond_enslave(): saving slave flags into original_flags before
+ *       call to netdev_set_master, so the IFF_SLAVE flag doesn't end
+ *       up in original_flags
+ *
+ * 2002/04/05 - Mark Smith <mark.smith at comdev dot cc> and
+ *              Steve Mead <steve.mead at comdev dot cc>
+ *     - Port Gleb Natapov's multicast support patchs from 2.4.12
+ *       to 2.4.18 adding support for multicast.
+ *
+ * 2002/06/10 - Tony Cureington <tony.cureington * hp_com>
+ *     - corrected uninitialized pointer (ifr.ifr_data) in bond_check_dev_link;
+ *       actually changed function to use MIIPHY, then MIIREG, and finally
+ *       ETHTOOL to determine the link status
+ *     - fixed bad ifr_data pointer assignments in bond_ioctl
+ *     - corrected mode 1 being reported as active-backup in bond_get_info;
+ *       also added text to distinguish type of load balancing (rr or xor)
+ *     - change arp_ip_target module param from "1-12s" (array of 12 ptrs)
+ *       to "s" (a single ptr)
+ *
+ * 2002/08/30 - Jay Vosburgh <fubar at us dot ibm dot com>
+ *     - Removed acquisition of xmit_lock in set_multicast_list; caused
+ *       deadlock on SMP (lock is held by caller).
+ *     - Revamped SIOCGMIIPHY, SIOCGMIIREG portion of bond_check_dev_link().
+ *
+ * 2002/09/18 - Jay Vosburgh <fubar at us dot ibm dot com>
+ *     - Fixed up bond_check_dev_link() (and callers): removed some magic
+ *	 numbers, banished local MII_ defines, wrapped ioctl calls to
+ *	 prevent EFAULT errors
+ *
+ * 2002/9/30 - Jay Vosburgh <fubar at us dot ibm dot com>
+ *     - make sure the ip target matches the arp_target before saving the
+ *	 hw address.
+ *
+ * 2002/9/30 - Dan Eisner <eisner at 2robots dot com>
+ *     - make sure my_ip is set before taking down the link, since
+ *	 not all switches respond if the source ip is not set.
+ *
+ * 2002/10/8 - Janice Girouard <girouard at us dot ibm dot com>
+ *     - read in the local ip address when enslaving a device
+ *     - add primary support
+ *     - make sure 2*arp_interval has passed when a new device
+ *       is brought on-line before taking it down.
+ *
+ * 2002/09/11 - Philippe De Muyter <phdm at macqel dot be>
+ *     - Added bond_xmit_broadcast logic.
+ *     - Added bond_mode() support function.
+ *
+ * 2002/10/26 - Laurent Deniel <laurent.deniel at free.fr>
+ *     - allow to register multicast addresses only on active slave
+ *       (useful in active-backup mode)
+ *     - add multicast module parameter
+ *     - fix deletion of multicast groups after unloading module
+ *
+ * 2002/11/06 - Kameshwara Rayaprolu <kameshwara.rao * wipro_com>
+ *     - Changes to prevent panic from closing the device twice; if we close
+ *       the device in bond_release, we must set the original_flags to down
+ *       so it won't be closed again by the network layer.
+ *
+ * 2002/11/07 - Tony Cureington <tony.cureington * hp_com>
+ *     - Fix arp_target_hw_addr memory leak
+ *     - Created activebackup_arp_monitor function to handle arp monitoring
+ *       in active backup mode - the bond_arp_monitor had several problems...
+ *       such as allowing slaves to tx arps sequentially without any delay
+ *       for a response
+ *     - Renamed bond_arp_monitor to loadbalance_arp_monitor and re-wrote
+ *       this function to just handle arp monitoring in load-balancing mode;
+ *       it is a lot more compact now
+ *     - Changes to ensure one and only one slave transmits in active-backup
+ *       mode
+ *     - Robustesize parameters; warn users about bad combinations of
+ *       parameters; also if miimon is specified and a network driver does
+ *       not support MII or ETHTOOL, inform the user of this
+ *     - Changes to support link_failure_count when in arp monitoring mode
+ *     - Fix up/down delay reported in /proc
+ *     - Added version; log version; make version available from "modinfo -d"
+ *     - Fixed problem in bond_check_dev_link - if the first IOCTL (SIOCGMIIPH)
+ *	 failed, the ETHTOOL ioctl never got a chance
+ *
+ * 2002/11/16 - Laurent Deniel <laurent.deniel at free.fr>
+ *     - fix multicast handling in activebackup_arp_monitor
+ *     - remove one unnecessary and confusing curr_active_slave == slave test
+ *	 in activebackup_arp_monitor
+ *
+ *  2002/11/17 - Laurent Deniel <laurent.deniel at free.fr>
+ *     - fix bond_slave_info_query when slave_id = num_slaves
+ *
+ *  2002/11/19 - Janice Girouard <girouard at us dot ibm dot com>
+ *     - correct ifr_data reference.  Update ifr_data reference
+ *       to mii_ioctl_data struct values to avoid confusion.
+ *
+ *  2002/11/22 - Bert Barbe <bert.barbe at oracle dot com>
+ *      - Add support for multiple arp_ip_target
+ *
+ *  2002/12/13 - Jay Vosburgh <fubar at us dot ibm dot com>
+ *	- Changed to allow text strings for mode and multicast, e.g.,
+ *	  insmod bonding mode=active-backup.  The numbers still work.
+ *	  One change: an invalid choice will cause module load failure,
+ *	  rather than the previous behavior of just picking one.
+ *	- Minor cleanups; got rid of dup ctype stuff, atoi function
+ *
+ * 2003/02/07 - Jay Vosburgh <fubar at us dot ibm dot com>
+ *	- Added use_carrier module parameter that causes miimon to
+ *	  use netif_carrier_ok() test instead of MII/ETHTOOL ioctls.
+ *	- Minor cleanups; consolidated ioctl calls to one function.
+ *
+ * 2003/02/07 - Tony Cureington <tony.cureington * hp_com>
+ *	- Fix bond_mii_monitor() logic error that could result in
+ *	  bonding round-robin mode ignoring links after failover/recovery
+ *
+ * 2003/03/17 - Jay Vosburgh <fubar at us dot ibm dot com>
+ *	- kmalloc fix (GFP_KERNEL to GFP_ATOMIC) reported by
+ *	  Shmulik dot Hen at intel.com.
+ *	- Based on discussion on mailing list, changed use of
+ *	  update_slave_cnt(), created wrapper functions for adding/removing
+ *	  slaves, changed bond_xmit_xor() to check slave_cnt instead of
+ *	  checking slave and slave->dev (which only worked by accident).
+ *	- Misc code cleanup: get arp_send() prototype from header file,
+ *	  add max_bonds to bonding.txt.
+ *
+ * 2003/03/18 - Tsippy Mendelson <tsippy.mendelson at intel dot com> and
+ *		Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Make sure only bond_attach_slave() and bond_detach_slave() can
+ *	  manipulate the slave list, including slave_cnt, even when in
+ *	  bond_release_all().
+ *	- Fixed hang in bond_release() with traffic running:
+ *	  netdev_set_master() must not be called from within the bond lock.
+ *
+ * 2003/03/18 - Tsippy Mendelson <tsippy.mendelson at intel dot com> and
+ *		Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Fixed hang in bond_enslave() with traffic running:
+ *	  netdev_set_master() must not be called from within the bond lock.
+ *
+ * 2003/03/18 - Amir Noam <amir.noam at intel dot com>
+ *	- Added support for getting slave's speed and duplex via ethtool.
+ *	  Needed for 802.3ad and other future modes.
+ *
+ * 2003/03/18 - Tsippy Mendelson <tsippy.mendelson at intel dot com> and
+ *		Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Enable support of modes that need to use the unique mac address of
+ *	  each slave.
+ *	  * bond_enslave(): Moved setting the slave's mac address, and
+ *	    openning it, from the application to the driver. This breaks
+ *	    backward comaptibility with old versions of ifenslave that open
+ *	     the slave before enalsving it !!!.
+ *	  * bond_release(): The driver also takes care of closing the slave
+ *	    and restoring its original mac address.
+ *	- Removed the code that restores all base driver's flags.
+ *	  Flags are automatically restored once all undo stages are done
+ *	  properly.
+ *	- Block possibility of enslaving before the master is up. This
+ *	  prevents putting the system in an unstable state.
+ *
+ * 2003/03/18 - Amir Noam <amir.noam at intel dot com>,
+ *		Tsippy Mendelson <tsippy.mendelson at intel dot com> and
+ *		Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Added support for IEEE 802.3ad Dynamic link aggregation mode.
+ *
+ * 2003/05/01 - Amir Noam <amir.noam at intel dot com>
+ *	- Added ABI version control to restore compatibility between
+ *	  new/old ifenslave and new/old bonding.
+ *
+ * 2003/05/01 - Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Fixed bug in bond_release_all(): save old value of curr_active_slave
+ *	  before setting it to NULL.
+ *	- Changed driver versioning scheme to include version number instead
+ *	  of release date (that is already in another field). There are 3
+ *	  fields X.Y.Z where:
+ *		X - Major version - big behavior changes
+ *		Y - Minor version - addition of features
+ *		Z - Extra version - minor changes and bug fixes
+ *	  The current version is 1.0.0 as a base line.
+ *
+ * 2003/05/01 - Tsippy Mendelson <tsippy.mendelson at intel dot com> and
+ *		Amir Noam <amir.noam at intel dot com>
+ *	- Added support for lacp_rate module param.
+ *	- Code beautification and style changes (mainly in comments).
+ *	  new version - 1.0.1
+ *
+ * 2003/05/01 - Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Based on discussion on mailing list, changed locking scheme
+ *	  to use lock/unlock or lock_bh/unlock_bh appropriately instead
+ *	  of lock_irqsave/unlock_irqrestore. The new scheme helps exposing
+ *	  hidden bugs and solves system hangs that occurred due to the fact
+ *	  that holding lock_irqsave doesn't prevent softirqs from running.
+ *	  This also increases total throughput since interrupts are not
+ *	  blocked on each transmitted packets or monitor timeout.
+ *	  new version - 2.0.0
+ *
+ * 2003/05/01 - Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Added support for Transmit load balancing mode.
+ *	- Concentrate all assignments of curr_active_slave to a single point
+ *	  so specific modes can take actions when the primary adapter is
+ *	  changed.
+ *	- Take the updelay parameter into consideration during bond_enslave
+ *	  since some adapters loose their link during setting the device.
+ *	- Renamed bond_3ad_link_status_changed() to
+ *	  bond_3ad_handle_link_change() for compatibility with TLB.
+ *	  new version - 2.1.0
+ *
+ * 2003/05/01 - Tsippy Mendelson <tsippy.mendelson at intel dot com>
+ *	- Added support for Adaptive load balancing mode which is
+ *	  equivalent to Transmit load balancing + Receive load balancing.
+ *	  new version - 2.2.0
+ *
+ * 2003/05/15 - Jay Vosburgh <fubar at us dot ibm dot com>
+ *	- Applied fix to activebackup_arp_monitor posted to bonding-devel
+ *	  by Tony Cureington <tony.cureington * hp_com>.  Fixes ARP
+ *	  monitor endless failover bug.  Version to 2.2.10
+ *
+ * 2003/05/20 - Amir Noam <amir.noam at intel dot com>
+ *	- Fixed bug in ABI version control - Don't commit to a specific
+ *	  ABI version if receiving unsupported ioctl commands.
+ *
+ * 2003/05/22 - Jay Vosburgh <fubar at us dot ibm dot com>
+ *	- Fix ifenslave -c causing bond to loose existing routes;
+ *	  added bond_set_mac_address() that doesn't require the
+ *	  bond to be down.
+ *	- In conjunction with fix for ifenslave -c, in
+ *	  bond_change_active(), changing to the already active slave
+ *	  is no longer an error (it successfully does nothing).
+ *
+ * 2003/06/30 - Amir Noam <amir.noam at intel dot com>
+ * 	- Fixed bond_change_active() for ALB/TLB modes.
+ *	  Version to 2.2.14.
+ *
+ * 2003/07/29 - Amir Noam <amir.noam at intel dot com>
+ * 	- Fixed ARP monitoring bug.
+ *	  Version to 2.2.15.
+ *
+ * 2003/07/31 - Willy Tarreau <willy at ods dot org>
+ * 	- Fixed kernel panic when using ARP monitoring without
+ *	  setting bond's IP address.
+ *	  Version to 2.2.16.
+ *
+ * 2003/08/06 - Amir Noam <amir.noam at intel dot com>
+ * 	- Back port from 2.6: use alloc_netdev(); fix /proc handling;
+ *	  made stats a part of bond struct so no need to allocate
+ *	  and free it separately; use standard list operations instead
+ *	  of pre-allocated array of bonds.
+ *	  Version to 2.3.0.
+ *
+ * 2003/08/07 - Jay Vosburgh <fubar at us dot ibm dot com>,
+ *	       Amir Noam <amir.noam at intel dot com> and
+ *	       Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Propagating master's settings: Distinguish between modes that
+ *	  use a primary slave from those that don't, and propagate settings
+ *	  accordingly; Consolidate change_active opeartions and add
+ *	  reselect_active and find_best opeartions; Decouple promiscuous
+ *	  handling from the multicast mode setting; Add support for changing
+ *	  HW address and MTU with proper unwind; Consolidate procfs code,
+ *	  add CHANGENAME handler; Enhance netdev notification handling.
+ *	  Version to 2.4.0.
+ *
+ * 2003/09/15 - Stephen Hemminger <shemminger at osdl dot org>,
+ *	       Amir Noam <amir.noam at intel dot com>
+ *	- Convert /proc to seq_file interface.
+ *	  Change /proc/net/bondX/info to /proc/net/bonding/bondX.
+ *	  Set version to 2.4.1.
+ *
+ * 2003/11/20 - Amir Noam <amir.noam at intel dot com>
+ *	- Fix /proc creation/destruction.
+ *
+ * 2003/12/01 - Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Massive cleanup - Set version to 2.5.0
+ *	  Code changes:
+ *	  o Consolidate format of prints and debug prints.
+ *	  o Remove bonding_t/slave_t typedefs and consolidate all casts.
+ *	  o Remove dead code and unnecessary checks.
+ *	  o Consolidate starting/stopping timers.
+ *	  o Consolidate handling of primary module param throughout the code.
+ *	  o Removed multicast module param support - all settings are done
+ *	    according to mode.
+ *	  o Slave list iteration - bond is no longer part of the list,
+ *	    added cyclic list iteration macros.
+ *	  o Consolidate error handling in all xmit functions.
+ *	  Style changes:
+ *	  o Consolidate function naming and declarations.
+ *	  o Consolidate function params and local variables names.
+ *	  o Consolidate return values.
+ *	  o Consolidate curly braces.
+ *	  o Consolidate conditionals format.
+ *	  o Change struct member names and types.
+ *	  o Chomp trailing spaces, remove empty lines, fix indentations.
+ *	  o Re-organize code according to context.
+ *
+ * 2003/12/30 - Amir Noam <amir.noam at intel dot com>
+ *	- Fixed: Cannot remove and re-enslave the original active slave.
+ *	- Fixed: Releasing the original active slave causes mac address
+ *		 duplication.
+ *	- Add support for slaves that use ethtool_ops.
+ *	  Set version to 2.5.3.
+ *
+ * 2004/01/05 - Amir Noam <amir.noam at intel dot com>
+ *	- Save bonding parameters per bond instead of using the global values.
+ *	  Set version to 2.5.4.
+ *
+ * 2004/01/14 - Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Enhance VLAN support:
+ *	  * Add support for VLAN hardware acceleration capable slaves.
+ *	  * Add capability to tag self generated packets in ALB/TLB modes.
+ *	  Set version to 2.6.0.
+ */
+
+//#define BONDING_DEBUG 1
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/socket.h>
+#include <linux/ctype.h>
+#include <linux/inet.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/uaccess.h>
+#include <linux/errno.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/igmp.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <net/sock.h>
+#include <linux/rtnetlink.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/smp.h>
+#include <linux/if_ether.h>
+#include <net/arp.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <linux/if_vlan.h>
+#include <linux/if_bonding.h>
+#include "bonding.h"
+#include "bond_3ad.h"
+#include "bond_alb.h"
+
+/*---------------------------- Module parameters ----------------------------*/
+
+/* monitor all links that often (in milliseconds). <=0 disables monitoring */
+#define BOND_LINK_MON_INTERV	0
+#define BOND_LINK_ARP_INTERV	0
+
+static int max_bonds	= BOND_DEFAULT_MAX_BONDS;
+static int miimon	= BOND_LINK_MON_INTERV;
+static int updelay	= 0;
+static int downdelay	= 0;
+static int use_carrier	= 1;
+static char *mode	= NULL;
+static char *primary	= NULL;
+static char *lacp_rate	= NULL;
+static int arp_interval = BOND_LINK_ARP_INTERV;
+static char *arp_ip_target[BOND_MAX_ARP_TARGETS] = { NULL, };
+
+MODULE_PARM(max_bonds, "i");
+MODULE_PARM_DESC(max_bonds, "Max number of bonded devices");
+MODULE_PARM(miimon, "i");
+MODULE_PARM_DESC(miimon, "Link check interval in milliseconds");
+MODULE_PARM(updelay, "i");
+MODULE_PARM_DESC(updelay, "Delay before considering link up, in milliseconds");
+MODULE_PARM(downdelay, "i");
+MODULE_PARM_DESC(downdelay, "Delay before considering link down, in milliseconds");
+MODULE_PARM(use_carrier, "i");
+MODULE_PARM_DESC(use_carrier, "Use netif_carrier_ok (vs MII ioctls) in miimon; 0 for off, 1 for on (default)");
+MODULE_PARM(mode, "s");
+MODULE_PARM_DESC(mode, "Mode of operation : 0 for round robin, 1 for active-backup, 2 for xor");
+MODULE_PARM(primary, "s");
+MODULE_PARM_DESC(primary, "Primary network device to use");
+MODULE_PARM(lacp_rate, "s");
+MODULE_PARM_DESC(lacp_rate, "LACPDU tx rate to request from 802.3ad partner (slow/fast)");
+MODULE_PARM(arp_interval, "i");
+MODULE_PARM_DESC(arp_interval, "arp interval in milliseconds");
+MODULE_PARM(arp_ip_target, "1-" __MODULE_STRING(BOND_MAX_ARP_TARGETS) "s");
+MODULE_PARM_DESC(arp_ip_target, "arp targets in n.n.n.n form");
+
+/*----------------------------- Global variables ----------------------------*/
+
+static const char *version =
+	DRV_DESCRIPTION ": v" DRV_VERSION " (" DRV_RELDATE ")\n";
+
+static LIST_HEAD(bond_dev_list);
+
+#ifdef CONFIG_PROC_FS
+static struct proc_dir_entry *bond_proc_dir = NULL;
+#endif
+
+static u32 arp_target[BOND_MAX_ARP_TARGETS] = { 0, } ;
+static int arp_ip_count	= 0;
+static u32 my_ip	= 0;
+static int bond_mode	= BOND_MODE_ROUNDROBIN;
+static int lacp_fast	= 0;
+static int app_abi_ver	= 0;
+static int orig_app_abi_ver = -1; /* This is used to save the first ABI version
+				   * we receive from the application. Once set,
+				   * it won't be changed, and the module will
+				   * refuse to enslave/release interfaces if the
+				   * command comes from an application using
+				   * another ABI version.
+				   */
+
+struct bond_parm_tbl {
+	char *modename;
+	int mode;
+};
+
+static struct bond_parm_tbl bond_lacp_tbl[] = {
+{	"slow",		AD_LACP_SLOW},
+{	"fast",		AD_LACP_FAST},
+{	NULL,		-1},
+};
+
+static struct bond_parm_tbl bond_mode_tbl[] = {
+{	"balance-rr",		BOND_MODE_ROUNDROBIN},
+{	"active-backup",	BOND_MODE_ACTIVEBACKUP},
+{	"balance-xor",		BOND_MODE_XOR},
+{	"broadcast",		BOND_MODE_BROADCAST},
+{	"802.3ad",		BOND_MODE_8023AD},
+{	"balance-tlb",		BOND_MODE_TLB},
+{	"balance-alb",		BOND_MODE_ALB},
+{	NULL,			-1},
+};
+
+/*-------------------------- Forward declarations ---------------------------*/
+
+static inline void bond_set_mode_ops(struct net_device *bond_dev, int mode);
+
+/*---------------------------- General routines -----------------------------*/
+
+static const char *bond_mode_name(int mode)
+{
+	switch (mode) {
+	case BOND_MODE_ROUNDROBIN :
+		return "load balancing (round-robin)";
+	case BOND_MODE_ACTIVEBACKUP :
+		return "fault-tolerance (active-backup)";
+	case BOND_MODE_XOR :
+		return "load balancing (xor)";
+	case BOND_MODE_BROADCAST :
+		return "fault-tolerance (broadcast)";
+	case BOND_MODE_8023AD:
+		return "IEEE 802.3ad Dynamic link aggregation";
+	case BOND_MODE_TLB:
+		return "transmit load balancing";
+	case BOND_MODE_ALB:
+		return "adaptive load balancing";
+	default:
+		return "unknown";
+	}
+}
+
+/*---------------------------------- VLAN -----------------------------------*/
+
+/**
+ * bond_add_vlan - add a new vlan id on bond
+ * @bond: bond that got the notification
+ * @vlan_id: the vlan id to add
+ *
+ * Returns -ENOMEM if allocation failed.
+ */
+static int bond_add_vlan(struct bonding *bond, unsigned short vlan_id)
+{
+	struct vlan_entry *vlan;
+
+	dprintk("bond: %s, vlan id %d\n",
+		(bond ? bond->dev->name: "None"), vlan_id);
+
+	vlan = kmalloc(sizeof(struct vlan_entry), GFP_KERNEL);
+	if (!vlan) {
+		return -ENOMEM;
+	}
+
+	INIT_LIST_HEAD(&vlan->vlan_list);
+	vlan->vlan_id = vlan_id;
+
+	write_lock_bh(&bond->lock);
+
+	list_add_tail(&vlan->vlan_list, &bond->vlan_list);
+
+	write_unlock_bh(&bond->lock);
+
+	dprintk("added VLAN ID %d on bond %s\n", vlan_id, bond->dev->name);
+
+	return 0;
+}
+
+/**
+ * bond_del_vlan - delete a vlan id from bond
+ * @bond: bond that got the notification
+ * @vlan_id: the vlan id to delete
+ *
+ * returns -ENODEV if @vlan_id was not found in @bond.
+ */
+static int bond_del_vlan(struct bonding *bond, unsigned short vlan_id)
+{
+	struct vlan_entry *vlan, *next;
+	int res = -ENODEV;
+
+	dprintk("bond: %s, vlan id %d\n", bond->dev->name, vlan_id);
+
+	write_lock_bh(&bond->lock);
+
+	list_for_each_entry_safe(vlan, next, &bond->vlan_list, vlan_list) {
+		if (vlan->vlan_id == vlan_id) {
+			list_del(&vlan->vlan_list);
+
+			if ((bond->params.mode == BOND_MODE_TLB) ||
+			    (bond->params.mode == BOND_MODE_ALB)) {
+				bond_alb_clear_vlan(bond, vlan_id);
+			}
+
+			dprintk("removed VLAN ID %d from bond %s\n", vlan_id,
+				bond->dev->name);
+
+			kfree(vlan);
+
+			if (list_empty(&bond->vlan_list) &&
+			    (bond->slave_cnt == 0)) {
+				/* Last VLAN removed and no slaves, so
+				 * restore block on adding VLANs. This will
+				 * be removed once new slaves that are not
+				 * VLAN challenged will be added.
+				 */
+				bond->dev->features |= NETIF_F_VLAN_CHALLENGED;
+			}
+
+			res = 0;
+			goto out;
+		}
+	}
+
+	dprintk("couldn't find VLAN ID %d in bond %s\n", vlan_id,
+		bond->dev->name);
+
+out:
+	write_unlock_bh(&bond->lock);
+	return res;
+}
+
+/**
+ * bond_has_challenged_slaves
+ * @bond: the bond we're working on
+ *
+ * Searches the slave list. Returns 1 if a vlan challenged slave
+ * was found, 0 otherwise.
+ *
+ * Assumes bond->lock is held.
+ */
+static int bond_has_challenged_slaves(struct bonding *bond)
+{
+	struct slave *slave;
+	int i;
+
+	bond_for_each_slave(bond, slave, i) {
+		if (slave->dev->features & NETIF_F_VLAN_CHALLENGED) {
+			dprintk("found VLAN challenged slave - %s\n",
+				slave->dev->name);
+			return 1;
+		}
+	}
+
+	dprintk("no VLAN challenged slaves found\n");
+	return 0;
+}
+
+/**
+ * bond_next_vlan - safely skip to the next item in the vlans list.
+ * @bond: the bond we're working on
+ * @curr: item we're advancing from
+ *
+ * Returns %NULL if list is empty, bond->next_vlan if @curr is %NULL,
+ * or @curr->next otherwise (even if it is @curr itself again).
+ * 
+ * Caller must hold bond->lock
+ */
+struct vlan_entry *bond_next_vlan(struct bonding *bond, struct vlan_entry *curr)
+{
+	struct vlan_entry *next, *last;
+
+	if (list_empty(&bond->vlan_list)) {
+		return NULL;
+	}
+
+	if (!curr) {
+		next = list_entry(bond->vlan_list.next,
+				  struct vlan_entry, vlan_list);
+	} else {
+		last = list_entry(bond->vlan_list.prev,
+				  struct vlan_entry, vlan_list);
+		if (last == curr) {
+			next = list_entry(bond->vlan_list.next,
+					  struct vlan_entry, vlan_list);
+		} else {
+			next = list_entry(curr->vlan_list.next,
+					  struct vlan_entry, vlan_list);
+		}
+	}
+
+	return next;
+}
+
+#ifdef HAVE_POLL_CONTROLLER
+static void bond_zap_completion_queue(void)
+{
+	int cpu = smp_processor_id();
+
+	if (softnet_data[cpu].completion_queue) {
+		struct sk_buff *clist;
+		unsigned long flags;
+
+		local_irq_save(flags);
+		clist = softnet_data[cpu].completion_queue;
+		softnet_data[cpu].completion_queue = NULL;
+		local_irq_restore(flags);
+
+		while (clist != NULL) {
+			struct sk_buff *skb = clist;
+			clist = clist->next;
+			__kfree_skb(skb);
+		}
+	}
+}
+
+static void bond_transmit_raw_skb(struct sk_buff *skb, struct net_device *dev)
+{
+	int poll_count = 0;
+
+repeat_poll:
+	/* drop the packet if we are making no progress */
+	if (likely(!netdump_mode) && poll_count++ > 32) {
+		dev_kfree_skb_any(skb);
+		return;
+	}
+
+	spin_lock(&dev->xmit_lock);
+	dev->xmit_lock_owner = smp_processor_id();
+
+	if (netif_queue_stopped(dev)) {
+		dev->xmit_lock_owner = -1;
+		spin_unlock(&dev->xmit_lock);
+
+		dev->poll_controller(dev);
+		bond_zap_completion_queue();
+		goto repeat_poll;
+	}
+
+	dev->hard_start_xmit(skb, dev);
+
+	dev->xmit_lock_owner = -1;
+	spin_unlock(&dev->xmit_lock);
+}
+#endif
+
+/**
+ * bond_dev_queue_xmit - Prepare skb for xmit.
+ * 
+ * @bond: bond device that got this skb for tx.
+ * @skb: hw accel VLAN tagged skb to transmit
+ * @slave_dev: slave that is supposed to xmit this skbuff
+ * 
+ * When the bond gets an skb to transmit that is
+ * already hardware accelerated VLAN tagged, and it
+ * needs to relay this skb to a slave that is not
+ * hw accel capable, the skb needs to be "unaccelerated",
+ * i.e. strip the hwaccel tag and re-insert it as part
+ * of the payload.
+ */
+int bond_dev_queue_xmit(struct bonding *bond, struct sk_buff *skb, struct net_device *slave_dev)
+{
+	unsigned short vlan_id;
+
+	if (!list_empty(&bond->vlan_list) &&
+	    !(slave_dev->features & NETIF_F_HW_VLAN_TX) &&
+	    vlan_get_tag(skb, &vlan_id) == 0) {
+		skb->dev = slave_dev;
+		skb = vlan_put_tag(skb, vlan_id);
+		if (!skb) {
+			/* vlan_put_tag() frees the skb in case of error,
+			 * so return success here so the calling functions
+			 * won't attempt to free is again.
+			 */
+			return 0;
+		}
+	} else {
+		skb->dev = slave_dev;
+	}
+
+	skb->priority = 1;
+#ifdef HAVE_POLL_CONTROLLER
+	if (bond->dev->priv_flags & IFF_NETCONSOLE)
+		bond_transmit_raw_skb(skb, skb->dev);
+	else
+#endif
+		dev_queue_xmit(skb);
+
+	return 0;
+}
+
+/*
+ * In the following 3 functions, bond_vlan_rx_register(), bond_vlan_rx_add_vid
+ * and bond_vlan_rx_kill_vid, We don't protect the slave list iteration with a
+ * lock because:
+ * a. This operation is performed in IOCTL context,
+ * b. The operation is protected by the RTNL semaphore in the 8021q code,
+ * c. Holding a lock with BH disabled while directly calling a base driver
+ *    entry point is generally a BAD idea.
+ * 
+ * The design of synchronization/protection for this operation in the 8021q
+ * module is good for one or more VLAN devices over a single physical device
+ * and cannot be extended for a teaming solution like bonding, so there is a
+ * potential race condition here where a net device from the vlan group might
+ * be referenced (either by a base driver or the 8021q code) while it is being
+ * removed from the system. However, it turns out we're not making matters
+ * worse, and if it works for regular VLAN usage it will work here too.
+*/
+
+/**
+ * bond_vlan_rx_register - Propagates registration to slaves
+ * @bond_dev: bonding net device that got called
+ * @grp: vlan group being registered
+ */
+static void bond_vlan_rx_register(struct net_device *bond_dev, struct vlan_group *grp)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct slave *slave;
+	int i;
+
+	bond->vlgrp = grp;
+
+	bond_for_each_slave(bond, slave, i) {
+		struct net_device *slave_dev = slave->dev;
+
+		if ((slave_dev->features & NETIF_F_HW_VLAN_RX) &&
+		    slave_dev->vlan_rx_register) {
+			slave_dev->vlan_rx_register(slave_dev, grp);
+		}
+	}
+}
+
+/**
+ * bond_vlan_rx_add_vid - Propagates adding an id to slaves
+ * @bond_dev: bonding net device that got called
+ * @vid: vlan id being added
+ */
+static void bond_vlan_rx_add_vid(struct net_device *bond_dev, uint16_t vid)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct slave *slave;
+	int i, res;
+
+	bond_for_each_slave(bond, slave, i) {
+		struct net_device *slave_dev = slave->dev;
+
+		if ((slave_dev->features & NETIF_F_HW_VLAN_FILTER) &&
+		    slave_dev->vlan_rx_add_vid) {
+			slave_dev->vlan_rx_add_vid(slave_dev, vid);
+		}
+	}
+
+	res = bond_add_vlan(bond, vid);
+	if (res) {
+		printk(KERN_ERR DRV_NAME
+		       ": %s: Failed to add vlan id %d\n",
+		       bond_dev->name, vid);
+	}
+}
+
+/**
+ * bond_vlan_rx_kill_vid - Propagates deleting an id to slaves
+ * @bond_dev: bonding net device that got called
+ * @vid: vlan id being removed
+ */
+static void bond_vlan_rx_kill_vid(struct net_device *bond_dev, uint16_t vid)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct slave *slave;
+	struct net_device *vlan_dev;
+	int i, res;
+
+	bond_for_each_slave(bond, slave, i) {
+		struct net_device *slave_dev = slave->dev;
+
+		if ((slave_dev->features & NETIF_F_HW_VLAN_FILTER) &&
+		    slave_dev->vlan_rx_kill_vid) {
+			/* Save and then restore vlan_dev in the grp array,
+			 * since the slave's driver might clear it.
+			 */
+			vlan_dev = bond->vlgrp->vlan_devices[vid];
+			slave_dev->vlan_rx_kill_vid(slave_dev, vid);
+			bond->vlgrp->vlan_devices[vid] = vlan_dev;
+		}
+	}
+
+	res = bond_del_vlan(bond, vid);
+	if (res) {
+		printk(KERN_ERR DRV_NAME
+		       ": %s: Failed to remove vlan id %d\n",
+		       bond_dev->name, vid);
+	}
+}
+
+static void bond_add_vlans_on_slave(struct bonding *bond, struct net_device *slave_dev)
+{
+	struct vlan_entry *vlan;
+
+	write_lock_bh(&bond->lock);
+
+	if (list_empty(&bond->vlan_list)) {
+		goto out;
+	}
+
+	if ((slave_dev->features & NETIF_F_HW_VLAN_RX) &&
+	    slave_dev->vlan_rx_register) {
+		slave_dev->vlan_rx_register(slave_dev, bond->vlgrp);
+	}
+
+	if (!(slave_dev->features & NETIF_F_HW_VLAN_FILTER) ||
+	    !(slave_dev->vlan_rx_add_vid)) {
+		goto out;
+	}
+
+	list_for_each_entry(vlan, &bond->vlan_list, vlan_list) {
+		slave_dev->vlan_rx_add_vid(slave_dev, vlan->vlan_id);
+	}
+
+out:
+	write_unlock_bh(&bond->lock);
+}
+
+static void bond_del_vlans_from_slave(struct bonding *bond, struct net_device *slave_dev)
+{
+	struct vlan_entry *vlan;
+	struct net_device *vlan_dev;
+
+	write_lock_bh(&bond->lock);
+
+	if (list_empty(&bond->vlan_list)) {
+		goto out;
+	}
+
+	if (!(slave_dev->features & NETIF_F_HW_VLAN_FILTER) ||
+	    !(slave_dev->vlan_rx_kill_vid)) {
+		goto unreg;
+	}
+
+	list_for_each_entry(vlan, &bond->vlan_list, vlan_list) {
+		/* Save and then restore vlan_dev in the grp array,
+		 * since the slave's driver might clear it.
+		 */
+		vlan_dev = bond->vlgrp->vlan_devices[vlan->vlan_id];
+		slave_dev->vlan_rx_kill_vid(slave_dev, vlan->vlan_id);
+		bond->vlgrp->vlan_devices[vlan->vlan_id] = vlan_dev;
+	}
+
+unreg:
+	if ((slave_dev->features & NETIF_F_HW_VLAN_RX) &&
+	    slave_dev->vlan_rx_register) {
+		slave_dev->vlan_rx_register(slave_dev, NULL);
+	}
+
+out:
+	write_unlock_bh(&bond->lock);
+}
+
+/*------------------------------- Link status -------------------------------*/
+
+/*
+ * Get link speed and duplex from the slave's base driver
+ * using ethtool. If for some reason the call fails or the
+ * values are invalid, fake speed and duplex to 100/Full
+ * and return error.
+ */
+static int bond_update_speed_duplex(struct slave *slave)
+{
+	struct net_device *slave_dev = slave->dev;
+	static int (* ioctl)(struct net_device *, struct ifreq *, int);
+	struct ifreq ifr;
+	struct ethtool_cmd etool;
+
+	/* Fake speed and duplex */
+	slave->speed = SPEED_100;
+	slave->duplex = DUPLEX_FULL;
+
+	if (slave_dev->ethtool_ops) {
+		u32 res;
+
+		if (!slave_dev->ethtool_ops->get_settings) {
+			return -1;
+		}
+
+		res = slave_dev->ethtool_ops->get_settings(slave_dev, &etool);
+		if (res < 0) {
+			return -1;
+		}
+
+		goto verify;
+	}
+
+	ioctl = slave_dev->do_ioctl;
+	strncpy(ifr.ifr_name, slave_dev->name, IFNAMSIZ);
+	etool.cmd = ETHTOOL_GSET;
+	ifr.ifr_data = (char*)&etool;
+	if (!ioctl || (IOCTL(slave_dev, &ifr, SIOCETHTOOL) < 0)) {
+		return -1;
+	}
+
+verify:
+	switch (etool.speed) {
+	case SPEED_10:
+	case SPEED_100:
+	case SPEED_1000:
+		break;
+	default:
+		return -1;
+	}
+
+	switch (etool.duplex) {
+	case DUPLEX_FULL:
+	case DUPLEX_HALF:
+		break;
+	default:
+		return -1;
+	}
+
+	slave->speed = etool.speed;
+	slave->duplex = etool.duplex;
+
+	return 0;
+}
+
+/*
+ * if <dev> supports MII link status reporting, check its link status.
+ *
+ * We either do MII/ETHTOOL ioctls, or check netif_carrier_ok(),
+ * depening upon the setting of the use_carrier parameter.
+ *
+ * Return either BMSR_LSTATUS, meaning that the link is up (or we
+ * can't tell and just pretend it is), or 0, meaning that the link is
+ * down.
+ *
+ * If reporting is non-zero, instead of faking link up, return -1 if
+ * both ETHTOOL and MII ioctls fail (meaning the device does not
+ * support them).  If use_carrier is set, return whatever it says.
+ * It'd be nice if there was a good way to tell if a driver supports
+ * netif_carrier, but there really isn't.
+ */
+static int bond_check_dev_link(struct bonding *bond, struct net_device *slave_dev, int reporting)
+{
+	static int (* ioctl)(struct net_device *, struct ifreq *, int);
+	struct ifreq ifr;
+	struct mii_ioctl_data *mii;
+	struct ethtool_value etool;
+
+	if (bond->params.use_carrier) {
+		return netif_carrier_ok(slave_dev) ? BMSR_LSTATUS : 0;
+	}
+
+	ioctl = slave_dev->do_ioctl;
+	if (ioctl) {
+		/* TODO: set pointer to correct ioctl on a per team member */
+		/*       bases to make this more efficient. that is, once  */
+		/*       we determine the correct ioctl, we will always    */
+		/*       call it and not the others for that team          */
+		/*       member.                                           */
+
+		/*
+		 * We cannot assume that SIOCGMIIPHY will also read a
+		 * register; not all network drivers (e.g., e100)
+		 * support that.
+		 */
+
+		/* Yes, the mii is overlaid on the ifreq.ifr_ifru */
+		strncpy(ifr.ifr_name, slave_dev->name, IFNAMSIZ);
+		mii = (struct mii_ioctl_data *)&ifr.ifr_data;
+		if (IOCTL(slave_dev, &ifr, SIOCGMIIPHY) == 0) {
+			mii->reg_num = MII_BMSR;
+			if (IOCTL(slave_dev, &ifr, SIOCGMIIREG) == 0) {
+				return (mii->val_out & BMSR_LSTATUS);
+			}
+		}
+	}
+
+	/* try SIOCETHTOOL ioctl, some drivers cache ETHTOOL_GLINK */
+	/* for a period of time so we attempt to get link status   */
+	/* from it last if the above MII ioctls fail...            */
+	if (slave_dev->ethtool_ops) {
+		if (slave_dev->ethtool_ops->get_link) {
+			u32 link;
+
+			link = slave_dev->ethtool_ops->get_link(slave_dev);
+
+			return link ? BMSR_LSTATUS : 0;
+		}
+	}
+
+	if (ioctl) {
+		strncpy(ifr.ifr_name, slave_dev->name, IFNAMSIZ);
+		etool.cmd = ETHTOOL_GLINK;
+		ifr.ifr_data = (char*)&etool;
+		if (IOCTL(slave_dev, &ifr, SIOCETHTOOL) == 0) {
+			if (etool.data == 1) {
+				return BMSR_LSTATUS;
+			} else {
+				dprintk("SIOCETHTOOL shows link down\n");
+				return 0;
+			}
+		}
+	}
+
+	/*
+	 * If reporting, report that either there's no dev->do_ioctl,
+	 * or both SIOCGMIIREG and SIOCETHTOOL failed (meaning that we
+	 * cannot report link status).  If not reporting, pretend
+	 * we're ok.
+	 */
+	return (reporting ? -1 : BMSR_LSTATUS);
+}
+
+/*----------------------------- Multicast list ------------------------------*/
+
+/*
+ * Returns 0 if dmi1 and dmi2 are the same, non-0 otherwise
+ */
+static inline int bond_is_dmi_same(struct dev_mc_list *dmi1, struct dev_mc_list *dmi2)
+{
+	return memcmp(dmi1->dmi_addr, dmi2->dmi_addr, dmi1->dmi_addrlen) == 0 &&
+			dmi1->dmi_addrlen == dmi2->dmi_addrlen;
+}
+
+/*
+ * returns dmi entry if found, NULL otherwise
+ */
+static struct dev_mc_list *bond_mc_list_find_dmi(struct dev_mc_list *dmi, struct dev_mc_list *mc_list)
+{
+	struct dev_mc_list *idmi;
+
+	for (idmi = mc_list; idmi; idmi = idmi->next) {
+		if (bond_is_dmi_same(dmi, idmi)) {
+			return idmi;
+		}
+	}
+
+	return NULL;
+}
+
+/*
+ * Push the promiscuity flag down to appropriate slaves
+ */
+static void bond_set_promiscuity(struct bonding *bond, int inc)
+{
+	if (USES_PRIMARY(bond->params.mode)) {
+		/* write lock already acquired */
+		if (bond->curr_active_slave) {
+			dev_set_promiscuity(bond->curr_active_slave->dev, inc);
+		}
+	} else {
+		struct slave *slave;
+		int i;
+		bond_for_each_slave(bond, slave, i) {
+			dev_set_promiscuity(slave->dev, inc);
+		}
+	}
+}
+
+/*
+ * Push the allmulti flag down to all slaves
+ */
+static void bond_set_allmulti(struct bonding *bond, int inc)
+{
+	if (USES_PRIMARY(bond->params.mode)) {
+		/* write lock already acquired */
+		if (bond->curr_active_slave) {
+			dev_set_allmulti(bond->curr_active_slave->dev, inc);
+		}
+	} else {
+		struct slave *slave;
+		int i;
+		bond_for_each_slave(bond, slave, i) {
+			dev_set_allmulti(slave->dev, inc);
+		}
+	}
+}
+
+/*
+ * Add a Multicast address to slaves
+ * according to mode
+ */
+static void bond_mc_add(struct bonding *bond, void *addr, int alen)
+{
+	if (USES_PRIMARY(bond->params.mode)) {
+		/* write lock already acquired */
+		if (bond->curr_active_slave) {
+			dev_mc_add(bond->curr_active_slave->dev, addr, alen, 0);
+		}
+	} else {
+		struct slave *slave;
+		int i;
+		bond_for_each_slave(bond, slave, i) {
+			dev_mc_add(slave->dev, addr, alen, 0);
+		}
+	}
+}
+
+/*
+ * Remove a multicast address from slave
+ * according to mode
+ */
+static void bond_mc_delete(struct bonding *bond, void *addr, int alen)
+{
+	if (USES_PRIMARY(bond->params.mode)) {
+		/* write lock already acquired */
+		if (bond->curr_active_slave) {
+			dev_mc_delete(bond->curr_active_slave->dev, addr, alen, 0);
+		}
+	} else {
+		struct slave *slave;
+		int i;
+		bond_for_each_slave(bond, slave, i) {
+			dev_mc_delete(slave->dev, addr, alen, 0);
+		}
+	}
+}
+
+
+/*
+ * Retrieve the list of registered multicast addresses for the bonding
+ * device and retransmit an IGMP JOIN request to the current active
+ * slave.
+ */
+static void bond_resend_igmp_join_requests(struct bonding *bond)
+{
+	struct in_device *in_dev;
+	struct ip_mc_list *im;
+
+	in_dev = in_dev_get(bond->dev);
+	if (in_dev) {
+		for (im = in_dev->mc_list; im; im = im->next) {
+			ip_mc_rejoin_group(im);
+		}
+		in_dev_put(in_dev);
+	}
+}
+
+/*
+ * Totally destroys the mc_list in bond
+ */
+static void bond_mc_list_destroy(struct bonding *bond)
+{
+	struct dev_mc_list *dmi;
+
+	dmi = bond->mc_list;
+	while (dmi) {
+		bond->mc_list = dmi->next;
+		kfree(dmi);
+		dmi = bond->mc_list;
+	}
+	bond->mc_list = NULL;
+}
+
+/*
+ * Copy all the Multicast addresses from src to the bonding device dst
+ */
+static int bond_mc_list_copy(struct dev_mc_list *mc_list, struct bonding *bond, int gpf_flag)
+{
+	struct dev_mc_list *dmi, *new_dmi;
+
+	for (dmi = mc_list; dmi; dmi = dmi->next) {
+		new_dmi = kmalloc(sizeof(struct dev_mc_list), gpf_flag);
+
+		if (!new_dmi) {
+			/* FIXME: Potential memory leak !!! */
+			return -ENOMEM;
+		}
+
+		new_dmi->next = bond->mc_list;
+		bond->mc_list = new_dmi;
+		new_dmi->dmi_addrlen = dmi->dmi_addrlen;
+		memcpy(new_dmi->dmi_addr, dmi->dmi_addr, dmi->dmi_addrlen);
+		new_dmi->dmi_users = dmi->dmi_users;
+		new_dmi->dmi_gusers = dmi->dmi_gusers;
+	}
+
+	return 0;
+}
+
+/*
+ * flush all members of flush->mc_list from device dev->mc_list
+ */
+static void bond_mc_list_flush(struct net_device *bond_dev, struct net_device *slave_dev)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct dev_mc_list *dmi;
+
+	for (dmi = bond_dev->mc_list; dmi; dmi = dmi->next) {
+		dev_mc_delete(slave_dev, dmi->dmi_addr, dmi->dmi_addrlen, 0);
+	}
+
+	if (bond->params.mode == BOND_MODE_8023AD) {
+		/* del lacpdu mc addr from mc list */
+		u8 lacpdu_multicast[ETH_ALEN] = MULTICAST_LACPDU_ADDR;
+
+		dev_mc_delete(slave_dev, lacpdu_multicast, ETH_ALEN, 0);
+	}
+}
+
+/*--------------------------- Active slave change ---------------------------*/
+
+/*
+ * Update the mc list and multicast-related flags for the new and
+ * old active slaves (if any) according to the multicast mode, and
+ * promiscuous flags unconditionally.
+ */
+static void bond_mc_swap(struct bonding *bond, struct slave *new_active, struct slave *old_active)
+{
+	struct dev_mc_list *dmi;
+
+	if (!USES_PRIMARY(bond->params.mode)) {
+		/* nothing to do -  mc list is already up-to-date on
+		 * all slaves
+		 */
+		return;
+	}
+
+	if (old_active) {
+		if (bond->dev->flags & IFF_PROMISC) {
+			dev_set_promiscuity(old_active->dev, -1);
+		}
+
+		if (bond->dev->flags & IFF_ALLMULTI) {
+			dev_set_allmulti(old_active->dev, -1);
+		}
+
+		for (dmi = bond->dev->mc_list; dmi; dmi = dmi->next) {
+			dev_mc_delete(old_active->dev, dmi->dmi_addr, dmi->dmi_addrlen, 0);
+		}
+	}
+
+	if (new_active) {
+		if (bond->dev->flags & IFF_PROMISC) {
+			dev_set_promiscuity(new_active->dev, 1);
+		}
+
+		if (bond->dev->flags & IFF_ALLMULTI) {
+			dev_set_allmulti(new_active->dev, 1);
+		}
+
+		for (dmi = bond->dev->mc_list; dmi; dmi = dmi->next) {
+			dev_mc_add(new_active->dev, dmi->dmi_addr, dmi->dmi_addrlen, 0);
+		}
+		bond_resend_igmp_join_requests(bond);
+	}
+}
+
+/**
+ * find_best_interface - select the best available slave to be the active one
+ * @bond: our bonding struct
+ *
+ * Warning: Caller must hold curr_slave_lock for writing.
+ */
+static struct slave *bond_find_best_slave(struct bonding *bond)
+{
+	struct slave *new_active, *old_active;
+	struct slave *bestslave = NULL;
+	int mintime = bond->params.updelay;
+	int i;
+
+	new_active = old_active = bond->curr_active_slave;
+
+	if (!new_active) { /* there were no active slaves left */
+		if (bond->slave_cnt > 0) {  /* found one slave */
+			new_active = bond->first_slave;
+		} else {
+			return NULL; /* still no slave, return NULL */
+		}
+	}
+
+	/* first try the primary link; if arping, a link must tx/rx traffic
+	 * before it can be considered the curr_active_slave - also, we would skip
+	 * slaves between the curr_active_slave and primary_slave that may be up
+	 * and able to arp
+	 */
+	if ((bond->primary_slave) &&
+	    (!bond->params.arp_interval) &&
+	    (IS_UP(bond->primary_slave->dev))) {
+		new_active = bond->primary_slave;
+	}
+
+	/* remember where to stop iterating over the slaves */
+	old_active = new_active;
+
+	bond_for_each_slave_from(bond, new_active, i, old_active) {
+		if (IS_UP(new_active->dev)) {
+			if (new_active->link == BOND_LINK_UP) {
+				return new_active;
+			} else if (new_active->link == BOND_LINK_BACK) {
+				/* link up, but waiting for stabilization */
+				if (new_active->delay < mintime) {
+					mintime = new_active->delay;
+					bestslave = new_active;
+				}
+			}
+		}
+	}
+
+	return bestslave;
+}
+
+/**
+ * change_active_interface - change the active slave into the specified one
+ * @bond: our bonding struct
+ * @new: the new slave to make the active one
+ *
+ * Set the new slave to the bond's settings and unset them on the old
+ * curr_active_slave.
+ * Setting include flags, mc-list, promiscuity, allmulti, etc.
+ *
+ * If @new's link state is %BOND_LINK_BACK we'll set it to %BOND_LINK_UP,
+ * because it is apparently the best available slave we have, even though its
+ * updelay hasn't timed out yet.
+ *
+ * Warning: Caller must hold curr_slave_lock for writing.
+ */
+static void bond_change_active_slave(struct bonding *bond, struct slave *new_active)
+{
+	struct slave *old_active = bond->curr_active_slave;
+
+	if (old_active == new_active) {
+		return;
+	}
+
+	if (new_active) {
+		if (new_active->link == BOND_LINK_BACK) {
+			if (USES_PRIMARY(bond->params.mode)) {
+				printk(KERN_INFO DRV_NAME
+				       ": %s: making interface %s the new "
+				       "active one %d ms earlier.\n",
+				       bond->dev->name, new_active->dev->name,
+				       (bond->params.updelay - new_active->delay) * bond->params.miimon);
+			}
+
+			new_active->delay = 0;
+			new_active->link = BOND_LINK_UP;
+			new_active->jiffies = jiffies;
+
+			if (bond->params.mode == BOND_MODE_8023AD) {
+				bond_3ad_handle_link_change(new_active, BOND_LINK_UP);
+			}
+
+			if ((bond->params.mode == BOND_MODE_TLB) ||
+			    (bond->params.mode == BOND_MODE_ALB)) {
+				bond_alb_handle_link_change(bond, new_active, BOND_LINK_UP);
+			}
+		} else {
+			if (USES_PRIMARY(bond->params.mode)) {
+				printk(KERN_INFO DRV_NAME
+				       ": %s: making interface %s the new "
+				       "active one.\n",
+				       bond->dev->name, new_active->dev->name);
+			}
+		}
+	}
+
+	if (bond->params.mode == BOND_MODE_ACTIVEBACKUP) {
+		if (old_active) {
+			bond_set_slave_inactive_flags(old_active);
+		}
+
+		if (new_active) {
+			bond_set_slave_active_flags(new_active);
+		}
+	}
+
+	if (USES_PRIMARY(bond->params.mode)) {
+		bond_mc_swap(bond, new_active, old_active);
+	}
+
+	if ((bond->params.mode == BOND_MODE_TLB) ||
+	    (bond->params.mode == BOND_MODE_ALB)) {
+		bond_alb_handle_active_change(bond, new_active);
+	} else {
+		bond->curr_active_slave = new_active;
+	}
+}
+
+/**
+ * bond_select_active_slave - select a new active slave, if needed
+ * @bond: our bonding struct
+ *
+ * This functions shoud be called when one of the following occurs:
+ * - The old curr_active_slave has been released or lost its link.
+ * - The primary_slave has got its link back.
+ * - A slave has got its link back and there's no old curr_active_slave.
+ *
+ * Warning: Caller must hold curr_slave_lock for writing.
+ */
+static void bond_select_active_slave(struct bonding *bond)
+{
+	struct slave *best_slave;
+
+	best_slave = bond_find_best_slave(bond);
+	if (best_slave != bond->curr_active_slave) {
+		bond_change_active_slave(bond, best_slave);
+	}
+}
+
+/*--------------------------- slave list handling ---------------------------*/
+
+/*
+ * This function attaches the slave to the end of list.
+ *
+ * bond->lock held for writing by caller.
+ */
+static void bond_attach_slave(struct bonding *bond, struct slave *new_slave)
+{
+	if (bond->first_slave == NULL) { /* attaching the first slave */
+		new_slave->next = new_slave;
+		new_slave->prev = new_slave;
+		bond->first_slave = new_slave;
+	} else {
+		new_slave->next = bond->first_slave;
+		new_slave->prev = bond->first_slave->prev;
+		new_slave->next->prev = new_slave;
+		new_slave->prev->next = new_slave;
+	}
+
+	bond->slave_cnt++;
+}
+
+/*
+ * This function detaches the slave from the list.
+ * WARNING: no check is made to verify if the slave effectively
+ * belongs to <bond>.
+ * Nothing is freed on return, structures are just unchained.
+ * If any slave pointer in bond was pointing to <slave>,
+ * it should be changed by the calling function.
+ *
+ * bond->lock held for writing by caller.
+ */
+static void bond_detach_slave(struct bonding *bond, struct slave *slave)
+{
+	if (slave->next) {
+		slave->next->prev = slave->prev;
+	}
+
+	if (slave->prev) {
+		slave->prev->next = slave->next;
+	}
+
+	if (bond->first_slave == slave) { /* slave is the first slave */
+		if (bond->slave_cnt > 1) { /* there are more slave */
+			bond->first_slave = slave->next;
+		} else {
+			bond->first_slave = NULL; /* slave was the last one */
+		}
+	}
+
+	slave->next = NULL;
+	slave->prev = NULL;
+	bond->slave_cnt--;
+}
+
+#ifdef HAVE_POLL_CONTROLLER
+static int slaves_support_netpoll(struct net_device *bond_dev)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct slave *slave;
+	int i;
+
+	bond_for_each_slave(bond, slave, i) {
+		if (!slave->dev->poll_controller)
+			return 0;
+	}
+
+	return 1;
+}
+
+static void bond_poll_controller(struct net_device *bond_dev)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct slave *slave;
+	int i;
+
+	bond_for_each_slave(bond, slave, i) {
+		if (slave->dev->poll_controller)
+			slave->dev->poll_controller(slave->dev);
+	}
+}
+#endif
+
+/*---------------------------------- IOCTL ----------------------------------*/
+
+static int bond_sethwaddr(struct net_device *bond_dev, struct net_device *slave_dev)
+{
+	dprintk("bond_dev=%p\n", bond_dev);
+	dprintk("slave_dev=%p\n", slave_dev);
+	dprintk("slave_dev->addr_len=%d\n", slave_dev->addr_len);
+	memcpy(bond_dev->dev_addr, slave_dev->dev_addr, slave_dev->addr_len);
+	return 0;
+}
+
+/* enslave device <slave> to bond device <master> */
+static int bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct slave *new_slave = NULL;
+	struct dev_mc_list *dmi;
+	struct sockaddr addr;
+	int link_reporting;
+	int old_features = bond_dev->features;
+	int res = 0;
+
+	if (slave_dev->do_ioctl == NULL) {
+		printk(KERN_WARNING DRV_NAME
+		       ": Warning : no link monitoring support for %s\n",
+		       slave_dev->name);
+	}
+
+	/* bond must be initialized by bond_open() before enslaving */
+	if (!(bond_dev->flags & IFF_UP)) {
+		dprintk("Error, master_dev is not up\n");
+		return -EPERM;
+	}
+
+	/* already enslaved */
+	if (slave_dev->flags & IFF_SLAVE) {
+		dprintk("Error, Device was already enslaved\n");
+		return -EBUSY;
+	}
+
+	/* vlan challenged mutual exclusion */
+	/* no need to lock since we're protected by rtnl_lock */
+	if (slave_dev->features & NETIF_F_VLAN_CHALLENGED) {
+		dprintk("%s: NETIF_F_VLAN_CHALLENGED\n", slave_dev->name);
+		if (!list_empty(&bond->vlan_list)) {
+			printk(KERN_ERR DRV_NAME
+			       ": Error: cannot enslave VLAN "
+			       "challenged slave %s on VLAN enabled "
+			       "bond %s\n", slave_dev->name,
+			       bond_dev->name);
+			return -EPERM;
+		} else {
+			printk(KERN_WARNING DRV_NAME
+			       ": Warning: enslaved VLAN challenged "
+			       "slave %s. Adding VLANs will be blocked as "
+			       "long as %s is part of bond %s\n",
+			       slave_dev->name, slave_dev->name,
+			       bond_dev->name);
+			bond_dev->features |= NETIF_F_VLAN_CHALLENGED;
+		}
+	} else {
+		dprintk("%s: ! NETIF_F_VLAN_CHALLENGED\n", slave_dev->name);
+		if (bond->slave_cnt == 0) {
+			/* First slave, and it is not VLAN challenged,
+			 * so remove the block of adding VLANs over the bond.
+			 */
+			bond_dev->features &= ~NETIF_F_VLAN_CHALLENGED;
+		}
+	}
+
+	if (app_abi_ver >= 1) {
+		/* The application is using an ABI, which requires the
+		 * slave interface to be closed.
+		 */
+		if ((slave_dev->flags & IFF_UP)) {
+			printk(KERN_ERR DRV_NAME
+			       ": Error: %s is up\n",
+			       slave_dev->name);
+			res = -EPERM;
+			goto err_undo_flags;
+		}
+
+		if (slave_dev->set_mac_address == NULL) {
+			printk(KERN_ERR DRV_NAME
+			       ": Error: The slave device you specified does "
+			       "not support setting the MAC address.\n");
+			printk(KERN_ERR
+			       "Your kernel likely does not support slave "
+			       "devices.\n");
+
+			res = -EOPNOTSUPP;
+			goto err_undo_flags;
+		}
+	} else {
+		/* The application is not using an ABI, which requires the
+		 * slave interface to be open.
+		 */
+		if (!(slave_dev->flags & IFF_UP)) {
+			printk(KERN_ERR DRV_NAME
+			       ": Error: %s is not running\n",
+			       slave_dev->name);
+			res = -EINVAL;
+			goto err_undo_flags;
+		}
+
+		if ((bond->params.mode == BOND_MODE_8023AD) ||
+		    (bond->params.mode == BOND_MODE_TLB)    ||
+		    (bond->params.mode == BOND_MODE_ALB)) {
+			printk(KERN_ERR DRV_NAME
+			       ": Error: to use %s mode, you must upgrade "
+			       "ifenslave.\n",
+			       bond_mode_name(bond->params.mode));
+			res = -EOPNOTSUPP;
+			goto err_undo_flags;
+		}
+	}
+
+	new_slave = kmalloc(sizeof(struct slave), GFP_KERNEL);
+	if (!new_slave) {
+		res = -ENOMEM;
+		goto err_undo_flags;
+	}
+
+	memset(new_slave, 0, sizeof(struct slave));
+
+	/* save slave's original flags before calling
+	 * netdev_set_master and dev_open
+	 */
+	new_slave->original_flags = slave_dev->flags;
+
+	if (app_abi_ver >= 1) {
+		/* save slave's original ("permanent") mac address for
+		 * modes that needs it, and for restoring it upon release,
+		 * and then set it to the master's address
+		 */
+		memcpy(new_slave->perm_hwaddr, slave_dev->dev_addr, ETH_ALEN);
+
+		/* set slave to master's mac address
+		 * The application already set the master's
+		 * mac address to that of the first slave
+		 */
+		memcpy(addr.sa_data, bond_dev->dev_addr, bond_dev->addr_len);
+		addr.sa_family = slave_dev->type;
+		res = slave_dev->set_mac_address(slave_dev, &addr);
+		if (res) {
+			dprintk("Error %d calling set_mac_address\n", res);
+			goto err_free;
+		}
+
+		/* open the slave since the application closed it */
+		res = dev_open(slave_dev);
+		if (res) {
+			dprintk("Openning slave %s failed\n", slave_dev->name);
+			goto err_restore_mac;
+		}
+	}
+
+	res = netdev_set_master(slave_dev, bond_dev);
+	if (res) {
+		dprintk("Error %d calling netdev_set_master\n", res);
+		if (app_abi_ver < 1) {
+			goto err_free;
+		} else {
+			goto err_close;
+		}
+	}
+
+	new_slave->dev = slave_dev;
+
+	if ((bond->params.mode == BOND_MODE_TLB) ||
+	    (bond->params.mode == BOND_MODE_ALB)) {
+		/* bond_alb_init_slave() must be called before all other stages since
+		 * it might fail and we do not want to have to undo everything
+		 */
+		res = bond_alb_init_slave(bond, new_slave);
+		if (res) {
+			goto err_unset_master;
+		}
+	}
+
+	/* If the mode USES_PRIMARY, then the new slave gets the
+	 * master's promisc (and mc) settings only if it becomes the
+	 * curr_active_slave, and that is taken care of later when calling
+	 * bond_change_active()
+	 */
+	if (!USES_PRIMARY(bond->params.mode)) {
+		/* set promiscuity level to new slave */
+		if (bond_dev->flags & IFF_PROMISC) {
+			dev_set_promiscuity(slave_dev, 1);
+		}
+
+		/* set allmulti level to new slave */
+		if (bond_dev->flags & IFF_ALLMULTI) {
+			dev_set_allmulti(slave_dev, 1);
+		}
+
+		/* upload master's mc_list to new slave */
+		for (dmi = bond_dev->mc_list; dmi; dmi = dmi->next) {
+			dev_mc_add (slave_dev, dmi->dmi_addr, dmi->dmi_addrlen, 0);
+		}
+	}
+
+	if (bond->params.mode == BOND_MODE_8023AD) {
+		/* add lacpdu mc addr to mc list */
+		u8 lacpdu_multicast[ETH_ALEN] = MULTICAST_LACPDU_ADDR;
+
+		dev_mc_add(slave_dev, lacpdu_multicast, ETH_ALEN, 0);
+	}
+
+	bond_add_vlans_on_slave(bond, slave_dev);
+
+	write_lock_bh(&bond->lock);
+
+	bond_attach_slave(bond, new_slave);
+
+	new_slave->delay = 0;
+	new_slave->link_failure_count = 0;
+
+	if (bond->params.miimon && !bond->params.use_carrier) {
+		link_reporting = bond_check_dev_link(bond, slave_dev, 1);
+
+		if ((link_reporting == -1) && !bond->params.arp_interval) {
+			/*
+			 * miimon is set but a bonded network driver
+			 * does not support ETHTOOL/MII and
+			 * arp_interval is not set.  Note: if
+			 * use_carrier is enabled, we will never go
+			 * here (because netif_carrier is always
+			 * supported); thus, we don't need to change
+			 * the messages for netif_carrier.
+			 */
+			printk(KERN_WARNING DRV_NAME
+			       ": Warning: MII and ETHTOOL support not "
+			       "available for interface %s, and "
+			       "arp_interval/arp_ip_target module parameters "
+			       "not specified, thus bonding will not detect "
+			       "link failures! see bonding.txt for details.\n",
+			       slave_dev->name);
+		} else if (link_reporting == -1) {
+			/* unable get link status using mii/ethtool */
+			printk(KERN_WARNING DRV_NAME
+			       ": Warning: can't get link status from "
+			       "interface %s; the network driver associated "
+			       "with this interface does not support MII or "
+			       "ETHTOOL link status reporting, thus miimon "
+			       "has no effect on this interface.\n",
+			       slave_dev->name);
+		}
+	}
+
+	/* check for initial state */
+	if (!bond->params.miimon ||
+	    (bond_check_dev_link(bond, slave_dev, 0) == BMSR_LSTATUS)) {
+		if (bond->params.updelay) {
+			dprintk("Initial state of slave_dev is "
+				"BOND_LINK_BACK\n");
+			new_slave->link  = BOND_LINK_BACK;
+			new_slave->delay = bond->params.updelay;
+		} else {
+			dprintk("Initial state of slave_dev is "
+				"BOND_LINK_UP\n");
+			new_slave->link  = BOND_LINK_UP;
+		}
+		new_slave->jiffies = jiffies;
+	} else {
+		dprintk("Initial state of slave_dev is "
+			"BOND_LINK_DOWN\n");
+		new_slave->link  = BOND_LINK_DOWN;
+	}
+
+	if (bond_update_speed_duplex(new_slave) &&
+	    (new_slave->link != BOND_LINK_DOWN)) {
+		printk(KERN_WARNING DRV_NAME
+		       ": Warning: failed to get speed/duplex from %s, speed "
+		       "forced to 100Mbps, duplex forced to Full.\n",
+		       new_slave->dev->name);
+
+		if (bond->params.mode == BOND_MODE_8023AD) {
+			printk(KERN_WARNING
+			       "Operation of 802.3ad mode requires ETHTOOL "
+			       "support in base driver for proper aggregator "
+			       "selection.\n");
+		}
+	}
+
+	if (USES_PRIMARY(bond->params.mode) && bond->params.primary[0]) {
+		/* if there is a primary slave, remember it */
+		if (strcmp(bond->params.primary, new_slave->dev->name) == 0) {
+			bond->primary_slave = new_slave;
+		}
+	}
+
+	switch (bond->params.mode) {
+	case BOND_MODE_ACTIVEBACKUP:
+		/* if we're in active-backup mode, we need one and only one active
+		 * interface. The backup interfaces will have their NOARP flag set
+		 * because we need them to be completely deaf and not to respond to
+		 * any ARP request on the network to avoid fooling a switch. Thus,
+		 * since we guarantee that curr_active_slave always point to the last
+		 * usable interface, we just have to verify this interface's flag.
+		 */
+		if (((!bond->curr_active_slave) ||
+		     (bond->curr_active_slave->dev->flags & IFF_NOARP)) &&
+		    (new_slave->link != BOND_LINK_DOWN)) {
+			dprintk("This is the first active slave\n");
+			/* first slave or no active slave yet, and this link
+			   is OK, so make this interface the active one */
+			bond_change_active_slave(bond, new_slave);
+		} else {
+			dprintk("This is just a backup slave\n");
+			bond_set_slave_inactive_flags(new_slave);
+		}
+		break;
+	case BOND_MODE_8023AD:
+		/* in 802.3ad mode, the internal mechanism
+		 * will activate the slaves in the selected
+		 * aggregator
+		 */
+		bond_set_slave_inactive_flags(new_slave);
+		/* if this is the first slave */
+		if (bond->slave_cnt == 1) {
+			SLAVE_AD_INFO(new_slave).id = 1;
+			/* Initialize AD with the number of times that the AD timer is called in 1 second
+			 * can be called only after the mac address of the bond is set
+			 */
+			bond_3ad_initialize(bond, 1000/AD_TIMER_INTERVAL,
+					    bond->params.lacp_fast);
+		} else {
+			SLAVE_AD_INFO(new_slave).id =
+				SLAVE_AD_INFO(new_slave->prev).id + 1;
+		}
+
+		bond_3ad_bind_slave(new_slave);
+		break;
+	case BOND_MODE_TLB:
+	case BOND_MODE_ALB:
+		new_slave->state = BOND_STATE_ACTIVE;
+		if ((!bond->curr_active_slave) &&
+		    (new_slave->link != BOND_LINK_DOWN)) {
+			/* first slave or no active slave yet, and this link
+			 * is OK, so make this interface the active one
+			 */
+			bond_change_active_slave(bond, new_slave);
+		}
+		break;
+	default:
+		dprintk("This slave is always active in trunk mode\n");
+
+		/* always active in trunk mode */
+		new_slave->state = BOND_STATE_ACTIVE;
+
+		/* In trunking mode there is little meaning to curr_active_slave
+		 * anyway (it holds no special properties of the bond device),
+		 * so we can change it without calling change_active_interface()
+		 */
+		if (!bond->curr_active_slave) {
+			bond->curr_active_slave = new_slave;
+		}
+		break;
+	} /* switch(bond_mode) */
+
+	write_unlock_bh(&bond->lock);
+
+	if (app_abi_ver < 1) {
+		/*
+		 * !!! This is to support old versions of ifenslave.
+		 * We can remove this in 2.5 because our ifenslave takes
+		 * care of this for us.
+		 * We check to see if the master has a mac address yet.
+		 * If not, we'll give it the mac address of our slave device.
+		 */
+		int ndx = 0;
+
+		for (ndx = 0; ndx < bond_dev->addr_len; ndx++) {
+			dprintk("Checking ndx=%d of bond_dev->dev_addr\n",
+				ndx);
+			if (bond_dev->dev_addr[ndx] != 0) {
+				dprintk("Found non-zero byte at ndx=%d\n",
+					ndx);
+				break;
+			}
+		}
+
+		if (ndx == bond_dev->addr_len) {
+			/*
+			 * We got all the way through the address and it was
+			 * all 0's.
+			 */
+			dprintk("%s doesn't have a MAC address yet.  \n",
+				bond_dev->name);
+			dprintk("Going to give assign it from %s.\n",
+				slave_dev->name);
+			bond_sethwaddr(bond_dev, slave_dev);
+		}
+	}
+
+	printk(KERN_INFO DRV_NAME
+	       ": %s: enslaving %s as a%s interface with a%s link.\n",
+	       bond_dev->name, slave_dev->name,
+	       new_slave->state == BOND_STATE_ACTIVE ? "n active" : " backup",
+	       new_slave->link != BOND_LINK_DOWN ? "n up" : " down");
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	if (slaves_support_netpoll(bond_dev)) {
+		bond_dev->poll_controller = bond_poll_controller;
+	} else if (bond_dev->poll_controller) {
+		bond_dev->poll_controller = NULL;
+		printk("New slave device %s does not support netconsole.\n",
+			slave_dev->name);
+		printk("netconsole disabled for %s.\n", bond_dev->name);
+	}
+#endif
+	/* enslave is successful */
+	return 0;
+
+/* Undo stages on error */
+err_unset_master:
+	netdev_set_master(slave_dev, NULL);
+
+err_close:
+	dev_close(slave_dev);
+
+err_restore_mac:
+	memcpy(addr.sa_data, new_slave->perm_hwaddr, ETH_ALEN);
+	addr.sa_family = slave_dev->type;
+	slave_dev->set_mac_address(slave_dev, &addr);
+
+err_free:
+	kfree(new_slave);
+
+err_undo_flags:
+	bond_dev->features = old_features;
+
+	return res;
+}
+
+/*
+ * Try to release the slave device <slave> from the bond device <master>
+ * It is legal to access curr_active_slave without a lock because all the function
+ * is write-locked.
+ *
+ * The rules for slave state should be:
+ *   for Active/Backup:
+ *     Active stays on all backups go down
+ *   for Bonded connections:
+ *     The first up interface should be left on and all others downed.
+ */
+static int bond_release(struct net_device *bond_dev, struct net_device *slave_dev)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct slave *slave, *oldcurrent;
+	struct sockaddr addr;
+	int mac_addr_differ;
+
+	/* slave is not a slave or master is not master of this slave */
+	if (!(slave_dev->flags & IFF_SLAVE) ||
+	    (slave_dev->master != bond_dev)) {
+		printk(KERN_ERR DRV_NAME
+		       ": Error: %s: cannot release %s.\n",
+		       bond_dev->name, slave_dev->name);
+		return -EINVAL;
+	}
+
+	write_lock_bh(&bond->lock);
+
+	slave = bond_get_slave_by_dev(bond, slave_dev);
+	if (!slave) {
+		/* not a slave of this bond */
+		printk(KERN_INFO DRV_NAME
+		       ": %s: %s not enslaved\n",
+		       bond_dev->name, slave_dev->name);
+		return -EINVAL;
+	}
+
+	mac_addr_differ = memcmp(bond_dev->dev_addr,
+				 slave->perm_hwaddr,
+				 ETH_ALEN);
+	if (!mac_addr_differ && (bond->slave_cnt > 1)) {
+		printk(KERN_WARNING DRV_NAME
+		       ": Warning: the permanent HWaddr of %s "
+		       "- %02X:%02X:%02X:%02X:%02X:%02X - is "
+		       "still in use by %s. Set the HWaddr of "
+		       "%s to a different address to avoid "
+		       "conflicts.\n",
+		       slave_dev->name,
+		       slave->perm_hwaddr[0],
+		       slave->perm_hwaddr[1],
+		       slave->perm_hwaddr[2],
+		       slave->perm_hwaddr[3],
+		       slave->perm_hwaddr[4],
+		       slave->perm_hwaddr[5],
+		       bond_dev->name,
+		       slave_dev->name);
+	}
+
+	/* Inform AD package of unbinding of slave. */
+	if (bond->params.mode == BOND_MODE_8023AD) {
+		/* must be called before the slave is
+		 * detached from the list
+		 */
+		bond_3ad_unbind_slave(slave);
+	}
+
+	printk(KERN_INFO DRV_NAME
+	       ": %s: releasing %s interface %s\n",
+	       bond_dev->name,
+	       (slave->state == BOND_STATE_ACTIVE)
+	       ? "active" : "backup",
+	       slave_dev->name);
+
+	oldcurrent = bond->curr_active_slave;
+
+	bond->current_arp_slave = NULL;
+
+	/* release the slave from its bond */
+	bond_detach_slave(bond, slave);
+
+	if (bond->primary_slave == slave) {
+		bond->primary_slave = NULL;
+	}
+
+	if (oldcurrent == slave) {
+		bond_change_active_slave(bond, NULL);
+	}
+
+	if ((bond->params.mode == BOND_MODE_TLB) ||
+	    (bond->params.mode == BOND_MODE_ALB)) {
+		/* Must be called only after the slave has been
+		 * detached from the list and the curr_active_slave
+		 * has been cleared (if our_slave == old_current),
+		 * but before a new active slave is selected.
+		 */
+		bond_alb_deinit_slave(bond, slave);
+	}
+
+	if (oldcurrent == slave) {
+		bond_select_active_slave(bond);
+
+		if (!bond->curr_active_slave) {
+			printk(KERN_INFO DRV_NAME
+			       ": %s: now running without any active "
+			       "interface !\n",
+			       bond_dev->name);
+		}
+	}
+
+	if (bond->slave_cnt == 0) {
+		/* if the last slave was removed, zero the mac address
+		 * of the master so it will be set by the application
+		 * to the mac address of the first slave
+		 */
+		memset(bond_dev->dev_addr, 0, bond_dev->addr_len);
+
+		if (list_empty(&bond->vlan_list)) {
+			bond_dev->features |= NETIF_F_VLAN_CHALLENGED;
+		} else {
+			printk(KERN_WARNING DRV_NAME
+			       ": Warning: clearing HW address of %s while it "
+			       "still has VLANs.\n",
+			       bond_dev->name);
+			printk(KERN_WARNING DRV_NAME
+			       ": When re-adding slaves, make sure the bond's "
+			       "HW address matches its VLANs'.\n");
+		}
+	} else if ((bond_dev->features & NETIF_F_VLAN_CHALLENGED) &&
+		   !bond_has_challenged_slaves(bond)) {
+		printk(KERN_INFO DRV_NAME
+		       ": last VLAN challenged slave %s "
+		       "left bond %s. VLAN blocking is removed\n",
+		       slave_dev->name, bond_dev->name);
+		bond_dev->features &= ~NETIF_F_VLAN_CHALLENGED;
+	}
+
+	write_unlock_bh(&bond->lock);
+
+	bond_del_vlans_from_slave(bond, slave_dev);
+
+	/* If the mode USES_PRIMARY, then we should only remove its
+	 * promisc and mc settings if it was the curr_active_slave, but that was
+	 * already taken care of above when we detached the slave
+	 */
+	if (!USES_PRIMARY(bond->params.mode)) {
+		/* unset promiscuity level from slave */
+		if (bond_dev->flags & IFF_PROMISC) {
+			dev_set_promiscuity(slave_dev, -1);
+		}
+
+		/* unset allmulti level from slave */
+		if (bond_dev->flags & IFF_ALLMULTI) {
+			dev_set_allmulti(slave_dev, -1);
+		}
+
+		/* flush master's mc_list from slave */
+		bond_mc_list_flush(bond_dev, slave_dev);
+	}
+
+	netdev_set_master(slave_dev, NULL);
+
+	/* close slave before restoring its mac address */
+	dev_close(slave_dev);
+
+	if (app_abi_ver >= 1) {
+		/* restore original ("permanent") mac address */
+		memcpy(addr.sa_data, slave->perm_hwaddr, ETH_ALEN);
+		addr.sa_family = slave_dev->type;
+		slave_dev->set_mac_address(slave_dev, &addr);
+	}
+
+	/* restore the original state of the
+	 * IFF_NOARP flag that might have been
+	 * set by bond_set_slave_inactive_flags()
+	 */
+	if ((slave->original_flags & IFF_NOARP) == 0) {
+		slave_dev->flags &= ~IFF_NOARP;
+	}
+
+	kfree(slave);
+
+	return 0;  /* deletion OK */
+}
+
+/*
+ * This function releases all slaves.
+ */
+static int bond_release_all(struct net_device *bond_dev)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct slave *slave;
+	struct net_device *slave_dev;
+	struct sockaddr addr;
+
+	write_lock_bh(&bond->lock);
+
+	if (bond->slave_cnt == 0) {
+		goto out;
+	}
+
+	bond->current_arp_slave = NULL;
+	bond->primary_slave = NULL;
+	bond_change_active_slave(bond, NULL);
+
+	while ((slave = bond->first_slave) != NULL) {
+		/* Inform AD package of unbinding of slave
+		 * before slave is detached from the list.
+		 */
+		if (bond->params.mode == BOND_MODE_8023AD) {
+			bond_3ad_unbind_slave(slave);
+		}
+
+		slave_dev = slave->dev;
+		bond_detach_slave(bond, slave);
+
+		if ((bond->params.mode == BOND_MODE_TLB) ||
+		    (bond->params.mode == BOND_MODE_ALB)) {
+			/* must be called only after the slave
+			 * has been detached from the list
+			 */
+			bond_alb_deinit_slave(bond, slave);
+		}
+
+		/* now that the slave is detached, unlock and perform
+		 * all the undo steps that should not be called from
+		 * within a lock.
+		 */
+		write_unlock_bh(&bond->lock);
+
+		bond_del_vlans_from_slave(bond, slave_dev);
+
+		/* If the mode USES_PRIMARY, then we should only remove its
+		 * promisc and mc settings if it was the curr_active_slave, but that was
+		 * already taken care of above when we detached the slave
+		 */
+		if (!USES_PRIMARY(bond->params.mode)) {
+			/* unset promiscuity level from slave */
+			if (bond_dev->flags & IFF_PROMISC) {
+				dev_set_promiscuity(slave_dev, -1);
+			}
+
+			/* unset allmulti level from slave */
+			if (bond_dev->flags & IFF_ALLMULTI) {
+				dev_set_allmulti(slave_dev, -1);
+			}
+
+			/* flush master's mc_list from slave */
+			bond_mc_list_flush(bond_dev, slave_dev);
+		}
+
+		netdev_set_master(slave_dev, NULL);
+
+		/* close slave before restoring its mac address */
+		dev_close(slave_dev);
+
+		if (app_abi_ver >= 1) {
+			/* restore original ("permanent") mac address*/
+			memcpy(addr.sa_data, slave->perm_hwaddr, ETH_ALEN);
+			addr.sa_family = slave_dev->type;
+			slave_dev->set_mac_address(slave_dev, &addr);
+		}
+
+		/* restore the original state of the IFF_NOARP flag that might have
+		 * been set by bond_set_slave_inactive_flags()
+		 */
+		if ((slave->original_flags & IFF_NOARP) == 0) {
+			slave_dev->flags &= ~IFF_NOARP;
+		}
+
+		kfree(slave);
+
+		/* re-acquire the lock before getting the next slave */
+		write_lock_bh(&bond->lock);
+	}
+
+	/* zero the mac address of the master so it will be
+	 * set by the application to the mac address of the
+	 * first slave
+	 */
+	memset(bond_dev->dev_addr, 0, bond_dev->addr_len);
+
+	if (list_empty(&bond->vlan_list)) {
+		bond_dev->features |= NETIF_F_VLAN_CHALLENGED;
+	} else {
+		printk(KERN_WARNING DRV_NAME
+		       ": Warning: clearing HW address of %s while it "
+		       "still has VLANs.\n",
+		       bond_dev->name);
+		printk(KERN_WARNING DRV_NAME
+		       ": When re-adding slaves, make sure the bond's "
+		       "HW address matches its VLANs'.\n");
+	}
+
+	printk(KERN_INFO DRV_NAME
+	       ": %s: released all slaves\n",
+	       bond_dev->name);
+
+out:
+	write_unlock_bh(&bond->lock);
+
+	return 0;
+}
+
+/*
+ * This function changes the active slave to slave <slave_dev>.
+ * It returns -EINVAL in the following cases.
+ *  - <slave_dev> is not found in the list.
+ *  - There is not active slave now.
+ *  - <slave_dev> is already active.
+ *  - The link state of <slave_dev> is not BOND_LINK_UP.
+ *  - <slave_dev> is not running.
+ * In these cases, this fuction does nothing.
+ * In the other cases, currnt_slave pointer is changed and 0 is returned.
+ */
+static int bond_ioctl_change_active(struct net_device *bond_dev, struct net_device *slave_dev)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct slave *old_active = NULL;
+	struct slave *new_active = NULL;
+	int res = 0;
+
+	if (!USES_PRIMARY(bond->params.mode)) {
+		return -EINVAL;
+	}
+
+	/* Verify that master_dev is indeed the master of slave_dev */
+	if (!(slave_dev->flags & IFF_SLAVE) ||
+	    (slave_dev->master != bond_dev)) {
+		return -EINVAL;
+	}
+
+	write_lock_bh(&bond->lock);
+
+	old_active = bond->curr_active_slave;
+	new_active = bond_get_slave_by_dev(bond, slave_dev);
+
+	/*
+	 * Changing to the current active: do nothing; return success.
+	 */
+	if (new_active && (new_active == old_active)) {
+		write_unlock_bh(&bond->lock);
+		return 0;
+	}
+
+	if ((new_active) &&
+	    (old_active) &&
+	    (new_active->link == BOND_LINK_UP) &&
+	    IS_UP(new_active->dev)) {
+		bond_change_active_slave(bond, new_active);
+	} else {
+		res = -EINVAL;
+	}
+
+	write_unlock_bh(&bond->lock);
+
+	return res;
+}
+
+static int bond_ethtool_ioctl(struct net_device *bond_dev, struct ifreq *ifr)
+{
+	struct ethtool_drvinfo info;
+	void *addr = ifr->ifr_data;
+	uint32_t cmd;
+
+	if (get_user(cmd, (uint32_t *)addr)) {
+		return -EFAULT;
+	}
+
+	switch (cmd) {
+	case ETHTOOL_GDRVINFO:
+		if (copy_from_user(&info, addr, sizeof(info))) {
+			return -EFAULT;
+		}
+
+		if (strcmp(info.driver, "ifenslave") == 0) {
+			int new_abi_ver;
+			char *endptr;
+
+			new_abi_ver = simple_strtoul(info.fw_version,
+						     &endptr, 0);
+			if (*endptr) {
+				printk(KERN_ERR DRV_NAME
+				       ": Error: got invalid ABI "
+				       "version from application\n");
+
+				return -EINVAL;
+			}
+
+			if (orig_app_abi_ver == -1) {
+				orig_app_abi_ver  = new_abi_ver;
+			}
+
+			app_abi_ver = new_abi_ver;
+		}
+
+		strncpy(info.driver,  DRV_NAME, 32);
+		strncpy(info.version, DRV_VERSION, 32);
+		snprintf(info.fw_version, 32, "%d", BOND_ABI_VERSION);
+
+		if (copy_to_user(addr, &info, sizeof(info))) {
+			return -EFAULT;
+		}
+
+		return 0;
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+static int bond_info_query(struct net_device *bond_dev, struct ifbond *info)
+{
+	struct bonding *bond = bond_dev->priv;
+
+	info->bond_mode = bond->params.mode;
+	info->miimon = bond->params.miimon;
+
+	read_lock_bh(&bond->lock);
+	info->num_slaves = bond->slave_cnt;
+	read_unlock_bh(&bond->lock);
+
+	return 0;
+}
+
+static int bond_slave_info_query(struct net_device *bond_dev, struct ifslave *info)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct slave *slave;
+	int i, found = 0;
+
+	if (info->slave_id < 0) {
+		return -ENODEV;
+	}
+
+	read_lock_bh(&bond->lock);
+
+	bond_for_each_slave(bond, slave, i) {
+		if (i == (int)info->slave_id) {
+			found = 1;
+			break;
+		}
+	}
+
+	read_unlock_bh(&bond->lock);
+
+	if (found) {
+		strcpy(info->slave_name, slave->dev->name);
+		info->link = slave->link;
+		info->state = slave->state;
+		info->link_failure_count = slave->link_failure_count;
+	} else {
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+/*-------------------------------- Monitoring -------------------------------*/
+
+/* this function is called regularly to monitor each slave's link. */
+static void bond_mii_monitor(struct net_device *bond_dev)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct slave *slave, *oldcurrent;
+	int do_failover = 0;
+	int delta_in_ticks;
+	int i;
+
+	read_lock(&bond->lock);
+
+	delta_in_ticks = (bond->params.miimon * HZ) / 1000;
+
+	if (bond->kill_timers) {
+		goto out;
+	}
+
+	if (bond->slave_cnt == 0) {
+		goto re_arm;
+	}
+
+	/* we will try to read the link status of each of our slaves, and
+	 * set their IFF_RUNNING flag appropriately. For each slave not
+	 * supporting MII status, we won't do anything so that a user-space
+	 * program could monitor the link itself if needed.
+	 */
+
+	read_lock(&bond->curr_slave_lock);
+	oldcurrent = bond->curr_active_slave;
+	read_unlock(&bond->curr_slave_lock);
+
+	bond_for_each_slave(bond, slave, i) {
+		struct net_device *slave_dev = slave->dev;
+		int link_state;
+		u16 old_speed = slave->speed;
+		u8 old_duplex = slave->duplex;
+
+		link_state = bond_check_dev_link(bond, slave_dev, 0);
+
+		switch (slave->link) {
+		case BOND_LINK_UP:	/* the link was up */
+			if (link_state == BMSR_LSTATUS) {
+				/* link stays up, nothing more to do */
+				break;
+			} else { /* link going down */
+				slave->link  = BOND_LINK_FAIL;
+				slave->delay = bond->params.downdelay;
+
+				if (slave->link_failure_count < UINT_MAX) {
+					slave->link_failure_count++;
+				}
+
+				if (bond->params.downdelay) {
+					printk(KERN_INFO DRV_NAME
+					       ": %s: link status down for %s "
+					       "interface %s, disabling it in "
+					       "%d ms.\n",
+					       bond_dev->name,
+					       IS_UP(slave_dev)
+					       ? ((bond->params.mode == BOND_MODE_ACTIVEBACKUP)
+						  ? ((slave == oldcurrent)
+						     ? "active " : "backup ")
+						  : "")
+					       : "idle ",
+					       slave_dev->name,
+					       bond->params.downdelay * bond->params.miimon);
+				}
+			}
+			/* no break ! fall through the BOND_LINK_FAIL test to
+			   ensure proper action to be taken
+			*/
+		case BOND_LINK_FAIL:	/* the link has just gone down */
+			if (link_state != BMSR_LSTATUS) {
+				/* link stays down */
+				if (slave->delay <= 0) {
+					/* link down for too long time */
+					slave->link = BOND_LINK_DOWN;
+
+					/* in active/backup mode, we must
+					 * completely disable this interface
+					 */
+					if ((bond->params.mode == BOND_MODE_ACTIVEBACKUP) ||
+					    (bond->params.mode == BOND_MODE_8023AD)) {
+						bond_set_slave_inactive_flags(slave);
+					}
+
+					printk(KERN_INFO DRV_NAME
+					       ": %s: link status definitely "
+					       "down for interface %s, "
+					       "disabling it\n",
+					       bond_dev->name,
+					       slave_dev->name);
+
+					/* notify ad that the link status has changed */
+					if (bond->params.mode == BOND_MODE_8023AD) {
+						bond_3ad_handle_link_change(slave, BOND_LINK_DOWN);
+					}
+
+					if ((bond->params.mode == BOND_MODE_TLB) ||
+					    (bond->params.mode == BOND_MODE_ALB)) {
+						bond_alb_handle_link_change(bond, slave, BOND_LINK_DOWN);
+					}
+
+					if (slave == oldcurrent) {
+						do_failover = 1;
+					}
+				} else {
+					slave->delay--;
+				}
+			} else {
+				/* link up again */
+				slave->link  = BOND_LINK_UP;
+				slave->jiffies = jiffies;
+				printk(KERN_INFO DRV_NAME
+				       ": %s: link status up again after %d "
+				       "ms for interface %s.\n",
+				       bond_dev->name,
+				       (bond->params.downdelay - slave->delay) * bond->params.miimon,
+				       slave_dev->name);
+			}
+			break;
+		case BOND_LINK_DOWN:	/* the link was down */
+			if (link_state != BMSR_LSTATUS) {
+				/* the link stays down, nothing more to do */
+				break;
+			} else {	/* link going up */
+				slave->link  = BOND_LINK_BACK;
+				slave->delay = bond->params.updelay;
+
+				if (bond->params.updelay) {
+					/* if updelay == 0, no need to
+					   advertise about a 0 ms delay */
+					printk(KERN_INFO DRV_NAME
+					       ": %s: link status up for "
+					       "interface %s, enabling it "
+					       "in %d ms.\n",
+					       bond_dev->name,
+					       slave_dev->name,
+					       bond->params.updelay * bond->params.miimon);
+				}
+			}
+			/* no break ! fall through the BOND_LINK_BACK state in
+			   case there's something to do.
+			*/
+		case BOND_LINK_BACK:	/* the link has just come back */
+			if (link_state != BMSR_LSTATUS) {
+				/* link down again */
+				slave->link  = BOND_LINK_DOWN;
+
+				printk(KERN_INFO DRV_NAME
+				       ": %s: link status down again after %d "
+				       "ms for interface %s.\n",
+				       bond_dev->name,
+				       (bond->params.updelay - slave->delay) * bond->params.miimon,
+				       slave_dev->name);
+			} else {
+				/* link stays up */
+				if (slave->delay == 0) {
+					/* now the link has been up for long time enough */
+					slave->link = BOND_LINK_UP;
+					slave->jiffies = jiffies;
+
+					if (bond->params.mode == BOND_MODE_8023AD) {
+						/* prevent it from being the active one */
+						slave->state = BOND_STATE_BACKUP;
+					} else if (bond->params.mode != BOND_MODE_ACTIVEBACKUP) {
+						/* make it immediately active */
+						slave->state = BOND_STATE_ACTIVE;
+					} else if (slave != bond->primary_slave) {
+						/* prevent it from being the active one */
+						slave->state = BOND_STATE_BACKUP;
+					}
+
+					printk(KERN_INFO DRV_NAME
+					       ": %s: link status definitely "
+					       "up for interface %s.\n",
+					       bond_dev->name,
+					       slave_dev->name);
+
+					/* notify ad that the link status has changed */
+					if (bond->params.mode == BOND_MODE_8023AD) {
+						bond_3ad_handle_link_change(slave, BOND_LINK_UP);
+					}
+
+					if ((bond->params.mode == BOND_MODE_TLB) ||
+					    (bond->params.mode == BOND_MODE_ALB)) {
+						bond_alb_handle_link_change(bond, slave, BOND_LINK_UP);
+					}
+
+					if ((!oldcurrent) ||
+					    (slave == bond->primary_slave)) {
+						do_failover = 1;
+					}
+				} else {
+					slave->delay--;
+				}
+			}
+			break;
+		default:
+			/* Should not happen */
+			printk(KERN_ERR "bonding: Error: %s  Illegal value (link=%d)\n",
+			       slave->dev->name, slave->link);
+			goto out;
+		} /* end of switch (slave->link) */
+
+		bond_update_speed_duplex(slave);
+
+		if (bond->params.mode == BOND_MODE_8023AD) {
+			if (old_speed != slave->speed) {
+				bond_3ad_adapter_speed_changed(slave);
+			}
+
+			if (old_duplex != slave->duplex) {
+				bond_3ad_adapter_duplex_changed(slave);
+			}
+		}
+
+	} /* end of for */
+
+	if (do_failover) {
+		write_lock(&bond->curr_slave_lock);
+
+		bond_select_active_slave(bond);
+
+		if (oldcurrent && !bond->curr_active_slave) {
+			printk(KERN_INFO DRV_NAME
+			       ": %s: now running without any active "
+			       "interface !\n",
+			       bond_dev->name);
+		}
+
+		write_unlock(&bond->curr_slave_lock);
+	}
+
+re_arm:
+	if (bond->params.miimon) {
+		mod_timer(&bond->mii_timer, jiffies + delta_in_ticks);
+	}
+out:
+	read_unlock(&bond->lock);
+}
+
+static void bond_arp_send_all(struct bonding *bond, struct slave *slave)
+{
+	int i;
+	u32 *targets = bond->params.arp_targets;
+
+	for (i = 0; (i < BOND_MAX_ARP_TARGETS) && targets[i]; i++) {
+		arp_send(ARPOP_REQUEST, ETH_P_ARP, targets[i], slave->dev,
+			 my_ip, NULL, slave->dev->dev_addr,
+			 NULL);
+	}
+}
+
+/*
+ * this function is called regularly to monitor each slave's link
+ * ensuring that traffic is being sent and received when arp monitoring
+ * is used in load-balancing mode. if the adapter has been dormant, then an
+ * arp is transmitted to generate traffic. see activebackup_arp_monitor for
+ * arp monitoring in active backup mode.
+ */
+static void bond_loadbalance_arp_mon(struct net_device *bond_dev)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct slave *slave, *oldcurrent;
+	int do_failover = 0;
+	int delta_in_ticks;
+	int i;
+
+	read_lock(&bond->lock);
+
+	delta_in_ticks = (bond->params.arp_interval * HZ) / 1000;
+
+	if (bond->kill_timers) {
+		goto out;
+	}
+
+	if (bond->slave_cnt == 0) {
+		goto re_arm;
+	}
+
+	read_lock(&bond->curr_slave_lock);
+	oldcurrent = bond->curr_active_slave;
+	read_unlock(&bond->curr_slave_lock);
+
+	/* see if any of the previous devices are up now (i.e. they have
+	 * xmt and rcv traffic). the curr_active_slave does not come into
+	 * the picture unless it is null. also, slave->jiffies is not needed
+	 * here because we send an arp on each slave and give a slave as
+	 * long as it needs to get the tx/rx within the delta.
+	 * TODO: what about up/down delay in arp mode? it wasn't here before
+	 *       so it can wait
+	 */
+	bond_for_each_slave(bond, slave, i) {
+		if (slave->link != BOND_LINK_UP) {
+			if (((jiffies - slave->dev->trans_start) <= delta_in_ticks) &&
+			    ((jiffies - slave->dev->last_rx) <= delta_in_ticks)) {
+
+				slave->link  = BOND_LINK_UP;
+				slave->state = BOND_STATE_ACTIVE;
+
+				/* primary_slave has no meaning in round-robin
+				 * mode. the window of a slave being up and
+				 * curr_active_slave being null after enslaving
+				 * is closed.
+				 */
+				if (!oldcurrent) {
+					printk(KERN_INFO DRV_NAME
+					       ": %s: link status definitely "
+					       "up for interface %s, ",
+					       bond_dev->name,
+					       slave->dev->name);
+					do_failover = 1;
+				} else {
+					printk(KERN_INFO DRV_NAME
+					       ": %s: interface %s is now up\n",
+					       bond_dev->name,
+					       slave->dev->name);
+				}
+			}
+		} else {
+			/* slave->link == BOND_LINK_UP */
+
+			/* not all switches will respond to an arp request
+			 * when the source ip is 0, so don't take the link down
+			 * if we don't know our ip yet
+			 */
+			if (((jiffies - slave->dev->trans_start) >= (2*delta_in_ticks)) ||
+			    (((jiffies - slave->dev->last_rx) >= (2*delta_in_ticks)) &&
+			     my_ip)) {
+
+				slave->link  = BOND_LINK_DOWN;
+				slave->state = BOND_STATE_BACKUP;
+
+				if (slave->link_failure_count < UINT_MAX) {
+					slave->link_failure_count++;
+				}
+
+				printk(KERN_INFO DRV_NAME
+				       ": %s: interface %s is now down.\n",
+				       bond_dev->name,
+				       slave->dev->name);
+
+				if (slave == oldcurrent) {
+					do_failover = 1;
+				}
+			}
+		}
+
+		/* note: if switch is in round-robin mode, all links
+		 * must tx arp to ensure all links rx an arp - otherwise
+		 * links may oscillate or not come up at all; if switch is
+		 * in something like xor mode, there is nothing we can
+		 * do - all replies will be rx'ed on same link causing slaves
+		 * to be unstable during low/no traffic periods
+		 */
+		if (IS_UP(slave->dev)) {
+			bond_arp_send_all(bond, slave);
+		}
+	}
+
+	if (do_failover) {
+		write_lock(&bond->curr_slave_lock);
+
+		bond_select_active_slave(bond);
+
+		if (oldcurrent && !bond->curr_active_slave) {
+			printk(KERN_INFO DRV_NAME
+			       ": %s: now running without any active "
+			       "interface !\n",
+			       bond_dev->name);
+		}
+
+		write_unlock(&bond->curr_slave_lock);
+	}
+
+re_arm:
+	if (bond->params.arp_interval) {
+		mod_timer(&bond->arp_timer, jiffies + delta_in_ticks);
+	}
+out:
+	read_unlock(&bond->lock);
+}
+
+/*
+ * When using arp monitoring in active-backup mode, this function is
+ * called to determine if any backup slaves have went down or a new
+ * current slave needs to be found.
+ * The backup slaves never generate traffic, they are considered up by merely
+ * receiving traffic. If the current slave goes down, each backup slave will
+ * be given the opportunity to tx/rx an arp before being taken down - this
+ * prevents all slaves from being taken down due to the current slave not
+ * sending any traffic for the backups to receive. The arps are not necessarily
+ * necessary, any tx and rx traffic will keep the current slave up. While any
+ * rx traffic will keep the backup slaves up, the current slave is responsible
+ * for generating traffic to keep them up regardless of any other traffic they
+ * may have received.
+ * see loadbalance_arp_monitor for arp monitoring in load balancing mode
+ */
+static void bond_activebackup_arp_mon(struct net_device *bond_dev)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct slave *slave;
+	int delta_in_ticks;
+	int i;
+
+	read_lock(&bond->lock);
+
+	delta_in_ticks = (bond->params.arp_interval * HZ) / 1000;
+
+	if (bond->kill_timers) {
+		goto out;
+	}
+
+	if (bond->slave_cnt == 0) {
+		goto re_arm;
+	}
+
+	/* determine if any slave has come up or any backup slave has
+	 * gone down
+	 * TODO: what about up/down delay in arp mode? it wasn't here before
+	 *       so it can wait
+	 */
+	bond_for_each_slave(bond, slave, i) {
+		if (slave->link != BOND_LINK_UP) {
+			if ((jiffies - slave->dev->last_rx) <= delta_in_ticks) {
+
+				slave->link = BOND_LINK_UP;
+
+				write_lock(&bond->curr_slave_lock);
+
+				if ((!bond->curr_active_slave) &&
+				    ((jiffies - slave->dev->trans_start) <= delta_in_ticks)) {
+					bond_change_active_slave(bond, slave);
+					bond->current_arp_slave = NULL;
+				} else if (bond->curr_active_slave != slave) {
+					/* this slave has just come up but we
+					 * already have a current slave; this
+					 * can also happen if bond_enslave adds
+					 * a new slave that is up while we are
+					 * searching for a new slave
+					 */
+					bond_set_slave_inactive_flags(slave);
+					bond->current_arp_slave = NULL;
+				}
+
+				if (slave == bond->curr_active_slave) {
+					printk(KERN_INFO DRV_NAME
+					       ": %s: %s is up and now the "
+					       "active interface\n",
+					       bond_dev->name,
+					       slave->dev->name);
+				} else {
+					printk(KERN_INFO DRV_NAME
+					       ": %s: backup interface %s is "
+					       "now up\n",
+					       bond_dev->name,
+					       slave->dev->name);
+				}
+
+				write_unlock(&bond->curr_slave_lock);
+			}
+		} else {
+			read_lock(&bond->curr_slave_lock);
+
+			if ((slave != bond->curr_active_slave) &&
+			    (!bond->current_arp_slave) &&
+			    (((jiffies - slave->dev->last_rx) >= 3*delta_in_ticks) &&
+			     my_ip)) {
+				/* a backup slave has gone down; three times
+				 * the delta allows the current slave to be
+				 * taken out before the backup slave.
+				 * note: a non-null current_arp_slave indicates
+				 * the curr_active_slave went down and we are
+				 * searching for a new one; under this
+				 * condition we only take the curr_active_slave
+				 * down - this gives each slave a chance to
+				 * tx/rx traffic before being taken out
+				 */
+
+				read_unlock(&bond->curr_slave_lock);
+
+				slave->link  = BOND_LINK_DOWN;
+
+				if (slave->link_failure_count < UINT_MAX) {
+					slave->link_failure_count++;
+				}
+
+				bond_set_slave_inactive_flags(slave);
+
+				printk(KERN_INFO DRV_NAME
+				       ": %s: backup interface %s is now down\n",
+				       bond_dev->name,
+				       slave->dev->name);
+			} else {
+				read_unlock(&bond->curr_slave_lock);
+			}
+		}
+	}
+
+	read_lock(&bond->curr_slave_lock);
+	slave = bond->curr_active_slave;
+	read_unlock(&bond->curr_slave_lock);
+
+	if (slave) {
+		/* if we have sent traffic in the past 2*arp_intervals but
+		 * haven't xmit and rx traffic in that time interval, select
+		 * a different slave. slave->jiffies is only updated when
+		 * a slave first becomes the curr_active_slave - not necessarily
+		 * after every arp; this ensures the slave has a full 2*delta
+		 * before being taken out. if a primary is being used, check
+		 * if it is up and needs to take over as the curr_active_slave
+		 */
+		if ((((jiffies - slave->dev->trans_start) >= (2*delta_in_ticks)) ||
+		     (((jiffies - slave->dev->last_rx) >= (2*delta_in_ticks)) &&
+		      my_ip)) &&
+		    ((jiffies - slave->jiffies) >= 2*delta_in_ticks)) {
+
+			slave->link  = BOND_LINK_DOWN;
+
+			if (slave->link_failure_count < UINT_MAX) {
+				slave->link_failure_count++;
+			}
+
+			printk(KERN_INFO DRV_NAME
+			       ": %s: link status down for active interface "
+			       "%s, disabling it\n",
+			       bond_dev->name,
+			       slave->dev->name);
+
+			write_lock(&bond->curr_slave_lock);
+
+			bond_select_active_slave(bond);
+			slave = bond->curr_active_slave;
+
+			write_unlock(&bond->curr_slave_lock);
+
+			bond->current_arp_slave = slave;
+
+			if (slave) {
+				slave->jiffies = jiffies;
+			}
+		} else if ((bond->primary_slave) &&
+			   (bond->primary_slave != slave) &&
+			   (bond->primary_slave->link == BOND_LINK_UP)) {
+			/* at this point, slave is the curr_active_slave */
+			printk(KERN_INFO DRV_NAME
+			       ": %s: changing from interface %s to primary "
+			       "interface %s\n",
+			       bond_dev->name,
+			       slave->dev->name,
+			       bond->primary_slave->dev->name);
+
+			/* primary is up so switch to it */
+			write_lock(&bond->curr_slave_lock);
+			bond_change_active_slave(bond, bond->primary_slave);
+			write_unlock(&bond->curr_slave_lock);
+
+			slave = bond->primary_slave;
+			slave->jiffies = jiffies;
+		} else {
+			bond->current_arp_slave = NULL;
+		}
+
+		/* the current slave must tx an arp to ensure backup slaves
+		 * rx traffic
+		 */
+		if (slave && my_ip) {
+			bond_arp_send_all(bond, slave);
+		}
+	}
+
+	/* if we don't have a curr_active_slave, search for the next available
+	 * backup slave from the current_arp_slave and make it the candidate
+	 * for becoming the curr_active_slave
+	 */
+	if (!slave) {
+		if (!bond->current_arp_slave) {
+			bond->current_arp_slave = bond->first_slave;
+		}
+
+		if (bond->current_arp_slave) {
+			bond_set_slave_inactive_flags(bond->current_arp_slave);
+
+			/* search for next candidate */
+			bond_for_each_slave_from(bond, slave, i, bond->current_arp_slave->next) {
+				if (IS_UP(slave->dev)) {
+					slave->link = BOND_LINK_BACK;
+					bond_set_slave_active_flags(slave);
+					bond_arp_send_all(bond, slave);
+					slave->jiffies = jiffies;
+					bond->current_arp_slave = slave;
+					break;
+				}
+
+				/* if the link state is up at this point, we
+				 * mark it down - this can happen if we have
+				 * simultaneous link failures and
+				 * reselect_active_interface doesn't make this
+				 * one the current slave so it is still marked
+				 * up when it is actually down
+				 */
+				if (slave->link == BOND_LINK_UP) {
+					slave->link  = BOND_LINK_DOWN;
+					if (slave->link_failure_count < UINT_MAX) {
+						slave->link_failure_count++;
+					}
+
+					bond_set_slave_inactive_flags(slave);
+
+					printk(KERN_INFO DRV_NAME
+					       ": %s: backup interface %s is "
+					       "now down.\n",
+					       bond_dev->name,
+					       slave->dev->name);
+				}
+			}
+		}
+	}
+
+re_arm:
+	if (bond->params.arp_interval) {
+		mod_timer(&bond->arp_timer, jiffies + delta_in_ticks);
+	}
+out:
+	read_unlock(&bond->lock);
+}
+
+/*------------------------------ proc/seq_file-------------------------------*/
+
+#ifdef CONFIG_PROC_FS
+
+#define SEQ_START_TOKEN ((void *)1)
+
+static void *bond_info_seq_start(struct seq_file *seq, loff_t *pos)
+{
+	struct bonding *bond = seq->private;
+	loff_t off = 0;
+	struct slave *slave;
+	int i;
+
+	/* make sure the bond won't be taken away */
+	read_lock(&dev_base_lock);
+	read_lock_bh(&bond->lock);
+
+	if (*pos == 0) {
+		return SEQ_START_TOKEN;
+	}
+
+	bond_for_each_slave(bond, slave, i) {
+		if (++off == *pos) {
+			return slave;
+		}
+	}
+
+	return NULL;
+}
+
+static void *bond_info_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	struct bonding *bond = seq->private;
+	struct slave *slave = v;
+
+	++*pos;
+	if (v == SEQ_START_TOKEN) {
+		return bond->first_slave;
+	}
+
+	slave = slave->next;
+
+	return (slave == bond->first_slave) ? NULL : slave;
+}
+
+static void bond_info_seq_stop(struct seq_file *seq, void *v)
+{
+	struct bonding *bond = seq->private;
+
+	read_unlock_bh(&bond->lock);
+	read_unlock(&dev_base_lock);
+}
+
+static void bond_info_show_master(struct seq_file *seq)
+{
+	struct bonding *bond = seq->private;
+	struct slave *curr;
+
+	read_lock(&bond->curr_slave_lock);
+	curr = bond->curr_active_slave;
+	read_unlock(&bond->curr_slave_lock);
+
+	seq_printf(seq, "Bonding Mode: %s\n",
+		   bond_mode_name(bond->params.mode));
+
+	if (USES_PRIMARY(bond->params.mode)) {
+		seq_printf(seq, "Primary Slave: %s\n",
+			   (bond->params.primary[0]) ?
+			   	bond->params.primary : "None");
+
+		seq_printf(seq, "Currently Active Slave: %s\n",
+			   (curr) ? curr->dev->name : "None");
+	}
+
+	seq_printf(seq, "MII Status: %s\n", (curr) ? "up" : "down");
+	seq_printf(seq, "MII Polling Interval (ms): %d\n", bond->params.miimon);
+	seq_printf(seq, "Up Delay (ms): %d\n",
+		   bond->params.updelay * bond->params.miimon);
+	seq_printf(seq, "Down Delay (ms): %d\n",
+		   bond->params.downdelay * bond->params.miimon);
+
+	if (bond->params.mode == BOND_MODE_8023AD) {
+		struct ad_info ad_info;
+
+		seq_puts(seq, "\n802.3ad info\n");
+		seq_printf(seq, "LACP rate: %s\n",
+			   (bond->params.lacp_fast) ? "fast" : "slow");
+
+		if (bond_3ad_get_active_agg_info(bond, &ad_info)) {
+			seq_printf(seq, "bond %s has no active aggregator\n",
+				   bond->dev->name);
+		} else {
+			seq_printf(seq, "Active Aggregator Info:\n");
+
+			seq_printf(seq, "\tAggregator ID: %d\n",
+				   ad_info.aggregator_id);
+			seq_printf(seq, "\tNumber of ports: %d\n",
+				   ad_info.ports);
+			seq_printf(seq, "\tActor Key: %d\n",
+				   ad_info.actor_key);
+			seq_printf(seq, "\tPartner Key: %d\n",
+				   ad_info.partner_key);
+			seq_printf(seq, "\tPartner Mac Address: %02x:%02x:%02x:%02x:%02x:%02x\n",
+				   ad_info.partner_system[0],
+				   ad_info.partner_system[1],
+				   ad_info.partner_system[2],
+				   ad_info.partner_system[3],
+				   ad_info.partner_system[4],
+				   ad_info.partner_system[5]);
+		}
+	}
+}
+
+static void bond_info_show_slave(struct seq_file *seq, const struct slave *slave)
+{
+	struct bonding *bond = seq->private;
+
+	seq_printf(seq, "\nSlave Interface: %s\n", slave->dev->name);
+	seq_printf(seq, "MII Status: %s\n",
+		   (slave->link == BOND_LINK_UP) ?  "up" : "down");
+	seq_printf(seq, "Link Failure Count: %d\n",
+		   slave->link_failure_count);
+
+	if (app_abi_ver >= 1) {
+		seq_printf(seq,
+			   "Permanent HW addr: %02x:%02x:%02x:%02x:%02x:%02x\n",
+			   slave->perm_hwaddr[0],
+			   slave->perm_hwaddr[1],
+			   slave->perm_hwaddr[2],
+			   slave->perm_hwaddr[3],
+			   slave->perm_hwaddr[4],
+			   slave->perm_hwaddr[5]);
+	}
+
+	if (bond->params.mode == BOND_MODE_8023AD) {
+		const struct aggregator *agg
+			= SLAVE_AD_INFO(slave).port.aggregator;
+
+		if (agg) {
+			seq_printf(seq, "Aggregator ID: %d\n",
+				   agg->aggregator_identifier);
+		} else {
+			seq_puts(seq, "Aggregator ID: N/A\n");
+		}
+	}
+}
+
+static int bond_info_seq_show(struct seq_file *seq, void *v)
+{
+	if (v == SEQ_START_TOKEN) {
+		seq_printf(seq, "%s\n", version);
+		bond_info_show_master(seq);
+	} else {
+		bond_info_show_slave(seq, v);
+	}
+
+	return 0;
+}
+
+static struct seq_operations bond_info_seq_ops = {
+	.start = bond_info_seq_start,
+	.next  = bond_info_seq_next,
+	.stop  = bond_info_seq_stop,
+	.show  = bond_info_seq_show,
+};
+
+static int bond_info_open(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq;
+	struct proc_dir_entry *proc;
+	int res;
+
+	res = seq_open(file, &bond_info_seq_ops);
+	if (!res) {
+		/* recover the pointer buried in proc_dir_entry data */
+		seq = file->private_data;
+		proc = PDE(inode);
+		seq->private = proc->data;
+	}
+
+	return res;
+}
+
+static struct file_operations bond_info_fops = {
+	.owner   = THIS_MODULE,
+	.open    = bond_info_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = seq_release,
+};
+
+static int bond_create_proc_entry(struct bonding *bond)
+{
+	struct net_device *bond_dev = bond->dev;
+
+	if (bond_proc_dir) {
+		bond->proc_entry = create_proc_entry(bond_dev->name,
+						     S_IRUGO,
+						     bond_proc_dir);
+		if (bond->proc_entry == NULL) {
+			printk(KERN_WARNING DRV_NAME
+			       ": Warning: Cannot create /proc/net/%s/%s\n",
+			       DRV_NAME, bond_dev->name);
+		} else {
+			bond->proc_entry->data = bond;
+			bond->proc_entry->proc_fops = &bond_info_fops;
+			bond->proc_entry->owner = THIS_MODULE;
+			memcpy(bond->proc_file_name, bond_dev->name, IFNAMSIZ);
+		}
+	}
+
+	return 0;
+}
+
+static void bond_remove_proc_entry(struct bonding *bond)
+{
+	if (bond_proc_dir && bond->proc_entry) {
+		remove_proc_entry(bond->proc_file_name, bond_proc_dir);
+		memset(bond->proc_file_name, 0, IFNAMSIZ);
+		bond->proc_entry = NULL;
+	}
+}
+
+/* Create the bonding directory under /proc/net, if doesn't exist yet.
+ * Caller must hold rtnl_lock.
+ */
+static void bond_create_proc_dir(void)
+{
+	int len = strlen(DRV_NAME);
+
+	for (bond_proc_dir = proc_net->subdir; bond_proc_dir;
+	     bond_proc_dir = bond_proc_dir->next) {
+		if ((bond_proc_dir->namelen == len) &&
+		    !memcmp(bond_proc_dir->name, DRV_NAME, len)) {
+			break;
+		}
+	}
+
+	if (!bond_proc_dir) {
+		bond_proc_dir = proc_mkdir(DRV_NAME, proc_net);
+		if (bond_proc_dir) {
+			bond_proc_dir->owner = THIS_MODULE;
+		} else {
+			printk(KERN_WARNING DRV_NAME
+				": Warning: cannot create /proc/net/%s\n",
+				DRV_NAME);
+		}
+	}
+}
+
+/* Destroy the bonding directory under /proc/net, if empty.
+ * Caller must hold rtnl_lock.
+ */
+static void bond_destroy_proc_dir(void)
+{
+	struct proc_dir_entry *de;
+
+	if (!bond_proc_dir) {
+		return;
+	}
+
+	/* verify that the /proc dir is empty */
+	for (de = bond_proc_dir->subdir; de; de = de->next) {
+		/* ignore . and .. */
+		if (*(de->name) != '.') {
+			break;
+		}
+	}
+
+	if (de) {
+		if (bond_proc_dir->owner == THIS_MODULE) {
+			bond_proc_dir->owner = NULL;
+		}
+	} else {
+		remove_proc_entry(DRV_NAME, proc_net);
+		bond_proc_dir = NULL;
+	}
+}
+#endif /* CONFIG_PROC_FS */
+
+/*-------------------------- netdev event handling --------------------------*/
+
+/*
+ * Change device name
+ */
+static int bond_event_changename(struct bonding *bond)
+{
+#ifdef CONFIG_PROC_FS
+	bond_remove_proc_entry(bond);
+	bond_create_proc_entry(bond);
+#endif
+
+	return NOTIFY_DONE;
+}
+
+static int bond_master_netdev_event(unsigned long event, struct net_device *bond_dev)
+{
+	struct bonding *event_bond = bond_dev->priv;
+
+	switch (event) {
+	case NETDEV_CHANGENAME:
+		return bond_event_changename(event_bond);
+	case NETDEV_UNREGISTER:
+		/*
+		 * TODO: remove a bond from the list?
+		 */
+		break;
+	default:
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static int bond_slave_netdev_event(unsigned long event, struct net_device *slave_dev)
+{
+	struct net_device *bond_dev = slave_dev->master;
+
+	switch (event) {
+	case NETDEV_UNREGISTER:
+		if (bond_dev) {
+			bond_release(bond_dev, slave_dev);
+		}
+		break;
+	case NETDEV_CHANGE:
+		/*
+		 * TODO: is this what we get if somebody
+		 * sets up a hierarchical bond, then rmmod's
+		 * one of the slave bonding devices?
+		 */
+		break;
+	case NETDEV_DOWN:
+		/*
+		 * ... Or is it this?
+		 */
+		break;
+	case NETDEV_CHANGEMTU:
+		/*
+		 * TODO: Should slaves be allowed to
+		 * independently alter their MTU?  For
+		 * an active-backup bond, slaves need
+		 * not be the same type of device, so
+		 * MTUs may vary.  For other modes,
+		 * slaves arguably should have the
+		 * same MTUs. To do this, we'd need to
+		 * take over the slave's change_mtu
+		 * function for the duration of their
+		 * servitude.
+		 */
+		break;
+	case NETDEV_CHANGENAME:
+		/*
+		 * TODO: handle changing the primary's name
+		 */
+		break;
+	default:
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+/*
+ * bond_netdev_event: handle netdev notifier chain events.
+ *
+ * This function receives events for the netdev chain.  The caller (an
+ * ioctl handler calling notifier_call_chain) holds the necessary
+ * locks for us to safely manipulate the slave devices (RTNL lock,
+ * dev_probe_lock).
+ */
+static int bond_netdev_event(struct notifier_block *this, unsigned long event, void *ptr)
+{
+	struct net_device *event_dev = (struct net_device *)ptr;
+
+	dprintk("event_dev: %s, event: %lx\n",
+		(event_dev ? event_dev->name : "None"),
+		event);
+
+	if (event_dev->flags & IFF_MASTER) {
+		dprintk("IFF_MASTER\n");
+		return bond_master_netdev_event(event, event_dev);
+	}
+
+	if (event_dev->flags & IFF_SLAVE) {
+		dprintk("IFF_SLAVE\n");
+		return bond_slave_netdev_event(event, event_dev);
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block bond_netdev_notifier = {
+	.notifier_call = bond_netdev_event,
+};
+
+/*-------------------------- Packet type handling ---------------------------*/
+
+/* register to receive lacpdus on a bond */
+static void bond_register_lacpdu(struct bonding *bond)
+{
+	struct packet_type *pk_type = &(BOND_AD_INFO(bond).ad_pkt_type);
+
+	/* initialize packet type */
+	pk_type->type = PKT_TYPE_LACPDU;
+	pk_type->dev = bond->dev;
+	pk_type->func = bond_3ad_lacpdu_recv;
+	pk_type->data = (void*)1;  /* understand shared skbs */
+
+	dev_add_pack(pk_type);
+}
+
+/* unregister to receive lacpdus on a bond */
+static void bond_unregister_lacpdu(struct bonding *bond)
+{
+	dev_remove_pack(&(BOND_AD_INFO(bond).ad_pkt_type));
+}
+
+/*-------------------------- Device entry points ----------------------------*/
+
+static int bond_open(struct net_device *bond_dev)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct timer_list *mii_timer = &bond->mii_timer;
+	struct timer_list *arp_timer = &bond->arp_timer;
+
+	bond->kill_timers = 0;
+
+	if ((bond->params.mode == BOND_MODE_TLB) ||
+	    (bond->params.mode == BOND_MODE_ALB)) {
+		struct timer_list *alb_timer = &(BOND_ALB_INFO(bond).alb_timer);
+
+		/* bond_alb_initialize must be called before the timer
+		 * is started.
+		 */
+		if (bond_alb_initialize(bond, (bond->params.mode == BOND_MODE_ALB))) {
+			/* something went wrong - fail the open operation */
+			return -1;
+		}
+
+		init_timer(alb_timer);
+		alb_timer->expires  = jiffies + 1;
+		alb_timer->data     = (unsigned long)bond;
+		alb_timer->function = (void *)&bond_alb_monitor;
+		add_timer(alb_timer);
+	}
+
+	if (bond->params.miimon) {  /* link check interval, in milliseconds. */
+		init_timer(mii_timer);
+		mii_timer->expires  = jiffies + 1;
+		mii_timer->data     = (unsigned long)bond_dev;
+		mii_timer->function = (void *)&bond_mii_monitor;
+		add_timer(mii_timer);
+	}
+
+	if (bond->params.arp_interval) {  /* arp interval, in milliseconds. */
+		init_timer(arp_timer);
+		arp_timer->expires  = jiffies + 1;
+		arp_timer->data     = (unsigned long)bond_dev;
+		if (bond->params.mode == BOND_MODE_ACTIVEBACKUP) {
+			arp_timer->function = (void *)&bond_activebackup_arp_mon;
+		} else {
+			arp_timer->function = (void *)&bond_loadbalance_arp_mon;
+		}
+		add_timer(arp_timer);
+	}
+
+	if (bond->params.mode == BOND_MODE_8023AD) {
+		struct timer_list *ad_timer = &(BOND_AD_INFO(bond).ad_timer);
+		init_timer(ad_timer);
+		ad_timer->expires  = jiffies + 1;
+		ad_timer->data     = (unsigned long)bond;
+		ad_timer->function = (void *)&bond_3ad_state_machine_handler;
+		add_timer(ad_timer);
+
+		/* register to receive LACPDUs */
+		bond_register_lacpdu(bond);
+	}
+
+	return 0;
+}
+
+static int bond_close(struct net_device *bond_dev)
+{
+	struct bonding *bond = bond_dev->priv;
+
+	write_lock_bh(&bond->lock);
+
+	bond_mc_list_destroy(bond);
+
+	if (bond->params.mode == BOND_MODE_8023AD) {
+		/* Unregister the receive of LACPDUs */
+		bond_unregister_lacpdu(bond);
+	}
+
+	/* signal timers not to re-arm */
+	bond->kill_timers = 1;
+
+	write_unlock_bh(&bond->lock);
+
+	/* del_timer_sync must run without holding the bond->lock
+	 * because a running timer might be trying to hold it too
+	 */
+
+	if (bond->params.miimon) {  /* link check interval, in milliseconds. */
+		del_timer_sync(&bond->mii_timer);
+	}
+
+	if (bond->params.arp_interval) {  /* arp interval, in milliseconds. */
+		del_timer_sync(&bond->arp_timer);
+	}
+
+	switch (bond->params.mode) {
+	case BOND_MODE_8023AD:
+		del_timer_sync(&(BOND_AD_INFO(bond).ad_timer));
+		break;
+	case BOND_MODE_TLB:
+	case BOND_MODE_ALB:
+		del_timer_sync(&(BOND_ALB_INFO(bond).alb_timer));
+		break;
+	default:
+		break;
+	}
+
+	/* Release the bonded slaves */
+	bond_release_all(bond_dev);
+
+	if ((bond->params.mode == BOND_MODE_TLB) ||
+	    (bond->params.mode == BOND_MODE_ALB)) {
+		/* Must be called only after all
+		 * slaves have been released
+		 */
+		bond_alb_deinitialize(bond);
+	}
+
+	return 0;
+}
+
+static struct net_device_stats *bond_get_stats(struct net_device *bond_dev)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct net_device_stats *stats = &(bond->stats), *sstats;
+	struct slave *slave;
+	int i;
+
+	memset(stats, 0, sizeof(struct net_device_stats));
+
+	read_lock_bh(&bond->lock);
+
+	bond_for_each_slave(bond, slave, i) {
+		sstats = slave->dev->get_stats(slave->dev);
+
+		stats->rx_packets += sstats->rx_packets;
+		stats->rx_bytes += sstats->rx_bytes;
+		stats->rx_errors += sstats->rx_errors;
+		stats->rx_dropped += sstats->rx_dropped;
+
+		stats->tx_packets += sstats->tx_packets;
+		stats->tx_bytes += sstats->tx_bytes;
+		stats->tx_errors += sstats->tx_errors;
+		stats->tx_dropped += sstats->tx_dropped;
+
+		stats->multicast += sstats->multicast;
+		stats->collisions += sstats->collisions;
+
+		stats->rx_length_errors += sstats->rx_length_errors;
+		stats->rx_over_errors += sstats->rx_over_errors;
+		stats->rx_crc_errors += sstats->rx_crc_errors;
+		stats->rx_frame_errors += sstats->rx_frame_errors;
+		stats->rx_fifo_errors += sstats->rx_fifo_errors;
+		stats->rx_missed_errors += sstats->rx_missed_errors;
+
+		stats->tx_aborted_errors += sstats->tx_aborted_errors;
+		stats->tx_carrier_errors += sstats->tx_carrier_errors;
+		stats->tx_fifo_errors += sstats->tx_fifo_errors;
+		stats->tx_heartbeat_errors += sstats->tx_heartbeat_errors;
+		stats->tx_window_errors += sstats->tx_window_errors;
+	}
+
+	read_unlock_bh(&bond->lock);
+
+	return stats;
+}
+
+static int bond_do_ioctl(struct net_device *bond_dev, struct ifreq *ifr, int cmd)
+{
+	struct net_device *slave_dev = NULL;
+	struct ifbond *u_binfo = NULL, k_binfo;
+	struct ifslave *u_sinfo = NULL, k_sinfo;
+	struct mii_ioctl_data *mii = NULL;
+	int prev_abi_ver = orig_app_abi_ver;
+	int res = 0;
+
+	dprintk("bond_ioctl: master=%s, cmd=%d\n",
+		bond_dev->name, cmd);
+
+	switch (cmd) {
+	case SIOCETHTOOL:
+		return bond_ethtool_ioctl(bond_dev, ifr);
+	case SIOCGMIIPHY:
+		mii = (struct mii_ioctl_data *)&ifr->ifr_data;
+		if (!mii) {
+			return -EINVAL;
+		}
+		mii->phy_id = 0;
+		/* Fall Through */
+	case SIOCGMIIREG:
+		/*
+		 * We do this again just in case we were called by SIOCGMIIREG
+		 * instead of SIOCGMIIPHY.
+		 */
+		mii = (struct mii_ioctl_data *)&ifr->ifr_data;
+		if (!mii) {
+			return -EINVAL;
+		}
+
+		if (mii->reg_num == 1) {
+			struct bonding *bond = bond_dev->priv;
+			mii->val_out = 0;
+			read_lock_bh(&bond->lock);
+			read_lock(&bond->curr_slave_lock);
+			if (bond->curr_active_slave) {
+				mii->val_out = BMSR_LSTATUS;
+			}
+			read_unlock(&bond->curr_slave_lock);
+			read_unlock_bh(&bond->lock);
+		}
+
+		return 0;
+	case BOND_INFO_QUERY_OLD:
+	case SIOCBONDINFOQUERY:
+		u_binfo = (struct ifbond *)ifr->ifr_data;
+
+		if (copy_from_user(&k_binfo, u_binfo, sizeof(ifbond))) {
+			return -EFAULT;
+		}
+
+		res = bond_info_query(bond_dev, &k_binfo);
+		if (res == 0) {
+			if (copy_to_user(u_binfo, &k_binfo, sizeof(ifbond))) {
+				return -EFAULT;
+			}
+		}
+
+		return res;
+	case BOND_SLAVE_INFO_QUERY_OLD:
+	case SIOCBONDSLAVEINFOQUERY:
+		u_sinfo = (struct ifslave *)ifr->ifr_data;
+
+		if (copy_from_user(&k_sinfo, u_sinfo, sizeof(ifslave))) {
+			return -EFAULT;
+		}
+
+		res = bond_slave_info_query(bond_dev, &k_sinfo);
+		if (res == 0) {
+			if (copy_to_user(u_sinfo, &k_sinfo, sizeof(ifslave))) {
+				return -EFAULT;
+			}
+		}
+
+		return res;
+	default:
+		/* Go on */
+		break;
+	}
+
+	if (!capable(CAP_NET_ADMIN)) {
+		return -EPERM;
+	}
+
+	if (orig_app_abi_ver == -1) {
+		/* no orig_app_abi_ver was provided yet, so we'll use the
+		 * current one from now on, even if it's 0
+		 */
+		orig_app_abi_ver = app_abi_ver;
+
+	} else if (orig_app_abi_ver != app_abi_ver) {
+		printk(KERN_ERR DRV_NAME
+		       ": Error: already using ifenslave ABI version %d; to "
+		       "upgrade ifenslave to version %d, you must first "
+		       "reload bonding.\n",
+		       orig_app_abi_ver, app_abi_ver);
+		return -EINVAL;
+	}
+
+	slave_dev = dev_get_by_name(ifr->ifr_slave);
+
+	dprintk("slave_dev=%p: \n", slave_dev);
+
+	if (!slave_dev) {
+		res = -ENODEV;
+	} else {
+		dprintk("slave_dev->name=%s: \n", slave_dev->name);
+		switch (cmd) {
+		case BOND_ENSLAVE_OLD:
+		case SIOCBONDENSLAVE:
+			res = bond_enslave(bond_dev, slave_dev);
+			break;
+		case BOND_RELEASE_OLD:
+		case SIOCBONDRELEASE:
+			res = bond_release(bond_dev, slave_dev);
+			break;
+		case BOND_SETHWADDR_OLD:
+		case SIOCBONDSETHWADDR:
+			res = bond_sethwaddr(bond_dev, slave_dev);
+			break;
+		case BOND_CHANGE_ACTIVE_OLD:
+		case SIOCBONDCHANGEACTIVE:
+			res = bond_ioctl_change_active(bond_dev, slave_dev);
+			break;
+		default:
+			res = -EOPNOTSUPP;
+		}
+
+		dev_put(slave_dev);
+	}
+
+	if (res < 0) {
+		/* The ioctl failed, so there's no point in changing the
+		 * orig_app_abi_ver. We'll restore it's value just in case
+		 * we've changed it earlier in this function.
+		 */
+		orig_app_abi_ver = prev_abi_ver;
+	}
+
+	return res;
+}
+
+static void bond_set_multicast_list(struct net_device *bond_dev)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct dev_mc_list *dmi;
+
+	write_lock_bh(&bond->lock);
+
+	/*
+	 * Do promisc before checking multicast_mode
+	 */
+	if ((bond_dev->flags & IFF_PROMISC) && !(bond->flags & IFF_PROMISC)) {
+		bond_set_promiscuity(bond, 1);
+	}
+
+	if (!(bond_dev->flags & IFF_PROMISC) && (bond->flags & IFF_PROMISC)) {
+		bond_set_promiscuity(bond, -1);
+	}
+
+	/* set allmulti flag to slaves */
+	if ((bond_dev->flags & IFF_ALLMULTI) && !(bond->flags & IFF_ALLMULTI)) {
+		bond_set_allmulti(bond, 1);
+	}
+
+	if (!(bond_dev->flags & IFF_ALLMULTI) && (bond->flags & IFF_ALLMULTI)) {
+		bond_set_allmulti(bond, -1);
+	}
+
+	bond->flags = bond_dev->flags;
+
+	/* looking for addresses to add to slaves' mc list */
+	for (dmi = bond_dev->mc_list; dmi; dmi = dmi->next) {
+		if (!bond_mc_list_find_dmi(dmi, bond->mc_list)) {
+			bond_mc_add(bond, dmi->dmi_addr, dmi->dmi_addrlen);
+		}
+	}
+
+	/* looking for addresses to delete from slaves' list */
+	for (dmi = bond->mc_list; dmi; dmi = dmi->next) {
+		if (!bond_mc_list_find_dmi(dmi, bond_dev->mc_list)) {
+			bond_mc_delete(bond, dmi->dmi_addr, dmi->dmi_addrlen);
+		}
+	}
+
+	/* save master's multicast list */
+	bond_mc_list_destroy(bond);
+	bond_mc_list_copy(bond_dev->mc_list, bond, GFP_ATOMIC);
+
+	write_unlock_bh(&bond->lock);
+}
+
+/*
+ * Change the MTU of all of a master's slaves to match the master
+ */
+static int bond_change_mtu(struct net_device *bond_dev, int new_mtu)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct slave *slave, *stop_at;
+	int res = 0;
+	int i;
+
+	dprintk("bond=%p, name=%s, new_mtu=%d\n", bond,
+		(bond_dev ? bond_dev->name : "None"), new_mtu);
+
+	/* Can't hold bond->lock with bh disabled here since
+	 * some base drivers panic. On the other hand we can't
+	 * hold bond->lock without bh disabled because we'll
+	 * deadlock. The only solution is to rely on the fact
+	 * that we're under rtnl_lock here, and the slaves
+	 * list won't change. This doesn't solve the problem
+	 * of setting the slave's MTU while it is
+	 * transmitting, but the assumption is that the base
+	 * driver can handle that.
+	 *
+	 * TODO: figure out a way to safely iterate the slaves
+	 * list, but without holding a lock around the actual
+	 * call to the base driver.
+	 */
+
+	bond_for_each_slave(bond, slave, i) {
+		dprintk("s %p s->p %p c_m %p\n", slave,
+			slave->prev, slave->dev->change_mtu);
+		if (slave->dev->change_mtu) {
+			res = slave->dev->change_mtu(slave->dev, new_mtu);
+		} else {
+			slave->dev->mtu = new_mtu;
+			res = 0;
+		}
+
+		if (res) {
+			/* If we failed to set the slave's mtu to the new value
+			 * we must abort the operation even in ACTIVE_BACKUP
+			 * mode, because if we allow the backup slaves to have
+			 * different mtu values than the active slave we'll
+			 * need to change their mtu when doing a failover. That
+			 * means changing their mtu from timer context, which
+			 * is probably not a good idea.
+			 */
+			dprintk("err %d %s\n", res, slave->dev->name);
+			goto unwind;
+		}
+	}
+
+	bond_dev->mtu = new_mtu;
+
+	return 0;
+
+unwind:
+	/* unwind from head to the slave that failed */
+	stop_at = slave;
+	bond_for_each_slave_from_to(bond, slave, i, bond->first_slave, stop_at) {
+		int tmp_res;
+
+		if (slave->dev->change_mtu) {
+			tmp_res = slave->dev->change_mtu(slave->dev, bond_dev->mtu);
+			if (tmp_res) {
+				dprintk("unwind err %d dev %s\n", tmp_res,
+					slave->dev->name);
+			}
+		} else {
+			slave->dev->mtu = bond_dev->mtu;
+		}
+	}
+
+	return res;
+}
+
+/*
+ * Change HW address
+ *
+ * Note that many devices must be down to change the HW address, and
+ * downing the master releases all slaves.  We can make bonds full of
+ * bonding devices to test this, however.
+ */
+static int bond_set_mac_address(struct net_device *bond_dev, void *addr)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct sockaddr *sa = addr, tmp_sa;
+	struct slave *slave, *stop_at;
+	int res = 0;
+	int i;
+
+	dprintk("bond=%p, name=%s\n", bond, (bond_dev ? bond_dev->name : "None"));
+
+	if (!is_valid_ether_addr(sa->sa_data)) {
+		return -EADDRNOTAVAIL;
+	}
+
+	/* Can't hold bond->lock with bh disabled here since
+	 * some base drivers panic. On the other hand we can't
+	 * hold bond->lock without bh disabled because we'll
+	 * deadlock. The only solution is to rely on the fact
+	 * that we're under rtnl_lock here, and the slaves
+	 * list won't change. This doesn't solve the problem
+	 * of setting the slave's hw address while it is
+	 * transmitting, but the assumption is that the base
+	 * driver can handle that.
+	 *
+	 * TODO: figure out a way to safely iterate the slaves
+	 * list, but without holding a lock around the actual
+	 * call to the base driver.
+	 */
+
+	bond_for_each_slave(bond, slave, i) {
+		dprintk("slave %p %s\n", slave, slave->dev->name);
+
+		if (slave->dev->set_mac_address == NULL) {
+			res = -EOPNOTSUPP;
+			dprintk("EOPNOTSUPP %s\n", slave->dev->name);
+			goto unwind;
+		}
+
+		res = slave->dev->set_mac_address(slave->dev, addr);
+		if (res) {
+			/* TODO: consider downing the slave
+			 * and retry ?
+			 * User should expect communications
+			 * breakage anyway until ARP finish
+			 * updating, so...
+			 */
+			dprintk("err %d %s\n", res, slave->dev->name);
+			goto unwind;
+		}
+	}
+
+	/* success */
+	memcpy(bond_dev->dev_addr, sa->sa_data, bond_dev->addr_len);
+	return 0;
+
+unwind:
+	memcpy(tmp_sa.sa_data, bond_dev->dev_addr, bond_dev->addr_len);
+	tmp_sa.sa_family = bond_dev->type;
+
+	/* unwind from head to the slave that failed */
+	stop_at = slave;
+	bond_for_each_slave_from_to(bond, slave, i, bond->first_slave, stop_at) {
+		int tmp_res;
+
+		tmp_res = slave->dev->set_mac_address(slave->dev, &tmp_sa);
+		if (tmp_res) {
+			dprintk("unwind err %d dev %s\n", tmp_res,
+				slave->dev->name);
+		}
+	}
+
+	return res;
+}
+
+static int bond_xmit_roundrobin(struct sk_buff *skb, struct net_device *bond_dev)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct slave *slave, *start_at;
+	int i;
+	int res = 1;
+
+	read_lock(&bond->lock);
+
+	if (!BOND_IS_OK(bond)) {
+		goto out;
+	}
+
+	read_lock(&bond->curr_slave_lock);
+	slave = start_at = bond->curr_active_slave;
+	read_unlock(&bond->curr_slave_lock);
+
+	if (!slave) {
+		goto out;
+	}
+
+	bond_for_each_slave_from(bond, slave, i, start_at) {
+		if (IS_UP(slave->dev) &&
+		    (slave->link == BOND_LINK_UP) &&
+		    (slave->state == BOND_STATE_ACTIVE)) {
+			res = bond_dev_queue_xmit(bond, skb, slave->dev);
+
+			write_lock(&bond->curr_slave_lock);
+			bond->curr_active_slave = slave->next;
+			write_unlock(&bond->curr_slave_lock);
+
+			break;
+		}
+	}
+
+
+out:
+	if (res) {
+		/* no suitable interface, frame not sent */
+		dev_kfree_skb(skb);
+	}
+	read_unlock(&bond->lock);
+	return 0;
+}
+
+
+/*
+ * in active-backup mode, we know that bond->curr_active_slave is always valid if
+ * the bond has a usable interface.
+ */
+static int bond_xmit_activebackup(struct sk_buff *skb, struct net_device *bond_dev)
+{
+	struct bonding *bond = bond_dev->priv;
+	int res = 1;
+
+	/* if we are sending arp packets, try to at least
+	   identify our own ip address */
+	if (bond->params.arp_interval && !my_ip &&
+		(skb->protocol == __constant_htons(ETH_P_ARP))) {
+		char *the_ip = (char *)skb->data +
+				sizeof(struct ethhdr) +
+				sizeof(struct arphdr) +
+				ETH_ALEN;
+		memcpy(&my_ip, the_ip, 4);
+	}
+
+	read_lock(&bond->lock);
+	read_lock(&bond->curr_slave_lock);
+
+	if (!BOND_IS_OK(bond)) {
+		goto out;
+	}
+
+	if (!bond->curr_active_slave)
+		goto out;
+
+	res = bond_dev_queue_xmit(bond, skb, bond->curr_active_slave->dev);
+
+out:
+	if (res) {
+		/* no suitable interface, frame not sent */
+		dev_kfree_skb(skb);
+	}
+	read_unlock(&bond->curr_slave_lock);
+	read_unlock(&bond->lock);
+	return 0;
+}
+
+/*
+ * in XOR mode, we determine the output device by performing xor on
+ * the source and destination hw adresses.  If this device is not
+ * enabled, find the next slave following this xor slave.
+ */
+static int bond_xmit_xor(struct sk_buff *skb, struct net_device *bond_dev)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct ethhdr *data = (struct ethhdr *)skb->data;
+	struct slave *slave, *start_at;
+	int slave_no;
+	int i;
+	int res = 1;
+
+	read_lock(&bond->lock);
+
+	if (!BOND_IS_OK(bond)) {
+		goto out;
+	}
+
+	slave_no = (data->h_dest[5]^bond_dev->dev_addr[5]) % bond->slave_cnt;
+
+	bond_for_each_slave(bond, slave, i) {
+		slave_no--;
+		if (slave_no < 0) {
+			break;
+		}
+	}
+
+	start_at = slave;
+
+	bond_for_each_slave_from(bond, slave, i, start_at) {
+		if (IS_UP(slave->dev) &&
+		    (slave->link == BOND_LINK_UP) &&
+		    (slave->state == BOND_STATE_ACTIVE)) {
+			res = bond_dev_queue_xmit(bond, skb, slave->dev);
+			break;
+		}
+	}
+
+out:
+	if (res) {
+		/* no suitable interface, frame not sent */
+		dev_kfree_skb(skb);
+	}
+	read_unlock(&bond->lock);
+	return 0;
+}
+
+/*
+ * in broadcast mode, we send everything to all usable interfaces.
+ */
+static int bond_xmit_broadcast(struct sk_buff *skb, struct net_device *bond_dev)
+{
+	struct bonding *bond = bond_dev->priv;
+	struct slave *slave, *start_at;
+	struct net_device *tx_dev = NULL;
+	int i;
+	int res = 1;
+
+	read_lock(&bond->lock);
+
+	if (!BOND_IS_OK(bond)) {
+		goto out;
+	}
+
+	read_lock(&bond->curr_slave_lock);
+	start_at = bond->curr_active_slave;
+	read_unlock(&bond->curr_slave_lock);
+
+	if (!start_at) {
+		goto out;
+	}
+
+	bond_for_each_slave_from(bond, slave, i, start_at) {
+		if (IS_UP(slave->dev) &&
+		    (slave->link == BOND_LINK_UP) &&
+		    (slave->state == BOND_STATE_ACTIVE)) {
+			if (tx_dev) {
+				struct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);
+				if (!skb2) {
+					printk(KERN_ERR DRV_NAME
+					       ": Error: bond_xmit_broadcast(): "
+					       "skb_clone() failed\n");
+					continue;
+				}
+
+				res = bond_dev_queue_xmit(bond, skb2, tx_dev);
+				if (res) {
+					dev_kfree_skb(skb2);
+					continue;
+				}
+			}
+			tx_dev = slave->dev;
+		}
+	}
+
+	if (tx_dev) {
+		res = bond_dev_queue_xmit(bond, skb, tx_dev);
+	}
+
+out:
+	if (res) {
+		/* no suitable interface, frame not sent */
+		dev_kfree_skb(skb);
+	}
+	/* frame sent to all suitable interfaces */
+	read_unlock(&bond->lock);
+	return 0;
+}
+
+#ifdef CONFIG_NET_FASTROUTE
+static int bond_accept_fastpath(struct net_device *bond_dev, struct dst_entry *dst)
+{
+	return -1;
+}
+#endif
+
+/*------------------------- Device initialization ---------------------------*/
+
+/*
+ * set bond mode specific net device operations
+ */
+static inline void bond_set_mode_ops(struct net_device *bond_dev, int mode)
+{
+	switch (mode) {
+	case BOND_MODE_ROUNDROBIN:
+		bond_dev->hard_start_xmit = bond_xmit_roundrobin;
+		break;
+	case BOND_MODE_ACTIVEBACKUP:
+		bond_dev->hard_start_xmit = bond_xmit_activebackup;
+		break;
+	case BOND_MODE_XOR:
+		bond_dev->hard_start_xmit = bond_xmit_xor;
+		break;
+	case BOND_MODE_BROADCAST:
+		bond_dev->hard_start_xmit = bond_xmit_broadcast;
+		break;
+	case BOND_MODE_8023AD:
+		bond_dev->hard_start_xmit = bond_3ad_xmit_xor;
+		break;
+	case BOND_MODE_TLB:
+	case BOND_MODE_ALB:
+		bond_dev->hard_start_xmit = bond_alb_xmit;
+		bond_dev->set_mac_address = bond_alb_set_mac_address;
+		break;
+	default:
+		/* Should never happen, mode already checked */
+		printk(KERN_ERR DRV_NAME
+		       ": Error: Unknown bonding mode %d\n",
+		       mode);
+		break;
+	}
+}
+
+/*
+ * Does not allocate but creates a /proc entry.
+ * Allowed to fail.
+ */
+static int __init bond_init(struct net_device *bond_dev, struct bond_params *params)
+{
+	struct bonding *bond = bond_dev->priv;
+
+	dprintk("Begin bond_init for %s\n", bond_dev->name);
+
+	/* initialize rwlocks */
+	rwlock_init(&bond->lock);
+	rwlock_init(&bond->curr_slave_lock);
+
+	bond->params = *params; /* copy params struct */
+
+	/* Initialize pointers */
+	bond->first_slave = NULL;
+	bond->curr_active_slave = NULL;
+	bond->current_arp_slave = NULL;
+	bond->primary_slave = NULL;
+	bond->dev = bond_dev;
+	INIT_LIST_HEAD(&bond->vlan_list);
+
+	/* Initialize the device entry points */
+	bond_dev->open = bond_open;
+	bond_dev->stop = bond_close;
+	bond_dev->get_stats = bond_get_stats;
+	bond_dev->do_ioctl = bond_do_ioctl;
+	bond_dev->set_multicast_list = bond_set_multicast_list;
+	bond_dev->change_mtu = bond_change_mtu;
+	bond_dev->set_mac_address = bond_set_mac_address;
+
+	bond_set_mode_ops(bond_dev, bond->params.mode);
+
+#ifdef CONFIG_NET_FASTROUTE
+	bond_dev->accept_fastpath = bond_accept_fastpath;
+#endif
+
+#ifdef HAVE_POLL_CONTROLLER
+	bond_dev->poll_controller = bond_poll_controller;
+#endif
+	/* Initialize the device options */
+	bond_dev->tx_queue_len = 0;
+	bond_dev->flags |= IFF_MASTER|IFF_MULTICAST;
+
+	/* At first, we block adding VLANs. That's the only way to
+	 * prevent problems that occur when adding VLANs over an
+	 * empty bond. The block will be removed once non-challenged
+	 * slaves are enslaved.
+	 */
+	bond_dev->features |= NETIF_F_VLAN_CHALLENGED;
+
+	/* By default, we declare the bond to be fully
+	 * VLAN hardware accelerated capable. Special
+	 * care is taken in the various xmit functions
+	 * when there are slaves that are not hw accel
+	 * capable
+	 */
+	bond_dev->vlan_rx_register = bond_vlan_rx_register;
+	bond_dev->vlan_rx_add_vid  = bond_vlan_rx_add_vid;
+	bond_dev->vlan_rx_kill_vid = bond_vlan_rx_kill_vid;
+	bond_dev->features |= (NETIF_F_HW_VLAN_TX |
+			       NETIF_F_HW_VLAN_RX |
+			       NETIF_F_HW_VLAN_FILTER);
+
+#ifdef CONFIG_PROC_FS
+	bond_create_proc_entry(bond);
+#endif
+
+	list_add_tail(&bond->bond_list, &bond_dev_list);
+
+	return 0;
+}
+
+/* De-initialize device specific data.
+ * Caller must hold rtnl_lock.
+ */
+static inline void bond_deinit(struct net_device *bond_dev)
+{
+	struct bonding *bond = bond_dev->priv;
+
+	list_del(&bond->bond_list);
+
+#ifdef CONFIG_PROC_FS
+	bond_remove_proc_entry(bond);
+#endif
+}
+
+/* Unregister and free all bond devices.
+ * Caller must hold rtnl_lock.
+ */
+static void bond_free_all(void)
+{
+	struct bonding *bond, *nxt;
+
+	list_for_each_entry_safe(bond, nxt, &bond_dev_list, bond_list) {
+		struct net_device *bond_dev = bond->dev;
+
+		unregister_netdevice(bond_dev);
+		bond_deinit(bond_dev);
+		free_netdev(bond_dev);
+	}
+
+#ifdef CONFIG_PROC_FS
+	bond_destroy_proc_dir();
+#endif
+}
+
+/*------------------------- Module initialization ---------------------------*/
+
+/*
+ * Convert string input module parms.  Accept either the
+ * number of the mode or its string name.
+ */
+static inline int bond_parse_parm(char *mode_arg, struct bond_parm_tbl *tbl)
+{
+	int i;
+
+	for (i = 0; tbl[i].modename; i++) {
+		if ((isdigit(*mode_arg) &&
+		     tbl[i].mode == simple_strtol(mode_arg, NULL, 0)) ||
+		    (strncmp(mode_arg, tbl[i].modename,
+			     strlen(tbl[i].modename)) == 0)) {
+			return tbl[i].mode;
+		}
+	}
+
+	return -1;
+}
+
+static int bond_check_params(struct bond_params *params)
+{
+	/*
+	 * Convert string parameters.
+	 */
+	if (mode) {
+		bond_mode = bond_parse_parm(mode, bond_mode_tbl);
+		if (bond_mode == -1) {
+			printk(KERN_ERR DRV_NAME
+			       ": Error: Invalid bonding mode \"%s\"\n",
+			       mode == NULL ? "NULL" : mode);
+			return -EINVAL;
+		}
+	}
+
+	if (lacp_rate) {
+		if (bond_mode != BOND_MODE_8023AD) {
+			printk(KERN_INFO DRV_NAME
+			       ": lacp_rate param is irrelevant in mode %s\n",
+			       bond_mode_name(bond_mode));
+		} else {
+			lacp_fast = bond_parse_parm(lacp_rate, bond_lacp_tbl);
+			if (lacp_fast == -1) {
+				printk(KERN_ERR DRV_NAME
+				       ": Error: Invalid lacp rate \"%s\"\n",
+				       lacp_rate == NULL ? "NULL" : lacp_rate);
+				return -EINVAL;
+			}
+		}
+	}
+
+	if (max_bonds < 1 || max_bonds > INT_MAX) {
+		printk(KERN_WARNING DRV_NAME
+		       ": Warning: max_bonds (%d) not in range %d-%d, so it "
+		       "was reset to BOND_DEFAULT_MAX_BONDS (%d)",
+		       max_bonds, 1, INT_MAX, BOND_DEFAULT_MAX_BONDS);
+		max_bonds = BOND_DEFAULT_MAX_BONDS;
+	}
+
+	if (miimon < 0) {
+		printk(KERN_WARNING DRV_NAME
+		       ": Warning: miimon module parameter (%d), "
+		       "not in range 0-%d, so it was reset to %d\n",
+		       miimon, INT_MAX, BOND_LINK_MON_INTERV);
+		miimon = BOND_LINK_MON_INTERV;
+	}
+
+	if (updelay < 0) {
+		printk(KERN_WARNING DRV_NAME
+		       ": Warning: updelay module parameter (%d), "
+		       "not in range 0-%d, so it was reset to 0\n",
+		       updelay, INT_MAX);
+		updelay = 0;
+	}
+
+	if (downdelay < 0) {
+		printk(KERN_WARNING DRV_NAME
+		       ": Warning: downdelay module parameter (%d), "
+		       "not in range 0-%d, so it was reset to 0\n",
+		       downdelay, INT_MAX);
+		downdelay = 0;
+	}
+
+	if ((use_carrier != 0) && (use_carrier != 1)) {
+		printk(KERN_WARNING DRV_NAME
+		       ": Warning: use_carrier module parameter (%d), "
+		       "not of valid value (0/1), so it was set to 1\n",
+		       use_carrier);
+		use_carrier = 1;
+	}
+
+	/* reset values for 802.3ad */
+	if (bond_mode == BOND_MODE_8023AD) {
+		if (!miimon) {
+			printk(KERN_WARNING DRV_NAME
+			       ": Warning: miimon must be specified, "
+			       "otherwise bonding will not detect link "
+			       "failure, speed and duplex which are "
+			       "essential for 802.3ad operation\n");
+			printk(KERN_WARNING "Forcing miimon to 100msec\n");
+			miimon = 100;
+		}
+	}
+
+	/* reset values for TLB/ALB */
+	if ((bond_mode == BOND_MODE_TLB) ||
+	    (bond_mode == BOND_MODE_ALB)) {
+		if (!miimon) {
+			printk(KERN_WARNING DRV_NAME
+			       ": Warning: miimon must be specified, "
+			       "otherwise bonding will not detect link "
+			       "failure and link speed which are essential "
+			       "for TLB/ALB load balancing\n");
+			printk(KERN_WARNING "Forcing miimon to 100msec\n");
+			miimon = 100;
+		}
+	}
+
+	if (bond_mode == BOND_MODE_ALB) {
+		printk(KERN_NOTICE DRV_NAME
+		       ": In ALB mode you might experience client "
+		       "disconnections upon reconnection of a link if the "
+		       "bonding module updelay parameter (%d msec) is "
+		       "incompatible with the forwarding delay time of the "
+		       "switch\n",
+		       updelay);
+	}
+
+	if (!miimon) {
+		if (updelay || downdelay) {
+			/* just warn the user the up/down delay will have
+			 * no effect since miimon is zero...
+			 */
+			printk(KERN_WARNING DRV_NAME
+			       ": Warning: miimon module parameter not set "
+			       "and updelay (%d) or downdelay (%d) module "
+			       "parameter is set; updelay and downdelay have "
+			       "no effect unless miimon is set\n",
+			       updelay, downdelay);
+		}
+	} else {
+		/* don't allow arp monitoring */
+		if (arp_interval) {
+			printk(KERN_WARNING DRV_NAME
+			       ": Warning: miimon (%d) and arp_interval (%d) "
+			       "can't be used simultaneously, disabling ARP "
+			       "monitoring\n",
+			       miimon, arp_interval);
+			arp_interval = 0;
+		}
+
+		if ((updelay % miimon) != 0) {
+			printk(KERN_WARNING DRV_NAME
+			       ": Warning: updelay (%d) is not a multiple "
+			       "of miimon (%d), updelay rounded to %d ms\n",
+			       updelay, miimon, (updelay / miimon) * miimon);
+		}
+
+		updelay /= miimon;
+
+		if ((downdelay % miimon) != 0) {
+			printk(KERN_WARNING DRV_NAME
+			       ": Warning: downdelay (%d) is not a multiple "
+			       "of miimon (%d), downdelay rounded to %d ms\n",
+			       downdelay, miimon,
+			       (downdelay / miimon) * miimon);
+		}
+
+		downdelay /= miimon;
+	}
+
+	if (arp_interval < 0) {
+		printk(KERN_WARNING DRV_NAME
+		       ": Warning: arp_interval module parameter (%d) "
+		       ", not in range 0-%d, so it was reset to %d\n",
+		       arp_interval, INT_MAX, BOND_LINK_ARP_INTERV);
+		arp_interval = BOND_LINK_ARP_INTERV;
+	}
+
+	for (arp_ip_count = 0;
+	     (arp_ip_count < BOND_MAX_ARP_TARGETS) && arp_ip_target[arp_ip_count];
+	     arp_ip_count++) {
+		/* not complete check, but should be good enough to
+		   catch mistakes */
+		if (!isdigit(arp_ip_target[arp_ip_count][0])) {
+			printk(KERN_WARNING DRV_NAME
+			       ": Warning: bad arp_ip_target module parameter "
+			       "(%s), ARP monitoring will not be performed\n",
+			       arp_ip_target[arp_ip_count]);
+			arp_interval = 0;
+		} else {
+			u32 ip = in_aton(arp_ip_target[arp_ip_count]);
+			arp_target[arp_ip_count] = ip;
+		}
+	}
+
+	if (arp_interval && !arp_ip_count) {
+		/* don't allow arping if no arp_ip_target given... */
+		printk(KERN_WARNING DRV_NAME
+		       ": Warning: arp_interval module parameter (%d) "
+		       "specified without providing an arp_ip_target "
+		       "parameter, arp_interval was reset to 0\n",
+		       arp_interval);
+		arp_interval = 0;
+	}
+
+	if (miimon) {
+		printk(KERN_INFO DRV_NAME
+		       ": MII link monitoring set to %d ms\n",
+		       miimon);
+	} else if (arp_interval) {
+		int i;
+
+		printk(KERN_INFO DRV_NAME
+		       ": ARP monitoring set to %d ms with %d target(s):",
+		       arp_interval, arp_ip_count);
+
+		for (i = 0; i < arp_ip_count; i++)
+			printk (" %s", arp_ip_target[i]);
+
+		printk("\n");
+
+	} else {
+		/* miimon and arp_interval not set, we need one so things
+		 * work as expected, see bonding.txt for details
+		 */
+		printk(KERN_WARNING DRV_NAME
+		       ": Warning: either miimon or arp_interval and "
+		       "arp_ip_target module parameters must be specified, "
+		       "otherwise bonding will not detect link failures! see "
+		       "bonding.txt for details.\n");
+	}
+
+	if (primary && !USES_PRIMARY(bond_mode)) {
+		/* currently, using a primary only makes sense
+		 * in active backup, TLB or ALB modes
+		 */
+		printk(KERN_WARNING DRV_NAME
+		       ": Warning: %s primary device specified but has no "
+		       "effect in %s mode\n",
+		       primary, bond_mode_name(bond_mode));
+		primary = NULL;
+	}
+
+	/* fill params struct with the proper values */
+	params->mode = bond_mode;
+	params->miimon = miimon;
+	params->arp_interval = arp_interval;
+	params->updelay = updelay;
+	params->downdelay = downdelay;
+	params->use_carrier = use_carrier;
+	params->lacp_fast = lacp_fast;
+	params->primary[0] = 0;
+
+	if (primary) {
+		strncpy(params->primary, primary, IFNAMSIZ);
+		params->primary[IFNAMSIZ - 1] = 0;
+	}
+
+	memcpy(params->arp_targets, arp_target, sizeof(arp_target));
+
+	return 0;
+}
+
+static int __init bonding_init(void)
+{
+	struct bond_params params;
+	int i;
+	int res;
+
+	printk(KERN_INFO "%s", version);
+
+	res = bond_check_params(&params);
+	if (res) {
+		return res;
+	}
+
+	rtnl_lock();
+
+#ifdef CONFIG_PROC_FS
+	bond_create_proc_dir();
+#endif
+
+	for (i = 0; i < max_bonds; i++) {
+		struct net_device *bond_dev;
+
+		bond_dev = alloc_netdev(sizeof(struct bonding), "", ether_setup);
+		if (!bond_dev) {
+			res = -ENOMEM;
+			goto out_err;
+		}
+
+		res = dev_alloc_name(bond_dev, "bond%d");
+		if (res < 0) {
+			free_netdev(bond_dev);
+			goto out_err;
+		}
+
+		/* bond_init() must be called after dev_alloc_name() (for the
+		 * /proc files), but before register_netdevice(), because we
+		 * need to set function pointers.
+		 */
+		res = bond_init(bond_dev, &params);
+		if (res < 0) {
+			free_netdev(bond_dev);
+			goto out_err;
+		}
+
+		SET_MODULE_OWNER(bond_dev);
+
+		res = register_netdevice(bond_dev);
+		if (res < 0) {
+			bond_deinit(bond_dev);
+			free_netdev(bond_dev);
+			goto out_err;
+		}
+	}
+
+	rtnl_unlock();
+	register_netdevice_notifier(&bond_netdev_notifier);
+
+	return 0;
+
+out_err:
+	/* free and unregister all bonds that were successfully added */
+	bond_free_all();
+
+	rtnl_unlock();
+
+	return res;
+}
+
+static void __exit bonding_exit(void)
+{
+	unregister_netdevice_notifier(&bond_netdev_notifier);
+
+	rtnl_lock();
+	bond_free_all();
+	rtnl_unlock();
+}
+
+module_init(bonding_init);
+module_exit(bonding_exit);
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION(DRV_DESCRIPTION ", v" DRV_VERSION);
+MODULE_AUTHOR("Thomas Davis, tadavis@lbl.gov and many others");
+MODULE_SUPPORTED_DEVICE("most ethernet devices");
+
+/*
+ * Local variables:
+ *  c-indent-level: 8
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ * End:
+ */
+
diff -urNp linux-8120/drivers/net/bonding/bonding.h linux-8121/drivers/net/bonding/bonding.h
--- linux-8120/drivers/net/bonding/bonding.h
+++ linux-8121/drivers/net/bonding/bonding.h
@@ -0,0 +1,252 @@
+/*
+ * Bond several ethernet interfaces into a Cisco, running 'Etherchannel'.
+ *
+ * Portions are (c) Copyright 1995 Simon "Guru Aleph-Null" Janes
+ * NCM: Network and Communications Management, Inc.
+ *
+ * BUT, I'm the one who modified it for ethernet, so:
+ * (c) Copyright 1999, Thomas Davis, tadavis@lbl.gov
+ *
+ *	This software may be used and distributed according to the terms
+ *	of the GNU Public License, incorporated herein by reference.
+ *
+ *
+ * 2003/03/18 - Amir Noam <amir.noam at intel dot com>,
+ *		Tsippy Mendelson <tsippy.mendelson at intel dot com> and
+ *		Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Added support for IEEE 802.3ad Dynamic link aggregation mode.
+ *
+ * 2003/05/01 - Tsippy Mendelson <tsippy.mendelson at intel dot com> and
+ *		Amir Noam <amir.noam at intel dot com>
+ *	- Code beautification and style changes (mainly in comments).
+ *
+ * 2003/05/01 - Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Added support for Transmit load balancing mode.
+ *
+ * 2003/12/01 - Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Code cleanup and style changes
+ */
+
+#ifndef _LINUX_BONDING_H
+#define _LINUX_BONDING_H
+
+#include <linux/timer.h>
+#include <linux/proc_fs.h>
+#include <linux/if_bonding.h>
+#include "bond_3ad.h"
+#include "bond_alb.h"
+
+#define DRV_VERSION	"2.6.0"
+#define DRV_RELDATE	"January 14, 2004"
+#define DRV_NAME	"bonding"
+#define DRV_DESCRIPTION	"Ethernet Channel Bonding Driver"
+
+#define BOND_MAX_ARP_TARGETS	16
+
+#ifdef BONDING_DEBUG
+#define dprintk(fmt, args...) \
+	printk(KERN_DEBUG     \
+	       DRV_NAME ": %s() %d: " fmt, __FUNCTION__, __LINE__ , ## args )
+#else
+#define dprintk(fmt, args...)
+#endif /* BONDING_DEBUG */
+
+#define IS_UP(dev)					   \
+	      ((((dev)->flags & IFF_UP) == IFF_UP)	&& \
+	       netif_running(dev)			&& \
+	       netif_carrier_ok(dev))
+
+/*
+ * Checks whether bond is ready for transmit.
+ *
+ * Caller must hold bond->lock
+ */
+#define BOND_IS_OK(bond)			     \
+		   (((bond)->dev->flags & IFF_UP) && \
+		    netif_running((bond)->dev)	  && \
+		    ((bond)->slave_cnt > 0))
+
+/*
+ * Checks whether slave is ready for transmit.
+ */
+#define SLAVE_IS_OK(slave)			        \
+		    (((slave)->dev->flags & IFF_UP)  && \
+		     netif_running((slave)->dev)     && \
+		     ((slave)->link == BOND_LINK_UP) && \
+		     ((slave)->state == BOND_STATE_ACTIVE))
+
+
+#define USES_PRIMARY(mode)				\
+		(((mode) == BOND_MODE_ACTIVEBACKUP) ||	\
+		 ((mode) == BOND_MODE_TLB)          ||	\
+		 ((mode) == BOND_MODE_ALB))
+
+/*
+ * Less bad way to call ioctl from within the kernel; this needs to be
+ * done some other way to get the call out of interrupt context.
+ * Needs "ioctl" variable to be supplied by calling context.
+ */
+#define IOCTL(dev, arg, cmd) ({		\
+	int res = 0;			\
+	mm_segment_t fs = get_fs();	\
+	set_fs(get_ds());		\
+	res = ioctl(dev, arg, cmd);	\
+	set_fs(fs);			\
+	res; })
+
+/**
+ * bond_for_each_slave_from - iterate the slaves list from a starting point
+ * @bond:	the bond holding this list.
+ * @pos:	current slave.
+ * @cnt:	counter for max number of moves
+ * @start:	starting point.
+ *
+ * Caller must hold bond->lock
+ */
+#define bond_for_each_slave_from(bond, pos, cnt, start)	\
+	for (cnt = 0, pos = start;				\
+	     cnt < (bond)->slave_cnt;				\
+             cnt++, pos = (pos)->next)
+
+/**
+ * bond_for_each_slave_from_to - iterate the slaves list from start point to stop point
+ * @bond:	the bond holding this list.
+ * @pos:	current slave.
+ * @cnt:	counter for number max of moves
+ * @start:	start point.
+ * @stop:	stop point.
+ *
+ * Caller must hold bond->lock
+ */
+#define bond_for_each_slave_from_to(bond, pos, cnt, start, stop)	\
+	for (cnt = 0, pos = start;					\
+	     ((cnt < (bond)->slave_cnt) && (pos != (stop)->next));	\
+             cnt++, pos = (pos)->next)
+
+/**
+ * bond_for_each_slave - iterate the slaves list from head
+ * @bond:	the bond holding this list.
+ * @pos:	current slave.
+ * @cnt:	counter for max number of moves
+ *
+ * Caller must hold bond->lock
+ */
+#define bond_for_each_slave(bond, pos, cnt)	\
+		bond_for_each_slave_from(bond, pos, cnt, (bond)->first_slave)
+
+
+struct bond_params {
+	int mode;
+	int miimon;
+	int arp_interval;
+	int use_carrier;
+	int updelay;
+	int downdelay;
+	int lacp_fast;
+	char primary[IFNAMSIZ];
+	u32 arp_targets[BOND_MAX_ARP_TARGETS];
+};
+
+struct vlan_entry {
+	struct list_head vlan_list;
+	unsigned short vlan_id;
+};
+
+struct slave {
+	struct net_device *dev; /* first - usefull for panic debug */
+	struct slave *next;
+	struct slave *prev;
+	s16    delay;
+	u32    jiffies;
+	s8     link;    /* one of BOND_LINK_XXXX */
+	s8     state;   /* one of BOND_STATE_XXXX */
+	u32    original_flags;
+	u32    link_failure_count;
+	u16    speed;
+	u8     duplex;
+	u8     perm_hwaddr[ETH_ALEN];
+	struct ad_slave_info ad_info; /* HUGE - better to dynamically alloc */
+	struct tlb_slave_info tlb_info;
+};
+
+/*
+ * Here are the locking policies for the two bonding locks:
+ *
+ * 1) Get bond->lock when reading/writing slave list.
+ * 2) Get bond->curr_slave_lock when reading/writing bond->curr_active_slave.
+ *    (It is unnecessary when the write-lock is put with bond->lock.)
+ * 3) When we lock with bond->curr_slave_lock, we must lock with bond->lock
+ *    beforehand.
+ */
+struct bonding {
+	struct   net_device *dev; /* first - usefull for panic debug */
+	struct   slave *first_slave;
+	struct   slave *curr_active_slave;
+	struct   slave *current_arp_slave;
+	struct   slave *primary_slave;
+	s32      slave_cnt; /* never change this value outside the attach/detach wrappers */
+	rwlock_t lock;
+	rwlock_t curr_slave_lock;
+	struct   timer_list mii_timer;
+	struct   timer_list arp_timer;
+	s8       kill_timers;
+	struct   net_device_stats stats;
+#ifdef CONFIG_PROC_FS
+	struct   proc_dir_entry *proc_entry;
+	char     proc_file_name[IFNAMSIZ];
+#endif /* CONFIG_PROC_FS */
+	struct   list_head bond_list;
+	struct   dev_mc_list *mc_list;
+	u16      flags;
+	struct   ad_bond_info ad_info;
+	struct   alb_bond_info alb_info;
+	struct   bond_params params;
+	struct   list_head vlan_list;
+	struct   vlan_group *vlgrp;
+};
+
+/**
+ * Returns NULL if the net_device does not belong to any of the bond's slaves
+ *
+ * Caller must hold bond lock for read
+ */
+extern inline struct slave *bond_get_slave_by_dev(struct bonding *bond, struct net_device *slave_dev)
+{
+	struct slave *slave = NULL;
+	int i;
+
+	bond_for_each_slave(bond, slave, i) {
+		if (slave->dev == slave_dev) {
+			break;
+		}
+	}
+
+	return slave;
+}
+
+extern inline struct bonding *bond_get_bond_by_slave(struct slave *slave)
+{
+	if (!slave || !slave->dev->master) {
+		return NULL;
+	}
+
+	return (struct bonding *)slave->dev->master->priv;
+}
+
+extern inline void bond_set_slave_inactive_flags(struct slave *slave)
+{
+	slave->state = BOND_STATE_BACKUP;
+	slave->dev->flags |= IFF_NOARP;
+}
+
+extern inline void bond_set_slave_active_flags(struct slave *slave)
+{
+	slave->state = BOND_STATE_ACTIVE;
+	slave->dev->flags &= ~IFF_NOARP;
+}
+
+struct vlan_entry *bond_next_vlan(struct bonding *bond, struct vlan_entry *curr);
+int bond_dev_queue_xmit(struct bonding *bond, struct sk_buff *skb, struct net_device *slave_dev);
+
+#endif /* _LINUX_BONDING_H */
+
diff -urNp linux-8120/drivers/net/bonding.c linux-8121/drivers/net/bonding.c
--- linux-8120/drivers/net/bonding.c
+++ linux-8121/drivers/net/bonding.c
@@ -1,3302 +0,0 @@
-/*
- * originally based on the dummy device.
- *
- * Copyright 1999, Thomas Davis, tadavis@lbl.gov.  
- * Licensed under the GPL. Based on dummy.c, and eql.c devices.
- *
- * bonding.c: an Ethernet Bonding driver
- *
- * This is useful to talk to a Cisco EtherChannel compatible equipment:
- *	Cisco 5500
- *	Sun Trunking (Solaris)
- *	Alteon AceDirector Trunks
- *	Linux Bonding
- *	and probably many L2 switches ...
- *
- * How it works:
- *    ifconfig bond0 ipaddress netmask up
- *      will setup a network device, with an ip address.  No mac address 
- *	will be assigned at this time.  The hw mac address will come from 
- *	the first slave bonded to the channel.  All slaves will then use 
- *	this hw mac address.
- *
- *    ifconfig bond0 down
- *         will release all slaves, marking them as down.
- *
- *    ifenslave bond0 eth0
- *	will attach eth0 to bond0 as a slave.  eth0 hw mac address will either
- *	a: be used as initial mac address
- *	b: if a hw mac address already is there, eth0's hw mac address 
- *	   will then be set from bond0.
- *
- * v0.1 - first working version.
- * v0.2 - changed stats to be calculated by summing slaves stats.
- *
- * Changes:
- * Arnaldo Carvalho de Melo <acme@conectiva.com.br>
- * - fix leaks on failure at bond_init
- *
- * 2000/09/30 - Willy Tarreau <willy at meta-x.org>
- *     - added trivial code to release a slave device.
- *     - fixed security bug (CAP_NET_ADMIN not checked)
- *     - implemented MII link monitoring to disable dead links :
- *       All MII capable slaves are checked every <miimon> milliseconds
- *       (100 ms seems good). This value can be changed by passing it to
- *       insmod. A value of zero disables the monitoring (default).
- *     - fixed an infinite loop in bond_xmit_roundrobin() when there's no
- *       good slave.
- *     - made the code hopefully SMP safe
- *
- * 2000/10/03 - Willy Tarreau <willy at meta-x.org>
- *     - optimized slave lists based on relevant suggestions from Thomas Davis
- *     - implemented active-backup method to obtain HA with two switches:
- *       stay as long as possible on the same active interface, while we
- *       also monitor the backup one (MII link status) because we want to know
- *       if we are able to switch at any time. ( pass "mode=1" to insmod )
- *     - lots of stress testings because we need it to be more robust than the
- *       wires ! :->
- *
- * 2000/10/09 - Willy Tarreau <willy at meta-x.org>
- *     - added up and down delays after link state change.
- *     - optimized the slaves chaining so that when we run forward, we never
- *       repass through the bond itself, but we can find it by searching
- *       backwards. Renders the deletion more difficult, but accelerates the
- *       scan.
- *     - smarter enslaving and releasing.
- *     - finer and more robust SMP locking
- *
- * 2000/10/17 - Willy Tarreau <willy at meta-x.org>
- *     - fixed two potential SMP race conditions
- *
- * 2000/10/18 - Willy Tarreau <willy at meta-x.org>
- *     - small fixes to the monitoring FSM in case of zero delays
- * 2000/11/01 - Willy Tarreau <willy at meta-x.org>
- *     - fixed first slave not automatically used in trunk mode.
- * 2000/11/10 : spelling of "EtherChannel" corrected.
- * 2000/11/13 : fixed a race condition in case of concurrent accesses to ioctl().
- * 2000/12/16 : fixed improper usage of rtnl_exlock_nowait().
- *
- * 2001/1/3 - Chad N. Tindel <ctindel at ieee dot org>
- *     - The bonding driver now simulates MII status monitoring, just like
- *       a normal network device.  It will show that the link is down iff
- *       every slave in the bond shows that their links are down.  If at least
- *       one slave is up, the bond's MII status will appear as up.
- *
- * 2001/2/7 - Chad N. Tindel <ctindel at ieee dot org>
- *     - Applications can now query the bond from user space to get
- *       information which may be useful.  They do this by calling
- *       the BOND_INFO_QUERY ioctl.  Once the app knows how many slaves
- *       are in the bond, it can call the BOND_SLAVE_INFO_QUERY ioctl to
- *       get slave specific information (# link failures, etc).  See
- *       <linux/if_bonding.h> for more details.  The structs of interest
- *       are ifbond and ifslave.
- *
- * 2001/4/5 - Chad N. Tindel <ctindel at ieee dot org>
- *     - Ported to 2.4 Kernel
- * 
- * 2001/5/2 - Jeffrey E. Mast <jeff at mastfamily dot com>
- *     - When a device is detached from a bond, the slave device is no longer
- *       left thinking that is has a master.
- *
- * 2001/5/16 - Jeffrey E. Mast <jeff at mastfamily dot com>
- *     - memset did not appropriately initialized the bond rw_locks. Used 
- *       rwlock_init to initialize to unlocked state to prevent deadlock when 
- *       first attempting a lock
- *     - Called SET_MODULE_OWNER for bond device
- *
- * 2001/5/17 - Tim Anderson <tsa at mvista.com>
- *     - 2 paths for releasing for slave release; 1 through ioctl
- *       and 2) through close. Both paths need to release the same way.
- *     - the free slave in bond release is changing slave status before
- *       the free. The netdev_set_master() is intended to change slave state
- *       so it should not be done as part of the release process.
- *     - Simple rule for slave state at release: only the active in A/B and
- *       only one in the trunked case.
- *
- * 2001/6/01 - Tim Anderson <tsa at mvista.com>
- *     - Now call dev_close when releasing a slave so it doesn't screw up
- *       out routing table.
- *
- * 2001/6/01 - Chad N. Tindel <ctindel at ieee dot org>
- *     - Added /proc support for getting bond and slave information.
- *       Information is in /proc/net/<bond device>/info. 
- *     - Changed the locking when calling bond_close to prevent deadlock.
- *
- * 2001/8/05 - Janice Girouard <girouard at us.ibm.com>
- *     - correct problem where refcnt of slave is not incremented in bond_ioctl
- *       so the system hangs when halting.
- *     - correct locking problem when unable to malloc in bond_enslave.
- *     - adding bond_xmit_xor logic.
- *     - adding multiple bond device support.
- *
- * 2001/8/13 - Erik Habbinga <erik_habbinga at hp dot com>
- *     - correct locking problem with rtnl_exlock_nowait
- *
- * 2001/8/23 - Janice Girouard <girouard at us.ibm.com>
- *     - bzero initial dev_bonds, to correct oops
- *     - convert SIOCDEVPRIVATE to new MII ioctl calls
- *
- * 2001/9/13 - Takao Indoh <indou dot takao at jp dot fujitsu dot com>
- *     - Add the BOND_CHANGE_ACTIVE ioctl implementation
- *
- * 2001/9/14 - Mark Huth <mhuth at mvista dot com>
- *     - Change MII_LINK_READY to not check for end of auto-negotiation,
- *       but only for an up link.
- *
- * 2001/9/20 - Chad N. Tindel <ctindel at ieee dot org>
- *     - Add the device field to bonding_t.  Previously the net_device 
- *       corresponding to a bond wasn't available from the bonding_t 
- *       structure.
- *
- * 2001/9/25 - Janice Girouard <girouard at us.ibm.com>
- *     - add arp_monitor for active backup mode
- *
- * 2001/10/23 - Takao Indoh <indou dot takao at jp dot fujitsu dot com>
- *     - Various memory leak fixes
- *
- * 2001/11/5 - Mark Huth <mark dot huth at mvista dot com>
- *     - Don't take rtnl lock in bond_mii_monitor as it deadlocks under 
- *       certain hotswap conditions.  
- *       Note:  this same change may be required in bond_arp_monitor ???
- *     - Remove possibility of calling bond_sethwaddr with NULL slave_dev ptr 
- *     - Handle hot swap ethernet interface deregistration events to remove
- *       kernel oops following hot swap of enslaved interface
- *
- * 2002/1/2 - Chad N. Tindel <ctindel at ieee dot org>
- *     - Restore original slave flags at release time.
- *
- * 2002/02/18 - Erik Habbinga <erik_habbinga at hp dot com>
- *     - bond_release(): calling kfree on our_slave after call to
- *       bond_restore_slave_flags, not before
- *     - bond_enslave(): saving slave flags into original_flags before
- *       call to netdev_set_master, so the IFF_SLAVE flag doesn't end
- *       up in original_flags
- *
- * 2002/04/05 - Mark Smith <mark.smith at comdev dot cc> and
- *              Steve Mead <steve.mead at comdev dot cc>
- *     - Port Gleb Natapov's multicast support patchs from 2.4.12
- *       to 2.4.18 adding support for multicast.
- *
- * 2002/06/10 - Tony Cureington <tony.cureington * hp_com>
- *     - corrected uninitialized pointer (ifr.ifr_data) in bond_check_dev_link;
- *       actually changed function to use MIIPHY, then MIIREG, and finally
- *       ETHTOOL to determine the link status
- *     - fixed bad ifr_data pointer assignments in bond_ioctl
- *     - corrected mode 1 being reported as active-backup in bond_get_info;
- *       also added text to distinguish type of load balancing (rr or xor)
- *     - change arp_ip_target module param from "1-12s" (array of 12 ptrs)
- *       to "s" (a single ptr)
- *
- * 2002/08/30 - Jay Vosburgh <fubar at us dot ibm dot com>
- *     - Removed acquisition of xmit_lock in set_multicast_list; caused
- *       deadlock on SMP (lock is held by caller).
- *     - Revamped SIOCGMIIPHY, SIOCGMIIREG portion of bond_check_dev_link().
- *
- * 2002/09/18 - Jay Vosburgh <fubar at us dot ibm dot com>
- *     - Fixed up bond_check_dev_link() (and callers): removed some magic
- *	 numbers, banished local MII_ defines, wrapped ioctl calls to
- *	 prevent EFAULT errors
- *
- * 2002/9/30 - Jay Vosburgh <fubar at us dot ibm dot com>
- *     - make sure the ip target matches the arp_target before saving the
- *	 hw address.
- *
- * 2002/9/30 - Dan Eisner <eisner at 2robots dot com>
- *     - make sure my_ip is set before taking down the link, since
- *	 not all switches respond if the source ip is not set.
- *
- * 2002/10/8 - Janice Girouard <girouard at us dot ibm dot com>
- *     - read in the local ip address when enslaving a device
- *     - add primary support
- *     - make sure 2*arp_interval has passed when a new device
- *       is brought on-line before taking it down.
- *
- * 2002/09/11 - Philippe De Muyter <phdm at macqel dot be>
- *     - Added bond_xmit_broadcast logic.
- *     - Added bond_mode() support function.
- *
- * 2002/10/26 - Laurent Deniel <laurent.deniel at free.fr>
- *     - allow to register multicast addresses only on active slave
- *       (useful in active-backup mode)
- *     - add multicast module parameter
- *     - fix deletion of multicast groups after unloading module
- *
- * 2002/11/06 - Kameshwara Rayaprolu <kameshwara.rao * wipro_com>
- *     - Changes to prevent panic from closing the device twice; if we close 
- *       the device in bond_release, we must set the original_flags to down 
- *       so it won't be closed again by the network layer.
- *
- * 2002/11/07 - Tony Cureington <tony.cureington * hp_com>
- *     - Fix arp_target_hw_addr memory leak
- *     - Created activebackup_arp_monitor function to handle arp monitoring 
- *       in active backup mode - the bond_arp_monitor had several problems... 
- *       such as allowing slaves to tx arps sequentially without any delay 
- *       for a response
- *     - Renamed bond_arp_monitor to loadbalance_arp_monitor and re-wrote
- *       this function to just handle arp monitoring in load-balancing mode;
- *       it is a lot more compact now
- *     - Changes to ensure one and only one slave transmits in active-backup 
- *       mode
- *     - Robustesize parameters; warn users about bad combinations of 
- *       parameters; also if miimon is specified and a network driver does 
- *       not support MII or ETHTOOL, inform the user of this
- *     - Changes to support link_failure_count when in arp monitoring mode
- *     - Fix up/down delay reported in /proc
- *     - Added version; log version; make version available from "modinfo -d"
- *     - Fixed problem in bond_check_dev_link - if the first IOCTL (SIOCGMIIPH)
- *	 failed, the ETHTOOL ioctl never got a chance
- *
- * 2002/11/16 - Laurent Deniel <laurent.deniel at free.fr>
- *     - fix multicast handling in activebackup_arp_monitor
- *     - remove one unnecessary and confusing current_slave == slave test 
- *	 in activebackup_arp_monitor
- *
- *  2002/11/17 - Laurent Deniel <laurent.deniel at free.fr>
- *     - fix bond_slave_info_query when slave_id = num_slaves
- *
- *  2002/11/19 - Janice Girouard <girouard at us dot ibm dot com>
- *     - correct ifr_data reference.  Update ifr_data reference
- *       to mii_ioctl_data struct values to avoid confusion.
- *
- *  2002/11/22 - Bert Barbe <bert.barbe at oracle dot com>
- *      - Add support for multiple arp_ip_target
- *
- *  2002/12/13 - Jay Vosburgh <fubar at us dot ibm dot com>
- *	- Changed to allow text strings for mode and multicast, e.g.,
- *	  insmod bonding mode=active-backup.  The numbers still work.
- *	  One change: an invalid choice will cause module load failure,
- *	  rather than the previous behavior of just picking one.
- *	- Minor cleanups; got rid of dup ctype stuff, atoi function
- * 
- * 2003/02/07 - Jay Vosburgh <fubar at us dot ibm dot com>
- *	- Added use_carrier module parameter that causes miimon to
- *	  use netif_carrier_ok() test instead of MII/ETHTOOL ioctls.
- *	- Minor cleanups; consolidated ioctl calls to one function.
- *
- * 2003/02/07 - Tony Cureington <tony.cureington * hp_com>
- *	- Fix bond_mii_monitor() logic error that could result in
- *	  bonding round-robin mode ignoring links after failover/recovery
- *
- * 2003/03/17 - Jay Vosburgh <fubar at us dot ibm dot com>
- *	- kmalloc fix (GPF_KERNEL to GPF_ATOMIC) reported by
- *	  Shmulik dot Hen at intel.com.
- *	- Based on discussion on mailing list, changed use of
- *	  update_slave_cnt(), created wrapper functions for adding/removing
- *	  slaves, changed bond_xmit_xor() to check slave_cnt instead of
- *	  checking slave and slave->dev (which only worked by accident).
- *	- Misc code cleanup: get arp_send() prototype from header file,
- *	  add max_bonds to bonding.txt.
- *
- * 2003/03/18 - Tsippy Mendelson <tsippy.mendelson at intel dot com> and
- *		Shmulik Hen <shmulik.hen at intel dot com>
- *	- Make sure only bond_attach_slave() and bond_detach_slave() can
- *	  manipulate the slave list, including slave_cnt, even when in
- *	  bond_release_all().
- *	- Fixed hang in bond_release() while traffic is running.
- *	  netdev_set_master() must not be called from within the bond lock.
- *
- * 2003/03/18 - Tsippy Mendelson <tsippy.mendelson at intel dot com> and
- *		Shmulik Hen <shmulik.hen at intel dot com>
- *	- Fixed hang in bond_enslave(): netdev_set_master() must not be
- *	  called from within the bond lock while traffic is running.
- */
-
-#include <linux/config.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/sched.h>
-#include <linux/types.h>
-#include <linux/fcntl.h>
-#include <linux/interrupt.h>
-#include <linux/ptrace.h>
-#include <linux/ioport.h>
-#include <linux/in.h>
-#include <linux/ip.h>
-#include <linux/slab.h>
-#include <linux/string.h>
-#include <linux/init.h>
-#include <linux/timer.h>
-#include <linux/socket.h>
-#include <linux/ctype.h>
-#include <asm/system.h>
-#include <asm/bitops.h>
-#include <asm/io.h>
-#include <asm/dma.h>
-#include <asm/uaccess.h>
-#include <linux/errno.h>
-
-#include <linux/netdevice.h>
-#include <linux/inetdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <net/sock.h>
-#include <linux/rtnetlink.h>
-
-#include <linux/if_bonding.h>
-#include <linux/smp.h>
-#include <linux/if_ether.h>
-#include <net/arp.h>
-#include <linux/mii.h>
-#include <linux/ethtool.h>
-
-#define DRV_VERSION		"2.4.20-20030320"
-#define DRV_RELDATE		"March 20, 2003"
-#define DRV_NAME		"bonding"
-#define DRV_DESCRIPTION		"Ethernet Channel Bonding Driver"
-
-static const char *version =
-DRV_NAME ".c:v" DRV_VERSION " (" DRV_RELDATE ")\n";
-
-/* monitor all links that often (in milliseconds). <=0 disables monitoring */
-#ifndef BOND_LINK_MON_INTERV
-#define BOND_LINK_MON_INTERV	0
-#endif
-
-#ifndef BOND_LINK_ARP_INTERV
-#define BOND_LINK_ARP_INTERV	0
-#endif
-
-#ifndef MAX_ARP_IP_TARGETS
-#define MAX_ARP_IP_TARGETS 16
-#endif
-
-static int arp_interval = BOND_LINK_ARP_INTERV;
-static char *arp_ip_target[MAX_ARP_IP_TARGETS] = { NULL, };
-static unsigned long arp_target[MAX_ARP_IP_TARGETS] = { 0, } ;
-static int arp_ip_count = 0;
-static u32 my_ip = 0;
-char *arp_target_hw_addr = NULL;
-
-static char *primary= NULL;
-
-static int max_bonds	= BOND_DEFAULT_MAX_BONDS;
-static int miimon	= BOND_LINK_MON_INTERV;
-static int use_carrier	= 1;
-static int bond_mode	= BOND_MODE_ROUNDROBIN;
-static int updelay	= 0;
-static int downdelay	= 0;
-
-static char *mode	= NULL;
-
-static struct bond_parm_tbl bond_mode_tbl[] = {
-{	"balance-rr",		BOND_MODE_ROUNDROBIN},
-{	"active-backup",	BOND_MODE_ACTIVEBACKUP},
-{	"balance-xor",		BOND_MODE_XOR},
-{	"broadcast",		BOND_MODE_BROADCAST},
-{	NULL,			-1},
-};
-
-static int multicast_mode	= BOND_MULTICAST_ALL;
-static char *multicast		= NULL;
-
-static struct bond_parm_tbl bond_mc_tbl[] = {
-{	"disabled",		BOND_MULTICAST_DISABLED},
-{	"active",		BOND_MULTICAST_ACTIVE},
-{	"all",			BOND_MULTICAST_ALL},
-{	NULL,			-1},
-};
-
-static int first_pass	= 1;
-static struct bonding *these_bonds =  NULL;
-static struct net_device *dev_bonds = NULL;
-
-MODULE_PARM(max_bonds, "i");
-MODULE_PARM_DESC(max_bonds, "Max number of bonded devices");
-MODULE_PARM(miimon, "i");
-MODULE_PARM_DESC(miimon, "Link check interval in milliseconds");
-MODULE_PARM(use_carrier, "i");
-MODULE_PARM_DESC(use_carrier, "Use netif_carrier_ok (vs MII ioctls) in miimon; 09 for off, 1 for on (default)");
-MODULE_PARM(mode, "s");
-MODULE_PARM_DESC(mode, "Mode of operation : 0 for round robin, 1 for active-backup, 2 for xor");
-MODULE_PARM(arp_interval, "i");
-MODULE_PARM_DESC(arp_interval, "arp interval in milliseconds");
-MODULE_PARM(arp_ip_target, "1-" __MODULE_STRING(MAX_ARP_IP_TARGETS) "s");
-MODULE_PARM_DESC(arp_ip_target, "arp targets in n.n.n.n form");
-MODULE_PARM(updelay, "i");
-MODULE_PARM_DESC(updelay, "Delay before considering link up, in milliseconds");
-MODULE_PARM(downdelay, "i");
-MODULE_PARM_DESC(downdelay, "Delay before considering link down, in milliseconds");
-MODULE_PARM(primary, "s");
-MODULE_PARM_DESC(primary, "Primary network device to use");
-MODULE_PARM(multicast, "s");
-MODULE_PARM_DESC(multicast, "Mode for multicast support : 0 for none, 1 for active slave, 2 for all slaves (default)");
-
-static int bond_xmit_roundrobin(struct sk_buff *skb, struct net_device *dev);
-static int bond_xmit_xor(struct sk_buff *skb, struct net_device *dev);
-static int bond_xmit_activebackup(struct sk_buff *skb, struct net_device *dev);
-static struct net_device_stats *bond_get_stats(struct net_device *dev);
-static void bond_mii_monitor(struct net_device *dev);
-static void loadbalance_arp_monitor(struct net_device *dev);
-static void activebackup_arp_monitor(struct net_device *dev);
-static int bond_event(struct notifier_block *this, unsigned long event, void *ptr);
-static void bond_restore_slave_flags(slave_t *slave);
-static void bond_mc_list_destroy(struct bonding *bond);
-static void bond_mc_add(bonding_t *bond, void *addr, int alen);
-static void bond_mc_delete(bonding_t *bond, void *addr, int alen);
-static int bond_mc_list_copy (struct dev_mc_list *src, struct bonding *dst, int gpf_flag);
-static inline int dmi_same(struct dev_mc_list *dmi1, struct dev_mc_list *dmi2);
-static void bond_set_promiscuity(bonding_t *bond, int inc);
-static void bond_set_allmulti(bonding_t *bond, int inc);
-static struct dev_mc_list* bond_mc_list_find_dmi(struct dev_mc_list *dmi, struct dev_mc_list *mc_list);
-static void bond_mc_update(bonding_t *bond, slave_t *new, slave_t *old);
-static void bond_set_slave_inactive_flags(slave_t *slave);
-static void bond_set_slave_active_flags(slave_t *slave);
-static int bond_enslave(struct net_device *master, struct net_device *slave);
-static int bond_release(struct net_device *master, struct net_device *slave);
-static int bond_release_all(struct net_device *master);
-static int bond_sethwaddr(struct net_device *master, struct net_device *slave);
-
-/*
- * bond_get_info is the interface into the /proc filesystem.  This is
- * a different interface than the BOND_INFO_QUERY ioctl.  That is done
- * through the generic networking ioctl interface, and bond_info_query
- * is the internal function which provides that information.
- */
-static int bond_get_info(char *buf, char **start, off_t offset, int length);
-
-/* #define BONDING_DEBUG 1 */
-
-/* several macros */
-
-#define IS_UP(dev)	((((dev)->flags & (IFF_UP)) == (IFF_UP)) && \
-			(netif_running(dev) && netif_carrier_ok(dev)))
-  
-static void arp_send_all(slave_t *slave)
-{	
-	int i; 
-
-	for (i = 0; (i<MAX_ARP_IP_TARGETS) && arp_target[i]; i++) { 
-		arp_send(ARPOP_REQUEST, ETH_P_ARP, arp_target[i], slave->dev, 
-			 my_ip, arp_target_hw_addr, slave->dev->dev_addr,
-			 arp_target_hw_addr); 
-	} 
-}
- 
-
-static const char *
-bond_mode_name(void)
-{
-	switch (bond_mode) {
-	case BOND_MODE_ROUNDROBIN :
-		return "load balancing (round-robin)";
-	case BOND_MODE_ACTIVEBACKUP :
-		return "fault-tolerance (active-backup)";
-	case BOND_MODE_XOR :
-		return "load balancing (xor)";
-	case BOND_MODE_BROADCAST :
-		return "fault-tolerance (broadcast)";
-	default :
-		return "unknown";
-	}
-}
-
-static const char *
-multicast_mode_name(void)
-{
-	switch(multicast_mode) {
-	case BOND_MULTICAST_DISABLED :
-		return "disabled";
-	case BOND_MULTICAST_ACTIVE :
-		return "active slave only";
-	case BOND_MULTICAST_ALL :
-		return "all slaves";
-	default :
-		return "unknown";
-	}
-}
-
-static void bond_restore_slave_flags(slave_t *slave)
-{
-	slave->dev->flags = slave->original_flags;
-}
-
-static void bond_set_slave_inactive_flags(slave_t *slave)
-{
-	slave->state = BOND_STATE_BACKUP;
-	slave->dev->flags |= IFF_NOARP;
-}
-
-static void bond_set_slave_active_flags(slave_t *slave)
-{
-	slave->state = BOND_STATE_ACTIVE;
-	slave->dev->flags &= ~IFF_NOARP;
-}
-
-/*
- * This function counts and verifies the the number of attached
- * slaves, checking the count against the expected value (given that incr
- * is either 1 or -1, for add or removal of a slave).  Only
- * bond_xmit_xor() uses the slave_cnt value, but this is still a good
- * consistency check.
- */
-static inline void
-update_slave_cnt(bonding_t *bond, int incr)
-{
-	slave_t *slave = NULL;
-	int expect = bond->slave_cnt + incr;
-
-	bond->slave_cnt = 0;
-	for (slave = bond->prev; slave != (slave_t*)bond;
-	     slave = slave->prev) {
-		bond->slave_cnt++;
-	}
-
-	if (expect != bond->slave_cnt)
-		BUG();
-}
-
-/* 
- * This function detaches the slave <slave> from the list <bond>.
- * WARNING: no check is made to verify if the slave effectively
- * belongs to <bond>. It returns <slave> in case it's needed.
- * Nothing is freed on return, structures are just unchained.
- * If the bond->current_slave pointer was pointing to <slave>,
- * it's replaced with slave->next, or <bond> if not applicable.
- *
- * bond->lock held by caller.
- */
-static slave_t *
-bond_detach_slave(bonding_t *bond, slave_t *slave)
-{
-	if ((bond == NULL) || (slave == NULL) ||
-	   ((void *)bond == (void *)slave)) {
-		printk(KERN_ERR
-			"bond_detach_slave(): trying to detach "
-			"slave %p from bond %p\n", bond, slave);
-		return slave;
-	}
-
-	if (bond->next == slave) {  /* is the slave at the head ? */
-		if (bond->prev == slave) {  /* is the slave alone ? */
-			write_lock(&bond->ptrlock);
-			bond->current_slave = NULL; /* no slave anymore */
-			write_unlock(&bond->ptrlock);
-			bond->prev = bond->next = (slave_t *)bond;
-		} else { /* not alone */
-			bond->next        = slave->next;
-			slave->next->prev = (slave_t *)bond;
-			bond->prev->next  = slave->next;
-
-			write_lock(&bond->ptrlock);
-			if (bond->current_slave == slave) {
-				bond->current_slave = slave->next;
-			}
-			write_unlock(&bond->ptrlock);
-		}
-	} else {
-		slave->prev->next = slave->next;
-		if (bond->prev == slave) {  /* is this slave the last one ? */
-			bond->prev = slave->prev;
-		} else {
-			slave->next->prev = slave->prev;
-		}
-
-		write_lock(&bond->ptrlock);
-		if (bond->current_slave == slave) {
-			bond->current_slave = slave->next;
-		}
-		write_unlock(&bond->ptrlock);
-	}
-
-	update_slave_cnt(bond, -1);
-
-	return slave;
-}
-
-static void
-bond_attach_slave(struct bonding *bond, struct slave *new_slave)
-{
-	/* 
-	 * queue to the end of the slaves list, make the first element its
-	 * successor, the last one its predecessor, and make it the bond's
-	 * predecessor. 
-	 *
-	 * Just to clarify, so future bonding driver hackers don't go through
-	 * the same confusion stage I did trying to figure this out, the
-	 * slaves are stored in a double linked circular list, sortof.
-	 * In the ->next direction, the last slave points to the first slave,
-	 * bypassing bond; only the slaves are in the ->next direction.
-	 * In the ->prev direction, however, the first slave points to bond
-	 * and bond points to the last slave.
-	 *
-	 * It looks like a circle with a little bubble hanging off one side
-	 * in the ->prev direction only.
-	 *
-	 * When going through the list once, its best to start at bond->prev
-	 * and go in the ->prev direction, testing for bond.  Doing this
-	 * in the ->next direction doesn't work.  Trust me, I know this now.
-	 * :)  -mts 2002.03.14
-	 */
-	new_slave->prev       = bond->prev;
-	new_slave->prev->next = new_slave;
-	bond->prev            = new_slave;
-	new_slave->next       = bond->next;
-
-	update_slave_cnt(bond, 1);
-}
-
-
-/*
- * Less bad way to call ioctl from within the kernel; this needs to be
- * done some other way to get the call out of interrupt context.
- * Needs "ioctl" variable to be supplied by calling context.
- */
-#define IOCTL(dev, arg, cmd) ({		\
-	int ret;			\
-	mm_segment_t fs = get_fs();	\
-	set_fs(get_ds());		\
-	ret = ioctl(dev, arg, cmd);	\
-	set_fs(fs);			\
-	ret; })
-
-/* 
- * if <dev> supports MII link status reporting, check its link status.
- *
- * We either do MII/ETHTOOL ioctls, or check netif_carrier_ok(),
- * depening upon the setting of the use_carrier parameter.
- *
- * Return either BMSR_LSTATUS, meaning that the link is up (or we
- * can't tell and just pretend it is), or 0, meaning that the link is
- * down.
- *
- * If reporting is non-zero, instead of faking link up, return -1 if
- * both ETHTOOL and MII ioctls fail (meaning the device does not
- * support them).  If use_carrier is set, return whatever it says.
- * It'd be nice if there was a good way to tell if a driver supports
- * netif_carrier, but there really isn't.
- */
-static int
-bond_check_dev_link(struct net_device *dev, int reporting)
-{
-	static int (* ioctl)(struct net_device *, struct ifreq *, int);
-	struct ifreq ifr;
-	struct mii_ioctl_data *mii;
-	struct ethtool_value etool;
-
-	if (use_carrier) {
-		return netif_carrier_ok(dev) ? BMSR_LSTATUS : 0;
-	}
-
-	ioctl = dev->do_ioctl;
-	if (ioctl) {
-		/* TODO: set pointer to correct ioctl on a per team member */
-		/*       bases to make this more efficient. that is, once  */
-		/*       we determine the correct ioctl, we will always    */
-		/*       call it and not the others for that team          */
-		/*       member.                                           */
-
-		/*
-		 * We cannot assume that SIOCGMIIPHY will also read a
-		 * register; not all network drivers (e.g., e100)
-		 * support that.
-		 */
-
-		/* Yes, the mii is overlaid on the ifreq.ifr_ifru */
-		mii = (struct mii_ioctl_data *)&ifr.ifr_data;
-		if (IOCTL(dev, &ifr, SIOCGMIIPHY) == 0) {
-			mii->reg_num = MII_BMSR;
-			if (IOCTL(dev, &ifr, SIOCGMIIREG) == 0) {
-				return mii->val_out & BMSR_LSTATUS;
-			}
-		}
-
-		/* try SIOCETHTOOL ioctl, some drivers cache ETHTOOL_GLINK */
-		/* for a period of time so we attempt to get link status   */
-		/* from it last if the above MII ioctls fail...            */
-	        etool.cmd = ETHTOOL_GLINK;
-	        ifr.ifr_data = (char*)&etool;
-		if (IOCTL(dev, &ifr, SIOCETHTOOL) == 0) {
-			if (etool.data == 1) {
-				return BMSR_LSTATUS;
-			} else { 
-#ifdef BONDING_DEBUG
-				printk(KERN_INFO 
-					":: SIOCETHTOOL shows link down \n");
-#endif
-				return 0;
-			} 
-		}
-
-	}
- 
-	/*
-	 * If reporting, report that either there's no dev->do_ioctl,
-	 * or both SIOCGMIIREG and SIOCETHTOOL failed (meaning that we
-	 * cannot report link status).  If not reporting, pretend
-	 * we're ok.
-	 */
-	return reporting ? -1 : BMSR_LSTATUS;
-}
-
-static u16 bond_check_mii_link(bonding_t *bond)
-{
-	int has_active_interface = 0;
-	unsigned long flags;
-
-	read_lock_irqsave(&bond->lock, flags);
-	read_lock(&bond->ptrlock);
-	has_active_interface = (bond->current_slave != NULL);
-	read_unlock(&bond->ptrlock);
-	read_unlock_irqrestore(&bond->lock, flags);
-
-	return (has_active_interface ? BMSR_LSTATUS : 0);
-}
-
-static int bond_open(struct net_device *dev)
-{
-	struct timer_list *timer = &((struct bonding *)(dev->priv))->mii_timer;
-	struct timer_list *arp_timer = &((struct bonding *)(dev->priv))->arp_timer;
-	MOD_INC_USE_COUNT;
-
-	if (miimon > 0) {  /* link check interval, in milliseconds. */
-		init_timer(timer);
-		timer->expires  = jiffies + (miimon * HZ / 1000);
-		timer->data     = (unsigned long)dev;
-		timer->function = (void *)&bond_mii_monitor;
-		add_timer(timer);
-	}
-
-	if (arp_interval> 0) {  /* arp interval, in milliseconds. */
-		init_timer(arp_timer);
-		arp_timer->expires  = jiffies + (arp_interval * HZ / 1000);
-		arp_timer->data     = (unsigned long)dev;
-		if (bond_mode == BOND_MODE_ACTIVEBACKUP) {
-			arp_timer->function = (void *)&activebackup_arp_monitor;
-		} else {
-			arp_timer->function = (void *)&loadbalance_arp_monitor;
-		}
-		add_timer(arp_timer);
-	}
-	return 0;
-}
-
-static int bond_close(struct net_device *master)
-{
-	bonding_t *bond = (struct bonding *) master->priv;
-	unsigned long flags;
-
-	write_lock_irqsave(&bond->lock, flags);
-
-	if (miimon > 0) {  /* link check interval, in milliseconds. */
-		del_timer(&bond->mii_timer);
-	}
-	if (arp_interval> 0) {  /* arp interval, in milliseconds. */
-		del_timer(&bond->arp_timer);
-                if (arp_target_hw_addr != NULL) {
-			kfree(arp_target_hw_addr); 
-			arp_target_hw_addr = NULL;
-		}
-	}
-
-	/* Release the bonded slaves */
-	bond_release_all(master);
-	bond_mc_list_destroy (bond);
-
-	write_unlock_irqrestore(&bond->lock, flags);
-
-	MOD_DEC_USE_COUNT;
-	return 0;
-}
-
-/* 
- * flush all members of flush->mc_list from device dev->mc_list
- */
-static void bond_mc_list_flush(struct net_device *dev, struct net_device *flush)
-{ 
-	struct dev_mc_list *dmi; 
- 
-	for (dmi = flush->mc_list; dmi != NULL; dmi = dmi->next) 
-		dev_mc_delete(dev, dmi->dmi_addr, dmi->dmi_addrlen, 0);
-}
-
-/*
- * Totally destroys the mc_list in bond
- */
-static void bond_mc_list_destroy(struct bonding *bond)
-{
-	struct dev_mc_list *dmi;
-
-	dmi = bond->mc_list; 
-	while (dmi) { 
-		bond->mc_list = dmi->next; 
-		kfree(dmi); 
-		dmi = bond->mc_list; 
-	}
-}
-
-/*
- * Add a Multicast address to every slave in the bonding group
- */
-static void bond_mc_add(bonding_t *bond, void *addr, int alen)
-{ 
-	slave_t *slave;
-	switch (multicast_mode) {
-	case BOND_MULTICAST_ACTIVE :
-		/* write lock already acquired */
-		if (bond->current_slave != NULL)
-			dev_mc_add(bond->current_slave->dev, addr, alen, 0);
-		break;
-	case BOND_MULTICAST_ALL :
-		for (slave = bond->prev; slave != (slave_t*)bond; slave = slave->prev)
-			dev_mc_add(slave->dev, addr, alen, 0);
-		break;
-	case BOND_MULTICAST_DISABLED :
-		break;
-	}
-} 
-
-/*
- * Remove a multicast address from every slave in the bonding group
- */
-static void bond_mc_delete(bonding_t *bond, void *addr, int alen)
-{ 
-	slave_t *slave; 
-	switch (multicast_mode) {
-	case BOND_MULTICAST_ACTIVE :
-		/* write lock already acquired */
-		if (bond->current_slave != NULL)
-			dev_mc_delete(bond->current_slave->dev, addr, alen, 0);
-		break;
-	case BOND_MULTICAST_ALL :
-		for (slave = bond->prev; slave != (slave_t*)bond; slave = slave->prev)
-			dev_mc_delete(slave->dev, addr, alen, 0);
-		break;
-	case BOND_MULTICAST_DISABLED :
-		break;
-	}
-} 
-
-/*
- * Copy all the Multicast addresses from src to the bonding device dst
- */
-static int bond_mc_list_copy (struct dev_mc_list *src, struct bonding *dst,
- int gpf_flag)
-{
-	struct dev_mc_list *dmi, *new_dmi;
-
-   	for (dmi = src; dmi != NULL; dmi = dmi->next) { 
-		new_dmi = kmalloc(sizeof(struct dev_mc_list), gpf_flag);
-
-		if (new_dmi == NULL) {
-			return -ENOMEM; 
-		}
-
-		new_dmi->next = dst->mc_list; 
-		dst->mc_list = new_dmi;
-
-		new_dmi->dmi_addrlen = dmi->dmi_addrlen; 
-		memcpy(new_dmi->dmi_addr, dmi->dmi_addr, dmi->dmi_addrlen); 
-		new_dmi->dmi_users = dmi->dmi_users;
-		new_dmi->dmi_gusers = dmi->dmi_gusers; 
-	} 
-	return 0;
-}
-
-/*
- * Returns 0 if dmi1 and dmi2 are the same, non-0 otherwise
- */
-static inline int dmi_same(struct dev_mc_list *dmi1, struct dev_mc_list *dmi2)
-{ 
-	return memcmp(dmi1->dmi_addr, dmi2->dmi_addr, dmi1->dmi_addrlen) == 0 &&
-	 dmi1->dmi_addrlen == dmi2->dmi_addrlen;
-} 
-
-/*
- * Push the promiscuity flag down to all slaves
- */
-static void bond_set_promiscuity(bonding_t *bond, int inc)
-{ 
-	slave_t *slave; 
-	switch (multicast_mode) {
-	case BOND_MULTICAST_ACTIVE :
-		/* write lock already acquired */
-		if (bond->current_slave != NULL)
-			dev_set_promiscuity(bond->current_slave->dev, inc);
-		break;
-	case BOND_MULTICAST_ALL :
-		for (slave = bond->prev; slave != (slave_t*)bond; slave = slave->prev)
-			dev_set_promiscuity(slave->dev, inc);
-		break;
-	case BOND_MULTICAST_DISABLED :
-		break;
-	}
-} 
-
-/*
- * Push the allmulti flag down to all slaves
- */
-static void bond_set_allmulti(bonding_t *bond, int inc)
-{ 
-	slave_t *slave; 
-	switch (multicast_mode) {
-	case BOND_MULTICAST_ACTIVE : 
-		/* write lock already acquired */
-		if (bond->current_slave != NULL)
-			dev_set_allmulti(bond->current_slave->dev, inc);
-		break;
-	case BOND_MULTICAST_ALL :
-		for (slave = bond->prev; slave != (slave_t*)bond; slave = slave->prev)
-			dev_set_allmulti(slave->dev, inc);
-		break;
-	case BOND_MULTICAST_DISABLED :
-		break;
-	}
-} 
-
-/* 
- * returns dmi entry if found, NULL otherwise 
- */
-static struct dev_mc_list* bond_mc_list_find_dmi(struct dev_mc_list *dmi,
- struct dev_mc_list *mc_list)
-{ 
-	struct dev_mc_list *idmi;
-
-	for (idmi = mc_list; idmi != NULL; idmi = idmi->next) {
-		if (dmi_same(dmi, idmi)) {
-			return idmi; 
-		}
-	}
-	return NULL;
-} 
-
-static void set_multicast_list(struct net_device *master)
-{
-	bonding_t *bond = master->priv;
-	struct dev_mc_list *dmi;
-	unsigned long flags = 0;
-
-	if (multicast_mode == BOND_MULTICAST_DISABLED)
-		return;
-	/*
-	 * Lock the private data for the master
-	 */
-	write_lock_irqsave(&bond->lock, flags);
-
-	/* set promiscuity flag to slaves */
-	if ( (master->flags & IFF_PROMISC) && !(bond->flags & IFF_PROMISC) )
-		bond_set_promiscuity(bond, 1); 
-
-	if ( !(master->flags & IFF_PROMISC) && (bond->flags & IFF_PROMISC) ) 
-		bond_set_promiscuity(bond, -1); 
-
-	/* set allmulti flag to slaves */ 
-	if ( (master->flags & IFF_ALLMULTI) && !(bond->flags & IFF_ALLMULTI) ) 
-		bond_set_allmulti(bond, 1); 
-
-	if ( !(master->flags & IFF_ALLMULTI) && (bond->flags & IFF_ALLMULTI) )
-		bond_set_allmulti(bond, -1); 
-
-	bond->flags = master->flags; 
-
-	/* looking for addresses to add to slaves' mc list */ 
-	for (dmi = master->mc_list; dmi != NULL; dmi = dmi->next) { 
-		if (bond_mc_list_find_dmi(dmi, bond->mc_list) == NULL) 
-		 bond_mc_add(bond, dmi->dmi_addr, dmi->dmi_addrlen); 
-	} 
-
-	/* looking for addresses to delete from slaves' list */ 
-	for (dmi = bond->mc_list; dmi != NULL; dmi = dmi->next) { 
-		if (bond_mc_list_find_dmi(dmi, master->mc_list) == NULL) 
-		 bond_mc_delete(bond, dmi->dmi_addr, dmi->dmi_addrlen); 
-	}
-
-
-	/* save master's multicast list */ 
-	bond_mc_list_destroy (bond);
-	bond_mc_list_copy (master->mc_list, bond, GFP_ATOMIC);
-
-	write_unlock_irqrestore(&bond->lock, flags);
-}
-
-/*
- * Update the mc list and multicast-related flags for the new and 
- * old active slaves (if any) according to the multicast mode
- */
-static void bond_mc_update(bonding_t *bond, slave_t *new, slave_t *old)
-{
-	struct dev_mc_list *dmi;
-
-	switch(multicast_mode) {
-	case BOND_MULTICAST_ACTIVE :		
-		if (bond->device->flags & IFF_PROMISC) {
-			if (old != NULL && new != old)
-				dev_set_promiscuity(old->dev, -1);
-			dev_set_promiscuity(new->dev, 1);
-		}
-		if (bond->device->flags & IFF_ALLMULTI) {
-			if (old != NULL && new != old)
-				dev_set_allmulti(old->dev, -1);
-			dev_set_allmulti(new->dev, 1);
-		}
-		/* first remove all mc addresses from old slave if any,
-		   and _then_ add them to new active slave */
-		if (old != NULL && new != old) {
-			for (dmi = bond->device->mc_list; dmi != NULL; dmi = dmi->next)
-				dev_mc_delete(old->dev, dmi->dmi_addr, dmi->dmi_addrlen, 0);
-		}
-		for (dmi = bond->device->mc_list; dmi != NULL; dmi = dmi->next)
-			dev_mc_add(new->dev, dmi->dmi_addr, dmi->dmi_addrlen, 0);
-		break;
-	case BOND_MULTICAST_ALL :
-		/* nothing to do: mc list is already up-to-date on all slaves */
-		break;
-	case BOND_MULTICAST_DISABLED :
-		break;
-	}
-}
-
-/* enslave device <slave> to bond device <master> */
-static int bond_enslave(struct net_device *master_dev, 
-                        struct net_device *slave_dev)
-{
-	bonding_t *bond = NULL;
-	slave_t *new_slave = NULL;
-	unsigned long flags = 0;
-	unsigned long rflags = 0;
-	int ndx = 0;
-	int err = 0;
-	struct dev_mc_list *dmi;
-	struct in_ifaddr **ifap;
-	struct in_ifaddr *ifa;
-	int link_reporting;
-
-	if (master_dev == NULL || slave_dev == NULL) {
-		return -ENODEV;
-	}
-	bond = (struct bonding *) master_dev->priv;
-
-	if (slave_dev->do_ioctl == NULL) {
-		printk(KERN_DEBUG
-			"Warning : no link monitoring support for %s\n",
-			slave_dev->name);
-	}
-
-	/* not running. */
-	if ((slave_dev->flags & IFF_UP) != IFF_UP) {
-#ifdef BONDING_DEBUG
-		printk(KERN_CRIT "Error, slave_dev is not running\n");
-#endif
-		return -EINVAL;
-	}
-
-	/* already enslaved */
-	if (master_dev->flags & IFF_SLAVE || slave_dev->flags & IFF_SLAVE) {
-#ifdef BONDING_DEBUG
-		printk(KERN_CRIT "Error, Device was already enslaved\n");
-#endif
-		return -EBUSY;
-	}
-		   
-	if ((new_slave = kmalloc(sizeof(slave_t), GFP_ATOMIC)) == NULL) {
-		return -ENOMEM;
-	}
-	memset(new_slave, 0, sizeof(slave_t));
-
-	/* save flags before call to netdev_set_master */
-	new_slave->original_flags = slave_dev->flags;
-	err = netdev_set_master(slave_dev, master_dev);
-
-	if (err) {
-#ifdef BONDING_DEBUG
-		printk(KERN_CRIT "Error %d calling netdev_set_master\n", err);
-#endif
-		goto err_free;
-	}
-
-	new_slave->dev = slave_dev;
-
-	if (multicast_mode == BOND_MULTICAST_ALL) {
-		/* set promiscuity level to new slave */ 
-		if (master_dev->flags & IFF_PROMISC)
-			dev_set_promiscuity(slave_dev, 1); 
- 
-		/* set allmulti level to new slave */
-		if (master_dev->flags & IFF_ALLMULTI) 
-			dev_set_allmulti(slave_dev, 1); 
-		
-		/* upload master's mc_list to new slave */ 
-		for (dmi = master_dev->mc_list; dmi != NULL; dmi = dmi->next) 
-			dev_mc_add (slave_dev, dmi->dmi_addr, dmi->dmi_addrlen, 0);
-	}
-
-	write_lock_irqsave(&bond->lock, flags);
-	
-	bond_attach_slave(bond, new_slave);
-	new_slave->delay = 0;
-	new_slave->link_failure_count = 0;
-
-	if (miimon > 0 && !use_carrier) {
-		link_reporting = bond_check_dev_link(slave_dev, 1);
-
-		if ((link_reporting == -1) && (arp_interval == 0)) {
-			/*
-			 * miimon is set but a bonded network driver
-			 * does not support ETHTOOL/MII and
-			 * arp_interval is not set.  Note: if
-			 * use_carrier is enabled, we will never go
-			 * here (because netif_carrier is always
-			 * supported); thus, we don't need to change
-			 * the messages for netif_carrier.
-			 */ 
-			printk(KERN_ERR
-				"bond_enslave(): MII and ETHTOOL support not "
-				"available for interface %s, and "
-				"arp_interval/arp_ip_target module parameters "
-		       		"not specified, thus bonding will not detect "
-				"link failures! see bonding.txt for details.\n",
-		       		slave_dev->name);
-		} else if (link_reporting == -1) {
-			/* unable  get link status using mii/ethtool */
-			printk(KERN_WARNING 
-			       "bond_enslave: can't get link status from "
-			       "interface %s; the network driver associated "
-			       "with this interface does not support "
-			       "MII or ETHTOOL link status reporting, thus "
-			       "miimon has no effect on this interface.\n", 
-			       slave_dev->name);
-		}
-	}
-
-	/* check for initial state */
-	if ((miimon <= 0) ||
-	    (bond_check_dev_link(slave_dev, 0) == BMSR_LSTATUS)) {
-#ifdef BONDING_DEBUG
-		printk(KERN_CRIT "Initial state of slave_dev is BOND_LINK_UP\n");
-#endif
-		new_slave->link  = BOND_LINK_UP;
-		new_slave->jiffies = jiffies;
-	}
-	else {
-#ifdef BONDING_DEBUG
-		printk(KERN_CRIT "Initial state of slave_dev is BOND_LINK_DOWN\n");
-#endif
-		new_slave->link  = BOND_LINK_DOWN;
-	}
-
-	/* if we're in active-backup mode, we need one and only one active
-	 * interface. The backup interfaces will have their NOARP flag set
-	 * because we need them to be completely deaf and not to respond to
-	 * any ARP request on the network to avoid fooling a switch. Thus,
-	 * since we guarantee that current_slave always point to the last
-	 * usable interface, we just have to verify this interface's flag.
-	 */
-	if (bond_mode == BOND_MODE_ACTIVEBACKUP) {
-		if (((bond->current_slave == NULL)
-			|| (bond->current_slave->dev->flags & IFF_NOARP))
-			&& (new_slave->link == BOND_LINK_UP)) {
-#ifdef BONDING_DEBUG
-			printk(KERN_CRIT "This is the first active slave\n");
-#endif
-			/* first slave or no active slave yet, and this link
-			   is OK, so make this interface the active one */
-			bond->current_slave = new_slave;
-			bond_set_slave_active_flags(new_slave);
-			bond_mc_update(bond, new_slave, NULL);
-		}
-		else {
-#ifdef BONDING_DEBUG
-			printk(KERN_CRIT "This is just a backup slave\n");
-#endif
-			bond_set_slave_inactive_flags(new_slave);
-		}
-		read_lock_irqsave(&(((struct in_device *)slave_dev->ip_ptr)->lock), rflags);
-		ifap= &(((struct in_device *)slave_dev->ip_ptr)->ifa_list);
-		ifa = *ifap;
-		my_ip = ifa->ifa_address;
-		read_unlock_irqrestore(&(((struct in_device *)slave_dev->ip_ptr)->lock), rflags);
-
-		/* if there is a primary slave, remember it */
-		if (primary != NULL)
-		  if( strcmp(primary, new_slave->dev->name) == 0) 
-			bond->primary_slave = new_slave;
-	} else {
-#ifdef BONDING_DEBUG
-		printk(KERN_CRIT "This slave is always active in trunk mode\n");
-#endif
-		/* always active in trunk mode */
-		new_slave->state = BOND_STATE_ACTIVE;
-		if (bond->current_slave == NULL) 
-			bond->current_slave = new_slave;
-	}
-
-	write_unlock_irqrestore(&bond->lock, flags);
-
-	/*
-	 * !!! This is to support old versions of ifenslave.  We can remove
-	 * this in 2.5 because our ifenslave takes care of this for us.
-	 * We check to see if the master has a mac address yet.  If not,
-	 * we'll give it the mac address of our slave device.
-	 */
-	for (ndx = 0; ndx < slave_dev->addr_len; ndx++) {
-#ifdef BONDING_DEBUG
-		printk(KERN_CRIT "Checking ndx=%d of master_dev->dev_addr\n",
-		       ndx);
-#endif
-		if (master_dev->dev_addr[ndx] != 0) {
-#ifdef BONDING_DEBUG
-		printk(KERN_CRIT "Found non-zero byte at ndx=%d\n",
-		       ndx);
-#endif
-			break;
-		}
-	}
-	if (ndx == slave_dev->addr_len) {
-		/*
-		 * We got all the way through the address and it was
-		 * all 0's.
-		 */
-#ifdef BONDING_DEBUG
-		printk(KERN_CRIT "%s doesn't have a MAC address yet.  ",
-		       master_dev->name);
-		printk(KERN_CRIT "Going to give assign it from %s.\n",
-		       slave_dev->name);
-#endif
-		bond_sethwaddr(master_dev, slave_dev);
-	}
-
-	printk (KERN_INFO "%s: enslaving %s as a%s interface with a%s link.\n",
-		master_dev->name, slave_dev->name,
-		new_slave->state == BOND_STATE_ACTIVE ? "n active" : " backup",
-		new_slave->link == BOND_LINK_UP ? "n up" : " down");
-
-	/* enslave is successful */
-	return 0;
-err_free:
-	kfree(new_slave);
-	return err;
-}
-
-/* 
- * This function changes the active slave to slave <slave_dev>.
- * It returns -EINVAL in the following cases.
- *  - <slave_dev> is not found in the list.
- *  - There is not active slave now.
- *  - <slave_dev> is already active.
- *  - The link state of <slave_dev> is not BOND_LINK_UP.
- *  - <slave_dev> is not running.
- * In these cases, this fuction does nothing.
- * In the other cases, currnt_slave pointer is changed and 0 is returned.
- */
-static int bond_change_active(struct net_device *master_dev, struct net_device *slave_dev)
-{
-	bonding_t *bond;
-	slave_t *slave;
-	slave_t *oldactive = NULL;
-	slave_t *newactive = NULL;
-	unsigned long flags;
-	int ret = 0;
-
-	if (master_dev == NULL || slave_dev == NULL) {
-		return -ENODEV;
-	}
-
-	bond = (struct bonding *) master_dev->priv;
-	write_lock_irqsave(&bond->lock, flags);
-	slave = (slave_t *)bond;
-	oldactive = bond->current_slave;
-
-	while ((slave = slave->prev) != (slave_t *)bond) {
-		if(slave_dev == slave->dev) {
-			newactive = slave;
-			break;
-		}
-	}
-
-	if ((newactive != NULL)&&
-	    (oldactive != NULL)&&
-	    (newactive != oldactive)&&
-	    (newactive->link == BOND_LINK_UP)&&
-	    IS_UP(newactive->dev)) {
-		bond_set_slave_inactive_flags(oldactive);
-		bond_set_slave_active_flags(newactive);
-		bond_mc_update(bond, newactive, oldactive);
-		bond->current_slave = newactive;
-		printk("%s : activate %s(old : %s)\n",
-			master_dev->name, newactive->dev->name, 
-			oldactive->dev->name);
-	}
-	else {
-		ret = -EINVAL;
-	}
-	write_unlock_irqrestore(&bond->lock, flags);
-	return ret;
-}
-
-/* Choose a new valid interface from the pool, set it active
- * and make it the current slave. If no valid interface is
- * found, the oldest slave in BACK state is choosen and
- * activated. If none is found, it's considered as no
- * interfaces left so the current slave is set to NULL.
- * The result is a pointer to the current slave.
- *
- * Since this function sends messages tails through printk, the caller
- * must have started something like `printk(KERN_INFO "xxxx ");'.
- *
- * Warning: must put locks around the call to this function if needed.
- */
-slave_t *change_active_interface(bonding_t *bond)
-{
-	slave_t *newslave, *oldslave;
-	slave_t *bestslave = NULL;
-	int mintime;
-
-	read_lock(&bond->ptrlock);
-	newslave = oldslave = bond->current_slave;
-	read_unlock(&bond->ptrlock);
-
-	if (newslave == NULL) { /* there were no active slaves left */
-		if (bond->next != (slave_t *)bond) {  /* found one slave */
-			write_lock(&bond->ptrlock);
-			newslave = bond->current_slave = bond->next;
-			write_unlock(&bond->ptrlock);
-		} else {
-
-			printk (" but could not find any %s interface.\n",
-				(bond_mode == BOND_MODE_ACTIVEBACKUP) ? "backup":"other");
-			write_lock(&bond->ptrlock);
-			bond->current_slave = (slave_t *)NULL;
-			write_unlock(&bond->ptrlock);
-			return NULL; /* still no slave, return NULL */
-		}
-	} else if (bond_mode == BOND_MODE_ACTIVEBACKUP) {
-		/* make sure oldslave doesn't send arps - this could
-		 * cause a ping-pong effect between interfaces since they
-		 * would be able to tx arps - in active backup only one
-		 * slave should be able to tx arps, and that should be
-		 * the current_slave; the only exception is when all
-		 * slaves have gone down, then only one non-current slave can
-		 * send arps at a time; clearing oldslaves' mc list is handled
-		 * later in this function.
-		 */
-		bond_set_slave_inactive_flags(oldslave);
-	}
-
-	mintime = updelay;
-
-	/* first try the primary link; if arping, a link must tx/rx traffic 
-	 * before it can be considered the current_slave - also, we would skip 
-	 * slaves between the current_slave and primary_slave that may be up 
-	 * and able to arp
-	 */
-	if ((bond->primary_slave != NULL) && (arp_interval == 0)) {
-		if (IS_UP(bond->primary_slave->dev)) 
-			newslave = bond->primary_slave;
-	}
-
-	do {
-		if (IS_UP(newslave->dev)) {
-			if (newslave->link == BOND_LINK_UP) {
-				/* this one is immediately usable */
-				if (bond_mode == BOND_MODE_ACTIVEBACKUP) {
-					bond_set_slave_active_flags(newslave);
-					bond_mc_update(bond, newslave, oldslave);
-					printk (" and making interface %s the active one.\n",
-						newslave->dev->name);
-				}
-				else {
-					printk (" and setting pointer to interface %s.\n",
-						newslave->dev->name);
-				}
-
-				write_lock(&bond->ptrlock);
-				bond->current_slave = newslave;
-				write_unlock(&bond->ptrlock);
-				return newslave;
-			}
-			else if (newslave->link == BOND_LINK_BACK) {
-				/* link up, but waiting for stabilization */
-				if (newslave->delay < mintime) {
-					mintime = newslave->delay;
-					bestslave = newslave;
-				}
-			}
-		}
-	} while ((newslave = newslave->next) != oldslave);
-
-	/* no usable backup found, we'll see if we at least got a link that was
-	   coming back for a long time, and could possibly already be usable.
-	*/
-
-	if (bestslave != NULL) {
-		/* early take-over. */
-		printk (" and making interface %s the active one %d ms earlier.\n",
-			bestslave->dev->name,
-			(updelay - bestslave->delay)*miimon);
-
-		bestslave->delay = 0;
-		bestslave->link = BOND_LINK_UP;
-		bestslave->jiffies = jiffies;
-		bond_set_slave_active_flags(bestslave);
-		bond_mc_update(bond, bestslave, oldslave);
-		write_lock(&bond->ptrlock);
-		bond->current_slave = bestslave;
-		write_unlock(&bond->ptrlock);
-		return bestslave;
-	}
-
-	if ((bond_mode == BOND_MODE_ACTIVEBACKUP) &&
-	    (multicast_mode == BOND_MULTICAST_ACTIVE) &&
-	    (oldslave != NULL)) {
-		/* flush bonds (master's) mc_list from oldslave since it wasn't
-		 * updated (and deleted) above
-		 */ 
-		bond_mc_list_flush(oldslave->dev, bond->device); 
-		if (bond->device->flags & IFF_PROMISC) {
-			dev_set_promiscuity(oldslave->dev, -1);
-		}
-		if (bond->device->flags & IFF_ALLMULTI) {
-			dev_set_allmulti(oldslave->dev, -1);
-		}
-	}
-
-	printk (" but could not find any %s interface.\n",
-		(bond_mode == BOND_MODE_ACTIVEBACKUP) ? "backup":"other");
-	
-	/* absolutely nothing found. let's return NULL */
-	write_lock(&bond->ptrlock);
-	bond->current_slave = (slave_t *)NULL;
-	write_unlock(&bond->ptrlock);
-	return NULL;
-}
-
-/*
- * Try to release the slave device <slave> from the bond device <master>
- * It is legal to access current_slave without a lock because all the function
- * is write-locked.
- *
- * The rules for slave state should be:
- *   for Active/Backup:
- *     Active stays on all backups go down
- *   for Bonded connections:
- *     The first up interface should be left on and all others downed.
- */
-static int bond_release(struct net_device *master, struct net_device *slave)
-{
-	bonding_t *bond;
-	slave_t *our_slave, *old_current;
-	unsigned long flags;
-	
-	if (master == NULL || slave == NULL)  {
-		return -ENODEV;
-	}
-
-	bond = (struct bonding *) master->priv;
-
-	/* master already enslaved, or slave not enslaved,
-	   or no slave for this master */
-	if ((master->flags & IFF_SLAVE) || !(slave->flags & IFF_SLAVE)) {
-		printk (KERN_DEBUG "%s: cannot release %s.\n", master->name, slave->name);
-		return -EINVAL;
-	}
-
-	write_lock_irqsave(&bond->lock, flags);
-	bond->current_arp_slave = NULL;
-	our_slave = (slave_t *)bond;
-	old_current = bond->current_slave;
-	while ((our_slave = our_slave->prev) != (slave_t *)bond) {
-		if (our_slave->dev == slave) {
-			bond_detach_slave(bond, our_slave);
-
-			printk (KERN_INFO "%s: releasing %s interface %s",
-				master->name,
-				(our_slave->state == BOND_STATE_ACTIVE) ? "active" : "backup",
-				slave->name);
-
-			if (our_slave == old_current) {
-				/* find a new interface and be verbose */
-				change_active_interface(bond); 
-			} else {
-				printk(".\n");
-			}
-			
-			if (bond->current_slave == NULL) {
-				printk(KERN_INFO
-					"%s: now running without any active interface !\n",
-					master->name);
-			}
-
-			if (bond->primary_slave == our_slave) {
-				bond->primary_slave = NULL;
-			}
-
-			break;
-		}
-
-	}
-	write_unlock_irqrestore(&bond->lock, flags);
-	
-	if (our_slave == (slave_t *)bond) {
-		/* if we get here, it's because the device was not found */
-		printk (KERN_INFO "%s: %s not enslaved\n", master->name, slave->name);
-		return -EINVAL;
-	}
-
-	/* undo settings and restore original values */
-	
-	if (multicast_mode == BOND_MULTICAST_ALL) {
-		/* flush master's mc_list from slave */ 
-		bond_mc_list_flush (slave, master); 
-
-		/* unset promiscuity level from slave */
-		if (master->flags & IFF_PROMISC) 
-			dev_set_promiscuity(slave, -1); 
-
-		/* unset allmulti level from slave */ 
-		if (master->flags & IFF_ALLMULTI)
-			dev_set_allmulti(slave, -1); 
-	}
-
-	netdev_set_master(slave, NULL);
-
-	/* only restore its RUNNING flag if monitoring set it down */
-	if (slave->flags & IFF_UP) {
-		slave->flags |= IFF_RUNNING;
-	}
-
-	if (slave->flags & IFF_NOARP || 
-		bond->current_slave != NULL) {
-			dev_close(slave);
-			our_slave->original_flags &= ~IFF_UP;
-	}
-
-	bond_restore_slave_flags(our_slave);
-	
-	kfree(our_slave);
-
-	return 0;  /* deletion OK */
-}
-
-/* 
- * This function releases all slaves.
- * Warning: must put write-locks around the call to this function.
- */
-static int bond_release_all(struct net_device *master)
-{
-	bonding_t *bond;
-	slave_t *our_slave;
-	struct net_device *slave_dev;
-
-	if (master == NULL)  {
-		return -ENODEV;
-	}
-
-	if (master->flags & IFF_SLAVE) {
-		return -EINVAL;
-	}
-
-	bond = (struct bonding *) master->priv;
-	bond->current_arp_slave = NULL;
-	bond->current_slave = NULL;
-	bond->primary_slave = NULL;
-
-	while ((our_slave = bond->prev) != (slave_t *)bond) {
-		slave_dev = our_slave->dev;
-		bond_detach_slave(bond, our_slave);
-
-		if (multicast_mode == BOND_MULTICAST_ALL 
-		    || (multicast_mode == BOND_MULTICAST_ACTIVE 
-			&& bond->current_slave == our_slave)) {
-
-			/* flush master's mc_list from slave */ 
-			bond_mc_list_flush (slave_dev, master); 
-			
-			/* unset promiscuity level from slave */
-			if (master->flags & IFF_PROMISC) 
-				dev_set_promiscuity(slave_dev, -1); 
-			
-			/* unset allmulti level from slave */ 
-			if (master->flags & IFF_ALLMULTI)
-				dev_set_allmulti(slave_dev, -1); 
-		}
-
-		kfree(our_slave);
-
-		/*
-		 * Can be safely called from inside the bond lock
-		 * since traffic and timers have already stopped
-		 */
-		netdev_set_master(slave_dev, NULL);
-
-		/* only restore its RUNNING flag if monitoring set it down */
-		if (slave_dev->flags & IFF_UP)
-			slave_dev->flags |= IFF_RUNNING;
-
-		if (slave_dev->flags & IFF_NOARP)
-			dev_close(slave_dev);
-	}
-
-	printk (KERN_INFO "%s: released all slaves\n", master->name);
-
-	return 0;
-}
-
-/* this function is called regularly to monitor each slave's link. */
-static void bond_mii_monitor(struct net_device *master)
-{
-	bonding_t *bond = (struct bonding *) master->priv;
-	slave_t *slave, *bestslave, *oldcurrent;
-	unsigned long flags;
-	int slave_died = 0;
-
-	read_lock_irqsave(&bond->lock, flags);
-
-	/* we will try to read the link status of each of our slaves, and
-	 * set their IFF_RUNNING flag appropriately. For each slave not
-	 * supporting MII status, we won't do anything so that a user-space
-	 * program could monitor the link itself if needed.
-	 */
-
-	bestslave = NULL;
-	slave = (slave_t *)bond;
-
-	read_lock(&bond->ptrlock);
-	oldcurrent = bond->current_slave;
-	read_unlock(&bond->ptrlock);
-
-	while ((slave = slave->prev) != (slave_t *)bond) {
-		/* use updelay+1 to match an UP slave even when updelay is 0 */
-		int mindelay = updelay + 1;
-		struct net_device *dev = slave->dev;
-		int link_state;
-		
-		link_state = bond_check_dev_link(dev, 0);
-
-		switch (slave->link) {
-		case BOND_LINK_UP:	/* the link was up */
-			if (link_state == BMSR_LSTATUS) {
-				/* link stays up, tell that this one
-				   is immediately available */
-				if (IS_UP(dev) && (mindelay > -2)) {
-					/* -2 is the best case :
-					   this slave was already up */
-					mindelay = -2;
-					bestslave = slave;
-				}
-				break;
-			}
-			else { /* link going down */
-				slave->link  = BOND_LINK_FAIL;
-				slave->delay = downdelay;
-				if (slave->link_failure_count < UINT_MAX) {
-					slave->link_failure_count++;
-				}
-				if (downdelay > 0) {
-					printk (KERN_INFO
-						"%s: link status down for %sinterface "
-						"%s, disabling it in %d ms.\n",
-						master->name,
-						IS_UP(dev)
-						? ((bond_mode == BOND_MODE_ACTIVEBACKUP)
-						   ? ((slave == oldcurrent)
-						      ? "active " : "backup ")
-						   : "")
-						: "idle ",
-						dev->name,
-						downdelay * miimon);
-					}
-			}
-			/* no break ! fall through the BOND_LINK_FAIL test to
-			   ensure proper action to be taken
-			*/
-		case BOND_LINK_FAIL:	/* the link has just gone down */
-			if (link_state != BMSR_LSTATUS) {
-				/* link stays down */
-				if (slave->delay <= 0) {
-					/* link down for too long time */
-					slave->link = BOND_LINK_DOWN;
-					/* in active/backup mode, we must
-					   completely disable this interface */
-					if (bond_mode == BOND_MODE_ACTIVEBACKUP) {
-						bond_set_slave_inactive_flags(slave);
-					}
-					printk(KERN_INFO
-						"%s: link status definitely down "
-						"for interface %s, disabling it",
-						master->name,
-						dev->name);
-
-					read_lock(&bond->ptrlock);
-					if (slave == bond->current_slave) {
-						read_unlock(&bond->ptrlock);
-						/* find a new interface and be verbose */
-						change_active_interface(bond);
-					} else {
-						read_unlock(&bond->ptrlock);
-						printk(".\n");
-					}
-					slave_died = 1;
-				} else {
-					slave->delay--;
-				}
-			} else {
-				/* link up again */
-				slave->link  = BOND_LINK_UP;
-				slave->jiffies = jiffies;
-				printk(KERN_INFO
-					"%s: link status up again after %d ms "
-					"for interface %s.\n",
-					master->name,
-					(downdelay - slave->delay) * miimon,
-					dev->name);
-
-				if (IS_UP(dev) && (mindelay > -1)) {
-					/* -1 is a good case : this slave went
-					   down only for a short time */
-					mindelay = -1;
-					bestslave = slave;
-				}
-			}
-			break;
-		case BOND_LINK_DOWN:	/* the link was down */
-			if (link_state != BMSR_LSTATUS) {
-				/* the link stays down, nothing more to do */
-				break;
-			} else {	/* link going up */
-				slave->link  = BOND_LINK_BACK;
-				slave->delay = updelay;
-				
-				if (updelay > 0) {
-					/* if updelay == 0, no need to
-					   advertise about a 0 ms delay */
-					printk (KERN_INFO
-						"%s: link status up for interface"
-						" %s, enabling it in %d ms.\n",
-						master->name,
-						dev->name,
-						updelay * miimon);
-				}
-			}
-			/* no break ! fall through the BOND_LINK_BACK state in
-			   case there's something to do.
-			*/
-		case BOND_LINK_BACK:	/* the link has just come back */
-			if (link_state != BMSR_LSTATUS) {
-				/* link down again */
-				slave->link  = BOND_LINK_DOWN;
-				printk(KERN_INFO
-					"%s: link status down again after %d ms "
-					"for interface %s.\n",
-					master->name,
-					(updelay - slave->delay) * miimon,
-					dev->name);
-			} else {
-				/* link stays up */
-				if (slave->delay == 0) {
-					/* now the link has been up for long time enough */
-					slave->link = BOND_LINK_UP;
-					slave->jiffies = jiffies;
-
-					if (bond_mode != BOND_MODE_ACTIVEBACKUP) {
-						/* make it immediately active */
-						slave->state = BOND_STATE_ACTIVE;
-					} else if (slave != bond->primary_slave) {
-						/* prevent it from being the active one */
-						slave->state = BOND_STATE_BACKUP;
-					}
-
-					printk(KERN_INFO
-						"%s: link status definitely up "
-						"for interface %s.\n",
-						master->name,
-						dev->name);
-	
-					if ( (bond->primary_slave != NULL)	 
-					  && (slave == bond->primary_slave) )
-						change_active_interface(bond); 
-				}
-				else
-					slave->delay--;
-				
-				/* we'll also look for the mostly eligible slave */
-				if (bond->primary_slave == NULL)  {
-				    if (IS_UP(dev) && (slave->delay < mindelay)) {
-					mindelay = slave->delay;
-					bestslave = slave;
-				    } 
-				} else if ( (IS_UP(bond->primary_slave->dev))  || 
-				          ( (!IS_UP(bond->primary_slave->dev))  && 
-				          (IS_UP(dev) && (slave->delay < mindelay)) ) ) {
-					mindelay = slave->delay;
-					bestslave = slave;
-				}
-			}
-			break;
-		} /* end of switch */
-	} /* end of while */
-
-	/* 
-	 * if there's no active interface and we discovered that one
-	 * of the slaves could be activated earlier, so we do it.
-	 */
-	read_lock(&bond->ptrlock);
-	oldcurrent = bond->current_slave;
-	read_unlock(&bond->ptrlock);
-
-	/* no active interface at the moment or need to bring up the primary */
-	if (oldcurrent == NULL)  { /* no active interface at the moment */
-		if (bestslave != NULL) { /* last chance to find one ? */
-			if (bestslave->link == BOND_LINK_UP) {
-				printk (KERN_INFO
-					"%s: making interface %s the new active one.\n",
-					master->name, bestslave->dev->name);
-			} else {
-				printk (KERN_INFO
-					"%s: making interface %s the new "
-					"active one %d ms earlier.\n",
-					master->name, bestslave->dev->name,
-					(updelay - bestslave->delay) * miimon);
-
-				bestslave->delay = 0;
-				bestslave->link  = BOND_LINK_UP;
-				bestslave->jiffies = jiffies;
-			}
-
-			if (bond_mode == BOND_MODE_ACTIVEBACKUP) {
-				bond_set_slave_active_flags(bestslave);
-				bond_mc_update(bond, bestslave, NULL);
-			} else {
-				bestslave->state = BOND_STATE_ACTIVE;
-			}
-			write_lock(&bond->ptrlock);
-			bond->current_slave = bestslave;
-			write_unlock(&bond->ptrlock);
-		} else if (slave_died) {
-			/* print this message only once a slave has just died */
-			printk(KERN_INFO
-				"%s: now running without any active interface !\n",
-				master->name);
-		}
-	}
-
-	read_unlock_irqrestore(&bond->lock, flags);
-	/* re-arm the timer */
-	mod_timer(&bond->mii_timer, jiffies + (miimon * HZ / 1000));
-}
-
-/* 
- * this function is called regularly to monitor each slave's link 
- * ensuring that traffic is being sent and received when arp monitoring
- * is used in load-balancing mode. if the adapter has been dormant, then an 
- * arp is transmitted to generate traffic. see activebackup_arp_monitor for 
- * arp monitoring in active backup mode. 
- */
-static void loadbalance_arp_monitor(struct net_device *master)
-{
-	bonding_t *bond;
-	unsigned long flags;
-	slave_t *slave;
-	int the_delta_in_ticks =  arp_interval * HZ / 1000;
-	int next_timer = jiffies + (arp_interval * HZ / 1000);
-
-	bond = (struct bonding *) master->priv; 
-	if (master->priv == NULL) {
-		mod_timer(&bond->arp_timer, next_timer);
-		return;
-	}
-
-	read_lock_irqsave(&bond->lock, flags);
-
-	/* TODO: investigate why rtnl_shlock_nowait and rtnl_exlock_nowait
-	 * are called below and add comment why they are required... 
-	 */
-	if ((!IS_UP(master)) || rtnl_shlock_nowait()) {
-		mod_timer(&bond->arp_timer, next_timer);
-		read_unlock_irqrestore(&bond->lock, flags);
-		return;
-	}
-
-	if (rtnl_exlock_nowait()) {
-		rtnl_shunlock();
-		mod_timer(&bond->arp_timer, next_timer);
-		read_unlock_irqrestore(&bond->lock, flags);
-		return;
-	}
-
-	/* see if any of the previous devices are up now (i.e. they have
-	 * xmt and rcv traffic). the current_slave does not come into
-	 * the picture unless it is null. also, slave->jiffies is not needed
-	 * here because we send an arp on each slave and give a slave as
-	 * long as it needs to get the tx/rx within the delta.
-	 * TODO: what about up/down delay in arp mode? it wasn't here before
-	 *       so it can wait 
-	 */
-	slave = (slave_t *)bond;
-	while ((slave = slave->prev) != (slave_t *)bond)  {
-
-	  	if (slave->link != BOND_LINK_UP) {
-
-	  		if (((jiffies - slave->dev->trans_start) <= 
-						the_delta_in_ticks) &&  
-			     ((jiffies - slave->dev->last_rx) <= 
-						the_delta_in_ticks)) {
-
-				slave->link  = BOND_LINK_UP;
-				slave->state = BOND_STATE_ACTIVE;
-
-				/* primary_slave has no meaning in round-robin
-				 * mode. the window of a slave being up and 
-				 * current_slave being null after enslaving
-				 * is closed.
-				 */
-				read_lock(&bond->ptrlock);
-				if (bond->current_slave == NULL) {
-					read_unlock(&bond->ptrlock);
-					printk(KERN_INFO
-						"%s: link status definitely up "
-						"for interface %s, ",
-						master->name,
-						slave->dev->name);
-					change_active_interface(bond); 
-				} else {
-					read_unlock(&bond->ptrlock);
-					printk(KERN_INFO
-						"%s: interface %s is now up\n",
-						master->name,
-						slave->dev->name);
-				}
-			} 
-		} else {
-			/* slave->link == BOND_LINK_UP */
-
-			/* not all switches will respond to an arp request
-			 * when the source ip is 0, so don't take the link down
-			 * if we don't know our ip yet
-			 */
-			if (((jiffies - slave->dev->trans_start) >= 
-		              (2*the_delta_in_ticks)) ||
-		             (((jiffies - slave->dev->last_rx) >= 
-		               (2*the_delta_in_ticks)) && my_ip !=0)) {
-				slave->link  = BOND_LINK_DOWN;
-				slave->state = BOND_STATE_BACKUP;
-				if (slave->link_failure_count < UINT_MAX) {
-					slave->link_failure_count++;
-				}
-				printk(KERN_INFO
-				       "%s: interface %s is now down.\n",
-				       master->name,
-				       slave->dev->name);
-
-				read_lock(&bond->ptrlock);
-				if (slave == bond->current_slave) {
-					read_unlock(&bond->ptrlock);
-					change_active_interface(bond);
-				} else {
-					read_unlock(&bond->ptrlock);
-				}
-			}
-		} 
-
-		/* note: if switch is in round-robin mode, all links 
-		 * must tx arp to ensure all links rx an arp - otherwise
-		 * links may oscillate or not come up at all; if switch is 
-		 * in something like xor mode, there is nothing we can 
-		 * do - all replies will be rx'ed on same link causing slaves 
-		 * to be unstable during low/no traffic periods
-		 */
-		if (IS_UP(slave->dev)) {
-			arp_send_all(slave);
-		}
-	}
-
-	rtnl_exunlock();
-	rtnl_shunlock();
-	read_unlock_irqrestore(&bond->lock, flags);
-
-	/* re-arm the timer */
-	mod_timer(&bond->arp_timer, next_timer);
-}
-
-/* 
- * When using arp monitoring in active-backup mode, this function is
- * called to determine if any backup slaves have went down or a new
- * current slave needs to be found.
- * The backup slaves never generate traffic, they are considered up by merely 
- * receiving traffic. If the current slave goes down, each backup slave will 
- * be given the opportunity to tx/rx an arp before being taken down - this 
- * prevents all slaves from being taken down due to the current slave not 
- * sending any traffic for the backups to receive. The arps are not necessarily
- * necessary, any tx and rx traffic will keep the current slave up. While any 
- * rx traffic will keep the backup slaves up, the current slave is responsible 
- * for generating traffic to keep them up regardless of any other traffic they 
- * may have received.
- * see loadbalance_arp_monitor for arp monitoring in load balancing mode
- */
-static void activebackup_arp_monitor(struct net_device *master)
-{
-	bonding_t *bond;
-	unsigned long flags;
-	slave_t *slave;
-	int the_delta_in_ticks =  arp_interval * HZ / 1000;
-	int next_timer = jiffies + (arp_interval * HZ / 1000);
-
-	bond = (struct bonding *) master->priv; 
-	if (master->priv == NULL) {
-		mod_timer(&bond->arp_timer, next_timer);
-		return;
-	}
-
-	read_lock_irqsave(&bond->lock, flags);
-
-	if (!IS_UP(master)) {
-		mod_timer(&bond->arp_timer, next_timer);
-	        read_unlock_irqrestore(&bond->lock, flags);
-		return;
-	}
-
-	/* determine if any slave has come up or any backup slave has 
-	 * gone down 
-	 * TODO: what about up/down delay in arp mode? it wasn't here before
-	 *       so it can wait 
-	 */
-	slave = (slave_t *)bond;
-	while ((slave = slave->prev) != (slave_t *)bond)  {
-
-	  	if (slave->link != BOND_LINK_UP) {
-			if ((jiffies - slave->dev->last_rx) <=
-			    the_delta_in_ticks) {
-
-				slave->link = BOND_LINK_UP;
-				write_lock(&bond->ptrlock);
-				if ((bond->current_slave == NULL) &&
-				    ((jiffies - slave->dev->trans_start) <=
-				     the_delta_in_ticks)) {
-					bond->current_slave = slave;
-					bond_set_slave_active_flags(slave);
-			                bond_mc_update(bond, slave, NULL);
-					bond->current_arp_slave = NULL;
-				} else if (bond->current_slave != slave) {
-					/* this slave has just come up but we 
-					 * already have a current slave; this
-					 * can also happen if bond_enslave adds
-					 * a new slave that is up while we are 
-					 * searching for a new slave
-					 */
-					bond_set_slave_inactive_flags(slave);
-					bond->current_arp_slave = NULL;
-				}
-
-				if (slave == bond->current_slave) {
-					printk(KERN_INFO
-						"%s: %s is up and now the "
-						"active interface\n",
-						master->name,
-						slave->dev->name);
-				} else {
-					printk(KERN_INFO
-						"%s: backup interface %s is "
-						"now up\n",
-						master->name,
-						slave->dev->name);
-				}
-
-				write_unlock(&bond->ptrlock);
-			}
-		} else {
-			read_lock(&bond->ptrlock);
-			if ((slave != bond->current_slave) &&
-			    (bond->current_arp_slave == NULL) &&
-			    (((jiffies - slave->dev->last_rx) >=
-			     3*the_delta_in_ticks) && (my_ip != 0))) {
-				/* a backup slave has gone down; three times 
-				 * the delta allows the current slave to be 
-				 * taken out before the backup slave.
-				 * note: a non-null current_arp_slave indicates
-				 * the current_slave went down and we are 
-				 * searching for a new one; under this 
-				 * condition we only take the current_slave 
-				 * down - this gives each slave a chance to 
-				 * tx/rx traffic before being taken out
-				 */
-				read_unlock(&bond->ptrlock);
-				slave->link  = BOND_LINK_DOWN;
-				if (slave->link_failure_count < UINT_MAX) {
-					slave->link_failure_count++;
-				}
-				bond_set_slave_inactive_flags(slave);
-				printk(KERN_INFO
-					"%s: backup interface %s is now down\n",
-					master->name,
-					slave->dev->name);
-			} else {
-				read_unlock(&bond->ptrlock);
-			}
-		}
-	}
-
-	read_lock(&bond->ptrlock);
-	slave = bond->current_slave;
-	read_unlock(&bond->ptrlock);
-
-	if (slave != NULL) {
-
-		/* if we have sent traffic in the past 2*arp_intervals but
-		 * haven't xmit and rx traffic in that time interval, select 
-		 * a different slave. slave->jiffies is only updated when
-		 * a slave first becomes the current_slave - not necessarily
-		 * after every arp; this ensures the slave has a full 2*delta 
-		 * before being taken out. if a primary is being used, check 
-		 * if it is up and needs to take over as the current_slave
-		 */
-		if ((((jiffies - slave->dev->trans_start) >= 
-		       (2*the_delta_in_ticks)) ||
-		     (((jiffies - slave->dev->last_rx) >= 
-		       (2*the_delta_in_ticks)) && (my_ip != 0))) &&
-		    ((jiffies - slave->jiffies) >= 2*the_delta_in_ticks)) {
-
-			slave->link  = BOND_LINK_DOWN;
-			if (slave->link_failure_count < UINT_MAX) {
-				slave->link_failure_count++;
-			}
-			printk(KERN_INFO "%s: link status down for "
-					 "active interface %s, disabling it",
-			       master->name,
-			       slave->dev->name);
-			slave = change_active_interface(bond);
-			bond->current_arp_slave = slave;
-			if (slave != NULL) {
-				slave->jiffies = jiffies;
-			}
-
-		} else if ((bond->primary_slave != NULL) && 
-			   (bond->primary_slave != slave) && 
-			   (bond->primary_slave->link == BOND_LINK_UP)) {
-			/* at this point, slave is the current_slave */
-			printk(KERN_INFO 
-			       "%s: changing from interface %s to primary "
-			       "interface %s\n",
-			       master->name, 
-			       slave->dev->name, 
-			       bond->primary_slave->dev->name);
-			       
-			/* primary is up so switch to it */
-			bond_set_slave_inactive_flags(slave);
-			bond_mc_update(bond, bond->primary_slave, slave);
-			write_lock(&bond->ptrlock);
-			bond->current_slave = bond->primary_slave;
-			write_unlock(&bond->ptrlock);
-			slave = bond->primary_slave;
-			bond_set_slave_active_flags(slave);
-			slave->jiffies = jiffies;
-		} else {
-			bond->current_arp_slave = NULL;
-		}
-
-		/* the current slave must tx an arp to ensure backup slaves
-		 * rx traffic
-		 */
-		if ((slave != NULL) &&
-		    (((jiffies - slave->dev->last_rx) >= the_delta_in_ticks) &&
-		     (my_ip != 0))) {
-		  arp_send_all(slave);
-		}
-	}
-
-	/* if we don't have a current_slave, search for the next available 
-	 * backup slave from the current_arp_slave and make it the candidate 
-	 * for becoming the current_slave
-	 */
-	if (slave == NULL) { 
-
-		if ((bond->current_arp_slave == NULL) ||
-		    (bond->current_arp_slave == (slave_t *)bond)) {
-			bond->current_arp_slave = bond->prev;
-		} 
-
-		if (bond->current_arp_slave != (slave_t *)bond) {
-			bond_set_slave_inactive_flags(bond->current_arp_slave);
-			slave = bond->current_arp_slave->next;
-
-			/* search for next candidate */
-			do {
-				if (IS_UP(slave->dev)) {
-					slave->link = BOND_LINK_BACK;
-					bond_set_slave_active_flags(slave);
-					arp_send_all(slave);
-					slave->jiffies = jiffies;
-					bond->current_arp_slave = slave;
-					break;
-				}
-
-				/* if the link state is up at this point, we 
-				 * mark it down - this can happen if we have 
-				 * simultaneous link failures and 
-				 * change_active_interface doesn't make this 
-				 * one the current slave so it is still marked 
-				 * up when it is actually down
-				 */
-				if (slave->link == BOND_LINK_UP) {
-					slave->link  = BOND_LINK_DOWN;
-					if (slave->link_failure_count < 
-							UINT_MAX) {
-						slave->link_failure_count++;
-					}
-
-					bond_set_slave_inactive_flags(slave);
-					printk(KERN_INFO
-						"%s: backup interface "
-						"%s is now down.\n",
-						master->name,
-						slave->dev->name);
-				}
-			} while ((slave = slave->next) != 
-					bond->current_arp_slave->next);
-		}
-	}
-
-	mod_timer(&bond->arp_timer, next_timer);
-	read_unlock_irqrestore(&bond->lock, flags);
-}
-
-typedef uint32_t in_addr_t;
-
-int
-my_inet_aton(char *cp, unsigned long *the_addr) {
-	static const in_addr_t max[4] = { 0xffffffff, 0xffffff, 0xffff, 0xff };
-	in_addr_t val;
-	char c;
-	union iaddr {
-	  uint8_t bytes[4];
-	  uint32_t word;
-	} res;
-	uint8_t *pp = res.bytes;
-	int digit,base;
-
-	res.word = 0;
-
-	c = *cp;
-	for (;;) {
-		/*
-		 * Collect number up to ``.''.
-		 * Values are specified as for C:
-		 * 0x=hex, 0=octal, isdigit=decimal.
-		 */
-		if (!isdigit(c)) goto ret_0;
-		val = 0; base = 10; digit = 0;
-		for (;;) {
-			if (isdigit(c)) {
-				val = (val * base) + (c - '0');
-				c = *++cp;
-				digit = 1;
-			} else {
-				break;
-			}
-		}
-		if (c == '.') {
-			/*
-			 * Internet format:
-			 *	a.b.c.d
-			 *	a.b.c	(with c treated as 16 bits)
-			 *	a.b	(with b treated as 24 bits)
-			 */
-			if (pp > res.bytes + 2 || val > 0xff) {
-				goto ret_0;
-			}
-			*pp++ = val;
-			c = *++cp;
-		} else
-			break;
-	}
-	/*
-	 * Check for trailing characters.
-	 */
-	if (c != '\0' && (!isascii(c) || !isspace(c))) {
-		goto ret_0;
-	}
-	/*
-	 * Did we get a valid digit?
-	 */
-	if (!digit) {
-		goto ret_0;
-	}
-
-	/* Check whether the last part is in its limits depending on
-	   the number of parts in total.  */
-	if (val > max[pp - res.bytes]) {
-		goto ret_0;
-	}
-
-	if (the_addr != NULL) {
-		*the_addr = res.word | htonl (val);
-	}
-
-	return (1);
-
-ret_0:
-	return (0);
-}
-
-static int bond_sethwaddr(struct net_device *master, struct net_device *slave)
-{
-#ifdef BONDING_DEBUG
-	printk(KERN_CRIT "bond_sethwaddr: master=%x\n", (unsigned int)master);
-	printk(KERN_CRIT "bond_sethwaddr: slave=%x\n", (unsigned int)slave);
-	printk(KERN_CRIT "bond_sethwaddr: slave->addr_len=%d\n", slave->addr_len);
-#endif
-	memcpy(master->dev_addr, slave->dev_addr, slave->addr_len);
-	return 0;
-}
-
-static int bond_info_query(struct net_device *master, struct ifbond *info)
-{
-	bonding_t *bond = (struct bonding *) master->priv;
-	slave_t *slave;
-	unsigned long flags;
-
-	info->bond_mode = bond_mode;
-	info->num_slaves = 0;
-	info->miimon = miimon;
-
-	read_lock_irqsave(&bond->lock, flags);
-	for (slave = bond->prev; slave != (slave_t *)bond; slave = slave->prev) {
-		info->num_slaves++;
-	}
-	read_unlock_irqrestore(&bond->lock, flags);
-
-	return 0;
-}
-
-static int bond_slave_info_query(struct net_device *master, 
-					struct ifslave *info)
-{
-	bonding_t *bond = (struct bonding *) master->priv;
-	slave_t *slave;
-	int cur_ndx = 0;
-	unsigned long flags;
-
-	if (info->slave_id < 0) {
-		return -ENODEV;
-	}
-
-	read_lock_irqsave(&bond->lock, flags);
-	for (slave = bond->prev; 
-		 slave != (slave_t *)bond && cur_ndx < info->slave_id; 
-		 slave = slave->prev) {
-		cur_ndx++;
-	}
-	read_unlock_irqrestore(&bond->lock, flags);
-
-	if (slave != (slave_t *)bond) {
-		strcpy(info->slave_name, slave->dev->name);
-		info->link = slave->link;
-		info->state = slave->state;
-		info->link_failure_count = slave->link_failure_count;
-	} else {
-		return -ENODEV;
-	}
-
-	return 0;
-}
-
-static int bond_ioctl(struct net_device *master_dev, struct ifreq *ifr, int cmd)
-{
-	struct net_device *slave_dev = NULL;
-	struct ifbond *u_binfo = NULL, k_binfo;
-	struct ifslave *u_sinfo = NULL, k_sinfo;
-	struct mii_ioctl_data *mii = NULL;
-	int ret = 0;
-
-#ifdef BONDING_DEBUG
-	printk(KERN_INFO "bond_ioctl: master=%s, cmd=%d\n", 
-		master_dev->name, cmd);
-#endif
-
-	switch (cmd) {
-	case SIOCGMIIPHY:
-		mii = (struct mii_ioctl_data *)&ifr->ifr_data;
-		if (mii == NULL) {
-			return -EINVAL;
-		}
-		mii->phy_id = 0;
-		/* Fall Through */
-	case SIOCGMIIREG:
-		/* 
-		 * We do this again just in case we were called by SIOCGMIIREG
-		 * instead of SIOCGMIIPHY.
-		 */
-		mii = (struct mii_ioctl_data *)&ifr->ifr_data;
-		if (mii == NULL) {
-			return -EINVAL;
-		}
-		if (mii->reg_num == 1) {
-			mii->val_out = bond_check_mii_link(
-				(struct bonding *)master_dev->priv);
-		}
-		return 0;
-	case BOND_INFO_QUERY_OLD:
-	case SIOCBONDINFOQUERY:
-		u_binfo = (struct ifbond *)ifr->ifr_data;
-		if (copy_from_user(&k_binfo, u_binfo, sizeof(ifbond))) {
-			return -EFAULT;
-		}
-		ret = bond_info_query(master_dev, &k_binfo);
-		if (ret == 0) {
-			if (copy_to_user(u_binfo, &k_binfo, sizeof(ifbond))) {
-				return -EFAULT;
-			}
-		}
-		return ret;
-	case BOND_SLAVE_INFO_QUERY_OLD:
-	case SIOCBONDSLAVEINFOQUERY:
-		u_sinfo = (struct ifslave *)ifr->ifr_data;
-		if (copy_from_user(&k_sinfo, u_sinfo, sizeof(ifslave))) {
-			return -EFAULT;
-		}
-		ret = bond_slave_info_query(master_dev, &k_sinfo);
-		if (ret == 0) {
-			if (copy_to_user(u_sinfo, &k_sinfo, sizeof(ifslave))) {
-				return -EFAULT;
-			}
-		}
-		return ret;
-	}
-
-	if (!capable(CAP_NET_ADMIN)) {
-		return -EPERM;
-	}
-
-	slave_dev = dev_get_by_name(ifr->ifr_slave);
-
-#ifdef BONDING_DEBUG
-	printk(KERN_INFO "slave_dev=%x: \n", (unsigned int)slave_dev);
-	printk(KERN_INFO "slave_dev->name=%s: \n", slave_dev->name);
-#endif
-
-	if (slave_dev == NULL) {
-		ret = -ENODEV;
-	} else {
-		switch (cmd) {
-		case BOND_ENSLAVE_OLD:
-		case SIOCBONDENSLAVE:		
-			ret = bond_enslave(master_dev, slave_dev);
-			break;
-		case BOND_RELEASE_OLD:			
-		case SIOCBONDRELEASE:	
-			ret = bond_release(master_dev, slave_dev); 
-			break;
-		case BOND_SETHWADDR_OLD:
-		case SIOCBONDSETHWADDR:	
-			ret = bond_sethwaddr(master_dev, slave_dev);
-			break;
-		case BOND_CHANGE_ACTIVE_OLD:
-		case SIOCBONDCHANGEACTIVE:
-			if (bond_mode == BOND_MODE_ACTIVEBACKUP) {
-				ret = bond_change_active(master_dev, slave_dev);
-			}
-			else {
-				ret = -EINVAL;
-			}
-			break;
-		default:
-			ret = -EOPNOTSUPP;
-		}
-		dev_put(slave_dev);
-	}
-	return ret;
-}
-
-#ifdef CONFIG_NET_FASTROUTE
-static int bond_accept_fastpath(struct net_device *dev, struct dst_entry *dst)
-{
-	return -1;
-}
-#endif
-
-/* 
- * in broadcast mode, we send everything to all usable interfaces.
- */
-static int bond_xmit_broadcast(struct sk_buff *skb, struct net_device *dev)
-{
-	slave_t *slave, *start_at;
-	struct bonding *bond = (struct bonding *) dev->priv;
-	unsigned long flags;
-	struct net_device *device_we_should_send_to = 0;
-
-	if (!IS_UP(dev)) { /* bond down */
-		dev_kfree_skb(skb);
-		return 0;
-	}
-
-	read_lock_irqsave(&bond->lock, flags);
-
-	read_lock(&bond->ptrlock);
-	slave = start_at = bond->current_slave;
-	read_unlock(&bond->ptrlock);
-
-	if (slave == NULL) { /* we're at the root, get the first slave */
-		/* no suitable interface, frame not sent */
-		read_unlock_irqrestore(&bond->lock, flags);
-		dev_kfree_skb(skb);
-		return 0;
-	}
-
-	do {
-		if (IS_UP(slave->dev)
-		    && (slave->link == BOND_LINK_UP)
-		    && (slave->state == BOND_STATE_ACTIVE)) {
-			if (device_we_should_send_to) {
-				struct sk_buff *skb2;
-				if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL) {
-					printk(KERN_ERR "bond_xmit_broadcast: skb_clone() failed\n");
-					continue;
-				}
-
-				skb2->dev = device_we_should_send_to;
-				skb2->priority = 1;
-				dev_queue_xmit(skb2);
-			}
-			device_we_should_send_to = slave->dev;
-		}
-	} while ((slave = slave->next) != start_at);
-
-	if (device_we_should_send_to) {
-		skb->dev = device_we_should_send_to;
-		skb->priority = 1;
-		dev_queue_xmit(skb);
-	} else
-		dev_kfree_skb(skb);
-
-	/* frame sent to all suitable interfaces */
-	read_unlock_irqrestore(&bond->lock, flags);
-	return 0;
-}
-
-static int bond_xmit_roundrobin(struct sk_buff *skb, struct net_device *dev)
-{
-	slave_t *slave, *start_at;
-	struct bonding *bond = (struct bonding *) dev->priv;
-	unsigned long flags;
-
-	if (!IS_UP(dev)) { /* bond down */
-		dev_kfree_skb(skb);
-		return 0;
-	}
-
-	read_lock_irqsave(&bond->lock, flags);
-
-	read_lock(&bond->ptrlock);
-	slave = start_at = bond->current_slave;
-	read_unlock(&bond->ptrlock);
-
-	if (slave == NULL) { /* we're at the root, get the first slave */
-		/* no suitable interface, frame not sent */
-		dev_kfree_skb(skb);
-		read_unlock_irqrestore(&bond->lock, flags);
-		return 0;
-	}
-
-	do {
-		if (IS_UP(slave->dev)
-		    && (slave->link == BOND_LINK_UP)
-		    && (slave->state == BOND_STATE_ACTIVE)) {
-
-			skb->dev = slave->dev;
-			skb->priority = 1;
-			dev_queue_xmit(skb);
-
-			write_lock(&bond->ptrlock);
-			bond->current_slave = slave->next;
-			write_unlock(&bond->ptrlock);
-
-			read_unlock_irqrestore(&bond->lock, flags);
-			return 0;
-		}
-	} while ((slave = slave->next) != start_at);
-
-	/* no suitable interface, frame not sent */
-	dev_kfree_skb(skb);
-	read_unlock_irqrestore(&bond->lock, flags);
-	return 0;
-}
-
-/* 
- * in XOR mode, we determine the output device by performing xor on
- * the source and destination hw adresses.  If this device is not 
- * enabled, find the next slave following this xor slave. 
- */
-static int bond_xmit_xor(struct sk_buff *skb, struct net_device *dev)
-{
-	slave_t *slave, *start_at;
-	struct bonding *bond = (struct bonding *) dev->priv;
-	unsigned long flags;
-	struct ethhdr *data = (struct ethhdr *)skb->data;
-	int slave_no;
-
-	if (!IS_UP(dev)) { /* bond down */
-		dev_kfree_skb(skb);
-		return 0;
-	}
-
-	read_lock_irqsave(&bond->lock, flags);
-	slave = bond->prev;
-
-	/* we're at the root, get the first slave */
-	if (bond->slave_cnt == 0) {
-		/* no suitable interface, frame not sent */
-		dev_kfree_skb(skb);
-		read_unlock_irqrestore(&bond->lock, flags);
-		return 0;
-	}
-
-	slave_no = (data->h_dest[5]^slave->dev->dev_addr[5]) % bond->slave_cnt;
-
-	while ( (slave_no > 0) && (slave != (slave_t *)bond) ) {
-		slave = slave->prev;
-		slave_no--;
-	} 
-	start_at = slave;
-
-	do {
-		if (IS_UP(slave->dev)
-		    && (slave->link == BOND_LINK_UP)
-		    && (slave->state == BOND_STATE_ACTIVE)) {
-
-			skb->dev = slave->dev;
-			skb->priority = 1;
-			dev_queue_xmit(skb);
-
-			read_unlock_irqrestore(&bond->lock, flags);
-			return 0;
-		}
-	} while ((slave = slave->next) != start_at);
-
-	/* no suitable interface, frame not sent */
-	dev_kfree_skb(skb);
-	read_unlock_irqrestore(&bond->lock, flags);
-	return 0;
-}
-
-/* 
- * in active-backup mode, we know that bond->current_slave is always valid if
- * the bond has a usable interface.
- */
-static int bond_xmit_activebackup(struct sk_buff *skb, struct net_device *dev)
-{
-	struct bonding *bond = (struct bonding *) dev->priv;
-	unsigned long flags;
-	int ret;
-
-	if (!IS_UP(dev)) { /* bond down */
-		dev_kfree_skb(skb);
-		return 0;
-	}
-
-	/* if we are sending arp packets, try to at least 
-	   identify our own ip address */
-	if ( (arp_interval > 0) && (my_ip == 0) &&
-		(skb->protocol == __constant_htons(ETH_P_ARP) ) ) {
-		char *the_ip = (((char *)skb->data)) 
-				+ sizeof(struct ethhdr)  
-				+ sizeof(struct arphdr) + 
-				ETH_ALEN;
-		memcpy(&my_ip, the_ip, 4);
-	}
-
-	/* if we are sending arp packets and don't know 
-	 * the target hw address, save it so we don't need 
-	 * to use a broadcast address.
-	 * don't do this if in active backup mode because the slaves must 
-	 * receive packets to stay up, and the only ones they receive are 
-	 * broadcasts. 
-	 */
-	if ( (bond_mode != BOND_MODE_ACTIVEBACKUP) && 
-             (arp_ip_count == 1) &&
-	     (arp_interval > 0) && (arp_target_hw_addr == NULL) &&
-	     (skb->protocol == __constant_htons(ETH_P_IP) ) ) {
-		struct ethhdr *eth_hdr = 
-			(struct ethhdr *) (((char *)skb->data));
-		struct iphdr *ip_hdr = (struct iphdr *)(eth_hdr + 1);
-
-		if (arp_target[0] == ip_hdr->daddr) {
-			arp_target_hw_addr = kmalloc(ETH_ALEN, GFP_KERNEL);
-			if (arp_target_hw_addr != NULL)
-				memcpy(arp_target_hw_addr, eth_hdr->h_dest, ETH_ALEN);
-		}
-	}
-
-	read_lock_irqsave(&bond->lock, flags);
-
-	read_lock(&bond->ptrlock);
-	if (bond->current_slave != NULL) { /* one usable interface */
-		skb->dev = bond->current_slave->dev;
-		read_unlock(&bond->ptrlock);
-		skb->priority = 1;
-		ret = dev_queue_xmit(skb);
-		read_unlock_irqrestore(&bond->lock, flags);
-		return 0;
-	}
-	else {
-		read_unlock(&bond->ptrlock);
-	}
-
-	/* no suitable interface, frame not sent */
-#ifdef BONDING_DEBUG
-	printk(KERN_INFO "There was no suitable interface, so we don't transmit\n");
-#endif
-	dev_kfree_skb(skb);
-	read_unlock_irqrestore(&bond->lock, flags);
-	return 0;
-}
-
-static struct net_device_stats *bond_get_stats(struct net_device *dev)
-{
-	bonding_t *bond = dev->priv;
-	struct net_device_stats *stats = bond->stats, *sstats;
-	slave_t *slave;
-	unsigned long flags;
-
-	memset(bond->stats, 0, sizeof(struct net_device_stats));
-
-	read_lock_irqsave(&bond->lock, flags);
-
-	for (slave = bond->prev; slave != (slave_t *)bond; slave = slave->prev) {
-		sstats = slave->dev->get_stats(slave->dev);
- 
-		stats->rx_packets += sstats->rx_packets;
-		stats->rx_bytes += sstats->rx_bytes;
-		stats->rx_errors += sstats->rx_errors;
-		stats->rx_dropped += sstats->rx_dropped;
-
-		stats->tx_packets += sstats->tx_packets;
-		stats->tx_bytes += sstats->tx_bytes;
-		stats->tx_errors += sstats->tx_errors;
-		stats->tx_dropped += sstats->tx_dropped;
-
-		stats->multicast += sstats->multicast;
-		stats->collisions += sstats->collisions;
-
-		stats->rx_length_errors += sstats->rx_length_errors;
-		stats->rx_over_errors += sstats->rx_over_errors;
-		stats->rx_crc_errors += sstats->rx_crc_errors;
-		stats->rx_frame_errors += sstats->rx_frame_errors;
-		stats->rx_fifo_errors += sstats->rx_fifo_errors;	
-		stats->rx_missed_errors += sstats->rx_missed_errors;
-	
-		stats->tx_aborted_errors += sstats->tx_aborted_errors;
-		stats->tx_carrier_errors += sstats->tx_carrier_errors;
-		stats->tx_fifo_errors += sstats->tx_fifo_errors;
-		stats->tx_heartbeat_errors += sstats->tx_heartbeat_errors;
-		stats->tx_window_errors += sstats->tx_window_errors;
-
-	}
-
-	read_unlock_irqrestore(&bond->lock, flags);
-	return stats;
-}
-
-static int bond_get_info(char *buf, char **start, off_t offset, int length)
-{
-	bonding_t *bond = these_bonds;
-	int len = 0;
-	off_t begin = 0;
-	u16 link;
-	slave_t *slave = NULL;
-	unsigned long flags;
-
-	while (bond != NULL) {
-		/*
-		 * This function locks the mutex, so we can't lock it until 
-		 * afterwards
-		 */
-		link = bond_check_mii_link(bond);
-
-		len += sprintf(buf + len, "Bonding Mode: %s\n",
-			       bond_mode_name());
-
-		if (bond_mode == BOND_MODE_ACTIVEBACKUP) {
-			read_lock_irqsave(&bond->lock, flags);
-			read_lock(&bond->ptrlock);
-			if (bond->current_slave != NULL) {
-				len += sprintf(buf + len, 
-					"Currently Active Slave: %s\n", 
-					bond->current_slave->dev->name);
-			}
-			read_unlock(&bond->ptrlock);
-			read_unlock_irqrestore(&bond->lock, flags);
-		}
-
-		len += sprintf(buf + len, "MII Status: ");
-		len += sprintf(buf + len, 
-				link == BMSR_LSTATUS ? "up\n" : "down\n");
-		len += sprintf(buf + len, "MII Polling Interval (ms): %d\n", 
-				miimon);
-		len += sprintf(buf + len, "Up Delay (ms): %d\n", 
-				updelay * miimon);
-		len += sprintf(buf + len, "Down Delay (ms): %d\n", 
-				downdelay * miimon);
-		len += sprintf(buf + len, "Multicast Mode: %s\n",
-			       multicast_mode_name());
-
-		read_lock_irqsave(&bond->lock, flags);
-		for (slave = bond->prev; slave != (slave_t *)bond; 
-		     slave = slave->prev) {
-			len += sprintf(buf + len, "\nSlave Interface: %s\n", slave->dev->name);
-
-			len += sprintf(buf + len, "MII Status: ");
-
-			len += sprintf(buf + len, 
-				slave->link == BOND_LINK_UP ? 
-				"up\n" : "down\n");
-			len += sprintf(buf + len, "Link Failure Count: %d\n", 
-				slave->link_failure_count);
-		}
-		read_unlock_irqrestore(&bond->lock, flags);
-
-		/*
-		 * Figure out the calcs for the /proc/net interface
-		 */
-		*start = buf + (offset - begin);
-		len -= (offset - begin);
-		if (len > length) {
-			len = length;
-		}
-		if (len < 0) {
-			len = 0;
-		}
-
-
-		bond = bond->next_bond;
-	}
-	return len;
-}
-
-static int bond_event(struct notifier_block *this, unsigned long event, 
-			void *ptr)
-{
-	struct bonding *this_bond = (struct bonding *)these_bonds;
-	struct bonding *last_bond;
-	struct net_device *event_dev = (struct net_device *)ptr;
-
-	/* while there are bonds configured */
-	while (this_bond != NULL) {
-		if (this_bond == event_dev->priv ) {
-			switch (event) {
-			case NETDEV_UNREGISTER:
-				/* 
-				 * remove this bond from a linked list of 
-				 * bonds 
-				 */
-				if (this_bond == these_bonds) {
-					these_bonds = this_bond->next_bond;
-				} else {
-					for (last_bond = these_bonds; 
-					     last_bond != NULL; 
-					     last_bond = last_bond->next_bond) {
-						if (last_bond->next_bond == 
-						    this_bond) {
-							last_bond->next_bond = 
-							this_bond->next_bond;
-						}
-					}
-				}
-				return NOTIFY_DONE;
-
-			default:
-				return NOTIFY_DONE;
-			}
-		} else if (this_bond->device == event_dev->master) {
-			switch (event) {
-			case NETDEV_UNREGISTER:
-				bond_release(this_bond->device, event_dev);
-				break;
-			}
-			return NOTIFY_DONE;
-		}
-		this_bond = this_bond->next_bond;
-	}
-	return NOTIFY_DONE;
-}
-
-static struct notifier_block bond_netdev_notifier = {
-	notifier_call: bond_event,
-};
-
-static int __init bond_init(struct net_device *dev)
-{
-	bonding_t *bond, *this_bond, *last_bond;
-	int count;
-
-#ifdef BONDING_DEBUG
-	printk (KERN_INFO "Begin bond_init for %s\n", dev->name);
-#endif
-	bond = kmalloc(sizeof(struct bonding), GFP_KERNEL);
-	if (bond == NULL) {
-		return -ENOMEM;
-	}
-	memset(bond, 0, sizeof(struct bonding));
-
-	/* initialize rwlocks */
-	rwlock_init(&bond->lock);
-	rwlock_init(&bond->ptrlock);
-	
-	bond->stats = kmalloc(sizeof(struct net_device_stats), GFP_KERNEL);
-	if (bond->stats == NULL) {
-		kfree(bond);
-		return -ENOMEM;
-	}
-	memset(bond->stats, 0, sizeof(struct net_device_stats));
-
-	bond->next = bond->prev = (slave_t *)bond;
-	bond->current_slave = NULL;
-	bond->current_arp_slave = NULL;
-	bond->device = dev;
-	dev->priv = bond;
-
-	/* Initialize the device structure. */
-	switch (bond_mode) {
-	case BOND_MODE_ACTIVEBACKUP:
-		dev->hard_start_xmit = bond_xmit_activebackup;
-		break;
-	case BOND_MODE_ROUNDROBIN:
-		dev->hard_start_xmit = bond_xmit_roundrobin;
-		break;
-	case BOND_MODE_XOR:
-		dev->hard_start_xmit = bond_xmit_xor;
-		break;
-	case BOND_MODE_BROADCAST:
-		dev->hard_start_xmit = bond_xmit_broadcast;
-		break;
-	default:
-		printk(KERN_ERR "Unknown bonding mode %d\n", bond_mode);
-		kfree(bond->stats);
-		kfree(bond);
-		return -EINVAL;
-	}
-
-	dev->get_stats = bond_get_stats;
-	dev->open = bond_open;
-	dev->stop = bond_close;
-	dev->set_multicast_list = set_multicast_list;
-	dev->do_ioctl = bond_ioctl;
-
-	/* 
-	 * Fill in the fields of the device structure with ethernet-generic 
-	 * values. 
-	 */
-
-	ether_setup(dev);
-
-	dev->tx_queue_len = 0;
-	dev->flags |= IFF_MASTER|IFF_MULTICAST;
-#ifdef CONFIG_NET_FASTROUTE
-	dev->accept_fastpath = bond_accept_fastpath;
-#endif
-
-	printk(KERN_INFO "%s registered with", dev->name);
-	if (miimon > 0) {
-		printk(" MII link monitoring set to %d ms", miimon);
-		updelay /= miimon;
-		downdelay /= miimon;
-	} else {
-		printk("out MII link monitoring");
-	}
-	printk(", in %s mode.\n", bond_mode_name());
-
-	printk(KERN_INFO "%s registered with", dev->name);
-	if (arp_interval > 0) {
-		printk(" ARP monitoring set to %d ms with %d target(s):", 
-			arp_interval, arp_ip_count);
-		for (count=0 ; count<arp_ip_count ; count++)
-                        printk (" %s", arp_ip_target[count]);
-		printk("\n");
-	} else {
-		printk("out ARP monitoring\n");
-	}
-
-#ifdef CONFIG_PROC_FS
-	bond->bond_proc_dir = proc_mkdir(dev->name, proc_net);
-	if (bond->bond_proc_dir == NULL) {
-		printk(KERN_ERR "%s: Cannot init /proc/net/%s/\n", 
-			dev->name, dev->name);
-		kfree(bond->stats);
-		kfree(bond);
-		return -ENOMEM;
-	}
-	bond->bond_proc_info_file = 
-		create_proc_info_entry("info", 0, bond->bond_proc_dir, 
-					bond_get_info);
-	if (bond->bond_proc_info_file == NULL) {
-		printk(KERN_ERR "%s: Cannot init /proc/net/%s/info\n", 
-			dev->name, dev->name);
-		remove_proc_entry(dev->name, proc_net);
-		kfree(bond->stats);
-		kfree(bond);
-		return -ENOMEM;
-	}
-#endif /* CONFIG_PROC_FS */
-
-	if (first_pass == 1) {
-		these_bonds = bond;
-		register_netdevice_notifier(&bond_netdev_notifier);
-		first_pass = 0;
-	} else {
-		last_bond = these_bonds;
-		this_bond = these_bonds->next_bond;
-		while (this_bond != NULL) {
-			last_bond = this_bond;
-			this_bond = this_bond->next_bond;
-		}
-		last_bond->next_bond = bond;
-	} 
-
-	return 0;
-}
-
-/*
-static int __init bond_probe(struct net_device *dev)
-{
-	bond_init(dev);
-	return 0;
-}
- */
-
-/*
- * Convert string input module parms.  Accept either the
- * number of the mode or its string name.
- */
-static inline int
-bond_parse_parm(char *mode_arg, struct bond_parm_tbl *tbl)
-{
-	int i;
-
-	for (i = 0; tbl[i].modename != NULL; i++) {
-		if ((isdigit(*mode_arg) &&
-		    tbl[i].mode == simple_strtol(mode_arg, NULL, 0)) ||
-		    (0 == strncmp(mode_arg, tbl[i].modename,
-				  strlen(tbl[i].modename)))) {
-			return tbl[i].mode;
-		}
-	}
-
-	return -1;
-}
-
-
-static int __init bonding_init(void)
-{
-	int no;
-	int err;
-
-	/* Find a name for this unit */
-	static struct net_device *dev_bond = NULL;
-
-	printk(KERN_INFO "%s", version);
-
-	/*
-	 * Convert string parameters.
-	 */
-	if (mode) {
-		bond_mode = bond_parse_parm(mode, bond_mode_tbl);
-		if (bond_mode == -1) {
-			printk(KERN_WARNING
-			       "bonding_init(): Invalid bonding mode \"%s\"\n",
-			       mode == NULL ? "NULL" : mode);
-			return -EINVAL;
-		}
-	}
-
-	if (multicast) {
-		multicast_mode = bond_parse_parm(multicast, bond_mc_tbl);
-		if (multicast_mode == -1) {
-			printk(KERN_WARNING 
-		       "bonding_init(): Invalid multicast mode \"%s\"\n",
-			       multicast == NULL ? "NULL" : multicast);
-			return -EINVAL;
-		}
-	}
-
-	if (max_bonds < 1 || max_bonds > INT_MAX) {
-		printk(KERN_WARNING 
-		       "bonding_init(): max_bonds (%d) not in range %d-%d, "
-		       "so it was reset to BOND_DEFAULT_MAX_BONDS (%d)",
-		       max_bonds, 1, INT_MAX, BOND_DEFAULT_MAX_BONDS);
-		max_bonds = BOND_DEFAULT_MAX_BONDS;
-	}
-	dev_bond = dev_bonds = kmalloc(max_bonds*sizeof(struct net_device), 
-					GFP_KERNEL);
-	if (dev_bond == NULL) {
-		return -ENOMEM;
-	}
-	memset(dev_bonds, 0, max_bonds*sizeof(struct net_device));
-
-	if (miimon < 0) {
-		printk(KERN_WARNING 
-		       "bonding_init(): miimon module parameter (%d), "
-		       "not in range 0-%d, so it was reset to %d\n",
-		       miimon, INT_MAX, BOND_LINK_MON_INTERV);
-		miimon = BOND_LINK_MON_INTERV;
-	}
-
-	if (updelay < 0) {
-		printk(KERN_WARNING 
-		       "bonding_init(): updelay module parameter (%d), "
-		       "not in range 0-%d, so it was reset to 0\n",
-		       updelay, INT_MAX);
-		updelay = 0;
-	}
-
-	if (downdelay < 0) {
-		printk(KERN_WARNING 
-		       "bonding_init(): downdelay module parameter (%d), "
-		       "not in range 0-%d, so it was reset to 0\n",
-		       downdelay, INT_MAX);
-		downdelay = 0;
-	}
-
-	if (miimon == 0) {
-		if ((updelay != 0) || (downdelay != 0)) {
-			/* just warn the user the up/down delay will have
-			 * no effect since miimon is zero...
-			 */
-			printk(KERN_WARNING 
-		               "bonding_init(): miimon module parameter not "
-			       "set and updelay (%d) or downdelay (%d) module "
-			       "parameter is set; updelay and downdelay have "
-			       "no effect unless miimon is set\n",
-		               updelay, downdelay);
-		}
-	} else {
-		/* don't allow arp monitoring */
-		if (arp_interval != 0) {
-			printk(KERN_WARNING 
-		               "bonding_init(): miimon (%d) and arp_interval "
-			       "(%d) can't be used simultaneously, "
-			       "disabling ARP monitoring\n",
-		               miimon, arp_interval);
-			arp_interval = 0;
-		}
-
-		if ((updelay % miimon) != 0) {
-			/* updelay will be rounded in bond_init() when it
-			 * is divided by miimon, we just inform user here
-			 */
-			printk(KERN_WARNING 
-		               "bonding_init(): updelay (%d) is not a multiple "
-			       "of miimon (%d), updelay rounded to %d ms\n",
-		               updelay, miimon, (updelay / miimon) * miimon);
-		}
-
-		if ((downdelay % miimon) != 0) {
-			/* downdelay will be rounded in bond_init() when it
-			 * is divided by miimon, we just inform user here
-			 */
-			printk(KERN_WARNING 
-		               "bonding_init(): downdelay (%d) is not a "
-			       "multiple of miimon (%d), downdelay rounded "
-			       "to %d ms\n",
-		               downdelay, miimon, 
-			       (downdelay / miimon) * miimon);
-		}
-	}
-
-	if (arp_interval < 0) {
-		printk(KERN_WARNING 
-		       "bonding_init(): arp_interval module parameter (%d), "
-		       "not in range 0-%d, so it was reset to %d\n",
-		       arp_interval, INT_MAX, BOND_LINK_ARP_INTERV);
-		arp_interval = BOND_LINK_ARP_INTERV;
-	}
-
-        for (arp_ip_count=0 ;
-             (arp_ip_count < MAX_ARP_IP_TARGETS) && arp_ip_target[arp_ip_count];
-              arp_ip_count++ ) {
-                /* TODO: check and log bad ip address */
-                if (my_inet_aton(arp_ip_target[arp_ip_count],
-                                 &arp_target[arp_ip_count]) == 0) {
-                        printk(KERN_WARNING
-                               "bonding_init(): bad arp_ip_target module "
-                               "parameter (%s), ARP monitoring will not be "
-                               "performed\n",
-                               arp_ip_target[arp_ip_count]);
-                        arp_interval = 0;
-		}
-        }
-
-
-	if ( (arp_interval > 0) && (arp_ip_count==0)) {
-		/* don't allow arping if no arp_ip_target given... */
-		printk(KERN_WARNING 
-		       "bonding_init(): arp_interval module parameter "
-		       "(%d) specified without providing an arp_ip_target "
-		       "parameter, arp_interval was reset to 0\n",
-		       arp_interval);
-		arp_interval = 0;
-	}
-
-	if ((miimon == 0) && (arp_interval == 0)) {
-		/* miimon and arp_interval not set, we need one so things
-		 * work as expected, see bonding.txt for details
-		 */
-		printk(KERN_ERR 
-		       "bonding_init(): either miimon or "
-		       "arp_interval and arp_ip_target module parameters "
-		       "must be specified, otherwise bonding will not detect "
-		       "link failures! see bonding.txt for details.\n");
-	}
-
-	if ((primary != NULL) && (bond_mode != BOND_MODE_ACTIVEBACKUP)){
-		/* currently, using a primary only makes sence 
-		 * in active backup mode 
-		 */
-		printk(KERN_WARNING 
-		       "bonding_init(): %s primary device specified but has "
-		       " no effect in %s mode\n",
-		       primary, bond_mode_name());
-		primary = NULL;
-	}
-
-
-	for (no = 0; no < max_bonds; no++) {
-		dev_bond->init = bond_init;
-	
-		err = dev_alloc_name(dev_bond,"bond%d");
-		if (err < 0) {
-			kfree(dev_bonds);
-			return err;
-		}
-		SET_MODULE_OWNER(dev_bond);
-		if (register_netdev(dev_bond) != 0) {
-			kfree(dev_bonds);
-			return -EIO;
-		}	
-		dev_bond++;
-	}
-	return 0;
-}
-
-static void __exit bonding_exit(void)
-{
-	struct net_device *dev_bond = dev_bonds;
-	struct bonding *bond;
-	int no;
-
-	unregister_netdevice_notifier(&bond_netdev_notifier);
-		 
-	for (no = 0; no < max_bonds; no++) {
-
-#ifdef CONFIG_PROC_FS
-		bond = (struct bonding *) dev_bond->priv;
-		remove_proc_entry("info", bond->bond_proc_dir);
-		remove_proc_entry(dev_bond->name, proc_net);
-#endif
-		unregister_netdev(dev_bond);
-		kfree(bond->stats);
-		kfree(dev_bond->priv);
-		
-		dev_bond->priv = NULL;
-		dev_bond++;
-	}
-	kfree(dev_bonds);
-}
-
-module_init(bonding_init);
-module_exit(bonding_exit);
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION(DRV_DESCRIPTION ", v" DRV_VERSION);
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- *  tab-width: 8
- * End:
- */
diff -urNp linux-8120/include/linux/if_bonding.h linux-8121/include/linux/if_bonding.h
--- linux-8120/include/linux/if_bonding.h
+++ linux-8121/include/linux/if_bonding.h
@@ -11,18 +11,38 @@
  *	This software may be used and distributed according to the terms
  *	of the GNU Public License, incorporated herein by reference.
  * 
+ * 2003/03/18 - Amir Noam <amir.noam at intel dot com>
+ *	- Added support for getting slave's speed and duplex via ethtool.
+ *	  Needed for 802.3ad and other future modes.
+ * 
+ * 2003/03/18 - Tsippy Mendelson <tsippy.mendelson at intel dot com> and
+ *		Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Enable support of modes that need to use the unique mac address of
+ *	  each slave.
+ *
+ * 2003/03/18 - Tsippy Mendelson <tsippy.mendelson at intel dot com> and
+ *		Amir Noam <amir.noam at intel dot com>
+ *	- Moved driver's private data types to bonding.h
+ *
+ * 2003/03/18 - Amir Noam <amir.noam at intel dot com>,
+ *		Tsippy Mendelson <tsippy.mendelson at intel dot com> and
+ *		Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Added support for IEEE 802.3ad Dynamic link aggregation mode.
+ *
+ * 2003/05/01 - Amir Noam <amir.noam at intel dot com>
+ *	- Added ABI version control to restore compatibility between
+ *	  new/old ifenslave and new/old bonding.
  */
 
 #ifndef _LINUX_IF_BONDING_H
 #define _LINUX_IF_BONDING_H
 
-#ifdef __KERNEL__
-#include <linux/timer.h>
 #include <linux/if.h>
-#include <linux/proc_fs.h>
-#endif /* __KERNEL__ */
-
 #include <linux/types.h>
+#include <linux/if_ether.h>
+
+/* userland - kernel ABI version (2003/05/08) */
+#define BOND_ABI_VERSION 1
 
 /*
  * We can remove these ioctl definitions in 2.5.  People should use the
@@ -41,6 +61,9 @@
 #define BOND_MODE_ACTIVEBACKUP	1
 #define BOND_MODE_XOR		2
 #define BOND_MODE_BROADCAST	3
+#define BOND_MODE_8023AD        4
+#define BOND_MODE_TLB           5
+#define BOND_MODE_ALB		6 /* TLB + RLB (receive load balancing) */
 
 /* each slave's link has 4 states */
 #define BOND_LINK_UP    0           /* link is up and running */
@@ -58,11 +81,6 @@
 #define BOND_MULTICAST_ACTIVE   1
 #define BOND_MULTICAST_ALL      2
 
-struct bond_parm_tbl {
-	char *modename;
-	int mode;
-};
-
 typedef struct ifbond {
 	__s32 bond_mode;
 	__s32 num_slaves;
@@ -78,52 +96,15 @@ typedef struct ifslave
 	__u32  link_failure_count;
 } ifslave;
 
-#ifdef __KERNEL__
-typedef struct slave {
-	struct slave *next;
-	struct slave *prev;
-	struct net_device *dev;
-	short  delay;
-	unsigned long jiffies;	
-	char   link;    /* one of BOND_LINK_XXXX */
-	char   state;   /* one of BOND_STATE_XXXX */
-	unsigned short original_flags;
-	u32 link_failure_count;
-} slave_t;
-
-/*
- * Here are the locking policies for the two bonding locks:
- *
- * 1) Get bond->lock when reading/writing slave list.
- * 2) Get bond->ptrlock when reading/writing bond->current_slave.
- *    (It is unnecessary when the write-lock is put with bond->lock.)
- * 3) When we lock with bond->ptrlock, we must lock with bond->lock
- *    beforehand.
- */
-typedef struct bonding {
-	slave_t *next;
-	slave_t *prev;
-	slave_t *current_slave;
-	slave_t *primary_slave;
-	slave_t *current_arp_slave;
-	__s32 slave_cnt;
-	rwlock_t lock;
-	rwlock_t ptrlock;
-	struct timer_list mii_timer;
-	struct timer_list arp_timer;
-	struct net_device_stats *stats;
-#ifdef CONFIG_PROC_FS
-	struct proc_dir_entry *bond_proc_dir;
-	struct proc_dir_entry *bond_proc_info_file;
-#endif /* CONFIG_PROC_FS */
-	struct bonding *next_bond;
-	struct net_device *device;
-	struct dev_mc_list *mc_list;
-	unsigned short flags;
-} bonding_t;
-#endif /* __KERNEL__ */
+struct ad_info {
+	__u16 aggregator_id;
+	__u16 ports;
+	__u16 actor_key;
+	__u16 partner_key;
+	__u8 partner_system[ETH_ALEN];
+};
 
-#endif /* _LINUX_BOND_H */
+#endif /* _LINUX_IF_BONDING_H */
 
 /*
  * Local variables:
diff -urNp linux-8120/include/linux/igmp.h linux-8121/include/linux/igmp.h
--- linux-8120/include/linux/igmp.h
+++ linux-8121/include/linux/igmp.h
@@ -211,5 +211,7 @@ extern void ip_mc_up(struct in_device *)
 extern void ip_mc_down(struct in_device *);
 extern void ip_mc_dec_group(struct in_device *in_dev, u32 addr);
 extern void ip_mc_inc_group(struct in_device *in_dev, u32 addr);
+extern void ip_mc_rejoin_group(struct ip_mc_list *im);
+
 #endif
 #endif
diff -urNp linux-8120/net/ipv4/igmp.c linux-8121/net/ipv4/igmp.c
--- linux-8120/net/ipv4/igmp.c
+++ linux-8121/net/ipv4/igmp.c
@@ -1167,6 +1167,28 @@ out:
 }
 
 /*
+ *	Resend IGMP JOIN report; used for bonding.
+ */
+void ip_mc_rejoin_group(struct ip_mc_list *im)
+{
+	struct in_device *in_dev = im->interface;
+
+#ifdef CONFIG_IP_MULTICAST
+	if (im->multiaddr == IGMP_ALL_HOSTS)
+		return;
+
+	if (IGMP_V1_SEEN(in_dev) || IGMP_V2_SEEN(in_dev)) {
+		igmp_mod_timer(im, IGMP_Initial_Report_Delay);
+		return;
+	}
+	/* else, v3 */
+	im->crcount = in_dev->mr_qrv ? in_dev->mr_qrv :
+		IGMP_Unsolicited_Report_Count;
+	igmp_ifc_event(in_dev);
+#endif
+}
+
+/*
  *	A socket has left a multicast group on device dev
  */
 
diff -urNp linux-8120/net/netsyms.c linux-8121/net/netsyms.c
--- linux-8120/net/netsyms.c
+++ linux-8121/net/netsyms.c
@@ -274,6 +274,7 @@ EXPORT_SYMBOL(in_aton);
 EXPORT_SYMBOL(ip_mc_inc_group);
 EXPORT_SYMBOL(ip_mc_dec_group);
 EXPORT_SYMBOL(ip_mc_join_group);
+EXPORT_SYMBOL(ip_mc_rejoin_group);
 EXPORT_SYMBOL(ip_finish_output);
 EXPORT_SYMBOL(inet_stream_ops);
 EXPORT_SYMBOL(inet_dgram_ops);
