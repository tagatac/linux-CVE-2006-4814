diff -urNp linux-7140/arch/s390/config.in linux-7150/arch/s390/config.in
--- linux-7140/arch/s390/config.in
+++ linux-7150/arch/s390/config.in
@@ -55,6 +55,10 @@ tristate 'Kernel support for MISC binari
 bool 'Show crashed user process info' CONFIG_PROCESS_DEBUG
 bool 'Pseudo page fault support' CONFIG_PFAULT
 bool 'VM shared kernel support' CONFIG_SHARED_KERNEL
+bool 'No HZ timer ticks in idle' CONFIG_NO_IDLE_HZ
+if [ "$CONFIG_NO_IDLE_HZ" = "y" ] ; then
+  bool '  Idle HZ timer on by default' CONFIG_NO_IDLE_HZ_INIT
+fi
 endmenu
 
 source drivers/s390/Config.in
diff -urNp linux-7140/arch/s390/kernel/entry.S linux-7150/arch/s390/kernel/entry.S
--- linux-7140/arch/s390/kernel/entry.S
+++ linux-7150/arch/s390/kernel/entry.S
@@ -715,6 +715,7 @@ pgm_tracesys:
 io_int_handler:
 	SAVE_ALL_BASE
         SAVE_ALL __LC_IO_OLD_PSW,0
+	mc	0,0
         GET_CURRENT               # load pointer to task_struct to R9
         l       %r1,BASED(.Ldo_IRQ)        # load address of do_IRQ
         la      %r2,SP_PTREGS(%r15) # address of register-save area
@@ -783,6 +784,7 @@ io_signal_return:     
 ext_int_handler:
 	SAVE_ALL_BASE
         SAVE_ALL __LC_EXT_OLD_PSW,0
+	mc	0,0
         GET_CURRENT                    # load pointer to task_struct to R9
 	lh	%r6,__LC_EXT_INT_CODE  # get interruption code
 	lr	%r1,%r6		       # calculate index = code & 0xff
@@ -795,7 +797,8 @@ ext_int_handler:
 ext_int_loop:
 	ch	%r6,8(%r7)	       # compare external interrupt code
 	bne	BASED(ext_int_next)
-	l	%r1,4(%r7)	       # get handler address
+	icm	%r1,15,4(%r7)	       # get handler address
+	bz	BASED(ext_int_next)
 	la	%r2,SP_PTREGS(%r15)    # address of register-save area
 	lr	%r3,%r6		       # interruption code
 	basr	%r14,%r1	       # call handler
@@ -812,6 +815,7 @@ ext_int_next:
 mcck_int_handler:
 	SAVE_ALL_BASE
         SAVE_ALL __LC_MCK_OLD_PSW,0
+	mc	0,0
 	l       %r1,BASED(.Ls390_mcck)
 	basr    %r14,%r1	  # call machine check handler
 mcck_return:
diff -urNp linux-7140/arch/s390/kernel/process.c linux-7150/arch/s390/kernel/process.c
--- linux-7140/arch/s390/kernel/process.c
+++ linux-7150/arch/s390/kernel/process.c
@@ -56,15 +56,21 @@ int cpu_idle(void)
 	unsigned long reg;
 
 	while (1) {
+		__cli();
 		if (current->need_resched) {
+			__sti();
 			schedule();
 			check_pgt_cache();
 			continue;
 		}
 
+#ifdef CONFIG_NO_IDLE_HZ
+		stop_hz_timer();
+#endif
+
 		/* 
 		 * Wait for external, I/O or machine check interrupt and
-		 * switch of machine check bit after the wait has ended.
+		 * switch off machine check bit after the wait has ended.
 		 */
 		wait_psw.mask = _WAIT_PSW_MASK;
 		asm volatile (
@@ -80,6 +86,10 @@ int cpu_idle(void)
 			"    lpsw 0(%1)\n"
 			"2:"
 			: "=&a" (reg) : "a" (&wait_psw) : "memory", "cc" );
+		/*
+		 * start_hz_timer is called by monitor call in entry.S
+		 * if stop_hz_timer switched off the regular HZ interrupts
+		 */
 	}
 }
 
diff -urNp linux-7140/arch/s390/kernel/time.c linux-7150/arch/s390/kernel/time.c
--- linux-7140/arch/s390/kernel/time.c
+++ linux-7150/arch/s390/kernel/time.c
@@ -35,16 +35,33 @@
 #include <asm/irq.h>
 
 /* change this if you have some constant time drift */
-#define USECS_PER_JIFFY     ((unsigned long) 1000000/HZ)
 #define CLK_TICKS_PER_JIFFY ((unsigned long) USECS_PER_JIFFY << 12)
 
+/*
+ * Create a small time difference between the timer interrupts
+ * on the different cpus to avoid lock contention.
+ */
+#define USECS_PER_JIFFY     ((unsigned long) 1000000/HZ)
+#define CPU_DEVIATION       (smp_processor_id() << 12)
+
 #define TICK_SIZE tick
 
 static ext_int_info_t ext_int_info_timer;
-static uint64_t init_timer_cc;
+static u64 init_timer_cc;
+static u64 xtime_cc;
 
 extern unsigned long wall_jiffies;
 
+#ifdef CONFIG_NO_IDLE_HZ
+
+#ifdef CONFIG_NO_IDLE_HZ_INIT
+int sysctl_hz_timer = 0;
+#else
+int sysctl_hz_timer = 1;
+#endif
+
+#endif
+
 void tod_to_timeval(__u64 todval, struct timeval *xtime)
 {
         const int high_bit = 0x80000000L;
@@ -83,7 +100,7 @@ static inline unsigned long do_gettimeof
 {
 	__u64 now;
 
-	asm ("STCK 0(%0)" : : "a" (&now) : "memory", "cc");
+	asm volatile ("STCK 0(%0)" : : "a" (&now) : "memory", "cc");
         now = (now - init_timer_cc) >> 12;
 	/* We require the offset from the latest update of xtime */
 	now -= (__u64) wall_jiffies*USECS_PER_JIFFY;
@@ -185,39 +202,85 @@ static inline void s390_do_profile(struc
 #define s390_do_profile(regs)  do { ; } while(0)
 #endif /* CONFIG_PROFILING */
 
+static inline __u32 div64_32(__u64 dividend, __u32 divisor)
+{
+	register_pair rp;
+
+	rp.pair = dividend;
+	asm ("dr %0,%1" : "+d" (rp) : "d" (divisor));
+	return rp.subreg.odd;
+}
+
 /*
  * timer_interrupt() needs to keep up the real-time clock,
  * as well as call the "do_timer()" routine every clocktick
  */
-
-#ifdef CONFIG_SMP
-extern __u16 boot_cpu_addr;
-#endif
-
 static void do_comparator_interrupt(struct pt_regs *regs, __u16 error_code)
 {
 	int cpu = smp_processor_id();
-
-	irq_enter(cpu, 0);
+	u64 tmp;
+	u32 ticks;
 
 	/*
-	 * set clock comparator for next tick
+	 * Calculate how many ticks have passed.
+	 *
+	 * This segment uses STCK as the 2.4.19 IBM stream did.
+	 * The reset is taken from the RHEL patch by Jan Gauber,
+	 * with additional case against fixpoint division fault (on boot)
+	 * by Martin Schwidefsky (if delta<0 return). XXX Wrapping?
 	 */
-        S390_lowcore.jiffy_timer += CLK_TICKS_PER_JIFFY;
-        asm volatile ("SCKC %0" : : "m" (S390_lowcore.jiffy_timer));
+	asm volatile ("STCK 0(%0)" : : "a" (&tmp) : "memory", "cc");
+	if (tmp < S390_lowcore.jiffy_timer)
+		return;
+	tmp = tmp - S390_lowcore.jiffy_timer;
+	if (tmp >= 2*CLK_TICKS_PER_JIFFY) {
+		ticks = div64_32(tmp >> 1, CLK_TICKS_PER_JIFFY >> 1) + 1;
+		S390_lowcore.jiffy_timer +=
+				CLK_TICKS_PER_JIFFY * (__u64) ticks;
+	} else if (tmp > CLK_TICKS_PER_JIFFY) {
+		ticks = 2;
+		S390_lowcore.jiffy_timer += 2*CLK_TICKS_PER_JIFFY;
+	} else {
+		ticks = 1;
+		S390_lowcore.jiffy_timer += CLK_TICKS_PER_JIFFY;
+	}
 
-#ifdef CONFIG_SMP
-	if (S390_lowcore.cpu_data.cpu_addr == boot_cpu_addr)
-		br_write_lock(BR_XTIME_LOCK);
+	/*
+	 * Set clock comparator for next tick.
+	 * If we return to cpu_idle(), stop_hz_timer will reprogram this.
+	 * If not, everything works as usual.
+	 */
+        tmp = S390_lowcore.jiffy_timer + CPU_DEVIATION;
+        asm volatile ("SCKC %0" : : "m" (tmp));
 
-	update_process_times(user_mode(regs));
+	irq_enter(cpu, 0);
 
-	if (S390_lowcore.cpu_data.cpu_addr == boot_cpu_addr) {
-		do_timer(regs);
-		br_write_unlock(BR_XTIME_LOCK);
+#ifdef CONFIG_SMP
+	/*
+	 * Do not rely on the boot cpu to do the calls to do_timer.
+	 * Spread it over all cpus instead.
+	 */
+	br_write_lock(BR_XTIME_LOCK);
+	if (S390_lowcore.jiffy_timer > xtime_cc) {
+		u32 xticks;
+
+		tmp = S390_lowcore.jiffy_timer - xtime_cc;
+		if (tmp >= 2*CLK_TICKS_PER_JIFFY) {
+			xticks = div64_32(tmp >> 1, CLK_TICKS_PER_JIFFY >> 1);
+			xtime_cc += (__u64) xticks * CLK_TICKS_PER_JIFFY;
+		} else {
+			xticks = 1;
+			xtime_cc += CLK_TICKS_PER_JIFFY;
+		}
+		while (xticks--)
+			do_timer(regs);
 	}
+	br_write_unlock(BR_XTIME_LOCK);
+	while (ticks--)
+		update_process_times(user_mode(regs));
 #else
-	do_timer(regs);
+	while (ticks--)
+		do_timer(regs);
 #endif
 	s390_do_profile(regs);
 
@@ -230,10 +293,13 @@ static void do_comparator_interrupt(stru
 void init_cpu_timer(void)
 {
 	unsigned long cr0;
+	u64 timer;
+
+	timer = init_timer_cc + (__u64) jiffies * CLK_TICKS_PER_JIFFY;
+	S390_lowcore.jiffy_timer = timer + CLK_TICKS_PER_JIFFY;
+	timer += CLK_TICKS_PER_JIFFY + CPU_DEVIATION;
+	asm volatile ("SCKC %0" : : "m" (timer));
 
-	S390_lowcore.jiffy_timer = (__u64) jiffies * CLK_TICKS_PER_JIFFY;
-	S390_lowcore.jiffy_timer += init_timer_cc + CLK_TICKS_PER_JIFFY;
-	asm volatile ("SCKC %0" : : "m" (S390_lowcore.jiffy_timer));
         /* allow clock comparator timer interrupt */
         asm volatile ("STCTL 0,0,%0" : "=m" (cr0) : : "memory");
         cr0 |= 0x800;
@@ -269,6 +335,7 @@ void __init time_init(void)
         }
 
 	/* set xtime */
+	xtime_cc = init_timer_cc + CLK_TICKS_PER_JIFFY;
         set_time_cc = init_timer_cc - 0x8126d60e46000000LL +
                       (0x3c26700LL*1000000*4096);
         tod_to_timeval(set_time_cc, &xtime);
@@ -281,3 +348,94 @@ void __init time_init(void)
         /* init CPU timer */
         init_cpu_timer();
 }
+
+#ifdef CONFIG_NO_IDLE_HZ
+
+/*
+ * Start the HZ tick on the current CPU.
+ * The cpu_idle used to call this function, but a monitor call does it now.
+ */
+void start_hz_timer(void)
+{
+	__u64 tmp;
+	__u32 ticks;
+
+	if (sysctl_hz_timer != 0)
+		return;
+
+	irq_enter(smp_processor_id(), 0);
+
+	/* Calculate how many ticks have passed */
+	asm volatile ("STCK 0(%0)" : : "a" (&tmp) : "memory", "cc");
+	tmp = tmp + CLK_TICKS_PER_JIFFY - S390_lowcore.jiffy_timer;
+	ticks = div64_32(tmp >> 1, CLK_TICKS_PER_JIFFY >> 1);
+	S390_lowcore.jiffy_timer += CLK_TICKS_PER_JIFFY * (__u64) ticks;
+
+	/* Set the clock comparator to the next tick. */
+	tmp = S390_lowcore.jiffy_timer + CPU_DEVIATION;
+	asm volatile ("SCKC %0" : : "m" (tmp));
+
+	/* Charge the ticks. */
+	if (ticks > 0) {
+#ifdef CONFIG_SMP
+		br_write_lock(BR_XTIME_LOCK);
+		if (S390_lowcore.jiffy_timer > xtime_cc) {
+			u32 xticks;
+
+			tmp = S390_lowcore.jiffy_timer - xtime_cc;
+			if (tmp >= 2*CLK_TICKS_PER_JIFFY) {
+			 	xticks = div64_32(tmp >> 1, CLK_TICKS_PER_JIFFY >> 1);
+ 				xtime_cc += (__u64) xticks * CLK_TICKS_PER_JIFFY;
+			} else {
+				xticks = 1;
+				xtime_cc += CLK_TICKS_PER_JIFFY;
+			}
+			do_timer_ticks(xticks);
+		}
+		br_write_unlock(BR_XTIME_LOCK);
+#else
+		do_timer_ticks(ticks);
+#endif
+	}
+
+	irq_exit(smp_processor_id(), 0);
+}
+
+/*
+ * Stop the HZ tick on the current CPU.
+ * Only cpu_idle may call this function. The next_timer_event() does the
+ * heavy lifting, so should not be called if we have anything better to do.
+ */
+void stop_hz_timer(void)
+{
+	u64 timer;
+
+	if (sysctl_hz_timer != 0)
+		return;
+
+	/* 
+	 * This cpu is going to sleep. Setup the clock
+	 * comparator for the next event if nothing on tq_timer
+	 * is pending. If something is pending on tq_timer then
+	 * don't change the clock comparator as it is setup for
+	 * the next timer tick already.
+	 */
+	if (!TQ_ACTIVE(tq_timer)) {
+		timer = next_timer_event();
+		timer *= CLK_TICKS_PER_JIFFY;
+		timer += init_timer_cc;
+		asm volatile ("SCKC %0" : : "m" (timer));
+	}
+
+	/* enable monitor call class 0 */
+	__ctl_set_bit(8, 15);
+}
+
+void do_monitor_call(struct pt_regs *regs, long interruption_code)
+{
+
+	/* disable monitor call class 0 */
+	__ctl_clear_bit(8, 15);
+	start_hz_timer();
+}
+#endif
diff -urNp linux-7140/arch/s390/kernel/traps.c linux-7150/arch/s390/kernel/traps.c
--- linux-7140/arch/s390/kernel/traps.c
+++ linux-7150/arch/s390/kernel/traps.c
@@ -55,6 +55,9 @@ extern pgm_check_handler_t do_protection
 extern pgm_check_handler_t do_segment_exception;
 extern pgm_check_handler_t do_page_exception;
 extern pgm_check_handler_t do_pseudo_page_fault;
+#ifdef CONFIG_NO_IDLE_HZ
+extern pgm_check_handler_t do_monitor_call;
+#endif
 #ifdef CONFIG_PFAULT
 extern int pfault_init(void);
 extern void pfault_fini(void);
@@ -722,6 +725,9 @@ void __init trap_init(void)
  	pgm_check_table[0x14] = &do_pseudo_page_fault;
         pgm_check_table[0x15] = &operand_exception;
         pgm_check_table[0x1C] = &privileged_op;
+#ifdef CONFIG_NO_IDLE_HZ
+	pgm_check_table[0x40] = &do_monitor_call;
+#endif
 #ifdef CONFIG_PFAULT
 	if (MACHINE_IS_VM) {
 		/* request the 0x2603 external interrupt */
diff -urNp linux-7140/arch/s390x/config.in linux-7150/arch/s390x/config.in
--- linux-7140/arch/s390x/config.in
+++ linux-7150/arch/s390x/config.in
@@ -59,6 +59,10 @@ tristate 'Kernel support for MISC binari
 bool 'Show crashed user process info' CONFIG_PROCESS_DEBUG
 bool 'Pseudo page fault support' CONFIG_PFAULT
 bool 'VM shared kernel support' CONFIG_SHARED_KERNEL
+bool 'No HZ timer ticks in idle' CONFIG_NO_IDLE_HZ
+if [ "$CONFIG_NO_IDLE_HZ" = "y" ] ; then
+  bool '  Idle HZ timer on by default' CONFIG_NO_IDLE_HZ_INIT
+fi
 endmenu
 
 
diff -urNp linux-7140/arch/s390x/kernel/entry.S linux-7150/arch/s390x/kernel/entry.S
--- linux-7140/arch/s390x/kernel/entry.S
+++ linux-7150/arch/s390x/kernel/entry.S
@@ -752,6 +752,7 @@ pgm_tracesys:
         .globl io_int_handler
 io_int_handler:
         SAVE_ALL __LC_IO_OLD_PSW,0
+	mc	0,0
         GET_CURRENT                    # load pointer to task_struct to R9
         la      %r2,SP_PTREGS(%r15)    # address of register-save area
 	llgh    %r3,__LC_SUBCHANNEL_NR # load subchannel number
@@ -816,6 +817,7 @@ io_signal_return:     
         .globl  ext_int_handler
 ext_int_handler:
         SAVE_ALL __LC_EXT_OLD_PSW,0
+	mc	0,0
         GET_CURRENT                    # load pointer to task_struct to R9
 	llgh	%r6,__LC_EXT_INT_CODE  # get interruption code
 	lgr	%r1,%r6		       # calculate index = code & 0xff
@@ -829,6 +831,8 @@ ext_int_loop:
 	ch	%r6,16(%r7)	       # compare external interrupt code
 	jne	ext_int_next
 	lg	%r1,8(%r7)	       # get handler address
+	ltgr	%r1,%r1
+	jz	ext_int_next
 	la	%r2,SP_PTREGS(%r15)    # address of register-save area
 	lgr	%r3,%r6		       # interruption code
 	basr	%r14,%r1	       # call handler
@@ -844,6 +848,7 @@ ext_int_next:
         .globl mcck_int_handler
 mcck_int_handler:
         SAVE_ALL __LC_MCK_OLD_PSW,0
+	mc	0,0
 	brasl   %r14,s390_do_machine_check
 mcck_return:
         RESTORE_ALL 0
diff -urNp linux-7140/arch/s390x/kernel/process.c linux-7150/arch/s390x/kernel/process.c
--- linux-7140/arch/s390x/kernel/process.c
+++ linux-7150/arch/s390x/kernel/process.c
@@ -50,21 +50,27 @@ asmlinkage void ret_from_fork(void) __as
  * The idle loop on a S390...
  */
 
-int cpu_idle(void *unused)
+int cpu_idle(void)
 {
 	psw_t wait_psw;
 	unsigned long reg;
 
 	while (1) {
+		__cli();
 		if (current->need_resched) {
+			__sti();
 			schedule();
 			check_pgt_cache();
 			continue;
 		}
 
+#ifdef CONFIG_NO_IDLE_HZ
+		stop_hz_timer();
+#endif
+
 		/* 
 		 * Wait for external, I/O or machine check interrupt and
-		 * switch of machine check bit after the wait has ended.
+		 * switch off machine check bit after the wait has ended.
 		 */
 		wait_psw.mask = _WAIT_PSW_MASK;
 		asm volatile (
@@ -77,6 +83,10 @@ int cpu_idle(void *unused)
 			"    lpswe 0(%1)\n"
 			"1:"
 			: "=&a" (reg) : "a" (&wait_psw) : "memory", "cc" );
+		/*
+		 * start_hz_timer is called by monitor call in entry.S
+		 * if stop_hz_timer switched off the regular HZ interrupts
+		 */
 	}
 }
 
diff -urNp linux-7140/arch/s390x/kernel/time.c linux-7150/arch/s390x/kernel/time.c
--- linux-7140/arch/s390x/kernel/time.c
+++ linux-7150/arch/s390x/kernel/time.c
@@ -35,16 +35,33 @@
 #include <asm/s390_ext.h>
 
 /* change this if you have some constant time drift */
-#define USECS_PER_JIFFY     ((unsigned long) 1000000/HZ)
 #define CLK_TICKS_PER_JIFFY ((unsigned long) USECS_PER_JIFFY << 12)
 
+/*
+ * Create a small time difference between the timer interrupts
+ * on the different cpus to avoid lock contention.
+ */
+#define USECS_PER_JIFFY     ((unsigned long) 1000000/HZ)
+#define CPU_DEVIATION       (smp_processor_id() << 12)
+
 #define TICK_SIZE tick
 
 static ext_int_info_t ext_int_info_timer;
-static uint64_t init_timer_cc;
+static u64 init_timer_cc;
+static u64 xtime_cc;
 
 extern unsigned long wall_jiffies;
 
+#ifdef CONFIG_NO_IDLE_HZ
+
+#ifdef CONFIG_NO_IDLE_HZ_INIT
+int sysctl_hz_timer = 0;
+#else
+int sysctl_hz_timer = 1;
+#endif
+
+#endif
+
 void tod_to_timeval(__u64 todval, struct timeval *xtime)
 {
         todval >>= 12;
@@ -56,7 +73,7 @@ static inline unsigned long do_gettimeof
 {
 	__u64 now;
 
-	asm ("STCK 0(%0)" : : "a" (&now) : "memory", "cc");
+	asm volatile ("STCK 0(%0)" : : "a" (&now) : "memory", "cc");
         now = (now - init_timer_cc) >> 12;
 	/* We require the offset from the latest update of xtime */
 	now -= (__u64) wall_jiffies*USECS_PER_JIFFY;
@@ -162,35 +179,72 @@ static inline void s390_do_profile(struc
  * timer_interrupt() needs to keep up the real-time clock,
  * as well as call the "do_timer()" routine every clocktick
  */
-
-#ifdef CONFIG_SMP
-extern __u16 boot_cpu_addr;
-#endif
-
 static void do_comparator_interrupt(struct pt_regs *regs, __u16 error_code)
 {
 	int cpu = smp_processor_id();
-
-	irq_enter(cpu, 0);
+	u64 tmp;
+	u32 ticks;
 
 	/*
-	 * set clock comparator for next tick
+	 * Calculate how many ticks have passed.
+	 *
+	 * This segment uses STCK as the 2.4.19 IBM stream did.
+	 * The reset is taken from the RHEL patch by Jan Gauber,
+	 * with additional case against fixpoint division fault (on boot)
+	 * by Martin Schwidefsky (if delta<0 return). XXX Wrapping?
 	 */
-        S390_lowcore.jiffy_timer += CLK_TICKS_PER_JIFFY;
-        asm volatile ("SCKC %0" : : "m" (S390_lowcore.jiffy_timer));
+	asm volatile ("STCK 0(%0)" : : "a" (&tmp) : "memory", "cc");
+	if (tmp < S390_lowcore.jiffy_timer)
+		return;
+	tmp = tmp - S390_lowcore.jiffy_timer;
+	if (tmp >= 2*CLK_TICKS_PER_JIFFY) {
+		ticks = tmp / CLK_TICKS_PER_JIFFY + 1;
+		S390_lowcore.jiffy_timer +=
+				CLK_TICKS_PER_JIFFY * (__u64) ticks;
+	} else if (tmp > CLK_TICKS_PER_JIFFY) {
+		ticks = 2;
+		S390_lowcore.jiffy_timer += 2*CLK_TICKS_PER_JIFFY;
+	} else {
+		ticks = 1;
+		S390_lowcore.jiffy_timer += CLK_TICKS_PER_JIFFY;
+	}
 
-#ifdef CONFIG_SMP
-	if (S390_lowcore.cpu_data.cpu_addr == boot_cpu_addr)
-		br_write_lock(BR_XTIME_LOCK);
+	/*
+	 * Set clock comparator for next tick.
+	 * If we return to cpu_idle(), stop_hz_timer will reprogram this.
+	 * If not, everything works as usual.
+	 */
+        tmp = S390_lowcore.jiffy_timer + CPU_DEVIATION;
+        asm volatile ("SCKC %0" : : "m" (tmp));
 
-	update_process_times(user_mode(regs));
+	irq_enter(cpu, 0);
 
-	if (S390_lowcore.cpu_data.cpu_addr == boot_cpu_addr) {
-		do_timer(regs);
-		br_write_unlock(BR_XTIME_LOCK);
+#ifdef CONFIG_SMP
+	/*
+	 * Do not rely on the boot cpu to do the calls to do_timer.
+	 * Spread it over all cpus instead.
+	 */
+	br_write_lock(BR_XTIME_LOCK);
+	if (S390_lowcore.jiffy_timer > xtime_cc) {
+		u32 xticks;
+
+		tmp = S390_lowcore.jiffy_timer - xtime_cc;
+		if (tmp >= 2*CLK_TICKS_PER_JIFFY) {
+			xticks = tmp / CLK_TICKS_PER_JIFFY;
+			xtime_cc += (__u64) xticks * CLK_TICKS_PER_JIFFY;
+		} else {
+			xticks = 1;
+			xtime_cc += CLK_TICKS_PER_JIFFY;
+		}
+		while (xticks--)
+			do_timer(regs);
 	}
+	br_write_unlock(BR_XTIME_LOCK);
+	while (ticks--)
+		update_process_times(user_mode(regs));
 #else
-	do_timer(regs);
+	while (ticks--)
+		do_timer(regs);
 #endif
 	s390_do_profile(regs);
 
@@ -203,10 +257,13 @@ static void do_comparator_interrupt(stru
 void init_cpu_timer(void)
 {
 	unsigned long cr0;
+	u64 timer;
+
+	timer = init_timer_cc + (__u64) jiffies * CLK_TICKS_PER_JIFFY;
+	S390_lowcore.jiffy_timer = timer + CLK_TICKS_PER_JIFFY;
+	timer += CLK_TICKS_PER_JIFFY + CPU_DEVIATION;
+	asm volatile ("SCKC %0" : : "m" (timer));
 
-	S390_lowcore.jiffy_timer = (__u64) jiffies * CLK_TICKS_PER_JIFFY;
-	S390_lowcore.jiffy_timer += init_timer_cc + CLK_TICKS_PER_JIFFY;
-	asm volatile ("SCKC %0" : : "m" (S390_lowcore.jiffy_timer));
         /* allow clock comparator timer interrupt */
         asm volatile ("STCTG 0,0,%0" : "=m" (cr0) : : "memory");
         cr0 |= 0x800;
@@ -242,6 +299,7 @@ void __init time_init(void)
         }
 
 	/* set xtime */
+	xtime_cc = init_timer_cc + CLK_TICKS_PER_JIFFY;
         set_time_cc = init_timer_cc - 0x8126d60e46000000LL +
                       (0x3c26700LL*1000000*4096);
         tod_to_timeval(set_time_cc, &xtime);
@@ -254,3 +312,94 @@ void __init time_init(void)
         /* init CPU timer */
         init_cpu_timer();
 }
+
+#ifdef CONFIG_NO_IDLE_HZ
+
+/*
+ * Start the HZ tick on the current CPU.
+ * The cpu_idle used to call this function, but a monitor call does it now.
+ */
+void start_hz_timer(void)
+{
+	__u64 tmp;
+	__u32 ticks;
+
+	if (sysctl_hz_timer != 0)
+		return;
+
+	irq_enter(smp_processor_id(), 0);
+
+	/* Calculate how many ticks have passed */
+	asm volatile ("STCK 0(%0)" : : "a" (&tmp) : "memory", "cc");
+	tmp = tmp + CLK_TICKS_PER_JIFFY - S390_lowcore.jiffy_timer;
+	ticks = tmp / CLK_TICKS_PER_JIFFY;
+	S390_lowcore.jiffy_timer += CLK_TICKS_PER_JIFFY * (__u64) ticks;
+
+	/* Set the clock comparator to the next tick. */
+	tmp = S390_lowcore.jiffy_timer + CPU_DEVIATION;
+	asm volatile ("SCKC %0" : : "m" (tmp));
+
+	/* Charge the ticks. */
+	if (ticks > 0) {
+#ifdef CONFIG_SMP
+		br_write_lock(BR_XTIME_LOCK);
+		if (S390_lowcore.jiffy_timer > xtime_cc) {
+			u32 xticks;
+
+			tmp = S390_lowcore.jiffy_timer - xtime_cc;
+			if (tmp >= 2*CLK_TICKS_PER_JIFFY) {
+			 	xticks = tmp / CLK_TICKS_PER_JIFFY;
+ 				xtime_cc += (__u64) xticks * CLK_TICKS_PER_JIFFY;
+			} else {
+				xticks = 1;
+				xtime_cc += CLK_TICKS_PER_JIFFY;
+			}
+			do_timer_ticks(xticks);
+		}
+		br_write_unlock(BR_XTIME_LOCK);
+#else
+		do_timer_ticks(ticks);
+#endif
+	}
+
+	irq_exit(smp_processor_id(), 0);
+}
+
+/*
+ * Stop the HZ tick on the current CPU.
+ * Only cpu_idle may call this function. The next_timer_event() does the
+ * heavy lifting, so should not be called if we have anything better to do.
+ */
+void stop_hz_timer(void)
+{
+	u64 timer;
+
+	if (sysctl_hz_timer != 0)
+		return;
+
+	/* 
+	 * This cpu is going to sleep. Setup the clock
+	 * comparator for the next event if nothing on tq_timer
+	 * is pending. If something is pending on tq_timer then
+	 * don't change the clock comparator as it is setup for
+	 * the next timer tick already.
+	 */
+	if (!TQ_ACTIVE(tq_timer)) {
+		timer = next_timer_event();
+		timer *= CLK_TICKS_PER_JIFFY;
+		timer += init_timer_cc;
+		asm volatile ("SCKC %0" : : "m" (timer));
+	}
+
+	/* enable monitor call class 0 */
+	__ctl_set_bit(8, 15);
+}
+
+void do_monitor_call(struct pt_regs *regs, long interruption_code)
+{
+
+	/* disable monitor call class 0 */
+	__ctl_clear_bit(8, 15);
+	start_hz_timer();
+}
+#endif
diff -urNp linux-7140/arch/s390x/kernel/traps.c linux-7150/arch/s390x/kernel/traps.c
--- linux-7140/arch/s390x/kernel/traps.c
+++ linux-7150/arch/s390x/kernel/traps.c
@@ -57,6 +57,9 @@ extern pgm_check_handler_t do_protection
 extern pgm_check_handler_t do_segment_exception;
 extern pgm_check_handler_t do_region_exception;
 extern pgm_check_handler_t do_page_exception;
+#ifdef CONFIG_NO_IDLE_HZ
+extern pgm_check_handler_t do_monitor_call;
+#endif
 #ifdef CONFIG_PFAULT
 extern int pfault_init(void);
 extern void pfault_fini(void);
@@ -577,6 +580,9 @@ void __init trap_init(void)
         pgm_check_table[0x1C] = &privileged_op;
         pgm_check_table[0x38] = &addressing_exception;
         pgm_check_table[0x3B] = &do_region_exception;
+#ifdef CONFIG_NO_IDLE_HZ
+	pgm_check_table[0x40] = &do_monitor_call;
+#endif
 #ifdef CONFIG_PFAULT
 	if (MACHINE_IS_VM) {
 		/* request the 0x2603 external interrupt */
diff -urNp linux-7140/include/asm-s390/system.h linux-7150/include/asm-s390/system.h
--- linux-7140/include/asm-s390/system.h
+++ linux-7150/include/asm-s390/system.h
@@ -269,6 +269,10 @@ extern void (*_machine_restart)(char *co
 extern void (*_machine_halt)(void);
 extern void (*_machine_power_off)(void);
 
+#ifdef CONFIG_NO_IDLE_HZ
+extern void stop_hz_timer(void);
+#endif
+
 #endif
 
 #endif
diff -urNp linux-7140/include/asm-s390x/system.h linux-7150/include/asm-s390x/system.h
--- linux-7140/include/asm-s390x/system.h
+++ linux-7150/include/asm-s390x/system.h
@@ -280,6 +280,10 @@ extern void (*_machine_restart)(char *co
 extern void (*_machine_halt)(void);
 extern void (*_machine_power_off)(void);
 
+#ifdef CONFIG_NO_IDLE_HZ
+extern void stop_hz_timer(void);
+#endif
+
 #endif
 
 #endif
diff -urNp linux-7140/include/linux/sched.h linux-7150/include/linux/sched.h
--- linux-7140/include/linux/sched.h
+++ linux-7150/include/linux/sched.h
@@ -168,6 +168,9 @@ extern void trap_init(void);
 extern void update_process_times(int user);
 extern void update_process_time_intertick(task_t *,
 					  struct kernel_stat_tick_times *);
+#ifdef CONFIG_NO_IDLE_HZ
+extern void update_process_times_us(int user, int system);
+#endif
 extern void update_one_process(task_t *p, struct kernel_stat_tick_times *,
 			       int cpu);
 extern void scheduler_tick(int timer_tick);
@@ -764,6 +767,9 @@ extern unsigned long itimer_ticks;
 extern unsigned long itimer_next;
 extern struct timeval xtime;
 extern void do_timer(struct pt_regs *);
+#ifdef CONFIG_NO_IDLE_HZ
+extern void do_timer_ticks(int ticks);
+#endif
 
 #define CURRENT_TIME (xtime.tv_sec)
 
diff -urNp linux-7140/include/linux/sysctl.h linux-7150/include/linux/sysctl.h
--- linux-7140/include/linux/sysctl.h
+++ linux-7150/include/linux/sysctl.h
@@ -130,6 +130,7 @@ enum
 	KERN_SERCONS_ESC=59,	/* int: ascii code of ser-cons "break" or -1 */
 	KERN_TASK_SIZE=60,	/* int: process VM size */
 	KERN_HONOR_UAC_NOPRINT=61, /* int: allow access to UAC_NOPRINT prctl */
+	KERN_S390_HZ_TIMER=62,	/* int: hz timer on or off */
 	KERN_UNKNOWN_NMI_PANIC=63, /* int: unknown nmi panic flag */
 	KERN_MEM_NMI_PANIC=64,  /* int: memory nmi panic flag */
 };
diff -urNp linux-7140/include/linux/timer.h linux-7150/include/linux/timer.h
--- linux-7140/include/linux/timer.h
+++ linux-7150/include/linux/timer.h
@@ -62,4 +62,8 @@ extern void it_real_fn(unsigned long);
 	ok;							\
 })
 
+#ifdef CONFIG_NO_IDLE_HZ
+extern unsigned long next_timer_event(void);
+#endif
+
 #endif
diff -urNp linux-7140/kernel/sysctl.c linux-7150/kernel/sysctl.c
--- linux-7140/kernel/sysctl.c
+++ linux-7150/kernel/sysctl.c
@@ -113,6 +113,9 @@ extern int unaligned_enabled;
 extern int sysctl_ieee_emulation_warnings;
 #endif
 extern int sysctl_userprocess_debug;
+#ifdef CONFIG_NO_IDLE_HZ
+extern int sysctl_hz_timer;
+#endif
 #endif
 
 #ifdef CONFIG_IA64
@@ -326,6 +329,10 @@ static ctl_table kern_table[] = {
 #endif
 	{KERN_S390_USER_DEBUG_LOGGING,"userprocess_debug",
 	 &sysctl_userprocess_debug,sizeof(int),0644,NULL,&proc_dointvec},
+#ifdef CONFIG_NO_IDLE_HZ
+	{KERN_S390_HZ_TIMER,"hz_timer",
+	 &sysctl_hz_timer,sizeof(int),0644,NULL,&proc_dointvec},
+#endif
 #endif
 #ifdef CONFIG_SERIAL_CONSOLE
 	{KERN_SERCONS_ESC, "sercons_esc", &sercons_escape_char,
diff -urNp linux-7140/kernel/timer.c linux-7150/kernel/timer.c
--- linux-7140/kernel/timer.c
+++ linux-7150/kernel/timer.c
@@ -512,6 +512,79 @@ repeat:
 	spin_unlock_irq(&base->lock);
 }
 
+#ifdef CONFIG_NO_IDLE_HZ
+
+/*
+ * Find out when the next timer event is due to happen. This
+ * is used on S/390 to stop all activity when all cpus are idle.
+ * This is called with all locks relevant to stop_hz_timer taken
+ * and interrupts closed, but it has to take locks in tvecs.
+ *
+ * Scan first 256 jiffies on all CPUs, then next 63*256 jiffies, etc.
+ */
+unsigned long next_timer_event(void)
+{
+	tvec_base_t *base;
+	struct list_head *list;
+	struct timer_list *nte;
+	unsigned long expires;
+	tvec_t *varray[4];
+	int i, j;
+
+	base = tvec_bases + smp_processor_id();
+	spin_lock(&base->lock);
+	expires = base->timer_jiffies + (LONG_MAX >> 1);
+	list = 0;
+	
+	/* Look for timer events in tv1. */
+	j = base->timer_jiffies & TVR_MASK;
+	do {
+		list_for_each_entry(nte, base->tv1.vec + j, entry) {
+			expires = nte->expires;
+			if (j < (base->timer_jiffies & TVR_MASK))
+				list = base->tv2.vec + (INDEX(0));
+			goto found;
+		}
+		j = (j + 1) & TVR_MASK;
+	} while (j != (base->timer_jiffies & TVR_MASK));
+	
+	/* Check tv2-tv5. */
+	varray[0] = &base->tv2;
+	varray[1] = &base->tv3;
+	varray[2] = &base->tv4;
+	varray[3] = &base->tv5;
+	for (i = 0; i < 4; i++) {
+		j = INDEX(i);
+		do {
+			if (list_empty(varray[i]->vec + j)) {
+				j = (j + 1) & TVN_MASK;
+				continue;
+			}
+			list_for_each_entry(nte, varray[i]->vec + j, entry)
+				if (time_before(nte->expires, expires))
+					expires = nte->expires;
+			if (j < (INDEX(i)) && i < 3)
+				list = varray[i + 1]->vec + (INDEX(i + 1));
+			goto found;
+		} while (j != (INDEX(i)));
+	}
+found:
+	if (list) {
+		/*
+		 * The search wrapped. We need to look at the next list
+		 * from next tv element that would cascade into tv element
+		 * where we found the timer element.
+		 */
+		list_for_each_entry(nte, list, entry) {
+			if (time_before(nte->expires, expires))
+				expires = nte->expires;
+		}
+	}
+	spin_unlock(&base->lock);
+	return expires;
+}
+#endif
+
 spinlock_t tqueue_lock = SPIN_LOCK_UNLOCKED;
 
 void tqueue_bh(void)
@@ -700,7 +773,7 @@ static void update_wall_time(unsigned lo
 		update_wall_time_one_tick();
 	} while (ticks);
 
-	if (xtime.tv_usec >= 1000000) {
+	while (xtime.tv_usec >= 1000000) {
 	    xtime.tv_usec -= 1000000;
 	    xtime.tv_sec++;
 	    second_overflow();
@@ -916,6 +989,32 @@ void update_process_times(int user_mode)
 }
 
 /*
+ * Called from the timer interrupt handler to charge a couple of ticks
+ * to the current process.
+ */
+void update_process_times_us(int user_ticks, int system_ticks)
+{
+	struct kernel_stat_tick_times time;
+	struct task_struct *p = current;
+	int cpu = smp_processor_id();
+
+	/*
+	 * Making a terribe hash out of accounting here. XXX
+	 * Ticks are fractional these days, but oh well...
+	 */
+	memset(&time, 0, sizeof(struct kernel_stat_tick_times));
+	if (task_nice(p) > 0)
+		time.n_usec = user_ticks*(1000000/HZ);
+	else
+		time.u_usec = user_ticks*(1000000/HZ);
+	time.s_usec = system_ticks*(1000000/HZ);
+	update_one_process(p, &time, cpu);
+
+	update_kstatpercpu(p, &time);
+	scheduler_tick(1);
+}
+
+/*
  * Nr of active tasks - counted in fixed-point numbers
  */
 static unsigned long count_active_tasks(void)
@@ -937,7 +1036,7 @@ static inline void calc_load(unsigned lo
 	static int count = LOAD_FREQ;
 
 	count -= ticks;
-	if (count < 0) {
+	while (count < 0) {
 		count += LOAD_FREQ;
 		active_tasks = count_active_tasks();
 		CALC_LOAD(avenrun[0], EXP_1, active_tasks);
@@ -963,6 +1062,14 @@ void do_timer(struct pt_regs *regs)
 		mark_bh(TQUEUE_BH);
 }
 
+void do_timer_ticks(int ticks)
+{
+	(*(unsigned long *)&jiffies) += ticks;
+	mark_bh(TIMER_BH);
+	if (TQ_ACTIVE(tq_timer))
+		mark_bh(TQUEUE_BH);
+}
+
 #if !defined(__alpha__) && !defined(__ia64__)
 
 /*
