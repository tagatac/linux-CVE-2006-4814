--- linux-2.4.21/arch/x86_64/ia32/ia32_ioctl.c.orig	2003-08-01 10:20:52.000000000 -0400
+++ linux-2.4.21/arch/x86_64/ia32/ia32_ioctl.c	2003-08-01 10:21:35.000000000 -0400
@@ -1759,12 +1759,6 @@ static int mt_ioctl_trans(unsigned int f
 	return err ? -EFAULT: 0;
 }
 
-struct cdrom_read32 {
-	int			cdread_lba;
-	__kernel_caddr_t32	cdread_bufaddr;
-	int			cdread_buflen;
-};
-
 struct cdrom_read_audio32 {
 	union cdrom_addr	addr;
 	u_char			addr_format;
@@ -1778,75 +1772,145 @@ struct cdrom_generic_command32 {
 	unsigned int		buflen;
 	int			stat;
 	__kernel_caddr_t32	sense;
-	__kernel_caddr_t32	reserved[3];
+	unsigned char		data_direction;
+	int			quiet;
+	int 			timeout;
+	__kernel_caddr_t32	reserved[1];
 };
 
-static int cdrom_ioctl_trans(unsigned int fd, unsigned int cmd, unsigned long arg)
+static int cdrom_do_read_audio(unsigned int fd, unsigned int cmd, 
+			       unsigned long arg)
+{
+	struct cdrom_read_audio cdread_audio;
+	struct cdrom_read_audio32 *cdread_audio32;
+	__u32 ubuf;
+	void *datap;
+	mm_segment_t old_fs;
+	int err;
+
+	cdread_audio32 = (struct cdrom_read_audio32 *) arg;
+
+	/* Copy in most of the request block from user space */
+	if (copy_from_user(&cdread_audio.addr, &cdread_audio32->addr,
+			   (sizeof(*cdread_audio32) - 
+			   sizeof(cdread_audio32->buf))))
+		return -EFAULT;
+
+	/* Grab the address of the user's receive buffer */
+	if (get_user(ubuf, &cdread_audio32->buf))
+		return -EFAULT;
+
+	/* 
+	 * Allocate a kernel buffer to receive the data. The driver will
+	 * use this address as the destination of the data transfer. Later,
+	 * the contents will be copied to the user's buffer.
+	 */
+	datap = kmalloc(cdread_audio.nframes * 2352, GFP_KERNEL);
+	if (!datap)
+		return -ENOMEM;
+	cdread_audio.buf = datap;
+
+	/* Do the real system call */
+	old_fs = get_fs();
+	set_fs (KERNEL_DS);
+	err = sys_ioctl(fd, cmd, (unsigned long) &cdread_audio);
+	set_fs (old_fs);
+
+	/* If success, copy the received data to the user's buffer */
+	if (!err && copy_to_user((char *)A(ubuf), datap, 
+				 cdread_audio.nframes * 2352))
+		err = -EFAULT;
+
+	/* Free the kernel buffer and return status to the user */
+	kfree(datap);
+	return err;
+}
+
+/*
+ * ptr32 is a buffer pointer in the 32-bit user application
+ * ptr64 is a buffer pointer in our 64-bit kernel
+ * 
+ * Copy the user pointer in, convert to 64 bit pointer, and store
+ * it at the specified location (ptr64) in the kernel.
+ */
+static int __cgc_do_ptr(void **ptr64, __u32 *ptr32)
+{
+	u32 data;
+	void *datap;
+
+	if (get_user(data, ptr32))
+		return -EFAULT;
+	datap = (void *) (unsigned long) data;
+	if (__put_user(datap, ptr64))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int cdrom_do_generic_command(unsigned int fd, unsigned int cmd, 
+				    unsigned long arg)
 {
-	mm_segment_t old_fs = get_fs();
-	struct cdrom_read cdread;
-	struct cdrom_read_audio cdreadaudio;
 	struct cdrom_generic_command cgc;
-	__kernel_caddr_t32 addr;
-	void *karg;
-	int err = 0;
+	struct cdrom_generic_command32 *cgc32;
+	mm_segment_t old_fs;
+	int err;
+
+	cgc32 = (struct cdrom_generic_command32 *) arg;
+
+	/* 
+	 * Copy the user request structure into the kernel version of
+	 * the structure. Data pointers within the user structure are
+	 * handled by __cgc_do_ptr.
+	 */
+	if (copy_from_user(cgc.cmd, &cgc32->cmd, sizeof(cgc.cmd)) ||
+	    copy_from_user(&cgc.buflen, &cgc32->buflen,
+			   sizeof(cgc.buflen) + sizeof(cgc.stat)) ||
+	    copy_from_user(&cgc.quiet, &cgc32->quiet, 
+			   sizeof(cgc.quiet) + sizeof(cgc.timeout)) ||
+	    get_user(cgc.data_direction, &cgc32->data_direction))
+		return -EFAULT;
+
+	  if (__cgc_do_ptr((void **) &cgc.buffer, &cgc32->buffer) ||
+	      __cgc_do_ptr((void **) &cgc.sense, &cgc32->sense) ||
+	      __cgc_do_ptr(&cgc.reserved[0], &cgc32->reserved[0]))
+		return -EFAULT;
+
+	/* Do the real system call using the kernel version of the structure */
+	old_fs = get_fs();
+	set_fs (KERNEL_DS);
+	err = sys_ioctl (fd, cmd, (unsigned long) &cgc);
+	set_fs (old_fs);
+	return err;
+}
+
+static int cdrom_ioctl_trans(unsigned int fd, unsigned int cmd, unsigned long arg)
+{
+	int err;
 
 	switch(cmd) {
-	case CDROMREADMODE2:
-	case CDROMREADMODE1:
-	case CDROMREADRAW:
-	case CDROMREADCOOKED:
-		karg = &cdread;
-		err = __get_user(cdread.cdread_lba, &((struct cdrom_read32 *)arg)->cdread_lba);
-		err |= __get_user(addr, &((struct cdrom_read32 *)arg)->cdread_bufaddr);
-		err |= __get_user(cdread.cdread_buflen, &((struct cdrom_read32 *)arg)->cdread_buflen);
-		if (err)
-			return -EFAULT;
-		if (verify_area(VERIFY_WRITE, (void *)A(addr), cdread.cdread_buflen))
-			return -EFAULT;
-		cdread.cdread_bufaddr = (void *)A(addr);
-		break;
 	case CDROMREADAUDIO:
-		karg = &cdreadaudio;
-		err = copy_from_user(&cdreadaudio.addr, &((struct cdrom_read_audio32 *)arg)->addr, sizeof(cdreadaudio.addr));
-		err |= __get_user(cdreadaudio.addr_format, &((struct cdrom_read_audio32 *)arg)->addr_format);
-		err |= __get_user(cdreadaudio.nframes, &((struct cdrom_read_audio32 *)arg)->nframes); 
-		err |= __get_user(addr, &((struct cdrom_read_audio32 *)arg)->buf);
-		if (err)
-			return -EFAULT;
-		
-
-		if (verify_area(VERIFY_WRITE, (void *)A(addr), cdreadaudio.nframes*2352))
-			return -EFAULT;
-		cdreadaudio.buf = (void *)A(addr);
+		err = cdrom_do_read_audio(fd, cmd, arg);
 		break;
+
 	case CDROM_SEND_PACKET:
-		karg = &cgc;
-		err = copy_from_user(cgc.cmd, &((struct cdrom_generic_command32 *)arg)->cmd, sizeof(cgc.cmd));
-		err |= __get_user(addr, &((struct cdrom_generic_command32 *)arg)->buffer);
-		err |= __get_user(cgc.buflen, &((struct cdrom_generic_command32 *)arg)->buflen);
-		if (err)
-			return -EFAULT;
-		if (verify_area(VERIFY_WRITE, (void *)A(addr), cgc.buflen))
-			return -EFAULT;
-		cgc.buffer = (void *)A(addr);
+		err = cdrom_do_generic_command(fd, cmd, arg);
 		break;
+
 	default:
 		do {
-			static int count;
+			static int count = 0;
 			if (++count <= 20)
 				printk("cdrom_ioctl: Unknown cmd fd(%d) "
 				       "cmd(%08x) arg(%08x)\n",
 				       (int)fd, (unsigned int)cmd, (unsigned int)arg);
-		} while(0);
-		return -EINVAL;
+		} while (0);
+		err = -EINVAL;
+		break;
 	}
-	set_fs (KERNEL_DS);
-	err = sys_ioctl (fd, cmd, (unsigned long)karg);
-	set_fs (old_fs);
-	return err ? -EFAULT : 0;
+	return err;
 }
 
+
 struct loop_info32 {
 	int			lo_number;      /* ioctl r/o */
 	__kernel_dev_t32	lo_device;      /* ioctl r/o */
@@ -3822,6 +3886,15 @@ COMPATIBLE_IOCTL(CDROM_CHANGER_NSLOTS)
 COMPATIBLE_IOCTL(CDROM_LOCKDOOR)
 COMPATIBLE_IOCTL(CDROM_DEBUG)
 COMPATIBLE_IOCTL(CDROM_GET_CAPABILITY)
+/* Ignore cdrom.h about these next 5 ioctls, they absolutely do
+ * not take a struct cdrom_read, instead they take a struct cdrom_msf
+ * which is compatible.
+ */
+COMPATIBLE_IOCTL(CDROMREADMODE2)
+COMPATIBLE_IOCTL(CDROMREADMODE1)
+COMPATIBLE_IOCTL(CDROMREADRAW)
+COMPATIBLE_IOCTL(CDROMREADCOOKED)
+COMPATIBLE_IOCTL(CDROMREADALL)
 /* DVD ioctls */
 COMPATIBLE_IOCTL(DVD_READ_STRUCT)
 COMPATIBLE_IOCTL(DVD_WRITE_STRUCT)
@@ -4241,12 +4314,7 @@ HANDLE_IOCTL(MTIOCGET32, mt_ioctl_trans)
 HANDLE_IOCTL(MTIOCPOS32, mt_ioctl_trans)
 HANDLE_IOCTL(MTIOCGETCONFIG32, mt_ioctl_trans)
 HANDLE_IOCTL(MTIOCSETCONFIG32, mt_ioctl_trans)
-HANDLE_IOCTL(CDROMREADMODE2, cdrom_ioctl_trans)
-HANDLE_IOCTL(CDROMREADMODE1, cdrom_ioctl_trans)
-HANDLE_IOCTL(CDROMREADRAW, cdrom_ioctl_trans)
-HANDLE_IOCTL(CDROMREADCOOKED, cdrom_ioctl_trans)
 HANDLE_IOCTL(CDROMREADAUDIO, cdrom_ioctl_trans)
-HANDLE_IOCTL(CDROMREADALL, cdrom_ioctl_trans)
 HANDLE_IOCTL(CDROM_SEND_PACKET, cdrom_ioctl_trans)
 HANDLE_IOCTL(LOOP_SET_STATUS, loop_status)
 HANDLE_IOCTL(LOOP_GET_STATUS, loop_status)
--- linux-2.4.21/arch/ppc64/kernel/ioctl32.c.orig	2003-08-01 10:19:11.000000000 -0400
+++ linux-2.4.21/arch/ppc64/kernel/ioctl32.c	2003-08-01 10:20:30.000000000 -0400
@@ -1669,45 +1669,130 @@ struct cdrom_generic_command32 {
 	unsigned int		buflen;
 	int			stat;
 	__kernel_caddr_t32	sense;
-	__kernel_caddr_t32	reserved[3];
+	unsigned char		data_direction;
+	int			quiet;
+	int 			timeout;
+	__kernel_caddr_t32	reserved[1];
 };
 
-static int cdrom_ioctl_trans(unsigned int fd, unsigned int cmd, unsigned long arg)
+static int cdrom_do_read_audio(unsigned int fd, unsigned int cmd, 
+			       unsigned long arg)
+{
+	struct cdrom_read_audio cdread_audio;
+	struct cdrom_read_audio32 *cdread_audio32;
+	__u32 ubuf;
+	void *datap;
+	mm_segment_t old_fs;
+	int err;
+
+	cdread_audio32 = (struct cdrom_read_audio32 *) arg;
+
+	/* Copy in most of the request block from user space */
+	if (copy_from_user(&cdread_audio.addr, &cdread_audio32->addr,
+			   (sizeof(*cdread_audio32) - 
+			   sizeof(cdread_audio32->buf))))
+		return -EFAULT;
+
+	/* Grab the address of the user's receive buffer */
+	if (get_user(ubuf, &cdread_audio32->buf))
+		return -EFAULT;
+
+	/* 
+	 * Allocate a kernel buffer to receive the data. The driver will
+	 * use this address as the destination of the data transfer. Later,
+	 * the contents will be copied to the user's buffer.
+	 */
+	datap = kmalloc(cdread_audio.nframes * 2352, GFP_KERNEL);
+	if (!datap)
+		return -ENOMEM;
+	cdread_audio.buf = datap;
+
+	/* Do the real system call */
+	old_fs = get_fs();
+	set_fs (KERNEL_DS);
+	err = sys_ioctl(fd, cmd, (unsigned long) &cdread_audio);
+	set_fs (old_fs);
+
+	/* If success, copy the received data to the user's buffer */
+	if (!err && copy_to_user((char *)A(ubuf), datap, 
+				 cdread_audio.nframes * 2352))
+		err = -EFAULT;
+
+	/* Free the kernel buffer and return status to the user */
+	kfree(datap);
+	return err;
+}
+
+/*
+ * ptr32 is a buffer pointer in the 32-bit user application
+ * ptr64 is a buffer pointer in our 64-bit kernel
+ * 
+ * Copy the user pointer in, convert to 64 bit pointer, and store
+ * it at the specified location (ptr64) in the kernel.
+ */
+static int __cgc_do_ptr(void **ptr64, __u32 *ptr32)
+{
+	u32 data;
+	void *datap;
+
+	if (get_user(data, ptr32))
+		return -EFAULT;
+	datap = (void *) (unsigned long) data;
+	if (__put_user(datap, ptr64))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int cdrom_do_generic_command(unsigned int fd, unsigned int cmd, 
+				    unsigned long arg)
 {
-	mm_segment_t old_fs = get_fs();
-	struct cdrom_read_audio cdreadaudio;
 	struct cdrom_generic_command cgc;
-	__kernel_caddr_t32 addr;
-	char *data = 0;
-	void *karg;
-	int err = 0;
+	struct cdrom_generic_command32 *cgc32;
+	mm_segment_t old_fs;
+	int err;
 
-	switch(cmd) {
-	case CDROMREADAUDIO:
-		karg = &cdreadaudio;
-		err = copy_from_user(&cdreadaudio.addr, &((struct cdrom_read_audio32 *)arg)->addr, sizeof(cdreadaudio.addr));
-		err |= __get_user(cdreadaudio.addr_format, &((struct cdrom_read_audio32 *)arg)->addr_format);
-		err |= __get_user(cdreadaudio.nframes, &((struct cdrom_read_audio32 *)arg)->nframes); 
-		err |= __get_user(addr, &((struct cdrom_read_audio32 *)arg)->buf);
-		if (err)
-			return -EFAULT;
+	cgc32 = (struct cdrom_generic_command32 *) arg;
 
+	/* 
+	 * Copy the user request structure into the kernel version of
+	 * the structure. Data pointers within the user structure are
+	 * handled by __cgc_do_ptr.
+	 */
+	if (copy_from_user(cgc.cmd, &cgc32->cmd, sizeof(cgc.cmd)) ||
+	    copy_from_user(&cgc.buflen, &cgc32->buflen,
+			   sizeof(cgc.buflen) + sizeof(cgc.stat)) ||
+	    copy_from_user(&cgc.quiet, &cgc32->quiet, 
+			   sizeof(cgc.quiet) + sizeof(cgc.timeout)) ||
+	    get_user(cgc.data_direction, &cgc32->data_direction))
+		return -EFAULT;
 
-		if (verify_area(VERIFY_WRITE, (void *)A(addr), cdreadaudio.nframes*2352))
-			return -EFAULT;
-		cdreadaudio.buf = (void *)A(addr);
+	  if (__cgc_do_ptr((void **) &cgc.buffer, &cgc32->buffer) ||
+	      __cgc_do_ptr((void **) &cgc.sense, &cgc32->sense) ||
+	      __cgc_do_ptr(&cgc.reserved[0], &cgc32->reserved[0]))
+		return -EFAULT;
+
+	/* Do the real system call using the kernel version of the structure */
+	old_fs = get_fs();
+	set_fs (KERNEL_DS);
+	err = sys_ioctl (fd, cmd, (unsigned long) &cgc);
+	set_fs (old_fs);
+	return err;
+}
+
+static int cdrom_ioctl_trans(unsigned int fd, unsigned int cmd, unsigned long arg)
+{
+	int err;
+
+	switch(cmd) {
+	case CDROMREADAUDIO:
+		err = cdrom_do_read_audio(fd, cmd, arg);
 		break;
+
 	case CDROM_SEND_PACKET:
-		karg = &cgc;
-		err = copy_from_user(cgc.cmd, &((struct cdrom_generic_command32 *)arg)->cmd, sizeof(cgc.cmd));
-		err |= __get_user(addr, &((struct cdrom_generic_command32 *)arg)->buffer);
-		err |= __get_user(cgc.buflen, &((struct cdrom_generic_command32 *)arg)->buflen);
-		if (err)
-			return -EFAULT;
-		if (verify_area(VERIFY_WRITE, (void *)A(addr), cgc.buflen))
-			return -EFAULT;
-		cgc.buffer = (void *)A(addr);
+		err = cdrom_do_generic_command(fd, cmd, arg);
 		break;
+
 	default:
 		do {
 			static int count = 0;
@@ -1716,28 +1801,13 @@ static int cdrom_ioctl_trans(unsigned in
 				       "cmd(%08x) arg(%08x)\n",
 				       (int)fd, (unsigned int)cmd, (unsigned int)arg);
 		} while (0);
-		return -EINVAL;
-	}
-	set_fs (KERNEL_DS);
-	err = sys_ioctl (fd, cmd, (unsigned long)karg);
-	set_fs (old_fs);
-	if (err)
-		goto out;
-	switch (cmd) {
-	case CDROMREADAUDIO:
-		err = copy_to_user((char *)A(addr), data, cdreadaudio.nframes * 2352);
-		break;
-	case CDROM_SEND_PACKET:
-		err = copy_to_user((char *)A(addr), data, cgc.buflen);
-		break;
-	default:
+		err = -EINVAL;
 		break;
 	}
-out:	if (data)
-		kfree(data);
-	return err ? -EFAULT : 0;
+	return err;
 }
 
+
 struct loop_info32 {
 	int			lo_number;      /* ioctl r/o */
 	__kernel_dev_t32	lo_device;      /* ioctl r/o */
--- linux-2.4.21/arch/sparc64/kernel/ioctl32.c.orig	2003-06-13 10:51:32.000000000 -0400
+++ linux-2.4.21/arch/sparc64/kernel/ioctl32.c	2003-08-01 10:20:30.000000000 -0400
@@ -1920,8 +1920,8 @@ static int cdrom_do_generic_command(unsi
 	    __cgc_do_ptr((void **) &cgc->sense, &cgc32->sense))
 		return -EFAULT;
 
-	if (get_user(dir, &cgc->data_direction) ||
-	    put_user(dir, &cgc32->data_direction))
+	if (get_user(dir, &cgc32->data_direction) ||
+	    put_user(dir, &cgc->data_direction))
 		return -EFAULT;
 
 	if (copy_in_user(&cgc->quiet, &cgc32->quiet,
