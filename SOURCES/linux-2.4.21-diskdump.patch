diff -urNp linux-5170/arch/i386/kernel/process.c linux-5175/arch/i386/kernel/process.c
--- linux-5170/arch/i386/kernel/process.c
+++ linux-5175/arch/i386/kernel/process.c
@@ -412,7 +412,7 @@ void machine_restart(char * __unused)
 	 * Stop all CPUs and turn off local APICs and the IO-APIC, so
 	 * other OSs see a clean IRQ state.
 	 */
-	if (!netdump_mode)
+	if (!crashdump_mode())
 		smp_send_stop();
 	disable_IO_APIC();
 #endif
diff -urNp linux-5170/arch/i386/kernel/traps.c linux-5175/arch/i386/kernel/traps.c
--- linux-5170/arch/i386/kernel/traps.c
+++ linux-5175/arch/i386/kernel/traps.c
@@ -317,6 +317,7 @@ bug:
 }
 
 spinlock_t die_lock = SPIN_LOCK_UNLOCKED;
+static int die_owner = -1;
 
 void die(const char * str, struct pt_regs * regs, long err)
 {
@@ -335,19 +336,20 @@ void die(const char * str, struct pt_reg
 	}
 #endif	
 	console_verbose();
-	spin_lock_irq(&die_lock);
+	local_irq_disable();
+	if (!spin_trylock(&die_lock)) {
+		if (smp_processor_id() != die_owner)
+			spin_lock(&die_lock);
+		/* allow recursive die to fall through */
+	}
+	die_owner = smp_processor_id();
 	bust_spinlocks(1);
 	handle_BUG(regs);
 	printk("%s: %04lx\n", str, err & 0xffff);
 	show_registers(regs);
-	if (netdump_func)
-		netdump_func(regs);
-	if (panic_on_oops) {
-		if (netdump_func)
-			netdump_func = NULL;
-		panic("Fatal exception");
-	}
+	try_crashdump(regs);
 	bust_spinlocks(0);
+	die_owner = -1;
 	spin_unlock_irq(&die_lock);
 	do_exit(SIGSEGV);
 }
diff -urNp linux-5170/arch/ia64/kernel/ia64_ksyms.c linux-5175/arch/ia64/kernel/ia64_ksyms.c
--- linux-5170/arch/ia64/kernel/ia64_ksyms.c
+++ linux-5175/arch/ia64/kernel/ia64_ksyms.c
@@ -182,7 +182,10 @@ EXPORT_SYMBOL_GPL(iosapic_fixup_pci_inte
 #include <linux/efi.h>
 EXPORT_SYMBOL(efi_mem_type);
 
+#include <linux/elf.h>
 #include <asm/unwind.h>
+extern void ia64_do_copy_regs (struct unw_frame_info *info, void *arg);
+EXPORT_SYMBOL(ia64_do_copy_regs);
 extern void ia64_freeze_cpu (struct unw_frame_info *info, void *arg);
 EXPORT_SYMBOL(ia64_freeze_cpu);
 extern void ia64_start_dump(struct unw_frame_info *, void *arg);
diff -urNp linux-5170/arch/ia64/kernel/process.c linux-5175/arch/ia64/kernel/process.c
--- linux-5170/arch/ia64/kernel/process.c
+++ linux-5175/arch/ia64/kernel/process.c
@@ -716,3 +716,21 @@ machine_power_off (void)
 		pm_power_off();
 	machine_halt();
 }
+
+void
+ia64_freeze_cpu (struct unw_frame_info *info, void *arg)
+{
+	struct switch_stack **dst = arg;
+
+	current->thread.ksp = (__u64)info->sw - 16;
+	*dst = info->sw;
+	for (;;) __cli();
+}
+
+void
+ia64_start_dump (struct unw_frame_info *info, void *arg)
+{
+	struct dump_call_param *param = arg;
+
+	param->func(param->regs, info);
+}
diff -urNp linux-5170/arch/ia64/kernel/traps.c linux-5175/arch/ia64/kernel/traps.c
--- linux-5170/arch/ia64/kernel/traps.c
+++ linux-5175/arch/ia64/kernel/traps.c
@@ -116,13 +116,9 @@ die (const char *str, struct pt_regs *re
   	} else
 		printk(KERN_ERR "Recursive die() failure, output suppressed\n");
 
-	if (netdump_func)
-		netdump_func(regs);
-	if (panic_on_oops) {
-		if (netdump_func)
-			netdump_func = NULL;
+	try_crashdump(regs);
+	if (panic_on_oops)
 		panic("Fatal exception");
-	}
 	bust_spinlocks(0);
 	die.lock_owner = -1;
 	spin_unlock_irq(&die.lock);
diff -urNp linux-5170/arch/x86_64/kernel/process.c linux-5175/arch/x86_64/kernel/process.c
--- linux-5170/arch/x86_64/kernel/process.c
+++ linux-5175/arch/x86_64/kernel/process.c
@@ -263,6 +263,9 @@ void machine_restart(char * __unused)
 	
 	cpuid = GET_APIC_ID(apic_read(APIC_ID));
 
+	if (crashdump_mode())
+		goto reboot;
+
 	if (reboot_smp) {
 
 		/* check to see if reboot_cpu is valid 
@@ -292,6 +295,7 @@ void machine_restart(char * __unused)
 	 * other OSs see a clean IRQ state.
 	 */
 		smp_send_stop();
+reboot:
 #endif
 	disable_IO_APIC();
 	/* Could do reset through the northbridge of the Hammer here. */
diff -urNp linux-5170/arch/x86_64/kernel/traps.c linux-5175/arch/x86_64/kernel/traps.c
--- linux-5170/arch/x86_64/kernel/traps.c
+++ linux-5175/arch/x86_64/kernel/traps.c
@@ -372,14 +372,11 @@ void die(const char * str, struct pt_reg
 	}
 	die_owner = cpu; 
 	show_registers(regs);
-	if (netdump_func)
-		netdump_func(regs);
-	if (panic_on_oops) {
-		if (netdump_func)
-			netdump_func = NULL;
+	try_crashdump(regs);
+	if (panic_on_oops)
 		panic("Fatal exception");
-	}
 	bust_spinlocks(0);
+	die_owner = -1;
 	spin_unlock_irq(&die_lock);
 	do_exit(SIGSEGV);
 }
diff -urNp linux-5170/arch/x86_64/kernel/x8664_ksyms.c linux-5175/arch/x86_64/kernel/x8664_ksyms.c
--- linux-5170/arch/x86_64/kernel/x8664_ksyms.c
+++ linux-5175/arch/x86_64/kernel/x8664_ksyms.c
@@ -25,6 +25,7 @@
 #include <asm/irq.h>
 #include <asm/mmx.h>
 #include <asm/nmi.h>
+#include <linux/nmi.h>
 #include <asm/desc.h>
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
@@ -128,10 +129,13 @@ EXPORT_SYMBOL(smp_call_function);
 EXPORT_SYMBOL(flush_tlb_page);
 #endif
 
-#if defined(CONFIG_X86_LOCAL_APIC) && defined(CONFIG_PM)
+#ifdef CONFIG_X86_LOCAL_APIC
+EXPORT_SYMBOL_GPL(touch_nmi_watchdog);
+#ifdef CONFIG_PM
 EXPORT_SYMBOL_GPL(set_nmi_pm_callback);
 EXPORT_SYMBOL_GPL(unset_nmi_pm_callback);
 #endif
+#endif
 
 #ifdef CONFIG_MCA
 EXPORT_SYMBOL(machine_id);
diff -urNp linux-5170/arch/x86_64/mm/init.c linux-5175/arch/x86_64/mm/init.c
--- linux-5170/arch/x86_64/mm/init.c
+++ linux-5175/arch/x86_64/mm/init.c
@@ -526,6 +526,39 @@ void free_bootmem_generic(unsigned long 
 #endif
 }
 
+#define __VIRTUAL_MASK_SHIFT	48
+
+int kern_addr_valid(unsigned long addr)
+{
+	unsigned long above = ((long)addr) >> __VIRTUAL_MASK_SHIFT;
+       pml4_t *pml4;
+       pgd_t *pgd;
+       pmd_t *pmd;
+       pte_t *pte;
+
+	if (above != 0 && above != -1UL)
+		return 0;
+	
+       pml4 = pml4_offset_k(addr);
+	if (pml4_none(*pml4))
+		return 0;
+
+       pgd = pgd_offset_k(addr);
+	if (pgd_none(*pgd))
+		return 0;
+
+       pmd = pmd_offset(pgd, addr);
+	if (pmd_none(*pmd))
+		return 0;
+	if (pmd_large(*pmd))
+		return pfn_valid(pte_pfn(*(pte_t *)pmd));
+
+       pte = pte_offset_kernel(pmd, addr);
+	if (pte_none(*pte))
+		return 0;
+	return pfn_valid(pte_pfn(*pte));
+}
+
 /* Unmap a kernel mapping if it exists. This is useful to avoid prefetches
    from the CPU leading to inconsistent cache lines. address and size
    must be aligned to 2MB boundaries.
diff -urNp linux-5170/drivers/block/Config.in linux-5175/drivers/block/Config.in
--- linux-5170/drivers/block/Config.in
+++ linux-5175/drivers/block/Config.in
@@ -50,4 +50,6 @@ dep_bool '  Initial RAM disk (initrd) su
 
 bool 'Per partition statistics in /proc/partitions' CONFIG_BLK_STATS
 
+tristate 'Disk dump support' CONFIG_DISKDUMP
+
 endmenu
diff -urNp linux-5170/drivers/block/Makefile linux-5175/drivers/block/Makefile
--- linux-5170/drivers/block/Makefile
+++ linux-5175/drivers/block/Makefile
@@ -10,7 +10,7 @@
 
 O_TARGET := block.o
 
-export-objs	:= ll_rw_blk.o blkpg.o elevator.o loop.o DAC960.o genhd.o acsi.o
+export-objs	:= ll_rw_blk.o blkpg.o elevator.o loop.o DAC960.o genhd.o acsi.o diskdump.o diskdumplib.o
 
 obj-y	:= ll_rw_blk.o blkpg.o genhd.o elevator.o
 
@@ -31,6 +31,7 @@ obj-$(CONFIG_BLK_CPQ_CISS_DA)  += cciss.
 obj-$(CONFIG_BLK_DEV_DAC960)	+= DAC960.o
 obj-$(CONFIG_BLK_DEV_UMEM)	+= umem.o
 obj-$(CONFIG_BLK_DEV_NBD)	+= nbd.o
+obj-$(CONFIG_DISKDUMP)		+= diskdump.o diskdumplib.o
 
 subdir-$(CONFIG_PARIDE) += paride
 
diff -urNp linux-5170/drivers/block/blkpg.c linux-5175/drivers/block/blkpg.c
--- linux-5170/drivers/block/blkpg.c
+++ linux-5175/drivers/block/blkpg.c
@@ -40,6 +40,26 @@
 #include <asm/uaccess.h>
 
 /*
+ *  Dump  stuff.
+ */
+void (*diskdump_func)(struct pt_regs *regs, void *platform_arg) = NULL;
+
+int diskdump_register_hook(void (*dump_func)(struct pt_regs *, void *))
+{
+	if (diskdump_func)
+		return -EEXIST;
+
+	diskdump_func = dump_func;
+
+	return 0;
+}
+
+void diskdump_unregister_hook(void)
+{
+	diskdump_func = NULL;
+}
+
+/*
  * What is the data describing a partition?
  *
  * 1. a device number (kdev_t)
diff -urNp linux-5170/drivers/block/diskdump.c linux-5175/drivers/block/diskdump.c
--- linux-5170/drivers/block/diskdump.c
+++ linux-5175/drivers/block/diskdump.c
@@ -0,0 +1,1052 @@
+/*
+ *  linux/drivers/block/diskdump.c
+ *
+ *  Copyright (C) 2004  FUJITSU LIMITED
+ *  Copyright (C) 2002  Red Hat, Inc.
+ *  Written by Nobuhiro Tachino (ntachino@jp.fujitsu.com)
+ *
+ *  Some codes were derived from netdump and copyright belongs to
+ *  Red Hat, Inc.
+ */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/file.h>
+#include <linux/reboot.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/highmem.h>
+#include <linux/utsname.h>
+#include <linux/console.h>
+#include <linux/smp_lock.h>
+#include <linux/nmi.h>
+#include <linux/genhd.h>
+#include <linux/crc32.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/blkdev.h>
+#include <linux/swap.h>
+#include <linux/diskdump.h>
+#include <linux/diskdumplib.h>
+#include <linux/blk.h>
+#include <asm/diskdump.h>
+
+#define DEBUG 0
+#if DEBUG
+# define Dbg(x, ...) printk(KERN_INFO "disk_dump:" x "\n", ## __VA_ARGS__)
+#else
+# define Dbg(x...)
+#endif
+
+#define Err(x, ...)	printk(KERN_ERR "disk_dump: " x "\n", ## __VA_ARGS__);
+#define Warn(x, ...)	printk(KERN_WARNING "disk_dump: " x "\n", ## __VA_ARGS__)
+#define Info(x, ...)	printk(KERN_INFO "disk_dump: " x "\n", ## __VA_ARGS__)
+
+#ifndef TRUE
+#define TRUE	1
+#endif
+#ifndef FALSE
+#define FALSE	0
+#endif
+
+#define KM_DISKDUMP		KM_NETDUMP
+
+#define ROUNDUP(x, y)	(((x) + ((y)-1))/(y))
+
+/* 512byte sectors to blocks */
+#define SECTOR_BLOCK(s)	((s) >> (DUMP_BLOCK_SHIFT - 9))
+
+/* The number of block which is used for saving format information */
+#define USER_PARAM_BLOCK	2
+
+static unsigned int fallback_on_err = 1;
+static unsigned int allow_risky_dumps = 1;
+static unsigned int block_order = 2;
+static unsigned int sample_rate = 8;
+MODULE_PARM(fallback_on_err, "i");
+MODULE_PARM(allow_risky_dumps, "i");
+MODULE_PARM(block_order, "i");
+MODULE_PARM(sample_rate, "i");
+
+static unsigned long timestamp_1sec;
+static uint32_t module_crc;
+static char *scratch;
+static struct disk_dump_header dump_header;
+static struct disk_dump_sub_header dump_sub_header;
+
+/* Registered dump devices */
+static LIST_HEAD(disk_dump_devices);
+
+/* Registered dump types, e.g. SCSI, ... */
+static LIST_HEAD(disk_dump_types);
+
+static spinlock_t disk_dump_lock = SPIN_LOCK_UNLOCKED;
+
+
+static unsigned int header_blocks;		/* The size of all headers */
+static unsigned int bitmap_blocks;		/* The size of bitmap header */
+static unsigned int total_ram_blocks;		/* The size of memory */
+static unsigned int total_blocks;		/* The sum of above */
+
+#if CONFIG_SMP
+static void freeze_cpu(void *dummy)
+{
+	unsigned int cpu = smp_processor_id();
+
+	dump_header.tasks[cpu] = current;
+
+	platform_freeze_cpu();
+}
+#endif
+
+static int lapse = 0;		/* 200msec unit */
+
+static inline unsigned long eta(unsigned long nr, unsigned long maxnr)
+{
+	unsigned long long eta;
+
+	eta = ((maxnr << 8) / nr) * (unsigned long long)lapse;
+
+	return (unsigned long)(eta >> 8) - lapse;
+}
+
+static inline void print_status(unsigned int nr, unsigned int maxnr)
+{
+	static char *spinner = "/|\\-";
+	static unsigned long long prev_timestamp = 0;
+	unsigned long long timestamp;
+
+	platform_timestamp(timestamp);
+
+	if (timestamp - prev_timestamp > (timestamp_1sec/5)) {
+		prev_timestamp = timestamp;
+		lapse++;
+		printk("%u/%u    %lu ETA %c          \r",
+			nr, maxnr, eta(nr, maxnr) / 5, spinner[lapse & 3]);
+	}
+}
+
+static inline void clear_status(int nr, int maxnr)
+{
+	printk("                                       \r");
+	lapse = 0;
+}
+
+/*
+ * Checking the signature on a block. The format is as follows.
+ *
+ * 1st word = 'disk'
+ * 2nd word = 'dump'
+ * 3rd word = block number
+ * 4th word = ((block number + 7) * 11) & 0xffffffff
+ * 5th word = ((4th word + 7)* 11) & 0xffffffff
+ * ..
+ *
+ * Return TRUE if the signature is correct, else return FALSE
+ */
+static int check_block_signature(void *buf, unsigned int block_nr)
+{
+	int word_nr = PAGE_SIZE / sizeof(int);
+	int *words = buf;
+	unsigned int val;
+	int i;
+
+	/*
+	* Block 2 is used for the area which formatter saves options like
+	* the sampling rate or the number of blocks. the Kernel part does not
+	* check this block.
+	*/
+	if (block_nr == USER_PARAM_BLOCK)
+		return 1;
+
+	if (memcmp(buf, DUMP_PARTITION_SIGNATURE, sizeof(*words)))
+		return FALSE;
+
+	val = block_nr;
+	for (i = 2; i < word_nr; i++) {
+		if (words[i] != val)
+			return FALSE;
+		val = (val + 7) * 11;
+	}
+
+	return TRUE;
+}
+
+/*
+ * Read one block into the dump partition
+ */
+static int read_blocks(struct disk_dump_partition *dump_part, unsigned int nr, char *buf, int len)
+{
+	struct disk_dump_device *device = dump_part->device;
+	int ret;
+
+	touch_nmi_watchdog();
+	__cli();
+	ret = device->ops.rw_block(dump_part, READ, nr, buf, len);
+	if (ret < 0) {
+		Err("read error on block %u", nr);
+		return ret;
+	}
+	return 0;
+}
+
+static int write_blocks(struct disk_dump_partition *dump_part, unsigned int offs, char *buf, int len)
+{
+	struct disk_dump_device *device = dump_part->device;
+	int ret;
+
+	touch_nmi_watchdog();
+	__cli();
+	ret = device->ops.rw_block(dump_part, WRITE, offs, buf, len);
+	if (ret < 0) {
+		Err("write error on block %u", offs);
+		return ret;
+	}
+	return 0;
+}
+
+/*
+ * Initialize the common header
+ */
+
+/*
+ * Write the common header
+ */
+static int write_header(struct disk_dump_partition *dump_part)
+{
+	memset(scratch, '\0', PAGE_SIZE);
+	memcpy(scratch, &dump_header, sizeof(dump_header));
+
+	return write_blocks(dump_part, 1, scratch, 1);
+}
+
+/*
+ * Check the signaures in all blocks of the dump partition
+ * Return TRUE if the signature is correct, else return FALSE
+ */
+static int check_dump_partition(struct disk_dump_partition *dump_part, unsigned int partition_size)
+{
+	unsigned int blk;
+	int ret;
+	unsigned int chunk_blks, skips;
+	int i;
+
+	if (sample_rate < 0)		/* No check */
+		return TRUE;
+
+	/*
+	 * If the device has limitations of transfer size, use it.
+	 */
+	chunk_blks = 1 << block_order;
+	if (dump_part->device->max_blocks &&
+	    dump_part->device->max_blocks < chunk_blks)
+		Warn("I/O size exceeds the maximum block size of SCSI device, signature check may fail");
+	skips = chunk_blks << sample_rate;
+
+	lapse = 0;
+	for (blk = 0; blk < partition_size; blk += skips) {
+		unsigned int len;
+redo:
+		len = min(chunk_blks, partition_size - blk);
+		if ((ret = read_blocks(dump_part, blk, scratch, len)) < 0)
+			return FALSE;
+		print_status(blk + 1, partition_size);
+		for (i = 0; i < len; i++)
+			if (!check_block_signature(scratch + i * DUMP_BLOCK_SIZE, blk + i)) {
+				Err("bad signature in block %u", blk + i);
+				return FALSE;
+			}
+	}
+	/* Check the end of the dump partition */
+	if (blk - skips + chunk_blks < partition_size) {
+		blk = partition_size - chunk_blks;
+		goto redo;
+	}
+	clear_status(blk, partition_size);
+	return TRUE;
+}
+
+/*
+ * Check the signaures in the first blocks of the swap partition
+ * Return 1 if the signature is correct, else return 0
+ */
+static int check_swap_partition(struct disk_dump_partition *dump_part,
+					    unsigned int partition_size)
+{
+	int ret;
+	union swap_header *swh;
+
+	if ((ret = read_blocks(dump_part, 0, scratch, 1)) < 0)
+	   return 0;
+
+	swh = (union swap_header *)scratch;
+
+	if (memcmp(swh->magic.magic, "SWAPSPACE2",
+						sizeof("SWAPSPACE2") - 1) != 0)
+								     return 0;
+
+	if (swh->info.version != 1)
+	   return 0;
+
+	if (swh->info.last_page + 1 != SECTOR_BLOCK(dump_part->nr_sects) ||
+				  swh->info.last_page < partition_size)
+						      return 0;
+
+	return 1;
+}
+
+/*
+ * Write memory bitmap after location of dump headers.
+ */
+#define IDX2PAGENR(nr, byte, bit)	(((nr) * PAGE_SIZE + (byte)) * 8 + (bit))
+static int write_bitmap(struct disk_dump_partition *dump_part, unsigned int bitmap_offset, unsigned int bitmap_blocks)
+{
+	unsigned int nr;
+	int bit, byte;
+	int ret = 0;
+	unsigned char val;
+
+	for (nr = 0; nr < bitmap_blocks; nr++) {
+		for (byte = 0; byte < PAGE_SIZE; byte++) {
+			val = 0;
+			for (bit = 0; bit < 8; bit++)
+				if (page_is_ram(IDX2PAGENR(nr, byte, bit)))
+					val |= (1 << bit);
+			scratch[byte] = (char)val;
+		}
+		if ((ret = write_blocks(dump_part, bitmap_offset + nr, scratch, 1)) < 0) {
+			Err("I/O error %d on block %u", ret, bitmap_offset + nr);
+			break;
+		}
+	}
+	return ret;
+}
+
+/*
+ * Write whole memory to dump partition.
+ * Return value is the number of writen blocks.
+ */
+static int write_memory(struct disk_dump_partition *dump_part, int offset, unsigned int max_blocks_written, unsigned int *blocks_written)
+{
+	char *kaddr;
+	unsigned int blocks = 0;
+	struct page *page;
+	unsigned long nr;
+	int ret = 0;
+	int blk_in_chunk = 0;
+
+	for (nr = 0; nr < max_mapnr; nr++) {
+		if (!page_is_ram(nr))
+			continue;
+
+		if (blocks >= max_blocks_written) {
+			Warn("dump device is too small. %lu pages were not saved", max_mapnr - blocks);
+			goto out;
+		}
+		page = pfn_to_page(nr);
+		kaddr = kmap_atomic(page, KM_DISKDUMP);
+
+		if (kern_addr_valid((unsigned long)kaddr)) {
+			/*
+			 * need to copy because adapter drivers use virt_to_bus()
+			 */
+			memcpy(scratch + blk_in_chunk * PAGE_SIZE, kaddr, PAGE_SIZE);
+		} else {
+			memset(scratch + blk_in_chunk * PAGE_SIZE, 0, PAGE_SIZE);
+			sprintf(scratch + blk_in_chunk * PAGE_SIZE,
+				"Unmapped page. PFN %lu\n", nr);
+			printk("Unmapped page. PFN %lu\n", nr);
+		}
+
+		blk_in_chunk++;
+		blocks++;
+		kunmap_atomic(kaddr, KM_DISKDUMP);
+
+		if (blk_in_chunk >= (1 << block_order)) {
+			ret = write_blocks(dump_part, offset, scratch, blk_in_chunk);
+			if (ret < 0) {
+				Err("I/O error %d on block %u", ret, offset);
+				break;
+			}
+			offset += blk_in_chunk;
+			blk_in_chunk = 0;
+			print_status(blocks, max_blocks_written);
+		}
+	}
+	if (ret >= 0 && blk_in_chunk > 0) {
+		ret = write_blocks(dump_part, offset, scratch, blk_in_chunk);
+		if (ret < 0)
+			Err("I/O error %d on block %u", ret, offset);
+	}
+
+out:
+	clear_status(nr, max_blocks_written);
+
+	*blocks_written = blocks;
+	return ret;
+}
+
+/*
+ * Select most suitable dump device. sanity_check() returns the state
+ * of each dump device. 0 means OK, negative value means NG, and
+ * positive value means it maybe work. select_dump_partition() first
+ * try to select a sane device and if it has no sane device and
+ * allow_risky_dumps is set, it select one from maybe OK devices.
+ *
+ * XXX We cannot handle multiple partitions yet.
+ */
+static struct disk_dump_partition *select_dump_partition(void)
+{
+	struct disk_dump_device *dump_device;
+	struct disk_dump_partition *dump_part;
+	int sanity;
+	int strict_check = 1;
+
+redo:
+	/*
+	 * Select a sane polling driver.
+	 */
+	list_for_each_entry(dump_device, &disk_dump_devices, list) {
+		sanity = 0;
+		if (dump_device->ops.sanity_check)
+			sanity = dump_device->ops.sanity_check(dump_device);
+		if (sanity < 0 || (sanity > 0 && strict_check))
+			continue;
+		list_for_each_entry(dump_part, &dump_device->partitions, list)
+				return dump_part;
+	}
+	if (allow_risky_dumps && strict_check) {
+		strict_check = 0;
+		goto redo;
+	}
+	return NULL;
+}
+
+static void disk_dump(struct pt_regs *regs, void *platform_arg)
+{
+	unsigned long flags;
+	int ret = -EIO;
+	struct pt_regs myregs;
+	unsigned int max_written_blocks, written_blocks;
+	int i;
+	struct disk_dump_device *dump_device = NULL;
+	struct disk_dump_partition *dump_part = NULL;
+
+	/* Inhibit interrupt and stop other CPUs */
+	__save_flags(flags);
+	__cli();
+
+	diskdump_lib_init();
+
+	/*
+	 * Check the checksum of myself
+	 */
+	spin_trylock(&disk_dump_lock);
+	if (!check_crc_module()) {
+		Err("checksum error. diskdump common module may be compromised.");
+		goto done;
+	}
+
+	diskdump_mode = 1;
+
+	Dbg("notify dump start.");
+	notifier_call_chain(&disk_dump_notifier_list, 0, NULL);
+
+#if CONFIG_SMP
+	dump_smp_call_function(freeze_cpu, NULL);
+	mdelay(3000);
+	printk("CPU frozen: ");
+	for (i = 0; i < NR_CPUS; i++) {
+		if (dump_header.tasks[i] != NULL)
+			printk("#%d", i);
+
+	}
+	printk("\n");
+	printk("CPU#%d is executing diskdump.\n", smp_processor_id());
+#else
+	mdelay(1000);
+#endif
+	dump_header.tasks[smp_processor_id()] = current;
+
+	platform_fix_regs();
+
+	if (list_empty(&disk_dump_devices)) {
+		Err("adapter driver is not registered.");
+		goto done;
+	}
+
+	printk("start dumping\n");
+
+	if (!(dump_part = select_dump_partition())) {
+		Err("No sane dump device found");
+		goto done;
+	}
+	dump_device = dump_part->device;
+
+	/* Force to Initialize io_request_lock */
+	io_request_lock = SPIN_LOCK_UNLOCKED;
+
+	/*
+	 * Stop ongoing I/O with polling driver and make the shift to I/O mode
+	 * for dump
+	 */
+	Dbg("do quiesce");
+	if (dump_device->ops.quiesce)
+		if ((ret = dump_device->ops.quiesce(dump_device)) < 0) {
+			Err("quiesce failed. error %d", ret);
+			goto done;
+		}
+
+	if (SECTOR_BLOCK(dump_part->nr_sects) < header_blocks + bitmap_blocks) {
+		Warn("dump partition is too small. Aborted");
+		ret = -EIO;
+		goto done;
+	}
+
+	/* Check dump partition */
+	printk("check dump partition...\n");
+	if (!check_swap_partition(dump_part, total_blocks) &&
+	    !check_dump_partition(dump_part, total_blocks)) {
+		Err("check partition failed.");
+		ret = -EIO;
+		goto done;
+	}
+
+	/*
+	 * Write the common header
+	 */
+	memcpy(dump_header.signature, DISK_DUMP_SIGNATURE, sizeof(dump_header.signature));
+	dump_header.header_version   = DISK_DUMP_HEADER_VERSION;
+	dump_header.utsname	     = system_utsname;
+	dump_header.timestamp	     = xtime;
+	dump_header.status	     = DUMP_HEADER_INCOMPLETED;
+	dump_header.block_size	     = PAGE_SIZE;
+	dump_header.sub_hdr_size     = size_of_sub_header();
+	dump_header.bitmap_blocks    = bitmap_blocks;
+	dump_header.max_mapnr	     = max_mapnr;
+	dump_header.total_ram_blocks = total_ram_blocks;
+	dump_header.device_blocks    = SECTOR_BLOCK(dump_part->nr_sects);
+	dump_header.current_cpu      = smp_processor_id();
+	dump_header.nr_cpus          = NR_CPUS;
+	dump_header.written_blocks   = 2;
+
+	write_header(dump_part);
+
+	/*
+	 * Write the architecture dependent header
+	 */
+	Dbg("write sub header");
+	if ((ret = write_sub_header()) < 0) {
+		Err("writing sub header failed. error %d", ret);
+		goto done;
+	}
+
+	Dbg("writing memory bitmaps..");
+	if ((ret = write_bitmap(dump_part, header_blocks, bitmap_blocks)) < 0)
+		goto done;
+
+	max_written_blocks = total_ram_blocks;
+	if (dump_header.device_blocks < total_blocks) {
+		Warn("dump partition is too small. actual blocks %u. expected blocks %u. whole memory will not be saved",
+				dump_header.device_blocks, total_blocks);
+		max_written_blocks -= (total_blocks - dump_header.device_blocks);
+	}
+
+	dump_header.written_blocks += dump_header.sub_hdr_size;
+	dump_header.written_blocks += dump_header.bitmap_blocks;
+	write_header(dump_part);
+
+	printk("dumping memory..\n");
+	if ((ret = write_memory(dump_part, header_blocks + bitmap_blocks,
+				max_written_blocks, &written_blocks)) < 0)
+		goto done;
+
+	/*
+	 * Set the number of block that is written into and write it
+	 * into partition again.
+	 */
+	dump_header.written_blocks += written_blocks;
+	dump_header.status = DUMP_HEADER_COMPLETED;
+	write_header(dump_part);
+
+	ret = 0;
+
+done:
+	Dbg("do adapter shutdown.");
+	if (dump_device && dump_device->ops.shutdown)
+		if (dump_device->ops.shutdown(dump_device))
+			Err("adapter shutdown failed.");
+
+	/*
+	 * If diskdump failed and fallback_on_err is set,
+	 * We just return and leave panic to netdump.
+	 */
+	if (fallback_on_err && ret != 0)
+		return;
+
+	Dbg("notify panic.");
+	notifier_call_chain(&panic_notifier_list, 0, NULL);
+
+	diskdump_lib_exit();
+
+	if (panic_timeout > 0) {
+		int i;
+
+		printk(KERN_EMERG "Rebooting in %d second%s..",
+			panic_timeout, "s" + (panic_timeout == 1));
+		for (i = 0; i < panic_timeout; i++) {
+			touch_nmi_watchdog();
+			mdelay(1000);
+		}
+		printk("\n");
+		machine_restart(NULL);
+	}
+	printk(KERN_EMERG "halt\n");
+	for (;;) {
+		touch_nmi_watchdog();
+		machine_halt();
+		mdelay(1000);
+	}
+}
+
+static struct disk_dump_partition *find_dump_partition(kdev_t dev)
+{
+	struct disk_dump_device *dump_device;
+	struct disk_dump_partition *dump_part;
+
+	list_for_each_entry(dump_device, &disk_dump_devices, list)
+		list_for_each_entry(dump_part, &dump_device->partitions, list)
+			if (dump_part->dentry->d_inode->i_rdev == dev)
+				return dump_part;
+	return NULL;
+}
+
+static struct disk_dump_device *find_dump_device(void *real_device)
+{
+	struct disk_dump_device *dump_device;
+
+	list_for_each_entry(dump_device, &disk_dump_devices, list)
+		if (real_device == dump_device->device)
+			return  dump_device;
+	return NULL;
+}
+
+static void *find_real_device(kdev_t dev, struct disk_dump_type **_dump_type)
+{
+	void *real_device;
+	struct disk_dump_type *dump_type;
+	list_t *t;
+
+	list_for_each_entry(dump_type, &disk_dump_types, list)
+		if ((real_device = dump_type->probe(dev)) != NULL) {
+			*_dump_type = dump_type;
+			return real_device;
+		}
+	return NULL;
+}
+
+/*
+ * Add dump partition structure corresponding to file to the dump device
+ * structure.
+ */
+static int add_dump_partition(struct disk_dump_device *dump_device, struct file *file)
+{
+	struct disk_dump_partition *dump_part;
+	struct inode *inode = file->f_dentry->d_inode;
+	kdev_t dev = inode->i_rdev;
+	struct gendisk *gd;
+
+	if (!(dump_part = kmalloc(sizeof(*dump_part), GFP_KERNEL)))
+		return -ENOMEM;
+
+	dump_part->device   = dump_device;
+	dump_part->vfsmount = mntget(file->f_vfsmnt);
+	dump_part->dentry   = dget(file->f_dentry);
+
+	gd = get_gendisk(inode->i_rdev);
+	if (!gd)
+		return -EINVAL;
+	dump_part->nr_sects   = gd->part[MINOR(dev)].nr_sects;
+	dump_part->start_sect = gd->part[MINOR(dev)].start_sect;
+
+	if (SECTOR_BLOCK(dump_part->nr_sects) < total_blocks)
+		Warn("%s is too small to save whole system memory\n", kdevname(dev));
+
+	list_add(&dump_part->list, &dump_device->partitions);
+
+	return 0;
+}
+
+/*
+ * Add dump partition corresponding to file.
+ * Must be called with disk_dump_lock held.
+ */
+static int add_dump(struct file *file)
+{
+	struct disk_dump_type *dump_type = NULL;
+	struct disk_dump_device *dump_device;
+	void *real_device;
+	kdev_t dev = file->f_dentry->d_inode->i_rdev;
+	int ret;
+
+	/* Check whether this inode is already registered */
+	if (find_dump_partition(dev))
+		return -EEXIST;
+
+	/* find dump_type and real device for this inode */
+	if (!(real_device = find_real_device(dev, &dump_type)))
+		return -ENXIO;
+
+	dump_device = find_dump_device(real_device);
+	if (dump_device == NULL) {
+		/* real_device is not registered. create new dump_device */
+		if (!(dump_device = kmalloc(sizeof(*dump_device), GFP_KERNEL)))
+			return -ENOMEM;
+
+		memset(dump_device, 0, sizeof(*dump_device));
+		INIT_LIST_HEAD(&dump_device->partitions);
+
+		dump_device->dump_type = dump_type;
+		dump_device->device = real_device;
+		if ((ret = dump_type->add_device(dump_device)) < 0) {
+			kfree(dump_device);
+			return ret;
+		}
+		__MOD_INC_USE_COUNT(dump_type->owner);
+		list_add(&dump_device->list, &disk_dump_devices);
+	}
+
+	ret = add_dump_partition(dump_device, file);
+	if (ret < 0) {
+		dump_type->remove_device(dump_device);
+		__MOD_DEC_USE_COUNT(dump_type->owner);
+		list_del(&dump_device->list);
+		kfree(dump_device);
+	}
+
+	return ret;
+}
+
+/*
+ * Remove user specified dump partition.
+ * Must be called with disk_dump_lock held.
+ */
+static int remove_dump(kdev_t dev)
+{
+	struct disk_dump_device *dump_device;
+	struct disk_dump_partition *dump_part;
+	struct disk_dump_type *dump_type;
+
+	if (!(dump_part = find_dump_partition(dev)))
+		return -ENOENT;
+
+	dump_device = dump_part->device;
+
+	list_del(&dump_part->list);
+	mntput(dump_part->vfsmount);
+	dput(dump_part->dentry);
+	kfree(dump_part);
+
+	if (list_empty(&dump_device->partitions)) {
+		dump_type = dump_device->dump_type;
+		dump_type->remove_device(dump_device);
+		__MOD_DEC_USE_COUNT(dump_type->owner);
+		list_del(&dump_device->list);
+		kfree(dump_device);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PROC_FS
+static int proc_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long param)
+{
+	int fd = (int)param;
+	int ret;
+	struct file *dump_file;
+	struct inode *dump_inode;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	dump_file = fget(fd);
+	if (!dump_file)
+		return -EBADF;
+	dump_inode = dump_file->f_dentry->d_inode;
+	if (!S_ISBLK(dump_inode->i_mode)) {
+		fput(dump_file);
+		return -EBADF;
+	}
+
+	spin_lock(&disk_dump_lock);
+	switch (cmd) {
+	case BLKADDDUMPDEVICE:
+		ret = add_dump(dump_file);
+		break;
+	case BLKREMOVEDUMPDEVICE:
+		ret = remove_dump(dump_inode->i_rdev);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	set_crc_modules();
+	spin_unlock(&disk_dump_lock);
+
+	fput(dump_file);
+
+	return ret;
+}
+
+static struct disk_dump_partition *dump_part_by_pos(struct seq_file *seq,
+						    loff_t pos)
+{
+	struct disk_dump_device *dump_device;
+	struct disk_dump_partition *dump_part;
+	list_t *p;
+
+	list_for_each_entry(dump_device, &disk_dump_devices, list) {
+		seq->private = dump_device;
+		list_for_each_entry(dump_part, &dump_device->partitions, list)
+			if (!pos--)
+				return dump_part;
+	}
+	return NULL;
+}
+
+static void *disk_dump_seq_start(struct seq_file *seq, loff_t *pos)
+{
+	loff_t n = *pos;
+
+	if (!n--)
+		return (void *)1;	/* header */
+
+	spin_lock(&disk_dump_lock);
+	return dump_part_by_pos(seq, n);
+}
+
+static void *disk_dump_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	list_t *partition = v;
+	list_t *device = seq->private;
+	struct disk_dump_device *dump_device;
+
+	(*pos)++;
+	if (v == (void *)1)
+		return dump_part_by_pos(seq, 0);
+
+	dump_device = list_entry(device, struct disk_dump_device, list);
+
+	partition = partition->next;
+	if (partition != &dump_device->partitions)
+		return partition;
+
+	device = device->next;
+	seq->private = device;
+	if (device == &disk_dump_devices)
+		return NULL;
+
+	dump_device = list_entry(device, struct disk_dump_device, list);
+
+	return dump_device->partitions.next;
+}
+
+static void disk_dump_seq_stop(struct seq_file *seq, void *v)
+{
+	spin_unlock(&disk_dump_lock);
+}
+
+static int disk_dump_seq_show(struct seq_file *seq, void *v)
+{
+	struct disk_dump_partition *dump_part = v;
+	char *page;
+	char *path;
+
+	if (v == (void *)1) {	/* header */
+		seq_printf(seq, "# sample_rate: %u\n", sample_rate);
+		seq_printf(seq, "# block_order: %u\n", block_order);
+		seq_printf(seq, "# fallback_on_err: %u\n", fallback_on_err);
+		seq_printf(seq, "# allow_risky_dumps: %u\n", allow_risky_dumps);
+		seq_printf(seq, "# total_blocks: %u\n", total_blocks);
+		seq_printf(seq, "#\n");
+
+		return 0;
+	}
+
+	if (!(page = (char *)__get_free_page(GFP_KERNEL)))
+		return -ENOMEM;
+	path = d_path(dump_part->dentry, dump_part->vfsmount, page, PAGE_SIZE);
+	seq_printf(seq, "%s %lu %lu\n",
+		path, dump_part->start_sect, dump_part->nr_sects);
+	free_page((unsigned long)page);
+	return 0;
+}
+
+static struct seq_operations disk_dump_seq_ops = {
+	.start	= disk_dump_seq_start,
+	.next	= disk_dump_seq_next,
+	.stop	= disk_dump_seq_stop,
+	.show	= disk_dump_seq_show,
+};
+
+static int disk_dump_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &disk_dump_seq_ops);
+}
+
+static struct file_operations disk_dump_fops = {
+	.owner		= THIS_MODULE,
+	.open		= disk_dump_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+	.ioctl		= proc_ioctl,
+};
+#endif
+
+
+int register_disk_dump_type(struct disk_dump_type *dump_type)
+{
+	spin_lock(&disk_dump_lock);
+	list_add(&dump_type->list, &disk_dump_types);
+	set_crc_modules();
+	list_for_each_entry(dump_type, &disk_dump_types, list)
+		if (dump_type->compute_cksum)
+			dump_type->compute_cksum();
+	spin_unlock(&disk_dump_lock);
+
+	return 0;
+}
+
+int unregister_disk_dump_type(struct disk_dump_type *dump_type)
+{
+	spin_lock(&disk_dump_lock);
+	list_del(&dump_type->list);
+	set_crc_modules();
+	spin_unlock(&disk_dump_lock);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(register_disk_dump_type);
+EXPORT_SYMBOL(unregister_disk_dump_type);
+
+
+static void compute_total_blocks(void)
+{
+	unsigned int nr;
+
+	/*
+	 * the number of block of the common header and the header
+	 * that is depend on the architecture
+	 *
+	 * block 0:		dump partition header
+	 * block 1:		dump header
+	 * block 2:		dump subheader
+	 * block 3..n:		memory bitmap
+	 * block (n + 1)...:	saved memory
+	 *
+	 * We never overwrite block 0
+	 */
+	header_blocks = 2 + size_of_sub_header();
+
+	total_ram_blocks = 0;
+	for (nr = 0; nr < max_mapnr; nr++) {
+		if (page_is_ram(nr))
+			total_ram_blocks++;
+	}
+
+	bitmap_blocks = ROUNDUP(max_mapnr, 8 * PAGE_SIZE);
+
+	/*
+	 * The necessary size of area for dump is:
+	 * 1 block for common header
+	 * m blocks for architecture dependent header
+	 * n blocks for memory bitmap
+	 * and whole memory
+	 */
+	total_blocks = header_blocks + bitmap_blocks + total_ram_blocks;
+
+	Info("total blocks required: %u (header %u + bitmap %u + memory %u)",
+		total_blocks, header_blocks, bitmap_blocks, total_ram_blocks);
+}
+
+static int init_diskdump(void)
+{
+	unsigned long long t0;
+	unsigned long long t1;
+	struct page *page;
+
+	if (!platform_supports_diskdump) {
+		Err("platform does not support diskdump.");
+		return -1;
+	}
+
+	/* Allocate one block that is used temporally */
+	do {
+		page = alloc_pages(GFP_KERNEL, block_order);
+		if (page != NULL)
+			break;
+	} while (--block_order >= 0);
+	if (!page) {
+		Err("alloc_pages failed.");
+		return -1;
+	}
+	scratch = page_address(page);
+	Info("Maximum block size: %lu", PAGE_SIZE << block_order);
+
+	if (diskdump_register_hook(disk_dump)) {
+		Err("failed to register hooks.");
+		return -1;
+	}
+
+	compute_total_blocks();
+
+	platform_timestamp(t0);
+	mdelay(1);
+	platform_timestamp(t1);
+	timestamp_1sec = (unsigned long)(t1 - t0) * 1000;
+
+#ifdef CONFIG_PROC_FS
+	{
+		struct proc_dir_entry *p;
+
+		p = create_proc_entry("diskdump", S_IRUGO|S_IWUSR, NULL);
+		if (p)
+			p->proc_fops = &disk_dump_fops;
+	}
+#endif
+
+	return 0;
+}
+
+static void cleanup_diskdump(void)
+{
+	Info("shut down.");
+	diskdump_unregister_hook();
+	free_pages((unsigned long)scratch, block_order);
+#ifdef CONFIG_PROC_FS
+	remove_proc_entry("diskdump", NULL);
+#endif
+}
+
+module_init(init_diskdump);
+module_exit(cleanup_diskdump);
+MODULE_LICENSE("GPL");
diff -urNp linux-5170/drivers/block/diskdumplib.c linux-5175/drivers/block/diskdumplib.c
--- linux-5170/drivers/block/diskdumplib.c
+++ linux-5175/drivers/block/diskdumplib.c
@@ -0,0 +1,255 @@
+/*
+ *  linux/drivers/block/diskdumplib.c
+ *
+ *  Copyright (C) 2004  FUJITSU LIMITED
+ *  Written by Nobuhiro Tachino (ntachino@jp.fujitsu.com)
+ *
+ */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/file.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/utsname.h>
+#include <linux/smp_lock.h>
+#include <linux/genhd.h>
+#include <linux/slab.h>
+#include <linux/blkdev.h>
+#include <linux/diskdump.h>
+#include <linux/diskdumplib.h>
+#include <asm/diskdump.h>
+
+/*
+ * timer list and tasklet_struct holder
+ */
+unsigned long volatile diskdump_base_jiffies;
+static unsigned long long timestamp_base;
+static unsigned long timestamp_hz;
+
+/* notifiers to be called before starting dump */
+struct notifier_block *disk_dump_notifier_list;
+
+#define DISKDUMP_NUM_TASKLETS	8
+
+/*
+ * We can't use next field of tasklet because it breaks the original
+ * tasklets chain and we have no way to know which chain the tasklet is
+ * linked.
+ */
+static struct tasklet_struct	*diskdump_tasklets[DISKDUMP_NUM_TASKLETS];
+
+static LIST_HEAD(diskdump_timers);
+static LIST_HEAD(diskdump_taskq);
+
+static void (*diskdump_poll_func)(void *);
+static void *diskdump_poll_device;
+
+void diskdump_register_poll(void *device, void (*poll_func)(void *))
+{
+	diskdump_poll_device = device;
+	diskdump_poll_func = poll_func;
+}
+
+static int woken;
+
+void _diskdump_wake_up(wait_queue_head_t *q, unsigned int mode, int nr_exclusive)
+{
+	woken = 1;
+}
+
+static int store_tasklet(struct tasklet_struct *tasklet)
+{
+	int i;
+
+	for (i = 0; i < DISKDUMP_NUM_TASKLETS; i++)
+		if (diskdump_tasklets[i] == NULL) {
+			diskdump_tasklets[i] = tasklet;
+			return 0;
+		}
+	return -1;
+}
+
+static struct tasklet_struct *find_tasklet(struct tasklet_struct *tasklet)
+{
+	int i;
+
+	for (i = 0; i < DISKDUMP_NUM_TASKLETS; i++)
+		if (diskdump_tasklets[i] == tasklet)
+			return diskdump_tasklets[i];
+	return NULL;
+}
+
+void _diskdump_tasklet_schedule(struct tasklet_struct *tasklet)
+{
+	struct tasklet_struct *tasklet_addr;
+
+	if (!find_tasklet(tasklet))
+		if (store_tasklet(tasklet))
+			printk(KERN_ERR "diskdumplib: too many tasklet. Ignored\n");
+	set_bit(TASKLET_STATE_SCHED, &tasklet->state);
+}
+
+int _diskdump_schedule_task(struct tq_struct *task)
+{
+	list_add_tail(&task->list, &diskdump_taskq);
+	return 1;
+}
+
+void _diskdump_add_timer(struct timer_list *timer)
+{
+	timer->base = (void *)1;
+	list_add(&timer->entry, &diskdump_timers);
+}
+
+int _diskdump_del_timer(struct timer_list *timer)
+{
+	if (timer->base != NULL) {
+		list_del(&timer->entry);
+		timer->base = NULL;
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+int _diskdump_mod_timer(struct timer_list *timer, unsigned long expires)
+{
+	int ret;
+
+	ret = _diskdump_del_timer(timer);
+	timer->expires = expires;
+	_diskdump_add_timer(timer);
+
+	return ret;
+}
+
+static void update_jiffies(void)
+{
+	unsigned long long t;
+
+	platform_timestamp(t);
+	while (t > timestamp_base + timestamp_hz) {
+		timestamp_base += timestamp_hz;
+		jiffies++;
+		platform_timestamp(t);
+	}
+}
+
+void diskdump_update(void)
+{
+	struct tasklet_struct *tasklet;
+	struct tq_struct *task;
+	struct timer_list *timer;
+	list_t *t, *n, head;
+	int i;
+
+	update_jiffies();
+
+	/* run timers */
+	list_for_each_safe(t, n, &diskdump_timers) {
+		timer = list_entry(t, struct timer_list, entry);
+		if (time_before_eq(timer->expires, jiffies)) {
+			list_del(t);
+			timer->base = NULL;
+			timer->function(timer->data);
+		}
+	}
+
+	/* run tasklet */
+	for (i = 0; i < DISKDUMP_NUM_TASKLETS; i++)
+		if ((tasklet = diskdump_tasklets[i]))
+			if (!atomic_read(&tasklet->count))
+				if (test_and_clear_bit(TASKLET_STATE_SCHED, &tasklet->state))
+					tasklet->func(tasklet->data);
+
+	/* run task queue */
+	list_add(&head, &diskdump_taskq);
+	list_del_init(&diskdump_taskq);
+	n = head.next;
+	while (n != &head) {
+		task = list_entry(t, struct tq_struct, list);
+		n = n->next;
+		if (task->routine)
+			task->routine(task->data);
+	}
+}
+
+void _diskdump_schedule(void)
+{
+	woken = 0;
+	while (!woken) {
+		diskdump_poll_func(diskdump_poll_device);
+		udelay(100);
+		diskdump_update();
+	}
+}
+
+signed long _diskdump_schedule_timeout(signed long timeout)
+{
+	unsigned long expire;
+
+	expire = timeout + jiffies;
+	woken = 0;
+	while (time_before(jiffies, expire)) {
+		diskdump_poll_func(diskdump_poll_device);
+		udelay(100);
+		diskdump_update();
+		if (woken)
+			return (signed long)(expire - jiffies);
+	}
+	return 0;
+}
+
+void diskdump_lib_init(void)
+{
+	unsigned long long t;
+
+	/* Save original jiffies value */
+	diskdump_base_jiffies = jiffies;
+
+	platform_timestamp(timestamp_base);
+	udelay(1000000/HZ);
+	platform_timestamp(t);
+	timestamp_hz = (unsigned long)(t - timestamp_base);
+
+	diskdump_update();
+}
+
+void diskdump_lib_exit(void)
+{
+	/* Resotre original jiffies. */
+	jiffies = diskdump_base_jiffies;
+}
+
+EXPORT_SYMBOL(disk_dump_notifier_list);
+EXPORT_SYMBOL(diskdump_lib_init);
+EXPORT_SYMBOL(diskdump_lib_exit);
+EXPORT_SYMBOL(diskdump_update);
+EXPORT_SYMBOL(_diskdump_add_timer);
+EXPORT_SYMBOL(_diskdump_del_timer);
+EXPORT_SYMBOL(_diskdump_mod_timer);
+EXPORT_SYMBOL(_diskdump_tasklet_schedule);
+EXPORT_SYMBOL(_diskdump_schedule_task);
+EXPORT_SYMBOL(_diskdump_schedule);
+EXPORT_SYMBOL(_diskdump_schedule_timeout);
+EXPORT_SYMBOL(_diskdump_wake_up);
+EXPORT_SYMBOL(diskdump_register_poll);
+
+MODULE_LICENSE("GPL");
diff -urNp linux-5170/drivers/s390/Config.in linux-5175/drivers/s390/Config.in
--- linux-5170/drivers/s390/Config.in
+++ linux-5175/drivers/s390/Config.in
@@ -37,6 +37,7 @@ endmenu
 #source drivers/block/Config.in
 # So, we just add missing parts by value here, as a bugfix.
 bool 'Per partition statistics in /proc/partitions' CONFIG_BLK_STATS
+tristate 'Disk dump support' CONFIG_DISKDUMP
 
 source drivers/md/Config.in
 
diff -urNp linux-5170/include/asm-i386/diskdump.h linux-5175/include/asm-i386/diskdump.h
--- linux-5170/include/asm-i386/diskdump.h
+++ linux-5175/include/asm-i386/diskdump.h
@@ -0,0 +1,81 @@
+#ifndef _ASM_I386_DISKDUMP_H
+#define _ASM_I386_DISKDUMP_H
+
+/*
+ * linux/include/asm-i386/diskdump.h
+ *
+ * Copyright (c) 2004 FUJITSU LIMITED
+ * Copyright (c) 2003 Red Hat, Inc. All rights reserved.
+ */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifdef __KERNEL__
+
+#include <linux/elf.h>
+
+extern int page_is_ram(unsigned long);
+const static int platform_supports_diskdump = 1;
+
+#define platform_fix_regs() \
+{                                                                      \
+       unsigned long esp;                                              \
+       unsigned short ss;                                              \
+       esp = (unsigned long) ((char *)regs + sizeof (struct pt_regs)); \
+       ss = __KERNEL_DS;                                               \
+       if (regs->xcs & 3) {                                            \
+               esp = regs->esp;                                        \
+               ss = regs->xss & 0xffff;                                \
+       }                                                               \
+       myregs = *regs;                                                 \
+       myregs.esp = esp;                                               \
+       myregs.xss = (myregs.xss & 0xffff0000) | ss;                    \
+}
+
+struct disk_dump_sub_header {
+	elf_gregset_t		elf_regs;
+};
+
+#define platform_timestamp(x) rdtscll(x)
+
+#define size_of_sub_header()	((sizeof(struct disk_dump_sub_header) + PAGE_SIZE - 1) / DUMP_BLOCK_SIZE)
+
+#define write_sub_header() \
+({								\
+ 	int ret;						\
+	struct disk_dump_sub_header *header;			\
+								\
+	header = (struct disk_dump_sub_header *)scratch;	\
+	ELF_CORE_COPY_REGS(header->elf_regs, (&myregs));	\
+	if ((ret = write_blocks(dump_part, 2, scratch, 1)) >= 0)\
+		ret = 1; /* size of sub header in page */;	\
+	ret;							\
+})
+
+#define platform_freeze_cpu() \
+{                             \
+	for (;;) __cli();     \
+}
+
+#define platform_start_diskdump(func, regs)	\
+{						\
+	func(regs, NULL);			\
+}
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_I386_DISKDUMP_H */
diff -urNp linux-5170/include/asm-ia64/diskdump.h linux-5175/include/asm-ia64/diskdump.h
--- linux-5170/include/asm-ia64/diskdump.h
+++ linux-5175/include/asm-ia64/diskdump.h
@@ -0,0 +1,87 @@
+#ifndef _ASM_IA64_DISKDUMP_H
+#define _ASM_IA64_DISKDUMP_H
+
+/*
+ * linux/include/asm-ia64/diskdump.h
+ *
+ * Copyright (c) 2004 FUJITSU LIMITED
+ * Copyright (c) 2003 Red Hat, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifdef __KERNEL__
+
+#include <linux/elf.h>
+#include <asm/unwind.h>
+
+extern void ia64_do_copy_regs(struct unw_frame_info *, void *arg);
+extern void ia64_freeze_cpu(struct unw_frame_info *, void *arg);
+extern void ia64_start_dump(struct unw_frame_info *, void *arg);
+extern int page_is_ram(unsigned long);
+
+const static int platform_supports_diskdump = 1;
+
+#define platform_fix_regs()					\
+{								\
+	struct unw_frame_info *info = platform_arg;		\
+								\
+	current->thread.ksp = (__u64)info->sw - 16;		\
+	myregs = *regs;						\
+}
+
+struct disk_dump_sub_header {
+	elf_gregset_t		 elf_regs;
+	struct switch_stack	*sw[NR_CPUS];
+};
+
+#define platform_timestamp(x) ({ x = ia64_get_itc(); })
+
+#define size_of_sub_header()	((sizeof(struct disk_dump_sub_header) + PAGE_SIZE - 1) / DUMP_BLOCK_SIZE)
+
+#define write_sub_header() \
+({								\
+ 	int ret;						\
+	struct unw_frame_info *info = platform_arg;		\
+								\
+	ia64_do_copy_regs(info, &dump_sub_header.elf_regs);	\
+	dump_sub_header.sw[smp_processor_id()] = info->sw;	\
+	clear_page(scratch);					\
+	memcpy(scratch, &dump_sub_header, sizeof(dump_sub_header));\
+ 								\
+	if ((ret = write_blocks(dump_part, 2, scratch, 1)) >= 0)\
+		ret = 1; /* size of sub header in page */;	\
+	ret;							\
+})
+
+#define platform_freeze_cpu() 					\
+{								\
+	unw_init_running(ia64_freeze_cpu,			\
+		&dump_sub_header.sw[smp_processor_id()]);	\
+}
+
+#define platform_start_diskdump(func, regs)			\
+{								\
+	struct dump_call_param param;				\
+								\
+	param.func = func;					\
+	param.regs = regs;					\
+	unw_init_running(ia64_start_dump, &param);		\
+}
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_IA64_DISKDUMP_H */
diff -urNp linux-5170/include/asm-ia64/ptrace.h linux-5175/include/asm-ia64/ptrace.h
--- linux-5170/include/asm-ia64/ptrace.h
+++ linux-5175/include/asm-ia64/ptrace.h
@@ -262,6 +262,12 @@ struct pt_all_user_regs {
 	struct ia64_fpreg fr[128];
 };
 
+/* Container to hold dump hander information */
+struct dump_call_param {
+	void (*func)(struct pt_regs *, void *);
+	struct pt_regs	*regs;
+};
+
 #endif /* !__ASSEMBLY__ */
 
 /* indices to application-registers array in pt_all_user_regs */
diff -urNp linux-5170/include/asm-x86_64/diskdump.h linux-5175/include/asm-x86_64/diskdump.h
--- linux-5170/include/asm-x86_64/diskdump.h
+++ linux-5175/include/asm-x86_64/diskdump.h
@@ -0,0 +1,82 @@
+#ifndef _ASM_X86_64_DISKDUMP_H
+#define _ASM_X86_64_DISKDUMP_H
+
+/*
+ * linux/include/asm-x86_64/diskdump.h
+ *
+ * Copyright (c) 2004 NEC Corporation
+ * Copyright (c) 2004 FUJITSU LIMITED
+ * Copyright (c) 2003 Red Hat, Inc. All rights reserved.
+ */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifdef __KERNEL__
+
+#include <linux/elf.h>
+
+extern int page_is_ram(unsigned long);
+
+const static int platform_supports_diskdump = 1;
+
+#define platform_fix_regs() \
+{                                                                      \
+       unsigned long rsp;                                              \
+       unsigned short ss;                                              \
+                                                                       \
+       rsp = (unsigned long) ((char *)regs + sizeof (struct pt_regs)); \
+       if (regs->rsp < TASK_SIZE) {                                    \
+                rsp = regs->rsp;                                       \
+       }                                                               \
+       myregs = *regs;                                                 \
+       myregs.rsp = rsp;                                               \
+                                                                       \
+}
+
+struct disk_dump_sub_header {
+	elf_gregset_t		elf_regs;
+};
+
+#define platform_timestamp(x) rdtscll(x)
+
+#define size_of_sub_header()	((sizeof(struct disk_dump_sub_header) + PAGE_SIZE - 1) / DUMP_BLOCK_SIZE)
+
+#define write_sub_header() \
+({								\
+ 	int ret;						\
+	struct disk_dump_sub_header *header;			\
+								\
+	header = (struct disk_dump_sub_header *)scratch;	\
+	ELF_CORE_COPY_REGS(header->elf_regs, (&myregs));	\
+	if ((ret = write_blocks(dump_part, 2, scratch, 1)) >= 0)\
+		ret = 1; /* size of sub header in page */;	\
+	ret;							\
+})
+
+#define platform_freeze_cpu() \
+{                             \
+	for (;;) __cli();     \
+}
+
+#define platform_start_diskdump(func, regs)	\
+{						\
+	func(regs, NULL);			\
+}
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_X86-64_DISKDUMP_H */
diff -urNp linux-5170/include/asm-x86_64/pgtable.h linux-5175/include/asm-x86_64/pgtable.h
--- linux-5170/include/asm-x86_64/pgtable.h
+++ linux-5175/include/asm-x86_64/pgtable.h
@@ -459,7 +459,8 @@ extern void clear_kernel_mapping(unsigne
 
 /* Needs to be defined here and not in linux/mm.h, as it is arch dependent */
 #define PageSkip(page)		(0)
-#define kern_addr_valid(kaddr)  ((kaddr)>>PAGE_SHIFT < max_mapnr)
+extern int kern_addr_valid(unsigned long addr); 
+
 
 #define io_remap_page_range remap_page_range
 
diff -urNp linux-5170/include/linux/diskdump.h linux-5175/include/linux/diskdump.h
--- linux-5170/include/linux/diskdump.h
+++ linux-5175/include/linux/diskdump.h
@@ -0,0 +1,158 @@
+#ifndef _LINUX_DISKDUMP_H
+#define _LINUX_DISKDUMP_H
+
+/*
+ * linux/include/linux/diskdump.h
+ *
+ * Copyright (c) 2004 FUJITSU LIMITED
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/list.h>
+#include <linux/mount.h>
+#include <linux/dcache.h>
+#include <linux/blkdev.h>
+#include <linux/utsname.h>
+#include <linux/notifier.h>
+
+/* The minimum Dump I/O unit. Must be the same of PAGE_SIZE */
+#define DUMP_BLOCK_SIZE		PAGE_SIZE
+#define DUMP_BLOCK_SHIFT	PAGE_SHIFT
+
+/* Dump ioctls */
+#define BLKADDDUMPDEVICE	0xdf00		/* Add a dump device */
+#define BLKREMOVEDUMPDEVICE	0xdf01		/* Delete a dump device */
+
+int diskdump_register_hook(void (*dump_func)(struct pt_regs *, void *));
+void diskdump_unregister_hook(void);
+
+/* notifiers to be called before starting dump */
+extern struct notifier_block *disk_dump_notifier_list;
+
+/*
+ * The handler that adapter driver provides for the common module of
+ * dump
+ */
+struct disk_dump_partition;
+struct disk_dump_device;
+
+struct disk_dump_type {
+	void *(*probe)(kdev_t);
+	int (*add_device)(struct disk_dump_device *);
+	void (*remove_device)(struct disk_dump_device *);
+	void (*compute_cksum)(void);
+	struct module *owner;
+	list_t list;
+};
+
+struct disk_dump_device_ops {
+	int (*sanity_check)(struct disk_dump_device *);
+	int (*quiesce)(struct disk_dump_device *);
+	int (*shutdown)(struct disk_dump_device *);
+	int (*rw_block)(struct disk_dump_partition *, int rw, unsigned long block, void *buf, int nr_blocks);
+};
+
+/* The data structure for a dump device */
+struct disk_dump_device {
+	list_t list;
+	struct disk_dump_device_ops ops;
+	struct disk_dump_type *dump_type;
+	void *device;
+	unsigned int max_blocks;
+	list_t partitions;
+};
+
+/* The data structure for a dump partition */
+struct disk_dump_partition {
+	list_t list;
+	struct disk_dump_device *device;
+	struct vfsmount *vfsmount;
+	struct dentry *dentry;
+	unsigned long start_sect;
+	unsigned long nr_sects;
+};
+
+
+int register_disk_dump_type(struct disk_dump_type *);
+int unregister_disk_dump_type(struct disk_dump_type *);
+
+
+/* The signature which is written in each block in the dump partition */
+#define DUMP_PARTITION_SIGNATURE	"diskdump"
+
+/*
+ * Architecture-independent dump header
+ */
+#define DISK_DUMP_SIGNATURE		"DISKDUMP"
+#define DISK_DUMP_HEADER_VERSION	1
+#define DUMP_HEADER_COMPLETED	0
+#define DUMP_HEADER_INCOMPLETED	1
+
+struct disk_dump_header {
+	char			signature[8];	/* = "DISKDUMP" */
+	int			header_version;	/* Dump header version */
+	struct new_utsname	utsname;	/* copy of system_utsname */
+	struct timeval		timestamp;	/* Time stamp */
+	unsigned int		status;		/* Above flags */
+	int			block_size;	/* Size of a block in byte */
+	int			sub_hdr_size;	/* Size of arch dependent
+						   header in blocks */
+	unsigned int		bitmap_blocks;	/* Size of Memory bitmap in
+						   block */
+	unsigned int		max_mapnr;	/* = max_mapnr */
+	unsigned int		total_ram_blocks;/* Size of Memory in block */
+	unsigned int		device_blocks;	/* Number of total blocks in
+						 * the dump device */
+	unsigned int		written_blocks;	/* Number of written blocks */
+	unsigned int		current_cpu;	/* CPU# which handles dump */
+	int			nr_cpus;	/* Number of CPUs */
+	struct task_struct	*tasks[NR_CPUS];
+};
+
+/*
+ * Calculate the check sum of the whole module
+ */
+#define get_crc_module()						\
+({									\
+	struct module *module = &__this_module;				\
+	crc32_le(0, (char *)(module + 1), module->size - sizeof(*module)); \
+})
+
+#define set_crc_modules()						\
+({									\
+	module_crc = 0;							\
+	module_crc = get_crc_module();					\
+})
+
+/*
+ * Compare the checksum value that is stored in module_crc to the check
+ * sum of current whole module. Must be called with holding disk_dump_lock.
+ * Return TRUE if they are the same, else return FALSE
+ *
+ */
+#define check_crc_module()						\
+({									\
+	uint32_t orig_crc, cur_crc;					\
+									\
+	orig_crc = module_crc; module_crc = 0;				\
+	cur_crc = get_crc_module();					\
+	module_crc = orig_crc;						\
+	orig_crc == cur_crc;						\
+})
+
+
+#endif /* _LINUX_DISKDUMP_H */
diff -urNp linux-5170/include/linux/diskdumplib.h linux-5175/include/linux/diskdumplib.h
--- linux-5170/include/linux/diskdumplib.h
+++ linux-5175/include/linux/diskdumplib.h
@@ -0,0 +1,95 @@
+#ifndef _LINUX_DISKDUMPLIB_H
+#define _LINUX_DISKDUMPLIB_H
+
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+
+void diskdump_lib_init(void);
+void diskdump_lib_exit(void);
+void diskdump_update(void);
+void diskdump_register_poll(void *device, void (*poll_func)(void *));
+
+void _diskdump_add_timer(struct timer_list *);
+int _diskdump_del_timer(struct timer_list *);
+int _diskdump_mod_timer(struct timer_list *, unsigned long);
+void _diskdump_tasklet_schedule(struct tasklet_struct *);
+int _diskdump_schedule_task(struct tq_struct *);
+void _diskdump_wake_up(wait_queue_head_t *q, unsigned int mode, int nr_exclusive);
+void _diskdump_schedule(void);
+signed long _diskdump_schedule_timeout(signed long timeout);
+
+static inline void diskdump_add_timer(struct timer_list *timer)
+{
+	if (crashdump_mode())
+		_diskdump_add_timer(timer);
+	else
+		add_timer(timer);
+}
+
+static inline int diskdump_del_timer(struct timer_list *timer)
+{
+	if (crashdump_mode())
+		return _diskdump_del_timer(timer);
+	else
+		return del_timer(timer);
+}
+
+static inline int diskdump_mod_timer(struct timer_list *timer, unsigned long expires)
+{
+	if (crashdump_mode())
+		return _diskdump_mod_timer(timer, expires);
+	else
+		return mod_timer(timer, expires);
+}
+
+static inline void diskdump_tasklet_schedule(struct tasklet_struct *tasklet)
+{
+	if (crashdump_mode())
+		return _diskdump_tasklet_schedule(tasklet);
+	else
+		return tasklet_schedule(tasklet);
+}
+
+static inline int diskdump_schedule_task(struct tq_struct *task)
+{
+	if (crashdump_mode())
+		return _diskdump_schedule_task(task);
+	else
+		return schedule_task(task);
+}
+
+static inline void diskdump_wake_up(wait_queue_head_t *q, unsigned int mode, int nr_exclusive)
+{
+	if (crashdump_mode())
+		_diskdump_wake_up(q, mode, nr_exclusive);
+	else
+		__wake_up(q, mode, nr_exclusive);
+	return;
+}
+
+static inline void diskdump_schedule(void)
+{
+	if (crashdump_mode())
+		_diskdump_schedule();
+	else
+		schedule();
+	return;
+}
+
+static inline signed long diskdump_schedule_timeout(signed long timeout)
+{ 
+	if (crashdump_mode())
+		return _diskdump_schedule_timeout(timeout);
+	else
+		return schedule_timeout(timeout);
+}
+
+static inline long diskdump_sleep_on_timeout(wait_queue_head_t *q, long timeout)
+{
+	if (crashdump_mode())
+		return _diskdump_schedule_timeout(timeout);
+	else
+		return sleep_on_timeout(q, timeout);
+}
+
+#endif /* _LINUX_DISKDUMPLIB_H */
diff -urNp linux-5170/include/linux/kernel.h linux-5175/include/linux/kernel.h
--- linux-5170/include/linux/kernel.h
+++ linux-5175/include/linux/kernel.h
@@ -88,6 +88,7 @@ extern void dev_probe_lock(void);
 extern void dev_probe_unlock(void);
 struct pt_regs;
 extern struct task_struct *copy_process(unsigned long, unsigned long, struct pt_regs*, unsigned long, int*, int*);
+extern void try_crashdump(struct pt_regs *);
 
 extern int session_of_pgrp(int pgrp);
 
@@ -110,7 +111,11 @@ extern int oops_in_progress;		/* If set,
 extern int panic_on_oops;
 struct pt_regs;
 extern void (*netdump_func)(struct pt_regs *regs);
+extern void (*diskdump_func)(struct pt_regs *regs, void *platform_arg);
 extern int netdump_mode;
+extern int diskdump_mode;
+
+#define crashdump_mode()	(netdump_mode || diskdump_mode)
 
 extern int tainted;
 extern const char *print_tainted(void);
diff -urNp linux-5170/kernel/ksyms.c linux-5175/kernel/ksyms.c
--- linux-5170/kernel/ksyms.c
+++ linux-5175/kernel/ksyms.c
@@ -54,6 +54,7 @@
 #include <asm/checksum.h>
 #include <linux/unistd.h>
 #include <linux/netdevice.h>
+#include <linux/diskdump.h>
 
 
 #if defined(CONFIG_PROC_FS)
@@ -658,3 +659,7 @@ EXPORT_SYMBOL_GPL(netdump_func);
 EXPORT_SYMBOL_GPL(netdump_mode);
 EXPORT_SYMBOL_GPL(netdump_register_hooks);
 EXPORT_SYMBOL_GPL(netdump_unregister_hooks);
+EXPORT_SYMBOL_GPL(diskdump_func);
+EXPORT_SYMBOL_GPL(diskdump_mode);
+EXPORT_SYMBOL_GPL(diskdump_register_hook);
+EXPORT_SYMBOL_GPL(diskdump_unregister_hook);
diff -urNp linux-5170/kernel/panic.c linux-5175/kernel/panic.c
--- linux-5170/kernel/panic.c
+++ linux-5175/kernel/panic.c
@@ -192,6 +192,7 @@ __setup("panicblink=", panicblink_setup)
  */
 
 int netdump_mode = 0;
+int diskdump_mode = 0;
  
 NORET_TYPE void panic(const char * fmt, ...)
 {
@@ -206,7 +207,7 @@ NORET_TYPE void panic(const char * fmt, 
 	vsprintf(buf, fmt, args);
 	va_end(args);
 	printk(KERN_EMERG "Kernel panic: %s\n",buf);
-	if (netdump_func)
+	if (netdump_func || diskdump_func)
 		BUG();
 	if (in_interrupt())
 		printk(KERN_EMERG "In interrupt handler - not syncing\n");
@@ -313,3 +314,29 @@ void __out_of_line_bug(int line)
 	for ( ; ; )
 		;
 }
+
+/*
+ * Try crashdump. Diskdump is first, netdump is second.
+ * We clear diskdump_func before call of diskdump_func, so
+ * If double panic would occur in diskdump, netdump can handle
+ * it.
+ */
+#if defined(CONFIG_DISKDUMP) || defined(CONFIG_DISKDUMP_MODULE)
+#include <asm/diskdump.h>
+#endif
+void try_crashdump(struct pt_regs *regs)
+{
+#if defined(CONFIG_DISKDUMP) || defined(CONFIG_DISKDUMP_MODULE)
+	if (diskdump_func) {
+		void (*func)(struct pt_regs *, void *);
+		func = diskdump_func;
+		diskdump_func = NULL;
+		platform_start_diskdump(func, regs);
+	}
+#endif
+	if (netdump_func)
+		netdump_func(regs);
+	netdump_func = NULL;
+	if (panic_on_oops)
+		panic("Fatal exception");
+}
diff -urNp linux-5170/kernel/printk.c linux-5175/kernel/printk.c
--- linux-5170/kernel/printk.c
+++ linux-5175/kernel/printk.c
@@ -494,7 +494,7 @@ asmlinkage int printk(const char *fmt, .
 	printed_len = vsnprintf(printk_buf, sizeof(printk_buf), fmt, args);
 	va_end(args);
 
-	if (unlikely(netdump_mode)) {
+	if (unlikely(crashdump_mode())) {
 		netdump_call_console_drivers(printk_buf, printed_len);
 		spin_unlock_irqrestore(&logbuf_lock, flags);
 		goto out;
