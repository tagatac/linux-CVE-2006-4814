diff -urNp linux-1226/mm/page_alloc.c linux-1227/mm/page_alloc.c
--- linux-1226/mm/page_alloc.c
+++ linux-1227/mm/page_alloc.c
@@ -480,31 +480,23 @@ struct page * __alloc_pages(unsigned int
 
 try_again:
 	/*
-	 * First, see if we have any zones with lots of free memory.
-	 *
-	 * We allocate free memory first because it doesn't contain
-	 * any data we would want to cache.  Make sure to stay above
-	 * the watermark that triggers kswapd, otherwise we could
-	 * upset zone balancing.
+	 * First, refill the free list to at least the minimum watermark.
+	 * This needs to be done in order to fulfill allocations which
+	 * can't do direct reclaim, as well as higher order allocations.
 	 */
 	zone = zonelist->zones;
 	if (!*zone)
 		return NULL;
-	for (;;) {
-		zone_t *z = *(zone++);
-		if (!z)
-			break;
-		if (!z->size)
-			continue;
-		if (z->free_pages > ((wired && zone_is_highmem(z)) ? z->pages_min:z->pages_low)) {
-			page = rmqueue(z, order);
-			if (page)
-				return page;
-		} else if (z->free_pages < z->pages_min)
-			fixup_freespace(z, direct_reclaim);
-
-		if (wired)
-			break;
+	if (direct_reclaim) {
+		for (;;) {
+			zone_t *z = *(zone++);
+			if (!z)
+				break;
+			if (!z->size)
+				continue;
+			if (z->free_pages < z->pages_min)
+				fixup_freespace(z, direct_reclaim);
+		}
 	}
 
 	/*
