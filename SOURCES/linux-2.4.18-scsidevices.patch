diff -urNp linux-5230/drivers/char/sysrq.c linux-5250/drivers/char/sysrq.c
--- linux-5230/drivers/char/sysrq.c
+++ linux-5250/drivers/char/sysrq.c
@@ -132,6 +132,8 @@ static int is_local_disk(kdev_t dev) {
 	unsigned int major;
 	major = MAJOR(dev);
 
+	if (SCSI_DISK_MAJOR(major))
+		return 1;
 	switch (major) {
 	case IDE0_MAJOR:
 	case IDE1_MAJOR:
@@ -143,14 +145,6 @@ static int is_local_disk(kdev_t dev) {
 	case IDE7_MAJOR:
 	case IDE8_MAJOR:
 	case IDE9_MAJOR:
-	case SCSI_DISK0_MAJOR:
-	case SCSI_DISK1_MAJOR:
-	case SCSI_DISK2_MAJOR:
-	case SCSI_DISK3_MAJOR:
-	case SCSI_DISK4_MAJOR:
-	case SCSI_DISK5_MAJOR:
-	case SCSI_DISK6_MAJOR:
-	case SCSI_DISK7_MAJOR:
 	case XT_DISK_MAJOR:
 		return 1;
 	default:
diff -urNp linux-5230/drivers/scsi/hosts.h linux-5250/drivers/scsi/hosts.h
--- linux-5230/drivers/scsi/hosts.h
+++ linux-5250/drivers/scsi/hosts.h
@@ -529,8 +529,8 @@ struct Scsi_Device_Template
     struct module * module;	  /* Used for loadable modules */
     unsigned char scsi_type;
     unsigned int major;
-    unsigned int min_major;      /* Minimum major in range. */ 
-    unsigned int max_major;      /* Maximum major in range. */
+    unsigned int _min_major_dontuse;
+    unsigned int _max_major_dontuse;
     unsigned int nr_dev;	  /* Number currently attached */
     unsigned int dev_noticed;	  /* Number of devices detected. */
     unsigned int dev_max;	  /* Current size of arrays */
diff -urNp linux-5230/drivers/scsi/ide-scsi.c linux-5250/drivers/scsi/ide-scsi.c
--- linux-5230/drivers/scsi/ide-scsi.c
+++ linux-5250/drivers/scsi/ide-scsi.c
@@ -35,6 +35,10 @@
  * Ver 0.92  Mar 21 02   Include DevFs support
  *                        Borsenkow Andrej <Andrej.Borsenkow@mow.siemens.ru>
  * Ver 0.93  Jun 10 02   Fix "off by one" error in transforms
+ * Ver -.--  Sep 09 03   Added transform for reading ATAPI tape drive block
+ *                        limits (ATAPI tapes report block limits in mode
+ *                        page 0x2A, not by "read block limits" command)
+ *                        Stuart Hayes @Dell
  */
 
 #define IDESCSI_VERSION "0.93"
@@ -234,6 +238,25 @@ static inline void idescsi_transform_pc1
 			pc->buffer_size += 4;
 		}
 	}
+	if (drive->media == ide_tape) {
+		if (sc[0] == READ_BLOCK_LIMITS) {	/* IDE tapes have blk lmts in mode page 0x2a */
+			if (!scsi_buf)
+				return;
+			/* buffer size should be 6 for READ_BLOCK_LIMITS    */
+			/* we need 12 bytes (4 for header + 8 for mode page */
+			if ((atapi_buf = kmalloc(12, GFP_ATOMIC)) == NULL)
+				return;
+			memset(atapi_buf, 0, 12);
+			memset (c, 0, 12);
+			c[0] = MODE_SENSE;
+			c[1] = 8;  	/* no block descriptors     */
+			c[2] = 0x2A;	/* mode page 0x2A           */
+			c[4] = 12;	/* buffer length 12 decimal */
+			pc->buffer = atapi_buf;
+			pc->request_transfer = 12;
+			pc->buffer_size = 12;
+		}
+	}
 }
 
 static inline void idescsi_transform_pc2 (ide_drive_t *drive, idescsi_pc_t *pc)
@@ -262,7 +285,19 @@ static inline void idescsi_transform_pc2
 			/* response data format */
 			scsi_buf[3] = (scsi_buf[3] & 0xf0) | 2;
 		}
+	}	
+	if (drive->media == ide_tape) {
+		if (sc[0] == READ_BLOCK_LIMITS) {
+			memset(scsi_buf, 0, pc->scsi_cmd->request_bufflen);
+			/* granularity of 9 (always 9 for ide tapes) */
+			scsi_buf[0] = 9;
+			/* block length of 1024 bytes supported? */
+			scsi_buf[2] = (atapi_buf[11] & 0x04) ? 4 : 2;
+			/* block length of 512 bytes supported?  */
+			scsi_buf[4] = (atapi_buf[11] & 0x02) ? 2 : 4;
+		}
 	}
+
 	if (atapi_buf && atapi_buf != scsi_buf)
 		kfree(atapi_buf);
 }
diff -urNp linux-5230/drivers/scsi/scsi.h linux-5250/drivers/scsi/scsi.h
--- linux-5230/drivers/scsi/scsi.h
+++ linux-5250/drivers/scsi/scsi.h
@@ -612,6 +612,9 @@ struct scsi_device {
 	unsigned remap:1;	/* support remapping  */
 	unsigned starved:1;	/* unable to process commands because
 				   host busy */
+#ifndef __GENKSYMS__ /* preserve KMI/ABI ksyms compatibility for mod linkage */
+        unsigned no_start_on_add:1;	/* do not issue start on add */
+#endif
 
 	// Flag to allow revalidate to succeed in sd_open
 	int allow_revalidate;
diff -urNp linux-5230/drivers/scsi/scsi_lib.c linux-5250/drivers/scsi/scsi_lib.c
--- linux-5230/drivers/scsi/scsi_lib.c
+++ linux-5250/drivers/scsi/scsi_lib.c
@@ -803,8 +803,9 @@ void scsi_io_completion(Scsi_Cmnd * SCpn
  *
  * Lock status: No locks assumed to be held, but as it happens the
  *              io_request_lock is held when this is called.
+ *              We traverse scis_devicelist, so protect that.
  *
- * Returns:     Nothing
+ * Returns:     Pointer to a Scsi_Device_Template.
  *
  * Notes:       The requests in the request queue may have originated
  *              from any block device driver.  We need to find out which
@@ -818,6 +819,9 @@ struct Scsi_Device_Template *scsi_get_re
 
 	ASSERT_LOCK(q->queue_lock, 1);
 
+	if (SCSI_DISK_MAJOR(major))
+		major = SCSI_DISK0_MAJOR;
+
 	for (spnt = scsi_devicelist; spnt; spnt = spnt->next) {
 		/*
 		 * Search for a block device driver that supports this
@@ -826,22 +830,6 @@ struct Scsi_Device_Template *scsi_get_re
 		if (spnt->blk && spnt->major == major) {
 			return spnt;
 		}
-		/*
-		 * I am still not entirely satisfied with this solution,
-		 * but it is good enough for now.  Disks have a number of
-		 * major numbers associated with them, the primary
-		 * 8, which we test above, and a secondary range of 7
-		 * different consecutive major numbers.   If this ever
-		 * becomes insufficient, then we could add another function
-		 * to the structure, and generalize this completely.
-		 */
-		if( spnt->min_major != 0 
-		    && spnt->max_major != 0
-		    && major >= spnt->min_major
-		    && major <= spnt->max_major )
-		{
-			return spnt;
-		}
 	}
 	return NULL;
 }
diff -urNp linux-5230/drivers/scsi/scsi_scan.c linux-5250/drivers/scsi/scsi_scan.c
--- linux-5230/drivers/scsi/scsi_scan.c
+++ linux-5250/drivers/scsi/scsi_scan.c
@@ -37,6 +37,7 @@
 #define BLIST_ISDISK    	0x100	/* Treat as (removable) disk */
 #define BLIST_ISROM     	0x200	/* Treat as (removable) CD-ROM */
 #define BLIST_LARGELUN		0x400	/* LUNs larger than 7 despite reporting as SCSI 2 */
+#define BLIST_NOSTARTONADD	0x800	/* do not do automatic start on add */
 
 static void print_inquiry(unsigned char *data);
 static int scan_scsis_single(unsigned int channel, unsigned int dev,
@@ -793,6 +794,13 @@ static int scan_scsis_single(unsigned in
 		SDpnt->borken = 0;
 
 	/*
+	 * Some devices may not want to have a start command automatically
+	 * issued when a device is added.
+	 */
+	if (bflags & BLIST_NOSTARTONADD)
+		SDpnt->no_start_on_add = 1;
+
+	/*
 	 * If we want to only allow I/O to one of the luns attached to this device
 	 * at a time, then we set this flag.
 	 */
diff -urNp linux-5230/drivers/scsi/sd.c linux-5250/drivers/scsi/sd.c
--- linux-5230/drivers/scsi/sd.c
+++ linux-5250/drivers/scsi/sd.c
@@ -65,10 +65,10 @@
  *  static const char RCSid[] = "$Header:";
  */
 
-/* system major --> sd_gendisks index */
-#define SD_MAJOR_IDX(i)		(MAJOR(i) & SD_MAJOR_MASK)
+/* device number --> sd_gendisks index */
+#define SD_MAJOR_IDX(i)		( ((MAJOR(i) & 0x80) >> 4) + (MAJOR(i) & 7) )
 /* sd_gendisks index --> system major */
-#define SD_MAJOR(i) (!(i) ? SCSI_DISK0_MAJOR : SCSI_DISK1_MAJOR-1+(i))
+#define SD_MAJOR(i)		(sd_major[i])
 
 #define SD_PARTITION(dev)	((SD_MAJOR_IDX(dev) << 8) | (MINOR(dev) & 255))
 
@@ -97,6 +97,25 @@ static int *sd_hardsizes;	/* Hardware se
 static int *sd_max_sectors;
 static char *sd_varyio;
 
+static const unsigned int sd_major[N_SD_MAJORS] = {
+	SCSI_DISK0_MAJOR,	/* 0x08 */
+	SCSI_DISK1_MAJOR,	/* 0x41 */
+	SCSI_DISK2_MAJOR,	/* 0x42 */
+	SCSI_DISK3_MAJOR,	/* 0x43 */
+	SCSI_DISK4_MAJOR,	/* 0x44 */
+	SCSI_DISK5_MAJOR,	/* 0x45 */
+	SCSI_DISK6_MAJOR,	/* 0x46 */
+	SCSI_DISK7_MAJOR,	/* 0x47 */
+	SCSI_DISK10_MAJOR,	/* 0x80 */
+	SCSI_DISK11_MAJOR,	/* 0x81 */
+	SCSI_DISK12_MAJOR,	/* 0x82 */
+	SCSI_DISK13_MAJOR,	/* 0x83 */
+	SCSI_DISK14_MAJOR,	/* 0x84 */
+	SCSI_DISK15_MAJOR,	/* 0x85 */
+	SCSI_DISK16_MAJOR,	/* 0x86 */
+	SCSI_DISK17_MAJOR,	/* 0x87 */
+};
+
 static int check_scsidisk_media_change(kdev_t);
 static int fop_revalidate_scsidisk(kdev_t);
 
@@ -115,11 +134,6 @@ static struct Scsi_Device_Template sd_te
 	tag:"sd",
 	scsi_type:TYPE_DISK,
 	major:SCSI_DISK0_MAJOR,
-        /*
-         * Secondary range of majors that this driver handles.
-         */
-	min_major:SCSI_DISK1_MAJOR,
-	max_major:SCSI_DISK7_MAJOR,
 	blk:1,
 	detect:sd_detect,
 	init:sd_init,
@@ -789,6 +803,19 @@ static int check_scsidisk_media_change(k
 	return retval;
 }
 
+/* See RH bz#157667, also drivers/ide/ide-floppy.c */
+static int sd_should_report_error(int the_result, Scsi_Request *SRpnt)
+{
+	/* Check if media was just changed. Allow any ASCQ and NOT_READY. */
+	if ((driver_byte(the_result) & DRIVER_SENSE) != 0 &&
+	    (SRpnt->sr_sense_buffer[2] == UNIT_ATTENTION ||
+	     SRpnt->sr_sense_buffer[2] == NOT_READY) &&
+	    SRpnt->sr_sense_buffer[12] == 0x3A)
+		return 0;
+	/* Anything else? Just media for now. */
+	return 1;
+}
+
 static int sd_init_onedisk(int i)
 {
 	unsigned char cmd[10];
@@ -864,7 +891,8 @@ static int sd_init_onedisk(int i)
 		 */
 		if( the_result != 0
 		    && ((driver_byte(the_result) & DRIVER_SENSE) != 0)
-		    && SRpnt->sr_sense_buffer[2] == UNIT_ATTENTION
+		    && (SRpnt->sr_sense_buffer[2] == UNIT_ATTENTION ||
+		        SRpnt->sr_sense_buffer[2] == NOT_READY)
 		    && SRpnt->sr_sense_buffer[12] == 0x3A ) {
 			rscsi_disks[i].capacity = 0x1fffff;
 			sector_size = 512;
@@ -873,6 +901,13 @@ static int sd_init_onedisk(int i)
 			break;
 		}
 
+		/*
+		 * The device does not want the automatic start to be issued.
+		 */
+		if (rscsi_disks[i].device->no_start_on_add) {
+			break;
+		}
+
 		/* Look for non-removable devices that return NOT_READY,
 		 * and don't require manual intervention.
 		 * Issue command to spin up drive for these cases. */
@@ -893,7 +928,7 @@ static int sd_init_onedisk(int i)
 				SRpnt->sr_sense_buffer[0] = 0;
 				SRpnt->sr_sense_buffer[2] = 0;
 
-				SRpnt->sr_data_direction = SCSI_DATA_READ;
+				SRpnt->sr_data_direction = SCSI_DATA_NONE;
 				scsi_wait_req(SRpnt, (void *) cmd, (void *) buffer,
 					    0/*512*/, SD_TIMEOUT, MAX_RETRIES);
 				spintime_value = jiffies;
@@ -951,21 +986,24 @@ static int sd_init_onedisk(int i)
 	 */
 
 	if (the_result) {
-		printk("%s : READ CAPACITY failed.\n"
-		       "%s : status = %x, message = %02x, host = %d, driver = %02x \n",
-		       nbuff, nbuff,
-		       status_byte(the_result),
-		       msg_byte(the_result),
-		       host_byte(the_result),
-		       driver_byte(the_result)
-		    );
-		if (driver_byte(the_result) & DRIVER_SENSE)
-			print_req_sense("sd", SRpnt);
-		else
-			printk("%s : sense not available. \n", nbuff);
-
-		printk("%s : block size assumed to be 512 bytes, disk size 1GB.  \n",
-		       nbuff);
+		if (sd_should_report_error(the_result, SRpnt)) {
+			printk("%s : READ CAPACITY failed.\n"
+			       "%s : status = %x, message = %02x, host = %d, driver = %02x \n",
+			       nbuff, nbuff,
+			       status_byte(the_result),
+			       msg_byte(the_result),
+			       host_byte(the_result),
+			       driver_byte(the_result)
+			    );
+			if (driver_byte(the_result) & DRIVER_SENSE)
+				print_req_sense("sd", SRpnt);
+			else
+				printk("%s : sense not available. \n", nbuff);
+
+			printk("%s : block size assumed to be 512 bytes,"
+			    " disk size 1GB.\n",
+			    nbuff);
+		}
 		rscsi_disks[i].capacity = 0x1fffff;
 		sector_size = 512;
 
@@ -1218,7 +1256,7 @@ static int sd_init()
 			goto cleanup_gendisks_part;
 		memset(sd_gendisks[i].part, 0, (SCSI_DISKS_PER_MAJOR << 4) * sizeof(struct hd_struct));
 		sd_gendisks[i].sizes = sd_sizes + (i * SCSI_DISKS_PER_MAJOR << 4);
-		sd_gendisks[i].nr_real = 0;
+		sd_gendisks[i].nr_real = SCSI_DISKS_PER_MAJOR;
 		sd_gendisks[i].real_devices =
 		    (void *) (rscsi_disks + i * SCSI_DISKS_PER_MAJOR);
 	}
@@ -1335,7 +1373,6 @@ static int sd_attach(Scsi_Device * SDp)
 	rscsi_disks[i].device = SDp;
 	rscsi_disks[i].has_part_table = 0;
 	sd_template.nr_dev++;
-	SD_GENDISK(i).nr_real++;
         devnum = i % SCSI_DISKS_PER_MAJOR;
         SD_GENDISK(i).de_arr[devnum] = SDp->de;
         if (SDp->removable)
@@ -1457,7 +1494,6 @@ static void sd_detach(Scsi_Device * SDp)
 			SDp->attached--;
 			sd_template.dev_noticed--;
 			sd_template.nr_dev--;
-			SD_GENDISK(i).nr_real--;
 			return;
 		}
 	return;
diff -urNp linux-5230/drivers/scsi/sd.h linux-5250/drivers/scsi/sd.h
--- linux-5230/drivers/scsi/sd.h
+++ linux-5250/drivers/scsi/sd.h
@@ -40,9 +40,7 @@ extern int revalidate_scsidisk(kdev_t de
  */
 extern kdev_t sd_find_target(void *host, int tgt);
 
-#define N_SD_MAJORS	8
-
-#define SD_MAJOR_MASK	(N_SD_MAJORS - 1)
+#define N_SD_MAJORS	16
 
 #endif
 
diff -urNp linux-5230/drivers/scsi/sg.c linux-5250/drivers/scsi/sg.c
--- linux-5230/drivers/scsi/sg.c
+++ linux-5250/drivers/scsi/sg.c
@@ -1057,7 +1057,7 @@ static int sg_fasync(int fd, struct file
 static void sg_rb_correct4mmap(Sg_scatter_hold * rsv_schp, int startFinish)
 {
     void * page_ptr;
-    struct page * page;
+    struct page * page = NULL;
     int k, m;
 
     SCSI_LOG_TIMEOUT(3, printk("sg_rb_correct4mmap: startFinish=%d, "
@@ -1068,8 +1068,13 @@ static void sg_rb_correct4mmap(Sg_scatte
 
         for (k = 0; k < rsv_schp->k_use_sg; ++k, ++sclp) {
 	    for (m = PAGE_SIZE; m < sclp->length; m += PAGE_SIZE) {
-		page_ptr = (unsigned char *)sclp->address + m;
-		page = virt_to_page(page_ptr);
+		if(sclp->page != NULL && sclp->address == NULL)
+		    page = sclp->page;
+		else if(sclp->page == NULL && sclp->address != NULL)
+		    page = virt_to_page(sclp->address + m);
+		else
+		    BUG();
+
 		if (startFinish)
 		    get_page(page);	/* increment page count */
 		else {
@@ -1121,8 +1126,12 @@ static struct page * sg_vma_nopage(struc
             len = vma->vm_end - sa;
             len = (len < sclp->length) ? len : sclp->length;
 	    if (offset < len) {
-		page_ptr = (unsigned char *)sclp->address + offset;
-		page = virt_to_page(page_ptr);
+		if(sclp->page != NULL && sclp->address == NULL)
+		    page = sclp->page;
+		else if(sclp->page == NULL && sclp->address != NULL)
+		    page = virt_to_page(sclp->address + offset);
+		else
+		    BUG();
 		get_page(page);	/* increment page count */
 		break;
 	    }
@@ -1584,7 +1593,8 @@ static int sg_start_req(Sg_request * srp
     	return 0;
     if (sg_allow_dio && (hp->flags & SG_FLAG_DIRECT_IO) && 
 	(dxfer_dir != SG_DXFER_UNKNOWN) && (0 == hp->iovec_count) &&
-	(! sfp->parentdp->device->host->unchecked_isa_dma)) {
+	(! sfp->parentdp->device->host->unchecked_isa_dma) &&
+	sfp->parentdp->device->host->highmem_io) {
 	res = sg_build_dir(srp, sfp, dxfer_len);
 	if (res <= 0)   /* -ve -> error, 0 -> done, 1 -> try indirect */
 	    return res;
@@ -1660,11 +1670,9 @@ static void sg_unmap_and(Sg_scatter_hold
 static int sg_build_dir(Sg_request * srp, Sg_fd * sfp, int dxfer_len)
 {
 #ifdef SG_ALLOW_DIO_CODE
-    int res, k, split, offset, num, mx_sc_elems, rem_sz;
+    int res, k, length, offset, mx_sc_elems;
     struct kiobuf * kp;
     char * mem_src_arr;
-    struct scatterlist * sclp;
-    unsigned long addr, prev_addr;
     sg_io_hdr_t * hp = &srp->header;
     Sg_scatter_hold * schp = &srp->data;
     int sg_tablesize = sfp->parentdp->sg_tablesize;
@@ -1686,56 +1694,34 @@ static int sg_build_dir(Sg_request * srp
     }
     schp->mapped = 1;
     kp = schp->kiobp;
-    prev_addr = (unsigned long) page_address(kp->maplist[0]);
-    for (k = 1, split = 0; k < kp->nr_pages; ++k, prev_addr = addr) {
-	addr = (unsigned long) page_address(kp->maplist[k]);
-	if ((prev_addr + PAGE_SIZE) != addr) {
-	    split = k;
-	    break;
-	}
-    }
-    if (! split) {
-	schp->k_use_sg = 0;
-	schp->buffer = page_address(kp->maplist[0]) + kp->offset;
-	schp->bufflen = dxfer_len;
-	schp->buffer_mem_src = SG_USER_MEM;
-	schp->b_malloc_len = dxfer_len;
-	hp->info |= SG_INFO_DIRECT_IO;
-	return 0;
-    }
     mx_sc_elems = sg_build_sgat(schp, sfp, sg_tablesize);
-    if (mx_sc_elems <= 1) {
+    if (mx_sc_elems < kp->nr_pages) {
 	sg_unmap_and(schp, 1);
 	sg_remove_scat(schp);
 	return 1;
     }
     mem_src_arr = schp->buffer + (mx_sc_elems * sizeof(struct scatterlist));
-    for (k = 0, sclp = schp->buffer, rem_sz = dxfer_len;
-	 (rem_sz > 0) && (k < mx_sc_elems);
-	 ++k, ++sclp) {
-	offset = (0 == k) ? kp->offset : 0;
-	num = (rem_sz > (PAGE_SIZE - offset)) ? (PAGE_SIZE - offset) :
-						rem_sz;
-	sclp->address = page_address(kp->maplist[k]) + offset;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,13)
-	sclp->page = NULL;
-#endif
-	sclp->length = num;
-	mem_src_arr[k] = SG_USER_MEM;
-	rem_sz -= num;
-	SCSI_LOG_TIMEOUT(5,
-	    printk("sg_build_dir: k=%d, a=0x%p, len=%d, ms=%d\n",
-	    k, sclp->address, num, mem_src_arr[k]));
+    memset(schp->buffer, 0, mx_sc_elems * sizeof(struct scatterlist));
+    memset(mem_src_arr, SG_USER_MEM, mx_sc_elems);
+
+    length = kp->length;
+    offset = kp->offset;
+    for (k = 0; k < kp->nr_pages; k++) {
+	struct scatterlist *sclp = &((struct scatterlist *)schp->buffer)[k];
+
+	sclp->page = kp->maplist[k];
+	sclp->offset = offset;
+	sclp->length = length;
+
+	if(sclp->length + sclp->offset > PAGE_SIZE)
+	    sclp->length = PAGE_SIZE - sclp->offset;
+	length -= sclp->length;
+	offset = 0;
     }
     schp->k_use_sg = k;
     SCSI_LOG_TIMEOUT(5,
-	printk("sg_build_dir: k_use_sg=%d, rem_sz=%d\n", k, rem_sz));
+	printk("sg_build_dir: k_use_sg=%d\n", schp->k_use_sg));
     schp->bufflen = dxfer_len;
-    if (rem_sz > 0) {   /* must have failed */
-	sg_unmap_and(schp, 1);
-	sg_remove_scat(schp);
-	return 1;   /* out of scatter gather elements, try indirect */
-    }
     hp->info |= SG_INFO_DIRECT_IO;
     return 0;
 #else
diff -urNp linux-5230/fs/partitions/check.c linux-5250/fs/partitions/check.c
--- linux-5230/fs/partitions/check.c
+++ linux-5250/fs/partitions/check.c
@@ -101,6 +101,10 @@ EXPORT_SYMBOL(genhd_dasd_ioctl);
  * a pointer to that same buffer (for convenience).
  */
 
+/* The major calculation part duplicates SD_MAJOR_INDEX verbatim. */
+#define SCSI_DEVICE_NR(M,m)	\
+    (( ( (((M) & 0x80) >> 4) + ((M) & 7) ) << (8 - 4)) + ((m) >> 4))
+
 char *disk_name (struct gendisk *hd, int minor, char *buf)
 {
 	const char *maj = hd->major_name;
@@ -151,8 +155,8 @@ char *disk_name (struct gendisk *hd, int
 			sprintf(buf, "%s%d", maj, unit);
 			return buf;
 	}
-	if (hd->major >= SCSI_DISK1_MAJOR && hd->major <= SCSI_DISK7_MAJOR) {
-		unit = unit + (hd->major - SCSI_DISK1_MAJOR + 1) * 16;
+	if (SCSI_DISK_MAJOR(hd->major)) {
+		unit = SCSI_DEVICE_NR(hd->major, minor);
 		if (unit+'a' > 'z') {
 			unit -= 26;
 			sprintf(buf, "sd%c%c", 'a' + unit / 26, 'a' + unit % 26);
diff -urNp linux-5230/include/linux/blk.h linux-5250/include/linux/blk.h
--- linux-5230/include/linux/blk.h
+++ linux-5250/include/linux/blk.h
@@ -151,7 +151,10 @@ static void floppy_off(unsigned int nr);
 
 #define DEVICE_NAME "scsidisk"
 #define TIMEOUT_VALUE (2*HZ)
-#define DEVICE_NR(device) (((MAJOR(device) & SD_MAJOR_MASK) << (8 - 4)) + (MINOR(device) >> 4))
+/* The major calculation part duplicates SD_MAJOR_INDEX verbatim. */
+#define DEVICE_NR(device)	\
+    (( ( ((MAJOR(device) & 0x80) >> 4) + (MAJOR(device) & 7) ) << (8 - 4)) + \
+     (MINOR(device) >> 4))
 
 /* Kludge to use the same number for both char and block major numbers */
 #elif  (MAJOR_NR == MD_MAJOR) && defined(MD_DRIVER)
diff -urNp linux-5230/include/linux/major.h linux-5250/include/linux/major.h
--- linux-5230/include/linux/major.h
+++ linux-5250/include/linux/major.h
@@ -123,6 +123,15 @@
 
 #define ATARAID_MAJOR		114
 
+#define SCSI_DISK10_MAJOR	128
+#define SCSI_DISK11_MAJOR	129
+#define SCSI_DISK12_MAJOR	130
+#define SCSI_DISK13_MAJOR	131
+#define SCSI_DISK14_MAJOR	132
+#define SCSI_DISK15_MAJOR	133
+#define SCSI_DISK16_MAJOR	134
+#define SCSI_DISK17_MAJOR	135
+
 #define DASD_MAJOR      94	/* Official assignations from Peter */
 
 #define MDISK_MAJOR     95	/* Official assignations from Peter */
@@ -174,7 +183,8 @@
  */
 
 #define SCSI_DISK_MAJOR(M) ((M) == SCSI_DISK0_MAJOR || \
-  ((M) >= SCSI_DISK1_MAJOR && (M) <= SCSI_DISK7_MAJOR))
+  ((M) >= SCSI_DISK1_MAJOR && (M) <= SCSI_DISK7_MAJOR) || \
+  ((M) >= SCSI_DISK10_MAJOR && (M) <= SCSI_DISK17_MAJOR))
   
 #define SCSI_BLK_MAJOR(M) \
   (SCSI_DISK_MAJOR(M)	\
