diff -urNp linux-5000/drivers/addon/megarac/admin.h linux-5010/drivers/addon/megarac/admin.h
--- linux-5000/drivers/addon/megarac/admin.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/admin.h	
@@ -0,0 +1,69 @@
+/*******************************************************************
+
+	File Name   :   ADMIN.H
+
+	Author      :   K.V.Subash & Parthiban Baskar
+
+	Modification :   J.Raja 
+
+	Purpose for  :   Alert by Mail is included
+	Modification     8 Feb 2000
+
+
+	Date        :   29 January 1998
+
+	Purpose     :   Equates, data types and structures for the
+					administrator list
+
+	Copyright   :   American Megatrends Inc., 1997-1998
+
+********************************************************************/
+
+#ifndef  __ADMIN_H__
+#define  __ADMIN_H__
+
+#include "dtypes.h"
+
+#define MAX_ADMINS  16
+#define LENGTH_OF_ALIAS 32
+#define LENGTH_OF_PASSWORD 32
+#define LENGTH_OF_CALLBACK_NO 32
+#define LENGTH_OF_PAGER_NO    32
+#define LENGTH_OF_CUSTOM_CODE 50
+//mjb$$
+#define LENGTH_OF_SERVICE_NO 32
+//mjb$$
+
+typedef struct Admin_Entry_Type_Tag
+{
+	u8    Index;          // 0 based index of this entry in the admin list
+	u8    Reserved1;      // Reserved
+	char    Alias [LENGTH_OF_ALIAS];      // Administrator Alias
+	char    Password [LENGTH_OF_PASSWORD];   // Administrator Password
+	char    CallBackNum [LENGTH_OF_CALLBACK_NO];   // Session callback phone number
+	char    PagerNum [LENGTH_OF_PAGER_NO];  // Paging service number
+	char    ServiceProviderNumber[LENGTH_OF_SERVICE_NO]; //In case of Alphanumeric paging
+	u8    PagerType;      // 00-none, 01-numeric, 02-alphanumeric (TAP)
+	u8    Reserved2;      // Reserved
+	TWOBYTES    Preferences;    // Page Bit Mask
+	char    CustomCode[LENGTH_OF_CUSTOM_CODE];
+	//for a customisable number to be sent on a numeric page
+} AdminEntry;
+
+//raja 
+typedef struct AdminMailIdList
+{
+char MailId[64];
+u8 Reserved[16];
+}ADMIN_MAIL_ID;
+
+typedef struct AdminMailServer
+{
+u8 TypeOfAddress;
+char ServerName[64];
+FOURBYTES IpAddress;
+}ADMIN_MAIL_SERVER_IP;
+
+//raja end
+#endif
+
diff -urNp linux-5000/drivers/addon/megarac/agpintfc.h linux-5010/drivers/addon/megarac/agpintfc.h
--- linux-5000/drivers/addon/megarac/agpintfc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/agpintfc.h	
@@ -0,0 +1,143 @@
+/*******************************************************************
+
+    File Name   :   AGPINTFC.H
+
+    Author      :   K.V.Subash & Parthiban Baskar
+
+    Date        :   12 December 1997
+
+    Purpose     :   Equates and data types used by the AGP Interface
+
+    Copyright   :   American Megatrends Inc., 1997-1998
+
+    TAB Spacing :   4
+
+********************************************************************/
+
+#ifndef  __AGPINTFC_H__
+#define  __AGPINTFC_H__
+
+#include "dtypes.h"
+#include "rtc.h"
+#include "rcs.h"
+
+/*  Command values written to the local command register    */
+# define AGP_COMMAND_GROUP  0x10
+
+#define AGP_NOP                     AGP_COMMAND_GROUP
+#define AGP_SET_TEXTVIDEO_ADDRESS   AGP_COMMAND_GROUP + 1
+#define AGP_SET_TEXTVIDEO_FORMAT    AGP_COMMAND_GROUP + 2
+#define AGP_START_TEXTVIDEO_SNOOP   AGP_COMMAND_GROUP + 3
+#define AGP_STOP_TEXTVIDEO_SNOOP    AGP_COMMAND_GROUP + 4
+#define AGP_START_SMI               AGP_COMMAND_GROUP + 5
+#define AGP_STOP_SMI                AGP_COMMAND_GROUP + 6
+#define GET_REDIRECTION_STATUS      AGP_COMMAND_GROUP + 7
+
+#define SMI_GENERATION_PORT     ((unsigned char *)0xFD400000)
+
+#define SMI_HANDSHAKE           0x01
+#define ENABLE_SMI              0x04
+#define DISABLE_SMI             0x00
+
+/*  The following defines for Host Video System are duplicated in
+    startup\src\fixddata.c for operational ease.  If they change here,
+    they have to change there too     */
+/*  Defines for Host Video system   */
+#define VGA     0
+#define AGP     1
+
+/*  Defines for the new method of videosnooping for AGP systems, with the
+    ability to treat NT/Novell crash screens as special cases   */
+#define STOP_SMI_RECD       2
+#define CANT_SMI_NOW        3
+#define SMI_TIMEOUT         4
+#define GRAPHICS_WITHOUT_DRIVER     5
+#define EXIT_AGPSCREENDUMP  0x0F
+
+/*  Copied from mg90xx.h    */
+# define LOCAL_INTR_FLAG_REG    ((unsigned char *)0xC0000800)
+# define LOCAL_INTR_GEN_REG     ((unsigned char *)0xC0000802)
+# define LOCAL_COMMAND_REG      ((unsigned char *)0xC0000803)
+# define LOCAL_DATA_REG         ((unsigned long *)0xC0000804)
+# define LOCAL_INTR_MASK_REG    ((unsigned char *)0xC0000809)
+# define LOCAL_FLAG_REG         ((unsigned char *)0xC000080C)
+
+# define SOFTINT2       0x80
+# define SRST           0x40
+# define SOFTINT1       0x10
+# define HCPF           0x08
+# define HDOF           0x04
+# define ENABLE_INTR    0x01
+# define INTR_SET       0x01
+# define HACC           0x04
+
+#define BLINK_ON        '5'
+#define BLINK_OFF_HI    '2'
+#define BLINK_OFF_LO    '5'
+#define HI_VIDEO        '1'
+#define LO_VIDEO_HI     '2'
+#define LO_VIDEO_LO     '1'
+
+typedef struct _TextScreenLogEntryHeaderTAG
+{
+    DATE_TIME   DateTimeStamp;
+    u8        Rows, Columns;
+    u8        CursorPosRow;
+    u8        CursorPosCol;
+    u8        Reserved [4];
+} TEXT_SCREEN_LOG_ENTRY_HEADER;
+
+typedef struct _TextScreenLogEntryTAG
+{
+    TEXT_SCREEN_LOG_ENTRY_HEADER   TextScreenHeader;
+    u8    TextScreenBuffer [16000];
+} TEXT_SCREEN_LOG_ENTRY;
+
+typedef struct _TextScreenPktToRemoteTAG
+{
+    RCS_COMMAND_PACKET  RCSCmdPkt;
+    TEXT_SCREEN_LOG_ENTRY_HEADER   TextScreenHeader;
+    u8    NumberOfBytesPerDirtyBit;
+    u8    NumberOfDirtyBytes;
+    u8    ScreenData [16100];
+} TEXT_SCREEN_PKT_TO_REMOTE;
+
+typedef struct _TextScreenLogPktToRemoteTAG
+{
+    RCS_COMMAND_PACKET RCSCmdPkt;
+    TEXT_SCREEN_LOG_ENTRY TextScreenPkt;
+
+} TEXT_SCREEN_LOG_PKT_TO_REMOTE;
+
+typedef struct _ReportCursorPosPktTAG
+{
+    u8        CursorPosRow;       // gives the current row
+    u8        CursorPosCol;       // gives the current column
+    TWOBYTES    LinearCursorPos;    // gives the current linear cursor pos
+    //08/09/99  // LinearCursorPos should be 0xffff when the other two fields
+    //Parts     //  are used.  If this is not 0xffff, then the top two fields
+                //  will be ignored regardless of what they contain,
+                //  and this value will be used.
+} REPORT_CURSOR_POS_PKT;
+
+
+/*
+    Function prototypes
+*/
+
+extern  int     AGPInitializeModule (void);
+extern  int     ReInitializeModules (void);
+extern  int     AGPHandler (void * param);
+extern  int     AGPScreenDump (void);
+extern  int     AltGotoxy (unsigned int CurrentPosition);
+extern  int     SetTextAttr (u8 Color);
+extern  int     AGPProcessDone(void);
+extern  int     ConnectionNotActive (u8 SessionIndex);
+extern  int     SendTextScreenToRemote (TEXT_SCREEN_PKT_TO_REMOTE *
+                        TextScreenPktToRemote, TWOBYTES Count);
+extern  u8    GetCursorPosRow (void);
+extern  u8    GetCursorPosCol (void);
+extern  void    ReportCursorPos (RCS_COMMAND_PACKET * RCSCmdPkt);
+
+#endif
+
diff -urNp linux-5000/drivers/addon/megarac/alerter.h linux-5010/drivers/addon/megarac/alerter.h
--- linux-5000/drivers/addon/megarac/alerter.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/alerter.h	
@@ -0,0 +1,77 @@
+
+/*******************************************************************
+
+	File Name    :   ALERTER.H
+
+	Author       :   K.V.Subash & Parthiban Baskar
+
+	Date         :   4 December 1997
+
+	Purpose      :   Prototype shell code for the Alerter
+					 Contains structures used internally by
+					 the Alerter and can be included
+
+					 by other modules which write to the
+					 Alerter Que(mostly Watcher)
+
+	Copyright    :   American Megatrends Inc., 1997-1998
+
+********************************************************************/
+#ifndef __ALERTER_H__
+#define __ALERTER_H__
+
+#include "dtypes.h"
+#include "rtc.h"
+
+#define PAGER_TYPE_NONE 00
+#define PAGER_TYPE_NUMERIC 01
+#define PAGER_TYPE_TAP 02
+
+#define ALERT_TYPES_NO_ALERT                    0x00
+#define ALERT_TYPES_MANAGED_CONSOLE   0x01
+#define ALERT_TYPES_PAGE                              0x02
+#define ALERT_TYPES_SNMPTRAP                    0x03
+//r
+#define ALERT_TYPES_EMAIL                    0x04
+//r
+
+#define LENGTH_OF_ALERT_DATA           100
+
+#define MAX_NO_ALERT_METHODES 4
+typedef struct _AlerterPacket
+{
+	FOURBYTES AlertCode;
+	u8 AlertData[100];
+	u8 OtherData[16];
+}
+ALERTER_PACKET;
+
+typedef struct _AlertPacket
+{
+	DATE_TIME DateTime;
+	FOURBYTES AlertCode;
+	u8 Reserved[16];
+	u8 AlertData[100];
+}
+ALERT_PACKET;
+
+
+
+typedef struct AlertOrderTable
+{
+u8 AlertMethod[4];
+u8 ReservedForExtraMethods[4];
+u8 RetriesMethod[4];
+u8 ReservedForExtraMethodRetries[4];
+TWOBYTES NotificationFrequency;
+}
+ALERT_ORDER_TABLE;
+
+//the alert order tabel structure which is used to maintain order of alerting
+//info. This is different from the individual admins alert info. He may choose to be paged or 
+//otherwise
+
+extern int ALERTER_ReadAlertTable(void);
+extern int ALERTER_ModifyAlertTable(void);
+#endif
+
diff -urNp linux-5000/drivers/addon/megarac/batmon.h linux-5010/drivers/addon/megarac/batmon.h
--- linux-5000/drivers/addon/megarac/batmon.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/batmon.h	
@@ -0,0 +1,59 @@
+/*************************************************************************
+*	File	:	BATRCS.C
+*
+*	Author	:	Prabhu.C
+*
+*	Purpose	:   Definition file for Battery Monitor module.
+*
+*	Date	:	23rd Feb 1998
+*
+*************************************************************************/
+#ifndef __BATMON_H__
+#define __BATMON_H__
+
+#include "dtypes.h"
+
+#define MAX_COUNTDOWN_TIMER   1800  // Battery charge life in seconds
+#define BATTERY_CHECK_PERIOD  30    // Frequency of battery checks in seconds
+
+#define BAT_GOOD		0x00
+#define BAT_ABSENT		0x01
+#define BAT_LOW			0x02
+#define BAT_BAD			0x03
+#define BAT_CHECKING 	0x04
+
+#define BAT_NOT_CHARGING		0x00
+#define BAT_FAST_CHARGING		0x01
+#define BAT_TRICKLE_CHARGING    0x02
+
+#define ALERT_LIMIT	900
+#define MAX_LIMIT	1000
+
+//Raid uses alert limit as 1000 and maximum limit as 1100
+
+#define BATTERY_PACK_PORT	(u8 *)0xfd500000
+#define BAT_CHARGE_CON_PORT	(u8 *)0xfd500002
+#define BAT_BACKUP_CON_PORT	(u8 *)0xfd500004
+
+/* BIT definitions */
+#define	STLED2	0x80	// Gives charge action status
+#define	STLED1	0x40	// Gives charge action status
+#define BV145	0x20	// Indicates whether the voltage of the battery pack
+						// is above or below 1.45v
+#define	NORMAL	0x10	// Battery pack is low (< or > 0.9v per cell)
+#define	CHGEN	0x08	// Enable Fast Charging
+#define	INH		0x04	// Charge Inhibit
+#define	BE		0x02	// Battery backup enable
+#define	BC		0x01	// Battery backup connect
+
+/*************************************************************************/
+
+typedef struct GET_BAT_STATUS_TYPE_tag
+{
+	u8 BatteryStatus;
+	u8 ChargeState;
+	u16 FastChargeCount;
+}GET_BAT_STATUS_TYPE;
+
+#endif
+
diff -urNp linux-5000/drivers/addon/megarac/ccbhdlr.h linux-5010/drivers/addon/megarac/ccbhdlr.h
--- linux-5000/drivers/addon/megarac/ccbhdlr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/ccbhdlr.h	
@@ -0,0 +1,121 @@
+/*******************************************************************
+
+	File Name   :   CCBHDLR.H
+
+	Author      :   K.V.Subash & Parthiban Baskar
+
+	Date        :   2 December 1997
+
+	Purpose     :   Prototype shell code for the CCB handler
+
+	Copyright       :       American Megatrends Inc., 1997-1998
+
+********************************************************************/
+
+#ifndef __CCBHDLR_H__
+#define __CCBHDLR_H__
+
+#include "dtypes.h"
+
+/*********************Codes needed for CCB Classification*****************/
+#define HB_COMMAND 0x0001
+#define EVENT_COMMAND 0X0002
+#define ALERT_COMMAND 0x0003
+
+// Codes 4 and 5 are reserved
+#define TEST_COMMAND 0x0004
+#define HOST_OS_SHUTDOWN_RESPONSE_COMMAND 0x0005
+
+#define START_HB_COMMAND 0x0006
+#define STOP_HB_COMMAND 0x0007
+
+#define SET_DATE_TIME_COMMAND 0x0008
+#define GET_DATE_TIME_COMMAND 0x0009
+
+#define MIN_HEARTBEAT_PERIOD 5
+/*************************************************************************/
+
+#define SEGFP(PTR) (PTR & 0xffff0000)
+#define OFFFP(PTR) (PTR & 0x0000ffff)
+#define HOSTTOLOCALADDR(PTR) ( (SEGFP(PTR) >> 4 + OFFFP(PTR)) + 0x40000000 )
+#define ABSOLUTE(SEG,OFF) (SEG >> 4 + OFF)
+
+
+
+typedef struct _CCB_Header
+{
+	TWOBYTES Command; /**indicates CCB Type**/
+	TWOBYTES Status;  /**Completion status of request**/
+	TWOBYTES Length;  /**Indicates length of the body**/
+	u8 Reserved[10]; /**resreved for future use**/
+}
+CCB_Header;
+
+
+typedef struct _Test_Command_Packet
+{
+	TWOBYTES Command; /**indicates CCB Type**/
+	TWOBYTES Status;  /**Completion status of request**/
+	TWOBYTES Length;  /**Indicates length of the body**/
+	u8 Reserved[10]; /**resreved for future use**/
+    TWOBYTES Counter;
+}
+TEST_COMMAND_PACKET;
+
+
+typedef struct _CCB_Start_HB_Cmd_Packet
+{
+   CCB_Header  CCBHeader;
+   FOURBYTES   HeartBeatPeriod;
+   char Data[1];
+}CCB_START_HB_CMD_PACKET;
+
+typedef struct _CCB_HB_Cmd_Packet
+{
+   CCB_Header  CCBHeader;
+   char        Data[1];       // Used for referencing time & date data
+}CCB_HB_CMD_PACKET;
+
+typedef struct _CCB_Event_Cmd_Packet
+{
+   CCB_Header  CCBHeader;
+   char        Data[1];       // Used for referencing event data
+}CCB_EVENT_CMD_PACKET;
+
+typedef struct _CCB_Alert_Cmd_Packet
+{
+   CCB_Header  CCBHeader;
+   char        Data[1];       // Used for referencing alert data
+}CCB_ALERT_CMD_PACKET;
+
+/**This command control block structure is actually used by the host.
+Pertinent Question :: WILL THE REMOTE SIDE WRAP A CCB IN SOME OTHER FORM
+AND SEND IT ALONG????*/
+
+/* Answer to the above: NO
+   The remote API is strictly Remote Console Service (RCS) packets.
+   A CCB packet sent by the remote would be invalid and an error 
+   returned.
+   Wrapping a CCB has no context.
+*/
+
+typedef struct _CCB_Set_Date_Time_Cmd_Packet
+{
+   CCB_Header  CCBHeader;
+   char        Data[1];       // Used for referencing time & date data
+}CCB_SET_DATE_TIME_CMD_PACKET;
+
+typedef struct _CCB_Get_Date_Time_Cmd_Packet
+{
+   CCB_Header  CCBHeader;
+   char        Data[1];       // Used for referencing time & date data
+}CCB_GET_DATE_TIME_CMD_PACKET;
+
+#endif
+
+
+
+
+
+
+
diff -urNp linux-5000/drivers/addon/megarac/comrcs.h linux-5010/drivers/addon/megarac/comrcs.h
--- linux-5000/drivers/addon/megarac/comrcs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/comrcs.h	
@@ -0,0 +1,86 @@
+#ifndef __COMRCS_H__
+#define __COMRCS_H__
+
+#include "rcs.h"
+#include "dtypes.h"
+
+#define SNMP_ENTRIES		8
+#define MGNT_CON_ENTRIES	8
+
+#define LENGTH_OF_PHONENUMBER 33
+#define LENGTH_OF_EXTRA_MODEM_STRING 80
+#define LENGTH_OF_COMUNITY_NAME 64
+
+#define LENGTH_OF_DIALOUT_ALIAS 32
+#define LENGTH_OF_DIALOUT_PASSWORD 32
+
+typedef struct NET_CFG_TYPE_tag
+{
+	FOURBYTES	IP;
+	FOURBYTES	SubnetMask;
+	FOURBYTES   Gateway;
+}NET_CFG_TYPE;
+
+typedef struct PPP_CFG_TYPE_tag
+{
+	FOURBYTES	IPPoolStart;
+}PPP_CFG_TYPE;
+
+typedef struct DIALOUT_CFG_TYPE_tag
+{
+   char  Alias [LENGTH_OF_DIALOUT_ALIAS];       // Dial out Alias
+   char  Password [LENGTH_OF_DIALOUT_PASSWORD]; // Dial out Password
+}DIALOUT_CFG_TYPE;
+
+typedef struct MODEM_CFG_TYPE_tag
+{
+	u8		ModemSelect;
+	FOURBYTES   BaudRate;
+	u8		DialMode;
+	u8		ExtraModemInitString[LENGTH_OF_EXTRA_MODEM_STRING];
+	FOURBYTES	PowerOnDelay;
+	FOURBYTES	SignalDelay;
+	FOURBYTES	RingDelay;
+	FOURBYTES	CDDelay;
+	FOURBYTES	ResponseDelay;
+	FOURBYTES	HangupDelay;
+	FOURBYTES	ConnectTimeOut;
+	FOURBYTES	DetectTimeOut;
+}MODEM_CFG_TYPE;
+
+typedef struct SNMP_DEST_TYPE_tag
+{
+        u8        index;
+	FOURBYTES   IP;
+        u8        ComunityName[LENGTH_OF_COMUNITY_NAME];
+}SNMP_DEST_TYPE;
+
+
+
+typedef struct MGNT_CON_TYPE_tag
+{
+	u8	index;
+	u8	PhoneNumber[LENGTH_OF_PHONENUMBER];
+}MGNT_CON_TYPE;
+
+typedef struct TCPIP_CFG_TYPE_tag{
+   TWOBYTES wEtherMTU;
+   TWOBYTES wTCPTTL;
+   TWOBYTES wSRTTBase;
+   TWOBYTES wSRTTDefault;
+   TWOBYTES wTCPReXmtMin;
+   TWOBYTES wTCPReXmtMax;
+//   TWOBYTES wTCPMSL;          /* max seg lifetime */
+//   TWOBYTES wTCPPersistMin    /* retransmit persistance */
+//   TWOBYTES wTCPPersistMax    /* maximum persist interval */
+//   TWOBYTES wTCPKeepInit      /* initial connect keep alive */
+//   TWOBYTES wTCPKeepIdle      /* dflt time before probing */
+//   TWOBYTES wTCPKeepInterval  /* default probe interval */
+//   TWOBYTES wTCPKeepCount     /* max probes before drop */
+//   TWOBYTES wTCPLingerTime    /* linger at most 2 minutes */
+//   TWOBYTES wTCPMaxReXmt      /* maximum retransmits */
+   u8 Reserved[52];
+}TCPIP_CFG_TYPE;
+
+#endif
+
diff -urNp linux-5000/drivers/addon/megarac/crc16.h linux-5010/drivers/addon/megarac/crc16.h
--- linux-5000/drivers/addon/megarac/crc16.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/crc16.h	
@@ -0,0 +1,59 @@
+/*******************************************************************
+    File Name   :   crc16.H
+        Reversed engineered from the following file in SourceSafe:
+            \Rac\Utils\raccfgLite\raccfg\winnt\src\CheckSum.c
+        Used by flashROM upgrade software.
+********************************************************************/
+#ifndef CRC_16_H
+#define CRC_16_H
+
+
+#define PPPINITFCS16   0xffff
+#define PPPGOODFCS16   0xf0b8
+
+#define CRC16_TABLE                                                                             \
+const static unsigned short Crc16Tab[256] = {                                                   \
+    0x0000,     0x1189,     0x2312,     0x329b,     0x4624,     0x57ad,     0x6536,     0x74bf, \
+    0x8c48,     0x9dc1,     0xaf5a,     0xbed3,     0xca6c,     0xdbe5,     0xe97e,     0xf8f7, \
+    0x1081,     0x0108,     0x3393,     0x221a,     0x56a5,     0x472c,     0x75b7,     0x643e, \
+    0x9cc9,     0x8d40,     0xbfdb,     0xae52,     0xdaed,     0xcb64,     0xf9ff,     0xe876, \
+    0x2102,     0x308b,     0x0210,     0x1399,     0x6726,     0x76af,     0x4434,     0x55bd, \
+    0xad4a,     0xbcc3,     0x8e58,     0x9fd1,     0xeb6e,     0xfae7,     0xc87c,     0xd9f5, \
+    0x3183,     0x200a,     0x1291,     0x0318,     0x77a7,     0x662e,     0x54b5,     0x453c, \
+    0xbdcb,     0xac42,     0x9ed9,     0x8f50,     0xfbef,     0xea66,     0xd8fd,     0xc974, \
+    0x4204,     0x538d,     0x6116,     0x709f,     0x0420,     0x15a9,     0x2732,     0x36bb, \
+    0xce4c,     0xdfc5,     0xed5e,     0xfcd7,     0x8868,     0x99e1,     0xab7a,     0xbaf3, \
+    0x5285,     0x430c,     0x7197,     0x601e,     0x14a1,     0x0528,     0x37b3,     0x263a, \
+    0xdecd,     0xcf44,     0xfddf,     0xec56,     0x98e9,     0x8960,     0xbbfb,     0xaa72, \
+    0x6306,     0x728f,     0x4014,     0x519d,     0x2522,     0x34ab,     0x0630,     0x17b9, \
+    0xef4e,     0xfec7,     0xcc5c,     0xddd5,     0xa96a,     0xb8e3,     0x8a78,     0x9bf1, \
+    0x7387,     0x620e,     0x5095,     0x411c,     0x35a3,     0x242a,     0x16b1,     0x0738, \
+    0xffcf,     0xee46,     0xdcdd,     0xcd54,     0xb9eb,     0xa862,     0x9af9,     0x8b70, \
+    0x8408,     0x9581,     0xa71a,     0xb693,     0xc22c,     0xd3a5,     0xe13e,     0xf0b7, \
+    0x0840,     0x19c9,     0x2b52,     0x3adb,     0x4e64,     0x5fed,     0x6d76,     0x7cff, \
+    0x9489,     0x8500,     0xb79b,     0xa612,     0xd2ad,     0xc324,     0xf1bf,     0xe036, \
+    0x18c1,     0x0948,     0x3bd3,     0x2a5a,     0x5ee5,     0x4f6c,     0x7df7,     0x6c7e, \
+    0xa50a,     0xb483,     0x8618,     0x9791,     0xe32e,     0xf2a7,     0xc03c,     0xd1b5, \
+    0x2942,     0x38cb,     0x0a50,     0x1bd9,     0x6f66,     0x7eef,     0x4c74,     0x5dfd, \
+    0xb58b,     0xa402,     0x9699,     0x8710,     0xf3af,     0xe226,     0xd0bd,     0xc134, \
+    0x39c3,     0x284a,     0x1ad1,     0x0b58,     0x7fe7,     0x6e6e,     0x5cf5,     0x4d7c, \
+    0xc60c,     0xd785,     0xe51e,     0xf497,     0x8028,     0x91a1,     0xa33a,     0xb2b3, \
+    0x4a44,     0x5bcd,     0x6956,     0x78df,     0x0c60,     0x1de9,     0x2f72,     0x3efb, \
+    0xd68d,     0xc704,     0xf59f,     0xe416,     0x90a9,     0x8120,     0xb3bb,     0xa232, \
+    0x5ac5,     0x4b4c,     0x79d7,     0x685e,     0x1ce1,     0x0d68,     0x3ff3,     0x2e7a, \
+    0xe70e,     0xf687,     0xc41c,     0xd595,     0xa12a,     0xb0a3,     0x8238,     0x93b1, \
+    0x6b46,     0x7acf,     0x4854,     0x59dd,     0x2d62,     0x3ceb,     0x0e70,     0x1ff9, \
+    0xf78f,     0xe606,     0xd49d,     0xc514,     0xb1ab,     0xa022,     0x92b9,     0x8330, \
+    0x7bc7,     0x6a4e,     0x58d5,     0x495c,     0x3de3,     0x2c6a,     0x1ef1,     0x0f78  \
+};
+
+#define CRC16_CALC                                                                  \
+static unsigned short calcCrc16( unsigned short Crc16, unsigned char* cp, int len ) \
+{                                                                                   \
+    while(len--)                                                                    \
+        Crc16 = (Crc16 >> 8) ^ Crc16Tab[(Crc16 ^ *cp++) & 0xff];                    \
+    return (Crc16);                                                                 \
+}
+
+
+#endif  /* #ifndef CRC_16_H */
diff -urNp linux-5000/drivers/addon/megarac/dbg_fn.h linux-5010/drivers/addon/megarac/dbg_fn.h
--- linux-5000/drivers/addon/megarac/dbg_fn.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/dbg_fn.h	
@@ -0,0 +1,80 @@
+/**********************************************************************
+
+        FILE        :       DBG_FN.H
+
+        PURPOSE     :       DebugLog,   Defines values for FileDesc 
+
+        AUTHOR(s)   :       Srikumar and Raja
+
+        DATE        :       28th September 1998
+
+        MODIFICATION HISTORY    :
+
+
+**********************************************************************/
+#ifndef __DBG_FN_H__
+#define __DBG_FN_H__
+
+
+//  The FileDesc value 0x00 & 0xFF are reserved.
+  
+#define DL_FN_ADMIN     0x01
+#define DL_FN_ALERTER   0x02
+#define DL_FN_BATRCS    0x03
+#define DL_FN_BATTMON   0x04
+#define DL_FN_CCBHDLR   0x05
+#define DL_FN_CQ        0x06
+#define DL_FN_DIALOUT   0x07
+#define DL_FN_INTERFAC  0x08
+#define DL_FN_PPP       0x09
+#define DL_FN_SERCOMM   0x0A
+#define DL_FN_SLIP      0x0B
+#define DL_FN_SOCKCOMM  0x0C
+#define DL_FN_TABLES    0x0D
+#define DL_FN_DMEM      0x0E
+#define DL_FN_ERRORHDL  0x0F
+#define DL_FN_EVTLOG    0x10
+#define DL_FN_HBMON     0x11
+#define DL_FN_HHF       0x12
+#define DL_FN_HHFDATA   0x13
+#define DL_FN_HHFTYPE   0x14
+#define DL_FN_MON       0x15
+#define DL_FN_RCSHHF    0x16
+#define DL_FN_MEGARAC   0x17
+#define DL_FN_MEGARACT  0x18
+#define DL_FN_MG90XX    0x19
+#define DL_FN_COMRCS    0x1A
+#define DL_FN_NVDATA    0x1B
+#define DL_FN_NVRAM     0x1C
+#define DL_FN_PCCARD    0x1D
+#define DL_FN_PCMCIA    0x1E
+#define DL_FN_POST      0x1F
+#define DL_FN_AGPINTFC  0x20
+#define DL_FN_REDIRECT  0x21
+#define DL_FN_RCSAC     0x22
+#define DL_FN_RCSCONN   0x23
+#define DL_FN_RCSDIAG   0x24
+#define DL_FN_RCSDISP   0x25
+#define DL_FN_RCSIC     0x26
+#define DL_FN_RCSRED    0x27
+#define DL_FN_RCSUSR    0x28
+#define DL_FN_RTC       0x29
+#define DL_FN_MODEM     0x2A
+#define DL_FN_PAGE      0x2B
+#define DL_FN_SERIAL    0x2C
+#define DL_FN_TAP       0x2D
+#define DL_FN_SNMPSERV  0x2E
+#define DL_FN_SNMPTRAP  0x2F
+#define DL_FN_AMIHELP   0x30
+#define DL_FN_DBGPRT    0x31
+#define DL_FN_DIRPRT    0x32
+#define DL_FN_REGDUMP   0x33
+#define DL_FN_SIZES     0x34
+#define DL_FN_VSPHDLR   0x35
+#define DL_FN_RCSHDLR   0x36
+#define DL_FN_MISC		0x37
+
+#define MAX_MODULES     0x38
+
+#endif
+
diff -urNp linux-5000/drivers/addon/megarac/dbglog.h linux-5010/drivers/addon/megarac/dbglog.h
--- linux-5000/drivers/addon/megarac/dbglog.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/dbglog.h	
@@ -0,0 +1,93 @@
+/**********************************************************************
+
+		FILE        :       DEBUG.H
+
+		PURPOSE     :       Defines values and structures used for
+							checkpoint logging
+
+		AUTHOR(s)   :       Srikumar and Raja
+
+		DATE        :       24th September 1998
+
+		MODIFICATION HISTORY    :
+
+
+**********************************************************************/
+#ifndef __DBGLOG_H__
+#define __DBGLOG_H__
+
+#include "dbg_fn.h"
+
+#define COMMON_FOURBYTES  unsigned long
+#define LENGTH 524288   //2 megabytes totally
+
+
+/* error codes */
+#define DL_SUCCESS  1
+#define DL_ERROR_INDEX_OUT_OF_RANGE -1
+#define DL_NOT_LOGGED               -2
+
+/*Severities*/
+#define DL_SEV_FATAL   0x00
+#define DL_SEV_WARNING 0x01
+#define DL_SEV_INFO    0x02
+#define DL_SEV_DATA    0x03
+
+#define HEADER_OK 1
+#define LOG_OK 2
+
+#define HEADER_CORRUPT 5
+#define LOG_CORRUPT 6
+
+/* Checkpoint String Limits */
+#define MAX_CHECKPOINT_STRING_LENGTH      80
+#define MAX_CHECKPOINT_STRINGS_PER_MODULE 50
+
+typedef struct _CheckPtLogHeader
+{
+        COMMON_FOURBYTES  head;
+        COMMON_FOURBYTES* LogTable;
+        COMMON_FOURBYTES  TotalNoOfElementsNow;
+        COMMON_FOURBYTES  MaximumNoOfElements;
+        COMMON_FOURBYTES  HeaderChecksum;
+        COMMON_FOURBYTES  Reserved1;
+        COMMON_FOURBYTES  Reserved2;
+} CHECKPT_LOG_HEADER;
+
+
+
+typedef union _CheckPt
+{
+        COMMON_FOURBYTES Code;
+	struct _DetailedCode
+	{
+		unsigned int CodeValue:16;
+                unsigned int DataLength:6;
+                unsigned int Severity:2;
+		unsigned int FileDesc:8;
+	} DetailedCode;
+
+} CHECKPT;
+
+
+#define HEADER_LOCATION (CHECKPT_LOG_HEADER*)0x800000
+#define TABLE_LOCATION  0x800200
+#define CHECKSUM_TABLE_LOCATION  (unsigned short*)TABLE_LOCATION + LENGTH + 10
+
+
+
+int BuildCheckpointHeader(void);
+
+int LogCheckpointLong(COMMON_FOURBYTES CheckpointValue);
+int LogCheckpoint_FSC(char filedesc, char severity, short codevalue);
+int LogCheckpointData(char filedesc, char buffer[], COMMON_FOURBYTES NoOfElements);
+
+int GetCheckpointDump(long index, COMMON_FOURBYTES TotalNoOfElementsRqd, COMMON_FOURBYTES buffer[]);
+int GetLast_N_Checkpoint(COMMON_FOURBYTES TotalNoOfElementsRqd, COMMON_FOURBYTES buffer[]);
+
+void GetCheckpointHeader(CHECKPT_LOG_HEADER* FillUp);
+
+void ClearCheckpointLog(void);
+
+
+#endif
diff -urNp linux-5000/drivers/addon/megarac/dmi.h linux-5010/drivers/addon/megarac/dmi.h
--- linux-5000/drivers/addon/megarac/dmi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/dmi.h	
@@ -0,0 +1,38 @@
+/*
+ ****************************************************************************
+ *
+ *          File Name   :       DMI.H
+ *
+ *          Author      :       Mike Bartholomew.
+ *
+ *          Date        :       08 Oct 1998
+ *
+ *          Purpose     :       This include file used for definitions 
+ *                              associated with detecting DMI information
+ *                              within the host system BIOS
+ *
+ *          Copyright   :       American Megatrends Inc., (C) 1997-1998
+ *                              All rights reserved.
+ *
+ ****************************************************************************
+ */
+#ifndef __AMI_DMI_H__
+#define __AMI_DMI_H__
+
+#define MAX_DMI_BUFFER 8192
+#define BIOS_START_ADDR 0x000f0000l
+#define BIOS_STOP_ADDR 0x00100000l
+
+typedef struct _dmi_header{
+   unsigned char  Signature[5];
+   unsigned char  Checksum;
+   unsigned short StructLength;
+   unsigned char  StructAddr[4];
+   unsigned short NumberOfStructs;
+   unsigned char  BCDRevision;
+   unsigned char  Reserved;
+}DMI_HEADER;
+
+#endif
+/***************************** End of DMI.H *******************************/
+
diff -urNp linux-5000/drivers/addon/megarac/dtypes.h linux-5010/drivers/addon/megarac/dtypes.h
--- linux-5000/drivers/addon/megarac/dtypes.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/dtypes.h	
@@ -0,0 +1,28 @@
+/*******************************************************************
+
+    File Name   :   DTYPES.H
+
+    Author      :   K.V.Subash & Parthiban Baskar
+
+    Date        :   5 December 1997
+
+    Purpose     :   Data Types defined within
+
+	Copyright	:	American Megatrends Inc., 1997-1998
+
+    Tab Spacing :   4
+
+********************************************************************/
+
+#ifndef __DTYPES_H__
+#define __DTYPES_H__
+
+#define TWOBYTES	unsigned short
+#define FOURBYTES  unsigned int
+#define EIGHTBYTES unsigned double
+#define BYTE		      unsigned char	
+
+#define PTR32BIT  unsigned char*
+
+#endif
+
diff -urNp linux-5000/drivers/addon/megarac/errcod.h linux-5010/drivers/addon/megarac/errcod.h
--- linux-5000/drivers/addon/megarac/errcod.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/errcod.h	
@@ -0,0 +1,97 @@
+/*******************************************************************
+
+    File Name   :   errcod.H
+
+	Author      :   K.V.Subash & Parthiban Baskar
+
+    Date        :   12 February 1998
+
+    Purpose     :   Error codes returned to RCS Users
+
+
+	Copyright   :   American Megatrends Inc., 1997-1998
+
+********************************************************************/
+#ifndef __ERRCOD_H__
+#define __ERRCOD_H__
+
+
+/*****************************SUCCESS CODE*************************/
+
+#define  RCSERR_SUCCESS 0x0000
+//ZERO is the success value usually returned
+
+/******************************************************************/
+
+
+
+/***************************SYSTEM ERROR GROUP*********************/
+//grp codes go as follows : 0xFFXX;
+/******************************************************************/
+
+
+/***************************NETWORK ERROR GROUP*********************/
+//grp codes go as follows : 0x00XX;
+/******************************************************************/
+
+
+
+/***************************FIRMWARE INIT GROUP*********************/
+//grp codes go as follows : 0x01XX;
+/******************************************************************/
+
+
+
+/***************************FIRMWARE OPERATIONS GROUP**************/
+//grp codes go as follows : 0x02XX;
+#define DRACERR_LIST_FULL                               0x0201
+#define DRACERR_INVALID_INDEX                           0x0202
+#define DRACERR_NULL_POINTER_ARGUMENT                   0x0203
+#define DRACERR_NO_RECORD                               0x0204
+#define DRACERR_INVALID_LOGIN                           0x0205
+#define DRACERR_REDIRECTION_ALREADY_ACTIVE              0x0206
+#define DRACERR_HOST_ALIVE                              0x0207
+#define DRACERR_HOST_DEAD                               0x0208
+#define DRACERR_HOST_WEAK                               0x0209
+#define DRACERR_HOST_STARTUP_FAILED                     0x020A
+#define DRACERR_HOST_IN_STARTUP                         0x020B
+#define SDKERR_MON_ABSENT                               0x020C
+#define SDKERR_MON_TRY_LATER                            0x020D
+#define SDKERR_MON_I2C_BUS_ERROR__LAST_VALUE_READ       0x020E
+#define SDKERR_MON_TEMPORARILY_DISABLED                 0x020F
+/******************************************************************/
+
+
+
+
+
+
+/***************************RCS GROUP******************************/
+//grp codes go as follows : 0x04XX;
+#define RCSERR_LOGIN_SUCCESSFUL_NO_CALLBACK           0x0400
+#define RCSERR_RESOURCES_OCCUPIED_RETRY               0x0401
+#define RCSERR_INVALID_INDEX                          0x0402
+#define RCSERR_BUSY                                   0x0403
+#define RCSERR_INVALID_LOGIN                          0x0404
+#define RCSERR_BAD_LENGTH                             0x0405
+#define RCSERR_BAD_ARGUMENT                           0x0406
+#define RCSERR_OUT_OF_BUFFERS__RETRY                  0x0407
+#define RCSERR_REMOTE_CONNECTION_DEAD                 0x0408
+#define RCSERR_DEVICE_NO_RESPONSE                     0x0409
+#define RCSERR_NVRAM_UPDATE_ERROR                     0x040a
+#define RCSERR_REDIRECTION_NOT_ACTIVE                 0x040b
+#define RCSERR_NO_PAGERNUMBER_SPECIFIED               0X040c
+#define RCSERR_NO_PAGER_TYPE                          0x040d
+#define RCSERR_OS_SHUTDOWN_PENDING                    0x040e
+#define RCSERR_INFORMATION_NOT_AVAILABLE              0x040f
+#define RCSERR_BUFFER_TOO_LONG                        0x0410
+#define RCSERR_LIST_FULL                              0x0411
+#define RCSERR_NULL_POINTER_ARGUMENT                  0x0412
+#define RCSERR_IP_IN_USE                              0x0413
+#define RCSERR_SYSTEM_FAILED_TO_POWER_ON              0x0414
+#define RCSERR_SYSTEM_FAILED_TO_POWER_OFF             0x0415
+#define RCSERR_FUNCTION_NOT_SUPPORTED                 0x04ff
+
+
+/******************************************************************/
+#endif
diff -urNp linux-5000/drivers/addon/megarac/evtlog.h linux-5010/drivers/addon/megarac/evtlog.h
--- linux-5000/drivers/addon/megarac/evtlog.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/evtlog.h	
@@ -0,0 +1,57 @@
+
+/*******************************************************************
+
+    File Name   :   EVTLOG.H
+
+    Author      :   K.V.Subash & Parthiban Baskar
+
+    Date        :   2 December 1997
+
+    Purpose     :   Prototype shell code for the Event Logger
+                    Contains structures used internally by
+                    the Event Logger and can be included
+                    by other modules which write to the
+                    Event Que
+
+	Copyright	:	American Megatrends Inc., 1997-1998
+
+********************************************************************/
+
+#ifndef __EVTLOG_H__
+#define __EVTLOG_H__
+
+#include "dtypes.h"
+#include "rtc.h"
+
+typedef struct _EventPacket
+{
+	FOURBYTES EventCode;
+	u8 EventData[100];
+	u8 OtherData[16];
+}
+EVENT_PACKET;
+
+
+
+
+typedef struct _Event_Log_Entry
+{
+	DATE_TIME DateTime;
+	FOURBYTES EventCode;
+	u8 Reserved[16];
+	u8 EventData[100];
+}
+EVENT_LOG_ENTRY;
+
+
+extern int EVTLOG_GetMostRecentNEvents(unsigned short* NoOfEvents,unsigned char* EventBuffer);
+
+#endif
+
+
+
+
+
+
+
+
diff -urNp linux-5000/drivers/addon/megarac/flash.h linux-5010/drivers/addon/megarac/flash.h
--- linux-5000/drivers/addon/megarac/flash.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/flash.h	
@@ -0,0 +1,96 @@
+/*******************************************************************
+    File Name   :   flash.H
+        Reversed engineered from the following file in SourceSafe:
+          \Rac\Utils\raccfgLite\raccfg\winnt\Inc\Cfg\Flash.h
+********************************************************************/
+#ifndef AMI_FLASH_H
+#define AMI_FLASH_H
+
+
+/*-------------- Packet structure of the Flash Command Packets ------------*/
+
+typedef struct  {
+        char AmiSig[4];
+        unsigned char Major;
+        unsigned char Minor;
+        char Padding[10];           /* 16 Bit Align of i960 Compiler */
+        char BuildDate[16];
+        char BuildTime[16];
+        char SdkVersion[8];
+} FwVer;
+
+
+typedef struct {
+    unsigned short Command;
+    unsigned short Status;
+    unsigned short Length;
+    unsigned long  Addr;
+    unsigned long  Size;
+    unsigned long  ExtStatus;
+    unsigned long  Reserved[3];
+    unsigned short ResShort;
+    BYTE           Data[1];     /* Data Follows the 32 Byte of Header */
+} FLASH_CMD_PKT;
+
+typedef struct
+{
+    RCS_COMMAND_PACKET  RCSCmdPkt;
+    FLASH_CMD_PKT       FlashHead;
+} FLASH_RCS_HEADER;
+
+/*----------------------- Flash Command Definitions -----------------------*/
+//# define NEW_FLASH_CMD          0x40    /* Command used to goto flash mode   */
+//# define ISSUE_FLASH_CMD        0x41    /* Command port value for flash cmd  */
+
+# define FLASH_SIZE             0x401
+# define FLASH_BLOCKSIZE        0x402
+# define FLASH_ERASE            0x403
+# define FLASH_READ             0x404
+# define FLASH_WRITE            0x405
+# define FLASH_VERIFY           0x406
+
+/*-------------------------- Flash Return Values --------------------------*/
+# define FLASH_SUCCESS              0x0000
+# define FLASH_UNSUPPORTED_COMMAND  0x0001
+# define FLASH_OUT_OF_RANGE         0x0002
+# define FLASH_ERROR                0x00FF
+
+/*----------- Defines of Extended Status Commands and ErrorCodes ----------*/
+
+# define FLASH_ERR_SUCCESS          0x00
+# define FLASH_ERR_FAIL             0x01    /* 'command' against 'block' n failed */
+# define FLASH_ERR_VPP_LOW          0x02    /* 'command' against 'block' n failed due to low Vpp */
+# define FLASH_ERR_DEV_PROTECT      0x03    /* 'command' against 'block' n failed due to protection */
+# define FLASH_ERR_CMDSEQ           0x04    /* 'command' against 'block' n failed due to internal error */
+# define FLASH_ERR_RESERVED         0x05
+# define FLASH_ERR_STOP             0x06
+# define FLASH_ERR_START            0x07
+
+# define FLASH_XCMD_FLASH_OVER      0x00
+# define FLASH_XCMD_CLEAR_LOCK      0x01
+# define FLASH_XCMD_BLOCK_LOCK      0x02
+# define FLASH_XCMD_WRITE           0x03
+# define FLASH_XCMD_ERASE           0x04
+# define FLASH_XCMD_VERIFY          0x05
+# define FLASH_XCMD_FLASH_SIZE      0x06
+# define FLASH_XCMD_READ            0x07
+# define FLASH_XCMD_DLL_INITIAL     0x0e
+# define FLASH_XCMD_DLL_HARD_RESET  0x0f
+
+#define FLASH_STATUS_DISSECT(statusIn,commandOut,errorOut,locationOut)  \
+    {   commandOut  = (statusIn >> 28) & 0x0F;                          \
+        errorOut    = (statusIn >> 24) & 0x0F;                          \
+        locationOut =  statusIn        & 0x00FFFFFFL; }
+    
+/*----------------------------- Other defines -----------------------------*/
+#define FLASH_VERSION_OFFSET        0x00004000L
+#define FLASH_INFO_START_LOC        0x00004000L
+#define FLASH_CHECKSUM_LOC          0x00004040L
+#define FLASH_NOSDK_CRC_START_LOC   0x00004100L
+#define FLASH_SDK_CRC_START_LOC     0x00020000L
+#define FLASH_BOOT_BLOCK_OFFSET     0x000F0000L
+#define FLASH_BOOT_BLOCK_SIZE       (64*1024L)
+#define FLASH_SDK_SIGNATURE         "SDK"   /*prabhu 19th Jan 1999. For Sdk support */
+
+
+# endif     /* #ifndef AMI_FLASH_H */
diff -urNp linux-5000/drivers/addon/megarac/ftp.h linux-5010/drivers/addon/megarac/ftp.h
--- linux-5000/drivers/addon/megarac/ftp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/ftp.h	
@@ -0,0 +1,213 @@
+/***********************************************************************
+   Note :  This file has been edited with a tab spacing of 4 spaces
+ ***********************************************************************
+
+		Project Code    :       AMI-MegaRac
+
+		File Name       :       FTP.H
+
+		Author          :       Parts and Prabhu
+
+		Date            :       Sep 24, 1998
+
+		Purpose         :       Defines and data structures for FTP
+
+				/--------------------------\
+				|   American Megatrends    |
+				|  Copyright (c) 1998,1999 |
+				\--------------------------/
+
+************************************************************************/
+#ifndef AMI_FTP_H
+#define AMI_FTP_H
+
+
+///////////////////////////////////////////////////////////////////////
+//	#defines...
+#define MAXDATASIZE	4000
+
+///////////////////////////////////////////////////////////////////////
+//	File transfer Command Values	
+#define	FTP_CREATE_FILE		0x0101
+#define	FTP_FILE_DATA		0x0102
+#define	FTP_FILE_DATA_ACK	0x0103
+#define	FTP_CLOSE_FILE		0x0104
+#define FTP_ABORT_FILE		0x0105
+
+///////////////////////////////////////////////////////////////////////
+//	File transfer Error Codes
+#define	FTP_ERR_SUCCESS				0x0000
+#define	FTP_ERR_FILE_NAME_REQD		0x0001
+#define	FTP_ERR_FILE_CREATE_FAILED	0x0002
+#define	FTP_ERR_INVALID_SEQUENCE	0x0003
+#define FTP_ERR_USER_ABORT			0x0004
+#define FTP_ERR_DISK_ERROR			0x0005
+#define	FTP_ERR_FILE_CLOSE_FAILED	0x0006
+#define FTP_ERR_FTP_ALREADY_ACTIVE	0x0007
+#define FTP_ERR_READFILE			0x0008
+#define FTP_FILE1_OVER				0x0009
+
+///////////////////////////////////////////////////////////////////////
+//	File transfer messages
+#define FTP_SEND_CREATE_COMMAND		0x0001
+#define FTP_SEND_PREV_COMMAND		0x0002
+#define FTP_ABORT_ACK				0x0003
+#define FTP_CREATEFILE_SUCCEEDED	0x0004
+#define FTP_INVALID_SEQUENCE		0x0005
+#define FTP_NEXT_DATA_PKT			0x0006
+#define FTP_ABORT_SESSION			0x0007
+#define FTP_CLOSE_SESSION			0x0008
+
+///////////////////////////////////////////////////////////////////////
+//  Remote Flash Commands
+#define REMOTE_FLASH_SESSION			0x0200
+#define REMOTE_FLASH_FTP				0x0201
+#define REMOTE_FLASH_START				0x0202
+#define REMOTE_FLASH_OVER				0x0203
+#define REMOTE_FLASH_ABORTED			0x0204
+#define REMOTE_FLASH_IN_PROGRESS		0x0205
+#define REMOTE_FLASH_STATUS				0x0206
+#define REMOTE_FLASH_BAD_IMAGE			0x0207
+#define REMOTE_FLASH_OLD_IMAGE			0x0208
+#define REMOTE_FLASH_OVERWRITE_YES		0x0209
+#define REMOTE_FLASH_CANCEL				0x020a
+#define REMOTE_FLASH_DISCONNECT_NOW		0x020b			// Not used now .... may be used later
+
+///////////////////////////////////////////////////////////////////////
+//  Remote Flash messages			
+#define REMOTE_FLASH_IS_HOST_READY		0x0001			// Not used now 
+
+///////////////////////////////////////////////////////////////////////
+//  Remote Flash Error Codes
+#define REMOTE_FLASH_ERR_SUCCESS		0x0000
+#define	REMOTE_FLASH_FILE_NAME_REQD		0x0001
+#define	REMOTE_FLASH_FILE_CREATE_FAILED	0x0002
+#define	REMOTE_FLASH_INVALID_SEQUENCE	0x0003
+#define REMOTE_FLASH_USER_ABORT			0x0004
+#define REMOTE_FLASH_DISK_ERROR			0x0005
+#define	REMOTE_FLASH_FILE_CLOSE_FAILED	0x0006
+#define REMOTE_FLASH_FTP_ALREADY_ACTIVE	0x0007
+
+///////////////////////////////////////////////////////////////////////
+//  SDK Flash Messages
+#define REMOTE_SDK_SESSION				0x0300
+#define REMOTE_SDK_FTP					0x0301
+#define REMOTE_SDK_START				0x0302
+#define REMOTE_SDK_OVER					0x0303
+#define REMOTE_SDK_ABORTED				0x0304
+#define REMOTE_SDK_IN_PROGRESS			0x0305
+#define REMOTE_SDK_STATUS				0x0306
+#define REMOTE_SDK_BAD_IMAGE			0x0307
+#define REMOTE_SDK_OLD_IMAGE			0x0308
+#define REMOTE_SDK_OVERWRITE_YES		0x0309
+#define REMOTE_SDK_CANCEL				0x030a
+
+///////////////////////////////////////////////////////////////////////
+//	REMOTE FLASH FIRMWARE AND SDK FILE ALSO
+#define REMOTE_FLASH_SDK_FTP			0x0400
+
+///////////////////////////////////////////////////////////////////////
+//	typedefs...
+typedef	struct
+{
+	u16	Command;
+	u16	Status;
+	u16	Length;
+	u8	Reserved[10];	// For future use
+} PTHeader;		// Passthru header
+
+typedef struct
+{
+	PTHeader	PTH;
+	u8		FName [80];
+	u32		FileSize;
+} CreateFilePacket;
+
+typedef struct
+{
+	PTHeader	PTH;
+	u32		FileOffset;
+	u16		Length;
+	u8		Data [MAXDATASIZE];
+} FileDataPacket;
+
+typedef struct
+{
+	PTHeader	PTH;
+	u32		FileOffset;
+} FileDataAckPacket;
+
+
+typedef struct
+{
+	PTHeader	PTH;
+} CloseFilePacket;
+
+typedef struct
+{
+	PTHeader	PTH;
+	u32		FlashStatus;				// Extended status. number of bytes written. returned by the DLL
+	u32		CurrentOp;					// Current Operation like WRITE , READ , ERASE
+} RemoteFlashStatusPacket;
+
+typedef struct
+{
+	PTHeader	PTH;
+} AbortFilePacket;
+
+typedef struct
+{
+	RCS_COMMAND_PACKET		RCSCmdPkt;
+	CreateFilePacket	CreateFilePkt;
+} RCSReadCreateFilePacket;
+
+typedef struct
+{
+	RCS_COMMAND_PACKET		RCSCmdPkt;
+	CloseFilePacket		CloseFilePkt;
+} RCSReadCloseFilePacket;
+
+typedef struct
+{
+	RCS_COMMAND_PACKET	RCSCmdPkt;
+	FileDataPacket	FileDataPkt;
+} RCSReadFileDataPacket;
+
+typedef struct
+{
+	RCS_COMMAND_PACKET		RCSCmdPkt;
+	FileDataAckPacket	FileDataAckPkt;
+} RCSFileDataAckPacket;
+
+typedef struct
+{
+	RCS_COMMAND_PACKET	RCSCmdPkt;
+	CloseFilePacket	CloseFilePkt;
+} RCSCloseFilePacket;
+
+typedef struct
+{
+	RCS_COMMAND_PACKET	RCSCmdPkt;
+	AbortFilePacket	AbortFilePkt;
+} RCSAbortFilePacket;
+
+typedef struct
+{
+	RCS_COMMAND_PACKET	RCSCmdPkt;
+	PTHeader		PTH;
+} RCSStatusToRemotePacket;
+
+typedef struct
+{
+	RCS_COMMAND_PACKET	RCSCmdPkt;
+	PTHeader		PTH;
+} RCSReadRemoteFlashPacket;
+
+typedef struct
+{
+	RCS_COMMAND_PACKET	RCSCmdPkt;
+	RemoteFlashStatusPacket		RemoteFlashStatusPkt;
+} RCSRemoteFlashStatusPacket;
+
+
+#endif
diff -urNp linux-5000/drivers/addon/megarac/i2crsa.h linux-5010/drivers/addon/megarac/i2crsa.h
--- linux-5000/drivers/addon/megarac/i2crsa.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/i2crsa.h	
@@ -0,0 +1,47 @@
+/*
+ ****************************************************************************
+ *
+ *          File Name   :       I2CRSA.H
+ *
+ *          Author      :       Chambers, N.T.
+ *
+ *          Date        :       5 May 1999
+ *
+ *          Purpose     :       I2CRSA related defines
+ *
+ *          Copyright   :       American Megatrends Inc., (C) 1997-1999
+ *                              All rights reserved.
+ *
+ ****************************************************************************
+*/
+
+#ifndef __I2CRSA_H__
+#define __I2CRSA_H__
+
+//Mem mapped addresses
+#define I2CDATALOC   (char *)0xFDA00000
+#define I2CCMDLOC    (char *)0xFDA00001
+
+#define I2C_REPEATED_START_ACCESS  0x602   /* I2C Repeated Start Access Ioctl */
+
+
+//Take care that the RAWPBuf[I2C_BUFFER_LENGTH] in Sdk.c is not exceeded
+#define I2C_MAX_DATA_BYTES    10
+#define I2C_MAX_TRANSACTIONS  10
+
+
+typedef struct I2C_REPEATED_START_TYPE_tag
+{
+   unsigned char TargetAddr;
+   unsigned char NumberOfBytes;
+   unsigned char Data[I2C_MAX_DATA_BYTES];
+}I2C_REPEATED_START_TYPE;
+
+typedef struct I2C_REPEATED_START_WITH_STATUS_tag
+{
+   unsigned char NumberOfTransactions;
+   unsigned char Status;
+   I2C_REPEATED_START_TYPE Transaction[I2C_MAX_TRANSACTIONS];
+}I2C_REPEATED_START_WITH_STATUS_TYPE;
+
+#endif
diff -urNp linux-5000/drivers/addon/megarac/Makefile linux-5010/drivers/addon/megarac/Makefile
--- linux-5000/drivers/addon/megarac/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/Makefile	
@@ -0,0 +1,18 @@
+#   -*-Makefile-*- template for the magarac kernel module and driver.
+#
+#   Copyright 1996 Olaf Titz <olaf@bigred.inka.de>
+#
+#   This program is free software; you can redistribute it and/or
+#   modify it under the terms of the GNU General Public License
+#   as published by the Free Software Foundation; either version
+#   2 of the License, or (at your option) any later version.
+
+O_TARGET := megar.o
+
+obj-y := 
+obj-m := 
+
+obj-$(CONFIG_CRYPTO_AEP) += megarac.o
+
+include $(TOPDIR)/Rules.make
+
diff -urNp linux-5000/drivers/addon/megarac/megarac.c linux-5010/drivers/addon/megarac/megarac.c
--- linux-5000/drivers/addon/megarac/megarac.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/megarac.c	
@@ -0,0 +1,1978 @@
+/*****************************************************************************
+ *
+ *  MegaRacDrvrLx.c : MegaRac device driver for Linux
+ *
+ *  VisualStudio printing format: courier, 12, landscape
+ *
+ ****************************************************************************/
+
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <linux/reboot.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/types.h>
+#include <linux/tqueue.h>
+#include <linux/unistd.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/interrupt.h>
+
+#include "MegaRacDrvr.h"
+#include "MegaRacDrvrLx.h"
+#include "MegaRacDLL.h"
+
+/* This is defined in 2.2.x series linux kernels, but not in 2.4.x */
+/* andrewm@ami.com 6/8/2001 */
+#ifndef copy_from_user_ret
+#define copy_from_user_ret(to,from,n,retval) ({ if (copy_from_user(to,from,n)) return retval; })
+#endif
+
+/* Added some macros for proper compilation on different versions of linux */
+/* andrewm@ami.com 6/18/2001 */
+#define PCI_BASE resource[0].start
+#warning wrong
+
+MODULE_AUTHOR("American Megatrends Inc");
+MODULE_LICENSE("GPL");
+#if   (OEM == MEGARAC_OEM_AMI)
+#define MR_REGION_NAME "MegaRAC"
+MODULE_DESCRIPTION("AMI MegaRAC driver");
+#elif (OEM == MEGARAC_OEM_DELL)
+#define MR_REGION_NAME "DRAC"
+MODULE_DESCRIPTION("DELL Remote Assistant Card driver");
+#else
+#define MR_REGION_NAME "RAC"
+MODULE_DESCRIPTION("Remote Assistant Card driver");
+#endif
+
+typedef enum {
+	MR_IO_IDLE,
+	MR_IO_WRITE_OUT,
+	MR_IO_WRITE_COMPLETE
+} MR_IO;
+
+typedef struct _RAC_OS_INFO {
+	struct _RAC_INFO *pRacInfo;
+	struct pci_dev pciDev;
+	struct timer_list timerUOW;
+	struct tq_struct isrBHqueue;
+	unsigned char *pContiguousBuffer;
+	unsigned int contiguousBufferLength;
+
+	/* Different handling of wait queues in 2.4.x series kernels */
+	/* andrewm@ami.com 6/18/2001 */
+	wait_queue_head_t writeQ, readQ, ioctlQ;
+	MEGARAC_IO_BUFS ioCB;
+	volatile MR_IO ioState;
+	BOOL bIRQ, bChrDev, bRegion;
+	RAC_EVENT_NOTIFICATION events;
+} RAC_OS_INFO;
+
+typedef struct _MEGARAC_DEVICE_INFO {
+	RAC_INFO racInfo;
+	RAC_OS_INFO osInfo;
+} MEGARAC_DEVICE_INFO;
+
+static MEGARAC_DEVICE_INFO devInfo;
+static const char regionName[] = MR_REGION_NAME;
+static const unsigned long regionExtent = 0x0080;
+static int racDebugFlag = 0;	/* modify at load time with insmod command */
+static int racSupport = 0;	/* disable cursor support for Dell */
+
+#define RAC_MAJOR 170		/* officially designated as Linux device major 170 per hpa@zytor.com */
+#define RAC_MINOR 0		/* ...see /usr/doc/kernel-doc-.../devices.txt */
+
+/*----------------------------------------------------------------------------
+ *  
+ *--------------------------------------------------------------------------*/
+#if _DEBUG
+#define DEBUG_PRINT		/* turn debug printing on */
+#define DEBUG_PRINT_FUNCTION megaOutputFunc
+#endif
+
+#include "MegaRacDebug.h"
+
+DebugFlagDeclare(mega, static);
+DebugOutputFuncLX(mega, static);
+
+/*----------------------------------------------------------------------------
+ *  macros required to support MegaRacDrvr.c
+ *--------------------------------------------------------------------------*/
+
+/* use PCI API here I think */
+#define MALLOC_CONTIGUOUS(raci,ptr,cast,cnt) ptr=(cast)kmalloc(cnt,GFP_ATOMIC)
+#define   FREE_CONTIGUOUS(raci,ptr)                    kfree(ptr)
+
+#define VIRTUAL_TO_PHYSICAL(raci,physAddr,virtAddr) physAddr = (void*)virt_to_phys(virtAddr);
+
+/* Modified macro works with new and old versions of gcc */
+/* andrewm@ami.com 6/18/2001 */
+#define  READ_RAC_UCHAR( raci,addr)         inb (     (unsigned long)raci addr )
+#define  READ_RAC_ULONG( raci,addr)         inl (     (unsigned long)raci addr )
+#define WRITE_RAC_UCHAR(raci,addr,val)      outb( val,(unsigned long)raci addr )
+#define WRITE_RAC_ULONG(raci,addr,val)      outl( val,(unsigned long)raci addr )
+
+/*****************************************************************************
+ *    
+ *   The linux kernel makes a feeble attempt to limit shared access
+ *   to i/o ports by the check_region() function.
+ *   If check_region() is used by this driver, a error return will
+ *   occur because the 'vga+' driver has already reserved the ports 
+ *   we want to access.
+ *   Currently the kernel does not actually modify the 
+ *   "x86 TSS I/O Permissions Bit Map", so we can skip using
+ *   check_region() and request_region(), and just blindly 
+ *   access the ports.  However, if in the future the kernel
+ *   does start checking the TSS then the following code is
+ *   a starting point for a work around.
+ *      typedef int (*sysfun_p)();
+ *      extern long sys_call_table[];
+ *      int error;
+ *      void *kfunc;
+ *      kfunc=(void*)sys_call_table[__NR_ioperm]; //sys_ioperm 101
+ *      error=((sysfun_p)kfunc)(0x3d4,2,1);
+ *
+ ****************************************************************************/
+static unsigned short
+getHardwareCursor(void)
+{
+	unsigned int save3D4, highByte, lowByte;
+	unsigned long flags = 0;	/* =0 makes compiler happy */
+
+	save_flags(flags);
+	cli();
+
+	save3D4 = inb(0x3d4);
+	outb(0x0e, 0x3d4);
+	highByte = inb(0x3d5);
+	highByte &= 0x00ff;
+	outb(0x0f, 0x3d4);
+	lowByte = inb(0x3d5);
+	lowByte &= 0x00ff;
+	outb(save3D4, 0x3d4);
+
+	restore_flags(flags);
+
+	return ((highByte << 8) | lowByte);
+}				/* end of getHardwareCursor() */
+
+/*****************************************************************************
+ *
+ ****************************************************************************/
+static void
+issueEvent(RAC_INFO * pRAC, RAC_EVENT rawEvent, RAC_EVENT firmEvent)
+{
+	RAC_OS_INFO *pOSI = pRAC->pOsInfo;
+
+	DebugFlagPrint(mega, MEGA_EVENT,
+		       ("issueEvent    : rawEvent=%#x, firmEvent=%#x, count=%d\n",
+			rawEvent, firmEvent, pOSI->events.eventHandle[racEventFirmwareRequest]));
+
+	if (rawEvent == racEventFirmwareRequest) {
+		pOSI->events.eventHandle[firmEvent] = 1;	/* this event has occurred */
+		pOSI->events.eventHandle[racEventFirmwareRequest]++;	/* this is our 'dirty' flag */
+	}
+
+	/* Same command, different arguments on different kernels */
+	/* andrewm@ami.com 6/18/2001 */
+	wake_up_interruptible(&pOSI->ioctlQ);
+
+}				/* end of issueEvent() */
+
+/*****************************************************************************
+ *
+ ****************************************************************************/
+static int
+racOpenDev(struct inode *ip, struct file *fp)
+{
+
+	DebugFlagPrint(mega, MEGA_ENTRY, ("racOpenDev    : ip=%p, fp=%p <<<<<<<<<<<\n", ip, fp));
+	fp->private_data = &devInfo;
+	MOD_INC_USE_COUNT;
+
+	return 0;
+}				/* end of racOpenDev() */
+
+/*****************************************************************************
+ *
+ ****************************************************************************/
+static int
+racCloseDev(struct inode *ip, struct file *fp)
+{
+
+	DebugFlagPrint(mega, MEGA_ENTRY, ("racCloseDev   : ip=%p, fp=%p >>>>>>>>>>>\n", ip, fp));
+	fp->private_data = NULL;
+	MOD_DEC_USE_COUNT;
+
+	return 0;
+}				/* end of racCloseDev() */
+
+/*****************************************************************************
+ *
+ ****************************************************************************/
+static int
+racPciInit(MEGARAC_DEVICE_INFO * pMDI)
+{
+	static void racISR(int irq, void *dev_id, struct pt_regs *regs);
+	static int racRead(struct file *, char *, size_t, loff_t *);
+	static int racWrite(struct file *, const char *, size_t, loff_t *);
+	static int racIoctl(struct inode *, struct file *, unsigned int, unsigned long);
+
+	//andrewm@ami.com
+	static struct file_operations racFops = {
+		/* 2.4.x series kernels include an owner field in this struct */
+		/* It should always be the THIS_MODULE macro for our uses.    */
+		/* andrewm@ami.com 6/18/2001                                  */
+		owner:THIS_MODULE,
+		llseek:NULL,
+		read:racRead,
+		write:racWrite,
+		readdir:NULL,
+		poll:NULL,
+		ioctl:racIoctl,
+		mmap:NULL,
+		open:racOpenDev,
+		flush:NULL,
+		release:racCloseDev
+	};
+
+	RAC_INFO *pRAC = &pMDI->racInfo;
+	RAC_OS_INFO *pOSI = &pMDI->osInfo;
+	struct pci_dev *pPCI = &pOSI->pciDev;
+	int result;
+
+	{
+		struct pci_dev *tempDev;
+		tempDev = pci_find_device(AMI_VENDOR_ID, AMI_MEGA_RAC_ID, NULL);
+		if (tempDev == NULL) {
+			printk(KERN_ERR "%s not found on PCI bus\n", regionName);
+			return (-ENODEV);
+		}
+
+		*pPCI = *tempDev;
+
+		DebugFlagPrint(mega, MEGA_ENTRY,
+			       ("racPciInit    : found MegaRac: base=%#lx, irq=%d ==========\n",
+				pci_resource_start(pPCI, 0), pPCI->irq));
+	}
+
+	/* Get IO region.... */
+
+	/* Changed PCI base references to a macro based on kernel version */
+	/* andrewm@ami.com 6/18/2001 */
+	result = check_region(pci_resource_start(pPCI, 0), regionExtent);
+	if (result) {
+		printk(KERN_ERR "%s can't get reserved region %#lx\n", regionName, pci_resource_start(pPCI, 0));
+		return result;
+	}
+
+	/* Changed PCI base references to a macro based on kernel version */
+	/* andrewm@ami.com 6/18/2001 */
+	request_region(pci_resource_start(pPCI, 0), regionExtent, regionName);
+	pOSI->bRegion = TRUE;
+
+	/* disable any interrupt from the MegaRac until ready */
+
+	/* Changed PCI base references to a macro based on kernel version */
+	/* andrewm@ami.com 6/18/2001 */
+	racSetAddrs(pRAC, (void *) pci_resource_start(pPCI, 0));
+	#warning wrong type
+
+	WRITE_RAC_UCHAR(pRAC->, portAddrHIMR, HIMR_DISABLE_ALL);
+	WRITE_RAC_UCHAR(pRAC->, portAddrHCR, HCR_INTR_RESET);
+
+	/* register device with kernel */
+
+	result = register_chrdev(RAC_MAJOR, regionName, &racFops);
+	if (result < 0) {
+		printk(KERN_ERR "%s can't get reserved major device %d\n", regionName, RAC_MAJOR);
+		return result;
+	}
+	pOSI->bChrDev = TRUE;
+
+	/* attach the IRQ to the driver */
+
+	result = request_irq(pPCI->irq, racISR, SA_SHIRQ, regionName, pMDI);
+	if (result) {
+		printk(KERN_ERR "%s can't register IRQ\n", regionName);
+		return result;
+	}
+	pOSI->bIRQ = TRUE;
+
+	/* all done */
+
+	return 0;
+}				/* end of racPciInit() */
+
+/*****************************************************************************
+ *  module entry point for driver
+ ****************************************************************************/
+int
+init_module(void)
+{
+	extern void cleanup_module(void);
+	static void racTimeout(unsigned long);
+	static void racIsrBottomHalf(void *);
+	MEGARAC_DEVICE_INFO *pMDI = &devInfo;
+	RAC_INFO *pRAC = &pMDI->racInfo;
+	RAC_OS_INFO *pOSI = &pMDI->osInfo;
+	int retval;
+
+	DebugFlagSet(mega, racDebugFlag);	/* turn on debugging */
+
+	if (!pci_present()) {
+		racDebugFlag++;	/* prevent compiler warning */
+		printk(KERN_ERR "PCI BIOS not present\n");
+		return -ENODEV;
+	}
+
+	/* Initialize wait queue heads */
+	/* Kernels before 2.4.x don't use wait queue heads in the same way */
+	/* andrewm@ami.com 6/18/2001 */
+
+	init_waitqueue_head(&pOSI->readQ);
+	init_waitqueue_head(&pOSI->writeQ);
+	init_waitqueue_head(&pOSI->ioctlQ);
+
+	/* allocate resources, ISR's, etc. */
+	pMDI->osInfo.pRacInfo = &pMDI->racInfo;
+	pMDI->racInfo.pOsInfo = &pMDI->osInfo;
+
+	pOSI->isrBHqueue.routine = racIsrBottomHalf;
+	pOSI->isrBHqueue.data = pMDI;
+
+	pOSI->contiguousBufferLength = max(MAX_DMI_BUFFER, MOUSE_DATA_BUFFER_SIZE);
+	pOSI->contiguousBufferLength += sizeof(CCB_Header);
+	pOSI->pContiguousBuffer = kmalloc(pOSI->contiguousBufferLength, GFP_KERNEL);
+	#warning PCI DMA ?
+	if (pOSI->pContiguousBuffer == NULL)
+		return -ENOMEM;
+
+	retval = racPciInit(pMDI);
+	if (retval) {
+		DebugFlagPrint(mega, MEGA_ENTRY, ("init_module    :  Error initializing %#x\n", retval));
+		cleanup_module();
+		return retval;
+	}
+
+	/* register special support functions for use by the common driver code */
+
+	if (racSupport & MEGARAC_SUPPORT_CURSOR)
+		racGetHardwareCursor = getHardwareCursor;	/* work around for ASIC bug */
+
+	racOsEventProc = issueEvent;
+
+	/* Tell card it's ready */
+
+	racStartupFinal(pRAC);	/* interrupts are now active */
+
+	/* setup timer for racTimeout function */
+
+	init_timer(&pOSI->timerUOW);
+	pOSI->timerUOW.function = racTimeout;
+	pOSI->timerUOW.data = (unsigned long) pMDI;
+	pOSI->timerUOW.expires = jiffies + HZ;	/* one second */
+	add_timer(&pOSI->timerUOW);	/* start timer */
+
+	return 0;
+}				/* end of init_module() */
+
+/*****************************************************************************
+ *
+ ****************************************************************************/
+void
+cleanup_module(void)
+{
+	MEGARAC_DEVICE_INFO *pMDI = &devInfo;
+	RAC_INFO *pRAC = &pMDI->racInfo;
+	RAC_OS_INFO *pOSI = &pMDI->osInfo;
+	int result;
+
+	if (pOSI->pContiguousBuffer) {
+		kfree(pOSI->pContiguousBuffer);
+		pOSI->pContiguousBuffer = NULL;
+	}
+
+	if (pOSI->timerUOW.function) {
+		pOSI->timerUOW.data = 0;	/* avoid race condition with racTimeout() */
+		del_timer_sync(&pOSI->timerUOW);
+		pOSI->timerUOW.function = NULL;
+	}
+
+	if (pOSI->bIRQ) {
+		free_irq(pOSI->pciDev.irq, pMDI);
+		pOSI->bIRQ = FALSE;
+	}
+
+	if (pOSI->bChrDev) {
+		result = unregister_chrdev(RAC_MAJOR, regionName);
+		pOSI->bChrDev = FALSE;
+		if (result)
+			DebugFlagPrint(mega, MEGA_ENTRY, ("cleanup_module: unregister_chrdev=%#x\n", result));
+	}
+
+	if (pOSI->bRegion) {
+		/* Changed PCI base references to a macro based on kernel version */
+		/* andrewm@ami.com 6/18/2001 */
+		release_region(pci_resource_start(&pOSI->pciDev, 0), regionExtent);
+		pOSI->bRegion = FALSE;
+	}
+
+	racShutdownBegin(pRAC);
+
+}				/* end of cleanup_module() */
+
+/*****************************************************************************
+ *
+ ****************************************************************************/
+static void
+racTimeout(unsigned long context)
+{
+	MEGARAC_DEVICE_INFO *pMDI = (MEGARAC_DEVICE_INFO *) context;
+	RAC_INFO *pRAC = &pMDI->racInfo;
+	RAC_OS_INFO *pOSI = &pMDI->osInfo;
+
+	if (pOSI->timerUOW.data == 0)	/* avoid race condition with cleanup_module() */
+		return;
+	racTimerTick(pRAC);
+
+	pOSI->timerUOW.expires = jiffies + HZ;	/* one second */
+	add_timer(&pOSI->timerUOW);	/* restart the timer */
+	#warning mod_timer maybe ?
+
+}				/* end of racTimeout() */
+
+/*********************************************************
+ *
+ *********************************************************/
+static int
+racWrite(struct file *fp, const char *pData, size_t dataLen, loff_t * ignored)
+{
+	RAC_INFO *pRAC = fp->private_data;
+	RAC_OS_INFO *pOSI = pRAC->pOsInfo;
+	CCB_Header *pCCB = (CCB_Header *) pOSI->pContiguousBuffer;
+	MEGARAC_IO_BUFS *pIOB = &pOSI->ioCB;
+	RAC_DRVR_ERR drvrStatus;
+	int osStatus;
+
+	/* Declare our own wait queue */
+	/* andrewm@ami.com 6/18/2001  */
+	DECLARE_WAITQUEUE(wait, current);
+
+	DebugFlagPrint(mega, MEGA_DEVICE,
+		       ("racWrite      : fp=%p, pData=%p, dataLen=%#lx, loff=%p, ioState=%d\n",
+			fp, pData, dataLen, ignored, pOSI->ioState));
+
+	/* validate the request */
+
+	if (pData == NULL || dataLen != sizeof(*pIOB)) {
+		DebugFlagPrint(mega, MEGA_DEVICE, ("racWrite      : unknown data %p, %#x\n", pData, dataLen));
+		return -ENOTTY;
+	}
+
+	/* Add the current context to the wait queue and set ourself as interruptible */
+	/* andrewm@ami.com 6/18/2001 */
+
+	add_wait_queue(&pOSI->writeQ, &wait);
+	set_current_state(TASK_INTERRUPTIBLE);
+
+	while (pOSI->ioState != MR_IO_IDLE) {
+		DebugFlagPrint(mega, MEGA_DEVICE, ("racWrite      : waiting\n"));
+
+		if (signal_pending(current)) {
+			/* Set ourself back to running mode and take ourself off the wait queue */
+			/* andrewm@ami.com 6/18/2001 */
+			set_current_state(TASK_RUNNING);
+			remove_wait_queue(&pOSI->writeQ, &wait);
+			return -ERESTARTSYS;
+		}
+
+		/* Go to sleep waiting for a wakeup from read */
+		/* andrewm@ami.com 6/18/2001 */
+		schedule();
+		set_current_state(TASK_INTERRUPTIBLE);
+
+	}
+
+	/* We don't need to wait any more, so set ourselves back to running, */
+	/* and remove ourselves from the wait queue */
+	/* andrewm@ami.com 6/18/2001 */
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&pOSI->writeQ, &wait);
+
+	/* construct control structure in kernelspace */
+
+	copy_from_user_ret(pIOB, (void *) pData, sizeof(*pIOB), -EFAULT);
+
+	DebugFlagPrint(mega, MEGA_DEVICE,
+		       ("racWrite      : ioCC=%#lx, reqBuf=%p, reqLen=%#lx, respBuf=%p, respLen=%#lx\n",
+			pIOB->ioControlCode, pIOB->requestBuf, pIOB->requestBufLen,
+			pIOB->responseBuf, pIOB->responseBufLen));
+
+	/* construct ccb in kernelspace */
+
+	if (pOSI->pContiguousBuffer == NULL ||
+	    pOSI->contiguousBufferLength < max(pIOB->requestBufLen, pIOB->responseBufLen))
+		return -EFAULT;
+
+	copy_from_user_ret(pCCB, pIOB->requestBuf, pIOB->requestBufLen, -EFAULT);
+
+	/* do some work */
+
+	racPreProcessCCB(pRAC, pCCB, pCCB->Length, pIOB->ioControlCode, &drvrStatus);
+	switch (drvrStatus) {
+	case racDrvrErrNone:
+		osStatus = 0;
+		break;
+	case racDrvrErrPending:
+		osStatus = -EWOULDBLOCK;
+		break;
+	case racDrvrErrInvalidParameter:
+		osStatus = -EMSGSIZE;
+		break;
+	case racDrvrErrNotImplemented:
+		osStatus = -ENOSYS;
+		break;
+	default:
+		osStatus = -ENOTTY;
+		break;
+	}
+
+	if (pIOB->ioControlCode == IOCTL_GET_GRAPHICS) {
+		osStatus = -ENOSYS;	/* not needed, and not supported */
+	}
+
+	else if (drvrStatus == racDrvrErrNone) {	/* completely handled within driver  */
+		pOSI->ioState = MR_IO_WRITE_COMPLETE;	/* ...don't need to send to card */
+	}
+
+	else if (drvrStatus == racDrvrErrPending) {	/* need to send request to the card */
+		pOSI->ioState = MR_IO_WRITE_OUT;	/* indicate write is outstanding */
+
+		if (!racSendCcb(pRAC, pCCB, pIOB->ioControlCode)) {
+			pOSI->ioState = MR_IO_IDLE;	/* failed: leave osStatus as set in switch */
+		} else {	/* ccb has been sent to megarac */
+
+			osStatus = 0;	/* allow API write() to complete normally */
+		}
+	}
+
+	DebugFlagPrint(mega, MEGA_DEVICE,
+		       ("racWrite      : exit drvrStatus=%#x, osStatus=%d, len=%#x\n",
+			drvrStatus, osStatus, sizeof(CCB_Header) + pCCB->Length));
+
+	return osStatus ? osStatus : dataLen;
+
+}				/* end of racWrite() */
+
+/*****************************************************************************
+ *
+ ****************************************************************************/
+static void
+racISR(int irq, void *dev_id, struct pt_regs *regs)
+{
+	MEGARAC_DEVICE_INFO *pMDI = (MEGARAC_DEVICE_INFO *) dev_id;
+	RAC_INFO *pRAC = &pMDI->racInfo;
+	unsigned char hifr;
+
+	hifr = READ_RAC_UCHAR(pRAC->, portAddrHIFR);
+	DebugFlagPrint(mega, MEGA_ISR, ("racISR        : hifr=%#x, ioState=%d\n", hifr, pMDI->osInfo.ioState));
+
+	if ((hifr & HIFR_ANY_INTR) == 0)
+		return;		/* not our interrupt */
+
+	/* disable interrupt to host (i.e. this driver),
+	   otherwise we get a continuing deluge of interrupts */
+
+	WRITE_RAC_UCHAR(pRAC->, portAddrHIMR, HIMR_DEFAULTS_NO_HOST);
+
+	queue_task(&pMDI->osInfo.isrBHqueue, &tq_immediate);	/* schedule bottom-half */
+	mark_bh(IMMEDIATE_BH);
+
+}				/* end of racISR() */
+
+/*****************************************************************************
+ *
+ ****************************************************************************/
+static void
+racIsrBottomHalf(void *data)
+{
+	MEGARAC_DEVICE_INFO *pMDI = (MEGARAC_DEVICE_INFO *) data;
+	RAC_OS_INFO *pOSI = &pMDI->osInfo;
+
+	/* if interrupts just got turned back on */
+	if (racIsrDpc(&pMDI->racInfo)) {
+		/* indicate a i/o has completed */
+		pOSI->ioState = MR_IO_WRITE_COMPLETE;
+
+		/* start any pending read() */
+		/* The argument to this is of different types in different kernels */
+		/* andrewm@ami.com 6/19/2001 */
+		wake_up_interruptible(&pOSI->readQ);
+	}
+
+}				/* end of racIsrBottomHalf() */
+
+/*********************************************************
+ *
+ *********************************************************/
+static int
+racRead(struct file *fp, char *pData, size_t dataLen, loff_t * ignored)
+{
+
+/* In 2.4.x series kernels, we also need to set the current thread back to */
+/* the TASK_RUNNING state and remove ourself from the wait queue. */
+/* andrewm@ami.com 6/19/2001 */
+#define RAC_READ_EXIT(retv) {                 \
+    	pOSI->ioState = MR_IO_IDLE;               \
+    	set_current_state(TASK_RUNNING);            \
+		remove_wait_queue( &pOSI->readQ, &wait ); \
+		wake_up( &pOSI->writeQ );   \
+	    return retv;                            }
+
+	RAC_INFO *pRAC = fp->private_data;
+	RAC_OS_INFO *pOSI = pRAC->pOsInfo;
+	CCB_Header *pCCB = (CCB_Header *) pOSI->pContiguousBuffer;
+	unsigned long length;
+
+	DECLARE_WAITQUEUE(wait, current);
+
+	DebugFlagPrint(mega, MEGA_DEVICE,
+		       ("racRead       : fp=%p, pData=%p, dataLen=%#lx, loff=%p, ioState=%d\n",
+			fp, pData, dataLen, ignored, pOSI->ioState));
+
+	/* validate the request */
+
+	if (pData == NULL || dataLen == 0) {
+		DebugFlagPrint(mega, MEGA_DEVICE, ("racRead       : unknown data %p, %#x\n", pData, dataLen));
+		return -ENOTTY;
+	}
+
+	if (pOSI->ioState == MR_IO_IDLE) {
+		DebugFlagPrint(mega, MEGA_DEVICE, ("racRead       : no i/o outstanding\n"));
+		return -ENOTTY;
+	}
+
+	/* Add the current context to the wait queue and set ourself as interruptible */
+	/* andrewm@ami.com 6/19/2001 */
+	add_wait_queue(&pOSI->readQ, &wait);
+	set_current_state(TASK_INTERRUPTIBLE);
+	while (pOSI->ioState != MR_IO_WRITE_COMPLETE) {
+		DebugFlagPrint(mega, MEGA_DEVICE, ("racRead       : waiting\n"));
+
+		if (signal_pending(current)) {
+			/* Set ourself back to running mode and take ourself off the wait queue */
+			/* andrewm@ami.com 6/19/2001 */
+			set_current_state(TASK_RUNNING);
+			remove_wait_queue(&pOSI->readQ, &wait);
+			return -ERESTARTSYS;
+		}
+
+		/* Go to sleep waiting for a wakeup */
+		/* andrewm@ami.com 6/19/2001 */
+		schedule();
+	}
+	remove_wait_queue(&pOSI->readQ, &wait);
+	
+
+	/* copy completed request back to user memory space */
+
+	length = sizeof(CCB_Header) + pCCB->Length;
+
+	set_current_state(TASK_RUNNING);
+
+	if (length > dataLen || copy_to_user(pData, pCCB, length)) {
+		DebugFlagPrint(mega, MEGA_DEVICE, ("racRead       : copy_to_user failed, length=%ld\n", length));
+	    	pOSI->ioState = MR_IO_IDLE;
+		wake_up( &pOSI->writeQ );
+		return -EFAULT;
+	}
+
+	/* if any write()'s are waiting then start next i/o */
+	
+    	pOSI->ioState = MR_IO_IDLE;
+	wake_up( &pOSI->writeQ );
+	return length; /* success */
+}				/* end of racRead() */
+
+/*********************************************************
+ *  
+ *********************************************************/
+static int
+racIoctl(struct inode *ip, struct file *fp, unsigned int ioControlCode, unsigned long datap)
+{
+	RAC_INFO *pRAC = fp->private_data;
+	RAC_OS_INFO *pOSI = pRAC->pOsInfo;
+	MEGARAC_IO_BUFS miob;
+	struct _ccbEvt {
+		CCB_Header ccb;
+		RAC_EVENT_NOTIFICATION events;
+	} ccbEvt;
+
+	/* Declare our own wait queue */
+	/* andrewm@ami.com 6/19/2001 */
+	DECLARE_WAITQUEUE(wait, current);
+
+	DebugFlagPrint(mega, MEGA_DEVICE,
+		       ("racIoctl      : ip=%p, fp=%p, ioCC=%#x, datap=%#lx, count=%d\n",
+			ip, fp, ioControlCode, datap, pOSI->events.eventHandle[racEventFirmwareRequest]));
+
+	if (ioControlCode != _IO(RAC_IOC_MAGIC, IOCTL_EVENT_WAIT) || datap == 0) {
+		DebugFlagPrint(mega, MEGA_DEVICE,
+			       ("racIoctl        unknown ioControlCode=%#x, datap=%p\n", ioControlCode, datap));
+		return -ENOTTY;
+	}
+
+	/* construct control structure in kernelspace */
+
+	copy_from_user_ret(&miob, (void *) datap, sizeof(miob), -EFAULT);
+
+	DebugFlagPrint(mega, MEGA_DEVICE,
+		       ("                ioCC=%#lx, reqBuf=%p, reqLen=%#lx, respBuf=%p, respLen=%#lx\n",
+			miob.ioControlCode, miob.requestBuf, miob.requestBufLen,
+			miob.responseBuf, miob.responseBufLen));
+
+	/* construct ccb in kernelspace */
+
+	if (miob.requestBufLen < sizeof(ccbEvt.ccb) || miob.responseBufLen < sizeof(ccbEvt.ccb))
+		return -ENOTTY;
+
+	copy_from_user_ret(&ccbEvt.ccb, miob.requestBuf, sizeof(ccbEvt.ccb), -EFAULT);
+
+	switch (ccbEvt.ccb.Command) {
+
+//        case MEGARAC_API_CMD_OS_RESTART:
+//            DebugFlagPrint( mega, MEGA_DEVICE, ("racIoctl      : issuing reboot\n") );
+//            {   
+//                typedef int (*sysfun_p)();
+//                extern long   sys_call_table[];
+//                void         *kfunc = (void*)sys_call_table[__NR_reboot];
+//                int           err   = ((sysfun_p)kfunc)( LINUX_REBOOT_MAGIC1, 
+//                                                         LINUX_REBOOT_MAGIC2, 
+//                                                         LINUX_REBOOT_CMD_HALT, NULL );
+//                if ( err ) {
+//                    DebugFlagPrint( mega, MEGA_DEVICE, ("racIoctl      : sys_reboot=%d\n",err) );
+//                    return err;
+//                }
+//                ccbEvt.ccb.Status = MEGARAC_ERR_NONE;
+//                copy_to_user( miob.responseBuf, &ccbEvt.ccb, sizeof(ccbEvt.ccb) );
+//            }
+//            break;
+
+	case MEGARAC_API_CMD_WAIT_EVENTS:
+		if (miob.responseBufLen != sizeof(ccbEvt) || ccbEvt.ccb.Length != sizeof(pOSI->events)) {
+			DebugFlagPrint(mega, MEGA_DEVICE, ("racIoctl      : unknown length=%#x\n", ccbEvt.ccb.Length));
+			return -ENOTTY;
+		}
+
+		/* Add the current context to the wait queue and set ourself as interruptible */
+		/* andrewm@ami.com 6/19/2001 */
+		add_wait_queue(&pOSI->ioctlQ, &wait);
+		set_current_state(TASK_INTERRUPTIBLE);
+		while (pOSI->events.eventHandle[racEventFirmwareRequest] == 0) {
+			DebugFlagPrint(mega, MEGA_DEVICE, ("racIoctl      : waiting\n"));
+			if (signal_pending(current)) {
+				/* Set ourself back to running mode and take ourself off the wait queue */
+				/* andrewm@ami.com 6/19/2001 */
+				set_current_state(TASK_RUNNING);
+				remove_wait_queue(&pOSI->ioctlQ, &wait);
+				return -ERESTARTSYS;
+			}
+
+			/* Go to sleep waiting for a wakeup from read */
+			/* andrewm@ami.com 6/19/2001 */
+			schedule();
+		}
+
+		/* We don't need to wait any more, so set ourselves back to running, */
+		/* and remove ourselves from the wait queue */
+		/* andrewm@ami.com 6/19/2001 */
+		set_current_state(TASK_RUNNING);
+		remove_wait_queue(&pOSI->ioctlQ, &wait);
+
+		ccbEvt.ccb.Status = MEGARAC_ERR_NONE;
+		memcpy(&ccbEvt.events, &pOSI->events, sizeof(ccbEvt.events));
+		memset(&pOSI->events, 0, sizeof(pOSI->events));
+
+		copy_to_user(miob.responseBuf, &ccbEvt, sizeof(ccbEvt));
+
+		DebugFlagPrint(mega, MEGA_DEVICE,
+			       ("racIoctl      : wait event exit: down=%d, cursor=%d, ftp=%d\n",
+				ccbEvt.events.eventHandle[racEventRequestHostOsShutdown],
+				ccbEvt.events.eventHandle[racEventCursorChange],
+				ccbEvt.events.eventHandle[racEventPassThruData]));
+		break;
+
+	default:
+		DebugFlagPrint(mega, MEGA_DEVICE, ("racIoctl      : unknown ccb.command=%#x\n", ccbEvt.ccb.Command));
+		return -ENOTTY;
+	}
+
+	return 0;
+}				/* end of racIoctl() */
+
+/****************************************************
+ * additional source files 
+ ****************************************************/
+
+#include "MegaRacDrvr.h"
+#include "MegaRacDLL.h"
+
+static void (*racOsEventProc) (RAC_INFO * pRAC, RAC_EVENT rawEvent, RAC_EVENT firmEvent);
+static void (*racOsSetEventsProc) (RAC_INFO * pRAC, CCB_Header * pCCB);
+static void (*racOsAttachmentsProc) (RAC_INFO * pRAC, CCB_Header * pCCB);
+static unsigned short (*racGetHardwareCursor) (void);
+
+/*****************************************************************************
+ *    
+ ****************************************************************************/
+#ifdef DEBUG_PRINT
+static void
+racDumpRegs(RAC_INFO * pRAC, char *str)
+{
+	unsigned char himr, hifr, hasr, hfr, hcr;
+
+	himr = READ_RAC_UCHAR(pRAC->, portAddrHIMR);
+	hifr = READ_RAC_UCHAR(pRAC->, portAddrHIFR);
+	hasr = READ_RAC_UCHAR(pRAC->, portAddrHASR);
+	hfr = READ_RAC_UCHAR(pRAC->, portAddrHFR);
+	hcr = READ_RAC_UCHAR(pRAC->, portAddrHCR);
+
+	DebugPrintf(("MegaRac dump  : %s: "
+		     "himr=%#x, hifr=%#x, hasr=%#x, hfr=%#x, hcr=%#x\n", str ? str : " ", himr, hifr, hasr, hfr, hcr));
+}				/* end of racDumpRegs() */
+#endif
+
+/*****************************************************************************
+ *    
+ ****************************************************************************/
+#ifdef DEBUG_PRINT
+static char *
+racIoctlToString(unsigned long ioControlCode)
+{
+	switch (ioControlCode) {
+	case IOCTL_ISSUE_RCS:
+		return "IOCTL_ISSUE_RCS";
+	case IOCTL_GET_GRAPHICS:
+		return "IOCTL_GET_GRAPHICS";
+	case IOCTL_RESET_CARD:
+		return "IOCTL_RESET_CARD";
+	case IOCTL_API_INTERNAL:
+		return "IOCTL_API_INTERNAL";
+	}
+	return "IOCTL_Unknown";
+}				/* end of racIoctlToString() */
+#endif
+
+/*****************************************************************************
+ *    
+ ****************************************************************************/
+#ifdef DEBUG_PRINT
+static char *
+racFriToString(int fri)
+{
+	switch (fri) {
+	case GetDCInfo_FRI:
+		return "GetDCInfo_FRI";
+	case GetDCPacket_x_FRI:
+		return "GetDCPacket_x_FRI";
+	case SendDCComplete_FRI:
+		return "SendDCComplete_FRI";
+	case SendKeyEvent_FRI:
+		return "SendKeyEvent_FRI";
+	case SendMouseEvent_FRI:
+		return "SendMouseEvent_FRI";
+	case SendAlertToHost_FRI:
+		return "SendAlertToHost_FRI";
+	case HOST_OS_SHUTDOWN_REQUEST_FRI:
+		return "HOST_OS_SHUTDOWN_REQUEST_FRI";
+	case ModeChangedToGraphics_FRI:
+		return "ModeChangedToGraphics_FRI";
+	case ServiceDYRM_FRI:
+		return "ServiceDYRM_FRI";
+	case PassThruData_FRI:
+		return "PassThruData_FRI";
+	}
+	return "FRI_Unknown";
+}				/* end of racFriToString() */
+#endif
+
+/*****************************************************************************
+ *    
+ ****************************************************************************/
+static void
+racSetAddrs(RAC_INFO * pRAC, void *baseAddr)
+{
+	unsigned char *address = (unsigned char *) baseAddr;
+	pRAC->portAddrBase = address;
+	pRAC->portAddrHIMR = address + HOST_INTERRUPT_MASK_REG;
+	pRAC->portAddrHIFR = address + HOST_INTERRUPT_FLAG_REG;
+	pRAC->portAddrHCMDR = address + HOST_COMMAND_REG;
+	pRAC->portAddrDATA = (unsigned long *) (address + HOST_DATA_OUT_REG);
+	pRAC->portAddrHASR = address + HOST_ADAPTER_STATUS_REG;
+	pRAC->portAddrHFR = address + HOST_FLAGS_REG;
+	pRAC->portAddrHCR = address + HOST_CONTROL_REG;
+
+	/* sanity check */
+
+	if (pRAC->pOsInfo == NULL) {
+		DebugFlagPrint(mega, MEGA_DEVICE, ("racSetAddrs   : warning: pOsInfo (and maybe pRacInfo) not set\n"));
+	}
+
+	/* make compiler happy by always referencing some functions that are not always used */
+
+	if (baseAddr == NULL || ((unsigned long) baseAddr & 0x01)) {
+#ifdef DEBUG_PRINT
+		racDumpRegs(pRAC, "racSetAddrs: SHOULD NEVER HAPPEN!!!!");
+#endif
+		racClearAddrs(pRAC);
+	}
+}				/* end of racSetAddrs() */
+
+/*****************************************************************************
+ *    
+ ****************************************************************************/
+static void
+racClearAddrs(RAC_INFO * pRAC)
+{
+	pRAC->portAddrBase = NULL;
+	pRAC->portAddrHIMR = NULL;
+	pRAC->portAddrHIFR = NULL;
+	pRAC->portAddrHCMDR = NULL;
+	pRAC->portAddrDATA = NULL;
+	pRAC->portAddrHASR = NULL;
+	pRAC->portAddrHFR = NULL;
+	pRAC->portAddrHCR = NULL;
+}				/* end of racClearAddrs() */
+
+/*****************************************************************************
+ * on entry to this routine 
+ *      pRAC->dmiHeader.Signature[0]==0
+ * if the DMI information is found in the BIOS, then when this routine exits
+ *      pRAC->dmiHeader.Signature[0]!=0
+ * this zero or non-zero result is used elsewhere in the driver code
+ *
+ * note: not all bios's have dmi information,
+ * to confirm, use dos debug command:     s 000f:0000 ffff "_DMI_"
+ ****************************************************************************/
+static void
+racFindDmiInBios(RAC_INFO * pRAC)
+#warning need to fix this to use the normal dmi driver
+{
+#define          BIOS_LENGTH (BIOS_STOP_ADDR - BIOS_START_ADDR)
+	unsigned char *pBiosStart = NULL,	/* runtime validity checked below */
+	*pBiosCur, *pBiosStop;
+	DMI_HEADER *pDmiHdr;
+
+	pBiosStart = phys_to_virt(BIOS_START_ADDR);
+
+	if (pBiosStart == NULL)	/* no known driver interface */
+		return;		/* ...was defined above */
+
+	for (pBiosStop = pBiosStart + BIOS_LENGTH - sizeof(DMI_HEADER),
+	     pBiosCur = pBiosStart; pBiosCur < pBiosStop; pBiosCur += sizeof(DMI_HEADER)) {
+
+		pDmiHdr = (DMI_HEADER *) pBiosCur;	/* default assumption */
+
+		if (pDmiHdr->Signature[0] == '_' &&
+		    pDmiHdr->Signature[1] == 'D' &&
+		    pDmiHdr->Signature[2] == 'M' && pDmiHdr->Signature[3] == 'I' && pDmiHdr->Signature[4] == '_') {
+			memcpy(&pRAC->dmiHeader, pDmiHdr, sizeof(pRAC->dmiHeader));
+			break;	/* found it */
+		}
+	}			/* end 'for pBiosCur' */
+
+}				/* end of racFindDmiInBios() */
+
+/*****************************************************************************
+ *    undocumented features between DLL and Driver:
+ *       1) Allow DLL to retrieve the DMI header without the
+ *          DMI data, because the DLL doesn't know the size of the data.
+ *       2) Allow the Driver to insert the DMI data into the
+ *          DLL's CCB buffer, because only the Driver has the data.
+ *    Besides the obvious ccb.Command value, 
+ *    the magic indicator for these features is ccb.Length 
+ ****************************************************************************/
+static BOOL
+racHandleReportDMI(RAC_INFO * pRAC, CCB_Header * pCCB)
+{
+#define DMI_RCS_HDR_LENGTH (  sizeof(  RCS_FN_GET_DMI_INFO_ARGS) - \
+                                  sizeof(((RCS_FN_GET_DMI_INFO_ARGS*)0)->DMIData)  )
+	static BOOL tryFindOnce = FALSE;
+	RCS_FN_GET_DMI_INFO_ARGS *pCcbDmi = (RCS_FN_GET_DMI_INFO_ARGS *) (pCCB + 1);
+	void *pDmiData;
+
+	DebugFlagPrint(mega, MEGA_ENTRY,
+		       ("rac--ReportDMI: cLen=%#x, HDR=%#x, sLen=%#x\n",
+			pCCB->Length, DMI_RCS_HDR_LENGTH, pRAC->dmiHeader.StructLength));
+
+	/* load DMI info from BIOS 
+	   because MegaRac can't access this address on a Pentium-II */
+
+	if (!tryFindOnce) {
+		tryFindOnce = TRUE;	/* never do again */
+		racFindDmiInBios(pRAC);
+	}
+
+	/* try to service the CCB request */
+
+	if (pRAC->dmiHeader.Signature[0] == 0) {	/* DMI info not available */
+		pCCB->Status = RCSERR_INFORMATION_NOT_AVAILABLE;
+		pCCB->Length = 0;
+		return TRUE;
+	}
+
+	if (pCCB->Length < DMI_RCS_HDR_LENGTH) {	/* ccb request too small */
+		pCCB->Status = RCSERR_BAD_ARGUMENT;
+		pCCB->Length = 0;
+		return TRUE;
+	}
+
+	/* copy DMI header to callers CCB */
+
+	pCcbDmi->NumStructs = pRAC->dmiHeader.NumberOfStructs;
+	pCcbDmi->BCDRevision = pRAC->dmiHeader.BCDRevision;
+	pCcbDmi->Reserved = 0;
+	pCcbDmi->DMIDataLen = pRAC->dmiHeader.StructLength;
+
+	/* check if caller only wanted the dmi header (not the actual data) */
+
+	if (pCCB->Length == DMI_RCS_HDR_LENGTH) {	/* DLL is requesting exactly */
+		pCCB->Status = RCSERR_SUCCESS;	/* ...the DMI header length */
+		return TRUE;	/* pass DMI header back to DLL */
+	}
+
+	/* caller wants the dmi data, will it fit? */
+
+	if (pCCB->Length < DMI_RCS_HDR_LENGTH + pRAC->dmiHeader.StructLength) {
+		pCCB->Status = RCSERR_BAD_ARGUMENT;	/* not enough space available */
+		pCCB->Length = 0;	/* ...to copy the DMI data */
+		return TRUE;
+	}
+
+	/* copy DMI data to callers CCB */
+
+	pDmiData = NULL;	/* assume failure of #define's */
+
+	{
+		unsigned long physAddr;
+		memcpy(&physAddr, &pRAC->dmiHeader.StructAddr, sizeof(physAddr));
+		pDmiData = phys_to_virt(physAddr);
+		if (pDmiData) {
+			memcpy(pCcbDmi->DMIData, pDmiData, pRAC->dmiHeader.StructLength);
+		}
+	}
+
+	if (pDmiData == NULL) {
+		pCCB->Status = RCSERR_INFORMATION_NOT_AVAILABLE;
+		pCCB->Length = 0;
+		return TRUE;
+	}
+
+	/* the DMI was successfully moved to the callers CCB */
+
+	pCCB->Length = pRAC->dmiHeader.StructLength + DMI_RCS_HDR_LENGTH;
+	return FALSE;
+}				/* end of racHandleReportDMI() */
+
+/*****************************************************************************
+ *  after a command is sent to the MegaRac, 
+ *    check if the command effects any internal driver flags
+ *  
+ * if RCS_ADMIN_SHUTDOWN_CARD, then will be last cmd executed until host power cycle
+ ****************************************************************************/
+static void
+racSendCcbMagic(RAC_INFO * pRAC, CCB_Header * pCCB, unsigned long ioControlCode)
+{
+	if (ioControlCode != IOCTL_ISSUE_RCS)
+		return;
+
+	switch (pCCB->Command) {
+	case RCS_CMD_START_HEARTBEAT:
+		pRAC->heartbeatStarted = TRUE;
+		break;
+	case RCS_CMD_STOP_HEARTBEAT:
+		pRAC->heartbeatStarted = FALSE;
+		break;
+	case RCS_ADMIN_SHUTDOWN_CARD:
+		pRAC->shutDownIssued = TRUE;
+		pRAC->okToProcessRCS = FALSE;
+		break;
+	case RCS_ADMIN_RESET_CARD:
+		pRAC->boardAliveCount = BOARD_ALIVE_RESET;
+		pRAC->resetInProgress = TRUE;
+		pRAC->okToProcessRCS = pRAC->specialModeInProgress = FALSE;
+		break;
+	}
+}				/* end of racSendCcbMagic() */
+
+/*****************************************************************************
+ *  returns:    TRUE  - ok to issue ccb to the MegaRac
+ *              FALSE - don't issue ccb to the MegaRac
+ ****************************************************************************/
+static BOOL
+racSendCcbPre(RAC_INFO * pRAC, CCB_Header * pCCB, unsigned long ioControlCode, void **pyCCB)
+{
+	CCB_Header dummyCCB;
+	void *yCCB;
+	unsigned char hasr, hfr;
+
+	if (pCCB == NULL)
+		pCCB = &dummyCCB;
+
+	/* sanity checks that should never fail */
+
+	if (ioControlCode != IOCTL_ISSUE_RCS) {
+		DebugFlagPrint(mega, MEGA_DEVICE, ("racSendCcbPre : unknown IoControlCode=%#x\n", ioControlCode));
+		pCCB->Status = RCSERR_BAD_ARGUMENT;
+		pCCB->Length = 0;
+		return FALSE;
+	}
+
+	if (pRAC->specialModeInProgress) {	/* use racSendCcbSpecialMode() instead */
+		DebugFlagPrint(mega, MEGA_DEVICE, ("racSendCcbPre : failed: specialModeInProgress\n"));
+		pCCB->Status = RCSERR_FUNCTION_NOT_SUPPORTED;
+		pCCB->Length = 0;
+		return FALSE;
+	}
+
+	/* if a shutdown has previously been issued, or a reset is in process, 
+	   then the board will never respond, so reject the command */
+
+	if (pRAC->shutDownIssued) {	/* remains true until power reset */
+		DebugFlagPrint(mega, MEGA_DEVICE, ("racSendCcbPre : failed: shutDownIssued\n"));
+		pCCB->Status = RCSERR_OS_SHUTDOWN_PENDING;
+		pCCB->Length = 0;
+		return FALSE;
+	}
+
+	if (pRAC->resetInProgress) {	/* cleared in racTimerTick() */
+		DebugFlagPrint(mega, MEGA_DEVICE, ("racSendCcbPre : failed: resetInProgress\n"));
+		pCCB->Status = RCSERR_RESOURCES_OCCUPIED_RETRY;
+		pCCB->Length = 0;
+		return FALSE;
+	}
+
+	/* i/o registers are not properly setup */
+
+	if (pRAC->portAddrBase == NULL) {
+		DebugFlagPrint(mega, MEGA_DEVICE, ("racSendCcbPre : failed: portAddrBase==NULL\n"));
+		pCCB->Status = DRACERR_NULL_POINTER_ARGUMENT;
+		pCCB->Length = 0;
+		return FALSE;
+	}
+
+	/* only check hardware status if we actually have a ccb to send to the card */
+
+	if (pyCCB) {
+
+		/* is the megaRAC hardware alive */
+
+		hasr = READ_RAC_UCHAR(pRAC->, portAddrHASR);
+		hfr = READ_RAC_UCHAR(pRAC->, portAddrHFR);
+
+		if ((hasr & HASR_FIRM_READY) == 0 || (hfr & HIFR_HACC)) {
+			DebugFlagPrint(mega, MEGA_DEVICE,
+				       ("racSendCcbPre : failed: MegaRAC not ready, hfr=%#x, hasr=%#x\n", hfr, hasr));
+			pCCB->Status = RCSERR_RESOURCES_OCCUPIED_RETRY;
+			pCCB->Length = 0;
+			return FALSE;
+		}
+
+		if (hasr & HASR_FIRM_FAILED) {
+			DebugFlagPrint(mega, MEGA_DEVICE, ("racSendCcbPre : failed: MegaRAC dead, hasr=%#x\n", hasr));
+			pCCB->Status = MEGARAC_ERR_DEAD;
+			pCCB->Length = 0;
+			return FALSE;
+		}
+
+		/* common place to convert address */
+
+		VIRTUAL_TO_PHYSICAL(pRAC, yCCB, pCCB);
+		if (yCCB)
+			*pyCCB = yCCB;	/* successfully converted to a physical address */
+		else {
+			DebugFlagPrint(mega, MEGA_DEVICE, ("racSendCcbPre : failed: yCCB==NULL\n"));
+			pCCB->Status = DRACERR_NULL_POINTER_ARGUMENT;
+			pCCB->Length = 0;
+			return FALSE;
+		}		/* end of 'if/else yCCB' */
+	}
+	/* end of 'if     pyCCB' */
+	return TRUE;
+}				/* end of racSendCcbPre() */
+
+/*****************************************************************************
+ *  returns:    TRUE  - ccb has been issued to the MegaRac
+ *              FALSE - unable to issue ccb to the MegaRac
+ ****************************************************************************/
+static BOOL
+racSendCcb(RAC_INFO * pRAC, CCB_Header * pCCB, unsigned long ioControlCode)
+{
+	void *yCCB;
+
+	if (pCCB == NULL || !racSendCcbPre(pRAC, pCCB, ioControlCode, &yCCB))
+		return FALSE;
+
+	pRAC->boardAliveCount = BOARD_ALIVE_RESET;	/* give board a chance to process */
+
+	/* give request to the MegaRAC */
+
+	pRAC->currentCCB = pCCB;
+
+	WRITE_RAC_ULONG(pRAC->, portAddrDATA, (unsigned long) yCCB);
+	WRITE_RAC_UCHAR(pRAC->, portAddrHCMDR, HCMDR_ISSUE_RCS_CMD);
+
+	racSendCcbMagic(pRAC, pCCB, ioControlCode);	/* update internal driver flags */
+
+	return TRUE;
+}				/* end of racSendCcb() */
+
+/*****************************************************************************
+ *  returns:    TRUE  - ccb has been issued to the MegaRac
+ *              FALSE - unable to issue ccb to the MegaRac
+ ****************************************************************************/
+static BOOL
+racSendCcbWait(RAC_INFO * pRAC, CCB_Header * pCCB, unsigned long ioControlCode)
+{
+#ifdef DEBUG_PRINT
+#define     RAC_DUMP_REGS(msg)	/*racDumpRegs( pRAC, msg ) */
+#else
+#define     RAC_DUMP_REGS(msg)	/* always blank when debugging is disabled */
+#endif
+
+#define         ARBITRARY_WAIT_LIMIT  2000	/* note: ipmi requests take over one second */
+
+	int limit_A, limit_B = 1, limit_C = 1;	/* prevent error message display if limit_A reached */
+	unsigned char himr, hfr, hasr;
+	BOOL retCode = TRUE;
+	void *yCCB;
+
+	if (pCCB == NULL)
+		return FALSE;
+
+	RAC_DUMP_REGS("before all      ");
+
+	himr = READ_RAC_UCHAR(pRAC->, portAddrHIMR);	/* save current interrupts */
+	WRITE_RAC_UCHAR(pRAC->, portAddrHIMR, HIMR_DISABLE_ALL);	/* disable all MegaRac interrupts */
+	WRITE_RAC_UCHAR(pRAC->, portAddrHFR, HIFR_HACC);	/* clear HACC bit */
+
+	/* wait for firmware to be ready to receive a new command */
+
+	for (limit_A = ARBITRARY_WAIT_LIMIT; --limit_A;) {
+
+		/* is 'firmware ready to receive command' */
+
+		hasr = READ_RAC_UCHAR(pRAC->, portAddrHASR);
+		if ((hasr & HASR_FIRM_READY) == 0) {
+			mdelay(1);	/* not ready, wait a milliSec and try again */
+			continue;
+		}
+
+		/* now the megarac is ready for the command */
+
+		if (!racSendCcbPre(pRAC, pCCB, ioControlCode, &yCCB))
+			return FALSE;
+
+		RAC_DUMP_REGS("before write_rac");
+
+		WRITE_RAC_ULONG(pRAC->, portAddrDATA, (unsigned long) yCCB);
+		WRITE_RAC_UCHAR(pRAC->, portAddrHCMDR, HCMDR_ISSUE_RCS_CMD);
+
+		RAC_DUMP_REGS("after  write_rac");
+
+		/* wait for firmware to read the ccb address */
+
+		for (limit_B = ARBITRARY_WAIT_LIMIT; --limit_B;) {
+			hfr = READ_RAC_UCHAR(pRAC->, portAddrHFR);
+			if (hfr & HIFR_DATA_OUT)	/* is 'Host Data Out Port Empty' */
+				break;	/* yes, firmware has read the request */
+			mdelay(1);	/* no, wait a milliSec and then try again */
+		}
+		RAC_DUMP_REGS("after do loop 1 ");
+
+		/* wait for firmware to process the ccb */
+
+		for (limit_C = ARBITRARY_WAIT_LIMIT; --limit_C;) {
+			hfr = READ_RAC_UCHAR(pRAC->, portAddrHFR);
+			if (hfr & HIFR_HACC)	/* is 'Host Adapter Cmd Complete' */
+				break;	/* yes, firmware has serviced the request */
+			mdelay(1);	/* no, wait a milliSec and then try again */
+		}
+		RAC_DUMP_REGS("after do loop 2 ");
+
+		WRITE_RAC_UCHAR(pRAC->, portAddrHFR, HIFR_HACC);	/* clear HACC bit */
+		break;
+	}			/* end 'for limit_A' */
+
+#ifdef DEBUG_PRINT
+	if (limit_A <= 0)
+		DebugFlagPrint(mega, MEGA_DEVICE, ("racSendCcbWait: limit_A EXCEEDED!!!!\n"));
+	if (limit_B <= 0)
+		DebugFlagPrint(mega, MEGA_DEVICE, ("racSendCcbWait: limit_B EXCEEDED!!!!\n"));
+	if (limit_C <= 0)
+		DebugFlagPrint(mega, MEGA_DEVICE, ("racSendCcbWait: limit_C EXCEEDED!!!!\n"));
+#endif
+
+	if (limit_A <= 0 || limit_B <= 0 || limit_C <= 0) {
+		pCCB->Status = RCSERR_RESOURCES_OCCUPIED_RETRY;
+		pCCB->Length = 0;
+		retCode = FALSE;
+	}
+
+	racSendCcbMagic(pRAC, pCCB, ioControlCode);	/* update internal driver flags */
+	WRITE_RAC_UCHAR(pRAC->, portAddrHIMR, himr);	/* restore original interrupts */
+	RAC_DUMP_REGS("at exit         ");
+	return retCode;
+}				/* end of racSendCcbWait() */
+
+/*****************************************************************************
+ *  returns:    TRUE  - command has been issued to the MegaRac
+ *              FALSE - unable to issue command to the MegaRac
+ ****************************************************************************/
+static BOOL
+racSendCommandWait(RAC_INFO * pRAC, unsigned char hcmdr)
+{
+#undef          ARBITRARY_WAIT_LIMIT
+#define         ARBITRARY_WAIT_LIMIT 4000
+	BOOL retStatus = TRUE;
+	unsigned char himr;
+	int limit_A;
+
+	/* wait for firmware to be ready for this command */
+
+	for (limit_A = ARBITRARY_WAIT_LIMIT; --limit_A;) {
+		unsigned char hasr = READ_RAC_UCHAR(pRAC->, portAddrHASR);
+		if ((hasr & HASR_FIRM_READY) == HASR_FIRM_READY)
+			break;	/* firmware is ready */
+		mdelay(1);	/* not ready, wait a milliSec and try again */
+	}
+	if (limit_A <= 0) {
+		DebugFlagPrint(mega, MEGA_DEVICE, ("racSendCommandWait: HASR_FIRM_READY EXCEEDED!!!!\n"));
+		return FALSE;
+	}
+
+	/* now the megarac is ready for the command */
+
+	himr = READ_RAC_UCHAR(pRAC->, portAddrHIMR);	/* save current interrupts */
+	WRITE_RAC_UCHAR(pRAC->, portAddrHIMR, HIMR_DISABLE_ALL);	/* disable all MegaRac interrupts */
+	WRITE_RAC_UCHAR(pRAC->, portAddrHCMDR, hcmdr);	/* issue the command */
+
+	/* wait for firmware to consume this command */
+
+	for (limit_A = ARBITRARY_WAIT_LIMIT; --limit_A;) {
+		unsigned char hfr = READ_RAC_UCHAR(pRAC->, portAddrHFR);
+		if (hfr & HIFR_HACC) {	/* is 'Host Adapter Command Complete' */
+			break;	/* yes, firmware has serviced the request */
+		}
+		mdelay(1);	/* no, wait a milliSec and then try again */
+	}
+
+	if (limit_A <= 0) {
+		DebugFlagPrint(mega, MEGA_DEVICE, ("racSendCommandWait: HIFR_HACC EXCEEDED!!!!\n"));
+		retStatus = FALSE;
+	}
+
+	WRITE_RAC_UCHAR(pRAC->, portAddrHFR, HIFR_HACC);	/* clear HACC bit */
+	WRITE_RAC_UCHAR(pRAC->, portAddrHIMR, himr);	/* restore original interrupts */
+	return retStatus;
+}				/* end of racSendCommandWait() */
+
+/*****************************************************************************
+ *    send MegaRac its I/O base address from the pciConfig info
+ *     to solve some firmware problem with the PentiumII
+ ****************************************************************************/
+static void
+racSendIoBaseAddr(RAC_INFO * pRAC)
+{
+	RCS_FN_REPORT_IO_BASE_ADDRESS_COMMAND *pCCB;
+
+	MALLOC_CONTIGUOUS(pRAC->, pCCB, RCS_FN_REPORT_IO_BASE_ADDRESS_COMMAND *, sizeof(*pCCB));
+	if (pCCB == NULL)
+		return;
+
+	memset(pCCB, 0, sizeof(*pCCB));
+	pCCB->RCSCmdPkt.Cmd.FullCmd = RCS_CMD_REPORT_IO_BASE_ADDRESS;
+	pCCB->RCSCmdPkt.Length = sizeof(RCS_FN_REPORT_IO_BASE_ADDRESS_ARGS);
+	pCCB->Data.IoBaseAddress = (unsigned long) pRAC->portAddrBase;
+
+	racSendCcbWait(pRAC, (CCB_Header *) pCCB, IOCTL_ISSUE_RCS);
+	FREE_CONTIGUOUS(pRAC->, pCCB);
+}				/* end of racSendIoBaseAddr() */
+
+/*****************************************************************************
+ * undocumented requirement:
+ *   the host or driver must send a start heartbeat so the firmware knows that the
+ *   host OS is available to respond to 'are you there' requests from the remote.
+ *   Otherwise, the firmware will never issue FirmwareRequestInterrupts to the driver. 
+ ****************************************************************************/
+static void
+racSendStartHeartBeat(RAC_INFO * pRAC)
+{
+	RCS_FN_START_HEARTBEAT_COMMAND *pCCB;
+
+	MALLOC_CONTIGUOUS(pRAC->, pCCB, RCS_FN_START_HEARTBEAT_COMMAND *, sizeof(*pCCB));
+	if (pCCB == NULL)
+		return;
+
+	memset(pCCB, 0, sizeof(*pCCB));
+	pCCB->RCSCmdPkt.Cmd.FullCmd = RCS_CMD_START_HEARTBEAT;
+	pCCB->RCSCmdPkt.Length = sizeof(RCS_FN_START_HEARTBEAT_ARGS);
+
+	racSendCcbWait(pRAC, (CCB_Header *) pCCB, IOCTL_ISSUE_RCS);
+	FREE_CONTIGUOUS(pRAC->, pCCB);
+}				/* end of racSendStartHeartBeat() */
+
+/*****************************************************************************
+ *    MegaRac needs a stop heartbeat to know the driver is finished
+ ****************************************************************************/
+static void
+racSendStopHeartBeat(RAC_INFO * pRAC)
+{
+	RCS_FN_STOP_HEARTBEAT_COMMAND *pCCB;
+
+	MALLOC_CONTIGUOUS(pRAC->, pCCB, RCS_FN_STOP_HEARTBEAT_COMMAND *, sizeof(*pCCB));
+	if (pCCB == NULL)
+		return;
+
+	memset(pCCB, 0, sizeof(*pCCB));
+	pCCB->RCSCmdPkt.Cmd.FullCmd = RCS_CMD_STOP_HEARTBEAT;
+
+	racSendCcbWait(pRAC, (CCB_Header *) pCCB, IOCTL_ISSUE_RCS);
+	FREE_CONTIGUOUS(pRAC->, pCCB);
+}				/* end of racSendStopHeartBeat() */
+
+/*****************************************************************************
+ *    
+ ****************************************************************************/
+static void
+racSendHardReset(RAC_INFO * pRAC)
+{
+	CCB_Header dummyCCB;
+
+	WRITE_RAC_UCHAR(pRAC->, portAddrHIMR, HIMR_DISABLE_ALL);	/* disable all MegaRac interrupts */
+	WRITE_RAC_UCHAR(pRAC->, portAddrHCR, HCR_HARD_RESET);	/* ...to prevent spurious */
+
+	dummyCCB.Command = RCS_ADMIN_RESET_CARD;	/* soft reset is ok for this magic */
+	racSendCcbMagic(pRAC, &dummyCCB, IOCTL_ISSUE_RCS);
+}				/* end of racSendHardReset() */
+
+/*****************************************************************************
+ *    
+ ****************************************************************************/
+static BOOL
+racGetRegister(RAC_INFO * pRAC, CCB_Header * pCCB)
+{
+	BOOL status = TRUE;
+	unsigned long value;
+
+	switch (pCCB->Reserved[0]) {
+	case HOST_INTERRUPT_MASK_REG:
+		value = (unsigned long) READ_RAC_UCHAR(pRAC->, portAddrHIMR);
+		break;
+	case HOST_INTERRUPT_FLAG_REG:
+		value = (unsigned long) READ_RAC_UCHAR(pRAC->, portAddrHIFR);
+		break;
+	case HOST_COMMAND_REG:
+		value = (unsigned long) READ_RAC_UCHAR(pRAC->, portAddrHCMDR);
+		break;
+	case HOST_DATA_IN_REG:
+		value = READ_RAC_ULONG(pRAC->, portAddrDATA);
+		break;
+	case HOST_ADAPTER_STATUS_REG:
+		value = (unsigned long) READ_RAC_UCHAR(pRAC->, portAddrHASR);
+		break;
+	case HOST_FLAGS_REG:
+		value = (unsigned long) READ_RAC_UCHAR(pRAC->, portAddrHFR);
+		break;
+	case HOST_CONTROL_REG:
+		value = (unsigned long) READ_RAC_UCHAR(pRAC->, portAddrHCR);
+		break;
+	default:
+		value = 0;
+		status = FALSE;
+		break;
+	}
+
+	pCCB->Reserved[2] = (unsigned char) ((value >> 24) & 0x00ff);
+	pCCB->Reserved[3] = (unsigned char) ((value >> 16) & 0x00ff);
+	pCCB->Reserved[4] = (unsigned char) ((value >> 8) & 0x00ff);
+	pCCB->Reserved[5] = (unsigned char) ((value) & 0x00ff);
+
+	return status;
+}				/* end of racGetRegister() */
+
+/*****************************************************************************
+ *    -----NEVER USED and NEVER TESTED------- 
+ ****************************************************************************/
+#if 0
+static void racSendEnterSpecialMode(RAC_INFO * pRAC, unsigned char specialMode);
+static void
+racSendEnterSpecialMode(RAC_INFO * pRAC, unsigned char specialMode)
+{
+#define HCMDR_ENTER_IMAGE_FLASH_MODE 0x40	/* enter image flash mode */
+	int i;
+
+	/* a double special situation, 
+	   request is to flash the SDK block, rather than the firmware image */
+
+	if (specialMode == HCMDR_ENTER_SDK_FLASH_MODE) {
+		racSendCommandWait(pRAC, specialMode);
+		specialMode = HCMDR_ENTER_IMAGE_FLASH_MODE;	/* a white lie for next phase */
+	}
+
+	/* special modes can only be entered during a small window of time after a reset */
+
+	racSendHardReset(pRAC);
+
+	for (i = 0; i < (10 * 1000); i++) {	/* wait maximum of ten seconds */
+		unsigned char hfr = READ_RAC_UCHAR(pRAC->, portAddrHFR);
+		if (hfr & HIFR_SOFT_INT) {	/* megarac is coming alive */
+			WRITE_RAC_UCHAR(pRAC->, portAddrHFR, HIFR_SOFT_INT);	/* reset the bit */
+			WRITE_RAC_UCHAR(pRAC->, portAddrHCMDR, specialMode);	/* tell megarac the desired mode */
+			pRAC->specialModeInProgress = TRUE;
+			mdelay(1);	/* wait a milliSec for mode to invoke */
+			return;	/* success */
+		}
+		mdelay(1);	/* wait a milliSec and then try again */
+	}
+
+	/* failed to capture the reset */
+
+	racSendHardReset(pRAC);	/* kick megarac back to normal mode */
+}				/* end of racSendEnterSpecialMode() */
+#endif
+
+/*****************************************************************************
+ *    
+ ****************************************************************************/
+static void
+racStartupFinal(RAC_INFO * pRAC)
+{
+	unsigned char hasr = READ_RAC_UCHAR(pRAC->, portAddrHASR);
+
+	DebugFlagPrint(mega, MEGA_ENTRY, ("racStartupFina: hasr=%#x\n", hasr));
+
+	pRAC->okToProcessRCS = FALSE;	/* racPreProcessCCB will reject future commands */
+
+	/* is 'firmware ready to receive command' */
+
+	if ((hasr & HASR_FIRM_READY) == 0 || (hasr & HASR_FIRM_FAILED)) {	/* bad news, board is probably very dead */
+		racSendHardReset(pRAC);	/* make attempt to kick-start */
+		DebugFlagPrint(mega, MEGA_ENTRY, ("racStartupFina: card is dead, trying to reset\n"));
+		return;
+	}
+
+	/* send MegaRac its I/O base address from the pciConfig info */
+
+	racSendIoBaseAddr(pRAC);
+
+	/* let MegaRac know that the driver is now running */
+
+	racSendStartHeartBeat(pRAC);
+
+	/* enable MegaRAC interrupts */
+
+	WRITE_RAC_UCHAR(pRAC->, portAddrHIMR, HIMR_DISABLE_ALL);	/* disable all MegaRac interrupts */
+	WRITE_RAC_UCHAR(pRAC->, portAddrHCR, HCR_INTR_RESET);	/* reset all interrupt bits */
+	WRITE_RAC_UCHAR(pRAC->, portAddrHIMR, HIMR_DEFAULTS);	/* enable desired interrupts */
+
+	/* the driver is now ready to service host requests */
+
+	pRAC->okToProcessRCS = TRUE;
+
+}				/* end of racStartupFinal() */
+
+/*****************************************************************************
+ *    
+ ****************************************************************************/
+static void
+racShutdownBegin(RAC_INFO * pRAC)
+{
+	/* the driver can no longer service host requests */
+
+	pRAC->okToProcessRCS = FALSE;
+
+	/* if an error occurs during driver initialization this function
+	   might get called before all the i/o registers are setup */
+
+	if (pRAC->portAddrBase == NULL)
+		return;
+
+	/* megarac needs a stop heartbeat to know the driver is finished */
+
+	if (pRAC->heartbeatStarted)
+		racSendStopHeartBeat(pRAC);
+
+	/* disable any future interrupts from the MegaRac */
+
+	WRITE_RAC_UCHAR(pRAC->, portAddrHIMR, HIMR_DISABLE_ALL);
+	WRITE_RAC_UCHAR(pRAC->, portAddrHCR, HCR_INTR_RESET);
+
+	/* if this is an operating system that is exiting to DOS,
+	   then need to leave HACC bit set to allow DOS based programs to work.
+	   Specifically this would be NetWare and raccfg */
+
+	WRITE_RAC_UCHAR(pRAC->, portAddrHCMDR, HCMDR_SET_HACC);
+
+}				/* end of racShutdownBegin() */
+
+/*****************************************************************************
+ *
+ ****************************************************************************/
+static void
+racPreProcessCCB(RAC_INFO * pRAC,
+		 CCB_Header * pCCB, unsigned long bufLen, unsigned long ioControlCode, RAC_DRVR_ERR * drvrStatus)
+{
+
+	if (!pCCB) {		/* prevent occasional surprise */
+		*drvrStatus = racDrvrErrNotImplemented;
+		return;
+	}
+
+	DebugFlagPrint(mega, MEGA_STARTIO,
+		       ("racPreProcessC: ccb.cmd=%#x, ccb.status=%#x, ccb.length=%#x\n",
+			pCCB->Command, pCCB->Status, pCCB->Length));
+
+	*drvrStatus = racDrvrErrNone;	/* hope for the best */
+
+	switch (ioControlCode) {
+	case IOCTL_ISSUE_RCS:
+		if (!racSendCcbPre(pRAC, pCCB, IOCTL_ISSUE_RCS, NULL))
+			break;	/* unable to process, return ccb to api */
+
+		if (!pRAC->okToProcessRCS) {
+			pCCB->Status = MEGARAC_ERR_FAILED;
+			pCCB->Length = 0;
+			break;	/* unable to process, return ccb to api */
+		}
+
+		if (pCCB->Command == RCS_CMD_REPORT_DMI_INFO) {
+			if (racHandleReportDMI(pRAC, pCCB))
+				break;	/* request has been fulfilled, return ccb to api */
+		} /* else fall thru and send ccb to megarac */
+		else if (pCCB->Command == RCS_RED_REPORT_CURSOR_POS && racGetHardwareCursor) {
+			REPORT_CURSOR_POS_PKT *pRCP = (REPORT_CURSOR_POS_PKT *) (pCCB + 1);
+			pRCP->LinearCursorPos = (*racGetHardwareCursor) ();
+			DebugFlagPrint(mega, MEGA_STARTIO,
+				       ("              : stuffed cursor=%#x\n", pRCP->LinearCursorPos));
+		}
+		/* fall thru and send ccb to megarac */
+#ifdef DEBUG_PRINT
+		if (DebugFlagIsSet(mega, MEGA_POLL_MODE)) {
+			BOOL bStatus = racSendCcbWait(pRAC, pCCB, IOCTL_ISSUE_RCS);
+			if (!bStatus) {
+				pCCB->Status = RCSERR_DEVICE_NO_RESPONSE;
+				pCCB->Length = 0;
+			}
+			DebugPrintf(("racPreProcessC: in MEGA_POLL_MODE status=%s ------------\n",
+				     bStatus ? "good" : "bad"));
+			break;
+		}
+#endif
+
+		*drvrStatus = racDrvrErrPending;	/* processing not complete */
+		break;		/* ... still need to send to megarac */
+
+/* according to Jose 07/12/99, this is not used, but need to test to be sure */
+	case IOCTL_GET_GRAPHICS:
+		if (bufLen < sizeof(pRAC->firmwareRequestDCPacket))
+			*drvrStatus = racDrvrErrInvalidParameter;
+		break;		/* OS driver must copy data into callers buffer */
+
+	case IOCTL_RESET_CARD:
+		pCCB->Status = RCSERR_SUCCESS;
+		pCCB->Length = 0;
+		racSendHardReset(pRAC);
+		break;
+
+	case IOCTL_API_INTERNAL:
+		pCCB->Status = RCSERR_SUCCESS;	/* be optimistic */
+		pCCB->Length = 0;
+		/* specialMode never used, and never tested
+		   //if ( xxx ) {          * a special mode is being requested *
+		   //    racSendEnterSpecialMode( pRAC, pCCB->Reserved[0] );
+		   //    if ( !pRAC->specialModeInProgress )
+		   //        pCCB->Status = RCSERR_DEVICE_NO_RESPONSE;
+		   //}
+		   //else */
+		switch (pCCB->Command) {
+		case MEGARAC_API_CMD_ATTACHMENTS:
+			if (racOsAttachmentsProc)
+				(*racOsAttachmentsProc) (pRAC, pCCB);
+			else
+				pCCB->Status = RCSERR_FUNCTION_NOT_SUPPORTED;
+			break;
+		case MEGARAC_API_CMD_ISSUE_CMD:
+			if (!racSendCommandWait(pRAC, pCCB->Reserved[0]))
+				pCCB->Status = RCSERR_DEVICE_NO_RESPONSE;
+			break;
+		case MEGARAC_API_CMD_GET_REG:
+			if (!racGetRegister(pRAC, pCCB))
+				pCCB->Status = RCSERR_FUNCTION_NOT_SUPPORTED;
+			break;
+		case MEGARAC_API_CMD_SET_EVENTS:
+			if (racOsSetEventsProc)
+				(*racOsSetEventsProc) (pRAC, pCCB);
+			else
+				pCCB->Status = RCSERR_FUNCTION_NOT_SUPPORTED;
+			break;
+		default:
+			pCCB->Status = RCSERR_FUNCTION_NOT_SUPPORTED;
+			break;
+		}
+		break;
+
+	default:
+		DebugFlagPrint(mega, MEGA_STARTIO, ("racPreProcessC: unknown IoControlCode=%#x\n", ioControlCode));
+		*drvrStatus = racDrvrErrNotImplemented;
+		break;
+	}			/* end of 'switch ioControlCode' */
+
+	DebugFlagPrint(mega, MEGA_STARTIO,
+		       ("              : exit drvrStatus=%#x, ioctl=%s\n",
+			*drvrStatus, racIoctlToString(ioControlCode)));
+}				/* end of racPreProcessCCB() */
+
+/*****************************************************************************
+ *  bottom-half of ISR
+ ****************************************************************************/
+static BOOL
+racIsrDpc(RAC_INFO * pRAC)
+{
+	BOOL didIoComplete = FALSE;
+	unsigned char hfr, hasr, himr;
+	unsigned long data;
+
+	/* get all possible info from board before reseting interrupt bits */
+
+	hasr = READ_RAC_UCHAR(pRAC->, portAddrHASR);
+	hfr = READ_RAC_UCHAR(pRAC->, portAddrHFR);
+	data = READ_RAC_ULONG(pRAC->, portAddrDATA);
+
+	DebugFlagPrint(mega, MEGA_DPCISR,
+		       ("racIsrDpc     : hfr=%#x, hasr=%#x, dataIn=%#x, curCCB=%#x\n",
+			hfr, hasr, data, pRAC->currentCCB));
+
+	/* reset interrupt bits, any new events will cause a new interrupt */
+
+	WRITE_RAC_UCHAR(pRAC->, portAddrHFR, hfr);
+
+	/* board is alive because it gave us this interrupt */
+
+	pRAC->boardAliveCount = BOARD_ALIVE_RESET;
+
+	/* check if new firmware request from MegaRAC */
+
+	if (hfr & HIFR_FIRM_REQ) {
+		pRAC->firmwareRequestData = data;
+		racEvent(pRAC, racEventFirmwareRequest);
+	}
+
+	/* check if board has completed a host command */
+
+	himr = HIMR_DEFAULTS;
+
+	if (hfr & HIFR_HACC) {
+		CCB_Header *pCCB = pRAC->currentCCB;
+
+		if (pRAC->resetInProgress)
+			himr = HIMR_DISABLE_ALL;	/* disable all MegaRac interrupts */
+
+		if (pCCB == NULL) {
+			DebugFlagPrint(mega, MEGA_DPCISR, ("************* : no currentCCB\n"));
+		} else {
+			DebugFlagPrint(mega, MEGA_DPCISR,
+				       ("                ccb.cmd=%#x, ccb.status=%#x, ccb.length=%#x\n",
+					pCCB->Command, pCCB->Status, pCCB->Length));
+			pRAC->currentCCB = NULL;
+			didIoComplete = TRUE;
+		}
+	}
+
+	WRITE_RAC_UCHAR(pRAC->, portAddrHIMR, himr);	/* enable desired interrupts */
+
+	return didIoComplete;
+}				/* end of racIsrDpc() */
+
+/*****************************************************************************
+ *  one second has elapsed
+ ****************************************************************************/
+static void
+racTimerTick(RAC_INFO * pRAC)
+{
+	static unsigned short lastCursorPosition = ~0;
+
+	static BOOL oncePerFailure = FALSE;
+	unsigned char hasr = READ_RAC_UCHAR(pRAC->, portAddrHASR);
+
+#if 0
+	DebugFlagPrint(mega, MEGA_TIMEOUT,
+		       ("racTimerTick   : hasr=%#x, resetInProgress=%#x\n", hasr, pRAC->resetInProgress));
+#endif
+
+	/* if a soft or hard reset was issued,
+	   we hope the board will eventually recover successfully 
+	   which will be indicated by HASR_FIRM_READY being set.
+	   If the board does not recover, then eventually 
+	   racInfo.boardAliveCount will expire and we'll signal the host */
+
+	if (pRAC->resetInProgress) {	/* reset was recently issued */
+		DebugFlagPrint(mega, MEGA_TIMEOUT,
+			       ("racTimerTick  : resetInProgress=%#x, hasr=%#x\n", pRAC->resetInProgress, hasr));
+		if (pRAC->specialModeInProgress)
+			pRAC->boardAliveCount = BOARD_ALIVE_RESET;
+		else if (hasr & HASR_FIRM_READY) {	/* has board recovered yet */
+			pRAC->resetInProgress = FALSE;	/* yes */
+			if (pRAC->portAddrBase) {	/* racStartupFinal() probably ran ok */
+				pRAC->okToProcessRCS = TRUE;
+				pRAC->boardAliveCount = BOARD_ALIVE_RESET;
+				WRITE_RAC_UCHAR(pRAC->, portAddrHCR, HCR_INTR_RESET);	/* reset all interrupt bits */
+				WRITE_RAC_UCHAR(pRAC->, portAddrHIMR, HIMR_DEFAULTS);	/* enable desired interrupts */
+			}
+		}
+	}
+
+	/* is firmware+hardware happy */
+
+	if ((hasr & HASR_FIRM_FAILED) == 0) {
+		oncePerFailure = FALSE;	/* everything ok */
+	} else {		/* board is dead */
+		if (!oncePerFailure) {	/* send alert, if haven't done yet */
+			DebugFlagPrint(mega, MEGA_TIMEOUT,
+				       ("racTimerTick  : firmware failure\n"
+					"************* : hasr=%#x, data=%#x, resetInProgress=%#x\n",
+					hasr, READ_RAC_ULONG(pRAC->, portAddrDATA), pRAC->resetInProgress));
+			oncePerFailure = TRUE;	/* don't send again until board is alive once */
+			racEvent(pRAC, racEventBoardDead);
+		}
+	}
+
+	/* no response from board, get back any outstanding i/o */
+
+	if (++pRAC->boardAliveCount >= RAC_CARD_READY_TIMEOUT) {
+		pRAC->boardAliveCount = BOARD_ALIVE_RESET;
+		if (pRAC->currentCCB) {
+			DebugFlagPrint(mega, MEGA_TIMEOUT,
+				       ("racTimerTick  : boardAliveCount failure, hasr=%#x\n", hasr));
+			racEvent(pRAC, racEventBoardDead);
+		}
+	}
+
+	/* on some platforms cursor position updates is done with software to work around asic bug */
+
+	if (racGetHardwareCursor &&	/* driver provides software cursor function */
+	    racOsEventProc &&	/* ...and has a way to signal application program */
+	    !pRAC->resetInProgress &&	/* soft or hard reset       not      issued */
+	    !pRAC->shutDownIssued) {	/* RCS_ADMIN_SHUTDOWN_CARD  not      issued */
+		unsigned short currentCursorPosition = (*racGetHardwareCursor) ();
+		if (lastCursorPosition != currentCursorPosition) {	/* the cursor has moved */
+			DebugFlagPrint(mega, MEGA_TIMEOUT,
+				       ("racTimerTick  : lastCursor=%#x, currentCursor=%#x\n", lastCursorPosition,
+					currentCursorPosition));
+			lastCursorPosition = currentCursorPosition;
+			(*racOsEventProc) (pRAC, racEventFirmwareRequest, racEventCursorChange);
+		}
+	}
+
+	/* send heartbeat to megarac to tell firmware that driver is alive */
+
+#if 0
+	DebugFlagPrint(mega, MEGA_TIMEOUT,
+		       ("racTimerTick  : heartbeatStarted=%#x, resetInProgress=%#x, shutDownIssued=%#x\n"
+			"                hasr=%#x, heartbeatCount=%#x\n",
+			pRAC->heartbeatStarted, pRAC->resetInProgress, pRAC->shutDownIssued,
+			hasr, pRAC->heartbeatCount));
+#endif
+
+	if (pRAC->heartbeatStarted &&	/* RCS_CMD_START_HEARTBEAT  has been issued */
+	    !pRAC->resetInProgress &&	/* soft or hard reset       not      issued */
+	    !pRAC->shutDownIssued &&	/* RCS_ADMIN_SHUTDOWN_CARD  not      issued */
+	    (hasr & HASR_FIRM_READY) &&	/* firmware is not busy doing something else */
+	    ++pRAC->heartbeatCount >= 5) {	/* and finally, it has been a few seconds */
+		WRITE_RAC_UCHAR(pRAC->, portAddrHCR, HCR_SOFT_INTR_1);	/* ...since last heartbeat */
+		pRAC->heartbeatCount = 0;	/* ...was sent to MegaRac */
+	}
+
+}				/* end of racTimerTick() */
+
+/*****************************************************************************
+ *
+ ****************************************************************************/
+static void
+racEvent(RAC_INFO * pRAC, RAC_EVENT rawEvent)
+{
+	RAC_EVENT firm = rawEvent;
+
+	DebugFlagPrint(mega, MEGA_EVENT, ("racEvent      : event=%#x\n", rawEvent));
+
+	/* the os dependent racOsEventProc() should release the current ccb back to the api */
+
+	if (rawEvent == racEventBoardDead) {
+		pRAC->okToProcessRCS = FALSE;
+
+		if (pRAC->currentCCB) {
+			pRAC->currentCCB->Status = MEGARAC_ERR_DEAD;
+			pRAC->currentCCB->Length = 0;
+			pRAC->currentCCB = NULL;	/* we've done all we can do */
+		}
+	}
+	/* according to Jose on 07/12/99, most of the racEventFirmwareRequest's are not handled.
+	   see megaRacDrvr.h for more info */
+	else if (rawEvent == racEventFirmwareRequest) {
+		switch (pRAC->firmwareRequestData & 0x0000ffff) {
+		case GetDCInfo_FRI:
+			firm = racEventGetDCInfo;
+			break;
+		case GetDCPacket_x_FRI:
+			firm = racEventGetDCPacket_X;
+			pRAC->firmwareRequestDCPacket = (unsigned short) (pRAC->firmwareRequestData >> 16) & 0x0ffff;
+			return;
+		case SendDCComplete_FRI:
+			firm = racEventSendDCComplete;
+			break;
+		case SendKeyEvent_FRI:
+			firm = racEventSendKey;
+			break;
+		case SendMouseEvent_FRI:
+			firm = racEventSendMouse;
+			break;
+		case SendAlertToHost_FRI:
+			firm = racEventSendAlertToHost;
+			break;
+		case HOST_OS_SHUTDOWN_REQUEST_FRI:
+			firm = racEventRequestHostOsShutdown;
+			break;
+		case ModeChangedToGraphics_FRI:
+			firm = racEventModeChangedToGraphics;
+			break;
+		case ServiceDYRM_FRI:
+			firm = racEventServiceDYRM;
+			break;
+		case PassThruData_FRI:
+			firm = racEventPassThruData;
+			break;
+		default:
+			return;
+		}		/* end 'switch' */
+
+		DebugFlagPrint(mega, MEGA_EVENT,
+			       ("racEvent      : HIFR_FIRM_REQ: firm=%#x (%s)\n",
+				(int) firm, racFriToString((int) firm)));
+	}
+
+	/* end 'if/else rawEvent' */
+	/* invoke the os-dependent function to service this event */
+	if (racOsEventProc)
+		(*racOsEventProc) (pRAC, rawEvent, firm);
+
+}				/* end of racEvent() */
+
diff -urNp linux-5000/drivers/addon/megarac/MegaRacDebug.h linux-5010/drivers/addon/megarac/MegaRacDebug.h
--- linux-5000/drivers/addon/megarac/MegaRacDebug.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/MegaRacDebug.h	
@@ -0,0 +1,229 @@
+/****************************************************************************
+ *
+ *  MegaRacDebug.h 
+ *
+ ****************************************************************************/
+#ifndef MEGARAC_DEBUG_H_INCLUDED
+#define MEGARAC_DEBUG_H_INCLUDED
+  
+#include "MegaRacWho.h"
+
+#if defined(MEGARAC_DRIVER_SOLARIS) || \
+    defined(MEGARAC_DRIVER_LINUX)           /* stdio makes unix kernels unhappy */
+#else                                       /* ...so don't include it */
+#include <stdio.h>
+#include <stdarg.h>
+#endif
+
+
+
+
+
+
+
+
+
+   /****************************************************************************
+    *
+    *  The application should choose a unique "prefix" related to its 
+    *  module name, e.g. DebugFlagDeclare(xyz,static) 
+    *
+    *  To make the "storage" class of the bit field empty, i.e. global,
+    *         do DebugFlagDeclare(xyz,DEBUG_PRINT_STORAGE_GLOBAL) 
+    *         then in other modules use DebugFlagDeclare(xyz,extern)
+    *
+    *  The usage of the bits in the "prefix##DebugFlags" variable
+    *  is currently undefined, but for now...
+    *    general users  : least significant bits (0x00000000-0x0000ffff)
+    *    system reserved: most  significant bits (0x00010000-0xffff0000)  
+    *
+    *  Note for the 'prt' parameter which is used for printf(),
+    *  the parameter must be specified within parentheses, e.g.
+    *  DebugPrint( ("called from %s at line %d\n",__FILE__,__LINE__) );
+    *
+    *  example:
+    *   #define DEBUG_PRINT      ** turn debug printing on **
+    *   #include "MegaRacDebug.h"
+    *   DebugFlagDeclare(xyz,static);
+    *   #define XYZ_ISR 0x0001
+    *   ...
+    *   DebugFlagSet( xyz, ~0 ); ** activate all bits for initial testing **
+    *   DebugFlagPrint( xyz, XYZ_ISR, ("in ISR: datum=%x\n",datum) );
+    *
+    ***************************************-***********************************/
+
+    /* it is a little complicated but...
+       if MegaRacDebug.h was already included, but now the user wants to change
+       the state of DEBUG_PRINT and reload the macros, then the user does:
+           #ifdef DEBUG_H_INCLUDED 
+           #undef DEBUG_H_INCLUDED
+           #endif
+           #define DEBUG_PRINT
+           #include "MegaRacDebug.h"
+       and we help here by undefining the existing macros to prevent
+       compiler warnings. */
+
+#ifdef DebugFlagDeclare
+    #undef  DEBUG_PRINT_STORAGE_GLOBAL
+    #undef  DebugFlagDeclare
+    #undef  DebugFlagSet
+    #undef  DebugFlagClear
+    #undef  DebugFlagIsSet
+    #undef  DebugFlagPrint
+    #undef  DebugFlagCode
+    #undef  DebugPrint
+    #undef  DebugCode
+    #undef  DebugOutputFuncNT
+    #undef  DebugOutputFuncNW
+    #undef  DebugOutputFuncSU
+    #undef  DebugOutputFuncLX
+    #undef  DebugOutputFuncSol
+#endif
+
+
+#ifdef DEBUG_PRINT
+    #if defined DEBUG_PRINT_FUNCTION
+                                #define DebugPrintFunction DEBUG_PRINT_FUNCTION
+    #else
+                                #define DebugPrintFunction printf
+    #endif
+  #define DEBUG_PRINT_STORAGE_GLOBAL       /* empty storage allows global visibility */
+  #define DebugFlagDeclare(prefix,storage ) storage unsigned long prefix ## DebugFlags
+  #define DebugFlagSet(    prefix,bits    )      prefix ## DebugFlags |=  (bits)
+  #define DebugFlagClear(  prefix,bits    )      prefix ## DebugFlags &= ~(bits)
+  #define DebugFlagIsSet(  prefix,bits    )     (prefix ## DebugFlags &   (bits))
+  #define DebugFlagPrint(  prefix,bits,prt) if ( prefix ## DebugFlags &   (bits) ) DebugPrintFunction prt
+  #define DebugFlagCode(   prefix,bits,cod) if ( prefix ## DebugFlags &   (bits) ) cod
+  #define DebugPrintf(                 prt) DebugPrintFunction prt
+  #define DebugCode(                   cod) cod
+  
+  #define DebugOutputFuncNT(prefix,storage) /* Windows API/DLL */       \
+            storage void prefix ## OutputFunc( char *fmtStr, ... )      \
+            {   static unsigned long cnt;                               \
+                int                len;                                 \
+                char               buf[500];                            \
+                va_list            ap;                                  \
+                va_start         ( ap,  fmtStr );                       \
+          len = vsprintf         ( buf, fmtStr, ap );                   \
+                  printf         ( buf );                               \
+                OutputDebugString( buf );                               \
+                if ( (prefix ## DebugFlags & MEGA_DLL_LOG) ) {              \
+                    int i, ii, offset;                                      \
+                    char last=0, bux[99];                                   \
+                    for( i=offset=0 ; i<=len ; i++ ) {                      \
+                        if ( buf[i]=='\n' || (buf[i]==0 && last!='\n') ) {  \
+                            last   = buf[i];                                \
+                            buf[i] = 0;                                     \
+                            ii=sprintf ( bux, "racAPI_" );                  \
+                               _strtime( bux + ii );                        \
+                               sprintf ( bux + ii + 8, "_%d", cnt++ );      \
+                            WritePrivateProfileString("Tester",bux,buf+offset,"racDLL.log");\
+                            offset = i + 1;                                 \
+                }   }   }                                                   \
+                va_end           ( ap );                                    \
+            }
+  #define DebugOutputFuncNW(prefix,storage) /* Netware Driver */        \
+            storage void prefix ## OutputFunc( char *fmtStr, ... )      \
+            {   extern unsigned long prefix ## ScreenHandle;            \
+                char               buf[500];                            \
+                va_list            ap;                                  \
+                va_start         ( ap,  fmtStr );                       \
+                vsprintf         ( buf, fmtStr, ap );                   \
+                OutputToScreen   ( prefix ## ScreenHandle, buf );       \
+                va_end           ( ap );                                \
+                if ( (prefix ## DebugFlags & MEGA_INSIDE_ISR) == 0 )    \
+                    NPA_Delay_Thread(devInfo.osInfo.npaHandle,1);       \
+            }
+  #define DebugOutputFuncNW_API(prefix,storage) /* Netware API */       \
+            storage void prefix ## OutputFunc( char *fmtStr, ... )      \
+            {   char               buf[500];                            \
+                va_list            ap;                                  \
+                va_start         ( ap,  fmtStr );                       \
+                vsprintf         ( buf, fmtStr, ap );                   \
+                  printf         ( buf );                               \
+                va_end           ( ap );                                \
+                delay(5);                                               \
+            }
+  #define DebugOutputFuncSU(prefix,storage) /* SCO Unix Driver */       \
+            storage void prefix ## OutputFunc( char *fmtStr, ... )      \
+            {   char               buf[500];                            \
+                va_list            ap;                                  \
+                va_start         ( ap,  fmtStr );                       \
+                vsprintf         ( buf, fmtStr, ap );                   \
+                cmn_err          ( CE_CONT, buf );                      \
+                va_end           ( ap );                                \
+            }
+  #define DebugOutputFuncLX(prefix,storage) /* Linux Driver */          \
+            storage void prefix ## OutputFunc( char *fmtStr, ... )      \
+            {   char            buf[500];                               \
+                const char      racText[] = KERN_ALERT "RAC: ";         \
+                const int       racTextLen=sizeof(racText)-1;           \
+                va_list            ap;                                  \
+                va_start         ( ap,  fmtStr );                       \
+                memcpy           ( buf, racText, racTextLen);           \
+                vsprintf         ( buf+racTextLen, fmtStr, ap );        \
+                printk           ( buf );                               \
+                va_end           ( ap );                                \
+            }
+  #define DebugOutputFuncLX_API(prefix,storage) /* Linux API */         \
+            storage void prefix ## OutputFunc( char *fmtStr, ... )      \
+            {   int                len;                                 \
+                char               buf[500];                            \
+                va_list            ap;                                  \
+                va_start         ( ap,  fmtStr );                       \
+          len = vsprintf         ( buf, fmtStr, ap );                   \
+                 fprintf         ( stderr, buf );                       \
+                if ( (prefix ## DebugFlags & MEGA_DLL_LOG) ) {              \
+                    static BOOL didOpenLog = FALSE;                         \
+                    int i, offset;                                          \
+                    char last=0;                                            \
+                    if ( !didOpenLog ) {                                    \
+                        didOpenLog = TRUE;                                  \
+                        openlog( "RAC  ", LOG_PID, LOG_USER );              \
+                    }                                                       \
+                    for( i=offset=0 ; i<=len ; i++ ) {                      \
+                        if ( buf[i]=='\n' || (buf[i]==0 && last!='\n') ) {  \
+                            last   = buf[i];                                \
+                            buf[i] = 0;                                     \
+                            syslog( LOG_USER|LOG_INFO, buf+offset );        \
+                            offset = i + 1;                                 \
+                }   }   }                                                   \
+                va_end           ( ap );                                    \
+            }
+  #define DebugOutputFuncSol(prefix,storage) /* Solaris Driver */       \
+            storage void prefix ## OutputFunc( char *fmtStr, ... )      \
+            {   char               buf[500];                            \
+                va_list            ap;                                  \
+                va_start         ( ap,  fmtStr );                       \
+                vsprintf         ( buf, fmtStr, ap );                   \
+                cmn_err          ( CE_CONT, buf );                      \
+                va_end           ( ap );                                \
+            }
+
+#else                                       /* else '#ifdef DEBUG_PRINT' */
+    #define DEBUG_PRINT_STORAGE_GLOBAL       
+    #define DebugFlagDeclare(  prefix,storage )
+    #define DebugFlagSet(      prefix,bits    )
+    #define DebugFlagClear(    prefix,bits    )
+    #define DebugFlagIsSet(    prefix,bits    ) 0   /* always FALSE */
+    #define DebugFlagPrint(    prefix,bits,prt)
+    #define DebugFlagCode(     prefix,bits,cod) 
+    #define DebugPrintf(                   prt)
+    #define DebugCode(                     cod)  
+    #define DebugOutputFuncNT( prefix,storage )
+    #define DebugOutputFuncNW( prefix,storage )
+    #define DebugOutputFuncSU( prefix,storage )
+    #define DebugOutputFuncLX( prefix,storage )
+    #define DebugOutputFuncSol(prefix,storage )
+    #if defined(__WATCOMC__) || defined(__SCO_VERSION__)
+        #undef  DebugFlagDeclare
+        #define DebugFlagDeclare( prefix,storage)   extern int dummyForCompilation
+        #undef  DebugOutputFuncNW
+        #define DebugOutputFuncNW(prefix,storage)   extern int dummyForCompilation;
+    #endif
+#endif                                      /* end '#ifdef/#else DEBUG_PRINT' */
+
+
+#endif /* MEGARAC_DEBUG_H_INCLUDED */
+
+
diff -urNp linux-5000/drivers/addon/megarac/MegaRacDLL.h linux-5010/drivers/addon/megarac/MegaRacDLL.h
--- linux-5000/drivers/addon/megarac/MegaRacDLL.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/MegaRacDLL.h	
@@ -0,0 +1,415 @@
+/****************************************************************************
+ *  MegaRacDLL.h
+ ****************************************************************************/
+#ifndef MEGA_RAC_DLL_H
+#define MEGA_RAC_DLL_H
+
+#include <linux/limits.h>
+
+/****************************************************************************
+ *      pack all structures in this file
+ ****************************************************************************/
+#pragma pack(1)                             /* supported by all current compilers */
+
+/*---------------------------
+ * begin Firmware
+ *---------------------------*/
+#ifndef WORD
+typedef unsigned short   WORD;
+#endif
+
+#include "admin.h"
+#include "agpintfc.h"
+#include "alerter.h"
+#include "batmon.h"
+#undef    ABSOLUTE
+#include "ccbhdlr.h"
+#include "comrcs.h"
+#include "crc16.h"
+#include "dbglog.h"
+#include "dmi.h"
+#include "errcod.h"
+#include "evtlog.h"
+#include "ftp.h"
+#include "flash.h"
+#include "i2crsa.h"
+#include "misc.h"
+#include "post.h"
+#include "rcs.h"
+#include "rcsadmin.h"
+#include "rcsdbg.h"
+#include "rcsdiag.h"
+#include "rcshhf.h"
+#include "rcsic.h"
+#include "rcsred.h"
+#include "rcssdk.h"
+#include "rcsusr.h"
+#include "redirect.h"
+#include "rtc.h"
+/* should be in rcsdiag.h, but isn't */
+#define RCS_DIAG_FORCE_FAIL                 0x0810
+#define FORCE_FAIL_CMD_PCISERR              0
+#define FORCE_FAIL_CMD_ABORT_WITH_RESET     1
+#define FORCE_FAIL_CMD_ABORT_WITHOUT_RESET  2
+#define FORCE_FAIL_CMD_EAT_COMMAND          3
+typedef struct _RCS_DIAG_ForceFailArgs {
+   unsigned short FailCmd;
+   unsigned char	FailPkt[16];
+}RCS_DIAG_FORCE_FAIL_ARGS;
+/*---------------------------
+ * end Firmware
+ *---------------------------*/
+
+/****************************************************************************
+ *  
+ ****************************************************************************/
+
+#include "MegaRacDrvr.h"
+
+/* some drivers or APIs provide control of selected functionality at startup */
+
+#define MEGARAC_SUPPORT_CURSOR      0x0001      /* software cursor position */
+#define MEGARAC_SUPPORT_FTP         0x0002      /* file transfer */
+#define MEGARAC_SUPPORT_SHUTDOWN    0x0004      /* handle OS restart */
+
+
+typedef struct {
+    CCB_Header  ccb;
+    char        data[1];
+} DC_INFO_TYPE;
+
+typedef enum {
+    megaRacIoctlRcs,
+    megaRacIoctlGraphic,
+    megaRacIoctlReset,
+    megaRacIoctlInternal,
+    megaRacIoctlEvent
+} MegaRacIoctl;
+
+typedef enum {                              /* see MegaRacFlashUpdate() */
+    MegaRacFlashUpdateNone,
+    MegaRacFlashUpdateIgnoreVersionAge   = 0x01,
+    MegaRacFlashUpdateSkipReset          = 0x02,
+    MegaRacFlashUpdateEraseSDK           = 0x04
+} MegaRacFlashUpdateOptions;
+
+/* if an error occurs during API processing,
+   one of the MEGARAC_ERR_* is returned (without the upper bit set).
+   If the firmware returns an error in ccb.status,
+   then MEGARAC_ERR_ERROR is or'ed with the ccb.status (setting the upper bit)
+   and the resulting value is returned as a typedef'ed MEGARAC_ERROR */
+typedef enum {
+    MEGARAC_ERR_NONE,
+    MEGARAC_ERR_NOT_SUPPORTED,
+    MEGARAC_ERR_FAILED,
+    MEGARAC_ERR_BAD_HANDLE,
+    MEGARAC_ERR_DEAD,
+    MEGARAC_ERR_FLASH_IN_PROGRESS,          /* special case, see MegaRacFlashUpdate() */
+    MEGARAC_ERR_FLASH_NO_RESOURCES,
+    MEGARAC_ERR_FLASH_IMAGE_FILE_NOT_FOUND,
+    MEGARAC_ERR_FLASH_IMAGE_FILE_CHECKSUM,
+    MEGARAC_ERR_FLASH_IMAGE_FILE_SIZE,
+    MEGARAC_ERR_FLASH_IMAGE_FILE_ACCESS,
+    MEGARAC_ERR_FLASH_IMAGE_FILE_AGE,
+    MEGARAC_ERR_FLASH_FIRMWARE_ACCESS,
+    MEGARAC_ERR_FIRMWARE_LOGIC,
+    MEGARAC_ERR_FLASH_SDK_FILE
+} MEGARAC_ERROR;
+
+#if UINT_MAX>0x0000ffff 
+    #define MEGARAC_ERR_ERROR 0x80000000    /* ccb.Status or'd in */
+#else
+    #define MEGARAC_ERR_ERROR 0x8000
+#endif
+
+
+typedef void* MEGARAC_HANDLE;
+#define MEGARAC_INVALID_HANDLE ((MEGARAC_HANDLE)(-1))
+
+    /* group 0 */
+extern MEGARAC_ERROR MegaRacGetFirmwareVersion   ( MEGARAC_HANDLE handle, GET_VERSION_TYPE                      *pCAM );
+extern MEGARAC_ERROR MegaRacGetInfo              ( MEGARAC_HANDLE handle, GET_MEGARAC_INFO_TYPE                 *pCAM );
+extern MEGARAC_ERROR MegaRacGetTotalEvents       ( MEGARAC_HANDLE handle, RCS_FN_GET_TOTAL_NO_OF_EVENTS_ARGS    *pCAM );
+extern MEGARAC_ERROR MegaRacGetRecentEvents      ( MEGARAC_HANDLE handle, RCS_FN_GET_MOST_RECENT_N_EVENTS_ARGS  *pCAM );
+extern MEGARAC_ERROR MegaRacGetOldestEvents      ( MEGARAC_HANDLE handle, RCS_FN_GET_MOST_OLD_N_EVENTS_ARGS     *pCAM );
+extern MEGARAC_ERROR MegaRacClearEvents          ( MEGARAC_HANDLE handle );
+extern MEGARAC_ERROR MegaRacGetCurrentPostLog    ( MEGARAC_HANDLE handle, RCS_FN_GET_CURRENT_POST_LOG_ARGS      *pCAM );
+extern MEGARAC_ERROR MegaRacGetAllPostLogs       ( MEGARAC_HANDLE handle, RCS_FN_GET_CURRENT_POST_LOG_ARGS      *pCAM );
+extern MEGARAC_ERROR MegaRacClearAllPostLogs     ( MEGARAC_HANDLE handle );
+    /* group 1 */
+extern MEGARAC_ERROR MegaRacGetDmi               ( MEGARAC_HANDLE handle, RCS_FN_GET_DMI_INFO_ARGS              *pCAM );
+extern MEGARAC_ERROR MegaRacGetIpmi              ( MEGARAC_HANDLE handle, RCS_FN_GET_IPMI_INFO_ARGS             *pCAM );
+extern MEGARAC_ERROR MegaRacReportDmi            ( MEGARAC_HANDLE handle );
+extern MEGARAC_ERROR MegaRacGetOsStatus          ( MEGARAC_HANDLE handle, RCS_FN_GET_OS_STATUS_ARGS             *pCAM );
+extern MEGARAC_ERROR MegaRacGetHostStatus        ( MEGARAC_HANDLE handle, RCS_FN_GET_HOST_STATUS_ARGS           *pCAM );
+extern MEGARAC_ERROR MegaRacGetGenericData       ( MEGARAC_HANDLE handle, RCS_FN_GET_GENERIC_DATA_ARGS          *pCAM );
+extern MEGARAC_ERROR MegaRacReportGenericData    ( MEGARAC_HANDLE handle, RCS_FN_REPORT_GENERIC_DATA_ARGS       *pCAM );
+    /* group 2 */
+extern MEGARAC_ERROR MegaRacGetBattery           ( MEGARAC_HANDLE handle, GET_BAT_STATUS_TYPE                   *pCAM );
+    /* group 3 */
+extern MEGARAC_ERROR MegaRacGetHhfNumber         ( MEGARAC_HANDLE handle, GET_NUM_CATEGORY_TYPE                 *pCAM );
+extern MEGARAC_ERROR MegaRacGetHhfName           ( MEGARAC_HANDLE handle, GET_CATEGORY_NAME_TYPE                *pCAM );
+extern MEGARAC_ERROR MegaRacGetHhfSubDiv         ( MEGARAC_HANDLE handle, GET_NUM_SUBDIVISIONS_TYPE             *pCAM );
+extern MEGARAC_ERROR MegaRacGetHhfSubDivName     ( MEGARAC_HANDLE handle, GET_SUBDIV_NAME_TYPE                  *pCAM );
+extern MEGARAC_ERROR MegaRacGetHhfValue          ( MEGARAC_HANDLE handle, GET_HHF_VALUE_TYPE                    *pCAM );
+extern MEGARAC_ERROR MegaRacGetSdkCategories     ( MEGARAC_HANDLE handle, SDK_GET_NUM_CATEGORY_TYPE             *pCAM );
+extern MEGARAC_ERROR MegaRacGetSdkCategoryName   ( MEGARAC_HANDLE handle, SDK_GET_CATEGORY_NAME_TYPE            *pCAM );
+extern MEGARAC_ERROR MegaRacGetSdkSubdivisions   ( MEGARAC_HANDLE handle, SDK_GET_NUM_SUBDIVISIONS_TYPE         *pCAM );
+extern MEGARAC_ERROR MegaRacGetSdkSubdivisionName( MEGARAC_HANDLE handle, SDK_GET_SUBDIV_NAME_TYPE              *pCAM );
+extern MEGARAC_ERROR MegaRacGetSdkValue          ( MEGARAC_HANDLE handle, GET_SDK_VALUE_TYPE                    *pCAM );
+extern MEGARAC_ERROR MegaRacGetSdkConfiguration  ( MEGARAC_HANDLE handle, SDK_CONFIG_TYPE                       *pCAM );
+extern MEGARAC_ERROR MegaRacModifySdkConfiguration(MEGARAC_HANDLE handle, SDK_CONFIG_TYPE                       *pCAM );
+extern MEGARAC_ERROR MegaRacI2cRepeatedStartAccess(MEGARAC_HANDLE handle, I2C_REPEATED_START_WITH_STATUS_TYPE   *pCAM );
+    /* group 4 */
+extern MEGARAC_ERROR MegaRacShutdownHost         ( MEGARAC_HANDLE handle );
+extern MEGARAC_ERROR MegaRacResetHost            ( MEGARAC_HANDLE handle );
+extern MEGARAC_ERROR MegaRacPowerCycleHost       ( MEGARAC_HANDLE handle );
+extern MEGARAC_ERROR MegaRacPowerOnOffHost       ( MEGARAC_HANDLE handle, RCS_FN_POWER_ON_OFF_WITH_DELAY_ARGS     *pCAM );
+extern MEGARAC_ERROR MegaRacResetHostDelay       ( MEGARAC_HANDLE handle, RCS_FN_RESET_HOST_AFTER_DELAY_ARGS      *pCAM );
+extern MEGARAC_ERROR MegaRacPowerCycleHostDelay  ( MEGARAC_HANDLE handle, RCS_FN_POWERCYCLE_HOST_AFTER_DELAY_ARGS *pCAM );
+extern MEGARAC_ERROR MegaRacPowerOnOffHostDelay  ( MEGARAC_HANDLE handle, RCS_FN_POWER_ON_OFF_WITH_DELAY_ARGS     *pCAM );
+extern MEGARAC_ERROR MegaRacReportIoBaseAddress  ( MEGARAC_HANDLE handle, RCS_FN_REPORT_IO_BASE_ADDRESS_ARGS      *pCAM );
+    /* group 6 */
+extern MEGARAC_ERROR MegaRacEvent                ( MEGARAC_HANDLE handle, RCS_FN_LOG_EVENT_ARGS         *pCAM );
+extern MEGARAC_ERROR MegaRacAlert                ( MEGARAC_HANDLE handle, RCS_FN_SEND_ALERT_ARGS        *pCAM );
+    /* group 7 */
+extern MEGARAC_ERROR MegaRacStartHeartbeat       ( MEGARAC_HANDLE handle, RCS_FN_START_HEARTBEAT_ARGS   *pCAM );
+extern MEGARAC_ERROR MegaRacStopHeartbeat        ( MEGARAC_HANDLE handle );
+    /* group 20 */
+extern MEGARAC_ERROR MegaRacReadKey              ( MEGARAC_HANDLE handle, KeyData       *pCAM );
+extern MEGARAC_ERROR MegaRacSendDcInfo           ( MEGARAC_HANDLE handle, DC_INFO_TYPE  *pCAM );
+extern MEGARAC_ERROR MegaRacSendDcPacket         ( MEGARAC_HANDLE handle, DC_INFO_TYPE  *pCAM );
+extern MEGARAC_ERROR MegaRacReadMouseEvent       ( MEGARAC_HANDLE handle, DC_INFO_TYPE  *pCAM );
+extern MEGARAC_ERROR MegaRacIDoReadYou           ( MEGARAC_HANDLE handle );
+    /* group 21 */
+extern MEGARAC_ERROR MegaRacFileTransfer         ( MEGARAC_HANDLE handle );
+extern MEGARAC_ERROR MegaRacSendToRemote         ( MEGARAC_HANDLE handle, DC_INFO_TYPE  *pCAM );
+extern MEGARAC_ERROR MegaRacReadFromRemote       ( MEGARAC_HANDLE handle, DC_INFO_TYPE  *pCAM );
+extern MEGARAC_ERROR MegaRacReportCursorPosition ( MEGARAC_HANDLE handle, int row, int col );
+    /* group 40 */
+extern MEGARAC_ERROR MegaRacEnableHhfMonitor     ( MEGARAC_HANDLE handle, EN_DIS_HHF_MONITOR_TYPE   *pCAM );
+extern MEGARAC_ERROR MegaRacEnableHhfThreshold   ( MEGARAC_HANDLE handle, EN_DIS_HHF_THRES_TYPE     *pCAM );
+extern MEGARAC_ERROR MegaRacReadHhfThreshold     ( MEGARAC_HANDLE handle, HHF_THRES_TYPE            *pCAM );
+extern MEGARAC_ERROR MegaRacModifyHhfThreshold   ( MEGARAC_HANDLE handle, HHF_THRES_TYPE            *pCAM );
+extern MEGARAC_ERROR MegaRacReadHhfSchedule      ( MEGARAC_HANDLE handle, HHF_SCHED_TYPE            *pCAM );
+extern MEGARAC_ERROR MegaRacModifyHhfSchedule    ( MEGARAC_HANDLE handle, HHF_SCHED_TYPE            *pCAM );
+extern MEGARAC_ERROR MegaRacReadHhfMonitorState  ( MEGARAC_HANDLE handle, EN_DIS_HHF_MONITOR_TYPE   *pCAM );
+extern MEGARAC_ERROR MegaRacReadHhfThresholdState( MEGARAC_HANDLE handle, EN_DIS_HHF_THRES_TYPE     *pCAM );
+extern MEGARAC_ERROR MegaRacEnableSdkMonitor     ( MEGARAC_HANDLE handle, EN_DIS_SDK_MONITOR_TYPE   *pCAM );
+extern MEGARAC_ERROR MegaRacEnableSdkThreshold   ( MEGARAC_HANDLE handle, EN_DIS_SDK_THRES_TYPE     *pCAM );
+extern MEGARAC_ERROR MegaRacReadSdkThreshold     ( MEGARAC_HANDLE handle, SDK_THRES_TYPE            *pCAM );
+extern MEGARAC_ERROR MegaRacModifySdkThreshold   ( MEGARAC_HANDLE handle, SDK_THRES_TYPE            *pCAM );
+extern MEGARAC_ERROR MegaRacReadSdkSchedule      ( MEGARAC_HANDLE handle, SDK_SCHED_TYPE            *pCAM );
+extern MEGARAC_ERROR MegaRacModifySdkSchedule    ( MEGARAC_HANDLE handle, SDK_SCHED_TYPE            *pCAM );
+extern MEGARAC_ERROR MegaRacReadSdkMonitorState  ( MEGARAC_HANDLE handle, EN_DIS_SDK_MONITOR_TYPE   *pCAM );
+extern MEGARAC_ERROR MegaRacReadSdkThresholdState( MEGARAC_HANDLE handle, EN_DIS_SDK_THRES_TYPE     *pCAM );
+    /* group 41 */
+extern MEGARAC_ERROR MegaRacAddAdministrator     ( MEGARAC_HANDLE handle, AdminEntry              *pCAM );
+extern MEGARAC_ERROR MegaRacReadAdministrator    ( MEGARAC_HANDLE handle, AdminEntry              *pCAM );
+extern MEGARAC_ERROR MegaRacDeleteAdministrator  ( MEGARAC_HANDLE handle, AdminEntry              *pCAM );
+extern MEGARAC_ERROR MegaRacModifyAdministrator  ( MEGARAC_HANDLE handle, AdminEntry              *pCAM );
+    /* group 42 */
+extern MEGARAC_ERROR MegaRacReadNetwork          ( MEGARAC_HANDLE handle, NET_CFG_TYPE            *pCAM );
+extern MEGARAC_ERROR MegaRacModifyNetwork        ( MEGARAC_HANDLE handle, NET_CFG_TYPE            *pCAM );
+extern MEGARAC_ERROR MegaRacReadModem            ( MEGARAC_HANDLE handle, MODEM_CFG_TYPE          *pCAM );
+extern MEGARAC_ERROR MegaRacModifyModem          ( MEGARAC_HANDLE handle, MODEM_CFG_TYPE          *pCAM );
+extern MEGARAC_ERROR MegaRacAddSnmpDestination   ( MEGARAC_HANDLE handle, SNMP_DEST_TYPE          *pCAM );
+extern MEGARAC_ERROR MegaRacReadSnmpDestination  ( MEGARAC_HANDLE handle, SNMP_DEST_TYPE          *pCAM );
+extern MEGARAC_ERROR MegaRacModifySnmpDestination( MEGARAC_HANDLE handle, SNMP_DEST_TYPE          *pCAM );
+extern MEGARAC_ERROR MegaRacDeleteSnmpDestination( MEGARAC_HANDLE handle, SNMP_DEST_TYPE          *pCAM );
+extern MEGARAC_ERROR MegaRacAddManagedConsole    ( MEGARAC_HANDLE handle, MGNT_CON_TYPE           *pCAM );
+extern MEGARAC_ERROR MegaRacReadManagedConsole   ( MEGARAC_HANDLE handle, MGNT_CON_TYPE           *pCAM );
+extern MEGARAC_ERROR MegaRacModifyManagedConsole ( MEGARAC_HANDLE handle, MGNT_CON_TYPE           *pCAM );
+extern MEGARAC_ERROR MegaRacDeleteManagedConsole ( MEGARAC_HANDLE handle, MGNT_CON_TYPE           *pCAM );
+extern MEGARAC_ERROR MegaRacReadAlertTable       ( MEGARAC_HANDLE handle, ALERT_ORDER_TABLE       *pCAM );
+extern MEGARAC_ERROR MegaRacModifyAlertTable     ( MEGARAC_HANDLE handle, ALERT_ORDER_TABLE       *pCAM );
+extern MEGARAC_ERROR MegaRacForceSaveConfig      ( MEGARAC_HANDLE handle );
+extern MEGARAC_ERROR MegaRacSendTestPage         ( MEGARAC_HANDLE handle, AdminEntry              *pCAM);
+    /* group 43 */
+extern MEGARAC_ERROR MegaRacReadPppConfig        ( MEGARAC_HANDLE handle, PPP_CFG_TYPE                   *pCAM );
+extern MEGARAC_ERROR MegaRacModifyPppConfig      ( MEGARAC_HANDLE handle, PPP_CFG_TYPE                   *pCAM );
+extern MEGARAC_ERROR MegaRacReadDialOutConfig    ( MEGARAC_HANDLE handle, DIALOUT_CFG_TYPE               *pCAM );
+extern MEGARAC_ERROR MegaRacModifyDialOutConfig  ( MEGARAC_HANDLE handle, DIALOUT_CFG_TYPE               *pCAM );
+extern MEGARAC_ERROR MegaRacReadTcpIpConfig      ( MEGARAC_HANDLE handle, RCS_TCPIP_CFG                  *pCAM );
+extern MEGARAC_ERROR MegaRacModifyTcpIpConfig    ( MEGARAC_HANDLE handle, RCS_TCPIP_CFG                  *pCAM );
+extern MEGARAC_ERROR MegaRacReadDhcpConfig       ( MEGARAC_HANDLE handle, RCS_DHCP_CFG                   *pCAM );
+extern MEGARAC_ERROR MegaRacModifyDhcpConfig     ( MEGARAC_HANDLE handle, RCS_DHCP_CFG                   *pCAM );
+extern MEGARAC_ERROR MegaRacReadAdminMailID      ( MEGARAC_HANDLE handle, RCS_ADMIN_MAIL_ID_PKT          *pCAM );
+extern MEGARAC_ERROR MegaRacModifyAdminMailID    ( MEGARAC_HANDLE handle, RCS_ADMIN_MAIL_ID_PKT          *pCAM );
+extern MEGARAC_ERROR MegaRacReadMailServerIP     ( MEGARAC_HANDLE handle, RCS_ADMIN_MAIL_SERVER_IP_PKT   *pCAM );
+extern MEGARAC_ERROR MegaRacModifyMailServerIP   ( MEGARAC_HANDLE handle, RCS_ADMIN_MAIL_SERVER_IP_PKT   *pCAM );
+extern MEGARAC_ERROR MegaRacSendTestEmail        ( MEGARAC_HANDLE handle, RCS_TEST_EMAIL_ARGS            *pCAM );
+    /* group 44 */
+extern MEGARAC_ERROR MegaRacSetAdminHourMask     ( MEGARAC_HANDLE handle, RCS_ADMIN_HOURLY_MASKS_PKT     *pCAM );
+extern MEGARAC_ERROR MegaRacGetAdminHourMask     ( MEGARAC_HANDLE handle, RCS_ADMIN_HOURLY_MASKS_PKT     *pCAM );
+extern MEGARAC_ERROR MegaRacSetSnmpSeverityMask  ( MEGARAC_HANDLE handle, RCS_SNMP_SEVERITY_MASKS_PKT    *pCAM );
+extern MEGARAC_ERROR MegaRacGetSnmpSeverityMask  ( MEGARAC_HANDLE handle, RCS_SNMP_SEVERITY_MASKS_PKT    *pCAM );
+extern MEGARAC_ERROR MegaRacSetManConSeverityMask( MEGARAC_HANDLE handle, RCS_MGNTCON_SEVERITY_MASKS_PKT *pCAM );
+extern MEGARAC_ERROR MegaRacGetManConSeverityMask( MEGARAC_HANDLE handle, RCS_MGNTCON_SEVERITY_MASKS_PKT *pCAM );
+    /* group 45 */
+extern MEGARAC_ERROR MegaRacReadMiscConfig            ( MEGARAC_HANDLE handle, MISC_CFG_TYPE             *pCAM );
+extern MEGARAC_ERROR MegaRacModifyMiscConfig          ( MEGARAC_HANDLE handle, MISC_CFG_TYPE             *pCAM );
+extern MEGARAC_ERROR MegaRacReadAutoRecoveryConfig    ( MEGARAC_HANDLE handle, RCS_AUTO_RECOVERY_CFG     *pCAM );
+extern MEGARAC_ERROR MegaRacModifyAutoRecoveryConfig  ( MEGARAC_HANDLE handle, RCS_AUTO_RECOVERY_CFG     *pCAM );
+extern MEGARAC_ERROR MegaRacReadTerminalServerConfig  ( MEGARAC_HANDLE handle, RCS_TERMINAL_SERVER_CFG   *pCAM );
+extern MEGARAC_ERROR MegaRacModifyTerminalServerConfig( MEGARAC_HANDLE handle, RCS_TERMINAL_SERVER_CFG   *pCAM );
+    /* group 46 */
+extern MEGARAC_ERROR MegaRacResetCardSoft         ( MEGARAC_HANDLE handle );
+extern MEGARAC_ERROR MegaRacShutdownCard          ( MEGARAC_HANDLE handle );
+extern MEGARAC_ERROR MegaRacResetBatteryCharge    ( MEGARAC_HANDLE handle );
+extern MEGARAC_ERROR MegaRacSetDateTime           ( MEGARAC_HANDLE handle, DATE_TIME *pCAM );
+extern MEGARAC_ERROR MegaRacGetDateTime           ( MEGARAC_HANDLE handle, DATE_TIME *pCAM );
+extern MEGARAC_ERROR MegaRacRestoreFactoryDefaults( MEGARAC_HANDLE handle );
+    /* group 47 */
+extern MEGARAC_ERROR MegaRacFlashUpdate         ( MEGARAC_HANDLE handle, 
+                                                          MegaRacFlashUpdateOptions     options, 
+                                                          char                         *filenameImage, 
+                                                          char                         *filenameSDK, 
+                                                          unsigned long                *flashExtStatus,
+                                                          MEGARAC_ERROR                *mrStatus );
+extern MEGARAC_ERROR MegaRacFlashGetVersion     ( MEGARAC_HANDLE handle, FwVer *romVer,
+                                                                                 char  *filename,
+                                                                                 FwVer *fileVer );
+extern MEGARAC_ERROR MegaRacFlashGetFileSize    (  char  *filename, unsigned long *fileSize );
+    /* group 48 */
+extern MEGARAC_ERROR MegaRacReadSnmpServerConfig ( MEGARAC_HANDLE handle, RCS_SNMPSERVER_CONFIG_PKT *pCAM );
+extern MEGARAC_ERROR MegaRacModifySnmpServerConfig(MEGARAC_HANDLE handle, RCS_SNMPSERVER_CONFIG_PKT *pCAM );
+    /* group 80 */
+extern MEGARAC_ERROR MegaRacDiagReadByte        ( MEGARAC_HANDLE handle, RCS_DIAG_RW_BYTE_ARGS      *pCAM );
+extern MEGARAC_ERROR MegaRacDiagWriteByte       ( MEGARAC_HANDLE handle, RCS_DIAG_RW_BYTE_ARGS      *pCAM );
+extern MEGARAC_ERROR MegaRacDiagReadWord        ( MEGARAC_HANDLE handle, RCS_DIAG_RW_WORD_ARGS      *pCAM );
+extern MEGARAC_ERROR MegaRacDiagWriteWord       ( MEGARAC_HANDLE handle, RCS_DIAG_RW_WORD_ARGS      *pCAM );
+extern MEGARAC_ERROR MegaRacDiagReadDword       ( MEGARAC_HANDLE handle, RCS_DIAG_RW_DWORD_ARGS     *pCAM );
+extern MEGARAC_ERROR MegaRacDiagWriteDword      ( MEGARAC_HANDLE handle, RCS_DIAG_RW_DWORD_ARGS     *pCAM );
+extern MEGARAC_ERROR MegaRacDiagDumpBlock       ( MEGARAC_HANDLE handle, RCS_DIAG_DUMP_BLOCK_ARGS   *pCAM );
+extern MEGARAC_ERROR MegaRacDiagScanMemory      ( MEGARAC_HANDLE handle, RCS_DIAG_SCAN_MEMORY_ARGS  *pCAM );
+extern MEGARAC_ERROR MegaRacDiagForceFail       ( MEGARAC_HANDLE handle, RCS_DIAG_FORCE_FAIL_ARGS   *pCAM );
+    /* group 100 */
+extern MEGARAC_ERROR MegaRacDebugSwitchVideoPrint( MEGARAC_HANDLE handle, RCS_DBG_SWITCH_VIDEO_PRINT_ARGS       *pCAM );
+extern MEGARAC_ERROR MegaRacDebugSetVideoMode    ( MEGARAC_HANDLE handle, RCS_DBG_SET_VIDEO_DEBUG_MODE_ARGS     *pCAM );
+extern MEGARAC_ERROR MegaRacGetLatestErrorLog    ( MEGARAC_HANDLE handle, RCS_DBG_GET_LATEST_ERROR_LOG_ARGS     *pCAM );
+extern MEGARAC_ERROR MegaRacGetErrorLogEntries   ( MEGARAC_HANDLE handle, RCS_DBG_GET_ERROR_LOG_ENTRIES_ARGS    *pCAM );
+extern MEGARAC_ERROR MegaRacGetCheckPointHeader  ( MEGARAC_HANDLE handle, RCS_DBG_GET_CHECKPT_HEADER_ARGS       *pCAM );
+extern MEGARAC_ERROR MegaRacClearCheckPointLog   ( MEGARAC_HANDLE handle );
+extern MEGARAC_ERROR MegaRacGetNumberOfModules   ( MEGARAC_HANDLE handle, RCS_DBG_GET_NO_OF_MODULES_ARGS        *pCAM );
+extern MEGARAC_ERROR MegaRacGetModuleNames       ( MEGARAC_HANDLE handle, RCS_DBG_GET_MODULE_NAMES_ARGS         *pCAM );
+extern MEGARAC_ERROR MegaRacGetDescriptiveStrings( MEGARAC_HANDLE handle, RCS_DBG_GET_DESC_STRINGS_ARGS         *pCAM );
+extern MEGARAC_ERROR MegaRacDebugSetMasks        ( MEGARAC_HANDLE handle, RCS_DBG_SET_DBGPRINT_MASKS_ARGS       *pCAM );
+extern MEGARAC_ERROR MegaRacClearVideoScreen     ( MEGARAC_HANDLE handle );
+    /* group 800, RCS_USR */ 
+extern MEGARAC_ERROR MegaRacGetEsmInfo          ( MEGARAC_HANDLE handle, GET_ESMII_INFO_DATA                    *pCAM );
+extern MEGARAC_ERROR MegaRacGetEsmEventLog      ( MEGARAC_HANDLE handle, RCS_USR_GET_ESMII_EVENT_LOG_ARGS       *pCAM );
+extern MEGARAC_ERROR MegaRacGetEsmPostLog       ( MEGARAC_HANDLE handle, RCS_USR_GET_ESMII_POST_LOG_ARGS        *pCAM );
+extern MEGARAC_ERROR MegaRacScanEsm             ( MEGARAC_HANDLE handle, RCS_USR_SCAN_FOR_ESMIIS_ARGS           *pCAM );
+extern MEGARAC_ERROR MegaRacSendEsmCommand      ( MEGARAC_HANDLE handle, RCS_USR_SEND_COMMAND_TO_ESMII_ARGS     *pCAM );
+extern MEGARAC_ERROR MegaRacReadEsmConfig       ( MEGARAC_HANDLE handle, RCS_USR_CONFIG_ESMII_ARGS              *pCAM );
+extern MEGARAC_ERROR MegaRacModifyEsmConfig     ( MEGARAC_HANDLE handle, RCS_USR_CONFIG_ESMII_ARGS              *pCAM );
+extern MEGARAC_ERROR MegaRacDumpEsmEventLog     ( MEGARAC_HANDLE handle, RCS_USR_GET_ESMII_EVENT_LOG_ARGS       *pCAM );
+extern MEGARAC_ERROR MegaRacDumpEsmPostLog      ( MEGARAC_HANDLE handle, RCS_USR_GET_ESMII_POST_LOG_ARGS        *pCAM );
+extern MEGARAC_ERROR MegaRacGetNumberEsm        ( MEGARAC_HANDLE handle, RCS_USR_CONFIG_ESMII_ARGS              *pCAM );
+extern MEGARAC_ERROR MegaRacGetEsmServerInfo    ( MEGARAC_HANDLE handle, RCS_USR_GET_SERVER_INFO_ARGS           *pCAM );
+extern MEGARAC_ERROR MegaRacClearEsmEventLog    ( MEGARAC_HANDLE handle, RCS_USR_CLEAR_ESMII_EVENT_LOG_ARGS     *pCAM );
+extern MEGARAC_ERROR MegaRacClearEsmPostLog     ( MEGARAC_HANDLE handle, RCS_USR_CLEAR_ESMII_POST_LOG_ARGS      *pCAM );
+extern MEGARAC_ERROR MegaRacGetUserAlertSeverity( MEGARAC_HANDLE handle, RCS_USR_GET_GLOBAL_ALERT_SEVERITY_ARGS *pCAM );
+extern MEGARAC_ERROR MegaRacReportServerInfo    ( MEGARAC_HANDLE handle, RCS_USR_REPORT_SERVER_INFO_ARGS        *pCAM );
+    /* group 801, RCS_USR */
+extern MEGARAC_ERROR MegaRacReportHostInfo      ( MEGARAC_HANDLE handle, RCS_USR_REPORT_HOST_INFO_ARGS           *pCAM );
+extern MEGARAC_ERROR MegaRacGetHostInfo         ( MEGARAC_HANDLE handle, RCS_USR_GET_HOST_INFO_ARGS              *pCAM );
+extern MEGARAC_ERROR MegaRacGetCurrentEsmPostLog( MEGARAC_HANDLE handle, RCS_USR_GET_CURRENT_ESMII_POST_LOG_ARGS *pCAM );
+extern MEGARAC_ERROR MegaRacGetAllEsmPostLogs   ( MEGARAC_HANDLE handle, RCS_USR_GET_ALL_ESMII_POST_LOGS_ARGS    *pCAM );
+extern MEGARAC_ERROR MegaRacClearAllEsmPostLogs ( MEGARAC_HANDLE handle );
+    /* group 804, RCS_USR */
+extern MEGARAC_ERROR MegaRacGetIpmiEventLog     ( MEGARAC_HANDLE handle, RCS_USR_GET_IPMI_EVENT_LOG_ARGS        *pCAM );
+extern MEGARAC_ERROR MegaRacClearIpmiEventLog   ( MEGARAC_HANDLE handle, RCS_USR_CLEAR_IPMI_EVENT_LOG_ARGS      *pCAM );
+extern MEGARAC_ERROR MegaRacGetSdrRecord        ( MEGARAC_HANDLE handle, RCS_USR_SDR_RECORD_ARGS                *pCAM );
+extern MEGARAC_ERROR MegaRacGetFruInfo          ( MEGARAC_HANDLE handle, RCS_USR_ALT_GET_FRU_DATA_ARGS          *pCAM );
+extern MEGARAC_ERROR MegaRacRescanFru           ( MEGARAC_HANDLE handle, RCS_USR_ALT_RESCAN_FRU_DATA_ARGS       *pCAM );
+extern MEGARAC_ERROR MegaRacStartStopIpmiMonitor( MEGARAC_HANDLE handle, RCS_USR_ALT_START_STOP_IPMI_MON_ARGS   *pCAM );
+extern MEGARAC_ERROR MegaRacDumpIpmiSdr         ( MEGARAC_HANDLE handle, RCS_USR_ALT_DUMP_SDR_RECORDS_ARGS      *pCAM );
+    /* group internal to MegaRacDLL */
+//#define                      MEGARAC_API_CMD_OS_RESTART     0xfff8
+#define                      MEGARAC_API_CMD_WAIT_EVENTS    0xfff9 
+#define                      MEGARAC_API_CMD_ATTACHMENTS    0xfffa  /* internal (static) to API */
+#define                      MEGARAC_API_CMD_ISSUE_CMD      0xfffb
+#define                      MEGARAC_API_CMD_GET_REG        0xfffc
+#define                      MEGARAC_API_CMD_SET_EVENTS     0xfffd
+#define                      MEGARAC_CMD_RESET_HARD         0xfffe
+//extern MEGARAC_ERROR MegaRacOsRestart           ( MEGARAC_HANDLE handle );
+extern MEGARAC_ERROR MegaRacWaitEvents          ( MEGARAC_HANDLE handle, RAC_EVENT_NOTIFICATION *pCAM );
+extern MEGARAC_ERROR MegaRacSetEvents           ( MEGARAC_HANDLE handle, RAC_EVENT_NOTIFICATION *pCAM );
+extern MEGARAC_ERROR MegaRacResetCardHard       ( MEGARAC_HANDLE handle );
+extern MEGARAC_ERROR MegaRacIsCardAlive         ( MEGARAC_HANDLE handle );
+extern void          MegaRacKludgeLoop          ( int doCursor, int doFtp );
+
+/*------------------------------------------------------
+ * for MegaRacCAM.c, mostly caused by old MegaRacApi.h
+ *-----------------------------------------------------*/
+
+typedef struct  _MEGARAC_INFO {
+    unsigned char   cpuDescr[30]; 
+    unsigned char   cpuSpeed[8];
+    unsigned char   memSize[8]; 
+    unsigned char   romSize[8]; 
+    unsigned char   nvramSize[8];
+    unsigned char   pciBridge[30];
+    unsigned char   networkController[30];
+    unsigned char   modemType;
+    unsigned char   pcmciaHostAdapter[30];
+    unsigned char   pcCardManufacturer[30];
+    unsigned char   pcCardProductName[30];
+    unsigned char   battery[30];
+    unsigned char   fwMajorNum;
+    unsigned char   fwMinorNum;
+    unsigned char   fwBuildDate[12];
+    unsigned short  voltCount;
+    unsigned short  tempCount;
+    unsigned short  fanCount;
+    unsigned short  switchCount;
+    unsigned short  faultCount;
+    unsigned char   ethernetAddress[18];
+    MEGARAC_HANDLE  handle;     
+    unsigned char   rsvd[64];
+} MEGARAC_INFO;
+
+typedef struct _MEGARAC_VARIABLE  {
+    unsigned short  index;
+    unsigned short  type;     
+    unsigned char   descr[32];
+    unsigned char   reading[32];  
+    unsigned char   unit[16];
+    unsigned char   limitLowAlert[32];
+    unsigned char   limitHighAlert[32];
+    unsigned char   limitLowWarn[32];
+    unsigned char   limitHighWarn[32];
+             long   rsvd[32];
+} MEGARAC_VAR;
+
+#define MEGARAC_MAX_VARIABLES  32
+typedef struct _MEGARAC_VARS {
+    unsigned short  count;
+    MEGARAC_VAR     var[MEGARAC_MAX_VARIABLES];
+} MEGARAC_VARS;
+
+typedef struct _MEGARAC_ALERT_CONFIG  {
+    unsigned char   index;
+    unsigned char   sendIPAddr[4];
+    unsigned char   sendCommunity[64];
+    unsigned char   callbackNumber[32];
+} MEGARAC_ALERT_CONFIG;
+
+extern MEGARAC_ERROR MegaRacHhfFindCat    ( MEGARAC_HANDLE handle,                           char         *cat, unsigned char *catIndex );
+extern MEGARAC_ERROR MegaRacHhfFindSub    ( MEGARAC_HANDLE handle, int             category, char         *sub, unsigned char *subIndex );
+extern MEGARAC_ERROR MegaRacGetVolts      ( MEGARAC_HANDLE handle, int             count,    MEGARAC_VARS *pOut );
+extern MEGARAC_ERROR MegaRacGetVolt       ( MEGARAC_HANDLE handle, int             index,    MEGARAC_VAR  *pOut);
+extern MEGARAC_ERROR MegaRacSetVolt       ( MEGARAC_HANDLE handle, MEGARAC_VAR    *pIn );
+extern MEGARAC_ERROR MegaRacGetTemps      ( MEGARAC_HANDLE handle, int             count,    MEGARAC_VARS *pOut );
+extern MEGARAC_ERROR MegaRacGetTemp       ( MEGARAC_HANDLE handle, int             index,    MEGARAC_VAR  *pOut );
+extern MEGARAC_ERROR MegaRacSetTemp       ( MEGARAC_HANDLE handle, MEGARAC_VAR    *pIn );
+extern MEGARAC_ERROR MegaRacGetInformation( MEGARAC_HANDLE handle, MEGARAC_INFO         *pInfo ); 
+extern MEGARAC_ERROR MegaRacGetAlertConfig( MEGARAC_HANDLE handle, MEGARAC_ALERT_CONFIG *pAlert );
+extern MEGARAC_ERROR MegaRacSetAlertConfig( MEGARAC_HANDLE handle, MEGARAC_ALERT_CONFIG *pAlert );
+
+
+#pragma pack()
+
+#endif /* MEGA_RAC_DLL_H */
diff -urNp linux-5000/drivers/addon/megarac/MegaRacDrvr.h linux-5010/drivers/addon/megarac/MegaRacDrvr.h
--- linux-5000/drivers/addon/megarac/MegaRacDrvr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/MegaRacDrvr.h	
@@ -0,0 +1,227 @@
+/*****************************************************************************
+ *
+ *  MegaRacDrvr.h : MegaRac device driver definitions
+ *
+ ****************************************************************************/
+#ifndef MEGARAC_DRIVER_H
+#define MEGARAC_DRIVER_H
+
+/****************************************************************
+ * firmware include files - pack all structures in these files
+ ***************************************************************/
+#pragma pack(1)                             /* supported by all current compilers */
+
+#include "agpintfc.h"
+#include "ccbhdlr.h"                 
+#include "dmi.h"
+#include "errcod.h"                 
+#include "mg90xx.h"
+#include "misc.h"
+#include "rcsadmin.h"                 
+#include "rcsic.h"                 
+#include "redirect.h"                 
+
+#pragma pack()
+
+/*****************************************************************************
+ * make determination about what is being compiled 
+ ****************************************************************************/
+#include "MegaRacWho.h"
+
+/*****************************************************************************
+ *
+ *  For Driver development, each MegaRacDrvr*.[ch] must
+ *  define the following macros (the following are Netware examples):
+ *      #define MEMSET( dst,val,cnt)                        CSetB( val, dst, cnt )
+ *      #define MEMZERO(dst,cnt)                            CSetB( 0,   dst, cnt )
+ *      #define MEMCPY( dst,src,cnt)                        CMovB( src, dst, cnt )
+ *      #define MALLOC_CONTIGUOUS(raci,ptr,cnt)             ...too complicated...
+ *      #define   FREE_CONTIGUOUS(raci,ptr)                 NPA_Return_Memory( raci pOsInfo->npaHandle, ptr )
+ *      #define VIRTUAL_TO_PHYSICAL(raci,physAddr,virtAddr) physAddr = (void*)MapDataOffsetToAbsoluteAddress(virtAddr)
+ *      #define MICRO_SECOND_DELAY(cnt)                     NPA_Micro_Delay( cnt )
+ *      #define  READ_RAC_UCHAR(raci,addr)                   In8( raci pOsInfo->busTag, raci addr )
+ *      #define  READ_RAC_ULONG(raci,addr)                  In32( raci pOsInfo->busTag, raci addr )
+ *      #define WRITE_RAC_UCHAR(raci,addr,val)              Out8( raci pOsInfo->busTag, raci addr, val )
+ *      #define WRITE_RAC_ULONG(raci,addr,val)             Out32( raci pOsInfo->busTag, raci addr, val )
+ *
+ ****************************************************************************/
+
+/*******************************************
+ * driver debug masks, see MegaRacDebug.h
+ ******************************************/
+#define MEGA_ENTRY          0x0001
+#define MEGA_ISR            0x0002
+#define MEGA_DPCISR         0x0004
+#define MEGA_STARTIO        0x0008
+#define MEGA_TIMEOUT        0x0010
+#define MEGA_DEVICE         0x0020
+#define MEGA_EXIT           0x0040
+#define MEGA_EVENT          0x0080
+#define MEGA_INSIDE_ISR     0x0100
+#define MEGA_CURSOR         0x0200
+#define MEGA_POLL_MODE  0x00020000
+
+/*******************************************
+ * common driver structures
+ ******************************************/
+
+typedef enum {                              /* for use with racEvent() */
+    racEventOpen                    = -3,   /*****open and close not currently used*********/
+    racEventClose,
+    racEventBoardDead,                      /* 07.12.99, Jose says: not used */
+    racEventFirmwareRequest,                /* raw RAC_INFO.firmwareRequest* to process  */
+    /* the following must match #define's in firmware/redirect.h */
+    racEventGetDCInfo               = 1,    
+    racEventGetDCPacket_X,                  /* =2, Jose says: not used */
+    racEventSendDCComplete,
+    racEventSendKey,                        /* =4, Jose says: not used */
+    racEventSendMouse,
+    racEventSendAlertToHost,                /* =6, Jose says: not used */
+    racEventRequestHostOsShutdown,
+    racEventModeChangedToGraphics,          /* =8, Jose says: not used */
+    racEventServiceDYRM,
+    racEventPassThruData,
+    racEventCursorChange,                   /* internal to driver/api */
+    racEventMaximum = racEventCursorChange  /* remember to update when adding events!!!! */
+} RAC_EVENT;
+
+typedef enum {                              /* see racPreProcessCCB() */
+    racDrvrErrNone,
+    racDrvrErrPending,
+    racDrvrErrInvalidParameter,
+    racDrvrErrNotImplemented
+} RAC_DRVR_ERR;
+
+typedef struct {                            /* see MegaRacSetEvents() and MegaRacWaitEvents() */
+    unsigned long eventHandle[racEventMaximum+1];
+} RAC_EVENT_NOTIFICATION;
+#define RAC_EVENT_NOTIFICATION_NO_CHANGE    ( 0)
+#define RAC_EVENT_NOTIFICATION_DELETE       (~0)
+
+typedef enum {
+        RAC_ATTACHMENTS_CMD_CUR,            /* get current value without any changes */
+        RAC_ATTACHMENTS_CMD_INC,
+        RAC_ATTACHMENTS_CMD_DEC
+} RAC_ATTACHMENTS_CMD;
+
+typedef struct {                            /* see MegaRacAttachments() */
+    RAC_ATTACHMENTS_CMD         cmd;
+    unsigned long               previous;
+    unsigned long               currentt;   /* if correctly spelled ("current") then */
+} RAC_ATTACHMENTS;                          /* ...linux smp driver complains */
+
+typedef struct _RAC_INFO {
+    struct _RAC_OS_INFO        *pOsInfo;
+    unsigned char              *portAddrBase;
+    unsigned char              *portAddrHIMR;
+    unsigned char              *portAddrHIFR;
+    unsigned char              *portAddrHCMDR;
+    unsigned long              *portAddrDATA;
+    unsigned char              *portAddrHASR;
+    unsigned char              *portAddrHFR;
+    unsigned char              *portAddrHCR;
+    CCB_Header                 *currentCCB;
+    BOOL                        resetInProgress;
+    BOOL                        specialModeInProgress;
+    BOOL                        shutDownIssued;
+    BOOL                        heartbeatStarted;
+    BOOL                        okToProcessRCS;
+    unsigned int                heartbeatCount;
+    unsigned int                boardAliveCount;
+    unsigned long               firmwareRequestData;     /* (hfr & HIFR_FIRM_REQ)==1 */
+    unsigned short              firmwareRequestDCPacket; /* from GetDCPacket_x_FRI */
+    DMI_HEADER                  dmiHeader;
+    PCI_COMMON_CONFIG           pciCommonConfig;
+    RAC_EVENT_NOTIFICATION      events;
+} RAC_INFO;
+
+/*******************************************
+ * MegaRacDrvr.c function definitions
+ ******************************************/
+#ifdef MEGARAC_DRIVER_IS
+#if DEBUG_PRINT
+    static char        *racIoctlToString        ( unsigned long   ioControlCode );
+    static char        *racFriToString          ( int             fri );
+    static void         racDumpRegs             ( RAC_INFO *pRAC, char *str );
+#endif
+static void             racSetAddrs             ( RAC_INFO *pRAC, void *baseAddr );
+static void             racClearAddrs           ( RAC_INFO *pRAC );
+static void             racFindDmiInBios        ( RAC_INFO *pRAC );
+static BOOL             racHandleReportDMI      ( RAC_INFO *pRAC, CCB_Header *pCCB );
+static BOOL             racSendCcb              ( RAC_INFO *pRAC, CCB_Header *pCCB, unsigned long ioControlCode );
+static BOOL             racSendCcbWait          ( RAC_INFO *pRAC, CCB_Header *pCCB, unsigned long ioControlCode );
+static void             racSendIoBaseAddr       ( RAC_INFO *pRAC );
+static void             racSendStartHeartBeat   ( RAC_INFO *pRAC );
+static void             racSendStopHeartBeat    ( RAC_INFO *pRAC );
+static void             racSendHardReset        ( RAC_INFO *pRAC );
+static void             racStartupFinal         ( RAC_INFO *pRAC );
+static void             racShutdownBegin        ( RAC_INFO *pRAC );
+static void             racPreProcessCCB        ( RAC_INFO *pRAC, CCB_Header *pCCB, unsigned long  bufLen,
+                                                                                    unsigned long  ioControlCode,
+                                                                                    RAC_DRVR_ERR  *drvrStatus );
+static BOOL             racIsrDpc               ( RAC_INFO *pRAC );
+static void             racTimerTick            ( RAC_INFO *pRAC );
+static void             racEvent                ( RAC_INFO *pRAC, RAC_EVENT   rawEvent );
+
+extern void           (*racOsEventProc)         ( RAC_INFO *pRAC, RAC_EVENT   rawEvent, RAC_EVENT firmEvent );
+extern void           (*racOsSetEventsProc)     ( RAC_INFO *pRAC, CCB_Header *pCCB );
+extern void           (*racOsAttachmentsProc)   ( RAC_INFO *pRAC, CCB_Header *pCCB );
+extern unsigned short (*racGetHardwareCursor)   ( void );
+#endif  /* ifdef MEGARAC_DRIVER_IS */
+
+/*******************************************
+ * MegaRac Device Registers and Definitions 
+ ******************************************/
+
+/* RAC Register Offsets */
+#define HOST_INTERRUPT_MASK_REG     0x01    /* alias HIMR_   */
+#define HOST_INTERRUPT_FLAG_REG     0x02    /* alias HIFR_   */
+#define HOST_COMMAND_REG            0x03    /* alias HCMDR_  */
+#define HOST_DATA_IN_REG            0x04
+#define HOST_DATA_OUT_REG           0x04
+#define HOST_ADAPTER_STATUS_REG     0x09    /* alias HASR_   */
+#define HOST_FLAGS_REG              0x0a    /* same as HIFR_ */
+#define HOST_CONTROL_REG            0x10    /* alias HCR_    */
+
+/* HIMR - Host Interrupt Mask Register */
+#define HIMR_DISABLE_ALL            0x00    /* disable all interrupts */
+#define HIMR_TO_HOST                0x80    /* enable interrupt to host */
+#define HIMR_FIRMWARE_REQ           0x08    /* enable firmware request int */
+#define HIMR_HOST_COMP              0x04    /* Host Adapter Cmd Execute Cmplt */
+#define HIMR_DEFAULTS             ( HIMR_TO_HOST | HIMR_FIRMWARE_REQ | HIMR_HOST_COMP )
+#define HIMR_DEFAULTS_NO_HOST     ( HIMR_DEFAULTS & ~HIMR_TO_HOST )
+
+/* HIFR - Host Interrupt Flag Register and
+   HFR  - Host Flag Register           are the same except for HIFR_ANY_INTR */
+#define HIFR_ANY_INTR               0x80    /* 'Any Interrupt' occurred */
+#define HIFR_SOFT_INT               0x40    /* 'Software Generated Interrupt by local processor' */
+#define HIFR_DATA_OUT               0x20    /* host data out port empty */
+#define HIFR_FIRM_REQ               0x08    /* firmware request interrupt */
+#define HIFR_HACC                   0x04    /* Host Adapter Cmd Execute Cmplt */
+#define HIFR_FIRM_HANDSHAKE         0x02    /* firmware request handshake */
+
+/* HCMDR - Host Command Register */
+#define HCMDR_ISSUE_RCS_CMD         ISSUE_RCS
+#define HCMDR_ENTER_SDK_FLASH_MODE  SDK_NEWFLASH    
+#define HCMDR_SET_HACC              SET_COMMAND_COMPLETE
+
+/* HASR - Host Adapter Status Register */
+#define HASR_FIRM_READY             0x80    /* firmware ready for command */
+#define HASR_FIRM_ABORT             0x40    /* firmware aborted */
+#define HASR_FIRM_FAULT             0x20    /* firmware fault */
+#define HASR_FIRM_INVALID           0x10    /* firmware invalid */
+#define HASR_FIRM_FAILED          ( HASR_FIRM_ABORT | HASR_FIRM_FAULT | HASR_FIRM_INVALID )
+
+/* HCR - Host Control Register */
+#define HCR_HARD_RESET              0x80    /* Hard Reset */
+#define HCR_SOFT_RESET              0x40    /* Soft Reset */
+#define HCR_INTR_RESET              0x20    /* reset all interrupts in HIFR */
+#define HCR_SOFT_INTR_1             0x10    /* host soft interrupt 1 */
+
+/* misc */
+#define BOARD_ALIVE_RESET              0
+#define AMI_VENDOR_ID             0x101e    /* see struct _PCI_COMMON_CONFIG.VendorID */
+#define AMI_MEGA_RAC_ID           0x9063    /* see struct _PCI_COMMON_CONFIG.DeviceID */
+
+
+#endif /* MEGARAC_DRIVER_H */
diff -urNp linux-5000/drivers/addon/megarac/MegaRacDrvrLx.h linux-5010/drivers/addon/megarac/MegaRacDrvrLx.h
--- linux-5000/drivers/addon/megarac/MegaRacDrvrLx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/MegaRacDrvrLx.h	
@@ -0,0 +1,28 @@
+/*****************************************************************************
+ *
+ *  MegaRacDrvrLx.h : MegaRac device driver definitions for Linux
+ *
+ ****************************************************************************/
+#ifndef MEGARAC_DRIVER_LX_H
+#define MEGARAC_DRIVER_LX_H
+
+/* ioctl stuff */
+
+#define RAC_IOC_MAGIC       0x0e /* part of vendor ID */
+#define IOCTL_ISSUE_RCS     0x01
+#define IOCTL_GET_GRAPHICS  0x02
+#define IOCTL_EVENT_WAIT    0x03
+#define IOCTL_API_INTERNAL  0x07
+#define IOCTL_RESET_CARD    0x09
+
+#define MEGARAC_DEVICE_NAME "/dev/rac0"
+
+typedef struct _MEGARAC_IO_BUFS {
+    unsigned long  ioControlCode;
+    void          *requestBuf;
+    unsigned long  requestBufLen;
+    void          *responseBuf;
+    unsigned long  responseBufLen;
+} MEGARAC_IO_BUFS;
+
+#endif /* MEGARAC_DRIVER_LX_H */
diff -urNp linux-5000/drivers/addon/megarac/MegaRacWho.h linux-5010/drivers/addon/megarac/MegaRacWho.h
--- linux-5000/drivers/addon/megarac/MegaRacWho.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/MegaRacWho.h	
@@ -0,0 +1,129 @@
+/*****************************************************************************
+ *
+ *  MegaRacWho.h : MegaRac 'who am I?'
+ *
+ ****************************************************************************/
+#ifndef MEGARAC_WHO_AM_I_H
+#define MEGARAC_WHO_AM_I_H
+
+ /* some code has conditionals such as
+        #if   OEM==0    ...do some AMI thing
+        #elif OEM==1    ...do some DELL thing
+   these defintions are for that purpose */
+//#include "oem_code.h"
+#define MEGARAC_OEM_AMI     0
+#define MEGARAC_OEM_DELL    1
+
+/*****************************************************************************
+ * make determination about what is being compiled 
+ *
+ *  target OS choices:
+ *      winNT   4.0
+ *      winNT   2000
+ *      Netware 4.x
+ *      Netware 5.x
+ *      SCO     Unix
+ *      RedHat  Linux
+ *      Sun     Solaris
+ *
+ *  software modules:
+ *      driver
+ *      api
+ *
+ ****************************************************************************/
+
+#ifdef __KERNEL__                       /* manually specified (but mandatory) for driver development */
+        #define MEGARAC_DRIVER_LINUX
+	#define MEGARAC_DRIVER_IS
+#else
+	#define MEGARAC_API_LINUX
+#endif
+
+
+/*******************************************
+ *  Linux
+ ******************************************/
+typedef int BOOL;
+#define TRUE        1
+#define FALSE       0
+#include "MegaRacDrvrLx.h"
+
+extern BOOL MegaRACInit(unsigned long);
+extern void MegaRACFinish(void);
+
+/****************************************************************
+ *   taken from winNT for compatability with all other platforms
+ ****************************************************************/
+#if ! ( defined(MEGARAC_DRIVER_WIN_NT) || \
+        defined(MEGARAC_DRIVER_WIN_2000) )
+    #define PCI_TYPE0_ADDRESSES  6
+   typedef struct _PCI_COMMON_CONFIG {
+    unsigned short  VendorID;                   
+    unsigned short  DeviceID;                   
+    unsigned short  Command;                    
+    unsigned short  Status;
+    unsigned char   RevisionID;                 
+    unsigned char   ProgIf;                     
+    unsigned char   SubClass;                   
+    unsigned char   BaseClass;                  
+    unsigned char   CacheLineSize;              
+    unsigned char   LatencyTimer;               
+    unsigned char   HeaderType;                 
+    unsigned char   BIST;                       
+    union {
+        struct _PCI_HEADER_TYPE_0 {
+            unsigned long   BaseAddresses[PCI_TYPE0_ADDRESSES];
+            unsigned long   CIS;
+            unsigned short  SubVendorID;
+            unsigned short  SubSystemID;
+            unsigned long   ROMBaseAddress;
+            unsigned long   Reserved2[2];
+            unsigned char   InterruptLine;      
+            unsigned char   InterruptPin;       
+            unsigned char   MinimumGrant;       
+            unsigned char   MaximumLatency;     
+        } type0;
+    } u;
+    unsigned char   DeviceSpecific[192];
+   } PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;
+    #define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))
+    #define PCI_MAX_DEVICES                     32
+    #define PCI_MAX_FUNCTION                    8
+    #define PCI_INVALID_VENDORID                0xFFFF
+    /* Bit encodings for  PCI_COMMON_CONFIG.HeaderType */
+    #define PCI_MULTIFUNCTION                   0x80
+    #define PCI_DEVICE_TYPE                     0x00
+    #define PCI_BRIDGE_TYPE                     0x01
+    /* Bit encodings for PCI_COMMON_CONFIG.Command */
+    #define PCI_ENABLE_IO_SPACE                 0x0001
+    #define PCI_ENABLE_MEMORY_SPACE             0x0002
+    #define PCI_ENABLE_BUS_MASTER               0x0004
+    #define PCI_ENABLE_SPECIAL_CYCLES           0x0008
+    #define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
+    #define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
+    #define PCI_ENABLE_PARITY                   0x0040  
+    #define PCI_ENABLE_WAIT_CYCLE               0x0080  
+    #define PCI_ENABLE_SERR                     0x0100  
+    #define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  
+    /* Bit encodings for PCI_COMMON_CONFIG.Status */
+    #define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  
+    #define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
+    #define PCI_STATUS_DEVSEL                   0x0600  
+    #define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
+    #define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
+    #define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
+    #define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
+    #define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000
+    /* Bit encodes for PCI_COMMON_CONFIG.u.type0.BaseAddresses */
+    #define PCI_ADDRESS_IO_SPACE                0x00000001  
+    #define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006  
+    #define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008  
+    #define PCI_TYPE_32BIT      0
+    #define PCI_TYPE_20BIT      2
+    #define PCI_TYPE_64BIT      4
+    /* Bit encodes for PCI_COMMON_CONFIG.u.type0.ROMBaseAddresses */
+    #define PCI_ROMADDRESS_ENABLED              0x00000001
+#endif /* #if !defined(MEGARAC_DRIVER_WIN_*) */
+
+
+#endif /* MEGARAC_WHO_AM_I_H */
diff -urNp linux-5000/drivers/addon/megarac/mg90xx.h linux-5010/drivers/addon/megarac/mg90xx.h
--- linux-5000/drivers/addon/megarac/mg90xx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/mg90xx.h	
@@ -0,0 +1,121 @@
+#ifndef __MG90XX_H__
+#define __MG90XX_H__
+
+/* Timeout value in seconds for RAC card to become ready after a cold start */
+#define RAC_CARD_READY_TIMEOUT	120
+
+# define LOCAL_INTR_FLAG_REG    ((unsigned char *)0xC0000800)
+# define HOST_INTR_GEN_REG     ((unsigned char *)0xC0000802)
+# define LOCAL_COMMAND_REG		((unsigned char *)0xC0000803)
+# define LOCAL_DATA_REG		((unsigned long *)0xC0000804)
+# define LOCAL_CONTROL_REG   ((unsigned char *)0xC0000808)
+# define LOCAL_INTR_MASK_REG	((unsigned char *)0xC0000809)
+# define LOCAL_FLAG_REG		((unsigned char *)0xC000080C)
+ 
+# define MG9063_NEW_FUNCTION_REG ((unsigned long*)0xC0001800)
+# define LOCAL_INTR_MASK_REG_2   ((unsigned char*)0xC0001804)
+#define  LOCAL_FLAG_REG_2   ((unsigned char*)0xC0001806)
+#define  CLASS_CODE_REG     ((unsigned char*)0xC0001808)
+#define  SUBSYSTEM_REG     ((unsigned char*)0xC000180C)
+
+
+# define MG9063_HOST_PCI_PAGE_WINDOW_1 ((unsigned short*)0xC0001810)
+# define MG9063_HOST_PCI_PAGE_WINDOW_2 ((unsigned short*)0xC0001812)
+# define MG9063_HOST_PCI_PAGE_WINDOW_3 ((unsigned short*)0xC0001814)
+# define MG9063_HOST_PCI_PAGE_WINDOW_4 ((unsigned short*)0xC0001816)
+
+# define CRT_REG2_DATA_REG              ((unsigned char*)0xC0001818)
+# define CRT_REG7_DATA_REG              ((unsigned char*)0xC0001819)
+# define CRT_REG9_DATA_REG              ((unsigned char*)0xC000181A)
+# define CRT_REGC_DATA_REG              ((unsigned char*)0xC000181B)
+# define CRT_REGD_DATA_REG              ((unsigned char*)0xC000181C)
+# define CRT_REG12H_DATA_REG            ((unsigned char*)0xC000181D)
+# define PORT80_DATA_REG                ((unsigned char*)0xC000181E)
+# define PCI_CACHE_LINE_REG             ((unsigned char*)0xC000181F)
+
+
+# define SOFTINT2	0x80
+# define SRST		0x40
+#define  TIMEOUT     0x20
+# define SOFTINT1	0x10
+# define HCPF		0x08
+# define HDOF    	0x04
+# define ENABLE_INTR	0x01
+# define INTR_SET       0x01
+# define HACC		0x04
+
+# define VGAEIN  0x01
+# define MONOEIN 0x02
+# define POSTEIN 0x04
+# define RSTEIN  0x08
+# define _3DEEIN 0x10
+# define _3D5EIN 0x40
+
+
+
+# define SET_SOFTINT    0x40
+# define SET_FRI        0x08
+# define SET_HACC       0x04
+# define FRI_PENDING    0x02    // FRI Handshaking
+# define SET_SMI        0x01    // SMI Handshaking
+
+#define NFR_IO_CYCLE                     0x00000001
+#define NFR_DISABLE_PCI_RETRY            0x00000004
+#define NFR_NO_RESET_ON_PCI_RESET        0x00000010
+#define NFR_IOCHRDY_ENABLED              0x00000040
+#define NFR_GENERAL_TMOUT_ENABLED        0x00000080
+#define NFR_PCI_DAC_CYCLE_ENABLED        0x00100000
+#define NFR_ACCESS_REG_THROUGH_PCI       0x00200000
+#define NFR_ROWSIZ12_DISABLE             0x00800000
+#define NFR_DRAM_TYPE_9060               0X00000000
+#define NFR_DRAM_TYPE_64MB               0x01000000
+#define NFR_DRAM_TYPE_16MB               0x02000000
+#define NFR_DRAM_TYPE_4MB                0x03000000
+#define NFR_PCI_READ_AHEAD_DISABLED      0x04000000
+#define NFR_PCI_VGA_3D4                  0x20000000
+#define NFR_REF16MHZ                     0x40000000
+#define NFR_FLUSHFIFO                    0x80000000
+
+
+
+#define IPND_MG9063_LOCAL_INT            0x0
+#define IPND_MG9063_TIMER_INT            0x1
+#define IPND_I2C_INT                     0x2
+#define IPND_RTC_INT                     0x3
+#define IPND_NET_INT                     0x4
+#define IPND_PCMCIA_INT                  0x5
+#define IPND_SERIAL_INT                  0x6
+#define IPND_RS485_INT                   0x7
+#define IPND_CLOCK_INT                   0x8
+#define IPND_TMR1_INT                    0x9
+
+#define SERIES_767 767
+#define SERIES_780 780
+#define SERIES_788 788
+
+
+
+
+/*  Command values written to the local command register    */
+#define ISSUE_CCB 0x01
+#define ISSUE_RCS 0x02
+# define AGP_SCREEN_DUMP    0x0A
+#define	 SET_COMMAND_COMPLETE   0x77 //for the host driver to tell us to set HACC while its going 									//out
+#define HEARTBEAT_ENABLE 0x78
+#define HEARTBEAT_DISABLE 0x79
+#define DEBUG_MODE_ON 0x88
+#define DEBUG_MODE_OFF 0x89
+#define ABORT_RECOVERY_ON   0x90
+#define ABORT_RECOVERY_OFF  0x91
+#define VSP_COMMAND_GROUP  0x80
+
+#define SDK_NEWFLASH   		0xA0
+
+
+
+
+#define HOST_TIMEDOUT  0x10
+#define HOST_NORMAL    0x0
+
+#endif
+
diff -urNp linux-5000/drivers/addon/megarac/misc.h linux-5010/drivers/addon/megarac/misc.h
--- linux-5000/drivers/addon/megarac/misc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/misc.h	
@@ -0,0 +1,90 @@
+#ifndef  __MISC_H__
+#define  __MISC_H__
+
+#include "rcs.h"
+#include "dtypes.h"
+
+#define NUM_GENERIC_DATA   4
+#define MAX_GENERIC_DATA   (1024*4)
+
+#define AR_DISABLE      0X00
+#define AR_HW_RESET     0X01
+#define AR_HW_PWRCYCLE  0X02
+#define MINIMUM_AUTO_RECOVERY_TIMER  15
+
+typedef struct GET_VERSION_TYPE_tag
+{
+	u8 MajorNum;
+	u8 MinorNum;
+	u8 BuildDate[12];
+	u8 Prefix[4];
+}GET_VERSION_TYPE;
+
+typedef struct GET_MEGARAC_INFO_TYPE_tag
+{
+   u8 Processor[30];
+   u8 CPUSpeed[8];
+   u8 MemorySize[8];
+   u8 ROMSize[8];
+   u8 NVRAMSize[8];
+   u8 HostBridge[30];
+   u8 NetworkController[30];
+   u8 ModemType;
+   u8 PCMCIAController[30];
+   u8 PcCardManufacturer[30];
+   u8 PcCardProductName[30];
+   u8 BatteryInfo[30];
+   TWOBYTES Series;
+   u8 Reserved[14];
+   u8 NICAddr[6];
+}GET_MEGARAC_INFO_TYPE;
+
+typedef struct MISC_CFG_TYPE_tag
+{
+	TWOBYTES StartupTimeDelay;
+	u8 AutoRecovery;
+	TWOBYTES HeartBeatTimeout;
+	u8 ServerID;
+}MISC_CFG_TYPE;
+
+typedef struct MISC_CFG_CMD_tag
+{
+	RCS_COMMAND_PACKET header;
+	MISC_CFG_TYPE info;
+}MISC_CFG_CMD;
+
+typedef struct _IPMI_GetSELInfoResp{
+	unsigned char	Version;
+	unsigned char 	NoEntriesLSB;
+	unsigned char	NoEntriesMSB;
+    unsigned char   FreespaceLSB;
+    unsigned char   FreespaceMSB;
+	unsigned char 	AddTime[4];
+	unsigned char 	EraseTime[4];
+	unsigned char	Operation;
+}IPMI_GET_SEL_INFO_RESP;
+
+typedef struct _IPMI_PowerCmd{
+	unsigned char Power;
+}IPMI_POWER_CMD;
+
+typedef struct _GetIPMIInfoArgs
+{
+   unsigned char  DestAddr;     /* Input Only . Unaltered on Return */
+   unsigned char  DestLun;      /* Input Only . Unaltered on Return */
+   unsigned char  NetFn;        /* Input Only . Unaltered on Return */
+   unsigned char  Cmd;          /* Input Only . Unaltered on Return */
+   unsigned char  RetCode;      /* Output - IPMI Return Code        */
+   int            BufLen;       /* Input Only . IPMIData Max Size   */
+   int            DataLen;      /* Input & Output - Data in IPMIData*/
+   char           IPMIData[1];  /* Input & Output - IPMI Data       */    
+}GET_IPMI_INFO_ARGS;
+
+typedef struct AUTO_RECOVERY_CFG_TYPE_tag
+{
+   u8 AutoRecovery;
+   FOURBYTES AutoRecoveryTimer;
+   u8 Reserved[11];
+}AUTO_RECOVERY_CFG_TYPE;
+
+#endif
diff -urNp linux-5000/drivers/addon/megarac/post.h linux-5010/drivers/addon/megarac/post.h
--- linux-5000/drivers/addon/megarac/post.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/post.h	
@@ -0,0 +1,53 @@
+/*
+ ****************************************************************************
+ *
+ *   File Name   :  POST.H
+ *
+ *   Author      :  Baskar Parthiban
+ *
+ *   Date        :  20 Apr 1998
+ *
+ *   Purpose     :  This file has #defines to help capture, saving and
+ *                  retrieval of the POST codes of the host during
+ *                  startup.
+ *
+ *   Copyright   :  American Megatrends Inc., (C) 1997-1998
+ *                  All rights reserved.
+ *
+ *
+ ****************************************************************************
+ */
+#ifndef __AMI_POST_H__
+#define __AMI_POST_H__
+
+#include    "rcs.h"
+
+#define POSTCodeSnoopPort   (BYTE *)0xC000181E
+#define MAX_POST_LOGS 4
+#define MAX_POST_CODES  512
+
+extern  TWOBYTES    NumOfPOSTCodes;
+
+typedef struct _POSTLogTag
+{
+    BYTE        POSTCodes [MAX_POST_CODES];
+} POSTLogStruct;
+
+typedef struct _POSTLogPktToRemoteTAG
+{
+    RCS_COMMAND_PACKET RCSCmdPkt;
+//    BYTE        POSTCodes [MAX_POST_CODES];
+    POSTLogStruct   strPOSTLog;
+
+} POST_LOG_PKT_TO_REMOTE;
+
+typedef struct _POSTLogTypeTAG{
+   TWOBYTES NumOfCodes;
+   BYTE     Log[MAX_POST_CODES];
+   void  *  pprev;
+   void  *  pnext;
+}POST_LOG_TYPE;
+
+#endif
+
+ /*---------------------------- End of POST.H -------------------------------*/
diff -urNp linux-5000/drivers/addon/megarac/rcsadmin.h linux-5010/drivers/addon/megarac/rcsadmin.h
--- linux-5000/drivers/addon/megarac/rcsadmin.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/rcsadmin.h	
@@ -0,0 +1,674 @@
+/*******************************************************************
+
+	File Name   :   RCSADMIN.H
+
+	Author      :   K.V.Subash & Parthiban Baskar
+
+	Date        :   8 December 1997
+
+	Purpose     :   RCS ADMIN cmd grp cmd codes
+
+	Copyright       :       American Megatrends Inc., 1997-1998
+
+********************************************************************/
+
+#ifndef __RCSADMIN_H__
+#define __RCSADMIN_H__
+
+#include "rcs.h"
+#include "rtc.h"
+#include "admin.h"
+#include "comrcs.h"
+/************************************************************************/
+/**************  REMOTE ADMIN AND CONFIG COMMANDS ***********************/
+/************************************************************************/
+
+/*******************************GROUP 040**************************/
+#define RCS_ADMIN_ENABLE_HHF_MONITOR            0X0400
+#define RCS_ADMIN_ENABLE_HHF_THRESHOLD          0X0401
+#define RCS_ADMIN_READ_HHF_THRESHOLD            0X0402
+#define RCS_ADMIN_MOD_HHF_THRESHOLD             0X0403
+#define RCS_ADMIN_READ_HHF_SCHEDULE             0X0404
+#define RCS_ADMIN_MOD_HHF_SCHEDULE              0X0405
+#define RCS_ADMIN_READ_HHF_MONITOR_STATE        0x0406
+#define RCS_ADMIN_READ_HHF_THRESHOLD_STATE      0x0407
+#define RCS_ADMIN_ENABLE_SDK_MONITOR            0X0408
+#define RCS_ADMIN_ENABLE_SDK_THRESHOLD          0X0409
+#define RCS_ADMIN_READ_SDK_THRESHOLD            0X040A
+#define RCS_ADMIN_MOD_SDK_THRESHOLD             0X040B
+#define RCS_ADMIN_READ_SDK_SCHEDULE             0X040C
+#define RCS_ADMIN_MOD_SDK_SCHEDULE              0X040D
+#define RCS_ADMIN_READ_SDK_MONITOR_STATE        0x040E
+#define RCS_ADMIN_READ_SDK_THRESHOLD_STATE      0x040F
+/************No of funtions beginning with 040**********************/
+#define FNS_040 16
+/*******************************************************************/
+
+
+/*******************************GROUP 041**************************/
+#define RCS_ADMIN_ADD_ADMIN_ENTRY               0X0410
+#define RCS_ADMIN_READ_ADMIN_ENTRY              0X0411
+#define RCS_ADMIN_DELETE_ADMIN_ENTRY            0X0412
+#define RCS_ADMIN_MODIFY_ADMIN_ENTRY            0X0413
+/************No of funtions beginning with 041**********************/
+#define FNS_041 4
+/*******************************************************************/
+
+
+/*******************************GROUP 042**************************/
+#define RCS_ADMIN_READ_NETWORK_CFG              0X0420
+#define RCS_ADMIN_MODIFY_NETWORK_CFG            0X0421
+#define RCS_ADMIN_READ_MODEM_CFG                0X0422
+#define RCS_ADMIN_MODIFY_MODEM_CFG              0X0423
+#define RCS_ADMIN_ADD_SNMP_DESTINATION          0X0424
+#define RCS_ADMIN_READ_SNMP_DESTINATION         0X0425
+#define RCS_ADMIN_MODIFY_SNMP_DESTINATION       0X0426
+#define RCS_ADMIN_DELETE_SNMP_DESTINATION       0X0427
+#define RCS_ADMIN_ADD_MANAGEMENT_CONSOLE        0X0428
+#define RCS_ADMIN_READ_MANAGEMENT_CONSOLE       0X0429
+#define RCS_ADMIN_MODIFY_MANAGEMENT_CONSOLE     0X042A
+#define RCS_ADMIN_DELETE_MANAGEMENT_CONSOLE     0X042B
+#define RCS_ADMIN_READ_ALERT_TABLE              0X042C
+#define RCS_ADMIN_MODIFY_ALERT_TABLE            0X042D
+#define RCS_ADMIN_FORCE_SAVE_CONFIG             0x042E
+#define RCS_ADMIN_TEST_PAGE                     0x042F
+/************No of funtions beginning with 042**********************/
+#define FNS_042 16
+/*******************************************************************/
+
+
+
+/*******************************GROUP 043**************************/
+#define RCS_ADMIN_READ_PPP_CFG                  0X0430
+#define RCS_ADMIN_MODIFY_PPP_CFG                0X0431
+#define RCS_ADMIN_READ_DIALOUT_CFG              0X0432
+#define RCS_ADMIN_MODIFY_DIALOUT_CFG            0X0433
+#define RCS_ADMIN_READ_TCPIP_CFG                0X0434
+#define RCS_ADMIN_MODIFY_TCPIP_CFG              0X0435
+#define RCS_ADMIN_READ_DHCP_CFG                 0X0436
+#define RCS_ADMIN_MODIFY_DHCP_CFG               0X0437
+
+/*r added to Read Admin Mail Id*/
+#define RCS_ADMIN_READ_MAIL_ID                  0X0438
+#define RCS_ADMIN_MODIFY_MAIL_ID                0X0439
+#define RCS_ADMIN_READ_MAIL_SERVER_IP           0X043a
+#define RCS_ADMIN_MODIFY_MAIL_SERVER_IP         0X043b
+#define RCS_SEND_TEST_EMAIL                     0X043C
+
+/*r End*/ 
+
+/************No of funtions beginning with 043**********************/
+#define FNS_043 13
+/*******************************************************************/
+
+
+
+/*******************************GROUP 044**************************/
+#define RCS_SET_ADMIN_HOURLY_MASKS              0x0440
+#define RCS_GET_ADMIN_HOURLY_MASKS              0x0441
+#define RCS_SET_SNMP_SEVERITY                   0x0442
+#define RCS_GET_SNMP_SEVERITY                   0x0443
+#define RCS_SET_MGNTCON_SEVERITY                0x0444
+#define RCS_GET_MGNTCON_SEVERITY                0x0445
+
+/************No of funtions beginning with 044**********************/
+#define FNS_044 6
+/*******************************************************************/
+
+
+
+
+/*******************************GROUP 045**************************/
+#define RCS_ADMIN_READ_MISC_CFG                 0X0450
+#define RCS_ADMIN_MODIFY_MISC_CFG               0X0451
+#define RCS_ADMIN_READ_AUTO_RECOVERY_CFG        0X0452
+#define RCS_ADMIN_MODIFY_AUTO_RECOVERY_CFG      0X0453
+#define RCS_ADMIN_READ_TERMINAL_SERVER_CFG      0X0454
+#define RCS_ADMIN_MODIFY_TERMINAL_SERVER_CFG    0X0455
+/************No of funtions beginning with 045**********************/
+#define FNS_045 6
+/*******************************************************************/
+
+
+
+/*******************************GROUP 046**************************/
+#define RCS_ADMIN_RESET_CARD                    0X0460
+#define RCS_ADMIN_SHUTDOWN_CARD                 0X0461
+#define RCS_ADMIN_RESET_BATT_CHG_CNT            0X0462
+#define RCS_ADMIN_SET_DATE_TIME                 0X0463
+#define RCS_ADMIN_GET_DATE_TIME                 0X0464
+#define RCS_ADMIN_RESTORE_FACTORY_DEFAULTS      0X0465
+/************No of funtions beginning with 046**********************/
+#define FNS_046 6
+/*******************************************************************/
+
+
+
+/*******************************GROUP 047**************************/
+#define RCS_ADMIN_UPDATE_FIRMWARE               0X0470
+/************No of funtions beginning with 047**********************/
+#define FNS_047 1
+/*******************************************************************/
+
+
+/*******************************GROUP 048**************************/
+#define RCS_ADMIN_READ_SNMPSERVER_CONFIG       0x0480
+#define RCS_ADMIN_MODIFY_SNMPSERVER_CONFIG     0x0481
+/************No of funtions beginning with 048**********************/
+#define FNS_048 2
+/*******************************************************************/
+
+
+
+/*******************************GROUP 049**************************/
+
+/************No of funtions beginning with 049**********************/
+#define FNS_049 0
+/*******************************************************************/
+
+
+/*******************************GROUP 04A**************************/
+
+/************No of funtions beginning with 04A**********************/
+#define FNS_04A 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 04B**************************/
+
+/************No of funtions beginning with 04B**********************/
+#define FNS_04B 0
+/*******************************************************************/
+
+
+/*******************************GROUP 04C**************************/
+
+/************No of funtions beginning with 04C**********************/
+#define FNS_04C 0
+/*******************************************************************/
+
+
+
+
+/*******************************GROUP 04D**************************/
+
+/************No of funtions beginning with 04D**********************/
+#define FNS_04D 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 04E**************************/
+
+/************No of funtions beginning with 04E**********************/
+#define FNS_04E 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 04F**************************/
+
+/************No of funtions beginning with 04F**********************/
+#define FNS_04F 0
+/*******************************************************************/
+
+
+/************************************************************************/
+/**************  REMOTE ADMIN AND CONFIG COMMANDS END********************/
+/************************************************************************/
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	DATE_TIME   dt;
+} RCS_GET_DATE_TIME_PKT;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	DATE_TIME   dt;
+} RCS_SET_DATE_TIME_PKT;
+
+
+typedef struct {
+	  u8 Index;
+	  FOURBYTES   HourlyMasks [7];  // For admin's day-of-week preference.
+			   } RCS_ADMIN_HOURLY_MASKS_PKT;
+
+//r
+typedef struct {
+	  u8 Index;
+	  ADMIN_MAIL_ID MailId;  //For admin's Mail Id List
+	  }RCS_ADMIN_MAIL_ID_PKT;
+
+typedef struct {
+	  ADMIN_MAIL_SERVER_IP ServerIp;  //For Mail Server Ip 
+	  }RCS_ADMIN_MAIL_SERVER_IP_PKT;
+
+//r end
+
+
+
+
+
+typedef struct {
+	  u8 Index;
+	  TWOBYTES SeverityMask;  // For SNMP Severity Mask
+			   } RCS_SNMP_SEVERITY_MASKS_PKT;
+
+typedef struct {
+			  u8 Index;
+			  TWOBYTES SeverityMask;  // For Management Console Severity Mask
+			  } RCS_MGNTCON_SEVERITY_MASKS_PKT;
+
+typedef struct {
+   RCS_COMMAND_PACKET  RCSCmdPkt;
+   RCS_ADMIN_HOURLY_MASKS_PKT Data;
+} RCS_FN_GET_ADMIN_HOURLY_MASKS_COMMAND;
+
+typedef struct {
+   RCS_COMMAND_PACKET  RCSCmdPkt;
+   RCS_ADMIN_HOURLY_MASKS_PKT Data;
+} RCS_FN_SET_ADMIN_HOURLY_MASKS_COMMAND;
+
+//r added
+typedef struct {
+   RCS_COMMAND_PACKET  RCSCmdPkt;
+   RCS_ADMIN_MAIL_ID_PKT Data;
+}RCS_FN_ADMIN_READ_MAIL_ID_COMMAND;
+
+typedef struct {
+   RCS_COMMAND_PACKET  RCSCmdPkt;
+   RCS_ADMIN_MAIL_ID_PKT Data;
+}RCS_FN_ADMIN_MODIFY_MAIL_ID_COMMAND;
+
+typedef struct {
+   RCS_COMMAND_PACKET  RCSCmdPkt;
+   RCS_ADMIN_MAIL_SERVER_IP_PKT Data;
+}RCS_FN_ADMIN_READ_MAIL_SERVER_IP_COMMAND;
+
+typedef struct {
+   RCS_COMMAND_PACKET  RCSCmdPkt;
+   RCS_ADMIN_MAIL_SERVER_IP_PKT Data;
+}RCS_FN_ADMIN_MODIFY_MAIL_SERVER_IP_COMMAND;
+
+//r end
+
+typedef struct {
+   RCS_COMMAND_PACKET  RCSCmdPkt;
+   RCS_SNMP_SEVERITY_MASKS_PKT Data;
+} RCS_FN_GET_SNMP_SEVERITY_MASKS_COMMAND;
+
+typedef struct {
+   RCS_COMMAND_PACKET  RCSCmdPkt;
+   RCS_SNMP_SEVERITY_MASKS_PKT Data;
+} RCS_FN_SET_SNMP_SEVERITY_MASKS_COMMAND;
+
+typedef struct {
+   RCS_COMMAND_PACKET  RCSCmdPkt;
+   RCS_MGNTCON_SEVERITY_MASKS_PKT Data;
+} RCS_FN_GET_MGNTCON_SEVERITY_MASKS_COMMAND;
+
+typedef struct {
+   RCS_COMMAND_PACKET  RCSCmdPkt;
+   RCS_MGNTCON_SEVERITY_MASKS_PKT Data;
+} RCS_FN_SET_MGNTCON_SEVERITY_MASKS_COMMAND;
+
+
+typedef struct {
+   u8 AutoRecovery;
+   FOURBYTES AutoRecoveryTimer;
+   u8 Reserved[11];
+}RCS_AUTO_RECOVERY_CFG;
+
+typedef struct {
+   RCS_COMMAND_PACKET  RCSCmdPkt;
+   RCS_AUTO_RECOVERY_CFG Data;
+} RCS_FN_READ_AUTO_RECOVERY_CFG_COMMAND;
+
+typedef struct {
+   RCS_COMMAND_PACKET  RCSCmdPkt;
+   RCS_AUTO_RECOVERY_CFG Data;
+} RCS_FN_MODIFY_AUTO_RECOVERY_CFG_COMMAND;
+
+/*
+   Refer to TCP_TIME.H for detailed descriptions on how the following TCP
+   time parameters are used.
+*/
+#define  MAX_ETHERNET_MTU  1500
+#define  MIN_ETHERNET_MTU  46
+
+#define  TCP_TTL_DEFAULT   60       /* default time to live for TCP segs */
+#define  MIN_TCP_TTL       60       /* minimum time to live for TCP segs */
+#define  MAX_TCP_TTL       512  /* maximum time to live for TCP segs */
+
+#define  MIN_TCP_SRTTBASE      0
+#define  MAX_TCP_SRTTBASE      4096
+#define  MIN_TCP_SRTTDFLT      6
+#define  MAX_TCP_SRTTDFLT      512
+#define  MIN_TCP_REXMT_MIN     2
+#define  MAX_TCP_REXMT_MIN     512
+#define  MIN_TCP_REXMT_MAX     128
+#define  MAX_TCP_REXMT_MAX     4096
+/*
+ * Time constants. PR_SLOWHZ equals 2 for our environment
+ */
+#define  TCP_MAX_SEG_LIFE  60    /* ( 30*PR_SLOWHZ) max seg lifetime */
+#define  TCP_SRTTBASE      0     /* base roundtrip time; if 0, no idea yet */
+#define  TCP_SRTTDFLT      6     /* (  3*PR_SLOWHZ) assumed RTT if no info */
+#define  TCP_PERSMIN       10    /* (  5*PR_SLOWHZ) retransmit persistance */
+#define  TCP_PERSMAX       120   /* ( 60*PR_SLOWHZ) maximum persist interval */
+#define  TCP_KEEP_INIT     150   /* ( 75*PR_SLOWHZ) initial connect keep alive */
+#define  TCP_KEEP_IDLE     14400 /* (120*60*PR_SLOWHZ) dflt time before probing */
+#define  TCP_KEEPINTVL     150   /* ( 75*PR_SLOWHZ) default probe interval */
+#define  TCP_KEEPCNT       8     /* max probes before drop */
+#define  TCP_REXMT_MIN     2     /* (  1*PR_SLOWHZ) minimum allowable value */
+#define  TCP_REXMT_MAX     128   /* ( 64*PR_SLOWHZ) max allowable REXMT value */
+#define  TCP_LINGER_TIME   120   /* linger at most 2 minutes */
+#define  TCP_MAXRXT_SHIFT  12    /* maximum retransmits */
+
+typedef struct {
+   TWOBYTES wEtherMTU;
+   TWOBYTES wTCPTTL;
+   TWOBYTES wSRTTBase;
+   TWOBYTES wSRTTDefault;
+   TWOBYTES wTCPReXmtMin;
+   TWOBYTES wTCPReXmtMax;
+//   TWOBYTES wTCPMSL;          /* max seg lifetime */
+//   TWOBYTES wTCPPersistMin    /* retransmit persistance */
+//   TWOBYTES wTCPPersistMax    /* maximum persist interval */
+//   TWOBYTES wTCPKeepInit      /* initial connect keep alive */
+//   TWOBYTES wTCPKeepIdle      /* dflt time before probing */
+//   TWOBYTES wTCPKeepInterval  /* default probe interval */
+//   TWOBYTES wTCPKeepCount     /* max probes before drop */
+//   TWOBYTES wTCPLingerTime    /* linger at most 2 minutes */
+//   TWOBYTES wTCPMaxReXmt      /* maximum retransmits */
+   u8 Reserved[52];
+}RCS_TCPIP_CFG;
+
+typedef struct {
+   RCS_COMMAND_PACKET  RCSCmdPkt;
+   RCS_TCPIP_CFG Data;
+} RCS_FN_READ_TCPIP_CFG_COMMAND;
+
+typedef struct {
+   RCS_COMMAND_PACKET  RCSCmdPkt;
+   RCS_TCPIP_CFG Data;
+} RCS_FN_MODIFY_TCPIP_CFG_COMMAND;
+
+
+/*  DHCPConfig related structures   */
+typedef struct {
+	u8    DHCPConfig;
+	u8    Reserved [15];
+}   RCS_DHCP_CFG;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_DHCP_CFG Data;
+}   RCS_FN_READ_DHCP_CFG_COMMAND;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_DHCP_CFG Data;
+}   RCS_FN_MODIFY_DHCP_CFG_COMMAND;
+
+
+
+/*  TerminalServerConfig related structures   */
+typedef struct {
+	u8    TerminalServerConfig;
+	u8    Reserved [15];
+}   RCS_TERMINAL_SERVER_CFG;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_TERMINAL_SERVER_CFG Data;
+}   RCS_FN_READ_TERMINAL_SERVER_CFG_COMMAND;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_TERMINAL_SERVER_CFG Data;
+}   RCS_FN_MODIFY_TERMINAL_SERVER_CFG_COMMAND;
+
+typedef struct{
+	unsigned char CommunityName[32];
+	unsigned int  EnterpriseID;
+	unsigned char Reserved[64];
+}
+RCS_SNMPSERVER_CONFIG_PKT;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_SNMPSERVER_CONFIG_PKT Data;
+}   RCS_FN_READ_SNMPSERVER_CFG_COMMAND;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_SNMPSERVER_CONFIG_PKT Data;
+}   RCS_FN_MODIFY_SNMPSERVER_CFG_COMMAND;
+
+/*  Administrator related commands  */
+typedef struct {
+	u8    Index;          // 0 based index of this entry in the admin list
+	u8    Reserved1;      // Reserved
+	char    Alias [LENGTH_OF_ALIAS];      // Administrator Alias
+	char    Password [LENGTH_OF_PASSWORD];   // Administrator Password
+	char    CallBackNum [LENGTH_OF_CALLBACK_NO];   // Session callback phone number
+	char    PagerNum [LENGTH_OF_PAGER_NO];  // Paging service number
+	char    ServiceProviderNumber[LENGTH_OF_SERVICE_NO]; //In case of Alphanumeric paging
+	u8    PagerType;      // 00-none, 01-numeric, 02-alphanumeric (TAP)
+	u8    Reserved2;      // Reserved
+	TWOBYTES    Preferences;    // Page Bit Mask
+	char    CustomCode[LENGTH_OF_CUSTOM_CODE];
+	//for a customisable number to be sent on a numeric page
+}   RCS_ADMIN_ENTRY;
+
+typedef struct {
+	u8    Index;
+}   RCS_DELETE_ADMIN_INDEX;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_ADMIN_ENTRY     Data;
+}   RCS_FN_ADD_ADMIN_ENTRY_COMMAND;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_ADMIN_ENTRY     Data;
+}   RCS_FN_READ_ADMIN_ENTRY_COMMAND;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_DELETE_ADMIN_INDEX  Data;
+}   RCS_FN_DELETE_ADMIN_ENTRY_COMMAND;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_ADMIN_ENTRY     Data;
+}   RCS_FN_MODIFY_ADMIN_ENTRY_COMMAND;
+
+/*  Net Config Commands */
+typedef struct {
+	FOURBYTES   IP;
+	FOURBYTES   SubnetMask;
+	FOURBYTES   Gateway;
+}   RCS_NET_CFG;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_NET_CFG         Data;
+}   RCS_FN_READ_NETWORK_CFG_COMMAND;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_NET_CFG         Data;
+}   RCS_FN_MODIFY_NETWORK_CFG_COMMAND;
+
+/*  ModemCfg Commands   */
+typedef struct
+{
+	u8        ModemSelect;
+	FOURBYTES   BaudRate;
+	u8        DialMode;
+	u8        ExtraModemInitString[LENGTH_OF_EXTRA_MODEM_STRING];
+	FOURBYTES   PowerOnDelay;
+	FOURBYTES   SignalDelay;
+	FOURBYTES   RingDelay;
+	FOURBYTES   CDDelay;
+	FOURBYTES   ResponseDelay;
+	FOURBYTES   HangupDelay;
+	FOURBYTES   ConnectTimeOut;
+	FOURBYTES   DetectTimeOut;
+}   RCS_MODEM_CFG;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_MODEM_CFG       Data;
+}   RCS_FN_READ_MODEM_CFG_COMMAND;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_MODEM_CFG       Data;
+}   RCS_FN_MODIFY_MODEM_CFG_COMMAND;
+
+/*  SNMP Destination Commands   */
+typedef struct
+{
+	u8        index;
+	FOURBYTES   IP;
+	u8        ComunityName[LENGTH_OF_COMUNITY_NAME];
+}   RCS_SNMP_DEST_CFG;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_SNMP_DEST_CFG   Data;
+}   RCS_FN_ADD_SNMP_DESTINATION_COMMAND;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_SNMP_DEST_CFG   Data;
+}   RCS_FN_READ_SNMP_DESTINATION_COMMAND;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_SNMP_DEST_CFG   Data;
+}   RCS_FN_MODIFY_SNMP_DESTINATION_COMMAND;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_SNMP_DEST_CFG   Data;
+}   RCS_FN_DELETE_SNMP_DESTINATION_COMMAND;
+
+/*  Management Console Commands */
+typedef struct
+{
+	u8    index;
+	u8    PhoneNumber[LENGTH_OF_PHONENUMBER];
+}   RCS_MGNT_CON_CFG;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_MGNT_CON_CFG    Data;
+}   RCS_FN_ADD_MANAGEMENT_CONSOLE_COMMAND;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_MGNT_CON_CFG    Data;
+}   RCS_FN_READ_MANAGEMENT_CONSOLE_COMMAND;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_MGNT_CON_CFG    Data;
+}   RCS_FN_MODIFY_MANAGEMENT_CONSOLE_COMMAND;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_MGNT_CON_CFG    Data;
+}   RCS_FN_DELETE_MANAGEMENT_CONSOLE_COMMAND;
+
+/*  Alert Table Commands    */
+typedef struct
+{
+	u8    AlertMethod [3];
+	u8    ReservedForExtraMethods [5];
+	u8    RetriesMethod [3];
+	u8    ReservedForExtraMethodRetries [5];
+	TWOBYTES    NotificationFrequency;
+}   RCS_ALERT_ORDER_TABLE_CFG;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_ALERT_ORDER_TABLE_CFG   Data;
+}   RCS_FN_READ_ALERT_TABLE_COMMAND;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_ALERT_ORDER_TABLE_CFG   Data;
+}   RCS_FN_MODIFY_ALERT_TABLE_COMMAND;
+
+/*  Force Save Config Command   */
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+}   RCS_FN_FORCE_SAVE_CONFIG_COMMAND;
+
+/*  Admin Test Page Command     */
+typedef struct {
+	u8    Index;
+}   RCS_TEST_PAGE_INDEX;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_TEST_PAGE_INDEX Data;
+}   RCS_ADMIN_TEST_PAGE_COMMAND;
+
+/*  PPP Config Commands     */
+typedef struct
+{
+	FOURBYTES   IPPoolStart;
+}   RCS_PPP_CFG;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_PPP_CFG         Data;
+}   RCS_FN_READ_PPP_CFG_COMMAND;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_PPP_CFG         Data;
+}   RCS_FN_MODIFY_PPP_CFG_COMMAND;
+
+/*  Dialout Config Commands     */
+typedef struct
+{
+	char    Alias [LENGTH_OF_DIALOUT_ALIAS];       // Dial out Alias
+	char    Password [LENGTH_OF_DIALOUT_PASSWORD]; // Dial out Password
+}   RCS_DIALOUT_CFG;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_DIALOUT_CFG     Data;
+}   RCS_FN_READ_DIALOUT_CFG_COMMAND;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_DIALOUT_CFG     Data;
+}   RCS_FN_MODIFY_DIALOUT_CFG_COMMAND;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+}   RCS_FN_RESTORE_FACTORY_DEFAULTS_COMMAND;
+
+//raja
+/*  Admin Test Email Command     */
+typedef struct {
+	u8    Index;
+	u8    Reserved[15];
+}   RCS_TEST_EMAIL_ARGS;
+
+typedef struct {
+	RCS_COMMAND_PACKET  RCSCmdPkt;
+	RCS_TEST_EMAIL_ARGS Data;
+}   RCS_FN_TEST_EMAIL_COMMAND;
+
+
+#endif
+
diff -urNp linux-5000/drivers/addon/megarac/rcsdbg.h linux-5010/drivers/addon/megarac/rcsdbg.h
--- linux-5000/drivers/addon/megarac/rcsdbg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/rcsdbg.h	
@@ -0,0 +1,175 @@
+#ifndef __RCSDBG_H__
+#define __RCSDBG_H__
+
+#include "rcs.h"
+#include "rtc.h"
+#include "dbglog.h"
+/************************************************************************/
+/**************  REMOTE DEBUG COMMANDS **********************************/
+/************************************************************************/
+
+/*******************************GROUP 100**************************/
+#define RCS_DEBUG_SWITCH_VIDEO_PRINT                 0X1000
+#define RCS_DEBUG_SET_VIDEO_DEBUG_MODE               0x1001
+#define RCS_DEBUG_GET_LATEST_ERROR_LOG               0x1002
+#define RCS_DEBUG_GET_ERROR_LOG_ENTRIES              0x1003
+#define RCS_DEBUG_GET_CHECKPT_HEADER                 0x1004
+#define RCS_DEBUG_CLEAR_CHECKPOINT_LOG               0x1005
+#define RCS_DEBUG_GET_NO_OF_MODULES                  0x1006
+#define RCS_DEBUG_GET_MODULE_NAMES                   0x1007
+#define RCS_DEBUG_GET_DESC_STRINGS                   0x1008
+#define RCS_DEBUG_SET_DBGPRINT_MASKS                 0x1009
+#define RCS_DEBUG_CLEAR_VIDEO_SCREEN                 0x100a
+                                                           
+/************No of funtions beginning with 100**********************/
+#define FNS_100 11
+/*******************************************************************/
+
+
+
+typedef struct _GETMODULENAMESARGS
+{
+RCS_COMMAND_PACKET CmdHeader;
+char ModuleNames[MAX_MODULES][20];
+}
+GETMODULENAMESARGS;
+
+
+typedef struct _GETDESCSTRINGSARGS
+{
+RCS_COMMAND_PACKET CmdHeader;
+int ModuleNo; //input
+int NoOfStrings; // given by firmware
+char Strings[1];
+}
+GETDESCSTRINGSARGS;
+
+typedef struct _DBGPRINTMASKS
+{
+RCS_COMMAND_PACKET CmdHeader;
+char Masks[MAX_MODULES];
+}
+DBGPRINTMASKS;
+
+
+typedef struct _RCS_DBG_SwitchVideoPrintArgs
+{
+   int   Mode;
+}RCS_DBG_SWITCH_VIDEO_PRINT_ARGS;
+
+typedef struct _RCS_DBG_SwitchVideoPrintCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_DBG_SWITCH_VIDEO_PRINT_ARGS Data;
+}RCS_DBG_SWITCH_VIDEO_PRINT_COMMAND;
+
+typedef struct _RCS_DBG_SetVideoDebugModeArgs
+{
+   int   Mode;
+}RCS_DBG_SET_VIDEO_DEBUG_MODE_ARGS;
+
+typedef struct _RCS_DBG_SetVideoDebugModeCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_DBG_SET_VIDEO_DEBUG_MODE_ARGS Data;
+}RCS_DBG_SET_VIDEO_DEBUG_MODE_COMMAND;
+
+typedef struct _RCS_DBG_GetLatestErrorLogArgs
+{
+   long NoOfEntriesReqd;
+   unsigned long Buffer[1];
+}RCS_DBG_GET_LATEST_ERROR_LOG_ARGS;
+
+typedef struct _RCS_DBG_GetLatestErrorLogCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_DBG_GET_LATEST_ERROR_LOG_ARGS Data;
+}RCS_DBG_GET_LATEST_ERROR_LOG_COMMAND;
+
+typedef struct _RCS_DBG_GetErrorLogEntriesArgs
+{
+   long  StartFrom;
+   long  NoOfEntriesReqd;
+   unsigned long Buffer[1];
+}RCS_DBG_GET_ERROR_LOG_ENTRIES_ARGS;
+
+typedef struct _RCS_DBG_GetErrorLogEntriesCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_DBG_GET_ERROR_LOG_ENTRIES_ARGS Data;
+}RCS_DBG_GET_ERROR_LOG_ENTRIES_COMMAND;
+
+typedef struct _RCS_DBG_GetCheckptHeaderArgs
+{
+   unsigned long  head;
+   unsigned long* LogTable;
+   unsigned long  TotalNoOfElementsNow;
+   unsigned long  MaximumNoOfElements;
+   unsigned long  HeaderChecksum;
+   unsigned long  Reserved1;
+   unsigned long  Reserved2;
+}RCS_DBG_GET_CHECKPT_HEADER_ARGS;
+
+typedef struct _RCS_DBG_GetCheckptHeaderCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_DBG_GET_CHECKPT_HEADER_ARGS Data;
+}RCS_DBG_GET_CHECKPT_HEADER_COMMAND;
+
+typedef struct _RCS_DBG_ClearCheckpointLogCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+}RCS_DBG_CLEAR_CHECKPOINT_LOG_COMMAND;
+
+typedef struct _RCS_DBG_GetNoOfModulesArgs
+{
+   int   NoOfModules;
+}RCS_DBG_GET_NO_OF_MODULES_ARGS;
+
+typedef struct _RCS_DBG_GetNoOfModulesCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_DBG_GET_NO_OF_MODULES_ARGS Data;
+}RCS_DBG_GET_NO_OF_MODULES_COMMAND;
+
+typedef struct _RCS_DBG_GetModuleNamesArgs
+{
+   char ModuleNames[MAX_MODULES][20];
+}RCS_DBG_GET_MODULE_NAMES_ARGS;
+
+typedef struct _RCS_DBG_GetModuleNamesCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_DBG_GET_MODULE_NAMES_ARGS Data;
+}RCS_DBG_GET_MODULE_NAMES_COMMAND;
+
+typedef struct _RCS_DBG_GetDescStringsArgs
+{
+   int ModuleNo;     //input
+   int NoOfStrings;  // given by firmware
+   char Strings[1];
+}RCS_DBG_GET_DESC_STRINGS_ARGS;
+
+typedef struct _RCS_DBG_GetDescStringsCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_DBG_GET_DESC_STRINGS_ARGS Data;
+}RCS_DBG_GET_DESC_STRINGS_COMMAND;
+
+typedef struct _RCS_DBG_SetDbgprintMasksArgs
+{
+   char Masks[MAX_MODULES];
+}RCS_DBG_SET_DBGPRINT_MASKS_ARGS;
+
+typedef struct _RCS_DBG_SetDbgprintMasksCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_DBG_SET_DBGPRINT_MASKS_ARGS Data;
+}RCS_DBG_SET_DBGPRINT_MASKS_COMMAND;
+
+typedef struct _RCS_DBG_ClearVideoScreenCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+}RCS_DBG_CLEAR_VIDEO_SCREEN_COMMAND;
+
+#endif
diff -urNp linux-5000/drivers/addon/megarac/rcsdiag.h linux-5010/drivers/addon/megarac/rcsdiag.h
--- linux-5000/drivers/addon/megarac/rcsdiag.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/rcsdiag.h	
@@ -0,0 +1,247 @@
+/*******************************************************************
+
+    File Name   :   RCSDIAG.H
+
+    Author      :   K.V.Subash & Parthiban Baskar
+
+    Date        :   8 December 1997
+
+    Purpose     :   RCS DIAg cmd grp codes
+
+	Copyright	:	American Megatrends Inc., 1997-1998
+
+********************************************************************/
+
+#ifndef __RCSDIAG_H__
+#define __RCSDIAG_H__
+
+
+
+/************************************************************************/
+/**************  REMOTE DIAGNOSTICS COMMANDS ****************************/
+/************************************************************************/
+
+/*******************************GROUP 080**************************/
+#define  RCS_DIAG_READ_BYTE            0x0801
+#define  RCS_DIAG_WRITE_BYTE           0x0802
+#define  RCS_DIAG_READ_WORD            0x0803
+#define  RCS_DIAG_WRITE_WORD           0x0804
+#define  RCS_DIAG_READ_DWORD           0x0805
+#define  RCS_DIAG_WRITE_DWORD          0x0806
+#define  RCS_DIAG_DUMP_BLOCK           0x0807
+#define  RCS_DIAG_SCAN_MEMORY          0x0808
+/************No of funtions beginning with 080**********************/
+#define FNS_080 8
+/*******************************************************************/
+
+
+/*******************************GROUP 081**************************/
+
+/************No of funtions beginning with 081**********************/
+#define FNS_081 0
+/*******************************************************************/
+
+
+/*******************************GROUP 082**************************/
+
+/************No of funtions beginning with 082**********************/
+#define FNS_082 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 083**************************/
+
+/************No of funtions beginning with 083**********************/
+#define FNS_083 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 084**************************/
+
+/************No of funtions beginning with 084**********************/
+#define FNS_084 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 085**************************/
+
+/************No of funtions beginning with 085**********************/
+#define FNS_085 0
+/*******************************************************************/
+
+
+/*******************************GROUP 086**************************/
+
+/************No of funtions beginning with 086**********************/
+#define FNS_086 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 087**************************/
+
+/************No of funtions beginning with 087**********************/
+#define FNS_087 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 088**************************/
+
+/************No of funtions beginning with 088**********************/
+#define FNS_088 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 089**************************/
+
+/************No of funtions beginning with 089**********************/
+#define FNS_089 0
+/*******************************************************************/
+
+
+/*******************************GROUP 08A**************************/
+
+/************No of funtions beginning with 08A**********************/
+#define FNS_08A 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 08B**************************/
+
+/************No of funtions beginning with 08B**********************/
+#define FNS_08B 0
+/*******************************************************************/
+
+
+/*******************************GROUP 08C**************************/
+
+/************No of funtions beginning with 08C**********************/
+#define FNS_08C 0
+/*******************************************************************/
+
+
+
+
+/*******************************GROUP 08D**************************/
+
+/************No of funtions beginning with 08D**********************/
+#define FNS_08D 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 08E**************************/
+
+/************No of funtions beginning with 08E**********************/
+#define FNS_08E 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 08F**************************/
+
+/************No of funtions beginning with 08F**********************/
+#define FNS_08F 0
+/*******************************************************************/
+
+
+
+
+
+/************************************************************************/
+/**************  REMOTE CONSOLE DIAGNOSTICS COMMANDS END ****************/
+/************************************************************************/
+
+/************************************************************************/
+/*************  REMOTE CONSOLE DIAGNOSTICS STRUCTURES *******************/
+/************************************************************************/
+
+//these structures define arguments to the various functions.
+//when a RCS Command Packet is put in the RCS Q , It usually
+//is appended with another argument structure for a specific function
+//The CCB Handler sees that it is a RCS CCB .But since the total length 
+//along with the Arguments for the various RCS Functions is variable
+//the length of the total packet is put in the CCB Header.It then writes
+//that many bytes into the RCS Q.
+//The RCS Dispatcher takes only the RCS COMMAND PACKET header
+//and then branches to the neccessary function. 
+//Then the function knows how many arguments to read and reads them from
+//the RCS Queue.
+
+typedef struct _RCS_DIAG_ReadWriteByteArgs
+{
+   unsigned long  Addr;
+   unsigned short Attributes;
+   unsigned char  Data;
+}RCS_DIAG_RW_BYTE_ARGS;
+
+typedef struct _RCS_DIAG_ReadWriteByteCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_DIAG_RW_BYTE_ARGS Data;
+}RCS_DIAG_RW_BYTE_COMMAND;
+
+typedef struct _RCS_DIAG_ReadWriteWordArgs
+{
+   unsigned long  Addr;
+   unsigned short Attributes;
+   unsigned short Data;
+}RCS_DIAG_RW_WORD_ARGS;
+
+typedef struct _RCS_DIAG_ReadWriteWordCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_DIAG_RW_WORD_ARGS Data;
+}RCS_DIAG_RW_WORD_COMMAND;
+
+typedef struct _RCS_DIAG_ReadWriteDwordArgs
+{
+   unsigned long  Addr;
+   unsigned short Attributes;
+   unsigned long  Data;
+}RCS_DIAG_RW_DWORD_ARGS;
+
+typedef struct _RCS_DIAG_ReadWriteDwordCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_DIAG_RW_DWORD_ARGS Data;
+}RCS_DIAG_RW_DWORD_COMMAND;
+
+typedef struct _RCS_DIAG_DumpBlockArgs
+{
+   unsigned long  Addr;
+   unsigned short Attributes;
+   unsigned short Length;
+   unsigned char	Data[1];
+}RCS_DIAG_DUMP_BLOCK_ARGS;
+
+typedef struct _RCS_DIAG_DumpBlockCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_DIAG_DUMP_BLOCK_ARGS Data;
+}RCS_DIAG_DUMP_BLOCK_COMMAND;
+
+typedef struct _RCS_DIAG_ScanMemoryArgs
+{
+   unsigned long  StartAddr;
+   unsigned long  EndAddr;
+   unsigned short Attributes;
+   unsigned char  PatternLength;
+   unsigned char  Occurance;
+   unsigned long  FoundAddr;
+   unsigned char	Data[1];
+}RCS_DIAG_SCAN_MEMORY_ARGS;
+
+typedef struct _RCS_DIAG_ScanMemoryCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_DIAG_SCAN_MEMORY_ARGS Data;
+}RCS_DIAG_SCAN_MEMORY_COMMAND;
+
+#endif
diff -urNp linux-5000/drivers/addon/megarac/rcs.h linux-5010/drivers/addon/megarac/rcs.h
--- linux-5000/drivers/addon/megarac/rcs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/rcs.h	
@@ -0,0 +1,90 @@
+/*******************************************************************
+
+    File Name   :   RCS.H
+
+    Author      :   K.V.Subash & Parthiban Baskar
+
+    Date        :   8 December 1997
+
+    Purpose     :   Data types and structures used by the RCS
+
+	Copyright	:	American Megatrends Inc., 1997-1998
+
+********************************************************************/
+#ifndef __RCS_H__
+#define __RCS_H__
+
+#include "dtypes.h"
+
+
+/****************RCS COMMAND GROUPS****************/
+#define RCS_CMD                          0x0000
+#define RCS_CONN                         0x0100
+#define RCS_RED                          0x0200
+#define RCS_ADMIN                        0x0400
+#define RCS_DIAG                         0x0800
+#define RCS_USR                          0x8000
+/**************************************************/
+
+/********************RCS CHANNELS*******************/
+#define RCS_CHANNEL_HOST 0
+#define RCS_CHANNEL_REMOTE 1
+#define RCS_CHANNEL_SELF_INITIATED  2
+/**************************************************/
+
+
+typedef struct _RCSCommandPacket
+{
+    union
+    {
+        TWOBYTES FullCmd;
+        struct
+        {
+            u8 CmdCode;
+            u8 CmdGrp;
+        } CmdBits;
+    } Cmd;
+    union
+    {
+        TWOBYTES FullStatus;
+        struct
+        {
+            u8 StatusCode;
+            u8 StatusGrp;
+        } StatusBits;
+     } Status;
+
+     TWOBYTES Length;
+     u8   Channel;
+     u8   Entry;
+     FOURBYTES Handle;
+     u8 Reserved[4];
+}
+RCS_COMMAND_PACKET;
+
+
+#endif
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff -urNp linux-5000/drivers/addon/megarac/rcshhf.h linux-5010/drivers/addon/megarac/rcshhf.h
--- linux-5000/drivers/addon/megarac/rcshhf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/rcshhf.h	
@@ -0,0 +1,142 @@
+//
+//  Definition file for Hhf structure
+//
+
+#ifndef __RCSHHF_H__
+#define __RCSHHF_H__
+
+typedef struct GET_NUM_CATEGORY_TYPE_tag
+{
+	u8 CatNum;
+}GET_NUM_CATEGORY_TYPE;
+
+typedef struct NO_OF_HHF_CAT_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	GET_NUM_CATEGORY_TYPE info;
+}NO_OF_HHF_CAT_PACKET;
+
+typedef struct GET_CATEGORY_NAME_TYPE_tag
+{
+	u8 CatNum;
+	char CatName[32];
+}GET_CATEGORY_NAME_TYPE;
+
+typedef struct HHF_CAT_NAME_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	GET_CATEGORY_NAME_TYPE info;
+}HHF_CAT_NAME_PACKET;
+
+typedef struct GET_NUM_SUBDIVISIONS_TYPE_tag
+{
+	u8 CatNum;
+	u8 SubNum;
+}GET_NUM_SUBDIVISIONS_TYPE;
+
+typedef struct NO_OF_HHF_SUBDIV_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	GET_NUM_SUBDIVISIONS_TYPE info;
+}NO_OF_HHF_SUBDIV_PACKET;
+
+typedef struct GET_SUBDIV_NAME_TYPE_tag
+{
+	u8 CatNum;
+	u8 SubNum;
+	char SubName[32];
+}GET_SUBDIV_NAME_TYPE;
+
+typedef struct HHF_SUBDIV_NAME_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	GET_SUBDIV_NAME_TYPE info;
+}HHF_SUBDIV_NAME_PACKET;
+
+typedef struct GET_HHF_VALUE_TYPE_tag
+{
+	u8 CatNum;
+	u8 SubNum;
+	u8 HostID;
+	u8 ID;
+	u8 HhfValue[32];
+	u8 HhfUnit[16];
+}GET_HHF_VALUE_TYPE;
+
+typedef struct HHF_VALUE_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	GET_HHF_VALUE_TYPE info;
+}HHF_VALUE_PACKET;
+
+typedef struct EN_DIS_HHF_MONITOR_TYPE_tag
+{
+	u8 CatNum;
+	u8 SubNum;
+	u8 Mode;
+}EN_DIS_HHF_MONITOR_TYPE;
+
+typedef struct ENABLE_HHF_MONITOR_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	EN_DIS_HHF_MONITOR_TYPE info;
+}ENABLE_HHF_MONITOR_PACKET;
+
+typedef struct EN_DIS_HHF_THRES_TYPE_tag
+{
+	u8 CatNum;
+	u8 SubNum;
+	u8 Mode;
+}EN_DIS_HHF_THRES_TYPE;
+
+typedef struct ENABLE_HHF_THRESHOLD_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	EN_DIS_HHF_THRES_TYPE info;
+}ENABLE_HHF_THRESHOLD_PACKET;
+
+typedef struct HHF_THRES_TYPE_tag
+{
+	u8 CatNum;
+	u8 SubNum;
+	u8 LowAlertLimit[32];
+	u8 HighAlertLimit[32];
+	u8 LowWarnLimit[32];
+	u8 HighWarnLimit[32];
+}HHF_THRES_TYPE;
+
+typedef struct READ_HHF_THRESHOLD_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	HHF_THRES_TYPE info;
+}READ_HHF_THRESHOLD_PACKET;
+
+typedef struct MODIFY_HHF_THRESHOLD_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	HHF_THRES_TYPE info;
+}MODIFY_HHF_THRESHOLD_PACKET;
+
+typedef struct HHF_SCHED_TYPE_tag
+{
+	u8 CatNum;
+	u8 SubNum;
+	unsigned short Attributes;
+	unsigned long Period;
+}HHF_SCHED_TYPE;
+
+typedef struct READ_HHF_SCHEDULE_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	HHF_SCHED_TYPE info;
+}READ_HHF_SCHEDULE_PACKET;
+
+typedef struct MODIFY_HHF_SCHEDULE_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	HHF_SCHED_TYPE info;
+}MODIFY_HHF_SCHEDULE_PACKET;
+
+
+#endif
+
diff -urNp linux-5000/drivers/addon/megarac/rcsic.h linux-5010/drivers/addon/megarac/rcsic.h
--- linux-5000/drivers/addon/megarac/rcsic.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/rcsic.h	
@@ -0,0 +1,480 @@
+/*******************************************************************
+
+    File Name   :   RCSIC.H
+
+    Author      :   K.V.Subash & Parthiban Baskar
+
+    Date        :   8 December 1997
+
+    Purpose     :   RCS Info And Ctrl Cmd grp codes
+
+    Copyright   :   American Megatrends Inc., 1997-1998
+
+********************************************************************/
+
+#ifndef __RCSIC_H__
+#define __RCSIC_H__
+
+#include "rtc.h"
+/************************************************************************/
+/*******  REMOTE CONSOLE INFORMATION AND CONTROL COMMANDS  **************/
+/************************************************************************/
+
+
+/*******************************GROUP 000**************************/
+#define RCS_CMD_GET_VERSION                 0x0000
+#define RCS_CMD_GET_MEGARAC_INFO            0x0001
+#define RCS_CMD_GET_TOTAL_NO_OF_EVENTS      0x0002
+#define RCS_CMD_MOST_RECENT_EVENT_ENTRIES   0x0003
+#define RCS_CMD_MOST_OLD_EVENT_ENTRIES      0x0004
+#define RCS_CMD_CLEAR_EVENT_LOG             0x0005
+#define RCS_CMD_GET_CURRENT_POST_LOG        0x0006
+#define RCS_CMD_GET_ALL_POST_LOGS           0x0007
+#define RCS_CMD_CLEAR_ALL_POST_LOGS         0x0008
+/************No of funtions beginning with 000**********************/
+#define FNS_000 9
+/*******************************************************************/
+
+
+
+
+/*******************************GROUP 001**************************/
+
+#define RCS_CMD_GET_DMI_INFO                 0x0010
+#define RCS_CMD_GET_IPMI_INFO                0x0011
+#define RCS_CMD_REPORT_DMI_INFO              0x0012
+#define RCS_CMD_GET_OS_STATUS                0x0013
+#define RCS_CMD_GET_HOST_STATUS              0x0014
+#define RCS_CMD_GET_GENERIC_DATA             0x0015
+#define RCS_CMD_REPORT_GENERIC_DATA          0x0016
+/************No of funtions beginning with 001**********************/
+#define FNS_001 7
+/*******************************************************************/
+
+
+
+
+/*******************************GROUP 002**************************/
+#define RCS_CMD_BATT_STATUS              0x0020
+/************No of funtions beginning with 002**********************/
+#define FNS_002 1
+/*******************************************************************/
+
+
+
+/*******************************GROUP 003**************************/
+#define RCS_CMD_GET_HHF_CATEGORIES          0X0030
+#define RCS_CMD_GET_HHF_CATEGORY_NAME       0x0031
+#define RCS_CMD_GET_HHF_SUBDIVISIONS        0x0032
+#define RCS_CMD_GET_HHF_SUBDIVISION_NAME    0x0033
+#define RCS_CMD_GET_HHF_VALUE               0x0034
+#define RCS_CMD_GET_SDK_CATEGORIES          0X0035
+#define RCS_CMD_GET_SDK_CATEGORY_NAME       0x0036
+#define RCS_CMD_GET_SDK_SUBDIVISIONS        0x0037
+#define RCS_CMD_GET_SDK_SUBDIVISION_NAME    0x0038
+#define RCS_CMD_GET_SDK_VALUE               0x0039
+#define RCS_CMD_READ_SDK_CONFIG             0x003A
+#define RCS_CMD_MODIFY_SDK_CONFIG           0x003B
+#define RCS_CMD_I2C_REPEATED_START_ACCESS   0x003C
+/************No of funtions beginning with 003**********************/
+#define FNS_003 13
+/*******************************************************************/
+
+
+/*******************************GROUP 004**************************/
+#define RCS_CMD_SHUTDOWN_OS                  0X0040
+#define RCS_CMD_RESET_HOST                   0X0041
+#define RCS_CMD_POWERCYCLE_HOST              0X0042
+#define RCS_CMD_POWER_ON_OFF                 0X0043
+#define RCS_CMD_RESET_HOST_AFTER_DELAY       0X0044
+#define RCS_CMD_POWERCYCLE_HOST_AFTER_DELAY  0X0045
+#define RCS_CMD_POWER_ON_OFF_AFTER_DELAY     0X0046
+#define RCS_CMD_REPORT_IO_BASE_ADDRESS       0X0047
+/************No of funtions beginning with 004**********************/
+#define FNS_004 8
+/*******************************************************************/
+
+
+
+/*******************************GROUP 005**************************/
+
+/************No of funtions beginning with 005**********************/
+#define FNS_005 0
+/*******************************************************************/
+
+
+/*******************************GROUP 006**************************/
+#define RCS_CMD_LOG_EVENT                    0X0060
+#define RCS_CMD_SEND_ALERT                   0X0061
+
+/************No of funtions beginning with 006**********************/
+#define FNS_006 2
+/*******************************************************************/
+
+
+
+/*******************************GROUP 007**************************/
+#define RCS_CMD_START_HEARTBEAT              0X0070
+#define RCS_CMD_STOP_HEARTBEAT               0X0071
+
+/************No of funtions beginning with 007**********************/
+#define FNS_007 2
+/*******************************************************************/
+
+
+/*******************************GROUP 008**************************/
+
+/************No of funtions beginning with 008**********************/
+#define FNS_008 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 009**************************/
+
+/************No of funtions beginning with 009**********************/
+#define FNS_009 0
+/*******************************************************************/
+
+
+/*******************************GROUP 00A**************************/
+
+/************No of funtions beginning with 00A**********************/
+#define FNS_00A 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 00B**************************/
+
+/************No of funtions beginning with 00B**********************/
+#define FNS_00B 0
+/*******************************************************************/
+
+
+/*******************************GROUP 00C**************************/
+
+/************No of funtions beginning with 00C**********************/
+#define FNS_00C 0
+/*******************************************************************/
+
+
+
+
+/*******************************GROUP 00D**************************/
+
+/************No of funtions beginning with 00D**********************/
+#define FNS_00D 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 00E**************************/
+
+/************No of funtions beginning with 00E**********************/
+#define FNS_00E 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 00F**************************/
+
+/************No of funtions beginning with 00F**********************/
+#define FNS_00F 0
+
+/*******************************************************************/
+
+#define MAX_POWER_OR_RESET_DELAY    1800
+
+
+
+
+
+
+
+/************************************************************************/
+/*******  REMOTE CONSOLE INFORMATION AND CONTROL COMMANDS END************/
+/************************************************************************/
+
+
+/************************************************************************/
+/*******  REMOTE CONSOLE INFORMATION AND CONTROL STRUCTURES*****/
+/************************************************************************/
+
+//these structures define arguments to the various functions.
+//when a RCS Command Packet is put in the RCS Q , It usually
+//is appended with another argument structure for a specific function
+//The CCB Handler sees that it is a RCS CCB .But since the total length
+//along with the Arguments for the various RCS Functions is variable
+//the length of the total packet is put in the CCB Header.It then writes
+//that many bytes into the RCS Q.
+//The RCS Dispatcher takes only the RCS COMMAND PACKET header
+//and then branches to the neccessary function.
+//Then the function knows how many arguments to read and reads them from
+//the RCS Queue.
+
+
+typedef struct _RCS_FN_GetMostRecentNEventsArgs
+{
+    TWOBYTES NoOfEvents;
+    u8 EventBuffer[1];
+    //the buffer to hold the events follows immediately after this.
+    //so this is made of size 1 . Actually it can be as long as neccessary
+}
+RCS_FN_GET_MOST_RECENT_N_EVENTS_ARGS;
+
+typedef struct _RCS_FN_GetMostRecentNEventsCommand
+{
+    RCS_COMMAND_PACKET RCSCmdPkt;
+    TWOBYTES NoOfEvents;
+    u8 EventBuffer[1];
+}
+RCS_FN_GET_MOST_RECENT_N_EVENTS_COMMAND;
+
+
+typedef struct _RCS_FNGetMostOldNEventsArgs
+{
+    TWOBYTES NoOfEvents;
+    u8 EventBuffer[1];
+}
+RCS_FN_GET_MOST_OLD_N_EVENTS_ARGS;
+
+typedef struct _RCS_FNGetMostOldNEventsCommand
+{
+    RCS_COMMAND_PACKET RCSCmdPkt;
+    TWOBYTES NoOfEvents;
+    u8 EventBuffer[1];
+}
+RCS_FN_GET_MOST_OLD_N_EVENTS_COMMAND;
+
+
+typedef struct _RCS_FN_GetTotalNoOfEventsArgs
+{
+    TWOBYTES NoOfEvents;
+}
+RCS_FN_GET_TOTAL_NO_OF_EVENTS_ARGS;
+
+typedef struct _RCS_FN_GetTotalNoOfEventsCommand
+{
+    RCS_COMMAND_PACKET RCSCmdPkt;
+    TWOBYTES NoOfEvents;
+}
+RCS_FN_GET_TOTAL_NO_OF_EVENTS_COMMAND;
+
+
+typedef struct _RCS_FN_PowerOnOffAfterDelayCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   u8     Power;
+   TWOBYTES Delay;
+}
+RCS_FN_POWER_ON_OFF_AFTER_DELAY_COMMAND;
+
+// mjb 12-16-99
+typedef struct _RCS_FN_PowerCycleHostAfterDelayArgs
+{
+   TWOBYTES Delay;      // Delay in seconds
+}RCS_FN_POWERCYCLE_HOST_AFTER_DELAY_ARGS;
+
+typedef struct _RCS_FN_PowerCycleHostAfterDelayCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_FN_POWERCYCLE_HOST_AFTER_DELAY_ARGS Data;
+}
+RCS_FN_POWERCYCLE_HOST_AFTER_DELAY_COMMAND;
+
+typedef struct _RCS_FN_ResetHostAfterDelayArgs
+{
+   TWOBYTES Delay;      // Delay in seconds
+}RCS_FN_RESET_HOST_AFTER_DELAY_ARGS;
+
+typedef struct _RCS_FN_ResetHostAfterDelayCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_FN_RESET_HOST_AFTER_DELAY_ARGS Data;
+}
+RCS_FN_RESET_HOST_AFTER_DELAY_COMMAND;
+
+//
+// The following are alternative structures that can be used for the
+// POWER_ON_OFF_AFTER_DELAY command.
+//
+typedef struct _RCS_FN_PowerOnOffWithDelayArgs
+{
+   u8     Power;      // 0 = Off, 1 = On
+   TWOBYTES Delay;      // Delay in seconds
+}RCS_FN_POWER_ON_OFF_WITH_DELAY_ARGS;
+
+typedef struct _RCS_FN_PowerOnOffWithDelayCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_FN_POWER_ON_OFF_WITH_DELAY_ARGS Data;
+}
+RCS_FN_POWER_ON_OFF_WITH_DELAY_COMMAND;
+
+// end mjb 12-16-99
+
+typedef struct _RCS_FN_GetDMIInfoArgs
+{
+   unsigned short NumStructs;
+   unsigned char  BCDRevision;
+   unsigned char  Reserved;
+   unsigned short DMIDataLen;
+   unsigned char  DMIData[1];
+}RCS_FN_GET_DMI_INFO_ARGS;
+
+typedef struct _RCS_FN_GetDMIInfoCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_FN_GET_DMI_INFO_ARGS Data;
+}RCS_FN_GET_DMI_INFO_COMMAND;
+
+typedef struct _RCS_FN_GetIPMIInfoArgs
+{
+   unsigned char  DestAddr;     /* Input Only . Unaltered on Return */
+   unsigned char  DestLun;      /* Input Only . Unaltered on Return */
+   unsigned char  NetFn;        /* Input Only . Unaltered on Return */
+   unsigned char  Cmd;          /* Input Only . Unaltered on Return */
+   unsigned char  RetCode;      /* Output - IPMI Return Code        */
+   int            BufLen;       /* Input Only . IPMIData Max Size   */
+   int            DataLen;      /* Input & Output - Data in IPMIData*/
+   char           IPMIData[1];  /* Input & Output - IPMI Data       */    
+}RCS_FN_GET_IPMI_INFO_ARGS;
+
+typedef struct _RCS_FN_GetIPMIInfoCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_FN_GET_IPMI_INFO_ARGS Data;
+}RCS_FN_GET_IPMI_INFO_COMMAND;
+
+
+typedef struct _RCS_FN_GetOSStatusArgs
+{
+   unsigned short HostOSStatus;
+}RCS_FN_GET_OS_STATUS_ARGS;
+
+typedef struct _RCS_FN_GetOSStatusCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_FN_GET_OS_STATUS_ARGS Data;
+}RCS_FN_GET_OS_STATUS_COMMAND;
+
+typedef struct _RCS_FN_GetHostStatusArgs
+{
+   unsigned short HostStatus;
+}RCS_FN_GET_HOST_STATUS_ARGS;
+
+typedef struct _RCS_FN_GetHostStatusCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_FN_GET_HOST_STATUS_ARGS Data;
+}RCS_FN_GET_HOST_STATUS_COMMAND;
+
+typedef struct _RCS_FN_ReportIoBaseAddressArgs
+{
+   unsigned long IoBaseAddress;
+}RCS_FN_REPORT_IO_BASE_ADDRESS_ARGS;
+
+typedef struct _RCS_FN_ReportIoBaseAddressCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_FN_REPORT_IO_BASE_ADDRESS_ARGS Data;
+}RCS_FN_REPORT_IO_BASE_ADDRESS_COMMAND;
+
+#define MAX_GENERIC_DATA_SIZE 4096
+
+typedef struct _RCS_FN_ReportGenericDataArgs
+{
+   unsigned short Index;
+   unsigned short Length;
+   unsigned char  Data[1];
+}RCS_FN_REPORT_GENERIC_DATA_ARGS;
+
+typedef struct _RCS_FN_ReportGenericDataCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_FN_REPORT_GENERIC_DATA_ARGS Data;
+}RCS_FN_REPORT_GENERIC_DATA_COMMAND;
+
+typedef struct _RCS_FN_GetGenericDataArgs
+{
+   unsigned short Index;
+   unsigned short Length;
+   unsigned char  Data[1];
+}RCS_FN_GET_GENERIC_DATA_ARGS;
+
+typedef struct _RCS_FN_GetGenericDataCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_FN_GET_GENERIC_DATA_ARGS Data;
+}RCS_FN_GET_GENERIC_DATA_COMMAND;
+
+typedef struct _RCS_FN_GetCurrentPostLogArgs
+{
+   TWOBYTES NumOfCodes;
+   u8     Log[1];
+}RCS_FN_GET_CURRENT_POST_LOG_ARGS;
+
+typedef struct _RCS_FN_GetCurrentPostLogCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_FN_GET_CURRENT_POST_LOG_ARGS Data;
+}RCS_FN_GET_CURRENT_POST_LOG_COMMAND;
+
+typedef struct _RCS_FN_GetAllPostLogsCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   u8 Data[1];
+}RCS_FN_GET_ALL_POST_LOGS_COMMAND;
+
+
+typedef struct _RCS_FN_LogEventArgs
+{
+   FOURBYTES   EventCode;
+   u8        EventData[100];
+   u8        OtherData[16];
+}RCS_FN_LOG_EVENT_ARGS;
+
+typedef struct _RCS_FN_LogEventCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_FN_LOG_EVENT_ARGS Data;
+}RCS_FN_LOG_EVENT_COMMAND;
+
+typedef struct _RCS_FN_SendAlertArgs
+{
+   FOURBYTES AlertCode;
+   u8 AlertData[100];
+   u8 OtherData[16];
+}RCS_FN_SEND_ALERT_ARGS;
+
+typedef struct _RCS_FN_SendAlertCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_FN_SEND_ALERT_ARGS Data;
+}RCS_FN_SEND_ALERT_COMMAND;
+
+
+typedef struct _RCS_FN_StartHeartbeatArgs
+{
+   FOURBYTES   HeartBeatPeriod;
+   u8        Reserved[12];
+}RCS_FN_START_HEARTBEAT_ARGS;
+
+typedef struct _RCS_FN_StartHeartbeatCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_FN_START_HEARTBEAT_ARGS Data;
+}RCS_FN_START_HEARTBEAT_COMMAND;
+
+typedef struct _RCS_FN_StopCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+}RCS_FN_STOP_HEARTBEAT_COMMAND;
+
+typedef struct _RCS_FN_ClearAllPostLogsCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+}RCS_FN_CLEAR_ALL_POST_LOGS_COMMAND;
+
+#endif
diff -urNp linux-5000/drivers/addon/megarac/rcsred.h linux-5010/drivers/addon/megarac/rcsred.h
--- linux-5000/drivers/addon/megarac/rcsred.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/rcsred.h	
@@ -0,0 +1,335 @@
+/*******************************************************************
+
+    File Name   :   RCSRED.H
+
+    Author      :   K.V.Subash & Parthiban Baskar
+
+    Date        :   8 December 1997
+
+    Purpose     :   RCS Redirection Cmd grp codes
+
+	Copyright	:	American Megatrends Inc., 1997-1998
+
+********************************************************************/
+
+#ifndef __RCSRED_H__
+#define __RCSRED_H__
+#include "rtc.h"
+#include "rcs.h"
+/************************************************************************/
+/**************  REMOTE CONSOLE REDIRECTION COMMANDS ********************/
+/************************************************************************/
+
+
+/*******************************GROUP 020**************************/
+#define RCS_RED_START_CONSOLE_REDIRECTION       0X0200
+#define RCS_RED_STOP_CONSOLE_REDIRECTION        0X0201
+#define RCS_RED_SEND_VIDEO_MODE                 0x0202
+#define RCS_RED_SEND_TEXT_SCREEN                0x0203
+#define RCS_RED_SEND_KEY                        0x0204
+#define RCS_RED_READ_KEY                        0x0205  //Obsolete
+#define RCS_RED_GET_DC_INFO                     0x0206
+#define RCS_RED_SEND_DC_INFO                    0x0207
+#define RCS_RED_GET_DC_PACKET                   0x0208  //Obsolete
+#define RCS_RED_SEND_DC_PACKET                  0x0209
+#define RCS_RED_SEND_DC_COMPLETE                0x020A
+#define RCS_RED_SEND_MOUSE_EVENT                0x020B
+#define RCS_RED_READ_MOUSE_EVENT                0x020C
+#define RCS_RED_GET_TEXT_SCREEN_LOG             0x020D  //Obsolete
+#define RCS_RED_SERVICE_DYRM                    0x020E
+#define RCS_RED_SERVICE_IDRY                    0x020F
+/************No of funtions beginning with 020**********************/
+#define FNS_020 16
+/*******************************************************************/
+
+
+
+/*******************************GROUP 021**************************/
+#define RCS_RED_GET_POST_LOG                    0x0210
+#define RCS_RED_GET_CRASH_SCREEN                0x0211
+#define RCS_RED_PASSTHRU_DATA_TO_HOST           0x0212
+#define RCS_RED_PASSTHRU_DATA_TO_REMOTE         0x0213
+#define RCS_RED_READ_PASSTHRU_DATA              0x0214
+#define RCS_RED_REPORT_CURSOR_POS               0x0215
+/************No of funtions beginning with 021**********************/
+#define FNS_021 6
+/*******************************************************************/
+
+
+/*******************************GROUP 022**************************/
+/************* This Group has Remote Floppy Command ***************/
+# define RCS_RED_START_REMOTE_FLOPPY				0x0220
+# define RCS_RED_STOP_REMOTE_FLOPPY					0x0221
+# define RCS_RED_INT_13H_COMMAND					0x0222
+# define RCS_RED_REMOTE_FLOPPY_COMMAND				0x0223
+# define RCS_RED_REMOTE_FLOPPY_STATUS				0x0224
+
+
+/************No of funtions beginning with 022**********************/
+#define FNS_022 5
+/*******************************************************************/
+
+
+
+/*******************************GROUP 023**************************/
+
+/************No of funtions beginning with 023**********************/
+#define FNS_023 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 024**************************/
+
+/************No of funtions beginning with 024**********************/
+#define FNS_024 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 025**************************/
+
+/************No of funtions beginning with 025**********************/
+#define FNS_025 0
+/*******************************************************************/
+
+
+/*******************************GROUP 026**************************/
+
+/************No of funtions beginning with 026**********************/
+#define FNS_026 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 027**************************/
+
+/************No of funtions beginning with 027**********************/
+#define FNS_027 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 028**************************/
+
+/************No of funtions beginning with 028**********************/
+#define FNS_028 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 029**************************/
+
+/************No of funtions beginning with 029**********************/
+#define FNS_029 0
+/*******************************************************************/
+
+
+/*******************************GROUP 02A**************************/
+
+/************No of funtions beginning with 02A**********************/
+#define FNS_02A 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 02B**************************/
+
+/************No of funtions beginning with 02B**********************/
+#define FNS_02B 0
+/*******************************************************************/
+
+
+/*******************************GROUP 02C**************************/
+
+/************No of funtions beginning with 02C**********************/
+#define FNS_02C 0
+/*******************************************************************/
+
+
+
+
+/*******************************GROUP 02D**************************/
+
+/************No of funtions beginning with 02D**********************/
+#define FNS_02D 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 02E**************************/
+
+/************No of funtions beginning with 02E**********************/
+#define FNS_02E 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 02F**************************/
+
+/************No of funtions beginning with 02F**********************/
+#define FNS_02F 0
+/*******************************************************************/
+
+
+
+
+/************************************************************************/
+/**************  REMOTE CONSOLE REDIRECTION COMMANDS END*****************/
+/************************************************************************/
+
+/************************************************************************/
+/**************  REMOTE CONSOLE REDIRECTION STRUCTURES  *****************/
+/************************************************************************/
+
+typedef struct _CrashScreenLogEntryHeaderTAG
+{
+    DATE_TIME   DateTimeStamp;
+    u8        Rows, Columns;
+    u8        CursorPosRow;
+    u8        CursorPosCol;
+    u8        Reserved [4];
+} CRASH_SCREEN_LOG_ENTRY_HEADER;
+
+typedef struct _CrashScreenLogEntryTAG
+{
+    CRASH_SCREEN_LOG_ENTRY_HEADER   CrashScreenHeader;
+    u8    CrashScreenBuffer [16000];
+} CRASH_SCREEN_LOG_ENTRY;
+
+typedef struct _RCS_FN_GetCrashScreenArgsTag
+{
+   CRASH_SCREEN_LOG_ENTRY CrashScreen;
+}RCS_FN_GET_CRASH_SCREEN_ARGS;
+
+typedef struct _RCS_FN_GetCrashScreenCommandTag
+{
+    RCS_COMMAND_PACKET RCSCmdPkt;
+    RCS_FN_GET_CRASH_SCREEN_ARGS Data;
+} RCS_FN_GET_CRASH_SCREEN_COMMAND;
+
+typedef struct
+{
+    RCS_COMMAND_PACKET  RCSCmdPkt;
+} RCS_FN_START_CONSOLE_REDIRECTION_COMMAND;
+
+typedef struct
+{
+    RCS_COMMAND_PACKET  RCSCmdPkt;
+} RCS_FN_STOP_CONSOLE_REDIRECTION_COMMAND;
+
+typedef struct
+{
+    u8    VideoMode;
+} VIDEO_MODE_ARGS;
+
+typedef struct
+{
+    RCS_COMMAND_PACKET  RCSCmdPkt;
+    VIDEO_MODE_ARGS     Data;
+} RCS_FN_SEND_VIDEO_MODE_COMMAND;
+
+typedef struct _KEY_DATA
+{
+    u8    KeySync;
+    u8    ScanCode;
+    u8    ASCIICode;
+    u8    RAWData [2];
+} KeyData;
+
+typedef struct
+{
+    KeyData KeyCodes [1];           //Variable Length Command
+} SEND_KEY_ARGS;
+
+typedef struct
+{
+    RCS_COMMAND_PACKET  RCSCmdPkt;
+    SEND_KEY_ARGS   Data;
+} RCS_FN_SEND_KEY_COMMAND;
+
+typedef struct
+{
+    RCS_COMMAND_PACKET  RCSCmdPkt;
+} RCS_FN_READ_KEY_COMMAND;          //Obsolete Command
+
+typedef struct
+{
+    RCS_COMMAND_PACKET  RCSCmdPkt;
+} RCS_FN_GET_DC_INFO_COMMAND;
+
+typedef struct
+{
+    u8    RawData [1];            //Variable Length Command
+} SEND_DC_INFO_ARGS;
+
+typedef struct
+{
+    RCS_COMMAND_PACKET  RCSCmdPkt;
+    SEND_DC_INFO_ARGS   Data;
+} RCS_FN_SEND_DC_INFO_COMMAND;
+
+typedef struct
+{
+    RCS_COMMAND_PACKET  RCSCmdPkt;
+} RCS_FN_GET_DC_PACKET_COMMAND;     //Obsolete Command
+
+typedef struct
+{
+    u8    RawData [1];            //Variable Length Command
+} SEND_DC_PACKET_ARGS;
+
+typedef struct
+{
+    RCS_COMMAND_PACKET  RCSCmdPkt;
+    SEND_DC_PACKET_ARGS   Data;
+} RCS_FN_SEND_DC_PACKET_COMMAND;
+
+typedef struct
+{
+    RCS_COMMAND_PACKET  RCSCmdPkt;
+} RCS_FN_SEND_DC_COMPLETE_COMMAND;
+
+typedef struct
+{
+    u8    RawData [1];            //Variable Length Command
+} MOUSE_EVENT_ARGS;
+
+typedef struct
+{
+    RCS_COMMAND_PACKET  RCSCmdPkt;
+    MOUSE_EVENT_ARGS   Data;
+} RCS_FN_SEND_MOUSE_EVENT_COMMAND;
+
+typedef struct
+{
+    RCS_COMMAND_PACKET  RCSCmdPkt;
+    MOUSE_EVENT_ARGS   Data;
+} RCS_FN_READ_MOUSE_EVENT_COMMAND;
+
+typedef struct
+{
+    RCS_COMMAND_PACKET  RCSCmdPkt;
+} RCS_FN_GET_TEST_SCREEN_LOG_COMMAND;   //Obsolete Command
+
+typedef struct
+{
+    RCS_COMMAND_PACKET  RCSCmdPkt;
+} RCS_FN_SERVICE_DYRM_COMMAND;
+
+typedef struct
+{
+    u8    RawData [1];            //Variable Length Command
+} SERVICE_IDRY_ARGS;
+
+typedef struct
+{
+    RCS_COMMAND_PACKET  RCSCmdPkt;
+    SERVICE_IDRY_ARGS   Data;
+} RCS_FN_SERVICE_IDRY_COMMAND;
+
+/************************************************************************/
+/**************  REMOTE CONSOLE REDIRECTION STRUCTURES  END  ************/
+/************************************************************************/
+#endif
+
diff -urNp linux-5000/drivers/addon/megarac/rcssdk.h linux-5010/drivers/addon/megarac/rcssdk.h
--- linux-5000/drivers/addon/megarac/rcssdk.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/rcssdk.h	
@@ -0,0 +1,195 @@
+//
+//  Definition file for sdk rcs structures
+//
+
+#ifndef __RCSSDK_H__
+#define __RCSSDK_H__
+
+
+#include "i2crsa.h"
+
+typedef struct SDK_I2C_REPEATED_START_PACKET_tag
+{
+        RCS_COMMAND_PACKET header;
+        I2C_REPEATED_START_WITH_STATUS_TYPE info;
+}SDK_I2C_REPEATED_START_PACKET;
+
+
+
+typedef struct SDK_GET_NUM_CATEGORY_TYPE_tag
+{
+	u8 CatNum;
+}SDK_GET_NUM_CATEGORY_TYPE;
+
+typedef struct NO_OF_SDK_CAT_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	SDK_GET_NUM_CATEGORY_TYPE info;
+}NO_OF_SDK_CAT_PACKET;
+
+typedef struct SDK_GET_CATEGORY_NAME_TYPE_tag
+{
+	u8 CatNum;
+	char CatName[32];
+}SDK_GET_CATEGORY_NAME_TYPE;
+
+typedef struct SDK_CAT_NAME_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	SDK_GET_CATEGORY_NAME_TYPE info;
+}SDK_CAT_NAME_PACKET;
+
+typedef struct SDK_GET_NUM_SUBDIVISIONS_TYPE_tag
+{
+	u8 CatNum;
+	u8 SubNum;
+}SDK_GET_NUM_SUBDIVISIONS_TYPE;
+
+typedef struct NO_OF_SDK_SUBDIV_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	SDK_GET_NUM_SUBDIVISIONS_TYPE info;
+}NO_OF_SDK_SUBDIV_PACKET;
+
+typedef struct SDK_GET_SUBDIV_NAME_TYPE_tag
+{
+	u8 CatNum;
+	u8 SubNum;
+	char SubName[32];
+}SDK_GET_SUBDIV_NAME_TYPE;
+
+typedef struct SDK_SUBDIV_NAME_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	SDK_GET_SUBDIV_NAME_TYPE info;
+}SDK_SUBDIV_NAME_PACKET;
+
+typedef struct GET_SDK_VALUE_TYPE_tag
+{
+	u8 CatNum;
+	u8 SubNum;
+	u8 HostID;
+	u8 ID;
+   	unsigned short 	wFlag;
+    // Bit15: Event change notification 0=HHF enabled, 1=HHF disabled
+    // Bit14: HHF change notification. 0=enable, 1=disable
+    // Bit13: Monitor HHF 0=enable, 1=disable
+   	long   		  	lValue;
+   	long          	lLowAlertLimit;
+   	long          	lHighAlertLimit;
+   	long          	lLowWarningLimit;
+   	long          	lHighWarningLimit;
+    long			lRangeLowLimit;
+    long			lRangeHighLimit;
+   	long          	lLastValue;
+   	unsigned short  wEvent;
+   	char            bUnitDesc;
+   	// From IPMI spec
+   	// this is used for converting the lValue to string for external
+   	// interface to the card
+   	//				1 - degrees c
+   	//				4 - volts
+   	//				18 - RPM
+   	//				100 - chassis intrusion. Not in IPMI spec?
+
+}GET_SDK_VALUE_TYPE;
+
+typedef struct SDK_VALUE_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	GET_SDK_VALUE_TYPE info;
+}SDK_VALUE_PACKET;
+
+typedef struct EN_DIS_SDK_MONITOR_TYPE_tag
+{
+	u8 CatNum;
+	u8 SubNum;
+	u8 Mode;
+}EN_DIS_SDK_MONITOR_TYPE;
+
+typedef struct ENABLE_SDK_MONITOR_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	EN_DIS_SDK_MONITOR_TYPE info;
+}ENABLE_SDK_MONITOR_PACKET;
+
+typedef struct EN_DIS_SDK_THRES_TYPE_tag
+{
+	u8 CatNum;
+	u8 SubNum;
+	u8 Mode;
+}EN_DIS_SDK_THRES_TYPE;
+
+typedef struct ENABLE_SDK_THRESHOLD_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	EN_DIS_SDK_THRES_TYPE info;
+}ENABLE_SDK_THRESHOLD_PACKET;
+
+typedef struct SDK_THRES_TYPE_tag
+{
+	u8 CatNum;
+	u8 SubNum;
+	long LowAlertLimit;
+	long HighAlertLimit;
+	long LowWarnLimit;
+	long HighWarnLimit;
+}SDK_THRES_TYPE;
+
+typedef struct READ_SDK_THRESHOLD_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	SDK_THRES_TYPE info;
+}READ_SDK_THRESHOLD_PACKET;
+
+typedef struct MODIFY_SDK_THRESHOLD_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	SDK_THRES_TYPE info;
+}MODIFY_SDK_THRESHOLD_PACKET;
+
+typedef struct SDK_SCHED_TYPE_tag
+{
+	u8 CatNum;
+	u8 SubNum;
+	unsigned short Attributes;
+	unsigned long Period;
+}SDK_SCHED_TYPE;
+
+typedef struct READ_SDK_SCHEDULE_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	SDK_SCHED_TYPE info;
+}READ_SDK_SCHEDULE_PACKET;
+
+typedef struct MODIFY_SDK_SCHEDULE_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	SDK_SCHED_TYPE info;
+}MODIFY_SDK_SCHEDULE_PACKET;
+
+typedef struct SDK_CONFIG_TYPE_tag
+{
+        u8 Config;
+}SDK_CONFIG_TYPE;
+
+typedef struct SDK_CONFIG_PACKET_tag
+{
+        RCS_COMMAND_PACKET header;
+        SDK_CONFIG_TYPE info;
+}SDK_CONFIG_PACKET;
+
+typedef struct READ_SDK_MONITOR_STATE_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	EN_DIS_SDK_MONITOR_TYPE info;
+}READ_SDK_MONITOR_STATE_PACKET;
+
+typedef struct READ_SDK_THRESHOLD_STATE_PACKET_tag
+{
+	RCS_COMMAND_PACKET header;
+	EN_DIS_SDK_THRES_TYPE info;
+}READ_SDK_THRESHOLD_STATE_PACKET;
+
+#endif
+
diff -urNp linux-5000/drivers/addon/megarac/rcsusr.h linux-5010/drivers/addon/megarac/rcsusr.h
--- linux-5000/drivers/addon/megarac/rcsusr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/rcsusr.h	
@@ -0,0 +1,776 @@
+/*******************************************************************
+
+    File Name   :   RCSUSR.H
+
+    Author      :   K.V.Subash & Parthiban Baskar
+
+    Date        :   8 December 1997
+
+    Purpose     :   RCS User Defined Cmd Grp Codes
+
+	Copyright       :       American Megatrends Inc., 1997-1998
+
+********************************************************************/
+
+#ifndef __RCSUSR_H__
+#define __RCSUSR_H__
+
+
+/************************************************************************/
+/**************  REMOTE USER DEFINED COMMANDS ***************************/
+/************************************************************************/
+
+/*******************************GROUP 800**************************/
+#define RCS_USR_GET_ESMII_INFO                  0X8000
+#define RCS_USR_GET_ESMII_EVENT_LOG             0X8001
+#define RCS_USR_GET_ESMII_POST_LOG              0X8002
+#define RCS_USR_SCAN_FOR_ESMIIS                 0X8003
+#define RCS_USR_SEND_ESMII_COMMAND              0X8004
+#define RCS_USR_READ_ESMII_CONFIG_COMMAND       0X8005
+#define RCS_USR_MODIFY_ESMII_CONFIG_COMMAND     0X8006
+#define RCS_USR_DUMP_ESMII_EVENT_LOG            0X8007
+#define RCS_USR_DUMP_ESMII_POST_LOG             0X8008
+#define RCS_USR_GET_NUM_ESMIIS                  0X8009
+#define RCS_USR_GET_SERVER_INFO                 0X800A
+#define RCS_USR_CLEAR_ESMII_EVENT_LOG           0X800B
+#define RCS_USR_CLEAR_ESMII_POST_LOG            0X800C
+#define RCS_USR_GET_GLOBAL_ALERT_SEVERITY       0X800D
+#define RCS_USR_REPORT_SERVER_INFO              0X800E
+/************No of functions beginning with 800**********************/
+#define FNS_800 15
+/*******************************************************************/
+
+
+/*******************************GROUP 801**************************/
+#define RCS_USR_REPORT_HOST_INFO                0X8010
+#define RCS_USR_GET_HOST_INFO                   0X8011
+#define RCS_USR_GET_CURRENT_ESMII_POST_LOG      0X8012
+#define RCS_USR_GET_ALL_ESMII_POST_LOGS         0X8013
+#define RCS_USR_CLEAR_ALL_ESMII_POST_LOGS       0X8014
+/************No of functions beginning with 801**********************/
+#define FNS_801 5
+/*******************************************************************/
+
+
+
+/*******************************GROUP 802**************************/
+#define RCS_USR_SEND_IM_COMMAND                 0x8020
+
+#define RCS_USR_READ_IM_CONFIG_COMMAND          0X8021
+#define RCS_USR_MODIFY_IM_CONFIG_COMMAND        0X8022
+
+#define RCS_USR_READ_IM_PROC_COMMAND            0x8023
+#define RCS_USR_MODIFY_IM_PROC_COMMAND          0x8024
+
+#define RCS_USR_READ_IM_SYSVOLT_COMMAND         0x8025
+#define RCS_USR_MODIFY_IM_SYSVOLT_COMMAND       0x8026
+
+#define RCS_USR_READ_IM_SYSTEMP_COMMAND         0x8027
+#define RCS_USR_MODIFY_IM_SYSTEMP_COMMAND       0x8028
+
+#define RCS_USR_READ_IM_SYSFAN_COMMAND          0x8029
+#define RCS_USR_MODIFY_IM_SYSFAN_COMMAND        0x802A
+
+#define RCS_USR_READ_IM_SYSFAULT_COMMAND        0x802B
+#define RCS_USR_MODIFY_IM_SYSFAULT_COMMAND      0x802C
+
+#define RCS_USR_READ_IM_SYSSWITCH_COMMAND       0x802D
+#define RCS_USR_MODIFY_IM_SYSSWITCH_COMMAND     0x802E
+/************No of functions beginning with 802**********************/
+#define FNS_802 13
+/*******************************************************************/
+
+
+
+/*******************************GROUP 803**************************/
+/************No of functions beginning with 803**********************/
+#define FNS_803 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 804**************************/
+#define RCS_USR_IPMI_GET_EVT_LOG_COMMAND      0x8040
+#define RCS_USR_IPMI_CLEAR_EVENT_LOG_COMMAND  0x8041
+#define RCS_USR_GET_SDR_RECORD_COMMAND        0x8042
+#define RCS_USR_GET_FRU_INFO_COMMAND		  0x8043
+#define RCS_USR_RESCAN_FRU_COMMAND			  0x8044
+#define	RCS_USR_START_STOP_IPMI_COMMAND		  0x8045
+#define	RCS_USR_DUMP_SDR_RECORDS			  0x8046
+/************No of functions beginning with 804**********************/
+#define FNS_804 7
+/*******************************************************************/
+
+
+
+/*******************************GROUP 805**************************/
+
+/************No of functions beginning with 805**********************/
+#define FNS_805 0
+/*******************************************************************/
+
+
+/*******************************GROUP 806**************************/
+
+/************No of functions beginning with 806**********************/
+#define FNS_806 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 807**************************/
+
+/************No of functions beginning with 807**********************/
+#define FNS_807 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 808**************************/
+
+/************No of functions beginning with 808**********************/
+#define FNS_808 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 809**************************/
+
+/************No of functions beginning with 809**********************/
+#define FNS_809 0
+/*******************************************************************/
+
+
+/*******************************GROUP 80A**************************/
+
+/************No of functions beginning with 80A**********************/
+#define FNS_80A 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 80B**************************/
+
+/************No of functions beginning with 80B**********************/
+#define FNS_80B 0
+/*******************************************************************/
+
+
+/*******************************GROUP 80C**************************/
+
+/************No of functions beginning with 80C**********************/
+#define FNS_80C 0
+/*******************************************************************/
+
+
+
+
+/*******************************GROUP 80D**************************/
+
+/************No of functions beginning with 80D**********************/
+#define FNS_80D 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 80E**************************/
+
+/************No of functions beginning with 80E**********************/
+#define FNS_80E 0
+/*******************************************************************/
+
+
+
+/*******************************GROUP 80F**************************/
+
+/************No of functions beginning with 80F**********************/
+#define FNS_80F 0
+/*******************************************************************/
+
+
+
+
+/************************************************************************/
+/**************  REMOTE USER DEFINED ERROR CODES ************************/
+/************************************************************************/
+#define RCS_USR_ERR_BUSY                        0x8003
+#define RCS_USR_ERR_BAD_LENGTH                  0x8005
+#define RCS_USR_ERR_BAD_ARGUMENT                0x8006
+#define RCS_USR_ERR_DEVICE_NO_RESPONSE          0x8009
+#define RCS_USR_ERR_INFORMATION_NOT_AVAILABLE   0x800f
+
+/************************************************************************/
+/**************  REMOTE USER DEFINED COMMANDS END************************/
+/************************************************************************/
+
+/* Implementation specific */
+/* Dell ESM Support */
+
+//#define  MAX_ESMII            16
+#define  MAX_ESMII            1
+//#define  MAX_EVENT_LOG_SIZE   1024
+#define  MAX_EVENT_LOG_SIZE   1300
+#define  MAX_POST_LOG_SIZE    256
+#define MAX_ESM_POST_LOGS  4
+
+//mjb 8/8/99
+#define SYS_MGMT_SUPPORT_NONE    0
+#define SYS_MGMT_SUPPORT_ESM     1
+#define SYS_MGMT_SUPPORT_IPMI    2
+//mjb 8/8/99
+
+typedef struct _EsmIITableEntry
+{
+   unsigned char  LogAddr;
+   unsigned char  Uid[8];
+}ESMII_TABLE_ENTRY;
+
+typedef struct _ServerInfoEntry
+{
+   unsigned char  EsmIILogAddr;
+   unsigned char  SystemModel;
+   unsigned char  BIOSVersion[4];
+   unsigned char  BackPlaneFirmware[4];
+   unsigned char  reserved1[12];
+   unsigned char  EsmIIFirmware[2];
+   unsigned char  ServiceTag[6];
+   unsigned char  AssetTag[11];
+// mjb 8/8/99
+//   unsigned char  reserved2;
+   unsigned char  SysMgmtSupportType; // 0=none, 1=ESM, 2=IPMI
+// mjb 8/8/99
+   unsigned char  PSPBFirmware[4];
+   unsigned char  reserved3[12];
+   unsigned char  ServerName[50];
+}SERVER_INFO_ENTRY;
+
+
+typedef struct _GetEsmIIInfoData
+{
+   unsigned char     RACLogAddr;
+   unsigned char     RACUid[8];
+   unsigned char     NumESMII;
+   char              ServerName[50];
+   ESMII_TABLE_ENTRY ESMIITable[MAX_ESMII];
+}GET_ESMII_INFO_DATA;
+
+typedef struct _RCS_USR_GetEsmIIInfoArgs
+{
+   unsigned char     RACLogAddr;
+   unsigned char     RACUid[8];
+   unsigned char     NumESMII;
+   char              ServerName[50];
+   ESMII_TABLE_ENTRY ESMIITable[1];
+}RCS_USR_GET_ESMII_INFO_ARGS;
+
+typedef struct _RCS_USR_GetEsmIIInfoCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_GET_ESMII_INFO_ARGS Data;
+}RCS_USR_GET_ESMII_INFO_COMMAND;
+
+// Following based on ESM 2 Log Types document dated 1/7/98
+typedef struct _EsmIILogEntry
+{
+   unsigned char  RecordType;
+   unsigned char  Severity;
+   unsigned char  Length;
+   unsigned char  Body[23]; // Max body size is 23
+}ESMII_LOG_ENTRY;
+
+typedef struct _EsmIIEventLog
+{
+   unsigned short NumEntries;
+   unsigned short LogSize;
+   unsigned char  LogData[MAX_EVENT_LOG_SIZE];
+}ESMII_EVENT_LOG;
+
+typedef struct _EsmIIPostLog
+{
+   unsigned short NumEntries;
+   unsigned short LogSize;
+   unsigned char  LogData[MAX_POST_LOG_SIZE];
+   void  *  pprev;
+   void  *  pnext;
+}ESMII_POST_LOG;
+
+typedef struct _EsmIILog
+{
+   unsigned char     LogAddr;
+   unsigned char     Uid[8];
+   ESMII_EVENT_LOG   Event;
+   ESMII_POST_LOG    Post;
+}ESMII_LOG;
+
+typedef struct _RCS_USR_GetEsmIIEventLogArgs
+{
+   unsigned char  LogAddr;
+   unsigned short NumEntries;
+   unsigned short LogSize;
+   unsigned char  LogData[1];
+}RCS_USR_GET_ESMII_EVENT_LOG_ARGS;
+
+typedef struct _RCS_USR_GetEsmIIEventLogCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_GET_ESMII_EVENT_LOG_ARGS Data;
+}RCS_USR_GET_ESMII_EVENT_LOG_COMMAND;
+
+typedef struct _RCS_USR_GetEsmIIPostLogArgs
+{
+   unsigned char  LogAddr;
+   unsigned short NumEntries;
+   unsigned short LogSize;
+   unsigned char  LogData[1];
+}RCS_USR_GET_ESMII_POST_LOG_ARGS;
+
+typedef struct _RCS_USR_GetEsmIIPostLogCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_GET_ESMII_POST_LOG_ARGS Data;
+}RCS_USR_GET_ESMII_POST_LOG_COMMAND;
+
+typedef struct _RCS_USR_ScanForGetEsmIIsArgs
+{
+   unsigned short NumberOfEsmIIs;
+}RCS_USR_SCAN_FOR_ESMIIS_ARGS;
+
+typedef struct _RCS_USR_ScanForGetEsmIIsCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_SCAN_FOR_ESMIIS_ARGS Data;
+}RCS_USR_SCAN_FOR_ESMIIS_COMMAND;
+
+#define RCS_USR_SEND_ESMII_CMD_MAX_RESP (1024 * 2) /* just a guess */
+
+typedef struct _RCS_USR_SendCommandToEsmIIArgs
+{
+   unsigned char  ESMIILogAddr;
+   unsigned char  RACLogAddr;
+   unsigned short CmdRespPacketLen;
+   unsigned char  CmdRespPacket[1];
+}RCS_USR_SEND_COMMAND_TO_ESMII_ARGS;
+
+typedef struct _RCS_USR_SendCommandToGetEsmIICommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_SEND_COMMAND_TO_ESMII_ARGS Data;
+}RCS_USR_SEND_COMMAND_TO_ESMII_COMMAND;
+
+
+typedef struct _RCS_USR_ConfigEsmIIArgs
+{
+   unsigned long  EsmIIPollPeriod;
+   unsigned long  StartEsmIIMonTimeOut;
+   unsigned char  DefaultLogicalAddress;
+}RCS_USR_CONFIG_ESMII_ARGS;
+
+typedef struct _RCS_USR_ConfigEsmIICommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_CONFIG_ESMII_ARGS Data;
+}RCS_USR_CONFIG_ESMII_COMMAND;
+
+
+typedef struct _RCS_USR_DumpEsmIIEventLogArgs
+{
+   unsigned char  LogAddr;
+   unsigned short NumEntries;
+   unsigned short LogSize;
+   unsigned char  LogData[1];
+}RCS_USR_DUMP_ESMII_EVENT_LOG_ARGS;
+
+typedef struct _RCS_USR_DumpEsmIIEventLogCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_DUMP_ESMII_EVENT_LOG_ARGS Data;
+}RCS_USR_DUMP_ESMII_EVENT_LOG_COMMAND;
+
+typedef struct _RCS_USR_DumpEsmIIPostLogArgs
+{
+   unsigned char  LogAddr;
+   unsigned short NumEntries;
+   unsigned short LogSize;
+   unsigned char  LogData[1];
+}RCS_USR_DUMP_ESMII_POST_LOG_ARGS;
+
+typedef struct _RCS_USR_DumpEsmIIPostLogCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_DUMP_ESMII_POST_LOG_ARGS Data;
+}RCS_USR_DUMP_ESMII_POST_LOG_COMMAND;
+
+typedef struct _RCS_USR_GetNumEsmIIsArgs
+{
+   unsigned short NumEsmIIs;
+}RCS_USR_GET_NUM_ESMIIS_ARGS;
+
+typedef struct _RCS_USR_GetNumEsmIIsCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_GET_NUM_ESMIIS_ARGS Data;
+}RCS_USR_GET_NUM_ESMIIS_COMMAND;
+
+typedef struct _RCS_USR_GetServerInfoArgs
+{
+   unsigned char  EsmIILogAddr;
+   unsigned char  SystemModel;
+   unsigned char  BIOSVersion[4];
+   unsigned char  BackPlaneFirmware[4];
+   unsigned char  reserved1[12];
+   unsigned char  EsmIIFirmware[2];
+   unsigned char  ServiceTag[6];
+   unsigned char  AssetTag[11];
+// mjb 8/8/99
+//   unsigned char  reserved2;
+   unsigned char  SysMgmtSupportType; // 0=none, 1=ESM, 2=IPMI
+// mjb 8/8/99
+   unsigned char  PSPBFirmware[4];
+   unsigned char  reserved3[12];
+   unsigned char  ServerName[50];
+}RCS_USR_GET_SERVER_INFO_ARGS;
+
+typedef struct _RCS_USR_GetServerInfoCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_GET_SERVER_INFO_ARGS Data;
+}RCS_USR_GET_SERVER_INFO_COMMAND;
+
+typedef struct _RCS_USR_ClearEsmIIEventLogArgs
+{
+   unsigned char  EsmIILogAddr;
+}RCS_USR_CLEAR_ESMII_EVENT_LOG_ARGS;
+
+typedef struct _RCS_USR_ClearEsmIIEventLogCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_CLEAR_ESMII_EVENT_LOG_ARGS Data;
+}RCS_USR_CLEAR_ESMII_EVENT_LOG_COMMAND;
+
+typedef struct _RCS_USR_ClearEsmIIPostLogArgs
+{
+   unsigned char  EsmIILogAddr;
+}RCS_USR_CLEAR_ESMII_POST_LOG_ARGS;
+
+typedef struct _RCS_USR_ClearEsmIIPostLogCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_CLEAR_ESMII_POST_LOG_ARGS Data;
+}RCS_USR_CLEAR_ESMII_POST_LOG_COMMAND;
+
+
+typedef struct _RCS_USR_GetGlobalAlertSeverityArgs
+{
+   unsigned char  EsmIILogAddr;
+   unsigned char  GlobalAlertSeverity;
+}RCS_USR_GET_GLOBAL_ALERT_SEVERITY_ARGS;
+
+typedef struct _RCS_USR_GetGlobalAlertSeverityCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_GET_GLOBAL_ALERT_SEVERITY_ARGS Data;
+}RCS_USR_GET_GLOBAL_ALERT_SEVERITY_COMMAND;
+
+typedef struct _RCS_USR_ReportServerInfoArgs
+{
+   unsigned char  EsmIILogAddr;
+   unsigned char  SystemModel;
+   unsigned char  BIOSVersion[4];
+   unsigned char  BackPlaneFirmware[4];
+   unsigned char  reserved1[12];
+   unsigned char  EsmIIFirmware[2];
+   unsigned char  ServiceTag[6];
+   unsigned char  AssetTag[11];
+// mjb 8/8/99
+//   unsigned char  reserved2;
+   unsigned char  SysMgmtSupportType; // 0=none, 1=ESM, 2=IPMI
+// mjb 8/8/99
+   unsigned char  PSPBFirmware[4];
+   unsigned char  reserved3[12];
+   unsigned char  ServerName[50];
+}RCS_USR_REPORT_SERVER_INFO_ARGS;
+
+typedef struct _RCS_USR_ReportServerInfoCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_REPORT_SERVER_INFO_ARGS Data;
+}RCS_USR_REPORT_SERVER_INFO_COMMAND;
+
+typedef struct _RCS_USR_ReportHostInfoArgs
+{
+   unsigned char  HostServerName[50];
+}RCS_USR_REPORT_HOST_INFO_ARGS;
+
+typedef struct _RCS_USR_ReportHostInfoCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_REPORT_HOST_INFO_ARGS Data;
+}RCS_USR_REPORT_HOST_INFO_COMMAND;
+
+typedef struct _RCS_USR_GetHostInfoArgs
+{
+   unsigned char  HostServerName[50];
+}RCS_USR_GET_HOST_INFO_ARGS;
+
+typedef struct _RCS_USR_GetHostInfoCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_GET_HOST_INFO_ARGS Data;
+}RCS_USR_GET_HOST_INFO_COMMAND;
+
+typedef struct _RCS_USR_GetCurrentEsmIIPostLogArgs
+{
+   unsigned short NumEntries;
+   unsigned char  LogData[1];
+}RCS_USR_GET_CURRENT_ESMII_POST_LOG_ARGS;
+
+typedef struct _RCS_USR_GetCurrentEsmIIPostLogCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_GET_CURRENT_ESMII_POST_LOG_ARGS Data;
+}RCS_USR_GET_CURRENT_ESMII_POST_LOG_COMMAND;
+
+typedef struct _RCS_USR_GetAllEsmIIPostLogsCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   unsigned char Data[1];
+}RCS_USR_GET_ALL_ESMII_POST_LOGS_COMMAND;
+
+typedef struct _RCS_USR_GetAllEsmIIPostLogsArgs
+{
+   unsigned char Data[1];
+}RCS_USR_GET_ALL_ESMII_POST_LOGS_ARGS;
+
+typedef struct _RCS_USR_ALT_GetAllEsmIIPostLogsCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_GET_ALL_ESMII_POST_LOGS_ARGS Data;
+}RCS_USR_ALT_GET_ALL_ESMII_POST_LOGS_COMMAND;
+
+typedef struct _RCS_USR_ClearAllEsmIIPostLogsCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+}RCS_USR_CLEAR_ALL_ESMII_POST_LOGS_COMMAND;
+
+/****************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
+
+/* Gateway InfoManager Suppoprt */
+
+typedef struct _RCS_USR_SendCommandToImArgs
+{
+   unsigned char TargetAddr;
+   unsigned char Cmd;
+   unsigned char ImPacket[1];
+}RCS_USR_SEND_COMMAND_TO_IM_ARGS;
+
+typedef struct _RCS_USR_SendCommandToImRespArgs
+{
+   unsigned char TargetAddr;
+   unsigned char Cmd;
+   unsigned char ImPacket[1];
+}RCS_USR_SEND_COMMAND_TO_IM_RESP_ARGS;
+
+typedef struct _RCS_USR_SendCommandToImCmdArgs
+{
+   unsigned char ImPacket[1];
+}RCS_USR_SEND_COMMAND_TO_IM_CMD_ARGS;
+
+typedef struct _RCS_USR_SendCommandToImCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_SEND_COMMAND_TO_IM_ARGS Data;
+}RCS_USR_SEND_COMMAND_TO_IM_COMMAND;
+
+typedef struct _RCS_USR_ConfigImArgs
+{
+   unsigned char  ImMonitorFlags;
+   unsigned int   ImPollPeriod;
+}RCS_USR_CONFIG_IM_ARGS;
+
+typedef struct _RCS_USR_ConfigImCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_CONFIG_IM_ARGS Data;
+}RCS_USR_CONFIG_IM_COMMAND;
+
+typedef struct _RCS_USR_MeasureImArgs
+{
+   unsigned char   ImMeasureIndex;
+   unsigned char   ImMeasurePacket[1];
+}RCS_USR_MEASURE_IM_ARGS;
+
+typedef struct _RCS_USR_MeasureImCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_MEASURE_IM_ARGS Data;
+}RCS_USR_MEASURE_IM_COMMAND;
+
+typedef struct _RCS_USR_FlagsImArgs
+{
+   unsigned char ImFlagsPacket[1];
+}RCS_USR_FLAGS_IM_ARGS;
+
+typedef struct _RCS_USR_FlagsImCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_FLAGS_IM_ARGS Data;
+}RCS_USR_FLAGS_IM_COMMAND;
+
+typedef struct _RCS_USR_SwitchImArgs
+{
+   unsigned short Mask;
+   unsigned short Switch;
+}RCS_USR_SWITCH_IM_ARGS;
+
+typedef struct _RCS_USR_SwitchImCommand
+{
+   RCS_COMMAND_PACKET RCSCmdPkt;
+   RCS_USR_SWITCH_IM_ARGS Data;
+}RCS_USR_SWITCH_IM_COMMAND;
+
+/************************************************************************/
+
+#define MAX_IPMI_EVENT_LOGS 500
+#define MAX_SDR_LOGS 110
+#define MAX_IPMI_EVENT_LOG_SIZE 16
+
+
+typedef struct _IPMI_SELRecord
+{
+    unsigned char    RecIDLSB;
+    unsigned char	 RecIDMSB;
+    unsigned char    RecordType;
+    unsigned char    TimeStamp[4];
+    unsigned char    GenID[2];
+    unsigned char    EvMRev;
+    unsigned char    SensorType;
+    unsigned char    SensorNo;
+    unsigned char    EventType;
+    unsigned char    Data[3];
+}IPMI_SEL_RECORD;
+
+typedef struct _IPMI_EventLog
+{
+	unsigned char LogData[MAX_IPMI_EVENT_LOG_SIZE];
+}IPMI_EVENT_LOG;
+
+typedef struct _RCS_USR_GetIPMIEventLogArgs{
+    unsigned short NumEntries;
+    unsigned char LogData[1];
+}RCS_USR_GET_IPMI_EVENT_LOG_ARGS;
+
+typedef struct _RCS_USR_GetIPMIEventLogCommand
+{
+    RCS_COMMAND_PACKET RCSCmdPkt;
+    RCS_USR_GET_IPMI_EVENT_LOG_ARGS Data;
+}RCS_USR_GET_IPMI_EVENT_LOG_COMMAND;
+
+typedef struct RCS_USR_ClearIPMIEventLogArgs
+{
+	unsigned short    NumEntries;
+	unsigned char    Status;
+}RCS_USR_CLEAR_IPMI_EVENT_LOG_ARGS;
+
+typedef struct _RCS_USR_ClearIPMIEventLogCommand
+{
+	RCS_COMMAND_PACKET RCSCmdPkt;
+	RCS_USR_CLEAR_IPMI_EVENT_LOG_ARGS Data;
+}RCS_USR_CLEAR_IPMI_EVENT_LOG_COMMAND;
+
+#define MAX_SDR_RECORD_DATA   64
+
+typedef struct _RCS_USR_SDRRecordArgs
+{
+	unsigned char OwnerID;
+	unsigned char Lun;
+	unsigned char SensorNo;
+	unsigned char Length;
+	unsigned char LogData[1];
+}RCS_USR_SDR_RECORD_ARGS;
+
+typedef struct _RCS_USR_SDRRecordCommand
+{
+    RCS_COMMAND_PACKET RCSCmdPkt;
+    RCS_USR_SDR_RECORD_ARGS Data;
+}RCS_USR_SDR_RECORD_COMMAND;
+
+typedef struct _RCS_USR_GetFRUDataArgs
+{
+	unsigned char LogData[1];
+}RCS_USR_GET_FRU_DATA_ARGS;
+
+typedef struct _RCS_USR_GetFRUDataCommand
+{
+	RCS_COMMAND_PACKET RCSCmdPkt;
+	unsigned char UseIPMI;
+	RCS_USR_GET_FRU_DATA_ARGS Data;
+}RCS_USR_GET_FRU_DATA_COMMAND;
+
+typedef struct _RCS_USR_ALT_GetFRUDataArgs
+{
+	unsigned char UseIPMI;
+	unsigned char LogData[1];
+}RCS_USR_ALT_GET_FRU_DATA_ARGS;
+
+typedef struct _RCS_USR_ALT_GetFRUDataCommand
+{
+	RCS_COMMAND_PACKET RCSCmdPkt;
+	RCS_USR_ALT_GET_FRU_DATA_ARGS Data;
+}RCS_USR_ALT_GET_FRU_DATA_COMMAND;
+
+typedef struct _RCS_USR_RescanFRUDataCommand
+{
+	RCS_COMMAND_PACKET	RCSCmdPkt;
+	unsigned char		Status;
+}RCS_USR_RESCAN_FRU_DATA_COMMAND;
+
+typedef struct _RCS_USR_ALT_RescanFRUDataArgs
+{
+	unsigned char		Status;
+}RCS_USR_ALT_RESCAN_FRU_DATA_ARGS;
+
+typedef struct _RCS_USR_ALT_RescanFRUDataCommand
+{
+	RCS_COMMAND_PACKET	         RCSCmdPkt;
+   RCS_USR_ALT_RESCAN_FRU_DATA_ARGS  Data;
+}RCS_USR_ALT_RESCAN_FRU_DATA_COMMAND;
+
+typedef struct _RCS_USR_StartStopIPMIMonCommand
+{
+	RCS_COMMAND_PACKET RCSCmdPkt;
+	unsigned char	Status;
+}RCS_USR_START_STOP_IPMI_MON_COMMAND;
+
+typedef struct _RCS_USR_ALT_StartStopIPMIMonArgs
+{
+	unsigned char	Status;
+}RCS_USR_ALT_START_STOP_IPMI_MON_ARGS;
+
+typedef struct _RCS_USR_ALT_StartStopIPMIMonCommand
+{
+	RCS_COMMAND_PACKET RCSCmdPkt;
+	RCS_USR_ALT_START_STOP_IPMI_MON_ARGS Data;
+}RCS_USR_ALT_START_STOP_IPMI_MON_COMMAND;
+
+typedef struct _RCS_USR_DumpSDRRecordsCommand
+{
+	RCS_COMMAND_PACKET RCSCmdPkt;
+	unsigned char Status;
+}RCS_USR_DUMP_SDR_RECORDS_COMMAND;
+
+typedef struct _RCS_USR_ALT_DumpSDRRecordsArgs
+{
+	unsigned char Status;
+}RCS_USR_ALT_DUMP_SDR_RECORDS_ARGS;
+
+typedef struct _RCS_USR_ALT_DumpSDRRecordsCommand
+{
+	RCS_COMMAND_PACKET                  RCSCmdPkt;
+   RCS_USR_ALT_DUMP_SDR_RECORDS_ARGS   Data;
+}RCS_USR_ALT_DUMP_SDR_RECORDS_COMMAND;
+
+/************************************************************************/
+#endif
+
diff -urNp linux-5000/drivers/addon/megarac/redirect.h linux-5010/drivers/addon/megarac/redirect.h
--- linux-5000/drivers/addon/megarac/redirect.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/redirect.h	
@@ -0,0 +1,101 @@
+/*******************************************************************
+
+    File Name   :   REDIRECT.H
+
+    Author      :   K.V.Subash & Parthiban Baskar
+
+    Date        :   4 February 1998
+
+    Purpose     :   Equates and data types used for Console redirection
+
+    Copyright   :   American Megatrends Inc., 1997-1998
+
+    TAB Spacing :   4
+
+********************************************************************/
+
+#ifndef  __REDIRECT_H__
+#define  __REDIRECT_H__
+
+#include "rcs.h"
+#include "rcsred.h"
+
+/*  FRICause codes for various FRI's    */
+#define GetDCInfo_FRI       0x00000001  // Host responds with SendDCInfo RCS.
+#define GetDCPacket_x_FRI   0x00000002  // where XXXX is the DCPacketNumber.
+                // 0x00000002 means GetDCPacket [0]
+                // 0x00010002 means GetDCPacket [1]
+                // 0x00FF0002 means GetDCPacket [255] and so on..
+#define SendDCComplete_FRI  0x00000003  // Host knows that GraphicScreen has transferred.
+#define SendKeyEvent_FRI    0x00000004  // Host issues ReadKey RCS to Firmware.
+#define SendMouseEvent_FRI  0x00000005  // Host issues ReadMouseEvent RCS to Firmware.
+#define SendAlertToHost_FRI 0x00000006  // To report any alert/event to the Host driver,
+                // apart from paging/logging etc.
+#define HOST_OS_SHUTDOWN_REQUEST_FRI  0x00000007  // Host os shutdown request.
+#define ModeChangedToGraphics_FRI   0x00000008  // Tell host driver that video mode
+                                                // has changed to Graphics.
+#define ServiceDYRM_FRI    0x00000009  // Used by the remote s/w to detect
+                // the presence of the RACService on the host.
+#define PassThruData_FRI   0x0000000a  // Used by the remote s/w to pass data
+                // thru to the OS Driver
+#define Maximum_FRI     PassThruData_FRI
+                // The above define should be changed if new FRI's are added.
+
+/*  RESERVED FRICause codes for s/w group   */
+#define Reserved_FRI_0      0x00000000
+#define Reserved_FRI_255    0x000000ff
+
+
+/*  The following defines for VideoModes are duplicated in
+    startup\src\fixddata.c for operational ease.  If they change here,
+    they have to change there too     */
+/*  VideoModes  */
+#define TEXTMODE        0
+#define GRAPHICSMODE    1
+
+/*  Keyboard Controller Ports   */
+#define HostKBStatusPort        (u8 *)0x0064
+#define HostKBCommandPort       (u8 *)0x0064
+#define HostKBDataPort          (u8 *)0x0060
+
+/*  Keyboard Controller Commands    */
+#define CMDLockLocalKBAccess        0xad
+#define CMDEnableLocalKBAccess      0xae
+#define CMDWriteKBOutputBuffer      0xd2
+
+#define KBTimeoutDelay              0x1000
+#define SendTimeoutDelay            0x1800
+
+/*  Other defines                   */
+#define MOUSE_DATA_BUFFER_SIZE      (5*1024)
+
+
+/*
+    Function prototypes
+*/
+extern  TWOBYTES    StartConsoleRedirection (RCS_COMMAND_PACKET * RCSCmdPkt);
+extern  TWOBYTES    SendKey (RCS_COMMAND_PACKET * RCSCmdPkt);
+extern  TWOBYTES    SendMouseEvent (RCS_COMMAND_PACKET * RCSCmdPkt);
+extern  TWOBYTES    StopConsoleRedirection (RCS_COMMAND_PACKET * RCSCmdPkt);
+extern  TWOBYTES    ReadKey (RCS_COMMAND_PACKET * RCSCmdPkt);
+extern  TWOBYTES    ReadMouseEvent (RCS_COMMAND_PACKET * RCSCmdPkt);
+extern  TWOBYTES    GetDCInfo (RCS_COMMAND_PACKET * RCSCmdPkt);
+extern  TWOBYTES    SendDCInfo (RCS_COMMAND_PACKET * RCSCmdPkt);
+extern  TWOBYTES    GetDCPacket (RCS_COMMAND_PACKET * RCSCmdPkt);
+extern  TWOBYTES    SendDCPacket (RCS_COMMAND_PACKET * RCSCmdPkt);
+extern  TWOBYTES    SendDCComplete (RCS_COMMAND_PACKET * RCSCmdPkt);
+extern  TWOBYTES    ServiceDYRM (RCS_COMMAND_PACKET * RCSCmdPkt);
+extern  void        SendMouseEventToHost (u8 * DataPtr, FOURBYTES FRICause);
+extern  int         FirmwareRequestInterrupt (FOURBYTES FRICause);
+extern  int         IssueFRI (void);
+extern  TWOBYTES    Stuff (u8 ScanCode);
+
+extern  int         VGAScreenDump (void);
+
+extern  TWOBYTES    PassThruDataToHost (RCS_COMMAND_PACKET * RCSCmdPkt);
+extern  TWOBYTES    PassThruDataToRemote (RCS_COMMAND_PACKET * RCSCmdPkt);
+extern  TWOBYTES    ReadPassThruData (RCS_COMMAND_PACKET * RCSCmdPkt);
+extern  void        CleanUpPassThruBuffers (short Entry);
+
+#endif
+
diff -urNp linux-5000/drivers/addon/megarac/rtc.h linux-5010/drivers/addon/megarac/rtc.h
--- linux-5000/drivers/addon/megarac/rtc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-5010/drivers/addon/megarac/rtc.h	
@@ -0,0 +1,38 @@
+/*
+ ****************************************************************************
+ *
+ *          File Name   :       RTC.H
+ *
+ *          Author      :       Vinesh C.S.
+ *
+ *          Date        :       16 Feb 1998
+ *
+ *          Purpose     :       This code contains Time and Date Related Code
+ *
+ *          Copyright   :       American Megatrends Inc., (C) 1997-1998
+ *                              All rights reserved.
+ *
+ *
+ ****************************************************************************
+ */
+#ifndef __AMI_RTC_H__
+#define __AMI_RTC_H__
+
+typedef struct {
+    unsigned short Year;
+    unsigned char  Mon;
+    unsigned char  Date;
+    unsigned char  Hour;
+    unsigned char  Min;
+    unsigned char  Sec;
+    unsigned char  Res;
+} DATE_TIME;
+
+void SetDateTime(DATE_TIME *dt);
+unsigned char GetDateTime(DATE_TIME *dt);
+
+void DriverDelay(unsigned long msec);
+
+#endif
+
+ /*---------------------------- End of RTC.H -------------------------------*/
