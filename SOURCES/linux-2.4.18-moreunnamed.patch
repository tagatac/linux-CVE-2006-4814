diff -urNp linux-1090/fs/dcache.c linux-1110/fs/dcache.c
--- linux-1090/fs/dcache.c	
+++ linux-1110/fs/dcache.c	
@@ -1297,4 +1297,5 @@ void __init vfs_caches_init(unsigned lon
 	bdev_cache_init();
 	cdev_cache_init();
 	iobuf_cache_init();
+	majorhog_init();
 }
diff -urNp linux-1090/fs/super.c linux-1110/fs/super.c
--- linux-1090/fs/super.c	
+++ linux-1110/fs/super.c	
@@ -590,7 +590,16 @@ int do_remount_sb(struct super_block *sb
  * filesystems which don't use real block-devices.  -- jrs
  */
 
-enum {Max_anon = 256};
+enum {Max_Maj = 5};
+enum {Max_anon = 256 * Max_Maj};
+
+static unsigned unnamed_dev_majors[Max_Maj] = {
+	UNNAMED_MAJOR, 12, 14, 38, 39,
+};
+
+static int unnamed_dev_nmaj = 1;	/* Actually used */
+static unsigned unnamed_maj_in_use[Max_Maj] = { UNNAMED_MAJOR, };
+
 static unsigned long unnamed_dev_in_use[Max_anon/(8*sizeof(unsigned long))];
 static spinlock_t unnamed_dev_lock = SPIN_LOCK_UNLOCKED;/* protects the above */
 
@@ -600,9 +609,24 @@ static spinlock_t unnamed_dev_lock = SPI
  */
 static void put_anon_dev(kdev_t dev)
 {
-	spin_lock(&unnamed_dev_lock);
-	clear_bit(MINOR(dev), unnamed_dev_in_use);
-	spin_unlock(&unnamed_dev_lock);
+	int i;
+
+	if (!dev)
+		return;		/* or better BUG()? */
+
+	for (i = 0; i < unnamed_dev_nmaj; i++) {
+		if (unnamed_maj_in_use[i] == MAJOR(dev)) {
+			spin_lock(&unnamed_dev_lock);
+			if (!test_and_clear_bit(i * 256 + MINOR(dev),
+			    unnamed_dev_in_use)) {
+				printk(KERN_WARNING "VFS: put_unnamed_dev:"
+				    " freeing unused device %s\n",
+				    kdevname(dev));
+			}
+			spin_unlock(&unnamed_dev_lock);
+			break;
+		}
+	}
 }
 
 /**
@@ -631,7 +655,7 @@ struct super_block *get_anon_super(struc
 	int (*compare)(struct super_block *,void *), void *data)
 {
 	struct super_block *s = alloc_super();
-	kdev_t dev;
+	unsigned xbit;
 	struct list_head *p;
 
 	if (!s)
@@ -651,17 +675,17 @@ retry:
 	}
 
 	spin_lock(&unnamed_dev_lock);
-	dev = find_first_zero_bit(unnamed_dev_in_use, Max_anon);
-	if (dev == Max_anon) {
+	xbit = find_first_zero_bit(unnamed_dev_in_use, unnamed_dev_nmaj * 256);
+	if (xbit == unnamed_dev_nmaj * 256) {
 		spin_unlock(&unnamed_dev_lock);
 		spin_unlock(&sb_lock);
 		destroy_super(s);
 		return ERR_PTR(-EMFILE);
 	}
-	set_bit(dev, unnamed_dev_in_use);
+	set_bit(xbit, unnamed_dev_in_use);
 	spin_unlock(&unnamed_dev_lock);
 
-	s->s_dev = dev;
+	s->s_dev = MKDEV(unnamed_maj_in_use[xbit/256], xbit & 255);
 	insert_super(s, type);
 	return s;
 }
@@ -882,3 +906,38 @@ struct vfsmount *kern_mount(struct file_
 {
 	return do_kern_mount(type->name, 0, (char *)type->name, NULL);
 }
+
+/*
+ * The majorhog part grabs more unnamed majors for safety.
+ */
+static int majorhog_open(struct inode *inode, struct file *file)
+{
+	return -EDOM;	/* Something rididculous for identification */
+}
+
+static struct block_device_operations majorhog_fops = {
+	open:		majorhog_open,
+};
+
+/*
+ * XXX This is not compatible with devfs. When devfs is being mounted,
+ * we may get here, so we cannot call devfs_register_blkdev().
+ */
+void majorhog_init(void) 
+{
+	int i, j;
+
+	j = 1;
+	for (i = 1; i < Max_Maj; i++) {
+		if (register_blkdev(unnamed_dev_majors[i],
+		    "unnamed", &majorhog_fops) == 0) {
+			unnamed_maj_in_use[j++] = unnamed_dev_majors[i];
+		} else {
+			printk(KERN_WARNING "Unable to hog major number %d\n",
+			    unnamed_dev_majors[i]);
+		}
+	}
+	unnamed_dev_nmaj = j;
+
+	set_bit(0, unnamed_dev_in_use);
+}
diff -urNp linux-1090/include/linux/fs.h linux-1110/include/linux/fs.h
--- linux-1090/include/linux/fs.h	
+++ linux-1110/include/linux/fs.h	
@@ -207,6 +207,7 @@ extern void buffer_init(unsigned long);
 extern void inode_init(unsigned long);
 extern void mnt_init(unsigned long);
 extern void files_init(unsigned long mempages);
+extern void majorhog_init(void);
 
 /* bh state bits */
 enum bh_state_bits {
