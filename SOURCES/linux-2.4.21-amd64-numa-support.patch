diff -urNp linux-203/arch/x86_64/mm/Makefile linux-204/arch/x86_64/mm/Makefile
--- linux-203/arch/x86_64/mm/Makefile
+++ linux-204/arch/x86_64/mm/Makefile
@@ -12,6 +12,6 @@ obj-y	 := init.o fault.o ioremap.o extab
 obj-$(CONFIG_DISCONTIGMEM) += numa.o
 obj-$(CONFIG_K8_NUMA) += k8topology.o
 
-export-objs := pageattr.o
+export-objs := pageattr.o numa.o
 
 include $(TOPDIR)/Rules.make
diff -urNp linux-203/arch/x86_64/mm/k8topology.c linux-204/arch/x86_64/mm/k8topology.c
--- linux-203/arch/x86_64/mm/k8topology.c
+++ linux-204/arch/x86_64/mm/k8topology.c
@@ -53,44 +53,49 @@ struct node { 
 #define for_all_nodes(n) \
 	for (n=0; n<MAXNODE;n++) if (nodes[n].start!=nodes[n].end)
 
-static __init int compute_hash_shift(struct node *nodes, int numnodes, u64 maxmem)
+static int __init compute_hash_shift(struct node *nodes)
 {
 	int i; 
-	int shift = 24;
-	u64 addr;
+	int shift = 20;
+	u64 addr, maxend = 0UL;
 	
-	/* When in doubt use brute force. */
-	while (shift < 48) { 
-		memset(memnodemap,0xff,sizeof(*memnodemap) * NODEMAPSIZE); 
-		for_all_nodes (i) { 
-			for (addr = nodes[i].start; 
-			     addr < nodes[i].end; 
-			     addr += (1UL << shift)) {
-				if (memnodemap[addr >> shift] != 0xff && 
-				    memnodemap[addr >> shift] != i) { 
-					printk("node %d shift %d addr %Lx conflict %d\n", 
-					       i, shift, addr, memnodemap[addr>>shift]);
-					goto next; 
-				} 
-				memnodemap[addr >> shift] = i; 
+	for (i = 0; i < MAXNODE; i++)
+		if ((nodes[i].start != nodes[i].end) && (nodes[i].end > maxend))
+			maxend = nodes[i].end;
+
+	while ((1UL << shift) < (maxend / NODEMAPSIZE))
+		shift++;
+
+	memset(memnodemap, 0xff, sizeof(*memnodemap) * NODEMAPSIZE);
+	for (i = 0; i < MAXNODE; i++) {
+		if (nodes[i].start == nodes[i].end)
+			continue;
+		for (addr = nodes[i].start;
+		     addr < nodes[i].end;
+		     addr += (1UL << shift)) {
+			if (memnodemap[addr >> shift] != 0xff) {
+				printk(KERN_INFO
+	"Your memory is not aligned - you need to rebuild your kernel "
+	"with a bigger NODEMAPSIZE (shift=%d addr=%lx)\n",
+					shift, addr);
+				return -1;
 			} 
+			memnodemap[addr >> shift] = i;
 		} 
-		return shift; 
-	next:
-		shift++; 
 	} 
-	memset(memnodemap,0,sizeof(*memnodemap) * NODEMAPSIZE); 
-	return -1; 
+	return shift;
 }
 
 extern unsigned long nodes_present;
 extern unsigned long end_pfn;
+int numa_nodes;
 
 int __init k8_scan_nodes(unsigned long start, unsigned long end)
 { 
 	unsigned long prevbase;
 	struct node nodes[MAXNODE];
-	int nodeid, numnodes, maxnode, i, nb; 
+	u32 reg;
+	int nodeid, maxnode, i, nb;
 
 	nb = find_northbridge(); 
 	if (nb < 0) 
@@ -98,7 +103,9 @@ int __init k8_scan_nodes(unsigned long s
 
 	printk(KERN_INFO "Scanning NUMA topology in Northbridge %d\n", nb); 
 
-	numnodes = (read_pci_config(0, nb, 0, 0x60 ) >> 4) & 3; 
+	reg = read_pci_config(0, nb, 0, 0x60);
+	numa_nodes = ((reg >> 4) & 7) + 1;
+	printk(KERN_INFO "Number of nodes: %d (%x)\n", numa_nodes, reg);
 
 	memset(&nodes,0,sizeof(nodes)); 
 	prevbase = 0;
@@ -109,7 +116,19 @@ int __init k8_scan_nodes(unsigned long s
 		base = read_pci_config(0, nb, 1, 0x40 + i*8);
 		limit = read_pci_config(0, nb, 1, 0x44 + i*8);
 
-		nodeid = limit & 3; 
+		nodeid = limit & 7;
+
+		if ((base & 3) == 0) {
+			if (i < numa_nodes)
+				printk(KERN_INFO "Skipping disabled node %d\n", i);
+			continue;
+		}
+		if (nodeid >= numa_nodes) {
+			printk(KERN_INFO "Ignoring excess node %d (%lx:%lx)\n", nodeid,
+				base, limit);
+			continue;
+		}
+
 		if (!limit) { 
 			printk(KERN_INFO "Skipping node entry %d (base %lx)\n", i,			       base);
 			continue;
@@ -169,7 +188,7 @@ int __init k8_scan_nodes(unsigned long s
 	if (maxnode <= 0)
 		return -1; 
 
-	memnode_shift = compute_hash_shift(nodes,maxnode,end);
+	memnode_shift = compute_hash_shift(nodes);
 	if (memnode_shift < 0) { 
 		printk(KERN_ERR "No NUMA node hash function found. Contact maintainer\n"); 
 		return -1; 
diff -urNp linux-203/arch/x86_64/mm/numa.c linux-204/arch/x86_64/mm/numa.c
--- linux-203/arch/x86_64/mm/numa.c
+++ linux-204/arch/x86_64/mm/numa.c
@@ -9,6 +9,7 @@
 #include <linux/init.h>
 #include <linux/bootmem.h>
 #include <linux/mmzone.h>
+#include <linux/mm_inline.h>
 #include <linux/blk.h>
 #include <asm/e820.h>
 #include <asm/proto.h>
@@ -76,6 +77,8 @@ void __init setup_node_bootmem(int nodei
 	nodes_present |= (1UL << nodeid); 
 } 
 
+EXPORT_SYMBOL(maxnode);
+
 /* Initialize final allocator for a zone */
 void __init setup_node_zones(int nodeid)
 { 
diff -urNp linux-203/include/asm-x86_64/mmzone.h linux-204/include/asm-x86_64/mmzone.h
--- linux-203/include/asm-x86_64/mmzone.h
+++ linux-204/include/asm-x86_64/mmzone.h
@@ -110,6 +110,8 @@ paddr_to_local_pfn(unsigned long phys_ad
 	} else { 
 		nid = phys_to_nid(phys_addr); 
 	} 			   
+	if (nid > maxnode)
+		return BAD_PAGE;
 	plat_pg_data_t *plat_pgdat = plat_node_data[nid]; 
 	unsigned long pfn = phys_addr >> PAGE_SHIFT; 
 	VIRTUAL_BUG_ON(pfn >= plat_pgdat->end_pfn);
@@ -156,6 +158,8 @@ paddr_to_local_pfn(unsigned long phys_ad
 
 extern void setup_node_bootmem(int nodeid, unsigned long start_, unsigned long end_);
 
+#define pfn_valid(pfn) ((pfn) >= num_physpages ? 0 : \
+				(phys_to_nid((pfn) << PAGE_SHIFT) != 0xff))
 
 #ifdef CONFIG_NUMA
 extern int fake_node;
diff -urNp linux-203/include/asm-x86_64/page.h linux-204/include/asm-x86_64/page.h
--- linux-203/include/asm-x86_64/page.h
+++ linux-204/include/asm-x86_64/page.h
@@ -133,8 +133,6 @@ extern __inline__ int get_order(unsigned
 #define page_to_pfn(page)	((unsigned long)((page) - mem_map))
 #define pfn_valid(pfn)		((pfn) < max_mapnr)
 #define VALID_PAGE(page)	(((page) - mem_map) < max_mapnr)
-#else
-#include <asm/mmzone.h>
 #endif
 
 #define pfn_to_phys(pfn)	((unsigned long)(pfn) << PAGE_SHIFT)
diff -urNp linux-203/mm/oom_kill.c linux-204/mm/oom_kill.c
--- linux-203/mm/oom_kill.c
+++ linux-204/mm/oom_kill.c
@@ -191,6 +191,15 @@ static void oom_kill(void)
 	 * for more memory.
 	 */
 	yield();
+#ifdef CONFIG_K8_NUMA
+	{
+		extern int numa_nodes;
+		if (numa_nodes > 1) {
+			printk(KERN_INFO "OOM kill occurred on an x86_64 NUMA system!\n");
+			printk(KERN_INFO "The numa=off boot option might help avoid this.\n");
+		}
+	}
+#endif
 	return;
 }
 
