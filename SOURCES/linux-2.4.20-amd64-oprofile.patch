diff -urNp linux-181/arch/x86_64/Makefile linux-190/arch/x86_64/Makefile
--- linux-181/arch/x86_64/Makefile
+++ linux-190/arch/x86_64/Makefile
@@ -68,6 +68,14 @@ endif
 
 CORE_FILES += $(core-y)
 
+# FIXME: is drivers- right ?
+ifdef CONFIG_OPROFILE
+SUBDIRS += arch/x86_64/oprofile
+ifeq ($(CONFIG_OPROFILE),y)
+DRIVERS += arch/x86_64/oprofile/oprofile.o
+endif
+endif
+
 arch/x86_64/tools: dummy
 	$(MAKE) linuxsubdirs SUBDIRS=arch/x86_64/tools 
 
diff -urNp linux-181/arch/x86_64/config.in linux-190/arch/x86_64/config.in
--- linux-181/arch/x86_64/config.in
+++ linux-190/arch/x86_64/config.in
@@ -232,6 +232,8 @@ source drivers/usb/Config.in
 
 source net/bluetooth/Config.in
 
+source arch/x86_64/oprofile/Config.in
+ 
 mainmenu_option next_comment
 comment 'Kernel hacking'
 
diff -urNp linux-181/arch/x86_64/ia32/ia32entry.S linux-190/arch/x86_64/ia32/ia32entry.S
--- linux-181/arch/x86_64/ia32/ia32entry.S
+++ linux-190/arch/x86_64/ia32/ia32entry.S
@@ -369,9 +369,23 @@ ia32_sys_call_table:
 	.quad sys_fremovexattr
 	.quad sys_tkill
 	.quad sys_sendfile64
-	.quad quiet_ni_syscall  /* futex */
+	.quad quiet_ni_syscall  /* 240 futex */
 	.quad quiet_ni_syscall  /* sched_setaffinity */
 	.quad quiet_ni_syscall  /* sched_getaffinity */	
+	.quad sys_ni_syscall
+	.quad sys_ni_syscall
+	.quad sys_ni_syscall	/* 245 */
+	.quad sys_ni_syscall
+	.quad sys_ni_syscall
+	.quad sys_ni_syscall
+	.quad sys_ni_syscall
+	.quad sys_ni_syscall	/* 250 */
+	.quad sys_ni_syscall /* free_huge_pages */
+	.quad sys_ni_syscall /* exit_group */
+	.quad sys_lookup_dcookie
+	.quad sys_ni_syscall
+	.quad sys_ni_syscall	/* 255 */
+
 ia32_syscall_end:		
 	.rept IA32_NR_syscalls-(ia32_syscall_end-ia32_sys_call_table)/8
 		.quad ni_syscall
diff -urNp linux-181/arch/x86_64/kernel/apic.c linux-190/arch/x86_64/kernel/apic.c
--- linux-181/arch/x86_64/kernel/apic.c
+++ linux-190/arch/x86_64/kernel/apic.c
@@ -920,17 +920,9 @@ int setup_profiling_timer(unsigned int m
 
 inline void smp_local_timer_interrupt(struct pt_regs *regs)
 {
-	int user = user_mode(regs);
 	int cpu = smp_processor_id();
 
-	/*
-	 * The profiling function is SMP safe. (nothing can mess
-	 * around with "current", and the profiling counters are
-	 * updated with atomic operations). This is especially
-	 * useful with a profiling multiplier != 1
-	 */
-	if (!user)
-		x86_do_profile(regs->rip);
+	x86_do_profile(regs);
 
 	if (--prof_counter[cpu] <= 0) {
 		/*
@@ -948,7 +940,7 @@ inline void smp_local_timer_interrupt(st
 		}
 
 #ifdef CONFIG_SMP
-		update_process_times(user);
+		update_process_times(user_mode(regs));
 #endif
 	}
 
diff -urNp linux-181/arch/x86_64/kernel/nmi.c linux-190/arch/x86_64/kernel/nmi.c
--- linux-181/arch/x86_64/kernel/nmi.c
+++ linux-190/arch/x86_64/kernel/nmi.c
@@ -174,6 +174,18 @@ static int nmi_pm_callback(struct pm_dev
 	return 0;
 }
 
+struct pm_dev * set_nmi_pm_callback(pm_callback callback)
+{
+	apic_pm_unregister(nmi_pmdev);
+	return apic_pm_register(PM_SYS_DEV, 0, callback);
+}
+
+void unset_nmi_pm_callback(struct pm_dev * dev)
+{
+	apic_pm_unregister(dev);
+	nmi_pmdev = apic_pm_register(PM_SYS_DEV, 0, nmi_pm_callback);
+}
+
 static void nmi_pm_init(void)
 {
 	if (!nmi_pmdev)
diff -urNp linux-181/arch/x86_64/kernel/traps.c linux-190/arch/x86_64/kernel/traps.c
--- linux-181/arch/x86_64/kernel/traps.c
+++ linux-190/arch/x86_64/kernel/traps.c
@@ -35,6 +35,7 @@
 #include <asm/debugreg.h>
 #include <asm/desc.h>
 #include <asm/i387.h>
+#include <asm/nmi.h>
 #include <asm/kdebug.h>
 
 #include <asm/smp.h>
@@ -534,16 +535,15 @@ static void io_check_error(unsigned char
 
 static void unknown_nmi_error(unsigned char reason, struct pt_regs * regs)
 {
-	printk("Uhhuh. NMI received for unknown reason %02x.\n", reason);
+	printk("Uhhuh. NMI received for unknown reason %02x on CPU %d.\n",
+		reason, smp_processor_id());
 	printk("Dazed and confused, but trying to continue\n");
 	printk("Do you have a strange power saving mode enabled?\n");
 }
 
-asmlinkage void do_nmi(struct pt_regs * regs)
+static void default_do_nmi(struct pt_regs * regs)
 {
 	unsigned char reason = inb(0x61);
-
-	++nmi_count(safe_smp_processor_id());
 	
 	if (!(reason & 0xc0)) {
 #if CONFIG_X86_LOCAL_APIC
@@ -576,6 +576,34 @@ asmlinkage void do_nmi(struct pt_regs * 
 	inb(0x71);		/* dummy */
 }
 
+static int dummy_nmi_callback(struct pt_regs * regs, int cpu)
+{
+	return 0;
+}
+ 
+static nmi_callback_t nmi_callback = dummy_nmi_callback;
+ 
+asmlinkage void do_nmi(struct pt_regs * regs, long error_code)
+{
+	int cpu = smp_processor_id();
+
+	++nmi_count(cpu);
+
+	if (!nmi_callback(regs, cpu))
+		default_do_nmi(regs);
+}
+
+void set_nmi_callback(nmi_callback_t callback)
+{
+	nmi_callback = callback;
+}
+
+void unset_nmi_callback(void)
+{
+	nmi_callback = dummy_nmi_callback;
+}
+
+
 asmlinkage void do_debug(struct pt_regs * regs, long error_code)
 {
 	unsigned long condition;
diff -urNp linux-181/arch/x86_64/kernel/x8664_ksyms.c linux-190/arch/x86_64/kernel/x8664_ksyms.c
--- linux-181/arch/x86_64/kernel/x8664_ksyms.c
+++ linux-190/arch/x86_64/kernel/x8664_ksyms.c
@@ -24,6 +24,7 @@
 #include <asm/delay.h>
 #include <asm/irq.h>
 #include <asm/mmx.h>
+#include <asm/nmi.h>
 #include <asm/desc.h>
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
@@ -124,6 +125,11 @@ EXPORT_SYMBOL(smp_call_function);
 EXPORT_SYMBOL(flush_tlb_page);
 #endif
 
+#if defined(CONFIG_X86_LOCAL_APIC) && defined(CONFIG_PM)
+EXPORT_SYMBOL_GPL(set_nmi_pm_callback);
+EXPORT_SYMBOL_GPL(unset_nmi_pm_callback);
+#endif
+
 #ifdef CONFIG_MCA
 EXPORT_SYMBOL(machine_id);
 #endif
@@ -136,6 +142,9 @@ EXPORT_SYMBOL(get_wchan);
 
 EXPORT_SYMBOL(rtc_lock);
 
+EXPORT_SYMBOL_GPL(set_nmi_callback);
+EXPORT_SYMBOL_GPL(unset_nmi_callback);
+
 /* Export string functions. We normally rely on gcc builtin for most of these,
    but gcc sometimes decides not to inline them. */    
 #undef memcpy
diff -urNp linux-181/arch/x86_64/oprofile/Config.help linux-190/arch/x86_64/oprofile/Config.help
--- linux-181/arch/x86_64/oprofile/Config.help
+++ linux-190/arch/x86_64/oprofile/Config.help
@@ -0,0 +1,6 @@
+CONFIG_OPROFILE
+  OProfile is a profiling system capable of profiling the
+  whole system, include the kernel, kernel modules, libraries,
+  and applications.
+
+  If unsure, say N.
diff -urNp linux-181/arch/x86_64/oprofile/Config.in linux-190/arch/x86_64/oprofile/Config.in
--- linux-181/arch/x86_64/oprofile/Config.in
+++ linux-190/arch/x86_64/oprofile/Config.in
@@ -0,0 +1,9 @@
+if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Profiling support'
+   bool 'Profiling support (EXPERIMENTAL)' CONFIG_PROFILING
+   if [ "$CONFIG_PROFILING" = "y" ]; then
+      tristate '  OProfile system profiling (EXPERIMENTAL)' CONFIG_OPROFILE
+   fi
+   endmenu
+fi
diff -urNp linux-181/arch/x86_64/oprofile/Makefile linux-190/arch/x86_64/oprofile/Makefile
--- linux-181/arch/x86_64/oprofile/Makefile
+++ linux-190/arch/x86_64/oprofile/Makefile
@@ -0,0 +1,37 @@
+#
+# oprofile for x86-64.
+# Just reuse the one from i386. The Hammer performance counters 
+# are similar to Athlon.
+#
+
+O_TARGET:=oprofile.o
+obj-m := $(O_TARGET)
+obj-y = init.o timer_int.o \
+	$(addprefix ../../../drivers/oprofile/, \
+	oprof.o cpu_buffer.o buffer_sync.o \
+	event_buffer.o oprofile_files.o \
+	oprofilefs.o oprofile_stats.o )
+ 
+ifeq ($(CONFIG_X86_LOCAL_APIC),y)
+obj-y += nmi_int.o op_model_athlon.o
+endif
+ 
+obj	:= .
+INCL := $(obj)/op_counter.h $(obj)/op_x86_model.h
+
+$(obj)/nmi_int.c: ${INCL}
+	@ln -sf ../../i386/oprofile/nmi_int.c $(obj)/nmi_int.c
+$(obj)/op_model_athlon.c: ${INCL}
+	@ln -sf ../../i386/oprofile/op_model_athlon.c $(obj)/op_model_athlon.c
+$(obj)/init.c: ${INCL}
+	@ln -sf ../../i386/oprofile/init.c $(obj)/init.c
+$(obj)/timer_int.c: ${INCL}
+	@ln -sf ../../i386/oprofile/timer_int.c $(obj)/timer_int.c
+$(obj)/op_counter.h: 
+	@ln -sf ../../i386/oprofile/op_counter.h $(obj)/op_counter.h
+$(obj)/op_x86_model.h:
+	@ln -sf ../../i386/oprofile/op_x86_model.h $(obj)/op_x86_model.h	
+clean-files += op_x86_model.h op_counter.h timer_int.c init.c \
+	       op_model_athlon.c nmi_int.c
+
+include $(TOPDIR)/Rules.make
diff -urNp linux-181/include/asm-x86_64/hw_irq.h linux-190/include/asm-x86_64/hw_irq.h
--- linux-181/include/asm-x86_64/hw_irq.h
+++ linux-190/include/asm-x86_64/hw_irq.h
@@ -19,6 +19,7 @@
 
 #include <linux/config.h>
 #include <linux/stddef.h>
+#include <linux/profile.h>
 #include <asm/atomic.h>
 #include <asm/irq.h>
 
@@ -123,20 +124,28 @@ SYMBOL_NAME_STR(IRQ) #nr "_interrupt:\n\
 	"push $" #nr "-256 ; " \
 	"jmp common_interrupt");
 
-extern unsigned long prof_cpu_mask;
-extern unsigned int * prof_buffer;
-extern unsigned long prof_len;
-extern unsigned long prof_shift;
-
 /*
- * x86 profiling function, SMP safe. We might want to do this in
- * assembly totally?
+ * The profiling function is SMP safe. (nothing can mess
+ * around with "current", and the profiling counters are
+ * updated with atomic operations). This is especially
+ * useful with a profiling multiplier != 1
  */
-static inline void x86_do_profile (unsigned long eip)
+static inline void x86_do_profile(struct pt_regs * regs)
 {
+	unsigned long rip;
+	extern unsigned long prof_cpu_mask;
+	extern char _stext;
+ 
+	profile_hook(regs);
+ 
+	if (user_mode(regs))
+		return;
+ 
 	if (!prof_buffer)
 		return;
 
+	rip = regs->rip;
+
 	/*
 	 * Only measure the CPUs specified by /proc/irq/prof_cpu_mask.
 	 * (default is all CPUs.)
@@ -144,16 +153,16 @@ static inline void x86_do_profile (unsig
 	if (!((1<<smp_processor_id()) & prof_cpu_mask))
 		return;
 
-	eip -= (unsigned long) &_stext;
-	eip >>= prof_shift;
+	rip -= (unsigned long) &_stext;
+	rip >>= prof_shift;
 	/*
-	 * Don't ignore out-of-bounds EIP values silently,
+	 * Don't ignore out-of-bounds RIP values silently,
 	 * put them into the last histogram slot, so if
 	 * present, they will show up as a sharp peak.
 	 */
-	if (eip > prof_len-1)
-		eip = prof_len-1;
-	atomic_inc((atomic_t *)&prof_buffer[eip]);
+	if (rip > prof_len-1)
+		rip = prof_len-1;
+	atomic_inc((atomic_t *)&prof_buffer[rip]);
 }
 
 #ifdef CONFIG_SMP /*more of this file should probably be ifdefed SMP */
diff -urNp linux-181/include/asm-x86_64/msr.h linux-190/include/asm-x86_64/msr.h
--- linux-181/include/asm-x86_64/msr.h
+++ linux-190/include/asm-x86_64/msr.h
@@ -85,8 +85,8 @@
 #define _EFER_NX 11  /* No execute enable */
 
 #define EFER_SCE (1<<_EFER_SCE)
-#define EFER_LME (1<<EFER_LME)
-#define EFER_LMA (1<<EFER_LMA)
+#define EFER_LME (1<<_EFER_LME)
+#define EFER_LMA (1<<_EFER_LMA)
 #define EFER_NX (1<<_EFER_NX)
 
 /* Intel MSRs. Some also available on other CPUs */
@@ -136,7 +136,13 @@
 
 /* K7/K8 MSRs. Not complete. See the architecture manual for a more complete list. */
 #define MSR_K7_EVNTSEL0            0xC0010000
+#define MSR_K7_EVNTSEL1            0xC0010001
+#define MSR_K7_EVNTSEL2            0xC0010002
+#define MSR_K7_EVNTSEL3            0xC0010003
 #define MSR_K7_PERFCTR0            0xC0010004
+#define MSR_K7_PERFCTR1            0xC0010005
+#define MSR_K7_PERFCTR2            0xC0010006
+#define MSR_K7_PERFCTR3            0xC0010007
 #define MSR_K7_EVNTSEL1            0xC0010001
 #define MSR_K7_PERFCTR1            0xC0010005
 #define MSR_K7_EVNTSEL2            0xC0010002
diff -urNp linux-181/include/asm-x86_64/nmi.h linux-190/include/asm-x86_64/nmi.h
--- linux-181/include/asm-x86_64/nmi.h
+++ linux-190/include/asm-x86_64/nmi.h
@@ -0,0 +1,49 @@
+/*
+ *  linux/include/asm-x86_64/nmi.h
+ */
+#ifndef ASM_NMI_H
+#define ASM_NMI_H
+
+#include <linux/pm.h>
+ 
+struct pt_regs;
+ 
+typedef int (*nmi_callback_t)(struct pt_regs * regs, int cpu);
+ 
+/** 
+ * set_nmi_callback
+ *
+ * Set a handler for an NMI. Only one handler may be
+ * set. Return 1 if the NMI was handled.
+ */
+void set_nmi_callback(nmi_callback_t callback);
+ 
+/** 
+ * unset_nmi_callback
+ *
+ * Remove the handler previously set.
+ */
+void unset_nmi_callback(void);
+ 
+#ifdef CONFIG_PM
+ 
+/** Replace the PM callback routine for NMI. */
+struct pm_dev * set_nmi_pm_callback(pm_callback callback);
+
+/** Unset the PM callback routine back to the default. */
+void unset_nmi_pm_callback(struct pm_dev * dev);
+
+#else
+
+static inline struct pm_dev * set_nmi_pm_callback(pm_callback callback)
+{
+	return 0;
+} 
+ 
+static inline void unset_nmi_pm_callback(struct pm_dev * dev)
+{
+}
+
+#endif /* CONFIG_PM */
+ 
+#endif /* ASM_NMI_H */
diff -urNp linux-181/include/asm-x86_64/smp.h linux-190/include/asm-x86_64/smp.h
--- linux-181/include/asm-x86_64/smp.h
+++ linux-190/include/asm-x86_64/smp.h
@@ -26,6 +26,7 @@
 
 #include <asm/pda.h>
 
+
 /*
  * Private routines/data
  */
@@ -42,6 +43,13 @@ extern void smp_invalidate_rcv(void);		/
 extern void (*mtrr_hook) (void);
 extern void zap_low_mappings (void);
 
+/* Newer 2.5 Linux kernels have cpu_possible. This provides equivalent function
+   for the older 2.4 kernels */
+static inline int cpu_possible(int cpu)
+{
+	return (cpu_online_map & (1<<(cpu)));
+} 
+
 /*
  * On x86 all CPUs are mapped 1:1 to the APIC space.
  * This simplifies scheduling and IPI sending and
diff -urNp linux-181/include/asm-x86_64/unistd.h linux-190/include/asm-x86_64/unistd.h
--- linux-181/include/asm-x86_64/unistd.h
+++ linux-190/include/asm-x86_64/unistd.h
@@ -484,7 +484,7 @@ __SYSCALL(__NR_io_cancel, sys_ni_syscall
 #define __NR_get_thread_area	211
 __SYSCALL(__NR_get_thread_area, sys_ni_syscall)
 #define __NR_lookup_dcookie     212
-__SYSCALL(__NR_lookup_dcookie, sys_ni_syscall)
+__SYSCALL(__NR_lookup_dcookie, sys_lookup_dcookie)
 #define __NR_epoll_create       213
 __SYSCALL(__NR_epoll_create, sys_ni_syscall)
 #define __NR_epoll_ctl  214
@@ -703,4 +703,12 @@ static inline pid_t wait(int * wait_stat
 
 #endif /* __NO_STUBS */
 
+/*
+ * "Conditional" syscalls
+ *
+ * What we want is __attribute__((weak,alias("sys_ni_syscall"))),
+ * but it doesn't work on all toolchains, so we just do it by hand
+ */
+#define cond_syscall(x) asm(".weak\t" #x "\n\t.set\t" #x ",sys_ni_syscall");
+
 #endif
