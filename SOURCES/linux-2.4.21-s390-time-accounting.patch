diff -urNp linux-7150/arch/s390/kernel/entry.S linux-7151/arch/s390/kernel/entry.S
--- linux-7150/arch/s390/kernel/entry.S
+++ linux-7151/arch/s390/kernel/entry.S
@@ -717,6 +717,10 @@ io_int_handler:
         SAVE_ALL __LC_IO_OLD_PSW,0
 	mc	0,0
         GET_CURRENT               # load pointer to task_struct to R9
+	stck	__LC_INT_CLOCK
+	clc	__LC_INT_CLOCK(8),__LC_JIFFY_TIMER
+	bhe	BASED(io_handle_tick)
+io_call_handler:
         l       %r1,BASED(.Ldo_IRQ)        # load address of do_IRQ
         la      %r2,SP_PTREGS(%r15) # address of register-save area
         sr      %r3,%r3
@@ -751,6 +755,15 @@ io_leave:
         RESTORE_ALL 0
 
 #
+# account tick
+#
+io_handle_tick:
+	l	%r1,BASED(.Laccount_ticks)
+	la	%r2,SP_PTREGS(%r15)    # address of register-save area
+	la	%r14,BASED(io_call_handler)
+	br	%r1
+
+#
 # call do_softirq
 #
 io_handle_bottom_half:
@@ -787,6 +800,10 @@ ext_int_handler:
 	mc	0,0
         GET_CURRENT                    # load pointer to task_struct to R9
 	lh	%r6,__LC_EXT_INT_CODE  # get interruption code
+	stck	__LC_INT_CLOCK
+	clc	__LC_INT_CLOCK(8),__LC_JIFFY_TIMER
+	bhe	BASED(ext_handle_tick)
+ext_call_handler:
 	lr	%r1,%r6		       # calculate index = code & 0xff
 	n	%r1,BASED(.Lc0xff)
 	sll	%r1,2
@@ -807,6 +824,15 @@ ext_int_next:
 	bnz	BASED(ext_int_loop)
 	b	BASED(io_return)
 
+#
+# account tick
+#
+ext_handle_tick:
+	l	%r1,BASED(.Laccount_ticks)
+	la	%r2,SP_PTREGS(%r15)    # address of register-save area
+	la	%r14,BASED(ext_call_handler)
+	br	%r1
+
 /*
  * Machine check handler routines
  */
@@ -899,3 +925,4 @@ restart_go:
 
 .Lschedtail:   .long  schedule_tail
 
+.Laccount_ticks:.long account_ticks
diff -urNp linux-7150/arch/s390/kernel/time.c linux-7151/arch/s390/kernel/time.c
--- linux-7150/arch/s390/kernel/time.c
+++ linux-7151/arch/s390/kernel/time.c
@@ -215,24 +215,14 @@ static inline __u32 div64_32(__u64 divid
  * timer_interrupt() needs to keep up the real-time clock,
  * as well as call the "do_timer()" routine every clocktick
  */
-static void do_comparator_interrupt(struct pt_regs *regs, __u16 error_code)
+void account_ticks(struct pt_regs *regs)
 {
 	int cpu = smp_processor_id();
 	u64 tmp;
 	u32 ticks;
 
-	/*
-	 * Calculate how many ticks have passed.
-	 *
-	 * This segment uses STCK as the 2.4.19 IBM stream did.
-	 * The reset is taken from the RHEL patch by Jan Gauber,
-	 * with additional case against fixpoint division fault (on boot)
-	 * by Martin Schwidefsky (if delta<0 return). XXX Wrapping?
-	 */
-	asm volatile ("STCK 0(%0)" : : "a" (&tmp) : "memory", "cc");
-	if (tmp < S390_lowcore.jiffy_timer)
-		return;
-	tmp = tmp - S390_lowcore.jiffy_timer;
+	/* Calculate how many ticks have passed. */
+	tmp = S390_lowcore.int_clock - S390_lowcore.jiffy_timer;
 	if (tmp >= 2*CLK_TICKS_PER_JIFFY) {
 		ticks = div64_32(tmp >> 1, CLK_TICKS_PER_JIFFY >> 1) + 1;
 		S390_lowcore.jiffy_timer +=
@@ -341,7 +331,7 @@ void __init time_init(void)
         tod_to_timeval(set_time_cc, &xtime);
 
         /* request the 0x1004 external interrupt */
-        if (register_early_external_interrupt(0x1004, do_comparator_interrupt,
+        if (register_early_external_interrupt(0x1004, NULL,
 					      &ext_int_info_timer) != 0)
                 panic("Couldn't request external interrupt 0x1004");
 
diff -urNp linux-7150/arch/s390x/kernel/entry.S linux-7151/arch/s390x/kernel/entry.S
--- linux-7150/arch/s390x/kernel/entry.S
+++ linux-7151/arch/s390x/kernel/entry.S
@@ -754,6 +754,10 @@ io_int_handler:
         SAVE_ALL __LC_IO_OLD_PSW,0
 	mc	0,0
         GET_CURRENT                    # load pointer to task_struct to R9
+	stck	__LC_INT_CLOCK
+	clc	__LC_INT_CLOCK(8),__LC_JIFFY_TIMER
+	jhe	io_handle_tick
+io_call_handler:
         la      %r2,SP_PTREGS(%r15)    # address of register-save area
 	llgh    %r3,__LC_SUBCHANNEL_NR # load subchannel number
         llgf    %r4,__LC_IO_INT_PARM   # load interuption parm
@@ -811,6 +815,14 @@ io_signal_return:     
 	larl    %r14,io_leave
         jg      do_signal           # return point is io_leave
 
+#
+# account tick
+#
+io_handle_tick:
+	la	%r2,SP_PTREGS(%r15)    # address of register-save area
+	larl	%r14,io_call_handler
+	jg	account_ticks
+
 /*
  * External interrupt handler routine
  */
@@ -820,6 +832,10 @@ ext_int_handler:
 	mc	0,0
         GET_CURRENT                    # load pointer to task_struct to R9
 	llgh	%r6,__LC_EXT_INT_CODE  # get interruption code
+	stck	__LC_INT_CLOCK
+	clc	__LC_INT_CLOCK(8),__LC_JIFFY_TIMER
+	jhe	ext_handle_tick
+ext_call_handler:
 	lgr	%r1,%r6		       # calculate index = code & 0xff
 	nill	%r1,0xff
 	sll	%r1,3
@@ -842,6 +858,14 @@ ext_int_next:
 	jnz	ext_int_loop
 	j	io_return
 
+#
+# account tick
+#
+ext_handle_tick:
+	la	%r2,SP_PTREGS(%r15)    # address of register-save area
+	larl	%r14,ext_call_handler
+	jg	account_ticks
+
 /*
  * Machine check handler routines
  */
diff -urNp linux-7150/arch/s390x/kernel/time.c linux-7151/arch/s390x/kernel/time.c
--- linux-7150/arch/s390x/kernel/time.c
+++ linux-7151/arch/s390x/kernel/time.c
@@ -179,7 +179,7 @@ static inline void s390_do_profile(struc
  * timer_interrupt() needs to keep up the real-time clock,
  * as well as call the "do_timer()" routine every clocktick
  */
-static void do_comparator_interrupt(struct pt_regs *regs, __u16 error_code)
+void account_ticks(struct pt_regs *regs)
 {
 	int cpu = smp_processor_id();
 	u64 tmp;
@@ -187,16 +187,8 @@ static void do_comparator_interrupt(stru
 
 	/*
 	 * Calculate how many ticks have passed.
-	 *
-	 * This segment uses STCK as the 2.4.19 IBM stream did.
-	 * The reset is taken from the RHEL patch by Jan Gauber,
-	 * with additional case against fixpoint division fault (on boot)
-	 * by Martin Schwidefsky (if delta<0 return). XXX Wrapping?
 	 */
-	asm volatile ("STCK 0(%0)" : : "a" (&tmp) : "memory", "cc");
-	if (tmp < S390_lowcore.jiffy_timer)
-		return;
-	tmp = tmp - S390_lowcore.jiffy_timer;
+	tmp = S390_lowcore.int_clock - S390_lowcore.jiffy_timer;
 	if (tmp >= 2*CLK_TICKS_PER_JIFFY) {
 		ticks = tmp / CLK_TICKS_PER_JIFFY + 1;
 		S390_lowcore.jiffy_timer +=
@@ -305,7 +297,7 @@ void __init time_init(void)
         tod_to_timeval(set_time_cc, &xtime);
 
         /* request the 0x1004 external interrupt */
-        if (register_early_external_interrupt(0x1004, do_comparator_interrupt,
+        if (register_early_external_interrupt(0x1004, NULL,
 					      &ext_int_info_timer) != 0)
                 panic("Couldn't request external interrupt 0x1004");
 
diff -urNp linux-7150/include/asm-s390/lowcore.h linux-7151/include/asm-s390/lowcore.h
--- linux-7150/include/asm-s390/lowcore.h
+++ linux-7151/include/asm-s390/lowcore.h
@@ -47,6 +47,7 @@
 #define __LC_IPLDEV                     0xC7C
 
 #define __LC_JIFFY_TIMER		0xC80
+#define __LC_INT_CLOCK			0xC88
 
 #define __LC_PANIC_MAGIC                0xE00
 
@@ -165,8 +166,9 @@ struct _lowcore
 
         /* SMP info area: defined by DJB */
         __u64        jiffy_timer;              /* 0xc80 */
-	atomic_t     ext_call_fast;            /* 0xc88 */
-        __u8         pad11[0xe00-0xc8c];       /* 0xc8c */
+        __u64        int_clock;                /* 0xc88 */
+	atomic_t     ext_call_fast;            /* 0xc90 */
+        __u8         pad11[0xe00-0xc94];       /* 0xc94 */
 
         /* 0xe00 is used as indicator for dump tools */
         /* whether the kernel died with panic() or not */
diff -urNp linux-7150/include/asm-s390x/lowcore.h linux-7151/include/asm-s390x/lowcore.h
--- linux-7150/include/asm-s390x/lowcore.h
+++ linux-7151/include/asm-s390x/lowcore.h
@@ -48,6 +48,7 @@
 #define __LC_IPLDEV                     0xDB8
 
 #define __LC_JIFFY_TIMER		0xDC0
+#define __LC_INT_CLOCK			0xDC8
 
 #define __LC_PANIC_MAGIC                0xE00
 
@@ -164,8 +165,9 @@ struct _lowcore
 
         /* SMP info area: defined by DJB */
         __u64        jiffy_timer;              /* 0xdc0 */
-	__u64        ext_call_fast;            /* 0xdc8 */
-        __u8         pad12[0xe00-0xdd0];       /* 0xdd0 */
+        __u64        int_clock;                /* 0xdc8 */
+	__u64        ext_call_fast;            /* 0xdd0 */
+        __u8         pad12[0xe00-0xdd8];       /* 0xdd8 */
 
         /* 0xe00 is used as indicator for dump tools */
         /* whether the kernel died with panic() or not */
