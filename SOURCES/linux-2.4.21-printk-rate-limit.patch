diff -urNp linux-7160/drivers/scsi/scsi_lib.c linux-7170/drivers/scsi/scsi_lib.c
--- linux-7160/drivers/scsi/scsi_lib.c
+++ linux-7170/drivers/scsi/scsi_lib.c
@@ -417,10 +417,9 @@ static Scsi_Cmnd *__scsi_end_request(Scs
 
 	req = &SCpnt->request;
 	req->errors = 0;
-	if (!uptodate) {
+	if (!uptodate && printk_ratelimit())
 		printk(" I/O error: dev %s, sector %lu\n",
-		       kdevname(req->rq_dev), req->sector);
-	}
+			kdevname(req->rq_dev), req->sector);
 	do {
 		if ((bh = req->bh) != NULL) {
 			nsect = bh->b_size >> 9;
@@ -790,12 +789,14 @@ void scsi_io_completion(Scsi_Cmnd * SCpn
 		struct Scsi_Device_Template *STpnt;
 
 		STpnt = scsi_get_request_dev(&SCpnt->request);
-		printk("SCSI %s error : host %d channel %d id %d lun %d return code = %x\n",
-		       (STpnt ? STpnt->name : "device"),
-		       SCpnt->device->host->host_no,
-		       SCpnt->device->channel,
-		       SCpnt->device->id,
-		       SCpnt->device->lun, result);
+		if (printk_ratelimit())
+			printk("SCSI %s error : host %d channel %d id %d lun %d "
+				"return code = %x\n",
+				(STpnt ? STpnt->name : "device"),
+				SCpnt->device->host->host_no,
+				SCpnt->device->channel,
+				SCpnt->device->id,
+				SCpnt->device->lun, result);
 
 		if (driver_byte(result) & DRIVER_SENSE)
 			print_sense("sd", SCpnt);
diff -urNp linux-7160/include/linux/kernel.h linux-7170/include/linux/kernel.h
--- linux-7160/include/linux/kernel.h
+++ linux-7170/include/linux/kernel.h
@@ -97,6 +97,8 @@ extern int session_of_pgrp(int pgrp);
 asmlinkage int printk(const char * fmt, ...)
 	__attribute__ ((format (printf, 1, 2)));
 
+extern int printk_ratelimit(void);
+
 static inline void console_silent(void)
 {
 	console_loglevel = 0;
diff -urNp linux-7160/include/linux/sysctl.h linux-7170/include/linux/sysctl.h
--- linux-7160/include/linux/sysctl.h
+++ linux-7170/include/linux/sysctl.h
@@ -133,6 +133,8 @@ enum
 	KERN_S390_HZ_TIMER=62,	/* int: hz timer on or off */
 	KERN_UNKNOWN_NMI_PANIC=63, /* int: unknown nmi panic flag */
 	KERN_MEM_NMI_PANIC=64,  /* int: memory nmi panic flag */
+	KERN_PRINTK_RATELIMIT=65, /* int: tune printk ratelimiting */
+	KERN_PRINTK_RATELIMIT_BURST=66,	/* int: tune printk ratelimiting */
 };
 
 
diff -urNp linux-7160/kernel/printk.c linux-7170/kernel/printk.c
--- linux-7160/kernel/printk.c
+++ linux-7170/kernel/printk.c
@@ -765,3 +765,48 @@ void tty_write_message(struct tty_struct
 		tty->driver.write(tty, 0, msg, strlen(msg));
 	return;
 }
+
+/* minimum time in jiffies between messages */
+int printk_ratelimit_jiffies = 0*HZ;
+
+/* number of messages we send before ratelimiting */
+int printk_ratelimit_burst = 10;
+
+/*
+ * printk rate limiting, lifted from the networking subsystem.
+ *
+ * This enforces a rate limit: not more than one kernel message
+ * every printk_ratelimit_jiffies to make a denial-of-service
+ * attack impossible.
+ */
+int printk_ratelimit(void)
+{
+	static spinlock_t ratelimit_lock = SPIN_LOCK_UNLOCKED;
+	static unsigned long toks = 10*5*HZ;
+	static unsigned long last_msg;
+	static int missed;
+	unsigned long flags;
+	unsigned long now = jiffies;
+
+	if (!printk_ratelimit_jiffies)
+		return 1;
+
+	spin_lock_irqsave(&ratelimit_lock, flags);
+	toks += now - last_msg;
+	last_msg = now;
+	if (toks > (printk_ratelimit_burst * printk_ratelimit_jiffies))
+		toks = printk_ratelimit_burst * printk_ratelimit_jiffies;
+	if (toks >= printk_ratelimit_jiffies) {
+		int lost = missed;
+		missed = 0;
+		toks -= printk_ratelimit_jiffies;
+		spin_unlock_irqrestore(&ratelimit_lock, flags);
+		if (lost)
+			printk(KERN_WARNING "printk: %d messages suppressed.\n", lost);
+		return 1;
+	}
+	missed++;
+	spin_unlock_irqrestore(&ratelimit_lock, flags);
+	return 0;
+}
+EXPORT_SYMBOL(printk_ratelimit);
diff -urNp linux-7160/kernel/sysctl.c linux-7170/kernel/sysctl.c
--- linux-7160/kernel/sysctl.c
+++ linux-7170/kernel/sysctl.c
@@ -72,6 +72,8 @@ int exec_shield = 1;
 extern int exec_shield32;
 #endif
 int exec_shield_randomize = 1;
+extern int printk_ratelimit_jiffies;
+extern int printk_ratelimit_burst;
 
 /* this is needed for the proc_dointvec_minmax for [fs_]overflow UID and GID */
 static int maxolduid = 65535;
@@ -209,6 +211,10 @@ static ctl_table kern_table[] = {
 	 0644, NULL, &proc_dointvec},
 	{KERN_PANIC, "panic_on_oops", &panic_on_oops, sizeof(int),
 	 0644, NULL, &proc_dointvec},
+	{KERN_PRINTK_RATELIMIT, "printk_ratelimit", &printk_ratelimit_jiffies,
+	 sizeof(int), 0644, NULL, &proc_dointvec_jiffies},
+	{KERN_PRINTK_RATELIMIT_BURST, "printk_ratelimit_burst",
+	 &printk_ratelimit_burst, sizeof(int), 0644, NULL, &proc_dointvec},
 	{KERN_PANIC, "print_fatal_signals", &print_fatal_signals, sizeof(int),
 	 0644, NULL, &proc_dointvec},
 	{KERN_PANIC, "exec-shield", &exec_shield, sizeof(int),
