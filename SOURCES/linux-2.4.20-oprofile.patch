diff -urNp linux-781/Documentation/Configure.help linux-790/Documentation/Configure.help
--- linux-781/Documentation/Configure.help
+++ linux-790/Documentation/Configure.help
@@ -109,6 +109,11 @@ CONFIG_OBSOLETE
   like MGA monitors that you are very unlikely to see on today's
   systems.
 
+Profiling support
+CONFIG_PROFILING
+  Say Y here to enable the extended profiling support mechanisms used
+  by profilers such as OProfile.
+
 Symmetric Multi-Processing support
 CONFIG_SMP
   This enables support for systems with more than one CPU. If you have
diff -urNp linux-781/drivers/oprofile/buffer_sync.c linux-790/drivers/oprofile/buffer_sync.c
--- linux-781/drivers/oprofile/buffer_sync.c
+++ linux-790/drivers/oprofile/buffer_sync.c
@@ -0,0 +1,489 @@
+/**
+ * @file buffer_sync.c
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon <levon@movementarian.org>
+ *
+ * This is the core of the buffer management. Each
+ * CPU buffer is processed and entered into the
+ * global event buffer. Such processing is necessary
+ * in several circumstances, mentioned below.
+ *
+ * The processing does the job of converting the
+ * transitory EIP value into a persistent dentry/offset
+ * value that the profiler can record at its leisure.
+ *
+ * See fs/dcookies.c for a description of the dentry/offset
+ * objects.
+ */
+
+#include <linux/mm.h>
+#include <linux/workqueue.h>
+#include <linux/notifier.h>
+#include <linux/dcookies.h>
+#include <linux/profile.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/spinlock.h>
+
+#include <asm/hardirq.h>
+ 
+#include "oprofile_stats.h"
+#include "event_buffer.h"
+#include "cpu_buffer.h"
+#include "buffer_sync.h"
+ 
+#define DEFAULT_EXPIRE (HZ / 4)
+ 
+static void wq_sync_buffers(void *);
+#if 0
+static DECLARE_WORK(sync_wq, wq_sync_buffers, 0);
+#else
+static struct tq_struct sync_wq = {
+	routine: wq_sync_buffers,
+};
+#endif
+ 
+static struct timer_list sync_timer;
+static void timer_ping(unsigned long data);
+static void sync_cpu_buffers(void);
+
+ 
+/* We must make sure to process every entry in the CPU buffers
+ * before a task got the PF_EXITING flag, otherwise we will hold
+ * references to a possibly freed task_struct. We are safe with
+ * samples past the PF_EXITING point in do_exit(), because we
+ * explicitly check for that in cpu_buffer.c 
+ */
+static int exit_task_notify(struct notifier_block * self, unsigned long val, void * data)
+{
+	sync_cpu_buffers();
+	return 0;
+}
+ 
+/* There are two cases of tasks modifying task->mm->mmap list we
+ * must concern ourselves with. First, when a task is about to
+ * exit (exit_mmap()), we should process the buffer to deal with
+ * any samples in the CPU buffer, before we lose the ->mmap information
+ * we need. Second, a task may unmap (part of) an executable mmap,
+ * so we want to process samples before that happens too
+ */
+static int mm_notify(struct notifier_block * self, unsigned long val, void * data)
+{
+	sync_cpu_buffers();
+	return 0;
+}
+
+ 
+/* We need to be told about new modules so we don't attribute to a previously
+ * loaded module, or drop the samples on the floor.
+ */
+static int module_load_notify(struct notifier_block * self, unsigned long val, void * data)
+{
+#ifdef CONFIG_MODULES
+	if (val != MODULE_STATE_COMING)
+		return 0;
+
+	sync_cpu_buffers();
+	down(&buffer_sem);
+	add_event_entry(ESCAPE_CODE);
+	add_event_entry(MODULE_LOADED_CODE);
+	up(&buffer_sem);
+#endif
+	return 0;
+}
+
+ 
+static struct notifier_block exit_task_nb = {
+	.notifier_call	= exit_task_notify,
+};
+
+static struct notifier_block exec_unmap_nb = {
+	.notifier_call	= mm_notify,
+};
+
+static struct notifier_block exit_mmap_nb = {
+	.notifier_call	= mm_notify,
+};
+
+static struct notifier_block module_load_nb = {
+	.notifier_call = module_load_notify,
+};
+
+ 
+int sync_start(void)
+{
+	int err;
+
+	init_timer(&sync_timer);
+	sync_timer.function = timer_ping;
+	sync_timer.expires = jiffies + DEFAULT_EXPIRE;
+	add_timer(&sync_timer);
+
+	err = profile_event_register(EXIT_TASK, &exit_task_nb);
+	if (err)
+		goto out1;
+	err = profile_event_register(EXIT_MMAP, &exit_mmap_nb);
+	if (err)
+		goto out2;
+	err = profile_event_register(EXEC_UNMAP, &exec_unmap_nb);
+	if (err)
+		goto out3;
+	err = register_module_notifier(&module_load_nb);
+	if (err)
+		goto out4;
+
+out:
+	return err;
+out4:
+	profile_event_unregister(EXEC_UNMAP, &exec_unmap_nb);
+out3:
+	profile_event_unregister(EXIT_MMAP, &exit_mmap_nb);
+out2:
+	profile_event_unregister(EXIT_TASK, &exit_task_nb);
+out1:
+	del_timer_sync(&sync_timer);
+	goto out;
+}
+
+
+void sync_stop(void)
+{
+	unregister_module_notifier(&module_load_nb);
+	profile_event_unregister(EXIT_TASK, &exit_task_nb);
+	profile_event_unregister(EXIT_MMAP, &exit_mmap_nb);
+	profile_event_unregister(EXEC_UNMAP, &exec_unmap_nb);
+	del_timer_sync(&sync_timer);
+}
+
+ 
+/* Optimisation. We can manage without taking the dcookie sem
+ * because we cannot reach this code without at least one
+ * dcookie user still being registered (namely, the reader
+ * of the event buffer). */
+static inline unsigned long fast_get_dcookie(struct dentry * dentry,
+	struct vfsmount * vfsmnt)
+{
+	unsigned long cookie;
+ 
+	if (dentry->d_cookie)
+		return (unsigned long)dentry;
+	get_dcookie(dentry, vfsmnt, &cookie);
+	return cookie;
+}
+
+ 
+/* Look up the dcookie for the task's first VM_EXECUTABLE mapping,
+ * which corresponds loosely to "application name". This is
+ * not strictly necessary but allows oprofile to associate
+ * shared-library samples with particular applications
+ */
+static unsigned long get_exec_dcookie(struct mm_struct * mm)
+{
+	unsigned long cookie = 0;
+	struct vm_area_struct * vma;
+ 
+	if (!mm)
+		goto out;
+ 
+	for (vma = mm->mmap; vma; vma = vma->vm_next) {
+		if (!vma->vm_file)
+			continue;
+		if (!(vma->vm_flags & VM_EXECUTABLE))
+			continue;
+		cookie = fast_get_dcookie(vma->vm_file->f_dentry,
+			vma->vm_file->f_vfsmnt);
+		break;
+	}
+
+out:
+	return cookie;
+}
+
+
+/* Convert the EIP value of a sample into a persistent dentry/offset
+ * pair that can then be added to the global event buffer. We make
+ * sure to do this lookup before a mm->mmap modification happens so
+ * we don't lose track.
+ */
+static unsigned long lookup_dcookie(struct mm_struct * mm, unsigned long addr, off_t * offset)
+{
+	unsigned long cookie = 0;
+	struct vm_area_struct * vma;
+
+	for (vma = find_vma(mm, addr); vma; vma = vma->vm_next) {
+		if (!vma)
+			goto out;
+ 
+		if (!vma->vm_file)
+			continue;
+
+		if (addr < vma->vm_start || addr >= vma->vm_end)
+			continue;
+
+		cookie = fast_get_dcookie(vma->vm_file->f_dentry,
+			vma->vm_file->f_vfsmnt);
+		*offset = (vma->vm_pgoff << PAGE_SHIFT) + addr - vma->vm_start; 
+		break;
+	}
+out:
+	return cookie;
+}
+
+
+static unsigned long last_cookie = ~0UL;
+ 
+static void add_cpu_switch(int i)
+{
+	add_event_entry(ESCAPE_CODE);
+	add_event_entry(CPU_SWITCH_CODE);
+	add_event_entry(i);
+	last_cookie = ~0UL;
+}
+
+static void add_kernel_ctx_switch(unsigned int in_kernel)
+{
+	add_event_entry(ESCAPE_CODE);
+	if (in_kernel)
+		add_event_entry(KERNEL_ENTER_SWITCH_CODE); 
+	else
+		add_event_entry(KERNEL_EXIT_SWITCH_CODE); 
+}
+ 
+static void add_user_ctx_switch(pid_t pid, unsigned long cookie)
+{
+	add_event_entry(ESCAPE_CODE);
+	add_event_entry(CTX_SWITCH_CODE); 
+	add_event_entry(pid);
+	add_event_entry(cookie);
+}
+
+ 
+static void add_cookie_switch(unsigned long cookie)
+{
+	add_event_entry(ESCAPE_CODE);
+	add_event_entry(COOKIE_SWITCH_CODE);
+	add_event_entry(cookie);
+}
+
+ 
+static void add_sample_entry(unsigned long offset, unsigned long event)
+{
+	add_event_entry(offset);
+	add_event_entry(event);
+}
+
+
+static void add_us_sample(struct mm_struct * mm, struct op_sample * s)
+{
+	unsigned long cookie;
+	off_t offset;
+ 
+ 	cookie = lookup_dcookie(mm, s->eip, &offset);
+ 
+	if (!cookie)
+		return;
+
+	if (cookie != last_cookie) {
+		add_cookie_switch(cookie);
+		last_cookie = cookie;
+	}
+
+	add_sample_entry(offset, s->event);
+}
+
+ 
+/* Add a sample to the global event buffer. If possible the
+ * sample is converted into a persistent dentry/offset pair
+ * for later lookup from userspace.
+ */
+static void add_sample(struct mm_struct * mm, struct op_sample * s, int in_kernel)
+{
+	if (in_kernel) {
+		add_sample_entry(s->eip, s->event);
+	} else if (mm) {
+		add_us_sample(mm, s);
+	}
+}
+ 
+ 
+static void release_mm(struct mm_struct * mm)
+{
+	if (mm) {
+		up_read(&mm->mmap_sem);
+		atomic_dec(&mm->mm_users);
+	}
+}
+
+
+/* Take the task's mmap_sem to protect ourselves from
+ * races when we do lookup_dcookie().
+ */
+static struct mm_struct * take_task_mm(struct task_struct * task)
+{
+	struct mm_struct *mm = NULL;
+
+	/* if task->mm !NULL, mm_count must be at least 1. It cannot
+	 * drop to 0 without the task exiting, which will have to sleep
+	 * on buffer_sem first. So we do not need to mark mm_count
+	 * ourselves.
+	 */
+	if (in_interrupt()) {
+		if (spin_trylock(&task->alloc_lock) == 0)
+			return mm;
+	} else
+		task_lock(task);
+
+    mm = task->mm;
+	if (mm) {
+		/* More ugliness. If a task took its mmap
+		 * sem then came to sleep on buffer_sem we
+		 * will deadlock waiting for it. So we can
+		 * but try. This will lose samples :/
+		 */
+		if (!down_read_trylock(&mm->mmap_sem)) {
+			/* FIXME: this underestimates samples lost */
+			atomic_inc(&oprofile_stats.sample_lost_mmap_sem);
+			mm = NULL;
+		} else {
+			/*
+			 * Tell mmput that we have a reference
+			 */
+			atomic_inc(&mm->mm_users);
+		}
+	}
+	task_unlock(task);
+ 
+	return mm;
+}
+ 
+ 
+static inline int is_ctx_switch(unsigned long val)
+{
+	return val == ~0UL;
+}
+ 
+
+/* compute number of filled slots in cpu_buffer queue */
+static unsigned long nr_filled_slots(struct oprofile_cpu_buffer * b)
+{
+	unsigned long head = b->head_pos;
+	unsigned long tail = b->tail_pos;
+
+	if (head >= tail)
+		return head - tail;
+
+	return head + (b->buffer_size - tail);
+}
+
+
+static void increment_tail(struct oprofile_cpu_buffer * b)
+{
+	unsigned long new_tail = b->tail_pos + 1;
+
+	rmb();
+
+	if (new_tail < (b->buffer_size))
+		b->tail_pos = new_tail;
+	else
+		b->tail_pos = 0;
+}
+
+
+/* Sync one of the CPU's buffers into the global event buffer.
+ * Here we need to go through each batch of samples punctuated
+ * by context switch notes, taking the task's mmap_sem and doing
+ * lookup in task->mm->mmap to convert EIP into dcookie/offset
+ * value.
+ */
+static void sync_buffer(struct oprofile_cpu_buffer * cpu_buf)
+{
+	struct mm_struct * mm = 0;
+	struct task_struct * new;
+	unsigned long cookie = 0;
+	int in_kernel = 1;
+	unsigned int i;
+ 
+	/* Remember, only we can modify tail_pos */
+
+	unsigned long const available_elements = nr_filled_slots(cpu_buf);
+  
+	for (i=0; i < available_elements; ++i) {
+		struct op_sample * s = &cpu_buf->buffer[cpu_buf->tail_pos];
+ 
+		if (is_ctx_switch(s->eip)) {
+			if (s->event <= 1) {
+				/* kernel/userspace switch */
+				in_kernel = s->event;
+				add_kernel_ctx_switch(s->event);
+			} else {
+				struct mm_struct * oldmm = mm;
+
+				/* userspace context switch */
+				new = (struct task_struct *)s->event;
+
+				release_mm(oldmm);
+				mm = take_task_mm(new);
+				if (mm != oldmm)
+					cookie = get_exec_dcookie(mm);
+				add_user_ctx_switch(new->pid, cookie);
+			}
+		} else {
+			add_sample(mm, s, in_kernel);
+		}
+
+		increment_tail(cpu_buf);
+	}
+	release_mm(mm);
+
+	cpu_buffer_reset(cpu_buf);
+}
+ 
+ 
+/* Process each CPU's local buffer into the global
+ * event buffer.
+ */
+static void sync_cpu_buffers(void)
+{
+	int i;
+
+	down(&buffer_sem);
+ 
+	for (i = 0; i < NR_CPUS; ++i) {
+		struct oprofile_cpu_buffer * cpu_buf;
+ 
+		if (!cpu_possible(i))
+			continue;
+ 
+		cpu_buf = &cpu_buffer[i];
+ 
+		add_cpu_switch(i);
+		sync_buffer(cpu_buf);
+	}
+
+	up(&buffer_sem);
+ 
+	mod_timer(&sync_timer, jiffies + DEFAULT_EXPIRE);
+}
+ 
+
+static void wq_sync_buffers(void * data)
+{
+	sync_cpu_buffers();
+}
+ 
+ 
+/* It is possible that we could have no munmap() or
+ * other events for a period of time. This will lead
+ * the CPU buffers to overflow and lose samples and
+ * context switches. We try to reduce the problem
+ * by timing out when nothing happens for a while.
+ */
+static void timer_ping(unsigned long data)
+{
+	schedule_task(&sync_wq);
+	/* timer is re-added by the scheduled task */
+}
+
diff -urNp linux-781/drivers/oprofile/buffer_sync.h linux-790/drivers/oprofile/buffer_sync.h
--- linux-781/drivers/oprofile/buffer_sync.h
+++ linux-790/drivers/oprofile/buffer_sync.h
@@ -0,0 +1,19 @@
+/**
+ * @file buffer_sync.h
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon <levon@movementarian.org>
+ */
+
+#ifndef OPROFILE_BUFFER_SYNC_H
+#define OPROFILE_BUFFER_SYNC_H
+ 
+/* add the necessary profiling hooks */
+int sync_start(void);
+
+/* remove the hooks */
+void sync_stop(void);
+ 
+#endif /* OPROFILE_BUFFER_SYNC_H */
diff -urNp linux-781/drivers/oprofile/cpu_buffer.c linux-790/drivers/oprofile/cpu_buffer.c
--- linux-781/drivers/oprofile/cpu_buffer.c
+++ linux-790/drivers/oprofile/cpu_buffer.c
@@ -0,0 +1,182 @@
+/**
+ * @file cpu_buffer.c
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon <levon@movementarian.org>
+ *
+ * Each CPU has a local buffer that stores PC value/event
+ * pairs. We also log context switches when we notice them.
+ * Eventually each CPU's buffer is processed into the global
+ * event buffer by sync_cpu_buffers().
+ *
+ * We use a local buffer for two reasons: an NMI or similar
+ * interrupt cannot synchronise, and high sampling rates
+ * would lead to catastrophic global synchronisation if
+ * a global buffer was used.
+ */
+
+#include <linux/sched.h>
+#include <linux/vmalloc.h>
+#include <linux/errno.h>
+ 
+#include "cpu_buffer.h"
+#include "oprof.h"
+
+struct oprofile_cpu_buffer cpu_buffer[NR_CPUS] __cacheline_aligned;
+
+static void __free_cpu_buffers(int num)
+{
+	int i;
+ 
+	for (i=0; i < num; ++i) {
+		struct oprofile_cpu_buffer * b = &cpu_buffer[i];
+ 
+		if (!cpu_possible(i)) 
+			continue;
+ 
+		vfree(b->buffer);
+	}
+}
+ 
+ 
+int alloc_cpu_buffers(void)
+{
+	int i;
+ 
+	unsigned long buffer_size = fs_cpu_buffer_size;
+ 
+	for (i=0; i < NR_CPUS; ++i) {
+		struct oprofile_cpu_buffer * b = &cpu_buffer[i];
+ 
+		if (!cpu_possible(i)) 
+			continue;
+ 
+		b->buffer = vmalloc(sizeof(struct op_sample) * buffer_size);
+		if (!b->buffer)
+			goto fail;
+ 
+		b->last_task = 0;
+		b->last_is_kernel = -1;
+		b->buffer_size = buffer_size;
+		b->tail_pos = 0;
+		b->head_pos = 0;
+		b->sample_received = 0;
+		b->sample_lost_overflow = 0;
+		b->sample_lost_task_exit = 0;
+	}
+	return 0;
+fail:
+	__free_cpu_buffers(i);
+	return -ENOMEM;
+}
+ 
+
+void free_cpu_buffers(void)
+{
+	__free_cpu_buffers(NR_CPUS);
+}
+
+
+/* compute number of available slots in cpu_buffer queue */
+static unsigned long nr_available_slots(struct oprofile_cpu_buffer const * b)
+{
+	unsigned long head = b->head_pos;
+	unsigned long tail = b->tail_pos;
+
+	if (tail > head)
+		return tail - head;
+
+	return tail + (b->buffer_size - head);
+}
+
+
+static void increment_head(struct oprofile_cpu_buffer * b)
+{
+	unsigned long new_head = b->head_pos + 1;
+
+	/* Ensure anything written to the slot before we
+	 * increment is visible */
+	wmb();
+
+	if (new_head < (b->buffer_size))
+		b->head_pos = new_head;
+	else
+		b->head_pos = 0;
+}
+
+
+/* This must be safe from any context. It's safe writing here
+ * because of the head/tail separation of the writer and reader
+ * of the CPU buffer.
+ *
+ * is_kernel is needed because on some architectures you cannot
+ * tell if you are in kernel or user space simply by looking at
+ * eip. We tag this in the buffer by generating kernel enter/exit
+ * events whenever is_kernel changes
+ */
+void oprofile_add_sample(unsigned long eip, unsigned int is_kernel, 
+	unsigned long event, int cpu)
+{
+	struct oprofile_cpu_buffer * cpu_buf = &cpu_buffer[cpu];
+	struct task_struct * task;
+
+	is_kernel = !!is_kernel;
+
+	cpu_buf->sample_received++;
+ 
+
+	if (nr_available_slots(cpu_buf) < 3) {
+		cpu_buf->sample_lost_overflow++;
+		return;
+	}
+
+	task = current;
+
+	/* notice a switch from user->kernel or vice versa */
+	if (cpu_buf->last_is_kernel != is_kernel) {
+		cpu_buf->last_is_kernel = is_kernel;
+		cpu_buf->buffer[cpu_buf->head_pos].eip = ~0UL;
+		cpu_buf->buffer[cpu_buf->head_pos].event = is_kernel;
+		increment_head(cpu_buf);
+	}
+
+	/* notice a task switch */
+	if (cpu_buf->last_task != task) {
+		cpu_buf->last_task = task;
+		if (!(task->flags & PF_EXITING)) {
+			cpu_buf->buffer[cpu_buf->head_pos].eip = ~0UL;
+			cpu_buf->buffer[cpu_buf->head_pos].event = (unsigned long)task;
+			increment_head(cpu_buf);
+		}
+	}
+ 
+	/* If the task is exiting it's not safe to take a sample
+	 * as the task_struct is about to be freed. We can't just
+	 * notify at release_task() time because of CLONE_DETACHED
+	 * tasks that release_task() themselves.
+	 */
+	if (task->flags & PF_EXITING) {
+		cpu_buf->sample_lost_task_exit++;
+		return;
+	}
+ 
+	cpu_buf->buffer[cpu_buf->head_pos].eip = eip;
+	cpu_buf->buffer[cpu_buf->head_pos].event = event;
+	increment_head(cpu_buf);
+}
+
+
+/* resets the cpu buffer to a sane state - should be called with 
+ * cpu_buf->int_lock held
+ */
+void cpu_buffer_reset(struct oprofile_cpu_buffer *cpu_buf)
+{
+	/* reset these to invalid values; the next sample
+	 * collected will populate the buffer with proper
+	 * values to initialize the buffer
+	 */
+	cpu_buf->last_is_kernel = -1;
+	cpu_buf->last_task = 0;
+}
diff -urNp linux-781/drivers/oprofile/cpu_buffer.h linux-790/drivers/oprofile/cpu_buffer.h
--- linux-781/drivers/oprofile/cpu_buffer.h
+++ linux-790/drivers/oprofile/cpu_buffer.h
@@ -0,0 +1,48 @@
+/**
+ * @file cpu_buffer.h
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon <levon@movementarian.org>
+ */
+
+#ifndef OPROFILE_CPU_BUFFER_H
+#define OPROFILE_CPU_BUFFER_H
+
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/cache.h>
+ 
+struct task_struct;
+ 
+/* allocate a sample buffer for each CPU */
+int alloc_cpu_buffers(void);
+
+void free_cpu_buffers(void);
+
+/* CPU buffer is composed of such entries (which are
+ * also used for context switch notes)
+ */
+struct op_sample {
+	unsigned long eip;
+	unsigned long event;
+};
+ 
+struct oprofile_cpu_buffer {
+	volatile unsigned long head_pos;
+	volatile unsigned long tail_pos;
+	unsigned long buffer_size;
+	struct task_struct * last_task;
+	int last_is_kernel;
+	struct op_sample * buffer;
+	unsigned long sample_received;
+	unsigned long sample_lost_overflow;
+	unsigned long sample_lost_task_exit;
+} ____cacheline_aligned;
+
+extern struct oprofile_cpu_buffer cpu_buffer[];
+
+void cpu_buffer_reset(struct oprofile_cpu_buffer *cpu_buf);
+
+#endif /* OPROFILE_CPU_BUFFER_H */
diff -urNp linux-781/drivers/oprofile/event_buffer.c linux-790/drivers/oprofile/event_buffer.c
--- linux-781/drivers/oprofile/event_buffer.c
+++ linux-790/drivers/oprofile/event_buffer.c
@@ -0,0 +1,244 @@
+/**
+ * @file event_buffer.c
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon <levon@movementarian.org>
+ *
+ * This is the global event buffer that the user-space
+ * daemon reads from. The event buffer is an untyped array
+ * of unsigned longs. Entries are prefixed by the
+ * escape value ESCAPE_CODE followed by an identifying code.
+ */
+
+#include <linux/vmalloc.h>
+#include <linux/oprofile.h>
+#include <linux/sched.h>
+#include <linux/dcookies.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+ 
+#include "oprof.h"
+#include "event_buffer.h"
+#include "oprofile_stats.h"
+
+DECLARE_MUTEX(buffer_sem);
+ 
+static unsigned long buffer_opened;
+static DECLARE_WAIT_QUEUE_HEAD(buffer_wait);
+static unsigned long * event_buffer;
+static unsigned long buffer_size;
+static unsigned long buffer_watershed;
+static size_t buffer_pos;
+/* atomic_t because wait_event checks it outside of buffer_sem */
+static atomic_t buffer_ready = ATOMIC_INIT(0);
+
+/* Add an entry to the event buffer. When we
+ * get near to the end we wake up the process
+ * sleeping on the read() of the file.
+ */
+void add_event_entry(unsigned long value)
+{
+	if (buffer_pos == buffer_size) {
+		atomic_inc(&oprofile_stats.event_lost_overflow);
+		return;
+	}
+
+	if (event_buffer) {
+		event_buffer[buffer_pos] = value;
+		if (++buffer_pos == buffer_size - buffer_watershed) {
+			atomic_set(&buffer_ready, 1);
+			wake_up(&buffer_wait);
+		}
+	}
+}
+
+
+/* Wake up the waiting process if any. This happens
+ * on "echo 0 >/dev/oprofile/enable" so the daemon
+ * processes the data remaining in the event buffer.
+ */
+void wake_up_buffer_waiter(void)
+{
+	down(&buffer_sem);
+	atomic_set(&buffer_ready, 1);
+	wake_up(&buffer_wait);
+	up(&buffer_sem);
+}
+
+ 
+int alloc_event_buffer(void)
+{
+	int err = -ENOMEM;
+	unsigned long * tmp;
+
+	/*
+	 * Do some sanity checking
+	 */
+	if (fs_buffer_watershed >= fs_buffer_size) {
+		return -EINVAL;
+	} 
+
+	/*
+	 * Check to see if event_buffer has
+	 * already been allocated.
+	 */
+	if (event_buffer != 0)
+		return 0;
+
+	tmp = vmalloc(sizeof(unsigned long) * fs_buffer_size);
+	if (!tmp)
+		goto out; 
+
+	down(&buffer_sem);
+	if (event_buffer == 0) {
+		buffer_size = fs_buffer_size;
+		buffer_watershed = fs_buffer_watershed;
+		event_buffer = tmp;
+		tmp = 0;
+	}
+	up(&buffer_sem);
+
+	if (tmp != 0)
+		vfree(tmp);
+
+	err = 0;
+out:
+	return err;
+}
+
+
+void free_event_buffer(void)
+{
+	unsigned long * tmp = 0;
+	
+	down(&buffer_sem);
+	tmp = event_buffer;
+	event_buffer = 0;
+	up(&buffer_sem);
+
+	if(tmp)
+		vfree(tmp);
+}
+
+ 
+int event_buffer_open(struct inode * inode, struct file * file)
+{
+	int err = -EPERM;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	if (test_and_set_bit(0, &buffer_opened))
+		return -EBUSY;
+
+	/* Register as a user of dcookies
+	 * to ensure they persist for the lifetime of
+	 * the open event file
+	 */
+	err = -EINVAL;
+	file->private_data = dcookie_register();
+	if (!file->private_data)
+		goto out;
+		 
+	if ((err = oprofile_setup()))
+		goto fail;
+
+	/* NB: the actual start happens from userspace
+	 * echo 1 >/dev/oprofile/enable
+	 */
+ 
+	return 0;
+
+fail:
+	dcookie_unregister(file->private_data);
+out:
+	clear_bit(0, &buffer_opened);
+	return err;
+}
+
+
+int event_buffer_release(struct inode * inode, struct file * file)
+{
+	oprofile_stop();
+	oprofile_shutdown();
+	dcookie_unregister(file->private_data);
+	buffer_pos = 0;
+	atomic_set(&buffer_ready, 0);
+	clear_bit(0, &buffer_opened);
+	return 0;
+}
+
+
+ssize_t event_buffer_read(struct file * file, char * buf, size_t count, loff_t * offset)
+{
+	int retval = -EINVAL;
+	size_t const max = buffer_size * sizeof(unsigned long);
+	unsigned long * tmp = 0;
+
+	/* handling partial reads is more trouble than it's worth */
+	if (count != max || *offset)
+		return -EINVAL;
+
+	if (file->f_flags & O_NDELAY) {
+		if (down_trylock(&buffer_sem)) {
+			/* Do some quick sanity checking */
+			if (event_buffer == 0)
+				goto out;
+			retval = 0;
+			if (atomic_read(&buffer_ready))
+				goto do_user_copy;
+			goto out;
+		}
+		return 0;
+	}
+
+tryagain:
+	/* wait for the event buffer to fill up with some data */
+	wait_event_interruptible(buffer_wait, atomic_read(&buffer_ready));
+	if (signal_pending(current))
+		return -EINTR;
+
+	down(&buffer_sem);
+
+	if (atomic_read(&buffer_ready))
+		atomic_set(&buffer_ready, 0);
+	else {
+		up(&buffer_sem);
+		goto tryagain;
+	}
+
+do_user_copy:
+
+	/* Do some quick sanity checking */
+	if (event_buffer == 0)
+		goto out;
+
+	count = buffer_pos * sizeof(unsigned long);
+
+	/* XXX: If we sleep here, the O_NDELAY semantics breaks.. */
+	tmp = vmalloc(count);
+	if (tmp == 0) {
+		retval = -ENOMEM;
+		goto out;
+	}
+	memcpy(tmp, event_buffer, count);
+	retval = count;
+	buffer_pos = 0;
+
+out:
+	up(&buffer_sem);
+	if (tmp) {
+		if (copy_to_user(buf, tmp, count))
+			retval = -EFAULT;
+		vfree(tmp);
+	}
+	return retval;
+}
+ 
+struct file_operations event_buffer_fops = {
+	.open		= event_buffer_open,
+	.release	= event_buffer_release,
+	.read		= event_buffer_read,
+};
diff -urNp linux-781/drivers/oprofile/event_buffer.h linux-790/drivers/oprofile/event_buffer.h
--- linux-781/drivers/oprofile/event_buffer.h
+++ linux-790/drivers/oprofile/event_buffer.h
@@ -0,0 +1,45 @@
+/**
+ * @file event_buffer.h
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon <levon@movementarian.org>
+ */
+
+#ifndef EVENT_BUFFER_H
+#define EVENT_BUFFER_H
+
+#include <linux/types.h> 
+#include <linux/sem.h>
+ 
+int alloc_event_buffer(void);
+
+void free_event_buffer(void);
+ 
+/* wake up the process sleeping on the event file */
+void wake_up_buffer_waiter(void);
+ 
+/* Each escaped entry is prefixed by ESCAPE_CODE
+ * then one of the following codes, then the
+ * relevant data.
+ */
+#define ESCAPE_CODE			~0UL
+#define CTX_SWITCH_CODE 		1
+#define CPU_SWITCH_CODE 		2
+#define COOKIE_SWITCH_CODE 		3
+#define KERNEL_ENTER_SWITCH_CODE	4
+#define KERNEL_EXIT_SWITCH_CODE		5
+#define MODULE_LOADED_CODE		6
+ 
+/* add data to the event buffer */
+void add_event_entry(unsigned long data);
+ 
+extern struct file_operations event_buffer_fops;
+ 
+/* mutex between sync_cpu_buffers() and the
+ * file reading code.
+ */
+extern struct semaphore buffer_sem;
+ 
+#endif /* EVENT_BUFFER_H */
diff -urNp linux-781/drivers/oprofile/oprof.c linux-790/drivers/oprofile/oprof.c
--- linux-781/drivers/oprofile/oprof.c
+++ linux-790/drivers/oprofile/oprof.c
@@ -0,0 +1,160 @@
+/**
+ * @file oprof.c
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon <levon@movementarian.org>
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/oprofile.h>
+#include <asm/semaphore.h>
+
+#include "oprof.h"
+#include "event_buffer.h"
+#include "cpu_buffer.h"
+#include "buffer_sync.h"
+#include "oprofile_stats.h"
+ 
+struct oprofile_operations * oprofile_ops;
+unsigned long oprofile_started;
+static unsigned long is_setup;
+static DECLARE_MUTEX(start_sem);
+
+int oprofile_setup(void)
+{
+	int err;
+ 
+	if ((err = alloc_cpu_buffers()))
+		goto out;
+
+	if ((err = alloc_event_buffer()))
+		goto out1;
+ 
+	if (oprofile_ops->setup && (err = oprofile_ops->setup()))
+		goto out2;
+ 
+	/* Note even though this starts part of the
+	 * profiling overhead, it's necessary to prevent
+	 * us missing task deaths and eventually oopsing
+	 * when trying to process the event buffer.
+	 */
+	if ((err = sync_start()))
+		goto out3;
+
+	down(&start_sem);
+	is_setup = 1;
+	up(&start_sem);
+	return 0;
+ 
+out3:
+	if (oprofile_ops->shutdown)
+		oprofile_ops->shutdown();
+out2:
+	free_event_buffer();
+out1:
+	free_cpu_buffers();
+out:
+	return err;
+}
+
+
+/* Actually start profiling (echo 1>/dev/oprofile/enable) */
+int oprofile_start(void)
+{
+	int err = -EINVAL;
+ 
+	down(&start_sem);
+ 
+	if (!is_setup)
+		goto out;
+
+	err = 0; 
+ 
+	if (oprofile_started)
+		goto out;
+ 
+	oprofile_reset_stats();
+
+	if ((err = oprofile_ops->start()))
+		goto out;
+
+	oprofile_started = 1;
+out:
+	up(&start_sem); 
+	return err;
+}
+
+ 
+/* echo 0>/dev/oprofile/enable */
+void oprofile_stop(void)
+{
+	down(&start_sem);
+	if (!oprofile_started)
+		goto out;
+	oprofile_ops->stop();
+	oprofile_started = 0;
+	/* wake up the daemon to read what remains */
+	wake_up_buffer_waiter();
+out:
+	up(&start_sem);
+}
+
+
+void oprofile_shutdown(void)
+{
+	sync_stop();
+	if (oprofile_ops->shutdown)
+		oprofile_ops->shutdown(); 
+	/* down() is also necessary to synchronise all pending events
+	 * before freeing */
+	down(&start_sem);
+	is_setup = 0;
+	up(&start_sem);
+	free_event_buffer();
+	free_cpu_buffers();
+}
+
+ 
+static int __init oprofile_init(void)
+{
+	int err;
+
+	/* Architecture must fill in the interrupt ops and the
+	 * logical CPU type.
+	 */
+	err = oprofile_arch_init(&oprofile_ops);
+	if (err)
+		goto out;
+
+	if (!oprofile_ops->cpu_type) {
+		printk(KERN_ERR "oprofile: cpu_type not set !\n");
+		err = -EFAULT;
+		goto out;
+	}
+
+	err = oprofilefs_register();
+	if (err)
+		goto out;
+ 
+out:
+	return err;
+}
+
+
+static void __exit oprofile_exit(void)
+{
+	oprofilefs_unregister();
+}
+
+ 
+module_init(oprofile_init);
+module_exit(oprofile_exit);
+ 
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("John Levon <levon@movementarian.org>");
+MODULE_DESCRIPTION("OProfile system profiler");
diff -urNp linux-781/drivers/oprofile/oprof.h linux-790/drivers/oprofile/oprof.h
--- linux-781/drivers/oprofile/oprof.h
+++ linux-790/drivers/oprofile/oprof.h
@@ -0,0 +1,35 @@
+/**
+ * @file oprof.h
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon <levon@movementarian.org>
+ */
+
+#ifndef OPROF_H
+#define OPROF_H
+
+int oprofile_setup(void);
+void oprofile_shutdown(void); 
+
+int oprofilefs_register(void);
+void oprofilefs_unregister(void);
+
+int oprofile_start(void);
+void oprofile_stop(void);
+
+struct oprofile_operations;
+ 
+extern unsigned long fs_buffer_size;
+extern unsigned long fs_cpu_buffer_size;
+extern unsigned long fs_buffer_watershed;
+extern struct oprofile_operations * oprofile_ops;
+extern unsigned long oprofile_started;
+ 
+struct super_block;
+struct dentry;
+
+void oprofile_create_files(struct super_block * sb, struct dentry * root);
+ 
+#endif /* OPROF_H */
diff -urNp linux-781/drivers/oprofile/oprofile_files.c linux-790/drivers/oprofile/oprofile_files.c
--- linux-781/drivers/oprofile/oprofile_files.c
+++ linux-790/drivers/oprofile/oprofile_files.c
@@ -0,0 +1,91 @@
+/**
+ * @file oprofile_files.c
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon <levon@movementarian.org>
+ */
+
+#include <linux/fs.h>
+#include <linux/oprofile.h>
+
+#include "event_buffer.h"
+#include "oprofile_stats.h"
+#include "oprof.h"
+ 
+unsigned long fs_buffer_size = 131072;
+unsigned long fs_cpu_buffer_size = 8192;
+unsigned long fs_buffer_watershed = 32768; /* FIXME: tune */
+
+ 
+static ssize_t cpu_type_read(struct file * file, char * buf, size_t count, loff_t * offset)
+{
+	return oprofilefs_str_to_user(oprofile_ops->cpu_type, buf, count, offset);
+}
+ 
+ 
+static struct file_operations cpu_type_fops = {
+	.read		= cpu_type_read,
+};
+ 
+ 
+static ssize_t enable_read(struct file * file, char * buf, size_t count, loff_t * offset)
+{
+	return oprofilefs_ulong_to_user(&oprofile_started, buf, count, offset);
+}
+
+
+static ssize_t enable_write(struct file *file, char const * buf, size_t count, loff_t * offset)
+{
+	unsigned long val;
+	int retval;
+
+	if (*offset)
+		return -EINVAL;
+
+	retval = oprofilefs_ulong_from_user(&val, buf, count);
+	if (retval)
+		return retval;
+ 
+	if (val)
+		retval = oprofile_start();
+	else
+		oprofile_stop();
+
+	if (retval)
+		return retval;
+	return count;
+}
+
+ 
+static struct file_operations enable_fops = {
+	.read		= enable_read,
+	.write		= enable_write,
+};
+
+
+static ssize_t dump_write(struct file *file, char const * buf, size_t count, loff_t * offset)
+{
+	wake_up_buffer_waiter();
+	return count;
+}
+
+
+static struct file_operations dump_fops = {
+	.write		= dump_write,
+};
+ 
+void oprofile_create_files(struct super_block * sb, struct dentry * root)
+{
+	oprofilefs_create_file(sb, root, "enable", &enable_fops);
+	oprofilefs_create_file(sb, root, "dump", &dump_fops);
+	oprofilefs_create_file(sb, root, "buffer", &event_buffer_fops);
+	oprofilefs_create_ulong(sb, root, "buffer_size", &fs_buffer_size);
+	oprofilefs_create_ulong(sb, root, "buffer_watershed", &fs_buffer_watershed);
+	oprofilefs_create_ulong(sb, root, "cpu_buffer_size", &fs_cpu_buffer_size);
+	oprofilefs_create_file(sb, root, "cpu_type", &cpu_type_fops); 
+	oprofile_create_stats_files(sb, root);
+	if (oprofile_ops->create_files)
+		oprofile_ops->create_files(sb, root);
+}
diff -urNp linux-781/drivers/oprofile/oprofile_stats.c linux-790/drivers/oprofile/oprofile_stats.c
--- linux-781/drivers/oprofile/oprofile_stats.c
+++ linux-790/drivers/oprofile/oprofile_stats.c
@@ -0,0 +1,75 @@
+/**
+ * @file oprofile_stats.c
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon
+ */
+
+#include <linux/oprofile.h>
+#include <linux/smp.h>
+#include <linux/threads.h>
+ 
+#include "oprofile_stats.h"
+#include "cpu_buffer.h"
+ 
+struct oprofile_stat_struct oprofile_stats;
+ 
+void oprofile_reset_stats(void)
+{
+	struct oprofile_cpu_buffer * cpu_buf; 
+	int i;
+ 
+	for (i = 0; i < NR_CPUS; ++i) {
+		if (!cpu_possible(i))
+			continue;
+
+		cpu_buf = &cpu_buffer[i]; 
+		cpu_buf->sample_received = 0;
+		cpu_buf->sample_lost_overflow = 0;
+		cpu_buf->sample_lost_task_exit = 0;
+	}
+ 
+	atomic_set(&oprofile_stats.sample_lost_mmap_sem, 0);
+	atomic_set(&oprofile_stats.event_lost_overflow, 0);
+}
+
+
+void oprofile_create_stats_files(struct super_block * sb, struct dentry * root)
+{
+	struct oprofile_cpu_buffer * cpu_buf;
+	struct dentry * cpudir;
+	struct dentry * dir;
+	char buf[10];
+	int i;
+
+	dir = oprofilefs_mkdir(sb, root, "stats");
+	if (!dir)
+		return;
+
+	for (i = 0; i < NR_CPUS; ++i) {
+		if (!cpu_possible(i))
+			continue;
+
+		cpu_buf = &cpu_buffer[i]; 
+		snprintf(buf, 6, "cpu%d", i);
+		cpudir = oprofilefs_mkdir(sb, dir, buf);
+ 
+		/* Strictly speaking access to these ulongs is racy,
+		 * but we can't simply lock them, and they are
+		 * informational only.
+		 */
+		oprofilefs_create_ro_ulong(sb, cpudir, "sample_received",
+			&cpu_buf->sample_received);
+		oprofilefs_create_ro_ulong(sb, cpudir, "sample_lost_overflow",
+			&cpu_buf->sample_lost_overflow);
+		oprofilefs_create_ro_ulong(sb, cpudir, "sample_lost_task_exit",
+			&cpu_buf->sample_lost_task_exit);
+	}
+ 
+	oprofilefs_create_ro_atomic(sb, dir, "sample_lost_mmap_sem",
+		&oprofile_stats.sample_lost_mmap_sem);
+	oprofilefs_create_ro_atomic(sb, dir, "event_lost_overflow",
+		&oprofile_stats.event_lost_overflow);
+}
diff -urNp linux-781/drivers/oprofile/oprofile_stats.h linux-790/drivers/oprofile/oprofile_stats.h
--- linux-781/drivers/oprofile/oprofile_stats.h
+++ linux-790/drivers/oprofile/oprofile_stats.h
@@ -0,0 +1,31 @@
+/**
+ * @file oprofile_stats.h
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon
+ */
+
+#ifndef OPROFILE_STATS_H
+#define OPROFILE_STATS_H
+
+#include <asm/atomic.h>
+ 
+struct oprofile_stat_struct {
+	atomic_t sample_lost_mmap_sem;
+	atomic_t event_lost_overflow;
+};
+
+extern struct oprofile_stat_struct oprofile_stats;
+ 
+/* reset all stats to zero */
+void oprofile_reset_stats(void);
+ 
+struct super_block;
+struct dentry;
+ 
+/* create the stats/ dir */
+void oprofile_create_stats_files(struct super_block * sb, struct dentry * root);
+
+#endif /* OPROFILE_STATS_H */
diff -urNp linux-781/drivers/oprofile/oprofilefs.c linux-790/drivers/oprofile/oprofilefs.c
--- linux-781/drivers/oprofile/oprofilefs.c
+++ linux-790/drivers/oprofile/oprofilefs.c
@@ -0,0 +1,430 @@
+/**
+ * @file oprofilefs.c
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon
+ *
+ * A simple filesystem for configuration and
+ * access of oprofile.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/oprofile.h>
+#include <linux/fs.h>
+#include <linux/pagemap.h>
+#include <asm/uaccess.h>
+
+#include "oprof.h"
+
+#define OPROFILEFS_MAGIC 0x6f70726f
+
+static struct inode * oprofilefs_get_inode(struct super_block * sb, int mode)
+{
+	struct inode * inode = new_inode(sb);
+
+	if (inode) {
+		inode->i_mode = mode;
+		inode->i_uid = 0;
+		inode->i_gid = 0;
+		inode->i_blksize = PAGE_CACHE_SIZE;
+		inode->i_blocks = 0;
+		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+	}
+	return inode;
+}
+
+/* copied from 2.5.46 fs/libfs.c:simple_statfs() */
+static int oprofilefs_statfs(struct super_block *sb, struct statfs *buf)
+{
+	buf->f_type = sb->s_magic;
+	buf->f_bsize = PAGE_CACHE_SIZE;
+	buf->f_namelen = NAME_MAX;
+	return 0;
+}
+
+static struct super_operations s_ops = {
+	.statfs		= oprofilefs_statfs,
+/* FIXME should I have something for .delete_inode ??? */
+/*	.drop_inode 	= generic_delete_inode, */
+};
+
+
+ssize_t oprofilefs_str_to_user(char const * str, char * buf, size_t count, loff_t * offset)
+{
+	size_t len = strlen(str);
+
+	if (!count)
+		return 0;
+
+	if (*offset > len)
+		return 0;
+
+	if (count > len - *offset)
+		count = len - *offset;
+
+	if (copy_to_user(buf, str + *offset, count))
+		return -EFAULT;
+
+	*offset += count;
+
+	return count;
+}
+
+
+#define TMPBUFSIZE 50
+
+ssize_t oprofilefs_ulong_to_user(unsigned long * val, char * buf, size_t count, loff_t * offset)
+{
+	char tmpbuf[TMPBUFSIZE];
+	size_t maxlen;
+
+	if (!count)
+		return 0;
+
+	maxlen = snprintf(tmpbuf, TMPBUFSIZE, "%lu\n", *val);
+
+	if (*offset > maxlen)
+		return 0;
+
+	if (count > maxlen - *offset)
+		count = maxlen - *offset;
+
+	if (copy_to_user(buf, tmpbuf + *offset, count))
+		return -EFAULT;
+
+	*offset += count;
+
+	return count;
+}
+
+
+int oprofilefs_ulong_from_user(unsigned long * val, char const * buf, size_t count)
+{
+	char tmpbuf[TMPBUFSIZE];
+
+	if (!count)
+		return 0;
+
+	if (count > TMPBUFSIZE - 1)
+		return -EINVAL;
+
+	memset(tmpbuf, 0x0, TMPBUFSIZE);
+
+	if (copy_from_user(tmpbuf, buf, count))
+		return -EFAULT;
+
+	*val = simple_strtoul(tmpbuf, NULL, 0);
+
+	return 0;
+}
+
+
+static ssize_t ulong_read_file(struct file * file, char * buf, size_t count, loff_t * offset)
+{
+	return oprofilefs_ulong_to_user(file->private_data, buf, count, offset);
+}
+
+
+static ssize_t ulong_write_file(struct file * file, char const * buf, size_t count, loff_t * offset)
+{
+	unsigned long * value = file->private_data;
+	int retval;
+
+	if (*offset)
+		return -EINVAL;
+
+	retval = oprofilefs_ulong_from_user(value, buf, count);
+
+	if (retval)
+		return retval;
+	return count;
+}
+
+
+static int default_open(struct inode * inode, struct file * filp)
+{
+	if (inode->u.generic_ip)
+		filp->private_data = inode->u.generic_ip;
+	return 0;
+}
+
+
+static struct file_operations ulong_fops = {
+	.read		= ulong_read_file,
+	.write		= ulong_write_file,
+	.open		= default_open,
+};
+
+
+static struct file_operations ulong_ro_fops = {
+	.read		= ulong_read_file,
+	.open		= default_open,
+};
+
+
+static struct dentry * __oprofilefs_create_file(struct super_block * sb,
+	struct dentry * root, char const * name, struct file_operations * fops)
+{
+	struct dentry * dentry;
+	struct inode * inode;
+	struct qstr qname;
+	qname.name = name;
+	qname.len = strlen(name);
+	qname.hash = full_name_hash(qname.name, qname.len);
+	dentry = d_alloc(root, &qname);
+	if (!dentry)
+		return 0;
+	inode = oprofilefs_get_inode(sb, S_IFREG | 0644);
+	if (!inode) {
+		dput(dentry);
+		return 0;
+	}
+	inode->i_fop = fops;
+	d_add(dentry, inode);
+	return dentry;
+}
+
+
+int oprofilefs_create_ulong(struct super_block * sb, struct dentry * root,
+	char const * name, unsigned long * val)
+{
+	struct dentry * d = __oprofilefs_create_file(sb, root, name, &ulong_fops);
+	if (!d)
+		return -EFAULT;
+
+	d->d_inode->u.generic_ip = val;
+	return 0;
+}
+
+
+int oprofilefs_create_ro_ulong(struct super_block * sb, struct dentry * root,
+	char const * name, unsigned long * val)
+{
+	struct dentry * d = __oprofilefs_create_file(sb, root, name, &ulong_ro_fops);
+	if (!d)
+		return -EFAULT;
+
+	d->d_inode->u.generic_ip = val;
+	return 0;
+}
+
+
+static ssize_t atomic_read_file(struct file * file, char * buf, size_t count, loff_t * offset)
+{
+	atomic_t * aval = file->private_data;
+	unsigned long val = atomic_read(aval);
+	return oprofilefs_ulong_to_user(&val, buf, count, offset);
+}
+ 
+
+static struct file_operations atomic_ro_fops = {
+	.read		= atomic_read_file,
+	.open		= default_open,
+};
+ 
+
+int oprofilefs_create_ro_atomic(struct super_block * sb, struct dentry * root,
+	char const * name, atomic_t * val)
+{
+	struct dentry * d = __oprofilefs_create_file(sb, root, name, &atomic_ro_fops);
+	if (!d)
+		return -EFAULT;
+
+	d->d_inode->u.generic_ip = val;
+	return 0;
+}
+
+ 
+int oprofilefs_create_file(struct super_block * sb, struct dentry * root,
+	char const * name, struct file_operations * fops)
+{
+	if (!__oprofilefs_create_file(sb, root, name, fops))
+		return -EFAULT;
+	return 0;
+}
+
+/* copied from linux 2.5.46 fs/libfs.c:simple_lookup() */
+static struct dentry *oprofilefs_lookup(struct inode *dir,
+					struct dentry *dentry)
+{
+	d_add(dentry, NULL);
+	return NULL;
+}
+
+
+/* copied from linux 2.5.46 fs/libfs.c:generic_read_dir() */
+static ssize_t oprofilefs_read_dir(struct file *filp, char *buf,
+				   size_t siz, loff_t *ppos)
+{
+	return -EISDIR;
+}
+
+/* copied from linux 2.5.46 fs/libfs.c:dt_type() */
+/* Relationship between i_mode and the DT_xxx types */
+static inline unsigned char dt_type(struct inode *inode)
+{
+	return (inode->i_mode >> 12) & 15;
+}
+
+/* adapted from linux 2.5.46 fs/libfs.c:dcache_readdir() */
+/*
+ * Directory is locked and all positive dentries in it are safe, since
+ * for ramfs-type trees they can't go away without unlink() or rmdir(),
+ * both impossible due to the lock on directory.
+ */
+
+static int oprofilefs_readdir(struct file * filp, void * dirent,
+			      filldir_t filldir)
+{
+	struct dentry *dentry = filp->f_dentry;
+	struct dentry *cursor = filp->private_data;
+	struct list_head *p, *q = &cursor->d_child;
+	ino_t ino;
+	int i = filp->f_pos;
+
+	switch (i) {
+		case 0:
+			ino = dentry->d_inode->i_ino;
+			if (filldir(dirent, ".", 1, i, ino, DT_DIR) < 0)
+				break;
+			filp->f_pos++;
+			i++;
+			/* fallthrough */
+		case 1:
+			if (filldir(dirent, "..", 2, i, 
+				    dentry->d_parent->d_inode->i_ino,
+				    DT_DIR) < 0)
+				break;
+			filp->f_pos++;
+			i++;
+			/* fallthrough */
+		default:
+			spin_lock(&dcache_lock);
+			if (filp->f_pos == 2) {
+				list_del(q);
+				list_add(q, &dentry->d_subdirs);
+			}
+			for (p=q->next; p != &dentry->d_subdirs; p=p->next) {
+				struct dentry *next;
+				next = list_entry(p, struct dentry, d_child);
+				if (list_empty(&next->d_hash) || !next->d_inode)
+					continue;
+
+				spin_unlock(&dcache_lock);
+				if (filldir(dirent, next->d_name.name, next->d_name.len, filp->f_pos, next->d_inode->i_ino, dt_type(next->d_inode)) < 0)
+					return 0;
+				spin_lock(&dcache_lock);
+				/* next is still alive */
+				list_del(q);
+				list_add(q, p);
+				p = q;
+				filp->f_pos++;
+			}
+			spin_unlock(&dcache_lock);
+	}
+	return 0;
+}
+
+/* copied from linux 2.5.46 fs/libfs.c:simple_dir_operations */
+struct file_operations oprofilefs_dir_operations = {
+	.open		= dcache_dir_open,
+	.release	= dcache_dir_close,
+	.llseek		= dcache_dir_lseek,
+	.read		= oprofilefs_read_dir,
+	.readdir	= oprofilefs_readdir,
+};
+
+/* copied from linux 2.5.46 fs/libfs.c:simple_dir_inode_operations */
+struct inode_operations oprofilefs_dir_inode_operations = {
+	.lookup		= oprofilefs_lookup,
+};
+
+
+struct dentry * oprofilefs_mkdir(struct super_block * sb,
+	struct dentry * root, char const * name)
+{
+	struct dentry * dentry;
+	struct inode * inode;
+	struct qstr qname;
+	qname.name = name;
+	qname.len = strlen(name);
+	qname.hash = full_name_hash(qname.name, qname.len);
+	dentry = d_alloc(root, &qname);
+	if (!dentry)
+		return 0;
+	inode = oprofilefs_get_inode(sb, S_IFDIR | 0755);
+	if (!inode) {
+		dput(dentry);
+		return 0;
+	}
+	inode->i_op = &oprofilefs_dir_inode_operations;
+	inode->i_fop = &oprofilefs_dir_operations;
+	d_add(dentry, inode);
+	return dentry;
+}
+
+
+static struct super_block *oprofilefs_fill_super(struct super_block * sb,
+						 void * data,
+						 int silent)
+{
+	struct inode * root_inode;
+	struct dentry * root_dentry;
+
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	sb->s_magic = OPROFILEFS_MAGIC;
+	sb->s_op = &s_ops;
+
+	root_inode = oprofilefs_get_inode(sb, S_IFDIR | 0755);
+	if (!root_inode)
+		return NULL;
+	root_inode->i_op = &oprofilefs_dir_inode_operations;
+	root_inode->i_fop = &oprofilefs_dir_operations;
+	root_dentry = d_alloc_root(root_inode);
+	if (!root_dentry) {
+		iput(root_inode);
+		return NULL;
+	}
+
+	sb->s_root = root_dentry;
+
+	oprofile_create_files(sb, root_dentry);
+
+	// FIXME: verify kill_litter_super removes our dentries
+	return sb;
+}
+
+
+#if 0
+static struct super_block * oprofilefs_get_sb(struct file_system_type * fs_type,
+	int flags, char * dev_name, void * data)
+{
+	return get_sb_single(fs_type, flags, data, oprofilefs_fill_super);
+}
+
+
+static struct file_system_type oprofilefs_type = {
+	.owner		= THIS_MODULE,
+	.name		= "oprofilefs",
+	.get_sb		= oprofilefs_get_sb,
+	.kill_sb	= kill_litter_super,
+};
+#else
+static DECLARE_FSTYPE(oprofilefs_type, "oprofilefs", oprofilefs_fill_super, FS_SINGLE | FS_LITTER);
+#endif
+
+
+int __init oprofilefs_register(void)
+{
+	return register_filesystem(&oprofilefs_type);
+}
+
+
+void __exit oprofilefs_unregister(void)
+{
+	unregister_filesystem(&oprofilefs_type);
+}
diff -urNp linux-781/fs/Makefile linux-790/fs/Makefile
--- linux-781/fs/Makefile
+++ linux-790/fs/Makefile
@@ -7,7 +7,7 @@
 
 O_TARGET := fs.o
 
-export-objs :=	filesystems.o open.o dcache.o buffer.o dquot.o
+export-objs :=	filesystems.o open.o dcache.o buffer.o dquot.o dcookies.o
 mod-subdirs :=	nls
 
 obj-y :=	open.o read_write.o devices.o file_table.o buffer.o \
@@ -27,6 +27,8 @@ export-objs += aio.o
 subdir-$(CONFIG_PROC_FS)	+= proc
 subdir-y			+= partitions
 
+obj-$(CONFIG_PROFILING)		+= dcookies.o
+ 
 # Do not add any filesystems before this line
 subdir-$(CONFIG_EXT3_FS)	+= ext3    # Before ext2 so root fs can be ext3
 subdir-$(CONFIG_JBD)		+= jbd
diff -urNp linux-781/fs/dcache.c linux-790/fs/dcache.c
--- linux-781/fs/dcache.c
+++ linux-790/fs/dcache.c
@@ -616,6 +616,7 @@ struct dentry * d_alloc(struct dentry * 
 	dentry->d_op = NULL;
 	dentry->d_fsdata = NULL;
 	dentry->d_mounted = 0;
+	dentry->d_cookie = NULL;
 	INIT_LIST_HEAD(&dentry->d_hash);
 	INIT_LIST_HEAD(&dentry->d_lru);
 	INIT_LIST_HEAD(&dentry->d_subdirs);
diff -urNp linux-781/fs/dcookies.c linux-790/fs/dcookies.c
--- linux-781/fs/dcookies.c
+++ linux-790/fs/dcookies.c
@@ -0,0 +1,323 @@
+/*
+ * dcookies.c
+ *
+ * Copyright 2002 John Levon <levon@movementarian.org>
+ *
+ * Persistent cookie-path mappings. These are used by
+ * profilers to convert a per-task EIP value into something
+ * non-transitory that can be processed at a later date.
+ * This is done by locking the dentry/vfsmnt pair in the
+ * kernel until released by the tasks needing the persistent
+ * objects. The tag is simply an unsigned long that refers
+ * to the pair and can be looked up from userspace.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/mount.h>
+#include <linux/dcache.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/dcookies.h>
+#include <asm/uaccess.h>
+
+/* The dcookies are allocated from a kmem_cache and
+ * hashed onto a small number of lists. None of the
+ * code here is particularly performance critical
+ */
+struct dcookie_struct {
+	struct dentry * dentry;
+	struct vfsmount * vfsmnt;
+	struct list_head hash_list;
+};
+
+static LIST_HEAD(dcookie_users);
+static DECLARE_MUTEX(dcookie_sem);
+static kmem_cache_t * dcookie_cache;
+static struct list_head * dcookie_hashtable;
+static size_t hash_size;
+
+static inline int is_live(void)
+{
+	return !(list_empty(&dcookie_users));
+}
+
+
+/* The dentry is locked, its address will do for the cookie */
+static inline unsigned long dcookie_value(struct dcookie_struct * dcs)
+{
+	return (unsigned long)dcs->dentry;
+}
+
+
+static size_t dcookie_hash(unsigned long dcookie)
+{
+	return (dcookie >> L1_CACHE_SHIFT) & (hash_size - 1);
+}
+
+
+static struct dcookie_struct * find_dcookie(unsigned long dcookie)
+{
+	struct dcookie_struct * found = 0;
+	struct dcookie_struct * dcs;
+	struct list_head * pos;
+	struct list_head * list;
+
+	list = dcookie_hashtable + dcookie_hash(dcookie);
+
+	list_for_each(pos, list) {
+		dcs = list_entry(pos, struct dcookie_struct, hash_list);
+		if (dcookie_value(dcs) == dcookie) {
+			found = dcs;
+			break;
+		}
+	}
+
+	return found;
+}
+
+
+static void hash_dcookie(struct dcookie_struct * dcs)
+{
+	struct list_head * list = dcookie_hashtable + dcookie_hash(dcookie_value(dcs));
+	list_add(&dcs->hash_list, list);
+}
+
+
+static struct dcookie_struct * alloc_dcookie(struct dentry * dentry,
+	struct vfsmount * vfsmnt)
+{
+	struct dcookie_struct * dcs = kmem_cache_alloc(dcookie_cache, GFP_KERNEL);
+	if (!dcs)
+		return NULL;
+
+	atomic_inc(&dentry->d_count);
+	atomic_inc(&vfsmnt->mnt_count);
+	dentry->d_cookie = dcs;
+
+	dcs->dentry = dentry;
+	dcs->vfsmnt = vfsmnt;
+	hash_dcookie(dcs);
+
+	return dcs;
+}
+
+
+/* This is the main kernel-side routine that retrieves the cookie
+ * value for a dentry/vfsmnt pair.
+ */
+int get_dcookie(struct dentry * dentry, struct vfsmount * vfsmnt,
+	unsigned long * cookie)
+{
+	int err = 0;
+	struct dcookie_struct * dcs;
+
+	down(&dcookie_sem);
+
+	if (!is_live()) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	dcs = dentry->d_cookie;
+
+	if (!dcs)
+		dcs = alloc_dcookie(dentry, vfsmnt);
+
+	if (!dcs) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	*cookie = dcookie_value(dcs);
+
+out:
+	up(&dcookie_sem);
+	return err;
+}
+
+
+/* And here is where the userspace process can look up the cookie value
+ * to retrieve the path.
+ */
+asmlinkage int sys_lookup_dcookie(u64 cookie64, char * buf, size_t len)
+{
+	unsigned long cookie = (unsigned long)cookie64;
+	int err = -EINVAL;
+	char * kbuf;
+	char * path;
+	size_t pathlen;
+	struct dcookie_struct * dcs;
+
+	/* we could leak path information to users
+	 * without dir read permission without this
+	 */
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	down(&dcookie_sem);
+
+	if (!is_live()) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	if (!(dcs = find_dcookie(cookie)))
+		goto out;
+
+	err = -ENOMEM;
+	kbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!kbuf)
+		goto out;
+
+	/* FIXME: (deleted) ? */
+	path = d_path(dcs->dentry, dcs->vfsmnt, kbuf, PAGE_SIZE);
+
+	err = -ERANGE;
+
+	pathlen = kbuf + PAGE_SIZE - path;
+	if (pathlen <= len) {
+		err = pathlen;
+		if (copy_to_user(buf, path, pathlen))
+			err = -EFAULT;
+	}
+
+	kfree(kbuf);
+out:
+	up(&dcookie_sem);
+	return err;
+}
+
+
+static int dcookie_init(void)
+{
+	struct list_head * d;
+	unsigned int i, hash_bits;
+	int err = -ENOMEM;
+
+	dcookie_cache = kmem_cache_create("dcookie_cache",
+		sizeof(struct dcookie_struct),
+		0, 0, NULL, NULL);
+
+	if (!dcookie_cache)
+		goto out;
+
+	dcookie_hashtable = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!dcookie_hashtable)
+		goto out_kmem;
+
+	err = 0;
+
+	/*
+	 * Find the power-of-two list-heads that can fit into the allocation..
+	 * We don't guarantee that "sizeof(struct list_head)" is necessarily
+	 * a power-of-two.
+	 */
+	hash_size = PAGE_SIZE / sizeof(struct list_head);
+	hash_bits = 0;
+	do {
+		hash_bits++;
+	} while ((hash_size >> hash_bits) != 0);
+	hash_bits--;
+
+	/*
+	 * Re-calculate the actual number of entries and the mask
+	 * from the number of bits we can fit.
+	 */
+	hash_size = 1UL << hash_bits;
+
+	/* And initialize the newly allocated array */
+	d = dcookie_hashtable;
+	i = hash_size;
+	do {
+		INIT_LIST_HEAD(d);
+		d++;
+		i--;
+	} while (i);
+
+out:
+	return err;
+out_kmem:
+	kmem_cache_destroy(dcookie_cache);
+	goto out;
+}
+
+
+static void free_dcookie(struct dcookie_struct * dcs)
+{
+	dcs->dentry->d_cookie = NULL;
+	dput(dcs->dentry);
+	mntput(dcs->vfsmnt);
+	kmem_cache_free(dcookie_cache, dcs);
+}
+
+
+static void dcookie_exit(void)
+{
+	struct list_head * list;
+	struct list_head * pos;
+	struct list_head * pos2;
+	struct dcookie_struct * dcs;
+	size_t i;
+
+	for (i = 0; i < hash_size; ++i) {
+		list = dcookie_hashtable + i;
+		list_for_each_safe(pos, pos2, list) {
+			dcs = list_entry(pos, struct dcookie_struct, hash_list);
+			list_del(&dcs->hash_list);
+			free_dcookie(dcs);
+		}
+	}
+
+	kfree(dcookie_hashtable);
+	kmem_cache_destroy(dcookie_cache);
+}
+
+
+struct dcookie_user {
+	struct list_head next;
+};
+ 
+struct dcookie_user * dcookie_register(void)
+{
+	struct dcookie_user * user;
+
+	down(&dcookie_sem);
+
+	user = kmalloc(sizeof(struct dcookie_user), GFP_KERNEL);
+	if (!user)
+		goto out;
+
+	if (!is_live() && dcookie_init())
+		goto out_free;
+
+	list_add(&user->next, &dcookie_users);
+
+out:
+	up(&dcookie_sem);
+	return user;
+out_free:
+	kfree(user);
+	user = NULL;
+	goto out;
+}
+
+
+void dcookie_unregister(struct dcookie_user * user)
+{
+	down(&dcookie_sem);
+
+	list_del(&user->next);
+	kfree(user);
+
+	if (!is_live())
+		dcookie_exit();
+
+	up(&dcookie_sem);
+}
+
+EXPORT_SYMBOL_GPL(dcookie_register);
+EXPORT_SYMBOL_GPL(dcookie_unregister);
+EXPORT_SYMBOL_GPL(get_dcookie);
diff -urNp linux-781/fs/proc/proc_misc.c linux-790/fs/proc/proc_misc.c
--- linux-781/fs/proc/proc_misc.c
+++ linux-790/fs/proc/proc_misc.c
@@ -34,6 +34,7 @@
 #include <linux/signal.h>
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/profile.h>
 #include <linux/smp_lock.h>
 #include <linux/seq_file.h>
 #include <linux/sysrq.h>
diff -urNp linux-781/include/linux/dcache.h linux-790/include/linux/dcache.h
--- linux-781/include/linux/dcache.h
+++ linux-790/include/linux/dcache.h
@@ -65,6 +65,8 @@ static __inline__ unsigned int full_name
 /* XXX: check good value for 64bit */ 
 #define DNAME_INLINE_LEN 32
 
+struct dcookie_struct;
+ 
 struct dentry {
 	atomic_t d_count;
 	unsigned int d_flags;
@@ -83,6 +85,7 @@ struct dentry {
 	unsigned long d_vfs_flags;
 	void * d_fsdata;		/* fs-specific data */
 	unsigned char d_iname[DNAME_INLINE_LEN]; /* small names */
+	struct dcookie_struct * d_cookie; /* cookie, if any */
 };
 
 struct dentry_operations {
diff -urNp linux-781/include/linux/dcookies.h linux-790/include/linux/dcookies.h
--- linux-781/include/linux/dcookies.h
+++ linux-790/include/linux/dcookies.h
@@ -0,0 +1,69 @@
+/*
+ * dcookies.h
+ *
+ * Persistent cookie-path mappings
+ *
+ * Copyright 2002 John Levon <levon@movementarian.org>
+ */
+
+#ifndef DCOOKIES_H
+#define DCOOKIES_H
+ 
+#include <linux/config.h>
+
+#ifdef CONFIG_PROFILING
+ 
+#include <linux/types.h>
+ 
+struct dcookie_user;
+ 
+/**
+ * dcookie_register - register a user of dcookies
+ *
+ * Register as a dcookie user. Returns %NULL on failure.
+ */
+struct dcookie_user * dcookie_register(void);
+
+/**
+ * dcookie_unregister - unregister a user of dcookies
+ *
+ * Unregister as a dcookie user. This may invalidate
+ * any dcookie values returned from get_dcookie().
+ */
+void dcookie_unregister(struct dcookie_user * user);
+  
+/**
+ * get_dcookie - acquire a dcookie
+ *
+ * Convert the given dentry/vfsmount pair into
+ * a cookie value.
+ *
+ * Returns -EINVAL if no living task has registered as a
+ * dcookie user.
+ *
+ * Returns 0 on success, with *cookie filled in
+ */
+int get_dcookie(struct dentry * dentry, struct vfsmount * vfsmnt,
+	unsigned long * cookie);
+
+#else
+
+struct dcookie_user * dcookie_register(void)
+{
+	return 0;
+}
+
+void dcookie_unregister(struct dcookie_user * user)
+{
+	return;
+}
+ 
+static inline int get_dcookie(struct dentry * dentry,
+	struct vfsmount * vfsmnt, unsigned long * cookie)
+{
+	return -ENOSYS;
+} 
+ 
+#endif /* CONFIG_PROFILING */
+ 
+#endif /* DCOOKIES_H */
diff -urNp linux-781/include/linux/module.h linux-790/include/linux/module.h
--- linux-781/include/linux/module.h
+++ linux-790/include/linux/module.h
@@ -50,6 +50,13 @@ struct module_ref
 /* TBD */
 struct module_persist;
 
+enum module_state
+{
+	MODULE_STATE_LIVE,
+	MODULE_STATE_COMING,
+	MODULE_STATE_GOING,
+};
+
 struct module
 {
 	unsigned long size_of_struct;	/* == sizeof(module) */
@@ -412,4 +419,29 @@ __attribute__((section("__ksymtab"))) =	
 #define SET_MODULE_OWNER(some_struct) do { } while (0)
 #endif
 
+/*
+ * module load notification support
+ */
+
+struct notifier_block;
+
+#ifdef CONFIG_MODULES
+
+int register_module_notifier(struct notifier_block * nb);
+int unregister_module_notifier(struct notifier_block * nb);
+
+#else  /* !MODULE */
+
+static inline int register_module_notifier(struct notifier_block * nb)
+{
+	/* no events will happen anyway, so this can always succeed */
+	return 0;
+}
+
+static inline int unregister_module_notifier(struct notifier_block * nb)
+{
+	return 0;
+}
+#endif
+
 #endif /* _LINUX_MODULE_H */
diff -urNp linux-781/include/linux/oprofile.h linux-790/include/linux/oprofile.h
--- linux-781/include/linux/oprofile.h
+++ linux-790/include/linux/oprofile.h
@@ -0,0 +1,99 @@
+/**
+ * @file oprofile.h
+ *
+ * API for machine-specific interrupts to interface
+ * to oprofile.
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon <levon@movementarian.org>
+ */
+
+#ifndef OPROFILE_H
+#define OPROFILE_H
+
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <asm/atomic.h>
+ 
+struct super_block;
+struct dentry;
+struct file_operations;
+ 
+/* Operations structure to be filled in */
+struct oprofile_operations {
+	/* create any necessary configuration files in the oprofile fs.
+	 * Optional. */
+	int (*create_files)(struct super_block * sb, struct dentry * root);
+	/* Do any necessary interrupt setup. Optional. */
+	int (*setup)(void);
+	/* Do any necessary interrupt shutdown. Optional. */
+	void (*shutdown)(void);
+	/* Start delivering interrupts. */
+	int (*start)(void);
+	/* Stop delivering interrupts. */
+	void (*stop)(void);
+	/* CPU identification string. */
+	char * cpu_type;
+};
+
+/**
+ * One-time initialisation. *ops must be set to a filled-in
+ * operations structure.
+ * Return 0 on success.
+ */
+int oprofile_arch_init(struct oprofile_operations ** ops);
+ 
+/**
+ * Add a sample. This may be called from any context. Pass
+ * smp_processor_id() as cpu.
+ */
+extern void oprofile_add_sample(unsigned long eip, unsigned int is_kernel, 
+	unsigned long event, int cpu);
+
+/**
+ * Create a file of the given name as a child of the given root, with
+ * the specified file operations.
+ */
+int oprofilefs_create_file(struct super_block * sb, struct dentry * root,
+	char const * name, struct file_operations * fops);
+ 
+/** Create a file for read/write access to an unsigned long. */
+int oprofilefs_create_ulong(struct super_block * sb, struct dentry * root,
+	char const * name, ulong * val);
+ 
+/** Create a file for read-only access to an unsigned long. */
+int oprofilefs_create_ro_ulong(struct super_block * sb, struct dentry * root,
+	char const * name, ulong * val);
+ 
+/** Create a file for read-only access to an atomic_t. */
+int oprofilefs_create_ro_atomic(struct super_block * sb, struct dentry * root,
+	char const * name, atomic_t * val);
+ 
+/** create a directory */
+struct dentry * oprofilefs_mkdir(struct super_block * sb, struct dentry * root,
+	char const * name);
+
+/**
+ * Write the given asciz string to the given user buffer @buf, updating *offset
+ * appropriately. Returns bytes written or -EFAULT.
+ */
+ssize_t oprofilefs_str_to_user(char const * str, char * buf, size_t count, loff_t * offset);
+
+/**
+ * Convert an unsigned long value into ASCII and copy it to the user buffer @buf,
+ * updating *offset appropriately. Returns bytes written or -EFAULT.
+ */
+ssize_t oprofilefs_ulong_to_user(unsigned long * val, char * buf, size_t count, loff_t * offset);
+
+/**
+ * Read an ASCII string for a number from a userspace buffer and fill *val on success.
+ * Returns 0 on success, < 0 on error.
+ */
+int oprofilefs_ulong_from_user(unsigned long * val, char const * buf, size_t count);
+
+/** lock for read/write safety */
+extern spinlock_t oprofilefs_lock;
+ 
+#endif /* OPROFILE_H */
diff -urNp linux-781/include/linux/profile.h linux-790/include/linux/profile.h
--- linux-781/include/linux/profile.h
+++ linux-790/include/linux/profile.h
@@ -0,0 +1,86 @@
+#ifndef _LINUX_PROFILE_H
+#define _LINUX_PROFILE_H
+
+#ifdef __KERNEL__
+
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <asm/errno.h>
+
+/* parse command line */
+int __init profile_setup(char * str);
+ 
+/* init basic kernel profiler */
+void __init profile_init(void);
+
+extern unsigned int * prof_buffer;
+extern unsigned long prof_len;
+extern unsigned long prof_shift;
+extern int prof_on;
+
+
+enum profile_type {
+	EXIT_TASK,
+	EXIT_MMAP,
+	EXEC_UNMAP
+};
+
+#ifdef CONFIG_PROFILING
+
+struct notifier_block;
+struct task_struct;
+struct mm_struct;
+ 
+/* task is in do_exit() */
+void profile_exit_task(struct task_struct * task);
+
+/* change of vma mappings */
+void profile_exec_unmap(struct mm_struct * mm);
+
+/* exit of all vmas for a task */
+void profile_exit_mmap(struct mm_struct * mm);
+
+int profile_event_register(enum profile_type, struct notifier_block * n);
+
+int profile_event_unregister(enum profile_type, struct notifier_block * n);
+
+int register_profile_notifier(struct notifier_block * nb);
+int unregister_profile_notifier(struct notifier_block * nb);
+
+/* profiling hook activated on each timer interrupt */
+void profile_hook(struct pt_regs * regs);
+
+#else
+
+static inline int profile_event_register(enum profile_type t, struct notifier_block * n)
+{
+	return -ENOSYS;
+}
+
+static inline int profile_event_unregister(enum profile_type t, struct notifier_block * n)
+{
+	return -ENOSYS;
+}
+ 
+#define profile_exit_task(a) do { } while (0)
+#define profile_exec_unmap(a) do { } while (0)
+#define profile_exit_mmap(a) do { } while (0)
+
+static inline int register_profile_notifier(struct notifier_block * nb)
+{
+	return -ENOSYS;
+}
+
+static inline int unregister_profile_notifier(struct notifier_block * nb)
+{
+	return -ENOSYS;
+}
+
+#define profile_hook(regs) do { } while (0)
+
+#endif /* CONFIG_PROFILING */
+ 
+#endif /* __KERNEL__ */
+
+#endif /* _LINUX_PROFILE_H */
diff -urNp linux-781/include/linux/sched.h linux-790/include/linux/sched.h
--- linux-781/include/linux/sched.h
+++ linux-790/include/linux/sched.h
@@ -706,10 +706,6 @@ extern unsigned long itimer_next;
 extern struct timeval xtime;
 extern void do_timer(struct pt_regs *);
 
-extern unsigned int * prof_buffer;
-extern unsigned long prof_len;
-extern unsigned long prof_shift;
-
 #define CURRENT_TIME (xtime.tv_sec)
 
 extern int FASTCALL(wake_up_state(struct task_struct * tsk, unsigned int state));
diff -urNp linux-781/include/linux/smp.h linux-790/include/linux/smp.h
--- linux-781/include/linux/smp.h
+++ linux-790/include/linux/smp.h
@@ -7,6 +7,8 @@
  */
 
 #include <linux/config.h>
+#include <linux/kernel.h>  /* For BUG_ON(). */
+#include <asm/page.h>  /* Just for BUG(): ugh. */
 
 #ifdef CONFIG_SMP
 
@@ -51,6 +53,25 @@ extern int smp_call_function (void (*fun
 			      int retry, int wait);
 
 /*
+ * Call a function on all processors
+ */
+static inline int on_each_cpu(void (*func) (void *info), void *info,
+			      int retry, int wait)
+{
+	int ret = 0;
+
+#ifdef CONFIG_PREEMPT
+	preempt_disable();
+#endif
+	ret = smp_call_function(func, info, retry, wait);
+	func(info);
+#ifdef CONFIG_PREEMPT
+	preempt_enable();
+#endif
+	return ret;
+}
+
+/*
  * True once the per process idle is forked
  */
 extern int smp_threads_ready;
@@ -87,6 +108,8 @@ extern volatile int smp_msg_id;
 #define cpu_online(cpu)				({ BUG_ON((cpu) != 0); 1; })
 #define smp_call_function(func,info,retry,wait)	({ 0; })
 #define cpu_online_map				1
+#define cpu_possible(cpu)			({ BUG_ON((cpu) != 0); 1; })
+#define on_each_cpu(func,info,retry,wait)	({ func(info); 0; })
 static inline void smp_send_reschedule(int cpu) { }
 static inline void smp_send_reschedule_all(void) { }
 #endif
diff -urNp linux-781/include/linux/workqueue.h linux-790/include/linux/workqueue.h
--- linux-781/include/linux/workqueue.h
+++ linux-790/include/linux/workqueue.h
@@ -0,0 +1,65 @@
+/*
+ * workqueue.h --- linux/work queue handling for Linux.
+ */
+
+#ifndef _LINUX_WORKQUEUE_H
+#define _LINUX_WORKQUEUE_H
+
+#include <linux/timer.h>
+#include <linux/linkage.h>
+
+struct workqueue_struct;
+
+struct work_struct {
+	unsigned long pending;
+	struct list_head entry;
+	void (*func)(void *);
+	void *data;
+	void *wq_data;
+	struct timer_list timer;
+};
+
+#define __WORK_INITIALIZER(n, f, d) {				\
+        .entry	= { &(n).entry, &(n).entry },			\
+	.func = (f),						\
+	.data = (d) }
+
+#define DECLARE_WORK(n, f, d)					\
+	struct work_struct n = __WORK_INITIALIZER(n, f, d)
+
+/*
+ * initialize a work-struct's func and data pointers:
+ */
+#define PREPARE_WORK(_work, _func, _data)			\
+	do {							\
+		(_work)->func = _func;				\
+		(_work)->data = _data;				\
+	} while (0)
+
+/*
+ * initialize all of a work-struct:
+ */
+#define INIT_WORK(_work, _func, _data)				\
+	do {							\
+		INIT_LIST_HEAD(&(_work)->entry);		\
+		(_work)->pending = 0;				\
+		PREPARE_WORK((_work), (_func), (_data));	\
+		init_timer(&(_work)->timer);			\
+	} while (0)
+
+extern struct workqueue_struct *create_workqueue(const char *name);
+extern void destroy_workqueue(struct workqueue_struct *wq);
+
+extern int FASTCALL(queue_work(struct workqueue_struct *wq, struct work_struct *work));
+extern int FASTCALL(queue_delayed_work(struct workqueue_struct *wq, struct work_struct *work, unsigned long delay));
+extern void FASTCALL(flush_workqueue(struct workqueue_struct *wq));
+
+extern int FASTCALL(schedule_work(struct work_struct *work));
+extern int FASTCALL(schedule_delayed_work(struct work_struct *work, unsigned long delay));
+extern void flush_scheduled_work(void);
+extern int current_is_keventd(void);
+
+extern void init_workqueues(void);
+
+#endif
+
diff -urNp linux-781/init/main.c linux-790/init/main.c
--- linux-781/init/main.c
+++ linux-790/init/main.c
@@ -27,6 +27,7 @@
 #include <linux/iobuf.h>
 #include <linux/bootmem.h>
 #include <linux/tty.h>
+#include <linux/profile.h>
 
 #include <asm/io.h>
 #include <asm/bugs.h>
@@ -83,7 +84,6 @@ extern int irda_device_init(void);
 #error Sorry, your GCC is too old. It builds incorrect kernels.
 #endif
 
-extern char _stext, _etext;
 extern char *linux_banner;
 
 static int init(void *);
@@ -138,13 +138,6 @@ char *execute_command;
 static char * argv_init[MAX_INIT_ARGS+2] = { "init", NULL, };
 char * envp_init[MAX_INIT_ENVS+2] = { "HOME=/", "TERM=linux", NULL, };
 
-static int __init profile_setup(char *str)
-{
-    int par;
-    if (get_option(&str,&par)) prof_shift = par;
-	return 1;
-}
-
 __setup("profile=", profile_setup);
 
 static int __init checksetup(char *line)
@@ -376,16 +369,7 @@ asmlinkage void __init start_kernel(void
 #ifdef CONFIG_MODULES
 	init_modules();
 #endif
-	if (prof_shift) {
-		unsigned int size;
-		/* only text is profiled */
-		prof_len = (unsigned long) &_etext - (unsigned long) &_stext;
-		prof_len >>= prof_shift;
-		
-		size = prof_len * sizeof(unsigned int) + PAGE_SIZE-1;
-		prof_buffer = (unsigned int *) alloc_bootmem(size);
-	}
-
+	profile_init();
 	kmem_cache_init();
 	sti();
 	calibrate_delay();
diff -urNp linux-781/kernel/Makefile linux-790/kernel/Makefile
--- linux-781/kernel/Makefile
+++ linux-790/kernel/Makefile
@@ -9,9 +9,9 @@
 
 O_TARGET := kernel.o
 
-export-objs = signal.o sys.o kmod.o context.o ksyms.o pm.o exec_domain.o printk.o cpufreq.o
+export-objs = signal.o sys.o kmod.o context.o ksyms.o pm.o exec_domain.o printk.o cpufreq.o profile.o module.o
 
-obj-y     = sched.o dma.o fork.o exec_domain.o panic.o printk.o \
+obj-y     = sched.o dma.o fork.o exec_domain.o panic.o printk.o profile.o \
 	    module.o exit.o itimer.o info.o time.o softirq.o resource.o \
 	    sysctl.o acct.o capability.o ptrace.o timer.o user.o \
 	    signal.o sys.o kmod.o context.o \
diff -urNp linux-781/kernel/exit.c linux-790/kernel/exit.c
--- linux-781/kernel/exit.c
+++ linux-790/kernel/exit.c
@@ -22,6 +22,7 @@
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
+#include <linux/profile.h>
 #include <asm/mmu_context.h>
 
 extern void sem_exit (void);
@@ -666,6 +667,8 @@ NORET_TYPE void do_exit(long code)
 	if (unlikely(current->ptrace & PT_TRACE_EXIT))
 		ptrace_notify((PTRACE_EVENT_EXIT << 8) | SIGTRAP);
 
+	profile_exit_task(tsk);
+
 	acct_process(code);
 	__exit_mm(tsk);
 
diff -urNp linux-781/kernel/module.c linux-790/kernel/module.c
--- linux-781/kernel/module.c
+++ linux-790/kernel/module.c
@@ -2,6 +2,7 @@
 #include <linux/mm.h>
 #include <linux/module.h>
 #include <asm/module.h>
+#include <linux/notifier.h>
 #include <asm/uaccess.h>
 #include <linux/vmalloc.h>
 #include <linux/smp_lock.h>
@@ -57,6 +58,33 @@ struct module *module_list = &kernel_mod
 
 #endif	/* defined(CONFIG_MODULES) || defined(CONFIG_KALLSYMS) */
 
+/*
+ * module load notification support
+ */
+
+static DECLARE_MUTEX(notify_mutex);
+static struct notifier_block * module_notify_list;
+
+int register_module_notifier(struct notifier_block * nb)
+{
+	int err;
+	down(&notify_mutex);
+	err = notifier_chain_register(&module_notify_list, nb);
+	up(&notify_mutex);
+	return err;
+}
+EXPORT_SYMBOL(register_module_notifier);
+
+int unregister_module_notifier(struct notifier_block * nb)
+{
+	int err;
+	down(&notify_mutex);
+	err = notifier_chain_unregister(&module_notify_list, nb);
+	up(&notify_mutex);
+	return err;
+}
+EXPORT_SYMBOL(unregister_module_notifier);
+
 /* inter_module functions are always available, even when the kernel is
  * compiled without modules.  Consumers of inter_module_xxx routines
  * will always work, even when both are built into the kernel, this
@@ -557,6 +585,10 @@ sys_init_module(const char *name_user, s
 	put_mod_name(n_name);
 	put_mod_name(name);
 
+	down(&notify_mutex);
+	notifier_call_chain(&module_notify_list, MODULE_STATE_COMING, mod);
+	up(&notify_mutex);
+
 	/* Initialize the module.  */
 	atomic_set(&mod->uc.usecount,1);
 	mod->flags |= MOD_INITIALIZING;
diff -urNp linux-781/kernel/profile.c linux-790/kernel/profile.c
--- linux-781/kernel/profile.c
+++ linux-790/kernel/profile.c
@@ -0,0 +1,158 @@
+/*
+ *  linux/kernel/profile.c
+ */
+
+#include <linux/config.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/profile.h>
+#include <linux/bootmem.h>
+#include <linux/notifier.h>
+
+extern char _stext, _etext;
+
+unsigned int * prof_buffer;
+unsigned long prof_len;
+unsigned long prof_shift;
+int prof_on;
+
+int __init profile_setup(char * str)
+{
+	int par;
+	if (get_option(&str,&par)) {
+		prof_shift = par;
+		prof_on = 1;
+		printk(KERN_INFO "kernel profiling enabled\n");
+	}
+	return 1;
+}
+
+
+void __init profile_init(void)
+{
+	unsigned int size;
+ 
+	if (!prof_on) 
+		return;
+ 
+	/* only text is profiled */
+	prof_len = (unsigned long) &_etext - (unsigned long) &_stext;
+	prof_len >>= prof_shift;
+		
+	size = prof_len * sizeof(unsigned int) + PAGE_SIZE - 1;
+	prof_buffer = (unsigned int *) alloc_bootmem(size);
+}
+
+/* Profile event notifications */
+ 
+#ifdef CONFIG_PROFILING
+ 
+static DECLARE_RWSEM(profile_rwsem);
+static struct notifier_block * exit_task_notifier;
+static struct notifier_block * exit_mmap_notifier;
+static struct notifier_block * exec_unmap_notifier;
+ 
+void profile_exit_task(struct task_struct * task)
+{
+	down_read(&profile_rwsem);
+	notifier_call_chain(&exit_task_notifier, 0, task);
+	up_read(&profile_rwsem);
+}
+ 
+void profile_exit_mmap(struct mm_struct * mm)
+{
+	down_read(&profile_rwsem);
+	notifier_call_chain(&exit_mmap_notifier, 0, mm);
+	up_read(&profile_rwsem);
+}
+
+void profile_exec_unmap(struct mm_struct * mm)
+{
+	down_read(&profile_rwsem);
+	notifier_call_chain(&exec_unmap_notifier, 0, mm);
+	up_read(&profile_rwsem);
+}
+
+int profile_event_register(enum profile_type type, struct notifier_block * n)
+{
+	int err = -EINVAL;
+ 
+	down_write(&profile_rwsem);
+ 
+	switch (type) {
+		case EXIT_TASK:
+			err = notifier_chain_register(&exit_task_notifier, n);
+			break;
+		case EXIT_MMAP:
+			err = notifier_chain_register(&exit_mmap_notifier, n);
+			break;
+		case EXEC_UNMAP:
+			err = notifier_chain_register(&exec_unmap_notifier, n);
+			break;
+	}
+ 
+	up_write(&profile_rwsem);
+ 
+	return err;
+}
+
+ 
+int profile_event_unregister(enum profile_type type, struct notifier_block * n)
+{
+	int err = -EINVAL;
+ 
+	down_write(&profile_rwsem);
+ 
+	switch (type) {
+		case EXIT_TASK:
+			err = notifier_chain_unregister(&exit_task_notifier, n);
+			break;
+		case EXIT_MMAP:
+			err = notifier_chain_unregister(&exit_mmap_notifier, n);
+			break;
+		case EXEC_UNMAP:
+			err = notifier_chain_unregister(&exec_unmap_notifier, n);
+			break;
+	}
+
+	up_write(&profile_rwsem);
+	return err;
+}
+
+static struct notifier_block * profile_listeners;
+static rwlock_t profile_lock = RW_LOCK_UNLOCKED;
+ 
+int register_profile_notifier(struct notifier_block * nb)
+{
+	int err;
+	write_lock_irq(&profile_lock);
+	err = notifier_chain_register(&profile_listeners, nb);
+	write_unlock_irq(&profile_lock);
+	return err;
+}
+
+
+int unregister_profile_notifier(struct notifier_block * nb)
+{
+	int err;
+	write_lock_irq(&profile_lock);
+	err = notifier_chain_unregister(&profile_listeners, nb);
+	write_unlock_irq(&profile_lock);
+	return err;
+}
+
+
+void profile_hook(struct pt_regs * regs)
+{
+	read_lock(&profile_lock);
+	notifier_call_chain(&profile_listeners, 0, regs);
+	read_unlock(&profile_lock);
+}
+
+EXPORT_SYMBOL_GPL(register_profile_notifier);
+EXPORT_SYMBOL_GPL(unregister_profile_notifier);
+
+#endif /* CONFIG_PROFILING */
+
+EXPORT_SYMBOL_GPL(profile_event_register);
+EXPORT_SYMBOL_GPL(profile_event_unregister);
diff -urNp linux-781/kernel/sys.c linux-790/kernel/sys.c
--- linux-781/kernel/sys.c
+++ linux-790/kernel/sys.c
@@ -15,6 +15,7 @@
 #include <linux/prctl.h>
 #include <linux/init.h>
 #include <linux/highuid.h>
+#include <linux/dcookies.h>
 #include <linux/fs.h>
 #include <linux/times.h>
 
@@ -176,6 +177,13 @@ int register_reboot_notifier(struct noti
 	return notifier_chain_register(&reboot_notifier_list, nb);
 }
 
+ #if !defined(CONFIG_PROFILING)
+ long asmlinkage sys_lookup_dcookie(void)
+ {
+ 	return -ENOSYS;
+ }
+ #endif
+
 /**
  *	unregister_reboot_notifier - Unregister previously registered reboot notifier
  *	@nb: Hook to be unregistered
diff -urNp linux-781/kernel/timer.c linux-790/kernel/timer.c
--- linux-781/kernel/timer.c
+++ linux-790/kernel/timer.c
@@ -69,10 +69,6 @@ extern int do_setitimer(int, struct itim
 
 unsigned long volatile jiffies;
 
-unsigned int * prof_buffer;
-unsigned long prof_len;
-unsigned long prof_shift;
-
 /*
  * Event timer code
  */
diff -urNp linux-781/mm/mmap.c linux-790/mm/mmap.c
--- linux-781/mm/mmap.c
+++ linux-790/mm/mmap.c
@@ -32,6 +32,7 @@
 #include <linux/fs.h>
 #include <linux/personality.h>
 #include <linux/compiler.h>
+#include <linux/profile.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgalloc.h>
@@ -1155,6 +1156,10 @@ int do_munmap(struct mm_struct *mm, unsi
 	    && mm->map_count >= max_map_count)
 		return -ENOMEM;
 
+	/* Something will probably happen, so notify. */
+	if (mpnt->vm_file && (mpnt->vm_flags & VM_EXEC))
+		profile_exec_unmap(mm);
+ 
 	/*
 	 * We may need one additional vma to fix up the mappings ... 
 	 * and this is the last chance for an easy error exit.
@@ -1345,7 +1350,10 @@ void exit_mmap(struct mm_struct * mm)
 {
 	struct vm_area_struct * mpnt;
 
+	profile_exit_mmap(mm);
+ 
 	release_segments(mm);
+ 
 	spin_lock(&mm->page_table_lock);
 	mpnt = mm->mmap;
 	mm->mmap = mm->mmap_cache = NULL;
