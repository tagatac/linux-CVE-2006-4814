diff -urNp linux-211/arch/i386/kernel/i387.c linux-212/arch/i386/kernel/i387.c
--- linux-211/arch/i386/kernel/i387.c
+++ linux-212/arch/i386/kernel/i387.c
@@ -70,8 +70,12 @@ void init_fpu(void)
 static inline void __save_init_fpu( struct task_struct *tsk )
 {
 	if ( cpu_has_fxsr ) {
-		asm volatile( "fxsave %0 ; fnclex"
+		asm volatile( "fxsave %0"
 			      : "=m" (tsk->thread.i387.fxsave) );
+		if (tsk->thread.i387.fxsave.swd & (1<<7))
+			asm volatile("fnclex");
+		/* AMD CPUs leak F?P. Clear it here */
+		asm volatile("ffree %%st(7) ; fildl %0" :: "m" (tsk->flags));
 	} else {
 		asm volatile( "fnsave %0 ; fwait"
 			      : "=m" (tsk->thread.i387.fsave) );
diff -urNp linux-211/arch/x86_64/kernel/process.c linux-212/arch/x86_64/kernel/process.c
--- linux-211/arch/x86_64/kernel/process.c
+++ linux-212/arch/x86_64/kernel/process.c
@@ -637,8 +637,6 @@ struct task_struct *__switch_to(struct t
 
 	/* never put a printk in __switch_to... printk() calls wake_up*() indirectly */
 
-	unlazy_fpu(prev_p);
-
 	/*
 	 * Reload rsp0, LDT and the page table pointer:
 	 */
@@ -658,6 +656,11 @@ struct task_struct *__switch_to(struct t
 	load_TLS(next, cpu);
 
 	/* 
+  	 * Must be after DS reload for AMD workaround.
+	 */
+	unlazy_fpu(prev_p);
+
+	/* 
 	 * Switch FS and GS.
 	 */
 	{ 
diff -urNp linux-211/include/asm-i386/i387.h linux-212/include/asm-i386/i387.h
--- linux-211/include/asm-i386/i387.h
+++ linux-212/include/asm-i386/i387.h
@@ -32,9 +32,16 @@ extern void kernel_fpu_begin(void);
 		save_init_fpu( tsk ); \
 } while (0)
 
+/*
+ * There might be some pending exceptions in the FP state at this point.
+ * However, it is too late to report them: this code is called during execve()
+ * (when the original executable is already gone) and during sigreturn() (when
+ * the signal handler context is already lost).  So just clear them to prevent
+ * problems later.
+ */
 #define clear_fpu( tsk ) do { \
 	if ( tsk->flags & PF_USEDFPU ) { \
-		asm volatile("fwait"); \
+		asm volatile("fnclex; fwait"); \
 		tsk->flags &= ~PF_USEDFPU; \
 		stts(); \
 	} \
diff -urNp linux-211/include/asm-x86_64/i387.h linux-212/include/asm-x86_64/i387.h
--- linux-211/include/asm-x86_64/i387.h
+++ linux-212/include/asm-x86_64/i387.h
@@ -32,9 +32,16 @@ extern int save_i387(struct _fpstate *bu
 		save_init_fpu( tsk ); \
 } while (0)
 
+/*
+ * There might be some pending exceptions in the FP state at this point.
+ * However, it is too late to report them: this code is called during execve()
+ * (when the original executable is already gone) and during sigreturn() (when
+ * the signal handler context is already lost).  So just clear them to prevent
+ * problems later.
+ */
 #define clear_fpu( tsk ) do { \
 	if ( tsk->flags & PF_USEDFPU ) { \
-		asm volatile("fwait"); \
+		asm volatile("fnclex; fwait"); \
 		tsk->flags &= ~PF_USEDFPU; \
 		stts(); \
 	} \
@@ -119,8 +126,12 @@ static inline void kernel_fpu_begin(void
 
 static inline void save_init_fpu( struct task_struct *tsk )
 {
-	asm volatile( "rex64; fxsave %0 ; fnclex"
+	asm volatile( "rex64; fxsave %0"
 		      : "=m" (tsk->thread.i387.fxsave));
+	if (tsk->thread.i387.fxsave.swd & (1<<7))
+		asm volatile("fnclex");
+	/* AMD CPUs leak F?P through FXSAVE. Clear it here */
+	asm volatile("ffree %%st(7) ; fildl %0" :: "m" (tsk->flags));
 	tsk->flags &= ~PF_USEDFPU;
 	stts();
 }
