diff -urNp linux-5178/arch/ia64/kernel/ia64_ksyms.c linux-5179/arch/ia64/kernel/ia64_ksyms.c
--- linux-5178/arch/ia64/kernel/ia64_ksyms.c
+++ linux-5179/arch/ia64/kernel/ia64_ksyms.c
@@ -197,6 +197,9 @@ EXPORT_SYMBOL(unw_init_running);
 extern unsigned long next_ram_page(unsigned long);
 EXPORT_SYMBOL_GPL(next_ram_page);
 
+extern int init_dump;
+EXPORT_SYMBOL(init_dump);
+
 EXPORT_SYMBOL_GPL(show_mem);
 EXPORT_SYMBOL_GPL(show_state);
 EXPORT_SYMBOL_GPL(show_regs);
diff -urNp linux-5178/arch/ia64/kernel/mca.c linux-5179/arch/ia64/kernel/mca.c
--- linux-5178/arch/ia64/kernel/mca.c
+++ linux-5179/arch/ia64/kernel/mca.c
@@ -74,6 +74,7 @@
 
 #include <asm/irq.h>
 #include <asm/hw_irq.h>
+#include <asm/diskdump.h>
 
 #if defined(IA64_MCA_DEBUG_INFO)
 # define IA64_MCA_DEBUG(fmt...)	printk(fmt)
@@ -92,17 +93,19 @@ typedef struct ia64_fptr {
 
 /* Used by mca_asm.S */
 ia64_mca_sal_to_os_state_t	ia64_sal_to_os_handoff_state;
+ia64_mca_sal_to_os_state_t	ia64_sal_to_os_handoff_state_init[NR_CPUS];
+u64				ia64_sal_to_os_handoff_state_addr[NR_CPUS];
 ia64_mca_os_to_sal_state_t	ia64_os_to_sal_handoff_state;
 u64				ia64_mca_proc_state_dump[512];
 u64				ia64_mca_stack[1024] __attribute__((aligned(16)));
 u64				ia64_mca_stackframe[32];
 u64				ia64_mca_bspstore[1024];
-u64				ia64_init_stack[INIT_TASK_SIZE/8] __attribute__((aligned(16)));
+u64				ia64_init_stack[NR_CPUS*INIT_TASK_SIZE/8] __attribute__((aligned(16)));
+u64				ia64_init_stack_addr[NR_CPUS];
 u64				ia64_mca_serialize;
 
 /* In mca_asm.S */
 extern void			ia64_monarch_init_handler (void);
-extern void			ia64_slave_init_handler (void);
 
 static ia64_mc_info_t		ia64_mc_info;
 
@@ -429,6 +432,10 @@ fetch_min_state (pal_min_state_area_t *m
 	PUT_NAT_BIT(sw->caller_unat, &pt->r30);	PUT_NAT_BIT(sw->caller_unat, &pt->r31);
 }
 
+int init_dump = 0;
+static spinlock_t init_dump_lock = SPIN_LOCK_UNLOCKED;
+static spinlock_t show_stack_lock = SPIN_LOCK_UNLOCKED;
+
 static void
 init_handler_platform (pal_min_state_area_t *ms,
 		       struct pt_regs *pt, struct switch_stack *sw)
@@ -445,12 +452,23 @@ init_handler_platform (pal_min_state_are
 	 */
 	printk("Delaying for 5 seconds...\n");
 	udelay(5*1000000);
+	spin_lock(&show_stack_lock);
 	show_min_state(ms);
 
 	printk("Backtrace of current task (pid %d, %s)\n", current->pid, current->comm);
 	fetch_min_state(ms, pt, sw);
 	unw_init_from_interruption(&info, current, pt, sw);
 	ia64_do_show_stack(&info, NULL);
+	spin_unlock(&show_stack_lock);
+
+	if (netdump_func || diskdump_func)
+		init_dump = 1;
+	if (init_dump) {
+		if (spin_trylock(&init_dump_lock))
+			try_crashdump(pt);
+		else
+			unw_init_running(ia64_freeze_cpu, NULL);
+	}
 
 #ifdef CONFIG_SMP
 	/* read_trylock() would be handy... */
@@ -1065,21 +1083,25 @@ ia64_mca_cpe_poll (unsigned long dummy)
 void
 ia64_init_handler (struct pt_regs *pt, struct switch_stack *sw)
 {
+	ia64_mca_sal_to_os_state_t *state;
 	pal_min_state_area_t *ms;
 
 	oops_in_progress = 1;	/* avoid deadlock in printk, but it makes recovery dodgy */
+	bust_spinlocks(1);
 
+	state = &ia64_sal_to_os_handoff_state_init[smp_processor_id()];
 	printk(KERN_INFO "Entered OS INIT handler. PSP=%lx\n",
-		ia64_sal_to_os_handoff_state.proc_state_param);
+		state->proc_state_param);
 
 	/*
 	 * Address of minstate area provided by PAL is physical,
 	 * uncacheable (bit 63 set). Convert to Linux virtual
 	 * address in region 6.
 	 */
-	ms = (pal_min_state_area_t *)(ia64_sal_to_os_handoff_state.pal_min_state | (6ul<<61));
+	ms = (pal_min_state_area_t *)(state->pal_min_state | (6ul<<61));
 
 	init_handler_platform(ms, pt, sw);	/* call platform specific routines */
+	bust_spinlocks(0);
 }
 
 static int __init
@@ -1153,7 +1175,7 @@ void __init
 ia64_mca_init(void)
 {
 	ia64_fptr_t *mon_init_ptr = (ia64_fptr_t *)ia64_monarch_init_handler;
-	ia64_fptr_t *slave_init_ptr = (ia64_fptr_t *)ia64_slave_init_handler;
+	ia64_fptr_t *slave_init_ptr = (ia64_fptr_t *)ia64_monarch_init_handler;
 	ia64_fptr_t *mca_hldlr_ptr = (ia64_fptr_t *)ia64_os_mca_dispatch;
 	int i;
 	s64 rc;
@@ -1256,6 +1278,15 @@ ia64_mca_init(void)
 		return;
 	}
 
+	/* Register stack for os init handler */
+	for(i = 0 ; i < NR_CPUS; i++) {
+		ia64_init_stack_addr[i] =
+			(u64)&ia64_init_stack[i*INIT_TASK_SIZE/8];
+
+		ia64_sal_to_os_handoff_state_addr[i] =
+			ia64_tpa(&ia64_sal_to_os_handoff_state_init[i]);
+	}
+
 	IA64_MCA_DEBUG("%s: registered OS INIT handler with SAL\n", __FUNCTION__);
 
 	/*
diff -urNp linux-5178/arch/ia64/kernel/mca_asm.S linux-5179/arch/ia64/kernel/mca_asm.S
--- linux-5178/arch/ia64/kernel/mca_asm.S
+++ linux-5179/arch/ia64/kernel/mca_asm.S
@@ -57,6 +57,23 @@
 	st8	[_tmp]=r17,0x08;;			\
 	st8	[_tmp]=r18,0x08
 
+#define SAL_TO_OS_MCA_HANDOFF_STATE_SAVE_INIT(_tmp1, _tmp2)	\
+	movl	_tmp1=ia64_sal_to_os_handoff_state_addr;;	\
+	DATA_VA_TO_PA(_tmp1);;					\
+	mov	_tmp2=IA64_KR(CURRENT);;			\
+	adds	_tmp2=IA64_TASK_CPU_OFFSET,_tmp2;;		\
+	ld4	_tmp2=[_tmp2];;					\
+	shladd	_tmp2=_tmp2,3,_tmp1;;				\
+	ld8	_tmp1=[_tmp2];;					\
+	st8	[_tmp1]=r1,0x08;;			\
+	st8	[_tmp1]=r8,0x08;;			\
+	st8	[_tmp1]=r9,0x08;;			\
+	st8	[_tmp1]=r10,0x08;;			\
+	st8	[_tmp1]=r11,0x08;;			\
+	st8	[_tmp1]=r12,0x08;;			\
+	st8	[_tmp1]=r17,0x08;;			\
+	st8	[_tmp1]=r18,0x08
+
 /*
  * OS_MCA_TO_SAL_HANDOFF_STATE (SAL 3.0 spec)
  * (p6) is executed if we never entered virtual mode (TLB error)
@@ -102,12 +119,14 @@
 	.global ia64_os_mca_dispatch
 	.global ia64_os_mca_dispatch_end
 	.global ia64_sal_to_os_handoff_state
+	.global ia64_sal_to_os_handoff_state_addr
 	.global	ia64_os_to_sal_handoff_state
 	.global	ia64_mca_proc_state_dump
 	.global	ia64_mca_stack
 	.global	ia64_mca_stackframe
 	.global	ia64_mca_bspstore
 	.global ia64_init_stack
+	.global ia64_init_stack_addr
 
 	.text
 	.align 16
@@ -868,7 +887,7 @@ end_os_mca_restore:
 GLOBAL_ENTRY(ia64_monarch_init_handler)
 
 	// stash the information the SAL passed to os
-	SAL_TO_OS_MCA_HANDOFF_STATE_SAVE(r2)
+	SAL_TO_OS_MCA_HANDOFF_STATE_SAVE_INIT(r2, r16)
 	;;
 	SAVE_MIN_WITH_COVER
 	;;
@@ -913,13 +932,3 @@ IVirtual_Switch:
 return_from_init:
 	br.sptk return_from_init
 END(ia64_monarch_init_handler)
-
-//
-// SAL to OS entry point for INIT on the slave processor
-// This has been defined for registration purposes with SAL
-// as a part of ia64_mca_init.
-//
-
-GLOBAL_ENTRY(ia64_slave_init_handler)
-1:	br.sptk 1b
-END(ia64_slave_init_handler)
diff -urNp linux-5178/arch/ia64/kernel/minstate.h linux-5179/arch/ia64/kernel/minstate.h
--- linux-5178/arch/ia64/kernel/minstate.h
+++ linux-5179/arch/ia64/kernel/minstate.h
@@ -54,7 +54,13 @@
  * go virtual and dont want to destroy the iip or ipsr.
  */
 #define MINSTATE_START_SAVE_MIN_PHYS								\
-(pKern) movl sp=ia64_init_stack+IA64_STK_OFFSET-IA64_PT_REGS_SIZE;				\
+(pKern) adds r16=IA64_TASK_CPU_OFFSET,r1;;	/* current->cpu */				\
+(pKern) ld4 r16=[r16];				/* smp_processor_id */				\
+(pKern) movl r1=ia64_init_stack_addr;;								\
+(pKern) shladd r1=r16,3,r1;;			/* ia64_init_stack_addr[cpu] */			\
+(pKern) dep r16=0,r1,61,3;;			/* compute physical addr */			\
+(pKern) ld8 r1=[r16];;				/* ia64_init_stack[cpu] */ 			\
+(pKern) addl sp=IA64_STK_OFFSET-IA64_PT_REGS_SIZE,r1;;						\
 (pUser)	mov ar.rsc=0;		/* set enforced lazy mode, pl 0, little-endian, loadrs=0 */	\
 (pUser)	addl rKRBS=IA64_RBS_OFFSET,r1;		/* compute base of register backing store */	\
 	;;											\
diff -urNp linux-5178/arch/ia64/kernel/process.c linux-5179/arch/ia64/kernel/process.c
--- linux-5178/arch/ia64/kernel/process.c
+++ linux-5179/arch/ia64/kernel/process.c
@@ -716,10 +716,7 @@ machine_power_off (void)
 void
 ia64_freeze_cpu (struct unw_frame_info *info, void *arg)
 {
-	struct switch_stack **dst = arg;
-
 	current->thread.ksp = (__u64)info->sw - 16;
-	*dst = info->sw;
 	for (;;) __cli();
 }
 
diff -urNp linux-5178/arch/ia64/tools/print_offsets.c linux-5179/arch/ia64/tools/print_offsets.c
--- linux-5178/arch/ia64/tools/print_offsets.c
+++ linux-5179/arch/ia64/tools/print_offsets.c
@@ -66,6 +66,7 @@ tab[] =
 #endif
     { "IA64_TASK_PID_OFFSET",		offsetof (struct task_struct, pid) },
     { "IA64_TASK_MM_OFFSET",		offsetof (struct task_struct, mm) },
+    { "IA64_TASK_CPU_OFFSET",		offsetof (struct task_struct, cpu) },
     { "IA64_PT_REGS_CR_IPSR_OFFSET",	offsetof (struct pt_regs, cr_ipsr) },
     { "IA64_PT_REGS_CR_IIP_OFFSET",	offsetof (struct pt_regs, cr_iip) },
     { "IA64_PT_REGS_CR_IFS_OFFSET",	offsetof (struct pt_regs, cr_ifs) },
diff -urNp linux-5178/include/asm-ia64/diskdump.h linux-5179/include/asm-ia64/diskdump.h
--- linux-5178/include/asm-ia64/diskdump.h
+++ linux-5179/include/asm-ia64/diskdump.h
@@ -53,18 +53,18 @@ struct disk_dump_sub_header {
 #define size_of_sub_header()	((sizeof(struct disk_dump_sub_header) + PAGE_SIZE - 1) / DUMP_BLOCK_SIZE)
 
 #define write_sub_header() \
-({								\
- 	int ret;						\
-	struct unw_frame_info *info = platform_arg;		\
-								\
-	ia64_do_copy_regs(info, &dump_sub_header.elf_regs);	\
-	dump_sub_header.sw[smp_processor_id()] = info->sw;	\
-	clear_page(scratch);					\
-	memcpy(scratch, &dump_sub_header, sizeof(dump_sub_header));\
- 								\
-	if ((ret = write_blocks(dump_part, 2, scratch, 1)) >= 0)\
-		ret = 1; /* size of sub header in page */;	\
-	ret;							\
+({									\
+ 	int ret;							\
+	struct unw_frame_info *info = platform_arg;			\
+									\
+	ia64_do_copy_regs(info, &dump_sub_header.elf_regs);		\
+	dump_sub_header.sw[smp_processor_id()] = info->sw;		\
+	clear_page(scratch);						\
+	memcpy(scratch, &dump_sub_header, sizeof(dump_sub_header));	\
+ 									\
+	if ((ret = write_blocks(dump_part, 2, scratch, 1)) >= 0)	\
+		ret = 1; /* size of sub header in page */;		\
+	ret;								\
 })
 
 #define platform_freeze_cpu() 					\
diff -urNp linux-5178/include/asm-ia64/mca.h linux-5179/include/asm-ia64/mca.h
--- linux-5178/include/asm-ia64/mca.h
+++ linux-5179/include/asm-ia64/mca.h
@@ -109,7 +109,6 @@ extern void ia64_os_mca_dispatch(void);
 extern void ia64_os_mca_dispatch_end(void);
 extern void ia64_mca_ucmc_handler(void);
 extern void ia64_monarch_init_handler(void);
-extern void ia64_slave_init_handler(void);
 extern void ia64_mca_cmc_vector_setup(void);
 extern int  ia64_mca_check_errors(void);
 
